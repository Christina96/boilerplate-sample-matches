<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for version.py &amp; gitfs_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for version.py &amp; gitfs_1.py
      </h3>
<h1 align="center">
        0.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>version.py (0.7707129%)<th>gitfs_1.py (0.26472536%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(679-688)<td><a href="#" name="0">(1355-1362)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>version.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import operator
2 import platform
3 import re
4 import sys
5 from collections import namedtuple
6 from functools import total_ordering
7 MAX_SIZE = sys.maxsize
8 VERSION_LIMIT = MAX_SIZE - 200
9 @total_ordering
10 class SaltVersion(namedtuple("SaltVersion", "name, info, released")):
11     __slots__ = ()
12     def __new__(cls, name, info, released=False):
13         if isinstance(info, int):
14             info = (info,)
15         return super().__new__(cls, name, info, released)
16     def __eq__(self, other):
17         return self.info == other.info
18     def __gt__(self, other):
19         return self.info &gt; other.info
20 class SaltVersionsInfo(type):
21     _sorted_versions = ()
22     _current_release = None
23     _previous_release = None
24     _next_release = None
25     HYDROGEN      = SaltVersion("Hydrogen"     , info=(2014, 1),  released=True)
26     HELIUM        = SaltVersion("Helium"       , info=(2014, 7),  released=True)
27     LITHIUM       = SaltVersion("Lithium"      , info=(2015, 5),  released=True)
28     BERYLLIUM     = SaltVersion("Beryllium"    , info=(2015, 8),  released=True)
29     BORON         = SaltVersion("Boron"        , info=(2016, 3),  released=True)
30     CARBON        = SaltVersion("Carbon"       , info=(2016, 11), released=True)
31     NITROGEN      = SaltVersion("Nitrogen"     , info=(2017, 7),  released=True)
32     OXYGEN        = SaltVersion("Oxygen"       , info=(2018, 3),  released=True)
33     FLUORINE      = SaltVersion("Fluorine"     , info=(2019, 2),  released=True)
34     NEON          = SaltVersion("Neon"         , info=3000,       released=True)
35     SODIUM        = SaltVersion("Sodium"       , info=3001,       released=True)
36     MAGNESIUM     = SaltVersion("Magnesium"    , info=3002,       released=True)
37     ALUMINIUM     = SaltVersion("Aluminium"    , info=3003,       released=True)
38     SILICON       = SaltVersion("Silicon"      , info=3004,       released=True)
39     PHOSPHORUS    = SaltVersion("Phosphorus"   , info=3005)
40     SULFUR        = SaltVersion("Sulfur"       , info=3006)
41     CHLORINE      = SaltVersion("Chlorine"     , info=3007)
42     ARGON         = SaltVersion("Argon"        , info=3008)
43     POTASSIUM     = SaltVersion("Potassium"    , info=3009)
44     CALCIUM       = SaltVersion("Calcium"      , info=3010)
45     SCANDIUM      = SaltVersion("Scandium"     , info=3011)
46     TITANIUM      = SaltVersion("Titanium"     , info=3012)
47     VANADIUM      = SaltVersion("Vanadium"     , info=3013)
48     CHROMIUM      = SaltVersion("Chromium"     , info=3014)
49     MANGANESE     = SaltVersion("Manganese"    , info=3015)
50     IRON          = SaltVersion("Iron"         , info=3016)
51     COBALT        = SaltVersion("Cobalt"       , info=3017)
52     NICKEL        = SaltVersion("Nickel"       , info=3018)
53     COPPER        = SaltVersion("Copper"       , info=3019)
54     ZINC          = SaltVersion("Zinc"         , info=3020)
55     GALLIUM       = SaltVersion("Gallium"      , info=3021)
56     GERMANIUM     = SaltVersion("Germanium"    , info=3022)
57     ARSENIC       = SaltVersion("Arsenic"      , info=3023)
58     SELENIUM      = SaltVersion("Selenium"     , info=3024)
59     BROMINE       = SaltVersion("Bromine"      , info=3025)
60     KRYPTON       = SaltVersion("Krypton"      , info=3026)
61     RUBIDIUM      = SaltVersion("Rubidium"     , info=3027)
62     STRONTIUM     = SaltVersion("Strontium"    , info=3028)
63     YTTRIUM       = SaltVersion("Yttrium"      , info=3029)
64     ZIRCONIUM     = SaltVersion("Zirconium"    , info=3030)
65     NIOBIUM       = SaltVersion("Niobium"      , info=3031)
66     MOLYBDENUM    = SaltVersion("Molybdenum"   , info=3032)
67     TECHNETIUM    = SaltVersion("Technetium"   , info=3033)
68     RUTHENIUM     = SaltVersion("Ruthenium"    , info=3034)
69     RHODIUM       = SaltVersion("Rhodium"      , info=3035)
70     PALLADIUM     = SaltVersion("Palladium"    , info=3036)
71     SILVER        = SaltVersion("Silver"       , info=3037)
72     CADMIUM       = SaltVersion("Cadmium"      , info=3038)
73     INDIUM        = SaltVersion("Indium"       , info=3039)
74     TIN           = SaltVersion("Tin"          , info=3040)
75     ANTIMONY      = SaltVersion("Antimony"     , info=3041)
76     TELLURIUM     = SaltVersion("Tellurium"    , info=3042)
77     IODINE        = SaltVersion("Iodine"       , info=3043)
78     XENON         = SaltVersion("Xenon"        , info=3044)
79     CESIUM        = SaltVersion("Cesium"       , info=3045)
80     BARIUM        = SaltVersion("Barium"       , info=3046)
81     LANTHANUM     = SaltVersion("Lanthanum"    , info=3047)
82     CERIUM        = SaltVersion("Cerium"       , info=3048)
83     PRASEODYMIUM  = SaltVersion("Praseodymium" , info=3049)
84     NEODYMIUM     = SaltVersion("Neodymium"    , info=3050)
85     PROMETHIUM    = SaltVersion("Promethium"   , info=3051)
86     SAMARIUM      = SaltVersion("Samarium"     , info=3052)
87     EUROPIUM      = SaltVersion("Europium"     , info=3053)
88     GADOLINIUM    = SaltVersion("Gadolinium"   , info=3054)
89     TERBIUM       = SaltVersion("Terbium"      , info=3055)
90     DYSPROSIUM    = SaltVersion("Dysprosium"   , info=3056)
91     HOLMIUM       = SaltVersion("Holmium"      , info=3057)
92     ERBIUM        = SaltVersion("Erbium"       , info=3058)
93     THULIUM       = SaltVersion("Thulium"      , info=3059)
94     YTTERBIUM     = SaltVersion("Ytterbium"    , info=3060)
95     LUTETIUM      = SaltVersion("Lutetium"     , info=3061)
96     HAFNIUM       = SaltVersion("Hafnium"      , info=3062)
97     TANTALUM      = SaltVersion("Tantalum"     , info=3063)
98     TUNGSTEN      = SaltVersion("Tungsten"     , info=3064)
99     RHENIUM       = SaltVersion("Rhenium"      , info=3065)
100     OSMIUM        = SaltVersion("Osmium"       , info=3066)
101     IRIDIUM       = SaltVersion("Iridium"      , info=3067)
102     PLATINUM      = SaltVersion("Platinum"     , info=3068)
103     GOLD          = SaltVersion("Gold"         , info=3069)
104     MERCURY       = SaltVersion("Mercury"      , info=3070)
105     THALLIUM      = SaltVersion("Thallium"     , info=3071)
106     LEAD          = SaltVersion("Lead"         , info=3072)
107     BISMUTH       = SaltVersion("Bismuth"      , info=3073)
108     POLONIUM      = SaltVersion("Polonium"     , info=3074)
109     ASTATINE      = SaltVersion("Astatine"     , info=3075)
110     RADON         = SaltVersion("Radon"        , info=3076)
111     FRANCIUM      = SaltVersion("Francium"     , info=3077)
112     RADIUM        = SaltVersion("Radium"       , info=3078)
113     ACTINIUM      = SaltVersion("Actinium"     , info=3079)
114     THORIUM       = SaltVersion("Thorium"      , info=3080)
115     PROTACTINIUM  = SaltVersion("Protactinium" , info=3081)
116     URANIUM       = SaltVersion("Uranium"      , info=3082)
117     NEPTUNIUM     = SaltVersion("Neptunium"    , info=3083)
118     PLUTONIUM     = SaltVersion("Plutonium"    , info=3084)
119     AMERICIUM     = SaltVersion("Americium"    , info=3085)
120     CURIUM        = SaltVersion("Curium"       , info=3086)
121     BERKELIUM     = SaltVersion("Berkelium"    , info=3087)
122     CALIFORNIUM   = SaltVersion("Californium"  , info=3088)
123     EINSTEINIUM   = SaltVersion("Einsteinium"  , info=3089)
124     FERMIUM       = SaltVersion("Fermium"      , info=3090)
125     MENDELEVIUM   = SaltVersion("Mendelevium"  , info=3091)
126     NOBELIUM      = SaltVersion("Nobelium"     , info=3092)
127     LAWRENCIUM    = SaltVersion("Lawrencium"   , info=3093)
128     RUTHERFORDIUM = SaltVersion("Rutherfordium", info=3094)
129     DUBNIUM       = SaltVersion("Dubnium"      , info=3095)
130     SEABORGIUM    = SaltVersion("Seaborgium"   , info=3096)
131     BOHRIUM       = SaltVersion("Bohrium"      , info=3097)
132     HASSIUM       = SaltVersion("Hassium"      , info=3098)
133     MEITNERIUM    = SaltVersion("Meitnerium"   , info=3099)
134     DARMSTADTIUM  = SaltVersion("Darmstadtium" , info=3100)
135     ROENTGENIUM   = SaltVersion("Roentgenium"  , info=3101)
136     COPERNICIUM   = SaltVersion("Copernicium"  , info=3102)
137     NIHONIUM      = SaltVersion("Nihonium"     , info=3103)
138     FLEROVIUM     = SaltVersion("Flerovium"    , info=3104)
139     MOSCOVIUM     = SaltVersion("Moscovium"    , info=3105)
140     LIVERMORIUM   = SaltVersion("Livermorium"  , info=3106)
141     TENNESSINE    = SaltVersion("Tennessine"   , info=3107)
142     OGANESSON     = SaltVersion("Oganesson"    , info=3108)
143     @classmethod
144     def versions(cls):
145         if not cls._sorted_versions:
146             cls._sorted_versions = sorted(
147                 (getattr(cls, name) for name in dir(cls) if name.isupper()),
148                 key=operator.attrgetter("info"),
149             )
150         return cls._sorted_versions
151     @classmethod
152     def current_release(cls):
153         if cls._current_release is None:
154             for version in cls.versions():
155                 if version.released is False:
156                     cls._current_release = version
157                     break
158         return cls._current_release
159     @classmethod
160     def next_release(cls):
161         if cls._next_release is None:
162             next_release_ahead = False
163             for version in cls.versions():
164                 if next_release_ahead:
165                     cls._next_release = version
166                     break
167                 if version == cls.current_release():
168                     next_release_ahead = True
169         return cls._next_release
170     @classmethod
171     def previous_release(cls):
172         if cls._previous_release is None:
173             previous = None
174             for version in cls.versions():
175                 if version == cls.current_release():
176                     break
177                 previous = version
178             cls._previous_release = previous
179         return cls._previous_release
180 class SaltStackVersion:
181     __slots__ = (
182         "name",
183         "major",
184         "minor",
185         "bugfix",
186         "mbugfix",
187         "pre_type",
188         "pre_num",
189         "noc",
190         "sha",
191     )
192     git_sha_regex = r"(?P&lt;sha&gt;g?[a-f0-9]{7,40})"
193     git_describe_regex = re.compile(
194         r"(?:[^\d]+)?(?P&lt;major&gt;[\d]{1,4})"
195         r"(?:\.(?P&lt;minor&gt;[\d]{1,2}))?"
196         r"(?:\.(?P&lt;bugfix&gt;[\d]{0,2}))?"
197         r"(?:\.(?P&lt;mbugfix&gt;[\d]{0,2}))?"
198         r"(?:(?P&lt;pre_type&gt;rc|a|b|alpha|beta|nb)(?P&lt;pre_num&gt;[\d]+))?"
199         r"(?:(?:.*)(?:\+|-)(?P&lt;noc&gt;(?:0na|[\d]+|n/a))(?:-|\.)" + git_sha_regex + r")?"
200     )
201     git_sha_regex = r"^" + git_sha_regex
202     git_sha_regex = re.compile(git_sha_regex)
203     NAMES = {v.name: v.info for v in SaltVersionsInfo.versions()}
204     LNAMES = {k.lower(): v for (k, v) in iter(NAMES.items())}
205     VNAMES = {v: k for (k, v) in iter(NAMES.items())}
206     RMATCH = {v[:2]: k for (k, v) in iter(NAMES.items())}
207     def __init__(
208         self,  # pylint: disable=C0103
209         major,
210         minor=None,
211         bugfix=None,
212         mbugfix=0,
213         pre_type=None,
214         pre_num=None,
215         noc=0,
216         sha=None,
217     ):
218         if isinstance(major, str):
219             major = int(major)
220         if isinstance(minor, str):
221             if not minor:
222                 minor = None
223             else:
224                 minor = int(minor)
225         if bugfix is None and not self.new_version(major=major):
226             bugfix = 0
227         elif isinstance(bugfix, str):
228             if not bugfix:
229                 bugfix = None
230             else:
231                 bugfix = int(bugfix)
232         if mbugfix is None:
233             mbugfix = 0
234         elif isinstance(mbugfix, str):
235             mbugfix = int(mbugfix)
236         if pre_type is None:
237             pre_type = ""
238         if pre_num is None:
239             pre_num = 0
240         elif isinstance(pre_num, str):
241             pre_num = int(pre_num)
242         if noc is None:
243             noc = 0
244         elif isinstance(noc, str) and noc in ("0na", "n/a"):
245             noc = -1
246         elif isinstance(noc, str):
247             noc = int(noc)
248         self.major = major
249         self.minor = minor
250         self.bugfix = bugfix
251         self.mbugfix = mbugfix
252         self.pre_type = pre_type
253         self.pre_num = pre_num
254         if self.new_version(major):
255             vnames_key = (major,)
256         else:
257             vnames_key = (major, minor)
258         self.name = self.VNAMES.get(vnames_key)
259         self.noc = noc
260         self.sha = sha
261     def new_version(self, major):
262         return bool(int(major) &gt;= 3000 and int(major) &lt; VERSION_LIMIT)
263     @classmethod
264     def parse(cls, version_string):
265         if version_string.lower() in cls.LNAMES:
266             return cls.from_name(version_string)
267         vstr = (
268             version_string.decode()
269             if isinstance(version_string, bytes)
270             else version_string
271         )
272         match = cls.git_describe_regex.match(vstr)
273         if not match:
274             raise ValueError(
275                 "Unable to parse version string: '{}'".format(version_string)
276             )
277         return cls(*match.groups())
278     @classmethod
279     def from_name(cls, name):
280         if name.lower() not in cls.LNAMES:
281             raise ValueError("Named version '{}' is not known".format(name))
282         return cls(*cls.LNAMES[name.lower()])
283     @classmethod
284     def from_last_named_version(cls):
285         import salt.utils.versions
286         salt.utils.versions.warn_until(
287             SaltVersionsInfo.SULFUR,
288             "The use of SaltStackVersion.from_last_named_version() is "
289             "deprecated and set to be removed in {version}. Please use "
290             "SaltStackVersion.current_release() instead.",
291         )
292         return cls.current_release()
293     @classmethod
294     def current_release(cls):
295         return cls(*SaltVersionsInfo.current_release().info)
296     @classmethod
297     def next_release(cls):
298         return cls(*SaltVersionsInfo.next_release().info)
299     @property
300     def sse(self):
301         return 0 &lt; self.major &lt; 2014
302     def min_info(self):
303         info = [self.major]
304         if self.new_version(self.major):
305             if self.minor:
306                 info.append(self.minor)
307         else:
308             info.extend([self.minor, self.bugfix, self.mbugfix])
309         return info
310     @property
311     def info(self):
312         return tuple(self.min_info())
313     @property
314     def pre_info(self):
315         info = self.min_info()
316         info.extend([self.pre_type, self.pre_num])
317         return tuple(info)
318     @property
319     def noc_info(self):
320         info = self.min_info()
321         info.extend([self.pre_type, self.pre_num, self.noc])
322         return tuple(info)
323     @property
324     def full_info(self):
325         info = self.min_info()
326         info.extend([self.pre_type, self.pre_num, self.noc, self.sha])
327         return tuple(info)
328     @property
329     def full_info_all_versions(self):
330         info = [
331             self.major,
332             self.minor,
333             self.bugfix,
334             self.mbugfix,
335             self.pre_type,
336             self.pre_num,
337             self.noc,
338             self.sha,
339         ]
340         return tuple(info)
341     @property
342     def string(self):
343         if self.new_version(self.major):
344             version_string = "{}".format(self.major)
345             if self.minor:
346                 version_string = "{}.{}".format(self.major, self.minor)
347         else:
348             version_string = "{}.{}.{}".format(self.major, self.minor, self.bugfix)
349         if self.mbugfix:
350             version_string += ".{}".format(self.mbugfix)
351         if self.pre_type:
352             version_string += "{}{}".format(self.pre_type, self.pre_num)
353         if self.noc and self.sha:
354             noc = self.noc
355             if noc &lt; 0:
356                 noc = "0na"
357             version_string += "+{}.{}".format(noc, self.sha)
358         return version_string
359     @property
360     def formatted_version(self):
361         if self.name and self.major &gt; 10000:
362             version_string = self.name
363             if self.sse:
364                 version_string += " Enterprise"
365             version_string += " (Unreleased)"
366             return version_string
367         version_string = self.string
368         if self.sse:
369             version_string += " Enterprise"
370         if (self.major, self.minor) in self.RMATCH:
371             version_string += " ({})".format(self.RMATCH[(self.major, self.minor)])
372         return version_string
373     @property
374     def pre_index(self):
375         if self.new_version(self.major):
376             pre_type = 2
377             if not isinstance(self.minor, int):
378                 pre_type = 1
379         else:
380             pre_type = 4
381         return pre_type
382     def __str__(self):
383         return self.string
384     def __compare__(self, other, method):
385         if not isinstance(other, SaltStackVersion):
386             if isinstance(other, str):
387                 other = SaltStackVersion.parse(other)
388             elif isinstance(other, (list, tuple)):
389                 other = SaltStackVersion(*other)
390             else:
391                 raise ValueError(
392                     "Cannot instantiate Version from type '{}'".format(type(other))
393                 )
394         pre_type = self.pre_index
395         other_pre_type = other.pre_index
396         other_noc_info = list(other.noc_info)
397         noc_info = list(self.noc_info)
398         if self.new_version(self.major):
399             if self.minor and not other.minor:
400                 if self.minor &gt; 0:
401                     other_noc_info[1] = 0
402             if not self.minor and other.minor:
403                 if other.minor &gt; 0:
404                     noc_info[1] = 0
405         if self.pre_type and not other.pre_type:
406             other_noc_info[other_pre_type] = "zzzzz"
407         if not self.pre_type and other.pre_type:
408             noc_info[pre_type] = "zzzzz"
409         return method(tuple(noc_info), tuple(other_noc_info))
410     def __lt__(self, other):
411         return self.__compare__(other, lambda _self, _other: _self &lt; _other)
412     def __le__(self, other):
413         return self.__compare__(other, lambda _self, _other: _self &lt;= _other)
414     def __eq__(self, other):
415         return self.__compare__(other, lambda _self, _other: _self == _other)
416     def __ne__(self, other):
417         return self.__compare__(other, lambda _self, _other: _self != _other)
418     def __ge__(self, other):
419         return self.__compare__(other, lambda _self, _other: _self &gt;= _other)
420     def __gt__(self, other):
421         return self.__compare__(other, lambda _self, _other: _self &gt; _other)
422     def __repr__(self):
423         parts = []
424         if self.name:
425             parts.append("name='{}'".format(self.name))
426         parts.extend(["major={}".format(self.major), "minor={}".format(self.minor)])
427         if self.new_version(self.major):
428             if not self.minor:
429                 parts.remove("".join([x for x in parts if re.search("^minor*", x)]))
430         else:
431             parts.extend(["bugfix={}".format(self.bugfix)])
432         if self.mbugfix:
433             parts.append("minor-bugfix={}".format(self.mbugfix))
434         if self.pre_type:
435             parts.append("{}={}".format(self.pre_type, self.pre_num))
436         noc = self.noc
437         if noc == -1:
438             noc = "0na"
439         if noc and self.sha:
440             parts.extend(["noc={}".format(noc), "sha={}".format(self.sha)])
441         return "&lt;{} {}&gt;".format(self.__class__.__name__, " ".join(parts))
442 __saltstack_version__ = SaltStackVersion.current_release()
443 def __discover_version(saltstack_version):
444     import os
445     import subprocess
446     if "SETUP_DIRNAME" in globals():
447         cwd = SETUP_DIRNAME  # pylint: disable=E0602
448         if not os.path.exists(os.path.join(cwd, ".git")):
449             return saltstack_version
450     else:
451         cwd = os.path.abspath(os.path.dirname(__file__))
452         if not os.path.exists(os.path.join(os.path.dirname(cwd), ".git")):
453             return saltstack_version
454     try:
455         kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
456         if not sys.platform.startswith("win"):
457             kwargs["close_fds"] = True
458         process = subprocess.Popen(
459             [
460                 "git",
461                 "describe",
462                 "--tags",
463                 "--long",
464                 "--match",
465                 "v[0-9]*",
466                 "--always",
467             ],
468             **kwargs
469         )
470         out, err = process.communicate()
471         out = out.decode().strip()
472         err = err.decode().strip()
473         if not out or err:
474             return saltstack_version
475         if SaltStackVersion.git_sha_regex.match(out):
476             saltstack_version.sha = out.strip()
477             saltstack_version.noc = -1
478             return saltstack_version
479         return SaltStackVersion.parse(out)
480     except OSError as os_err:
481         if os_err.errno != 2:
482             raise
483     return saltstack_version
484 def __get_version(saltstack_version):
485     try:
486         from salt._version import __saltstack_version__  # pylint: disable=E0611,F0401
487         return __saltstack_version__
488     except ImportError:
489         return __discover_version(saltstack_version)
490 __saltstack_version__ = __get_version(__saltstack_version__)
491 if __saltstack_version__.name:
492     SaltVersionsInfo._current_release = getattr(
493         SaltVersionsInfo, __saltstack_version__.name.upper()
494     )
495 del __get_version
496 __version_info__ = __saltstack_version__.info
497 __version__ = __saltstack_version__.string
498 def salt_information():
499     yield "Salt", __version__
500 def dependency_information(include_salt_cloud=False):
501     libs = [
502         ("Python", None, sys.version.rsplit("\n")<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0].strip()),
503         ("Jinja2", "jinja2", "__version__"),
504         ("M2Crypto", "M2Crypto", "version"),
505         ("msgpack", "msgpack", "version"),
506         ("msgpack-pure", "msgpack_pure", "version"),
507         ("pycrypto", "Crypto", "__version__"),
508         ("pycryptodome", "Cryptodome", "version_info"),
509         ("PyYAML", "yaml", "__version__"),
510         ("PyZMQ", "zmq", "__version__"),
511         ("ZMQ"</b></font>, "zmq", "zmq_version"),
512         ("Mako", "mako", "__version__"),
513         ("Tornado", "tornado", "version"),
514         ("timelib", "timelib", "version"),
515         ("dateutil", "dateutil", "__version__"),
516         ("pygit2", "pygit2", "__version__"),
517         ("libgit2", "pygit2", "LIBGIT2_VERSION"),
518         ("smmap", "smmap", "__version__"),
519         ("cffi", "cffi", "__version__"),
520         ("pycparser", "pycparser", "__version__"),
521         ("gitdb", "gitdb", "__version__"),
522         ("gitpython", "git", "__version__"),
523         ("python-gnupg", "gnupg", "__version__"),
524         ("mysql-python", "MySQLdb", "__version__"),
525         ("cherrypy", "cherrypy", "__version__"),
526         ("docker-py", "docker", "__version__"),
527     ]
528     if include_salt_cloud:
529         libs.append(
530             ("Apache Libcloud", "libcloud", "__version__"),
531         )
532     for name, imp, attr in libs:
533         if imp is None:
534             yield name, attr
535             continue
536         try:
537             imp = __import__(imp)
538             version = getattr(imp, attr)
539             if callable(version):
540                 version = version()
541             if isinstance(version, (tuple, list)):
542                 version = ".".join(map(str, version))
543             yield name, version
544         except Exception:  # pylint: disable=broad-except
545             yield name, None
546 def system_information():
547     from distro import linux_distribution
548     def system_version():
549         lin_ver = linux_distribution()
550         mac_ver = platform.mac_ver()
551         win_ver = platform.win32_ver()
552         if mac_ver[0]:
553             if isinstance(mac_ver[1], (tuple, list)) and "".join(mac_ver[1]):
554                 return " ".join([mac_ver[0], ".".join(mac_ver[1]), mac_ver[2]])
555             else:
556                 return " ".join([mac_ver[0], mac_ver[2]])
557         elif win_ver[0]:
558             return " ".join(win_ver)
559         elif lin_ver[0]:
560             return " ".join(lin_ver)
561         else:
562             return ""
563     if platform.win32_ver()[0]:
564         import win32api  # pylint: disable=3rd-party-module-not-gated
565         import win32con  # pylint: disable=3rd-party-module-not-gated
566         hkey = win32con.HKEY_LOCAL_MACHINE
567         key = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
568         value_name = "ProductName"
569         reg_handle = win32api.RegOpenKey(hkey, key)
570         product_name, _ = win32api.RegQueryValueEx(reg_handle, value_name)
571         version = "Unknown"
572         release = ""
573         if "Server" in product_name:
574             for item in product_name.split(" "):
575                 if re.match(r"\d+", item):
576                     version = item
577                 if re.match(r"^R\d+$", item):
578                     release = item
579             release = "{}Server{}".format(version, release)
580         else:
581             for item in product_name.split(" "):
582                 if re.match(r"^(\d+(\.\d+)?)|Thin|Vista$", item):
583                     version = item
584             release = version
585         _, ver, service_pack, extra = platform.win32_ver()
586         version = " ".join([release, ver, service_pack, extra])
587     else:
588         version = system_version()
589         release = platform.release()
590     system = [
591         ("system", platform.system()),
592         ("dist", " ".join(linux_distribution(full_distribution_name=False))),
593         ("release", release),
594         ("machine", platform.machine()),
595         ("version", version),
596         ("locale", __salt_system_encoding__),
597     ]
598     for name, attr in system:
599         yield name, attr
600         continue
601 def extensions_information():
602     import salt.utils.entrypoints
603     extensions = {}
604     for entry_point in salt.utils.entrypoints.iter_entry_points("salt.loader"):
605         dist_nv = salt.utils.entrypoints.name_and_version_from_entry_point(entry_point)
606         if not dist_nv:
607             continue
608         if dist_nv.name in extensions:
609             continue
610         extensions[dist_nv.name] = dist_nv.version
611     return extensions
612 def versions_information(include_salt_cloud=False, include_extensions=True):
613     salt_info = list(salt_information())
614     lib_info = list(dependency_information(include_salt_cloud))
615     sys_info = list(system_information())
616     info = {
617         "Salt Version": dict(salt_info),
618         "Dependency Versions": dict(lib_info),
619         "System Versions": dict(sys_info),
620     }
621     if include_extensions:
622         extensions_info = extensions_information()
623         if extensions_info:
624             info["Salt Extensions"] = extensions_info
625     return info
626 def versions_report(include_salt_cloud=False, include_extensions=True):
627     ver_info = versions_information(
628         include_salt_cloud=include_salt_cloud, include_extensions=include_extensions
629     )
630     not_installed = "Not Installed"
631     ns_pad = len(not_installed)
632     lib_pad = max(len(name) for name in ver_info["Dependency Versions"])
633     sys_pad = max(len(name) for name in ver_info["System Versions"])
634     if include_extensions and "Salt Extensions" in ver_info:
635         ext_pad = max(len(name) for name in ver_info["Salt Extensions"])
636     else:
637         ext_pad = 1
638     padding = max(lib_pad, sys_pad, ns_pad, ext_pad) + 1
639     fmt = "{0:&gt;{pad}}: {1}"
640     info = []
641     for ver_type in (
642         "Salt Version",
643         "Dependency Versions",
644         "Salt Extensions",
645         "System Versions",
646     ):
647         if ver_type == "Salt Extensions" and ver_type not in ver_info:
648             continue
649         info.append("{}:".format(ver_type))
650         for name in sorted(ver_info[ver_type], key=lambda x: x.lower()):
651             ver = fmt.format(
652                 name, ver_info[ver_type][name] or not_installed, pad=padding
653             )
654             info.append(ver)
655         info.append(" ")
656     yield from info
657 if __name__ == "__main__":
658     print(__version__)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gitfs_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import copy
3 import errno
4 import fnmatch
5 import glob
6 import hashlib
7 import io
8 import logging
9 import os
10 import shlex
11 import shutil
12 import stat
13 import subprocess
14 import time
15 import weakref
16 from datetime import datetime
17 import salt.ext.tornado.ioloop
18 import salt.fileserver
19 import salt.utils.configparser
20 import salt.utils.data
21 import salt.utils.files
22 import salt.utils.gzip_util
23 import salt.utils.hashutils
24 import salt.utils.itertools
25 import salt.utils.path
26 import salt.utils.platform
27 import salt.utils.stringutils
28 import salt.utils.url
29 import salt.utils.user
30 import salt.utils.versions
31 from salt.config import DEFAULT_MASTER_OPTS as _DEFAULT_MASTER_OPTS
32 from salt.exceptions import FileserverConfigError, GitLockError, get_error_message
33 from salt.utils.event import tagify
34 from salt.utils.odict import OrderedDict
35 from salt.utils.process import os_is_running as pid_exists
36 from salt.utils.versions import LooseVersion as _LooseVersion
37 VALID_REF_TYPES = _DEFAULT_MASTER_OPTS["gitfs_ref_types"]
38 PER_REMOTE_ONLY = ("name",)
39 GLOBAL_ONLY = ()
40 SYMLINK_RECURSE_DEPTH = 100
41 AUTH_PROVIDERS = ("pygit2",)
42 AUTH_PARAMS = ("user", "password", "pubkey", "privkey", "passphrase", "insecure_auth")
43 PER_SALTENV_PARAMS = ("mountpoint", "root", "ref")
44 _RECOMMEND_GITPYTHON = (
45     "GitPython is installed, you may wish to set %s_provider to "
46     "'gitpython' to use GitPython for %s support."
47 )
48 _RECOMMEND_PYGIT2 = (
49     "pygit2 is installed, you may wish to set %s_provider to "
50     "'pygit2' to use pygit2 for for %s support."
51 )
52 _INVALID_REPO = (
53     "Cache path %s (corresponding remote: %s) exists but is not a valid "
54     "git repository. You will need to manually delete this directory on the "
55     "master to continue to use this %s remote."
56 )
57 log = logging.getLogger(__name__)
58 try:
59     if (
60         salt.utils.platform.is_darwin()
61         and salt.utils.path.which("git") == "/usr/bin/git"
62     ):
63         from salt.utils.mac_utils import git_is_stub
64         if git_is_stub():
65             raise ImportError("Git is not present.")
66     import git
67     import gitdb
68     GITPYTHON_VERSION = _LooseVersion(git.__version__)
69 except Exception:  # pylint: disable=broad-except
70     GITPYTHON_VERSION = None
71 try:
72     import warnings
73     with warnings.catch_warnings():
74         warnings.simplefilter("ignore")
75         import pygit2
76     PYGIT2_VERSION = _LooseVersion(pygit2.__version__)
77     LIBGIT2_VERSION = _LooseVersion(pygit2.LIBGIT2_VERSION)
78     if PYGIT2_VERSION &lt;= _LooseVersion("0.26.3"):
79         try:
80             import pygit2.ffi
81             import pygit2.remote
82         except ImportError:
83             pass
84         else:
85             def __maybe_string(ptr):
86                 if not ptr:
87                     return None
88                 return pygit2.ffi.string(ptr).decode("utf-8")
89             pygit2.remote.maybe_string = __maybe_string
90     try:
91         GitError = pygit2.errors.GitError
92     except AttributeError:
93         GitError = Exception
94 except Exception as exc:  # pylint: disable=broad-except
95     PYGIT2_VERSION = None
96     LIBGIT2_VERSION = None
97     if not isinstance(exc, ImportError):
98         log.exception("Failed to import pygit2")
99 GITPYTHON_MINVER = _LooseVersion("0.3")
100 PYGIT2_MINVER = _LooseVersion("0.20.3")
101 LIBGIT2_MINVER = _LooseVersion("0.20.0")
102 def enforce_types(key, val):
103     non_string_params = {
104         "ssl_verify": bool,
105         "insecure_auth": bool,
106         "disable_saltenv_mapping": bool,
107         "saltenv_whitelist": "stringlist",
108         "saltenv_blacklist": "stringlist",
109         "refspecs": "stringlist",
110         "ref_types": "stringlist",
111         "update_interval": int,
112     }
113     def _find_global(key):
114         for item in non_string_params:
115             try:
116                 if key.endswith("_" + item):
117                     ret = item
118                     break
119             except TypeError:
120                 if key.endswith("_" + str(item)):
121                     ret = item
122                     break
123         else:
124             ret = None
125         return ret
126     if key not in non_string_params:
127         key = _find_global(key)
128         if key is None:
129             return str(val)
130     expected = non_string_params[key]
131     if expected == "stringlist":
132         if not isinstance(val, ((str,), list)):
133             val = str(val)
134         if isinstance(val, str):
135             return [x.strip() for x in val.split(",")]
136         return [str(x) for x in val]
137     else:
138         try:
139             return expected(val)
140         except Exception as exc:  # pylint: disable=broad-except
141             log.error(
142                 "Failed to enforce type for key=%s with val=%s, falling back "
143                 "to a string",
144                 key,
145                 val,
146             )
147             return str(val)
148 def failhard(role):
149     raise FileserverConfigError("Failed to load {}".format(role))
150 class GitProvider:
151     def __init__(
152         self,
153         opts,
154         remote,
155         per_remote_defaults,
156         per_remote_only,
157         override_params,
158         cache_root,
159         role="gitfs",
160     ):
161         self.opts = opts
162         self.role = role
163         self.global_saltenv = salt.utils.data.repack_dictlist(
164             self.opts.get("{}_saltenv".format(self.role), []),
165             strict=True,
166             recurse=True,
167             key_cb=str,
168             val_cb=lambda x, y: str(y),
169         )
170         self.conf = copy.deepcopy(per_remote_defaults)
171         for saltenv, saltenv_conf in self.global_saltenv.items():
172             if "mountpoint" in saltenv_conf:
173                 self.global_saltenv[saltenv]["mountpoint"] = salt.utils.url.strip_proto(
174                     self.global_saltenv[saltenv]["mountpoint"]
175                 )
176         per_remote_collisions = [x for x in override_params if x in per_remote_only]
177         if per_remote_collisions:
178             log.critical(
179                 "The following parameter names are restricted to per-remote "
180                 "use only: %s. This is a bug, please report it.",
181                 ", ".join(per_remote_collisions),
182             )
183         try:
184             valid_per_remote_params = override_params + per_remote_only
185         except TypeError:
186             valid_per_remote_params = list(override_params) + list(per_remote_only)
187         if isinstance(remote, dict):
188             self.id = next(iter(remote))
189             self.get_url()
190             per_remote_conf = salt.utils.data.repack_dictlist(
191                 remote[self.id],
192                 strict=True,
193                 recurse=True,
194                 key_cb=str,
195                 val_cb=enforce_types,
196             )
197             if not per_remote_conf:
198                 log.critical(
199                     "Invalid per-remote configuration for %s remote '%s'. "
200                     "If no per-remote parameters are being specified, there "
201                     "may be a trailing colon after the URL, which should be "
202                     "removed. Check the master configuration file.",
203                     self.role,
204                     self.id,
205                 )
206                 failhard(self.role)
207             if (
208                 self.role == "git_pillar"
209                 and self.branch != "__env__"
210                 and "base" in per_remote_conf
211             ):
212                 log.critical(
213                     "Invalid per-remote configuration for %s remote '%s'. base can only"
214                     " be specified if __env__ is specified as the branch name.",
215                     self.role,
216                     self.id,
217                 )
218                 failhard(self.role)
219             per_remote_errors = False
220             for param in (
221                 x for x in per_remote_conf if x not in valid_per_remote_params
222             ):
223                 per_remote_errors = True
224                 if param in AUTH_PARAMS and self.provider not in AUTH_PROVIDERS:
225                     msg = (
226                         "{0} authentication parameter '{1}' (from remote "
227                         "'{2}') is only supported by the following "
228                         "provider(s): {3}. Current {0}_provider is '{4}'.".format(
229                             self.role,
230                             param,
231                             self.id,
232                             ", ".join(AUTH_PROVIDERS),
233                             self.provider,
234                         )
235                     )
236                     if self.role == "gitfs":
237                         msg += (
238                             "See the GitFS Walkthrough in the Salt "
239                             "documentation for further information."
240                         )
241                     log.critical(msg)
242                 else:
243                     msg = (
244                         "Invalid {} configuration parameter '{}' in "
245                         "remote '{}'. Valid parameters are: {}.".format(
246                             self.role,
247                             param,
248                             self.id,
249                             ", ".join(valid_per_remote_params),
250                         )
251                     )
252                     if self.role == "gitfs":
253                         msg += (
254                             " See the GitFS Walkthrough in the Salt "
255                             "documentation for further information."
256                         )
257                     log.critical(msg)
258             if per_remote_errors:
259                 failhard(self.role)
260             self.conf.update(per_remote_conf)
261         else:
262             self.id = remote
263             self.get_url()
264         if "root" not in self.conf:
265             self.conf["root"] = ""
266         if self.role == "winrepo" and "name" not in self.conf:
267             self.conf["name"] = self.url.rsplit("/", 1)[-1]
268             if self.conf["name"].lower().endswith(".git"):
269                 self.conf["name"] = self.conf["name"][:-4]
270         if "mountpoint" in self.conf:
271             self.conf["mountpoint"] = salt.utils.url.strip_proto(
272                 self.conf["mountpoint"]
273             ).strip("/")
274         else:
275             self.conf["mountpoint"] = ""
276         if "saltenv" not in self.conf:
277             self.conf["saltenv"] = {}
278         else:
279             for saltenv, saltenv_conf in self.conf["saltenv"].items():
280                 if "mountpoint" in saltenv_conf:
281                     saltenv_ptr = self.conf["saltenv"][saltenv]
282                     saltenv_ptr["mountpoint"] = salt.utils.url.strip_proto(
283                         saltenv_ptr["mountpoint"]
284                     )
285         for key, val in self.conf.items():
286             if key not in PER_SALTENV_PARAMS and not hasattr(self, key):
287                 setattr(self, key, val)
288         for key in PER_SALTENV_PARAMS:
289             if key != "ref":
290                 setattr(self, "_" + key, self.conf[key])
291             self.add_conf_overlay(key)
292         if not hasattr(self, "refspecs"):
293             key = "{}_refspecs".format(self.role)
294             try:
295                 default_refspecs = _DEFAULT_MASTER_OPTS[key]
296             except KeyError:
297                 log.critical(
298                     "The '%s' option has no default value in salt/config/__init__.py.",
299                     key,
300                 )
301                 failhard(self.role)
302             setattr(self, "refspecs", default_refspecs)
303             log.debug(
304                 "The 'refspecs' option was not explicitly defined as a "
305                 "configurable parameter. Falling back to %s for %s remote "
306                 "'%s'.",
307                 default_refspecs,
308                 self.role,
309                 self.id,
310             )
311         delattr(self, "conf")
312         if hasattr(self, "ref_types"):
313             self.ref_types = [x.lower() for x in self.ref_types]
314             invalid_ref_types = [x for x in self.ref_types if x not in VALID_REF_TYPES]
315             if invalid_ref_types:
316                 log.critical(
317                     "The following ref_types for %s remote '%s' are "
318                     "invalid: %s. The supported values are: %s",
319                     self.role,
320                     self.id,
321                     ", ".join(invalid_ref_types),
322                     ", ".join(VALID_REF_TYPES),
323                 )
324                 failhard(self.role)
325         if not isinstance(self.url, str):
326             log.critical(
327                 "Invalid %s remote '%s'. Remotes must be strings, you "
328                 "may need to enclose the URL in quotes",
329                 self.role,
330                 self.id,
331             )
332             failhard(self.role)
333         hash_type = getattr(hashlib, self.opts.get("hash_type", "md5"))
334         self.hash = hash_type(self.id.encode("utf-8")).hexdigest()
335         self.cachedir_basename = getattr(self, "name", self.hash)
336         self.cachedir = salt.utils.path.join(cache_root, self.cachedir_basename)
337         self.linkdir = salt.utils.path.join(cache_root, "links", self.cachedir_basename)
338         if not os.path.isdir(self.cachedir):
339             os.makedirs(self.cachedir)
340         try:
341             self.new = self.init_remote()
342         except Exception as exc:  # pylint: disable=broad-except
343             msg = "Exception caught while initializing {} remote '{}': {}".format(
344                 self.role, self.id, exc
345             )
346             if isinstance(self, GitPython):
347                 msg += " Perhaps git is not available."
348             log.critical(msg, exc_info=True)
349             failhard(self.role)
350     def _get_envs_from_ref_paths(self, refs):
351         def _check_ref(env_set, rname):
352             if rname in self.saltenv_revmap:
353                 env_set.update(self.saltenv_revmap[rname])
354             else:
355                 if rname == self.base:
356                     env_set.add("base")
357                 elif not self.disable_saltenv_mapping:
358                     env_set.add(rname)
359         use_branches = "branch" in self.ref_types
360         use_tags = "tag" in self.ref_types
361         ret = set()
362         if salt.utils.stringutils.is_hex(self.base):
363             ret.add("base")
364         for ref in salt.utils.data.decode(refs):
365             if ref.startswith("refs/"):
366                 ref = ref[5:]
367             rtype, rname = ref.split("/", 1)
368             if rtype == "remotes" and use_branches:
369                 parted = rname.partition("/")
370                 rname = parted[2] if parted[2] else parted[0]
371                 _check_ref(ret, rname)
372             elif rtype == "tags" and use_tags:
373                 _check_ref(ret, rname)
374         return ret
375     def _get_lock_file(self, lock_type="update"):
376         return salt.utils.path.join(self.gitdir, lock_type + ".lk")
377     @classmethod
378     def add_conf_overlay(cls, name):
379         def _getconf(self, tgt_env="base"):
380             strip_sep = (
381                 lambda x: x.rstrip(os.sep) if name in ("root", "mountpoint") else x
382             )
383             if self.role != "gitfs":
384                 return strip_sep(getattr(self, "_" + name))
385             saltenv_conf = self.saltenv.get(tgt_env, {})
386             if name == "ref":
387                 def _get_per_saltenv(tgt_env):
388                     if name in saltenv_conf:
389                         return saltenv_conf[name]
390                     elif (
391                         tgt_env in self.global_saltenv
392                         and name in self.global_saltenv[tgt_env]
393                     ):
394                         return self.global_saltenv[tgt_env][name]
395                     else:
396                         return None
397                 per_saltenv_ref = _get_per_saltenv(tgt_env)
398                 try:
399                     all_saltenvs_ref = self.all_saltenvs
400                     if per_saltenv_ref and all_saltenvs_ref != per_saltenv_ref:
401                         log.debug(
402                             "The per-saltenv configuration has mapped the "
403                             "'%s' branch/tag to saltenv '%s' for %s "
404                             "remote '%s', but this remote has "
405                             "all_saltenvs set to '%s'. The per-saltenv "
406                             "mapping will be ignored in favor of '%s'.",
407                             per_saltenv_ref,
408                             tgt_env,
409                             self.role,
410                             self.id,
411                             all_saltenvs_ref,
412                             all_saltenvs_ref,
413                         )
414                     return all_saltenvs_ref
415                 except AttributeError:
416                     pass
417                 if tgt_env == "base":
418                     return self.base
419                 elif self.disable_saltenv_mapping:
420                     if per_saltenv_ref is None:
421                         log.debug(
422                             "saltenv mapping is disabled for %s remote '%s' "
423                             "and saltenv '%s' is not explicitly mapped",
424                             self.role,
425                             self.id,
426                             tgt_env,
427                         )
428                     return per_saltenv_ref
429                 else:
430                     return per_saltenv_ref or tgt_env
431             if name in saltenv_conf:
432                 return strip_sep(saltenv_conf[name])
433             elif (
434                 tgt_env in self.global_saltenv and name in self.global_saltenv[tgt_env]
435             ):
436                 return strip_sep(self.global_saltenv[tgt_env][name])
437             else:
438                 return strip_sep(getattr(self, "_" + name))
439         setattr(cls, name, _getconf)
440     def check_root(self):
441         root_dir = salt.utils.path.join(self.cachedir, self.root()).rstrip(os.sep)
442         if os.path.isdir(root_dir):
443             return root_dir
444         log.error(
445             "Root path '%s' not present in %s remote '%s', skipping.",
446             self.root(),
447             self.role,
448             self.id,
449         )
450         return None
451     def clean_stale_refs(self):
452         cleaned = []
453         cmd_str = "git remote prune origin"
454         env = os.environ.copy()
455         if not salt.utils.platform.is_windows():
456             env[b"LANGUAGE"] = b"C"
457             env[b"LC_ALL"] = b"C"
458         cmd = subprocess.Popen(
459             shlex.split(cmd_str),
460             close_fds=not salt.utils.platform.is_windows(),
461             cwd=os.path.dirname(self.gitdir),
462             env=env,
463             stdout=subprocess.PIPE,
464             stderr=subprocess.STDOUT,
465         )
466         output = cmd.communicate()[0]
467         output = output.decode(__salt_system_encoding__)
468         if cmd.returncode != 0:
469             log.warning(
470                 "Failed to prune stale branches for %s remote '%s'. "
471                 "Output from '%s' follows:\n%s",
472                 self.role,
473                 self.id,
474                 cmd_str,
475                 output,
476             )
477         else:
478             marker = " * [pruned] "
479             for line in salt.utils.itertools.split(output, "\n"):
480                 if line.startswith(marker):
481                     cleaned.append(line[len(marker) :].strip())
482             if cleaned:
483                 log.debug(
484                     "%s pruned the following stale refs: %s",
485                     self.role,
486                     ", ".join(cleaned),
487                 )
488         return cleaned
489     def clear_lock(self, lock_type="update"):
490         lock_file = self._get_lock_file(lock_type=lock_type)
491         def _add_error(errlist, exc):
492             msg = "Unable to remove update lock for {} ({}): {} ".format(
493                 self.url, lock_file, exc
494             )
495             log.debug(msg)
496             errlist.append(msg)
497         success = []
498         failed = []
499         try:
500             os.remove(lock_file)
501         except OSError as exc:
502             if exc.errno == errno.ENOENT:
503                 pass
504             elif exc.errno == errno.EISDIR:
505                 try:
506                     shutil.rmtree(lock_file)
507                 except OSError as exc:
508                     _add_error(failed, exc)
509             else:
510                 _add_error(failed, exc)
511         else:
512             msg = "Removed {} lock for {} remote '{}'".format(
513                 lock_type, self.role, self.id
514             )
515             log.debug(msg)
516             success.append(msg)
517         return success, failed
518     def enforce_git_config(self):
519         git_config = os.path.join(self.gitdir, "config")
520         conf = salt.utils.configparser.GitConfigParser()
521         if not conf.read(git_config):
522             log.error("Failed to read from git config file %s", git_config)
523         else:
524             conf_changed = False
525             remote_section = 'remote "origin"'
526             try:
527                 url = conf.get(remote_section, "url")
528             except salt.utils.configparser.NoSectionError:
529                 conf.add_section(remote_section)
530                 conf_changed = True
531                 url = None
532             log.debug(
533                 "Current fetch URL for %s remote '%s': %s (desired: %s)",
534                 self.role,
535                 self.id,
536                 url,
537                 self.url,
538             )
539             if url != self.url:
540                 conf.set(remote_section, "url", self.url)
541                 log.debug(
542                     "Fetch URL for %s remote '%s' set to %s",
543                     self.role,
544                     self.id,
545                     self.url,
546                 )
547                 conf_changed = True
548             try:
549                 refspecs = sorted(conf.get(remote_section, "fetch", as_list=True))
550             except salt.utils.configparser.NoOptionError:
551                 refspecs = []
552             desired_refspecs = sorted(self.refspecs)
553             log.debug(
554                 "Current refspecs for %s remote '%s': %s (desired: %s)",
555                 self.role,
556                 self.id,
557                 refspecs,
558                 desired_refspecs,
559             )
560             if refspecs != desired_refspecs:
561                 conf.set_multivar(remote_section, "fetch", self.refspecs)
562                 log.debug(
563                     "Refspecs for %s remote '%s' set to %s",
564                     self.role,
565                     self.id,
566                     desired_refspecs,
567                 )
568                 conf_changed = True
569             try:
570                 ssl_verify = conf.get("http", "sslVerify")
571             except salt.utils.configparser.NoSectionError:
572                 conf.add_section("http")
573                 ssl_verify = None
574             except salt.utils.configparser.NoOptionError:
575                 ssl_verify = None
576             desired_ssl_verify = str(self.ssl_verify).lower()
577             log.debug(
578                 "Current http.sslVerify for %s remote '%s': %s (desired: %s)",
579                 self.role,
580                 self.id,
581                 ssl_verify,
582                 desired_ssl_verify,
583             )
584             if ssl_verify != desired_ssl_verify:
585                 conf.set("http", "sslVerify", desired_ssl_verify)
586                 log.debug(
587                     "http.sslVerify for %s remote '%s' set to %s",
588                     self.role,
589                     self.id,
590                     desired_ssl_verify,
591                 )
592                 conf_changed = True
593             if conf_changed:
594                 with salt.utils.files.fopen(git_config, "w") as fp_:
595                     conf.write(fp_)
596                     log.debug(
597                         "Config updates for %s remote '%s' written to %s",
598                         self.role,
599                         self.id,
600                         git_config,
601                     )
602     def fetch(self):
603         try:
604             with self.gen_lock(lock_type="update"):
605                 log.debug("Fetching %s remote '%s'", self.role, self.id)
606                 return self._fetch()
607         except GitLockError as exc:
608             if exc.errno == errno.EEXIST:
609                 log.warning(
610                     "Update lock file is present for %s remote '%s', "
611                     "skipping. If this warning persists, it is possible that "
612                     "the update process was interrupted, but the lock could "
613                     "also have been manually set. Removing %s or running "
614                     "'salt-run cache.clear_git_lock %s type=update' will "
615                     "allow updates to continue for this remote.",
616                     self.role,
617                     self.id,
618                     self._get_lock_file(lock_type="update"),
619                     self.role,
620                 )
621             return False
622     def _lock(self, lock_type="update", failhard=False):
623         try:
624             fh_ = os.open(
625                 self._get_lock_file(lock_type), os.O_CREAT | os.O_EXCL | os.O_WRONLY
626             )
627             with os.fdopen(fh_, "wb"):
628                 os.write(fh_, salt.utils.stringutils.to_bytes(str(os.getpid())))
629         except OSError as exc:
630             if exc.errno == errno.EEXIST:
631                 with salt.utils.files.fopen(self._get_lock_file(lock_type), "r") as fd_:
632                     try:
633                         pid = int(
634                             salt.utils.stringutils.to_unicode(fd_.readline()).rstrip()
635                         )
636                     except ValueError:
637                         pid = 0
638                 global_lock_key = self.role + "_global_lock"
639                 lock_file = self._get_lock_file(lock_type=lock_type)
640                 if self.opts[global_lock_key]:
641                     msg = (
642                         "{} is enabled and {} lockfile {} is present for "
643                         "{} remote '{}'.".format(
644                             global_lock_key,
645                             lock_type,
646                             lock_file,
647                             self.role,
648                             self.id,
649                         )
650                     )
651                     if pid:
652                         msg += " Process {} obtained the lock".format(pid)
653                         if not pid_exists(pid):
654                             msg += (
655                                 " but this process is not running. The "
656                                 "update may have been interrupted. If "
657                                 "using multi-master with shared gitfs "
658                                 "cache, the lock may have been obtained "
659                                 "by another master."
660                             )
661                     log.warning(msg)
662                     if failhard:
663                         raise
664                     return
665                 elif pid and pid_exists(pid):
666                     log.warning(
667                         "Process %d has a %s %s lock (%s)",
668                         pid,
669                         self.role,
670                         lock_type,
671                         lock_file,
672                     )
673                     if failhard:
674                         raise
675                     return
676                 else:
677                     if pid:
678                         log.warning(
679                             "Process %d has a %s %s lock (%s), but this "
680                             "process is not running. Cleaning up lock file.",
681                             pid,
682                             self.role,
683                             lock_type,
684                             lock_file,
685                         )
686                     success, fail = self.clear_lock()
687                     if success:
688                         return self._lock(lock_type="update", failhard=failhard)
689                     elif failhard:
690                         raise
691                     return
692             else:
693                 msg = "Unable to set {} lock for {} ({}): {} ".format(
694                     lock_type, self.id, self._get_lock_file(lock_type), exc
695                 )
696                 log.error(msg, exc_info=True)
697                 raise GitLockError(exc.errno, msg)
698         msg = "Set {} lock for {} remote '{}'".format(lock_type, self.role, self.id)
699         log.debug(msg)
700         return msg
701     def lock(self):
702         success = []
703         failed = []
704         try:
705             result = self._lock(lock_type="update")
706         except GitLockError as exc:
707             failed.append(exc.strerror)
708         else:
709             if result is not None:
710                 success.append(result)
711         return success, failed
712     @contextlib.contextmanager
713     def gen_lock(self, lock_type="update", timeout=0, poll_interval=0.5):
714         if not isinstance(lock_type, str):
715             raise GitLockError(errno.EINVAL, "Invalid lock_type '{}'".format(lock_type))
716         try:
717             timeout = int(timeout)
718         except ValueError:
719             timeout = 0
720         else:
721             if timeout &lt; 0:
722                 timeout = 0
723         if not isinstance(poll_interval, ((int,), float)) or poll_interval &lt; 0:
724             poll_interval = 0.5
725         if poll_interval &gt; timeout:
726             poll_interval = timeout
727         lock_set = False
728         try:
729             time_start = time.time()
730             while True:
731                 try:
732                     self._lock(lock_type=lock_type, failhard=True)
733                     lock_set = True
734                     yield
735                     break
736                 except (OSError, GitLockError) as exc:
737                     if not timeout or time.time() - time_start &gt; timeout:
738                         raise GitLockError(exc.errno, exc.strerror)
739                     else:
740                         log.debug(
741                             "A %s lock is already present for %s remote "
742                             "'%s', sleeping %f second(s)",
743                             lock_type,
744                             self.role,
745                             self.id,
746                             poll_interval,
747                         )
748                         time.sleep(poll_interval)
749                         continue
750         finally:
751             if lock_set:
752                 self.clear_lock(lock_type=lock_type)
753     def init_remote(self):
754         raise NotImplementedError()
755     def checkout(self):
756         raise NotImplementedError()
757     def dir_list(self, tgt_env):
758         raise NotImplementedError()
759     def env_is_exposed(self, tgt_env):
760         return salt.utils.stringutils.check_whitelist_blacklist(
761             tgt_env,
762             whitelist=self.saltenv_whitelist,
763             blacklist=self.saltenv_blacklist,
764         )
765     def _fetch(self):
766         raise NotImplementedError()
767     def envs(self):
768         raise NotImplementedError()
769     def file_list(self, tgt_env):
770         raise NotImplementedError()
771     def find_file(self, path, tgt_env):
772         raise NotImplementedError()
773     def get_checkout_target(self):
774         if self.role == "git_pillar" and self.branch == "__env__":
775             try:
776                 return self.all_saltenvs
777             except AttributeError:
778                 pass
779             target = self.opts.get("pillarenv") or self.opts.get("saltenv") or "base"
780             return self.base if target == "base" else str(target)
781         return self.branch
782     def get_tree(self, tgt_env):
783         if not self.env_is_exposed(tgt_env):
784             return None
785         tgt_ref = self.ref(tgt_env)
786         if tgt_ref is None:
787             return None
788         for ref_type in self.ref_types:
789             try:
790                 func_name = "get_tree_from_{}".format(ref_type)
791                 func = getattr(self, func_name)
792             except AttributeError:
793                 log.error(
794                     "%s class is missing function '%s'",
795                     self.__class__.__name__,
796                     func_name,
797                 )
798             else:
799                 candidate = func(tgt_ref)
800                 if candidate is not None:
801                     return candidate
802         if self.fallback:
803             for ref_type in self.ref_types:
804                 try:
805                     func_name = "get_tree_from_{}".format(ref_type)
806                     func = getattr(self, func_name)
807                 except AttributeError:
808                     log.error(
809                         "%s class is missing function '%s'",
810                         self.__class__.__name__,
811                         func_name,
812                     )
813                 else:
814                     candidate = func(self.fallback)
815                     if candidate is not None:
816                         return candidate
817         return None
818     def get_url(self):
819         if self.role in ("git_pillar", "winrepo"):
820             try:
821                 self.branch, self.url = self.id.split(None, 1)
822             except ValueError:
823                 self.branch = self.conf["branch"]
824                 self.url = self.id
825         else:
826             self.url = self.id
827     @property
828     def linkdir_walk(self):
829         try:
830             return self._linkdir_walk
831         except AttributeError:
832             self._linkdir_walk = []
833             try:
834                 parts = self._mountpoint.split("/")
835             except AttributeError:
836                 log.error(
837                     "%s class is missing a '_mountpoint' attribute",
838                     self.__class__.__name__,
839                 )
840             else:
841                 for idx, item in enumerate(parts[:-1]):
842                     try:
843                         dirs = [parts[idx + 1]]
844                     except IndexError:
845                         dirs = []
846                     self._linkdir_walk.append(
847                         (
848                             salt.utils.path.join(self.linkdir, *parts[: idx + 1]),
849                             dirs,
850                             [],
851                         )
852                     )
853                 try:
854                     self._linkdir_walk.insert(0, (self.linkdir, [parts[0]], []))
855                 except IndexError:
856                     pass
857             return self._linkdir_walk
858     def setup_callbacks(self):
859     def verify_auth(self):
860         self.credentials = None
861         return True
862     def write_file(self, blob, dest):
863         raise NotImplementedError()
864 class GitPython(GitProvider):
865     def __init__(
866         self,
867         opts,
868         remote,
869         per_remote_defaults,
870         per_remote_only,
871         override_params,
872         cache_root,
873         role="gitfs",
874     ):
875         self.provider = "gitpython"
876         super().__init__(
877             opts,
878             remote,
879             per_remote_defaults,
880             per_remote_only,
881             override_params,
882             cache_root,
883             role,
884         )
885     def checkout(self):
886         tgt_ref = self.get_checkout_target()
887         try:
888             head_sha = self.repo.rev_parse("HEAD").hexsha
889         except Exception:  # pylint: disable=broad-except
890             head_sha = None
891         checkout_refs = [
892             ("origin/" + tgt_ref, False),
893             ("tags/" + tgt_ref, False),
894         ]
895         if self.fallback:
896             checkout_refs += [
897                 ("origin/" + self.fallback, True),
898                 ("tags/" + self.fallback, True),
899             ]
900         for checkout_ref, fallback in checkout_refs:
901             try:
902                 target_sha = self.repo.rev_parse(checkout_ref).hexsha
903             except Exception:  # pylint: disable=broad-except
904                 continue
905             else:
906                 if head_sha == target_sha:
907                     return self.check_root()
908             try:
909                 with self.gen_lock(lock_type="checkout"):
910                     self.repo.git.checkout(checkout_ref)
911                     log.debug(
912                         "%s remote '%s' has been checked out to %s%s",
913                         self.role,
914                         self.id,
915                         checkout_ref,
916                         " as fallback" if fallback else "",
917                     )
918             except GitLockError as exc:
919                 if exc.errno == errno.EEXIST:
920                     raise GitLockError(
921                         exc.errno,
922                         "Checkout lock exists for {} remote '{}'".format(
923                             self.role, self.id
924                         ),
925                     )
926                 else:
927                     log.error(
928                         "Error %d encountered obtaining checkout lock "
929                         "for %s remote '%s'",
930                         exc.errno,
931                         self.role,
932                         self.id,
933                     )
934                     return None
935             except Exception:  # pylint: disable=broad-except
936                 continue
937             return self.check_root()
938         log.error(
939             "Failed to checkout %s from %s remote '%s': remote ref does not exist",
940             tgt_ref,
941             self.role,
942             self.id,
943         )
944         return None
945     def init_remote(self):
946         new = False
947         if not os.listdir(self.cachedir):
948             self.repo = git.Repo.init(self.cachedir)
949             new = True
950         else:
951             try:
952                 self.repo = git.Repo(self.cachedir)
953             except git.exc.InvalidGitRepositoryError:
954                 log.error(_INVALID_REPO, self.cachedir, self.url, self.role)
955                 return new
956         self.gitdir = salt.utils.path.join(self.repo.working_dir, ".git")
957         self.enforce_git_config()
958         return new
959     def dir_list(self, tgt_env):
960         ret = set()
961         tree = self.get_tree(tgt_env)
962         if not tree:
963             return ret
964         if self.root(tgt_env):
965             try:
966                 tree = tree / self.root(tgt_env)
967             except KeyError:
968                 return ret
969             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
970         else:
971             relpath = lambda path: path
972         add_mountpoint = lambda path: salt.utils.path.join(
973             self.mountpoint(tgt_env), path, use_posixpath=True
974         )
975         for blob in tree.traverse():
976             if isinstance(blob, git.Tree):
977                 ret.add(add_mountpoint(relpath(blob.path)))
978         if self.mountpoint(tgt_env):
979             ret.add(self.mountpoint(tgt_env))
980         return ret
981     def envs(self):
982         ref_paths = [x.path for x in self.repo.refs]
983         return self._get_envs_from_ref_paths(ref_paths)
984     def _fetch(self):
985         origin = self.repo.remotes[0]
986         try:
987             fetch_results = origin.fetch()
988         except AssertionError:
989             fetch_results = origin.fetch()
990 <a name="0"></a>
991         new_objs = False
992         for fetchinfo in fetch_results:
993             if fetchinfo<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.old_commit is not None:
994                 log.debug(
995                     "%s has updated '%s' for remote '%s' from %s to %s",
996                     self.role,
997                     fetchinfo.name,
998                     self.id,
999                     fetchinfo.old_commit.hexsha[:7],
1000                     fetchinfo.commit.hexsha[</b></font>:7],
1001                 )
1002                 new_objs = True
1003             elif fetchinfo.flags in (fetchinfo.NEW_TAG, fetchinfo.NEW_HEAD):
1004                 log.debug(
1005                     "%s has fetched new %s '%s' for remote '%s'",
1006                     self.role,
1007                     "tag" if fetchinfo.flags == fetchinfo.NEW_TAG else "head",
1008                     fetchinfo.name,
1009                     self.id,
1010                 )
1011                 new_objs = True
1012         cleaned = self.clean_stale_refs()
1013         return True if (new_objs or cleaned) else None
1014     def file_list(self, tgt_env):
1015         files = set()
1016         symlinks = {}
1017         tree = self.get_tree(tgt_env)
1018         if not tree:
1019             return files, symlinks
1020         if self.root(tgt_env):
1021             try:
1022                 tree = tree / self.root(tgt_env)
1023             except KeyError:
1024                 return files, symlinks
1025             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
1026         else:
1027             relpath = lambda path: path
1028         add_mountpoint = lambda path: salt.utils.path.join(
1029             self.mountpoint(tgt_env), path, use_posixpath=True
1030         )
1031         for file_blob in tree.traverse():
1032             if not isinstance(file_blob, git.Blob):
1033                 continue
1034             file_path = add_mountpoint(relpath(file_blob.path))
1035             files.add(file_path)
1036             if stat.S_ISLNK(file_blob.mode):
1037                 stream = io.BytesIO()
1038                 file_blob.stream_data(stream)
1039                 stream.seek(0)
1040                 link_tgt = salt.utils.stringutils.to_str(stream.read())
1041                 stream.close()
1042                 symlinks[file_path] = link_tgt
1043         return files, symlinks
1044     def find_file(self, path, tgt_env):
1045         tree = self.get_tree(tgt_env)
1046         if not tree:
1047             return None, None, None
1048         blob = None
1049         depth = 0
1050         while True:
1051             depth += 1
1052             if depth &gt; SYMLINK_RECURSE_DEPTH:
1053                 blob = None
1054                 break
1055             try:
1056                 file_blob = tree / path
1057                 if stat.S_ISLNK(file_blob.mode):
1058                     stream = io.BytesIO()
1059                     file_blob.stream_data(stream)
1060                     stream.seek(0)
1061                     link_tgt = salt.utils.stringutils.to_str(stream.read())
1062                     stream.close()
1063                     path = salt.utils.path.join(
1064                         os.path.dirname(path), link_tgt, use_posixpath=True
1065                     )
1066                 else:
1067                     blob = file_blob
1068                     if isinstance(blob, git.Tree):
1069                         blob = None
1070                     break
1071             except KeyError:
1072                 blob = None
1073                 break
1074         if isinstance(blob, git.Blob):
1075             return blob, blob.hexsha, blob.mode
1076         return None, None, None
1077     def get_tree_from_branch(self, ref):
1078         try:
1079             return git.RemoteReference(
1080                 self.repo, "refs/remotes/origin/{}".format(ref)
1081             ).commit.tree
1082         except ValueError:
1083             return None
1084     def get_tree_from_tag(self, ref):
1085         try:
1086             return git.TagReference(self.repo, "refs/tags/{}".format(ref)).commit.tree
1087         except ValueError:
1088             return None
1089     def get_tree_from_sha(self, ref):
1090         try:
1091             return self.repo.rev_parse(ref).tree
1092         except (gitdb.exc.ODBError, AttributeError):
1093             return None
1094     def write_file(self, blob, dest):
1095         with salt.utils.files.fopen(dest, "wb+") as fp_:
1096             blob.stream_data(fp_)
1097 class Pygit2(GitProvider):
1098     def __init__(
1099         self,
1100         opts,
1101         remote,
1102         per_remote_defaults,
1103         per_remote_only,
1104         override_params,
1105         cache_root,
1106         role="gitfs",
1107     ):
1108         self.provider = "pygit2"
1109         super().__init__(
1110             opts,
1111             remote,
1112             per_remote_defaults,
1113             per_remote_only,
1114             override_params,
1115             cache_root,
1116             role,
1117         )
1118     def peel(self, obj):
1119         try:
1120             return obj.peel()
1121         except AttributeError:
1122             return obj.get_object()
1123     def checkout(self):
1124         tgt_ref = self.get_checkout_target()
1125         local_ref = "refs/heads/" + tgt_ref
1126         remote_ref = "refs/remotes/origin/" + tgt_ref
1127         tag_ref = "refs/tags/" + tgt_ref
1128         try:
1129             local_head = self.repo.lookup_reference("HEAD")
1130         except KeyError:
1131             log.warning("HEAD not present in %s remote '%s'", self.role, self.id)
1132             return None
1133         try:
1134             head_sha = self.peel(local_head).hex
1135         except AttributeError:
1136             log.error(
1137                 "Unable to get SHA of HEAD for %s remote '%s'", self.role, self.id
1138             )
1139             return None
1140         except KeyError:
1141             head_sha = None
1142         refs = self.repo.listall_references()
1143         def _perform_checkout(checkout_ref, branch=True):
1144             try:
1145                 with self.gen_lock(lock_type="checkout"):
1146                     self.repo.checkout(checkout_ref)
1147                     if branch:
1148                         self.repo.reset(oid, pygit2.GIT_RESET_HARD)
1149                 return True
1150             except GitLockError as exc:
1151                 if exc.errno == errno.EEXIST:
1152                     raise GitLockError(
1153                         exc.errno,
1154                         "Checkout lock exists for {} remote '{}'".format(
1155                             self.role, self.id
1156                         ),
1157                     )
1158                 else:
1159                     log.error(
1160                         "Error %d encountered obtaining checkout lock "
1161                         "for %s remote '%s'",
1162                         exc.errno,
1163                         self.role,
1164                         self.id,
1165                     )
1166             return False
1167         try:
1168             if remote_ref not in refs and tag_ref not in refs and self.fallback:
1169                 tgt_ref = self.fallback
1170                 local_ref = "refs/heads/" + tgt_ref
1171                 remote_ref = "refs/remotes/origin/" + tgt_ref
1172                 tag_ref = "refs/tags/" + tgt_ref
1173             if remote_ref in refs:
1174                 oid = self.peel(self.repo.lookup_reference(remote_ref)).id
1175                 if local_ref not in refs:
1176                     self.repo.create_reference(local_ref, oid)
1177                 try:
1178                     target_sha = self.peel(self.repo.lookup_reference(remote_ref)).hex
1179                 except KeyError:
1180                     log.error(
1181                         "pygit2 was unable to get SHA for %s in %s remote '%s'",
1182                         local_ref,
1183                         self.role,
1184                         self.id,
1185                         exc_info=True,
1186                     )
1187                     return None
1188                 if head_sha != target_sha:
1189                     head_ref = local_head.target
1190                     if (
1191                         isinstance(head_ref, str)
1192                         and head_ref not in refs
1193                         and head_ref != local_ref
1194                     ):
1195                         branch_name = head_ref.partition("refs/heads/")[-1]
1196                         if not branch_name:
1197                             log.error(
1198                                 "pygit2 was unable to resolve branch name from "
1199                                 "HEAD ref '%s' in %s remote '%s'",
1200                                 head_ref,
1201                                 self.role,
1202                                 self.id,
1203                             )
1204                             return None
1205                         remote_head = "refs/remotes/origin/" + branch_name
1206                         if remote_head not in refs:
1207                             remote_head = remote_ref
1208                         self.repo.create_reference(
1209                             head_ref, self.repo.lookup_reference(remote_head).target
1210                         )
1211                     if not _perform_checkout(local_ref, branch=True):
1212                         return None
1213                 return self.check_root()
1214             elif tag_ref in refs:
1215                 tag_obj = self.repo.revparse_single(tag_ref)
1216                 if not isinstance(tag_obj, (pygit2.Commit, pygit2.Tag)):
1217                     log.error(
1218                         "%s does not correspond to pygit2 Commit or Tag object. It is"
1219                         " of type %s",
1220                         tag_ref,
1221                         type(tag_obj),
1222                     )
1223                 else:
1224                     try:
1225                         tag_sha = tag_obj.target.hex
1226                     except AttributeError:
1227                         try:
1228                             tag_sha = tag_obj.hex
1229                         except AttributeError:
1230                             log.error(
1231                                 "Unable to resolve %s from %s remote '%s' "
1232                                 "to either an annotated or non-annotated tag",
1233                                 tag_ref,
1234                                 self.role,
1235                                 self.id,
1236                                 exc_info=True,
1237                             )
1238                             return None
1239                     log.debug("SHA of tag %s: %s", tgt_ref, tag_sha)
1240                     if head_sha != tag_sha:
1241                         if not _perform_checkout(tag_ref, branch=False):
1242                             return None
1243                     return self.check_root()
1244         except GitLockError:
1245             raise
1246         except Exception as exc:  # pylint: disable=broad-except
1247             log.error(
1248                 "Failed to checkout %s from %s remote '%s': %s",
1249                 tgt_ref,
1250                 self.role,
1251                 self.id,
1252                 exc,
1253                 exc_info=True,
1254             )
1255             return None
1256         log.error(
1257             "Failed to checkout %s from %s remote '%s': remote ref does not exist",
1258             tgt_ref,
1259             self.role,
1260             self.id,
1261         )
1262         return None
1263     def clean_stale_refs(self, local_refs=None):  # pylint: disable=arguments-differ
1264         try:
1265             if pygit2.GIT_FETCH_PRUNE:
1266                 return []
1267         except AttributeError:
1268             pass
1269         if self.credentials is not None:
1270             log.debug(
1271                 "The installed version of pygit2 (%s) does not support "
1272                 "detecting stale refs for authenticated remotes, saltenvs "
1273                 "will not reflect branches/tags removed from remote '%s'",
1274                 PYGIT2_VERSION,
1275                 self.id,
1276             )
1277             return []
1278         return super().clean_stale_refs()
1279     def init_remote(self):
1280         home = os.path.expanduser("~")
1281         pygit2.settings.search_path[pygit2.GIT_CONFIG_LEVEL_GLOBAL] = home
1282         new = False
1283         if not os.listdir(self.cachedir):
1284             self.repo = pygit2.init_repository(self.cachedir)
1285             new = True
1286         else:
1287             try:
1288                 self.repo = pygit2.Repository(self.cachedir)
1289             except KeyError:
1290                 log.error(_INVALID_REPO, self.cachedir, self.url, self.role)
1291                 return new
1292         self.gitdir = salt.utils.path.join(self.repo.workdir, ".git")
1293         self.enforce_git_config()
1294         git_config = os.path.join(self.gitdir, "config")
1295         if os.path.exists(git_config) and PYGIT2_VERSION &gt;= _LooseVersion("0.28.0"):
1296             self.repo.config.add_file(git_config)
1297         return new
1298     def dir_list(self, tgt_env):
1299         def _traverse(tree, blobs, prefix):
1300             for entry in iter(tree):
1301                 if entry.oid not in self.repo:
1302                     continue
1303                 blob = self.repo[entry.oid]
1304                 if not isinstance(blob, pygit2.Tree):
1305                     continue
1306                 blobs.append(
1307                     salt.utils.path.join(prefix, entry.name, use_posixpath=True)
1308                 )
1309                 if blob:
1310                     _traverse(
1311                         blob,
1312                         blobs,
1313                         salt.utils.path.join(prefix, entry.name, use_posixpath=True),
1314                     )
1315         ret = set()
1316         tree = self.get_tree(tgt_env)
1317         if not tree:
1318             return ret
1319         if self.root(tgt_env):
1320             try:
1321                 oid = tree[self.root(tgt_env)].oid
1322                 tree = self.repo[oid]
1323             except KeyError:
1324                 return ret
1325             if not isinstance(tree, pygit2.Tree):
1326                 return ret
1327             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
1328         else:
1329             relpath = lambda path: path
1330         blobs = []
1331         if tree:
1332             _traverse(tree, blobs, self.root(tgt_env))
1333         add_mountpoint = lambda path: salt.utils.path.join(
1334             self.mountpoint(tgt_env), path, use_posixpath=True
1335         )
1336         for blob in blobs:
1337             ret.add(add_mountpoint(relpath(blob)))
1338         if self.mountpoint(tgt_env):
1339             ret.add(self.mountpoint(tgt_env))
1340         return ret
1341     def envs(self):
1342         ref_paths = self.repo.listall_references()
1343         return self._get_envs_from_ref_paths(ref_paths)
1344     def _fetch(self):
1345         origin = self.repo.remotes[0]
1346         refs_pre = self.repo.listall_references()
1347         fetch_kwargs = {}
1348         if self.remotecallbacks is not None:
1349             fetch_kwargs["callbacks"] = self.remotecallbacks
1350         else:
1351             if self.credentials is not None:
1352                 origin.credentials = self.credentials
1353         try:
1354             fetch_kwargs["prune"] = pygit2.GIT_FETCH_PRUNE
1355         except AttributeError:
1356             pass
1357         try:
1358             fetch_results = origin.fetch(**fetch_kwargs)
1359         except GitError as exc:  # pylint: disable=broad-except
1360             exc_str = get_error_message(exc).lower()
1361             if "unsupported url protocol" in exc_str and isinstance(
1362                 self.credentials, pygit2.Keypair
1363             ):
1364                 log.error(
1365                     "Unable to fetch SSH-based %s remote '%s'. "
1366                     "You may need to add ssh:// to the repo string or "
1367                     "libgit2 must be compiled with libssh2 to support "
1368                     "SSH authentication.",
1369                     self.role,
1370                     self.id,
1371                     exc_info=True,
1372                 )
1373             elif "authentication required but no callback set" in exc_str:
1374                 log.error(
1375                     "%s remote '%s' requires authentication, but no "
1376                     "authentication configured",
1377                     self.role,
1378                     self.id,
1379                     exc_info=True,
1380                 )
1381             else:
1382                 log.error(
1383                     "Error occurred fetching %s remote '%s': %s",
1384                     self.role,
1385                     self.id,
1386                     exc,
1387                     exc_info=True,
1388                 )
1389             return False
1390         try:
1391             received_objects = fetch_results["received_objects"]
1392         except (AttributeError, TypeError):
1393             received_objects = fetch_results.received_objects
1394         if received_objects != 0:
1395             log.debug(
1396                 "%s received %s objects for remote '%s'",
1397                 self.role,
1398                 received_objects,
1399                 self.id,
1400             )
1401         else:
1402             log.debug("%s remote '%s' is up-to-date", self.role, self.id)
1403         refs_post = self.repo.listall_references()
1404         cleaned = self.clean_stale_refs(local_refs=refs_post)
1405         return True if (received_objects or refs_pre != refs_post or cleaned) else None
1406     def file_list(self, tgt_env):
1407         def _traverse(tree, blobs, prefix):
1408             for entry in iter(tree):
1409                 if entry.oid not in self.repo:
1410                     continue
1411                 obj = self.repo[entry.oid]
1412                 if isinstance(obj, pygit2.Blob):
1413                     repo_path = salt.utils.path.join(
1414                         prefix, entry.name, use_posixpath=True
1415                     )
1416                     blobs.setdefault("files", []).append(repo_path)
1417                     if stat.S_ISLNK(tree[entry.name].filemode):
1418                         link_tgt = self.repo[tree[entry.name].oid].data
1419                         blobs.setdefault("symlinks", {})[repo_path] = link_tgt
1420                 elif isinstance(obj, pygit2.Tree):
1421                     _traverse(
1422                         obj,
1423                         blobs,
1424                         salt.utils.path.join(prefix, entry.name, use_posixpath=True),
1425                     )
1426         files = set()
1427         symlinks = {}
1428         tree = self.get_tree(tgt_env)
1429         if not tree:
1430             return files, symlinks
1431         if self.root(tgt_env):
1432             try:
1433                 oid = tree[self.root(tgt_env)].oid
1434                 tree = self.repo[oid]
1435             except KeyError:
1436                 return files, symlinks
1437             if not isinstance(tree, pygit2.Tree):
1438                 return files, symlinks
1439             relpath = lambda path: os.path.relpath(path, self.root(tgt_env))
1440         else:
1441             relpath = lambda path: path
1442         blobs = {}
1443         if tree:
1444             _traverse(tree, blobs, self.root(tgt_env))
1445         add_mountpoint = lambda path: salt.utils.path.join(
1446             self.mountpoint(tgt_env), path, use_posixpath=True
1447         )
1448         for repo_path in blobs.get("files", []):
1449             files.add(add_mountpoint(relpath(repo_path)))
1450         for repo_path, link_tgt in blobs.get("symlinks", {}).items():
1451             symlinks[add_mountpoint(relpath(repo_path))] = link_tgt
1452         return files, symlinks
1453     def find_file(self, path, tgt_env):
1454         tree = self.get_tree(tgt_env)
1455         if not tree:
1456             return None, None, None
1457         blob = None
1458         mode = None
1459         depth = 0
1460         while True:
1461             depth += 1
1462             if depth &gt; SYMLINK_RECURSE_DEPTH:
1463                 blob = None
1464                 break
1465             try:
1466                 entry = tree[path]
1467                 mode = entry.filemode
1468                 if stat.S_ISLNK(mode):
1469                     link_tgt = self.repo[entry.oid].data
1470                     path = salt.utils.path.join(
1471                         os.path.dirname(path), link_tgt, use_posixpath=True
1472                     )
1473                 else:
1474                     blob = self.repo[entry.oid]
1475                     if isinstance(blob, pygit2.Tree):
1476                         blob = None
1477                     break
1478             except KeyError:
1479                 blob = None
1480                 break
1481         if isinstance(blob, pygit2.Blob):
1482             return blob, blob.hex, mode
1483         return None, None, None
1484     def get_tree_from_branch(self, ref):
1485         try:
1486             return self.peel(
1487                 self.repo.lookup_reference("refs/remotes/origin/{}".format(ref))
1488             ).tree
1489         except KeyError:
1490             return None
1491     def get_tree_from_tag(self, ref):
1492         try:
1493             return self.peel(
1494                 self.repo.lookup_reference("refs/tags/{}".format(ref))
1495             ).tree
1496         except KeyError:
1497             return None
1498     def get_tree_from_sha(self, ref):
1499         try:
1500             return self.repo.revparse_single(ref).tree
1501         except (KeyError, TypeError, ValueError, AttributeError):
1502             return None
1503     def setup_callbacks(self):
1504         if PYGIT2_VERSION &gt;= _LooseVersion("0.23.2"):
1505             self.remotecallbacks = pygit2.RemoteCallbacks(credentials=self.credentials)
1506             if not self.ssl_verify:
1507                 self.remotecallbacks.certificate_check = lambda *args, **kwargs: True
1508         else:
1509             self.remotecallbacks = None
1510             if not self.ssl_verify:
1511                 warnings.warn(
1512                     "pygit2 does not support disabling the SSL certificate "
1513                     "check in versions prior to 0.23.2 (installed: {}). "
1514                     "Fetches for self-signed certificates will fail.".format(
1515                         PYGIT2_VERSION
1516                     )
1517                 )
1518     def verify_auth(self):
1519         self.credentials = None
1520         if os.path.isabs(self.url):
1521             return True
1522         elif not any(getattr(self, x, None) for x in AUTH_PARAMS):
1523             return True
1524         def _incomplete_auth(missing):
1525             log.critical(
1526                 "Incomplete authentication information for %s remote "
1527                 "'%s'. Missing parameters: %s",
1528                 self.role,
1529                 self.id,
1530                 ", ".join(missing),
1531             )
1532             failhard(self.role)
1533         def _key_does_not_exist(key_type, path):
1534             log.critical(
1535                 "SSH %s (%s) for %s remote '%s' could not be found, path "
1536                 "may be incorrect. Note that it may be necessary to clear "
1537                 "git_pillar locks to proceed once this is resolved and the "
1538                 "master has been started back up. A warning will be logged "
1539                 "if this is the case, with instructions.",
1540                 key_type,
1541                 path,
1542                 self.role,
1543                 self.id,
1544             )
1545             failhard(self.role)
1546         transport, _, address = self.url.partition("://")
1547         if not address:
1548             transport = "ssh"
1549             address = self.url
1550         transport = transport.lower()
1551         if transport in ("git", "file"):
1552             return True
1553         elif "ssh" in transport:
1554             required_params = ("pubkey", "privkey")
1555             user = address.split("@")[0]
1556             if user == address:
1557                 log.critical(
1558                     "Keypair specified for %s remote '%s', but remote URL "
1559                     "is missing a username",
1560                     self.role,
1561                     self.id,
1562                 )
1563                 failhard(self.role)
1564             self.user = user
1565             if all(bool(getattr(self, x, None)) for x in required_params):
1566                 keypair_params = [
1567                     getattr(self, x, None)
1568                     for x in ("user", "pubkey", "privkey", "passphrase")
1569                 ]
1570                 for idx, key_type in ((1, "pubkey"), (2, "privkey")):
1571                     key_path = keypair_params[idx]
1572                     if key_path is not None:
1573                         try:
1574                             if not os.path.isfile(key_path):
1575                                 _key_does_not_exist(key_type, key_path)
1576                         except TypeError:
1577                             _key_does_not_exist(key_type, key_path)
1578                 self.credentials = pygit2.Keypair(*keypair_params)
1579                 return True
1580             else:
1581                 missing_auth = [
1582                     x for x in required_params if not bool(getattr(self, x, None))
1583                 ]
1584                 _incomplete_auth(missing_auth)
1585         elif "http" in transport:
1586             required_params = ("user", "password")
1587             password_ok = all(bool(getattr(self, x, None)) for x in required_params)
1588             no_password_auth = not any(
1589                 bool(getattr(self, x, None)) for x in required_params
1590             )
1591             if no_password_auth:
1592                 return True
1593             if password_ok:
1594                 if transport == "http" and not self.insecure_auth:
1595                     log.critical(
1596                         "Invalid configuration for %s remote '%s'. "
1597                         "Authentication is disabled by default on http "
1598                         "remotes. Either set %s_insecure_auth to True in the "
1599                         "master configuration file, set a per-remote config "
1600                         "option named 'insecure_auth' to True, or use https "
1601                         "or ssh-based authentication.",
1602                         self.role,
1603                         self.id,
1604                         self.role,
1605                     )
1606                     failhard(self.role)
1607                 self.credentials = pygit2.UserPass(self.user, self.password)
1608                 return True
1609             else:
1610                 missing_auth = [
1611                     x for x in required_params if not bool(getattr(self, x, None))
1612                 ]
1613                 _incomplete_auth(missing_auth)
1614         else:
1615             log.critical(
1616                 "Invalid configuration for %s remote '%s'. Unsupported transport '%s'.",
1617                 self.role,
1618                 self.id,
1619                 transport,
1620             )
1621             failhard(self.role)
1622     def write_file(self, blob, dest):
1623         with salt.utils.files.fopen(dest, "wb+") as fp_:
1624             fp_.write(blob.data)
1625 GIT_PROVIDERS = {
1626     "pygit2": Pygit2,
1627     "gitpython": GitPython,
1628 }
1629 class GitBase:
1630     def __init__(
1631         self,
1632         opts,
1633         remotes=None,
1634         per_remote_overrides=(),
1635         per_remote_only=PER_REMOTE_ONLY,
1636         global_only=GLOBAL_ONLY,
1637         git_providers=None,
1638         cache_root=None,
1639         init_remotes=True,
1640     ):
1641         self.opts = opts
1642         self.git_providers = (
1643             git_providers if git_providers is not None else GIT_PROVIDERS
1644         )
1645         self.verify_provider()
1646         if cache_root is not None:
1647             self.cache_root = self.remote_root = cache_root
1648         else:
1649             self.cache_root = salt.utils.path.join(self.opts["cachedir"], self.role)
1650             self.remote_root = salt.utils.path.join(self.cache_root, "remotes")
1651         self.env_cache = salt.utils.path.join(self.cache_root, "envs.p")
1652         self.hash_cachedir = salt.utils.path.join(self.cache_root, "hash")
1653         self.file_list_cachedir = salt.utils.path.join(
1654             self.opts["cachedir"], "file_lists", self.role
1655         )
1656         if init_remotes:
1657             self.init_remotes(
1658                 remotes if remotes is not None else [],
1659                 per_remote_overrides,
1660                 per_remote_only,
1661                 global_only,
1662             )
1663     def init_remotes(
1664         self,
1665         remotes,
1666         per_remote_overrides=(),
1667         per_remote_only=PER_REMOTE_ONLY,
1668         global_only=GLOBAL_ONLY,
1669     ):
1670         override_params = copy.deepcopy(per_remote_overrides)
1671         global_auth_params = [
1672             "{}_{}".format(self.role, x)
1673             for x in AUTH_PARAMS
1674             if self.opts["{}_{}".format(self.role, x)]
1675         ]
1676         if self.provider in AUTH_PROVIDERS:
1677             override_params += AUTH_PARAMS
1678         elif global_auth_params:
1679             msg = (
1680                 "{0} authentication was configured, but the '{1}' "
1681                 "{0}_provider does not support authentication. The "
1682                 "providers for which authentication is supported in {0} "
1683                 "are: {2}.".format(self.role, self.provider, ", ".join(AUTH_PROVIDERS))
1684             )
1685             if self.role == "gitfs":
1686                 msg += (
1687                     " See the GitFS Walkthrough in the Salt documentation "
1688                     "for further information."
1689                 )
1690             log.critical(msg)
1691             failhard(self.role)
1692         per_remote_defaults = {}
1693         global_values = set(override_params)
1694         global_values.update(set(global_only))
1695         for param in global_values:
1696             key = "{}_{}".format(self.role, param)
1697             if key not in self.opts:
1698                 log.critical(
1699                     "Key '%s' not present in global configuration. This is "
1700                     "a bug, please report it.",
1701                     key,
1702                 )
1703                 failhard(self.role)
1704             per_remote_defaults[param] = enforce_types(key, self.opts[key])
1705         self.remotes = []
1706         for remote in remotes:
1707             repo_obj = self.git_providers[self.provider](
1708                 self.opts,
1709                 remote,
1710                 per_remote_defaults,
1711                 per_remote_only,
1712                 override_params,
1713                 self.cache_root,
1714                 self.role,
1715             )
1716             if hasattr(repo_obj, "repo"):
1717                 repo_obj.verify_auth()
1718                 repo_obj.setup_callbacks()
1719                 if self.opts["__role"] == "minion" and repo_obj.new:
1720                     repo_obj.fetch()
1721                 repo_obj.saltenv_revmap = {}
1722                 for saltenv, saltenv_conf in repo_obj.saltenv.items():
1723                     if "ref" in saltenv_conf:
1724                         ref = saltenv_conf["ref"]
1725                         repo_obj.saltenv_revmap.setdefault(ref, []).append(saltenv)
1726                         if saltenv == "base":
1727                             repo_obj.saltenv[saltenv].pop("ref")
1728                             if ref != repo_obj.base:
1729                                 log.warning(
1730                                     "The 'base' environment has been "
1731                                     "defined in the 'saltenv' param for %s "
1732                                     "remote %s and will override the "
1733                                     "branch/tag specified by %s_base (or a "
1734                                     "per-remote 'base' parameter).",
1735                                     self.role,
1736                                     repo_obj.id,
1737                                     self.role,
1738                                 )
1739                                 repo_obj.base = ref
1740                 all_envs = []
1741                 for env_names in repo_obj.saltenv_revmap.values():
1742                     all_envs.extend(env_names)
1743                 for key, conf in repo_obj.global_saltenv.items():
1744                     if key not in all_envs and "ref" in conf:
1745                         repo_obj.saltenv_revmap.setdefault(conf["ref"], []).append(key)
1746                 self.remotes.append(repo_obj)
1747         cachedir_map = {}
1748         for repo in self.remotes:
1749             cachedir_map.setdefault(repo.cachedir, []).append(repo.id)
1750         collisions = [x for x in cachedir_map if len(cachedir_map[x]) &gt; 1]
1751         if collisions:
1752             for dirname in collisions:
1753                 log.critical(
1754                     "The following %s remotes have conflicting cachedirs: "
1755                     "%s. Resolve this using a per-remote parameter called "
1756                     "'name'.",
1757                     self.role,
1758                     ", ".join(cachedir_map[dirname]),
1759                 )
1760                 failhard(self.role)
1761         if any(x.new for x in self.remotes):
1762             self.write_remote_map()
1763     def clear_old_remotes(self):
1764         try:
1765             cachedir_ls = os.listdir(self.cache_root)
1766         except OSError:
1767             cachedir_ls = []
1768         for repo in self.remotes:
1769             try:
1770                 cachedir_ls.remove(repo.cachedir_basename)
1771             except ValueError:
1772                 pass
1773         to_remove = []
1774         for item in cachedir_ls:
1775             if item in ("hash", "refs"):
1776                 continue
1777             path = salt.utils.path.join(self.cache_root, item)
1778             if os.path.isdir(path):
1779                 to_remove.append(path)
1780         failed = []
1781         if to_remove:
1782             for rdir in to_remove:
1783                 try:
1784                     shutil.rmtree(rdir)
1785                 except OSError as exc:
1786                     log.error(
1787                         "Unable to remove old %s remote cachedir %s: %s",
1788                         self.role,
1789                         rdir,
1790                         exc,
1791                     )
1792                     failed.append(rdir)
1793                 else:
1794                     log.debug("%s removed old cachedir %s", self.role, rdir)
1795         for fdir in failed:
1796             to_remove.remove(fdir)
1797         ret = bool(to_remove)
1798         if ret:
1799             self.write_remote_map()
1800         return ret
1801     def clear_cache(self):
1802         errors = []
1803         for rdir in (self.cache_root, self.file_list_cachedir):
1804             if os.path.exists(rdir):
1805                 try:
1806                     shutil.rmtree(rdir)
1807                 except OSError as exc:
1808                     errors.append("Unable to delete {}: {}".format(rdir, exc))
1809         return errors
1810     def clear_lock(self, remote=None, lock_type="update"):
1811         cleared = []
1812         errors = []
1813         for repo in self.remotes:
1814             if remote:
1815                 try:
1816                     if not fnmatch.fnmatch(repo.url, remote):
1817                         continue
1818                 except TypeError:
1819                     if not fnmatch.fnmatch(repo.url, str(remote)):
1820                         continue
1821             success, failed = repo.clear_lock(lock_type=lock_type)
1822             cleared.extend(success)
1823             errors.extend(failed)
1824         return cleared, errors
1825     def fetch_remotes(self, remotes=None):
1826         if remotes is None:
1827             remotes = []
1828         elif isinstance(remotes, str):
1829             remotes = remotes.split(",")
1830         elif not isinstance(remotes, list):
1831             log.error(
1832                 "Invalid 'remotes' argument (%s) for fetch_remotes. "
1833                 "Must be a list of strings",
1834                 remotes,
1835             )
1836             remotes = []
1837         changed = False
1838         for repo in self.remotes:
1839             name = getattr(repo, "name", None)
1840             if not remotes or (repo.id, name) in remotes or name in remotes:
1841                 try:
1842                     if repo.fetch():
1843                         changed = True
1844                 except Exception as exc:  # pylint: disable=broad-except
1845                     log.error(
1846                         "Exception caught while fetching %s remote '%s': %s",
1847                         self.role,
1848                         repo.id,
1849                         exc,
1850                         exc_info=True,
1851                     )
1852         return changed
1853     def lock(self, remote=None):
1854         locked = []
1855         errors = []
1856         for repo in self.remotes:
1857             if remote:
1858                 try:
1859                     if not fnmatch.fnmatch(repo.url, remote):
1860                         continue
1861                 except TypeError:
1862                     if not fnmatch.fnmatch(repo.url, str(remote)):
1863                         continue
1864             success, failed = repo.lock()
1865             locked.extend(success)
1866             errors.extend(failed)
1867         return locked, errors
1868     def update(self, remotes=None):
1869         data = {"changed": False, "backend": "gitfs"}
1870         data["changed"] = self.clear_old_remotes()
1871         if self.fetch_remotes(remotes=remotes):
1872             data["changed"] = True
1873         refresh_env_cache = self.opts["__role"] == "minion"
1874         if data["changed"] is True or not os.path.isfile(self.env_cache):
1875             env_cachedir = os.path.dirname(self.env_cache)
1876             if not os.path.exists(env_cachedir):
1877                 os.makedirs(env_cachedir)
1878             refresh_env_cache = True
1879         if refresh_env_cache:
1880             new_envs = self.envs(ignore_cache=True)
1881             with salt.utils.files.fopen(self.env_cache, "wb+") as fp_:
1882                 fp_.write(salt.payload.dumps(new_envs))
1883                 log.trace("Wrote env cache data to %s", self.env_cache)
1884         if self.opts.get("fileserver_events", False):
1885             with salt.utils.event.get_event(
1886                 "master",
1887                 self.opts["sock_dir"],
1888                 opts=self.opts,
1889                 listen=False,
1890             ) as event:
1891                 event.fire_event(data, tagify(["gitfs", "update"], prefix="fileserver"))
1892         try:
1893             salt.fileserver.reap_fileserver_cache_dir(
1894                 self.hash_cachedir, self.find_file
1895             )
1896         except OSError:
1897             pass
1898     def update_intervals(self):
1899         return {
1900             (repo.id, getattr(repo, "name", None)): repo.update_interval
1901             for repo in self.remotes
1902         }
1903     def verify_provider(self):
1904         if "verified_{}_provider".format(self.role) in self.opts:
1905             self.provider = self.opts["verified_{}_provider".format(self.role)]
1906         else:
1907             desired_provider = self.opts.get("{}_provider".format(self.role))
1908             if not desired_provider:
1909                 if self.verify_pygit2(quiet=True):
1910                     self.provider = "pygit2"
1911                 elif self.verify_gitpython(quiet=True):
1912                     self.provider = "gitpython"
1913             else:
1914                 try:
1915                     desired_provider = desired_provider.lower()
1916                 except AttributeError:
1917                     desired_provider = str(desired_provider).lower()
1918                 if desired_provider not in self.git_providers:
1919                     log.critical(
1920                         "Invalid %s_provider '%s'. Valid choices are: %s",
1921                         self.role,
1922                         desired_provider,
1923                         ", ".join(self.git_providers),
1924                     )
1925                     failhard(self.role)
1926                 elif desired_provider == "pygit2" and self.verify_pygit2():
1927                     self.provider = "pygit2"
1928                 elif desired_provider == "gitpython" and self.verify_gitpython():
1929                     self.provider = "gitpython"
1930         if not hasattr(self, "provider"):
1931             log.critical("No suitable %s provider module is installed.", self.role)
1932             failhard(self.role)
1933     def verify_gitpython(self, quiet=False):
1934         def _recommend():
1935             if PYGIT2_VERSION and "pygit2" in self.git_providers:
1936                 log.error(_RECOMMEND_PYGIT2, self.role, self.role)
1937         if not GITPYTHON_VERSION:
1938             if not quiet:
1939                 log.error(
1940                     "%s is configured but could not be loaded, is GitPython installed?",
1941                     self.role,
1942                 )
1943                 _recommend()
1944             return False
1945         elif "gitpython" not in self.git_providers:
1946             return False
1947         errors = []
1948         if GITPYTHON_VERSION &lt; GITPYTHON_MINVER:
1949             errors.append(
1950                 "{} is configured, but the GitPython version is earlier than "
1951                 "{}. Version {} detected.".format(
1952                     self.role, GITPYTHON_MINVER, GITPYTHON_VERSION
1953                 )
1954             )
1955         if not salt.utils.path.which("git"):
1956             errors.append(
1957                 "The git command line utility is required when using the "
1958                 "'gitpython' {}_provider.".format(self.role)
1959             )
1960         if errors:
1961             for error in errors:
1962                 log.error(error)
1963             if not quiet:
1964                 _recommend()
1965             return False
1966         self.opts["verified_{}_provider".format(self.role)] = "gitpython"
1967         log.debug("gitpython %s_provider enabled", self.role)
1968         return True
1969     def verify_pygit2(self, quiet=False):
1970         def _recommend():
1971             if GITPYTHON_VERSION and "gitpython" in self.git_providers:
1972                 log.error(_RECOMMEND_GITPYTHON, self.role, self.role)
1973         if not PYGIT2_VERSION:
1974             if not quiet:
1975                 log.error(
1976                     "%s is configured but could not be loaded, are pygit2 "
1977                     "and libgit2 installed?",
1978                     self.role,
1979                 )
1980                 _recommend()
1981             return False
1982         elif "pygit2" not in self.git_providers:
1983             return False
1984         errors = []
1985         if PYGIT2_VERSION &lt; PYGIT2_MINVER:
1986             errors.append(
1987                 "{} is configured, but the pygit2 version is earlier than "
1988                 "{}. Version {} detected.".format(
1989                     self.role, PYGIT2_MINVER, PYGIT2_VERSION
1990                 )
1991             )
1992         if LIBGIT2_VERSION &lt; LIBGIT2_MINVER:
1993             errors.append(
1994                 "{} is configured, but the libgit2 version is earlier than "
1995                 "{}. Version {} detected.".format(
1996                     self.role, LIBGIT2_MINVER, LIBGIT2_VERSION
1997                 )
1998             )
1999         if not getattr(pygit2, "GIT_FETCH_PRUNE", False) and not salt.utils.path.which(
2000             "git"
2001         ):
2002             errors.append(
2003                 "The git command line utility is required when using the "
2004                 "'pygit2' {}_provider.".format(self.role)
2005             )
2006         if errors:
2007             for error in errors:
2008                 log.error(error)
2009             if not quiet:
2010                 _recommend()
2011             return False
2012         self.opts["verified_{}_provider".format(self.role)] = "pygit2"
2013         log.debug("pygit2 %s_provider enabled", self.role)
2014         return True
2015     def write_remote_map(self):
2016         remote_map = salt.utils.path.join(self.cache_root, "remote_map.txt")
2017         try:
2018             with salt.utils.files.fopen(remote_map, "w+") as fp_:
2019                 timestamp = datetime.now().strftime("%d %b %Y %H:%M:%S.%f")
2020                 fp_.write("# {}_remote map as of {}\n".format(self.role, timestamp))
2021                 for repo in self.remotes:
2022                     fp_.write(
2023                         salt.utils.stringutils.to_str(
2024                             "{} = {}\n".format(repo.cachedir_basename, repo.id)
2025                         )
2026                     )
2027         except OSError:
2028             pass
2029         else:
2030             log.info("Wrote new %s remote map to %s", self.role, remote_map)
2031     def do_checkout(self, repo):
2032         time_start = time.time()
2033         while time.time() - time_start &lt;= 5:
2034             try:
2035                 return repo.checkout()
2036             except GitLockError as exc:
2037                 if exc.errno == errno.EEXIST:
2038                     time.sleep(0.1)
2039                     continue
2040                 else:
2041                     log.error(
2042                         "Error %d encountered while obtaining checkout "
2043                         "lock for %s remote '%s': %s",
2044                         exc.errno,
2045                         repo.role,
2046                         repo.id,
2047                         exc,
2048                         exc_info=True,
2049                     )
2050                     break
2051         else:
2052             log.error(
2053                 "Timed out waiting for checkout lock to be released for "
2054                 "%s remote '%s'. If this error persists, run 'salt-run "
2055                 "cache.clear_git_lock %s type=checkout' to clear it.",
2056                 self.role,
2057                 repo.id,
2058                 self.role,
2059             )
2060         return None
2061 class GitFS(GitBase):
2062     role = "gitfs"
2063     instance_map = weakref.WeakKeyDictionary()
2064     def __new__(
2065         cls,
2066         opts,
2067         remotes=None,
2068         per_remote_overrides=(),
2069         per_remote_only=PER_REMOTE_ONLY,
2070         git_providers=None,
2071         cache_root=None,
2072         init_remotes=True,
2073     ):
2074         io_loop = salt.ext.tornado.ioloop.IOLoop.current() if init_remotes else None
2075         if not init_remotes or io_loop not in cls.instance_map:
2076             obj = object.__new__(cls)
2077             super(GitFS, obj).__init__(
2078                 opts,
2079                 remotes if remotes is not None else [],
2080                 per_remote_overrides=per_remote_overrides,
2081                 per_remote_only=per_remote_only,
2082                 git_providers=git_providers
2083                 if git_providers is not None
2084                 else GIT_PROVIDERS,
2085                 cache_root=cache_root,
2086                 init_remotes=init_remotes,
2087             )
2088             if not init_remotes:
2089                 log.debug("Created gitfs object with uninitialized remotes")
2090             else:
2091                 log.debug("Created gitfs object for process %s", os.getpid())
2092                 cls.instance_map[io_loop] = obj
2093             return obj
2094         log.debug("Re-using gitfs object for process %s", os.getpid())
2095         return cls.instance_map[io_loop]
2096     def __init__(
2097         self,
2098         opts,
2099         remotes,
2100         per_remote_overrides=(),
2101         per_remote_only=PER_REMOTE_ONLY,
2102         git_providers=None,
2103         cache_root=None,
2104         init_remotes=True,
2105     ):
2106         pass
2107     def dir_list(self, load):
2108         return self._file_lists(load, "dirs")
2109     def envs(self, ignore_cache=False):
2110         if not ignore_cache:
2111             cache_match = salt.fileserver.check_env_cache(self.opts, self.env_cache)
2112             if cache_match is not None:
2113                 return cache_match
2114         ret = set()
2115         for repo in self.remotes:
2116             repo_envs = repo.envs()
2117             for env_list in repo.saltenv_revmap.values():
2118                 repo_envs.update(env_list)
2119             ret.update([x for x in repo_envs if repo.env_is_exposed(x)])
2120         return sorted(ret)
2121     def find_file(self, path, tgt_env="base", **kwargs):  # pylint: disable=W0613
2122         fnd = {"path": "", "rel": ""}
2123         if os.path.isabs(path):
2124             return fnd
2125         dest = salt.utils.path.join(self.cache_root, "refs", tgt_env, path)
2126         hashes_glob = salt.utils.path.join(
2127             self.hash_cachedir, tgt_env, "{}.hash.*".format(path)
2128         )
2129         blobshadest = salt.utils.path.join(
2130             self.hash_cachedir, tgt_env, "{}.hash.blob_sha1".format(path)
2131         )
2132         lk_fn = salt.utils.path.join(self.hash_cachedir, tgt_env, "{}.lk".format(path))
2133         destdir = os.path.dirname(dest)
2134         hashdir = os.path.dirname(blobshadest)
2135         if not os.path.isdir(destdir):
2136             try:
2137                 os.makedirs(destdir)
2138             except OSError:
2139                 os.remove(destdir)
2140                 os.makedirs(destdir)
2141         if not os.path.isdir(hashdir):
2142             try:
2143                 os.makedirs(hashdir)
2144             except OSError:
2145                 os.remove(hashdir)
2146                 os.makedirs(hashdir)
2147         for repo in self.remotes:
2148             if repo.mountpoint(tgt_env) and not path.startswith(
2149                 repo.mountpoint(tgt_env) + os.sep
2150             ):
2151                 continue
2152             if (
2153                 not salt.utils.stringutils.is_hex(tgt_env)
2154                 and tgt_env not in self.envs()
2155                 and not repo.fallback
2156             ):
2157                 continue
2158             repo_path = path[len(repo.mountpoint(tgt_env)) :].lstrip(os.sep)
2159             if repo.root(tgt_env):
2160                 repo_path = salt.utils.path.join(repo.root(tgt_env), repo_path)
2161             blob, blob_hexsha, blob_mode = repo.find_file(repo_path, tgt_env)
2162             if blob is None:
2163                 continue
2164             def _add_file_stat(fnd, mode):
2165                 if mode is not None:
2166                     fnd["stat"] = [mode]
2167                 return fnd
2168             salt.fileserver.wait_lock(lk_fn, dest)
2169             try:
2170                 with salt.utils.files.fopen(blobshadest, "r") as fp_:
2171                     sha = salt.utils.stringutils.to_unicode(fp_.read())
2172                     if sha == blob_hexsha:
2173                         fnd["rel"] = path
2174                         fnd["path"] = dest
2175                         return _add_file_stat(fnd, blob_mode)
2176             except OSError as exc:
2177                 if exc.errno != errno.ENOENT:
2178                     raise
2179             with salt.utils.files.fopen(lk_fn, "w"):
2180                 pass
2181             for filename in glob.glob(hashes_glob):
2182                 try:
2183                     os.remove(filename)
2184                 except Exception:  # pylint: disable=broad-except
2185                     pass
2186             repo.write_file(blob, dest)
2187             with salt.utils.files.fopen(blobshadest, "w+") as fp_:
2188                 fp_.write(blob_hexsha)
2189             try:
2190                 os.remove(lk_fn)
2191             except OSError:
2192                 pass
2193             fnd["rel"] = path
2194             fnd["path"] = dest
2195             return _add_file_stat(fnd, blob_mode)
2196         return fnd
2197     def serve_file(self, load, fnd):
2198         if "env" in load:
2199             load.pop("env")
2200         ret = {"data": "", "dest": ""}
2201         required_load_keys = {"path", "loc", "saltenv"}
2202         if not all(x in load for x in required_load_keys):
2203             log.debug(
2204                 "Not all of the required keys present in payload. Missing: %s",
2205                 ", ".join(required_load_keys.difference(load)),
2206             )
2207             return ret
2208         if not fnd["path"]:
2209             return ret
2210         ret["dest"] = fnd["rel"]
2211         gzip = load.get("gzip", None)
2212         fpath = os.path.normpath(fnd["path"])
2213         with salt.utils.files.fopen(fpath, "rb") as fp_:
2214             fp_.seek(load["loc"])
2215             data = fp_.read(self.opts["file_buffer_size"])
2216             if data and not salt.utils.files.is_binary(fpath):
2217                 data = data.decode(__salt_system_encoding__)
2218             if gzip and data:
2219                 data = salt.utils.gzip_util.compress(data, gzip)
2220                 ret["gzip"] = gzip
2221             ret["data"] = data
2222         return ret
2223     def file_hash(self, load, fnd):
2224         if "env" in load:
2225             load.pop("env")
2226         if not all(x in load for x in ("path", "saltenv")):
2227             return "", None
2228         ret = {"hash_type": self.opts["hash_type"]}
2229         relpath = fnd["rel"]
2230         path = fnd["path"]
2231         hashdest = salt.utils.path.join(
2232             self.hash_cachedir,
2233             load["saltenv"],
2234             "{}.hash.{}".format(relpath, self.opts["hash_type"]),
2235         )
2236         try:
2237             with salt.utils.files.fopen(hashdest, "rb") as fp_:
2238                 ret["hsum"] = fp_.read()
2239             return ret
2240         except OSError as exc:
2241             if exc.errno != errno.ENOENT:
2242                 raise
2243         try:
2244             os.makedirs(os.path.dirname(hashdest))
2245         except OSError as exc:
2246             if exc.errno != errno.EEXIST:
2247                 raise
2248         ret["hsum"] = salt.utils.hashutils.get_hash(path, self.opts["hash_type"])
2249         with salt.utils.files.fopen(hashdest, "w+") as fp_:
2250             fp_.write(ret["hsum"])
2251         return ret
2252     def _file_lists(self, load, form):
2253         if "env" in load:
2254             load.pop("env")
2255         if not os.path.isdir(self.file_list_cachedir):
2256             try:
2257                 os.makedirs(self.file_list_cachedir)
2258             except os.error:
2259                 log.error("Unable to make cachedir %s", self.file_list_cachedir)
2260                 return []
2261         list_cache = salt.utils.path.join(
2262             self.file_list_cachedir,
2263             "{}.p".format(load["saltenv"].replace(os.path.sep, "_|-")),
2264         )
2265         w_lock = salt.utils.path.join(
2266             self.file_list_cachedir,
2267             ".{}.w".format(load["saltenv"].replace(os.path.sep, "_|-")),
2268         )
2269         cache_match, refresh_cache, save_cache = salt.fileserver.check_file_list_cache(
2270             self.opts, form, list_cache, w_lock
2271         )
2272         if cache_match is not None:
2273             return cache_match
2274         if refresh_cache:
2275             log.trace("Start rebuilding gitfs file_list cache")
2276             ret = {"files": set(), "symlinks": {}, "dirs": set()}
2277             for repo in self.remotes:
2278                 if (
2279                     salt.utils.stringutils.is_hex(load["saltenv"])
2280                     or load["saltenv"] in self.envs()
2281                     or repo.fallback
2282                 ):
2283                     start = time.time()
2284                     repo_files, repo_symlinks = repo.file_list(load["saltenv"])
2285                     ret["files"].update(repo_files)
2286                     ret["symlinks"].update(repo_symlinks)
2287                     ret["dirs"].update(repo.dir_list(load["saltenv"]))
2288                     log.profile(
2289                         "gitfs file_name cache rebuild repo=%s duration=%s seconds",
2290                         repo.id,
2291                         time.time() - start,
2292                     )
2293             ret["files"] = sorted(ret["files"])
2294             ret["dirs"] = sorted(ret["dirs"])
2295             if save_cache:
2296                 salt.fileserver.write_file_list_cache(
2297                     self.opts, ret, list_cache, w_lock
2298                 )
2299             log.trace("Finished rebuilding gitfs file_list cache")
2300             return ret.get(form, [])
2301         return {} if form == "symlinks" else []
2302     def file_list(self, load):
2303         return self._file_lists(load, "files")
2304     def file_list_emptydirs(self, load):  # pylint: disable=W0613
2305         return []
2306     def symlink_list(self, load):
2307         if "env" in load:
2308             load.pop("env")
2309         if (
2310             not salt.utils.stringutils.is_hex(load["saltenv"])
2311             and load["saltenv"] not in self.envs()
2312         ):
2313             return {}
2314         if "prefix" in load:
2315             prefix = load["prefix"].strip("/")
2316         else:
2317             prefix = ""
2318         symlinks = self._file_lists(load, "symlinks")
2319         return {key: val for key, val in symlinks.items() if key.startswith(prefix)}
2320 class GitPillar(GitBase):
2321     role = "git_pillar"
2322     def checkout(self):
2323         self.pillar_dirs = OrderedDict()
2324         self.pillar_linked_dirs = []
2325         for repo in self.remotes:
2326             cachedir = self.do_checkout(repo)
2327             if cachedir is not None:
2328                 if repo.branch == "__env__" and hasattr(repo, "all_saltenvs"):
2329                     env = (
2330                         self.opts.get("pillarenv") or self.opts.get("saltenv") or "base"
2331                     )
2332                 elif repo.env:
2333                     env = repo.env
2334                 else:
2335                     if repo.branch == repo.base:
2336                         env = "base"
2337                     else:
2338                         tgt = repo.get_checkout_target()
2339                         env = "base" if tgt == repo.base else tgt
2340                 if repo._mountpoint:
2341                     if self.link_mountpoint(repo):
2342                         self.pillar_dirs[repo.linkdir] = env
2343                         self.pillar_linked_dirs.append(repo.linkdir)
2344                 else:
2345                     self.pillar_dirs[cachedir] = env
2346     def link_mountpoint(self, repo):
2347         lcachelink = salt.utils.path.join(repo.linkdir, repo._mountpoint)
2348         lcachedest = salt.utils.path.join(repo.cachedir, repo.root()).rstrip(os.sep)
2349         wipe_linkdir = False
2350         create_link = False
2351         try:
2352             with repo.gen_lock(lock_type="mountpoint", timeout=10):
2353                 walk_results = list(os.walk(repo.linkdir, followlinks=False))
2354                 if walk_results != repo.linkdir_walk:
2355                     log.debug(
2356                         "Results of walking %s differ from expected results",
2357                         repo.linkdir,
2358                     )
2359                     log.debug("Walk results: %s", walk_results)
2360                     log.debug("Expected results: %s", repo.linkdir_walk)
2361                     wipe_linkdir = True
2362                 else:
2363                     if not all(
2364                         not salt.utils.path.islink(x[0]) and os.path.isdir(x[0])
2365                         for x in walk_results[:-1]
2366                     ):
2367                         log.debug(
2368                             "Linkdir parents of %s are not all directories", lcachelink
2369                         )
2370                         wipe_linkdir = True
2371                     elif not salt.utils.path.islink(lcachelink):
2372                         wipe_linkdir = True
2373                     else:
2374                         try:
2375                             ldest = salt.utils.path.readlink(lcachelink)
2376                         except Exception:  # pylint: disable=broad-except
2377                             log.debug("Failed to read destination of %s", lcachelink)
2378                             wipe_linkdir = True
2379                         else:
2380                             if ldest != lcachedest:
2381                                 log.debug(
2382                                     "Destination of %s (%s) does not match "
2383                                     "the expected value (%s)",
2384                                     lcachelink,
2385                                     ldest,
2386                                     lcachedest,
2387                                 )
2388                                 try:
2389                                     if (
2390                                         salt.utils.platform.is_windows()
2391                                         and not ldest.startswith("\\\\")
2392                                         and os.path.isdir(ldest)
2393                                     ):
2394                                         shutil.rmtree(lcachelink)
2395                                     else:
2396                                         os.remove(lcachelink)
2397                                 except Exception as exc:  # pylint: disable=broad-except
2398                                     log.exception(
2399                                         "Failed to remove existing git_pillar "
2400                                         "mountpoint link %s: %s",
2401                                         lcachelink,
2402                                         exc.__str__(),
2403                                     )
2404                                 wipe_linkdir = False
2405                                 create_link = True
2406                 if wipe_linkdir:
2407                     create_link = True
2408                     try:
2409                         shutil.rmtree(repo.linkdir)
2410                     except OSError:
2411                         pass
2412                     try:
2413                         ldirname = os.path.dirname(lcachelink)
2414                         os.makedirs(ldirname)
2415                         log.debug("Successfully made linkdir parent %s", ldirname)
2416                     except OSError as exc:
2417                         log.error(
2418                             "Failed to os.makedirs() linkdir parent %s: %s",
2419                             ldirname,
2420                             exc.__str__(),
2421                         )
2422                         return False
2423                 if create_link:
2424                     try:
2425                         os.symlink(lcachedest, lcachelink)
2426                         log.debug(
2427                             "Successfully linked %s to cachedir %s",
2428                             lcachelink,
2429                             lcachedest,
2430                         )
2431                         return True
2432                     except OSError as exc:
2433                         log.error(
2434                             "Failed to create symlink to %s at path %s: %s",
2435                             lcachedest,
2436                             lcachelink,
2437                             exc.__str__(),
2438                         )
2439                         return False
2440         except GitLockError:
2441             log.error(
2442                 "Timed out setting mountpoint lock for %s remote '%s'. If "
2443                 "this error persists, it may be because an earlier %s "
2444                 "checkout was interrupted. The lock can be cleared by running "
2445                 "'salt-run cache.clear_git_lock %s type=mountpoint', or by "
2446                 "manually removing %s.",
2447                 self.role,
2448                 repo.id,
2449                 self.role,
2450                 self.role,
2451                 repo._get_lock_file(lock_type="mountpoint"),
2452             )
2453             return False
2454         return True
2455 class WinRepo(GitBase):
2456     role = "winrepo"
2457     winrepo_dirs = {}
2458     def checkout(self):
2459         self.winrepo_dirs = {}
2460         for repo in self.remotes:
2461             cachedir = self.do_checkout(repo)
2462             if cachedir is not None:
2463                 self.winrepo_dirs[repo.id] = cachedir
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
