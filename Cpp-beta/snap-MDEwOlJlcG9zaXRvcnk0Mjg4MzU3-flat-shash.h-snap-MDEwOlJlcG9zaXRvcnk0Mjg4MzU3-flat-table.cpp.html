
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.011268597587815%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-shash.h</h3>
            <pre><code>1  #ifndef shash_h
2  #define shash_h
3  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
4  class TKeyDatFl {
5  private:
6    TInt ElemCnt;
7    TFIn FIn;
8    TKey Key;
9    TDat Dat;
10  public:
11    TKeyDatFl(const TStr& FNm) : FIn(FNm) { ElemCnt.Load(FIn); }
12    int Len() const { return ElemCnt; }
13    bool Next() { if (FIn.Eof()) { return false; }
14      Key.Load(FIn);  Dat.Load(FIn); return true; }
15    const TKey& GetKey() const { return Key; }
16    TKey& GetKey() { return Key; }
17    const TDat& GetDat() const { return Dat; }
18    TDat& GetDat() { return Dat; }
19    static void Save(const TStr& OutFNm, const THash<TKey, TDat, THashFunc>& Hash) {
20      TFOut FOut(OutFNm);  Load(FOut, Hash); }
21    static void Save(TSOut& SOut, const THash<TKey, TDat, THashFunc>& Hash) {
22      SOut.Save(Hash.Len());
23      for (int k = Hash.FFirstKeyId(); Hash.FNextKeyId(k); ) {
24        Hash.GetKey(k).Save(SOut);  Hash[k].Save(SOut); }
25    }
26    static void LoadHash(const TStr& InFNm, THash<TKey, TDat, THashFunc>& Hash, const int& LoadN=-1) {
27      TFIn FIn(InFNm);  Load(FIn, Hash, LoadN); }
28    static void LoadHash(TSIn& SIn, THash<TKey, TDat, THashFunc>& Hash, int LoadN=-1) {
29      TInt ElemCnt(SIn);  const int Start=clock();
30      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
31      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  Hash.Gen(LoadN);
32      for (int i = 0; i < LoadN; i++) { Hash.AddDat(TKey(SIn)).Load(SIn); }
33      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
34    }
35    static void LoadKeyV(TSIn& SIn, TVec<TKey>& KeyV, int LoadN=-1) {
36      TInt ElemCnt(SIn);  const int Start=clock();
37      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
38      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  KeyV.Gen(LoadN, 0);
39      for (int i = 0; i < LoadN; i++) { KeyV.Add(TKey(SIn));  TDat D(SIn); }
40      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
41    }
42    static void LoadDatV(TSIn& SIn, TVec<TDat>& DatV, int LoadN=-1) {
43      TInt ElemCnt(SIn);  const int Start=clock();
44      if (ElemCnt < LoadN || LoadN == -1) { LoadN = ElemCnt; }
45      printf("Loading %s: %d elements ... ", SIn.GetSNm().CStr(), LoadN);  DatV.Gen(LoadN, 0);
46      for (int i = 0; i < LoadN; i++) { TKey(SIn);  DatV.Add(TDat(SIn)); }
47      printf(" [%ds]\n", int((clock()-Start)/CLOCKS_PER_SEC));
48    }
49  };
50  template <class TVal, uint16 GroupSize> 
51  class TSparseGroup {
52  private:
53    unsigned char BitSet [(GroupSize-1)/8 + 1];   
54    uint16 Buckets;                               
55    TVal *Group;
56  private:
57    static int CharBit(const int&  ValN) { return ValN >> 3; }
58    static int ModBit(const int&  ValN) { return 1 << (ValN&7); }
59    bool BMTest(const int&  ValN) const { return (BitSet[CharBit(ValN)] & ModBit(ValN)) != 0; }
60    void BMSet(const int&  ValN) { BitSet[CharBit(ValN)] |= ModBit(ValN); }
61    void BMClear(const int&  ValN) { BitSet[CharBit(ValN)] &= ~ModBit(ValN); }
62    static int PosToOffset(const unsigned char *BitSet, int Pos);
63  public:
64    TSparseGroup() : Buckets(0), Group(NULL) { memset(BitSet, 0, sizeof(BitSet)); }
65    TSparseGroup(TSIn& SIn) : Buckets(0), Group(NULL) { Load(SIn); }
66    TSparseGroup(const TSparseGroup& SG);
67    ~TSparseGroup() { if (Group != NULL) delete [] Group; }
68    void Load(TSIn& SIn);
69    void Save(TSOut& SOut) const;
70    TSparseGroup& operator = (const TSparseGroup& SG);
71    bool operator == (const TSparseGroup& SG) const;
72    bool operator < (const TSparseGroup& SG) const;
73    int Len() const { return Buckets; }
74    int MxLen() const { return GroupSize; }
75    int Reserved() const { return GroupSize; }
76    bool Empty() const { return Buckets == 0; }
77    void Clr(const bool& DoDel = true);
78    int GetGroupSize() const { return GroupSize; }
79    uint GetDiskSz() const { return sizeof(BitSet) + sizeof(uint16) + Buckets*sizeof(TVal); }
80    bool IsEmpty(const int& ValN) const { return ! BMTest(ValN); }
81    const TVal& Offset(const int& Pos) const { return Group[Pos]; }
82    TVal& Offset(const int& Pos) { return Group[Pos]; }
83    int OffsetToPos(int Offset) const;
84    int PosToOffset(int Pos) const { return PosToOffset(BitSet, Pos); }
85    const TVal& DefVal() const { static TVal DefValue = TVal();  return DefValue; }
86    const TVal& Get(const int& ValN) const {
87      if (BMTest(ValN)) return Group[PosToOffset(BitSet, ValN)]; else return DefVal(); }
88    const TVal& operator [] (const int ValN) const { return Get(ValN); }
89    TVal& Set(const int& ValN, const TVal& Val);
90    TVal& Set(const int& ValN) {
91      if (! BMTest(ValN)) Set(ValN, DefVal());
92      return Group[PosToOffset(BitSet, ValN)];
93    }
94    void Del(const int& ValN);
95  };
96  template <class TVal, uint16 GroupSize>
97  int TSparseGroup<TVal, GroupSize>::PosToOffset(const unsigned char *BitSet, int Pos) {
98    static const int bits_in [256] = {      
99      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
100      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
101      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
102      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
103      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
104      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
105      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
106      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
107      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
108      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
109      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
110      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
111      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
112      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
113      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
114      4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
115    };
116    int Offset = 0;
117    for ( ; Pos > 8; Pos -= 8 )                        
118      Offset += bits_in[*BitSet++];                    
119    return Offset + bits_in[*BitSet & ((1 << Pos)-1)]; 
120  }
121  template <class TVal, uint16 GroupSize>
122  TSparseGroup<TVal, GroupSize>::TSparseGroup(const TSparseGroup& SG) : Buckets(SG.Buckets), Group(NULL) {
123    memcpy(BitSet, SG.BitSet, sizeof(BitSet));
124    if (Buckets > 0) {
125      Group = new TVal [Buckets];
126      for (int b = 0; b < Buckets; b++) { Group[b] = SG.Group[b]; }
127    }
128  }
129  template <class TVal, uint16 GroupSize>
130  void TSparseGroup<TVal, GroupSize>::Load(TSIn& SIn) {
131    SIn.LoadBf(BitSet, sizeof(BitSet));
132    SIn.Load(Buckets);
133    if (Group != NULL) delete [] Group;
134    Group = new TVal [Buckets];
135    for (int b = 0; b < Buckets; b++) { Group[b] = TVal(SIn); }
136  }
137  template <class TVal, uint16 GroupSize>
138  void TSparseGroup<TVal, GroupSize>::Save(TSOut& SOut) const {
139    SOut.SaveBf(BitSet, sizeof(BitSet));
140    SOut.Save(Buckets);
141    for (int b = 0; b < Buckets; b++) { Group[b].Save(SOut); }
142  }
143  template <class TVal, uint16 GroupSize>
144  TSparseGroup<TVal, GroupSize>& TSparseGroup<TVal, GroupSize>::operator = (const TSparseGroup& SG) {
145    if (this != &SG) {
146      if (SG.Buckets == 0 && Group != NULL) {
147        delete [] Group;
148        Group = 0;
149      } else {
150        if (Buckets != SG.Buckets) {
151          if (Group != NULL) delete [] Group;
152          Group = new TVal [SG.Buckets];
153        }
154        for (int b = 0; b < SG.Buckets; b++) { Group[b] = SG.Group[b]; }
155      }
156      Buckets = SG.Buckets;
157      memcpy(BitSet, SG.BitSet, sizeof(BitSet));
158    }
159    return *this;
160  }
161  template <class TVal, uint16 GroupSize>
162  bool TSparseGroup<TVal, GroupSize>::operator == (const TSparseGroup& SG) const {
163    if (Buckets == SG.Buckets && memcmp(BitSet, SG.BitSet, sizeof(BitSet)) == 0) {
164      for (int b = 0; b < Buckets; b++) {
165        if (Group[b] != SG.Group[b]) return false;
166      }
167      return true;
168    }
169    return false;
170  }
171  template <class TVal, uint16 GroupSize>
172  bool TSparseGroup<TVal, GroupSize>::operator < (const TSparseGroup& SG) const {
173    if (Buckets < SG.Buckets) return true;
174    if (memcmp(BitSet, SG.BitSet, sizeof(BitSet)) == -1) return true;
175    for (int b = 0; b < Buckets; b++) {
176      if (Group[b] < SG.Group[b]) return true;
177    }
178    return false;
179  }
180  template <class TVal, uint16 GroupSize>
181  int TSparseGroup<TVal, GroupSize>::OffsetToPos(int Offset) const {
182    Assert(Offset < Buckets);
183    for (int i = 0; i < sizeof(BitSet); i++) {
184      for (int b = 0; b < 8; b++) {
185        if (TB1Def::GetBit(b, BitSet[i])) {
186          if (Offset == 0) return i*8 + b;
187          Offset--;
188        }
189      }
190    }
191    Fail;
192    return -1;
193  }
194  template <class TVal, uint16 GroupSize>
195  void TSparseGroup<TVal, GroupSize>::Clr(const bool& DoDel) {
196    if (DoDel && Group != NULL) {
197      delete [] Group;
198      Group = 0;
199    }
200    memset(BitSet, 0, sizeof(BitSet));
201    Buckets = 0;
202  }
203  template <class TVal, uint16 GroupSize>
204  TVal& TSparseGroup<TVal, GroupSize>::Set(const int& ValN, const TVal& Val) {
205    const int Offset = PosToOffset(BitSet, ValN);
206    if (! BMTest(ValN)) {
207      const TVal *OldGroup = Group;
208      Group = new TVal [Buckets+1];
209      for (int b = 0; b < Offset; b++) Group[b] = OldGroup[b];
210      for (int b = Offset+1; b <= Buckets; b++) Group[b] = OldGroup[b-1];
211      if (OldGroup != NULL) delete [] OldGroup;
212      Buckets++;
213      BMSet(ValN);
214    }
215    Group[Offset] = Val;
216    return Group[Offset];
217  }
218  template <class TVal, uint16 GroupSize>
219  void TSparseGroup<TVal, GroupSize>::Del(const int& ValN) {
220    if (BMTest(ValN)) {
221      const int Offset = PosToOffset(BitSet, ValN);
222      if (--Buckets == 0) {
223        delete [] Group;
224        Group = 0;
225      } else {
226        const TVal *OldGroup = Group;
227        Group = new TVal [Buckets];
228        for (int b = 0; b < Offset; b++) Group[b] = OldGroup[b];
229        for (int b = Offset+1; b <= Buckets; b++) Group[b-1] = OldGroup[b];
230        if (OldGroup != NULL) delete [] OldGroup;
231      }
232      BMClear(ValN);
233    }
234  }
235  template <class TVal, uint16 GroupSize>
236  class TSparseTableI {
237  private:
238    typedef TSparseGroup<TVal, GroupSize> TValGroup;
239    typedef typename TVec<TValGroup>::TIter TGroupVI;
240    int CurOff; 
241    TGroupVI BegI, GroupI, EndI;
242  public:
243    TSparseTableI() : CurOff(0), GroupI(NULL), EndI(NULL) { }
244    TSparseTableI(const TGroupVI& BegIter, const TGroupVI& CurIter, const TGroupVI& EndIter,
245      const int& Offset = 0) : CurOff(Offset), BegI(BegIter), GroupI(CurIter), EndI(EndIter) { }
246    TSparseTableI(const TSparseTableI& STI) :
247      CurOff(STI.CurOff), BegI(STI.BegI), GroupI(STI.GroupI), EndI(STI.EndI) { }
248    TSparseTableI& operator = (const TSparseTableI& STI) {
249      CurOff=STI.CurOff;  BegI=STI.BegI;  GroupI=STI.GroupI;  EndI=STI.EndI;  return *this; }
250    bool operator == (const TSparseTableI& STI) const {
251      return GroupI == STI.GroupI && CurOff == STI.CurOff; }
252    bool operator < (const TSparseTableI& STI) const {
253      return GroupI < STI.GroupI || (GroupI == STI.GroupI && CurOff < STI.CurOff); }
254    TSparseTableI& operator++ (int) {
255      if (CurOff+1 == GroupI->Len()) { CurOff = 0;
256        if (GroupI < EndI) { GroupI++;
257          while (GroupI < EndI && GroupI->Empty()) { GroupI++; } }
258      } else { CurOff++; }
259      return *this;
260    }
261    TSparseTableI& operator-- (int) {
262      if (CurOff == 0) {
263        while (GroupI >= BegI && GroupI->Empty()) { GroupI--; }
264        if (GroupI >= BegI) CurOff = GroupI->Len()-1;
265      } else { CurOff--; }
266      return *this;
267    }
268    int GetValN() const { return int(GroupI-BegI)*GroupSize + GroupI->OffsetToPos(CurOff); }
269    bool IsEnd() const { return GroupI==EndI; }
270    TVal& operator*() const { return GroupI->Offset(CurOff); }
271    TVal& operator()() const { return GroupI->Offset(CurOff); }
272    TVal* operator->() const { return &(operator*()); }
273  };
274  template <class TVal, uint16 GroupSize = 48> 
275  class TSparseTable {
276  public:
277    typedef TSparseGroup<TVal, GroupSize> TSGroup;
278    typedef TSparseTableI<TVal, GroupSize> TIter;
279  private:
280    TInt MxVals, Vals;
281    TVec<TSGroup> GroupV;
282  private:
283    static int GetGroups(const int& Vals) { return Vals == 0 ? 0 : ((Vals-1) / GroupSize) + 1; }
284    int PosInGroup(const int& ValN) const { return ValN % GroupSize; }
285    int GroupNum(const int& ValN) const { return ValN / GroupSize; }
286    const TSGroup& GetGrp1(const int& ValN) const { return GroupV[GroupNum(ValN)]; }
287    TSGroup& GetGrp1(const int& ValN) { return GroupV[GroupNum(ValN)]; }
288  public:
289    TSparseTable(const int& MaxVals = 0) : MxVals(MaxVals),
290      Vals(0), GroupV(GetGroups(MaxVals), GetGroups(MaxVals)) { }
291    TSparseTable(const TSparseTable& ST) : MxVals(ST.MxVals), Vals(ST.Vals), GroupV(ST.GroupV) { }
292    TSparseTable(TSIn& SIn) : MxVals(SIn), Vals(SIn), GroupV(SIn) { }
293    void Load(TSIn& SIn) { MxVals.Load(SIn);  Vals.Load(SIn);  GroupV.Load(SIn); }
294    void Save(TSOut& SOut) const { MxVals.Save(SOut);  Vals.Save(SOut);  GroupV.Save(SOut); }
295    TSparseTable& operator = (const TSparseTable& ST);
296    bool operator == (const TSparseTable& ST) const;
297    bool operator < (const TSparseTable& ST) const;
298    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Vals*sizeof(TVal)+GroupV.GetMemUsed(); }
299    TIter BegI() const {
300      if (Len() > 0) { int B = 0;
301        while (B < Groups() && GroupV[B].Empty()) { B++; }
302        return TIter(GroupV.BegI(), GroupV.BegI()+B, GroupV.EndI()); }
303      return TIter(GroupV.BegI(), GroupV.EndI(), GroupV.EndI());
304    }
305    TIter EndI() const { return TIter(GroupV.BegI(), GroupV.EndI(), GroupV.EndI()); }
306    TIter GetI(const int& ValN) const { Assert(! IsEmpty(ValN));
307      typedef typename TVec<TSGroup>::TIter TVIter;
308      const TVIter GI = GroupV.GetI(GroupNum(ValN));
309      return TIter(GroupV.BegI(), GI, GroupV.EndI(), GI->PosToOffset(PosInGroup(ValN)));
310    }
311    int Len() const { return Vals; }
312    int Reserved() const { return MxVals; }
313    int Groups() const { return GroupV.Len(); }
314    bool Empty() const { return Vals == 0; }
315    uint GetDiskSz() const {
316      return sizeof(TInt)*4 + ((GroupSize+16)/8)*Groups() + sizeof(TVal)*Vals; }
317    void Clr(const bool& DoDel = true);
318    void Reserve(const int NewVals) { Resize(NewVals); }
319    void Resize(const int& NewVals);
320    void Swap(TSparseTable& ST);
321    bool IsEmpty(const int& ValN) const { return GroupV[GroupNum(ValN)].IsEmpty(PosInGroup(ValN)); }
322    const TVal& Get(const int& ValN) const { return GroupV[GroupNum(ValN)].Get(PosInGroup(ValN)); }
323    TVal& Set(const int& ValN, const TVal& Val);
324    TVal& Set(const int& ValN);
325    void Del(const int& ValN);
326    TSGroup& GetGroup(const int& GroupN) { return GroupV[GroupN]; }
327    const TSGroup& GetGroup(const int& GroupN) const { return GroupV[GroupN]; }
328  };
329  template <class TVal, uint16 GroupSize>
330  TSparseTable<TVal, GroupSize>& TSparseTable<TVal, GroupSize>::operator = (const TSparseTable& ST) {
331    if (this != &ST) {
332      MxVals = ST.MxVals;
333      Vals = ST.Vals;
334      GroupV = ST.GroupV;
335    }
336    return *this;
337  }
338  template <class TVal, uint16 GroupSize>
339  bool TSparseTable<TVal, GroupSize>::operator == (const TSparseTable& ST) const {
340    return Vals == ST.Vals && MxVals == ST.MxVals && GroupV == ST.GroupV;
341  }
342  template <class TVal, uint16 GroupSize>
343  bool TSparseTable<TVal, GroupSize>::operator < (const TSparseTable& ST) const {
344    return Vals < ST.Vals || (Vals == ST.Vals && GroupV < ST.GroupV);
345  }
346  template <class TVal, uint16 GroupSize>
347  void TSparseTable<TVal, GroupSize>::Clr(const bool& DoDel) {
348    if (! DoDel) {
349      for (int g = 0; g < GroupV.Len(); g++) GroupV[g].Clr(false);
350    } else {
351      MxVals = 0;
352      GroupV.Clr(true);
353    }
354    Vals = 0;
355  }
356  template <class TVal, uint16 GroupSize>
357  void TSparseTable<TVal, GroupSize>::Resize(const int& NewVals) {
358    if (NewVals > MxVals) {
359      const int Groups = GetGroups(NewVals);
360      GroupV.Reserve(Groups, Groups);
361      MxVals = NewVals;
362    }
363  }
364  template <class TVal, uint16 GroupSize>
365  void TSparseTable<TVal, GroupSize>::Swap(TSparseTable& ST) {
366    ::Swap(MxVals, ST.MxVals);
367    ::Swap(Vals, ST.Vals);
368    GroupV.Swap(ST.GroupV);
369  }
370  template <class TVal, uint16 GroupSize>
371  TVal& TSparseTable<TVal, GroupSize>::Set(const int& ValN, const TVal& Val) {
372    Assert(ValN < MxVals);
373    TSGroup& Group = GetGrp1(ValN);
374    const int OldVals = Group.Len();
375    TVal& ValRef = Group.Set(PosInGroup(ValN), Val);
376    Vals += Group.Len() - OldVals;
377    return ValRef;
378  }
379  template <class TVal, uint16 GroupSize>
380  TVal& TSparseTable<TVal, GroupSize>::Set(const int& ValN) {
381    Assert(ValN < MxVals);
382    TSGroup& Group = GetGrp1(ValN);
383    const int OldVals = Group.Len();
384    TVal& ValRef = Group.Set(PosInGroup(ValN));
385    Vals += Group.Len() - OldVals;
386    return ValRef;
387  }
388  template <class TVal, uint16 GroupSize>
389  void TSparseTable<TVal, GroupSize>::Del(const int& ValN) {
390    Assert(ValN < MxVals);
391    TSGroup& Group = GetGrp1(ValN);
392    const int OldVals = Group.Len();
393    Group.Del(PosInGroup(ValN));
394    Vals += Group.Len() - OldVals;
395  }
396  #pragma pack(push, 1) 
397  template <class TKey, class TDat>
398  class TSHashKeyDat {
399  public:
400    TKey Key;
401    TDat Dat;
402  public:
403    TSHashKeyDat() : Key(), Dat() { }
404    TSHashKeyDat(const TKey& _Key) : Key(_Key), Dat() { }
405    TSHashKeyDat(const TKey& _Key, const TDat& _Dat) : Key(_Key), Dat(_Dat) { }
406    TSHashKeyDat(const TSHashKeyDat& HashKeyDat) : Key(HashKeyDat.Key), Dat(HashKeyDat.Dat) { }
407    explicit TSHashKeyDat(TSIn& SIn) : Key(SIn), Dat(SIn) { }
408    void Save(TSOut& SOut) const { Key.Save(SOut);  Dat.Save(SOut); }
409    TSHashKeyDat& operator = (const TSHashKeyDat& HashKeyDat) { if (this != &HashKeyDat) {
410      Key = HashKeyDat.Key;  Dat = HashKeyDat.Dat; }  return *this; }
411    bool operator == (const TSHashKeyDat& HashKeyDat) const { return Key == HashKeyDat.Key; }
412    bool operator < (const TSHashKeyDat& HashKeyDat) const { return Key < HashKeyDat.Key; }
413    int Hash() const { return Key.GetPrimHashCd(); }
414  };
415  #pragma pack(pop)
416  template <class TKey, class TDat, uint16 GroupSize=48> 
417  class TSparseHash {
418  public:
419    typedef TSHashKeyDat<TKey, TDat> THashKeyDat;
420    typedef typename TSparseTable<THashKeyDat, GroupSize>::TIter TIter;
421    typedef typename TSparseTable<THashKeyDat, GroupSize>::TSGroup TSGroup;
422  public:
423    static const float MxOccupancy; 
424    static const float MnOccupancy; 
425    static const int MinBuckets;    
426  private:
427    void ResetThresh();
428    int GetMinSize(const int& CurVals, const int& WantedVals) const;
429    void CopyFrom(const TSparseHash& HT, const int& MnWanted);
430    void MoveFrom(TSparseHash& HT, const int& MnWanted);
431    void ResizeDelta(const int& ValsToAdd, const int& MnWanted = 0);
432    void FindPos(const TKey& Key, int& Pos, int& PosToIns) const;
433  private:
434    TInt ShrinkThresh, ExpandThresh;
435    TSparseTable<THashKeyDat, GroupSize> Table;
436  public:
437    TSparseHash(const int& WantedVals = 0) : Table(GetMinSize(0, WantedVals)) { ResetThresh(); }
438    TSparseHash(TSIn& SIn) : ShrinkThresh(SIn), ExpandThresh(SIn), Table(SIn) { }
439    void Load(TSIn& SIn) { ShrinkThresh.Load(SIn);  ExpandThresh.Load(SIn);  Table.Load(SIn); }
440    void Save(TSOut& SOut) const { ShrinkThresh.Save(SOut); ExpandThresh.Save(SOut); Table.Save(SOut); }
441    TSparseHash& operator = (const TSparseHash& SHT);
442    bool operator == (const TSparseHash& SHT) const;
443    bool operator < (const TSparseHash& SHT) const;
444    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Table.GetMemUsed(); }
445    TIter BegI() const { return Table.BegI(); }
446    TIter EndI() const { return Table.EndI(); }
447    TIter GetI(const TKey& Key) const { Assert(IsKey(Key));  return Table.GetI(GetKeyId(Key)); }
448    bool Empty() const { return Len() == 0; }
449    int Len() const { return Table.Len(); }
450    int Reserved() const  { return Table.Reserved(); }
451    uint GetDiskSz() const { return 2*sizeof(TInt) + Table.GetDiskSz(); }
452    void Reserve(const int& MxVals) { if (MxVals > Len()) ResizeDelta(MxVals - Len(), 0); }
453    void Clr(const bool& DoDel = true) { Table.Clr(DoDel);  ResetThresh(); }
454    void Swap(TSparseHash& HT);
455    int AddKey(const TKey& Key);
456    TDat& AddDat(const TKey& Key);
457    TDat& AddDat(const TKey& Key, const TDat& Dat);
458    const TKey& GetKey(const int& KeyId) const { return Table.Get(KeyId).Key; }
459    int GetKeyId(const TKey& Key) const {
460      int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);  return Pos; }
461    bool IsKey(const TKey& Key) const { return GetKeyId(Key) != -1; }
462    bool IsKey(const TKey& Key, int& KeyId) const {
463      KeyId = GetKeyId(Key);  return KeyId != -1; }
464    bool IsKeyId(const int& KeyId) const { return ! Table.IsEmpty(KeyId); }
465    int GetRndKeyId(TRnd& Rnd = TInt::Rnd) const { Assert(Len()>0);
466      int KeyId = Rnd.GetUniDevInt(Reserved());
467      while (! IsKeyId(KeyId)) { KeyId = Rnd.GetUniDevInt(Reserved()); } return KeyId; }
468    const TDat& GetDat(const TKey& Key) const;
469    TDat& GetDat(const TKey& Key);
470    const TDat& GetDatKeyId(const int& KeyId) const { return Table.Get(KeyId).Dat; }
471    TDat& GetDatKeyId(const int& KeyId) { return Table.Set(KeyId).Dat; }
472    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const;
473    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const;
474    void GetKeyV(TVec<TKey>& KeyV) const;
475    void GetDatV(TVec<TDat>& DatV) const;
476    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
477    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
478  };
479  template <class TKey, class TDat, uint16 GroupSize>
480  const float TSparseHash<TKey, TDat, GroupSize>::MxOccupancy = 0.8f; 
481  template <class TKey, class TDat, uint16 GroupSize>
482  const float TSparseHash<TKey, TDat, GroupSize>::MnOccupancy = 0.4f * 0.8f; 
483  template <class TKey, class TDat, uint16 GroupSize>
484  const int TSparseHash<TKey, TDat, GroupSize>::MinBuckets = 32;
485  template <class TKey, class TDat, uint16 GroupSize>
486  void TSparseHash<TKey, TDat, GroupSize>::ResetThresh() {
487    ExpandThresh = int(Table.Reserved() * MxOccupancy);
488    ShrinkThresh = int(Table.Reserved() * MnOccupancy);
489  }
490  template <class TKey, class TDat, uint16 GroupSize>
491  int TSparseHash<TKey, TDat, GroupSize>::GetMinSize(const int& CurVals, const int& WantedVals) const {
492    int Size = MinBuckets;
493    while (Size*MxOccupancy < WantedVals || CurVals >= Size * MxOccupancy) Size *= 2;
494    return Size;
495  }
496  template <class TKey, class TDat, uint16 GroupSize>
497  void TSparseHash<TKey, TDat, GroupSize>::CopyFrom(const TSparseHash& HT, const int& MnWanted) {
498    Clr(false);
499    const int NewSize = GetMinSize(HT.Reserved(), MnWanted);
500    if (NewSize > Reserved()) {
501      Table.Resize(NewSize);
502      ResetThresh();
503    }
504    const uint BuckM1 = Reserved() - 1;
505    for (int g = 0; g < HT.Table.Groups(); g++) {
506      const TSGroup& Group = HT.Table.GetGroup(g);
507      for (int b = 0; b < Group.Len(); b++) {
508        int Tries = 0; uint BuckNum;
509        for (BuckNum = Group.Offset(b).Hash() & BuckM1;
510         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
511          Tries++;
512          Assert(Tries < Reserved());
513        }
514        Table.Set(BuckNum, Group.Offset(b));
515      }
516    }
517  }
518  template <class TKey, class TDat, uint16 GroupSize>
519  void TSparseHash<TKey, TDat, GroupSize>::MoveFrom(TSparseHash& HT, const int& MnWanted) {
520    Clr(false);
521    int NewSize;
522    if (MnWanted == 0) NewSize = HT.Reserved();
523    else NewSize = GetMinSize(HT.Reserved(), MnWanted);
524    if (NewSize > Reserved()) {
525      Table.Resize(NewSize);
526      ResetThresh();
527    }
528    const uint BuckM1 = Reserved() - 1;
529    for (int g = 0; g < HT.Table.Groups(); g++) {
530      TSGroup& Group = HT.Table.GetGroup(g);
531      for (int b = 0; b < Group.Len(); b++) {
532        int Tries = 0; uint BuckNum;
533        for (BuckNum = Group.Offset(b).Hash() & BuckM1;
534         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
535          Tries++;
536          Assert(Tries < Reserved());
537        }
538        Assert(Table.IsEmpty(BuckNum));
539        Table.Set(BuckNum, Group.Offset(b));
540      }
541      Group.Clr(true); 
542    }
543  }
544  template <class TKey, class TDat, uint16 GroupSize>
<span onclick='openModal()' class='match'>545  void TSparseHash<TKey, TDat, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
546    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
547    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
</span>548    if (NewSize > Reserved()) {
549      printf("***Resize SparseHash:%d->%d\n", Reserved(), NewSize);
550      TSparseHash TmpHt(ValsToAdd+Len());
551      TmpHt.ResetThresh();
552      TmpHt.MoveFrom(*this, Len());
553      Swap(TmpHt);
554    }
555  }
556  template <class TKey, class TDat, uint16 GroupSize>
557  void TSparseHash<TKey, TDat, GroupSize>::FindPos(const TKey& Key, int& Pos, int& PosToIns) const {
558    const uint BuckM1 = Reserved() - 1;
559    uint BuckNum = Key.GetPrimHashCd() & BuckM1;
560    int Tries = 0;
561    while (true) {
562      if (Table.IsEmpty(BuckNum)) {
563        Pos = -1;  PosToIns = BuckNum;  return;
564      }
565      else if (Key == Table.Get(BuckNum).Key) {
566        Pos = BuckNum;  PosToIns = -1;  return;
567      }
568      Tries++;
569      BuckNum = (BuckNum + Tries) & BuckM1;
570      Assert(Tries < Reserved());
571    }
572  }
573  template <class TKey, class TDat, uint16 GroupSize>
574  TSparseHash<TKey, TDat, GroupSize>& TSparseHash<TKey, TDat, GroupSize>::operator = (const TSparseHash& SHT) {
575    if (this != &SHT) {
576      ShrinkThresh = SHT.ShrinkThresh;
577      ExpandThresh = SHT.ExpandThresh;
578      Table = SHT.Table;
579    }
580    return *this;
581  }
582  template <class TKey, class TDat, uint16 GroupSize>
583  bool TSparseHash<TKey, TDat, GroupSize>::operator == (const TSparseHash& SHT) const {
584    return Table == SHT.Table;
585  }
586  template <class TKey, class TDat, uint16 GroupSize>
587  bool TSparseHash<TKey, TDat, GroupSize>::operator < (const TSparseHash& SHT) const {
588    return Table < SHT.Table;
589  }
590  template <class TKey, class TDat, uint16 GroupSize>
591  void TSparseHash<TKey, TDat, GroupSize>::Swap(TSparseHash& HT) {
592    ::Swap(ShrinkThresh, HT.ShrinkThresh);
593    ::Swap(ExpandThresh, HT.ExpandThresh);
594    Table.Swap(HT.Table);
595  }
596  template <class TKey, class TDat, uint16 GroupSize>
597  int TSparseHash<TKey, TDat, GroupSize>::AddKey(const TKey& Key) {
598    ResizeDelta(1);
599    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
600    if (Pos != -1) { return Pos; } 
601    else {
602      Table.Set(PosToIns, THashKeyDat(Key));
603      return PosToIns;
604    }
605  }
606  template <class TKey, class TDat, uint16 GroupSize>
607  TDat& TSparseHash<TKey, TDat, GroupSize>::AddDat(const TKey& Key) {
608    ResizeDelta(1);
609    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
610    if (PosToIns != -1) {
611      return Table.Set(PosToIns, THashKeyDat(Key)).Dat;
612    } else { return Table.Set(Pos).Dat; }
613  }
614  template <class TKey, class TDat, uint16 GroupSize>
615  TDat& TSparseHash<TKey, TDat, GroupSize>::AddDat(const TKey& Key, const TDat& Dat) {
616    ResizeDelta(1);
617    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
618    if (PosToIns != -1) {
619      return Table.Set(PosToIns, THashKeyDat(Key, Dat)).Dat;
620    } else { return Table.Set(Pos).Dat = Dat; }
621  }
622  template <class TKey, class TDat, uint16 GroupSize>
623  const TDat& TSparseHash<TKey, TDat, GroupSize>::GetDat(const TKey& Key) const {
624    int Pos, PosToIns;
625    FindPos(Key, Pos, PosToIns);
626    Assert(Pos != -1);
627    return Table.Get(Pos).Dat;
628  }
629  template <class TKey, class TDat, uint16 GroupSize>
630  TDat& TSparseHash<TKey, TDat, GroupSize>::GetDat(const TKey& Key) {
631    int Pos, PosToIns;
632    FindPos(Key, Pos, PosToIns);
633    Assert(Pos != -1);
634    return Table.Set(Pos).Dat;
635  }
636  template <class TKey, class TDat, uint16 GroupSize>
637  void TSparseHash<TKey, TDat, GroupSize>::GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
638    Assert(IsKey(KeyId));
639    const THashKeyDat& KeyDat = Table.Get(KeyId);
640    Key = KeyDat.Key;
641    Dat = KeyDat.Dat;
642  }
643  template <class TKey, class TDat, uint16 GroupSize>
644  bool TSparseHash<TKey, TDat, GroupSize>::IsKeyGetDat(const TKey& Key, TDat& Dat) const {
645    int KeyId;
646    if (IsKey(Key, KeyId)) {
647      Dat=Table.Get(KeyId).Dat;
648      return true;
649    } else { return false; }
650  }
651  template <class TKey, class TDat, uint16 GroupSize>
652  void TSparseHash<TKey, TDat, GroupSize>::GetKeyV(TVec<TKey>& KeyV) const {
653    KeyV.Gen(Len(), 0);
654    for (TIter i = BegI(); i < EndI(); i++) {
655      KeyV.Add(i->Key);
656    }
657  }
658  template <class TKey, class TDat, uint16 GroupSize>
659  void TSparseHash<TKey, TDat, GroupSize>::GetDatV(TVec<TDat>& DatV) const {
660    DatV.Gen(Len(), 0);
661    for (TIter i = BegI(); i < EndI(); i++) {
662      DatV.Add(i->Dat);
663    }
664  }
665  template <class TKey, class TDat, uint16 GroupSize>
666  void TSparseHash<TKey, TDat, GroupSize>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
667    KeyDatPrV.Gen(Len(), 0);
668    for (TIter i = BegI(); i < EndI(); i++) {
669      KeyDatPrV.Add(TPair<TKey, TDat>(i->Key, i->Dat));
670    }
671  }
672  template <class TKey, class TDat, uint16 GroupSize>
673  void TSparseHash<TKey, TDat, GroupSize>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
674    DatKeyPrV.Gen(Len(), 0);
675    for (TIter i = BegI(); i < EndI(); i++) {
676      DatKeyPrV.Add(TPair<TDat, TKey>(i->Dat, i->Key));
677    }
678  }
679  template <class TKey, uint16 GroupSize=48> 
680  class TSparseSet {
681  public:
682    typedef typename TSparseTable<TKey, GroupSize>::TIter TIter;
683    typedef typename TSparseTable<TKey, GroupSize>::TSGroup TSGroup;
684  public:
685    static const float MxOccupancy; 
686    static const float MnOccupancy; 
687    static const int MinBuckets;    
688  private:
689    void ResetThresh();
690    int GetMinSize(const int& CurVals, const int& WantedVals) const;
691    void CopyFrom(const TSparseSet& SSet, const int& MnWanted);
692    void MoveFrom(TSparseSet& SSet, const int& MnWanted);
693    void ResizeDelta(const int& ValsToAdd, const int& MnWanted = 0);
694    void FindPos(const TKey& Key, int& Pos, int& PosToIns) const;
695  private:
696    TInt ShrinkThresh, ExpandThresh;
697    TSparseTable<TKey, GroupSize> Table;
698  public:
699    TSparseSet(const int& WantedVals = 0) : Table(GetMinSize(0, WantedVals)) { ResetThresh(); }
700    TSparseSet(TSIn& SIn) : ShrinkThresh(SIn), ExpandThresh(SIn), Table(SIn) { }
701    void Load(TSIn& SIn) { ShrinkThresh.Load(SIn);  ExpandThresh.Load(SIn);  Table.Load(SIn); }
702    void Save(TSOut& SOut) const { ShrinkThresh.Save(SOut); ExpandThresh.Save(SOut); Table.Save(SOut); }
703    TSparseSet& operator = (const TSparseSet& SSet);
704    bool operator == (const TSparseSet& SSet) const;
705    bool operator < (const TSparseSet& SSet) const;
706    ::TSize GetMemUsed() const { return 2*sizeof(TInt)+Table.GetMemUsed(); }
707    TIter BegI() const { return Table.BegI(); }
708    TIter EndI() const { return Table.EndI(); }
709    TIter GetI(const int& KeyId) const { Assert(IsKeyId(KeyId));  return Table.GetI(KeyId); }
710    bool Empty() const { return Len() == 0; }
711    int Len() const { return Table.Len(); }
712    int Reserved() const  { return Table.Reserved(); }
713    uint GetDiskSz() const { return 2*sizeof(TInt) + Table.GetDiskSz(); }
714    void Reserve(const int& MxVals) { if (MxVals > Len()) ResizeDelta(MxVals - Len(), 0); }
715    void Clr(const bool& DoDel = true) { Table.Clr(DoDel);  ResetThresh(); }
716    void Swap(TSparseSet& SSet);
717    int AddKey(const TKey& Key);
718    const TKey& GetKey(const int& KeyId) const { return Table.Get(KeyId); }
719    int GetKeyId(const TKey& Key) const { int Pos, PosToIns;
720      FindPos(Key, Pos, PosToIns);  return Pos; }
721    bool IsKey(const TKey& Key) const { return GetKeyId(Key) != -1; }
722    bool IsKey(const TKey& Key, int& KeyId) const {
723      KeyId = GetKeyId(Key);  return KeyId != -1; }
724    bool IsKeyId(const int& KeyId) const { return ! Table.IsEmpty(KeyId); }
725    int GetRndKeyId(TRnd& Rnd = TInt::Rnd) const { Assert(Len()>0);
726      int KeyId = Rnd.GetUniDevInt(Reserved());
727      while (! IsKeyId(KeyId)) { KeyId = Rnd.GetUniDevInt(Reserved()); } return KeyId; }
728    void GetKeyV(TVec<TKey>& KeyV) const;
729  };
730  template <class TKey, uint16 GroupSize>
731  const float TSparseSet<TKey, GroupSize>::MxOccupancy = 0.8f;
732  template <class TKey, uint16 GroupSize>
733  const float TSparseSet<TKey, GroupSize>::MnOccupancy = 0.4f * 0.8f;
734  template <class TKey, uint16 GroupSize>
735  const int TSparseSet<TKey, GroupSize>::MinBuckets = 32;
736  template <class TKey, uint16 GroupSize>
737  void TSparseSet<TKey, GroupSize>::ResetThresh() {
738    ExpandThresh = int(Table.Reserved() * MxOccupancy);
739    ShrinkThresh = int(Table.Reserved() * MnOccupancy);
740  }
741  template <class TKey, uint16 GroupSize>
742  int TSparseSet<TKey, GroupSize>::GetMinSize(const int& CurVals, const int& WantedVals) const {
743    int Size = MinBuckets;
744    while (Size*MxOccupancy <= WantedVals || CurVals > Size * MxOccupancy) Size *= 2;
745    return Size;
746  }
747  template <class TKey, uint16 GroupSize>
748  void TSparseSet<TKey, GroupSize>::CopyFrom(const TSparseSet& SSet, const int& MnWanted) {
749    Clr(false);
750    const int NewSize = GetMinSize(SSet.Reserved(), MnWanted);
751    if (NewSize > Reserved()) {
752      Table.Resize(NewSize);
753      ResetThresh();
754    }
755    const uint BuckM1 = Reserved() - 1;
756    for (int g = 0; g < SSet.Table.Groups(); g++) {
757      const TSGroup& Group = SSet.Table.GetGroup(g);
758      for (int b = 0; b < Group.Len(); b++) {
759        int Tries = 0; uint BuckNum;
760        for (BuckNum = Group.Offset(b).GetPrimHashCd() & BuckM1;
761         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
762          Tries++;
763          Assert(Tries < Reserved());
764        }
765        Table.Set(BuckNum, Group.Offset(b));
766      }
767    }
768  }
769  template <class TKey, uint16 GroupSize>
770  void TSparseSet<TKey, GroupSize>::MoveFrom(TSparseSet& SSet, const int& MnWanted) {
771    Clr(false);
772    int NewSize;
773    if (MnWanted == 0) NewSize = SSet.Reserved();
774    else NewSize = GetMinSize(SSet.Reserved(), MnWanted);
775    if (NewSize > Reserved()) {
776      Table.Resize(NewSize);
777      ResetThresh();
778    }
779    const uint BuckM1 = Reserved() - 1;
780    for (int g = 0; g < SSet.Table.Groups(); g++) {
781      TSGroup& Group = SSet.Table.GetGroup(g);
782      for (int b = 0; b < Group.Len(); b++) {
783        int Tries = 0; uint BuckNum;
784        for (BuckNum = Group.Offset(b).GetPrimHashCd() & BuckM1;
785         ! Table.IsEmpty(BuckNum); BuckNum = (BuckNum + Tries) & BuckM1) {
786          Tries++;
787          Assert(Tries < Reserved());
788        }
789        Assert(Table.IsEmpty(BuckNum));
790        Table.Set(BuckNum, Group.Offset(b));
791      }
792      Group.Clr(true); 
793    }
794  }
795  template <class TKey, uint16 GroupSize>
796  void TSparseSet<TKey, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
797    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
798    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
799    if (NewSize > Reserved()) {
800      printf("***Resize SparseSet: %d->%d\n", Reserved(), NewSize);
801      TSparseSet TmpSSet(Len()+ValsToAdd);
802      TmpSSet.ResetThresh();
803      TmpSSet.MoveFrom(*this, Len());
804      Swap(TmpSSet);
805    }
806  }
807  template <class TKey, uint16 GroupSize>
808  void TSparseSet<TKey, GroupSize>::FindPos(const TKey& Key, int& Pos, int& PosToIns) const {
809    const uint BuckM1 = Reserved() - 1;
810    uint BuckNum = Key.GetPrimHashCd() & BuckM1;
811    int Tries = 0;
812    while (true) {
813      if (Table.IsEmpty(BuckNum)) {
814        Pos = -1;  PosToIns = BuckNum;  return;
815      }
816      else if (Key == Table.Get(BuckNum)) {
817        Pos = BuckNum;  PosToIns = -1;  return;
818      }
819      Tries++;
820      BuckNum = (BuckNum + Tries) & BuckM1;
821      Assert(Tries < Reserved());
822    }
823  }
824  template <class TKey, uint16 GroupSize>
825  TSparseSet<TKey, GroupSize>& TSparseSet<TKey, GroupSize>::operator = (const TSparseSet& SSet) {
826    if (this != &SSet) {
827      ShrinkThresh = SSet.ShrinkThresh;
828      ExpandThresh = SSet.ExpandThresh;
829      Table = SSet.Table;
830    }
831    return *this;
832  }
833  template <class TKey, uint16 GroupSize>
834  bool TSparseSet<TKey, GroupSize>::operator == (const TSparseSet& SSet) const {
835    return Table == SSet.Table;
836  }
837  template <class TKey, uint16 GroupSize>
838  bool TSparseSet<TKey, GroupSize>::operator < (const TSparseSet& SSet) const {
839    return Table < SSet.Table;
840  }
841  template <class TKey, uint16 GroupSize>
842  void TSparseSet<TKey, GroupSize>::Swap(TSparseSet& SSet) {
843    ::Swap(ShrinkThresh, SSet.ShrinkThresh);
844    ::Swap(ExpandThresh, SSet.ExpandThresh);
845    Table.Swap(SSet.Table);
846  }
847  template <class TKey, uint16 GroupSize>
848  int TSparseSet<TKey, GroupSize>::AddKey(const TKey& Key) {
849    ResizeDelta(1);
850    int Pos, PosToIns;  FindPos(Key, Pos, PosToIns);
851    if (Pos != -1) { return Pos; } 
852    else {
853      Table.Set(PosToIns, Key);
854      return PosToIns;
855    }
856  }
857  template <class TKey, uint16 GroupSize>
858  void TSparseSet<TKey, GroupSize>::GetKeyV(TVec<TKey>& KeyV) const {
859    KeyV.Gen(Len(), 0);
860    for (TIter I = BegI(); I < EndI(); I++) {
861      KeyV.Add(I()); }
862  }
863  #pragma pack(push, 1) 
864  template <class TKey>
865  class THashSetKey{
866  public:
867    TInt Next;
868    TInt HashCd;
869    TKey Key;
870  public:
871    THashSetKey():
872      Next(-1), HashCd(-1), Key() {}
873    THashSetKey(const int& _Next, const int& _HashCd, const TKey& _Key):
874      Next(_Next), HashCd(_HashCd), Key(_Key) {}
875    explicit THashSetKey(TSIn& SIn):
876      Next(SIn), HashCd(SIn), Key(SIn) {}
877    void Save(TSOut& SOut) const {
878      Next.Save(SOut); HashCd.Save(SOut); Key.Save(SOut); }
879    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="") {
880      XLoadHd(Nm); XLoad(Key); }
881    void SaveXml(TSOut& SOut, const TStr& Nm) const {
882      XSaveHd(Nm); XSave(Key); }
883    THashSetKey& operator=(const THashSetKey& SetKey) {
884      if (this!=&SetKey) { Next=SetKey.Next; HashCd=SetKey.HashCd; Key=SetKey.Key; }
885      return *this; }
886  };
887  #pragma pack(pop)
888  template <class TKey>
889  class THashSetKeyI{
890  public:
891    typedef THashSetKey<TKey> TSetKey;
892  private:
893    TSetKey* KeyI;
894    TSetKey* EndI;
895  public:
896    THashSetKeyI(): KeyI(NULL), EndI(NULL) { }
897    THashSetKeyI(const THashSetKeyI& _SetKeyI):
898      KeyI(_SetKeyI.KeyI), EndI(_SetKeyI.EndI) { }
899    THashSetKeyI(const TSetKey* _KeyI, const TSetKey* _EndI):
900      KeyI((TSetKey*)_KeyI), EndI((TSetKey*)_EndI) { }
901    THashSetKeyI& operator=(const THashSetKeyI& SetKeyI) {
902      KeyI=SetKeyI.KeyI; EndI=SetKeyI.EndI; return *this; }
903    bool operator==(const THashSetKeyI& SetKeyI) const {
904      return KeyI==SetKeyI.KeyI; }
905    bool operator<(const THashSetKeyI& SetKeyI) const {
906      return KeyI<SetKeyI.KeyI; }
907    THashSetKeyI& operator++(int) { KeyI++; while (KeyI < EndI && KeyI->HashCd==-1) { KeyI++; } return *this; }
908    THashSetKeyI& operator--(int) { do { KeyI--; } while (KeyI->HashCd==-1); return *this; }
909    const TKey& operator*() const { return KeyI->Key; }
910    const TKey& operator()() const { return KeyI->Key; }
911    const TKey* operator->() const { return &KeyI->Key; }
912    THashSetKeyI& Next() { operator++(1); return *this; }
913    bool IsEmpty() const { return KeyI == NULL; }
914    bool IsEnd() const { return EndI == KeyI; }
915    const TKey& GetKey() const {Assert((KeyI!=NULL)&&(KeyI->HashCd!=-1)); return KeyI->Key; }
916  };
917  template <class TKey, class THashFunc = TDefaultHashFunc<TKey> >
918  class THashSet{
919  public:
920    typedef THashSetKeyI<TKey> TIter;
921  private:
922    typedef THashSetKey<TKey> TSetKey;
923    TIntV PortV;
924    TVec<TSetKey> KeyV;
925    TBool AutoSizeP;
926    TInt FFreeKeyId, FreeKeys;
927  private:
928    TSetKey& GetSetKey(const int& KeyId) {
929      TSetKey& SetKey=KeyV[KeyId];
930      Assert(SetKey.HashCd!=-1); return SetKey; }
931    const TSetKey& GetSetKey(const int& KeyId) const {
932      const TSetKey& SetKey=KeyV[KeyId];
933      Assert(SetKey.HashCd!=-1); return SetKey; }
934    uint GetNextPrime(const uint& Val) const;
935    void Resize();
936  public:
937    THashSet():
938      PortV(), KeyV(),
939      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0) { }
940    THashSet(const THashSet& Set):
941      PortV(Set.PortV), KeyV(Set.KeyV), AutoSizeP(Set.AutoSizeP),
942      FFreeKeyId(Set.FFreeKeyId), FreeKeys(Set.FreeKeys) { }
943    THashSet(const int& ExpectVals, const bool& _AutoSizeP=false);
944    explicit THashSet(const TVec<TKey>& KeyV);
945    explicit THashSet(TSIn& SIn):
946      PortV(SIn), KeyV(SIn),
947      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn) {
948      SIn.LoadCs(); }
949    void Load(TSIn& SIn) {
950      PortV.Load(SIn); KeyV.Load(SIn);
951      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
952      SIn.LoadCs(); }
953    void Save(TSOut& SOut) const {
954      PortV.Save(SOut); KeyV.Save(SOut);
955      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
956      SOut.SaveCs(); }
957    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="") {
958      XLoadHd(Nm); TVec<TSetKey> KeyV; XLoad(KeyV); XLoad(AutoSizeP);
959      for (int KeyN=0; KeyN<KeyV.Len(); KeyN++) {
960        AddKey(KeyV[KeyN].Key); }}
961    void SaveXml(TSOut& SOut, const TStr& Nm) {
962      Defrag(); XSaveHd(Nm); XSave(KeyV); XSave(AutoSizeP); }
963    THashSet& operator=(const THashSet& Set) {
964      if (this!=&Set) {
965        PortV=Set.PortV; KeyV=Set.KeyV; AutoSizeP=Set.AutoSizeP;
966        FFreeKeyId=Set.FFreeKeyId; FreeKeys=Set.FreeKeys; }
967      return *this; }
968    bool operator==(const THashSet& Set) const;
969    const TKey& operator[](const int& KeyId) const {return GetSetKey(KeyId).Key; }
970    TKey& operator[](const int& KeyId) {return GetSetKey(KeyId).Key; }
971    ::TSize GetMemUsed() const {
972      return PortV.GetMemUsed() + KeyV.GetMemUsed() + sizeof(bool) + 2*sizeof(int); }
973    TIter BegI() const {
974      if (Len()>0) {
975        if (IsKeyIdEqKeyN()) { return TIter(KeyV.BegI(), KeyV.EndI()); }
976        int FKeyId=-1;  FNextKeyId(FKeyId);
977        return TIter(KeyV.BegI()+FKeyId, KeyV.EndI()); }
978      return TIter(KeyV.EndI(), KeyV.EndI());
979    }
980    TIter EndI() const {return TIter(KeyV.EndI(), KeyV.EndI()); }
981    TIter GetI(const TKey& Key) const {return TIter(&KeyV[GetKeyId(Key)], KeyV.EndI()); }
982    void Gen(const int& ExpectVals) {
983      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyV.Gen(ExpectVals, 0);
984      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1)); }
985    void Clr(const bool& DoDel=true, const int& NoDelLim=-1);
986    bool Empty() const {return Len()==0; }
987    int Len() const {return KeyV.Len()-FreeKeys; }
988    int GetPorts() const {return PortV.Len(); }
989    bool IsAutoSize() const {return AutoSizeP; }
990    int GetMxKeyIds() const {return KeyV.Len(); }
991    int GetReservedKeyIds() const { return KeyV.Reserved(); }
992    bool IsKeyIdEqKeyN() const {return FreeKeys==0; }
993    int AddKey(const TKey& Key);
994    void AddKeyV(const TVec<TKey>& KeyV);
995    void DelKey(const TKey& Key);
996    bool DelIfKey(const TKey& Key) {
997      int KeyId; if (IsKey(Key, KeyId)) {DelKeyId(KeyId); return true;} return false;}
998    void DelKeyId(const int& KeyId) {DelKey(GetKey(KeyId)); }
999    void DelKeyIdV(const TIntV& KeyIdV) {
1000      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++) {DelKeyId(KeyIdV[KeyIdN]); }}
1001    void MarkDelKey(const TKey& Key);
1002    void MarkDelKeyId(const int& KeyId) {MarkDelKey(GetKey(KeyId)); }
1003    const TKey& GetKey(const int& KeyId) const {
1004      return GetSetKey(KeyId).Key; }
1005    int GetKeyId(const TKey& Key) const;
1006    int GetRndKeyId(TRnd& Rnd) const {
1007      IAssert(IsKeyIdEqKeyN());
1008      IAssert(Len()>0);
1009      return Rnd.GetUniDevInt(Len()); }
1010    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1; }
1011    bool IsKey(const TKey& Key, int& KeyId) const {
1012      KeyId=GetKeyId(Key); return KeyId!=-1; }
1013    bool IsKeyId(const int& KeyId) const {
1014      return (0<=KeyId)&&(KeyId<KeyV.Len())&&(KeyV[KeyId].HashCd!=-1); }
1015    int FFirstKeyId() const {return 0-1; }
1016    bool FNextKeyId(int& KeyId) const;
1017    void GetKeyV(TVec<TKey>& KeyV) const;
1018    void Swap(THashSet& Set);
1019    void Defrag();
1020    void Pack() {KeyV.Pack(); }
1021    static THashSet<TKey> GetSet(const TKey& Key1){
1022  	THashSet<TKey> Set(1); Set.AddKey(Key1); return Set;}
1023    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2){
1024      THashSet<TKey> Set(2); Set.AddKey(Key1); Set.AddKey(Key2); return Set;}
1025    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3){
1026      THashSet<TKey> Set(3); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); return Set;}
1027    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4){
1028      THashSet<TKey> Set(4); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); return Set;}
1029    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5){
1030      THashSet<TKey> Set(5); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); return Set;}
1031    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6){
1032      THashSet<TKey> Set(6); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); return Set;}
1033    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7){
1034      THashSet<TKey> Set(7); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); return Set;}
1035    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7, const TKey& Key8){
1036      THashSet<TKey> Set(8); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); Set.AddKey(Key8); return Set;}
1037    static THashSet<TKey> GetSet(const TKey& Key1, const TKey& Key2, const TKey& Key3, const TKey& Key4, const TKey& Key5, const TKey& Key6, const TKey& Key7, const TKey& Key8, const TKey& Key9){
1038      THashSet<TKey> Set(9); Set.AddKey(Key1); Set.AddKey(Key2); Set.AddKey(Key3); Set.AddKey(Key4); Set.AddKey(Key5); Set.AddKey(Key6); Set.AddKey(Key7); Set.AddKey(Key8); Set.AddKey(Key9); return Set;}
1039  };
1040  template <class TKey, class THashFunc>
1041  uint THashSet<TKey, THashFunc>::GetNextPrime(const uint& Val) const {
1042    uint* f=(uint*)TIntH::HashPrimeT, *m, *l=(uint*)TIntH::HashPrimeT + (int)TIntH::HashPrimes;
1043    int h, len = (int)TIntH::HashPrimes;
1044    while (len > 0) {
1045      h = len >> 1;  m = f + h;
1046      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
1047      else len = h;
1048    }
1049    return f == l ? *(l - 1) : *f;
1050  }
1051  template <class TKey, class THashFunc>
1052  void THashSet<TKey, THashFunc>::Resize() {
1053    if (PortV.Len()==0) {PortV.Gen(17); }
1054    else if (AutoSizeP&&(KeyV.Len()>2*PortV.Len())) {
1055      PortV.Gen(GetNextPrime(PortV.Len()+1));
1056    } else {
1057      return;
1058    }
1059    PortV.PutAll(TInt(-1));
1060    for (int KeyId=0; KeyId<KeyV.Len(); KeyId++) {
1061      TSetKey& SetKey=KeyV[KeyId];
1062      if (SetKey.HashCd!=-1) {
1063        int PortN=abs(THashFunc::GetPrimHashCd(SetKey.Key)%PortV.Len());
1064        SetKey.Next=PortV[PortN];
1065        PortV[PortN]=KeyId;
1066      }
1067    }
1068  }
1069  template <class TKey, class THashFunc>
1070  THashSet<TKey, THashFunc>::THashSet(const int& ExpectVals, const bool& _AutoSizeP):
1071    PortV(GetNextPrime(ExpectVals/2+1)), KeyV(ExpectVals, 0),
1072    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0) {
1073    PortV.PutAll(TInt(-1));
1074  }
1075  template <class TKey, class THashFunc>
1076  THashSet<TKey, THashFunc>::THashSet(const TVec<TKey>& _KeyV) :
1077   PortV(GetNextPrime(_KeyV.Len()/2+1)), KeyV(_KeyV.Len(), 0),
1078   AutoSizeP(false), FFreeKeyId(-1), FreeKeys(0) {
1079    PortV.PutAll(TInt(-1));
1080    for (int i = 0; i < _KeyV.Len(); i++) {
1081      AddKey(_KeyV[i]);
1082    }
1083  }
1084  template <class TKey, class THashFunc>
1085  bool THashSet<TKey, THashFunc>::operator==(const THashSet& Set) const {
1086    if (Len() != Set.Len()) { return false; }
1087    for (int k = FFirstKeyId(); FNextKeyId(k); k++) {
1088      if (! Set.IsKey(GetKey(k))) { return false; }
1089    }
1090    return true;
1091  }
1092  template <class TKey, class THashFunc>
1093  void THashSet<TKey, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim) {
1094    if (DoDel) {
1095      PortV.Clr(); KeyV.Clr();
1096    } else {
1097      PortV.PutAll(TInt(-1));
1098      KeyV.Clr(DoDel, NoDelLim);
1099    }
1100    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
1101  }
1102  template <class TKey, class THashFunc>
1103  int THashSet<TKey, THashFunc>::AddKey(const TKey& Key) {
1104    if ((KeyV.Len()>2*PortV.Len())||PortV.Empty()) {Resize(); }
1105    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1106    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1107    int PrevKeyId=-1;
1108    int KeyId=PortV[PortN];
1109    while ((KeyId!=-1) &&
1110     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1111      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1112    if (KeyId==-1) {
1113      if (FFreeKeyId==-1) {
1114        KeyId=KeyV.Add(TSetKey(-1, HashCd, Key));
1115      } else {
1116        KeyId=FFreeKeyId; FFreeKeyId=KeyV[FFreeKeyId].Next; FreeKeys--;
1117        KeyV[KeyId].Next = -1;
1118        KeyV[KeyId].HashCd = HashCd;
1119        KeyV[KeyId].Key = Key;
1120      }
1121      if (PrevKeyId==-1) {
1122        PortV[PortN]=KeyId;
1123      } else {
1124        KeyV[PrevKeyId].Next=KeyId;
1125      }
1126    }
1127    return KeyId;
1128  }
1129  template <class TKey, class THashFunc>
1130  void THashSet<TKey, THashFunc>::AddKeyV(const TVec<TKey>& KeyV) {
1131    for (int i = 0; i < KeyV.Len(); i++) { AddKey(KeyV[i]); }
1132  }
1133  template <class TKey, class THashFunc>
1134  void THashSet<TKey, THashFunc>::DelKey(const TKey& Key) {
1135    IAssert(!PortV.Empty());
1136    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1137    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1138    int PrevKeyId=-1;
1139    int KeyId=PortV[PortN];
1140    while ((KeyId!=-1) &&
1141     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1142      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1143    IAssertR(KeyId!=-1, Key.GetStr());
1144    if (PrevKeyId==-1) {PortV[PortN]=KeyV[KeyId].Next; }
1145    else {KeyV[PrevKeyId].Next=KeyV[KeyId].Next; }
1146    KeyV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
1147    KeyV[KeyId].HashCd=TInt(-1);
1148    KeyV[KeyId].Key=TKey();
1149  }
1150  template <class TKey, class THashFunc>
1151  void THashSet<TKey, THashFunc>::MarkDelKey(const TKey& Key) {
1152    IAssert(!PortV.Empty());
1153    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1154    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1155    int PrevKeyId=-1;
1156    int KeyId=PortV[PortN];
1157    while ((KeyId!=-1) &&
1158     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1159      PrevKeyId=KeyId; KeyId=KeyV[KeyId].Next; }
1160    IAssertR(KeyId!=-1, Key.GetStr());
1161    if (PrevKeyId==-1) {PortV[PortN]=KeyV[KeyId].Next; }
1162    else {KeyV[PrevKeyId].Next=KeyV[KeyId].Next; }
1163    KeyV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
1164    KeyV[KeyId].HashCd=TInt(-1);
1165  }
1166  template <class TKey, class THashFunc>
1167  int THashSet<TKey, THashFunc>::GetKeyId(const TKey& Key) const {
1168    if (PortV.Empty()) {return -1; }
1169    int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
1170    int HashCd=abs(THashFunc::GetSecHashCd(Key));
1171    int KeyId=PortV[PortN];
1172    while ((KeyId!=-1) &&
1173     !((KeyV[KeyId].HashCd==HashCd) && (KeyV[KeyId].Key==Key))) {
1174      KeyId=KeyV[KeyId].Next; }
1175    return KeyId;
1176  }
1177  template <class TKey, class THashFunc>
1178  bool THashSet<TKey, THashFunc>::FNextKeyId(int& KeyId) const {
1179    do {KeyId++; } while ((KeyId<KeyV.Len())&&(KeyV[KeyId].HashCd==-1));
1180    return KeyId<KeyV.Len();
1181  }
1182  template <class TKey, class THashFunc>
1183  void THashSet<TKey, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
1184    KeyV.Clr();
1185    int KeyId=FFirstKeyId();
1186    while (FNextKeyId(KeyId)) {
1187      KeyV.Add(GetKey(KeyId)); }
1188  }
1189  template <class TKey, class THashFunc>
1190  void THashSet<TKey, THashFunc>::Swap(THashSet& Set) {
1191    if (this!=&Set) {
1192      PortV.Swap(Set.PortV);
1193      KeyV.Swap(Set.KeyV);
1194      ::Swap(AutoSizeP, Set.AutoSizeP);
1195      ::Swap(FFreeKeyId, Set.FFreeKeyId);
1196      ::Swap(FreeKeys, Set.FreeKeys);
1197    }
1198  }
1199  template <class TKey, class THashFunc>
1200  void THashSet<TKey, THashFunc>::Defrag() {
1201    if (!IsKeyIdEqKeyN()) {
1202      THashSet<TKey> Set(PortV.Len());
1203      int KeyId=FFirstKeyId();
1204      while (FNextKeyId(KeyId)) {
1205        Set.AddKey(GetKey(KeyId));
1206      }
1207      Pack();
1208      operator=(Set);
1209      IAssert(IsKeyIdEqKeyN());
1210    }
1211  }
1212  typedef THashSet<TUCh> TUChSet;
1213  typedef THashSet<TInt> TIntSet;
1214  typedef THashSet<TUInt64> TUInt64Set;
1215  typedef THashSet<TFlt> TFltSet;
1216  typedef THashSet<TStr> TStrSet;
1217  typedef THashSet<TUChIntPr> TUChIntPrSet;
1218  typedef THashSet<TUChUInt64Pr> TUChUInt64PrSet;
1219  typedef THashSet<TIntPr> TIntPrSet;
1220  template<class TVal>
1221  class TPackVec {
1222  public:
1223    typedef TVal* TIter;
1224  private:
1225    int Vals;
1226    TVal* ValT;
1227    void ResizeDelta(const int& ValsToAdd=1);
1228  public:
1229    TPackVec() : Vals(0), ValT(NULL) { }
1230    TPackVec(const TPackVec& Vec) : Vals(0), ValT(NULL) {
1231      Gen(Vec.Len());
1232      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals);
1233    }
1234    explicit TPackVec(const int& _Vals) : Vals(_Vals) {
1235      if (Vals==0) { ValT=NULL; } else { ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals); } }
1236    ~TPackVec() { if (ValT != NULL) { free(ValT); } }
1237    explicit TPackVec(TSIn& SIn): Vals(0), ValT(NULL) { Load(SIn); }
1238    void Load(TSIn& SIn);
1239    void Save(TSOut& SOut) const;
1240    const TVal& operator [] (const int& ValN) const { return ValT[ValN]; }
1241    TVal& operator [] (const int& ValN) { return ValT[ValN]; }
1242    TPackVec<TVal>& operator = (const TPackVec<TVal>& Vec) { Gen(Vec.Len());
1243      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals); return *this; }
1244    TVec<TVal>& operator = (const TVec<TVal>& Vec) { Gen(Vec.Len());
1245      memcpy(ValT, Vec.ValT, sizeof(TVal)*Vals); return *this; }
1246    void Gen(const int& _Vals) {
1247      if (ValT != NULL) { free(ValT); } Vals = _Vals;
1248      if (Vals==0) { ValT=NULL; } else { ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals); } }
1249    void Clr() { if (ValT != NULL) { free(ValT); ValT=NULL; } Vals = 0; }
1250    bool Empty() const {return Vals==0; }
1251    int Len() const {return Vals; }
1252    const TVal& Last() const { return ValT[Len()-1]; }
1253    TVal& Last() { return ValT[Len()-1]; }
1254    TIter BegI() const {return ValT; }
1255    TIter EndI() const {return ValT+Vals; }
1256    TIter GetI(const int& ValN) const { return ValT+ValN; }
1257    void Add(const TVal& Val) { ResizeDelta(1); ValT[Vals-1]=Val; }
1258    void AddV(const TPackVec<TVal>& ValV) { ResizeDelta(ValV.Len());
1259      memcpy(ValT+Vals-ValV.Len(), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1260    void AddV(const TVec<TVal>& ValV) { ResizeDelta(ValV.Len());
1261      memcpy(ValT+Vals-ValV.Len(), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1262    void AddV(TSIn& FIn) { int NVals;  FIn.Load(NVals);
1263      ResizeDelta(NVals);  FIn.LoadBf(ValT+Vals-NVals, sizeof(TVal)*NVals); }
1264    void Sort(const bool& Asc=true) {
1265      if (Asc) { TVec<TVal>::QSortCmp(BegI(), EndI(), TLss<TVal>()); }
1266      else { TVec<TVal>::QSortCmp(BegI(), EndI(), TGtr<TVal>()); }
1267    }
1268  };
1269  template<class TVal>
1270  void TPackVec<TVal>::ResizeDelta(const int& ValsToAdd) {
1271    if (ValsToAdd == 0) return;
1272    Vals += ValsToAdd;
1273    ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals);
1274    EAssert(ValT != NULL);
1275  }
1276  template<class TVal>
1277  void TPackVec<TVal>::Load(TSIn& SIn) {
1278    SIn.Load(Vals);
1279    if (Vals==0) {
1280      if (ValT != NULL) { free(ValT); }
1281      ValT = NULL; }
1282    else {
1283      ValT = (TVal *) realloc(ValT, sizeof(TVal)*Vals);
1284    }
1285    SIn.LoadBf(ValT, sizeof(TVal)*Vals);
1286  }
1287  template<class TVal>
1288  void TPackVec<TVal>::Save(TSOut& SOut) const {
1289    SOut.Save(Vals);
1290    if (Vals != 0) {
1291      SOut.SaveBf(ValT, sizeof(TVal)*Vals); }
1292  }
1293  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</h3>
            <pre><code>1  void TPredicateNode::GetVariables(TStrV& Variables) {
2    if (Left != NULL) { Left->GetVariables(Variables); }
3    if (Right != NULL) { Right->GetVariables(Variables); }
4    if (Op == NOP) {
5      if (Atom.Lvar != "" ) { Variables.Add(Atom.Lvar); }
6      if (Atom.Rvar != "" ) { Variables.Add(Atom.Rvar); }
7    }
8  }
9  void TPredicate::GetVariables(TStrV& Variables) {
10    Root->GetVariables(Variables);
11  }
12  TBool TPredicate::Eval() {
13    TPredicateNode* Curr = Root;
14    TPredicateNode* Prev = NULL;
15    while (!(Curr == NULL && Prev == Root)) {
16      if (Prev == NULL || Prev == Curr->Parent) {
17        if (Curr->Left != NULL) {
18          Prev = Curr;
19          Curr = Curr->Left;
20        } else if (Curr->Right != NULL) {
21          Prev = Curr;
22          Curr = Curr->Right;
23        } else {
24          Curr->Result = EvalAtomicPredicate(Curr->Atom);
25          Prev = Curr;
26          Curr = Curr->Parent;
27        }
28      } else if (Prev == Curr->Left) {
29        switch (Curr->Op) {
30          case NOT: {
31            Assert(Curr->Right == NULL);
32            Curr->Result = !(Prev->Result);
33            Prev = Curr;
34            Curr = Curr->Parent;
35            break;
36          }
37          case AND: {
38            Assert(Curr->Right != NULL);
39            if (!Prev->Result) {
40              Curr->Result = false;
41              Prev = Curr;
42              Curr = Curr->Parent;
43            } else {
44              Prev = Curr;
45              Curr = Curr->Right;
46            }
47            break;
48          }
49          case OR: {
50            Assert(Curr->Right != NULL);
51            if (Prev->Result) {
52              Curr->Result = true;
53              Prev = Curr;
54              Curr = Curr->Parent;
55            } else {
56              Prev = Curr;
57              Curr = Curr->Right;
58            }
59            break;
60          }
61          case NOP: {
62            break;
63          }
64        }
65      } else {
66        Assert(Prev == Curr->Right);
67        switch (Curr->Op) {
68          case NOT: {
69            Assert(Curr->Left == NULL);
70            Curr->Result = !(Prev->Result);
71            break;
72          }
73          case AND: {
74            Assert(Curr->Left != NULL);
75            Assert(Curr->Left->Result);
76            Curr->Result = Prev->Result;
77            break;
78          }
79          case OR: {
80            Assert(Curr->Left != NULL);
81            Assert(!Curr->Left->Result);
82            Curr->Result = Prev->Result;
83            break;
84          }
85          case NOP: {
86            break;
87          }
88        }
89        Prev = Curr;
90        Curr = Curr->Parent;
91      }
92    }
93    return Root->Result;
94  }
95  TBool TPredicate::EvalAtomicPredicate(const TAtomicPredicate& Atom) {
96    switch (Atom.Type) {
97      case atInt: {
98        if (Atom.IsConst) { 
99          return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), Atom.IntConst, Atom.Compare); 
100        }
101        return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), IntVars.GetDat(Atom.Rvar), Atom.Compare);
102      }
103      case atFlt: {
104        if (Atom.IsConst) { 
105          return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), Atom.FltConst, Atom.Compare); 
106        }
107        return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), FltVars.GetDat(Atom.Rvar), Atom.Compare);
108      }
109      case atStr: {
110        if (Atom.IsConst) { 
111          return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), Atom.StrConst, Atom.Compare); 
112        }
113        return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), StrVars.GetDat(Atom.Rvar), Atom.Compare);
114      }
115    }
116    return false;
117  }
118  TInt const TTable::Last = -1;
119  TInt const TTable::Invalid = -2;
120  TInt TTable::UseMP = 1;
121  TRowIterator& TRowIterator::operator++(int) {
122    return this->Next();
123  }
124  TRowIterator& TRowIterator::Next() {
125    CurrRowIdx = Table->Next[CurrRowIdx];
126    return *this;
127  }
128  bool TRowIterator::operator < (const TRowIterator& RowI) const{
129    if (CurrRowIdx == TTable::Last) { return false; }
130    if (RowI.CurrRowIdx == TTable::Last) { return true; }
131    return CurrRowIdx < RowI.CurrRowIdx;
132  }
133  bool TRowIterator::operator == (const TRowIterator& RowI) const {
134    return CurrRowIdx == RowI.CurrRowIdx;
135  }
136  TInt TRowIterator::GetRowIdx() const {
137    return CurrRowIdx;
138  }
139  TInt TRowIterator::GetIntAttr(TInt ColIdx) const {
140    return Table->IntCols[ColIdx][CurrRowIdx];
141  }
142  TFlt TRowIterator::GetFltAttr(TInt ColIdx) const {
143    return Table->FltCols[ColIdx][CurrRowIdx];
144  }
145  TStr TRowIterator::GetStrAttr(TInt ColIdx) const {
146    return Table->GetStrValIdx(ColIdx, CurrRowIdx);
147  }
148  TInt TRowIterator::GetIntAttr(const TStr& Col) const {
149    TInt ColIdx = Table->GetColIdx(Col);
150    return Table->IntCols[ColIdx][CurrRowIdx];
151  }
152  TFlt TRowIterator::GetFltAttr(const TStr& Col) const {
153    TInt ColIdx = Table->GetColIdx(Col);
154    return Table->FltCols[ColIdx][CurrRowIdx];
155  }
156  TStr TRowIterator::GetStrAttr(const TStr& Col) const {
157    return Table->GetStrVal(Col, CurrRowIdx);
158  }
159  TInt TRowIterator::GetStrMapByName(const TStr& Col) const {
160    TInt ColIdx = Table->GetColIdx(Col);
161    return Table->StrColMaps[ColIdx][CurrRowIdx];
162  }
163  TInt TRowIterator::GetStrMapById(TInt ColIdx) const {
164    return Table->StrColMaps[ColIdx][CurrRowIdx];
165  }
166  TBool TRowIterator::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
167    TBool Result;
168    switch (Val.GetType()) {
169      case atInt:
170        Result = TPredicate::EvalAtom(GetIntAttr(ColIdx), Val.GetInt(), Cmp);
171        break;
172      case atFlt:
173        Result = TPredicate::EvalAtom(GetFltAttr(ColIdx), Val.GetFlt(), Cmp);
174        break;
175      case atStr:
176        Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val.GetStr(), Cmp);
177        break;
178      default:
179        Result = TBool(false);
180    }
181    return Result;
182  }
183  TBool TRowIterator::CompareAtomicConstTStr(TInt ColIdx, const TStr& Val, TPredComp Cmp) {
184    TBool Result;
185    Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val, Cmp);
186    return Result;
187  }
188  TRowIteratorWithRemove::TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr) :
189    CurrRowIdx(RowIdx), Table(TablePtr), Start(RowIdx == TablePtr->FirstValidRow) {}
190  TRowIteratorWithRemove& TRowIteratorWithRemove::operator++(int) {
191    return this->Next();
192  }
193  TRowIteratorWithRemove& TRowIteratorWithRemove::Next() {
194    CurrRowIdx = GetNextRowIdx();
195    Start = false;
196    Assert(CurrRowIdx != TTable::Invalid);
197    return *this;
198  }
199  bool TRowIteratorWithRemove::operator < (const TRowIteratorWithRemove& RowI) const {
200    if (CurrRowIdx == TTable::Last) { return false; }
201    if (RowI.CurrRowIdx == TTable::Last) { return true; }
202    return CurrRowIdx < RowI.CurrRowIdx;
203  }
204  bool TRowIteratorWithRemove::operator == (const TRowIteratorWithRemove& RowI) const {
205    return CurrRowIdx == RowI.CurrRowIdx;
206  }
207  TInt TRowIteratorWithRemove::GetRowIdx() const {
208    return CurrRowIdx;
209  }
210  TInt TRowIteratorWithRemove::GetNextRowIdx() const {
211    return (Start ? Table->FirstValidRow : Table->Next[CurrRowIdx]);
212  }
213  TInt TRowIteratorWithRemove::GetNextIntAttr(TInt ColIdx) const {
214    return Table->IntCols[ColIdx][GetNextRowIdx()];
215  }
216  TFlt TRowIteratorWithRemove::GetNextFltAttr(TInt ColIdx) const {
217    return Table->FltCols[ColIdx][GetNextRowIdx()];
218  }
219  TStr TRowIteratorWithRemove::GetNextStrAttr(TInt ColIdx) const {
220    return Table->GetStrValIdx(ColIdx, GetNextRowIdx());
221  }
222  TInt TRowIteratorWithRemove::GetNextIntAttr(const TStr& Col) const {
223    TInt ColIdx = Table->GetColIdx(Col);
224    return Table->IntCols[ColIdx][GetNextRowIdx()];
225  }
226  TFlt TRowIteratorWithRemove::GetNextFltAttr(const TStr& Col) const {
227    TInt ColIdx = Table->GetColIdx(Col);
228    return Table->FltCols[ColIdx][GetNextRowIdx()];
229  }
230  TStr TRowIteratorWithRemove::GetNextStrAttr(const TStr& Col) const {
231    return Table->GetStrVal(Col, GetNextRowIdx());
232  }
233  TBool TRowIteratorWithRemove::IsFirst() const {
234    return CurrRowIdx == Table->FirstValidRow;
235  }
236  void TRowIteratorWithRemove::RemoveNext() {
237    Table->RemoveRow(GetNextRowIdx(), CurrRowIdx);
238  }
239  TBool TRowIteratorWithRemove::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
240    TBool Result;
241    switch (Val.GetType()) {
242      case atInt:
243        Result = TPredicate::EvalAtom(GetNextIntAttr(ColIdx), Val.GetInt(), Cmp);
244        break;
245      case atFlt:
246        Result = TPredicate::EvalAtom(GetNextFltAttr(ColIdx), Val.GetFlt(), Cmp);
247        break;
248      case atStr:
249        Result = TPredicate::EvalStrAtom(GetNextStrAttr(ColIdx), Val.GetStr(), Cmp);
250        break;
251      default:
252        Result = TBool(false);
253    }
254    return Result;
255  }
256  TTable::TTable(): Context(new TTableContext), NumRows(0), NumValidRows(0),
257    FirstValidRow(0), LastValidRow(-1) {}
258  TTable::TTable(TTableContext* Context): Context(Context), NumRows(0),
259    NumValidRows(0), FirstValidRow(0), LastValidRow(-1) {}
260  TTable::TTable(const Schema& TableSchema, TTableContext* Context): Context(Context), 
261    NumRows(0), NumValidRows(0), FirstValidRow(0), LastValidRow(-1), IsNextDirty(0) {
262    TInt IntColCnt = 0;
263    TInt FltColCnt = 0;
264    TInt StrColCnt = 0;
265    for (TInt i = 0; i < TableSchema.Len(); i++) {
266      TStr ColName = TableSchema[i].Val1;
267      TAttrType ColType = TableSchema[i].Val2;
268      AddSchemaCol(ColName, ColType);
269      switch (ColType) {
270        case atInt:
271          AddColType(ColName, atInt, IntColCnt);
272          IntColCnt++;
273          break;
274        case atFlt:
275          AddColType(ColName, atFlt, FltColCnt);
276          FltColCnt++;
277          break;
278        case atStr:
279          AddColType(ColName, atStr, StrColCnt);
280          StrColCnt++;
281          break;
282      }
283    }
284    IntCols = TVec<TIntV>(IntColCnt);
285    FltCols = TVec<TFltV>(FltColCnt);
286    StrColMaps = TVec<TIntV>(StrColCnt);
287  }
288  void TTable::GenerateColTypeMap(THash<TStr,TPair<TInt,TInt> > & ColTypeIntMap) {
289    ColTypeMap.Clr();
290    Sch.Clr();
291    for (THash<TStr,TPair<TInt,TInt> >::TIter it = ColTypeIntMap.BegI(); it < ColTypeIntMap.EndI(); it++) {
292      TPair<TInt,TInt> dat = it.GetDat();
293      switch (dat.GetVal1()) {
294        case 0:
295          AddColType(it.GetKey(), atInt, dat.GetVal2());
296          AddSchemaCol(it.GetKey(), atInt);
297          break;
298        case 1:
299          AddColType(it.GetKey(), atFlt, dat.GetVal2());
300          AddSchemaCol(it.GetKey(), atFlt);
301          break;
302        case 2:
303          AddColType(it.GetKey(), atStr, dat.GetVal2());
304          AddSchemaCol(it.GetKey(), atStr);
305          break;
306      }
307    }
308    IsNextDirty = 0;
309  }
310  void TTable::LoadTableShM(TShMIn& ShMIn, TTableContext* ContextTable) {
311    Context = ContextTable;
312    NumRows = TInt(ShMIn);
313    NumValidRows = TInt(ShMIn);
314    FirstValidRow = TInt(ShMIn);
315    LastValidRow = TInt(ShMIn);
316    Next.LoadShM(ShMIn);
317    TLoadVecInit Fn;
318    IntCols.LoadShM(ShMIn, Fn);
319    FltCols.Load(ShMIn);
320    StrColMaps.LoadShM(ShMIn, Fn);
321    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
322    ColTypeIntMap.LoadShM(ShMIn);
323    GenerateColTypeMap(ColTypeIntMap);
324  }
325  TTable::TTable(TSIn& SIn, TTableContext* Context): Context(Context), NumRows(SIn),
326    NumValidRows(SIn), FirstValidRow(SIn), LastValidRow(SIn), Next(SIn), IntCols(SIn),
327    FltCols(SIn), StrColMaps(SIn) {
328    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap(SIn);
329    GenerateColTypeMap(ColTypeIntMap);
330  }
331  TTable::TTable(const TIntIntH& H, const TStr& Col1, const TStr& Col2,
332   TTableContext* Context, const TBool IsStrKeys) : Context(Context), NumRows(H.Len()),
333    NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
334      TAttrType KeyType = IsStrKeys ? atStr : atInt;
335      AddSchemaCol(Col1, KeyType);
336      AddSchemaCol(Col2, atInt);
337      AddColType(Col1, KeyType, 0);
338      AddColType(Col2, atInt, 1);
339      if (IsStrKeys) {
340        StrColMaps = TVec<TIntV>(1);
341        IntCols = TVec<TIntV>(1);
342        H.GetKeyV(StrColMaps[0]);
343        H.GetDatV(IntCols[0]);
344      } else {
345        IntCols = TVec<TIntV>(2);
346        H.GetKeyV(IntCols[0]);
347        H.GetDatV(IntCols[1]);
348      }
349      Next = TIntV(NumRows);
350      for (TInt i = 0; i < NumRows; i++) {
351        Next[i] = i+1;
352      }
353      Next[NumRows-1] = Last;
354      IsNextDirty = 0;
355      InitIds();
356  }
357  TTable::TTable(const TIntFltH& H, const TStr& Col1, const TStr& Col2,
358   TTableContext* Context, const TBool IsStrKeys) : Context(Context),
359    NumRows(H.Len()), NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
360    TAttrType KeyType = IsStrKeys ? atStr : atInt;
361    AddSchemaCol(Col1, KeyType);
362    AddSchemaCol(Col2, atFlt);
363    AddColType(Col1, KeyType, 0);
364    AddColType(Col2, atFlt, 0);
365    if (IsStrKeys) {
366      StrColMaps = TVec<TIntV>(1);
367      H.GetKeyV(StrColMaps[0]);
368    } else {
369      IntCols = TVec<TIntV>(1);
370      H.GetKeyV(IntCols[0]);
371    }
372    FltCols = TVec<TFltV>(1);
373    H.GetDatV(FltCols[0]);
374    Next = TIntV(NumRows);
375    for (TInt i = 0; i < NumRows; i++) {
376      Next[i] = i+1;
377    }
378    Next[NumRows-1] = Last;
379    IsNextDirty = 0;
380    InitIds();
381  }
382  TTable::TTable(const TTable& Table, const TIntV& RowIDs) : Context(Table.Context),
383    Sch(Table.Sch), SrcCol(Table.SrcCol), DstCol(Table.DstCol), EdgeAttrV(Table.EdgeAttrV),
384    SrcNodeAttrV(Table.SrcNodeAttrV), DstNodeAttrV(Table.DstNodeAttrV),
385    CommonNodeAttrs(Table.CommonNodeAttrs) {
386    ColTypeMap = Table.ColTypeMap;
387    IntCols = TVec<TIntV>(Table.IntCols.Len());
388    FltCols = TVec<TFltV>(Table.FltCols.Len());
389    StrColMaps = TVec<TIntV>(Table.StrColMaps.Len());
390    FirstValidRow = 0;
391    LastValidRow = -1;
392    NumRows = 0;
393    NumValidRows = 0;
394    AddSelectedRows(Table, RowIDs);
395    IsNextDirty = 0;
396    InitIds();
397  }
398  void TTable::GetSchema(const TStr& InFNm, Schema& S, const char& Separator) {
399    TSsParser Ss(InFNm, '\t', false, false, false);
400    TInt rowsToPeek = 1000;
401    TInt currRow = 0;
402    TInt lastComment = 0;
403    while (Ss.Next()) {
404      if (Ss.IsCmt()) {
405        lastComment += 1;
406      }
407      else break;
408    }
409    if (Ss.Eof()) {TExcept::Throw("No Data to determine attribute types!");}
410    TInt numCols = Ss.GetFlds();
411    TVec<TAttrType> colAttrV(numCols);
412    colAttrV.PutAll(atInt);
413    while (true) {
414      for (TInt i = 0; i < numCols; i++) {
415        if (Ss.IsInt(i)) {
416        }
417        else if (Ss.IsFlt(i)) {
418          colAttrV[i] = atFlt;
419        }
420        else {
421          colAttrV[i] = atStr;
422        }
423      }
424      currRow++;
425      if (currRow > rowsToPeek || Ss.Eof()) break;
426      Ss.Next();
427    }
428    TSsParser SsNames(InFNm, Separator, false, false, false);
429    for (int i = 0; i < lastComment; i++) { SsNames.Next();}
430    TVec<TStr> attrV;
431    TStr first(SsNames[0]);
432    int begin = 0;
433    TStr comment('#');
434    if (first != comment) {
435      for (int i = 1; i < first.Len(); i++){
436        if (first[i] != ' ') { begin = i; break;}
437      }
438      attrV.Add(first.GetSubStr(begin));
439    }
440    for (int i = 1; i < SsNames.GetFlds(); i++) {attrV.Add(SsNames[i]);}
441    for (TInt i = 0; i < numCols; i++) {
442      S.Add(TPair<TStr,TAttrType>(attrV[i],colAttrV[i]));
443    } 
444  }
445  #ifdef GCC_ATOMIC
446  void TTable::LoadSSPar(PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols, 
447                          const char& Separator, TBool HasTitleLine) {
448    TInt RowLen = T->Sch.Len();
449    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
450    for (TInt i = 0; i < RowLen; i++) {
451      ColTypes[i] = T->GetSchemaColType(i);
452    }
453    TSsParserMP Ss(InFNm, Separator);
454    Ss.SkipCommentLines();
455    if (HasTitleLine) {
456      Ss.Next();
457      if (S.Len() != Ss.GetFlds()) {
458        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
459      }
460      for (TInt i = 0; i < Ss.GetFlds(); i++) {
461        TInt L = strlen(Ss[i]);
462        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
463        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
464      }
465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
469    uint64 Rem = Len - Pos;
470    int NumThreads = omp_get_max_threads();
471    uint64 Delta = Rem / NumThreads;
472    if (Delta < 1) Delta = 1;
473    TVec<uint64> StartIntV(NumThreads);
474    TVec<uint64> LineCountV(NumThreads);
475    TVec<uint64> PrefixSumV(NumThreads);
476    StartIntV[0] = Pos;
477    for (int i = 1; i < NumThreads; i++) {
478      StartIntV[i] = StartIntV[i-1] + Delta;
479    }
480    StartIntV.Add(Len);
481    omp_set_num_threads(NumThreads);
482    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
483    for (int i = 0; i < NumThreads; i++) {
484      LineCountV[i] = Ss.CountNewLinesInRange(StartIntV[i], StartIntV[i+1]);
485      Cnt += LineCountV[i];
486    }
487    PrefixSumV[0] = 0;
488    for (int i = 1; i < NumThreads; i++) {
489      PrefixSumV[i] = PrefixSumV[i-1] + LineCountV[i-1];
490    }
491    Ss.SetStreamPos(Pos);
492    TInt IntColIdx = 0;
493    TInt FltColIdx = 0;
494    for (TInt i = 0; i < RowLen; i++) {
495      switch (ColTypes[i]) {
496        case atInt:
497          T->IntCols[IntColIdx].Gen(Cnt);
498          IntColIdx++;
499          break;
500        case atFlt:
501          T->FltCols[FltColIdx].Gen(Cnt);
502          FltColIdx++;
503          break;
504        case atStr:
505          break;
506      }
507    }
508    Cnt = 0;
509    omp_set_num_threads(NumThreads);
510    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
511    for (int i = 0; i < NumThreads; i++) {
512      TVec<uint64> LineStartPosV = Ss.GetStartPosV(StartIntV[i], StartIntV[i+1]);
513      for (uint64 k = 0; k < (uint64) LineStartPosV.Len(); k++) {
514        TVec<char*> FieldsV;
515        Ss.NextFromIndex(LineStartPosV[k], FieldsV);
516        if (FieldsV.Len() != S.Len()) {
517          TExcept::Throw("Error reading tsv file");
518        }
519        TInt IntColIdx = 0;
520        TInt FltColIdx = 0;
521        TInt RowIdx = PrefixSumV[i] + k;
522        for (TInt j = 0; j < RowLen; j++) {
523          switch (ColTypes[j]) {
524            case atInt:
525              if (RelevantCols.Len() == 0) {
526                T->IntCols[IntColIdx][RowIdx] = \
527                  (Ss.GetIntFromFldV(FieldsV, j));
528              } else {
529                T->IntCols[IntColIdx][RowIdx] = \
530                  (Ss.GetIntFromFldV(FieldsV, RelevantCols[j]));
531              }
532              IntColIdx++;
533              break;
534            case atFlt:
535              if (RelevantCols.Len() == 0) {
536                T->FltCols[FltColIdx][RowIdx] = \
537                  (Ss.GetFltFromFldV(FieldsV, j));
538              } else {
539                T->FltCols[FltColIdx][RowIdx] = \
540                  (Ss.GetFltFromFldV(FieldsV, RelevantCols[j]));
541              }
542              FltColIdx++;
543              break;
544            case atStr:
545              TExcept::Throw("TTable::LoadSS:: Str Col found\n");
546              break;
547          }
548        }
549        Cnt++;
550      }
551    }
552    T->NumRows = Cnt;
553    T->NumValidRows = T->NumRows;
554    T->Next.Clr();
555    T->Next.Gen(Cnt);
556    omp_set_num_threads(NumThreads);
557    #pragma omp parallel for schedule(dynamic, 10000)
558    for (int64 i = 0; i < Cnt-1; i++) {
559      T->Next[i] = i+1;
560    }
561    T->IsNextDirty = 0;
562    T->Next[Cnt-1] = Last;
563    T->LastValidRow = T->NumRows - 1;
564    T->IdColName = "_id";
565    TInt IdCol = T->IntCols.Add();
566    T->IntCols[IdCol].Gen(Cnt);
567    omp_set_num_threads(NumThreads);
568    #pragma omp parallel for schedule(dynamic, 10000)
569    for (int64 i = 0; i < Cnt; i++) {
570      T->IntCols[IdCol][i] = i;
571    }
572    T->AddSchemaCol(T->IdColName, atInt);
573    T->AddColType(T->IdColName, atInt, T->IntCols.Len()-1);
574  }
575  #endif 
576  void TTable::LoadSSSeq(
577   PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols,
578   const char& Separator, TBool HasTitleLine) {
579    int RowLen = T->Sch.Len();
580    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
581    for (int i = 0; i < RowLen; i++) {
582      ColTypes[i] = T->GetSchemaColType(i);
583    }
584    TSsParser Ss(InFNm, Separator);
585    if (HasTitleLine) {
586      Ss.Next();
587      if (S.Len() != Ss.GetFlds()) {
588        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
589      }
590      for (int i = 0; i < Ss.GetFlds(); i++) {
591        int L = strlen(Ss[i]);
592        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
593        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
594      }
595    }
596    uint64 Cnt = 0;
597    while (Ss.Next()) {
598      int IntColIdx = 0;
599      int FltColIdx = 0;
600      int StrColIdx = 0;
601      Assert(Ss.GetFlds() == S.Len()); 
602      if (Ss.GetFlds() != S.Len()) {
603        printf("%s\n", Ss[S.Len()]); TExcept::Throw("Error reading tsv file");
604      }
605      for (int i = 0; i < RowLen; i++) {
606        switch (ColTypes[i]) {
607          case atInt:
608            if (RelevantCols.Len() == 0) {
609              T->IntCols[IntColIdx].Add(Ss.GetInt(i));
610            } else {
611              T->IntCols[IntColIdx].Add(Ss.GetInt(RelevantCols[i]));
612            }
613            IntColIdx++;
614            break;
615          case atFlt:
616            if (RelevantCols.Len() == 0) {
617              T->FltCols[FltColIdx].Add(Ss.GetFlt(i));
618            } else {
619              T->FltCols[FltColIdx].Add(Ss.GetFlt(RelevantCols[i]));
620            }
621            FltColIdx++;
622            break;
623          case atStr:
624            int ColIdx;
625            if (RelevantCols.Len() == 0) {
626              ColIdx = i;
627            } else {
628              ColIdx = RelevantCols[i];
629            }
630            TStr Sval = TStr(Ss[ColIdx]);
631            T->AddStrVal(StrColIdx, Sval);
632            StrColIdx++;
633            break;
634        }
635      }
636      Cnt += 1;
637    }
638    T->NumRows = static_cast<int>(Cnt);
639    T->NumValidRows = T->NumRows;
640    T->Next.Clr();
641    T->Next.Gen(static_cast<int>(Cnt));
642    for (uint64 i = 0; i < Cnt-1; i++) {
643      T->Next[static_cast<int>(i)] = static_cast<int>(i+1);
644    }
645    T->IsNextDirty = 0;
646    T->Next[static_cast<int>(Cnt-1)] = Last;
647    T->LastValidRow = T->NumRows - 1;
648    T->InitIds();
649  }
650  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
651   const TIntV& RelevantCols, const char& Separator, TBool HasTitleLine) {
652    TVec<uint64> IntGroupByCols;
653    bool NoStringCols = true;
654    Schema SR;
655    if (RelevantCols.Len() == 0) {
656      SR = S;
657    } else {
658      for (int i = 0; i < RelevantCols.Len(); i++) {
659        SR.Add(S[RelevantCols[i]]);
660      }
661    }
662    PTable T = New(SR, Context);
663    for (int i = 0; i < SR.Len(); i++) {
664      if (T->GetSchemaColType(i) == atStr) {
665        NoStringCols = false;
666        break;
667      }
668    }
669    if (GetMP() && NoStringCols) {
670  #ifdef GLib_LINUX
671      LoadSSPar(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
672  #else
673      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
674  #endif
675    } else {
676      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
677    }
678    return T;
679  }
680  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
681   const char& Separator, TBool HasTitleLine) {
682    return LoadSS(S, InFNm, Context, TIntV(), Separator, HasTitleLine);
683  }
684  void TTable::SaveSS(const TStr& OutFNm) {
685    if (NumValidRows == 0) {
686      printf("Table is empty");
687      return;
688    }
689    FILE* F = fopen(OutFNm.CStr(), "w");
690    if (F == NULL) {
691      printf("failed to open file %s\n", OutFNm.CStr());
692      perror("fail ");
693      return;
694    }
695    Dump(F);
696  #if 0
697    Schema DSch = DenormalizeSchema();
698    TInt L = Sch.Len();
699    fprintf(F, "# ");
700    for (TInt i = 0; i < L-1; i++) {
701      fprintf(F, "%s\t", DSch[i].Val1.CStr());
702    }  
703    fprintf(F, "%s\n", DSch[L-1].Val1.CStr());
704    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
705      for (TInt i = 0; i < L; i++) {
706        char C = (i == L-1) ? '\n' : '\t';
707        switch (GetSchemaColType(i)) {
708          case atInt: {
709            fprintf(F, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
710            break;
711          }
712          case atFlt: {
713            fprintf(F, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
714            break;
715          }
716          case atStr: {
717            fprintf(F, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
718            break;
719          }
720        }
721      }
722    }
723  #endif
724    fclose(F);
725  }
726  void TTable::SaveBin(const TStr& OutFNm) {
727    TFOut SOut(OutFNm);
728    Save(SOut);
729  }
730  void TTable::Save(TSOut& SOut) {
731    NumRows.Save(SOut);
732    NumValidRows.Save(SOut);
733    FirstValidRow.Save(SOut);
734    LastValidRow.Save(SOut);
735    Next.Save(SOut);
736    IntCols.Save(SOut);
737    FltCols.Save(SOut);
738    StrColMaps.Save(SOut);
739    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
740    TInt atIntVal = TInt(0);
741    TInt atFltVal = TInt(1);
742    TInt atStrVal = TInt(2);
743    for (THash<TStr,TPair<TAttrType,TInt> >::TIter it = ColTypeMap.BegI(); it < ColTypeMap.EndI(); it++) {
744      TPair<TAttrType,TInt> dat = it.GetDat();
745      TStr DColName = DenormalizeColName(it.GetKey());
746      switch (dat.GetVal1()) {
747        case atInt:
748          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atIntVal, dat.GetVal2()));
749          break;
750        case atFlt:
751          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atFltVal, dat.GetVal2()));
752          break;
753        case atStr:
754          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atStrVal, dat.GetVal2()));
755          break;
756      }
757    }
758    ColTypeIntMap.Save(SOut);
759    SOut.Flush();
760  }
761  void TTable::Dump(FILE *OutF) const {
762    TInt L = Sch.Len();
763    Schema DSch = DenormalizeSchema();
764    fprintf(OutF, "# ");
765    for (TInt i = 0; i < L-1; i++) {
766      fprintf(OutF, "%s\t", DSch[i].Val1.CStr());
767    }  
768    fprintf(OutF, "%s\n", DSch[L-1].Val1.CStr());
769    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
770      for (TInt i = 0; i < L; i++) {
771        char C = (i == L-1) ? '\n' : '\t';
772        switch (GetSchemaColType(i)) {
773          case atInt: {
774            fprintf(OutF, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
775            break;
776          }
777          case atFlt: {
778            fprintf(OutF, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
779            break;
780          }
781          case atStr: {
782            fprintf(OutF, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
783            break;
784          }
785        }
786      }
787    }
788  }
789  TTableContext* TTable::ChangeContext(TTableContext* NewContext) {
790    TInt L = Sch.Len();
791  #if 0
792    for (TInt i = 0; i < L; i++) {
793      if (GetSchemaColType(i) != atStr) {
794        continue;
795      }
796      TInt ColIdx = GetColIdx(GetSchemaColName(i));
797      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
798        TInt RowIdx = RowI.GetRowIdx();
799        TInt KeyId = StrColMaps[ColIdx][RowIdx];
800        printf("ChangeContext in  %d  %d  %d  .%s.\n",
801            ColIdx.Val, RowIdx.Val, KeyId.Val, GetStrVal(ColIdx, RowIdx).CStr());
802      }
803    }
804  #endif
805    for (TInt i = 0; i < L; i++) {
806      if (GetSchemaColType(i) != atStr) {
807        continue;
808      }
809      TInt ColIdx = GetColIdx(GetSchemaColName(i));
810      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
811        TInt RowIdx = RowI.GetRowIdx();
812        TStr Key = GetStrValIdx(ColIdx, RowIdx);
813        TInt KeyId = TInt(NewContext->StringVals.AddKey(Key));
814        StrColMaps[ColIdx][RowIdx] = KeyId;
815      }
816    }
817    Context = NewContext;
818    return Context;
819  }
820  void TTable::AddStrVal(const TInt& ColIdx, const TStr& Key) {
821    TInt KeyId = TInt(Context->StringVals.AddKey(Key));
822    StrColMaps[ColIdx].Add(KeyId);
823  }
824  void TTable::AddStrVal(const TStr& Col, const TStr& Key) {
825    if (GetColType(Col) != atStr) {
826      TExcept::Throw(Col + " is not a string valued column");
827    }
828    AddStrVal(GetColIdx(Col), Key);
829  }
830  void TTable::AddGraphAttribute(const TStr& Attr, TBool IsEdge, TBool IsSrc, TBool IsDst) {
831    if (!IsColName(Attr)) { TExcept::Throw(Attr + ": No such column"); }
832    if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attr)); }
833    if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attr)); }
834    if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attr)); }
835  }
836  void TTable::AddGraphAttributeV(TStrV& Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst) {
837    for (TInt i = 0; i < Attrs.Len(); i++) {
838      if (!IsColName(Attrs[i])) {
839        TExcept::Throw(Attrs[i] + ": no such column");
840      }
841    }
842    for (TInt i = 0; i < Attrs.Len(); i++) {
843      if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attrs[i])); }
844      if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attrs[i])); }
845      if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attrs[i])); }
846    }
847  }
848  TStrV TTable::GetSrcNodeIntAttrV() const {
849    TStrV IntNA = TStrV(IntCols.Len(),0);
850    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
851      TStr Attr = SrcNodeAttrV[i];
852      if (GetColType(Attr) == atInt) {
853        IntNA.Add(Attr);
854      }
855    }
856    return IntNA;
857  }
858  TStrV TTable::GetDstNodeIntAttrV() const {
859    TStrV IntNA = TStrV(IntCols.Len(),0);
860    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
861      TStr Attr = DstNodeAttrV[i];
862      if (GetColType(Attr) == atInt) {
863        IntNA.Add(Attr);
864      }
865    }
866    return IntNA;
867  }
868  TStrV TTable::GetEdgeIntAttrV() const {
869    TStrV IntEA = TStrV(IntCols.Len(),0);
870    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
871      TStr Attr = EdgeAttrV[i];
872      if (GetColType(Attr) == atInt) {
873        IntEA.Add(Attr);
874      }
875    }
876    return IntEA;
877  }
878  TStrV TTable::GetSrcNodeFltAttrV() const {
879    TStrV FltNA = TStrV(FltCols.Len(),0);
880    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
881      TStr Attr = SrcNodeAttrV[i];
882      if (GetColType(Attr) == atFlt) {
883        FltNA.Add(Attr);
884      }
885    }
886    return FltNA;
887  }
888  TStrV TTable::GetDstNodeFltAttrV() const {
889    TStrV FltNA = TStrV(FltCols.Len(),0);
890    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
891      TStr Attr = DstNodeAttrV[i];
892      if (GetColType(Attr) == atFlt) {
893        FltNA.Add(Attr);
894      }
895    }
896    return FltNA;
897  }
898  TStrV TTable::GetEdgeFltAttrV() const {
899    TStrV FltEA = TStrV(FltCols.Len(),0);;
900    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
901      TStr Attr = EdgeAttrV[i];
902      if (GetColType(Attr) == atFlt) {
903        FltEA.Add(Attr);
904      }
905    }
906    return FltEA;
907  }
908  TStrV TTable::GetSrcNodeStrAttrV() const {
909    TStrV StrNA = TStrV(StrColMaps.Len(),0);
910    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
911      TStr Attr = SrcNodeAttrV[i];
912      if (GetColType(Attr) == atStr) {
913        StrNA.Add(Attr);
914      }
915    }
916    return StrNA;
917  }
918  TStrV TTable::GetDstNodeStrAttrV() const {
919    TStrV StrNA = TStrV(StrColMaps.Len(),0);
920    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
921      TStr Attr = DstNodeAttrV[i];
922      if (GetColType(Attr) == atStr) {
923        StrNA.Add(Attr);
924      }
925    }
926    return StrNA;
927  }
928  TStrV TTable::GetEdgeStrAttrV() const {
929    TStrV StrEA = TStrV(StrColMaps.Len(),0);
930    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
931      TStr Attr = EdgeAttrV[i];
932      if (GetColType(Attr) == atStr) {
933        StrEA.Add(Attr);
934      }
935    }
936    return StrEA;
937  }
938  void TTable::Rename(const TStr& column, const TStr& NewLabel) {
939    if (!IsColName(column)) { TExcept::Throw("no such column " + column); }
940    TPair<TAttrType,TInt> ColVal = GetColTypeMap(column);
941    DelColType(column);
942    AddColType(NewLabel, ColVal);
943    TStr NColName = NormalizeColName(column);
944    TStr NLabel = NormalizeColName(NewLabel);
945    for (TInt c = 0; c < Sch.Len(); c++) {
946      if (Sch[c].Val1 == NColName) {
947        Sch.SetVal(c, TPair<TStr, TAttrType>(NLabel, Sch[c].Val2));
948        break;
949      }
950    }
951  }
952  void TTable::RemoveFirstRow() {
953    if (FirstValidRow == LastValidRow) {
954      LastValidRow = -1;
955    }
956    TInt Old = FirstValidRow;
957    FirstValidRow = Next[FirstValidRow];
958    Next[Old] = TTable::Invalid;
959    NumValidRows--;
960    TInt IdColIdx = GetColIdx(GetIdColName());
961    RowIdMap.AddDat(IntCols[IdColIdx][Old], Invalid);
962  }
963  void TTable::RemoveRow(TInt RowIdx, TInt PrevRowIdx) {
964    if (RowIdx == FirstValidRow) {
965      RemoveFirstRow();
966      return;
967    }
968    Assert(RowIdx != TTable::Invalid);
969    if (RowIdx == TTable::Last) { return; }
970    Next[PrevRowIdx] = Next[RowIdx];
971    if (LastValidRow == RowIdx) {
972      LastValidRow = RowIdx;
973    }
974    Next[RowIdx] = TTable::Invalid;
975    NumValidRows--;
976    TInt IdColIdx = GetColIdx(GetIdColName());
977    RowIdMap.AddDat(IntCols[IdColIdx][RowIdx], Invalid);
978  }
979  void TTable::KeepSortedRows(const TIntV& KeepV) {
980    TIntIntH KeepH(KeepV.Len());
981    for (TInt i = 0; i < KeepV.Len(); i++) {
982      KeepH.AddKey(KeepV[i]);
983    }
984    TRowIteratorWithRemove RowI = BegRIWR();
985    TInt KeepSize = 0;
986    while (RowI.GetNextRowIdx() != Last) {
987      if (KeepSize < KeepV.Len()) {
988        if (KeepH.IsKey(RowI.GetNextRowIdx())) {
989          KeepSize++;
990          RowI++;
991        } else {
992          RowI.RemoveNext();
993        }
994      } else {
995        RowI.RemoveNext();
996      }
997    }
998    LastValidRow = KeepV[KeepV.Len()-1];
999  }
1000  void TTable::GetPartitionRanges(TIntPrV& Partitions, TInt NumPartitions) const {
1001    TInt PartitionSize = NumValidRows / (NumPartitions);
1002    if (NumValidRows % NumPartitions != 0) PartitionSize++;
1003    if (PartitionSize < 10) { 
1004      PartitionSize = 10;
1005      NumPartitions = NumValidRows / PartitionSize; 
1006    }
1007    Partitions.Reserve(NumPartitions+1);
1008    TInt currRow = FirstValidRow;
1009    TInt currStart = currRow;
1010    if (IsNextDirty) {
1011      TInt currCount = PartitionSize;
1012      while (currRow != TTable::Last) {
1013        if (currCount == 0) {
1014          Partitions.Add(TIntPr(currStart, currRow));
1015          currStart = currRow;
1016          currCount = PartitionSize;
1017        }
1018        currRow = Next[currRow];
1019        currCount--;
1020      }
1021      Partitions.Add(TIntPr(currStart, currRow));
1022    } else {
1023      currRow += PartitionSize;
1024      while (currRow != TTable::Last && currRow < Next.Len()) {
1025        if (Next[currRow] == TTable::Invalid) { currRow++; continue; }
1026        Partitions.Add(TIntPr(currStart, currRow));
1027        currStart = currRow;
1028        currRow += PartitionSize;
1029      }
1030      Partitions.Add(TIntPr(currStart, TTable::Last));
1031    }
1032  }
1033  void TTable::GroupingSanityCheck(const TStr& GroupBy, const TAttrType& AttrType) const {
1034    if (!IsColName(GroupBy)) {
1035      TExcept::Throw("no such column " + GroupBy);
1036    }
1037    if (GetColType(GroupBy) != AttrType) {
1038      TExcept::Throw(GroupBy + " values are not of expected type");
1039    }
1040  }
1041  #ifdef GCC_ATOMIC
1042  void TTable::GroupByIntColMP(const TStr& GroupBy, THashMP<TInt, TIntV>& Grouping, TBool UsePhysicalIds) const {
1043    timeval timer0;
1044    gettimeofday(&timer0, NULL);
1045    TInt IdColIdx = GetColIdx(IdColName);
1046    TInt GroupByColIdx = GetColIdx(GroupBy);
1047    if(!UsePhysicalIds && IdColIdx < 0){
1048    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1049    }
1050    GroupingSanityCheck(GroupBy, atInt);
1051    TIntPrV Partitions;
1052    GetPartitionRanges(Partitions, 8*CHUNKS_PER_THREAD);
1053    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1054    Grouping.Gen(NumValidRows);
1055    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1056    for (int i = 0; i < Partitions.Len(); i++){
1057      TRowIterator RowI(Partitions[i].GetVal1(), this);
1058      TRowIterator EndI(Partitions[i].GetVal2(), this);
1059      while (RowI < EndI) {
1060        TInt idx = UsePhysicalIds ? RowI.GetRowIdx() : RowI.GetIntAttr(IdColIdx);
1061        UpdateGrouping<TInt>(Grouping, RowI.GetIntAttr(GroupByColIdx), idx);
1062        RowI++;
1063      }
1064    }
1065    gettimeofday(&timer0, NULL);
1066  }
1067  #endif 
1068  void TTable::Unique(const TStr& Col) {
1069    TIntV RemainingRows;
1070    TStr NCol = NormalizeColName(Col);
1071    switch (GetColType(NCol)) {
1072      case atInt: {
1073        TIntIntVH Grouping;
1074        GroupByIntCol(NCol, Grouping, TIntV(), true, true);
1075        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1076          RemainingRows.Add(it->Dat[0]);
1077        }
1078        break;
1079      }
1080      case atFlt: {
1081        THash<TFlt,TIntV> Grouping;
1082        GroupByFltCol(NCol, Grouping, TIntV(), true, true);
1083        for (THash<TFlt,TIntV>::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1084          RemainingRows.Add(it->Dat[0]);
1085        }
1086        break;
1087      } 
1088      case atStr: {
1089        TIntIntVH Grouping;
1090        GroupByStrCol(NCol, Grouping, TIntV(), true, true);
1091        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1092          RemainingRows.Add(it->Dat[0]);
1093        }
1094        break;
1095      }
1096    }
1097    KeepSortedRows(RemainingRows);
1098  }
<span onclick='openModal()' class='match'>1099  void TTable::Unique(const TStrV& Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
</span>1105    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1106    TIntV UniqueVec;
1107    GroupAux(NCols, Grouping, Ordered, "", true, UniqueVec, true);
1108    KeepSortedRows(UniqueVec);
1109  }
1110  void TTable::StoreGroupCol(const TStr& GroupColName, const TVec<TPair<TInt, TInt> >& GroupAndRowIds) {
1111    IntCols.Add(TIntV(NumRows));
1112    TInt L = IntCols.Len();
1113    AddColType(GroupColName, atInt, L-1);
1114    for (TInt i = 0; i < GroupAndRowIds.Len(); i++) {
1115      IntCols[L-1][GroupAndRowIds[i].Val2] = GroupAndRowIds[i].Val1;
1116    }
1117  }
1118  void TTable::GroupAux(const TStrV& GroupBy, THash<TGroupKey, TPair<TInt, TIntV> >& Grouping, 
1119   TBool Ordered, const TStr& GroupColName, TBool KeepUnique, TIntV& UniqueVec, TBool UsePhysicalIds) {
1120    TInt IdColIdx = GetColIdx(IdColName);
1121    if(!UsePhysicalIds && IdColIdx < 0){
1122    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1123    }
1124    TIntV IntGroupByCols;
1125    TIntV FltGroupByCols;
1126    TIntV StrGroupByCols;
1127    for (TInt c = 0; c < GroupBy.Len(); c++) {
1128      if (!IsColName(GroupBy[c])) { 
1129        TExcept::Throw("no such column " + GroupBy[c]); 
1130      }
1131      TPair<TAttrType, TInt> ColType = GetColTypeMap(GroupBy[c]);
1132      switch (ColType.Val1) {
1133        case atInt:
1134          IntGroupByCols.Add(ColType.Val2);
1135          break;
1136        case atFlt:
1137          FltGroupByCols.Add(ColType.Val2);
1138          break;
1139        case atStr:
1140          StrGroupByCols.Add(ColType.Val2);
1141          break;
1142      }
1143    }
1144    TInt IKLen = IntGroupByCols.Len();
1145    TInt FKLen = FltGroupByCols.Len();
1146    TInt SKLen = StrGroupByCols.Len();
1147    TInt GroupNum = 0;
1148    TVec<TPair<TInt, TInt> > GroupAndRowIds;
1149    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
1150      TIntV IKey(IKLen + SKLen, 0);
1151      TFltV FKey(FKLen, 0);
1152      TIntV SKey(SKLen, 0);
1153      for (TInt c = 0; c < IKLen; c++) {
1154        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
1155      }
1156      for (TInt c = 0; c < FKLen; c++) {
1157        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
1158      }
1159      for (TInt c = 0; c < SKLen; c++) {
1160        SKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
1161      }
1162      if (!Ordered) {
1163        if (IKLen > 0) { IKey.ISort(0, IKey.Len()-1, true); }
1164        if (FKLen > 0) { FKey.ISort(0, FKey.Len()-1, true); }
1165        if (SKLen > 0) { SKey.ISort(0, SKey.Len()-1, true); }
1166      }
1167      for (TInt c = 0; c < SKLen; c++) {
1168        IKey.Add(SKey[c]);
1169      }
1170      TGroupKey GroupKey = TGroupKey(IKey, FKey);
1171      TInt RowIdx = it.GetRowIdx();
1172      TInt idx = UsePhysicalIds ? it.GetRowIdx() : IntCols[IdColIdx][it.GetRowIdx()];
1173      if (!Grouping.IsKey(GroupKey)) {
1174        TPair<TInt, TIntV> NewGroup;
1175        NewGroup.Val1 = GroupNum;
1176        NewGroup.Val2.Add(idx);
1177        Grouping.AddDat(GroupKey, NewGroup);
1178        if (GroupColName != "") {
1179          GroupAndRowIds.Add(TPair<TInt, TInt>(GroupNum, RowIdx));
1180        }
1181        if (KeepUnique) { 
1182          UniqueVec.Add(idx);
1183        }
1184        GroupNum++;
1185      } else {
1186        if (!KeepUnique) {
1187          TPair<TInt, TIntV>& NewGroup = Grouping.GetDat(GroupKey);
1188          NewGroup.Val2.Add(idx);
1189          if (GroupColName != "") {
1190            GroupAndRowIds.Add(TPair<TInt, TInt>(NewGroup.Val1, RowIdx));
1191          }
1192        }
1193      }
1194    }
1195    if (!KeepUnique) {
1196      GroupStmt Stmt(NormalizeColNameV(GroupBy), Ordered, UsePhysicalIds);
1197      GroupStmtNames.AddDat(GroupColName, Stmt);
1198      GroupIDMapping.AddKey(Stmt);
1199      GroupMapping.AddKey(Stmt);
1200      for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1201        TGroupKey key = it.GetKey();
1202        TPair<TInt, TIntV> group = it.GetDat();
1203        GroupIDMapping.GetDat(Stmt).AddDat(group.Val1, TGroupKey(key));
1204        GroupMapping.GetDat(Stmt).AddDat(TGroupKey(key), TIntV(group.Val2));
1205      }
1206    }
1207    if (GroupColName != "") {
1208      StoreGroupCol(GroupColName, GroupAndRowIds);
1209      AddSchemaCol(GroupColName, atInt);  
1210    }
1211  }
1212  void TTable::Group(const TStrV& GroupBy, const TStr& GroupColName, TBool Ordered, TBool UsePhysicalIds) {
1213    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1214    TStr NGroupColName = NormalizeColName(GroupColName);
1215    TIntV UniqueVec;
1216    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1217    GroupAux(NGroupBy, Grouping, Ordered, NGroupColName, false, UniqueVec, UsePhysicalIds);
1218  }
1219  void TTable::InvalidatePhysicalGroupings(){
1220  }
1221  void TTable::InvalidateAffectedGroupings(const TStr& Attr){
1222  }
1223  void TTable::Aggregate(const TStrV& GroupByAttrs, TAttrAggr AggOp,
1224   const TStr& ValAttr, const TStr& ResAttr, TBool Ordered) {
1225     for (TInt c = 0; c < GroupByAttrs.Len(); c++) {
1226      if (!IsColName(GroupByAttrs[c])) { 
1227        TExcept::Throw("no such column " + GroupByAttrs[c]); 
1228      }
1229     }
1230    TStrV NGroupByAttrs = NormalizeColNameV(GroupByAttrs);
1231    TBool UsePhysicalIds = (GetColIdx(IdColName) < 0);
1232    THash<TInt,TIntV> GroupByIntMapping;
1233    THash<TFlt,TIntV> GroupByFltMapping;
1234    THash<TInt,TIntV> GroupByStrMapping;
1235    THash<TGroupKey,TIntV> Mapping;
1236  #ifdef GCC_ATOMIC
1237    THashMP<TInt,TIntV> GroupByIntMapping_MP(NumValidRows);
1238    TIntV GroupByIntMPKeys(NumValidRows);
1239  #endif
1240    TInt NumOfGroups = 0;
1241    TInt GroupingCase = 0;
1242    GroupStmt Stmt(NGroupByAttrs, Ordered, UsePhysicalIds);
1243    if (GroupMapping.IsKey(Stmt)) {
1244      Mapping = GroupMapping.GetDat(Stmt);
1245    } else{
1246    	if(NGroupByAttrs.Len() == 1){
1247    		switch(GetColType(NGroupByAttrs[0])){
1248    			case atInt:
1249  #ifdef GCC_ATOMIC
1250    				if(GetMP()){
1251    					GroupByIntColMP(NGroupByAttrs[0], GroupByIntMapping_MP, UsePhysicalIds);
1252    					int x = 0;
1253  					for(THashMP<TInt,TIntV>::TIter it = GroupByIntMapping_MP.BegI(); it < GroupByIntMapping_MP.EndI(); it++){
1254  						GroupByIntMPKeys[x] = it.GetKey();
1255  						x++;
1256  					}
1257    					NumOfGroups = x;
1258    					GroupingCase = 4;
1259    					break;
1260    				}
1261  #endif 
1262    				GroupByIntCol(NGroupByAttrs[0], GroupByIntMapping, TIntV(), true, UsePhysicalIds);
1263    				NumOfGroups = GroupByIntMapping.Len();
1264    				GroupingCase = 1;
1265    				break;
1266    			case atFlt:
1267    				GroupByFltCol(NGroupByAttrs[0], GroupByFltMapping, TIntV(), true, UsePhysicalIds);
1268    				NumOfGroups = GroupByFltMapping.Len();
1269    				GroupingCase = 2;
1270    				break;
1271    			case atStr:
1272    				GroupByStrCol(NGroupByAttrs[0], GroupByStrMapping, TIntV(), true, UsePhysicalIds);
1273    				NumOfGroups = GroupByStrMapping.Len();
1274    				GroupingCase = 3;
1275    				break;
1276    		}
1277    	}
1278    	else{
1279    		TIntV UniqueVector;
1280    		THash<TGroupKey, TPair<TInt, TIntV> > Mapping_aux;
1281    		GroupAux(NGroupByAttrs, Mapping_aux, Ordered, "", false, UniqueVector, UsePhysicalIds);
1282    		for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Mapping_aux.BegI(); it < Mapping_aux.EndI(); it++){
1283    			Mapping.AddDat(it.GetKey(), it.GetDat().Val2);
1284    		}
1285    		NumOfGroups = Mapping.Len();
1286    	}
1287    }
1288    TAttrType T = GetColType(ValAttr);
1289    if (AggOp == aaCount) { AddIntCol(ResAttr); } 
1290    else {
1291      if (T == atInt) { AddIntCol(ResAttr); }
1292      else if (T == atFlt) { AddFltCol(ResAttr); }
1293      else {
1294        TExcept::Throw("Invalid aggregation for Str type!");
1295      }
1296    }
1297    TInt ColIdx = GetColIdx(ResAttr);
1298    TInt AggrColIdx = GetColIdx(ValAttr);
1299  #ifdef USE_OPENMP
1300    #pragma omp parallel for schedule(dynamic)
1301  #endif 
1302    for (int g = 0; g < NumOfGroups; g++) {
1303    	TIntV* GroupRows = NULL;
1304    	switch(GroupingCase){
1305    		case 0:
1306    			GroupRows = & Mapping.GetDat(Mapping.GetKey(g));
1307    			break;
1308    		case 1:
1309    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1310    			break;
1311    		case 2:
1312    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1313    			break;
1314    	    case 3:
1315    			GroupRows = & GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g));
1316    			break;
1317    		case 4:
1318  #ifdef GCC_ATOMIC
1319    			GroupRows = & GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]);
1320  #endif
1321    			break;
1322    	}
1323  	TIntV& ValidRows = *GroupRows;
1324      TInt sz = ValidRows.Len();
1325      if (sz <= 0) continue;
1326      if (AggOp == aaCount) {
1327        for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; }
1328      } else {
1329        if (T == atInt) {
1330          TIntV V;
1331          for (TInt i = 0; i < sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); }
1332          TInt Res = AggregateVector<TInt>(V, AggOp);
1333          if (AggOp == aaMean) { Res = Res / sz; }
1334          for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; }
1335        } else {
1336          TFltV V;
1337          for (TInt i = 0; i < sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); }
1338          TFlt Res = AggregateVector<TFlt>(V, AggOp);
1339          if (AggOp == aaMean) { Res /= sz; }
1340          for (TInt i = 0; i < sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; }
1341        }
1342      }
1343    }
1344  }
1345  void TTable::AggregateCols(const TStrV& AggrAttrs, TAttrAggr AggOp, const TStr& ResAttr) {
1346    TVec<TPair<TAttrType, TInt> >Info;
1347    for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1348      Info.Add(GetColTypeMap(AggrAttrs[i]));
1349      if (Info[i].Val1 != Info[0].Val1) {
1350        TExcept::Throw("AggregateCols: Aggregation attributes must have the same type");
1351      }
1352    }
1353    if (Info[0].Val1 == atInt) {
1354      AddIntCol(ResAttr);
1355      TInt ResIdx = GetColIdx(ResAttr);
1356      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1357        TInt RowIdx = RI.GetRowIdx();
1358        TIntV V;
1359        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1360          V.Add(IntCols[Info[i].Val2][RowIdx]);
1361        }
1362        IntCols[ResIdx][RowIdx] = AggregateVector<TInt>(V, AggOp);
1363      }
1364    } else if (Info[0].Val1 == atFlt) {
1365      AddFltCol(ResAttr);
1366      TInt ResIdx = GetColIdx(ResAttr);
1367      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1368        TInt RowIdx = RI.GetRowIdx();
1369        TFltV V;
1370        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1371          V.Add(FltCols[Info[i].Val2][RowIdx]);
1372        }
1373        FltCols[ResIdx][RowIdx] = AggregateVector<TFlt>(V, AggOp);
1374      }
1375    } else {
1376      TExcept::Throw("AggregateCols: Only Int and Flt aggregation supported right now");
1377    }
1378  }
1379  void TTable::PrintGrouping(const THash<TGroupKey, TIntV>& Mapping) const{
1380  	for(THash<TGroupKey, TIntV>::TIter it = Mapping.BegI(); it < Mapping.EndI(); it++){
1381    		TGroupKey gk = it.GetKey();
1382    		TIntV ik = gk.Val1;
1383    		TFltV fk = gk.Val2;
1384    		for(int i = 0; i < ik.Len(); i++){ printf("%d ",ik[i].Val);} 
1385    		for(int i = 0; i < fk.Len(); i++){ printf("%f ",fk[i].Val);} 
1386    		printf("-->");
1387    		TIntV v = it.GetDat();
1388    		for(int i = 0; i < v.Len(); i++){ printf("%d ",v[i].Val);} 
1389    		printf("\n");
1390    	}
1391  }
1392  void TTable::Count(const TStr& CountColName, const TStr& Col) {
1393    TStrV GroupByAttrs;
1394    GroupByAttrs.Add(CountColName);
1395    Aggregate(GroupByAttrs, aaCount, "", Col);
1396  }
1397  TVec<PTable> TTable::SpliceByGroup(const TStrV& GroupBy, TBool Ordered) {
1398    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1399    TIntV UniqueVec;
1400    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
1401    TVec<PTable> Result;
1402    Schema NewSchema;
1403    for (TInt c = 0; c < Sch.Len(); c++) {
1404      if (Sch[c].Val1 != GetIdColName()) {
1405        NewSchema.Add(Sch[c]);
1406      }
1407    }
1408    GroupAux(NGroupBy, Grouping, Ordered, "", false, UniqueVec);
1409    TInt cnt = 0;
1410    for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it != Grouping.EndI(); it++) {
1411      PTable GroupTable = TTable::New(NewSchema, Context);
1412      TVec<TPair<TAttrType, TInt> > ColInfo;
1413      TIntV V;
1414      for (TInt i = 0; i < Sch.Len(); i++) {
1415        ColInfo.Add(GroupTable->GetColTypeMap(Sch[i].Val1));
1416        if (Sch[i].Val1 == IdColName()) {
1417          ColInfo[i].Val2 = -1;
1418        }
1419        V.Add(GetColIdx(Sch[i].Val1));
1420      }
1421      TIntV& Rows = it.GetDat().Val2;
1422      for (TInt i = 0; i < Rows.Len(); i++) {
1423        TInt RowIdx = RowIdMap.GetDat(Rows[i]);
1424        for (TInt c = 0; c < Sch.Len(); c++) {
1425          TPair<TAttrType, TInt> Info = ColInfo[c];
1426          TInt ColIdx = Info.Val2;
1427          if (ColIdx == -1) { continue; }
1428          switch (Info.Val1) {
1429            case atInt:
1430              GroupTable->IntCols[ColIdx].Add(IntCols[V[c]][RowIdx]);
1431              break;
1432            case atFlt:
1433              GroupTable->FltCols[ColIdx].Add(FltCols[V[c]][RowIdx]);
1434              break;
1435            case atStr:
1436              GroupTable->StrColMaps[ColIdx].Add(StrColMaps[V[c]][RowIdx]);
1437              break;
1438          }
1439        }
1440        if (GroupTable->LastValidRow >= 0) {
1441          GroupTable->Next[GroupTable->LastValidRow] = GroupTable->NumRows;
1442        }
1443        GroupTable->Next.Add(GroupTable->Last);
1444        GroupTable->LastValidRow = GroupTable->NumRows;
1445        GroupTable->NumRows++;
1446        GroupTable->NumValidRows++;
1447      }
1448      GroupTable->InitIds();
1449      Result.Add(GroupTable);
1450      cnt += 1;
1451    }
1452    return Result;
1453  }
1454  void TTable::InitIds() {
1455    IdColName = "_id";
1456    AddIdColumn(IdColName);
1457  }
1458  void TTable::Reindex() {
1459    RowIdMap.Clr();
1460    TInt IdColIdx = GetColIdx(IdColName);
1461    TInt IdCnt = 0;
1462    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1463      IntCols[IdColIdx][RI.GetRowIdx()] = IdCnt;
1464      RowIdMap.AddDat(RI.GetRowIdx(), IdCnt);
1465      IdCnt++;
1466    }
1467  }
1468  void TTable::AddIdColumn(const TStr& ColName) {
1469    TInt IdCol = IntCols.Add();
1470    IntCols[IdCol].Reserve(NumRows, NumRows);
1471    TInt IdCnt = 0;
1472    RowIdMap.Clr();
1473    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1474      IntCols[IdCol][RI.GetRowIdx()] = IdCnt;
1475      RowIdMap.AddDat(IdCnt, RI.GetRowIdx());
1476      IdCnt++;
1477    }
1478    AddSchemaCol(ColName, atInt);
1479    AddColType(ColName, atInt, IntCols.Len()-1);
1480  }
1481   PTable TTable::InitializeJointTable(const TTable& Table) {
1482    PTable JointTable = New(Context);
1483    JointTable->IntCols = TVec<TIntV>(IntCols.Len() + Table.IntCols.Len() + 1);
1484    JointTable->FltCols = TVec<TFltV>(FltCols.Len() + Table.FltCols.Len());
1485    JointTable->StrColMaps = TVec<TIntV>(StrColMaps.Len() + Table.StrColMaps.Len());
1486    for (TInt i = 0; i < Sch.Len(); i++) {
1487      TStr ColName = GetSchemaColName(i);
1488      TAttrType ColType = GetSchemaColType(i);
1489      TStr CName = JointTable->RenumberColName(ColName);
1490      TPair<TAttrType, TInt> TypeMap = GetColTypeMap(ColName);
1491      JointTable->AddColType(CName, TypeMap);
1492      JointTable->AddSchemaCol(CName, ColType);
1493    }
1494    for (TInt i = 0; i < Table.Sch.Len(); i++) {
1495      TStr ColName = Table.GetSchemaColName(i);
1496      TAttrType ColType = Table.GetSchemaColType(i);
1497      TStr CName = JointTable->RenumberColName(ColName);
1498      TPair<TAttrType, TInt> NewDat = Table.GetColTypeMap(ColName);
1499      Assert(ColType == NewDat.Val1);
1500      switch (NewDat.Val1) {
1501        case atInt:
1502          NewDat.Val2 += IntCols.Len();
1503          break;
1504        case atFlt:
1505          NewDat.Val2 += FltCols.Len();
1506          break;
1507        case atStr:
1508          NewDat.Val2 += StrColMaps.Len();
1509          break;
1510      }
1511      JointTable->AddColType(CName, NewDat);
1512      JointTable->AddSchemaCol(CName, ColType);
1513    }
1514    TStr IdColName = "_id";
1515    JointTable->AddColType(IdColName, atInt, IntCols.Len() + Table.IntCols.Len());
1516    JointTable->AddSchemaCol(IdColName, atInt);
1517    return JointTable;
1518  }
1519  void TTable::AddJointRow(const TTable& T1, const TTable& T2, TInt RowIdx1, TInt RowIdx2) {
1520    for (TInt i = 0; i < T1.IntCols.Len(); i++) {
1521      IntCols[i].Add(T1.IntCols[i][RowIdx1]);
1522    }
1523    for (TInt i = 0; i < T1.FltCols.Len(); i++) {
1524      FltCols[i].Add(T1.FltCols[i][RowIdx1]);
1525    }
1526    for (TInt i = 0; i < T1.StrColMaps.Len(); i++) {
1527      StrColMaps[i].Add(T1.StrColMaps[i][RowIdx1]);
1528    }
1529    TInt IntOffset = T1.IntCols.Len();
1530    TInt FltOffset = T1.FltCols.Len();
1531    TInt StrOffset = T1.StrColMaps.Len();
1532    for (TInt i = 0; i < T2.IntCols.Len(); i++) {
1533      IntCols[i+IntOffset].Add(T2.IntCols[i][RowIdx2]);
1534    }
1535    for (TInt i = 0; i < T2.FltCols.Len(); i++) {
1536      FltCols[i+FltOffset].Add(T2.FltCols[i][RowIdx2]);
1537    }
1538    for (TInt i = 0; i < T2.StrColMaps.Len(); i++) {
1539      StrColMaps[i+StrOffset].Add(T2.StrColMaps[i][RowIdx2]);
1540    }
1541    TInt IdOffset = IntOffset + T2.IntCols.Len(); 
1542    NumRows++;
1543    NumValidRows++;
1544    if (!Next.Empty()) {
1545      Next[Next.Len()-1] = NumValidRows-1;
1546      LastValidRow = NumValidRows-1;
1547    }
1548    Next.Add(Last);
1549    RowIdMap.AddDat(NumRows-1,NumRows-1);
1550    IntCols[IdOffset].Add(NumRows-1);
1551  }
1552  PTable TTable::SimJoin(const TStrV& Cols1, const TTable& Table, const TStrV& Cols2, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold)
1553  {
1554  	Assert(Cols1.Len() == Cols2.Len());
1555  	if(Cols1.Len()!=Cols2.Len()){
1556  		TExcept::Throw("Column vectors must match in type and length");
1557  	}
1558  	for (TInt i = 0; i < Cols1.Len(); i++) {
1559  		if(!IsColName(Cols1[i]) || !Table.IsColName(Cols2[i])){
1560  			TExcept::Throw("Column not found in Table");
1561  		}
1562  		TAttrType Type1 = GetColType(Cols1[i]);
1563  		TAttrType Type2 = GetColType(Cols2[i]);
1564  		if(Type1!=Type2){
1565  			TExcept::Throw("Column types on the two tables must match.");
1566  		}
1567  		if((Type1!=atInt && Type1!=atFlt) || (Type2!=atInt && Type2!=atFlt)){
1568  			TExcept::Throw("Column type not supported. Only Flt and Int column types are supported.");
1569  		}
1570    }
1571    PTable JointTable = InitializeJointTable(Table);
1572  	TFltV DistanceV;
1573  	for(TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1574  		for(TRowIterator RowI2 = Table.BegRI(); RowI2 < Table.EndRI(); RowI2++) {
1575  			float distance = 0;
1576  			switch(SimType)
1577  			{
1578  				case L2Norm:
1579  					for(TInt i = 0; i < Cols1.Len(); i++) {
1580  						float attrVal1, attrVal2;
1581  						attrVal1 = GetColType(Cols1[i])==atInt ? (float)RowI.GetIntAttr(Cols1[i]) : (float)RowI.GetFltAttr(Cols1[i]);
1582  						attrVal2 = Table.GetColType(Cols2[i])==atInt ? (float)RowI2.GetIntAttr(Cols2[i]) : (float)RowI2.GetFltAttr(Cols2[i]);
1583  						distance += pow(attrVal1 - attrVal2, 2);
1584  					}
1585  					distance = sqrt(distance);
1586  					if(distance<=Threshold){
1587  						JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1588  						DistanceV.Add(distance);
1589  					}
1590  					break;
1591  				case Haversine:
1592  					{
1593  						if(Cols1.Len()!=2){
1594  							TExcept::Throw("Haversine disance expects exactly two attributes - latitude and longitude - in that order.");
1595  						}
1596  						TFlt Radius = 6373; 
1597  						float Latitude1  = GetColType(Cols1[0])==atInt ? (float)RowI.GetIntAttr(Cols1[0]) : (float)RowI.GetFltAttr(Cols1[0]);
1598  						float Latitude2 = Table.GetColType(Cols2[0])==atInt ? (float)RowI2.GetIntAttr(Cols2[0]) : (float)RowI2.GetFltAttr(Cols2[0]);
1599  						float Longitude1  = GetColType(Cols1[1])==atInt ? (float)RowI.GetIntAttr(Cols1[1]) : (float)RowI.GetFltAttr(Cols1[1]);
1600  						float Longitude2  = Table.GetColType(Cols2[1])==atInt ? (float)RowI2.GetIntAttr(Cols2[1]) : (float)RowI2.GetFltAttr(Cols2[1]);
1601  						Latitude1 *= static_cast<float>(M_PI/180.0);
1602  						Latitude2 *= static_cast<float>(M_PI/180.0);
1603  						Longitude1 *= static_cast<float>(M_PI/180.0);
1604  						Longitude2 *= static_cast<float>(M_PI/180.0);
1605  						float dlon = Longitude2 - Longitude1;
1606  						float dlat = Latitude2 - Latitude1;
1607  						float a = pow(sin(dlat/2), 2) + cos(Latitude1)*cos(Latitude2)*pow(sin(dlon/2), 2);
1608  						float c = 2*atan2(sqrt(a), sqrt(1-a));
1609  						distance = (static_cast<float>(Radius.Val))*c;
1610  						if(distance<=Threshold){
1611  							JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1612  							DistanceV.Add(distance);
1613  						}
1614  					}
1615  					break;
1616  				case L1Norm:
1617  				case Jaccard:
1618  					TExcept::Throw("This distance metric is not supported");
1619  			}
1620  		}	
1621  	}
1622  	JointTable->StoreFltCol(DistanceColName, DistanceV);
1623  	JointTable->InitIds();
1624  	return JointTable;
1625  }
1626  PTable TTable::SelfSimJoinPerGroup(const TStr& GroupAttr, const TStr& SimCol, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) 
1627  {
1628  	if(!IsColName(SimCol) || !IsColName(GroupAttr)){
1629  		TExcept::Throw("No such column found in table");
1630  	}
1631    PTable JointTable = New(Context);
1632  	JointTable->IntCols = TVec<TIntV>(2);
1633  	JointTable->FltCols = TVec<TFltV>(1);
1634  	for(TInt i=0;i<2;i++){
1635      TInt Suffix = i+1;
1636      TStr CName = "GroupId_" + Suffix.GetStr();
1637      TPair<TAttrType, TInt> Group(atInt, (int)i);
1638      JointTable->AddColType(CName, Group);
1639      JointTable->AddSchemaCol(CName, atInt);
1640    }
1641  	TPair<TAttrType, TInt> Group(atFlt, 0);
1642  	JointTable->AddColType(DistanceColName, Group);
1643  	JointTable->AddSchemaCol(DistanceColName, atFlt);
1644  	THash<TInt, THash<TInt, TInt> > TIntHH;
1645  	TAttrType attrType = GetColType(SimCol);
1646  	TInt GroupColIdx = GetColIdx(GroupAttr);
1647  	TInt SimColIdx = GetColIdx(SimCol);
1648  	for (TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1649  		TInt GroupId = IntCols[GroupColIdx][RowI.GetRowIdx()];
1650  		if(attrType==atInt || attrType==atStr)
1651  		{
1652  			if(!TIntHH.IsKey(GroupId)){
1653  				THash<TInt, TInt> TIntH;
1654  				TIntHH.AddDat(GroupId, TIntH);
1655  			}
1656  			THash<TInt, TInt>& TIntH = TIntHH.GetDat(GroupId);
1657  			TInt SimAttrVal = (attrType==atInt ? IntCols[SimColIdx][RowI.GetRowIdx()] : StrColMaps[SimColIdx][RowI.GetRowIdx()]);
1658  			TIntH.AddDat(SimAttrVal, 0);
1659  		}
1660  		else
1661  		{
1662  			TExcept::Throw("Attribute type not supported.");
1663  		}
1664  	}
1665  	for (THash<TInt, THash<TInt, TInt> >::TIter it1 = TIntHH.BegI(); it1 < TIntHH.EndI(); it1++) {
1666  		THash<TInt, TInt> Vals1H = it1.GetDat();
1667  		TInt GroupId1 = it1.GetKey();
1668  		for (THash<TInt, THash<TInt, TInt> >::TIter it2 = TIntHH.BegI(); it2 < TIntHH.EndI(); it2++) {
1669  				int intersectionCount = 0;
1670  				TInt GroupId2 = it2.GetKey();
1671  				THash<TInt, TInt> Vals2H = it2.GetDat();
1672  				for(THash<TInt, TInt>::TIter it = Vals1H.BegI(); it < Vals1H.EndI(); it++)
1673  				{
1674  					TInt Val = it.GetKey();
1675  					if(Vals2H.IsKey(Val)){
1676  						intersectionCount+=1;
1677  					}
1678  				}
1679  				int unionCount = Vals1H.Len() + Vals2H.Len() - intersectionCount;
1680  				float distance = 1.0f - (float)intersectionCount/unionCount;
1681  				if(distance<=Threshold){
1682  						JointTable->IntCols[0].Add(GroupId1);
1683  						JointTable->IntCols[1].Add(GroupId2);
1684  						JointTable->FltCols[0].Add(distance);
1685  						JointTable->IncrementNext();
1686  			}
1687  		}
1688  	}
1689    JointTable->InitIds();
1690  	return JointTable;
1691  }
1692  PTable TTable::SelfSimJoinPerGroup(const TStrV& GroupBy, const TStr& SimCol, 
1693   const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) {
1694    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1695  	TStrV ProjectionV;
1696  	for(TInt i=0; i<GroupBy.Len(); i++)
1697  	{
1698  		ProjectionV.Add(GroupBy[i]);
1699  	}
1700  	ProjectionV.Add(SimCol);
1701  	ProjectInPlace(ProjectionV);
1702  	TStr CName = "Group";
1703    TIntV UniqueVec;
1704    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1705    GroupAux(NGroupBy, Grouping, false, CName, false, UniqueVec);
1706  	PTable GroupJointTable = SelfSimJoinPerGroup(CName, SimCol, DistanceColName, SimType, Threshold);
1707  	PTable JointTable = InitializeJointTable(*this);
1708  	THash<TInt, TInt> GroupIdH;
1709  	for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it=Grouping.BegI(); it<Grouping.EndI(); it++)
1710  	{
1711  		TPair<TInt, TIntV> group = it.GetDat();
1712  		TInt GroupNum = group.Val1;
1713  		TIntV RowIds = group.Val2;
1714  		if(!GroupIdH.IsKey(GroupNum))
1715  		{
1716  			TInt RandomRowId = RowIds[0];  
1717  			GroupIdH.AddDat(GroupNum, RandomRowId);
1718  		}
1719  	}
1720  	for(TRowIterator RowI = GroupJointTable->BegRI(); RowI < GroupJointTable->EndRI(); RowI++)
1721  	{
1722  		TInt GroupId1 = GroupJointTable->IntCols[0][RowI.GetRowIdx()];
1723  		TInt GroupId2 = GroupJointTable->IntCols[1][RowI.GetRowIdx()];
1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
1725  		TInt RowId2 = GroupIdH.GetDat(GroupId2);
1726  		JointTable->AddJointRow(*this, *this, RowId1, RowId2);
1727  	} 
1728  	JointTable->StoreFltCol(DistanceColName, GroupJointTable->FltCols[0]);
1729  	ProjectionV.Clr();
1730  	ProjectionV.Add(DistanceColName);
1731  	for(TInt i=0; i<GroupBy.Len(); i++){
1732  		for(TInt j=0; j<JointTable->Sch.Len(); j++)
1733  		{
1734  			TStr ColName = JointTable->Sch[j].Val1;
1735  			if(ColName.IsStrIn(GroupBy[i]))
1736  			{
1737  				ProjectionV.Add(ColName);
1738  			}
1739  		}
1740  	}
1741  	JointTable->ProjectInPlace(ProjectionV);
1742  	JointTable->InitIds();
1743  	return JointTable;
1744  }
1745  void TTable::IncrementNext()
1746  {
1747  	NumRows++;
1748  	NumValidRows++;
1749  	if (!Next.Empty()) {
1750  		Next[Next.Len()-1] = NumValidRows-1;
1751  		LastValidRow = NumValidRows-1;
1752  	}
1753  	Next.Add(Last);
1754  }
1755  PTable TTable::Join(const TStr& Col1, const TTable& Table, const TStr& Col2) {
1756    if (!IsColName(Col1)) {
1757      TExcept::Throw("no such column " + Col1);
1758      printf("no such column %s\n", Col1.CStr());
1759    }
1760    if (!Table.IsColName(Col2)) {
1761      TExcept::Throw("no such column " + Col2);
1762      printf("no such column %s\n", Col2.CStr());
1763    }
1764    if (GetColType(Col1) != Table.GetColType(Col2)) {
1765      TExcept::Throw("Trying to Join on columns of different type");
1766      printf("Trying to Join on columns of different type\n");
1767    }
1768    PTable JointTable = InitializeJointTable(Table);
1769    TAttrType ColType = GetColType(Col1);
1770    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
1771    const TTable& TS = ThisIsSmaller ? *this : Table;
1772    const TTable& TB = ThisIsSmaller ?  Table : *this;
1773    TStr ColS = ThisIsSmaller ? Col1 : Col2;
1774    TStr ColB = ThisIsSmaller ? Col2 : Col1;
1775    TInt ColBId = ThisIsSmaller ? Table.GetColIdx(ColB) : GetColIdx(ColB);
1776  #ifdef GCC_ATOMIC
1777    if (GetMP()) {
1778      switch(ColType){
1779        case atInt:{
1780          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1781          TS.GroupByIntColMP(ColS, T, true);
1782          TIntPrV Partitions;
1783          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1784          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1785          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1786          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1787          for (int i = 0; i < Partitions.Len(); i++){
1788            JointRowIDSet[i].Reserve(PartitionSize);
1789            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1790            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1791            while (RowI < EndI) {
1792              TInt K = RowI.GetIntAttr(ColBId);
1793              if(T.IsKey(K)){
1794                TIntV& Group = T.GetDat(K);
1795                for(TInt j = 0; j < Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
1803              RowI++;
1804            }
1805          }
1806          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);      
1807          break;
1808        }
1809        case atFlt:{
1810          THashMP<TFlt, TIntV> T(TS.GetNumValidRows());
1811          TS.GroupByFltCol(ColS, T, TIntV(), true);
1812          TIntPrV Partitions;
1813          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1814          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1815          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1816          #pragma omp parallel for schedule(dynamic) 
1817          for (int i = 0; i < Partitions.Len(); i++){
1818            JointRowIDSet[i].Reserve(PartitionSize);
1819            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1820            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1821            while (RowI < EndI) {
1822              TFlt K = RowI.GetFltAttr(ColBId);
1823              if(T.IsKey(K)){
1824                TIntV& Group = T.GetDat(K);
1825                for(TInt j = 0; j < Group.Len(); j++){
1826                  if(ThisIsSmaller){
1827                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1828                  } else{
1829                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1830                  }
1831                }
1832              }
1833              RowI++;
1834            }
1835          }
1836          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1837          break;
1838        }
1839        case atStr:{
1840          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1841          TS.GroupByStrCol(ColS, T, TIntV(), true);
1842          TIntPrV Partitions;
1843          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1844          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1845          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1846          #pragma omp parallel for schedule(dynamic) 
1847          for (int i = 0; i < Partitions.Len(); i++){
1848            JointRowIDSet[i].Reserve(PartitionSize);
1849            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1850            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1851            while (RowI < EndI) {
1852              TInt K = RowI.GetStrMapById(ColBId);
1853              if(T.IsKey(K)){
1854                TIntV& Group = T.GetDat(K);
1855                for(TInt j = 0; j < Group.Len(); j++){
1856                  if(ThisIsSmaller){
1857                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1858                  } else{
1859                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1860                  }
1861                }
1862              }
1863              RowI++;
1864            }
1865          }
1866          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1867        }
1868        break;
1869      }
1870    } else {
1871  #endif 
1872      switch (ColType) {
1873        case atInt:{
1874          TIntIntVH T;
1875          TS.GroupByIntCol(ColS, T, TIntV(), true);
1876          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1877            TInt K = RowI.GetIntAttr(ColBId);
1878            if (T.IsKey(K)) {
1879              TIntV& Group = T.GetDat(K);
1880              for (TInt i = 0; i < Group.Len(); i++) {
1881                if (ThisIsSmaller) {
1882                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1883                } else {
1884                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1885                }
1886              }
1887            }
1888          }
1889          break;
1890        }
1891        case atFlt:{
1892          THash<TFlt, TIntV> T;
1893          TS.GroupByFltCol(ColS, T, TIntV(), true);
1894          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1895            TFlt K = RowI.GetFltAttr(ColBId);
1896            if (T.IsKey(K)) {
1897              TIntV& Group = T.GetDat(K);
1898              for (TInt i = 0; i < Group.Len(); i++) {
1899                if (ThisIsSmaller) {
1900                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1901                } else {
1902                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1903                }
1904              }
1905            }
1906          }
1907          break;
1908        }
1909        case atStr:{
1910          TIntIntVH T;
1911          TS.GroupByStrCol(ColS, T, TIntV(), true);
1912          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1913            TInt K = RowI.GetStrMapById(ColBId);
1914            if (T.IsKey(K)) {
1915              TIntV& Group = T.GetDat(K);
1916              for (TInt i = 0; i < Group.Len(); i++) {
1917                if (ThisIsSmaller) {
1918                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1919                } else {
1920                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1921                }
1922              }
1923            }
1924          }
1925        }
1926        break;
1927      }
1928  #ifdef GCC_ATOMIC
1929    }
1930  #endif
1931    return JointTable; 
1932  }
1933  void TTable::ThresholdJoinInputCorrectness(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
1934    const TStr& KeyCol2, const TStr& JoinCol2){
1935    if (!IsColName(KeyCol1)) {
1936      printf("no such column %s\n", KeyCol1.CStr());
1937      TExcept::Throw("no such column " + KeyCol1);
1938    }
1939    if (!Table.IsColName(KeyCol2)) {
1940      printf("no such column %s\n", KeyCol2.CStr());
1941      TExcept::Throw("no such column " + KeyCol2);
1942    }
1943    if (!IsColName(JoinCol1)) {
1944      printf("no such column %s\n", JoinCol1.CStr());
1945      TExcept::Throw("no such column " + JoinCol1);
1946    }
1947    if (!Table.IsColName(JoinCol2)) {
1948      printf("no such column %s\n", JoinCol2.CStr());
1949      TExcept::Throw("no such column " + JoinCol2);
1950    }
1951    if (GetColType(JoinCol1) != Table.GetColType(JoinCol2)) {
1952      printf("Trying to Join on columns of different type\n");
1953      TExcept::Throw("Trying to Join on columns of different type");
1954    }
1955    if (GetColType(KeyCol1) != Table.GetColType(KeyCol2)) {
1956      printf("Key type mismatch\n");
1957      TExcept::Throw("Key type mismatch");
1958    }
1959  }
1960  void TTable::ThresholdJoinCountCollisions(const TTable& TB, const TTable& TS, 
1961    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
1962    THash<TIntPr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
1963      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1964        TInt JVal = 0;
1965        if(JoinColType == atStr){
1966          JVal = RowI.GetStrMapById(JoinColIdxB);
1967        } else{
1968          JVal = RowI.GetIntAttr(JoinColIdxB);
1969        }
1970        if(T.IsKey(JVal)){
1971          TInt KeyB = 0;
1972          if(KeyType == atStr){
1973            KeyB = RowI.GetStrMapById(KeyColIdxB);
1974          } else{
1975            KeyB = RowI.GetIntAttr(KeyColIdxB);
1976          } 
1977          const TIntV& RelevantRows = T.GetDat(JVal);
1978          for(int i = 0; i < RelevantRows.Len(); i++){
1979            TInt KeyS = 0;
1980            if(KeyType == atStr){
1981              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
1982            } else{
1983              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
1984            }
1985            TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
1986            if(Counters.IsKey(Keys)){
1987              TIntTr& V = Counters.GetDat(Keys);
1988              V.Val3 = V.Val3 + 1;
1989            } else{
1990              if(ThisIsSmaller){
1991                Counters.AddDat(Keys, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
1992              } else{
1993                Counters.AddDat(Keys, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
1994              }
1995            }
1996          }	
1997        }	
1998      } 
1999  }
2000  void TTable::ThresholdJoinCountPerJoinKeyCollisions(const TTable& TB, const TTable& TS, 
2001    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
2002    THash<TIntTr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
2003      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
2004        TInt JVal = 0;
2005        if(JoinColType == atStr){
2006          JVal = RowI.GetStrMapById(JoinColIdxB);
2007         } else{
2008          JVal = RowI.GetIntAttr(JoinColIdxB);
2009         }
2010        if(T.IsKey(JVal)){
2011          TInt KeyB = 0;
2012          if(KeyType == atStr){
2013            KeyB = RowI.GetStrMapById(KeyColIdxB);
2014          } else{
2015            KeyB = RowI.GetIntAttr(KeyColIdxB);
2016          } 
2017          const TIntV& RelevantRows = T.GetDat(JVal);
2018          for(int i = 0; i < RelevantRows.Len(); i++){
2019            TInt KeyS = 0;
2020            if(KeyType == atStr){
2021              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
2022            } else{
2023              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
2024            }
2025          	TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
2026          	TIntTr K(Keys.Val1,Keys.Val2,JVal);
2027            if(Counters.IsKey(K)){
2028              TIntTr& V = Counters.GetDat(K);
2029              V.Val3 = V.Val3 + 1;
2030            } else{
2031              if(ThisIsSmaller){
2032                Counters.AddDat(K, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
2033              } else{
2034                Counters.AddDat(K, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
2035              }
2036            }
2037          }	
2038        }	
2039      } 
2040    }
2041  PTable TTable::ThresholdJoinOutputTable(const THash<TIntPr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2042    PTable JointTable = InitializeJointTable(Table);
2043    for(THash<TIntPr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2044      TIntTr& Counter = iter.GetDat();
2045      if(Counter.Val3 >= Threshold){
2046        JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2047      }
2048    }
2049    return JointTable;
2050  }
2051  PTable TTable::ThresholdJoinPerJoinKeyOutputTable(const THash<TIntTr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2052    PTable JointTable = InitializeJointTable(Table);
2053    for(THash<TIntTr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2054      const TIntTr& Counter = iter.GetDat();
2055      const TIntTr& Keys = iter.GetKey();
2056      THashSet<TIntPr> Pairs;
2057      if(Counter.Val3 >= Threshold){
2058        TIntPr K(Keys.Val1,Keys.Val2);
2059        if(!Pairs.IsKey(K)){
2060          Pairs.AddKey(K);
2061          JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2062        }
2063      }
2064    }
2065    return JointTable;
2066  }
2067  PTable TTable::ThresholdJoin(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
2068    const TStr& KeyCol2, const TStr& JoinCol2, TInt Threshold, TBool PerJoinKey){
2069    ThresholdJoinInputCorrectness(KeyCol1, JoinCol1, Table, KeyCol2, JoinCol2);
2070    TAttrType JoinColType = GetColType(JoinCol1);
2071    TAttrType KeyType = GetColType(KeyCol1);
2072    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
2073    const TTable& TS = ThisIsSmaller ? *this : Table;
2074    const TTable& TB = ThisIsSmaller ?  Table : *this;
2075    TStr JoinColS = JoinCol1;
2076    TInt JoinColIdxB = GetColIdx(JoinCol2);
2077    TInt KeyColIdxS = GetColIdx(KeyCol1);
2078    TInt KeyColIdxB = GetColIdx(KeyCol2);
2079    if(!ThisIsSmaller){
2080    	JoinColS = JoinCol2;
2081      JoinColIdxB = GetColIdx(JoinCol1);
2082    	KeyColIdxS = GetColIdx(KeyCol2);
2083      KeyColIdxB = GetColIdx(KeyCol1);
2084    }
2085    if(KeyType != atInt && KeyType != atStr){
2086      printf("ThresholdJoin only supports integer or string key attributes\n");
2087      TExcept::Throw("ThresholdJoin only supports integer or string key attributes");
2088    }
2089    if(JoinColType != atInt && JoinColType != atStr){
2090      printf("ThresholdJoin only supports integer or string join attributes\n");
2091      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2092    }
2093    TIntIntVH T;
2094    if(JoinColType == atInt){
2095      TS.GroupByIntCol(JoinColS, T, TIntV(), true);
2096    } else if(JoinColType == atStr){
2097      TS.GroupByStrCol(JoinColS, T, TIntV(), true);
2098    } else{
2099      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2100    } 
2101    if(PerJoinKey){
2102      THash<TIntTr,TIntTr> Counters;
2103      ThresholdJoinCountPerJoinKeyCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2104      return ThresholdJoinPerJoinKeyOutputTable(Counters, Threshold, Table);
2105    } else{
2106      THash<TIntPr,TIntTr> Counters;
2107      ThresholdJoinCountCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2108      return ThresholdJoinOutputTable(Counters, Threshold, Table);
2109    }
2110  }
2111  void TTable::Select(TPredicate& Predicate, TIntV& SelectedRows, TBool Remove) {
2112    TIntV Selected;
2113    TStrV RelevantCols;
2114    Predicate.GetVariables(RelevantCols);
2115    TInt NumRelevantCols = RelevantCols.Len();
2116    TVec<TAttrType> ColTypes = TVec<TAttrType>(NumRelevantCols);
2117    TIntV ColIndices = TIntV(NumRelevantCols);
2118    for (TInt i = 0; i < NumRelevantCols; i++) {
2119      ColTypes[i] = GetColType(RelevantCols[i]);
2120      ColIndices[i] = GetColIdx(RelevantCols[i]);
2121    } 
2122    if (Remove) {
2123      TRowIteratorWithRemove RowI = BegRIWR();
2124      while (RowI.GetNextRowIdx() != Last) {
2125        for (TInt i = 0; i < NumRelevantCols; i++) {
2126          switch (ColTypes[i]) {
2127          case atInt:
2128            Predicate.SetIntVal(RelevantCols[i], RowI.GetNextIntAttr(ColIndices[i]));
2129            break;
2130          case atFlt:
2131            Predicate.SetFltVal(RelevantCols[i], RowI.GetNextFltAttr(ColIndices[i]));
2132            break;
2133          case atStr:
2134            Predicate.SetStrVal(RelevantCols[i], RowI.GetNextStrAttr(ColIndices[i]));
2135            break;
2136          }
2137        }
2138        if (!Predicate.Eval()) { 
2139          RowI.RemoveNext();
2140        } else {
2141          RowI++;
2142        }
2143      }
2144    } else {
2145      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2146        for (TInt i = 0; i < NumRelevantCols; i++) {
2147          switch (ColTypes[i]) {
2148          case atInt:
2149            Predicate.SetIntVal(RelevantCols[i], RowI.GetIntAttr(RelevantCols[i]));
2150            break;
2151          case atFlt:
2152            Predicate.SetFltVal(RelevantCols[i], RowI.GetFltAttr(RelevantCols[i]));
2153            break;
2154          case atStr:
2155            Predicate.SetStrVal(RelevantCols[i], RowI.GetStrAttr(RelevantCols[i]));
2156            break;
2157          }
2158        }
2159        if (Predicate.Eval()) { SelectedRows.Add(RowI.GetRowIdx()); }
2160      }
2161    }
2162  }
2163  void TTable::Classify(TPredicate& Predicate, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2164    TIntV SelectedRows;
2165    Select(Predicate, SelectedRows, false);
2166    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2167  }
2168  void TTable::SelectAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp, TIntV& SelectedRows, TBool Remove) {
2169    const TAttrType Ty1 = GetColType(Col1);
2170    const TAttrType Ty2 = GetColType(Col2);
2171    const TInt ColIdx1 = GetColIdx(Col1);
2172    const TInt ColIdx2 = GetColIdx(Col2);
2173    if (Ty1 != Ty2) {
2174      TExcept::Throw("SelectAtomic: diff types");
2175    }
2176    if (Cmp == SUBSTR || Cmp == SUPERSTR) { Assert(Ty1 == atStr); }
2177    if (Remove) {
2178      TRowIteratorWithRemove RowI = BegRIWR();
2179      while (RowI.GetNextRowIdx() != Last) {
2180        TBool Result;
2181        switch (Ty1) {
2182          case atInt:
2183            Result = TPredicate::EvalAtom(RowI.GetNextIntAttr(ColIdx1), RowI.GetNextIntAttr(ColIdx2), Cmp);
2184            break;
2185          case atFlt:
2186            Result = TPredicate::EvalAtom(RowI.GetNextFltAttr(ColIdx1), RowI.GetNextFltAttr(ColIdx2), Cmp);
2187            break;
2188          case atStr:
2189            Result = TPredicate::EvalStrAtom(RowI.GetNextStrAttr(ColIdx1), RowI.GetNextStrAttr(ColIdx2), Cmp);
2190            break;
2191        }
2192        if (!Result) { 
2193          RowI.RemoveNext();
2194        } else {
2195          RowI++;
2196        }
2197      }
2198    } else {
2199      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2200        TBool Result;
2201        switch (Ty1) {
2202          case atInt:
2203            Result = TPredicate::EvalAtom(RowI.GetIntAttr(Col1), RowI.GetIntAttr(Col2), Cmp);
2204            break;
2205          case atFlt:
2206            Result = TPredicate::EvalAtom(RowI.GetFltAttr(Col1), RowI.GetFltAttr(Col2), Cmp);
2207            break;
2208          case atStr:
2209            Result = TPredicate::EvalStrAtom(RowI.GetStrAttr(Col1), RowI.GetStrAttr(Col2), Cmp);
2210            break;
2211        }
2212        if (Result) { SelectedRows.Add(RowI.GetRowIdx()); }
2213      }
2214    }
2215  }
2216  void TTable::ClassifyAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp,
2217    const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2218    TIntV SelectedRows;
2219    SelectAtomic(Col1, Col2, Cmp, SelectedRows, false);
2220    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2221  }
2222  void TTable::SelectAtomicConst(const TStr& Col, const TPrimitive& Val, TPredComp Cmp, 
2223    TIntV& SelectedRows, PTable& SelectedTable, TBool Remove, TBool Table) {
2224    TStr ValTStr(Val.GetStr());
2225    TAttrType Type = GetColType(Col);
2226    TInt ColIdx = GetColIdx(Col);
2227    if (Type != Val.GetType()) { 
2228      TExcept::Throw("SelectAtomicConst: coltype does not match const type"); 
2229    }
2230    if(Remove){
2231  #ifdef USE_OPENMP
2232      if (GetMP()) {
2233        TIntPrV Partitions;
2234        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2235        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2236        int RemoveCount = 0;
2237        TIntPrV Bounds(Partitions.Len());
2238        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:RemoveCount)
2239        for (int i = 0; i < Partitions.Len(); i++){
2240          TRowIterator RowI(Partitions[i].GetVal1(), this);
2241          TRowIterator EndI(Partitions[i].GetVal2(), this);
2242          TInt FirstRowIdx = TTable::Invalid;
2243          TInt LastRowIdx = TTable::Invalid;
2244          TBool First = true;
2245          while (RowI < EndI) {
2246            TInt CurrRowIdx = RowI.GetRowIdx();
2247            TBool Result;
2248            if (Type != atStr) {
2249              Result = RowI.CompareAtomicConst(ColIdx, Val, Cmp);
2250            } else {
2251              Result = RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp);
2252            }
2253            RowI++;
2254            if(!Result) {
2255              Next[CurrRowIdx] = TTable::Invalid;
2256              RemoveCount++;
2257            } else { 
2258              if (First) { FirstRowIdx = CurrRowIdx; First = false; } 
2259              else { Next[LastRowIdx] = CurrRowIdx; }
2260              LastRowIdx = CurrRowIdx; 
2261            }
2262          }
2263          Bounds[i] = TIntPr(FirstRowIdx, LastRowIdx);
2264        }
2265        TInt CurrBound = 0;
2266        while (CurrBound < Bounds.Len() && Bounds[CurrBound].Val1 == TTable::Invalid) {
2267          CurrBound++;
2268        }
2269        if (CurrBound == Bounds.Len()) {
2270          Assert(NumValidRows == RemoveCount);
2271          NumValidRows = 0;
2272          FirstValidRow = TTable::Invalid;
2273          LastValidRow = TTable::Invalid;
2274        } else {
2275          NumValidRows -= RemoveCount;
2276          FirstValidRow = Bounds[CurrBound].Val1;
2277          LastValidRow = Bounds[CurrBound].Val2;
2278          TInt PrevBound = CurrBound;
2279          CurrBound++;
2280          while (CurrBound < Bounds.Len()) {
2281            if (Bounds[CurrBound].Val1 == TTable::Invalid) { CurrBound++; continue; }
2282            Next[Bounds[PrevBound].Val2] = Bounds[CurrBound].Val1;
2283            LastValidRow = Bounds[CurrBound].Val2;
2284            PrevBound = CurrBound;
2285            CurrBound++;
2286          }
2287          Next[Bounds[PrevBound].Val2] = TTable::Last;
2288        }
2289        IsNextDirty = 1;
2290      } else {
2291  #endif
2292        TRowIteratorWithRemove RowI = BegRIWR();
2293        while(RowI.GetNextRowIdx() != Last){
2294          if (!RowI.CompareAtomicConst(ColIdx, Val, Cmp)) {
2295            RowI.RemoveNext();
2296          } else {
2297            RowI++;
2298          }
2299        }
2300        IsNextDirty = 1;
2301  #ifdef USE_OPENMP
2302      }
2303  #endif
2304    } else if (Table) {
2305  #ifdef USE_OPENMP
2306      if (GetMP()) {
2307        TIntPrV Partitions;
2308        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2309        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2310        int TotalSelectedRows = 0;
2311        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:TotalSelectedRows)
2312        for (int i = 0; i < Partitions.Len(); i++){
2313          TRowIterator RowI(Partitions[i].GetVal1(), this);
2314          TRowIterator EndI(Partitions[i].GetVal2(), this);
2315          while (RowI < EndI) {
2316            if (Type != atStr) {
2317              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2318                TotalSelectedRows++;
2319              }
2320            } else {
2321              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2322                TotalSelectedRows++;
2323              }
2324            }
2325            RowI++;
2326          }
2327        }
2328        SelectedTable->ResizeTable(TotalSelectedRows);
2329        if (TotalSelectedRows == 0) {
2330          return;
2331        }
2332        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
2333        for (int i = 0; i < Partitions.Len(); i++){
2334          TIntV LocalSelectedRows;
2335          LocalSelectedRows.Reserve(PartitionSize);
2336          TRowIterator RowI(Partitions[i].GetVal1(), this);
2337          TRowIterator EndI(Partitions[i].GetVal2(), this);
2338          while (RowI < EndI) {
2339            if (Type != atStr) {
2340              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2341                LocalSelectedRows.Add(RowI.GetRowIdx());
2342              }
2343            } else {
2344              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2345                LocalSelectedRows.Add(RowI.GetRowIdx());
2346              }
2347            }
2348            RowI++;
2349          }
2350          SelectedTable->AddSelectedRows(*this, LocalSelectedRows);
2351        }
2352        SelectedTable->SetFirstValidRow();
2353      } else {
2354  #endif
2355        for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2356          if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2357            SelectedTable->AddRowI(RowI);
2358          }
2359        }
2360  #ifdef USE_OPENMP
2361      }
2362  #endif
2363    } else {
2364      for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2365        if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2366          SelectedRows.Add(RowI.GetRowIdx());
2367        }
2368      }
2369    }
2370  }
2371  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TAttrType& CompareByType, const TInt& CompareByIndex, TBool Asc) {
2372    switch (CompareByType) {
2373      case atInt:{
2374        if (IntCols[CompareByIndex][R1] > IntCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2375        if (IntCols[CompareByIndex][R1] < IntCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2376        return 0;
2377      }
2378      case atFlt:{
2379        if (FltCols[CompareByIndex][R1] > FltCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2380        if (FltCols[CompareByIndex][R1] < FltCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2381        return 0;
2382      }
2383      case atStr:{
2384        TStr S1 = GetStrValIdx(CompareByIndex, R1);
2385        TStr S2 = GetStrValIdx(CompareByIndex, R2);
2386        int CmpRes = strcmp(S1.CStr(), S2.CStr());
2387        return (Asc ? CmpRes : -CmpRes);
2388      }
2389    }
2390    return 0;
2391  }
2392  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TVec<TAttrType>& CompareByTypes, const TIntV& CompareByIndices, TBool Asc) {
2393    for (TInt i = 0; i < CompareByTypes.Len(); i++) {
2394      TInt res = CompareRows(R1, R2, CompareByTypes[i], CompareByIndices[i], Asc);
2395      if (res != 0) { return res; }
2396    }
2397    return 0;
2398  }
2399  void TTable::ISort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2400    if (StartIdx < EndIdx) {
2401      for (TInt i = StartIdx+1; i <= EndIdx; i++) {
2402        TInt Val = V[i];
2403        TInt j = i;
2404        while ((StartIdx < j) && (CompareRows(V[j-1], Val, SortByTypes, SortByIndices, Asc) > 0)) {
2405          V[j] = V[j-1];
2406          j--;
2407        }
2408        V[j] = Val;
2409      }
2410    }
2411  }
2412  TInt TTable::GetPivot(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2413    TInt L = EndIdx - StartIdx + 1;
2414    const TInt Idx1 = StartIdx + TInt::GetRnd(L);
2415    const TInt Idx2 = StartIdx + TInt::GetRnd(L);
2416    const TInt Idx3 = StartIdx + TInt::GetRnd(L);
2417    if (CompareRows(V[Idx1], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) {
2418      if (CompareRows(V[Idx2], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2419      if (CompareRows(V[Idx1], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2420      return Idx1;
2421    } else {
2422      if (CompareRows(V[Idx3], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2423      if (CompareRows(V[Idx3], V[Idx1], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2424      return Idx1;
2425    }
2426  }
2427  TInt TTable::Partition(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2428    TInt j;
2429    for (j = StartIdx; j < EndIdx; j++) {
2430      if (CompareRows(V[j], V[j+1], SortByTypes, SortByIndices, Asc) > 0) {
2431        break;
2432      }
2433    }
2434    if (j >= EndIdx) {
2435      return EndIdx+1;
2436    }
2437    TInt PivotIdx = GetPivot(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2438    TInt Pivot = V[PivotIdx];
2439    V.Swap(PivotIdx, EndIdx);
2440    TInt StoreIdx = StartIdx;
2441    for (TInt i = StartIdx; i < EndIdx; i++) {
2442      if (CompareRows(V[i], Pivot, SortByTypes, SortByIndices, Asc) <= 0) {
2443        V.Swap(i, StoreIdx);
2444        StoreIdx++;
2445      }
2446    }
2447    V.Swap(StoreIdx, EndIdx);
2448    return StoreIdx;
2449  }
2450  void TTable::QSort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2451    if (StartIdx < EndIdx) {
2452      if (EndIdx - StartIdx < 20) {
2453        ISort(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2454      } else {
2455        TInt Pivot = Partition(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2456        if (Pivot > EndIdx) {
2457          return;
2458        }
2459        int Ub = Pivot - 1;
2460        while (Ub >= StartIdx && CompareRows(
2461          V[Ub], V[Pivot], SortByTypes, SortByIndices, Asc) == 0) {
2462          Ub -= 1;
2463        }
2464        QSort(V, StartIdx, Ub, SortByTypes, SortByIndices, Asc);
2465        QSort(V, Pivot+1, EndIdx, SortByTypes, SortByIndices, Asc);
2466      }
2467    }
2468  }
2469  void TTable::Merge(TIntV& V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2470    TInt i = Idx1, j = Idx2;
2471    TIntV SortedV;
2472    while  (i < Idx2 && j < Idx3) {
2473      if (CompareRows(V[i], V[j], SortByTypes, SortByIndices, Asc) <= 0) {
2474        SortedV.Add(V[i]);
2475        i++;
2476      }
2477      else {
2478        SortedV.Add(V[j]);
2479        j++;
2480      }
2481    }
2482    while (i < Idx2) {
2483      SortedV.Add(V[i]);
2484      i++;
2485    }
2486    while (j < Idx3) {
2487      SortedV.Add(V[j]);
2488      j++;
2489    }
2490    for (TInt sz = 0; sz < Idx3 - Idx1; sz++) {
2491      V[Idx1 + sz] = SortedV[sz];
2492    }
2493  }
2494  #ifdef USE_OPENMP
2495  void TTable::QSortPar(TIntV& V, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2496    TInt NumThreads = 8; 
2497    TInt Sz = V.Len();
2498    TIntV IndV, NextV;
2499    for (TInt i = 0; i < NumThreads; i++) {
2500      IndV.Add(i * (Sz / NumThreads));
2501    }
2502    IndV.Add(Sz);
2503    omp_set_num_threads(NumThreads);
2504    #pragma omp parallel for
2505    for (int i = 0; i < NumThreads; i++) {
2506      QSort(V, IndV[i], IndV[i+1] - 1, SortByTypes, SortByIndices, Asc);
2507    }
2508    while (NumThreads > 1) {
2509      omp_set_num_threads(NumThreads / 2);
2510      #pragma omp parallel for
2511      for (int i = 0; i < NumThreads; i += 2) {
2512        Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc);
2513      }
2514      NextV.Clr();
2515      for (TInt i = 0; i < NumThreads; i+=2) {
2516        NextV.Add(IndV[i]);
2517      }
2518      NextV.Add(Sz);
2519      IndV = NextV;
2520      NumThreads = NumThreads / 2;
2521    }
2522  }
2523  #endif 
2524  void TTable::Order(const TStrV& OrderBy, TStr OrderColName, TBool ResetRankByMSC, TBool Asc) {
2525    TIntV ValidRows = TIntV(NumValidRows);
2526    if (NumRows == NumValidRows) {
2527      for (TInt i = 0; i < NumValidRows; i++) {
2528        ValidRows[i] = i;
2529      }
2530    } else {
2531      TInt i = 0;
2532      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
2533        ValidRows[i] = RI.GetRowIdx();
2534        i++;
2535      }
2536    }
2537    TVec<TAttrType> OrderByTypes(OrderBy.Len());
2538    TIntV OrderByIndices(OrderBy.Len());
2539    for (TInt i = 0; i < OrderBy.Len(); i++) {
2540      OrderByTypes[i] = GetColType(OrderBy[i]);
2541      OrderByIndices[i] = GetColIdx(OrderBy[i]);
2542    }
2543  #ifdef USE_OPENMP
2544    if (GetMP()) {
2545      QSortPar(ValidRows, OrderByTypes, OrderByIndices, Asc);
2546    } else {
2547  #endif
2548      QSort(ValidRows, 0, NumValidRows-1, OrderByTypes, OrderByIndices, Asc);
2549  #ifdef USE_OPENMP
2550    }
2551  #endif
2552    IsNextDirty = 1;
2553    if (NumValidRows > 0) {
2554      FirstValidRow = ValidRows[0];
2555    } else {
2556      FirstValidRow = Last;
2557    }
2558    for (TInt i = 0; i < NumValidRows-1; i++) {
2559      Next[ValidRows[i]] = ValidRows[i+1];
2560    }
2561    if (NumValidRows > 0) {
2562      Next[ValidRows[NumValidRows-1]] = Last;
2563      LastValidRow = ValidRows[NumValidRows-1];
2564    } else {
2565      LastValidRow = Last;
2566    }
2567    if (!OrderColName.Empty()) {
2568      TIntV RankCol = TIntV(NumRows);
2569      for (TInt i = 0; i < NumValidRows; i++) {
2570        RankCol[ValidRows[i]] = i;
2571      }
2572      if (ResetRankByMSC) {
2573        for (TInt i = 1; i < NumValidRows; i++) {
2574          TStr GroupName = OrderBy[0];
2575          if (GetStrVal(GroupName, ValidRows[i]) != GetStrVal(GroupName, ValidRows[i-1])) { 
2576            RankCol[ValidRows[i]] = 0;
2577          } else {
2578            RankCol[ValidRows[i]] = RankCol[ValidRows[i-1]] + 1;
2579          }
2580        }
2581      }
2582      IntCols.Add(RankCol);
2583      AddSchemaCol(OrderColName, atInt);
2584      AddColType(OrderColName, atInt, IntCols.Len()-1);
2585    }
2586  }
2587  void TTable::Defrag() {
2588    TInt FreeIndex = 0;
2589    TIntV Mapping;  
2590    TInt IdColIdx = GetColIdx(IdColName);
2591    for (TInt i = 0; i < Next.Len(); i++) {
2592      if (Next[i] != TTable::Invalid) {  
2593        if (FreeIndex == 0) {
2594          Assert (i == FirstValidRow);
2595          FirstValidRow = 0;
2596        }
2597        if (Next[i] != Last) { 
2598          Next[FreeIndex] = FreeIndex + 1;
2599          Mapping.Add(FreeIndex);
2600        } else {
2601          Next[FreeIndex] = Last;
2602          LastValidRow = FreeIndex;
2603          Mapping.Add(Last);
2604        }
2605        RowIdMap.AddDat(IntCols[IdColIdx][i], FreeIndex);
2606        for (TInt j = 0; j < IntCols.Len(); j++) {
2607          IntCols[j][FreeIndex] = IntCols[j][i];
2608        }
2609        for (TInt j = 0; j < FltCols.Len(); j++) {
2610          FltCols[j][FreeIndex] = FltCols[j][i];
2611        }
2612        for (TInt j = 0; j < StrColMaps.Len(); j++) {
2613          StrColMaps[j][FreeIndex] = StrColMaps[j][i];
2614        }
2615        FreeIndex++;
2616      } else {
2617        NumRows--;
2618        Mapping.Add(TTable::Invalid);
2619      }
2620    }
2621    Assert (NumValidRows == NumRows);
2622  }
2623  void TTable::SelectFirstNRows(const TInt& N) {
2624    if (N == 0) {
2625      LastValidRow = -1;
2626      return;
2627    }
2628    TRowIterator RowI = BegRI();
2629    TInt count = 1;
2630    while (count < N) {
2631      if (!(RowI < EndRI())) {
2632        return; 
2633      }
2634      RowI++;
2635      count++;
2636    }
2637    NumValidRows = N;
2638    TInt LastId = RowI.GetRowIdx();
2639    if (Next[LastId] == Last) {
2640      return; 
2641    }
2642    TInt CurrId = LastId;
2643    while (Next[CurrId] != Last) {
2644      Assert(Next[CurrId] != Invalid);
2645      TInt NextId = Next[CurrId];
2646      Next[CurrId] = Invalid;
2647      CurrId = NextId;
2648    }
2649    Next[LastId] = Last;
2650    LastValidRow = LastId;
2651  }
2652  inline void TTable::CheckAndAddIntNode(PNEANet Graph, THashSet<TInt>& NodeVals, TInt NodeId) {
2653    if (!NodeVals.IsKey(NodeId)) {
2654      Graph->AddNode(NodeId);
2655      NodeVals.AddKey(NodeId);
2656    }
2657  }
2658  inline void TTable::AddEdgeAttributes(PNEANet& Graph, int RowId) {
2659    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
2660      TStr ColName = EdgeAttrV[i];
2661      TAttrType T = GetColType(ColName);
2662      TInt Index = GetColIdx(ColName);
2663      switch (T) {
2664        case atInt:
2665          Graph->AddIntAttrDatE(RowId, IntCols[Index][RowId], ColName);
2666          break;
2667        case atFlt:
2668          Graph->AddFltAttrDatE(RowId, FltCols[Index][RowId], ColName);
2669          break;
2670        case atStr:
2671          Graph->AddStrAttrDatE(RowId, GetStrValIdx(Index, RowId), ColName);
2672          break;
2673      }
2674    }
2675  }
2676  inline void TTable::AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId, THash<TInt, TStrIntVH>& NodeIntAttrs,
2677    THash<TInt, TStrFltVH>& NodeFltAttrs, THash<TInt, TStrStrVH>& NodeStrAttrs) {
2678    for (TInt i = 0; i < NodeAttrV.Len(); i++) {
2679      TStr ColAttr = NodeAttrV[i];
2680      TAttrType CT = GetColType(ColAttr);
2681      int ColId = GetColIdx(ColAttr);
2682      for (TInt i = 0; i < CommonNodeAttrs.Len(); i++) {
2683        if (CommonNodeAttrs[i].Val1 == ColAttr || CommonNodeAttrs[i].Val2 == ColAttr) {
2684          ColAttr = CommonNodeAttrs[i].Val3;
2685          break;
2686        }
2687      }
2688      if (CT == atInt) {
2689        if (!NodeIntAttrs.IsKey(NId)) { NodeIntAttrs.AddKey(NId); }
2690        if (!NodeIntAttrs.GetDat(NId).IsKey(ColAttr)) { NodeIntAttrs.GetDat(NId).AddKey(ColAttr); }
2691        NodeIntAttrs.GetDat(NId).GetDat(ColAttr).Add(IntCols[ColId][RowId]);
2692      } else if (CT == atFlt) {
2693        if (!NodeFltAttrs.IsKey(NId)) { NodeFltAttrs.AddKey(NId); }
2694        if (!NodeFltAttrs.GetDat(NId).IsKey(ColAttr)) { NodeFltAttrs.GetDat(NId).AddKey(ColAttr); }
2695        NodeFltAttrs.GetDat(NId).GetDat(ColAttr).Add(FltCols[ColId][RowId]);
2696      } else {
2697        if (!NodeStrAttrs.IsKey(NId)) { NodeStrAttrs.AddKey(NId); }
2698        if (!NodeStrAttrs.GetDat(NId).IsKey(ColAttr)) { NodeStrAttrs.GetDat(NId).AddKey(ColAttr); }
2699        NodeStrAttrs.GetDat(NId).GetDat(ColAttr).Add(GetStrValIdx(ColId, RowId));
2700      }
2701    }
2702  }
2703  PNEANet TTable::BuildGraph(const TIntV& RowIds, TAttrAggr AggrPolicy) {
2704    PNEANet Graph = TNEANet::New();
2705    const TAttrType NodeType = GetColType(SrcCol);
2706    Assert(NodeType == GetColType(DstCol));
2707    const TInt SrcColIdx = GetColIdx(SrcCol);
2708    const TInt DstColIdx = GetColIdx(DstCol);
2709    THash<TFlt, TInt> FltNodeVals;
2710    THash<TInt, TStrIntVH> NodeIntAttrs;
2711    THash<TInt, TStrFltVH> NodeFltAttrs;
2712    THash<TInt, TStrStrVH> NodeStrAttrs;
2713    for (TVec<TInt>::TIter it = RowIds.BegI(); it < RowIds.EndI(); it++) {
2714      TInt CurrRowIdx = *it;
2715      TInt SVal, DVal;
2716      if (NodeType == atFlt) {
2717        TFlt FSVal = FltCols[SrcColIdx][CurrRowIdx];
2718        SVal = CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
2719        TFlt FDVal = FltCols[SrcColIdx][CurrRowIdx];
2720        DVal = CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
2721      } else if (NodeType == atInt || NodeType == atStr) {
2722        if (NodeType == atInt) {
2723          SVal = IntCols[SrcColIdx][CurrRowIdx];
2724          DVal = IntCols[DstColIdx][CurrRowIdx];
2725        } else {
2726          SVal = StrColMaps[SrcColIdx][CurrRowIdx];
2727          if (strlen(Context->StringVals.GetKey(SVal)) == 0) { continue; }  
2728          DVal = StrColMaps[DstColIdx][CurrRowIdx];
2729          if (strlen(Context->StringVals.GetKey(DVal)) == 0) { continue; }  
2730        }
2731        if (!Graph->IsNode(SVal)) { Graph->AddNode(SVal); }
2732        if (!Graph->IsNode(DVal)) { Graph->AddNode(DVal); }
2733      } 
2734      Graph->AddEdge(SVal, DVal, CurrRowIdx);
2735      if (EdgeAttrV.Len() > 0) { AddEdgeAttributes(Graph, CurrRowIdx); }
2736      if (SrcNodeAttrV.Len() > 0) { 
2737        AddNodeAttributes(SVal, SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2738      }
2739      if (DstNodeAttrV.Len() > 0) {
2740        AddNodeAttributes(DVal, DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2741      }
2742    }
2743    if (SrcNodeAttrV.Len() > 0 || DstNodeAttrV.Len() > 0) {
2744      for (TNEANet::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
2745        TInt NId = NodeI.GetId();
2746        if (NodeIntAttrs.IsKey(NId)) {
2747          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
2748          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it < IntAttrVals.EndI(); it++) {
2749            TInt AttrVal = AggregateVector<TInt>(it.GetDat(), AggrPolicy);
2750            Graph->AddIntAttrDatN(NId, AttrVal, it.GetKey());
2751          }
2752        }
2753        if (NodeFltAttrs.IsKey(NId)) {
2754          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
2755          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it < FltAttrVals.EndI(); it++) {
2756            TFlt AttrVal = AggregateVector<TFlt>(it.GetDat(), AggrPolicy);
2757            Graph->AddFltAttrDatN(NId, AttrVal, it.GetKey());
2758          }
2759        }
2760        if (NodeStrAttrs.IsKey(NId)) {
2761          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
2762          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it < StrAttrVals.EndI(); it++) {
2763            TStr AttrVal = AggregateVector<TStr>(it.GetDat(), AggrPolicy);
2764            Graph->AddStrAttrDatN(NId, AttrVal, it.GetKey());
2765          }
2766        }
2767      }
2768    }
2769    return Graph;
2770  }
2771  void TTable::InitRowIdBuckets(int NumBuckets) {
2772    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2773      RowIdBuckets[i].Clr();
2774    }
2775    RowIdBuckets.Clr();
2776    RowIdBuckets.Gen(NumBuckets);
2777    for (TInt i = 0; i < NumBuckets; i++) {
2778      RowIdBuckets[i].Gen(10, 0);
2779    }
2780  }
2781  void TTable::FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize, TInt StartVal, TInt EndVal) {
2782    Assert (JumpSize <= WindowSize);
2783    int NumBuckets, MinBucket, MaxBucket;
2784    TInt SplitColId = GetColIdx(SplitAttr);
2785    if (StartVal == TInt::Mn || EndVal == TInt::Mx) {
2786      TInt MinValue = TInt::Mx;
2787      TInt MaxValue = TInt::Mn;
2788      for (TInt i = 0; i < Next.Len(); i++) {
2789        if (Next[i] != Invalid) { 
2790          if (MinValue > IntCols[SplitColId][i]) {
2791            MinValue = IntCols[SplitColId][i];
2792          }
2793          if (MaxValue < IntCols[SplitColId][i]) {
2794            MaxValue = IntCols[SplitColId][i];
2795          }
2796        }
2797      }
2798      if (StartVal == TInt::Mn) StartVal = MinValue;
2799      if (EndVal == TInt::Mx) EndVal = MaxValue;
2800    }
2801    NumBuckets = 1;
2802    if (JumpSize > 0) {
2803      NumBuckets = (EndVal - StartVal)/JumpSize + 1;
2804    }
2805    InitRowIdBuckets(NumBuckets);
2806    for (TInt i = 0; i < Next.Len(); i++) {
2807      if (Next[i] == Invalid) { continue; }
2808      int SplitVal = IntCols[SplitColId][i];
2809      if (SplitVal < StartVal || SplitVal > EndVal) { continue; }
2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
2817        if (RowVal < WindowSize) { MinBucket = 0; }
2818        else { MinBucket = (RowVal-WindowSize)/JumpSize + 1; }
2819        MaxBucket = RowVal/JumpSize;  
2820      }
2821      for (TInt j = MinBucket; j <= MaxBucket; j++) { RowIdBuckets[j].Add(i); }
2822    }
2823  }
2824  void TTable::FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals) {
2825    TInt SplitColId = GetColIdx(SplitAttr);
2826    int NumBuckets = SplitIntervals.Len();
2827    InitRowIdBuckets(NumBuckets);
2828    for (TInt i = 0; i < Next.Len(); i++) {
2829      if (Next[i] == Invalid) { continue; }
2830      int SplitVal = IntCols[SplitColId][i];
2831      for (TInt j = 0; j < SplitIntervals.Len(); j++) { 
2832        if (SplitVal >= SplitIntervals[j].Val1 && SplitVal < SplitIntervals[j].Val2) {
2833          RowIdBuckets[j].Add(i);
2834        }
2835      }
2836    }
2837  }
2838  TVec<PNEANet> TTable::GetGraphsFromSequence(TAttrAggr AggrPolicy) {
2839    TVec<PNEANet> GraphSequence;
2840    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2841      if (RowIdBuckets[i].Len() == 0) { continue; }
2842      PNEANet PNet = BuildGraph(RowIdBuckets[i], AggrPolicy);
2843      GraphSequence.Add(PNet);
2844    }
2845    return GraphSequence;
2846  }
2847  PNEANet TTable::GetFirstGraphFromSequence(TAttrAggr AggrPolicy) {
2848    CurrBucket = -1;
2849    this->AggrPolicy = AggrPolicy;
2850    return GetNextGraphFromSequence();
2851  }
2852  PNEANet TTable::GetNextGraphFromSequence() {
2853    CurrBucket++;
2854    while (CurrBucket < RowIdBuckets.Len() && RowIdBuckets[CurrBucket].Len() == 0) {
2855      CurrBucket++;
2856    }
2857    if (CurrBucket >= RowIdBuckets.Len()) { return NULL; }
2858    return BuildGraph(RowIdBuckets[CurrBucket], AggrPolicy);
2859  }
2860  TVec<PNEANet> TTable::ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2861    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2862    printf("buckets filled\n");
2863    return GetGraphsFromSequence(AggrPolicy);  
2864  }
2865  TVec<PNEANet> TTable::ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2866    FillBucketsByInterval(SplitAttr, SplitIntervals);
2867    return GetGraphsFromSequence(AggrPolicy);
2868  }
2869  TVec<PNEANet> TTable::ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy) {
2870    return ToGraphSequence(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2871  }
2872  PNEANet TTable::ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2873    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2874    return GetFirstGraphFromSequence(AggrPolicy);  
2875  }
2876  PNEANet TTable::ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2877    FillBucketsByInterval(SplitAttr, SplitIntervals);
2878    return GetFirstGraphFromSequence(AggrPolicy);
2879  }
2880  PNEANet TTable::ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy) {
2881    return ToGraphSequenceIterator(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2882  }
2883  PNEANet TTable::NextGraphIterator() {
2884    return GetNextGraphFromSequence();
2885  }
2886  TBool TTable::IsLastGraphOfSequence() {
2887    return CurrBucket >= RowIdBuckets.Len() - 1;
2888  }
2889  PTable TTable::GetNodeTable(const PNEANet& Network, TTableContext* Context) {
2890    Schema SR;
2891    SR.Add(TPair<TStr,TAttrType>("node_id",atInt));
2892    TStrV IntAttrNames;
2893    TStrV FltAttrNames;
2894    TStrV StrAttrNames;
2895    TNEANet::TNodeI NodeI = Network->BegNI();
2896    NodeI.GetIntAttrNames(IntAttrNames);
2897    NodeI.GetFltAttrNames(FltAttrNames);
2898    NodeI.GetStrAttrNames(StrAttrNames);
2899    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2900      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2901    }
2902    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2903      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2904    }
2905    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2906      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2907    }
2908    PTable T = New(SR, Context);
2909    TInt Cnt = 0;
2910    while (NodeI < Network->EndNI()) {
2911      T->IntCols[0].Add(NodeI.GetId());
2912      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2913        T->IntCols[i+1].Add(Network->GetIntAttrDatN(NodeI,IntAttrNames[i]));
2914      }
2915      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2916        T->FltCols[i].Add(Network->GetFltAttrDatN(NodeI,FltAttrNames[i]));
2917      }
2918      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2919        T->AddStrVal(i, Network->GetStrAttrDatN(NodeI,StrAttrNames[i]));
2920      }
2921      Cnt++;
2922      NodeI++;
2923    }
2924    T->NumRows = Cnt;
2925    T->NumValidRows = T->NumRows;
2926    T->Next = TIntV(T->NumRows,0);
2927    for (TInt i = 0; i < T->NumRows-1; i++) {
2928      T->Next.Add(i+1);
2929    }
2930    T->LastValidRow = T->NumRows-1;
2931    T->Next.Add(Last);
2932    return T;
2933  }
2934  PTable TTable::GetEdgeTable(const PNEANet& Network, TTableContext* Context) {
2935    Schema SR;
2936    SR.Add(TPair<TStr,TAttrType>("edg_id",atInt));
2937    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2938    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2939    TStrV IntAttrNames;
2940    TStrV FltAttrNames;
2941    TStrV StrAttrNames;
2942    TNEANet::TEdgeI EdgeI = Network->BegEI();
2943    EdgeI.GetIntAttrNames(IntAttrNames);
2944    EdgeI.GetFltAttrNames(FltAttrNames);
2945    EdgeI.GetStrAttrNames(StrAttrNames);
2946    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2947      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2948    }
2949    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2950      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2951    }
2952    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2953      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2954    }
2955    PTable T = New(SR, Context);
2956    TInt Cnt = 0;
2957    while (EdgeI < Network->EndEI()) {
2958      T->IntCols[0].Add(EdgeI.GetId());
2959      T->IntCols[1].Add(EdgeI.GetSrcNId());
2960      T->IntCols[2].Add(EdgeI.GetDstNId());
2961      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2962        T->IntCols[i+3].Add(Network->GetIntAttrDatE(EdgeI,IntAttrNames[i]));
2963      }
2964      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2965        T->FltCols[i].Add(Network->GetFltAttrDatE(EdgeI,FltAttrNames[i]));
2966      }
2967      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2968        T->AddStrVal(i, Network->GetStrAttrDatE(EdgeI,StrAttrNames[i]));
2969      }
2970      Cnt++;
2971      EdgeI++;
2972    }
2973    T->NumRows = Cnt;
2974    T->NumValidRows = T->NumRows;
2975    T->Next = TIntV(T->NumRows,0);
2976    for (TInt i = 0; i < T->NumRows-1; i++) {
2977      T->Next.Add(i+1);
2978    }
2979    T->LastValidRow = T->NumRows-1;
2980    T->Next.Add(Last);
2981    return T;
2982  }
2983  #ifdef GCC_ATOMIC
2984  PTable TTable::GetEdgeTablePN(const PNGraphMP& Network, TTableContext* Context){
2985    Schema SR;
2986    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2987    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2988    TNGraphMP::TEdgeI FirstEI = Network->BegEI();
2989    PTable T = New(SR, Context);
2990    TInt NumEdges = Network->GetEdges();
2991    TInt NumPartitions = omp_get_max_threads()*CHUNKS_PER_THREAD;
2992    TInt PartitionSize = NumEdges/NumPartitions;
2993    if (PartitionSize*NumPartitions < NumEdges) { NumPartitions++;}
2994    typedef TPair<TNGraphMP::TEdgeI, TNGraphMP::TEdgeI> TEIPr;
2995    TVec<TEIPr> Partitions;
2996    TIntV PartitionSizes;
2997    TNGraphMP::TEdgeI currStart = FirstEI;
2998    TInt currCount = 0;
2999    while (FirstEI < Network->EndEI()){
3000      if (currCount == PartitionSize) {
3001        Partitions.Add(TEIPr(currStart, FirstEI));
3002        currStart = FirstEI;
3003        PartitionSizes.Add(currCount);
3004        currCount = 0;
3005      }
3006      FirstEI++;
3007      currCount++;
3008    }
3009    Partitions.Add(TEIPr(currStart, FirstEI));
3010    PartitionSizes.Add(currCount);
3011    T->ResizeTable(NumEdges);
3012    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3013    for (int p = 0; p < Partitions.Len(); p++) {
3014      TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();
3015      TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();
3016      int start = T->GetEmptyRowsStart(PartitionSizes[p]);
3017      while (EdgeI < EndI) {
3018        T->IntCols[0][start] = EdgeI.GetSrcNId();
3019        T->IntCols[1][start] = EdgeI.GetDstNId();
3020        EdgeI++;
3021        if (EdgeI < EndI) { T->Next[start] = start+1;}
3022        start++;
3023      }
3024    }
3025    Assert(T->NumRows == NumEdges);
3026    return T;
3027  }
3028  #endif 
3029  PTable TTable::GetFltNodePropertyTable(const PNEANet& Network, const TIntFltH& Property, 
3030   const TStr& NodeAttrName, const TAttrType& NodeAttrType, const TStr& PropertyAttrName, 
3031   TTableContext* Context) {
3032    Schema SR;
3033    SR.Add(TPair<TStr,TAttrType>(NodeAttrName,NodeAttrType));
3034    SR.Add(TPair<TStr,TAttrType>(PropertyAttrName,atFlt));
3035    PTable T = New(SR, Context);
3036    TInt NodeColIdx = T->GetColIdx(NodeAttrName);
3037    TInt Cnt = 0;
3038    for (TNEANet::TNodeI NodeI = Network->BegNI(); NodeI < Network->EndNI(); NodeI++) {
3039      switch (NodeAttrType) {
3040        case atInt:
3041          T->IntCols[NodeColIdx].Add(Network->GetIntAttrDatN(NodeI,NodeAttrName));
3042          break;
3043        case atFlt:
3044          T->FltCols[NodeColIdx].Add(Network->GetFltAttrDatN(NodeI,NodeAttrName));
3045          break;
3046        case atStr:
3047          T->AddStrVal(TInt(0), Network->GetStrAttrDatN(NodeI,NodeAttrName));
3048          break;
3049      }
3050      T->FltCols[0].Add(Property.GetDat(NodeI.GetId()));
3051      Cnt++;
3052    }
3053    T->NumRows = Cnt;
3054    T->NumValidRows = T->NumRows;
3055    T->Next = TIntV(T->NumRows,0);
3056    for (TInt i = 0; i < T->NumRows-1; i++) {
3057      T->Next.Add(i+1);
3058    }
3059    T->LastValidRow = T->NumRows-1;
3060    T->Next.Add(Last);
3061    return T;
3062  }
3063  PTable TTable::IsNextK(const TStr& OrderCol, TInt K, const TStr& GroupBy, const TStr& RankColName) {
3064    TStrV OrderBy;
3065    if (GroupBy.Empty()) {
3066      OrderBy.Add(OrderCol);
3067    } else {
3068      OrderBy.Add(GroupBy);
3069      OrderBy.Add(OrderCol);
3070    }
3071    if (RankColName.Empty()) {
3072      Order(OrderBy);
3073    } else {
3074      Order(OrderBy, RankColName, true);
3075    }
3076    TAttrType GroupByAttrType = GetColType(GroupBy);
3077    PTable T = InitializeJointTable(*this);
3078    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3079      TInt Succ = RI.GetRowIdx();
3080      TBool OutOfGroup = false;
3081      for (TInt i = 0; i < K; i++) {
3082        Succ = Next[Succ];
3083        if (Succ == Last) { break; }
3084        switch (GroupByAttrType) {
3085          case atInt:
3086            if (GetIntVal(GroupBy, Succ) != RI.GetIntAttr(GroupBy)) { OutOfGroup = true; }
3087            break;
3088          case atFlt:
3089            if (GetFltVal(GroupBy, Succ) != RI.GetFltAttr(GroupBy)) { OutOfGroup = true; }
3090            break;
3091          case atStr:
3092            if (GetStrVal(GroupBy, Succ) != RI.GetStrAttr(GroupBy)) { OutOfGroup = true; }
3093            break;
3094        }
3095        if (OutOfGroup) { break; }  
3096        T->AddJointRow(*this, *this, RI.GetRowIdx(), Succ);
3097      }
3098    }
3099    return T;
3100  }
3101  void TTable::PrintSize(){
3102  	printf("Total number of rows: %d\n", NumRows.Val);
3103  	printf("Number of valid rows: %d\n", NumValidRows.Val);
3104  	printf("Number of Int columns: %d\n", IntCols.Len());
3105  	printf("Number of Flt columns: %d\n", FltCols.Len());
3106  	printf("Number of Str columns: %d\n", StrColMaps.Len());
3107  	TSize MemUsed = GetMemUsedKB();
3108  	printf("Approximate table size is %s KB\n", TUInt64::GetStr(MemUsed).CStr());
3109  }
3110  TSize TTable::GetMemUsedKB() {
3111    TSize ApproxSize = 0;
3112    ApproxSize += Next.GetMemUsed()/1000;  
3113    for(int i = 0; i < IntCols.Len(); i++){
3114    	ApproxSize += IntCols[i].GetMemUsed()/1000;
3115    }
3116    for(int i = 0; i < FltCols.Len(); i++){
3117    	ApproxSize += FltCols[i].GetMemUsed()/1000;
3118    }
3119    for(int i = 0; i < StrColMaps.Len(); i++){
3120    	ApproxSize += StrColMaps[i].GetMemUsed()/1000;
3121    }
3122    ApproxSize += RowIdMap.GetMemUsed()/1000;
3123    ApproxSize += GroupIDMapping.GetMemUsed()/1000;
3124    ApproxSize += GroupMapping.GetMemUsed()/1000;
3125    ApproxSize += RowIdBuckets.GetMemUsed() / 1000;
3126    return ApproxSize;
3127  }
3128  void TTable::PrintContextSize(){
3129  	printf("Number of strings in pool: ");
3130  	printf("%d\n", Context->StringVals.Len());
3131  	printf("Number of entries in hash table: ");
3132  	printf("%d\n", Context->StringVals.Reserved());
3133  	TSize MemUsed = GetContextMemUsedKB();
3134  	printf("Approximate context size is %s KB\n",
3135            TUInt64::GetStr(MemUsed).CStr());
3136  }
3137  TSize TTable::GetContextMemUsedKB(){
3138  	TSize ApproxSize = 0;
3139  	ApproxSize += Context->StringVals.GetMemUsed();
3140  	return ApproxSize;
3141  }
3142  void TTable::AddTable(const TTable& T) {
3143    for (TInt c = 0; c < Sch.Len(); c++) {
3144      TStr ColName = GetSchemaColName(c);
3145      TInt ColIdx = GetColIdx(ColName);
3146      TInt TColIdx = ColName == IdColName ? T.GetColIdx(T.IdColName) : T.GetColIdx(ColName);
3147      if (TColIdx < 0) { TExcept::Throw("when adding a table, it must contain all columns of source table!"); }
3148      switch (GetColType(ColName)) { 
3149      case atInt:
3150         IntCols[ColIdx].AddV(T.IntCols[TColIdx]);
3151         break;
3152      case atFlt:
3153         FltCols[ColIdx].AddV(T.FltCols[TColIdx]);
3154         break;
3155      case atStr:
3156         StrColMaps[ColIdx].AddV(T.StrColMaps[TColIdx]);
3157         break;
3158      }
3159    }
3160    TIntV TNext(T.Next);
3161    for (TInt i = 0; i < TNext.Len(); i++) {
3162      if (TNext[i] != Last && TNext[i] != Invalid) { TNext[i] += NumRows; }
3163    }
3164    Next.AddV(TNext);
3165    if (LastValidRow >= 0) {
3166      Next[LastValidRow] = NumRows + T.FirstValidRow;
3167    }
3168    LastValidRow = NumRows + T.LastValidRow;
3169    NumRows += T.NumRows;
3170    NumValidRows += T.NumValidRows;
3171  }
3172  void TTable::GetCollidingRows(const TTable& Table, THashSet<TInt>& Collisions) {
3173    TIntV UniqueVec;
3174    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
3175    TStrV GroupBy;
3176    TIntV IntGroupByCols;
3177    TIntV FltGroupByCols;
3178    TIntV StrGroupByCols;
3179    TInt IKLen, FKLen, SKLen;
3180    for (TInt c = 0; c < Sch.Len(); c++) {
3181      if (Sch[c].Val1 == IdColName) {
3182        if (Table.Sch[c].Val1 != Table.GetIdColName()) {
3183          TExcept::Throw("GetCollidingRows: schemas do not match!");
3184        }
3185        continue;
3186      }
3187      if (Sch[c] != Table.Sch[c]) {
3188        printf("(%s,%d) != (%s,%d)\n", Sch[c].Val1.CStr(), Sch[c].Val2, Table.Sch[c].Val1.CStr(), Table.Sch[c].Val2); 
3189        TExcept::Throw("GetCollidingRows: schemas do not match!");
3190      }
3191      GroupBy.Add(NormalizeColName(Sch[c].Val1));
3192      TPair<TAttrType, TInt> ColType = Table.GetColTypeMap(Sch[c].Val1);
3193      switch (ColType.Val1) {
3194        case atInt:
3195          IntGroupByCols.Add(ColType.Val2);
3196          break;
3197        case atFlt:
3198          FltGroupByCols.Add(ColType.Val2);
3199          break;
3200        case atStr:
3201          StrGroupByCols.Add(ColType.Val2);
3202          break;
3203      }
3204    }
3205    IKLen = IntGroupByCols.Len();
3206    FKLen = FltGroupByCols.Len();
3207    SKLen = StrGroupByCols.Len();
3208    GroupAux(GroupBy, Grouping, true, "", false, UniqueVec, true);
3209    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3210      TIntV IKey(IKLen + SKLen, 0);
3211      TFltV FKey(FKLen, 0);
3212      for (TInt c = 0; c < IKLen; c++) {
3213        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
3214      }
3215      for (TInt c = 0; c < FKLen; c++) {
3216        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
3217      }
3218      for (TInt c = 0; c < SKLen; c++) {
3219        IKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
3220      }
3221      TGroupKey GroupKey = TGroupKey(IKey, FKey);
3222      TInt RowIdx = it.GetRowIdx();
3223      if (Grouping.IsKey(GroupKey)) {
3224        Collisions.AddKey(RowIdx);
3225      }
3226    }
3227  }
3228  void TTable::StoreIntCol(const TStr& ColName, const TIntV& ColVals) {
3229    if (ColVals.Len() != NumRows) {
3230      printf("new column dimension must agree with number of rows\n");
3231      return;
3232    }
3233    AddSchemaCol(ColName, atInt);
3234    IntCols.Add(TIntV(NumRows));
3235    TInt ColIdx = IntCols.Len()-1;
3236    TInt i = 0;
3237    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3238      IntCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3239      i++;
3240    }
3241    TInt L = IntCols.Len();
3242    AddColType(ColName, atInt, L-1);
3243  }
3244  void TTable::StoreFltCol(const TStr& ColName, const TFltV& ColVals) {
3245    if (ColVals.Len() != NumRows) {
3246      printf("new column dimension must agree with number of rows\n");
3247      return;
3248    }
3249    AddSchemaCol(ColName, atFlt);
3250    FltCols.Add(TFltV(NumRows));
3251    TInt ColIdx = FltCols.Len()-1;
3252    TInt i = 0;
3253    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3254      FltCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3255      i++;
3256    }
3257    TInt L = FltCols.Len();
3258    AddColType(ColName, atFlt, L-1);
3259  }
3260  void TTable::StoreStrCol(const TStr& ColName, const TStrV& ColVals) {
3261    if (ColVals.Len() != NumRows) {
3262      printf("new column dimension must agree with number of rows\n");
3263      return;
3264    }
3265    AddSchemaCol(ColName, atStr);
3266    StrColMaps.Add(TIntV(NumRows,0));
3267    TInt ColIdx = FltCols.Len()-1;
3268    TInt i = 0;
3269    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3270      TInt Key = Context->StringVals.GetKeyId(ColVals[i]);
3271      if (Key == -1) { Context->StringVals.AddKey(ColVals[i]); }
3272      StrColMaps[ColIdx][RI.GetRowIdx()] = Key;
3273      i++;
3274    }
3275    TInt L = StrColMaps.Len();
3276    AddColType(ColName, atStr, L-1);
3277  }
3278  void TTable::UpdateTableForNewRow() {
3279    if (LastValidRow >= 0) {
3280      Next[LastValidRow] = NumRows;
3281    }
3282    Next.Add(Last);
3283    LastValidRow = NumRows;
3284    NumRows++;
3285    NumValidRows++;
3286  }
3287  #ifdef GCC_ATOMIC
3288  void TTable::SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal){
3289      if(!GetMP()){ TExcept::Throw("Not Using MP!");}
3290  	TIntPrV Partitions;
3291  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3292  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3293  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3294  	for (int i = 0; i < Partitions.Len(); i++){
3295  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3296  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3297  		while(RowI < EndI){
3298  			FltCols[UpdateColIdx][RowI.GetRowIdx()] = DefaultFltVal;
3299  			RowI++;
3300  		}
3301  	}
3302  }
3303  int sync_bool_compare_and_swap(int *lock) {
3304    return(__sync_bool_compare_and_swap(lock, 0, 1));
3305  }
3306  void TTable::UpdateFltFromTableMP(const TStr& KeyAttr, const TStr& UpdateAttr,
3307      const TTable& Table, const TStr& FKeyAttr, const TStr& ReadAttr,
3308      TFlt DefaultFltVal) {
3309  	if (!GetMP()) {
3310      TExcept::Throw("Not Using MP!");
3311    }
3312    TAttrType KeyType = GetColType(KeyAttr);
3313    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3314    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3315    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3316      TExcept::Throw("Expecting Float values");
3317    }
3318    TStr NKeyAttr = NormalizeColName(KeyAttr);
3319    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3320    TInt FKeyColIdx = GetColIdx(FKeyAttr);
3321    TInt ReadColIdx = GetColIdx(ReadAttr);
3322    SetFltColToConstMP(UpdateColIdx, DefaultFltVal);
3323  	TIntPrV Partitions;
3324  	Table.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3325  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3326  	TIntV Locks(NumRows);
3327  	Locks.PutAll(0);	
3328    switch (KeyType) {
3329      case atInt: {
3330          THashMP<TInt,TIntV> Grouping;
3331          GroupByIntColMP(NKeyAttr, Grouping, true);
3332          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3333  			  for (int i = 0; i < Partitions.Len(); i++) {
3334  				  TRowIterator RowI(Partitions[i].GetVal1(), &Table);
3335  				  TRowIterator EndI(Partitions[i].GetVal2(), &Table);
3336  				  while (RowI < EndI) {
3337              TInt K = RowI.GetIntAttr(FKeyColIdx);
3338              if (Grouping.IsKey(K)) {
3339                TIntV& UpdateRows = Grouping.GetDat(K);
3340                for (int j = 0; j < UpdateRows.Len(); j++) {
3341                  int* lock = &Locks[UpdateRows[j]].Val;
3342                  if (!sync_bool_compare_and_swap(lock)) {
3343                    continue;
3344                  }
3345    							  FltCols[UpdateColIdx][UpdateRows[j]] = RowI.GetFltAttr(ReadColIdx);
3346                } 
3347              } 
3348              RowI++;
3349            } 
3350          }	
3351        } 
3352        break;
3353      default:
3354        break;
3355    } 
3356  }
3357  #endif	
3358  void TTable::UpdateFltFromTable(const TStr& KeyAttr, const TStr& UpdateAttr, const TTable& Table, 
3359    const TStr& FKeyAttr, const TStr& ReadAttr, TFlt DefaultFltVal){
3360    if(!IsColName(KeyAttr)){ TExcept::Throw("Bad KeyAttr parameter");}
3361    if(!IsColName(UpdateAttr)){ TExcept::Throw("Bad UpdateAttr parameter");}
3362    if(!Table.IsColName(FKeyAttr)){ TExcept::Throw("Bad FKeyAttr parameter");}
3363    if(!Table.IsColName(ReadAttr)){ TExcept::Throw("Bad ReadAttr parameter");}
3364  #ifdef GCC_ATOMIC
3365    if(GetMP()){
3366      UpdateFltFromTableMP(KeyAttr, UpdateAttr,Table, FKeyAttr, ReadAttr, DefaultFltVal);
3367      return;
3368    }
3369  #endif	
3370    TAttrType KeyType = GetColType(KeyAttr);
3371    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3372    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3373    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3374      TExcept::Throw("Expecting Float values");
3375    }
3376    TStr NKeyAttr = NormalizeColName(KeyAttr);
3377    TStr NUpdateAttr = NormalizeColName(UpdateAttr);
3378    TStr NFKeyAttr = Table.NormalizeColName(FKeyAttr);
3379    TStr NReadAttr = Table.NormalizeColName(ReadAttr);
3380    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3381    for(TRowIterator iter = BegRI(); iter < EndRI(); iter++){
3382      FltCols[UpdateColIdx][iter.GetRowIdx()] = DefaultFltVal;
3383    }
3384    switch(KeyType) {
3385      case atInt: {
3386          TIntIntVH Grouping;
3387          GroupByIntCol(NKeyAttr, Grouping, TIntV(), true, true);
3388          for (TRowIterator RI = Table.BegRI(); RI < Table.EndRI(); RI++) {
3389            TInt K = RI.GetIntAttr(NFKeyAttr);
3390            if (Grouping.IsKey(K)) {
3391              TIntV& UpdateRows = Grouping.GetDat(K);
3392              for (int i = 0; i < UpdateRows.Len(); i++) {
3393                FltCols[UpdateColIdx][UpdateRows[i]] = RI.GetFltAttr(NReadAttr);
3394              } 
3395            } 
3396          } 
3397        } 
3398        break;
3399      default:
3400        break;
3401    } 
3402  }
3403  void TTable::AddRowI(const TRowIterator& RI) {
3404    for (TInt c = 0; c < Sch.Len(); c++) {
3405      TStr ColName = GetSchemaColName(c);
3406      if (ColName == IdColName) { continue; }
3407      TInt ColIdx = GetColIdx(ColName);
3408      switch (GetColType(ColName)) {
3409      case atInt:
3410         IntCols[ColIdx].Add(RI.GetIntAttr(ColName));
3411         break;
3412      case atFlt:
3413         FltCols[ColIdx].Add(RI.GetFltAttr(ColName));
3414         break;
3415      case atStr:
3416         StrColMaps[ColIdx].Add(RI.GetStrMapByName(ColName));
3417         break;
3418      }
3419    }
3420    UpdateTableForNewRow();
3421  }
3422  void TTable::AddRowV(const TIntV& IntVals, const TFltV& FltVals, const TStrV& StrVals) {
3423    for (TInt c = 0; c < IntVals.Len(); c++) {
3424      IntCols[c].Add(IntVals[c]);
3425    }
3426    for (TInt c = 0; c < FltVals.Len(); c++) {
3427      FltCols[c].Add(FltVals[c]);
3428    }
3429    for (TInt c = 0; c < StrVals.Len(); c++) {
3430      AddStrVal(c, StrVals[c]);
3431    }
3432    UpdateTableForNewRow();
3433  }
3434  void TTable::ResizeTable(int RowCount) {
3435    if (RowCount == 0) {
3436      NumValidRows = 0;
3437      FirstValidRow = TTable::Invalid;
3438      LastValidRow = TTable::Invalid;
3439    }
3440    if (Next.Len() < RowCount) {
3441      TInt FltOffset = IntCols.Len();
3442      TInt StrOffset = FltOffset + FltCols.Len();
3443      TInt TotalCols = StrOffset + StrColMaps.Len();
3444  #ifdef USE_OPENMP
3445      #pragma omp parallel for schedule(static)
3446  #endif
3447      for (int i = 0; i < TotalCols+1; i++) {
3448        if (i < FltOffset) {
3449          IntCols[i].Reserve(RowCount, RowCount); 
3450        } else if (i < StrOffset) {
3451          FltCols[i-FltOffset].Reserve(RowCount, RowCount);
3452        } else if (i < TotalCols) {
3453          StrColMaps[i-StrOffset].Reserve(RowCount, RowCount);  
3454        } else {
3455          Next.Reserve(RowCount, RowCount);    
3456        }
3457      }
3458    } else if (Next.Len() > RowCount) {
3459      TInt FltOffset = IntCols.Len();
3460      TInt StrOffset = FltOffset + FltCols.Len();
3461      TInt TotalCols = StrOffset + StrColMaps.Len();
3462  #ifdef USE_OPENMP
3463      #pragma omp parallel for schedule(static)
3464  #endif
3465      for (int i = 0; i < TotalCols+1; i++) {
3466        if (i < FltOffset) {
3467          IntCols[i].Trunc(RowCount); 
3468        } else if (i < StrOffset) {
3469          FltCols[i-FltOffset].Trunc(RowCount); 
3470        } else if (i < TotalCols) {
3471          StrColMaps[i-StrOffset].Trunc(RowCount); 
3472        } else {
3473          Next.Trunc(RowCount); 
3474        }
3475      }
3476    }
3477  }
3478  int TTable::GetEmptyRowsStart(int NewRows) {
3479    int start = -1;
3480  #ifdef USE_OPENMP
3481    #pragma omp critical
3482    {
3483  #endif
3484      start = NumRows;
3485      NumRows += NewRows;
3486      NumValidRows += NewRows;
3487      Assert(NumRows <= Next.Len());
3488      if (LastValidRow >= 0) {Next[LastValidRow] = start;}
3489      LastValidRow = start+NewRows-1;
3490      Next[LastValidRow] = Last;
3491  #ifdef USE_OPENMP
3492    }
3493  #endif
3494    Assert (start >= 0);
3495    return start;
3496  }
3497  void TTable::AddSelectedRows(const TTable& Table, const TIntV& RowIDs) {
3498    int NewRows = RowIDs.Len();
3499    if (NewRows == 0) { return; }
3500    int start = GetEmptyRowsStart(NewRows);
3501    for (TInt r = 0; r < NewRows; r++) {
3502      TInt CurrRowIdx = RowIDs[r];
3503      for (TInt i = 0; i < Table.IntCols.Len(); i++) {
3504        IntCols[i][start+r] = Table.IntCols[i][CurrRowIdx];
3505      }
3506      for (TInt i = 0; i < Table.FltCols.Len(); i++) {
3507        FltCols[i][start+r] = Table.FltCols[i][CurrRowIdx];
3508      }
3509      for (TInt i = 0; i < Table.StrColMaps.Len(); i++) {
3510        StrColMaps[i][start+r] = Table.StrColMaps[i][CurrRowIdx];
3511      }
3512    }
3513    for (TInt r = 0; r < NewRows-1; r++) {
3514      Next[start+r] = start+r+1;
3515    }
3516  }  
3517  void TTable::AddNRows(int NewRows, const TVec<TIntV>& IntColsP, const TVec<TFltV>& FltColsP, const TVec<TIntV>& StrColMapsP) {
3518    if (NewRows == 0) { return; }
3519    int start = GetEmptyRowsStart(NewRows);
3520    for (TInt r = 0; r < NewRows; r++) {
3521      for (TInt i = 0; i < IntColsP.Len(); i++) {
3522        IntCols[i][start+r] = IntColsP[i][r];
3523      }
3524      for (TInt i = 0; i < FltColsP.Len(); i++) {
3525        FltCols[i][start+r] = FltColsP[i][r];
3526      }
3527      for (TInt i = 0; i < StrColMapsP.Len(); i++) {
3528        StrColMaps[i][start+r] = StrColMapsP[i][r];
3529      }
3530    }
3531    for (TInt r = 0; r < NewRows-1; r++) {
3532      Next[start+r] = start+r+1;
3533    }
3534  }
3535  #ifdef USE_OPENMP
3536  void TTable::AddNJointRowsMP(const TTable& T1, const TTable& T2, const TVec<TIntPrV>& JointRowIDSet) {
3537    int JointTableSize = 0;
3538    TIntV StartOffsets(JointRowIDSet.Len());
3539    for (int i = 0; i < JointRowIDSet.Len(); i++) {
3540      StartOffsets[i] = JointTableSize;
3541      JointTableSize += JointRowIDSet[i].Len();
3542    }
3543    if (JointTableSize == 0) {
3544      TExcept::Throw("Joint table is empty");
3545    }
3546    ResizeTable(JointTableSize);
3547    NumRows = JointTableSize;
3548    NumValidRows = JointTableSize;
3549    Assert(NumRows <= Next.Len());
3550    TInt IntOffset = T1.IntCols.Len();
3551    TInt FltOffset = T1.FltCols.Len();
3552    TInt StrOffset = T1.StrColMaps.Len();
3553    TInt IdOffset = IntOffset + T2.IntCols.Len();
3554    RowIdMap.Clr();
3555    for (TInt IdCnt = 0; IdCnt < JointTableSize; IdCnt++) {
3556      RowIdMap.AddDat(IdCnt, IdCnt);
3557    }
3558    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3559    for (int j = 0; j < JointRowIDSet.Len(); j++) {
3560      const TIntPrV& RowIDs = JointRowIDSet[j];
3561      int start = StartOffsets[j];
3562      int NewRows = RowIDs.Len();
3563      if (NewRows == 0) {continue;}
3564      for (TInt r = 0; r < NewRows; r++){
3565        TIntPr CurrRowIdPr = RowIDs[r]; 
3566        for(TInt i = 0; i < T1.IntCols.Len(); i++){
3567          IntCols[i][start+r] = T1.IntCols[i][CurrRowIdPr.GetVal1()];
3568        }
3569        for(TInt i = 0; i < T1.FltCols.Len(); i++){
3570          FltCols[i][start+r] = T1.FltCols[i][CurrRowIdPr.GetVal1()];
3571        }
3572        for(TInt i = 0; i < T1.StrColMaps.Len(); i++){
3573          StrColMaps[i][start+r] = T1.StrColMaps[i][CurrRowIdPr.GetVal1()];
3574        }
3575        for(TInt i = 0; i < T2.IntCols.Len(); i++){
3576          IntCols[i+IntOffset][start+r] = T2.IntCols[i][CurrRowIdPr.GetVal2()];
3577        }
3578        for(TInt i = 0; i < T2.FltCols.Len(); i++){
3579          FltCols[i+FltOffset][start+r] = T2.FltCols[i][CurrRowIdPr.GetVal2()];
3580        }
3581        for(TInt i = 0; i < T2.StrColMaps.Len(); i++){
3582          StrColMaps[i+StrOffset][start+r] = T2.StrColMaps[i][CurrRowIdPr.GetVal2()];
3583        }
3584        IntCols[IdOffset][start+r] = start+r;
3585      }
3586      for(TInt r = 0; r < NewRows; r++){
3587        Next[start+r] = start+r+1;
3588      }
3589    }      
3590    LastValidRow = JointTableSize-1;
3591    Next[LastValidRow] = Last;
3592  }
3593  #endif 
3594  PTable TTable::UnionAll(const TTable& Table) {
3595    Schema NewSchema;
3596    for (TInt c = 0; c < Sch.Len(); c++) {
3597      if (Sch[c].Val1 != GetIdColName()) {
3598        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3599      }
3600    }
3601    PTable result = TTable::New(NewSchema, Context);
3602    result->AddTable(*this);
3603    result->UnionAllInPlace(Table);
3604    return result;
3605  }
3606  void TTable::UnionAllInPlace(const TTable& Table) {
3607    AddTable(Table);
3608  }
3609  PTable TTable::Union(const TTable& Table) {
3610    Schema NewSchema;
3611    THashSet<TInt> Collisions;
3612    TStrV ColNames;
3613    for (TInt c = 0; c < Sch.Len(); c++) {
3614      if (Sch[c].Val1 != GetIdColName()) {
3615        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3616        ColNames.Add(Sch[c].Val1);
3617      }
3618    }
3619    PTable result = TTable::New(NewSchema, Context);
3620    GetCollidingRows(Table, Collisions); 
3621    result->AddTable(*this);
3622    result->Unique(ColNames);
3623    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3624      if (!Collisions.IsKey(it.GetRowIdx())) {
3625        result->AddRowI(it);
3626      }
3627    }
3628    result->InitIds();
3629    return result;
3630  }
3631  PTable TTable::Intersection(const TTable& Table) {
3632    Schema NewSchema;
3633    THashSet<TInt> Collisions;
3634    for (TInt c = 0; c < Sch.Len(); c++) {
3635      if (Sch[c].Val1 != GetIdColName()) {
3636        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3637      }
3638    }
3639    PTable result = TTable::New(NewSchema, Context);
3640    GetCollidingRows(Table, Collisions);
3641    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3642      if (Collisions.IsKey(it.GetRowIdx())) {
3643        result->AddRowI(it);
3644      }
3645    }
3646    result->InitIds();
3647    return result;
3648  }
3649  PTable TTable::Minus(TTable& Table) {
3650    Schema NewSchema;
3651    THashSet<TInt> Collisions;
3652    for (TInt c = 0; c < Sch.Len(); c++) {
3653      if (Sch[c].Val1 != GetIdColName()) {
3654        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3655      }
3656    }
3657    PTable result = TTable::New(NewSchema, Context);
3658    Table.GetCollidingRows(*this, Collisions);
3659    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
3660      if (!Collisions.IsKey(it.GetRowIdx())) {
3661        result->AddRowI(it);
3662      }
3663    }
3664    result->InitIds();
3665    return result;
3666  }
3667  PTable TTable::Project(const TStrV& ProjectCols) {
3668    Schema NewSchema;
3669    for (TInt c = 0; c < ProjectCols.Len(); c++) {
3670      if (!IsColName(ProjectCols[c])) { TExcept::Throw("no such column " + ProjectCols[c]); }
3671      NewSchema.Add(TPair<TStr,TAttrType>(ProjectCols[c], GetColType(ProjectCols[c])));
3672    }
3673    PTable result = TTable::New(NewSchema, Context);
3674    result->AddTable(*this);
3675    result->InitIds();
3676    return result;
3677  }
3678  TBool TTable::IsAttr(const TStr& Attr) {
3679    return IsColName(Attr);
3680  }
3681  TStr TTable::RenumberColName(const TStr& ColName) const {
3682    TStr NColName = ColName;
3683    if (NColName.GetCh(NColName.Len()-2) == '-') { 
3684      NColName = NColName.GetSubStr(0,NColName.Len()-3); 
3685    }
3686    TInt Conflicts = 0;
3687    for (TInt i = 0; i < Sch.Len(); i++) {
3688      if (NColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3689        Conflicts++;
3690      }
3691    }
3692    Conflicts++;
3693    NColName = NColName + "-" + Conflicts.GetStr();
3694    return NColName;
3695  }
3696  TStr TTable::DenormalizeColName(const TStr& ColName) const {
3697    TStr DColName = ColName;
3698    if (DColName.Len() == 0) { return DColName; }
3699    if (DColName.GetCh(0) == '_') { return DColName; }
3700    if (DColName.GetCh(DColName.Len()-2) == '-') { 
3701      DColName = DColName.GetSubStr(0,DColName.Len()-3); 
3702    }
3703    TInt Conflicts = 0;
3704    for (TInt i = 0; i < Sch.Len(); i++) {
3705      if (DColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3706        Conflicts++;
3707      }
3708    }
3709    if (Conflicts > 1) { return ColName; } 
3710    else { return DColName; }
3711  }
3712  Schema TTable::DenormalizeSchema() const {
3713    Schema DSch;
3714    for (TInt i = 0; i < Sch.Len(); i++) {
3715      DSch.Add(TPair<TStr, TAttrType>(DenormalizeColName(Sch[i].Val1), Sch[i].Val2));
3716    }
3717    return DSch;
3718  }
3719  void TTable::AddIntCol(const TStr& ColName) {
3720    AddSchemaCol(ColName, atInt);
3721    IntCols.Add(TIntV(NumRows));
3722    TInt L = IntCols.Len();
3723    AddColType(ColName, atInt, L-1);
3724  }
3725  void TTable::AddFltCol(const TStr& ColName) {
3726    AddSchemaCol(ColName, atFlt);
3727    FltCols.Add(TFltV(NumRows));
3728    TInt L = FltCols.Len();
3729    AddColType(ColName, atFlt, L-1);
3730  }
3731  void TTable::AddStrCol(const TStr& ColName) {
3732    AddSchemaCol(ColName, atStr);
3733    StrColMaps.Add(TIntV(NumRows));
3734    TInt L = StrColMaps.Len();
3735    AddColType(ColName, atStr, L-1);
3736  }
3737  void TTable::ClassifyAux(const TIntV& SelectedRows, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
3738    AddSchemaCol(LabelName, atInt);
3739    TInt LabelColIdx = IntCols.Len();
3740    AddColType(LabelName, atInt, LabelColIdx);
3741    IntCols.Add(TIntV(NumRows));
3742    for (TInt i = 0; i < NumRows; i++) {
3743      IntCols[LabelColIdx][i] = NegativeLabel;
3744    }
3745    for (TInt i = 0; i < SelectedRows.Len(); i++) {
3746      IntCols[LabelColIdx][SelectedRows[i]] = PositiveLabel;
3747    }
3748  }
3749  #ifdef USE_OPENMP
3750  void TTable::ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op){
3751  	TAttrType ResType = atFlt;
3752  	if(ArgType1 == atInt && ArgType2 == atInt){ ResType = atInt;}
3753  	TIntPrV Partitions;
3754  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3755  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3756  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3757  	for (int i = 0; i < Partitions.Len(); i++){
3758  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3759  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3760  		while(RowI < EndI){
3761  			if(ResType == atInt){
3762  				TInt V1 = RowI.GetIntAttr(ArgColIdx1);
3763  				TInt V2 = RowI.GetIntAttr(ArgColIdx2);
3764  				if (op == aoAdd) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3765        			if (op == aoSub) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3766        			if (op == aoMul) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3767        			if (op == aoDiv) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3768        			if (op == aoMod) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 % V2; }
3769        			if (op == aoMin) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3770        			if (op == aoMax) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3771  			} else{
3772  			    TFlt V1 = (ArgType1 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx1) : RowI.GetFltAttr(ArgColIdx1);
3773  			    TFlt V2 = (ArgType2 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx2) : RowI.GetFltAttr(ArgColIdx2);
3774  				if (op == aoAdd) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3775        			if (op == aoSub) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3776        			if (op == aoMul) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3777        			if (op == aoDiv) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3778        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3779        			if (op == aoMin) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3780        			if (op == aoMax) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3781  			}
3782  			RowI++;
3783  		}
3784  	}
3785  }
3786  #endif	
3787  void TTable::ColGenericOp(const TStr& Attr1, const TStr& Attr2, const TStr& ResAttr, TArithOp op) {
3788    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
3789    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
3790    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3791    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
3792    TAttrType Arg1Type = Info1.Val1;
3793    TAttrType Arg2Type = Info2.Val1;
3794    if (Arg1Type == atStr || Arg2Type == atStr) {
3795      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3796    }
3797    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3798    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3799    }
3800    TInt ColIdx1 = Info1.Val2;
3801    TInt ColIdx2 = Info2.Val2;
3802    TInt ColIdx3 = ColIdx1;
3803    if (ResAttr != "") {
3804        if (Arg1Type == atInt && Arg2Type == atInt) {
3805            AddIntCol(ResAttr);
3806        }
3807        else {
3808            AddFltCol(ResAttr);
3809        }
3810        ColIdx3 = GetColIdx(ResAttr);
3811    }
3812  #ifdef USE_OPENMP
3813    if(GetMP()){
3814    	ColGenericOpMP(ColIdx1, ColIdx2, Arg1Type, Arg2Type, ColIdx3, op);
3815    	return;
3816    }
3817  #endif	
3818    TAttrType ResType = atFlt;
3819    if(Arg1Type == atInt && Arg2Type == atInt){ printf("hooray!\n"); ResType = atInt;}
3820    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3821  		if(ResType == atInt){
3822  			TInt V1 = RowI.GetIntAttr(ColIdx1);
3823  			TInt V2 = RowI.GetIntAttr(ColIdx2);
3824  			if (op == aoAdd) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3825        		if (op == aoSub) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3826        		if (op == aoMul) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3827        		if (op == aoDiv) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3828        		if (op == aoMod) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 % V2; }
3829        		if (op == aoMin) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3830        		if (op == aoMax) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3831  		} else{
3832  			TFlt V1 = (Arg1Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx1) : RowI.GetFltAttr(ColIdx1);
3833  			TFlt V2 = (Arg2Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx2) : RowI.GetFltAttr(ColIdx2);
3834  			if (op == aoAdd) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3835        		if (op == aoSub) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3836        		if (op == aoMul) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3837        		if (op == aoDiv) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3838        		if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3839        		if (op == aoMin) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3840        		if (op == aoMax) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3841  		}
3842    }
3843  }
3844  void TTable::ColAdd(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3845    ColGenericOp(Attr1, Attr2, ResultAttrName, aoAdd);
3846  }
3847  void TTable::ColSub(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3848    ColGenericOp(Attr1, Attr2, ResultAttrName, aoSub);
3849  }
3850  void TTable::ColMul(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3851    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMul);
3852  }
3853  void TTable::ColDiv(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3854    ColGenericOp(Attr1, Attr2, ResultAttrName, aoDiv);
3855  }
3856  void TTable::ColMod(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3857    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMod);
3858  }
3859  void TTable::ColMin(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3860    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMin);
3861  }
3862  void TTable::ColMax(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3863    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMax);
3864  }
3865  void TTable::ColGenericOp(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr,
3866   TArithOp op, TBool AddToFirstTable) {
3867    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3868    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
3869    if (NumValidRows != Table.NumValidRows) {
3870      TExcept::Throw("Tables do not have equal number of rows");
3871    }
3872    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3873    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
3874    TAttrType Arg1Type = Info1.Val1;
3875    TAttrType Arg2Type = Info2.Val1;
3876    if (Info1.Val1 == atStr || Info2.Val1 == atStr) {
3877      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3878    }
3879    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3880    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3881    }
3882    TInt ColIdx1 = Info1.Val2;
3883    TInt ColIdx2 = Info2.Val2;
3884    TInt ColIdx3 = AddToFirstTable ? ColIdx1 : ColIdx2;
3885    if (ResAttr != "") {
3886      if (AddToFirstTable) {
3887        if (Arg1Type == atInt && Arg2Type == atInt) {
3888            AddIntCol(ResAttr);
3889        } else {
3890            AddFltCol(ResAttr);
3891        }
3892        ColIdx3 = GetColIdx(ResAttr);
3893      }
3894      else {
3895        if (Arg1Type == atInt && Arg2Type == atInt) {
3896            Table.AddIntCol(ResAttr);
3897        } else {
3898            Table.AddFltCol(ResAttr);
3899        }
3900        ColIdx3 = Table.GetColIdx(ResAttr);
3901      }
3902    }
3903    TRowIterator RI1, RI2;
3904    RI1 = BegRI();
3905    RI2 = Table.BegRI();
3906    TAttrType ResType = atFlt;
3907    if(Arg1Type == atInt && Arg2Type == atInt){ ResType = atInt;}
3908    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
3909      if (ResType == atInt) {
3910  		TInt V1 = RI1.GetIntAttr(ColIdx1);
3911  		TInt V2 = RI2.GetIntAttr(ColIdx2);
3912          if (AddToFirstTable) {
3913          	if (op == aoAdd) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3914          	if (op == aoSub) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3915          	if (op == aoMul) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3916          	if (op == aoDiv) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3917         		if (op == aoMod) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 % V2; }
3918        	}
3919        	else {
3920          	if (op == aoAdd) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3921          	if (op == aoSub) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3922          	if (op == aoMul) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3923          	if (op == aoDiv) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3924          	if (op == aoMod) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 % V2; }
3925        	}
3926      } else {
3927  	  	TFlt V1 = (Arg1Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx1) : RI2.GetFltAttr(ColIdx1);
3928  		TFlt V2 = (Arg2Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx2) : RI2.GetFltAttr(ColIdx2);
3929        	if (AddToFirstTable) {
3930          	if (op == aoAdd) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3931          	if (op == aoSub) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3932          	if (op == aoMul) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3933         	 	if (op == aoDiv) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3934          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3935        	} else {
3936          	if (op == aoAdd) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3937          	if (op == aoSub) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3938          	if (op == aoMul) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3939          	if (op == aoDiv) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3940          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3941        	}
3942      }
3943      RI1++;
3944      RI2++;
3945    }
3946    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
3947      TExcept::Throw("ColGenericOp: Iteration error");
3948    }
3949  }
3950  void TTable::ColAdd(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3951   const TStr& ResultAttrName, TBool AddToFirstTable) {
3952    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoAdd, AddToFirstTable);
3953  }
3954  void TTable::ColSub(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3955   const TStr& ResultAttrName, TBool AddToFirstTable) {
3956    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoSub, AddToFirstTable);
3957  }
3958  void TTable::ColMul(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3959   const TStr& ResultAttrName, TBool AddToFirstTable) {
3960    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMul, AddToFirstTable);
3961  }
3962  void TTable::ColDiv(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3963   const TStr& ResultAttrName, TBool AddToFirstTable) {
3964    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoDiv, AddToFirstTable);
3965  }
3966  void TTable::ColMod(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3967   const TStr& ResultAttrName, TBool AddToFirstTable) {
3968    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMod, AddToFirstTable);
3969  }
3970  void TTable::ColGenericOp(const TStr& Attr1, const TFlt& Num, const TStr& ResAttr, TArithOp op, const TBool floatCast) {
3971    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3972    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3973    TAttrType ArgType = Info1.Val1;
3974    if (ArgType == atStr) {
3975      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3976    }
3977    TInt ColIdx1 = Info1.Val2;
3978    TInt ColIdx2 = ColIdx1;
3979    TBool shouldCast = floatCast;
3980    if (ResAttr != "") {
3981        if ((ArgType == atInt) & !shouldCast) {
3982            AddIntCol(ResAttr);
3983        } else {
3984            AddFltCol(ResAttr);
3985        }
3986        ColIdx2 = GetColIdx(ResAttr);
3987    } else {
3988      shouldCast = false;
3989    }
3990    #ifdef USE_OPENMP
3991    if(GetMP()){
3992    	ColGenericOpMP(ColIdx1, ColIdx2, ArgType, Num, op, shouldCast);
3993    	return;
3994    }
3995    #endif  
3996    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3997      if ((ArgType == atInt) && !shouldCast) {
3998        TInt CurVal = RowI.GetIntAttr(ColIdx1);
3999        TInt Val = static_cast<int>(Num);
4000        if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4001        if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4002        if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4003        if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4004        if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4005      }
4006      else {
4007        TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4008        if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4009        if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4010        if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4011        if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4012        if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4013      }
4014    }
4015  }
4016  #ifdef USE_OPENMP
4017  void TTable::ColGenericOpMP(const TInt& ColIdx1, const TInt& ColIdx2, TAttrType ArgType, const TFlt& Num, TArithOp op, TBool ShouldCast){
4018  	TIntPrV Partitions;
4019  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
4020  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
4021  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
4022  	for (int i = 0; i < Partitions.Len(); i++){
4023  		TRowIterator RowI(Partitions[i].GetVal1(), this);
4024  		TRowIterator EndI(Partitions[i].GetVal2(), this);
4025  		while(RowI < EndI){
4026  			if ((ArgType == atInt) && !ShouldCast) {
4027        			TInt CurVal = RowI.GetIntAttr(ColIdx1);
4028        			TInt Val = static_cast<int>(Num);
4029        			if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4030        			if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4031        			if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4032        			if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4033        			if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4034      		} else {
4035       			TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4036        			if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4037        			if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4038        			if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4039        			if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4040        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4041      		}
4042      		RowI++;
4043  		}
4044  	}
4045  }
4046  #endif
4047  void TTable::ColAdd(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4048    ColGenericOp(Attr1, Num, ResultAttrName, aoAdd, floatCast);
4049  }
4050  void TTable::ColSub(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4051    ColGenericOp(Attr1, Num, ResultAttrName, aoSub, floatCast);
4052  }
4053  void TTable::ColMul(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4054    ColGenericOp(Attr1, Num, ResultAttrName, aoMul, floatCast);
4055  }
4056  void TTable::ColDiv(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4057    ColGenericOp(Attr1, Num, ResultAttrName, aoDiv, floatCast);
4058  }
4059  void TTable::ColMod(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4060    ColGenericOp(Attr1, Num, ResultAttrName, aoMod, floatCast);
4061  }
4062  void TTable::ColConcat(const TStr& Attr1, const TStr& Attr2, const TStr& Sep, const TStr& ResAttr) {
4063    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
4064    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
4065    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4066    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
4067    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4068      TExcept::Throw("Only string columns supported in concat.");
4069    }
4070    TInt ColIdx1 = Info1.Val2;
4071    TInt ColIdx2 = Info2.Val2;
4072    TInt ColIdx3 = ColIdx1;
4073    if (ResAttr != "") {
4074        AddStrCol(ResAttr);
4075        ColIdx3 = GetColIdx(ResAttr);
4076    }
4077    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4078      TStr CurVal1 = RowI.GetStrAttr(ColIdx1);
4079      TStr CurVal2 = RowI.GetStrAttr(ColIdx2);
4080      TStr NewVal = CurVal1 + Sep + CurVal2;
4081      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4082      StrColMaps[ColIdx3][RowI.GetRowIdx()] = Key;
4083    }
4084  }
4085  void TTable::ColConcat(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& Sep, 
4086   const TStr& ResAttr, TBool AddToFirstTable) {
4087    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4088    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
4089    if (NumValidRows != Table.NumValidRows) {
4090      TExcept::Throw("Tables do not have equal number of rows");
4091    }
4092    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4093    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
4094    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4095      TExcept::Throw("Only string columns supported in concat.");
4096    }
4097    TInt ColIdx1 = Info1.Val2;
4098    TInt ColIdx2 = Info2.Val2;
4099    TInt ColIdx3 = ColIdx1;
4100    if (!AddToFirstTable) {
4101      ColIdx3 = ColIdx2;
4102    }
4103    if (ResAttr != "") {
4104      if (AddToFirstTable) {
4105        AddStrCol(ResAttr);
4106        ColIdx3 = GetColIdx(ResAttr);
4107      }
4108      else {
4109        Table.AddStrCol(ResAttr);
4110        ColIdx3 = Table.GetColIdx(ResAttr);
4111      }
4112    }
4113    TRowIterator RI1, RI2;
4114    RI1 = BegRI();
4115    RI2 = Table.BegRI();
4116    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
4117      TStr CurVal1 = RI1.GetStrAttr(ColIdx1);
4118      TStr CurVal2 = RI2.GetStrAttr(ColIdx2);
4119      TStr NewVal = CurVal1 + Sep + CurVal2;
4120      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4121      if (AddToFirstTable) {
4122        StrColMaps[ColIdx3][RI1.GetRowIdx()] = Key;
4123      }
4124      else {
4125        Table.StrColMaps[ColIdx3][RI2.GetRowIdx()] = Key;
4126      }
4127      RI1++;
4128      RI2++;
4129    }
4130    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
4131      TExcept::Throw("ColGenericOp: Iteration error");
4132    }
4133  }
4134  void TTable::ColConcatConst(const TStr& Attr1, const TStr& Val, const TStr& Sep, const TStr& ResAttr) {
4135    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4136    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4137    if (Info1.Val1 != atStr) {
4138      TExcept::Throw("Only string columns supported in concat.");
4139    }
4140    TInt ColIdx1 = Info1.Val2;
4141    TInt ColIdx2 = ColIdx1;
4142    if (ResAttr != "") {
4143      AddStrCol(ResAttr);
4144      ColIdx2 = GetColIdx(ResAttr);
4145    }
4146    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4147      TStr CurVal = RowI.GetStrAttr(ColIdx1);
4148      TStr NewVal = CurVal + Sep + Val;
4149      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4150      StrColMaps[ColIdx2][RowI.GetRowIdx()] = Key;
4151    }  
4152  }
4153  void TTable::ReadIntCol(const TStr& ColName, TIntV& Result) const{
4154    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4155    if (GetColType(ColName) != atInt) { TExcept::Throw("not an integer column " + ColName); }
4156    TInt ColId = GetColIdx(ColName);
4157    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4158      Result.Add(it.GetIntAttr(ColId));
4159    }
4160  }
4161  void TTable::ReadFltCol(const TStr& ColName, TFltV& Result) const{
4162    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4163    if (GetColType(ColName) != atFlt) { TExcept::Throw("not a floating point column " + ColName); }
4164    TInt ColId = GetColIdx(ColName);
4165    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4166      Result.Add(it.GetFltAttr(ColId));
4167    }
4168  }
4169  void TTable::ReadStrCol(const TStr& ColName, TStrV& Result) const{
4170    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4171    if (GetColType(ColName) != atStr) { TExcept::Throw("not a string column " + ColName); }
4172    TInt ColId = GetColIdx(ColName);
4173    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4174      Result.Add(it.GetStrAttr(ColId));
4175    }
4176  }
4177  void TTable::ProjectInPlace(const TStrV& ProjectCols) {
4178    TStrV NProjectCols = NormalizeColNameV(ProjectCols);
4179    for (TInt c = 0; c < NProjectCols.Len(); c++) {
4180      if (!IsColName(NProjectCols[c])) { TExcept::Throw("no such column " + NProjectCols[c]); }
4181    }
4182    THashSet<TStr> ProjectColsSet = THashSet<TStr>(NProjectCols);
4183    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4184      TStr ColName = GetSchemaColName(i);
4185      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4186      TAttrType ColType = GetSchemaColType(i);
4187      TInt ColId = GetColIdx(ColName);
4188      switch (ColType) {
4189        case atInt:
4190          IntCols.Del(ColId);
4191          break;
4192        case atFlt:
4193          FltCols.Del(ColId);
4194          break;
4195        case atStr:
4196          StrColMaps.Del(ColId);
4197          break;
4198      }
4199    }
4200    TInt IntColCnt = 0;
4201    TInt FltColCnt = 0;
4202    TInt StrColCnt = 0;
4203    ColTypeMap.Clr();
4204    for (TInt i = 0; i < Sch.Len(); i++) {
4205      TStr ColName = GetSchemaColName(i);
4206      if (!ProjectColsSet.IsKey(ColName) && ColName != IdColName) { continue; }
4207      TAttrType ColType = GetSchemaColType(i);
4208      switch (ColType) {
4209        case atInt:
4210          AddColType(ColName, atInt, IntColCnt);
4211          IntColCnt++;
4212          break;
4213        case atFlt:
4214          AddColType(ColName, atFlt, FltColCnt);
4215          FltColCnt++;
4216          break;
4217        case atStr:
4218          AddColType(ColName, atStr, StrColCnt);
4219          StrColCnt++;
4220          break;
4221      }
4222    }
4223    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4224      TStr ColName = GetSchemaColName(i);
4225      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4226      Sch.Del(i);
4227    }
4228  }
4229  TInt TTable::CompareKeyVal(const TInt& K1, const TInt& V1, const TInt& K2, const TInt& V2) {
4230    if (K1 == K2) { return V1 - V2; }
4231    else { return K1 - K2; }
4232  }
4233  TInt TTable::CheckSortedKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4234    TInt j;
4235    for (j = Start; j < End; j++) {
4236      if (CompareKeyVal(Key[j], Val[j], Key[j+1], Val[j+1]) > 0) {
4237        break;
4238      }
4239    }
4240    if (j >= End) { return 0; }
4241    else { return 1; }
4242  }
4243  void TTable::ISortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4244    if (Start < End) {
4245      for (TInt i = Start+1; i <= End; i++) {
4246        TInt K = Key[i];
4247        TInt V = Val[i];
4248        TInt j = i;
4249        while ((Start < j) && (CompareKeyVal(Key[j-1], Val[j-1], K, V) > 0)) {
4250          Key[j] = Key[j-1];
4251          Val[j] = Val[j-1];
4252          j--;
4253        }
4254        Key[j] = K;
4255        Val[j] = V;
4256      }
4257    }
4258  }
4259  TInt TTable::GetPivotKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4260    TInt L = End - Start + 1;
4261    const TInt Idx1 = Start + TInt::GetRnd(L);
4262    const TInt Idx2 = Start + TInt::GetRnd(L);
4263    const TInt Idx3 = Start + TInt::GetRnd(L);
4264    if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx2], Val[Idx2]) < 0) {
4265      if (CompareKeyVal(Key[Idx2], Val[Idx2], Key[Idx3], Val[Idx3]) < 0) { return Idx2; }
4266      if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx3], Val[Idx3]) < 0) { return Idx3; }
4267      return Idx1;
4268    } else {
4269      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx2], Val[Idx2]) < 0) { return Idx2; }
4270      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx1], Val[Idx1]) < 0) { return Idx3; }
4271      return Idx1;
4272    }
4273  }
4274  TInt TTable::PartitionKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4275    TInt Pivot = GetPivotKeyVal(Key, Val, Start, End);
4276    TInt PivotKey = Key[Pivot];
4277    TInt PivotVal = Val[Pivot];
4278    Key.Swap(Pivot, End);
4279    Val.Swap(Pivot, End);
4280    TInt StoreIdx = Start;
4281    for (TInt i = Start; i < End; i++) {
4282      if (CompareKeyVal(Key[i], Val[i], PivotKey, PivotVal) <= 0) {
4283        Key.Swap(i, StoreIdx);
4284        Val.Swap(i, StoreIdx);
4285        StoreIdx++;
4286      }
4287    }
4288    Key.Swap(StoreIdx, End);
4289    Val.Swap(StoreIdx, End);
4290    return StoreIdx;
4291  }
4292  void TTable::QSortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4293    TInt L = End-Start;
4294    if (L <= 0) { return; }
4295    if (CheckSortedKeyVal(Key, Val, Start, End) == 0) { return; }
4296    if (L <= 20) { ISortKeyVal(Key, Val, Start, End); }
4297    else {
4298      TInt Pivot = PartitionKeyVal(Key, Val, Start, End);
4299      if (Pivot > End) { return; }
4300      if (L <= 500000) {
4301        QSortKeyVal(Key, Val, Start, Pivot-1);
4302        QSortKeyVal(Key, Val, Pivot+1, End);
4303      } else {
4304  #ifdef USE_OPENMP
4305  #ifndef GLib_WIN32
4306        #pragma omp task untied shared(Key, Val)
4307  #endif
4308  #endif
4309        { QSortKeyVal(Key, Val, Start, Pivot-1); }
4310  #ifdef USE_OPENMP
4311  #ifndef GLib_WIN32
4312        #pragma omp task untied shared(Key, Val)
4313  #endif
4314  #endif
4315        { QSortKeyVal(Key, Val, Pivot+1, End); }
4316      }
4317    }
4318  }
4319  TIntV TTable::GetIntRowIdxByVal(const TStr& ColName, const TInt& Val) const {
4320    if (IntColIndexes.IsKey(ColName)) {
4321      THash<TInt, TIntV> ColIndex = IntColIndexes.GetDat(ColName);
4322      if (ColIndex.IsKey(Val)) {
4323        return ColIndex.GetDat(Val);
4324      }
4325      else {
4326        TIntV Empty;
4327        return Empty;
4328      }
4329    }
4330    TIntV ToReturn;
4331    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4332      TInt ValAtRow = RowI.GetIntAttr(ColName);
4333      if ( Val == ValAtRow) {
4334        ToReturn.Add(RowI.GetRowIdx());
4335      }
4336    }
4337    return ToReturn;
4338  }
4339  TIntV TTable::GetStrRowIdxByMap(const TStr& ColName, const TInt& Map) const {
4340    if (StrMapColIndexes.IsKey(ColName)) {
4341      THash<TInt, TIntV> ColIndex = StrMapColIndexes.GetDat(ColName);
4342      if (ColIndex.IsKey(Map)) {
4343        return ColIndex.GetDat(Map);
4344      }
4345      else {
4346        TIntV Empty;
4347        return Empty;
4348      }
4349    }
4350    TIntV ToReturn;
4351    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4352      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4353      if ( Map == MapAtRow) {
4354        ToReturn.Add(RowI.GetRowIdx());
4355      }
4356    }
4357    return ToReturn;
4358  }
4359  TIntV TTable::GetFltRowIdxByVal(const TStr& ColName, const TFlt& Val) const {
4360    if (FltColIndexes.IsKey(ColName)) {
4361      THash<TFlt, TIntV> ColIndex = FltColIndexes.GetDat(ColName);
4362      if (ColIndex.IsKey(Val)) {
4363        return ColIndex.GetDat(Val);
4364      }
4365      else {
4366        TIntV Empty;
4367        return Empty;
4368      }
4369    }
4370    TIntV ToReturn;
4371    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4372      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4373      if ( Val == ValAtRow) {
4374        ToReturn.Add(RowI.GetRowIdx());
4375      }
4376    }
4377    return ToReturn;
4378  }
4379  TInt TTable::RequestIndexInt(const TStr& ColName) {
4380    THash<TInt, TIntV> NewIndex;
4381    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4382      TInt ValAtRow = RowI.GetIntAttr(ColName);
4383      TInt RowIdx = RowI.GetRowIdx();
4384      if (NewIndex.IsKey(ValAtRow)) {
4385         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4386         Curr_V.Add(RowIdx);
4387      }
4388      else {
4389        TIntV New_V;
4390        New_V.Add(RowIdx);
4391        NewIndex.AddDat(ValAtRow, New_V);
4392      }
4393    }
4394    IntColIndexes.AddDat(ColName, NewIndex); 
4395    return 0;
4396  }
4397  TInt TTable::RequestIndexFlt(const TStr& ColName) {
4398    THash<TFlt, TIntV> NewIndex;
4399    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4400      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4401      TInt RowIdx = RowI.GetRowIdx();
4402      if (NewIndex.IsKey(ValAtRow)) {
4403         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4404         Curr_V.Add(RowIdx);
4405      }
4406      else {
4407        TIntV New_V;
4408        New_V.Add(RowIdx);
4409        NewIndex.AddDat(ValAtRow, New_V);
4410      }
4411    }
4412    FltColIndexes.AddDat(ColName, NewIndex); 
4413    return 0;
4414  }
4415  TInt TTable::RequestIndexStrMap(const TStr& ColName) {
4416    THash<TInt, TIntV> NewIndex;
4417    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4418      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4419      TInt RowIdx = RowI.GetRowIdx();
4420      if (NewIndex.IsKey(MapAtRow)) {
4421         TIntV Curr_V = NewIndex.GetDat(MapAtRow);
4422         Curr_V.Add(RowIdx);
4423      }
4424      else {
4425        TIntV New_V;
4426        New_V.Add(RowIdx);
4427        NewIndex.AddDat(MapAtRow, New_V);
4428      }
4429    }
4430    StrMapColIndexes.AddDat(ColName, NewIndex); 
4431    return 0;
4432  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-shash.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</div>
                </div>
                <div class="column column_space"><pre><code>545  void TSparseHash<TKey, TDat, GroupSize>::ResizeDelta(const int& ValsToAdd, const int& MnWanted) {
546    if (Reserved() > MnWanted && Len()+ValsToAdd < ExpandThresh) { return; }
547    const int NewSize = GetMinSize(Table.Len()+ValsToAdd, MnWanted);
</pre></code></div>
                <div class="column column_space"><pre><code>1099  void TTable::Unique(const TStrV& Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    