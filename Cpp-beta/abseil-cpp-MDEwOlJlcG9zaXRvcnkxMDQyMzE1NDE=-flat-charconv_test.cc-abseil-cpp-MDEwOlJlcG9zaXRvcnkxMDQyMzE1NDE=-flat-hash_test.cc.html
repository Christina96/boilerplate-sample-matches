
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.440734557595993%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_test.cc</h3>
            <pre><code>1  #include "absl/strings/charconv.h"
2  #include <cstdlib>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/strings/internal/pow10_helper.h"
7  #include "absl/strings/str_cat.h"
8  #include "absl/strings/str_format.h"
9  #ifdef _MSC_FULL_VER
10  #define ABSL_COMPILER_DOES_EXACT_ROUNDING 0
11  #define ABSL_STRTOD_HANDLES_NAN_CORRECTLY 0
12  #else
13  #define ABSL_COMPILER_DOES_EXACT_ROUNDING 1
14  #define ABSL_STRTOD_HANDLES_NAN_CORRECTLY 1
15  #endif
16  namespace {
17  using absl::strings_internal::Pow10;
18  #if ABSL_COMPILER_DOES_EXACT_ROUNDING
19  void TestDoubleParse(absl::string_view str, double expected_number) {
20    SCOPED_TRACE(str);
21    double actual_number = 0.0;
22    absl::from_chars_result result =
23        absl::from_chars(str.data(), str.data() + str.length(), actual_number);
24    EXPECT_EQ(result.ec, std::errc());
25    EXPECT_EQ(result.ptr, str.data() + str.length());
26    EXPECT_EQ(actual_number, expected_number);
27  }
28  void TestFloatParse(absl::string_view str, float expected_number) {
29    SCOPED_TRACE(str);
30    float actual_number = 0.0;
31    absl::from_chars_result result =
32        absl::from_chars(str.data(), str.data() + str.length(), actual_number);
33    EXPECT_EQ(result.ec, std::errc());
34    EXPECT_EQ(result.ptr, str.data() + str.length());
35    EXPECT_EQ(actual_number, expected_number);
36  }
37  #define FROM_CHARS_TEST_DOUBLE(number)     \
38    {                                        \
39      TestDoubleParse(#number, number);      \
40      TestDoubleParse("-" #number, -number); \
41    }
42  #define FROM_CHARS_TEST_FLOAT(number)        \
43    {                                          \
44      TestFloatParse(#number, number##f);      \
45      TestFloatParse("-" #number, -number##f); \
46    }
47  TEST(FromChars, NearRoundingCases) {
48    FROM_CHARS_TEST_DOUBLE(5.e125);
49    FROM_CHARS_TEST_DOUBLE(69.e267);
50    FROM_CHARS_TEST_DOUBLE(999.e-026);
51    FROM_CHARS_TEST_DOUBLE(7861.e-034);
52    FROM_CHARS_TEST_DOUBLE(75569.e-254);
53    FROM_CHARS_TEST_DOUBLE(928609.e-261);
54    FROM_CHARS_TEST_DOUBLE(9210917.e080);
55    FROM_CHARS_TEST_DOUBLE(84863171.e114);
56    FROM_CHARS_TEST_DOUBLE(653777767.e273);
57    FROM_CHARS_TEST_DOUBLE(5232604057.e-298);
58    FROM_CHARS_TEST_DOUBLE(27235667517.e-109);
59    FROM_CHARS_TEST_DOUBLE(653532977297.e-123);
60    FROM_CHARS_TEST_DOUBLE(3142213164987.e-294);
61    FROM_CHARS_TEST_DOUBLE(46202199371337.e-072);
62    FROM_CHARS_TEST_DOUBLE(231010996856685.e-073);
63    FROM_CHARS_TEST_DOUBLE(9324754620109615.e212);
64    FROM_CHARS_TEST_DOUBLE(78459735791271921.e049);
65    FROM_CHARS_TEST_DOUBLE(272104041512242479.e200);
66    FROM_CHARS_TEST_DOUBLE(6802601037806061975.e198);
67    FROM_CHARS_TEST_DOUBLE(20505426358836677347.e-221);
68    FROM_CHARS_TEST_DOUBLE(836168422905420598437.e-234);
69    FROM_CHARS_TEST_DOUBLE(4891559871276714924261.e222);
70    FROM_CHARS_TEST_FLOAT(5.e-20);
71    FROM_CHARS_TEST_FLOAT(67.e14);
72    FROM_CHARS_TEST_FLOAT(985.e15);
73    FROM_CHARS_TEST_FLOAT(7693.e-42);
74    FROM_CHARS_TEST_FLOAT(55895.e-16);
75    FROM_CHARS_TEST_FLOAT(996622.e-44);
76    FROM_CHARS_TEST_FLOAT(7038531.e-32);
77    FROM_CHARS_TEST_FLOAT(60419369.e-46);
78    FROM_CHARS_TEST_FLOAT(702990899.e-20);
79    FROM_CHARS_TEST_FLOAT(6930161142.e-48);
80    FROM_CHARS_TEST_FLOAT(25933168707.e-13);
81    FROM_CHARS_TEST_FLOAT(596428896559.e20);
82    FROM_CHARS_TEST_DOUBLE(9.e-265);
83    FROM_CHARS_TEST_DOUBLE(85.e-037);
84    FROM_CHARS_TEST_DOUBLE(623.e100);
85    FROM_CHARS_TEST_DOUBLE(3571.e263);
86    FROM_CHARS_TEST_DOUBLE(81661.e153);
87    FROM_CHARS_TEST_DOUBLE(920657.e-023);
88    FROM_CHARS_TEST_DOUBLE(4603285.e-024);
89    FROM_CHARS_TEST_DOUBLE(87575437.e-309);
90    FROM_CHARS_TEST_DOUBLE(245540327.e122);
91    FROM_CHARS_TEST_DOUBLE(6138508175.e120);
92    FROM_CHARS_TEST_DOUBLE(83356057653.e193);
93    FROM_CHARS_TEST_DOUBLE(619534293513.e124);
94    FROM_CHARS_TEST_DOUBLE(2335141086879.e218);
95    FROM_CHARS_TEST_DOUBLE(36167929443327.e-159);
96    FROM_CHARS_TEST_DOUBLE(609610927149051.e-255);
97    FROM_CHARS_TEST_DOUBLE(3743626360493413.e-165);
98    FROM_CHARS_TEST_DOUBLE(94080055902682397.e-242);
99    FROM_CHARS_TEST_DOUBLE(899810892172646163.e283);
100    FROM_CHARS_TEST_DOUBLE(7120190517612959703.e120);
101    FROM_CHARS_TEST_DOUBLE(25188282901709339043.e-252);
102    FROM_CHARS_TEST_DOUBLE(308984926168550152811.e-052);
103    FROM_CHARS_TEST_DOUBLE(6372891218502368041059.e064);
104    FROM_CHARS_TEST_FLOAT(3.e-23);
105    FROM_CHARS_TEST_FLOAT(57.e18);
106    FROM_CHARS_TEST_FLOAT(789.e-35);
107    FROM_CHARS_TEST_FLOAT(2539.e-18);
108    FROM_CHARS_TEST_FLOAT(76173.e28);
109    FROM_CHARS_TEST_FLOAT(887745.e-11);
110    FROM_CHARS_TEST_FLOAT(5382571.e-37);
111    FROM_CHARS_TEST_FLOAT(82381273.e-35);
112    FROM_CHARS_TEST_FLOAT(750486563.e-38);
113    FROM_CHARS_TEST_FLOAT(3752432815.e-39);
114    FROM_CHARS_TEST_FLOAT(75224575729.e-45);
115    FROM_CHARS_TEST_FLOAT(459926601011.e15);
116  }
117  #undef FROM_CHARS_TEST_DOUBLE
118  #undef FROM_CHARS_TEST_FLOAT
119  #endif
120  float ToFloat(absl::string_view s) {
121    float f;
122    absl::from_chars(s.data(), s.data() + s.size(), f);
123    return f;
124  }
125  double ToDouble(absl::string_view s) {
126    double d;
127    absl::from_chars(s.data(), s.data() + s.size(), d);
128    return d;
129  }
130  TEST(FromChars, NearRoundingCasesExplicit) {
131    EXPECT_EQ(ToDouble("5.e125"), ldexp(6653062250012735, 365));
132    EXPECT_EQ(ToDouble("69.e267"), ldexp(4705683757438170, 841));
133    EXPECT_EQ(ToDouble("999.e-026"), ldexp(6798841691080350, -129));
134    EXPECT_EQ(ToDouble("7861.e-034"), ldexp(8975675289889240, -153));
135    EXPECT_EQ(ToDouble("75569.e-254"), ldexp(6091718967192243, -880));
136    EXPECT_EQ(ToDouble("928609.e-261"), ldexp(7849264900213743, -900));
137    EXPECT_EQ(ToDouble("9210917.e080"), ldexp(8341110837370930, 236));
138    EXPECT_EQ(ToDouble("84863171.e114"), ldexp(4625202867375927, 353));
139    EXPECT_EQ(ToDouble("653777767.e273"), ldexp(5068902999763073, 884));
140    EXPECT_EQ(ToDouble("5232604057.e-298"), ldexp(5741343011915040, -1010));
141    EXPECT_EQ(ToDouble("27235667517.e-109"), ldexp(6707124626673586, -380));
142    EXPECT_EQ(ToDouble("653532977297.e-123"), ldexp(7078246407265384, -422));
143    EXPECT_EQ(ToDouble("3142213164987.e-294"), ldexp(8219991337640559, -988));
144    EXPECT_EQ(ToDouble("46202199371337.e-072"), ldexp(5224462102115359, -246));
145    EXPECT_EQ(ToDouble("231010996856685.e-073"), ldexp(5224462102115359, -247));
146    EXPECT_EQ(ToDouble("9324754620109615.e212"), ldexp(5539753864394442, 705));
147    EXPECT_EQ(ToDouble("78459735791271921.e049"), ldexp(8388176519442766, 166));
148    EXPECT_EQ(ToDouble("272104041512242479.e200"), ldexp(5554409530847367, 670));
149    EXPECT_EQ(ToDouble("6802601037806061975.e198"), ldexp(5554409530847367, 668));
150    EXPECT_EQ(ToDouble("20505426358836677347.e-221"),
151              ldexp(4524032052079546, -722));
152    EXPECT_EQ(ToDouble("836168422905420598437.e-234"),
153              ldexp(5070963299887562, -760));
154    EXPECT_EQ(ToDouble("4891559871276714924261.e222"),
155              ldexp(6452687840519111, 757));
156    EXPECT_EQ(ToFloat("5.e-20"), ldexpf(15474250, -88));
157    EXPECT_EQ(ToFloat("67.e14"), ldexpf(12479722, 29));
158    EXPECT_EQ(ToFloat("985.e15"), ldexpf(14333636, 36));
159    EXPECT_EQ(ToFloat("7693.e-42"), ldexpf(10979816, -150));
160    EXPECT_EQ(ToFloat("55895.e-16"), ldexpf(12888509, -61));
161    EXPECT_EQ(ToFloat("996622.e-44"), ldexpf(14224264, -150));
162    EXPECT_EQ(ToFloat("7038531.e-32"), ldexpf(11420669, -107));
163    EXPECT_EQ(ToFloat("60419369.e-46"), ldexpf(8623340, -150));
164    EXPECT_EQ(ToFloat("702990899.e-20"), ldexpf(16209866, -61));
165    EXPECT_EQ(ToFloat("6930161142.e-48"), ldexpf(9891056, -150));
166    EXPECT_EQ(ToFloat("25933168707.e-13"), ldexpf(11138211, -32));
167    EXPECT_EQ(ToFloat("596428896559.e20"), ldexpf(12333860, 82));
168    EXPECT_EQ(ToDouble("9.e-265"), ldexp(8168427841980010, -930));
169    EXPECT_EQ(ToDouble("85.e-037"), ldexp(6360455125664090, -169));
170    EXPECT_EQ(ToDouble("623.e100"), ldexp(6263531988747231, 289));
171    EXPECT_EQ(ToDouble("3571.e263"), ldexp(6234526311072170, 833));
172    EXPECT_EQ(ToDouble("81661.e153"), ldexp(6696636728760206, 472));
173    EXPECT_EQ(ToDouble("920657.e-023"), ldexp(5975405561110124, -109));
174    EXPECT_EQ(ToDouble("4603285.e-024"), ldexp(5975405561110124, -110));
175    EXPECT_EQ(ToDouble("87575437.e-309"), ldexp(8452160731874668, -1053));
176    EXPECT_EQ(ToDouble("245540327.e122"), ldexp(4985336549131723, 381));
177    EXPECT_EQ(ToDouble("6138508175.e120"), ldexp(4985336549131723, 379));
178    EXPECT_EQ(ToDouble("83356057653.e193"), ldexp(5986732817132056, 625));
179    EXPECT_EQ(ToDouble("619534293513.e124"), ldexp(4798406992060657, 399));
180    EXPECT_EQ(ToDouble("2335141086879.e218"), ldexp(5419088166961646, 713));
181    EXPECT_EQ(ToDouble("36167929443327.e-159"), ldexp(8135819834632444, -536));
182    EXPECT_EQ(ToDouble("609610927149051.e-255"), ldexp(4576664294594737, -850));
183    EXPECT_EQ(ToDouble("3743626360493413.e-165"), ldexp(6898586531774201, -549));
184    EXPECT_EQ(ToDouble("94080055902682397.e-242"), ldexp(6273271706052298, -800));
185    EXPECT_EQ(ToDouble("899810892172646163.e283"), ldexp(7563892574477827, 947));
186    EXPECT_EQ(ToDouble("7120190517612959703.e120"), ldexp(5385467232557565, 409));
187    EXPECT_EQ(ToDouble("25188282901709339043.e-252"),
188              ldexp(5635662608542340, -825));
189    EXPECT_EQ(ToDouble("308984926168550152811.e-052"),
190              ldexp(5644774693823803, -157));
191    EXPECT_EQ(ToDouble("6372891218502368041059.e064"),
192              ldexp(4616868614322430, 233));
193    EXPECT_EQ(ToFloat("3.e-23"), ldexpf(9507380, -98));
194    EXPECT_EQ(ToFloat("57.e18"), ldexpf(12960300, 42));
<span onclick='openModal()' class='match'>195    EXPECT_EQ(ToFloat("789.e-35"), ldexpf(10739312, -130));
196    EXPECT_EQ(ToFloat("2539.e-18"), ldexpf(11990089, -72));
197    EXPECT_EQ(ToFloat("76173.e28"), ldexpf(9845130, 86));
198    EXPECT_EQ(ToFloat("887745.e-11"), ldexpf(9760860, -40));
199    EXPECT_EQ(ToFloat("5382571.e-37"), ldexpf(11447463, -124));
</span>200    EXPECT_EQ(ToFloat("82381273.e-35"), ldexpf(8554961, -113));
201    EXPECT_EQ(ToFloat("750486563.e-38"), ldexpf(9975678, -120));
202    EXPECT_EQ(ToFloat("3752432815.e-39"), ldexpf(9975678, -121));
203    EXPECT_EQ(ToFloat("75224575729.e-45"), ldexpf(13105970, -137));
204    EXPECT_EQ(ToFloat("459926601011.e15"), ldexpf(12466336, 65));
205  }
206  template <typename FloatType>
207  void TestHalfwayValue(const std::string& mantissa, int exponent,
208                        FloatType expected_low, FloatType expected_high,
209                        FloatType expected_half) {
210    std::string low_rep = mantissa;
211    low_rep[low_rep.size() - 1] -= 1;
212    absl::StrAppend(&low_rep, std::string(1000, '9'), "e", exponent);
213    FloatType actual_low = 0;
214    absl::from_chars(low_rep.data(), low_rep.data() + low_rep.size(), actual_low);
215    EXPECT_EQ(expected_low, actual_low);
216    std::string high_rep =
217        absl::StrCat(mantissa, std::string(1000, '0'), "1e", exponent);
218    FloatType actual_high = 0;
219    absl::from_chars(high_rep.data(), high_rep.data() + high_rep.size(),
220                     actual_high);
221    EXPECT_EQ(expected_high, actual_high);
222    std::string halfway_rep = absl::StrCat(mantissa, "e", exponent);
223    FloatType actual_half = 0;
224    absl::from_chars(halfway_rep.data(), halfway_rep.data() + halfway_rep.size(),
225                     actual_half);
226    EXPECT_EQ(expected_half, actual_half);
227  }
228  TEST(FromChars, DoubleRounding) {
229    const double zero = 0.0;
230    const double first_subnormal = nextafter(zero, 1.0);
231    const double second_subnormal = nextafter(first_subnormal, 1.0);
232    const double first_normal = DBL_MIN;
233    const double last_subnormal = nextafter(first_normal, 0.0);
234    const double second_normal = nextafter(first_normal, 1.0);
235    const double last_normal = DBL_MAX;
236    const double penultimate_normal = nextafter(last_normal, 0.0);
237    TestHalfwayValue(
238        "2."
239        "470328229206232720882843964341106861825299013071623822127928412503377536"
240        "351043759326499181808179961898982823477228588654633283551779698981993873"
241        "980053909390631503565951557022639229085839244910518443593180284993653615"
242        "250031937045767824921936562366986365848075700158576926990370631192827955"
243        "855133292783433840935197801553124659726357957462276646527282722005637400"
244        "648549997709659947045402082816622623785739345073633900796776193057750674"
245        "017632467360096895134053553745851666113422376667860416215968046191446729"
246        "184030053005753084904876539171138659164623952491262365388187963623937328"
247        "042389101867234849766823508986338858792562830275599565752445550725518931"
248        "369083625477918694866799496832404970582102851318545139621383772282614543"
249        "7693412532098591327667236328125",
250        -324, zero, first_subnormal, zero);
251    TestHalfwayValue(
252        "7."
253        "410984687618698162648531893023320585475897039214871466383785237510132609"
254        "053131277979497545424539885696948470431685765963899850655339096945981621"
255        "940161728171894510697854671067917687257517734731555330779540854980960845"
256        "750095811137303474765809687100959097544227100475730780971111893578483867"
257        "565399878350301522805593404659373979179073872386829939581848166016912201"
258        "945649993128979841136206248449867871357218035220901702390328579173252022"
259        "052897402080290685402160661237554998340267130003581248647904138574340187"
260        "552090159017259254714629617513415977493871857473787096164563890871811984"
261        "127167305601704549300470526959016576377688490826798697257336652176556794"
262        "107250876433756084600398490497214911746308553955635418864151316847843631"
263        "3080237596295773983001708984375",
264        -324, first_subnormal, second_subnormal, second_subnormal);
265    TestHalfwayValue(
266        "2."
267        "225073858507201136057409796709131975934819546351645648023426109724822222"
268        "021076945516529523908135087914149158913039621106870086438694594645527657"
269        "207407820621743379988141063267329253552286881372149012981122451451889849"
270        "057222307285255133155755015914397476397983411801999323962548289017107081"
271        "850690630666655994938275772572015763062690663332647565300009245888316433"
272        "037779791869612049497390377829704905051080609940730262937128958950003583"
273        "799967207254304360284078895771796150945516748243471030702609144621572289"
274        "880258182545180325707018860872113128079512233426288368622321503775666622"
275        "503982534335974568884423900265498198385487948292206894721689831099698365"
276        "846814022854243330660339850886445804001034933970427567186443383770486037"
277        "86162277173854562306587467901408672332763671875",
278        -308, last_subnormal, first_normal, first_normal);
279    TestHalfwayValue(
280        "2."
281        "225073858507201630123055637955676152503612414573018013083228724049586647"
282        "606759446192036794116886953213985520549032000903434781884412325572184367"
283        "563347617020518175998922941393629966742598285899994830148971433555578567"
284        "693279306015978183162142425067962460785295885199272493577688320732492479"
285        "924816869232247165964934329258783950102250973957579510571600738343645738"
286        "494324192997092179207389919761694314131497173265255020084997973676783743"
287        "155205818804439163810572367791175177756227497413804253387084478193655533"
288        "073867420834526162513029462022730109054820067654020201547112002028139700"
289        "141575259123440177362244273712468151750189745559978653234255886219611516"
290        "335924167958029604477064946470184777360934300451421683607013647479513962"
291        "13837722826145437693412532098591327667236328125",
292        -308, first_normal, second_normal, first_normal);
293    TestHalfwayValue(
294        "1."
295        "797693134862315608353258760581052985162070023416521662616611746258695532"
296        "672923265745300992879465492467506314903358770175220871059269879629062776"
297        "047355692132901909191523941804762171253349609463563872612866401980290377"
298        "995141836029815117562837277714038305214839639239356331336428021390916694"
299        "57927874464075218944",
300        308, penultimate_normal, last_normal, penultimate_normal);
301  }
302  TEST(FromChars, FloatRounding) {
303    const float zero = 0.0;
304    const float first_subnormal = nextafterf(zero, 1.0);
305    const float second_subnormal = nextafterf(first_subnormal, 1.0);
306    const float first_normal = FLT_MIN;
307    const float last_subnormal = nextafterf(first_normal, 0.0);
308    const float second_normal = nextafterf(first_normal, 1.0);
309    const float last_normal = FLT_MAX;
310    const float penultimate_normal = nextafterf(last_normal, 0.0);
311    TestHalfwayValue(
312        "7."
313        "006492321624085354618647916449580656401309709382578858785341419448955413"
314        "42930300743319094181060791015625",
315        -46, zero, first_subnormal, zero);
316    TestHalfwayValue(
317        "2."
318        "101947696487225606385594374934874196920392912814773657635602425834686624"
319        "028790902229957282543182373046875",
320        -45, first_subnormal, second_subnormal, second_subnormal);
321    TestHalfwayValue(
322        "1."
323        "175494280757364291727882991035766513322858992758990427682963118425003064"
324        "9651730385585324256680905818939208984375",
325        -38, last_subnormal, first_normal, first_normal);
326    TestHalfwayValue(
327        "1."
328        "175494420887210724209590083408724842314472120785184615334540294131831453"
329        "9442813071445925743319094181060791015625",
330        -38, first_normal, second_normal, first_normal);
331    TestHalfwayValue("3.40282336497324057985868971510891282432", 38,
332                     penultimate_normal, last_normal, penultimate_normal);
333  }
334  TEST(FromChars, Underflow) {
335    double d;
336    float f;
337    absl::from_chars_result result;
338    std::string negative_underflow = "-1e-1000";
339    const char* begin = negative_underflow.data();
340    const char* end = begin + negative_underflow.size();
341    d = 100.0;
342    result = absl::from_chars(begin, end, d);
343    EXPECT_EQ(result.ptr, end);
344    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
345    EXPECT_TRUE(std::signbit(d));  
346    EXPECT_GE(d, -std::numeric_limits<double>::min());
347    f = 100.0;
348    result = absl::from_chars(begin, end, f);
349    EXPECT_EQ(result.ptr, end);
350    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
351    EXPECT_TRUE(std::signbit(f));  
352    EXPECT_GE(f, -std::numeric_limits<float>::min());
353    std::string positive_underflow = "1e-1000";
354    begin = positive_underflow.data();
355    end = begin + positive_underflow.size();
356    d = -100.0;
357    result = absl::from_chars(begin, end, d);
358    EXPECT_EQ(result.ptr, end);
359    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
360    EXPECT_FALSE(std::signbit(d));  
361    EXPECT_LE(d, std::numeric_limits<double>::min());
362    f = -100.0;
363    result = absl::from_chars(begin, end, f);
364    EXPECT_EQ(result.ptr, end);
365    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
366    EXPECT_FALSE(std::signbit(f));  
367    EXPECT_LE(f, std::numeric_limits<float>::min());
368  }
369  TEST(FromChars, Overflow) {
370    double d;
371    float f;
372    absl::from_chars_result result;
373    std::string negative_overflow = "-1e1000";
374    const char* begin = negative_overflow.data();
375    const char* end = begin + negative_overflow.size();
376    d = 100.0;
377    result = absl::from_chars(begin, end, d);
378    EXPECT_EQ(result.ptr, end);
379    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
380    EXPECT_TRUE(std::signbit(d));  
381    EXPECT_EQ(d, -std::numeric_limits<double>::max());
382    f = 100.0;
383    result = absl::from_chars(begin, end, f);
384    EXPECT_EQ(result.ptr, end);
385    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
386    EXPECT_TRUE(std::signbit(f));  
387    EXPECT_EQ(f, -std::numeric_limits<float>::max());
388    std::string positive_overflow = "1e1000";
389    begin = positive_overflow.data();
390    end = begin + positive_overflow.size();
391    d = -100.0;
392    result = absl::from_chars(begin, end, d);
393    EXPECT_EQ(result.ptr, end);
394    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
395    EXPECT_FALSE(std::signbit(d));  
396    EXPECT_EQ(d, std::numeric_limits<double>::max());
397    f = -100.0;
398    result = absl::from_chars(begin, end, f);
399    EXPECT_EQ(result.ptr, end);
400    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
401    EXPECT_FALSE(std::signbit(f));  
402    EXPECT_EQ(f, std::numeric_limits<float>::max());
403  }
404  TEST(FromChars, RegressionTestsFromFuzzer) {
405    absl::string_view src = "0x21900000p00000000099";
406    float f;
407    auto result = absl::from_chars(src.data(), src.data() + src.size(), f);
408    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
409  }
410  TEST(FromChars, ReturnValuePtr) {
411    double d;
412    absl::from_chars_result result;
413    std::string normal = "3.14@#$%@#$%";
414    result = absl::from_chars(normal.data(), normal.data() + normal.size(), d);
415    EXPECT_EQ(result.ec, std::errc());
416    EXPECT_EQ(result.ptr - normal.data(), 4);
417    std::string overflow = "1e1000@#$%@#$%";
418    result = absl::from_chars(overflow.data(),
419                              overflow.data() + overflow.size(), d);
420    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
421    EXPECT_EQ(result.ptr - overflow.data(), 6);
422    std::string garbage = "#$%@#$%";
423    result = absl::from_chars(garbage.data(),
424                              garbage.data() + garbage.size(), d);
425    EXPECT_EQ(result.ec, std::errc::invalid_argument);
426    EXPECT_EQ(result.ptr - garbage.data(), 0);
427  }
428  TEST(FromChars, TestVersusStrtod) {
429    for (int mantissa = 1000000; mantissa <= 9999999; mantissa += 501) {
430      for (int exponent = -300; exponent < 300; ++exponent) {
431        std::string candidate = absl::StrCat(mantissa, "e", exponent);
432        double strtod_value = strtod(candidate.c_str(), nullptr);
433        double absl_value = 0;
434        absl::from_chars(candidate.data(), candidate.data() + candidate.size(),
435                         absl_value);
436        ASSERT_EQ(strtod_value, absl_value) << candidate;
437      }
438    }
439  }
440  TEST(FromChars, TestVersusStrtof) {
441    for (int mantissa = 1000000; mantissa <= 9999999; mantissa += 501) {
442      for (int exponent = -43; exponent < 32; ++exponent) {
443        std::string candidate = absl::StrCat(mantissa, "e", exponent);
444        float strtod_value = strtof(candidate.c_str(), nullptr);
445        float absl_value = 0;
446        absl::from_chars(candidate.data(), candidate.data() + candidate.size(),
447                         absl_value);
448        ASSERT_EQ(strtod_value, absl_value) << candidate;
449      }
450    }
451  }
452  template <typename Float>
453  bool Identical(Float a, Float b) {
454    return 0 == memcmp(&a, &b, sizeof(Float));
455  }
456  TEST(FromChars, NaNDoubles) {
457    for (std::string n_char_sequence :
458         {"", "1", "2", "3", "fff", "FFF", "200000", "400000", "4000000000000",
459          "8000000000000", "abc123", "legal_but_unexpected",
460          "99999999999999999999999", "_"}) {
461      std::string input = absl::StrCat("nan(", n_char_sequence, ")");
462      SCOPED_TRACE(input);
463      double from_chars_double;
464      absl::from_chars(input.data(), input.data() + input.size(),
465                       from_chars_double);
466      double std_nan_double = std::nan(n_char_sequence.c_str());
467      EXPECT_TRUE(Identical(from_chars_double, std_nan_double));
468  #if ABSL_STRTOD_HANDLES_NAN_CORRECTLY
469      double strtod_double = strtod(input.c_str(), nullptr);
470      EXPECT_TRUE(Identical(from_chars_double, strtod_double));
471  #endif  
472      std::string negative_input = "-" + input;
473      double negative_from_chars_double;
474      absl::from_chars(negative_input.data(),
475                       negative_input.data() + negative_input.size(),
476                       negative_from_chars_double);
477      EXPECT_TRUE(std::signbit(negative_from_chars_double));
478      EXPECT_FALSE(Identical(negative_from_chars_double, from_chars_double));
479      from_chars_double = std::copysign(from_chars_double, -1.0);
480      EXPECT_TRUE(Identical(negative_from_chars_double, from_chars_double));
481    }
482  }
483  TEST(FromChars, NaNFloats) {
484    for (std::string n_char_sequence :
485         {"", "1", "2", "3", "fff", "FFF", "200000", "400000", "4000000000000",
486          "8000000000000", "abc123", "legal_but_unexpected",
487          "99999999999999999999999", "_"}) {
488      std::string input = absl::StrCat("nan(", n_char_sequence, ")");
489      SCOPED_TRACE(input);
490      float from_chars_float;
491      absl::from_chars(input.data(), input.data() + input.size(),
492                       from_chars_float);
493      float std_nan_float = std::nanf(n_char_sequence.c_str());
494      EXPECT_TRUE(Identical(from_chars_float, std_nan_float));
495  #if ABSL_STRTOD_HANDLES_NAN_CORRECTLY
496      float strtof_float = strtof(input.c_str(), nullptr);
497      EXPECT_TRUE(Identical(from_chars_float, strtof_float));
498  #endif  
499      std::string negative_input = "-" + input;
500      float negative_from_chars_float;
501      absl::from_chars(negative_input.data(),
502                       negative_input.data() + negative_input.size(),
503                       negative_from_chars_float);
504      EXPECT_TRUE(std::signbit(negative_from_chars_float));
505      EXPECT_FALSE(Identical(negative_from_chars_float, from_chars_float));
506      from_chars_float = std::copysign(from_chars_float, -1.0f);
507      EXPECT_TRUE(Identical(negative_from_chars_float, from_chars_float));
508    }
509  }
510  int NextStep(int step) {
511    return step + (step >> 2) + 1;
512  }
513  template <typename Float>
514  void TestOverflowAndUnderflow(
515      const std::function<std::string(int)>& input_generator,
516      const std::function<Float(int)>& expected_generator, int lower_bound,
517      int upper_bound) {
518    int index, step;
519    for (index = lower_bound, step = 1; index < upper_bound;
520         index += step, step = NextStep(step)) {
521      std::string input = input_generator(index);
522      SCOPED_TRACE(input);
523      Float expected = expected_generator(index);
524      Float actual;
525      auto result =
526          absl::from_chars(input.data(), input.data() + input.size(), actual);
527      EXPECT_EQ(result.ec, std::errc());
528      EXPECT_EQ(expected, actual)
529          << absl::StrFormat("%a vs %a", expected, actual);
530    }
531    for (index = upper_bound, step = 1; index > lower_bound;
532         index -= step, step = NextStep(step)) {
533      std::string input = input_generator(index);
534      SCOPED_TRACE(input);
535      Float expected = expected_generator(index);
536      Float actual;
537      auto result =
538          absl::from_chars(input.data(), input.data() + input.size(), actual);
539      EXPECT_EQ(result.ec, std::errc());
540      EXPECT_EQ(expected, actual)
541          << absl::StrFormat("%a vs %a", expected, actual);
542    }
543    for (index = lower_bound - 1, step = 1; index > -1000000;
544         index -= step, step = NextStep(step)) {
545      std::string input = input_generator(index);
546      SCOPED_TRACE(input);
547      Float actual;
548      auto result =
549          absl::from_chars(input.data(), input.data() + input.size(), actual);
550      EXPECT_EQ(result.ec, std::errc::result_out_of_range);
551      EXPECT_LT(actual, 1.0);  
552    }
553    for (index = upper_bound + 1, step = 1; index < 1000000;
554         index += step, step = NextStep(step)) {
555      std::string input = input_generator(index);
556      SCOPED_TRACE(input);
557      Float actual;
558      auto result =
559          absl::from_chars(input.data(), input.data() + input.size(), actual);
560      EXPECT_EQ(result.ec, std::errc::result_out_of_range);
561      EXPECT_GT(actual, 1.0);  
562    }
563  }
564  TEST(FromChars, HexdecimalDoubleLimits) {
565    auto input_gen = [](int index) { return absl::StrCat("0x1.0p", index); };
566    auto expected_gen = [](int index) { return std::ldexp(1.0, index); };
567    TestOverflowAndUnderflow<double>(input_gen, expected_gen, -1074, 1023);
568  }
569  TEST(FromChars, HexdecimalFloatLimits) {
570    auto input_gen = [](int index) { return absl::StrCat("0x1.0p", index); };
571    auto expected_gen = [](int index) { return std::ldexp(1.0f, index); };
572    TestOverflowAndUnderflow<float>(input_gen, expected_gen, -149, 127);
573  }
574  TEST(FromChars, DecimalDoubleLimits) {
575    auto input_gen = [](int index) { return absl::StrCat("1.0e", index); };
576    auto expected_gen = [](int index) { return Pow10(index); };
577    TestOverflowAndUnderflow<double>(input_gen, expected_gen, -323, 308);
578  }
579  TEST(FromChars, DecimalFloatLimits) {
580    auto input_gen = [](int index) { return absl::StrCat("1.0e", index); };
581    auto expected_gen = [](int index) { return Pow10(index); };
582    TestOverflowAndUnderflow<float>(input_gen, expected_gen, -45, 38);
583  }
584  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_test.cc</h3>
            <pre><code>1  #include "absl/hash/hash.h"
2  #include <algorithm>
3  #include <array>
4  #include <bitset>
5  #include <cstdint>
6  #include <cstring>
7  #include <deque>
8  #include <forward_list>
9  #include <functional>
10  #include <initializer_list>
11  #include <iterator>
12  #include <limits>
13  #include <list>
14  #include <map>
15  #include <memory>
16  #include <numeric>
17  #include <random>
18  #include <set>
19  #include <string>
20  #include <tuple>
21  #include <type_traits>
22  #include <unordered_map>
23  #include <unordered_set>
24  #include <utility>
25  #include <vector>
26  #include "gmock/gmock.h"
27  #include "gtest/gtest.h"
28  #include "absl/container/btree_map.h"
29  #include "absl/container/btree_set.h"
30  #include "absl/container/flat_hash_map.h"
31  #include "absl/container/flat_hash_set.h"
32  #include "absl/container/node_hash_map.h"
33  #include "absl/container/node_hash_set.h"
34  #include "absl/hash/hash_testing.h"
35  #include "absl/hash/internal/hash_test.h"
36  #include "absl/hash/internal/spy_hash_state.h"
37  #include "absl/meta/type_traits.h"
38  #include "absl/numeric/int128.h"
39  #include "absl/strings/cord_test_helpers.h"
40  #ifdef ABSL_HAVE_STD_STRING_VIEW
41  #include <string_view>
42  #endif
43  namespace {
44  using ::absl::hash_test_internal::is_hashable;
45  using ::absl::hash_test_internal::TypeErasedContainer;
46  using ::absl::hash_test_internal::TypeErasedValue;
47  template <typename T>
48  using TypeErasedVector = TypeErasedContainer<std::vector<T>>;
49  using absl::Hash;
50  using absl::hash_internal::SpyHashState;
51  template <typename T>
52  class HashValueIntTest : public testing::Test {
53  };
54  TYPED_TEST_SUITE_P(HashValueIntTest);
55  template <typename T>
56  SpyHashState SpyHash(const T& value) {
57    return SpyHashState::combine(SpyHashState(), value);
58  }
59  TYPED_TEST_P(HashValueIntTest, BasicUsage) {
60    EXPECT_TRUE((is_hashable<TypeParam>::value));
61    TypeParam n = 42;
62    EXPECT_EQ(SpyHash(n), SpyHash(TypeParam{42}));
63    EXPECT_NE(SpyHash(n), SpyHash(TypeParam{0}));
64    EXPECT_NE(SpyHash(std::numeric_limits<TypeParam>::max()),
65              SpyHash(std::numeric_limits<TypeParam>::min()));
66  }
67  TYPED_TEST_P(HashValueIntTest, FastPath) {
68    TypeParam n = 42;
69    EXPECT_EQ(absl::Hash<TypeParam>{}(n),
70              absl::Hash<std::tuple<TypeParam>>{}(std::tuple<TypeParam>(n)));
71  }
72  REGISTER_TYPED_TEST_SUITE_P(HashValueIntTest, BasicUsage, FastPath);
73  using IntTypes = testing::Types<unsigned char, char, int, int32_t, int64_t,
74                                  uint32_t, uint64_t, size_t>;
75  INSTANTIATE_TYPED_TEST_SUITE_P(My, HashValueIntTest, IntTypes);
76  enum LegacyEnum { kValue1, kValue2, kValue3 };
77  enum class EnumClass { kValue4, kValue5, kValue6 };
78  TEST(HashValueTest, EnumAndBool) {
79    EXPECT_TRUE((is_hashable<LegacyEnum>::value));
80    EXPECT_TRUE((is_hashable<EnumClass>::value));
81    EXPECT_TRUE((is_hashable<bool>::value));
82    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
83        LegacyEnum::kValue1, LegacyEnum::kValue2, LegacyEnum::kValue3)));
84    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
85        EnumClass::kValue4, EnumClass::kValue5, EnumClass::kValue6)));
86    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
87        std::make_tuple(true, false)));
88  }
89  TEST(HashValueTest, FloatingPoint) {
90    EXPECT_TRUE((is_hashable<float>::value));
91    EXPECT_TRUE((is_hashable<double>::value));
92    EXPECT_TRUE((is_hashable<long double>::value));
93    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
94        std::make_tuple(42.f, 0.f, -0.f, std::numeric_limits<float>::infinity(),
95                        -std::numeric_limits<float>::infinity())));
96    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
97        std::make_tuple(42., 0., -0., std::numeric_limits<double>::infinity(),
98                        -std::numeric_limits<double>::infinity())));
99    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
100        .5L, 1.L, 2.L, 4.L, 42.L, 0.L, -0.L,
101        17 * static_cast<long double>(std::numeric_limits<double>::max()),
102        std::numeric_limits<long double>::infinity(),
103        -std::numeric_limits<long double>::infinity())));
104  }
105  TEST(HashValueTest, Pointer) {
106    EXPECT_TRUE((is_hashable<int*>::value));
107    EXPECT_TRUE((is_hashable<int(*)(char, float)>::value));
108    EXPECT_TRUE((is_hashable<void(*)(int, int, ...)>::value));
109    int i;
110    int* ptr = &i;
111    int* n = nullptr;
112    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
113        std::make_tuple(&i, ptr, nullptr, ptr + 1, n)));
114  }
115  TEST(HashValueTest, PointerAlignment) {
116    constexpr size_t kTotalSize = 1 << 20;
117    std::unique_ptr<char[]> data(new char[kTotalSize]);
118    constexpr size_t kLog2NumValues = 5;
119    constexpr size_t kNumValues = 1 << kLog2NumValues;
120    for (size_t align = 1; align < kTotalSize / kNumValues;
121         align < 8 ? align += 1 : align < 1024 ? align += 8 : align += 32) {
122      SCOPED_TRACE(align);
123      ASSERT_LE(align * kNumValues, kTotalSize);
124      size_t bits_or = 0;
125      size_t bits_and = ~size_t{};
126      for (size_t i = 0; i < kNumValues; ++i) {
127        size_t hash = absl::Hash<void*>()(data.get() + i * align);
128        bits_or |= hash;
129        bits_and &= hash;
130      }
131      constexpr size_t kMask = (1 << (kLog2NumValues + 7)) - 1;
132      size_t stuck_bits = (~bits_or | bits_and) & kMask;
133      EXPECT_EQ(stuck_bits, 0u) << "0x" << std::hex << stuck_bits;
134    }
135  }
136  TEST(HashValueTest, PointerToMember) {
137    struct Bass {
138      void q() {}
139    };
140    struct A : Bass {
141      virtual ~A() = default;
142      virtual void vfa() {}
143      static auto pq() -> void (A::*)() { return &A::q; }
144    };
145    struct B : Bass {
146      virtual ~B() = default;
147      virtual void vfb() {}
148      static auto pq() -> void (B::*)() { return &B::q; }
149    };
150    struct Foo : A, B {
151      void f1() {}
152      void f2() const {}
153      int g1() & { return 0; }
154      int g2() const & { return 0; }
155      int g3() && { return 0; }
156      int g4() const && { return 0; }
157      int h1() & { return 0; }
158      int h2() const & { return 0; }
159      int h3() && { return 0; }
160      int h4() const && { return 0; }
161      int a;
162      int b;
163      const int c = 11;
164      const int d = 22;
165    };
166    EXPECT_TRUE((is_hashable<float Foo::*>::value));
167    EXPECT_TRUE((is_hashable<double (Foo::*)(int, int)&&>::value));
168    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
169        std::make_tuple(&Foo::a, &Foo::b, static_cast<int Foo::*>(nullptr))));
170    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
171        std::make_tuple(&Foo::c, &Foo::d, static_cast<const int Foo::*>(nullptr),
172                        &Foo::a, &Foo::b)));
173    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
174        &Foo::f1, static_cast<void (Foo::*)()>(nullptr))));
175    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
176        &Foo::f2, static_cast<void (Foo::*)() const>(nullptr))));
177    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
178        &Foo::g1, &Foo::h1, static_cast<int (Foo::*)() &>(nullptr))));
179    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
180        &Foo::g2, &Foo::h2, static_cast<int (Foo::*)() const &>(nullptr))));
181    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
182        &Foo::g3, &Foo::h3, static_cast<int (Foo::*)() &&>(nullptr))));
183    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
184        &Foo::g4, &Foo::h4, static_cast<int (Foo::*)() const &&>(nullptr))));
185    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
186        std::make_tuple(static_cast<void (Foo::*)()>(&Foo::vfa),
187                        static_cast<void (Foo::*)()>(&Foo::vfb),
188                        static_cast<void (Foo::*)()>(nullptr))));
189    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
190        std::make_tuple(static_cast<void (Foo::*)()>(Foo::A::pq()),
191                        static_cast<void (Foo::*)()>(Foo::B::pq()),
192                        static_cast<void (Foo::*)()>(nullptr))));
193  }
194  TEST(HashValueTest, PairAndTuple) {
195    EXPECT_TRUE((is_hashable<std::pair<int, int>>::value));
196    EXPECT_TRUE((is_hashable<std::pair<const int&, const int&>>::value));
197    EXPECT_TRUE((is_hashable<std::tuple<int&, int&>>::value));
198    EXPECT_TRUE((is_hashable<std::tuple<int&&, int&&>>::value));
199    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
200        std::make_pair(0, 42), std::make_pair(0, 42), std::make_pair(42, 0),
201        std::make_pair(0, 0), std::make_pair(42, 42), std::make_pair(1, 42))));
202    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
203        std::make_tuple(std::make_tuple(0, 0, 0), std::make_tuple(0, 0, 42),
204                        std::make_tuple(0, 23, 0), std::make_tuple(17, 0, 0),
205                        std::make_tuple(42, 0, 0), std::make_tuple(3, 9, 9),
206                        std::make_tuple(0, 0, -42))));
207    int a = 0, b = 1, c = 17, d = 23;
208    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
209        std::tie(a, a), std::tie(a, b), std::tie(b, c), std::tie(c, d))));
210    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
211        std::forward_as_tuple(0, 0, 0), std::forward_as_tuple(0, 0, 42),
212        std::forward_as_tuple(0, 23, 0), std::forward_as_tuple(17, 0, 0),
213        std::forward_as_tuple(42, 0, 0), std::forward_as_tuple(3, 9, 9),
214        std::forward_as_tuple(0, 0, -42))));
215  }
216  TEST(HashValueTest, CombineContiguousWorks) {
217    std::vector<std::tuple<int>> v1 = {std::make_tuple(1), std::make_tuple(3)};
218    std::vector<std::tuple<int>> v2 = {std::make_tuple(1), std::make_tuple(2)};
219    auto vh1 = SpyHash(v1);
220    auto vh2 = SpyHash(v2);
221    EXPECT_NE(vh1, vh2);
222  }
223  struct DummyDeleter {
224    template <typename T>
225    void operator() (T* ptr) {}
226  };
227  struct SmartPointerEq {
228    template <typename T, typename U>
229    bool operator()(const T& t, const U& u) const {
230      return GetPtr(t) == GetPtr(u);
231    }
232    template <typename T>
233    static auto GetPtr(const T& t) -> decltype(&*t) {
234      return t ? &*t : nullptr;
235    }
236    static std::nullptr_t GetPtr(std::nullptr_t) { return nullptr; }
237  };
238  TEST(HashValueTest, SmartPointers) {
239    EXPECT_TRUE((is_hashable<std::unique_ptr<int>>::value));
240    EXPECT_TRUE((is_hashable<std::unique_ptr<int, DummyDeleter>>::value));
241    EXPECT_TRUE((is_hashable<std::shared_ptr<int>>::value));
242    int i, j;
243    std::unique_ptr<int, DummyDeleter> unique1(&i);
244    std::unique_ptr<int, DummyDeleter> unique2(&i);
245    std::unique_ptr<int, DummyDeleter> unique_other(&j);
246    std::unique_ptr<int, DummyDeleter> unique_null;
247    std::shared_ptr<int> shared1(&i, DummyDeleter());
248    std::shared_ptr<int> shared2(&i, DummyDeleter());
249    std::shared_ptr<int> shared_other(&j, DummyDeleter());
250    std::shared_ptr<int> shared_null;
251    ASSERT_TRUE(SmartPointerEq{}(unique1, shared1));
252    ASSERT_FALSE(SmartPointerEq{}(unique1, shared_other));
253    ASSERT_TRUE(SmartPointerEq{}(unique_null, nullptr));
254    ASSERT_FALSE(SmartPointerEq{}(shared2, nullptr));
255    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
256        std::forward_as_tuple(&i, nullptr,                    
257                              unique1, unique2, unique_null,  
258                              absl::make_unique<int>(),       
259                              shared1, shared2, shared_null,  
260                              std::make_shared<int>()),
261        SmartPointerEq{}));
262  }
263  TEST(HashValueTest, FunctionPointer) {
264    using Func = int (*)();
265    EXPECT_TRUE(is_hashable<Func>::value);
266    Func p1 = [] { return 2; }, p2 = [] { return 1; };
267    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
268        std::make_tuple(p1, p2, nullptr)));
269  }
270  struct WrapInTuple {
271    template <typename T>
272    std::tuple<int, T, size_t> operator()(const T& t) const {
273      return std::make_tuple(7, t, 0xdeadbeef);
274    }
275  };
276  absl::Cord FlatCord(absl::string_view sv) {
277    absl::Cord c(sv);
278    c.Flatten();
279    return c;
280  }
281  absl::Cord FragmentedCord(absl::string_view sv) {
282    if (sv.size() < 2) {
283      return absl::Cord(sv);
284    }
285    size_t halfway = sv.size() / 2;
286    std::vector<absl::string_view> parts = {sv.substr(0, halfway),
287                                            sv.substr(halfway)};
288    return absl::MakeFragmentedCord(parts);
289  }
290  TEST(HashValueTest, Strings) {
291    EXPECT_TRUE((is_hashable<std::string>::value));
292    const std::string small = "foo";
293    const std::string dup = "foofoo";
294    const std::string large = std::string(2048, 'x');  
295    const std::string huge = std::string(5000, 'a');   
296    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(  
297        std::string(), absl::string_view(), absl::Cord(),                     
298        std::string(""), absl::string_view(""), absl::Cord(""),               
299        std::string(small), absl::string_view(small), absl::Cord(small),      
300        std::string(dup), absl::string_view(dup), absl::Cord(dup),            
301        std::string(large), absl::string_view(large), absl::Cord(large),      
302        std::string(huge), absl::string_view(huge), FlatCord(huge),           
303        FragmentedCord(huge))));
304    const WrapInTuple t{};
305    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(  
306        t(std::string()), t(absl::string_view()), t(absl::Cord()),            
307        t(std::string("")), t(absl::string_view("")), t(absl::Cord("")),      
308        t(std::string(small)), t(absl::string_view(small)),                   
309            t(absl::Cord(small)),                                             
310        t(std::string(dup)), t(absl::string_view(dup)), t(absl::Cord(dup)),   
311        t(std::string(large)), t(absl::string_view(large)),                   
312            t(absl::Cord(large)),                                             
313        t(std::string(huge)), t(absl::string_view(huge)),                     
314            t(FlatCord(huge)), t(FragmentedCord(huge)))));
315    EXPECT_NE(SpyHash(static_cast<const char*>("ABC")),
316              SpyHash(absl::string_view("ABC")));
317  }
318  TEST(HashValueTest, WString) {
319    EXPECT_TRUE((is_hashable<std::wstring>::value));
320    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
321        std::wstring(), std::wstring(L"ABC"), std::wstring(L"ABC"),
322        std::wstring(L"Some other different string"),
323        std::wstring(L"Iñtërnâtiônàlizætiøn"))));
324  }
325  TEST(HashValueTest, U16String) {
326    EXPECT_TRUE((is_hashable<std::u16string>::value));
327    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
328        std::u16string(), std::u16string(u"ABC"), std::u16string(u"ABC"),
329        std::u16string(u"Some other different string"),
330        std::u16string(u"Iñtërnâtiônàlizætiøn"))));
331  }
332  TEST(HashValueTest, U32String) {
333    EXPECT_TRUE((is_hashable<std::u32string>::value));
334    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
335        std::u32string(), std::u32string(U"ABC"), std::u32string(U"ABC"),
336        std::u32string(U"Some other different string"),
337        std::u32string(U"Iñtërnâtiônàlizætiøn"))));
338  }
339  TEST(HashValueTest, WStringView) {
340  #ifndef ABSL_HAVE_STD_STRING_VIEW
341    GTEST_SKIP();
342  #else
343    EXPECT_TRUE((is_hashable<std::wstring_view>::value));
344    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
345        std::wstring_view(), std::wstring_view(L"ABC"), std::wstring_view(L"ABC"),
346        std::wstring_view(L"Some other different string_view"),
347        std::wstring_view(L"Iñtërnâtiônàlizætiøn"))));
348  #endif
349  }
350  TEST(HashValueTest, U16StringView) {
351  #ifndef ABSL_HAVE_STD_STRING_VIEW
352    GTEST_SKIP();
353  #else
354    EXPECT_TRUE((is_hashable<std::u16string_view>::value));
355    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
356        std::make_tuple(std::u16string_view(), std::u16string_view(u"ABC"),
357                        std::u16string_view(u"ABC"),
358                        std::u16string_view(u"Some other different string_view"),
359                        std::u16string_view(u"Iñtërnâtiônàlizætiøn"))));
360  #endif
361  }
362  TEST(HashValueTest, U32StringView) {
363  #ifndef ABSL_HAVE_STD_STRING_VIEW
<span onclick='openModal()' class='match'>364    GTEST_SKIP();
365  #else
366    EXPECT_TRUE((is_hashable<std::u32string_view>::value));
367    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
368        std::make_tuple(std::u32string_view(), std::u32string_view(U"ABC"),
369                        std::u32string_view(U"ABC"),
370                        std::u32string_view(U"Some other different string_view"),
371                        std::u32string_view(U"Iñtërnâtiônàlizætiøn"))));
</span>372  #endif
373  }
374  TEST(HashValueTest, StdArray) {
375    EXPECT_TRUE((is_hashable<std::array<int, 3>>::value));
376    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
377        std::make_tuple(std::array<int, 3>{}, std::array<int, 3>{{0, 23, 42}})));
378  }
379  TEST(HashValueTest, StdBitset) {
380    EXPECT_TRUE((is_hashable<std::bitset<257>>::value));
381    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
382        {std::bitset<2>("00"), std::bitset<2>("01"), std::bitset<2>("10"),
383         std::bitset<2>("11")}));
384    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
385        {std::bitset<5>("10101"), std::bitset<5>("10001"), std::bitset<5>()}));
386    constexpr int kNumBits = 256;
387    std::array<std::string, 6> bit_strings;
388    bit_strings.fill(std::string(kNumBits, '1'));
389    bit_strings[1][0] = '0';
390    bit_strings[2][1] = '0';
391    bit_strings[3][kNumBits / 3] = '0';
392    bit_strings[4][kNumBits - 2] = '0';
393    bit_strings[5][kNumBits - 1] = '0';
394    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
395        {std::bitset<kNumBits>(bit_strings[0].c_str()),
396         std::bitset<kNumBits>(bit_strings[1].c_str()),
397         std::bitset<kNumBits>(bit_strings[2].c_str()),
398         std::bitset<kNumBits>(bit_strings[3].c_str()),
399         std::bitset<kNumBits>(bit_strings[4].c_str()),
400         std::bitset<kNumBits>(bit_strings[5].c_str())}));
401  }  
402  struct Private {
403    int i;
404    template <typename H>
405    friend H AbslHashValue(H h, Private p) {
406      return H::combine(std::move(h), std::abs(p.i));
407    }
408    friend bool operator==(Private a, Private b) {
409      return std::abs(a.i) == std::abs(b.i);
410    }
411    friend std::ostream& operator<<(std::ostream& o, Private p) {
412      return o << p.i;
413    }
414  };
415  class PiecewiseHashTester {
416   public:
417    explicit PiecewiseHashTester(absl::string_view buf)
418        : buf_(buf), piecewise_(false), split_locations_() {}
419    PiecewiseHashTester(absl::string_view buf, std::set<size_t> split_locations)
420        : buf_(buf),
421          piecewise_(true),
422          split_locations_(std::move(split_locations)) {}
423    template <typename H>
424    friend H AbslHashValue(H h, const PiecewiseHashTester& p) {
425      if (!p.piecewise_) {
426        return H::combine_contiguous(std::move(h), p.buf_.data(), p.buf_.size());
427      }
428      absl::hash_internal::PiecewiseCombiner combiner;
429      if (p.split_locations_.empty()) {
430        h = combiner.add_buffer(std::move(h), p.buf_.data(), p.buf_.size());
431        return combiner.finalize(std::move(h));
432      }
433      size_t begin = 0;
434      for (size_t next : p.split_locations_) {
435        absl::string_view chunk = p.buf_.substr(begin, next - begin);
436        h = combiner.add_buffer(std::move(h), chunk.data(), chunk.size());
437        begin = next;
438      }
439      absl::string_view last_chunk = p.buf_.substr(begin);
440      if (!last_chunk.empty()) {
441        h = combiner.add_buffer(std::move(h), last_chunk.data(),
442                                last_chunk.size());
443      }
444      return combiner.finalize(std::move(h));
445    }
446   private:
447    absl::string_view buf_;
448    bool piecewise_;
449    std::set<size_t> split_locations_;
450  };
451  struct DummyFooBar {
452    template <typename H>
453    friend H AbslHashValue(H h, const DummyFooBar&) {
454      const char* foo = "foo";
455      const char* bar = "bar";
456      h = H::combine_contiguous(std::move(h), foo, 3);
457      h = H::combine_contiguous(std::move(h), bar, 3);
458      return h;
459    }
460  };
461  TEST(HashValueTest, CombinePiecewiseBuffer) {
462    absl::Hash<PiecewiseHashTester> hash;
463    EXPECT_EQ(hash(PiecewiseHashTester("")), hash(PiecewiseHashTester("", {})));
464    EXPECT_EQ(hash(PiecewiseHashTester("foobar")),
465              hash(PiecewiseHashTester("foobar", {})));
466    EXPECT_EQ(hash(PiecewiseHashTester("foobar")),
467              hash(PiecewiseHashTester("foobar", {3})));
468    EXPECT_NE(hash(PiecewiseHashTester("foobar", {3})),
469              absl::Hash<DummyFooBar>()(DummyFooBar{}));
470    for (size_t big_buffer_size : {1024u * 2 + 512u, 1024u * 3}) {
471      SCOPED_TRACE(big_buffer_size);
472      std::string big_buffer;
473      for (size_t i = 0; i < big_buffer_size; ++i) {
474        big_buffer.push_back(32 + (i * (i / 3)) % 64);
475      }
476      auto big_buffer_hash = hash(PiecewiseHashTester(big_buffer));
477      const int possible_breaks = 9;
478      size_t breaks[possible_breaks] = {1,    512,  1023, 1024, 1025,
479                                        1536, 2047, 2048, 2049};
480      for (unsigned test_mask = 0; test_mask < (1u << possible_breaks);
481           ++test_mask) {
482        SCOPED_TRACE(test_mask);
483        std::set<size_t> break_locations;
484        for (int j = 0; j < possible_breaks; ++j) {
485          if (test_mask & (1u << j)) {
486            break_locations.insert(breaks[j]);
487          }
488        }
489        EXPECT_EQ(
490            hash(PiecewiseHashTester(big_buffer, std::move(break_locations))),
491            big_buffer_hash);
492      }
493    }
494  }
495  TEST(HashValueTest, PrivateSanity) {
496    EXPECT_TRUE(is_hashable<Private>::value);
497    EXPECT_NE(SpyHash(Private{0}), SpyHash(Private{1}));
498    EXPECT_EQ(SpyHash(Private{1}), SpyHash(Private{1}));
499  }
500  TEST(HashValueTest, Optional) {
501    EXPECT_TRUE(is_hashable<absl::optional<Private>>::value);
502    using O = absl::optional<Private>;
503    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
504        std::make_tuple(O{}, O{{1}}, O{{-1}}, O{{10}})));
505  }
506  TEST(HashValueTest, Variant) {
507    using V = absl::variant<Private, std::string>;
508    EXPECT_TRUE(is_hashable<V>::value);
509    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
510        V(Private{1}), V(Private{-1}), V(Private{2}), V("ABC"), V("BCD"))));
511  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
512    struct S {};
513    EXPECT_FALSE(is_hashable<absl::variant<S>>::value);
514  #endif
515  }
516  TEST(HashValueTest, ReferenceWrapper) {
517    EXPECT_TRUE(is_hashable<std::reference_wrapper<Private>>::value);
518    Private p1{1}, p10{10};
519    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
520        p1, p10, std::ref(p1), std::ref(p10), std::cref(p1), std::cref(p10))));
521    EXPECT_TRUE(is_hashable<std::reference_wrapper<int>>::value);
522    int one = 1, ten = 10;
523    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
524        one, ten, std::ref(one), std::ref(ten), std::cref(one), std::cref(ten))));
525    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
526        std::make_tuple(std::tuple<std::reference_wrapper<int>>(std::ref(one)),
527                        std::tuple<std::reference_wrapper<int>>(std::ref(ten)),
528                        std::tuple<int>(one), std::tuple<int>(ten))));
529  }
530  template <typename T, typename = void>
531  struct IsHashCallable : std::false_type {};
532  template <typename T>
533  struct IsHashCallable<T, absl::void_t<decltype(std::declval<absl::Hash<T>>()(
534                              std::declval<const T&>()))>> : std::true_type {};
535  template <typename T, typename = void>
536  struct IsAggregateInitializable : std::false_type {};
537  template <typename T>
538  struct IsAggregateInitializable<T, absl::void_t<decltype(T{})>>
539      : std::true_type {};
540  TEST(IsHashableTest, ValidHash) {
541    EXPECT_TRUE((is_hashable<int>::value));
542    EXPECT_TRUE(std::is_default_constructible<absl::Hash<int>>::value);
543    EXPECT_TRUE(std::is_copy_constructible<absl::Hash<int>>::value);
544    EXPECT_TRUE(std::is_move_constructible<absl::Hash<int>>::value);
545    EXPECT_TRUE(absl::is_copy_assignable<absl::Hash<int>>::value);
546    EXPECT_TRUE(absl::is_move_assignable<absl::Hash<int>>::value);
547    EXPECT_TRUE(IsHashCallable<int>::value);
548    EXPECT_TRUE(IsAggregateInitializable<absl::Hash<int>>::value);
549  }
550  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
551  TEST(IsHashableTest, PoisonHash) {
552    struct X {};
553    EXPECT_FALSE((is_hashable<X>::value));
554    EXPECT_FALSE(std::is_default_constructible<absl::Hash<X>>::value);
555    EXPECT_FALSE(std::is_copy_constructible<absl::Hash<X>>::value);
556    EXPECT_FALSE(std::is_move_constructible<absl::Hash<X>>::value);
557    EXPECT_FALSE(absl::is_copy_assignable<absl::Hash<X>>::value);
558    EXPECT_FALSE(absl::is_move_assignable<absl::Hash<X>>::value);
559    EXPECT_FALSE(IsHashCallable<X>::value);
560  #if !defined(__GNUC__) || defined(__clang__)
561    EXPECT_FALSE(IsAggregateInitializable<absl::Hash<X>>::value);
562  #endif
563  }
564  #endif  
565  struct NoOp {
566    template <typename HashCode>
567    friend HashCode AbslHashValue(HashCode h, NoOp n) {
568      return h;
569    }
570  };
571  struct EmptyCombine {
572    template <typename HashCode>
573    friend HashCode AbslHashValue(HashCode h, EmptyCombine e) {
574      return HashCode::combine(std::move(h));
575    }
576  };
577  template <typename Int>
578  struct CombineIterative {
579    template <typename HashCode>
580    friend HashCode AbslHashValue(HashCode h, CombineIterative c) {
581      for (int i = 0; i < 5; ++i) {
582        h = HashCode::combine(std::move(h), Int(i));
583      }
584      return h;
585    }
586  };
587  template <typename Int>
588  struct CombineVariadic {
589    template <typename HashCode>
590    friend HashCode AbslHashValue(HashCode h, CombineVariadic c) {
591      return HashCode::combine(std::move(h), Int(0), Int(1), Int(2), Int(3),
592                               Int(4));
593    }
594  };
595  enum class InvokeTag {
596    kUniquelyRepresented,
597    kHashValue,
598  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
599    kLegacyHash,
600  #endif  
601    kStdHash,
602    kNone
603  };
604  template <InvokeTag T>
605  using InvokeTagConstant = std::integral_constant<InvokeTag, T>;
606  template <InvokeTag... Tags>
607  struct MinTag;
608  template <InvokeTag a, InvokeTag b, InvokeTag... Tags>
609  struct MinTag<a, b, Tags...> : MinTag<(a < b ? a : b), Tags...> {};
610  template <InvokeTag a>
611  struct MinTag<a> : InvokeTagConstant<a> {};
612  template <InvokeTag... Tags>
613  struct CustomHashType {
614    explicit CustomHashType(size_t val) : value(val) {}
615    size_t value;
616  };
617  template <InvokeTag allowed, InvokeTag... tags>
618  struct EnableIfContained
619      : std::enable_if<absl::disjunction<
620            std::integral_constant<bool, allowed == tags>...>::value> {};
621  template <
622      typename H, InvokeTag... Tags,
623      typename = typename EnableIfContained<InvokeTag::kHashValue, Tags...>::type>
624  H AbslHashValue(H state, CustomHashType<Tags...> t) {
625    static_assert(MinTag<Tags...>::value == InvokeTag::kHashValue, "");
626    return H::combine(std::move(state),
627                      t.value + static_cast<int>(InvokeTag::kHashValue));
628  }
629  }  
630  namespace absl {
631  ABSL_NAMESPACE_BEGIN
632  namespace hash_internal {
633  template <InvokeTag... Tags>
634  struct is_uniquely_represented<
635      CustomHashType<Tags...>,
636      typename EnableIfContained<InvokeTag::kUniquelyRepresented, Tags...>::type>
637      : std::true_type {};
638  }  
639  ABSL_NAMESPACE_END
640  }  
641  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
642  namespace ABSL_INTERNAL_LEGACY_HASH_NAMESPACE {
643  template <InvokeTag... Tags>
644  struct hash<CustomHashType<Tags...>> {
645    template <InvokeTag... TagsIn, typename = typename EnableIfContained<
646                                       InvokeTag::kLegacyHash, TagsIn...>::type>
647    size_t operator()(CustomHashType<TagsIn...> t) const {
648      static_assert(MinTag<Tags...>::value == InvokeTag::kLegacyHash, "");
649      return t.value + static_cast<int>(InvokeTag::kLegacyHash);
650    }
651  };
652  }  
653  #endif  
654  namespace std {
655  template <InvokeTag... Tags>  
656  struct hash<CustomHashType<Tags...>> {
657    template <InvokeTag... TagsIn, typename = typename EnableIfContained<
658                                       InvokeTag::kStdHash, TagsIn...>::type>
659    size_t operator()(CustomHashType<TagsIn...> t) const {
660      static_assert(MinTag<Tags...>::value == InvokeTag::kStdHash, "");
661      return t.value + static_cast<int>(InvokeTag::kStdHash);
662    }
663  };
664  }  
665  namespace {
666  template <typename... T>
667  void TestCustomHashType(InvokeTagConstant<InvokeTag::kNone>, T...) {
668    using type = CustomHashType<T::value...>;
669    SCOPED_TRACE(testing::PrintToString(std::vector<InvokeTag>{T::value...}));
670    EXPECT_TRUE(is_hashable<type>());
671    EXPECT_TRUE(is_hashable<const type>());
672    EXPECT_TRUE(is_hashable<const type&>());
673    const size_t offset = static_cast<int>(std::min({T::value...}));
674    EXPECT_EQ(SpyHash(type(7)), SpyHash(size_t{7 + offset}));
675  }
676  void TestCustomHashType(InvokeTagConstant<InvokeTag::kNone>) {
677  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
678    using type = CustomHashType<>;
679    EXPECT_FALSE(is_hashable<type>());
680    EXPECT_FALSE(is_hashable<const type>());
681    EXPECT_FALSE(is_hashable<const type&>());
682  #endif  
683  }
684  template <InvokeTag Tag, typename... T>
685  void TestCustomHashType(InvokeTagConstant<Tag> tag, T... t) {
686    constexpr auto next = static_cast<InvokeTag>(static_cast<int>(Tag) + 1);
687    TestCustomHashType(InvokeTagConstant<next>(), tag, t...);
688    TestCustomHashType(InvokeTagConstant<next>(), t...);
689  }
690  TEST(HashTest, CustomHashType) {
691    TestCustomHashType(InvokeTagConstant<InvokeTag{}>());
692  }
693  TEST(HashTest, NoOpsAreEquivalent) {
694    EXPECT_EQ(Hash<NoOp>()({}), Hash<NoOp>()({}));
695    EXPECT_EQ(Hash<NoOp>()({}), Hash<EmptyCombine>()({}));
696  }
697  template <typename T>
698  class HashIntTest : public testing::Test {
699  };
700  TYPED_TEST_SUITE_P(HashIntTest);
701  TYPED_TEST_P(HashIntTest, BasicUsage) {
702    EXPECT_NE(Hash<NoOp>()({}), Hash<TypeParam>()(0));
703    EXPECT_NE(Hash<NoOp>()({}),
704              Hash<TypeParam>()(std::numeric_limits<TypeParam>::max()));
705    if (std::numeric_limits<TypeParam>::min() != 0) {
706      EXPECT_NE(Hash<NoOp>()({}),
707                Hash<TypeParam>()(std::numeric_limits<TypeParam>::min()));
708    }
709    EXPECT_EQ(Hash<CombineIterative<TypeParam>>()({}),
710              Hash<CombineVariadic<TypeParam>>()({}));
711  }
712  REGISTER_TYPED_TEST_SUITE_P(HashIntTest, BasicUsage);
713  using IntTypes = testing::Types<unsigned char, char, int, int32_t, int64_t,
714                                  uint32_t, uint64_t, size_t>;
715  INSTANTIATE_TYPED_TEST_SUITE_P(My, HashIntTest, IntTypes);
716  struct StructWithPadding {
717    char c;
718    int i;
719    template <typename H>
720    friend H AbslHashValue(H hash_state, const StructWithPadding& s) {
721      return H::combine(std::move(hash_state), s.c, s.i);
722    }
723  };
724  static_assert(sizeof(StructWithPadding) > sizeof(char) + sizeof(int),
725                "StructWithPadding doesn't have padding");
726  static_assert(std::is_standard_layout<StructWithPadding>::value, "");
727  template <typename T>
728  struct ArraySlice {
729    T* begin;
730    T* end;
731    template <typename H>
732    friend H AbslHashValue(H hash_state, const ArraySlice& slice) {
733      for (auto t = slice.begin; t != slice.end; ++t) {
734        hash_state = H::combine(std::move(hash_state), *t);
735      }
736      return hash_state;
737    }
738  };
739  TEST(HashTest, HashNonUniquelyRepresentedType) {
740    static const size_t kNumStructs = 10;
741    unsigned char buffer1[kNumStructs * sizeof(StructWithPadding)];
742    std::memset(buffer1, 0, sizeof(buffer1));
743    auto* s1 = reinterpret_cast<StructWithPadding*>(buffer1);
744    unsigned char buffer2[kNumStructs * sizeof(StructWithPadding)];
745    std::memset(buffer2, 255, sizeof(buffer2));
746    auto* s2 = reinterpret_cast<StructWithPadding*>(buffer2);
747    for (size_t i = 0; i < kNumStructs; ++i) {
748      SCOPED_TRACE(i);
749      s1[i].c = s2[i].c = static_cast<char>('0' + i);
750      s1[i].i = s2[i].i = static_cast<int>(i);
751      ASSERT_FALSE(memcmp(buffer1 + i * sizeof(StructWithPadding),
752                          buffer2 + i * sizeof(StructWithPadding),
753                          sizeof(StructWithPadding)) == 0)
754          << "Bug in test code: objects do not have unequal"
755          << " object representations";
756    }
757    EXPECT_EQ(Hash<StructWithPadding>()(s1[0]), Hash<StructWithPadding>()(s2[0]));
758    EXPECT_EQ(Hash<ArraySlice<StructWithPadding>>()({s1, s1 + kNumStructs}),
759              Hash<ArraySlice<StructWithPadding>>()({s2, s2 + kNumStructs}));
760  }
761  TEST(HashTest, StandardHashContainerUsage) {
762    std::unordered_map<int, std::string, Hash<int>> map = {{0, "foo"},
763                                                           {42, "bar"}};
764    EXPECT_NE(map.find(0), map.end());
765    EXPECT_EQ(map.find(1), map.end());
766    EXPECT_NE(map.find(0u), map.end());
767  }
768  struct ConvertibleFromNoOp {
769    ConvertibleFromNoOp(NoOp) {}  
770    template <typename H>
771    friend H AbslHashValue(H hash_state, ConvertibleFromNoOp) {
772      return H::combine(std::move(hash_state), 1);
773    }
774  };
775  TEST(HashTest, HeterogeneousCall) {
776    EXPECT_NE(Hash<ConvertibleFromNoOp>()(NoOp()),
777              Hash<NoOp>()(NoOp()));
778  }
779  TEST(IsUniquelyRepresentedTest, SanityTest) {
780    using absl::hash_internal::is_uniquely_represented;
781    EXPECT_TRUE(is_uniquely_represented<unsigned char>::value);
782    EXPECT_TRUE(is_uniquely_represented<int>::value);
783    EXPECT_FALSE(is_uniquely_represented<bool>::value);
784    EXPECT_FALSE(is_uniquely_represented<int*>::value);
785  }
786  struct IntAndString {
787    int i;
788    std::string s;
789    template <typename H>
790    friend H AbslHashValue(H hash_state, IntAndString int_and_string) {
791      return H::combine(std::move(hash_state), int_and_string.s,
792                        int_and_string.i);
793    }
794  };
795  TEST(HashTest, SmallValueOn64ByteBoundary) {
796    Hash<IntAndString>()(IntAndString{0, std::string(63, '0')});
797  }
798  TEST(HashTest, TypeErased) {
799    EXPECT_TRUE((is_hashable<TypeErasedValue<size_t>>::value));
800    EXPECT_TRUE((is_hashable<std::pair<TypeErasedValue<size_t>, int>>::value));
801    EXPECT_EQ(SpyHash(TypeErasedValue<size_t>(7)), SpyHash(size_t{7}));
802    EXPECT_NE(SpyHash(TypeErasedValue<size_t>(7)), SpyHash(size_t{13}));
803    EXPECT_EQ(SpyHash(std::make_pair(TypeErasedValue<size_t>(7), 17)),
804              SpyHash(std::make_pair(size_t{7}, 17)));
805    absl::flat_hash_set<absl::flat_hash_set<int>> ss = {{1, 2}, {3, 4}};
806    TypeErasedContainer<absl::flat_hash_set<absl::flat_hash_set<int>>> es = {
807        absl::flat_hash_set<int>{1, 2}, {3, 4}};
808    absl::flat_hash_set<TypeErasedContainer<absl::flat_hash_set<int>>> se = {
809        {1, 2}, {3, 4}};
810    EXPECT_EQ(SpyHash(ss), SpyHash(es));
811    EXPECT_EQ(SpyHash(ss), SpyHash(se));
812  }
813  struct ValueWithBoolConversion {
814    operator bool() const { return false; }
815    int i;
816  };
817  }  
818  namespace std {
819  template <>
820  struct hash<ValueWithBoolConversion> {
821    size_t operator()(ValueWithBoolConversion v) {
822      return static_cast<size_t>(v.i);
823    }
824  };
825  }  
826  namespace {
827  TEST(HashTest, DoesNotUseImplicitConversionsToBool) {
828    EXPECT_NE(absl::Hash<ValueWithBoolConversion>()(ValueWithBoolConversion{0}),
829              absl::Hash<ValueWithBoolConversion>()(ValueWithBoolConversion{1}));
830  }
831  TEST(HashOf, MatchesHashForSingleArgument) {
832    std::string s = "forty two";
833    double d = 42.0;
834    std::tuple<int, int> t{4, 2};
835    int i = 42;
836    int neg_i = -42;
837    int16_t i16 = 42;
838    int16_t neg_i16 = -42;
839    int8_t i8 = 42;
840    int8_t neg_i8 = -42;
841    EXPECT_EQ(absl::HashOf(s), absl::Hash<std::string>{}(s));
842    EXPECT_EQ(absl::HashOf(d), absl::Hash<double>{}(d));
843    EXPECT_EQ(absl::HashOf(t), (absl::Hash<std::tuple<int, int>>{}(t)));
844    EXPECT_EQ(absl::HashOf(i), absl::Hash<int>{}(i));
845    EXPECT_EQ(absl::HashOf(neg_i), absl::Hash<int>{}(neg_i));
846    EXPECT_EQ(absl::HashOf(i16), absl::Hash<int16_t>{}(i16));
847    EXPECT_EQ(absl::HashOf(neg_i16), absl::Hash<int16_t>{}(neg_i16));
848    EXPECT_EQ(absl::HashOf(i8), absl::Hash<int8_t>{}(i8));
849    EXPECT_EQ(absl::HashOf(neg_i8), absl::Hash<int8_t>{}(neg_i8));
850  }
851  TEST(HashOf, MatchesHashOfTupleForMultipleArguments) {
852    std::string hello = "hello";
853    std::string world = "world";
854    EXPECT_EQ(absl::HashOf(), absl::HashOf(std::make_tuple()));
855    EXPECT_EQ(absl::HashOf(hello), absl::HashOf(std::make_tuple(hello)));
856    EXPECT_EQ(absl::HashOf(hello, world),
857              absl::HashOf(std::make_tuple(hello, world)));
858  }
859  template <typename T>
860  std::true_type HashOfExplicitParameter(decltype(absl::HashOf<T>(0))) {
861    return {};
862  }
863  template <typename T>
864  std::false_type HashOfExplicitParameter(size_t) {
865    return {};
866  }
867  TEST(HashOf, CantPassExplicitTemplateParameters) {
868    EXPECT_FALSE(HashOfExplicitParameter<int>(0));
869  }
870  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>195    EXPECT_EQ(ToFloat("789.e-35"), ldexpf(10739312, -130));
196    EXPECT_EQ(ToFloat("2539.e-18"), ldexpf(11990089, -72));
197    EXPECT_EQ(ToFloat("76173.e28"), ldexpf(9845130, 86));
198    EXPECT_EQ(ToFloat("887745.e-11"), ldexpf(9760860, -40));
199    EXPECT_EQ(ToFloat("5382571.e-37"), ldexpf(11447463, -124));
</pre></code></div>
                <div class="column column_space"><pre><code>364    GTEST_SKIP();
365  #else
366    EXPECT_TRUE((is_hashable<std::u32string_view>::value));
367    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
368        std::make_tuple(std::u32string_view(), std::u32string_view(U"ABC"),
369                        std::u32string_view(U"ABC"),
370                        std::u32string_view(U"Some other different string_view"),
371                        std::u32string_view(U"Iñtërnâtiônàlizætiøn"))));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    