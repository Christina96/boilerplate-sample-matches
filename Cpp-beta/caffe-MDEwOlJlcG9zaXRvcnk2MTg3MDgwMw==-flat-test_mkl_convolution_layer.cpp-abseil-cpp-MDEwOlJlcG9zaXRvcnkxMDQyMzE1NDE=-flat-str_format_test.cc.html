
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.626311541565777%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_convolution_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkl_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  void caffe_conv(const Blob<Dtype>* in, ConvolutionParameter* conv_param,
13      const vector<shared_ptr<Blob<Dtype> > >& weights,
14      Blob<Dtype>* out) {
15    const bool has_depth = (out->num_axes() == 5);
16    if (!has_depth) { CHECK_EQ(4, out->num_axes()); }
17    int kernel_h, kernel_w;
18    if (conv_param->has_kernel_h() || conv_param->has_kernel_w()) {
19      kernel_h = conv_param->kernel_h();
20      kernel_w = conv_param->kernel_w();
21    } else {
22      kernel_h = kernel_w = conv_param->kernel_size(0);
23    }
24    int pad_h, pad_w;
25    if (conv_param->has_pad_h() || conv_param->has_pad_w()) {
26      pad_h = conv_param->pad_h();
27      pad_w = conv_param->pad_w();
28    } else {
29      pad_h = pad_w = conv_param->pad_size() ? conv_param->pad(0) : 0;
30    }
31    int stride_h, stride_w;
32    if (conv_param->has_stride_h() || conv_param->has_stride_w()) {
33      stride_h = conv_param->stride_h();
34      stride_w = conv_param->stride_w();
35    } else {
36      stride_h = stride_w = conv_param->stride_size() ? conv_param->stride(0) : 1;
37    }
38    int dilation_h, dilation_w;
39    dilation_h = dilation_w = conv_param->dilation_size() ?
40                              conv_param->dilation(0) : 1;
41    int kernel_d, pad_d, stride_d, dilation_d;
42    if (has_depth) {
43      kernel_d = kernel_h;
44      stride_d = stride_h;
45      pad_d = pad_h;
46      dilation_d = dilation_h;
47    } else {
48      kernel_d = stride_d = dilation_d = 1;
49      pad_d = 0;
50    }
51    int groups = conv_param->group();
52    int o_g = out->shape(1) / groups;
53    int k_g = in->shape(1) / groups;
54    int o_head, k_head;
55    vector<int> weight_offset(4 + has_depth);
56    vector<int> in_offset(4 + has_depth);
57    vector<int> out_offset(4 + has_depth);
58    Dtype* out_data = out->mutable_cpu_data();
59    for (int n = 0; n < out->shape(0); n++) {
60      for (int g = 0; g < groups; g++) {
61        o_head = o_g * g;
62        k_head = k_g * g;
63        for (int o = 0; o < o_g; o++) {
64          for (int k = 0; k < k_g; k++) {
65            for (int z = 0; z < (has_depth ? out->shape(2) : 1); z++) {
66              for (int y = 0; y < out->shape(2 + has_depth); y++) {
67                for (int x = 0; x < out->shape(3 + has_depth); x++) {
68                  for (int r = 0; r < kernel_d; r++) {
69                    for (int p = 0; p < kernel_h; p++) {
70                      for (int q = 0; q < kernel_w; q++) {
71                        int in_z = z * stride_d - pad_d + r * dilation_d;
72                        int in_y = y * stride_h - pad_h + p * dilation_h;
73                        int in_x = x * stride_w - pad_w + q * dilation_w;
74                        if (in_z >= 0 && in_z < (has_depth ? in->shape(2) : 1)
75                            && in_y >= 0 && in_y < in->shape(2 + has_depth)
76                            && in_x >= 0 && in_x < in->shape(3 + has_depth)) {
77                          weight_offset[0] = o + o_head;
78                          weight_offset[1] = k;
79                          if (has_depth) { weight_offset[2] = r; }
80                          weight_offset[2 + has_depth] = p;
81                          weight_offset[3 + has_depth] = q;
82                          in_offset[0] = n;
83                          in_offset[1] = k + k_head;
84                          if (has_depth) { in_offset[2] = in_z; }
85                          in_offset[2 + has_depth] = in_y;
86                          in_offset[3 + has_depth] = in_x;
87                          out_offset[0] = n;
88                          out_offset[1] = o + o_head;
89                          if (has_depth) { out_offset[2] = z; }
90                          out_offset[2 + has_depth] = y;
91                          out_offset[3 + has_depth] = x;
92                          out_data[out->offset(out_offset)] +=
93                              in->data_at(in_offset)
94                              * weights[0]->data_at(weight_offset);
95                        }
96                      }
97                    }
98                  }
99                }
100              }
101            }
102          }
103        }
104      }
105    }
106    if (conv_param->bias_term()) {
107      const Dtype* bias_data = weights[1]->cpu_data();
108      for (int n = 0; n < out->shape(0); n++) {
109        for (int o = 0; o < out->shape(1); o++) {
110          for (int z = 0; z < (has_depth ? out->shape(2) : 1); z++) {
111            for (int y = 0; y < out->shape(2 + has_depth); y++) {
112              for (int x = 0; x < out->shape(3 + has_depth); x++) {
113                out_offset[0] = n;
114                out_offset[1] = o;
115                if (has_depth) { out_offset[2] = z; }
116                out_offset[2 + has_depth] = y;
117                out_offset[3 + has_depth] = x;
118                out_data[out->offset(out_offset)] += bias_data[o];
119              }
120            }
121          }
122        }
123      }
124    }
125    if (conv_param->relu()) {
126      for (int n = 0; n < out->shape(0); n++) {
127        for (int o = 0; o < out->shape(1); o++) {
128          for (int z = 0; z < (has_depth ? out->shape(2) : 1); z++) {
129            for (int y = 0; y < out->shape(2 + has_depth); y++) {
130              for (int x = 0; x < out->shape(3 + has_depth); x++) {
131                out_offset[0] = n;
132                out_offset[1] = o;
133                if (has_depth) { out_offset[2] = z; }
134                out_offset[2 + has_depth] = y;
135                out_offset[3 + has_depth] = x;
136                if(out_data[out->offset(out_offset)] < 0) out_data[out->offset(out_offset)] = 0;
137              }
138            }
139          }
140        }
141      }
142    }
143  }
144  template void caffe_conv(const Blob<float>* in,
145      ConvolutionParameter* conv_param,
146      const vector<shared_ptr<Blob<float> > >& weights,
147      Blob<float>* out);
148  template void caffe_conv(const Blob<double>* in,
149      ConvolutionParameter* conv_param,
150      const vector<shared_ptr<Blob<double> > >& weights,
151      Blob<double>* out);
152  template <typename TypeParam>
153  class MKLConvolutionLayerTest : public MultiDeviceTest<TypeParam> {
154    typedef typename TypeParam::Dtype Dtype;
155   protected:
156    MKLConvolutionLayerTest()
157        : blob_bottom_(new Blob<Dtype>(2, 3, 6, 4)),
158          blob_bottom_2_(new Blob<Dtype>(2, 3, 6, 4)),
159          blob_top_(new Blob<Dtype>()),
160          blob_top_2_(new Blob<Dtype>()) {}
161    virtual void SetUp() {
162      FillerParameter filler_param;
163      filler_param.set_value(1.);
164      GaussianFiller<Dtype> filler(filler_param);
165      filler.Fill(this->blob_bottom_);
166      filler.Fill(this->blob_bottom_2_);
167      blob_bottom_vec_.push_back(blob_bottom_);
168      blob_top_vec_.push_back(blob_top_);
169    }
170    virtual ~MKLConvolutionLayerTest() {
171      delete blob_bottom_;
172      delete blob_bottom_2_;
173      delete blob_top_;
174      delete blob_top_2_;
175    }
176    virtual Blob<Dtype>* MakeReferenceTop(Blob<Dtype>* top) {
177      this->ref_blob_top_.reset(new Blob<Dtype>());
178      this->ref_blob_top_->ReshapeLike(*top);
179      return this->ref_blob_top_.get();
180    }
181    Blob<Dtype>* const blob_bottom_;
182    Blob<Dtype>* const blob_bottom_2_;
183    Blob<Dtype>* const blob_top_;
184    Blob<Dtype>* const blob_top_2_;
185    shared_ptr<Blob<Dtype> > ref_blob_top_;
186    vector<Blob<Dtype>*> blob_bottom_vec_;
187    vector<Blob<Dtype>*> blob_top_vec_;
188  };
189  typedef ::testing::Types<CPUDevice<float>,
190                           CPUDevice<double> > TestDtypesCPU;
191  TYPED_TEST_CASE(MKLConvolutionLayerTest, TestDtypesCPU);
<span onclick='openModal()' class='match'>192  TYPED_TEST(MKLConvolutionLayerTest, TestSetupMKL) {
193    typedef typename TypeParam::Dtype Dtype;
194    LayerParameter layer_param;
195    ConvolutionParameter* convolution_param =
196        layer_param.mutable_convolution_param();
197    convolution_param->add_kernel_size(3);
198    convolution_param->add_stride(2);
199    convolution_param->set_num_output(4);
200    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
201    this->blob_top_vec_.push_back(this->blob_top_2_);
</span>202    shared_ptr<Layer<Dtype> > layer(
203        new MKLConvolutionLayer<Dtype>(layer_param));
204    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
205    EXPECT_EQ(this->blob_top_->num(), 2);
206    EXPECT_EQ(this->blob_top_->channels(), 4);
207    EXPECT_EQ(this->blob_top_->height(), 2);
208    EXPECT_EQ(this->blob_top_->width(), 1);
209    EXPECT_EQ(this->blob_top_2_->num(), 2);
210    EXPECT_EQ(this->blob_top_2_->channels(), 4);
211    EXPECT_EQ(this->blob_top_2_->height(), 2);
212    EXPECT_EQ(this->blob_top_2_->width(), 1);
213    convolution_param->set_num_output(3);
214    convolution_param->set_group(3);
215    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
216    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
217    EXPECT_EQ(this->blob_top_->num(), 2);
218    EXPECT_EQ(this->blob_top_->channels(), 3);
219    EXPECT_EQ(this->blob_top_->height(), 2);
220    EXPECT_EQ(this->blob_top_->width(), 1);
221    EXPECT_EQ(this->blob_top_2_->num(), 2);
222    EXPECT_EQ(this->blob_top_2_->channels(), 3);
223    EXPECT_EQ(this->blob_top_2_->height(), 2);
224    EXPECT_EQ(this->blob_top_2_->width(), 1);
225  }
226  TYPED_TEST(MKLConvolutionLayerTest, TestSimpleConvolutionMKL) {
227    typedef typename TypeParam::Dtype Dtype;
228    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
229    this->blob_top_vec_.push_back(this->blob_top_2_);
230    LayerParameter layer_param;
231    ConvolutionParameter* convolution_param =
232        layer_param.mutable_convolution_param();
233    convolution_param->add_kernel_size(3);
234    convolution_param->add_stride(2);
235    convolution_param->set_num_output(4);
236    convolution_param->mutable_weight_filler()->set_type("gaussian");
237    convolution_param->mutable_bias_filler()->set_type("constant");
238    convolution_param->mutable_bias_filler()->set_value(0.1);
239    shared_ptr<Layer<Dtype> > layer(
240        new MKLConvolutionLayer<Dtype>(layer_param));
241    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
242    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
243    const Dtype* top_data;
244    const Dtype* ref_top_data;
245    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
246        this->MakeReferenceTop(this->blob_top_));
247    top_data = this->blob_top_->cpu_data();
248    ref_top_data = this->ref_blob_top_->cpu_data();
249    for (int i = 0; i < this->blob_top_->count(); ++i) {
250      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
251    }
252  #if 0   
253    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
254        this->MakeReferenceTop(this->blob_top_2_));
255    top_data = this->blob_top_2_->cpu_data();
256    ref_top_data = this->ref_blob_top_->cpu_data();
257    for (int i = 0; i < this->blob_top_->count(); ++i) {
258      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
259    }
260  #endif
261  }
262  #if 0
263  TYPED_TEST(MKLConvolutionLayerTest, TestDilatedConvolutionMKL) {
264    typedef typename TypeParam::Dtype Dtype;
265    vector<int> bottom_shape;
266    bottom_shape.push_back(2);
267    bottom_shape.push_back(3);
268    bottom_shape.push_back(8);
269    bottom_shape.push_back(7);
270    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
271    this->blob_top_vec_.push_back(this->blob_top_2_);
272    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
273      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
274    }
275    LayerParameter layer_param;
276    ConvolutionParameter* convolution_param =
277        layer_param.mutable_convolution_param();
278    convolution_param->add_kernel_size(3);
279    convolution_param->add_dilation(2);
280    convolution_param->set_num_output(4);
281    convolution_param->mutable_weight_filler()->set_type("gaussian");
282    convolution_param->mutable_bias_filler()->set_type("constant");
283    convolution_param->mutable_bias_filler()->set_value(0.1);
284    shared_ptr<Layer<Dtype> > layer(
285        new MKLConvolutionLayer<Dtype>(layer_param));
286    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
287    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
288    const Dtype* top_data;
289    const Dtype* ref_top_data;
290    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
291               this->MakeReferenceTop(this->blob_top_));
292    top_data = this->blob_top_->cpu_data();
293    ref_top_data = this->ref_blob_top_->cpu_data();
294    for (int i = 0; i < this->blob_top_->count(); ++i) {
295      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
296    }
297  #if 0   
298    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
299               this->MakeReferenceTop(this->blob_top_2_));
300    top_data = this->blob_top_2_->cpu_data();
301    ref_top_data = this->ref_blob_top_->cpu_data();
302    for (int i = 0; i < this->blob_top_->count(); ++i) {
303      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
304    }
305  #endif
306  }
307  #endif
308  #if 0
309  TYPED_TEST(MKLConvolutionLayerTest, Test0DConvolutionMKL) {
310    typedef typename TypeParam::Dtype Dtype;
311    LayerParameter layer_param;
312    ConvolutionParameter* convolution_param =
313        layer_param.mutable_convolution_param();
314    const int kNumOutput = 3;
315    convolution_param->set_num_output(kNumOutput);
316    convolution_param->set_axis(3);
317    convolution_param->mutable_weight_filler()->set_type("gaussian");
318    convolution_param->mutable_bias_filler()->set_type("gaussian");
319    shared_ptr<Layer<Dtype> > layer(
320        new MKLConvolutionLayer<Dtype>(layer_param));
321    vector<int> top_shape = this->blob_bottom_->shape();
322    top_shape[3] = kNumOutput;
323    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
324    EXPECT_EQ(top_shape, this->blob_top_->shape());
325    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
326    vector<int> weight_offset(2);
327    const Blob<Dtype>* weight = layer->blobs()[0].get();
328    const Blob<Dtype>* bias = layer->blobs()[1].get();
329    const int num = this->blob_top_->count(3);
330    const int dim = this->blob_top_->shape(3);
331    const int bottom_dim = this->blob_bottom_->shape(3);
332    for (int n = 0; n < num; ++n) {
333      for (int d = 0; d < dim; ++d) {
334        weight_offset[0] = d;
335        Dtype value = bias->cpu_data()[d];
336        for (int bottom_d = 0; bottom_d < bottom_dim; ++bottom_d) {
337          weight_offset[1] = bottom_d;
338          value += weight->data_at(weight_offset) *
339                   this->blob_bottom_->cpu_data()[n * bottom_dim + bottom_d];
340        }
341        EXPECT_NEAR(value, this->blob_top_->cpu_data()[n * dim + d], 1e-4);
342      }
343    }
344  }
345  #endif
346  #if 0
347  TYPED_TEST(MKLConvolutionLayerTest, TestSimple3DConvolution) {
348    typedef typename TypeParam::Dtype Dtype;
349    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
350    this->blob_top_vec_.push_back(this->blob_top_2_);
351    vector<int> bottom_shape(5);
352    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
353    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
354    bottom_shape[2] = 5;
355    bottom_shape[3] = this->blob_bottom_vec_[0]->shape(2);
356    bottom_shape[4] = this->blob_bottom_vec_[0]->shape(3);
357    FillerParameter filler_param;
358    GaussianFiller<Dtype> filler(filler_param);
359    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
360      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
361      filler.Fill(this->blob_bottom_vec_[i]);
362    }
363    LayerParameter layer_param;
364    ConvolutionParameter* convolution_param =
365        layer_param.mutable_convolution_param();
366    convolution_param->add_kernel_size(3);
367    convolution_param->add_stride(2);
368    convolution_param->set_num_output(4);
369    convolution_param->mutable_weight_filler()->set_type("gaussian");
370    convolution_param->mutable_bias_filler()->set_type("gaussian");
371    shared_ptr<Layer<Dtype> > layer(
372        new MKLConvolutionLayer<Dtype>(layer_param));
373    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
374    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
375    const Dtype* top_data;
376    const Dtype* ref_top_data;
377    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
378        this->MakeReferenceTop(this->blob_top_));
379    top_data = this->blob_top_->cpu_data();
380    ref_top_data = this->ref_blob_top_->cpu_data();
381    for (int i = 0; i < this->blob_top_->count(); ++i) {
382      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
383    }
384  #if 0   
385    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
386        this->MakeReferenceTop(this->blob_top_2_));
387    top_data = this->blob_top_2_->cpu_data();
388    ref_top_data = this->ref_blob_top_->cpu_data();
389    for (int i = 0; i < this->blob_top_->count(); ++i) {
390      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
391    }
392  #endif
393  }
394  #endif
395  #if 0
396  TYPED_TEST(MKLConvolutionLayerTest, TestDilated3DConvolution) {
397    typedef typename TypeParam::Dtype Dtype;
398    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
399    this->blob_top_vec_.push_back(this->blob_top_2_);
400    vector<int> bottom_shape(5);
401    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
402    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
403    bottom_shape[2] = 6;
404    bottom_shape[3] = 7;
405    bottom_shape[4] = 8;
406    FillerParameter filler_param;
407    GaussianFiller<Dtype> filler(filler_param);
408    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
409      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
410      filler.Fill(this->blob_bottom_vec_[i]);
411    }
412    LayerParameter layer_param;
413    ConvolutionParameter* convolution_param =
414        layer_param.mutable_convolution_param();
415    convolution_param->add_kernel_size(3);
416    convolution_param->add_dilation(2);
417    convolution_param->set_num_output(4);
418    convolution_param->mutable_weight_filler()->set_type("gaussian");
419    convolution_param->mutable_bias_filler()->set_type("gaussian");
420    shared_ptr<Layer<Dtype> > layer(
421        new MKLConvolutionLayer<Dtype>(layer_param));
422    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
423    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
424    const Dtype* top_data;
425    const Dtype* ref_top_data;
426    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
427               this->MakeReferenceTop(this->blob_top_));
428    top_data = this->blob_top_->cpu_data();
429    ref_top_data = this->ref_blob_top_->cpu_data();
430    for (int i = 0; i < this->blob_top_->count(); ++i) {
431      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
432    }
433    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
434               this->MakeReferenceTop(this->blob_top_2_));
435    top_data = this->blob_top_2_->cpu_data();
436    ref_top_data = this->ref_blob_top_->cpu_data();
437    for (int i = 0; i < this->blob_top_->count(); ++i) {
438      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
439    }
440  }
441  #endif
442  TYPED_TEST(MKLConvolutionLayerTest, Test1x1Convolution) {
443    typedef typename TypeParam::Dtype Dtype;
444    LayerParameter layer_param;
445    ConvolutionParameter* convolution_param =
446        layer_param.mutable_convolution_param();
447    convolution_param->add_kernel_size(1);
448    convolution_param->add_stride(1);
449    convolution_param->set_num_output(4);
450    convolution_param->mutable_weight_filler()->set_type("gaussian");
451    convolution_param->mutable_bias_filler()->set_type("constant");
452    convolution_param->mutable_bias_filler()->set_value(0.1);
453    shared_ptr<Layer<Dtype> > layer(
454        new MKLConvolutionLayer<Dtype>(layer_param));
455    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
456    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
457    const Dtype* top_data;
458    const Dtype* ref_top_data;
459    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
460        this->MakeReferenceTop(this->blob_top_));
461    top_data = this->blob_top_->cpu_data();
462    ref_top_data = this->ref_blob_top_->cpu_data();
463    for (int i = 0; i < this->blob_top_->count(); ++i) {
464      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
465    }
466  }
467  TYPED_TEST(MKLConvolutionLayerTest, TestSimpleConvolutionGroup) {
468    typedef typename TypeParam::Dtype Dtype;
469    LayerParameter layer_param;
470    ConvolutionParameter* convolution_param =
471        layer_param.mutable_convolution_param();
472    convolution_param->add_kernel_size(3);
473    convolution_param->add_stride(2);
474    convolution_param->set_num_output(3);
475    convolution_param->set_group(3);
476    convolution_param->mutable_weight_filler()->set_type("gaussian");
477    convolution_param->mutable_bias_filler()->set_type("constant");
478    convolution_param->mutable_bias_filler()->set_value(0.1);
479    shared_ptr<Layer<Dtype> > layer(
480        new MKLConvolutionLayer<Dtype>(layer_param));
481    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
482    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
483    const Dtype* top_data;
484    const Dtype* ref_top_data;
485    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
486        this->MakeReferenceTop(this->blob_top_));
487    top_data = this->blob_top_->cpu_data();
488    ref_top_data = this->ref_blob_top_->cpu_data();
489    for (int i = 0; i < this->blob_top_->count(); ++i) {
490      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
491    }
492  }
493  #if 0
494  TYPED_TEST(MKLConvolutionLayerTest, TestSobelConvolution) {
495    typedef typename TypeParam::Dtype Dtype;
496    shared_ptr<GaussianFiller<Dtype> > filler;
497    FillerParameter filler_param;
498    filler_param.set_value(1.);
499    filler.reset(new GaussianFiller<Dtype>(filler_param));
500    filler->Fill(this->blob_bottom_);
501    this->blob_bottom_2_->CopyFrom(*this->blob_bottom_);
502    LayerParameter layer_param;
503    ConvolutionParameter* convolution_param =
504        layer_param.mutable_convolution_param();
505    convolution_param->add_kernel_size(3);
506    convolution_param->add_stride(2);
507    convolution_param->set_num_output(1);
508    convolution_param->set_bias_term(false);
509    shared_ptr<Layer<Dtype> > layer(
510        new MKLConvolutionLayer<Dtype>(layer_param));
511    layer->blobs().resize(1);
512    layer->blobs()[0].reset(new Blob<Dtype>(1, 3, 3, 3));
513    Dtype* weights = layer->blobs()[0]->mutable_cpu_data();
514    for (int c = 0; c < 3; ++c) {
515      int i = c * 9;  
516      weights[i +  0] = -1;
517      weights[i +  1] =  0;
518      weights[i +  2] =  1;
519      weights[i +  3] = -2;
520      weights[i +  4] =  0;
521      weights[i +  5] =  2;
522      weights[i +  6] = -1;
523      weights[i +  7] =  0;
524      weights[i +  8] =  1;
525    }
526    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
527    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
528    vector<Blob<Dtype>*> sep_blob_bottom_vec;
529    vector<Blob<Dtype>*> sep_blob_top_vec;
530    shared_ptr<Blob<Dtype> > blob_sep(new Blob<Dtype>());
531    sep_blob_bottom_vec.push_back(this->blob_bottom_2_);
532    sep_blob_top_vec.push_back(this->blob_top_2_);
533    convolution_param->clear_kernel_size();
534    convolution_param->clear_stride();
535    convolution_param->set_kernel_h(3);
536    convolution_param->set_kernel_w(1);
537    convolution_param->set_stride_h(2);
538    convolution_param->set_stride_w(1);
539    convolution_param->set_num_output(1);
540    convolution_param->set_bias_term(false);
541    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
542    layer->blobs().resize(1);
543    layer->blobs()[0].reset(new Blob<Dtype>(1, 3, 3, 1));
544    Dtype* weights_1 = layer->blobs()[0]->mutable_cpu_data();
545    for (int c = 0; c < 3; ++c) {
546      int i = c * 3;  
547      weights_1[i +  0] = 1;
548      weights_1[i +  1] = 2;
549      weights_1[i +  2] = 1;
550    }
551    layer->SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
552    layer->Forward(sep_blob_bottom_vec, sep_blob_top_vec);
553    blob_sep->CopyFrom(*this->blob_top_2_, false, true);
554    sep_blob_bottom_vec.clear();
555    sep_blob_bottom_vec.push_back(blob_sep.get());
556    convolution_param->set_kernel_h(1);
557    convolution_param->set_kernel_w(3);
558    convolution_param->set_stride_h(1);
559    convolution_param->set_stride_w(2);
560    convolution_param->set_num_output(1);
561    convolution_param->set_bias_term(false);
562    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
563    layer->blobs().resize(1);
564    layer->blobs()[0].reset(new Blob<Dtype>(1, 1, 1, 3));
565    Dtype* weights_2 = layer->blobs()[0]->mutable_cpu_data();
566    weights_2[0] = -1;
567    weights_2[1] =  0;
568    weights_2[2] =  1;
569    layer->SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
570    layer->Forward(sep_blob_bottom_vec, sep_blob_top_vec);
571    const Dtype* top_data = this->blob_top_->cpu_data();
572    const Dtype* sep_top_data = this->blob_top_2_->cpu_data();
573    for (int i = 0; i < this->blob_top_->count(); ++i) {
574      EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
575    }
576  }
577  #endif
578  #if 0
579  TYPED_TEST(MKLConvolutionLayerTest, TestNDAgainst2D) {
580    typedef typename TypeParam::Dtype Dtype;
581    const int kernel_h = 11;
582    const int kernel_w = 13;
583    vector<int> bottom_shape(4);
584    bottom_shape[0] = 15;
585    bottom_shape[1] = 18;
586    bottom_shape[2] = kernel_h * 2;
587    bottom_shape[3] = kernel_w * 2;
588    FillerParameter filler_param;
589    GaussianFiller<Dtype> filler(filler_param);
590    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
591      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
592      filler.Fill(this->blob_bottom_vec_[i]);
593    }
594    LayerParameter layer_param;
595    ConvolutionParameter* convolution_param =
596        layer_param.mutable_convolution_param();
597    convolution_param->set_num_output(12);
598    convolution_param->set_bias_term(false);
599    convolution_param->set_group(6);
600    convolution_param->set_kernel_h(kernel_h);
601    convolution_param->set_kernel_w(kernel_w);
602    convolution_param->mutable_weight_filler()->set_type("gaussian");
603    Blob<Dtype> weights;
604    Blob<Dtype> top_diff;
605    bool copy_diff;
606    bool reshape;
607    {
608      MKLConvolutionLayer<Dtype> layer(layer_param);
609      layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
610      top_diff.ReshapeLike(*this->blob_top_);
611      filler.Fill(&top_diff);
612      ASSERT_EQ(1, layer.blobs().size());
613      copy_diff = false; reshape = true;
614      weights.CopyFrom(*layer.blobs()[0], copy_diff, reshape);
615    }
616    vector<bool> propagate_down(1, true);
617    Blob<Dtype> result_2d;
618    Blob<Dtype> backward_result_2d;
619    Blob<Dtype> backward_weight_result_2d;
620    {
621      caffe_set(this->blob_top_->count(), Dtype(0),
622                this->blob_top_->mutable_cpu_data());
623      caffe_set(this->blob_bottom_->count(), Dtype(0),
624                this->blob_bottom_->mutable_cpu_diff());
625      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
626      convolution_param->set_force_nd_im2col(false);
627      MKLConvolutionLayer<Dtype> layer_2d(layer_param);
628      layer_2d.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
629      ASSERT_EQ(1, layer_2d.blobs().size());
630      copy_diff = false; reshape = false;
631      layer_2d.blobs()[0]->CopyFrom(weights, copy_diff, reshape);
632      layer_2d.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
633      copy_diff = false; reshape = true;
634      result_2d.CopyFrom(*this->blob_top_, copy_diff, reshape);
635      ASSERT_EQ(this->blob_top_->shape(), top_diff.shape());
636      caffe_copy(top_diff.count(), top_diff.cpu_data(),
637                 this->blob_top_->mutable_cpu_diff());
638      layer_2d.Backward(this->blob_top_vec_, propagate_down,
639                        this->blob_bottom_vec_);
640      copy_diff = true; reshape = true;
641      backward_result_2d.CopyFrom(*this->blob_bottom_, copy_diff, reshape);
642      backward_weight_result_2d.CopyFrom(weights, copy_diff, reshape);
643    }
644    Blob<Dtype> result_nd;
645    Blob<Dtype> backward_result_nd;
646    Blob<Dtype> backward_weight_result_nd;
647    {
648      caffe_set(this->blob_top_->count(), Dtype(0),
649                this->blob_top_->mutable_cpu_data());
650      caffe_set(this->blob_bottom_->count(), Dtype(0),
651                this->blob_bottom_->mutable_cpu_diff());
652      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
653      convolution_param->set_force_nd_im2col(true);
654      MKLConvolutionLayer<Dtype> layer_nd(layer_param);
655      layer_nd.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
656      ASSERT_EQ(1, layer_nd.blobs().size());
657      copy_diff = false; reshape = false;
658      layer_nd.blobs()[0]->CopyFrom(weights, copy_diff, reshape);
659      layer_nd.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
660      copy_diff = false; reshape = true;
661      result_nd.CopyFrom(*this->blob_top_, copy_diff, reshape);
662      ASSERT_EQ(this->blob_top_->shape(), top_diff.shape());
663      caffe_copy(top_diff.count(), top_diff.cpu_data(),
664                 this->blob_top_->mutable_cpu_diff());
665      layer_nd.Backward(this->blob_top_vec_, propagate_down,
666                        this->blob_bottom_vec_);
667      copy_diff = true; reshape = true;
668      backward_result_nd.CopyFrom(*this->blob_bottom_, copy_diff, reshape);
669      backward_weight_result_nd.CopyFrom(weights, copy_diff, reshape);
670    }
671    ASSERT_EQ(result_nd.count(), result_2d.count());
672    for (int i = 0; i < result_2d.count(); ++i)  {
673      EXPECT_EQ(result_2d.cpu_data()[i], result_nd.cpu_data()[i]);
674    }
675    ASSERT_EQ(backward_result_nd.count(), backward_result_2d.count());
676    for (int i = 0; i < backward_result_2d.count(); ++i) {
677      EXPECT_EQ(backward_result_2d.cpu_diff()[i],
678                backward_result_nd.cpu_diff()[i]);
679    }
680    ASSERT_EQ(backward_weight_result_nd.count(),
681              backward_weight_result_2d.count());
682    for (int i = 0; i < backward_weight_result_2d.count(); ++i) {
683      EXPECT_EQ(backward_weight_result_2d.cpu_diff()[i],
684                backward_weight_result_nd.cpu_diff()[i]);
685    }
686  }
687  #endif
688  TYPED_TEST(MKLConvolutionLayerTest, TestGradient) {
689    typedef typename TypeParam::Dtype Dtype;
690    LayerParameter layer_param;
691    ConvolutionParameter* convolution_param =
692        layer_param.mutable_convolution_param();
693    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
694    this->blob_top_vec_.push_back(this->blob_top_2_);
695    convolution_param->add_kernel_size(3);
696    convolution_param->add_stride(2);
697    convolution_param->set_num_output(2);
698    convolution_param->mutable_weight_filler()->set_type("gaussian");
699    convolution_param->mutable_bias_filler()->set_type("gaussian");
700    MKLConvolutionLayer<Dtype> layer(layer_param);
701    GradientChecker<Dtype> checker(1e-2, 1e-3);
702    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
703        this->blob_top_vec_);
704  }
705  #if 0
706  TYPED_TEST(MKLConvolutionLayerTest, TestDilatedGradient) {
707    typedef typename TypeParam::Dtype Dtype;
708    LayerParameter layer_param;
709    ConvolutionParameter* convolution_param =
710        layer_param.mutable_convolution_param();
711    vector<int> bottom_shape;
712    bottom_shape.push_back(2);
713    bottom_shape.push_back(3);
714    bottom_shape.push_back(5);
715    bottom_shape.push_back(6);
716    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
717      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
718    }
719    convolution_param->add_kernel_size(3);
720    convolution_param->add_dilation(2);
721    convolution_param->set_num_output(2);
722    convolution_param->mutable_weight_filler()->set_type("gaussian");
723    convolution_param->mutable_bias_filler()->set_type("gaussian");
724    MKLConvolutionLayer<Dtype> layer(layer_param);
725    GradientChecker<Dtype> checker(1e-2, 1e-3);
726    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
727                                    this->blob_top_vec_);
728  }
729  #endif
730  #if 0
731  TYPED_TEST(MKLConvolutionLayerTest, TestGradient3D) {
732    typedef typename TypeParam::Dtype Dtype;
733    LayerParameter layer_param;
734    ConvolutionParameter* convolution_param =
735        layer_param.mutable_convolution_param();
736    vector<int> bottom_shape(5);
737    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
738    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
739    bottom_shape[2] = 5;
740    bottom_shape[3] = this->blob_bottom_vec_[0]->shape(2);
741    bottom_shape[4] = this->blob_bottom_vec_[0]->shape(3);
742    FillerParameter filler_param;
743    GaussianFiller<Dtype> filler(filler_param);
744    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
745      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
746      filler.Fill(this->blob_bottom_vec_[i]);
747    }
748    convolution_param->add_kernel_size(3);
749    convolution_param->add_stride(2);
750    convolution_param->set_num_output(2);
751    convolution_param->mutable_weight_filler()->set_type("gaussian");
752    convolution_param->mutable_bias_filler()->set_type("gaussian");
753    MKLConvolutionLayer<Dtype> layer(layer_param);
754    GradientChecker<Dtype> checker(1e-2, 1e-3);
755    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
756        this->blob_top_vec_);
757  }
758  #endif
759  TYPED_TEST(MKLConvolutionLayerTest, Test1x1Gradient) {
760    typedef typename TypeParam::Dtype Dtype;
761    LayerParameter layer_param;
762    ConvolutionParameter* convolution_param =
763        layer_param.mutable_convolution_param();
764    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
765    this->blob_top_vec_.push_back(this->blob_top_2_);
766    convolution_param->add_kernel_size(1);
767    convolution_param->add_stride(1);
768    convolution_param->set_num_output(2);
769    convolution_param->mutable_weight_filler()->set_type("gaussian");
770    convolution_param->mutable_bias_filler()->set_type("gaussian");
771    MKLConvolutionLayer<Dtype> layer(layer_param);
772    GradientChecker<Dtype> checker(1e-2, 1e-3);
773    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
774        this->blob_top_vec_);
775  }
776  TYPED_TEST(MKLConvolutionLayerTest, TestGradientGroup) {
777    typedef typename TypeParam::Dtype Dtype;
778    LayerParameter layer_param;
779    ConvolutionParameter* convolution_param =
780        layer_param.mutable_convolution_param();
781    convolution_param->add_kernel_size(3);
782    convolution_param->add_stride(2);
783    convolution_param->set_num_output(3);
784    convolution_param->set_group(3);
785    convolution_param->mutable_weight_filler()->set_type("gaussian");
786    convolution_param->mutable_bias_filler()->set_type("gaussian");
787    MKLConvolutionLayer<Dtype> layer(layer_param);
788    GradientChecker<Dtype> checker(1e-2, 1e-3);
789    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
790        this->blob_top_vec_);
791  }
792  }  
793  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_format.h"
2  #include <cstdarg>
3  #include <cstdint>
4  #include <cstdio>
5  #include <string>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/strings/cord.h"
9  #include "absl/strings/str_cat.h"
10  #include "absl/strings/string_view.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace {
14  using str_format_internal::FormatArgImpl;
15  using FormatEntryPointTest = ::testing::Test;
16  TEST_F(FormatEntryPointTest, Format) {
17    std::string sink;
18    EXPECT_TRUE(Format(&sink, "A format %d", 123));
19    EXPECT_EQ("A format 123", sink);
20    sink.clear();
21    ParsedFormat<'d'> pc("A format %d");
22    EXPECT_TRUE(Format(&sink, pc, 123));
23    EXPECT_EQ("A format 123", sink);
24  }
25  TEST_F(FormatEntryPointTest, FormatWithV) {
26    std::string sink;
27    EXPECT_TRUE(Format(&sink, "A format %v", 123));
28    EXPECT_EQ("A format 123", sink);
29    sink.clear();
30    ParsedFormat<'v'> pc("A format %v");
31    EXPECT_TRUE(Format(&sink, pc, 123));
32    EXPECT_EQ("A format 123", sink);
33  }
34  TEST_F(FormatEntryPointTest, UntypedFormat) {
35    constexpr const char* formats[] = {
36      "",
37      "a",
38      "%80d",
39  #if !defined(_MSC_VER) && !defined(__ANDROID__) && !defined(__native_client__)
40      "complicated multipart %% %1$d format %1$0999d",
41  #endif  
42    };
43    for (const char* fmt : formats) {
44      std::string actual;
45      int i = 123;
46      FormatArgImpl arg_123(i);
47      absl::Span<const FormatArgImpl> args(&arg_123, 1);
48      UntypedFormatSpec format(fmt);
49      EXPECT_TRUE(FormatUntyped(&actual, format, args));
50      char buf[4096]{};
51      snprintf(buf, sizeof(buf), fmt, 123);
52      EXPECT_EQ(
53          str_format_internal::FormatPack(
54              str_format_internal::UntypedFormatSpecImpl::Extract(format), args),
55          buf);
56      EXPECT_EQ(actual, buf);
57    }
58    ParsedFormat<'d'> pc("A format %d");
59    int i = 345;
60    FormatArg arg(i);
61    std::string out;
62    EXPECT_TRUE(str_format_internal::FormatUntyped(
63        &out, str_format_internal::UntypedFormatSpecImpl(&pc), {&arg, 1}));
64    EXPECT_EQ("A format 345", out);
65  }
66  TEST_F(FormatEntryPointTest, StringFormat) {
67    EXPECT_EQ("123", StrFormat("%d", 123));
68    constexpr absl::string_view view("=%d=", 4);
69    EXPECT_EQ("=123=", StrFormat(view, 123));
70  }
71  TEST_F(FormatEntryPointTest, StringFormatV) {
72    std::string hello = "hello";
73    EXPECT_EQ("hello", StrFormat("%v", hello));
74    EXPECT_EQ("123", StrFormat("%v", 123));
75    constexpr absl::string_view view("=%v=", 4);
76    EXPECT_EQ("=123=", StrFormat(view, 123));
77  }
78  TEST_F(FormatEntryPointTest, AppendFormat) {
79    std::string s;
80    std::string& r = StrAppendFormat(&s, "%d", 123);
81    EXPECT_EQ(&s, &r);  
82    EXPECT_EQ("123", r);
83  }
84  TEST_F(FormatEntryPointTest, AppendFormatWithV) {
85    std::string s;
86    std::string& r = StrAppendFormat(&s, "%v", 123);
87    EXPECT_EQ(&s, &r);  
88    EXPECT_EQ("123", r);
89  }
90  TEST_F(FormatEntryPointTest, AppendFormatFail) {
91    std::string s = "orig";
92    UntypedFormatSpec format(" more %d");
93    FormatArgImpl arg("not an int");
94    EXPECT_EQ("orig",
95              str_format_internal::AppendPack(
96                  &s, str_format_internal::UntypedFormatSpecImpl::Extract(format),
97                  {&arg, 1}));
98  }
99  TEST_F(FormatEntryPointTest, AppendFormatFailWithV) {
100    std::string s = "orig";
101    UntypedFormatSpec format(" more %v");
102    FormatArgImpl arg("not an int");
103    EXPECT_EQ("orig",
104              str_format_internal::AppendPack(
105                  &s, str_format_internal::UntypedFormatSpecImpl::Extract(format),
106                  {&arg, 1}));
107  }
108  TEST_F(FormatEntryPointTest, ManyArgs) {
109    EXPECT_EQ(
110        "60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 "
111        "36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 "
112        "12 11 10 9 8 7 6 5 4 3 2 1",
113        StrFormat("%60$d %59$d %58$d %57$d %56$d %55$d %54$d %53$d %52$d %51$d "
114                  "%50$d %49$d %48$d %47$d %46$d %45$d %44$d %43$d %42$d %41$d "
115                  "%40$d %39$d %38$d %37$d %36$d %35$d %34$d %33$d %32$d %31$d "
116                  "%30$d %29$d %28$d %27$d %26$d %25$d %24$d %23$d %22$d %21$d "
117                  "%20$d %19$d %18$d %17$d %16$d %15$d %14$d %13$d %12$d %11$d "
118                  "%10$d %9$d %8$d %7$d %6$d %5$d %4$d %3$d %2$d %1$d",
119                  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
120                  19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
121                  35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
122                  51, 52, 53, 54, 55, 56, 57, 58, 59, 60));
123  }
124  TEST_F(FormatEntryPointTest, Preparsed) {
125    ParsedFormat<'d'> pc("%d");
126    EXPECT_EQ("123", StrFormat(pc, 123));
127    EXPECT_EQ("123", StrFormat(ParsedFormat<'d'>("%d"), 123));
128    constexpr absl::string_view view("=%d=", 4);
129    EXPECT_EQ("=123=", StrFormat(ParsedFormat<'d'>(view), 123));
130  }
131  TEST_F(FormatEntryPointTest, PreparsedWithV) {
132    ParsedFormat<'v'> pc("%v");
133    EXPECT_EQ("123", StrFormat(pc, 123));
134    EXPECT_EQ("123", StrFormat(ParsedFormat<'v'>("%v"), 123));
135    constexpr absl::string_view view("=%v=", 4);
136    EXPECT_EQ("=123=", StrFormat(ParsedFormat<'v'>(view), 123));
137  }
138  TEST_F(FormatEntryPointTest, FormatCountCapture) {
139    int n = 0;
140    EXPECT_EQ("", StrFormat("%n", FormatCountCapture(&n)));
141    EXPECT_EQ(0, n);
142    EXPECT_EQ("123", StrFormat("%d%n", 123, FormatCountCapture(&n)));
143    EXPECT_EQ(3, n);
144  }
145  TEST_F(FormatEntryPointTest, FormatCountCaptureWithV) {
146    int n = 0;
147    EXPECT_EQ("", StrFormat("%n", FormatCountCapture(&n)));
148    EXPECT_EQ(0, n);
149    EXPECT_EQ("123", StrFormat("%v%n", 123, FormatCountCapture(&n)));
150    EXPECT_EQ(3, n);
151  }
152  TEST_F(FormatEntryPointTest, FormatCountCaptureWrongType) {
153    int n = 0;
154    UntypedFormatSpec format("%d%n");
155    int i = 123, *ip = &n;
156    FormatArgImpl args[2] = {FormatArgImpl(i), FormatArgImpl(ip)};
157    EXPECT_EQ("", str_format_internal::FormatPack(
158                      str_format_internal::UntypedFormatSpecImpl::Extract(format),
159                      absl::MakeSpan(args)));
160  }
161  TEST_F(FormatEntryPointTest, FormatCountCaptureWrongTypeWithV) {
162    int n = 0;
163    UntypedFormatSpec format("%v%n");
164    int i = 123, *ip = &n;
165    FormatArgImpl args[2] = {FormatArgImpl(i), FormatArgImpl(ip)};
166    EXPECT_EQ("", str_format_internal::FormatPack(
167                      str_format_internal::UntypedFormatSpecImpl::Extract(format),
168                      absl::MakeSpan(args)));
169  }
170  TEST_F(FormatEntryPointTest, FormatCountCaptureMultiple) {
171    int n1 = 0;
172    int n2 = 0;
173    EXPECT_EQ("    1         2",
174              StrFormat("%5d%n%10d%n", 1, FormatCountCapture(&n1), 2,
175                        FormatCountCapture(&n2)));
176    EXPECT_EQ(5, n1);
177    EXPECT_EQ(15, n2);
178  }
179  TEST_F(FormatEntryPointTest, FormatCountCaptureExample) {
180    int n;
181    std::string s;
182    StrAppendFormat(&s, "%s: %n%s\n", "(1,1)", FormatCountCapture(&n), "(1,2)");
183    StrAppendFormat(&s, "%*s%s\n", n, "", "(2,2)");
184    EXPECT_EQ(7, n);
185    EXPECT_EQ(
186        "(1,1): (1,2)\n"
187        "       (2,2)\n",
188        s);
189  }
190  TEST_F(FormatEntryPointTest, FormatCountCaptureExampleWithV) {
191    int n;
192    std::string s;
193    std::string a1 = "(1,1)";
194    std::string a2 = "(1,2)";
195    std::string a3 = "(2,2)";
196    StrAppendFormat(&s, "%v: %n%v\n", a1, FormatCountCapture(&n), a2);
197    StrAppendFormat(&s, "%*s%v\n", n, "", a3);
198    EXPECT_EQ(7, n);
199    EXPECT_EQ(
200        "(1,1): (1,2)\n"
201        "       (2,2)\n",
202        s);
203  }
204  TEST_F(FormatEntryPointTest, Stream) {
205    const std::string formats[] = {
206      "",
207      "a",
208      "%80d",
209      "%d %u %c %s %f %g",
210  #if !defined(_MSC_VER) && !defined(__ANDROID__) && !defined(__native_client__)
211      "complicated multipart %% %1$d format %1$080d",
212  #endif  
213    };
214    std::string buf(4096, '\0');
215    for (const auto& fmt : formats) {
216      const auto parsed =
217          ParsedFormat<'d', 'u', 'c', 's', 'f', 'g'>::NewAllowIgnored(fmt);
218      std::ostringstream oss;
219      oss << StreamFormat(*parsed, 123, 3, 49, "multistreaming!!!", 1.01, 1.01);
220      int fmt_result = snprintf(&*buf.begin(), buf.size(), fmt.c_str(),  
221                                123, 3, 49, "multistreaming!!!", 1.01, 1.01);
222      ASSERT_TRUE(oss) << fmt;
223      ASSERT_TRUE(fmt_result >= 0 && static_cast<size_t>(fmt_result) < buf.size())
224          << fmt_result;
225      EXPECT_EQ(buf.c_str(), oss.str());
226    }
227  }
228  TEST_F(FormatEntryPointTest, StreamWithV) {
229    const std::string formats[] = {
230        "",
231        "a",
232        "%v %u %c %v %f %v",
233    };
234    const std::string formats_for_buf[] = {
235        "",
236        "a",
237        "%d %u %c %s %f %g",
238    };
239    std::string buf(4096, '\0');
240    for (auto i = 0; i < ABSL_ARRAYSIZE(formats); ++i) {
241      const auto parsed =
242          ParsedFormat<'v', 'u', 'c', 'v', 'f', 'v'>::NewAllowIgnored(formats[i]);
243      std::ostringstream oss;
244      oss << StreamFormat(*parsed, 123, 3, 49,
245                          absl::string_view("multistreaming!!!"), 1.01, 1.01);
246      int fmt_result =
247          snprintf(&*buf.begin(), buf.size(), formats_for_buf[i].c_str(),  
248                   123, 3, 49, "multistreaming!!!", 1.01, 1.01);
249      ASSERT_TRUE(oss) << formats[i];
250      ASSERT_TRUE(fmt_result >= 0 && static_cast<size_t>(fmt_result) < buf.size())
251          << fmt_result;
252      EXPECT_EQ(buf.c_str(), oss.str());
253    }
254  }
255  TEST_F(FormatEntryPointTest, StreamOk) {
256    std::ostringstream oss;
257    oss << StreamFormat("hello %d", 123);
258    EXPECT_EQ("hello 123", oss.str());
259    EXPECT_TRUE(oss.good());
260  }
261  TEST_F(FormatEntryPointTest, StreamOkWithV) {
262    std::ostringstream oss;
263    oss << StreamFormat("hello %v", 123);
264    EXPECT_EQ("hello 123", oss.str());
265    EXPECT_TRUE(oss.good());
266  }
267  TEST_F(FormatEntryPointTest, StreamFail) {
268    std::ostringstream oss;
269    UntypedFormatSpec format("hello %d");
270    FormatArgImpl arg("non-numeric");
271    oss << str_format_internal::Streamable(
272        str_format_internal::UntypedFormatSpecImpl::Extract(format), {&arg, 1});
273    EXPECT_EQ("hello ", oss.str());  
274    EXPECT_TRUE(oss.fail());
275  }
276  TEST_F(FormatEntryPointTest, StreamFailWithV) {
277    std::ostringstream oss;
278    UntypedFormatSpec format("hello %v");
279    FormatArgImpl arg("non-numeric");
280    oss << str_format_internal::Streamable(
281        str_format_internal::UntypedFormatSpecImpl::Extract(format), {&arg, 1});
282    EXPECT_EQ("hello ", oss.str());  
283    EXPECT_TRUE(oss.fail());
284  }
285  std::string WithSnprintf(const char* fmt, ...) {
286    std::string buf;
287    buf.resize(128);
288    va_list va;
<span onclick='openModal()' class='match'>289    va_start(va, fmt);
290    int r = vsnprintf(&*buf.begin(), buf.size(), fmt, va);
291    va_end(va);
292    EXPECT_GE(r, 0);
293    EXPECT_LT(r, buf.size());
294    buf.resize(r);
</span>295    return buf;
296  }
297  TEST_F(FormatEntryPointTest, FloatPrecisionArg) {
298    EXPECT_EQ("0.1", StrFormat("%.1f", 0.1));
299    EXPECT_EQ("0.1", WithSnprintf("%.1f", 0.1));
300    EXPECT_EQ("  0.1", StrFormat("%*.1f", 5, 0.1));
301    EXPECT_EQ("  0.1", WithSnprintf("%*.1f", 5, 0.1));
302    EXPECT_EQ("0.1", StrFormat("%.*f", 1, 0.1));
303    EXPECT_EQ("0.1", WithSnprintf("%.*f", 1, 0.1));
304    EXPECT_EQ("  0.1", StrFormat("%*.*f", 5, 1, 0.1));
305    EXPECT_EQ("  0.1", WithSnprintf("%*.*f", 5, 1, 0.1));
306  }
307  namespace streamed_test {
308  struct X {};
309  std::ostream& operator<<(std::ostream& os, const X&) {
310    return os << "X";
311  }
312  }  
313  TEST_F(FormatEntryPointTest, FormatStreamed) {
314    EXPECT_EQ("123", StrFormat("%s", FormatStreamed(123)));
315    EXPECT_EQ("  123", StrFormat("%5s", FormatStreamed(123)));
316    EXPECT_EQ("123  ", StrFormat("%-5s", FormatStreamed(123)));
317    EXPECT_EQ("X", StrFormat("%s", FormatStreamed(streamed_test::X())));
318    EXPECT_EQ("123", StrFormat("%s", FormatStreamed(StreamFormat("%d", 123))));
319  }
320  TEST_F(FormatEntryPointTest, FormatStreamedWithV) {
321    EXPECT_EQ("123", StrFormat("%v", FormatStreamed(123)));
322    EXPECT_EQ("X", StrFormat("%v", FormatStreamed(streamed_test::X())));
323    EXPECT_EQ("123", StrFormat("%v", FormatStreamed(StreamFormat("%d", 123))));
324  }
325  class TempFile {
326   public:
327    TempFile() : file_(std::tmpfile()) {}
328    ~TempFile() { std::fclose(file_); }
329    std::FILE* file() const { return file_; }
330    std::string ReadFile() {
331      std::fseek(file_, 0, SEEK_END);
332      int size = std::ftell(file_);
333      EXPECT_GT(size, 0);
334      std::rewind(file_);
335      std::string str(2 * size, ' ');
336      int read_bytes = std::fread(&str[0], 1, str.size(), file_);
337      EXPECT_EQ(read_bytes, size);
338      str.resize(read_bytes);
339      EXPECT_TRUE(std::feof(file_));
340      return str;
341    }
342   private:
343    std::FILE* file_;
344  };
345  TEST_F(FormatEntryPointTest, FPrintF) {
346    TempFile tmp;
347    int result =
348        FPrintF(tmp.file(), "STRING: %s NUMBER: %010d", std::string("ABC"), -19);
349    EXPECT_EQ(result, 30);
350    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
351  }
352  TEST_F(FormatEntryPointTest, FPrintFWithV) {
353    TempFile tmp;
354    int result =
355        FPrintF(tmp.file(), "STRING: %v NUMBER: %010d", std::string("ABC"), -19);
356    EXPECT_EQ(result, 30);
357    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
358  }
359  TEST_F(FormatEntryPointTest, FPrintFError) {
360    errno = 0;
361    int result = FPrintF(stdin, "ABC");
362    EXPECT_LT(result, 0);
363    EXPECT_EQ(errno, EBADF);
364  }
365  #ifdef __GLIBC__
366  TEST_F(FormatEntryPointTest, FprintfTooLarge) {
367    std::FILE* f = std::fopen("/dev/null", "w");
368    int width = 2000000000;
369    errno = 0;
370    int result = FPrintF(f, "%*d %*d", width, 0, width, 0);
371    EXPECT_LT(result, 0);
372    EXPECT_EQ(errno, EFBIG);
373    std::fclose(f);
374  }
375  TEST_F(FormatEntryPointTest, PrintF) {
376    int stdout_tmp = dup(STDOUT_FILENO);
377    TempFile tmp;
378    std::fflush(stdout);
379    dup2(fileno(tmp.file()), STDOUT_FILENO);
380    int result = PrintF("STRING: %s NUMBER: %010d", std::string("ABC"), -19);
381    std::fflush(stdout);
382    dup2(stdout_tmp, STDOUT_FILENO);
383    close(stdout_tmp);
384    EXPECT_EQ(result, 30);
385    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
386  }
387  TEST_F(FormatEntryPointTest, PrintFWithV) {
388    int stdout_tmp = dup(STDOUT_FILENO);
389    TempFile tmp;
390    std::fflush(stdout);
391    dup2(fileno(tmp.file()), STDOUT_FILENO);
392    int result = PrintF("STRING: %v NUMBER: %010d", std::string("ABC"), -19);
393    std::fflush(stdout);
394    dup2(stdout_tmp, STDOUT_FILENO);
395    close(stdout_tmp);
396    EXPECT_EQ(result, 30);
397    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
398  }
399  #endif  
400  TEST_F(FormatEntryPointTest, SNPrintF) {
401    char buffer[16];
402    int result =
403        SNPrintF(buffer, sizeof(buffer), "STRING: %s", std::string("ABC"));
404    EXPECT_EQ(result, 11);
405    EXPECT_EQ(std::string(buffer), "STRING: ABC");
406    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 123456);
407    EXPECT_EQ(result, 14);
408    EXPECT_EQ(std::string(buffer), "NUMBER: 123456");
409    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 1234567);
410    EXPECT_EQ(result, 15);
411    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
412    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 12345678);
413    EXPECT_EQ(result, 16);
414    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
415    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 123456789);
416    EXPECT_EQ(result, 17);
417    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
418    result = SNPrintF(nullptr, 0, "Just checking the %s of the output.", "size");
419    EXPECT_EQ(result, 37);
420  }
421  TEST_F(FormatEntryPointTest, SNPrintFWithV) {
422    char buffer[16];
423    int result =
424        SNPrintF(buffer, sizeof(buffer), "STRING: %v", std::string("ABC"));
425    EXPECT_EQ(result, 11);
426    EXPECT_EQ(std::string(buffer), "STRING: ABC");
427    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 123456);
428    EXPECT_EQ(result, 14);
429    EXPECT_EQ(std::string(buffer), "NUMBER: 123456");
430    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 1234567);
431    EXPECT_EQ(result, 15);
432    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
433    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 12345678);
434    EXPECT_EQ(result, 16);
435    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
436    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 123456789);
437    EXPECT_EQ(result, 17);
438    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
439    std::string size = "size";
440    result = SNPrintF(nullptr, 0, "Just checking the %v of the output.", size);
441    EXPECT_EQ(result, 37);
442  }
443  TEST(StrFormat, BehavesAsDocumented) {
444    std::string s = absl::StrFormat("%s, %d!", "Hello", 123);
445    EXPECT_EQ("Hello, 123!", s);
446    std::string hello = "Hello";
447    std::string s2 = absl::StrFormat("%v, %v!", hello, 123);
448    EXPECT_EQ("Hello, 123!", s2);
449    EXPECT_EQ(absl::StrFormat("%1$+3.2Lf", 1.1), "+1.10");
450    EXPECT_EQ(StrFormat("%c", 'a'), "a");
451    EXPECT_EQ(StrFormat("%c", 0x20), " ");
452    EXPECT_EQ(StrFormat("%c", int{'a'}), "a");
453    EXPECT_EQ(StrFormat("%c", long{'a'}), "a");  
454    EXPECT_EQ(StrFormat("%c", uint64_t{'a'}), "a");
455    EXPECT_EQ(StrFormat("%s", "C"), "C");
456    EXPECT_EQ(StrFormat("%v", std::string("C")), "C");
457    EXPECT_EQ(StrFormat("%s", std::string("C++")), "C++");
458    EXPECT_EQ(StrFormat("%v", std::string("C++")), "C++");
459    EXPECT_EQ(StrFormat("%s", string_view("view")), "view");
460    EXPECT_EQ(StrFormat("%v", string_view("view")), "view");
461    EXPECT_EQ(StrFormat("%s", absl::Cord("cord")), "cord");
462    EXPECT_EQ(StrFormat("%v", absl::Cord("cord")), "cord");
463    EXPECT_EQ(StrFormat("%d", char{10}), "10");
464    EXPECT_EQ(StrFormat("%d", int{10}), "10");
465    EXPECT_EQ(StrFormat("%d", long{10}), "10");  
466    EXPECT_EQ(StrFormat("%d", uint64_t{10}), "10");
467    EXPECT_EQ(StrFormat("%v", int{10}), "10");
468    EXPECT_EQ(StrFormat("%v", long{10}), "10");  
469    EXPECT_EQ(StrFormat("%v", uint64_t{10}), "10");
470    EXPECT_EQ(StrFormat("%d", -10), "-10");
471    EXPECT_EQ(StrFormat("%i", -10), "-10");
472    EXPECT_EQ(StrFormat("%v", -10), "-10");
473    EXPECT_EQ(StrFormat("%o", 10), "12");
474    EXPECT_EQ(StrFormat("%u", 10), "10");
475    EXPECT_EQ(StrFormat("%v", 10), "10");
476    EXPECT_EQ(StrFormat("%x", 10), "a");
477    EXPECT_EQ(StrFormat("%X", 10), "A");
478    EXPECT_EQ(StrFormat("%.1f", float{1}), "1.0");
479    EXPECT_EQ(StrFormat("%.1f", double{1}), "1.0");
480    const long double long_double = 1.0;
481    EXPECT_EQ(StrFormat("%.1f", long_double), "1.0");
482    EXPECT_EQ(StrFormat("%.1f", char{1}), "1.0");
483    EXPECT_EQ(StrFormat("%.1f", int{1}), "1.0");
484    EXPECT_EQ(StrFormat("%.1f", long{1}), "1.0");  
485    EXPECT_EQ(StrFormat("%.1f", uint64_t{1}), "1.0");
486    EXPECT_EQ(StrFormat("%f", 123456789), "123456789.000000");
487    EXPECT_EQ(StrFormat("%F", 123456789), "123456789.000000");
488    EXPECT_EQ(StrFormat("%e", .01), "1.000000e-02");
489    EXPECT_EQ(StrFormat("%E", .01), "1.000000E-02");
490    EXPECT_EQ(StrFormat("%g", .01), "0.01");
491    EXPECT_EQ(StrFormat("%g", 1e10), "1e+10");
492    EXPECT_EQ(StrFormat("%G", 1e10), "1E+10");
493    EXPECT_EQ(StrFormat("%v", .01), "0.01");
494    EXPECT_EQ(StrFormat("%v", 1e10), "1e+10");
495  #if !defined(__ANDROID_API__) || __ANDROID_API__ > 21
496    EXPECT_EQ(StrFormat("%.1a", -3.0), "-0x1.8p+1");  
497    EXPECT_EQ(StrFormat("%.1A", -3.0), "-0X1.8P+1");  
498  #endif
499    int64_t value = 0x7ffdeb4;
500    auto ptr_value = static_cast<uintptr_t>(value);
501    const int& something = *reinterpret_cast<const int*>(ptr_value);
502    EXPECT_EQ(StrFormat("%p", &something), StrFormat("0x%x", ptr_value));
503    EXPECT_EQ(StrFormat("%3d", 1), "  1");
504    EXPECT_EQ(StrFormat("%3d", 123456), "123456");
505    EXPECT_EQ(StrFormat("%06.2f", 1.234), "001.23");
506    EXPECT_EQ(StrFormat("%+d", 1), "+1");
507    EXPECT_EQ(StrFormat("% d", 1), " 1");
508    EXPECT_EQ(StrFormat("%-4d", -1), "-1  ");
509    EXPECT_EQ(StrFormat("%#o", 10), "012");
510    EXPECT_EQ(StrFormat("%#x", 15), "0xf");
511    EXPECT_EQ(StrFormat("%04d", 8), "0008");
512    EXPECT_EQ(absl::StrFormat("%2$s, %3$s, %1$s!", "vici", "veni", "vidi"),
513              "veni, vidi, vici!");
514    EXPECT_EQ(StrFormat("%hhd", int{1}), "1");
515    EXPECT_EQ(StrFormat("%hd", int{1}), "1");
516    EXPECT_EQ(StrFormat("%ld", int{1}), "1");
517    EXPECT_EQ(StrFormat("%lld", int{1}), "1");
518    EXPECT_EQ(StrFormat("%Ld", int{1}), "1");
519    EXPECT_EQ(StrFormat("%jd", int{1}), "1");
520    EXPECT_EQ(StrFormat("%zd", int{1}), "1");
521    EXPECT_EQ(StrFormat("%td", int{1}), "1");
522    EXPECT_EQ(StrFormat("%qd", int{1}), "1");
523    EXPECT_EQ(StrFormat("%v", true), "true");
524    EXPECT_EQ(StrFormat("%v", false), "false");
525    EXPECT_EQ(StrFormat("%d", true), "1");
526  }
527  using str_format_internal::ExtendedParsedFormat;
528  using str_format_internal::ParsedFormatBase;
529  struct SummarizeConsumer {
530    std::string* out;
531    explicit SummarizeConsumer(std::string* out) : out(out) {}
532    bool Append(string_view s) {
533      *out += "[" + std::string(s) + "]";
534      return true;
535    }
536    bool ConvertOne(const str_format_internal::UnboundConversion& conv,
537                    string_view s) {
538      *out += "{";
539      *out += std::string(s);
540      *out += ":";
541      *out += std::to_string(conv.arg_position) + "$";
542      if (conv.width.is_from_arg()) {
543        *out += std::to_string(conv.width.get_from_arg()) + "$*";
544      }
545      if (conv.precision.is_from_arg()) {
546        *out += "." + std::to_string(conv.precision.get_from_arg()) + "$*";
547      }
548      *out += str_format_internal::FormatConversionCharToChar(conv.conv);
549      *out += "}";
550      return true;
551    }
552  };
553  std::string SummarizeParsedFormat(const ParsedFormatBase& pc) {
554    std::string out;
555    if (!pc.ProcessFormat(SummarizeConsumer(&out))) out += "!";
556    return out;
557  }
558  using ParsedFormatTest = ::testing::Test;
559  TEST_F(ParsedFormatTest, SimpleChecked) {
560    EXPECT_EQ("[ABC]{d:1$d}[DEF]",
561              SummarizeParsedFormat(ParsedFormat<'d'>("ABC%dDEF")));
562    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}",
563              SummarizeParsedFormat(ParsedFormat<'s', 'd', 'f'>("%sFFF%dZZZ%f")));
564    EXPECT_EQ("{s:1$s}[ ]{.*d:3$.2$*d}",
565              SummarizeParsedFormat(ParsedFormat<'s', '*', 'd'>("%s %.*d")));
566  }
567  TEST_F(ParsedFormatTest, SimpleCheckedWithV) {
568    EXPECT_EQ("[ABC]{v:1$v}[DEF]",
569              SummarizeParsedFormat(ParsedFormat<'v'>("ABC%vDEF")));
570    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}",
571              SummarizeParsedFormat(ParsedFormat<'v', 'v', 'f'>("%vFFF%vZZZ%f")));
572    EXPECT_EQ("{v:1$v}[ ]{.*d:3$.2$*d}",
573              SummarizeParsedFormat(ParsedFormat<'v', '*', 'd'>("%v %.*d")));
574  }
575  TEST_F(ParsedFormatTest, SimpleUncheckedCorrect) {
576    auto f = ParsedFormat<'d'>::New("ABC%dDEF");
577    ASSERT_TRUE(f);
578    EXPECT_EQ("[ABC]{d:1$d}[DEF]", SummarizeParsedFormat(*f));
579    std::string format = "%sFFF%dZZZ%f";
580    auto f2 = ParsedFormat<'s', 'd', 'f'>::New(format);
581    ASSERT_TRUE(f2);
582    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
583    f2 = ParsedFormat<'s', 'd', 'f'>::New("%s %d %f");
584    ASSERT_TRUE(f2);
585    EXPECT_EQ("{s:1$s}[ ]{d:2$d}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
586    auto star = ParsedFormat<'*', 'd'>::New("%*d");
587    ASSERT_TRUE(star);
588    EXPECT_EQ("{*d:2$1$*d}", SummarizeParsedFormat(*star));
589    auto dollar = ParsedFormat<'d', 's'>::New("%2$s %1$d");
590    ASSERT_TRUE(dollar);
591    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}", SummarizeParsedFormat(*dollar));
592    dollar = ParsedFormat<'d', 's'>::New("%2$s %1$d %1$d");
593    ASSERT_TRUE(dollar);
594    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}[ ]{1$d:1$d}",
595              SummarizeParsedFormat(*dollar));
596  }
597  TEST_F(ParsedFormatTest, SimpleUncheckedCorrectWithV) {
598    auto f = ParsedFormat<'v'>::New("ABC%vDEF");
599    ASSERT_TRUE(f);
600    EXPECT_EQ("[ABC]{v:1$v}[DEF]", SummarizeParsedFormat(*f));
601    std::string format = "%vFFF%vZZZ%f";
602    auto f2 = ParsedFormat<'v', 'v', 'f'>::New(format);
603    ASSERT_TRUE(f2);
604    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
605    f2 = ParsedFormat<'v', 'v', 'f'>::New("%v %v %f");
606    ASSERT_TRUE(f2);
607    EXPECT_EQ("{v:1$v}[ ]{v:2$v}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
608  }
609  TEST_F(ParsedFormatTest, SimpleUncheckedIgnoredArgs) {
610    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("ABC")));
611    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("%dABC")));
612    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("ABC%2$s")));
613    auto f = ParsedFormat<'d', 's'>::NewAllowIgnored("ABC");
614    ASSERT_TRUE(f);
615    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
616    f = ParsedFormat<'d', 's'>::NewAllowIgnored("%dABC");
617    ASSERT_TRUE(f);
618    EXPECT_EQ("{d:1$d}[ABC]", SummarizeParsedFormat(*f));
619    f = ParsedFormat<'d', 's'>::NewAllowIgnored("ABC%2$s");
620    ASSERT_TRUE(f);
621    EXPECT_EQ("[ABC]{2$s:2$s}", SummarizeParsedFormat(*f));
622  }
623  TEST_F(ParsedFormatTest, SimpleUncheckedIgnoredArgsWithV) {
624    EXPECT_FALSE((ParsedFormat<'v', 'v'>::New("ABC")));
625    EXPECT_FALSE((ParsedFormat<'v', 'v'>::New("%vABC")));
626    EXPECT_FALSE((ParsedFormat<'v', 's'>::New("ABC%2$s")));
627    auto f = ParsedFormat<'v', 'v'>::NewAllowIgnored("ABC");
628    ASSERT_TRUE(f);
629    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
630    f = ParsedFormat<'v', 'v'>::NewAllowIgnored("%vABC");
631    ASSERT_TRUE(f);
632    EXPECT_EQ("{v:1$v}[ABC]", SummarizeParsedFormat(*f));
633  }
634  TEST_F(ParsedFormatTest, SimpleUncheckedUnsupported) {
635    EXPECT_FALSE(ParsedFormat<'d'>::New("%1$d %1$x"));
636    EXPECT_FALSE(ParsedFormat<'x'>::New("%1$d %1$x"));
637  }
638  TEST_F(ParsedFormatTest, SimpleUncheckedIncorrect) {
639    EXPECT_FALSE(ParsedFormat<'d'>::New(""));
640    EXPECT_FALSE(ParsedFormat<'d'>::New("ABC%dDEF%d"));
641    std::string format = "%sFFF%dZZZ%f";
642    EXPECT_FALSE((ParsedFormat<'s', 'd', 'g'>::New(format)));
643  }
644  TEST_F(ParsedFormatTest, SimpleUncheckedIncorrectWithV) {
645    EXPECT_FALSE(ParsedFormat<'v'>::New(""));
646    EXPECT_FALSE(ParsedFormat<'v'>::New("ABC%vDEF%v"));
647    std::string format = "%vFFF%vZZZ%f";
648    EXPECT_FALSE((ParsedFormat<'v', 'v', 'g'>::New(format)));
649  }
650  #if defined(__cpp_nontype_template_parameter_auto)
651  template <auto T>
652  std::true_type IsValidParsedFormatArgTest(ParsedFormat<T>*);
653  template <auto T>
654  std::false_type IsValidParsedFormatArgTest(...);
655  template <auto T>
656  using IsValidParsedFormatArg = decltype(IsValidParsedFormatArgTest<T>(nullptr));
657  TEST_F(ParsedFormatTest, OnlyValidTypesAllowed) {
658    ASSERT_TRUE(IsValidParsedFormatArg<'c'>::value);
659    ASSERT_TRUE(IsValidParsedFormatArg<FormatConversionCharSet::d>::value);
660    ASSERT_TRUE(IsValidParsedFormatArg<absl::FormatConversionCharSet::d |
661                                       absl::FormatConversionCharSet::x>::value);
662    ASSERT_TRUE(
663        IsValidParsedFormatArg<absl::FormatConversionCharSet::kIntegral>::value);
664    ASSERT_FALSE(IsValidParsedFormatArg<'x' | 'd'>::value);
665    ASSERT_FALSE(IsValidParsedFormatArg<absl::FormatConversionChar::d>::value);
666  }
667  TEST_F(ParsedFormatTest, ExtendedTyping) {
668    EXPECT_FALSE(ParsedFormat<FormatConversionCharSet::d>::New(""));
669    ASSERT_TRUE(ParsedFormat<absl::FormatConversionCharSet::d>::New("%d"));
670    auto v1 = ParsedFormat<'d', absl::FormatConversionCharSet::s>::New("%d%s");
671    ASSERT_TRUE(v1);
672    auto v2 = ParsedFormat<absl::FormatConversionCharSet::d, 's'>::New("%d%s");
673    ASSERT_TRUE(v2);
674    auto v3 = ParsedFormat<absl::FormatConversionCharSet::d |
675                               absl::FormatConversionCharSet::s,
676                           's'>::New("%d%s");
677    ASSERT_TRUE(v3);
678    auto v4 = ParsedFormat<absl::FormatConversionCharSet::d |
679                               absl::FormatConversionCharSet::s,
680                           's'>::New("%s%s");
681    ASSERT_TRUE(v4);
682  }
683  TEST_F(ParsedFormatTest, ExtendedTypingWithV) {
684    EXPECT_FALSE(ParsedFormat<FormatConversionCharSet::v>::New(""));
685    ASSERT_TRUE(ParsedFormat<absl::FormatConversionCharSet::v>::New("%v"));
686    auto v1 = ParsedFormat<'v', absl::FormatConversionCharSet::v>::New("%v%v");
687    ASSERT_TRUE(v1);
688    auto v2 = ParsedFormat<absl::FormatConversionCharSet::v, 'v'>::New("%v%v");
689    ASSERT_TRUE(v2);
690    auto v3 = ParsedFormat<absl::FormatConversionCharSet::v |
691                               absl::FormatConversionCharSet::v,
692                           'v'>::New("%v%v");
693    ASSERT_TRUE(v3);
694    auto v4 = ParsedFormat<absl::FormatConversionCharSet::v |
695                               absl::FormatConversionCharSet::v,
696                           'v'>::New("%v%v");
697    ASSERT_TRUE(v4);
698  }
699  #endif
700  TEST_F(ParsedFormatTest, UncheckedCorrect) {
701    auto f =
702        ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New("ABC%dDEF");
703    ASSERT_TRUE(f);
704    EXPECT_EQ("[ABC]{d:1$d}[DEF]", SummarizeParsedFormat(*f));
705    std::string format = "%sFFF%dZZZ%f";
706    auto f2 = ExtendedParsedFormat<
707        absl::FormatConversionCharSet::kString, absl::FormatConversionCharSet::d,
708        absl::FormatConversionCharSet::kFloating>::New(format);
709    ASSERT_TRUE(f2);
710    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
711    f2 = ExtendedParsedFormat<
712        absl::FormatConversionCharSet::kString, absl::FormatConversionCharSet::d,
713        absl::FormatConversionCharSet::kFloating>::New("%s %d %f");
714    ASSERT_TRUE(f2);
715    EXPECT_EQ("{s:1$s}[ ]{d:2$d}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
716    auto star =
717        ExtendedParsedFormat<absl::FormatConversionCharSet::kStar,
718                             absl::FormatConversionCharSet::d>::New("%*d");
719    ASSERT_TRUE(star);
720    EXPECT_EQ("{*d:2$1$*d}", SummarizeParsedFormat(*star));
721    auto dollar =
722        ExtendedParsedFormat<absl::FormatConversionCharSet::d,
723                             absl::FormatConversionCharSet::s>::New("%2$s %1$d");
724    ASSERT_TRUE(dollar);
725    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}", SummarizeParsedFormat(*dollar));
726    dollar = ExtendedParsedFormat<
727        absl::FormatConversionCharSet::d,
728        absl::FormatConversionCharSet::s>::New("%2$s %1$d %1$d");
729    ASSERT_TRUE(dollar);
730    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}[ ]{1$d:1$d}",
731              SummarizeParsedFormat(*dollar));
732  }
733  TEST_F(ParsedFormatTest, UncheckedCorrectWithV) {
734    auto f =
735        ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New("ABC%vDEF");
736    ASSERT_TRUE(f);
737    EXPECT_EQ("[ABC]{v:1$v}[DEF]", SummarizeParsedFormat(*f));
738    std::string format = "%vFFF%vZZZ%f";
739    auto f2 = ExtendedParsedFormat<
740        absl::FormatConversionCharSet::v, absl::FormatConversionCharSet::v,
741        absl::FormatConversionCharSet::kFloating>::New(format);
742    ASSERT_TRUE(f2);
743    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
744    f2 = ExtendedParsedFormat<
745        absl::FormatConversionCharSet::v, absl::FormatConversionCharSet::v,
746        absl::FormatConversionCharSet::kFloating>::New("%v %v %f");
747    ASSERT_TRUE(f2);
748    EXPECT_EQ("{v:1$v}[ ]{v:2$v}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
749  }
750  TEST_F(ParsedFormatTest, UncheckedIgnoredArgs) {
751    EXPECT_FALSE(
752        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
753                              absl::FormatConversionCharSet::s>::New("ABC")));
754    EXPECT_FALSE(
755        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
756                              absl::FormatConversionCharSet::s>::New("%dABC")));
757    EXPECT_FALSE(
758        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
759                              absl::FormatConversionCharSet::s>::New("ABC%2$s")));
760    auto f = ExtendedParsedFormat<
761        absl::FormatConversionCharSet::d,
762        absl::FormatConversionCharSet::s>::NewAllowIgnored("ABC");
763    ASSERT_TRUE(f);
764    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
765    f = ExtendedParsedFormat<
766        absl::FormatConversionCharSet::d,
767        absl::FormatConversionCharSet::s>::NewAllowIgnored("%dABC");
768    ASSERT_TRUE(f);
769    EXPECT_EQ("{d:1$d}[ABC]", SummarizeParsedFormat(*f));
770    f = ExtendedParsedFormat<
771        absl::FormatConversionCharSet::d,
772        absl::FormatConversionCharSet::s>::NewAllowIgnored("ABC%2$s");
773    ASSERT_TRUE(f);
774    EXPECT_EQ("[ABC]{2$s:2$s}", SummarizeParsedFormat(*f));
775  }
776  TEST_F(ParsedFormatTest, UncheckedIgnoredArgsWithV) {
777    EXPECT_FALSE(
778        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
779                              absl::FormatConversionCharSet::v>::New("ABC")));
780    EXPECT_FALSE(
781        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
782                              absl::FormatConversionCharSet::v>::New("%vABC")));
783    EXPECT_FALSE((ExtendedParsedFormat<absl::FormatConversionCharSet::v,
784                                       absl::FormatConversionCharSet::s>::
785                      New("ABC%2$s")));
786    auto f = ExtendedParsedFormat<
787        absl::FormatConversionCharSet::v,
788        absl::FormatConversionCharSet::v>::NewAllowIgnored("ABC");
789    ASSERT_TRUE(f);
790    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
791    f = ExtendedParsedFormat<
792        absl::FormatConversionCharSet::v,
793        absl::FormatConversionCharSet::v>::NewAllowIgnored("%vABC");
794    ASSERT_TRUE(f);
795    EXPECT_EQ("{v:1$v}[ABC]", SummarizeParsedFormat(*f));
796  }
797  TEST_F(ParsedFormatTest, UncheckedMultipleTypes) {
798    auto dx =
799        ExtendedParsedFormat<absl::FormatConversionCharSet::d |
800                             absl::FormatConversionCharSet::x>::New("%1$d %1$x");
801    EXPECT_TRUE(dx);
802    EXPECT_EQ("{1$d:1$d}[ ]{1$x:1$x}", SummarizeParsedFormat(*dx));
803    dx = ExtendedParsedFormat<absl::FormatConversionCharSet::d |
804                              absl::FormatConversionCharSet::x>::New("%1$d");
805    EXPECT_TRUE(dx);
806    EXPECT_EQ("{1$d:1$d}", SummarizeParsedFormat(*dx));
807  }
808  TEST_F(ParsedFormatTest, UncheckedIncorrect) {
809    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New(""));
810    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New(
811        "ABC%dDEF%d"));
812    std::string format = "%sFFF%dZZZ%f";
813    EXPECT_FALSE(
814        (ExtendedParsedFormat<absl::FormatConversionCharSet::s,
815                              absl::FormatConversionCharSet::d,
816                              absl::FormatConversionCharSet::g>::New(format)));
817  }
818  TEST_F(ParsedFormatTest, UncheckedIncorrectWithV) {
819    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New(""));
820    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New(
821        "ABC%vDEF%v"));
822    std::string format = "%vFFF%vZZZ%f";
823    EXPECT_FALSE(
824        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
825                              absl::FormatConversionCharSet::g>::New(format)));
826  }
827  TEST_F(ParsedFormatTest, RegressionMixPositional) {
828    EXPECT_FALSE(
829        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
830                              absl::FormatConversionCharSet::o>::New("%1$d %o")));
831  }
832  TEST_F(ParsedFormatTest, DisallowModifiersWithV) {
833    auto f = ParsedFormat<'v'>::New("ABC%80vDEF");
834    EXPECT_EQ(f, nullptr);
835    f = ParsedFormat<'v'>::New("ABC%0vDEF");
836    EXPECT_EQ(f, nullptr);
837    f = ParsedFormat<'v'>::New("ABC%.1vDEF");
838    EXPECT_EQ(f, nullptr);
839  }
840  using FormatWrapperTest = ::testing::Test;
841  template <typename... Args>
842  std::string WrappedFormat(const absl::FormatSpec<Args...>& format,
843                            const Args&... args) {
844    return StrFormat(format, args...);
845  }
846  TEST_F(FormatWrapperTest, ConstexprStringFormat) {
847    EXPECT_EQ(WrappedFormat("%s there", "hello"), "hello there");
848  }
849  TEST_F(FormatWrapperTest, ConstexprStringFormatWithV) {
850    std::string hello = "hello";
851    EXPECT_EQ(WrappedFormat("%v there", hello), "hello there");
852  }
853  TEST_F(FormatWrapperTest, ParsedFormat) {
854    ParsedFormat<'s'> format("%s there");
855    EXPECT_EQ(WrappedFormat(format, "hello"), "hello there");
856  }
857  TEST_F(FormatWrapperTest, ParsedFormatWithV) {
858    std::string hello = "hello";
859    ParsedFormat<'v'> format("%v there");
860    EXPECT_EQ(WrappedFormat(format, hello), "hello there");
861  }
862  }  
863  ABSL_NAMESPACE_END
864  }  
865  namespace {
866  using FormatExtensionTest = ::testing::Test;
867  struct Point {
868    friend absl::FormatConvertResult<absl::FormatConversionCharSet::kString |
869                                     absl::FormatConversionCharSet::kIntegral |
870                                     absl::FormatConversionCharSet::v>
871    AbslFormatConvert(const Point& p, const absl::FormatConversionSpec& spec,
872                      absl::FormatSink* s) {
873      if (spec.conversion_char() == absl::FormatConversionChar::s) {
874        s->Append(absl::StrCat("x=", p.x, " y=", p.y));
875      } else {
876        s->Append(absl::StrCat(p.x, ",", p.y));
877      }
878      return {true};
879    }
880    int x = 10;
881    int y = 20;
882  };
883  TEST_F(FormatExtensionTest, AbslFormatConvertExample) {
884    Point p;
885    EXPECT_EQ(absl::StrFormat("a %s z", p), "a x=10 y=20 z");
886    EXPECT_EQ(absl::StrFormat("a %d z", p), "a 10,20 z");
887    EXPECT_EQ(absl::StrFormat("a %v z", p), "a 10,20 z");
888    std::string actual;
889    absl::UntypedFormatSpec f1("%f");
890    EXPECT_FALSE(absl::FormatUntyped(&actual, f1, {absl::FormatArg(p)}));
891  }
892  struct PointStringify {
893    template <typename FormatSink>
894    friend void AbslStringify(FormatSink& sink, const PointStringify& p) {
895      sink.Append(absl::StrCat("(", p.x, ", ", p.y, ")"));
896    }
897    double x = 10.0;
898    double y = 20.0;
899  };
900  TEST_F(FormatExtensionTest, AbslStringifyExample) {
901    PointStringify p;
902    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
903  }
904  struct PointStringifyUsingFormat {
905    template <typename FormatSink>
906    friend void AbslStringify(FormatSink& sink,
907                              const PointStringifyUsingFormat& p) {
908      absl::Format(&sink, "(%g, %g)", p.x, p.y);
909    }
910    double x = 10.0;
911    double y = 20.0;
912  };
913  TEST_F(FormatExtensionTest, AbslStringifyExampleUsingFormat) {
914    PointStringifyUsingFormat p;
915    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
916  }
917  enum class EnumClassWithStringify { Many = 0, Choices = 1 };
918  template <typename Sink>
919  void AbslStringify(Sink& sink, EnumClassWithStringify e) {
920    absl::Format(&sink, "%s",
921                 e == EnumClassWithStringify::Many ? "Many" : "Choices");
922  }
923  enum EnumWithStringify { Many, Choices };
924  template <typename Sink>
925  void AbslStringify(Sink& sink, EnumWithStringify e) {
926    absl::Format(&sink, "%s", e == EnumWithStringify::Many ? "Many" : "Choices");
927  }
928  TEST_F(FormatExtensionTest, AbslStringifyWithEnumWithV) {
929    const auto e_class = EnumClassWithStringify::Choices;
930    EXPECT_EQ(absl::StrFormat("My choice is %v", e_class),
931              "My choice is Choices");
932    const auto e = EnumWithStringify::Choices;
933    EXPECT_EQ(absl::StrFormat("My choice is %v", e), "My choice is Choices");
934  }
935  TEST_F(FormatExtensionTest, AbslStringifyEnumWithD) {
936    const auto e_class = EnumClassWithStringify::Many;
937    EXPECT_EQ(absl::StrFormat("My choice is %d", e_class), "My choice is 0");
938    const auto e = EnumWithStringify::Choices;
939    EXPECT_EQ(absl::StrFormat("My choice is %d", e), "My choice is 1");
940  }
941  enum class EnumWithLargerValue { x = 32 };
942  template <typename Sink>
943  void AbslStringify(Sink& sink, EnumWithLargerValue e) {
944    absl::Format(&sink, "%s", "Many");
945  }
946  TEST_F(FormatExtensionTest, AbslStringifyEnumOtherSpecifiers) {
947    const auto e = EnumWithLargerValue::x;
948    EXPECT_EQ(absl::StrFormat("My choice is %g", e), "My choice is 32");
949    EXPECT_EQ(absl::StrFormat("My choice is %x", e), "My choice is 20");
950  }
951  }  
952  std::string CodegenAbslStrFormatInt(int i) {  
953    return absl::StrFormat("%d", i);
954  }
955  std::string CodegenAbslStrFormatIntStringInt64(int i, const std::string& s,
956                                                 int64_t i64) {  
957    return absl::StrFormat("%d %s %d", i, s, i64);
958  }
959  void CodegenAbslStrAppendFormatInt(std::string* out, int i) {  
960    absl::StrAppendFormat(out, "%d", i);
961  }
962  void CodegenAbslStrAppendFormatIntStringInt64(std::string* out, int i,
963                                                const std::string& s,
964                                                int64_t i64) {  
965    absl::StrAppendFormat(out, "%d %s %d", i, s, i64);
966  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_convolution_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>192  TYPED_TEST(MKLConvolutionLayerTest, TestSetupMKL) {
193    typedef typename TypeParam::Dtype Dtype;
194    LayerParameter layer_param;
195    ConvolutionParameter* convolution_param =
196        layer_param.mutable_convolution_param();
197    convolution_param->add_kernel_size(3);
198    convolution_param->add_stride(2);
199    convolution_param->set_num_output(4);
200    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
201    this->blob_top_vec_.push_back(this->blob_top_2_);
</pre></code></div>
                <div class="column column_space"><pre><code>289    va_start(va, fmt);
290    int r = vsnprintf(&*buf.begin(), buf.size(), fmt, va);
291    va_end(va);
292    EXPECT_GE(r, 0);
293    EXPECT_LT(r, buf.size());
294    buf.resize(r);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    