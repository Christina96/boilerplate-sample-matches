
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.355413303645978%, Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Platform.h</h3>
            <pre><code>1  #ifndef PLATFORM_H
2  #define PLATFORM_H
3  #define PLAT_GTK 0
4  #define PLAT_GTK_WIN32 0
5  #define PLAT_GTK_MACOSX 0
6  #define PLAT_MACOSX 0
7  #define PLAT_WIN 0
8  #define PLAT_WX  0
9  #define PLAT_QT 0
10  #define PLAT_QT_QML 0
11  #define PLAT_FOX 0
12  #define PLAT_CURSES 0
13  #define PLAT_TK 0
14  #define PLAT_HAIKU 0
15  #if defined(FOX)
16  #undef PLAT_FOX
17  #define PLAT_FOX 1
18  #elif defined(__WX__)
19  #undef PLAT_WX
20  #define PLAT_WX  1
21  #elif defined(CURSES)
22  #undef PLAT_CURSES
23  #define PLAT_CURSES 1
24  #elif defined(__HAIKU__)
25  #undef PLAT_HAIKU
26  #define PLAT_HAIKU 1
27  #elif defined(SCINTILLA_QT)
28  #undef PLAT_QT
29  #define PLAT_QT 1
30  #elif defined(SCINTILLA_QT_QML)
31  #undef PLAT_QT_QML
32  #define PLAT_QT_QML 1
33  #elif defined(TK)
34  #undef PLAT_TK
35  #define PLAT_TK 1
36  #elif defined(GTK)
37  #undef PLAT_GTK
38  #define PLAT_GTK 1
39  #if defined(__WIN32__) || defined(_MSC_VER)
40  #undef PLAT_GTK_WIN32
41  #define PLAT_GTK_WIN32 1
42  #endif
43  #if defined(__APPLE__)
44  #undef PLAT_GTK_MACOSX
45  #define PLAT_GTK_MACOSX 1
46  #endif
47  #elif defined(__APPLE__)
48  #undef PLAT_MACOSX
49  #define PLAT_MACOSX 1
50  #else
51  #undef PLAT_WIN
52  #define PLAT_WIN 1
53  #endif
54  namespace Scintilla::Internal {
55  typedef void *SurfaceID;
56  typedef void *WindowID;
57  typedef void *MenuID;
58  typedef void *TickerID;
59  typedef void *Function;
60  typedef void *IdlerID;
61  constexpr const char *localeNameDefault = "en-us";
62  struct FontParameters {
63  	const char *faceName;
64  	XYPOSITION size;
65  	Scintilla::FontWeight weight;
66  	bool italic;
67  	Scintilla::FontQuality extraFontFlag;
68  	Scintilla::Technology technology;
69  	Scintilla::CharacterSet characterSet;
70  	const char *localeName;
71  	constexpr FontParameters(
72  		const char *faceName_,
73  		XYPOSITION size_=10,
74  		Scintilla::FontWeight weight_= Scintilla::FontWeight::Normal,
75  		bool italic_=false,
76  		Scintilla::FontQuality extraFontFlag_= Scintilla::FontQuality::QualityDefault,
77  		Scintilla::Technology technology_= Scintilla::Technology::Default,
78  		Scintilla::CharacterSet characterSet_= Scintilla::CharacterSet::Ansi,
79  		const char *localeName_=localeNameDefault) noexcept :
80  		faceName(faceName_),
81  		size(size_),
82  		weight(weight_),
83  		italic(italic_),
84  		extraFontFlag(extraFontFlag_),
85  		technology(technology_),
86  		characterSet(characterSet_),
87  		localeName(localeName_)
88  	{
89  	}
90  };
91  class Font {
92  public:
93  	Font() noexcept = default;
94  	Font(const Font &) = delete;
95  	Font(Font &&) = delete;
96  	Font &operator=(const Font &) = delete;
97  	Font &operator=(Font &&) = delete;
98  	virtual ~Font() noexcept = default;
99  	static std::shared_ptr<Font> Allocate(const FontParameters &fp);
100  };
101  class IScreenLine {
102  public:
103  	virtual std::string_view Text() const = 0;
104  	virtual size_t Length() const = 0;
105  	virtual size_t RepresentationCount() const = 0;
106  	virtual XYPOSITION Width() const = 0;
107  	virtual XYPOSITION Height() const = 0;
108  	virtual XYPOSITION TabWidth() const = 0;
109  	virtual XYPOSITION TabWidthMinimumPixels() const = 0;
110  	virtual const Font *FontOfPosition(size_t position) const = 0;
111  	virtual XYPOSITION RepresentationWidth(size_t position) const = 0;
112  	virtual XYPOSITION TabPositionAfter(XYPOSITION xPosition) const = 0;
113  };
114  class IScreenLineLayout {
115  public:
116  	virtual ~IScreenLineLayout() noexcept = default;
117  	virtual size_t PositionFromX(XYPOSITION xDistance, bool charPosition) = 0;
118  	virtual XYPOSITION XFromPosition(size_t caretPosition) = 0;
119  	virtual std::vector<Interval> FindRangeIntervals(size_t start, size_t end) = 0;
120  };
121  struct SurfaceMode {
122  	int codePage = 0;
123  	bool bidiR2L = false;
124  	SurfaceMode() = default;
125  	explicit SurfaceMode(int codePage_, bool bidiR2L_) noexcept : codePage(codePage_), bidiR2L(bidiR2L_) {
126  	}
127  };
128  class Surface {
129  public:
130  	Surface() noexcept = default;
131  	Surface(const Surface &) = delete;
132  	Surface(Surface &&) = delete;
133  	Surface &operator=(const Surface &) = delete;
134  	Surface &operator=(Surface &&) = delete;
135  	virtual ~Surface() noexcept = default;
136  	static std::unique_ptr<Surface> Allocate(Scintilla::Technology technology);
137  	virtual void Init(WindowID wid)=0;
138  	virtual void Init(SurfaceID sid, WindowID wid)=0;
139  	virtual std::unique_ptr<Surface> AllocatePixMap(int width, int height)=0;
140  	virtual void SetMode(SurfaceMode mode)=0;
141  	enum class Ends {
142  		semiCircles = 0x0,
143  		leftFlat = 0x1,
144  		leftAngle = 0x2,
145  		rightFlat = 0x10,
146  		rightAngle = 0x20,
147  	};
148  	virtual void Release() noexcept=0;
149  	virtual int SupportsFeature(Scintilla::Supports feature) noexcept=0;
150  	virtual bool Initialised()=0;
151  	virtual int LogPixelsY()=0;
152  	virtual int PixelDivisions()=0;
153  	virtual int DeviceHeightFont(int points)=0;
154  	virtual void LineDraw(Point start, Point end, Stroke stroke)=0;
155  	virtual void PolyLine(const Point *pts, size_t npts, Stroke stroke)=0;
156  	virtual void Polygon(const Point *pts, size_t npts, FillStroke fillStroke)=0;
157  	virtual void RectangleDraw(PRectangle rc, FillStroke fillStroke)=0;
158  	virtual void RectangleFrame(PRectangle rc, Stroke stroke)=0;
159  	virtual void FillRectangle(PRectangle rc, Fill fill)=0;
160  	virtual void FillRectangleAligned(PRectangle rc, Fill fill)=0;
161  	virtual void FillRectangle(PRectangle rc, Surface &surfacePattern)=0;
162  	virtual void RoundedRectangle(PRectangle rc, FillStroke fillStroke)=0;
163  	virtual void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke)=0;
164  	enum class GradientOptions { leftToRight, topToBottom };
165  	virtual void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options)=0;
166  	virtual void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) = 0;
167  	virtual void Ellipse(PRectangle rc, FillStroke fillStroke)=0;
168  	virtual void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends)=0;
169  	virtual void Copy(PRectangle rc, Point from, Surface &surfaceSource)=0;
170  	virtual std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) = 0;
171  	virtual void DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
172  	virtual void DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
173  	virtual void DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) = 0;
174  	virtual void MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) = 0;
175  	virtual XYPOSITION WidthText(const Font *font_, std::string_view text) = 0;
176  	virtual void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
177  	virtual void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
178  	virtual void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) = 0;
179  	virtual void MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) = 0;
180  	virtual XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) = 0;
181  	virtual XYPOSITION Ascent(const Font *font_)=0;
182  	virtual XYPOSITION Descent(const Font *font_)=0;
183  	virtual XYPOSITION InternalLeading(const Font *font_)=0;
184  	virtual XYPOSITION Height(const Font *font_)=0;
185  	virtual XYPOSITION AverageCharWidth(const Font *font_)=0;
186  	virtual void SetClip(PRectangle rc)=0;
187  	virtual void PopClip()=0;
188  	virtual void FlushCachedState()=0;
189  	virtual void FlushDrawing()=0;
190  };
191  class Window {
192  protected:
193  	WindowID wid;
194  public:
195  	Window() noexcept : wid(nullptr), cursorLast(Cursor::invalid) {
196  	}
197  	Window(const Window &source) = delete;
198  	Window(Window &&) = delete;
199  	Window &operator=(WindowID wid_) noexcept {
200  		wid = wid_;
201  		cursorLast = Cursor::invalid;
202  		return *this;
203  	}
204  	Window &operator=(const Window &) = delete;
205  	Window &operator=(Window &&) = delete;
206  	virtual ~Window() noexcept;
207  	WindowID GetID() const noexcept { return wid; }
<span onclick='openModal()' class='match'>208  	bool Created() const noexcept { return wid != nullptr; }
209  	void Destroy() noexcept;
210  	PRectangle GetPosition() const;
211  	void SetPosition(PRectangle rc);
212  	void SetPositionRelative(PRectangle rc, const Window *relativeTo);
213  	PRectangle GetClientPosition() const;
214  	void Show(bool show=true);
215  	void InvalidateAll();
216  	void InvalidateRectangle(PRectangle rc);
</span>217  	enum class Cursor { invalid, text, arrow, up, wait, horizontal, vertical, reverseArrow, hand };
218  	void SetCursor(Cursor curs);
219  	PRectangle GetMonitorRect(Point pt);
220  private:
221  	Cursor cursorLast;
222  };
223  struct ListBoxEvent {
224  	enum class EventType { selectionChange, doubleClick } event;
225  	ListBoxEvent(EventType event_) noexcept : event(event_) {
226  	}
227  };
228  class IListBoxDelegate {
229  public:
230  	virtual void ListNotify(ListBoxEvent *plbe)=0;
231  };
232  struct ListOptions {
233  	std::optional<ColourRGBA> fore;
234  	std::optional<ColourRGBA> back;
235  	std::optional<ColourRGBA> foreSelected;
236  	std::optional<ColourRGBA> backSelected;
237  	AutoCompleteOption options=AutoCompleteOption::Normal;
238  };
239  class ListBox : public Window {
240  public:
241  	ListBox() noexcept;
242  	~ListBox() noexcept override;
243  	static std::unique_ptr<ListBox> Allocate();
244  	virtual void SetFont(const Font *font)=0;
245  	virtual void Create(Window &parent, int ctrlID, Point location, int lineHeight_, bool unicodeMode_, Scintilla::Technology technology_)=0;
246  	virtual void SetAverageCharWidth(int width)=0;
247  	virtual void SetVisibleRows(int rows)=0;
248  	virtual int GetVisibleRows() const=0;
249  	virtual PRectangle GetDesiredRect()=0;
250  	virtual int CaretFromEdge()=0;
251  	virtual void Clear() noexcept=0;
252  	virtual void Append(char *s, int type = -1)=0;
253  	virtual int Length()=0;
254  	virtual void Select(int n)=0;
255  	virtual int GetSelection()=0;
256  	virtual int Find(const char *prefix)=0;
257  	virtual std::string GetValue(int n)=0;
258  	virtual void RegisterImage(int type, const char *xpm_data)=0;
259  	virtual void RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) = 0;
260  	virtual void ClearRegisteredImages()=0;
261  	virtual void SetDelegate(IListBoxDelegate *lbDelegate)=0;
262  	virtual void SetList(const char* list, char separator, char typesep)=0;
263  	virtual void SetOptions(ListOptions options_)=0;
264  };
265  class Menu {
266  	MenuID mid;
267  public:
268  	Menu() noexcept;
269  	MenuID GetID() const noexcept { return mid; }
270  	void CreatePopUp();
271  	void Destroy() noexcept;
272  	void Show(Point pt, const Window &w);
273  };
274  namespace Platform {
275  ColourRGBA Chrome();
276  ColourRGBA ChromeHighlight();
277  const char *DefaultFont();
278  int DefaultFontSize();
279  unsigned int DoubleClickTime();
280  constexpr long LongFromTwoShorts(short a,short b) noexcept {
281  	return (a) | ((b) << 16);
282  }
283  }
284  }
285  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph_3.h</h3>
            <pre><code>1  class TUNGraph;
2  class TBPGraph;
3  class THGraph;
4  typedef TPt<TUNGraph> PUNGraph;
5  typedef TPt<TBPGraph> PBPGraph;
6  typedef TPt<THGraph> PHGraph;
7  class TNGraph;
8  class TNEGraph;
9  typedef TPt<TNGraph> PNGraph;
10  typedef TPt<TNEGraph> PNEGraph;
11  class TUNGraph {
12  public:
13    typedef TUNGraph TNet;
14    typedef TPt<TUNGraph> PNet;
15  public:
16    class TNode {
17    private:
18      TInt Id;
19      TIntV NIdV;
20    public:
21      TNode() : Id(-1), NIdV() { }
22      TNode(const int& NId) : Id(NId), NIdV() { }
23      TNode(const TNode& Node) : Id(Node.Id), NIdV(Node.NIdV) { }
24      TNode(TSIn& SIn) : Id(SIn), NIdV(SIn) { }
25      void LoadShM(TShMIn& ShMIn) {
26        Id = TInt(ShMIn);
27        NIdV.LoadShM(ShMIn);
28      }
29      void Save(TSOut& SOut) const { Id.Save(SOut); NIdV.Save(SOut); }
30      int GetId() const { return Id; }
31      int GetDeg() const { return NIdV.Len(); }
32      int GetInDeg() const { return GetDeg(); }
33      int GetOutDeg() const { return GetDeg(); }
34      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
35      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
36      int GetNbrNId(const int& NodeN) const { return NIdV[NodeN]; }
37      bool IsNbrNId(const int& NId) const { return NIdV.SearchBin(NId)!=-1; }
38      bool IsInNId(const int& NId) const { return IsNbrNId(NId); }
39      bool IsOutNId(const int& NId) const { return IsNbrNId(NId); }
40      void PackOutNIdV() { NIdV.Pack(); }
41      void PackNIdV() { NIdV.Pack(); }
42      void SortNIdV() { NIdV.Sort();}
43      friend class TUNGraph;
44      friend class TUNGraphMtx;
45    };
46    class TNodeI {
47    private:
48      typedef THash<TInt, TNode>::TIter THashIter;
49      THashIter NodeHI;
50    public:
51      TNodeI() : NodeHI() { }
52      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
53      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
54      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
55      TNodeI& operator++ (int) { NodeHI++; return *this; }
56      TNodeI& operator-- (int) { NodeHI--; return *this; }
57      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
58      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
59      int GetId() const { return NodeHI.GetDat().GetId(); }
60      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
61      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
62      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
63      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
64      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
65      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
66      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
67      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
68      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
69      bool IsNbrNId(const int& NId) const { return NodeHI.GetDat().IsNbrNId(NId); }
70      friend class TUNGraph;
71    };
72    class TEdgeI {
73    private:
74      TNodeI CurNode, EndNode;
75      int CurEdge;
76    public:
77      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
78      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
79      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
80      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; } return *this; }
81      TEdgeI& operator++ (int) { do { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++; while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } } } while (CurNode < EndNode && GetSrcNId()>GetDstNId()); return *this; }
82      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
83      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
84      int GetId() const { return -1; }
85      int GetSrcNId() const { return CurNode.GetId(); }
86      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
87      friend class TUNGraph;
88    };
89  private:
90    TCRef CRef;
91    TInt MxNId, NEdges;
92    THash<TInt, TNode> NodeH;
93  private:
94    class TLoadTNodeInitializer {
95    public:
96      TLoadTNodeInitializer() {}
97      void operator() (TNode* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
98    };
99  private:
100    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
101    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
102    void LoadGraphShM(TShMIn& ShMIn) {
103      MxNId = TInt(ShMIn);
104      NEdges = TInt(ShMIn);
105      TLoadTNodeInitializer Fn;
106      NodeH.LoadShM(ShMIn, Fn);
107    }
108  public:
109    TUNGraph() : CRef(), MxNId(0), NEdges(0), NodeH() { }
110    explicit TUNGraph(const int& Nodes, const int& Edges) : MxNId(0), NEdges(0) { Reserve(Nodes, Edges); }
111    TUNGraph(const TUNGraph& Graph) : MxNId(Graph.MxNId), NEdges(Graph.NEdges), NodeH(Graph.NodeH) { }
112    TUNGraph(TSIn& SIn) : MxNId(SIn), NEdges(SIn), NodeH(SIn) { }
113    void Save(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut); SOut.Flush(); }
114    static PUNGraph New() { return new TUNGraph(); }
115    static PUNGraph New(const int& Nodes, const int& Edges) { return new TUNGraph(Nodes, Edges); }
116    static PUNGraph Load(TSIn& SIn) { return PUNGraph(new TUNGraph(SIn)); }
117    static PUNGraph LoadShM(TShMIn& ShMIn) {
118      TUNGraph* Graph = new TUNGraph();
119      Graph->LoadGraphShM(ShMIn);
120      return PUNGraph(Graph);
121    }  
122    bool HasFlag(const TGraphFlag& Flag) const;
123    TUNGraph& operator = (const TUNGraph& Graph) {
124      if (this!=&Graph) { MxNId=Graph.MxNId; NEdges=Graph.NEdges; NodeH=Graph.NodeH; } return *this; }
125    int GetNodes() const { return NodeH.Len(); }
126    int AddNode(int NId = -1);
127    int AddNodeUnchecked(int NId = -1);
128    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId()); }
129    int AddNode(const int& NId, const TIntV& NbrNIdV);
130    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId);
131    void DelNode(const int& NId);
132    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
133    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
134    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
135    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
136    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
137    int GetMxNId() const { return MxNId; }
138    int GetEdges() const;
139    int AddEdge(const int& SrcNId, const int& DstNId);
140    int AddEdge(const int& SrcNId, const int& DstNId, const int& EId) { return AddEdge(SrcNId, DstNId); }
141    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
142    int AddEdge2(const int& SrcNId, const int& DstNId);
143    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
144    void DelEdge(const int& SrcNId, const int& DstNId);
145    bool IsEdge(const int& SrcNId, const int& DstNId) const;
146    bool IsEdge(const int& EId) const { return false; }
147    TEdgeI BegEI() const { TNodeI NI = BegNI(); TEdgeI EI(NI, EndNI(), 0); if (GetNodes() != 0 && (NI.GetOutDeg()==0 || NI.GetId()>NI.GetOutNId(0))) { EI++; } return EI; }
148    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
149    TEdgeI GetEI(const int& EId) const;
150    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
151    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
152    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
153    void GetNIdV(TIntV& NIdV) const;
154    bool Empty() const { return GetNodes()==0; }
155    void Clr() { MxNId=0; NEdges=0; NodeH.Clr(); }
156    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
157    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) NodeH.Gen(Nodes/2); }
158    void ReserveNIdDeg(const int& NId, const int& Deg) { GetNode(NId).NIdV.Reserve(Deg); }
159    void Defrag(const bool& OnlyNodeLinks=false);
160    bool IsOk(const bool& ThrowExcept=true) const;
161    void Dump(FILE *OutF=stdout) const;
162    static PUNGraph GetSmallGraph();
163    friend class TUNGraphMtx;
164    friend class TPt<TUNGraph>;
165  };
166  class TNGraph {
167  public:
168    typedef TNGraph TNet;
169    typedef TPt<TNGraph> PNet;
170  public:
171    class TNode {
172    private:
173      TInt Id;
174      TIntV InNIdV, OutNIdV;
175    public:
176      TNode() : Id(-1), InNIdV(), OutNIdV() { }
177      TNode(const int& NId) : Id(NId), InNIdV(), OutNIdV() { }
178      TNode(const TNode& Node) : Id(Node.Id), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
179      TNode(TSIn& SIn) : Id(SIn), InNIdV(SIn), OutNIdV(SIn) { }
180      void Save(TSOut& SOut) const { Id.Save(SOut); InNIdV.Save(SOut); OutNIdV.Save(SOut); }
181      int GetId() const { return Id; }
182      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
183      int GetInDeg() const { return InNIdV.Len(); }
184      int GetOutDeg() const { return OutNIdV.Len(); }
185      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
186      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
187      int GetNbrNId(const int& NodeN) const { return NodeN<GetOutDeg()?GetOutNId(NodeN):GetInNId(NodeN-GetOutDeg()); }
188      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId) != -1; }
189      bool IsOutNId(const int& NId) const { return OutNIdV.SearchBin(NId) != -1; }
190      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
191      void PackOutNIdV() { OutNIdV.Pack(); }
192      void PackNIdV() { InNIdV.Pack(); }
193      void SortNIdV() { InNIdV.Sort(); OutNIdV.Sort();}
194      void LoadShM(TShMIn& ShMIn) {
195        Id = TInt(ShMIn);
196        InNIdV.LoadShM(ShMIn);
197        OutNIdV.LoadShM(ShMIn);
198      }
199      friend class TNGraph;
200      friend class TNGraphMtx;
201    };
202    class TNodeI {
203    private:
204      typedef THash<TInt, TNode>::TIter THashIter;
205      THashIter NodeHI;
206    public:
207      TNodeI() : NodeHI() { }
208      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
209      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
210      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
211      TNodeI& operator++ (int) { NodeHI++; return *this; }
212      TNodeI& operator-- (int) { NodeHI--; return *this; }
213      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
214      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
215      int GetId() const { return NodeHI.GetDat().GetId(); }
216      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
217      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
218      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
219      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
220      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
221      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
222      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
223      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
224      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
225      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
226      friend class TNGraph;
227    };
228    class TEdgeI {
229    private:
230      TNodeI CurNode, EndNode;
231      int CurEdge;
232    public:
233      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
234      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
235      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
236      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
237      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
238        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
239      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
240      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
241      int GetId() const { return -1; }
242      int GetSrcNId() const { return CurNode.GetId(); }
243      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
244      friend class TNGraph;
245    };
246  private:
247    TCRef CRef;
248    TInt MxNId;
249    THash<TInt, TNode> NodeH;
250  private:
251    class TLoadTNodeInitializer {
252    public:
253      TLoadTNodeInitializer() {}
254      void operator() (TNode* Node, TShMIn& ShMIn) {Node->LoadShM(ShMIn);}
255    };
256  private:
257    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
258    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
259    void LoadGraphShM(TShMIn& ShMIn) {
260      MxNId = TInt(ShMIn);
261      TLoadTNodeInitializer Fn;
262      NodeH.LoadShM(ShMIn, Fn);
263    }
264  public:
265    TNGraph() : CRef(), MxNId(0), NodeH() { }
266    explicit TNGraph(const int& Nodes, const int& Edges) : MxNId(0) { Reserve(Nodes, Edges); }
267    TNGraph(const TNGraph& Graph) : MxNId(Graph.MxNId), NodeH(Graph.NodeH) { }
268    TNGraph(TSIn& SIn) : MxNId(SIn), NodeH(SIn) { }
269    void Save(TSOut& SOut) const { MxNId.Save(SOut); NodeH.Save(SOut); SOut.Flush(); }
270    static PNGraph New() { return new TNGraph(); }
271    static PNGraph New(const int& Nodes, const int& Edges) { return new TNGraph(Nodes, Edges); }
272    static PNGraph Load(TSIn& SIn) { return PNGraph(new TNGraph(SIn)); }
273    static PNGraph LoadShM(TShMIn& ShMIn) {
274      TNGraph* Graph = new TNGraph();
275      Graph->LoadGraphShM(ShMIn);
276      return PNGraph(Graph);
277    }
278    bool HasFlag(const TGraphFlag& Flag) const;
279    TNGraph& operator = (const TNGraph& Graph) {
280      if (this!=&Graph) { MxNId=Graph.MxNId; NodeH=Graph.NodeH; }  return *this; }
281    int GetNodes() const { return NodeH.Len(); }
282    int AddNode(int NId = -1);
283    int AddNodeUnchecked(int NId = -1);
<span onclick='openModal()' class='match'>284    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
285    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
286    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
287    void DelNode(const int& NId);
</span>288    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
289    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
290    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
291    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
292    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
293    int GetMxNId() const { return MxNId; }
294    int GetEdges() const;
295    int AddEdge(const int& SrcNId, const int& DstNId);
296    int AddEdge(const int& SrcNId, const int& DstNId, const int& EId) { return AddEdge(SrcNId, DstNId); }
297    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
298    int AddEdge2(const int& SrcNId, const int& DstNId);
299    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
300    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
301    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
302    bool IsEdge(const int& EId) const { return false; }
303    TEdgeI BegEI() const { TNodeI NI=BegNI(); while(NI<EndNI() && NI.GetOutDeg()==0){NI++;} return TEdgeI(NI, EndNI()); }
304    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
305    TEdgeI GetEI(const int& EId) const; 
306    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
307    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
308    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
309    void GetNIdV(TIntV& NIdV) const;
310    bool Empty() const { return GetNodes()==0; }
311    void Clr() { MxNId=0; NodeH.Clr(); }
312    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
313    void ReserveNIdInDeg(const int& NId, const int& InDeg) { GetNode(NId).InNIdV.Reserve(InDeg); }
314    void ReserveNIdOutDeg(const int& NId, const int& OutDeg) { GetNode(NId).OutNIdV.Reserve(OutDeg); }
315    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
316    void Defrag(const bool& OnlyNodeLinks=false);
317    bool IsOk(const bool& ThrowExcept=true) const;
318    void Dump(FILE *OutF=stdout) const;
319    static PNGraph GetSmallGraph();
320    friend class TPt<TNGraph>;
321    friend class TNGraphMtx;
322  };
323  namespace TSnap {
324  template <> struct IsDirected<TNGraph> { enum { Val = 1 }; };
325  }
326  class TNEGraph {
327  public:
328    typedef TNEGraph TNet;
329    typedef TPt<TNEGraph> PNet;
330  public:
331    class TNode {
332    private:
333      TInt Id;
334      TIntV InEIdV, OutEIdV;
335    public:
336      TNode() : Id(-1), InEIdV(), OutEIdV() { }
337      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV() { }
338      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV) { }
339      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn) { }
340      void Save(TSOut& SOut) const { Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut); }
341      int GetId() const { return Id; }
342      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
343      int GetInDeg() const { return InEIdV.Len(); }
344      int GetOutDeg() const { return OutEIdV.Len(); }
345      int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
346      int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
347      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
348      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
349      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
350      friend class TNEGraph;
351    };
352    class TEdge {
353    private:
354      TInt Id, SrcNId, DstNId;
355    public:
356      TEdge() : Id(-1), SrcNId(-1), DstNId(-1) { }
357      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
358      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
359      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn) { }
360      void Save(TSOut& SOut) const { Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
361      int GetId() const { return Id; }
362      int GetSrcNId() const { return SrcNId; }
363      int GetDstNId() const { return DstNId; }
364      friend class TNEGraph;
365    };
366    class TNodeI {
367    private:
368      typedef THash<TInt, TNode>::TIter THashIter;
369      THashIter NodeHI;
370      const TNEGraph *Graph;
371    public:
372      TNodeI() : NodeHI(), Graph(NULL) { }
373      TNodeI(const THashIter& NodeHIter, const TNEGraph* GraphPt) : NodeHI(NodeHIter), Graph(GraphPt) { }
374      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Graph(NodeI.Graph) { }
375      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
376      TNodeI& operator++ (int) { NodeHI++; return *this; }
377      TNodeI& operator-- (int) { NodeHI--; return *this; }
378      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
379      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
380      int GetId() const { return NodeHI.GetDat().GetId(); }
381      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
382      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
383      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
384      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
385      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
386      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN));
387        return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
388      bool IsInNId(const int& NId) const;
389      bool IsOutNId(const int& NId) const;
390      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
391      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
392      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
393      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
394      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
395      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
396      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
397      friend class TNEGraph;
398    };
399    class TEdgeI {
400    private:
401      typedef THash<TInt, TEdge>::TIter THashIter;
402      THashIter EdgeHI;
403      const TNEGraph *Graph;
404    public:
405      TEdgeI() : EdgeHI(), Graph(NULL) { }
406      TEdgeI(const THashIter& EdgeHIter, const TNEGraph *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
407      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
408      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
409      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
410      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
411      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
412      int GetId() const { return EdgeHI.GetDat().GetId(); }
413      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
414      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
415      friend class TNEGraph;
416    };
417  private:
418    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
419    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
420    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
421    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
422  private:
423    TCRef CRef;
424    TInt MxNId, MxEId;
425    THash<TInt, TNode> NodeH;
426    THash<TInt, TEdge> EdgeH;
427  public:
428    TNEGraph() : CRef(), MxNId(0), MxEId(0) { }
429    explicit TNEGraph(const int& Nodes, const int& Edges) : CRef(), MxNId(0), MxEId(0) { Reserve(Nodes, Edges); }
430    TNEGraph(const TNEGraph& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId), NodeH(Graph.NodeH), EdgeH(Graph.EdgeH) { }
431    TNEGraph(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn) { }
432    void Save(TSOut& SOut) const { MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut); SOut.Flush(); }
433    static PNEGraph New() { return PNEGraph(new TNEGraph()); }
434    static PNEGraph New(const int& Nodes, const int& Edges) { return PNEGraph(new TNEGraph(Nodes, Edges)); }
435    static PNEGraph Load(TSIn& SIn) { return PNEGraph(new TNEGraph(SIn)); }
436    bool HasFlag(const TGraphFlag& Flag) const;
437    TNEGraph& operator = (const TNEGraph& Graph) { if (this!=&Graph) {
438      MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH; }  return *this; }
439    int GetNodes() const { return NodeH.Len(); }
440    int AddNode(int NId = -1);
441    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
442    void DelNode(const int& NId);
443    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
444    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
445    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
446    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
447    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
448    int GetMxNId() const { return MxNId; }
449    int GetEdges() const { return EdgeH.Len(); }
450    int AddEdge(const int& SrcNId, const int& DstNId, int EId  = -1);
451    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId()); }
452    void DelEdge(const int& EId);
453    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
454    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
455    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
456    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
457    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
458    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
459    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
460    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
461    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
462    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
463    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
464    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
465    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
466    void GetNIdV(TIntV& NIdV) const;
467    void GetEIdV(TIntV& EIdV) const;
468    bool Empty() const { return GetNodes()==0; }
469    void Clr() { MxNId=0; MxEId=0; NodeH.Clr(); EdgeH.Clr(); }
470    void Reserve(const int& Nodes, const int& Edges) {
471      if (Nodes>0) { NodeH.Gen(Nodes/2); } if (Edges>0) { EdgeH.Gen(Edges/2); } }
472    void Defrag(const bool& OnlyNodeLinks=false);
473    bool IsOk(const bool& ThrowExcept=true) const;
474    void Dump(FILE *OutF=stdout) const;
475    static PNEGraph GetSmallGraph();
476    friend class TPt<TNEGraph>;
477  };
478  namespace TSnap {
479  template <> struct IsMultiGraph<TNEGraph> { enum { Val = 1 }; };
480  template <> struct IsDirected<TNEGraph> { enum { Val = 1 }; };
481  }
482  class TBPGraph {
483  public:
484    typedef TBPGraph TNet;
485    typedef TPt<TBPGraph> PNet;
486    typedef enum { bgsUndef, bgsLeft, bgsRight, bgsBoth } TNodeTy; 
487  public:
488    class TNode {
489    private:
490      TInt Id;
491      TIntV NIdV;
492      TNodeTy NodeTy; 
493    public:
494      TNode() : Id(-1), NIdV(), NodeTy(bgsUndef) { }
495      TNode(const int& NId) : Id(NId), NIdV(), NodeTy(true?bgsLeft:bgsRight) { }
496      TNode(const TNode& Node) : Id(Node.Id), NIdV(Node.NIdV), NodeTy(Node.NodeTy) { }
497      TNode(TSIn& SIn) : Id(SIn), NIdV(SIn), NodeTy(bgsUndef) { TInt Ty(SIn); NodeTy=(TNodeTy)Ty.Val; }
498      void Save(TSOut& SOut) const { Id.Save(SOut); NIdV.Save(SOut); TInt(NodeTy).Save(SOut); }
499      int GetId() const { return Id; }
500      int GetDeg() const { return NIdV.Len(); }
501      int GetInDeg() const { return GetDeg(); }
502      int GetOutDeg() const { return GetDeg(); }
503      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
504      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
505      int GetNbrNId(const int& NodeN) const { return NIdV[NodeN]; }
506      bool IsNbrNId(const int& NId) const { return NIdV.SearchBin(NId)!=-1; }
507      bool IsInNId(const int& NId) const { return IsNbrNId(NId); }
508      bool IsOutNId(const int& NId) const { return IsNbrNId(NId); }
509      void PackOutNIdV() { NIdV.Pack(); }
510      void PackNIdV() { NIdV.Pack(); }
511      friend class TBPGraph;
512    };
513    class TNodeI {
514    private:
515      typedef THash<TInt, TNode>::TIter THashIter;
516      THashIter LeftHI, RightHI; 
517    private:
518      inline THashIter HI() const { return ! LeftHI.IsEnd()?LeftHI:RightHI; }
519    public:
520      TNodeI() : LeftHI(), RightHI() { }
521      TNodeI(const THashIter& LeftHIter, const THashIter& RightHIter) : LeftHI(LeftHIter), RightHI(RightHIter) { }
522      TNodeI(const TNodeI& NodeI) : LeftHI(NodeI.LeftHI), RightHI(NodeI.RightHI) { }
523      TNodeI& operator = (const TNodeI& NodeI) { LeftHI = NodeI.LeftHI; RightHI=NodeI.RightHI; return *this; }
524      TNodeI& operator++ (int) { 
525        if (! LeftHI.IsEnd()) { 
526          LeftHI++; } 
527        else if (! RightHI.IsEnd()) { 
528          RightHI++; } 
529        return *this; }
530      bool operator < (const TNodeI& NodeI) const { return LeftHI < NodeI.LeftHI || (LeftHI==NodeI.LeftHI && RightHI < NodeI.RightHI); }
531      bool operator == (const TNodeI& NodeI) const { return LeftHI==NodeI.LeftHI && RightHI==NodeI.RightHI; }
532      int GetId() const { return HI().GetDat().GetId(); }
533      bool IsLeft() const { return ! LeftHI.IsEnd(); }
534      bool IsRight() const { return ! IsLeft(); }
535      int GetDeg() const { return HI().GetDat().GetDeg(); }
536      int GetInDeg() const { return HI().GetDat().GetInDeg(); }
537      int GetOutDeg() const { return HI().GetDat().GetOutDeg(); }
538      int GetInNId(const int& NodeN) const { return HI().GetDat().GetInNId(NodeN); }
539      int GetOutNId(const int& NodeN) const { return HI().GetDat().GetOutNId(NodeN); }
540      int GetNbrNId(const int& NodeN) const { return HI().GetDat().GetNbrNId(NodeN); }
541      bool IsInNId(const int& NId) const { return HI().GetDat().IsInNId(NId); }
542      bool IsOutNId(const int& NId) const { return HI().GetDat().IsOutNId(NId); }
543      bool IsNbrNId(const int& NId) const { return HI().GetDat().IsNbrNId(NId); }
544      friend class TBPGraph;
545    };
546    class TEdgeI {
547    private:
548      TNodeI CurNode, EndNode; 
549      int CurEdge;
550    public:
551      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
552      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
553      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
554      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
555      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
556        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
557      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
558      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
559      int GetId() const { return -1; }
560      int GetSrcNId() const { return CurNode.GetId(); }
561      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
562      int GetLNId() const { return GetSrcNId(); }
563      int GetRNId() const { return GetDstNId(); }
564      friend class TBPGraph;
565    };
566  private:
567    TCRef CRef;
568    TInt MxNId;                 
569    THash<TInt, TNode> LeftH;   
570    THash<TInt, TNode> RightH;  
571  private:
572  public:
573    TBPGraph() : CRef(), MxNId(0), LeftH(), RightH() { }
574    explicit TBPGraph(const int& Nodes, const int& Edges) : MxNId(0) { } 
575    TBPGraph(const TBPGraph& BPGraph) : MxNId(BPGraph.MxNId), LeftH(BPGraph.LeftH), RightH(BPGraph.RightH) { }
576    TBPGraph(TSIn& SIn) : MxNId(SIn), LeftH(SIn), RightH(SIn) { }
577    void Save(TSOut& SOut) const { MxNId.Save(SOut); LeftH.Save(SOut); RightH.Save(SOut); SOut.Flush(); }
578    static PBPGraph New() { return new TBPGraph(); }
579    static PBPGraph New(const int& Nodes, const int& Edges) { return new TBPGraph(Nodes, Edges); }
580    static PBPGraph Load(TSIn& SIn) { return PBPGraph(new TBPGraph(SIn)); }
581    bool HasFlag(const TGraphFlag& Flag) const;
582    TBPGraph& operator = (const TBPGraph& BPGraph) {
583      if (this!=&BPGraph) { MxNId=BPGraph.MxNId; LeftH=BPGraph.LeftH; RightH=BPGraph.RightH; }  return *this; }
584    int GetNodes() const { return GetLNodes() + GetRNodes(); }
585    int GetLNodes() const { return LeftH.Len(); }
586    int GetRNodes() const { return RightH.Len(); }
587    int AddNode(int NId = -1, const bool& LeftNode=true);
588    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.IsLeft()); }
589    void DelNode(const int& NId);
590    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
591    bool IsNode(const int& NId) const { return IsLNode(NId) || IsRNode(NId); }
592    bool IsLNode(const int& NId) const { return LeftH.IsKey(NId); }
593    bool IsRNode(const int& NId) const { return RightH.IsKey(NId); }
594    int GetMxNId() const { return MxNId; }
595    TNodeI BegNI() const { return TNodeI(LeftH.BegI(), RightH.BegI()); }
596    TNodeI EndNI() const { return TNodeI(LeftH.EndI(), RightH.EndI()); }
597    TNodeI GetNI(const int& NId) const { return IsLNode(NId) ? TNodeI(LeftH.GetI(NId), RightH.EndI()) : TNodeI(LeftH.EndI(), RightH.GetI(NId)); }
598    TNodeI BegLNI() const { return TNodeI(LeftH.BegI(), RightH.EndI()); }
599    TNodeI EndLNI() const { return EndNI(); }
600    TNodeI BegRNI() const { return TNodeI(LeftH.EndI(), RightH.BegI()); }
601    TNodeI EndRNI() const { return EndNI(); }
602    int GetEdges() const;
603    int AddEdge(const int& LeftNId, const int& RightNId);
604    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
605    void DelEdge(const int& LeftNId, const int& RightNId);
606    bool IsEdge(const int& LeftNId, const int& RightNId) const;
607    TEdgeI BegEI() const { TNodeI NI=BegLNI(); while (NI<EndLNI() && (NI.GetOutDeg()==0 || NI.GetId()>NI.GetOutNId(0))) { NI++; } return TEdgeI(NI, EndLNI()); }
608    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
609    TEdgeI GetEI(const int& EId) const;
610    TEdgeI GetEI(const int& LeftNId, const int& RightNId) const;
611    int GetRndNId(TRnd& Rnd=TInt::Rnd);
612    int GetRndLNId(TRnd& Rnd=TInt::Rnd);
613    int GetRndRNId(TRnd& Rnd=TInt::Rnd);
614    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
615    void GetNIdV(TIntV& NIdV) const;
616    void GetLNIdV(TIntV& NIdV) const;
617    void GetRNIdV(TIntV& NIdV) const;
618    bool Empty() const { return GetNodes()==0; }
619    void Clr() { MxNId=0; LeftH.Clr(); RightH.Clr(); }
620    void Reserve(const int& Nodes, const int& Edges);
621    void Defrag(const bool& OnlyNodeLinks=false);
622    bool IsOk(const bool& ThrowExcept=true) const;
623    void Dump(FILE *OutF=stdout) const;
624    static PBPGraph GetSmallGraph();
625    friend class TPt<TBPGraph>;
626  };
627  namespace TSnap {
628  template <> struct IsBipart<TBPGraph> { enum { Val = 1 }; };
629  }
630  class THGraph {
631  public:
632    typedef THGraph TNet;
633    typedef TPt<THGraph> PNet;
634  public:
635    class TNode {
636    private:
637      TInt Id;
638      TStr Name;
639      TIntV EIdV; 
640      THash<TInt, TInt> NbrNIdENumH;
641    public:
642      TNode() : Id(-1), Name(""), EIdV(), NbrNIdENumH() { }
643      TNode(const int& NId) : Id(NId), Name(""), EIdV(), NbrNIdENumH() { }
644      TNode(const int& NId, const TStr& NName) : Id(NId), Name(NName), EIdV(), NbrNIdENumH() { }
645      TNode(const TNode& Node) : Id(Node.Id), Name(Node.Name), EIdV(Node.EIdV), NbrNIdENumH(Node.NbrNIdENumH) { }
646      TNode(TSIn& SIn) : Id(SIn), Name(SIn), EIdV(SIn), NbrNIdENumH(SIn) { }
647      void Save(TSOut& SOut) const { Id.Save(SOut); Name.Save(SOut); EIdV.Save(SOut); NbrNIdENumH.Save(SOut);}
648      int GetId() const { return Id; }
649      TStr GetName() const { return Name; }
650      int GetNbrNodes() const { return NbrNIdENumH.Len(); }
651      void GetNbrNodes(TIntV& VNbrV) const { NbrNIdENumH.GetKeyV(VNbrV); }
652      void GetNbrEdges(TIntV& ENbrV) const { ENbrV = EIdV; }
653      int GetDeg() const { return EIdV.Len(); }
654      int GetInDeg() const { return GetDeg(); }
655      int GetOutDeg() const { return GetDeg(); }
656      int GetNbrEId(const int& NE) const { return EIdV[NE]; } 
657      int GetNbrNId(const int& NN) const { return NbrNIdENumH.GetKey(NN); } 
658      bool IsNbrNId(const int& NId) const { return HasNeiN(NId); }
659      bool IsInNId(const int& NId) const { return HasNeiN(NId); }
660      bool IsOutNId(const int& NId) const { return HasNeiN(NId); }
661      void SortNIdV() { NbrNIdENumH.SortByKey();}
662      bool HasNeiN(const TNode &Node) const { return NbrNIdENumH.IsKey(Node.GetId()); } 
663      bool HasNeiN(const int& NId) const { return NbrNIdENumH.IsKey(NId); } 
664      void UpdEInfo(const int& EId, const TIntSet& ENodesHS);
665      void GetEIDs(TIntV& NeiEIdV) const { NeiEIdV=EIdV; } 
666      void GetEIDs(TIntSet& NeiEIdH) const {TIntSet EH(EIdV); NeiEIdH=EH; } 
667      int GetEdges() const { return GetDeg(); } 
668      int Get2Edges() const { return (NbrNIdENumH.Len() * (NbrNIdENumH.Len()-1))/2; } 
669      void AddNeighbor(const int& NId) {
670        if (NbrNIdENumH.IsKey(NId)) {
671          NbrNIdENumH.AddDat(NId, NbrNIdENumH.GetDat(NId)+1);
672        }else {
673          NbrNIdENumH.AddDat(NId,1);
674        }
675      }
676      int DelNeighbor(const int& NId) {
677        if (NbrNIdENumH.IsKey(NId)) {
678          if (NbrNIdENumH.GetDat(NId)>1) {
679            NbrNIdENumH.AddDat(NId, NbrNIdENumH.GetDat(NId)-1);
680          } else {
681            NbrNIdENumH.DelKey(NId);
682          }
683        }
684        return NbrNIdENumH.GetDat(NId);
685      }
686      bool operator == (const TNode& Node) const {
687        TIntV* ThisNNeiV;
688        TIntV* InpNNeiV;
689        GetNbrNodes(*ThisNNeiV); Node.GetNbrNodes(*InpNNeiV);
690        if (*ThisNNeiV == *InpNNeiV && EIdV == Node.EIdV) {
691          IAssertR(Id != Node.Id, "All node's neighbors are the same, but IDs don't match.");
692          IAssertR(Name.EqI(Node.Name), "All node's neighbors are the same, but Names don't match.");
693          return true;
694        }
695        return false;
696      }
697      friend class THGraph;
698    };
699    class TNodeI {
700    private:
701      typedef THash<TInt, TNode>::TIter THashIter;
702      THashIter NodeHI;
703    public:
704      TNodeI() : NodeHI() { }
705      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
706      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
707      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
708      TNodeI& operator++ (int) { NodeHI++; return *this; }
709      TNodeI& operator-- (int) { NodeHI--; return *this; }
710      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
711      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
712      int GetId() const { return NodeHI.GetDat().GetId(); }
713      TStr GetName() const { return NodeHI.GetDat().GetName(); }
714      int GetNbrNodes() const { return NodeHI.GetDat().GetNbrNodes(); }
715      void GetNbrNodes(TIntV& VNbrV) const { NodeHI.GetDat().GetNbrNodes(VNbrV); }
716      void GetEIDs(TIntV& NeiEIdV) { NodeHI.GetDat().GetEIDs(NeiEIdV); }
717      void GetEIDs(TIntSet& NeiEIdH) { NodeHI.GetDat().GetEIDs(NeiEIdH); }
718      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
719      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
720      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
721      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
722      bool HasNeiInN(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
723      bool HasNeiOutN(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
724      bool HasNeiN(const int& NId) const { return NodeHI.GetDat().IsNbrNId(NId); }
725      int Get2Edges() const { return NodeHI.GetDat().Get2Edges(); }
726      bool HasEdge(const int& EId) {
727        TIntV EV = NodeHI.GetDat().EIdV;
728        for (int i = 0; i < EV.Len(); i++) {
729          if (EId == EV[i]) { return true; }
730          return false;
731        }
732      }
733      friend class THGraph;
734    };
735    class TEdge {
736    private:
737      TInt Id;
738      TIntSet NeiNIdSH;
739      THGraph* Graph;
740    public:
741      TEdge() { TEdge(NULL); }
742      TEdge(THGraph* GraphPt) : Id(-1), NeiNIdSH(), Graph(GraphPt) { }
743      TEdge(const int& EId, const TIntSet& NodesIDsH, THGraph* GraphPt) : Id(EId), NeiNIdSH(NodesIDsH), Graph(GraphPt) { }
744      TEdge(const int& EId, const TIntV& NodesIDsV, THGraph* GraphPt) : Id(EId), NeiNIdSH(NodesIDsV), Graph(GraphPt) { }
745      TEdge(const TEdge& Edge) : Id(Edge.Id), NeiNIdSH(Edge.NeiNIdSH), Graph(Edge.Graph) { }
746      TEdge(THGraph* GraphPt, const TIntSet& NodeIdsHS);
747      TEdge(THGraph* GraphPt, const TIntV& NodeIdsV);
748      TEdge(TSIn& SIn) : Id(SIn), NeiNIdSH(SIn), Graph(NULL) { }
749      TEdge(TSIn& SIn, THGraph* GraphPt) : Id(SIn), NeiNIdSH(SIn), Graph(GraphPt) { }
750      TEdge(const THashSet<TInt>& NIdH, const int& EId) {
751        TIntV NIdV;
752        NIdH.GetKeyV(NIdV);
753        TEdge(EId, NIdV, Graph);
754      }
755      void Save(TSOut& SOut) const { Id.Save(SOut); NeiNIdSH.Save(SOut); }
756      int GetId() const { return Id; }
757      int Len() const { return NeiNIdSH.Len(); }
758      void GetNodesV(TIntV& NeiV) const { NeiNIdSH.GetKeyV(NeiV); }
759      void GetNbrNodes(TIntV& NIdsV) { NeiNIdSH.GetKeyV(NIdsV);}
760      bool HasNode(const TNode& Node) const { return NeiNIdSH.IsKey(Node.GetId()); } 
761      void UpdNEInfo(const TIntSet& ENodesHS);
762      friend class THGraph;
763    };
764    class TEdgeI {
765    private:
766      typedef THash<TInt, TEdge>::TIter THashIter;
767      THashIter EdgeHI;
768    public:
769      TEdgeI() : EdgeHI() { }
770      TEdgeI(const THashIter& EdgeHIter) : EdgeHI(EdgeHIter) { }
771      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI) { }
772      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; }  return *this; }
773      TEdgeI& operator ++ (int) { EdgeHI++; return *this; }
774      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
775      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
776      int GetId() const { return EdgeHI.GetDat().GetId(); }
777      TEdge GetEdge() {return EdgeHI.GetDat();}
778      void GetNodesV(TIntV& NeiV) const { EdgeHI.GetDat().GetNodesV(NeiV); }
779      void GetNbrNodes(TIntV& NIDV) { EdgeHI.GetDat().GetNbrNodes(NIDV); }
780      int Len() const { return EdgeHI.GetDat().Len(); }
781      int GetDeg() const { return Len(); }
782      friend class THGraph;
783    };
784  private:
785    TCRef CRef;
786    TInt MxNId, MxEId, NEdges, N2Edges;
787    THash<TInt, TNode> NodeH;
788    THash<TInt, TEdge> EdgeH;
789  private:
790    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
791    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
792    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
793    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
794    int AssertNodes(const TIntSet& NodesIS);
795    static void TIntersect(TIntSet& S, const TIntSet& S2) {
796      TIntV MarkDel(S.Len(),0); 
797      for (THashSetKeyI<TInt> i = S.BegI(); i < S.EndI(); i++) {
798        if (!S2.IsKey(i.GetKey())) { MarkDel.Add(i.GetKey()); }
799      }
800      if (MarkDel.Len() > 0) { for (int j = 0; j < MarkDel.Len(); j++) S.DelKey(MarkDel[j]); }
801    }
802  public:
803    THGraph() : CRef(), MxNId(0), MxEId(0), NEdges(0), N2Edges(0), NodeH(), EdgeH() { }
804    explicit THGraph(const int& Nodes, const int& Edges) : MxNId(0), NEdges(0), N2Edges(0) { Reserve(Nodes, Edges); }
805    THGraph(const THGraph& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId), NEdges(Graph.NEdges), N2Edges(Graph.N2Edges), NodeH(Graph.NodeH), EdgeH(Graph.EdgeH) { }
806    THGraph(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NEdges(SIn), N2Edges(SIn), NodeH(SIn), EdgeH(SIn) { }
807    void Save(TSOut& SOut) const { MxNId.Save(SOut); MxEId.Save(SOut); NEdges.Save(SOut); N2Edges.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut); }
808    static PHGraph New() { return new THGraph(); }
809    static PHGraph New(const int& Nodes, const int& Edges) { return new THGraph(Nodes, Edges); }
810    static PHGraph Load(TSIn& SIn) { return PHGraph(new THGraph(SIn)); }
811    bool HasFlag(const TGraphFlag& Flag) const;
812    THGraph& operator = (const THGraph& Graph) {
813      if (this!=&Graph) { MxNId=Graph.MxNId; MxEId=Graph.MxEId; NEdges=Graph.NEdges; N2Edges=Graph.N2Edges; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH; } return *this; }
814    int GetNodes() const { return NodeH.Len(); }
815    int AddNodeUnchecked(int NId = -1, TStr NName = "");
816    int AddNode(int NId = -1, TStr NName = "");
817    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetName()); }
818    void DelNode(const int& NId);
819    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
820    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
821    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
822    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
823    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
824    int GetMxNId() const { return MxNId; }
825    int GetVNbrNodes(int& NId) const { return GetNode(NId).GetNbrNodes(); }
826    void GetVNbrEdges(int& NId, TIntV& EIDV) const { return GetNode(NId).GetNbrEdges(EIDV); }
827    int GetEdges() const { return EdgeH.Len(); }
828    int Get2Edges() const { return N2Edges; }
829    void GetENbrNodes(int EId, TIntV& NIDV) { GetEdge(EId).GetNbrNodes(NIDV); }
830    int AddEdge(const THash<TInt, TNode>& NodeIdsHS){
831      TIntV NIdV;
832      NodeIdsHS.GetKeyV(NIdV);
833      return AddEdge(NIdV);
834    }
835    int AddEdge(const TIntSet& NIdH, int& EId);
836    int AddEdge(const TIntSet& NIdH){ int _EId = -1; return AddEdge(NIdH, _EId); }
837    int AddEdge(const TIntV& NodeV) { TIntSet NodeIdsHS(NodeV); return AddEdge(NodeIdsHS); }
838    int AddEdge(const TEdgeI& EI){
839      int _EId = EI.GetId();
840      return AddEdge(EI.EdgeHI.GetDat().NeiNIdSH, _EId);
841    }
842    int AddEdge(const TEdgeI& EI, int& EId){ return AddEdge(EI.EdgeHI.GetDat().NeiNIdSH, EId); }
843    void DelEdge(const int& EId);
844    void DelEdge(const TEdge& Edge) { DelEdge(Edge.Id); }
845    bool IsEdgeId(const int& EId) const { return EdgeH.IsKey(EId); }
846    bool IsEdge(const TIntSet& NIdH);
847    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI()); }
848    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI()); }
849    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId)); }
850    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
851    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
852    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
853    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
854    TEdge GetRndEdge(TRnd& Rnd=TInt::Rnd) { return GetEdge(GetRndEId(Rnd)); }
855    void GetNIdV(TIntV& NIdV) const;
856    void GetEIdV(TIntV& EIdV) const { EdgeH.GetKeyV(EIdV); }
857    bool Empty() const { return GetNodes()==0; }
858    void Clr() { MxNId=0; MxEId=0; NEdges=0; N2Edges=0; NodeH.Clr(); EdgeH.Clr(); }
859    void Reserve(const int& Nodes, const int& Edges) {
860      if (Nodes>0) { NodeH.Gen(Nodes/2); } if (Edges>0) { EdgeH.Gen(Edges/2); }
861    }
862    void Defrag(const bool& OnlyNodeLinks=false);
863    bool IsOk(const bool& ThrowExcept=true) const;
864    void Dump(FILE *OutF=stdout) const;
865    static PHGraph GetSmallGraph();
866    void PrintEdge(const int EId);
867    friend class TPt<THGraph>;
868  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Platform.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph_3.h</div>
                </div>
                <div class="column column_space"><pre><code>208  	bool Created() const noexcept { return wid != nullptr; }
209  	void Destroy() noexcept;
210  	PRectangle GetPosition() const;
211  	void SetPosition(PRectangle rc);
212  	void SetPositionRelative(PRectangle rc, const Window *relativeTo);
213  	PRectangle GetClientPosition() const;
214  	void Show(bool show=true);
215  	void InvalidateAll();
216  	void InvalidateRectangle(PRectangle rc);
</pre></code></div>
                <div class="column column_space"><pre><code>284    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
285    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
286    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
287    void DelNode(const int& NId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    