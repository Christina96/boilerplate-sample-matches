
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.3478260869565215%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-low_level_alloc_test.cc</h3>
            <pre><code>1  #include "absl/base/internal/low_level_alloc.h"
2  #include <stdint.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <thread>  
6  #include <unordered_map>
7  #include <utility>
8  #ifdef __EMSCRIPTEN__
9  #include <emscripten.h>
10  #endif
11  #include "absl/container/node_hash_map.h"
12  namespace absl {
13  ABSL_NAMESPACE_BEGIN
14  namespace base_internal {
15  namespace {
16  #define TEST_ASSERT(x)                                           \
17    if (!(x)) {                                                    \
18      printf("TEST_ASSERT(%s) FAILED ON LINE %d\n", #x, __LINE__); \
19      abort();                                                     \
20    }
21  struct BlockDesc {
22    char *ptr;      
23    int len;        
24    int fill;       
25  };
26  static void CheckBlockDesc(const BlockDesc &d) {
27    for (int i = 0; i != d.len; i++) {
28      TEST_ASSERT((d.ptr[i] & 0xff) == ((d.fill + i) & 0xff));
29    }
30  }
31  static void RandomizeBlockDesc(BlockDesc *d) {
32    d->fill = rand() & 0xff;
33    for (int i = 0; i != d->len; i++) {
34      d->ptr[i] = (d->fill + i) & 0xff;
35    }
36  }
37  static bool using_low_level_alloc = false;
<span onclick='openModal()' class='match'>38  static void Test(bool use_new_arena, bool call_malloc_hook, int n) {
39    typedef absl::node_hash_map<int, BlockDesc> AllocMap;
40    AllocMap allocated;
41    AllocMap::iterator it;
42    BlockDesc block_desc;
43    int rnd;
44    LowLevelAlloc::Arena *arena = nullptr;
</span>45    if (use_new_arena) {
46      int32_t flags = call_malloc_hook ? LowLevelAlloc::kCallMallocHook : 0;
47      arena = LowLevelAlloc::NewArena(flags);
48    }
49    for (int i = 0; i != n; i++) {
50      if (i != 0 && i % 10000 == 0) {
51        printf(".");
52        fflush(stdout);
53      }
54      switch (rand() & 1) {      
55      case 0:     
56        using_low_level_alloc = true;
57        block_desc.len = rand() & 0x3fff;
58        block_desc.ptr = reinterpret_cast<char *>(
59            arena == nullptr
60                ? LowLevelAlloc::Alloc(block_desc.len)
61                : LowLevelAlloc::AllocWithArena(block_desc.len, arena));
62        using_low_level_alloc = false;
63        RandomizeBlockDesc(&block_desc);
64        rnd = rand();
65        it = allocated.find(rnd);
66        if (it != allocated.end()) {
67          CheckBlockDesc(it->second);
68          using_low_level_alloc = true;
69          LowLevelAlloc::Free(it->second.ptr);
70          using_low_level_alloc = false;
71          it->second = block_desc;
72        } else {
73          allocated[rnd] = block_desc;
74        }
75        break;
76      case 1:     
77        it = allocated.begin();
78        if (it != allocated.end()) {
79          CheckBlockDesc(it->second);
80          using_low_level_alloc = true;
81          LowLevelAlloc::Free(it->second.ptr);
82          using_low_level_alloc = false;
83          allocated.erase(it);
84        }
85        break;
86      }
87    }
88    while ((it = allocated.begin()) != allocated.end()) {
89      CheckBlockDesc(it->second);
90      using_low_level_alloc = true;
91      LowLevelAlloc::Free(it->second.ptr);
92      using_low_level_alloc = false;
93      allocated.erase(it);
94    }
95    if (use_new_arena) {
96      TEST_ASSERT(LowLevelAlloc::DeleteArena(arena));
97    }
98  }
99  static struct BeforeMain {
100    BeforeMain() {
101      Test(false, false, 50000);
102      Test(true, false, 50000);
103      Test(true, true, 50000);
104    }
105  } before_main;
106  }  
107  }  
108  ABSL_NAMESPACE_END
109  }  
110  int main(int argc, char *argv[]) {
111    printf("PASS\n");
112  #ifdef __EMSCRIPTEN__
113      MAIN_THREAD_EM_ASM({
114        if (ENVIRONMENT_IS_WEB) {
115          if (typeof TEST_FINISH === 'function') {
116            TEST_FINISH($0);
117          } else {
118            console.error('Attempted to exit with status ' + $0);
119            console.error('But TEST_FINSIHED is not a function.');
120          }
121        }
122      }, 0);
123  #endif
124    return 0;
125  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blamer.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCSTRUCT_BLAMER_H_
2  #define TESSERACT_CCSTRUCT_BLAMER_H_
3  #ifdef HAVE_CONFIG_H
4  #  include "config_auto.h" 
5  #endif
6  #include "boxword.h" 
7  #ifndef DISABLED_LEGACY_ENGINE
8  #  include "params_training_featdef.h" 
9  #endif                                 
10  #include "ratngs.h"                    
11  #include "rect.h"                      
12  #include "tprintf.h"                   
13  #include <tesseract/unichar.h> 
14  #include <cstdint> 
15  #include <cstring> 
16  #include <vector>  
17  namespace tesseract {
18  class DENORM;
19  class MATRIX;
20  class UNICHARSET;
21  class WERD_RES;
22  struct MATRIX_COORD;
23  struct TWERD;
24  class LMPainPoints;
25  static const int16_t kBlamerBoxTolerance = 5;
26  enum IncorrectResultReason {
<span onclick='openModal()' class='match'>27    IRR_CORRECT,
28    IRR_CLASSIFIER,
29    IRR_CHOPPER,
30    IRR_CLASS_LM_TRADEOFF,
31    IRR_PAGE_LAYOUT,
32    IRR_SEGSEARCH_HEUR,
33    IRR_SEGSEARCH_PP,
34    IRR_CLASS_OLD_LM_TRADEOFF,
35    IRR_ADAPTION,
</span>36    IRR_NO_TRUTH_SPLIT,
37    IRR_NO_TRUTH,
38    IRR_UNKNOWN,
39    IRR_NUM_REASONS
40  };
41  struct BlamerBundle {
42    static const char *IncorrectReasonName(IncorrectResultReason irr);
43    BlamerBundle()
44        : truth_has_char_boxes_(false)
45        , incorrect_result_reason_(IRR_CORRECT)
46        , lattice_data_(nullptr) {
47      ClearResults();
48    }
49    BlamerBundle(const BlamerBundle &other) {
50      this->CopyTruth(other);
51      this->CopyResults(other);
52    }
53    ~BlamerBundle() {
54      delete[] lattice_data_;
55    }
56    std::string TruthString() const {
57      std::string truth_str;
58      for (auto &text : truth_text_) {
59        truth_str += text;
60      }
61      return truth_str;
62    }
63    IncorrectResultReason incorrect_result_reason() const {
64      return incorrect_result_reason_;
65    }
66    bool NoTruth() const {
67      return incorrect_result_reason_ == IRR_NO_TRUTH || incorrect_result_reason_ == IRR_PAGE_LAYOUT;
68    }
69    bool HasDebugInfo() const {
70      return debug_.length() > 0 || misadaption_debug_.length() > 0;
71    }
72    const std::string &debug() const {
73      return debug_;
74    }
75    const std::string &misadaption_debug() const {
76      return misadaption_debug_;
77    }
78    void UpdateBestRating(float rating) {
79      if (rating < best_correctly_segmented_rating_) {
80        best_correctly_segmented_rating_ = rating;
81      }
82    }
83    int correct_segmentation_length() const {
84      return correct_segmentation_cols_.size();
85    }
86    bool MatrixPositionCorrect(int index, const MATRIX_COORD &coord) {
87      return correct_segmentation_cols_[index] == coord.col &&
88             correct_segmentation_rows_[index] == coord.row;
89    }
90    void set_best_choice_is_dict_and_top_choice(bool value) {
91      best_choice_is_dict_and_top_choice_ = value;
92    }
93    const char *lattice_data() const {
94      return lattice_data_;
95    }
96    int lattice_size() const {
97      return lattice_size_; 
98    }
99    void set_lattice_data(const char *data, int size) {
100      lattice_size_ = size;
101      delete[] lattice_data_;
102      lattice_data_ = new char[lattice_size_];
103      memcpy(lattice_data_, data, lattice_size_);
104    }
105  #ifndef DISABLED_LEGACY_ENGINE
106    const tesseract::ParamsTrainingBundle &params_training_bundle() const {
107      return params_training_bundle_;
108    }
109    void AddHypothesis(const tesseract::ParamsTrainingHypothesis &hypo) {
110      params_training_bundle_.AddHypothesis(hypo);
111    }
112  #endif 
113    void SetWordTruth(const UNICHARSET &unicharset, const char *truth_str, const TBOX &word_box);
114    void SetSymbolTruth(const UNICHARSET &unicharset, const char *char_str, const TBOX &char_box);
115    void SetRejectedTruth();
116    bool ChoiceIsCorrect(const WERD_CHOICE *word_choice) const;
117    void ClearResults() {
118      norm_truth_word_.DeleteAllBoxes();
119      norm_box_tolerance_ = 0;
120      if (!NoTruth()) {
121        incorrect_result_reason_ = IRR_CORRECT;
122      }
123      debug_ = "";
124      segsearch_is_looking_for_blame_ = false;
125      best_correctly_segmented_rating_ = WERD_CHOICE::kBadRating;
126      correct_segmentation_cols_.clear();
127      correct_segmentation_rows_.clear();
128      best_choice_is_dict_and_top_choice_ = false;
129      delete[] lattice_data_;
130      lattice_data_ = nullptr;
131      lattice_size_ = 0;
132    }
133    void CopyTruth(const BlamerBundle &other) {
134      truth_has_char_boxes_ = other.truth_has_char_boxes_;
135      truth_word_ = other.truth_word_;
136      truth_text_ = other.truth_text_;
137      incorrect_result_reason_ = (other.NoTruth() ? other.incorrect_result_reason_ : IRR_CORRECT);
138    }
139    void CopyResults(const BlamerBundle &other) {
140      norm_truth_word_ = other.norm_truth_word_;
141      norm_box_tolerance_ = other.norm_box_tolerance_;
142      incorrect_result_reason_ = other.incorrect_result_reason_;
143      segsearch_is_looking_for_blame_ = other.segsearch_is_looking_for_blame_;
144      best_correctly_segmented_rating_ = other.best_correctly_segmented_rating_;
145      correct_segmentation_cols_ = other.correct_segmentation_cols_;
146      correct_segmentation_rows_ = other.correct_segmentation_rows_;
147      best_choice_is_dict_and_top_choice_ = other.best_choice_is_dict_and_top_choice_;
148      if (other.lattice_data_ != nullptr) {
149        lattice_data_ = new char[other.lattice_size_];
150        memcpy(lattice_data_, other.lattice_data_, other.lattice_size_);
151        lattice_size_ = other.lattice_size_;
152      } else {
153        lattice_data_ = nullptr;
154      }
155    }
156    const char *IncorrectReason() const;
157    void FillDebugString(const std::string &msg, const WERD_CHOICE *choice, std::string &debug);
158    void SetupNormTruthWord(const DENORM &denorm);
159    void SplitBundle(int word1_right, int word2_left, bool debug, BlamerBundle *bundle1,
160                     BlamerBundle *bundle2) const;
161    void JoinBlames(const BlamerBundle &bundle1, const BlamerBundle &bundle2, bool debug);
162    void BlameClassifier(const UNICHARSET &unicharset, const TBOX &blob_box,
163                         const BLOB_CHOICE_LIST &choices, bool debug);
164    void SetChopperBlame(const WERD_RES *word, bool debug);
165    void BlameClassifierOrLangModel(const WERD_RES *word, const UNICHARSET &unicharset,
166                                    bool valid_permuter, bool debug);
167    void SetupCorrectSegmentation(const TWERD *word, bool debug);
168    bool GuidedSegsearchNeeded(const WERD_CHOICE *best_choice) const;
169    void InitForSegSearch(const WERD_CHOICE *best_choice, MATRIX *ratings, UNICHAR_ID wildcard_id,
170                          bool debug, std::string &debug_str, tesseract::LMPainPoints *pain_points,
171                          double max_char_wh_ratio, WERD_RES *word_res);
172    bool GuidedSegsearchStillGoing() const;
173    void FinishSegSearch(const WERD_CHOICE *best_choice, bool debug, std::string &debug_str);
174    static void LastChanceBlame(bool debug, WERD_RES *word);
175    void SetMisAdaptionDebug(const WERD_CHOICE *best_choice, bool debug);
176  private:
177    BlamerBundle &operator=(const BlamerBundle &other) = delete;
178    void SetBlame(IncorrectResultReason irr, const std::string &msg, const WERD_CHOICE *choice,
179                  bool debug) {
180      incorrect_result_reason_ = irr;
181      debug_ = IncorrectReason();
182      debug_ += " to blame: ";
183      FillDebugString(msg, choice, debug_);
184      if (debug) {
185        tprintf("SetBlame(): %s", debug_.c_str());
186      }
187    }
188  private:
189    bool truth_has_char_boxes_;
190    bool segsearch_is_looking_for_blame_;
191    bool best_choice_is_dict_and_top_choice_;
192    int norm_box_tolerance_;
193    tesseract::BoxWord truth_word_;
194    tesseract::BoxWord norm_truth_word_;
195    std::vector<std::string> truth_text_;
196    IncorrectResultReason incorrect_result_reason_;
197    std::string debug_;
198    std::string misadaption_debug_;
199    std::vector<int> correct_segmentation_cols_;
200    std::vector<int> correct_segmentation_rows_;
201    float best_correctly_segmented_rating_;
202    int lattice_size_; 
203    char *lattice_data_;
204  #ifndef DISABLED_LEGACY_ENGINE
205    tesseract::ParamsTrainingBundle params_training_bundle_;
206  #endif 
207  };
208  } 
209  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-low_level_alloc_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blamer.h</div>
                </div>
                <div class="column column_space"><pre><code>38  static void Test(bool use_new_arena, bool call_malloc_hook, int n) {
39    typedef absl::node_hash_map<int, BlockDesc> AllocMap;
40    AllocMap allocated;
41    AllocMap::iterator it;
42    BlockDesc block_desc;
43    int rnd;
44    LowLevelAlloc::Arena *arena = nullptr;
</pre></code></div>
                <div class="column column_space"><pre><code>27    IRR_CORRECT,
28    IRR_CLASSIFIER,
29    IRR_CHOPPER,
30    IRR_CLASS_LM_TRADEOFF,
31    IRR_PAGE_LAYOUT,
32    IRR_SEGSEARCH_HEUR,
33    IRR_SEGSEARCH_PP,
34    IRR_CLASS_OLD_LM_TRADEOFF,
35    IRR_ADAPTION,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    