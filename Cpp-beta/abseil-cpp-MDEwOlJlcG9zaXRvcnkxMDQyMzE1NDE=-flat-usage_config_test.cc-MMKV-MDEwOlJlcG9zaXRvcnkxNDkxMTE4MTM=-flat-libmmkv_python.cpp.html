
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.821086261980831%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-usage_config_test.cc</h3>
            <pre><code>1  #include "absl/flags/usage_config.h"
2  #include <string>
3  #include "gtest/gtest.h"
4  #include "absl/flags/internal/path_util.h"
5  #include "absl/flags/internal/program_name.h"
6  #include "absl/strings/match.h"
7  #include "absl/strings/string_view.h"
8  namespace {
9  class FlagsUsageConfigTest : public testing::Test {
10   protected:
11    void SetUp() override {
12      absl::FlagsUsageConfig default_config;
13      absl::SetFlagsUsageConfig(default_config);
14    }
15  };
16  namespace flags = absl::flags_internal;
17  bool TstContainsHelpshortFlags(absl::string_view f) {
18    return absl::StartsWith(flags::Basename(f), "progname.");
19  }
20  bool TstContainsHelppackageFlags(absl::string_view f) {
21    return absl::EndsWith(flags::Package(f), "aaa/");
22  }
23  bool TstContainsHelpFlags(absl::string_view f) {
24    return absl::EndsWith(flags::Package(f), "zzz/");
25  }
26  std::string TstVersionString() { return "program 1.0.0"; }
27  std::string TstNormalizeFilename(absl::string_view filename) {
28    return std::string(filename.substr(2));
29  }
30  void TstReportUsageMessage(absl::string_view msg) {}
31  TEST_F(FlagsUsageConfigTest, TestGetSetFlagsUsageConfig) {
32    EXPECT_TRUE(flags::GetUsageConfig().contains_helpshort_flags);
33    EXPECT_TRUE(flags::GetUsageConfig().contains_help_flags);
34    EXPECT_TRUE(flags::GetUsageConfig().contains_helppackage_flags);
35    EXPECT_TRUE(flags::GetUsageConfig().version_string);
36    EXPECT_TRUE(flags::GetUsageConfig().normalize_filename);
37    absl::FlagsUsageConfig empty_config;
38    empty_config.contains_helpshort_flags = &TstContainsHelpshortFlags;
39    empty_config.contains_help_flags = &TstContainsHelpFlags;
40    empty_config.contains_helppackage_flags = &TstContainsHelppackageFlags;
41    empty_config.version_string = &TstVersionString;
42    empty_config.normalize_filename = &TstNormalizeFilename;
43    absl::SetFlagsUsageConfig(empty_config);
44    EXPECT_TRUE(flags::GetUsageConfig().contains_helpshort_flags);
45    EXPECT_TRUE(flags::GetUsageConfig().contains_help_flags);
46    EXPECT_TRUE(flags::GetUsageConfig().contains_helppackage_flags);
47    EXPECT_TRUE(flags::GetUsageConfig().version_string);
48    EXPECT_TRUE(flags::GetUsageConfig().normalize_filename);
49  }
50  TEST_F(FlagsUsageConfigTest, TestContainsHelpshortFlags) {
51  #if defined(_WIN32)
52    flags::SetProgramInvocationName("usage_config_test.exe");
53  #else
54    flags::SetProgramInvocationName("usage_config_test");
55  #endif
56    auto config = flags::GetUsageConfig();
57    EXPECT_TRUE(config.contains_helpshort_flags("adir/cd/usage_config_test.cc"));
58    EXPECT_TRUE(
<span onclick='openModal()' class='match'>59        config.contains_helpshort_flags("aaaa/usage_config_test-main.cc"));
60    EXPECT_TRUE(config.contains_helpshort_flags("abc/usage_config_test_main.cc"));
61    EXPECT_FALSE(config.contains_helpshort_flags("usage_config_main.cc"));
62    absl::FlagsUsageConfig empty_config;
63    empty_config.contains_helpshort_flags = &TstContainsHelpshortFlags;
64    absl::SetFlagsUsageConfig(empty_config);
65    EXPECT_TRUE(
66        flags::GetUsageConfig().contains_helpshort_flags("aaa/progname.cpp"));
67    EXPECT_FALSE(
68        flags::GetUsageConfig().contains_helpshort_flags("aaa/progmane.cpp"));
</span>69  }
70  TEST_F(FlagsUsageConfigTest, TestContainsHelpFlags) {
71    flags::SetProgramInvocationName("usage_config_test");
72    auto config = flags::GetUsageConfig();
73    EXPECT_TRUE(config.contains_help_flags("zzz/usage_config_test.cc"));
74    EXPECT_TRUE(
75        config.contains_help_flags("bdir/a/zzz/usage_config_test-main.cc"));
76    EXPECT_TRUE(
77        config.contains_help_flags("&bsol;&bsol;aqse/zzz/usage_config_test_main.cc"));
78    EXPECT_FALSE(config.contains_help_flags("zzz/aa/usage_config_main.cc"));
79    absl::FlagsUsageConfig empty_config;
80    empty_config.contains_help_flags = &TstContainsHelpFlags;
81    absl::SetFlagsUsageConfig(empty_config);
82    EXPECT_TRUE(flags::GetUsageConfig().contains_help_flags("zzz/main-body.c"));
83    EXPECT_FALSE(
84        flags::GetUsageConfig().contains_help_flags("zzz/dir/main-body.c"));
85  }
86  TEST_F(FlagsUsageConfigTest, TestContainsHelppackageFlags) {
87    flags::SetProgramInvocationName("usage_config_test");
88    auto config = flags::GetUsageConfig();
89    EXPECT_TRUE(config.contains_helppackage_flags("aaa/usage_config_test.cc"));
90    EXPECT_TRUE(
91        config.contains_helppackage_flags("bbdir/aaa/usage_config_test-main.cc"));
92    EXPECT_TRUE(config.contains_helppackage_flags(
93        "&bsol;&bsol;aqswde/aaa/usage_config_test_main.cc"));
94    EXPECT_FALSE(config.contains_helppackage_flags("aadir/usage_config_main.cc"));
95    absl::FlagsUsageConfig empty_config;
96    empty_config.contains_helppackage_flags = &TstContainsHelppackageFlags;
97    absl::SetFlagsUsageConfig(empty_config);
98    EXPECT_TRUE(
99        flags::GetUsageConfig().contains_helppackage_flags("aaa/main-body.c"));
100    EXPECT_FALSE(
101        flags::GetUsageConfig().contains_helppackage_flags("aadir/main-body.c"));
102  }
103  TEST_F(FlagsUsageConfigTest, TestVersionString) {
104    flags::SetProgramInvocationName("usage_config_test");
105  #ifdef NDEBUG
106    std::string expected_output = "usage_config_test\n";
107  #else
108    std::string expected_output =
109        "usage_config_test\nDebug build (NDEBUG not #defined)\n";
110  #endif
111    EXPECT_EQ(flags::GetUsageConfig().version_string(), expected_output);
112    absl::FlagsUsageConfig empty_config;
113    empty_config.version_string = &TstVersionString;
114    absl::SetFlagsUsageConfig(empty_config);
115    EXPECT_EQ(flags::GetUsageConfig().version_string(), "program 1.0.0");
116  }
117  TEST_F(FlagsUsageConfigTest, TestNormalizeFilename) {
118    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("a/a.cc"), "a/a.cc");
119    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("/a/a.cc"), "a/a.cc");
120    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("&bsol;&bsol;/a/a.cc"), "a/a.cc");
121    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("/"), "");
122    absl::FlagsUsageConfig empty_config;
123    empty_config.normalize_filename = &TstNormalizeFilename;
124    absl::SetFlagsUsageConfig(empty_config);
125    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("a/a.cc"), "a.cc");
126    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("aaa/a.cc"), "a/a.cc");
127    empty_config.normalize_filename = nullptr;
128    absl::SetFlagsUsageConfig(empty_config);
129    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("a/a.cc"), "a/a.cc");
130    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("/a/a.cc"), "a/a.cc");
131    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("&bsol;&bsol;/a/a.cc"), "a/a.cc");
132    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("\\a\\a.cc"), "a\\a.cc");
133    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("&bsol;&bsol;"), "");
134    EXPECT_EQ(flags::GetUsageConfig().normalize_filename("\\\\"), "");
135  }
136  }  
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-libmmkv_python.cpp</h3>
            <pre><code>1  #include "MMKV.h"
2  #include <pybind11/functional.h>
3  #include <pybind11/pybind11.h>
4  #include <pybind11/stl.h>
5  using namespace mmkv;
6  using namespace std;
7  namespace py = pybind11;
8  static MMBuffer pyBytes2MMBuffer(const py::bytes &bytes) {
9      char *buffer = nullptr;
10      ssize_t length = 0;
11      if (PYBIND11_BYTES_AS_STRING_AND_SIZE(bytes.ptr(), &buffer, &length) == 0) {
12          return {buffer, static_cast<size_t>(length), MMBufferNoCopy};
13      }
14      return MMBuffer(0);
15  }
16  static function<void(MMKVLogLevel level, const char *file, int line, const char *function, const string &message)>
17      g_logHandler = nullptr;
18  static void MyLogHandler(MMKVLogLevel level, const char *file, int line, const char *function, const string &message) {
19      if (g_logHandler) {
20          g_logHandler(level, file, line, function, message);
21      }
22  }
23  static function<MMKVRecoverStrategic(const string &mmapID, MMKVErrorType errorType)> g_errorHandler = nullptr;
24  static MMKVRecoverStrategic MyErrorHandler(const string &mmapID, MMKVErrorType errorType) {
25      if (g_errorHandler) {
26          return g_errorHandler(mmapID, errorType);
27      }
28      return OnErrorDiscard;
29  }
30  static function<void(const string &mmapID)> g_contentHandler = nullptr;
31  static void MyContentChangeHandler(const std::string &mmapID) {
32      if (g_contentHandler) {
33          g_contentHandler(mmapID);
34      }
35  }
36  PYBIND11_MODULE(mmkv, m) {
37      m.doc() = "An efficient, small key-value storage framework developed by WeChat Team.";
38      py::enum_<MMKVMode>(m, "MMKVMode")
39          .value("SingleProcess", MMKVMode::MMKV_SINGLE_PROCESS)
40          .value("MultiProcess", MMKVMode::MMKV_MULTI_PROCESS)
41          .export_values();
42      py::enum_<MMKVLogLevel>(m, "MMKVLogLevel")
43          .value("NoLog", MMKVLogLevel::MMKVLogNone)
44          .value("Debug", MMKVLogLevel::MMKVLogDebug)
45          .value("Info", MMKVLogLevel::MMKVLogInfo)
46          .value("Warning", MMKVLogLevel::MMKVLogWarning)
47          .value("Error", MMKVLogLevel::MMKVLogError)
48          .export_values();
49      py::enum_<SyncFlag>(m, "SyncFlag")
50          .value("Sync", SyncFlag::MMKV_SYNC)
51          .value("ASync", SyncFlag::MMKV_ASYNC)
52          .export_values();
53      py::enum_<MMKVRecoverStrategic>(m, "MMKVRecoverStrategic")
54          .value("OnErrorDiscard", MMKVRecoverStrategic::OnErrorDiscard)
55          .value("OnErrorRecover", MMKVRecoverStrategic::OnErrorRecover)
56          .export_values();
57      py::enum_<MMKVErrorType>(m, "MMKVErrorType")
58          .value("CRCCheckFail", MMKVErrorType::MMKVCRCCheckFail)
59          .value("FileLength", MMKVErrorType::MMKVFileLength)
60          .export_values();
61      py::class_<MMKV, unique_ptr<MMKV, py::nodelete>> clsMMKV(m, "MMKV");
62      clsMMKV.def(py::init([](const string &mmapID, MMKVMode mode, const string &cryptKey, const string &rootDir) {
63                      string *cryptKeyPtr = (cryptKey.length() > 0) ? (string *) &cryptKey : nullptr;
64                      string *rootDirPtr = (rootDir.length() > 0) ? (string *) &rootDir : nullptr;
65                      return MMKV::mmkvWithID(mmapID, mode, cryptKeyPtr, rootDirPtr);
66                  }),
67                  "Parameters:\n"
68                  "  mmapID: all instances of the same mmapID share the same data and file storage\n"
69                  "  mode: pass MMKVMode.MultiProcess for a multi-process MMKV\n"
70                  "  cryptKey: pass a non-empty string for an encrypted MMKV, 16 bytes at most\n"
71                  "  rootDir: custom root directory",
72                  py::arg("mmapID"), py::arg("mode") = MMKV_SINGLE_PROCESS, py::arg("cryptKey") = string(),
73                  py::arg("rootDir") = string());
74      clsMMKV.def("__eq__", [](MMKV &kv, const MMKV &other) { return kv.mmapID() == other.mmapID(); });
75      clsMMKV.def_static("initializeMMKV", [](const string &rootDir, MMKVLogLevel logLevel, decltype(g_logHandler) logHandler) {
76              if (logHandler) {
77                  g_logHandler = std::move(logHandler);
78                  MMKV::initializeMMKV(rootDir, logLevel, MyLogHandler);
79              } else {
80                  MMKV::initializeMMKV(rootDir, logLevel, nullptr);
81              }
82          }, "must call this before getting any MMKV instance",
83                         py::arg("rootDir"), py::arg("logLevel") = MMKVLogNone, py::arg("log_handler") = nullptr);
84      clsMMKV.def_static(
85          "defaultMMKV",
86          [](MMKVMode mode, const string &cryptKey) {
87              string *cryptKeyPtr = (cryptKey.length() > 0) ? (string *) &cryptKey : nullptr;
88              return MMKV::defaultMMKV(mode, cryptKeyPtr);
89          },
90          "a generic purpose instance", py::arg("mode") = MMKV_SINGLE_PROCESS, py::arg("cryptKey") = string());
91      clsMMKV.def("mmapID", &MMKV::mmapID);
92      clsMMKV.def_readonly("isInterProcess", &MMKV::m_isInterProcess);
93      clsMMKV.def("cryptKey", &MMKV::cryptKey);
94      clsMMKV.def("reKey", &MMKV::reKey,
95                  "transform plain text into encrypted text, or vice versa with an empty cryptKey\n"
96                  "Parameters:\n"
97                  "  newCryptKey: 16 bytes at most",
98                  py::arg("newCryptKey"));
99      clsMMKV.def("checkReSetCryptKey", &MMKV::checkReSetCryptKey,
100                  "just reset cryptKey (will not encrypt or decrypt anything),\n"
101                  "usually you should call this method after other process reKey() a multi-process mmkv",
102                  py::arg("newCryptKey"));
103      clsMMKV.def("set", (bool (MMKV::*)(bool, const string &))(&MMKV::set), "encode a boolean value", py::arg("value"),
104                  py::arg("key"));
105      clsMMKV.def("set", (bool (MMKV::*)(bool, const string &, uint32_t))(&MMKV::set), "encode a boolean value with expiration",
106                  py::arg("value"), py::arg("key"), py::arg("expireDuration"));
107      clsMMKV.def("set", (bool (MMKV::*)(int32_t, const string &))(&MMKV::set), "encode an int32 value",
108                  py::arg("value"), py::arg("key"));
109      clsMMKV.def("set", (bool (MMKV::*)(int32_t, const string &, uint32_t))(&MMKV::set), "encode an int32 value with expiration", py::arg("value"),
110                  py::arg("key"), py::arg("expireDuration"));
111      clsMMKV.def("set", (bool (MMKV::*)(uint32_t, const string &))(&MMKV::set), "encode an unsigned int32 value",
112                  py::arg("value"), py::arg("key"));
113      clsMMKV.def("set", (bool (MMKV::*)(uint32_t, const string &, uint32_t))(&MMKV::set), "encode an unsigned int32 value with expiration",
114                  py::arg("value"), py::arg("key"), py::arg("expireDuration"));
115      clsMMKV.def("set", (bool (MMKV::*)(int64_t, const string &))(&MMKV::set), "encode an int64 value", py::arg("value"),
116                  py::arg("key"));
117      clsMMKV.def("set", (bool (MMKV::*)(int64_t, const string &, uint32_t))(&MMKV::set), "encode an int64 value with expiration", py::arg("value"),
118                  py::arg("key"), py::arg("expireDuration"));
119      clsMMKV.def("set", (bool (MMKV::*)(uint64_t, const string &))(&MMKV::set), "encode an unsigned int64 value",
120                  py::arg("value"), py::arg("key"));
121      clsMMKV.def("set", (bool (MMKV::*)(uint64_t, const string &, uint32_t))(&MMKV::set), "encode an unsigned int64 value with expiration",
122                  py::arg("value"), py::arg("key"), py::arg("expireDuration"));
123      clsMMKV.def("set", (bool (MMKV::*)(double, const string &))(&MMKV::set), "encode a float/double value",
124                  py::arg("value"), py::arg("key"));
125      clsMMKV.def("set", (bool (MMKV::*)(double, const string &, uint32_t))(&MMKV::set), "encode a float/double value with expiration",
126                  py::arg("value"), py::arg("key"), py::arg("expireDuration"));
127      clsMMKV.def("set", (bool (MMKV::*)(const string &, const string &))(&MMKV::set),
128                  "encode an UTF-8 String/bytes value", py::arg("value"), py::arg("key"));
129      clsMMKV.def("set", (bool (MMKV::*)(const string &, const string &, uint32_t))(&MMKV::set),
130                  "encode an UTF-8 String/bytes value with expiration", py::arg("value"), py::arg("key"), py::arg("expireDuration"));
131  #if PY_MAJOR_VERSION >= 3
132      clsMMKV.def(
133          "set", [](MMKV &kv, const py::bytes &value, const string &key) { return kv.set(pyBytes2MMBuffer(value), key); },
134          "encode a bytes value", py::arg("value"), py::arg("key"));
135      clsMMKV.def(
136          "set",
137          [](MMKV &kv, const py::bytes &value, const string &key, uint32_t expireDuration) {
138                      return kv.set(pyBytes2MMBuffer(value), key, expireDuration);
139                  },
140          "encode a bytes value with expiration", py::arg("value"), py::arg("key"), py::arg("expireDuration"));
141  #endif
142      clsMMKV.def("getBool", &MMKV::getBool, "decode a boolean value", py::arg("key"), py::arg("defaultValue") = false, py::arg("hasValue") = nullptr);
143      clsMMKV.def("getInt", &MMKV::getInt32, "decode an int32 value", py::arg("key"), py::arg("defaultValue") = 0, py::arg("hasValue") = nullptr);
144      clsMMKV.def("getUInt", &MMKV::getUInt32, "decode an unsigned int32 value", py::arg("key"),
145                  py::arg("defaultValue") = 0, py::arg("hasValue") = nullptr);
146      clsMMKV.def("getLongInt", &MMKV::getInt64, "decode an int64 value", py::arg("key"), py::arg("defaultValue") = 0, py::arg("hasValue") = nullptr);
147      clsMMKV.def("getLongUInt", &MMKV::getUInt64, "decode an unsigned int64 value", py::arg("key"),
148                  py::arg("defaultValue") = 0, py::arg("hasValue") = nullptr);
149      clsMMKV.def("getFloat", &MMKV::getDouble, "decode a float/double value", py::arg("key"),
150                  py::arg("defaultValue") = 0, py::arg("hasValue") = nullptr);
151      clsMMKV.def(
152          "getString",
153          [](MMKV &kv, const string &key, const string &defaultValue) {
154              string result;
155              if (kv.getString(key, result)) {
156                  return result;
157              }
158              return defaultValue;
159          },
160          "decode an UTF-8 String/bytes value", py::arg("key"), py::arg("defaultValue") = string());
161      clsMMKV.def(
162          "getBytes",
163          [](MMKV &kv, const string &key, const py::bytes &defaultValue) {
164              MMBuffer result = kv.getBytes(key);
165              if (result.length() > 0) {
166                  return py::bytes((const char *) result.getPtr(), result.length());
167              }
168              return defaultValue;
169          },
170          "decode a bytes value", py::arg("key"), py::arg("defaultValue") = py::bytes());
171      clsMMKV.def("__contains__", &MMKV::containsKey, py::arg("key"));
172      clsMMKV.def("keys", &MMKV::allKeys);
173      clsMMKV.def("count", &MMKV::count);
174      clsMMKV.def("totalSize", &MMKV::totalSize);
175      clsMMKV.def("actualSize", &MMKV::actualSize);
176      clsMMKV.def("remove", &MMKV::removeValueForKey, py::arg("key"));
177      clsMMKV.def("remove", &MMKV::removeValuesForKeys, py::arg("keys"));
178      clsMMKV.def("clearAll", &MMKV::clearAll, "remove all key-values");
179      clsMMKV.def("trim", &MMKV::trim, "call this method after lots of removing if you care about disk usage");
180      clsMMKV.def("clearMemoryCache", &MMKV::clearMemoryCache, "call this method if you are facing memory-warning");
181      clsMMKV.def("sync", &MMKV::sync, py::arg("flag") = MMKV_SYNC,
182                  "this call is not necessary unless you worry about unexpected shutdown of the machine (running out of "
183                  "battery, etc)");
184      clsMMKV.def("enableAutoKeyExpire", &MMKV::enableAutoKeyExpire, py::arg("expireDurationInSecond"),
185                  "turn on auto key expiration, passing 0 means never expire");
186      clsMMKV.def("disableAutoKeyExpire", &MMKV::disableAutoKeyExpire, "turn off auto key expiration");
187      clsMMKV.def("lock", &MMKV::lock, "get exclusive access, won't return until the lock is obtained");
188      clsMMKV.def("unlock", &MMKV::unlock);
189      clsMMKV.def("try_lock", &MMKV::try_lock, "try to get exclusive access");
190      clsMMKV.def_static(
191          "registerLogHandler",
192          [](decltype(g_logHandler) callback) {
193              g_logHandler = std::move(callback);
194              MMKV::registerLogHandler(MyLogHandler);
195          },
196          "call this method to redirect MMKV's log,\n"
197          "must call MMKV.unRegisterLogHandler() or MMKV.onExit() before exit\n"
198          "Parameters:\n"
199          "  log_handler: (logLevel: mmkv.MMKVLogLevel, file: str, line: int, function: str, message: str) -> None",
200          py::arg("log_handler"));
201      clsMMKV.def_static(
202          "unRegisterLogHandler",
203          [] {
204              g_logHandler = nullptr;
205              MMKV::unRegisterLogHandler();
206          },
207          "If you have registered a log handler, you must call this method or MMKV.onExit() before exit. "
208          "Otherwise your app/script won't exit properly.");
209      clsMMKV.def_static(
210          "registerErrorHandler",
211          [](decltype(g_errorHandler) callback) {
212              g_errorHandler = std::move(callback);
213              MMKV::registerErrorHandler(MyErrorHandler);
214          },
215          "call this method to handle MMKV failure,\n"
216          "must call MMKV.unRegisterErrorHandler() or MMKV.onExit() before exit\n"
217          "Parameters:\n"
218          "  error_handler: (mmapID: str, errorType: mmkv.MMKVErrorType) -> mmkv.MMKVRecoverStrategic",
219          py::arg("error_handler"));
220      clsMMKV.def_static(
221          "unRegisterErrorHandler",
222          [] {
223              g_errorHandler = nullptr;
<span onclick='openModal()' class='match'>224              MMKV::unRegisterErrorHandler();
225          },
226          "If you have registered an error handler, you must call this method or MMKV.onExit() before exit. "
227          "Otherwise your app/script won't exit properly.");
228      clsMMKV.def("checkContentChanged", &MMKV::checkContentChanged, "check if content been changed by other process");
229      clsMMKV.def_static(
230          "registerContentChangeHandler",
231          [](decltype(g_contentHandler) callback) {
232              g_contentHandler = std::move(callback);
233              MMKV::registerContentChangeHandler(MyContentChangeHandler);
234          },
235          "register a content change handler,\n"
236          "get notified when an MMKV instance has been changed by other process (not guarantee real-time notification),\n"
237          "must call MMKV.unRegisterContentChangeHandler() or MMKV.onExit() before exit\n"
238          "Parameters:\n"
239          "  content_change_handler: (mmapID: str) -> None",
240          py::arg("content_change_handler"));
241      clsMMKV.def_static(
</span>242          "unRegisterContentChangeHandler",
243          [] {
244              g_contentHandler = nullptr;
245              MMKV::unRegisterContentChangeHandler();
246          },
247          "If you have registered a content change handler, you must call this method or MMKV.onExit() before exit. "
248          "Otherwise your app/script won't exit properly.");
249      clsMMKV.def_static(
250          "onExit",
251          [] {
252              MMKV::onExit();
253              g_logHandler = nullptr;
254              g_errorHandler = nullptr;
255              g_contentHandler = nullptr;
256          },
257          "call this method before exit, especially if you have registered any callback handlers");
258      clsMMKV.def_static(
259          "backupOneToDirectory",
260          [](const string &mmapID, const string &dstDir, const string &srcDir) {
261              string *srcDirPtr = (srcDir.length() > 0) ? (string *) &srcDir : nullptr;
262              return MMKV::backupOneToDirectory(mmapID, dstDir, srcDirPtr);
263          },
264          "backup one MMKV instance from srcDir (default to the root dir of MMKV) to dstDir",
265          py::arg("mmapID"), py::arg("dstDir"), py::arg("srcDir") = string());
266      clsMMKV.def_static(
267          "restoreOneFromDirectory",
268          [](const string &mmapID, const string &srcDir, const string &dstDir) {
269              string *dstDirPtr = (dstDir.length() > 0) ? (string *) &dstDir : nullptr;
270              return MMKV::restoreOneFromDirectory(mmapID, srcDir, dstDirPtr);
271          },
272          "restore one MMKV instance from srcDir to dstDir (default to the root dir of MMKV)",
273          py::arg("mmapID"), py::arg("srcDir"), py::arg("dstDir") = string());
274      clsMMKV.def_static(
275          "backupAllToDirectory",
276          [](const string &dstDir, const string &srcDir) {
277              string *srcDirPtr = (srcDir.length() > 0) ? (string *) &srcDir : nullptr;
278              return MMKV::backupAllToDirectory(dstDir, srcDirPtr);
279          },
280          "backup all MMKV instance from srcDir (default to the root dir of MMKV) to dstDir",
281          py::arg("dstDir"), py::arg("srcDir") = string());
282      clsMMKV.def_static(
283          "restoreAllFromDirectory",
284          [](const string &srcDir, const string &dstDir) {
285              string *dstDirPtr = (dstDir.length() > 0) ? (string *) &dstDir : nullptr;
286              return MMKV::restoreAllFromDirectory(srcDir, dstDirPtr);
287          },
288          "restore all MMKV instance from srcDir to dstDir (default to the root dir of MMKV)",
289          py::arg("srcDir"), py::arg("dstDir") = string());
290  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-usage_config_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-libmmkv_python.cpp</div>
                </div>
                <div class="column column_space"><pre><code>59        config.contains_helpshort_flags("aaaa/usage_config_test-main.cc"));
60    EXPECT_TRUE(config.contains_helpshort_flags("abc/usage_config_test_main.cc"));
61    EXPECT_FALSE(config.contains_helpshort_flags("usage_config_main.cc"));
62    absl::FlagsUsageConfig empty_config;
63    empty_config.contains_helpshort_flags = &TstContainsHelpshortFlags;
64    absl::SetFlagsUsageConfig(empty_config);
65    EXPECT_TRUE(
66        flags::GetUsageConfig().contains_helpshort_flags("aaa/progname.cpp"));
67    EXPECT_FALSE(
68        flags::GetUsageConfig().contains_helpshort_flags("aaa/progmane.cpp"));
</pre></code></div>
                <div class="column column_space"><pre><code>224              MMKV::unRegisterErrorHandler();
225          },
226          "If you have registered an error handler, you must call this method or MMKV.onExit() before exit. "
227          "Otherwise your app/script won't exit properly.");
228      clsMMKV.def("checkContentChanged", &MMKV::checkContentChanged, "check if content been changed by other process");
229      clsMMKV.def_static(
230          "registerContentChangeHandler",
231          [](decltype(g_contentHandler) callback) {
232              g_contentHandler = std::move(callback);
233              MMKV::registerContentChangeHandler(MyContentChangeHandler);
234          },
235          "register a content change handler,\n"
236          "get notified when an MMKV instance has been changed by other process (not guarantee real-time notification),\n"
237          "must call MMKV.unRegisterContentChangeHandler() or MMKV.onExit() before exit\n"
238          "Parameters:\n"
239          "  content_change_handler: (mmapID: str) -> None",
240          py::arg("content_change_handler"));
241      clsMMKV.def_static(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    