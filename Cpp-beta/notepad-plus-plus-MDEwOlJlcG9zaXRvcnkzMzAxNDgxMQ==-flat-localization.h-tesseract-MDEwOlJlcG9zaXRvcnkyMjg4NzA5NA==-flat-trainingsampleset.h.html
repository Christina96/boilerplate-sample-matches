
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 77.5%, Tokens: 32, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-localization.h</h3>
            <pre><code>1  #pragma once
2  #include "Common.h"
3  #include "tinyxmlA.h"
4  class FindReplaceDlg;
5  class PreferenceDlg;
6  class ShortcutMapper;
7  class UserDefineDialog;
8  class PluginsAdminDlg;
9  class MenuPosition {
10  public:
11  	int _x = -1; 
12  	int _y = -1; 
13  	int _z = -1; 
14  	char _id[64] = { '\0' }; 
15  };
16  class NativeLangSpeaker {
17  public:
<span onclick='openModal()' class='match'>18  	NativeLangSpeaker():_nativeLangA(NULL), _nativeLangEncoding(CP_ACP), _isRTL(false), _fileName(NULL){};
19  	void init(TiXmlDocumentA *nativeLangDocRootA, bool loadIfEnglish = false);
20  	void changeConfigLang(HWND hDlg);
21  	void changeLangTabContextMenu(HMENU hCM);
22  	TiXmlNodeA * searchDlgNode(TiXmlNodeA *node, const char *dlgTagName);
23  	bool changeDlgLang(HWND hDlg, const char *dlgTagName, char *title = NULL, size_t titleMaxSize = 0);
24  	void changeLangTabDropContextMenu(HMENU hCM);
25  	void changeLangTrayIconContexMenu(HMENU hCM);
</span>26  	generic_string getSubMenuEntryName(const char *nodeName) const;
27  	generic_string getNativeLangMenuString(int itemID) const;
28  	generic_string getShortcutNameString(int itemID) const;
29  	void changeMenuLang(HMENU menuHandle);
30  	void changeShortcutLang();
31  	void changeStyleCtrlsLang(HWND hDlg, int *idArray, const char **translatedText);
32  	void changeUserDefineLang(UserDefineDialog *userDefineDlg);
33  	void changeUserDefineLangPopupDlg(HWND hDlg);
34  	void changeFindReplaceDlgLang(FindReplaceDlg & findReplaceDlg);
35  	void changePrefereceDlgLang(PreferenceDlg & preference);
36  	void changePluginsAdminDlgLang(PluginsAdminDlg & pluginsAdminDlg);
37  	bool getDoSaveOrNotStrings(generic_string& title, generic_string& msg);
38  	bool isRTL() const {
39  		return _isRTL;
40  	};
41  	const char * getFileName() const {
42  		return _fileName;
43  	};
44  	const TiXmlNodeA * getNativeLangA() {
45  		return _nativeLangA;
46  	};
47  	int getLangEncoding() const {
48  		return _nativeLangEncoding;
49  	};
50  	bool getMsgBoxLang(const char *msgBoxTagName, generic_string & title, generic_string & message);
51  	generic_string getShortcutMapperLangStr(const char *nodeName, const TCHAR *defaultStr) const;
52  	generic_string getProjectPanelLangMenuStr(const char * nodeName, int cmdID, const TCHAR *defaultStr) const;
53  	generic_string getDlgLangMenuStr(const char* firstLevelNodeName, const char* secondLevelNodeName, int cmdID, const TCHAR *defaultStr) const;
54  	generic_string getAttrNameStr(const TCHAR *defaultStr, const char *nodeL1Name, const char *nodeL2Name, const char *nodeL3Name = "name") const;
55  	generic_string getAttrNameByIdStr(const TCHAR *defaultStr, TiXmlNodeA *targetNode, const char *nodeL1Value, const char *nodeL1Name = "id", const char *nodeL2Name = "name") const;
56  	generic_string getLocalizedStrFromID(const char *strID, const generic_string& defaultString) const;
57  	int messageBox(const char *msgBoxTagName, HWND hWnd, const TCHAR *message, const TCHAR *title, int msgBoxType, int intInfo = 0, const TCHAR *strInfo = NULL);
58  private:
59  	TiXmlNodeA *_nativeLangA;
60  	int _nativeLangEncoding;
61  	bool _isRTL;
62  	const char *_fileName;
63  };
64  MenuPosition & getMenuPosition(const char *id);
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trainingsampleset.h</h3>
            <pre><code>1  #ifndef TESSERACT_TRAINING_TRAININGSAMPLESET_H_
2  #define TESSERACT_TRAINING_TRAININGSAMPLESET_H_
3  #include "bitvector.h"
4  #include "indexmapbidi.h"
5  #include "matrix.h"
6  #include "shapetable.h"
7  #include "trainingsample.h"
8  namespace tesseract {
9  class UNICHARSET;
10  struct FontInfo;
11  class FontInfoTable;
12  class IntFeatureMap;
13  class IntFeatureSpace;
14  class TrainingSample;
15  struct UnicharAndFonts;
16  class TrainingSampleSet {
17  public:
18    explicit TrainingSampleSet(const FontInfoTable &fontinfo_table);
19    ~TrainingSampleSet();
20    bool Serialize(FILE *fp) const;
21    bool DeSerialize(bool swap, FILE *fp);
22    int num_samples() const {
23      return samples_.size();
24    }
25    int num_raw_samples() const {
26      return num_raw_samples_;
27    }
28    int NumFonts() const {
29      return font_id_map_.SparseSize();
30    }
31    const UNICHARSET &unicharset() const {
32      return unicharset_;
33    }
34    int charsetsize() const {
35      return unicharset_size_;
36    }
37    const FontInfoTable &fontinfo_table() const {
38      return fontinfo_table_;
39    }
40    void LoadUnicharset(const char *filename);
41    int AddSample(const char *unichar, TrainingSample *sample);
42    void AddSample(int unichar_id, TrainingSample *sample);
43    int NumClassSamples(int font_id, int class_id, bool randomize) const;
44    const TrainingSample *GetSample(int index) const;
45    const TrainingSample *GetSample(int font_id, int class_id, int index) const;
46    TrainingSample *MutableSample(int font_id, int class_id, int index);
47    std::string SampleToString(const TrainingSample &sample) const;
48    const BitVector &GetCloudFeatures(int font_id, int class_id) const;
49    const std::vector<int> &GetCanonicalFeatures(int font_id, int class_id) const;
50    float UnicharDistance(const UnicharAndFonts &uf1, const UnicharAndFonts &uf2, bool matched_fonts,
51                          const IntFeatureMap &feature_map);
52    float ClusterDistance(int font_id1, int class_id1, int font_id2, int class_id2,
53                          const IntFeatureMap &feature_map);
54    float ComputeClusterDistance(int font_id1, int class_id1, int font_id2, int class_id2,
55                                 const IntFeatureMap &feature_map) const;
56    int ReliablySeparable(int font_id1, int class_id1, int font_id2, int class_id2,
57                          const IntFeatureMap &feature_map, bool thorough) const;
58    int GlobalSampleIndex(int font_id, int class_id, int index) const;
59    const TrainingSample *GetCanonicalSample(int font_id, int class_id) const;
60    float GetCanonicalDist(int font_id, int class_id) const;
61    TrainingSample *mutable_sample(int index) {
62      return samples_[index];
63    }
64    TrainingSample *extract_sample(int index) {
65      TrainingSample *sample = samples_[index];
66      samples_[index] = nullptr;
67      return sample;
<span onclick='openModal()' class='match'>68    }
69    void IndexFeatures(const IntFeatureSpace &feature_space);
70    void KillSample(TrainingSample *sample);
71    void DeleteDeadSamples();
72    void OrganizeByFontAndClass();
73    void SetupFontIdMap();
74    void ComputeCanonicalSamples(const IntFeatureMap &map, bool debug);
75    void ReplicateAndRandomizeSamples();
76    void ComputeCanonicalFeatures();
77    void ComputeCloudFeatures(int feature_space_size);
78    void AddAllFontsForClass(int class_id, Shape *shape) const;
79    void DisplaySamplesWithFeature(int f_index, const Shape &shape,
80                                   const IntFeatureSpace &feature_space, ScrollView::Color color,
</span>81                                   ScrollView *window) const;
82  private:
83    struct FontClassDistance {
84      int unichar_id;
85      int font_id; 
86      float distance;
87    };
88    struct FontClassInfo {
89      FontClassInfo();
90      bool Serialize(FILE *fp) const;
91      bool DeSerialize(bool swap, FILE *fp);
92      int32_t num_raw_samples;
93      int32_t canonical_sample;
94      float canonical_dist;
95      std::vector<int32_t> samples;
96      std::vector<int> canonical_features;
97      BitVector cloud_features;
98      std::vector<float> font_distance_cache;
99      std::vector<float> unichar_distance_cache;
100      std::vector<FontClassDistance> distance_cache;
101    };
102    std::vector<TrainingSample *> samples_;
103    int num_raw_samples_;
104    UNICHARSET unicharset_;
105    int unicharset_size_;
106    IndexMapBiDi font_id_map_;
107    GENERIC_2D_ARRAY<FontClassInfo> *font_class_array_;
108    const FontInfoTable &fontinfo_table_;
109  };
110  } 
111  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-localization.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trainingsampleset.h</div>
                </div>
                <div class="column column_space"><pre><code>18  	NativeLangSpeaker():_nativeLangA(NULL), _nativeLangEncoding(CP_ACP), _isRTL(false), _fileName(NULL){};
19  	void init(TiXmlDocumentA *nativeLangDocRootA, bool loadIfEnglish = false);
20  	void changeConfigLang(HWND hDlg);
21  	void changeLangTabContextMenu(HMENU hCM);
22  	TiXmlNodeA * searchDlgNode(TiXmlNodeA *node, const char *dlgTagName);
23  	bool changeDlgLang(HWND hDlg, const char *dlgTagName, char *title = NULL, size_t titleMaxSize = 0);
24  	void changeLangTabDropContextMenu(HMENU hCM);
25  	void changeLangTrayIconContexMenu(HMENU hCM);
</pre></code></div>
                <div class="column column_space"><pre><code>68    }
69    void IndexFeatures(const IntFeatureSpace &feature_space);
70    void KillSample(TrainingSample *sample);
71    void DeleteDeadSamples();
72    void OrganizeByFontAndClass();
73    void SetupFontIdMap();
74    void ComputeCanonicalSamples(const IntFeatureMap &map, bool debug);
75    void ReplicateAndRandomizeSamples();
76    void ComputeCanonicalFeatures();
77    void ComputeCloudFeatures(int feature_space_size);
78    void AddAllFontsForClass(int class_id, Shape *shape) const;
79    void DisplaySamplesWithFeature(int f_index, const Shape &shape,
80                                   const IntFeatureSpace &feature_space, ScrollView::Color color,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    