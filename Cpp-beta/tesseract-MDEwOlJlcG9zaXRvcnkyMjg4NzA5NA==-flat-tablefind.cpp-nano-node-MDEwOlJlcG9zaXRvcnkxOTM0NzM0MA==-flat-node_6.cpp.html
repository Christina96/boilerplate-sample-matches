
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.81081081081081%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <algorithm>
5  #include <cmath>
6  #include <utility>
7  #include "tablefind.h"
8  #include <allheaders.h>
9  #include "colpartitionset.h"
10  #include "tablerecog.h"
11  namespace tesseract {
12  const int kMaxVerticalSpacing = 500;
13  const int kMaxBlobWidth = 500;
14  const double kSplitPartitionSize = 2.0;
15  const double kAllowTextHeight = 0.5;
16  const double kAllowTextWidth = 0.6;
17  const double kAllowTextArea = 0.8;
18  const double kAllowBlobHeight = 0.3;
19  const double kAllowBlobWidth = 0.4;
20  const double kAllowBlobArea = 0.05;
21  const int kMinBoxesInTextPartition = 10;
22  const int kMaxBoxesInDataPartition = 20;
23  const double kMaxGapInTextPartition = 4.0;
24  const double kMinMaxGapInTextPartition = 0.5;
25  const double kMaxBlobOverlapFactor = 4.0;
26  const double kMaxTableCellXheight = 2.0;
27  const int kMaxColumnHeaderDistance = 4;
28  const double kTableColumnThreshold = 3.0;
29  const double kMinOverlapWithTable = 0.6;
30  const int kSideSpaceMargin = 10;
31  const double kSmallTableProjectionThreshold = 0.35;
32  const double kLargeTableProjectionThreshold = 0.45;
33  const int kLargeTableRowCount = 6;
34  const int kMinRowsInTable = 3;
35  const int kAdjacentLeaderSearchPadding = 2;
36  const double kParagraphEndingPreviousLineRatio = 1.3;
37  const double kMaxParagraphEndingLeftSpaceMultiple = 3.0;
38  const double kMinParagraphEndingTextToWhitespaceRatio = 3.0;
39  const double kMaxXProjectionGapFactor = 2.0;
40  const double kStrokeWidthFractionalTolerance = 0.25;
41  const double kStrokeWidthConstantTolerance = 2.0;
42  #ifndef GRAPHICS_DISABLED
43  static BOOL_VAR(textord_show_tables, false, "Show table regions (ScrollView)");
44  static BOOL_VAR(textord_tablefind_show_mark, false,
45                  "Debug table marking steps in detail (ScrollView)");
46  static BOOL_VAR(textord_tablefind_show_stats, false,
47                  "Show page stats used in table finding (ScrollView)");
48  #endif
49  static BOOL_VAR(textord_tablefind_recognize_tables, false,
50                  "Enables the table recognizer for table layout and filtering.");
51  template <typename T>
52  void DeleteObject(T *object) {
53    delete object;
54  }
55  TableFinder::TableFinder()
56      : resolution_(0),
57        global_median_xheight_(0),
58        global_median_blob_width_(0),
59        global_median_ledding_(0),
60        left_to_right_language_(true) {}
61  TableFinder::~TableFinder() {
62    clean_part_grid_.ClearGridData(&DeleteObject<ColPartition>);
63    leader_and_ruling_grid_.ClearGridData(&DeleteObject<ColPartition>);
64    fragmented_text_grid_.ClearGridData(&DeleteObject<ColPartition>);
65    col_seg_grid_.ClearGridData(&DeleteObject<ColSegment>);
66    table_grid_.ClearGridData(&DeleteObject<ColSegment>);
67  }
68  void TableFinder::set_left_to_right_language(bool order) {
69    left_to_right_language_ = order;
70  }
71  void TableFinder::Init(int grid_size, const ICOORD &bottom_left,
72                         const ICOORD &top_right) {
73    clean_part_grid_.Init(grid_size, bottom_left, top_right);
74    leader_and_ruling_grid_.Init(grid_size, bottom_left, top_right);
75    fragmented_text_grid_.Init(grid_size, bottom_left, top_right);
76    col_seg_grid_.Init(grid_size, bottom_left, top_right);
77    table_grid_.Init(grid_size, bottom_left, top_right);
78  }
79  void TableFinder::InsertCleanPartitions(ColPartitionGrid *grid,
80                                          TO_BLOCK *block) {
81    SetGlobalSpacings(grid);
82    ColPartitionGridSearch gsearch(grid);
83    gsearch.SetUniqueMode(true);
84    gsearch.StartFullSearch();
85    ColPartition *part = nullptr;
86    while ((part = gsearch.NextFullSearch()) != nullptr) {
87      if (part->blob_type() == BRT_NOISE || part->bounding_box().area() <= 0) {
88        continue;
89      }
90      ColPartition *clean_part = part->ShallowCopy();
91      ColPartition *leader_part = nullptr;
92      if (part->IsLineType()) {
93        InsertRulingPartition(clean_part);
94        continue;
95      }
96      if (!part->IsTextType()) {
97        InsertImagePartition(clean_part);
98        continue;
99      }
100      BLOBNBOX_CLIST *part_boxes = part->boxes();
101      BLOBNBOX_C_IT pit(part_boxes);
102      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
103        BLOBNBOX *pblob = pit.data();
104        if (!AllowBlob(*pblob)) {
105          continue;
106        }
107        if (pblob->flow() == BTFT_LEADER) {
108          if (leader_part == nullptr) {
109            leader_part = part->ShallowCopy();
110            leader_part->set_flow(BTFT_LEADER);
111          }
112          leader_part->AddBox(pblob);
113        } else if (pblob->region_type() != BRT_NOISE) {
114          clean_part->AddBox(pblob);
115        }
116      }
117      clean_part->ComputeLimits();
118      ColPartition *fragmented = clean_part->CopyButDontOwnBlobs();
119      InsertTextPartition(clean_part);
120      SplitAndInsertFragmentedTextPartition(fragmented);
121      if (leader_part != nullptr) {
122        leader_part->ComputeLimits();
123        InsertLeaderPartition(leader_part);
124      }
125    }
126    clean_part_grid_.FindPartitionPartners();
127    clean_part_grid_.RefinePartitionPartners(false);
128  }
129  void TableFinder::LocateTables(ColPartitionGrid *grid,
130                                 ColPartitionSet **all_columns,
131                                 WidthCallback width_cb, const FCOORD &reskew) {
132    InitializePartitions(all_columns);
133  #ifndef GRAPHICS_DISABLED
134    if (textord_show_tables) {
135      ScrollView *table_win = MakeWindow(0, 300, "Column Partitions & Neighbors");
136      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
137      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
138                           ScrollView::AQUAMARINE);
139      DisplayColPartitionConnections(table_win, &clean_part_grid_,
140                                     ScrollView::ORANGE);
141      table_win = MakeWindow(100, 300, "Fragmented Text");
142      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE);
143    }
144  #endif 
145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &column_blocks);
148    SetColumnsType(&column_blocks);
149    MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);
150    GridMergeColumnBlocks();
151    ColSegment_LIST table_columns;
152    GetTableColumns(&table_columns);
153    ColSegment_LIST table_regions;
154    GetTableRegions(&table_columns, &table_regions);
155  #ifndef GRAPHICS_DISABLED
156    if (textord_tablefind_show_mark) {
157      ScrollView *table_win = MakeWindow(1200, 300, "Table Columns and Regions");
158      DisplayColSegments(table_win, &table_columns, ScrollView::DARK_TURQUOISE);
159      DisplayColSegments(table_win, &table_regions, ScrollView::YELLOW);
160    }
161  #endif 
162    MoveColSegmentsToGrid(&table_regions, &table_grid_);
163    GridMergeTableRegions();
164    AdjustTableBoundaries();
165    GridMergeTableRegions();
166    if (textord_tablefind_recognize_tables) {
167      DeleteSingleColumnTables();
168  #ifndef GRAPHICS_DISABLED
169      if (textord_show_tables) {
170        ScrollView *table_win = MakeWindow(1200, 300, "Detected Table Locations");
171        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
172        DisplayColSegments(table_win, &table_columns, ScrollView::KHAKI);
173        table_grid_.DisplayBoxes(table_win);
174      }
175  #endif 
176      RecognizeTables();
177      GridMergeTableRegions();
178      RecognizeTables();
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_tables) {
181        ScrollView *table_win = MakeWindow(1400, 600, "Recognized Tables");
182        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
183                             ScrollView::BLUE);
184        table_grid_.DisplayBoxes(table_win);
185      }
186  #endif 
187    } else {
188      DeleteSingleColumnTables();
189  #ifndef GRAPHICS_DISABLED
190      if (textord_show_tables) {
191        ScrollView *table_win = MakeWindow(1500, 300, "Detected Tables");
192        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
193                             ScrollView::BLUE);
194        table_grid_.DisplayBoxes(table_win);
195      }
196  #endif 
197    }
198    MakeTableBlocks(grid, all_columns, width_cb);
199  }
200  int TableFinder::gridsize() const {
201    return clean_part_grid_.gridsize();
202  }
203  int TableFinder::gridwidth() const {
204    return clean_part_grid_.gridwidth();
205  }
206  int TableFinder::gridheight() const {
207    return clean_part_grid_.gridheight();
208  }
209  const ICOORD &TableFinder::bleft() const {
210    return clean_part_grid_.bleft();
211  }
212  const ICOORD &TableFinder::tright() const {
213    return clean_part_grid_.tright();
214  }
215  void TableFinder::InsertTextPartition(ColPartition *part) {
216    ASSERT_HOST(part != nullptr);
217    if (AllowTextPartition(*part)) {
218      clean_part_grid_.InsertBBox(true, true, part);
219    } else {
220      delete part;
221    }
222  }
223  void TableFinder::InsertFragmentedTextPartition(ColPartition *part) {
224    ASSERT_HOST(part != nullptr);
225    if (AllowTextPartition(*part)) {
226      fragmented_text_grid_.InsertBBox(true, true, part);
227    } else {
228      delete part;
229    }
230  }
231  void TableFinder::InsertLeaderPartition(ColPartition *part) {
232    ASSERT_HOST(part != nullptr);
233    if (!part->IsEmpty() && part->bounding_box().area() > 0) {
234      leader_and_ruling_grid_.InsertBBox(true, true, part);
235    } else {
236      delete part;
237    }
238  }
239  void TableFinder::InsertRulingPartition(ColPartition *part) {
240    leader_and_ruling_grid_.InsertBBox(true, true, part);
241  }
242  void TableFinder::InsertImagePartition(ColPartition *part) {
243    clean_part_grid_.InsertBBox(true, true, part);
244  }
245  void TableFinder::SplitAndInsertFragmentedTextPartition(ColPartition *part) {
246    ASSERT_HOST(part != nullptr);
247    if (part->boxes()->empty()) {
248      delete part;
249      return;
250    }
251    ASSERT_HOST(part->median_width() > 0);
252    const double kThreshold = part->median_width() * kSplitPartitionSize;
253    ColPartition *right_part = part;
254    bool found_split = true;
255    while (found_split) {
256      found_split = false;
257      BLOBNBOX_C_IT box_it(right_part->boxes());
258      int previous_right = INT32_MIN;
259      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
260        const TBOX &box = box_it.data()->bounding_box();
261        if (previous_right != INT32_MIN &&
262            box.left() - previous_right > kThreshold) {
263          int mid_x = (box.left() + previous_right) / 2;
264          ColPartition *left_part = right_part;
265          right_part = left_part->SplitAt(mid_x);
266          InsertFragmentedTextPartition(left_part);
267          found_split = true;
268          break;
269        }
270        previous_right = std::max(previous_right, static_cast<int>(box.right()));
271      }
272    }
273    InsertFragmentedTextPartition(right_part);
274  }
275  bool TableFinder::AllowTextPartition(const ColPartition &part) const {
276    const double kHeightRequired = global_median_xheight_ * kAllowTextHeight;
277    const double kWidthRequired = global_median_blob_width_ * kAllowTextWidth;
278    const int median_area = global_median_xheight_ * global_median_blob_width_;
279    const double kAreaPerBlobRequired = median_area * kAllowTextArea;
280    return part.median_height() > kHeightRequired &&
281           part.median_width() > kWidthRequired &&
282           part.bounding_box().area() > kAreaPerBlobRequired * part.boxes_count();
283  }
284  bool TableFinder::AllowBlob(const BLOBNBOX &blob) const {
285    const TBOX &box = blob.bounding_box();
286    const double kHeightRequired = global_median_xheight_ * kAllowBlobHeight;
287    const double kWidthRequired = global_median_blob_width_ * kAllowBlobWidth;
288    const int median_area = global_median_xheight_ * global_median_blob_width_;
289    const double kAreaRequired = median_area * kAllowBlobArea;
290    return box.height() > kHeightRequired && box.width() > kWidthRequired &&
291           box.area() > kAreaRequired;
292  }
293  #ifndef GRAPHICS_DISABLED
294  ScrollView *TableFinder::MakeWindow(int x, int y, const char *window_name) {
295    return clean_part_grid_.MakeWindow(x, y, window_name);
296  }
297  #endif
298  void TableFinder::GetColumnBlocks(ColPartitionSet **all_columns,
299                                    ColSegment_LIST *column_blocks) {
300    for (int i = 0; i < gridheight(); ++i) {
301      ColPartitionSet *columns = all_columns[i];
302      if (columns != nullptr) {
303        ColSegment_LIST new_blocks;
304        columns->GetColumnBoxes(i * gridsize(), (i + 1) * gridsize(),
305                                &new_blocks);
306        GroupColumnBlocks(&new_blocks, column_blocks);
307      }
308    }
309  }
310  void TableFinder::GroupColumnBlocks(ColSegment_LIST *new_blocks,
311                                      ColSegment_LIST *column_blocks) {
312    ColSegment_IT src_it(new_blocks);
313    ColSegment_IT dest_it(column_blocks);
314    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
315      ColSegment *src_seg = src_it.data();
316      const TBOX &src_box = src_seg->bounding_box();
317      bool match_found = false;
318      for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
319        ColSegment *dest_seg = dest_it.data();
320        TBOX dest_box = dest_seg->bounding_box();
321        if (ConsecutiveBoxes(src_box, dest_box)) {
322          dest_seg->InsertBox(src_box);
323          match_found = true;
324          delete src_it.extract();
325          break;
326        }
327      }
328      if (!match_found) {
329        dest_it.add_after_then_move(src_it.extract());
330      }
331    }
332  }
333  bool TableFinder::ConsecutiveBoxes(const TBOX &b1, const TBOX &b2) {
334    int x_margin = 20;
335    int y_margin = 5;
336    return (abs(b1.left() - b2.left()) < x_margin) &&
337           (abs(b1.right() - b2.right()) < x_margin) &&
338           (abs(b1.top() - b2.bottom()) < y_margin ||
339            abs(b2.top() - b1.bottom()) < y_margin);
340  }
341  void TableFinder::InitializePartitions(ColPartitionSet **all_columns) {
342    FindNeighbors();
343    SetPartitionSpacings(&clean_part_grid_, all_columns);
344    SetGlobalSpacings(&clean_part_grid_);
345  }
346  void TableFinder::SetPartitionSpacings(ColPartitionGrid *grid,
347                                         ColPartitionSet **all_columns) {
348    ColPartitionGridSearch gsearch(grid);
349    gsearch.StartFullSearch();
350    ColPartition *part = nullptr;
351    while ((part = gsearch.NextFullSearch()) != nullptr) {
352      ColPartitionSet *columns = all_columns[gsearch.GridY()];
353      TBOX box = part->bounding_box();
354      int y = part->MidY();
355      ColPartition *left_column = columns->ColumnContaining(box.left(), y);
356      ColPartition *right_column = columns->ColumnContaining(box.right(), y);
357      if (left_column) {
358        int left_space = std::max(0, box.left() - left_column->LeftAtY(y));
359        part->set_space_to_left(left_space);
360      }
361      if (right_column) {
362        int right_space = std::max(0, right_column->RightAtY(y) - box.right());
363        part->set_space_to_right(right_space);
364      }
365      ColPartitionGridSearch hsearch(grid);
366      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
367      ColPartition *neighbor = nullptr;
368      while ((neighbor = hsearch.NextSideSearch(true)) != nullptr) {
369        if (neighbor->type() == PT_PULLOUT_IMAGE ||
370            neighbor->type() == PT_FLOWING_IMAGE ||
371            neighbor->type() == PT_HEADING_IMAGE) {
372          int right = neighbor->bounding_box().right();
373          if (right < box.left()) {
374            int space = std::min(box.left() - right, part->space_to_left());
375            part->set_space_to_left(space);
376          }
377        }
378      }
379      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
380      neighbor = nullptr;
381      while ((neighbor = hsearch.NextSideSearch(false)) != nullptr) {
382        if (neighbor->type() == PT_PULLOUT_IMAGE ||
383            neighbor->type() == PT_FLOWING_IMAGE ||
384            neighbor->type() == PT_HEADING_IMAGE) {
385          int left = neighbor->bounding_box().left();
386          if (left > box.right()) {
387            int space = std::min(left - box.right(), part->space_to_right());
388            part->set_space_to_right(space);
389          }
390        }
391      }
392      ColPartition *upper_part = part->SingletonPartner(true);
393      if (upper_part) {
394        int space =
395            std::max(0, static_cast<int>(upper_part->bounding_box().bottom() -
396                                         part->bounding_box().bottom()));
397        part->set_space_above(space);
398      } else {
399        part->set_space_above(INT32_MAX);
400      }
401      ColPartition *lower_part = part->SingletonPartner(false);
402      if (lower_part) {
403        int space =
404            std::max(0, static_cast<int>(part->bounding_box().bottom() -
405                                         lower_part->bounding_box().bottom()));
406        part->set_space_below(space);
407      } else {
408        part->set_space_below(INT32_MAX);
409      }
410    }
411  }
412  void TableFinder::SetVerticalSpacing(ColPartition *part) {
413    TBOX box = part->bounding_box();
414    int top_range =
415        std::min(box.top() + kMaxVerticalSpacing, static_cast<int>(tright().y()));
416    int bottom_range = std::max(box.bottom() - kMaxVerticalSpacing,
417                                static_cast<int>(bleft().y()));
418    box.set_top(top_range);
419    box.set_bottom(bottom_range);
420    TBOX part_box = part->bounding_box();
421    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
422        &clean_part_grid_);
423    rectsearch.StartRectSearch(box);
424    ColPartition *neighbor;
425    int min_space_above = kMaxVerticalSpacing;
426    int min_space_below = kMaxVerticalSpacing;
427    ColPartition *above_neighbor = nullptr;
428    ColPartition *below_neighbor = nullptr;
429    while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
430      if (neighbor == part) {
431        continue;
432      }
433      TBOX neighbor_box = neighbor->bounding_box();
434      if (neighbor_box.major_x_overlap(part_box)) {
435        int gap = abs(part->median_bottom() - neighbor->median_bottom());
436        if (neighbor_box.top() < part_box.bottom() && gap < min_space_below) {
437          min_space_below = gap;
438          below_neighbor = neighbor;
439        } 
440        else if (part_box.top() < neighbor_box.bottom() &&
441                 gap < min_space_above) {
442          min_space_above = gap;
443          above_neighbor = neighbor;
444        }
445      }
446    }
447    part->set_space_above(min_space_above);
448    part->set_space_below(min_space_below);
449    part->set_nearest_neighbor_above(above_neighbor);
450    part->set_nearest_neighbor_below(below_neighbor);
451  }
452  void TableFinder::SetGlobalSpacings(ColPartitionGrid *grid) {
453    STATS xheight_stats(0, kMaxVerticalSpacing);
454    STATS width_stats(0, kMaxBlobWidth);
455    STATS ledding_stats(0, kMaxVerticalSpacing);
456    ColPartitionGridSearch gsearch(grid);
457    gsearch.SetUniqueMode(true);
458    gsearch.StartFullSearch();
459    ColPartition *part = nullptr;
460    while ((part = gsearch.NextFullSearch()) != nullptr) {
461      if (part->IsTextType()) {
462        BLOBNBOX_C_IT it(part->boxes());
463        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
464          xheight_stats.add(it.data()->bounding_box().height(), 1);
465          width_stats.add(it.data()->bounding_box().width(), 1);
466        }
467        ledding_stats.add(part->space_above(), 1);
468        ledding_stats.add(part->space_below(), 1);
469      }
470    }
471    set_global_median_xheight(static_cast<int>(xheight_stats.median() + 0.5));
472    set_global_median_blob_width(static_cast<int>(width_stats.median() + 0.5));
473    set_global_median_ledding(static_cast<int>(ledding_stats.median() + 0.5));
474  #ifndef GRAPHICS_DISABLED
475    if (textord_tablefind_show_stats) {
476      const char *kWindowName = "X-height (R), X-width (G), and ledding (B)";
477      ScrollView *stats_win = MakeWindow(500, 10, kWindowName);
478      xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
479      width_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
480      ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::BLUE);
481    }
482  #endif 
483  }
484  void TableFinder::set_global_median_xheight(int xheight) {
485    global_median_xheight_ = xheight;
486  }
487  void TableFinder::set_global_median_blob_width(int width) {
488    global_median_blob_width_ = width;
489  }
490  void TableFinder::set_global_median_ledding(int ledding) {
491    global_median_ledding_ = ledding;
492  }
493  void TableFinder::FindNeighbors() {
494    ColPartitionGridSearch gsearch(&clean_part_grid_);
495    gsearch.StartFullSearch();
496    ColPartition *part = nullptr;
497    while ((part = gsearch.NextFullSearch()) != nullptr) {
498      ColPartition *upper = part->SingletonPartner(true);
499      if (upper) {
500        part->set_nearest_neighbor_above(upper);
501      }
502      ColPartition *lower = part->SingletonPartner(false);
503      if (lower) {
504        part->set_nearest_neighbor_below(lower);
505      }
506    }
507  }
508  void TableFinder::MarkTablePartitions() {
509    MarkPartitionsUsingLocalInformation();
510  #ifndef GRAPHICS_DISABLED
511    if (textord_tablefind_show_mark) {
512      ScrollView *table_win = MakeWindow(300, 300, "Initial Table Partitions");
513      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
514      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
515                           ScrollView::AQUAMARINE);
516    }
517  #endif
518    FilterFalseAlarms();
519  #ifndef GRAPHICS_DISABLED
520    if (textord_tablefind_show_mark) {
521      ScrollView *table_win = MakeWindow(600, 300, "Filtered Table Partitions");
522      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
523      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
524                           ScrollView::AQUAMARINE);
525    }
526  #endif
527    SmoothTablePartitionRuns();
528  #ifndef GRAPHICS_DISABLED
529    if (textord_tablefind_show_mark) {
530      ScrollView *table_win = MakeWindow(900, 300, "Smoothed Table Partitions");
531      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
532      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
533                           ScrollView::AQUAMARINE);
534    }
535  #endif
536    FilterFalseAlarms();
537  #ifndef GRAPHICS_DISABLED
538    if (textord_tablefind_show_mark || textord_show_tables) {
539      ScrollView *table_win = MakeWindow(900, 300, "Final Table Partitions");
540      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
541      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
542                           ScrollView::AQUAMARINE);
543    }
544  #endif
545  }
546  void TableFinder::MarkPartitionsUsingLocalInformation() {
547    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
548        &clean_part_grid_);
549    gsearch.StartFullSearch();
550    ColPartition *part = nullptr;
551    while ((part = gsearch.NextFullSearch()) != nullptr) {
552      if (!part->IsTextType()) { 
553        continue;
554      }
555      if (part->median_height() > kMaxTableCellXheight * global_median_xheight_) {
556        continue;
557      }
558      if (HasWideOrNoInterWordGap(part) || HasLeaderAdjacent(*part)) {
559        part->set_table_type();
560      }
561    }
562  }
563  bool TableFinder::HasWideOrNoInterWordGap(ColPartition *part) const {
564    ASSERT_HOST(part->IsTextType());
565    BLOBNBOX_CLIST *part_boxes = part->boxes();
566    BLOBNBOX_C_IT it(part_boxes);
567    if (part->bounding_box().width() <
568            kMinBoxesInTextPartition * part->median_height() &&
569        part_boxes->length() < kMinBoxesInTextPartition) {
570      return true;
571    }
572    int current_x0 = -1;
573    int current_x1 = -1;
574    int previous_x1 = -1;
575    int largest_partition_gap_found = -1;
576    const double max_gap = kMaxGapInTextPartition * part->median_height();
577    const double min_gap = kMinMaxGapInTextPartition * part->median_height();
578    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
579      BLOBNBOX *blob = it.data();
580      current_x0 = blob->bounding_box().left();
581      current_x1 = blob->bounding_box().right();
582      if (previous_x1 != -1) {
583        int gap = current_x0 - previous_x1;
584        if (gap < 0) {
585          if (-gap < part->median_height() * kMaxBlobOverlapFactor) {
586            previous_x1 = std::max(previous_x1, current_x1);
587            continue;
588          }
589          else {
590          }
591        }
592        if (gap > max_gap) {
593          return true;
594        }
595        if (gap > largest_partition_gap_found) {
596          largest_partition_gap_found = gap;
597        }
598      }
599      previous_x1 = current_x1;
600    }
601    if (part->bounding_box().width() >
602            kMaxBoxesInDataPartition * part->median_height() ||
603        part_boxes->length() > kMaxBoxesInDataPartition) {
604      return false;
605    }
606    if (largest_partition_gap_found == -1) {
607      return true;
608    }
609    return largest_partition_gap_found < min_gap;
610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &box = part.bounding_box();
616    const int search_size = kAdjacentLeaderSearchPadding * global_median_xheight_;
617    const int top = box.top() + search_size;
618    const int bottom = box.bottom() - search_size;
619    ColPartitionGridSearch hsearch(&leader_and_ruling_grid_);
620    for (int direction = 0; direction < 2; ++direction) {
621      bool right_to_left = (direction == 0);
622      int x = right_to_left ? box.right() : box.left();
623      hsearch.StartSideSearch(x, bottom, top);
624      ColPartition *leader = nullptr;
625      while ((leader = hsearch.NextSideSearch(right_to_left)) != nullptr) {
626        if (leader->flow() != BTFT_LEADER) {
627          continue;
628        }
629        ASSERT_HOST(&part != leader);
630        if (!part.IsInSameColumnAs(*leader)) {
631          break;
632        }
633        if (!leader->VSignificantCoreOverlap(part)) {
634          continue;
635        }
636        return true;
637      }
638    }
639    return false;
640  }
641  void TableFinder::FilterFalseAlarms() {
642    FilterParagraphEndings();
643    FilterHeaderAndFooter();
644  }
645  void TableFinder::FilterParagraphEndings() {
646    ColPartitionGridSearch gsearch(&clean_part_grid_);
647    gsearch.StartFullSearch();
648    ColPartition *part = nullptr;
649    while ((part = gsearch.NextFullSearch()) != nullptr) {
650      if (part->type() != PT_TABLE) {
651        continue; 
652      }
653      ColPartition *upper_part = part->nearest_neighbor_above();
654      if (!upper_part) {
655        continue;
656      }
657      if (upper_part->type() != PT_FLOWING_TEXT) {
658        continue;
659      }
660      if (upper_part->bounding_box().width() < 2 * part->bounding_box().width()) {
661        continue;
662      }
663      int mid = (part->bounding_box().left() + part->bounding_box().right()) / 2;
664      int upper_mid = (upper_part->bounding_box().left() +
665                       upper_part->bounding_box().right()) /
666                      2;
667      int current_spacing = 0; 
668      int upper_spacing = 0;   
669      if (left_to_right_language_) {
670        int left = std::min(part->bounding_box().left(),
671                            upper_part->bounding_box().left());
672        current_spacing = mid - left;
673        upper_spacing = upper_mid - left;
674      } else {
675        int right = std::max(part->bounding_box().right(),
676                             upper_part->bounding_box().right());
677        current_spacing = right - mid;
678        upper_spacing = right - upper_mid;
679      }
680      if (current_spacing * kParagraphEndingPreviousLineRatio > upper_spacing) {
681        continue;
682      }
683      if (!part->MatchingSizes(*upper_part) ||
684          !part->MatchingStrokeWidth(*upper_part, kStrokeWidthFractionalTolerance,
685                                     kStrokeWidthConstantTolerance)) {
686        continue;
687      }
688      if (part->space_to_left() >
689          kMaxParagraphEndingLeftSpaceMultiple * part->median_height()) {
690        continue;
691      }
692      if (upper_part->bounding_box().width() <
693          kMinParagraphEndingTextToWhitespaceRatio *
694              upper_part->space_to_right()) {
695        continue;
696      }
697      if (part->space_above() >= part->space_below() ||
698          part->space_above() > 2 * global_median_ledding_) {
699        continue;
700      }
701      part->clear_table_type();
702    }
703  }
704  void TableFinder::FilterHeaderAndFooter() {
705    ColPartition *header = nullptr;
706    ColPartition *footer = nullptr;
707    int max_top = INT32_MIN;
708    int min_bottom = INT32_MAX;
709    ColPartitionGridSearch gsearch(&clean_part_grid_);
710    gsearch.StartFullSearch();
711    ColPartition *part = nullptr;
712    while ((part = gsearch.NextFullSearch()) != nullptr) {
713      if (!part->IsTextType()) {
714        continue; 
715      }
716      int top = part->bounding_box().top();
717      int bottom = part->bounding_box().bottom();
718      if (top > max_top) {
719        max_top = top;
720        header = part;
721      }
722      if (bottom < min_bottom) {
723        min_bottom = bottom;
724        footer = part;
725      }
726    }
727    if (header) {
728      header->clear_table_type();
729    }
730    if (footer) {
731      footer->clear_table_type();
732    }
733  }
734  void TableFinder::SmoothTablePartitionRuns() {
735    ColPartitionGridSearch gsearch(&clean_part_grid_);
736    gsearch.StartFullSearch();
737    ColPartition *part = nullptr;
738    while ((part = gsearch.NextFullSearch()) != nullptr) {
739      if (part->type() >= PT_TABLE || part->type() == PT_UNKNOWN) {
740        continue; 
741      }
742      ColPartition *upper_part = part->nearest_neighbor_above();
743      ColPartition *lower_part = part->nearest_neighbor_below();
744      if (!upper_part || !lower_part) {
745        continue;
746      }
747      if (upper_part->type() == PT_TABLE && lower_part->type() == PT_TABLE) {
748        part->set_table_type();
749      }
750    }
751    gsearch.StartFullSearch();
752    part = nullptr;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      if (part->type() != PT_TABLE) {
755        continue; 
756      }
757      ColPartition *upper_part = part->nearest_neighbor_above();
758      ColPartition *lower_part = part->nearest_neighbor_below();
759      if ((upper_part && upper_part->type() != PT_TABLE) &&
760          (lower_part && lower_part->type() != PT_TABLE)) {
761        part->clear_table_type();
762      }
763    }
764  }
765  void TableFinder::SetColumnsType(ColSegment_LIST *column_blocks) {
766    ColSegment_IT it(column_blocks);
767    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
768      ColSegment *seg = it.data();
769      TBOX box = seg->bounding_box();
770      int num_table_cells = 0;
771      int num_text_cells = 0;
772      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rsearch(
773          &clean_part_grid_);
774      rsearch.SetUniqueMode(true);
775      rsearch.StartRectSearch(box);
776      ColPartition *part = nullptr;
777      while ((part = rsearch.NextRectSearch()) != nullptr) {
778        if (part->type() == PT_TABLE) {
779          num_table_cells++;
780        } else if (part->type() == PT_FLOWING_TEXT) {
781          num_text_cells++;
782        }
783      }
784      if (!num_table_cells && !num_text_cells) {
785        delete it.extract();
786      } else {
787        seg->set_num_table_cells(num_table_cells);
788        seg->set_num_text_cells(num_text_cells);
789        seg->set_type();
790      }
791    }
792  }
793  void TableFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
794                                          ColSegmentGrid *col_seg_grid) {
795    ColSegment_IT it(segments);
796    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
797      ColSegment *seg = it.extract();
798      col_seg_grid->InsertBBox(true, true, seg);
799    }
800  }
801  void TableFinder::GridMergeColumnBlocks() {
802    int margin = gridsize();
803    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
804        &col_seg_grid_);
805    gsearch.StartFullSearch();
806    ColSegment *seg;
807    while ((seg = gsearch.NextFullSearch()) != nullptr) {
808      if (seg->type() != COL_TEXT) {
809        continue; 
810      }
811      bool neighbor_found = false;
812      bool modified = false; 
813      do {
814        TBOX box = seg->bounding_box();
815        int top_range =
816            std::min(box.top() + margin, static_cast<int>(tright().y()));
817        int bottom_range =
818            std::max(box.bottom() - margin, static_cast<int>(bleft().y()));
819        box.set_top(top_range);
820        box.set_bottom(bottom_range);
821        neighbor_found = false;
822        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
823            &col_seg_grid_);
824        rectsearch.StartRectSearch(box);
825        ColSegment *neighbor = nullptr;
826        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
827          if (neighbor == seg) {
828            continue;
829          }
830          const TBOX &neighbor_box = neighbor->bounding_box();
831          if (neighbor_box.overlap_fraction(box) >= 0.9) {
832            seg->InsertBox(neighbor_box);
833            modified = true;
834            rectsearch.RemoveBBox();
835            gsearch.RepositionIterator();
836            delete neighbor;
837            continue;
838          }
839          if (neighbor->type() != COL_TABLE) {
840            continue;
841          }
842          if (neighbor_box.major_x_overlap(box) && !box.contains(neighbor_box)) {
843            seg->InsertBox(neighbor_box);
844            neighbor_found = true;
845            modified = true;
846            rectsearch.RemoveBBox();
847            gsearch.RepositionIterator();
848            delete neighbor;
849          }
850        }
851      } while (neighbor_found);
852      if (modified) {
853        gsearch.RemoveBBox();
854        col_seg_grid_.InsertBBox(true, true, seg);
855        gsearch.RepositionIterator();
856      }
857    }
858  }
859  void TableFinder::GetTableColumns(ColSegment_LIST *table_columns) {
860    ColSegment_IT it(table_columns);
861    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
862        &clean_part_grid_);
863    gsearch.StartFullSearch();
864    ColPartition *part;
865    while ((part = gsearch.NextFullSearch()) != nullptr) {
866      if (part->inside_table_column() || part->type() != PT_TABLE) {
867        continue; 
868      }
869      const TBOX &box = part->bounding_box();
870      auto *col = new ColSegment();
871      col->InsertBox(box);
872      part->set_inside_table_column(true);
873      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> vsearch(
874          &clean_part_grid_);
875      vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
876      ColPartition *neighbor = nullptr;
877      bool found_neighbours = false;
878      while ((neighbor = vsearch.NextVerticalSearch(true)) != nullptr) {
879        if (neighbor->inside_table_column()) {
880          continue;
881        }
882        if (neighbor->IsHorizontalLine()) {
883          continue;
884        }
885        if (neighbor->type() != PT_TABLE) {
886          break;
887        }
888        const TBOX &neighbor_box = neighbor->bounding_box();
889        col->InsertBox(neighbor_box);
890        neighbor->set_inside_table_column(true);
891        found_neighbours = true;
892      }
893      if (found_neighbours) {
894        it.add_after_then_move(col);
895      } else {
896        part->set_inside_table_column(false);
897        delete col;
898      }
899    }
900  }
901  void TableFinder::GetTableRegions(ColSegment_LIST *table_columns,
902                                    ColSegment_LIST *table_regions) {
903    ColSegment_IT cit(table_columns);
904    ColSegment_IT rit(table_regions);
905    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
906        &col_seg_grid_);
907    gsearch.StartFullSearch();
908    ColSegment *part;
909    int page_height = tright().y() - bleft().y();
910    ASSERT_HOST(page_height > 0);
911    bool *table_region = new bool[page_height];
<span onclick='openModal()' class='match'>912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &part_box = part->bounding_box();
914      for (int i = 0; i < page_height; i++) {
915        table_region[i] = false;
</span>916      }
917      cit.move_to_first();
918      for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
919        TBOX col_box = cit.data()->bounding_box();
920        TBOX intersection_box = col_box.intersection(part_box);
921        for (int i = intersection_box.bottom(); i < intersection_box.top(); i++) {
922          table_region[i - bleft().y()] = true;
923        }
924      }
925      TBOX current_table_box;
926      current_table_box.set_left(part_box.left());
927      current_table_box.set_right(part_box.right());
928      for (int i = 1; i < page_height; i++) {
929        if (!table_region[i - 1] && table_region[i]) {
930          current_table_box.set_bottom(i + bleft().y());
931        }
932        if (table_region[i - 1] && !table_region[i]) {
933          current_table_box.set_top(i + bleft().y());
934          if (!current_table_box.null_box()) {
935            auto *seg = new ColSegment();
936            seg->InsertBox(current_table_box);
937            rit.add_after_then_move(seg);
938          }
939        }
940      }
941    }
942    delete[] table_region;
943  }
944  void TableFinder::GridMergeTableRegions() {
945    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
946        &table_grid_);
947    gsearch.StartFullSearch();
948    ColSegment *seg = nullptr;
949    while ((seg = gsearch.NextFullSearch()) != nullptr) {
950      bool neighbor_found = false;
951      bool modified = false; 
952      do {
953        const TBOX &box = seg->bounding_box();
954        TBOX search_region(box);
955        search_region.set_left(bleft().x());
956        search_region.set_right(tright().x());
957        neighbor_found = false;
958        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
959            &table_grid_);
960        rectsearch.StartRectSearch(search_region);
961        ColSegment *neighbor = nullptr;
962        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
963          if (neighbor == seg) {
964            continue;
965          }
966          const TBOX &neighbor_box = neighbor->bounding_box();
967          if (neighbor_box.overlap_fraction(box) >= 0.9) {
968            seg->InsertBox(neighbor_box);
969            rectsearch.RemoveBBox();
970            gsearch.RepositionIterator();
971            delete neighbor;
972            modified = true;
973            continue;
974          }
975          if (BelongToOneTable(box, neighbor_box)) {
976            seg->InsertBox(neighbor_box);
977            neighbor_found = true;
978            modified = true;
979            rectsearch.RemoveBBox();
980            gsearch.RepositionIterator();
981            delete neighbor;
982          }
983        }
984      } while (neighbor_found);
985      if (modified) {
986        gsearch.RemoveBBox();
987        table_grid_.InsertBBox(true, true, seg);
988        gsearch.RepositionIterator();
989      }
990    }
991  }
992  bool TableFinder::BelongToOneTable(const TBOX &box1, const TBOX &box2) {
993    if (box1.overlap(box2)) {
994      return true;
995    }
996    TBOX bbox = box1.bounding_union(box2);
997    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
998        &clean_part_grid_);
999    rectsearch.StartRectSearch(bbox);
1000    ColPartition *part = nullptr;
1001    while ((part = rectsearch.NextRectSearch()) != nullptr) {
1002      const TBOX &part_box = part->bounding_box();
1003      if (part_box.overlap(box1) && part_box.overlap(box2) &&
1004          !part->IsImageType()) {
1005        return true;
1006      }
1007    }
1008    return false;
1009  }
1010  void TableFinder::AdjustTableBoundaries() {
1011    ColSegment_CLIST adjusted_tables;
1012    ColSegment_C_IT it(&adjusted_tables);
1013    ColSegmentGridSearch gsearch(&table_grid_);
1014    gsearch.StartFullSearch();
1015    ColSegment *table = nullptr;
1016    while ((table = gsearch.NextFullSearch()) != nullptr) {
1017      const TBOX &table_box = table->bounding_box();
1018      TBOX grown_box = table_box;
1019      GrowTableBox(table_box, &grown_box);
1020      if (!grown_box.null_box()) {
1021        auto *col = new ColSegment();
1022        col->InsertBox(grown_box);
1023        it.add_after_then_move(col);
1024      }
1025      gsearch.RemoveBBox();
1026      delete table;
1027    }
1028    table_grid_.Clear();
1029    it.move_to_first();
1030    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1031      ColSegment *seg = it.extract();
1032      table_grid_.InsertBBox(true, true, seg);
1033    }
1034  }
1035  void TableFinder::GrowTableBox(const TBOX &table_box, TBOX *result_box) {
1036    TBOX search_box = table_box;
1037    GrowTableToIncludePartials(table_box, search_box, result_box);
1038    GrowTableToIncludeLines(table_box, search_box, result_box);
1039    IncludeLeftOutColumnHeaders(result_box);
1040  }
1041  void TableFinder::GrowTableToIncludePartials(const TBOX &table_box,
1042                                               const TBOX &search_range,
1043                                               TBOX *result_box) {
1044    for (int i = 0; i < 2; ++i) {
1045      ColPartitionGrid *grid =
1046          (i == 0) ? &fragmented_text_grid_ : &leader_and_ruling_grid_;
1047      ColPartitionGridSearch rectsearch(grid);
1048      rectsearch.StartRectSearch(search_range);
1049      ColPartition *part = nullptr;
1050      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1051        if (part->IsImageType()) {
1052          continue;
1053        }
1054        const TBOX &part_box = part->bounding_box();
1055        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1056          *result_box = result_box->bounding_union(part_box);
1057          continue;
1058        }
1059      }
1060    }
1061  }
1062  void TableFinder::GrowTableToIncludeLines(const TBOX &table_box,
1063                                            const TBOX &search_range,
1064                                            TBOX *result_box) {
1065    ColPartitionGridSearch rsearch(&leader_and_ruling_grid_);
1066    rsearch.SetUniqueMode(true);
1067    rsearch.StartRectSearch(search_range);
1068    ColPartition *part = nullptr;
1069    while ((part = rsearch.NextRectSearch()) != nullptr) {
1070      if (!part->IsLineType()) {
1071        continue;
1072      }
1073      const TBOX &part_box = part->bounding_box();
1074      if (result_box->contains(part_box)) {
1075        continue;
1076      }
1077      if (HLineBelongsToTable(*part, table_box)) {
1078        *result_box = result_box->bounding_union(part_box);
1079      }
1080    }
1081  }
1082  bool TableFinder::HLineBelongsToTable(const ColPartition &part,
1083                                        const TBOX &table_box) {
1084    if (!part.IsHorizontalLine()) {
1085      return false;
1086    }
1087    const TBOX &part_box = part.bounding_box();
1088    if (!part_box.major_x_overlap(table_box)) {
1089      return false;
1090    }
1091    const TBOX bbox = part_box.bounding_union(table_box);
1092    int num_extra_partitions = 0;
1093    int extra_space_to_right = 0;
1094    int extra_space_to_left = 0;
1095    for (int i = 0; i < 2; ++i) {
1096      ColPartitionGrid *grid =
1097          (i == 0) ? &clean_part_grid_ : &leader_and_ruling_grid_;
1098      ColPartitionGridSearch rectsearch(grid);
1099      rectsearch.SetUniqueMode(true);
1100      rectsearch.StartRectSearch(bbox);
1101      ColPartition *extra_part = nullptr;
1102      while ((extra_part = rectsearch.NextRectSearch()) != nullptr) {
1103        const TBOX &extra_part_box = extra_part->bounding_box();
1104        if (extra_part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1105          continue;
1106        }
1107        if (extra_part->IsImageType()) {
1108          continue;
1109        }
1110        num_extra_partitions++;
1111        if (extra_part->type() == PT_TABLE || extra_part->IsLineType()) {
1112          extra_space_to_right++;
1113          extra_space_to_left++;
1114          continue;
1115        }
1116        int space_threshold = kSideSpaceMargin * part.median_height();
1117        if (extra_part->space_to_right() > space_threshold) {
1118          extra_space_to_right++;
1119        }
1120        if (extra_part->space_to_left() > space_threshold) {
1121          extra_space_to_left++;
1122        }
1123      }
1124    }
1125    return (extra_space_to_right > num_extra_partitions / 2) ||
1126           (extra_space_to_left > num_extra_partitions / 2);
1127  }
1128  void TableFinder::IncludeLeftOutColumnHeaders(TBOX *table_box) {
1129    ColPartitionGridSearch vsearch(&clean_part_grid_);
1130    vsearch.StartVerticalSearch(table_box->left(), table_box->right(),
1131                                table_box->top());
1132    ColPartition *neighbor = nullptr;
1133    ColPartition *previous_neighbor = nullptr;
1134    while ((neighbor = vsearch.NextVerticalSearch(false)) != nullptr) {
1135      const int max_distance =
1136          kMaxColumnHeaderDistance * neighbor->median_height();
1137      int table_top = table_box->top();
1138      const TBOX &box = neighbor->bounding_box();
1139      if (box.bottom() - table_top > max_distance) {
1140        break;
1141      }
1142      if (neighbor->type() == PT_TABLE || neighbor->IsLineType()) {
1143        table_box->set_top(box.top());
1144        previous_neighbor = nullptr;
1145        continue;
1146      }
1147      if (previous_neighbor == nullptr) {
1148        previous_neighbor = neighbor;
1149      } else {
1150        const TBOX &previous_box = previous_neighbor->bounding_box();
1151        if (!box.major_y_overlap(previous_box)) {
1152          break;
1153        }
1154      }
1155    }
1156  }
1157  void TableFinder::DeleteSingleColumnTables() {
1158    int page_width = tright().x() - bleft().x();
1159    ASSERT_HOST(page_width > 0);
1160    int *table_xprojection = new int[page_width];
1161    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1162        &table_grid_);
1163    table_search.StartFullSearch();
1164    ColSegment *table;
1165    while ((table = table_search.NextFullSearch()) != nullptr) {
1166      TBOX table_box = table->bounding_box();
1167      for (int i = 0; i < page_width; i++) {
1168        table_xprojection[i] = 0;
1169      }
1170      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1171          &clean_part_grid_);
1172      rectsearch.SetUniqueMode(true);
1173      rectsearch.StartRectSearch(table_box);
1174      ColPartition *part;
1175      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1176        if (!part->IsTextType()) {
1177          continue; 
1178        }
1179        if (part->flow() == BTFT_LEADER) {
1180          continue; 
1181        }
1182        TBOX part_box = part->bounding_box();
1183        if (part_box.overlap_fraction(table_box) < kMinOverlapWithTable) {
1184          continue;
1185        }
1186        BLOBNBOX_CLIST *part_boxes = part->boxes();
1187        BLOBNBOX_C_IT pit(part_boxes);
1188        int next_position_to_write = 0;
1189        for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
1190          BLOBNBOX *pblob = pit.data();
1191          int xstart = pblob->bounding_box().left();
1192          int xend = pblob->bounding_box().right();
1193          xstart = std::max(xstart, next_position_to_write);
1194          for (int i = xstart; i < xend; i++) {
1195            table_xprojection[i - bleft().x()]++;
1196          }
1197          next_position_to_write = xend;
1198        }
1199      }
1200      if (!GapInXProjection(table_xprojection, page_width)) {
1201        table_search.RemoveBBox();
1202        delete table;
1203      }
1204    }
1205    delete[] table_xprojection;
1206  }
1207  bool TableFinder::GapInXProjection(int *xprojection, int length) {
1208    int peak_value = 0;
1209    for (int i = 0; i < length; i++) {
1210      if (xprojection[i] > peak_value) {
1211        peak_value = xprojection[i];
1212      }
1213    }
1214    if (peak_value < kMinRowsInTable) {
1215      return false;
1216    }
1217    double projection_threshold = kSmallTableProjectionThreshold * peak_value;
1218    if (peak_value >= kLargeTableRowCount) {
1219      projection_threshold = kLargeTableProjectionThreshold * peak_value;
1220    }
1221    for (int i = 0; i < length; i++) {
1222      xprojection[i] = (xprojection[i] >= projection_threshold) ? 1 : 0;
1223    }
1224    int largest_gap = 0;
1225    int run_start = -1;
1226    for (int i = 1; i < length; i++) {
1227      if (xprojection[i - 1] && !xprojection[i]) {
1228        run_start = i;
1229      }
1230      if (run_start != -1 && !xprojection[i - 1] && xprojection[i]) {
1231        int gap = i - run_start;
1232        if (gap > largest_gap) {
1233          largest_gap = gap;
1234        }
1235        run_start = -1;
1236      }
1237    }
1238    return largest_gap > kMaxXProjectionGapFactor * global_median_xheight_;
1239  }
1240  void TableFinder::RecognizeTables() {
1241  #ifndef GRAPHICS_DISABLED
1242    ScrollView *table_win = nullptr;
1243    if (textord_show_tables) {
1244      table_win = MakeWindow(0, 0, "Table Structure");
1245      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE,
1246                           ScrollView::LIGHT_BLUE);
1247    }
1248  #endif
1249    TableRecognizer recognizer;
1250    recognizer.Init();
1251    recognizer.set_line_grid(&leader_and_ruling_grid_);
1252    recognizer.set_text_grid(&fragmented_text_grid_);
1253    recognizer.set_max_text_height(global_median_xheight_ * 2.0);
1254    recognizer.set_min_height(1.5 * gridheight());
1255    ColSegment_CLIST good_tables;
1256    ColSegment_C_IT good_it(&good_tables);
1257    ColSegmentGridSearch gsearch(&table_grid_);
1258    gsearch.StartFullSearch();
1259    ColSegment *found_table = nullptr;
1260    while ((found_table = gsearch.NextFullSearch()) != nullptr) {
1261      gsearch.RemoveBBox();
1262      const TBOX &found_box = found_table->bounding_box();
1263      StructuredTable *table_structure = recognizer.RecognizeTable(found_box);
1264      if (table_structure != nullptr) {
1265  #ifndef GRAPHICS_DISABLED
1266        if (textord_show_tables) {
1267          table_structure->Display(table_win, ScrollView::LIME_GREEN);
1268        }
1269  #endif
1270        found_table->set_bounding_box(table_structure->bounding_box());
1271        delete table_structure;
1272        good_it.add_after_then_move(found_table);
1273      } else {
1274        delete found_table;
1275      }
1276    }
1277    for (good_it.mark_cycle_pt(); !good_it.cycled_list(); good_it.forward()) {
1278      table_grid_.InsertBBox(true, true, good_it.extract());
1279    }
1280  }
1281  #ifndef GRAPHICS_DISABLED
1282  void TableFinder::DisplayColSegments(ScrollView *win, ColSegment_LIST *segments,
1283                                       ScrollView::Color color) {
1284    win->Pen(color);
1285    win->Brush(ScrollView::NONE);
1286    ColSegment_IT it(segments);
1287    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1288      ColSegment *col = it.data();
1289      const TBOX &box = col->bounding_box();
1290      int left_x = box.left();
1291      int right_x = box.right();
1292      int top_y = box.top();
1293      int bottom_y = box.bottom();
1294      win->Rectangle(left_x, bottom_y, right_x, top_y);
1295    }
1296    win->UpdateWindow();
1297  }
1298  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1299                                         ScrollView::Color default_color,
1300                                         ScrollView::Color table_color) {
1301    ScrollView::Color color = default_color;
1302    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1303    gsearch.StartFullSearch();
1304    ColPartition *part = nullptr;
1305    while ((part = gsearch.NextFullSearch()) != nullptr) {
1306      color = default_color;
1307      if (part->type() == PT_TABLE) {
1308        color = table_color;
1309      }
1310      const TBOX &box = part->bounding_box();
1311      int left_x = box.left();
1312      int right_x = box.right();
1313      int top_y = box.top();
1314      int bottom_y = box.bottom();
1315      win->Brush(ScrollView::NONE);
1316      win->Pen(color);
1317      win->Rectangle(left_x, bottom_y, right_x, top_y);
1318    }
1319    win->UpdateWindow();
1320  }
1321  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1322                                         ScrollView::Color default_color) {
1323    DisplayColPartitions(win, grid, default_color, ScrollView::YELLOW);
1324  }
1325  void TableFinder::DisplayColPartitionConnections(ScrollView *win,
1326                                                   ColPartitionGrid *grid,
1327                                                   ScrollView::Color color) {
1328    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1329    gsearch.StartFullSearch();
1330    ColPartition *part = nullptr;
1331    while ((part = gsearch.NextFullSearch()) != nullptr) {
1332      const TBOX &box = part->bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part->nearest_neighbor_above();
1338      if (upper_part) {
1339        const TBOX &upper_box = upper_part->bounding_box();
1340        int mid_x = (left_x + right_x) / 2;
1341        int mid_y = (top_y + bottom_y) / 2;
1342        int other_x = (upper_box.left() + upper_box.right()) / 2;
1343        int other_y = (upper_box.top() + upper_box.bottom()) / 2;
1344        win->Brush(ScrollView::NONE);
1345        win->Pen(color);
1346        win->Line(mid_x, mid_y, other_x, other_y);
1347      }
1348      ColPartition *lower_part = part->nearest_neighbor_below();
1349      if (lower_part) {
1350        const TBOX &lower_box = lower_part->bounding_box();
1351        int mid_x = (left_x + right_x) / 2;
1352        int mid_y = (top_y + bottom_y) / 2;
1353        int other_x = (lower_box.left() + lower_box.right()) / 2;
1354        int other_y = (lower_box.top() + lower_box.bottom()) / 2;
1355        win->Brush(ScrollView::NONE);
1356        win->Pen(color);
1357        win->Line(mid_x, mid_y, other_x, other_y);
1358      }
1359    }
1360    win->UpdateWindow();
1361  }
1362  #endif
1363  void TableFinder::MakeTableBlocks(ColPartitionGrid *grid,
1364                                    ColPartitionSet **all_columns,
1365                                    const WidthCallback &width_cb) {
1366    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1367    gsearch.StartFullSearch();
1368    ColPartition *part = nullptr;
1369    while ((part = gsearch.NextFullSearch()) != nullptr) {
1370      if (part->type() == PT_TABLE) {
1371        part->clear_table_type();
1372      }
1373    }
1374    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1375        &table_grid_);
1376    table_search.StartFullSearch();
1377    ColSegment *table;
1378    while ((table = table_search.NextFullSearch()) != nullptr) {
1379      const TBOX &table_box = table->bounding_box();
1380      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1381          grid);
1382      rectsearch.StartRectSearch(table_box);
1383      ColPartition *part;
1384      ColPartition *table_partition = nullptr;
1385      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1386        if (!part->IsTextType()) {
1387          continue;
1388        }
1389        TBOX part_box = part->bounding_box();
1390        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1391          rectsearch.RemoveBBox();
1392          if (table_partition) {
1393            table_partition->Absorb(part, width_cb);
1394          } else {
1395            table_partition = part;
1396          }
1397        }
1398      }
1399      if (table_partition) {
1400        const TBOX &table_box = table_partition->bounding_box();
1401        int grid_x, grid_y;
1402        grid->GridCoords(table_box.left(), table_box.bottom(), &grid_x, &grid_y);
1403        table_partition->SetPartitionType(resolution_, all_columns[grid_y]);
1404        table_partition->set_table_type();
1405        table_partition->set_blob_type(BRT_TEXT);
1406        table_partition->set_flow(BTFT_CHAIN);
1407        table_partition->SetBlobTypes();
1408        grid->InsertBBox(true, true, table_partition);
1409      }
1410    }
1411  }
1412  ColSegment::ColSegment()
1413      : ELIST_LINK(),
1414        num_table_cells_(0),
1415        num_text_cells_(0),
1416        type_(COL_UNKNOWN) {}
1417  ScrollView::Color ColSegment::BoxColor() const {
1418    const ScrollView::Color kBoxColors[PT_COUNT] = {
1419        ScrollView::YELLOW,
1420        ScrollView::BLUE,
1421        ScrollView::YELLOW,
1422        ScrollView::MAGENTA,
1423    };
1424    return kBoxColors[type_];
1425  }
1426  void ColSegment::InsertBox(const TBOX &other) {
1427    bounding_box_ = bounding_box_.bounding_union(other);
1428  }
1429  void ColSegment::set_type() {
1430    if (num_table_cells_ > kTableColumnThreshold * num_text_cells_) {
1431      type_ = COL_TABLE;
1432    } else if (num_text_cells_ > num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
1437  }
1438  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/node/election.hpp>
4  #include <nano/node/scheduler/buckets.hpp>
5  #include <nano/node/scheduler/component.hpp>
6  #include <nano/node/transport/inproc.hpp>
7  #include <nano/node/unchecked_map.hpp>
8  #include <nano/test_common/network.hpp>
9  #include <nano/test_common/system.hpp>
10  #include <nano/test_common/testutil.hpp>
11  #include <gtest/gtest.h>
12  #include <boost/format.hpp>
13  #include <boost/unordered_set.hpp>
14  #include <numeric>
15  #include <random>
16  using namespace std::chrono_literals;
17  size_t manually_count_pruned_blocks (nano::store & store)
18  {
19  	size_t count = 0;
20  	auto transaction = store.tx_begin_read ();
21  	auto i = store.pruned.begin (transaction);
22  	for (; i != store.pruned.end (); ++i)
23  	{
24  		++count;
25  	}
26  	return count;
27  }
28  TEST (system, generate_mass_activity)
29  {
30  	nano::test::system system;
31  	nano::node_config node_config = system.default_config ();
32  	node_config.enable_voting = false; 
33  	auto node = system.add_node (node_config);
34  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
35  	uint32_t count (20);
36  	system.generate_mass_activity (count, *system.nodes[0]);
37  	auto transaction (system.nodes[0]->store.tx_begin_read ());
38  	for (auto i (system.nodes[0]->store.account.begin (transaction)), n (system.nodes[0]->store.account.end ()); i != n; ++i)
39  	{
40  	}
41  }
42  TEST (system, generate_mass_activity_long)
43  {
44  	nano::test::system system;
45  	nano::node_config node_config = system.default_config ();
46  	node_config.enable_voting = false; 
47  	auto node = system.add_node (node_config);
48  	nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
49  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
50  	uint32_t count (1000000);
51  	auto count_env_var = std::getenv ("SLOW_TEST_SYSTEM_GENERATE_MASS_ACTIVITY_LONG_COUNT");
52  	if (count_env_var)
53  	{
54  		count = boost::lexical_cast<uint32_t> (count_env_var);
55  		std::cout << "count override due to env variable set, count=" << count << std::endl;
56  	}
57  	system.generate_mass_activity (count, *system.nodes[0]);
58  	auto transaction (system.nodes[0]->store.tx_begin_read ());
59  	for (auto i (system.nodes[0]->store.account.begin (transaction)), n (system.nodes[0]->store.account.end ()); i != n; ++i)
60  	{
61  	}
62  	system.stop ();
63  	runner.join ();
64  }
65  TEST (system, receive_while_synchronizing)
66  {
67  	std::vector<boost::thread> threads;
68  	{
69  		nano::test::system system;
70  		nano::node_config node_config = system.default_config ();
71  		node_config.enable_voting = false; 
72  		auto node = system.add_node (node_config);
73  		nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
74  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
75  		uint32_t count (1000);
76  		system.generate_mass_activity (count, *system.nodes[0]);
77  		nano::keypair key;
78  		auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
79  		ASSERT_FALSE (node1->init_error ());
80  		auto wallet (node1->wallets.create (1));
81  		wallet->insert_adhoc (nano::dev::genesis_key.prv); 
82  		ASSERT_EQ (key.pub, wallet->insert_adhoc (key.prv));
83  		node1->start ();
84  		system.nodes.push_back (node1);
85  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node->network.endpoint ()));
86  		node1->workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::milliseconds (200), ([&system, &key] () {
87  			auto hash (system.wallet (0)->send_sync (nano::dev::genesis_key.pub, key.pub, system.nodes[0]->config.receive_minimum.number ()));
88  			auto transaction (system.nodes[0]->store.tx_begin_read ());
89  			auto block (system.nodes[0]->store.block.get (transaction, hash));
90  			std::string block_text;
91  			block->serialize_json (block_text);
92  		}));
93  		ASSERT_TIMELY (10s, !node1->balance (key.pub).is_zero ());
94  		node1->stop ();
95  		system.stop ();
96  		runner.join ();
97  	}
98  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
99  	{
100  		i->join ();
101  	}
102  }
103  TEST (ledger, deep_account_compute)
104  {
105  	nano::logger_mt logger;
106  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
107  	ASSERT_FALSE (store->init_error ());
108  	nano::stats stats;
109  	nano::ledger ledger (*store, stats, nano::dev::constants);
110  	auto transaction (store->tx_begin_write ());
111  	store->initialize (transaction, ledger.cache, ledger.constants);
112  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
113  	nano::keypair key;
114  	auto balance (nano::dev::constants.genesis_amount - 1);
115  	nano::block_builder builder;
116  	auto send = builder
117  				.send ()
118  				.previous (nano::dev::genesis->hash ())
119  				.destination (key.pub)
120  				.balance (balance)
121  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
122  				.work (*pool.generate (nano::dev::genesis->hash ()))
123  				.build ();
124  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
125  	auto open = builder
126  				.open ()
127  				.source (send->hash ())
128  				.representative (nano::dev::genesis_key.pub)
129  				.account (key.pub)
130  				.sign (key.prv, key.pub)
131  				.work (*pool.generate (key.pub))
132  				.build ();
133  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
134  	auto sprevious (send->hash ());
135  	auto rprevious (open->hash ());
136  	for (auto i (0), n (100000); i != n; ++i)
137  	{
138  		balance -= 1;
139  		auto send = builder
140  					.send ()
141  					.previous (sprevious)
142  					.destination (key.pub)
143  					.balance (balance)
144  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
145  					.work (*pool.generate (sprevious))
146  					.build ();
147  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
148  		sprevious = send->hash ();
149  		auto receive = builder
150  					   .receive ()
151  					   .previous (rprevious)
152  					   .source (send->hash ())
153  					   .sign (key.prv, key.pub)
154  					   .work (*pool.generate (rprevious))
155  					   .build ();
156  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
157  		rprevious = receive->hash ();
158  		if (i % 100 == 0)
159  		{
160  			std::cerr << i << ' ';
161  		}
162  		ledger.account (transaction, sprevious);
163  		ledger.balance (transaction, rprevious);
164  	}
165  }
166  TEST (wallet, multithreaded_send_async)
167  {
168  	std::vector<boost::thread> threads;
169  	{
170  		nano::test::system system (1);
171  		nano::keypair key;
172  		auto wallet_l (system.wallet (0));
173  		wallet_l->insert_adhoc (nano::dev::genesis_key.prv);
174  		wallet_l->insert_adhoc (key.prv);
175  		int num_of_threads = 20;
176  		int num_of_sends = 1000;
177  		for (auto i (0); i < num_of_threads; ++i)
178  		{
179  			threads.push_back (boost::thread ([wallet_l, &key, num_of_threads, num_of_sends] () {
180  				for (auto i (0); i < num_of_sends; ++i)
181  				{
182  					wallet_l->send_async (nano::dev::genesis_key.pub, key.pub, 1000, [] (std::shared_ptr<nano::block> const & block_a) {
183  						ASSERT_FALSE (block_a == nullptr);
184  						ASSERT_FALSE (block_a->hash ().is_zero ());
185  					});
186  				}
187  			}));
188  		}
189  		ASSERT_TIMELY (1000s, system.nodes[0]->balance (nano::dev::genesis_key.pub) == (nano::dev::constants.genesis_amount - num_of_threads * num_of_sends * 1000));
190  	}
191  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
192  	{
193  		i->join ();
194  	}
195  }
196  TEST (store, load)
197  {
198  	nano::test::system system (1);
199  	std::vector<boost::thread> threads;
200  	for (auto i (0); i < 100; ++i)
201  	{
202  		threads.push_back (boost::thread ([&system] () {
203  			for (auto i (0); i != 1000; ++i)
204  			{
205  				auto transaction (system.nodes[0]->store.tx_begin_write ());
206  				for (auto j (0); j != 10; ++j)
207  				{
208  					nano::account account;
209  					nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
210  					system.nodes[0]->store.confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
211  					system.nodes[0]->store.account.put (transaction, account, nano::account_info ());
212  				}
213  			}
214  		}));
215  	}
216  	for (auto & i : threads)
217  	{
218  		i.join ();
219  	}
220  }
221  namespace nano
222  {
223  TEST (node, fork_storm)
224  {
225  	static const auto node_count (23);
226  	nano::node_flags flags;
227  	flags.disable_max_peers_per_ip = true;
228  	nano::test::system system (node_count, nano::transport::transport_type::tcp, flags);
229  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
230  	auto previous (system.nodes[0]->latest (nano::dev::genesis_key.pub));
231  	auto balance (system.nodes[0]->balance (nano::dev::genesis_key.pub));
232  	ASSERT_FALSE (previous.is_zero ());
233  	nano::block_builder builder;
234  	for (auto node_j : system.nodes)
235  	{
236  		balance -= 1;
237  		nano::keypair key;
238  		auto send = builder
239  					.send ()
240  					.previous (previous)
241  					.destination (key.pub)
242  					.balance (balance)
243  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
244  					.work (0)
245  					.build ();
246  		node_j->work_generate_blocking (*send);
247  		previous = send->hash ();
248  		for (auto node_i : system.nodes)
249  		{
250  			auto send_result (node_i->process (*send));
251  			ASSERT_EQ (nano::process_result::progress, send_result.code);
252  			nano::keypair rep;
253  			auto open = builder
254  						.open ()
255  						.source (previous)
256  						.representative (rep.pub)
257  						.account (key.pub)
258  						.sign (key.prv, key.pub)
259  						.work (0)
260  						.build_shared ();
261  			node_i->work_generate_blocking (*open);
262  			auto open_result (node_i->process (*open));
263  			ASSERT_EQ (nano::process_result::progress, open_result.code);
264  			auto transaction (node_i->store.tx_begin_read ());
265  			node_i->network.flood_block (open);
266  		}
267  	}
268  	auto again (true);
269  	int iteration (0);
270  	auto old_empty (0);
271  	auto old_single (0);
272  	auto stall_count (0);
273  	while (again)
274  	{
275  		auto empty = 0;
276  		auto single = 0;
277  		std::for_each (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) {
278  			if (node_a->active.empty ())
279  			{
280  				++empty;
281  			}
282  			else
283  			{
284  				nano::unique_lock<nano::mutex> lock{ node_a->active.mutex };
285  				auto election = node_a->active.roots.begin ()->election;
286  				lock.unlock ();
287  				if (election->votes ().size () == 1)
288  				{
289  					++single;
290  				}
291  			}
292  		});
293  		ASSERT_NO_ERROR (system.poll ());
294  		if (old_empty == empty && old_single == single)
295  		{
296  			static const auto stall_tolerance (100000);
297  			++stall_count;
298  			ASSERT_LE (stall_count, stall_tolerance) << "Stall deteceted. These values were both expected to eventually reach 0 but have remained unchanged for " << stall_tolerance << " iterations. Empty: " << empty << " single: " << single << std::endl;
299  		}
300  		else
301  		{
302  			stall_count = 0;
303  			old_empty = empty;
304  			old_single = single;
305  		}
306  		again = (empty != 0) || (single != 0);
307  		++iteration;
308  	}
309  	ASSERT_TRUE (true);
310  }
311  } 
312  namespace
313  {
314  size_t heard_count (std::vector<uint8_t> const & nodes)
315  {
316  	auto result (0);
317  	for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
318  	{
319  		switch (*i)
320  		{
321  			case 0:
322  				break;
323  			case 1:
324  				++result;
325  				break;
326  			case 2:
327  				++result;
328  				break;
329  		}
330  	}
331  	return result;
332  }
333  }
334  TEST (broadcast, world_broadcast_simulate)
335  {
336  	auto node_count (10000);
337  	std::vector<uint8_t> nodes;
338  	nodes.resize (node_count, 0);
339  	nodes[0] = 1;
340  	auto any_changed (true);
341  	auto message_count (0);
342  	while (any_changed)
343  	{
344  		any_changed = false;
345  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
346  		{
347  			switch (*i)
348  			{
349  				case 0:
350  					break;
351  				case 1:
352  					for (auto j (nodes.begin ()), m (nodes.end ()); j != m; ++j)
353  					{
354  						++message_count;
355  						switch (*j)
356  						{
357  							case 0:
358  								*j = 1;
359  								any_changed = true;
360  								break;
361  							case 1:
362  								break;
363  							case 2:
364  								break;
365  						}
366  					}
367  					*i = 2;
368  					any_changed = true;
369  					break;
370  				case 2:
371  					break;
372  				default:
373  					ASSERT_FALSE (true);
374  					break;
375  			}
376  		}
377  	}
378  	auto count (heard_count (nodes));
379  	(void)count;
380  }
381  TEST (broadcast, sqrt_broadcast_simulate)
382  {
383  	auto node_count (10000);
384  	auto broadcast_count (std::ceil (std::sqrt (node_count)));
385  	std::vector<uint8_t> nodes;
386  	nodes.resize (node_count, 0);
387  	nodes[0] = 1;
388  	auto any_changed (true);
389  	uint64_t message_count (0);
390  	while (any_changed)
391  	{
392  		any_changed = false;
393  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
394  		{
395  			switch (*i)
396  			{
397  				case 0:
398  					break;
399  				case 1:
400  					for (auto j (0); j != broadcast_count; ++j)
401  					{
402  						++message_count;
403  						auto entry (nano::random_pool::generate_word32 (0, node_count - 1));
404  						switch (nodes[entry])
405  						{
406  							case 0:
407  								nodes[entry] = 1;
408  								any_changed = true;
409  								break;
410  							case 1:
411  								break;
412  							case 2:
413  								break;
414  						}
415  					}
416  					*i = 2;
417  					any_changed = true;
418  					break;
419  				case 2:
420  					break;
421  				default:
422  					ASSERT_FALSE (true);
423  					break;
424  			}
425  		}
426  	}
427  	auto count (heard_count (nodes));
428  	(void)count;
429  }
430  TEST (peer_container, random_set)
431  {
432  	nano::test::system system (1);
433  	auto old (std::chrono::steady_clock::now ());
434  	auto current (std::chrono::steady_clock::now ());
435  	for (auto i (0); i < 10000; ++i)
436  	{
437  		auto list (system.nodes[0]->network.random_set (15));
438  	}
439  	auto end (std::chrono::steady_clock::now ());
440  	(void)end;
441  	auto old_ms (std::chrono::duration_cast<std::chrono::milliseconds> (current - old));
442  	(void)old_ms;
443  	auto new_ms (std::chrono::duration_cast<std::chrono::milliseconds> (end - current));
444  	(void)new_ms;
445  }
446  TEST (store, unchecked_load)
447  {
448  	nano::test::system system{ 1 };
449  	auto & node = *system.nodes[0];
450  	nano::block_builder builder;
451  	std::shared_ptr<nano::block> block = builder
452  										 .send ()
453  										 .previous (0)
454  										 .destination (0)
455  										 .balance (0)
456  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
457  										 .work (0)
458  										 .build_shared ();
459  	constexpr auto num_unchecked = 1'000'000;
460  	for (auto i (0); i < num_unchecked; ++i)
461  	{
462  		node.unchecked.put (i, block);
463  	}
464  	ASSERT_TIMELY (8000s, num_unchecked == node.unchecked.count ());
465  }
466  TEST (store, vote_load)
467  {
468  	nano::test::system system{ 1 };
469  	auto & node = *system.nodes[0];
470  	for (auto i = 0u; i < 1000000u; ++i)
471  	{
472  		auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, i, 0, std::vector<nano::block_hash>{ i });
473  		node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
474  	}
475  }
476  TEST (store, pruned_load)
477  {
478  	nano::logger_mt logger;
479  	auto path (nano::unique_path ());
480  	constexpr auto num_pruned = 2000000;
481  	auto const expected_result = num_pruned / 2;
482  	constexpr auto batch_size = 20;
483  	boost::unordered_set<nano::block_hash> hashes;
484  	{
485  		auto store = nano::make_store (logger, path, nano::dev::constants);
486  		ASSERT_FALSE (store->init_error ());
487  		for (auto i (0); i < num_pruned / batch_size; ++i)
488  		{
489  			{
490  				auto transaction (store->tx_begin_write ());
491  				for (auto k (0); k < batch_size; ++k)
492  				{
493  					nano::block_hash random_hash;
494  					nano::random_pool::generate_block (random_hash.bytes.data (), random_hash.bytes.size ());
495  					store->pruned.put (transaction, random_hash);
496  					hashes.insert (random_hash);
497  				}
498  			}
499  			{
500  				auto transaction (store->tx_begin_write ());
501  				for (auto k (0); !hashes.empty () && k < batch_size / 2; ++k)
502  				{
503  					auto hash (hashes.begin ());
504  					store->pruned.del (transaction, *hash);
505  					hashes.erase (hash);
506  				}
507  			}
508  		}
509  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
510  	}
511  	{
512  		auto store = nano::make_store (logger, path, nano::dev::constants);
513  		ASSERT_FALSE (store->init_error ());
514  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
515  	}
516  }
517  TEST (wallets, rep_scan)
518  {
519  	nano::test::system system (1);
520  	auto & node (*system.nodes[0]);
521  	auto wallet (system.wallet (0));
522  	{
523  		auto transaction (node.wallets.tx_begin_write ());
524  		for (auto i (0); i < 10000; ++i)
525  		{
526  			wallet->deterministic_insert (transaction);
527  		}
528  	}
529  	auto begin (std::chrono::steady_clock::now ());
530  	node.wallets.foreach_representative ([] (nano::public_key const & pub_a, nano::raw_key const & prv_a) {
531  	});
532  	ASSERT_LT (std::chrono::steady_clock::now () - begin, std::chrono::milliseconds (5));
533  }
534  TEST (node, mass_vote_by_hash)
535  {
536  	nano::test::system system (1);
537  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
538  	nano::block_hash previous (nano::dev::genesis->hash ());
539  	nano::keypair key;
540  	std::vector<std::shared_ptr<nano::state_block>> blocks;
541  	nano::block_builder builder;
542  	for (auto i (0); i < 10000; ++i)
543  	{
544  		auto block = builder
545  					 .state ()
546  					 .account (nano::dev::genesis_key.pub)
547  					 .previous (previous)
548  					 .representative (nano::dev::genesis_key.pub)
549  					 .balance (nano::dev::constants.genesis_amount - (i + 1) * nano::Gxrb_ratio)
550  					 .link (key.pub)
551  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  					 .work (*system.work.generate (previous))
553  					 .build_shared ();
554  		previous = block->hash ();
555  		blocks.push_back (block);
556  	}
557  	for (auto i (blocks.begin ()), n (blocks.end ()); i != n; ++i)
558  	{
559  		system.nodes[0]->block_processor.add (*i);
560  	}
561  }
562  namespace nano
563  {
564  TEST (confirmation_height, many_accounts_single_confirmation)
565  {
566  	nano::test::system system;
567  	nano::node_config node_config = system.default_config ();
568  	node_config.online_weight_minimum = 100;
569  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
570  	auto node = system.add_node (node_config);
571  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
572  	node->confirmation_height_processor.batch_write_size = 500;
573  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
574  	nano::keypair last_keypair = nano::dev::genesis_key;
575  	nano::block_builder builder;
576  	auto last_open_hash = node->latest (nano::dev::genesis_key.pub);
577  	{
578  		auto transaction = node->store.tx_begin_write ();
579  		for (auto i = num_accounts - 1; i > 0; --i)
580  		{
581  			nano::keypair key;
582  			system.wallet (0)->insert_adhoc (key.prv);
583  			auto send = builder
584  						.send ()
585  						.previous (last_open_hash)
586  						.destination (key.pub)
587  						.balance (node->online_reps.delta ())
588  						.sign (last_keypair.prv, last_keypair.pub)
589  						.work (*system.work.generate (last_open_hash))
590  						.build ();
591  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
592  			auto open = builder
593  						.open ()
594  						.source (send->hash ())
595  						.representative (last_keypair.pub)
596  						.account (key.pub)
597  						.sign (key.prv, key.pub)
598  						.work (*system.work.generate (key.pub))
599  						.build ();
600  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
601  			last_open_hash = open->hash ();
602  			last_keypair = key;
603  		}
604  	}
605  	{
606  		auto block = node->block (last_open_hash);
607  		ASSERT_NE (nullptr, block);
608  		node->scheduler.buckets.manual (block);
609  		std::shared_ptr<nano::election> election;
610  		ASSERT_TIMELY (10s, (election = node->active.election (block->qualified_root ())) != nullptr);
611  		election->force_confirm ();
612  	}
613  	ASSERT_TIMELY (120s, node->ledger.block_confirmed (node->store.tx_begin_read (), last_open_hash));
614  	auto transaction = node->store.tx_begin_read ();
615  	for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
616  	{
617  		auto & account = i->first;
618  		auto & account_info = i->second;
619  		auto count = (account != last_keypair.pub) ? 2 : 1;
620  		nano::confirmation_height_info confirmation_height_info;
621  		ASSERT_FALSE (node->store.confirmation_height.get (transaction, account, confirmation_height_info));
622  		ASSERT_EQ (count, confirmation_height_info.height);
623  		ASSERT_EQ (count, account_info.block_count);
624  	}
625  	size_t cemented_count = 0;
626  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
627  	{
628  		cemented_count += i->second.height;
629  	}
630  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
631  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_accounts * 2 - 2);
632  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_accounts * 2 - 2);
633  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
634  	ASSERT_TIMELY (40s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
635  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
636  }
637  TEST (confirmation_height, many_accounts_many_confirmations)
638  {
639  	nano::test::system system;
640  	nano::node_config node_config = system.default_config ();
641  	node_config.online_weight_minimum = 100;
642  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
643  	auto node = system.add_node (node_config);
644  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
645  	node->confirmation_height_processor.batch_write_size = 500;
646  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
647  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
648  	nano::block_builder builder;
649  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
650  	{
651  		auto transaction = node->store.tx_begin_write ();
652  		for (auto i = num_accounts - 1; i > 0; --i)
653  		{
654  			nano::keypair key;
655  			system.wallet (0)->insert_adhoc (key.prv);
656  			auto send = builder
657  						.send ()
658  						.previous (latest_genesis)
659  						.destination (key.pub)
660  						.balance (node->online_reps.delta ())
661  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
662  						.work (*system.work.generate (latest_genesis))
663  						.build ();
664  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
665  			auto open = builder
666  						.open ()
667  						.source (send->hash ())
668  						.representative (nano::dev::genesis_key.pub)
669  						.account (key.pub)
670  						.sign (key.prv, key.pub)
671  						.work (*system.work.generate (key.pub))
672  						.build_shared ();
673  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
674  			open_blocks.push_back (std::move (open));
675  			latest_genesis = send->hash ();
676  		}
677  	}
678  	for (auto & open_block : open_blocks)
679  	{
680  		node->scheduler.buckets.manual (open_block);
681  		std::shared_ptr<nano::election> election;
682  		ASSERT_TIMELY (10s, (election = node->active.election (open_block->qualified_root ())) != nullptr);
683  		election->force_confirm ();
684  	}
685  	auto const num_blocks_to_confirm = (num_accounts - 1) * 2;
686  	ASSERT_TIMELY (1500s, node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) == num_blocks_to_confirm);
687  	auto num_confirmed_bounded = node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in);
688  	ASSERT_GE (num_confirmed_bounded, nano::confirmation_height::unbounded_cutoff);
689  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks_to_confirm - num_confirmed_bounded);
690  	ASSERT_TIMELY (60s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
691  	auto transaction = node->store.tx_begin_read ();
692  	size_t cemented_count = 0;
693  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
694  	{
695  		cemented_count += i->second.height;
696  	}
697  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
698  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
699  	ASSERT_TIMELY (20s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
700  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
701  }
702  TEST (confirmation_height, long_chains)
703  {
704  	nano::test::system system;
705  	nano::node_config node_config = system.default_config ();
706  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
707  	auto node = system.add_node (node_config);
708  	nano::keypair key1;
709  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
710  	nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
711  	system.wallet (0)->insert_adhoc (key1.prv);
712  	node->confirmation_height_processor.batch_write_size = 500;
713  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff * 2 + 50;
714  	nano::block_builder builder;
715  	auto send = builder
716  				.send ()
717  				.previous (latest)
718  				.destination (key1.pub)
719  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + num_blocks + 1)
720  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
721  				.work (*system.work.generate (latest))
722  				.build ();
723  	auto open = builder
724  				.open ()
725  				.source (send->hash ())
726  				.representative (nano::dev::genesis->account ())
727  				.account (key1.pub)
728  				.sign (key1.prv, key1.pub)
729  				.work (*system.work.generate (key1.pub))
730  				.build ();
731  	{
732  		auto transaction = node->store.tx_begin_write ();
733  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
734  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
735  	}
736  	auto previous_genesis_chain_hash = send->hash ();
737  	auto previous_destination_chain_hash = open->hash ();
738  	{
739  		auto transaction = node->store.tx_begin_write ();
740  		for (auto i = num_blocks - 1; i > 0; --i)
741  		{
742  			auto send = builder
743  						.send ()
744  						.previous (previous_genesis_chain_hash)
745  						.destination (key1.pub)
746  						.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
747  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
748  						.work (*system.work.generate (previous_genesis_chain_hash))
749  						.build ();
750  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
751  			auto receive = builder
752  						   .receive ()
753  						   .previous (previous_destination_chain_hash)
754  						   .source (send->hash ())
755  						   .sign (key1.prv, key1.pub)
756  						   .work (*system.work.generate (previous_destination_chain_hash))
757  						   .build ();
758  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *receive).code);
759  			previous_genesis_chain_hash = send->hash ();
760  			previous_destination_chain_hash = receive->hash ();
761  		}
762  	}
763  	auto send1 = builder
764  				 .send ()
765  				 .previous (previous_destination_chain_hash)
766  				 .destination (nano::dev::genesis_key.pub)
767  				 .balance (nano::Gxrb_ratio - 2)
768  				 .sign (key1.prv, key1.pub)
769  				 .work (*system.work.generate (previous_destination_chain_hash))
770  				 .build ();
771  	auto receive1 = builder
772  					.state ()
773  					.account (nano::dev::genesis_key.pub)
774  					.previous (previous_genesis_chain_hash)
775  					.representative (nano::dev::genesis->account ())
776  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + 1)
777  					.link (send1->hash ())
778  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
779  					.work (*system.work.generate (previous_genesis_chain_hash))
780  					.build_shared ();
781  	nano::keypair key2;
782  	auto send2 = builder
783  				 .state ()
784  				 .account (nano::dev::genesis->account ())
785  				 .previous (receive1->hash ())
786  				 .representative (nano::dev::genesis->account ())
787  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
788  				 .link (key2.pub)
789  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
790  				 .work (*system.work.generate (receive1->hash ()))
791  				 .build ();
792  	{
793  		auto transaction = node->store.tx_begin_write ();
794  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
795  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *receive1).code);
796  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send2).code);
797  	}
798  	{
799  		node->scheduler.buckets.manual (receive1);
800  		std::shared_ptr<nano::election> election;
801  		ASSERT_TIMELY (10s, (election = node->active.election (receive1->qualified_root ())) != nullptr);
802  		election->force_confirm ();
803  	}
804  	ASSERT_TIMELY (30s, node->ledger.block_confirmed (node->store.tx_begin_read (), receive1->hash ()));
805  	auto transaction (node->store.tx_begin_read ());
806  	auto info = node->ledger.account_info (transaction, nano::dev::genesis_key.pub);
807  	ASSERT_TRUE (info);
808  	nano::confirmation_height_info confirmation_height_info;
809  	ASSERT_FALSE (node->store.confirmation_height.get (transaction, nano::dev::genesis_key.pub, confirmation_height_info));
810  	ASSERT_EQ (num_blocks + 2, confirmation_height_info.height);
811  	ASSERT_EQ (num_blocks + 3, info->block_count); 
812  	info = node->ledger.account_info (transaction, key1.pub);
813  	ASSERT_TRUE (info);
814  	ASSERT_FALSE (node->store.confirmation_height.get (transaction, key1.pub, confirmation_height_info));
815  	ASSERT_EQ (num_blocks + 1, confirmation_height_info.height);
816  	ASSERT_EQ (num_blocks + 1, info->block_count);
817  	size_t cemented_count = 0;
818  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
819  	{
820  		cemented_count += i->second.height;
821  	}
822  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
823  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks * 2 + 2);
824  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_blocks * 2 + 2);
825  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
826  	ASSERT_TIMELY (40s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
827  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
828  }
829  TEST (confirmation_height, dynamic_algorithm)
830  {
831  	nano::test::system system;
832  	nano::node_config node_config = system.default_config ();
833  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
834  	auto node = system.add_node (node_config);
835  	nano::keypair key;
836  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
837  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff;
838  	auto latest_genesis = nano::dev::genesis;
839  	std::vector<std::shared_ptr<nano::state_block>> state_blocks;
840  	nano::block_builder builder;
841  	for (auto i = 0; i < num_blocks; ++i)
842  	{
843  		auto send = builder
844  					.state ()
845  					.account (nano::dev::genesis_key.pub)
846  					.previous (latest_genesis->hash ())
847  					.representative (nano::dev::genesis_key.pub)
848  					.balance (nano::dev::constants.genesis_amount - i - 1)
849  					.link (key.pub)
850  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
851  					.work (*system.work.generate (latest_genesis->hash ()))
852  					.build_shared ();
853  		latest_genesis = send;
854  		state_blocks.push_back (send);
855  	}
856  	{
857  		auto transaction = node->store.tx_begin_write ();
858  		for (auto const & block : state_blocks)
859  		{
860  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *block).code);
861  		}
862  	}
863  	node->confirmation_height_processor.add (state_blocks.front ());
864  	ASSERT_TIMELY (20s, node->ledger.cache.cemented_count == 2);
865  	node->confirmation_height_processor.add (latest_genesis);
866  	ASSERT_TIMELY (20s, node->ledger.cache.cemented_count == num_blocks + 1);
867  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
868  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 1);
869  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks - 1);
870  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
871  }
872  TEST (confirmation_height, dynamic_algorithm_no_transition_while_pending)
873  {
874  	for (auto _ = 0; _ < 3; ++_)
875  	{
876  		nano::test::system system;
877  		nano::node_config node_config = system.default_config ();
878  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
879  		nano::node_flags node_flags;
880  		node_flags.force_use_write_database_queue = true;
881  		auto node = system.add_node (node_config, node_flags);
882  		nano::keypair key;
883  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
884  		auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
885  		std::vector<std::shared_ptr<nano::state_block>> state_blocks;
886  		auto const num_blocks = nano::confirmation_height::unbounded_cutoff - 2;
887  		auto add_block_to_genesis_chain = [&] (nano::write_transaction & transaction) {
888  			static int num = 0;
889  			nano::block_builder builder;
890  			auto send = builder
891  						.state ()
892  						.account (nano::dev::genesis_key.pub)
893  						.previous (latest_genesis)
894  						.representative (nano::dev::genesis_key.pub)
895  						.balance (nano::dev::constants.genesis_amount - num - 1)
896  						.link (key.pub)
897  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
898  						.work (*system.work.generate (latest_genesis))
899  						.build_shared ();
900  			latest_genesis = send->hash ();
901  			state_blocks.push_back (send);
902  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
903  			++num;
904  		};
905  		for (auto i = 0; i < num_blocks; ++i)
906  		{
907  			auto transaction = node->store.tx_begin_write ();
908  			add_block_to_genesis_chain (transaction);
909  		}
910  		{
911  			auto write_guard = node->write_database_queue.wait (nano::writer::testing);
912  			node->confirmation_height_processor.add (state_blocks.back ());
913  			nano::timer<> timer;
914  			timer.start ();
915  			while (node->confirmation_height_processor.current ().is_zero ())
916  			{
917  				ASSERT_LT (timer.since_start (), 2s);
918  			}
919  			node->confirmation_height_processor.pause ();
920  			timer.restart ();
921  			ASSERT_TIMELY (10s, node->confirmation_height_processor.unbounded_processor.pending_writes_size != 0);
922  			{
923  				auto transaction = node->store.tx_begin_write ();
924  				add_block_to_genesis_chain (transaction);
925  				add_block_to_genesis_chain (transaction);
926  			}
927  			node->confirmation_height_processor.add (state_blocks.front ());
928  			node->confirmation_height_processor.unpause ();
929  		}
930  		ASSERT_TIMELY (10s, node->ledger.cache.cemented_count == num_blocks + 1);
931  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
932  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 0);
933  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks);
934  		ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
935  	}
936  }
937  TEST (confirmation_height, many_accounts_send_receive_self)
938  {
939  	nano::test::system system;
940  	nano::node_config node_config = system.default_config ();
941  	node_config.online_weight_minimum = 100;
942  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
943  	node_config.active_elections_size = 400000;
944  	nano::node_flags node_flags;
945  	node_flags.confirmation_height_processor_mode = nano::confirmation_height_mode::unbounded;
946  	auto node = system.add_node (node_config);
947  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
948  #ifndef NDEBUG
949  	auto const num_accounts = 10000;
950  #else
951  	auto const num_accounts = 100000;
952  #endif
953  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
954  	std::vector<nano::keypair> keys;
955  	nano::block_builder builder;
956  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
957  	{
958  		auto transaction = node->store.tx_begin_write ();
959  		for (auto i = 0; i < num_accounts; ++i)
960  		{
961  			nano::keypair key;
962  			keys.emplace_back (key);
963  			auto send = builder
964  						.send ()
965  						.previous (latest_genesis)
966  						.destination (key.pub)
967  						.balance (nano::dev::constants.genesis_amount - 1 - i)
968  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
969  						.work (*system.work.generate (latest_genesis))
970  						.build ();
971  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
972  			auto open = builder
973  						.open ()
974  						.source (send->hash ())
975  						.representative (nano::dev::genesis_key.pub)
976  						.account (key.pub)
977  						.sign (key.prv, key.pub)
978  						.work (*system.work.generate (key.pub))
979  						.build_shared ();
980  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
981  			open_blocks.push_back (std::move (open));
982  			latest_genesis = send->hash ();
983  		}
984  	}
985  	for (auto & open_block : open_blocks)
986  	{
987  		node->block_confirm (open_block);
988  		std::shared_ptr<nano::election> election;
989  		ASSERT_TIMELY (10s, (election = node->active.election (open_block->qualified_root ())) != nullptr);
990  		election->force_confirm ();
991  	}
992  	system.deadline_set (100s);
993  	auto num_blocks_to_confirm = num_accounts * 2;
994  	while (node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
995  	{
996  		ASSERT_NO_ERROR (system.poll ());
997  	}
998  	std::vector<std::shared_ptr<nano::send_block>> send_blocks;
999  	std::vector<std::shared_ptr<nano::receive_block>> receive_blocks;
1000  	for (int i = 0; i < open_blocks.size (); ++i)
1001  	{
1002  		auto open_block = open_blocks[i];
1003  		auto & keypair = keys[i];
1004  		send_blocks.emplace_back (builder
1005  								  .send ()
1006  								  .previous (open_block->hash ())
1007  								  .destination (keypair.pub)
1008  								  .balance (1)
1009  								  .sign (keypair.prv, keypair.pub)
1010  								  .work (*system.work.generate (open_block->hash ()))
1011  								  .build_shared ());
1012  		receive_blocks.emplace_back (builder
1013  									 .receive ()
1014  									 .previous (send_blocks.back ()->hash ())
1015  									 .source (send_blocks.back ()->hash ())
1016  									 .sign (keypair.prv, keypair.pub)
1017  									 .work (*system.work.generate (send_blocks.back ()->hash ()))
1018  									 .build_shared ());
1019  	}
1020  	for (int i = 0; i < open_blocks.size (); ++i)
1021  	{
1022  		node->process_active (send_blocks[i]);
1023  		node->process_active (receive_blocks[i]);
1024  	}
1025  	system.deadline_set (300s);
1026  	num_blocks_to_confirm = num_accounts * 4;
1027  	while (node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1028  	{
1029  		ASSERT_NO_ERROR (system.poll ());
1030  	}
1031  	system.deadline_set (200s);
1032  	while ((node->ledger.cache.cemented_count - 1) != node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1033  	{
1034  		ASSERT_NO_ERROR (system.poll ());
1035  	}
1036  	auto transaction = node->store.tx_begin_read ();
1037  	size_t cemented_count = 0;
1038  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
1039  	{
1040  		cemented_count += i->second.height;
1041  	}
1042  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1043  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
1044  	system.deadline_set (60s);
1045  	while ((node->ledger.cache.cemented_count - 1) != node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1046  	{
1047  		ASSERT_NO_ERROR (system.poll ());
1048  	}
1049  	system.deadline_set (60s);
1050  	while (node->active.election_winner_details_size () > 0)
1051  	{
1052  		ASSERT_NO_ERROR (system.poll ());
1053  	}
1054  }
1055  TEST (confirmation_height, many_accounts_send_receive_self_no_elections)
1056  {
1057  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
1058  	{
1059  		return;
1060  	}
1061  	nano::logger_mt logger;
1062  	nano::logging logging;
1063  	auto path (nano::unique_path ());
1064  	auto store = nano::make_store (logger, path, nano::dev::constants);
1065  	ASSERT_TRUE (!store->init_error ());
1066  	nano::stats stats;
1067  	nano::ledger ledger (*store, stats, nano::dev::constants);
1068  	nano::write_database_queue write_database_queue (false);
1069  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1070  	std::atomic<bool> stopped{ false };
1071  	boost::latch initialized_latch{ 0 };
1072  	nano::block_hash block_hash_being_processed{ 0 };
1073  	nano::confirmation_height_processor confirmation_height_processor{ ledger, write_database_queue, 10ms, logging, logger, initialized_latch, confirmation_height_mode::automatic };
1074  	auto const num_accounts = 100000;
1075  	auto latest_genesis = nano::dev::genesis->hash ();
1076  	std::vector<nano::keypair> keys;
1077  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
1078  	nano::block_builder builder;
1079  	nano::test::system system;
1080  	{
1081  		auto transaction (store->tx_begin_write ());
1082  		store->initialize (transaction, ledger.cache, ledger.constants);
1083  		for (auto i = 0; i < num_accounts; ++i)
1084  		{
1085  			nano::keypair key;
1086  			keys.emplace_back (key);
1087  			auto send = builder
1088  						.send ()
1089  						.previous (latest_genesis)
1090  						.destination (key.pub)
1091  						.balance (nano::dev::constants.genesis_amount - 1 - i)
1092  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1093  						.work (*pool.generate (latest_genesis))
1094  						.build ();
1095  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1096  			auto open = builder
1097  						.open ()
1098  						.source (send->hash ())
1099  						.representative (nano::dev::genesis_key.pub)
1100  						.account (key.pub)
1101  						.sign (key.prv, key.pub)
1102  						.work (*pool.generate (key.pub))
1103  						.build_shared ();
1104  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1105  			open_blocks.push_back (std::move (open));
1106  			latest_genesis = send->hash ();
1107  		}
1108  	}
1109  	for (auto & open_block : open_blocks)
1110  	{
1111  		confirmation_height_processor.add (open_block);
1112  	}
1113  	system.deadline_set (1000s);
1114  	auto num_blocks_to_confirm = num_accounts * 2;
1115  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1116  	{
1117  		ASSERT_NO_ERROR (system.poll ());
1118  	}
1119  	std::vector<std::shared_ptr<nano::send_block>> send_blocks;
1120  	std::vector<std::shared_ptr<nano::receive_block>> receive_blocks;
1121  	{
1122  		auto transaction (store->tx_begin_write ());
1123  		for (int i = 0; i < open_blocks.size (); ++i)
1124  		{
1125  			auto open_block = open_blocks[i];
1126  			auto & keypair = keys[i];
1127  			send_blocks.emplace_back (builder
1128  									  .send ()
1129  									  .previous (open_block->hash ())
1130  									  .destination (keypair.pub)
1131  									  .balance (1)
1132  									  .sign (keypair.prv, keypair.pub)
1133  									  .work (*system.work.generate (open_block->hash ()))
1134  									  .build_shared ());
1135  			receive_blocks.emplace_back (builder
1136  										 .receive ()
1137  										 .previous (send_blocks.back ()->hash ())
1138  										 .source (send_blocks.back ()->hash ())
1139  										 .sign (keypair.prv, keypair.pub)
1140  										 .work (*system.work.generate (send_blocks.back ()->hash ()))
1141  										 .build_shared ());
1142  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_blocks.back ()).code);
1143  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive_blocks.back ()).code);
1144  		}
1145  	}
1146  	std::random_device rd;
1147  	std::mt19937 g (rd ());
1148  	std::shuffle (send_blocks.begin (), send_blocks.end (), g);
1149  	std::mt19937 g1 (rd ());
1150  	std::shuffle (receive_blocks.begin (), receive_blocks.end (), g1);
1151  	for (int i = 0; i < open_blocks.size (); ++i)
1152  	{
1153  		confirmation_height_processor.add (send_blocks[i]);
1154  		confirmation_height_processor.add (receive_blocks[i]);
1155  	}
1156  	system.deadline_set (1000s);
1157  	num_blocks_to_confirm = num_accounts * 4;
1158  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1159  	{
1160  		ASSERT_NO_ERROR (system.poll ());
1161  	}
1162  	while (!confirmation_height_processor.current ().is_zero ())
1163  	{
1164  		ASSERT_NO_ERROR (system.poll ());
1165  	}
1166  	auto transaction = store->tx_begin_read ();
1167  	size_t cemented_count = 0;
1168  	for (auto i (store->confirmation_height.begin (transaction)), n (store->confirmation_height.end ()); i != n; ++i)
1169  	{
1170  		cemented_count += i->second.height;
1171  	}
1172  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1173  	ASSERT_EQ (cemented_count, ledger.cache.cemented_count);
1174  }
1175  }
1176  namespace
1177  {
1178  class data
1179  {
1180  public:
1181  	std::atomic<bool> awaiting_cache{ false };
1182  	std::atomic<bool> keep_requesting_metrics{ true };
1183  	std::shared_ptr<nano::node> node;
1184  	std::chrono::system_clock::time_point orig_time;
1185  	std::atomic_flag orig_time_set = ATOMIC_FLAG_INIT;
1186  };
1187  class shared_data
1188  {
1189  public:
1190  	nano::test::counted_completion write_completion{ 0 };
1191  	std::atomic<bool> done{ false };
1192  };
1193  template <typename T>
1194  void callback_process (shared_data & shared_data_a, data & data, T & all_node_data_a, std::chrono::system_clock::time_point last_updated)
1195  {
1196  	if (!data.orig_time_set.test_and_set ())
1197  	{
1198  		data.orig_time = last_updated;
1199  	}
1200  	if (data.awaiting_cache && data.orig_time != last_updated)
1201  	{
1202  		data.keep_requesting_metrics = false;
1203  	}
1204  	if (data.orig_time != last_updated)
1205  	{
1206  		data.awaiting_cache = true;
1207  		data.orig_time = last_updated;
1208  	}
1209  	shared_data_a.write_completion.increment ();
1210  };
1211  }
1212  TEST (telemetry, ongoing_requests)
1213  {
1214  	nano::test::system system;
1215  	nano::node_flags node_flags;
1216  	auto node_client = system.add_node (node_flags);
1217  	auto node_server = system.add_node (node_flags);
1218  	nano::test::wait_peer_connections (system);
1219  	ASSERT_EQ (0, node_client->telemetry.size ());
1220  	ASSERT_EQ (0, node_server->telemetry.size ());
1221  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1222  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1223  	ASSERT_TIMELY (20s, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1 && node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1);
1224  	auto time = std::chrono::steady_clock::now ();
1225  	ASSERT_TIMELY (10s, std::chrono::steady_clock::now () >= (time + nano::dev::network_params.network.telemetry_cache_cutoff + 1s));
1226  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1227  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1228  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1229  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1230  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1231  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1232  }
1233  namespace nano
1234  {
1235  namespace transport
1236  {
1237  	TEST (telemetry, simultaneous_requests)
1238  	{
1239  		nano::test::system system;
1240  		nano::node_flags node_flags;
1241  		auto const num_nodes = 4;
1242  		for (int i = 0; i < num_nodes; ++i)
1243  		{
1244  			system.add_node (node_flags);
1245  		}
1246  		nano::test::wait_peer_connections (system);
1247  		std::vector<std::thread> threads;
1248  		auto const num_threads = 4;
1249  		std::array<data, num_nodes> node_data{};
1250  		for (auto i = 0; i < num_nodes; ++i)
1251  		{
1252  			node_data[i].node = system.nodes[i];
1253  		}
1254  		shared_data shared_data;
1255  		for (int i = 0; i < num_threads; ++i)
1256  		{
1257  			threads.emplace_back ([&node_data, &shared_data] () {
1258  				while (std::any_of (node_data.cbegin (), node_data.cend (), [] (auto const & data) { return data.keep_requesting_metrics.load (); }))
1259  				{
1260  					for (auto & data : node_data)
1261  					{
1262  						if (data.keep_requesting_metrics)
1263  						{
1264  							shared_data.write_completion.increment_required_count ();
1265  							auto peer = data.node->network.tcp_channels.channels[0].channel;
1266  							auto maybe_telemetry = data.node->telemetry.get_telemetry (peer->get_endpoint ());
1267  							if (maybe_telemetry)
1268  							{
1269  								callback_process (shared_data, data, node_data, maybe_telemetry->timestamp);
1270  							}
1271  						}
1272  						std::this_thread::sleep_for (1ms);
1273  					}
1274  				}
1275  				shared_data.write_completion.await_count_for (20s);
1276  				shared_data.done = true;
1277  			});
1278  		}
1279  		ASSERT_TIMELY (30s, shared_data.done);
1280  		ASSERT_TRUE (std::all_of (node_data.begin (), node_data.end (), [] (auto const & data) { return !data.keep_requesting_metrics; }));
1281  		for (auto & thread : threads)
1282  		{
1283  			thread.join ();
1284  		}
1285  	}
1286  }
1287  }
1288  TEST (telemetry, under_load)
1289  {
1290  	nano::test::system system;
1291  	nano::node_config node_config = system.default_config ();
1292  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1293  	nano::node_flags node_flags;
1294  	auto node = system.add_node (node_config, node_flags);
1295  	node_config.peering_port = system.get_available_port ();
1296  	auto node1 = system.add_node (node_config, node_flags);
1297  	nano::keypair key;
1298  	nano::keypair key1;
1299  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1300  	system.wallet (0)->insert_adhoc (key.prv);
1301  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
1302  	auto num_blocks = 150000;
1303  	nano::block_builder builder;
1304  	auto send = builder
1305  				.state ()
1306  				.account (nano::dev::genesis_key.pub)
1307  				.previous (latest_genesis)
1308  				.representative (nano::dev::genesis_key.pub)
1309  				.balance (nano::dev::constants.genesis_amount - num_blocks)
1310  				.link (key.pub)
1311  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1312  				.work (*system.work.generate (latest_genesis))
1313  				.build_shared ();
1314  	node->process_active (send);
1315  	latest_genesis = send->hash ();
1316  	auto open = builder
1317  				.state ()
1318  				.account (key.pub)
1319  				.previous (0)
1320  				.representative (key.pub)
1321  				.balance (num_blocks)
1322  				.link (send->hash ())
1323  				.sign (key.prv, key.pub)
1324  				.work (*system.work.generate (key.pub))
1325  				.build_shared ();
1326  	node->process_active (open);
1327  	auto latest_key = open->hash ();
1328  	auto thread_func = [key1, &system, node, num_blocks] (nano::keypair const & keypair, nano::block_hash const & latest, nano::uint128_t const initial_amount) {
1329  		auto latest_l = latest;
1330  		nano::block_builder builder;
1331  		for (int i = 0; i < num_blocks; ++i)
1332  		{
1333  			auto send = builder
1334  						.state ()
1335  						.account (keypair.pub)
1336  						.previous (latest_l)
1337  						.representative (keypair.pub)
1338  						.balance (initial_amount - i - 1)
1339  						.link (key1.pub)
1340  						.sign (keypair.prv, keypair.pub)
1341  						.work (*system.work.generate (latest_l))
1342  						.build_shared ();
1343  			latest_l = send->hash ();
1344  			node->process_active (send);
1345  		}
1346  	};
1347  	std::thread thread1 (thread_func, nano::dev::genesis_key, latest_genesis, nano::dev::constants.genesis_amount - num_blocks);
1348  	std::thread thread2 (thread_func, key, latest_key, num_blocks);
1349  	ASSERT_TIMELY (200s, node1->ledger.cache.block_count == num_blocks * 2 + 3);
1350  	thread1.join ();
1351  	thread2.join ();
1352  	for (auto const & node : system.nodes)
1353  	{
1354  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::failed_send_telemetry_req));
1355  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone));
1356  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::unsolicited_telemetry_ack));
1357  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::no_response_received));
1358  	}
1359  }
1360  TEST (telemetry, cache_read_and_timeout)
1361  {
1362  	nano::test::system system;
1363  	nano::node_flags node_flags;
1364  	node_flags.disable_ongoing_telemetry_requests = true;
1365  	auto node_client = system.add_node (node_flags);
1366  	auto node_server = system.add_node (node_flags);
1367  	nano::test::wait_peer_connections (system);
1368  	std::optional<nano::telemetry_data> telemetry_data;
1369  	auto channel = node_client->network.find_node_id (node_server->get_node_id ());
1370  	ASSERT_NE (channel, nullptr);
1371  	node_client->telemetry.trigger ();
1372  	ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (channel->get_endpoint ()));
1373  	auto responses = node_client->telemetry.get_all_telemetries ();
1374  	ASSERT_TRUE (!responses.empty ());
1375  	ASSERT_EQ (telemetry_data, responses.begin ()->second);
1376  	ASSERT_EQ (1, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1377  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1378  	ASSERT_EQ (1, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1379  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1380  	ASSERT_EQ (1, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1381  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1382  	ASSERT_TIMELY (5s, node_client->telemetry.get_all_telemetries ().empty ());
1383  	responses = node_client->telemetry.get_all_telemetries ();
1384  	ASSERT_TRUE (responses.empty ());
1385  	node_client->telemetry.trigger ();
1386  	ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (channel->get_endpoint ()));
1387  	responses = node_client->telemetry.get_all_telemetries ();
1388  	ASSERT_TRUE (!responses.empty ());
1389  	ASSERT_EQ (telemetry_data, responses.begin ()->second);
1390  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1391  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1392  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1393  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1394  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1395  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1396  }
1397  TEST (telemetry, many_nodes)
1398  {
1399  	nano::test::system system;
1400  	nano::node_flags node_flags;
1401  	node_flags.disable_request_loop = true;
1402  	auto const num_nodes = nano::memory_intensive_instrumentation () ? 4 : 10;
1403  	for (auto i = 0; i < num_nodes; ++i)
1404  	{
1405  		nano::node_config node_config = system.default_config ();
1406  		node_config.bandwidth_limit = 100000 + i;
1407  		auto node = std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), node_config, system.work, node_flags);
1408  		node->start ();
1409  		system.nodes.push_back (node);
1410  	}
1411  	for (auto const & node : system.nodes)
1412  	{
1413  		for (auto const & other_node : system.nodes)
1414  		{
1415  			if (node != other_node)
1416  			{
1417  				node->network.merge_peer (other_node->network.endpoint ());
1418  			}
1419  		}
1420  	}
1421  	nano::test::wait_peer_connections (system);
1422  	nano::keypair key;
1423  	nano::block_builder builder;
1424  	auto send = builder
1425  				.state ()
1426  				.account (nano::dev::genesis_key.pub)
1427  				.previous (nano::dev::genesis->hash ())
1428  				.representative (nano::dev::genesis_key.pub)
1429  				.balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1430  				.link (key.pub)
1431  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1432  				.work (*system.work.generate (nano::dev::genesis->hash ()))
1433  				.build ();
1434  	for (auto node : system.nodes)
1435  	{
1436  		auto transaction (node->store.tx_begin_write ());
1437  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
1438  	}
1439  	auto node_client = system.nodes.front ();
1440  	std::vector<nano::telemetry_data> telemetry_datas;
1441  	auto peers = node_client->network.list (num_nodes - 1);
1442  	ASSERT_EQ (peers.size (), num_nodes - 1);
1443  	for (auto const & peer : peers)
1444  	{
1445  		std::optional<nano::telemetry_data> telemetry_data;
1446  		ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (peer->get_endpoint ()));
1447  		telemetry_datas.push_back (*telemetry_data);
1448  	}
1449  	ASSERT_EQ (telemetry_datas.size (), num_nodes - 1);
1450  	for (auto & data : telemetry_datas)
1451  	{
1452  		ASSERT_EQ (data.unchecked_count, 0);
1453  		ASSERT_EQ (data.cemented_count, 1);
1454  		ASSERT_LE (data.peer_count, 9U);
1455  		ASSERT_EQ (data.account_count, 1);
1456  		ASSERT_TRUE (data.block_count == 2);
1457  		ASSERT_EQ (data.protocol_version, nano::dev::network_params.network.protocol_version);
1458  		ASSERT_GE (data.bandwidth_cap, 100000);
1459  		ASSERT_LT (data.bandwidth_cap, 100000 + system.nodes.size ());
1460  		ASSERT_EQ (data.major_version, nano::get_major_node_version ());
1461  		ASSERT_EQ (data.minor_version, nano::get_minor_node_version ());
1462  		ASSERT_EQ (data.patch_version, nano::get_patch_node_version ());
1463  		ASSERT_EQ (data.pre_release_version, nano::get_pre_release_node_version ());
1464  		ASSERT_EQ (data.maker, 0);
1465  		ASSERT_LT (data.uptime, 100);
1466  		ASSERT_EQ (data.genesis_block, nano::dev::genesis->hash ());
1467  		ASSERT_LE (data.timestamp, std::chrono::system_clock::now ());
1468  		ASSERT_EQ (data.active_difficulty, system.nodes.front ()->default_difficulty (nano::work_version::work_1));
1469  	}
1470  	auto bandwidth_cap = telemetry_datas.front ().bandwidth_cap;
1471  	telemetry_datas.erase (telemetry_datas.begin ());
1472  	auto all_bandwidth_limits_same = std::all_of (telemetry_datas.begin (), telemetry_datas.end (), [bandwidth_cap] (auto & telemetry_data) {
1473  		return telemetry_data.bandwidth_cap == bandwidth_cap;
1474  	});
1475  	ASSERT_FALSE (all_bandwidth_limits_same);
1476  }
1477  TEST (signature_checker, mass_boundary_checks)
1478  {
1479  	std::vector<size_t> sizes{ 0, 1 };
1480  	auto add_boundary = [&sizes] (size_t boundary) {
1481  		sizes.insert (sizes.end (), { boundary - 1, boundary, boundary + 1 });
1482  	};
1483  	for (auto i = 1; i <= 10; ++i)
1484  	{
1485  		add_boundary (nano::signature_checker::batch_size * i);
1486  	}
1487  	nano::block_builder builder;
1488  	for (auto num_threads = 0; num_threads < 5; ++num_threads)
1489  	{
1490  		nano::signature_checker checker (num_threads);
1491  		auto max_size = *(sizes.end () - 1);
1492  		std::vector<nano::uint256_union> hashes;
1493  		hashes.reserve (max_size);
1494  		std::vector<unsigned char const *> messages;
1495  		messages.reserve (max_size);
1496  		std::vector<size_t> lengths;
1497  		lengths.reserve (max_size);
1498  		std::vector<unsigned char const *> pub_keys;
1499  		pub_keys.reserve (max_size);
1500  		std::vector<unsigned char const *> signatures;
1501  		signatures.reserve (max_size);
1502  		nano::keypair key;
1503  		auto block = builder
1504  					 .state ()
1505  					 .account (key.pub)
1506  					 .previous (0)
1507  					 .representative (key.pub)
1508  					 .balance (0)
1509  					 .link (0)
1510  					 .sign (key.prv, key.pub)
1511  					 .work (0)
1512  					 .build ();
1513  		size_t last_size = 0;
1514  		for (auto size : sizes)
1515  		{
1516  			auto extra_size = size - last_size;
1517  			std::vector<int> verifications;
1518  			verifications.resize (size);
1519  			for (auto i (0); i < extra_size; ++i)
1520  			{
1521  				hashes.push_back (block->hash ());
1522  				messages.push_back (hashes.back ().bytes.data ());
1523  				lengths.push_back (sizeof (decltype (hashes)::value_type));
1524  				pub_keys.push_back (block->hashables.account.bytes.data ());
1525  				signatures.push_back (block->signature.bytes.data ());
1526  			}
1527  			nano::signature_check_set check = { size, messages.data (), lengths.data (), pub_keys.data (), signatures.data (), verifications.data () };
1528  			checker.verify (check);
1529  			bool all_valid = std::all_of (verifications.cbegin (), verifications.cend (), [] (auto verification) { return verification == 1; });
1530  			ASSERT_TRUE (all_valid);
1531  			last_size = size;
1532  		}
1533  	}
1534  }
1535  TEST (node, mass_epoch_upgrader)
1536  {
1537  	auto perform_test = [] (size_t const batch_size) {
1538  		unsigned threads = 5;
1539  		size_t total_accounts = 2500;
1540  #ifndef NDEBUG
1541  		total_accounts /= 5;
1542  #endif
1543  		struct info
1544  		{
1545  			nano::keypair key;
1546  			nano::block_hash pending_hash;
1547  		};
1548  		std::vector<info> opened (total_accounts / 2);
1549  		std::vector<info> unopened (total_accounts / 2);
1550  		nano::test::system system;
1551  		nano::node_config node_config = system.default_config ();
1552  		node_config.work_threads = 4;
1553  		auto & node = *system.add_node (node_config);
1554  		auto balance = node.balance (nano::dev::genesis_key.pub);
1555  		auto latest = node.latest (nano::dev::genesis_key.pub);
1556  		nano::uint128_t amount = 1;
1557  		std::array<std::vector<info> *, 2> all{ &opened, &unopened };
1558  		for (auto & accounts : all)
1559  		{
1560  			for (auto & info : *accounts)
1561  			{
1562  				balance -= amount;
1563  				nano::state_block_builder builder;
1564  				std::error_code ec;
1565  				auto block = builder
1566  							 .account (nano::dev::genesis_key.pub)
1567  							 .previous (latest)
1568  							 .balance (balance)
1569  							 .link (info.key.pub)
1570  							 .representative (nano::dev::genesis_key.pub)
1571  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1572  							 .work (*node.work_generate_blocking (latest, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1573  							 .build (ec);
1574  				ASSERT_FALSE (ec);
1575  				ASSERT_NE (nullptr, block);
1576  				ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1577  				latest = block->hash ();
1578  				info.pending_hash = block->hash ();
1579  			}
1580  		}
1581  		ASSERT_EQ (1 + total_accounts, node.ledger.cache.block_count);
1582  		ASSERT_EQ (1, node.ledger.cache.account_count);
1583  		for (auto const & info : opened)
1584  		{
1585  			nano::state_block_builder builder;
1586  			std::error_code ec;
1587  			auto block = builder
1588  						 .account (info.key.pub)
1589  						 .previous (0)
1590  						 .balance (amount)
1591  						 .link (info.pending_hash)
1592  						 .representative (info.key.pub)
1593  						 .sign (info.key.prv, info.key.pub)
1594  						 .work (*node.work_generate_blocking (info.key.pub, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1595  						 .build (ec);
1596  			ASSERT_FALSE (ec);
1597  			ASSERT_NE (nullptr, block);
1598  			ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1599  		}
1600  		ASSERT_EQ (1 + total_accounts + opened.size (), node.ledger.cache.block_count);
1601  		ASSERT_EQ (1 + opened.size (), node.ledger.cache.account_count);
1602  		nano::keypair epoch_signer (nano::dev::genesis_key);
1603  		auto const block_count_before = node.ledger.cache.block_count.load ();
1604  		auto const total_to_upgrade = 1 + total_accounts;
1605  		std::cout << "Mass upgrading " << total_to_upgrade << " accounts" << std::endl;
1606  		while (node.ledger.cache.block_count != block_count_before + total_to_upgrade)
1607  		{
1608  			auto const pre_upgrade = node.ledger.cache.block_count.load ();
1609  			auto upgrade_count = std::min<size_t> (batch_size, block_count_before + total_to_upgrade - pre_upgrade);
1610  			ASSERT_FALSE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1611  			ASSERT_TRUE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1612  			system.deadline_set (60s);
1613  			while (node.ledger.cache.block_count != pre_upgrade + upgrade_count)
1614  			{
1615  				ASSERT_NO_ERROR (system.poll ());
1616  				std::this_thread::sleep_for (200ms);
1617  				std::cout << node.ledger.cache.block_count - block_count_before << " / " << total_to_upgrade << std::endl;
1618  			}
1619  			std::this_thread::sleep_for (50ms);
1620  		}
1621  		auto expected_blocks = block_count_before + total_accounts + 1;
1622  		ASSERT_EQ (expected_blocks, node.ledger.cache.block_count);
1623  		{
1624  			auto transaction (node.store.tx_begin_read ());
1625  			size_t block_count_sum = 0;
1626  			for (auto i (node.store.account.begin (transaction)); i != node.store.account.end (); ++i)
1627  			{
1628  				nano::account_info info (i->second);
1629  				ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1630  				block_count_sum += info.block_count;
1631  			}
1632  			ASSERT_EQ (expected_blocks, block_count_sum);
1633  		}
1634  	};
1635  	perform_test (42);
1636  	perform_test (std::numeric_limits<size_t>::max ());
1637  }
1638  namespace nano
1639  {
1640  TEST (node, mass_block_new)
1641  {
1642  	nano::test::system system;
1643  	nano::node_config node_config = system.default_config ();
1644  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1645  	auto & node = *system.add_node (node_config);
1646  	node.network_params.network.aec_loop_interval_ms = 500;
1647  #ifndef NDEBUG
1648  	auto const num_blocks = 5000;
1649  #else
1650  	auto const num_blocks = 50000;
1651  #endif
1652  	std::cout << num_blocks << " x4 blocks" << std::endl;
1653  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
1654  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_2);
1655  	auto next_block_count = num_blocks + 3;
1656  	auto process_all = [&] (std::vector<std::shared_ptr<nano::state_block>> const & blocks_a) {
1657  		for (auto const & block : blocks_a)
1658  		{
1659  			node.process_active (block);
1660  		}
1661  		ASSERT_TIMELY (200s, node.ledger.cache.block_count == next_block_count);
1662  		next_block_count += num_blocks;
1663  		node.block_processor.flush ();
1664  		{
1665  			nano::lock_guard<nano::mutex> guard{ node.active.mutex };
1666  			node.active.roots.clear ();
1667  			node.active.blocks.clear ();
1668  		}
1669  	};
1670  	nano::keypair key;
1671  	std::vector<nano::keypair> keys (num_blocks);
1672  	nano::state_block_builder builder;
1673  	std::vector<std::shared_ptr<nano::state_block>> send_blocks;
1674  	auto send_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false)));
1675  	auto latest_genesis = node.latest (nano::dev::genesis_key.pub);
1676  	for (auto i = 0; i < num_blocks; ++i)
1677  	{
1678  		auto send = builder.make_block ()
1679  					.account (nano::dev::genesis_key.pub)
1680  					.previous (latest_genesis)
1681  					.balance (nano::dev::constants.genesis_amount - i - 1)
1682  					.representative (nano::dev::genesis_key.pub)
1683  					.link (keys[i].pub)
1684  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1685  					.work (*system.work.generate (nano::work_version::work_1, latest_genesis, send_threshold))
1686  					.build ();
1687  		latest_genesis = send->hash ();
1688  		send_blocks.push_back (std::move (send));
1689  	}
1690  	std::cout << "Send blocks built, start processing" << std::endl;
1691  	nano::timer<> timer;
1692  	timer.start ();
1693  	process_all (send_blocks);
1694  	std::cout << "Send blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1695  	std::vector<std::shared_ptr<nano::state_block>> open_blocks;
1696  	auto receive_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, true, false)));
1697  	for (auto i = 0; i < num_blocks; ++i)
1698  	{
1699  		auto const & key = keys[i];
1700  		auto open = builder.make_block ()
1701  					.account (key.pub)
1702  					.previous (0)
1703  					.balance (1)
1704  					.representative (key.pub)
1705  					.link (send_blocks[i]->hash ())
1706  					.sign (key.prv, key.pub)
1707  					.work (*system.work.generate (nano::work_version::work_1, key.pub, receive_threshold))
1708  					.build ();
1709  		open_blocks.push_back (std::move (open));
1710  	}
1711  	std::cout << "Open blocks built, start processing" << std::endl;
1712  	timer.restart ();
1713  	process_all (open_blocks);
1714  	std::cout << "Open blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1715  	std::vector<std::shared_ptr<nano::state_block>> send_blocks2;
1716  	for (auto i = 0; i < num_blocks; ++i)
1717  	{
1718  		auto const & key = keys[i];
1719  		auto const & latest = open_blocks[i];
1720  		auto send2 = builder.make_block ()
1721  					 .account (key.pub)
1722  					 .previous (latest->hash ())
1723  					 .balance (0)
1724  					 .representative (key.pub)
1725  					 .link (key.pub)
1726  					 .sign (key.prv, key.pub)
1727  					 .work (*system.work.generate (nano::work_version::work_1, latest->hash (), send_threshold))
1728  					 .build ();
1729  		send_blocks2.push_back (std::move (send2));
1730  	}
1731  	std::cout << "Send2 blocks built, start processing" << std::endl;
1732  	timer.restart ();
1733  	process_all (send_blocks2);
1734  	std::cout << "Send2 blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1735  	std::vector<std::shared_ptr<nano::state_block>> receive_blocks;
1736  	for (auto i = 0; i < num_blocks; ++i)
1737  	{
1738  		auto const & key = keys[i];
1739  		auto const & latest = send_blocks2[i];
1740  		auto send2 = builder.make_block ()
1741  					 .account (key.pub)
1742  					 .previous (latest->hash ())
1743  					 .balance (1)
1744  					 .representative (key.pub)
1745  					 .link (latest->hash ())
1746  					 .sign (key.prv, key.pub)
1747  					 .work (*system.work.generate (nano::work_version::work_1, latest->hash (), receive_threshold))
1748  					 .build ();
1749  		receive_blocks.push_back (std::move (send2));
1750  	}
1751  	std::cout << "Receive blocks built, start processing" << std::endl;
1752  	timer.restart ();
1753  	process_all (receive_blocks);
1754  	std::cout << "Receive blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1755  }
1756  TEST (node, aggressive_flooding)
1757  {
1758  	nano::test::system system;
1759  	nano::node_flags node_flags;
1760  	node_flags.disable_request_loop = true;
1761  	node_flags.disable_bootstrap_bulk_push_client = true;
1762  	node_flags.disable_bootstrap_bulk_pull_server = true;
1763  	node_flags.disable_bootstrap_listener = true;
1764  	node_flags.disable_lazy_bootstrap = true;
1765  	node_flags.disable_legacy_bootstrap = true;
1766  	node_flags.disable_wallet_bootstrap = true;
1767  	node_flags.disable_ascending_bootstrap = true;
1768  	auto & node1 (*system.add_node (node_flags));
1769  	auto & wallet1 (*system.wallet (0));
1770  	wallet1.insert_adhoc (nano::dev::genesis_key.prv);
1771  	std::vector<std::pair<std::shared_ptr<nano::node>, std::shared_ptr<nano::wallet>>> nodes_wallets;
1772  	nodes_wallets.resize (!nano::memory_intensive_instrumentation () ? 5 : 3);
1773  	std::generate (nodes_wallets.begin (), nodes_wallets.end (), [&system, node_flags] () {
1774  		nano::node_config node_config = system.default_config ();
1775  		auto node (system.add_node (node_config, node_flags));
1776  		return std::make_pair (node, system.wallet (system.nodes.size () - 1));
1777  	});
1778  	ASSERT_TIMELY (5s, node1.network.size () == nodes_wallets.size ());
1779  	ASSERT_LT (node1.network.fanout (), nodes_wallets.size ());
1780  	ASSERT_TIMELY (10s, std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const & node_wallet) { return node_wallet.first->rep_crawler.principal_representatives ().size () != 0; }));
1781  	auto large_amount = (nano::dev::constants.genesis_amount / 2) / nodes_wallets.size ();
1782  	std::vector<std::shared_ptr<nano::block>> genesis_blocks;
1783  	for (auto & node_wallet : nodes_wallets)
1784  	{
1785  		nano::keypair keypair;
1786  		node_wallet.second->store.representative_set (node_wallet.first->wallets.tx_begin_write (), keypair.pub);
1787  		node_wallet.second->insert_adhoc (keypair.prv);
1788  		auto block (wallet1.send_action (nano::dev::genesis_key.pub, keypair.pub, large_amount));
1789  		ASSERT_NE (nullptr, block);
1790  		genesis_blocks.push_back (block);
1791  	}
1792  	for (auto & node_wallet : nodes_wallets)
1793  	{
1794  		for (auto const & block : genesis_blocks)
1795  		{
1796  			auto process_result (node_wallet.first->process (*block));
1797  			ASSERT_TRUE (nano::process_result::progress == process_result.code || nano::process_result::old == process_result.code);
1798  		}
1799  		ASSERT_EQ (node1.latest (nano::dev::genesis_key.pub), node_wallet.first->latest (nano::dev::genesis_key.pub));
1800  		ASSERT_EQ (genesis_blocks.back ()->hash (), node_wallet.first->latest (nano::dev::genesis_key.pub));
1801  		nano::test::start_elections (system, *node_wallet.first, { genesis_blocks.back () }, true);
1802  	}
1803  	nano::test::start_elections (system, node1, { genesis_blocks.back () }, true);
1804  	auto all_received = [&nodes_wallets] () {
1805  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const & node_wallet) {
1806  			auto local_representative (node_wallet.second->store.representative (node_wallet.first->wallets.tx_begin_read ()));
1807  			return node_wallet.first->ledger.account_balance (node_wallet.first->store.tx_begin_read (), local_representative) > 0;
1808  		});
1809  	};
1810  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, all_received ());
1811  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.ledger.cache.block_count == 1 + 2 * nodes_wallets.size ());
1812  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.rep_crawler.principal_representatives ().size () == nodes_wallets.size ());
1813  	nano::state_block_builder builder;
1814  	std::shared_ptr<nano::state_block> block{};
1815  	{
1816  		auto transaction (node1.store.tx_begin_read ());
1817  		block = builder.make_block ()
1818  				.account (nano::dev::genesis_key.pub)
1819  				.representative (nano::dev::genesis_key.pub)
1820  				.previous (node1.ledger.latest (transaction, nano::dev::genesis_key.pub))
1821  				.balance (node1.ledger.account_balance (transaction, nano::dev::genesis_key.pub) - 1)
1822  				.link (nano::dev::genesis_key.pub)
1823  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  				.work (*node1.work_generate_blocking (node1.ledger.latest (transaction, nano::dev::genesis_key.pub)))
1825  				.build ();
1826  	}
1827  	ASSERT_EQ (nano::process_result::progress, node1.process_local (block).value ().code);
1828  	auto all_have_block = [&nodes_wallets] (nano::block_hash const & hash_a) {
1829  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [hash = hash_a] (auto const & node_wallet) {
1830  			return node_wallet.first->block (hash) != nullptr;
1831  		});
1832  	};
1833  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (block->hash ()));
1834  	auto wallet_block = wallet1.send_sync (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 10);
1835  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (wallet_block));
1836  	ASSERT_EQ (1 + 2 * nodes_wallets.size () + 2, node1.ledger.cache.block_count);
1837  }
1838  TEST (node, send_single_many_peers)
1839  {
1840  	nano::test::system system (nano::memory_intensive_instrumentation () ? 4 : 10);
1841  	nano::keypair key2;
1842  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1843  	system.wallet (1)->insert_adhoc (key2.prv);
1844  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
1845  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
1846  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
1847  	ASSERT_TIMELY (3.5min, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return !node_a->balance (key2.pub).is_zero (); }));
1848  	system.stop ();
1849  	for (auto node : system.nodes)
1850  	{
1851  		ASSERT_TRUE (node->stopped);
1852  	}
1853  }
1854  }
1855  TEST (node, wallet_create_block_confirm_conflicts)
1856  {
1857  	for (int i = 0; i < 5; ++i)
1858  	{
1859  		nano::test::system system;
1860  		nano::block_builder builder;
1861  		nano::node_config node_config (system.get_available_port (), system.logging);
1862  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1863  		auto node = system.add_node (node_config);
1864  		auto const num_blocks = 10000;
1865  		auto latest = nano::dev::genesis->hash ();
1866  		nano::keypair key1;
1867  		{
1868  			auto transaction = node->store.tx_begin_write ();
1869  			for (auto i = num_blocks - 1; i > 0; --i)
1870  			{
1871  				auto send = builder
1872  							.send ()
1873  							.previous (latest)
1874  							.destination (key1.pub)
1875  							.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
1876  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1877  							.work (*system.work.generate (latest))
1878  							.build ();
1879  				ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
1880  				latest = send->hash ();
1881  			}
1882  		}
1883  		std::atomic<bool> done{ false };
1884  		std::thread t ([node, &done] () {
1885  			while (!done)
1886  			{
1887  				node->wallets.create (nano::random_wallet_id ());
1888  			}
1889  		});
1890  		{
1891  			auto block = node->store.block.get (node->store.tx_begin_read (), latest);
1892  			node->scheduler.buckets.manual (block);
1893  			std::shared_ptr<nano::election> election;
1894  			ASSERT_TIMELY (10s, (election = node->active.election (block->qualified_root ())) != nullptr);
1895  			election->force_confirm ();
1896  		}
1897  		ASSERT_TIMELY (120s, node->ledger.block_confirmed (node->store.tx_begin_read (), latest) && node->confirmation_height_processor.current () == 0);
1898  		done = true;
1899  		t.join ();
1900  	}
1901  }
1902  namespace nano
1903  {
1904  TEST (system, block_sequence)
1905  {
1906  	size_t const block_count = 400;
1907  	size_t const pr_count = 4;
1908  	size_t const listeners_per_pr = 0;
1909  	nano::test::system system;
1910  	std::vector<nano::keypair> reps;
1911  	for (auto i = 0; i < pr_count; ++i)
1912  	{
1913  		reps.push_back (nano::keypair{});
1914  	}
1915  	system.ledger_initialization_set (reps, nano::Gxrb_ratio);
1916  	system.deadline_set (3600s);
1917  	nano::node_config config;
1918  	config.peering_port = system.get_available_port ();
1919  	config.enable_voting = true;
1920  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1921  	nano::node_flags flags;
1922  	flags.disable_max_peers_per_ip = true;
1923  	flags.disable_ongoing_bootstrap = true;
1924  	auto root = system.add_node (config, flags);
1925  	auto wallet = root->wallets.items.begin ()->second;
1926  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
1927  	for (auto rep : reps)
1928  	{
1929  		system.wallet (0);
<span onclick='openModal()' class='match'>1930  		config.peering_port = system.get_available_port ();
1931  		auto pr = system.add_node (config, flags, nano::transport::transport_type::tcp, rep);
1932  		for (auto j = 0; j < listeners_per_pr; ++j)
1933  		{
1934  			config.peering_port = system.get_available_port ();
</span>1935  			system.add_node (config, flags);
1936  		}
1937  		std::cerr << rep.pub.to_account () << ' ' << pr->wallets.items.begin ()->second->exists (rep.pub) << pr->weight (rep.pub) << ' ' << '\n';
1938  	}
1939  	while (std::any_of (system.nodes.begin (), system.nodes.end (), [] (std::shared_ptr<nano::node> const & node) {
1940  		return node->rep_crawler.representative_count () < 3;
1941  	}))
1942  	{
1943  		system.poll ();
1944  	}
1945  	for (auto & node : system.nodes)
1946  	{
1947  		std::cerr << std::to_string (node->network.port) << ": ";
1948  		auto prs = node->rep_crawler.principal_representatives ();
1949  		for (auto pr : prs)
1950  		{
1951  			std::cerr << pr.account.to_account () << ' ';
1952  		}
1953  		std::cerr << '\n';
1954  	}
1955  	nano::keypair key;
1956  	auto start = std::chrono::system_clock::now ();
1957  	std::deque<std::shared_ptr<nano::block>> blocks;
1958  	for (auto i = 0; i < block_count; ++i)
1959  	{
1960  		if ((i % 1000) == 0)
1961  		{
1962  			std::cerr << "Block: " << std::to_string (i) << " ms: " << std::to_string (std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now () - start).count ()) << "\n";
1963  		}
1964  		auto block = wallet->send_action (nano::dev::genesis_key.pub, key.pub, 1);
1965  		debug_assert (block != nullptr);
1966  		blocks.push_back (block);
1967  	}
1968  	auto done = false;
1969  	std::chrono::system_clock::time_point last;
1970  	auto interval = 1000ms;
1971  	while (!done)
1972  	{
1973  		if (std::chrono::system_clock::now () - last > interval)
1974  		{
1975  			std::string message;
1976  			for (auto i : system.nodes)
1977  			{
1978  				message += boost::str (boost::format ("N:%1% b:%2% c:%3% a:%4% s:%5% p:%6%\n") % std::to_string (i->network.port) % std::to_string (i->ledger.cache.block_count) % std::to_string (i->ledger.cache.cemented_count) % std::to_string (i->active.size ()) % std::to_string (i->scheduler.buckets.size ()) % std::to_string (i->network.size ()));
1979  				nano::lock_guard<nano::mutex> lock{ i->active.mutex };
1980  				for (auto const & j : i->active.roots)
1981  				{
1982  					auto election = j.election;
1983  					if (election->confirmation_request_count > 10)
1984  					{
1985  						message += boost::str (boost::format ("\t r:%1% i:%2%\n") % j.root.to_string () % std::to_string (election->confirmation_request_count));
1986  						for (auto const & k : election->votes ())
1987  						{
1988  							message += boost::str (boost::format ("\t\t r:%1% t:%2%\n") % k.first.to_account () % std::to_string (k.second.timestamp));
1989  						}
1990  					}
1991  				}
1992  			}
1993  			std::cerr << message << std::endl;
1994  			last = std::chrono::system_clock::now ();
1995  		}
1996  		done = std::all_of (system.nodes.begin (), system.nodes.end (), [&blocks] (std::shared_ptr<nano::node> node) { return node->block_confirmed (blocks.back ()->hash ()); });
1997  		system.poll ();
1998  	}
1999  }
2000  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</div>
                </div>
                <div class="column column_space"><pre><code>912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &part_box = part->bounding_box();
914      for (int i = 0; i < page_height; i++) {
915        table_region[i] = false;
</pre></code></div>
                <div class="column column_space"><pre><code>1930  		config.peering_port = system.get_available_port ();
1931  		auto pr = system.add_node (config, flags, nano::transport::transport_type::tcp, rep);
1932  		for (auto j = 0; j < listeners_per_pr; ++j)
1933  		{
1934  			config.peering_port = system.get_available_port ();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    