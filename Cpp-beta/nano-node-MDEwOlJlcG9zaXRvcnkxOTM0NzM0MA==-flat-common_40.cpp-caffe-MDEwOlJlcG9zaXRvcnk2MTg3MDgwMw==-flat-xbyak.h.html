
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.8685121107266434%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-common_40.cpp</h3>
            <pre><code>1  #include <nano/lib/blocks.hpp>
2  #include <nano/lib/memory.hpp>
3  #include <nano/node/active_transactions.hpp>
4  #include <nano/node/common.hpp>
5  #include <nano/node/election.hpp>
6  #include <nano/node/network.hpp>
7  #include <nano/node/wallet.hpp>
8  #include <nano/secure/buffer.hpp>
9  #include <boost/format.hpp>
10  uint64_t nano::ip_address_hash_raw (boost::asio::ip::address const & ip_a, uint16_t port)
11  {
12  	debug_assert (ip_a.is_v6 ());
13  	uint64_t result;
14  	nano::uint128_union address;
15  	address.bytes = ip_a.to_v6 ().to_bytes ();
16  	blake2b_state state;
17  	blake2b_init (&state, sizeof (result));
18  	blake2b_update (&state, nano::hardened_constants::get ().random_128.bytes.data (), nano::hardened_constants::get ().random_128.bytes.size ());
19  	if (port != 0)
20  	{
21  		blake2b_update (&state, &port, sizeof (port));
22  	}
23  	blake2b_update (&state, address.bytes.data (), address.bytes.size ());
24  	blake2b_final (&state, &result, sizeof (result));
25  	return result;
26  }
27  bool nano::parse_port (std::string const & string_a, uint16_t & port_a)
28  {
29  	bool result = false;
30  	try
31  	{
32  		port_a = boost::lexical_cast<uint16_t> (string_a);
33  	}
34  	catch (...)
35  	{
36  		result = true;
37  	}
38  	return result;
39  }
40  bool nano::parse_address (std::string const & address_text_a, boost::asio::ip::address & address_a)
41  {
42  	auto address_text = address_text_a;
43  	if (!address_text.empty () && address_text.front () == '[' && address_text.back () == ']')
44  	{
45  		address_text = address_text.substr (1, address_text.size () - 2);
<span onclick='openModal()' class='match'>46  	}
47  	boost::system::error_code address_ec;
48  	address_a = boost::asio::ip::make_address (address_text, address_ec);
49  	return !!address_ec;
50  }
51  bool nano::parse_address_port (std::string const & string, boost::asio::ip::address & address_a, uint16_t & port_a)
</span>52  {
53  	auto result (false);
54  	auto port_position (string.rfind (':'));
55  	if (port_position != std::string::npos && port_position > 0)
56  	{
57  		std::string port_string (string.substr (port_position + 1));
58  		try
59  		{
60  			uint16_t port;
61  			result = parse_port (port_string, port);
62  			if (!result)
63  			{
64  				boost::system::error_code ec;
65  				auto address (boost::asio::ip::make_address_v6 (string.substr (0, port_position), ec));
66  				if (!ec)
67  				{
68  					address_a = address;
69  					port_a = port;
70  				}
71  				else
72  				{
73  					result = true;
74  				}
75  			}
76  			else
77  			{
78  				result = true;
79  			}
80  		}
81  		catch (...)
82  		{
83  			result = true;
84  		}
85  	}
86  	else
87  	{
88  		result = true;
89  	}
90  	return result;
91  }
92  bool nano::parse_endpoint (std::string const & string, nano::endpoint & endpoint_a)
93  {
94  	boost::asio::ip::address address;
95  	uint16_t port;
96  	auto result (parse_address_port (string, address, port));
97  	if (!result)
98  	{
99  		endpoint_a = nano::endpoint (address, port);
100  	}
101  	return result;
102  }
103  std::optional<nano::endpoint> nano::parse_endpoint (const std::string & str)
104  {
105  	nano::endpoint endpoint;
106  	if (!parse_endpoint (str, endpoint))
107  	{
108  		return endpoint; 
109  	}
110  	return {};
111  }
112  bool nano::parse_tcp_endpoint (std::string const & string, nano::tcp_endpoint & endpoint_a)
113  {
114  	boost::asio::ip::address address;
115  	uint16_t port;
116  	auto result (parse_address_port (string, address, port));
117  	if (!result)
118  	{
119  		endpoint_a = nano::tcp_endpoint (address, port);
120  	}
121  	return result;
122  }
123  nano::node_singleton_memory_pool_purge_guard::node_singleton_memory_pool_purge_guard () :
124  	cleanup_guard ({ nano::block_memory_pool_purge, nano::purge_shared_ptr_singleton_pool_memory<nano::vote>, nano::purge_shared_ptr_singleton_pool_memory<nano::election> })
125  {
126  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-xbyak.h</h3>
            <pre><code>1  #pragma once
2  #ifndef XBYAK_XBYAK_H_
3  #define XBYAK_XBYAK_H_
4  #ifndef XBYAK_NO_OP_NAMES
5  	#if not +0 
6  		#error "use -fno-operator-names option if you want to use and(), or(), xor(), not() as function names, Or define XBYAK_NO_OP_NAMES and use and_(), or_(), xor_(), not_()."
7  	#endif
8  #endif
9  #include <stdio.h> 
10  #include <assert.h>
11  #include <list>
12  #include <string>
13  #include <algorithm>
14  #ifndef NDEBUG
15  #include <iostream>
16  #endif
17  #if !defined(__GNUC__) || defined(__MINGW32__)
18  	#undef XBYAK_USE_MMAP_ALLOCATOR
19  #endif
20  #if ((defined(_MSC_VER) && (_MSC_VER >= 1600)) || defined(_LIBCPP_VERSION) ||\
21  	 			 ((__cplusplus >= 201103) || defined(__GXX_EXPERIMENTAL_CXX0X__)))
22  	#include <unordered_map>
23  	#define XBYAK_STD_UNORDERED_MAP std::unordered_map
24  	#define XBYAK_STD_UNORDERED_MULTIMAP std::unordered_multimap
25  #elif defined(__GNUC__) && (__GNUC__ >= 4) && ((__GNUC_MINOR__ >= 5) || \
26  								 ((__GLIBCXX__ >= 20070719) && (__GNUC_MINOR__ >= 2) && \
27  									(defined(__INTEL_COMPILER) || defined(__llvm__))))
28  	#include <tr1/unordered_map>
29  	#define XBYAK_STD_UNORDERED_MAP std::tr1::unordered_map
30  	#define XBYAK_STD_UNORDERED_MULTIMAP std::tr1::unordered_multimap
31  #elif defined(_MSC_VER) && (_MSC_VER >= 1500) && (_MSC_VER < 1600)
32  	#include <unordered_map>
33  	#define XBYAK_STD_UNORDERED_MAP std::tr1::unordered_map
34  	#define XBYAK_STD_UNORDERED_MULTIMAP std::tr1::unordered_multimap
35  #else
36  	#include <map>
37  	#define XBYAK_STD_UNORDERED_MAP std::map
38  	#define XBYAK_STD_UNORDERED_MULTIMAP std::multimap
39  #endif
40  #ifdef _WIN32
41  	#include <windows.h>
42  	#include <malloc.h>
43  #elif defined(__GNUC__)
44  	#include <unistd.h>
45  	#include <sys/mman.h>
46  	#include <stdlib.h>
47  #endif
48  #if !defined(_MSC_VER) || (_MSC_VER >= 1600)
49  	#include <stdint.h>
50  #endif
51  #if defined(_WIN64) || defined(__MINGW64__) || (defined(__CYGWIN__) && defined(__x86_64__))
52  	#define XBYAK64_WIN
53  #elif defined(__x86_64__)
54  	#define XBYAK64_GCC
55  #endif
56  #if !defined(XBYAK64) && !defined(XBYAK32)
57  	#if defined(XBYAK64_GCC) || defined(XBYAK64_WIN)
58  		#define XBYAK64
59  	#else
60  		#define XBYAK32
61  	#endif
62  #endif
63  #if (__cplusplus >= 201103) || (_MSC_VER >= 1800)
64  	#define XBYAK_VARIADIC_TEMPLATE
65  #endif
66  #ifdef _MSC_VER
67  	#pragma warning(push)
68  	#pragma warning(disable : 4514) &bsol;* remove inline function */
69  	#pragma warning(disable : 4786) &bsol;* identifier is too long */
70  	#pragma warning(disable : 4503) &bsol;* name is too long */
71  	#pragma warning(disable : 4127) &bsol;* constant expresison */
72  #endif
73  namespace Xbyak {
74  #include "xbyak_bin2hex.h"
75  enum {
76  	DEFAULT_MAX_CODE_SIZE = 4096,
77  	VERSION = 0x4870 &bsol;* 0xABCD = A.BC(D) */
78  };
79  #ifndef MIE_INTEGER_TYPE_DEFINED
80  #define MIE_INTEGER_TYPE_DEFINED
81  #ifdef _MSC_VER
82  	typedef unsigned __int64 uint64;
83  	typedef __int64 sint64;
84  #else
85  	typedef uint64_t uint64;
86  	typedef int64_t sint64;
87  #endif
88  typedef unsigned int uint32;
89  typedef unsigned short uint16;
90  typedef unsigned char uint8;
91  #endif
92  #ifndef MIE_ALIGN
93  	#ifdef _MSC_VER
94  		#define MIE_ALIGN(x) __declspec(align(x))
95  	#else
96  		#define MIE_ALIGN(x) __attribute__((aligned(x)))
97  	#endif
98  #endif
99  #ifndef MIE_PACK 
100  	#define MIE_PACK(x, y, z, w) ((x) * 64 + (y) * 16 + (z) * 4 + (w))
101  #endif
102  enum {
103  	ERR_NONE = 0,
104  	ERR_BAD_ADDRESSING,
105  	ERR_CODE_IS_TOO_BIG,
106  	ERR_BAD_SCALE,
107  	ERR_ESP_CANT_BE_INDEX,
108  	ERR_BAD_COMBINATION,
109  	ERR_BAD_SIZE_OF_REGISTER,
110  	ERR_IMM_IS_TOO_BIG,
111  	ERR_BAD_ALIGN,
112  	ERR_LABEL_IS_REDEFINED,
113  	ERR_LABEL_IS_TOO_FAR,
114  	ERR_LABEL_IS_NOT_FOUND,
115  	ERR_CODE_ISNOT_COPYABLE,
116  	ERR_BAD_PARAMETER,
117  	ERR_CANT_PROTECT,
118  	ERR_CANT_USE_64BIT_DISP,
119  	ERR_OFFSET_IS_TOO_BIG,
120  	ERR_MEM_SIZE_IS_NOT_SPECIFIED,
121  	ERR_BAD_MEM_SIZE,
122  	ERR_BAD_ST_COMBINATION,
123  	ERR_OVER_LOCAL_LABEL, 
124  	ERR_UNDER_LOCAL_LABEL,
125  	ERR_CANT_ALLOC,
126  	ERR_ONLY_T_NEAR_IS_SUPPORTED_IN_AUTO_GROW,
127  	ERR_BAD_PROTECT_MODE,
128  	ERR_BAD_PNUM,
129  	ERR_BAD_TNUM,
130  	ERR_BAD_VSIB_ADDRESSING,
131  	ERR_CANT_CONVERT,
132  	ERR_LABEL_ISNOT_SET_BY_L,
133  	ERR_LABEL_IS_ALREADY_SET_BY_L,
134  	ERR_BAD_LABEL_STR,
135  	ERR_MUNMAP,
136  	ERR_INTERNAL
137  };
138  class Error : public std::exception {
139  	int err_;
140  public:
141  	explicit Error(int err) : err_(err)
142  	{
143  		if (err_ < 0 || err_ > ERR_INTERNAL) {
144  			fprintf(stderr, "bad err=%d in Xbyak::Error\n", err_);
145  			exit(1);
146  		}
147  	}
148  	operator int() const { return err_; }
149  	const char *what() const throw()
150  	{
151  		static const char *errTbl[] = {
152  			"none",
153  			"bad addressing",
154  			"code is too big",
155  			"bad scale",
156  			"esp can't be index",
157  			"bad combination",
158  			"bad size of register",
159  			"imm is too big",
160  			"bad align",
161  			"label is redefined",
162  			"label is too far",
163  			"label is not found",
164  			"code is not copyable",
165  			"bad parameter",
166  			"can't protect",
167  			"can't use 64bit disp(use (void*))",
168  			"offset is too big",
169  			"MEM size is not specified",
170  			"bad mem size",
171  			"bad st combination",
172  			"over local label",
173  			"under local label",
174  			"can't alloc",
175  			"T_SHORT is not supported in AutoGrow",
176  			"bad protect mode",
177  			"bad pNum",
178  			"bad tNum",
179  			"bad vsib addressing",
180  			"can't convert",
181  			"label is not set by L()",
182  			"label is already set by L()",
183  			"bad label string",
184  			"err munmap",
185  			"internal error",
186  		};
187  		assert((size_t)err_ < sizeof(errTbl) / sizeof(*errTbl));
188  		return errTbl[err_];
189  	}
190  };
191  inline const char *ConvertErrorToString(Error err)
192  {
193  	return err.what();
194  }
195  inline void *AlignedMalloc(size_t size, size_t alignment)
196  {
197  #ifdef __MINGW32__
198  	return __mingw_aligned_malloc(size, alignment);
199  #elif defined(_WIN32)
200  	return _aligned_malloc(size, alignment);
201  #else
202  	void *p;
203  	int ret = posix_memalign(&p, alignment, size);
204  	return (ret == 0) ? p : 0;
205  #endif
206  }
207  inline void AlignedFree(void *p)
208  {
209  #ifdef __MINGW32__
210  	__mingw_aligned_free(p);
211  #elif defined(_MSC_VER)
212  	_aligned_free(p);
213  #else
214  	free(p);
215  #endif
216  }
217  template<class To, class From>
218  inline const To CastTo(From p) throw()
219  {
220  	return (const To)(size_t)(p);
221  }
222  namespace inner {
223  static const size_t ALIGN_PAGE_SIZE = 4096;
224  inline bool IsInDisp8(uint32 x) { return 0xFFFFFF80 <= x || x <= 0x7F; }
225  inline bool IsInInt32(uint64 x) { return ~uint64(0x7fffffffu) <= x || x <= 0x7FFFFFFFU; }
226  inline uint32 VerifyInInt32(uint64 x)
227  {
228  #ifdef XBYAK64
229  	if (!IsInInt32(x)) throw Error(ERR_OFFSET_IS_TOO_BIG);
230  #endif
231  	return static_cast<uint32>(x);
232  }
233  enum LabelMode {
234  	LasIs, 
235  	Labs, 
236  	LaddTop 
237  };
238  } 
239  struct Allocator {
240  	virtual uint8 *alloc(size_t size) { return reinterpret_cast<uint8*>(AlignedMalloc(size, inner::ALIGN_PAGE_SIZE)); }
241  	virtual void free(uint8 *p) { AlignedFree(p); }
242  	virtual ~Allocator() {}
243  	virtual bool useProtect() const { return true; }
244  };
245  #ifdef XBYAK_USE_MMAP_ALLOCATOR
246  class MmapAllocator : Allocator {
247  	typedef XBYAK_STD_UNORDERED_MAP<uintptr_t, size_t> SizeList;
248  	SizeList sizeList_;
249  public:
250  	uint8 *alloc(size_t size)
251  	{
252  		const size_t alignedSizeM1 = inner::ALIGN_PAGE_SIZE - 1;
253  		size = (size + alignedSizeM1) & ~alignedSizeM1;
254  #ifdef MAP_ANONYMOUS
255  		const int mode = MAP_PRIVATE | MAP_ANONYMOUS;
256  #elif defined(MAP_ANON)
257  		const int mode = MAP_PRIVATE | MAP_ANON;
258  #else
259  		#error "not supported"
260  #endif
261  		void *p = mmap(NULL, size, PROT_READ | PROT_WRITE, mode, -1, 0);
262  		if (p == MAP_FAILED) throw Error(ERR_CANT_ALLOC);
263  		assert(p);
264  		sizeList_[(uintptr_t)p] = size;
265  		return (uint8*)p;
266  	}
267  	void free(uint8 *p)
268  	{
269  		if (p == 0) return;
270  		SizeList::iterator i = sizeList_.find((uintptr_t)p);
271  		if (i == sizeList_.end()) throw Error(ERR_BAD_PARAMETER);
272  		if (munmap((void*)i->first, i->second) < 0) throw Error(ERR_MUNMAP);
273  		sizeList_.erase(i);
274  	}
275  };
276  #endif
277  class Operand {
278  private:
279  	uint8 idx_; 
280  	uint8 kind_;
281  	uint16 bit_;
282  public:
283  	enum Kind {
284  		NONE = 0,
285  		MEM = 1 << 1,
286  		IMM = 1 << 2,
287  		REG = 1 << 3,
288  		MMX = 1 << 4,
289  		XMM = 1 << 5,
290  		FPU = 1 << 6,
291  		YMM = 1 << 7
292  	};
293  	enum Code {
294  #ifdef XBYAK64
295  		RAX = 0, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15,
296  		R8D = 8, R9D, R10D, R11D, R12D, R13D, R14D, R15D,
297  		R8W = 8, R9W, R10W, R11W, R12W, R13W, R14W, R15W,
298  		R8B = 8, R9B, R10B, R11B, R12B, R13B, R14B, R15B,
299  		SPL = 4, BPL, SIL, DIL,
300  #endif
301  		EAX = 0, ECX, EDX, EBX, ESP, EBP, ESI, EDI,
302  		AX = 0, CX, DX, BX, SP, BP, SI, DI,
303  		AL = 0, CL, DL, BL, AH, CH, DH, BH
304  	};
305  	Operand() : idx_(0), kind_(0), bit_(0) { }
306  	Operand(int idx, Kind kind, int bit, bool ext8bit = 0)
307  		: idx_(static_cast<uint8>(idx | (ext8bit ? 0x80 : 0)))
308  		, kind_(static_cast<uint8>(kind))
309  		, bit_(static_cast<uint16>(bit))
310  	{
311  		assert((bit_ & (bit_ - 1)) == 0); 
312  	}
313  	Kind getKind() const { return static_cast<Kind>(kind_); }
314  	int getIdx() const { return idx_ & 15; }
315  	bool isNone() const { return kind_ == 0; }
316  	bool isMMX() const { return is(MMX); }
317  	bool isXMM() const { return is(XMM); }
318  	bool isYMM() const { return is(YMM); }
319  	bool isREG(int bit = 0) const { return is(REG, bit); }
320  	bool isMEM(int bit = 0) const { return is(MEM, bit); }
321  	bool isFPU() const { return is(FPU); }
322  	bool isExt8bit() const { return (idx_ & 0x80) != 0; }
323  	bool isHigh8bit() const
324  	{
325  		if (!isBit(8)) return false;
<span onclick='openModal()' class='match'>326  		if (isExt8bit()) return false;
327  		const int idx = getIdx();
328  		return AH <= idx && idx <= BH;
329  	}
330  	bool is(int kind, uint32 bit = 0) const
</span>331  	{
332  		return (kind_ & kind) && (bit == 0 || (bit_ & bit)); 
333  	}
334  	bool isBit(uint32 bit) const { return (bit_ & bit) != 0; }
335  	uint32 getBit() const { return bit_; }
336  	const char *toString() const
337  	{
338  		const int idx = getIdx();
339  		if (kind_ == REG) {
340  			if (isExt8bit()) {
341  				static const char *tbl[4] = { "spl", "bpl", "sil", "dil" };
342  				return tbl[idx - 4];
343  			}
344  			static const char *tbl[4][16] = {
345  				{ "al", "cl", "dl", "bl", "ah", "ch", "dh", "bh", "r8b", "r9b", "r10b",  "r11b", "r12b", "r13b", "r14b", "r15b" },
346  				{ "ax", "cx", "dx", "bx", "sp", "bp", "si", "di", "r8w", "r9w", "r10w",  "r11w", "r12w", "r13w", "r14w", "r15w" },
347  				{ "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi", "r8d", "r9d", "r10d",  "r11d", "r12d", "r13d", "r14d", "r15d" },
348  				{ "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi", "r8", "r9", "r10",  "r11", "r12", "r13", "r14", "r15" },
349  			};
350  			return tbl[bit_ == 8 ? 0 : bit_ == 16 ? 1 : bit_ == 32 ? 2 : 3][idx];
351  		} else if (isYMM()) {
352  			static const char *tbl[16] = { "ym0", "ym1", "ym2", "ym3", "ym4", "ym5", "ym6", "ym7", "ym8", "ym9", "ym10", "ym11", "ym12", "ym13", "ym14", "ym15" };
353  			return tbl[idx];
354  		} else if (isXMM()) {
355  			static const char *tbl[16] = { "xm0", "xm1", "xm2", "xm3", "xm4", "xm5", "xm6", "xm7", "xm8", "xm9", "xm10", "xm11", "xm12", "xm13", "xm14", "xm15" };
356  			return tbl[idx];
357  		} else if (isMMX()) {
358  			static const char *tbl[8] = { "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7" };
359  			return tbl[idx];
360  		} else if (isFPU()) {
361  			static const char *tbl[8] = { "st0", "st1", "st2", "st3", "st4", "st5", "st6", "st7" };
362  			return tbl[idx];
363  		}
364  		throw Error(ERR_INTERNAL);
365  	}
366  	bool isSameNotInherited(const Operand& rhs) const { return idx_ == rhs.idx_ && kind_ == rhs.kind_ && bit_ == rhs.bit_; }
367  	bool operator==(const Operand& rhs) const;
368  	bool operator!=(const Operand& rhs) const { return !operator==(rhs); }
369  };
370  class Label;
371  struct Reg8;
372  struct Reg16;
373  struct Reg32;
374  #ifdef XBYAK64
375  struct Reg64;
376  #endif
377  class Reg : public Operand {
378  	bool hasRex() const { return isExt8bit() | isREG(64) | isExtIdx(); }
379  public:
380  	Reg() { }
381  	Reg(int idx, Kind kind, int bit = 0, bool ext8bit = false) : Operand(idx, kind, bit, ext8bit) { }
382  	Reg changeBit(int bit) const { return Reg(getIdx(), getKind(), bit, isExt8bit()); }
383  	bool isExtIdx() const { return getIdx() > 7; }
384  	uint8 getRex(const Reg& base = Reg()) const
385  	{
386  		return (hasRex() || base.hasRex()) ? uint8(0x40 | ((isREG(64) | base.isREG(64)) ? 8 : 0) | (isExtIdx() ? 4 : 0)| (base.isExtIdx() ? 1 : 0)) : 0;
387  	}
388  	Reg8 cvt8() const;
389  	Reg16 cvt16() const;
390  	Reg32 cvt32() const;
391  #ifdef XBYAK64
392  	Reg64 cvt64() const;
393  #endif
394  };
395  struct Reg8 : public Reg {
396  	explicit Reg8(int idx = 0, bool ext8bit = false) : Reg(idx, Operand::REG, 8, ext8bit) { }
397  };
398  struct Reg16 : public Reg {
399  	explicit Reg16(int idx = 0) : Reg(idx, Operand::REG, 16) { }
400  };
401  struct Mmx : public Reg {
402  	explicit Mmx(int idx = 0, Kind kind = Operand::MMX, int bit = 64) : Reg(idx, kind, bit) { }
403  };
404  struct Xmm : public Mmx {
405  	explicit Xmm(int idx = 0, Kind kind = Operand::XMM, int bit = 128) : Mmx(idx, kind, bit) { }
406  };
407  struct Ymm : public Xmm {
408  	explicit Ymm(int idx = 0) : Xmm(idx, Operand::YMM, 256) { }
409  };
410  struct Fpu : public Reg {
411  	explicit Fpu(int idx = 0) : Reg(idx, Operand::FPU, 32) { }
412  };
413  struct Reg32e : public Reg {
414  	explicit Reg32e(int idx, int bit) : Reg(idx, Operand::REG, bit) {}
415  };
416  struct Reg32 : public Reg32e {
417  	explicit Reg32(int idx = 0) : Reg32e(idx, 32) {}
418  };
419  #ifdef XBYAK64
420  struct Reg64 : public Reg32e {
421  	explicit Reg64(int idx = 0) : Reg32e(idx, 64) {}
422  };
423  struct RegRip {
424  	sint64 disp_;
425  	Label* label_;
426  	explicit RegRip(sint64 disp = 0, Label* label = 0) : disp_(disp), label_(label) {}
427  	friend const RegRip operator+(const RegRip& r, sint64 disp) {
428  		return RegRip(r.disp_ + disp, r.label_);
429  	}
430  	friend const RegRip operator-(const RegRip& r, sint64 disp) {
431  		return RegRip(r.disp_ - disp, r.label_);
432  	}
433  	friend const RegRip operator+(const RegRip& r, Label& label) {
434  		if (r.label_) throw Error(ERR_BAD_ADDRESSING);
435  		return RegRip(r.disp_, &label);
436  	}
437  };
438  #endif
439  inline Reg8 Reg::cvt8() const
440  {
441  	const int idx = getIdx();
442  	if (isBit(8)) return Reg8(idx, isExt8bit());
443  #ifdef XBYAK32
444  	if (idx >= 4) throw Error(ERR_CANT_CONVERT);
445  #endif
446  	return Reg8(idx, 4 <= idx && idx < 8);
447  }
448  inline Reg16 Reg::cvt16() const
449  {
450  	const int idx = getIdx();
451  	if (isBit(8) && (4 <= idx && idx < 8) && !isExt8bit()) throw Error(ERR_CANT_CONVERT);
452  	return Reg16(idx);
453  }
454  inline Reg32 Reg::cvt32() const
455  {
456  	const int idx = getIdx();
457  	if (isBit(8) && (4 <= idx && idx < 8) && !isExt8bit()) throw Error(ERR_CANT_CONVERT);
458  	return Reg32(idx);
459  }
460  #ifdef XBYAK64
461  inline Reg64 Reg::cvt64() const
462  {
463  	const int idx = getIdx();
464  	if (isBit(8) && (4 <= idx && idx < 8) && !isExt8bit()) throw Error(ERR_CANT_CONVERT);
465  	return Reg64(idx);
466  }
467  #endif
468  #ifndef XBYAK_DISABLE_SEGMENT
469  class Segment {
470  	int idx_;
471  public:
472  	enum {
473  		es, cs, ss, ds, fs, gs
474  	};
475  	Segment(int idx) : idx_(idx) { assert(0 <= idx_ && idx_ < 6); }
476  	int getIdx() const { return idx_; }
477  	const char *toString() const
478  	{
479  		static const char tbl[][3] = {
480  			"es", "cs", "ss", "ds", "fs", "gs"
481  		};
482  		return tbl[idx_];
483  	}
484  };
485  #endif
486  class RegExp {
487  public:
488  	struct SReg {
489  		uint16 bit:9; 
490  		uint16 idx:7;
491  		SReg() : bit(0), idx(0) { }
492  		void set(const Reg& r) { this->bit = uint16(r.getBit()); this->idx = uint16(r.getIdx()); }
493  		bool operator==(const SReg& rhs) const { return bit == rhs.bit && idx == rhs.idx; }
494  	};
495  	RegExp(size_t disp = 0) : disp_(disp), scale_(0) { }
496  	RegExp(const Reg& r, int scale = 1)
497  		: disp_(0)
498  		, scale_(scale)
499  	{
500  		if (!r.is(Reg::REG, 32|64) && !r.is(Reg::XMM|Reg::YMM)) throw Error(ERR_BAD_SIZE_OF_REGISTER);
501  		if (scale != 1 && scale != 2 && scale != 4 && scale != 8) throw Error(ERR_BAD_SCALE);
502  		if (r.getBit() >= 128 || scale != 1) { 
503  			index_.set(r);
504  		} else {
505  			base_.set(r);
506  		}
507  	}
508  	bool isVsib() const { return index_.bit >= 128; }
509  	bool isYMM() const { return index_.bit >= 256; }
510  	RegExp optimize() const 
511  	{
512  		if (!isVsib() && !base_.bit && index_.bit && scale_ == 2) {
513  			RegExp ret = *this;
514  			ret.base_ = index_;
515  			ret.scale_ = 1;
516  			return ret;
517  		}
518  		return *this;
519  	}
520  	bool operator==(const RegExp& rhs) const
521  	{
522  		return base_ == rhs.base_ && index_ == rhs.index_ && disp_ == rhs.disp_;
523  	}
524  	const SReg& getBase() const { return base_; }
525  	const SReg& getIndex() const { return index_; }
526  	int getScale() const { return scale_; }
527  	uint32 getDisp() const { return uint32(disp_); }
528  	void verify() const
529  	{
530  		if (base_.bit >= 128) throw Error(ERR_BAD_SIZE_OF_REGISTER);
531  		if (index_.bit && index_.bit <= 64) {
532  			if (index_.idx == Operand::ESP) throw Error(ERR_ESP_CANT_BE_INDEX);
533  			if (base_.bit && base_.bit != index_.bit) throw Error(ERR_BAD_SIZE_OF_REGISTER);
534  		}
535  	}
536  private:
537  	friend RegExp operator+(const RegExp& a, const RegExp& b);
538  	friend RegExp operator-(const RegExp& e, size_t disp);
539  	size_t disp_;
540  	int scale_;
541  	SReg base_;
542  	SReg index_;
543  };
544  inline RegExp operator+(const RegExp& a, const RegExp& b)
545  {
546  	if (a.index_.bit && b.index_.bit) throw Error(ERR_BAD_ADDRESSING);
547  	RegExp ret = a;
548  	if (!ret.index_.bit) { ret.index_ = b.index_; ret.scale_ = b.scale_; }
549  	if (b.base_.bit) {
550  		if (ret.base_.bit) {
551  			if (ret.index_.bit) throw Error(ERR_BAD_ADDRESSING);
552  			ret.index_ = b.base_;
553  			if (ret.index_.idx == Operand::ESP) std::swap(ret.base_, ret.index_);
554  			ret.scale_ = 1;
555  		} else {
556  			ret.base_ = b.base_;
557  		}
558  	}
559  	ret.disp_ += b.disp_;
560  	return ret;
561  }
562  inline RegExp operator*(const Reg& r, int scale)
563  {
564  	return RegExp(r, scale);
565  }
566  inline RegExp operator-(const RegExp& e, size_t disp)
567  {
568  	RegExp ret = e;
569  	ret.disp_ -= disp;
570  	return ret;
571  }
572  void *const AutoGrow = (void*)1;
573  class CodeArray {
574  	enum Type {
575  		USER_BUF = 1, 
576  		ALLOC_BUF, 
577  		AUTO_GROW 
578  	};
579  	CodeArray(const CodeArray& rhs);
580  	void operator=(const CodeArray&);
581  	bool isAllocType() const { return type_ == ALLOC_BUF || type_ == AUTO_GROW; }
582  	struct AddrInfo {
583  		size_t codeOffset; 
584  		size_t jmpAddr; 
585  		int jmpSize; 
586  		inner::LabelMode mode;
587  		AddrInfo(size_t _codeOffset, size_t _jmpAddr, int _jmpSize, inner::LabelMode _mode)
588  			: codeOffset(_codeOffset), jmpAddr(_jmpAddr), jmpSize(_jmpSize), mode(_mode) {}
589  		uint64 getVal(const uint8 *top) const
590  		{
591  			uint64 disp = (mode == inner::LaddTop) ? jmpAddr + size_t(top) : (mode == inner::LasIs) ? jmpAddr : jmpAddr - size_t(top);
592  			if (jmpSize == 4) disp = inner::VerifyInInt32(disp);
593  			return disp;
594  		}
595  	};
596  	typedef std::list<AddrInfo> AddrInfoList;
597  	AddrInfoList addrInfoList_;
598  	const Type type_;
599  #ifdef XBYAK_USE_MMAP_ALLOCATOR
600  	MmapAllocator defaultAllocator_;
601  #else
602  	Allocator defaultAllocator_;
603  #endif
604  	Allocator *alloc_;
605  protected:
606  	size_t maxSize_;
607  	uint8 *top_;
608  	size_t size_;
609  	void growMemory()
610  	{
611  		const size_t newSize = (std::max<size_t>)(DEFAULT_MAX_CODE_SIZE, maxSize_ * 2);
612  		uint8 *newTop = alloc_->alloc(newSize);
613  		if (newTop == 0) throw Error(ERR_CANT_ALLOC);
614  		for (size_t i = 0; i < size_; i++) newTop[i] = top_[i];
615  		alloc_->free(top_);
616  		top_ = newTop;
617  		maxSize_ = newSize;
618  	}
619  	void calcJmpAddress()
620  	{
621  		for (AddrInfoList::const_iterator i = addrInfoList_.begin(), ie = addrInfoList_.end(); i != ie; ++i) {
622  			uint64 disp = i->getVal(top_);
623  			rewrite(i->codeOffset, disp, i->jmpSize);
624  		}
625  		if (alloc_->useProtect() && !protect(top_, size_, true)) throw Error(ERR_CANT_PROTECT);
626  	}
627  public:
628  	explicit CodeArray(size_t maxSize, void *userPtr = 0, Allocator *allocator = 0)
629  		: type_(userPtr == AutoGrow ? AUTO_GROW : userPtr ? USER_BUF : ALLOC_BUF)
630  		, alloc_(allocator ? allocator : (Allocator*)&defaultAllocator_)
631  		, maxSize_(maxSize)
632  		, top_(type_ == USER_BUF ? reinterpret_cast<uint8*>(userPtr) : alloc_->alloc((std::max<size_t>)(maxSize, 1)))
633  		, size_(0)
634  	{
635  		if (maxSize_ > 0 && top_ == 0) throw Error(ERR_CANT_ALLOC);
636  		if ((type_ == ALLOC_BUF && alloc_->useProtect()) && !protect(top_, maxSize, true)) {
637  			alloc_->free(top_);
638  			throw Error(ERR_CANT_PROTECT);
639  		}
640  	}
641  	virtual ~CodeArray()
642  	{
643  		if (isAllocType()) {
644  			if (alloc_->useProtect()) protect(top_, maxSize_, false);
645  			alloc_->free(top_);
646  		}
647  	}
648  	void resetSize()
649  	{
650  		size_ = 0;
651  		addrInfoList_.clear();
652  	}
653  	void db(int code)
654  	{
655  		if (size_ >= maxSize_) {
656  			if (type_ == AUTO_GROW) {
657  				growMemory();
658  			} else {
659  				throw Error(ERR_CODE_IS_TOO_BIG);
660  			}
661  		}
662  		top_[size_++] = static_cast<uint8>(code);
663  	}
664  	void db(const uint8 *code, int codeSize)
665  	{
666  		for (int i = 0; i < codeSize; i++) db(code[i]);
667  	}
668  	void db(uint64 code, int codeSize)
669  	{
670  		if (codeSize > 8) throw Error(ERR_BAD_PARAMETER);
671  		for (int i = 0; i < codeSize; i++) db(static_cast<uint8>(code >> (i * 8)));
672  	}
673  	void dw(uint32 code) { db(code, 2); }
674  	void dd(uint32 code) { db(code, 4); }
675  	void dq(uint64 code) { db(code, 8); }
676  	const uint8 *getCode() const { return top_; }
677  	template<class F>
678  	const F getCode() const { return CastTo<F>(top_); }
679  	const uint8 *getCurr() const { return &top_[size_]; }
680  	template<class F>
681  	const F getCurr() const { return CastTo<F>(&top_[size_]); }
682  	size_t getSize() const { return size_; }
683  	void setSize(size_t size)
684  	{
685  		if (size > maxSize_) throw Error(ERR_OFFSET_IS_TOO_BIG);
686  		size_ = size;
687  	}
688  	void dump() const
689  	{
690  		const uint8 *p = getCode();
691  		size_t bufSize = getSize();
692  		size_t remain = bufSize;
693  		for (int i = 0; i < 4; i++) {
694  			size_t disp = 16;
695  			if (remain < 16) {
696  				disp = remain;
697  			}
698  			for (size_t j = 0; j < 16; j++) {
699  				if (j < disp) {
700  					printf("%02X", p[i * 16 + j]);
701  				}
702  			}
703  			putchar('\n');
704  			remain -= disp;
705  			if (remain <= 0) {
706  				break;
707  			}
708  		}
709  	}
710  	void rewrite(size_t offset, uint64 disp, size_t size)
711  	{
712  		assert(offset < maxSize_);
713  		if (size != 1 && size != 2 && size != 4 && size != 8) throw Error(ERR_BAD_PARAMETER);
714  		uint8 *const data = top_ + offset;
715  		for (size_t i = 0; i < size; i++) {
716  			data[i] = static_cast<uint8>(disp >> (i * 8));
717  		}
718  	}
719  	void save(size_t offset, size_t val, int size, inner::LabelMode mode)
720  	{
721  		addrInfoList_.push_back(AddrInfo(offset, val, size, mode));
722  	}
723  	bool isAutoGrow() const { return type_ == AUTO_GROW; }
724  	static inline bool protect(const void *addr, size_t size, bool canExec)
725  	{
726  #if defined(_WIN32)
727  		DWORD oldProtect;
728  		return VirtualProtect(const_cast<void*>(addr), size, canExec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE, &oldProtect) != 0;
729  #elif defined(__GNUC__)
730  		size_t pageSize = sysconf(_SC_PAGESIZE);
731  		size_t iaddr = reinterpret_cast<size_t>(addr);
732  		size_t roundAddr = iaddr & ~(pageSize - static_cast<size_t>(1));
733  		int mode = PROT_READ | PROT_WRITE | (canExec ? PROT_EXEC : 0);
734  		return mprotect(reinterpret_cast<void*>(roundAddr), size + (iaddr - roundAddr), mode) == 0;
735  #else
736  		return true;
737  #endif
738  	}
739  	static inline uint8 *getAlignedAddress(uint8 *addr, size_t alignedSize = 16)
740  	{
741  		return reinterpret_cast<uint8*>((reinterpret_cast<size_t>(addr) + alignedSize - 1) & ~(alignedSize - static_cast<size_t>(1)));
742  	}
743  };
744  class Address : public Operand {
745  	mutable uint8 top_[6]; 
746  	uint8 size_;
747  	uint8 rex_;
748  	size_t disp_;
749  	const Label* label_;
750  	bool isOnlyDisp_;
751  	bool is64bitDisp_;
752  	bool is32bit_;
753  	mutable bool isVsib_;
754  	bool isYMM_;
755  	void verify() const { if (isVsib_) throw Error(ERR_BAD_VSIB_ADDRESSING); }
756  public:
757  	Address(uint32 sizeBit, bool isOnlyDisp, size_t disp, bool is32bit, bool is64bitDisp = false, bool isVsib = false, bool isYMM = false)
758  		: Operand(0, MEM, sizeBit)
759  		, size_(0)
760  		, rex_(0)
761  		, disp_(disp)
762  		, label_(0)
763  		, isOnlyDisp_(isOnlyDisp)
764  		, is64bitDisp_(is64bitDisp)
765  		, is32bit_(is32bit)
766  		, isVsib_(isVsib)
767  		, isYMM_(isYMM)
768  	{
769  	}
770  	void db(int code)
771  	{
772  		if (size_ >= sizeof(top_)) throw Error(ERR_CODE_IS_TOO_BIG);
773  		top_[size_++] = static_cast<uint8>(code);
774  	}
775  	void dd(uint32 code) { for (int i = 0; i < 4; i++) db(code >> (i * 8)); }
776  	const uint8 *getCode() const { return top_; }
777  	size_t getSize() const { return size_; }
778  	void updateRegField(uint8 regIdx) const
779  	{
780  		*top_ = (*top_ & B11000111) | ((regIdx << 3) & B00111000);
781  	}
782  	void setVsib(bool isVsib) const { isVsib_ = isVsib; }
783  	bool isVsib() const { return isVsib_; }
784  	bool isYMM() const { return isYMM_; }
785  	bool is32bit() const { verify(); return is32bit_; }
786  	bool isOnlyDisp() const { verify(); return isOnlyDisp_; } 
787  	size_t getDisp() const { verify(); return disp_; }
788  	uint8 getRex() const { verify(); return rex_; }
789  	bool is64bitDisp() const { verify(); return is64bitDisp_; } 
790  	void setRex(uint8 rex) { rex_ = rex; }
791  	void setLabel(const Label* label) { label_ = label; }
792  	const Label* getLabel() const { return label_; }
793  	bool operator==(const Address& rhs) const
794  	{
795  		return getBit() == rhs.getBit() && size_ == rhs.size_ && rex_ == rhs.rex_ && disp_ == rhs.disp_ && label_ == rhs.label_ && isOnlyDisp_ == rhs.isOnlyDisp_
796  			&& is64bitDisp_ == rhs.is64bitDisp_ && is32bit_ == rhs.is32bit_ && isVsib_ == rhs.isVsib_ && isYMM_ == rhs.isYMM_;
797  	}
798  	bool operator!=(const Address& rhs) const { return !operator==(rhs); }
799  };
800  inline bool Operand::operator==(const Operand& rhs) const
801  {
802  	if (isMEM() && rhs.isMEM()) return static_cast<const Address&>(*this) == static_cast<const Address&>(rhs);
803  	return isSameNotInherited(rhs);
804  }
805  class AddressFrame {
806  private:
807  	void operator=(const AddressFrame&);
808  	Address makeAddress(const RegExp& e) const
809  	{
810  		e.verify();
811  		const bool isVsib = e.isVsib();
812  		const bool isYMM = e.isYMM();
813  		const RegExp::SReg& base = e.getBase();
814  		const RegExp::SReg& index = e.getIndex();
815  		const uint32 disp = e.getDisp();
816  		Address frame(bit_, (!base.bit && !index.bit), disp, base.bit == 32 || index.bit == 32, false, isVsib, isYMM);
817  		enum {
818  			mod00 = 0, mod01 = 1, mod10 = 2
819  		};
820  		int mod;
821  		if (!base.bit || ((base.idx & 7) != Operand::EBP && disp == 0)) {
822  			mod = mod00;
823  		} else if (inner::IsInDisp8(disp)) {
824  			mod = mod01;
825  		} else {
826  			mod = mod10;
827  		}
828  		const int baseIdx = base.bit ? (base.idx & 7) : Operand::EBP;
829  		bool hasSIB = index.bit || (base.idx & 7) == Operand::ESP;
830  #ifdef XBYAK64
831  		if (!base.bit && !index.bit) hasSIB = true;
832  #endif
833  		if (hasSIB) {
834  			frame.db((mod << 6) | Operand::ESP);
835  			const int indexIdx = index.bit ? (index.idx & 7) : Operand::ESP;
836  			const int scale = e.getScale();
837  			const int ss = (scale == 8) ? 3 : (scale == 4) ? 2 : (scale == 2) ? 1 : 0;
838  			frame.db((ss << 6) | (indexIdx << 3) | baseIdx);
839  		} else {
840  			frame.db((mod << 6) | baseIdx);
841  		}
842  		if (mod == mod01) {
843  			frame.db(disp);
844  		} else if (mod == mod10 || (mod == mod00 && !base.bit)) {
845  			frame.dd(disp);
846  		}
847  		int rex = ((index.idx >> 3) << 1) | (base.idx >> 3);
848  		if (rex) rex |= 0x40;
849  		frame.setRex(uint8(rex));
850  		return frame;
851  	}
852  public:
853  	const uint32 bit_;
854  	explicit AddressFrame(uint32 bit) : bit_(bit) { }
855  	Address operator[](const void *disp) const
856  	{
857  		size_t adr = reinterpret_cast<size_t>(disp);
858  #ifdef XBYAK64
859  		if (adr > 0xFFFFFFFFU) throw Error(ERR_OFFSET_IS_TOO_BIG);
860  #endif
861  		RegExp e(static_cast<uint32>(adr));
862  		return operator[](e);
863  	}
864  #ifdef XBYAK64
865  	Address operator[](uint64 disp) const
866  	{
867  		return Address(64, true, disp, false, true);
868  	}
869  	Address operator[](const RegRip& addr) const
870  	{
871  		Address frame(bit_, true, addr.disp_, false);
872  		frame.db(0x05);
873  		if (addr.label_) {
874  			frame.setLabel(addr.label_);
875  		} else {
876  			frame.dd(inner::VerifyInInt32(addr.disp_));
877  		}
878  		return frame;
879  	}
880  #endif
881  	Address operator[](const RegExp& e) const
882  	{
883  		return makeAddress(e.optimize());
884  	}
885  };
886  struct JmpLabel {
887  	size_t endOfJmp; &bsol;* offset from top to the end address of jmp */
888  	int jmpSize;
889  	inner::LabelMode mode;
890  	size_t disp; 
891  	explicit JmpLabel(size_t endOfJmp = 0, int jmpSize = 0, inner::LabelMode mode = inner::LasIs, size_t disp = 0)
892  		: endOfJmp(endOfJmp), jmpSize(jmpSize), mode(mode), disp(disp)
893  	{
894  	}
895  };
896  class LabelManager;
897  class Label {
898  	mutable LabelManager *mgr;
899  	mutable int id;
900  	friend class LabelManager;
901  public:
902  	Label() : mgr(0), id(0) {}
903  	Label(const Label& rhs);
904  	Label& operator=(const Label& rhs);
905  	~Label();
906  	int getId() const { return id; }
907  	static std::string toStr(int num)
908  	{
909  		char buf[16];
910  #ifdef _MSC_VER
911  		_snprintf_s
912  #else
913  		snprintf
914  #endif
915  		(buf, sizeof(buf), ".%08x", num);
916  		return buf;
917  	}
918  };
919  class LabelManager {
920  	struct SlabelVal {
921  		size_t offset;
922  		SlabelVal(size_t offset) : offset(offset) {}
923  	};
924  	typedef XBYAK_STD_UNORDERED_MAP<std::string, SlabelVal> SlabelDefList;
925  	typedef XBYAK_STD_UNORDERED_MULTIMAP<std::string, const JmpLabel> SlabelUndefList;
926  	struct SlabelState {
927  		SlabelDefList defList;
928  		SlabelUndefList undefList;
929  	};
930  	typedef std::list<SlabelState> StateList;
931  	struct ClabelVal {
932  		ClabelVal(size_t offset = 0) : offset(offset), refCount(1) {}
933  		size_t offset;
934  		int refCount;
935  	};
936  	typedef XBYAK_STD_UNORDERED_MAP<int, ClabelVal> ClabelDefList;
937  	typedef XBYAK_STD_UNORDERED_MULTIMAP<int, const JmpLabel> ClabelUndefList;
938  	CodeArray *base_;
939  	StateList stateList_;
940  	mutable int labelId_;
941  	ClabelDefList clabelDefList_;
942  	ClabelUndefList clabelUndefList_;
943  	int getId(const Label& label) const
944  	{
945  		if (label.id == 0) label.id = labelId_++;
946  		return label.id;
947  	}
948  	template<class DefList, class UndefList, class T>
949  	void define_inner(DefList& defList, UndefList& undefList, const T& labelId, size_t addrOffset)
950  	{
951  		typename DefList::value_type item(labelId, addrOffset);
952  		std::pair<typename DefList::iterator, bool> ret = defList.insert(item);
953  		if (!ret.second) throw Error(ERR_LABEL_IS_REDEFINED);
954  		for (;;) {
955  			typename UndefList::iterator itr = undefList.find(labelId);
956  			if (itr == undefList.end()) break;
957  			const JmpLabel *jmp = &itr->second;
958  			const size_t offset = jmp->endOfJmp - jmp->jmpSize;
959  			size_t disp;
960  			if (jmp->mode == inner::LaddTop) {
961  				disp = addrOffset;
962  			} else if (jmp->mode == inner::Labs) {
963  				disp = size_t(base_->getCurr());
964  			} else {
965  				disp = addrOffset - jmp->endOfJmp + jmp->disp;
966  #ifdef XBYAK64
967  				if (jmp->jmpSize <= 4 && !inner::IsInInt32(disp)) throw Error(ERR_OFFSET_IS_TOO_BIG);
968  #endif
969  				if (jmp->jmpSize == 1 && !inner::IsInDisp8((uint32)disp)) throw Error(ERR_LABEL_IS_TOO_FAR);
970  			}
971  			if (base_->isAutoGrow()) {
972  				base_->save(offset, disp, jmp->jmpSize, jmp->mode);
973  			} else {
974  				base_->rewrite(offset, disp, jmp->jmpSize);
975  			}
976  			undefList.erase(itr);
977  		}
978  	}
979  	template<class DefList, class T>
980  	bool getOffset_inner(const DefList& defList, size_t *offset, const T& label) const
981  	{
982  		typename DefList::const_iterator i = defList.find(label);
983  		if (i == defList.end()) return false;
984  		*offset = i->second.offset;
985  		return true;
986  	}
987  	friend class Label;
988  	void incRefCount(int id) { clabelDefList_[id].refCount++; }
989  	void decRefCount(int id)
990  	{
991  		ClabelDefList::iterator i = clabelDefList_.find(id);
992  		if (i == clabelDefList_.end()) return;
993  		if (i->second.refCount == 1) {
994  			clabelDefList_.erase(id);
995  		} else {
996  			--i->second.refCount;
997  		}
998  	}
999  	template<class T>
1000  	bool hasUndefinedLabel_inner(const T& list) const
1001  	{
1002  #ifndef NDEBUG
1003  		for (typename T::const_iterator i = list.begin(); i != list.end(); ++i) {
1004  			std::cerr << "undefined label:" << i->first << std::endl;
1005  		}
1006  #endif
1007  		return !list.empty();
1008  	}
1009  public:
1010  	LabelManager()
1011  	{
1012  		reset();
1013  	}
1014  	void reset()
1015  	{
1016  		base_ = 0;
1017  		labelId_ = 1;
1018  		stateList_.clear();
1019  		stateList_.push_back(SlabelState());
1020  		stateList_.push_back(SlabelState());
1021  		clabelDefList_.clear();
1022  		clabelUndefList_.clear();
1023  	}
1024  	void enterLocal()
1025  	{
1026  		stateList_.push_back(SlabelState());
1027  	}
1028  	void leaveLocal()
1029  	{
1030  		if (stateList_.size() <= 2) throw Error(ERR_UNDER_LOCAL_LABEL);
1031  		if (hasUndefinedLabel_inner(stateList_.back().undefList)) throw Error(ERR_LABEL_IS_NOT_FOUND);
1032  		stateList_.pop_back();
1033  	}
1034  	void set(CodeArray *base) { base_ = base; }
1035  	void defineSlabel(std::string label)
1036  	{
1037  		if (label == "@b" || label == "@f") throw Error(ERR_BAD_LABEL_STR);
1038  		if (label == "@@") {
1039  			SlabelDefList& defList = stateList_.front().defList;
1040  			SlabelDefList::iterator i = defList.find("@f");
1041  			if (i != defList.end()) {
1042  				defList.erase(i);
1043  				label = "@b";
1044  			} else {
1045  				i = defList.find("@b");
1046  				if (i != defList.end()) {
1047  					defList.erase(i);
1048  				}
1049  				label = "@f";
1050  			}
1051  		}
1052  		SlabelState& st = *label.c_str() == '.' ? stateList_.back() : stateList_.front();
1053  		define_inner(st.defList, st.undefList, label, base_->getSize());
1054  	}
1055  	void defineClabel(const Label& label)
1056  	{
1057  		define_inner(clabelDefList_, clabelUndefList_, getId(label), base_->getSize());
1058  		label.mgr = this;
1059  	}
1060  	void assign(Label& dst, const Label& src)
1061  	{
1062  		ClabelDefList::const_iterator i = clabelDefList_.find(src.id);
1063  		if (i == clabelDefList_.end()) throw Error(ERR_LABEL_ISNOT_SET_BY_L);
1064  		define_inner(clabelDefList_, clabelUndefList_, dst.id, i->second.offset);
1065  		dst.mgr = this;
1066  	}
1067  	bool getOffset(size_t *offset, std::string& label) const
1068  	{
1069  		const SlabelDefList& defList = stateList_.front().defList;
1070  		if (label == "@b") {
1071  			if (defList.find("@f") != defList.end()) {
1072  				label = "@f";
1073  			} else if (defList.find("@b") == defList.end()) {
1074  				throw Error(ERR_LABEL_IS_NOT_FOUND);
1075  			}
1076  		} else if (label == "@f") {
1077  			if (defList.find("@f") != defList.end()) {
1078  				label = "@b";
1079  			}
1080  		}
1081  		const SlabelState& st = *label.c_str() == '.' ? stateList_.back() : stateList_.front();
1082  		return getOffset_inner(st.defList, offset, label);
1083  	}
1084  	bool getOffset(size_t *offset, const Label& label) const
1085  	{
1086  		return getOffset_inner(clabelDefList_, offset, getId(label));
1087  	}
1088  	void addUndefinedLabel(const std::string& label, const JmpLabel& jmp)
1089  	{
1090  		SlabelState& st = *label.c_str() == '.' ? stateList_.back() : stateList_.front();
1091  		st.undefList.insert(SlabelUndefList::value_type(label, jmp));
1092  	}
1093  	void addUndefinedLabel(const Label& label, const JmpLabel& jmp)
1094  	{
1095  		clabelUndefList_.insert(ClabelUndefList::value_type(label.id, jmp));
1096  	}
1097  	bool hasUndefSlabel() const
1098  	{
1099  		for (StateList::const_iterator i = stateList_.begin(), ie = stateList_.end(); i != ie; ++i) {
1100  			if (hasUndefinedLabel_inner(i->undefList)) return true;
1101  		}
1102  		return false;
1103  	}
1104  	bool hasUndefClabel() const { return hasUndefinedLabel_inner(clabelUndefList_); }
1105  };
1106  inline Label::Label(const Label& rhs)
1107  {
1108  	id = rhs.id;
1109  	mgr = rhs.mgr;
1110  	if (mgr) mgr->incRefCount(id);
1111  }
1112  inline Label& Label::operator=(const Label& rhs)
1113  {
1114  	if (id) throw Error(ERR_LABEL_IS_ALREADY_SET_BY_L);
1115  	id = rhs.id;
1116  	mgr = rhs.mgr;
1117  	if (mgr) mgr->incRefCount(id);
1118  	return *this;
1119  }
1120  inline Label::~Label()
1121  {
1122  	if (id && mgr) mgr->decRefCount(id);
1123  }
1124  class CodeGenerator : public CodeArray {
1125  public:
1126  	enum LabelType {
1127  		T_SHORT,
1128  		T_NEAR,
1129  		T_AUTO 
1130  	};
1131  private:
1132  	CodeGenerator operator=(const CodeGenerator&); 
1133  #ifdef XBYAK64
1134  	enum { i32e = 32 | 64, BIT = 64 };
1135  	static const size_t dummyAddr = (size_t(0x11223344) << 32) | 55667788;
1136  	typedef Reg64 NativeReg;
1137  #else
1138  	enum { i32e = 32, BIT = 32 };
1139  	static const size_t dummyAddr = 0x12345678;
1140  	typedef Reg32 NativeReg;
1141  #endif
1142  	static inline bool isXMM_XMMorMEM(const Operand& op1, const Operand& op2)
1143  	{
1144  		return op1.isXMM() && (op2.isXMM() || op2.isMEM());
1145  	}
1146  	static inline bool isXMMorMMX_MEM(const Operand& op1, const Operand& op2)
1147  	{
1148  		return (op1.isMMX() && (op2.isMMX() || op2.isMEM())) || isXMM_XMMorMEM(op1, op2);
1149  	}
1150  	static inline bool isXMM_MMXorMEM(const Operand& op1, const Operand& op2)
1151  	{
1152  		return op1.isXMM() && (op2.isMMX() || op2.isMEM());
1153  	}
1154  	static inline bool isMMX_XMMorMEM(const Operand& op1, const Operand& op2)
1155  	{
1156  		return op1.isMMX() && (op2.isXMM() || op2.isMEM());
1157  	}
1158  	static inline bool isXMM_REG32orMEM(const Operand& op1, const Operand& op2)
1159  	{
1160  		return op1.isXMM() && (op2.isREG(i32e) || op2.isMEM());
1161  	}
1162  	static inline bool isREG32_XMMorMEM(const Operand& op1, const Operand& op2)
1163  	{
1164  		return op1.isREG(i32e) && (op2.isXMM() || op2.isMEM());
1165  	}
1166  	static inline bool isREG32_REG32orMEM(const Operand& op1, const Operand& op2)
1167  	{
1168  		return op1.isREG(i32e) && ((op2.isREG(i32e) && op1.getBit() == op2.getBit()) || op2.isMEM());
1169  	}
1170  	void rex(const Operand& op1, const Operand& op2 = Operand())
1171  	{
1172  		uint8 rex = 0;
1173  		const Operand *p1 = &op1, *p2 = &op2;
1174  		if (p1->isMEM()) std::swap(p1, p2);
1175  		if (p1->isMEM()) throw Error(ERR_BAD_COMBINATION);
1176  		if (p2->isMEM()) {
1177  			const Address& addr = static_cast<const Address&>(*p2);
1178  			if (BIT == 64 && addr.is32bit()) db(0x67);
1179  			rex = addr.getRex() | static_cast<const Reg&>(*p1).getRex();
1180  		} else {
1181  			rex = static_cast<const Reg&>(op2).getRex(static_cast<const Reg&>(op1));
1182  		}
1183  		if ((op1.isBit(16) && !op2.isBit(i32e)) || (op2.isBit(16) && !op1.isBit(i32e))) db(0x66);
1184  		if (rex) db(rex);
1185  	}
1186  	enum AVXtype {
1187  		PP_NONE = 1 << 0,
1188  		PP_66 = 1 << 1,
1189  		PP_F3 = 1 << 2,
1190  		PP_F2 = 1 << 3,
1191  		MM_RESERVED = 1 << 4,
1192  		MM_0F = 1 << 5,
1193  		MM_0F38 = 1 << 6,
1194  		MM_0F3A = 1 << 7
1195  	};
1196  	void vex(bool r, int idx, bool is256, int type, bool x = false, bool b = false, int w = 1)
1197  	{
1198  		uint32 pp = (type & PP_66) ? 1 : (type & PP_F3) ? 2 : (type & PP_F2) ? 3 : 0;
1199  		uint32 vvvv = (((~idx) & 15) << 3) | (is256 ? 4 : 0) | pp;
1200  		if (!b && !x && !w && (type & MM_0F)) {
1201  			db(0xC5); db((r ? 0 : 0x80) | vvvv);
1202  		} else {
1203  			uint32 mmmm = (type & MM_0F) ? 1 : (type & MM_0F38) ? 2 : (type & MM_0F3A) ? 3 : 0;
1204  			db(0xC4); db((r ? 0 : 0x80) | (x ? 0 : 0x40) | (b ? 0 : 0x20) | mmmm); db((w << 7) | vvvv);
1205  		}
1206  	}
1207  	LabelManager labelMgr_;
1208  	bool isInDisp16(uint32 x) const { return 0xFFFF8000 <= x || x <= 0x7FFF; }
1209  	uint8 getModRM(int mod, int r1, int r2) const { return static_cast<uint8>((mod << 6) | ((r1 & 7) << 3) | (r2 & 7)); }
1210  	void opModR(const Reg& reg1, const Reg& reg2, int code0, int code1 = NONE, int code2 = NONE)
1211  	{
1212  		rex(reg2, reg1);
1213  		db(code0 | (reg1.isBit(8) ? 0 : 1)); if (code1 != NONE) db(code1); if (code2 != NONE) db(code2);
1214  		db(getModRM(3, reg1.getIdx(), reg2.getIdx()));
1215  	}
1216  	void opModM(const Address& addr, const Reg& reg, int code0, int code1 = NONE, int code2 = NONE, int immSize = 0)
1217  	{
1218  		if (addr.is64bitDisp()) throw Error(ERR_CANT_USE_64BIT_DISP);
1219  		rex(addr, reg);
1220  		db(code0 | (reg.isBit(8) ? 0 : 1)); if (code1 != NONE) db(code1); if (code2 != NONE) db(code2);
1221  		addr.updateRegField(static_cast<uint8>(reg.getIdx()));
1222  		opAddr(addr, immSize);
1223  	}
1224  	void makeJmp(uint32 disp, LabelType type, uint8 shortCode, uint8 longCode, uint8 longPref)
1225  	{
1226  		const int shortJmpSize = 2;
1227  		const int longHeaderSize = longPref ? 2 : 1;
1228  		const int longJmpSize = longHeaderSize + 4;
1229  		if (type != T_NEAR && inner::IsInDisp8(disp - shortJmpSize)) {
1230  			db(shortCode); db(disp - shortJmpSize);
1231  		} else {
1232  			if (type == T_SHORT) throw Error(ERR_LABEL_IS_TOO_FAR);
1233  			if (longPref) db(longPref);
1234  			db(longCode); dd(disp - longJmpSize);
1235  		}
1236  	}
1237  	template<class T>
1238  	void opJmp(T& label, LabelType type, uint8 shortCode, uint8 longCode, uint8 longPref)
1239  	{
1240  		if (isAutoGrow() && size_ + 16 >= maxSize_) growMemory(); &bsol;* avoid splitting code of jmp */
1241  		size_t offset = 0;
1242  		if (labelMgr_.getOffset(&offset, label)) { &bsol;* label exists */
1243  			makeJmp(inner::VerifyInInt32(offset - size_), type, shortCode, longCode, longPref);
1244  		} else {
1245  			int jmpSize = 0;
1246  			if (type == T_NEAR) {
1247  				jmpSize = 4;
1248  				if (longPref) db(longPref);
1249  				db(longCode); dd(0);
1250  			} else {
1251  				jmpSize = 1;
1252  				db(shortCode); db(0);
1253  			}
1254  			JmpLabel jmp(size_, jmpSize, inner::LasIs);
1255  			labelMgr_.addUndefinedLabel(label, jmp);
1256  		}
1257  	}
1258  	void opJmpAbs(const void *addr, LabelType type, uint8 shortCode, uint8 longCode)
1259  	{
1260  		if (isAutoGrow()) {
1261  			if (type != T_NEAR) throw Error(ERR_ONLY_T_NEAR_IS_SUPPORTED_IN_AUTO_GROW);
1262  			if (size_ + 16 >= maxSize_) growMemory();
1263  			db(longCode);
1264  			dd(0);
1265  			save(size_ - 4, size_t(addr) - size_, 4, inner::Labs);
1266  		} else {
1267  			makeJmp(inner::VerifyInInt32(reinterpret_cast<const uint8*>(addr) - getCurr()), type, shortCode, longCode, 0);
1268  		}
1269  	}
1270  	void opAddr(const Address &addr, int immSize = 0)
1271  	{
1272  		db(addr.getCode(), static_cast<int>(addr.getSize()));
1273  		if (addr.getLabel()) { 
1274  			putL_inner(*addr.getLabel(), true, addr.getDisp() - immSize);
1275  		}
1276  	}
1277  	void opGen(const Operand& reg, const Operand& op, int code, int pref, bool isValid(const Operand&, const Operand&), int imm8 = NONE, int preCode = NONE)
1278  	{
1279  		if (isValid && !isValid(reg, op)) throw Error(ERR_BAD_COMBINATION);
1280  		if (pref != NONE) db(pref);
1281  		if (op.isMEM()) {
1282  			opModM(static_cast<const Address&>(op), static_cast<const Reg&>(reg), 0x0F, preCode, code, (imm8 != NONE) ? 1 : 0);
1283  		} else {
1284  			opModR(static_cast<const Reg&>(reg), static_cast<const Reg&>(op), 0x0F, preCode, code);
1285  		}
1286  		if (imm8 != NONE) db(imm8);
1287  	}
1288  	void opMMX_IMM(const Mmx& mmx, int imm8, int code, int ext)
1289  	{
1290  		if (mmx.isXMM()) db(0x66);
1291  		opModR(Reg32(ext), mmx, 0x0F, code);
1292  		db(imm8);
1293  	}
1294  	void opMMX(const Mmx& mmx, const Operand& op, int code, int pref = 0x66, int imm8 = NONE, int preCode = NONE)
1295  	{
1296  		opGen(mmx, op, code, mmx.isXMM() ? pref : NONE, isXMMorMMX_MEM, imm8, preCode);
1297  	}
1298  	void opMovXMM(const Operand& op1, const Operand& op2, int code, int pref)
1299  	{
1300  		if (pref != NONE) db(pref);
1301  		if (op1.isXMM() && op2.isMEM()) {
1302  			opModM(static_cast<const Address&>(op2), static_cast<const Reg&>(op1), 0x0F, code);
1303  		} else if (op1.isMEM() && op2.isXMM()) {
1304  			opModM(static_cast<const Address&>(op1), static_cast<const Reg&>(op2), 0x0F, code | 1);
1305  		} else {
1306  			throw Error(ERR_BAD_COMBINATION);
1307  		}
1308  	}
1309  	void opExt(const Operand& op, const Mmx& mmx, int code, int imm, bool hasMMX2 = false)
1310  	{
1311  		if (hasMMX2 && op.isREG(i32e)) { &bsol;* pextrw is special */
1312  			if (mmx.isXMM()) db(0x66);
1313  			opModR(static_cast<const Reg&>(op), mmx, 0x0F, B11000101); db(imm);
1314  		} else {
1315  			opGen(mmx, op, code, 0x66, isXMM_REG32orMEM, imm, B00111010);
1316  		}
1317  	}
1318  	void opR_ModM(const Operand& op, int bit, int ext, int code0, int code1 = NONE, int code2 = NONE, bool disableRex = false, int immSize = 0)
1319  	{
1320  		int opBit = op.getBit();
1321  		if (disableRex && opBit == 64) opBit = 32;
1322  		if (op.isREG(bit)) {
1323  			opModR(Reg(ext, Operand::REG, opBit), static_cast<const Reg&>(op).changeBit(opBit), code0, code1, code2);
1324  		} else if (op.isMEM()) {
1325  			opModM(static_cast<const Address&>(op), Reg(ext, Operand::REG, opBit), code0, code1, code2, immSize);
1326  		} else {
1327  			throw Error(ERR_BAD_COMBINATION);
1328  		}
1329  	}
1330  	void opShift(const Operand& op, int imm, int ext)
1331  	{
1332  		verifyMemHasSize(op);
1333  		opR_ModM(op, 0, ext, (B11000000 | ((imm == 1 ? 1 : 0) << 4)), NONE, NONE, false, (imm != 1) ? 1 : 0);
1334  		if (imm != 1) db(imm);
1335  	}
1336  	void opShift(const Operand& op, const Reg8& _cl, int ext)
1337  	{
1338  		if (_cl.getIdx() != Operand::CL) throw Error(ERR_BAD_COMBINATION);
1339  		opR_ModM(op, 0, ext, B11010010);
1340  	}
1341  	void opModRM(const Operand& op1, const Operand& op2, bool condR, bool condM, int code0, int code1 = NONE, int code2 = NONE, int immSize = 0)
1342  	{
1343  		if (condR) {
1344  			opModR(static_cast<const Reg&>(op1), static_cast<const Reg&>(op2), code0, code1, code2);
1345  		} else if (condM) {
1346  			opModM(static_cast<const Address&>(op2), static_cast<const Reg&>(op1), code0, code1, code2, immSize);
1347  		} else {
1348  			throw Error(ERR_BAD_COMBINATION);
1349  		}
1350  	}
1351  	void opShxd(const Operand& op, const Reg& reg, uint8 imm, int code, const Reg8 *_cl = 0)
1352  	{
1353  		if (_cl && _cl->getIdx() != Operand::CL) throw Error(ERR_BAD_COMBINATION);
1354  		opModRM(reg, op, (op.isREG(16 | i32e) && op.getBit() == reg.getBit()), op.isMEM() && (reg.isREG(16 | i32e)), 0x0F, code | (_cl ? 1 : 0), NONE, _cl ? 0 : 1);
1355  		if (!_cl) db(imm);
1356  	}
1357  	void opRM_RM(const Operand& op1, const Operand& op2, int code)
1358  	{
1359  		if (op1.isREG() && op2.isMEM()) {
1360  			opModM(static_cast<const Address&>(op2), static_cast<const Reg&>(op1), code | 2);
1361  		} else {
1362  			opModRM(op2, op1, op1.isREG() && op1.getKind() == op2.getKind(), op1.isMEM() && op2.isREG(), code);
1363  		}
1364  	}
1365  	void opRM_I(const Operand& op, uint32 imm, int code, int ext)
1366  	{
1367  		verifyMemHasSize(op);
1368  		uint32 immBit = inner::IsInDisp8(imm) ? 8 : isInDisp16(imm) ? 16 : 32;
1369  		if (op.isBit(8)) immBit = 8;
1370  		if (op.getBit() < immBit) throw Error(ERR_IMM_IS_TOO_BIG);
1371  		if (op.isBit(32|64) && immBit == 16) immBit = 32; &bsol;* don't use MEM16 if 32/64bit mode */
1372  		if (op.isREG() && op.getIdx() == 0 && (op.getBit() == immBit || (op.isBit(64) && immBit == 32))) { 
1373  			rex(op);
1374  			db(code | 4 | (immBit == 8 ? 0 : 1));
1375  		} else {
1376  			int tmp = immBit < (std::min)(op.getBit(), 32U) ? 2 : 0;
1377  			opR_ModM(op, 0, ext, B10000000 | tmp, NONE, NONE, false, immBit / 8);
1378  		}
1379  		db(imm, immBit / 8);
1380  	}
1381  	void opIncDec(const Operand& op, int code, int ext)
1382  	{
1383  		verifyMemHasSize(op);
1384  #ifndef XBYAK64
1385  		if (op.isREG() && !op.isBit(8)) {
1386  			rex(op); db(code | op.getIdx());
1387  			return;
1388  		}
1389  #endif
1390  		code = B11111110;
1391  		if (op.isREG()) {
1392  			opModR(Reg(ext, Operand::REG, op.getBit()), static_cast<const Reg&>(op), code);
1393  		} else {
1394  			opModM(static_cast<const Address&>(op), Reg(ext, Operand::REG, op.getBit()), code);
1395  		}
1396  	}
1397  	void opPushPop(const Operand& op, int code, int ext, int alt)
1398  	{
1399  		if (op.isREG()) {
1400  			if (op.isBit(16)) db(0x66);
1401  			if (static_cast<const Reg&>(op).getIdx() >= 8) db(0x41);
1402  			db(alt | (op.getIdx() & 7));
1403  		} else if (op.isMEM()) {
1404  			opModM(static_cast<const Address&>(op), Reg(ext, Operand::REG, op.getBit()), code);
1405  		} else {
1406  			throw Error(ERR_BAD_COMBINATION);
1407  		}
1408  	}
1409  	void verifyMemHasSize(const Operand& op) const
1410  	{
1411  		if (op.isMEM() && op.getBit() == 0) throw Error(ERR_MEM_SIZE_IS_NOT_SPECIFIED);
1412  	}
1413  	void opMovxx(const Reg& reg, const Operand& op, uint8 code)
1414  	{
1415  		if (op.isBit(32)) throw Error(ERR_BAD_COMBINATION);
1416  		int w = op.isBit(16);
1417  #ifdef XBYAK64
1418  		if (op.isHigh8bit()) throw Error(ERR_BAD_COMBINATION);
1419  #endif
1420  		bool cond = reg.isREG() && (reg.getBit() > op.getBit());
1421  		opModRM(reg, op, cond && op.isREG(), cond && op.isMEM(), 0x0F, code | w);
1422  	}
1423  	void opFpuMem(const Address& addr, uint8 m16, uint8 m32, uint8 m64, uint8 ext, uint8 m64ext)
1424  	{
1425  		if (addr.is64bitDisp()) throw Error(ERR_CANT_USE_64BIT_DISP);
1426  		uint8 code = addr.isBit(16) ? m16 : addr.isBit(32) ? m32 : addr.isBit(64) ? m64 : 0;
1427  		if (!code) throw Error(ERR_BAD_MEM_SIZE);
1428  		if (m64ext && addr.isBit(64)) ext = m64ext;
1429  		rex(addr, st0);
1430  		db(code);
1431  		addr.updateRegField(ext);
1432  		opAddr(addr);
1433  	}
1434  	void opFpuFpu(const Fpu& reg1, const Fpu& reg2, uint32 code1, uint32 code2)
1435  	{
1436  		uint32 code = reg1.getIdx() == 0 ? code1 : reg2.getIdx() == 0 ? code2 : 0;
1437  		if (!code) throw Error(ERR_BAD_ST_COMBINATION);
1438  		db(uint8(code >> 8));
1439  		db(uint8(code | (reg1.getIdx() | reg2.getIdx())));
1440  	}
1441  	void opFpu(const Fpu& reg, uint8 code1, uint8 code2)
1442  	{
1443  		db(code1); db(code2 | reg.getIdx());
1444  	}
1445  	void opVex(const Reg& r, const Operand *p1, const Operand *p2, int type, int code, int w, int imm8 = NONE)
1446  	{
1447  		bool x, b;
1448  		if (p2->isMEM()) {
1449  			const Address& addr = static_cast<const Address&>(*p2);
1450  			uint8 rex = addr.getRex();
1451  			x = (rex & 2) != 0;
1452  			b = (rex & 1) != 0;
1453  			if (BIT == 64 && addr.is32bit()) db(0x67);
1454  			if (BIT == 64 && w == -1) w = (rex & 4) ? 1 : 0;
1455  		} else {
1456  			x = false;
1457  			b = static_cast<const Reg&>(*p2).isExtIdx();
1458  		}
1459  		if (w == -1) w = 0;
1460  		vex(r.isExtIdx(), p1 ? p1->getIdx() : 0, r.isYMM(), type, x, b, w);
1461  		db(code);
1462  		if (p2->isMEM()) {
1463  			const Address& addr = static_cast<const Address&>(*p2);
1464  			addr.updateRegField(static_cast<uint8>(r.getIdx()));
1465  			opAddr(addr, (imm8 != NONE) ? 1 : 0);
1466  		} else {
1467  			db(getModRM(3, r.getIdx(), p2->getIdx()));
1468  		}
1469          if (imm8 != NONE) db(imm8);
1470  	}
1471  	void opGpr(const Reg32e& r, const Operand& op1, const Operand& op2, int type, uint8 code, bool isR_R_RM, int imm8 = NONE)
1472  	{
1473  		const Operand *p1 = &op1;
1474  		const Operand *p2 = &op2;
1475  		if (!isR_R_RM) std::swap(p1, p2);
1476  		const unsigned int bit = r.getBit();
1477  		if (p1->getBit() != bit || (p2->isREG() && p2->getBit() != bit)) throw Error(ERR_BAD_COMBINATION);
1478  		int w = bit == 64;
1479  		opVex(r, p1, p2, type, code, w, imm8);
1480  	}
1481  	void opAVX_X_X_XM(const Xmm& x1, const Operand& op1, const Operand& op2, int type, int code0, bool supportYMM, int w = -1, int imm8 = NONE)
1482  	{
1483  		const Xmm *x2;
1484  		const Operand *op;
1485  		if (op2.isNone()) {
1486  			x2 = &x1;
1487  			op = &op1;
1488  		} else {
1489  			if (!(op1.isXMM() || (supportYMM && op1.isYMM()))) throw Error(ERR_BAD_COMBINATION);
1490  			x2 = static_cast<const Xmm*>(&op1);
1491  			op = &op2;
1492  		}
1493  		if (!((x1.isXMM() && x2->isXMM()) || (supportYMM && x1.isYMM() && x2->isYMM()))) throw Error(ERR_BAD_COMBINATION);
1494  		opVex(x1, x2, op, type, code0, w, imm8);
1495  	}
1496  	void opAVX_X_X_XMcvt(const Xmm& x1, const Operand& op1, const Operand& op2, bool cvt, Operand::Kind kind, int type, int code0, bool supportYMM, int w = -1, int imm8 = NONE)
1497  	{
1498  		opAVX_X_X_XM(x1, op1, cvt ? kind == Operand::XMM ? static_cast<const Operand&>(Xmm(op2.getIdx())) : static_cast<const Operand&>(Ymm(op2.getIdx())) : op2, type, code0, supportYMM, w, imm8);
1499  	}
1500  	void opAVX_X_XM_IMM(const Xmm& x, const Operand& op, int type, int code, bool supportYMM, int w = -1, int imm8 = NONE)
1501  	{
1502  		opAVX_X_X_XM(x, x.isXMM() ? xm0 : ym0, op, type, code, supportYMM, w, imm8);
1503  	}
1504  	void opSp1(const Reg& reg, const Operand& op, uint8 pref, uint8 code0, uint8 code1)
1505  	{
1506  		if (reg.isBit(8)) throw Error(ERR_BAD_SIZE_OF_REGISTER);
1507  		bool is16bit = reg.isREG(16) && (op.isREG(16) || op.isMEM());
1508  		if (!is16bit && !(reg.isREG(i32e) && (op.isREG(reg.getBit()) || op.isMEM()))) throw Error(ERR_BAD_COMBINATION);
1509  		if (is16bit) db(0x66);
1510  		db(pref); opModRM(reg.changeBit(i32e == 32 ? 32 : reg.getBit()), op, op.isREG(), true, code0, code1);
1511  	}
1512  	void opGather(const Xmm& x1, const Address& addr, const Xmm& x2, int type, uint8 code, int w, int mode)
1513  	{
1514  		if (!addr.isVsib()) throw Error(ERR_BAD_VSIB_ADDRESSING);
1515  		const int y_vx_y = 0;
1516  		const int y_vy_y = 1;
1517  		const bool isAddrYMM = addr.isYMM();
1518  		if (!x1.isXMM() || isAddrYMM || !x2.isXMM()) {
1519  			bool isOK = false;
1520  			if (mode == y_vx_y) {
1521  				isOK = x1.isYMM() && !isAddrYMM && x2.isYMM();
1522  			} else if (mode == y_vy_y) {
1523  				isOK = x1.isYMM() && isAddrYMM && x2.isYMM();
1524  			} else { 
1525  				isOK = !x1.isYMM() && isAddrYMM && !x2.isYMM();
1526  			}
1527  			if (!isOK) throw Error(ERR_BAD_VSIB_ADDRESSING);
1528  		}
1529  		addr.setVsib(false);
1530  		opAVX_X_X_XM(isAddrYMM ? Ymm(x1.getIdx()) : x1, isAddrYMM ? Ymm(x2.getIdx()) : x2, addr, type, code, true, w);
1531  		addr.setVsib(true);
1532  	}
1533  public:
1534  	unsigned int getVersion() const { return VERSION; }
1535  	using CodeArray::db;
1536  	const Mmx mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;
1537  	const Xmm xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7;
1538  	const Ymm ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7;
1539  	const Xmm &xm0, &xm1, &xm2, &xm3, &xm4, &xm5, &xm6, &xm7;
1540  	const Ymm &ym0, &ym1, &ym2, &ym3, &ym4, &ym5, &ym6, &ym7;
1541  	const Reg32 eax, ecx, edx, ebx, esp, ebp, esi, edi;
1542  	const Reg16 ax, cx, dx, bx, sp, bp, si, di;
1543  	const Reg8 al, cl, dl, bl, ah, ch, dh, bh;
1544  	const AddressFrame ptr, byte, word, dword, qword;
1545  	const Fpu st0, st1, st2, st3, st4, st5, st6, st7;
1546  #ifdef XBYAK64
1547  	const Reg64 rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;
1548  	const Reg32 r8d, r9d, r10d, r11d, r12d, r13d, r14d, r15d;
1549  	const Reg16 r8w, r9w, r10w, r11w, r12w, r13w, r14w, r15w;
1550  	const Reg8 r8b, r9b, r10b, r11b, r12b, r13b, r14b, r15b;
1551  	const Reg8 spl, bpl, sil, dil;
1552  	const Xmm xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15;
1553  	const Ymm ymm8, ymm9, ymm10, ymm11, ymm12, ymm13, ymm14, ymm15;
1554  	const Xmm &xm8, &xm9, &xm10, &xm11, &xm12, &xm13, &xm14, &xm15; 
1555  	const Ymm &ym8, &ym9, &ym10, &ym11, &ym12, &ym13, &ym14, &ym15;
1556  	const RegRip rip;
1557  #endif
1558  #ifndef XBYAK_DISABLE_SEGMENT
1559  	const Segment es, cs, ss, ds, fs, gs;
1560  #endif
1561  	void L(const std::string& label) { labelMgr_.defineSlabel(label); }
1562  	void L(const Label& label) { labelMgr_.defineClabel(label); }
1563  	void assignL(Label& dst, const Label& src) { labelMgr_.assign(dst, src); }
1564  	void inLocalLabel() { labelMgr_.enterLocal(); }
1565  	void outLocalLabel() { labelMgr_.leaveLocal(); }
1566  	void jmp(std::string label, LabelType type = T_AUTO)
1567  	{
1568  		opJmp(label, type, B11101011, B11101001, 0);
1569  	}
1570  	void jmp(const Label& label, LabelType type = T_AUTO)
1571  	{
1572  		opJmp(label, type, B11101011, B11101001, 0);
1573  	}
1574  	void jmp(const char *label, LabelType type = T_AUTO) { jmp(std::string(label), type); }
1575  	void jmp(const void *addr, LabelType type = T_AUTO)
1576  	{
1577  		opJmpAbs(addr, type, B11101011, B11101001);
1578  	}
1579  	void jmp(const Operand& op)
1580  	{
1581  		opR_ModM(op, BIT, 4, 0xFF, NONE, NONE, true);
1582  	}
1583  	void call(const Operand& op)
1584  	{
1585  		opR_ModM(op, 16 | i32e, 2, 0xFF, NONE, NONE, true);
1586  	}
1587  	void test(const Operand& op, const Reg& reg)
1588  	{
1589  		opModRM(reg, op, op.isREG() && (op.getKind() == reg.getKind()), op.isMEM(), B10000100);
1590  	}
1591  	void test(const Operand& op, uint32 imm)
1592  	{
1593  		verifyMemHasSize(op);
1594          int immSize = (std::min)(op.getBit() / 8, 4U);
1595  		if (op.isREG() && op.getIdx() == 0) { 
1596  			rex(op);
1597  			db(B10101000 | (op.isBit(8) ? 0 : 1));
1598  		} else {
1599  			opR_ModM(op, 0, 0, B11110110, NONE, NONE, false, immSize);
1600  		}
1601  		db(imm, immSize);
1602  	}
1603  	void ret(int imm = 0)
1604  	{
1605  		if (imm) {
1606  			db(B11000010); dw(imm);
1607  		} else {
1608  			db(B11000011);
1609  		}
1610  	}
1611  	void imul(const Reg& reg, const Operand& op)
1612  	{
1613  		opModRM(reg, op, op.isREG() && (reg.getKind() == op.getKind()), op.isMEM(), 0x0F, B10101111);
1614  	}
1615  	void imul(const Reg& reg, const Operand& op, int imm)
1616  	{
1617  		int s = inner::IsInDisp8(imm) ? 1 : 0;
1618          int immSize = s ? 1 : reg.isREG(16) ? 2 : 4;
1619  		opModRM(reg, op, op.isREG() && (reg.getKind() == op.getKind()), op.isMEM(), B01101001 | (s << 1), NONE, NONE, immSize);
1620  		db(imm, immSize);
1621  	}
1622  	void pop(const Operand& op)
1623  	{
1624  		opPushPop(op, B10001111, 0, B01011000);
1625  	}
1626  	void push(const Operand& op)
1627  	{
1628  		opPushPop(op, B11111111, 6, B01010000);
1629  	}
1630  	void push(const AddressFrame& af, uint32 imm)
1631  	{
1632  		if (af.bit_ == 8 && inner::IsInDisp8(imm)) {
1633  			db(B01101010); db(imm);
1634  		} else if (af.bit_ == 16 && isInDisp16(imm)) {
1635  			db(0x66); db(B01101000); dw(imm);
1636  		} else {
1637  			db(B01101000); dd(imm);
1638  		}
1639  	}
1640  	void push(uint32 imm)
1641  	{
1642  		if (inner::IsInDisp8(imm)) {
1643  			push(byte, imm);
1644  		} else {
1645  			push(dword, imm);
1646  		}
1647  	}
1648  #ifndef XBYAK_DISABLE_SEGMENT
1649  	void push(const Segment& seg)
1650  	{
1651  		switch (seg.getIdx()) {
1652  		case Segment::es: db(0x06); break;
1653  		case Segment::cs: db(0x0e); break;
1654  		case Segment::ss: db(0x16); break;
1655  		case Segment::ds: db(0x1e); break;
1656  		case Segment::fs: db(0x0f); db(0xa0); break;
1657  		case Segment::gs: db(0x0f); db(0xa8); break;
1658  		default:
1659  			assert(0);
1660  		}
1661  	}
1662  	void pop(const Segment& seg)
1663  	{
1664  		switch (seg.getIdx()) {
1665  		case Segment::es: db(0x07); break;
1666  		case Segment::cs: throw Error(ERR_BAD_COMBINATION);
1667  		case Segment::ss: db(0x17); break;
1668  		case Segment::ds: db(0x1f); break;
1669  		case Segment::fs: db(0x0f); db(0xa1); break;
1670  		case Segment::gs: db(0x0f); db(0xa9); break;
1671  		default:
1672  			assert(0);
1673  		}
1674  	}
1675  #endif
1676  	void bswap(const Reg32e& reg)
1677  	{
1678  		opModR(Reg32(1), reg, 0x0F);
1679  	}
1680  	void mov(const Operand& reg1, const Operand& reg2)
1681  	{
1682  		const Reg *reg = 0;
1683  		const Address *addr = 0;
1684  		uint8 code = 0;
1685  		if (reg1.isREG() && reg1.getIdx() == 0 && reg2.isMEM()) { 
1686  			reg = &static_cast<const Reg&>(reg1);
1687  			addr= &static_cast<const Address&>(reg2);
1688  			code = B10100000;
1689  		} else
1690  		if (reg1.isMEM() && reg2.isREG() && reg2.getIdx() == 0) { 
1691  			reg = &static_cast<const Reg&>(reg2);
1692  			addr= &static_cast<const Address&>(reg1);
1693  			code = B10100010;
1694  		}
1695  #ifdef XBYAK64
1696  		if (addr && addr->is64bitDisp()) {
1697  			if (code) {
1698  				rex(*reg);
1699  				db(reg1.isREG(8) ? 0xA0 : reg1.isREG() ? 0xA1 : reg2.isREG(8) ? 0xA2 : 0xA3);
1700  				db(addr->getDisp(), 8);
1701  			} else {
1702  				throw Error(ERR_BAD_COMBINATION);
1703  			}
1704  		} else
1705  #else
1706  		if (code && addr->isOnlyDisp()) {
1707  			rex(*reg, *addr);
1708  			db(code | (reg->isBit(8) ? 0 : 1));
1709  			dd(static_cast<uint32>(addr->getDisp()));
1710  		} else
1711  #endif
1712  		{
1713  			opRM_RM(reg1, reg2, B10001000);
1714  		}
1715  	}
1716  private:
1717  	int mov_imm(const Reg& reg, size_t imm)
1718  	{
1719  		int bit = reg.getBit();
1720  		const int idx = reg.getIdx();
1721  		int code = B10110000 | ((bit == 8 ? 0 : 1) << 3);
1722  		if (bit == 64 && (imm & ~size_t(0xffffffffu)) == 0) {
1723  			rex(Reg32(idx));
1724  			bit = 32;
1725  		} else {
1726  			rex(reg);
1727  			if (bit == 64 && inner::IsInInt32(imm)) {
1728  				db(B11000111);
1729  				code = B11000000;
1730  				bit = 32;
1731  			}
1732  		}
1733  		db(code | (idx & 7));
1734  		return bit / 8;
1735  	}
1736  	template<class T>
1737  	void putL_inner(T& label, bool relative = false, size_t disp = 0)
1738  	{
1739  		const int jmpSize = relative ? 4 : (int)sizeof(size_t);
1740  		if (isAutoGrow() && size_ + 16 >= maxSize_) growMemory();
1741  		size_t offset = 0;
1742  		if (labelMgr_.getOffset(&offset, label)) {
1743  			if (relative) {
1744  				db(inner::VerifyInInt32(offset + disp - size_ - jmpSize), jmpSize);
1745  			} else if (isAutoGrow()) {
1746  				db(uint64(0), jmpSize);
1747  				save(size_ - jmpSize, offset, jmpSize, inner::LaddTop);
1748  			} else {
1749  				db(size_t(top_) + offset, jmpSize);
1750  			}
1751  			return;
1752  		}
1753  		db(uint64(0), jmpSize);
1754  		JmpLabel jmp(size_, jmpSize, (relative ? inner::LasIs : isAutoGrow() ? inner::LaddTop : inner::Labs), disp);
1755  		labelMgr_.addUndefinedLabel(label, jmp);
1756  	}
1757  public:
1758  	void mov(const Operand& op, size_t imm)
1759  	{
1760  		if (op.isREG()) {
1761  			const int size = mov_imm(static_cast<const Reg&>(op), imm);
1762  			db(imm, size);
1763  		} else if (op.isMEM()) {
1764  			verifyMemHasSize(op);
1765  			int immSize = op.getBit() / 8;
1766  			if (immSize <= 4) {
1767  				sint64 s = sint64(imm) >> (immSize * 8);
1768  				if (s != 0 && s != -1) throw Error(ERR_IMM_IS_TOO_BIG);
1769  			} else {
1770  				if (!inner::IsInInt32(imm)) throw Error(ERR_IMM_IS_TOO_BIG);
1771  				immSize = 4;
1772  			}
1773  			opModM(static_cast<const Address&>(op), Reg(0, Operand::REG, op.getBit()), B11000110, NONE, NONE, immSize);
1774  			db(static_cast<uint32>(imm), immSize);
1775  		} else {
1776  			throw Error(ERR_BAD_COMBINATION);
1777  		}
1778  	}
1779  	void mov(const NativeReg& reg, const char *label) 
1780  	{
1781  		if (label == 0) {
1782  			mov(static_cast<const Operand&>(reg), 0); 
1783  			return;
1784  		}
1785  		mov_imm(reg, dummyAddr);
1786  		putL(label);
1787  	}
1788  	void mov(const NativeReg& reg, const Label& label)
1789  	{
1790  		mov_imm(reg, dummyAddr);
1791  		putL(label);
1792  	}
1793  #ifndef XBYAK_DISABLE_SEGMENT
1794  	void putSeg(const Segment& seg)
1795  	{
1796  		switch (seg.getIdx()) {
1797  		case Segment::es: db(0x2e); break;
1798  		case Segment::cs: db(0x36); break;
1799  		case Segment::ss: db(0x3e); break;
1800  		case Segment::ds: db(0x26); break;
1801  		case Segment::fs: db(0x64); break;
1802  		case Segment::gs: db(0x65); break;
1803  		default:
1804  			assert(0);
1805  		}
1806  	}
1807  	void mov(const Operand& op, const Segment& seg)
1808  	{
1809  		opModRM(Reg8(seg.getIdx()), op, op.isREG(16|i32e), op.isMEM(), 0x8C);
1810  	}
1811  	void mov(const Segment& seg, const Operand& op)
1812  	{
1813  		opModRM(Reg8(seg.getIdx()), op.isREG(16|i32e) ? static_cast<const Operand&>(static_cast<const Reg&>(op).cvt32()) : op, op.isREG(16|i32e), op.isMEM(), 0x8E);
1814  	}
1815  #endif
1816  	void movbe(const Reg& reg, const Address& addr) { opModM(addr, reg, 0x0F, 0x38, 0xF0); }
1817  	void movbe(const Address& addr, const Reg& reg) { opModM(addr, reg, 0x0F, 0x38, 0xF1); }
1818  	void putL(std::string label) { putL_inner(label); }
1819  	void putL(const Label& label) { putL_inner(label); }
1820  	void adcx(const Reg32e& reg, const Operand& op) { opGen(reg, op, 0xF6, 0x66, isREG32_REG32orMEM, NONE, 0x38); }
1821  	void adox(const Reg32e& reg, const Operand& op) { opGen(reg, op, 0xF6, 0xF3, isREG32_REG32orMEM, NONE, 0x38); }
1822  	void cmpxchg8b(const Address& addr) { opModM(addr, Reg32(1), 0x0F, B11000111); }
1823  #ifdef XBYAK64
1824  	void cmpxchg16b(const Address& addr) { opModM(addr, Reg64(1), 0x0F, B11000111); }
1825  #endif
1826  	void xadd(const Operand& op, const Reg& reg)
1827  	{
1828  		opModRM(reg, op, (op.isREG() && reg.isREG() && op.getBit() == reg.getBit()), op.isMEM(), 0x0F, B11000000 | (reg.isBit(8) ? 0 : 1));
1829  	}
1830  	void cmpxchg(const Operand& op, const Reg& reg)
1831  	{
1832  		opModRM(reg, op, (op.isREG() && reg.isREG() && op.getBit() == reg.getBit()), op.isMEM(), 0x0F, 0xb0 | (reg.isBit(8) ? 0 : 1));
1833  	}
1834  	void xchg(const Operand& op1, const Operand& op2)
1835  	{
1836  		const Operand *p1 = &op1, *p2 = &op2;
1837  		if (p1->isMEM() || (p2->isREG(16 | i32e) && p2->getIdx() == 0)) {
1838  			p1 = &op2; p2 = &op1;
1839  		}
1840  		if (p1->isMEM()) throw Error(ERR_BAD_COMBINATION);
1841  		if (p2->isREG() && (p1->isREG(16 | i32e) && p1->getIdx() == 0)
1842  #ifdef XBYAK64
1843  			&& (p2->getIdx() != 0 || !p1->isREG(32))
1844  #endif
1845  		) {
1846  			rex(*p2, *p1); db(0x90 | (p2->getIdx() & 7));
1847  			return;
1848  		}
1849  		opModRM(*p1, *p2, (p1->isREG() && p2->isREG() && (p1->getBit() == p2->getBit())), p2->isMEM(), B10000110 | (p1->isBit(8) ? 0 : 1));
1850  	}
1851  	void call(std::string label) { opJmp(label, T_NEAR, 0, B11101000, 0); }
1852  	void call(const char *label) { call(std::string(label)); }
1853  	void call(const Label& label) { opJmp(label, T_NEAR, 0, B11101000, 0); }
1854  #ifdef XBYAK_VARIADIC_TEMPLATE
1855  	template<class Ret, class... Params>
1856  	void call(Ret(*func)(Params...)) { call(CastTo<const void*>(func)); }
1857  #endif
1858  	void call(const void *addr) { opJmpAbs(addr, T_NEAR, 0, B11101000); }
1859  	void movd(const Address& addr, const Mmx& mmx)
1860  	{
1861  		if (mmx.isXMM()) db(0x66);
1862  		opModM(addr, mmx, 0x0F, B01111110);
1863  	}
1864  	void movd(const Reg32& reg, const Mmx& mmx)
1865  	{
1866  		if (mmx.isXMM()) db(0x66);
1867  		opModR(mmx, reg, 0x0F, B01111110);
1868  	}
1869  	void movd(const Mmx& mmx, const Address& addr)
1870  	{
1871  		if (mmx.isXMM()) db(0x66);
1872  		opModM(addr, mmx, 0x0F, B01101110);
1873  	}
1874  	void movd(const Mmx& mmx, const Reg32& reg)
1875  	{
1876  		if (mmx.isXMM()) db(0x66);
1877  		opModR(mmx, reg, 0x0F, B01101110);
1878  	}
1879  	void movq2dq(const Xmm& xmm, const Mmx& mmx)
1880  	{
1881  		db(0xF3); opModR(xmm, mmx, 0x0F, B11010110);
1882  	}
1883  	void movdq2q(const Mmx& mmx, const Xmm& xmm)
1884  	{
1885  		db(0xF2); opModR(mmx, xmm, 0x0F, B11010110);
1886  	}
1887  	void movq(const Mmx& mmx, const Operand& op)
1888  	{
1889  		if (mmx.isXMM()) db(0xF3);
1890  		opModRM(mmx, op, (mmx.getKind() == op.getKind()), op.isMEM(), 0x0F, mmx.isXMM() ? B01111110 : B01101111);
1891  	}
1892  	void movq(const Address& addr, const Mmx& mmx)
1893  	{
1894  		if (mmx.isXMM()) db(0x66);
1895  		opModM(addr, mmx, 0x0F, mmx.isXMM() ? B11010110 : B01111111);
1896  	}
1897  #ifdef XBYAK64
1898  	void movq(const Reg64& reg, const Mmx& mmx)
1899  	{
1900  		if (mmx.isXMM()) db(0x66);
1901  		opModR(mmx, reg, 0x0F, B01111110);
1902  	}
1903  	void movq(const Mmx& mmx, const Reg64& reg)
1904  	{
1905  		if (mmx.isXMM()) db(0x66);
1906  		opModR(mmx, reg, 0x0F, B01101110);
1907  	}
1908  	void pextrq(const Operand& op, const Xmm& xmm, uint8 imm)
1909  	{
1910  		if (!op.isREG(64) && !op.isMEM()) throw Error(ERR_BAD_COMBINATION);
1911  		opGen(Reg64(xmm.getIdx()), op, 0x16, 0x66, 0, imm, B00111010); 
1912  	}
1913  	void pinsrq(const Xmm& xmm, const Operand& op, uint8 imm)
1914  	{
1915  		if (!op.isREG(64) && !op.isMEM()) throw Error(ERR_BAD_COMBINATION);
1916  		opGen(Reg64(xmm.getIdx()), op, 0x22, 0x66, 0, imm, B00111010); 
1917  	}
1918  	void movsxd(const Reg64& reg, const Operand& op)
1919  	{
1920  		if (!op.isBit(32)) throw Error(ERR_BAD_COMBINATION);
1921  		opModRM(reg, op, op.isREG(), op.isMEM(), 0x63);
1922  	}
1923  #endif
1924  	void pextrw(const Operand& op, const Mmx& xmm, uint8 imm) { opExt(op, xmm, 0x15, imm, true); }
1925  	void pextrb(const Operand& op, const Xmm& xmm, uint8 imm) { opExt(op, xmm, 0x14, imm); }
1926  	void pextrd(const Operand& op, const Xmm& xmm, uint8 imm) { opExt(op, xmm, 0x16, imm); }
1927  	void extractps(const Operand& op, const Xmm& xmm, uint8 imm) { opExt(op, xmm, 0x17, imm); }
1928  	void pinsrw(const Mmx& mmx, const Operand& op, int imm)
1929  	{
1930  		if (!op.isREG(32) && !op.isMEM()) throw Error(ERR_BAD_COMBINATION);
1931  		opGen(mmx, op, B11000100, mmx.isXMM() ? 0x66 : NONE, 0, imm);
1932  	}
1933  	void insertps(const Xmm& xmm, const Operand& op, uint8 imm) { opGen(xmm, op, 0x21, 0x66, isXMM_XMMorMEM, imm, B00111010); }
1934  	void pinsrb(const Xmm& xmm, const Operand& op, uint8 imm) { opGen(xmm, op, 0x20, 0x66, isXMM_REG32orMEM, imm, B00111010); }
1935  	void pinsrd(const Xmm& xmm, const Operand& op, uint8 imm) { opGen(xmm, op, 0x22, 0x66, isXMM_REG32orMEM, imm, B00111010); }
1936  	void pmovmskb(const Reg32e& reg, const Mmx& mmx)
1937  	{
1938  		if (mmx.isXMM()) db(0x66);
1939  		opModR(reg, mmx, 0x0F, B11010111);
1940  	}
1941  	void maskmovq(const Mmx& reg1, const Mmx& reg2)
1942  	{
1943  		if (!reg1.isMMX() || !reg2.isMMX()) throw Error(ERR_BAD_COMBINATION);
1944  		opModR(reg1, reg2, 0x0F, B11110111);
1945  	}
1946  	void lea(const Reg32e& reg, const Address& addr) { opModM(addr, reg, B10001101); }
1947  	void movmskps(const Reg32e& reg, const Xmm& xmm) { opModR(reg, xmm, 0x0F, B01010000); }
1948  	void movmskpd(const Reg32e& reg, const Xmm& xmm) { db(0x66); movmskps(reg, xmm); }
1949  	void movntps(const Address& addr, const Xmm& xmm) { opModM(addr, Mmx(xmm.getIdx()), 0x0F, B00101011); }
1950  	void movntdqa(const Xmm& xmm, const Address& addr) { db(0x66); opModM(addr, xmm, 0x0F, 0x38, 0x2A); }
1951  	void lddqu(const Xmm& xmm, const Address& addr) { db(0xF2); opModM(addr, xmm, 0x0F, B11110000); }
1952  	void movnti(const Address& addr, const Reg32e& reg) { opModM(addr, reg, 0x0F, B11000011); }
1953  	void movntq(const Address& addr, const Mmx& mmx)
1954  	{
1955  		if (!mmx.isMMX()) throw Error(ERR_BAD_COMBINATION);
1956  		opModM(addr, mmx, 0x0F, B11100111);
1957  	}
1958  	void crc32(const Reg32e& reg, const Operand& op)
1959  	{
1960  		if (reg.isBit(32) && op.isBit(16)) db(0x66);
1961  		db(0xF2);
1962  		opModRM(reg, op, op.isREG(), op.isMEM(), 0x0F, 0x38, 0xF0 | (op.isBit(8) ? 0 : 1));
1963  	}
1964  	void rdrand(const Reg& r) { if (r.isBit(8)) throw Error(ERR_BAD_SIZE_OF_REGISTER); opModR(Reg(6, Operand::REG, r.getBit()), r, 0x0f, 0xc7); }
1965  	void rdseed(const Reg& r) { if (r.isBit(8)) throw Error(ERR_BAD_SIZE_OF_REGISTER); opModR(Reg(7, Operand::REG, r.getBit()), r, 0x0f, 0xc7); }
1966  	void rorx(const Reg32e& r, const Operand& op, uint8 imm) { opGpr(r, op, Reg32e(0, r.getBit()), MM_0F3A | PP_F2, 0xF0, false, imm); }
1967  	enum { NONE = 256 };
1968  	CodeGenerator(size_t maxSize = DEFAULT_MAX_CODE_SIZE, void *userPtr = 0, Allocator *allocator = 0)
1969  		: CodeArray(maxSize, userPtr, allocator)
1970  		, mm0(0), mm1(1), mm2(2), mm3(3), mm4(4), mm5(5), mm6(6), mm7(7)
1971  		, xmm0(0), xmm1(1), xmm2(2), xmm3(3), xmm4(4), xmm5(5), xmm6(6), xmm7(7)
1972  		, ymm0(0), ymm1(1), ymm2(2), ymm3(3), ymm4(4), ymm5(5), ymm6(6), ymm7(7)
1973  		, xm0(xmm0), xm1(xmm1), xm2(xmm2), xm3(xmm3), xm4(xmm4), xm5(xmm5), xm6(xmm6), xm7(xmm7) 
1974  		, ym0(ymm0), ym1(ymm1), ym2(ymm2), ym3(ymm3), ym4(ymm4), ym5(ymm5), ym6(ymm6), ym7(ymm7) 
1975  		, eax(Operand::EAX), ecx(Operand::ECX), edx(Operand::EDX), ebx(Operand::EBX), esp(Operand::ESP), ebp(Operand::EBP), esi(Operand::ESI), edi(Operand::EDI)
1976  		, ax(Operand::AX), cx(Operand::CX), dx(Operand::DX), bx(Operand::BX), sp(Operand::SP), bp(Operand::BP), si(Operand::SI), di(Operand::DI)
1977  		, al(Operand::AL), cl(Operand::CL), dl(Operand::DL), bl(Operand::BL), ah(Operand::AH), ch(Operand::CH), dh(Operand::DH), bh(Operand::BH)
1978  		, ptr(0), byte(8), word(16), dword(32), qword(64)
1979  		, st0(0), st1(1), st2(2), st3(3), st4(4), st5(5), st6(6), st7(7)
1980  #ifdef XBYAK64
1981  		, rax(Operand::RAX), rcx(Operand::RCX), rdx(Operand::RDX), rbx(Operand::RBX), rsp(Operand::RSP), rbp(Operand::RBP), rsi(Operand::RSI), rdi(Operand::RDI), r8(Operand::R8), r9(Operand::R9), r10(Operand::R10), r11(Operand::R11), r12(Operand::R12), r13(Operand::R13), r14(Operand::R14), r15(Operand::R15)
1982  		, r8d(Operand::R8D), r9d(Operand::R9D), r10d(Operand::R10D), r11d(Operand::R11D), r12d(Operand::R12D), r13d(Operand::R13D), r14d(Operand::R14D), r15d(Operand::R15D)
1983  		, r8w(Operand::R8W), r9w(Operand::R9W), r10w(Operand::R10W), r11w(Operand::R11W), r12w(Operand::R12W), r13w(Operand::R13W), r14w(Operand::R14W), r15w(Operand::R15W)
1984  		, r8b(Operand::R8B), r9b(Operand::R9B), r10b(Operand::R10B), r11b(Operand::R11B), r12b(Operand::R12B), r13b(Operand::R13B), r14b(Operand::R14B), r15b(Operand::R15B)
1985  		, spl(Operand::SPL, true), bpl(Operand::BPL, true), sil(Operand::SIL, true), dil(Operand::DIL, true)
1986  		, xmm8(8), xmm9(9), xmm10(10), xmm11(11), xmm12(12), xmm13(13), xmm14(14), xmm15(15)
1987  		, ymm8(8), ymm9(9), ymm10(10), ymm11(11), ymm12(12), ymm13(13), ymm14(14), ymm15(15)
1988  		, xm8(xmm8), xm9(xmm9), xm10(xmm10), xm11(xmm11), xm12(xmm12), xm13(xmm13), xm14(xmm14), xm15(xmm15) 
1989  		, ym8(ymm8), ym9(ymm9), ym10(ymm10), ym11(ymm11), ym12(ymm12), ym13(ymm13), ym14(ymm14), ym15(ymm15) 
1990  		, rip()
1991  #endif
1992  #ifndef XBYAK_DISABLE_SEGMENT
1993  		, es(Segment::es), cs(Segment::cs), ss(Segment::ss), ds(Segment::ds), fs(Segment::fs), gs(Segment::gs)
1994  #endif
1995  	{
1996  		labelMgr_.set(this);
1997  	}
1998  	void reset()
1999  	{
2000  		resetSize();
2001  		labelMgr_.reset();
2002  		labelMgr_.set(this);
2003  	}
2004  	bool hasUndefinedLabel() const { return labelMgr_.hasUndefSlabel() || labelMgr_.hasUndefClabel(); }
2005  	void ready()
2006  	{
2007  		if (hasUndefinedLabel()) throw Error(ERR_LABEL_IS_NOT_FOUND);
2008  		calcJmpAddress();
2009  	}
2010  #ifdef XBYAK_TEST
2011  	void dump(bool doClear = true)
2012  	{
2013  		CodeArray::dump();
2014  		if (doClear) size_ = 0;
2015  	}
2016  #endif
2017  #ifndef XBYAK_DONT_READ_LIST
2018  #include "xbyak_mnemonic.h"
2019  	void align(int x = 16)
2020  	{
2021  		if (x == 1) return;
2022  		if (x < 1 || (x & (x - 1))) throw Error(ERR_BAD_ALIGN);
2023  		if (isAutoGrow() && x > (int)inner::ALIGN_PAGE_SIZE) fprintf(stderr, "warning:autoGrow mode does not support %d align\n", x);
2024  		while (size_t(getCurr()) % x) {
2025  			nop();
2026  		}
2027  	}
2028  #endif
2029  };
2030  namespace util {
2031  static const Mmx mm0(0), mm1(1), mm2(2), mm3(3), mm4(4), mm5(5), mm6(6), mm7(7);
2032  static const Xmm xmm0(0), xmm1(1), xmm2(2), xmm3(3), xmm4(4), xmm5(5), xmm6(6), xmm7(7);
2033  static const Ymm ymm0(0), ymm1(1), ymm2(2), ymm3(3), ymm4(4), ymm5(5), ymm6(6), ymm7(7);
2034  static const Reg32 eax(Operand::EAX), ecx(Operand::ECX), edx(Operand::EDX), ebx(Operand::EBX), esp(Operand::ESP), ebp(Operand::EBP), esi(Operand::ESI), edi(Operand::EDI);
2035  static const Reg16 ax(Operand::AX), cx(Operand::CX), dx(Operand::DX), bx(Operand::BX), sp(Operand::SP), bp(Operand::BP), si(Operand::SI), di(Operand::DI);
2036  static const Reg8 al(Operand::AL), cl(Operand::CL), dl(Operand::DL), bl(Operand::BL), ah(Operand::AH), ch(Operand::CH), dh(Operand::DH), bh(Operand::BH);
2037  static const AddressFrame ptr(0), byte(8), word(16), dword(32), qword(64);
2038  static const Fpu st0(0), st1(1), st2(2), st3(3), st4(4), st5(5), st6(6), st7(7);
2039  #ifdef XBYAK64
2040  static const Reg64 rax(Operand::RAX), rcx(Operand::RCX), rdx(Operand::RDX), rbx(Operand::RBX), rsp(Operand::RSP), rbp(Operand::RBP), rsi(Operand::RSI), rdi(Operand::RDI), r8(Operand::R8), r9(Operand::R9), r10(Operand::R10), r11(Operand::R11), r12(Operand::R12), r13(Operand::R13), r14(Operand::R14), r15(Operand::R15);
2041  static const Reg32 r8d(Operand::R8D), r9d(Operand::R9D), r10d(Operand::R10D), r11d(Operand::R11D), r12d(Operand::R12D), r13d(Operand::R13D), r14d(Operand::R14D), r15d(Operand::R15D);
2042  static const Reg16 r8w(Operand::R8W), r9w(Operand::R9W), r10w(Operand::R10W), r11w(Operand::R11W), r12w(Operand::R12W), r13w(Operand::R13W), r14w(Operand::R14W), r15w(Operand::R15W);
2043  static const Reg8 r8b(Operand::R8B), r9b(Operand::R9B), r10b(Operand::R10B), r11b(Operand::R11B), r12b(Operand::R12B), r13b(Operand::R13B), r14b(Operand::R14B), r15b(Operand::R15B), spl(Operand::SPL, 1), bpl(Operand::BPL, 1), sil(Operand::SIL, 1), dil(Operand::DIL, 1);
2044  static const Xmm xmm8(8), xmm9(9), xmm10(10), xmm11(11), xmm12(12), xmm13(13), xmm14(14), xmm15(15);
2045  static const Ymm ymm8(8), ymm9(9), ymm10(10), ymm11(11), ymm12(12), ymm13(13), ymm14(14), ymm15(15);
2046  static const RegRip rip;
2047  #endif
2048  #ifndef XBYAK_DISABLE_SEGMENT
2049  static const Segment es(Segment::es), cs(Segment::cs), ss(Segment::ss), ds(Segment::ds), fs(Segment::fs), gs(Segment::gs);
2050  #endif
2051  } 
2052  #ifdef _MSC_VER
2053  	#pragma warning(pop)
2054  #endif
2055  } 
2056  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-common_40.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-xbyak.h</div>
                </div>
                <div class="column column_space"><pre><code>46  	}
47  	boost::system::error_code address_ec;
48  	address_a = boost::asio::ip::make_address (address_text, address_ec);
49  	return !!address_ec;
50  }
51  bool nano::parse_address_port (std::string const & string, boost::asio::ip::address & address_a, uint16_t & port_a)
</pre></code></div>
                <div class="column column_space"><pre><code>326  		if (isExt8bit()) return false;
327  		const int idx = getIdx();
328  		return AH <= idx && idx <= BH;
329  	}
330  	bool is(int kind, uint32 bit = 0) const
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    