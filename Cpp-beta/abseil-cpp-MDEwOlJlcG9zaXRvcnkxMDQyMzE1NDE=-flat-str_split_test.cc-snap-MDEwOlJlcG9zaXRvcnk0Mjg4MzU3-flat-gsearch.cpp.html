
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.451084082496035%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_split_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_split.h"
2  #include <deque>
3  #include <initializer_list>
4  #include <list>
5  #include <map>
6  #include <memory>
7  #include <string>
8  #include <type_traits>
9  #include <unordered_map>
10  #include <unordered_set>
11  #include <vector>
12  #include "gmock/gmock.h"
13  #include "gtest/gtest.h"
14  #include "absl/base/dynamic_annotations.h"
15  #include "absl/base/macros.h"
16  #include "absl/container/btree_map.h"
17  #include "absl/container/btree_set.h"
18  #include "absl/container/flat_hash_map.h"
19  #include "absl/container/node_hash_map.h"
20  #include "absl/strings/numbers.h"
21  namespace {
22  using ::testing::ElementsAre;
23  using ::testing::Pair;
24  using ::testing::UnorderedElementsAre;
25  TEST(Split, TraitsTest) {
26    static_assert(!absl::strings_internal::SplitterIsConvertibleTo<int>::value,
27                  "");
28    static_assert(
29        !absl::strings_internal::SplitterIsConvertibleTo<std::string>::value, "");
30    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
31                      std::vector<std::string>>::value,
32                  "");
33    static_assert(
34        !absl::strings_internal::SplitterIsConvertibleTo<std::vector<int>>::value,
35        "");
36    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
37                      std::vector<absl::string_view>>::value,
38                  "");
39    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
40                      std::map<std::string, std::string>>::value,
41                  "");
42    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
43                      std::map<absl::string_view, absl::string_view>>::value,
44                  "");
45    static_assert(!absl::strings_internal::SplitterIsConvertibleTo<
46                      std::map<int, std::string>>::value,
47                  "");
48    static_assert(!absl::strings_internal::SplitterIsConvertibleTo<
49                      std::map<std::string, int>>::value,
50                  "");
51  }
52  TEST(Split, APIExamples) {
53    {
54      std::vector<std::string> v = absl::StrSplit("a,b,c", ",");  
55      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
56      using absl::ByString;
57      v = absl::StrSplit("a,b,c", ByString(","));
58      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
59      EXPECT_THAT(absl::StrSplit("a,b,c", ByString(",")),
60                  ElementsAre("a", "b", "c"));
61    }
62    {
63      std::vector<std::string> v = absl::StrSplit("a,b,c", ',');
64      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
65      using absl::ByChar;
66      v = absl::StrSplit("a,b,c", ByChar(','));
67      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
68    }
69    {
70      const std::vector<std::string> v = absl::StrSplit("a=>b=>c", "=>");
71      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
72    }
73    {
74      std::vector<absl::string_view> v = absl::StrSplit("a,b,c", ',');
75      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
76    }
77    {
78      std::vector<std::string> v = absl::StrSplit(",a,b,c,", ',');
79      EXPECT_THAT(v, ElementsAre("", "a", "b", "c", ""));
80    }
81    {
82      std::vector<std::string> v = absl::StrSplit("abc", ',');
83      EXPECT_THAT(v, ElementsAre("abc"));
84    }
85    {
86      std::vector<std::string> v = absl::StrSplit("abc", "");
87      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
88    }
89    {
90      std::string embedded_nulls("a\0b\0c", 5);
91      std::string null_delim("\0", 1);
92      std::vector<std::string> v = absl::StrSplit(embedded_nulls, null_delim);
93      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
94    }
95    {
96      std::pair<std::string, std::string> p = absl::StrSplit("a,b,c", ',');
97      EXPECT_EQ("a", p.first);
98      EXPECT_EQ("b", p.second);
99    }
100    {
101      std::set<std::string> v = absl::StrSplit("a,b,c,a,b,c,a,b,c", ',');
102      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
103    }
104    {
105      char a[] = ",";
106      char* d = a + 0;
107      std::vector<std::string> v = absl::StrSplit("a,b,c", d);
108      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
109    }
110    {
111      using absl::ByAnyChar;
112      std::vector<std::string> v = absl::StrSplit("a,b;c", ByAnyChar(",;"));
113      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
114    }
115    {
116      using absl::SkipWhitespace;
117      std::vector<std::string> v =
118          absl::StrSplit(" a , ,,b,", ',', SkipWhitespace());
119      EXPECT_THAT(v, ElementsAre(" a ", "b"));
120    }
121    {
122      using absl::ByLength;
123      std::vector<std::string> v = absl::StrSplit("abcdefg", ByLength(3));
124      EXPECT_THAT(v, ElementsAre("abc", "def", "g"));
125    }
126    {
127      std::vector<std::string> v1 = absl::StrSplit("a,b,c", ',');
128      EXPECT_THAT(v1, ElementsAre("a", "b", "c"));
129      std::vector<std::string> v2(absl::StrSplit("a,b,c", ','));
130      EXPECT_THAT(v2, ElementsAre("a", "b", "c"));
131      auto v3 = std::vector<std::string>(absl::StrSplit("a,b,c", ','));
132      EXPECT_THAT(v3, ElementsAre("a", "b", "c"));
133      v3 = absl::StrSplit("a,b,c", ',');
134      EXPECT_THAT(v3, ElementsAre("a", "b", "c"));
135    }
136    {
137      std::map<std::string, std::string> m = absl::StrSplit("a,1,b,2,a,3", ',');
138      EXPECT_EQ(2, m.size());
139      EXPECT_EQ("3", m["a"]);
140      EXPECT_EQ("2", m["b"]);
141    }
142    {
143      std::multimap<std::string, std::string> m =
144          absl::StrSplit("a,1,b,2,a,3", ',');
145      EXPECT_EQ(3, m.size());
146      auto it = m.find("a");
147      EXPECT_EQ("1", it->second);
148      ++it;
149      EXPECT_EQ("3", it->second);
150      it = m.find("b");
151      EXPECT_EQ("2", it->second);
152    }
153    {
154      std::string s = "x,x,x,x,x,x,x";
155      for (absl::string_view sp : absl::StrSplit(s, ',')) {
156        EXPECT_EQ("x", sp);
157      }
158    }
159    {
160      using absl::SkipWhitespace;
161      std::string s = " ,x,,x,,x,x,x,,";
162      for (absl::string_view sp : absl::StrSplit(s, ',', SkipWhitespace())) {
163        EXPECT_EQ("x", sp);
164      }
165    }
166    {
167      std::map<std::string, std::string> m;
168      for (absl::string_view sp : absl::StrSplit("a=b=c,d=e,f=,g", ',')) {
169        m.insert(absl::StrSplit(sp, absl::MaxSplits('=', 1)));
170      }
171      EXPECT_EQ("b=c", m.find("a")->second);
172      EXPECT_EQ("e", m.find("d")->second);
173      EXPECT_EQ("", m.find("f")->second);
174      EXPECT_EQ("", m.find("g")->second);
175    }
176  }
177  TEST(SplitIterator, Basics) {
178    auto splitter = absl::StrSplit("a,b", ',');
179    auto it = splitter.begin();
180    auto end = splitter.end();
181    EXPECT_NE(it, end);
182    EXPECT_EQ("a", *it);  
183    ++it;                 
184    EXPECT_NE(it, end);
185    EXPECT_EQ("b",
186              std::string(it->data(), it->size()));  
187    it++;                                            
188    EXPECT_EQ(it, end);
189  }
190  class Skip {
191   public:
192    explicit Skip(const std::string& s) : s_(s) {}
193    bool operator()(absl::string_view sp) { return sp != s_; }
194   private:
195    std::string s_;
196  };
197  TEST(SplitIterator, Predicate) {
198    auto splitter = absl::StrSplit("a,b,c", ',', Skip("b"));
199    auto it = splitter.begin();
200    auto end = splitter.end();
201    EXPECT_NE(it, end);
202    EXPECT_EQ("a", *it);  
203    ++it;                 
204    EXPECT_NE(it, end);
205    EXPECT_EQ("c",
206              std::string(it->data(), it->size()));  
207    it++;                                            
208    EXPECT_EQ(it, end);
209  }
210  TEST(SplitIterator, EdgeCases) {
211    struct {
212      std::string in;
213      std::vector<std::string> expect;
214    } specs[] = {
215        {"", {""}},
216        {"foo", {"foo"}},
217        {",", {"", ""}},
218        {",foo", {"", "foo"}},
219        {"foo,", {"foo", ""}},
220        {",foo,", {"", "foo", ""}},
221        {"foo,bar", {"foo", "bar"}},
222    };
223    for (const auto& spec : specs) {
224      SCOPED_TRACE(spec.in);
225      auto splitter = absl::StrSplit(spec.in, ',');
226      auto it = splitter.begin();
227      auto end = splitter.end();
228      for (const auto& expected : spec.expect) {
229        EXPECT_NE(it, end);
230        EXPECT_EQ(expected, *it++);
231      }
232      EXPECT_EQ(it, end);
233    }
234  }
235  TEST(Splitter, Const) {
236    const auto splitter = absl::StrSplit("a,b,c", ',');
237    EXPECT_THAT(splitter, ElementsAre("a", "b", "c"));
238  }
239  TEST(Split, EmptyAndNull) {
240    EXPECT_THAT(absl::StrSplit(absl::string_view(""), '-'), ElementsAre(""));
241    EXPECT_THAT(absl::StrSplit(absl::string_view(), '-'), ElementsAre());
242  }
243  TEST(SplitIterator, EqualityAsEndCondition) {
244    auto splitter = absl::StrSplit("a,b,c", ',');
245    auto it = splitter.begin();
246    auto it2 = it;
247    ++it2;
248    ++it2;
249    EXPECT_EQ("c", *it2);
250    std::vector<absl::string_view> v;
251    for (; it != it2; ++it) {
252      v.push_back(*it);
253    }
254    EXPECT_THAT(v, ElementsAre("a", "b"));
255  }
256  TEST(Splitter, RangeIterators) {
257    auto splitter = absl::StrSplit("a,b,c", ',');
258    std::vector<absl::string_view> output;
259    for (absl::string_view p : splitter) {
260      output.push_back(p);
261    }
262    EXPECT_THAT(output, ElementsAre("a", "b", "c"));
263  }
264  template <typename ContainerType, typename Splitter>
265  void TestConversionOperator(const Splitter& splitter) {
266    ContainerType output = splitter;
267    EXPECT_THAT(output, UnorderedElementsAre("a", "b", "c", "d"));
268  }
269  template <typename MapType, typename Splitter>
270  void TestMapConversionOperator(const Splitter& splitter) {
271    MapType m = splitter;
272    EXPECT_THAT(m, UnorderedElementsAre(Pair("a", "b"), Pair("c", "d")));
273  }
274  template <typename FirstType, typename SecondType, typename Splitter>
275  void TestPairConversionOperator(const Splitter& splitter) {
276    std::pair<FirstType, SecondType> p = splitter;
277    EXPECT_EQ(p, (std::pair<FirstType, SecondType>("a", "b")));
278  }
279  TEST(Splitter, ConversionOperator) {
280    auto splitter = absl::StrSplit("a,b,c,d", ',');
281    TestConversionOperator<std::vector<absl::string_view>>(splitter);
282    TestConversionOperator<std::vector<std::string>>(splitter);
283    TestConversionOperator<std::list<absl::string_view>>(splitter);
284    TestConversionOperator<std::list<std::string>>(splitter);
285    TestConversionOperator<std::deque<absl::string_view>>(splitter);
286    TestConversionOperator<std::deque<std::string>>(splitter);
287    TestConversionOperator<std::set<absl::string_view>>(splitter);
288    TestConversionOperator<std::set<std::string>>(splitter);
289    TestConversionOperator<std::multiset<absl::string_view>>(splitter);
290    TestConversionOperator<std::multiset<std::string>>(splitter);
291    TestConversionOperator<absl::btree_set<absl::string_view>>(splitter);
292    TestConversionOperator<absl::btree_set<std::string>>(splitter);
293    TestConversionOperator<absl::btree_multiset<absl::string_view>>(splitter);
294    TestConversionOperator<absl::btree_multiset<std::string>>(splitter);
295    TestConversionOperator<std::unordered_set<std::string>>(splitter);
296    TestMapConversionOperator<std::map<absl::string_view, absl::string_view>>(
297        splitter);
298    TestMapConversionOperator<std::map<absl::string_view, std::string>>(splitter);
299    TestMapConversionOperator<std::map<std::string, absl::string_view>>(splitter);
300    TestMapConversionOperator<std::map<std::string, std::string>>(splitter);
301    TestMapConversionOperator<
302        std::multimap<absl::string_view, absl::string_view>>(splitter);
303    TestMapConversionOperator<std::multimap<absl::string_view, std::string>>(
304        splitter);
305    TestMapConversionOperator<std::multimap<std::string, absl::string_view>>(
306        splitter);
307    TestMapConversionOperator<std::multimap<std::string, std::string>>(splitter);
308    TestMapConversionOperator<
309        absl::btree_map<absl::string_view, absl::string_view>>(splitter);
310    TestMapConversionOperator<absl::btree_map<absl::string_view, std::string>>(
311        splitter);
312    TestMapConversionOperator<absl::btree_map<std::string, absl::string_view>>(
313        splitter);
314    TestMapConversionOperator<absl::btree_map<std::string, std::string>>(
315        splitter);
316    TestMapConversionOperator<
317        absl::btree_multimap<absl::string_view, absl::string_view>>(splitter);
318    TestMapConversionOperator<
319        absl::btree_multimap<absl::string_view, std::string>>(splitter);
320    TestMapConversionOperator<
321        absl::btree_multimap<std::string, absl::string_view>>(splitter);
322    TestMapConversionOperator<absl::btree_multimap<std::string, std::string>>(
323        splitter);
324    TestMapConversionOperator<std::unordered_map<std::string, std::string>>(
325        splitter);
326    TestMapConversionOperator<
327        absl::node_hash_map<absl::string_view, absl::string_view>>(splitter);
328    TestMapConversionOperator<
329        absl::node_hash_map<absl::string_view, std::string>>(splitter);
330    TestMapConversionOperator<
331        absl::node_hash_map<std::string, absl::string_view>>(splitter);
332    TestMapConversionOperator<
333        absl::flat_hash_map<absl::string_view, absl::string_view>>(splitter);
334    TestMapConversionOperator<
335        absl::flat_hash_map<absl::string_view, std::string>>(splitter);
336    TestMapConversionOperator<
337        absl::flat_hash_map<std::string, absl::string_view>>(splitter);
338    TestPairConversionOperator<absl::string_view, absl::string_view>(splitter);
339    TestPairConversionOperator<absl::string_view, std::string>(splitter);
340    TestPairConversionOperator<std::string, absl::string_view>(splitter);
341    TestPairConversionOperator<std::string, std::string>(splitter);
342  }
343  TEST(Splitter, ToPair) {
344    {
345      std::pair<std::string, std::string> p = absl::StrSplit("", ',');
346      EXPECT_EQ("", p.first);
347      EXPECT_EQ("", p.second);
348    }
349    {
350      std::pair<std::string, std::string> p = absl::StrSplit("a", ',');
351      EXPECT_EQ("a", p.first);
352      EXPECT_EQ("", p.second);
353    }
354    {
355      std::pair<std::string, std::string> p = absl::StrSplit(",b", ',');
356      EXPECT_EQ("", p.first);
357      EXPECT_EQ("b", p.second);
358    }
359    {
360      std::pair<std::string, std::string> p = absl::StrSplit("a,b", ',');
361      EXPECT_EQ("a", p.first);
362      EXPECT_EQ("b", p.second);
363    }
364    {
365      std::pair<std::string, std::string> p = absl::StrSplit("a,b,c", ',');
366      EXPECT_EQ("a", p.first);
367      EXPECT_EQ("b", p.second);
368    }
369  }
370  TEST(Splitter, Predicates) {
371    static const char kTestChars[] = ",a, ,b,";
372    using absl::AllowEmpty;
373    using absl::SkipEmpty;
374    using absl::SkipWhitespace;
375    {
376      auto splitter = absl::StrSplit(kTestChars, ',');
377      std::vector<std::string> v = splitter;
378      EXPECT_THAT(v, ElementsAre("", "a", " ", "b", ""));
379    }
380    {
381      auto splitter = absl::StrSplit(kTestChars, ',', AllowEmpty());
382      std::vector<std::string> v_allowempty = splitter;
383      EXPECT_THAT(v_allowempty, ElementsAre("", "a", " ", "b", ""));
384      auto splitter_nopredicate = absl::StrSplit(kTestChars, ',');
385      std::vector<std::string> v_nopredicate = splitter_nopredicate;
386      EXPECT_EQ(v_allowempty, v_nopredicate);
387    }
388    {
389      auto splitter = absl::StrSplit(kTestChars, ',', SkipEmpty());
390      std::vector<std::string> v = splitter;
391      EXPECT_THAT(v, ElementsAre("a", " ", "b"));
392    }
393    {
394      auto splitter = absl::StrSplit(kTestChars, ',', SkipWhitespace());
395      std::vector<std::string> v = splitter;
396      EXPECT_THAT(v, ElementsAre("a", "b"));
397    }
398  }
399  TEST(Split, Basics) {
400    {
401      absl::StrSplit("a,b,c", ',');
402    }
403    {
404      std::vector<absl::string_view> v = absl::StrSplit("a,b,c", ',');
405      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
406    }
407    {
408      std::vector<std::string> v = absl::StrSplit("a,b,c", ',');
409      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
410    }
411    {
412      std::vector<std::string> v;
413      v = absl::StrSplit("a,b,c", ',');
414      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
415      std::map<std::string, std::string> m;
416      m = absl::StrSplit("a,b,c", ',');
417      EXPECT_EQ(2, m.size());
418      std::unordered_map<std::string, std::string> hm;
419      hm = absl::StrSplit("a,b,c", ',');
420      EXPECT_EQ(2, hm.size());
421    }
422  }
423  absl::string_view ReturnStringView() { return "Hello World"; }
424  const char* ReturnConstCharP() { return "Hello World"; }
425  char* ReturnCharP() { return const_cast<char*>("Hello World"); }
426  TEST(Split, AcceptsCertainTemporaries) {
427    std::vector<std::string> v;
428    v = absl::StrSplit(ReturnStringView(), ' ');
429    EXPECT_THAT(v, ElementsAre("Hello", "World"));
430    v = absl::StrSplit(ReturnConstCharP(), ' ');
431    EXPECT_THAT(v, ElementsAre("Hello", "World"));
432    v = absl::StrSplit(ReturnCharP(), ' ');
433    EXPECT_THAT(v, ElementsAre("Hello", "World"));
434  }
435  TEST(Split, Temporary) {
436    const char input[] = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u";
437    EXPECT_LT(sizeof(std::string), ABSL_ARRAYSIZE(input))
438        << "Input should be larger than fits on the stack.";
439    auto splitter = absl::StrSplit(std::string(input), ',');
440    std::string expected = "a";
441    for (absl::string_view letter : splitter) {
442      EXPECT_EQ(expected, letter);
443      ++expected[0];
444    }
445    EXPECT_EQ("v", expected);
446    auto std_splitter = absl::StrSplit(std::string(input), ',');
447    expected = "a";
448    for (absl::string_view letter : std_splitter) {
449      EXPECT_EQ(expected, letter);
450      ++expected[0];
451    }
452    EXPECT_EQ("v", expected);
453  }
454  template <typename T>
455  static std::unique_ptr<T> CopyToHeap(const T& value) {
456    return std::unique_ptr<T>(new T(value));
457  }
458  TEST(Split, LvalueCaptureIsCopyable) {
459    std::string input = "a,b";
460    auto heap_splitter = CopyToHeap(absl::StrSplit(input, ','));
461    auto stack_splitter = *heap_splitter;
462    heap_splitter.reset();
463    std::vector<std::string> result = stack_splitter;
464    EXPECT_THAT(result, testing::ElementsAre("a", "b"));
465  }
466  TEST(Split, TemporaryCaptureIsCopyable) {
467    auto heap_splitter = CopyToHeap(absl::StrSplit(std::string("a,b"), ','));
468    auto stack_splitter = *heap_splitter;
469    heap_splitter.reset();
470    std::vector<std::string> result = stack_splitter;
471    EXPECT_THAT(result, testing::ElementsAre("a", "b"));
472  }
473  TEST(Split, SplitterIsCopyableAndMoveable) {
474    auto a = absl::StrSplit("foo", '-');
475    auto b = a;             
476    auto c = std::move(a);  
477    b = c;                  
478    c = std::move(b);       
479    EXPECT_THAT(c, ElementsAre("foo"));
480  }
481  TEST(Split, StringDelimiter) {
482    {
483      std::vector<absl::string_view> v = absl::StrSplit("a,b", ',');
484      EXPECT_THAT(v, ElementsAre("a", "b"));
485    }
486    {
487      std::vector<absl::string_view> v = absl::StrSplit("a,b", std::string(","));
488      EXPECT_THAT(v, ElementsAre("a", "b"));
489    }
490    {
491      std::vector<absl::string_view> v =
492          absl::StrSplit("a,b", absl::string_view(","));
493      EXPECT_THAT(v, ElementsAre("a", "b"));
494    }
495  }
496  #if !defined(__cpp_char8_t)
497  #if defined(__clang__)
498  #pragma clang diagnostic push
499  #pragma clang diagnostic ignored "-Wc++2a-compat"
500  #endif
501  TEST(Split, UTF8) {
502    std::string utf8_string = u8"\u03BA\u1F79\u03C3\u03BC\u03B5";
503    {
504      std::string to_split = "a," + utf8_string;
505      std::vector<absl::string_view> v = absl::StrSplit(to_split, ',');
506      EXPECT_THAT(v, ElementsAre("a", utf8_string));
507    }
508    {
509      std::string to_split = "a," + utf8_string + ",b";
510      std::string unicode_delimiter = "," + utf8_string + ",";
511      std::vector<absl::string_view> v =
512          absl::StrSplit(to_split, unicode_delimiter);
513      EXPECT_THAT(v, ElementsAre("a", "b"));
514    }
515    {
516      std::vector<absl::string_view> v =
517          absl::StrSplit(u8"Foo h\u00E4llo th\u4E1Ere", absl::ByAnyChar(" \t"));
518      EXPECT_THAT(v, ElementsAre("Foo", u8"h\u00E4llo", u8"th\u4E1Ere"));
519    }
520  }
521  #if defined(__clang__)
522  #pragma clang diagnostic pop
523  #endif
524  #endif  
525  TEST(Split, EmptyStringDelimiter) {
526    {
527      std::vector<std::string> v = absl::StrSplit("", "");
528      EXPECT_THAT(v, ElementsAre(""));
529    }
530    {
531      std::vector<std::string> v = absl::StrSplit("a", "");
532      EXPECT_THAT(v, ElementsAre("a"));
533    }
534    {
535      std::vector<std::string> v = absl::StrSplit("ab", "");
536      EXPECT_THAT(v, ElementsAre("a", "b"));
537    }
538    {
539      std::vector<std::string> v = absl::StrSplit("a b", "");
<span onclick='openModal()' class='match'>540      EXPECT_THAT(v, ElementsAre("a", " ", "b"));
541    }
542  }
543  TEST(Split, SubstrDelimiter) {
544    std::vector<absl::string_view> results;
545    absl::string_view delim("&bsol;&bsol;");
546    results = absl::StrSplit("", delim);
547    EXPECT_THAT(results, ElementsAre(""));
</span>548    results = absl::StrSplit("&bsol;&bsol;", delim);
549    EXPECT_THAT(results, ElementsAre("", ""));
550    results = absl::StrSplit("ab", delim);
551    EXPECT_THAT(results, ElementsAre("ab"));
552    results = absl::StrSplit("ab
553    EXPECT_THAT(results, ElementsAre("ab", ""));
554    results = absl::StrSplit("ab/", delim);
555    EXPECT_THAT(results, ElementsAre("ab/"));
556    results = absl::StrSplit("a/b", delim);
557    EXPECT_THAT(results, ElementsAre("a/b"));
558    results = absl::StrSplit("a
559    EXPECT_THAT(results, ElementsAre("a", "b"));
560    results = absl::StrSplit("a
561    EXPECT_THAT(results, ElementsAre("a", "/b"));
562    results = absl::StrSplit("a
563    EXPECT_THAT(results, ElementsAre("a", "", "b"));
564  }
565  TEST(Split, EmptyResults) {
566    std::vector<absl::string_view> results;
567    results = absl::StrSplit("", '#');
568    EXPECT_THAT(results, ElementsAre(""));
569    results = absl::StrSplit("#", '#');
570    EXPECT_THAT(results, ElementsAre("", ""));
571    results = absl::StrSplit("#cd", '#');
572    EXPECT_THAT(results, ElementsAre("", "cd"));
573    results = absl::StrSplit("ab#cd#", '#');
574    EXPECT_THAT(results, ElementsAre("ab", "cd", ""));
575    results = absl::StrSplit("ab##cd", '#');
576    EXPECT_THAT(results, ElementsAre("ab", "", "cd"));
577    results = absl::StrSplit("ab##", '#');
578    EXPECT_THAT(results, ElementsAre("ab", "", ""));
579    results = absl::StrSplit("ab#ab#", '#');
580    EXPECT_THAT(results, ElementsAre("ab", "ab", ""));
581    results = absl::StrSplit("aaaa", 'a');
582    EXPECT_THAT(results, ElementsAre("", "", "", "", ""));
583    results = absl::StrSplit("", '#', absl::SkipEmpty());
584    EXPECT_THAT(results, ElementsAre());
585  }
586  template <typename Delimiter>
587  static bool IsFoundAtStartingPos(absl::string_view text, Delimiter d,
588                                   size_t starting_pos, int expected_pos) {
589    absl::string_view found = d.Find(text, starting_pos);
590    return found.data() != text.data() + text.size() &&
591           expected_pos == found.data() - text.data();
592  }
593  template <typename Delimiter>
594  static bool IsFoundAt(absl::string_view text, Delimiter d, int expected_pos) {
595    const std::string leading_text = ",x,y,z,";
596    return IsFoundAtStartingPos(text, d, 0, expected_pos) &&
597           IsFoundAtStartingPos(leading_text + std::string(text), d,
598                                leading_text.length(),
599                                expected_pos + leading_text.length());
600  }
601  template <typename Delimiter>
602  void TestComma(Delimiter d) {
603    EXPECT_TRUE(IsFoundAt(",", d, 0));
604    EXPECT_TRUE(IsFoundAt("a,", d, 1));
605    EXPECT_TRUE(IsFoundAt(",b", d, 0));
606    EXPECT_TRUE(IsFoundAt("a,b", d, 1));
607    EXPECT_TRUE(IsFoundAt("a,b,", d, 1));
608    EXPECT_TRUE(IsFoundAt("a,b,c", d, 1));
609    EXPECT_FALSE(IsFoundAt("", d, -1));
610    EXPECT_FALSE(IsFoundAt(" ", d, -1));
611    EXPECT_FALSE(IsFoundAt("a", d, -1));
612    EXPECT_FALSE(IsFoundAt("a b c", d, -1));
613    EXPECT_FALSE(IsFoundAt("a;b;c", d, -1));
614    EXPECT_FALSE(IsFoundAt(";", d, -1));
615  }
616  TEST(Delimiter, ByString) {
617    using absl::ByString;
618    TestComma(ByString(","));
619    ByString comma_string(",");
620    TestComma(comma_string);
621    absl::string_view abc("abc");
622    EXPECT_EQ(0, abc.find(""));  
623    ByString empty("");
624    EXPECT_FALSE(IsFoundAt("", empty, 0));
625    EXPECT_FALSE(IsFoundAt("a", empty, 0));
626    EXPECT_TRUE(IsFoundAt("ab", empty, 1));
627    EXPECT_TRUE(IsFoundAt("abc", empty, 1));
628  }
629  TEST(Split, ByChar) {
630    using absl::ByChar;
631    TestComma(ByChar(','));
632    ByChar comma_char(',');
633    TestComma(comma_char);
634  }
635  TEST(Delimiter, ByAnyChar) {
636    using absl::ByAnyChar;
637    ByAnyChar one_delim(",");
638    EXPECT_TRUE(IsFoundAt(",", one_delim, 0));
639    EXPECT_TRUE(IsFoundAt("a,", one_delim, 1));
640    EXPECT_TRUE(IsFoundAt("a,b", one_delim, 1));
641    EXPECT_TRUE(IsFoundAt(",b", one_delim, 0));
642    EXPECT_FALSE(IsFoundAt("", one_delim, -1));
643    EXPECT_FALSE(IsFoundAt(" ", one_delim, -1));
644    EXPECT_FALSE(IsFoundAt("a", one_delim, -1));
645    EXPECT_FALSE(IsFoundAt("a;b;c", one_delim, -1));
646    EXPECT_FALSE(IsFoundAt(";", one_delim, -1));
647    ByAnyChar two_delims(",;");
648    EXPECT_TRUE(IsFoundAt(",", two_delims, 0));
649    EXPECT_TRUE(IsFoundAt(";", two_delims, 0));
650    EXPECT_TRUE(IsFoundAt(",;", two_delims, 0));
651    EXPECT_TRUE(IsFoundAt(";,", two_delims, 0));
652    EXPECT_TRUE(IsFoundAt(",;b", two_delims, 0));
653    EXPECT_TRUE(IsFoundAt(";,b", two_delims, 0));
654    EXPECT_TRUE(IsFoundAt("a;,", two_delims, 1));
655    EXPECT_TRUE(IsFoundAt("a,;", two_delims, 1));
656    EXPECT_TRUE(IsFoundAt("a;,b", two_delims, 1));
657    EXPECT_TRUE(IsFoundAt("a,;b", two_delims, 1));
658    EXPECT_FALSE(IsFoundAt("", two_delims, -1));
659    EXPECT_FALSE(IsFoundAt(" ", two_delims, -1));
660    EXPECT_FALSE(IsFoundAt("a", two_delims, -1));
661    EXPECT_FALSE(IsFoundAt("a=b=c", two_delims, -1));
662    EXPECT_FALSE(IsFoundAt("=", two_delims, -1));
663    ByAnyChar empty("");
664    EXPECT_FALSE(IsFoundAt("", empty, 0));
665    EXPECT_FALSE(IsFoundAt("a", empty, 0));
666    EXPECT_TRUE(IsFoundAt("ab", empty, 1));
667    EXPECT_TRUE(IsFoundAt("abc", empty, 1));
668  }
669  TEST(Delimiter, ByLength) {
670    using absl::ByLength;
671    ByLength four_char_delim(4);
672    EXPECT_TRUE(IsFoundAt("abcde", four_char_delim, 4));
673    EXPECT_TRUE(IsFoundAt("abcdefghijklmnopqrstuvwxyz", four_char_delim, 4));
674    EXPECT_TRUE(IsFoundAt("a b,c\nd", four_char_delim, 4));
675    EXPECT_FALSE(IsFoundAt("", four_char_delim, 0));
676    EXPECT_FALSE(IsFoundAt("a", four_char_delim, 0));
677    EXPECT_FALSE(IsFoundAt("ab", four_char_delim, 0));
678    EXPECT_FALSE(IsFoundAt("abc", four_char_delim, 0));
679    EXPECT_FALSE(IsFoundAt("abcd", four_char_delim, 0));
680  }
681  TEST(Split, WorksWithLargeStrings) {
682  #if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
683      defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
684    constexpr size_t kSize = (uint32_t{1} << 26) + 1;  
685  #else
686    constexpr size_t kSize = (uint32_t{1} << 31) + 1;  
687  #endif
688    if (sizeof(size_t) > 4) {
689      std::string s(kSize, 'x');
690      s.back() = '-';
691      std::vector<absl::string_view> v = absl::StrSplit(s, '-');
692      EXPECT_EQ(2, v.size());
693      EXPECT_EQ('x', v[0][0]);
694      EXPECT_EQ('x', v[0][1]);
695      EXPECT_EQ('x', v[0][3]);
696      EXPECT_EQ("", v[1]);
697    }
698  }
699  TEST(SplitInternalTest, TypeTraits) {
700    EXPECT_FALSE(absl::strings_internal::HasMappedType<int>::value);
701    EXPECT_TRUE(
702        (absl::strings_internal::HasMappedType<std::map<int, int>>::value));
703    EXPECT_FALSE(absl::strings_internal::HasValueType<int>::value);
704    EXPECT_TRUE(
705        (absl::strings_internal::HasValueType<std::map<int, int>>::value));
706    EXPECT_FALSE(absl::strings_internal::HasConstIterator<int>::value);
707    EXPECT_TRUE(
708        (absl::strings_internal::HasConstIterator<std::map<int, int>>::value));
709    EXPECT_FALSE(absl::strings_internal::IsInitializerList<int>::value);
710    EXPECT_TRUE((absl::strings_internal::IsInitializerList<
711                 std::initializer_list<int>>::value));
712  }
713  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</h3>
            <pre><code>1  TStr TGixConst::WdGixFNm = "WdGix";
2  TStr TGixConst::WdGixDatFNm = "WdGix.Dat";
3  TStr TGixConst::WdGixBsFNm = "WdGixBs.MBlobBs";
4  TStr TGixConst::WdGixMDSFNm = "WdGixMDS.Dat";
5  TStr TGixConst::TrGixFNm = "TrGix";
6  TStr TGixConst::TrGixDatFNm = "TrGix.Dat";
7  TStr TGixConst::TrGixDocBsFNm = "TrGixDocBs.MBlobBs";
8  TStr TGixConst::TrGixSentBsFNm = "TrGixSentBs.MBlobBs";
9  TStr TGixConst::TrGixTrAttrBsFNm = "TrGixTrAttrBs.MBlobBs";
10  TStr TGixConst::MWdGixFNm = "MWdGix";
11  TStr TGixConst::MWdGixDatFNm = "MWdGix.Dat";
12  TStr TGixConst::MWdGixDocBsFNm = "MWdGixDocBs.MBlobBs";
13  TStr TGixConst::MWdGixBsFNm = "MWdGixBs.Dat";
14  int TWdGixItem::TitleBit = 0;
15  int TWdGixItem::NmObjBit = 1;
16  int TWdGixItem::AnchorBit = 2;
17  int TWdGixItem::EmphBit = 3;
18  TWdGixItem::TWdGixItem(const TBlobPt& BlobPt, const uchar& _Wgt, const uchar& _WdPos,
19          const bool& TitleP, const bool& NmObjP, const bool& AnchorP, const bool& EmphP):
20              Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()), WdPos(_WdPos) {
21      FSet.SetBit(TitleBit, TitleP);
22      FSet.SetBit(NmObjBit, NmObjP);
23      FSet.SetBit(AnchorBit, AnchorP);
24      FSet.SetBit(EmphBit, EmphP);
25  }
26  TWdGixItem::TWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _Wgt,
27          const uchar& _WdPos, const bool& TitleP, const bool& NmObjP, const bool& AnchorP,
28          const bool& EmphP): Seg(_Seg), Addr(_Addr), Wgt(_Wgt), WdPos(_WdPos) {
29      FSet.SetBit(TitleBit, TitleP);
30      FSet.SetBit(NmObjBit, NmObjP);
31      FSet.SetBit(AnchorBit, AnchorP);
32      FSet.SetBit(EmphBit, EmphP);
33  }
34  TWdGixItem::TWdGixItem(TSIn& SIn) {
35      SIn.Load(Seg); SIn.Load(Addr);
36      SIn.Load(Wgt); SIn.Load(WdPos); FSet=TB8Set(SIn);
37  }
38  void TWdGixItem::Save(TSOut& SOut) const {
39      SOut.Save(Seg); SOut.Save(Addr);
40      SOut.Save(Wgt); SOut.Save(WdPos); FSet.Save(SOut);
41  }
42  inline bool TWdGixItem::operator==(const TWdGixItem& Item) const {
43      return (Seg == Item.Seg) && (Addr == Item.Addr); 
44  }
45  inline bool TWdGixItem::operator<(const TWdGixItem& Item) const {
46      return (Seg < Item.Seg) ||
47          ((Seg == Item.Seg) && (Addr < Item.Addr)); 
48  }
49  void TWdGix::LoadTags() {
50      TitleTagH.AddKey("<TITLE>");
51      NmObjTagH.AddKey("<NMOBJ>");
52      EmphTagH.AddKey("<EM>"); EmphTagH.AddKey("<A>"); EmphTagH.AddKey("<B>");
53      EmphTagH.AddKey("<I>"); EmphTagH.AddKey("<H1>"); EmphTagH.AddKey("<H2>");
54      EmphTagH.AddKey("<H3>"); EmphTagH.AddKey("<H4>"); EmphTagH.AddKey("<H5>");
55  }
56  TWdGix::TWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
57      FPath = _FPath; FAccess = _FAccess;
58      WGix = TWGix::New(TGixConst::WdGixFNm, FPath, FAccess, CacheSize);
59      if (FAccess == faCreate) {
60          Stemmer = TStemmer::New(stmtPorter, false);
61          SwSet = TSwSet::New(swstEn523);
62      } else {
63          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
64          TFIn FIn(WdGixDatFNm);
65          WordH.Load(FIn);
66          Stemmer = TStemmer::Load(FIn);
67          SwSet = TSwSet::Load(FIn);
68      }
69      LoadTags();
70  }
71  TWdGix::~TWdGix() {
72      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
73          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
74          TFOut FOut(WdGixDatFNm);
75          WordH.Save(FOut);
76          Stemmer->Save(FOut);
77          SwSet->Save(FOut);
78      }
79  }
80  void TWdGix::AddHtml(const TStr& HtmlStr, const TBlobPt& BlobPt, const uchar& Wgt) {
81      PSIn HtmlSIn = TStrIn::New(HtmlStr);
82      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
83      THash<TInt, TWdGixItemV> WIdToItemVH; uchar WdPos = 0;
84      bool TitleP = false, NmObjP = false; int EmphLv = 0;
85      while (HtmlLx.Sym != hsyEof) {
86          if (HtmlLx.Sym == hsyStr) {
87              TStr WordStr = HtmlLx.UcChA;
88              if (!SwSet->IsIn(WordStr)) {
89                  WordStr=Stemmer->GetStem(WordStr);
90                  const int WId = WordH.AddKey(WordStr);
91                  WdPos++;
92                  WIdToItemVH.AddDat(WId).Add(
93                      TWdGixItem(BlobPt, Wgt, WdPos, TitleP, NmObjP, false, (EmphLv>0)));
94              }
95          } else if (HtmlLx.Sym == hsyBTag) {
96              TStr TagStr = HtmlLx.UcChA;
97              if (TitleTagH.IsKey(TagStr)) { TitleP = true; }
98              if (NmObjTagH.IsKey(TagStr)) { NmObjP = true; }
99              if (EmphTagH.IsKey(TagStr)) { EmphLv++; }
100          } else if (HtmlLx.Sym == hsyETag) {
101              TStr TagStr = HtmlLx.UcChA;
102              if (TitleTagH.IsKey(TagStr)) { TitleP = false; }
103              if (NmObjTagH.IsKey(TagStr)) { NmObjP = false; }
104              if (EmphTagH.IsKey(TagStr)) { EmphLv--; EmphLv = TInt::GetMx(0, EmphLv); }
105          }
106          HtmlLx.GetSym();
107      }
108      int WdKeyId = WIdToItemVH.FFirstKeyId();
109      while (WIdToItemVH.FNextKeyId(WdKeyId)) {
110          const int WId = WIdToItemVH.GetKey(WdKeyId); WordH[WId]++;
111          const TWdGixItemV& ItemV = WIdToItemVH[WdKeyId];
112          const uchar Seg = ItemV[0].GetSeg();
113          const uint Addr = ItemV[0].GetAddr();
114          const uchar Count = uchar(TInt::GetMn(int(TUCh::Mx), ItemV.Len()));
115          bool TitleP = false, NmObjP = false, EmphP = false, AnchorP = false;
116          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
117              const TWdGixItem& Item = ItemV[ItemN];
118              TitleP = TitleP || Item.IsTitle();
119              NmObjP = NmObjP || Item.IsNmObj();
120              EmphP = EmphP || Item.IsAnchor();
121              AnchorP = AnchorP || Item.IsEmph();
122          }
123          TWdGixItem Item(Seg, Addr, Wgt, Count, TitleP, NmObjP, AnchorP, EmphP);
124          WGix->AddItem(WId, Item);
125      }
126  }
127  bool TWdGix::Search(const TStr& QueryStr, TWdGixItemV& ResItemV) {
128      PWGixExpItem WGixExp = TWGixExpItem::NewEmpty();
129      PSIn HtmlSIn = TStrIn::New(QueryStr);
130      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
131      while (HtmlLx.Sym != hsyEof) {
132          if (HtmlLx.Sym == hsyStr) {
133              TStr WordStr = HtmlLx.UcChA;
134              WordStr=Stemmer->GetStem(WordStr);
135              const int WId = WordH.GetKeyId(WordStr);
136              if (WId != -1) {
137                  PWGixExpItem WGixExpItem = TWGixExpItem::NewItem(WId);
138                  if (WGixExp->IsEmpty()) { WGixExp = WGixExpItem; }
139                  else { WGixExp = TWGixExpItem::NewAnd(WGixExp, WGixExpItem); }
140              }
141          }
142          HtmlLx.GetSym();
143      }
144      return WGixExp->Eval(WGix, ResItemV);
145  }
146  void TWdGixMDS::AddDate(const TBlobPt& DocBlobPt, const TTm& DateTime) {
147      TAddrPr AddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr());
148      const uint64 DateMSecs = TTm::GetMSecsFromTm(DateTime);
149      AddrPrToDateH.AddDat(AddrPr, DateMSecs);
150  }
151  inline uint64 TWdGixMDS::GetDateMSecs(const TBlobPt& DocBlobPt) const {
152      return AddrPrToDateH.GetDat(TAddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr()));
153  }
154  inline TTm TWdGixMDS::GetDateTTm(const TBlobPt& DocBlobPt) const {
155      return TTm::GetTmFromMSecs(GetDateMSecs(DocBlobPt));
156  }
157  void TWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
158          const TStrV& CatNmV, const TTm& DateTime) {
159      DocTitleV.Add(DocTitle);
160      DocTitleV.Last().DelChAll('\n');
161      DocTitleV.Last().DelChAll('\r');
162      DocStrV.Add(DocStr);
163      CatNmVV.Add(CatNmV);
164      DateTimeV.Add(DateTime);
165  }
166  void TWdGixRSet::SortByDate(const bool& Asc) {
167      typedef TPair<TUInt64, TInt> TUInt64IntPr;
168      TVec<TUInt64IntPr> TmMSecsDocNV;
169      const int Docs = GetDocs();
170      for (int DocN = 0; DocN < Docs; DocN++) {
171          uint64 TmMSecs = TTm::GetMSecsFromTm(DateTimeV[DocN]);
172          TmMSecsDocNV.Add(TUInt64IntPr(TmMSecs, DocN));
173      }
174      TmMSecsDocNV.Sort(Asc);
175      TStrV NewDocTitleV(Docs, 0), NewDocStrV(Docs, 0);
176      TVec<TStrV> NewCatNmVV(Docs, 0); TTmV NewDateTimeV(Docs, 0);
177      for (int NewDocN = 0; NewDocN < Docs; NewDocN++) {
178          const int OldDocN = TmMSecsDocNV[NewDocN].Val2;
179          NewDocTitleV.Add(DocTitleV[OldDocN]);
180          NewDocStrV.Add(DocStrV[OldDocN]);
181          NewCatNmVV.Add(CatNmVV[OldDocN]);
182          NewDateTimeV.Add(DateTimeV[OldDocN]);
183      }
184      DocTitleV = NewDocTitleV; DocStrV = NewDocStrV;
185      CatNmVV = NewCatNmVV; DateTimeV = NewDateTimeV;
186  }
187  void TWdGixRSet::PrintRes(PNotify Notify) {
188      const int Docs = GetDocs();
189      Notify->OnStatus(TStr::Fmt(
190          "All results: %d, Showing results from %d to %d",
191          AllDocs.Val, Docs, Docs + Offset.Val));
192      for (int DocN = 0; DocN < Docs; DocN++) {
193          TTm DateTime = DateTimeV[DocN];
194          if (DateTime.IsDef()) {
195              Notify->OnStatus(TStr::Fmt("[%d: %s] %s ...", DocN+1,
196                  DateTime.GetWebLogDateStr().CStr(),
197                  DocTitleV[DocN].Left(50).CStr()));
198          } else {
199              Notify->OnStatus(TStr::Fmt("[%d] %s ...", DocN+1,
200                  DocTitleV[DocN].Left(60).CStr()));
201          }
202      }
203      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
204          AllDocs.Val, Docs, Docs + Offset.Val));
205  }
206  PBowDocBs TWdGixRSet::GenBowDocBs() const {
207      PSwSet SwSet = TSwSet::New(swstEn523);
208      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
209      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
210      const int Docs = GetDocs();
211      for (int DocN = 0; DocN < Docs; DocN++) {
212          const TStr& DocNm = DocTitleV[DocN];
213          const TStr& DocStr = DocStrV[DocN];
214          BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, true);
215      }
216      return BowDocBs;
217  }
218  void TWdGixBs::Filter(const TWgtWdGixItemKdV& InItemV,
219          const TWdGixBsGrouping& Grouping, TWgtWdGixItemKdV& OutItemV) {
220      OutItemV.Clr();
221      if (Grouping == wgbgName) {
222          TStrFltH NameToRankH; TStrH NameToItemNH;
223          const int Items = InItemV.Len();
224          for (int ItemN = 0; ItemN < Items; ItemN++) {
225              TBlobPt BlobPt = InItemV[ItemN].Dat.GetBlobPt();
226              TStr Name = GetDocTitle(BlobPt);
227              const double Rank = InItemV[ItemN].Key;
228              if (NameToRankH.IsKey(Name)) {
229                  const double OldRank = NameToRankH.GetDat(Name);
230                  if (Rank > OldRank) {
231                      NameToRankH.GetDat(Name) = Rank;
232                      NameToItemNH.GetDat(Name) = ItemN;
233                  }
234              } else {
235                  NameToRankH.AddDat(Name) = Rank;
236                  NameToItemNH.AddDat(Name) = ItemN;
237              }
238          }
239          int KeyId = NameToItemNH.FFirstKeyId();
240          while (NameToItemNH.FNextKeyId(KeyId)) {
241              const int ItemN = NameToItemNH[KeyId];
242              OutItemV.Add(InItemV[ItemN]);
243          }
244      } else if (Grouping == wgbgDate) {
245          Fail;
246      } else if (Grouping == wgbgDateTime) {
247          Fail;
248      }
249  }
250  TWdGixBs::TWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
251      FPath = _FPath; FAccess = _FAccess;
252      TStr WdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixBsFNm;
253      DocBBs = TMBlobBs::New(WdGixBsFNm, FAccess);
254      if (FAccess == faCreate) { WdGixMDS = TWdGixMDS::New(); }
255      else {
256          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
257          WdGixMDS = TWdGixMDS::LoadBin(WdGixMDSFNm);
258      }
259      WdGix = TWdGix::New(FPath, FAccess, CacheSize);
260  }
261  TWdGixBs::~TWdGixBs() {
262      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
263          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
264          WdGixMDS->SaveBin(WdGixMDSFNm);
265      }
266  }
267  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
268          const TStrV& CatNmV, const TTm& DateTime, const uchar& Wgt) {
269      TMOut DocMOut;
270      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
271      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
272      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
273      WdGix->AddHtml(DocStr, DocBlobPt, Wgt);
274  }
275  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStoreStr,
276          const TStr& DocIndexStr, const TStrV& CatNmV,
277          const TTm& DateTime, const uchar& Wgt) {
278      TMOut DocMOut;
279      DocTitle.Save(DocMOut); DocStoreStr.Save(DocMOut); CatNmV.Save(DocMOut);
280      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
281      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
282      WdGix->AddHtml(DocIndexStr, DocBlobPt, Wgt);
283  }
284  void TWdGixBs::GetDoc(const TBlobPt& BlobPt,
285          TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
286      PSIn SIn = DocBBs->GetBlob(BlobPt);
287      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
288  }
289  TStr TWdGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
290      PSIn SIn = DocBBs->GetBlob(BlobPt);
291      TStr DocTitle; DocTitle.Load(*SIn);
292      return DocTitle;
293  }
294  TStr TWdGixBs::GetDocStr(const TBlobPt& BlobPt) const {
295      PSIn SIn = DocBBs->GetBlob(BlobPt);
296      {TStr DocTitle; DocTitle.Load(*SIn);}
297      TStr DocStr; DocStr.Load(*SIn);
298      return DocStr;
299  }
300  TStrV TWdGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
301      PSIn SIn = DocBBs->GetBlob(BlobPt);
302      {TStr DocTitle; DocTitle.Load(*SIn);}
303      {TStr DocStr; DocStr.Load(*SIn);}
304      TStrV CatNmV; CatNmV.Load(*SIn);
305      return CatNmV;
306  }
307  PWdGixRSet TWdGixBs::SearchDoc(const TStr& QueryStr,
308          const TWdGixBsGrouping& Grouping, TWdGixRankFun& RankFun,
309          const int& Docs, const int& Offset, const TTm& MnDate,
310          const TTm& MxDate) {
311      printf("  Loading from Gix ...\n");
312      TWdGixItemV ResItemV; WdGix->Search(QueryStr, ResItemV);
313      printf("  Weighting %d hits ...\n", ResItemV.Len());
314      TWgtWdGixItemKdV FullWgtItemV(ResItemV.Len(), 0);
315      const bool CheckMnDateP = MnDate.IsDef();
316      const bool CheckMxDateP = MxDate.IsDef();
317      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
318          const TWdGixItem& Item = ResItemV[ItemN];
319          TTm DateTime = WdGixMDS->GetDateTTm(Item.GetBlobPt());
320          if (CheckMnDateP && DateTime < MnDate) { continue; }
321          if (CheckMxDateP && DateTime > MxDate) { continue; }
322          const double Wgt = RankFun(DateTime, Item.GetWgt(), Item.GetWdPos(),
323              Item.IsTitle(), Item.IsNmObj(), Item.IsAnchor(), Item.IsEmph());
324          FullWgtItemV.Add(TWgtWdGixItemKd(Wgt, Item));
325      }
326      printf("  Filtering ...\n");
327      if (Grouping != wgbgNone) {
328          TWgtWdGixItemKdV TmpWgtItemV;
329          Filter(FullWgtItemV, Grouping, TmpWgtItemV);
330          FullWgtItemV = TmpWgtItemV;
331      }
332      printf("  Sorting %d hits ...\n", FullWgtItemV.Len());
333      TWgtWdGixItemKdV WgtItemV;
334      if (Docs == -1) {
335          WgtItemV = FullWgtItemV;
336      } else if (ResItemV.Len() >= (Docs + Offset)) {
337          WgtItemV = FullWgtItemV;
338          WgtItemV.Sort(false); WgtItemV.Trunc(Docs + Offset);
339          WgtItemV.Sort(true); WgtItemV.Trunc(Docs);
340      } else if (ResItemV.Len() > Offset) {
341          WgtItemV = FullWgtItemV; WgtItemV.Sort(true);
342          WgtItemV.Trunc(FullWgtItemV.Len() - Offset);
343      } else {
344      }
345      WgtItemV.Sort(false);
346      printf("  Loading content for %d hits ...\n", WgtItemV.Len());
347      PWdGixRSet RSet = TWdGixRSet::New(
348          QueryStr, FullWgtItemV.Len(), Offset);
349      for (int ItemN = 0; ItemN < WgtItemV.Len(); ItemN++) {
350          const TWdGixItem& Item = WgtItemV[ItemN].Dat;
351          TBlobPt DocBlobPt = Item.GetBlobPt();
352          TStr DocTitle, DocStr; TStrV CatNmV;
353          GetDoc(DocBlobPt, DocTitle, DocStr, CatNmV);
354          TTm DateTime = WdGixMDS->GetDateTTm(DocBlobPt);
355          RSet->AddDoc(DocTitle, DocStr, CatNmV, DateTime);
356      }
357      printf("  Done\n");
358      return RSet;
359  }
360  void TWdGixBs::AddReuters(const TStr& XmlFNm) {
361      PXmlDoc Doc=TXmlDoc::LoadTxt(XmlFNm);
362      TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
363      TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
364      TChA DocChA; DocChA += "<doc>";
365      TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
366      DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
367      DocChA += "<body>";
368      TStr DocHeadline = Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
369      DocChA += "<p><em>"; DocChA += TXmlDoc::GetXmlStr(DocHeadline); DocChA += "</em></p>\n";
370      TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
371      for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
372          TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
373          TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("enamex", NmObjTokV);
374          for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
375              TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
376              ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
377          }
378          DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
379      }
380      DocChA += "</body></doc>";
381      TStrV CatNmV;
382      TXmlTokV CdsTokV; Doc->GetTagTokV("newsitem|metadata|codes", CdsTokV);
383      for (int CdsTokN = 0; CdsTokN < CdsTokV.Len(); CdsTokN++){
384          PXmlTok CdsTok = CdsTokV[CdsTokN];
385          TXmlTokV CdTokV; CdsTok->GetTagTokV("code", CdTokV);
386          if (CdsTok->GetArgVal("class") == "bip:topics:1.0"){
387              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
388                  TStr CdNm = CdTokV[CdTokN]->GetArgVal("code");
389                  CatNmV.AddMerged(CdNm);
390              }
391          } else if (CdsTok->GetArgVal("class")=="bip:countries:1.0"){
392              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
393                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
394                  CatNmV.AddMerged(CdNm);
395              }
396          } else if (CdsTok->GetArgVal("class")=="bip:industries:1.0"){
397              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
398                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
399                  CatNmV.AddMerged(CdNm);
400              }
401          } else { Fail; }
402      }
403      AddDoc(DocTitle, DocChA, CatNmV, DateTm);
404  }
405  void TWdGixBs::IndexReuters(const TStr& FPath) {
406      PNotify Notify = TStdNotify::New();
407      Notify->OnStatus("Loading Reuters documents from " + FPath + " ...\n");
408      TFFile FFile(FPath, ".xml", true);
409      TStr XmlFNm; int Files = 0;
410      while (FFile.Next(XmlFNm)) {
411          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm); Files++; }
412          if (Files % 1000 == 0) { Notify->OnStatus(TStr::Fmt("F:%d\r", Files)); }
413      }
414      Notify->OnStatus(TStr::Fmt("F:%d\n", Files));
415  }
416  void TWdGixBs::IndexNmEnBs(const TStr& FNm) {
417      PNotify Notify = TStdNotify::New();
418      Notify->OnStatus("Loading name-entitites from " + FNm + " ...\n");
419      PNmEnBs NmEnBs = TNmEnBs::LoadBin(FNm, true);
420      int NmEnKeyId = NmEnBs->GetFFirstNmEn();
421      int NmEnN = 0; const int NmEns = NmEnBs->GetNmEns();
422      while (NmEnBs->GetFNextNmEn(NmEnKeyId)) {
423          if (NmEnN > 100000) { break; }
424          if (NmEnN % 1000 == 0) { Notify->OnStatus(TStr::Fmt("N:%d/%d\r", NmEnN, NmEns)); }
425          TStr NmEnStr = NmEnBs->GetNmEnStr(NmEnKeyId);
426          IAssertR(NmEnBs->IsNmEn(NmEnStr), NmEnStr);
427          THash<TUInt, TChA> DateIntToCtxH; THash<TUInt, TInt> DateIntToCountH;
428          const TIntV& NmEnCtxIdV = NmEnBs->GetCtxIdV(NmEnKeyId);
429          for (int CtxIdN = 0; CtxIdN < NmEnCtxIdV.Len(); CtxIdN++) {
430              const int CtxId = NmEnCtxIdV[CtxIdN];
431              TStr NmEnCtxStr = NmEnBs->GetCtxStr(CtxId);
432              TTm NmEnCtxTm = NmEnBs->GetCtxTm(CtxId);
433              const uint DateInt = TTm::GetDateIntFromTm(NmEnCtxTm);
434              DateIntToCtxH.AddDat(DateInt) += NmEnCtxStr;
435              DateIntToCountH.AddDat(DateInt)++;
436          }
437          int CtxKeyId = DateIntToCtxH.FFirstKeyId();
438          while (DateIntToCtxH.FNextKeyId(CtxKeyId)) {
439              const int DateInt = DateIntToCtxH.GetKey(CtxKeyId);
440              TTm CtxDate = TTm::GetTmFromDateTimeInt(DateInt);
441              TStr CtxStr = DateIntToCtxH[CtxKeyId];
442              const uchar Wgt = uchar(DateIntToCountH.GetDat(DateInt).Val);
443              AddDoc(NmEnStr, CtxStr, TStrV(), CtxDate, Wgt);
444          }
445          NmEnN++;
446      }
447      Notify->OnStatus(TStr::Fmt("N:%d/%d", NmEnN, NmEns));
448  }
449  void TWdGixBs::IndexNyt(const TStr& XmlFNm) {
450      PNotify Notify = TStdNotify::New();
451      Notify->OnStatus("Loading NYT documents from " + XmlFNm + " ...\n");
452      PSIn SIn = TFIn::New(XmlFNm); int Docs = 0;
453      TStr LastTitle = "";
454      forever {
455          if (Docs % 1000 == 0) { Notify->OnStatus(TStr::Fmt("Docs: %d\r", Docs)); }
456          PXmlDoc Doc = TXmlDoc::LoadTxt(SIn); Docs++;
457          if (!Doc->IsOk()) { printf("%s - %s\n", LastTitle.CStr(), Doc->GetMsgStr().CStr()); break; }
458          TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
459          TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
460          TChA DocChA; DocChA += "<doc>";
461          TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
462          DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
463          DocChA += "<body>";
464          TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
465          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
466              TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
467              TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("ent", NmObjTokV);
468              for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
469                  TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
470                  ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
471              }
472              DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
473          }
474          DocChA += "</body></doc>";
475          AddDoc(DocTitle, DocChA, TStrV(), DateTm);
476          LastTitle = DocTitle;
477      }
478      Notify->OnStatus(TStr::Fmt("Docs: %d", Docs));
479  }
480  TSearchTopics::TSearchTopics(PWdGixRSet RSet, const int& Topics) {
481      PBowDocBs BowDocBs = RSet->GenBowDocBs();
482      TRnd Rnd(1);
483      PBowDocPart BowDocPart = TBowClust::GetKMeansPart(
484          TNullNotify::New(), BowDocBs, TBowSim::New(bstCos), Rnd,
485          Topics, 1, 10, 1, bwwtLogDFNrmTFIDF, 0.0, 0);
486      TopicV.Gen(Topics, 0);
487      TIntH FrameH; THash<TInt, TIntH> FrameTopicHH;
488      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
489          PBowDocPartClust Clust = BowDocPart->GetClust(ClustN);
490          TStr TopicNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 3, 1, ", ", false, false);
491          TopicV.Add(TopicNm);
492          for (int DocN = 0; DocN < Clust->GetDocs(); DocN++) {
493              const int DocId = Clust->GetDId(DocN);
494              TTm DocDate = RSet->GetDocDateTime(DocId);
495              const uint FrameId = TTm::GetYearIntFromTm(DocDate);
496              FrameH.AddDat(FrameId)++;
497              FrameTopicHH.AddDat(FrameId).AddDat(ClustN)++;
498          }
499      }
500      const int Frames = FrameH.Len();
501      FrameV.Gen(Frames, 0);
502      TopicFrameFqVV.Gen(Topics, Frames); TopicFrameFqVV.PutAll(0.0);
503      FrameH.SortByKey(); int FrameKeyId = FrameH.FFirstKeyId();
504      while (FrameH.FNextKeyId(FrameKeyId)) {
505          int FrameId = FrameH.GetKey(FrameKeyId);
506          TTm FrameDate = TTm::GetTmFromDateTimeInt(FrameId);
507          TStr FrameNm = TStr::Fmt("%4d", FrameDate.GetYear());
508          const int FrameN = FrameV.Add(FrameNm);
509          const TIntH& TopicH = FrameTopicHH.GetDat(FrameId);
510          int TopicKeyId = TopicH.FFirstKeyId(); int CountSum = 0;
511          while (TopicH.FNextKeyId(TopicKeyId)) {
512              const int TopicN = TopicH.GetKey(TopicKeyId);
513              int TopicCount = TInt::Abs(TopicH.GetDat(TopicKeyId)) > 1000 ?
514                  0 : TopicH.GetDat(TopicKeyId)();
515              CountSum += TopicCount;
516              const double Fq = double(CountSum); 
517              TopicFrameFqVV(TopicN, FrameN) = Fq;
518          }
519      }
520  }
521  TTrGixItem::TTrGixItem(const TBlobPt& BlobPt, const int& _SubjectId,
522      const int& _PredicatId, const int& _ObjectId, const int& _WdId,
523      const uchar& Type, const uchar& Pos, const bool& Full, const bool& Stem,
524      const uchar& Hyper): Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()),
525          SubjectId(_SubjectId), PredicatId(_PredicatId), ObjectId(_ObjectId), WdId(_WdId) {
526      SetWordInfo(Type, Pos, Full, Stem, Hyper);
527      ClrMergeInfo();
528  }
529  TTrGixItem::TTrGixItem(TSIn& SIn) {
530      SIn.Load(Seg); SIn.Load(Addr);
531      SIn.Load(SubjectId);
532      SIn.Load(PredicatId);
533      SIn.Load(ObjectId);
534      SIn.Load(WdId);
535      SIn.Load(WdInfo);
536      ClrMergeInfo();
537  }
538  void TTrGixItem::Save(TSOut& SOut) const {
539      SOut.Save(Seg); SOut.Save(Addr);
540      SOut.Save(SubjectId);
541      SOut.Save(PredicatId);
542      SOut.Save(ObjectId);
543      SOut.Save(WdId);
544      SOut.Save(WdInfo);
545  }
546  bool TTrGixItem::operator==(const TTrGixItem& Item) const {
547      return ((Seg==Item.Seg)&&(Addr==Item.Addr)&&
548          (SubjectId==Item.SubjectId)&&
549          (PredicatId==Item.PredicatId)&&
550          (ObjectId==Item.ObjectId));
551  }
552  bool TTrGixItem::operator<(const TTrGixItem& Item) const {
553      return (Seg<Item.Seg) ||
554          ((Seg==Item.Seg)&&(Addr<Item.Addr)) ||
555          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId<Item.SubjectId)) ||
556          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId<Item.PredicatId)) ||
557          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId==Item.PredicatId)&&(ObjectId<Item.ObjectId));
558  }
559  void TTrGixItem::SetWordInfo(const uchar& Type, const uchar& Pos,
560          const bool& Full, const bool& Stem, const uchar& Hyper) {
561      TTrGixItemWdInfo Info;
562      Info.Short = 0;
563      Info.Bits.Type = Type;
564      Info.Bits.Pos = Type;
565      Info.Bits.Full = Full ? 1 : 0;
566      Info.Bits.Stem = Stem ? 1 : 0;
567      Info.Bits.Hyper = Hyper;
568      WdInfo = Info.Short;
569  }
570  char TTrGix::SubjectType = 0;
571  char TTrGix::SubjectWdType = 1;
572  char TTrGix::SubjectAttrWdType = 2;
573  char TTrGix::SubjectStemType = 3;
574  char TTrGix::SubjectAttrStemType = 4;
575  char TTrGix::PredicatType = 5;
576  char TTrGix::PredicatWdType = 6;
577  char TTrGix::PredicatAttrWdType = 7;
578  char TTrGix::PredicatStemType = 8;
579  char TTrGix::PredicatAttrStemType = 9;
580  char TTrGix::ObjectType = 10;
581  char TTrGix::ObjectWdType = 11;
582  char TTrGix::ObjectAttrWdType = 12;
583  char TTrGix::ObjectStemType = 13;
584  char TTrGix::ObjectAttrStemType = 14;
585  void TTrGix::AddTrPart(const int& FullId, const char& Type, const int& SubjectId,
586          const int& PredicatId, const int& ObjectId, const TBlobPt& BlobPt) {
587      Gix->AddItem(TTrGixKey(FullId, Type),
588          TTrGixItem(BlobPt, SubjectId, PredicatId,
589              ObjectId, FullId, Type, 0, true, false, 0));
590  }
591  void TTrGix::AddTrPart(const TIntPrV& IdPrV, const char& WdType, const char& StemType,
592          const int& SubjectId, const int& PredicatId, const int& ObjectId,
593          const TBlobPt& BlobPt) {
594      for (int IdPrN = 0; IdPrN < IdPrV.Len(); IdPrN++) {
595          const int WdId = IdPrV[IdPrN].Val1;
596          Gix->AddItem(TTrGixKey(WdId, WdType),
597              TTrGixItem(BlobPt, SubjectId, PredicatId,
598                  ObjectId, WdId, WdType, IdPrN, false, false, 0));
599          const int StemId = IdPrV[IdPrN].Val2;
600          Gix->AddItem(TTrGixKey(StemId, StemType),
601              TTrGixItem(BlobPt, SubjectId, PredicatId,
602                  ObjectId, StemId, StemType, IdPrN, false, true, 0));
603      }
604  }
605  TTrGix::PTGixExpItem TTrGix::GetExactExp(const TStr& Str, const char& Type) {
606      TTrGixKey FullTrKey = TTrGixKey(GetWordId(Str, false), Type);
607      return TTGixExpItem::NewItem(FullTrKey);
608  }
609  TTrGix::PTGixExpItem TTrGix::GetPartExp(const TStr& Str, const char& WdType, const char& StemType) {
610      TIntPrV WordStemIdV; GetWordIdV(Str, WordStemIdV, false);
611      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
612      for (int WordStemIdN = 0; WordStemIdN < WordStemIdV.Len(); WordStemIdN++) {
613          TTrGixKey WdKey(WordStemIdV[WordStemIdN].Val1, WdType);
614          TTrGixKey StemKey(WordStemIdV[WordStemIdN].Val2, StemType);
615          PTGixExpItem ExpItem = TTGixExpItem::NewOr(
616              TTGixExpItem::NewItem(WdKey), TTGixExpItem::NewItem(StemKey));
617          if (Exp->IsEmpty()) { Exp = ExpItem; }
618          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
619      }
620      return Exp;
621  }
622  TTrGix::TTrGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
623      FPath = _FPath; FAccess = _FAccess;
624      Gix = TTGix::New(TGixConst::TrGixFNm, FPath, FAccess, CacheSize);
625      if (FAccess == faCreate) {
626          Stemmer = TStemmer::New(stmtPorter, true);
627      } else {
628          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
629          TFIn FIn(TrGixDatFNm);
630          WordH.Load(FIn);
631          Stemmer = TStemmer::Load(FIn);
632      }
633  }
634  TTrGix::~TTrGix() {
635      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
636          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
637          TFOut FOut(TrGixDatFNm);
638          WordH.Save(FOut);
639          Stemmer->Save(FOut);
640      }
641  }
642  int TTrGix::GetWordId(const TStr& WordStr, const bool& AddIfNotExistP) {
643      if (WordStr.Empty()) { return -1; }
644      if (AddIfNotExistP) { return WordH.AddKey(WordStr.GetUc()); }
645      else { return WordH.GetKeyId(WordStr.GetUc()); }
646  }
647  inline TStr TTrGix::GetWordStr(const int& WId) const {
648      return WId != -1 ? WordH.GetKey(WId) : "";
649  }
650  void TTrGix::GetWordIdV(const TStr& Str,
651          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
652      PSIn HtmlSIn = TStrIn::New(Str);
653      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
654      while (HtmlLx.Sym != hsyEof) {
655          if (HtmlLx.Sym == hsyStr) {
656              const TStr WordStr = HtmlLx.UcChA;
657              const int WordId = GetWordId(WordStr, AddIfNotExistP);
658              const int StemId = GetWordId(Stemmer->GetStem(WordStr), AddIfNotExistP);
659              WordStemIdV.Add(TIntPr(WordId, StemId));
660          }
661          HtmlLx.GetSym();
662      }
663  }
664  void TTrGix::GetWordIdV(const TStrV& WordStrV,
665          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
666      for (int WordStrN = 0; WordStrN < WordStrV.Len(); WordStrN++) {
667          GetWordIdV(WordStrV[WordStrN], WordStemIdV, AddIfNotExistP);
668      }
669  }
670  void TTrGix::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
671          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
672          const TStrV& ObjectAttrV, const TBlobPt& BlobPt) {
673      const int SubjectId = GetWordId(SubjectStr, true);
674      const int PredicatId = GetWordId(PredicatStr, true);
675      const int ObjectId = GetWordId(ObjectStr, true);
676      AddTrPart(SubjectId, SubjectType, SubjectId, PredicatId, ObjectId, BlobPt);
677      AddTrPart(PredicatId, PredicatType, SubjectId, PredicatId, ObjectId, BlobPt);
678      AddTrPart(ObjectId, ObjectType, SubjectId, PredicatId, ObjectId, BlobPt);
679      TIntPrV SubjectWIdSIdV; GetWordIdV(SubjectStr, SubjectWIdSIdV, true);
680      TIntPrV SubjectAttrWIdSIdV; GetWordIdV(SubjectAttrV, SubjectAttrWIdSIdV, true);
681      TIntPrV PredicatWIdSIdV; GetWordIdV(PredicatStr, PredicatWIdSIdV, true);
682      TIntPrV PredicatAttrWIdSIdV; GetWordIdV(PredicatAttrV, PredicatAttrWIdSIdV, true);
683      TIntPrV ObjectWIdSIdV; GetWordIdV(ObjectStr, ObjectWIdSIdV, true);
684      TIntPrV ObjectAttrWIdSIdV; GetWordIdV(ObjectAttrV, ObjectAttrWIdSIdV, true);
685      AddTrPart(SubjectWIdSIdV, SubjectWdType, SubjectStemType,
686          SubjectId, PredicatId, ObjectId, BlobPt);
687      AddTrPart(SubjectAttrWIdSIdV, SubjectAttrWdType, SubjectAttrStemType,
688          SubjectId, PredicatId, ObjectId, BlobPt);
689      AddTrPart(PredicatWIdSIdV, PredicatWdType, PredicatStemType,
690          SubjectId, PredicatId, ObjectId, BlobPt);
691      AddTrPart(PredicatAttrWIdSIdV, PredicatAttrWdType, PredicatAttrStemType,
692          SubjectId, PredicatId, ObjectId, BlobPt);
693      AddTrPart(ObjectWIdSIdV, ObjectWdType, ObjectStemType,
694          SubjectId, PredicatId, ObjectId, BlobPt);
695      AddTrPart(ObjectAttrWIdSIdV, ObjectAttrWdType, ObjectAttrStemType,
696          SubjectId, PredicatId, ObjectId, BlobPt);
697  }
698  bool TTrGix::SearchExact(const TStr& SubjectStr, const TStr& PredicatStr,
699          const TStr& ObjectStr, TTrGixItemV& ResItemV) {
700      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
701      if (!SubjectStr.Empty()) {
702          PTGixExpItem ExpItem = GetExactExp(SubjectStr, SubjectType);
703          if (Exp->IsEmpty()) { Exp = ExpItem; }
704          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
705      }
706      if (!PredicatStr.Empty()) {
707          PTGixExpItem ExpItem = GetExactExp(PredicatStr, PredicatType);
708          if (Exp->IsEmpty()) { Exp = ExpItem; }
709          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
710      }
711      if (!ObjectStr.Empty()) {
712          PTGixExpItem ExpItem = GetExactExp(ObjectStr, ObjectType);
713          if (Exp->IsEmpty()) { Exp = ExpItem; }
714          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
715      }
716      return Exp->Eval(Gix, ResItemV);
717  }
718  bool TTrGix::SearchPart(const TStr& SubjectStr, const TStr& PredicatStr,
719          const TStr& ObjectStr, TTrGixItemV& ResItemV, const bool& IncExactP) {
720      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
721      if (!SubjectStr.Empty()) {
722          PTGixExpItem ExpItem = GetPartExp(SubjectStr, SubjectWdType, SubjectStemType);
723          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(SubjectStr, SubjectType), ExpItem); }
724          if (Exp->IsEmpty()) { Exp = ExpItem; }
725          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
726      }
727      if (!PredicatStr.Empty()) {
728          PTGixExpItem ExpItem = GetPartExp(PredicatStr, PredicatWdType, PredicatStemType);
729          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(PredicatStr, PredicatType), ExpItem); }
730          if (Exp->IsEmpty()) { Exp = ExpItem; }
731          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
732      }
733      if (!ObjectStr.Empty()) {
734          PTGixExpItem ExpItem = GetPartExp(ObjectStr, ObjectWdType, ObjectStemType);
735          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(ObjectStr, ObjectType), ExpItem); }
736          if (Exp->IsEmpty()) { Exp = ExpItem; }
737          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
738      }
739      return Exp->Eval(Gix, ResItemV);
740  }
741  void TTrGixRSet::AddTr(const TStrTr& TrStr, const TBlobPtV& TrAttrBlobPtV) {
742      TrStrV.Add(TrStr);
743      TrAttrBlobPtVV.Add(TrAttrBlobPtV);
744  }
745  void TTrGixRSet::GetSubjectV(TStrIntKdV& SubjectStrWgtV) {
746      TIntStrKdV SubjectWgtStrV;
747      for (int TrN = 0; TrN < GetTrs(); TrN++) {
748          const TStr& SubjectStr = TrStrV[TrN].Val1;
749          const int Wgt = GetTrCount(TrN);
750          SubjectWgtStrV.Add(TIntStrKd(Wgt, SubjectStr));
751      }
752      SubjectWgtStrV.Sort(false);
753      GetSwitchedKdV<TInt, TStr>(SubjectWgtStrV, SubjectStrWgtV);
754  }
755  void TTrGixRSet::GetPredicatV(TStrIntKdV& PredicatStrWgtV) {
756      TIntStrKdV PredicatWgtStrV;
757      for (int TrN = 0; TrN < GetTrs(); TrN++) {
758          const TStr& PredicatStr = TrStrV[TrN].Val2;
759          const int Wgt = GetTrCount(TrN);
760          PredicatWgtStrV.Add(TIntStrKd(Wgt, PredicatStr));
761      }
762      PredicatWgtStrV.Sort(false);
763      GetSwitchedKdV<TInt, TStr>(PredicatWgtStrV, PredicatStrWgtV);
764  }
765  void TTrGixRSet::GetObjectV(TStrIntKdV& ObjectStrWgtV) {
766      TIntStrKdV ObjectWgtStrV;
767      for (int TrN = 0; TrN < GetTrs(); TrN++) {
768          const TStr& ObjectStr = TrStrV[TrN].Val3;
769          const int Wgt = GetTrCount(TrN);
770          ObjectWgtStrV.Add(TIntStrKd(Wgt, ObjectStr));
771      }
772      ObjectWgtStrV.Sort(false);
773      GetSwitchedKdV<TInt, TStr>(ObjectWgtStrV, ObjectStrWgtV);
774  }
775  void TTrGixRSet::PrintRes(const bool& PrintSentsP, PNotify Notify) const {
776      printf("Query:\n");
777      printf("  Subject: '%s'\n", GetSubjectStr().CStr());
778      printf("  Predicat: '%s'\n", GetPredicatStr().CStr());
779      printf("  Object: '%s'\n", GetObjectStr().CStr());
780      printf("Displaying: %d - %d (All hits: %d)\n",
781          GetOffset()+1, Offset.Val+GetTrs()+1, GetAllTrs());
782      for (int TrN = 0; TrN < GetTrs(); TrN++) {
783          printf("%d. [%s <- %s -> %s], (Support:%d)\n", TrN+GetOffset()+1,
784              GetTrSubjectStr(TrN).CStr(), GetTrPredicatStr(TrN).CStr(),
785              GetTrObjectStr(TrN).CStr(), GetTrCount(TrN));
786      }
787  }
788  void TTrGixBs::GetAttrV(PXmlTok XmlTok, TStrV& AttrV) {
789      TXmlTokV AttrTokV; XmlTok->GetTagTokV("attrib", AttrTokV);
790      for (int AttrTokN = 0; AttrTokN < AttrTokV.Len(); AttrTokN++) {
791          PXmlTok AttrTok = AttrTokV[AttrTokN];
792          AttrV.Add(AttrTok->GetStrArgVal("word"));
793          GetAttrV(AttrTok, AttrV);
794      }
795  }
796  TTrGixBs::TTrGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
797      FPath = _FPath; FAccess = _FAccess;
798      TStr TrGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDocBsFNm;
799      DocBBs = TMBlobBs::New(TrGixDocBsFNm, FAccess);
800      TStr TrGixSentBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixSentBsFNm;
801      SentBBs = TMBlobBs::New(TrGixSentBsFNm, FAccess);
802      TStr TrGixTrAttrBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixTrAttrBsFNm;
803      TrAttrBBs = TMBlobBs::New(TrGixTrAttrBsFNm, FAccess);
804      TrGix = TTrGix::New(FPath, FAccess, CacheSize);
805  }
806  TTrGixBs::~TTrGixBs() {
807      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
808      }
809  }
810  TBlobPt TTrGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr, const TStrV& CatNmV) {
811      TMOut DocMOut;
812      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
813      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
814      return DocBlobPt;
815  }
816  TBlobPt TTrGixBs::AddSent(const TStr& SentStr) {
817      TMOut SentMOut; SentStr.Save(SentMOut);
818      TBlobPt SentBlobPt = SentBBs->PutBlob(SentMOut.GetSIn());
819      return SentBlobPt;
820  }
821  TBlobPt TTrGixBs::AddTrAttr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
822          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
823          const TStrV& ObjectAttrV, const TBlobPt& SentBlobPt, const TBlobPt& DocBlobPt) {
824      TMOut TrAttrMOut;
825      SubjectStr.Save(TrAttrMOut); SubjectAttrV.Save(TrAttrMOut);
826      PredicatStr.Save(TrAttrMOut); PredicatAttrV.Save(TrAttrMOut);
827      ObjectStr.Save(TrAttrMOut); ObjectAttrV.Save(TrAttrMOut);
828      SentBlobPt.Save(TrAttrMOut); DocBlobPt.Save(TrAttrMOut);
829      TBlobPt TrAttrBlobPt = TrAttrBBs->PutBlob(TrAttrMOut.GetSIn());
830      return TrAttrBlobPt;
831  }
832  void TTrGixBs::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
833          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
834          const TStrV& ObjectAttrV, const TBlobPt& TrAttrBlobPt) {
835      TrGix->AddTr(SubjectStr, SubjectAttrV, PredicatStr,
836          PredicatAttrV, ObjectStr, ObjectAttrV, TrAttrBlobPt);
837  }
838  void TTrGixBs::GetDoc(const TBlobPt& DocBlobPt, TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
839      PSIn SIn = DocBBs->GetBlob(DocBlobPt);
840      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
841  }
842  TStr TTrGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
843      PSIn SIn = DocBBs->GetBlob(BlobPt);
844      TStr DocTitle; DocTitle.Load(*SIn);
845      return DocTitle;
846  }
847  TStr TTrGixBs::GetDocStr(const TBlobPt& BlobPt) const {
848      PSIn SIn = DocBBs->GetBlob(BlobPt);
849      {TStr DocTitle; DocTitle.Load(*SIn);}
850      TStr DocStr; DocStr.Load(*SIn);
851      return DocStr;
852  }
853  TStrV TTrGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
854      PSIn SIn = DocBBs->GetBlob(BlobPt);
855      {TStr DocTitle; DocTitle.Load(*SIn);}
856      {TStr DocStr; DocStr.Load(*SIn);}
857      TStrV CatNmV; CatNmV.Load(*SIn);
858      return CatNmV;
859  }
860  TStr TTrGixBs::GetSentStr(const TBlobPt& SentBlobPt) {
861      PSIn SIn = SentBBs->GetBlob(SentBlobPt);
862      return TStr(*SIn);
863  }
864  void TTrGixBs::GetTrAttr(const TBlobPt& TrAttrBlobPt, TStr& SubjectStr,
865          TStrV& SubjectAttrV, TStr& PredicatStr, TStrV& PredicatAttrV,
866          TStr& ObjectStr, TStrV& ObjectAttrV, TBlobPt& SentBlobPt,
867          TBlobPt& DocBlobPt) {
868      PSIn SIn = TrAttrBBs->GetBlob(TrAttrBlobPt);
869      SubjectStr.Load(*SIn); SubjectAttrV.Load(*SIn);
870      PredicatStr.Load(*SIn); PredicatAttrV.Load(*SIn);
871      ObjectStr.Load(*SIn); ObjectAttrV.Load(*SIn);
872      SentBlobPt = TBlobPt(*SIn); DocBlobPt = TBlobPt(*SIn);
873  }
874  PTrGixRSet TTrGixBs::SearchTr(const TStr& SubjectStr, const TStr& PredicatStr,
875          const TStr& ObjectStr, TTrGixRankFun& RankFun, const int& Docs,
876          const int& Offset, const bool& ExactP) {
877      TTrGixItemV ResItemV;
878      if (ExactP) { TrGix->SearchExact(SubjectStr, PredicatStr, ObjectStr, ResItemV); }
879      else { TrGix->SearchPart(SubjectStr, PredicatStr, ObjectStr, ResItemV, true); }
880      THash<TIntTr, TIntV> TrToItemVH;
881      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
882          const TTrGixItem& Item = ResItemV[ItemN];
883          TrToItemVH.AddDat(Item.GetIdTr()).Add(ItemN);
884      }
885      TFltIntKdV FullWgtTrKeyIdV;
886      int TrKeyId = TrToItemVH.FFirstKeyId();
887      while (TrToItemVH.FNextKeyId(TrKeyId)) {
888          const double Wgt = RankFun(TrToItemVH[TrKeyId].Len());
889          FullWgtTrKeyIdV.Add(TFltIntKd(Wgt, TrKeyId));
890      }
891      TFltIntKdV WgtTrKeyIdV;
892      if (Docs == -1) {
893          WgtTrKeyIdV = FullWgtTrKeyIdV;
894      } else if (ResItemV.Len() >= (Docs + Offset)) {
895          WgtTrKeyIdV = FullWgtTrKeyIdV;
896          WgtTrKeyIdV.Sort(false); WgtTrKeyIdV.Trunc(Docs + Offset);
897          WgtTrKeyIdV.Sort(true); WgtTrKeyIdV.Trunc(Docs);
898      } else if (ResItemV.Len() > Offset) {
899          WgtTrKeyIdV = FullWgtTrKeyIdV; WgtTrKeyIdV.Sort(true);
900          WgtTrKeyIdV.Trunc(FullWgtTrKeyIdV.Len() - Offset);
901      } else {
902      }
903      WgtTrKeyIdV.Sort(false);
904      PTrGixRSet RSet = TTrGixRSet::New(SubjectStr, PredicatStr,
905          ObjectStr, FullWgtTrKeyIdV.Len(), Offset);
906      for (int TrN = 0; TrN < WgtTrKeyIdV.Len(); TrN++) {
907          const int TrKeyId = WgtTrKeyIdV[TrN].Dat;
908          const TIntTr& WIdTr = TrToItemVH.GetKey(TrKeyId);
909          const TIntV& ItemV = TrToItemVH[TrKeyId];
910          TStr SubjectStr = TrGix->GetWordStr(WIdTr.Val1);
911          TStr PredicatStr = TrGix->GetWordStr(WIdTr.Val2);
912          TStr ObjectStr = TrGix->GetWordStr(WIdTr.Val3);
913          TStrTr TrStr(SubjectStr, PredicatStr, ObjectStr);
914          TBlobPtV TrAttrBlobPtV;
915          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
916              const TTrGixItem& Item = ResItemV[ItemV[ItemN]];
917              TBlobPt TrAttrBlobPt = Item.GetBlobPt();
918              TrAttrBlobPtV.Add(TrAttrBlobPt);
919          }
920          RSet->AddTr(TrStr, TrAttrBlobPtV);
921      }
922      return RSet;
923  }
924  void TTrGixBs::AddReuters(const TStr& XmlFNm, int& Trs, const PSOut& CsvOut) {
925      PNotify Notify = TStdNotify::New();
926      TBlobPt EmptyDocBlobPt = AddDoc("No full document text!");
927      PSIn XmlSIn = TFIn::New(XmlFNm);
928      TXmlDoc::SkipTopTag(XmlSIn);
929      PXmlDoc XmlDoc; int XmlDocs = 0;
930      forever{
931          if (Trs % 100 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", Trs)); }
932          XmlDocs++; XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
933          if (!XmlDoc->IsOk()) { break; }
934          PXmlTok TopTok = XmlDoc->GetTok();
935          if (TopTok->IsTag("sentence")){
936              TStr DocStr = ""; TBlobPt DocBlobPt = EmptyDocBlobPt;
937              TStr SentStr = TopTok->GetTagTok("originalSentence")->GetTokStr(false);
938              TBlobPt SentBlobPt = AddSent(SentStr);
939              TXmlTokV TrTokV; TopTok->GetTagTokV("triplet", TrTokV);
940              for (int TrTokN = 0; TrTokN < TrTokV.Len(); TrTokN++) {
941                  PXmlTok TrTok = TrTokV[TrTokN];
942                  TStr SubjectStr = TrTok->GetTagTok("subject")->GetStrArgVal("word");
943                  TStr PredicatStr = TrTok->GetTagTok("verb")->GetStrArgVal("word");
944                  TStr ObjectStr = TrTok->GetTagTok("object")->GetStrArgVal("word");
945                  TStrV SubjectAttrV; GetAttrV(TrTok->GetTagTok("subject"), SubjectAttrV);
946                  TStrV PredicatAttrV; GetAttrV(TrTok->GetTagTok("verb"), PredicatAttrV);
947                  TStrV ObjectAttrV; GetAttrV(TrTok->GetTagTok("object"), ObjectAttrV);
948                  TBlobPt TrAttrBlobPt = AddTrAttr(SubjectStr, SubjectAttrV,
949                      PredicatStr, PredicatAttrV, ObjectStr, ObjectAttrV,
950                      SentBlobPt, DocBlobPt);
951                  AddTr(SubjectStr, SubjectAttrV, PredicatStr, PredicatAttrV,
952                      ObjectStr, ObjectAttrV, TrAttrBlobPt);
953                  Trs++;
954                  if (!CsvOut.Empty()) {
955                      SubjectStr.DelChAll(','); CsvOut->PutStr(SubjectStr + ",");
956                      PredicatStr.DelChAll(','); CsvOut->PutStr(PredicatStr + ",");
957                      ObjectStr.DelChAll(','); CsvOut->PutStr(ObjectStr + ",");
958                      CsvOut->PutStr(TStr::Fmt("%u,", uint(SentBlobPt.GetSeg())));
959                      CsvOut->PutStr(TStr::Fmt("%u,", SentBlobPt.GetAddr()));
960                      CsvOut->PutStr(TStr::Fmt("%d,", SubjectAttrV.Len()));
961                      for (int AttrN = 0; AttrN < SubjectAttrV.Len(); AttrN++) {
962                          SubjectAttrV[AttrN].DelChAll(',');
963                          CsvOut->PutStr(SubjectAttrV[AttrN]);
964                          CsvOut->PutStr(",");
965                      }
966                      CsvOut->PutStr(TStr::Fmt("%d,", PredicatAttrV.Len()));
967                      for (int AttrN = 0; AttrN < PredicatAttrV.Len(); AttrN++) {
968                          PredicatAttrV[AttrN].DelChAll(',');
969                          CsvOut->PutStr(PredicatAttrV[AttrN]);
970                          CsvOut->PutStr(",");
971                      }
972                      CsvOut->PutStr(TStr::Fmt("%d,", ObjectAttrV.Len()));
973                      for (int AttrN = 0; AttrN < ObjectAttrV.Len(); AttrN++) {
974                          ObjectAttrV[AttrN].DelChAll(',');
975                          CsvOut->PutStr(ObjectAttrV[AttrN]);
976                          CsvOut->PutStr(",");
977                      }
978                      CsvOut->PutStr("-1"); CsvOut->PutLn();
979                  }
980              }
981          }
982      }
<span onclick='openModal()' class='match'>983      CsvOut->Flush();
984  }
985  void TTrGixBs::IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm, const int& MxTrs) {
986      PNotify Notify = TStdNotify::New();
987      Notify->OnStatus("Loading Reuters documents from " + XmlFPath + " ...\n");
</span>988      TFFile FFile(XmlFPath, ".xml", true); TStr XmlFNm; int Files = 0, Trs = 0;
989      PSOut CsvOut; if (!CsvFNm.Empty()) { CsvOut = TFOut::New(CsvFNm); }
990      while (FFile.Next(XmlFNm) && ((MxTrs == -11)||(MxTrs > Trs))) {
991          Notify->OnStatus(TStr::Fmt("Loading %3d : %s ...", Files+1, XmlFNm.CStr()));
992          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm, Trs, CsvOut); Files++; }
993      }
994      Notify->OnStatus(TStr::Fmt("Triplets loaded: %d", Trs));
995  }
996  TMWdGixItem::TMWdGixItem(TSIn& SIn) {
997      SIn.Load(Seg); SIn.Load(Addr);
998      SIn.Load(WdFq); SIn.Load(DocWds);
999  }
1000  void TMWdGixItem::Save(TSOut& SOut) const {
1001      SOut.Save(Seg); SOut.Save(Addr);
1002      SOut.Save(WdFq); SOut.Save(DocWds);
1003  }
1004  inline bool TMWdGixItem::operator==(const TMWdGixItem& Item) const {
1005      return (Seg == Item.Seg) && (Addr == Item.Addr);
1006  }
1007  inline bool TMWdGixItem::operator<(const TMWdGixItem& Item) const {
1008      return (Seg < Item.Seg) || ((Seg == Item.Seg) && (Addr < Item.Addr));
1009  }
1010  void TMWdGixDefMerger::Union(TMWdGixItemV& DstV, const TMWdGixItemV& SrcV) const {
1011      TMWdGixItemV DstValV(TInt::GetMx(DstV.Len(), SrcV.Len()), 0);
1012      int ValN1 = 0; int ValN2 = 0;
1013      while ((ValN1<DstV.Len()) && (ValN2<SrcV.Len())){
1014          const TMWdGixItem& Val1 = DstV.GetVal(ValN1);
1015          const TMWdGixItem& Val2 = SrcV.GetVal(ValN2);
1016          if (Val1 < Val2) { DstValV.Add(Val1); ValN1++; }
1017          else if (Val1>Val2) { DstValV.Add(Val2); ValN2++; }
1018          else { DstValV.Add(TMWdGixItem(Val1, Val2)); ValN1++; ValN2++; }
1019      }
1020      for (int RestValN1=ValN1; RestValN1<DstV.Len(); RestValN1++){
1021          DstValV.Add(DstV.GetVal(RestValN1));}
1022      for (int RestValN2=ValN2; RestValN2<SrcV.Len(); RestValN2++){
1023          DstValV.Add(SrcV.GetVal(RestValN2));}
1024      DstV = DstValV;
1025  }
1026  void TMWdGixDefMerger::Def(const TInt& Key, TMWdGixItemV& ItemV) const  {
1027      const int WdDocFq = MWdGix->GetWdFq(Key);
1028      const int Docs = MWdGix->GetAllDocs();
1029      const double AvgDocWds = MWdGix->GetAvgDocWds();
1030      const int Items = ItemV.Len();
1031      for (int ItemN = 0; ItemN < Items; ItemN++) {
1032          TMWdGixItem& Item = ItemV[ItemN];
1033          const int WdFq = Item.GetWdFq();
1034          const int DocWds = Item.GetDocWds();
1035          const double Wgt = RankFun->WdRank(WdFq, DocWds, WdDocFq, Docs, AvgDocWds);
1036          Item.PutWgt(Wgt);
1037      }
1038  }
1039  TMWdGix::TMWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
1040      FPath = _FPath; FAccess = _FAccess;
1041      printf("Loading '%s' .. ", FPath.CStr());
1042      if (FAccess == faCreate) { printf("create .. "); }
1043      if (FAccess == faRdOnly) { printf("read-only .. "); }
1044      printf("Cache[%s]\n", TUInt64::GetMegaStr(CacheSize).CStr());
1045      MWGix = TMWGix::New(TGixConst::MWdGixFNm, FPath, FAccess, CacheSize);
1046      if (FAccess != faCreate) {
1047          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1048          TFIn FIn(MWdGixDatFNm);
1049          WordH.Load(FIn);
1050          AllDocs.Load(FIn);
1051          AllWords.Load(FIn);
1052      }
1053  }
1054  TMWdGix::~TMWdGix() {
1055      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1056          printf("Closing %s: docs=%d, words=%d\n",
1057              FPath.CStr(), AllDocs.Val, AllWords.Val);
1058          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1059          TFOut FOut(MWdGixDatFNm);
1060          WordH.Save(FOut);
1061          AllDocs.Save(FOut);
1062          AllWords.Save(FOut);
1063      }
1064  }
1065  void TMWdGix::AddHtml(const TStr& DocStr, const TBlobPt& BlobPt) {
1066      PSIn HtmlSIn = TStrIn::New(DocStr);
1067      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1068      TIntH DocWIdH; int DocWds = 0;
1069      while (HtmlLx.Sym != hsyEof) {
1070          if (HtmlLx.Sym == hsyStr) {
1071              TStr WordStr = HtmlLx.UcChA;
1072              const int WId = WordH.AddKey(WordStr);
1073              DocWIdH.AddDat(WId)++;
1074              DocWds++;
1075          }
1076          HtmlLx.GetSym();
1077      }
1078      int WdKeyId = DocWIdH.FFirstKeyId();
1079      while (DocWIdH.FNextKeyId(WdKeyId)) {
1080          const int WId = DocWIdH.GetKey(WdKeyId);
1081          const int WdFq = DocWIdH[WdKeyId];
1082          WordH[WId]++; 
1083          TMWdGixKey Key(WId);
1084          TMWdGixItem Item(BlobPt, WdFq, DocWds);
1085          MWGix->AddItem(Key, Item);
1086      }
1087      AllDocs++; AllWords += DocWds;
1088  }
1089  bool TMWdGix::Search(const TStr& QueryStr,
1090          TMWdGixItemV& ResItemV, const TMWdGixDefMerger& Merger) {
1091      PMWGixExpItem MWGixExp = TMWGixExpItem::NewEmpty();
1092      PSIn HtmlSIn = TStrIn::New(QueryStr);
1093      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1094      while (HtmlLx.Sym != hsyEof) {
1095          if (HtmlLx.Sym == hsyStr) {
1096              TStr WordStr = HtmlLx.UcChA;
1097              const int WId = WordH.GetKeyId(WordStr);
1098              if (WId != -1) {
1099                  PMWGixExpItem MWGixExpItem = TMWGixExpItem::NewItem(TMWdGixKey(WId));
1100                  if (MWGixExp->IsEmpty()) { MWGixExp = MWGixExpItem; }
1101                  else { MWGixExp = TMWGixExpItem::NewOr(MWGixExp, MWGixExpItem); }
1102              }
1103          }
1104          HtmlLx.GetSym();
1105      }
1106      return MWGixExp->Eval(MWGix, ResItemV, Merger);
1107  }
1108  TStr TMWdGixRSet::GetMainPara(const TStr& QueryStr, const TStr& FullStr) {
1109      PBowDocBs BowDocBs = TBowDocBs::New();
1110      BowDocBs->AddHtmlDoc("Query", TStrV(), QueryStr, false);
1111      TStrV ParaV; FullStr.SplitOnAllCh('\n', ParaV);
1112      if (ParaV.Empty()) { return ""; }
1113      for (int ParaN = 0; ParaN < ParaV.Len(); ParaN++) {
1114          BowDocBs->AddHtmlDoc("Doc" + TInt::GetStr(ParaN), TStrV(), ParaV[ParaN], false);
1115      }
1116      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
1117      PBowSpV QuerySpV = BowDocWgtBs->GetSpV(0); int MxParaN = 0;
1118      double MxParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(1));
1119      for (int ParaN = 1; ParaN < ParaV.Len(); ParaN++) {
1120          const double ParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(ParaN+1));
1121          if (ParaSim > MxParaSim) {
1122              MxParaSim = ParaSim;
1123              MxParaN = ParaN;
1124          }
1125      }
1126      return ParaV[MxParaN];
1127  }
1128  void TMWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1129          const TStr& DocLang, const TStrV& KeyWdV) {
1130      DocTitleV.Add(DocTitle);
1131      DocTitleV.Last().DelChAll('\n');
1132      DocTitleV.Last().DelChAll('\r');
1133      DocStrV.Add(GetMainPara(LangQueryH.GetDat(DocLang), DocStr));
1134      DocLangV.Add(DocLang);
1135      KeyWdVV.Add(KeyWdV);
1136  }
1137  void TMWdGixRSet::PrintRes(PNotify Notify) {
1138      const int Docs = GetDocs();
1139      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1140          AllDocs.Val, Docs, Docs + Offset.Val));
1141      for (int DocN = 0; DocN < Docs; DocN++) {
1142          TStr DocStr = DocTitleV[DocN] + " - " + DocStrV[DocN];
1143          DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
1144          Notify->OnStatus(TStr::Fmt("[%d:%s] %s ...", DocN+1,
1145              DocLangV[DocN].CStr(), DocStr.Left(60).CStr()));
1146      }
1147      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1148          AllDocs.Val, Docs, Docs + Offset.Val));
1149  }
1150  TStr TMWdGixRSet::GetWsXml(const TStrPrStrH& EurovocH) const {
1151      PXmlTok TopTok = TXmlTok::New("cca");
1152      TopTok->AddArg("allhits", GetAllDocs());
1153      for (int DocN = 0; DocN < GetDocs(); DocN++) {
1154          PXmlTok HitTok = TXmlTok::New("hit");
1155          HitTok->AddArg("rank", DocN+1);
1156          HitTok->AddArg("lang", DocLangV[DocN]);
1157          TStr Title = DocTitleV[DocN];
1158          if (Title.Len() > 100) { Title = Title.Left(100) + "..."; }
1159          TStr Snipet = DocStrV[DocN].Left(800);
1160          if (Snipet.Len() > 800) { Snipet = Snipet.Left(800) + "..."; }
1161          HitTok->AddSubTok(TXmlTok::New("title", Title));
1162          HitTok->AddSubTok(TXmlTok::New("snipet", Snipet));
1163          PXmlTok KeyWdTok = TXmlTok::New("keywords");
1164          const TStrV& KeyWdV = KeyWdVV[DocN]; int GoodKeyWds = 0;
1165          for (int KeyWdN = 0; KeyWdN < KeyWdV.Len(); KeyWdN++) {
1166              TStrPr KeyWd(QueryLang, KeyWdV[KeyWdN]);
1167              if (EurovocH.IsKey(KeyWd)) {
1168                  KeyWdTok->AddSubTok(TXmlTok::New("keyword", EurovocH.GetDat(KeyWd)));
1169                  GoodKeyWds++;
1170              }
1171          }
1172          HitTok->AddSubTok(KeyWdTok);
1173          if (GoodKeyWds == 0) { continue; }
1174          TopTok->AddSubTok(HitTok);
1175      }
1176      return TopTok->GetTokStr();
1177  }
1178  TMWdGixBs::TMWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& _CacheSize) {
1179      FPath = _FPath; FAccess = _FAccess; CacheSize = _CacheSize;
1180      TStr MWdGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDocBsFNm;
1181      DocBBs = TMBlobBs::New(MWdGixDocBsFNm, FAccess);
1182      if (FAccess != faCreate) {
1183          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1184          AlignPairBs = TAlignPairBs::LoadBin(MWdGixBsFNm);
1185          InitGixs(FAccess);
1186      }
1187  }
1188  TMWdGixBs::~TMWdGixBs() {
1189      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1190          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1191          AlignPairBs->SaveBin(MWdGixBsFNm);
1192      }
1193  }
1194  void TMWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1195          const TStr& DocLang, const TStrV& KeyWdV) {
1196      TMOut DocMOut;
1197      DocTitle.Save(DocMOut); DocStr.Save(DocMOut);
1198      DocLang.Save(DocMOut); KeyWdV.Save(DocMOut);
1199      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
1200      LangMWdGixH.GetDat(DocLang)->AddHtml(DocStr, DocBlobPt);
1201  }
1202  void TMWdGixBs::GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
1203          TStr& DocStr, TStr& DocLang, TStrV& KeyWdV) const {
1204      PSIn SIn = DocBBs->GetBlob(BlobPt);
1205      DocTitle.Load(*SIn); DocStr.Load(*SIn);
1206      DocLang.Load(*SIn); KeyWdV.Load(*SIn);
1207  }
1208  PMWdGixRSet TMWdGixBs::SearchDoc(const TStr& QueryStr, const TStr& QueryLang,
1209          const TStrV& TargetLangV, const int& Docs, const int& Offset,
1210          PMWdGixRankFun& RankFun) {
1211      if (!AlignPairBs->IsLang(QueryLang)) {
1212          return TMWdGixRSet::New(QueryStr, "", TStrStrH(), 0, 0); }
1213      const int Queries = TargetLangV.Len();
1214      printf("  Translationg %d queries ...\n", Queries);
1215      const int QueryLangId = AlignPairBs->GetLangId(QueryLang);
1216      TStrStrH LangQueryH;
1217      TWgtMWdGixIntItemKdV FullWgtLangItemV;
1218      for (int TargetLangN = 0; TargetLangN < Queries; TargetLangN++) {
1219          if (!AlignPairBs->IsLang(TargetLangV[TargetLangN])) { continue; }
1220          const TStr& TargetLang = TargetLangV[TargetLangN];
1221          const int TargetLangId = AlignPairBs->GetLangId(TargetLang);
1222          if (TargetLangId == QueryLangId) { continue; }
1223          TStr TargetQueryStr = AlignPairBs->MapQuery(
1224              AlignPairMap, QueryStr, QueryLangId, TargetLangId);
1225          LangQueryH.AddDat(TargetLang, TargetQueryStr);
1226          printf("  Query: '%s' -> '%s'\n", QueryStr.CStr(), TargetQueryStr.CStr());
1227          printf("  Loading from Gix ...\n");
1228          TMWdGixItemV LangResItemV;
1229          PMWdGix LangMWdGix = LangMWdGixH.GetDat(TargetLang);
1230          TMWdGixDefMerger LangMerger(LangMWdGix, RankFun);
1231          LangMWdGix->Search(TargetQueryStr, LangResItemV, LangMerger);
1232          double MxWgt = 0.0;
1233          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1234              const TMWdGixItem& Item = LangResItemV[ItemN];
1235              MxWgt = TFlt::GetMx(Item.GetWgt(), MxWgt);
1236          }
1237          printf("  MxWgt: %g\n", MxWgt);
1238          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1239              const TMWdGixItem& Item = LangResItemV[ItemN];
1240              const double Wgt = MxWgt > 0.0 ? Item.GetWgt() / MxWgt : 0.0;
1241              TMWdGixIntItemPr LangItemPr(TargetLangId, Item);
1242              FullWgtLangItemV.Add(TWgtMWdGixIntItemKd(Wgt, LangItemPr));
1243          }
1244      }
1245      FullWgtLangItemV.Sort(false);
1246      printf("  Sorting %d hits ...\n", FullWgtLangItemV.Len());
1247      TWgtMWdGixIntItemKdV WgtLangItemV;
1248      if (Docs == -1) {
1249          WgtLangItemV = FullWgtLangItemV;
1250      } else if (FullWgtLangItemV.Len() >= (Docs + Offset)) {
1251          WgtLangItemV = FullWgtLangItemV;
1252          WgtLangItemV.Sort(false); WgtLangItemV.Trunc(Docs + Offset);
1253          WgtLangItemV.Sort(true); WgtLangItemV.Trunc(Docs);
1254      } else if (FullWgtLangItemV.Len() > Offset) {
1255          WgtLangItemV = FullWgtLangItemV; WgtLangItemV.Sort(true);
1256          WgtLangItemV.Trunc(FullWgtLangItemV.Len() - Offset);
1257      } else {
1258      }
1259      WgtLangItemV.Sort(false);
1260      printf("  Loading content for %d hits ...\n", WgtLangItemV.Len());
1261      PMWdGixRSet RSet = TMWdGixRSet::New(QueryStr,
1262          QueryLang, LangQueryH, FullWgtLangItemV.Len(), Offset);
1263      for (int ItemN = 0; ItemN < WgtLangItemV.Len(); ItemN++) {
1264          const TMWdGixIntItemPr& LangItem = WgtLangItemV[ItemN].Dat;
1265          const TMWdGixItem& Item = LangItem.Val2;
1266          TBlobPt DocBlobPt = Item.GetBlobPt();
1267          TStr DocTitle, DocStr, DocLang; TStrV KeyWdV;
1268          GetDoc(DocBlobPt, DocTitle, DocStr, DocLang, KeyWdV);
1269          RSet->AddDoc(DocTitle, DocStr, DocLang, KeyWdV);
1270      }
1271      printf("  Done\n");
1272      return RSet;
1273  }
1274  void TMWdGixBs::AddAcquis(const TStr& XmlFNm, const TStr& Lang) {
1275      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlFNm);
1276      if (!XmlDoc->IsOk()) { return; }
1277      PXmlTok TopTok = XmlDoc->GetTok();
1278      PXmlTok TextTok = TopTok->GetTagTok("text|body");
1279      if (TextTok.Empty()) { printf("  Bad file '%s'\n", XmlFNm.CStr()); return; }
1280      TStr DocTitle; TChA DocChA;
1281      for (int SubTokN = 0; SubTokN < TextTok->GetSubToks(); SubTokN++) {
1282          PXmlTok SubTok = TextTok->GetSubTok(SubTokN);
1283          if (!SubTok->IsTag()) { continue; }
1284          if (SubTok->GetTagNm() == "head") {
1285              DocTitle = SubTok->GetTokStr(false);
1286          } else if (SubTok->GetTagNm() == "div") {
1287              for (int ParaN = 0; ParaN < SubTok->GetSubToks(); ParaN++) {
1288                  if (SubTok->IsTag()) {
1289                      DocChA += SubTok->GetSubTok(ParaN)->GetTokStr(false);
1290                      DocChA += '\n';
1291                  }
1292              }
1293              DocChA += '\n';
1294          }
1295      }
1296      TStrV KeyWdV;
1297      PXmlTok KeyWdTok = TopTok->GetTagTok("teiHeader|profileDesc|textClass");
1298      if (!KeyWdTok.Empty()) {
1299          for (int SubTokN = 0; SubTokN < KeyWdTok->GetSubToks(); SubTokN++) {
1300              PXmlTok SubTok = KeyWdTok->GetSubTok(SubTokN);
1301              if (!SubTok->IsTag()) { continue; }
1302              if (SubTok->IsArg("scheme")) {
1303                  KeyWdV.Add(SubTok->GetStrArgVal("scheme") + "-" + SubTok->GetTokStr(false));
1304              }
1305          }
1306      }
1307      if (!KeyWdV.Empty()) { AddDoc(DocTitle, DocChA, Lang, KeyWdV); }
1308  }
1309  void TMWdGixBs::IndexAcquis(const TStr& InFPath, PAlignPairBs _AlignPairBs,
1310          const int& MxDocs, const int64& IndexCacheSize) {
1311      AlignPairBs = _AlignPairBs;
1312      int LangId = AlignPairBs->FFirstLangId();
1313      while (AlignPairBs->FNextLangId(LangId)) {
1314          const TStr& Lang = AlignPairBs->GetLang(LangId);
1315          TStr LangFPath = InFPath + "/" + Lang;
1316          printf("Indexing %s ...\n", LangFPath.CStr());
1317          LangMWdGixH.AddDat(Lang) =
1318                  TMWdGix::New(FPath + "/" + Lang, FAccess, IndexCacheSize);
1319          TFFile FFile(LangFPath, ".xml", true);
1320          TStr XmlFNm; int XmlFNms = 0;
1321          while (FFile.Next(XmlFNm)) {
1322              if (XmlFNms == MxDocs) { break; }
1323              if (XmlFNms % 100 == 0) { printf("  %d\r", XmlFNms); }
1324              try { AddAcquis(XmlFNm, Lang); } catch (...) { }
1325              XmlFNms++;
1326          } printf("\n");
1327          LangMWdGixH.Clr();
1328      }
1329      InitGixs(faRdOnly);
1330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_split_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>540      EXPECT_THAT(v, ElementsAre("a", " ", "b"));
541    }
542  }
543  TEST(Split, SubstrDelimiter) {
544    std::vector<absl::string_view> results;
545    absl::string_view delim("&bsol;&bsol;");
546    results = absl::StrSplit("", delim);
547    EXPECT_THAT(results, ElementsAre(""));
</pre></code></div>
                <div class="column column_space"><pre><code>983      CsvOut->Flush();
984  }
985  void TTrGixBs::IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm, const int& MxTrs) {
986      PNotify Notify = TStdNotify::New();
987      Notify->OnStatus("Loading Reuters documents from " + XmlFPath + " ...\n");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    