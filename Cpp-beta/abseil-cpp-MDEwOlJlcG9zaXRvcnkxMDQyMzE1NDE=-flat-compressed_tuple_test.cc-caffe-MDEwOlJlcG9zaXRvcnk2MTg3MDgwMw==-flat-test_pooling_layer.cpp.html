
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.707317073170733%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-compressed_tuple_test.cc</h3>
            <pre><code>1  #include "absl/container/internal/compressed_tuple.h"
2  #include <memory>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/container/internal/test_instance_tracker.h"
7  #include "absl/memory/memory.h"
8  #include "absl/types/any.h"
9  #include "absl/types/optional.h"
10  #include "absl/utility/utility.h"
11  enum class CallType { kConstRef, kConstMove };
12  template <int>
13  struct Empty {
14    constexpr CallType value() const& { return CallType::kConstRef; }
15    constexpr CallType value() const&& { return CallType::kConstMove; }
16  };
17  template <typename T>
18  struct NotEmpty {
19    T value;
20  };
21  template <typename T, typename U>
22  struct TwoValues {
23    T value1;
24    U value2;
25  };
26  namespace absl {
27  ABSL_NAMESPACE_BEGIN
28  namespace container_internal {
29  namespace {
30  using absl::test_internal::CopyableMovableInstance;
31  using absl::test_internal::InstanceTracker;
32  TEST(CompressedTupleTest, Sizeof) {
33    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int>));
34    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int, Empty<0>>));
35    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int, Empty<0>, Empty<1>>));
36    EXPECT_EQ(sizeof(int),
37              sizeof(CompressedTuple<int, Empty<0>, Empty<1>, Empty<2>>));
38    EXPECT_EQ(sizeof(TwoValues<int, double>),
39              sizeof(CompressedTuple<int, NotEmpty<double>>));
40    EXPECT_EQ(sizeof(TwoValues<int, double>),
41              sizeof(CompressedTuple<int, Empty<0>, NotEmpty<double>>));
42    EXPECT_EQ(sizeof(TwoValues<int, double>),
43              sizeof(CompressedTuple<int, Empty<0>, NotEmpty<double>, Empty<1>>));
44  }
45  TEST(CompressedTupleTest, OneMoveOnRValueConstructionTemp) {
46    InstanceTracker tracker;
47    CompressedTuple<CopyableMovableInstance> x1(CopyableMovableInstance(1));
48    EXPECT_EQ(tracker.instances(), 1);
49    EXPECT_EQ(tracker.copies(), 0);
50    EXPECT_LE(tracker.moves(), 1);
51    EXPECT_EQ(x1.get<0>().value(), 1);
52  }
53  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMove) {
54    InstanceTracker tracker;
55    CopyableMovableInstance i1(1);
56    CompressedTuple<CopyableMovableInstance> x1(std::move(i1));
<span onclick='openModal()' class='match'>57    EXPECT_EQ(tracker.instances(), 2);
58    EXPECT_EQ(tracker.copies(), 0);
59    EXPECT_LE(tracker.moves(), 1);
60    EXPECT_EQ(x1.get<0>().value(), 1);
61  }
62  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMixedTypes) {
63    InstanceTracker tracker;
64    CopyableMovableInstance i1(1);
</span>65    CopyableMovableInstance i2(2);
66    Empty<0> empty;
67    CompressedTuple<CopyableMovableInstance, CopyableMovableInstance&, Empty<0>>
68        x1(std::move(i1), i2, empty);
69    EXPECT_EQ(x1.get<0>().value(), 1);
70    EXPECT_EQ(x1.get<1>().value(), 2);
71    EXPECT_EQ(tracker.copies(), 0);
72    EXPECT_EQ(tracker.moves(), 1);
73  }
74  struct IncompleteType;
75  CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>>
76  MakeWithIncomplete(CopyableMovableInstance i1,
77                     IncompleteType& t,  
78                     Empty<0> empty) {
79    return CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>>{
80        std::move(i1), t, empty};
81  }
82  struct IncompleteType {};
83  TEST(CompressedTupleTest, OneMoveOnRValueConstructionWithIncompleteType) {
84    InstanceTracker tracker;
85    CopyableMovableInstance i1(1);
86    Empty<0> empty;
87    struct DerivedType : IncompleteType {int value = 0;};
88    DerivedType fd;
89    fd.value = 7;
90    CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>> x1 =
91        MakeWithIncomplete(std::move(i1), fd, empty);
92    EXPECT_EQ(x1.get<0>().value(), 1);
93    EXPECT_EQ(static_cast<DerivedType&>(x1.get<1>()).value, 7);
94    EXPECT_EQ(tracker.copies(), 0);
95    EXPECT_EQ(tracker.moves(), 2);
96  }
97  TEST(CompressedTupleTest,
98       OneMoveOnRValueConstructionMixedTypes_BraceInitPoisonPillExpected) {
99    InstanceTracker tracker;
100    CopyableMovableInstance i1(1);
101    CopyableMovableInstance i2(2);
102    CompressedTuple<CopyableMovableInstance, CopyableMovableInstance&, Empty<0>>
103        x1(std::move(i1), i2, {});  
104    EXPECT_EQ(x1.get<0>().value(), 1);
105    EXPECT_EQ(x1.get<1>().value(), 2);
106    EXPECT_EQ(tracker.instances(), 3);
107    EXPECT_EQ(tracker.copies(), 1);
108    EXPECT_EQ(tracker.moves(), 0);
109  }
110  TEST(CompressedTupleTest, OneCopyOnLValueConstruction) {
111    InstanceTracker tracker;
112    CopyableMovableInstance i1(1);
113    CompressedTuple<CopyableMovableInstance> x1(i1);
114    EXPECT_EQ(tracker.copies(), 1);
115    EXPECT_EQ(tracker.moves(), 0);
116    tracker.ResetCopiesMovesSwaps();
117    CopyableMovableInstance i2(2);
118    const CopyableMovableInstance& i2_ref = i2;
119    CompressedTuple<CopyableMovableInstance> x2(i2_ref);
120    EXPECT_EQ(tracker.copies(), 1);
121    EXPECT_EQ(tracker.moves(), 0);
122  }
123  TEST(CompressedTupleTest, OneMoveOnRValueAccess) {
124    InstanceTracker tracker;
125    CopyableMovableInstance i1(1);
126    CompressedTuple<CopyableMovableInstance> x(std::move(i1));
127    tracker.ResetCopiesMovesSwaps();
128    CopyableMovableInstance i2 = std::move(x).get<0>();
129    EXPECT_EQ(tracker.copies(), 0);
130    EXPECT_EQ(tracker.moves(), 1);
131  }
132  TEST(CompressedTupleTest, OneCopyOnLValueAccess) {
133    InstanceTracker tracker;
134    CompressedTuple<CopyableMovableInstance> x(CopyableMovableInstance(0));
135    EXPECT_EQ(tracker.copies(), 0);
136    EXPECT_EQ(tracker.moves(), 1);
137    CopyableMovableInstance t = x.get<0>();
138    EXPECT_EQ(tracker.copies(), 1);
139    EXPECT_EQ(tracker.moves(), 1);
140  }
141  TEST(CompressedTupleTest, ZeroCopyOnRefAccess) {
142    InstanceTracker tracker;
143    CompressedTuple<CopyableMovableInstance> x(CopyableMovableInstance(0));
144    EXPECT_EQ(tracker.copies(), 0);
145    EXPECT_EQ(tracker.moves(), 1);
146    CopyableMovableInstance& t1 = x.get<0>();
147    const CopyableMovableInstance& t2 = x.get<0>();
148    EXPECT_EQ(tracker.copies(), 0);
149    EXPECT_EQ(tracker.moves(), 1);
150    EXPECT_EQ(t1.value(), 0);
151    EXPECT_EQ(t2.value(), 0);
152  }
153  TEST(CompressedTupleTest, Access) {
154    struct S {
155      std::string x;
156    };
157    CompressedTuple<int, Empty<0>, S> x(7, {}, S{"ABC"});
158    EXPECT_EQ(sizeof(x), sizeof(TwoValues<int, S>));
159    EXPECT_EQ(7, x.get<0>());
160    EXPECT_EQ("ABC", x.get<2>().x);
161  }
162  TEST(CompressedTupleTest, NonClasses) {
163    CompressedTuple<int, const char*> x(7, "ABC");
164    EXPECT_EQ(7, x.get<0>());
165    EXPECT_STREQ("ABC", x.get<1>());
166  }
167  TEST(CompressedTupleTest, MixClassAndNonClass) {
168    CompressedTuple<int, const char*, Empty<0>, NotEmpty<double>> x(7, "ABC", {},
169                                                                    {1.25});
170    struct Mock {
171      int v;
172      const char* p;
173      double d;
174    };
175    EXPECT_EQ(sizeof(x), sizeof(Mock));
176    EXPECT_EQ(7, x.get<0>());
177    EXPECT_STREQ("ABC", x.get<1>());
178    EXPECT_EQ(1.25, x.get<3>().value);
179  }
180  TEST(CompressedTupleTest, Nested) {
181    CompressedTuple<int, CompressedTuple<int>,
182                    CompressedTuple<int, CompressedTuple<int>>>
183        x(1, CompressedTuple<int>(2),
184          CompressedTuple<int, CompressedTuple<int>>(3, CompressedTuple<int>(4)));
185    EXPECT_EQ(1, x.get<0>());
186    EXPECT_EQ(2, x.get<1>().get<0>());
187    EXPECT_EQ(3, x.get<2>().get<0>());
188    EXPECT_EQ(4, x.get<2>().get<1>().get<0>());
189    CompressedTuple<Empty<0>, Empty<0>,
190                    CompressedTuple<Empty<0>, CompressedTuple<Empty<0>>>>
191        y;
192    std::set<Empty<0>*> empties{&y.get<0>(), &y.get<1>(), &y.get<2>().get<0>(),
193                                &y.get<2>().get<1>().get<0>()};
194  #ifdef _MSC_VER
195    int expected = 1;
196  #else
197    int expected = 4;
198  #endif
199    EXPECT_EQ(expected, sizeof(y));
200    EXPECT_EQ(expected, empties.size());
201    EXPECT_EQ(sizeof(y), sizeof(Empty<0>) * empties.size());
202    EXPECT_EQ(4 * sizeof(char),
203              sizeof(CompressedTuple<CompressedTuple<char, char>,
204                                     CompressedTuple<char, char>>));
205    EXPECT_TRUE((std::is_empty<CompressedTuple<Empty<0>, Empty<1>>>::value));
206    struct CT_Empty : CompressedTuple<Empty<0>> {};
207    CompressedTuple<Empty<0>, CT_Empty> nested_empty;
208    auto contained = nested_empty.get<0>();
209    auto nested = nested_empty.get<1>().get<0>();
210    EXPECT_TRUE((std::is_same<decltype(contained), decltype(nested)>::value));
211  }
212  TEST(CompressedTupleTest, Reference) {
213    int i = 7;
214    std::string s = "Very long string that goes in the heap";
215    CompressedTuple<int, int&, std::string, std::string&> x(i, i, s, s);
216    EXPECT_EQ(s, "Very long string that goes in the heap");
217    EXPECT_EQ(x.get<0>(), x.get<1>());
218    EXPECT_NE(&x.get<0>(), &x.get<1>());
219    EXPECT_EQ(&x.get<1>(), &i);
220    EXPECT_EQ(x.get<2>(), x.get<3>());
221    EXPECT_NE(&x.get<2>(), &x.get<3>());
222    EXPECT_EQ(&x.get<3>(), &s);
223  }
224  TEST(CompressedTupleTest, NoElements) {
225    CompressedTuple<> x;
226    static_cast<void>(x);  
227    EXPECT_TRUE(std::is_empty<CompressedTuple<>>::value);
228  }
229  TEST(CompressedTupleTest, MoveOnlyElements) {
230    CompressedTuple<std::unique_ptr<std::string>> str_tup(
231        absl::make_unique<std::string>("str"));
232    CompressedTuple<CompressedTuple<std::unique_ptr<std::string>>,
233                    std::unique_ptr<int>>
234    x(std::move(str_tup), absl::make_unique<int>(5));
235    EXPECT_EQ(*x.get<0>().get<0>(), "str");
236    EXPECT_EQ(*x.get<1>(), 5);
237    std::unique_ptr<std::string> x0 = std::move(x.get<0>()).get<0>();
238    std::unique_ptr<int> x1 = std::move(x).get<1>();
239    EXPECT_EQ(*x0, "str");
240    EXPECT_EQ(*x1, 5);
241  }
242  TEST(CompressedTupleTest, MoveConstructionMoveOnlyElements) {
243    CompressedTuple<std::unique_ptr<std::string>> base(
244        absl::make_unique<std::string>("str"));
245    EXPECT_EQ(*base.get<0>(), "str");
246    CompressedTuple<std::unique_ptr<std::string>> copy(std::move(base));
247    EXPECT_EQ(*copy.get<0>(), "str");
248  }
249  TEST(CompressedTupleTest, AnyElements) {
250    any a(std::string("str"));
251    CompressedTuple<any, any&> x(any(5), a);
252    EXPECT_EQ(absl::any_cast<int>(x.get<0>()), 5);
253    EXPECT_EQ(absl::any_cast<std::string>(x.get<1>()), "str");
254    a = 0.5f;
255    EXPECT_EQ(absl::any_cast<float>(x.get<1>()), 0.5);
256  }
257  TEST(CompressedTupleTest, Constexpr) {
258    struct NonTrivialStruct {
259      constexpr NonTrivialStruct() = default;
260      constexpr int value() const { return v; }
261      int v = 5;
262    };
263    struct TrivialStruct {
264      TrivialStruct() = default;
265      constexpr int value() const { return v; }
266      int v;
267    };
268    constexpr CompressedTuple<int, double, CompressedTuple<int>, Empty<0>> x(
269        7, 1.25, CompressedTuple<int>(5), {});
270    constexpr int x0 = x.get<0>();
271    constexpr double x1 = x.get<1>();
272    constexpr int x2 = x.get<2>().get<0>();
273    constexpr CallType x3 = x.get<3>().value();
274    EXPECT_EQ(x0, 7);
275    EXPECT_EQ(x1, 1.25);
276    EXPECT_EQ(x2, 5);
277    EXPECT_EQ(x3, CallType::kConstRef);
278  #if !defined(__GNUC__) || defined(__clang__) || __GNUC__ > 4
279    constexpr CompressedTuple<Empty<0>, TrivialStruct, int> trivial = {};
280    constexpr CallType trivial0 = trivial.get<0>().value();
281    constexpr int trivial1 = trivial.get<1>().value();
282    constexpr int trivial2 = trivial.get<2>();
283    EXPECT_EQ(trivial0, CallType::kConstRef);
284    EXPECT_EQ(trivial1, 0);
285    EXPECT_EQ(trivial2, 0);
286  #endif
287    constexpr CompressedTuple<Empty<0>, NonTrivialStruct, absl::optional<int>>
288        non_trivial = {};
289    constexpr CallType non_trivial0 = non_trivial.get<0>().value();
290    constexpr int non_trivial1 = non_trivial.get<1>().value();
291    constexpr absl::optional<int> non_trivial2 = non_trivial.get<2>();
292    EXPECT_EQ(non_trivial0, CallType::kConstRef);
293    EXPECT_EQ(non_trivial1, 5);
294    EXPECT_EQ(non_trivial2, absl::nullopt);
295    static constexpr char data[] = "DEF";
296    constexpr CompressedTuple<const char*> z(data);
297    constexpr const char* z1 = z.get<0>();
298    EXPECT_EQ(std::string(z1), std::string(data));
299  #if defined(__clang__)
300    constexpr int x2m = absl::move(x.get<2>()).get<0>();
301    constexpr CallType x3m = absl::move(x).get<3>().value();
302    EXPECT_EQ(x2m, 5);
303    EXPECT_EQ(x3m, CallType::kConstMove);
304  #endif
305  }
306  #if defined(__clang__) || defined(__GNUC__)
307  TEST(CompressedTupleTest, EmptyFinalClass) {
308    struct S final {
309      int f() const { return 5; }
310    };
311    CompressedTuple<S> x;
312    EXPECT_EQ(x.get<0>().f(), 5);
313  }
314  #endif
315  TEST(CompressedTupleTest, DISABLED_NestedEbo) {
316    struct Empty1 {};
317    struct Empty2 {};
318    CompressedTuple<Empty1, CompressedTuple<Empty2>, int> x;
319    CompressedTuple<Empty1, Empty2, int> y;
320    EXPECT_EQ(sizeof(x), sizeof(y));
321  }
322  }  
323  }  
324  ABSL_NAMESPACE_END
325  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_pooling_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "gtest/gtest.h"
3  #include "caffe/blob.hpp"
4  #include "caffe/common.hpp"
5  #include "caffe/filler.hpp"
6  #include "caffe/layers/pooling_layer.hpp"
7  #ifdef USE_CUDNN
8  #include "caffe/layers/cudnn_pooling_layer.hpp"
9  #endif
10  #include "caffe/test/test_caffe_main.hpp"
11  #include "caffe/test/test_gradient_check_util.hpp"
12  namespace caffe {
13  template <typename TypeParam>
14  class PoolingLayerTest : public MultiDeviceTest<TypeParam> {
15    typedef typename TypeParam::Dtype Dtype;
16   protected:
17    PoolingLayerTest()
18        : blob_bottom_(new Blob<Dtype>()),
19          blob_top_(new Blob<Dtype>()),
20          blob_top_mask_(new Blob<Dtype>()) {}
21    virtual void SetUp() {
22      Caffe::set_random_seed(1701);
23      blob_bottom_->Reshape(2, 3, 6, 5);
24      FillerParameter filler_param;
25      GaussianFiller<Dtype> filler(filler_param);
26      filler.Fill(this->blob_bottom_);
27      blob_bottom_vec_.push_back(blob_bottom_);
28      blob_top_vec_.push_back(blob_top_);
29    }
30    virtual ~PoolingLayerTest() {
31      delete blob_bottom_;
32      delete blob_top_;
33      delete blob_top_mask_;
34    }
35    Blob<Dtype>* const blob_bottom_;
36    Blob<Dtype>* const blob_top_;
37    Blob<Dtype>* const blob_top_mask_;
38    vector<Blob<Dtype>*> blob_bottom_vec_;
39    vector<Blob<Dtype>*> blob_top_vec_;
40    void TestForwardSquare() {
41      LayerParameter layer_param;
42      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
43      pooling_param->set_kernel_size(2);
44      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
45      const int num = 2;
46      const int channels = 2;
47      blob_bottom_->Reshape(num, channels, 3, 5);
48      for (int i = 0; i < 15 * num * channels; i += 15) {
49        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
50        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
52        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
53        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
54        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
55        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
57        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
58        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
59        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
60        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
62        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
63        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
64      }
65      PoolingLayer<Dtype> layer(layer_param);
66      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
67      EXPECT_EQ(blob_top_->num(), num);
68      EXPECT_EQ(blob_top_->channels(), channels);
69      EXPECT_EQ(blob_top_->height(), 2);
70      EXPECT_EQ(blob_top_->width(), 4);
71      if (blob_top_vec_.size() > 1) {
72        EXPECT_EQ(blob_top_mask_->num(), num);
73        EXPECT_EQ(blob_top_mask_->channels(), channels);
74        EXPECT_EQ(blob_top_mask_->height(), 2);
75        EXPECT_EQ(blob_top_mask_->width(), 4);
76      }
77      layer.Forward(blob_bottom_vec_, blob_top_vec_);
78      for (int i = 0; i < 8 * num * channels; i += 8) {
79        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
85        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
86        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
87      }
88      if (blob_top_vec_.size() > 1) {
89        for (int i = 0; i < 8 * num * channels; i += 8) {
90          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
91          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
92          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
93          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
94          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
95          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
96          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
97          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
98        }
99      }
100    }
101    void TestForwardRectHigh() {
102      LayerParameter layer_param;
103      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
104      pooling_param->set_kernel_h(3);
105      pooling_param->set_kernel_w(2);
106      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
107      const int num = 2;
108      const int channels = 2;
109      blob_bottom_->Reshape(num, channels, 6, 6);
110      for (int i = 0; i < 36 * num * channels; i += 36) {
111        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
112        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
113        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
114        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
115        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
116        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
117        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
118        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
119        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
120        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
121        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
122        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
123        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
124        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
125        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
126        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
127        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
128        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
129        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
130        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
131        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
132        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
133        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
134        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
135        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
136        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
137        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
138        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
139        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
140        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
141        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
142        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
143        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
144        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
145        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
146        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
147      }
148      PoolingLayer<Dtype> layer(layer_param);
149      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
150      EXPECT_EQ(blob_top_->num(), num);
151      EXPECT_EQ(blob_top_->channels(), channels);
152      EXPECT_EQ(blob_top_->height(), 4);
153      EXPECT_EQ(blob_top_->width(), 5);
154      if (blob_top_vec_.size() > 1) {
155        EXPECT_EQ(blob_top_mask_->num(), num);
156        EXPECT_EQ(blob_top_mask_->channels(), channels);
157        EXPECT_EQ(blob_top_mask_->height(), 4);
158        EXPECT_EQ(blob_top_mask_->width(), 5);
159      }
160      layer.Forward(blob_bottom_vec_, blob_top_vec_);
161      for (int i = 0; i < 20 * num * channels; i += 20) {
162        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
170        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
171        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
180        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
181        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
182      }
183      if (blob_top_vec_.size() > 1) {
184        for (int i = 0; i < 20 * num * channels; i += 20) {
185          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
186          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
187          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
188          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
189          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
190          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
191          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
192          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
193          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
194          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
195          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
196          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
197          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
198          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
199          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
200          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
201          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
202          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
203          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
204          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
205        }
206      }
207    }
208    void TestForwardRectWide() {
209      LayerParameter layer_param;
210      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
211      pooling_param->set_kernel_h(2);
212      pooling_param->set_kernel_w(3);
213      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
214      const int num = 2;
215      const int channels = 2;
216      blob_bottom_->Reshape(num, channels, 6, 6);
217      for (int i = 0; i < 36 * num * channels; i += 36) {
218        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
219        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
220        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
221        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
222        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
223        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
224        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
225        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
226        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
227        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
228        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
229        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
230        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
231        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
232        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
233        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
234        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
235        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
236        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
237        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
238        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
239        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
240        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
241        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
242        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
243        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
244        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
245        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
246        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
247        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
248        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
249        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
250        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
251        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
252        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
253        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
254      }
255      PoolingLayer<Dtype> layer(layer_param);
256      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
257      EXPECT_EQ(blob_top_->num(), num);
258      EXPECT_EQ(blob_top_->channels(), channels);
259      EXPECT_EQ(blob_top_->height(), 5);
260      EXPECT_EQ(blob_top_->width(), 4);
261      if (blob_top_vec_.size() > 1) {
262        EXPECT_EQ(blob_top_mask_->num(), num);
263        EXPECT_EQ(blob_top_mask_->channels(), channels);
264        EXPECT_EQ(blob_top_mask_->height(), 5);
265        EXPECT_EQ(blob_top_mask_->width(), 4);
266      }
267      layer.Forward(blob_bottom_vec_, blob_top_vec_);
268      for (int i = 0; i < 20 * num * channels; i += 20) {
269        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
277        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
287        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
288        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
289      }
290      if (blob_top_vec_.size() > 1) {
291        for (int i = 0; i < 20 * num * channels; i += 20) {
292          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
293          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
294          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
295          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
296          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
297          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
298          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
299          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
300          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
301          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
302          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
303          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
304          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
305          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
306          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
307          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
308          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
309          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
310          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
311          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
312        }
313      }
314    }
315  };
316  TYPED_TEST_CASE(PoolingLayerTest, TestDtypesAndDevices);
317  TYPED_TEST(PoolingLayerTest, TestSetup) {
318    typedef typename TypeParam::Dtype Dtype;
319    LayerParameter layer_param;
320    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
321    pooling_param->set_kernel_size(3);
322    pooling_param->set_stride(2);
323    PoolingLayer<Dtype> layer(layer_param);
324    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
325    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
326    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
327    EXPECT_EQ(this->blob_top_->height(), 3);
328    EXPECT_EQ(this->blob_top_->width(), 2);
329  }
330  TYPED_TEST(PoolingLayerTest, TestSetupPadded) {
331    typedef typename TypeParam::Dtype Dtype;
332    LayerParameter layer_param;
333    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
334    pooling_param->set_kernel_size(3);
335    pooling_param->set_stride(2);
336    pooling_param->set_pad(1);
337    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
338    PoolingLayer<Dtype> layer(layer_param);
339    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
340    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
341    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
342    EXPECT_EQ(this->blob_top_->height(), 4);
343    EXPECT_EQ(this->blob_top_->width(), 3);
344  }
345  TYPED_TEST(PoolingLayerTest, TestSetupGlobalPooling) {
346    typedef typename TypeParam::Dtype Dtype;
347    LayerParameter layer_param;
348    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
349    pooling_param->set_global_pooling(true);
350    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
351    PoolingLayer<Dtype> layer(layer_param);
352    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
353    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
354    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
355    EXPECT_EQ(this->blob_top_->height(), 1);
356    EXPECT_EQ(this->blob_top_->width(), 1);
357  }
358  TYPED_TEST(PoolingLayerTest, TestForwardMax) {
359    this->TestForwardSquare();
360    this->TestForwardRectHigh();
361    this->TestForwardRectWide();
362  }
363  TYPED_TEST(PoolingLayerTest, TestForwardMaxTopMask) {
364    this->blob_top_vec_.push_back(this->blob_top_mask_);
365    this->TestForwardSquare();
366    this->TestForwardRectHigh();
367    this->TestForwardRectWide();
368  }
369  TYPED_TEST(PoolingLayerTest, TestGradientMax) {
370    typedef typename TypeParam::Dtype Dtype;
371    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
372      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
373        LayerParameter layer_param;
374        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
375        pooling_param->set_kernel_h(kernel_h);
376        pooling_param->set_kernel_w(kernel_w);
377        pooling_param->set_stride(2);
378        pooling_param->set_pad(1);
379        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
380        PoolingLayer<Dtype> layer(layer_param);
381        GradientChecker<Dtype> checker(1e-4, 1e-2);
382        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
383            this->blob_top_vec_);
384      }
385    }
386  }
387  TYPED_TEST(PoolingLayerTest, TestForwardMaxPadded) {
388    typedef typename TypeParam::Dtype Dtype;
389    LayerParameter layer_param;
390    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
391    pooling_param->set_kernel_size(3);
392    pooling_param->set_stride(2);
393    pooling_param->set_pad(2);
394    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
395    this->blob_bottom_->Reshape(1, 1, 3, 3);
396    this->blob_bottom_->mutable_cpu_data()[0] = 1;
397    this->blob_bottom_->mutable_cpu_data()[1] = 2;
398    this->blob_bottom_->mutable_cpu_data()[2] = 4;
399    this->blob_bottom_->mutable_cpu_data()[3] = 2;
400    this->blob_bottom_->mutable_cpu_data()[4] = 3;
401    this->blob_bottom_->mutable_cpu_data()[5] = 2;
402    this->blob_bottom_->mutable_cpu_data()[6] = 4;
403    this->blob_bottom_->mutable_cpu_data()[7] = 2;
404    this->blob_bottom_->mutable_cpu_data()[8] = 1;
405    PoolingLayer<Dtype> layer(layer_param);
406    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
407    EXPECT_EQ(this->blob_top_->num(), 1);
408    EXPECT_EQ(this->blob_top_->channels(), 1);
409    EXPECT_EQ(this->blob_top_->height(), 3);
410    EXPECT_EQ(this->blob_top_->width(), 3);
411    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
412    Dtype epsilon = 1e-8;
413    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
414    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
415    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
416    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
417    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
418    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
419    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
422  }
423  TYPED_TEST(PoolingLayerTest, TestGradientMaxTopMask) {
424    typedef typename TypeParam::Dtype Dtype;
425    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
426      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
427        LayerParameter layer_param;
428        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
429        pooling_param->set_kernel_h(kernel_h);
430        pooling_param->set_kernel_w(kernel_w);
431        pooling_param->set_stride(2);
432        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
433        this->blob_top_vec_.push_back(this->blob_top_mask_);
434        PoolingLayer<Dtype> layer(layer_param);
435        GradientChecker<Dtype> checker(1e-4, 1e-2);
436        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
437            this->blob_top_vec_);
438        this->blob_top_vec_.pop_back();
439      }
440    }
441  }
442  TYPED_TEST(PoolingLayerTest, TestForwardAve) {
443    typedef typename TypeParam::Dtype Dtype;
444    LayerParameter layer_param;
445    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
446    pooling_param->set_kernel_size(3);
447    pooling_param->set_stride(1);
448    pooling_param->set_pad(1);
449    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
450    this->blob_bottom_->Reshape(1, 1, 3, 3);
451    FillerParameter filler_param;
452    filler_param.set_value(Dtype(2));
453    ConstantFiller<Dtype> filler(filler_param);
454    filler.Fill(this->blob_bottom_);
455    PoolingLayer<Dtype> layer(layer_param);
456    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
457    EXPECT_EQ(this->blob_top_->num(), 1);
458    EXPECT_EQ(this->blob_top_->channels(), 1);
459    EXPECT_EQ(this->blob_top_->height(), 3);
460    EXPECT_EQ(this->blob_top_->width(), 3);
461    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
462    Dtype epsilon = 1e-5;
463    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
464    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4.0 / 3, epsilon);
465    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
466    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4.0 / 3, epsilon);
467    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
468    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4.0 / 3, epsilon);
469    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
470    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4.0 / 3, epsilon);
471    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
472  }
473  TYPED_TEST(PoolingLayerTest, TestGradientAve) {
474    typedef typename TypeParam::Dtype Dtype;
475    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
476      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
477        LayerParameter layer_param;
478        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
479        pooling_param->set_kernel_h(kernel_h);
480        pooling_param->set_kernel_w(kernel_w);
481        pooling_param->set_stride(2);
482        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
483        PoolingLayer<Dtype> layer(layer_param);
484        GradientChecker<Dtype> checker(1e-2, 1e-2);
485        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
486            this->blob_top_vec_);
487      }
488    }
489  }
490  TYPED_TEST(PoolingLayerTest, TestGradientAvePadded) {
491    typedef typename TypeParam::Dtype Dtype;
492    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
493      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
494        LayerParameter layer_param;
495        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
496        pooling_param->set_kernel_h(kernel_h);
497        pooling_param->set_kernel_w(kernel_w);
498        pooling_param->set_stride(2);
499        pooling_param->set_pad(2);
500        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
501        PoolingLayer<Dtype> layer(layer_param);
502        GradientChecker<Dtype> checker(1e-2, 1e-2);
503        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
504            this->blob_top_vec_);
505      }
506    }
507  }
508  #ifdef USE_CUDNN
509  template <typename Dtype>
510  class CuDNNPoolingLayerTest : public GPUDeviceTest<Dtype> {
511   protected:
512    CuDNNPoolingLayerTest()
513        : blob_bottom_(new Blob<Dtype>()),
514          blob_top_(new Blob<Dtype>()),
515          blob_top_mask_(new Blob<Dtype>()) {}
516    virtual void SetUp() {
517      Caffe::set_random_seed(1701);
518      blob_bottom_->Reshape(2, 3, 6, 5);
519      FillerParameter filler_param;
520      GaussianFiller<Dtype> filler(filler_param);
521      filler.Fill(this->blob_bottom_);
522      blob_bottom_vec_.push_back(blob_bottom_);
523      blob_top_vec_.push_back(blob_top_);
524    }
525    virtual ~CuDNNPoolingLayerTest() {
526      delete blob_bottom_;
527      delete blob_top_;
528      delete blob_top_mask_;
529    }
530    Blob<Dtype>* const blob_bottom_;
531    Blob<Dtype>* const blob_top_;
532    Blob<Dtype>* const blob_top_mask_;
533    vector<Blob<Dtype>*> blob_bottom_vec_;
534    vector<Blob<Dtype>*> blob_top_vec_;
535    void TestForwardSquare() {
536      LayerParameter layer_param;
537      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
538      pooling_param->set_kernel_size(2);
539      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
540      const int num = 2;
541      const int channels = 2;
542      blob_bottom_->Reshape(num, channels, 3, 5);
543      for (int i = 0; i < 15 * num * channels; i += 15) {
544        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
545        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
546        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
547        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
548        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
549        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
550        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
551        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
552        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
553        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
554        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
555        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
556        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
557        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
558        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
559      }
560      CuDNNPoolingLayer<Dtype> layer(layer_param);
561      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
562      EXPECT_EQ(blob_top_->num(), num);
563      EXPECT_EQ(blob_top_->channels(), channels);
564      EXPECT_EQ(blob_top_->height(), 2);
565      EXPECT_EQ(blob_top_->width(), 4);
566      if (blob_top_vec_.size() > 1) {
567        EXPECT_EQ(blob_top_mask_->num(), num);
568        EXPECT_EQ(blob_top_mask_->channels(), channels);
569        EXPECT_EQ(blob_top_mask_->height(), 2);
570        EXPECT_EQ(blob_top_mask_->width(), 4);
571      }
572      layer.Forward(blob_bottom_vec_, blob_top_vec_);
573      for (int i = 0; i < 8 * num * channels; i += 8) {
574        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
575        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
576        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
577        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
578        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
579        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
580        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
581        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
582      }
583      if (blob_top_vec_.size() > 1) {
584        for (int i = 0; i < 8 * num * channels; i += 8) {
585          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
586          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
587          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
588          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
589          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
590          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
591          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
592          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
593        }
594      }
595    }
596    void TestForwardRectHigh() {
597      LayerParameter layer_param;
598      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
599      pooling_param->set_kernel_h(3);
600      pooling_param->set_kernel_w(2);
601      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
602      const int num = 2;
603      const int channels = 2;
604      blob_bottom_->Reshape(num, channels, 6, 6);
605      for (int i = 0; i < 36 * num * channels; i += 36) {
606        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
607        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
608        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
609        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
610        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
611        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
612        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
613        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
614        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
615        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
616        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
617        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
618        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
619        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
620        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
621        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
622        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
623        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
624        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
625        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
626        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
627        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
628        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
629        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
630        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
631        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
632        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
633        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
634        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
635        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
636        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
637        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
638        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
639        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
640        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
641        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
642      }
643      CuDNNPoolingLayer<Dtype> layer(layer_param);
644      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
645      EXPECT_EQ(blob_top_->num(), num);
646      EXPECT_EQ(blob_top_->channels(), channels);
647      EXPECT_EQ(blob_top_->height(), 4);
648      EXPECT_EQ(blob_top_->width(), 5);
649      if (blob_top_vec_.size() > 1) {
650        EXPECT_EQ(blob_top_mask_->num(), num);
651        EXPECT_EQ(blob_top_mask_->channels(), channels);
652        EXPECT_EQ(blob_top_mask_->height(), 4);
653        EXPECT_EQ(blob_top_mask_->width(), 5);
654      }
655      layer.Forward(blob_bottom_vec_, blob_top_vec_);
656      for (int i = 0; i < 20 * num * channels; i += 20) {
657        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
658        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
659        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
660        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
661        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
662        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
663        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
664        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
665        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
666        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
667        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
668        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
669        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
670        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
671        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
672        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
673        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
674        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
675        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
676        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
677      }
678      if (blob_top_vec_.size() > 1) {
679        for (int i = 0; i < 20 * num * channels; i += 20) {
680          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
681          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
682          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
683          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
684          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
685          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
686          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
687          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
688          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
689          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
690          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
691          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
692          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
693          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
694          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
695          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
696          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
697          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
698          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
699          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
700        }
701      }
702    }
703    void TestForwardRectWide() {
704      LayerParameter layer_param;
705      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
706      pooling_param->set_kernel_h(2);
707      pooling_param->set_kernel_w(3);
708      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
709      const int num = 2;
710      const int channels = 2;
711      blob_bottom_->Reshape(num, channels, 6, 6);
712      for (int i = 0; i < 36 * num * channels; i += 36) {
713        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
714        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
715        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
716        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
717        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
718        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
719        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
720        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
721        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
722        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
723        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
724        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
725        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
726        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
727        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
728        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
729        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
730        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
731        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
732        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
733        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
734        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
735        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
736        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
737        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
738        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
739        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
740        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
741        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
742        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
743        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
744        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
745        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
746        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
747        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
748        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
749      }
750      CuDNNPoolingLayer<Dtype> layer(layer_param);
751      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
752      EXPECT_EQ(blob_top_->num(), num);
753      EXPECT_EQ(blob_top_->channels(), channels);
754      EXPECT_EQ(blob_top_->height(), 5);
755      EXPECT_EQ(blob_top_->width(), 4);
756      if (blob_top_vec_.size() > 1) {
757        EXPECT_EQ(blob_top_mask_->num(), num);
758        EXPECT_EQ(blob_top_mask_->channels(), channels);
759        EXPECT_EQ(blob_top_mask_->height(), 5);
760        EXPECT_EQ(blob_top_mask_->width(), 4);
761      }
762      layer.Forward(blob_bottom_vec_, blob_top_vec_);
763      for (int i = 0; i < 20 * num * channels; i += 20) {
764        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
765        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
766        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
767        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
768        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
769        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
770        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
771        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
772        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
773        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
774        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
775        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
776        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
777        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
778        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
779        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
780        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
781        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
782        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
783        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
784      }
785      if (blob_top_vec_.size() > 1) {
786        for (int i = 0; i < 20 * num * channels; i += 20) {
787          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
788          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
789          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
790          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
791          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
792          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
793          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
794          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
795          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
796          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
797          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
798          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
799          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
800          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
801          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
802          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
803          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
804          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
805          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
806          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
807        }
808      }
809    }
810  };
811  TYPED_TEST_CASE(CuDNNPoolingLayerTest, TestDtypes);
812  TYPED_TEST(CuDNNPoolingLayerTest, TestSetupCuDNN) {
813    LayerParameter layer_param;
814    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
815    pooling_param->set_kernel_size(3);
816    pooling_param->set_stride(2);
817    CuDNNPoolingLayer<TypeParam> layer(layer_param);
818    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
<span onclick='openModal()' class='match'>819    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
820    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
821    EXPECT_EQ(this->blob_top_->height(), 3);
822    EXPECT_EQ(this->blob_top_->width(), 2);
823  }
824  TYPED_TEST(CuDNNPoolingLayerTest, TestSetupPaddedCuDNN) {
825    LayerParameter layer_param;
826    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
</span>827    pooling_param->set_kernel_size(3);
828    pooling_param->set_stride(2);
829    pooling_param->set_pad(1);
830    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
831    CuDNNPoolingLayer<TypeParam> layer(layer_param);
832    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
833    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
834    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
835    EXPECT_EQ(this->blob_top_->height(), 4);
836    EXPECT_EQ(this->blob_top_->width(), 3);
837  }
838  TYPED_TEST(CuDNNPoolingLayerTest, TestForwardMaxCuDNN) {
839    this->TestForwardSquare();
840    this->TestForwardRectHigh();
841    this->TestForwardRectWide();
842  }
843  TYPED_TEST(CuDNNPoolingLayerTest, TestGradientMaxCuDNN) {
844    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
845      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
846        LayerParameter layer_param;
847        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
848        pooling_param->set_kernel_h(kernel_h);
849        pooling_param->set_kernel_w(kernel_w);
850        pooling_param->set_stride(2);
851        pooling_param->set_pad(0);
852        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
853        CuDNNPoolingLayer<TypeParam> layer(layer_param);
854        GradientChecker<TypeParam> checker(1e-4, 1e-2);
855        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
856            this->blob_top_vec_);
857      }
858    }
859  }
860  TYPED_TEST(CuDNNPoolingLayerTest, TestForwardMaxPaddedCuDNN) {
861    LayerParameter layer_param;
862    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
863    pooling_param->set_kernel_size(3);
864    pooling_param->set_stride(2);
865    pooling_param->set_pad(2);
866    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
867    this->blob_bottom_->Reshape(1, 1, 3, 3);
868    this->blob_bottom_->mutable_cpu_data()[0] = 1;
869    this->blob_bottom_->mutable_cpu_data()[1] = 2;
870    this->blob_bottom_->mutable_cpu_data()[2] = 4;
871    this->blob_bottom_->mutable_cpu_data()[3] = 2;
872    this->blob_bottom_->mutable_cpu_data()[4] = 3;
873    this->blob_bottom_->mutable_cpu_data()[5] = 2;
874    this->blob_bottom_->mutable_cpu_data()[6] = 4;
875    this->blob_bottom_->mutable_cpu_data()[7] = 2;
876    this->blob_bottom_->mutable_cpu_data()[8] = 1;
877    CuDNNPoolingLayer<TypeParam> layer(layer_param);
878    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
879    EXPECT_EQ(this->blob_top_->num(), 1);
880    EXPECT_EQ(this->blob_top_->channels(), 1);
881    EXPECT_EQ(this->blob_top_->height(), 3);
882    EXPECT_EQ(this->blob_top_->width(), 3);
883    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
884    TypeParam epsilon = 1e-8;
885    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
886    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
887    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
888    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
889    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
890    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
891    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
892    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
893    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
894  }
895  TYPED_TEST(CuDNNPoolingLayerTest, TestForwardAveCuDNN) {
896    LayerParameter layer_param;
897    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
898    pooling_param->set_kernel_size(3);
899    pooling_param->set_stride(1);
900    pooling_param->set_pad(0);
901    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
902    this->blob_bottom_->Reshape(1, 1, 3, 3);
903    FillerParameter filler_param;
904    filler_param.set_value(TypeParam(2));
905    ConstantFiller<TypeParam> filler(filler_param);
906    filler.Fill(this->blob_bottom_);
907    CuDNNPoolingLayer<TypeParam> layer(layer_param);
908    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
909    EXPECT_EQ(this->blob_top_->num(), 1);
910    EXPECT_EQ(this->blob_top_->channels(), 1);
911    EXPECT_EQ(this->blob_top_->height(), 1);
912    EXPECT_EQ(this->blob_top_->width(), 1);
913    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
914    TypeParam epsilon = 1e-5;
915    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 2.0, epsilon);
916  }
917  TYPED_TEST(CuDNNPoolingLayerTest, TestGradientAveCuDNN) {
918    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
919      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
920        LayerParameter layer_param;
921        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
922        pooling_param->set_kernel_h(kernel_h);
923        pooling_param->set_kernel_w(kernel_w);
924        pooling_param->set_stride(2);
925        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
926        CuDNNPoolingLayer<TypeParam> layer(layer_param);
927        GradientChecker<TypeParam> checker(1e-2, 1e-2);
928        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
929            this->blob_top_vec_);
930      }
931    }
932  }
933  TYPED_TEST(CuDNNPoolingLayerTest, TestGradientAvePaddedCuDNN) {
934    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
935      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
936        LayerParameter layer_param;
937        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
938        pooling_param->set_kernel_h(kernel_h);
939        pooling_param->set_kernel_w(kernel_w);
940        pooling_param->set_stride(2);
941        pooling_param->set_pad(2);
942        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
943        CuDNNPoolingLayer<TypeParam> layer(layer_param);
944        GradientChecker<TypeParam> checker(1e-2, 1e-2);
945        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
946            this->blob_top_vec_);
947      }
948    }
949  }
950  #endif
951  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-compressed_tuple_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_pooling_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>57    EXPECT_EQ(tracker.instances(), 2);
58    EXPECT_EQ(tracker.copies(), 0);
59    EXPECT_LE(tracker.moves(), 1);
60    EXPECT_EQ(x1.get<0>().value(), 1);
61  }
62  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMixedTypes) {
63    InstanceTracker tracker;
64    CopyableMovableInstance i1(1);
</pre></code></div>
                <div class="column column_space"><pre><code>819    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
820    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
821    EXPECT_EQ(this->blob_top_->height(), 3);
822    EXPECT_EQ(this->blob_top_->width(), 2);
823  }
824  TYPED_TEST(CuDNNPoolingLayerTest, TestSetupPaddedCuDNN) {
825    LayerParameter layer_param;
826    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    