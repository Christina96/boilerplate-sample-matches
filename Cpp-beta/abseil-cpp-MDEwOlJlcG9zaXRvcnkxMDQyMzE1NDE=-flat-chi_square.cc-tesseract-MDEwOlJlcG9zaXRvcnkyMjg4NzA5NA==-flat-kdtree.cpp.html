
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.78386605783866%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-chi_square.cc</h3>
            <pre><code>1  #include "absl/random/internal/chi_square.h"
2  #include <cmath>
3  #include "absl/random/internal/distribution_test_util.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace random_internal {
7  namespace {
8  #if defined(__EMSCRIPTEN__)
9  inline double fma(double x, double y, double z) {
10    return (x * y) + z;
11  }
12  #endif
13  template <typename T, unsigned N>
14  inline T EvaluatePolynomial(T x, const T (&poly)[N]) {
15  #if !defined(__EMSCRIPTEN__)
16    using std::fma;
17  #endif
18    T p = poly[N - 1];
19    for (unsigned i = 2; i <= N; i++) {
20      p = fma(p, x, poly[N - i]);
21    }
22    return p;
23  }
24  static constexpr int kLargeDOF = 150;
25  double POZ(double z) {
26    static constexpr double kP1[] = {
27        0.797884560593,  -0.531923007300, 0.319152932694,
28        -0.151968751364, 0.059054035642,  -0.019198292004,
29        0.005198775019,  -0.001075204047, 0.000124818987,
30    };
31    static constexpr double kP2[] = {
32        0.999936657524,  0.000535310849,  -0.002141268741, 0.005353579108,
33        -0.009279453341, 0.011630447319,  -0.010557625006, 0.006549791214,
34        -0.002034254874, -0.000794620820, 0.001390604284,  -0.000676904986,
35        -0.000019538132, 0.000152529290,  -0.000045255659,
36    };
37    const double kZMax = 6.0;  
38    if (z == 0.0) {
39      return 0.5;
40    }
41    double x;
42    double y = 0.5 * std::fabs(z);
43    if (y >= (kZMax * 0.5)) {
44      x = 1.0;
45    } else if (y < 1.0) {
46      double w = y * y;
47      x = EvaluatePolynomial(w, kP1) * y * 2.0;
48    } else {
49      y -= 2.0;
50      x = EvaluatePolynomial(y, kP2);
51    }
52    return z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5);
53  }
54  double normal_survival(double z) {
55    static constexpr double kR[] = {
56        1.0, 0.196854, 0.115194, 0.000344, 0.019527,
57    };
58    double r = EvaluatePolynomial(z, kR);
59    r *= r;
60    return 0.5 / (r * r);
61  }
62  }  
63  double ChiSquareValue(int dof, double p) {
64    static constexpr double kChiEpsilon =
65        0.000001;  
66    static constexpr double kChiMax =
67        99999.0;  
68    const double p_value = 1.0 - p;
69    if (dof < 1 || p_value > 1.0) {
70      return 0.0;
71    }
72    if (dof > kLargeDOF) {
73      const double z = InverseNormalSurvival(p_value);
74      const double mean = 1 - 2.0 / (9 * dof);
75      const double variance = 2.0 / (9 * dof);
76      if (variance != 0) {
77        double term = z * std::sqrt(variance) + mean;
78        return dof * (term * term * term);
79      }
80    }
81    if (p_value <= 0.0) return kChiMax;
<span onclick='openModal()' class='match'>82    double min_chisq = 0.0;
83    double max_chisq = kChiMax;
84    double current = dof / std::sqrt(p_value);
85    while ((max_chisq - min_chisq) > kChiEpsilon) {
86      if (ChiSquarePValue(current, dof) < p_value) {
</span>87        max_chisq = current;
88      } else {
89        min_chisq = current;
90      }
91      current = (max_chisq + min_chisq) * 0.5;
92    }
93    return current;
94  }
95  double ChiSquarePValue(double chi_square, int dof) {
96    static constexpr double kLogSqrtPi =
97        0.5723649429247000870717135;  
98    static constexpr double kInverseSqrtPi =
99        0.5641895835477562869480795;  
100    if (dof > kLargeDOF) {
101      const double chi_square_scaled = std::pow(chi_square / dof, 1.0 / 3);
102      const double mean = 1 - 2.0 / (9 * dof);
103      const double variance = 2.0 / (9 * dof);
104      if (variance != 0) {
105        const double z = (chi_square_scaled - mean) / std::sqrt(variance);
106        if (z > 0) {
107          return normal_survival(z);
108        } else if (z < 0) {
109          return 1.0 - normal_survival(-z);
110        } else {
111          return 0.5;
112        }
113      }
114    }
115    if (chi_square <= 0.0) return 1.0;
116    if (dof < 1) return 0;
117    auto capped_exp = [](double x) { return x < -20 ? 0.0 : std::exp(x); };
118    static constexpr double kBigX = 20;
119    double a = 0.5 * chi_square;
120    const bool even = !(dof & 1);  
121    const double y = capped_exp(-a);
122    double s = even ? y : (2.0 * POZ(-std::sqrt(chi_square)));
123    if (dof <= 2) {
124      return s;
125    }
126    chi_square = 0.5 * (dof - 1.0);
127    double z = (even ? 1.0 : 0.5);
128    if (a > kBigX) {
129      double e = (even ? 0.0 : kLogSqrtPi);
130      double c = std::log(a);
131      while (z <= chi_square) {
132        e = std::log(z) + e;
133        s += capped_exp(c * z - a - e);
134        z += 1.0;
135      }
136      return s;
137    }
138    double e = (even ? 1.0 : (kInverseSqrtPi / std::sqrt(a)));
139    double c = 0.0;
140    while (z <= chi_square) {
141      e = e * (a / z);
142      c = c + e;
143      z += 1.0;
144    }
145    return c * y + s;
146  }
147  }  
148  ABSL_NAMESPACE_END
149  }  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-kdtree.cpp</h3>
            <pre><code>1  #include "kdtree.h"
2  #include <algorithm>
3  #include <cfloat> 
4  #include <cmath>
5  #include <cstdio>
6  namespace tesseract {
7  #define Magnitude(X) ((X) < 0 ? -(X) : (X))
8  #define NodeFound(N, K, D) (((N)->Key == (K)) && ((N)->Data == (D)))
9  #define MINSEARCH (-FLT_MAX)
10  #define MAXSEARCH FLT_MAX
11  static int NextLevel(KDTREE *tree, int level) {
12    do {
13      ++level;
14      if (level >= tree->KeySize) {
15        level = 0;
16      }
17    } while (tree->KeyDesc[level].NonEssential);
18    return level;
19  }
20  template <typename Key, typename Value>
21  class MinK {
22  public:
23    MinK(Key max_key, int k);
24    ~MinK();
25    struct Element {
26      Element() = default;
27      Element(const Key &k, const Value &v) : key(k), value(v) {}
28      Key key;
29      Value value;
30    };
31    bool insert(Key k, Value v);
32    const Key &max_insertable_key();
33    int elements_count() {
34      return elements_count_;
35    }
36    const Element *elements() {
37      return elements_;
38    }
39  private:
40    const Key max_key_;  
41    Element *elements_;  
42    int elements_count_; 
43    int k_;              
44    int max_index_;      
45  };
46  template <typename Key, typename Value>
47  MinK<Key, Value>::MinK(Key max_key, int k)
48      : max_key_(max_key), elements_count_(0), k_(k < 1 ? 1 : k), max_index_(0) {
49    elements_ = new Element[k_];
50  }
51  template <typename Key, typename Value>
52  MinK<Key, Value>::~MinK() {
53    delete[] elements_;
54  }
55  template <typename Key, typename Value>
56  const Key &MinK<Key, Value>::max_insertable_key() {
57    if (elements_count_ < k_) {
58      return max_key_;
59    }
60    return elements_[max_index_].key;
61  }
62  template <typename Key, typename Value>
63  bool MinK<Key, Value>::insert(Key key, Value value) {
64    if (elements_count_ < k_) {
65      elements_[elements_count_++] = Element(key, value);
66      if (key > elements_[max_index_].key) {
67        max_index_ = elements_count_ - 1;
68      }
69      return true;
70    } else if (key < elements_[max_index_].key) {
71      elements_[max_index_] = Element(key, value);
72      for (int i = 0; i < elements_count_; i++) {
73        if (elements_[i].key > elements_[max_index_].key) {
74          max_index_ = i;
75        }
76      }
77      return true;
78    }
79    return false;
80  }
81  class KDTreeSearch {
82  public:
83    KDTreeSearch(KDTREE *tree, float *query_point, int k_closest);
84    ~KDTreeSearch();
85    void Search(int *result_count, float *distances, void **results);
86  private:
87    void SearchRec(int Level, KDNODE *SubTree);
88    bool BoxIntersectsSearch(float *lower, float *upper);
89    KDTREE *tree_;
90    float *query_point_;
91    float *sb_min_; 
92    float *sb_max_; 
93    MinK<float, void *> results_;
94  };
95  KDTreeSearch::KDTreeSearch(KDTREE *tree, float *query_point, int k_closest)
96      : tree_(tree), query_point_(query_point), results_(MAXSEARCH, k_closest) {
97    sb_min_ = new float[tree->KeySize];
98    sb_max_ = new float[tree->KeySize];
99  }
100  KDTreeSearch::~KDTreeSearch() {
101    delete[] sb_min_;
102    delete[] sb_max_;
103  }
104  void KDTreeSearch::Search(int *result_count, float *distances, void **results) {
105    if (tree_->Root.Left == nullptr) {
106      *result_count = 0;
107    } else {
108      for (int i = 0; i < tree_->KeySize; i++) {
109        sb_min_[i] = tree_->KeyDesc[i].Min;
110        sb_max_[i] = tree_->KeyDesc[i].Max;
111      }
112      SearchRec(0, tree_->Root.Left);
113      int count = results_.elements_count();
114      *result_count = count;
115      for (int j = 0; j < count; j++) {
116        distances[j] = static_cast<float>(sqrt(static_cast<double>(results_.elements()[j].key)));
117        results[j] = results_.elements()[j].value;
118      }
119    }
120  }
121  KDTREE *MakeKDTree(int16_t KeySize, const PARAM_DESC KeyDesc[]) {
122    auto *KDTree = new KDTREE(KeySize);
123    for (int i = 0; i < KeySize; i++) {
124      KDTree->KeyDesc[i].NonEssential = KeyDesc[i].NonEssential;
125      KDTree->KeyDesc[i].Circular = KeyDesc[i].Circular;
126      if (KeyDesc[i].Circular) {
127        KDTree->KeyDesc[i].Min = KeyDesc[i].Min;
128        KDTree->KeyDesc[i].Max = KeyDesc[i].Max;
129        KDTree->KeyDesc[i].Range = KeyDesc[i].Max - KeyDesc[i].Min;
130        KDTree->KeyDesc[i].HalfRange = KDTree->KeyDesc[i].Range / 2;
131        KDTree->KeyDesc[i].MidRange = (KeyDesc[i].Max + KeyDesc[i].Min) / 2;
132      } else {
133        KDTree->KeyDesc[i].Min = MINSEARCH;
134        KDTree->KeyDesc[i].Max = MAXSEARCH;
135      }
136    }
137    KDTree->Root.Left = nullptr;
138    KDTree->Root.Right = nullptr;
139    return KDTree;
140  }
141  void KDStore(KDTREE *Tree, float *Key, CLUSTER *Data) {
<span onclick='openModal()' class='match'>142    auto PtrToNode = &(Tree->Root.Left);
143    auto Node = *PtrToNode;
144    auto Level = NextLevel(Tree, -1);
145    while (Node != nullptr) {
146      if (Key[Level] < Node->BranchPoint) {
</span>147        PtrToNode = &(Node->Left);
148        if (Key[Level] > Node->LeftBranch) {
149          Node->LeftBranch = Key[Level];
150        }
151      } else {
152        PtrToNode = &(Node->Right);
153        if (Key[Level] < Node->RightBranch) {
154          Node->RightBranch = Key[Level];
155        }
156      }
157      Level = NextLevel(Tree, Level);
158      Node = *PtrToNode;
159    }
160    *PtrToNode = new KDNODE(Tree, Key, Data, Level);
161  } &bsol;* KDStore */
162  void KDDelete(KDTREE *Tree, float Key[], void *Data) {
163    int Level;
164    KDNODE *Current;
165    KDNODE *Father;
166    Father = &(Tree->Root);
167    Current = Father->Left;
168    Level = NextLevel(Tree, -1);
169    while ((Current != nullptr) && (!NodeFound(Current, Key, Data))) {
170      Father = Current;
171      if (Key[Level] < Current->BranchPoint) {
172        Current = Current->Left;
173      } else {
174        Current = Current->Right;
175      }
176      Level = NextLevel(Tree, Level);
177    }
178    if (Current != nullptr) { &bsol;* if node to be deleted was found */
179      if (Current == Father->Left) {
180        Father->Left = nullptr;
181        Father->LeftBranch = Tree->KeyDesc[Level].Min;
182      } else {
183        Father->Right = nullptr;
184        Father->RightBranch = Tree->KeyDesc[Level].Max;
185      }
186      InsertNodes(Tree, Current->Left);
187      InsertNodes(Tree, Current->Right);
188      delete Current;
189    }
190  } &bsol;* KDDelete */
191  void KDNearestNeighborSearch(KDTREE *Tree, float Query[], int QuerySize, float MaxDistance,
192                               int *NumberOfResults, void **NBuffer, float DBuffer[]) {
193    KDTreeSearch search(Tree, Query, QuerySize);
194    search.Search(NumberOfResults, DBuffer, NBuffer);
195  }
196  void KDWalk(KDTREE *Tree, kdwalk_proc action, ClusteringContext *context) {
197    if (Tree->Root.Left != nullptr) {
198      Walk(Tree, action, context, Tree->Root.Left, NextLevel(Tree, -1));
199    }
200  }
201  void KDTreeSearch::SearchRec(int level, KDNODE *sub_tree) {
202    if (level >= tree_->KeySize) {
203      level = 0;
204    }
205    if (!BoxIntersectsSearch(sb_min_, sb_max_)) {
206      return;
207    }
208    results_.insert(DistanceSquared(tree_->KeySize, &tree_->KeyDesc[0], query_point_, sub_tree->Key),
209                    sub_tree->Data);
210    if (query_point_[level] < sub_tree->BranchPoint) {
211      if (sub_tree->Left != nullptr) {
212        float tmp = sb_max_[level];
213        sb_max_[level] = sub_tree->LeftBranch;
214        SearchRec(NextLevel(tree_, level), sub_tree->Left);
215        sb_max_[level] = tmp;
216      }
217      if (sub_tree->Right != nullptr) {
218        float tmp = sb_min_[level];
219        sb_min_[level] = sub_tree->RightBranch;
220        SearchRec(NextLevel(tree_, level), sub_tree->Right);
221        sb_min_[level] = tmp;
222      }
223    } else {
224      if (sub_tree->Right != nullptr) {
225        float tmp = sb_min_[level];
226        sb_min_[level] = sub_tree->RightBranch;
227        SearchRec(NextLevel(tree_, level), sub_tree->Right);
228        sb_min_[level] = tmp;
229      }
230      if (sub_tree->Left != nullptr) {
231        float tmp = sb_max_[level];
232        sb_max_[level] = sub_tree->LeftBranch;
233        SearchRec(NextLevel(tree_, level), sub_tree->Left);
234        sb_max_[level] = tmp;
235      }
236    }
237  }
238  float DistanceSquared(int k, PARAM_DESC *dim, float p1[], float p2[]) {
239    float total_distance = 0;
240    for (; k > 0; k--, p1++, p2++, dim++) {
241      if (dim->NonEssential) {
242        continue;
243      }
244      float dimension_distance = *p1 - *p2;
245      if (dim->Circular) {
246        dimension_distance = Magnitude(dimension_distance);
247        float wrap_distance = dim->Max - dim->Min - dimension_distance;
248        dimension_distance = std::min(dimension_distance, wrap_distance);
249      }
250      total_distance += dimension_distance * dimension_distance;
251    }
252    return total_distance;
253  }
254  float ComputeDistance(int k, PARAM_DESC *dim, float p1[], float p2[]) {
255    return std::sqrt(DistanceSquared(k, dim, p1, p2));
256  }
257  bool KDTreeSearch::BoxIntersectsSearch(float *lower, float *upper) {
258    float *query = query_point_;
259    double total_distance = 0.0;
260    double radius_squared =
261        static_cast<double>(results_.max_insertable_key()) * results_.max_insertable_key();
262    PARAM_DESC *dim = &tree_->KeyDesc[0];
263    for (int i = tree_->KeySize; i > 0; i--, dim++, query++, lower++, upper++) {
264      if (dim->NonEssential) {
265        continue;
266      }
267      float dimension_distance;
268      if (*query < *lower) {
269        dimension_distance = *lower - *query;
270      } else if (*query > *upper) {
271        dimension_distance = *query - *upper;
272      } else {
273        dimension_distance = 0;
274      }
275      if (dim->Circular) {
276        float wrap_distance = FLT_MAX;
277        if (*query < *lower) {
278          wrap_distance = *query + dim->Max - dim->Min - *upper;
279        } else if (*query > *upper) {
280          wrap_distance = *lower - (*query - (dim->Max - dim->Min));
281        }
282        dimension_distance = std::min(dimension_distance, wrap_distance);
283      }
284      total_distance += static_cast<double>(dimension_distance) * dimension_distance;
285      if (total_distance >= radius_squared) {
286        return false;
287      }
288    }
289    return true;
290  }
291  void Walk(KDTREE *tree, kdwalk_proc action, ClusteringContext *context, KDNODE *sub_tree, int32_t level) {
292    (*action)(context, sub_tree->Data, level);
293    if (sub_tree->Left != nullptr) {
294      Walk(tree, action, context, sub_tree->Left, NextLevel(tree, level));
295    }
296    if (sub_tree->Right != nullptr) {
297      Walk(tree, action, context, sub_tree->Right, NextLevel(tree, level));
298    }
299  }
300  void InsertNodes(KDTREE *tree, KDNODE *nodes) {
301    if (nodes == nullptr) {
302      return;
303    }
304    KDStore(tree, nodes->Key, nodes->Data);
305    InsertNodes(tree, nodes->Left);
306    InsertNodes(tree, nodes->Right);
307  }
308  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-chi_square.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-kdtree.cpp</div>
                </div>
                <div class="column column_space"><pre><code>82    double min_chisq = 0.0;
83    double max_chisq = kChiMax;
84    double current = dof / std::sqrt(p_value);
85    while ((max_chisq - min_chisq) > kChiEpsilon) {
86      if (ChiSquarePValue(current, dof) < p_value) {
</pre></code></div>
                <div class="column column_space"><pre><code>142    auto PtrToNode = &(Tree->Root.Left);
143    auto Node = *PtrToNode;
144    auto Level = NextLevel(Tree, -1);
145    while (Node != nullptr) {
146      if (Key[Level] < Node->BranchPoint) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    