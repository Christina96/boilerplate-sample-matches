
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.888499708114419%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-pooling_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cfloat>
3  #include <vector>
4  #include "caffe/common.hpp"
5  #include "caffe/layer.hpp"
6  #include "caffe/syncedmem.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #include "caffe/layers/pooling_layer.hpp"
9  namespace caffe {
10  using std::min;
11  using std::max;
12  template <typename Dtype>
13  void PoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
14        const vector<Blob<Dtype>*>& top) {
15    PoolingParameter pool_param = this->layer_param_.pooling_param();
16    channel_axis_ = bottom[0]->CanonicalAxisIndex(pool_param.axis());
17    channels_ = bottom[0]->shape(channel_axis_);
18    const int first_spatial_axis = channel_axis_ + 1;
19    const int num_axes = bottom[0]->num_axes();
20    num_spatial_axes_ = num_axes - first_spatial_axis;
21    CHECK_GE(num_spatial_axes_, 1);
22    if (num_spatial_axes_ == 2) {
23        if (pool_param.global_pooling()) {
24          CHECK(!(pool_param.has_kernel_size() ||
25            pool_param.has_kernel_h() || pool_param.has_kernel_w()))
26            << "With Global_pooling: true Filter size cannot specified";
27        } else {
28          CHECK(!pool_param.has_kernel_size() !=
29            !(pool_param.has_kernel_h() && pool_param.has_kernel_w()))
30            << "Filter size is kernel_size OR kernel_h and kernel_w; not both";
31          CHECK(pool_param.has_kernel_size() ||
32            (pool_param.has_kernel_h() && pool_param.has_kernel_w()))
33            << "For non-square filters both kernel_h and kernel_w are required.";
34        }
35        CHECK((!pool_param.has_pad() && pool_param.has_pad_h()
36            && pool_param.has_pad_w())
37            || (!pool_param.has_pad_h() && !pool_param.has_pad_w()))
38            << "pad is pad OR pad_h and pad_w are required.";
39        CHECK((!pool_param.has_stride() && pool_param.has_stride_h()
40            && pool_param.has_stride_w())
41            || (!pool_param.has_stride_h() && !pool_param.has_stride_w()))
42            << "Stride is stride OR stride_h and stride_w are required.";
43        global_pooling_ = pool_param.global_pooling();
44        if (global_pooling_) {
45          kernel_h_ = bottom[0]->height();
46          kernel_w_ = bottom[0]->width();
47        } else {
48          if (pool_param.has_kernel_size()) {
49            kernel_h_ = kernel_w_ = pool_param.kernel_size();
50          } else {
51            kernel_h_ = pool_param.kernel_h();
52            kernel_w_ = pool_param.kernel_w();
53          }
54        }
55        CHECK_GT(kernel_h_, 0) << "Filter dimensions cannot be zero.";
56        CHECK_GT(kernel_w_, 0) << "Filter dimensions cannot be zero.";
57        if (!pool_param.has_pad_h()) {
58          pad_h_ = pad_w_ = pool_param.pad();
59        } else {
60          pad_h_ = pool_param.pad_h();
61          pad_w_ = pool_param.pad_w();
62        }
63        if (!pool_param.has_stride_h()) {
64          stride_h_ = stride_w_ = pool_param.stride();
65        } else {
66          stride_h_ = pool_param.stride_h();
67          stride_w_ = pool_param.stride_w();
68        }
69        if (global_pooling_) {
70          CHECK(pad_h_ == 0 && pad_w_ == 0 && stride_h_ == 1 && stride_w_ == 1)
71            << "With Global_pooling: true; only pad = 0 and stride = 1";
72        }
73        if (pad_h_ != 0 || pad_w_ != 0) {
74          CHECK(this->layer_param_.pooling_param().pool()
75              == PoolingParameter_PoolMethod_AVE
76              || this->layer_param_.pooling_param().pool()
77              == PoolingParameter_PoolMethod_MAX)
78              << "Padding implemented only for average and max pooling.";
79          CHECK_LT(pad_h_, kernel_h_);
80          CHECK_LT(pad_w_, kernel_w_);
81        }
82      } else if (num_spatial_axes_ == 3) {
83        vector<int> bottom_dim_blob_shape(1, num_spatial_axes_ + 1);
84        input_shape_.Reshape(bottom_dim_blob_shape);
85        int* input_shape_data = input_shape_.mutable_cpu_data();
86        for (int i = 0; i < num_spatial_axes_ + 1; ++i) {
87          input_shape_data[i] = bottom[0]->shape(channel_axis_ + i);
88        }
89        vector<int> spatial_dim_blob_shape(1, num_spatial_axes_);
90        global_pooling_ = pool_param.global_pooling();
91        kernel_shape_.Reshape(spatial_dim_blob_shape);
92        int* kernel_shape_data = kernel_shape_.mutable_cpu_data();
93        if (global_pooling_) {
94          CHECK_GE(0, pool_param.kernel_size_3d_size())
95              << "With Global_pooling: true Filter size cannot specified.";
96          CHECK(!pool_param.has_kernel_h() || !pool_param.has_kernel_w())
97              << "With Global_pooling: true Filter size cannot specified.";
98          for (int i = 0; i < num_spatial_axes_ + 1; ++i) {
99            kernel_shape_data[i] = bottom[0]->shape(channel_axis_ + i);
100          }
101        } else {
102          if (pool_param.has_kernel_h() || pool_param.has_kernel_w()) {
103              CHECK_EQ(num_spatial_axes_, 2)
104                << "kernel_h & kernel_w can only be used for 2D pooling.";
105              CHECK_EQ(0, pool_param.kernel_size_3d_size())
106                << "Either kernel_size or kernel_h/w should be specified, not both.";
107              kernel_shape_data[0] = pool_param.kernel_h();
108              kernel_shape_data[1] = pool_param.kernel_w();
109          } else {
110              const int num_kernel_dims = pool_param.kernel_size_3d_size();
111              CHECK(num_kernel_dims == 1 || num_kernel_dims == num_spatial_axes_)
112                << "kernel_size must be specified once, or once per spatial dimension"
113                << " (kernel_size specified " << num_kernel_dims << " times "
114                << num_spatial_axes_ << " spatial dims).";
115              for (int i = 0; i < num_spatial_axes_; ++i) {
116                  kernel_shape_data[i] = pool_param.kernel_size_3d((num_kernel_dims == 1) ? 0 : i);
117              }
118          }
119        }
120        for (int i = 0; i < num_spatial_axes_; ++i) {
121            CHECK_GT(kernel_shape_data[i], 0) << "Filter dimensions must be nonzero.";
122        }
123        pad_.Reshape(spatial_dim_blob_shape);
124        int* pad_data = pad_.mutable_cpu_data();
125        int pad_sum = 0;
126        if (pool_param.has_pad_h() || pool_param.has_pad_w()) {
127            CHECK_EQ(num_spatial_axes_, 2)
128              << "pad_h & pad_w can only be used for 2D convolution.";
129            CHECK_EQ(0, pool_param.pad_3d_size())
130              << "Either pad or pad_h/w should be specified, not both.";
131            pad_data[0] = pool_param.pad_h();
132            pad_data[1] = pool_param.pad_w();
133        } else {
134          const int num_pad_dims = pool_param.pad_3d_size();
135          CHECK(num_pad_dims == 0 || num_pad_dims == 1 ||
136                num_pad_dims == num_spatial_axes_)
137              << "pad must be specified once, or once per spatial dimension "
138              << "(pad specified " << num_pad_dims << " times "
139              << num_spatial_axes_ << " spatial dims).";
140          const int kDefaultPad = 0;
141          for (int i = 0; i < num_spatial_axes_; ++i) {
142            pad_data[i] = (num_pad_dims == 0) ? kDefaultPad :
143                pool_param.pad_3d((num_pad_dims == 1) ? 0 : i);
144            if (global_pooling_) {
145                CHECK_EQ(pad_data[i], 0)
146                  << "With Global_pooling: true; pool = 0";
147              }
148            CHECK_LT(pad_data[i], kernel_shape_data[i]);
149            pad_sum += pad_data[i];
150          }
151        }
152        if (pad_sum != 0) {
153           CHECK(this->layer_param_.pooling_param().pool() ==
154            PoolingParameter_PoolMethod_AVE
155            || this->layer_param_.pooling_param().pool() ==
156            PoolingParameter_PoolMethod_MAX)
157              << "Padding implemented only for average and max pooling.";
158        }
159        stride_.Reshape(spatial_dim_blob_shape);
160        int* stride_data = stride_.mutable_cpu_data();
161        if (pool_param.has_stride_h() || pool_param.has_stride_w()) {
162          CHECK_EQ(num_spatial_axes_, 2)
163              << "stride_h & stride_w can only be used for 2D convolution.";
164          CHECK_EQ(0, pool_param.stride_3d_size())
165              << "Either stride or stride_h/w should be specified, not both.";
166          stride_data[0] = pool_param.stride_h();
167          stride_data[1] = pool_param.stride_w();
168        } else {
169          const int num_stride_dims = pool_param.stride_3d_size();
170          CHECK(num_stride_dims == 0 || num_stride_dims == 1 ||
171                num_stride_dims == num_spatial_axes_)
172              << "stride must be specified once, or once per spatial dimension "
173              << "(stride specified " << num_stride_dims << " times "
174              << num_spatial_axes_ << " spatial dims).";
175          const int kDefaultStride = 1;
176          for (int i = 0; i < num_spatial_axes_; ++i) {
177            stride_data[i] = (num_stride_dims == 0) ? kDefaultStride :
178                pool_param.stride_3d((num_stride_dims == 1) ? 0 : i);
179            CHECK_GT(stride_data[i], 0) << "Stride dimensions must be nonzero.";
180            if (global_pooling_) {
181              CHECK_EQ(stride_data[i], 1)
182                << "With Global_pooling: true; stride = 1";
183            }
184          }
185        }
186      } else {
187        NOT_IMPLEMENTED;
188      }
189  }
190  template <typename Dtype>
191  void PoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
192        const vector<Blob<Dtype>*>& top) {
193    PoolingParameter pool_param = this->layer_param_.pooling_param();
194    channel_axis_ = bottom[0]->CanonicalAxisIndex(pool_param.axis());
195    num_ = bottom[0]->count(0, channel_axis_);
196    const int first_spatial_axis = channel_axis_ + 1;
197    const int num_axes = bottom[0]->num_axes();
198    num_spatial_axes_ = num_axes - first_spatial_axis;
199    CHECK_GE(num_spatial_axes_, 1);
200    if (num_spatial_axes_ == 2) {
201        CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
202            << "corresponding to (num, channels, height, width).";
203        channels_ = bottom[0]->channels();
204        height_ = bottom[0]->height();
205        width_ = bottom[0]->width();
206        if (global_pooling_) {
207          kernel_h_ = bottom[0]->height();
208          kernel_w_ = bottom[0]->width();
209        }
210        pooled_height_ = static_cast<int>(ceil(static_cast<float>(
211            height_ + 2 * pad_h_ - kernel_h_) / stride_h_)) + 1;
212        pooled_width_ = static_cast<int>(ceil(static_cast<float>(
213            width_ + 2 * pad_w_ - kernel_w_) / stride_w_)) + 1;
214        if (pad_h_ || pad_w_ || kernel_h_ == 1 || kernel_w_ == 1) {
215          if ((pooled_height_ - 1) * stride_h_ >= height_ + pad_h_) {
216            --pooled_height_;
217          }
218          if ((pooled_width_ - 1) * stride_w_ >= width_ + pad_w_) {
219            --pooled_width_;
220          }
221          CHECK_LT((pooled_height_ - 1) * stride_h_, height_ + pad_h_);
222          CHECK_LT((pooled_width_ - 1) * stride_w_, width_ + pad_w_);
223        }
224        top[0]->Reshape(bottom[0]->num(), channels_, pooled_height_,
225            pooled_width_);
226        if (top.size() > 1) {
227          top[1]->ReshapeLike(*top[0]);
228        }
229        if (this->layer_param_.pooling_param().pool() ==
230            PoolingParameter_PoolMethod_MAX && top.size() == 1) {
231          max_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_,
232              pooled_width_);
233        }
234        if (this->layer_param_.pooling_param().pool() ==
235            PoolingParameter_PoolMethod_STOCHASTIC) {
236          rand_idx_.Reshape(bottom[0]->num(), channels_, pooled_height_, pooled_width_);
237        }
238    } else if (num_spatial_axes_ == 3) {
239        int* kernel_shape_data = kernel_shape_.mutable_cpu_data();
240        const int* input_shape_data = this->input_shape_.cpu_data();
241        if (global_pooling_) {
242          for (int i = 0; i < num_spatial_axes_; ++i) {
243            kernel_shape_data[i] = input_shape_data[i+1];
244          }
245        }
246        const int* pad_data = this->pad_.cpu_data();
247        const int* stride_data = this->stride_.cpu_data();
248        vector<int> spatial_dim_blob_shape(1, num_spatial_axes_);
249        output_shape_.Reshape(spatial_dim_blob_shape);
250        int* output_shape_data = output_shape_.mutable_cpu_data();
251        int pad_sum = 0;
252        for (int i = 0; i < num_spatial_axes_; ++i) {
253          int oc = static_cast<int>(ceil(static_cast<float>(
254                input_shape_data[i+1] + 2 * pad_data[i]
255                - kernel_shape_data[i]) / stride_data[i])) + 1;
256          pad_sum += pad_data[i];
257          output_shape_data[i] = oc;
258        }
259        if (pad_sum) {
260          for (int i = 0; i < num_spatial_axes_; ++i) {
261              if ((output_shape_data[i] - 1) * stride_data[i] >=
262                input_shape_data[i+1] + pad_data[i])
263                  --output_shape_data[i];
264              CHECK_LT((output_shape_data[i] - 1) * stride_data[i],
265                input_shape_data[i+1] + pad_data[i]);
266          }
267        }
268        vector<int> top_shape = bottom[0]->shape();
269        top_shape.resize(first_spatial_axis);
270        for (int i = 0; i < num_spatial_axes_; ++i) {
271            top_shape.push_back(output_shape_data[i]);
272        }
273        top[0]->Reshape(top_shape);
274        if (top.size() > 1) {
275          top[1]->ReshapeLike(*top[0]);
276        }
277        if (this->layer_param_.pooling_param().pool() ==
278            PoolingParameter_PoolMethod_MAX && top.size() == 1) {
279          max_idx_.Reshape(top_shape);
280        }
281        if (this->layer_param_.pooling_param().pool() ==
282            PoolingParameter_PoolMethod_STOCHASTIC) {
283          rand_idx_.Reshape(top_shape);
284        }
285    } else {
286      NOT_IMPLEMENTED;
287    }
288  }
289  template <typename Dtype>
290  void PoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
291        const vector<Blob<Dtype>*>& top) {
292    const Dtype* bottom_data = bottom[0]->cpu_data();
293    Dtype* top_data = top[0]->mutable_cpu_data();
294    const int top_count = top[0]->count();
295    const bool use_top_mask = top.size() > 1;
296    if (num_spatial_axes_ == 2) {
297        typename PoolingCodeGeneratorForward<Dtype>::Callback_t* generator_func =
298                 Forward_code_generator.Get_callback(this, top[0], use_top_mask);
299        void* mask = NULL;
300        if (this->layer_param_.pooling_param().pool() ==
301            PoolingParameter_PoolMethod_MAX ) {
302          mask = (use_top_mask) ? static_cast<void*>(top[1]->mutable_cpu_data()) :
303                                  static_cast<void*>(max_idx_.mutable_cpu_data());
304        }
305        const int batch_size = bottom[0]->num();
306        const int num_channels = bottom[0]->channels();
307  #ifdef _OPENMP
308    #if defined(_MSC_EXTENSIONS)
309      #pragma omp parallel for
310    #else
311      #pragma omp parallel for collapse(2)
312    #endif
313  #endif
314        for (int image = 0; image < batch_size; ++image)
315          for (int channel = 0; channel < num_channels; ++channel)
316            generator_func(bottom_data,
317                           top_data,
318                           top_count,
319                           image,
320                           image+1,
321                           mask,
322                           channel,
323                           channel+1,
324                           this,
325                           use_top_mask);
326    } else if (num_spatial_axes_ == 3) {
327        vector<int> offset(2, 0);
328        offset[1] = 1;
329        const int* kernel_shape = kernel_shape_.cpu_data();
330        const int* pad_data = this->pad_.cpu_data();
331        const int* stride_data = this->stride_.cpu_data();
332        const int* input_shape_data = this->input_shape_.cpu_data();
333        const int* output_shape_data = this->output_shape_.cpu_data();
334        long bottom_offset = bottom[0]->offset(offset);
335        long top_offset = top[0]->offset(offset);
336        switch (this->layer_param_.pooling_param().pool()) {
337        case PoolingParameter_PoolMethod_MAX:
338          if (use_top_mask) {
339            caffe_set(top_count, Dtype(-1), top[1]->mutable_cpu_data());
340          } else {
341            caffe_set(top_count, -1, max_idx_.mutable_cpu_data());
342          }
343          caffe_set(top_count, Dtype(-FLT_MAX), top_data);
344  #ifdef _OPENMP
345    #if defined(_MSC_EXTENSIONS)
346      #pragma omp parallel for
347    #else
348      #pragma omp parallel for collapse(2)
349    #endif
350  #endif
351          for (int n = 0; n < num_; ++n) {
352            for (int c = 0; c < channels_; ++c) {
<span onclick='openModal()' class='match'>353              long nc = n * channels_ + c;
354              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
355              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
356              Dtype *top_mask = NULL;
</span>357              int *mask = NULL;
358              if (use_top_mask) {
359                top_mask = top[1]->mutable_cpu_data() + nc * top_offset;
360              } else {
361                mask = max_idx_.mutable_cpu_data() + nc * top_offset;
362              }
363              for (int pz = 0; pz < output_shape_data[0]; ++pz) {
364                for (int ph = 0; ph < output_shape_data[1]; ++ph) {
365                  for (int pw = 0; pw < output_shape_data[2]; ++pw) {
366                      int zstart = pz * stride_data[0] - pad_data[0];
367                      int hstart = ph * stride_data[1] - pad_data[1];
368                      int wstart = pw * stride_data[2] - pad_data[2];
369                      int zend = min(zstart + kernel_shape[0], input_shape_data[1]);
370                      int hend = min(hstart + kernel_shape[1], input_shape_data[2]);
371                      int wend = min(wstart + kernel_shape[2], input_shape_data[3]);
372                      hstart = max(hstart, 0);
373                      wstart = max(wstart, 0);
374                      zstart = max(zstart, 0);
375                      const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
376                      for (int z = zstart; z < zend; ++z) {
377                        for (int h = hstart; h < hend; ++h) {
378                          for (int w = wstart; w < wend; ++w) {
379                            const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
380                            if (bottom_data2[index] > top_data2[pool_index]) {
381                              top_data2[pool_index] = bottom_data2[index];
382                              if (use_top_mask) {
383                                top_mask[pool_index] = static_cast<Dtype>(index);
384                              } else {
385                                mask[pool_index] = index;
386                              }
387                            }
388                          }
389                        }
390                      }
391                  }
392                }
393              }
394            }
395          }
396          break;
397        case PoolingParameter_PoolMethod_AVE:
398          caffe_set(top_count, Dtype(0), top_data);
399  #ifdef _OPENMP
400    #if defined(_MSC_EXTENSIONS)
401      #pragma omp parallel for
402    #else
403      #pragma omp parallel for collapse(2)
404    #endif
405  #endif
406          for (int n = 0; n < num_; ++n) {
407            for (int c = 0; c < channels_; ++c) {
408              long nc = n * channels_ + c;
409              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
410              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
411              for (int pz = 0; pz < output_shape_data[0]; ++pz) {
412                for (int ph = 0; ph < output_shape_data[1]; ++ph) {
413                  for (int pw = 0; pw < output_shape_data[2]; ++pw) {
414                    int zstart = pz * stride_data[0] - pad_data[0];
415                    int hstart = ph * stride_data[1] - pad_data[1];
416                    int wstart = pw * stride_data[2] - pad_data[2];
417                    int zend = min(zstart + kernel_shape[0],
418                             input_shape_data[1] + pad_data[0]);
419                    int hend = min(hstart + kernel_shape[1],
420                              input_shape_data[2] + pad_data[1]);
421                    int wend = min(wstart + kernel_shape[2],
422                            input_shape_data[3] + pad_data[2]);
423                    int pool_size = (hend - hstart) *
424                                    (wend - wstart) *
425                                    (zend - zstart);
426                    hstart = max(hstart, 0);
427                    wstart = max(wstart, 0);
428                    zstart = max(zstart, 0);
429                    zend = min(zend, input_shape_data[1]);
430                    hend = min(hend, input_shape_data[2]);
431                    wend = min(wend, input_shape_data[3]);
432                    const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
433                    for (int z = zstart; z < zend; ++z) {
434                      for (int h = hstart; h < hend; ++h) {
435                        for (int w = wstart; w < wend; ++w) {
436                          const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
437                          top_data2[pool_index] += bottom_data2[index];
438                        }
439                      }
440                    }
441                    top_data2[pool_index] /= pool_size;
442                  }
443                }
444              }
445            }
446          }
447          break;
448        case PoolingParameter_PoolMethod_STOCHASTIC:
449          NOT_IMPLEMENTED;
450          break;
451        default:
452          LOG(FATAL) << "Unknown pooling method.";
453        }
454      } else {
455        NOT_IMPLEMENTED;
456      }
457  }
458  template <typename Dtype>
459  void PoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
460        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
461    if (!propagate_down[0]) {
462      return;
463    }
464    const Dtype* top_diff = top[0]->cpu_diff();
465    Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
466    caffe_set(bottom[0]->count(), Dtype(0), bottom_diff);
467    const bool use_top_mask = top.size() > 1;
468    if (num_spatial_axes_ == 2) {
469        typename PoolingCodeGeneratorBackward<Dtype>::Callback_t* generator_func =
470                            Backward_code_generator.Get_callback(this, top[0]);
471        void* mask = NULL;
472        if (this->layer_param_.pooling_param().pool() ==
473            PoolingParameter_PoolMethod_MAX ) {
474          mask = (use_top_mask) ? static_cast<void*>(top[1]->mutable_cpu_data()) :
475                                  static_cast<void*>(max_idx_.mutable_cpu_data());
476        }
477        const int batch_size = bottom[0]->num();
478        const int num_channels = bottom[0]->channels();
479  #ifdef _OPENMP
480    #if defined(_MSC_EXTENSIONS)
481      #pragma omp parallel for
482    #else
483      #pragma omp parallel for collapse(2)
484    #endif
485  #endif
486        for (int image = 0; image < batch_size; ++image)
487          for (int channel = 0; channel < num_channels; ++channel)
488            generator_func(top_diff,
489                           bottom_diff,
490                           image,
491                           image+1,
492                           channel,
493                           channel+1,
494                           use_top_mask,
495                           mask,
496                           this);
497        } else if (num_spatial_axes_ == 3) {
498          const int* kernel_shape = this->kernel_shape_.cpu_data();
499          const int* pad_data = this->pad_.cpu_data();
500          const int* stride_data = this->stride_.cpu_data();
501          const int* input_shape_data = this->input_shape_.cpu_data();
502          const int* output_shape_data = this->output_shape_.cpu_data();
503          int top_num = top[0]->count(0, channel_axis_);
504          vector<int> offset(2, 0);
505          offset[1] = 1;
506          long bottom_offset = bottom[0]->offset(offset);
507          long top_offset = top[0]->offset(offset);
508          switch (this->layer_param_.pooling_param().pool()) {
509          case PoolingParameter_PoolMethod_MAX:
510  #ifdef _OPENMP
511    #if defined(_MSC_EXTENSIONS)
512      #pragma omp parallel for
513    #else
514      #pragma omp parallel for collapse(2)
515    #endif
516  #endif
517            for (int n = 0; n < top_num; ++n) {
518              for (int c = 0; c < channels_; ++c) {
519                long nc = n * channels_ + c;
520                Dtype *bottom_diff2 = bottom[0]->mutable_cpu_diff() + nc * bottom_offset;
521                const Dtype *top_diff2 = top[0]->cpu_diff() + nc * top_offset;
522                const Dtype *top_mask = NULL;
523                const int *mask = NULL;
524                if (use_top_mask) {
525                  top_mask = top[1]->cpu_data() + nc * top_offset;
526                } else {
527                  mask = max_idx_.cpu_data() + nc * top_offset;
528                }
529                for (int pz = 0; pz < output_shape_data[0]; ++pz) {
530                  for (int ph = 0; ph < output_shape_data[1]; ++ph) {
531                    for (int pw = 0; pw < output_shape_data[2]; ++pw) {
532                      const int index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
533                      const int bottom_index = use_top_mask ? top_mask[index] : mask[index];
534                      bottom_diff2[bottom_index] += top_diff2[index];
535                    }
536                  }
537                }
538              }
539            }
540            break;
541          case PoolingParameter_PoolMethod_AVE:
542  #ifdef _OPENMP
543    #if defined(_MSC_EXTENSIONS)
544      #pragma omp parallel for
545    #else
546      #pragma omp parallel for collapse(2)
547    #endif
548  #endif
549            for (int n = 0; n < top_num; ++n) {
550              for (int c = 0; c < channels_; ++c) {
551                long nc = n * channels_ + c;
552                Dtype *bottom_diff2 = bottom[0]->mutable_cpu_diff() + nc * bottom_offset;
553                const Dtype *top_diff2 = top[0]->cpu_diff() + nc * top_offset;
554                for (int pz = 0; pz < output_shape_data[0]; ++pz) {
555                  for (int ph = 0; ph < output_shape_data[1]; ++ph) {
556                    for (int pw = 0; pw < output_shape_data[2]; ++pw) {
557                      int zstart = pz * stride_data[0] - pad_data[0];
558                      int hstart = ph * stride_data[1] - pad_data[1];
559                      int wstart = pw * stride_data[2] - pad_data[2];
560                      int zend = min(zstart + kernel_shape[0], input_shape_data[1] + pad_data[0]);
561                      int hend = min(hstart + kernel_shape[1], input_shape_data[2] + pad_data[1]);
562                      int wend = min(wstart + kernel_shape[2], input_shape_data[3] + pad_data[2]);
563                      int pool_size = (hend - hstart) * (wend - wstart) * (zend - zstart);
564                      hstart = max(hstart, 0);
565                      wstart = max(wstart, 0);
566                      zstart = max(zstart, 0);
567                      zend = min(zend, input_shape_data[1]);
568                      hend = min(hend, input_shape_data[2]);
569                      wend = min(wend, input_shape_data[3]);
570                      const int pool_index = (pz * output_shape_data[1] + ph) * output_shape_data[2] + pw;
571                      for (int z = zstart; z < zend; ++z) {
572                        for (int h = hstart; h < hend; ++h) {
573                          for (int w = wstart; w < wend; ++w) {
574                            const int index = (z * input_shape_data[2] + h) * input_shape_data[3] + w;
575                            bottom_diff2[index] += top_diff2[pool_index] / pool_size;
576                          }
577                        }
578                      }
579                    }
580                  }
581                }
582              }
583            }
584            break;
585          case PoolingParameter_PoolMethod_STOCHASTIC:
586            NOT_IMPLEMENTED;
587            break;
588          default:
589            LOG(FATAL) << "Unknown pooling method.";
590        }
591      } else {
592        NOT_IMPLEMENTED;
593      }
594  }
595  #ifdef CPU_ONLY
596  STUB_GPU(PoolingLayer);
597  #endif
598  INSTANTIATE_CLASS(PoolingLayer);
599  }  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppCommands.cpp</h3>
            <pre><code>1  #include <memory>
2  #include <regex>
3  #include <shlwapi.h>
4  #include "Notepad_plus_Window.h"
5  #include "EncodingMapper.h"
6  #include "ShortcutMapper.h"
7  #include "TaskListDlg.h"
8  #include "clipboardFormats.h"
9  #include "VerticalFileSwitcher.h"
10  #include "documentMap.h"
11  #include "functionListPanel.h"
12  #include "ProjectPanel.h"
13  #include "fileBrowser.h"
14  #include "clipboardHistoryPanel.h"
15  #include "ansiCharPanel.h"
16  #include "Sorters.h"
17  #include "verifySignedfile.h"
18  #include "md5.h"
19  #include "sha-256.h"
20  using namespace std;
21  std::mutex command_mutex;
22  void Notepad_plus::macroPlayback(Macro macro)
23  {
24  	_playingBackMacro = true;
25  	_pEditView->execute(SCI_BEGINUNDOACTION);
26  	for (Macro::iterator step = macro.begin(); step != macro.end(); ++step)
27  	{
28  		if (step->isScintillaMacro())
29  			step->PlayBack(_pPublicInterface, _pEditView);
30  		else
31  			_findReplaceDlg.execSavedCommand(step->_message, step->_lParameter, string2wstring(step->_sParameter, CP_UTF8));
32  	}
33  	_pEditView->execute(SCI_ENDUNDOACTION);
34  	_playingBackMacro = false;
35  }
36  void Notepad_plus::command(int id)
37  {
38  	switch (id)
39  	{
40  		case IDM_FILE_NEW:
41  		{
42  			fileNew();
43  		}
44  		break;
45  		case IDM_EDIT_INSERT_DATETIME_SHORT:
46  		case IDM_EDIT_INSERT_DATETIME_LONG:
47  		{
48  			SYSTEMTIME currentTime = {};
49  			::GetLocalTime(&currentTime);
50  			wchar_t dateStr[128] = { '\0' };
51  			wchar_t timeStr[128] = { '\0' };
52  			int dateFlag = (id == IDM_EDIT_INSERT_DATETIME_SHORT) ? DATE_SHORTDATE : DATE_LONGDATE;
53  			GetDateFormatEx(LOCALE_NAME_USER_DEFAULT, dateFlag, &currentTime, NULL, dateStr, sizeof(dateStr) / sizeof(dateStr[0]), NULL);
54  			GetTimeFormatEx(LOCALE_NAME_USER_DEFAULT, TIME_NOSECONDS, &currentTime, NULL, timeStr, sizeof(timeStr) / sizeof(timeStr[0]));
55  			generic_string dateTimeStr;
56  			if (NppParameters::getInstance().getNppGUI()._dateTimeReverseDefaultOrder)
57  			{
58  				dateTimeStr = dateStr;
59  				dateTimeStr += TEXT(" ");
60  				dateTimeStr += timeStr;
61  			}
62  			else
63  			{
64  				dateTimeStr = timeStr;
65  				dateTimeStr += TEXT(" ");
66  				dateTimeStr += dateStr;
67  			}
68  			_pEditView->execute(SCI_BEGINUNDOACTION);
69  			_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
70  			_pEditView->addGenericText(dateTimeStr.c_str());
71  			_pEditView->execute(SCI_ENDUNDOACTION);
72  		}
73  		break;
74  		case IDM_EDIT_INSERT_DATETIME_CUSTOMIZED:
75  		{
76  			SYSTEMTIME currentTime = {};
77  			::GetLocalTime(&currentTime);
78  			NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
79  			generic_string dateTimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, currentTime);
80  			_pEditView->execute(SCI_BEGINUNDOACTION);
81  			_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
82  			_pEditView->addGenericText(dateTimeStr.c_str());
83  			_pEditView->execute(SCI_ENDUNDOACTION);
84  		}
85  		break;
86  		case IDM_FILE_OPEN:
87  		{
88  			fileOpen();
89  		}
90  		break;
91  		case IDM_FILE_OPEN_FOLDER:
92  		{
93  			Command cmd(TEXT("explorer /select,\"$(FULL_CURRENT_PATH)\""));
94  			cmd.run(_pPublicInterface->getHSelf());
95  		}
96  		break;
97  		case IDM_FILE_OPEN_CMD:
98  		{
99  			Command cmd(NppParameters::getInstance().getNppGUI()._commandLineInterpreter.c_str());
100  			cmd.run(_pPublicInterface->getHSelf(), TEXT("$(CURRENT_DIRECTORY)"));
101  		}
102  		break;
103  		case IDM_FILE_CONTAININGFOLDERASWORKSPACE:
104  		{
105  			TCHAR currentFile[CURRENTWORD_MAXLENGTH] = { '\0' };
106  			TCHAR currentDir[CURRENTWORD_MAXLENGTH] = { '\0' };
107  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_GETFULLCURRENTPATH, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(currentFile));
108  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_GETCURRENTDIRECTORY, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(currentDir));
109  			if (!_pFileBrowser)
110  			{
111  				command(IDM_VIEW_FILEBROWSER);
112  			}
113  			vector<generic_string> folders;
114  			folders.push_back(currentDir);
115  			launchFileBrowser(folders, currentFile);
116  		}
117  		break;
118  		case IDM_FILE_OPEN_DEFAULT_VIEWER:
119  		{
120              BufferID buf = _pEditView->getCurrentBufferID();
121  			HINSTANCE res = ::ShellExecute(NULL, TEXT("open"), buf->getFullPathName(), NULL, NULL, SW_SHOW);
122  			int retResult = static_cast<int>(reinterpret_cast<intptr_t>(res));
123  			if (retResult <= 32)
124  			{
125  				generic_string errorMsg;
126  				errorMsg += GetLastErrorAsString(retResult);
127  				errorMsg += TEXT("An attempt was made to execute the below command.");
128  				errorMsg += TEXT("\n----------------------------------------------------------");
129  				errorMsg += TEXT("\nCommand: ");
130  				errorMsg += buf->getFullPathName();
131  				errorMsg += TEXT("\nError Code: ");
132  				errorMsg += intToString(retResult);
133  				errorMsg += TEXT("\n----------------------------------------------------------");
134  				::MessageBox(_pPublicInterface->getHSelf(), errorMsg.c_str(), TEXT("ShellExecute - ERROR"), MB_ICONINFORMATION | MB_APPLMODAL);
135  			}
136  		}
137  		break;
138  		case IDM_FILE_OPENFOLDERASWORSPACE:
139  		{
140  			NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
141  			generic_string openWorkspaceStr = pNativeSpeaker->getAttrNameStr(TEXT("Select a folder to add in Folder as Workspace panel"),
142  				FOLDERASWORKSPACE_NODE, "SelectFolderFromBrowserString");
143  			generic_string folderPath = folderBrowser(_pPublicInterface->getHSelf(), openWorkspaceStr);
144  			if (!folderPath.empty())
145  			{
146  				if (_pFileBrowser == nullptr) 
147  				{
148  					vector<generic_string> dummy;
149  					generic_string emptyStr;
150  					launchFileBrowser(dummy, emptyStr);
151  					if (_pFileBrowser != nullptr)
152  					{
153  						checkMenuItem(IDM_VIEW_FILEBROWSER, true);
154  						_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
155  						_pFileBrowser->setClosed(false);
156  					}
157  					else 
158  						return;
159  				}
160  				else
161  				{
162  					if (_pFileBrowser->isClosed())
163  					{
164  						_pFileBrowser->display();
165  						checkMenuItem(IDM_VIEW_FILEBROWSER, true);
166  						_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
167  						_pFileBrowser->setClosed(false);
168  					}
169  				}
170  				_pFileBrowser->addRootFolder(folderPath);
171  			}
172  		}
173  		break;
174  		case IDM_FILE_RELOAD:
175  			fileReload();
176  			break;
177  		case IDM_DOCLIST_FILESCLOSE:
178  		case IDM_DOCLIST_FILESCLOSEOTHERS:
179  			if (_pDocumentListPanel)
180  			{
181  				vector<BufferViewInfo> bufs2Close = _pDocumentListPanel->getSelectedFiles(id == IDM_DOCLIST_FILESCLOSEOTHERS);
182  				fileCloseAllGiven(bufs2Close);
183  				if (id == IDM_DOCLIST_FILESCLOSEOTHERS)
184  				{
185  					_pDocumentListPanel->activateItem(_pEditView->getCurrentBufferID(), currentView());
186  				}
187  			}
188  			break;
189  		case IDM_DOCLIST_COPYNAMES:
190  		case IDM_DOCLIST_COPYPATHS:
191  			if (_pDocumentListPanel)
192  			{
193  				std::vector<Buffer*> buffers;
194  				auto files = _pDocumentListPanel->getSelectedFiles(false);
195  				for (auto&& sel : files)
196  					buffers.push_back(MainFileManager.getBufferByID(sel._bufID));
197  				buf2Clipborad(buffers, id == IDM_DOCLIST_COPYPATHS, _pDocumentListPanel->getHSelf());
198  			}
199  			break;
200  		case IDM_FILE_CLOSE:
201  			if (fileClose())
202                  checkDocState();
203  			break;
204  		case IDM_FILE_DELETE:
205  			if (fileDelete())
206                  checkDocState();
207  			break;
208  		case IDM_FILE_RENAME:
209  			fileRename();
210  			break;
211  		case IDM_FILE_CLOSEALL:
212  		{
213  			bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
214  			fileCloseAll(isSnapshotMode, false);
215              checkDocState();
216  			break;
217  		}
218  		case IDM_FILE_CLOSEALL_BUT_CURRENT :
219  			fileCloseAllButCurrent();
220              checkDocState();
221  			break;
222  		case IDM_FILE_CLOSEALL_TOLEFT :
223  			fileCloseAllToLeft();
224  			checkDocState();
225  			break;
226  		case IDM_FILE_CLOSEALL_TORIGHT :
227  			fileCloseAllToRight();
228  			checkDocState();
229  			break;
230  		case IDM_FILE_CLOSEALL_UNCHANGED:
231  			fileCloseAllUnchanged();
232  			checkDocState();
233  			break;
234  		case IDM_FILE_SAVE :
235  			fileSave();
236  			break;
237  		case IDM_FILE_SAVEALL :
238  			fileSaveAll();
239  			break;
240  		case IDM_FILE_SAVEAS :
241  			fileSaveAs();
242  			break;
243  		case IDM_FILE_SAVECOPYAS :
244  			fileSaveAs(BUFFER_INVALID, true);
245  			break;
246  		case IDM_FILE_LOADSESSION:
247  			fileLoadSession();
248  			break;
249  		case IDM_FILE_SAVESESSION:
250  			fileSaveSession();
251  			break;
252  		case IDM_FILE_PRINTNOW :
253  			filePrint(false);
254  			break;
255  		case IDM_FILE_PRINT :
256  			filePrint(true);
257  			break;
258  		case IDM_FILE_EXIT:
259  			::PostMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
260  			break;
261  		case IDM_EDIT_UNDO:
262  		{
263  			std::lock_guard<std::mutex> lock(command_mutex);
264  			_pEditView->execute(WM_UNDO);
265  			checkClipboard();
266  			checkUndoState();
267  			break;
268  		}
269  		case IDM_EDIT_REDO:
270  		{
271  			std::lock_guard<std::mutex> lock(command_mutex);
272  			_pEditView->execute(SCI_REDO);
273  			checkClipboard();
274  			checkUndoState();
275  			break;
276  		}
277  		case IDM_EDIT_CUT:
278  			_pEditView->execute(WM_CUT);
279  			checkClipboard();
280  			break;
281  		case IDM_EDIT_COPY:
282  			_pEditView->execute(WM_COPY);
283  			checkClipboard();
284  			break;
285  		case IDM_EDIT_COPY_LINK:
286  		{
287  			size_t startPos = 0, endPos = 0, curPos = 0;
288  			if (_pEditView->getIndicatorRange(URL_INDIC, &startPos, &endPos, &curPos))
289  			{
290  				_pEditView->execute(SCI_SETSEL, startPos, endPos);
291  				_pEditView->execute(WM_COPY);
292  				checkClipboard();
293  				_pEditView->execute(SCI_SETSEL, curPos, curPos);
294  			}
295  			break;
296  		}
297  		case IDM_EDIT_COPY_BINARY:
298  		case IDM_EDIT_CUT_BINARY:
299  		{
300  			size_t textLen = _pEditView->execute(SCI_GETSELTEXT, 0, 0);
301  			if (!textLen)
302  				return;
303  			char *pBinText = new char[textLen + 1];
304  			_pEditView->getSelectedText(pBinText, textLen + 1);
305  			if (!OpenClipboard(NULL))
306  				return;
307  			EmptyClipboard();
308  			HGLOBAL hglbCopy = GlobalAlloc(GMEM_MOVEABLE, (textLen + 1) * sizeof(unsigned char));
309  			if (hglbCopy == NULL)
310  			{
311  				CloseClipboard();
312  				return;
313  			}
314  			unsigned char *lpucharCopy = (unsigned char *)GlobalLock(hglbCopy);
315  			memcpy(lpucharCopy, pBinText, textLen * sizeof(unsigned char));
316  			lpucharCopy[textLen] = 0;    
317  			delete[] pBinText;
318  			GlobalUnlock(hglbCopy);
319  			SetClipboardData(CF_TEXT, hglbCopy);
320  			HGLOBAL hglbLenCopy = GlobalAlloc(GMEM_MOVEABLE, sizeof(unsigned long));
321  			if (hglbLenCopy == NULL)
322  			{
323  				CloseClipboard();
324  				return;
325  			}
326  			unsigned long *lpLenCopy = (unsigned long *)GlobalLock(hglbLenCopy);
327  			*lpLenCopy = static_cast<unsigned long>(textLen);
328  			GlobalUnlock(hglbLenCopy);
329  			UINT f = RegisterClipboardFormat(CF_NPPTEXTLEN);
330  			SetClipboardData(f, hglbLenCopy);
331  			CloseClipboard();
332  			if (id == IDM_EDIT_CUT_BINARY)
333  				_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
334  		}
335  		break;
336  		case IDM_EDIT_PASTE:
337  		{
338  			std::lock_guard<std::mutex> lock(command_mutex);
339  			intptr_t eolMode = _pEditView->execute(SCI_GETEOLMODE);
340  			_pEditView->execute(SCI_PASTE);
341  			_pEditView->execute(SCI_CONVERTEOLS, eolMode);
342  		}
343  		break;
344  		case IDM_EDIT_PASTE_BINARY:
345  		{
346  			std::lock_guard<std::mutex> lock(command_mutex);
347  			if (!IsClipboardFormatAvailable(CF_TEXT))
348  				return;
349  			if (!OpenClipboard(NULL))
350  				return;
351  			HGLOBAL hglb = GetClipboardData(CF_TEXT);
352  			if (hglb != NULL)
353  			{
354  				char *lpchar = (char *)GlobalLock(hglb);
355  				if (lpchar != NULL)
356  				{
357  					UINT cf_nppTextLen = RegisterClipboardFormat(CF_NPPTEXTLEN);
358  					if (IsClipboardFormatAvailable(cf_nppTextLen))
359  					{
360  						HGLOBAL hglbLen = GetClipboardData(cf_nppTextLen);
361  						if (hglbLen != NULL)
362  						{
363  							unsigned long *lpLen = (unsigned long *)GlobalLock(hglbLen);
364  							if (lpLen != NULL)
365  							{
366  								_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
367  								_pEditView->execute(SCI_ADDTEXT, *lpLen, reinterpret_cast<LPARAM>(lpchar));
368  								GlobalUnlock(hglbLen);
369  							}
370  						}
371  					}
372  					else
373  					{
374  						_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(lpchar));
375  					}
376  					GlobalUnlock(hglb);
377  				}
378  			}
379  			CloseClipboard();
380  		}
381  		break;
382  		case IDM_EDIT_OPENINFOLDER:
383  		case IDM_EDIT_OPENASFILE:
384  		{
385  			if (_pEditView->execute(SCI_GETSELECTIONS) != 1) 
386  				return;
387  			HWND hwnd = _pPublicInterface->getHSelf();
388  			TCHAR curentWord[CURRENTWORD_MAXLENGTH] = { '\0' };
389  			::SendMessage(hwnd, NPPM_GETFILENAMEATCURSOR, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(curentWord));
390  			TCHAR cmd2Exec[CURRENTWORD_MAXLENGTH] = { '\0' };
391  			if (id == IDM_EDIT_OPENINFOLDER)
392  			{
393  				wcscpy_s(cmd2Exec, TEXT("explorer"));
394  			}
395  			else
396  			{
397  				::SendMessage(hwnd, NPPM_GETNPPFULLFILEPATH, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(cmd2Exec));
398  			}
399  			if (::PathFileExists(curentWord))
400  			{
401  				generic_string fullFilePath = id == IDM_EDIT_OPENINFOLDER ? TEXT("/select,") : TEXT("");
402  				fullFilePath += TEXT("\"");
403  				fullFilePath += curentWord;
404  				fullFilePath += TEXT("\"");
405  				if (id == IDM_EDIT_OPENINFOLDER ||
406  					(id == IDM_EDIT_OPENASFILE && !::PathIsDirectory(curentWord)))
407  					::ShellExecute(hwnd, TEXT("open"), cmd2Exec, fullFilePath.c_str(), TEXT("."), SW_SHOW);
408  			}
409  			else 
410  			{
411  				TCHAR currentDir[CURRENTWORD_MAXLENGTH] = { '\0' };
412  				::SendMessage(hwnd, NPPM_GETCURRENTDIRECTORY, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(currentDir));
413  				generic_string fullFilePath = id == IDM_EDIT_OPENINFOLDER ? TEXT("/select,") : TEXT("");
414  				fullFilePath += TEXT("\"");
415  				fullFilePath += currentDir;
416  				fullFilePath += TEXT("\\");
417  				fullFilePath += curentWord;
418  				if ((id == IDM_EDIT_OPENASFILE &&
419  					(!::PathFileExists(fullFilePath.c_str() + 1) || ::PathIsDirectory(fullFilePath.c_str() + 1))))
420  				{
421  					_nativeLangSpeaker.messageBox("FilePathNotFoundWarning",
422  						_pPublicInterface->getHSelf(),
423  						TEXT("The file you're trying to open doesn't exist."),
424  						TEXT("File Open"),
425  						MB_OK | MB_APPLMODAL);
426  					return;
427  				}
428  				fullFilePath += TEXT("\"");
429  				::ShellExecute(hwnd, TEXT("open"), cmd2Exec, fullFilePath.c_str(), TEXT("."), SW_SHOW);
430  			}
431  		}
432  		break;
433  		case IDM_EDIT_SEARCHONINTERNET:
434  		{
435  			if (_pEditView->execute(SCI_GETSELECTIONS) != 1) 
436  				return;
437  			const NppGUI & nppGui = (NppParameters::getInstance()).getNppGUI();
438  			generic_string url;
439  			if (nppGui._searchEngineChoice == nppGui.se_custom)
440  			{
441  				url = nppGui._searchEngineCustom;
442  				url.erase(std::remove_if(url.begin(), url.end(), [](_TUCHAR x) {return _istspace(x); }),
443  					url.end());
444  				auto httpPos = url.find(TEXT("http:&bsol;&bsol;"));
445  				auto httpsPos = url.find(TEXT("https:&bsol;&bsol;"));
446  				if (url.empty() || (httpPos != 0 && httpsPos != 0)) 
447  				{
448  					url = TEXT("https:&bsol;&bsol;www.google.com/search?q=$(CURRENT_WORD)");
449  				}
450  			}
451  			else if (nppGui._searchEngineChoice == nppGui.se_duckDuckGo || nppGui._searchEngineChoice == nppGui.se_bing)
452  			{
453  				url = TEXT("https:&bsol;&bsol;duckduckgo.com/?q=$(CURRENT_WORD)");
454  			}
455  			else if (nppGui._searchEngineChoice == nppGui.se_google)
456  			{
457  				url = TEXT("https:&bsol;&bsol;www.google.com/search?q=$(CURRENT_WORD)");
458  			}
459  			else if (nppGui._searchEngineChoice == nppGui.se_yahoo)
460  			{
461  				url = TEXT("https:&bsol;&bsol;search.yahoo.com/search?q=$(CURRENT_WORD)");
462  			}
463  			else if (nppGui._searchEngineChoice == nppGui.se_stackoverflow)
464  			{
465  				url = TEXT("https:&bsol;&bsol;stackoverflow.com/search?q=$(CURRENT_WORD)");
466  			}
467  			Command cmd(url.c_str());
468  			cmd.run(_pPublicInterface->getHSelf());	
469  		}
470  		break;
471  		case IDM_EDIT_CHANGESEARCHENGINE:
472  		{
473  			command(IDM_SETTING_PREFERENCE);
474  			_preference.showDialogByName(TEXT("SearchEngine"));
475  		}
476  		break;
477  		case IDM_EDIT_PASTE_AS_RTF:
478  		case IDM_EDIT_PASTE_AS_HTML:
479  		{
480  			std::lock_guard<std::mutex> lock(command_mutex);
481  			UINT f = RegisterClipboardFormat(id==IDM_EDIT_PASTE_AS_HTML?CF_HTML:CF_RTF);
482  			if (!IsClipboardFormatAvailable(f))
483  				return;
484  			if (!OpenClipboard(NULL))
485  				return;
486  			HGLOBAL hglb = GetClipboardData(f);
487  			if (hglb != NULL)
488  			{
489  				LPSTR lptstr = (LPSTR)GlobalLock(hglb);
490  				if (lptstr != NULL)
491  				{
492  					_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(lptstr));
493  					GlobalUnlock(hglb);
494  				}
495  			}
496  			CloseClipboard();
497  		}
498  		break;
499  		case IDM_EDIT_BEGINENDSELECT:
500  		case IDM_EDIT_BEGINENDSELECT_COLUMNMODE:
501  		{
502  			_pEditView->beginOrEndSelect(id == IDM_EDIT_BEGINENDSELECT_COLUMNMODE);
503  			bool isStarted = _pEditView->beginEndSelectedIsStarted();
504  			::CheckMenuItem(_mainMenuHandle, id, MF_BYCOMMAND | (isStarted ? MF_CHECKED : MF_UNCHECKED));
505  			int otherId = (id == IDM_EDIT_BEGINENDSELECT) ? IDM_EDIT_BEGINENDSELECT_COLUMNMODE : IDM_EDIT_BEGINENDSELECT;
506  			::EnableMenuItem(_mainMenuHandle, otherId, MF_BYCOMMAND | (isStarted ? (MF_DISABLED | MF_GRAYED) : MF_ENABLED));
507  		}
508  		break;
509  		case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING:
510  		case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING:
511  		case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING:
512  		case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING:
513  		case IDM_EDIT_SORTLINES_INTEGER_ASCENDING:
514  		case IDM_EDIT_SORTLINES_INTEGER_DESCENDING:
515  		case IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING:
516  		case IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING:
517  		case IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING:
518  		case IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING:
519  		case IDM_EDIT_SORTLINES_REVERSE_ORDER:
520  		case IDM_EDIT_SORTLINES_RANDOMLY:
521  		{
522  			std::lock_guard<std::mutex> lock(command_mutex);
523  			size_t fromLine = 0, toLine = 0;
524  			size_t fromColumn = 0, toColumn = 0;
525  			bool hasLineSelection = false;
526  			if (_pEditView->execute(SCI_GETSELECTIONS) > 1)
527  			{
528  				if (_pEditView->execute(SCI_SELECTIONISRECTANGLE) || _pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN)
529  				{
530  					size_t rectSelAnchor = _pEditView->execute(SCI_GETRECTANGULARSELECTIONANCHOR);
531  					size_t rectSelCaret = _pEditView->execute(SCI_GETRECTANGULARSELECTIONCARET);
532  					size_t anchorLine = _pEditView->execute(SCI_LINEFROMPOSITION, rectSelAnchor);
533  					size_t caretLine = _pEditView->execute(SCI_LINEFROMPOSITION, rectSelCaret);
534  					fromLine = std::min<size_t>(anchorLine, caretLine);
535  					toLine = std::max<size_t>(anchorLine, caretLine);
536  					size_t anchorLineOffset = rectSelAnchor - _pEditView->execute(SCI_POSITIONFROMLINE, anchorLine) + _pEditView->execute(SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE);
537  					size_t caretLineOffset = rectSelCaret - _pEditView->execute(SCI_POSITIONFROMLINE, caretLine) + _pEditView->execute(SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE);
538  					fromColumn = std::min<size_t>(anchorLineOffset, caretLineOffset);
539  					toColumn = std::max<size_t>(anchorLineOffset, caretLineOffset);
540  				}
541  				else
542  				{
543  					return;
544  				}
545  			}
546  			else
547  			{
548  				auto selStart = _pEditView->execute(SCI_GETSELECTIONSTART);
549  				auto selEnd = _pEditView->execute(SCI_GETSELECTIONEND);
550  				hasLineSelection = selStart != selEnd;
551  				if (hasLineSelection)
552  				{
553  					const pair<size_t, size_t> lineRange = _pEditView->getSelectionLinesRange();
554  					if (lineRange.first == lineRange.second)
555  					{
556  						return;
557  					}
558  					fromLine = lineRange.first;
559  					toLine = lineRange.second;
560  				}
561  				else
562  				{
563  					fromLine = 0;
564  					toLine = _pEditView->execute(SCI_GETLINECOUNT) - 1;
565  				}
566  			}
567  			bool isDescending = id == IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING ||
568  								id == IDM_EDIT_SORTLINES_INTEGER_DESCENDING ||
569  								id == IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING ||
570  								id == IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING ||
571  								id == IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING;
572  			_pEditView->execute(SCI_BEGINUNDOACTION);
573  			std::unique_ptr<ISorter> pSorter;
574  			if (id == IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING || id == IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING)
575  			{
576  				pSorter = std::unique_ptr<ISorter>(new LexicographicSorter(isDescending, fromColumn, toColumn));
577  			}
578  			else if (id == IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING || id == IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING)
579  			{
580  				pSorter = std::unique_ptr<ISorter>(new LexicographicCaseInsensitiveSorter(isDescending, fromColumn, toColumn));
581  			}
582  			else if (id == IDM_EDIT_SORTLINES_INTEGER_DESCENDING || id == IDM_EDIT_SORTLINES_INTEGER_ASCENDING)
583  			{
584  				pSorter = std::unique_ptr<ISorter>(new IntegerSorter(isDescending, fromColumn, toColumn));
585  			}
586  			else if (id == IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING || id == IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING)
587  			{
588  				pSorter = std::unique_ptr<ISorter>(new DecimalCommaSorter(isDescending, fromColumn, toColumn));
589  			}
590  			else if (id == IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING || id == IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING)
591  			{
592  				pSorter = std::unique_ptr<ISorter>(new DecimalDotSorter(isDescending, fromColumn, toColumn));
593  			}
594  			else if (id == IDM_EDIT_SORTLINES_REVERSE_ORDER)
595  			{
596  				pSorter = std::unique_ptr<ISorter>(new ReverseSorter(isDescending, fromColumn, toColumn));
597  			}
598  			else
599  			{
600  				pSorter = std::unique_ptr<ISorter>(new RandomSorter(isDescending, fromColumn, toColumn));
601  			}
602  			try
603  			{
604  				_pEditView->sortLines(fromLine, toLine, pSorter.get());
605  			}
606  			catch (size_t& failedLineIndex)
607  			{
608  				size_t lineNo = 1 + fromLine + failedLineIndex;
609  				_nativeLangSpeaker.messageBox("SortingError",
610  					_pPublicInterface->getHSelf(),
611  					TEXT("Unable to perform numeric sorting due to line $INT_REPLACE$."),
612  					TEXT("Sorting Error"),
613  					MB_OK | MB_ICONINFORMATION | MB_APPLMODAL,
614  					static_cast<int>(lineNo),
615  					0);
616  			}
617  			_pEditView->execute(SCI_ENDUNDOACTION);
618  			if (hasLineSelection) 
619  			{
620  				auto posStart = _pEditView->execute(SCI_POSITIONFROMLINE, fromLine);
621  				auto posEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, toLine);
622  				_pEditView->execute(SCI_SETSELECTIONSTART, posStart);
623  				_pEditView->execute(SCI_SETSELECTIONEND, posEnd);
624  			}
625  		}
626  		break;
627  		case IDM_EDIT_BLANKLINEABOVECURRENT:
628  		{
629  			_pEditView->insertNewLineAboveCurrentLine();
630  		}
631  		break;
632  		case IDM_EDIT_BLANKLINEBELOWCURRENT:
633  		{
634  			_pEditView->insertNewLineBelowCurrentLine();
635  		}
636  		break;
637  		case IDM_EDIT_CHAR_PANEL:
638  		{
639  			if (_pAnsiCharPanel && (!_pAnsiCharPanel->isClosed()))
640  			{
641  				_pAnsiCharPanel->display(false);
642  				_pAnsiCharPanel->setClosed(true);
643  				checkMenuItem(IDM_EDIT_CHAR_PANEL, false);
644  			}
645  			else
646  			{
647  				checkMenuItem(IDM_EDIT_CHAR_PANEL, true);
648  				launchAnsiCharPanel();
649  				_pAnsiCharPanel->setClosed(false);
650  			}
651  		}
652  		break;
653  		case IDM_EDIT_CLIPBOARDHISTORY_PANEL:
654  		{
655  			if (_pClipboardHistoryPanel && (!_pClipboardHistoryPanel->isClosed()))
656  			{
657  				_pClipboardHistoryPanel->display(false);
658  				_pClipboardHistoryPanel->setClosed(true);
659  				checkMenuItem(IDM_EDIT_CLIPBOARDHISTORY_PANEL, false);
660  			}
661  			else
662  			{
663  				checkMenuItem(IDM_EDIT_CLIPBOARDHISTORY_PANEL, true);
664  				launchClipboardHistoryPanel();
665  				_pClipboardHistoryPanel->setClosed(false);
666  			}
667  		}
668  		break;
669  		case IDM_VIEW_SWITCHTO_DOCLIST:
670  		{
671  			if (_pDocumentListPanel && _pDocumentListPanel->isVisible())
672  			{
673  				_pDocumentListPanel->getFocus();
674  			}
675  			else
676  			{
677  				checkMenuItem(IDM_VIEW_DOCLIST, true);
678  				_toolBar.setCheck(IDM_VIEW_DOCLIST, true);
679  				launchDocumentListPanel();
680  				_pDocumentListPanel->setClosed(false);
681  			}
682  		}
683  		break;
684  		case IDM_VIEW_DOCLIST:
685  		{
686  			if (_pDocumentListPanel && (!_pDocumentListPanel->isClosed()))
687  			{
688  				_pDocumentListPanel->display(false);
689  				_pDocumentListPanel->setClosed(true);
690  				checkMenuItem(IDM_VIEW_DOCLIST, false);
691  				_toolBar.setCheck(IDM_VIEW_DOCLIST, false);
692  			}
693  			else
694  			{
695  				launchDocumentListPanel();
696  				if (_pDocumentListPanel)
697  				{
698  					checkMenuItem(IDM_VIEW_DOCLIST, true);
699  					_toolBar.setCheck(IDM_VIEW_DOCLIST, true);
700  					_pDocumentListPanel->setClosed(false);
701  				}
702  			}
703  		}
704  		break;
705  		case IDM_VIEW_PROJECT_PANEL_1:
706  		case IDM_VIEW_PROJECT_PANEL_2:
707  		case IDM_VIEW_PROJECT_PANEL_3:
708  		{
709  			ProjectPanel** pp [] = {&_pProjectPanel_1, &_pProjectPanel_2, &_pProjectPanel_3};
710  			int idx = id - IDM_VIEW_PROJECT_PANEL_1;
711  			if (*pp [idx] == nullptr)
712  			{
713  				launchProjectPanel(id, pp [idx], idx);
714  			}
715  			else
716  			{
717  				if (!(*pp[idx])->isClosed())
718  				{
719  					if ((*pp[idx])->checkIfNeedSave())
720  					{
721  						if (::IsChild((*pp[idx])->getHSelf(), ::GetFocus()))
722  							::SetFocus(_pEditView->getHSelf());
723  						(*pp[idx])->display(false);
724  						(*pp[idx])->setClosed(true);
725  						checkMenuItem(id, false);
726  						checkProjectMenuItem();
727  					}
728  				}
729  				else
730  				{
731  					launchProjectPanel(id, pp [idx], idx);
732  				}
733  			}
734  		}
735  		break;
736  		case IDM_VIEW_SWITCHTO_PROJECT_PANEL_1:
737  		case IDM_VIEW_SWITCHTO_PROJECT_PANEL_2:
738  		case IDM_VIEW_SWITCHTO_PROJECT_PANEL_3:
739  		{
740  			ProjectPanel** pp [] = {&_pProjectPanel_1, &_pProjectPanel_2, &_pProjectPanel_3};
741  			int idx = id - IDM_VIEW_SWITCHTO_PROJECT_PANEL_1;
742  			launchProjectPanel(id - IDM_VIEW_SWITCHTO_PROJECT_PANEL_1 + IDM_VIEW_PROJECT_PANEL_1, pp [idx], idx);
743  		}
744  		break;
745  		case IDM_VIEW_FILEBROWSER:
746  		case IDM_VIEW_SWITCHTO_FILEBROWSER:
747  		{
748  			if (_pFileBrowser == nullptr) 
749  			{
750  				NppParameters& nppParam = NppParameters::getInstance();
751  				launchFileBrowser(nppParam.getFileBrowserRoots(), nppParam.getFileBrowserSelectedItemPath());
752  				if (_pFileBrowser != nullptr)
753  				{
754  					checkMenuItem(IDM_VIEW_FILEBROWSER, true);
755  					_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
756  					_pFileBrowser->setClosed(false);
757  				}
758  			}
759  			else
760  			{
761  				if (!_pFileBrowser->isClosed() && (id != IDM_VIEW_SWITCHTO_FILEBROWSER))
762  				{
763  					_pFileBrowser->display(false);
764  					_pFileBrowser->setClosed(true);
765  					checkMenuItem(IDM_VIEW_FILEBROWSER, false);
766  					_toolBar.setCheck(IDM_VIEW_FILEBROWSER, false);
767  				}
768  				else
769  				{
770  					vector<generic_string> dummy;
771  					generic_string emptyStr;
772  					launchFileBrowser(dummy, emptyStr);
773  					checkMenuItem(IDM_VIEW_FILEBROWSER, true);
774  					_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
775  					_pFileBrowser->setClosed(false);
776  				}
777  			}
778  		}
779  		break;
780  		case IDM_VIEW_DOC_MAP:
781  		{
782  			if (_pDocMap && (!_pDocMap->isClosed()))
783  			{
784  				_pDocMap->display(false);
785  				_pDocMap->vzDlgDisplay(false);
786  				_pDocMap->setClosed(true);
787  				checkMenuItem(IDM_VIEW_DOC_MAP, false);
788  				_toolBar.setCheck(IDM_VIEW_DOC_MAP, false);
789  			}
790  			else
791  			{
792  				launchDocMap();
793  				if (_pDocMap)
794  				{
795  					checkMenuItem(IDM_VIEW_DOC_MAP, true);
796  					_toolBar.setCheck(IDM_VIEW_DOC_MAP, true);
797  					_pDocMap->setClosed(false);
798  				}
799  			}
800  		}
801  		break;
802  		case IDM_VIEW_SWITCHTO_FUNC_LIST:
803  		{
804  			if (_pFuncList && _pFuncList->isVisible())
805  			{
806  				_pFuncList->getFocus();
807  			}
808  			else
809  			{
810  				checkMenuItem(IDM_VIEW_FUNC_LIST, true);
811  				_toolBar.setCheck(IDM_VIEW_FUNC_LIST, true);
812  				launchFunctionList();
813  				_pFuncList->setClosed(false);
814  			}
815  		}
816  		break;
817  		case IDM_VIEW_FUNC_LIST:
818  		{
819  			if (_pFuncList && (!_pFuncList->isClosed()))
820  			{
821  				_pFuncList->display(false);
822  				_pFuncList->setClosed(true);
823  				checkMenuItem(IDM_VIEW_FUNC_LIST, false);
824  				_toolBar.setCheck(IDM_VIEW_FUNC_LIST, false);
825  			}
826  			else
827  			{
828  				checkMenuItem(IDM_VIEW_FUNC_LIST, true);
829  				_toolBar.setCheck(IDM_VIEW_FUNC_LIST, true);
830  				launchFunctionList();
831  				_pFuncList->setClosed(false);
832  			}
833  		}
834  		break;
835  		case IDM_VIEW_TAB_COLOUR_NONE:
836  		case IDM_VIEW_TAB_COLOUR_1:
837  		case IDM_VIEW_TAB_COLOUR_2:
838  		case IDM_VIEW_TAB_COLOUR_3:
839  		case IDM_VIEW_TAB_COLOUR_4:
840  		case IDM_VIEW_TAB_COLOUR_5:
841  		{
842  			const int color_id = (id - IDM_VIEW_TAB_COLOUR_NONE) - 1;
843  			const auto current_index = _pDocTab->getCurrentTabIndex();
844  			BufferID buffer_id = _pDocTab->getBufferByIndex(current_index);
845  			_pDocTab->setIndividualTabColour(buffer_id, color_id);
846  			_pDocTab->redraw();
847  			if (_pDocumentListPanel != nullptr)
848  			{
849  				_pDocumentListPanel->setItemColor(buffer_id);
850  			}
851  		}
852  		break;
853  		case IDM_VIEW_TAB1:
854  		case IDM_VIEW_TAB2:
855  		case IDM_VIEW_TAB3:
856  		case IDM_VIEW_TAB4:
857  		case IDM_VIEW_TAB5:
858  		case IDM_VIEW_TAB6:
859  		case IDM_VIEW_TAB7:
860  		case IDM_VIEW_TAB8:
861  		case IDM_VIEW_TAB9:
862  		{
863  			const int index = id - IDM_VIEW_TAB1;
864  			BufferID buf = _pDocTab->getBufferByIndex(index);
865  			_isFolding = true;
866  			if (buf == BUFFER_INVALID)
867  			{
868  				const int last_index = _pDocTab->getItemCount() - 1;
869  				if (last_index > 0)
870  					switchToFile(_pDocTab->getBufferByIndex(last_index));
871  			}
872  			else
873  			{
874  				switchToFile(buf);
875  			}
876  			_isFolding = false;
877  		}
878  		break;
879  		case IDM_VIEW_TAB_NEXT:
880  		{
881  			const int current_index = _pDocTab->getCurrentTabIndex();
882  			const int last_index = _pDocTab->getItemCount() - 1;
883  			_isFolding = true;
884  			if (current_index < last_index)
885  				switchToFile(_pDocTab->getBufferByIndex(current_index + 1));
886  			else
887  			{
888  				switchToFile(_pDocTab->getBufferByIndex(0)); 
889  			}
890  			_isFolding = false;
891  		}
892  		break;
893  		case IDM_VIEW_TAB_PREV:
894  		{
895  			const int current_index = _pDocTab->getCurrentTabIndex();
896  			_isFolding = true;
897  			if (current_index > 0)
898  				switchToFile(_pDocTab->getBufferByIndex(current_index - 1));
899  			else
900  			{
901  				const int last_index = _pDocTab->getItemCount() - 1;
902  				switchToFile(_pDocTab->getBufferByIndex(last_index)); 
903  			}
904  			_isFolding = false;
905  		}
906  		break;
907  		case IDM_VIEW_TAB_MOVEFORWARD:
908  		case IDM_VIEW_TAB_MOVEBACKWARD:
909  		{
910  			const int currentTabIndex = _pDocTab->getCurrentTabIndex();
911  			const int lastTabIndex = _pDocTab->getItemCount() - 1;
912  			int newTabIndex = currentTabIndex;
913  			if (id == IDM_VIEW_TAB_MOVEFORWARD)
914  			{
915  				if (currentTabIndex >= lastTabIndex)
916  					return;
917  				++newTabIndex;
918  			}
919  			else
920  			{
921  				if (currentTabIndex < 1)
922  					return;
923  				--newTabIndex;
924  			}
925  			TCITEM tciMove{}, tciShift{};
926  			tciMove.mask = tciShift.mask = TCIF_IMAGE | TCIF_TEXT | TCIF_PARAM;
927  			const int strSizeMax = 256;
928  			TCHAR strMove[strSizeMax] = { '\0' };
929  			TCHAR strShift[strSizeMax] = { '\0' };
930  			tciMove.pszText = strMove;
931  			tciMove.cchTextMax = strSizeMax;
932  			tciShift.pszText = strShift;
933  			tciShift.cchTextMax = strSizeMax;
934  			::SendMessage(_pDocTab->getHSelf(), TCM_GETITEM, currentTabIndex, reinterpret_cast<LPARAM>(&tciMove));
935  			::SendMessage(_pDocTab->getHSelf(), TCM_GETITEM, newTabIndex, reinterpret_cast<LPARAM>(&tciShift));
936  			::SendMessage(_pDocTab->getHSelf(), TCM_SETITEM, currentTabIndex, reinterpret_cast<LPARAM>(&tciShift));
937  			::SendMessage(_pDocTab->getHSelf(), TCM_SETITEM, newTabIndex, reinterpret_cast<LPARAM>(&tciMove));
938  			::SendMessage(_pDocTab->getHSelf(), TCM_SETCURSEL, newTabIndex, 0);
939  			::SendMessage(_pDocTab->getHParent(), NPPM_INTERNAL_DOCORDERCHANGED, 0, newTabIndex);
940  		}
941  		break;
942  		case IDM_EDIT_DELETE:
943  			_pEditView->execute(WM_CLEAR);
944  			break;
945  		case IDM_MACRO_STARTRECORDINGMACRO:
946  		case IDM_MACRO_STOPRECORDINGMACRO:
947  		case IDC_EDIT_TOGGLEMACRORECORDING:
948  		{
949  			if (_recordingMacro)
950  			{
951  				_mainEditView.execute(SCI_STOPRECORD);
952  				_subEditView.execute(SCI_STOPRECORD);
953  				_mainEditView.execute(SCI_SETCURSOR, static_cast<WPARAM>(SC_CURSORNORMAL));
954  				_subEditView.execute(SCI_SETCURSOR, static_cast<WPARAM>(SC_CURSORNORMAL));
955  				_recordingMacro = false;
956  				_runMacroDlg.initMacroList();
957  			}
958  			else
959  			{
960  				_mainEditView.execute(SCI_SETCURSOR, 9);
961  				_subEditView.execute(SCI_SETCURSOR, 9);
962  				_macro.clear();
963  				_mainEditView.execute(SCI_STARTRECORD);
964  				_subEditView.execute(SCI_STARTRECORD);
965  				_recordingMacro = true;
966  			}
967  			_recordingSaved = false;
968  			checkMacroState();
969  			break;
970  		}
971  		case IDM_MACRO_PLAYBACKRECORDEDMACRO:
972  			if (!_recordingMacro) 
973  			{
974  				macroPlayback(_macro);
975  			}
976  			break;
977  		case IDM_MACRO_RUNMULTIMACRODLG :
978  		{
979  			if (!_recordingMacro) 
980  			{
981  				bool isFirstTime = !_runMacroDlg.isCreated();
982  				_runMacroDlg.doDialog(_nativeLangSpeaker.isRTL());
983  				if (isFirstTime)
984  				{
985  					_nativeLangSpeaker.changeDlgLang(_runMacroDlg.getHSelf(), "MultiMacro");
986  				}
987  				break;
988  			}
989  		}
990  		break;
991  		case IDM_MACRO_SAVECURRENTMACRO :
992  		{
993  			if (addCurrentMacro())
994  			{
995  				_recordingSaved = true;
996  				_runMacroDlg.initMacroList();
997  				checkMacroState();
998  			}
999  			break;
1000  		}
1001  		case IDM_EDIT_FULLPATHTOCLIP :
1002  		case IDM_EDIT_CURRENTDIRTOCLIP :
1003  		case IDM_EDIT_FILENAMETOCLIP :
1004  		{
1005  			Buffer * buf = _pEditView->getCurrentBuffer();
1006  			if (id == IDM_EDIT_FULLPATHTOCLIP)
1007  			{
1008  				str2Cliboard(buf->getFullPathName());
1009  			}
1010  			else if (id == IDM_EDIT_CURRENTDIRTOCLIP)
1011  			{
1012  				generic_string dir(buf->getFullPathName());
1013  				PathRemoveFileSpec(dir);
1014  				str2Cliboard(dir);
1015  			}
1016  			else if (id == IDM_EDIT_FILENAMETOCLIP)
1017  			{
1018  				str2Cliboard(buf->getFileName());
1019  			}
1020  		}
1021  		break;
1022  		case IDM_EDIT_COPY_ALL_NAMES:
1023  		case IDM_EDIT_COPY_ALL_PATHS:
1024  			{
1025  				std::vector<DocTabView*> docTabs;
1026  				if (viewVisible(MAIN_VIEW))
1027  					docTabs.push_back(&_mainDocTab);
1028  				if (viewVisible(SUB_VIEW))
1029  					docTabs.push_back(&_subDocTab);
1030  				std::vector<Buffer*> buffers;
1031  				for (auto&& docTab : docTabs)
1032  				{
1033  					for (size_t i = 0, len = docTab->nbItem(); i < len; ++i)
1034  					{
1035  						BufferID bufID = docTab->getBufferByIndex(i);
1036  						Buffer* buf = MainFileManager.getBufferByID(bufID);
1037  						if (docTabs.size() < 2 || std::find(buffers.begin(), buffers.end(), buf) == buffers.end())
1038  							buffers.push_back(buf);
1039  					}
1040  				}
1041  				buf2Clipborad({ buffers.begin(), buffers.end() }, id == IDM_EDIT_COPY_ALL_PATHS, _pPublicInterface->getHSelf());
1042  			}
1043  			break;
1044  		case IDM_SEARCH_FIND :
1045  		case IDM_SEARCH_REPLACE :
1046  		case IDM_SEARCH_MARK :
1047  		{
1048  			const int strSize = FINDREPLACE_MAXLENGTH;
1049  			TCHAR str[strSize] = { '\0' };
1050  			bool isFirstTime = !_findReplaceDlg.isCreated();
1051  			DIALOG_TYPE dlgID = FIND_DLG;
1052  			if (id == IDM_SEARCH_REPLACE)
1053  				dlgID = REPLACE_DLG;
1054  			else if (id == IDM_SEARCH_MARK)
1055  				dlgID = MARK_DLG;
1056  			_findReplaceDlg.doDialog(dlgID, _nativeLangSpeaker.isRTL());
1057  			const NppGUI & nppGui = (NppParameters::getInstance()).getNppGUI();
1058  			if (nppGui._fillFindFieldWithSelected)
1059  			{
1060  				_pEditView->getGenericSelectedText(str, strSize, nppGui._fillFindFieldSelectCaret);
1061  				if (lstrlen(str) <= FINDREPLACE_INSEL_TEXTSIZE_THRESHOLD)
1062  				{
1063  					_findReplaceDlg.setSearchText(str);
1064  				}
1065  			}
1066  			setFindReplaceFolderFilter(NULL, NULL);
1067  			if (isFirstTime)
1068  				_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
1069  			break;
1070  		}
1071  		case IDM_SEARCH_FINDINFILES:
1072  		{
1073  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_LAUNCHFINDINFILESDLG, 0, 0);
1074  			break;
1075  		}
1076  		case IDM_SEARCH_FINDINCREMENT :
1077  		{
1078  			const int strSize = FINDREPLACE_MAXLENGTH;
1079  			TCHAR str[strSize] = { '\0' };
1080  			static bool isFirstTime = true;
1081  			if (isFirstTime)
1082  			{
1083  				_nativeLangSpeaker.changeDlgLang(_incrementFindDlg.getHSelf(), "IncrementalFind");
1084  				isFirstTime = false;
1085  			}
1086  			_pEditView->getGenericSelectedText(str, strSize, false);
1087  			if (0 != str[0])         
1088  				_incrementFindDlg.setSearchText(str, _pEditView->getCurrentBuffer()->getUnicodeMode() != uni8Bit);
1089  			_incrementFindDlg.display();
1090  		}
1091  		break;
1092  		case IDM_SEARCH_FINDNEXT :
1093  		case IDM_SEARCH_FINDPREV :
1094  		{
1095  			if (_findReplaceDlg.isCreated())
1096  			{
1097  				FindOption op = _findReplaceDlg.getCurrentOptions();
1098  				NppParameters& nppParams = NppParameters::getInstance();
1099  				if ((id == IDM_SEARCH_FINDPREV) && (op._searchType == FindRegex) && !nppParams.regexBackward4PowerUser())
1100  				{
1101  				}
1102  				else
1103  				{
1104  					op._whichDirection = (id == IDM_SEARCH_FINDNEXT ? DIR_DOWN : DIR_UP);
1105  					generic_string s = _findReplaceDlg.getText2search();
1106  					FindStatus status = FSNoMessage;
1107  					_findReplaceDlg.processFindNext(s.c_str(), &op, &status);
1108  					if (status == FSEndReached)
1109  					{
1110  						generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-end-reached", TEXT("Find: Found the 1st occurrence from the top. The end of the document has been reached."));
1111  						_findReplaceDlg.setStatusbarMessage(msg, FSEndReached);
1112  					}
1113  					else if (status == FSTopReached)
1114  					{
1115  						generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-top-reached", TEXT("Find: Found the 1st occurrence from the bottom. The beginning of the document has been reached."));
1116  						_findReplaceDlg.setStatusbarMessage(msg, FSTopReached);
1117  					}
1118  				}
1119  			}
1120  		}
1121  		break;
1122          case IDM_SEARCH_SETANDFINDNEXT :
1123  		case IDM_SEARCH_SETANDFINDPREV :
1124          {
1125              bool isFirstTime = !_findReplaceDlg.isCreated();
1126  			if (isFirstTime)
1127  				_findReplaceDlg.doDialog(FIND_DLG, _nativeLangSpeaker.isRTL(), false);
1128  			const int strSize = FINDREPLACE_MAXLENGTH;
1129  			TCHAR str[strSize] = { '\0' };
1130  			_pEditView->getGenericSelectedText(str, strSize);
1131  			_findReplaceDlg.setSearchText(str);
1132  			_findReplaceDlg._env->_str2Search = str;
1133  			setFindReplaceFolderFilter(NULL, NULL);
1134  			if (isFirstTime)
1135  				_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
1136  			FindOption op = _findReplaceDlg.getCurrentOptions();
1137  			op._searchType = FindNormal;
1138  			op._whichDirection = (id == IDM_SEARCH_SETANDFINDNEXT?DIR_DOWN:DIR_UP);
1139  			FindStatus status = FSNoMessage;
1140  			_findReplaceDlg.processFindNext(str, &op, &status);
1141  			if (status == FSEndReached)
1142  			{
1143  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-end-reached", TEXT("Find: Found the 1st occurrence from the top. The end of the document has been reached."));
1144  				_findReplaceDlg.setStatusbarMessage(msg, FSEndReached);
1145  			}
1146  			else if (status == FSTopReached)
1147  			{
1148  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-top-reached", TEXT("Find: Found the 1st occurrence from the bottom. The beginning of the document has been reached."));
1149  				_findReplaceDlg.setStatusbarMessage(msg, FSTopReached);
1150  			}
1151          }
1152  		break;
1153  		case IDM_SEARCH_GOTONEXTFOUND:
1154  		{
1155  			_findReplaceDlg.gotoNextFoundResult();
1156  		}
1157  		break;
1158  		case IDM_SEARCH_GOTOPREVFOUND:
1159  		{
1160  			_findReplaceDlg.gotoNextFoundResult(-1);
1161  		}
1162  		break;
1163  		case IDM_FOCUS_ON_FOUND_RESULTS:
1164  		{
1165  			if (GetFocus() == _findReplaceDlg.getHFindResults())
1166  				switchEditViewTo(currentView());
1167  			else
1168  				_findReplaceDlg.focusOnFinder();
1169  		}
1170  		break;
1171  		case IDM_SEARCH_VOLATILE_FINDNEXT :
1172  		case IDM_SEARCH_VOLATILE_FINDPREV :
1173  		{
1174  			const int strSize = FINDREPLACE_MAXLENGTH;
1175  			TCHAR str[strSize] = { '\0' };
1176  			_pEditView->getGenericSelectedText(str, strSize);
1177  			FindOption op;
1178  			op._isMatchCase = false;
1179  			op._isWholeWord = false;
1180  			op._isWrapAround = true;
1181  			op._searchType = FindNormal;
1182  			op._whichDirection = (id == IDM_SEARCH_VOLATILE_FINDNEXT ? DIR_DOWN : DIR_UP);
1183  			FindStatus status = FSNoMessage;
1184  			_findReplaceDlg.processFindNext(str, &op, &status);
1185  			if (status == FSEndReached)
1186  			{
1187  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-end-reached", TEXT("Find: Found the 1st occurrence from the top. The end of the document has been reached."));
1188  				_findReplaceDlg.setStatusbarMessage(msg, FSEndReached);
1189  			}
1190  			else if (status == FSTopReached)
1191  			{
1192  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-top-reached", TEXT("Find: Found the 1st occurrence from the bottom. The beginning of the document has been reached."));
1193  				_findReplaceDlg.setStatusbarMessage(msg, FSTopReached);
1194  			}
1195  		}
1196  		break;
1197  		case IDM_SEARCH_MARKALLEXT1 :
1198  		case IDM_SEARCH_MARKALLEXT2 :
1199  		case IDM_SEARCH_MARKALLEXT3 :
1200  		case IDM_SEARCH_MARKALLEXT4 :
1201  		case IDM_SEARCH_MARKALLEXT5 :
1202  		{
1203  			int styleID;
1204  			if (id == IDM_SEARCH_MARKALLEXT1)
1205  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1206  			else if (id == IDM_SEARCH_MARKALLEXT2)
1207  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1208  			else if (id == IDM_SEARCH_MARKALLEXT3)
1209  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1210  			else if (id == IDM_SEARCH_MARKALLEXT4)
1211  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1212  			else 
1213  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1214  			const int strSize = FINDREPLACE_MAXLENGTH;
1215  			TCHAR selectedText[strSize] = { '\0' };
1216  			TCHAR wordOnCaret[strSize] = { '\0' };
1217  			_pEditView->getGenericSelectedText(selectedText, strSize, false);
1218  			_pEditView->getGenericWordOnCaretPos(wordOnCaret, strSize);
1219  			if (selectedText[0] == '\0')
1220  			{
1221  				if (lstrlen(wordOnCaret) > 0)
1222  				{
1223  					_findReplaceDlg.markAll(wordOnCaret, styleID);
1224  				}
1225  			}
1226  			else
1227  			{
1228  				_findReplaceDlg.markAll(selectedText, styleID);
1229  			}
1230  		}
1231  		break;
1232  		case IDM_SEARCH_MARKONEEXT1:
1233  		case IDM_SEARCH_MARKONEEXT2:
1234  		case IDM_SEARCH_MARKONEEXT3:
1235  		case IDM_SEARCH_MARKONEEXT4:
1236  		case IDM_SEARCH_MARKONEEXT5:
1237  		{
1238  			int styleID;
1239  			if (id == IDM_SEARCH_MARKONEEXT1)
1240  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1241  			else if (id == IDM_SEARCH_MARKONEEXT2)
1242  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1243  			else if (id == IDM_SEARCH_MARKONEEXT3)
1244  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1245  			else if (id == IDM_SEARCH_MARKONEEXT4)
1246  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1247  			else 
1248  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1249  			Sci_CharacterRangeFull range = _pEditView->getSelection();
1250  			if (range.cpMin == range.cpMax)
1251  			{
1252  				auto caretPos = _pEditView->execute(SCI_GETCURRENTPOS, 0, 0);
1253  				range.cpMin = _pEditView->execute(SCI_WORDSTARTPOSITION, caretPos, true);
1254  				range.cpMax = _pEditView->execute(SCI_WORDENDPOSITION, caretPos, true);
1255  			}
1256  			if (range.cpMax > range.cpMin)
1257  			{
1258  				_pEditView->execute(SCI_SETINDICATORCURRENT, styleID);
1259  				_pEditView->execute(SCI_INDICATORFILLRANGE, range.cpMin, range.cpMax - range.cpMin);
1260  			}
1261  		}
1262  		break;
1263  		case IDM_SEARCH_UNMARKALLEXT1 :
1264  		case IDM_SEARCH_UNMARKALLEXT2 :
1265  		case IDM_SEARCH_UNMARKALLEXT3 :
1266  		case IDM_SEARCH_UNMARKALLEXT4 :
1267  		case IDM_SEARCH_UNMARKALLEXT5 :
1268  		{
1269  			int styleID;
1270  			if (id == IDM_SEARCH_UNMARKALLEXT1)
1271  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1272  			else if (id == IDM_SEARCH_UNMARKALLEXT2)
1273  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1274  			else if (id == IDM_SEARCH_UNMARKALLEXT3)
1275  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1276  			else if (id == IDM_SEARCH_UNMARKALLEXT4)
1277  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1278  			else 
1279  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1280  			_pEditView->clearIndicator(styleID);
1281  		}
1282  		break;
1283  		case IDM_SEARCH_GONEXTMARKER1 :
1284  		case IDM_SEARCH_GONEXTMARKER2 :
1285  		case IDM_SEARCH_GONEXTMARKER3 :
1286  		case IDM_SEARCH_GONEXTMARKER4 :
1287  		case IDM_SEARCH_GONEXTMARKER5 :
1288  		case IDM_SEARCH_GONEXTMARKER_DEF :
1289  		{
1290  			int styleID;
1291  			if (id == IDM_SEARCH_GONEXTMARKER1)
1292  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1293  			else if (id == IDM_SEARCH_GONEXTMARKER2)
1294  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1295  			else if (id == IDM_SEARCH_GONEXTMARKER3)
1296  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1297  			else if (id == IDM_SEARCH_GONEXTMARKER4)
1298  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1299  			else if (id == IDM_SEARCH_GONEXTMARKER5)
1300  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1301  			else 
1302  				styleID = SCE_UNIVERSAL_FOUND_STYLE;
1303  			goToNextIndicator(styleID);
1304  		}
1305  		break;
1306  		case IDM_SEARCH_GOPREVMARKER1 :
1307  		case IDM_SEARCH_GOPREVMARKER2 :
1308  		case IDM_SEARCH_GOPREVMARKER3 :
1309  		case IDM_SEARCH_GOPREVMARKER4 :
1310  		case IDM_SEARCH_GOPREVMARKER5 :
1311  		case IDM_SEARCH_GOPREVMARKER_DEF :
1312  		{
1313  			int styleID;
1314  			if (id == IDM_SEARCH_GOPREVMARKER1)
1315  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1316  			else if (id == IDM_SEARCH_GOPREVMARKER2)
1317  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1318  			else if (id == IDM_SEARCH_GOPREVMARKER3)
1319  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1320  			else if (id == IDM_SEARCH_GOPREVMARKER4)
1321  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1322  			else if (id == IDM_SEARCH_GOPREVMARKER5)
1323  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1324  			else 
1325  				styleID = SCE_UNIVERSAL_FOUND_STYLE;
1326  			goToPreviousIndicator(styleID);	
1327  		}
1328  		break;
1329  		case IDM_SEARCH_CLEARALLMARKS :
1330  		{
1331  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT1);
1332  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT2);
1333  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT3);
1334  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT4);
1335  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT5);
1336  		}
1337  		break;
1338  		case IDM_SEARCH_STYLE1TOCLIP:
1339  		{
1340  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT1);
1341  		}
1342  		break;
1343  		case IDM_SEARCH_STYLE2TOCLIP:
1344  		{
1345  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT2);
1346  		}
1347  		break;
1348  		case IDM_SEARCH_STYLE3TOCLIP:
1349  		{
1350  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT3);
1351  		}
1352  		break;
1353  		case IDM_SEARCH_STYLE4TOCLIP:
1354  		{
1355  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT4);
1356  		}
1357  		break;
1358  		case IDM_SEARCH_STYLE5TOCLIP:
1359  		{
1360  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT5);
1361  		}
1362  		break;
1363  		case IDM_SEARCH_ALLSTYLESTOCLIP:
1364  		{
1365  			_pEditView->markedTextToClipboard(-1, true);
1366  		}
1367  		break;
1368  		case IDM_SEARCH_MARKEDTOCLIP:
1369  		{
1370  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE);
1371  		}
1372  		break;
1373  		case IDM_SEARCH_GOTOLINE:
1374  		{
1375  			bool isFirstTime = !_goToLineDlg.isCreated();
1376  			_goToLineDlg.doDialog(_nativeLangSpeaker.isRTL());
1377  			if (isFirstTime)
1378  				_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
1379  		}
1380  		break;
1381  		case IDM_SEARCH_FINDCHARINRANGE :
1382  		{
1383  			bool isFirstTime = !_findCharsInRangeDlg.isCreated();
1384  			_findCharsInRangeDlg.doDialog(_nativeLangSpeaker.isRTL());
1385  			if (isFirstTime)
1386  				_nativeLangSpeaker.changeDlgLang(_findCharsInRangeDlg.getHSelf(), "FindCharsInRange");
1387  		}
1388  		break;
1389          case IDM_EDIT_COLUMNMODETIP :
1390  		{
1391  			_nativeLangSpeaker.messageBox("ColumnModeTip",
1392  					_pPublicInterface->getHSelf(),
1393  					TEXT("There are 3 ways to switch to column-select mode:\r\n\r\n")
1394  					TEXT("1. (Keyboard and Mouse)  Hold Alt while left-click dragging\r\n\r\n")
1395  					TEXT("2. (Keyboard only)  Hold Alt+Shift while using arrow keys\r\n\r\n")
1396  					TEXT("3. (Keyboard or Mouse)\r\n")
1397  					TEXT("      Put caret at desired start of column block position, then\r\n")
1398  					TEXT("       execute \"Begin/End Select in Column Mode\" command;\r\n")
1399  					TEXT("      Move caret to desired end of column block position, then\r\n")
1400  					TEXT("       execute \"Begin/End Select in Column Mode\" command again\r\n"),
1401  					TEXT("Column Mode Tip"),
1402  					MB_OK|MB_APPLMODAL);
1403  		}
1404  		break;
1405          case IDM_EDIT_COLUMNMODE :
1406  		{
1407  			bool isFirstTime = !_colEditorDlg.isCreated();
1408  			_colEditorDlg.doDialog(_nativeLangSpeaker.isRTL());
1409  			if (isFirstTime)
1410  				_nativeLangSpeaker.changeDlgLang(_colEditorDlg.getHSelf(), "ColumnEditor");
1411  		}
1412  		break;
1413  		case IDM_SEARCH_GOTOMATCHINGBRACE :
1414  		case IDM_SEARCH_SELECTMATCHINGBRACES :
1415  		{
1416  			intptr_t braceAtCaret = -1;
1417  			intptr_t braceOpposite = -1;
1418  			findMatchingBracePos(braceAtCaret, braceOpposite);
1419  			if (braceOpposite != -1)
1420  			{
1421  				if (id == IDM_SEARCH_GOTOMATCHINGBRACE)
1422  					_pEditView->execute(SCI_GOTOPOS, braceOpposite);
1423  				else
1424  					_pEditView->execute(SCI_SETSEL, std::min<intptr_t>(braceAtCaret, braceOpposite), std::max<intptr_t>(braceAtCaret, braceOpposite) + 1); 
1425  				_pEditView->execute(SCI_CHOOSECARETX);
1426  			}
1427  		}
1428  		break;
1429          case IDM_SEARCH_TOGGLE_BOOKMARK :
1430  	        bookmarkToggle(-1);
1431              break;
1432  	    case IDM_SEARCH_NEXT_BOOKMARK:
1433  		    bookmarkNext(true);
1434  		    break;
1435  	    case IDM_SEARCH_PREV_BOOKMARK:
1436  		    bookmarkNext(false);
1437  		    break;
1438  	    case IDM_SEARCH_CLEAR_BOOKMARKS:
1439  			bookmarkClearAll();
1440  		    break;
1441          case IDM_LANG_USER_DLG :
1442          {
1443  		    bool isUDDlgVisible = false;
1444  		    UserDefineDialog *udd = _pEditView->getUserDefineDlg();
1445  		    if (!udd->isCreated())
1446  		    {
1447  			    _pEditView->doUserDefineDlg(true, _nativeLangSpeaker.isRTL());
1448  				_nativeLangSpeaker.changeUserDefineLang(udd);
1449  				if (_isUDDocked)
1450  					::SendMessage(udd->getHSelf(), WM_COMMAND, IDC_DOCK_BUTTON, 0);
1451  		    }
1452  			else
1453  			{
1454  				isUDDlgVisible = udd->isVisible();
1455  				bool isUDDlgDocked = udd->isDocked();
1456  				if ((isUDDlgDocked)&&(isUDDlgVisible))
1457  				{
1458  					::ShowWindow(_pMainSplitter->getHSelf(), SW_HIDE);
1459  					if (bothActive())
1460  						_pMainWindow = &_subSplitter;
1461  					else
1462  						_pMainWindow = _pDocTab;
1463  					::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1464  					udd->display(false);
1465  					_mainWindowStatus &= ~WindowUserActive;
1466  				}
1467  				else if ((isUDDlgDocked)&&(!isUDDlgVisible))
1468  				{
1469                      if (!_pMainSplitter)
1470                      {
1471                          _pMainSplitter = new SplitterContainer;
1472                          _pMainSplitter->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
1473                          Window *pWindow;
1474                          if (bothActive())
1475                              pWindow = &_subSplitter;
1476                          else
1477                              pWindow = _pDocTab;
1478  						int splitterSizeDyn = NppParameters::getInstance()._dpiManager.scaleX(splitterSize);
1479                          _pMainSplitter->create(pWindow, ScintillaEditView::getUserDefineDlg(), splitterSizeDyn, SplitterMode::RIGHT_FIX, 45);
1480                      }
1481  					_pMainWindow = _pMainSplitter;
1482  					_pMainSplitter->setWin0((bothActive())?(Window *)&_subSplitter:(Window *)_pDocTab);
1483  					::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1484  					_pMainWindow->display();
1485  					_mainWindowStatus |= WindowUserActive;
1486  				}
1487  				else if ((!isUDDlgDocked)&&(isUDDlgVisible))
1488  				{
1489  					udd->display(false);
1490  				}
1491  				else 
1492  					udd->display();
1493  			}
1494  			checkMenuItem(IDM_LANG_USER_DLG, !isUDDlgVisible);
1495  			_toolBar.setCheck(IDM_LANG_USER_DLG, !isUDDlgVisible);
1496          }
1497  		break;
1498  		case IDM_EDIT_SELECTALL:
1499  			_pEditView->execute(SCI_SELECTALL);
1500  			checkClipboard();
1501  			break;
1502  		case IDM_EDIT_INS_TAB:
1503  		case IDM_EDIT_RMV_TAB:
1504  		{
1505  			bool forwards = id == IDM_EDIT_INS_TAB;
1506  			size_t selStartPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1507  			size_t lineNumber = _pEditView->execute(SCI_LINEFROMPOSITION, selStartPos);
1508  			size_t numSelections = _pEditView->execute(SCI_GETSELECTIONS);
1509  			size_t selEndPos = _pEditView->execute(SCI_GETSELECTIONEND);
1510  			size_t selEndLineNumber = _pEditView->execute(SCI_LINEFROMPOSITION, selEndPos);
1511  			if ((numSelections > 1) || (lineNumber != selEndLineNumber))
1512  			{
1513  				_pEditView->execute(forwards ? SCI_TAB : SCI_BACKTAB);
1514  			}
1515  			else
1516  			{
1517  				size_t currentIndent = _pEditView->execute(SCI_GETLINEINDENTATION, lineNumber);
1518  				intptr_t indentDelta = _pEditView->execute(SCI_GETTABWIDTH);
1519  				if (!forwards) indentDelta = -indentDelta;
1520  				_pEditView->setLineIndent(lineNumber, static_cast<intptr_t>(currentIndent) + indentDelta);
1521  			}
1522  		}
1523  		break;
1524  		case IDM_EDIT_DUP_LINE:
1525  			_pEditView->execute(SCI_LINEDUPLICATE);
1526  			break;
1527  		case IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES:
1528  			_pEditView->execute(SCI_BEGINUNDOACTION);
1529  			removeDuplicateLines();
1530  			_pEditView->execute(SCI_ENDUNDOACTION);
1531  			break;
1532  		case IDM_EDIT_REMOVE_ANY_DUP_LINES:
1533  			_pEditView->execute(SCI_BEGINUNDOACTION);
1534  			_pEditView->removeAnyDuplicateLines();
1535  			_pEditView->execute(SCI_ENDUNDOACTION);
1536  			break;
1537  		case IDM_EDIT_SPLIT_LINES:
1538  		{
1539  			if (_pEditView->execute(SCI_GETSELECTIONS) == 1)
1540  			{
1541  				pair<size_t, size_t> lineRange = _pEditView->getSelectionLinesRange();
1542  				auto anchorPos = _pEditView->execute(SCI_POSITIONFROMLINE, lineRange.first);
1543  				auto caretPos = _pEditView->execute(SCI_GETLINEENDPOSITION, lineRange.second);
1544  				_pEditView->execute(SCI_SETSELECTION, caretPos, anchorPos);
1545  				_pEditView->execute(SCI_TARGETFROMSELECTION);
1546  				size_t edgeMode = _pEditView->execute(SCI_GETEDGEMODE);
1547  				if (edgeMode == EDGE_NONE)
1548  				{
1549  					_pEditView->execute(SCI_LINESSPLIT, 0);
1550  				}
1551  				else
1552  				{
1553  					auto textWidth = _pEditView->execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
1554  					auto edgeCol = _pEditView->execute(SCI_GETEDGECOLUMN); 
1555  					if (edgeMode == EDGE_MULTILINE)
1556  					{
1557  						NppParameters& nppParam = NppParameters::getInstance();
1558  						ScintillaViewParams& svp = const_cast<ScintillaViewParams&>(nppParam.getSVP());
1559  						edgeCol = svp._edgeMultiColumnPos.back();  
1560  					}
1561  					++edgeCol;  
1562  					_pEditView->execute(SCI_LINESSPLIT, textWidth * edgeCol);
1563  				}
1564  			}
1565  		}
1566  		break;
1567  		case IDM_EDIT_JOIN_LINES:
1568  		{
1569  			const pair<size_t, size_t> lineRange = _pEditView->getSelectionLinesRange();
1570  			if (lineRange.first != lineRange.second)
1571  			{
1572  				auto anchorPos = _pEditView->execute(SCI_POSITIONFROMLINE, lineRange.first);
1573  				auto caretPos = _pEditView->execute(SCI_GETLINEENDPOSITION, lineRange.second);
1574  				_pEditView->execute(SCI_SETSELECTION, caretPos, anchorPos);
1575  				_pEditView->execute(SCI_TARGETFROMSELECTION);
1576  				_pEditView->execute(SCI_LINESJOIN);
1577  			}
1578  		}
1579  		break;
1580  		case IDM_EDIT_LINE_UP:
1581  			_pEditView->currentLinesUp();
1582  			break;
1583  		case IDM_EDIT_LINE_DOWN:
1584  			_pEditView->currentLinesDown();
1585  			break;
1586  		case IDM_EDIT_REMOVEEMPTYLINES:
1587  			_pEditView->execute(SCI_BEGINUNDOACTION);
1588  			removeEmptyLine(false);
1589  			_pEditView->execute(SCI_ENDUNDOACTION);
1590  			break;
1591  		case IDM_EDIT_REMOVEEMPTYLINESWITHBLANK:
1592  			_pEditView->execute(SCI_BEGINUNDOACTION);
1593  			removeEmptyLine(true);
1594  			_pEditView->execute(SCI_ENDUNDOACTION);
1595  			break;
1596  		case IDM_EDIT_UPPERCASE:
1597              _pEditView->convertSelectedTextToUpperCase();
1598  			break;
1599  		case IDM_EDIT_LOWERCASE:
1600              _pEditView->convertSelectedTextToLowerCase();
1601  			break;
1602  		case IDM_EDIT_PROPERCASE_FORCE:
1603  			_pEditView->convertSelectedTextToNewerCase(TITLECASE_FORCE);
1604  			break;
1605  		case IDM_EDIT_PROPERCASE_BLEND:
1606  			_pEditView->convertSelectedTextToNewerCase(TITLECASE_BLEND);
1607  			break;
1608  		case IDM_EDIT_SENTENCECASE_FORCE:
1609  			_pEditView->convertSelectedTextToNewerCase(SENTENCECASE_FORCE);
1610  			break;
1611  		case IDM_EDIT_SENTENCECASE_BLEND:
1612  			_pEditView->convertSelectedTextToNewerCase(SENTENCECASE_BLEND);
1613  			break;
1614  		case IDM_EDIT_INVERTCASE:
1615  			_pEditView->convertSelectedTextToNewerCase(INVERTCASE);
1616  			break;
1617  		case IDM_EDIT_RANDOMCASE:
1618  			_pEditView->convertSelectedTextToNewerCase(RANDOMCASE);
1619  			break;
1620  		case IDM_EDIT_BLOCK_COMMENT:
1621  			doBlockComment(cm_toggle);
1622   			break;
1623  		case IDM_EDIT_BLOCK_COMMENT_SET:
1624  			doBlockComment(cm_comment);
1625  			break;
1626  		case IDM_EDIT_BLOCK_UNCOMMENT:
1627  			doBlockComment(cm_uncomment);
1628  			break;
1629  		case IDM_EDIT_STREAM_COMMENT:
1630  			doStreamComment();
1631  			break;
1632  		case IDM_EDIT_STREAM_UNCOMMENT:
1633  			undoStreamComment();
1634  			break;
1635  		case IDM_EDIT_TRIMTRAILING:
1636  		{
1637  			std::lock_guard<std::mutex> lock(command_mutex);
1638  			_pEditView->execute(SCI_BEGINUNDOACTION);
1639  			doTrim(lineTail);
1640  			_pEditView->execute(SCI_ENDUNDOACTION);
1641  			break;
1642  		}
1643  		case IDM_EDIT_TRIMLINEHEAD:
1644  		{
1645  			std::lock_guard<std::mutex> lock(command_mutex);
1646  			_pEditView->execute(SCI_BEGINUNDOACTION);
1647  			doTrim(lineHeader);
1648  			_pEditView->execute(SCI_ENDUNDOACTION);
1649  			break;
1650  		}
1651  		case IDM_EDIT_TRIM_BOTH:
1652  		{
1653  			std::lock_guard<std::mutex> lock(command_mutex);
1654  			_pEditView->execute(SCI_BEGINUNDOACTION);
1655  			doTrim(lineBoth);
1656  			_pEditView->execute(SCI_ENDUNDOACTION);
1657  			break;
1658  		}
1659  		case IDM_EDIT_EOL2WS:
1660  			_pEditView->execute(SCI_BEGINUNDOACTION);
1661  			eol2ws();
1662  			_pEditView->execute(SCI_ENDUNDOACTION);
1663  			break;
1664  		case IDM_EDIT_TRIMALL:
1665  		{
1666  			std::lock_guard<std::mutex> lock(command_mutex);
1667  			_pEditView->execute(SCI_BEGINUNDOACTION);
1668  			bool isEntireDoc = _pEditView->execute(SCI_GETANCHOR) == _pEditView->execute(SCI_GETCURRENTPOS);
1669  			doTrim(lineBoth);
1670  			if (isEntireDoc || _pEditView->execute(SCI_GETANCHOR) != _pEditView->execute(SCI_GETCURRENTPOS))
1671  				eol2ws();
1672  			_pEditView->execute(SCI_ENDUNDOACTION);
1673  			break;
1674  		}
1675  		case IDM_EDIT_TAB2SW:
1676  			wsTabConvert(tab2Space);
1677  			break;
1678  		case IDM_EDIT_SW2TAB_LEADING:
1679  			wsTabConvert(space2TabLeading);
1680  			break;
1681  		case IDM_EDIT_SW2TAB_ALL:
1682  			wsTabConvert(space2TabAll);
1683  			break;
1684  		case IDM_EDIT_SETREADONLY:
1685  		{
1686  			Buffer * buf = _pEditView->getCurrentBuffer();
1687  			buf->setUserReadOnly(!buf->getUserReadOnly());
1688  		}
1689  		break;
1690  		case IDM_EDIT_CLEARREADONLY:
1691  		{
1692  			Buffer * buf = _pEditView->getCurrentBuffer();
1693  			DWORD dwFileAttribs = ::GetFileAttributes(buf->getFullPathName());
1694  			dwFileAttribs &= ~FILE_ATTRIBUTE_READONLY;
1695  			::SetFileAttributes(buf->getFullPathName(), dwFileAttribs);
1696  			buf->setFileReadOnly(false);
1697  		}
1698  		break;
1699  		case IDM_SEARCH_CUTMARKEDLINES :
1700  			cutMarkedLines();
1701  			break;
1702  		case IDM_SEARCH_COPYMARKEDLINES :
1703  			copyMarkedLines();
1704  			break;
1705  		case IDM_SEARCH_PASTEMARKEDLINES :
1706  			pasteToMarkedLines();
1707  			break;
1708  		case IDM_SEARCH_DELETEMARKEDLINES :
1709  			deleteMarkedLines(true);
1710  			break;
1711  		case IDM_SEARCH_DELETEUNMARKEDLINES :
1712  			deleteMarkedLines(false);
1713  			break;
1714  		case IDM_SEARCH_INVERSEMARKS :
1715  			inverseMarks();
1716  			break;
1717  	    case IDM_VIEW_ALWAYSONTOP:
1718  		{
1719  			int check = (::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED)?MF_UNCHECKED:MF_CHECKED;
1720  			::CheckMenuItem(_mainMenuHandle, id, MF_BYCOMMAND | check);
1721  			SetWindowPos(_pPublicInterface->getHSelf(), check == MF_CHECKED?HWND_TOPMOST:HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
1722  		}
1723  		break;
1724  		case IDM_VIEW_FOLD_CURRENT:
1725  		case IDM_VIEW_UNFOLD_CURRENT:
1726  		{
1727  			bool isToggleEnabled = NppParameters::getInstance().getNppGUI()._enableFoldCmdToggable;
1728  			bool mode = id == IDM_VIEW_FOLD_CURRENT ? fold_collapse : fold_uncollapse;
1729  			if (isToggleEnabled)
1730  			{
1731  				bool isFolded = _pEditView->isCurrentLineFolded();
1732  				mode = isFolded ? fold_uncollapse : fold_collapse;
1733  			}
1734  			_pEditView->foldCurrentPos(mode);
1735  		}
1736  		break;
1737  		case IDM_VIEW_FOLDALL:
1738  		case IDM_VIEW_UNFOLDALL:
1739  		{
1740  			_isFolding = true; 
1741  			bool doCollapse = (id==IDM_VIEW_FOLDALL)?fold_collapse:fold_uncollapse;
1742   			_pEditView->foldAll(doCollapse);
1743  			if (_pDocMap)
1744  			{
1745  				_pDocMap->foldAll(doCollapse);
1746  			}
1747  			_isFolding = false;
1748  		}
1749  		break;
1750  		case IDM_VIEW_FOLD_1:
1751  		case IDM_VIEW_FOLD_2:
1752  		case IDM_VIEW_FOLD_3:
1753  		case IDM_VIEW_FOLD_4:
1754  		case IDM_VIEW_FOLD_5:
1755  		case IDM_VIEW_FOLD_6:
1756  		case IDM_VIEW_FOLD_7:
1757  		case IDM_VIEW_FOLD_8:
1758  			_isFolding = true; 
1759   			_pEditView->collapse(id - IDM_VIEW_FOLD - 1, fold_collapse);
1760  			_isFolding = false;
1761  			break;
1762  		case IDM_VIEW_UNFOLD_1:
1763  		case IDM_VIEW_UNFOLD_2:
1764  		case IDM_VIEW_UNFOLD_3:
1765  		case IDM_VIEW_UNFOLD_4:
1766  		case IDM_VIEW_UNFOLD_5:
1767  		case IDM_VIEW_UNFOLD_6:
1768  		case IDM_VIEW_UNFOLD_7:
1769  		case IDM_VIEW_UNFOLD_8:
1770  			_isFolding = true; 
1771   			_pEditView->collapse(id - IDM_VIEW_UNFOLD - 1, fold_uncollapse);
1772  			_isFolding = false;
1773  			break;
1774  		case IDM_VIEW_TOOLBAR_REDUCE:
1775  		{
1776              toolBarStatusType state = _toolBar.getState();
1777              if (state != TB_SMALL)
1778              {
1779  			    _toolBar.reduce();
1780              }
1781  		}
1782  		break;
1783  		case IDM_VIEW_TOOLBAR_ENLARGE:
1784  		{
1785              toolBarStatusType state = _toolBar.getState();
1786              if (state != TB_LARGE)
1787              {
1788  			    _toolBar.enlarge();
1789              }
1790  		}
1791  		break;
1792  		case IDM_VIEW_TOOLBAR_REDUCE_SET2:
1793  		{
1794  			toolBarStatusType state = _toolBar.getState();
1795  			if (state != TB_SMALL2)
1796  			{
1797  				_toolBar.reduceToSet2();
1798  			}
1799  		}
1800  		break;
1801  		case IDM_VIEW_TOOLBAR_ENLARGE_SET2:
1802  		{
1803  			toolBarStatusType state = _toolBar.getState();
1804  			if (state != TB_LARGE2)
1805  			{
1806  				_toolBar.enlargeToSet2();
1807  			}
1808  		}
1809  		break;
1810  		case IDM_VIEW_TOOLBAR_STANDARD:
1811  		{
1812  			toolBarStatusType state = _toolBar.getState();
1813              if (state != TB_STANDARD)
1814              {
1815  				_toolBar.setToBmpIcons();
1816  			}
1817  		}
1818  		break;
1819  		case IDM_VIEW_REDUCETABBAR:
1820  		{
<span onclick='openModal()' class='match'>1821  			_toReduceTabBar = !_toReduceTabBar;
1822  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
1823  			int tabDpiDynamicalWidth = dpiManager.scaleX(g_TabWidth);
1824  			int tabDpiDynamicalHeight = dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
</span>1825  			TabCtrl_SetItemSize(_mainDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1826  			TabCtrl_SetItemSize(_subDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1827  			const auto& hf = _mainDocTab.getFont(_toReduceTabBar);
1828  			if (hf)
1829  			{
1830  				::SendMessage(_mainDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
1831  				::SendMessage(_subDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
1832  			}
1833  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1834  			break;
1835  		}
1836  		case IDM_VIEW_REFRESHTABAR :
1837  		{
1838  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1839  			break;
1840  		}
1841          case IDM_VIEW_LOCKTABBAR:
1842  		{
1843  			bool isDrag = TabBarPlus::doDragNDropOrNot();
1844              TabBarPlus::doDragNDrop(!isDrag);
1845              break;
1846  		}
1847  		case IDM_VIEW_DRAWTABBAR_INACIVETAB:
1848  		{
1849  			TabBarPlus::setDrawInactiveTab(!TabBarPlus::drawInactiveTab());
1850  			break;
1851  		}
1852  		case IDM_VIEW_DRAWTABBAR_TOPBAR:
1853  		{
1854  			TabBarPlus::setDrawTopBar(!TabBarPlus::drawTopBar());
1855  			break;
1856  		}
1857  		case IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN:
1858  		{
1859  			TabBarPlus::setDrawTabCloseButton(!TabBarPlus::drawTabCloseButton());
1860  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
1861  			int tabDpiDynamicalHeight = dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
1862  			int tabDpiDynamicalWidth = dpiManager.scaleX(TabBarPlus::drawTabCloseButton() ? g_TabWidthCloseBtn : g_TabWidth);
1863  			TabCtrl_SetItemSize(_mainDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1864  			TabCtrl_SetItemSize(_subDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1865  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1866  			break;
1867  		}
1868  		case IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE :
1869  		{
1870  			TabBarPlus::setDbClk2Close(!TabBarPlus::isDbClk2Close());
1871  			break;
1872  		}
1873  		case IDM_VIEW_DRAWTABBAR_VERTICAL :
1874  		{
1875  			TabBarPlus::setVertical(!TabBarPlus::isVertical());
1876  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1877  			break;
1878  		}
1879  		case IDM_VIEW_DRAWTABBAR_MULTILINE :
1880  		{
1881  			TabBarPlus::setMultiLine(!TabBarPlus::isMultiLine());
1882  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1883  			break;
1884  		}
1885  		case IDM_VIEW_FULLSCREENTOGGLE:
1886  		{
1887  			if (!_beforeSpecialView._isDistractionFree)
1888  				fullScreenToggle();
1889  		}
1890  		break;
1891  		case IDM_VIEW_POSTIT :
1892  		{
1893  			if (!_beforeSpecialView._isDistractionFree)
1894  				postItToggle();
1895  		}
1896  		break;
1897  		case IDM_VIEW_DISTRACTIONFREE:
1898  		{
1899  			if ((_beforeSpecialView._isDistractionFree && _beforeSpecialView._isFullScreen && _beforeSpecialView._isPostIt) ||
1900  				(!_beforeSpecialView._isDistractionFree && !_beforeSpecialView._isFullScreen && !_beforeSpecialView._isPostIt))
1901  				distractionFreeToggle();
1902  		}
1903  		break;
1904  		case IDM_VIEW_IN_FIREFOX:
1905  		case IDM_VIEW_IN_CHROME:
1906  		case IDM_VIEW_IN_EDGE:
1907  		case IDM_VIEW_IN_IE:
1908  		{
1909  			auto currentBuf = _pEditView->getCurrentBuffer();
1910  			if (!currentBuf->isUntitled())
1911  			{
1912  				generic_string appName;
1913  				if (id == IDM_VIEW_IN_FIREFOX)
1914  				{
1915  					appName = TEXT("firefox.exe");
1916  				}
1917  				else if (id == IDM_VIEW_IN_CHROME)
1918  				{
1919  					appName = TEXT("chrome.exe");
1920  				}
1921  				else if (id == IDM_VIEW_IN_EDGE)
1922  				{
1923  					appName = TEXT("msedge.exe");
1924  				}
1925  				else 
1926  				{
1927  					appName = TEXT("IEXPLORE.EXE");
1928  				}
1929  				TCHAR valData[MAX_PATH] = {'\0'};
1930  				DWORD valDataLen = MAX_PATH * sizeof(TCHAR);
1931  				DWORD valType = 0;
1932  				HKEY hKey2Check = nullptr;
1933  				generic_string appEntry = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
1934  				appEntry += appName;
1935  				::RegOpenKeyEx(HKEY_LOCAL_MACHINE, appEntry.c_str(), 0, KEY_READ, &hKey2Check);
1936  				::RegQueryValueEx(hKey2Check, TEXT(""), nullptr, &valType, reinterpret_cast<LPBYTE>(valData), &valDataLen);
1937  				generic_string fullCurrentPath = TEXT("\"");
1938  				fullCurrentPath += currentBuf->getFullPathName();
1939  				fullCurrentPath += TEXT("\"");
1940  				if (hKey2Check && valData[0] != '\0')
1941  				{
1942  					::ShellExecute(NULL, TEXT("open"), valData, fullCurrentPath.c_str(), NULL, SW_SHOWNORMAL);
1943  				}
1944  				else if (id == IDM_VIEW_IN_EDGE)
1945  				{
1946  					generic_string fullCurrentPath = currentBuf->getFullPathName();
1947  					::ShellExecute(NULL, TEXT("open"), TEXT("shell:Appsfolder\\Microsoft.MicrosoftEdge_8wekyb3d8bbwe!MicrosoftEdge"), fullCurrentPath.c_str(), NULL, SW_SHOW);
1948  				} 
1949  				else 
1950  				{
1951  					_nativeLangSpeaker.messageBox("ViewInBrowser",
1952  						_pPublicInterface->getHSelf(),
1953  						TEXT("Application cannot be found in your system."),
1954  						TEXT("View Current File in Browser"),
1955  						MB_OK);
1956  				}
1957  				::RegCloseKey(hKey2Check);
1958  			}
1959  		}
1960  		break;
1961  		case IDM_VIEW_TAB_SPACE:
1962  		{
1963  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
1964  			checkMenuItem(id, isChecked);
1965  			_mainEditView.showWSAndTab(isChecked);
1966  			_subEditView.showWSAndTab(isChecked);
1967  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
1968  			svp1._whiteSpaceShow = isChecked;
1969  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
1970  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
1971  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
1972  			break;
1973  		}
1974  		case IDM_VIEW_EOL:
1975  		{
1976  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
1977  			checkMenuItem(id, isChecked);
1978  			_mainEditView.showEOL(isChecked);
1979  			_subEditView.showEOL(isChecked);
1980  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
1981  			svp1._eolShow = isChecked;
1982  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
1983  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
1984  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
1985  			break;
1986  		}
1987  		case IDM_VIEW_NPC:
1988  		{
1989  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
1990  			checkMenuItem(id, isChecked);
1991  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
1992  			svp1._npcShow = isChecked;
1993  			_mainEditView.showNpc(isChecked);
1994  			_subEditView.showNpc(isChecked);
1995  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
1996  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
1997  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
1998  			_findReplaceDlg.updateFinderScintillaForNpc();
1999  			break;
2000  		}
2001  		case IDM_VIEW_NPC_CCUNIEOL:
2002  		{
2003  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
2004  			checkMenuItem(id, isChecked);
2005  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
2006  			svp1._ccUniEolShow = isChecked;
2007  			_mainEditView.showCcUniEol(isChecked);
2008  			_subEditView.showCcUniEol(isChecked);
2009  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
2010  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
2011  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
2012  			break;
2013  		}
2014  		case IDM_VIEW_ALL_CHARACTERS:
2015  		{
2016  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
2017  			checkMenuItem(id, isChecked);
2018  			checkMenuItem(IDM_VIEW_TAB_SPACE, isChecked);
2019  			checkMenuItem(IDM_VIEW_EOL, isChecked);
2020  			checkMenuItem(IDM_VIEW_NPC, isChecked);
2021  			checkMenuItem(IDM_VIEW_NPC_CCUNIEOL, isChecked);
2022  			_toolBar.setCheck(id, isChecked);
2023  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
2024  			svp1._whiteSpaceShow = isChecked;
2025  			svp1._eolShow = isChecked;
2026  			svp1._npcShow = isChecked;
2027  			svp1._ccUniEolShow = isChecked;
2028  			_mainEditView.showInvisibleChars(isChecked);
2029  			_subEditView.showInvisibleChars(isChecked);
2030  			_findReplaceDlg.updateFinderScintillaForNpc();
2031  			break;
2032  		}
2033  		case IDM_VIEW_INDENT_GUIDE:
2034  		{
2035  			_mainEditView.showIndentGuideLine(!_pEditView->isShownIndentGuide());
2036  			_subEditView.showIndentGuideLine(!_pEditView->isShownIndentGuide());
2037              _toolBar.setCheck(IDM_VIEW_INDENT_GUIDE, _pEditView->isShownIndentGuide());
2038  			checkMenuItem(IDM_VIEW_INDENT_GUIDE, _pEditView->isShownIndentGuide());
2039              ScintillaViewParams & svp1 = (ScintillaViewParams &)(NppParameters::getInstance()).getSVP();
2040              svp1._indentGuideLineShow = _pEditView->isShownIndentGuide();
2041  			break;
2042  		}
2043  		case IDM_VIEW_WRAP:
2044  		{
2045  			bool isWraped = !_pEditView->isWrap();
2046  			if (!isWraped)
2047  			{
2048  				_mainEditView.saveCurrentPos();
2049  				_mainEditView.setWrapRestoreNeeded(true);
2050  				_subEditView.saveCurrentPos();
2051  				_subEditView.setWrapRestoreNeeded(true);
2052  			}
2053  			_mainEditView.wrap(isWraped);
2054  			_subEditView.wrap(isWraped);
2055  			_toolBar.setCheck(IDM_VIEW_WRAP, isWraped);
2056  			checkMenuItem(IDM_VIEW_WRAP, isWraped);
2057  			ScintillaViewParams & svp1 = (ScintillaViewParams &)(NppParameters::getInstance()).getSVP();
2058  			svp1._doWrap = isWraped;
2059  			if (_pDocMap)
2060  			{
2061  				_pDocMap->initWrapMap();
2062  				_pDocMap->wrapMap();
2063  			}
2064  			break;
2065  		}
2066  		case IDM_VIEW_WRAP_SYMBOL:
2067  		{
2068  			_mainEditView.showWrapSymbol(!_pEditView->isWrapSymbolVisible());
2069  			_subEditView.showWrapSymbol(!_pEditView->isWrapSymbolVisible());
2070  			checkMenuItem(IDM_VIEW_WRAP_SYMBOL, _pEditView->isWrapSymbolVisible());
2071              ScintillaViewParams & svp1 = (ScintillaViewParams &)(NppParameters::getInstance()).getSVP();
2072              svp1._wrapSymbolShow = _pEditView->isWrapSymbolVisible();
2073  			break;
2074  		}
2075  		case IDM_VIEW_HIDELINES:
2076  		{
2077  			_pEditView->hideLines();
2078  			break;
2079  		}
2080  		case IDM_VIEW_ZOOMIN:
2081  		{
2082  			_pEditView->execute(SCI_ZOOMIN);
2083  			break;
2084  		}
2085  		case IDM_VIEW_ZOOMOUT:
2086  			_pEditView->execute(SCI_ZOOMOUT);
2087  			break;
2088  		case IDM_VIEW_ZOOMRESTORE:
2089  			_pEditView->execute(SCI_SETZOOM, 0);
2090  			break;
2091  		case IDM_VIEW_SYNSCROLLV:
2092  		{
2093              bool isSynScollV = !_syncInfo._isSynScollV;
2094  			checkMenuItem(IDM_VIEW_SYNSCROLLV, isSynScollV);
2095  			_toolBar.setCheck(IDM_VIEW_SYNSCROLLV, isSynScollV);
2096              _syncInfo._isSynScollV = isSynScollV;
2097  			if (_syncInfo._isSynScollV)
2098  			{
2099  				intptr_t mainCurrentLine = _mainEditView.execute(SCI_GETFIRSTVISIBLELINE);
2100  				intptr_t subCurrentLine = _subEditView.execute(SCI_GETFIRSTVISIBLELINE);
2101  				_syncInfo._line = mainCurrentLine - subCurrentLine;
2102  			}
2103  		}
2104  		break;
2105  		case IDM_VIEW_SYNSCROLLH:
2106  		{
2107              bool isSynScollH = !_syncInfo._isSynScollH;
2108  			checkMenuItem(IDM_VIEW_SYNSCROLLH, isSynScollH);
2109  			_toolBar.setCheck(IDM_VIEW_SYNSCROLLH, isSynScollH);
2110              _syncInfo._isSynScollH = isSynScollH;
2111  			if (_syncInfo._isSynScollH)
2112  			{
2113  				intptr_t mxoffset = _mainEditView.execute(SCI_GETXOFFSET);
2114  				intptr_t pixel = _mainEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
2115  				intptr_t mainColumn = mxoffset/pixel;
2116  				intptr_t sxoffset = _subEditView.execute(SCI_GETXOFFSET);
2117  				pixel = _subEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
2118  				intptr_t subColumn = sxoffset/pixel;
2119  				_syncInfo._column = mainColumn - subColumn;
2120  			}
2121  		}
2122  		break;
2123  		case IDM_VIEW_SUMMARY:
2124  		{
2125  			generic_string characterNumber = TEXT("");
2126  			Buffer * curBuf = _pEditView->getCurrentBuffer();
2127  			int64_t fileLen = curBuf->getFileLength();
2128  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
2129  			if (pNativeSpeaker)
2130  			{
2131  				if (fileLen != -1)
2132  				{
2133  					generic_string filePathLabel = pNativeSpeaker->getLocalizedStrFromID("summary-filepath", TEXT("Full file path: "));
2134  					generic_string fileCreateTimeLabel = pNativeSpeaker->getLocalizedStrFromID("summary-filecreatetime", TEXT("Created: "));
2135  					generic_string fileModifyTimeLabel = pNativeSpeaker->getLocalizedStrFromID("summary-filemodifytime", TEXT("Modified: "));
2136  					characterNumber += filePathLabel;
2137  					characterNumber += curBuf->getFullPathName();
2138  					characterNumber += TEXT("\r");
2139  					characterNumber += fileCreateTimeLabel;
2140  					characterNumber += curBuf->getFileTime(Buffer::ft_created);
2141  					characterNumber += TEXT("\r");
2142  					characterNumber += fileModifyTimeLabel;
2143  					characterNumber += curBuf->getFileTime(Buffer::ft_modified);
2144  					characterNumber += TEXT("\r");
2145  				}
2146  				generic_string nbCharLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbchar", TEXT("Characters (without line endings): "));
2147  				generic_string nbWordLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbword", TEXT("Words: "));
2148  				generic_string nbLineLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbline", TEXT("Lines: "));
2149  				generic_string nbByteLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbbyte", TEXT("Document length: "));
2150  				generic_string nbSelLabel1 = pNativeSpeaker->getLocalizedStrFromID("summary-nbsel1", TEXT(" selected characters ("));
2151  				generic_string nbSelLabel2 = pNativeSpeaker->getLocalizedStrFromID("summary-nbsel2", TEXT(" bytes) in "));
2152  				generic_string nbRangeLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbrange", TEXT(" ranges"));
2153  				UniMode um = _pEditView->getCurrentBuffer()->getUnicodeMode();
2154  				size_t nbChar = getCurrentDocCharCount(um);
2155  				int nbWord = wordCount();
2156  				size_t nbLine = _pEditView->execute(SCI_GETLINECOUNT);
2157  				size_t nbByte = _pEditView->execute(SCI_GETLENGTH);
2158  				size_t nbSel = getSelectedCharNumber(um);
2159  				size_t nbSelByte = getSelectedBytes();
2160  				size_t nbRange = getSelectedAreas();
2161  				characterNumber += nbCharLabel;
2162  				characterNumber += commafyInt(nbChar).c_str();
2163  				characterNumber += TEXT("\r");
2164  				characterNumber += nbWordLabel;
2165  				characterNumber += commafyInt(nbWord).c_str();
2166  				characterNumber += TEXT("\r");
2167  				characterNumber += nbLineLabel;
2168  				characterNumber += commafyInt(nbLine).c_str();
2169  				characterNumber += TEXT("\r");
2170  				characterNumber += nbByteLabel;
2171  				characterNumber += commafyInt(nbByte).c_str();
2172  				characterNumber += TEXT("\r");
2173  				characterNumber += commafyInt(nbSel).c_str();
2174  				characterNumber += nbSelLabel1;
2175  				characterNumber += commafyInt(nbSelByte).c_str();
2176  				characterNumber += nbSelLabel2;
2177  				characterNumber += commafyInt(nbRange).c_str();
2178  				characterNumber += nbRangeLabel;
2179  				characterNumber += TEXT("\r");
2180  				generic_string summaryLabel = pNativeSpeaker->getLocalizedStrFromID("summary", TEXT("Summary"));
2181  				::MessageBox(_pPublicInterface->getHSelf(), characterNumber.c_str(), summaryLabel.c_str(), MB_OK|MB_APPLMODAL);
2182  			}
2183  		}
2184  		break;
2185  		case IDM_VIEW_MONITORING:
2186  		{
2187  			Buffer * curBuf = _pEditView->getCurrentBuffer();
2188  			if (curBuf->isMonitoringOn())
2189  			{
2190  				monitoringStartOrStopAndUpdateUI(curBuf, false);
2191  			}
2192  			else
2193  			{
2194  				const TCHAR *longFileName = curBuf->getFullPathName();
2195  				if (::PathFileExists(longFileName))
2196  				{
2197  					if (curBuf->isDirty())
2198  					{
2199  						_nativeLangSpeaker.messageBox("DocTooDirtyToMonitor",
2200  							_pPublicInterface->getHSelf(),
2201  							TEXT("The document is dirty. Please save the modification before monitoring it."),
2202  							TEXT("Monitoring problem"),
2203  							MB_OK);
2204  					}
2205  					else
2206  					{
2207  						monitoringStartOrStopAndUpdateUI(curBuf, true);
2208  						createMonitoringThread(curBuf);
2209  					}
2210  				}
2211  				else
2212  				{
2213  					_nativeLangSpeaker.messageBox("DocNoExistToMonitor",
2214  						_pPublicInterface->getHSelf(),
2215  						TEXT("The file should exist to be monitored."),
2216  						TEXT("Monitoring problem"),
2217  						MB_OK);
2218  				}
2219  			}
2220  			break;
2221  		}
2222  		case IDM_EXECUTE:
2223  		{
2224  			bool isFirstTime = !_runDlg.isCreated();
2225  			_runDlg.doDialog(_nativeLangSpeaker.isRTL());
2226  			if (isFirstTime)
2227  				_nativeLangSpeaker.changeDlgLang(_runDlg.getHSelf(), "Run");
2228  			break;
2229  		}
2230  		case IDM_FORMAT_TODOS:
2231  		case IDM_FORMAT_TOUNIX:
2232  		case IDM_FORMAT_TOMAC:
2233  		{
2234  			EolType newFormat = (id == IDM_FORMAT_TODOS)
2235  				? EolType::windows
2236  				: (id == IDM_FORMAT_TOUNIX) ? EolType::unix : EolType::macos;
2237  			Buffer* buf = _pEditView->getCurrentBuffer();
2238  			if (!buf->isReadOnly())
2239  			{
2240  				std::lock_guard<std::mutex> lock(command_mutex);
2241  				buf->setEolFormat(newFormat);
2242  				_pEditView->execute(SCI_CONVERTEOLS, static_cast<int>(buf->getEolFormat()));
2243  			}
2244  			break;
2245  		}
2246  		case IDM_FORMAT_ANSI :
2247  		case IDM_FORMAT_UTF_8 :
2248  		case IDM_FORMAT_UTF_16BE :
2249  		case IDM_FORMAT_UTF_16LE :
2250  		case IDM_FORMAT_AS_UTF_8 :
2251  		{
2252  			Buffer * buf = _pEditView->getCurrentBuffer();
2253  			UniMode um;
2254  			bool shoulBeDirty = true;
2255  			switch (id)
2256  			{
2257  				case IDM_FORMAT_AS_UTF_8:
2258  					shoulBeDirty = buf->getUnicodeMode() != uni8Bit;
2259  					um = uniCookie;
2260  					break;
2261  				case IDM_FORMAT_UTF_8:
2262  					um = uniUTF8;
2263  					break;
2264  				case IDM_FORMAT_UTF_16BE:
2265  					um = uni16BE;
2266  					break;
2267  				case IDM_FORMAT_UTF_16LE:
2268  					um = uni16LE;
2269  					break;
2270  				default : 
2271  					shoulBeDirty = buf->getUnicodeMode() != uniCookie;
2272  					um = uni8Bit;
2273  			}
2274  			if (buf->getEncoding() != -1)
2275  			{
2276  				if (buf->isDirty())
2277  				{
2278  					int answer = _nativeLangSpeaker.messageBox("SaveCurrentModifWarning",
2279  						_pPublicInterface->getHSelf(),
2280  						TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2281  						TEXT("Save Current Modification"),
2282  						MB_YESNO);
2283  					if (answer == IDYES)
2284  					{
2285  						fileSave();
2286  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2287  					}
2288  					else
2289  						return;
2290  				}
2291  				if (_pEditView->execute(SCI_CANUNDO) == TRUE)
2292  				{
2293  					generic_string msg, title;
2294  					int answer = _nativeLangSpeaker.messageBox("LoseUndoAbilityWarning",
2295  						_pPublicInterface->getHSelf(),
2296  						TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2297  						TEXT("Lose Undo Ability Waning"),
2298  						MB_YESNO);
2299  					if (answer == IDYES)
2300  					{
2301  					}
2302  					else
2303  						return;
2304  				}
2305  				buf->setEncoding(-1);
2306  				if (um == uni8Bit)
2307  					_pEditView->execute(SCI_SETCODEPAGE, CP_ACP);
2308  				else
2309  					buf->setUnicodeMode(um);
2310  				fileReload();
2311  			}
2312  			else
2313  			{
2314  				if (buf->getUnicodeMode() != um)
2315  				{
2316  					buf->setUnicodeMode(um);
2317  					if (shoulBeDirty)
2318  						buf->setDirty(true);
2319  				}
2320  			}
2321  			break;
2322  		}
2323          case IDM_FORMAT_WIN_1250 :
2324          case IDM_FORMAT_WIN_1251 :
2325          case IDM_FORMAT_WIN_1252 :
2326          case IDM_FORMAT_WIN_1253 :
2327          case IDM_FORMAT_WIN_1254 :
2328          case IDM_FORMAT_WIN_1255 :
2329          case IDM_FORMAT_WIN_1256 :
2330          case IDM_FORMAT_WIN_1257 :
2331          case IDM_FORMAT_WIN_1258 :
2332          case IDM_FORMAT_ISO_8859_1  :
2333          case IDM_FORMAT_ISO_8859_2  :
2334          case IDM_FORMAT_ISO_8859_3  :
2335          case IDM_FORMAT_ISO_8859_4  :
2336          case IDM_FORMAT_ISO_8859_5  :
2337          case IDM_FORMAT_ISO_8859_6  :
2338          case IDM_FORMAT_ISO_8859_7  :
2339          case IDM_FORMAT_ISO_8859_8  :
2340          case IDM_FORMAT_ISO_8859_9  :
2341          case IDM_FORMAT_ISO_8859_13 :
2342          case IDM_FORMAT_ISO_8859_14 :
2343          case IDM_FORMAT_ISO_8859_15 :
2344          case IDM_FORMAT_DOS_437 :
2345          case IDM_FORMAT_DOS_720 :
2346          case IDM_FORMAT_DOS_737 :
2347          case IDM_FORMAT_DOS_775 :
2348          case IDM_FORMAT_DOS_850 :
2349          case IDM_FORMAT_DOS_852 :
2350          case IDM_FORMAT_DOS_855 :
2351          case IDM_FORMAT_DOS_857 :
2352          case IDM_FORMAT_DOS_858 :
2353          case IDM_FORMAT_DOS_860 :
2354          case IDM_FORMAT_DOS_861 :
2355          case IDM_FORMAT_DOS_862 :
2356          case IDM_FORMAT_DOS_863 :
2357          case IDM_FORMAT_DOS_865 :
2358          case IDM_FORMAT_DOS_866 :
2359          case IDM_FORMAT_DOS_869 :
2360          case IDM_FORMAT_BIG5 :
2361          case IDM_FORMAT_GB2312 :
2362          case IDM_FORMAT_SHIFT_JIS :
2363          case IDM_FORMAT_KOREAN_WIN :
2364          case IDM_FORMAT_EUC_KR :
2365          case IDM_FORMAT_TIS_620 :
2366          case IDM_FORMAT_MAC_CYRILLIC :
2367          case IDM_FORMAT_KOI8U_CYRILLIC :
2368          case IDM_FORMAT_KOI8R_CYRILLIC :
2369          {
2370  			int index = id - IDM_FORMAT_ENCODE;
2371  			EncodingMapper& em = EncodingMapper::getInstance();
2372  			int encoding = em.getEncodingFromIndex(index);
2373  			if (encoding == -1)
2374  			{
2375  				return;
2376  			}
2377              Buffer* buf = _pEditView->getCurrentBuffer();
2378              if (buf->isDirty())
2379              {
2380  				generic_string warning, title;
2381  				int answer = _nativeLangSpeaker.messageBox("SaveCurrentModifWarning",
2382  					_pPublicInterface->getHSelf(),
2383  					TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2384  					TEXT("Save Current Modification"),
2385  					MB_YESNO);
2386                  if (answer == IDYES)
2387                  {
2388                      fileSave();
2389  					_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2390                  }
2391                  else
2392                      return;
2393              }
2394              if (_pEditView->execute(SCI_CANUNDO) == TRUE)
2395              {
2396  				generic_string msg, title;
2397  				int answer = _nativeLangSpeaker.messageBox("LoseUndoAbilityWarning",
2398  					_pPublicInterface->getHSelf(),
2399  					TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2400  					TEXT("Lose Undo Ability Waning"),
2401  					MB_YESNO);
2402                  if (answer != IDYES)
2403                      return;
2404              }
2405              if (!buf->isDirty())
2406              {
2407  				buf->setEncoding(encoding);
2408  				buf->setUnicodeMode(uniCookie);
2409  				fileReload();
2410              }
2411  			break;
2412  		}
2413  		case IDM_FORMAT_CONV2_ANSI:
2414  		case IDM_FORMAT_CONV2_AS_UTF_8:
2415  		case IDM_FORMAT_CONV2_UTF_8:
2416  		case IDM_FORMAT_CONV2_UTF_16BE:
2417  		case IDM_FORMAT_CONV2_UTF_16LE:
2418  		{
2419  			int idEncoding = -1;
2420  			Buffer *buf = _pEditView->getCurrentBuffer();
2421              UniMode um = buf->getUnicodeMode();
2422              int encoding = buf->getEncoding();
2423  			switch(id)
2424  			{
2425  				case IDM_FORMAT_CONV2_ANSI:
2426  				{
2427                      if (encoding != -1)
2428                      {
2429                          return;
2430                      }
2431                      else
2432                      {
2433  					    if (um == uni8Bit)
2434  						    return;
2435  					    idEncoding = IDM_FORMAT_ANSI;
2436                      }
2437  					break;
2438  				}
2439  				case IDM_FORMAT_CONV2_AS_UTF_8:
2440  				{
2441                      if (encoding != -1)
2442                      {
2443                          buf->setDirty(true);
2444                          buf->setUnicodeMode(uniCookie);
2445                          buf->setEncoding(-1);
2446                          return;
2447                      }
2448  					idEncoding = IDM_FORMAT_AS_UTF_8;
2449  					if (um == uniCookie)
2450  						return;
2451  					if (um != uni8Bit)
2452  					{
2453  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2454  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2455  						return;
2456  					}
2457  					break;
2458  				}
2459  				case IDM_FORMAT_CONV2_UTF_8:
2460  				{
2461                      if (encoding != -1)
2462                      {
2463                          buf->setDirty(true);
2464                          buf->setUnicodeMode(uniUTF8);
2465                          buf->setEncoding(-1);
2466                          return;
2467                      }
2468  					idEncoding = IDM_FORMAT_UTF_8;
2469  					if (um == uniUTF8)
2470  						return;
2471  					if (um != uni8Bit)
2472  					{
2473  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2474  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2475  						return;
2476  					}
2477  					break;
2478  				}
2479  				case IDM_FORMAT_CONV2_UTF_16BE:
2480  				{
2481                      if (encoding != -1)
2482                      {
2483                          buf->setDirty(true);
2484                          buf->setUnicodeMode(uni16BE);
2485                          buf->setEncoding(-1);
2486                          return;
2487                      }
2488  					idEncoding = IDM_FORMAT_UTF_16BE;
2489  					if (um == uni16BE)
2490  						return;
2491  					if (um != uni8Bit)
2492  					{
2493  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2494  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2495  						return;
2496  					}
2497  					break;
2498  				}
2499  				case IDM_FORMAT_CONV2_UTF_16LE:
2500  				{
2501                      if (encoding != -1)
2502                      {
2503                          buf->setDirty(true);
2504                          buf->setUnicodeMode(uni16LE);
2505                          buf->setEncoding(-1);
2506                          return;
2507                      }
2508  					idEncoding = IDM_FORMAT_UTF_16LE;
2509  					if (um == uni16LE)
2510  						return;
2511  					if (um != uni8Bit)
2512  					{
2513  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2514  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2515  						return;
2516  					}
2517  					break;
2518  				}
2519  			}
2520  			if (idEncoding != -1)
2521  			{
2522  				::OpenClipboard(_pPublicInterface->getHSelf());
2523  				HANDLE clipboardData = ::GetClipboardData(CF_TEXT);
2524  				int len = static_cast<int32_t>(::GlobalSize(clipboardData));
2525  				LPVOID clipboardDataPtr = ::GlobalLock(clipboardData);
2526  				HANDLE allocClipboardData = ::GlobalAlloc(GMEM_MOVEABLE, len);
2527  				LPVOID clipboardData2 = ::GlobalLock(allocClipboardData);
2528  				::memcpy(clipboardData2, clipboardDataPtr, len);
2529  				::GlobalUnlock(clipboardData);
2530  				::GlobalUnlock(allocClipboardData);
2531  				::CloseClipboard();
2532  				_pEditView->saveCurrentPos();
2533  				size_t docLen = _pEditView->getCurrentDocLen();
2534  				_pEditView->execute(SCI_COPYRANGE, 0, docLen);
2535  				_pEditView->execute(SCI_CLEARALL);
2536  				::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2537  				_pEditView->execute(SCI_PASTE);
2538  				_pEditView->restoreCurrentPosPreStep();
2539  				::OpenClipboard(_pPublicInterface->getHSelf());
2540  				::EmptyClipboard();
2541  				::SetClipboardData(CF_TEXT, clipboardData2);
2542  				::CloseClipboard();
2543  				_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2544  				buf->setSavePointDirty(true);
2545  			}
2546  			break;
2547  		}
2548  		case IDM_SETTING_IMPORTPLUGIN :
2549          {
2550              const TCHAR *extFilterName = TEXT("Notepad++ plugin");
2551              const TCHAR *extFilter = TEXT(".dll");
2552              vector<generic_string> copiedFiles = addNppPlugins(extFilterName, extFilter);
2553  			if (copiedFiles.size())
2554  			{
2555  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
2556  				pNativeSpeaker->messageBox("NeedToRestartToLoadPlugins",
2557  					_pPublicInterface->getHSelf(),
2558  					TEXT("You have to restart Notepad++ to load plugins you installed."),
2559  					TEXT("Notepad++ need to be relaunched"),
2560  					MB_OK | MB_APPLMODAL);
2561  			}
2562              break;
2563          }
2564          case IDM_SETTING_IMPORTSTYLETHEMS :
2565          {
2566              const TCHAR *extFilterName = TEXT("Notepad++ style theme");
2567              const TCHAR *extFilter = TEXT(".xml");
2568              const TCHAR *destDir = TEXT("themes");
2569              NppParameters& nppParams = NppParameters::getInstance();
2570              ThemeSwitcher & themeSwitcher = nppParams.getThemeSwitcher();
2571              vector<generic_string> copiedFiles = addNppComponents(destDir, extFilterName, extFilter);
2572              for (size_t i = 0, len = copiedFiles.size(); i < len ; ++i)
2573              {
2574                  generic_string themeName(themeSwitcher.getThemeFromXmlFileName(copiedFiles[i].c_str()));
2575  		        if (!themeSwitcher.themeNameExists(themeName.c_str()))
2576  		        {
2577  			        themeSwitcher.addThemeFromXml(copiedFiles[i].c_str());
2578                      if (_configStyleDlg.isCreated())
2579                      {
2580                          _configStyleDlg.addLastThemeEntry();
2581                      }
2582  		        }
2583              }
2584              break;
2585          }
2586  		case IDM_SETTING_PLUGINADM:
2587  		{
2588  			bool isFirstTime = !_pluginsAdminDlg.isCreated();
2589  			_pluginsAdminDlg.doDialog(_nativeLangSpeaker.isRTL());
2590  			if (isFirstTime)
2591  			{
2592  				_nativeLangSpeaker.changePluginsAdminDlgLang(_pluginsAdminDlg);
2593  				_pluginsAdminDlg.updateList();
2594  			}
2595  			break;
2596  		}
2597  		case IDM_SETTING_OPENPLUGINSDIR:
2598  		{
2599  			const TCHAR* pluginHomePath = NppParameters::getInstance().getPluginRootDir();
2600  			if (pluginHomePath && pluginHomePath[0])
2601  			{
2602  				::ShellExecute(NULL, NULL, pluginHomePath, NULL, NULL, SW_SHOWNORMAL);
2603  			}
2604  			break;
2605  		}
2606  		case IDM_SETTING_SHORTCUT_MAPPER :
2607  		case IDM_SETTING_SHORTCUT_MAPPER_MACRO :
2608          case IDM_SETTING_SHORTCUT_MAPPER_RUN :
2609  		{
2610              GridState st = id==IDM_SETTING_SHORTCUT_MAPPER_MACRO?STATE_MACRO:id==IDM_SETTING_SHORTCUT_MAPPER_RUN?STATE_USER:STATE_MENU;
2611  			ShortcutMapper shortcutMapper;
2612              shortcutMapper.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), st);
2613  			shortcutMapper.doDialog(_nativeLangSpeaker.isRTL());
2614  			shortcutMapper.destroy();
2615  			break;
2616  		}
2617  		case IDM_SETTING_PREFERENCE:
2618  		{
2619  			bool isFirstTime = !_preference.isCreated();
2620  			_preference.doDialog(_nativeLangSpeaker.isRTL());
2621  			if (isFirstTime)
2622  			{
2623  				_nativeLangSpeaker.changePrefereceDlgLang(_preference);
2624  			}
2625  			break;
2626  		}
2627          case IDM_SETTING_EDITCONTEXTMENU :
2628          {
2629  			_nativeLangSpeaker.messageBox("ContextMenuXmlEditWarning",
2630  				_pPublicInterface->getHSelf(),
2631  				TEXT("Editing contextMenu.xml allows you to modify your Notepad++ popup context menu on edit zone.\rYou have to restart your Notepad++ to take effect after modifying contextMenu.xml."),
2632  				TEXT("Editing contextMenu"),
2633  				MB_OK|MB_APPLMODAL);
2634              NppParameters& nppParams = NppParameters::getInstance();
2635              BufferID bufID = doOpen((nppParams.getContextMenuPath()));
2636  			switchToFile(bufID);
2637              break;
2638          }
2639          case IDM_VIEW_GOTO_ANOTHER_VIEW:
2640              docGotoAnotherEditView(TransferMove);
2641  			checkSyncState();
2642  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
2643              break;
2644          case IDM_VIEW_CLONE_TO_ANOTHER_VIEW:
2645              docGotoAnotherEditView(TransferClone);
2646  			checkSyncState();
2647  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
2648              break;
2649          case IDM_VIEW_GOTO_NEW_INSTANCE :
2650              docOpenInNewInstance(TransferMove);
2651              break;
2652          case IDM_VIEW_LOAD_IN_NEW_INSTANCE:
2653              docOpenInNewInstance(TransferClone);
2654              break;
2655  		case IDM_VIEW_SWITCHTO_OTHER_VIEW:
2656  		{
2657  			int view_to_focus;
2658  			HWND wnd = GetFocus();
2659  			if (_pEditView->getHSelf() == wnd)
2660  			{
2661  				view_to_focus = otherView();
2662  				if (!viewVisible(view_to_focus)) view_to_focus = _activeView;
2663  			}
2664  			else
2665  			{
2666  				view_to_focus = currentView();
2667  			}
2668  			switchEditViewTo(view_to_focus);
2669  			break;
2670  		}
2671  		case IDM_TOOL_MD5_GENERATE:
2672  		{
2673  			bool isFirstTime = !_md5FromTextDlg.isCreated();
2674  			_md5FromTextDlg.doDialog(_nativeLangSpeaker.isRTL());
2675  			if (isFirstTime)
2676  				_nativeLangSpeaker.changeDlgLang(_md5FromTextDlg.getHSelf(), "MD5FromTextDlg");
2677  		}
2678  		break;
2679  		case IDM_TOOL_MD5_GENERATEFROMFILE:
2680  		{
2681  			bool isFirstTime = !_md5FromFilesDlg.isCreated();
2682  			_md5FromFilesDlg.doDialog(_nativeLangSpeaker.isRTL());
2683  			if (isFirstTime)
2684  				_nativeLangSpeaker.changeDlgLang(_md5FromFilesDlg.getHSelf(), "MD5FromFilesDlg");
2685  		}
2686  		break;
2687  		case IDM_TOOL_MD5_GENERATEINTOCLIPBOARD:
2688  		{
2689  			if (_pEditView->execute(SCI_GETSELECTIONS) == 1)
2690  			{
2691  				size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
2692  				size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
2693  				intptr_t strLen = selectionEnd - selectionStart;
2694  				if (strLen)
2695  				{
2696  					intptr_t strSize = strLen + 1;
2697  					char *selectedStr = new char[strSize];
2698  					_pEditView->execute(SCI_GETSELTEXT, 0, reinterpret_cast<LPARAM>(selectedStr));
2699  					MD5 md5;
2700  					std::string md5ResultA = md5.digestString(selectedStr);
2701  					std::wstring md5ResultW(md5ResultA.begin(), md5ResultA.end());
2702  					str2Clipboard(md5ResultW, _pPublicInterface->getHSelf());
2703  					delete [] selectedStr;
2704  				}
2705  			}
2706  		}
2707  		break;
2708  		case IDM_TOOL_SHA256_GENERATE:
2709  		{
2710  			bool isFirstTime = !_sha2FromTextDlg.isCreated();
2711  			_sha2FromTextDlg.doDialog(_nativeLangSpeaker.isRTL());
2712  			if (isFirstTime)
2713  				_nativeLangSpeaker.changeDlgLang(_sha2FromTextDlg.getHSelf(), "SHA256FromTextDlg");
2714  		}
2715  		break;
2716  		case IDM_TOOL_SHA256_GENERATEFROMFILE:
2717  		{
2718  			bool isFirstTime = !_sha2FromFilesDlg.isCreated();
2719  			_sha2FromFilesDlg.doDialog(_nativeLangSpeaker.isRTL());
2720  			if (isFirstTime)
2721  				_nativeLangSpeaker.changeDlgLang(_sha2FromFilesDlg.getHSelf(), "SHA256FromFilesDlg");
2722  		}
2723  		break;
2724  		case IDM_TOOL_SHA256_GENERATEINTOCLIPBOARD:
2725  		{
2726  			if (_pEditView->execute(SCI_GETSELECTIONS) == 1)
2727  			{
2728  				size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
2729  				size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
2730  				intptr_t strLen = selectionEnd - selectionStart;
2731  				if (strLen)
2732  				{
2733  					intptr_t strSize = strLen + 1;
2734  					char *selectedStr = new char[strSize];
2735  					_pEditView->execute(SCI_GETSELTEXT, 0, reinterpret_cast<LPARAM>(selectedStr));
2736  					uint8_t sha2hash[32];
2737  					calc_sha_256(sha2hash, reinterpret_cast<const uint8_t*>(selectedStr), strlen(selectedStr));
2738  					wchar_t sha2hashStr[65] = { '\0' };
2739  					for (size_t i = 0; i < 32; i++)
2740  						wsprintf(sha2hashStr + i * 2, TEXT("%02x"), sha2hash[i]);
2741  					str2Clipboard(sha2hashStr, _pPublicInterface->getHSelf());
2742  					delete[] selectedStr;
2743  				}
2744  			}
2745  		}
2746  		break;
2747  		case IDM_DEBUGINFO:
2748  		{
2749  			_debugInfoDlg.doDialog();
2750  			break;
2751  		}
2752          case IDM_ABOUT:
2753  		{
2754  			bool doAboutDlg = false;
2755  			const int maxSelLen = 32;
2756  			auto textLen = _pEditView->execute(SCI_GETSELTEXT, 0, 0);
2757  			if (textLen <= 0)
2758  				doAboutDlg = true;
2759  			if (textLen > maxSelLen)
2760  				doAboutDlg = true;
2761  			if (!doAboutDlg)
2762  			{
2763  				char author[maxSelLen+1] = "";
2764  				_pEditView->getSelectedText(author, maxSelLen + 1);
2765  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2766  				const wchar_t * authorW = wmc.char2wchar(author, _nativeLangSpeaker.getLangEncoding());
2767  				int iQuote = getQuoteIndexFrom(authorW);
2768  				if (iQuote == -1)
2769  				{
2770  					doAboutDlg = true;
2771  				}
2772  				else if (iQuote == -2)
2773  				{
2774  					generic_string noEasterEggsPath((NppParameters::getInstance()).getNppPath());
2775  					noEasterEggsPath.append(TEXT("\\noEasterEggs.xml"));
2776  					if (!::PathFileExists(noEasterEggsPath.c_str()))
2777  						showAllQuotes();
2778  					return;
2779  				}
2780  				if (iQuote != -1)
2781  				{
2782  					generic_string noEasterEggsPath((NppParameters::getInstance()).getNppPath());
2783  					noEasterEggsPath.append(TEXT("\\noEasterEggs.xml"));
2784  					if (!::PathFileExists(noEasterEggsPath.c_str()))
2785  						showQuoteFromIndex(iQuote);
2786  					return;
2787  				}
2788  			}
2789  			if (doAboutDlg)
2790  			{
2791  				_aboutDlg.doDialog();
2792  			}
2793  			break;
2794  		}
2795  		case IDM_HOMESWEETHOME :
2796  		{
2797  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;notepad-plus-plus.org/"), NULL, NULL, SW_SHOWNORMAL);
2798  			break;
2799  		}
2800  		case IDM_PROJECTPAGE :
2801  		{
2802  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;github.com/notepad-plus-plus/notepad-plus-plus/"), NULL, NULL, SW_SHOWNORMAL);
2803  			break;
2804  		}
2805  		case IDM_ONLINEDOCUMENT:
2806  		{
2807  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;npp-user-manual.org/"), NULL, NULL, SW_SHOWNORMAL);
2808  			break;
2809  		}
2810  		case IDM_CMDLINEARGUMENTS:
2811  		{
2812  			::MessageBox(_pPublicInterface->getHSelf(), COMMAND_ARG_HELP, TEXT("Notepad++ Command Argument Help"), MB_OK | MB_APPLMODAL);
2813  			break;
2814  		}
2815  		case IDM_FORUM:
2816  		{
2817  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;community.notepad-plus-plus.org/"), NULL, NULL, SW_SHOWNORMAL);
2818  			break;
2819  		}
2820  		case IDM_UPDATE_NPP :
2821  		case IDM_CONFUPDATERPROXY :
2822  		{
2823  			winVer ver = NppParameters::getInstance().getWinVersion();
2824  			if (ver <= WV_XP)
2825  			{
2826  				long res = _nativeLangSpeaker.messageBox("XpUpdaterProblem",
2827  					_pPublicInterface->getHSelf(),
2828  					TEXT("Notepad++ updater is not compatible with XP due to the obsolete security layer under XP.\rDo you want to go to Notepad++ page to download the latest version?"),
2829  					TEXT("Notepad++ Updater"),
2830  					MB_YESNO);
2831  				if (res == IDYES)
2832  				{
2833  					::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;notepad-plus-plus.org/downloads/"), NULL, NULL, SW_SHOWNORMAL);
2834  				}
2835  			}
2836  			else
2837  			{
2838  				generic_string updaterDir = (NppParameters::getInstance()).getNppPath();
2839  				pathAppend(updaterDir, TEXT("updater"));
2840  				generic_string updaterFullPath = updaterDir;
2841  				pathAppend(updaterFullPath, TEXT("gup.exe"));
2842  #ifdef DEBUG 
2843  				bool isCertifVerified = true;
2844  #else 
2845  				SecurityGuard securityGuard;
2846  				bool isCertifVerified = securityGuard.checkModule(updaterFullPath, nm_gup);
2847  #endif
2848  				if (isCertifVerified)
2849  				{
2850  					generic_string param;
2851  					if (id == IDM_CONFUPDATERPROXY)
2852  					{
2853  						if (!_isAdministrator)
2854  						{
2855  							_nativeLangSpeaker.messageBox("GUpProxyConfNeedAdminMode",
2856  								_pPublicInterface->getHSelf(),
2857  								TEXT("Please relaunch Notepad++ in Admin mode to configure proxy."),
2858  								TEXT("Proxy Settings"),
2859  								MB_OK | MB_APPLMODAL);
2860  							return;
2861  						}
2862  						param = TEXT("-options");
2863  					}
2864  					else
2865  					{
2866  						param = TEXT("-verbose -v");
2867  						param += VERSION_VALUE;
2868  						int archType = NppParameters::getInstance().archType();
2869  						if (archType == IMAGE_FILE_MACHINE_AMD64)
2870  						{
2871  							param += TEXT(" -px64");
2872  						}
2873  						else if (archType == IMAGE_FILE_MACHINE_ARM64)
2874  						{
2875  							param += TEXT(" -parm64");
2876  						}
2877  					}
2878  					Process updater(updaterFullPath.c_str(), param.c_str(), updaterDir.c_str());
2879  					updater.run();
2880  				}
2881  			}
2882  			break;
2883  		}
2884  		case IDM_EDIT_AUTOCOMPLETE :
2885  			showAutoComp();
2886  			break;
2887  		case IDM_EDIT_AUTOCOMPLETE_CURRENTFILE :
2888  			autoCompFromCurrentFile();
2889  			break;
2890  		case IDM_EDIT_AUTOCOMPLETE_PATH :
2891  			showPathCompletion();
2892  			break;
2893  		case IDM_EDIT_FUNCCALLTIP :
2894  			showFunctionComp();
2895  			break;
2896  		case IDM_EDIT_FUNCCALLTIP_PREVIOUS :
2897  			showFunctionNextHint(false);
2898  			break;
2899  		case IDM_EDIT_FUNCCALLTIP_NEXT :
2900  			showFunctionNextHint();
2901  			break;
2902          case IDM_LANGSTYLE_CONFIG_DLG :
2903  		{
2904  			if (!(NppParameters::getInstance()).isStylerDocLoaded())
2905  			{
2906  			}
2907  			else
2908  			{
2909  				bool isFirstTime = !_configStyleDlg.isCreated();
2910  				_configStyleDlg.doDialog(_nativeLangSpeaker.isRTL());
2911  				if (isFirstTime)
2912  					_nativeLangSpeaker.changeConfigLang(_configStyleDlg.getHSelf());
2913  			}
2914  			break;
2915  		}
2916          case IDM_LANG_C	:
2917          case IDM_LANG_CPP :
2918          case IDM_LANG_JAVA :
2919          case IDM_LANG_CS :
2920          case IDM_LANG_HTML :
2921          case IDM_LANG_XML :
2922          case IDM_LANG_JS :
2923  		case IDM_LANG_JSON :
2924  		case IDM_LANG_JSON5 :
2925          case IDM_LANG_PHP :
2926          case IDM_LANG_ASP :
2927          case IDM_LANG_CSS :
2928          case IDM_LANG_LUA :
2929          case IDM_LANG_PERL :
2930          case IDM_LANG_PYTHON :
2931          case IDM_LANG_PASCAL :
2932          case IDM_LANG_BATCH :
2933          case IDM_LANG_OBJC :
2934          case IDM_LANG_VB :
2935          case IDM_LANG_SQL :
2936          case IDM_LANG_MSSQL :
2937          case IDM_LANG_ASCII :
2938          case IDM_LANG_TEXT :
2939          case IDM_LANG_RC :
2940          case IDM_LANG_MAKEFILE :
2941          case IDM_LANG_INI :
2942          case IDM_LANG_TEX :
2943          case IDM_LANG_FORTRAN :
2944  		case IDM_LANG_FORTRAN_77 :
2945          case IDM_LANG_BASH :
2946          case IDM_LANG_FLASH :
2947  		case IDM_LANG_NSIS :
2948  		case IDM_LANG_TCL :
2949  		case IDM_LANG_LISP :
2950  		case IDM_LANG_SCHEME :
2951  		case IDM_LANG_ASM :
2952  		case IDM_LANG_DIFF :
2953  		case IDM_LANG_PROPS :
2954  		case IDM_LANG_PS:
2955  		case IDM_LANG_RUBY:
2956  		case IDM_LANG_SMALLTALK:
2957  		case IDM_LANG_VHDL :
2958          case IDM_LANG_KIX :
2959          case IDM_LANG_CAML :
2960          case IDM_LANG_ADA :
2961          case IDM_LANG_VERILOG :
2962  		case IDM_LANG_MATLAB :
2963  		case IDM_LANG_HASKELL :
2964          case IDM_LANG_AU3 :
2965  		case IDM_LANG_INNO :
2966  		case IDM_LANG_CMAKE :
2967  		case IDM_LANG_YAML :
2968          case IDM_LANG_COBOL :
2969          case IDM_LANG_D :
2970          case IDM_LANG_GUI4CLI :
2971          case IDM_LANG_POWERSHELL :
2972          case IDM_LANG_R :
2973          case IDM_LANG_JSP :
2974  		case IDM_LANG_COFFEESCRIPT:
2975  		case IDM_LANG_BAANC:
2976  		case IDM_LANG_SREC:
2977  		case IDM_LANG_IHEX:
2978  		case IDM_LANG_TEHEX:
2979  		case IDM_LANG_SWIFT:
2980          case IDM_LANG_ASN1 :
2981          case IDM_LANG_AVS :
2982          case IDM_LANG_BLITZBASIC :
2983          case IDM_LANG_PUREBASIC :
2984          case IDM_LANG_FREEBASIC :
2985          case IDM_LANG_CSOUND :
2986          case IDM_LANG_ERLANG :
2987          case IDM_LANG_ESCRIPT :
2988          case IDM_LANG_FORTH :
2989          case IDM_LANG_LATEX :
2990          case IDM_LANG_MMIXAL :
2991          case IDM_LANG_NIM :
2992          case IDM_LANG_NNCRONTAB :
2993          case IDM_LANG_OSCRIPT :
2994          case IDM_LANG_REBOL :
2995          case IDM_LANG_REGISTRY :
2996          case IDM_LANG_RUST :
2997          case IDM_LANG_SPICE :
2998          case IDM_LANG_TXT2TAGS :
2999          case IDM_LANG_VISUALPROLOG:
3000  		case IDM_LANG_TYPESCRIPT:
3001  		case IDM_LANG_GDSCRIPT:
3002  		case IDM_LANG_HOLLYWOOD:
3003  		case IDM_LANG_USER :
3004  		{
3005              setLanguage(menuID2LangType(id));
3006  			Buffer *buffer = _pEditView->getCurrentBuffer();
3007  			buffer->langHasBeenSetFromMenu();
3008  			if (_pDocMap)
3009  			{
3010  				_pDocMap->setSyntaxHiliting();
3011  			}
3012  		}
3013          break;
3014  		case IDM_LANG_OPENUDLDIR:
3015  		{
3016  			generic_string userDefineLangFolderPath = NppParameters::getInstance().getUserDefineLangFolderPath();
3017  			::ShellExecute(_pPublicInterface->getHSelf(), TEXT("open"), userDefineLangFolderPath.c_str(), NULL, NULL, SW_SHOW);
3018  			break;
3019  		}
3020  		case IDM_LANG_UDLCOLLECTION_PROJECT_SITE:
3021  		{
3022  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;github.com/notepad-plus-plus/userDefinedLanguages"), NULL, NULL, SW_SHOWNORMAL);
3023  			break;
3024  		}
3025          case IDC_PREV_DOC :
3026          case IDC_NEXT_DOC :
3027          {
3028  			size_t nbDoc = viewVisible(MAIN_VIEW) ? _mainDocTab.nbItem() : 0;
3029  			nbDoc += viewVisible(SUB_VIEW)?_subDocTab.nbItem():0;
3030  			bool doTaskList = ((NppParameters::getInstance()).getNppGUI())._doTaskList;
3031  			_isFolding = true;
3032  			if (nbDoc > 1)
3033  			{
3034  				bool direction = (id == IDC_NEXT_DOC)?dirDown:dirUp;
3035  				if (!doTaskList)
3036  				{
3037  					activateNextDoc(direction);
3038  				}
3039  				else
3040  				{
3041  					if (TaskListDlg::_instanceCount == 0)
3042  					{
3043  						TaskListDlg tld;
3044  						HIMAGELIST hImgLst = nullptr;
3045  						const int tabIconSet = NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
3046  						switch (tabIconSet)
3047  						{
3048  							case 1:
3049  							{
3050  								hImgLst = _docTabIconListAlt.getHandle();
3051  								break;
3052  							}
3053  							case 2:
3054  							{
3055  								hImgLst = _docTabIconListDarkMode.getHandle();
3056  								break;
3057  							}
3058  							default:
3059  								hImgLst = _docTabIconList.getHandle();
3060  						}
3061  						tld.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), hImgLst, direction);
3062  						tld.doDialog(_nativeLangSpeaker.isRTL());
3063  					}
3064  				}
3065  			}
3066  			_isFolding = false;
3067  			_linkTriggered = true;
3068  		}
3069          break;
3070  		case IDM_OPEN_ALL_RECENT_FILE :
3071  		{
3072  			BufferID lastOne = BUFFER_INVALID;
3073  			int size = _lastRecentFileList.getSize();
3074  			for (int i = size - 1; i >= 0; i--)
3075  			{
3076  				BufferID test = doOpen(_lastRecentFileList.getIndex(i));
3077  				if (test != BUFFER_INVALID)
3078  					lastOne = test;
3079  			}
3080  			if (lastOne != BUFFER_INVALID)
3081  			{
3082  				switchToFile(lastOne);
3083  			}
3084  			break;
3085  		}
3086  		case IDM_CLEAN_RECENT_FILE_LIST :
3087  			_lastRecentFileList.clear();
3088  			break;
3089  		case IDM_EDIT_RTL :
3090  		case IDM_EDIT_LTR :
3091  		{
3092  			bool toRTL = id == IDM_EDIT_RTL;
3093  			bool isRTL = _pEditView->isTextDirectionRTL();
3094  			if ((toRTL && isRTL) || (!toRTL && !isRTL))
3095  			{
3096  				if (! ((NppParameters::getInstance()).getNppGUI())._muteSounds)
3097  					::MessageBeep(MB_OK);
3098  				break;
3099  			}
3100  			_pEditView->changeTextDirection(toRTL);
3101  			_pNonEditView->changeTextDirection(toRTL);
3102  			bool isWraped = _pEditView->isWrap();
3103  			_pEditView->wrap(!isWraped);
3104  			_pEditView->wrap(isWraped);
3105  			_pNonEditView->wrap(!isWraped);
3106  			_pNonEditView->wrap(isWraped);
3107  			if (_pDocMap)
3108  			{
3109  				_pDocMap->changeTextDirection(toRTL);
3110  			}
3111  		}
3112  		break;
3113  		case IDM_WINDOW_WINDOWS :
3114  		{
3115  			WindowsDlg _windowsDlg;
3116  			_windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3117              const TiXmlNodeA *nativeLangA = _nativeLangSpeaker.getNativeLangA();
3118  			TiXmlNodeA *dlgNode = NULL;
3119  			if (nativeLangA)
3120  			{
3121  				dlgNode = nativeLangA->FirstChild("Dialog");
3122  				if (dlgNode)
3123  					dlgNode = _nativeLangSpeaker.searchDlgNode(dlgNode, "Window");
3124  			}
3125  			_windowsDlg.doDialog();
3126  		}
3127  		break;
3128  		case IDM_WINDOW_SORT_FN_ASC :
3129  		{
3130  			WindowsDlg windowsDlg;
3131  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3132  			windowsDlg.sortFileNameASC();
3133  			windowsDlg.doSort();
3134  		}
3135  		break;
3136  		case IDM_WINDOW_SORT_FN_DSC :
3137  		{
3138  			WindowsDlg windowsDlg;
3139  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3140  			windowsDlg.sortFileNameDSC();
3141  			windowsDlg.doSort();
3142  		}
3143  		break;
3144  		case IDM_WINDOW_SORT_FP_ASC :
3145  		{
3146  			WindowsDlg windowsDlg;
3147  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3148  			windowsDlg.sortFilePathASC();
3149  			windowsDlg.doSort();
3150  		}
3151  		break;
3152  		case IDM_WINDOW_SORT_FP_DSC :
3153  		{
3154  			WindowsDlg windowsDlg;
3155  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3156  			windowsDlg.sortFilePathDSC();
3157  			windowsDlg.doSort();
3158  		}
3159  		break;
3160  		case IDM_WINDOW_SORT_FT_ASC :
3161  		{
3162  			WindowsDlg windowsDlg;
3163  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3164  			windowsDlg.sortFileTypeASC();
3165  			windowsDlg.doSort();
3166  		}
3167  		break;
3168  		case IDM_WINDOW_SORT_FT_DSC :
3169  		{
3170  			WindowsDlg windowsDlg;
3171  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3172  			windowsDlg.sortFileTypeDSC();
3173  			windowsDlg.doSort();
3174  		}
3175  		break;
3176  		case IDM_WINDOW_SORT_FS_ASC :
3177  		{
3178  			WindowsDlg windowsDlg;
3179  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3180  			windowsDlg.sortFileSizeASC();
3181  			windowsDlg.doSort();
3182  		}
3183  		break;
3184  		case IDM_WINDOW_SORT_FS_DSC :
3185  		{
3186  			WindowsDlg windowsDlg;
3187  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3188  			windowsDlg.sortFileSizeDSC();
3189  			windowsDlg.doSort();
3190  		}
3191  		break;
3192  		case IDM_SYSTRAYPOPUP_NEWDOC:
3193  		{
3194  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3195  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3196  			_dockingManager.showFloatingContainers(true);
3197  			restoreMinimizeDialogs();
3198  			fileNew();
3199  		}
3200  		break;
3201  		case IDM_SYSTRAYPOPUP_ACTIVATE :
3202  		{
3203  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3204  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3205  			_dockingManager.showFloatingContainers(true);
3206  			restoreMinimizeDialogs();
3207  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3208  		}
3209  		break;
3210  		case IDM_SYSTRAYPOPUP_NEW_AND_PASTE:
3211  		{
3212  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3213  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3214  			_dockingManager.showFloatingContainers(true);
3215  			restoreMinimizeDialogs();
3216  			BufferID bufferID = _pEditView->getCurrentBufferID();
3217  			Buffer * buf = MainFileManager.getBufferByID(bufferID);
3218  			if (!buf->isUntitled() || buf->docLength() != 0)
3219  			{
3220  				fileNew();
3221  			}
3222  			command(IDM_EDIT_PASTE);
3223  		}
3224  		break;
3225  		case IDM_SYSTRAYPOPUP_OPENFILE:
3226  		{
3227  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3228  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3229  			_dockingManager.showFloatingContainers(true);
3230  			restoreMinimizeDialogs();
3231  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3232  			fileOpen();
3233  		}
3234  		break;
3235  		case IDM_SYSTRAYPOPUP_CLOSE:
3236  		{
3237  			_pPublicInterface->setIsPrelaunch(false);
3238  			_pTrayIco->doTrayIcon(REMOVE);
3239  			if (!::IsWindowVisible(_pPublicInterface->getHSelf()))
3240  				::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0,0);
3241  		}
3242  		break;
3243  		case IDM_FILE_RESTORELASTCLOSEDFILE:
3244  		{
3245  			generic_string lastOpenedFullPath = _lastRecentFileList.getFirstItem();
3246  			if (!lastOpenedFullPath.empty())
3247  			{
3248  				BufferID lastOpened = doOpen(lastOpenedFullPath);
3249  				if (lastOpened != BUFFER_INVALID)
3250  					switchToFile(lastOpened);
3251  			}
3252  		}
3253  		break;
3254  		case IDM_VIEW_LINENUMBER:
3255  		case IDM_VIEW_SYMBOLMARGIN:
3256  		{
3257  			int margin;
3258  			if (id == IDM_VIEW_LINENUMBER)
3259  				margin = ScintillaEditView::_SC_MARGE_LINENUMBER;
3260  			else 
3261  				margin = ScintillaEditView::_SC_MARGE_SYMBOL;
3262  			if (_mainEditView.hasMarginShowed(margin))
3263  			{
3264  				_mainEditView.showMargin(margin, false);
3265  				_subEditView.showMargin(margin, false);
3266  			}
3267  			else
3268  			{
3269  				_mainEditView.showMargin(margin);
3270  				_subEditView.showMargin(margin);
3271  			}
3272  		}
3273  		break;
3274  		case IDM_VIEW_FOLDERMAGIN_SIMPLE:
3275  		case IDM_VIEW_FOLDERMAGIN_ARROW:
3276  		case IDM_VIEW_FOLDERMAGIN_CIRCLE:
3277  		case IDM_VIEW_FOLDERMAGIN_BOX:
3278  		case IDM_VIEW_FOLDERMAGIN:
3279  		{
3280  			folderStyle fStyle = (id == IDM_VIEW_FOLDERMAGIN_SIMPLE) ? FOLDER_STYLE_SIMPLE : \
3281  				(id == IDM_VIEW_FOLDERMAGIN_ARROW) ? FOLDER_STYLE_ARROW : \
3282  				(id == IDM_VIEW_FOLDERMAGIN_CIRCLE) ? FOLDER_STYLE_CIRCLE : \
3283  				(id == IDM_VIEW_FOLDERMAGIN) ? FOLDER_STYLE_NONE : FOLDER_STYLE_BOX;
3284  			_mainEditView.setMakerStyle(fStyle);
3285  			_subEditView.setMakerStyle(fStyle);
3286  		}
3287  		break;
3288  		case IDM_VIEW_CURLINE_HILITING:
3289  		{
3290  			NppParameters& nppParams = NppParameters::getInstance();
3291  			const ScintillaViewParams& svp = nppParams.getSVP();
3292  			const COLORREF bgColour { nppParams.getCurLineHilitingColour() };
3293  			const LPARAM frameWidth { (svp._currentLineHiliteMode == LINEHILITE_FRAME) ? svp._currentLineFrameWidth : 0 };
3294  			if (svp._currentLineHiliteMode != LINEHILITE_NONE)
3295  			{
3296  				_mainEditView.execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, bgColour);
3297  				_subEditView.execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, bgColour);
3298  			}
3299  			else
3300  			{
3301  				_mainEditView.execute(SCI_RESETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, 0);
3302  				_subEditView.execute(SCI_RESETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, 0);
3303  			}
3304  			_mainEditView.execute(SCI_SETCARETLINEFRAME, frameWidth);
3305  			_subEditView.execute(SCI_SETCARETLINEFRAME, frameWidth);
3306  		}
3307  		break;
3308  		case IDM_VIEW_LWDEF:
3309  		case IDM_VIEW_LWALIGN:
3310  		case IDM_VIEW_LWINDENT:
3311  		{
3312  			int mode = (id == IDM_VIEW_LWALIGN) ? SC_WRAPINDENT_SAME : \
3313  				(id == IDM_VIEW_LWINDENT) ? SC_WRAPINDENT_INDENT : SC_WRAPINDENT_FIXED;
3314  			_mainEditView.execute(SCI_SETWRAPINDENTMODE, mode);
3315  			_subEditView.execute(SCI_SETWRAPINDENTMODE, mode);
3316  		}
3317  		break;
3318  		default :
3319  			if (id > IDM_FILEMENU_LASTONE && id < (IDM_FILEMENU_LASTONE + _lastRecentFileList.getMaxNbLRF() + 1))
3320  			{
3321  				BufferID lastOpened = doOpen(_lastRecentFileList.getItem(id));
3322  				if (lastOpened != BUFFER_INVALID)
3323  				{
3324  					switchToFile(lastOpened);
3325  				}
3326  			}
3327  			else if ((id > IDM_LANG_USER) && (id < IDM_LANG_USER_LIMIT))
3328  			{
3329  				TCHAR langName[menuItemStrLenMax];
3330  				::GetMenuString(_mainMenuHandle, id, langName, menuItemStrLenMax, MF_BYCOMMAND);
3331  				_pEditView->getCurrentBuffer()->setLangType(L_USER, langName);
3332  				if (_pDocMap)
3333  				{
3334  					_pDocMap->setSyntaxHiliting();
3335  				}
3336  			}
3337  			else if ((id >= IDM_LANG_EXTERNAL) && (id <= IDM_LANG_EXTERNAL_LIMIT))
3338  			{
3339  				setLanguage((LangType)(id - IDM_LANG_EXTERNAL + L_EXTERNAL));
3340  				if (_pDocMap)
3341  				{
3342  					_pDocMap->setSyntaxHiliting();
3343  				}
3344  			}
3345  			else if ((id >= ID_MACRO) && (id < ID_MACRO_LIMIT))
3346  			{
3347  				int i = id - ID_MACRO;
3348  				vector<MacroShortcut> & theMacros = (NppParameters::getInstance()).getMacroList();
3349  				macroPlayback(theMacros[i].getMacro());
3350  			}
3351  			else if ((id >= ID_USER_CMD) && (id < ID_USER_CMD_LIMIT))
3352  			{
3353  				int i = id - ID_USER_CMD;
3354  				vector<UserCommand> & theUserCommands = (NppParameters::getInstance()).getUserCommandList();
3355  				UserCommand ucmd = theUserCommands[i];
3356  				Command cmd(string2wstring(ucmd.getCmd(), CP_UTF8));
3357  				cmd.run(_pPublicInterface->getHSelf());
3358  			}
3359  			else if ((id >= ID_PLUGINS_CMD) && (id < ID_PLUGINS_CMD_LIMIT))
3360  			{
3361  				int i = id - ID_PLUGINS_CMD;
3362  				_pluginsManager.runPluginCommand(i);
3363  			}
3364  			else if (_pluginsManager.inDynamicRange(id)) 
3365  			{
3366  				_pluginsManager.relayNppMessages(WM_COMMAND, id, 0);
3367  			}
3368  			else if ((id >= IDM_WINDOW_MRU_FIRST) && (id <= IDM_WINDOW_MRU_LIMIT))
3369  			{
3370  				activateDoc(id - IDM_WINDOW_MRU_FIRST);
3371  			}
3372  			else if ((id >= IDM_DROPLIST_MRU_FIRST) && (id < (IDM_DROPLIST_MRU_FIRST + static_cast<int32_t>(_pDocTab->nbItem()))))
3373  			{
3374  				activateDoc(id - IDM_DROPLIST_MRU_FIRST);
3375  			}
3376  	}
3377  	if (_recordingMacro)
3378  		switch (id)
3379  		{
3380  			case IDM_FILE_NEW :
3381  			case IDM_FILE_CLOSE :
3382  			case IDM_FILE_CLOSEALL :
3383  			case IDM_FILE_CLOSEALL_BUT_CURRENT :
3384  			case IDM_FILE_CLOSEALL_TOLEFT :
3385  			case IDM_FILE_CLOSEALL_TORIGHT :
3386  			case IDM_FILE_CLOSEALL_UNCHANGED:
3387  			case IDM_FILE_SAVE :
3388  			case IDM_FILE_SAVEALL :
3389  			case IDM_FILE_RELOAD:
3390  			case IDM_EDIT_UNDO:
3391  			case IDM_EDIT_REDO:
3392  			case IDM_EDIT_CUT:
3393  			case IDM_EDIT_COPY:
3394  			case IDM_EDIT_DELETE:
3395  			case IDM_SEARCH_FINDNEXT :
3396  			case IDM_SEARCH_FINDPREV :
3397              case IDM_SEARCH_SETANDFINDNEXT :
3398  			case IDM_SEARCH_SETANDFINDPREV :
3399  			case IDM_SEARCH_GOTOMATCHINGBRACE :
3400  			case IDM_SEARCH_SELECTMATCHINGBRACES :
3401  			case IDM_SEARCH_TOGGLE_BOOKMARK :
3402  			case IDM_SEARCH_NEXT_BOOKMARK:
3403  			case IDM_SEARCH_PREV_BOOKMARK:
3404  			case IDM_SEARCH_CLEAR_BOOKMARKS:
3405  			case IDM_SEARCH_INVERSEMARKS:
3406  			case IDM_EDIT_SELECTALL:
3407  			case IDM_EDIT_INS_TAB:
3408  			case IDM_EDIT_RMV_TAB:
3409  			case IDM_EDIT_DUP_LINE:
3410  			case IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES:
3411  			case IDM_EDIT_REMOVE_ANY_DUP_LINES:
3412  			case IDM_EDIT_TRANSPOSE_LINE:
3413  			case IDM_EDIT_SPLIT_LINES:
3414  			case IDM_EDIT_JOIN_LINES:
3415  			case IDM_EDIT_LINE_UP:
3416  			case IDM_EDIT_LINE_DOWN:
3417  			case IDM_EDIT_REMOVEEMPTYLINES:
3418  			case IDM_EDIT_REMOVEEMPTYLINESWITHBLANK:
3419  			case IDM_EDIT_UPPERCASE:
3420  			case IDM_EDIT_LOWERCASE:
3421  			case IDM_EDIT_PROPERCASE_FORCE:
3422  			case IDM_EDIT_PROPERCASE_BLEND:
3423  			case IDM_EDIT_SENTENCECASE_FORCE:
3424  			case IDM_EDIT_SENTENCECASE_BLEND:
3425  			case IDM_EDIT_INVERTCASE:
3426  			case IDM_EDIT_RANDOMCASE:
3427  			case IDM_EDIT_BLOCK_COMMENT:
3428  			case IDM_EDIT_BLOCK_COMMENT_SET:
3429  			case IDM_EDIT_BLOCK_UNCOMMENT:
3430  			case IDM_EDIT_STREAM_COMMENT:
3431  			case IDM_EDIT_TRIMTRAILING:
3432  			case IDM_EDIT_TRIMLINEHEAD:
3433  			case IDM_EDIT_TRIM_BOTH:
3434  			case IDM_EDIT_EOL2WS:
3435  			case IDM_EDIT_TRIMALL:
3436  			case IDM_EDIT_TAB2SW:
3437  			case IDM_EDIT_SW2TAB_ALL:
3438  			case IDM_EDIT_SW2TAB_LEADING:
3439  			case IDM_EDIT_SETREADONLY :
3440  			case IDM_EDIT_FULLPATHTOCLIP :
3441  			case IDM_EDIT_FILENAMETOCLIP :
3442  			case IDM_EDIT_CURRENTDIRTOCLIP :
3443  			case IDM_EDIT_CLEARREADONLY :
3444  			case IDM_EDIT_RTL :
3445  			case IDM_EDIT_LTR :
3446  			case IDM_EDIT_BEGINENDSELECT:
3447  			case IDM_EDIT_BEGINENDSELECT_COLUMNMODE:
3448  			case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING:
3449  			case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING:
3450  			case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING:
3451  			case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING:
3452  			case IDM_EDIT_SORTLINES_INTEGER_ASCENDING:
3453  			case IDM_EDIT_SORTLINES_INTEGER_DESCENDING:
3454  			case IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING:
3455  			case IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING:
3456  			case IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING:
3457  			case IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING:
3458  			case IDM_EDIT_SORTLINES_REVERSE_ORDER:
3459  			case IDM_EDIT_SORTLINES_RANDOMLY:
3460  			case IDM_EDIT_BLANKLINEABOVECURRENT:
3461  			case IDM_EDIT_BLANKLINEBELOWCURRENT:
3462  			case IDM_VIEW_FULLSCREENTOGGLE :
3463  			case IDM_VIEW_ALWAYSONTOP :
3464  			case IDM_VIEW_WRAP :
3465  			case IDM_VIEW_FOLD_CURRENT :
3466  			case IDM_VIEW_UNFOLD_CURRENT :
3467  			case IDM_VIEW_FOLDALL:
3468  			case IDM_VIEW_UNFOLDALL:
3469  			case IDM_VIEW_FOLD_1:
3470  			case IDM_VIEW_FOLD_2:
3471  			case IDM_VIEW_FOLD_3:
3472  			case IDM_VIEW_FOLD_4:
3473  			case IDM_VIEW_FOLD_5:
3474  			case IDM_VIEW_FOLD_6:
3475  			case IDM_VIEW_FOLD_7:
3476  			case IDM_VIEW_FOLD_8:
3477  			case IDM_VIEW_UNFOLD_1:
3478  			case IDM_VIEW_UNFOLD_2:
3479  			case IDM_VIEW_UNFOLD_3:
3480  			case IDM_VIEW_UNFOLD_4:
3481  			case IDM_VIEW_UNFOLD_5:
3482  			case IDM_VIEW_UNFOLD_6:
3483  			case IDM_VIEW_UNFOLD_7:
3484  			case IDM_VIEW_UNFOLD_8:
3485  			case IDM_VIEW_GOTO_ANOTHER_VIEW:
3486  			case IDM_VIEW_SYNSCROLLV:
3487  			case IDM_VIEW_SYNSCROLLH:
3488  			case IDM_VIEW_TAB1:
3489  			case IDM_VIEW_TAB2:
3490  			case IDM_VIEW_TAB3:
3491  			case IDM_VIEW_TAB4:
3492  			case IDM_VIEW_TAB5:
3493  			case IDM_VIEW_TAB6:
3494  			case IDM_VIEW_TAB7:
3495  			case IDM_VIEW_TAB8:
3496  			case IDM_VIEW_TAB9:
3497  			case IDM_VIEW_TAB_NEXT:
3498  			case IDM_VIEW_TAB_PREV:
3499  			case IDM_VIEW_TAB_MOVEFORWARD:
3500  			case IDM_VIEW_TAB_MOVEBACKWARD:
3501  			case IDC_PREV_DOC :
3502  			case IDC_NEXT_DOC :
3503  			case IDM_SEARCH_GOPREVMARKER1   :
3504  			case IDM_SEARCH_GOPREVMARKER2   :
3505  			case IDM_SEARCH_GOPREVMARKER3   :
3506  			case IDM_SEARCH_GOPREVMARKER4   :
3507  			case IDM_SEARCH_GOPREVMARKER5   :
3508  			case IDM_SEARCH_GOPREVMARKER_DEF:
3509  			case IDM_SEARCH_GONEXTMARKER1   :
3510  			case IDM_SEARCH_GONEXTMARKER2   :
3511  			case IDM_SEARCH_GONEXTMARKER3   :
3512  			case IDM_SEARCH_GONEXTMARKER4   :
3513  			case IDM_SEARCH_GONEXTMARKER5   :
3514  			case IDM_SEARCH_GONEXTMARKER_DEF:
3515  			case IDM_SEARCH_STYLE1TOCLIP:
3516  			case IDM_SEARCH_STYLE2TOCLIP:
3517  			case IDM_SEARCH_STYLE3TOCLIP:
3518  			case IDM_SEARCH_STYLE4TOCLIP:
3519  			case IDM_SEARCH_STYLE5TOCLIP:
3520  			case IDM_SEARCH_ALLSTYLESTOCLIP:
3521  			case IDM_SEARCH_MARKEDTOCLIP:
3522  			case IDM_SEARCH_VOLATILE_FINDNEXT:
3523  			case IDM_SEARCH_VOLATILE_FINDPREV:
3524  			case IDM_SEARCH_CUTMARKEDLINES   :
3525  			case IDM_SEARCH_COPYMARKEDLINES     :
3526  			case IDM_SEARCH_PASTEMARKEDLINES    :
3527  			case IDM_SEARCH_DELETEMARKEDLINES   :
3528  			case IDM_SEARCH_DELETEUNMARKEDLINES :
3529  			case IDM_SEARCH_MARKALLEXT1      :
3530  			case IDM_SEARCH_MARKALLEXT2      :
3531  			case IDM_SEARCH_MARKALLEXT3      :
3532  			case IDM_SEARCH_MARKALLEXT4      :
3533  			case IDM_SEARCH_MARKALLEXT5      :
3534  			case IDM_SEARCH_MARKONEEXT1      :
3535  			case IDM_SEARCH_MARKONEEXT2      :
3536  			case IDM_SEARCH_MARKONEEXT3      :
3537  			case IDM_SEARCH_MARKONEEXT4      :
3538  			case IDM_SEARCH_MARKONEEXT5      :
3539  			case IDM_SEARCH_UNMARKALLEXT1    :
3540  			case IDM_SEARCH_UNMARKALLEXT2    :
3541  			case IDM_SEARCH_UNMARKALLEXT3    :
3542  			case IDM_SEARCH_UNMARKALLEXT4    :
3543  			case IDM_SEARCH_UNMARKALLEXT5    :
3544  			case IDM_SEARCH_CLEARALLMARKS    :
3545  			case IDM_FORMAT_TODOS  :
3546  			case IDM_FORMAT_TOUNIX :
3547  			case IDM_FORMAT_TOMAC  :
3548  			case IDM_VIEW_IN_FIREFOX :
3549  			case IDM_VIEW_IN_CHROME  :
3550  			case IDM_VIEW_IN_EDGE    :
3551  			case IDM_VIEW_IN_IE      :
3552  			case IDM_EDIT_COPY_ALL_NAMES:
3553  			case IDM_EDIT_COPY_ALL_PATHS:
3554  				_macro.push_back(recordedMacroStep(id));
3555  				break;
3556  			case IDM_EDIT_INSERT_DATETIME_SHORT:
3557  			case IDM_EDIT_INSERT_DATETIME_LONG:
3558  			case IDM_EDIT_INSERT_DATETIME_CUSTOMIZED:
3559  			{
3560  				size_t lastIndex = _macro.size();
3561  				if (lastIndex >= 2)
3562  				{
3563  					--lastIndex;
3564  					if (_macro[lastIndex]._message == SCI_ADDTEXT && _macro[lastIndex - 1]._message == SCI_REPLACESEL)
3565  					{
3566  						_macro.erase(_macro.begin() + lastIndex);
3567  						--lastIndex;
3568  						_macro.erase(_macro.begin() + lastIndex);
3569  					}
3570  				}
3571  				_macro.push_back(recordedMacroStep(id));
3572  			}
3573  			break;
3574  		}
3575  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppCommands.cpp</div>
                </div>
                <div class="column column_space"><pre><code>353              long nc = n * channels_ + c;
354              const Dtype *bottom_data2 = bottom[0]->cpu_data() + nc * bottom_offset;
355              Dtype *top_data2 = top[0]->mutable_cpu_data() + nc * top_offset;
356              Dtype *top_mask = NULL;
</pre></code></div>
                <div class="column column_space"><pre><code>1821  			_toReduceTabBar = !_toReduceTabBar;
1822  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
1823  			int tabDpiDynamicalWidth = dpiManager.scaleX(g_TabWidth);
1824  			int tabDpiDynamicalHeight = dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    