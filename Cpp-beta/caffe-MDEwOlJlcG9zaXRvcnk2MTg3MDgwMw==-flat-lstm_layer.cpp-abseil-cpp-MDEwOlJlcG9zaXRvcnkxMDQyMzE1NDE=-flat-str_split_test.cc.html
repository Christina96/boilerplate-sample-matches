
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.22058823529412%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lstm_layer.cpp</h3>
            <pre><code>1  #include <string>
2  #include <vector>
3  #include "caffe/blob.hpp"
4  #include "caffe/common.hpp"
5  #include "caffe/filler.hpp"
6  #include "caffe/layer.hpp"
7  #include "caffe/layers/lstm_layer.hpp"
8  #include "caffe/util/math_functions.hpp"
9  namespace caffe {
10  template <typename Dtype>
11  void LSTMLayer<Dtype>::RecurrentInputBlobNames(vector<string>* names) const {
12    names->resize(2);
13    (*names)[0] = "h_0";
14    (*names)[1] = "c_0";
15  }
16  template <typename Dtype>
17  void LSTMLayer<Dtype>::RecurrentOutputBlobNames(vector<string>* names) const {
18    names->resize(2);
19    (*names)[0] = "h_" + format_int(this->T_);
20    (*names)[1] = "c_T";
21  }
22  template <typename Dtype>
23  void LSTMLayer<Dtype>::RecurrentInputShapes(vector<BlobShape>* shapes) const {
24    const int num_output = this->layer_param_.recurrent_param().num_output();
25    const int num_blobs = 2;
26    shapes->resize(num_blobs);
27    for (int i = 0; i < num_blobs; ++i) {
28      (*shapes)[i].Clear();
29      (*shapes)[i].add_dim(1);  
30      (*shapes)[i].add_dim(this->N_);
31      (*shapes)[i].add_dim(num_output);
32    }
33  }
34  template <typename Dtype>
35  void LSTMLayer<Dtype>::OutputBlobNames(vector<string>* names) const {
36    names->resize(1);
37    (*names)[0] = "h";
38  }
39  template <typename Dtype>
40  void LSTMLayer<Dtype>::FillUnrolledNet(NetParameter* net_param) const {
41    const int num_output = this->layer_param_.recurrent_param().num_output();
42    CHECK_GT(num_output, 0) << "num_output must be positive";
43    const FillerParameter& weight_filler =
44        this->layer_param_.recurrent_param().weight_filler();
45    const FillerParameter& bias_filler =
46        this->layer_param_.recurrent_param().bias_filler();
47    LayerParameter hidden_param;
48    hidden_param.set_type("InnerProduct");
49    hidden_param.mutable_inner_product_param()->set_num_output(num_output * 4);
50    hidden_param.mutable_inner_product_param()->set_bias_term(false);
51    hidden_param.mutable_inner_product_param()->set_axis(2);
52    hidden_param.mutable_inner_product_param()->
53        mutable_weight_filler()->CopyFrom(weight_filler);
54    LayerParameter biased_hidden_param(hidden_param);
55    biased_hidden_param.mutable_inner_product_param()->set_bias_term(true);
56    biased_hidden_param.mutable_inner_product_param()->
57        mutable_bias_filler()->CopyFrom(bias_filler);
58    LayerParameter sum_param;
59    sum_param.set_type("Eltwise");
60    sum_param.mutable_eltwise_param()->set_operation(
61        EltwiseParameter_EltwiseOp_SUM);
62    LayerParameter scale_param;
63    scale_param.set_type("Scale");
64    scale_param.mutable_scale_param()->set_axis(0);
65    LayerParameter slice_param;
66    slice_param.set_type("Slice");
67    slice_param.mutable_slice_param()->set_axis(0);
68    LayerParameter split_param;
69    split_param.set_type("Split");
70    vector<BlobShape> input_shapes;
71    RecurrentInputShapes(&input_shapes);
72    CHECK_EQ(2, input_shapes.size());
73    LayerParameter* input_layer_param = net_param->add_layer();
74    input_layer_param->set_type("Input");
75    InputParameter* input_param = input_layer_param->mutable_input_param();
76    input_layer_param->add_top("c_0");
77    input_param->add_shape()->CopyFrom(input_shapes[0]);
78    input_layer_param->add_top("h_0");
79    input_param->add_shape()->CopyFrom(input_shapes[1]);
80    LayerParameter* cont_slice_param = net_param->add_layer();
81    cont_slice_param->CopyFrom(slice_param);
82    cont_slice_param->set_name("cont_slice");
83    cont_slice_param->add_bottom("cont");
84    cont_slice_param->mutable_slice_param()->set_axis(0);
85    {
86      LayerParameter* x_transform_param = net_param->add_layer();
87      x_transform_param->CopyFrom(biased_hidden_param);
88      x_transform_param->set_name("x_transform");
89      x_transform_param->add_param()->set_name("W_xc");
90      x_transform_param->add_param()->set_name("b_c");
91      x_transform_param->add_bottom("x");
92      x_transform_param->add_top("W_xc_x");
93      x_transform_param->add_propagate_down(true);
94    }
95    if (this->static_input_) {
<span onclick='openModal()' class='match'>96      LayerParameter* x_static_transform_param = net_param->add_layer();
97      x_static_transform_param->CopyFrom(hidden_param);
98      x_static_transform_param->mutable_inner_product_param()->set_axis(1);
99      x_static_transform_param->set_name("W_xc_x_static");
100      x_static_transform_param->add_param()->set_name("W_xc_static");
101      x_static_transform_param->add_bottom("x_static");
102      x_static_transform_param->add_top("W_xc_x_static_preshape");
103      x_static_transform_param->add_propagate_down(true);
</span>104      LayerParameter* reshape_param = net_param->add_layer();
105      reshape_param->set_type("Reshape");
106      BlobShape* new_shape =
107           reshape_param->mutable_reshape_param()->mutable_shape();
108      new_shape->add_dim(1);  
109      new_shape->add_dim(-1);
110      new_shape->add_dim(
111          x_static_transform_param->inner_product_param().num_output());
112      reshape_param->set_name("W_xc_x_static_reshape");
113      reshape_param->add_bottom("W_xc_x_static_preshape");
114      reshape_param->add_top("W_xc_x_static");
115    }
116    LayerParameter* x_slice_param = net_param->add_layer();
117    x_slice_param->CopyFrom(slice_param);
118    x_slice_param->add_bottom("W_xc_x");
119    x_slice_param->set_name("W_xc_x_slice");
120    LayerParameter output_concat_layer;
121    output_concat_layer.set_name("h_concat");
122    output_concat_layer.set_type("Concat");
123    output_concat_layer.add_top("h");
124    output_concat_layer.mutable_concat_param()->set_axis(0);
125    for (int t = 1; t <= this->T_; ++t) {
126      string tm1s = format_int(t - 1);
127      string ts = format_int(t);
128      cont_slice_param->add_top("cont_" + ts);
129      x_slice_param->add_top("W_xc_x_" + ts);
130      {
131        LayerParameter* cont_h_param = net_param->add_layer();
132        cont_h_param->CopyFrom(scale_param);
133        cont_h_param->set_name("h_conted_" + tm1s);
134        cont_h_param->add_bottom("h_" + tm1s);
135        cont_h_param->add_bottom("cont_" + ts);
136        cont_h_param->add_top("h_conted_" + tm1s);
137      }
138      {
139        LayerParameter* w_param = net_param->add_layer();
140        w_param->CopyFrom(hidden_param);
141        w_param->set_name("transform_" + ts);
142        w_param->add_param()->set_name("W_hc");
143        w_param->add_bottom("h_conted_" + tm1s);
144        w_param->add_top("W_hc_h_" + tm1s);
145        w_param->mutable_inner_product_param()->set_axis(2);
146      }
147      {
148        LayerParameter* input_sum_layer = net_param->add_layer();
149        input_sum_layer->CopyFrom(sum_param);
150        input_sum_layer->set_name("gate_input_" + ts);
151        input_sum_layer->add_bottom("W_hc_h_" + tm1s);
152        input_sum_layer->add_bottom("W_xc_x_" + ts);
153        if (this->static_input_) {
154          input_sum_layer->add_bottom("W_xc_x_static");
155        }
156        input_sum_layer->add_top("gate_input_" + ts);
157      }
158      {
159        LayerParameter* lstm_unit_param = net_param->add_layer();
160        lstm_unit_param->set_type("LSTMUnit");
161        lstm_unit_param->add_bottom("c_" + tm1s);
162        lstm_unit_param->add_bottom("gate_input_" + ts);
163        lstm_unit_param->add_bottom("cont_" + ts);
164        lstm_unit_param->add_top("c_" + ts);
165        lstm_unit_param->add_top("h_" + ts);
166        lstm_unit_param->set_name("unit_" + ts);
167      }
168      output_concat_layer.add_bottom("h_" + ts);
169    }  
170    {
171      LayerParameter* c_T_copy_param = net_param->add_layer();
172      c_T_copy_param->CopyFrom(split_param);
173      c_T_copy_param->add_bottom("c_" + format_int(this->T_));
174      c_T_copy_param->add_top("c_T");
175    }
176    net_param->add_layer()->CopyFrom(output_concat_layer);
177  }
178  INSTANTIATE_CLASS(LSTMLayer);
179  REGISTER_LAYER_CLASS(LSTM);
180  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_split_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_split.h"
2  #include <deque>
3  #include <initializer_list>
4  #include <list>
5  #include <map>
6  #include <memory>
7  #include <string>
8  #include <type_traits>
9  #include <unordered_map>
10  #include <unordered_set>
11  #include <vector>
12  #include "gmock/gmock.h"
13  #include "gtest/gtest.h"
14  #include "absl/base/dynamic_annotations.h"
15  #include "absl/base/macros.h"
16  #include "absl/container/btree_map.h"
17  #include "absl/container/btree_set.h"
18  #include "absl/container/flat_hash_map.h"
19  #include "absl/container/node_hash_map.h"
20  #include "absl/strings/numbers.h"
21  namespace {
22  using ::testing::ElementsAre;
23  using ::testing::Pair;
24  using ::testing::UnorderedElementsAre;
25  TEST(Split, TraitsTest) {
26    static_assert(!absl::strings_internal::SplitterIsConvertibleTo<int>::value,
27                  "");
28    static_assert(
29        !absl::strings_internal::SplitterIsConvertibleTo<std::string>::value, "");
30    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
31                      std::vector<std::string>>::value,
32                  "");
33    static_assert(
34        !absl::strings_internal::SplitterIsConvertibleTo<std::vector<int>>::value,
35        "");
36    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
37                      std::vector<absl::string_view>>::value,
38                  "");
39    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
40                      std::map<std::string, std::string>>::value,
41                  "");
42    static_assert(absl::strings_internal::SplitterIsConvertibleTo<
43                      std::map<absl::string_view, absl::string_view>>::value,
44                  "");
45    static_assert(!absl::strings_internal::SplitterIsConvertibleTo<
46                      std::map<int, std::string>>::value,
47                  "");
48    static_assert(!absl::strings_internal::SplitterIsConvertibleTo<
49                      std::map<std::string, int>>::value,
50                  "");
51  }
52  TEST(Split, APIExamples) {
53    {
54      std::vector<std::string> v = absl::StrSplit("a,b,c", ",");  
55      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
56      using absl::ByString;
57      v = absl::StrSplit("a,b,c", ByString(","));
58      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
59      EXPECT_THAT(absl::StrSplit("a,b,c", ByString(",")),
60                  ElementsAre("a", "b", "c"));
61    }
62    {
63      std::vector<std::string> v = absl::StrSplit("a,b,c", ',');
64      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
65      using absl::ByChar;
66      v = absl::StrSplit("a,b,c", ByChar(','));
67      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
68    }
69    {
70      const std::vector<std::string> v = absl::StrSplit("a=>b=>c", "=>");
71      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
72    }
73    {
74      std::vector<absl::string_view> v = absl::StrSplit("a,b,c", ',');
75      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
76    }
77    {
78      std::vector<std::string> v = absl::StrSplit(",a,b,c,", ',');
79      EXPECT_THAT(v, ElementsAre("", "a", "b", "c", ""));
80    }
81    {
82      std::vector<std::string> v = absl::StrSplit("abc", ',');
83      EXPECT_THAT(v, ElementsAre("abc"));
84    }
85    {
86      std::vector<std::string> v = absl::StrSplit("abc", "");
87      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
88    }
89    {
90      std::string embedded_nulls("a\0b\0c", 5);
91      std::string null_delim("\0", 1);
92      std::vector<std::string> v = absl::StrSplit(embedded_nulls, null_delim);
93      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
94    }
95    {
96      std::pair<std::string, std::string> p = absl::StrSplit("a,b,c", ',');
97      EXPECT_EQ("a", p.first);
98      EXPECT_EQ("b", p.second);
99    }
100    {
101      std::set<std::string> v = absl::StrSplit("a,b,c,a,b,c,a,b,c", ',');
102      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
103    }
104    {
105      char a[] = ",";
106      char* d = a + 0;
107      std::vector<std::string> v = absl::StrSplit("a,b,c", d);
108      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
109    }
110    {
111      using absl::ByAnyChar;
112      std::vector<std::string> v = absl::StrSplit("a,b;c", ByAnyChar(",;"));
113      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
114    }
115    {
116      using absl::SkipWhitespace;
117      std::vector<std::string> v =
118          absl::StrSplit(" a , ,,b,", ',', SkipWhitespace());
119      EXPECT_THAT(v, ElementsAre(" a ", "b"));
120    }
121    {
122      using absl::ByLength;
123      std::vector<std::string> v = absl::StrSplit("abcdefg", ByLength(3));
124      EXPECT_THAT(v, ElementsAre("abc", "def", "g"));
125    }
126    {
127      std::vector<std::string> v1 = absl::StrSplit("a,b,c", ',');
128      EXPECT_THAT(v1, ElementsAre("a", "b", "c"));
129      std::vector<std::string> v2(absl::StrSplit("a,b,c", ','));
130      EXPECT_THAT(v2, ElementsAre("a", "b", "c"));
131      auto v3 = std::vector<std::string>(absl::StrSplit("a,b,c", ','));
132      EXPECT_THAT(v3, ElementsAre("a", "b", "c"));
133      v3 = absl::StrSplit("a,b,c", ',');
134      EXPECT_THAT(v3, ElementsAre("a", "b", "c"));
135    }
136    {
137      std::map<std::string, std::string> m = absl::StrSplit("a,1,b,2,a,3", ',');
138      EXPECT_EQ(2, m.size());
139      EXPECT_EQ("3", m["a"]);
140      EXPECT_EQ("2", m["b"]);
141    }
142    {
143      std::multimap<std::string, std::string> m =
144          absl::StrSplit("a,1,b,2,a,3", ',');
145      EXPECT_EQ(3, m.size());
146      auto it = m.find("a");
147      EXPECT_EQ("1", it->second);
148      ++it;
149      EXPECT_EQ("3", it->second);
150      it = m.find("b");
151      EXPECT_EQ("2", it->second);
152    }
153    {
154      std::string s = "x,x,x,x,x,x,x";
155      for (absl::string_view sp : absl::StrSplit(s, ',')) {
156        EXPECT_EQ("x", sp);
157      }
158    }
159    {
160      using absl::SkipWhitespace;
161      std::string s = " ,x,,x,,x,x,x,,";
162      for (absl::string_view sp : absl::StrSplit(s, ',', SkipWhitespace())) {
163        EXPECT_EQ("x", sp);
164      }
165    }
166    {
167      std::map<std::string, std::string> m;
168      for (absl::string_view sp : absl::StrSplit("a=b=c,d=e,f=,g", ',')) {
169        m.insert(absl::StrSplit(sp, absl::MaxSplits('=', 1)));
170      }
171      EXPECT_EQ("b=c", m.find("a")->second);
172      EXPECT_EQ("e", m.find("d")->second);
173      EXPECT_EQ("", m.find("f")->second);
174      EXPECT_EQ("", m.find("g")->second);
175    }
176  }
177  TEST(SplitIterator, Basics) {
178    auto splitter = absl::StrSplit("a,b", ',');
179    auto it = splitter.begin();
180    auto end = splitter.end();
181    EXPECT_NE(it, end);
182    EXPECT_EQ("a", *it);  
183    ++it;                 
184    EXPECT_NE(it, end);
185    EXPECT_EQ("b",
186              std::string(it->data(), it->size()));  
187    it++;                                            
188    EXPECT_EQ(it, end);
189  }
190  class Skip {
191   public:
192    explicit Skip(const std::string& s) : s_(s) {}
193    bool operator()(absl::string_view sp) { return sp != s_; }
194   private:
195    std::string s_;
196  };
197  TEST(SplitIterator, Predicate) {
198    auto splitter = absl::StrSplit("a,b,c", ',', Skip("b"));
199    auto it = splitter.begin();
200    auto end = splitter.end();
201    EXPECT_NE(it, end);
202    EXPECT_EQ("a", *it);  
203    ++it;                 
204    EXPECT_NE(it, end);
205    EXPECT_EQ("c",
206              std::string(it->data(), it->size()));  
207    it++;                                            
208    EXPECT_EQ(it, end);
209  }
210  TEST(SplitIterator, EdgeCases) {
211    struct {
212      std::string in;
213      std::vector<std::string> expect;
214    } specs[] = {
215        {"", {""}},
216        {"foo", {"foo"}},
217        {",", {"", ""}},
218        {",foo", {"", "foo"}},
219        {"foo,", {"foo", ""}},
220        {",foo,", {"", "foo", ""}},
221        {"foo,bar", {"foo", "bar"}},
222    };
223    for (const auto& spec : specs) {
224      SCOPED_TRACE(spec.in);
225      auto splitter = absl::StrSplit(spec.in, ',');
226      auto it = splitter.begin();
227      auto end = splitter.end();
228      for (const auto& expected : spec.expect) {
229        EXPECT_NE(it, end);
230        EXPECT_EQ(expected, *it++);
231      }
232      EXPECT_EQ(it, end);
233    }
234  }
235  TEST(Splitter, Const) {
236    const auto splitter = absl::StrSplit("a,b,c", ',');
237    EXPECT_THAT(splitter, ElementsAre("a", "b", "c"));
238  }
239  TEST(Split, EmptyAndNull) {
240    EXPECT_THAT(absl::StrSplit(absl::string_view(""), '-'), ElementsAre(""));
241    EXPECT_THAT(absl::StrSplit(absl::string_view(), '-'), ElementsAre());
242  }
243  TEST(SplitIterator, EqualityAsEndCondition) {
244    auto splitter = absl::StrSplit("a,b,c", ',');
245    auto it = splitter.begin();
246    auto it2 = it;
247    ++it2;
248    ++it2;
249    EXPECT_EQ("c", *it2);
250    std::vector<absl::string_view> v;
251    for (; it != it2; ++it) {
252      v.push_back(*it);
253    }
254    EXPECT_THAT(v, ElementsAre("a", "b"));
255  }
256  TEST(Splitter, RangeIterators) {
257    auto splitter = absl::StrSplit("a,b,c", ',');
258    std::vector<absl::string_view> output;
259    for (absl::string_view p : splitter) {
260      output.push_back(p);
261    }
262    EXPECT_THAT(output, ElementsAre("a", "b", "c"));
263  }
264  template <typename ContainerType, typename Splitter>
265  void TestConversionOperator(const Splitter& splitter) {
266    ContainerType output = splitter;
267    EXPECT_THAT(output, UnorderedElementsAre("a", "b", "c", "d"));
268  }
269  template <typename MapType, typename Splitter>
270  void TestMapConversionOperator(const Splitter& splitter) {
271    MapType m = splitter;
272    EXPECT_THAT(m, UnorderedElementsAre(Pair("a", "b"), Pair("c", "d")));
273  }
274  template <typename FirstType, typename SecondType, typename Splitter>
275  void TestPairConversionOperator(const Splitter& splitter) {
276    std::pair<FirstType, SecondType> p = splitter;
277    EXPECT_EQ(p, (std::pair<FirstType, SecondType>("a", "b")));
278  }
279  TEST(Splitter, ConversionOperator) {
280    auto splitter = absl::StrSplit("a,b,c,d", ',');
281    TestConversionOperator<std::vector<absl::string_view>>(splitter);
282    TestConversionOperator<std::vector<std::string>>(splitter);
283    TestConversionOperator<std::list<absl::string_view>>(splitter);
284    TestConversionOperator<std::list<std::string>>(splitter);
285    TestConversionOperator<std::deque<absl::string_view>>(splitter);
286    TestConversionOperator<std::deque<std::string>>(splitter);
287    TestConversionOperator<std::set<absl::string_view>>(splitter);
288    TestConversionOperator<std::set<std::string>>(splitter);
289    TestConversionOperator<std::multiset<absl::string_view>>(splitter);
<span onclick='openModal()' class='match'>290    TestConversionOperator<std::multiset<std::string>>(splitter);
291    TestConversionOperator<absl::btree_set<absl::string_view>>(splitter);
292    TestConversionOperator<absl::btree_set<std::string>>(splitter);
293    TestConversionOperator<absl::btree_multiset<absl::string_view>>(splitter);
294    TestConversionOperator<absl::btree_multiset<std::string>>(splitter);
295    TestConversionOperator<std::unordered_set<std::string>>(splitter);
296    TestMapConversionOperator<std::map<absl::string_view, absl::string_view>>(
297        splitter);
298    TestMapConversionOperator<std::map<absl::string_view, std::string>>(splitter);
299    TestMapConversionOperator<std::map<std::string, absl::string_view>>(splitter);
300    TestMapConversionOperator<std::map<std::string, std::string>>(splitter);
</span>301    TestMapConversionOperator<
302        std::multimap<absl::string_view, absl::string_view>>(splitter);
303    TestMapConversionOperator<std::multimap<absl::string_view, std::string>>(
304        splitter);
305    TestMapConversionOperator<std::multimap<std::string, absl::string_view>>(
306        splitter);
307    TestMapConversionOperator<std::multimap<std::string, std::string>>(splitter);
308    TestMapConversionOperator<
309        absl::btree_map<absl::string_view, absl::string_view>>(splitter);
310    TestMapConversionOperator<absl::btree_map<absl::string_view, std::string>>(
311        splitter);
312    TestMapConversionOperator<absl::btree_map<std::string, absl::string_view>>(
313        splitter);
314    TestMapConversionOperator<absl::btree_map<std::string, std::string>>(
315        splitter);
316    TestMapConversionOperator<
317        absl::btree_multimap<absl::string_view, absl::string_view>>(splitter);
318    TestMapConversionOperator<
319        absl::btree_multimap<absl::string_view, std::string>>(splitter);
320    TestMapConversionOperator<
321        absl::btree_multimap<std::string, absl::string_view>>(splitter);
322    TestMapConversionOperator<absl::btree_multimap<std::string, std::string>>(
323        splitter);
324    TestMapConversionOperator<std::unordered_map<std::string, std::string>>(
325        splitter);
326    TestMapConversionOperator<
327        absl::node_hash_map<absl::string_view, absl::string_view>>(splitter);
328    TestMapConversionOperator<
329        absl::node_hash_map<absl::string_view, std::string>>(splitter);
330    TestMapConversionOperator<
331        absl::node_hash_map<std::string, absl::string_view>>(splitter);
332    TestMapConversionOperator<
333        absl::flat_hash_map<absl::string_view, absl::string_view>>(splitter);
334    TestMapConversionOperator<
335        absl::flat_hash_map<absl::string_view, std::string>>(splitter);
336    TestMapConversionOperator<
337        absl::flat_hash_map<std::string, absl::string_view>>(splitter);
338    TestPairConversionOperator<absl::string_view, absl::string_view>(splitter);
339    TestPairConversionOperator<absl::string_view, std::string>(splitter);
340    TestPairConversionOperator<std::string, absl::string_view>(splitter);
341    TestPairConversionOperator<std::string, std::string>(splitter);
342  }
343  TEST(Splitter, ToPair) {
344    {
345      std::pair<std::string, std::string> p = absl::StrSplit("", ',');
346      EXPECT_EQ("", p.first);
347      EXPECT_EQ("", p.second);
348    }
349    {
350      std::pair<std::string, std::string> p = absl::StrSplit("a", ',');
351      EXPECT_EQ("a", p.first);
352      EXPECT_EQ("", p.second);
353    }
354    {
355      std::pair<std::string, std::string> p = absl::StrSplit(",b", ',');
356      EXPECT_EQ("", p.first);
357      EXPECT_EQ("b", p.second);
358    }
359    {
360      std::pair<std::string, std::string> p = absl::StrSplit("a,b", ',');
361      EXPECT_EQ("a", p.first);
362      EXPECT_EQ("b", p.second);
363    }
364    {
365      std::pair<std::string, std::string> p = absl::StrSplit("a,b,c", ',');
366      EXPECT_EQ("a", p.first);
367      EXPECT_EQ("b", p.second);
368    }
369  }
370  TEST(Splitter, Predicates) {
371    static const char kTestChars[] = ",a, ,b,";
372    using absl::AllowEmpty;
373    using absl::SkipEmpty;
374    using absl::SkipWhitespace;
375    {
376      auto splitter = absl::StrSplit(kTestChars, ',');
377      std::vector<std::string> v = splitter;
378      EXPECT_THAT(v, ElementsAre("", "a", " ", "b", ""));
379    }
380    {
381      auto splitter = absl::StrSplit(kTestChars, ',', AllowEmpty());
382      std::vector<std::string> v_allowempty = splitter;
383      EXPECT_THAT(v_allowempty, ElementsAre("", "a", " ", "b", ""));
384      auto splitter_nopredicate = absl::StrSplit(kTestChars, ',');
385      std::vector<std::string> v_nopredicate = splitter_nopredicate;
386      EXPECT_EQ(v_allowempty, v_nopredicate);
387    }
388    {
389      auto splitter = absl::StrSplit(kTestChars, ',', SkipEmpty());
390      std::vector<std::string> v = splitter;
391      EXPECT_THAT(v, ElementsAre("a", " ", "b"));
392    }
393    {
394      auto splitter = absl::StrSplit(kTestChars, ',', SkipWhitespace());
395      std::vector<std::string> v = splitter;
396      EXPECT_THAT(v, ElementsAre("a", "b"));
397    }
398  }
399  TEST(Split, Basics) {
400    {
401      absl::StrSplit("a,b,c", ',');
402    }
403    {
404      std::vector<absl::string_view> v = absl::StrSplit("a,b,c", ',');
405      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
406    }
407    {
408      std::vector<std::string> v = absl::StrSplit("a,b,c", ',');
409      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
410    }
411    {
412      std::vector<std::string> v;
413      v = absl::StrSplit("a,b,c", ',');
414      EXPECT_THAT(v, ElementsAre("a", "b", "c"));
415      std::map<std::string, std::string> m;
416      m = absl::StrSplit("a,b,c", ',');
417      EXPECT_EQ(2, m.size());
418      std::unordered_map<std::string, std::string> hm;
419      hm = absl::StrSplit("a,b,c", ',');
420      EXPECT_EQ(2, hm.size());
421    }
422  }
423  absl::string_view ReturnStringView() { return "Hello World"; }
424  const char* ReturnConstCharP() { return "Hello World"; }
425  char* ReturnCharP() { return const_cast<char*>("Hello World"); }
426  TEST(Split, AcceptsCertainTemporaries) {
427    std::vector<std::string> v;
428    v = absl::StrSplit(ReturnStringView(), ' ');
429    EXPECT_THAT(v, ElementsAre("Hello", "World"));
430    v = absl::StrSplit(ReturnConstCharP(), ' ');
431    EXPECT_THAT(v, ElementsAre("Hello", "World"));
432    v = absl::StrSplit(ReturnCharP(), ' ');
433    EXPECT_THAT(v, ElementsAre("Hello", "World"));
434  }
435  TEST(Split, Temporary) {
436    const char input[] = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u";
437    EXPECT_LT(sizeof(std::string), ABSL_ARRAYSIZE(input))
438        << "Input should be larger than fits on the stack.";
439    auto splitter = absl::StrSplit(std::string(input), ',');
440    std::string expected = "a";
441    for (absl::string_view letter : splitter) {
442      EXPECT_EQ(expected, letter);
443      ++expected[0];
444    }
445    EXPECT_EQ("v", expected);
446    auto std_splitter = absl::StrSplit(std::string(input), ',');
447    expected = "a";
448    for (absl::string_view letter : std_splitter) {
449      EXPECT_EQ(expected, letter);
450      ++expected[0];
451    }
452    EXPECT_EQ("v", expected);
453  }
454  template <typename T>
455  static std::unique_ptr<T> CopyToHeap(const T& value) {
456    return std::unique_ptr<T>(new T(value));
457  }
458  TEST(Split, LvalueCaptureIsCopyable) {
459    std::string input = "a,b";
460    auto heap_splitter = CopyToHeap(absl::StrSplit(input, ','));
461    auto stack_splitter = *heap_splitter;
462    heap_splitter.reset();
463    std::vector<std::string> result = stack_splitter;
464    EXPECT_THAT(result, testing::ElementsAre("a", "b"));
465  }
466  TEST(Split, TemporaryCaptureIsCopyable) {
467    auto heap_splitter = CopyToHeap(absl::StrSplit(std::string("a,b"), ','));
468    auto stack_splitter = *heap_splitter;
469    heap_splitter.reset();
470    std::vector<std::string> result = stack_splitter;
471    EXPECT_THAT(result, testing::ElementsAre("a", "b"));
472  }
473  TEST(Split, SplitterIsCopyableAndMoveable) {
474    auto a = absl::StrSplit("foo", '-');
475    auto b = a;             
476    auto c = std::move(a);  
477    b = c;                  
478    c = std::move(b);       
479    EXPECT_THAT(c, ElementsAre("foo"));
480  }
481  TEST(Split, StringDelimiter) {
482    {
483      std::vector<absl::string_view> v = absl::StrSplit("a,b", ',');
484      EXPECT_THAT(v, ElementsAre("a", "b"));
485    }
486    {
487      std::vector<absl::string_view> v = absl::StrSplit("a,b", std::string(","));
488      EXPECT_THAT(v, ElementsAre("a", "b"));
489    }
490    {
491      std::vector<absl::string_view> v =
492          absl::StrSplit("a,b", absl::string_view(","));
493      EXPECT_THAT(v, ElementsAre("a", "b"));
494    }
495  }
496  #if !defined(__cpp_char8_t)
497  #if defined(__clang__)
498  #pragma clang diagnostic push
499  #pragma clang diagnostic ignored "-Wc++2a-compat"
500  #endif
501  TEST(Split, UTF8) {
502    std::string utf8_string = u8"\u03BA\u1F79\u03C3\u03BC\u03B5";
503    {
504      std::string to_split = "a," + utf8_string;
505      std::vector<absl::string_view> v = absl::StrSplit(to_split, ',');
506      EXPECT_THAT(v, ElementsAre("a", utf8_string));
507    }
508    {
509      std::string to_split = "a," + utf8_string + ",b";
510      std::string unicode_delimiter = "," + utf8_string + ",";
511      std::vector<absl::string_view> v =
512          absl::StrSplit(to_split, unicode_delimiter);
513      EXPECT_THAT(v, ElementsAre("a", "b"));
514    }
515    {
516      std::vector<absl::string_view> v =
517          absl::StrSplit(u8"Foo h\u00E4llo th\u4E1Ere", absl::ByAnyChar(" \t"));
518      EXPECT_THAT(v, ElementsAre("Foo", u8"h\u00E4llo", u8"th\u4E1Ere"));
519    }
520  }
521  #if defined(__clang__)
522  #pragma clang diagnostic pop
523  #endif
524  #endif  
525  TEST(Split, EmptyStringDelimiter) {
526    {
527      std::vector<std::string> v = absl::StrSplit("", "");
528      EXPECT_THAT(v, ElementsAre(""));
529    }
530    {
531      std::vector<std::string> v = absl::StrSplit("a", "");
532      EXPECT_THAT(v, ElementsAre("a"));
533    }
534    {
535      std::vector<std::string> v = absl::StrSplit("ab", "");
536      EXPECT_THAT(v, ElementsAre("a", "b"));
537    }
538    {
539      std::vector<std::string> v = absl::StrSplit("a b", "");
540      EXPECT_THAT(v, ElementsAre("a", " ", "b"));
541    }
542  }
543  TEST(Split, SubstrDelimiter) {
544    std::vector<absl::string_view> results;
545    absl::string_view delim("&bsol;&bsol;");
546    results = absl::StrSplit("", delim);
547    EXPECT_THAT(results, ElementsAre(""));
548    results = absl::StrSplit("&bsol;&bsol;", delim);
549    EXPECT_THAT(results, ElementsAre("", ""));
550    results = absl::StrSplit("ab", delim);
551    EXPECT_THAT(results, ElementsAre("ab"));
552    results = absl::StrSplit("ab
553    EXPECT_THAT(results, ElementsAre("ab", ""));
554    results = absl::StrSplit("ab/", delim);
555    EXPECT_THAT(results, ElementsAre("ab/"));
556    results = absl::StrSplit("a/b", delim);
557    EXPECT_THAT(results, ElementsAre("a/b"));
558    results = absl::StrSplit("a
559    EXPECT_THAT(results, ElementsAre("a", "b"));
560    results = absl::StrSplit("a
561    EXPECT_THAT(results, ElementsAre("a", "/b"));
562    results = absl::StrSplit("a
563    EXPECT_THAT(results, ElementsAre("a", "", "b"));
564  }
565  TEST(Split, EmptyResults) {
566    std::vector<absl::string_view> results;
567    results = absl::StrSplit("", '#');
568    EXPECT_THAT(results, ElementsAre(""));
569    results = absl::StrSplit("#", '#');
570    EXPECT_THAT(results, ElementsAre("", ""));
571    results = absl::StrSplit("#cd", '#');
572    EXPECT_THAT(results, ElementsAre("", "cd"));
573    results = absl::StrSplit("ab#cd#", '#');
574    EXPECT_THAT(results, ElementsAre("ab", "cd", ""));
575    results = absl::StrSplit("ab##cd", '#');
576    EXPECT_THAT(results, ElementsAre("ab", "", "cd"));
577    results = absl::StrSplit("ab##", '#');
578    EXPECT_THAT(results, ElementsAre("ab", "", ""));
579    results = absl::StrSplit("ab#ab#", '#');
580    EXPECT_THAT(results, ElementsAre("ab", "ab", ""));
581    results = absl::StrSplit("aaaa", 'a');
582    EXPECT_THAT(results, ElementsAre("", "", "", "", ""));
583    results = absl::StrSplit("", '#', absl::SkipEmpty());
584    EXPECT_THAT(results, ElementsAre());
585  }
586  template <typename Delimiter>
587  static bool IsFoundAtStartingPos(absl::string_view text, Delimiter d,
588                                   size_t starting_pos, int expected_pos) {
589    absl::string_view found = d.Find(text, starting_pos);
590    return found.data() != text.data() + text.size() &&
591           expected_pos == found.data() - text.data();
592  }
593  template <typename Delimiter>
594  static bool IsFoundAt(absl::string_view text, Delimiter d, int expected_pos) {
595    const std::string leading_text = ",x,y,z,";
596    return IsFoundAtStartingPos(text, d, 0, expected_pos) &&
597           IsFoundAtStartingPos(leading_text + std::string(text), d,
598                                leading_text.length(),
599                                expected_pos + leading_text.length());
600  }
601  template <typename Delimiter>
602  void TestComma(Delimiter d) {
603    EXPECT_TRUE(IsFoundAt(",", d, 0));
604    EXPECT_TRUE(IsFoundAt("a,", d, 1));
605    EXPECT_TRUE(IsFoundAt(",b", d, 0));
606    EXPECT_TRUE(IsFoundAt("a,b", d, 1));
607    EXPECT_TRUE(IsFoundAt("a,b,", d, 1));
608    EXPECT_TRUE(IsFoundAt("a,b,c", d, 1));
609    EXPECT_FALSE(IsFoundAt("", d, -1));
610    EXPECT_FALSE(IsFoundAt(" ", d, -1));
611    EXPECT_FALSE(IsFoundAt("a", d, -1));
612    EXPECT_FALSE(IsFoundAt("a b c", d, -1));
613    EXPECT_FALSE(IsFoundAt("a;b;c", d, -1));
614    EXPECT_FALSE(IsFoundAt(";", d, -1));
615  }
616  TEST(Delimiter, ByString) {
617    using absl::ByString;
618    TestComma(ByString(","));
619    ByString comma_string(",");
620    TestComma(comma_string);
621    absl::string_view abc("abc");
622    EXPECT_EQ(0, abc.find(""));  
623    ByString empty("");
624    EXPECT_FALSE(IsFoundAt("", empty, 0));
625    EXPECT_FALSE(IsFoundAt("a", empty, 0));
626    EXPECT_TRUE(IsFoundAt("ab", empty, 1));
627    EXPECT_TRUE(IsFoundAt("abc", empty, 1));
628  }
629  TEST(Split, ByChar) {
630    using absl::ByChar;
631    TestComma(ByChar(','));
632    ByChar comma_char(',');
633    TestComma(comma_char);
634  }
635  TEST(Delimiter, ByAnyChar) {
636    using absl::ByAnyChar;
637    ByAnyChar one_delim(",");
638    EXPECT_TRUE(IsFoundAt(",", one_delim, 0));
639    EXPECT_TRUE(IsFoundAt("a,", one_delim, 1));
640    EXPECT_TRUE(IsFoundAt("a,b", one_delim, 1));
641    EXPECT_TRUE(IsFoundAt(",b", one_delim, 0));
642    EXPECT_FALSE(IsFoundAt("", one_delim, -1));
643    EXPECT_FALSE(IsFoundAt(" ", one_delim, -1));
644    EXPECT_FALSE(IsFoundAt("a", one_delim, -1));
645    EXPECT_FALSE(IsFoundAt("a;b;c", one_delim, -1));
646    EXPECT_FALSE(IsFoundAt(";", one_delim, -1));
647    ByAnyChar two_delims(",;");
648    EXPECT_TRUE(IsFoundAt(",", two_delims, 0));
649    EXPECT_TRUE(IsFoundAt(";", two_delims, 0));
650    EXPECT_TRUE(IsFoundAt(",;", two_delims, 0));
651    EXPECT_TRUE(IsFoundAt(";,", two_delims, 0));
652    EXPECT_TRUE(IsFoundAt(",;b", two_delims, 0));
653    EXPECT_TRUE(IsFoundAt(";,b", two_delims, 0));
654    EXPECT_TRUE(IsFoundAt("a;,", two_delims, 1));
655    EXPECT_TRUE(IsFoundAt("a,;", two_delims, 1));
656    EXPECT_TRUE(IsFoundAt("a;,b", two_delims, 1));
657    EXPECT_TRUE(IsFoundAt("a,;b", two_delims, 1));
658    EXPECT_FALSE(IsFoundAt("", two_delims, -1));
659    EXPECT_FALSE(IsFoundAt(" ", two_delims, -1));
660    EXPECT_FALSE(IsFoundAt("a", two_delims, -1));
661    EXPECT_FALSE(IsFoundAt("a=b=c", two_delims, -1));
662    EXPECT_FALSE(IsFoundAt("=", two_delims, -1));
663    ByAnyChar empty("");
664    EXPECT_FALSE(IsFoundAt("", empty, 0));
665    EXPECT_FALSE(IsFoundAt("a", empty, 0));
666    EXPECT_TRUE(IsFoundAt("ab", empty, 1));
667    EXPECT_TRUE(IsFoundAt("abc", empty, 1));
668  }
669  TEST(Delimiter, ByLength) {
670    using absl::ByLength;
671    ByLength four_char_delim(4);
672    EXPECT_TRUE(IsFoundAt("abcde", four_char_delim, 4));
673    EXPECT_TRUE(IsFoundAt("abcdefghijklmnopqrstuvwxyz", four_char_delim, 4));
674    EXPECT_TRUE(IsFoundAt("a b,c\nd", four_char_delim, 4));
675    EXPECT_FALSE(IsFoundAt("", four_char_delim, 0));
676    EXPECT_FALSE(IsFoundAt("a", four_char_delim, 0));
677    EXPECT_FALSE(IsFoundAt("ab", four_char_delim, 0));
678    EXPECT_FALSE(IsFoundAt("abc", four_char_delim, 0));
679    EXPECT_FALSE(IsFoundAt("abcd", four_char_delim, 0));
680  }
681  TEST(Split, WorksWithLargeStrings) {
682  #if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
683      defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
684    constexpr size_t kSize = (uint32_t{1} << 26) + 1;  
685  #else
686    constexpr size_t kSize = (uint32_t{1} << 31) + 1;  
687  #endif
688    if (sizeof(size_t) > 4) {
689      std::string s(kSize, 'x');
690      s.back() = '-';
691      std::vector<absl::string_view> v = absl::StrSplit(s, '-');
692      EXPECT_EQ(2, v.size());
693      EXPECT_EQ('x', v[0][0]);
694      EXPECT_EQ('x', v[0][1]);
695      EXPECT_EQ('x', v[0][3]);
696      EXPECT_EQ("", v[1]);
697    }
698  }
699  TEST(SplitInternalTest, TypeTraits) {
700    EXPECT_FALSE(absl::strings_internal::HasMappedType<int>::value);
701    EXPECT_TRUE(
702        (absl::strings_internal::HasMappedType<std::map<int, int>>::value));
703    EXPECT_FALSE(absl::strings_internal::HasValueType<int>::value);
704    EXPECT_TRUE(
705        (absl::strings_internal::HasValueType<std::map<int, int>>::value));
706    EXPECT_FALSE(absl::strings_internal::HasConstIterator<int>::value);
707    EXPECT_TRUE(
708        (absl::strings_internal::HasConstIterator<std::map<int, int>>::value));
709    EXPECT_FALSE(absl::strings_internal::IsInitializerList<int>::value);
710    EXPECT_TRUE((absl::strings_internal::IsInitializerList<
711                 std::initializer_list<int>>::value));
712  }
713  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lstm_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_split_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>96      LayerParameter* x_static_transform_param = net_param->add_layer();
97      x_static_transform_param->CopyFrom(hidden_param);
98      x_static_transform_param->mutable_inner_product_param()->set_axis(1);
99      x_static_transform_param->set_name("W_xc_x_static");
100      x_static_transform_param->add_param()->set_name("W_xc_static");
101      x_static_transform_param->add_bottom("x_static");
102      x_static_transform_param->add_top("W_xc_x_static_preshape");
103      x_static_transform_param->add_propagate_down(true);
</pre></code></div>
                <div class="column column_space"><pre><code>290    TestConversionOperator<std::multiset<std::string>>(splitter);
291    TestConversionOperator<absl::btree_set<absl::string_view>>(splitter);
292    TestConversionOperator<absl::btree_set<std::string>>(splitter);
293    TestConversionOperator<absl::btree_multiset<absl::string_view>>(splitter);
294    TestConversionOperator<absl::btree_multiset<std::string>>(splitter);
295    TestConversionOperator<std::unordered_set<std::string>>(splitter);
296    TestMapConversionOperator<std::map<absl::string_view, absl::string_view>>(
297        splitter);
298    TestMapConversionOperator<std::map<absl::string_view, std::string>>(splitter);
299    TestMapConversionOperator<std::map<std::string, absl::string_view>>(splitter);
300    TestMapConversionOperator<std::map<std::string, std::string>>(splitter);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    