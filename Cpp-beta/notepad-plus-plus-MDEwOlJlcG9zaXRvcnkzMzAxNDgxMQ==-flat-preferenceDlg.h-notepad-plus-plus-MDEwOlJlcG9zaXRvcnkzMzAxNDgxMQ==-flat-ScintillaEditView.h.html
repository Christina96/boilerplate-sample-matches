
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 26.94350555287301%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.h</h3>
            <pre><code>1  #pragma once
2  #include "ControlsTab.h"
3  #include "preference_rc.h"
4  #include "Parameters.h"
5  #include "regExtDlg.h"
6  #include "WordStyleDlg.h"
7  class MiscSubDlg : public StaticDialog
8  {
9  public :
10  	MiscSubDlg() = default;
11  private :
12  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
13  };
14  class GeneralSubDlg : public StaticDialog
15  {
16  public :
17  	GeneralSubDlg() = default;
18  	void setTabbarAlternateIcons(bool enable = false);
19  private :
20  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
21  };
22  class EditingSubDlg : public StaticDialog
23  {
24  friend class PreferenceDlg;
25  public :
26  	EditingSubDlg() = default;
27  	~EditingSubDlg() {
28  		if (_tip != nullptr)
29  		{
30  			::DestroyWindow(_tip);
31  			_tip = nullptr;
32  		}
33  		for (auto& tip : _tips)
34  		{
35  			if (tip != nullptr)
36  			{
37  				::DestroyWindow(tip);
38  				tip = nullptr;
39  			}
40  		}
41  	};
42  private :
43  	HWND _tip = nullptr;
44  	HWND _tipNote = nullptr;
45  	HWND _tipAbb = nullptr;
46  	HWND _tipCodepoint = nullptr;
47  	HWND _tipNpcColor = nullptr;
48  	HWND _tipNpcInclude = nullptr;
49  	std::vector<HWND> _tips;
50  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
51  	void initScintParam();
52  	void changeLineHiliteMode(bool enableSlider);
53  };
54  class DarkModeSubDlg : public StaticDialog
55  {
56  public:
57  	DarkModeSubDlg() = default;
58  private:
59  	ColourPicker* _pBackgroundColorPicker = nullptr;
60  	ColourPicker* _pSofterBackgroundColorPicker = nullptr;
61  	ColourPicker* _pHotBackgroundColorPicker = nullptr;
62  	ColourPicker* _pPureBackgroundColorPicker = nullptr;
63  	ColourPicker* _pErrorBackgroundColorPicker = nullptr;
64  	ColourPicker* _pTextColorPicker = nullptr;
65  	ColourPicker* _pDarkerTextColorPicker = nullptr;
66  	ColourPicker* _pDisabledTextColorPicker = nullptr;
67  	ColourPicker* _pEdgeColorPicker = nullptr;
68  	ColourPicker* _pLinkColorPicker = nullptr;
69  	ColourPicker* _pHotEdgeColorPicker = nullptr;
70  	ColourPicker* _pDisabledEdgeColorPicker = nullptr;
71  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
72  	void enableCustomizedColorCtrls(bool doEnable);
73  	void move2CtrlLeft(int ctrlID, HWND handle2Move, int handle2MoveWidth, int handle2MoveHeight);
74  };
75  class MarginsBorderEdgeSubDlg : public StaticDialog
76  {
77  public :
78  	MarginsBorderEdgeSubDlg() = default;
79  private :
80  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam);
81  	void initScintParam();
82  };
83  struct LangID_Name
84  {
85  	LangType _id = L_TEXT;
86  	generic_string _name;
87  	LangID_Name(LangType id, const generic_string& name) : _id(id), _name(name){};
88  };
89  class NewDocumentSubDlg : public StaticDialog
90  {
91  public :
92  	NewDocumentSubDlg() = default;
93  private :
94  	void makeOpenAnsiAsUtf8(bool doIt){
95  		if (!doIt)
96  			::SendDlgItemMessage(_hSelf, IDC_CHECK_OPENANSIASUTF8, BM_SETCHECK, BST_UNCHECKED, 0);
<span onclick='openModal()' class='match'>97  		::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), doIt);
98  	};
99  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
</span>100  };
101  class DefaultDirectorySubDlg : public StaticDialog
102  {
103  public :
104  	DefaultDirectorySubDlg() = default;
105  private :
106  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
107  };
108  class RecentFilesHistorySubDlg : public StaticDialog
109  {
110  public :
111  	RecentFilesHistorySubDlg() = default;
112  private :
113  	void setCustomLen(int val);
114  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
115  };
116  class LanguageSubDlg : public StaticDialog
117  {
118  public :
119  	LanguageSubDlg() = default;
120  private :
121  	LexerStylerArray _lsArray;
122  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
123  	std::vector<LangMenuItem> _langList;
124  };
125  class HighlightingSubDlg : public StaticDialog
126  {
127  public :
128  	HighlightingSubDlg() = default;
129  private :
130  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
131  };
132  class SearchingSubDlg : public StaticDialog
133  {
134  public:
135  	SearchingSubDlg() = default;
136  private:
137  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
138  };
139  class PrintSubDlg : public StaticDialog
140  {
141  public :
142  	PrintSubDlg() = default;
143  private :
144  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
145  	std::vector<generic_string> varList;
146  	int _focusedEditCtrl = 0;
147  };
148  class BackupSubDlg : public StaticDialog
149  {
150  public :
151  	BackupSubDlg() = default;
152  private :
153  	void updateBackupSessionGUI();
154  	void updateBackupOnSaveGUI();
155  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
156  };
157  class AutoCompletionSubDlg : public StaticDialog
158  {
159  public :
160  	AutoCompletionSubDlg() = default;
161  private :
162  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
163  };
164  class MultiInstanceSubDlg : public StaticDialog
165  {
166  public :
167  	MultiInstanceSubDlg() = default;
168  private :
169  	const SYSTEMTIME _BTTF_time = {1985, 10, 6, 26, 16, 24, 42, 0};
170  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
171  };
172  class DelimiterSubDlg : public StaticDialog
173  {
174  friend class PreferenceDlg;
175  public :
176  	DelimiterSubDlg() = default;
177  	~DelimiterSubDlg() {
178  		if (_tip)
179  			::DestroyWindow(_tip);
180  	};
181  private :
182  	POINT _singleLineModePoint = {};
183  	POINT _multiLineModePoint = {};
184  	RECT _closerRect = {};
185  	RECT _closerLabelRect = {};
186  	HWND _tip = nullptr;
187  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
188  	void detectSpace(const char *text2Check, int & nbSp, int & nbTab) const;
189  	generic_string getWarningText(size_t nbSp, size_t nbTab) const;
190  	void setWarningIfNeed() const;
191  };
192  class CloudAndLinkSubDlg : public StaticDialog
193  {
194  public :
195  	CloudAndLinkSubDlg() = default;
196  private :
197  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
198  };
199  class SearchEngineSubDlg : public StaticDialog
200  {
201  public :
202  	SearchEngineSubDlg() = default;
203  private :
204  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
205  };
206  class PerformanceSubDlg : public StaticDialog
207  {
208  friend class PreferenceDlg;
209  public :
210  	PerformanceSubDlg() = default;
211  	~PerformanceSubDlg() {
212  		if (_largeFileRestrictionTip)
213  			::DestroyWindow(_largeFileRestrictionTip);
214  	};
215  private :
216  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
217  	HWND _largeFileRestrictionTip = nullptr;
218  };
219  class PreferenceDlg : public StaticDialog
220  {
221  friend class NativeLangSpeaker;
222  friend class Notepad_plus;
223  public :
224  	PreferenceDlg() = default;
225  	void doDialog(bool isRTL = false) {
226  		if (!isCreated())
227  		{
228  			create(IDD_PREFERENCE_BOX, isRTL);
229  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
230  		}
231  		display();
232  	};
233  	bool renameDialogTitle(const TCHAR *internalName, const TCHAR *newName);
234  	int getListSelectedIndex() const {
235  		return static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_LIST_DLGTITLE, LB_GETCURSEL, 0, 0));
236  	};
237  	void showDialogByName(const TCHAR *name) const;
238  	bool setListSelection(size_t currentSel) const;
239  	bool goToSection(size_t iPage, intptr_t ctrlID = -1);
240  	void destroy() override;
241  private :
242  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
243  	void makeCategoryList();
244  	int32_t getIndexFromName(const TCHAR *name) const;
245  	void showDialogByIndex(size_t index) const;
246  	WindowVector _wVector;
247  	GeneralSubDlg _generalSubDlg;
248  	EditingSubDlg _editingSubDlg;
249  	DarkModeSubDlg _darkModeSubDlg;
250  	MarginsBorderEdgeSubDlg _marginsBorderEdgeSubDlg;
251  	MiscSubDlg _miscSubDlg;
252  	RegExtDlg _fileAssocDlg;
253  	LanguageSubDlg _languageSubDlg;
254  	HighlightingSubDlg _highlightingSubDlg;
255  	PrintSubDlg _printSubDlg;
256  	NewDocumentSubDlg _newDocumentSubDlg;
257  	DefaultDirectorySubDlg	_defaultDirectorySubDlg;
258  	RecentFilesHistorySubDlg _recentFilesHistorySubDlg;
259  	BackupSubDlg _backupSubDlg;
260  	AutoCompletionSubDlg _autoCompletionSubDlg;
261  	MultiInstanceSubDlg _multiInstanceSubDlg;
262  	DelimiterSubDlg _delimiterSubDlg;
263  	PerformanceSubDlg _performanceSubDlg;
264  	CloudAndLinkSubDlg _cloudAndLinkSubDlg;
265  	SearchEngineSubDlg _searchEngineSubDlg;
266  	SearchingSubDlg _searchingSubDlg;
267  };
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.h</h3>
            <pre><code>1  #pragma once
2  #include "Scintilla.h"
3  #include "ScintillaRef.h"
4  #include "SciLexer.h"
5  #include "Buffer.h"
6  #include "colors.h"
7  #include "UserDefineDialog.h"
8  #include "rgba_icons.h"
9  #ifndef WM_MOUSEWHEEL
10  #define WM_MOUSEWHEEL 0x020A
11  #endif 
12  #ifndef WM_MOUSEHWHEEL
13  #define WM_MOUSEHWHEEL 0x020E
14  #endif 
15  #ifndef WM_APPCOMMAND
16  #define WM_APPCOMMAND                   0x0319
17  #define APPCOMMAND_BROWSER_BACKWARD       1
18  #define APPCOMMAND_BROWSER_FORWARD        2
19  #define FAPPCOMMAND_MASK  0xF000
20  #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
21  #endif 
22  class NppParameters;
23  #define NB_WORD_LIST 4
24  #define WORD_LIST_LEN 256
25  typedef sptr_t(*SCINTILLA_FUNC) (void *, unsigned int, uptr_t, sptr_t);
26  typedef void * SCINTILLA_PTR;
27  #define WM_DOCK_USERDEFINE_DLG      (SCINTILLA_USER + 1)
28  #define WM_UNDOCK_USERDEFINE_DLG    (SCINTILLA_USER + 2)
29  #define WM_CLOSE_USERDEFINE_DLG     (SCINTILLA_USER + 3)
30  #define WM_REMOVE_USERLANG          (SCINTILLA_USER + 4)
31  #define WM_RENAME_USERLANG          (SCINTILLA_USER + 5)
32  #define WM_REPLACEALL_INOPENEDDOC   (SCINTILLA_USER + 6)
33  #define WM_FINDALL_INOPENEDDOC      (SCINTILLA_USER + 7)
34  #define WM_DOOPEN                   (SCINTILLA_USER + 8)
35  #define WM_FINDINFILES              (SCINTILLA_USER + 9)
36  #define WM_REPLACEINFILES           (SCINTILLA_USER + 10)
37  #define WM_FINDALL_INCURRENTDOC     (SCINTILLA_USER + 11)
38  #define WM_FRSAVE_INT               (SCINTILLA_USER + 12)
39  #define WM_FRSAVE_STR               (SCINTILLA_USER + 13)
40  #define WM_FINDALL_INCURRENTFINDER  (SCINTILLA_USER + 14)
41  #define WM_FINDINPROJECTS           (SCINTILLA_USER + 15)
42  #define WM_REPLACEINPROJECTS        (SCINTILLA_USER + 16)
43  const int NB_FOLDER_STATE = 7;
44  const int CP_CHINESE_TRADITIONAL = 950;
45  const int CP_CHINESE_SIMPLIFIED = 936;
46  const int CP_JAPANESE = 932;
47  const int CP_KOREAN = 949;
48  const int CP_GREEK = 1253;
49  #define LIST_NONE 0
50  #define LIST_0 1
51  #define LIST_1 2
52  #define LIST_2 4
53  #define LIST_3 8
54  #define LIST_4 16
55  #define LIST_5 32
56  #define LIST_6 64
57  #define LIST_7 128
58  #define LIST_8 256
59  const bool fold_uncollapse = true;
60  const bool fold_collapse = false;
61  #define MAX_FOLD_COLLAPSE_LEVEL	8
62  enum TextCase : UCHAR
63  {
64  	UPPERCASE,
65  	LOWERCASE,
66  	TITLECASE_FORCE,
67  	TITLECASE_BLEND,
68  	SENTENCECASE_FORCE,
69  	SENTENCECASE_BLEND,
70  	INVERTCASE,
71  	RANDOMCASE
72  };
73  const UCHAR MASK_FORMAT = 0x03;
74  const UCHAR BASE_10 = 0x00; 
75  const UCHAR BASE_16 = 0x01; 
76  const UCHAR BASE_08 = 0x02; 
77  const UCHAR BASE_02 = 0x03; 
78  const int MARK_BOOKMARK = 20;
79  const int MARK_HIDELINESBEGIN = 19;
80  const int MARK_HIDELINESEND = 18;
81  constexpr char g_ZWSP[] = "\xE2\x80\x8B";
82  const std::vector<std::vector<const char*>> g_ccUniEolChars =
83  {
84  	{"\x00", "NUL", "U+0000"},               
85  	{"\x01", "SOH", "U+0001"},               
86  	{"\x02", "STX", "U+0002"},               
87  	{"\x03", "ETX", "U+0003"},               
88  	{"\x04", "EOT", "U+0004"},               
89  	{"\x05", "ENQ", "U+0005"},               
90  	{"\x06", "ACK", "U+0006"},               
91  	{"\a", "BEL", "U+0007"},                 
92  	{"\b", "BS", "U+0008"},                  
93  	{"\v", "VT", "U+000B"},                  
94  	{"\f", "FF", "U+000C"},                  
95  	{"\x0E", "SO", "U+000E"},                
96  	{"\x0F", "SI", "U+000F"},                
97  	{"\x10", "DLE", "U+0010"},               
98  	{"\x11", "DC1", "U+0011"},               
99  	{"\x12", "DC2", "U+0012"},               
100  	{"\x13", "DC3", "U+0013"},               
101  	{"\x14", "DC4", "U+0014"},               
102  	{"\x15", "NAK", "U+0015"},               
103  	{"\x16", "SYN", "U+0016"},               
104  	{"\x17", "ETB", "U+0017"},               
105  	{"\x18", "CAN", "U+0018"},               
106  	{"\x19", "EM", "U+0019"},                
107  	{"\x1A", "SUB", "U+001A"},               
108  	{"\x1B", "ESC", "U+001B"},               
109  	{"\x1C", "FS", "U+001C"},                
110  	{"\x1D", "GS", "U+001D"},                
111  	{"\x1E", "RS", "U+001E"},                
112  	{"\x1F", "US", "U+001F"},                
113  	{"\x7F", "DEL", "U+007F"},               
114  	{"\xC2\x80", "PAD", "U+0080"},           
115  	{"\xC2\x81", "HOP", "U+0081"},           
116  	{"\xC2\x82", "BPH", "U+0082"},           
117  	{"\xC2\x83", "NBH", "U+0083"},           
118  	{"\xC2\x84", "IND", "U+0084"},           
119  	{"\xC2\x86", "SSA", "U+0086"},           
120  	{"\xC2\x87", "ESA", "U+0087"},           
121  	{"\xC2\x88", "HTS", "U+0088"},           
122  	{"\xC2\x89", "HTJ", "U+0089"},           
123  	{"\xC2\x8A", "LTS", "U+008A"},           
124  	{"\xC2\x8B", "PLD", "U+008B"},           
125  	{"\xC2\x8C", "PLU", "U+008C"},           
126  	{"\xC2\x8D", "RI", "U+008D"},            
127  	{"\xC2\x8E", "SS2", "U+008E"},           
128  	{"\xC2\x8F", "SS3", "U+008F"},           
129  	{"\xC2\x90", "DCS", "U+0090"},           
130  	{"\xC2\x91", "PU1", "U+0091"},           
131  	{"\xC2\x92", "PU2", "U+0092"},           
132  	{"\xC2\x93", "STS", "U+0093"},           
133  	{"\xC2\x94", "CCH", "U+0094"},           
134  	{"\xC2\x95", "MW", "U+0095"},            
135  	{"\xC2\x96", "SPA", "U+0096"},           
136  	{"\xC2\x97", "EPA", "U+0097"},           
137  	{"\xC2\x98", "SOS", "U+0098"},           
138  	{"\xC2\x99", "SGCI", "U+0099"},          
139  	{"\xC2\x9A", "SCI", "U+009A"},           
140  	{"\xC2\x9B", "CSI", "U+009B"},           
141  	{"\xC2\x9C", "ST", "U+009C"},            
142  	{"\xC2\x9D", "OSC", "U+009D"},           
143  	{"\xC2\x9E", "PM", "U+009E"},            
144  	{"\xC2\x9F", "APC", "U+009F"},           
145  	{"\xC2\x85", "NEL", "U+0085"},           
146  	{"\xE2\x80\xA8", "LS", "U+2028"},        
147  	{"\xE2\x80\xA9", "PS", "U+2029"}         
148  };
149  const std::vector<std::vector<const char*>> g_nonPrintingChars =
150  {
151  	{"\xC2\xA0", "NBSP", "U+00A0"},          
152  	{"\xC2\xAD", "SHY", "U+00AD"},           
153  	{"\xD8\x9C", "ALM", "U+061C"},           
154  	{"\xDC\x8F", "SAM", "U+070F"},           
155  	{"\xE1\x9A\x80", "OSPM", "U+1680"},      
156  	{"\xE1\xA0\x8E", "MVS", "U+180E"},       
157  	{"\xE2\x80\x80", "NQSP", "U+2000"},      
158  	{"\xE2\x80\x81", "MQSP", "U+2001"},      
159  	{"\xE2\x80\x82", "ENSP", "U+2002"},      
160  	{"\xE2\x80\x83", "EMSP", "U+2003"},      
161  	{"\xE2\x80\x84", "3/MSP", "U+2004"},     
162  	{"\xE2\x80\x85", "4/MSP", "U+2005"},     
163  	{"\xE2\x80\x86", "6/MSP", "U+2006"},     
164  	{"\xE2\x80\x87", "FSP", "U+2007"},       
165  	{"\xE2\x80\x88", "PSP", "U+2008"},       
166  	{"\xE2\x80\x89", "THSP", "U+2009"},      
167  	{"\xE2\x80\x8A", "HSP", "U+200A"},       
168  	{"\xE2\x80\x8B", "ZWSP", "U+200B"},      
169  	{"\xE2\x80\x8C", "ZWNJ", "U+200C"},      
170  	{"\xE2\x80\x8D", "ZWJ", "U+200D"},       
171  	{"\xE2\x80\x8E", "LRM", "U+200E"},       
172  	{"\xE2\x80\x8F", "RLM", "U+200F"},       
173  	{"\xE2\x80\xAA", "LRE", "U+202A"},       
174  	{"\xE2\x80\xAB", "RLE", "U+202B"},       
175  	{"\xE2\x80\xAC", "PDF", "U+202C"},       
176  	{"\xE2\x80\xAD", "LRO", "U+202D"},       
177  	{"\xE2\x80\xAE", "RLO", "U+202E"},       
178  	{"\xE2\x80\xAF", "NNBSP", "U+202F"},     
179  	{"\xE2\x81\x9F", "MMSP", "U+205F"},      
180  	{"\xE2\x81\xA0", "WJ", "U+2060"},        
181  	{"\xE2\x81\xA1", "(FA)", "U+2061"},      
182  	{"\xE2\x81\xA2", "(IT)", "U+2062"},      
183  	{"\xE2\x81\xA3", "(IS)", "U+2063"},      
184  	{"\xE2\x81\xA4", "(IP)", "U+2064"},      
185  	{"\xE2\x81\xA6", "LRI", "U+2066"},       
186  	{"\xE2\x81\xA7", "RLI", "U+2067"},       
187  	{"\xE2\x81\xA8", "FSI", "U+2068"},       
188  	{"\xE2\x81\xA9", "PDI", "U+2069"},       
189  	{"\xE2\x81\xAA", "ISS", "U+206A"},       
190  	{"\xE2\x81\xAB", "ASS", "U+206B"},       
191  	{"\xE2\x81\xAC", "IAFS", "U+206C"},      
192  	{"\xE2\x81\xAD", "AAFS", "U+206D"},      
193  	{"\xE2\x81\xAE", "NADS", "U+206E"},      
194  	{"\xE2\x81\xAF", "NODS", "U+206F"},      
195  	{"\xE3\x80\x80", "IDSP", "U+3000"},      
196  	{"\xEF\xBB\xBF", "ZWNBSP", "U+FEFF"},    
197  	{"\xEF\xBF\xB9", "IAA", "U+FFF9"},       
198  	{"\xEF\xBF\xBA", "IAS", "U+FFFA"},       
199  	{"\xEF\xBF\xBB", "IAT", "U+FFFB"}        
200  };
201  int getNbDigits(int aNum, int base);
202  TCHAR* int2str(TCHAR* str, int strLen, int number, int base, int nbDigits, ColumnEditorParam::leadingChoice lead);
203  typedef LRESULT (WINAPI *CallWindowProcFunc) (WNDPROC,HWND,UINT,WPARAM,LPARAM);
204  const bool L2R = true;
205  const bool R2L = false;
206  struct ColumnModeInfo {
207  	intptr_t _selLpos = 0;
208  	intptr_t _selRpos = 0;
209  	intptr_t _order = -1; 
210  	bool _direction = L2R; 
211  	intptr_t _nbVirtualAnchorSpc = 0;
212  	intptr_t _nbVirtualCaretSpc = 0;
213  	ColumnModeInfo(intptr_t lPos, intptr_t rPos, intptr_t order, bool dir = L2R, intptr_t vAnchorNbSpc = 0, intptr_t vCaretNbSpc = 0)
214  		: _selLpos(lPos), _selRpos(rPos), _order(order), _direction(dir), _nbVirtualAnchorSpc(vAnchorNbSpc), _nbVirtualCaretSpc(vCaretNbSpc){};
215  	bool isValid() const {
216  		return (_order >= 0 && _selLpos >= 0 && _selRpos >= 0 && _selLpos <= _selRpos);
217  	};
218  };
219  struct SortInSelectOrder {
220  	bool operator() (ColumnModeInfo & l, ColumnModeInfo & r) {
221  		return (l._order < r._order);
222  	}
223  };
224  struct SortInPositionOrder {
225  	bool operator() (ColumnModeInfo & l, ColumnModeInfo & r) {
226  		return (l._selLpos < r._selLpos);
227  	}
228  };
229  typedef std::vector<ColumnModeInfo> ColumnModeInfos;
230  struct LanguageNameInfo {
231  	const TCHAR* _langName = nullptr;
232  	const TCHAR* _shortName = nullptr;
233  	const TCHAR* _longName = nullptr;
234  	LangType _langID = L_TEXT;
235  	const char* _lexerID = nullptr;
236  };
237  #define URL_INDIC 8
238  class ISorter;
239  class ScintillaEditView : public Window
240  {
241  friend class Finder;
242  public:
243  	ScintillaEditView(): Window() {
244  		++_refCount;
245  	};
246  	virtual ~ScintillaEditView()
247  	{
248  		--_refCount;
249  		if ((!_refCount)&&(_SciInit))
250  		{
251  			Scintilla_ReleaseResources();
252  			for (BufferStyleMap::iterator it(_hotspotStyles.begin()); it != _hotspotStyles.end(); ++it )
253  			{
254  				delete it->second;
255  			}
256  		}
257  	};
258  	virtual void destroy()
259  	{
260  		::DestroyWindow(_hSelf);
261  		_hSelf = NULL;
262  		_pScintillaFunc = NULL;
263  	};
264  	virtual void init(HINSTANCE hInst, HWND hPere);
265  	LRESULT execute(UINT Msg, WPARAM wParam=0, LPARAM lParam=0) const {
266  		try {
267  			return (_pScintillaFunc) ? _pScintillaFunc(_pScintillaPtr, Msg, wParam, lParam) : -1;
268  		}
269  		catch (...)
270  		{
271  			return -1;
272  		}
273  	};
274  	void activateBuffer(BufferID buffer, bool force = false);
275  	void getCurrentFoldStates(std::vector<size_t> & lineStateVector);
276  	void syncFoldStateWith(const std::vector<size_t> & lineStateVectorNew);
277  	void getText(char *dest, size_t start, size_t end) const;
278  	void getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end) const;
279  	void getGenericText(TCHAR *dest, size_t deslen, size_t start, size_t end, intptr_t* mstart, intptr_t* mend) const;
280  	generic_string getGenericTextAsString(size_t start, size_t end) const;
281  	void insertGenericTextFrom(size_t position, const TCHAR *text2insert) const;
282  	void replaceSelWith(const char * replaceText);
283  	intptr_t getSelectedTextCount() {
284  		Sci_CharacterRangeFull range = getSelection();
285  		return (range.cpMax - range.cpMin);
286  	};
287  	void getVisibleStartAndEndPosition(intptr_t* startPos, intptr_t* endPos);
288      char * getWordFromRange(char * txt, size_t size, size_t pos1, size_t pos2);
289  	char * getSelectedText(char * txt, size_t size, bool expand = true);
290      char * getWordOnCaretPos(char * txt, size_t size);
291      TCHAR * getGenericWordOnCaretPos(TCHAR * txt, int size);
292  	TCHAR * getGenericSelectedText(TCHAR * txt, int size, bool expand = true);
293  	intptr_t searchInTarget(const TCHAR * Text2Find, size_t lenOfText2Find, size_t fromPos, size_t toPos) const;
294  	void appandGenericText(const TCHAR * text2Append) const;
295  	void addGenericText(const TCHAR * text2Append) const;
296  	void addGenericText(const TCHAR * text2Append, intptr_t* mstart, intptr_t* mend) const;
297  	intptr_t replaceTarget(const TCHAR * str2replace, intptr_t fromTargetPos = -1, intptr_t toTargetPos = -1) const;
298  	intptr_t replaceTargetRegExMode(const TCHAR * re, intptr_t fromTargetPos = -1, intptr_t toTargetPos = -1) const;
299  	void showAutoComletion(size_t lenEntered, const TCHAR * list);
300  	void showCallTip(size_t startPos, const TCHAR * def);
301  	generic_string getLine(size_t lineNumber);
302  	void getLine(size_t lineNumber, TCHAR * line, size_t lineBufferLen);
303  	void addText(size_t length, const char *buf);
304  	void insertNewLineAboveCurrentLine();
305  	void insertNewLineBelowCurrentLine();
306  	void saveCurrentPos();
307  	void restoreCurrentPosPreStep();
308  	void restoreCurrentPosPostStep();
309  	void beginOrEndSelect(bool isColumnMode);
310  	bool beginEndSelectedIsStarted() const {
311  		return _beginSelectPosition != -1;
312  	};
313  	size_t getCurrentDocLen() const {
314  		return size_t(execute(SCI_GETLENGTH));
315  	};
316  	Sci_CharacterRangeFull getSelection() const {
317  		Sci_CharacterRangeFull crange{};
318  		crange.cpMin = execute(SCI_GETSELECTIONSTART);
319  		crange.cpMax = execute(SCI_GETSELECTIONEND);
320  		return crange;
321  	};
322  	void getWordToCurrentPos(TCHAR * str, intptr_t strLen) const {
323  		auto caretPos = execute(SCI_GETCURRENTPOS);
324  		auto startPos = execute(SCI_WORDSTARTPOSITION, caretPos, true);
325  		str[0] = '\0';
326  		if ((caretPos - startPos) < strLen)
327  			getGenericText(str, strLen, startPos, caretPos);
328  	};
329      void doUserDefineDlg(bool willBeShown = true, bool isRTL = false) {
330          _userDefineDlg.doDialog(willBeShown, isRTL);
331      };
332      static UserDefineDialog * getUserDefineDlg() {return &_userDefineDlg;};
333      void setCaretColorWidth(int color, int width = 1) const {
334          execute(SCI_SETCARETFORE, color);
335          execute(SCI_SETCARETWIDTH, width);
336      };
337  	void beSwitched() {
338  		_userDefineDlg.setScintilla(this);
339  	};
340      static const int _SC_MARGE_LINENUMBER;
341      static const int _SC_MARGE_SYMBOL;
342      static const int _SC_MARGE_FOLDER;
343      static const int _SC_MARGE_CHANGEHISTORY;
344      void showMargin(int whichMarge, bool willBeShowed = true);
345      void showChangeHistoryMargin(bool willBeShowed = true);
346      bool hasMarginShowed(int witchMarge) {
347  		return (execute(SCI_GETMARGINWIDTHN, witchMarge, 0) != 0);
348      };
349      void updateBeginEndSelectPosition(bool is_insert, size_t position, size_t length);
350      void marginClick(Sci_Position position, int modifiers);
351      void setMakerStyle(folderStyle style) {
352  		bool display;
353  		if (style == FOLDER_STYLE_NONE)
354  		{
355  			style = FOLDER_STYLE_BOX;
356  			display = false;
357  		}
358  		else
359  		{
360  			display = true;
361  		}
362  		COLORREF foldfgColor = white, foldbgColor = grey, activeFoldFgColor = red;
363  		getFoldColor(foldfgColor, foldbgColor, activeFoldFgColor);
364  		for (int i = 0 ; i < NB_FOLDER_STATE ; ++i)
365  			defineMarker(_markersArray[FOLDER_TYPE][i], _markersArray[style][i], foldfgColor, foldbgColor, activeFoldFgColor);
366  		showMargin(ScintillaEditView::_SC_MARGE_FOLDER, display);
367      };
368  	void setWrapMode(lineWrapMethod meth) {
369  		int mode = (meth == LINEWRAP_ALIGNED)?SC_WRAPINDENT_SAME:\
370  				(meth == LINEWRAP_INDENT)?SC_WRAPINDENT_INDENT:SC_WRAPINDENT_FIXED;
371  		execute(SCI_SETWRAPINDENTMODE, mode);
372  	};
373  	void showWSAndTab(bool willBeShowed = true) {
374  		execute(SCI_SETVIEWWS, willBeShowed?SCWS_VISIBLEALWAYS:SCWS_INVISIBLE);
375  		execute(SCI_SETWHITESPACESIZE, 2, 0);
376  	};
377  	bool isShownSpaceAndTab() {
378  		return (execute(SCI_GETVIEWWS) != 0);
379  	};
380  	void showEOL(bool willBeShowed = true) {
381  		execute(SCI_SETVIEWEOL, willBeShowed);
382  	};
383  	bool isShownEol() {
384  		return (execute(SCI_GETVIEWEOL) != 0);
385  	};
386  	void showNpc(bool willBeShowed = true, bool isSearchResult = false);
387  	bool isShownNpc() {
388  		auto& svp = NppParameters::getInstance().getSVP();
389  		return svp._npcShow;
390  	};
391  	void maintainStateForNpc() {
392  		const auto& svp = NppParameters::getInstance().getSVP();
393  		const bool isShownNpc = svp._npcShow;
394  		const bool isShownCcUniEol = svp._ccUniEolShow;
395  		if (isShownNpc && isShownCcUniEol)
396  		{
397  			showNpc(true);
398  			showCcUniEol(true);
399  			if (svp._eolMode != svp.roundedRectangleText)
400  			{
401  				setCRLF();
402  			}
403  		}
404  		else if (!isShownNpc && isShownCcUniEol)
405  		{
406  			showNpc(false);
407  		}
408  		else
409  		{
410  			showCcUniEol(false);
411  		}
412  	}
413  	void showCcUniEol(bool willBeShowed = true, bool isSearchResult = false);
414  	bool isShownCcUniEol() {
415  		auto& svp = NppParameters::getInstance().getSVP();
416  		return svp._ccUniEolShow;
417  	};
418  	void showInvisibleChars(bool willBeShowed = true) {
419  		showNpc(willBeShowed);
420  		showCcUniEol(willBeShowed);
421  		showWSAndTab(willBeShowed);
422  		showEOL(willBeShowed);
423  	};
424  	void showIndentGuideLine(bool willBeShowed = true);
425  	bool isShownIndentGuide() const {
426  		return (execute(SCI_GETINDENTATIONGUIDES) != 0);
427  	};
428      void wrap(bool willBeWrapped = true) {
429          execute(SCI_SETWRAPMODE, willBeWrapped);
430      };
431      bool isWrap() const {
432          return (execute(SCI_GETWRAPMODE) == SC_WRAP_WORD);
433      };
434  	bool isWrapSymbolVisible() const {
435  		return (execute(SCI_GETWRAPVISUALFLAGS) != SC_WRAPVISUALFLAG_NONE);
436  	};
437      void showWrapSymbol(bool willBeShown = true) {
438  		execute(SCI_SETWRAPVISUALFLAGSLOCATION, SC_WRAPVISUALFLAGLOC_DEFAULT);
439  		execute(SCI_SETWRAPVISUALFLAGS, willBeShown?SC_WRAPVISUALFLAG_END:SC_WRAPVISUALFLAG_NONE);
440      };
441  	intptr_t getCurrentLineNumber()const {
442  		return execute(SCI_LINEFROMPOSITION, execute(SCI_GETCURRENTPOS));
443  	};
444  	intptr_t lastZeroBasedLineNumber() const {
445  		auto endPos = execute(SCI_GETLENGTH);
446  		return execute(SCI_LINEFROMPOSITION, endPos);
447  	};
448  	intptr_t getCurrentXOffset()const{
449  		return execute(SCI_GETXOFFSET);
450  	};
451  	void setCurrentXOffset(long xOffset){
452  		execute(SCI_SETXOFFSET,xOffset);
453  	};
454  	void scroll(intptr_t column, intptr_t line){
455  		execute(SCI_LINESCROLL, column, line);
456  	};
457  	intptr_t getCurrentPointX()const{
458  		return execute(SCI_POINTXFROMPOSITION, 0, execute(SCI_GETCURRENTPOS));
459  	};
460  	intptr_t getCurrentPointY()const{
461  		return execute(SCI_POINTYFROMPOSITION, 0, execute(SCI_GETCURRENTPOS));
462  	};
463  	intptr_t getTextHeight()const{
464  		return execute(SCI_TEXTHEIGHT);
465  	};
466  	int getTextZoneWidth() const;
467  	void gotoLine(intptr_t line){
468  		if (line < execute(SCI_GETLINECOUNT))
469  			execute(SCI_GOTOLINE,line);
470  	};
471  	intptr_t getCurrentColumnNumber() const {
472          return execute(SCI_GETCOLUMN, execute(SCI_GETCURRENTPOS));
473      };
474  	std::pair<size_t, size_t> getSelectedCharsAndLinesCount(long long maxSelectionsForLineCount = -1) const;
475  	size_t getUnicodeSelectedLength() const;
476  	intptr_t getLineLength(size_t line) const {
477  		return execute(SCI_GETLINEENDPOSITION, line) - execute(SCI_POSITIONFROMLINE, line);
478  	};
479  	intptr_t getLineIndent(size_t line) const {
480  		return execute(SCI_GETLINEINDENTATION, line);
481  	};
482  	void setLineIndent(size_t line, size_t indent) const;
483  	void updateLineNumbersMargin(bool forcedToHide) {
484  		const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
485  		if (forcedToHide)
486  		{
487  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, 0);
488  		}
489  		else if (svp._lineNumberMarginShow)
490  		{
491  			updateLineNumberWidth();
492  		}
493  		else
494  		{
495  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, 0);
496  		}
497  	}
498  	void updateLineNumberWidth();
499  	void performGlobalStyles();
500  	void expand(size_t& line, bool doExpand, bool force = false, intptr_t visLevels = 0, intptr_t level = -1);
501  	std::pair<size_t, size_t> getSelectionLinesRange(intptr_t selectionNumber = -1) const;
502      void currentLinesUp() const;
503      void currentLinesDown() const;
504  	intptr_t caseConvertRange(intptr_t start, intptr_t end, TextCase caseToConvert);
505  	void changeCase(__inout wchar_t * const strWToConvert, const int & nbChars, const TextCase & caseToConvert) const;
506  	void convertSelectedTextTo(const TextCase & caseToConvert);
507  	void setMultiSelections(const ColumnModeInfos & cmi);
508      void convertSelectedTextToLowerCase() {
509  		if ((NppParameters::getInstance()).isTransparentAvailable())
510  			convertSelectedTextTo(LOWERCASE);
511  		else
512  			execute(SCI_LOWERCASE);
513  	};
514      void convertSelectedTextToUpperCase() {
515  		if ((NppParameters::getInstance()).isTransparentAvailable())
516  			convertSelectedTextTo(UPPERCASE);
517  		else
518  			execute(SCI_UPPERCASE);
519  	};
520  	void convertSelectedTextToNewerCase(const TextCase & caseToConvert) {
521  		if ((NppParameters::getInstance()).isTransparentAvailable())
522  			convertSelectedTextTo(caseToConvert);
523  		else
524  			::MessageBox(_hSelf, TEXT("This function needs a newer OS version."), TEXT("Change Case Error"), MB_OK | MB_ICONHAND);
525  	};
526  	bool isFoldIndentationBased() const;
527  	void collapseFoldIndentationBased(int level2Collapse, bool mode);
528  	void collapse(int level2Collapse, bool mode);
529  	void foldAll(bool mode);
530  	void fold(size_t line, bool mode);
531  	bool isFolded(size_t line) const {
532  		return (execute(SCI_GETFOLDEXPANDED, line) != 0);
533  	};
534  	bool isCurrentLineFolded() const;
535  	void foldCurrentPos(bool mode);
536  	int getCodepage() const {return _codepage;};
537  	ColumnModeInfos getColumnModeSelectInfo();
538  	void columnReplace(ColumnModeInfos & cmi, const TCHAR *str);
539  	void columnReplace(ColumnModeInfos & cmi, int initial, int incr, int repeat, UCHAR format, ColumnEditorParam::leadingChoice lead);
540  	void clearIndicator(int indicatorNumber) {
541  		size_t docStart = 0;
542  		size_t docEnd = getCurrentDocLen();
543  		execute(SCI_SETINDICATORCURRENT, indicatorNumber);
544  		execute(SCI_INDICATORCLEARRANGE, docStart, docEnd - docStart);
545  	};
546  	bool getIndicatorRange(size_t indicatorNumber, size_t* from = NULL, size_t* to = NULL, size_t* cur = NULL);
547  	static LanguageNameInfo _langNameInfoArray[L_EXTERNAL+1];
548  	void bufferUpdated(Buffer * buffer, int mask);
549  	BufferID getCurrentBufferID() { return _currentBufferID; };
550  	Buffer * getCurrentBuffer() { return _currentBuffer; };
551  	void setCurrentBuffer(Buffer *buf2set) { _currentBuffer = buf2set; };
552  	void styleChange();
553  	void hideLines();
554  	bool markerMarginClick(intptr_t lineNumber);	
555  	void notifyMarkers(Buffer * buf, bool isHide, size_t location, bool del);
556  	void runMarkers(bool doHide, size_t searchStart, bool endOfDoc, bool doDelete);
557  	bool isSelecting() const {
558  		static Sci_CharacterRangeFull previousSelRange = getSelection();
559  		Sci_CharacterRangeFull currentSelRange = getSelection();
560  		if (currentSelRange.cpMin == currentSelRange.cpMax)
561  		{
562  			previousSelRange = currentSelRange;
563  			return false;
564  		}
565  		if ((previousSelRange.cpMin == currentSelRange.cpMin) || (previousSelRange.cpMax == currentSelRange.cpMax))
566  		{
567  			previousSelRange = currentSelRange;
568  			return true;
569  		}
570  		previousSelRange = currentSelRange;
571  		return false;
572  	};
573  	bool isPythonStyleIndentation(LangType typeDoc) const{
574  		return (typeDoc == L_PYTHON || typeDoc == L_COFFEESCRIPT || typeDoc == L_HASKELL ||\
575  			typeDoc == L_C || typeDoc == L_CPP || typeDoc == L_OBJC || typeDoc == L_CS || typeDoc == L_JAVA ||\
576  			typeDoc == L_PHP || typeDoc == L_JS || typeDoc == L_JAVASCRIPT || typeDoc == L_MAKEFILE ||\
577  			typeDoc == L_ASN1 || typeDoc == L_GDSCRIPT);
578  	};
579  	void defineDocType(LangType typeDoc);	
580  	void addCustomWordChars();
581  	void restoreDefaultWordChars();
582  	void setWordChars();
583  	void setCRLF(long color = -1);
584  	void setNpcAndCcUniEOL(long color = -1);
585  	void mouseWheel(WPARAM wParam, LPARAM lParam) {
<span onclick='openModal()' class='match'>586  		scintillaNew_Proc(_hSelf, WM_MOUSEWHEEL, wParam, lParam);
587  	};
588  	void setHotspotStyle(const Style& styleToSet);
589      void setTabSettings(Lang *lang);
</span>590  	bool isWrapRestoreNeeded() const {return _wrapRestoreNeeded;};
591  	void setWrapRestoreNeeded(bool isWrapRestoredNeeded) {_wrapRestoreNeeded = isWrapRestoredNeeded;};
592  	bool isCJK() const {
593  		return ((_codepage == CP_CHINESE_TRADITIONAL) || (_codepage == CP_CHINESE_SIMPLIFIED) ||
594  			    (_codepage == CP_JAPANESE) || (_codepage == CP_KOREAN));
595  	};
596  	void scrollPosToCenter(size_t pos);
597  	generic_string getEOLString();
598  	void setBorderEdge(bool doWithBorderEdge);
599  	void sortLines(size_t fromLine, size_t toLine, ISorter *pSort);
600  	void changeTextDirection(bool isRTL);
601  	bool isTextDirectionRTL() const;
602  	void setPositionRestoreNeeded(bool val) { _positionRestoreNeeded = val; };
603  	void markedTextToClipboard(int indiStyle, bool doAll = false);
604  	void removeAnyDuplicateLines();
605  protected:
606  	static bool _SciInit;
607  	static int _refCount;
608      static UserDefineDialog _userDefineDlg;
609      static const int _markersArray[][NB_FOLDER_STATE];
610  	static LRESULT CALLBACK scintillaStatic_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
611  	LRESULT scintillaNew_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
612  	SCINTILLA_FUNC _pScintillaFunc = nullptr;
613  	SCINTILLA_PTR  _pScintillaPtr = nullptr;
614  	static WNDPROC _scintillaDefaultProc;
615  	CallWindowProcFunc _callWindowProc = nullptr;
616  	BufferID attachDefaultDoc();
617  	BufferID _currentBufferID = nullptr;
618  	Buffer * _currentBuffer = nullptr;
619  	int _codepage = CP_ACP;
620  	bool _wrapRestoreNeeded = false;
621  	bool _positionRestoreNeeded = false;
622  	uint32_t _restorePositionRetryCount = 0;
623  	typedef std::unordered_map<int, Style> StyleMap;
624  	typedef std::unordered_map<BufferID, StyleMap*> BufferStyleMap;
625  	BufferStyleMap _hotspotStyles;
626  	intptr_t _beginSelectPosition = -1;
627  	static std::string _defaultCharList;
628  	void restyleBuffer();
629  	const char * getCompleteKeywordList(std::basic_string<char> & kwl, LangType langType, int keywordIndex);
630  	void setKeywords(LangType langType, const char *keywords, int index);
631  	void setLexer(LangType langID, int whichList);
632  	bool setLexerFromLangID(int langID);
633  	void makeStyle(LangType langType, const TCHAR **keywordArray = NULL);
634  	void setStyle(Style styleToSet);			
635  	void setSpecialStyle(const Style & styleToSet);	
636  	void setSpecialIndicator(const Style & styleToSet) {
637  		execute(SCI_INDICSETFORE, styleToSet._styleID, styleToSet._bgColor);
638  	};
639  	void setXmlLexer(LangType type);
640   	void setCppLexer(LangType type);
641  	void setJsLexer();
642  	void setTclLexer();
643      void setObjCLexer(LangType type);
644  	void setUserLexer(const TCHAR *userLangName = NULL);
645  	void setExternalLexer(LangType typeDoc);
646  	void setEmbeddedJSLexer();
647      void setEmbeddedPhpLexer();
648      void setEmbeddedAspLexer();
649  	void setJsonLexer(bool isJson5 = false);
650  	void setTypeScriptLexer();
651  	void setCssLexer() {
652  		setLexer(L_CSS, LIST_0 | LIST_1 | LIST_4 | LIST_6);
653  	};
654  	void setLuaLexer() {
655  		setLexer(L_LUA, LIST_0 | LIST_1 | LIST_2 | LIST_3);
656  	};
657  	void setMakefileLexer() {
658  		setLexer(L_MAKEFILE, LIST_NONE);
659  	};
660  	void setPropsLexer(bool isPropsButNotIni = true) {
661  		LangType L_id = isPropsButNotIni ? L_PROPS : L_INI;
662  		setLexer(L_id, LIST_NONE);
663  		execute(SCI_STYLESETEOLFILLED, SCE_PROPS_SECTION, true);
664  	};
665  	void setSqlLexer() {
666  		const bool kbBackSlash = NppParameters::getInstance().getNppGUI()._backSlashIsEscapeCharacterForSql;
667  		setLexer(L_SQL, LIST_0 | LIST_1 | LIST_4);
668  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("sql.backslash.escapes"), reinterpret_cast<LPARAM>(kbBackSlash ? "1" : "0"));
669  	};
670  	void setMSSqlLexer() {
671  		setLexer(L_MSSQL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
672  	};
673  	void setBashLexer() {
674  		setLexer(L_BASH, LIST_0);
675  	};
676  	void setVBLexer() {
677  		setLexer(L_VB, LIST_0);
678  	};
679  	void setPascalLexer() {
680  		setLexer(L_PASCAL, LIST_0);
681  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
682  	};
683  	void setPerlLexer() {
684  		setLexer(L_PERL, LIST_0);
685  	};
686  	void setPythonLexer() {
687  		setLexer(L_PYTHON, LIST_0 | LIST_1);
688  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.quotes.python"), reinterpret_cast<LPARAM>("1"));
689  	};
690  	void setGDScriptLexer() {
691  		setLexer(L_GDSCRIPT, LIST_0 | LIST_1);
692  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.gdscript.keywords2.no.sub.identifiers"), reinterpret_cast<LPARAM>("1"));
693  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.gdscript.whinge.level"), reinterpret_cast<LPARAM>("1"));
694  	};
695  	void setBatchLexer() {
696  		setLexer(L_BATCH, LIST_0);
697  	};
698  	void setTeXLexer() {
699  		for (int i = 0 ; i < 4 ; ++i)
700  			execute(SCI_SETKEYWORDS, i, reinterpret_cast<LPARAM>(TEXT("")));
701  		setLexer(L_TEX, LIST_NONE);
702  	};
703  	void setNsisLexer() {
704  		setLexer(L_NSIS, LIST_0 | LIST_1 | LIST_2 | LIST_3);
705  	};
706  	void setFortranLexer() {
707  		setLexer(L_FORTRAN, LIST_0 | LIST_1 | LIST_2);
708  	};
709  	void setFortran77Lexer() {
710  		setLexer(L_FORTRAN_77, LIST_0 | LIST_1 | LIST_2);
711  	};
712  	void setLispLexer(){
713  		setLexer(L_LISP, LIST_0 | LIST_1);
714  	};
715  	void setSchemeLexer(){
716  		setLexer(L_SCHEME, LIST_0 | LIST_1);
717  	};
718  	void setAsmLexer(){
719  		setLexer(L_ASM, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6 | LIST_7);
720  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.asm.syntax.based"), reinterpret_cast<LPARAM>("1"));
721  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.asm.comment.multiline"), reinterpret_cast<LPARAM>("1"));
722  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.asm.comment.explicit"), reinterpret_cast<LPARAM>("1"));
723  	};
724  	void setDiffLexer(){
725  		setLexer(L_DIFF, LIST_NONE);
726  	};
727  	void setPostscriptLexer(){
728  		setLexer(L_PS, LIST_0 | LIST_1 | LIST_2 | LIST_3);
729  	};
730  	void setRubyLexer(){
731  		setLexer(L_RUBY, LIST_0);
732  		execute(SCI_STYLESETEOLFILLED, SCE_RB_POD, true);
733  	};
734  	void setSmalltalkLexer(){
735  		setLexer(L_SMALLTALK, LIST_0);
736  	};
737  	void setVhdlLexer(){
738  		setLexer(L_VHDL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
739  	};
740  	void setKixLexer(){
741  		setLexer(L_KIX, LIST_0 | LIST_1 | LIST_2);
742  	};
743  	void setAutoItLexer(){
744  		setLexer(L_AU3, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
745  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
746  	};
747  	void setCamlLexer(){
748  		setLexer(L_CAML, LIST_0 | LIST_1 | LIST_2);
749  	};
750  	void setAdaLexer(){
751  		setLexer(L_ADA, LIST_0);
752  	};
753  	void setVerilogLexer(){
754  		setLexer(L_VERILOG, LIST_0 | LIST_1);
755  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
756  	};
757  	void setMatlabLexer(){
758  		setLexer(L_MATLAB, LIST_0);
759  	};
760  	void setHaskellLexer(){
761  		setLexer(L_HASKELL, LIST_0);
762  	};
763  	void setInnoLexer() {
764  		setLexer(L_INNO, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
765  	};
766  	void setCmakeLexer() {
767  		setLexer(L_CMAKE, LIST_0 | LIST_1 | LIST_2);
768  	};
769  	void setYamlLexer() {
770  		setLexer(L_YAML, LIST_0);
771  	};
772      void setCobolLexer() {
773  		setLexer(L_COBOL, LIST_0 | LIST_1 | LIST_2);
774  	};
775      void setGui4CliLexer() {
776  		setLexer(L_GUI4CLI, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4);
777  	};
778      void setDLexer() {
779  		setLexer(L_D, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
780  	};
781      void setPowerShellLexer() {
782  		setLexer(L_POWERSHELL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
783  	};
784      void setRLexer() {
785  		setLexer(L_R, LIST_0 | LIST_1 | LIST_2);
786  	};
787      void setCoffeeScriptLexer() {
788  		setLexer(L_COFFEESCRIPT, LIST_0 | LIST_1 | LIST_2  | LIST_3);
789  	};
790  	void setBaanCLexer() {
791  		setLexer(L_BAANC, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6 | LIST_7 | LIST_8);
792  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.baan.styling.within.preprocessor"), reinterpret_cast<LPARAM>("1"));
793  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$:"));
794  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
795  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.syntax.based"), reinterpret_cast<LPARAM>("1"));
796  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.keywords.based"), reinterpret_cast<LPARAM>("1"));
797  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.sections"), reinterpret_cast<LPARAM>("1"));
798  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.inner.level"), reinterpret_cast<LPARAM>("1"));
799  		execute(SCI_STYLESETEOLFILLED, SCE_BAAN_STRINGEOL, true);
800  	};
801  	void setSrecLexer() {
802  		setLexer(L_SREC, LIST_NONE);
803  	};
804  	void setIHexLexer() {
805  		setLexer(L_IHEX, LIST_NONE);
806  	};
807  	void setTEHexLexer() {
808  		setLexer(L_TEHEX, LIST_NONE);
809  	};
810  	void setAsn1Lexer() {
811  		setLexer(L_ASN1, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
812  	};
813  	void setAVSLexer() {
814  		setLexer(L_AVS, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
815  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#"));
816  	};
817  	void setBlitzBasicLexer() {
818  		setLexer(L_BLITZBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
819  	};
820  	void setPureBasicLexer() {
821  		setLexer(L_PUREBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
822  	};
823  	void setFreeBasicLexer() {
824  		setLexer(L_FREEBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
825  	};
826  	void setCsoundLexer() {
827  		setLexer(L_CSOUND, LIST_0 | LIST_1 | LIST_2);
828  		execute(SCI_STYLESETEOLFILLED, SCE_CSOUND_STRINGEOL, true);
829  	};
830  	void setErlangLexer() {
831  		setLexer(L_ERLANG, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5); 
832  	};
833  	void setESCRIPTLexer() {
834  		setLexer(L_ESCRIPT, LIST_0 | LIST_1 | LIST_2); 
835  	};
836  	void setForthLexer() {
837  		setLexer(L_FORTH, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
838  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%-"));
839  	};
840  	void setLatexLexer() {
841  		setLexer(L_LATEX, LIST_NONE); 
842  	};
843  	void setMMIXALLexer() {
844  		setLexer(L_MMIXAL, LIST_0 | LIST_1 | LIST_2); 
845  	};
846  	void setNimrodLexer() {
847  		setLexer(L_NIM, LIST_0);
848  	};
849  	void setNncrontabLexer() {
850  		setLexer(L_NNCRONTAB, LIST_0 | LIST_1 | LIST_2); 
851  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%-"));
852  	};
853  	void setOScriptLexer() {
854  		setLexer(L_OSCRIPT, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
855  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$"));
856  	};
857  	void setREBOLLexer() {
858  		setLexer(L_REBOL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
859  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?!.'+-*&|=_~"));
860  	};
861  	void setRegistryLexer() {
862  		setLexer(L_REGISTRY, LIST_NONE); 
863  	};
864  	void setRustLexer() {
865  		setLexer(L_RUST, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6); 
866  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#"));
867  	};
868  	void setSpiceLexer() {
869  		setLexer(L_SPICE, LIST_0 | LIST_1 | LIST_2); 
870  	};
871  	void setTxt2tagsLexer() {
872  		setLexer(L_TXT2TAGS, LIST_NONE); 
873  	};
874  	void setVisualPrologLexer() {
875  		setLexer(L_VISUALPROLOG, LIST_0 | LIST_1 | LIST_2 | LIST_3);
876  	}
877  	void setHollywoodLexer() {
878  		setLexer(L_HOLLYWOOD, LIST_0 | LIST_1 | LIST_2 | LIST_3);
879  	};	
880  	void setSearchResultLexer() {
881  		if (execute(SCI_GETLEXER) == SCLEX_SEARCHRESULT)
882  		{
883  			makeStyle(L_SEARCHRESULT, nullptr);
884  			return;
885  		}
886  		execute(SCI_STYLESETEOLFILLED, SCE_SEARCHRESULT_FILE_HEADER, true);
887  		execute(SCI_STYLESETEOLFILLED, SCE_SEARCHRESULT_SEARCH_HEADER, true);
888  		setLexer(L_SEARCHRESULT, LIST_NONE);
889  	};
890  	bool isNeededFolderMarge(LangType typeDoc) const {
891  		switch (typeDoc)
892  		{
893  			case L_ASCII:
894  			case L_BATCH:
895  			case L_TEXT:
896  			case L_MAKEFILE:
897  			case L_HASKELL:
898  			case L_SMALLTALK:
899  			case L_KIX:
900  			case L_ADA:
901  				return false;
902  			default:
903  				return true;
904  		}
905  	};
906      void defineMarker(int marker, int markerType, COLORREF fore, COLORREF back, COLORREF foreActive) {
907  	    execute(SCI_MARKERDEFINE, marker, markerType);
908  	    execute(SCI_MARKERSETFORE, marker, fore);
909  	    execute(SCI_MARKERSETBACK, marker, back);
910  		execute(SCI_MARKERSETBACKSELECTED, marker, foreActive);
911  	};
912  	int codepage2CharSet() const {
913  		switch (_codepage)
914  		{
915  			case CP_CHINESE_TRADITIONAL : return SC_CHARSET_CHINESEBIG5;
916  			case CP_CHINESE_SIMPLIFIED : return SC_CHARSET_GB2312;
917  			case CP_KOREAN : return SC_CHARSET_HANGUL;
918  			case CP_JAPANESE : return SC_CHARSET_SHIFTJIS;
919  			case CP_GREEK : return SC_CHARSET_GREEK;
920  			default : return 0;
921  		}
922  	};
923  	std::pair<size_t, size_t> getWordRange();
924  	bool expandWordSelection();
925  	void getFoldColor(COLORREF& fgColor, COLORREF& bgColor, COLORREF& activeFgColor);
926  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-preferenceDlg.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.h</div>
                </div>
                <div class="column column_space"><pre><code>97  		::EnableWindow(::GetDlgItem(_hSelf, IDC_CHECK_OPENANSIASUTF8), doIt);
98  	};
99  	intptr_t CALLBACK run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam) override;
</pre></code></div>
                <div class="column column_space"><pre><code>586  		scintillaNew_Proc(_hSelf, WM_MOUSEWHEEL, wParam, lParam);
587  	};
588  	void setHotspotStyle(const Style& styleToSet);
589      void setTabSettings(Lang *lang);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    