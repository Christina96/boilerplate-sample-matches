
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.974169741697416%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-nonsecure_base.h</h3>
            <pre><code>1  #ifndef ABSL_RANDOM_INTERNAL_NONSECURE_BASE_H_
2  #define ABSL_RANDOM_INTERNAL_NONSECURE_BASE_H_
3  #include <algorithm>
4  #include <cstdint>
5  #include <iterator>
6  #include <type_traits>
7  #include <utility>
8  #include <vector>
9  #include "absl/base/macros.h"
10  #include "absl/container/inlined_vector.h"
11  #include "absl/meta/type_traits.h"
12  #include "absl/random/internal/pool_urbg.h"
13  #include "absl/random/internal/salted_seed_seq.h"
14  #include "absl/random/internal/seed_material.h"
15  #include "absl/types/span.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace random_internal {
19  class RandenPoolSeedSeq {
20   private:
21    struct ContiguousTag {};
22    struct BufferTag {};
23    template <typename Contiguous>
24    void generate_impl(ContiguousTag, Contiguous begin, Contiguous end) {
25      const size_t n = static_cast<size_t>(std::distance(begin, end));
26      auto* a = &(*begin);
27      RandenPool<uint8_t>::Fill(
28          absl::MakeSpan(reinterpret_cast<uint8_t*>(a), sizeof(*a) * n));
<span onclick='openModal()' class='match'>29    }
30    template <typename RandomAccessIterator>
31    void generate_impl(BufferTag, RandomAccessIterator begin,
32                       RandomAccessIterator end) {
33      const size_t n = std::distance(begin, end);
34      absl::InlinedVector<uint32_t, 8> data(n, 0);
</span>35      RandenPool<uint32_t>::Fill(absl::MakeSpan(data.begin(), data.end()));
36      std::copy(std::begin(data), std::end(data), begin);
37    }
38   public:
39    using result_type = uint32_t;
40    size_t size() { return 0; }
41    template <typename OutIterator>
42    void param(OutIterator) const {}
43    template <typename RandomAccessIterator>
44    void generate(RandomAccessIterator begin, RandomAccessIterator end) {
45      if (begin != end) {
46        using U = typename std::iterator_traits<RandomAccessIterator>::value_type;
47        using TagType = absl::conditional_t<
48            (std::is_pointer<RandomAccessIterator>::value ||
49             std::is_same<RandomAccessIterator,
50                          typename std::vector<U>::iterator>::value),
51            ContiguousTag, BufferTag>;
52        generate_impl(TagType{}, begin, end);
53      }
54    }
55  };
56  template <typename URBG, typename Seeder = RandenPoolSeedSeq>
57  class NonsecureURBGBase {
58   public:
59    using result_type = typename URBG::result_type;
60    NonsecureURBGBase() : urbg_(ConstructURBG()) {}
61    NonsecureURBGBase(const NonsecureURBGBase&) = delete;
62    NonsecureURBGBase& operator=(const NonsecureURBGBase&) = delete;
63    NonsecureURBGBase(NonsecureURBGBase&&) = default;
64    NonsecureURBGBase& operator=(NonsecureURBGBase&&) = default;
65    template <class SSeq, typename = typename absl::enable_if_t<
66                              !std::is_same<SSeq, NonsecureURBGBase>::value>>
67    explicit NonsecureURBGBase(SSeq&& seq)
68        : urbg_(ConstructURBG(std::forward<SSeq>(seq))) {}
69    static constexpr result_type(min)() { return (URBG::min)(); }
70    static constexpr result_type(max)() { return (URBG::max)(); }
71    result_type operator()() { return urbg_(); }
72    void discard(unsigned long long values) {  
73      urbg_.discard(values);
74    }
75    bool operator==(const NonsecureURBGBase& other) const {
76      return urbg_ == other.urbg_;
77    }
78    bool operator!=(const NonsecureURBGBase& other) const {
79      return !(urbg_ == other.urbg_);
80    }
81   private:
82    static URBG ConstructURBG() {
83      Seeder seeder;
84      return URBG(seeder);
85    }
86    template <typename SSeq>
87    static URBG ConstructURBG(SSeq&& seq) {  
88      auto salted_seq =
89          random_internal::MakeSaltedSeedSeq(std::forward<SSeq>(seq));
90      return URBG(salted_seq);
91    }
92    URBG urbg_;
93  };
94  }  
95  ABSL_NAMESPACE_END
96  }  
97  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash.h</h3>
            <pre><code>1  #ifndef ABSL_HASH_HASH_H_
2  #define ABSL_HASH_HASH_H_
3  #include <tuple>
4  #include <utility>
5  #include "absl/functional/function_ref.h"
6  #include "absl/hash/internal/hash.h"
7  namespace absl {
8  ABSL_NAMESPACE_BEGIN
9  template <typename T>
10  using Hash = absl::hash_internal::Hash<T>;
11  template <int&... ExplicitArgumentBarrier, typename... Types>
12  size_t HashOf(const Types&... values) {
13    auto tuple = std::tie(values...);
14    return absl::Hash<decltype(tuple)>{}(tuple);
15  }
16  class HashState : public hash_internal::HashStateBase<HashState> {
17   public:
18    template <typename T>
19    static HashState Create(T* state) {
20      HashState s;
21      s.Init(state);
22      return s;
23    }
24    HashState(const HashState&) = delete;
25    HashState& operator=(const HashState&) = delete;
26    HashState(HashState&&) = default;
27    HashState& operator=(HashState&&) = default;
28    using HashState::HashStateBase::combine;
29    static HashState combine_contiguous(HashState hash_state,
30                                        const unsigned char* first, size_t size) {
31      hash_state.combine_contiguous_(hash_state.state_, first, size);
32      return hash_state;
33    }
34    using HashState::HashStateBase::combine_contiguous;
35   private:
<span onclick='openModal()' class='match'>36    HashState() = default;
37    friend class HashState::HashStateBase;
38    template <typename T>
39    static void CombineContiguousImpl(void* p, const unsigned char* first,
40                                      size_t size) {
41      T& state = *static_cast<T*>(p);
</span>42      state = T::combine_contiguous(std::move(state), first, size);
43    }
44    template <typename T>
45    void Init(T* state) {
46      state_ = state;
47      combine_contiguous_ = &CombineContiguousImpl<T>;
48      run_combine_unordered_ = &RunCombineUnorderedImpl<T>;
49    }
50    template <typename HS>
51    struct CombineUnorderedInvoker {
52      template <typename T, typename ConsumerT>
53      void operator()(T inner_state, ConsumerT inner_cb) {
54        f(HashState::Create(&inner_state),
55          [&](HashState& inner_erased) { inner_cb(inner_erased.Real<T>()); });
56      }
57      absl::FunctionRef<void(HS, absl::FunctionRef<void(HS&)>)> f;
58    };
59    template <typename T>
60    static HashState RunCombineUnorderedImpl(
61        HashState state,
62        absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>
63            f) {
64      T& real_state = state.Real<T>();
65      real_state = T::RunCombineUnordered(
66          std::move(real_state), CombineUnorderedInvoker<HashState>{f});
67      return state;
68    }
69    template <typename CombinerT>
70    static HashState RunCombineUnordered(HashState state, CombinerT combiner) {
71      auto* run = state.run_combine_unordered_;
72      return run(std::move(state), std::ref(combiner));
73    }
74    void Init(HashState* state) {
75      state_ = state->state_;
76      combine_contiguous_ = state->combine_contiguous_;
77      run_combine_unordered_ = state->run_combine_unordered_;
78    }
79    template <typename T>
80    T& Real() {
81      return *static_cast<T*>(state_);
82    }
83    void* state_;
84    void (*combine_contiguous_)(void*, const unsigned char*, size_t);
85    HashState (*run_combine_unordered_)(
86        HashState state,
87        absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>);
88  };
89  ABSL_NAMESPACE_END
90  }  
91  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-nonsecure_base.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash.h</div>
                </div>
                <div class="column column_space"><pre><code>29    }
30    template <typename RandomAccessIterator>
31    void generate_impl(BufferTag, RandomAccessIterator begin,
32                       RandomAccessIterator end) {
33      const size_t n = std::distance(begin, end);
34      absl::InlinedVector<uint32_t, 8> data(n, 0);
</pre></code></div>
                <div class="column column_space"><pre><code>36    HashState() = default;
37    friend class HashState::HashStateBase;
38    template <typename T>
39    static void CombineContiguousImpl(void* p, const unsigned char* first,
40                                      size_t size) {
41      T& state = *static_cast<T*>(p);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    