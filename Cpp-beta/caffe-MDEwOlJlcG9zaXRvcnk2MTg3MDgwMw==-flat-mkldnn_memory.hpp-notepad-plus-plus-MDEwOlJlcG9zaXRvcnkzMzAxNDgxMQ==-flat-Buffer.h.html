
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 40.36144578313253%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_memory.hpp</h3>
            <pre><code>1  #ifndef CAFFE_MKLDNN_MEMORY_HPP_
2  #define CAFFE_MKLDNN_MEMORY_HPP_
3  #include <string>
4  #include <vector>
5  #include <boost/interprocess/shared_memory_object.hpp>
6  #include <boost/interprocess/mapped_region.hpp>
7  #include "boost/enable_shared_from_this.hpp"
8  #include "caffe/blob.hpp"
9  #include "caffe/common.hpp"
10  #include "caffe/util/math_functions.hpp"
11  #include "mkldnn.hpp"
12  #include "mkldnn_base.hpp"
13  #include "caffe/syncedmem.hpp"
14  #include "caffe/net.hpp"
15  using namespace mkldnn;
16  using namespace boost::interprocess;
17  namespace caffe {
18  template <typename Dtype>
19  class MKLDNNMemoryDescriptorBase : public PrvMemDescr
20          , public boost::enable_shared_from_this<MKLDNNMemoryDescriptorBase<Dtype> >
21  {
22  public:
23      MKLDNNMemoryDescriptorBase(shared_ptr<memory::primitive_desc> usr_memory_pd
24                                  , shared_ptr<memory::primitive_desc> prv_memory_pd
25                                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
26                                  , std::vector<float>scale=std::vector<float>(1,1.)
27                                  , int mask=0
28                                  , bool is_sum=false
29                                  , bool is_wino=false
30                                  , bool is_weight=false
31                                  , std::string _name="");
32      ~MKLDNNMemoryDescriptorBase() {}
33      virtual void convert_from_other(shared_ptr<PrvMemDescr> other);
34      virtual bool layout_compare(shared_ptr<PrvMemDescr> other);
35      virtual PrvDescrType get_descr_type() {return PRV_DESCR_MKLDNN;}
36      virtual size_t prv_count() { return prv_size()/sizeof(Dtype); }
37      virtual size_t prv_size() { return _prv_memory_pd->get_size(); }
38      shared_ptr<MKLDNNMemoryDescriptorBase<Dtype> > get_shared_ptr() {
39          return this->shared_from_this();
40      }
<span onclick='openModal()' class='match'>41      shared_ptr<memory::primitive_desc>  prv_memory_pd() const {
42          return _prv_memory_pd;
43      }
44      shared_ptr<memory::primitive_desc>  usr_memory_pd() const {
45          return _usr_memory_pd;
46      }
47      inline bool conversion_needed() const { return (_reorder_usr2prv_pd != NULL || _reorder_extprv2prv_pd != NULL); }
48      virtual void* prv_ptr() { return _internal_ptr;  }
49      shared_ptr<memory>  get_prv_memory()
</span>50      {
51          if (_prv_memory == NULL) allocate();
52          return _prv_memory;
53      }
54      Dtype* get_prv_ptr() {
55          if (_prv_memory == NULL) allocate();
56          return _internal_ptr;
57      }
58      shared_ptr<primitive>  reorder_usr2prv() { return _reorder_usr2prv.aprimitive; }
59      shared_ptr<primitive>  reorder_prv2usr() { return _reorder_prv2usr.aprimitive; }
60      shared_ptr<primitive>  reorder_extprv2prv() { return _reorder_extprv2prv.aprimitive; }
61      float get_scale(int i) { return _scale[i]; }
62      std::vector<float> get_scale() { return _scale; }
63      void set_scale(std::vector<float> scale) { _scale.assign(scale.begin(),scale.end());}
64      void set_sum(bool is_sum) { _is_sum = is_sum; }
65      bool get_sum() { return _is_sum; }
66      void set_mkldnn_layer(MKLDNNLayer<Dtype>* layer) { _mkldnn_layer = layer;  }
67      MKLDNNLayer<Dtype>*  mkldnn_layer() const { return _mkldnn_layer;  }
68      std::string name;  
69      shared_memory_object *shm;
70      mapped_region *region;
71  protected:
72      void check_usr_with_prv_descriptors();
73      void set_prv_memory(shared_ptr<memory> memory)
74      {
75          _prv_memory = memory;
76          _internal_ptr = (Dtype *)(_prv_memory->get_data_handle());
77      }
78      void allocate() {
79          if (_prv_memory == NULL) {
80  #ifdef USE_MLSL
81            if (mn::is_multinode()) {
82              auto mlsl_free = [](char* p) { mn::free((void*)p); };
83              _mlsl_memory.reset(
84                (char*)mn::alloc(_prv_memory_pd->get_size(), 64), mlsl_free);
85              _prv_memory = shared_ptr<memory>(
86                new memory(*_prv_memory_pd, (void*)_mlsl_memory.get()));
87            } else {
88  #endif
89              if (CircleBuf::Instance()->GetBufSize()) {
90                if (!_is_weight) {
91                  _m_memory = CircleBuf::Instance()->GetFreeBuf();
92                } else {
93                  if (getenv("CAFFE_INFERENCE_WEIGHT_SHARING")) {
94                    shm = new shared_memory_object(open_or_create, name.c_str(), read_write);
95                    shm->truncate(_prv_memory_pd->get_size());
96                    region = new mapped_region(*shm, read_write);
97                    _m_memory = region->get_address();
98                  } else {
99                    bool cuda;
100                    CaffeMallocHost(&_m_memory, _prv_memory_pd->get_size(), &cuda);
101                  }
102                }
103                _prv_memory = shared_ptr<memory>(new memory(*_prv_memory_pd, _m_memory));
104              } else
105                _prv_memory = shared_ptr<memory>(new memory(*_prv_memory_pd));
106  #ifdef USE_MLSL
107            }
108  #endif
109            _internal_ptr = (Dtype *)(_prv_memory->get_data_handle());
110          }
111      }
112      void set_prv_memory_pd(shared_ptr<memory::primitive_desc> memory_pd, std::vector<float> scale, int mask, bool is_wino, bool is_weight)  {
113          _prv_memory_pd = memory_pd;
114          if (_prv_memory_pd && _usr_memory_pd) {
115              check_usr_with_prv_descriptors();
116              std::vector<float>scale_ext = std::vector<float>(1,1.);            
117              this->create_reorder_descriptors(scale, mask, scale_ext, false, is_wino, is_weight);
118          }
119      }
120      void set_extprv_memory_pd(shared_ptr<memory::primitive_desc> memory_pd, std::vector<float> scale, std::vector<float> scale_ext, bool is_sum)  {
121          _extprv_memory_pd = memory_pd;
122          if (_prv_memory_pd && _usr_memory_pd) {
123              check_usr_with_prv_descriptors();
124              this->create_reorder_descriptors(scale, 0, scale_ext, is_sum);
125          }
126      }
127      void set_usr_memory_pd(shared_ptr<memory::primitive_desc> memory_pd, std::vector<float> scale) {
128          _usr_memory_pd = memory_pd;
129      }
130      void create_reorder_descriptors(std::vector<float> scale, int mask=0, std::vector<float>scale_ext=std::vector<float>(1,1.), bool is_sum=false, bool is_wino=false, bool is_weight=false);
131      shared_ptr<memory::primitive_desc> _usr_memory_pd;
132      shared_ptr<memory::primitive_desc> _prv_memory_pd;
133      shared_ptr<memory::primitive_desc> _extprv_memory_pd;
134      shared_ptr<reorder::primitive_desc> _reorder_usr2prv_pd;
135      shared_ptr<reorder::primitive_desc> _reorder_prv2usr_pd;
136      shared_ptr<reorder::primitive_desc> _reorder_extprv2prv_pd;
137      MKLDNNPrimitive<Dtype> _reorder_usr2prv;
138      MKLDNNPrimitive<Dtype> _reorder_prv2usr;
139      MKLDNNPrimitive<Dtype> _reorder_extprv2prv;
140      shared_ptr<memory> _prv_memory;
141      Dtype* _internal_ptr;
142      shared_ptr<memory> _usr_memory;
143      void* _cpu_ptr;
144  #ifdef CO_SIM
145      shared_ptr<memory> _usr_memory_cosim;
146      MKLDNNPrimitive<Dtype> _reorder_prv2usr_cosim;
147      shared_ptr<memory> _prv_memory_cosim;
148      shared_ptr<primitive::at>  at_prv_cosim;
149  #endif
150      MKLDNNLayer<Dtype>* _mkldnn_layer;
151      Blob<Dtype>* _blob;
152      std::vector<float> _scale = std::vector<float>(1,1.);
153      bool _is_sum = false;
154  #ifdef USE_MLSL
155      shared_ptr<char> _mlsl_memory;
156  #endif
157      void* _m_memory;
158      bool _is_weight;
159  };
160  template <typename Dtype, bool is_diff>
161  class MKLDNNMemoryDescriptor : public MKLDNNMemoryDescriptorBase<Dtype> {
162  public:
163      MKLDNNMemoryDescriptor(shared_ptr<memory::primitive_desc> usr_memory_pd
164                          , shared_ptr<memory::primitive_desc> prv_memory_pd
165                          , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
166                          , std::vector<float> scale=std::vector<float>(1,1.)
167                          , int mask=0
168                          , bool is_sum=false
169                          , bool is_wino=false
170                          , bool is_weight=false
171                          , std::string name="");
172      virtual void convert_from_prv(void* cpu_ptr);
173      virtual void convert_to_prv(void* cpu_ptr);
174      virtual void convert_from_extprv(shared_ptr<primitive> aprimitive);
175      virtual bool on_to_cpu();
176  #ifdef CO_SIM
177      virtual void create_reorder_from_prv_cosim(void* cpu_ptr);
178      virtual void convert_from_prv_cosim(void* cpu_ptr);
179  #endif
180      virtual void create_reorder_from_prv(void* cpu_ptr);
181      virtual void create_reorder_to_prv(void* cpu_ptr);
182      virtual void create_reorder_from_extprv(shared_ptr<primitive> aprimitive);
183      shared_ptr<primitive> get_blob_prv_primitive(Blob<Dtype> * blob, bool set_prv_ptr, bool convert = true,
184              MKLDNNMemoryDescriptor<Dtype, is_diff>* converted_in_fwd = NULL);
185      void sync_before_read();
186      void sync_before_write(bool inplace = false);
187      shared_ptr<primitive> create_input(Blob<Dtype> * blob, bool set_prv_ptr);
188      shared_ptr<memory> create_output_memory(Blob<Dtype> * blob, bool inplace = false);
189      shared_ptr<primitive> create_input(bool set_prv_ptr);
190      shared_ptr<memory> create_output_memory(bool inplace = false);
191      Dtype* get_memory_ptr(long offset = 0);
192      shared_ptr<memory::desc> get_memory_desc();
193      size_t get_memory_count();
194      void set_mkldnn_primitive(MKLDNNPrimitive<Dtype>& mprimitive) { CHECK(mprimitive.aprimitive); _mkldnn_primitive = mprimitive;  }
195      MKLDNNPrimitive<Dtype>&  mkldnn_primitive() { return _mkldnn_primitive; }
196      shared_ptr<primitive> aprimitive() const { return _mkldnn_primitive.aprimitive; }
197  private:
198      MKLDNNPrimitive<Dtype> _mkldnn_primitive;
199  };
200  template <typename Dtype>
201  class MKLDNNData : public MKLDNNMemoryDescriptor<Dtype, false>
202  {
203  public:
204      MKLDNNData(shared_ptr<memory::primitive_desc> usr_memory_pd
205                  , shared_ptr<memory::primitive_desc> prv_memory_pd
206                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
207                  , std::vector<float> scale=std::vector<float>(1,1.)
208                  , int mask=0
209                  , bool is_sum=false
210                  , bool is_wino=false
211                  , bool is_weight=false
212                  , std::string name="")
213          : MKLDNNMemoryDescriptor<Dtype, false>(usr_memory_pd, prv_memory_pd, blob, mkldnn_layer, scale, mask, is_sum, is_wino, is_weight, name) {}
214  };
215  template <typename Dtype>
216  class MKLDNNDiff : public MKLDNNMemoryDescriptor<Dtype, true>
217  {
218  public:
219      MKLDNNDiff(shared_ptr<memory::primitive_desc> usr_memory_pd
220                  , shared_ptr<memory::primitive_desc> prv_memory_pd
221                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer)
222          : MKLDNNMemoryDescriptor<Dtype, true>(usr_memory_pd, prv_memory_pd, blob, mkldnn_layer ) {}
223  };
224  template <typename Dtype, bool is_diff>
225  shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > get_mkldnn_prv_descriptor(Blob<Dtype>* blob);
226  }  
227  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.h</h3>
            <pre><code>1  #pragma once
2  #include <mutex>
3  #include "Utf8_16.h"
4  class Notepad_plus;
5  class Buffer;
6  typedef Buffer* BufferID;	
7  #define BUFFER_INVALID	reinterpret_cast<BufferID>(0)
8  typedef sptr_t Document;
9  enum DocFileStatus {
10  	DOC_REGULAR    = 0x01, 
11  	DOC_UNNAMED    = 0x02, 
12  	DOC_DELETED    = 0x04, 
13  	DOC_MODIFIED   = 0x08, 
14  	DOC_NEEDRELOAD = 0x10  
15  };
16  enum BufferStatusInfo {
17  	BufferChangeNone		= 0x000,  
18  	BufferChangeLanguage	= 0x001,  
19  	BufferChangeDirty		= 0x002,  
20  	BufferChangeFormat		= 0x004,  
21  	BufferChangeUnicode		= 0x008,  
22  	BufferChangeReadonly	= 0x010,  
23  	BufferChangeStatus		= 0x020,  
24  	BufferChangeTimestamp	= 0x040,  
25  	BufferChangeFilename	= 0x080,  
26  	BufferChangeRecentTag	= 0x100,  
27  	BufferChangeLexing		= 0x200,  
28  	BufferChangeMask		= 0x3FF   
29  };
30  enum SavingStatus {
31  	SaveOK             = 0,
32  	SaveOpenFailed     = 1,
33  	SaveWritingFailed  = 2
34  };
35  struct BufferViewInfo {
36  	BufferID _bufID = 0;
37  	int _iView = 0;
38  	BufferViewInfo() = delete;
39  	BufferViewInfo(BufferID buf, int view) : _bufID(buf), _iView(view) {};
40  };
41  const TCHAR UNTITLED_STR[] = TEXT("new ");
42  class FileManager final {
43  public:
44  	void init(Notepad_plus* pNotepadPlus, ScintillaEditView* pscratchTilla);
45  	void checkFilesystemChanges(bool bCheckOnlyCurrentBuffer);
46  	size_t getNbBuffers() const { return _nbBufs; };
47  	size_t getNbDirtyBuffers() const;
48  	int getBufferIndexByID(BufferID id);
49  	Buffer * getBufferByIndex(size_t index);
50  	Buffer * getBufferByID(BufferID id) {return id;}
51  	void beNotifiedOfBufferChange(Buffer * theBuf, int mask);
52  	void closeBuffer(BufferID, ScintillaEditView * identifer);		
53  	void addBufferReference(BufferID id, ScintillaEditView * identifer);	
54  	BufferID loadFile(const TCHAR * filename, Document doc = static_cast<Document>(NULL), int encoding = -1, const TCHAR *backupFileName = nullptr, FILETIME fileNameTimestamp = {});	
55  	BufferID newEmptyDocument();
56  	BufferID bufferFromDocument(Document doc,  bool dontIncrease = false, bool dontRef = false);
57  	BufferID getBufferFromName(const TCHAR * name);
58  	BufferID getBufferFromDocument(Document doc);
59  	void setLoadedBufferEncodingAndEol(Buffer* buf, const Utf8_16_Read& UnicodeConvertor, int encoding, EolType bkformat);
60  	bool reloadBuffer(BufferID id);
61  	bool reloadBufferDeferred(BufferID id);
62  	SavingStatus saveBuffer(BufferID id, const TCHAR* filename, bool isCopy = false);
63  	bool backupCurrentBuffer();
64  	bool deleteBufferBackup(BufferID id);
65  	bool deleteFile(BufferID id);
66  	bool moveFile(BufferID id, const TCHAR * newFilename);
67  	bool createEmptyFile(const TCHAR * path);
68  	static FileManager& getInstance() {
69  		static FileManager instance;
70  		return instance;
71  	};
72  	int getFileNameFromBuffer(BufferID id, TCHAR * fn2copy);
73  	size_t docLength(Buffer * buffer) const;
74  	size_t nextUntitledNewNumber() const;
75  private:
76  	struct LoadedFileFormat {
77  		LoadedFileFormat() = default;
78  		LangType _language = L_TEXT;
79  		int _encoding = 0;
80  		EolType _eolFormat = EolType::osdefault;
81  	};
82  	FileManager() = default;
83  	~FileManager();
84  	FileManager(const FileManager&) = delete;
85  	FileManager& operator=(const FileManager&) = delete;
86  	FileManager(FileManager&&) = delete;
87  	FileManager& operator=(FileManager&&) = delete;
88  	int detectCodepage(char* buf, size_t len);
89  	bool loadFileData(Document doc, int64_t fileSize, const TCHAR* filename, char* buffer, Utf8_16_Read* UnicodeConvertor, LoadedFileFormat& fileFormat);
90  	LangType detectLanguageFromTextBegining(const unsigned char *data, size_t dataLen);
91  	Notepad_plus* _pNotepadPlus = nullptr;
92  	ScintillaEditView* _pscratchTilla = nullptr;
93  	Document _scratchDocDefault = 0;
94  	std::vector<Buffer*> _buffers;
95  	BufferID _nextBufferID = 0;
96  	size_t _nbBufs = 0;
97  };
98  #define MainFileManager FileManager::getInstance()
99  class Buffer final {
100  	friend class FileManager;
101  public:
102  	Buffer(FileManager * pManager, BufferID id, Document doc, DocFileStatus type, const TCHAR *fileName, bool isLargeFile);
103  	void setFileName(const TCHAR *fn);
104  	const TCHAR * getFullPathName() const { return _fullPathName.c_str(); }
105  	const TCHAR * getFileName() const { return _fileName; }
106  	BufferID getID() const { return _id; }
107  	void increaseRecentTag() {
108  		_recentTag = ++_recentTagCtr;
109  		doNotify(BufferChangeRecentTag);
110  	}
111  	long getRecentTag() const { return _recentTag; }
112  	bool checkFileState();
<span onclick='openModal()' class='match'>113  	bool isDirty() const { return _isDirty; }
114  	bool isReadOnly() const { return (_isUserReadOnly || _isFileReadOnly); }
115  	bool isUntitled() const { return ((_currentStatus & DOC_UNNAMED) == DOC_UNNAMED); }
116  	bool getFileReadOnly() const { return _isFileReadOnly; }
117  	void setFileReadOnly(bool ro) {
</span>118  		_isFileReadOnly = ro;
119  		doNotify(BufferChangeReadonly);
120  	}
121  	bool getUserReadOnly() const { return _isUserReadOnly; }
122  	void setUserReadOnly(bool ro) {
123  		_isUserReadOnly = ro;
124  		doNotify(BufferChangeReadonly);
125  	}
126  	EolType getEolFormat() const { return _eolFormat; }
127  	void setEolFormat(EolType format) {
128  		_eolFormat = format;
129  		doNotify(BufferChangeFormat);
130  	}
131  	LangType getLangType() const { return _lang; }
132  	void setLangType(LangType lang, const TCHAR * userLangName = TEXT(""));
133  	UniMode getUnicodeMode() const { return _unicodeMode; }
134  	void setUnicodeMode(UniMode mode);
135  	int getEncoding() const { return _encoding; }
136  	void setEncoding(int encoding);
137  	DocFileStatus getStatus() const { return _currentStatus; }
138  	Document getDocument() { return _doc; }
139  	void setDirty(bool dirty);
140  	void setPosition(const Position & pos, ScintillaEditView * identifier);
141  	Position & getPosition(ScintillaEditView * identifier);
142  	void setHeaderLineState(const std::vector<size_t> & folds, ScintillaEditView * identifier);
143  	const std::vector<size_t> & getHeaderLineState(const ScintillaEditView * identifier) const;
144  	bool isUserDefineLangExt() const { return (_userLangExt[0] != '\0'); }
145  	const TCHAR * getUserDefineLangName() const	{ return _userLangExt.c_str(); }
146  	const TCHAR * getCommentLineSymbol() const {
147  		Lang *l = getCurrentLang();
148  		if (!l)
149  			return NULL;
150  		return l->_pCommentLineSymbol;
151  	}
152  	const TCHAR * getCommentStart() const {
153  		Lang *l = getCurrentLang();
154  		if (!l)
155  			return NULL;
156  		return l->_pCommentStart;
157  	}
158  	const TCHAR * getCommentEnd() const {
159  		Lang *l = getCurrentLang();
160  		if (!l)
161  			return NULL;
162  		return l->_pCommentEnd;
163  	}
164  	bool getNeedsLexing() const { return _needLexer; }
165  	void setNeedsLexing(bool lex) {
166  		_needLexer = lex;
167  		doNotify(BufferChangeLexing);
168  	}
169  	int addReference(ScintillaEditView * identifier);		
170  	int removeReference(ScintillaEditView * identifier);		
171  	void setHideLineChanged(bool isHide, size_t location);
172  	void setDeferredReload();
173  	bool getNeedReload() const { return _needReloading; }
174  	void setNeedReload(bool reload) { _needReloading = reload; }
175  	size_t docLength() const {
176  		assert(_pManager != nullptr);
177  		return _pManager->docLength(_id);
178  	}
179  	int64_t getFileLength() const; 
180  	enum fileTimeType { ft_created, ft_modified, ft_accessed };
181  	generic_string getFileTime(fileTimeType ftt) const;
182  	Lang * getCurrentLang() const;
183  	bool isModified() const { return _isModified; }
184  	void setModifiedStatus(bool isModified) { _isModified = isModified; }
185  	generic_string getBackupFileName() const { return _backupFileName; }
186  	void setBackupFileName(const generic_string& fileName) { _backupFileName = fileName; }
187  	FILETIME getLastModifiedTimestamp() const { return _timeStamp; }
188  	bool isLoadedDirty() const { return _isLoadedDirty; }
189  	void setLoadedDirty(bool val) {	_isLoadedDirty = val; }
190  	bool isUnsync() const { return _isUnsync; }
191  	void setUnsync(bool val) { _isUnsync = val; }
192  	bool isSavePointDirty() const { return _isSavePointDirty; }
193  	void setSavePointDirty(bool val) { _isSavePointDirty = val; }
194  	bool isLargeFile() const { return _isLargeFile; }
195  	void startMonitoring() {
196  		_isMonitoringOn = true;
197  		_eventHandle = ::CreateEvent(nullptr, TRUE, FALSE, nullptr);
198  	};
199  	HANDLE getMonitoringEvent() const { return _eventHandle; };
200  	void stopMonitoring() {
201  		_isMonitoringOn = false;
202  		::SetEvent(_eventHandle);
203  		::CloseHandle(_eventHandle);
204  	};
205  	bool isMonitoringOn() const { return _isMonitoringOn; };
206  	void updateTimeStamp();
207  	void reload();
208  	void setMapPosition(const MapPosition & mapPosition) { _mapPosition = mapPosition; };
209  	MapPosition getMapPosition() const { return _mapPosition; };
210  	void langHasBeenSetFromMenu() { _hasLangBeenSetFromMenu = true; };
211  	bool allowBraceMach() const;
212  	bool allowAutoCompletion() const;
213  	bool allowSmartHilite() const;
214  	bool allowClickableLink() const;
215  	void setDocColorId(int idx) {
216  		_docColorId = idx;
217  	};
218  	int getDocColorId() {
219  		return _docColorId;
220  	};
221  private:
222  	int indexOfReference(const ScintillaEditView * identifier) const;
223  	void setStatus(DocFileStatus status) {
224  		_currentStatus = status;
225  		doNotify(BufferChangeStatus);
226  	}
227  	void doNotify(int mask);
228  	Buffer(const Buffer&) = delete;
229  	Buffer& operator = (const Buffer&) = delete;
230  private:
231  	FileManager * _pManager = nullptr;
232  	bool _canNotify = false; 
233  	int _references = 0; 
234  	BufferID _id = nullptr;
235  	Document _doc;	
236  	LangType _lang = L_TEXT;
237  	generic_string _userLangExt; 
238  	bool _isDirty = false;
239  	EolType _eolFormat = EolType::osdefault;
240  	UniMode _unicodeMode = uniUTF8;
241  	int _encoding = -1;
242  	bool _isUserReadOnly = false;
243  	bool _needLexer = false; 
244  	std::vector<ScintillaEditView *> _referees; 
245  	std::vector<Position> _positions;
246  	std::vector<std::vector<size_t>> _foldStates;
247  	DocFileStatus _currentStatus = DOC_REGULAR;
248  	FILETIME _timeStamp = {}; 
249  	bool _isFileReadOnly = false;
250  	generic_string _fullPathName;
251  	TCHAR * _fileName = nullptr; 
252  	bool _needReloading = false; 
253  	long _recentTag = -1;
254  	static long _recentTagCtr;
255  	int _docColorId = -1;
256  	generic_string _backupFileName;
257  	bool _isModified = false;
258  	bool _isLoadedDirty = false; 
259  	bool _isUnsync = false; 
260  	bool _isLargeFile = false; 
261  	bool _isSavePointDirty = false; 
262  	HANDLE _eventHandle = nullptr;
263  	bool _isMonitoringOn = false;
264  	bool _hasLangBeenSetFromMenu = false;
265  	MapPosition _mapPosition;
266  	std::mutex _reloadFromDiskRequestGuard;
267  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_memory.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.h</div>
                </div>
                <div class="column column_space"><pre><code>41      shared_ptr<memory::primitive_desc>  prv_memory_pd() const {
42          return _prv_memory_pd;
43      }
44      shared_ptr<memory::primitive_desc>  usr_memory_pd() const {
45          return _usr_memory_pd;
46      }
47      inline bool conversion_needed() const { return (_reorder_usr2prv_pd != NULL || _reorder_extprv2prv_pd != NULL); }
48      virtual void* prv_ptr() { return _internal_ptr;  }
49      shared_ptr<memory>  get_prv_memory()
</pre></code></div>
                <div class="column column_space"><pre><code>113  	bool isDirty() const { return _isDirty; }
114  	bool isReadOnly() const { return (_isUserReadOnly || _isFileReadOnly); }
115  	bool isUntitled() const { return ((_currentStatus & DOC_UNNAMED) == DOC_UNNAMED); }
116  	bool getFileReadOnly() const { return _isFileReadOnly; }
117  	void setFileReadOnly(bool ro) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    