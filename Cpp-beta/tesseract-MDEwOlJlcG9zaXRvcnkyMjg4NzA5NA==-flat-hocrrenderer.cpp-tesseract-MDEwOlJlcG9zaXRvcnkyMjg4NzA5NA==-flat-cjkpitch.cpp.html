
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.136498516320475%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-hocrrenderer.cpp</h3>
            <pre><code>1  #include <tesseract/baseapi.h> 
2  #include <locale>              
3  #include <memory>              
4  #include <sstream>             
5  #ifdef _WIN32
6  #  include "host.h" 
7  #endif
8  #include <tesseract/renderer.h>
9  #include "tesseractclass.h" 
10  namespace tesseract {
11  static tesseract::Orientation GetBlockTextOrientation(const PageIterator *it) {
12    tesseract::Orientation orientation;
13    tesseract::WritingDirection writing_direction;
14    tesseract::TextlineOrder textline_order;
15    float deskew_angle;
16    it->Orientation(&orientation, &writing_direction, &textline_order,
17                    &deskew_angle);
18    return orientation;
19  }
20  static void AddBaselineCoordsTohOCR(const PageIterator *it,
21                                      PageIteratorLevel level,
22                                      std::stringstream &hocr_str) {
23    tesseract::Orientation orientation = GetBlockTextOrientation(it);
24    if (orientation != ORIENTATION_PAGE_UP) {
25      hocr_str << "; textangle " << 360 - orientation * 90;
26      return;
27    }
28    int left, top, right, bottom;
29    it->BoundingBox(level, &left, &top, &right, &bottom);
30    int x1, y1, x2, y2;
31    if (!it->Baseline(level, &x1, &y1, &x2, &y2)) {
32      return;
33    }
34    x1 -= left;
35    x2 -= left;
36    y1 -= bottom;
37    y2 -= bottom;
38    if (x1 == x2) {
39      return;
40    }
41    double p1 = (y2 - y1) / static_cast<double>(x2 - x1);
42    double p0 = y1 - p1 * x1;
43    hocr_str << "; baseline " << round(p1 * 1000.0) / 1000.0 << " "
44             << round(p0 * 1000.0) / 1000.0;
45  }
46  static void AddBoxTohOCR(const ResultIterator *it, PageIteratorLevel level,
47                           std::stringstream &hocr_str) {
48    int left, top, right, bottom;
49    it->BoundingBox(level, &left, &top, &right, &bottom);
50    hocr_str << " title=\"bbox " << left << " " << top << " " << right << " "
51             << bottom;
52    if (level == RIL_TEXTLINE) {
53      AddBaselineCoordsTohOCR(it, level, hocr_str);
54      float row_height, descenders, ascenders; 
55      it->RowAttributes(&row_height, &descenders, &ascenders);
56      hocr_str << "; x_size " << row_height << "; x_descenders " << -descenders
57               << "; x_ascenders " << ascenders;
58    }
59    hocr_str << "\">";
60  }
<span onclick='openModal()' class='match'>61  char *TessBaseAPI::GetHOCRText(int page_number) {
62    return GetHOCRText(nullptr, page_number);
63  }
64  char *TessBaseAPI::GetHOCRText(ETEXT_DESC *monitor, int page_number) {
65    if (tesseract_ == nullptr ||
66        (page_res_ == nullptr && Recognize(monitor) < 0)) {
</span>67      return nullptr;
68    }
69    int lcnt = 1, bcnt = 1, pcnt = 1, wcnt = 1, scnt = 1, tcnt = 1, ccnt = 1;
70    int page_id = page_number + 1; 
71    bool para_is_ltr = true;       
72    const char *paragraph_lang = nullptr;
73    bool font_info = false;
74    bool hocr_boxes = false;
75    GetBoolVariable("hocr_font_info", &font_info);
76    GetBoolVariable("hocr_char_boxes", &hocr_boxes);
77    if (input_file_.empty()) {
78      SetInputName(nullptr);
79    }
80  #ifdef _WIN32
81    int str16_len =
82        MultiByteToWideChar(CP_ACP, 0, input_file_.c_str(), -1, nullptr, 0);
83    wchar_t *uni16_str = new WCHAR[str16_len];
84    str16_len = MultiByteToWideChar(CP_ACP, 0, input_file_.c_str(), -1, uni16_str,
85                                    str16_len);
86    int utf8_len = WideCharToMultiByte(CP_UTF8, 0, uni16_str, str16_len, nullptr,
87                                       0, nullptr, nullptr);
88    char *utf8_str = new char[utf8_len];
89    WideCharToMultiByte(CP_UTF8, 0, uni16_str, str16_len, utf8_str, utf8_len,
90                        nullptr, nullptr);
91    input_file_ = utf8_str;
92    delete[] uni16_str;
93    delete[] utf8_str;
94  #endif
95    std::stringstream hocr_str;
96    hocr_str.imbue(std::locale::classic());
97    hocr_str.precision(8);
98    hocr_str << "  <div class='ocr_page'"
99             << " id='"
100             << "page_" << page_id << "'"
101             << " title='image \"";
102    if (!input_file_.empty()) {
103      hocr_str << HOcrEscape(input_file_.c_str());
104    } else {
105      hocr_str << "unknown";
106    }
107    hocr_str << "\"; bbox " << rect_left_ << " " << rect_top_ << " "
108             << rect_width_ << " " << rect_height_ << "; ppageno " << page_number
109             << "; scan_res " << GetSourceYResolution() << " "
110             << GetSourceYResolution() << "'>\n";
111    std::unique_ptr<ResultIterator> res_it(GetIterator());
112    while (!res_it->Empty(RIL_BLOCK)) {
113      int left, top, right, bottom;
114      auto block_type = res_it->BlockType();
115      switch (block_type) {
116        case PT_FLOWING_IMAGE:
117        case PT_HEADING_IMAGE:
118        case PT_PULLOUT_IMAGE: {
119          res_it.get()->BoundingBox(RIL_TEXTLINE, &left, &top, &right, &bottom);
120          hocr_str << "   <div class='ocr_photo' id='block_" << page_id << '_'
121                   << bcnt++ << "' title=\"bbox " << left << " " << top << " "
122                   << right << " " << bottom << "\"></div>\n";
123          res_it->Next(RIL_BLOCK);
124          continue;
125        }
126        case PT_HORZ_LINE:
127        case PT_VERT_LINE:
128          res_it.get()->BoundingBox(RIL_TEXTLINE, &left, &top, &right, &bottom);
129          hocr_str << "   <div class='ocr_separator' id='block_" << page_id << '_'
130                   << bcnt++ << "' title=\"bbox " << left << " " << top << " "
131                   << right << " " << bottom << "\"></div>\n";
132          res_it->Next(RIL_BLOCK);
133          continue;
134        case PT_NOISE:
135          tprintf("TODO: Please report image which triggers the noise case.\n");
136          ASSERT_HOST(false);
137        default:
138          break;
139      }
140      if (res_it->Empty(RIL_WORD)) {
141        res_it->Next(RIL_WORD);
142        continue;
143      }
144      if (res_it->IsAtBeginningOf(RIL_BLOCK)) {
145        para_is_ltr = true; 
146        hocr_str << "   <div class='ocr_carea'"
147                 << " id='"
148                 << "block_" << page_id << "_" << bcnt << "'";
149        AddBoxTohOCR(res_it.get(), RIL_BLOCK, hocr_str);
150      }
151      if (res_it->IsAtBeginningOf(RIL_PARA)) {
152        hocr_str << "\n    <p class='ocr_par'";
153        para_is_ltr = res_it->ParagraphIsLtr();
154        if (!para_is_ltr) {
155          hocr_str << " dir='rtl'";
156        }
157        hocr_str << " id='"
158                 << "par_" << page_id << "_" << pcnt << "'";
159        paragraph_lang = res_it->WordRecognitionLanguage();
160        if (paragraph_lang) {
161          hocr_str << " lang='" << paragraph_lang << "'";
162        }
163        AddBoxTohOCR(res_it.get(), RIL_PARA, hocr_str);
164      }
165      if (res_it->IsAtBeginningOf(RIL_TEXTLINE)) {
166        hocr_str << "\n     <span class='";
167        switch (block_type) {
168          case PT_HEADING_TEXT:
169            hocr_str << "ocr_header";
170            break;
171          case PT_PULLOUT_TEXT:
172            hocr_str << "ocr_textfloat";
173            break;
174          case PT_CAPTION_TEXT:
175            hocr_str << "ocr_caption";
176            break;
177          case PT_FLOWING_IMAGE:
178          case PT_HEADING_IMAGE:
179          case PT_PULLOUT_IMAGE:
180            ASSERT_HOST(false);
181            break;
182          default:
183            hocr_str << "ocr_line";
184        }
185        hocr_str << "' id='"
186                 << "line_" << page_id << "_" << lcnt << "'";
187        AddBoxTohOCR(res_it.get(), RIL_TEXTLINE, hocr_str);
188      }
189      int32_t lstm_choice_mode = tesseract_->lstm_choice_mode;
190      std::vector<std::vector<std::vector<std::pair<const char *, float>>>>
191          *rawTimestepMap = nullptr;
192      std::vector<std::vector<std::pair<const char *, float>>> *CTCMap = nullptr;
193      if (lstm_choice_mode) {
194        CTCMap = res_it->GetBestLSTMSymbolChoices();
195        rawTimestepMap = res_it->GetRawLSTMTimesteps();
196      }
197      hocr_str << "\n      <span class='ocrx_word'"
198               << " id='"
199               << "word_" << page_id << "_" << wcnt << "'";
200      bool bold, italic, underlined, monospace, serif, smallcaps;
201      int pointsize, font_id;
202      res_it->BoundingBox(RIL_WORD, &left, &top, &right, &bottom);
203      const char *font_name =
204          res_it->WordFontAttributes(&bold, &italic, &underlined, &monospace,
205                                     &serif, &smallcaps, &pointsize, &font_id);
206      hocr_str << " title='bbox " << left << " " << top << " " << right << " "
207               << bottom << "; x_wconf "
208               << static_cast<int>(res_it->Confidence(RIL_WORD));
209      if (font_info) {
210        if (font_name) {
211          hocr_str << "; x_font " << HOcrEscape(font_name).c_str();
212        }
213        hocr_str << "; x_fsize " << pointsize;
214      }
215      hocr_str << "'";
216      const char *lang = res_it->WordRecognitionLanguage();
217      if (lang && (!paragraph_lang || strcmp(lang, paragraph_lang))) {
218        hocr_str << " lang='" << lang << "'";
219      }
220      switch (res_it->WordDirection()) {
221        case DIR_LEFT_TO_RIGHT:
222          if (!para_is_ltr) {
223            hocr_str << " dir='ltr'";
224          }
225          break;
226        case DIR_RIGHT_TO_LEFT:
227          if (para_is_ltr) {
228            hocr_str << " dir='rtl'";
229          }
230          break;
231        case DIR_MIX:
232        case DIR_NEUTRAL:
233        default: 
234          break;
235      }
236      hocr_str << ">";
237      bool last_word_in_line = res_it->IsAtFinalElement(RIL_TEXTLINE, RIL_WORD);
238      bool last_word_in_para = res_it->IsAtFinalElement(RIL_PARA, RIL_WORD);
239      bool last_word_in_block = res_it->IsAtFinalElement(RIL_BLOCK, RIL_WORD);
240      if (bold) {
241        hocr_str << "<strong>";
242      }
243      if (italic) {
244        hocr_str << "<em>";
245      }
246      do {
247        const std::unique_ptr<const char[]> grapheme(
248            res_it->GetUTF8Text(RIL_SYMBOL));
249        if (grapheme && grapheme[0] != 0) {
250          if (hocr_boxes) {
251            res_it->BoundingBox(RIL_SYMBOL, &left, &top, &right, &bottom);
252            hocr_str << "\n       <span class='ocrx_cinfo' title='x_bboxes "
253                     << left << " " << top << " " << right << " " << bottom
254                     << "; x_conf " << res_it->Confidence(RIL_SYMBOL) << "'>";
255          }
256          hocr_str << HOcrEscape(grapheme.get()).c_str();
257          if (hocr_boxes) {
258            hocr_str << "</span>";
259            tesseract::ChoiceIterator ci(*res_it);
260            if (lstm_choice_mode == 1 && ci.Timesteps() != nullptr) {
261              std::vector<std::vector<std::pair<const char *, float>>> *symbol =
262                  ci.Timesteps();
263              hocr_str << "\n        <span class='ocr_symbol'"
264                       << " id='"
265                       << "symbol_" << page_id << "_" << wcnt << "_" << scnt
266                       << "'>";
267              for (const auto &timestep : *symbol) {
268                hocr_str << "\n         <span class='ocrx_cinfo'"
269                         << " id='"
270                         << "timestep" << page_id << "_" << wcnt << "_" << tcnt
271                         << "'>";
272                for (auto conf : timestep) {
273                  hocr_str << "\n          <span class='ocrx_cinfo'"
274                           << " id='"
275                           << "choice_" << page_id << "_" << wcnt << "_" << ccnt
276                           << "'"
277                           << " title='x_confs " << int(conf.second * 100) << "'>"
278                           << HOcrEscape(conf.first).c_str() << "</span>";
279                  ++ccnt;
280                }
281                hocr_str << "</span>";
282                ++tcnt;
283              }
284              hocr_str << "\n        </span>";
285              ++scnt;
286            } else if (lstm_choice_mode == 2) {
287              hocr_str << "\n        <span class='ocrx_cinfo'"
288                       << " id='"
289                       << "lstm_choices_" << page_id << "_" << wcnt << "_" << tcnt
290                       << "'>";
291              do {
292                const char *choice = ci.GetUTF8Text();
293                float choiceconf = ci.Confidence();
294                if (choice != nullptr) {
295                  hocr_str << "\n         <span class='ocrx_cinfo'"
296                           << " id='"
297                           << "choice_" << page_id << "_" << wcnt << "_" << ccnt
298                           << "'"
299                           << " title='x_confs " << choiceconf << "'>"
300                           << HOcrEscape(choice).c_str() << "</span>";
301                  ccnt++;
302                }
303              } while (ci.Next());
304              hocr_str << "\n        </span>";
305              tcnt++;
306            }
307          }
308        }
309        res_it->Next(RIL_SYMBOL);
310      } while (!res_it->Empty(RIL_BLOCK) && !res_it->IsAtBeginningOf(RIL_WORD));
311      if (italic) {
312        hocr_str << "</em>";
313      }
314      if (bold) {
315        hocr_str << "</strong>";
316      }
317      if (lstm_choice_mode == 1 && !hocr_boxes && rawTimestepMap != nullptr) {
318        for (const auto &symbol : *rawTimestepMap) {
319          hocr_str << "\n       <span class='ocr_symbol'"
320                   << " id='"
321                   << "symbol_" << page_id << "_" << wcnt << "_" << scnt << "'>";
322          for (const auto &timestep : symbol) {
323            hocr_str << "\n        <span class='ocrx_cinfo'"
324                     << " id='"
325                     << "timestep" << page_id << "_" << wcnt << "_" << tcnt
326                     << "'>";
327            for (auto &&conf : timestep) {
328              hocr_str << "\n         <span class='ocrx_cinfo'"
329                       << " id='"
330                       << "choice_" << page_id << "_" << wcnt << "_" << ccnt
331                       << "'"
332                       << " title='x_confs " << int(conf.second * 100) << "'>"
333                       << HOcrEscape(conf.first).c_str() << "</span>";
334              ++ccnt;
335            }
336            hocr_str << "</span>";
337            ++tcnt;
338          }
339          hocr_str << "</span>";
340          ++scnt;
341        }
342      } else if (lstm_choice_mode == 2 && !hocr_boxes && CTCMap != nullptr) {
343        for (const auto &timestep : *CTCMap) {
344          if (timestep.size() > 0) {
345            hocr_str << "\n       <span class='ocrx_cinfo'"
346                     << " id='"
347                     << "lstm_choices_" << page_id << "_" << wcnt << "_" << tcnt
348                     << "'>";
349            for (auto &j : timestep) {
350              float conf = 100 - tesseract_->lstm_rating_coefficient * j.second;
351              if (conf < 0.0f) {
352                conf = 0.0f;
353              }
354              if (conf > 100.0f) {
355                conf = 100.0f;
356              }
357              hocr_str << "\n        <span class='ocrx_cinfo'"
358                       << " id='"
359                       << "choice_" << page_id << "_" << wcnt << "_" << ccnt
360                       << "'"
361                       << " title='x_confs " << conf << "'>"
362                       << HOcrEscape(j.first).c_str() << "</span>";
363              ccnt++;
364            }
365            hocr_str << "</span>";
366            tcnt++;
367          }
368        }
369      }
370      if (hocr_boxes || lstm_choice_mode > 0) {
371        hocr_str << "\n      ";
372      }
373      hocr_str << "</span>";
374      tcnt = 1;
375      ccnt = 1;
376      wcnt++;
377      if (last_word_in_line) {
378        hocr_str << "\n     </span>";
379        lcnt++;
380      }
381      if (last_word_in_para) {
382        hocr_str << "\n    </p>\n";
383        pcnt++;
384        para_is_ltr = true; 
385      }
386      if (last_word_in_block) {
387        hocr_str << "   </div>\n";
388        bcnt++;
389      }
390    }
391    hocr_str << "  </div>\n";
392    const std::string &text = hocr_str.str();
393    char *result = new char[text.length() + 1];
394    strcpy(result, text.c_str());
395    return result;
396  }
397  TessHOcrRenderer::TessHOcrRenderer(const char *outputbase)
398      : TessResultRenderer(outputbase, "hocr") {
399    font_info_ = false;
400  }
401  TessHOcrRenderer::TessHOcrRenderer(const char *outputbase, bool font_info)
402      : TessResultRenderer(outputbase, "hocr") {
403    font_info_ = font_info;
404  }
405  bool TessHOcrRenderer::BeginDocumentHandler() {
406    AppendString(
407        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
408        "<!DOCTYPE html PUBLIC \"-
409        "    \"http:&bsol;&bsol;www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
410        "<html xmlns=\"http:&bsol;&bsol;www.w3.org/1999/xhtml\" xml:lang=\"en\" "
411        "lang=\"en\">\n <head>\n  <title>");
412    AppendString(title());
413    AppendString(
414        "</title>\n"
415        "  <meta http-equiv=\"Content-Type\" content=\"text/html;"
416        "charset=utf-8\"/>\n"
417        "  <meta name='ocr-system' content='tesseract " TESSERACT_VERSION_STR
418        "' />\n"
419        "  <meta name='ocr-capabilities' content='ocr_page ocr_carea ocr_par"
420        " ocr_line ocrx_word ocrp_wconf");
421    if (font_info_) {
422      AppendString(" ocrp_lang ocrp_dir ocrp_font ocrp_fsize");
423    }
424    AppendString(
425        "'/>\n"
426        " </head>\n"
427        " <body>\n");
428    return true;
429  }
430  bool TessHOcrRenderer::EndDocumentHandler() {
431    AppendString(" </body>\n</html>\n");
432    return true;
433  }
434  bool TessHOcrRenderer::AddImageHandler(TessBaseAPI *api) {
435    const std::unique_ptr<const char[]> hocr(api->GetHOCRText(imagenum()));
436    if (hocr == nullptr) {
437      return false;
438    }
439    AppendString(hocr.get());
440    return true;
441  }
442  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cjkpitch.cpp</h3>
            <pre><code>1  #include "cjkpitch.h"
2  #include "topitch.h"
3  #include "tovars.h"
4  #include <algorithm> 
5  #include <cmath>
6  #include <vector>    
7  namespace tesseract {
8  static BOOL_VAR(textord_space_size_is_variable, false,
9                  "If true, word delimiter spaces are assumed to have "
10                  "variable width, even though characters have fixed pitch.");
11  static const float kFPTolerance = 0.1f;
12  static const float kFixedPitchThreshold = 0.35f;
13  class SimpleStats {
14  public:
15    SimpleStats() = default;
16    ~SimpleStats() = default;
17    void Clear() {
18      values_.clear();
19      finalized_ = false;
20    }
21    void Add(float value) {
22      values_.push_back(value);
23      finalized_ = false;
24    }
25    void Finish() {
26      std::sort(values_.begin(), values_.end());
27      finalized_ = true;
28    }
29    float ile(double frac) {
30      if (!finalized_) {
31        Finish();
32      }
33      if (values_.empty()) {
34        return 0.0f;
35      }
36      if (frac >= 1.0) {
37        return values_.back();
38      }
39      if (frac <= 0.0 || values_.size() == 1) {
40        return values_[0];
41      }
42      int index = static_cast<int>((values_.size() - 1) * frac);
43      float reminder = (values_.size() - 1) * frac - index;
44      return values_[index] * (1.0f - reminder) + values_[index + 1] * reminder;
45    }
46    float median() {
47      return ile(0.5);
48    }
49    float minimum() {
50      if (!finalized_) {
51        Finish();
52      }
53      if (values_.empty()) {
54        return 0.0f;
55      }
56      return values_[0];
57    }
58    bool empty() const {
59      return values_.empty();
60    }
61    int size() const {
62      return values_.size();
63    }
64  private:
65    bool finalized_ = false;
66    std::vector<float> values_;
67  };
68  class LocalCorrelation {
69  public:
70    struct float_pair {
71      float x, y;
72      int vote;
73    };
74    LocalCorrelation() : finalized_(false) {}
75    ~LocalCorrelation() = default;
76    void Finish() {
77      std::sort(values_.begin(), values_.end(), float_pair_compare);
78      finalized_ = true;
79    }
80    void Clear() {
81      finalized_ = false;
82    }
83    void Add(float x, float y, int v) {
84      struct float_pair value;
85      value.x = x;
86      value.y = y;
87      value.vote = v;
88      values_.push_back(value);
89      finalized_ = false;
90    }
91    float EstimateYFor(float x, float r) {
92      ASSERT_HOST(finalized_);
93      unsigned start = 0, end = values_.size();
94      while (start < values_.size() && values_[start].x < x * (1 - r)) {
95        start++;
96      }
97      while (end > 0 && values_[end - 1].x > x * (1 + r)) {
98        end--;
99      }
100      if (start >= end) {
101        start = 0;
102        end = values_.size();
103      }
104      float rc = 0;
105      int vote = 0;
106      for (auto i = start; i < end; i++) {
107        rc += values_[i].vote * x * values_[i].y / values_[i].x;
108        vote += values_[i].vote;
109      }
110      return vote == 0 ? 0.0f : rc / vote;
111    }
112  private:
113    static bool float_pair_compare(const float_pair f_a, const float_pair f_b) {
114      return f_a.x < f_b.x;
115    }
116    bool finalized_;
117    std::vector<struct float_pair> values_;
118  };
119  class FPChar {
120  public:
121    enum Alignment { ALIGN_UNKNOWN, ALIGN_GOOD, ALIGN_BAD };
122    FPChar()
123        : box_()
124        , real_body_()
125        , from_(nullptr)
126        , to_(nullptr)
127        , num_blobs_(0)
128        , max_gap_(0)
129        , final_(false)
130        , alignment_(ALIGN_UNKNOWN)
131        , merge_to_prev_(false)
132        , delete_flag_(false) {}
133    void Init(BLOBNBOX *blob) {
134      box_ = blob->bounding_box();
135      real_body_ = box_;
136      from_ = to_ = blob;
137      num_blobs_ = 1;
138    }
139    void Merge(const FPChar &next) {
140      int gap = real_body_.x_gap(next.real_body_);
141      if (gap > max_gap_) {
142        max_gap_ = gap;
143      }
144      box_ += next.box_;
145      real_body_ += next.real_body_;
146      to_ = next.to_;
147      num_blobs_ += next.num_blobs_;
148    }
149    const TBOX &box() const {
150      return box_;
151    }
152    void set_box(const TBOX &box) {
153      box_ = box;
154    }
155    const TBOX &real_body() const {
156      return real_body_;
157    }
158    bool is_final() const {
159      return final_;
160    }
161    void set_final(bool flag) {
162      final_ = flag;
163    }
164    const Alignment &alignment() const {
165      return alignment_;
166    }
167    void set_alignment(Alignment alignment) {
168      alignment_ = alignment;
169    }
170    bool merge_to_prev() const {
171      return merge_to_prev_;
172    }
173    void set_merge_to_prev(bool flag) {
174      merge_to_prev_ = flag;
175    }
176    bool delete_flag() const {
177      return delete_flag_;
178    }
179    void set_delete_flag(bool flag) {
180      delete_flag_ = flag;
181    }
182    int max_gap() const {
183      return max_gap_;
184    }
185    int num_blobs() const {
186      return num_blobs_;
187    }
188  private:
189    TBOX box_; 
190    TBOX real_body_; 
191    BLOBNBOX *from_; 
192    BLOBNBOX *to_;   
193    int num_blobs_;  
194    int max_gap_;    
195    bool final_; 
196    Alignment alignment_; 
197    bool merge_to_prev_;  
198    int delete_flag_; 
199  };
200  class FPRow {
201  public:
202    FPRow() : all_pitches_(), all_gaps_(), good_pitches_(), good_gaps_(), heights_(), characters_() {}
203    ~FPRow() = default;
204    void Init(TO_ROW *row);
205    void EstimatePitch(bool pass1);
206    void Pass1Analyze();
207    bool Pass2Analyze();
208    void MergeFragments();
209    void FinalizeLargeChars();
210    void OutputEstimations();
211    void DebugOutputResult(int row_index);
212    int good_pitches() {
213      return good_pitches_.size();
214    }
215    float pitch() {
216      return pitch_;
217    }
218    float estimated_pitch() {
219      return estimated_pitch_;
220    }
221    void set_estimated_pitch(float v) {
222      estimated_pitch_ = v;
223    }
224    float height() {
225      return height_;
226    }
227    float height_pitch_ratio() {
228      if (good_pitches_.size() < 2) {
229        return -1.0;
230      }
231      return height_ / good_pitches_.median();
232    }
233    float gap() {
234      return gap_;
235    }
236    size_t num_chars() {
237      return characters_.size();
238    }
239    FPChar *character(int i) {
240      return &characters_[i];
241    }
242    const TBOX &box(int i) {
243      return characters_[i].box();
244    }
245    const TBOX &real_body(int i) {
246      return characters_[i].real_body();
247    }
248    bool is_box_modified(int i) {
249      return !(characters_[i].box() == characters_[i].real_body());
250    }
251    float center_x(int i) {
252      return (characters_[i].box().left() + characters_[i].box().right()) / 2.0;
253    }
254    bool is_final(int i) {
255      return characters_[i].is_final();
256    }
257    void finalize(int i) {
258      characters_[i].set_final(true);
259    }
260    bool is_good(int i) {
261      return characters_[i].alignment() == FPChar::ALIGN_GOOD;
262    }
263    void mark_good(int i) {
264      characters_[i].set_alignment(FPChar::ALIGN_GOOD);
265    }
266    void mark_bad(int i) {
267      characters_[i].set_alignment(FPChar::ALIGN_BAD);
268    }
269    void clear_alignment(int i) {
270      characters_[i].set_alignment(FPChar::ALIGN_UNKNOWN);
271    }
272  private:
273    static float x_overlap_fraction(const TBOX &box1, const TBOX &box2) {
274      if (std::min(box1.width(), box2.width()) == 0) {
275        return 0.0;
276      }
277      return -box1.x_gap(box2) / static_cast<float>(std::min(box1.width(), box2.width()));
278    }
<span onclick='openModal()' class='match'>279    static bool mostly_overlap(const TBOX &box1, const TBOX &box2) {
280      return x_overlap_fraction(box1, box2) > 0.9;
281    }
282    static bool significant_overlap(const TBOX &box1, const TBOX &box2) {
283      if (std::min(box1.width(), box2.width()) == 0) {
</span>284        return false;
285      }
286      int overlap = -box1.x_gap(box2);
287      return overlap > 1 || x_overlap_fraction(box1, box2) > 0.1;
288    }
289    static float box_pitch(const TBOX &ref, const TBOX &box) {
290      return abs(ref.left() + ref.right() - box.left() - box.right()) / 2.0;
291    }
292    static bool is_good_pitch(float pitch, const TBOX &box1, const TBOX &box2) {
293      if (box1.width() >= pitch * (1.0 + kFPTolerance) ||
294          box2.width() >= pitch * (1.0 + kFPTolerance) ||
295          box1.height() >= pitch * (1.0 + kFPTolerance) ||
296          box2.height() >= pitch * (1.0 + kFPTolerance)) {
297        return false;
298      }
299      const float real_pitch = box_pitch(box1, box2);
300      if (std::fabs(real_pitch - pitch) < pitch * kFPTolerance) {
301        return true;
302      }
303      if (textord_space_size_is_variable) {
304        if (real_pitch > pitch && real_pitch < pitch * 2.0 && real_pitch - box1.x_gap(box2) < pitch) {
305          return true;
306        }
307      }
308      return false;
309    }
310    static bool is_interesting_blob(const BLOBNBOX *blob) {
311      return !blob->joined_to_prev() && blob->flow() != BTFT_LEADER;
312    }
313    void DeleteChars() {
314      unsigned index = 0;
315      for (unsigned i = 0; i < characters_.size(); ++i) {
316        if (!characters_[i].delete_flag()) {
317          if (index != i) {
318            characters_[index] = characters_[i];
319          }
320          index++;
321        }
322      }
323      characters_.resize(index);
324    }
325    float pitch_ = 0.0f;           
326    float estimated_pitch_ = 0.0f; 
327    float height_ = 0.0f; 
328    float gap_ = 0.0f;    
329    SimpleStats all_pitches_;
330    SimpleStats all_gaps_;
331    SimpleStats good_pitches_;
332    SimpleStats good_gaps_;
333    SimpleStats heights_;
334    std::vector<FPChar> characters_;
335    TO_ROW *real_row_ = nullptr; 
336  };
337  void FPRow::Init(TO_ROW *row) {
338    ASSERT_HOST(row != nullptr);
339    ASSERT_HOST(row->xheight > 0);
340    real_row_ = row;
341    real_row_->pitch_decision = PITCH_CORR_PROP; 
342    BLOBNBOX_IT blob_it = row->blob_list();
343    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
344      if (is_interesting_blob(blob_it.data())) {
345        FPChar fp_char;
346        fp_char.Init(blob_it.data());
347        if (!characters_.empty() && significant_overlap(fp_char.box(), characters_.back().box())) {
348          characters_.back().Merge(fp_char);
349        } else {
350          characters_.push_back(fp_char);
351        }
352        TBOX bound = blob_it.data()->bounding_box();
353        if (bound.height() * 3.0 > bound.width()) {
354          heights_.Add(bound.height());
355        }
356      }
357    }
358    heights_.Finish();
359    height_ = heights_.ile(0.875);
360  }
361  void FPRow::OutputEstimations() {
362    if (good_pitches_.empty()) {
363      pitch_ = 0.0f;
364      real_row_->pitch_decision = PITCH_CORR_PROP;
365      return;
366    }
367    pitch_ = good_pitches_.median();
368    real_row_->fixed_pitch = pitch_;
369    real_row_->kern_size = real_row_->pr_nonsp =
370        std::min(good_gaps_.ile(0.125), std::max(pitch_ - height_, 0.0f));
371    real_row_->body_size = pitch_ - real_row_->kern_size;
372    if (good_pitches_.size() < all_pitches_.size() * kFixedPitchThreshold) {
373      real_row_->pitch_decision = PITCH_CORR_PROP;
374      return;
375    } else if (good_pitches_.size() > all_pitches_.size() * 0.75) {
376      real_row_->pitch_decision = PITCH_DEF_FIXED;
377    } else {
378      real_row_->pitch_decision = PITCH_CORR_FIXED;
379    }
380    real_row_->space_size = real_row_->pr_space = pitch_;
381    real_row_->min_space = (pitch_ + good_gaps_.minimum()) * 0.5;
382    real_row_->max_nonspace =
383        std::max(pitch_ * 0.25 + good_gaps_.minimum(), static_cast<double>(good_gaps_.ile(0.875)));
384    int space_threshold = std::min((real_row_->max_nonspace + real_row_->min_space) / 2,
385                                   static_cast<int>(real_row_->xheight));
386    for (size_t i = 0; i < num_chars(); ++i) {
387      if (characters_[i].max_gap() > real_row_->max_nonspace) {
388        real_row_->max_nonspace = characters_[i].max_gap();
389      }
390    }
391    real_row_->space_threshold = std::min((real_row_->max_nonspace + real_row_->min_space) / 2,
392                                          static_cast<int>(real_row_->xheight));
393    real_row_->used_dm_model = false;
394    ICOORDELT_IT cell_it = &real_row_->char_cells;
395    auto *cell = new ICOORDELT(real_body(0).left(), 0);
396    cell_it.add_after_then_move(cell);
397    int right = real_body(0).right();
398    for (size_t i = 1; i < num_chars(); ++i) {
399      if ((is_final(i - 1) || is_final(i)) &&
400          real_body(i - 1).x_gap(real_body(i)) > space_threshold) {
401        cell = new ICOORDELT(right + 1, 0);
402        cell_it.add_after_then_move(cell);
403        while (right + pitch_ < box(i).left()) {
404          right += pitch_;
405          cell = new ICOORDELT(right + 1, 0);
406          cell_it.add_after_then_move(cell);
407        }
408        right = box(i).left();
409      }
410      cell = new ICOORDELT((right + real_body(i).left()) / 2, 0);
411      cell_it.add_after_then_move(cell);
412      right = real_body(i).right();
413    }
414    cell = new ICOORDELT(right + 1, 0);
415    cell_it.add_after_then_move(cell);
416  }
417  void FPRow::EstimatePitch(bool pass1) {
418    good_pitches_.Clear();
419    all_pitches_.Clear();
420    good_gaps_.Clear();
421    all_gaps_.Clear();
422    heights_.Clear();
423    if (num_chars() == 0) {
424      return;
425    }
426    int32_t cx0, cx1;
427    bool prev_was_good = is_good(0);
428    cx0 = center_x(0);
429    heights_.Add(box(0).height());
430    for (size_t i = 1; i < num_chars(); i++) {
431      cx1 = center_x(i);
432      int32_t pitch = cx1 - cx0;
433      int32_t gap = std::max(0, real_body(i - 1).x_gap(real_body(i)));
434      heights_.Add(box(i).height());
435      if (pitch > height_ * 0.5) {
436        all_pitches_.Add(pitch);
437        all_gaps_.Add(gap);
438        if (is_good(i)) {
439          if (pass1 ||
440              (prev_was_good && std::fabs(estimated_pitch_ - pitch) < kFPTolerance * estimated_pitch_)) {
441            good_pitches_.Add(pitch);
442            if (!is_box_modified(i - 1) && !is_box_modified(i)) {
443              good_gaps_.Add(gap);
444            }
445          }
446          prev_was_good = true;
447        } else {
448          prev_was_good = false;
449        }
450      }
451      cx0 = cx1;
452    }
453    good_pitches_.Finish();
454    all_pitches_.Finish();
455    good_gaps_.Finish();
456    all_gaps_.Finish();
457    heights_.Finish();
458    height_ = heights_.ile(0.875);
459    if (all_pitches_.empty()) {
460      pitch_ = 0.0f;
461      gap_ = 0.0f;
462    } else if (good_pitches_.size() < 2) {
463      pitch_ = all_pitches_.median();
464      ASSERT_HOST(pitch_ > 0.0f);
465      gap_ = all_gaps_.ile(0.125);
466    } else {
467      pitch_ = good_pitches_.median();
468      ASSERT_HOST(pitch_ > 0.0f);
469      gap_ = good_gaps_.ile(0.125);
470    }
471  }
472  void FPRow::DebugOutputResult(int row_index) {
473    if (num_chars() > 0) {
474      tprintf(
475          "Row %d: pitch_decision=%d, fixed_pitch=%f, max_nonspace=%d, "
476          "space_size=%f, space_threshold=%d, xheight=%f\n",
477          row_index, static_cast<int>(real_row_->pitch_decision), real_row_->fixed_pitch,
478          real_row_->max_nonspace, real_row_->space_size, real_row_->space_threshold,
479          real_row_->xheight);
480      for (unsigned i = 0; i < num_chars(); i++) {
481        tprintf("Char %u: is_final=%d is_good=%d num_blobs=%d: ", i, is_final(i), is_good(i),
482                character(i)->num_blobs());
483        box(i).print();
484      }
485    }
486  }
487  void FPRow::Pass1Analyze() {
488    if (num_chars() < 2) {
489      return;
490    }
491    if (estimated_pitch_ > 0.0f) {
492      for (size_t i = 2; i < num_chars(); i++) {
493        if (is_good_pitch(estimated_pitch_, box(i - 2), box(i - 1)) &&
494            is_good_pitch(estimated_pitch_, box(i - 1), box(i))) {
495          mark_good(i - 1);
496        }
497      }
498    } else {
499      for (size_t i = 2; i < num_chars(); i++) {
500        if (is_good_pitch(box_pitch(box(i - 2), box(i - 1)), box(i - 1), box(i))) {
501          mark_good(i - 1);
502        }
503      }
504    }
505    character(0)->set_alignment(character(1)->alignment());
506    character(num_chars() - 1)->set_alignment(character(num_chars() - 2)->alignment());
507  }
508  bool FPRow::Pass2Analyze() {
509    bool changed = false;
510    if (num_chars() <= 1 || estimated_pitch_ == 0.0f) {
511      return false;
512    }
513    for (size_t i = 0; i < num_chars(); i++) {
514      if (is_final(i)) {
515        continue;
516      }
517      FPChar::Alignment alignment = character(i)->alignment();
518      bool intersecting = false;
519      bool not_intersecting = false;
520      if (i < num_chars() - 1 && is_final(i + 1)) {
521        bool skipped_whitespaces = false;
522        float c1 = center_x(i + 1) - 1.5 * estimated_pitch_;
523        while (c1 > box(i).right()) {
524          skipped_whitespaces = true;
525          c1 -= estimated_pitch_;
526        }
527        TBOX ibody(c1, box(i).bottom(), c1 + estimated_pitch_, box(i).top());
528        int j = i;
529        TBOX merged;
530        while (j >= 0 && !is_final(j) && mostly_overlap(ibody, box(j)) &&
531               merged.bounding_union(box(j)).height() < estimated_pitch_ * (1 + kFPTolerance)) {
532          merged += box(j);
533          j--;
534        }
535        if (j >= 0 && significant_overlap(ibody, box(j))) {
536          if (!is_final(j)) {
537            intersecting = true;
538          }
539        } else {
540          not_intersecting = true;
541          if (i - j > 0) {
542            if (i - j == 1) {
543              if (!skipped_whitespaces) {
544                mark_good(i);
545              }
546              if (box(i).width() <= estimated_pitch_ * 0.5) {
547                ibody += box(i);
548                character(i)->set_box(ibody);
549              }
550              character(i)->set_merge_to_prev(false);
551              finalize(i);
552            } else {
553              for (int k = i; k > j + 1; k--) {
554                character(k)->set_merge_to_prev(true);
555              }
556            }
557          }
558        }
559      }
560      if (i > 0 && is_final(i - 1)) {
561        bool skipped_whitespaces = false;
562        float c1 = center_x(i - 1) + 1.5 * estimated_pitch_;
563        while (c1 < box(i).left()) {
564          skipped_whitespaces = true;
565          c1 += estimated_pitch_;
566        }
567        TBOX ibody(c1 - estimated_pitch_, box(i).bottom(), c1, box(i).top());
568        size_t j = i;
569        TBOX merged;
570        while (j < num_chars() && !is_final(j) && mostly_overlap(ibody, box(j)) &&
571               merged.bounding_union(box(j)).height() < estimated_pitch_ * (1 + kFPTolerance)) {
572          merged += box(j);
573          j++;
574        }
575        if (j < num_chars() && significant_overlap(ibody, box(j))) {
576          if (!is_final(j)) {
577            intersecting = true;
578          }
579        } else {
580          not_intersecting = true;
581          if (j - i > 0) {
582            if (j - i == 1) {
583              if (!skipped_whitespaces) {
584                mark_good(i);
585              }
586              if (box(i).width() <= estimated_pitch_ * 0.5) {
587                ibody += box(i);
588                character(i)->set_box(ibody);
589              }
590              character(i)->set_merge_to_prev(false);
591              finalize(i);
592            } else {
593              for (size_t k = i + 1; k < j; k++) {
594                character(k)->set_merge_to_prev(true);
595              }
596            }
597          }
598        }
599      }
600      if (intersecting && !not_intersecting) {
601        mark_bad(i);
602      }
603      if (character(i)->alignment() != alignment || character(i)->merge_to_prev()) {
604        changed = true;
605      }
606    }
607    return changed;
608  }
609  void FPRow::MergeFragments() {
610    int last_char = 0;
611    for (size_t j = 0; j < num_chars(); ++j) {
612      if (character(j)->merge_to_prev()) {
613        character(last_char)->Merge(*character(j));
614        character(j)->set_delete_flag(true);
615        clear_alignment(last_char);
616        character(j - 1)->set_merge_to_prev(false);
617      } else {
618        last_char = j;
619      }
620    }
621    DeleteChars();
622  }
623  void FPRow::FinalizeLargeChars() {
624    float row_pitch = estimated_pitch();
625    for (size_t i = 0; i < num_chars(); i++) {
626      if (is_final(i)) {
627        continue;
628      }
629      if (i > 0 && is_final(i - 1) && i < num_chars() - 1 && is_final(i + 1)) {
630        finalize(i);
631        continue;
632      }
633      float cx = center_x(i);
634      TBOX ibody(cx - 0.5 * row_pitch, 0, cx + 0.5 * row_pitch, 1);
635      if (i > 0) {
636        if (x_overlap_fraction(ibody, box(i - 1)) > 0.1) {
637          continue;
638        }
639        if (!is_final(i - 1)) {
640          TBOX merged = box(i);
641          merged += box(i - 1);
642          if (merged.width() < row_pitch) {
643            continue;
644          }
645        }
646      }
647      if (i < num_chars() - 1) {
648        if (x_overlap_fraction(ibody, box(i + 1)) > 0.1) {
649          continue;
650        }
651        if (!is_final(i + 1)) {
652          TBOX merged = box(i);
653          merged += box(i + 1);
654          if (merged.width() < row_pitch) {
655            continue;
656          }
657        }
658      }
659      finalize(i);
660    }
661    for (size_t i = 0; i < num_chars(); i++) {
662      if (!is_final(i)) {
663        continue;
664      }
665      bool good_pitch = false;
666      bool bad_pitch = false;
667      if (i > 0 && is_final(i - 1)) {
668        if (is_good_pitch(row_pitch, box(i - 1), box(i))) {
669          good_pitch = true;
670        } else {
671          bad_pitch = true;
672        }
673      }
674      if (i < num_chars() - 1 && is_final(i + 1)) {
675        if (is_good_pitch(row_pitch, box(i), box(i + 1))) {
676          good_pitch = true;
677        } else {
678          bad_pitch = true;
679        }
680      }
681      if (good_pitch && !bad_pitch) {
682        mark_good(i);
683      } else if (!good_pitch && bad_pitch) {
684        mark_bad(i);
685      }
686    }
687  }
688  class FPAnalyzer {
689  public:
690    FPAnalyzer(ICOORD page_tr, TO_BLOCK_LIST *port_blocks);
691    ~FPAnalyzer() = default;
692    void Pass1Analyze() {
693      for (auto &row : rows_) {
694        row.Pass1Analyze();
695      }
696    }
697    void EstimatePitch(bool pass1);
698    bool maybe_fixed_pitch() {
699      if (rows_.empty() || rows_.size() <= num_bad_rows_ + num_tall_rows_ + 1) {
700        return false;
701      }
702      return true;
703    }
704    void MergeFragments() {
705      for (auto &row : rows_) {
706        row.MergeFragments();
707      }
708    }
709    void FinalizeLargeChars() {
710      for (auto &row : rows_) {
711        row.FinalizeLargeChars();
712      }
713    }
714    bool Pass2Analyze() {
715      bool changed = false;
716      for (auto &row : rows_) {
717        if (row.Pass2Analyze()) {
718          changed = true;
719        }
720      }
721      return changed;
722    }
723    void OutputEstimations() {
724      for (auto &row : rows_) {
725        row.OutputEstimations();
726      }
727    }
728    void DebugOutputResult() {
729      tprintf("FPAnalyzer: final result\n");
730      for (size_t i = 0; i < rows_.size(); i++) {
731        rows_[i].DebugOutputResult(i);
732      }
733    }
734    size_t num_rows() {
735      return rows_.size();
736    }
737    unsigned max_iteration() {
738      return max_chars_per_row_ + 100;
739    }
740  private:
741    ICOORD page_tr_;
742    std::vector<FPRow> rows_;
743    unsigned num_tall_rows_;
744    unsigned num_bad_rows_;
745    unsigned num_empty_rows_;
746    unsigned max_chars_per_row_;
747  };
748  FPAnalyzer::FPAnalyzer(ICOORD page_tr, TO_BLOCK_LIST *port_blocks)
749      : page_tr_(page_tr)
750      , num_tall_rows_(0)
751      , num_bad_rows_(0)
752      , num_empty_rows_(0)
753      , max_chars_per_row_(0) {
754    TO_BLOCK_IT block_it(port_blocks);
755    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
756      TO_BLOCK *block = block_it.data();
757      if (!block->get_rows()->empty()) {
758        ASSERT_HOST(block->xheight > 0);
759        find_repeated_chars(block, false);
760      }
761    }
762    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
763      TO_ROW_IT row_it = block_it.data()->get_rows();
764      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
765        FPRow row;
766        row.Init(row_it.data());
767        rows_.push_back(row);
768        size_t num_chars = rows_.back().num_chars();
769        if (num_chars <= 1) {
770          num_empty_rows_++;
771        }
772        if (num_chars > max_chars_per_row_) {
773          max_chars_per_row_ = num_chars;
774        }
775      }
776    }
777  }
778  void FPAnalyzer::EstimatePitch(bool pass1) {
779    LocalCorrelation pitch_height_stats;
780    num_tall_rows_ = 0;
781    num_bad_rows_ = 0;
782    pitch_height_stats.Clear();
783    for (auto &row : rows_) {
784      row.EstimatePitch(pass1);
785      if (row.good_pitches()) {
786        pitch_height_stats.Add(row.height() + row.gap(), row.pitch(), row.good_pitches());
787        if (row.height_pitch_ratio() > 1.1) {
788          num_tall_rows_++;
789        }
790      } else {
791        num_bad_rows_++;
792      }
793    }
794    pitch_height_stats.Finish();
795    for (auto &row : rows_) {
796      if (row.good_pitches() >= 5) {
797        row.set_estimated_pitch(row.pitch());
798      } else if (row.num_chars() > 1) {
799        float estimated_pitch = pitch_height_stats.EstimateYFor(row.height() + row.gap(), 0.1f);
800        if (estimated_pitch > row.pitch() || row.pitch() > row.height() * 2.0) {
801          row.set_estimated_pitch(estimated_pitch);
802        } else {
803          row.set_estimated_pitch(row.pitch());
804        }
805      }
806    }
807  }
808  void compute_fixed_pitch_cjk(ICOORD page_tr, TO_BLOCK_LIST *port_blocks) {
809    FPAnalyzer analyzer(page_tr, port_blocks);
810    if (analyzer.num_rows() == 0) {
811      return;
812    }
813    analyzer.Pass1Analyze();
814    analyzer.EstimatePitch(true);
815    analyzer.Pass1Analyze();
816    analyzer.EstimatePitch(true);
817    if (!analyzer.maybe_fixed_pitch()) {
818      if (textord_debug_pitch_test) {
819        tprintf("Page doesn't seem to contain fixed pitch rows\n");
820      }
821      return;
822    }
823    unsigned iteration = 0;
824    do {
825      analyzer.MergeFragments();
826      analyzer.FinalizeLargeChars();
827      analyzer.EstimatePitch(false);
828      iteration++;
829    } while (analyzer.Pass2Analyze() && iteration < analyzer.max_iteration());
830    if (textord_debug_pitch_test) {
831      tprintf("compute_fixed_pitch_cjk finished after %u iteration (limit=%u)\n", iteration,
832              analyzer.max_iteration());
833    }
834    analyzer.OutputEstimations();
835    if (textord_debug_pitch_test) {
836      analyzer.DebugOutputResult();
837    }
838  }
839  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-hocrrenderer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cjkpitch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>61  char *TessBaseAPI::GetHOCRText(int page_number) {
62    return GetHOCRText(nullptr, page_number);
63  }
64  char *TessBaseAPI::GetHOCRText(ETEXT_DESC *monitor, int page_number) {
65    if (tesseract_ == nullptr ||
66        (page_res_ == nullptr && Recognize(monitor) < 0)) {
</pre></code></div>
                <div class="column column_space"><pre><code>279    static bool mostly_overlap(const TBOX &box1, const TBOX &box2) {
280      return x_overlap_fraction(box1, box2) > 0.9;
281    }
282    static bool significant_overlap(const TBOX &box1, const TBOX &box2) {
283      if (std::min(box1.width(), box2.width()) == 0) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    