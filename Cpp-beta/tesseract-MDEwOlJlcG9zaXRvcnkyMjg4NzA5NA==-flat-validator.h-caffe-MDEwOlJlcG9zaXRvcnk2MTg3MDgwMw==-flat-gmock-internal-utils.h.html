
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 23.058823529411764%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-validator.h</h3>
            <pre><code>1  #ifndef TESSERACT_TRAINING_VALIDATOR_H_
2  #define TESSERACT_TRAINING_VALIDATOR_H_
3  #include "export.h"
4  #include <tesseract/unichar.h>
5  #include <memory>
6  #include <vector>
7  namespace tesseract {
8  enum class GraphemeNormMode {
9    kSingleString,
10    kCombined,
11    kGlyphSplit,
12    kIndividualUnicodes,
13  };
14  enum class ViramaScript : char32 {
15    kNonVirama = 0,
16    kDevanagari = 0x900,
17    kBengali = 0x980,
18    kGurmukhi = 0xa00,
19    kGujarati = 0xa80,
20    kOriya = 0xb00,
21    kTamil = 0xb80,
22    kTelugu = 0xc00,
23    kKannada = 0xc80,
24    kMalayalam = 0xd00,
25    kSinhala = 0xd80,
26    kMyanmar = 0x1000,
27    kKhmer = 0x1780,
28    kJavanese = 0xa980,
29  };
30  class TESS_UNICHARSET_TRAINING_API Validator {
31  public:
32    static bool ValidateCleanAndSegment(GraphemeNormMode g_mode, bool report_errors,
33                                        const std::vector<char32> &src,
34                                        std::vector<std::vector<char32>> *dest);
35    static bool IsZeroWidthMark(char32 ch) {
36      return ch == kZeroWidthSpace || ch == kLeftToRightMark || ch == kRightToLeftMark ||
37             ch == kInvalid;
38    }
39    virtual ~Validator();
40    static const char32 kZeroWidthSpace;
41    static const char32 kZeroWidthNonJoiner;
42    static const char32 kZeroWidthJoiner;
43    static const char32 kLeftToRightMark;
44    static const char32 kRightToLeftMark;
45    static const char32 kInvalid;
46  protected:
47    enum class CharClass {
48      kConsonant = 'C',
49      kVowel = 'V',
50      kVirama = 'H',             
51      kMatra = 'M',              
52      kMatraPiece = 'P',         
53      kVowelModifier = 'D',      
54      kZeroWidthNonJoiner = 'z', 
55      kZeroWidthJoiner = 'Z',    
56      kVedicMark = 'v',          
57      kNukta = 'N',              
58      kRobat = 'R',              
59      kOther = 'O',              
60      kWhitespace = ' ',
61      kCombiner = 'c', 
62    };
63    using IndicPair = std::pair<CharClass, char32>;
64    Validator(ViramaScript script, bool report_errors)
65        : script_(script), codes_used_(0), output_used_(0), report_errors_(report_errors) {}
66    static std::unique_ptr<Validator> ScriptValidator(ViramaScript script, bool report_errors);
67    bool ValidateCleanAndSegmentInternal(GraphemeNormMode g_mode, const std::vector<char32> &src,
68                                         std::vector<std::vector<char32>> *dest);
69    void MoveResultsToDest(GraphemeNormMode g_mode, std::vector<std::vector<char32>> *dest);
70    static ViramaScript MostFrequentViramaScript(const std::vector<char32> &utf32);
71    static bool IsVirama(char32 unicode);
72    static bool IsVedicAccent(char32 unicode);
73    bool IsSubscriptScript() const;
74    bool CodeOnlyToOutput() {
75      output_.push_back(codes_[codes_used_].second);
76      return ++codes_used_ == codes_.size();
77    }
78    void MultiCodePart(unsigned length) {
79      while (output_used_ + length < output_.size()) {
80        parts_.emplace_back(std::initializer_list<char32>{output_[output_used_++]});
81      }
82      parts_.emplace_back(std::initializer_list<char32>{output_[output_used_]});
83      while (++output_used_ < output_.size()) {
84        parts_.back().push_back(output_[output_used_]);
85      }
86    }
87    bool UseMultiCode(unsigned length) {
88      output_.push_back(codes_[codes_used_].second);
89      MultiCodePart(length);
90      return ++codes_used_ == codes_.size();
91    }
92    virtual bool ConsumeGraphemeIfValid() = 0;
93    void ComputeClassCodes(const std::vector<char32> &text);
94    virtual CharClass UnicodeToCharClass(char32 ch) const = 0;
95    void Clear();
96    static const int kIndicCodePageSize = 128;
97    static const char32 kMinIndicUnicode = 0x900;
98    static const char32 kMaxSinhalaUnicode = 0xdff;
99    static const char32 kMaxViramaScriptUnicode = 0x17ff;
100    static const char32 kSinhalaVirama = 0xdca;
101    static const char32 kMyanmarVirama = 0x1039;
<span onclick='openModal()' class='match'>102    static const char32 kKhmerVirama = 0x17d2;
103    static const char32 kJavaneseVirama = 0xa9c0;
104    static const char32 kMaxJavaneseUnicode = 0xa9df;
105    ViramaScript script_;
106    std::vector<IndicPair> codes_;
107    std::vector<std::vector<char32>> parts_;
108    std::vector<char32> output_;
</span>109    unsigned codes_used_;
110    unsigned output_used_;
111    bool report_errors_;
112  };
113  } 
114  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-internal-utils.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_
2  #define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_
3  #include <stdio.h>
4  #include <ostream>  
5  #include <string>
6  #include "gmock/internal/gmock-generated-internal-utils.h"
7  #include "gmock/internal/gmock-port.h"
8  #include "gtest/gtest.h"
9  namespace testing {
10  namespace internal {
11  GTEST_API_ string ConvertIdentifierNameToWords(const char* id_name);
12  template <typename Pointer>
13  struct PointeeOf {
14    typedef typename Pointer::element_type type;
15  };
16  template <typename T>
17  struct PointeeOf<T*> { typedef T type; };  
18  template <typename Pointer>
19  inline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {
20    return p.get();
21  }
22  template <typename Element>
23  inline Element* GetRawPointer(Element* p) { return p; }
24  template <typename T>
25  struct LinkedPtrLessThan {
26    bool operator()(const ::testing::internal::linked_ptr<T>& lhs,
27                    const ::testing::internal::linked_ptr<T>& rhs) const {
28      return lhs.get() < rhs.get();
29    }
30  };
31  #if (GTEST_OS_SYMBIAN && defined(_STLP_NO_WCHAR_T)) || \
32      (defined(_MSC_VER) && !defined(_NATIVE_WCHAR_T_DEFINED))
33  #else
34  # define GMOCK_WCHAR_T_IS_NATIVE_ 1
35  #endif
36  #ifdef __GNUC__
37  # define GMOCK_HAS_SIGNED_WCHAR_T_ 1
38  #endif
39  enum TypeKind {
40    kBool, kInteger, kFloatingPoint, kOther
41  };
42  template <typename T> struct KindOf {
43    enum { value = kOther };  
44  };
45  #define GMOCK_DECLARE_KIND_(type, kind) \
46    template <> struct KindOf<type> { enum { value = kind }; }
47  GMOCK_DECLARE_KIND_(bool, kBool);
48  GMOCK_DECLARE_KIND_(char, kInteger);
49  GMOCK_DECLARE_KIND_(signed char, kInteger);
50  GMOCK_DECLARE_KIND_(unsigned char, kInteger);
51  GMOCK_DECLARE_KIND_(short, kInteger);  
52  GMOCK_DECLARE_KIND_(unsigned short, kInteger);  
53  GMOCK_DECLARE_KIND_(int, kInteger);
54  GMOCK_DECLARE_KIND_(unsigned int, kInteger);
55  GMOCK_DECLARE_KIND_(long, kInteger);  
56  GMOCK_DECLARE_KIND_(unsigned long, kInteger);  
57  #if GMOCK_WCHAR_T_IS_NATIVE_
58  GMOCK_DECLARE_KIND_(wchar_t, kInteger);
59  #endif
60  GMOCK_DECLARE_KIND_(Int64, kInteger);
61  GMOCK_DECLARE_KIND_(UInt64, kInteger);
62  GMOCK_DECLARE_KIND_(float, kFloatingPoint);
63  GMOCK_DECLARE_KIND_(double, kFloatingPoint);
64  GMOCK_DECLARE_KIND_(long double, kFloatingPoint);
65  #undef GMOCK_DECLARE_KIND_
66  #define GMOCK_KIND_OF_(type) \
67    static_cast< ::testing::internal::TypeKind>( \
68        ::testing::internal::KindOf<type>::value)
69  #define GMOCK_IS_SIGNED_(T) (static_cast<T>(-1) < 0)
70  template <TypeKind kFromKind, typename From, TypeKind kToKind, typename To>
71  struct LosslessArithmeticConvertibleImpl : public false_type {};
72  template <>
73  struct LosslessArithmeticConvertibleImpl<kBool, bool, kBool, bool>
74      : public true_type {};  
75  template <typename To>
76  struct LosslessArithmeticConvertibleImpl<kBool, bool, kInteger, To>
77      : public true_type {};  
78  template <typename To>
79  struct LosslessArithmeticConvertibleImpl<kBool, bool, kFloatingPoint, To>
80      : public true_type {};  
81  template <typename From>
82  struct LosslessArithmeticConvertibleImpl<kInteger, From, kBool, bool>
83      : public false_type {};  
84  template <typename From, typename To>
85  struct LosslessArithmeticConvertibleImpl<kInteger, From, kInteger, To>
86      : public bool_constant<
87        ((sizeof(From) < sizeof(To)) &&
88         (!GMOCK_IS_SIGNED_(From) || GMOCK_IS_SIGNED_(To))) ||
89        ((sizeof(From) == sizeof(To)) &&
90         (GMOCK_IS_SIGNED_(From) == GMOCK_IS_SIGNED_(To)))> {};  
91  #undef GMOCK_IS_SIGNED_
92  template <typename From, typename To>
93  struct LosslessArithmeticConvertibleImpl<kInteger, From, kFloatingPoint, To>
94      : public false_type {};  
95  template <typename From>
96  struct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kBool, bool>
97      : public false_type {};  
98  template <typename From, typename To>
99  struct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kInteger, To>
100      : public false_type {};  
101  template <typename From, typename To>
102  struct LosslessArithmeticConvertibleImpl<
103    kFloatingPoint, From, kFloatingPoint, To>
104      : public bool_constant<sizeof(From) <= sizeof(To)> {};  
105  template <typename From, typename To>
106  struct LosslessArithmeticConvertible
107      : public LosslessArithmeticConvertibleImpl<
108    GMOCK_KIND_OF_(From), From, GMOCK_KIND_OF_(To), To> {};  
109  class FailureReporterInterface {
110   public:
111    enum FailureType {
112      kNonfatal, kFatal
113    };
114    virtual ~FailureReporterInterface() {}
115    virtual void ReportFailure(FailureType type, const char* file, int line,
116                               const string& message) = 0;
117  };
118  GTEST_API_ FailureReporterInterface* GetFailureReporter();
119  inline void Assert(bool condition, const char* file, int line,
120                     const string& msg) {
121    if (!condition) {
122      GetFailureReporter()->ReportFailure(FailureReporterInterface::kFatal,
123                                          file, line, msg);
124    }
125  }
126  inline void Assert(bool condition, const char* file, int line) {
127    Assert(condition, file, line, "Assertion failed.");
128  }
129  inline void Expect(bool condition, const char* file, int line,
130                     const string& msg) {
131    if (!condition) {
132      GetFailureReporter()->ReportFailure(FailureReporterInterface::kNonfatal,
133                                          file, line, msg);
134    }
135  }
136  inline void Expect(bool condition, const char* file, int line) {
137    Expect(condition, file, line, "Expectation failed.");
138  }
139  enum LogSeverity {
140    kInfo = 0,
141    kWarning = 1
142  };
<span onclick='openModal()' class='match'>143  const char kInfoVerbosity[] = "info";
144  const char kWarningVerbosity[] = "warning";
145  const char kErrorVerbosity[] = "error";
146  GTEST_API_ bool LogIsVisible(LogSeverity severity);
147  GTEST_API_ void Log(LogSeverity severity,
148                      const string& message,
149                      int stack_frames_to_skip);
</span>150  template <typename T> struct is_reference : public false_type {};
151  template <typename T> struct is_reference<T&> : public true_type {};
152  template <typename T1, typename T2> struct type_equals : public false_type {};
153  template <typename T> struct type_equals<T, T> : public true_type {};
154  template <typename T> struct remove_reference { typedef T type; };  
155  template <typename T> struct remove_reference<T&> { typedef T type; }; 
156  template <typename T> struct DecayArray { typedef T type; };  
157  template <typename T, size_t N> struct DecayArray<T[N]> {
158    typedef const T* type;
159  };
160  template <typename T> struct DecayArray<T[]> {
161    typedef const T* type;
162  };
163  template <typename T>
164  inline T Invalid() {
165    return const_cast<typename remove_reference<T>::type&>(
166        *static_cast<volatile typename remove_reference<T>::type*>(NULL));
167  }
168  template <>
169  inline void Invalid<void>() {}
170  template <class RawContainer>
171  class StlContainerView {
172   public:
173    typedef RawContainer type;
174    typedef const type& const_reference;
175    static const_reference ConstReference(const RawContainer& container) {
176      testing::StaticAssertTypeEq<RawContainer,
177          GTEST_REMOVE_CONST_(RawContainer)>();
178      return container;
179    }
180    static type Copy(const RawContainer& container) { return container; }
181  };
182  template <typename Element, size_t N>
183  class StlContainerView<Element[N]> {
184   public:
185    typedef GTEST_REMOVE_CONST_(Element) RawElement;
186    typedef internal::NativeArray<RawElement> type;
187    typedef const type const_reference;
188    static const_reference ConstReference(const Element (&array)[N]) {
189      testing::StaticAssertTypeEq<Element, RawElement>();
190  #if GTEST_OS_SYMBIAN
191      return type(const_cast<Element*>(&array[0]), N, kReference);
192  #else
193      return type(array, N, kReference);
194  #endif  
195    }
196    static type Copy(const Element (&array)[N]) {
197  #if GTEST_OS_SYMBIAN
198      return type(const_cast<Element*>(&array[0]), N, kCopy);
199  #else
200      return type(array, N, kCopy);
201  #endif  
202    }
203  };
204  template <typename ElementPointer, typename Size>
205  class StlContainerView< ::std::tr1::tuple<ElementPointer, Size> > {
206   public:
207    typedef GTEST_REMOVE_CONST_(
208        typename internal::PointeeOf<ElementPointer>::type) RawElement;
209    typedef internal::NativeArray<RawElement> type;
210    typedef const type const_reference;
211    static const_reference ConstReference(
212        const ::std::tr1::tuple<ElementPointer, Size>& array) {
213      using ::std::tr1::get;
214      return type(get<0>(array), get<1>(array), kReference);
215    }
216    static type Copy(const ::std::tr1::tuple<ElementPointer, Size>& array) {
217      using ::std::tr1::get;
218      return type(get<0>(array), get<1>(array), kCopy);
219    }
220  };
221  template <typename T> class StlContainerView<T&>;
222  template <typename T>
223  struct RemoveConstFromKey {
224    typedef T type;
225  };
226  template <typename K, typename V>
227  struct RemoveConstFromKey<std::pair<const K, V> > {
228    typedef std::pair<K, V> type;
229  };
230  template <bool kValue>
231  struct BooleanConstant {};
232  }  
233  }  
234  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-validator.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-internal-utils.h</div>
                </div>
                <div class="column column_space"><pre><code>102    static const char32 kKhmerVirama = 0x17d2;
103    static const char32 kJavaneseVirama = 0xa9c0;
104    static const char32 kMaxJavaneseUnicode = 0xa9df;
105    ViramaScript script_;
106    std::vector<IndicPair> codes_;
107    std::vector<std::vector<char32>> parts_;
108    std::vector<char32> output_;
</pre></code></div>
                <div class="column column_space"><pre><code>143  const char kInfoVerbosity[] = "info";
144  const char kWarningVerbosity[] = "warning";
145  const char kErrorVerbosity[] = "error";
146  GTEST_API_ bool LogIsVisible(LogSeverity severity);
147  GTEST_API_ void Log(LogSeverity severity,
148                      const string& message,
149                      int stack_frames_to_skip);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    