
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6809815950920246%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-config.hpp</h3>
            <pre><code>1  #pragma once
2  #include <boost/config.hpp>
3  #include <boost/version.hpp>
4  #include <algorithm>
5  #include <array>
6  #include <chrono>
7  #include <optional>
8  #include <string>
9  using namespace std::chrono_literals;
10  namespace boost
11  {
12  namespace filesystem
13  {
14  	class path;
15  }
16  }
17  #define xstr(a) ver_str (a)
18  #define ver_str(a) #a
19  char const * const NANO_VERSION_STRING = xstr (TAG_VERSION_STRING);
20  char const * const NANO_MAJOR_VERSION_STRING = xstr (MAJOR_VERSION_STRING);
21  char const * const NANO_MINOR_VERSION_STRING = xstr (MINOR_VERSION_STRING);
22  char const * const NANO_PATCH_VERSION_STRING = xstr (PATCH_VERSION_STRING);
23  char const * const NANO_PRE_RELEASE_VERSION_STRING = xstr (PRE_RELEASE_VERSION_STRING);
24  char const * const BUILD_INFO = xstr (GIT_COMMIT_HASH BOOST_COMPILER) " \"BOOST " xstr (BOOST_VERSION) "\" BUILT " xstr (__DATE__);
25  #if defined(__has_feature)
26  #if __has_feature(address_sanitizer)
<span onclick='openModal()' class='match'>27  inline bool is_asan_build ()
28  {
29  	return true;
30  }
31  #else
32  inline bool is_asan_build ()
33  {
34  	return false;
35  }
36  #endif
37  #elif defined(__SANITIZE_ADDRESS__)
38  inline bool is_asan_build ()
39  {
40  	return true;
41  }
42  #else
43  inline bool is_asan_build ()
44  {
45  	return false;
46  }
</span>47  #endif
48  #if defined(__has_feature)
49  #if __has_feature(thread_sanitizer)
50  inline bool is_tsan_build ()
51  {
52  	return true;
53  }
54  #else
55  inline bool is_tsan_build ()
56  {
57  	return false;
58  }
59  #endif
60  #elif defined(__SANITIZE_THREAD__)
61  inline bool is_tsan_build ()
62  {
63  	return true;
64  }
65  #else
66  inline bool is_tsan_build ()
67  {
68  	return false;
69  }
70  #endif
71  namespace nano
72  {
73  uint8_t get_major_node_version ();
74  uint8_t get_minor_node_version ();
75  uint8_t get_patch_node_version ();
76  uint8_t get_pre_release_node_version ();
77  std::optional<std::string> get_env (char const * variable_name);
78  std::string get_env_or_default (char const * variable_name, std::string const default_value);
79  int get_env_int_or_default (char const * variable_name, int const default_value);
80  uint64_t get_env_threshold_or_default (char const * variable_name, uint64_t const default_value);
81  uint16_t test_node_port ();
82  uint16_t test_rpc_port ();
83  uint16_t test_ipc_port ();
84  uint16_t test_websocket_port ();
85  std::array<uint8_t, 2> test_magic_number ();
86  uint32_t test_scan_wallet_reps_delay ();
87  enum class networks : uint16_t
88  {
89  	invalid = 0x0,
90  	nano_dev_network = 0x5241, 
91  	nano_beta_network = 0x5242, 
92  	nano_live_network = 0x5243, 
93  	nano_test_network = 0x5258, 
94  };
95  enum class work_version
96  {
97  	unspecified,
98  	work_1
99  };
100  enum class block_type : uint8_t;
101  class root;
102  class block;
103  class block_details;
104  class work_thresholds
105  {
106  public:
107  	uint64_t const epoch_1;
108  	uint64_t const epoch_2;
109  	uint64_t const epoch_2_receive;
110  	uint64_t const base;
111  	uint64_t const entry;
112  	constexpr work_thresholds (uint64_t epoch_1_a, uint64_t epoch_2_a, uint64_t epoch_2_receive_a) :
113  		epoch_1 (epoch_1_a), epoch_2 (epoch_2_a), epoch_2_receive (epoch_2_receive_a),
114  		base (std::max ({ epoch_1, epoch_2, epoch_2_receive })),
115  		entry (std::min ({ epoch_1, epoch_2, epoch_2_receive }))
116  	{
117  	}
118  	work_thresholds () = delete;
119  	work_thresholds operator= (nano::work_thresholds const & other_a)
120  	{
121  		return other_a;
122  	}
123  	uint64_t threshold_entry (nano::work_version const, nano::block_type const) const;
124  	uint64_t threshold (nano::block_details const &) const;
125  	uint64_t threshold (nano::work_version const, nano::block_details const) const;
126  	uint64_t threshold_base (nano::work_version const) const;
127  	uint64_t value (nano::root const & root_a, uint64_t work_a) const;
128  	double normalized_multiplier (double const, uint64_t const) const;
129  	double denormalized_multiplier (double const, uint64_t const) const;
130  	uint64_t difficulty (nano::work_version const, nano::root const &, uint64_t const) const;
131  	uint64_t difficulty (nano::block const & block_a) const;
132  	bool validate_entry (nano::work_version const, nano::root const &, uint64_t const) const;
133  	bool validate_entry (nano::block const &) const;
134  	static nano::work_thresholds const publish_full;
135  	static nano::work_thresholds const publish_beta;
136  	static nano::work_thresholds const publish_dev;
137  	static nano::work_thresholds const publish_test;
138  };
139  class network_constants
140  {
141  	static constexpr std::chrono::seconds default_cleanup_period = std::chrono::seconds (60);
142  	static constexpr size_t default_max_peers_per_ip = 10;
143  public:
144  	network_constants (nano::work_thresholds & work_, nano::networks network_a) :
145  		current_network (network_a),
146  		work (work_),
147  		principal_weight_factor (1000), 
148  		default_node_port (44000),
149  		default_rpc_port (45000),
150  		default_ipc_port (46000),
151  		default_websocket_port (47000),
152  		aec_loop_interval_ms (300), 
153  		cleanup_period (default_cleanup_period),
154  		keepalive_period (std::chrono::seconds (15)),
155  		idle_timeout (default_cleanup_period * 2),
156  		silent_connection_tolerance_time (std::chrono::seconds (120)),
157  		syn_cookie_cutoff (std::chrono::seconds (5)),
158  		bootstrap_interval (std::chrono::seconds (15 * 60)),
159  		max_peers_per_ip (default_max_peers_per_ip),
160  		max_peers_per_subnetwork (default_max_peers_per_ip * 4),
161  		ipv6_subnetwork_prefix_for_limiting (64), 
162  		peer_dump_interval (std::chrono::seconds (5 * 60)),
163  		vote_broadcast_interval (15 * 1000)
164  	{
165  		if (is_live_network ())
166  		{
167  			default_node_port = 7075;
168  			default_rpc_port = 7076;
169  			default_ipc_port = 7077;
170  			default_websocket_port = 7078;
171  		}
172  		else if (is_beta_network ())
173  		{
174  			default_node_port = 54000;
175  			default_rpc_port = 55000;
176  			default_ipc_port = 56000;
177  			default_websocket_port = 57000;
178  		}
179  		else if (is_test_network ())
180  		{
181  			default_node_port = test_node_port ();
182  			default_rpc_port = test_rpc_port ();
183  			default_ipc_port = test_ipc_port ();
184  			default_websocket_port = test_websocket_port ();
185  		}
186  		else if (is_dev_network ())
187  		{
188  			aec_loop_interval_ms = 20;
189  			cleanup_period = std::chrono::seconds (1);
190  			keepalive_period = std::chrono::seconds (1);
191  			idle_timeout = cleanup_period * 15;
192  			max_peers_per_ip = 20;
193  			max_peers_per_subnetwork = max_peers_per_ip * 4;
194  			peer_dump_interval = std::chrono::seconds (1);
195  			vote_broadcast_interval = 500;
196  			telemetry_request_cooldown = 500ms;
197  			telemetry_cache_cutoff = 2000ms;
198  			telemetry_request_interval = 500ms;
199  			telemetry_broadcast_interval = 500ms;
200  			optimistic_activation_delay = 2s;
201  		}
202  	}
203  	static char const * active_network_err_msg;
204  	nano::networks current_network{ nano::network_constants::active_network };
205  	nano::work_thresholds & work;
206  	unsigned principal_weight_factor;
207  	uint16_t default_node_port;
208  	uint16_t default_rpc_port;
209  	uint16_t default_ipc_port;
210  	uint16_t default_websocket_port;
211  	unsigned aec_loop_interval_ms;
212  	std::chrono::seconds cleanup_period;
213  	std::chrono::milliseconds cleanup_period_half () const
214  	{
215  		return std::chrono::duration_cast<std::chrono::milliseconds> (cleanup_period) / 2;
216  	}
217  	std::chrono::seconds cleanup_cutoff () const
218  	{
219  		return cleanup_period * 5;
220  	}
221  	std::chrono::seconds keepalive_period;
222  	std::chrono::seconds idle_timeout;
223  	std::chrono::seconds silent_connection_tolerance_time;
224  	std::chrono::seconds syn_cookie_cutoff;
225  	std::chrono::seconds bootstrap_interval;
226  	size_t max_peers_per_ip;
227  	size_t max_peers_per_subnetwork;
228  	size_t ipv6_subnetwork_prefix_for_limiting;
229  	std::chrono::seconds peer_dump_interval;
230  	uint64_t vote_broadcast_interval;
231  	std::chrono::milliseconds telemetry_request_cooldown{ 1000 * 15 };
232  	std::chrono::milliseconds telemetry_request_interval{ 1000 * 60 };
233  	std::chrono::milliseconds telemetry_broadcast_interval{ 1000 * 60 };
234  	std::chrono::milliseconds telemetry_cache_cutoff{ 1000 * 130 }; 
235  	std::chrono::seconds optimistic_activation_delay{ 30 };
236  	nano::networks network () const
237  	{
238  		return current_network;
239  	}
240  	static void set_active_network (nano::networks network_a)
241  	{
242  		active_network = network_a;
243  	}
244  	static bool set_active_network (std::string network_a)
245  	{
246  		auto error{ false };
247  		if (network_a == "live")
248  		{
249  			active_network = nano::networks::nano_live_network;
250  		}
251  		else if (network_a == "beta")
252  		{
253  			active_network = nano::networks::nano_beta_network;
254  		}
255  		else if (network_a == "dev")
256  		{
257  			active_network = nano::networks::nano_dev_network;
258  		}
259  		else if (network_a == "test")
260  		{
261  			active_network = nano::networks::nano_test_network;
262  		}
263  		else
264  		{
265  			error = true;
266  		}
267  		return error;
268  	}
269  	char const * get_current_network_as_string ()
270  	{
271  		return is_live_network () ? "live" : is_beta_network () ? "beta"
272  		: is_test_network ()                                    ? "test"
273  																: "dev";
274  	}
275  	bool is_live_network () const
276  	{
277  		return current_network == nano::networks::nano_live_network;
278  	}
279  	bool is_beta_network () const
280  	{
281  		return current_network == nano::networks::nano_beta_network;
282  	}
283  	bool is_dev_network () const
284  	{
285  		return current_network == nano::networks::nano_dev_network;
286  	}
287  	bool is_test_network () const
288  	{
289  		return current_network == nano::networks::nano_test_network;
290  	}
291  	static nano::networks active_network;
292  	uint8_t const protocol_version = 0x13;
293  	uint8_t const protocol_version_min = 0x12;
294  	uint8_t const bootstrap_protocol_version_min = 0x13;
295  };
296  std::string get_node_toml_config_path (boost::filesystem::path const & data_path);
297  std::string get_rpc_toml_config_path (boost::filesystem::path const & data_path);
298  std::string get_access_toml_config_path (boost::filesystem::path const & data_path);
299  std::string get_qtwallet_toml_config_path (boost::filesystem::path const & data_path);
300  std::string get_tls_toml_config_path (boost::filesystem::path const & data_path);
301  bool running_within_valgrind ();
302  bool memory_intensive_instrumentation ();
303  bool slow_instrumentation ();
304  bool is_sanitizer_build ();
305  void force_nano_dev_network ();
306  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-bind_front_test.cc</h3>
            <pre><code>1  #include "absl/functional/bind_front.h"
2  #include <stddef.h>
3  #include <functional>
4  #include <memory>
5  #include <string>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/memory/memory.h"
9  namespace {
10  char CharAt(const char* s, size_t index) { return s[index]; }
11  TEST(BindTest, Basics) {
12    EXPECT_EQ('C', absl::bind_front(CharAt)("ABC", 2));
13    EXPECT_EQ('C', absl::bind_front(CharAt, "ABC")(2));
14    EXPECT_EQ('C', absl::bind_front(CharAt, "ABC", 2)());
15  }
16  TEST(BindTest, Lambda) {
17    auto lambda = [](int x, int y, int z) { return x + y + z; };
18    EXPECT_EQ(6, absl::bind_front(lambda)(1, 2, 3));
19    EXPECT_EQ(6, absl::bind_front(lambda, 1)(2, 3));
20    EXPECT_EQ(6, absl::bind_front(lambda, 1, 2)(3));
21    EXPECT_EQ(6, absl::bind_front(lambda, 1, 2, 3)());
22  }
23  struct Functor {
<span onclick='openModal()' class='match'>24    std::string operator()() & { return "&"; }
25    std::string operator()() const& { return "const&"; }
26    std::string operator()() && { return "&&"; }
27    std::string operator()() const&& { return "const&&"; }
</span>28  };
29  TEST(BindTest, PerfectForwardingOfBoundArgs) {
30    auto f = absl::bind_front(Functor());
31    const auto& cf = f;
32    EXPECT_EQ("&", f());
33    EXPECT_EQ("const&", cf());
34    EXPECT_EQ("&&", std::move(f)());
35    EXPECT_EQ("const&&", std::move(cf)());
36  }
37  struct ArgDescribe {
38    std::string operator()(int&) const { return "&"; }             
39    std::string operator()(const int&) const { return "const&"; }  
40    std::string operator()(int&&) const { return "&&"; }
41    std::string operator()(const int&&) const { return "const&&"; }
42  };
43  TEST(BindTest, PerfectForwardingOfFreeArgs) {
44    ArgDescribe f;
45    int i;
46    EXPECT_EQ("&", absl::bind_front(f)(static_cast<int&>(i)));
47    EXPECT_EQ("const&", absl::bind_front(f)(static_cast<const int&>(i)));
48    EXPECT_EQ("&&", absl::bind_front(f)(static_cast<int&&>(i)));
49    EXPECT_EQ("const&&", absl::bind_front(f)(static_cast<const int&&>(i)));
50  }
51  struct NonCopyableFunctor {
52    NonCopyableFunctor() = default;
53    NonCopyableFunctor(const NonCopyableFunctor&) = delete;
54    NonCopyableFunctor& operator=(const NonCopyableFunctor&) = delete;
55    const NonCopyableFunctor* operator()() const { return this; }
56  };
57  TEST(BindTest, RefToFunctor) {
58    NonCopyableFunctor ncf;
59    auto bound_ncf = absl::bind_front(std::ref(ncf));
60    auto bound_ncf_copy = bound_ncf;
61    EXPECT_EQ(&ncf, bound_ncf_copy());
62  }
63  struct Struct {
64    std::string value;
65  };
66  TEST(BindTest, StoreByCopy) {
67    Struct s = {"hello"};
68    auto f = absl::bind_front(&Struct::value, s);
69    auto g = f;
70    EXPECT_EQ("hello", f());
71    EXPECT_EQ("hello", g());
72    EXPECT_NE(&s.value, &f());
73    EXPECT_NE(&s.value, &g());
74    EXPECT_NE(&g(), &f());
75  }
76  struct NonCopyable {
77    explicit NonCopyable(const std::string& s) : value(s) {}
78    NonCopyable(const NonCopyable&) = delete;
79    NonCopyable& operator=(const NonCopyable&) = delete;
80    std::string value;
81  };
82  const std::string& GetNonCopyableValue(const NonCopyable& n) { return n.value; }
83  TEST(BindTest, StoreByRef) {
84    NonCopyable s("hello");
85    auto f = absl::bind_front(&GetNonCopyableValue, std::ref(s));
86    EXPECT_EQ("hello", f());
87    EXPECT_EQ(&s.value, &f());
88    auto g = std::move(f);  
89    EXPECT_EQ("hello", g());
90    EXPECT_EQ(&s.value, &g());
91    s.value = "goodbye";
92    EXPECT_EQ("goodbye", g());
93  }
94  TEST(BindTest, StoreByCRef) {
95    NonCopyable s("hello");
96    auto f = absl::bind_front(&GetNonCopyableValue, std::cref(s));
97    EXPECT_EQ("hello", f());
98    EXPECT_EQ(&s.value, &f());
99    auto g = std::move(f);  
100    EXPECT_EQ("hello", g());
101    EXPECT_EQ(&s.value, &g());
102    s.value = "goodbye";
103    EXPECT_EQ("goodbye", g());
104  }
105  const std::string& GetNonCopyableValueByWrapper(
106      std::reference_wrapper<NonCopyable> n) {
107    return n.get().value;
108  }
109  TEST(BindTest, StoreByRefInvokeByWrapper) {
110    NonCopyable s("hello");
111    auto f = absl::bind_front(GetNonCopyableValueByWrapper, std::ref(s));
112    EXPECT_EQ("hello", f());
113    EXPECT_EQ(&s.value, &f());
114    auto g = std::move(f);
115    EXPECT_EQ("hello", g());
116    EXPECT_EQ(&s.value, &g());
117    s.value = "goodbye";
118    EXPECT_EQ("goodbye", g());
119  }
120  TEST(BindTest, StoreByPointer) {
121    NonCopyable s("hello");
122    auto f = absl::bind_front(&NonCopyable::value, &s);
123    EXPECT_EQ("hello", f());
124    EXPECT_EQ(&s.value, &f());
125    auto g = std::move(f);
126    EXPECT_EQ("hello", g());
127    EXPECT_EQ(&s.value, &g());
128  }
129  int Sink(std::unique_ptr<int> p) {
130    return *p;
131  }
132  std::unique_ptr<int> Factory(int n) { return absl::make_unique<int>(n); }
133  TEST(BindTest, NonCopyableArg) {
134    EXPECT_EQ(42, absl::bind_front(Sink)(absl::make_unique<int>(42)));
135    EXPECT_EQ(42, absl::bind_front(Sink, absl::make_unique<int>(42))());
136  }
137  TEST(BindTest, NonCopyableResult) {
138    EXPECT_THAT(absl::bind_front(Factory)(42), ::testing::Pointee(42));
139    EXPECT_THAT(absl::bind_front(Factory, 42)(), ::testing::Pointee(42));
140  }
141  template <class T>
142  struct FalseCopyable {
143    FalseCopyable() {}
144    FalseCopyable(const FalseCopyable& other) : m(other.m) {}
145    FalseCopyable(FalseCopyable&& other) : m(std::move(other.m)) {}
146    T m;
147  };
148  int GetMember(FalseCopyable<std::unique_ptr<int>> x) { return *x.m; }
149  TEST(BindTest, WrappedMoveOnly) {
150    FalseCopyable<std::unique_ptr<int>> x;
151    x.m = absl::make_unique<int>(42);
152    auto f = absl::bind_front(&GetMember, std::move(x));
153    EXPECT_EQ(42, std::move(f)());
154  }
155  int Plus(int a, int b) { return a + b; }
156  TEST(BindTest, ConstExpr) {
157    constexpr auto f = absl::bind_front(CharAt);
158    EXPECT_EQ(f("ABC", 1), 'B');
159    static constexpr int five = 5;
160    constexpr auto plus5 = absl::bind_front(Plus, five);
161    EXPECT_EQ(plus5(1), 6);
162  #if !(defined(_MSC_VER) && _MSC_VER < 1910)
163    static constexpr char data[] = "DEF";
164    constexpr auto g = absl::bind_front(CharAt, data);
165    EXPECT_EQ(g(1), 'E');
166  #endif
167  }
168  struct ManglingCall {
169    int operator()(int, double, std::string) const { return 0; }
170  };
171  TEST(BindTest, Mangling) {
172    absl::bind_front(ManglingCall{}, 1, 3.3)("A");
173  }
174  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-config.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-bind_front_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>27  inline bool is_asan_build ()
28  {
29  	return true;
30  }
31  #else
32  inline bool is_asan_build ()
33  {
34  	return false;
35  }
36  #endif
37  #elif defined(__SANITIZE_ADDRESS__)
38  inline bool is_asan_build ()
39  {
40  	return true;
41  }
42  #else
43  inline bool is_asan_build ()
44  {
45  	return false;
46  }
</pre></code></div>
                <div class="column column_space"><pre><code>24    std::string operator()() & { return "&"; }
25    std::string operator()() const& { return "const&"; }
26    std::string operator()() && { return "&&"; }
27    std::string operator()() const&& { return "const&&"; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    