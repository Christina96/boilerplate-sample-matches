
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.872434830837493%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</h3>
            <pre><code>1  #include "normalis.h"
2  #include "tesseractclass.h"
3  namespace tesseract {
4  static int LeadingUnicharsToChopped(WERD_RES *word, int num_unichars) {
5    int num_chopped = 0;
6    for (int i = 0; i < num_unichars; i++) {
7      num_chopped += word->best_state[i];
8    }
9    return num_chopped;
10  }
11  static int TrailingUnicharsToChopped(WERD_RES *word, int num_unichars) {
12    int num_chopped = 0;
13    for (int i = 0; i < num_unichars; i++) {
14      num_chopped += word->best_state[word->best_state.size() - 1 - i];
15    }
16    return num_chopped;
17  }
18  static void YOutlierPieces(WERD_RES *word, int rebuilt_blob_index, int super_y_bottom,
19                             int sub_y_top, ScriptPos *leading_pos, int *num_leading_outliers,
20                             ScriptPos *trailing_pos, int *num_trailing_outliers) {
21    ScriptPos sp_unused1, sp_unused2;
22    int unused1, unused2;
23    if (!leading_pos) {
24      leading_pos = &sp_unused1;
25    }
26    if (!num_leading_outliers) {
27      num_leading_outliers = &unused1;
28    }
29    if (!trailing_pos) {
30      trailing_pos = &sp_unused2;
31    }
32    if (!num_trailing_outliers) {
33      num_trailing_outliers = &unused2;
34    }
<span onclick='openModal()' class='match'>35    *num_leading_outliers = *num_trailing_outliers = 0;
36    *leading_pos = *trailing_pos = SP_NORMAL;
37    int chopped_start = LeadingUnicharsToChopped(word, rebuilt_blob_index);
38    int num_chopped_pieces = word->best_state[rebuilt_blob_index];
39    ScriptPos last_pos = SP_NORMAL;
40    int trailing_outliers = 0;
</span>41    for (int i = 0; i < num_chopped_pieces; i++) {
42      TBOX box = word->chopped_word->blobs[chopped_start + i]->bounding_box();
43      ScriptPos pos = SP_NORMAL;
44      if (box.bottom() >= super_y_bottom) {
45        pos = SP_SUPERSCRIPT;
46      } else if (box.top() <= sub_y_top) {
47        pos = SP_SUBSCRIPT;
48      }
49      if (pos == SP_NORMAL) {
50        if (trailing_outliers == i) {
51          *num_leading_outliers = trailing_outliers;
52          *leading_pos = last_pos;
53        }
54        trailing_outliers = 0;
55      } else {
56        if (pos == last_pos) {
57          trailing_outliers++;
58        } else {
59          trailing_outliers = 1;
60        }
61      }
62      last_pos = pos;
63    }
64    *num_trailing_outliers = trailing_outliers;
65    *trailing_pos = last_pos;
66  }
67  bool Tesseract::SubAndSuperscriptFix(WERD_RES *word) {
68    if (word->tess_failed || word->word->flag(W_REP_CHAR) || !word->best_choice) {
69      return false;
70    }
71    int num_leading, num_trailing;
72    ScriptPos sp_leading, sp_trailing;
73    float leading_certainty, trailing_certainty;
74    float avg_certainty, unlikely_threshold;
75    GetSubAndSuperscriptCandidates(word, &num_leading, &sp_leading, &leading_certainty, &num_trailing,
76                                   &sp_trailing, &trailing_certainty, &avg_certainty,
77                                   &unlikely_threshold);
78    const char *leading_pos = sp_leading == SP_SUBSCRIPT ? "sub" : "super";
79    const char *trailing_pos = sp_trailing == SP_SUBSCRIPT ? "sub" : "super";
80    int num_blobs = word->best_choice->length();
81    int num_remainder_leading = 0, num_remainder_trailing = 0;
82    if (num_leading + num_trailing < num_blobs && unlikely_threshold < 0.0) {
83      int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
84      int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
85      int last_word_char = num_blobs - 1 - num_trailing;
86      float last_char_certainty = word->best_choice->certainty(last_word_char);
87      if (word->best_choice->unichar_id(last_word_char) != 0 &&
88          last_char_certainty <= unlikely_threshold) {
89        ScriptPos rpos;
90        YOutlierPieces(word, last_word_char, super_y_bottom, sub_y_top, nullptr, nullptr, &rpos,
91                       &num_remainder_trailing);
92        if (num_trailing > 0 && rpos != sp_trailing) {
93          num_remainder_trailing = 0;
94        }
95        if (num_remainder_trailing > 0 && last_char_certainty < trailing_certainty) {
96          trailing_certainty = last_char_certainty;
97        }
98      }
99      bool another_blob_available =
100          (num_remainder_trailing == 0) || num_leading + num_trailing + 1 < num_blobs;
101      int first_char_certainty = word->best_choice->certainty(num_leading);
102      if (another_blob_available && word->best_choice->unichar_id(num_leading) != 0 &&
103          first_char_certainty <= unlikely_threshold) {
104        ScriptPos lpos;
105        YOutlierPieces(word, num_leading, super_y_bottom, sub_y_top, &lpos, &num_remainder_leading,
106                       nullptr, nullptr);
107        if (num_leading > 0 && lpos != sp_leading) {
108          num_remainder_leading = 0;
109        }
110        if (num_remainder_leading > 0 && first_char_certainty < leading_certainty) {
111          leading_certainty = first_char_certainty;
112        }
113      }
114    }
115    if (num_leading + num_trailing + num_remainder_leading + num_remainder_trailing == 0) {
116      return false;
117    }
118    if (superscript_debug >= 1) {
119      tprintf("Candidate for superscript detection: %s (",
120              word->best_choice->unichar_string().c_str());
121      if (num_leading || num_remainder_leading) {
122        tprintf("%d.%d %s-leading ", num_leading, num_remainder_leading, leading_pos);
123      }
124      if (num_trailing || num_remainder_trailing) {
125        tprintf("%d.%d %s-trailing ", num_trailing, num_remainder_trailing, trailing_pos);
126      }
127      tprintf(")\n");
128    }
129    if (superscript_debug >= 3) {
130      word->best_choice->print();
131    }
132    if (superscript_debug >= 2) {
133      tprintf(" Certainties -- Average: %.2f  Unlikely thresh: %.2f  ", avg_certainty,
134              unlikely_threshold);
135      if (num_leading) {
136        tprintf("Orig. leading (min): %.2f  ", leading_certainty);
137      }
138      if (num_trailing) {
139        tprintf("Orig. trailing (min): %.2f  ", trailing_certainty);
140      }
141      tprintf("\n");
142    }
143    int num_chopped_leading = LeadingUnicharsToChopped(word, num_leading) + num_remainder_leading;
144    int num_chopped_trailing = TrailingUnicharsToChopped(word, num_trailing) + num_remainder_trailing;
145    int retry_leading = 0;
146    int retry_trailing = 0;
147    bool is_good = false;
148    WERD_RES *revised = TrySuperscriptSplits(num_chopped_leading, leading_certainty, sp_leading,
149                                             num_chopped_trailing, trailing_certainty, sp_trailing,
150                                             word, &is_good, &retry_leading, &retry_trailing);
151    if (is_good) {
152      word->ConsumeWordResults(revised);
153    } else if (retry_leading || retry_trailing) {
154      int retry_chopped_leading = LeadingUnicharsToChopped(revised, retry_leading);
155      int retry_chopped_trailing = TrailingUnicharsToChopped(revised, retry_trailing);
156      WERD_RES *revised2 = TrySuperscriptSplits(
157          retry_chopped_leading, leading_certainty, sp_leading, retry_chopped_trailing,
158          trailing_certainty, sp_trailing, revised, &is_good, &retry_leading, &retry_trailing);
159      if (is_good) {
160        word->ConsumeWordResults(revised2);
161      }
162      delete revised2;
163    }
164    delete revised;
165    return is_good;
166  }
167  void Tesseract::GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
168                                                 ScriptPos *leading_pos, float *leading_certainty,
169                                                 int *num_rebuilt_trailing, ScriptPos *trailing_pos,
170                                                 float *trailing_certainty, float *avg_certainty,
171                                                 float *unlikely_threshold) {
172    *avg_certainty = *unlikely_threshold = 0.0f;
173    *num_rebuilt_leading = *num_rebuilt_trailing = 0;
174    *leading_certainty = *trailing_certainty = 0.0f;
175    int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
176    int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
177    *leading_pos = *trailing_pos = SP_NORMAL;
178    int leading_outliers = 0;
179    int trailing_outliers = 0;
180    int num_normal = 0;
181    float normal_certainty_total = 0.0f;
182    float worst_normal_certainty = 0.0f;
183    ScriptPos last_pos = SP_NORMAL;
184    int num_blobs = word->rebuild_word->NumBlobs();
185    for (int b = 0; b < num_blobs; ++b) {
186      TBOX box = word->rebuild_word->blobs[b]->bounding_box();
187      ScriptPos pos = SP_NORMAL;
188      if (box.bottom() >= super_y_bottom) {
189        pos = SP_SUPERSCRIPT;
190      } else if (box.top() <= sub_y_top) {
191        pos = SP_SUBSCRIPT;
192      }
193      if (pos == SP_NORMAL) {
194        if (word->best_choice->unichar_id(b) != 0) {
195          float char_certainty = word->best_choice->certainty(b);
196          if (char_certainty < worst_normal_certainty) {
197            worst_normal_certainty = char_certainty;
198          }
199          num_normal++;
200          normal_certainty_total += char_certainty;
201        }
202        if (trailing_outliers == b) {
203          leading_outliers = trailing_outliers;
204          *leading_pos = last_pos;
205        }
206        trailing_outliers = 0;
207      } else {
208        if (last_pos == pos) {
209          trailing_outliers++;
210        } else {
211          trailing_outliers = 1;
212        }
213      }
214      last_pos = pos;
215    }
216    *trailing_pos = last_pos;
217    if (num_normal >= 3) { 
218      num_normal--;
219      normal_certainty_total -= worst_normal_certainty;
220    }
221    if (num_normal > 0) {
222      *avg_certainty = normal_certainty_total / num_normal;
223      *unlikely_threshold = superscript_worse_certainty * (*avg_certainty);
224    }
225    if (num_normal == 0 || (leading_outliers == 0 && trailing_outliers == 0)) {
226      return;
227    }
228    for (*leading_certainty = 0.0f, *num_rebuilt_leading = 0; *num_rebuilt_leading < leading_outliers;
229         (*num_rebuilt_leading)++) {
230      float char_certainty = word->best_choice->certainty(*num_rebuilt_leading);
231      if (char_certainty > *unlikely_threshold) {
232        break;
233      }
234      if (char_certainty < *leading_certainty) {
235        *leading_certainty = char_certainty;
236      }
237    }
238    for (*trailing_certainty = 0.0f, *num_rebuilt_trailing = 0;
239         *num_rebuilt_trailing < trailing_outliers; (*num_rebuilt_trailing)++) {
240      int blob_idx = num_blobs - 1 - *num_rebuilt_trailing;
241      float char_certainty = word->best_choice->certainty(blob_idx);
242      if (char_certainty > *unlikely_threshold) {
243        break;
244      }
245      if (char_certainty < *trailing_certainty) {
246        *trailing_certainty = char_certainty;
247      }
248    }
249  }
250  WERD_RES *Tesseract::TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
251                                            ScriptPos leading_pos, int num_chopped_trailing,
252                                            float trailing_certainty, ScriptPos trailing_pos,
253                                            WERD_RES *word, bool *is_good, int *retry_rebuild_leading,
254                                            int *retry_rebuild_trailing) {
255    int num_chopped = word->chopped_word->NumBlobs();
256    *retry_rebuild_leading = *retry_rebuild_trailing = 0;
257    BlamerBundle *bb0 = nullptr;
258    BlamerBundle *bb1 = nullptr;
259    WERD_RES *prefix = nullptr;
260    WERD_RES *core = nullptr;
261    WERD_RES *suffix = nullptr;
262    if (num_chopped_leading > 0) {
263      prefix = new WERD_RES(*word);
264      split_word(prefix, num_chopped_leading, &core, &bb0);
265    } else {
266      core = new WERD_RES(*word);
267    }
268    if (num_chopped_trailing > 0) {
269      int split_pt = num_chopped - num_chopped_trailing - num_chopped_leading;
270      split_word(core, split_pt, &suffix, &bb1);
271    }
272    int saved_cp_multiplier = classify_class_pruner_multiplier;
273    int saved_im_multiplier = classify_integer_matcher_multiplier;
274    if (prefix) {
275      classify_class_pruner_multiplier.set_value(0);
276      classify_integer_matcher_multiplier.set_value(0);
277      if (superscript_debug >= 3) {
278        tprintf(" recognizing first %d chopped blobs\n", num_chopped_leading);
279      }
280      recog_word_recursive(prefix);
281      if (superscript_debug >= 2) {
282        tprintf(" The leading bits look like %s %s\n", ScriptPosToString(leading_pos),
283                prefix->best_choice->unichar_string().c_str());
284      }
285      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
286      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
287    }
288    if (superscript_debug >= 3) {
289      tprintf(" recognizing middle %d chopped blobs\n",
290              num_chopped - num_chopped_leading - num_chopped_trailing);
291    }
292    if (suffix) {
293      classify_class_pruner_multiplier.set_value(0);
294      classify_integer_matcher_multiplier.set_value(0);
295      if (superscript_debug >= 3) {
296        tprintf(" recognizing last %d chopped blobs\n", num_chopped_trailing);
297      }
298      recog_word_recursive(suffix);
299      if (superscript_debug >= 2) {
300        tprintf(" The trailing bits look like %s %s\n", ScriptPosToString(trailing_pos),
301                suffix->best_choice->unichar_string().c_str());
302      }
303      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
304      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
305    }
306    bool good_prefix =
307        !prefix || BelievableSuperscript(superscript_debug >= 1, *prefix,
308                                         superscript_bettered_certainty * leading_certainty,
309                                         retry_rebuild_leading, nullptr);
310    bool good_suffix =
311        !suffix || BelievableSuperscript(superscript_debug >= 1, *suffix,
312                                         superscript_bettered_certainty * trailing_certainty, nullptr,
313                                         retry_rebuild_trailing);
314    *is_good = good_prefix && good_suffix;
315    if (!*is_good && !*retry_rebuild_leading && !*retry_rebuild_trailing) {
316      delete core;
317      delete prefix;
318      delete suffix;
319      delete bb1;
320      return nullptr;
321    }
322    recog_word_recursive(core);
323    if (suffix) {
324      suffix->SetAllScriptPositions(trailing_pos);
325      join_words(core, suffix, bb1);
326    }
327    if (prefix) {
328      prefix->SetAllScriptPositions(leading_pos);
329      join_words(prefix, core, bb0);
330      core = prefix;
331      prefix = nullptr;
332    }
333    if (superscript_debug >= 1) {
334      tprintf("%s superscript fix: %s\n", *is_good ? "ACCEPT" : "REJECT",
335              core->best_choice->unichar_string().c_str());
336    }
337    return core;
338  }
339  bool Tesseract::BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
340                                        int *left_ok, int *right_ok) const {
341    unsigned initial_ok_run_count = 0;
342    unsigned ok_run_count = 0;
343    float worst_certainty = 0.0f;
344    const WERD_CHOICE &wc = *word.best_choice;
345    const UnicityTable<FontInfo> &fontinfo_table = get_fontinfo_table();
346    for (unsigned i = 0; i < wc.length(); i++) {
347      TBLOB *blob = word.rebuild_word->blobs[i];
348      UNICHAR_ID unichar_id = wc.unichar_id(i);
349      float char_certainty = wc.certainty(i);
350      bool bad_certainty = char_certainty < certainty_threshold;
351      bool is_punc = wc.unicharset()->get_ispunctuation(unichar_id);
352      bool is_italic = word.fontinfo && word.fontinfo->is_italic();
353      BLOB_CHOICE *choice = word.GetBlobChoice(i);
354      if (choice && fontinfo_table.size() > 0) {
355        int font_id1 = choice->fontinfo_id();
356        bool font1_is_italic = font_id1 >= 0 ? fontinfo_table.at(font_id1).is_italic() : false;
357        int font_id2 = choice->fontinfo_id2();
358        is_italic = font1_is_italic && (font_id2 < 0 || fontinfo_table.at(font_id2).is_italic());
359      }
360      float height_fraction = 1.0f;
361      float char_height = blob->bounding_box().height();
362      float normal_height = char_height;
363      if (wc.unicharset()->top_bottom_useful()) {
364        int min_bot, max_bot, min_top, max_top;
365        wc.unicharset()->get_top_bottom(unichar_id, &min_bot, &max_bot, &min_top, &max_top);
366        float hi_height = max_top - max_bot;
367        float lo_height = min_top - min_bot;
368        normal_height = (hi_height + lo_height) / 2;
369        if (normal_height >= kBlnXHeight) {
370          height_fraction = char_height / normal_height;
371        }
372      }
373      bool bad_height = height_fraction < superscript_scaledown_ratio;
374      if (debug) {
375        if (is_italic) {
376          tprintf(" Rejecting: superscript is italic.\n");
377        }
378        if (is_punc) {
379          tprintf(" Rejecting: punctuation present.\n");
380        }
381        const char *char_str = wc.unicharset()->id_to_unichar(unichar_id);
382        if (bad_certainty) {
383          tprintf(
384              " Rejecting: don't believe character %s with certainty %.2f "
385              "which is less than threshold %.2f\n",
386              char_str, char_certainty, certainty_threshold);
387        }
388        if (bad_height) {
389          tprintf(
390              " Rejecting: character %s seems too small @ %.2f versus "
391              "expected %.2f\n",
392              char_str, char_height, normal_height);
393        }
394      }
395      if (bad_certainty || bad_height || is_punc || is_italic) {
396        if (ok_run_count == i) {
397          initial_ok_run_count = ok_run_count;
398        }
399        ok_run_count = 0;
400      } else {
401        ok_run_count++;
402      }
403      if (char_certainty < worst_certainty) {
404        worst_certainty = char_certainty;
405      }
406    }
407    bool all_ok = ok_run_count == wc.length();
408    if (all_ok && debug) {
409      tprintf(" Accept: worst revised certainty is %.2f\n", worst_certainty);
410    }
411    if (!all_ok) {
412      if (left_ok) {
413        *left_ok = initial_ok_run_count;
414      }
415      if (right_ok) {
416        *right_ok = ok_run_count;
417      }
418    }
419    return all_ok;
420  }
421  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</h3>
            <pre><code>1  #if !defined(HAS_STRPTIME)
2  #if !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__VXWORKS__)
3  #define HAS_STRPTIME \
4    1  
5  #endif
6  #endif
7  #if defined(HAS_STRPTIME) && HAS_STRPTIME
8  #if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__)
9  #define _XOPEN_SOURCE  
10  #endif
11  #endif
12  #include "absl/base/config.h"
13  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
14  #include <time.h>
15  #include <cctype>
16  #include <chrono>
17  #include <cstddef>
18  #include <cstdint>
19  #include <cstring>
20  #include <ctime>
21  #include <limits>
22  #include <string>
23  #include <vector>
24  #if !HAS_STRPTIME
25  #include <iomanip>
26  #include <sstream>
27  #endif
28  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
29  #include "time_zone_if.h"
30  namespace absl {
31  ABSL_NAMESPACE_BEGIN
32  namespace time_internal {
33  namespace cctz {
34  namespace detail {
35  namespace {
36  #if !HAS_STRPTIME
37  char* strptime(const char* s, const char* fmt, std::tm* tm) {
38    std::istringstream input(s);
39    input >> std::get_time(tm, fmt);
40    if (input.fail()) return nullptr;
41    return const_cast<char*>(s) +
42           (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
43  }
44  #endif
45  int ToTmWday(weekday wd) {
46    switch (wd) {
47      case weekday::sunday:
48        return 0;
49      case weekday::monday:
50        return 1;
51      case weekday::tuesday:
52        return 2;
53      case weekday::wednesday:
54        return 3;
55      case weekday::thursday:
56        return 4;
57      case weekday::friday:
58        return 5;
59      case weekday::saturday:
60        return 6;
61    }
62    return 0; &bsol;*NOTREACHED*/
63  }
64  weekday FromTmWday(int tm_wday) {
65    switch (tm_wday) {
66      case 0:
67        return weekday::sunday;
68      case 1:
69        return weekday::monday;
70      case 2:
71        return weekday::tuesday;
72      case 3:
73        return weekday::wednesday;
74      case 4:
75        return weekday::thursday;
76      case 5:
77        return weekday::friday;
78      case 6:
79        return weekday::saturday;
80    }
81    return weekday::sunday; &bsol;*NOTREACHED*/
82  }
83  std::tm ToTM(const time_zone::absolute_lookup& al) {
84    std::tm tm{};
85    tm.tm_sec = al.cs.second();
86    tm.tm_min = al.cs.minute();
87    tm.tm_hour = al.cs.hour();
88    tm.tm_mday = al.cs.day();
89    tm.tm_mon = al.cs.month() - 1;
90    if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
91      tm.tm_year = std::numeric_limits<int>::min();
92    } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
93      tm.tm_year = std::numeric_limits<int>::max();
94    } else {
95      tm.tm_year = static_cast<int>(al.cs.year() - 1900);
96    }
97    tm.tm_wday = ToTmWday(get_weekday(al.cs));
98    tm.tm_yday = get_yearday(al.cs) - 1;
99    tm.tm_isdst = al.is_dst ? 1 : 0;
100    return tm;
101  }
102  int ToWeek(const civil_day& cd, weekday week_start) {
103    const civil_day d(cd.year() % 400, cd.month(), cd.day());
104    return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
105  }
106  const char kDigits[] = "0123456789";
107  char* Format64(char* ep, int width, std::int_fast64_t v) {
108    bool neg = false;
109    if (v < 0) {
110      --width;
111      neg = true;
112      if (v == std::numeric_limits<std::int_fast64_t>::min()) {
113        std::int_fast64_t last_digit = -(v % 10);
114        v /= 10;
115        if (last_digit < 0) {
116          ++v;
117          last_digit += 10;
118        }
119        --width;
120        *--ep = kDigits[last_digit];
121      }
122      v = -v;
123    }
124    do {
125      --width;
126      *--ep = kDigits[v % 10];
127    } while (v /= 10);
128    while (--width >= 0) *--ep = '0';  
129    if (neg) *--ep = '-';
130    return ep;
131  }
132  char* Format02d(char* ep, int v) {
133    *--ep = kDigits[v % 10];
134    *--ep = kDigits[(v / 10) % 10];
135    return ep;
136  }
137  char* FormatOffset(char* ep, int offset, const char* mode) {
138    char sign = '+';
139    if (offset < 0) {
140      offset = -offset;  
141      sign = '-';
142    }
143    const int seconds = offset % 60;
144    const int minutes = (offset /= 60) % 60;
145    const int hours = offset /= 60;
146    const char sep = mode[0];
147    const bool ext = (sep != '\0' && mode[1] == '*');
148    const bool ccc = (ext && mode[2] == ':');
149    if (ext && (!ccc || seconds != 0)) {
150      ep = Format02d(ep, seconds);
151      *--ep = sep;
152    } else {
153      if (hours == 0 && minutes == 0) sign = '+';
154    }
155    if (!ccc || minutes != 0 || seconds != 0) {
156      ep = Format02d(ep, minutes);
157      if (sep != '\0') *--ep = sep;
158    }
159    ep = Format02d(ep, hours);
160    *--ep = sign;
161    return ep;
162  }
163  void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
164    for (std::size_t i = 2; i != 32; i *= 2) {
165      std::size_t buf_size = fmt.size() * i;
166      std::vector<char> buf(buf_size);
167      if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
168        out->append(&buf[0], len);
169        return;
170      }
171    }
172  }
173  template <typename T>
174  const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
175    if (dp != nullptr) {
176      const T kmin = std::numeric_limits<T>::min();
177      bool erange = false;
178      bool neg = false;
179      T value = 0;
180      if (*dp == '-') {
181        neg = true;
182        if (width <= 0 || --width != 0) {
183          ++dp;
184        } else {
185          dp = nullptr;  
186        }
187      }
188      if (const char* const bp = dp) {
189        while (const char* cp = strchr(kDigits, *dp)) {
190          int d = static_cast<int>(cp - kDigits);
191          if (d >= 10) break;
192          if (value < kmin / 10) {
193            erange = true;
194            break;
195          }
196          value *= 10;
197          if (value < kmin + d) {
198            erange = true;
199            break;
200          }
201          value -= d;
202          dp += 1;
203          if (width > 0 && --width == 0) break;
204        }
205        if (dp != bp && !erange && (neg || value != kmin)) {
206          if (!neg || value != 0) {
207            if (!neg) value = -value;  
208            if (min <= value && value <= max) {
209              *vp = value;
210            } else {
211              dp = nullptr;
212            }
213          } else {
214            dp = nullptr;
215          }
216        } else {
217          dp = nullptr;
218        }
219      }
220    }
221    return dp;
222  }
223  const int kDigits10_64 = 18;
224  const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
225      1,
226      10,
227      100,
228      1000,
229      10000,
230      100000,
231      1000000,
232      10000000,
233      100000000,
234      1000000000,
235      10000000000,
236      100000000000,
237      1000000000000,
238      10000000000000,
239      100000000000000,
240      1000000000000000,
241      10000000000000000,
242      100000000000000000,
243      1000000000000000000,
244  };
245  }  
246  std::string format(const std::string& format, const time_point<seconds>& tp,
247                     const detail::femtoseconds& fs, const time_zone& tz) {
248    std::string result;
249    result.reserve(format.size());  
250    const time_zone::absolute_lookup al = tz.lookup(tp);
251    const std::tm tm = ToTM(al);
252    char buf[3 + kDigits10_64];  
253    char* const ep = buf + sizeof(buf);
254    char* bp;  
255    const char* pending = format.c_str();  
256    const char* cur = pending;
257    const char* end = pending + format.length();
258    while (cur != end) {  
259      const char* start = cur;
260      while (cur != end && *cur != '%') ++cur;
261      if (cur != start && pending == start) {
262        result.append(pending, static_cast<std::size_t>(cur - pending));
263        pending = start = cur;
264      }
265      const char* percent = cur;
266      while (cur != end && *cur == '%') ++cur;
267      if (cur != start && pending == start) {
268        std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
269        result.append(pending, escaped);
270        pending += escaped * 2;
271        if (pending != cur && cur == end) {
272          result.push_back(*pending++);
273        }
274      }
275      if (cur == end || (cur - percent) % 2 == 0) continue;
276      if (strchr("YmdeUuWwHMSzZs%", *cur)) {
277        if (cur - 1 != pending) {
278          FormatTM(&result, std::string(pending, cur - 1), tm);
279        }
280        switch (*cur) {
281          case 'Y':
282            bp = Format64(ep, 0, al.cs.year());
283            result.append(bp, static_cast<std::size_t>(ep - bp));
284            break;
285          case 'm':
286            bp = Format02d(ep, al.cs.month());
287            result.append(bp, static_cast<std::size_t>(ep - bp));
288            break;
289          case 'd':
290          case 'e':
291            bp = Format02d(ep, al.cs.day());
292            if (*cur == 'e' && *bp == '0') *bp = ' ';  
293            result.append(bp, static_cast<std::size_t>(ep - bp));
294            break;
295          case 'U':
296            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
297            result.append(bp, static_cast<std::size_t>(ep - bp));
298            break;
299          case 'u':
300            bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
301            result.append(bp, static_cast<std::size_t>(ep - bp));
302            break;
303          case 'W':
304            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
305            result.append(bp, static_cast<std::size_t>(ep - bp));
306            break;
307          case 'w':
308            bp = Format64(ep, 0, tm.tm_wday);
309            result.append(bp, static_cast<std::size_t>(ep - bp));
310            break;
311          case 'H':
312            bp = Format02d(ep, al.cs.hour());
313            result.append(bp, static_cast<std::size_t>(ep - bp));
314            break;
315          case 'M':
316            bp = Format02d(ep, al.cs.minute());
317            result.append(bp, static_cast<std::size_t>(ep - bp));
318            break;
319          case 'S':
320            bp = Format02d(ep, al.cs.second());
321            result.append(bp, static_cast<std::size_t>(ep - bp));
322            break;
323          case 'z':
324            bp = FormatOffset(ep, al.offset, "");
325            result.append(bp, static_cast<std::size_t>(ep - bp));
326            break;
327          case 'Z':
328            result.append(al.abbr);
329            break;
330          case 's':
331            bp = Format64(ep, 0, ToUnixSeconds(tp));
332            result.append(bp, static_cast<std::size_t>(ep - bp));
333            break;
334          case '%':
335            result.push_back('%');
336            break;
337        }
338        pending = ++cur;
339        continue;
340      }
341      if (*cur == ':' && cur + 1 != end) {
342        if (*(cur + 1) == 'z') {
343          if (cur - 1 != pending) {
344            FormatTM(&result, std::string(pending, cur - 1), tm);
345          }
346          bp = FormatOffset(ep, al.offset, ":");
347          result.append(bp, static_cast<std::size_t>(ep - bp));
348          pending = cur += 2;
349          continue;
350        }
351        if (*(cur + 1) == ':' && cur + 2 != end) {
352          if (*(cur + 2) == 'z') {
353            if (cur - 1 != pending) {
354              FormatTM(&result, std::string(pending, cur - 1), tm);
355            }
356            bp = FormatOffset(ep, al.offset, ":*");
357            result.append(bp, static_cast<std::size_t>(ep - bp));
358            pending = cur += 3;
359            continue;
360          }
361          if (*(cur + 2) == ':' && cur + 3 != end) {
362            if (*(cur + 3) == 'z') {
363              if (cur - 1 != pending) {
364                FormatTM(&result, std::string(pending, cur - 1), tm);
365              }
366              bp = FormatOffset(ep, al.offset, ":*:");
367              result.append(bp, static_cast<std::size_t>(ep - bp));
368              pending = cur += 4;
369              continue;
370            }
371          }
372        }
373      }
374      if (*cur != 'E' || ++cur == end) continue;
375      if (*cur == 'T') {
376        if (cur - 2 != pending) {
377          FormatTM(&result, std::string(pending, cur - 2), tm);
378        }
379        result.append("T");
380        pending = ++cur;
381      } else if (*cur == 'z') {
382        if (cur - 2 != pending) {
383          FormatTM(&result, std::string(pending, cur - 2), tm);
384        }
385        bp = FormatOffset(ep, al.offset, ":");
386        result.append(bp, static_cast<std::size_t>(ep - bp));
387        pending = ++cur;
388      } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
389        if (cur - 2 != pending) {
390          FormatTM(&result, std::string(pending, cur - 2), tm);
391        }
392        bp = FormatOffset(ep, al.offset, ":*");
393        result.append(bp, static_cast<std::size_t>(ep - bp));
394        pending = cur += 2;
395      } else if (*cur == '*' && cur + 1 != end &&
396                 (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
397        if (cur - 2 != pending) {
398          FormatTM(&result, std::string(pending, cur - 2), tm);
399        }
400        char* cp = ep;
401        bp = Format64(cp, 15, fs.count());
402        while (cp != bp && cp[-1] == '0') --cp;
403        switch (*(cur + 1)) {
404          case 'S':
405            if (cp != bp) *--bp = '.';
406            bp = Format02d(bp, al.cs.second());
407            break;
408          case 'f':
409            if (cp == bp) *--bp = '0';
410            break;
411        }
412        result.append(bp, static_cast<std::size_t>(cp - bp));
413        pending = cur += 2;
414      } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
415        if (cur - 2 != pending) {
416          FormatTM(&result, std::string(pending, cur - 2), tm);
417        }
418        bp = Format64(ep, 4, al.cs.year());
419        result.append(bp, static_cast<std::size_t>(ep - bp));
420        pending = cur += 2;
421      } else if (std::isdigit(*cur)) {
422        int n = 0;
423        if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
424          if (*np == 'S' || *np == 'f') {
425            if (cur - 2 != pending) {
426              FormatTM(&result, std::string(pending, cur - 2), tm);
427            }
428            bp = ep;
429            if (n > 0) {
430              if (n > kDigits10_64) n = kDigits10_64;
431              bp = Format64(bp, n,
432                            (n > 15) ? fs.count() * kExp10[n - 15]
433                                     : fs.count() / kExp10[15 - n]);
434              if (*np == 'S') *--bp = '.';
435            }
436            if (*np == 'S') bp = Format02d(bp, al.cs.second());
437            result.append(bp, static_cast<std::size_t>(ep - bp));
438            pending = cur = ++np;
439          }
440        }
441      }
442    }
443    if (end != pending) {
444      FormatTM(&result, std::string(pending, end), tm);
445    }
446    return result;
447  }
448  namespace {
449  const char* ParseOffset(const char* dp, const char* mode, int* offset) {
450    if (dp != nullptr) {
451      const char first = *dp++;
452      if (first == '+' || first == '-') {
453        char sep = mode[0];
454        int hours = 0;
455        int minutes = 0;
456        int seconds = 0;
457        const char* ap = ParseInt(dp, 2, 0, 23, &hours);
458        if (ap != nullptr && ap - dp == 2) {
459          dp = ap;
460          if (sep != '\0' && *ap == sep) ++ap;
461          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
462          if (bp != nullptr && bp - ap == 2) {
463            dp = bp;
464            if (sep != '\0' && *bp == sep) ++bp;
465            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
466            if (cp != nullptr && cp - bp == 2) dp = cp;
467          }
468          *offset = ((hours * 60 + minutes) * 60) + seconds;
469          if (first == '-') *offset = -*offset;
470        } else {
471          dp = nullptr;
472        }
473      } else if (first == 'Z' || first == 'z') {  
474        *offset = 0;
475      } else {
476        dp = nullptr;
477      }
478    }
479    return dp;
480  }
481  const char* ParseZone(const char* dp, std::string* zone) {
482    zone->clear();
483    if (dp != nullptr) {
484      while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
485      if (zone->empty()) dp = nullptr;
486    }
487    return dp;
488  }
489  const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
490    if (dp != nullptr) {
491      std::int_fast64_t v = 0;
492      std::int_fast64_t exp = 0;
493      const char* const bp = dp;
494      while (const char* cp = strchr(kDigits, *dp)) {
495        int d = static_cast<int>(cp - kDigits);
496        if (d >= 10) break;
497        if (exp < 15) {
498          exp += 1;
499          v *= 10;
500          v += d;
501        }
502        ++dp;
503      }
504      if (dp != bp) {
505        v *= kExp10[15 - exp];
506        *subseconds = detail::femtoseconds(v);
507      } else {
508        dp = nullptr;
509      }
510    }
511    return dp;
512  }
513  const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
514    if (dp != nullptr) {
515      dp = strptime(dp, fmt, tm);
516    }
517    return dp;
518  }
519  bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
520    const civil_year y(*year % 400);
521    civil_day cd = prev_weekday(y, week_start);  
522    cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
523    if (const year_t shift = cd.year() - y.year()) {
524      if (shift > 0) {
525        if (*year > std::numeric_limits<year_t>::max() - shift) return false;
526      } else {
527        if (*year < std::numeric_limits<year_t>::min() - shift) return false;
528      }
529      *year += shift;
530    }
531    tm->tm_mon = cd.month() - 1;
532    tm->tm_mday = cd.day();
533    return true;
534  }
535  }  
536  bool parse(const std::string& format, const std::string& input,
537             const time_zone& tz, time_point<seconds>* sec,
538             detail::femtoseconds* fs, std::string* err) {
539    const char* data = input.c_str();  
540    while (std::isspace(*data)) ++data;
541    const year_t kyearmax = std::numeric_limits<year_t>::max();
542    const year_t kyearmin = std::numeric_limits<year_t>::min();
543    bool saw_year = false;
544    year_t year = 1970;
545    std::tm tm{};
546    tm.tm_year = 1970 - 1900;
547    tm.tm_mon = 1 - 1;  
548    tm.tm_mday = 1;
549    tm.tm_hour = 0;
550    tm.tm_min = 0;
<span onclick='openModal()' class='match'>551    tm.tm_sec = 0;
552    tm.tm_wday = 4;  
553    tm.tm_yday = 0;
554    tm.tm_isdst = 0;
555    auto subseconds = detail::femtoseconds::zero();
556    bool saw_offset = false;
557    int offset = 0;  
558    std::string zone = "UTC";
</span>559    const char* fmt = format.c_str();  
560    bool twelve_hour = false;
561    bool afternoon = false;
562    int week_num = -1;
563    weekday week_start = weekday::sunday;
564    bool saw_percent_s = false;
565    std::int_fast64_t percent_s = 0;
566    while (data != nullptr && *fmt != '\0') {
567      if (std::isspace(*fmt)) {
568        while (std::isspace(*data)) ++data;
569        while (std::isspace(*++fmt)) continue;
570        continue;
571      }
572      if (*fmt != '%') {
573        if (*data == *fmt) {
574          ++data;
575          ++fmt;
576        } else {
577          data = nullptr;
578        }
579        continue;
580      }
581      const char* percent = fmt;
582      if (*++fmt == '\0') {
583        data = nullptr;
584        continue;
585      }
586      switch (*fmt++) {
587        case 'Y':
588          data = ParseInt(data, 0, kyearmin, kyearmax, &year);
589          if (data != nullptr) saw_year = true;
590          continue;
591        case 'm':
592          data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
593          if (data != nullptr) tm.tm_mon -= 1;
594          week_num = -1;
595          continue;
596        case 'd':
597        case 'e':
598          data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
599          week_num = -1;
600          continue;
601        case 'U':
602          data = ParseInt(data, 0, 0, 53, &week_num);
603          week_start = weekday::sunday;
604          continue;
605        case 'W':
606          data = ParseInt(data, 0, 0, 53, &week_num);
607          week_start = weekday::monday;
608          continue;
609        case 'u':
610          data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
611          if (data != nullptr) tm.tm_wday %= 7;
612          continue;
613        case 'w':
614          data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
615          continue;
616        case 'H':
617          data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
618          twelve_hour = false;
619          continue;
620        case 'M':
621          data = ParseInt(data, 2, 0, 59, &tm.tm_min);
622          continue;
623        case 'S':
624          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
625          continue;
626        case 'I':
627        case 'l':
628        case 'r':  
629          twelve_hour = true;
630          break;
631        case 'R':  
632        case 'T':  
633        case 'c':  
634        case 'X':  
635          twelve_hour = false;
636          break;
637        case 'z':
638          data = ParseOffset(data, "", &offset);
639          if (data != nullptr) saw_offset = true;
640          continue;
641        case 'Z':  
642          data = ParseZone(data, &zone);
643          continue;
644        case 's':
645          data =
646              ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
647                       std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
648          if (data != nullptr) saw_percent_s = true;
649          continue;
650        case ':':
651          if (fmt[0] == 'z' ||
652              (fmt[0] == ':' &&
653               (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
654            data = ParseOffset(data, ":", &offset);
655            if (data != nullptr) saw_offset = true;
656            fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
657            continue;
658          }
659          break;
660        case '%':
661          data = (*data == '%' ? data + 1 : nullptr);
662          continue;
663        case 'E':
664          if (fmt[0] == 'T') {
665            if (*data == 'T' || *data == 't') {
666              ++data;
667              ++fmt;
668            } else {
669              data = nullptr;
670            }
671            continue;
672          }
673          if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
674            data = ParseOffset(data, ":", &offset);
675            if (data != nullptr) saw_offset = true;
676            fmt += (fmt[0] == 'z') ? 1 : 2;
677            continue;
678          }
679          if (fmt[0] == '*' && fmt[1] == 'S') {
680            data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
681            if (data != nullptr && *data == '.') {
682              data = ParseSubSeconds(data + 1, &subseconds);
683            }
684            fmt += 2;
685            continue;
686          }
687          if (fmt[0] == '*' && fmt[1] == 'f') {
688            if (data != nullptr && std::isdigit(*data)) {
689              data = ParseSubSeconds(data, &subseconds);
690            }
691            fmt += 2;
692            continue;
693          }
694          if (fmt[0] == '4' && fmt[1] == 'Y') {
695            const char* bp = data;
696            data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
697            if (data != nullptr) {
698              if (data - bp == 4) {
699                saw_year = true;
700              } else {
701                data = nullptr;  
702              }
703            }
704            fmt += 2;
705            continue;
706          }
707          if (std::isdigit(*fmt)) {
708            int n = 0;  
709            if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
710              if (*np == 'S') {
711                data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
712                if (data != nullptr && *data == '.') {
713                  data = ParseSubSeconds(data + 1, &subseconds);
714                }
715                fmt = ++np;
716                continue;
717              }
718              if (*np == 'f') {
719                if (data != nullptr && std::isdigit(*data)) {
720                  data = ParseSubSeconds(data, &subseconds);
721                }
722                fmt = ++np;
723                continue;
724              }
725            }
726          }
727          if (*fmt == 'c') twelve_hour = false;  
728          if (*fmt == 'X') twelve_hour = false;  
729          if (*fmt != '\0') ++fmt;
730          break;
731        case 'O':
732          if (*fmt == 'H') twelve_hour = false;
733          if (*fmt == 'I') twelve_hour = true;
734          if (*fmt != '\0') ++fmt;
735          break;
736      }
737      const char* orig_data = data;
738      std::string spec(percent, static_cast<std::size_t>(fmt - percent));
739      data = ParseTM(data, spec.c_str(), &tm);
740      if (spec == "%p" && data != nullptr) {
741        std::string test_input = "1";
742        test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
743        const char* test_data = test_input.c_str();
744        std::tm tmp{};
745        ParseTM(test_data, "%I%p", &tmp);
746        afternoon = (tmp.tm_hour == 13);
747      }
748    }
749    if (twelve_hour && afternoon && tm.tm_hour < 12) {
750      tm.tm_hour += 12;
751    }
752    if (data == nullptr) {
753      if (err != nullptr) *err = "Failed to parse input";
754      return false;
755    }
756    while (std::isspace(*data)) ++data;
757    if (*data != '\0') {
758      if (err != nullptr) *err = "Illegal trailing data in input string";
759      return false;
760    }
761    if (saw_percent_s) {
762      *sec = FromUnixSeconds(percent_s);
763      *fs = detail::femtoseconds::zero();
764      return true;
765    }
766    time_zone ptz = saw_offset ? utc_time_zone() : tz;
767    if (tm.tm_sec == 60) {
768      tm.tm_sec -= 1;
769      offset -= 1;
770      subseconds = detail::femtoseconds::zero();
771    }
772    if (!saw_year) {
773      year = year_t{tm.tm_year};
774      if (year > kyearmax - 1900) {
775        if (err != nullptr) *err = "Out-of-range year";
776        return false;
777      }
778      year += 1900;
779    }
780    if (week_num != -1) {
781      if (!FromWeek(week_num, week_start, &year, &tm)) {
782        if (err != nullptr) *err = "Out-of-range field";
783        return false;
784      }
785    }
786    const int month = tm.tm_mon + 1;
787    civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
788    if (cs.month() != month || cs.day() != tm.tm_mday) {
789      if (err != nullptr) *err = "Out-of-range field";
790      return false;
791    }
792    if ((offset < 0 && cs > civil_second::max() + offset) ||
793        (offset > 0 && cs < civil_second::min() + offset)) {
794      if (err != nullptr) *err = "Out-of-range field";
795      return false;
796    }
797    cs -= offset;
798    const auto tp = ptz.lookup(cs).pre;
799    if (tp == time_point<seconds>::max()) {
800      const auto al = ptz.lookup(time_point<seconds>::max());
801      if (cs > al.cs) {
802        if (err != nullptr) *err = "Out-of-range field";
803        return false;
804      }
805    }
806    if (tp == time_point<seconds>::min()) {
807      const auto al = ptz.lookup(time_point<seconds>::min());
808      if (cs < al.cs) {
809        if (err != nullptr) *err = "Out-of-range field";
810        return false;
811      }
812    }
813    *sec = tp;
814    *fs = subseconds;
815    return true;
816  }
817  }  
818  }  
819  }  
820  ABSL_NAMESPACE_END
821  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</div>
                </div>
                <div class="column column_space"><pre><code>35    *num_leading_outliers = *num_trailing_outliers = 0;
36    *leading_pos = *trailing_pos = SP_NORMAL;
37    int chopped_start = LeadingUnicharsToChopped(word, rebuilt_blob_index);
38    int num_chopped_pieces = word->best_state[rebuilt_blob_index];
39    ScriptPos last_pos = SP_NORMAL;
40    int trailing_outliers = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>551    tm.tm_sec = 0;
552    tm.tm_wday = 4;  
553    tm.tm_yday = 0;
554    tm.tm_isdst = 0;
555    auto subseconds = detail::femtoseconds::zero();
556    bool saw_offset = false;
557    int offset = 0;  
558    std::string zone = "UTC";
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    