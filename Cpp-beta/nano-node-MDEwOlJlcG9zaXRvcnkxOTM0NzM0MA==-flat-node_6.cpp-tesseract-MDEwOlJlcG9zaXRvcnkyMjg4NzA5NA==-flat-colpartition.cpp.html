
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.89125655335701%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/node/election.hpp>
4  #include <nano/node/scheduler/buckets.hpp>
5  #include <nano/node/scheduler/component.hpp>
6  #include <nano/node/transport/inproc.hpp>
7  #include <nano/node/unchecked_map.hpp>
8  #include <nano/test_common/network.hpp>
9  #include <nano/test_common/system.hpp>
10  #include <nano/test_common/testutil.hpp>
11  #include <gtest/gtest.h>
12  #include <boost/format.hpp>
13  #include <boost/unordered_set.hpp>
14  #include <numeric>
15  #include <random>
16  using namespace std::chrono_literals;
17  size_t manually_count_pruned_blocks (nano::store & store)
18  {
19  	size_t count = 0;
20  	auto transaction = store.tx_begin_read ();
21  	auto i = store.pruned.begin (transaction);
22  	for (; i != store.pruned.end (); ++i)
23  	{
24  		++count;
25  	}
26  	return count;
27  }
28  TEST (system, generate_mass_activity)
29  {
30  	nano::test::system system;
31  	nano::node_config node_config = system.default_config ();
32  	node_config.enable_voting = false; 
33  	auto node = system.add_node (node_config);
34  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
35  	uint32_t count (20);
36  	system.generate_mass_activity (count, *system.nodes[0]);
37  	auto transaction (system.nodes[0]->store.tx_begin_read ());
38  	for (auto i (system.nodes[0]->store.account.begin (transaction)), n (system.nodes[0]->store.account.end ()); i != n; ++i)
39  	{
40  	}
41  }
42  TEST (system, generate_mass_activity_long)
43  {
44  	nano::test::system system;
45  	nano::node_config node_config = system.default_config ();
46  	node_config.enable_voting = false; 
47  	auto node = system.add_node (node_config);
48  	nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
49  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
50  	uint32_t count (1000000);
51  	auto count_env_var = std::getenv ("SLOW_TEST_SYSTEM_GENERATE_MASS_ACTIVITY_LONG_COUNT");
52  	if (count_env_var)
53  	{
54  		count = boost::lexical_cast<uint32_t> (count_env_var);
55  		std::cout << "count override due to env variable set, count=" << count << std::endl;
56  	}
57  	system.generate_mass_activity (count, *system.nodes[0]);
58  	auto transaction (system.nodes[0]->store.tx_begin_read ());
59  	for (auto i (system.nodes[0]->store.account.begin (transaction)), n (system.nodes[0]->store.account.end ()); i != n; ++i)
60  	{
61  	}
62  	system.stop ();
63  	runner.join ();
64  }
65  TEST (system, receive_while_synchronizing)
66  {
67  	std::vector<boost::thread> threads;
68  	{
69  		nano::test::system system;
70  		nano::node_config node_config = system.default_config ();
71  		node_config.enable_voting = false; 
72  		auto node = system.add_node (node_config);
73  		nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
74  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
75  		uint32_t count (1000);
76  		system.generate_mass_activity (count, *system.nodes[0]);
77  		nano::keypair key;
78  		auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
79  		ASSERT_FALSE (node1->init_error ());
80  		auto wallet (node1->wallets.create (1));
81  		wallet->insert_adhoc (nano::dev::genesis_key.prv); 
82  		ASSERT_EQ (key.pub, wallet->insert_adhoc (key.prv));
83  		node1->start ();
84  		system.nodes.push_back (node1);
85  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node->network.endpoint ()));
86  		node1->workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::milliseconds (200), ([&system, &key] () {
87  			auto hash (system.wallet (0)->send_sync (nano::dev::genesis_key.pub, key.pub, system.nodes[0]->config.receive_minimum.number ()));
88  			auto transaction (system.nodes[0]->store.tx_begin_read ());
89  			auto block (system.nodes[0]->store.block.get (transaction, hash));
90  			std::string block_text;
91  			block->serialize_json (block_text);
92  		}));
93  		ASSERT_TIMELY (10s, !node1->balance (key.pub).is_zero ());
94  		node1->stop ();
95  		system.stop ();
96  		runner.join ();
97  	}
98  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
99  	{
100  		i->join ();
101  	}
102  }
103  TEST (ledger, deep_account_compute)
104  {
105  	nano::logger_mt logger;
106  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
107  	ASSERT_FALSE (store->init_error ());
108  	nano::stats stats;
109  	nano::ledger ledger (*store, stats, nano::dev::constants);
110  	auto transaction (store->tx_begin_write ());
111  	store->initialize (transaction, ledger.cache, ledger.constants);
112  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
113  	nano::keypair key;
114  	auto balance (nano::dev::constants.genesis_amount - 1);
115  	nano::block_builder builder;
116  	auto send = builder
117  				.send ()
118  				.previous (nano::dev::genesis->hash ())
119  				.destination (key.pub)
120  				.balance (balance)
121  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
122  				.work (*pool.generate (nano::dev::genesis->hash ()))
123  				.build ();
124  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
125  	auto open = builder
126  				.open ()
127  				.source (send->hash ())
128  				.representative (nano::dev::genesis_key.pub)
129  				.account (key.pub)
130  				.sign (key.prv, key.pub)
131  				.work (*pool.generate (key.pub))
132  				.build ();
133  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
134  	auto sprevious (send->hash ());
135  	auto rprevious (open->hash ());
136  	for (auto i (0), n (100000); i != n; ++i)
137  	{
138  		balance -= 1;
139  		auto send = builder
140  					.send ()
141  					.previous (sprevious)
142  					.destination (key.pub)
143  					.balance (balance)
144  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
145  					.work (*pool.generate (sprevious))
146  					.build ();
147  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
148  		sprevious = send->hash ();
149  		auto receive = builder
150  					   .receive ()
151  					   .previous (rprevious)
152  					   .source (send->hash ())
153  					   .sign (key.prv, key.pub)
154  					   .work (*pool.generate (rprevious))
155  					   .build ();
156  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
157  		rprevious = receive->hash ();
158  		if (i % 100 == 0)
159  		{
160  			std::cerr << i << ' ';
161  		}
162  		ledger.account (transaction, sprevious);
163  		ledger.balance (transaction, rprevious);
164  	}
165  }
166  TEST (wallet, multithreaded_send_async)
167  {
168  	std::vector<boost::thread> threads;
169  	{
170  		nano::test::system system (1);
171  		nano::keypair key;
172  		auto wallet_l (system.wallet (0));
173  		wallet_l->insert_adhoc (nano::dev::genesis_key.prv);
174  		wallet_l->insert_adhoc (key.prv);
175  		int num_of_threads = 20;
176  		int num_of_sends = 1000;
177  		for (auto i (0); i < num_of_threads; ++i)
178  		{
179  			threads.push_back (boost::thread ([wallet_l, &key, num_of_threads, num_of_sends] () {
180  				for (auto i (0); i < num_of_sends; ++i)
181  				{
182  					wallet_l->send_async (nano::dev::genesis_key.pub, key.pub, 1000, [] (std::shared_ptr<nano::block> const & block_a) {
183  						ASSERT_FALSE (block_a == nullptr);
184  						ASSERT_FALSE (block_a->hash ().is_zero ());
185  					});
186  				}
187  			}));
188  		}
189  		ASSERT_TIMELY (1000s, system.nodes[0]->balance (nano::dev::genesis_key.pub) == (nano::dev::constants.genesis_amount - num_of_threads * num_of_sends * 1000));
190  	}
191  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
192  	{
193  		i->join ();
194  	}
195  }
196  TEST (store, load)
197  {
198  	nano::test::system system (1);
199  	std::vector<boost::thread> threads;
200  	for (auto i (0); i < 100; ++i)
201  	{
202  		threads.push_back (boost::thread ([&system] () {
203  			for (auto i (0); i != 1000; ++i)
204  			{
205  				auto transaction (system.nodes[0]->store.tx_begin_write ());
206  				for (auto j (0); j != 10; ++j)
207  				{
208  					nano::account account;
209  					nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
210  					system.nodes[0]->store.confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
211  					system.nodes[0]->store.account.put (transaction, account, nano::account_info ());
212  				}
213  			}
214  		}));
215  	}
216  	for (auto & i : threads)
217  	{
218  		i.join ();
219  	}
220  }
221  namespace nano
222  {
223  TEST (node, fork_storm)
224  {
225  	static const auto node_count (23);
226  	nano::node_flags flags;
227  	flags.disable_max_peers_per_ip = true;
228  	nano::test::system system (node_count, nano::transport::transport_type::tcp, flags);
229  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
230  	auto previous (system.nodes[0]->latest (nano::dev::genesis_key.pub));
231  	auto balance (system.nodes[0]->balance (nano::dev::genesis_key.pub));
232  	ASSERT_FALSE (previous.is_zero ());
233  	nano::block_builder builder;
234  	for (auto node_j : system.nodes)
235  	{
236  		balance -= 1;
237  		nano::keypair key;
238  		auto send = builder
239  					.send ()
240  					.previous (previous)
241  					.destination (key.pub)
242  					.balance (balance)
243  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
244  					.work (0)
245  					.build ();
246  		node_j->work_generate_blocking (*send);
247  		previous = send->hash ();
248  		for (auto node_i : system.nodes)
249  		{
250  			auto send_result (node_i->process (*send));
251  			ASSERT_EQ (nano::process_result::progress, send_result.code);
252  			nano::keypair rep;
253  			auto open = builder
254  						.open ()
255  						.source (previous)
256  						.representative (rep.pub)
257  						.account (key.pub)
258  						.sign (key.prv, key.pub)
259  						.work (0)
260  						.build_shared ();
261  			node_i->work_generate_blocking (*open);
262  			auto open_result (node_i->process (*open));
263  			ASSERT_EQ (nano::process_result::progress, open_result.code);
264  			auto transaction (node_i->store.tx_begin_read ());
265  			node_i->network.flood_block (open);
266  		}
267  	}
268  	auto again (true);
269  	int iteration (0);
270  	auto old_empty (0);
271  	auto old_single (0);
272  	auto stall_count (0);
273  	while (again)
274  	{
275  		auto empty = 0;
276  		auto single = 0;
277  		std::for_each (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) {
278  			if (node_a->active.empty ())
279  			{
280  				++empty;
281  			}
282  			else
283  			{
284  				nano::unique_lock<nano::mutex> lock{ node_a->active.mutex };
285  				auto election = node_a->active.roots.begin ()->election;
286  				lock.unlock ();
287  				if (election->votes ().size () == 1)
288  				{
289  					++single;
290  				}
291  			}
292  		});
293  		ASSERT_NO_ERROR (system.poll ());
294  		if (old_empty == empty && old_single == single)
295  		{
296  			static const auto stall_tolerance (100000);
297  			++stall_count;
298  			ASSERT_LE (stall_count, stall_tolerance) << "Stall deteceted. These values were both expected to eventually reach 0 but have remained unchanged for " << stall_tolerance << " iterations. Empty: " << empty << " single: " << single << std::endl;
299  		}
300  		else
301  		{
302  			stall_count = 0;
303  			old_empty = empty;
304  			old_single = single;
305  		}
306  		again = (empty != 0) || (single != 0);
307  		++iteration;
308  	}
309  	ASSERT_TRUE (true);
310  }
311  } 
312  namespace
313  {
314  size_t heard_count (std::vector<uint8_t> const & nodes)
315  {
316  	auto result (0);
317  	for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
318  	{
319  		switch (*i)
320  		{
321  			case 0:
322  				break;
323  			case 1:
324  				++result;
325  				break;
326  			case 2:
327  				++result;
328  				break;
329  		}
330  	}
331  	return result;
332  }
333  }
334  TEST (broadcast, world_broadcast_simulate)
335  {
336  	auto node_count (10000);
337  	std::vector<uint8_t> nodes;
338  	nodes.resize (node_count, 0);
339  	nodes[0] = 1;
340  	auto any_changed (true);
341  	auto message_count (0);
342  	while (any_changed)
343  	{
344  		any_changed = false;
345  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
346  		{
347  			switch (*i)
348  			{
349  				case 0:
350  					break;
351  				case 1:
352  					for (auto j (nodes.begin ()), m (nodes.end ()); j != m; ++j)
353  					{
354  						++message_count;
355  						switch (*j)
356  						{
357  							case 0:
358  								*j = 1;
359  								any_changed = true;
360  								break;
361  							case 1:
362  								break;
363  							case 2:
364  								break;
365  						}
366  					}
367  					*i = 2;
368  					any_changed = true;
369  					break;
370  				case 2:
371  					break;
372  				default:
373  					ASSERT_FALSE (true);
374  					break;
375  			}
376  		}
377  	}
378  	auto count (heard_count (nodes));
379  	(void)count;
380  }
381  TEST (broadcast, sqrt_broadcast_simulate)
382  {
383  	auto node_count (10000);
384  	auto broadcast_count (std::ceil (std::sqrt (node_count)));
385  	std::vector<uint8_t> nodes;
386  	nodes.resize (node_count, 0);
387  	nodes[0] = 1;
388  	auto any_changed (true);
389  	uint64_t message_count (0);
390  	while (any_changed)
391  	{
392  		any_changed = false;
393  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
394  		{
395  			switch (*i)
396  			{
397  				case 0:
398  					break;
399  				case 1:
400  					for (auto j (0); j != broadcast_count; ++j)
401  					{
402  						++message_count;
403  						auto entry (nano::random_pool::generate_word32 (0, node_count - 1));
404  						switch (nodes[entry])
405  						{
406  							case 0:
407  								nodes[entry] = 1;
408  								any_changed = true;
409  								break;
410  							case 1:
411  								break;
412  							case 2:
413  								break;
414  						}
415  					}
416  					*i = 2;
417  					any_changed = true;
418  					break;
419  				case 2:
420  					break;
421  				default:
422  					ASSERT_FALSE (true);
423  					break;
424  			}
425  		}
426  	}
427  	auto count (heard_count (nodes));
428  	(void)count;
429  }
430  TEST (peer_container, random_set)
431  {
432  	nano::test::system system (1);
433  	auto old (std::chrono::steady_clock::now ());
434  	auto current (std::chrono::steady_clock::now ());
435  	for (auto i (0); i < 10000; ++i)
436  	{
437  		auto list (system.nodes[0]->network.random_set (15));
438  	}
439  	auto end (std::chrono::steady_clock::now ());
440  	(void)end;
441  	auto old_ms (std::chrono::duration_cast<std::chrono::milliseconds> (current - old));
442  	(void)old_ms;
443  	auto new_ms (std::chrono::duration_cast<std::chrono::milliseconds> (end - current));
444  	(void)new_ms;
445  }
446  TEST (store, unchecked_load)
447  {
448  	nano::test::system system{ 1 };
449  	auto & node = *system.nodes[0];
450  	nano::block_builder builder;
451  	std::shared_ptr<nano::block> block = builder
452  										 .send ()
453  										 .previous (0)
454  										 .destination (0)
455  										 .balance (0)
456  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
457  										 .work (0)
458  										 .build_shared ();
459  	constexpr auto num_unchecked = 1'000'000;
460  	for (auto i (0); i < num_unchecked; ++i)
461  	{
462  		node.unchecked.put (i, block);
463  	}
464  	ASSERT_TIMELY (8000s, num_unchecked == node.unchecked.count ());
465  }
466  TEST (store, vote_load)
467  {
468  	nano::test::system system{ 1 };
469  	auto & node = *system.nodes[0];
470  	for (auto i = 0u; i < 1000000u; ++i)
471  	{
472  		auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, i, 0, std::vector<nano::block_hash>{ i });
473  		node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
474  	}
<span onclick='openModal()' class='match'>475  }
476  TEST (store, pruned_load)
477  {
478  	nano::logger_mt logger;
479  	auto path (nano::unique_path ());
480  	constexpr auto num_pruned = 2000000;
481  	auto const expected_result = num_pruned / 2;
</span>482  	constexpr auto batch_size = 20;
483  	boost::unordered_set<nano::block_hash> hashes;
484  	{
485  		auto store = nano::make_store (logger, path, nano::dev::constants);
486  		ASSERT_FALSE (store->init_error ());
487  		for (auto i (0); i < num_pruned / batch_size; ++i)
488  		{
489  			{
490  				auto transaction (store->tx_begin_write ());
491  				for (auto k (0); k < batch_size; ++k)
492  				{
493  					nano::block_hash random_hash;
494  					nano::random_pool::generate_block (random_hash.bytes.data (), random_hash.bytes.size ());
495  					store->pruned.put (transaction, random_hash);
496  					hashes.insert (random_hash);
497  				}
498  			}
499  			{
500  				auto transaction (store->tx_begin_write ());
501  				for (auto k (0); !hashes.empty () && k < batch_size / 2; ++k)
502  				{
503  					auto hash (hashes.begin ());
504  					store->pruned.del (transaction, *hash);
505  					hashes.erase (hash);
506  				}
507  			}
508  		}
509  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
510  	}
511  	{
512  		auto store = nano::make_store (logger, path, nano::dev::constants);
513  		ASSERT_FALSE (store->init_error ());
514  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
515  	}
516  }
517  TEST (wallets, rep_scan)
518  {
519  	nano::test::system system (1);
520  	auto & node (*system.nodes[0]);
521  	auto wallet (system.wallet (0));
522  	{
523  		auto transaction (node.wallets.tx_begin_write ());
524  		for (auto i (0); i < 10000; ++i)
525  		{
526  			wallet->deterministic_insert (transaction);
527  		}
528  	}
529  	auto begin (std::chrono::steady_clock::now ());
530  	node.wallets.foreach_representative ([] (nano::public_key const & pub_a, nano::raw_key const & prv_a) {
531  	});
532  	ASSERT_LT (std::chrono::steady_clock::now () - begin, std::chrono::milliseconds (5));
533  }
534  TEST (node, mass_vote_by_hash)
535  {
536  	nano::test::system system (1);
537  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
538  	nano::block_hash previous (nano::dev::genesis->hash ());
539  	nano::keypair key;
540  	std::vector<std::shared_ptr<nano::state_block>> blocks;
541  	nano::block_builder builder;
542  	for (auto i (0); i < 10000; ++i)
543  	{
544  		auto block = builder
545  					 .state ()
546  					 .account (nano::dev::genesis_key.pub)
547  					 .previous (previous)
548  					 .representative (nano::dev::genesis_key.pub)
549  					 .balance (nano::dev::constants.genesis_amount - (i + 1) * nano::Gxrb_ratio)
550  					 .link (key.pub)
551  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  					 .work (*system.work.generate (previous))
553  					 .build_shared ();
554  		previous = block->hash ();
555  		blocks.push_back (block);
556  	}
557  	for (auto i (blocks.begin ()), n (blocks.end ()); i != n; ++i)
558  	{
559  		system.nodes[0]->block_processor.add (*i);
560  	}
561  }
562  namespace nano
563  {
564  TEST (confirmation_height, many_accounts_single_confirmation)
565  {
566  	nano::test::system system;
567  	nano::node_config node_config = system.default_config ();
568  	node_config.online_weight_minimum = 100;
569  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
570  	auto node = system.add_node (node_config);
571  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
572  	node->confirmation_height_processor.batch_write_size = 500;
573  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
574  	nano::keypair last_keypair = nano::dev::genesis_key;
575  	nano::block_builder builder;
576  	auto last_open_hash = node->latest (nano::dev::genesis_key.pub);
577  	{
578  		auto transaction = node->store.tx_begin_write ();
579  		for (auto i = num_accounts - 1; i > 0; --i)
580  		{
581  			nano::keypair key;
582  			system.wallet (0)->insert_adhoc (key.prv);
583  			auto send = builder
584  						.send ()
585  						.previous (last_open_hash)
586  						.destination (key.pub)
587  						.balance (node->online_reps.delta ())
588  						.sign (last_keypair.prv, last_keypair.pub)
589  						.work (*system.work.generate (last_open_hash))
590  						.build ();
591  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
592  			auto open = builder
593  						.open ()
594  						.source (send->hash ())
595  						.representative (last_keypair.pub)
596  						.account (key.pub)
597  						.sign (key.prv, key.pub)
598  						.work (*system.work.generate (key.pub))
599  						.build ();
600  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
601  			last_open_hash = open->hash ();
602  			last_keypair = key;
603  		}
604  	}
605  	{
606  		auto block = node->block (last_open_hash);
607  		ASSERT_NE (nullptr, block);
608  		node->scheduler.buckets.manual (block);
609  		std::shared_ptr<nano::election> election;
610  		ASSERT_TIMELY (10s, (election = node->active.election (block->qualified_root ())) != nullptr);
611  		election->force_confirm ();
612  	}
613  	ASSERT_TIMELY (120s, node->ledger.block_confirmed (node->store.tx_begin_read (), last_open_hash));
614  	auto transaction = node->store.tx_begin_read ();
615  	for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
616  	{
617  		auto & account = i->first;
618  		auto & account_info = i->second;
619  		auto count = (account != last_keypair.pub) ? 2 : 1;
620  		nano::confirmation_height_info confirmation_height_info;
621  		ASSERT_FALSE (node->store.confirmation_height.get (transaction, account, confirmation_height_info));
622  		ASSERT_EQ (count, confirmation_height_info.height);
623  		ASSERT_EQ (count, account_info.block_count);
624  	}
625  	size_t cemented_count = 0;
626  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
627  	{
628  		cemented_count += i->second.height;
629  	}
630  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
631  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_accounts * 2 - 2);
632  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_accounts * 2 - 2);
633  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
634  	ASSERT_TIMELY (40s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
635  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
636  }
637  TEST (confirmation_height, many_accounts_many_confirmations)
638  {
639  	nano::test::system system;
640  	nano::node_config node_config = system.default_config ();
641  	node_config.online_weight_minimum = 100;
642  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
643  	auto node = system.add_node (node_config);
644  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
645  	node->confirmation_height_processor.batch_write_size = 500;
646  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
647  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
648  	nano::block_builder builder;
649  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
650  	{
651  		auto transaction = node->store.tx_begin_write ();
652  		for (auto i = num_accounts - 1; i > 0; --i)
653  		{
654  			nano::keypair key;
655  			system.wallet (0)->insert_adhoc (key.prv);
656  			auto send = builder
657  						.send ()
658  						.previous (latest_genesis)
659  						.destination (key.pub)
660  						.balance (node->online_reps.delta ())
661  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
662  						.work (*system.work.generate (latest_genesis))
663  						.build ();
664  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
665  			auto open = builder
666  						.open ()
667  						.source (send->hash ())
668  						.representative (nano::dev::genesis_key.pub)
669  						.account (key.pub)
670  						.sign (key.prv, key.pub)
671  						.work (*system.work.generate (key.pub))
672  						.build_shared ();
673  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
674  			open_blocks.push_back (std::move (open));
675  			latest_genesis = send->hash ();
676  		}
677  	}
678  	for (auto & open_block : open_blocks)
679  	{
680  		node->scheduler.buckets.manual (open_block);
681  		std::shared_ptr<nano::election> election;
682  		ASSERT_TIMELY (10s, (election = node->active.election (open_block->qualified_root ())) != nullptr);
683  		election->force_confirm ();
684  	}
685  	auto const num_blocks_to_confirm = (num_accounts - 1) * 2;
686  	ASSERT_TIMELY (1500s, node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) == num_blocks_to_confirm);
687  	auto num_confirmed_bounded = node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in);
688  	ASSERT_GE (num_confirmed_bounded, nano::confirmation_height::unbounded_cutoff);
689  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks_to_confirm - num_confirmed_bounded);
690  	ASSERT_TIMELY (60s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
691  	auto transaction = node->store.tx_begin_read ();
692  	size_t cemented_count = 0;
693  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
694  	{
695  		cemented_count += i->second.height;
696  	}
697  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
698  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
699  	ASSERT_TIMELY (20s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
700  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
701  }
702  TEST (confirmation_height, long_chains)
703  {
704  	nano::test::system system;
705  	nano::node_config node_config = system.default_config ();
706  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
707  	auto node = system.add_node (node_config);
708  	nano::keypair key1;
709  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
710  	nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
711  	system.wallet (0)->insert_adhoc (key1.prv);
712  	node->confirmation_height_processor.batch_write_size = 500;
713  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff * 2 + 50;
714  	nano::block_builder builder;
715  	auto send = builder
716  				.send ()
717  				.previous (latest)
718  				.destination (key1.pub)
719  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + num_blocks + 1)
720  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
721  				.work (*system.work.generate (latest))
722  				.build ();
723  	auto open = builder
724  				.open ()
725  				.source (send->hash ())
726  				.representative (nano::dev::genesis->account ())
727  				.account (key1.pub)
728  				.sign (key1.prv, key1.pub)
729  				.work (*system.work.generate (key1.pub))
730  				.build ();
731  	{
732  		auto transaction = node->store.tx_begin_write ();
733  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
734  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
735  	}
736  	auto previous_genesis_chain_hash = send->hash ();
737  	auto previous_destination_chain_hash = open->hash ();
738  	{
739  		auto transaction = node->store.tx_begin_write ();
740  		for (auto i = num_blocks - 1; i > 0; --i)
741  		{
742  			auto send = builder
743  						.send ()
744  						.previous (previous_genesis_chain_hash)
745  						.destination (key1.pub)
746  						.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
747  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
748  						.work (*system.work.generate (previous_genesis_chain_hash))
749  						.build ();
750  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
751  			auto receive = builder
752  						   .receive ()
753  						   .previous (previous_destination_chain_hash)
754  						   .source (send->hash ())
755  						   .sign (key1.prv, key1.pub)
756  						   .work (*system.work.generate (previous_destination_chain_hash))
757  						   .build ();
758  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *receive).code);
759  			previous_genesis_chain_hash = send->hash ();
760  			previous_destination_chain_hash = receive->hash ();
761  		}
762  	}
763  	auto send1 = builder
764  				 .send ()
765  				 .previous (previous_destination_chain_hash)
766  				 .destination (nano::dev::genesis_key.pub)
767  				 .balance (nano::Gxrb_ratio - 2)
768  				 .sign (key1.prv, key1.pub)
769  				 .work (*system.work.generate (previous_destination_chain_hash))
770  				 .build ();
771  	auto receive1 = builder
772  					.state ()
773  					.account (nano::dev::genesis_key.pub)
774  					.previous (previous_genesis_chain_hash)
775  					.representative (nano::dev::genesis->account ())
776  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + 1)
777  					.link (send1->hash ())
778  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
779  					.work (*system.work.generate (previous_genesis_chain_hash))
780  					.build_shared ();
781  	nano::keypair key2;
782  	auto send2 = builder
783  				 .state ()
784  				 .account (nano::dev::genesis->account ())
785  				 .previous (receive1->hash ())
786  				 .representative (nano::dev::genesis->account ())
787  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
788  				 .link (key2.pub)
789  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
790  				 .work (*system.work.generate (receive1->hash ()))
791  				 .build ();
792  	{
793  		auto transaction = node->store.tx_begin_write ();
794  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
795  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *receive1).code);
796  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send2).code);
797  	}
798  	{
799  		node->scheduler.buckets.manual (receive1);
800  		std::shared_ptr<nano::election> election;
801  		ASSERT_TIMELY (10s, (election = node->active.election (receive1->qualified_root ())) != nullptr);
802  		election->force_confirm ();
803  	}
804  	ASSERT_TIMELY (30s, node->ledger.block_confirmed (node->store.tx_begin_read (), receive1->hash ()));
805  	auto transaction (node->store.tx_begin_read ());
806  	auto info = node->ledger.account_info (transaction, nano::dev::genesis_key.pub);
807  	ASSERT_TRUE (info);
808  	nano::confirmation_height_info confirmation_height_info;
809  	ASSERT_FALSE (node->store.confirmation_height.get (transaction, nano::dev::genesis_key.pub, confirmation_height_info));
810  	ASSERT_EQ (num_blocks + 2, confirmation_height_info.height);
811  	ASSERT_EQ (num_blocks + 3, info->block_count); 
812  	info = node->ledger.account_info (transaction, key1.pub);
813  	ASSERT_TRUE (info);
814  	ASSERT_FALSE (node->store.confirmation_height.get (transaction, key1.pub, confirmation_height_info));
815  	ASSERT_EQ (num_blocks + 1, confirmation_height_info.height);
816  	ASSERT_EQ (num_blocks + 1, info->block_count);
817  	size_t cemented_count = 0;
818  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
819  	{
820  		cemented_count += i->second.height;
821  	}
822  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
823  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks * 2 + 2);
824  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_blocks * 2 + 2);
825  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
826  	ASSERT_TIMELY (40s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
827  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
828  }
829  TEST (confirmation_height, dynamic_algorithm)
830  {
831  	nano::test::system system;
832  	nano::node_config node_config = system.default_config ();
833  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
834  	auto node = system.add_node (node_config);
835  	nano::keypair key;
836  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
837  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff;
838  	auto latest_genesis = nano::dev::genesis;
839  	std::vector<std::shared_ptr<nano::state_block>> state_blocks;
840  	nano::block_builder builder;
841  	for (auto i = 0; i < num_blocks; ++i)
842  	{
843  		auto send = builder
844  					.state ()
845  					.account (nano::dev::genesis_key.pub)
846  					.previous (latest_genesis->hash ())
847  					.representative (nano::dev::genesis_key.pub)
848  					.balance (nano::dev::constants.genesis_amount - i - 1)
849  					.link (key.pub)
850  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
851  					.work (*system.work.generate (latest_genesis->hash ()))
852  					.build_shared ();
853  		latest_genesis = send;
854  		state_blocks.push_back (send);
855  	}
856  	{
857  		auto transaction = node->store.tx_begin_write ();
858  		for (auto const & block : state_blocks)
859  		{
860  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *block).code);
861  		}
862  	}
863  	node->confirmation_height_processor.add (state_blocks.front ());
864  	ASSERT_TIMELY (20s, node->ledger.cache.cemented_count == 2);
865  	node->confirmation_height_processor.add (latest_genesis);
866  	ASSERT_TIMELY (20s, node->ledger.cache.cemented_count == num_blocks + 1);
867  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
868  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 1);
869  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks - 1);
870  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
871  }
872  TEST (confirmation_height, dynamic_algorithm_no_transition_while_pending)
873  {
874  	for (auto _ = 0; _ < 3; ++_)
875  	{
876  		nano::test::system system;
877  		nano::node_config node_config = system.default_config ();
878  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
879  		nano::node_flags node_flags;
880  		node_flags.force_use_write_database_queue = true;
881  		auto node = system.add_node (node_config, node_flags);
882  		nano::keypair key;
883  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
884  		auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
885  		std::vector<std::shared_ptr<nano::state_block>> state_blocks;
886  		auto const num_blocks = nano::confirmation_height::unbounded_cutoff - 2;
887  		auto add_block_to_genesis_chain = [&] (nano::write_transaction & transaction) {
888  			static int num = 0;
889  			nano::block_builder builder;
890  			auto send = builder
891  						.state ()
892  						.account (nano::dev::genesis_key.pub)
893  						.previous (latest_genesis)
894  						.representative (nano::dev::genesis_key.pub)
895  						.balance (nano::dev::constants.genesis_amount - num - 1)
896  						.link (key.pub)
897  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
898  						.work (*system.work.generate (latest_genesis))
899  						.build_shared ();
900  			latest_genesis = send->hash ();
901  			state_blocks.push_back (send);
902  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
903  			++num;
904  		};
905  		for (auto i = 0; i < num_blocks; ++i)
906  		{
907  			auto transaction = node->store.tx_begin_write ();
908  			add_block_to_genesis_chain (transaction);
909  		}
910  		{
911  			auto write_guard = node->write_database_queue.wait (nano::writer::testing);
912  			node->confirmation_height_processor.add (state_blocks.back ());
913  			nano::timer<> timer;
914  			timer.start ();
915  			while (node->confirmation_height_processor.current ().is_zero ())
916  			{
917  				ASSERT_LT (timer.since_start (), 2s);
918  			}
919  			node->confirmation_height_processor.pause ();
920  			timer.restart ();
921  			ASSERT_TIMELY (10s, node->confirmation_height_processor.unbounded_processor.pending_writes_size != 0);
922  			{
923  				auto transaction = node->store.tx_begin_write ();
924  				add_block_to_genesis_chain (transaction);
925  				add_block_to_genesis_chain (transaction);
926  			}
927  			node->confirmation_height_processor.add (state_blocks.front ());
928  			node->confirmation_height_processor.unpause ();
929  		}
930  		ASSERT_TIMELY (10s, node->ledger.cache.cemented_count == num_blocks + 1);
931  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
932  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 0);
933  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks);
934  		ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
935  	}
936  }
937  TEST (confirmation_height, many_accounts_send_receive_self)
938  {
939  	nano::test::system system;
940  	nano::node_config node_config = system.default_config ();
941  	node_config.online_weight_minimum = 100;
942  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
943  	node_config.active_elections_size = 400000;
944  	nano::node_flags node_flags;
945  	node_flags.confirmation_height_processor_mode = nano::confirmation_height_mode::unbounded;
946  	auto node = system.add_node (node_config);
947  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
948  #ifndef NDEBUG
949  	auto const num_accounts = 10000;
950  #else
951  	auto const num_accounts = 100000;
952  #endif
953  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
954  	std::vector<nano::keypair> keys;
955  	nano::block_builder builder;
956  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
957  	{
958  		auto transaction = node->store.tx_begin_write ();
959  		for (auto i = 0; i < num_accounts; ++i)
960  		{
961  			nano::keypair key;
962  			keys.emplace_back (key);
963  			auto send = builder
964  						.send ()
965  						.previous (latest_genesis)
966  						.destination (key.pub)
967  						.balance (nano::dev::constants.genesis_amount - 1 - i)
968  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
969  						.work (*system.work.generate (latest_genesis))
970  						.build ();
971  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
972  			auto open = builder
973  						.open ()
974  						.source (send->hash ())
975  						.representative (nano::dev::genesis_key.pub)
976  						.account (key.pub)
977  						.sign (key.prv, key.pub)
978  						.work (*system.work.generate (key.pub))
979  						.build_shared ();
980  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
981  			open_blocks.push_back (std::move (open));
982  			latest_genesis = send->hash ();
983  		}
984  	}
985  	for (auto & open_block : open_blocks)
986  	{
987  		node->block_confirm (open_block);
988  		std::shared_ptr<nano::election> election;
989  		ASSERT_TIMELY (10s, (election = node->active.election (open_block->qualified_root ())) != nullptr);
990  		election->force_confirm ();
991  	}
992  	system.deadline_set (100s);
993  	auto num_blocks_to_confirm = num_accounts * 2;
994  	while (node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
995  	{
996  		ASSERT_NO_ERROR (system.poll ());
997  	}
998  	std::vector<std::shared_ptr<nano::send_block>> send_blocks;
999  	std::vector<std::shared_ptr<nano::receive_block>> receive_blocks;
1000  	for (int i = 0; i < open_blocks.size (); ++i)
1001  	{
1002  		auto open_block = open_blocks[i];
1003  		auto & keypair = keys[i];
1004  		send_blocks.emplace_back (builder
1005  								  .send ()
1006  								  .previous (open_block->hash ())
1007  								  .destination (keypair.pub)
1008  								  .balance (1)
1009  								  .sign (keypair.prv, keypair.pub)
1010  								  .work (*system.work.generate (open_block->hash ()))
1011  								  .build_shared ());
1012  		receive_blocks.emplace_back (builder
1013  									 .receive ()
1014  									 .previous (send_blocks.back ()->hash ())
1015  									 .source (send_blocks.back ()->hash ())
1016  									 .sign (keypair.prv, keypair.pub)
1017  									 .work (*system.work.generate (send_blocks.back ()->hash ()))
1018  									 .build_shared ());
1019  	}
1020  	for (int i = 0; i < open_blocks.size (); ++i)
1021  	{
1022  		node->process_active (send_blocks[i]);
1023  		node->process_active (receive_blocks[i]);
1024  	}
1025  	system.deadline_set (300s);
1026  	num_blocks_to_confirm = num_accounts * 4;
1027  	while (node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1028  	{
1029  		ASSERT_NO_ERROR (system.poll ());
1030  	}
1031  	system.deadline_set (200s);
1032  	while ((node->ledger.cache.cemented_count - 1) != node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1033  	{
1034  		ASSERT_NO_ERROR (system.poll ());
1035  	}
1036  	auto transaction = node->store.tx_begin_read ();
1037  	size_t cemented_count = 0;
1038  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
1039  	{
1040  		cemented_count += i->second.height;
1041  	}
1042  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1043  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
1044  	system.deadline_set (60s);
1045  	while ((node->ledger.cache.cemented_count - 1) != node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1046  	{
1047  		ASSERT_NO_ERROR (system.poll ());
1048  	}
1049  	system.deadline_set (60s);
1050  	while (node->active.election_winner_details_size () > 0)
1051  	{
1052  		ASSERT_NO_ERROR (system.poll ());
1053  	}
1054  }
1055  TEST (confirmation_height, many_accounts_send_receive_self_no_elections)
1056  {
1057  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
1058  	{
1059  		return;
1060  	}
1061  	nano::logger_mt logger;
1062  	nano::logging logging;
1063  	auto path (nano::unique_path ());
1064  	auto store = nano::make_store (logger, path, nano::dev::constants);
1065  	ASSERT_TRUE (!store->init_error ());
1066  	nano::stats stats;
1067  	nano::ledger ledger (*store, stats, nano::dev::constants);
1068  	nano::write_database_queue write_database_queue (false);
1069  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1070  	std::atomic<bool> stopped{ false };
1071  	boost::latch initialized_latch{ 0 };
1072  	nano::block_hash block_hash_being_processed{ 0 };
1073  	nano::confirmation_height_processor confirmation_height_processor{ ledger, write_database_queue, 10ms, logging, logger, initialized_latch, confirmation_height_mode::automatic };
1074  	auto const num_accounts = 100000;
1075  	auto latest_genesis = nano::dev::genesis->hash ();
1076  	std::vector<nano::keypair> keys;
1077  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
1078  	nano::block_builder builder;
1079  	nano::test::system system;
1080  	{
1081  		auto transaction (store->tx_begin_write ());
1082  		store->initialize (transaction, ledger.cache, ledger.constants);
1083  		for (auto i = 0; i < num_accounts; ++i)
1084  		{
1085  			nano::keypair key;
1086  			keys.emplace_back (key);
1087  			auto send = builder
1088  						.send ()
1089  						.previous (latest_genesis)
1090  						.destination (key.pub)
1091  						.balance (nano::dev::constants.genesis_amount - 1 - i)
1092  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1093  						.work (*pool.generate (latest_genesis))
1094  						.build ();
1095  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1096  			auto open = builder
1097  						.open ()
1098  						.source (send->hash ())
1099  						.representative (nano::dev::genesis_key.pub)
1100  						.account (key.pub)
1101  						.sign (key.prv, key.pub)
1102  						.work (*pool.generate (key.pub))
1103  						.build_shared ();
1104  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1105  			open_blocks.push_back (std::move (open));
1106  			latest_genesis = send->hash ();
1107  		}
1108  	}
1109  	for (auto & open_block : open_blocks)
1110  	{
1111  		confirmation_height_processor.add (open_block);
1112  	}
1113  	system.deadline_set (1000s);
1114  	auto num_blocks_to_confirm = num_accounts * 2;
1115  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1116  	{
1117  		ASSERT_NO_ERROR (system.poll ());
1118  	}
1119  	std::vector<std::shared_ptr<nano::send_block>> send_blocks;
1120  	std::vector<std::shared_ptr<nano::receive_block>> receive_blocks;
1121  	{
1122  		auto transaction (store->tx_begin_write ());
1123  		for (int i = 0; i < open_blocks.size (); ++i)
1124  		{
1125  			auto open_block = open_blocks[i];
1126  			auto & keypair = keys[i];
1127  			send_blocks.emplace_back (builder
1128  									  .send ()
1129  									  .previous (open_block->hash ())
1130  									  .destination (keypair.pub)
1131  									  .balance (1)
1132  									  .sign (keypair.prv, keypair.pub)
1133  									  .work (*system.work.generate (open_block->hash ()))
1134  									  .build_shared ());
1135  			receive_blocks.emplace_back (builder
1136  										 .receive ()
1137  										 .previous (send_blocks.back ()->hash ())
1138  										 .source (send_blocks.back ()->hash ())
1139  										 .sign (keypair.prv, keypair.pub)
1140  										 .work (*system.work.generate (send_blocks.back ()->hash ()))
1141  										 .build_shared ());
1142  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_blocks.back ()).code);
1143  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive_blocks.back ()).code);
1144  		}
1145  	}
1146  	std::random_device rd;
1147  	std::mt19937 g (rd ());
1148  	std::shuffle (send_blocks.begin (), send_blocks.end (), g);
1149  	std::mt19937 g1 (rd ());
1150  	std::shuffle (receive_blocks.begin (), receive_blocks.end (), g1);
1151  	for (int i = 0; i < open_blocks.size (); ++i)
1152  	{
1153  		confirmation_height_processor.add (send_blocks[i]);
1154  		confirmation_height_processor.add (receive_blocks[i]);
1155  	}
1156  	system.deadline_set (1000s);
1157  	num_blocks_to_confirm = num_accounts * 4;
1158  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1159  	{
1160  		ASSERT_NO_ERROR (system.poll ());
1161  	}
1162  	while (!confirmation_height_processor.current ().is_zero ())
1163  	{
1164  		ASSERT_NO_ERROR (system.poll ());
1165  	}
1166  	auto transaction = store->tx_begin_read ();
1167  	size_t cemented_count = 0;
1168  	for (auto i (store->confirmation_height.begin (transaction)), n (store->confirmation_height.end ()); i != n; ++i)
1169  	{
1170  		cemented_count += i->second.height;
1171  	}
1172  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1173  	ASSERT_EQ (cemented_count, ledger.cache.cemented_count);
1174  }
1175  }
1176  namespace
1177  {
1178  class data
1179  {
1180  public:
1181  	std::atomic<bool> awaiting_cache{ false };
1182  	std::atomic<bool> keep_requesting_metrics{ true };
1183  	std::shared_ptr<nano::node> node;
1184  	std::chrono::system_clock::time_point orig_time;
1185  	std::atomic_flag orig_time_set = ATOMIC_FLAG_INIT;
1186  };
1187  class shared_data
1188  {
1189  public:
1190  	nano::test::counted_completion write_completion{ 0 };
1191  	std::atomic<bool> done{ false };
1192  };
1193  template <typename T>
1194  void callback_process (shared_data & shared_data_a, data & data, T & all_node_data_a, std::chrono::system_clock::time_point last_updated)
1195  {
1196  	if (!data.orig_time_set.test_and_set ())
1197  	{
1198  		data.orig_time = last_updated;
1199  	}
1200  	if (data.awaiting_cache && data.orig_time != last_updated)
1201  	{
1202  		data.keep_requesting_metrics = false;
1203  	}
1204  	if (data.orig_time != last_updated)
1205  	{
1206  		data.awaiting_cache = true;
1207  		data.orig_time = last_updated;
1208  	}
1209  	shared_data_a.write_completion.increment ();
1210  };
1211  }
1212  TEST (telemetry, ongoing_requests)
1213  {
1214  	nano::test::system system;
1215  	nano::node_flags node_flags;
1216  	auto node_client = system.add_node (node_flags);
1217  	auto node_server = system.add_node (node_flags);
1218  	nano::test::wait_peer_connections (system);
1219  	ASSERT_EQ (0, node_client->telemetry.size ());
1220  	ASSERT_EQ (0, node_server->telemetry.size ());
1221  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1222  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1223  	ASSERT_TIMELY (20s, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1 && node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1);
1224  	auto time = std::chrono::steady_clock::now ();
1225  	ASSERT_TIMELY (10s, std::chrono::steady_clock::now () >= (time + nano::dev::network_params.network.telemetry_cache_cutoff + 1s));
1226  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1227  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1228  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1229  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1230  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1231  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1232  }
1233  namespace nano
1234  {
1235  namespace transport
1236  {
1237  	TEST (telemetry, simultaneous_requests)
1238  	{
1239  		nano::test::system system;
1240  		nano::node_flags node_flags;
1241  		auto const num_nodes = 4;
1242  		for (int i = 0; i < num_nodes; ++i)
1243  		{
1244  			system.add_node (node_flags);
1245  		}
1246  		nano::test::wait_peer_connections (system);
1247  		std::vector<std::thread> threads;
1248  		auto const num_threads = 4;
1249  		std::array<data, num_nodes> node_data{};
1250  		for (auto i = 0; i < num_nodes; ++i)
1251  		{
1252  			node_data[i].node = system.nodes[i];
1253  		}
1254  		shared_data shared_data;
1255  		for (int i = 0; i < num_threads; ++i)
1256  		{
1257  			threads.emplace_back ([&node_data, &shared_data] () {
1258  				while (std::any_of (node_data.cbegin (), node_data.cend (), [] (auto const & data) { return data.keep_requesting_metrics.load (); }))
1259  				{
1260  					for (auto & data : node_data)
1261  					{
1262  						if (data.keep_requesting_metrics)
1263  						{
1264  							shared_data.write_completion.increment_required_count ();
1265  							auto peer = data.node->network.tcp_channels.channels[0].channel;
1266  							auto maybe_telemetry = data.node->telemetry.get_telemetry (peer->get_endpoint ());
1267  							if (maybe_telemetry)
1268  							{
1269  								callback_process (shared_data, data, node_data, maybe_telemetry->timestamp);
1270  							}
1271  						}
1272  						std::this_thread::sleep_for (1ms);
1273  					}
1274  				}
1275  				shared_data.write_completion.await_count_for (20s);
1276  				shared_data.done = true;
1277  			});
1278  		}
1279  		ASSERT_TIMELY (30s, shared_data.done);
1280  		ASSERT_TRUE (std::all_of (node_data.begin (), node_data.end (), [] (auto const & data) { return !data.keep_requesting_metrics; }));
1281  		for (auto & thread : threads)
1282  		{
1283  			thread.join ();
1284  		}
1285  	}
1286  }
1287  }
1288  TEST (telemetry, under_load)
1289  {
1290  	nano::test::system system;
1291  	nano::node_config node_config = system.default_config ();
1292  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1293  	nano::node_flags node_flags;
1294  	auto node = system.add_node (node_config, node_flags);
1295  	node_config.peering_port = system.get_available_port ();
1296  	auto node1 = system.add_node (node_config, node_flags);
1297  	nano::keypair key;
1298  	nano::keypair key1;
1299  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1300  	system.wallet (0)->insert_adhoc (key.prv);
1301  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
1302  	auto num_blocks = 150000;
1303  	nano::block_builder builder;
1304  	auto send = builder
1305  				.state ()
1306  				.account (nano::dev::genesis_key.pub)
1307  				.previous (latest_genesis)
1308  				.representative (nano::dev::genesis_key.pub)
1309  				.balance (nano::dev::constants.genesis_amount - num_blocks)
1310  				.link (key.pub)
1311  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1312  				.work (*system.work.generate (latest_genesis))
1313  				.build_shared ();
1314  	node->process_active (send);
1315  	latest_genesis = send->hash ();
1316  	auto open = builder
1317  				.state ()
1318  				.account (key.pub)
1319  				.previous (0)
1320  				.representative (key.pub)
1321  				.balance (num_blocks)
1322  				.link (send->hash ())
1323  				.sign (key.prv, key.pub)
1324  				.work (*system.work.generate (key.pub))
1325  				.build_shared ();
1326  	node->process_active (open);
1327  	auto latest_key = open->hash ();
1328  	auto thread_func = [key1, &system, node, num_blocks] (nano::keypair const & keypair, nano::block_hash const & latest, nano::uint128_t const initial_amount) {
1329  		auto latest_l = latest;
1330  		nano::block_builder builder;
1331  		for (int i = 0; i < num_blocks; ++i)
1332  		{
1333  			auto send = builder
1334  						.state ()
1335  						.account (keypair.pub)
1336  						.previous (latest_l)
1337  						.representative (keypair.pub)
1338  						.balance (initial_amount - i - 1)
1339  						.link (key1.pub)
1340  						.sign (keypair.prv, keypair.pub)
1341  						.work (*system.work.generate (latest_l))
1342  						.build_shared ();
1343  			latest_l = send->hash ();
1344  			node->process_active (send);
1345  		}
1346  	};
1347  	std::thread thread1 (thread_func, nano::dev::genesis_key, latest_genesis, nano::dev::constants.genesis_amount - num_blocks);
1348  	std::thread thread2 (thread_func, key, latest_key, num_blocks);
1349  	ASSERT_TIMELY (200s, node1->ledger.cache.block_count == num_blocks * 2 + 3);
1350  	thread1.join ();
1351  	thread2.join ();
1352  	for (auto const & node : system.nodes)
1353  	{
1354  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::failed_send_telemetry_req));
1355  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone));
1356  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::unsolicited_telemetry_ack));
1357  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::no_response_received));
1358  	}
1359  }
1360  TEST (telemetry, cache_read_and_timeout)
1361  {
1362  	nano::test::system system;
1363  	nano::node_flags node_flags;
1364  	node_flags.disable_ongoing_telemetry_requests = true;
1365  	auto node_client = system.add_node (node_flags);
1366  	auto node_server = system.add_node (node_flags);
1367  	nano::test::wait_peer_connections (system);
1368  	std::optional<nano::telemetry_data> telemetry_data;
1369  	auto channel = node_client->network.find_node_id (node_server->get_node_id ());
1370  	ASSERT_NE (channel, nullptr);
1371  	node_client->telemetry.trigger ();
1372  	ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (channel->get_endpoint ()));
1373  	auto responses = node_client->telemetry.get_all_telemetries ();
1374  	ASSERT_TRUE (!responses.empty ());
1375  	ASSERT_EQ (telemetry_data, responses.begin ()->second);
1376  	ASSERT_EQ (1, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1377  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1378  	ASSERT_EQ (1, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1379  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1380  	ASSERT_EQ (1, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1381  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1382  	ASSERT_TIMELY (5s, node_client->telemetry.get_all_telemetries ().empty ());
1383  	responses = node_client->telemetry.get_all_telemetries ();
1384  	ASSERT_TRUE (responses.empty ());
1385  	node_client->telemetry.trigger ();
1386  	ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (channel->get_endpoint ()));
1387  	responses = node_client->telemetry.get_all_telemetries ();
1388  	ASSERT_TRUE (!responses.empty ());
1389  	ASSERT_EQ (telemetry_data, responses.begin ()->second);
1390  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1391  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1392  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1393  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1394  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1395  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1396  }
1397  TEST (telemetry, many_nodes)
1398  {
1399  	nano::test::system system;
1400  	nano::node_flags node_flags;
1401  	node_flags.disable_request_loop = true;
1402  	auto const num_nodes = nano::memory_intensive_instrumentation () ? 4 : 10;
1403  	for (auto i = 0; i < num_nodes; ++i)
1404  	{
1405  		nano::node_config node_config = system.default_config ();
1406  		node_config.bandwidth_limit = 100000 + i;
1407  		auto node = std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), node_config, system.work, node_flags);
1408  		node->start ();
1409  		system.nodes.push_back (node);
1410  	}
1411  	for (auto const & node : system.nodes)
1412  	{
1413  		for (auto const & other_node : system.nodes)
1414  		{
1415  			if (node != other_node)
1416  			{
1417  				node->network.merge_peer (other_node->network.endpoint ());
1418  			}
1419  		}
1420  	}
1421  	nano::test::wait_peer_connections (system);
1422  	nano::keypair key;
1423  	nano::block_builder builder;
1424  	auto send = builder
1425  				.state ()
1426  				.account (nano::dev::genesis_key.pub)
1427  				.previous (nano::dev::genesis->hash ())
1428  				.representative (nano::dev::genesis_key.pub)
1429  				.balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1430  				.link (key.pub)
1431  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1432  				.work (*system.work.generate (nano::dev::genesis->hash ()))
1433  				.build ();
1434  	for (auto node : system.nodes)
1435  	{
1436  		auto transaction (node->store.tx_begin_write ());
1437  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
1438  	}
1439  	auto node_client = system.nodes.front ();
1440  	std::vector<nano::telemetry_data> telemetry_datas;
1441  	auto peers = node_client->network.list (num_nodes - 1);
1442  	ASSERT_EQ (peers.size (), num_nodes - 1);
1443  	for (auto const & peer : peers)
1444  	{
1445  		std::optional<nano::telemetry_data> telemetry_data;
1446  		ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (peer->get_endpoint ()));
1447  		telemetry_datas.push_back (*telemetry_data);
1448  	}
1449  	ASSERT_EQ (telemetry_datas.size (), num_nodes - 1);
1450  	for (auto & data : telemetry_datas)
1451  	{
1452  		ASSERT_EQ (data.unchecked_count, 0);
1453  		ASSERT_EQ (data.cemented_count, 1);
1454  		ASSERT_LE (data.peer_count, 9U);
1455  		ASSERT_EQ (data.account_count, 1);
1456  		ASSERT_TRUE (data.block_count == 2);
1457  		ASSERT_EQ (data.protocol_version, nano::dev::network_params.network.protocol_version);
1458  		ASSERT_GE (data.bandwidth_cap, 100000);
1459  		ASSERT_LT (data.bandwidth_cap, 100000 + system.nodes.size ());
1460  		ASSERT_EQ (data.major_version, nano::get_major_node_version ());
1461  		ASSERT_EQ (data.minor_version, nano::get_minor_node_version ());
1462  		ASSERT_EQ (data.patch_version, nano::get_patch_node_version ());
1463  		ASSERT_EQ (data.pre_release_version, nano::get_pre_release_node_version ());
1464  		ASSERT_EQ (data.maker, 0);
1465  		ASSERT_LT (data.uptime, 100);
1466  		ASSERT_EQ (data.genesis_block, nano::dev::genesis->hash ());
1467  		ASSERT_LE (data.timestamp, std::chrono::system_clock::now ());
1468  		ASSERT_EQ (data.active_difficulty, system.nodes.front ()->default_difficulty (nano::work_version::work_1));
1469  	}
1470  	auto bandwidth_cap = telemetry_datas.front ().bandwidth_cap;
1471  	telemetry_datas.erase (telemetry_datas.begin ());
1472  	auto all_bandwidth_limits_same = std::all_of (telemetry_datas.begin (), telemetry_datas.end (), [bandwidth_cap] (auto & telemetry_data) {
1473  		return telemetry_data.bandwidth_cap == bandwidth_cap;
1474  	});
1475  	ASSERT_FALSE (all_bandwidth_limits_same);
1476  }
1477  TEST (signature_checker, mass_boundary_checks)
1478  {
1479  	std::vector<size_t> sizes{ 0, 1 };
1480  	auto add_boundary = [&sizes] (size_t boundary) {
1481  		sizes.insert (sizes.end (), { boundary - 1, boundary, boundary + 1 });
1482  	};
1483  	for (auto i = 1; i <= 10; ++i)
1484  	{
1485  		add_boundary (nano::signature_checker::batch_size * i);
1486  	}
1487  	nano::block_builder builder;
1488  	for (auto num_threads = 0; num_threads < 5; ++num_threads)
1489  	{
1490  		nano::signature_checker checker (num_threads);
1491  		auto max_size = *(sizes.end () - 1);
1492  		std::vector<nano::uint256_union> hashes;
1493  		hashes.reserve (max_size);
1494  		std::vector<unsigned char const *> messages;
1495  		messages.reserve (max_size);
1496  		std::vector<size_t> lengths;
1497  		lengths.reserve (max_size);
1498  		std::vector<unsigned char const *> pub_keys;
1499  		pub_keys.reserve (max_size);
1500  		std::vector<unsigned char const *> signatures;
1501  		signatures.reserve (max_size);
1502  		nano::keypair key;
1503  		auto block = builder
1504  					 .state ()
1505  					 .account (key.pub)
1506  					 .previous (0)
1507  					 .representative (key.pub)
1508  					 .balance (0)
1509  					 .link (0)
1510  					 .sign (key.prv, key.pub)
1511  					 .work (0)
1512  					 .build ();
1513  		size_t last_size = 0;
1514  		for (auto size : sizes)
1515  		{
1516  			auto extra_size = size - last_size;
1517  			std::vector<int> verifications;
1518  			verifications.resize (size);
1519  			for (auto i (0); i < extra_size; ++i)
1520  			{
1521  				hashes.push_back (block->hash ());
1522  				messages.push_back (hashes.back ().bytes.data ());
1523  				lengths.push_back (sizeof (decltype (hashes)::value_type));
1524  				pub_keys.push_back (block->hashables.account.bytes.data ());
1525  				signatures.push_back (block->signature.bytes.data ());
1526  			}
1527  			nano::signature_check_set check = { size, messages.data (), lengths.data (), pub_keys.data (), signatures.data (), verifications.data () };
1528  			checker.verify (check);
1529  			bool all_valid = std::all_of (verifications.cbegin (), verifications.cend (), [] (auto verification) { return verification == 1; });
1530  			ASSERT_TRUE (all_valid);
1531  			last_size = size;
1532  		}
1533  	}
1534  }
1535  TEST (node, mass_epoch_upgrader)
1536  {
1537  	auto perform_test = [] (size_t const batch_size) {
1538  		unsigned threads = 5;
1539  		size_t total_accounts = 2500;
1540  #ifndef NDEBUG
1541  		total_accounts /= 5;
1542  #endif
1543  		struct info
1544  		{
1545  			nano::keypair key;
1546  			nano::block_hash pending_hash;
1547  		};
1548  		std::vector<info> opened (total_accounts / 2);
1549  		std::vector<info> unopened (total_accounts / 2);
1550  		nano::test::system system;
1551  		nano::node_config node_config = system.default_config ();
1552  		node_config.work_threads = 4;
1553  		auto & node = *system.add_node (node_config);
1554  		auto balance = node.balance (nano::dev::genesis_key.pub);
1555  		auto latest = node.latest (nano::dev::genesis_key.pub);
1556  		nano::uint128_t amount = 1;
1557  		std::array<std::vector<info> *, 2> all{ &opened, &unopened };
1558  		for (auto & accounts : all)
1559  		{
1560  			for (auto & info : *accounts)
1561  			{
1562  				balance -= amount;
1563  				nano::state_block_builder builder;
1564  				std::error_code ec;
1565  				auto block = builder
1566  							 .account (nano::dev::genesis_key.pub)
1567  							 .previous (latest)
1568  							 .balance (balance)
1569  							 .link (info.key.pub)
1570  							 .representative (nano::dev::genesis_key.pub)
1571  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1572  							 .work (*node.work_generate_blocking (latest, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1573  							 .build (ec);
1574  				ASSERT_FALSE (ec);
1575  				ASSERT_NE (nullptr, block);
1576  				ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1577  				latest = block->hash ();
1578  				info.pending_hash = block->hash ();
1579  			}
1580  		}
1581  		ASSERT_EQ (1 + total_accounts, node.ledger.cache.block_count);
1582  		ASSERT_EQ (1, node.ledger.cache.account_count);
1583  		for (auto const & info : opened)
1584  		{
1585  			nano::state_block_builder builder;
1586  			std::error_code ec;
1587  			auto block = builder
1588  						 .account (info.key.pub)
1589  						 .previous (0)
1590  						 .balance (amount)
1591  						 .link (info.pending_hash)
1592  						 .representative (info.key.pub)
1593  						 .sign (info.key.prv, info.key.pub)
1594  						 .work (*node.work_generate_blocking (info.key.pub, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1595  						 .build (ec);
1596  			ASSERT_FALSE (ec);
1597  			ASSERT_NE (nullptr, block);
1598  			ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1599  		}
1600  		ASSERT_EQ (1 + total_accounts + opened.size (), node.ledger.cache.block_count);
1601  		ASSERT_EQ (1 + opened.size (), node.ledger.cache.account_count);
1602  		nano::keypair epoch_signer (nano::dev::genesis_key);
1603  		auto const block_count_before = node.ledger.cache.block_count.load ();
1604  		auto const total_to_upgrade = 1 + total_accounts;
1605  		std::cout << "Mass upgrading " << total_to_upgrade << " accounts" << std::endl;
1606  		while (node.ledger.cache.block_count != block_count_before + total_to_upgrade)
1607  		{
1608  			auto const pre_upgrade = node.ledger.cache.block_count.load ();
1609  			auto upgrade_count = std::min<size_t> (batch_size, block_count_before + total_to_upgrade - pre_upgrade);
1610  			ASSERT_FALSE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1611  			ASSERT_TRUE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1612  			system.deadline_set (60s);
1613  			while (node.ledger.cache.block_count != pre_upgrade + upgrade_count)
1614  			{
1615  				ASSERT_NO_ERROR (system.poll ());
1616  				std::this_thread::sleep_for (200ms);
1617  				std::cout << node.ledger.cache.block_count - block_count_before << " / " << total_to_upgrade << std::endl;
1618  			}
1619  			std::this_thread::sleep_for (50ms);
1620  		}
1621  		auto expected_blocks = block_count_before + total_accounts + 1;
1622  		ASSERT_EQ (expected_blocks, node.ledger.cache.block_count);
1623  		{
1624  			auto transaction (node.store.tx_begin_read ());
1625  			size_t block_count_sum = 0;
1626  			for (auto i (node.store.account.begin (transaction)); i != node.store.account.end (); ++i)
1627  			{
1628  				nano::account_info info (i->second);
1629  				ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1630  				block_count_sum += info.block_count;
1631  			}
1632  			ASSERT_EQ (expected_blocks, block_count_sum);
1633  		}
1634  	};
1635  	perform_test (42);
1636  	perform_test (std::numeric_limits<size_t>::max ());
1637  }
1638  namespace nano
1639  {
1640  TEST (node, mass_block_new)
1641  {
1642  	nano::test::system system;
1643  	nano::node_config node_config = system.default_config ();
1644  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1645  	auto & node = *system.add_node (node_config);
1646  	node.network_params.network.aec_loop_interval_ms = 500;
1647  #ifndef NDEBUG
1648  	auto const num_blocks = 5000;
1649  #else
1650  	auto const num_blocks = 50000;
1651  #endif
1652  	std::cout << num_blocks << " x4 blocks" << std::endl;
1653  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
1654  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_2);
1655  	auto next_block_count = num_blocks + 3;
1656  	auto process_all = [&] (std::vector<std::shared_ptr<nano::state_block>> const & blocks_a) {
1657  		for (auto const & block : blocks_a)
1658  		{
1659  			node.process_active (block);
1660  		}
1661  		ASSERT_TIMELY (200s, node.ledger.cache.block_count == next_block_count);
1662  		next_block_count += num_blocks;
1663  		node.block_processor.flush ();
1664  		{
1665  			nano::lock_guard<nano::mutex> guard{ node.active.mutex };
1666  			node.active.roots.clear ();
1667  			node.active.blocks.clear ();
1668  		}
1669  	};
1670  	nano::keypair key;
1671  	std::vector<nano::keypair> keys (num_blocks);
1672  	nano::state_block_builder builder;
1673  	std::vector<std::shared_ptr<nano::state_block>> send_blocks;
1674  	auto send_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false)));
1675  	auto latest_genesis = node.latest (nano::dev::genesis_key.pub);
1676  	for (auto i = 0; i < num_blocks; ++i)
1677  	{
1678  		auto send = builder.make_block ()
1679  					.account (nano::dev::genesis_key.pub)
1680  					.previous (latest_genesis)
1681  					.balance (nano::dev::constants.genesis_amount - i - 1)
1682  					.representative (nano::dev::genesis_key.pub)
1683  					.link (keys[i].pub)
1684  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1685  					.work (*system.work.generate (nano::work_version::work_1, latest_genesis, send_threshold))
1686  					.build ();
1687  		latest_genesis = send->hash ();
1688  		send_blocks.push_back (std::move (send));
1689  	}
1690  	std::cout << "Send blocks built, start processing" << std::endl;
1691  	nano::timer<> timer;
1692  	timer.start ();
1693  	process_all (send_blocks);
1694  	std::cout << "Send blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1695  	std::vector<std::shared_ptr<nano::state_block>> open_blocks;
1696  	auto receive_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, true, false)));
1697  	for (auto i = 0; i < num_blocks; ++i)
1698  	{
1699  		auto const & key = keys[i];
1700  		auto open = builder.make_block ()
1701  					.account (key.pub)
1702  					.previous (0)
1703  					.balance (1)
1704  					.representative (key.pub)
1705  					.link (send_blocks[i]->hash ())
1706  					.sign (key.prv, key.pub)
1707  					.work (*system.work.generate (nano::work_version::work_1, key.pub, receive_threshold))
1708  					.build ();
1709  		open_blocks.push_back (std::move (open));
1710  	}
1711  	std::cout << "Open blocks built, start processing" << std::endl;
1712  	timer.restart ();
1713  	process_all (open_blocks);
1714  	std::cout << "Open blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1715  	std::vector<std::shared_ptr<nano::state_block>> send_blocks2;
1716  	for (auto i = 0; i < num_blocks; ++i)
1717  	{
1718  		auto const & key = keys[i];
1719  		auto const & latest = open_blocks[i];
1720  		auto send2 = builder.make_block ()
1721  					 .account (key.pub)
1722  					 .previous (latest->hash ())
1723  					 .balance (0)
1724  					 .representative (key.pub)
1725  					 .link (key.pub)
1726  					 .sign (key.prv, key.pub)
1727  					 .work (*system.work.generate (nano::work_version::work_1, latest->hash (), send_threshold))
1728  					 .build ();
1729  		send_blocks2.push_back (std::move (send2));
1730  	}
1731  	std::cout << "Send2 blocks built, start processing" << std::endl;
1732  	timer.restart ();
1733  	process_all (send_blocks2);
1734  	std::cout << "Send2 blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1735  	std::vector<std::shared_ptr<nano::state_block>> receive_blocks;
1736  	for (auto i = 0; i < num_blocks; ++i)
1737  	{
1738  		auto const & key = keys[i];
1739  		auto const & latest = send_blocks2[i];
1740  		auto send2 = builder.make_block ()
1741  					 .account (key.pub)
1742  					 .previous (latest->hash ())
1743  					 .balance (1)
1744  					 .representative (key.pub)
1745  					 .link (latest->hash ())
1746  					 .sign (key.prv, key.pub)
1747  					 .work (*system.work.generate (nano::work_version::work_1, latest->hash (), receive_threshold))
1748  					 .build ();
1749  		receive_blocks.push_back (std::move (send2));
1750  	}
1751  	std::cout << "Receive blocks built, start processing" << std::endl;
1752  	timer.restart ();
1753  	process_all (receive_blocks);
1754  	std::cout << "Receive blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1755  }
1756  TEST (node, aggressive_flooding)
1757  {
1758  	nano::test::system system;
1759  	nano::node_flags node_flags;
1760  	node_flags.disable_request_loop = true;
1761  	node_flags.disable_bootstrap_bulk_push_client = true;
1762  	node_flags.disable_bootstrap_bulk_pull_server = true;
1763  	node_flags.disable_bootstrap_listener = true;
1764  	node_flags.disable_lazy_bootstrap = true;
1765  	node_flags.disable_legacy_bootstrap = true;
1766  	node_flags.disable_wallet_bootstrap = true;
1767  	node_flags.disable_ascending_bootstrap = true;
1768  	auto & node1 (*system.add_node (node_flags));
1769  	auto & wallet1 (*system.wallet (0));
1770  	wallet1.insert_adhoc (nano::dev::genesis_key.prv);
1771  	std::vector<std::pair<std::shared_ptr<nano::node>, std::shared_ptr<nano::wallet>>> nodes_wallets;
1772  	nodes_wallets.resize (!nano::memory_intensive_instrumentation () ? 5 : 3);
1773  	std::generate (nodes_wallets.begin (), nodes_wallets.end (), [&system, node_flags] () {
1774  		nano::node_config node_config = system.default_config ();
1775  		auto node (system.add_node (node_config, node_flags));
1776  		return std::make_pair (node, system.wallet (system.nodes.size () - 1));
1777  	});
1778  	ASSERT_TIMELY (5s, node1.network.size () == nodes_wallets.size ());
1779  	ASSERT_LT (node1.network.fanout (), nodes_wallets.size ());
1780  	ASSERT_TIMELY (10s, std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const & node_wallet) { return node_wallet.first->rep_crawler.principal_representatives ().size () != 0; }));
1781  	auto large_amount = (nano::dev::constants.genesis_amount / 2) / nodes_wallets.size ();
1782  	std::vector<std::shared_ptr<nano::block>> genesis_blocks;
1783  	for (auto & node_wallet : nodes_wallets)
1784  	{
1785  		nano::keypair keypair;
1786  		node_wallet.second->store.representative_set (node_wallet.first->wallets.tx_begin_write (), keypair.pub);
1787  		node_wallet.second->insert_adhoc (keypair.prv);
1788  		auto block (wallet1.send_action (nano::dev::genesis_key.pub, keypair.pub, large_amount));
1789  		ASSERT_NE (nullptr, block);
1790  		genesis_blocks.push_back (block);
1791  	}
1792  	for (auto & node_wallet : nodes_wallets)
1793  	{
1794  		for (auto const & block : genesis_blocks)
1795  		{
1796  			auto process_result (node_wallet.first->process (*block));
1797  			ASSERT_TRUE (nano::process_result::progress == process_result.code || nano::process_result::old == process_result.code);
1798  		}
1799  		ASSERT_EQ (node1.latest (nano::dev::genesis_key.pub), node_wallet.first->latest (nano::dev::genesis_key.pub));
1800  		ASSERT_EQ (genesis_blocks.back ()->hash (), node_wallet.first->latest (nano::dev::genesis_key.pub));
1801  		nano::test::start_elections (system, *node_wallet.first, { genesis_blocks.back () }, true);
1802  	}
1803  	nano::test::start_elections (system, node1, { genesis_blocks.back () }, true);
1804  	auto all_received = [&nodes_wallets] () {
1805  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const & node_wallet) {
1806  			auto local_representative (node_wallet.second->store.representative (node_wallet.first->wallets.tx_begin_read ()));
1807  			return node_wallet.first->ledger.account_balance (node_wallet.first->store.tx_begin_read (), local_representative) > 0;
1808  		});
1809  	};
1810  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, all_received ());
1811  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.ledger.cache.block_count == 1 + 2 * nodes_wallets.size ());
1812  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.rep_crawler.principal_representatives ().size () == nodes_wallets.size ());
1813  	nano::state_block_builder builder;
1814  	std::shared_ptr<nano::state_block> block{};
1815  	{
1816  		auto transaction (node1.store.tx_begin_read ());
1817  		block = builder.make_block ()
1818  				.account (nano::dev::genesis_key.pub)
1819  				.representative (nano::dev::genesis_key.pub)
1820  				.previous (node1.ledger.latest (transaction, nano::dev::genesis_key.pub))
1821  				.balance (node1.ledger.account_balance (transaction, nano::dev::genesis_key.pub) - 1)
1822  				.link (nano::dev::genesis_key.pub)
1823  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  				.work (*node1.work_generate_blocking (node1.ledger.latest (transaction, nano::dev::genesis_key.pub)))
1825  				.build ();
1826  	}
1827  	ASSERT_EQ (nano::process_result::progress, node1.process_local (block).value ().code);
1828  	auto all_have_block = [&nodes_wallets] (nano::block_hash const & hash_a) {
1829  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [hash = hash_a] (auto const & node_wallet) {
1830  			return node_wallet.first->block (hash) != nullptr;
1831  		});
1832  	};
1833  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (block->hash ()));
1834  	auto wallet_block = wallet1.send_sync (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 10);
1835  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (wallet_block));
1836  	ASSERT_EQ (1 + 2 * nodes_wallets.size () + 2, node1.ledger.cache.block_count);
1837  }
1838  TEST (node, send_single_many_peers)
1839  {
1840  	nano::test::system system (nano::memory_intensive_instrumentation () ? 4 : 10);
1841  	nano::keypair key2;
1842  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1843  	system.wallet (1)->insert_adhoc (key2.prv);
1844  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
1845  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
1846  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
1847  	ASSERT_TIMELY (3.5min, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return !node_a->balance (key2.pub).is_zero (); }));
1848  	system.stop ();
1849  	for (auto node : system.nodes)
1850  	{
1851  		ASSERT_TRUE (node->stopped);
1852  	}
1853  }
1854  }
1855  TEST (node, wallet_create_block_confirm_conflicts)
1856  {
1857  	for (int i = 0; i < 5; ++i)
1858  	{
1859  		nano::test::system system;
1860  		nano::block_builder builder;
1861  		nano::node_config node_config (system.get_available_port (), system.logging);
1862  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1863  		auto node = system.add_node (node_config);
1864  		auto const num_blocks = 10000;
1865  		auto latest = nano::dev::genesis->hash ();
1866  		nano::keypair key1;
1867  		{
1868  			auto transaction = node->store.tx_begin_write ();
1869  			for (auto i = num_blocks - 1; i > 0; --i)
1870  			{
1871  				auto send = builder
1872  							.send ()
1873  							.previous (latest)
1874  							.destination (key1.pub)
1875  							.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
1876  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1877  							.work (*system.work.generate (latest))
1878  							.build ();
1879  				ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
1880  				latest = send->hash ();
1881  			}
1882  		}
1883  		std::atomic<bool> done{ false };
1884  		std::thread t ([node, &done] () {
1885  			while (!done)
1886  			{
1887  				node->wallets.create (nano::random_wallet_id ());
1888  			}
1889  		});
1890  		{
1891  			auto block = node->store.block.get (node->store.tx_begin_read (), latest);
1892  			node->scheduler.buckets.manual (block);
1893  			std::shared_ptr<nano::election> election;
1894  			ASSERT_TIMELY (10s, (election = node->active.election (block->qualified_root ())) != nullptr);
1895  			election->force_confirm ();
1896  		}
1897  		ASSERT_TIMELY (120s, node->ledger.block_confirmed (node->store.tx_begin_read (), latest) && node->confirmation_height_processor.current () == 0);
1898  		done = true;
1899  		t.join ();
1900  	}
1901  }
1902  namespace nano
1903  {
1904  TEST (system, block_sequence)
1905  {
1906  	size_t const block_count = 400;
1907  	size_t const pr_count = 4;
1908  	size_t const listeners_per_pr = 0;
1909  	nano::test::system system;
1910  	std::vector<nano::keypair> reps;
1911  	for (auto i = 0; i < pr_count; ++i)
1912  	{
1913  		reps.push_back (nano::keypair{});
1914  	}
1915  	system.ledger_initialization_set (reps, nano::Gxrb_ratio);
1916  	system.deadline_set (3600s);
1917  	nano::node_config config;
1918  	config.peering_port = system.get_available_port ();
1919  	config.enable_voting = true;
1920  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1921  	nano::node_flags flags;
1922  	flags.disable_max_peers_per_ip = true;
1923  	flags.disable_ongoing_bootstrap = true;
1924  	auto root = system.add_node (config, flags);
1925  	auto wallet = root->wallets.items.begin ()->second;
1926  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
1927  	for (auto rep : reps)
1928  	{
1929  		system.wallet (0);
1930  		config.peering_port = system.get_available_port ();
1931  		auto pr = system.add_node (config, flags, nano::transport::transport_type::tcp, rep);
1932  		for (auto j = 0; j < listeners_per_pr; ++j)
1933  		{
1934  			config.peering_port = system.get_available_port ();
1935  			system.add_node (config, flags);
1936  		}
1937  		std::cerr << rep.pub.to_account () << ' ' << pr->wallets.items.begin ()->second->exists (rep.pub) << pr->weight (rep.pub) << ' ' << '\n';
1938  	}
1939  	while (std::any_of (system.nodes.begin (), system.nodes.end (), [] (std::shared_ptr<nano::node> const & node) {
1940  		return node->rep_crawler.representative_count () < 3;
1941  	}))
1942  	{
1943  		system.poll ();
1944  	}
1945  	for (auto & node : system.nodes)
1946  	{
1947  		std::cerr << std::to_string (node->network.port) << ": ";
1948  		auto prs = node->rep_crawler.principal_representatives ();
1949  		for (auto pr : prs)
1950  		{
1951  			std::cerr << pr.account.to_account () << ' ';
1952  		}
1953  		std::cerr << '\n';
1954  	}
1955  	nano::keypair key;
1956  	auto start = std::chrono::system_clock::now ();
1957  	std::deque<std::shared_ptr<nano::block>> blocks;
1958  	for (auto i = 0; i < block_count; ++i)
1959  	{
1960  		if ((i % 1000) == 0)
1961  		{
1962  			std::cerr << "Block: " << std::to_string (i) << " ms: " << std::to_string (std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now () - start).count ()) << "\n";
1963  		}
1964  		auto block = wallet->send_action (nano::dev::genesis_key.pub, key.pub, 1);
1965  		debug_assert (block != nullptr);
1966  		blocks.push_back (block);
1967  	}
1968  	auto done = false;
1969  	std::chrono::system_clock::time_point last;
1970  	auto interval = 1000ms;
1971  	while (!done)
1972  	{
1973  		if (std::chrono::system_clock::now () - last > interval)
1974  		{
1975  			std::string message;
1976  			for (auto i : system.nodes)
1977  			{
1978  				message += boost::str (boost::format ("N:%1% b:%2% c:%3% a:%4% s:%5% p:%6%\n") % std::to_string (i->network.port) % std::to_string (i->ledger.cache.block_count) % std::to_string (i->ledger.cache.cemented_count) % std::to_string (i->active.size ()) % std::to_string (i->scheduler.buckets.size ()) % std::to_string (i->network.size ()));
1979  				nano::lock_guard<nano::mutex> lock{ i->active.mutex };
1980  				for (auto const & j : i->active.roots)
1981  				{
1982  					auto election = j.election;
1983  					if (election->confirmation_request_count > 10)
1984  					{
1985  						message += boost::str (boost::format ("\t r:%1% i:%2%\n") % j.root.to_string () % std::to_string (election->confirmation_request_count));
1986  						for (auto const & k : election->votes ())
1987  						{
1988  							message += boost::str (boost::format ("\t\t r:%1% t:%2%\n") % k.first.to_account () % std::to_string (k.second.timestamp));
1989  						}
1990  					}
1991  				}
1992  			}
1993  			std::cerr << message << std::endl;
1994  			last = std::chrono::system_clock::now ();
1995  		}
1996  		done = std::all_of (system.nodes.begin (), system.nodes.end (), [&blocks] (std::shared_ptr<nano::node> node) { return node->block_confirmed (blocks.back ()->hash ()); });
1997  		system.poll ();
1998  	}
1999  }
2000  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartition.h"
5  #include "colpartitiongrid.h"
6  #include "colpartitionset.h"
7  #include "detlinefit.h"
8  #include "dppoint.h"
9  #include "helpers.h" 
10  #include "host.h"    
11  #include "imagefind.h"
12  #include "workingpartset.h"
13  #include <algorithm>
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part->set_type(block_type);
57    part->set_flow(flow);
58    part->AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part->set_left_margin(box.left());
60    part->set_right_margin(box.right());
61    part->SetBlobTypes();
62    part->ComputeLimits();
63    part->ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box->set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single->set_flow(BTFT_NONE);
71    single->AddBox(box);
72    single->ComputeLimits();
73    single->ClaimBoxes();
74    single->SetBlobTypes();
75    single->set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()->RemovePartner(false, this);
86    }
87    it.set_to_list(&lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()->RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
96    part->bounding_box_ = TBOX(left, bottom, right, top);
97    part->median_bottom_ = bottom;
98    part->median_top_ = top;
99    part->median_height_ = top - bottom;
100    part->median_left_ = left;
101    part->median_right_ = right;
102    part->median_width_ = right - left;
103    part->left_key_ = part->BoxLeftKey();
104    part->right_key_ = part->BoxRightKey();
105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox->bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom<BLOBNBOX>);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom<BLOBNBOX>, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft<BLOBNBOX>);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft<BLOBNBOX>, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf("Added box (%d,%d)->(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n",
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox->bounding_box().width() > biggest->bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox->bounding_box().height() > biggest->bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()->bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob->owner();
183      if (other == nullptr) {
184        bblob->set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob->owner() == this || bblob->owner() == nullptr);
195      bblob->set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob->owner() == this) {
203        bblob->set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob->flow() != BTFT_LEADER) {
212        if (bblob->owner() == this) {
213          bblob->set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob->remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ && !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() > bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf("Bounding box invalid\n");
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ > bounding_box_.left() ||
255        right_margin_ < bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf("Margins invalid\n");
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ > BoxLeftKey() || right_key_ < BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf("Key inside box: %d v %d or %d v %d\n", left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &other) const {
285    if (color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise &&
286        other.color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o < kMaxColorDistance && d_this2_o < kMaxColorDistance &&
298           d_o1_this < kMaxColorDistance && d_o2_this < kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &other) const {
308    if (bounding_box_.right() < other.bounding_box_.left() &&
309        bounding_box_.right() < other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() < bounding_box_.left() &&
313        other.bounding_box_.right() < LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() > other.bounding_box_.right() &&
317        bounding_box_.left() > other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() > bounding_box_.right() &&
321        other.bounding_box_.left() > RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
332    BLOBNBOX_C_IT other_it(const_cast<BLOBNBOX_CLIST *>(&other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() && !other_it.cycled_list()) {
336      if (box_it.data()->MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count > nonmatch_count;
<span onclick='openModal()' class='match'>346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
</span>352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob->IsDiacritic()) {
355        if (debug) {
356          tprintf("Blob is not a diacritic:");
357          blob->bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob->base_char_top() < min_top) {
362        min_top = blob->base_char_top();
363      }
364      if (blob->base_char_bottom() > max_bottom) {
365        max_bottom = blob->base_char_bottom();
366      }
367    }
368    bool result =
369        min_top > candidate.median_bottom_ && max_bottom < candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf("OKDiacritic!\n");
373      } else {
374        tprintf("y ranges don\'t overlap: %d-%d / %d-%d\n", max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector->sort_key();
383      left_key_tab_ = left_key_ <= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector->sort_key();
394      right_key_tab_ = right_key_ >= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ > bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ < bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
428    return it.data()->left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
432    it.move_to_last();
433    return it.data()->right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type < BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type < BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob->special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type < BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob->special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner->lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
477    } else {
478      partner->upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &upper_partners_ : &lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
494    if (!partners->singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &cb) {
501    ASSERT_HOST(owns_blobs() == other->owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other->bounding_box_.left(),
505                                  other->bounding_box_.bottom())) {
506      tprintf("Merging:");
507      Print();
508      other->Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type < BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other->boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other->special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) > 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&boxes_);
522    BLOBNBOX_C_IT it2(&other->boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2->owner();
526      if (prev_owner != other && prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2->set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other->left_margin_);
536    right_margin_ = std::max(right_margin_, other->right_margin_);
537    if (other->left_key_ < left_key_) {
538      left_key_ = other->left_key_;
539      left_key_tab_ = other->left_key_tab_;
540    }
541    if (other->right_key_ > right_key_) {
542      right_key_ = other->right_key_;
543      right_key_tab_ = other->right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other->flow_)) {
546      flow_ = other->flow_;
547      blob_type_ = other->blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom<BLOBNBOX>);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft<BLOBNBOX>);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper < 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&partners);
561      part_it.add_list_after(upper ? &other->upper_partners_
562                                   : &other->lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner->RemovePartner(!upper, other);
566        partner->RemovePartner(!upper, this);
567        partner->AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &merge1,
576                                    const ColPartition &merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf("Vertical partition\n");
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf("Voverlap %d (%d)\n", merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() < median_top_ && merged_box.top() > median_bottom_ &&
594        merged_box.bottom() < bounding_box_.top() - ok_box_overlap &&
595        merged_box.top() > bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf("Excessive box overlap\n");
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&boxes_);
608    TBOX left_box(it.data()->bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox->bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part->set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox->owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part->boxes_.empty()) {
627        split_part->AddBox(it.extract());
628        if (owns_blobs() && prev_owner != nullptr) {
629          bbox->set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part->IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part->left_key_tab_ = false;
640    ComputeLimits();
641    split_part->ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x <= bounding_box_.left() || split_x >= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part->set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox->owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &box = bbox->bounding_box();
656      if (box.left() >= split_x) {
657        split_part->AddBox(it.extract());
658        if (owns_blobs() && prev_owner != nullptr) {
659          bbox->set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&split_part->boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part->IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part->left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part->left_margin_ = split_x;
675    ComputeLimits();
676    split_part->ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox->bounding_box();
693        if (bbox->flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ > BoxLeftKey() && textord_debug_bugs) {
702      tprintf("Computed left-illegal partition\n");
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ < BoxRightKey() && textord_debug_bugs) {
709      tprintf("Computed right-illegal partition\n");
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox->flow() != BTFT_LEADER) {
733          const TBOX &box = bbox->bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast<int>(top_stats.median() + 0.5);
744      median_bottom_ = static_cast<int>(bottom_stats.median() + 0.5);
745      median_height_ = static_cast<int>(height_stats.median() + 0.5);
746      median_left_ = static_cast<int>(left_stats.median() + 0.5);
747      median_right_ = static_cast<int>(right_stats.median() + 0.5);
748      median_width_ = static_cast<int>(width_stats.median() + 0.5);
749    }
750    if (right_margin_ < bounding_box_.right() && textord_debug_bugs) {
751      tprintf("Made partition with bad right coords, %d < %d\n", right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ > bounding_box_.left() && textord_debug_bugs) {
756      tprintf("Made partition with bad left coords, %d > %d\n", left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper < 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&partners);
763      part_it.add_list_after(upper ? &upper_partners_ : &lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner->RemovePartner(!upper, this);
767        partner->AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf("Recomputed box for partition %p\n", static_cast<void *>(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &box) {
777    BLOBNBOX_C_IT it(&boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox->bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns->SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &first_column_, &last_column_,
793        &first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ < last_column_ && span_type == CST_PULLOUT &&
796        !IsLineType()) {
797      if (first_spanned_col >= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ & 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ & 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE && blob_type_ != BRT_VLINE &&
815          blob_type_ != BRT_RECTIMAGE && blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!"Undefined flow type for image!");
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!"Undefined flow type for text!");
854        }
855    }
856    ASSERT_HOST(!"Should never get here!");
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns->SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT && left_key_tab_ && right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob->set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob->bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob->bounding_box().left();
887      int right = blob->bounding_box().right();
888      gap_stats.add(left - prev_blob->bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob->set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind >= 4) {
900      tprintf("gap iqr = %g, blob_count=%d, limits=%g,%g\n", gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr < max_width * kMaxLeaderGapFractionOfMax &&
905        gap_iqr < min_width * kMaxLeaderGapFractionOfMin &&
906        blob_count >= kMinLeaderCount) {
907      int offset = static_cast<int>(ceil(gap_iqr * 2));
908      int min_step = static_cast<int>(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob->bounding_box().left();
917        int right = blob->bounding_box().right();
918        int height = blob->bounding_box().height();
919        for (int x = left; x < right; ++x) {
920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr && best_end->total_cost() < blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)->bounding_box().left() -
933                      blob->bounding_box().right();
934            if (blob->bounding_box().width() + gap > max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob->bounding_box().left() -
942                      it.data_relative(-1)->bounding_box().right();
943            if (blob->bounding_box().width() + gap > max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob->set_region_type(BRT_TEXT);
950          blob->set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf("No path\n");
960        } else {
961          tprintf("Total cost = %d vs allowed %d\n", best_end->total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob->NoisyNeighbours();
980      good_blob_score_ += blob->GoodTextBlob();
981      if (blob->region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob->region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count > vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count > hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value < -1 || 1 < value) {
997      int long_side;
998      int short_side;
999      if (value > 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count >= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side > kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect < long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) >= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) >= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN && strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN && value < 0 && strong_score < 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count >= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf("RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,",
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(" Projection value=%d, flow=%d, blob_type=%d\n", value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob->flow() != BTFT_LEADER) {
1053        blob->set_flow(flow_);
1054      }
1055      blob->set_region_type(blob_type_);
1056      ASSERT_HOST(blob->owner() == nullptr || blob->owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&boxes_);
1066    TBOX box(it.data()->bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob->bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()->bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()->bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob->bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()->bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&start_pt, &end_pt);
1107    return error < max_error && coverage >= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr && partner->working_set_ != nullptr) {
1120      working_set_ = partner->working_set_;
1121      working_set_->AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr && textord_debug_bugs) {
1125      tprintf("Partition with partner has no working set!:");
1126      Print();
1127      partner->Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() && col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind >= 2) {
1137      tprintf("Match is %s for:", (col_index & 1) ? "Real" : "Between");
1138      Print();
1139    }
1140    if (it.cycled_list() && textord_debug_bugs) {
1141      tprintf("Target column=%d, only had %d\n", first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() && last_column_ != first_column_ && !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() && col_index <= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &completed_blocks, &to_blocks);
1153      }
1154      work_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set->AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part->boxes()->empty());
1172      STATS side_steps(0, part->bounding_box().height() - 1);
1173      if (part->bounding_box().height() > max_line_height) {
1174        max_line_height = part->bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part->boxes());
1177      int prev_bottom = blob_it.data()->bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob->bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step < 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part->set_side_step(static_cast<int>(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part->set_bottom_spacing(part->median_bottom() -
1192                                 next_part->median_bottom());
1193        part->set_top_spacing(part->median_top() - next_part->median_top());
1194      } else {
1195        part->set_bottom_spacing(page_height);
1196        part->set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part->Print();
1200        tprintf("side step = %.2f, top spacing = %d, bottom spacing=%d\n",
1201                side_steps.median(), part->top_spacing(), part->bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part->bottom_spacing() > same_block_threshold ||
1219          !part->SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() && part->bottom_spacing() <= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                "Spacings unequal: upper:%d/%d, lower:%d/%d,"
1226                " sizes %d %d %d\n",
1227                part->top_spacing(), part->bottom_spacing(),
1228                next_part->top_spacing(), next_part->bottom_spacing(),
1229                part->median_height(), next_part->median_height(),
1230                third_part != nullptr ? third_part->median_height() : 0);
1231          }
1232          if (part->SizesSimilar(*next_part) &&
1233              next_part->median_height() * kMaxSameBlockLineSpacing >
1234                  part->bottom_spacing() &&
1235              part->median_height() * kMaxSameBlockLineSpacing >
1236                  part->top_spacing()) {
1237            if (third_part == nullptr || !next_part->SizesSimilar(*third_part) ||
1238                third_part->median_height() * kMaxSameBlockLineSpacing <=
1239                    next_part->bottom_spacing() ||
1240                next_part->median_height() * kMaxSameBlockLineSpacing <=
1241                    next_part->top_spacing() ||
1242                next_part->bottom_spacing() > part->bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf("Added line to current block.\n");
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block->block);
1255        }
1256        sp_block_it.set_to_list(&spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind && !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf("Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n",
1261                  part->top_spacing(), part->bottom_spacing(),
1262                  next_part->top_spacing(), next_part->bottom_spacing(),
1263                  part->median_height(), next_part->median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &bleft, const ICOORD &tright, ICOORD *pos) {
1269    if (pos->x() < bleft.x()) {
1270      pos->set_x(bleft.x());
1271    }
1272    if (pos->x() > tright.x()) {
1273      pos->set_x(tright.x());
1274    }
1275    if (pos->y() < bleft.y()) {
1276      pos->set_y(bleft.y());
1277    }
1278    if (pos->y() > tright.y()) {
1279      pos->set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block->pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block->pdblk.poly_block()->IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&to_block->blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part->boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob->owner() != part) {
1297          tprintf("Ownership incorrect for blob:");
1298          bblob->bounding_box().print();
1299          tprintf("Part=");
1300          part->Print();
1301          if (bblob->owner() == nullptr) {
1302            tprintf("Not owned\n");
1303          } else {
1304            tprintf("Owner part:");
1305            bblob->owner()->Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob->owner() == part);
1309        ASSERT_HOST(!text_type || bblob->region_type() >= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob->cblob()->out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()->pathlength() > 0);
1313        if (vertical_text) {
1314          sizes.add(bblob->bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob->bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type && blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block->line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block->pdblk.bounding_box().width();
1330      if (block_width < line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block->line_spacing = static_cast<float>(line_spacing);
1334      to_block->max_blob_size = static_cast<float>(block_width + 1);
1335    } else {
1336      int block_height = block->pdblk.bounding_box().height();
1337      if (block_height < line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block->line_spacing = static_cast<float>(line_spacing);
1341      to_block->max_blob_size = static_cast<float>(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &bleft, const ICOORD &tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts->empty()) {
1349      return nullptr; 
1350    }
1351    block_parts->sort(&ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part->type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part->bottom_spacing();
1359    if (line_spacing < part->median_height()) {
1360      line_spacing = part->bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&it, &start, &end);
1373      } else {
1374        ColPartition::RightEdgeRun(&it, &start, &end);
1375      }
1376      ClipCoord(bleft, tright, &start);
1377      ClipCoord(bleft, tright, &end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &min_x, &max_x);
1381      UpdateRange(end.x(), &min_x, &max_x);
1382      UpdateRange(start.y(), &min_y, &max_y);
1383      UpdateRange(end.y(), &min_y, &max_y);
1384      if ((iteration == 0 && it.at_first()) || (iteration == 1 && it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration < 2);
1389    if (textord_debug_tabfind) {
1390      tprintf("Making block at (%d,%d)->(%d,%d)\n", min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK("", true, 0, 0, min_x, min_y, max_x, max_y);
1393    block->pdblk.set_poly_block(new POLY_BLOCK(&vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &bleft,
1397                                                const ICOORD &tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts->empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part->bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()->type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()->bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf("Making block at:");
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK("", true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block->pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob->bounding_box().top();
1427      int bottom = blob->bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast<float>(top), static_cast<float>(bottom),
1431                       static_cast<float>(line_size));
1432      } else {
1433        row->add_blob(blob, static_cast<float>(top), static_cast<float>(bottom),
1434                      static_cast<float>(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part->left_margin_ = left_margin_;
1442    part->right_margin_ = right_margin_;
1443    part->bounding_box_ = bounding_box_;
1444    memcpy(part->special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part->median_bottom_ = median_bottom_;
1447    part->median_top_ = median_top_;
1448    part->median_height_ = median_height_;
1449    part->median_left_ = median_left_;
1450    part->median_right_ = median_right_;
1451    part->median_width_ = median_width_;
1452    part->good_width_ = good_width_;
1453    part->good_column_ = good_column_;
1454    part->left_key_tab_ = left_key_tab_;
1455    part->right_key_tab_ = right_key_tab_;
1456    part->type_ = type_;
1457    part->flow_ = flow_;
1458    part->left_key_ = left_key_;
1459    part->right_key_ = right_key_;
1460    part->first_column_ = first_column_;
1461    part->last_column_ = last_column_;
1462    part->owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy->set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy->boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = "NHSRIUVT";
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        "ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)->(%dB-%d%c-%dM/%d,%d/%d)"
1489        " w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d"
1490        " ts=%d bs=%d ls=%d rs=%d\n",
1491        boxes_.empty() ? 'E' : ' ', left_margin_, left_key_tab_ ? 'T' : 'B',
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? 'T' : 'B', right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf("Colors:(%d, %d, %d)%d -> (%d, %d, %d)\n", color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner->SingletonPartner(false)) {
1512      if (partner->type_ > max_type) {
1513        max_type = partner->type_;
1514      }
1515      if (column_set_ == partner->column_set_) {
1516        left_stats.add(partner->first_column_, 1);
1517        right_stats.add(partner->last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ < first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner->SingletonPartner(false)) {
1529      partner->type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner->column_set_) {
1532        partner->first_column_ = first_column_;
1533        partner->last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &upper_partners_);
1545      RefinePartnersByType(false, &lower_partners_);
1546      if (!upper_partners_.empty() && !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &upper_partners_);
1548      }
1549      if (!lower_partners_.empty() && !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
1557    if (!partners->empty() && !partners->singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners->empty() && !partners->singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners->empty() && !partners->singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) && get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners->empty() && !partners->singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners->empty() && !partners->singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf("Refining %d %s partners by type for:\n", partners->length(),
1581              upper ? "Upper" : "Lower");
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() && !IsLineType() && type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner->type_)) {
1589          if (debug) {
1590            tprintf("Removing partner:");
1591            partner->Print();
1592          }
1593          partner->RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf("Keeping partner:");
1597          partner->Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner->blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf("Removing partner:");
1607            partner->Print();
1608          }
1609          partner->RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf("Keeping partner:");
1613          partner->Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &a->upper_partners_ : &a->lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a->RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2->RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any && !partners->empty() && !partners->singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf("Refining %d %s partners by merge for:\n", partners->length(),
1662              upper ? "Upper" : "Lower");
1663      Print();
1664    }
1665    while (!partners->empty() && !partners->singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part->first_column_ == candidate->last_column_ &&
1673            part->last_column_ == candidate->first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid->BestMergeCandidate(
1679          part, &candidates, debug, nullptr, &overlap_increase);
1680      if (candidate != nullptr && (overlap_increase <= 0 || desperate)) {
1681        if (debug) {
1682          tprintf("Merging:hoverlap=%d, voverlap=%d, OLI=%d\n",
1683                  part->HCoreOverlap(*candidate), part->VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid->RemoveBBox(candidate);
1687        grid->RemoveBBox(part);
1688        part->Absorb(candidate, nullptr);
1689        grid->InsertBBox(true, true, part);
1690        if (overlap_increase > 0) {
1691          part->desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf("Refining %d %s partners by overlap for:\n", partners->length(),
1704              upper ? "Upper" : "Lower");
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner->bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner->bounding_box_.left());
1715      if (overlap > best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf("Removing partner:");
1725          partner->Print();
1726        }
1727        partner->RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &other) {
1734    const TBOX &box = bbox->bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left < left_margin_ || right > right_margin_) {
1738      return false;
1739    }
1740    if (left < other.left_margin_ || right > other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf("Unique on (%d,%d)->(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n",
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss < other_miss) {
1758      return true;
1759    }
1760    if (this_miss > other_miss) {
1761      return false;
1762    }
1763    if (this_overlap > other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap < other_overlap) {
1767      return false;
1768    }
1769    return median_top_ >= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part->bottom_spacing(), 1);
1777      stats.add(part->top_spacing(), 1);
1778    }
1779    return static_cast<int>(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &part) const {
1782    return (last_column_ >= part.first_column_) &&
1783           (first_column_ <= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i < PN_COUNT; ++i) {
1794      if (i < PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]->SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &&
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &&
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]->SpacingEqual(median_space, resolution)) &&
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]->SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper->bottom_spacing();
1827          total_top += upper->top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count > 0) {
1833          int top_spacing = static_cast<int>(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast<int>(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf("Spacing run ended. Cause:");
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf("No more lines\n");
1839            } else {
1840              tprintf("Spacing change. Spacings:\n");
1841              for (int i = 0; i < PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf("NULL");
1844                  if (i > 0 && neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]->SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(" Lower partner:");
1848                      neighbourhood[i - 1]->SingletonPartner(false)->Print();
1849                    } else {
1850                      tprintf(" nullptr lower partner:\n");
1851                    }
1852                  } else {
1853                    tprintf("\n");
1854                  }
1855                } else {
1856                  tprintf("Top = %d, bottom = %d\n",
1857                          neighbourhood[i]->top_spacing(),
1858                          neighbourhood[i]->bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf("Mean spacing = %d/%d\n", top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper->set_top_spacing(top_spacing);
1868            upper->set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf("Setting mean on:");
1871              upper->Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j < PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]->SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &&
1897           ((parts[PN_ABOVE1] != nullptr &&
1898             parts[PN_ABOVE1]->SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &&
1900             parts[PN_BELOW1]->SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &&
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &&
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &&
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &&
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast<int>(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast<int>(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &other) const {
1940    return median_height_ <= other.median_height_ * kMaxSizeRatio &&
1941           other.median_height_ <= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key <= *margin_right && right_key >= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it->data();
1964    ColPartition *start_part = part;
1965    int start_y = part->bounding_box_.top();
1966    if (!part_it->at_first()) {
1967      int prev_bottom = part_it->data_relative(-1)->bounding_box_.bottom();
1968      if (prev_bottom < start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom > start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part->bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &margin_left, &margin_right);
1978    do {
1979      part_it->forward();
1980      part = part_it->data();
1981    } while (!part_it->at_first() &&
1982             UpdateLeftMargin(*part, &margin_left, &margin_right));
1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &next_margin_left, &next_margin_right);
1986    if (next_margin_left > margin_right) {
1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &&
1992               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1993      do {
1994        part_it->backward();
1995        part = part_it->data();
1996      } while (part != start_part &&
1997               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1998      part_it->forward();
1999    }
2000    part = part_it->data_relative(-1);
2001    end_y = part->bounding_box_.bottom();
2002    if (!part_it->at_first() && part_it->data()->bounding_box_.top() < end_y) {
2003      end_y = (end_y + part_it->data()->bounding_box_.top()) / 2;
2004    }
2005    start->set_y(start_y);
2006    start->set_x(part->XAtY(margin_right, start_y));
2007    end->set_y(end_y);
2008    end->set_x(part->XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind && !part_it->at_first()) {
2010      tprintf("Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2011              start_y, end_y, part->XAtY(margin_left, end_y), end->x(),
2012              part->left_margin_, part->bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key <= *margin_right && right_key >= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it->data();
2036    ColPartition *start_part = part;
2037    int start_y = part->bounding_box_.bottom();
2038    if (!part_it->at_last()) {
2039      int next_y = part_it->data_relative(1)->bounding_box_.top();
2040      if (next_y > start_y) {
2041        start_y = next_y;
2042      } else if (next_y < start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part->bounding_box_.top();
2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &margin_left, &margin_right);
2050    do {
2051      part_it->backward();
2052      part = part_it->data();
2053    } while (!part_it->at_last() &&
2054             UpdateRightMargin(*part, &margin_left, &margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &next_margin_left, &next_margin_right);
2058    if (next_margin_right < margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &&
2064               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2065      do {
2066        part_it->forward();
2067        part = part_it->data();
2068      } while (part != start_part &&
2069               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2070      part_it->backward();
2071    }
2072    part = part_it->data_relative(1);
2073    end_y = part->bounding_box().top();
2074    if (!part_it->at_last() && part_it->data()->bounding_box_.bottom() > end_y) {
2075      end_y = (end_y + part_it->data()->bounding_box_.bottom()) / 2;
2076    }
2077    start->set_y(start_y);
2078    start->set_x(part->XAtY(margin_left, start_y));
2079    end->set_y(end_y);
2080    end->set_x(part->XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind && !part_it->at_last()) {
2082      tprintf("Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2083              start_y, end_y, end->x(), part->XAtY(margin_right, end_y),
2084              part->bounding_box_.right(), part->right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                </div>
                <div class="column column_space"><pre><code>475  }
476  TEST (store, pruned_load)
477  {
478  	nano::logger_mt logger;
479  	auto path (nano::unique_path ());
480  	constexpr auto num_pruned = 2000000;
481  	auto const expected_result = num_pruned / 2;
</pre></code></div>
                <div class="column column_space"><pre><code>346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    