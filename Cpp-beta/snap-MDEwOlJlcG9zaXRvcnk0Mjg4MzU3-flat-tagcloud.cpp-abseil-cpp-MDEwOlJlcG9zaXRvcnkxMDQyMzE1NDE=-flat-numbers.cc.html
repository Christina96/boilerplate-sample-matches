
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.976303317535545%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tagcloud.cpp</h3>
            <pre><code>1  #include "tagcloud.h"
<span onclick='openModal()' class='match'>2  PTagCloud TTagCloud::GetFromDocStrWgtPrV(const TStrFltPrV& DocStrWgtPrV, 
3   const int& TopWords=25, const double& TopWordsWgtSumPrc=1.0){
4    PTagCloud TagCloud=TTagCloud::New();
5    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
6    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
</span>7    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NULL);
8    TIntFltPrV DocIdWgtPrV(DocStrWgtPrV.Len(), 0);
9    for (int DocN=0; DocN<DocStrWgtPrV.Len(); DocN++){
10      TStr DocNm=TInt(DocN).GetStr();
11      TStr DocStr=DocStrWgtPrV[DocN].Val1;
12      double DocWgt=DocStrWgtPrV[DocN].Val2;
13      int DocId=BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr);
14      DocIdWgtPrV.Add(TIntFltPr(DocId, DocWgt));
15    }
16    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
17    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
18    PBowSim BowSim=TBowSim::New(bstCos); 
19    TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
20    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, AllDIdV, 1, DocIdWgtPrV);
21    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, TagCloud->WordStrWgtPrV);
22    TagCloud->PlaceWords();
23    return TagCloud;
24  }
25  void TTagCloud::PlaceWords(){
26    int Words=WordStrWgtPrV.Len();
27    TGksRectV RectV(Words);
28    for (int WordN=0; WordN<Words; WordN++){
29      RectV[WordN].X1=0; RectV[WordN].Y1=0;
30      RectV[WordN].X2=WordStrWgtPrV[WordN].Val1.Len(); RectV[WordN].Y2=1;
31    }
32    forever {
33      double AreaSum=0; double MxY=0;
34      for (int WordN=0; WordN<Words; WordN++){
35        RectV[WordN].X2*=0.9; RectV[WordN].Y2=0.9;
36        AreaSum+=RectV[WordN].X2*RectV[WordN].Y2;
37        MxY=(WordN==0) ? RectV[WordN].Y2 : TFlt::GetMx(MxY, RectV[WordN].Y2);
38      }
39      if ((AreaSum<0.25)&&(MxY<1)){
40        break;}
41    }
42  }
43  void TTagCloud::Dump(){
44    for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
45      printf("[%s:%.2f] ", WordStrWgtPrV[WordN].Val1.CStr(), WordStrWgtPrV[WordN].Val2);
46    }
47  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers.cc</h3>
            <pre><code>1  #include "absl/strings/numbers.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <cfloat>  
5  #include <cmath>   
6  #include <cstdint>
7  #include <cstdio>
8  #include <cstdlib>
9  #include <cstring>
10  #include <iterator>
11  #include <limits>
12  #include <memory>
13  #include <utility>
14  #include "absl/base/attributes.h"
15  #include "absl/base/internal/endian.h"
16  #include "absl/base/internal/raw_logging.h"
17  #include "absl/base/optimization.h"
18  #include "absl/numeric/bits.h"
19  #include "absl/strings/ascii.h"
20  #include "absl/strings/charconv.h"
21  #include "absl/strings/escaping.h"
22  #include "absl/strings/internal/memutil.h"
23  #include "absl/strings/match.h"
24  #include "absl/strings/str_cat.h"
25  namespace absl {
26  ABSL_NAMESPACE_BEGIN
27  bool SimpleAtof(absl::string_view str, float* out) {
28    *out = 0.0;
29    str = StripAsciiWhitespace(str);
30    if (!str.empty() && str[0] == '+') {
31      str.remove_prefix(1);
32      if (!str.empty() && str[0] == '-') {
33        return false;
34      }
35    }
36    auto result = absl::from_chars(str.data(), str.data() + str.size(), *out);
37    if (result.ec == std::errc::invalid_argument) {
38      return false;
39    }
40    if (result.ptr != str.data() + str.size()) {
41      return false;
42    }
43    if (result.ec == std::errc::result_out_of_range) {
44      if (*out > 1.0) {
45        *out = std::numeric_limits<float>::infinity();
46      } else if (*out < -1.0) {
47        *out = -std::numeric_limits<float>::infinity();
48      }
49    }
50    return true;
51  }
52  bool SimpleAtod(absl::string_view str, double* out) {
53    *out = 0.0;
54    str = StripAsciiWhitespace(str);
55    if (!str.empty() && str[0] == '+') {
56      str.remove_prefix(1);
57      if (!str.empty() && str[0] == '-') {
58        return false;
59      }
60    }
61    auto result = absl::from_chars(str.data(), str.data() + str.size(), *out);
62    if (result.ec == std::errc::invalid_argument) {
63      return false;
64    }
65    if (result.ptr != str.data() + str.size()) {
66      return false;
67    }
68    if (result.ec == std::errc::result_out_of_range) {
69      if (*out > 1.0) {
70        *out = std::numeric_limits<double>::infinity();
71      } else if (*out < -1.0) {
72        *out = -std::numeric_limits<double>::infinity();
73      }
74    }
75    return true;
76  }
77  bool SimpleAtob(absl::string_view str, bool* out) {
78    ABSL_RAW_CHECK(out != nullptr, "Output pointer must not be nullptr.");
79    if (EqualsIgnoreCase(str, "true") || EqualsIgnoreCase(str, "t") ||
80        EqualsIgnoreCase(str, "yes") || EqualsIgnoreCase(str, "y") ||
81        EqualsIgnoreCase(str, "1")) {
82      *out = true;
83      return true;
84    }
85    if (EqualsIgnoreCase(str, "false") || EqualsIgnoreCase(str, "f") ||
86        EqualsIgnoreCase(str, "no") || EqualsIgnoreCase(str, "n") ||
87        EqualsIgnoreCase(str, "0")) {
88      *out = false;
89      return true;
90    }
91    return false;
92  }
93  namespace {
94  constexpr uint32_t kTwoZeroBytes = 0x0101 * '0';
95  constexpr uint64_t kFourZeroBytes = 0x01010101 * '0';
96  constexpr uint64_t kEightZeroBytes = 0x0101010101010101ull * '0';
97  constexpr uint64_t kDivisionBy10Mul = 103u;
98  constexpr uint64_t kDivisionBy10Div = 1 << 10;
99  constexpr uint64_t kDivisionBy100Mul = 10486u;
100  constexpr uint64_t kDivisionBy100Div = 1 << 20;
101  inline char* EncodeHundred(uint32_t n, char* out_str) {
102    int num_digits = static_cast<int>(n - 10) >> 8;
103    uint32_t base = kTwoZeroBytes;
104    uint32_t div10 = (n * kDivisionBy10Mul) / kDivisionBy10Div;
105    uint32_t mod10 = n - 10u * div10;
106    base += div10 + (mod10 << 8);
107    base >>= num_digits & 8;
108    little_endian::Store16(out_str, static_cast<uint16_t>(base));
109    return out_str + 2 + num_digits;
110  }
111  inline char* EncodeTenThousand(uint32_t n, char* out_str) {
112    uint32_t div100 = (n * kDivisionBy100Mul) / kDivisionBy100Div;
113    uint32_t mod100 = n - 100ull * div100;
114    uint32_t hundreds = (mod100 << 16) + div100;
115    uint32_t tens = (hundreds * kDivisionBy10Mul) / kDivisionBy10Div;
116    tens &= (0xFull << 16) | 0xFull;
117    tens += (hundreds - 10ull * tens) << 8;
118    ABSL_ASSUME(tens != 0);
119    uint32_t zeroes = static_cast<uint32_t>(absl::countr_zero(tens)) & (0 - 8ull);
120    tens += kFourZeroBytes;
121    tens >>= zeroes;
122    little_endian::Store32(out_str, tens);
123    return out_str + sizeof(tens) - zeroes / 8;
124  }
125  inline uint64_t PrepareTenThousands(uint64_t hi, uint64_t lo) {
126    uint64_t merged = hi | (lo << 32);
127    uint64_t div100 = ((merged * kDivisionBy100Mul) / kDivisionBy100Div) &
128                      ((0x7Full << 32) | 0x7Full);
129    uint64_t mod100 = merged - 100ull * div100;
130    uint64_t hundreds = (mod100 << 16) + div100;
131    uint64_t tens = (hundreds * kDivisionBy10Mul) / kDivisionBy10Div;
132    tens &= (0xFull << 48) | (0xFull << 32) | (0xFull << 16) | 0xFull;
133    tens += (hundreds - 10ull * tens) << 8;
134    return tens;
135  }
136  inline char* EncodeFullU32(uint32_t n, char* out_str) {
137    if (n < 100'000'000) {
138      uint64_t bottom = PrepareTenThousands(n / 10000, n % 10000);
139      ABSL_ASSUME(bottom != 0);
140      uint32_t zeroes = static_cast<uint32_t>(absl::countr_zero(bottom))
141          & (0 - 8ull);
142      uint64_t bottom_res = bottom + kEightZeroBytes;
143      bottom_res >>= zeroes;
144      little_endian::Store64(out_str, bottom_res);
145      return out_str + sizeof(bottom) - zeroes / 8;
146    }
147    uint32_t top = n / 100'000'000;
148    n %= 100'000'000;
149    uint64_t bottom = PrepareTenThousands(n / 10000, n % 10000);
150    uint64_t bottom_res = bottom + kEightZeroBytes;
151    out_str = EncodeHundred(top, out_str);
152    little_endian::Store64(out_str, bottom_res);
153    return out_str + sizeof(bottom);
154  }
155  }  
156  void numbers_internal::PutTwoDigits(uint32_t i, char* buf) {
157    assert(i < 100);
158    uint32_t base = kTwoZeroBytes;
159    uint32_t div10 = (i * kDivisionBy10Mul) / kDivisionBy10Div;
160    uint32_t mod10 = i - 10u * div10;
161    base += div10 + (mod10 << 8);
162    little_endian::Store16(buf, static_cast<uint16_t>(base));
163  }
164  char* numbers_internal::FastIntToBuffer(uint32_t n, char* out_str) {
165    if (n < 100) {
166      out_str = EncodeHundred(n, out_str);
167      goto set_last_zero;
168    }
169    if (n < 10000) {
170      out_str = EncodeTenThousand(n, out_str);
171      goto set_last_zero;
172    }
173    out_str = EncodeFullU32(n, out_str);
174  set_last_zero:
175    *out_str = '\0';
176    return out_str;
177  }
178  char* numbers_internal::FastIntToBuffer(int32_t i, char* buffer) {
179    uint32_t u = static_cast<uint32_t>(i);
180    if (i < 0) {
181      *buffer++ = '-';
182      u = 0 - u;
183    }
184    return numbers_internal::FastIntToBuffer(u, buffer);
185  }
186  char* numbers_internal::FastIntToBuffer(uint64_t i, char* buffer) {
187    uint32_t u32 = static_cast<uint32_t>(i);
188    if (u32 == i) return numbers_internal::FastIntToBuffer(u32, buffer);
189    uint64_t div08 = i / 100'000'000ull;
190    uint64_t mod08 = i % 100'000'000ull;
191    uint64_t mod_result =
192        PrepareTenThousands(mod08 / 10000, mod08 % 10000) + kEightZeroBytes;
193    if (i < 10'000'000'000ull) {
194      buffer = EncodeHundred(static_cast<uint32_t>(div08), buffer);
195      little_endian::Store64(buffer, mod_result);
196      buffer += 8;
197      goto set_last_zero;
198    }
199    if (i < 10'000'000'000'000'000ull) {
200      buffer = EncodeFullU32(static_cast<uint32_t>(div08), buffer);
201      little_endian::Store64(buffer, mod_result);
202      buffer += 8;
203      goto set_last_zero;
204    } else {
205      uint64_t div016 = i / 10'000'000'000'000'000ull;
206      buffer = EncodeTenThousand(static_cast<uint32_t>(div016), buffer);
207      uint64_t mid_result = div08 - div016 * 100'000'000ull;
208      mid_result = PrepareTenThousands(mid_result / 10000, mid_result % 10000) +
209                   kEightZeroBytes;
210      little_endian::Store64(buffer, mid_result);
211      buffer += 8;
212      little_endian::Store64(buffer, mod_result);
213      buffer += 8;
214      goto set_last_zero;
215    }
216  set_last_zero:
217    *buffer = '\0';
218    return buffer;
219  }
220  char* numbers_internal::FastIntToBuffer(int64_t i, char* buffer) {
221    uint64_t u = static_cast<uint64_t>(i);
222    if (i < 0) {
223      *buffer++ = '-';
224      u = 0 - u;
225    }
226    return numbers_internal::FastIntToBuffer(u, buffer);
227  }
228  static std::pair<uint64_t, uint64_t> Mul32(std::pair<uint64_t, uint64_t> num,
229                                             uint32_t mul) {
230    uint64_t bits0_31 = num.second & 0xFFFFFFFF;
231    uint64_t bits32_63 = num.second >> 32;
232    uint64_t bits64_95 = num.first & 0xFFFFFFFF;
233    uint64_t bits96_127 = num.first >> 32;
234    bits0_31 *= mul;
235    bits32_63 *= mul;
236    bits64_95 *= mul;
237    bits96_127 *= mul;
238    uint64_t bits0_63 = bits0_31 + (bits32_63 << 32);
239    uint64_t bits64_127 = bits64_95 + (bits96_127 << 32) + (bits32_63 >> 32) +
240                          (bits0_63 < bits0_31);
241    uint64_t bits128_up = (bits96_127 >> 32) + (bits64_127 < bits64_95);
242    if (bits128_up == 0) return {bits64_127, bits0_63};
243    auto shift = static_cast<unsigned>(bit_width(bits128_up));
244    uint64_t lo = (bits0_63 >> shift) + (bits64_127 << (64 - shift));
245    uint64_t hi = (bits64_127 >> shift) + (bits128_up << (64 - shift));
246    return {hi, lo};
247  }
248  static std::pair<uint64_t, uint64_t> PowFive(uint64_t num, int expfive) {
249    std::pair<uint64_t, uint64_t> result = {num, 0};
250    while (expfive >= 13) {
251      result = Mul32(result, 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5);
252      expfive -= 13;
253    }
254    constexpr uint32_t powers_of_five[13] = {
255        1,
256        5,
257        5 * 5,
258        5 * 5 * 5,
259        5 * 5 * 5 * 5,
260        5 * 5 * 5 * 5 * 5,
261        5 * 5 * 5 * 5 * 5 * 5,
262        5 * 5 * 5 * 5 * 5 * 5 * 5,
263        5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
264        5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
265        5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
266        5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
267        5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5};
268    result = Mul32(result, powers_of_five[expfive & 15]);
269    int shift = countl_zero(result.first);
270    if (shift != 0) {
271      result.first = (result.first << shift) + (result.second >> (64 - shift));
272      result.second = (result.second << shift);
273    }
274    return result;
275  }
276  struct ExpDigits {
277    int32_t exponent;
278    char digits[6];
279  };
280  static ExpDigits SplitToSix(const double value) {
281    ExpDigits exp_dig;
282    int exp = 5;
283    double d = value;
284    if (d >= 999999.5) {
285      if (d >= 1e+261) exp += 256, d *= 1e-256;
286      if (d >= 1e+133) exp += 128, d *= 1e-128;
287      if (d >= 1e+69) exp += 64, d *= 1e-64;
288      if (d >= 1e+37) exp += 32, d *= 1e-32;
289      if (d >= 1e+21) exp += 16, d *= 1e-16;
290      if (d >= 1e+13) exp += 8, d *= 1e-8;
291      if (d >= 1e+9) exp += 4, d *= 1e-4;
292      if (d >= 1e+7) exp += 2, d *= 1e-2;
293      if (d >= 1e+6) exp += 1, d *= 1e-1;
294    } else {
295      if (d < 1e-250) exp -= 256, d *= 1e256;
296      if (d < 1e-122) exp -= 128, d *= 1e128;
297      if (d < 1e-58) exp -= 64, d *= 1e64;
298      if (d < 1e-26) exp -= 32, d *= 1e32;
299      if (d < 1e-10) exp -= 16, d *= 1e16;
300      if (d < 1e-2) exp -= 8, d *= 1e8;
301      if (d < 1e+2) exp -= 4, d *= 1e4;
302      if (d < 1e+4) exp -= 2, d *= 1e2;
303      if (d < 1e+5) exp -= 1, d *= 1e1;
304    }
305    uint64_t d64k = d * 65536;
306    uint32_t dddddd;  
307    if ((d64k % 65536) == 32767 || (d64k % 65536) == 32768) {
308      dddddd = static_cast<uint32_t>(d64k / 65536);
309      int exp2;
310      double m = std::frexp(value, &exp2);
311      uint64_t mantissa = m * (32768.0 * 65536.0 * 65536.0 * 65536.0);
312      mantissa <<= 1;
313      exp2 -= 64;  
314      std::pair<uint64_t, uint64_t> edge, val;
315      if (exp >= 6) {
316        edge = PowFive(2 * dddddd + 1, exp - 5);
317        val.first = mantissa;
318        val.second = 0;
319      } else {
320        edge = PowFive(2 * dddddd + 1, 0);
321        val = PowFive(mantissa, 5 - exp);
322      }
323      if (val > edge) {
324        dddddd++;
325      } else if (val == edge) {
326        dddddd += (dddddd & 1);
327      }
328    } else {
329      dddddd = static_cast<uint32_t>((d64k + 32768) / 65536);
330    }
331    if (dddddd == 1000000) {
332      dddddd = 100000;
333      exp += 1;
334    }
335    exp_dig.exponent = exp;
336    uint32_t two_digits = dddddd / 10000;
337    dddddd -= two_digits * 10000;
338    numbers_internal::PutTwoDigits(two_digits, &exp_dig.digits[0]);
339    two_digits = dddddd / 100;
340    dddddd -= two_digits * 100;
341    numbers_internal::PutTwoDigits(two_digits, &exp_dig.digits[2]);
342    numbers_internal::PutTwoDigits(dddddd, &exp_dig.digits[4]);
343    return exp_dig;
344  }
345  size_t numbers_internal::SixDigitsToBuffer(double d, char* const buffer) {
346    static_assert(std::numeric_limits<float>::is_iec559,
347                  "IEEE-754/IEC-559 support only");
348    char* out = buffer;  
349    if (std::isnan(d)) {
350      strcpy(out, "nan");  
351      return 3;
352    }
353    if (d == 0) {  
354      if (std::signbit(d)) *out++ = '-';
355      *out++ = '0';
356      *out = 0;
357      return static_cast<size_t>(out - buffer);
358    }
359    if (d < 0) {
360      *out++ = '-';
361      d = -d;
362    }
363    if (d > std::numeric_limits<double>::max()) {
364      strcpy(out, "inf");  
365      return static_cast<size_t>(out + 3 - buffer);
366    }
367    auto exp_dig = SplitToSix(d);
368    int exp = exp_dig.exponent;
369    const char* digits = exp_dig.digits;
370    out[0] = '0';
371    out[1] = '.';
372    switch (exp) {
373      case 5:
374        memcpy(out, &digits[0], 6), out += 6;
375        *out = 0;
376        return static_cast<size_t>(out - buffer);
377      case 4:
378        memcpy(out, &digits[0], 5), out += 5;
379        if (digits[5] != '0') {
380          *out++ = '.';
381          *out++ = digits[5];
382        }
383        *out = 0;
384        return static_cast<size_t>(out - buffer);
385      case 3:
386        memcpy(out, &digits[0], 4), out += 4;
387        if ((digits[5] | digits[4]) != '0') {
388          *out++ = '.';
389          *out++ = digits[4];
390          if (digits[5] != '0') *out++ = digits[5];
391        }
392        *out = 0;
393        return static_cast<size_t>(out - buffer);
394      case 2:
395        memcpy(out, &digits[0], 3), out += 3;
396        *out++ = '.';
397        memcpy(out, &digits[3], 3);
398        out += 3;
399        while (out[-1] == '0') --out;
400        if (out[-1] == '.') --out;
401        *out = 0;
402        return static_cast<size_t>(out - buffer);
403      case 1:
404        memcpy(out, &digits[0], 2), out += 2;
405        *out++ = '.';
406        memcpy(out, &digits[2], 4);
407        out += 4;
408        while (out[-1] == '0') --out;
409        if (out[-1] == '.') --out;
410        *out = 0;
411        return static_cast<size_t>(out - buffer);
412      case 0:
413        memcpy(out, &digits[0], 1), out += 1;
414        *out++ = '.';
415        memcpy(out, &digits[1], 5);
416        out += 5;
417        while (out[-1] == '0') --out;
418        if (out[-1] == '.') --out;
419        *out = 0;
420        return static_cast<size_t>(out - buffer);
421      case -4:
422        out[2] = '0';
423        ++out;
424        ABSL_FALLTHROUGH_INTENDED;
425      case -3:
426        out[2] = '0';
427        ++out;
428        ABSL_FALLTHROUGH_INTENDED;
429      case -2:
430        out[2] = '0';
431        ++out;
432        ABSL_FALLTHROUGH_INTENDED;
433      case -1:
434        out += 2;
435        memcpy(out, &digits[0], 6);
436        out += 6;
437        while (out[-1] == '0') --out;
438        *out = 0;
439        return static_cast<size_t>(out - buffer);
440    }
441    assert(exp < -4 || exp >= 6);
442    out[0] = digits[0];
443    assert(out[1] == '.');
444    out += 2;
445    memcpy(out, &digits[1], 5), out += 5;
446    while (out[-1] == '0') --out;
447    if (out[-1] == '.') --out;
448    *out++ = 'e';
449    if (exp > 0) {
450      *out++ = '+';
451    } else {
452      *out++ = '-';
453      exp = -exp;
454    }
455    if (exp > 99) {
456      int dig1 = exp / 100;
457      exp -= dig1 * 100;
458      *out++ = '0' + static_cast<char>(dig1);
459    }
460    PutTwoDigits(static_cast<uint32_t>(exp), out);
461    out += 2;
462    *out = 0;
463    return static_cast<size_t>(out - buffer);
464  }
465  namespace {
466  static const int8_t kAsciiToInt[256] = {
467      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  
468      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
469      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 0,  1,  2,  3,  4,  5,
470      6,  7,  8,  9,  36, 36, 36, 36, 36, 36, 36, 10, 11, 12, 13, 14, 15, 16, 17,
471      18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
472      36, 36, 36, 36, 36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
473      24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36, 36, 36,
474      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
475      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
476      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
477      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
478      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
479      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
480      36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36};
<span onclick='openModal()' class='match'>481  inline bool safe_parse_sign_and_base(absl::string_view* text &bsol;*inout*/,
482                                       int* base_ptr &bsol;*inout*/,
483                                       bool* negative_ptr &bsol;*output*/) {
484    if (text->data() == nullptr) {
485      return false;
486    }
487    const char* start = text->data();
488    const char* end = start + text->size();
489    int base = *base_ptr;
</span>490    while (start < end &&
491           absl::ascii_isspace(static_cast<unsigned char>(start[0]))) {
492      ++start;
493    }
494    while (start < end &&
495           absl::ascii_isspace(static_cast<unsigned char>(end[-1]))) {
496      --end;
497    }
498    if (start >= end) {
499      return false;
500    }
501    *negative_ptr = (start[0] == '-');
502    if (*negative_ptr || start[0] == '+') {
503      ++start;
504      if (start >= end) {
505        return false;
506      }
507    }
508    if (base == 0) {
509      if (end - start >= 2 && start[0] == '0' &&
510          (start[1] == 'x' || start[1] == 'X')) {
511        base = 16;
512        start += 2;
513        if (start >= end) {
514          return false;
515        }
516      } else if (end - start >= 1 && start[0] == '0') {
517        base = 8;
518        start += 1;
519      } else {
520        base = 10;
521      }
522    } else if (base == 16) {
523      if (end - start >= 2 && start[0] == '0' &&
524          (start[1] == 'x' || start[1] == 'X')) {
525        start += 2;
526        if (start >= end) {
527          return false;
528        }
529      }
530    } else if (base >= 2 && base <= 36) {
531    } else {
532      return false;
533    }
534    *text = absl::string_view(start, static_cast<size_t>(end - start));
535    *base_ptr = base;
536    return true;
537  }
538  template <typename IntType>
539  struct LookupTables {
540    ABSL_CONST_INIT static const IntType kVmaxOverBase[];
541    ABSL_CONST_INIT static const IntType kVminOverBase[];
542  };
543  #define X_OVER_BASE_INITIALIZER(X)                                        \
544    {                                                                       \
545      0, 0, X / 2, X / 3, X / 4, X / 5, X / 6, X / 7, X / 8, X / 9, X / 10, \
546          X / 11, X / 12, X / 13, X / 14, X / 15, X / 16, X / 17, X / 18,   \
547          X / 19, X / 20, X / 21, X / 22, X / 23, X / 24, X / 25, X / 26,   \
548          X / 27, X / 28, X / 29, X / 30, X / 31, X / 32, X / 33, X / 34,   \
549          X / 35, X / 36,                                                   \
550    }
551  template <>
552  ABSL_CONST_INIT const uint128 LookupTables<uint128>::kVmaxOverBase[] = {
553      0,
554      0,
555      MakeUint128(9223372036854775807u, 18446744073709551615u),
556      MakeUint128(6148914691236517205u, 6148914691236517205u),
557      MakeUint128(4611686018427387903u, 18446744073709551615u),
558      MakeUint128(3689348814741910323u, 3689348814741910323u),
559      MakeUint128(3074457345618258602u, 12297829382473034410u),
560      MakeUint128(2635249153387078802u, 5270498306774157604u),
561      MakeUint128(2305843009213693951u, 18446744073709551615u),
562      MakeUint128(2049638230412172401u, 14347467612885206812u),
563      MakeUint128(1844674407370955161u, 11068046444225730969u),
564      MakeUint128(1676976733973595601u, 8384883669867978007u),
565      MakeUint128(1537228672809129301u, 6148914691236517205u),
566      MakeUint128(1418980313362273201u, 4256940940086819603u),
567      MakeUint128(1317624576693539401u, 2635249153387078802u),
568      MakeUint128(1229782938247303441u, 1229782938247303441u),
569      MakeUint128(1152921504606846975u, 18446744073709551615u),
570      MakeUint128(1085102592571150095u, 1085102592571150095u),
571      MakeUint128(1024819115206086200u, 16397105843297379214u),
572      MakeUint128(970881267037344821u, 16504981539634861972u),
573      MakeUint128(922337203685477580u, 14757395258967641292u),
574      MakeUint128(878416384462359600u, 14054662151397753612u),
575      MakeUint128(838488366986797800u, 13415813871788764811u),
576      MakeUint128(802032351030850070u, 4812194106185100421u),
577      MakeUint128(768614336404564650u, 12297829382473034410u),
578      MakeUint128(737869762948382064u, 11805916207174113034u),
579      MakeUint128(709490156681136600u, 11351842506898185609u),
580      MakeUint128(683212743470724133u, 17080318586768103348u),
581      MakeUint128(658812288346769700u, 10540996613548315209u),
582      MakeUint128(636094623231363848u, 15266270957552732371u),
583      MakeUint128(614891469123651720u, 9838263505978427528u),
584      MakeUint128(595056260442243600u, 9520900167075897608u),
585      MakeUint128(576460752303423487u, 18446744073709551615u),
586      MakeUint128(558992244657865200u, 8943875914525843207u),
587      MakeUint128(542551296285575047u, 9765923333140350855u),
588      MakeUint128(527049830677415760u, 8432797290838652167u),
589      MakeUint128(512409557603043100u, 8198552921648689607u),
590  };
591  template <>
592  ABSL_CONST_INIT const int128 LookupTables<int128>::kVmaxOverBase[] = {
593      0,
594      0,
595      MakeInt128(4611686018427387903, 18446744073709551615u),
596      MakeInt128(3074457345618258602, 12297829382473034410u),
597      MakeInt128(2305843009213693951, 18446744073709551615u),
598      MakeInt128(1844674407370955161, 11068046444225730969u),
599      MakeInt128(1537228672809129301, 6148914691236517205u),
600      MakeInt128(1317624576693539401, 2635249153387078802u),
601      MakeInt128(1152921504606846975, 18446744073709551615u),
602      MakeInt128(1024819115206086200, 16397105843297379214u),
603      MakeInt128(922337203685477580, 14757395258967641292u),
604      MakeInt128(838488366986797800, 13415813871788764811u),
605      MakeInt128(768614336404564650, 12297829382473034410u),
606      MakeInt128(709490156681136600, 11351842506898185609u),
607      MakeInt128(658812288346769700, 10540996613548315209u),
608      MakeInt128(614891469123651720, 9838263505978427528u),
609      MakeInt128(576460752303423487, 18446744073709551615u),
610      MakeInt128(542551296285575047, 9765923333140350855u),
611      MakeInt128(512409557603043100, 8198552921648689607u),
612      MakeInt128(485440633518672410, 17475862806672206794u),
613      MakeInt128(461168601842738790, 7378697629483820646u),
614      MakeInt128(439208192231179800, 7027331075698876806u),
615      MakeInt128(419244183493398900, 6707906935894382405u),
616      MakeInt128(401016175515425035, 2406097053092550210u),
617      MakeInt128(384307168202282325, 6148914691236517205u),
618      MakeInt128(368934881474191032, 5902958103587056517u),
619      MakeInt128(354745078340568300, 5675921253449092804u),
620      MakeInt128(341606371735362066, 17763531330238827482u),
621      MakeInt128(329406144173384850, 5270498306774157604u),
622      MakeInt128(318047311615681924, 7633135478776366185u),
623      MakeInt128(307445734561825860, 4919131752989213764u),
624      MakeInt128(297528130221121800, 4760450083537948804u),
625      MakeInt128(288230376151711743, 18446744073709551615u),
626      MakeInt128(279496122328932600, 4471937957262921603u),
627      MakeInt128(271275648142787523, 14106333703424951235u),
628      MakeInt128(263524915338707880, 4216398645419326083u),
629      MakeInt128(256204778801521550, 4099276460824344803u),
630  };
631  template <>
632  ABSL_CONST_INIT const int128 LookupTables<int128>::kVminOverBase[] = {
633      0,
634      0,
635      MakeInt128(-4611686018427387904, 0u),
636      MakeInt128(-3074457345618258603, 6148914691236517206u),
637      MakeInt128(-2305843009213693952, 0u),
638      MakeInt128(-1844674407370955162, 7378697629483820647u),
639      MakeInt128(-1537228672809129302, 12297829382473034411u),
640      MakeInt128(-1317624576693539402, 15811494920322472814u),
641      MakeInt128(-1152921504606846976, 0u),
642      MakeInt128(-1024819115206086201, 2049638230412172402u),
643      MakeInt128(-922337203685477581, 3689348814741910324u),
644      MakeInt128(-838488366986797801, 5030930201920786805u),
645      MakeInt128(-768614336404564651, 6148914691236517206u),
646      MakeInt128(-709490156681136601, 7094901566811366007u),
647      MakeInt128(-658812288346769701, 7905747460161236407u),
648      MakeInt128(-614891469123651721, 8608480567731124088u),
649      MakeInt128(-576460752303423488, 0u),
650      MakeInt128(-542551296285575048, 8680820740569200761u),
651      MakeInt128(-512409557603043101, 10248191152060862009u),
652      MakeInt128(-485440633518672411, 970881267037344822u),
653      MakeInt128(-461168601842738791, 11068046444225730970u),
654      MakeInt128(-439208192231179801, 11419412998010674810u),
655      MakeInt128(-419244183493398901, 11738837137815169211u),
656      MakeInt128(-401016175515425036, 16040647020617001406u),
657      MakeInt128(-384307168202282326, 12297829382473034411u),
658      MakeInt128(-368934881474191033, 12543785970122495099u),
659      MakeInt128(-354745078340568301, 12770822820260458812u),
660      MakeInt128(-341606371735362067, 683212743470724134u),
661      MakeInt128(-329406144173384851, 13176245766935394012u),
662      MakeInt128(-318047311615681925, 10813608594933185431u),
663      MakeInt128(-307445734561825861, 13527612320720337852u),
664      MakeInt128(-297528130221121801, 13686293990171602812u),
665      MakeInt128(-288230376151711744, 0u),
666      MakeInt128(-279496122328932601, 13974806116446630013u),
667      MakeInt128(-271275648142787524, 4340410370284600381u),
668      MakeInt128(-263524915338707881, 14230345428290225533u),
669      MakeInt128(-256204778801521551, 14347467612885206813u),
670  };
671  template <typename IntType>
672  ABSL_CONST_INIT const IntType LookupTables<IntType>::kVmaxOverBase[] =
673      X_OVER_BASE_INITIALIZER(std::numeric_limits<IntType>::max());
674  template <typename IntType>
675  ABSL_CONST_INIT const IntType LookupTables<IntType>::kVminOverBase[] =
676      X_OVER_BASE_INITIALIZER(std::numeric_limits<IntType>::min());
677  #undef X_OVER_BASE_INITIALIZER
678  template <typename IntType>
679  inline bool safe_parse_positive_int(absl::string_view text, int base,
680                                      IntType* value_p) {
681    IntType value = 0;
682    const IntType vmax = std::numeric_limits<IntType>::max();
683    assert(vmax > 0);
684    assert(base >= 0);
685    const IntType base_inttype = static_cast<IntType>(base);
686    assert(vmax >= base_inttype);
687    const IntType vmax_over_base = LookupTables<IntType>::kVmaxOverBase[base];
688    assert(base < 2 ||
689           std::numeric_limits<IntType>::max() / base_inttype == vmax_over_base);
690    const char* start = text.data();
691    const char* end = start + text.size();
692    for (; start < end; ++start) {
693      unsigned char c = static_cast<unsigned char>(start[0]);
694      IntType digit = static_cast<IntType>(kAsciiToInt[c]);
695      if (digit >= base_inttype) {
696        *value_p = value;
697        return false;
698      }
699      if (value > vmax_over_base) {
700        *value_p = vmax;
701        return false;
702      }
703      value *= base_inttype;
704      if (value > vmax - digit) {
705        *value_p = vmax;
706        return false;
707      }
708      value += digit;
709    }
710    *value_p = value;
711    return true;
712  }
713  template <typename IntType>
714  inline bool safe_parse_negative_int(absl::string_view text, int base,
715                                      IntType* value_p) {
716    IntType value = 0;
717    const IntType vmin = std::numeric_limits<IntType>::min();
718    assert(vmin < 0);
719    assert(vmin <= 0 - base);
720    IntType vmin_over_base = LookupTables<IntType>::kVminOverBase[base];
721    assert(base < 2 ||
722           std::numeric_limits<IntType>::min() / base == vmin_over_base);
723    if (vmin % base > 0) {
724      vmin_over_base += 1;
725    }
726    const char* start = text.data();
727    const char* end = start + text.size();
728    for (; start < end; ++start) {
729      unsigned char c = static_cast<unsigned char>(start[0]);
730      int digit = kAsciiToInt[c];
731      if (digit >= base) {
732        *value_p = value;
733        return false;
734      }
735      if (value < vmin_over_base) {
736        *value_p = vmin;
737        return false;
738      }
739      value *= base;
740      if (value < vmin + digit) {
741        *value_p = vmin;
742        return false;
743      }
744      value -= digit;
745    }
746    *value_p = value;
747    return true;
748  }
749  template <typename IntType>
750  inline bool safe_int_internal(absl::string_view text, IntType* value_p,
751                                int base) {
752    *value_p = 0;
753    bool negative;
754    if (!safe_parse_sign_and_base(&text, &base, &negative)) {
755      return false;
756    }
757    if (!negative) {
758      return safe_parse_positive_int(text, base, value_p);
759    } else {
760      return safe_parse_negative_int(text, base, value_p);
761    }
762  }
763  template <typename IntType>
764  inline bool safe_uint_internal(absl::string_view text, IntType* value_p,
765                                 int base) {
766    *value_p = 0;
767    bool negative;
768    if (!safe_parse_sign_and_base(&text, &base, &negative) || negative) {
769      return false;
770    }
771    return safe_parse_positive_int(text, base, value_p);
772  }
773  }  
774  namespace numbers_internal {
775  ABSL_CONST_INIT ABSL_DLL const char kHexChar[] =
776      "0123456789abcdef";
777  ABSL_CONST_INIT ABSL_DLL const char kHexTable[513] =
778      "000102030405060708090a0b0c0d0e0f"
779      "101112131415161718191a1b1c1d1e1f"
780      "202122232425262728292a2b2c2d2e2f"
781      "303132333435363738393a3b3c3d3e3f"
782      "404142434445464748494a4b4c4d4e4f"
783      "505152535455565758595a5b5c5d5e5f"
784      "606162636465666768696a6b6c6d6e6f"
785      "707172737475767778797a7b7c7d7e7f"
786      "808182838485868788898a8b8c8d8e8f"
787      "909192939495969798999a9b9c9d9e9f"
788      "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
789      "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
790      "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
791      "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
792      "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
793      "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
794  bool safe_strto32_base(absl::string_view text, int32_t* value, int base) {
795    return safe_int_internal<int32_t>(text, value, base);
796  }
797  bool safe_strto64_base(absl::string_view text, int64_t* value, int base) {
798    return safe_int_internal<int64_t>(text, value, base);
799  }
800  bool safe_strto128_base(absl::string_view text, int128* value, int base) {
801    return safe_int_internal<absl::int128>(text, value, base);
802  }
803  bool safe_strtou32_base(absl::string_view text, uint32_t* value, int base) {
804    return safe_uint_internal<uint32_t>(text, value, base);
805  }
806  bool safe_strtou64_base(absl::string_view text, uint64_t* value, int base) {
807    return safe_uint_internal<uint64_t>(text, value, base);
808  }
809  bool safe_strtou128_base(absl::string_view text, uint128* value, int base) {
810    return safe_uint_internal<absl::uint128>(text, value, base);
811  }
812  }  
813  ABSL_NAMESPACE_END
814  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tagcloud.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers.cc</div>
                </div>
                <div class="column column_space"><pre><code>2  PTagCloud TTagCloud::GetFromDocStrWgtPrV(const TStrFltPrV& DocStrWgtPrV, 
3   const int& TopWords=25, const double& TopWordsWgtSumPrc=1.0){
4    PTagCloud TagCloud=TTagCloud::New();
5    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
6    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
</pre></code></div>
                <div class="column column_space"><pre><code>481  inline bool safe_parse_sign_and_base(absl::string_view* text &bsol;*inout*/,
482                                       int* base_ptr &bsol;*inout*/,
483                                       bool* negative_ptr &bsol;*output*/) {
484    if (text->data() == nullptr) {
485      return false;
486    }
487    const char* start = text->data();
488    const char* end = start + text->size();
489    int base = *base_ptr;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    