
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.031446540880504%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-symbolize_test.cc</h3>
            <pre><code>1  #include "absl/debugging/symbolize.h"
2  #ifndef _WIN32
3  #include <fcntl.h>
4  #include <sys/mman.h>
5  #endif
6  #include <cstring>
7  #include <iostream>
8  #include <memory>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/casts.h"
13  #include "absl/base/config.h"
14  #include "absl/base/internal/per_thread_tls.h"
15  #include "absl/base/optimization.h"
16  #include "absl/debugging/internal/stack_consumption.h"
17  #include "absl/log/check.h"
18  #include "absl/log/log.h"
19  #include "absl/memory/memory.h"
20  #include "absl/strings/string_view.h"
21  using testing::Contains;
22  #ifdef _WIN32
23  #define ABSL_SYMBOLIZE_TEST_NOINLINE __declspec(noinline)
24  #else
25  #define ABSL_SYMBOLIZE_TEST_NOINLINE ABSL_ATTRIBUTE_NOINLINE
26  #endif
27  extern "C" {
28  ABSL_SYMBOLIZE_TEST_NOINLINE void nonstatic_func() {
29    volatile int x = __LINE__;
30    static_cast<void>(x);
31    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
32  }
33  ABSL_SYMBOLIZE_TEST_NOINLINE static void static_func() {
34    volatile int x = __LINE__;
35    static_cast<void>(x);
36    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
37  }
38  }  
39  struct Foo {
40    static void func(int x);
41  };
42  ABSL_SYMBOLIZE_TEST_NOINLINE void Foo::func(int) {
43    volatile int x = __LINE__;
44    static_cast<void>(x);
45    ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
46  }
47  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.unlikely) unlikely_func() {
48    return 0;
49  }
50  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.hot) hot_func() {
51    return 0;
52  }
53  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.startup) startup_func() {
54    return 0;
55  }
56  int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.exit) exit_func() {
57    return 0;
58  }
59  int &bsol;*ABSL_ATTRIBUTE_SECTION_VARIABLE(.text)*/ regular_func() {
60    return 0;
61  }
62  #if ABSL_PER_THREAD_TLS
63  static ABSL_PER_THREAD_TLS_KEYWORD char symbolize_test_thread_small[1];
64  static ABSL_PER_THREAD_TLS_KEYWORD char
65      symbolize_test_thread_big[2 * 1024 * 1024];
66  #endif
67  #if !defined(__EMSCRIPTEN__)
68  static volatile bool volatile_bool = false;
69  static constexpr size_t kHpageSize = 1 << 21;
70  const char kHpageTextPadding[kHpageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(
71      .text) = "";
72  #endif  
73  static char try_symbolize_buffer[4096];
74  static const char *TrySymbolizeWithLimit(void *pc, int limit) {
75    CHECK_LE(limit, sizeof(try_symbolize_buffer))
76        << "try_symbolize_buffer is too small";
77    auto heap_buffer = absl::make_unique<char[]>(sizeof(try_symbolize_buffer));
78    bool found = absl::Symbolize(pc, heap_buffer.get(), limit);
79    if (found) {
80      CHECK_LT(static_cast<int>(
81                   strnlen(heap_buffer.get(), static_cast<size_t>(limit))),
82               limit)
83          << "absl::Symbolize() did not properly terminate the string";
84      strncpy(try_symbolize_buffer, heap_buffer.get(),
85              sizeof(try_symbolize_buffer) - 1);
86      try_symbolize_buffer[sizeof(try_symbolize_buffer) - 1] = '\0';
87    }
88    return found ? try_symbolize_buffer : nullptr;
89  }
90  static const char *TrySymbolize(void *pc) {
91    return TrySymbolizeWithLimit(pc, sizeof(try_symbolize_buffer));
92  }
93  #if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) ||    \
94      defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE) || \
95      defined(ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE)
96  void ABSL_ATTRIBUTE_NOINLINE TestWithReturnAddress() {
97  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
98    void *return_address = __builtin_return_address(0);
99    const char *symbol = TrySymbolize(return_address);
100    CHECK_NE(symbol, nullptr) << "TestWithReturnAddress failed";
101    CHECK_STREQ(symbol, "main") << "TestWithReturnAddress failed";
102    std::cout << "TestWithReturnAddress passed" << std::endl;
103  #endif
104  }
105  #ifndef ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE
106  TEST(Symbolize, Cached) {
107    EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));
108    const char *static_func_symbol = TrySymbolize((void *)(&static_func));
109    EXPECT_TRUE(strcmp("static_func", static_func_symbol) == 0 ||
110                strcmp("static_func()", static_func_symbol) == 0);
111    EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
112  }
113  TEST(Symbolize, Truncation) {
114    constexpr char kNonStaticFunc[] = "nonstatic_func";
115    EXPECT_STREQ("nonstatic_func",
116                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
117                                       strlen(kNonStaticFunc) + 1));
118    EXPECT_STREQ("nonstatic_...",
119                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
120                                       strlen(kNonStaticFunc) + 0));
121    EXPECT_STREQ("nonstatic...",
122                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
123                                       strlen(kNonStaticFunc) - 1));
124    EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
125    EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
126    EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
127    EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
128    EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
129    EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
130  }
131  TEST(Symbolize, SymbolizeWithDemangling) {
132    Foo::func(100);
133    EXPECT_STREQ("Foo::func()", TrySymbolize((void *)(&Foo::func)));
134  }
135  TEST(Symbolize, SymbolizeSplitTextSections) {
136    EXPECT_STREQ("unlikely_func()", TrySymbolize((void *)(&unlikely_func)));
137    EXPECT_STREQ("hot_func()", TrySymbolize((void *)(&hot_func)));
138    EXPECT_STREQ("startup_func()", TrySymbolize((void *)(&startup_func)));
139    EXPECT_STREQ("exit_func()", TrySymbolize((void *)(&exit_func)));
140    EXPECT_STREQ("regular_func()", TrySymbolize((void *)(&regular_func)));
141  }
142  #ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
143  static void *g_pc_to_symbolize;
144  static char g_symbolize_buffer[4096];
145  static char *g_symbolize_result;
146  static void SymbolizeSignalHandler(int signo) {
147    if (absl::Symbolize(g_pc_to_symbolize, g_symbolize_buffer,
148                        sizeof(g_symbolize_buffer))) {
149      g_symbolize_result = g_symbolize_buffer;
150    } else {
151      g_symbolize_result = nullptr;
152    }
153  }
154  static const char *SymbolizeStackConsumption(void *pc, int *stack_consumed) {
155    g_pc_to_symbolize = pc;
156    *stack_consumed = absl::debugging_internal::GetSignalHandlerStackConsumption(
157        SymbolizeSignalHandler);
158    return g_symbolize_result;
159  }
160  static int GetStackConsumptionUpperLimit() {
161    int stack_consumption_upper_limit = 2048;
162  #if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
163      defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
164    stack_consumption_upper_limit *= 5;
165  #endif
166    return stack_consumption_upper_limit;
167  }
168  TEST(Symbolize, SymbolizeStackConsumption) {
169    int stack_consumed = 0;
170    const char *symbol =
171        SymbolizeStackConsumption((void *)(&nonstatic_func), &stack_consumed);
172    EXPECT_STREQ("nonstatic_func", symbol);
173    EXPECT_GT(stack_consumed, 0);
174    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
175    symbol = SymbolizeStackConsumption((void *)(&static_func), &stack_consumed);
176    EXPECT_TRUE(strcmp("static_func", symbol) == 0 ||
177                strcmp("static_func()", symbol) == 0);
178    EXPECT_GT(stack_consumed, 0);
179    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
180  }
181  TEST(Symbolize, SymbolizeWithDemanglingStackConsumption) {
182    Foo::func(100);
183    int stack_consumed = 0;
184    const char *symbol =
185        SymbolizeStackConsumption((void *)(&Foo::func), &stack_consumed);
186    EXPECT_STREQ("Foo::func()", symbol);
187    EXPECT_GT(stack_consumed, 0);
188    EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
189  }
190  #endif  
191  #ifndef ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
192  const size_t kPageSize = 64 << 10;
193  const char kPadding0[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) =
194      "";
195  const char kPadding1[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) =
196      "";
197  static int FilterElfHeader(struct dl_phdr_info *info, size_t size, void *data) {
198    for (int i = 0; i < info->dlpi_phnum; i++) {
199      if (info->dlpi_phdr[i].p_type == PT_LOAD &&
200          info->dlpi_phdr[i].p_flags == (PF_R | PF_X)) {
201        const void *const vaddr =
202            absl::bit_cast<void *>(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);
203        const auto segsize = info->dlpi_phdr[i].p_memsz;
204        const char *self_exe;
205        if (info->dlpi_name != nullptr && info->dlpi_name[0] != '\0') {
206          self_exe = info->dlpi_name;
207        } else {
208          self_exe = "/proc/self/exe";
209        }
210        absl::debugging_internal::RegisterFileMappingHint(
211            vaddr, reinterpret_cast<const char *>(vaddr) + segsize,
212            info->dlpi_phdr[i].p_offset, self_exe);
213        return 1;
214      }
215    }
216    return 1;
217  }
218  TEST(Symbolize, SymbolizeWithMultipleMaps) {
219    if (volatile_bool) {
220      LOG(INFO) << kPadding0;
221      LOG(INFO) << kPadding1;
222    }
223    char buf[512];
224    memset(buf, 0, sizeof(buf));
225    absl::Symbolize(kPadding0, buf, sizeof(buf));
226    EXPECT_STREQ("kPadding0", buf);
227    memset(buf, 0, sizeof(buf));
228    absl::Symbolize(kPadding1, buf, sizeof(buf));
229    EXPECT_STREQ("kPadding1", buf);
230    dl_iterate_phdr(FilterElfHeader, nullptr);
231    const char *ptrs[] = {kPadding0, kPadding1};
232    for (const char *ptr : ptrs) {
233      const int kMapFlags = MAP_ANONYMOUS | MAP_PRIVATE;
234      void *addr = mmap(nullptr, kPageSize, PROT_READ, kMapFlags, 0, 0);
235      ASSERT_NE(addr, MAP_FAILED);
236      void *remapped = reinterpret_cast<void *>(
237          reinterpret_cast<uintptr_t>(ptr + kPageSize) & ~(kPageSize - 1ULL));
238      const int kMremapFlags = (MREMAP_MAYMOVE | MREMAP_FIXED);
239      void *ret = mremap(addr, kPageSize, kPageSize, kMremapFlags, remapped);
240      ASSERT_NE(ret, MAP_FAILED);
241    }
242    absl::Symbolize(nullptr, buf, sizeof(buf));
243    const char *expected[] = {"kPadding0", "kPadding1"};
244    const size_t offsets[] = {0, kPageSize, 2 * kPageSize, 3 * kPageSize};
245    for (int i = 0; i < 2; i++) {
246      for (size_t offset : offsets) {
247        memset(buf, 0, sizeof(buf));
248        absl::Symbolize(ptrs[i] + offset, buf, sizeof(buf));
249        EXPECT_STREQ(expected[i], buf);
250      }
251    }
252  }
253  static void DummySymbolDecorator(
254      const absl::debugging_internal::SymbolDecoratorArgs *args) {
255    std::string *message = static_cast<std::string *>(args->arg);
256    strncat(args->symbol_buf, message->c_str(),
257            args->symbol_buf_size - strlen(args->symbol_buf) - 1);
258  }
259  TEST(Symbolize, InstallAndRemoveSymbolDecorators) {
260    int ticket_a;
261    std::string a_message("a");
262    EXPECT_GE(ticket_a = absl::debugging_internal::InstallSymbolDecorator(
263                  DummySymbolDecorator, &a_message),
264              0);
265    int ticket_b;
266    std::string b_message("b");
267    EXPECT_GE(ticket_b = absl::debugging_internal::InstallSymbolDecorator(
268                  DummySymbolDecorator, &b_message),
269              0);
270    int ticket_c;
271    std::string c_message("c");
272    EXPECT_GE(ticket_c = absl::debugging_internal::InstallSymbolDecorator(
273                  DummySymbolDecorator, &c_message),
274              0);
275    char *address = reinterpret_cast<char *>(4);
276    EXPECT_STREQ("abc", TrySymbolize(address));
277    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_b));
278    EXPECT_STREQ("ac", TrySymbolize(address + 4));
279    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_a));
280    EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_c));
281  }
282  static int in_data_section = 1;
283  TEST(Symbolize, ForEachSection) {
284    int fd = TEMP_FAILURE_RETRY(open("/proc/self/exe", O_RDONLY));
285    ASSERT_NE(fd, -1);
286    std::vector<std::string> sections;
287    ASSERT_TRUE(absl::debugging_internal::ForEachSection(
288        fd, [&sections](const absl::string_view name, const ElfW(Shdr) &) {
289          sections.emplace_back(name);
290          return true;
291        }));
292    EXPECT_THAT(sections, Contains(".text"));
293    EXPECT_THAT(sections, Contains(".rodata"));
294    EXPECT_THAT(sections, Contains(".bss"));
295    ++in_data_section;
296    EXPECT_THAT(sections, Contains(".data"));
297    close(fd);
298  }
299  #endif  
300  #endif  
301  extern "C" {
302  inline void *ABSL_ATTRIBUTE_ALWAYS_INLINE inline_func() {
303    void *pc = nullptr;
304  #if defined(__i386__)
305    __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [ PC ] "=r"(pc));
306  #elif defined(__x86_64__)
307    __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [ PC ] "=r"(pc));
308  #endif
309    return pc;
310  }
311  void *ABSL_ATTRIBUTE_NOINLINE non_inline_func() {
312    void *pc = nullptr;
313  #if defined(__i386__)
314    __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [ PC ] "=r"(pc));
315  #elif defined(__x86_64__)
316    __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [ PC ] "=r"(pc));
317  #endif
318    return pc;
319  }
320  void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideNonInlineFunction() {
321  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE) && \
322      (defined(__i386__) || defined(__x86_64__))
323    void *pc = non_inline_func();
324    const char *symbol = TrySymbolize(pc);
325    CHECK_NE(symbol, nullptr) << "TestWithPCInsideNonInlineFunction failed";
326    CHECK_STREQ(symbol, "non_inline_func")
327        << "TestWithPCInsideNonInlineFunction failed";
328    std::cout << "TestWithPCInsideNonInlineFunction passed" << std::endl;
329  #endif
330  }
331  void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideInlineFunction() {
332  #if defined(ABSL_HAVE_ATTRIBUTE_ALWAYS_INLINE) && \
333      (defined(__i386__) || defined(__x86_64__))
334    void *pc = inline_func();  
335    const char *symbol = TrySymbolize(pc);
336    CHECK_NE(symbol, nullptr) << "TestWithPCInsideInlineFunction failed";
337    CHECK_STREQ(symbol, __FUNCTION__) << "TestWithPCInsideInlineFunction failed";
338    std::cout << "TestWithPCInsideInlineFunction passed" << std::endl;
339  #endif
340  }
341  }
342  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
343      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
344  __attribute__((target("thumb"))) int ArmThumbOverlapThumb(int x) {
345    return x * x * x;
346  }
347  __attribute__((target("arm"))) int ArmThumbOverlapArm(int x) {
348    return x * x * x;
349  }
350  void ABSL_ATTRIBUTE_NOINLINE TestArmThumbOverlap() {
351  #if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
352    const char *symbol = TrySymbolize((void *)&ArmThumbOverlapArm);
353    CHECK_NE(symbol, nullptr) << "TestArmThumbOverlap failed";
354    CHECK_STREQ("ArmThumbOverlapArm()", symbol) << "TestArmThumbOverlap failed";
355    std::cout << "TestArmThumbOverlap passed" << std::endl;
356  #endif
357  }
358  #endif  
359  #elif defined(_WIN32)
360  #if !defined(ABSL_CONSUME_DLL)
361  TEST(Symbolize, Basics) {
362    EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));
363    const char *static_func_symbol = TrySymbolize((void *)(&static_func));
364    ASSERT_TRUE(static_func_symbol != nullptr);
365    EXPECT_TRUE(strstr(static_func_symbol, "static_func") != nullptr);
366    EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
367  }
368  TEST(Symbolize, Truncation) {
369    constexpr char kNonStaticFunc[] = "nonstatic_func";
370    EXPECT_STREQ("nonstatic_func",
371                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
372                                       strlen(kNonStaticFunc) + 1));
373    EXPECT_STREQ("nonstatic_...",
374                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
375                                       strlen(kNonStaticFunc) + 0));
376    EXPECT_STREQ("nonstatic...",
377                 TrySymbolizeWithLimit((void *)(&nonstatic_func),
378                                       strlen(kNonStaticFunc) - 1));
379    EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
380    EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
381    EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
382    EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
383    EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
384    EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
385  }
386  TEST(Symbolize, SymbolizeWithDemangling) {
387    const char *result = TrySymbolize((void *)(&Foo::func));
388    ASSERT_TRUE(result != nullptr);
389    EXPECT_TRUE(strstr(result, "Foo::func") != nullptr) << result;
390  }
391  #endif  
392  #else  
<span onclick='openModal()' class='match'>393  TEST(Symbolize, Unimplemented) {
394    char buf[64];
395    EXPECT_FALSE(absl::Symbolize((void *)(&nonstatic_func), buf, sizeof(buf)));
396    EXPECT_FALSE(absl::Symbolize((void *)(&static_func), buf, sizeof(buf)));
397    EXPECT_FALSE(absl::Symbolize((void *)(&Foo::func), buf, sizeof(buf)));
</span>398  }
399  #endif
400  int main(int argc, char **argv) {
401  #if !defined(__EMSCRIPTEN__)
402    if (volatile_bool) {
403      LOG(INFO) << kHpageTextPadding;
404    }
405  #endif  
406  #if ABSL_PER_THREAD_TLS
407    symbolize_test_thread_small[0] = 0;
408    symbolize_test_thread_big[0] = 0;
409  #endif
410    absl::InitializeSymbolizer(argv[0]);
411    testing::InitGoogleTest(&argc, argv);
412  #if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) || \
413      defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE)
414    TestWithPCInsideInlineFunction();
415    TestWithPCInsideNonInlineFunction();
416    TestWithReturnAddress();
417  #if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
418      ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
419    TestArmThumbOverlap();
420  #endif
421  #endif
422    return RUN_ALL_TESTS();
423  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-crc_x86_arm_combined.cc</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdint>
3  #include "absl/base/attributes.h"
4  #include "absl/base/config.h"
5  #include "absl/base/dynamic_annotations.h"
6  #include "absl/base/internal/endian.h"
7  #include "absl/base/prefetch.h"
8  #include "absl/crc/internal/cpu_detect.h"
9  #include "absl/crc/internal/crc.h"
10  #include "absl/crc/internal/crc32_x86_arm_combined_simd.h"
11  #include "absl/crc/internal/crc_internal.h"
12  #include "absl/memory/memory.h"
13  #include "absl/numeric/bits.h"
14  #if defined(ABSL_CRC_INTERNAL_HAVE_ARM_SIMD) || \
15      defined(ABSL_CRC_INTERNAL_HAVE_X86_SIMD)
16  #define ABSL_INTERNAL_CAN_USE_SIMD_CRC32C
17  #endif
18  namespace absl {
19  ABSL_NAMESPACE_BEGIN
20  namespace crc_internal {
21  #if defined(ABSL_INTERNAL_CAN_USE_SIMD_CRC32C)
22  namespace {
23  class CRC32AcceleratedX86ARMCombined : public CRC32 {
24   public:
25    CRC32AcceleratedX86ARMCombined() {}
26    ~CRC32AcceleratedX86ARMCombined() override {}
27    void ExtendByZeroes(uint32_t* crc, size_t length) const override;
28    uint32_t ComputeZeroConstant(size_t length) const;
29   private:
30    CRC32AcceleratedX86ARMCombined(const CRC32AcceleratedX86ARMCombined&) =
31        delete;
32    CRC32AcceleratedX86ARMCombined& operator=(
33        const CRC32AcceleratedX86ARMCombined&) = delete;
34  };
35  constexpr size_t kSmallCutoff = 256;
36  constexpr size_t kMediumCutoff = 2048;
37  #define ABSL_INTERNAL_STEP1(crc)                      \
38    do {                                                \
39      crc = CRC32_u8(static_cast<uint32_t>(crc), *p++); \
40    } while (0)
41  #define ABSL_INTERNAL_STEP2(crc)                                               \
42    do {                                                                         \
43      crc =                                                                      \
44          CRC32_u16(static_cast<uint32_t>(crc), absl::little_endian::Load16(p)); \
45      p += 2;                                                                    \
46    } while (0)
47  #define ABSL_INTERNAL_STEP4(crc)                                               \
48    do {                                                                         \
49      crc =                                                                      \
50          CRC32_u32(static_cast<uint32_t>(crc), absl::little_endian::Load32(p)); \
51      p += 4;                                                                    \
52    } while (0)
53  #define ABSL_INTERNAL_STEP8(crc, data)                  \
54    do {                                                  \
55      crc = CRC32_u64(static_cast<uint32_t>(crc),         \
56                      absl::little_endian::Load64(data)); \
57      data += 8;                                          \
58    } while (0)
59  #define ABSL_INTERNAL_STEP8BY2(crc0, crc1, p0, p1) \
60    do {                                             \
61      ABSL_INTERNAL_STEP8(crc0, p0);                 \
62      ABSL_INTERNAL_STEP8(crc1, p1);                 \
63    } while (0)
64  #define ABSL_INTERNAL_STEP8BY3(crc0, crc1, crc2, p0, p1, p2) \
65    do {                                                       \
66      ABSL_INTERNAL_STEP8(crc0, p0);                           \
67      ABSL_INTERNAL_STEP8(crc1, p1);                           \
68      ABSL_INTERNAL_STEP8(crc2, p2);                           \
69    } while (0)
70  namespace {
71  uint32_t multiply(uint32_t a, uint32_t b) {
72    V128 shifts = V128_From2x64(0, 1);
73    V128 power = V128_From2x64(0, a);
74    V128 crc = V128_From2x64(0, b);
75    V128 res = V128_PMulLow(power, crc);
76    res = V128_ShiftLeft64(res, shifts);
77    return static_cast<uint32_t>(V128_Extract32<1>(res)) ^
78           CRC32_u32(0, static_cast<uint32_t>(V128_Low64(res)));
79  }
80  constexpr uint32_t kCRC32CPowers[] = {
81      0x82f63b78, 0x6ea2d55c, 0x18b8ea18, 0x510ac59a, 0xb82be955, 0xb8fdb1e7,
82      0x88e56f72, 0x74c360a4, 0xe4172b16, 0x0d65762a, 0x35d73a62, 0x28461564,
83      0xbf455269, 0xe2ea32dc, 0xfe7740e6, 0xf946610b, 0x3c204f8f, 0x538586e3,
84      0x59726915, 0x734d5309, 0xbc1ac763, 0x7d0722cc, 0xd289cabe, 0xe94ca9bc,
85      0x05b74f3f, 0xa51e1f42, 0x40000000, 0x20000000, 0x08000000, 0x00800000,
86      0x00008000, 0x82f63b78, 0x6ea2d55c, 0x18b8ea18, 0x510ac59a, 0xb82be955,
87      0xb8fdb1e7, 0x88e56f72, 0x74c360a4, 0xe4172b16, 0x0d65762a, 0x35d73a62,
88      0x28461564, 0xbf455269, 0xe2ea32dc, 0xfe7740e6, 0xf946610b, 0x3c204f8f,
89      0x538586e3, 0x59726915, 0x734d5309, 0xbc1ac763, 0x7d0722cc, 0xd289cabe,
90      0xe94ca9bc, 0x05b74f3f, 0xa51e1f42, 0x40000000, 0x20000000, 0x08000000,
91      0x00800000, 0x00008000,
92  };
93  }  
94  uint32_t CRC32AcceleratedX86ARMCombined::ComputeZeroConstant(
95      size_t length) const {
96    length >>= 2;
97    int index = absl::countr_zero(length);
98    uint32_t prev = kCRC32CPowers[index];
99    length &= length - 1;
100    while (length) {
101      index = absl::countr_zero(length);
102      prev = multiply(prev, kCRC32CPowers[index]);
103      length &= length - 1;
104    }
105    return prev;
106  }
107  void CRC32AcceleratedX86ARMCombined::ExtendByZeroes(uint32_t* crc,
108                                                      size_t length) const {
109    uint32_t val = *crc;
110    switch (length & 3) {
111      case 0:
112        break;
113      case 1:
114        val = CRC32_u8(val, 0);
115        break;
116      case 2:
117        val = CRC32_u16(val, 0);
118        break;
119      case 3:
120        val = CRC32_u8(val, 0);
121        val = CRC32_u16(val, 0);
122        break;
123    }
124    if (length > 3) {
125      val = multiply(val, ComputeZeroConstant(length));
126    }
127    *crc = val;
128  }
129  constexpr uint64_t kClmulConstants[] = {
130      0x09e4addf8, 0x0ba4fc28e, 0x00d3b6092, 0x09e4addf8, 0x0ab7aff2a,
131      0x102f9b8a2, 0x0b9e02b86, 0x00d3b6092, 0x1bf2e8b8a, 0x18266e456,
132      0x0d270f1a2, 0x0ab7aff2a, 0x11eef4f8e, 0x083348832, 0x0dd7e3b0c,
133      0x0b9e02b86, 0x0271d9844, 0x1b331e26a, 0x06b749fb2, 0x1bf2e8b8a,
134      0x0e6fc4e6a, 0x0ce7f39f4, 0x0d7a4825c, 0x0d270f1a2, 0x026f6a60a,
135      0x12ed0daac, 0x068bce87a, 0x11eef4f8e, 0x1329d9f7e, 0x0b3e32c28,
136      0x0170076fa, 0x0dd7e3b0c, 0x1fae1cc66, 0x010746f3c, 0x086d8e4d2,
137      0x0271d9844, 0x0b3af077a, 0x093a5f730, 0x1d88abd4a, 0x06b749fb2,
138      0x0c9c8b782, 0x0cec3662e, 0x1ddffc5d4, 0x0e6fc4e6a, 0x168763fa6,
139      0x0b0cd4768, 0x19b1afbc4, 0x0d7a4825c, 0x123888b7a, 0x00167d312,
140      0x133d7a042, 0x026f6a60a, 0x000bcf5f6, 0x19d34af3a, 0x1af900c24,
141      0x068bce87a, 0x06d390dec, 0x16cba8aca, 0x1f16a3418, 0x1329d9f7e,
142      0x19fb2a8b0, 0x02178513a, 0x1a0f717c4, 0x0170076fa,
143  };
144  enum class CutoffStrategy {
145    Fold3,
146    Unroll64CRC,
147  };
148  class CRC32AcceleratedX86ARMCombinedMultipleStreamsBase
149      : public CRC32AcceleratedX86ARMCombined {
150   protected:
151    ABSL_ATTRIBUTE_ALWAYS_INLINE void Process64BytesPclmul(
152        const uint8_t* p, V128* partialCRC) const {
153      V128 loopMultiplicands = V128_Load(reinterpret_cast<const V128*>(k1k2));
154      V128 partialCRC1 = partialCRC[0];
155      V128 partialCRC2 = partialCRC[1];
156      V128 partialCRC3 = partialCRC[2];
157      V128 partialCRC4 = partialCRC[3];
158      V128 tmp1 = V128_PMulHi(partialCRC1, loopMultiplicands);
159      V128 tmp2 = V128_PMulHi(partialCRC2, loopMultiplicands);
160      V128 tmp3 = V128_PMulHi(partialCRC3, loopMultiplicands);
161      V128 tmp4 = V128_PMulHi(partialCRC4, loopMultiplicands);
162      V128 data1 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 0));
163      V128 data2 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 1));
164      V128 data3 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 2));
165      V128 data4 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 3));
166      partialCRC1 = V128_PMulLow(partialCRC1, loopMultiplicands);
167      partialCRC2 = V128_PMulLow(partialCRC2, loopMultiplicands);
168      partialCRC3 = V128_PMulLow(partialCRC3, loopMultiplicands);
169      partialCRC4 = V128_PMulLow(partialCRC4, loopMultiplicands);
170      partialCRC1 = V128_Xor(tmp1, partialCRC1);
171      partialCRC2 = V128_Xor(tmp2, partialCRC2);
172      partialCRC3 = V128_Xor(tmp3, partialCRC3);
173      partialCRC4 = V128_Xor(tmp4, partialCRC4);
174      partialCRC1 = V128_Xor(partialCRC1, data1);
175      partialCRC2 = V128_Xor(partialCRC2, data2);
176      partialCRC3 = V128_Xor(partialCRC3, data3);
177      partialCRC4 = V128_Xor(partialCRC4, data4);
178      partialCRC[0] = partialCRC1;
179      partialCRC[1] = partialCRC2;
180      partialCRC[2] = partialCRC3;
181      partialCRC[3] = partialCRC4;
182    }
183    ABSL_ATTRIBUTE_ALWAYS_INLINE uint64_t
184    FinalizePclmulStream(V128* partialCRC) const {
185      V128 partialCRC1 = partialCRC[0];
186      V128 partialCRC2 = partialCRC[1];
187      V128 partialCRC3 = partialCRC[2];
188      V128 partialCRC4 = partialCRC[3];
189      V128 reductionMultiplicands =
190          V128_Load(reinterpret_cast<const V128*>(k5k6));
191      V128 low = V128_PMulLow(reductionMultiplicands, partialCRC1);
192      V128 high = V128_PMulHi(reductionMultiplicands, partialCRC1);
193      partialCRC1 = V128_Xor(low, high);
194      partialCRC1 = V128_Xor(partialCRC1, partialCRC2);
195      low = V128_PMulLow(reductionMultiplicands, partialCRC3);
196      high = V128_PMulHi(reductionMultiplicands, partialCRC3);
197      partialCRC3 = V128_Xor(low, high);
198      partialCRC3 = V128_Xor(partialCRC3, partialCRC4);
199      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(k3k4));
200      low = V128_PMulLow(reductionMultiplicands, partialCRC1);
201      high = V128_PMulHi(reductionMultiplicands, partialCRC1);
202      V128 fullCRC = V128_Xor(low, high);
203      fullCRC = V128_Xor(fullCRC, partialCRC3);
204      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(k5k6));
205      V128 mask = V128_Load(reinterpret_cast<const V128*>(kMask));
206      V128 tmp = V128_PMul01(reductionMultiplicands, fullCRC);
207      fullCRC = V128_ShiftRight<8>(fullCRC);
208      fullCRC = V128_Xor(fullCRC, tmp);
209      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(k7k0));
210      tmp = V128_ShiftRight<4>(fullCRC);
211      fullCRC = V128_And(fullCRC, mask);
212      fullCRC = V128_PMulLow(reductionMultiplicands, fullCRC);
213      fullCRC = V128_Xor(tmp, fullCRC);
214      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(kPoly));
215      tmp = V128_And(fullCRC, mask);
216      tmp = V128_PMul01(reductionMultiplicands, tmp);
217      tmp = V128_And(tmp, mask);
218      tmp = V128_PMulLow(reductionMultiplicands, tmp);
219      fullCRC = V128_Xor(tmp, fullCRC);
220      return static_cast<uint64_t>(V128_Extract32<1>(fullCRC));
221    }
222    ABSL_ATTRIBUTE_ALWAYS_INLINE uint64_t Process64BytesCRC(const uint8_t* p,
223                                                            uint64_t crc) const {
224      for (int i = 0; i < 8; i++) {
225        crc =
226            CRC32_u64(static_cast<uint32_t>(crc), absl::little_endian::Load64(p));
227        p += 8;
228      }
229      return crc;
230    }
231    alignas(16) static constexpr uint64_t k1k2[2] = {0x0740eef02, 0x09e4addf8};
232    alignas(16) static constexpr uint64_t k3k4[2] = {0x1384aa63a, 0x0ba4fc28e};
233    alignas(16) static constexpr uint64_t k5k6[2] = {0x0f20c0dfe, 0x14cd00bd6};
234    alignas(16) static constexpr uint64_t k7k0[2] = {0x0dd45aab8, 0x000000000};
235    alignas(16) static constexpr uint64_t kPoly[2] = {0x105ec76f0, 0x0dea713f1};
236    alignas(16) static constexpr uint32_t kMask[4] = {~0u, 0u, ~0u, 0u};
237    static constexpr size_t kGroupsSmall = 3;
238    static constexpr size_t kMaxStreams = 3;
239  };
240  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
241  alignas(16) constexpr uint64_t
242      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k1k2[2];
243  alignas(16) constexpr uint64_t
244      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k3k4[2];
245  alignas(16) constexpr uint64_t
246      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k5k6[2];
247  alignas(16) constexpr uint64_t
248      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k7k0[2];
249  alignas(16) constexpr uint64_t
250      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kPoly[2];
251  alignas(16) constexpr uint32_t
252      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kMask[4];
253  constexpr size_t
254      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kGroupsSmall;
255  constexpr size_t CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kMaxStreams;
256  #endif  
257  template <size_t num_crc_streams, size_t num_pclmul_streams,
258            CutoffStrategy strategy>
259  class CRC32AcceleratedX86ARMCombinedMultipleStreams
260      : public CRC32AcceleratedX86ARMCombinedMultipleStreamsBase {
261    ABSL_ATTRIBUTE_HOT
262    void Extend(uint32_t* crc, const void* bytes, size_t length) const override {
263      static_assert(num_crc_streams >= 1 && num_crc_streams <= kMaxStreams,
264                    "Invalid number of crc streams");
265      static_assert(num_pclmul_streams >= 0 && num_pclmul_streams <= kMaxStreams,
266                    "Invalid number of pclmul streams");
267      const uint8_t* p = static_cast<const uint8_t*>(bytes);
268      const uint8_t* e = p + length;
269      uint32_t l = *crc;
270      uint64_t l64;
271      if (length & 8) {
272        ABSL_INTERNAL_STEP8(l, p);
273        length &= ~size_t{8};
274      }
275      if (length & 4) {
276        ABSL_INTERNAL_STEP4(l);
277        length &= ~size_t{4};
278      }
279      if (length & 2) {
280        ABSL_INTERNAL_STEP2(l);
281        length &= ~size_t{2};
282      }
283      if (length & 1) {
284        ABSL_INTERNAL_STEP1(l);
285        length &= ~size_t{1};
286      }
287      if (length == 0) {
288        *crc = l;
289        return;
290      }
291      if (strategy != CutoffStrategy::Unroll64CRC) {
292        if (length < kSmallCutoff) {
293          while (length >= 16) {
294            ABSL_INTERNAL_STEP8(l, p);
295            ABSL_INTERNAL_STEP8(l, p);
296            length -= 16;
297          }
298          *crc = l;
299          return;
300        }
301      }
302      if (length < kMediumCutoff) {
303        l64 = l;
304        if (strategy == CutoffStrategy::Fold3) {
305          uint64_t l641 = 0;
306          uint64_t l642 = 0;
307          const size_t blockSize = 32;
308          size_t bs = static_cast<size_t>(e - p) / kGroupsSmall / blockSize;
309          const uint8_t* p1 = p + bs * blockSize;
310          const uint8_t* p2 = p1 + bs * blockSize;
311          for (size_t i = 0; i + 1 < bs; ++i) {
312            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
313            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
314            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
<span onclick='openModal()' class='match'>315            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
316            PrefetchToLocalCache(
317                reinterpret_cast<const char*>(p + kPrefetchHorizonMedium));
318            PrefetchToLocalCache(
319                reinterpret_cast<const char*>(p1 + kPrefetchHorizonMedium));
320            PrefetchToLocalCache(
321                reinterpret_cast<const char*>(p2 + kPrefetchHorizonMedium));
</span>322          }
323          ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
324          ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
325          ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
326          ABSL_INTERNAL_STEP8BY2(l64, l641, p, p1);
327          V128 magic = *(reinterpret_cast<const V128*>(kClmulConstants) + bs - 1);
328          V128 tmp = V128_From2x64(0, l64);
329          V128 res1 = V128_PMulLow(tmp, magic);
330          tmp = V128_From2x64(0, l641);
331          V128 res2 = V128_PMul10(tmp, magic);
332          V128 x = V128_Xor(res1, res2);
333          l64 = static_cast<uint64_t>(V128_Low64(x)) ^
334                absl::little_endian::Load64(p2);
335          l64 = CRC32_u64(static_cast<uint32_t>(l642), l64);
336          p = p2 + 8;
337        } else if (strategy == CutoffStrategy::Unroll64CRC) {
338          while ((e - p) >= 64) {
339            l64 = Process64BytesCRC(p, l64);
340            p += 64;
341          }
342        }
343      } else {
344        const uint8_t* x = RoundUp<8>(p);
345        while (p != x) {
346          ABSL_INTERNAL_STEP1(l);
347        }
348        size_t bs = static_cast<size_t>(e - p) /
349                    (num_crc_streams + num_pclmul_streams) / 64;
350        const uint8_t* crc_streams[kMaxStreams];
351        const uint8_t* pclmul_streams[kMaxStreams];
352        crc_streams[0] = p;
353        for (size_t i = 1; i < num_crc_streams; i++) {
354          crc_streams[i] = crc_streams[i - 1] + bs * 64;
355        }
356        pclmul_streams[0] = crc_streams[num_crc_streams - 1] + bs * 64;
357        for (size_t i = 1; i < num_pclmul_streams; i++) {
358          pclmul_streams[i] = pclmul_streams[i - 1] + bs * 64;
359        }
360        uint64_t l64_crc[kMaxStreams] = {l};
361        uint64_t l64_pclmul[kMaxStreams] = {0};
362        for (size_t i = 0; i < num_crc_streams; i++) {
363          l64_crc[i] = Process64BytesCRC(crc_streams[i], l64_crc[i]);
364          crc_streams[i] += 16 * 4;
365        }
366        V128 partialCRC[kMaxStreams][4];
367        for (size_t i = 0; i < num_pclmul_streams; i++) {
368          partialCRC[i][0] = V128_LoadU(
369              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 0));
370          partialCRC[i][1] = V128_LoadU(
371              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 1));
372          partialCRC[i][2] = V128_LoadU(
373              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 2));
374          partialCRC[i][3] = V128_LoadU(
375              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 3));
376          pclmul_streams[i] += 16 * 4;
377        }
378        for (size_t i = 1; i < bs; i++) {
379          for (size_t j = 0; j < num_crc_streams; j++) {
380            PrefetchToLocalCache(
381                reinterpret_cast<const char*>(crc_streams[j] + kPrefetchHorizon));
382          }
383          for (size_t j = 0; j < num_pclmul_streams; j++) {
384            PrefetchToLocalCache(reinterpret_cast<const char*>(pclmul_streams[j] +
385                                                               kPrefetchHorizon));
386          }
387          l64_crc[0] = Process64BytesCRC(crc_streams[0], l64_crc[0]);
388          crc_streams[0] += 16 * 4;
389          if (num_pclmul_streams > 0) {
390            Process64BytesPclmul(pclmul_streams[0], partialCRC[0]);
391            pclmul_streams[0] += 16 * 4;
392          }
393          if (num_crc_streams > 1) {
394            l64_crc[1] = Process64BytesCRC(crc_streams[1], l64_crc[1]);
395            crc_streams[1] += 16 * 4;
396          }
397          if (num_pclmul_streams > 1) {
398            Process64BytesPclmul(pclmul_streams[1], partialCRC[1]);
399            pclmul_streams[1] += 16 * 4;
400          }
401          if (num_crc_streams > 2) {
402            l64_crc[2] = Process64BytesCRC(crc_streams[2], l64_crc[2]);
403            crc_streams[2] += 16 * 4;
404          }
405          if (num_pclmul_streams > 2) {
406            Process64BytesPclmul(pclmul_streams[2], partialCRC[2]);
407            pclmul_streams[2] += 16 * 4;
408          }
409        }
410        for (size_t i = 0; i < num_pclmul_streams; i++) {
411          l64_pclmul[i] = FinalizePclmulStream(partialCRC[i]);
412        }
413        uint32_t magic = ComputeZeroConstant(bs * 64);
414        l64 = l64_crc[0];
415        for (size_t i = 1; i < num_crc_streams; i++) {
416          l64 = multiply(static_cast<uint32_t>(l64), magic);
417          l64 ^= l64_crc[i];
418        }
419        for (size_t i = 0; i < num_pclmul_streams; i++) {
420          l64 = multiply(static_cast<uint32_t>(l64), magic);
421          l64 ^= l64_pclmul[i];
422        }
423        if (num_pclmul_streams > 0) {
424          p = pclmul_streams[num_pclmul_streams - 1];
425        } else {
426          p = crc_streams[num_crc_streams - 1];
427        }
428      }
429      l = static_cast<uint32_t>(l64);
430      while ((e - p) >= 16) {
431        ABSL_INTERNAL_STEP8(l, p);
432        ABSL_INTERNAL_STEP8(l, p);
433      }
434      while (p != e) {
435        ABSL_INTERNAL_STEP1(l);
436      }
437  #undef ABSL_INTERNAL_STEP8BY3
438  #undef ABSL_INTERNAL_STEP8BY2
439  #undef ABSL_INTERNAL_STEP8
440  #undef ABSL_INTERNAL_STEP4
441  #undef ABSL_INTERNAL_STEP2
442  #undef ABSL_INTERNAL_STEP1
443      *crc = l;
444    }
445  };
446  }  
447  CRCImpl* TryNewCRC32AcceleratedX86ARMCombined() {
448    CpuType type = GetCpuType();
449    switch (type) {
450      case CpuType::kIntelHaswell:
451      case CpuType::kAmdRome:
452      case CpuType::kAmdNaples:
453      case CpuType::kAmdMilan:
454        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
455            3, 1, CutoffStrategy::Fold3>();
456      case CpuType::kIntelCascadelakeXeon:
457      case CpuType::kIntelSkylakeXeon:
458      case CpuType::kIntelBroadwell:
459      case CpuType::kIntelSkylake:
460        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
461            3, 2, CutoffStrategy::Fold3>();
462      case CpuType::kIntelIvybridge:
463      case CpuType::kIntelSandybridge:
464      case CpuType::kIntelWestmere:
465        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
466            3, 0, CutoffStrategy::Fold3>();
467      case CpuType::kArmNeoverseN1:
468        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
469            1, 1, CutoffStrategy::Unroll64CRC>();
470  #if defined(__aarch64__)
471      default:
472        if (SupportsArmCRC32PMULL()) {
473          return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
474              1, 1, CutoffStrategy::Unroll64CRC>();
475        } else {
476          return nullptr;
477        }
478  #else
479      default:
480        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
481            3, 0, CutoffStrategy::Fold3>();
482  #endif
483    }
484  }
485  std::vector<std::unique_ptr<CRCImpl>> NewCRC32AcceleratedX86ARMCombinedAll() {
486    auto ret = std::vector<std::unique_ptr<CRCImpl>>();
487    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
488                      1, 0, CutoffStrategy::Fold3>>());
489    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
490                      1, 1, CutoffStrategy::Fold3>>());
491    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
492                      1, 2, CutoffStrategy::Fold3>>());
493    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
494                      1, 3, CutoffStrategy::Fold3>>());
495    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
496                      2, 0, CutoffStrategy::Fold3>>());
497    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
498                      2, 1, CutoffStrategy::Fold3>>());
499    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
500                      2, 2, CutoffStrategy::Fold3>>());
501    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
502                      2, 3, CutoffStrategy::Fold3>>());
503    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
504                      3, 0, CutoffStrategy::Fold3>>());
505    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
506                      3, 1, CutoffStrategy::Fold3>>());
507    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
508                      3, 2, CutoffStrategy::Fold3>>());
509    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
510                      3, 3, CutoffStrategy::Fold3>>());
511    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
512                      1, 0, CutoffStrategy::Unroll64CRC>>());
513    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
514                      1, 1, CutoffStrategy::Unroll64CRC>>());
515    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
516                      1, 2, CutoffStrategy::Unroll64CRC>>());
517    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
518                      1, 3, CutoffStrategy::Unroll64CRC>>());
519    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
520                      2, 0, CutoffStrategy::Unroll64CRC>>());
521    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
522                      2, 1, CutoffStrategy::Unroll64CRC>>());
523    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
524                      2, 2, CutoffStrategy::Unroll64CRC>>());
525    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
526                      2, 3, CutoffStrategy::Unroll64CRC>>());
527    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
528                      3, 0, CutoffStrategy::Unroll64CRC>>());
529    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
530                      3, 1, CutoffStrategy::Unroll64CRC>>());
531    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
532                      3, 2, CutoffStrategy::Unroll64CRC>>());
533    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
534                      3, 3, CutoffStrategy::Unroll64CRC>>());
535    return ret;
536  }
537  #else  
538  std::vector<std::unique_ptr<CRCImpl>> NewCRC32AcceleratedX86ARMCombinedAll() {
539    return std::vector<std::unique_ptr<CRCImpl>>();
540  }
541  CRCImpl* TryNewCRC32AcceleratedX86ARMCombined() { return nullptr; }
542  #endif
543  }  
544  ABSL_NAMESPACE_END
545  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-symbolize_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-crc_x86_arm_combined.cc</div>
                </div>
                <div class="column column_space"><pre><code>393  TEST(Symbolize, Unimplemented) {
394    char buf[64];
395    EXPECT_FALSE(absl::Symbolize((void *)(&nonstatic_func), buf, sizeof(buf)));
396    EXPECT_FALSE(absl::Symbolize((void *)(&static_func), buf, sizeof(buf)));
397    EXPECT_FALSE(absl::Symbolize((void *)(&Foo::func), buf, sizeof(buf)));
</pre></code></div>
                <div class="column column_space"><pre><code>315            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
316            PrefetchToLocalCache(
317                reinterpret_cast<const char*>(p + kPrefetchHorizonMedium));
318            PrefetchToLocalCache(
319                reinterpret_cast<const char*>(p1 + kPrefetchHorizonMedium));
320            PrefetchToLocalCache(
321                reinterpret_cast<const char*>(p2 + kPrefetchHorizonMedium));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    