
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.234234234234234%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fixed_array_test.cc</h3>
            <pre><code>1  #include "absl/container/fixed_array.h"
2  #include <stdio.h>
3  #include <cstring>
4  #include <list>
5  #include <memory>
6  #include <numeric>
7  #include <scoped_allocator>
8  #include <stdexcept>
9  #include <string>
10  #include <vector>
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/base/config.h"
14  #include "absl/base/internal/exception_testing.h"
15  #include "absl/base/options.h"
16  #include "absl/container/internal/counting_allocator.h"
17  #include "absl/hash/hash_testing.h"
18  #include "absl/memory/memory.h"
19  using ::testing::ElementsAreArray;
20  namespace {
21  template <typename ArrayType>
22  static bool IsOnStack(const ArrayType& a) {
23    return a.size() <= ArrayType::inline_elements;
24  }
25  class ConstructionTester {
26   public:
27    ConstructionTester() : self_ptr_(this), value_(0) { constructions++; }
28    ~ConstructionTester() {
29      assert(self_ptr_ == this);
30      self_ptr_ = nullptr;
31      destructions++;
32    }
33    static int constructions;
34    static int destructions;
35    void CheckConstructed() { assert(self_ptr_ == this); }
36    void set(int value) { value_ = value; }
37    int get() { return value_; }
38   private:
39    ConstructionTester* self_ptr_;
40    int value_;
41  };
42  int ConstructionTester::constructions = 0;
43  int ConstructionTester::destructions = 0;
44  class ThreeInts {
45   public:
46    ThreeInts() {
47      x_ = counter;
48      y_ = counter;
49      z_ = counter;
50      ++counter;
51    }
52    static int counter;
53    int x_, y_, z_;
54  };
55  int ThreeInts::counter = 0;
56  TEST(FixedArrayTest, CopyCtor) {
57    absl::FixedArray<int, 10> on_stack(5);
58    std::iota(on_stack.begin(), on_stack.end(), 0);
59    absl::FixedArray<int, 10> stack_copy = on_stack;
60    EXPECT_THAT(stack_copy, ElementsAreArray(on_stack));
61    EXPECT_TRUE(IsOnStack(stack_copy));
62    absl::FixedArray<int, 10> allocated(15);
63    std::iota(allocated.begin(), allocated.end(), 0);
64    absl::FixedArray<int, 10> alloced_copy = allocated;
65    EXPECT_THAT(alloced_copy, ElementsAreArray(allocated));
66    EXPECT_FALSE(IsOnStack(alloced_copy));
67  }
68  TEST(FixedArrayTest, MoveCtor) {
69    absl::FixedArray<std::unique_ptr<int>, 10> on_stack(5);
70    for (int i = 0; i < 5; ++i) {
71      on_stack[i] = absl::make_unique<int>(i);
72    }
73    absl::FixedArray<std::unique_ptr<int>, 10> stack_copy = std::move(on_stack);
74    for (int i = 0; i < 5; ++i) EXPECT_EQ(*(stack_copy[i]), i);
75    EXPECT_EQ(stack_copy.size(), on_stack.size());
76    absl::FixedArray<std::unique_ptr<int>, 10> allocated(15);
77    for (int i = 0; i < 15; ++i) {
78      allocated[i] = absl::make_unique<int>(i);
79    }
80    absl::FixedArray<std::unique_ptr<int>, 10> alloced_copy =
81        std::move(allocated);
82    for (int i = 0; i < 15; ++i) EXPECT_EQ(*(alloced_copy[i]), i);
83    EXPECT_EQ(allocated.size(), alloced_copy.size());
84  }
85  TEST(FixedArrayTest, SmallObjects) {
86    {
87      absl::FixedArray<int> array(4);
88      EXPECT_TRUE(IsOnStack(array));
89    }
90    {
91      absl::FixedArray<int> array(1048576);
92      EXPECT_FALSE(IsOnStack(array));
93    }
94    {
95      absl::FixedArray<int, 100> array(100);
96      EXPECT_TRUE(IsOnStack(array));
97    }
98    {
99      absl::FixedArray<int, 100> array(101);
100      EXPECT_FALSE(IsOnStack(array));
101    }
102    {
103      absl::FixedArray<int> array1(0);
104      absl::FixedArray<char> array2(0);
105      EXPECT_LE(sizeof(array1), sizeof(array2) + 100);
106      EXPECT_LE(sizeof(array2), sizeof(array1) + 100);
107    }
108    {
109      absl::FixedArray<std::vector<int>> array(2);
110      EXPECT_EQ(0, array[0].size());
111      EXPECT_EQ(0, array[1].size());
112    }
113    {
114      ThreeInts::counter = 1;
115      absl::FixedArray<ThreeInts> array(2);
116      EXPECT_EQ(1, array[0].x_);
117      EXPECT_EQ(1, array[0].y_);
118      EXPECT_EQ(1, array[0].z_);
119      EXPECT_EQ(2, array[1].x_);
120      EXPECT_EQ(2, array[1].y_);
121      EXPECT_EQ(2, array[1].z_);
122    }
123  }
124  TEST(FixedArrayTest, AtThrows) {
125    absl::FixedArray<int> a = {1, 2, 3};
126    EXPECT_EQ(a.at(2), 3);
127    ABSL_BASE_INTERNAL_EXPECT_FAIL(a.at(3), std::out_of_range,
128                                   "failed bounds check");
129  }
130  TEST(FixedArrayTest, Hardened) {
131  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
132    absl::FixedArray<int> a = {1, 2, 3};
133    EXPECT_EQ(a[2], 3);
134    EXPECT_DEATH_IF_SUPPORTED(a[3], "");
135    EXPECT_DEATH_IF_SUPPORTED(a[-1], "");
136    absl::FixedArray<int> empty(0);
137    EXPECT_DEATH_IF_SUPPORTED(empty[0], "");
138    EXPECT_DEATH_IF_SUPPORTED(empty[-1], "");
139    EXPECT_DEATH_IF_SUPPORTED(empty.front(), "");
140    EXPECT_DEATH_IF_SUPPORTED(empty.back(), "");
141  #endif
142  }
143  TEST(FixedArrayRelationalsTest, EqualArrays) {
144    for (int i = 0; i < 10; ++i) {
145      absl::FixedArray<int, 5> a1(i);
146      std::iota(a1.begin(), a1.end(), 0);
147      absl::FixedArray<int, 5> a2(a1.begin(), a1.end());
148      EXPECT_TRUE(a1 == a2);
149      EXPECT_FALSE(a1 != a2);
150      EXPECT_TRUE(a2 == a1);
151      EXPECT_FALSE(a2 != a1);
152      EXPECT_FALSE(a1 < a2);
153      EXPECT_FALSE(a1 > a2);
154      EXPECT_FALSE(a2 < a1);
155      EXPECT_FALSE(a2 > a1);
156      EXPECT_TRUE(a1 <= a2);
157      EXPECT_TRUE(a1 >= a2);
158      EXPECT_TRUE(a2 <= a1);
159      EXPECT_TRUE(a2 >= a1);
160    }
161  }
162  TEST(FixedArrayRelationalsTest, UnequalArrays) {
163    for (int i = 1; i < 10; ++i) {
164      absl::FixedArray<int, 5> a1(i);
165      std::iota(a1.begin(), a1.end(), 0);
166      absl::FixedArray<int, 5> a2(a1.begin(), a1.end());
167      --a2[i / 2];
168      EXPECT_FALSE(a1 == a2);
169      EXPECT_TRUE(a1 != a2);
170      EXPECT_FALSE(a2 == a1);
171      EXPECT_TRUE(a2 != a1);
172      EXPECT_FALSE(a1 < a2);
173      EXPECT_TRUE(a1 > a2);
174      EXPECT_TRUE(a2 < a1);
175      EXPECT_FALSE(a2 > a1);
176      EXPECT_FALSE(a1 <= a2);
177      EXPECT_TRUE(a1 >= a2);
178      EXPECT_TRUE(a2 <= a1);
179      EXPECT_FALSE(a2 >= a1);
180    }
181  }
182  template <int stack_elements>
183  static void TestArray(int n) {
184    SCOPED_TRACE(n);
185    SCOPED_TRACE(stack_elements);
186    ConstructionTester::constructions = 0;
187    ConstructionTester::destructions = 0;
188    {
189      absl::FixedArray<ConstructionTester, stack_elements> array(n);
190      EXPECT_THAT(array.size(), n);
191      EXPECT_THAT(array.memsize(), sizeof(ConstructionTester) * n);
192      EXPECT_THAT(array.begin() + n, array.end());
193      for (int i = 0; i < n; i++) {
194        array[i].CheckConstructed();
195      }
196      EXPECT_THAT(ConstructionTester::constructions, n);
197      for (int i = 0; i < n; i++) {
198        array[i].set(i);
199      }
200      for (int i = 0; i < n; i++) {
201        EXPECT_THAT(array[i].get(), i);
202        EXPECT_THAT(array.data()[i].get(), i);
203      }
204      for (int i = 0; i < n; i++) {
205        array.data()[i].set(i + 1);
206      }
207      for (int i = 0; i < n; i++) {
208        EXPECT_THAT(array[i].get(), i + 1);
209        EXPECT_THAT(array.data()[i].get(), i + 1);
210      }
211    }  
212    EXPECT_EQ(ConstructionTester::constructions,
213              ConstructionTester::destructions);
214  }
215  template <int elements_per_inner_array, int inline_elements>
216  static void TestArrayOfArrays(int n) {
217    SCOPED_TRACE(n);
218    SCOPED_TRACE(inline_elements);
219    SCOPED_TRACE(elements_per_inner_array);
220    ConstructionTester::constructions = 0;
221    ConstructionTester::destructions = 0;
222    {
223      using InnerArray = ConstructionTester[elements_per_inner_array];
224      auto array_ptr =
225          absl::make_unique<absl::FixedArray<InnerArray, inline_elements>>(n);
226      auto& array = *array_ptr;
227      ASSERT_EQ(array.size(), n);
228      ASSERT_EQ(array.memsize(),
229                sizeof(ConstructionTester) * elements_per_inner_array * n);
230      ASSERT_EQ(array.begin() + n, array.end());
231      for (int i = 0; i < n; i++) {
232        for (int j = 0; j < elements_per_inner_array; j++) {
233          (array[i])[j].CheckConstructed();
234        }
235      }
236      ASSERT_EQ(ConstructionTester::constructions, n * elements_per_inner_array);
237      for (int i = 0; i < n; i++) {
238        for (int j = 0; j < elements_per_inner_array; j++) {
239          (array[i])[j].set(i * elements_per_inner_array + j);
240        }
241      }
242      for (int i = 0; i < n; i++) {
243        for (int j = 0; j < elements_per_inner_array; j++) {
244          ASSERT_EQ((array[i])[j].get(), i * elements_per_inner_array + j);
245          ASSERT_EQ((array.data()[i])[j].get(), i * elements_per_inner_array + j);
246        }
247      }
248      for (int i = 0; i < n; i++) {
249        for (int j = 0; j < elements_per_inner_array; j++) {
250          (array.data()[i])[j].set((i + 1) * elements_per_inner_array + j);
251        }
252      }
253      for (int i = 0; i < n; i++) {
254        for (int j = 0; j < elements_per_inner_array; j++) {
255          ASSERT_EQ((array[i])[j].get(), (i + 1) * elements_per_inner_array + j);
256          ASSERT_EQ((array.data()[i])[j].get(),
257                    (i + 1) * elements_per_inner_array + j);
258        }
259      }
260    }  
261    EXPECT_EQ(ConstructionTester::constructions,
262              ConstructionTester::destructions);
263  }
264  TEST(IteratorConstructorTest, NonInline) {
265    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
266    absl::FixedArray<int, ABSL_ARRAYSIZE(kInput) - 1> const fixed(
267        kInput, kInput + ABSL_ARRAYSIZE(kInput));
268    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
269    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
270      ASSERT_EQ(kInput[i], fixed[i]);
271    }
272  }
273  TEST(IteratorConstructorTest, Inline) {
274    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
275    absl::FixedArray<int, ABSL_ARRAYSIZE(kInput)> const fixed(
276        kInput, kInput + ABSL_ARRAYSIZE(kInput));
277    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
278    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
279      ASSERT_EQ(kInput[i], fixed[i]);
280    }
281  }
282  TEST(IteratorConstructorTest, NonPod) {
283    char const* kInput[] = {"red",  "orange", "yellow", "green",
284                            "blue", "indigo", "violet"};
285    absl::FixedArray<std::string> const fixed(kInput,
286                                              kInput + ABSL_ARRAYSIZE(kInput));
287    ASSERT_EQ(ABSL_ARRAYSIZE(kInput), fixed.size());
288    for (size_t i = 0; i < ABSL_ARRAYSIZE(kInput); ++i) {
289      ASSERT_EQ(kInput[i], fixed[i]);
290    }
291  }
292  TEST(IteratorConstructorTest, FromEmptyVector) {
293    std::vector<int> const empty;
294    absl::FixedArray<int> const fixed(empty.begin(), empty.end());
295    EXPECT_EQ(0, fixed.size());
296    EXPECT_EQ(empty.size(), fixed.size());
297  }
298  TEST(IteratorConstructorTest, FromNonEmptyVector) {
299    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
300    std::vector<int> const items(kInput, kInput + ABSL_ARRAYSIZE(kInput));
301    absl::FixedArray<int> const fixed(items.begin(), items.end());
302    ASSERT_EQ(items.size(), fixed.size());
303    for (size_t i = 0; i < items.size(); ++i) {
304      ASSERT_EQ(items[i], fixed[i]);
305    }
306  }
307  TEST(IteratorConstructorTest, FromBidirectionalIteratorRange) {
308    int const kInput[] = {2, 3, 5, 7, 11, 13, 17};
309    std::list<int> const items(kInput, kInput + ABSL_ARRAYSIZE(kInput));
310    absl::FixedArray<int> const fixed(items.begin(), items.end());
311    EXPECT_THAT(fixed, testing::ElementsAreArray(kInput));
312  }
313  TEST(InitListConstructorTest, InitListConstruction) {
314    absl::FixedArray<int> fixed = {1, 2, 3};
315    EXPECT_THAT(fixed, testing::ElementsAreArray({1, 2, 3}));
316  }
317  TEST(FillConstructorTest, NonEmptyArrays) {
318    absl::FixedArray<int> stack_array(4, 1);
319    EXPECT_THAT(stack_array, testing::ElementsAreArray({1, 1, 1, 1}));
320    absl::FixedArray<int, 0> heap_array(4, 1);
321    EXPECT_THAT(stack_array, testing::ElementsAreArray({1, 1, 1, 1}));
322  }
323  TEST(FillConstructorTest, EmptyArray) {
324    absl::FixedArray<int> empty_fill(0, 1);
325    absl::FixedArray<int> empty_size(0);
326    EXPECT_EQ(empty_fill, empty_size);
327  }
328  TEST(FillConstructorTest, NotTriviallyCopyable) {
329    std::string str = "abcd";
330    absl::FixedArray<std::string> strings = {str, str, str, str};
331    absl::FixedArray<std::string> array(4, str);
332    EXPECT_EQ(array, strings);
333  }
334  TEST(FillConstructorTest, Disambiguation) {
335    absl::FixedArray<size_t> a(1, 2);
336    EXPECT_THAT(a, testing::ElementsAre(2));
337  }
338  TEST(FixedArrayTest, ManySizedArrays) {
339    std::vector<int> sizes;
340    for (int i = 1; i < 100; i++) sizes.push_back(i);
341    for (int i = 100; i <= 1000; i += 100) sizes.push_back(i);
342    for (int n : sizes) {
343      TestArray<0>(n);
344      TestArray<1>(n);
345      TestArray<64>(n);
346      TestArray<1000>(n);
347    }
348  }
349  TEST(FixedArrayTest, ManySizedArraysOfArraysOf1) {
350    for (int n = 1; n < 1000; n++) {
351      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 0>(n)));
352      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 1>(n)));
353      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 64>(n)));
354      ASSERT_NO_FATAL_FAILURE((TestArrayOfArrays<1, 1000>(n)));
355    }
356  }
357  TEST(FixedArrayTest, ManySizedArraysOfArraysOf2) {
358    for (int n = 1; n < 1000; n++) {
359      TestArrayOfArrays<2, 0>(n);
360      TestArrayOfArrays<2, 1>(n);
361      TestArrayOfArrays<2, 64>(n);
362      TestArrayOfArrays<2, 1000>(n);
363    }
364  }
365  TEST(FixedArrayTest, AvoidParanoidDiagnostics) {
366    absl::FixedArray<char, 32> buf(32);
367    sprintf(buf.data(), "foo");  
368  }
369  TEST(FixedArrayTest, TooBigInlinedSpace) {
370    struct TooBig {
371      char c[1 << 20];
372    };  
373    struct Data {
374      TooBig* p;
375      size_t size;
376    };
377    static_assert(sizeof(absl::FixedArray<TooBig, 0>) == sizeof(Data),
378                  "0-sized absl::FixedArray should have same size as Data.");
379    static_assert(alignof(absl::FixedArray<TooBig, 0>) == alignof(Data),
380                  "0-sized absl::FixedArray should have same alignment as Data.");
381    static_assert(sizeof(absl::FixedArray<TooBig>) == sizeof(Data),
382                  "default-sized absl::FixedArray should have same size as Data");
383    static_assert(
384        alignof(absl::FixedArray<TooBig>) == alignof(Data),
385        "default-sized absl::FixedArray should have same alignment as Data.");
386  }
387  struct PickyDelete {
388    PickyDelete() {}
389    ~PickyDelete() {}
390    void operator delete(void* p) {
391      EXPECT_TRUE(false) << __FUNCTION__;
392      ::operator delete(p);
393    }
394    void operator delete[](void* p) {
395      EXPECT_TRUE(false) << __FUNCTION__;
396      ::operator delete[](p);
397    }
398  };
399  TEST(FixedArrayTest, UsesGlobalAlloc) { absl::FixedArray<PickyDelete, 0> a(5); }
400  TEST(FixedArrayTest, Data) {
401    static const int kInput[] = {2, 3, 5, 7, 11, 13, 17};
402    absl::FixedArray<int> fa(std::begin(kInput), std::end(kInput));
403    EXPECT_EQ(fa.data(), &*fa.begin());
404    EXPECT_EQ(fa.data(), &fa[0]);
405    const absl::FixedArray<int>& cfa = fa;
406    EXPECT_EQ(cfa.data(), &*cfa.begin());
407    EXPECT_EQ(cfa.data(), &cfa[0]);
408  }
409  TEST(FixedArrayTest, Empty) {
410    absl::FixedArray<int> empty(0);
411    absl::FixedArray<int> inline_filled(1);
412    absl::FixedArray<int, 0> heap_filled(1);
413    EXPECT_TRUE(empty.empty());
414    EXPECT_FALSE(inline_filled.empty());
415    EXPECT_FALSE(heap_filled.empty());
416  }
417  TEST(FixedArrayTest, FrontAndBack) {
418    absl::FixedArray<int, 3 * sizeof(int)> inlined = {1, 2, 3};
419    EXPECT_EQ(inlined.front(), 1);
420    EXPECT_EQ(inlined.back(), 3);
421    absl::FixedArray<int, 0> allocated = {1, 2, 3};
422    EXPECT_EQ(allocated.front(), 1);
423    EXPECT_EQ(allocated.back(), 3);
424    absl::FixedArray<int> one_element = {1};
425    EXPECT_EQ(one_element.front(), one_element.back());
426  }
427  TEST(FixedArrayTest, ReverseIteratorInlined) {
428    absl::FixedArray<int, 5 * sizeof(int)> a = {0, 1, 2, 3, 4};
429    int counter = 5;
430    for (absl::FixedArray<int>::reverse_iterator iter = a.rbegin();
431         iter != a.rend(); ++iter) {
432      counter--;
433      EXPECT_EQ(counter, *iter);
434    }
435    EXPECT_EQ(counter, 0);
436    counter = 5;
437    for (absl::FixedArray<int>::const_reverse_iterator iter = a.rbegin();
438         iter != a.rend(); ++iter) {
439      counter--;
440      EXPECT_EQ(counter, *iter);
441    }
442    EXPECT_EQ(counter, 0);
443    counter = 5;
444    for (auto iter = a.crbegin(); iter != a.crend(); ++iter) {
445      counter--;
446      EXPECT_EQ(counter, *iter);
447    }
448    EXPECT_EQ(counter, 0);
449  }
450  TEST(FixedArrayTest, ReverseIteratorAllocated) {
451    absl::FixedArray<int, 0> a = {0, 1, 2, 3, 4};
452    int counter = 5;
453    for (absl::FixedArray<int>::reverse_iterator iter = a.rbegin();
454         iter != a.rend(); ++iter) {
455      counter--;
456      EXPECT_EQ(counter, *iter);
457    }
458    EXPECT_EQ(counter, 0);
459    counter = 5;
460    for (absl::FixedArray<int>::const_reverse_iterator iter = a.rbegin();
461         iter != a.rend(); ++iter) {
462      counter--;
463      EXPECT_EQ(counter, *iter);
464    }
465    EXPECT_EQ(counter, 0);
466    counter = 5;
467    for (auto iter = a.crbegin(); iter != a.crend(); ++iter) {
468      counter--;
469      EXPECT_EQ(counter, *iter);
470    }
471    EXPECT_EQ(counter, 0);
472  }
473  TEST(FixedArrayTest, Fill) {
474    absl::FixedArray<int, 5 * sizeof(int)> inlined(5);
475    int fill_val = 42;
476    inlined.fill(fill_val);
477    for (int i : inlined) EXPECT_EQ(i, fill_val);
478    absl::FixedArray<int, 0> allocated(5);
479    allocated.fill(fill_val);
480    for (int i : allocated) EXPECT_EQ(i, fill_val);
481    absl::FixedArray<int> empty(0);
482    empty.fill(fill_val);
483  }
484  #ifndef __GNUC__
485  TEST(FixedArrayTest, DefaultCtorDoesNotValueInit) {
486    using T = char;
487    constexpr auto capacity = 10;
488    using FixedArrType = absl::FixedArray<T, capacity>;
489    constexpr auto scrubbed_bits = 0x95;
490    constexpr auto length = capacity / 2;
491    alignas(FixedArrType) unsigned char buff[sizeof(FixedArrType)];
492    std::memset(std::addressof(buff), scrubbed_bits, sizeof(FixedArrType));
493    FixedArrType* arr =
494        ::new (static_cast<void*>(std::addressof(buff))) FixedArrType(length);
495    EXPECT_THAT(*arr, testing::Each(scrubbed_bits));
496    arr->~FixedArrType();
497  }
498  #endif  
499  TEST(AllocatorSupportTest, CountInlineAllocations) {
500    constexpr size_t inlined_size = 4;
501    using Alloc = absl::container_internal::CountingAllocator<int>;
502    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
503    int64_t allocated = 0;
504    int64_t active_instances = 0;
505    {
506      const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
507      Alloc alloc(&allocated, &active_instances);
508      AllocFxdArr arr(ia, ia + inlined_size, alloc);
509      static_cast<void>(arr);
510    }
511    EXPECT_EQ(allocated, 0);
512    EXPECT_EQ(active_instances, 0);
513  }
514  TEST(AllocatorSupportTest, CountOutoflineAllocations) {
515    constexpr size_t inlined_size = 4;
516    using Alloc = absl::container_internal::CountingAllocator<int>;
517    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
518    int64_t allocated = 0;
519    int64_t active_instances = 0;
520    {
521      const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
522      Alloc alloc(&allocated, &active_instances);
523      AllocFxdArr arr(ia, ia + ABSL_ARRAYSIZE(ia), alloc);
524      EXPECT_EQ(allocated, arr.size() * sizeof(int));
525      static_cast<void>(arr);
526    }
527    EXPECT_EQ(active_instances, 0);
528  }
529  TEST(AllocatorSupportTest, CountCopyInlineAllocations) {
530    constexpr size_t inlined_size = 4;
531    using Alloc = absl::container_internal::CountingAllocator<int>;
532    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
533    int64_t allocated1 = 0;
534    int64_t allocated2 = 0;
535    int64_t active_instances = 0;
536    Alloc alloc(&allocated1, &active_instances);
537    Alloc alloc2(&allocated2, &active_instances);
538    {
539      int initial_value = 1;
540      AllocFxdArr arr1(inlined_size / 2, initial_value, alloc);
541      EXPECT_EQ(allocated1, 0);
542      AllocFxdArr arr2(arr1, alloc2);
543      EXPECT_EQ(allocated2, 0);
544      static_cast<void>(arr1);
545      static_cast<void>(arr2);
546    }
547    EXPECT_EQ(active_instances, 0);
548  }
549  TEST(AllocatorSupportTest, CountCopyOutoflineAllocations) {
<span onclick='openModal()' class='match'>550    constexpr size_t inlined_size = 4;
551    using Alloc = absl::container_internal::CountingAllocator<int>;
552    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
553    int64_t allocated1 = 0;
554    int64_t allocated2 = 0;
555    int64_t active_instances = 0;
556    Alloc alloc(&allocated1, &active_instances);
</span>557    Alloc alloc2(&allocated2, &active_instances);
558    {
559      int initial_value = 1;
560      AllocFxdArr arr1(inlined_size * 2, initial_value, alloc);
561      EXPECT_EQ(allocated1, arr1.size() * sizeof(int));
562      AllocFxdArr arr2(arr1, alloc2);
563      EXPECT_EQ(allocated2, inlined_size * 2 * sizeof(int));
564      static_cast<void>(arr1);
565      static_cast<void>(arr2);
566    }
567    EXPECT_EQ(active_instances, 0);
568  }
569  TEST(AllocatorSupportTest, SizeValAllocConstructor) {
570    using testing::AllOf;
571    using testing::Each;
572    using testing::SizeIs;
573    constexpr size_t inlined_size = 4;
574    using Alloc = absl::container_internal::CountingAllocator<int>;
575    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
576    {
577      auto len = inlined_size / 2;
578      auto val = 0;
579      int64_t allocated = 0;
580      AllocFxdArr arr(len, val, Alloc(&allocated));
581      EXPECT_EQ(allocated, 0);
582      EXPECT_THAT(arr, AllOf(SizeIs(len), Each(0)));
583    }
584    {
585      auto len = inlined_size * 2;
586      auto val = 0;
587      int64_t allocated = 0;
588      AllocFxdArr arr(len, val, Alloc(&allocated));
589      EXPECT_EQ(allocated, len * sizeof(int));
590      EXPECT_THAT(arr, AllOf(SizeIs(len), Each(0)));
591    }
592  }
593  TEST(AllocatorSupportTest, PropagatesStatefulAllocator) {
594    constexpr size_t inlined_size = 4;
595    using Alloc = absl::container_internal::CountingAllocator<int>;
596    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
597    auto len = inlined_size * 2;
598    auto val = 0;
599    int64_t allocated = 0;
600    AllocFxdArr arr(len, val, Alloc(&allocated));
601    EXPECT_EQ(allocated, len * sizeof(int));
602    AllocFxdArr copy = arr;
603    EXPECT_EQ(allocated, len * sizeof(int) * 2);
604  }
605  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
606  TEST(FixedArrayTest, AddressSanitizerAnnotations1) {
607    absl::FixedArray<int, 32> a(10);
608    int* raw = a.data();
609    raw[0] = 0;
610    raw[9] = 0;
611    EXPECT_DEATH_IF_SUPPORTED(raw[-2] = 0, "container-overflow");
612    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
613    EXPECT_DEATH_IF_SUPPORTED(raw[10] = 0, "container-overflow");
614    EXPECT_DEATH_IF_SUPPORTED(raw[31] = 0, "container-overflow");
615  }
616  TEST(FixedArrayTest, AddressSanitizerAnnotations2) {
617    absl::FixedArray<char, 17> a(12);
618    char* raw = a.data();
619    raw[0] = 0;
620    raw[11] = 0;
621    EXPECT_DEATH_IF_SUPPORTED(raw[-7] = 0, "container-overflow");
622    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
623    EXPECT_DEATH_IF_SUPPORTED(raw[12] = 0, "container-overflow");
624    EXPECT_DEATH_IF_SUPPORTED(raw[17] = 0, "container-overflow");
625  }
626  TEST(FixedArrayTest, AddressSanitizerAnnotations3) {
627    absl::FixedArray<uint64_t, 20> a(20);
628    uint64_t* raw = a.data();
629    raw[0] = 0;
630    raw[19] = 0;
631    EXPECT_DEATH_IF_SUPPORTED(raw[-1] = 0, "container-overflow");
632    EXPECT_DEATH_IF_SUPPORTED(raw[20] = 0, "container-overflow");
633  }
634  TEST(FixedArrayTest, AddressSanitizerAnnotations4) {
635    absl::FixedArray<ThreeInts> a(10);
636    ThreeInts* raw = a.data();
637    raw[0] = ThreeInts();
638    raw[9] = ThreeInts();
639    EXPECT_DEATH_IF_SUPPORTED(raw[-1].z_ = 0, "container-overflow");
640    EXPECT_DEATH_IF_SUPPORTED(raw[10] = ThreeInts(), "container-overflow");
641    EXPECT_DEATH_IF_SUPPORTED(raw[21] = ThreeInts(), "container-overflow");
642  }
643  #endif  
644  TEST(FixedArrayTest, AbslHashValueWorks) {
645    using V = absl::FixedArray<int>;
646    std::vector<V> cases;
647    for (int i = 0; i < 10; ++i) {
648      V v(i);
649      for (int j = 0; j < i; ++j) {
650        v[j] = j;
651      }
652      cases.push_back(v);
653    }
654    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(cases));
655  }
656  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</h3>
            <pre><code>1  #if !defined(HAS_STRPTIME)
2  #if !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__VXWORKS__)
3  #define HAS_STRPTIME \
4    1  
5  #endif
6  #endif
7  #if defined(HAS_STRPTIME) && HAS_STRPTIME
8  #if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__)
9  #define _XOPEN_SOURCE  
10  #endif
11  #endif
12  #include "absl/base/config.h"
13  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
14  #include <time.h>
15  #include <cctype>
16  #include <chrono>
17  #include <cstddef>
18  #include <cstdint>
19  #include <cstring>
20  #include <ctime>
21  #include <limits>
22  #include <string>
23  #include <vector>
24  #if !HAS_STRPTIME
25  #include <iomanip>
26  #include <sstream>
27  #endif
28  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
29  #include "time_zone_if.h"
30  namespace absl {
31  ABSL_NAMESPACE_BEGIN
32  namespace time_internal {
33  namespace cctz {
34  namespace detail {
35  namespace {
36  #if !HAS_STRPTIME
37  char* strptime(const char* s, const char* fmt, std::tm* tm) {
38    std::istringstream input(s);
39    input >> std::get_time(tm, fmt);
40    if (input.fail()) return nullptr;
41    return const_cast<char*>(s) +
42           (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
43  }
44  #endif
45  int ToTmWday(weekday wd) {
46    switch (wd) {
47      case weekday::sunday:
48        return 0;
49      case weekday::monday:
50        return 1;
51      case weekday::tuesday:
52        return 2;
53      case weekday::wednesday:
54        return 3;
55      case weekday::thursday:
56        return 4;
57      case weekday::friday:
58        return 5;
59      case weekday::saturday:
60        return 6;
61    }
62    return 0; &bsol;*NOTREACHED*/
63  }
64  weekday FromTmWday(int tm_wday) {
65    switch (tm_wday) {
66      case 0:
67        return weekday::sunday;
68      case 1:
69        return weekday::monday;
70      case 2:
71        return weekday::tuesday;
72      case 3:
73        return weekday::wednesday;
74      case 4:
75        return weekday::thursday;
76      case 5:
77        return weekday::friday;
78      case 6:
79        return weekday::saturday;
80    }
81    return weekday::sunday; &bsol;*NOTREACHED*/
82  }
83  std::tm ToTM(const time_zone::absolute_lookup& al) {
84    std::tm tm{};
85    tm.tm_sec = al.cs.second();
86    tm.tm_min = al.cs.minute();
87    tm.tm_hour = al.cs.hour();
88    tm.tm_mday = al.cs.day();
89    tm.tm_mon = al.cs.month() - 1;
90    if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
91      tm.tm_year = std::numeric_limits<int>::min();
92    } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
93      tm.tm_year = std::numeric_limits<int>::max();
94    } else {
95      tm.tm_year = static_cast<int>(al.cs.year() - 1900);
96    }
97    tm.tm_wday = ToTmWday(get_weekday(al.cs));
98    tm.tm_yday = get_yearday(al.cs) - 1;
99    tm.tm_isdst = al.is_dst ? 1 : 0;
100    return tm;
101  }
102  int ToWeek(const civil_day& cd, weekday week_start) {
103    const civil_day d(cd.year() % 400, cd.month(), cd.day());
104    return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
105  }
106  const char kDigits[] = "0123456789";
107  char* Format64(char* ep, int width, std::int_fast64_t v) {
108    bool neg = false;
109    if (v < 0) {
110      --width;
111      neg = true;
112      if (v == std::numeric_limits<std::int_fast64_t>::min()) {
113        std::int_fast64_t last_digit = -(v % 10);
114        v /= 10;
115        if (last_digit < 0) {
116          ++v;
117          last_digit += 10;
118        }
119        --width;
120        *--ep = kDigits[last_digit];
121      }
122      v = -v;
123    }
124    do {
125      --width;
126      *--ep = kDigits[v % 10];
127    } while (v /= 10);
128    while (--width >= 0) *--ep = '0';  
129    if (neg) *--ep = '-';
130    return ep;
131  }
132  char* Format02d(char* ep, int v) {
133    *--ep = kDigits[v % 10];
134    *--ep = kDigits[(v / 10) % 10];
135    return ep;
136  }
137  char* FormatOffset(char* ep, int offset, const char* mode) {
138    char sign = '+';
139    if (offset < 0) {
140      offset = -offset;  
141      sign = '-';
142    }
143    const int seconds = offset % 60;
144    const int minutes = (offset /= 60) % 60;
145    const int hours = offset /= 60;
146    const char sep = mode[0];
147    const bool ext = (sep != '\0' && mode[1] == '*');
148    const bool ccc = (ext && mode[2] == ':');
149    if (ext && (!ccc || seconds != 0)) {
150      ep = Format02d(ep, seconds);
151      *--ep = sep;
152    } else {
153      if (hours == 0 && minutes == 0) sign = '+';
154    }
155    if (!ccc || minutes != 0 || seconds != 0) {
156      ep = Format02d(ep, minutes);
157      if (sep != '\0') *--ep = sep;
158    }
159    ep = Format02d(ep, hours);
160    *--ep = sign;
161    return ep;
162  }
163  void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
164    for (std::size_t i = 2; i != 32; i *= 2) {
165      std::size_t buf_size = fmt.size() * i;
166      std::vector<char> buf(buf_size);
167      if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
168        out->append(&buf[0], len);
169        return;
170      }
171    }
172  }
173  template <typename T>
174  const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
175    if (dp != nullptr) {
176      const T kmin = std::numeric_limits<T>::min();
177      bool erange = false;
178      bool neg = false;
179      T value = 0;
180      if (*dp == '-') {
181        neg = true;
182        if (width <= 0 || --width != 0) {
183          ++dp;
184        } else {
185          dp = nullptr;  
186        }
187      }
188      if (const char* const bp = dp) {
189        while (const char* cp = strchr(kDigits, *dp)) {
190          int d = static_cast<int>(cp - kDigits);
191          if (d >= 10) break;
192          if (value < kmin / 10) {
193            erange = true;
194            break;
195          }
196          value *= 10;
197          if (value < kmin + d) {
198            erange = true;
199            break;
200          }
201          value -= d;
202          dp += 1;
203          if (width > 0 && --width == 0) break;
204        }
205        if (dp != bp && !erange && (neg || value != kmin)) {
206          if (!neg || value != 0) {
207            if (!neg) value = -value;  
208            if (min <= value && value <= max) {
209              *vp = value;
210            } else {
211              dp = nullptr;
212            }
213          } else {
214            dp = nullptr;
215          }
216        } else {
217          dp = nullptr;
218        }
219      }
220    }
221    return dp;
222  }
223  const int kDigits10_64 = 18;
224  const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
225      1,
226      10,
227      100,
228      1000,
229      10000,
230      100000,
231      1000000,
232      10000000,
233      100000000,
234      1000000000,
235      10000000000,
236      100000000000,
237      1000000000000,
238      10000000000000,
239      100000000000000,
240      1000000000000000,
241      10000000000000000,
242      100000000000000000,
243      1000000000000000000,
244  };
245  }  
246  std::string format(const std::string& format, const time_point<seconds>& tp,
247                     const detail::femtoseconds& fs, const time_zone& tz) {
248    std::string result;
249    result.reserve(format.size());  
250    const time_zone::absolute_lookup al = tz.lookup(tp);
251    const std::tm tm = ToTM(al);
252    char buf[3 + kDigits10_64];  
253    char* const ep = buf + sizeof(buf);
254    char* bp;  
255    const char* pending = format.c_str();  
256    const char* cur = pending;
257    const char* end = pending + format.length();
258    while (cur != end) {  
259      const char* start = cur;
260      while (cur != end && *cur != '%') ++cur;
261      if (cur != start && pending == start) {
262        result.append(pending, static_cast<std::size_t>(cur - pending));
263        pending = start = cur;
264      }
265      const char* percent = cur;
266      while (cur != end && *cur == '%') ++cur;
267      if (cur != start && pending == start) {
268        std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
269        result.append(pending, escaped);
270        pending += escaped * 2;
271        if (pending != cur && cur == end) {
272          result.push_back(*pending++);
273        }
274      }
275      if (cur == end || (cur - percent) % 2 == 0) continue;
276      if (strchr("YmdeUuWwHMSzZs%", *cur)) {
277        if (cur - 1 != pending) {
278          FormatTM(&result, std::string(pending, cur - 1), tm);
279        }
280        switch (*cur) {
281          case 'Y':
282            bp = Format64(ep, 0, al.cs.year());
283            result.append(bp, static_cast<std::size_t>(ep - bp));
284            break;
285          case 'm':
286            bp = Format02d(ep, al.cs.month());
287            result.append(bp, static_cast<std::size_t>(ep - bp));
288            break;
289          case 'd':
290          case 'e':
291            bp = Format02d(ep, al.cs.day());
292            if (*cur == 'e' && *bp == '0') *bp = ' ';  
293            result.append(bp, static_cast<std::size_t>(ep - bp));
294            break;
295          case 'U':
296            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
297            result.append(bp, static_cast<std::size_t>(ep - bp));
298            break;
299          case 'u':
300            bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
301            result.append(bp, static_cast<std::size_t>(ep - bp));
302            break;
303          case 'W':
304            bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
305            result.append(bp, static_cast<std::size_t>(ep - bp));
306            break;
307          case 'w':
308            bp = Format64(ep, 0, tm.tm_wday);
309            result.append(bp, static_cast<std::size_t>(ep - bp));
310            break;
311          case 'H':
312            bp = Format02d(ep, al.cs.hour());
313            result.append(bp, static_cast<std::size_t>(ep - bp));
314            break;
315          case 'M':
316            bp = Format02d(ep, al.cs.minute());
317            result.append(bp, static_cast<std::size_t>(ep - bp));
318            break;
319          case 'S':
320            bp = Format02d(ep, al.cs.second());
321            result.append(bp, static_cast<std::size_t>(ep - bp));
322            break;
323          case 'z':
324            bp = FormatOffset(ep, al.offset, "");
325            result.append(bp, static_cast<std::size_t>(ep - bp));
326            break;
327          case 'Z':
328            result.append(al.abbr);
329            break;
330          case 's':
331            bp = Format64(ep, 0, ToUnixSeconds(tp));
332            result.append(bp, static_cast<std::size_t>(ep - bp));
333            break;
334          case '%':
335            result.push_back('%');
336            break;
337        }
338        pending = ++cur;
339        continue;
340      }
341      if (*cur == ':' && cur + 1 != end) {
342        if (*(cur + 1) == 'z') {
343          if (cur - 1 != pending) {
344            FormatTM(&result, std::string(pending, cur - 1), tm);
345          }
346          bp = FormatOffset(ep, al.offset, ":");
347          result.append(bp, static_cast<std::size_t>(ep - bp));
348          pending = cur += 2;
349          continue;
350        }
351        if (*(cur + 1) == ':' && cur + 2 != end) {
352          if (*(cur + 2) == 'z') {
353            if (cur - 1 != pending) {
354              FormatTM(&result, std::string(pending, cur - 1), tm);
355            }
356            bp = FormatOffset(ep, al.offset, ":*");
357            result.append(bp, static_cast<std::size_t>(ep - bp));
358            pending = cur += 3;
359            continue;
360          }
361          if (*(cur + 2) == ':' && cur + 3 != end) {
362            if (*(cur + 3) == 'z') {
363              if (cur - 1 != pending) {
364                FormatTM(&result, std::string(pending, cur - 1), tm);
365              }
366              bp = FormatOffset(ep, al.offset, ":*:");
367              result.append(bp, static_cast<std::size_t>(ep - bp));
368              pending = cur += 4;
369              continue;
370            }
371          }
372        }
373      }
374      if (*cur != 'E' || ++cur == end) continue;
375      if (*cur == 'T') {
376        if (cur - 2 != pending) {
377          FormatTM(&result, std::string(pending, cur - 2), tm);
378        }
379        result.append("T");
380        pending = ++cur;
381      } else if (*cur == 'z') {
382        if (cur - 2 != pending) {
383          FormatTM(&result, std::string(pending, cur - 2), tm);
384        }
385        bp = FormatOffset(ep, al.offset, ":");
386        result.append(bp, static_cast<std::size_t>(ep - bp));
387        pending = ++cur;
388      } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
389        if (cur - 2 != pending) {
390          FormatTM(&result, std::string(pending, cur - 2), tm);
391        }
392        bp = FormatOffset(ep, al.offset, ":*");
393        result.append(bp, static_cast<std::size_t>(ep - bp));
394        pending = cur += 2;
395      } else if (*cur == '*' && cur + 1 != end &&
396                 (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
397        if (cur - 2 != pending) {
398          FormatTM(&result, std::string(pending, cur - 2), tm);
399        }
400        char* cp = ep;
401        bp = Format64(cp, 15, fs.count());
402        while (cp != bp && cp[-1] == '0') --cp;
403        switch (*(cur + 1)) {
404          case 'S':
405            if (cp != bp) *--bp = '.';
406            bp = Format02d(bp, al.cs.second());
407            break;
408          case 'f':
409            if (cp == bp) *--bp = '0';
410            break;
411        }
412        result.append(bp, static_cast<std::size_t>(cp - bp));
413        pending = cur += 2;
414      } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
415        if (cur - 2 != pending) {
416          FormatTM(&result, std::string(pending, cur - 2), tm);
417        }
418        bp = Format64(ep, 4, al.cs.year());
419        result.append(bp, static_cast<std::size_t>(ep - bp));
420        pending = cur += 2;
421      } else if (std::isdigit(*cur)) {
422        int n = 0;
423        if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
424          if (*np == 'S' || *np == 'f') {
425            if (cur - 2 != pending) {
426              FormatTM(&result, std::string(pending, cur - 2), tm);
427            }
428            bp = ep;
429            if (n > 0) {
430              if (n > kDigits10_64) n = kDigits10_64;
431              bp = Format64(bp, n,
432                            (n > 15) ? fs.count() * kExp10[n - 15]
433                                     : fs.count() / kExp10[15 - n]);
434              if (*np == 'S') *--bp = '.';
435            }
436            if (*np == 'S') bp = Format02d(bp, al.cs.second());
437            result.append(bp, static_cast<std::size_t>(ep - bp));
438            pending = cur = ++np;
439          }
440        }
441      }
442    }
443    if (end != pending) {
444      FormatTM(&result, std::string(pending, end), tm);
445    }
446    return result;
447  }
448  namespace {
449  const char* ParseOffset(const char* dp, const char* mode, int* offset) {
450    if (dp != nullptr) {
451      const char first = *dp++;
452      if (first == '+' || first == '-') {
453        char sep = mode[0];
454        int hours = 0;
455        int minutes = 0;
456        int seconds = 0;
457        const char* ap = ParseInt(dp, 2, 0, 23, &hours);
458        if (ap != nullptr && ap - dp == 2) {
459          dp = ap;
460          if (sep != '\0' && *ap == sep) ++ap;
461          const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
462          if (bp != nullptr && bp - ap == 2) {
463            dp = bp;
464            if (sep != '\0' && *bp == sep) ++bp;
465            const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
466            if (cp != nullptr && cp - bp == 2) dp = cp;
467          }
468          *offset = ((hours * 60 + minutes) * 60) + seconds;
469          if (first == '-') *offset = -*offset;
470        } else {
471          dp = nullptr;
472        }
473      } else if (first == 'Z' || first == 'z') {  
474        *offset = 0;
475      } else {
476        dp = nullptr;
477      }
478    }
479    return dp;
480  }
481  const char* ParseZone(const char* dp, std::string* zone) {
482    zone->clear();
483    if (dp != nullptr) {
484      while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
485      if (zone->empty()) dp = nullptr;
486    }
487    return dp;
488  }
489  const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
490    if (dp != nullptr) {
491      std::int_fast64_t v = 0;
492      std::int_fast64_t exp = 0;
493      const char* const bp = dp;
494      while (const char* cp = strchr(kDigits, *dp)) {
495        int d = static_cast<int>(cp - kDigits);
496        if (d >= 10) break;
497        if (exp < 15) {
498          exp += 1;
499          v *= 10;
500          v += d;
501        }
502        ++dp;
503      }
504      if (dp != bp) {
505        v *= kExp10[15 - exp];
506        *subseconds = detail::femtoseconds(v);
507      } else {
508        dp = nullptr;
509      }
510    }
511    return dp;
512  }
513  const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
514    if (dp != nullptr) {
515      dp = strptime(dp, fmt, tm);
516    }
517    return dp;
518  }
519  bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
520    const civil_year y(*year % 400);
521    civil_day cd = prev_weekday(y, week_start);  
522    cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
523    if (const year_t shift = cd.year() - y.year()) {
524      if (shift > 0) {
525        if (*year > std::numeric_limits<year_t>::max() - shift) return false;
526      } else {
527        if (*year < std::numeric_limits<year_t>::min() - shift) return false;
528      }
529      *year += shift;
530    }
531    tm->tm_mon = cd.month() - 1;
532    tm->tm_mday = cd.day();
533    return true;
534  }
535  }  
536  bool parse(const std::string& format, const std::string& input,
537             const time_zone& tz, time_point<seconds>* sec,
538             detail::femtoseconds* fs, std::string* err) {
539    const char* data = input.c_str();  
540    while (std::isspace(*data)) ++data;
541    const year_t kyearmax = std::numeric_limits<year_t>::max();
542    const year_t kyearmin = std::numeric_limits<year_t>::min();
543    bool saw_year = false;
544    year_t year = 1970;
545    std::tm tm{};
546    tm.tm_year = 1970 - 1900;
547    tm.tm_mon = 1 - 1;  
548    tm.tm_mday = 1;
549    tm.tm_hour = 0;
550    tm.tm_min = 0;
551    tm.tm_sec = 0;
552    tm.tm_wday = 4;  
553    tm.tm_yday = 0;
554    tm.tm_isdst = 0;
555    auto subseconds = detail::femtoseconds::zero();
556    bool saw_offset = false;
557    int offset = 0;  
558    std::string zone = "UTC";
559    const char* fmt = format.c_str();  
<span onclick='openModal()' class='match'>560    bool twelve_hour = false;
561    bool afternoon = false;
562    int week_num = -1;
563    weekday week_start = weekday::sunday;
564    bool saw_percent_s = false;
</span>565    std::int_fast64_t percent_s = 0;
566    while (data != nullptr && *fmt != '\0') {
567      if (std::isspace(*fmt)) {
568        while (std::isspace(*data)) ++data;
569        while (std::isspace(*++fmt)) continue;
570        continue;
571      }
572      if (*fmt != '%') {
573        if (*data == *fmt) {
574          ++data;
575          ++fmt;
576        } else {
577          data = nullptr;
578        }
579        continue;
580      }
581      const char* percent = fmt;
582      if (*++fmt == '\0') {
583        data = nullptr;
584        continue;
585      }
586      switch (*fmt++) {
587        case 'Y':
588          data = ParseInt(data, 0, kyearmin, kyearmax, &year);
589          if (data != nullptr) saw_year = true;
590          continue;
591        case 'm':
592          data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
593          if (data != nullptr) tm.tm_mon -= 1;
594          week_num = -1;
595          continue;
596        case 'd':
597        case 'e':
598          data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
599          week_num = -1;
600          continue;
601        case 'U':
602          data = ParseInt(data, 0, 0, 53, &week_num);
603          week_start = weekday::sunday;
604          continue;
605        case 'W':
606          data = ParseInt(data, 0, 0, 53, &week_num);
607          week_start = weekday::monday;
608          continue;
609        case 'u':
610          data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
611          if (data != nullptr) tm.tm_wday %= 7;
612          continue;
613        case 'w':
614          data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
615          continue;
616        case 'H':
617          data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
618          twelve_hour = false;
619          continue;
620        case 'M':
621          data = ParseInt(data, 2, 0, 59, &tm.tm_min);
622          continue;
623        case 'S':
624          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
625          continue;
626        case 'I':
627        case 'l':
628        case 'r':  
629          twelve_hour = true;
630          break;
631        case 'R':  
632        case 'T':  
633        case 'c':  
634        case 'X':  
635          twelve_hour = false;
636          break;
637        case 'z':
638          data = ParseOffset(data, "", &offset);
639          if (data != nullptr) saw_offset = true;
640          continue;
641        case 'Z':  
642          data = ParseZone(data, &zone);
643          continue;
644        case 's':
645          data =
646              ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
647                       std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
648          if (data != nullptr) saw_percent_s = true;
649          continue;
650        case ':':
651          if (fmt[0] == 'z' ||
652              (fmt[0] == ':' &&
653               (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
654            data = ParseOffset(data, ":", &offset);
655            if (data != nullptr) saw_offset = true;
656            fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
657            continue;
658          }
659          break;
660        case '%':
661          data = (*data == '%' ? data + 1 : nullptr);
662          continue;
663        case 'E':
664          if (fmt[0] == 'T') {
665            if (*data == 'T' || *data == 't') {
666              ++data;
667              ++fmt;
668            } else {
669              data = nullptr;
670            }
671            continue;
672          }
673          if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
674            data = ParseOffset(data, ":", &offset);
675            if (data != nullptr) saw_offset = true;
676            fmt += (fmt[0] == 'z') ? 1 : 2;
677            continue;
678          }
679          if (fmt[0] == '*' && fmt[1] == 'S') {
680            data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
681            if (data != nullptr && *data == '.') {
682              data = ParseSubSeconds(data + 1, &subseconds);
683            }
684            fmt += 2;
685            continue;
686          }
687          if (fmt[0] == '*' && fmt[1] == 'f') {
688            if (data != nullptr && std::isdigit(*data)) {
689              data = ParseSubSeconds(data, &subseconds);
690            }
691            fmt += 2;
692            continue;
693          }
694          if (fmt[0] == '4' && fmt[1] == 'Y') {
695            const char* bp = data;
696            data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
697            if (data != nullptr) {
698              if (data - bp == 4) {
699                saw_year = true;
700              } else {
701                data = nullptr;  
702              }
703            }
704            fmt += 2;
705            continue;
706          }
707          if (std::isdigit(*fmt)) {
708            int n = 0;  
709            if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
710              if (*np == 'S') {
711                data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
712                if (data != nullptr && *data == '.') {
713                  data = ParseSubSeconds(data + 1, &subseconds);
714                }
715                fmt = ++np;
716                continue;
717              }
718              if (*np == 'f') {
719                if (data != nullptr && std::isdigit(*data)) {
720                  data = ParseSubSeconds(data, &subseconds);
721                }
722                fmt = ++np;
723                continue;
724              }
725            }
726          }
727          if (*fmt == 'c') twelve_hour = false;  
728          if (*fmt == 'X') twelve_hour = false;  
729          if (*fmt != '\0') ++fmt;
730          break;
731        case 'O':
732          if (*fmt == 'H') twelve_hour = false;
733          if (*fmt == 'I') twelve_hour = true;
734          if (*fmt != '\0') ++fmt;
735          break;
736      }
737      const char* orig_data = data;
738      std::string spec(percent, static_cast<std::size_t>(fmt - percent));
739      data = ParseTM(data, spec.c_str(), &tm);
740      if (spec == "%p" && data != nullptr) {
741        std::string test_input = "1";
742        test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
743        const char* test_data = test_input.c_str();
744        std::tm tmp{};
745        ParseTM(test_data, "%I%p", &tmp);
746        afternoon = (tmp.tm_hour == 13);
747      }
748    }
749    if (twelve_hour && afternoon && tm.tm_hour < 12) {
750      tm.tm_hour += 12;
751    }
752    if (data == nullptr) {
753      if (err != nullptr) *err = "Failed to parse input";
754      return false;
755    }
756    while (std::isspace(*data)) ++data;
757    if (*data != '\0') {
758      if (err != nullptr) *err = "Illegal trailing data in input string";
759      return false;
760    }
761    if (saw_percent_s) {
762      *sec = FromUnixSeconds(percent_s);
763      *fs = detail::femtoseconds::zero();
764      return true;
765    }
766    time_zone ptz = saw_offset ? utc_time_zone() : tz;
767    if (tm.tm_sec == 60) {
768      tm.tm_sec -= 1;
769      offset -= 1;
770      subseconds = detail::femtoseconds::zero();
771    }
772    if (!saw_year) {
773      year = year_t{tm.tm_year};
774      if (year > kyearmax - 1900) {
775        if (err != nullptr) *err = "Out-of-range year";
776        return false;
777      }
778      year += 1900;
779    }
780    if (week_num != -1) {
781      if (!FromWeek(week_num, week_start, &year, &tm)) {
782        if (err != nullptr) *err = "Out-of-range field";
783        return false;
784      }
785    }
786    const int month = tm.tm_mon + 1;
787    civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
788    if (cs.month() != month || cs.day() != tm.tm_mday) {
789      if (err != nullptr) *err = "Out-of-range field";
790      return false;
791    }
792    if ((offset < 0 && cs > civil_second::max() + offset) ||
793        (offset > 0 && cs < civil_second::min() + offset)) {
794      if (err != nullptr) *err = "Out-of-range field";
795      return false;
796    }
797    cs -= offset;
798    const auto tp = ptz.lookup(cs).pre;
799    if (tp == time_point<seconds>::max()) {
800      const auto al = ptz.lookup(time_point<seconds>::max());
801      if (cs > al.cs) {
802        if (err != nullptr) *err = "Out-of-range field";
803        return false;
804      }
805    }
806    if (tp == time_point<seconds>::min()) {
807      const auto al = ptz.lookup(time_point<seconds>::min());
808      if (cs < al.cs) {
809        if (err != nullptr) *err = "Out-of-range field";
810        return false;
811      }
812    }
813    *sec = tp;
814    *fs = subseconds;
815    return true;
816  }
817  }  
818  }  
819  }  
820  ABSL_NAMESPACE_END
821  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fixed_array_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format.cc</div>
                </div>
                <div class="column column_space"><pre><code>550    constexpr size_t inlined_size = 4;
551    using Alloc = absl::container_internal::CountingAllocator<int>;
552    using AllocFxdArr = absl::FixedArray<int, inlined_size, Alloc>;
553    int64_t allocated1 = 0;
554    int64_t allocated2 = 0;
555    int64_t active_instances = 0;
556    Alloc alloc(&allocated1, &active_instances);
</pre></code></div>
                <div class="column column_space"><pre><code>560    bool twelve_hour = false;
561    bool afternoon = false;
562    int week_num = -1;
563    weekday week_start = weekday::sunday;
564    bool saw_percent_s = false;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    