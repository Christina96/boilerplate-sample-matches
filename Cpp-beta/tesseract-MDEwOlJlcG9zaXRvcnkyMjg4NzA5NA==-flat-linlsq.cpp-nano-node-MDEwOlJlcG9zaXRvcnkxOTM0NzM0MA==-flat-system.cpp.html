
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.090909090909092%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linlsq.cpp</h3>
            <pre><code>1  #include "linlsq.h"
2  #include <cmath> 
3  #include <cstdio>
4  #include "errcode.h"
5  namespace tesseract {
6  constexpr ERRCODE EMPTY_LLSQ("Can't delete from an empty LLSQ");
7  void LLSQ::clear() {  
8    total_weight = 0.0; 
9    sigx = 0.0;         
10    sigy = 0.0;
11    sigxx = 0.0;
12    sigxy = 0.0;
13    sigyy = 0.0;
14  }
15  void LLSQ::add(double x, double y) { 
16    total_weight++;                    
17    sigx += x;                         
18    sigy += y;
19    sigxx += x * x;
20    sigxy += x * y;
21    sigyy += y * y;
22  }
23  void LLSQ::add(double x, double y, double weight) {
24    total_weight += weight;
25    sigx += x * weight; 
26    sigy += y * weight;
27    sigxx += x * x * weight;
28    sigxy += x * y * weight;
29    sigyy += y * y * weight;
30  }
31  void LLSQ::add(const LLSQ &other) {
32    total_weight += other.total_weight;
33    sigx += other.sigx; 
34    sigy += other.sigy;
35    sigxx += other.sigxx;
36    sigxy += other.sigxy;
37    sigyy += other.sigyy;
38  }
39  void LLSQ::remove(double x, double y) { 
40    if (total_weight <= 0.0) {            
41      EMPTY_LLSQ.error("LLSQ::remove", ABORT);
42    }
43    total_weight--; 
44    sigx -= x;      
45    sigy -= y;
46    sigxx -= x * x;
47    sigxy -= x * y;
48    sigyy -= y * y;
49  }
50  double LLSQ::m() const { 
51    double covar = covariance();
52    double x_var = x_variance();
53    if (x_var != 0.0) {
54      return covar / x_var;
55    } else {
56      return 0.0; 
57    }
58  }
59  double LLSQ::c(double m) const { 
60    if (total_weight > 0.0) {
61      return (sigy - m * sigx) / total_weight;
62    } else {
63      return 0; 
64    }
65  }
66  double LLSQ::rms(double m, double c) const { 
67    double error;                              
68    if (total_weight > 0) {
69      error = sigyy + m * (m * sigxx + 2 * (c * sigx - sigxy)) + c * (total_weight * c - 2 * sigy);
70      if (error >= 0) {
71        error = std::sqrt(error / total_weight); 
72      } else {
73        error = 0;
74      }
75    } else {
76      error = 0; 
77    }
78    return error;
79  }
80  double LLSQ::pearson() const { 
81    double r = 0.0;              
82    double covar = covariance();
83    if (covar != 0.0) {
84      double var_product = x_variance() * y_variance();
85      if (var_product > 0.0) {
86        r = covar / std::sqrt(var_product);
87      }
88    }
89    return r;
90  }
91  FCOORD LLSQ::mean_point() const {
92    if (total_weight > 0.0) {
93      return FCOORD(sigx / total_weight, sigy / total_weight);
94    } else {
95      return FCOORD(0.0f, 0.0f);
96    }
97  }
98  double LLSQ::rms_orth(const FCOORD &dir) const {
99    FCOORD v = !dir;
100    v.normalise();
101    return std::sqrt(x_variance() * v.x() * v.x() + 2 * covariance() * v.x() * v.y() +
102                     y_variance() * v.y() * v.y());
103  }
104  FCOORD LLSQ::vector_fit() const {
105    double x_var = x_variance();
106    double y_var = y_variance();
<span onclick='openModal()' class='match'>107    double covar = covariance();
108    double theta = 0.5 * atan2(2.0 * covar, x_var - y_var);
109    FCOORD result(cos(theta), sin(theta));
</span>110    return result;
111  }
112  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-system.cpp</h3>
            <pre><code>1  #include <nano/node/transport/inproc.hpp>
2  #include <nano/test_common/network.hpp>
3  #include <nano/test_common/system.hpp>
4  #include <nano/test_common/testutil.hpp>
5  #include <gtest/gtest.h>
6  using namespace std::chrono_literals;
7  TEST (system, work_generate_limited)
8  {
9  	nano::test::system system;
10  	nano::block_hash key (1);
11  	auto min = nano::dev::network_params.work.entry;
12  	auto max = nano::dev::network_params.work.base;
13  	for (int i = 0; i < 5; ++i)
14  	{
<span onclick='openModal()' class='match'>15  		auto work = system.work_generate_limited (key, min, max);
16  		auto difficulty = nano::dev::network_params.work.difficulty (nano::work_version::work_1, key, work);
17  		ASSERT_GE (difficulty, min);
</span>18  		ASSERT_LT (difficulty, max);
19  	}
20  }
21  TEST (system, system_genesis)
22  {
23  	nano::test::system system (2);
24  	for (auto & i : system.nodes)
25  	{
26  		auto transaction (i->store.tx_begin_read ());
27  		ASSERT_EQ (nano::dev::constants.genesis_amount, i->ledger.account_balance (transaction, nano::dev::genesis->account ()));
28  	}
29  }
30  TEST (system, DISABLED_generate_send_existing)
31  {
32  	nano::test::system system (1);
33  	auto & node1 (*system.nodes[0]);
34  	nano::thread_runner runner (system.io_ctx, node1.config.io_threads);
35  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
36  	nano::keypair stake_preserver;
37  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis->account (), stake_preserver.pub, nano::dev::constants.genesis_amount / 3 * 2, true));
38  	auto info1 = node1.ledger.account_info (node1.store.tx_begin_read (), nano::dev::genesis_key.pub);
39  	ASSERT_TRUE (info1);
40  	std::vector<nano::account> accounts;
41  	accounts.push_back (nano::dev::genesis_key.pub);
42  	system.generate_send_existing (node1, accounts);
43  	{
44  		auto transaction (node1.store.tx_begin_write ());
45  		nano::block_builder builder;
46  		auto open_block = builder
47  						  .open ()
48  						  .source (send_block->hash ())
49  						  .representative (nano::dev::genesis->account ())
50  						  .account (stake_preserver.pub)
51  						  .sign (stake_preserver.prv, stake_preserver.pub)
52  						  .work (0)
53  						  .build_shared ();
54  		node1.work_generate_blocking (*open_block);
55  		ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *open_block).code);
56  	}
57  	ASSERT_GT (node1.balance (stake_preserver.pub), node1.balance (nano::dev::genesis->account ()));
58  	auto info2 = node1.ledger.account_info (node1.store.tx_begin_read (), nano::dev::genesis_key.pub);
59  	ASSERT_TRUE (info2);
60  	ASSERT_NE (info1->head, info2->head);
61  	system.deadline_set (15s);
62  	while (info2->block_count < info1->block_count + 2)
63  	{
64  		ASSERT_NO_ERROR (system.poll ());
65  		auto transaction (node1.store.tx_begin_read ());
66  		info2 = node1.ledger.account_info (transaction, nano::dev::genesis_key.pub);
67  		ASSERT_TRUE (info2);
68  	}
69  	ASSERT_EQ (info1->block_count + 2, info2->block_count);
70  	ASSERT_EQ (info2->balance, nano::dev::constants.genesis_amount / 3);
71  	{
72  		auto transaction (node1.store.tx_begin_read ());
73  		ASSERT_NE (node1.ledger.amount (transaction, info2->head), 0);
74  	}
75  	system.stop ();
76  	runner.join ();
77  }
78  TEST (system, DISABLED_generate_send_new)
79  {
80  	nano::test::system system (1);
81  	auto & node1 (*system.nodes[0]);
82  	nano::thread_runner runner (system.io_ctx, node1.config.io_threads);
83  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
84  	{
85  		auto transaction (node1.store.tx_begin_read ());
86  		auto iterator1 (node1.store.account.begin (transaction));
87  		ASSERT_NE (node1.store.account.end (), iterator1);
88  		++iterator1;
89  		ASSERT_EQ (node1.store.account.end (), iterator1);
90  	}
91  	nano::keypair stake_preserver;
92  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis->account (), stake_preserver.pub, nano::dev::constants.genesis_amount / 3 * 2, true));
93  	{
94  		auto transaction (node1.store.tx_begin_write ());
95  		nano::block_builder builder;
96  		auto open_block = builder
97  						  .open ()
98  						  .source (send_block->hash ())
99  						  .representative (nano::dev::genesis->account ())
100  						  .account (stake_preserver.pub)
101  						  .sign (stake_preserver.prv, stake_preserver.pub)
102  						  .work (0)
103  						  .build_shared ();
104  		node1.work_generate_blocking (*open_block);
105  		ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *open_block).code);
106  	}
107  	ASSERT_GT (node1.balance (stake_preserver.pub), node1.balance (nano::dev::genesis->account ()));
108  	std::vector<nano::account> accounts;
109  	accounts.push_back (nano::dev::genesis_key.pub);
110  	ASSERT_TIMELY (5s, node1.wallets.reps ().voting > 0);
111  	system.generate_send_new (node1, accounts);
112  	nano::account new_account{};
113  	{
114  		auto transaction (node1.wallets.tx_begin_read ());
115  		auto iterator2 (system.wallet (0)->store.begin (transaction));
116  		if (iterator2->first != nano::dev::genesis_key.pub)
117  		{
118  			new_account = iterator2->first;
119  		}
120  		++iterator2;
121  		ASSERT_NE (system.wallet (0)->store.end (), iterator2);
122  		if (iterator2->first != nano::dev::genesis_key.pub)
123  		{
124  			new_account = iterator2->first;
125  		}
126  		++iterator2;
127  		ASSERT_EQ (system.wallet (0)->store.end (), iterator2);
128  		ASSERT_FALSE (new_account.is_zero ());
129  	}
130  	ASSERT_TIMELY (10s, node1.balance (new_account) != 0);
131  	system.stop ();
132  	runner.join ();
133  }
134  TEST (system, rep_initialize_one)
135  {
136  	nano::test::system system;
137  	nano::keypair key;
138  	system.ledger_initialization_set ({ key });
139  	auto node = system.add_node ();
140  	ASSERT_EQ (nano::dev::constants.genesis_amount, node->balance (key.pub));
141  }
142  TEST (system, rep_initialize_two)
143  {
144  	nano::test::system system;
145  	nano::keypair key0;
146  	nano::keypair key1;
147  	system.ledger_initialization_set ({ key0, key1 });
148  	auto node = system.add_node ();
149  	ASSERT_EQ (nano::dev::constants.genesis_amount / 2, node->balance (key0.pub));
150  	ASSERT_EQ (nano::dev::constants.genesis_amount / 2, node->balance (key1.pub));
151  }
152  TEST (system, rep_initialize_one_reserve)
153  {
154  	nano::test::system system;
155  	nano::keypair key;
156  	system.ledger_initialization_set ({ key }, nano::Gxrb_ratio);
157  	auto node = system.add_node ();
158  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, node->balance (key.pub));
159  	ASSERT_EQ (nano::Gxrb_ratio, node->balance (nano::dev::genesis_key.pub));
160  }
161  TEST (system, rep_initialize_two_reserve)
162  {
163  	nano::test::system system;
164  	nano::keypair key0;
165  	nano::keypair key1;
166  	system.ledger_initialization_set ({ key0, key1 }, nano::Gxrb_ratio);
167  	auto node = system.add_node ();
168  	ASSERT_EQ ((nano::dev::constants.genesis_amount - nano::Gxrb_ratio) / 2, node->balance (key0.pub));
169  	ASSERT_EQ ((nano::dev::constants.genesis_amount - nano::Gxrb_ratio) / 2, node->balance (key1.pub));
170  }
171  TEST (system, rep_initialize_many)
172  {
173  	nano::test::system system;
174  	nano::keypair key0;
175  	nano::keypair key1;
176  	system.ledger_initialization_set ({ key0, key1 }, nano::Gxrb_ratio);
177  	auto node0 = system.add_node ();
178  	ASSERT_EQ ((nano::dev::constants.genesis_amount - nano::Gxrb_ratio) / 2, node0->balance (key0.pub));
179  	ASSERT_EQ ((nano::dev::constants.genesis_amount - nano::Gxrb_ratio) / 2, node0->balance (key1.pub));
180  	auto node1 = system.add_node ();
181  	ASSERT_EQ ((nano::dev::constants.genesis_amount - nano::Gxrb_ratio) / 2, node1->balance (key0.pub));
182  	ASSERT_EQ ((nano::dev::constants.genesis_amount - nano::Gxrb_ratio) / 2, node1->balance (key1.pub));
183  }
184  TEST (system, transport_basic)
185  {
186  	nano::test::system system{ 1 };
187  	auto & node0 = *system.nodes[0];
188  	nano::test::system system1{ 1 };
189  	auto & node1 = *system1.nodes[0];
190  	ASSERT_EQ (0, node1.stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in));
191  	nano::transport::inproc::channel channel{ node0, node1 };
192  	nano::keepalive junk{ nano::dev::network_params.network };
193  	channel.send (junk);
194  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in) > 0);
195  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linlsq.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-system.cpp</div>
                </div>
                <div class="column column_space"><pre><code>107    double covar = covariance();
108    double theta = 0.5 * atan2(2.0 * covar, x_var - y_var);
109    FCOORD result(cos(theta), sin(theta));
</pre></code></div>
                <div class="column column_space"><pre><code>15  		auto work = system.work_generate_limited (key, min, max);
16  		auto difficulty = nano::dev::network_params.work.difficulty (nano::work_version::work_1, key, work);
17  		ASSERT_GE (difficulty, min);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    