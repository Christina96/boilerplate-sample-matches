
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.909630886720407%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-os.cpp</h3>
            <pre><code>1  #ifdef GLib_WIN
2  void TSysProc::Sleep(const uint& MSecs){
3    SleepEx(MSecs, false);
4  }
5  TStr TSysProc::GetExeFNm(){
6    DWORD MxFNmLen=1024;
7    LPTSTR FNmCStr=new char[MxFNmLen];
8    DWORD FNmLen=GetModuleFileName(NULL, FNmCStr, MxFNmLen);
9    TStr FNm;
10    if (FNmLen!=0){
11      FNm=FNmCStr;}
12    delete[] FNmCStr;
13    return FNm;
14  }
15  void TSysProc::SetLowPriority(){
16    SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS);
17  }
18  bool TSysProc::ExeProc(const TStr& ExeFNm, TStr& ParamStr){
19    STARTUPINFO si;
20    PROCESS_INFORMATION pi;
21    ZeroMemory(&si, sizeof(si));
22    si.cb=sizeof(si);
23    ZeroMemory(&pi, sizeof(pi));
24    BOOL Ok=CreateProcess(
25     ExeFNm.CStr(),    
26     ParamStr.CStr(),  
27     NULL,             
28     NULL,             
29     FALSE,            
30     0,                
31     NULL,             
32     NULL,             
33     &si,              
34     &pi);             
35    if (Ok){
36      WaitForSingleObject( pi.hProcess, INFINITE );
37      CloseHandle( pi.hProcess );
38      CloseHandle( pi.hThread );
39      return true;
40    } else {
41      return false;
42    }
43  }
44  TStr TSysMemStat::GetLoadStr(){
45    static TStr MemUsageStr="Mem Load: ";
46    TChA ChA;
47    ChA+=MemUsageStr;
48    ChA+=TUInt64::GetStr(GetLoad());
49    ChA+="%";
50    return ChA;
51  }
52  TStr TSysMemStat::GetUsageStr(){
53    static TStr MemUsageStr="Mem Usage: ";
54    uint64 GlobalUsage=GetTotalPageFile()-GetAvailPageFile();
55    TChA ChA;
56    ChA+=MemUsageStr;
57    ChA+=TUInt64::GetStr(GlobalUsage/1024);
58    ChA+="K / ";
59    ChA+=TUInt64::GetStr(GetTotalPageFile()/1024);
60    ChA+="K";
61    return ChA;
62  }
63  TStr TSysMemStat::GetInfoStr(){
64    TChA ChA;
65    ChA+="Memory Load:";
66    ChA+=TUInt64::GetMegaStr(GetLoad()); ChA+="\r\n";
67    ChA+="Total Physical:";
68    ChA+=TUInt64::GetMegaStr(GetTotalPhys()); ChA+="\r\n";
69    ChA+="Available Physical:";
70    ChA+=TUInt64::GetMegaStr(GetAvailPhys()); ChA+="\r\n";
71    ChA+="Total Page File:";
72    ChA+=TUInt64::GetMegaStr(GetTotalPageFile()); ChA+="\r\n";
73    ChA+="Available Page File:";
74    ChA+=TUInt64::GetMegaStr(GetAvailPageFile()); ChA+="\r\n";
75    ChA+="Total Virtual:";
76    ChA+=TUInt64::GetMegaStr(GetTotalVirtual()); ChA+="\r\n";
77    ChA+="Available Virtual:";
78    ChA+=TUInt64::GetMegaStr(GetAvailVirtual()); ChA+="\r\n";
79    return ChA;
80  }
81  TStr TSysMemStat::GetStr(){
82    TChA ChA;
83    ChA+=TUInt64::GetStr(GetLoad()); ChA+=' ';
84    ChA+=TUInt64::GetStr(GetTotalPhys()); ChA+=' ';
85    ChA+=TUInt64::GetStr(GetAvailPhys()); ChA+=' ';
86    ChA+=TUInt64::GetStr(GetTotalPageFile()); ChA+=' ';
87    ChA+=TUInt64::GetStr(GetAvailPageFile()); ChA+=' ';
88    ChA+=TUInt64::GetStr(GetTotalVirtual()); ChA+=' ';
89    ChA+=TUInt64::GetStr(GetAvailVirtual());
90    return ChA;
91  }
92  TSysConsole::TSysConsole(){
93    Ok=(AllocConsole()!=0);
94    IAssert(Ok);
95    hStdOut=GetStdHandle(STD_OUTPUT_HANDLE);
96    IAssert(hStdOut!=INVALID_HANDLE_VALUE);
97  }
98  TSysConsole::~TSysConsole(){
99    if (Ok){
100      IAssert(FreeConsole());}
101  }
102  void TSysConsole::Put(const TStr& Str){
103    DWORD ChsWritten;
104    WriteConsole(hStdOut, Str.CStr(), Str.Len(), &ChsWritten, NULL);
105    IAssert(ChsWritten==DWORD(Str.Len()));
106  }
107  void TSysConsoleNotify::OnNotify(const TNotifyType& Type, const TStr& MsgStr){
108    if (Type==ntInfo){
109      SysConsole->PutLn(TStr::Fmt("%s", MsgStr.CStr()));
110    } else {
111      TStr TypeStr=TNotify::GetTypeStr(Type, false);
112      SysConsole->PutLn(TStr::Fmt("%s: %s", TypeStr.CStr(), MsgStr.CStr()));
113    }
114  }
115  void TSysConsoleNotify::OnStatus(const TStr& MsgStr){
116    SysConsole->Put(MsgStr.CStr());
117    if ((!MsgStr.Empty())&&(MsgStr.LastCh()!='\r')){
118      SysConsole->PutLn(""); }
119  }
120  TTm TSysTm::GetCurUniTm(){
121    SYSTEMTIME SysTm;
122    GetSystemTime(&SysTm);
123    return TTm(SysTm.wYear, SysTm.wMonth, SysTm.wDay, SysTm.wDayOfWeek,
124     SysTm.wHour, SysTm.wMinute, SysTm.wSecond, SysTm.wMilliseconds);
125  }
126  TTm TSysTm::GetCurLocTm(){
127    SYSTEMTIME SysTm;
128    GetLocalTime(&SysTm);
129    return TTm(SysTm.wYear, SysTm.wMonth, SysTm.wDay, SysTm.wDayOfWeek,
130     SysTm.wHour, SysTm.wMinute, SysTm.wSecond, SysTm.wMilliseconds);
131  }
132  uint64 TSysTm::GetCurUniMSecs(){
133    SYSTEMTIME SysTm; FILETIME FileTm;
134    GetSystemTime(&SysTm);
135    IAssert(SystemTimeToFileTime(&SysTm, &FileTm));
136    TUInt64 UInt64(uint(FileTm.dwHighDateTime), uint(FileTm.dwLowDateTime));
137    return UInt64.Val/uint64(10000);
138  }
139  uint64 TSysTm::GetCurLocMSecs(){
140    SYSTEMTIME SysTm; FILETIME FileTm;
141    GetLocalTime(&SysTm);
142    IAssert(SystemTimeToFileTime(&SysTm, &FileTm));
143    TUInt64 UInt64(uint(FileTm.dwHighDateTime), uint(FileTm.dwLowDateTime));
144    return UInt64.Val/uint64(10000);
145  }
146  uint64 TSysTm::GetMSecsFromTm(const TTm& Tm){
147    SYSTEMTIME SysTm; FILETIME FileTm;
148    SysTm.wYear=WORD(Tm.GetYear());
149    SysTm.wMonth=WORD(Tm.GetMonth());
150    SysTm.wDayOfWeek=WORD(Tm.GetDayOfWeek());
151    SysTm.wDay=WORD(Tm.GetDay());
152    SysTm.wHour=WORD(Tm.GetHour());
153    SysTm.wMinute=WORD(Tm.GetMin());
154    SysTm.wSecond=WORD(Tm.GetSec());
155    SysTm.wMilliseconds=WORD(Tm.GetMSec());
156    ESAssert(SystemTimeToFileTime(&SysTm, &FileTm));
157    TUInt64 UInt64(uint(FileTm.dwHighDateTime), uint(FileTm.dwLowDateTime));
158    return UInt64.Val/uint64(10000);
159  }
160  TTm TSysTm::GetTmFromMSecs(const uint64& MSecs){
161    TUInt64 FileTmUnits(MSecs*uint64(10000));
162    SYSTEMTIME SysTm; FILETIME FileTm;
163    FileTm.dwHighDateTime=FileTmUnits.GetMsVal();
164    FileTm.dwLowDateTime=FileTmUnits.GetLsVal();
165    SAssert(FileTimeToSystemTime(&FileTm, &SysTm));
166    return TTm(SysTm.wYear, SysTm.wMonth, SysTm.wDay, SysTm.wDayOfWeek,
167     SysTm.wHour, SysTm.wMinute, SysTm.wSecond, SysTm.wMilliseconds);
168  }
169  uint TSysTm::GetMSecsFromOsStart(){
170    return uint(GetTickCount());
171  }
172  TTm TSysTm::GetLocTmFromUniTm(const TTm& Tm){
173    TIME_ZONE_INFORMATION TzInf;
174    GetTimeZoneInformation(&TzInf);
175    SYSTEMTIME UniSysTm;
176    UniSysTm.wYear=WORD(Tm.GetYear());
177    UniSysTm.wMonth=WORD(Tm.GetMonth());
178    UniSysTm.wDayOfWeek=WORD(Tm.GetDayOfWeek());
179    UniSysTm.wDay=WORD(Tm.GetDay());
180    UniSysTm.wHour=WORD(Tm.GetHour());
181    UniSysTm.wMinute=WORD(Tm.GetMin());
182    UniSysTm.wSecond=WORD(Tm.GetSec());
183    UniSysTm.wMilliseconds=WORD(Tm.GetMSec());
184    SYSTEMTIME LocSysTm;
185    SystemTimeToTzSpecificLocalTime(&TzInf, &UniSysTm, &LocSysTm);
186    return TTm(LocSysTm.wYear, LocSysTm.wMonth, LocSysTm.wDay, LocSysTm.wDayOfWeek,
187     LocSysTm.wHour, LocSysTm.wMinute, LocSysTm.wSecond, LocSysTm.wMilliseconds);
188  }
189  TTm TSysTm::GetUniTmFromLocTm(const TTm& Tm){
190    TIME_ZONE_INFORMATION TzInf;
191    GetTimeZoneInformation(&TzInf);
192    SYSTEMTIME LocSysTm;
193    LocSysTm.wYear=WORD(Tm.GetYear());
194    LocSysTm.wMonth=WORD(Tm.GetMonth());
195    LocSysTm.wDayOfWeek=WORD(Tm.GetDayOfWeek());
196    LocSysTm.wDay=WORD(Tm.GetDay());
197    LocSysTm.wHour=WORD(Tm.GetHour());
198    LocSysTm.wMinute=WORD(Tm.GetMin());
199    LocSysTm.wSecond=WORD(Tm.GetSec());
200    LocSysTm.wMilliseconds=WORD(Tm.GetMSec());
201    SYSTEMTIME UniSysTm=LocSysTm;
202    Fail; 
203    return TTm(UniSysTm.wYear, UniSysTm.wMonth, UniSysTm.wDay, UniSysTm.wDayOfWeek,
204     UniSysTm.wHour, UniSysTm.wMinute, UniSysTm.wSecond, UniSysTm.wMilliseconds);
205  }
206  uint64 TSysTm::GetProcessMSecs(){
207    FILETIME CreationTime, ExitTime, KernelTime, UserTime;
208    IAssert(GetProcessTimes(GetCurrentProcess(),
209     &CreationTime, &ExitTime, &KernelTime, &UserTime));
210    TUInt64 KernelMSecs(uint(KernelTime.dwHighDateTime), uint(KernelTime.dwLowDateTime));
211    TUInt64 UserMSecs(uint(UserTime.dwHighDateTime), uint(UserTime.dwLowDateTime));
212    uint64 ProcessMSecs=KernelMSecs+UserMSecs;
213    return ProcessMSecs;
214  }
215  uint64 TSysTm::GetThreadMSecs(){
216    FILETIME CreationTime, ExitTime, KernelTime, UserTime;
217    IAssert(GetProcessTimes(GetCurrentProcess(),
218     &CreationTime, &ExitTime, &KernelTime, &UserTime));
219    TUInt64 KernelMSecs(uint(KernelTime.dwHighDateTime), uint(KernelTime.dwLowDateTime));
220    TUInt64 UserMSecs(uint(UserTime.dwHighDateTime), uint(UserTime.dwLowDateTime));
221    uint64 ThreadMSecs=KernelMSecs+UserMSecs;
222    return ThreadMSecs;
223  }
224  uint64 TSysTm::GetPerfTimerFq(){
225    uint MsFq; uint LsFq;
226    LARGE_INTEGER LargeInt;
227    if (QueryPerformanceFrequency(&LargeInt)){
228      MsFq=LargeInt.u.HighPart;
229      LsFq=LargeInt.u.LowPart;
230    } else {
231      MsFq=0;
232      LsFq=1;
233    }
234    TUInt64 UInt64(MsFq, LsFq);
235    return UInt64.Val;
236  }
237  uint64 TSysTm::GetPerfTimerTicks(){
238    uint MsVal; uint LsVal;
239    LARGE_INTEGER LargeInt;
240    if (QueryPerformanceCounter(&LargeInt)){
241      MsVal=LargeInt.u.HighPart;
242      LsVal=LargeInt.u.LowPart;
243    } else {
244      MsVal=0;
245      LsVal=int(time(NULL));
246    }
247    TUInt64 UInt64(MsVal, LsVal);
248    return UInt64.Val;
249  }
250  TStr TSysStr::GetCmLn(){
251    return TStr((char*)GetCommandLine());
252  }
253  TStr TSysStr::GetMsgStr(const DWORD& MsgCd){
254    LPVOID lpMsgBuf;
255    FormatMessage(
256     FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
257     NULL,
258     MsgCd,
259     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
260     (LPTSTR) &lpMsgBuf,
261     0,
262     NULL);
263    TStr MsgStr((char*)lpMsgBuf);
264    LocalFree(lpMsgBuf);
265    return MsgStr;
266  }
267  char* TSysStr::GetLastMsgCStr(){
268    TStr MsgStr=GetLastMsgStr();
269    static char* MsgCStr=NULL;
270    if (MsgCStr==NULL){MsgCStr=new char[1000];}
271    strcpy(MsgCStr, MsgStr.CStr());
272    return MsgCStr;
273  }
274  PRegKey TRegKey::GetKey(const PRegKey& BaseKey, const TStr& SubKeyNm){
275    HKEY hKey;
276    DWORD RetCd=RegOpenKeyEx(
277     BaseKey->GetHandle(), SubKeyNm.CStr(), 0, KEY_ALL_ACCESS, &hKey);
278    bool Ok=RetCd==ERROR_SUCCESS;
279    return new TRegKey(Ok, hKey);
280  }
281  TStr TRegKey::GetVal(const PRegKey& Key, const TStr& SubKeyNm, const TStr& ValNm){
282    PRegKey RegKey=TRegKey::GetKey(Key, SubKeyNm);
283    if (RegKey->IsOk()){
284      TStrKdV ValNmStrKdV; RegKey->GetValV(ValNmStrKdV);
285      int ValN;
286      if (ValNmStrKdV.IsIn(TStrKd(ValNm), ValN)){
287        return ValNmStrKdV[ValN].Dat;
288      } else {
289        return "";
290      }
291    } else {
292      return "";
293    }
294  }
295  void TRegKey::GetKeyNmV(TStrV& KeyNmV) const {
296    KeyNmV.Clr();
297    if (!Ok){return;}
298    DWORD SubKeys; 
299    DWORD MxSubKeyNmLen; 
300    DWORD RetCd=RegQueryInfoKey(
301     hKey, 
302     NULL, 
303     NULL, 
304     NULL, 
305     &SubKeys, 
306     &MxSubKeyNmLen, 
307     NULL, 
308     NULL, 
309     NULL, 
310     NULL, 
311     NULL, 
312     NULL); 
313     if (RetCd!=ERROR_SUCCESS){return;}
314    if (SubKeys>0){
315      KeyNmV.Gen(SubKeys, 0);
316      char* SubKeyNmCStr=new char[MxSubKeyNmLen+1];
317      DWORD SubKeyN=0;
318      forever{
319        DWORD SubKeyNmCStrLen=MxSubKeyNmLen+1;
320        DWORD RetCd=RegEnumKeyEx(
321         hKey, 
322         SubKeyN, 
323         SubKeyNmCStr, 
324         &SubKeyNmCStrLen, 
325         NULL, 
326         NULL, 
327         NULL, 
328         NULL); 
329        if (RetCd==ERROR_SUCCESS){
330          TStr KeyNm(SubKeyNmCStr);
331          KeyNmV.Add(KeyNm);
332        } else {
333          break;
334        }
335        SubKeyN++;
336      }
337      delete[] SubKeyNmCStr;
338    }
339  }
340  void TRegKey::GetValV(TStrKdV& ValNmStrKdV) const {
341    ValNmStrKdV.Clr();
342    if (!Ok){return;}
343    DWORD Vals; 
344    DWORD MxValNmLen; 
345    DWORD MxValStrLen; 
346    DWORD RetCd=RegQueryInfoKey(
347     hKey, 
348     NULL, 
349     NULL, 
350     NULL, 
351     NULL, 
352     NULL, 
353     NULL, 
354     &Vals, 
355     &MxValNmLen, 
356     &MxValStrLen, 
357     NULL, 
358     NULL); 
359     if (RetCd!=ERROR_SUCCESS){return;}
360    if (Vals>0){
361      ValNmStrKdV.Gen(Vals, 0);
362      char* ValNmCStr=new char[MxValNmLen+1];
363      char* ValCStr=new char[MxValStrLen+1];
364      DWORD ValN=0;
365      forever{
366        DWORD ValNmCStrLen=MxValNmLen+1;
367        DWORD ValCStrLen=MxValStrLen+1;
368        DWORD ValType;
369        DWORD RetCd=RegEnumValue(
370         hKey, 
371         ValN, 
372         ValNmCStr, 
373         &ValNmCStrLen, 
374         NULL, 
375         &ValType, 
376         (unsigned char*) ValCStr, 
377         &ValCStrLen); 
378        if (RetCd==ERROR_SUCCESS){
379          if (ValType==REG_SZ){
380            TStr ValNm(ValNmCStr);
381            TStr ValStr(ValCStr);
382            ValNmStrKdV.Add(TStrKd(ValNm, ValStr));
383          }
384        } else {
385          break;
386        }
387        ValN++;
388      }
389      delete[] ValNmCStr;
390      delete[] ValCStr;
391    }
392  }
393  void TStdIOPipe::CreateProc(const TStr& Cmd) {
394    PROCESS_INFORMATION piProcInfo;
395    STARTUPINFO siStartInfo;
396    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
397    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
398    siStartInfo.cb = sizeof(STARTUPINFO);
399    siStartInfo.hStdInput = ChildStdinRd;
400    siStartInfo.hStdOutput = ChildStdoutWr;
401    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
402    const BOOL FuncRetn = CreateProcess(NULL,
403      (LPSTR) Cmd.CStr(),  
404      NULL,          
405      NULL,          
406      TRUE,          
407      0,             
408      NULL,          
409      NULL,          
410      &siStartInfo,  
411      &piProcInfo);  
412    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s'", Cmd.CStr()).CStr());
413    CloseHandle(piProcInfo.hProcess);
414    CloseHandle(piProcInfo.hThread);
415  }
416  TStdIOPipe::TStdIOPipe(const TStr& CmdToExe) : ChildStdinRd(NULL), ChildStdinWrDup(NULL),
417    ChildStdoutWr(NULL), ChildStdoutRdDup(NULL) {
418    HANDLE ChildStdinWr, ChildStdoutRd;
419    SECURITY_ATTRIBUTES saAttr;
420    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
421    saAttr.bInheritHandle = TRUE;
422    saAttr.lpSecurityDescriptor = NULL;
423    EAssert(CreatePipe(&ChildStdoutRd, &ChildStdoutWr, &saAttr, 0));
424    EAssert(DuplicateHandle(GetCurrentProcess(), ChildStdoutRd,
425      GetCurrentProcess(), &ChildStdoutRdDup, 0, FALSE, DUPLICATE_SAME_ACCESS));
426    CloseHandle(ChildStdoutRd);
427    EAssert(CreatePipe(&ChildStdinRd, &ChildStdinWr, &saAttr, 0));
428    EAssert(DuplicateHandle(GetCurrentProcess(), ChildStdinWr,
429      GetCurrentProcess(), &ChildStdinWrDup, 0, FALSE, DUPLICATE_SAME_ACCESS));
430    CloseHandle(ChildStdinWr);
431    CreateProc(CmdToExe);
432  }
433  TStdIOPipe::~TStdIOPipe() {
434    if (ChildStdinRd != NULL) CloseHandle(ChildStdinRd);
435    if (ChildStdinWrDup != NULL) CloseHandle(ChildStdinWrDup);
436    if (ChildStdoutWr != NULL) CloseHandle(ChildStdoutWr);
437    if (ChildStdoutRdDup != NULL) CloseHandle(ChildStdoutRdDup);
438  }
439  int TStdIOPipe::Write(const char* Bf, const int& BfLen) {
440    DWORD Written;
441    EAssert(WriteFile(ChildStdinWrDup, Bf, BfLen, &Written, NULL));
442    return int(Written);
443  }
444  int TStdIOPipe::Read(char *Bf, const int& BfMxLen) {
445    DWORD Read;
446    EAssert(ReadFile(ChildStdoutRdDup, Bf, BfMxLen, &Read, NULL));
447    return int(Read);
448  }
449  #elif defined(GLib_UNIX)
450  int GetModuleFileName(void *hModule, char *Bf, int MxBfL) {
451    int retlen = (int) readlink("/proc/self/exe", Bf, MxBfL);
452    if (retlen == -1) {
453      if (MxBfL > 0) Bf[0] = '\0';
454      return 0;
455    }
456    if (retlen == MxBfL) --retlen;
457    Bf[retlen] = '\0';
458    return retlen;
459  }
460  int GetCurrentDirectory(const int MxBfL, char *Bf) {
461    getcwd(Bf, MxBfL);
462    return (int) strlen(Bf);
463  }
464  int CreateDirectory(const char *FNm, void *useless) {
465    return mkdir(FNm, 0777)==0;
466  }
467  int RemoveDirectory(const char *FNm) {
468    return unlink(FNm)==0;
469  }
470  #define TICKS_PER_SECOND 10000000
471  #define EPOCH_DIFFERENCE 11644473600LL
472  uint64 Epoch2Ft(time_t Epoch){
473    uint64 Ft;
474    Ft = Epoch + EPOCH_DIFFERENCE;  
475    Ft *= TICKS_PER_SECOND;         
476    return Ft;
477  }
478  time_t Ft2Epoch(uint64 Ft){
479    uint64 Epoch;
480    Epoch = Ft / TICKS_PER_SECOND;  
481    Epoch -= EPOCH_DIFFERENCE;      
482    return (time_t) Epoch;
483  }
484  TTm TSysTm::GetCurUniTm(){
485    time_t t;
486    struct tm tms;
487    struct timeval tv;
488    time(&t);
489    int ErrCd = gettimeofday(&tv, NULL);
490    if (ErrCd != 0) {
491      Assert((ErrCd==0)&&(t!=-1));
492    }
493    gmtime_r(&t, &tms);
494    return TTm(1900+tms.tm_year, tms.tm_mon, tms.tm_mday, tms.tm_wday,
495     tms.tm_hour, tms.tm_min, tms.tm_sec, tv.tv_usec/1000);
496  }
497  TTm TSysTm::GetCurLocTm(){
498    time_t t;
499    struct tm tms;
500    struct timeval tv;
501    time(&t);
502    int ErrCd = gettimeofday(&tv, NULL);
503    if (ErrCd != 0) {
504      Assert((ErrCd==0)&&(t!=-1));
505    }
506    localtime_r(&t, &tms);
507    return TTm(1900+tms.tm_year, tms.tm_mon, tms.tm_mday, tms.tm_wday,
508     tms.tm_hour, tms.tm_min, tms.tm_sec, tv.tv_usec/1000);
509  }
510  uint64 TSysTm::GetCurUniMSecs(){
511    return TTm::GetMSecsFromTm(GetCurLocTm());
512  }
513  uint64 TSysTm::GetCurLocMSecs(){
514    return TTm::GetMSecsFromTm(GetCurUniTm());
515  }
516  uint64 TSysTm::GetMSecsFromTm(const TTm& Tm){
517    time_t t;
518    struct tm tms;
519    tms.tm_year = Tm.GetYear() - 1900;
520    tms.tm_mon = Tm.GetMonth();
521    tms.tm_mday = Tm.GetDay();
522    tms.tm_hour = Tm.GetHour();
523    tms.tm_min = Tm.GetMin();
524    tms.tm_sec = Tm.GetSec();
525    t = timegm(&tms);
526    return Epoch2Ft(t)/10000 + (uint64)Tm.GetMSec();
527  }
528  TTm TSysTm::GetTmFromMSecs(const uint64& TmNum){
529    const int MSec = int(TmNum % 1000);
530    time_t Sec = Ft2Epoch(TmNum*10000);
531    struct tm tms;
532    gmtime_r(&Sec, &tms);
533    return TTm(1900+tms.tm_year, tms.tm_mon, tms.tm_mday, tms.tm_wday,
534     tms.tm_hour, tms.tm_min, tms.tm_sec, MSec);
535  }
536  TTm TSysTm::GetLocTmFromUniTm(const TTm& Tm) {
537    struct tm tms, tmr;
538    tms.tm_year = Tm.GetYear() - 1900;
539    tms.tm_mon = Tm.GetMonth();
540    tms.tm_mday = Tm.GetDay();
541    tms.tm_hour = Tm.GetHour();
542    tms.tm_min = Tm.GetMin();
543    tms.tm_sec = Tm.GetSec();
<span onclick='openModal()' class='match'>544    int MSec = Tm.GetMSec();
545    time_t Sec = timegm(&tms);
546    localtime_r(&Sec, &tmr);
547    return TTm(1900+tmr.tm_year, tmr.tm_mon, tmr.tm_mday, tmr.tm_wday,
548     tmr.tm_hour, tmr.tm_min, tmr.tm_sec, MSec);
549  }
550  TTm TSysTm::GetUniTmFromLocTm(const TTm& Tm) {
551    struct tm tms, tmr;
552    tms.tm_year = Tm.GetYear() - 1900;
</span>553    tms.tm_mon = Tm.GetMonth();
554    tms.tm_mday = Tm.GetDay();
555    tms.tm_hour = Tm.GetHour();
556    tms.tm_min = Tm.GetMin();
557    tms.tm_sec = Tm.GetSec();
558    tms.tm_isdst = -1;      
559    int MSec = Tm.GetMSec();
560    time_t Sec = mktime(&tms);
561    gmtime_r(&Sec, &tmr);
562    return TTm(1900+tmr.tm_year, tmr.tm_mon, tmr.tm_mday, tmr.tm_wday,
563     tmr.tm_hour, tmr.tm_min, tmr.tm_sec, MSec);
564  }
565  uint TSysTm::GetMSecsFromOsStart(){
566  #if defined(_POSIX_MONOTONIC_CLOCK) && (_POSIX_MONOTONIC_CLOCK != -1)
567    struct timespec ts;
568    int ErrCd=clock_gettime(CLOCK_MONOTONIC, &ts);
569    if (ErrCd != 0) {
570      Assert(ErrCd==0);
571    }
572    return (ts.tv_sec*1000) + (ts.tv_nsec/1000000);
573  #else
574    FILE *f;
575    uint sec, csec;
576    f = fopen("/proc/uptime", "r");
577    if (!f) return 0xffffffff;    
578    fscanf(f, "%u.%u", &sec, &csec);
579    fclose(f);
580    return (uint) (sec * 1000) + (csec * 10);
581  #endif
582  }
583  uint64 TSysTm::GetProcessMSecs() {
584  #if defined(_POSIX_CPUTIME) && (_POSIX_CPUTIME != -1)
585    struct timespec ts;
586    int ErrCd=clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);
587    if (ErrCd != 0) {
588      Assert(ErrCd==0);
589    }
590    return (ts.tv_sec*1000) + (ts.tv_nsec / 1000000);
591  #else
592    struct rusage ru;
593    int ErrCd = getrusage(RUSAGE_SELF, &ru);
594    if (ErrCd != 0) {
595      Assert(ErrCd == 0);
596    }
597    return ((ru.ru_utime.tv_usec + ru.ru_stime.tv_usec) / 1000) +
598           ((ru.ru_utime.tv_sec + ru.ru_stime.tv_sec) * 1000);
599  #endif
600  }
601  uint64 TSysTm::GetThreadMSecs() {
602  #if defined(_POSIX_THREAD_CPUTIME) && (_POSIX_THREAD_CPUTIME != -1)
603    struct timespec ts;
604    int ErrCd=clock_gettime(CLOCK_THREAD_CPUTIME_ID, &ts);
605    if (ErrCd != 0) {
606      Assert(ErrCd==0);
607    }
608    return (ts.tv_sec*1000) + (ts.tv_nsec / 1000000);
609  #else
610    return GetProcessMSecs();
611  #endif
612  }
613  uint64 TSysTm::GetPerfTimerFq(){
614  #if defined(_POSIX_MONOTONIC_CLOCK) && (_POSIX_MONOTONIC_CLOCK != -1)
615    return 1000000000;
616  #else
617    return 1000000;
618  #endif
619  }
620  uint64 TSysTm::GetPerfTimerTicks(){
621  #if defined(_POSIX_MONOTONIC_CLOCK) && (_POSIX_MONOTONIC_CLOCK != -1)
622    struct timespec ts;
623    int ErrCd=clock_gettime(CLOCK_MONOTONIC, &ts);
624    if (ErrCd != 0) {
625      return (uint64)ts.tv_sec*1000000000ll + (uint64)ts.tv_nsec; }
626    else {
627      struct timeval tv;
628      gettimeofday(&tv, NULL);
629      return (uint64)tv.tv_usec + ((uint64)tv.tv_sec)*1000000;
630    }
631  #else
632    struct timeval tv;
633    gettimeofday(&tv, NULL);
634    return (uint64)tv.tv_usec + ((uint64)tv.tv_sec)*1000000;
635  #endif
636  }
637  int TSysProc::Sleep(const uint& MSecs) {
638    int ret;
639    struct timespec tsp, trem;
640    tsp.tv_sec = MSecs / 1000;
641    tsp.tv_nsec = (MSecs % 1000) * 1000000;
642    while (true) {
643      ret = nanosleep(&tsp, &trem);
644      if ((ret != -1)  ||  (errno != EINTR)) {
645        break;
646      }
647      tsp = trem;
648    }
649    return ret;
650  }
651  TStr TSysProc::GetExeFNm() {
652    char Bf[1024];
653    GetModuleFileName(NULL, Bf, 1023);
654    return TStr(Bf);
655  }
656  void TSysProc::SetLowPriority() {
657    nice(19);
658  }
659  bool TSysProc::ExeProc(const TStr& ExeFNm, TStr& ParamStr) {
660    TStrV SArgV;
661    ParamStr.SplitOnWs(SArgV);
662    int pid = fork();
663    if (pid == -1) return false;
664    if (pid > 0) return true;
665    char **argv;
666    argv = new char*[SArgV.Len()+2];
667    argv[0] = strdup(ExeFNm.CStr());
668    for (int i=0;i<SArgV.Len();i++) argv[i+1] = strdup(SArgV[i].CStr());
669    argv[SArgV.Len()+1] = NULL;
670    execvp(argv[0], argv);
671    kill(getpid(), SIGINT);
672    return false;
673  }
674  TStdIOPipe::TStdIOPipe(const TStr& CmdToExe) {
675    FailR("Not intended for use under Linux!");
676  }
677  TStdIOPipe::~TStdIOPipe() {
678    FailR("Not intended for use under Linux!");
679  }
680  int TStdIOPipe::Write(const char* Bf, const int& BfLen) {
681    FailR("Not intended for use under Linux!");
682    return -1;
683  }
684  int TStdIOPipe::Read(char *Bf, const int& BfMxLen) {
685    FailR("Not intended for use under Linux!");
686    return -1;
687  }
688  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-pluginsAdmin.cpp</h3>
            <pre><code>1  #include "json.hpp"
2  #include <algorithm>
3  #include <iostream>
4  #include <fstream>
5  #include <string>
6  #include <cctype>
7  #include <shlobj.h>
8  #include <shlwapi.h>
9  #include "pluginsAdmin.h"
10  #include "ScintillaEditView.h"
11  #include "localization.h"
12  #include "Processus.h"
13  #include "PluginsManager.h"
14  #include "verifySignedfile.h"
15  #define TEXTFILE        256
16  #define IDR_PLUGINLISTJSONFILE  101
17  using namespace std;
18  using nlohmann::json;
19  generic_string PluginUpdateInfo::describe()
20  {
21  	generic_string desc;
22  	const TCHAR *EOL = TEXT("\r\n");
23  	if (!_description.empty())
24  	{
25  		desc = _description;
26  		desc += EOL;
27  	}
28  	if (!_author.empty())
29  	{
30  		desc += TEXT("Author: ");
31  		desc += _author;
32  		desc += EOL;
33  	}
34  	if (!_homepage.empty())
35  	{
36  		desc += TEXT("Homepage: ");
37  		desc += _homepage;
38  		desc += EOL;
39  	}
40  	return desc;
41  }
42  bool findStrNoCase(const generic_string & strHaystack, const generic_string & strNeedle)
43  {
44  	auto it = std::search(
45  		strHaystack.begin(), strHaystack.end(),
46  		strNeedle.begin(), strNeedle.end(),
47  		[](wchar_t ch1, wchar_t ch2){return towupper(ch1) == towupper(ch2); }
48  	);
49  	return (it != strHaystack.end());
50  }
51  bool PluginsAdminDlg::isFoundInListFromIndex(const PluginViewList& inWhichList, int index, const generic_string& str2search, bool inWhichPart) const
52  {
53  	PluginUpdateInfo* pui = inWhichList.getPluginInfoFromUiIndex(index);
54  	generic_string searchIn;
55  	if (inWhichPart == _inNames)
56  		searchIn = pui->_displayName;
57  	else 
58  		searchIn = pui->_description;
59  	return (findStrNoCase(searchIn, str2search));
60  }
61  long PluginsAdminDlg::searchFromCurrentSel(const PluginViewList& inWhichList, const generic_string& str2search, bool inWhichPart, bool isNextMode) const
62  {
63  	long currentIndex = inWhichList.getSelectedIndex();
64  	int nbItem = static_cast<int>(inWhichList.nbItem());
65  	if (currentIndex == -1)
66  	{
67  		for (int i = 0; i < nbItem; ++i)
68  		{
69  			if (isFoundInListFromIndex(inWhichList, i, str2search, inWhichPart))
70  				return i;
71  		}
72  	}
73  	else 
74  	{
75  		for (int i = currentIndex + (isNextMode ? 1 : 0); i < nbItem; ++i)
76  		{
77  			if (isFoundInListFromIndex(inWhichList, i, str2search, inWhichPart))
78  				return i;
79  		}
80  		for (int i = 0; i < currentIndex + (isNextMode ? 1 : 0); ++i)
81  		{
82  			if (isFoundInListFromIndex(inWhichList, i, str2search, inWhichPart))
83  				return i;
84  		}
85  	}
86  	return -1;
87  }
88  void PluginsAdminDlg::create(int dialogID, bool isRTL, bool msgDestParent)
89  {
90  	collectNppCurrentStatusInfos();
91  	StaticDialog::create(dialogID, isRTL, msgDestParent);
92  	RECT rect{};
93  	getClientRect(rect);
94  	_tab.init(_hInst, _hSelf, false, true);
95  	NppDarkMode::subclassTabControl(_tab.getHSelf());
96  	DPIManager& dpiManager = NppParameters::getInstance()._dpiManager;
97  	int tabDpiDynamicalHeight = dpiManager.scaleY(13);
98  	_tab.setFont(TEXT("Tahoma"), tabDpiDynamicalHeight);
99  	const TCHAR *available = TEXT("Available");
100  	const TCHAR *updates = TEXT("Updates");
101  	const TCHAR *installed = TEXT("Installed");
102  	const TCHAR *incompatible = TEXT("Incompatible");
103  	_tab.insertAtEnd(available);
104  	_tab.insertAtEnd(updates);
105  	_tab.insertAtEnd(installed);
106  	_tab.insertAtEnd(incompatible);
107  	RECT rcDesc{};
108  	getMappedChildRect(IDC_PLUGINADM_EDIT, rcDesc);
109  	const long margeX = ::GetSystemMetrics(SM_CXEDGE);
110  	const long margeY = tabDpiDynamicalHeight;
111  	rect.bottom = rcDesc.bottom + margeY;
112  	_tab.reSizeTo(rect);
113  	_tab.display();
114  	RECT rcSearch{};
115  	getMappedChildRect(IDC_PLUGINADM_SEARCH_EDIT, rcSearch);
116  	RECT listRect{
117  		rcDesc.left - margeX,
118  		rcSearch.bottom + margeY,
119  		rcDesc.right + ::GetSystemMetrics(SM_CXVSCROLL) + margeX,
120  		rcDesc.top - margeY
121  	};
122  	NppParameters& nppParam = NppParameters::getInstance();
123  	NativeLangSpeaker *pNativeSpeaker = nppParam.getNativeLangSpeaker();
124  	generic_string pluginStr = pNativeSpeaker->getAttrNameStr(TEXT("Plugin"), "PluginAdmin", "Plugin");
125  	generic_string vesionStr = pNativeSpeaker->getAttrNameStr(TEXT("Version"), "PluginAdmin", "Version");
126  	const COLORREF fgColor = nppParam.getCurrentDefaultFgColor();
127  	const COLORREF bgColor = nppParam.getCurrentDefaultBgColor();
128  	const size_t szColVer = dpiManager.scaleX(100);
129  	const size_t szColName = szColVer * 2;
130  	auto initListView = [&](PluginViewList& list) -> void {
131  		list.addColumn(columnInfo(pluginStr, szColName));
132  		list.addColumn(columnInfo(vesionStr, szColVer));
133  		list.setViewStyleOption(LVS_EX_CHECKBOXES);
134  		list.initView(_hInst, _hSelf);
135  		const HWND hList = list.getViewHwnd();
136  		ListView_SetBkColor(hList, bgColor);
137  		ListView_SetTextBkColor(hList, bgColor);
138  		ListView_SetTextColor(hList, fgColor);
139  		list.reSizeView(listRect);
140  	};
141  	initListView(_availableList);
142  	initListView(_updateList);
143  	initListView(_installedList);
144  	initListView(_incompatibleList);
145  	switchDialog(0);
146  	NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
147  	NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
148  	HWND hPluginListVersionNumber = ::GetDlgItem(_hSelf, IDC_PLUGINLIST_VERSIONNUMBER_STATIC);
149  	::SetWindowText(hPluginListVersionNumber, _pluginListVersion.c_str());
150  	_repoLink.init(_hInst, _hSelf);
151  	_repoLink.create(::GetDlgItem(_hSelf, IDC_PLUGINLIST_ADDR), TEXT("https:&bsol;&bsol;github.com/notepad-plus-plus/nppPluginList"));
152  	goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
153  }
154  void PluginsAdminDlg::collectNppCurrentStatusInfos()
155  {
156  	NppParameters& nppParam = NppParameters::getInstance();
157  	_nppCurrentStatus._nppInstallPath = nppParam.getNppPath();
158  	_nppCurrentStatus._isAppDataPluginsAllowed = ::SendMessage(_hParent, NPPM_GETAPPDATAPLUGINSALLOWED, 0, 0) == TRUE;
159  	_nppCurrentStatus._appdataPath = nppParam.getAppDataNppDir();
160  	generic_string programFilesPath = NppParameters::getSpecialFolderLocation(CSIDL_PROGRAM_FILES);
161  	_nppCurrentStatus._isInProgramFiles = (_nppCurrentStatus._nppInstallPath.find(programFilesPath) == 0);
162  }
163  vector<PluginUpdateInfo*> PluginViewList::fromUiIndexesToPluginInfos(const std::vector<size_t>& uiIndexes) const
164  {
165  	std::vector<PluginUpdateInfo*> r;
166  	size_t nb = _ui.nbItem();
167  	for (const auto &i : uiIndexes)
168  	{
169  		if (i < nb)
170  		{
171  			r.push_back(getPluginInfoFromUiIndex(i));
172  		}
173  	}
174  	return r;
175  }
176  PluginsAdminDlg::PluginsAdminDlg()
177  {
178  	NppParameters& nppParameters = NppParameters::getInstance();
179  	_updaterDir = nppParameters.getNppPath();
180  	pathAppend(_updaterDir, TEXT("updater"));
181  	_updaterFullPath = _updaterDir;
182  	pathAppend(_updaterFullPath, TEXT("gup.exe"));
183  	_pluginListFullPath = nppParameters.getPluginConfDir();
184  #ifdef DEBUG 
185  	pathAppend(_pluginListFullPath, TEXT("nppPluginList.json"));
186  #else 
187  	pathAppend(_pluginListFullPath, TEXT("nppPluginList.dll"));
188  #endif
189  }
190  generic_string PluginsAdminDlg::getPluginListVerStr() const
191  {
192  	Version v;
193  	v.setVersionFrom(_pluginListFullPath);
194  	return v.toString();
195  }
196  bool PluginsAdminDlg::exitToInstallRemovePlugins(Operation op, const vector<PluginUpdateInfo*>& puis)
197  {
198  	generic_string opStr;
199  	if (op == pa_install)
200  		opStr = TEXT("-unzipTo ");
201  	else if (op == pa_update)
202  		opStr = TEXT("-unzipTo -clean ");
203  	else if (op == pa_remove)
204  		opStr = TEXT("-clean ");
205  	else
206  		return false;
207  	NppParameters& nppParameters = NppParameters::getInstance();
208  	generic_string updaterDir = nppParameters.getNppPath();
209  	updaterDir += TEXT("\\updater\\");
210  	generic_string updaterFullPath = updaterDir + TEXT("gup.exe");
211  	generic_string updaterParams = opStr;
212  	TCHAR nppFullPath[MAX_PATH]{};
213  	::GetModuleFileName(NULL, nppFullPath, MAX_PATH);
214  	updaterParams += TEXT("\"");
215  	updaterParams += nppFullPath;
216  	updaterParams += TEXT("\" ");
217  	updaterParams += TEXT("\"");
218  	updaterParams += nppParameters.getPluginRootDir();
219  	updaterParams += TEXT("\"");
220  	for (const auto &i : puis)
221  	{
222  		if (op == pa_install || op == pa_update)
223  		{
224  			updaterParams += TEXT(" \"");
225  			updaterParams += i->_folderName;
226  			updaterParams += TEXT(" ");
227  			updaterParams += i->_repository;
228  			updaterParams += TEXT(" ");
229  			updaterParams += i->_id;
230  			updaterParams += TEXT("\"");
231  		}
232  		else 
233  		{
234  			updaterParams += TEXT(" \"");
235  			generic_string folderName = i->_folderName;
236  			if (folderName.empty())
237  			{
238  				auto lastindex = i->_displayName.find_last_of(TEXT("."));
239  				if (lastindex != generic_string::npos)
240  					folderName = i->_displayName.substr(0, lastindex);
241  				else
242  					folderName = i->_displayName;	
243  			}
244  			updaterParams += folderName;
245  			updaterParams += TEXT("\"");
246  		}
247  	}
248  	NativeLangSpeaker *pNativeSpeaker = nppParameters.getNativeLangSpeaker();
249  	auto res = pNativeSpeaker->messageBox("ExitToUpdatePlugins",
250  		_hSelf,
251  		TEXT("If you click YES, you will quit Notepad++ to continue the operations.\nNotepad++ will be restarted after all the operations are terminated.\nContinue?"),
252  		TEXT("Notepad++ is about to exit"),
253  		MB_YESNO | MB_APPLMODAL);
254  	if (res == IDYES)
255  	{
256  		NppParameters& nppParam = NppParameters::getInstance();
257  		nppParam.setWingupFullPath(updaterFullPath);
258  		nppParam.setWingupParams(updaterParams);
259  		nppParam.setWingupDir(updaterDir);
260  		::PostMessage(_hParent, WM_COMMAND, IDM_FILE_EXIT, 0);
261  	}
262  	return true;
263  }
264  bool PluginsAdminDlg::installPlugins()
265  {
<span onclick='openModal()' class='match'>266  	vector<size_t> indexes = _availableList.getCheckedIndexes();
267  	vector<PluginUpdateInfo*> puis = _availableList.fromUiIndexesToPluginInfos(indexes);
268  	return exitToInstallRemovePlugins(pa_install, puis);
269  }
270  bool PluginsAdminDlg::updatePlugins()
271  {
272  	vector<size_t> indexes = _updateList.getCheckedIndexes();
</span>273  	vector<PluginUpdateInfo*> puis = _updateList.fromUiIndexesToPluginInfos(indexes);
274  	return exitToInstallRemovePlugins(pa_update, puis);
275  }
276  bool PluginsAdminDlg::removePlugins()
277  {
278  	vector<size_t> indexes = _installedList.getCheckedIndexes();
279  	vector<PluginUpdateInfo*> puis = _installedList.fromUiIndexesToPluginInfos(indexes);
280  	return exitToInstallRemovePlugins(pa_remove, puis);
281  }
282  void PluginsAdminDlg::changeTabName(LIST_TYPE index, const TCHAR *name2change)
283  {
284  	TCITEM tie{};
285  	tie.mask = TCIF_TEXT;
286  	tie.pszText = (TCHAR *)name2change;
287  	TabCtrl_SetItem(_tab.getHSelf(), index, &tie);
288  	TCHAR label[MAX_PATH]{};
289  	_tab.getCurrentTitle(label, MAX_PATH);
290  	::SetWindowText(_hSelf, label);
291  }
292  void PluginsAdminDlg::changeColumnName(COLUMN_TYPE index, const TCHAR *name2change)
293  {
294  	_availableList.changeColumnName(index, name2change);
295  	_updateList.changeColumnName(index, name2change);
296  	_installedList.changeColumnName(index, name2change);
297  	_incompatibleList.changeColumnName(index, name2change);
298  }
299  void PluginViewList::changeColumnName(COLUMN_TYPE index, const TCHAR *name2change)
300  {
301  	_ui.setColumnText(index, name2change);
302  }
303  bool PluginViewList::removeFromFolderName(const generic_string& folderName)
304  {
305  	for (size_t i = 0; i < _ui.nbItem(); ++i)
306  	{
307  		PluginUpdateInfo* pi = getPluginInfoFromUiIndex(i);
308  		if (pi->_folderName == folderName)
309  		{
310  			if (!_ui.removeFromIndex(i))
311  				return false;
312  			for (size_t j = 0; j < _list.size(); ++j)
313  			{
314  				if (_list[j] == pi)
315  				{
316  					_list.erase(_list.begin() + j);
317  					return true;
318  				}
319  			}
320  		}
321  	}
322  	return false;
323  }
324  void PluginViewList::pushBack(PluginUpdateInfo* pi)
325  {
326  	_list.push_back(pi);
327  	vector<generic_string> values2Add;
328  	values2Add.push_back(pi->_displayName);
329  	Version v = pi->_version;
330  	values2Add.push_back(v.toString());
331  	size_t i = _ui.findAlphabeticalOrderPos(pi->_displayName, _sortType == DISPLAY_NAME_ALPHABET_ENCREASE ? _ui.sortEncrease : _ui.sortDecrease);
332  	_ui.addLine(values2Add, reinterpret_cast<LPARAM>(pi), static_cast<int>(i));
333  }
334  std::pair<Version, Version> getIntervalVersions(generic_string intervalVerStr)
335  {
336  	std::pair<Version, Version> result;
337  	if (intervalVerStr.empty())
338  		return result;
339  	const size_t indexEnd = intervalVerStr.length() - 1;
340  	if (intervalVerStr[0] == '[' && intervalVerStr[indexEnd] == ']') 
341  	{
342  		generic_string cleanIntervalVerStr = intervalVerStr.substr(1, indexEnd - 1);
343  		vector<generic_string> versionVect;
344  		cutStringBy(cleanIntervalVerStr.c_str(), versionVect, ',', true);
345  		if (versionVect.size() == 2)
346  		{
347  			if (!versionVect[0].empty() && !versionVect[1].empty()) 
348  			{
349  				result.first = Version(versionVect[0]);
350  				result.second = Version(versionVect[1]);
351  			}
352  			else if (!versionVect[0].empty() && versionVect[1].empty()) 
353  			{
354  				result.first = Version(versionVect[0]);
355  			}
356  			else if (versionVect[0].empty() && !versionVect[1].empty()) 
357  			{
358  				result.second = Version(versionVect[1]);
359  			}
360  		}
361  	}
362  	else if (intervalVerStr[0] != '[' && intervalVerStr[indexEnd] != ']') 
363  	{
364  		result.first = Version(intervalVerStr);
365  		result.second = Version(intervalVerStr);
366  	}
367  	else 
368  	{
369  	}
370  	return result;
371  }
372  std::pair<std::pair<Version, Version>, std::pair<Version, Version>> getTwoIntervalVersions(generic_string twoIntervalVerStr)
373  {
374  	std::pair<std::pair<Version, Version>, std::pair<Version, Version>> r;
375  	generic_string sep = TEXT("][");
376  	generic_string::size_type pos = twoIntervalVerStr.find(sep, 0);
377  	if (pos == string::npos)
378  		return r;
379  	generic_string intervalStr1 = twoIntervalVerStr.substr(0, pos + 1);
380  	generic_string intervalStr2 = twoIntervalVerStr.substr(pos + 1, twoIntervalVerStr.length() - pos + 1);
381  	r.first = getIntervalVersions(intervalStr1);
382  	r.second = getIntervalVersions(intervalStr2);
383  	return r;
384  }
385  bool loadFromJson(std::vector<PluginUpdateInfo*>& pl, wstring& verStr, const json& j)
386  {
387  	if (j.empty())
388  		return false;
389  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
390  	json jVerStr = j["version"];
391  	if (jVerStr.empty() || jVerStr.type() != json::value_t::string)
392  		return false;
393  	string s = jVerStr.get<std::string>();
394  	verStr = wmc.char2wchar(s.c_str(), CP_ACP);
395  	json jArray = j["npp-plugins"];
396  	if (jArray.empty() || jArray.type() != json::value_t::array)
397  		return false;
398  	for (const auto& i : jArray)
399  	{
400  		try {
401  			PluginUpdateInfo* pi = new PluginUpdateInfo();
402  			string valStr = i.at("folder-name").get<std::string>();
403  			pi->_folderName = wmc.char2wchar(valStr.c_str(), CP_ACP);
404  			valStr = i.at("display-name").get<std::string>();
405  			pi->_displayName = wmc.char2wchar(valStr.c_str(), CP_ACP);
406  			valStr = i.at("author").get<std::string>();
407  			pi->_author = wmc.char2wchar(valStr.c_str(), CP_UTF8);
408  			valStr = i.at("description").get<std::string>();
409  			pi->_description = wmc.char2wchar(valStr.c_str(), CP_UTF8);
410  			valStr = i.at("id").get<std::string>();
411  			pi->_id = wmc.char2wchar(valStr.c_str(), CP_ACP);
412  			try {
413  				valStr = i.at("version").get<std::string>();
414  				generic_string newValStr(valStr.begin(), valStr.end());
415  				pi->_version = Version(newValStr);
416  				if (i.contains("npp-compatible-versions"))
417  				{
418  					json jNppCompatibleVer = i["npp-compatible-versions"];
419  					string versionsStr = jNppCompatibleVer.get<std::string>();
420  					generic_string nppCompatibleVersionStr(versionsStr.begin(), versionsStr.end());
421  					pi->_nppCompatibleVersions = getIntervalVersions(nppCompatibleVersionStr);
422  				}
423  				if (i.contains("old-versions-compatibility"))
424  				{
425  					json jOldVerCompatibility = i["old-versions-compatibility"];
426  					string versionsStr = jOldVerCompatibility.get<std::string>();
427  					generic_string oldVerCompatibilityStr(versionsStr.begin(), versionsStr.end());
428  					pi->_oldVersionCompatibility = getTwoIntervalVersions(oldVerCompatibilityStr);
429  				}
430  			}
431  			catch (const wstring& s)
432  			{
433  				wstring msg = pi->_displayName;
434  				msg += L": ";
435  				throw msg + s;
436  			}
437  			valStr = i.at("repository").get<std::string>();
438  			pi->_repository = wmc.char2wchar(valStr.c_str(), CP_ACP);
439  			valStr = i.at("homepage").get<std::string>();
440  			pi->_homepage = wmc.char2wchar(valStr.c_str(), CP_ACP);
441  			pl.push_back(pi);
442  		}
443  #ifdef DEBUG
444  		catch (const wstring& s)
445  		{
446  			::MessageBox(NULL, s.c_str(), TEXT("Exception caught in: PluginsAdmin loadFromJson()"), MB_ICONERROR);
447  			continue;
448  		}
449  		catch (std::exception& e)
450  		{
451  			::MessageBoxA(NULL, e.what(), "Exception caught in: PluginsAdmin loadFromJson()", MB_ICONERROR);
452  			continue;
453  		}
454  #endif
455  		catch (...) 
456  		{
457  #ifdef DEBUG
458  			::MessageBoxA(NULL, "An unknown exception is just caught", "Unknown Exception", MB_OK);
459  #endif
460  			continue; 
461  		}
462  	}
463  	return true;
464  }
465  PluginUpdateInfo::PluginUpdateInfo(const generic_string& fullFilePath, const generic_string& filename)
466  {
467  	if (!::PathFileExists(fullFilePath.c_str()))
468  		return;
469  	_fullFilePath = fullFilePath;
470  	_displayName = filename;
471  	std::string content = getFileContent(fullFilePath.c_str());
472  	if (content.empty())
473  		return;
474  	_version.setVersionFrom(fullFilePath);
475  }
476  typedef const char * (__cdecl * PFUNCGETPLUGINLIST)();
477  bool PluginsAdminDlg::initFromJson()
478  {
479  	winVer winVersion = (NppParameters::getInstance()).getWinVersion();
480  	if (winVersion <= WV_XP)
481  	{
482  		return false;
483  	}
484  	if (!::PathFileExists(_pluginListFullPath.c_str()))
485  	{
486  		return false;
487  	}
488  	if (!::PathFileExists(_updaterFullPath.c_str()))
489  	{
490  		return false;
491  	}
492  	json j;
493  #ifdef DEBUG 
494  #ifdef __MINGW32__
495  	ifstream nppPluginListJson(wstring2string(_pluginListFullPath, CP_UTF8));
496  #else 
497  	ifstream nppPluginListJson(_pluginListFullPath);
498  #endif
499  	nppPluginListJson >> j;
500  #else 
501  	SecurityGuard securityGuard;
502  	bool isSecured = securityGuard.checkModule(_pluginListFullPath, nm_pluginList);
503  	if (!isSecured)
504  		return false;
505  	isSecured = securityGuard.checkModule(_updaterFullPath, nm_gup);
506  	if (isSecured)
507  	{
508  		HMODULE hLib = NULL;
509  		hLib = ::LoadLibraryEx(_pluginListFullPath.c_str(), 0, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE);
510  		if (!hLib)
511  		{
512  			return false;
513  		}
514  		HRSRC rc = ::FindResource(hLib, MAKEINTRESOURCE(IDR_PLUGINLISTJSONFILE), MAKEINTRESOURCE(TEXTFILE));
515  		if (!rc)
516  		{
517  			::FreeLibrary(hLib);
518  			return false;
519  		}
520  		HGLOBAL rcData = ::LoadResource(hLib, rc);
521  		if (!rcData)
522  		{
523  			::FreeLibrary(hLib);
524  			return false;
525  		}
526  		auto size = ::SizeofResource(hLib, rc);
527  		auto data = static_cast<const char*>(::LockResource(rcData));
528  		char* buffer = new char[size + 1];
529  		::memcpy(buffer, data, size);
530  		buffer[size] = '\0';
531  		j = j.parse(buffer);
532  		delete[] buffer;
533  		::FreeLibrary(hLib);
534  	}
535  #endif
536  	return loadFromJson(_availableList._list, _pluginListVersion, j);
537  }
538  bool PluginsAdminDlg::updateList()
539  {
540  	initAvailablePluginsViewFromList();
541  	checkUpdates();
542  	initIncompatiblePluginList();
543  	loadFromPluginInfos();
544  	return true;
545  }
546  bool PluginsAdminDlg::initAvailablePluginsViewFromList()
547  {
548  	TCHAR nppFullPathName[MAX_PATH]{};
549  	GetModuleFileName(NULL, nppFullPathName, MAX_PATH);
550  	Version nppVer;
551  	nppVer.setVersionFrom(nppFullPathName);
552  	for (const auto& i : _availableList._list)
553  	{
554  		bool isCompatible = nppVer.isCompatibleTo(i->_nppCompatibleVersions.first, i->_nppCompatibleVersions.second);
555  		if (isCompatible)
556  		{
557  			vector<generic_string> values2Add;
558  			values2Add.push_back(i->_displayName);
559  			Version v = i->_version;
560  			values2Add.push_back(v.toString());
561  			size_t j = _availableList._ui.findAlphabeticalOrderPos(i->_displayName, _availableList._sortType == DISPLAY_NAME_ALPHABET_ENCREASE ? ListView::sortEncrease : ListView::sortDecrease);
562  			_availableList._ui.addLine(values2Add, reinterpret_cast<LPARAM>(i), static_cast<int>(j));
563  		}
564  	}
565  	return true;
566  }
567  bool PluginsAdminDlg::initIncompatiblePluginList()
568  {
569  	TCHAR nppFullPathName[MAX_PATH]{};
570  	GetModuleFileName(NULL, nppFullPathName, MAX_PATH);
571  	Version nppVer;
572  	nppVer.setVersionFrom(nppFullPathName);
573  	for (const auto& i : _incompatibleList._list)
574  	{
575  		vector<generic_string> values2Add;
576  		values2Add.push_back(i->_displayName);
577  		Version v = i->_version;
578  		values2Add.push_back(v.toString());
579  		size_t j = _incompatibleList._ui.findAlphabeticalOrderPos(i->_displayName, _incompatibleList._sortType == DISPLAY_NAME_ALPHABET_ENCREASE ? ListView::sortEncrease : ListView::sortDecrease);
580  		_incompatibleList._ui.addLine(values2Add, reinterpret_cast<LPARAM>(i), static_cast<int>(j));
581  	}
582  	return true;
583  }
584  bool PluginsAdminDlg::loadFromPluginInfos()
585  {
586  	if (!_pPluginsManager)
587  		return false;
588  	for (const auto& i : _pPluginsManager->_loadedDlls)
589  	{
590  		if (i._fileName.length() >= MAX_PATH)
591  			continue;
592  		TCHAR fnNoExt[MAX_PATH]{};
593  		wcscpy_s(fnNoExt, i._fileName.c_str());
594  		::PathRemoveExtension(fnNoExt);
595  		int listIndex;
596  		PluginUpdateInfo* foundInfo = _availableList.findPluginInfoFromFolderName(fnNoExt, listIndex);
597  		if (!foundInfo)
598  		{
599  			PluginUpdateInfo* pui = new PluginUpdateInfo(i._fullFilePath, i._fileName);
600  			_installedList.pushBack(pui);
601  		}
602  		else
603  		{
604  			PluginUpdateInfo* pui = new PluginUpdateInfo(*foundInfo);
605  			pui->_fullFilePath = i._fullFilePath;
606  			pui->_version.setVersionFrom(i._fullFilePath);
607  			_installedList.pushBack(pui);
608  			_availableList.hideFromListIndex(listIndex);
609  			if (pui->_version < foundInfo->_version)
610  			{
611  				PluginUpdateInfo* pui2 = new PluginUpdateInfo(*foundInfo);
612  				_updateList.pushBack(pui2);
613  			}
614  		}
615  	}
616  	for (size_t j = 0, nb = _incompatibleList.nbItem(); j < nb; j++)
617  	{
618  		PluginUpdateInfo* incompatiblePluginInfo = _incompatibleList.getPluginInfoFromUiIndex(j);
619  		int listIndex;
620  		PluginUpdateInfo* foundInfoOfAvailable = _availableList.findPluginInfoFromFolderName(incompatiblePluginInfo->_folderName, listIndex);
621  		if (foundInfoOfAvailable)
622  		{
623  			if (foundInfoOfAvailable->_version > incompatiblePluginInfo->_version)
624  			{
625  				_availableList.hideFromListIndex(listIndex);
626  				PluginUpdateInfo* pui = new PluginUpdateInfo(*foundInfoOfAvailable);
627  				_updateList.pushBack(pui);
628  			}
629  		}
630  	}
631  	return true;
632  }
633  PluginUpdateInfo* PluginViewList::findPluginInfoFromFolderName(const generic_string& folderName, int& index) const
634  {
635  	index = 0;
636  	for (const auto& i : _list)
637  	{
638  		if (lstrcmpi(i->_folderName.c_str(), folderName.c_str()) == 0)
639  			return i;
640  		++index;
641  	}
642  	index = -1;
643  	return nullptr;
644  }
645  bool PluginViewList::removeFromUiIndex(size_t index2remove)
646  {
647  	if (index2remove >= _ui.nbItem())
648  		return false;
649  	return _ui.removeFromIndex(index2remove);
650  }
651  bool PluginViewList::removeFromListIndex(size_t index2remove)
652  {
653  	if (index2remove >= _list.size())
654  		return false;
655  	for (size_t i = 0; i < _ui.nbItem(); ++i)
656  	{
657  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(_list[index2remove]))
658  		{
659  			if (!_ui.removeFromIndex(i))
660  				return false;
661  		}
662  	}
663  	_list.erase(_list.begin() + index2remove);
664  	return true;
665  }
666  bool PluginViewList::removeFromPluginInfoPtr(PluginUpdateInfo* pluginInfo2hide)
667  {
668  	for (size_t i = 0; i < _ui.nbItem(); ++i)
669  	{
670  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(pluginInfo2hide))
671  		{
672  			if (!_ui.removeFromIndex(static_cast<int>(i)))
673  			{
674  				return false;
675  			}
676  		}
677  	}
678  	for (size_t j = 0; j < _list.size(); ++j)
679  	{
680  		if (_list[j] == pluginInfo2hide)
681  		{
682  			_list.erase(_list.begin() + j);
683  			return true;
684  		}
685  	}
686  	return false;
687  }
688  bool PluginViewList::hideFromPluginInfoPtr(PluginUpdateInfo* pluginInfo2hide)
689  {
690  	for (size_t i = 0; i < _ui.nbItem(); ++i)
691  	{
692  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(pluginInfo2hide))
693  		{
694  			if (!_ui.removeFromIndex(static_cast<int>(i)))
695  			{
696  				return false;
697  			}
698  			else
699  			{
700  				pluginInfo2hide->_isVisible = false;
701  				return true;
702  			}
703  		}
704  	}
705  	return false;
706  }
707  bool PluginViewList::restore(const generic_string& folderName)
708  {
709  	for (const auto &i : _list)
710  	{
711  		if (i->_folderName == folderName)
712  		{
713  			vector<generic_string> values2Add;
714  			values2Add.push_back(i->_displayName);
715  			Version v = i->_version;
716  			values2Add.push_back(v.toString());
717  			values2Add.push_back(TEXT("Yes"));
718  			_ui.addLine(values2Add, reinterpret_cast<LPARAM>(i));
719  			i->_isVisible = true;
720  			return true;
721  		}
722  	}
723  	return false;
724  }
725  bool PluginViewList::hideFromListIndex(size_t index2hide)
726  {
727  	if (index2hide >= _list.size())
728  		return false;
729  	for (size_t i = 0; i < _ui.nbItem(); ++i)
730  	{
731  		if (_ui.getLParamFromIndex(static_cast<int>(i)) == reinterpret_cast<LPARAM>(_list[index2hide]))
732  		{
733  			if (!_ui.removeFromIndex(static_cast<int>(i)))
734  				return false;
735  		}
736  	}
737  	_list[index2hide]->_isVisible = false;
738  	return true;
739  }
740  bool PluginsAdminDlg::checkUpdates()
741  {
742  	return true;
743  }
744  bool PluginsAdminDlg::searchInPlugins(bool isNextMode) const
745  {
746  	constexpr int maxLen = 256;
747  	TCHAR txt2search[maxLen]{};
748  	::GetDlgItemText(_hSelf, IDC_PLUGINADM_SEARCH_EDIT, txt2search, maxLen);
749  	if (lstrlen(txt2search) < 2)
750  		return false;
751  	HWND tabHandle = _tab.getHSelf();
752  	int inWhichTab = int(::SendMessage(tabHandle, TCM_GETCURSEL, 0, 0));
753  	const PluginViewList* inWhichList = nullptr;
754  	switch (inWhichTab)
755  	{
756  	case 3:
757  		inWhichList = &_incompatibleList;
758  		break;
759  	case 2:
760  		inWhichList = &_installedList;
761  		break;
762  	case 1:
763  		inWhichList = &_updateList;
764  		break;
765  	case 0:
766  	default:
767  		inWhichList = &_availableList;
768  		break;
769  	}
770  	long foundIndex = searchInNamesFromCurrentSel(*inWhichList, txt2search, isNextMode);
771  	if (foundIndex == -1)
772  		foundIndex = searchInDescsFromCurrentSel(*inWhichList, txt2search, isNextMode);
773  	if (foundIndex == -1)
774  		return false;
775  	inWhichList->setSelection(foundIndex);
776  	return true;
777  }
778  void PluginsAdminDlg::switchDialog(int indexToSwitch)
779  {
780  	generic_string desc;
781  	bool showAvailable, showUpdate, showInstalled, showIncompatibile;
782  	switch (indexToSwitch)
783  	{
784  		case 0: 
785  		{
786  			showAvailable = true;
787  			showUpdate = false;
788  			showInstalled = false;
789  			showIncompatibile = false;
790  			long infoIndex = _availableList.getSelectedIndex();
791  			if (infoIndex != -1 && infoIndex < static_cast<long>(_availableList.nbItem()))
792  				desc = _availableList.getPluginInfoFromUiIndex(infoIndex)->describe();
793  		}
794  		break;
795  		case 1: 
796  		{
797  			showAvailable = false;
798  			showUpdate = true;
799  			showInstalled = false;
800  			showIncompatibile = false;
801  			long infoIndex = _updateList.getSelectedIndex();
802  			if (infoIndex != -1 && infoIndex < static_cast<long>(_updateList.nbItem()))
803  				desc = _updateList.getPluginInfoFromUiIndex(infoIndex)->describe();
804  		}
805  		break;
806  		case 2: 
807  		{
808  			showAvailable = false;
809  			showUpdate = false;
810  			showInstalled = true;
811  			showIncompatibile = false;
812  			long infoIndex = _installedList.getSelectedIndex();
813  			if (infoIndex != -1 && infoIndex < static_cast<long>(_installedList.nbItem()))
814  				desc = _installedList.getPluginInfoFromUiIndex(infoIndex)->describe();
815  		}
816  		break;
817  		case 3: 
818  		{
819  			showAvailable = false;
820  			showUpdate = false;
821  			showInstalled = false;
822  			showIncompatibile = true;
823  			long infoIndex = _incompatibleList.getSelectedIndex();
824  			if (infoIndex != -1 && infoIndex < static_cast<long>(_incompatibleList.nbItem()))
825  				desc = _incompatibleList.getPluginInfoFromUiIndex(infoIndex)->_description;
826  		}
827  		break;
828  		default:
829  			return;
830  	}
831  	_availableList.displayView(showAvailable);
832  	_updateList.displayView(showUpdate);
833  	_installedList.displayView(showInstalled);
834  	_incompatibleList.displayView(showIncompatibile);
835  	::SetDlgItemText(_hSelf, IDC_PLUGINADM_EDIT, desc.c_str());
836  	HWND hInstallButton = ::GetDlgItem(_hSelf, IDC_PLUGINADM_INSTALL);
837  	HWND hUpdateButton = ::GetDlgItem(_hSelf, IDC_PLUGINADM_UPDATE);
838  	HWND hRemoveButton = ::GetDlgItem(_hSelf, IDC_PLUGINADM_REMOVE);
839  	::ShowWindow(hInstallButton, showAvailable ? SW_SHOW : SW_HIDE);
840  	if (showAvailable)
841  	{
842  		vector<size_t> checkedArray = _availableList.getCheckedIndexes();
843  		showAvailable = checkedArray.size() > 0;
844  	}
845  	::EnableWindow(hInstallButton, showAvailable);
846  	::ShowWindow(hUpdateButton, showUpdate ? SW_SHOW : SW_HIDE);
847  	if (showUpdate)
848  	{
849  		vector<size_t> checkedArray = _updateList.getCheckedIndexes();
850  		showUpdate = checkedArray.size() > 0;
851  	}
852  	::EnableWindow(hUpdateButton, showUpdate);
853  	::ShowWindow(hRemoveButton, showInstalled ? SW_SHOW : SW_HIDE);
854  	if (showInstalled)
855  	{
856  		vector<size_t> checkedArray = _installedList.getCheckedIndexes();
857  		showInstalled = checkedArray.size() > 0;
858  	}
859  	::EnableWindow(hRemoveButton, showInstalled);
860  }
861  intptr_t CALLBACK PluginsAdminDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
862  {
863  	switch (message)
864  	{
865  		case WM_CTLCOLOREDIT:
866  		{
867  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
868  		}
869  		case WM_CTLCOLORDLG:
870  		{
871  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
872  		}
873  		case WM_CTLCOLORSTATIC:
874  		{
875  			if (NppDarkMode::isEnabled())
876  			{
877  				const int dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
878  				if (dlgCtrlID == IDC_PLUGINADM_EDIT)
879  				{
880  					return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
881  				}
882  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
883  			}
884  			break;
885  		}
886  		case WM_PRINTCLIENT:
887  		{
888  			if (NppDarkMode::isEnabled())
889  			{
890  				return TRUE;
891  			}
892  			break;
893  		}
894  		case NPPM_INTERNAL_REFRESHDARKMODE:
895  		{
896  			NppDarkMode::autoThemeChildControls(_hSelf);
897  			return TRUE;
898  		}
899  		case WM_COMMAND :
900  		{
901  			if (HIWORD(wParam) == EN_CHANGE)
902  			{
903  				switch (LOWORD(wParam))
904  				{
905  					case  IDC_PLUGINADM_SEARCH_EDIT:
906  					{
907  						searchInPlugins(false);
908  						return TRUE;
909  					}
910  				}
911  			}
912  			switch (wParam)
913  			{
914  				case IDOK:
915  					if (::GetFocus() == ::GetDlgItem(_hSelf, IDC_PLUGINADM_SEARCH_EDIT))
916  						::PostMessage(_hSelf, WM_NEXTDLGCTL, 0, 0L);
917  					return TRUE;
918  				case IDCANCEL:
919  					display(false);
920  					return TRUE;
921  				case IDC_PLUGINADM_RESEARCH_NEXT:
922  					searchInPlugins(true);
923  					return true;
924  				case IDC_PLUGINADM_INSTALL:
925  					installPlugins();
926  					return true;
927  				case IDC_PLUGINADM_UPDATE:
928  					updatePlugins();
929  					return true;
930  				case IDC_PLUGINADM_REMOVE:
931  				{
932  					removePlugins();
933  					return true;
934  				}
935  				default :
936  					break;
937  			}
938  			return FALSE;
939  		}
940  		case WM_NOTIFY :
941  		{
942  			LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
943  			if (pnmh->code == TCN_SELCHANGE)
944  			{
945  				HWND tabHandle = _tab.getHSelf();
946  				if (pnmh->hwndFrom == tabHandle)
947  				{
948  					int indexClicked = int(::SendMessage(tabHandle, TCM_GETCURSEL, 0, 0));
949  					switchDialog(indexClicked);
950  				}
951  			}
952  			else if (pnmh->hwndFrom == _availableList.getViewHwnd() ||
953                       pnmh->hwndFrom == _updateList.getViewHwnd() ||
954                       pnmh->hwndFrom == _installedList.getViewHwnd() ||
955                       pnmh->hwndFrom == _incompatibleList.getViewHwnd())
956  			{
957  				PluginViewList* pViewList = nullptr;
958  				int buttonID = 0;
959  				if (pnmh->hwndFrom == _availableList.getViewHwnd())
960  				{
961  					pViewList = &_availableList;
962  					buttonID = IDC_PLUGINADM_INSTALL;
963  				}
964  				else if (pnmh->hwndFrom == _updateList.getViewHwnd())
965  				{
966  					pViewList = &_updateList;
967  					buttonID = IDC_PLUGINADM_UPDATE;
968  				}
969  				else if (pnmh->hwndFrom == _installedList.getViewHwnd())
970  				{
971  					pViewList = &_installedList;
972  					buttonID = IDC_PLUGINADM_REMOVE;
973  				}
974  				else 
975  				{
976  					pViewList = &_incompatibleList;
977  					buttonID = 0;
978  				}
979  				LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;
980  				if (pnmh->code == LVN_ITEMCHANGED)
981  				{
982  					if (pnmv->uChanged & LVIF_STATE)
983  					{
984  						if ((pnmv->uNewState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(2) || 
985  							(pnmv->uNewState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(1))   
986  						{
987  							if (buttonID)
988  							{
989  								HWND hButton = ::GetDlgItem(_hSelf, buttonID);
990  								vector<size_t> checkedArray = pViewList->getCheckedIndexes();
991  								bool showButton = checkedArray.size() > 0;
992  								::EnableWindow(hButton, showButton);
993  							}
994  						}
995  						else if (pnmv->uNewState & LVIS_SELECTED)
996  						{
997  							PluginUpdateInfo* pui = pViewList->getPluginInfoFromUiIndex(pnmv->iItem);
998  							generic_string desc = buttonID ? pui->describe() : pui->_description;
999  							::SetDlgItemText(_hSelf, IDC_PLUGINADM_EDIT, desc.c_str());
1000  						}
1001  					}
1002  				}
1003  			}
1004  			return TRUE;
1005  		}
1006  		case WM_DESTROY :
1007  		{
1008  			return TRUE;
1009  		}
1010  	}
1011  	return FALSE;
1012  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-os.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-pluginsAdmin.cpp</div>
                </div>
                <div class="column column_space"><pre><code>544    int MSec = Tm.GetMSec();
545    time_t Sec = timegm(&tms);
546    localtime_r(&Sec, &tmr);
547    return TTm(1900+tmr.tm_year, tmr.tm_mon, tmr.tm_mday, tmr.tm_wday,
548     tmr.tm_hour, tmr.tm_min, tmr.tm_sec, MSec);
549  }
550  TTm TSysTm::GetUniTmFromLocTm(const TTm& Tm) {
551    struct tm tms, tmr;
552    tms.tm_year = Tm.GetYear() - 1900;
</pre></code></div>
                <div class="column column_space"><pre><code>266  	vector<size_t> indexes = _availableList.getCheckedIndexes();
267  	vector<PluginUpdateInfo*> puis = _availableList.fromUiIndexesToPluginInfos(indexes);
268  	return exitToInstallRemovePlugins(pa_install, puis);
269  }
270  bool PluginsAdminDlg::updatePlugins()
271  {
272  	vector<size_t> indexes = _updateList.getCheckedIndexes();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    