
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 40.38004750593824%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-peer_container.cpp</h3>
            <pre><code>1  #include <nano/node/transport/socket.hpp>
2  #include <nano/node/transport/tcp.hpp>
3  #include <nano/node/transport/tcp_server.hpp>
4  #include <nano/test_common/network.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  #include <memory>
9  using namespace std::chrono_literals;
10  TEST (peer_container, empty_peers)
11  {
12  	nano::test::system system (1);
13  	nano::network & network (system.nodes[0]->network);
14  	system.nodes[0]->network.cleanup (std::chrono::steady_clock::now ());
15  	ASSERT_EQ (0, network.size ());
16  }
17  TEST (peer_container, no_self_incoming)
18  {
19  	nano::test::system system{ 1 };
20  	auto & node = *system.nodes[0];
21  	node.network.tcp_channels.start_tcp (node.network.endpoint ());
22  	auto error = system.poll_until_true (2s, [&node] {
23  		auto result = node.network.tcp_channels.find_channel (nano::transport::map_endpoint_to_tcp (node.network.endpoint ()));
24  		return result != nullptr;
25  	});
26  	ASSERT_TRUE (error);
27  	ASSERT_TRUE (system.nodes[0]->network.empty ());
28  }
29  TEST (peer_container, reserved_ip_is_not_a_peer)
30  {
31  	nano::test::system system{ 1 };
32  	auto not_a_peer = [&node = system.nodes[0]] (nano::endpoint endpoint_a) -> bool {
33  		return node->network.not_a_peer (endpoint_a, true);
34  	};
35  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0x00000001)), 10000))));
36  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xc0000201)), 10000))));
37  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xc6336401)), 10000))));
38  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xcb007101)), 10000))));
39  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xe9fc0001)), 10000))));
40  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xf0000001)), 10000))));
41  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xffffffff)), 10000))));
42  	ASSERT_FALSE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0x08080808)), 10000))));
43  }
44  TEST (peer_container, tcp_channel_cleanup_works)
45  {
46  	nano::test::system system;
47  	nano::node_config node_config = system.default_config ();
48  	node_config.network_params.network.keepalive_period = std::chrono::minutes (10);
49  	nano::node_flags node_flags;
50  	node_flags.disable_connection_cleanup = true;
51  	node_flags.disable_rep_crawler = true;
52  	auto & node1 = *system.add_node (node_config, node_flags);
53  	auto outer_node1 = nano::test::add_outer_node (system, node_flags);
54  	outer_node1->config.network_params.network.keepalive_period = std::chrono::minutes (10);
55  	auto outer_node2 = nano::test::add_outer_node (system, node_flags);
56  	outer_node2->config.network_params.network.keepalive_period = std::chrono::minutes (10);
57  	auto now = std::chrono::steady_clock::now ();
58  	auto channel1 = nano::test::establish_tcp (system, node1, outer_node1->network.endpoint ());
59  	ASSERT_NE (nullptr, channel1);
60  	node1.network.tcp_channels.modify (channel1, [&now] (auto channel) {
61  		channel->set_last_packet_sent (now - std::chrono::seconds (5));
62  	});
63  	auto channel2 = nano::test::establish_tcp (system, node1, outer_node2->network.endpoint ());
64  	ASSERT_NE (nullptr, channel2);
65  	node1.network.tcp_channels.modify (channel2, [&now] (auto channel) {
66  		channel->set_last_packet_sent (now + std::chrono::seconds (1));
67  	});
68  	ASSERT_EQ (2, node1.network.size ());
69  	ASSERT_EQ (2, node1.network.tcp_channels.size ());
70  	for (auto it = 0; node1.network.tcp_channels.size () > 1 && it < 10; ++it)
71  	{
72  		auto const channel1_last_packet_sent = channel1->get_last_packet_sent ();
73  		auto const channel2_last_packet_sent = channel2->get_last_packet_sent ();
74  		auto const max_last_packet_sent = std::max (channel1_last_packet_sent, channel2_last_packet_sent);
75  		auto const min_last_packet_sent = std::min (channel1_last_packet_sent, channel2_last_packet_sent);
76  		auto const cleanup_point = ((max_last_packet_sent - min_last_packet_sent) / 2) + min_last_packet_sent;
77  		node1.network.cleanup (cleanup_point);
78  		if (node1.network.tcp_channels.size () == 2)
79  		{
80  			WAIT (500ms);
81  		}
82  	}
83  	ASSERT_EQ (1, node1.network.size ());
84  	ASSERT_EQ (1, node1.network.tcp_channels.size ());
85  }
86  TEST (channels, fill_random_clear)
87  {
88  	nano::test::system system (1);
89  	std::array<nano::endpoint, 8> target;
90  	std::fill (target.begin (), target.end (), nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000));
91  	system.nodes[0]->network.random_fill (target);
92  	ASSERT_TRUE (std::all_of (target.begin (), target.end (), [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::any (), 0); }));
93  }
94  TEST (channels, fill_random_full)
95  {
96  	nano::test::system system{ 1 };
97  	for (int i = 0; i < 8; ++i)
98  	{
99  		auto outer_node = nano::test::add_outer_node (system);
100  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
101  	}
102  	ASSERT_TIMELY_EQ (5s, 8, system.nodes[0]->network.tcp_channels.size ());
103  	auto filler_endpoint = nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000);
104  	std::array<nano::endpoint, 8> target;
105  	std::fill (target.begin (), target.end (), filler_endpoint);
106  	system.nodes[0]->network.random_fill (target);
107  	auto is_filler = [&filler_endpoint] (nano::endpoint const & endpoint_a) {
108  		return endpoint_a == filler_endpoint;
109  	};
110  	ASSERT_TRUE (std::none_of (target.begin (), target.end (), is_filler));
111  }
112  TEST (channels, fill_random_part)
113  {
114  	nano::test::system system{ 1 };
115  	std::array<nano::endpoint, 8> target;
<span onclick='openModal()' class='match'>116  	std::size_t half = target.size () / 2;
117  	for (std::size_t i = 0; i < half; ++i)
118  	{
119  		auto outer_node = nano::test::add_outer_node (system);
120  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
</span>121  	}
122  	ASSERT_EQ (half, system.nodes[0]->network.tcp_channels.size ());
123  	std::fill (target.begin (), target.end (), nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000));
124  	system.nodes[0]->network.random_fill (target);
125  	ASSERT_TRUE (std::none_of (target.begin (), target.begin () + half, [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000); }));
126  	ASSERT_TRUE (std::none_of (target.begin (), target.begin () + half, [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::loopback (), 0); }));
127  	ASSERT_TRUE (std::all_of (target.begin () + half, target.end (), [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::any (), 0); }));
128  }
129  TEST (peer_container, list_fanout)
130  {
131  	nano::test::system system{ 1 };
132  	auto node = system.nodes[0];
133  	ASSERT_EQ (0, node->network.size ());
134  	ASSERT_EQ (0.0, node->network.size_sqrt ());
135  	ASSERT_EQ (0, node->network.fanout ());
136  	ASSERT_TRUE (node->network.list (node->network.fanout ()).empty ());
137  	auto add_peer = [&node, &system] () {
138  		auto outer_node = nano::test::add_outer_node (system);
139  		auto channel = nano::test::establish_tcp (system, *node, outer_node->network.endpoint ());
140  	};
141  	add_peer ();
142  	ASSERT_TIMELY_EQ (5s, 1, node->network.size ());
143  	ASSERT_EQ (1.f, node->network.size_sqrt ());
144  	ASSERT_EQ (1, node->network.fanout ());
145  	ASSERT_EQ (1, node->network.list (node->network.fanout ()).size ());
146  	add_peer ();
147  	ASSERT_TIMELY_EQ (5s, 2, node->network.size ());
148  	ASSERT_EQ (std::sqrt (2.f), node->network.size_sqrt ());
149  	ASSERT_EQ (2, node->network.fanout ());
150  	ASSERT_EQ (2, node->network.list (node->network.fanout ()).size ());
151  	unsigned number_of_peers = 10;
152  	for (unsigned i = 2; i < number_of_peers; ++i)
153  	{
154  		add_peer ();
155  	}
156  	ASSERT_TIMELY_EQ (5s, number_of_peers, node->network.size ());
157  	ASSERT_EQ (std::sqrt (float (number_of_peers)), node->network.size_sqrt ());
158  	ASSERT_EQ (4, node->network.fanout ());
159  	ASSERT_EQ (4, node->network.list (node->network.fanout ()).size ());
160  }
161  TEST (peer_container, reachout)
162  {
163  	nano::test::system system;
164  	nano::node_flags node_flags;
165  	auto & node1 = *system.add_node (node_flags);
166  	auto outer_node1 = nano::test::add_outer_node (system);
167  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, node1, outer_node1->network.endpoint ()));
168  	ASSERT_TRUE (node1.network.reachout (outer_node1->network.endpoint ()));
169  	auto outer_node2 = nano::test::add_outer_node (system);
170  	ASSERT_FALSE (node1.network.reachout (outer_node2->network.endpoint ()));
171  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, node1, outer_node2->network.endpoint ()));
172  	ASSERT_TRUE (node1.network.reachout (outer_node2->network.endpoint ()));
173  	node1.network.cleanup (std::chrono::steady_clock::now () - std::chrono::seconds (10));
174  	ASSERT_TRUE (node1.network.reachout (outer_node2->network.endpoint ()));
175  	node1.network.cleanup (std::chrono::steady_clock::now () + std::chrono::seconds (10));
176  	ASSERT_FALSE (node1.network.reachout (outer_node2->network.endpoint ()));
177  }
178  TEST (peer_container, depeer_on_outdated_version)
179  {
180  	nano::test::system system{ 2 };
181  	auto & node1 = *system.nodes[0];
182  	auto & node2 = *system.nodes[1];
183  	auto channel = node2.network.find_node_id (node1.get_node_id ());
184  	ASSERT_NE (nullptr, channel);
185  	nano::keepalive keepalive{ nano::dev::network_params.network };
186  	const_cast<uint8_t &> (keepalive.header.version_using) = nano::dev::network_params.network.protocol_version_min - 1;
187  	ASSERT_TIMELY (5s, channel->alive ());
188  	channel->send (keepalive);
189  	ASSERT_TIMELY (5s, !channel->alive ());
190  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_buffer_test.cc</h3>
            <pre><code>1  #include "absl/strings/cord_buffer.h"
2  #include <algorithm>
3  #include <climits>
4  #include <cstring>
5  #include <string>
6  #include <utility>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/strings/internal/cord_rep_flat.h"
11  #include "absl/strings/internal/cord_rep_test_util.h"
12  #include "absl/types/span.h"
13  using testing::Eq;
14  using testing::Ge;
15  using testing::Le;
16  using testing::Ne;
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  class CordBufferTestPeer {
20   public:
21    static cord_internal::CordRep* ConsumeValue(CordBuffer& buffer,
22                                                absl::string_view& short_value) {
23      return buffer.ConsumeValue(short_value);
24    }
25  };
26  namespace {
27  using ::absl::cordrep_testing::CordToString;
28  constexpr size_t kInlinedSize = sizeof(CordBuffer) - 1;
29  constexpr size_t kDefaultLimit = CordBuffer::kDefaultLimit;
30  constexpr size_t kCustomLimit = CordBuffer::kCustomLimit;
31  constexpr size_t kMaxFlatSize = cord_internal::kMaxFlatSize;
32  constexpr size_t kMaxFlatLength = cord_internal::kMaxFlatLength;
33  constexpr size_t kFlatOverhead = cord_internal::kFlatOverhead;
34  constexpr size_t k8KiB = 8 << 10;
35  constexpr size_t k16KiB = 16 << 10;
36  constexpr size_t k64KiB = 64 << 10;
37  constexpr size_t k1MB = 1 << 20;
38  class CordBufferTest : public testing::TestWithParam<size_t> {};
39  INSTANTIATE_TEST_SUITE_P(MediumSize, CordBufferTest,
40                           testing::Values(1, kInlinedSize - 1, kInlinedSize,
41                                           kInlinedSize + 1, kDefaultLimit - 1,
42                                           kDefaultLimit));
43  TEST_P(CordBufferTest, MaximumPayload) {
44    EXPECT_THAT(CordBuffer::MaximumPayload(), Eq(kMaxFlatLength));
45    EXPECT_THAT(CordBuffer::MaximumPayload(512), Eq(512 - kFlatOverhead));
46    EXPECT_THAT(CordBuffer::MaximumPayload(k64KiB), Eq(k64KiB - kFlatOverhead));
47    EXPECT_THAT(CordBuffer::MaximumPayload(k1MB), Eq(k64KiB - kFlatOverhead));
48  }
49  TEST(CordBufferTest, ConstructDefault) {
50    CordBuffer buffer;
51    EXPECT_THAT(buffer.capacity(), Eq(sizeof(CordBuffer) - 1));
52    EXPECT_THAT(buffer.length(), Eq(0));
53    EXPECT_THAT(buffer.data(), Ne(nullptr));
54    EXPECT_THAT(buffer.available().data(), Eq(buffer.data()));
55    EXPECT_THAT(buffer.available().size(), Eq(buffer.capacity()));
56    memset(buffer.data(), 0xCD, buffer.capacity());
57  }
58  TEST(CordBufferTest, CreateSsoWithDefaultLimit) {
59    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(3);
60    EXPECT_THAT(buffer.capacity(), Ge(3));
61    EXPECT_THAT(buffer.capacity(), Le(sizeof(CordBuffer)));
62    EXPECT_THAT(buffer.length(), Eq(0));
63    memset(buffer.data(), 0xCD, buffer.capacity());
64    memcpy(buffer.data(), "Abc", 3);
65    buffer.SetLength(3);
66    EXPECT_THAT(buffer.length(), Eq(3));
67    absl::string_view short_value;
68    EXPECT_THAT(CordBufferTestPeer::ConsumeValue(buffer, short_value),
69                Eq(nullptr));
70    EXPECT_THAT(absl::string_view(buffer.data(), 3), Eq("Abc"));
71    EXPECT_THAT(short_value, Eq("Abc"));
72  }
73  TEST_P(CordBufferTest, Available) {
74    const size_t requested = GetParam();
75    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(requested);
76    EXPECT_THAT(buffer.available().data(), Eq(buffer.data()));
77    EXPECT_THAT(buffer.available().size(), Eq(buffer.capacity()));
78    buffer.SetLength(2);
79    EXPECT_THAT(buffer.available().data(), Eq(buffer.data() + 2));
80    EXPECT_THAT(buffer.available().size(), Eq(buffer.capacity() - 2));
81  }
82  TEST_P(CordBufferTest, IncreaseLengthBy) {
83    const size_t requested = GetParam();
84    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(requested);
85    buffer.IncreaseLengthBy(2);
86    EXPECT_THAT(buffer.length(), Eq(2));
87    buffer.IncreaseLengthBy(5);
88    EXPECT_THAT(buffer.length(), Eq(7));
89  }
90  TEST_P(CordBufferTest, AvailableUpTo) {
91    const size_t requested = GetParam();
92    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(requested);
93    size_t expected_up_to = std::min<size_t>(3, buffer.capacity());
94    EXPECT_THAT(buffer.available_up_to(3).data(), Eq(buffer.data()));
95    EXPECT_THAT(buffer.available_up_to(3).size(), Eq(expected_up_to));
96    buffer.SetLength(2);
97    expected_up_to = std::min<size_t>(3, buffer.capacity() - 2);
98    EXPECT_THAT(buffer.available_up_to(3).data(), Eq(buffer.data() + 2));
99    EXPECT_THAT(buffer.available_up_to(3).size(), Eq(expected_up_to));
100  }
101  size_t MaxCapacityFor(size_t block_size, size_t requested) {
102    requested = (std::min)(requested, cord_internal::kMaxLargeFlatSize);
103    return block_size - kFlatOverhead;
104  }
105  TEST_P(CordBufferTest, CreateWithDefaultLimit) {
106    const size_t requested = GetParam();
107    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(requested);
108    EXPECT_THAT(buffer.capacity(), Ge(requested));
109    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(kMaxFlatSize, requested)));
110    EXPECT_THAT(buffer.length(), Eq(0));
111    memset(buffer.data(), 0xCD, buffer.capacity());
112    std::string data(requested - 1, 'x');
113    memcpy(buffer.data(), data.c_str(), requested);
114    buffer.SetLength(requested);
115    EXPECT_THAT(buffer.length(), Eq(requested));
116    EXPECT_THAT(absl::string_view(buffer.data()), Eq(data));
117  }
118  TEST(CordBufferTest, CreateWithDefaultLimitAskingFor2GB) {
119    constexpr size_t k2GiB = 1U << 31;
120    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(k2GiB);
121    EXPECT_THAT(buffer.capacity(), Le(2 * CordBuffer::kDefaultLimit));
122    EXPECT_THAT(buffer.length(), Eq(0));
123    EXPECT_THAT(buffer.data(), Ne(nullptr));
124    memset(buffer.data(), 0xCD, buffer.capacity());
125  }
126  TEST_P(CordBufferTest, MoveConstruct) {
127    const size_t requested = GetParam();
128    CordBuffer from = CordBuffer::CreateWithDefaultLimit(requested);
129    const size_t capacity = from.capacity();
130    memcpy(from.data(), "Abc", 4);
131    from.SetLength(4);
132    CordBuffer to(std::move(from));
133    EXPECT_THAT(to.capacity(), Eq(capacity));
134    EXPECT_THAT(to.length(), Eq(4));
135    EXPECT_THAT(absl::string_view(to.data()), Eq("Abc"));
136    EXPECT_THAT(from.length(), Eq(0));  
137  }
138  TEST_P(CordBufferTest, MoveAssign) {
139    const size_t requested = GetParam();
140    CordBuffer from = CordBuffer::CreateWithDefaultLimit(requested);
141    const size_t capacity = from.capacity();
142    memcpy(from.data(), "Abc", 4);
143    from.SetLength(4);
144    CordBuffer to;
145    to = std::move(from);
146    EXPECT_THAT(to.capacity(), Eq(capacity));
147    EXPECT_THAT(to.length(), Eq(4));
148    EXPECT_THAT(absl::string_view(to.data()), Eq("Abc"));
149    EXPECT_THAT(from.length(), Eq(0));  
150  }
151  TEST_P(CordBufferTest, ConsumeValue) {
152    const size_t requested = GetParam();
153    CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(requested);
154    memcpy(buffer.data(), "Abc", 4);
155    buffer.SetLength(3);
156    absl::string_view short_value;
157    if (cord_internal::CordRep* rep =
158            CordBufferTestPeer::ConsumeValue(buffer, short_value)) {
159      EXPECT_THAT(CordToString(rep), Eq("Abc"));
160      cord_internal::CordRep::Unref(rep);
161    } else {
162      EXPECT_THAT(short_value, Eq("Abc"));
163    }
164    EXPECT_THAT(buffer.length(), Eq(0));
165  }
166  TEST_P(CordBufferTest, CreateWithCustomLimitWithinDefaultLimit) {
167    const size_t requested = GetParam();
168    CordBuffer buffer =
169        CordBuffer::CreateWithCustomLimit(kMaxFlatSize, requested);
170    EXPECT_THAT(buffer.capacity(), Ge(requested));
171    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(kMaxFlatSize, requested)));
172    EXPECT_THAT(buffer.length(), Eq(0));
173    memset(buffer.data(), 0xCD, buffer.capacity());
174    std::string data(requested - 1, 'x');
175    memcpy(buffer.data(), data.c_str(), requested);
176    buffer.SetLength(requested);
177    EXPECT_THAT(buffer.length(), Eq(requested));
178    EXPECT_THAT(absl::string_view(buffer.data()), Eq(data));
179  }
180  TEST(CordLargeBufferTest, CreateAtOrBelowDefaultLimit) {
181    CordBuffer buffer = CordBuffer::CreateWithCustomLimit(k64KiB, kDefaultLimit);
182    EXPECT_THAT(buffer.capacity(), Ge(kDefaultLimit));
183    EXPECT_THAT(buffer.capacity(),
184                Le(MaxCapacityFor(kMaxFlatSize, kDefaultLimit)));
185    buffer = CordBuffer::CreateWithCustomLimit(k64KiB, 3178);
186    EXPECT_THAT(buffer.capacity(), Ge(3178));
187  }
188  TEST(CordLargeBufferTest, CreateWithCustomLimit) {
189    ASSERT_THAT((kMaxFlatSize & (kMaxFlatSize - 1)) == 0, "Must be power of 2");
190    for (size_t size = kMaxFlatSize; size <= kCustomLimit; size *= 2) {
191      CordBuffer buffer = CordBuffer::CreateWithCustomLimit(size, size);
192      size_t expected = size - kFlatOverhead;
193      ASSERT_THAT(buffer.capacity(), Ge(expected));
194      EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(size, expected)));
195    }
196  }
197  TEST(CordLargeBufferTest, CreateWithTooLargeLimit) {
198    CordBuffer buffer = CordBuffer::CreateWithCustomLimit(k64KiB, k1MB);
199    ASSERT_THAT(buffer.capacity(), Ge(k64KiB - kFlatOverhead));
200    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(k64KiB, k1MB)));
201  }
202  TEST(CordLargeBufferTest, CreateWithHugeValueForOverFlowHardening) {
203    for (size_t dist_from_max = 0; dist_from_max <= 32; ++dist_from_max) {
204      size_t capacity = std::numeric_limits<size_t>::max() - dist_from_max;
205      CordBuffer buffer = CordBuffer::CreateWithDefaultLimit(capacity);
206      ASSERT_THAT(buffer.capacity(), Ge(kDefaultLimit));
<span onclick='openModal()' class='match'>207      EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(kMaxFlatSize, capacity)));
208      for (size_t limit = kMaxFlatSize; limit <= kCustomLimit; limit *= 2) {
209        CordBuffer buffer = CordBuffer::CreateWithCustomLimit(limit, capacity);
210        ASSERT_THAT(buffer.capacity(), Ge(limit - kFlatOverhead));
</span>211        EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(limit, capacity)));
212      }
213    }
214  }
215  TEST(CordLargeBufferTest, CreateWithSmallLimit) {
216    CordBuffer buffer = CordBuffer::CreateWithCustomLimit(512, 1024);
217    ASSERT_THAT(buffer.capacity(), Ge(512 - kFlatOverhead));
218    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(512, 1024)));
219    buffer = CordBuffer::CreateWithCustomLimit(512, 512);
220    ASSERT_THAT(buffer.capacity(), Ge(512 - kFlatOverhead));
221    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(512, 512)));
222    buffer = CordBuffer::CreateWithCustomLimit(512, 511);
223    ASSERT_THAT(buffer.capacity(), Ge(512 - kFlatOverhead));
224    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(512, 511)));
225    buffer = CordBuffer::CreateWithCustomLimit(512, 498);
226    ASSERT_THAT(buffer.capacity(), Ge(512 - kFlatOverhead));
227    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(512, 498)));
228  }
229  TEST(CordLargeBufferTest, CreateWasteFull) {
230    const size_t requested = (15 << 10);
231    CordBuffer buffer = CordBuffer::CreateWithCustomLimit(k16KiB, requested);
232    ASSERT_THAT(buffer.capacity(), Ge(k8KiB - kFlatOverhead));
233    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(k8KiB, requested)));
234  }
235  TEST(CordLargeBufferTest, CreateSmallSlop) {
236    const size_t requested = k16KiB - 2 * kFlatOverhead;
237    CordBuffer buffer = CordBuffer::CreateWithCustomLimit(k16KiB, requested);
238    ASSERT_THAT(buffer.capacity(), Ge(k16KiB - kFlatOverhead));
239    EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(k16KiB, requested)));
240  }
241  }  
242  ABSL_NAMESPACE_END
243  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-peer_container.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_buffer_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>116  	std::size_t half = target.size () / 2;
117  	for (std::size_t i = 0; i < half; ++i)
118  	{
119  		auto outer_node = nano::test::add_outer_node (system);
120  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
</pre></code></div>
                <div class="column column_space"><pre><code>207      EXPECT_THAT(buffer.capacity(), Le(MaxCapacityFor(kMaxFlatSize, capacity)));
208      for (size_t limit = kMaxFlatSize; limit <= kCustomLimit; limit *= 2) {
209        CordBuffer buffer = CordBuffer::CreateWithCustomLimit(limit, capacity);
210        ASSERT_THAT(buffer.capacity(), Ge(limit - kFlatOverhead));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    