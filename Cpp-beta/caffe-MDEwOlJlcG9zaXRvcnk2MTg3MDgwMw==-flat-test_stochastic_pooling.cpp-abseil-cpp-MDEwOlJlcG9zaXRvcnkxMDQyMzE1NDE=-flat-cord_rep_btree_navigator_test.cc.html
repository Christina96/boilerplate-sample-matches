
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.76595744680851%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_stochastic_pooling.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/pooling_layer.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  using std::min;
11  namespace caffe {
12  template <typename TypeParam>
13  class StochasticPoolingLayerTest : public MultiDeviceTest<TypeParam> {
14    typedef typename TypeParam::Dtype Dtype;
15   protected:
16    StochasticPoolingLayerTest()
17        : blob_bottom_(new Blob<Dtype>()),
18          blob_top_(new Blob<Dtype>()) {}
19    virtual void SetUp() {
20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
23      filler_param.set_min(0.1);
24      filler_param.set_max(1.);
25      UniformFiller<Dtype> filler(filler_param);
26      filler.Fill(this->blob_bottom_);
27      blob_bottom_vec_.push_back(blob_bottom_);
28      blob_top_vec_.push_back(blob_top_);
29    }
30    virtual ~StochasticPoolingLayerTest() {
31      delete blob_bottom_; delete blob_top_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    vector<Blob<Dtype>*> blob_bottom_vec_;
36    vector<Blob<Dtype>*> blob_top_vec_;
37  };
38  template <typename Dtype>
39  class CPUStochasticPoolingLayerTest
40    : public StochasticPoolingLayerTest<CPUDevice<Dtype> > {
41  };
42  TYPED_TEST_CASE(CPUStochasticPoolingLayerTest, TestDtypes);
43  TYPED_TEST(CPUStochasticPoolingLayerTest, TestSetup) {
44    LayerParameter layer_param;
45    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
46    pooling_param->set_kernel_size(3);
47    pooling_param->set_stride(2);
48    PoolingLayer<TypeParam> layer(layer_param);
49    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
50    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
51    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
52    EXPECT_EQ(this->blob_top_->height(), 3);
53    EXPECT_EQ(this->blob_top_->width(), 2);
54  }
55  #ifndef CPU_ONLY
56  template <typename Dtype>
57  class GPUStochasticPoolingLayerTest
58    : public StochasticPoolingLayerTest<GPUDevice<Dtype> > {
59  };
60  TYPED_TEST_CASE(GPUStochasticPoolingLayerTest, TestDtypes);
61  TYPED_TEST(GPUStochasticPoolingLayerTest, TestStochastic) {
62    LayerParameter layer_param;
63    layer_param.set_phase(TRAIN);
64    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
65    pooling_param->add_kernel_size(3);
66    pooling_param->add_stride(2);
67    pooling_param->set_pool(PoolingParameter_PoolMethod_STOCHASTIC);
68    PoolingLayer<TypeParam> layer(layer_param);
69    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
70    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
71    const TypeParam* bottom_data = this->blob_bottom_->cpu_data();
72    const TypeParam* top_data = this->blob_top_->cpu_data();
73    TypeParam total = 0;
74    for (int n = 0; n < this->blob_top_->num(); ++n) {
75      for (int c = 0; c < this->blob_top_->channels(); ++c) {
76        for (int ph = 0; ph < this->blob_top_->height(); ++ph) {
77          for (int pw = 0; pw < this->blob_top_->width(); ++pw) {
78            TypeParam pooled = top_data[this->blob_top_->offset(n, c, ph, pw)];
79            total += pooled;
80            int hstart = ph * 2;
81            int hend = min(hstart + 3, this->blob_bottom_->height());
82            int wstart = pw * 2;
83            int wend = min(wstart + 3, this->blob_bottom_->width());
<span onclick='openModal()' class='match'>84            bool has_equal = false;
85            for (int h = hstart; h < hend; ++h) {
86              for (int w = wstart; w < wend; ++w) {
</span>87                has_equal |= (pooled == bottom_data[this->blob_bottom_->
88                    offset(n, c, h, w)]);
89              }
90            }
91            EXPECT_TRUE(has_equal);
92          }
93        }
94      }
95    }
96    EXPECT_GE(total / this->blob_top_->count(), 0.55);
97  }
98  TYPED_TEST(GPUStochasticPoolingLayerTest, TestStochasticTestPhase) {
99    LayerParameter layer_param;
100    layer_param.set_phase(TEST);
101    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
102    pooling_param->add_kernel_size(3);
103    pooling_param->add_stride(2);
104    pooling_param->set_pool(PoolingParameter_PoolMethod_STOCHASTIC);
105    PoolingLayer<TypeParam> layer(layer_param);
106    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
107    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
108    const TypeParam* bottom_data = this->blob_bottom_->cpu_data();
109    const TypeParam* top_data = this->blob_top_->cpu_data();
110    for (int n = 0; n < this->blob_top_->num(); ++n) {
111      for (int c = 0; c < this->blob_top_->channels(); ++c) {
112        for (int ph = 0; ph < this->blob_top_->height(); ++ph) {
113          for (int pw = 0; pw < this->blob_top_->width(); ++pw) {
114            TypeParam pooled = top_data[this->blob_top_->offset(n, c, ph, pw)];
115            int hstart = ph * 2;
116            int hend = min(hstart + 3, this->blob_bottom_->height());
117            int wstart = pw * 2;
118            int wend = min(wstart + 3, this->blob_bottom_->width());
119            bool smaller_than_max = false;
120            for (int h = hstart; h < hend; ++h) {
121              for (int w = wstart; w < wend; ++w) {
122                smaller_than_max |= (pooled <= bottom_data[this->blob_bottom_->
123                    offset(n, c, h, w)]);
124              }
125            }
126            EXPECT_TRUE(smaller_than_max);
127          }
128        }
129      }
130    }
131  }
132  TYPED_TEST(GPUStochasticPoolingLayerTest, TestGradient) {
133    LayerParameter layer_param;
134    layer_param.set_phase(TRAIN);
135    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
136    pooling_param->add_kernel_size(3);
137    pooling_param->add_stride(2);
138    pooling_param->set_pool(PoolingParameter_PoolMethod_STOCHASTIC);
139    PoolingLayer<TypeParam> layer(layer_param);
140    GradientChecker<TypeParam> checker(1e-4, 1e-2);
141    checker.CheckGradient(&layer, this->blob_bottom_vec_,
142        this->blob_top_vec_);
143  }
144  #endif
145  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_navigator_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree_navigator.h"
2  #include <string>
3  #include <vector>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/base/config.h"
7  #include "absl/base/internal/raw_logging.h"
8  #include "absl/strings/internal/cord_internal.h"
9  #include "absl/strings/internal/cord_rep_btree.h"
10  #include "absl/strings/internal/cord_rep_test_util.h"
11  #include "absl/strings/str_cat.h"
12  #include "absl/strings/string_view.h"
13  namespace absl {
14  ABSL_NAMESPACE_BEGIN
15  namespace cord_internal {
16  namespace {
17  using ::testing::Eq;
18  using ::testing::Ne;
19  using ::absl::cordrep_testing::CordRepBtreeFromFlats;
20  using ::absl::cordrep_testing::CordToString;
21  using ::absl::cordrep_testing::CreateFlatsFromString;
22  using ::absl::cordrep_testing::CreateRandomString;
23  using ::absl::cordrep_testing::MakeFlat;
24  using ::absl::cordrep_testing::MakeSubstring;
25  using ReadResult = CordRepBtreeNavigator::ReadResult;
26  using Position = CordRepBtreeNavigator::Position;
27  class CordRepBtreeNavigatorTest : public testing::TestWithParam<size_t> {
28   public:
29    using Flats = std::vector<CordRep*>;
30    static constexpr size_t kCharsPerFlat = 3;
31    CordRepBtreeNavigatorTest() {
32      data_ = CreateRandomString(count() * kCharsPerFlat);
33      flats_ = CreateFlatsFromString(data_, kCharsPerFlat);
34      if (count() > 1) {
35        CordRep::Unref(flats_[1]);
36        flats_[1] = MakeSubstring(kCharsPerFlat, kCharsPerFlat, MakeFlat(data_));
37      } else {
38        CordRep::Unref(flats_[0]);
39        flats_[0] = MakeSubstring(0, kCharsPerFlat, MakeFlat(data_));
40      }
41      tree_ = CordRepBtreeFromFlats(flats_);
42    }
43    ~CordRepBtreeNavigatorTest() override { CordRep::Unref(tree_); }
44    size_t count() const { return GetParam(); }
45    CordRepBtree* tree() { return tree_; }
46    const std::string& data() const { return data_; }
47    const std::vector<CordRep*>& flats() const { return flats_; }
48    static std::string ToString(testing::TestParamInfo<size_t> param) {
49      return absl::StrCat(param.param, "_Flats");
50    }
51   private:
52    std::string data_;
53    Flats flats_;
54    CordRepBtree* tree_;
55  };
56  INSTANTIATE_TEST_SUITE_P(
57      WithParam, CordRepBtreeNavigatorTest,
58      testing::Values(1, CordRepBtree::kMaxCapacity - 1,
59                      CordRepBtree::kMaxCapacity,
60                      CordRepBtree::kMaxCapacity* CordRepBtree::kMaxCapacity - 1,
61                      CordRepBtree::kMaxCapacity* CordRepBtree::kMaxCapacity,
62                      CordRepBtree::kMaxCapacity* CordRepBtree::kMaxCapacity + 1,
63                      CordRepBtree::kMaxCapacity* CordRepBtree::kMaxCapacity * 2 +
64                          17),
65      CordRepBtreeNavigatorTest::ToString);
66  TEST(CordRepBtreeNavigatorTest, Uninitialized) {
67    CordRepBtreeNavigator nav;
68    EXPECT_FALSE(nav);
69    EXPECT_THAT(nav.btree(), Eq(nullptr));
70  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
71    EXPECT_DEATH(nav.Current(), ".*");
72  #endif
73  }
74  TEST_P(CordRepBtreeNavigatorTest, InitFirst) {
75    CordRepBtreeNavigator nav;
76    CordRep* edge = nav.InitFirst(tree());
77    EXPECT_TRUE(nav);
78    EXPECT_THAT(nav.btree(), Eq(tree()));
79    EXPECT_THAT(nav.Current(), Eq(flats().front()));
80    EXPECT_THAT(edge, Eq(flats().front()));
81  }
82  TEST_P(CordRepBtreeNavigatorTest, InitLast) {
83    CordRepBtreeNavigator nav;
84    CordRep* edge = nav.InitLast(tree());
85    EXPECT_TRUE(nav);
86    EXPECT_THAT(nav.btree(), Eq(tree()));
87    EXPECT_THAT(nav.Current(), Eq(flats().back()));
88    EXPECT_THAT(edge, Eq(flats().back()));
89  }
90  TEST_P(CordRepBtreeNavigatorTest, NextPrev) {
91    CordRepBtreeNavigator nav;
92    nav.InitFirst(tree());
93    const Flats& flats = this->flats();
94    EXPECT_THAT(nav.Previous(), Eq(nullptr));
95    EXPECT_THAT(nav.Current(), Eq(flats.front()));
96    for (size_t i = 1; i < flats.size(); ++i) {
97      ASSERT_THAT(nav.Next(), Eq(flats[i]));
98      EXPECT_THAT(nav.Current(), Eq(flats[i]));
99    }
100    EXPECT_THAT(nav.Next(), Eq(nullptr));
101    EXPECT_THAT(nav.Current(), Eq(flats.back()));
102    for (size_t i = flats.size() - 1; i > 0; --i) {
103      ASSERT_THAT(nav.Previous(), Eq(flats[i - 1]));
104      EXPECT_THAT(nav.Current(), Eq(flats[i - 1]));
105    }
106    EXPECT_THAT(nav.Previous(), Eq(nullptr));
107    EXPECT_THAT(nav.Current(), Eq(flats.front()));
108  }
109  TEST_P(CordRepBtreeNavigatorTest, PrevNext) {
110    CordRepBtreeNavigator nav;
111    nav.InitLast(tree());
112    const Flats& flats = this->flats();
113    EXPECT_THAT(nav.Next(), Eq(nullptr));
114    EXPECT_THAT(nav.Current(), Eq(flats.back()));
115    for (size_t i = flats.size() - 1; i > 0; --i) {
116      ASSERT_THAT(nav.Previous(), Eq(flats[i - 1]));
117      EXPECT_THAT(nav.Current(), Eq(flats[i - 1]));
118    }
119    EXPECT_THAT(nav.Previous(), Eq(nullptr));
120    EXPECT_THAT(nav.Current(), Eq(flats.front()));
121    for (size_t i = 1; i < flats.size(); ++i) {
122      ASSERT_THAT(nav.Next(), Eq(flats[i]));
123      EXPECT_THAT(nav.Current(), Eq(flats[i]));
124    }
125    EXPECT_THAT(nav.Next(), Eq(nullptr));
126    EXPECT_THAT(nav.Current(), Eq(flats.back()));
127  }
128  TEST(CordRepBtreeNavigatorTest, Reset) {
129    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
130    CordRepBtreeNavigator nav;
131    nav.InitFirst(tree);
132    nav.Reset();
133    EXPECT_FALSE(nav);
134    EXPECT_THAT(nav.btree(), Eq(nullptr));
135  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
136    EXPECT_DEATH(nav.Current(), ".*");
137  #endif
138    CordRep::Unref(tree);
139  }
140  TEST_P(CordRepBtreeNavigatorTest, Skip) {
141    size_t count = this->count();
142    const Flats& flats = this->flats();
143    CordRepBtreeNavigator nav;
144    nav.InitFirst(tree());
145    for (size_t char_offset = 0; char_offset < kCharsPerFlat; ++char_offset) {
146      Position pos = nav.Skip(char_offset);
147      EXPECT_THAT(pos.edge, Eq(nav.Current()));
148      EXPECT_THAT(pos.edge, Eq(flats[0]));
149      EXPECT_THAT(pos.offset, Eq(char_offset));
150    }
<span onclick='openModal()' class='match'>151    for (size_t index1 = 0; index1 < count; ++index1) {
152      for (size_t index2 = index1; index2 < count; ++index2) {
153        for (size_t char_offset = 0; char_offset < kCharsPerFlat; ++char_offset) {
</span>154          CordRepBtreeNavigator nav;
155          nav.InitFirst(tree());
156          size_t length1 = index1 * kCharsPerFlat;
157          Position pos1 = nav.Skip(length1 + char_offset);
158          ASSERT_THAT(pos1.edge, Eq(flats[index1]));
159          ASSERT_THAT(pos1.edge, Eq(nav.Current()));
160          ASSERT_THAT(pos1.offset, Eq(char_offset));
161          size_t length2 = index2 * kCharsPerFlat;
162          Position pos2 = nav.Skip(length2 - length1 + char_offset);
163          ASSERT_THAT(pos2.edge, Eq(flats[index2]));
164          ASSERT_THAT(pos2.edge, Eq(nav.Current()));
165          ASSERT_THAT(pos2.offset, Eq(char_offset));
166        }
167      }
168    }
169  }
170  TEST_P(CordRepBtreeNavigatorTest, Seek) {
171    size_t count = this->count();
172    const Flats& flats = this->flats();
173    CordRepBtreeNavigator nav;
174    nav.InitFirst(tree());
175    for (size_t char_offset = 0; char_offset < kCharsPerFlat; ++char_offset) {
176      Position pos = nav.Seek(char_offset);
177      EXPECT_THAT(pos.edge, Eq(nav.Current()));
178      EXPECT_THAT(pos.edge, Eq(flats[0]));
179      EXPECT_THAT(pos.offset, Eq(char_offset));
180    }
181    for (size_t index = 0; index < count; ++index) {
182      for (size_t char_offset = 0; char_offset < kCharsPerFlat; ++char_offset) {
183        size_t offset = index * kCharsPerFlat + char_offset;
184        Position pos1 = nav.Seek(offset);
185        ASSERT_THAT(pos1.edge, Eq(flats[index]));
186        ASSERT_THAT(pos1.edge, Eq(nav.Current()));
187        ASSERT_THAT(pos1.offset, Eq(char_offset));
188      }
189    }
190  }
191  TEST(CordRepBtreeNavigatorTest, InitOffset) {
192    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
193    tree = CordRepBtree::Append(tree, MakeFlat("def"));
194    CordRepBtreeNavigator nav;
195    Position pos = nav.InitOffset(tree, 5);
196    EXPECT_TRUE(nav);
197    EXPECT_THAT(nav.btree(), Eq(tree));
198    EXPECT_THAT(pos.edge, Eq(tree->Edges()[1]));
199    EXPECT_THAT(pos.edge, Eq(nav.Current()));
200    EXPECT_THAT(pos.offset, Eq(2u));
201    CordRep::Unref(tree);
202  }
203  TEST(CordRepBtreeNavigatorTest, InitOffsetAndSeekBeyondLength) {
204    CordRepBtree* tree1 = CordRepBtree::Create(MakeFlat("abc"));
205    CordRepBtree* tree2 = CordRepBtree::Create(MakeFlat("def"));
206    CordRepBtreeNavigator nav;
207    nav.InitFirst(tree1);
208    EXPECT_THAT(nav.Seek(3).edge, Eq(nullptr));
209    EXPECT_THAT(nav.Seek(100).edge, Eq(nullptr));
210    EXPECT_THAT(nav.btree(), Eq(tree1));
211    EXPECT_THAT(nav.Current(), Eq(tree1->Edges().front()));
212    EXPECT_THAT(nav.InitOffset(tree2, 3).edge, Eq(nullptr));
213    EXPECT_THAT(nav.InitOffset(tree2, 100).edge, Eq(nullptr));
214    EXPECT_THAT(nav.btree(), Eq(tree1));
215    EXPECT_THAT(nav.Current(), Eq(tree1->Edges().front()));
216    CordRep::Unref(tree1);
217    CordRep::Unref(tree2);
218  }
219  TEST_P(CordRepBtreeNavigatorTest, Read) {
220    const Flats& flats = this->flats();
221    const std::string& data = this->data();
222    for (size_t offset = 0; offset < data.size(); ++offset) {
223      for (size_t length = 1; length <= data.size() - offset; ++length) {
224        CordRepBtreeNavigator nav;
225        nav.InitFirst(tree());
226        size_t edge_offset = nav.Skip(offset).offset;
227        ReadResult result = nav.Read(edge_offset, length);
228        ASSERT_THAT(result.tree, Ne(nullptr));
229        EXPECT_THAT(result.tree->length, Eq(length));
230        if (result.tree->tag == BTREE) {
231          ASSERT_TRUE(CordRepBtree::IsValid(result.tree->btree()));
232        }
233        std::string value = CordToString(result.tree);
234        EXPECT_THAT(value, Eq(data.substr(offset, length)));
235        size_t partial = (offset + length) % kCharsPerFlat;
236        ASSERT_THAT(result.n, Eq(partial));
237        if (offset + length < data.size()) {
238          size_t index = (offset + length) / kCharsPerFlat;
239          EXPECT_THAT(nav.Current(), Eq(flats[index]));
240        }
241        CordRep::Unref(result.tree);
242      }
243    }
244  }
245  TEST_P(CordRepBtreeNavigatorTest, ReadBeyondLengthOfTree) {
246    CordRepBtreeNavigator nav;
247    nav.InitFirst(tree());
248    ReadResult result = nav.Read(2, tree()->length);
249    ASSERT_THAT(result.tree, Eq(nullptr));
250  }
251  TEST(CordRepBtreeNavigatorTest, NavigateMaximumTreeDepth) {
252    CordRepFlat* flat1 = MakeFlat("Hello world");
253    CordRepFlat* flat2 = MakeFlat("World Hello");
254    CordRepBtree* node = CordRepBtree::Create(flat1);
255    node = CordRepBtree::Append(node, flat2);
256    while (node->height() < CordRepBtree::kMaxHeight) {
257      node = CordRepBtree::New(node);
258    }
259    CordRepBtreeNavigator nav;
260    CordRep* edge = nav.InitFirst(node);
261    EXPECT_THAT(edge, Eq(flat1));
262    EXPECT_THAT(nav.Next(), Eq(flat2));
263    EXPECT_THAT(nav.Next(), Eq(nullptr));
264    EXPECT_THAT(nav.Previous(), Eq(flat1));
265    EXPECT_THAT(nav.Previous(), Eq(nullptr));
266    CordRep::Unref(node);
267  }
268  }  
269  }  
270  ABSL_NAMESPACE_END
271  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_stochastic_pooling.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_navigator_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>84            bool has_equal = false;
85            for (int h = hstart; h < hend; ++h) {
86              for (int w = wstart; w < wend; ++w) {
</pre></code></div>
                <div class="column column_space"><pre><code>151    for (size_t index1 = 0; index1 < count; ++index1) {
152      for (size_t index2 = index1; index2 < count; ++index2) {
153        for (size_t char_offset = 0; char_offset < kCharsPerFlat; ++char_offset) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    