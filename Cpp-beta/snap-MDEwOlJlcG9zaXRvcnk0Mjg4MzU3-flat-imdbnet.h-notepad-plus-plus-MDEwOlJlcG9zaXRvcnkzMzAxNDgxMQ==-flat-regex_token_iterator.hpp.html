
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.573221757322173%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-imdbnet.h</h3>
            <pre><code>1  #ifndef snap_imdb_net_h
2  #define snap_imbd_net_h
3  #include "Snap.h"
4  class TImdbNet;
5  typedef TPt<TImdbNet> PImdbNet;
6  typedef enum { mtyUndef, mtyActor, mtyMovie, mtyTv, mtyV, mtyVg, mtyA,
7    mtyScene, mtyMini, mtyArch, mtyVoice, mtySing, mtyAls, mtyEpisod } TMovieTy;
8  class TImdbNode {
9  private:
10    TInt Name, Year, Position; 
11    TCh Type; TBool IsMaleAct;
12    TInt Cntry, Lang;          
13  public:
14    TImdbNode() : Type(mtyUndef) { }
15    TImdbNode(const int& MovieName, const int& MovieYear, const TMovieTy& MovieTy);
16    TImdbNode(const int& ActorName, const int& ActorYear, const int& ActorPos, const bool& IsMaleActor);
17    TImdbNode(const PXmlTok& XmlTok) { Fail; }
18    PXmlTok GetXmlTok() const { Fail; return NULL; }
19    TImdbNode(TSIn& SIn);
20    void Save(TSOut& SOut) const;
21    int GetNm() const { return Name; }
22    int GetYear() const { return Year; }
23    int GetPos() const { return Position; }
24    TMovieTy GetTy() const { return TMovieTy(Type.Val); }
25    bool IsMale() const { return IsMaleAct; }
26    int GetCntry() const { return Cntry; }
27    int GetLang() const { return Lang; }
28    bool IsActor() const { return GetTy() == mtyActor; }
29    bool IsMovie() const { return GetTy() != mtyActor; }
30    friend class TImdbNet;
31  };
32  class TImdbNet : public TNodeNet<TImdbNode> {
33  public:
34    typedef TNodeNet<TImdbNode> TNet;
35    typedef TPt<TNodeNet<TImdbNode> > PNet;
36  private:
37    TStrHash<TInt> StrIdH;
38  public:
39    TImdbNet() : StrIdH() { }
40    TImdbNet(TSIn& SIn, const bool& LoadStrH=true) : TNet(SIn) {
41      if (LoadStrH) StrIdH.Load(SIn); printf("load.\n"); }
42    void Save(TSOut& SOut) const { TNet::Save(SOut);  StrIdH.Save(SOut); }
43    static PImdbNet New() { return new TImdbNet(); }
44    static PImdbNet Load(TSIn& SIn, const bool& LoadStrH=true) {
45      return new TImdbNet(SIn, LoadStrH); }
46    int GetStrs() const { return StrIdH.Len(); }
47    bool IsStr(const TStr& Str) const { return StrIdH.IsKey(Str); }
48    bool IsStr(const TStr& Str, int& StrId) const { StrId=StrIdH.GetKeyId(Str); return StrId!=-1; }
49    int GetStrId(const TStr& Str) const { return StrIdH.GetKeyId(Str); }
50    TStr GetStr(const int& StrId) const { IAssert(! StrIdH.GetPool().Empty()); return StrIdH.GetKey(StrId); }
51    int AddStr(const TStr& Str) { return StrIdH.AddKey(Str); }
<span onclick='openModal()' class='match'>52    PUNGraph GetActorGraph() const;
53    void SetLangCntryByMajority();
54    void SetActorCntryLangByMajority();
55    static PImdbNet LoadTxt(const TStr& ActorFNm);
56    static PImdbNet LoadFromImdb(const TStr& DataDir);
57    static TMovieTy GetMovieTy(const TStr& MovieTyStr);
58    static TStr GetMovieTyStr(const TMovieTy& MovieTy);
</span>59    friend class TPt<TImdbNet>;
60  };
61  namespace TSnap {
62  template <> struct IsDirected<TImdbNet> { enum { Val = 1 }; };
63  template <> struct IsNodeDat<TImdbNet> { enum { Val = 1 }; };
64  }
65  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-regex_token_iterator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_REGEX_TOKEN_ITERATOR_HPP
2  #define BOOST_REGEX_V5_REGEX_TOKEN_ITERATOR_HPP
3  #include <memory>
4  namespace boost{
5  template <class BidirectionalIterator,
6            class charT,
7            class traits>
8  class regex_token_iterator_implementation 
9  {
10     typedef basic_regex<charT, traits> regex_type;
11     typedef sub_match<BidirectionalIterator>      value_type;
12     match_results<BidirectionalIterator> what;   
13     BidirectionalIterator                base;    
14     BidirectionalIterator                end;    
15     const regex_type                     re;    
16     match_flag_type                      flags;  
17     value_type                           result; 
18     int                                  N;      
19     std::vector<int>                     subs;   
20  public:
21     regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
22        : end(last), re(*p), flags(f), N(0){ subs.push_back(sub); }
23     regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
24        : end(last), re(*p), flags(f), N(0), subs(v){}
25     template <std::size_t CN>
26     regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
27        : end(last), re(*p), flags(f), N(0)
28     {
29        for(std::size_t i = 0; i < CN; ++i)
30        {
31           subs.push_back(submatches[i]);
32        }
33     }
34     regex_token_iterator_implementation(const regex_token_iterator_implementation& other) = default;
35     bool init(BidirectionalIterator first)
36     {
37        N = 0;
38        base = first;
39        if(regex_search(first, end, what, re, flags, base) == true)
40        {
41           N = 0;
42           result = ((subs[N] == -1) ? what.prefix() : what[(int)subs[N]]);
43           return true;
44        }
45        else if((subs[N] == -1) && (first != end))
46        {
47           result.first = first;
48           result.second = end;
49           result.matched = (first != end);
50           N = -1;
51           return true;
52        }
53        return false;
54     }
55     bool compare(const regex_token_iterator_implementation& that)
56     {
57        if(this == &that) return true;
58        return (&re.get_data() == &that.re.get_data()) 
59           && (end == that.end) 
60           && (flags == that.flags) 
61           && (N == that.N) 
62           && (what[0].first == that.what[0].first) 
63           && (what[0].second == that.what[0].second);
64     }
65     const value_type& get()
66     { return result; }
67     bool next()
68     {
69        if(N == -1)
70           return false;
71        if(N+1 < (int)subs.size())
72        {
73           ++N;
74           result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
75           return true;
76        }
77        BidirectionalIterator last_end(what[0].second);
78        if(regex_search(last_end, end, what, re, ((what[0].first == what[0].second) ? flags | regex_constants::match_not_initial_null : flags), base))
79        {
80           N =0;
81           result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
82           return true;
83        }
84        else if((last_end != end) && (subs[0] == -1))
85        {
86           N =-1;
87           result.first = last_end;
88           result.second = end;
89           result.matched = (last_end != end);
90           return true;
91        }
92        return false;
93     }
94  private:
95     regex_token_iterator_implementation& operator=(const regex_token_iterator_implementation&);
96  };
97  template <class BidirectionalIterator, 
98            class charT = typename std::iterator_traits<BidirectionalIterator>::value_type,
99            class traits = regex_traits<charT> >
100  class regex_token_iterator 
101  {
102  private:
<span onclick='openModal()' class='match'>103     typedef regex_token_iterator_implementation<BidirectionalIterator, charT, traits> impl;
104     typedef std::shared_ptr<impl> pimpl;
105  public:
106     typedef          basic_regex<charT, traits>                   regex_type;
107     typedef          sub_match<BidirectionalIterator>                        value_type;
108     typedef typename std::iterator_traits<BidirectionalIterator>::difference_type 
109                                                                              difference_type;
110     typedef          const value_type*                                       pointer;
111     typedef          const value_type&                                       reference; 
112     typedef          std::forward_iterator_tag                               iterator_category;
</span>113     regex_token_iterator(){}
114     regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, 
115                          int submatch = 0, match_flag_type m = match_default)
116                          : pdata(new impl(&re, b, submatch, m))
117     {
118        if(!pdata->init(a))
119           pdata.reset();
120     }
121     regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, 
122                          const std::vector<int>& submatches, match_flag_type m = match_default)
123                          : pdata(new impl(&re, b, submatches, m))
124     {
125        if(!pdata->init(a))
126           pdata.reset();
127     }
128     template <std::size_t N>
129     regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,
130                          const int (&submatches)[N], match_flag_type m = match_default)
131                          : pdata(new impl(&re, b, submatches, m))
132     {
133        if(!pdata->init(a))
134           pdata.reset();
135     }
136     regex_token_iterator(const regex_token_iterator& that)
137        : pdata(that.pdata) {}
138     regex_token_iterator& operator=(const regex_token_iterator& that)
139     {
140        pdata = that.pdata;
141        return *this;
142     }
143     bool operator==(const regex_token_iterator& that)const
144     { 
145        if((pdata.get() == 0) || (that.pdata.get() == 0))
146           return pdata.get() == that.pdata.get();
147        return pdata->compare(*(that.pdata.get())); 
148     }
149     bool operator!=(const regex_token_iterator& that)const
150     { return !(*this == that); }
151     const value_type& operator*()const
152     { return pdata->get(); }
153     const value_type* operator->()const
154     { return &(pdata->get()); }
155     regex_token_iterator& operator++()
156     {
157        cow();
158        if(0 == pdata->next())
159        {
160           pdata.reset();
161        }
162        return *this;
163     }
164     regex_token_iterator operator++(int)
165     {
166        regex_token_iterator result(*this);
167        ++(*this);
168        return result;
169     }
170  private:
171     pimpl pdata;
172     void cow()
173     {
174        if(pdata.get() && (pdata.use_count() > 1))
175        {
176           pdata.reset(new impl(*(pdata.get())));
177        }
178     }
179  };
180  typedef regex_token_iterator<const char*> cregex_token_iterator;
181  typedef regex_token_iterator<std::string::const_iterator> sregex_token_iterator;
182  #ifndef BOOST_NO_WREGEX
183  typedef regex_token_iterator<const wchar_t*> wcregex_token_iterator;
184  typedef regex_token_iterator<std::wstring::const_iterator> wsregex_token_iterator;
185  #endif
186  template <class charT, class traits>
187  inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
188  {
189     return regex_token_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, submatch, m);
190  }
191  template <class charT, class traits, class ST, class SA>
192  inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
193  {
194     return regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, submatch, m);
195  }
196  template <class charT, class traits, std::size_t N>
197  inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
198  {
199     return regex_token_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, submatch, m);
200  }
201  template <class charT, class traits, class ST, class SA, std::size_t N>
202  inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
203  {
204     return regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, submatch, m);
205  }
206  template <class charT, class traits>
207  inline regex_token_iterator<const charT*, charT, traits> make_regex_token_iterator(const charT* p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
208  {
209     return regex_token_iterator<const charT*, charT, traits>(p, p+traits::length(p), e, submatch, m);
210  }
211  template <class charT, class traits, class ST, class SA>
212  inline regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits> make_regex_token_iterator(const std::basic_string<charT, ST, SA>& p, const basic_regex<charT, traits>& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
213  {
214     return regex_token_iterator<typename std::basic_string<charT, ST, SA>::const_iterator, charT, traits>(p.begin(), p.end(), e, submatch, m);
215  }
216  } 
217  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-imdbnet.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-regex_token_iterator.hpp</div>
                </div>
                <div class="column column_space"><pre><code>52    PUNGraph GetActorGraph() const;
53    void SetLangCntryByMajority();
54    void SetActorCntryLangByMajority();
55    static PImdbNet LoadTxt(const TStr& ActorFNm);
56    static PImdbNet LoadFromImdb(const TStr& DataDir);
57    static TMovieTy GetMovieTy(const TStr& MovieTyStr);
58    static TStr GetMovieTyStr(const TMovieTy& MovieTy);
</pre></code></div>
                <div class="column column_space"><pre><code>103     typedef regex_token_iterator_implementation<BidirectionalIterator, charT, traits> impl;
104     typedef std::shared_ptr<impl> pimpl;
105  public:
106     typedef          basic_regex<charT, traits>                   regex_type;
107     typedef          sub_match<BidirectionalIterator>                        value_type;
108     typedef typename std::iterator_traits<BidirectionalIterator>::difference_type 
109                                                                              difference_type;
110     typedef          const value_type*                                       pointer;
111     typedef          const value_type&                                       reference; 
112     typedef          std::forward_iterator_tag                               iterator_category;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    