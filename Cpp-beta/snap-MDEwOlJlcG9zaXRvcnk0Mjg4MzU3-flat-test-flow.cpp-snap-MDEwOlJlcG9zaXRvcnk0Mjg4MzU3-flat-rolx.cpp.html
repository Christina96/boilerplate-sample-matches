
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.08130081300813%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-flow.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  int BuildCapacityNetwork(const TStr& InFNm, PNEANet &Net, const int& SrcColId = 0, const int& DstColId = 1, const int& CapColId = 2) {
4    TSsParser Ss(InFNm, ssfWhiteSep, true, true, true);
5    TRnd Random;
6    Net.Clr();
7    Net = TNEANet::New();
8    int SrcNId, DstNId, CapVal, EId;
9    int MaxCap = 0;
10    while (Ss.Next()) {
11      if (! Ss.GetInt(SrcColId, SrcNId) || ! Ss.GetInt(DstColId, DstNId) || ! Ss.GetInt(CapColId, CapVal)) { continue; }
12      MaxCap = MAX(CapVal, MaxCap);
13      if (! Net->IsNode(SrcNId)) {
14        Net->AddNode(SrcNId);
15      }
16      if (! Net->IsNode(DstNId)) {
17        Net->AddNode(DstNId);
18      }
19      EId = Net->AddEdge(SrcNId, DstNId);
20      Net->AddIntAttrDatE(EId, CapVal, TSnap::CapAttrName);
21    }
22    return MaxCap;
23  }
24  TEST(FlowTest, BasicTest) {
25    PNEANet Net;
26    BuildCapacityNetwork("flow/small_sample.txt", Net);
27    int PRFlow1 = TSnap::GetMaxFlowIntPR(Net, 53, 2);
28    int EKFlow1 = TSnap::GetMaxFlowIntEK(Net, 53, 2);
29    int PRFlow2 = TSnap::GetMaxFlowIntPR(Net, 86, 77);
30    int EKFlow2 = TSnap::GetMaxFlowIntEK(Net, 86, 77);
31    int PRFlow3 = TSnap::GetMaxFlowIntPR(Net, 62, 81);
32    int EKFlow3 = TSnap::GetMaxFlowIntEK(Net, 62, 81);
33    int PRFlow4 = TSnap::GetMaxFlowIntPR(Net, 92, 92);
<span onclick='openModal()' class='match'>34    int EKFlow4 = TSnap::GetMaxFlowIntEK(Net, 92, 92);
35    EXPECT_EQ (PRFlow1, EKFlow1);
36    EXPECT_EQ (PRFlow2, EKFlow2);
37    EXPECT_EQ (PRFlow3, EKFlow3);
38    EXPECT_EQ (PRFlow4, EKFlow4);
</span>39    EXPECT_EQ (PRFlow1, 1735);
40    EXPECT_EQ (PRFlow2, 3959);
41    EXPECT_EQ (PRFlow3, 2074);
42    EXPECT_EQ (PRFlow4, 0);
43  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "Snap.h"
3  #include "rolx.h"
4  void PrintFeatures(const TIntFtrH& Features) {
5    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
6      printf("%d: [", HI.GetKey()());
7      const TFtr& Feature = HI.GetDat();
8      for (int i = 0; i < Feature.Len(); ++i) {
9        if (i > 0) {
10          printf(",");
11        }
12        printf("%f", Feature[i]());
13      }
14      printf("]\n");
15    }
16  }
17  TIntFtrH CreateEmptyFeatures(const PUNGraph Graph) {
18    TIntFtrH EmptyFeatures;
19    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
20      EmptyFeatures.AddDat(TInt(NI.GetId()), TFtr());
21    }
22    return EmptyFeatures;
23  }
24  TIntFtrH CreateEmptyFeatures(const TIntFtrH& Features) {
25    TIntFtrH EmptyFeatures;
26    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
27      EmptyFeatures.AddDat(HI.GetKey(), TFtr());
28    }
29    return EmptyFeatures;
30  }
31  int GetNumFeatures(const TIntFtrH& Features) {
32    return Features.BegI().GetDat().Len();
33  }
34  TFtr GetNthFeature(const TIntFtrH& Features, const int N) {
35    TFtr NthFeature;
36    IAssert(0 <= N && N < GetNumFeatures(Features));
37    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
38      NthFeature.Add(HI.GetDat()[N]);
39    }
40    return NthFeature;
41  }
42  TIntFtrH ExtractFeatures(const PUNGraph Graph) {
43    TIntFtrH Features = CreateEmptyFeatures(Graph);
44    AddNeighborhoodFeatures(Graph, Features);
45    printf("finish neighborhood features\n");
46    AddRecursiveFeatures(Graph, Features);
47    printf("finish recursive features\n");
48    return Features;
49  }
50  void AddNeighborhoodFeatures(const PUNGraph Graph, TIntFtrH& Features) {
51    AddLocalFeatures(Graph, Features);
52    printf("finish local features\n");
53    AddEgonetFeatures(Graph, Features);
54    printf("finish egonet features\n");
55  }
56  void AddRecursiveFeatures(const PUNGraph Graph, TIntFtrH& Features) {
57    int SimilarityThreshold = 0;
58    TIntFtrH RetainedFeatures = Features;
59    while (true) {
60      TIntFtrH NewFeatures = GenerateRecursiveFeatures(Graph, RetainedFeatures);
61      RetainedFeatures = PruneRecursiveFeatures(Graph, Features, NewFeatures,
62          SimilarityThreshold);
63      if (0 == GetNumFeatures(RetainedFeatures)) {
64        break;
65      }
66      AppendFeatures(Features, RetainedFeatures);
67      ++SimilarityThreshold;
68      printf("recursion %d: ", SimilarityThreshold);
69      printf("current feature number %d\n", GetNumFeatures(Features));
70    }
71  }
72  void AddLocalFeatures(const PUNGraph Graph, TIntFtrH& Features) {
73    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
74      Features.GetDat(TInt(NI.GetId())).Add(NI.GetInDeg());
75    }
76  }
77  void AddEgonetFeatures(const PUNGraph Graph, TIntFtrH& Features) {
78    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
79      int NId = NI.GetId();
80      int ArndEdges;
81      PUNGraph Egonet = TSnap::GetEgonet(Graph, NId, ArndEdges);
82      Features.GetDat(NId).Add(Egonet->GetEdges());
83      Features.GetDat(NId).Add(ArndEdges);
84    }
85  }
86  TIntFtrH GenerateRecursiveFeatures(const PUNGraph Graph,
87      const TIntFtrH& CurrFeatures) {
88    const int NumCurrFeatures = GetNumFeatures(CurrFeatures);
89    if (0 == NumCurrFeatures) {
90      return CurrFeatures;
91    }
92    TIntFtrH NewFeatures = CreateEmptyFeatures(CurrFeatures);
93    for (int i = 0; i < NumCurrFeatures; ++i) {
94      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
95        float Sum = 0;
96        for (int j = 0; j < NI.GetInDeg(); ++j) {
97          int NbrNId = NI.GetInNId(j);
98          Sum += CurrFeatures.GetDat(NbrNId)[i]();
99        }
100        NewFeatures.GetDat(NI.GetId()).Add(Sum);
101        NewFeatures.GetDat(NI.GetId()).Add(0 == NI.GetInDeg()?
102            0 : (float(Sum) / NI.GetInDeg()));
103      }
104    }
105    return NewFeatures;
106  }
107  TIntFtrH PruneRecursiveFeatures(const PUNGraph Graph, const TIntFtrH& Features,
108      const TIntFtrH& NewFeatures, const int SimilarityThreshold) {
109    TIntFtrH AllFeatures = CreateEmptyFeatures(Features);
110    AppendFeatures(AllFeatures, Features);
111    AppendFeatures(AllFeatures, NewFeatures);
112    const float BinFraction = 0.5;
113    TIntFtrH LogBinFeatures = CalcVerticalLogBinning(AllFeatures, BinFraction);
114    PUNGraph FeatureGraph = BuildFeatureGraph(LogBinFeatures,
115        SimilarityThreshold);
116    return SummarizeConnectedComponents(FeatureGraph, Features, NewFeatures);
117  }
118  void AppendFeatures(TIntFtrH& DstFeatures, const TIntFtrH& SrcFeatures,
119      const int ColIdx) {
120    for (TIntFtrH::TIter HI = SrcFeatures.BegI();
121        HI < SrcFeatures.EndI();
122        HI++) {
123      const TFtr& Feature = HI.GetDat();
124      if (ColIdx >= 0) {
125        DstFeatures.GetDat(HI.GetKey()).Add(Feature[ColIdx]);
126      } else {
127        for (int i = 0; i < Feature.Len(); ++i) {
128          DstFeatures.GetDat(HI.GetKey()).Add(Feature[i]);
129        }
130      }
131    }
132  }
133  TIntFtrH CalcVerticalLogBinning(const TIntFtrH& Features,
134      const float BinFraction) {
135    const int NumFeatures = GetNumFeatures(Features);
136    TIntFtrH LogBinFeatures = CreateEmptyFeatures(Features);
137    for (int i = 0; i < NumFeatures; ++i) {
138      TVec<TInt> SortedNId = GetNIdSorted(Features, i);
139      AssignBinValue(SortedNId, BinFraction, LogBinFeatures);
140    }
141    return LogBinFeatures;
142  }
143  PUNGraph BuildFeatureGraph(const TIntFtrH& LogBinFeatures,
144      const int SimilarityThreshold) {
145    PUNGraph FeatureGraph = PUNGraph::New();
146    const int NumFeatures = GetNumFeatures(LogBinFeatures);
147    for (int i = 0; i < NumFeatures; ++i) {
148      FeatureGraph->AddNode(i);
149    }
150    for (int i = 0; i < NumFeatures; ++i) {
151      TFtr IthFeature = GetNthFeature(LogBinFeatures, i);
152      for (int j = i + 1; j < NumFeatures; ++j) {
153        TFtr JthFeature = GetNthFeature(LogBinFeatures, j);
154        if (IsSimilarFeature(IthFeature, JthFeature, SimilarityThreshold) &&
155            !FeatureGraph->IsEdge(i, j)) {
156          FeatureGraph->AddEdge(i, j);
157        }
158      }
159    }
160    return FeatureGraph;
161  }
162  TIntFtrH SummarizeConnectedComponents(const PUNGraph FeatureGraph,
163      const TIntFtrH& Features, const TIntFtrH& NewFeatures) {
164    TCnComV Wcc;
165    TSnap::GetWccs(FeatureGraph, Wcc);
166    TVec<TInt> RetainedIdx;
167    for (int i = 0; i < Wcc.Len(); ++i) {
168      RetainedIdx.Add(Wcc[i][0]);
169    }
170    RetainedIdx.Sort();
171    TIntFtrH RetainedFeatures = CreateEmptyFeatures(Features);
172    const int StartIdxNewFeatures = GetNumFeatures(Features);
173    for (int i = 0; i < RetainedIdx.Len(); ++i) {
174      const int IdxNewFeatures = RetainedIdx[i] - StartIdxNewFeatures;
175      if (IdxNewFeatures >= 0) {
176        AppendFeatures(RetainedFeatures, NewFeatures, IdxNewFeatures);
177      }
178    }
179    return RetainedFeatures;
180  }
181  TVec<TInt> GetNIdSorted(const TIntFtrH& Features, const int Idx) {
182    THash<TInt, TFlt> F;
183    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
184      F.AddDat(HI.GetKey(), HI.GetDat()[Idx]);
185    }
186    F.SortByDat();
187    TVec<TInt> SortedNId;
188    for (THash<TInt, TFlt>::TIter HI = F.BegI(); HI < F.EndI(); HI++) {
189      SortedNId.Add(HI.GetKey());
190    }
191    return SortedNId;
192  }
193  void AssignBinValue(const TVec<TInt>& SortedNId, const float BinFraction,
194      TIntFtrH& LogBinFeatures) {
195    int NumNodes = LogBinFeatures.Len();
196    int NumAssigned = 0;
197    int BinValue = 0;
198    while (NumAssigned < NumNodes) {
199      int NumToAssign = ceil(BinFraction * (NumNodes - NumAssigned));
200      for (int i = NumAssigned; i < NumAssigned + NumToAssign; ++i) {
201        int NId = SortedNId[i];
202        LogBinFeatures.GetDat(NId).Add(BinValue);
203      }
204      NumAssigned += NumToAssign;
205      ++BinValue;
206    }
207  }
208  bool IsSimilarFeature(const TFtr& F1, const TFtr& F2,
209      const int SimilarityThreshold) {
210    IAssert(F1.Len() == F2.Len());
211    for (int i = 0; i < F1.Len(); ++i) {
212      if (TFlt::Abs(F1[i] - F2[i]) > SimilarityThreshold) {
213        return false;
214      }
215    }
216    return true;
217  }
218  TFltVV ConvertFeatureToMatrix(const TIntFtrH& Features,
219      const TIntIntH& NodeIdMtxIdxH) {
220    const int NumNodes = Features.Len();
221    const int NumFeatures = GetNumFeatures(Features);
222    TFltVV FeaturesMtx(NumNodes, NumFeatures);
223    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
224      int i = GetMtxIdx(HI.GetKey(), NodeIdMtxIdxH);
225      for (int j = 0; j < NumFeatures; ++j) {
226        FeaturesMtx(i, j) = HI.GetDat()[j];
227      }
228    }
229    return FeaturesMtx;
230  }
231  void PrintMatrix(const TFltVV& Matrix) {
232    int XDim = Matrix.GetXDim();
233    int YDim = Matrix.GetYDim();
234    printf("[");
235    for (int i = 0; i < XDim; ++i) {
236      printf("[");
237      for (int j = 0; j < YDim; ++j) {
238        if (j != 0) {
239          printf(" ");
240        }
241        printf("%f", Matrix(i, j)());
242      }
243      printf("]\n");
244    }
245    printf("]\n");
246  }
247  TFltVV CreateRandMatrix(const int XDim, const int YDim) {
248    int Seed = 13;
249    TFltVV Matrix(XDim, YDim);
250    for (int i = 0; i < XDim; ++i) {
251      for (int j = 0; j < YDim; ++j) {
252        Matrix(i, j) = (double)Seed / 10007;
253        Seed = (Seed * 1871) % 10007;
254      }
255    }
256    return Matrix;
257  }
258  bool FltIsZero(const TFlt Number) {
259    return TFlt::Abs(Number) < TFlt::Eps;
260  }
261  void CalcNonNegativeFactorization(const TFltVV& V, const int NumRoles,
262      TFltVV& W, TFltVV& H, const double Threshold) {
263    double Cost = 100, NewCost = 0;
264    int NumNodes = V.GetXDim();
265    int NumFeatures = V.GetYDim();
266    W = CreateRandMatrix(NumNodes, NumRoles);
<span onclick='openModal()' class='match'>267    H = CreateRandMatrix(NumRoles, NumFeatures);
268    TFltVV NewW(NumNodes, NumRoles);
269    TFltVV NewH(NumRoles, NumFeatures);
270    TFltVV Product(NumNodes, NumFeatures);
271    TFltV Sum(NumRoles);
272    TFltVV *PW = &W, *PH = &H, *PNewW = &NewW, *PNewH = &NewH, *Tmp;
</span>273    while (TFlt::Abs((NewCost - Cost)/Cost) > Threshold) {
274      TLinAlg::Multiply(*PW, *PH, Product);
275      Cost = NewCost;
276      NewCost = 0;
277      for (int i = 0; i < NumNodes; i++) {
278        for (int j = 0; j < NumFeatures; j++) {
279          NewCost += V(i, j) * TMath::Log(Product(i, j)) - Product(i, j);
280        }
281      }
282      for (int i = 0; i < NumNodes; i++) {
283        for (int a = 0; a < NumRoles; a++) {
284          double SumU = 0;
285          for (int u = 0; u < NumFeatures; ++u) {
286            if (!FltIsZero(Product(i, u))) {
287              SumU += V(i, u) / Product(i, u) * PH->At(a, u);
288            }
289          }
290          PNewW->At(i, a) = PW->At(i, a) * SumU;
291        }
292      }
293      for (int i = 0; i < NumRoles; i++) {
294        Sum[i] = 0;
295      }
296      for (int i = 0; i < NumNodes; i++) {
297        for (int j = 0; j < NumRoles; j++) {
298          Sum[j] += PNewW->At(i, j);
299        }
300      }
301      for (int i = 0; i < NumNodes; i++) {
302        for (int j = 0; j < NumRoles; j++) {
303          PNewW->At(i, j) /= Sum[j];
304        }
305      }
306      for (int a = 0; a < NumRoles; a++) {
307        for (int u = 0; u < NumFeatures; u++) {
308          double SumI = 0;
309          for (int i = 0; i < NumNodes; ++i) {
310            if (!FltIsZero(Product(i, u))) {
311              SumI += PW->At(i, a) * V(i, u) / Product(i, u);
312            }
313          }
314          PNewH->At(a, u) = PH->At(a, u) * SumI;
315        }
316      }
317      Tmp = PW; PW = PNewW; PNewW = Tmp;
318      Tmp = PH; PH = PNewH; PNewH = Tmp;
319    }
320  }
321  TFlt CalcDescriptionLength(const TFltVV& V, const TFltVV& G,
322      const TFltVV& F) {
323    int B = 64;
324    int M = B * V.GetYDim() * (V.GetXDim() + F.GetYDim());
325    TFlt E = 0;
326    TFltVV GF(G.GetXDim(), F.GetYDim());
327    TLinAlg::Multiply(G, F, GF);
328    for (int i = 0; i < V.GetXDim(); ++i) {
329      for (int j = 0; j < V.GetYDim(); ++j) {
330        TFlt ValueV = V(i, j);
331        TFlt ValueGF = GF(i, j);
332        if (FltIsZero(ValueV)) {
333          E += ValueGF;
334        } else if (!FltIsZero(ValueGF)) {
335          E += ValueV * TMath::Log(ValueV / ValueGF) - ValueV + ValueGF;
336        }
337      }
338    }
339    return M + E;
340  }
341  TIntIntH CreateNodeIdMtxIdxHash(const TIntFtrH& Features) {
342    TIntIntH H;
343    TInt Idx = 0;
344    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
345      H.AddDat(HI.GetKey(), Idx);
346      Idx++;
347    }
348    return H;
349  }
350  int GetMtxIdx(const TInt NodeId, const TIntIntH& NodeIdMtxIdxH) {
351    return NodeIdMtxIdxH.GetDat(NodeId)();
352  }
353  int GetNodeId(const TInt MtxId, const TIntIntH& NodeIdMtxIdxH) {
354    for (TIntIntH::TIter HI = NodeIdMtxIdxH.BegI();
355        HI < NodeIdMtxIdxH.EndI();
356        HI++) {
357      if (HI.GetDat() == MtxId) {
358        return HI.GetKey()();
359      }
360    }
361    return -1;
362  }
363  TIntIntH FindRoles(const TFltVV& G, const TIntIntH& NodeIdMtxIdxH) {
364    TIntIntH Roles;
365    for (int i = 0; i < G.GetXDim(); i++) {
366      int Role = -1;
367      TFlt Max = TFlt::Mn;
368      for (int j = 0; j < G.GetYDim(); j ++) {
369        if (G(i, j) > Max) {
370          Max = G(i, j);
371          Role = j;
372        }
373      }
374      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
375      Roles.AddDat(NodeId, Role);
376    }
377    return Roles;
378  }
379  void PlotRoles(const PUNGraph Graph, const TIntIntH& Roles) {
380    TStr RoleToColor[10] = { "white", "black", "red", "green", "blue",
381        "yellow", "gold", "cyan", "magenta", "brown" };
382    TIntStrH Color;
383    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
384      Color.AddDat(HI.GetKey(), RoleToColor[HI.GetDat()].CStr());
385    }
386    TSnap::DrawGViz(Graph, gvlDot, "gviz_plot.png", "Dot", 1, Color);
387  }
388  void PrintRoles(const TIntIntH& Roles) {
389    printf("--roles (node ID: role ID)--\n");
390    printf("{\n");
391    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
392      printf("(%d: %d)\n", HI.GetKey()(), HI.GetDat()());
393    }
394    printf("}\n");
395  }
396  void FPrintMatrix(const TFltVV& Matrix, const TStr& Path) {
397    FILE *Fp;
398    Fp = fopen(Path.CStr(), "w");
399    int XDim = Matrix.GetXDim();
400    int YDim = Matrix.GetYDim();
401    for (int i = 0; i < XDim; ++i) {
402      for (int j = 0; j < YDim; ++j) {
403        if (j != 0) {
404          fprintf(Fp, " ");
405        }
406        fprintf(Fp, "%f", Matrix(i, j)());
407      }
408      fprintf(Fp, "\n");
409    }
410    fclose(Fp);
411  }
412  void FPrintNodeMappings(const TIntIntH& NodeIdMtxIdxH, const TStr& Path) {
413    FILE *Fp;
414    Fp = fopen(Path.CStr(), "w");
415    fprintf(Fp, "# mappings from the feature line numbers to node IDs\n");
416    for (int i = 0; i < NodeIdMtxIdxH.Len(); i++) {
417      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
418      fprintf(Fp, "%d %d\n", i, NodeId);
419    }
420    fclose(Fp);
421  }
422  void FPrintRoles(const TIntIntH& Roles, const TStr& Path) {
423    FILE *Fp;
424    Fp = fopen(Path.CStr(), "w");
425    fprintf(Fp, "--roles (node ID role ID)--\n\n");
426    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
427      fprintf(Fp, "%d\t%d\n", HI.GetKey()(), HI.GetDat()());
428    }
429    fclose(Fp);
430  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-flow.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>34    int EKFlow4 = TSnap::GetMaxFlowIntEK(Net, 92, 92);
35    EXPECT_EQ (PRFlow1, EKFlow1);
36    EXPECT_EQ (PRFlow2, EKFlow2);
37    EXPECT_EQ (PRFlow3, EKFlow3);
38    EXPECT_EQ (PRFlow4, EKFlow4);
</pre></code></div>
                <div class="column column_space"><pre><code>267    H = CreateRandMatrix(NumRoles, NumFeatures);
268    TFltVV NewW(NumNodes, NumRoles);
269    TFltVV NewH(NumRoles, NumFeatures);
270    TFltVV Product(NumNodes, NumFeatures);
271    TFltV Sum(NumRoles);
272    TFltVV *PW = &W, *PH = &H, *PNewW = &NewW, *PNewH = &NewH, *Tmp;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    