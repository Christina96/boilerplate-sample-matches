
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.092198581560284%, Tokens: 50, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-frontier_store_74.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/secure/store.hpp>
3  #include <lmdb/libraries/liblmdb/lmdb.h>
4  namespace nano
5  {
6  namespace lmdb
7  {
8  	class store;
9  	class frontier_store : public nano::frontier_store
10  	{
11  	private:
<span onclick='openModal()' class='match'>12  		nano::lmdb::store & store;
13  	public:
14  		frontier_store (nano::lmdb::store & store);
15  		void put (nano::write_transaction const &, nano::block_hash const &, nano::account const &) override;
16  		nano::account get (nano::transaction const &, nano::block_hash const &) const override;
17  		void del (nano::write_transaction const &, nano::block_hash const &) override;
18  		nano::store_iterator<nano::block_hash, nano::account> begin (nano::transaction const &) const override;
19  		nano::store_iterator<nano::block_hash, nano::account> begin (nano::transaction const &, nano::block_hash const &) const override;
20  		nano::store_iterator<nano::block_hash, nano::account> end () const override;
21  		void for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::block_hash, nano::account>, nano::store_iterator<nano::block_hash, nano::account>)> const & action_a) const override;
22  		MDB_dbi frontiers_handle{ 0 };
</span>23  	};
24  }
25  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.h</h3>
            <pre><code>1  #ifndef EDITOR_H
2  #define EDITOR_H
3  namespace Scintilla::Internal {
4  class Timer {
5  public:
6  	bool ticking;
7  	int ticksToWait;
8  	enum {tickSize = 100};
9  	TickerID tickerID;
10  	Timer() noexcept;
11  };
12  class Idler {
13  public:
14  	bool state;
15  	IdlerID idlerID;
16  	Idler() noexcept;
17  };
18  enum class WorkItems {
19  	none = 0,
20  	style = 1,
21  	updateUI = 2
22  };
23  class WorkNeeded {
24  public:
25  	enum WorkItems items;
26  	Sci::Position upTo;
27  	WorkNeeded() noexcept : items(WorkItems::none), upTo(0) {}
28  	void Reset() noexcept {
29  		items = WorkItems::none;
30  		upTo = 0;
31  	}
32  	void Need(WorkItems items_, Sci::Position pos) noexcept {
33  		if (Scintilla::FlagSet(items_, WorkItems::style) && (upTo < pos))
34  			upTo = pos;
35  		items = static_cast<WorkItems>(static_cast<int>(items) | static_cast<int>(items_));
36  	}
37  };
38  class SelectionText {
39  	std::string s;
40  public:
41  	bool rectangular;
42  	bool lineCopy;
43  	int codePage;
44  	Scintilla::CharacterSet characterSet;
45  	SelectionText() noexcept : rectangular(false), lineCopy(false), codePage(0), characterSet(Scintilla::CharacterSet::Ansi) {}
46  	void Clear() noexcept {
47  		s.clear();
48  		rectangular = false;
49  		lineCopy = false;
50  		codePage = 0;
51  		characterSet = Scintilla::CharacterSet::Ansi;
52  	}
53  	void Copy(const std::string &s_, int codePage_, Scintilla::CharacterSet characterSet_, bool rectangular_, bool lineCopy_) {
54  		s = s_;
55  		codePage = codePage_;
56  		characterSet = characterSet_;
57  		rectangular = rectangular_;
58  		lineCopy = lineCopy_;
59  		FixSelectionForClipboard();
60  	}
61  	void Copy(const SelectionText &other) {
62  		Copy(other.s, other.codePage, other.characterSet, other.rectangular, other.lineCopy);
63  	}
64  	const char *Data() const noexcept {
65  		return s.c_str();
66  	}
67  	size_t Length() const noexcept {
68  		return s.length();
69  	}
70  	size_t LengthWithTerminator() const noexcept {
71  		return s.length() + 1;
72  	}
73  	bool Empty() const noexcept {
74  		return s.empty();
75  	}
76  private:
77  	void FixSelectionForClipboard() {
78  		std::replace(s.begin(), s.end(), '\0', ' ');
79  	}
80  };
81  struct WrapPending {
82  	enum { lineLarge = 0x7ffffff };
83  	Sci::Line start;	
84  	Sci::Line end;	
85  	WrapPending() noexcept {
86  		start = lineLarge;
87  		end = lineLarge;
88  	}
89  	void Reset() noexcept {
90  		start = lineLarge;
91  		end = lineLarge;
92  	}
93  	void Wrapped(Sci::Line line) noexcept {
94  		if (start == line)
95  			start++;
96  	}
97  	bool NeedsWrap() const noexcept {
98  		return start < end;
99  	}
100  	bool AddRange(Sci::Line lineStart, Sci::Line lineEnd) noexcept {
101  		const bool neededWrap = NeedsWrap();
102  		bool changed = false;
103  		if (start > lineStart) {
104  			start = lineStart;
105  			changed = true;
106  		}
107  		if ((end < lineEnd) || !neededWrap) {
108  			end = lineEnd;
109  			changed = true;
110  		}
111  		return changed;
112  	}
113  };
114  struct CaretPolicySlop {
115  	Scintilla::CaretPolicy policy;	
116  	int slop;	
117  	CaretPolicySlop(Scintilla::CaretPolicy policy_, intptr_t slop_) noexcept :
118  		policy(policy_), slop(static_cast<int>(slop_)) {}
119  	CaretPolicySlop(uintptr_t policy_=0, intptr_t slop_=0) noexcept :
120  		policy(static_cast<Scintilla::CaretPolicy>(policy_)), slop(static_cast<int>(slop_)) {}
121  };
122  struct CaretPolicies {
123  	CaretPolicySlop x;
124  	CaretPolicySlop y;
125  };
126  struct VisiblePolicySlop {
127  	Scintilla::VisiblePolicy policy;	
128  	int slop;	
129  	VisiblePolicySlop(uintptr_t policy_ = 0, intptr_t slop_ = 0) noexcept :
130  		policy(static_cast<Scintilla::VisiblePolicy>(policy_)), slop(static_cast<int>(slop_)) {}
131  };
132  enum class XYScrollOptions {
133  	none = 0x0,
134  	useMargin = 0x1,
135  	vertical = 0x2,
136  	horizontal = 0x4,
137  	all = useMargin | vertical | horizontal
138  };
139  constexpr XYScrollOptions operator|(XYScrollOptions a, XYScrollOptions b) noexcept {
140  	return static_cast<XYScrollOptions>(static_cast<int>(a) | static_cast<int>(b));
141  }
142  class Editor : public EditModel, public DocWatcher {
143  protected:	
144  	Window wMain;	
145  	Window wMargin;	
146  	bool redrawPendingText = false;
147  	bool redrawPendingMargin = false;
148  	bool stylesValid;
149  	ViewStyle vs;
150  	Scintilla::Technology technology;
151  	Point sizeRGBAImage;
152  	float scaleRGBAImage;
153  	MarginView marginView;
154  	EditView view;
155  	Scintilla::CursorShape cursorMode;
156  	bool mouseDownCaptures;
157  	bool mouseWheelCaptures;
158  	int xCaretMargin;	
159  	bool horizontalScrollBarVisible;
160  	int scrollWidth;
161  	bool verticalScrollBarVisible;
162  	bool endAtLastLine;
163  	Scintilla::CaretSticky caretSticky;
164  	Scintilla::MarginOption marginOptions;
165  	bool mouseSelectionRectangularSwitch;
166  	bool multipleSelection;
167  	bool additionalSelectionTyping;
168  	Scintilla::MultiPaste multiPasteMode;
169  	Scintilla::VirtualSpace virtualSpaceOptions;
170  	KeyMap kmap;
171  	Timer timer;
172  	Timer autoScrollTimer;
173  	enum { autoScrollDelay = 200 };
174  	Idler idler;
175  	Point lastClick;
176  	unsigned int lastClickTime;
177  	Point doubleClickCloseThreshold;
178  	int dwellDelay;
179  	int ticksToDwell;
180  	bool dwelling;
181  	enum class TextUnit { character, word, subLine, wholeLine } selectionUnit;
182  	Point ptMouseLast;
183  	enum class DragDrop { none, initial, dragging } inDragDrop;
184  	bool dropWentOutside;
185  	SelectionPosition posDrop;
186  	Sci::Position hotSpotClickPos;
187  	int lastXChosen;
188  	Sci::Position lineAnchorPos;
189  	Sci::Position originalAnchorPos;
190  	Sci::Position wordSelectAnchorStartPos;
191  	Sci::Position wordSelectAnchorEndPos;
192  	Sci::Position wordSelectInitialCaretPos;
193  	SelectionSegment targetRange;
194  	Scintilla::FindOption searchFlags;
195  	Sci::Line topLine;
196  	Sci::Position posTopLine;
197  	Sci::Position lengthForEncode;
198  	Scintilla::Update needUpdateUI;
199  	enum class PaintState { notPainting, painting, abandoned } paintState;
200  	bool paintAbandonedByStyling;
201  	PRectangle rcPaint;
202  	bool paintingAllText;
203  	bool willRedrawAll;
204  	WorkNeeded workNeeded;
205  	Scintilla::IdleStyling idleStyling;
206  	bool needIdleStyling;
207  	Scintilla::ModificationFlags modEventMask;
208  	bool commandEvents;
209  	SelectionText drag;
210  	CaretPolicies caretPolicies;
211  	VisiblePolicySlop visiblePolicy;
212  	Sci::Position searchAnchor;
213  	bool recordingMacro;
214  	Scintilla::AutomaticFold foldAutomatic;
215  	WrapPending wrapPending;
216  	ActionDuration durationWrapOneByte;
217  	bool convertPastes;
218  	Editor();
219  	Editor(const Editor &) = delete;
220  	Editor(Editor &&) = delete;
221  	Editor &operator=(const Editor &) = delete;
222  	Editor &operator=(Editor &&) = delete;
223  	virtual void Initialise() = 0;
<span onclick='openModal()' class='match'>224  	virtual void Finalise();
225  	void InvalidateStyleData() noexcept;
226  	void InvalidateStyleRedraw();
227  	void RefreshStyleData();
228  	void SetRepresentations();
229  	void DropGraphics() noexcept;
230  	bool HasMarginWindow() const noexcept;
231  	Point GetVisibleOriginInMain() const override;
232  	PointDocument DocumentPointFromView(Point ptView) const;  
233  	Sci::Line TopLineOfMain() const noexcept final;   
234  	virtual Point ClientSize() const;
235  	virtual PRectangle GetClientRectangle() const;
236  	virtual PRectangle GetClientDrawingRectangle();
237  	PRectangle GetTextRectangle() const;
238  	Sci::Line LinesOnScreen() const override;
239  	Sci::Line LinesToScroll() const;
240  	Sci::Line MaxScrollPos() const;
241  	SelectionPosition ClampPositionIntoDocument(SelectionPosition sp) const;
242  	Point LocationFromPosition(SelectionPosition pos, PointEnd pe=PointEnd::start);
243  	Point LocationFromPosition(Sci::Position pos, PointEnd pe=PointEnd::start);
244  	int XFromPosition(SelectionPosition sp);
245  	SelectionPosition SPositionFromLocation(Point pt, bool canReturnInvalid=false, bool charPosition=false, bool virtualSpace=true);
246  	Sci::Position PositionFromLocation(Point pt, bool canReturnInvalid = false, bool charPosition = false);
</span>247  	SelectionPosition SPositionFromLineX(Sci::Line lineDoc, int x);
248  	Sci::Position PositionFromLineX(Sci::Line lineDoc, int x);
249  	Sci::Line LineFromLocation(Point pt) const noexcept;
250  	void SetTopLine(Sci::Line topLineNew);
251  	virtual bool AbandonPaint();
252  	virtual void RedrawRect(PRectangle rc);
253  	virtual void DiscardOverdraw();
254  	virtual void Redraw();
255  	void RedrawSelMargin(Sci::Line line=-1, bool allAfter=false);
256  	PRectangle RectangleFromRange(Range r, int overlap);
257  	void InvalidateRange(Sci::Position start, Sci::Position end);
258  	bool UserVirtualSpace() const noexcept {
259  		return (FlagSet(virtualSpaceOptions, Scintilla::VirtualSpace::UserAccessible));
260  	}
261  	Sci::Position CurrentPosition() const noexcept;
262  	bool SelectionEmpty() const noexcept;
263  	SelectionPosition SelectionStart() noexcept;
264  	SelectionPosition SelectionEnd() noexcept;
265  	void SetRectangularRange();
266  	void ThinRectangularRange();
267  	void InvalidateSelection(SelectionRange newMain, bool invalidateWholeSelection=false);
268  	void InvalidateWholeSelection();
269  	SelectionRange LineSelectionRange(SelectionPosition currentPos_, SelectionPosition anchor_) const;
270  	void SetSelection(SelectionPosition currentPos_, SelectionPosition anchor_);
271  	void SetSelection(Sci::Position currentPos_, Sci::Position anchor_);
272  	void SetSelection(SelectionPosition currentPos_);
273  	void SetEmptySelection(SelectionPosition currentPos_);
274  	void SetEmptySelection(Sci::Position currentPos_);
275  	enum class AddNumber { one, each };
276  	void MultipleSelectAdd(AddNumber addNumber);
277  	bool RangeContainsProtected(Sci::Position start, Sci::Position end) const noexcept;
278  	bool SelectionContainsProtected() const noexcept;
279  	Sci::Position MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd=true) const;
280  	SelectionPosition MovePositionOutsideChar(SelectionPosition pos, Sci::Position moveDir, bool checkLineEnd=true) const;
281  	void MovedCaret(SelectionPosition newPos, SelectionPosition previousPos,
282  		bool ensureVisible, CaretPolicies policies);
283  	void MovePositionTo(SelectionPosition newPos, Selection::SelTypes selt=Selection::SelTypes::none, bool ensureVisible=true);
284  	void MovePositionTo(Sci::Position newPos, Selection::SelTypes selt=Selection::SelTypes::none, bool ensureVisible=true);
285  	SelectionPosition MovePositionSoVisible(SelectionPosition pos, int moveDir);
286  	SelectionPosition MovePositionSoVisible(Sci::Position pos, int moveDir);
287  	Point PointMainCaret();
288  	void SetLastXChosen();
289  	void ScrollTo(Sci::Line line, bool moveThumb=true);
290  	virtual void ScrollText(Sci::Line linesToMove);
291  	void HorizontalScrollTo(int xPos);
292  	void VerticalCentreCaret();
293  	void MoveSelectedLines(int lineDelta);
294  	void MoveSelectedLinesUp();
295  	void MoveSelectedLinesDown();
296  	void MoveCaretInsideView(bool ensureVisible=true);
297  	Sci::Line DisplayFromPosition(Sci::Position pos);
298  	struct XYScrollPosition {
299  		int xOffset;
300  		Sci::Line topLine;
301  		XYScrollPosition(int xOffset_, Sci::Line topLine_) noexcept : xOffset(xOffset_), topLine(topLine_) {}
302  		bool operator==(const XYScrollPosition &other) const noexcept {
303  			return (xOffset == other.xOffset) && (topLine == other.topLine);
304  		}
305  	};
306  	XYScrollPosition XYScrollToMakeVisible(const SelectionRange &range,
307  		const XYScrollOptions options, CaretPolicies policies);
308  	void SetXYScroll(XYScrollPosition newXY);
309  	void EnsureCaretVisible(bool useMargin=true, bool vert=true, bool horiz=true);
310  	void ScrollRange(SelectionRange range);
311  	void ShowCaretAtCurrentPosition();
312  	void DropCaret();
313  	void CaretSetPeriod(int period);
314  	void InvalidateCaret();
315  	virtual void NotifyCaretMove();
316  	virtual void UpdateSystemCaret();
317  	bool Wrapping() const noexcept;
318  	void NeedWrapping(Sci::Line docLineStart=0, Sci::Line docLineEnd=WrapPending::lineLarge);
319  	bool WrapOneLine(Surface *surface, Sci::Line lineToWrap);
320  	bool WrapBlock(Surface *surface, Sci::Line lineToWrap, Sci::Line lineToWrapEnd);
321  	enum class WrapScope {wsAll, wsVisible, wsIdle};
322  	bool WrapLines(WrapScope ws);
323  	void LinesJoin();
324  	void LinesSplit(int pixelWidth);
325  	void PaintSelMargin(Surface *surfaceWindow, const PRectangle &rc);
326  	void RefreshPixMaps(Surface *surfaceWindow);
327  	void Paint(Surface *surfaceWindow, PRectangle rcArea);
328  	Sci::Position FormatRange(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
329  	long TextWidth(Scintilla::uptr_t style, const char *text);
330  	virtual void SetVerticalScrollPos() = 0;
331  	virtual void SetHorizontalScrollPos() = 0;
332  	virtual bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) = 0;
333  	virtual void ReconfigureScrollBars();
334  	void ChangeScrollBars();
335  	virtual void SetScrollBars();
336  	void ChangeSize();
337  	void FilterSelections();
338  	Sci::Position RealizeVirtualSpace(Sci::Position position, Sci::Position virtualSpace);
339  	SelectionPosition RealizeVirtualSpace(const SelectionPosition &position);
340  	void AddChar(char ch);
341  	virtual void InsertCharacter(std::string_view sv, Scintilla::CharacterSource charSource);
342  	void ClearBeforeTentativeStart();
343  	void InsertPaste(const char *text, Sci::Position len);
344  	enum class PasteShape { stream=0, rectangular = 1, line = 2 };
345  	void InsertPasteShape(const char *text, Sci::Position len, PasteShape shape);
346  	void ClearSelection(bool retainMultipleSelections = false);
347  	void ClearAll();
348  	void ClearDocumentStyle();
349  	virtual void Cut();
350  	void PasteRectangular(SelectionPosition pos, const char *ptr, Sci::Position len);
351  	virtual void Copy() = 0;
352  	void CopyAllowLine();
353  	virtual bool CanPaste();
354  	virtual void Paste() = 0;
355  	void Clear();
356  	virtual void SelectAll();
357  	virtual void Undo();
358  	virtual void Redo();
359  	void DelCharBack(bool allowLineStartDeletion);
360  	virtual void ClaimSelection() = 0;
361  	virtual void NotifyChange() = 0;
362  	virtual void NotifyFocus(bool focus);
363  	virtual void SetCtrlID(int identifier);
364  	virtual int GetCtrlID() { return ctrlID; }
365  	virtual void NotifyParent(Scintilla::NotificationData scn) = 0;
366  	virtual void NotifyStyleToNeeded(Sci::Position endStyleNeeded);
367  	void NotifyChar(int ch, Scintilla::CharacterSource charSource);
368  	void NotifySavePoint(bool isSavePoint);
369  	void NotifyModifyAttempt();
370  	virtual void NotifyDoubleClick(Point pt, Scintilla::KeyMod modifiers);
371  	void NotifyHotSpotClicked(Sci::Position position, Scintilla::KeyMod modifiers);
372  	void NotifyHotSpotDoubleClicked(Sci::Position position, Scintilla::KeyMod modifiers);
373  	void NotifyHotSpotReleaseClick(Sci::Position position, Scintilla::KeyMod modifiers);
374  	bool NotifyUpdateUI();
375  	void NotifyPainted();
376  	void NotifyIndicatorClick(bool click, Sci::Position position, Scintilla::KeyMod modifiers);
377  	bool NotifyMarginClick(Point pt, Scintilla::KeyMod modifiers);
378  	bool NotifyMarginRightClick(Point pt, Scintilla::KeyMod modifiers);
379  	void NotifyNeedShown(Sci::Position pos, Sci::Position len);
380  	void NotifyDwelling(Point pt, bool state);
381  	void NotifyZoom();
382  	void NotifyModifyAttempt(Document *document, void *userData) override;
383  	void NotifySavePoint(Document *document, void *userData, bool atSavePoint) override;
384  	void CheckModificationForWrap(DocModification mh);
385  	void NotifyModified(Document *document, DocModification mh, void *userData) override;
386  	void NotifyDeleted(Document *document, void *userData) noexcept override;
387  	void NotifyStyleNeeded(Document *doc, void *userData, Sci::Position endStyleNeeded) override;
388  	void NotifyErrorOccurred(Document *doc, void *userData, Scintilla::Status status) override;
389  	void NotifyMacroRecord(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
390  	void ContainerNeedsUpdate(Scintilla::Update flags) noexcept;
391  	void PageMove(int direction, Selection::SelTypes selt=Selection::SelTypes::none, bool stuttered = false);
392  	enum class CaseMapping { same, upper, lower };
393  	virtual std::string CaseMapString(const std::string &s, CaseMapping caseMapping);
394  	void ChangeCaseOfSelection(CaseMapping caseMapping);
395  	void LineTranspose();
396  	void LineReverse();
397  	void Duplicate(bool forLine);
398  	virtual void CancelModes();
399  	void NewLine();
400  	SelectionPosition PositionUpOrDown(SelectionPosition spStart, int direction, int lastX);
401  	void CursorUpOrDown(int direction, Selection::SelTypes selt);
402  	void ParaUpOrDown(int direction, Selection::SelTypes selt);
403  	Range RangeDisplayLine(Sci::Line lineVisible);
404  	Sci::Position StartEndDisplayLine(Sci::Position pos, bool start);
405  	Sci::Position VCHomeDisplayPosition(Sci::Position position);
406  	Sci::Position VCHomeWrapPosition(Sci::Position position);
407  	Sci::Position LineEndWrapPosition(Sci::Position position);
408  	int HorizontalMove(Scintilla::Message iMessage);
409  	int DelWordOrLine(Scintilla::Message iMessage);
410  	virtual int KeyCommand(Scintilla::Message iMessage);
411  	virtual int KeyDefault(Scintilla::Keys &bsol;* key */, Scintilla::KeyMod &bsol;*modifiers*/);
412  	int KeyDownWithModifiers(Scintilla::Keys key, Scintilla::KeyMod modifiers, bool *consumed);
413  	void Indent(bool forwards);
414  	virtual std::unique_ptr<CaseFolder> CaseFolderForEncoding();
415  	Sci::Position FindText(Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
416  	Sci::Position FindTextFull(Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
417  	void SearchAnchor() noexcept;
418  	Sci::Position SearchText(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
419  	Sci::Position SearchInTarget(const char *text, Sci::Position length);
420  	void GoToLine(Sci::Line lineNo);
421  	virtual void CopyToClipboard(const SelectionText &selectedText) = 0;
422  	std::string RangeText(Sci::Position start, Sci::Position end) const;
423  	void CopySelectionRange(SelectionText *ss, bool allowLineCopy=false);
424  	void CopyRangeToClipboard(Sci::Position start, Sci::Position end);
425  	void CopyText(size_t length, const char *text);
426  	void SetDragPosition(SelectionPosition newPos);
427  	virtual void DisplayCursor(Window::Cursor c);
428  	virtual bool DragThreshold(Point ptStart, Point ptNow);
429  	virtual void StartDrag();
430  	void DropAt(SelectionPosition position, const char *value, size_t lengthValue, bool moving, bool rectangular);
431  	void DropAt(SelectionPosition position, const char *value, bool moving, bool rectangular);
432  	bool PositionInSelection(Sci::Position pos);
433  	bool PointInSelection(Point pt);
434  	bool PointInSelMargin(Point pt) const;
435  	Window::Cursor GetMarginCursor(Point pt) const noexcept;
436  	void TrimAndSetSelection(Sci::Position currentPos_, Sci::Position anchor_);
437  	void LineSelection(Sci::Position lineCurrentPos_, Sci::Position lineAnchorPos_, bool wholeLine);
438  	void WordSelection(Sci::Position pos);
439  	void DwellEnd(bool mouseMoved);
440  	void MouseLeave();
441  	virtual void ButtonDownWithModifiers(Point pt, unsigned int curTime, Scintilla::KeyMod modifiers);
442  	virtual void RightButtonDownWithModifiers(Point pt, unsigned int curTime, Scintilla::KeyMod modifiers);
443  	void ButtonMoveWithModifiers(Point pt, unsigned int curTime, Scintilla::KeyMod modifiers);
444  	void ButtonUpWithModifiers(Point pt, unsigned int curTime, Scintilla::KeyMod modifiers);
445  	bool Idle();
446  	enum class TickReason { caret, scroll, widen, dwell, platform };
447  	virtual void TickFor(TickReason reason);
448  	virtual bool FineTickerRunning(TickReason reason);
449  	virtual void FineTickerStart(TickReason reason, int millis, int tolerance);
450  	virtual void FineTickerCancel(TickReason reason);
451  	virtual bool SetIdle(bool) { return false; }
452  	virtual void SetMouseCapture(bool on) = 0;
453  	virtual bool HaveMouseCapture() = 0;
454  	void SetFocusState(bool focusState);
455  	virtual void UpdateBaseElements();
456  	Sci::Position PositionAfterArea(PRectangle rcArea) const;
457  	void StyleToPositionInView(Sci::Position pos);
458  	Sci::Position PositionAfterMaxStyling(Sci::Position posMax, bool scrolling) const;
459  	void StartIdleStyling(bool truncatedLastStyling);
460  	void StyleAreaBounded(PRectangle rcArea, bool scrolling);
461  	constexpr bool SynchronousStylingToVisible() const noexcept {
462  		return (idleStyling == Scintilla::IdleStyling::None) || (idleStyling == Scintilla::IdleStyling::AfterVisible);
463  	}
464  	void IdleStyle();
465  	virtual void IdleWork();
466  	virtual void QueueIdleWork(WorkItems items, Sci::Position upTo=0);
467  	virtual int SupportsFeature(Scintilla::Supports feature);
468  	virtual bool PaintContains(PRectangle rc);
469  	bool PaintContainsMargin();
470  	void CheckForChangeOutsidePaint(Range r);
471  	void SetBraceHighlight(Sci::Position pos0, Sci::Position pos1, int matchStyle);
472  	void SetAnnotationHeights(Sci::Line start, Sci::Line end);
473  	virtual void SetDocPointer(Document *document);
474  	void SetAnnotationVisible(Scintilla::AnnotationVisible visible);
475  	void SetEOLAnnotationVisible(Scintilla::EOLAnnotationVisible visible);
476  	Sci::Line ExpandLine(Sci::Line line);
477  	void SetFoldExpanded(Sci::Line lineDoc, bool expanded);
478  	void FoldLine(Sci::Line line, Scintilla::FoldAction action);
479  	void FoldExpand(Sci::Line line, Scintilla::FoldAction action, Scintilla::FoldLevel level);
480  	Sci::Line ContractedFoldNext(Sci::Line lineStart) const;
481  	void EnsureLineVisible(Sci::Line lineDoc, bool enforcePolicy);
482  	void FoldChanged(Sci::Line line, Scintilla::FoldLevel levelNow, Scintilla::FoldLevel levelPrev);
483  	void NeedShown(Sci::Position pos, Sci::Position len);
484  	void FoldAll(Scintilla::FoldAction action);
485  	Sci::Position GetTag(char *tagValue, int tagNumber);
486  	enum class ReplaceType {basic, patterns, minimal};
487  	Sci::Position ReplaceTarget(ReplaceType replaceType, std::string_view text);
488  	bool PositionIsHotspot(Sci::Position position) const noexcept;
489  	bool PointIsHotspot(Point pt);
490  	void SetHotSpotRange(const Point *pt);
491  	void SetHoverIndicatorPosition(Sci::Position position);
492  	void SetHoverIndicatorPoint(Point pt);
493  	int CodePage() const noexcept;
494  	virtual bool ValidCodePage(int &bsol;* codePage */) const { return true; }
495  	virtual std::string UTF8FromEncoded(std::string_view encoded) const = 0;
496  	virtual std::string EncodedFromUTF8(std::string_view utf8) const = 0;
497  	virtual std::unique_ptr<Surface> CreateMeasurementSurface() const;
498  	virtual std::unique_ptr<Surface> CreateDrawingSurface(SurfaceID sid, std::optional<Scintilla::Technology> technologyOpt = {}) const;
499  	Sci::Line WrapCount(Sci::Line line);
500  	void AddStyledText(const char *buffer, Sci::Position appendLength);
501  	Sci::Position GetStyledText(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const noexcept;
502  	Sci::Position GetTextRange(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const;
503  	virtual Scintilla::sptr_t DefWndProc(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam) = 0;
504  	bool ValidMargin(Scintilla::uptr_t wParam) const noexcept;
505  	void StyleSetMessage(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
506  	Scintilla::sptr_t StyleGetMessage(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
507  	void SetSelectionNMessage(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
508  	static void *PtrFromSPtr(Scintilla::sptr_t lParam) noexcept {
509  		return reinterpret_cast<void *>(lParam);
510  	}
511  	static const char *ConstCharPtrFromSPtr(Scintilla::sptr_t lParam) noexcept {
512  		return static_cast<const char *>(PtrFromSPtr(lParam));
513  	}
514  	static const unsigned char *ConstUCharPtrFromSPtr(Scintilla::sptr_t lParam) noexcept {
515  		return static_cast<const unsigned char *>(PtrFromSPtr(lParam));
516  	}
517  	static char *CharPtrFromSPtr(Scintilla::sptr_t lParam) noexcept {
518  		return static_cast<char *>(PtrFromSPtr(lParam));
519  	}
520  	static unsigned char *UCharPtrFromSPtr(Scintilla::sptr_t lParam) noexcept {
521  		return static_cast<unsigned char *>(PtrFromSPtr(lParam));
522  	}
523  	static std::string_view ViewFromParams(Scintilla::sptr_t lParam, Scintilla::uptr_t wParam) noexcept {
524  		if (SPtrFromUPtr(wParam) == -1) {
525  			return std::string_view(CharPtrFromSPtr(lParam));
526  		}
527  		return std::string_view(CharPtrFromSPtr(lParam), wParam);
528  	}
529  	static void *PtrFromUPtr(Scintilla::uptr_t wParam) noexcept {
530  		return reinterpret_cast<void *>(wParam);
531  	}
532  	static const char *ConstCharPtrFromUPtr(Scintilla::uptr_t wParam) noexcept {
533  		return static_cast<const char *>(PtrFromUPtr(wParam));
534  	}
535  	static constexpr Scintilla::sptr_t SPtrFromUPtr(Scintilla::uptr_t wParam) noexcept {
536  		return static_cast<Scintilla::sptr_t>(wParam);
537  	}
538  	static constexpr Sci::Position PositionFromUPtr(Scintilla::uptr_t wParam) noexcept {
539  		return SPtrFromUPtr(wParam);
540  	}
541  	static constexpr Sci::Line LineFromUPtr(Scintilla::uptr_t wParam) noexcept {
542  		return SPtrFromUPtr(wParam);
543  	}
544  	Point PointFromParameters(Scintilla::uptr_t wParam, Scintilla::sptr_t lParam) const noexcept {
545  		return Point(static_cast<XYPOSITION>(wParam) - vs.ExternalMarginWidth(), static_cast<XYPOSITION>(lParam));
546  	}
547  	static constexpr std::optional<FoldLevel> OptionalFoldLevel(Scintilla::sptr_t lParam) {
548  		if (lParam >= 0) {
549  			return static_cast<FoldLevel>(lParam);
550  		}
551  		return std::nullopt;
552  	}
553  	static Scintilla::sptr_t StringResult(Scintilla::sptr_t lParam, const char *val) noexcept;
554  	static Scintilla::sptr_t BytesResult(Scintilla::sptr_t lParam, const unsigned char *val, size_t len) noexcept;
555  	template <typename T>
556  	bool SetAppearance(T &variable, T value) {
557  		const bool changed = !(variable == value);
558  		if (changed) {
559  			variable = value;
560  			InvalidateStyleRedraw();
561  		}
562  		return changed;
563  	}
564  public:
565  	~Editor() override;
566  	bool IsUnicodeMode() const noexcept;
567  	virtual Scintilla::sptr_t WndProc(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
568  	int ctrlID;
569  	Scintilla::Status errorStatus;
570  	friend class AutoSurface;
571  };
572  class AutoSurface {
573  private:
574  	std::unique_ptr<Surface> surf;
575  public:
576  	AutoSurface(const Editor *ed) :
577  		surf(ed->CreateMeasurementSurface())  {
578  	}
579  	AutoSurface(SurfaceID sid, Editor *ed, std::optional<Scintilla::Technology> technology = {}) :
580  		surf(ed->CreateDrawingSurface(sid, technology)) {
581  	}
582  	AutoSurface(const AutoSurface &) = delete;
583  	AutoSurface(AutoSurface &&) = delete;
584  	void operator=(const AutoSurface &) = delete;
585  	void operator=(AutoSurface &&) = delete;
586  	~AutoSurface() {
587  	}
588  	Surface *operator->() const noexcept {
589  		return surf.get();
590  	}
591  	operator Surface *() const noexcept {
592  		return surf.get();
593  	}
594  };
595  }
596  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-frontier_store_74.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.h</div>
                </div>
                <div class="column column_space"><pre><code>12  		nano::lmdb::store & store;
13  	public:
14  		frontier_store (nano::lmdb::store & store);
15  		void put (nano::write_transaction const &, nano::block_hash const &, nano::account const &) override;
16  		nano::account get (nano::transaction const &, nano::block_hash const &) const override;
17  		void del (nano::write_transaction const &, nano::block_hash const &) override;
18  		nano::store_iterator<nano::block_hash, nano::account> begin (nano::transaction const &) const override;
19  		nano::store_iterator<nano::block_hash, nano::account> begin (nano::transaction const &, nano::block_hash const &) const override;
20  		nano::store_iterator<nano::block_hash, nano::account> end () const override;
21  		void for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::block_hash, nano::account>, nano::store_iterator<nano::block_hash, nano::account>)> const & action_a) const override;
22  		MDB_dbi frontiers_handle{ 0 };
</pre></code></div>
                <div class="column column_space"><pre><code>224  	virtual void Finalise();
225  	void InvalidateStyleData() noexcept;
226  	void InvalidateStyleRedraw();
227  	void RefreshStyleData();
228  	void SetRepresentations();
229  	void DropGraphics() noexcept;
230  	bool HasMarginWindow() const noexcept;
231  	Point GetVisibleOriginInMain() const override;
232  	PointDocument DocumentPointFromView(Point ptView) const;  
233  	Sci::Line TopLineOfMain() const noexcept final;   
234  	virtual Point ClientSize() const;
235  	virtual PRectangle GetClientRectangle() const;
236  	virtual PRectangle GetClientDrawingRectangle();
237  	PRectangle GetTextRectangle() const;
238  	Sci::Line LinesOnScreen() const override;
239  	Sci::Line LinesToScroll() const;
240  	Sci::Line MaxScrollPos() const;
241  	SelectionPosition ClampPositionIntoDocument(SelectionPosition sp) const;
242  	Point LocationFromPosition(SelectionPosition pos, PointEnd pe=PointEnd::start);
243  	Point LocationFromPosition(Sci::Position pos, PointEnd pe=PointEnd::start);
244  	int XFromPosition(SelectionPosition sp);
245  	SelectionPosition SPositionFromLocation(Point pt, bool canReturnInvalid=false, bool charPosition=false, bool virtualSpace=true);
246  	Sci::Position PositionFromLocation(Point pt, bool canReturnInvalid = false, bool charPosition = false);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    