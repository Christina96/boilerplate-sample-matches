
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.406844106463879%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_format.h</h3>
            <pre><code>1  #ifndef ABSL_LOG_INTERNAL_LOG_FORMAT_H_
2  #define ABSL_LOG_INTERNAL_LOG_FORMAT_H_
3  #include <stddef.h>
4  #include <string>
5  #include "absl/base/config.h"
6  #include "absl/base/log_severity.h"
7  #include "absl/log/internal/config.h"
8  #include "absl/strings/string_view.h"
9  #include "absl/time/civil_time.h"
10  #include "absl/time/time.h"
11  #include "absl/types/span.h"
12  namespace absl {
13  ABSL_NAMESPACE_BEGIN
14  namespace log_internal {
15  enum class PrefixFormat {
16    kNotRaw,
17    kRaw,
18  };
<span onclick='openModal()' class='match'>19  std::string FormatLogMessage(absl::LogSeverity severity,
20                               absl::CivilSecond civil_second,
21                               absl::Duration subsecond, log_internal::Tid tid,
22                               absl::string_view basename, int line,
23                               PrefixFormat format, absl::string_view message);
24  size_t FormatLogPrefix(absl::LogSeverity severity, absl::Time timestamp,
25                         log_internal::Tid tid, absl::string_view basename,
26                         int line, PrefixFormat format, absl::Span<char>& buf);
</span>27  }  
28  ABSL_NAMESPACE_END
29  }  
30  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.h</h3>
            <pre><code>1  #ifndef COUTLN_H
2  #define COUTLN_H
3  #include "elst.h"       
4  #include "mod128.h"     
5  #include "points.h"     
6  #include "rect.h"       
7  #include "scrollview.h" 
8  #include <tesseract/export.h> 
9  #include <cstdint> 
10  #include <bitset>  
11  struct Pix;
12  namespace tesseract {
13  class CRACKEDGE;
14  class DENORM;
15  #define INTERSECTING INT16_MAX 
16  #define STEP_MASK 3
17  enum C_OUTLINE_FLAGS {
18    COUT_INVERSE 
19  };
20  struct EdgeOffset {
21    int8_t offset_numerator;
22    uint8_t pixel_diff;
23    uint8_t direction;
24  };
25  class C_OUTLINE; 
26  ELISTIZEH(C_OUTLINE)
27  class C_OUTLINE : public ELIST_LINK {
28  public:
29    C_OUTLINE() {
30      stepcount = 0;
31      offsets = nullptr;
32    }
33    C_OUTLINE(              
<span onclick='openModal()' class='match'>34        CRACKEDGE *startpt, 
35        ICOORD bot_left,    
36        ICOORD top_right, int16_t length);
37    C_OUTLINE(ICOORD startpt,                       
38              DIR128 *new_steps,                    
39              int16_t length);                      
40    C_OUTLINE(C_OUTLINE *srcline, FCOORD rotation); 
</span>41    static void FakeOutline(const TBOX &box, C_OUTLINE_LIST *outlines);
42    ~C_OUTLINE() { 
43      delete[] offsets;
44    }
45    bool flag(                        
46        C_OUTLINE_FLAGS mask) const { 
47      return flags[mask];
48    }
49    void set_flag(            
50        C_OUTLINE_FLAGS mask, 
51        bool value) {         
52      flags.set(mask, value);
53    }
54    C_OUTLINE_LIST *child() { 
55      return &children;
56    }
57    const TBOX &bounding_box() const {
58      return box;
59    }
60    void set_step(         
61        int16_t stepindex, 
62        int8_t stepdir) {  
63      int shift = stepindex % 4 * 2;
64      uint8_t mask = 3 << shift;
65      steps[stepindex / 4] = ((stepdir << shift) & mask) | (steps[stepindex / 4] & ~mask);
66    }
67    void set_step(         
68        int16_t stepindex, 
69        DIR128 stepdir) {  
70      int8_t chaindir = stepdir.get_dir() >> (DIRBITS - 2);
71      set_step(stepindex, chaindir);
72    }
73    int32_t pathlength() const { 
74      return stepcount;
75    }
76    DIR128 step_dir(int index) const {
77      return DIR128(
78          static_cast<int16_t>(((steps[index / 4] >> (index % 4 * 2)) & STEP_MASK) << (DIRBITS - 2)));
79    }
80    ICOORD step(int index) const { 
81      return step_coords[chain_code(index)];
82    }
83    const ICOORD &start_pos() const {
84      return start;
85    }
86    ICOORD position_at_index(int index) const {
87      ICOORD pos = start;
88      for (int i = 0; i < index; ++i) {
89        pos += step(i);
90      }
91      return pos;
92    }
93    FCOORD sub_pixel_pos_at_index(const ICOORD &pos, int index) const {
94      const ICOORD &step_to_next(step(index));
95      FCOORD f_pos(pos.x() + step_to_next.x() / 2.0f, pos.y() + step_to_next.y() / 2.0f);
96      if (offsets != nullptr && offsets[index].pixel_diff > 0) {
97        float offset = offsets[index].offset_numerator;
98        offset /= offsets[index].pixel_diff;
99        if (step_to_next.x() != 0) {
100          f_pos.set_y(f_pos.y() + offset);
101        } else {
102          f_pos.set_x(f_pos.x() + offset);
103        }
104      }
105      return f_pos;
106    }
107    int direction_at_index(int index) const {
108      if (offsets != nullptr && offsets[index].pixel_diff > 0) {
109        return offsets[index].direction;
110      }
111      return -1;
112    }
113    int edge_strength_at_index(int index) const {
114      if (offsets != nullptr) {
115        return offsets[index].pixel_diff;
116      }
117      return 1;
118    }
119    int chain_code(int index) const { 
120      return (steps[index / 4] >> (index % 4 * 2)) & STEP_MASK;
121    }
122    int32_t area() const;       
123    int32_t perimeter() const;  
124    int32_t outer_area() const; 
125    int32_t count_transitions(  
126        int32_t threshold);     
127    bool operator<( 
128        const C_OUTLINE &other) const;
129    bool operator>( 
130        C_OUTLINE &other) const {
131      return other < *this; 
132    }
133    int16_t winding_number(   
134        ICOORD testpt) const; 
135    int16_t turn_direction() const;
136    void reverse(); 
137    void move(             
138        const ICOORD vec); 
139    bool IsLegallyNested() const;
140    void RemoveSmallRecursive(int min_size, C_OUTLINE_IT *it);
141    void ComputeEdgeOffsets(int threshold, Image pix);
142    void ComputeBinaryOffsets();
143    void render(int left, int top, Image pix) const;
144    void render_outline(int left, int top, Image pix) const;
145  #ifndef GRAPHICS_DISABLED
146    void plot(                           
147        ScrollView *window,              
148        ScrollView::Color colour) const; 
149    void plot_normed(const DENORM &denorm, ScrollView::Color colour, ScrollView *window) const;
150  #endif 
151    C_OUTLINE &operator=(const C_OUTLINE &source);
152    static C_OUTLINE *deep_copy(const C_OUTLINE *src) {
153      auto *outline = new C_OUTLINE;
154      *outline = *src;
155      return outline;
156    }
157    static ICOORD chain_step(int chaindir);
158    static const int kMaxOutlineLength = 16000;
159  private:
160    void increment_step(int s, int increment, ICOORD *pos, int *dir_counts, int *pos_totals) const;
161    int step_mem() const {
162      return (stepcount + 3) / 4;
163    }
164    TBOX box;                
165    ICOORD start;            
166    int16_t stepcount;       
167    std::bitset<16> flags;   
168    std::vector<uint8_t> steps; 
169    EdgeOffset *offsets;     
170    C_OUTLINE_LIST children; 
171    static ICOORD step_coords[4];
172  };
173  } 
174  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_format.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.h</div>
                </div>
                <div class="column column_space"><pre><code>19  std::string FormatLogMessage(absl::LogSeverity severity,
20                               absl::CivilSecond civil_second,
21                               absl::Duration subsecond, log_internal::Tid tid,
22                               absl::string_view basename, int line,
23                               PrefixFormat format, absl::string_view message);
24  size_t FormatLogPrefix(absl::LogSeverity severity, absl::Time timestamp,
25                         log_internal::Tid tid, absl::string_view basename,
26                         int line, PrefixFormat format, absl::Span<char>& buf);
</pre></code></div>
                <div class="column column_space"><pre><code>34        CRACKEDGE *startpt, 
35        ICOORD bot_left,    
36        ICOORD top_right, int16_t length);
37    C_OUTLINE(ICOORD startpt,                       
38              DIR128 *new_steps,                    
39              int16_t length);                      
40    C_OUTLINE(C_OUTLINE *srcline, FCOORD rotation); 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    