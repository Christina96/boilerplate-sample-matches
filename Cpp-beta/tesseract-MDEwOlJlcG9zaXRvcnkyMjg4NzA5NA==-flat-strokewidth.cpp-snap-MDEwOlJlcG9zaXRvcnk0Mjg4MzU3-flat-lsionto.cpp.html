
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.043731778425656%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "strokewidth.h"
5  #include <algorithm>
6  #include <cmath>
7  #include "blobbox.h"
8  #include "colpartition.h"
9  #include "colpartitiongrid.h"
10  #include "helpers.h" 
11  #include "imagefind.h"
12  #include "linlsq.h"
13  #include "statistc.h"
14  #include "tabfind.h"
15  #include "textlineprojection.h"
16  #include "tordmain.h" 
17  namespace tesseract {
18  #ifndef GRAPHICS_DISABLED
19  static INT_VAR(textord_tabfind_show_strokewidths, 0, "Show stroke widths (ScrollView)");
20  #else
21  static INT_VAR(textord_tabfind_show_strokewidths, 0, "Show stroke widths");
22  #endif
23  static BOOL_VAR(textord_tabfind_only_strokewidths, false, "Only run stroke widths");
24  const double kStrokeWidthFractionTolerance = 0.125;
25  const double kStrokeWidthTolerance = 1.5;
26  const double kStrokeWidthFractionCJK = 0.25;
27  const double kStrokeWidthCJK = 2.0;
28  const int kCJKRadius = 2;
29  const double kCJKBrokenDistanceFraction = 0.25;
30  const int kCJKMaxComponents = 8;
31  const double kCJKAspectRatio = 1.25;
32  const double kCJKAspectRatioIncrease = 1.0625;
33  const int kMaxCJKSizeRatio = 5;
34  const double kBrokenCJKIterationFraction = 0.125;
35  const double kDiacriticXPadRatio = 7.0;
36  const double kDiacriticYPadRatio = 1.75;
37  const double kMinDiacriticSizeRatio = 1.0625;
38  const double kMaxDiacriticDistanceRatio = 1.25;
39  const double kMaxDiacriticGapToBaseCharHeight = 1.0;
40  const int kLineTrapLongest = 4;
41  const int kLineTrapShortest = 2;
42  const int kMostlyOneDirRatio = 3;
43  const double kLineResidueAspectRatio = 8.0;
44  const int kLineResiduePadRatio = 3;
45  const double kLineResidueSizeRatio = 1.75;
46  const float kSizeRatioToReject = 2.0;
47  const double kNeighbourSearchFactor = 2.5;
48  const double kNoiseOverlapGrowthFactor = 4.0;
49  const double kNoiseOverlapAreaFactor = 1.0 / 512;
50  StrokeWidth::StrokeWidth(int gridsize, const ICOORD &bleft, const ICOORD &tright)
51      : BlobGrid(gridsize, bleft, tright)
52      , nontext_map_(nullptr)
53      , projection_(nullptr)
54      , denorm_(nullptr)
55      , grid_box_(bleft, tright)
56      , rerotation_(1.0f, 0.0f) {
57  }
58  StrokeWidth::~StrokeWidth() {
59  #ifndef GRAPHICS_DISABLED
60    if (widths_win_ != nullptr) {
61      widths_win_->AwaitEvent(SVET_DESTROY);
62      if (textord_tabfind_only_strokewidths) {
63        exit(0);
64      }
65      delete widths_win_;
66    }
67    delete leaders_win_;
68    delete initial_widths_win_;
69    delete chains_win_;
70    delete textlines_win_;
71    delete smoothed_win_;
72    delete diacritics_win_;
73  #endif
74  }
75  void StrokeWidth::SetNeighboursOnMediumBlobs(TO_BLOCK *block) {
76    InsertBlobList(&block->blobs);
77    BLOBNBOX_IT blob_it(&block->blobs);
78    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
79      SetNeighbours(false, false, blob_it.data());
80    }
81    Clear();
82  }
83  void StrokeWidth::FindTextlineDirectionAndFixBrokenCJK(PageSegMode pageseg_mode, bool cjk_merge,
84                                                         TO_BLOCK *input_block) {
85    InsertBlobs(input_block);
86    while (cjk_merge && FixBrokenCJK(input_block)) {
87    }
88    FindTextlineFlowDirection(pageseg_mode, false);
89    Clear();
90  }
91  static void CollectHorizVertBlobs(BLOBNBOX_LIST *input_blobs, int *num_vertical_blobs,
92                                    int *num_horizontal_blobs, BLOBNBOX_CLIST *vertical_blobs,
93                                    BLOBNBOX_CLIST *horizontal_blobs,
94                                    BLOBNBOX_CLIST *nondescript_blobs) {
95    BLOBNBOX_C_IT v_it(vertical_blobs);
96    BLOBNBOX_C_IT h_it(horizontal_blobs);
97    BLOBNBOX_C_IT n_it(nondescript_blobs);
98    BLOBNBOX_IT blob_it(input_blobs);
<span onclick='openModal()' class='match'>99    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
100      BLOBNBOX *blob = blob_it.data();
101      const TBOX &box = blob->bounding_box();
102      float y_x = static_cast<float>(box.height()) / box.width();
</span>103      float x_y = 1.0f / y_x;
104      float ratio = x_y > y_x ? x_y : y_x;
105      bool ok_blob = ratio <= kSizeRatioToReject;
106      if (blob->UniquelyVertical()) {
107        ++*num_vertical_blobs;
108        if (ok_blob) {
109          v_it.add_after_then_move(blob);
110        }
111      } else if (blob->UniquelyHorizontal()) {
112        ++*num_horizontal_blobs;
113        if (ok_blob) {
114          h_it.add_after_then_move(blob);
115        }
116      } else if (ok_blob) {
117        n_it.add_after_then_move(blob);
118      }
119    }
120  }
121  bool StrokeWidth::TestVerticalTextDirection(double find_vertical_text_ratio, TO_BLOCK *block,
122                                              BLOBNBOX_CLIST *osd_blobs) {
123    int vertical_boxes = 0;
124    int horizontal_boxes = 0;
125    BLOBNBOX_CLIST vertical_blobs;
126    BLOBNBOX_CLIST horizontal_blobs;
127    BLOBNBOX_CLIST nondescript_blobs;
128    CollectHorizVertBlobs(&block->blobs, &vertical_boxes, &horizontal_boxes, &vertical_blobs,
129                          &horizontal_blobs, &nondescript_blobs);
130    CollectHorizVertBlobs(&block->large_blobs, &vertical_boxes, &horizontal_boxes, &vertical_blobs,
131                          &horizontal_blobs, &nondescript_blobs);
132    if (textord_debug_tabfind) {
133      tprintf("TextDir hbox=%d vs vbox=%d, %dH, %dV, %dN osd blobs\n", horizontal_boxes,
134              vertical_boxes, horizontal_blobs.length(), vertical_blobs.length(),
135              nondescript_blobs.length());
136    }
137    if (osd_blobs != nullptr && vertical_boxes == 0 && horizontal_boxes == 0) {
138      BLOBNBOX_C_IT osd_it(osd_blobs);
139      osd_it.add_list_after(&nondescript_blobs);
140      return false;
141    }
142    int min_vert_boxes =
143        static_cast<int>((vertical_boxes + horizontal_boxes) * find_vertical_text_ratio);
144    if (vertical_boxes >= min_vert_boxes) {
145      if (osd_blobs != nullptr) {
146        BLOBNBOX_C_IT osd_it(osd_blobs);
147        osd_it.add_list_after(&vertical_blobs);
148      }
149      return true;
150    } else {
151      if (osd_blobs != nullptr) {
152        BLOBNBOX_C_IT osd_it(osd_blobs);
153        osd_it.add_list_after(&horizontal_blobs);
154      }
155      return false;
156    }
157  }
158  void StrokeWidth::CorrectForRotation(const FCOORD &rotation, ColPartitionGrid *part_grid) {
159    Init(part_grid->gridsize(), part_grid->bleft(), part_grid->tright());
160    grid_box_ = TBOX(bleft(), tright());
161    rerotation_.set_x(rotation.x());
162    rerotation_.set_y(-rotation.y());
163  }
164  void StrokeWidth::FindLeaderPartitions(TO_BLOCK *block, ColPartitionGrid *part_grid) {
165    Clear();
166    ColPartition_LIST leader_parts;
167    FindLeadersAndMarkNoise(block, &leader_parts);
168    InsertBlobList(&block->blobs);
169    for (ColPartition_IT it(&leader_parts); !it.empty(); it.forward()) {
170      ColPartition *part = it.extract();
171      part->ClaimBoxes();
172      MarkLeaderNeighbours(part, LR_LEFT);
173      MarkLeaderNeighbours(part, LR_RIGHT);
174      part_grid->InsertBBox(true, true, part);
175    }
176  }
177  void StrokeWidth::RemoveLineResidue(ColPartition_LIST *big_part_list) {
178    BlobGridSearch gsearch(this);
179    BLOBNBOX *bbox;
180    gsearch.StartFullSearch();
181    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
182      TBOX box = bbox->bounding_box();
183      if (box.height() < box.width() * kLineResidueAspectRatio) {
184        continue;
185      }
186      int padding = box.height() * kLineResiduePadRatio;
187      TBOX search_box = box;
188      search_box.pad(padding, padding);
189      bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
190      BlobGridSearch rsearch(this);
191      int max_height = 0;
192      BLOBNBOX *n;
193      rsearch.StartRectSearch(search_box);
194      while ((n = rsearch.NextRectSearch()) != nullptr) {
195        if (n == bbox) {
196          continue;
197        }
198        TBOX nbox = n->bounding_box();
199        if (nbox.height() > max_height) {
200          max_height = nbox.height();
201        }
202      }
203      if (debug) {
204        tprintf("Max neighbour size=%d for candidate line box at:", max_height);
205        box.print();
206      }
207      if (max_height * kLineResidueSizeRatio < box.height()) {
208  #ifndef GRAPHICS_DISABLED
209        if (leaders_win_ != nullptr) {
210          leaders_win_->Pen(ScrollView::PINK);
211          leaders_win_->Rectangle(box.left(), box.bottom(), box.right(), box.top());
212        }
213  #endif 
214        ColPartition::MakeBigPartition(bbox, big_part_list);
215      }
216    }
217  }
218  void StrokeWidth::GradeBlobsIntoPartitions(PageSegMode pageseg_mode, const FCOORD &rerotation,
219                                             TO_BLOCK *block, Image nontext_pix, const DENORM *denorm,
220                                             bool cjk_script, TextlineProjection *projection,
221                                             BLOBNBOX_LIST *diacritic_blobs,
222                                             ColPartitionGrid *part_grid,
223                                             ColPartition_LIST *big_parts) {
224    nontext_map_ = nontext_pix;
225    projection_ = projection;
226    denorm_ = denorm;
227    Clear();
228    InsertBlobs(block);
229    if (cjk_script) {
230      FixBrokenCJK(block);
231    }
232    FindTextlineFlowDirection(pageseg_mode, false);
233    projection_->ConstructProjection(block, rerotation, nontext_map_);
234  #ifndef GRAPHICS_DISABLED
235    if (textord_tabfind_show_strokewidths) {
236      ScrollView *line_blobs_win = MakeWindow(0, 0, "Initial textline Blobs");
237      projection_->PlotGradedBlobs(&block->blobs, line_blobs_win);
238      projection_->PlotGradedBlobs(&block->small_blobs, line_blobs_win);
239    }
240  #endif
241    projection_->MoveNonTextlineBlobs(&block->blobs, &block->noise_blobs);
242    projection_->MoveNonTextlineBlobs(&block->small_blobs, &block->noise_blobs);
243    Clear();
244    InsertBlobs(block);
245    FCOORD skew;
246    FindTextlineFlowDirection(pageseg_mode, true);
247    PartitionFindResult r = FindInitialPartitions(pageseg_mode, rerotation, true, block,
248                                                  diacritic_blobs, part_grid, big_parts, &skew);
249    if (r == PFR_NOISE) {
250      tprintf("Detected %d diacritics\n", diacritic_blobs->length());
251      Clear();
252      InsertBlobs(block);
253      FindTextlineFlowDirection(pageseg_mode, true);
254      r = FindInitialPartitions(pageseg_mode, rerotation, false, block, diacritic_blobs, part_grid,
255                                big_parts, &skew);
256    }
257    nontext_map_ = nullptr;
258    projection_ = nullptr;
259    denorm_ = nullptr;
260  }
261  static void PrintBoxWidths(BLOBNBOX *neighbour) {
262    const TBOX &nbox = neighbour->bounding_box();
263    tprintf("Box (%d,%d)->(%d,%d): h-width=%.1f, v-width=%.1f p-width=%1.f\n", nbox.left(),
264            nbox.bottom(), nbox.right(), nbox.top(), neighbour->horz_stroke_width(),
265            neighbour->vert_stroke_width(),
266            2.0 * neighbour->cblob()->area() / neighbour->cblob()->perimeter());
267  }
268  void StrokeWidth::HandleClick(int x, int y) {
269    BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>::HandleClick(x, y);
270    BlobGridSearch radsearch(this);
271    radsearch.StartRadSearch(x, y, 1);
272    BLOBNBOX *neighbour;
273    FCOORD click(static_cast<float>(x), static_cast<float>(y));
274    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
275      TBOX nbox = neighbour->bounding_box();
276      if (nbox.contains(click) && neighbour->cblob() != nullptr) {
277        PrintBoxWidths(neighbour);
278        if (neighbour->neighbour(BND_LEFT) != nullptr) {
279          PrintBoxWidths(neighbour->neighbour(BND_LEFT));
280        }
281        if (neighbour->neighbour(BND_RIGHT) != nullptr) {
282          PrintBoxWidths(neighbour->neighbour(BND_RIGHT));
283        }
284        if (neighbour->neighbour(BND_ABOVE) != nullptr) {
285          PrintBoxWidths(neighbour->neighbour(BND_ABOVE));
286        }
287        if (neighbour->neighbour(BND_BELOW) != nullptr) {
288          PrintBoxWidths(neighbour->neighbour(BND_BELOW));
289        }
290        int gaps[BND_COUNT];
291        neighbour->NeighbourGaps(gaps);
292        tprintf(
293            "Left gap=%d, right=%d, above=%d, below=%d, horz=%d, vert=%d\n"
294            "Good=    %d        %d        %d        %d\n",
295            gaps[BND_LEFT], gaps[BND_RIGHT], gaps[BND_ABOVE], gaps[BND_BELOW],
296            neighbour->horz_possible(), neighbour->vert_possible(),
297            neighbour->good_stroke_neighbour(BND_LEFT), neighbour->good_stroke_neighbour(BND_RIGHT),
298            neighbour->good_stroke_neighbour(BND_ABOVE), neighbour->good_stroke_neighbour(BND_BELOW));
299        break;
300      }
301    }
302  }
303  void StrokeWidth::FindLeadersAndMarkNoise(TO_BLOCK *block, ColPartition_LIST *leader_parts) {
304    InsertBlobList(&block->small_blobs);
305    InsertBlobList(&block->noise_blobs);
306    BlobGridSearch gsearch(this);
307    BLOBNBOX *bbox;
308    gsearch.StartFullSearch();
309    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
310      SetNeighbours(true, false, bbox);
311    }
312    ColPartition_IT part_it(leader_parts);
313    gsearch.StartFullSearch();
314    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
315      if (bbox->flow() == BTFT_NONE) {
316        if (bbox->neighbour(BND_RIGHT) == nullptr && bbox->neighbour(BND_LEFT) == nullptr) {
317          continue;
318        }
319        auto *part = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
320        BLOBNBOX *blob;
321        for (blob = bbox; blob != nullptr && blob->flow() == BTFT_NONE;
322             blob = blob->neighbour(BND_RIGHT)) {
323          part->AddBox(blob);
324        }
325        for (blob = bbox->neighbour(BND_LEFT); blob != nullptr && blob->flow() == BTFT_NONE;
326             blob = blob->neighbour(BND_LEFT)) {
327          part->AddBox(blob);
328        }
329        if (part->MarkAsLeaderIfMonospaced()) {
330          part_it.add_after_then_move(part);
331        } else {
332          delete part;
333        }
334      }
335    }
336  #ifndef GRAPHICS_DISABLED
337    if (textord_tabfind_show_strokewidths) {
338      leaders_win_ = DisplayGoodBlobs("LeaderNeighbours", 0, 0);
339    }
340  #endif
341    BLOBNBOX_IT blob_it(&block->blobs);
342    BLOBNBOX_IT small_it(&block->small_blobs);
343    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
344      BLOBNBOX *blob = small_it.data();
345      if (blob->flow() != BTFT_LEADER) {
346        if (blob->flow() == BTFT_NEIGHBOURS) {
347          blob->set_flow(BTFT_NONE);
348        }
349        blob->ClearNeighbours();
350        blob_it.add_to_end(small_it.extract());
351      }
352    }
353    BLOBNBOX_IT noise_it(&block->noise_blobs);
354    for (noise_it.mark_cycle_pt(); !noise_it.cycled_list(); noise_it.forward()) {
355      BLOBNBOX *blob = noise_it.data();
356      if (blob->flow() == BTFT_LEADER || blob->joined_to_prev()) {
357        small_it.add_to_end(noise_it.extract());
358      } else if (blob->flow() == BTFT_NEIGHBOURS) {
359        blob->set_flow(BTFT_NONE);
360        blob->ClearNeighbours();
361      }
362    }
363    Clear();
364  }
365  void StrokeWidth::InsertBlobs(TO_BLOCK *block) {
366    InsertBlobList(&block->blobs);
367    InsertBlobList(&block->large_blobs);
368  }
369  void StrokeWidth::MarkLeaderNeighbours(const ColPartition *part, LeftOrRight side) {
370    const TBOX &part_box = part->bounding_box();
371    BlobGridSearch blobsearch(this);
372    BLOBNBOX *best_blob = nullptr;
373    int best_gap = 0;
374    blobsearch.StartSideSearch(side == LR_LEFT ? part_box.left() : part_box.right(),
375                               part_box.bottom(), part_box.top());
376    BLOBNBOX *blob;
377    while ((blob = blobsearch.NextSideSearch(side == LR_LEFT)) != nullptr) {
378      const TBOX &blob_box = blob->bounding_box();
379      if (!blob_box.y_overlap(part_box)) {
380        continue;
381      }
382      int x_gap = blob_box.x_gap(part_box);
383      if (x_gap > 2 * gridsize()) {
384        break;
385      } else if (best_blob == nullptr || x_gap < best_gap) {
386        best_blob = blob;
387        best_gap = x_gap;
388      }
389    }
390    if (best_blob != nullptr) {
391      if (side == LR_LEFT) {
392        best_blob->set_leader_on_right(true);
393      } else {
394        best_blob->set_leader_on_left(true);
395      }
396  #ifndef GRAPHICS_DISABLED
397      if (leaders_win_ != nullptr) {
398        leaders_win_->Pen(side == LR_LEFT ? ScrollView::RED : ScrollView::GREEN);
399        const TBOX &blob_box = best_blob->bounding_box();
400        leaders_win_->Rectangle(blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
401      }
402  #endif 
403    }
404  }
405  static int UpperQuartileCJKSize(int gridsize, BLOBNBOX_LIST *blobs) {
406    STATS sizes(0, gridsize * kMaxCJKSizeRatio - 1);
407    BLOBNBOX_IT it(blobs);
408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
409      BLOBNBOX *blob = it.data();
410      int width = blob->bounding_box().width();
411      int height = blob->bounding_box().height();
412      if (width <= height * kCJKAspectRatio && height < width * kCJKAspectRatio) {
413        sizes.add(height, 1);
414      }
415    }
416    return static_cast<int>(sizes.ile(0.75f) + 0.5);
417  }
418  bool StrokeWidth::FixBrokenCJK(TO_BLOCK *block) {
419    BLOBNBOX_LIST *blobs = &block->blobs;
420    int median_height = UpperQuartileCJKSize(gridsize(), blobs);
421    int max_dist = static_cast<int>(median_height * kCJKBrokenDistanceFraction);
422    int max_height = static_cast<int>(median_height * kCJKAspectRatio);
423    int num_fixed = 0;
424    BLOBNBOX_IT blob_it(blobs);
425    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
426      BLOBNBOX *blob = blob_it.data();
427      if (blob->cblob() == nullptr || blob->cblob()->out_list()->empty()) {
428        continue;
429      }
430      TBOX bbox = blob->bounding_box();
431      bool debug = AlignedBlob::WithinTestRegion(3, bbox.left(), bbox.bottom());
432      if (debug) {
433        tprintf("Checking for Broken CJK (max size=%d):", max_height);
434        bbox.print();
435      }
436      BLOBNBOX_CLIST overlapped_blobs;
437      AccumulateOverlaps(blob, debug, max_height, max_dist, &bbox, &overlapped_blobs);
438      if (!overlapped_blobs.empty()) {
439        if (bbox.width() > bbox.height() * kCJKAspectRatio ||
440            bbox.height() > bbox.width() * kCJKAspectRatio) {
441          if (debug) {
442            tprintf("Bad final aspectratio:");
443            bbox.print();
444          }
445          continue;
446        }
447        if (overlapped_blobs.length() >= kCJKMaxComponents) {
448          if (debug) {
449            tprintf("Too many neighbours: %d\n", overlapped_blobs.length());
450          }
451          continue;
452        }
453        BLOBNBOX_C_IT n_it(&overlapped_blobs);
454        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
455          BLOBNBOX *neighbour = nullptr;
456          neighbour = n_it.data();
457          if (!blob->MatchingStrokeWidth(*neighbour, kStrokeWidthFractionCJK, kStrokeWidthCJK)) {
458            break;
459          }
460        }
461        if (!n_it.cycled_list()) {
462          if (debug) {
463            tprintf("Bad stroke widths:");
464            PrintBoxWidths(blob);
465          }
466          continue; 
467        }
468        RemoveBBox(blob);
469        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
470          BLOBNBOX *neighbour = n_it.data();
471          RemoveBBox(neighbour);
472          neighbour->set_region_type(BRT_NOISE);
473          blob->really_merge(neighbour);
474          if (rerotation_.x() != 1.0f || rerotation_.y() != 0.0f) {
475            blob->rotate_box(rerotation_);
476          }
477        }
478        InsertBBox(true, true, blob);
479        ++num_fixed;
480        if (debug) {
481          tprintf("Done! Final box:");
482          bbox.print();
483        }
484      }
485    }
486    int num_remaining = 0;
487    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
488      BLOBNBOX *blob = blob_it.data();
489      if (blob->cblob() != nullptr && !blob->cblob()->out_list()->empty()) {
490        ++num_remaining;
491      }
492    }
493    block->DeleteUnownedNoise();
494    return num_fixed > num_remaining * kBrokenCJKIterationFraction;
495  }
496  static bool AcceptableCJKMerge(const TBOX &bbox, const TBOX &nbox, bool debug, int max_size,
497                                 int max_dist, int *x_gap, int *y_gap) {
498    *x_gap = bbox.x_gap(nbox);
499    *y_gap = bbox.y_gap(nbox);
500    TBOX merged(nbox);
501    merged += bbox;
502    if (debug) {
503      tprintf("gaps = %d, %d, merged_box:", *x_gap, *y_gap);
504      merged.print();
505    }
506    if (*x_gap <= max_dist && *y_gap <= max_dist && merged.width() <= max_size &&
507        merged.height() <= max_size) {
508      double old_ratio = static_cast<double>(bbox.width()) / bbox.height();
509      if (old_ratio < 1.0) {
510        old_ratio = 1.0 / old_ratio;
511      }
512      double new_ratio = static_cast<double>(merged.width()) / merged.height();
513      if (new_ratio < 1.0) {
514        new_ratio = 1.0 / new_ratio;
515      }
516      if (new_ratio <= old_ratio * kCJKAspectRatioIncrease) {
517        return true;
518      }
519    }
520    return false;
521  }
522  void StrokeWidth::AccumulateOverlaps(const BLOBNBOX *not_this, bool debug, int max_size,
523                                       int max_dist, TBOX *bbox, BLOBNBOX_CLIST *blobs) {
524    BLOBNBOX *nearests[BND_COUNT];
525    for (auto &nearest : nearests) {
526      nearest = nullptr;
527    }
528    int x = (bbox->left() + bbox->right()) / 2;
529    int y = (bbox->bottom() + bbox->top()) / 2;
530    BlobGridSearch radsearch(this);
531    radsearch.StartRadSearch(x, y, kCJKRadius);
532    BLOBNBOX *neighbour;
533    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
534      if (neighbour == not_this) {
535        continue;
536      }
537      TBOX nbox = neighbour->bounding_box();
538      int x_gap, y_gap;
539      if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &x_gap, &y_gap)) {
540        *bbox += nbox;
541        blobs->add_sorted(SortByBoxLeft<BLOBNBOX>, true, neighbour);
542        if (debug) {
543          tprintf("Added:");
544          nbox.print();
545        }
546        for (int dir = 0; dir < BND_COUNT; ++dir) {
547          if (nearests[dir] == nullptr) {
548            continue;
549          }
550          nbox = nearests[dir]->bounding_box();
551          if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &x_gap, &y_gap)) {
552            *bbox += nbox;
553            blobs->add_sorted(SortByBoxLeft<BLOBNBOX>, true, nearests[dir]);
554            if (debug) {
555              tprintf("Added:");
556              nbox.print();
557            }
558            nearests[dir] = nullptr;
559            dir = -1; 
560          }
561        }
562      } else if (x_gap < 0 && x_gap <= y_gap) {
563        BlobNeighbourDir dir = nbox.top() > bbox->top() ? BND_ABOVE : BND_BELOW;
564        if (nearests[dir] == nullptr || y_gap < bbox->y_gap(nearests[dir]->bounding_box())) {
565          nearests[dir] = neighbour;
566        }
567      } else if (y_gap < 0 && y_gap <= x_gap) {
568        BlobNeighbourDir dir = nbox.left() > bbox->left() ? BND_RIGHT : BND_LEFT;
569        if (nearests[dir] == nullptr || x_gap < bbox->x_gap(nearests[dir]->bounding_box())) {
570          nearests[dir] = neighbour;
571        }
572      }
573      if (nearests[BND_LEFT] && nearests[BND_RIGHT] && nearests[BND_ABOVE] && nearests[BND_BELOW]) {
574        break;
575      }
576    }
577    for (auto &nearest : nearests) {
578      if (nearest == nullptr) {
579        continue;
580      }
581      const TBOX &nbox = nearest->bounding_box();
582      if (debug) {
583        tprintf("Testing for overlap with:");
584        nbox.print();
585      }
586      if (bbox->overlap(nbox)) {
587        blobs->shallow_clear();
588        if (debug) {
589          tprintf("Final box overlaps nearest\n");
590        }
591        return;
592      }
593    }
594  }
595  void StrokeWidth::FindTextlineFlowDirection(PageSegMode pageseg_mode, bool display_if_debugging) {
596    BlobGridSearch gsearch(this);
597    BLOBNBOX *bbox;
598    gsearch.StartFullSearch();
599    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
600      SetNeighbours(false, display_if_debugging, bbox);
601    }
602    gsearch.StartFullSearch();
603    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
604      SimplifyObviousNeighbours(bbox);
605    }
606    gsearch.StartFullSearch();
607    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
608      if (FindingVerticalOnly(pageseg_mode)) {
609        bbox->set_vert_possible(true);
610        bbox->set_horz_possible(false);
611      } else if (FindingHorizontalOnly(pageseg_mode)) {
612        bbox->set_vert_possible(false);
613        bbox->set_horz_possible(true);
614      } else {
615        SetNeighbourFlows(bbox);
616      }
617    }
618  #ifndef GRAPHICS_DISABLED
619    if ((textord_tabfind_show_strokewidths && display_if_debugging) ||
620        textord_tabfind_show_strokewidths > 1) {
621      initial_widths_win_ = DisplayGoodBlobs("InitialStrokewidths", 400, 0);
622    }
623  #endif
624    gsearch.StartFullSearch();
625    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
626      SmoothNeighbourTypes(pageseg_mode, false, bbox);
627    }
628    gsearch.StartFullSearch();
629    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
630      SmoothNeighbourTypes(pageseg_mode, true, bbox);
631    }
632    gsearch.StartFullSearch();
633    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
634      SmoothNeighbourTypes(pageseg_mode, true, bbox);
635    }
636  #ifndef GRAPHICS_DISABLED
637    if ((textord_tabfind_show_strokewidths && display_if_debugging) ||
638        textord_tabfind_show_strokewidths > 1) {
639      widths_win_ = DisplayGoodBlobs("ImprovedStrokewidths", 800, 0);
640    }
641  #endif
642  }
643  void StrokeWidth::SetNeighbours(bool leaders, bool activate_line_trap, BLOBNBOX *blob) {
644    int line_trap_count = 0;
645    for (int dir = 0; dir < BND_COUNT; ++dir) {
646      auto bnd = static_cast<BlobNeighbourDir>(dir);
647      line_trap_count += FindGoodNeighbour(bnd, leaders, blob);
648    }
649    if (line_trap_count > 0 && activate_line_trap) {
650      blob->ClearNeighbours();
651      const TBOX &box = blob->bounding_box();
652      blob->set_region_type(box.width() > box.height() ? BRT_HLINE : BRT_VLINE);
653    }
654  }
655  int StrokeWidth::FindGoodNeighbour(BlobNeighbourDir dir, bool leaders, BLOBNBOX *blob) {
656    TBOX blob_box = blob->bounding_box();
657    bool debug = AlignedBlob::WithinTestRegion(2, blob_box.left(), blob_box.bottom());
658    if (debug) {
659      tprintf("FGN in dir %d for blob:", dir);
660      blob_box.print();
661    }
662    int top = blob_box.top();
663    int bottom = blob_box.bottom();
664    int left = blob_box.left();
665    int right = blob_box.right();
666    int width = right - left;
667    int height = top - bottom;
668    int line_trap_max = std::max(width, height) / kLineTrapLongest;
669    int line_trap_min = std::min(width, height) * kLineTrapShortest;
670    int line_trap_count = 0;
671    int min_good_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 2 : width / 2;
672    int min_decent_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 3 : width / 3;
673    if (leaders) {
674      min_good_overlap = min_decent_overlap = 1;
675    }
676    int search_pad =
677        static_cast<int>(sqrt(static_cast<double>(width * height)) * kNeighbourSearchFactor);
678    if (gridsize() > search_pad) {
679      search_pad = gridsize();
680    }
681    TBOX search_box = blob_box;
682    switch (dir) {
683      case BND_LEFT:
684        search_box.set_left(search_box.left() - search_pad);
685        break;
686      case BND_RIGHT:
687        search_box.set_right(search_box.right() + search_pad);
688        break;
689      case BND_BELOW:
690        search_box.set_bottom(search_box.bottom() - search_pad);
691        break;
692      case BND_ABOVE:
693        search_box.set_top(search_box.top() + search_pad);
694        break;
695      case BND_COUNT:
696        return 0;
697    }
698    BlobGridSearch rectsearch(this);
699    rectsearch.StartRectSearch(search_box);
700    BLOBNBOX *best_neighbour = nullptr;
701    double best_goodness = 0.0;
702    bool best_is_good = false;
703    BLOBNBOX *neighbour;
704    while ((neighbour = rectsearch.NextRectSearch()) != nullptr) {
705      TBOX nbox = neighbour->bounding_box();
706      if (neighbour == blob) {
707        continue;
708      }
709      int mid_x = (nbox.left() + nbox.right()) / 2;
710      if (mid_x < blob->left_rule() || mid_x > blob->right_rule()) {
711        continue; 
712      }
713      if (debug) {
714        tprintf("Neighbour at:");
715        nbox.print();
716      }
717      int n_width = nbox.width();
718      int n_height = nbox.height();
719      if (std::min(n_width, n_height) > line_trap_min &&
720          std::max(n_width, n_height) < line_trap_max) {
721        ++line_trap_count;
722      }
723      if (TabFind::VeryDifferentSizes(std::max(n_width, n_height), std::max(width, height)) &&
724          (((dir == BND_LEFT || dir == BND_RIGHT) && TabFind::DifferentSizes(n_height, height)) ||
725           ((dir == BND_BELOW || dir == BND_ABOVE) && TabFind::DifferentSizes(n_width, width)))) {
726        if (debug) {
727          tprintf("Bad size\n");
728        }
729        continue; 
730      }
731      int overlap;
732      int perp_overlap;
733      int gap;
734      if (dir == BND_LEFT || dir == BND_RIGHT) {
735        overlap = std::min(static_cast<int>(nbox.top()), top) -
736                  std::max(static_cast<int>(nbox.bottom()), bottom);
737        if (overlap == nbox.height() && nbox.width() > nbox.height()) {
738          perp_overlap = nbox.width();
739        } else {
740          perp_overlap = overlap;
741        }
742        gap = dir == BND_LEFT ? left - nbox.left() : nbox.right() - right;
743        if (gap <= 0) {
744          if (debug) {
745            tprintf("On wrong side\n");
746          }
747          continue; 
748        }
749        gap -= n_width;
750      } else {
751        overlap = std::min(static_cast<int>(nbox.right()), right) -
752                  std::max(static_cast<int>(nbox.left()), left);
753        if (overlap == nbox.width() && nbox.height() > nbox.width()) {
754          perp_overlap = nbox.height();
755        } else {
756          perp_overlap = overlap;
757        }
758        gap = dir == BND_BELOW ? bottom - nbox.bottom() : nbox.top() - top;
759        if (gap <= 0) {
760          if (debug) {
761            tprintf("On wrong side\n");
762          }
763          continue; 
764        }
765        gap -= n_height;
766      }
767      if (-gap > overlap) {
768        if (debug) {
769          tprintf("Overlaps wrong way\n");
770        }
771        continue; 
772      }
773      if (perp_overlap < min_decent_overlap) {
774        if (debug) {
775          tprintf("Doesn't overlap enough\n");
776        }
777        continue; 
778      }
779      bool bad_sizes =
780          TabFind::DifferentSizes(height, n_height) && TabFind::DifferentSizes(width, n_width);
781      bool is_good =
782          overlap >= min_good_overlap && !bad_sizes &&
783          blob->MatchingStrokeWidth(*neighbour, kStrokeWidthFractionTolerance, kStrokeWidthTolerance);
784      if (gap < 1) {
785        gap = 1;
786      }
787      double goodness = (1.0 + is_good) * overlap / gap;
788      if (debug) {
789        tprintf("goodness = %g vs best of %g, good=%d, overlap=%d, gap=%d\n", goodness, best_goodness,
790                is_good, overlap, gap);
791      }
792      if (goodness > best_goodness) {
793        best_neighbour = neighbour;
794        best_goodness = goodness;
795        best_is_good = is_good;
796      }
797    }
798    blob->set_neighbour(dir, best_neighbour, best_is_good);
799    return line_trap_count;
800  }
801  static void ListNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
802    for (int dir = 0; dir < BND_COUNT; ++dir) {
803      auto bnd = static_cast<BlobNeighbourDir>(dir);
804      BLOBNBOX *neighbour = blob->neighbour(bnd);
805      if (neighbour != nullptr) {
806        neighbours->add_sorted(SortByBoxLeft<BLOBNBOX>, true, neighbour);
807      }
808    }
809  }
810  static void List2ndNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
811    ListNeighbours(blob, neighbours);
812    for (int dir = 0; dir < BND_COUNT; ++dir) {
813      auto bnd = static_cast<BlobNeighbourDir>(dir);
814      BLOBNBOX *neighbour = blob->neighbour(bnd);
815      if (neighbour != nullptr) {
816        ListNeighbours(neighbour, neighbours);
817      }
818    }
819  }
820  static void List3rdNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
821    List2ndNeighbours(blob, neighbours);
822    for (int dir = 0; dir < BND_COUNT; ++dir) {
823      auto bnd = static_cast<BlobNeighbourDir>(dir);
824      BLOBNBOX *neighbour = blob->neighbour(bnd);
825      if (neighbour != nullptr) {
826        List2ndNeighbours(neighbour, neighbours);
827      }
828    }
829  }
830  static void CountNeighbourGaps(bool debug, BLOBNBOX_CLIST *neighbours, int *pure_h_count,
831                                 int *pure_v_count) {
832    if (neighbours->length() <= kMostlyOneDirRatio) {
833      return;
834    }
835    BLOBNBOX_C_IT it(neighbours);
836    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
837      BLOBNBOX *blob = it.data();
838      int h_min, h_max, v_min, v_max;
839      blob->MinMaxGapsClipped(&h_min, &h_max, &v_min, &v_max);
840      if (debug) {
841        tprintf("Hgaps [%d,%d], vgaps [%d,%d]:", h_min, h_max, v_min, v_max);
842      }
843      if (h_max < v_min || blob->leader_on_left() || blob->leader_on_right()) {
844        ++*pure_h_count;
845        if (debug) {
846          tprintf("Horz at:");
847        }
848      } else if (v_max < h_min) {
849        ++*pure_v_count;
850        if (debug) {
851          tprintf("Vert at:");
852        }
853      } else {
854        if (debug) {
855          tprintf("Neither at:");
856        }
857      }
858      if (debug) {
859        blob->bounding_box().print();
860      }
861    }
862  }
863  void StrokeWidth::SetNeighbourFlows(BLOBNBOX *blob) {
864    if (blob->DefiniteIndividualFlow()) {
865      return;
866    }
867    bool debug =
868        AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(), blob->bounding_box().bottom());
869    if (debug) {
870      tprintf("SetNeighbourFlows (current flow=%d, type=%d) on:", blob->flow(), blob->region_type());
871      blob->bounding_box().print();
872    }
873    BLOBNBOX_CLIST neighbours;
874    List3rdNeighbours(blob, &neighbours);
875    int pure_h_count = 0;
876    int pure_v_count = 0;
877    CountNeighbourGaps(debug, &neighbours, &pure_h_count, &pure_v_count);
878    if (debug) {
879      HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
880      tprintf("SetFlows: h_count=%d, v_count=%d\n", pure_h_count, pure_v_count);
881    }
882    if (!neighbours.empty()) {
883      blob->set_vert_possible(true);
884      blob->set_horz_possible(true);
885      if (pure_h_count > 2 * pure_v_count) {
886        blob->set_vert_possible(false);
887      } else if (pure_v_count > 2 * pure_h_count) {
888        blob->set_horz_possible(false);
889      }
890    } else {
891      blob->set_vert_possible(false);
892      blob->set_horz_possible(false);
893    }
894  }
895  static void CountNeighbourTypes(BLOBNBOX_CLIST *neighbours, int *pure_h_count, int *pure_v_count) {
896    BLOBNBOX_C_IT it(neighbours);
897    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
898      BLOBNBOX *blob = it.data();
899      if (blob->UniquelyHorizontal()) {
900        ++*pure_h_count;
901      }
902      if (blob->UniquelyVertical()) {
903        ++*pure_v_count;
904      }
905    }
906  }
907  void StrokeWidth::SimplifyObviousNeighbours(BLOBNBOX *blob) {
908    if ((blob->bounding_box().width() > 3 * blob->area_stroke_width() &&
909         blob->bounding_box().height() > 3 * blob->area_stroke_width())) {
910      if (blob->bounding_box().width() > 4 * blob->bounding_box().height()) {
911        blob->set_neighbour(BND_ABOVE, nullptr, false);
912        blob->set_neighbour(BND_BELOW, nullptr, false);
913        return;
914      }
915      if (blob->bounding_box().height() > 4 * blob->bounding_box().width()) {
916        blob->set_neighbour(BND_LEFT, nullptr, false);
917        blob->set_neighbour(BND_RIGHT, nullptr, false);
918        return;
919      }
920    }
921    int margin = gridsize() / 2;
922    int h_min, h_max, v_min, v_max;
923    blob->MinMaxGapsClipped(&h_min, &h_max, &v_min, &v_max);
924    if ((h_max + margin < v_min && h_max < margin / 2) || blob->leader_on_left() ||
925        blob->leader_on_right()) {
926      blob->set_neighbour(BND_ABOVE, nullptr, false);
927      blob->set_neighbour(BND_BELOW, nullptr, false);
928    } else if (v_max + margin < h_min && v_max < margin / 2) {
929      blob->set_neighbour(BND_LEFT, nullptr, false);
930      blob->set_neighbour(BND_RIGHT, nullptr, false);
931    }
932  }
933  void StrokeWidth::SmoothNeighbourTypes(PageSegMode pageseg_mode, bool reset_all, BLOBNBOX *blob) {
934    if ((blob->vert_possible() && blob->horz_possible()) || reset_all) {
935      BLOBNBOX_CLIST neighbours;
936      List2ndNeighbours(blob, &neighbours);
937      int pure_h_count = 0;
938      int pure_v_count = 0;
939      CountNeighbourTypes(&neighbours, &pure_h_count, &pure_v_count);
940      if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
941                                        blob->bounding_box().bottom())) {
942        HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
943        tprintf("pure_h=%d, pure_v=%d\n", pure_h_count, pure_v_count);
944      }
945      if (pure_h_count > pure_v_count && !FindingVerticalOnly(pageseg_mode)) {
946        blob->set_vert_possible(false);
947        blob->set_horz_possible(true);
948      } else if (pure_v_count > pure_h_count && !FindingHorizontalOnly(pageseg_mode)) {
949        blob->set_horz_possible(false);
950        blob->set_vert_possible(true);
951      }
952    } else if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
953                                             blob->bounding_box().bottom())) {
954      HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
955      tprintf("Clean on pass 3!\n");
956    }
957  }
958  PartitionFindResult StrokeWidth::FindInitialPartitions(
959      PageSegMode pageseg_mode, const FCOORD &rerotation, bool find_problems, TO_BLOCK *block,
960      BLOBNBOX_LIST *diacritic_blobs, ColPartitionGrid *part_grid, ColPartition_LIST *big_parts,
961      FCOORD *skew_angle) {
962    if (!FindingHorizontalOnly(pageseg_mode)) {
963      FindVerticalTextChains(part_grid);
964    }
965    if (!FindingVerticalOnly(pageseg_mode)) {
966      FindHorizontalTextChains(part_grid);
967    }
968  #ifndef GRAPHICS_DISABLED
969    if (textord_tabfind_show_strokewidths) {
970      chains_win_ = MakeWindow(0, 400, "Initial text chains");
971      part_grid->DisplayBoxes(chains_win_);
972      projection_->DisplayProjection();
973    }
974  #endif
975    if (find_problems) {
976    }
977    part_grid->SplitOverlappingPartitions(big_parts);
978    EasyMerges(part_grid);
979    RemoveLargeUnusedBlobs(block, part_grid, big_parts);
980    TBOX grid_box(bleft(), tright());
981    while (part_grid->GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
982      ;
983    }
984    while (part_grid->GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
985      ;
986    }
987    int pre_overlap = part_grid->ComputeTotalOverlap(nullptr);
988    TestDiacritics(part_grid, block);
989    MergeDiacritics(block, part_grid);
990    if (find_problems && diacritic_blobs != nullptr &&
991        DetectAndRemoveNoise(pre_overlap, grid_box, block, part_grid, diacritic_blobs)) {
992      return PFR_NOISE;
993    }
994  #ifndef GRAPHICS_DISABLED
995    if (textord_tabfind_show_strokewidths) {
996      textlines_win_ = MakeWindow(400, 400, "GoodTextline blobs");
997      part_grid->DisplayBoxes(textlines_win_);
998      diacritics_win_ = DisplayDiacritics("Diacritics", 0, 0, block);
999    }
1000  #endif
1001    PartitionRemainingBlobs(pageseg_mode, part_grid);
1002    part_grid->SplitOverlappingPartitions(big_parts);
1003    EasyMerges(part_grid);
1004    while (part_grid->GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
1005      ;
1006    }
1007    while (part_grid->GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
1008      ;
1009    }
1010    while (part_grid->GridSmoothNeighbours(BTFT_STRONG_CHAIN, nontext_map_, grid_box, rerotation)) {
1011      ;
1012    }
1013  #ifndef GRAPHICS_DISABLED
1014    if (textord_tabfind_show_strokewidths) {
1015      smoothed_win_ = MakeWindow(800, 400, "Smoothed blobs");
1016      part_grid->DisplayBoxes(smoothed_win_);
1017    }
1018  #endif
1019    return PFR_OK;
1020  }
1021  bool StrokeWidth::DetectAndRemoveNoise(int pre_overlap, const TBOX &grid_box, TO_BLOCK *block,
1022                                         ColPartitionGrid *part_grid,
1023                                         BLOBNBOX_LIST *diacritic_blobs) {
1024    ColPartitionGrid *noise_grid = nullptr;
1025    int post_overlap = part_grid->ComputeTotalOverlap(&noise_grid);
1026    if (pre_overlap == 0) {
1027      pre_overlap = 1;
1028    }
1029    BLOBNBOX_IT diacritic_it(diacritic_blobs);
1030    if (noise_grid != nullptr) {
1031      if (post_overlap > pre_overlap * kNoiseOverlapGrowthFactor &&
1032          post_overlap > grid_box.area() * kNoiseOverlapAreaFactor) {
1033  #ifndef GRAPHICS_DISABLED
1034        if (textord_tabfind_show_strokewidths) {
1035          ScrollView *noise_win = MakeWindow(1000, 500, "Noise Areas");
1036          noise_grid->DisplayBoxes(noise_win);
1037        }
1038  #endif
1039        part_grid->DeleteNonLeaderParts();
1040        BLOBNBOX_IT blob_it(&block->noise_blobs);
1041        ColPartitionGridSearch rsearch(noise_grid);
1042        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1043          BLOBNBOX *blob = blob_it.data();
1044          blob->ClearNeighbours();
1045          if (!blob->IsDiacritic() || blob->owner() != nullptr) {
1046            continue; 
1047          }
1048          TBOX search_box(blob->bounding_box());
1049          search_box.pad(gridsize(), gridsize());
1050          rsearch.StartRectSearch(search_box);
1051          ColPartition *part = rsearch.NextRectSearch();
1052          if (part != nullptr) {
1053            blob->set_owns_cblob(true);
1054            blob->compute_bounding_box();
1055            diacritic_it.add_after_then_move(blob_it.extract());
1056          }
1057        }
1058        noise_grid->DeleteParts();
1059        delete noise_grid;
1060        return true;
1061      }
1062      noise_grid->DeleteParts();
1063      delete noise_grid;
1064    }
1065    return false;
1066  }
1067  static BLOBNBOX *MutualUnusedVNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1068    BLOBNBOX *next_blob = blob->neighbour(dir);
1069    if (next_blob == nullptr || next_blob->owner() != nullptr || next_blob->UniquelyHorizontal()) {
1070      return nullptr;
1071    }
1072    if (next_blob->neighbour(DirOtherWay(dir)) == blob) {
1073      return next_blob;
1074    }
1075    return nullptr;
1076  }
1077  void StrokeWidth::FindVerticalTextChains(ColPartitionGrid *part_grid) {
1078    PageSegMode pageseg_mode =
1079        rerotation_.y() == 0.0f ? PSM_SINGLE_BLOCK_VERT_TEXT : PSM_SINGLE_COLUMN;
1080    BlobGridSearch gsearch(this);
1081    BLOBNBOX *bbox;
1082    gsearch.StartFullSearch();
1083    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1084      BLOBNBOX *blob;
1085      if (bbox->owner() == nullptr && bbox->UniquelyVertical() &&
1086          (blob = MutualUnusedVNeighbour(bbox, BND_ABOVE)) != nullptr) {
1087        auto *part = new ColPartition(BRT_VERT_TEXT, ICOORD(0, 1));
1088        part->AddBox(bbox);
1089        while (blob != nullptr) {
1090          part->AddBox(blob);
1091          blob = MutualUnusedVNeighbour(blob, BND_ABOVE);
1092        }
1093        blob = MutualUnusedVNeighbour(bbox, BND_BELOW);
1094        while (blob != nullptr) {
1095          part->AddBox(blob);
1096          blob = MutualUnusedVNeighbour(blob, BND_BELOW);
1097        }
1098        CompletePartition(pageseg_mode, part, part_grid);
1099      }
1100    }
1101  }
1102  static BLOBNBOX *MutualUnusedHNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1103    BLOBNBOX *next_blob = blob->neighbour(dir);
1104    if (next_blob == nullptr || next_blob->owner() != nullptr || next_blob->UniquelyVertical()) {
1105      return nullptr;
1106    }
1107    if (next_blob->neighbour(DirOtherWay(dir)) == blob) {
1108      return next_blob;
1109    }
1110    return nullptr;
1111  }
1112  void StrokeWidth::FindHorizontalTextChains(ColPartitionGrid *part_grid) {
1113    PageSegMode pageseg_mode =
1114        rerotation_.y() == 0.0f ? PSM_SINGLE_COLUMN : PSM_SINGLE_BLOCK_VERT_TEXT;
1115    BlobGridSearch gsearch(this);
1116    BLOBNBOX *bbox;
1117    gsearch.StartFullSearch();
1118    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1119      BLOBNBOX *blob;
1120      if (bbox->owner() == nullptr && bbox->UniquelyHorizontal() &&
1121          (blob = MutualUnusedHNeighbour(bbox, BND_RIGHT)) != nullptr) {
1122        auto *part = new ColPartition(BRT_TEXT, ICOORD(0, 1));
1123        part->AddBox(bbox);
1124        while (blob != nullptr) {
1125          part->AddBox(blob);
1126          blob = MutualUnusedHNeighbour(blob, BND_RIGHT);
1127        }
1128        blob = MutualUnusedHNeighbour(bbox, BND_LEFT);
1129        while (blob != nullptr) {
1130          part->AddBox(blob);
1131          blob = MutualUnusedVNeighbour(blob, BND_LEFT);
1132        }
1133        CompletePartition(pageseg_mode, part, part_grid);
1134      }
1135    }
1136  }
1137  void StrokeWidth::TestDiacritics(ColPartitionGrid *part_grid, TO_BLOCK *block) {
1138    BlobGrid small_grid(gridsize(), bleft(), tright());
1139    small_grid.InsertBlobList(&block->noise_blobs);
1140    small_grid.InsertBlobList(&block->blobs);
1141    int medium_diacritics = 0;
1142    int small_diacritics = 0;
1143    BLOBNBOX_IT small_it(&block->noise_blobs);
1144    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1145      BLOBNBOX *blob = small_it.data();
1146      if (blob->owner() == nullptr && !blob->IsDiacritic() && DiacriticBlob(&small_grid, blob)) {
1147        ++small_diacritics;
1148      }
1149    }
1150    BLOBNBOX_IT blob_it(&block->blobs);
1151    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1152      BLOBNBOX *blob = blob_it.data();
1153      if (blob->IsDiacritic()) {
1154        small_it.add_to_end(blob_it.extract());
1155        continue; 
1156      }
1157      ColPartition *part = blob->owner();
1158      if (part == nullptr && DiacriticBlob(&small_grid, blob)) {
1159        ++medium_diacritics;
1160        RemoveBBox(blob);
1161        small_it.add_to_end(blob_it.extract());
1162      } else if (part != nullptr && !part->block_owned() && part->boxes_count() < 3) {
1163        BLOBNBOX_C_IT box_it(part->boxes());
1164        for (box_it.mark_cycle_pt();
1165             !box_it.cycled_list() && DiacriticBlob(&small_grid, box_it.data()); box_it.forward()) {
1166          ;
1167        }
1168        if (box_it.cycled_list()) {
1169          while (!box_it.empty()) {
1170            BLOBNBOX *box = box_it.extract();
1171            box->set_owner(nullptr);
1172            box_it.forward();
1173            ++medium_diacritics;
1174            RemoveBBox(box);
1175          }
1176          small_it.add_to_end(blob_it.extract());
1177          part_grid->RemoveBBox(part);
1178          delete part;
1179        }
1180      } else if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
1181                                               blob->bounding_box().bottom())) {
1182        tprintf("Blob not available to be a diacritic at:");
1183        blob->bounding_box().print();
1184      }
1185    }
1186    if (textord_tabfind_show_strokewidths) {
1187      tprintf("Found %d small diacritics, %d medium\n", small_diacritics, medium_diacritics);
1188    }
1189  }
1190  bool StrokeWidth::DiacriticBlob(BlobGrid *small_grid, BLOBNBOX *blob) {
1191    if (BLOBNBOX::UnMergeableType(blob->region_type()) || blob->region_type() == BRT_VERT_TEXT) {
1192      return false;
1193    }
1194    TBOX small_box(blob->bounding_box());
1195    bool debug = AlignedBlob::WithinTestRegion(2, small_box.left(), small_box.bottom());
1196    if (debug) {
1197      tprintf("Testing blob for diacriticness at:");
1198      small_box.print();
1199    }
1200    int x = (small_box.left() + small_box.right()) / 2;
1201    int y = (small_box.bottom() + small_box.top()) / 2;
1202    int grid_x, grid_y;
1203    GridCoords(x, y, &grid_x, &grid_y);
1204    int height = small_box.height();
1205    BLOBNBOX *best_x_overlap = nullptr;
1206    BLOBNBOX *best_y_overlap = nullptr;
1207    int best_total_dist = 0;
1208    int best_y_gap = 0;
1209    TBOX best_xbox;
1210    TBOX search_box(small_box);
1211    int x_pad = IntCastRounded(gridsize() * kDiacriticXPadRatio);
1212    int y_pad = IntCastRounded(gridsize() * kDiacriticYPadRatio);
1213    search_box.pad(x_pad, y_pad);
1214    BlobGridSearch rsearch(this);
1215    rsearch.SetUniqueMode(true);
1216    int min_height = height * kMinDiacriticSizeRatio;
1217    rsearch.StartRectSearch(search_box);
1218    BLOBNBOX *neighbour;
1219    while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1220      if (BLOBNBOX::UnMergeableType(neighbour->region_type()) || neighbour == blob ||
1221          neighbour->owner() == blob->owner()) {
1222        continue;
1223      }
1224      TBOX nbox = neighbour->bounding_box();
1225      if (neighbour->owner() == nullptr || neighbour->owner()->IsVerticalType() ||
1226          (neighbour->flow() != BTFT_CHAIN && neighbour->flow() != BTFT_STRONG_CHAIN)) {
1227        if (debug) {
1228          tprintf("Neighbour not strong enough:");
1229          nbox.print();
1230        }
1231        continue; 
1232      }
1233      if (nbox.height() < min_height) {
1234        if (debug) {
1235          tprintf("Neighbour not big enough:");
1236          nbox.print();
1237        }
1238        continue; 
1239      }
1240      int x_gap = small_box.x_gap(nbox);
1241      int y_gap = small_box.y_gap(nbox);
1242      int total_distance = projection_->DistanceOfBoxFromBox(small_box, nbox, true, denorm_, debug);
1243      if (debug) {
1244        tprintf("xgap=%d, y=%d, total dist=%d\n", x_gap, y_gap, total_distance);
1245      }
1246      if (total_distance > neighbour->owner()->median_height() * kMaxDiacriticDistanceRatio) {
1247        if (debug) {
1248          tprintf("Neighbour with median size %d too far away:", neighbour->owner()->median_height());
1249          neighbour->bounding_box().print();
1250        }
1251        continue; 
1252      }
1253      if (x_gap <= 0) {
1254        if (debug) {
1255          tprintf("Computing reduced box for :");
1256          nbox.print();
1257        }
1258        int left = small_box.left() - small_box.width();
1259        int right = small_box.right() + small_box.width();
1260        nbox = neighbour->BoundsWithinLimits(left, right);
1261        y_gap = small_box.y_gap(nbox);
1262        if (best_x_overlap == nullptr || y_gap < best_y_gap) {
1263          best_x_overlap = neighbour;
1264          best_xbox = nbox;
1265          best_y_gap = y_gap;
1266          if (debug) {
1267            tprintf("New best:");
1268            nbox.print();
1269          }
1270        } else if (debug) {
1271          tprintf("Shrunken box doesn't win:");
1272          nbox.print();
1273        }
1274      } else if (blob->ConfirmNoTabViolation(*neighbour)) {
1275        if (best_y_overlap == nullptr || total_distance < best_total_dist) {
1276          if (debug) {
1277            tprintf("New best y overlap:");
1278            nbox.print();
1279          }
1280          best_y_overlap = neighbour;
1281          best_total_dist = total_distance;
1282        } else if (debug) {
1283          tprintf("New y overlap box doesn't win:");
1284          nbox.print();
1285        }
1286      } else if (debug) {
1287        tprintf("Neighbour wrong side of a tab:");
1288        nbox.print();
1289      }
1290    }
1291    if (best_x_overlap != nullptr &&
1292        (best_y_overlap == nullptr || best_xbox.major_y_overlap(best_y_overlap->bounding_box()))) {
1293      blob->set_diacritic_box(best_xbox);
1294      blob->set_base_char_blob(best_x_overlap);
1295      if (debug) {
1296        tprintf("DiacriticBlob OK! (x-overlap:");
1297        small_box.print();
1298        best_xbox.print();
1299      }
1300      return true;
1301    }
1302    if (best_y_overlap != nullptr &&
1303        DiacriticXGapFilled(small_grid, small_box, best_y_overlap->bounding_box()) &&
1304        NoNoiseInBetween(small_box, best_y_overlap->bounding_box())) {
1305      blob->set_diacritic_box(best_y_overlap->bounding_box());
1306      blob->set_base_char_blob(best_y_overlap);
1307      if (debug) {
1308        tprintf("DiacriticBlob OK! (y-overlap:");
1309        small_box.print();
1310        best_y_overlap->bounding_box().print();
1311      }
1312      return true;
1313    }
1314    if (debug) {
1315      tprintf("DiacriticBlob fails:");
1316      small_box.print();
1317      tprintf("Best x+y gap = %d, y = %d\n", best_total_dist, best_y_gap);
1318      if (best_y_overlap != nullptr) {
1319        tprintf("XGapFilled=%d, NoiseBetween=%d\n",
1320                DiacriticXGapFilled(small_grid, small_box, best_y_overlap->bounding_box()),
1321                NoNoiseInBetween(small_box, best_y_overlap->bounding_box()));
1322      }
1323    }
1324    return false;
1325  }
1326  bool StrokeWidth::DiacriticXGapFilled(BlobGrid *grid, const TBOX &diacritic_box,
1327                                        const TBOX &base_box) {
1328    int max_gap = IntCastRounded(base_box.height() * kMaxDiacriticGapToBaseCharHeight);
1329    TBOX occupied_box(base_box);
1330    int diacritic_gap;
1331    while ((diacritic_gap = diacritic_box.x_gap(occupied_box)) > max_gap) {
1332      TBOX search_box(occupied_box);
1333      if (diacritic_box.left() > search_box.right()) {
1334        search_box.set_left(search_box.right());
1335        search_box.set_right(search_box.left() + max_gap);
1336      } else {
1337        search_box.set_right(search_box.left());
1338        search_box.set_left(search_box.left() - max_gap);
1339      }
1340      BlobGridSearch rsearch(grid);
1341      rsearch.StartRectSearch(search_box);
1342      BLOBNBOX *neighbour;
1343      while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1344        const TBOX &nbox = neighbour->bounding_box();
1345        if (nbox.x_gap(diacritic_box) < diacritic_gap) {
1346          if (nbox.left() < occupied_box.left()) {
1347            occupied_box.set_left(nbox.left());
1348          }
1349          if (nbox.right() > occupied_box.right()) {
1350            occupied_box.set_right(nbox.right());
1351          }
1352          break;
1353        }
1354      }
1355      if (neighbour == nullptr) {
1356        return false; 
1357      }
1358    }
1359    return true; 
1360  }
1361  void StrokeWidth::MergeDiacritics(TO_BLOCK *block, ColPartitionGrid *part_grid) {
1362    BLOBNBOX_IT small_it(&block->noise_blobs);
1363    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1364      BLOBNBOX *blob = small_it.data();
1365      if (blob->base_char_blob() != nullptr) {
1366        ColPartition *part = blob->base_char_blob()->owner();
1367        if (part != nullptr && !part->block_owned() && blob->owner() == nullptr &&
1368            blob->IsDiacritic()) {
1369          part_grid->RemoveBBox(part);
1370          part->AddBox(blob);
1371          blob->set_region_type(part->blob_type());
1372          blob->set_flow(part->flow());
1373          blob->set_owner(part);
1374          part_grid->InsertBBox(true, true, part);
1375        }
1376        blob->set_base_char_blob(nullptr);
1377      }
1378    }
1379  }
1380  void StrokeWidth::RemoveLargeUnusedBlobs(TO_BLOCK *block, ColPartitionGrid *part_grid,
1381                                           ColPartition_LIST *big_parts) {
1382    BLOBNBOX_IT large_it(&block->large_blobs);
1383    for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
1384      BLOBNBOX *blob = large_it.data();
1385      ColPartition *big_part = blob->owner();
1386      if (big_part == nullptr) {
1387        ColPartition::MakeBigPartition(blob, big_parts);
1388      }
1389    }
1390  }
1391  void StrokeWidth::PartitionRemainingBlobs(PageSegMode pageseg_mode, ColPartitionGrid *part_grid) {
1392    BlobGridSearch gsearch(this);
1393    BLOBNBOX *bbox;
1394    int prev_grid_x = -1;
1395    int prev_grid_y = -1;
1396    BLOBNBOX_CLIST cell_list;
1397    BLOBNBOX_C_IT cell_it(&cell_list);
1398    bool cell_all_noise = true;
1399    gsearch.StartFullSearch();
1400    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1401      int grid_x = gsearch.GridX();
1402      int grid_y = gsearch.GridY();
1403      if (grid_x != prev_grid_x || grid_y != prev_grid_y) {
1404        MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &cell_list);
1405        cell_it.set_to_list(&cell_list);
1406        prev_grid_x = grid_x;
1407        prev_grid_y = grid_y;
1408        cell_all_noise = true;
1409      }
1410      if (bbox->owner() == nullptr) {
1411        cell_it.add_to_end(bbox);
1412        if (bbox->flow() != BTFT_NONTEXT) {
1413          cell_all_noise = false;
1414        }
1415      } else {
1416        cell_all_noise = false;
1417      }
1418    }
1419    MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &cell_list);
1420  }
1421  void StrokeWidth::MakePartitionsFromCellList(PageSegMode pageseg_mode, bool combine,
1422                                               ColPartitionGrid *part_grid,
1423                                               BLOBNBOX_CLIST *cell_list) {
1424    if (cell_list->empty()) {
1425      return;
1426    }
1427    BLOBNBOX_C_IT cell_it(cell_list);
1428    if (combine) {
1429      BLOBNBOX *bbox = cell_it.extract();
1430      auto *part = new ColPartition(bbox->region_type(), ICOORD(0, 1));
1431      part->AddBox(bbox);
1432      part->set_flow(bbox->flow());
1433      for (cell_it.forward(); !cell_it.empty(); cell_it.forward()) {
1434        part->AddBox(cell_it.extract());
1435      }
1436      CompletePartition(pageseg_mode, part, part_grid);
1437    } else {
1438      for (; !cell_it.empty(); cell_it.forward()) {
1439        BLOBNBOX *bbox = cell_it.extract();
1440        auto *part = new ColPartition(bbox->region_type(), ICOORD(0, 1));
1441        part->set_flow(bbox->flow());
1442        part->AddBox(bbox);
1443        CompletePartition(pageseg_mode, part, part_grid);
1444      }
1445    }
1446  }
1447  void StrokeWidth::CompletePartition(PageSegMode pageseg_mode, ColPartition *part,
1448                                      ColPartitionGrid *part_grid) {
1449    part->ComputeLimits();
1450    TBOX box = part->bounding_box();
1451    bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
1452    int value = projection_->EvaluateColPartition(*part, denorm_, debug);
1453    if (value > 0 && FindingVerticalOnly(pageseg_mode)) {
1454      value = part->boxes_count() == 1 ? 0 : -2;
1455    } else if (value < 0 && FindingHorizontalOnly(pageseg_mode)) {
1456      value = part->boxes_count() == 1 ? 0 : 2;
1457    }
1458    part->SetRegionAndFlowTypesFromProjectionValue(value);
1459    part->ClaimBoxes();
1460    part_grid->InsertBBox(true, true, part);
1461  }
1462  void StrokeWidth::EasyMerges(ColPartitionGrid *part_grid) {
1463    using namespace std::placeholders; 
1464    part_grid->Merges(std::bind(&StrokeWidth::OrientationSearchBox, this, _1, _2),
1465                      std::bind(&StrokeWidth::ConfirmEasyMerge, this, _1, _2));
1466  }
1467  bool StrokeWidth::OrientationSearchBox(ColPartition *part, TBOX *box) {
1468    if (part->IsVerticalType()) {
1469      box->set_top(box->top() + box->width());
1470      box->set_bottom(box->bottom() - box->width());
1471    } else {
1472      box->set_left(box->left() - box->height());
1473      box->set_right(box->right() + box->height());
1474    }
1475    return true;
1476  }
1477  bool StrokeWidth::ConfirmEasyMerge(const ColPartition *p1, const ColPartition *p2) {
1478    ASSERT_HOST(p1 != nullptr && p2 != nullptr);
1479    ASSERT_HOST(!p1->IsEmpty() && !p2->IsEmpty());
1480    if ((p1->flow() == BTFT_NONTEXT && p2->flow() >= BTFT_CHAIN) ||
1481        (p1->flow() >= BTFT_CHAIN && p2->flow() == BTFT_NONTEXT)) {
1482      return false; 
1483    }
1484    if ((p1->IsVerticalType() || p2->IsVerticalType()) && p1->HCoreOverlap(*p2) <= 0 &&
1485        ((!p1->IsSingleton() && !p2->IsSingleton()) ||
1486         !p1->bounding_box().major_overlap(p2->bounding_box()))) {
1487      return false; 
1488    }
1489    if ((p1->IsHorizontalType() || p2->IsHorizontalType()) && p1->VCoreOverlap(*p2) <= 0 &&
1490        ((!p1->IsSingleton() && !p2->IsSingleton()) ||
1491         (!p1->bounding_box().major_overlap(p2->bounding_box()) &&
1492          !p1->OKDiacriticMerge(*p2, false) && !p2->OKDiacriticMerge(*p1, false)))) {
1493      return false; 
1494    }
1495    if (!p1->ConfirmNoTabViolation(*p2)) {
1496      return false;
1497    }
1498    if (p1->flow() <= BTFT_NONTEXT && p2->flow() <= BTFT_NONTEXT) {
1499      return true;
1500    }
1501    return NoNoiseInBetween(p1->bounding_box(), p2->bounding_box());
1502  }
1503  bool StrokeWidth::NoNoiseInBetween(const TBOX &box1, const TBOX &box2) const {
1504    return ImageFind::BlankImageInBetween(box1, box2, grid_box_, rerotation_, nontext_map_);
1505  }
1506  #ifndef GRAPHICS_DISABLED
1507  ScrollView *StrokeWidth::DisplayGoodBlobs(const char *window_name, int x, int y) {
1508    auto window = MakeWindow(x, y, window_name);
1509    window->Brush(ScrollView::NONE);
1510    BlobGridSearch gsearch(this);
1511    gsearch.StartFullSearch();
1512    BLOBNBOX *bbox;
1513    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1514      const TBOX &box = bbox->bounding_box();
1515      int left_x = box.left();
1516      int right_x = box.right();
1517      int top_y = box.top();
1518      int bottom_y = box.bottom();
1519      int goodness = bbox->GoodTextBlob();
1520      BlobRegionType blob_type = bbox->region_type();
1521      if (bbox->UniquelyVertical()) {
1522        blob_type = BRT_VERT_TEXT;
1523      }
1524      if (bbox->UniquelyHorizontal()) {
1525        blob_type = BRT_TEXT;
1526      }
1527      BlobTextFlowType flow = bbox->flow();
1528      if (flow == BTFT_NONE) {
1529        if (goodness == 0) {
1530          flow = BTFT_NEIGHBOURS;
1531        } else if (goodness == 1) {
1532          flow = BTFT_CHAIN;
1533        } else {
1534          flow = BTFT_STRONG_CHAIN;
1535        }
1536      }
1537      window->Pen(BLOBNBOX::TextlineColor(blob_type, flow));
1538      window->Rectangle(left_x, bottom_y, right_x, top_y);
1539    }
1540    window->Update();
1541    return window;
1542  }
1543  static void DrawDiacriticJoiner(const BLOBNBOX *blob, ScrollView *window) {
1544    const TBOX &blob_box(blob->bounding_box());
1545    int top = std::max(static_cast<int>(blob_box.top()), blob->base_char_top());
1546    int bottom = std::min(static_cast<int>(blob_box.bottom()), blob->base_char_bottom());
1547    int x = (blob_box.left() + blob_box.right()) / 2;
1548    window->Line(x, top, x, bottom);
1549  }
1550  ScrollView *StrokeWidth::DisplayDiacritics(const char *window_name, int x, int y, TO_BLOCK *block) {
1551    auto window = MakeWindow(x, y, window_name);
1552    window->Brush(ScrollView::NONE);
1553    BLOBNBOX_IT it(&block->blobs);
1554    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1555      BLOBNBOX *blob = it.data();
1556      if (blob->IsDiacritic()) {
1557        window->Pen(ScrollView::GREEN);
1558        DrawDiacriticJoiner(blob, window);
1559      } else {
1560        window->Pen(blob->BoxColor());
1561      }
1562      const TBOX &box = blob->bounding_box();
1563      window->Rectangle(box.left(), box.bottom(), box.right(), box.top());
1564    }
1565    it.set_to_list(&block->noise_blobs);
1566    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1567      BLOBNBOX *blob = it.data();
1568      if (blob->IsDiacritic()) {
1569        window->Pen(ScrollView::GREEN);
1570        DrawDiacriticJoiner(blob, window);
1571      } else {
1572        window->Pen(ScrollView::WHITE);
1573      }
1574      const TBOX &box = blob->bounding_box();
1575      window->Rectangle(box.left(), box.bottom(), box.right(), box.top());
1576    }
1577    window->Update();
1578    return window;
1579  }
1580  #endif 
1581  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</h3>
            <pre><code>1  #include "lsionto.h"
2  void TOntoConcept::GenMedoid(PBowDocWgtBs BowDocWgtBs) {
3      TFltIntKdV WgtDIdV;
4      for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
5          const int DId = DIdV[DIdN];
6          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
7          const double Wgt = TBowSim::GetCosSim(ConceptSpV, DocSpV);
8          WgtDIdV.Add(TFltIntKd(Wgt, DId));
9      }
10      const int TopN = 33;
11      TFltIntKdV TopWgtDIdV;
12      if (WgtDIdV.Len() > TopN) {
13          TFltIntKdHp::GetTopV(htMin, TopN, WgtDIdV, TopWgtDIdV, true);
14      } else { 
15          TopWgtDIdV = WgtDIdV; TopWgtDIdV.Sort(false);
16      }
17      GetSwitchedKdV<TFlt, TInt>(TopWgtDIdV, MedoidDIdWgtV);
18  }
19  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
20          const int _Id, const TIntV& _DIdV): Id(_Id), DIdV(_DIdV)  { 
21      ResetCentroidSpV(BowDocWgtBs);
22      CptNm = GetKeyWdStr(BowDocBs, 3, 1.0, ", ", false, false);
23      SvmKeyWdSpV = TBowSpV::New();
24      if (!DIdV.IsSorted()) { DIdV.Sort(); }
25      Compactness = Clarity = -1.0;
26  };
27  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, const int _Id, 
28          const TStr& _CptNm, const TIntV& _DIdV): Id(_Id), CptNm(_CptNm), DIdV(_DIdV) { 
29      ResetCentroidSpV(BowDocWgtBs);
30      SvmKeyWdSpV = TBowSpV::New();
31      if (!DIdV.IsSorted()) { DIdV.Sort(); }
32      Compactness = Clarity = -1.0;
33  };
34  void TOntoConcept::ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs) {
35      ConceptSpV = TBowClust::GetConceptSpV(BowDocWgtBs, NULL, DIdV);
36      GenMedoid(BowDocWgtBs);
37      IsValid = true;
38  }
39  void TOntoConcept::SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& _DIdV) {
40      if (Id == 0) return; 
41      DIdV = _DIdV; if (!DIdV.IsSorted()) { DIdV.Sort(); }
42      ResetCentroidSpV(BowDocWgtBs);
43  }
44  void TOntoConcept::AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV) {
45      DIdV.Union(SubDIdV);
46      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
47      else { IsValid = false; }
48  }
49  void TOntoConcept::AddDId(PBowDocWgtBs BowDocWgtBs, const int& DId) {
50      if (DIdV.SearchBin(DId) == -1) { DIdV.AddSorted(DId); }
51      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
52      else { IsValid = false; }
53  }
54  void TOntoConcept::DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV) {
55      if (Id == 0) return; 
56      DIdV.Diff(SubDIdV);
57      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
58      else { IsValid = false; }
59  }
60  bool TOntoConcept::DelDId(PBowDocWgtBs BowDocWgtBs, const int& DId) {
61      if (Id == 0) return false; 
62      bool DocDeletedP = DIdV.DelIfIn(DId);
63      if (DocDeletedP && !BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
64      else { IsValid = false; }
65      return DocDeletedP;
66  }
67  TStr TOntoConcept::GetKeyWdStr(PBowDocBs BowDocBs, const int& TopWords, 
68          const double& TopWordsWgtPrc, const TStr& SepStr, 
69          const bool& ShowWeights, const bool& UseMedoidP) const { 
70      if (!UseMedoidP) {
71          return ConceptSpV->GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
72      } else {
73          if (MedoidDIdWgtV.Empty()) { return "Empty concept"; }
74          TStr KeyWdStr = BowDocBs->GetDocNm(MedoidDIdWgtV[0].Key);
75          const int DIds = TInt::GetMn(TopWords, MedoidDIdWgtV.Len());
76          for (int DIdN = 1; DIdN < DIds; DIdN++) {
77              const int DId = MedoidDIdWgtV[DIdN].Key;
78              TStr DocNm = BowDocBs->GetDocNm(DId);
79              KeyWdStr += SepStr; KeyWdStr += DocNm;
80          }
81          return KeyWdStr;
82      }
83  }
84  TStr TOntoConcept::GetSvmKeyWdStr(PBowDocBs BowDocBs, const int& TopWords,
85          const double& TopWordsWgtPrc, const TStr& SepStr, const bool& ShowWeights) const {
86      return SvmKeyWdSpV->GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
87  }
88  void TOntoConcept::CalcCptMd(PBowDocBs BowDocBs, const TIntV& ContextDIdV,
89          const double& SvmC, const double& SvmJ, const int& SvmTime) {
90      if (Id == 0) return;
91      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, 
92          bwwtLogDFNrmTFIDF, 0.0, 0, ContextDIdV);
93      PSVMTrainSet TrainSet = TBowDocBs2TrainSet::NewBowAllCatV(
94          BowDocWgtBs, ContextDIdV, DIdV);
95      CptMd = TSVMModel::NewClsLinear(TrainSet, SvmC, SvmJ, TIntV(), 
96          TSVMLearnParam::Lin(SvmTime));
97      CptMd->MakeProb(TrainSet);
98  }
99  TStr TOntoRltType::SubCptOfRltStr = "SubConcept-Of";
100  TStr TOntoRltType::SimilarRltStr = "Similar";
101  void TOntoAlg::SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
102          const TIntV& DIdV, const int& _NewConceptN, PUniqueId UniqueId, 
103          TOntoConceptV& NewConceptV) {
104      const int NewConceptN = TInt::GetMn(DIdV.Len(), _NewConceptN);
105      NewConceptV.Clr(); if (NewConceptN < 2) return;
106      TIntV FullDIdV; BowDocWgtBs->GetDIdV(FullDIdV);
107      BowDocWgtBs->SetDIdV(DIdV);
108      PBowSim BowSim = TBowSim::New(bstCos);
109      PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
110          TNotify::StdNotify, BowDocWgtBs, BowDocBs, 
111          BowSim, TRnd(1), NewConceptN, 1, 10, 1);
112      BowDocWgtBs->SetDIdV(FullDIdV);
113      IAssert(BowDocPart->GetClusts() == NewConceptN);
114      NewConceptV.Gen(NewConceptN, 0);
115      for (int ClustC = 0; ClustC < NewConceptN; ClustC++) {
116          PBowDocPartClust Clust = BowDocPart->GetClust(ClustC);
117          TIntV CptDIdV; Clust->GetDIdV(CptDIdV);
118          NewConceptV.Add(TOntoConcept::New(BowDocBs,
119              BowDocWgtBs, UniqueId->GetNextId(), CptDIdV));
120      }
121  }
122  void TOntoAlg::SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
123          const TIntV& DIdV, PUniqueId UniqueId, TOntoConceptV& NewConceptV) {
124      TIntIntVH CIdDIdVH;
125      for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
126          const int DId = DIdV[DocN];
127          const int DocCIds = BowDocBs->GetDocCIds(DId);
128          for (int DocCIdN = 0; DocCIdN < DocCIds; DocCIdN++) {
129              const int DocCId = BowDocBs->GetDocCId(DId, DocCIdN);
130              if (CIdDIdVH.IsKey(DocCId)) {
131                  CIdDIdVH.GetDat(DocCId).Add(DId);
132              } else {
133                  CIdDIdVH.AddDat(DocCId, TIntV::GetV(DId));
134              }
135          }
136      }
137      TIntKdV DocsKeyIdV(CIdDIdVH.Len(), 0);
138      int KeyId = CIdDIdVH.FFirstKeyId();
139      while (CIdDIdVH.FNextKeyId(KeyId)) {
140          const int Docs = CIdDIdVH[KeyId].Len();
141          DocsKeyIdV.Add(TIntKd(Docs, KeyId));
142      }
143      DocsKeyIdV.Sort(false);
144      NewConceptV.Gen(CIdDIdVH.Len(), 0);
145      for (int CptN = 0; CptN < DocsKeyIdV.Len(); CptN++) {
146          const int CptKeyId = DocsKeyIdV[CptN].Dat;
147          const TIntV& CptDIdV = CIdDIdVH[CptKeyId];
148          TStr CptNm = BowDocBs->GetCatNm(CIdDIdVH.GetKey(CptKeyId));
149          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
150              UniqueId->GetNextId(), CptNm, CptDIdV));
151      }
152  }
153  void TOntoAlg::SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
154          const TIntV& DIdV, PLwOntoCfier LwOntoCfier, const int& _NewConcepts, 
155          PUniqueId UniqueId, TOntoConceptV& NewConceptV) {
156      TIntH TermIdFqH; TIntIntVH TermIdDIdVH;
157      for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
158          const int DId = DIdV[DIdN];
159          TStr DocStr = BowDocBs->GetDocStr(DId);
160          TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
161          LwOntoCfier->ClassifyStr(DocStr, SimTermIdPrV);
162          if (!SimTermIdPrV.Empty()) { 
163              const int TermId = SimTermIdPrV[0].Val2;
164              if (TermIdFqH.IsKey(TermId)) { 
165                  TermIdFqH(TermId)++; 
166                  TermIdDIdVH(TermId).Add(DId);
167              } else { 
168                  TermIdFqH.AddDat(TermId, 1); 
169                  TermIdDIdVH.AddDat(TermId, TIntV::GetV(DId));
170              }
171          }
172      }
173      TIntPrV TermFqIdV; TermIdFqH.GetDatKeyPrV(TermFqIdV); TermFqIdV.Sort(false);
174      const int NewConcepts = TInt::GetMn(_NewConcepts, TermFqIdV.Len());
175      NewConceptV.Gen(NewConcepts, 0);
176      PLwTermBs TermBs = LwOntoCfier->GetLwOnto()->GetTermBs();
177      for (int NewConceptN = 0; NewConceptN < NewConcepts; NewConceptN++) {
178          const int TermId = TermFqIdV[NewConceptN].Val2;
179          const TIntV& CptDIdV = TermIdDIdVH(TermId);
180          TStr TermNm = TermBs->GetTerm(TermId)->GetTermNm();
181          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
182              UniqueId->GetNextId(), TermNm, CptDIdV));
183      }
184  }
185  TStr TOntoExportPTO::GetUri(const int& Id, const TStr& Nm) {
186      TChA CleanChA; bool ToUc = true;
187      for (int ChN = 0; ChN < Nm.Len(); ChN++) {
188          char Ch = Nm[ChN];
189          if (TCh::IsAlpha(Ch)) { 
190              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
191              CleanChA += Ch; 
192          } else { ToUc = true; }
193      }
194      return TInt::GetStr(Id) + "_" + TStr(CleanChA);
195  }
196  void TOntoExportPTO::StartExport() {
197      SOut->PutStrLn("<?xml version='1.0' encoding='UTF-8'?>");
198      SOut->PutStrLn("");
199      SOut->PutStrLn("<!DOCTYPE rdf:RDF [");
200      SOut->PutStrLn("    <!ENTITY rdf  'http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#'>");
201      SOut->PutStrLn("    <!ENTITY rdfs 'http:&bsol;&bsol;www.w3.org/2000/01/rdf-schema#'>");
202      SOut->PutStrLn("    <!ENTITY owl  'http:&bsol;&bsol;www.w3.org/2002/07/owl#'>");
203      SOut->PutStrLn("    <!ENTITY xsd  'http:&bsol;&bsol;www.w3.org/2001/XMLSchema#' >");
204      SOut->PutStrLn("    <!ENTITY ptop 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont#'>");
205      SOut->PutStrLn("    <!ENTITY psys 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>");
206      SOut->PutStrLn("    <!ENTITY protonkm  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm#'>");
207      if (DigLibP) { SOut->PutStrLn("    <!ENTITY diglib 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>"); }
208      SOut->PutStrLn("    <!ENTITY jsikm  'http:&bsol;&bsol;kt.ijs.si/blazf/jsikm#'>");
209      SOut->PutStrLn("]>");
210      SOut->PutStrLn("");
211      SOut->PutStrLn("<rdf:RDF");
212      SOut->PutStrLn("    xmlns:owl=\"&owl;\"");
213      SOut->PutStrLn("    xmlns:rdf=\"&rdf;\"");
214      SOut->PutStrLn("    xmlns:rdfs=\"&rdfs;\"");
215      SOut->PutStrLn("    xmlns:psys=\"&psys;\"");
216      SOut->PutStrLn("    xmlns:ptop=\"&ptop;\"");
217      SOut->PutStrLn("    xmlns:protonkm=\"&protonkm;\"");
218      SOut->PutStrLn("    xmlns=\"&protonkm;\"");
219      if (DigLibP) { SOut->PutStrLn("    xmlns:diglib=\"&diglib;\""); }
220      SOut->PutStrLn("    xmlns:jsikm=\"&jsikm;\"");
221      SOut->PutStrLn("    xml:base=\"&protonkm;\""); 
222      SOut->PutStrLn(">");
223      SOut->PutStrLn("");
224      SOut->PutStrLn("<owl:Ontology rdf:about=\"\">");
225      SOut->PutStrLn("  <rdfs:comment>PROTON Topics (from Inspec Thesaurus) ordered by algorithm X</rdfs:comment>");
226      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons\"/>");
227      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont\"/>");
228      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu\"/>");
229      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm\"/>");
230      if (DigLibP) { SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>"); }
231      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>");
232      SOut->PutStrLn("  <owl:versionInfo>\"0.1\"</owl:versionInfo>");
233      SOut->PutStrLn("</owl:Ontology>");
234      SOut->PutStrLn("");
235  }
236  void TOntoExportPTO::EndExport() {
237      SOut->PutStrLn("</rdf:RDF>");
238      SOut->Flush();
239  }
240  void TOntoExportPTO::PutCpt(const int& CptId, const TStr CptNm, 
241          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, const TIntV& DIdV, 
242          PBowDocBs BowDocBs, PBowSpV KeyWdSpV, PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
243      SOut->PutStrLn("<ptop:Topic rdf:about=\"#Cpt" + GetUri(CptId, CptNm) + "\">");
244      SOut->PutStrLn("  <psys:description>" + CptNm + "</psys:description>");
245      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
246          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
247          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
248          SOut->PutStrLn("  <ptop:subTopicOf rdf:resource=\"#Cpt" + 
249              GetUri(SuperCptId, SuperCptNm) + "\" />");
250      }
251      if (DigLibP) {
252          for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
253              const int DId = DIdV[DIdN];
254              TStr DNm = BowDocBs->GetDocNm(DId);
255              SOut->PutStrLn("  <diglib:hasArticle rdf:resource=\"#Doc" + 
256                  GetUri(DId, DNm) + "\" />");
257          }
258      }
259      SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenClassProperties rdf:resource=\"#CLS_PROP_%d\" />", CptId));
260      SOut->PutStrLn("</ptop:Topic>");
261      SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenClassProperties rdf:about=\"#CLS_PROP_%d\">", CptId));
262      TStr KeyWdStr = KeyWdSpV->GetStr(BowDocBs, 10, 1.0, ", ", false, true);
263      SOut->PutStrLn("  <jsikm:hasCentroidKeywords>" + KeyWdStr + "</jsikm:hasCentroidKeywords>");
264      TStr SvmKeyWdStr = SvmKeyWdSpV->GetStr(BowDocBs, 10, 1.0, ", ", false, true);
265      SOut->PutStrLn("  <jsikm:hasSVMKeywords>" + SvmKeyWdStr + "</jsikm:hasSVMKeywords>");
266      SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
267      SOut->PutStrLn("");
268  }
269  void TOntoExportPTO::PutDoc(const int& DId, const TStr& DocTitle, 
270          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
271      SOut->PutStrLn("<ptop:Document rdf:about=\"#Doc" + GetUri(DId, DocTitle) + "\">");
272      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
273          const int CptId = CptIdNmV[CptIdN].Val1;
274          TStr CptNm = CptIdNmV[CptIdN].Val2;
275          SOut->PutStrLn("  <ptop:hasSubject rdf:resource=\"#Cpt" + 
276              GetUri(CptId, CptNm) + "\" />");
277      }
278      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
279      CleanDocAbstract.ChangeChAll('\n', ' '); CleanDocAbstract.ChangeChAll('\n', ' ');
280      SOut->PutStrLn(TStr::Fmt("  <ptop:documentAbstract>%s</ptop:documentAbstract>", CleanDocAbstract.CStr()));
281      SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenInstanceProperties rdf:resource=\"#INST_PROP_%d\" />", DId));
282      SOut->PutStrLn("</ptop:Document>");
283      TStr ShortBowFNm = BowFNmStr.GetFMid() + BowFNmStr.GetFExt();
284      SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenInstanceProperties rdf:about=\"#INST_PROP_%d\">", DId));
285      SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
286      SOut->PutStrLn("</jsikm:OntoGenInstanceProperties>");
287      SOut->PutStrLn("");
288  }
289  void TOntoExportProlog::StartExport() {
290      SOut->PutStrLn("% OntoGen export in Prolog.");
291  }
292  void TOntoExportProlog::EndExport() {
293      SOut->Flush();
294  }
295  void TOntoExportProlog::PutCpt(const int& CptId, const TStr CptNm, 
296          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
297          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
298          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
299      SOut->PutStrLn(TStr::Fmt("class( %s, label, '%s' ).", 
300          GetCptLabel(CptId).CStr(), CptNm.CStr()));
301      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
302          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
303          SOut->PutStrLn(TStr::Fmt("subClassOf( %s, %s ).", 
304              GetCptLabel(CptId).CStr(), GetCptLabel(SuperCptId).CStr()));
305      }
306  }
307  void TOntoExportProlog::PutDoc(const int& DId, const TStr& DocTitle, 
308          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
309      TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll('\'');
310      CleanDocTitle.DelChAll('\n'); CleanDocTitle.DelChAll('\r');
311      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
312      CleanDocAbstract.DelChAll('\''); CleanDocAbstract.DelChAll('\n'); 
313      CleanDocAbstract.DelChAll('\r');
314      SOut->PutStrLn(TStr::Fmt("instance( %s, label, '%s' ).", 
315          GetInstLabel(DId).CStr(), CleanDocTitle.CStr()));
316      SOut->PutStrLn(TStr::Fmt("instance( %s, text, '%s' ).", 
317          GetInstLabel(DId).CStr(), CleanDocAbstract.CStr()));
318      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
319          const int CptId = CptIdNmV[CptIdN].Val1;
320          SOut->PutStrLn(TStr::Fmt("instanceOf( %s, %s ).", 
321              GetInstLabel(DId).CStr(), GetCptLabel(CptId).CStr()));
322      }
323  }
324  TStr TOntoExportOWL::GetUri(const int& Id, const TStr& Nm) {
325      TChA CleanChA; bool ToUc = true;
326      for (int ChN = 0; ChN < Nm.Len(); ChN++) {
327          char Ch = Nm[ChN];
328          if (TCh::IsAlpha(Ch)) { 
329              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
330              CleanChA += Ch; 
331          } else { ToUc = true; }
332      }
333      return TInt::GetStr(Id) + "_" + TStr(CleanChA);
334  }
335  void TOntoExportOWL::StartExport() {
336      SOut->PutStrLn("<?xml version=\"1.0\"?>");
337      SOut->PutStrLn("<rdf:RDF");
338      SOut->PutStrLn("    xmlns:rdf=\"http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#\"");
339      SOut->PutStrLn("    xmlns:xsd=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema#\"");
340      SOut->PutStrLn("    xmlns:rdfs=\"http:&bsol;&bsol;www.w3.org/2000/01/rdf-schema#\"");
341      SOut->PutStrLn("    xmlns:owl=\"http:&bsol;&bsol;www.w3.org/2002/07/owl#\"");
342      SOut->PutStrLn("    xmlns=\"http:&bsol;&bsol;www.owl-ontologies.com/Ontology1150050933.owl#\"");
343      SOut->PutStrLn("    xml:base=\"http:&bsol;&bsol;www.owl-ontologies.com/Ontology1150050933.owl\">");
344      SOut->PutStrLn("");
345      SOut->PutStrLn("<owl:Ontology rdf:about=\"OntoGen OWL export\"/>");
346      SOut->PutStrLn("");
347  }
348  void TOntoExportOWL::EndExport() {
349      SOut->PutStrLn("");
350      SOut->PutStrLn("</rdf:RDF>");
351      SOut->Flush();
352  }
353  void TOntoExportOWL::PutCpt(const int& CptId, const TStr CptNm, 
354          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
355          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
356          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
357      SOut->PutStrLn("<owl:Class rdf:ID=\"Cpt" + GetUri(CptId, CptNm) + "\">");
358      SOut->PutStrLn("  <rdfs:label>" + CptNm + "</rdfs:label>");
359      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
360          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
361          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
362          SOut->PutStrLn("  <rdfs:subClassOf rdf:resource=\"#Cpt" + 
363              GetUri(SuperCptId, SuperCptNm) + "\"/>");
364      }
365      SOut->PutStrLn("</owl:Class>");
366      SOut->PutStrLn("");
367  }
368  void TOntoExportOWL::PutDoc(const int& DId, const TStr& DocTitle, 
369          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
370      if (!StoreDocsP) { return; }
371      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
372          const int CptId = CptIdNmV[CptIdN].Val1;
373          TStr CptNm = CptIdNmV[CptIdN].Val2;
374          SOut->PutStrLn("<Cpt" + GetUri(CptId, CptNm) + " rdf:ID=\"Doc" + 
375              GetUri(DId, DocTitle) + "\">");
376          if (CptIdN == 0) {
377              TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll('\'');
378              CleanDocTitle.DelChAll('\n'); CleanDocTitle.DelChAll('\r');
379              SOut->PutStrLn("  <rdfs:label>" + CleanDocTitle + "</rdfs:label>");
380              if (StoreAbstractsP) {
381                  TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
382                  CleanDocAbstract.DelChAll('\''); CleanDocAbstract.DelChAll('\n'); 
383                  CleanDocAbstract.DelChAll('\r');
384                  SOut->PutStrLn("  <rdfs:comment>" + CleanDocAbstract + "</rdfs:label>");
385              }
386          }
387          SOut->PutStrLn("</Cpt" + GetUri(CptId, CptNm) + ">");
388      }
389      SOut->PutStrLn("");
390  }
391  void TOntoExportOWL::PutRltType(const TStr& RltNm, const bool& DirectedP,
392          const bool& TransitiveP) {
393      SOut->PutStrLn("<owl:ObjectProperty rdf:ID=\"" + RltNm + "\"/>");
394      SOut->PutStrLn("");    
395  }
396  void TOntoExportOWL::PutRlt(const TStr& RltNm, const int& SrcCptId, 
397          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm) {
398      SOut->PutStrLn("<owl:Class rdf:ID=\"Cpt" + GetUri(SrcCptId, SrcCptNm) + "\">");
399      SOut->PutStrLn("  <rdfs:subClassOf><owl:Restriction>");
400      SOut->PutStrLn("    <owl:onProperty rdf:resource=\"#" + RltNm + "\"/>");
401      SOut->PutStrLn("    <owl:someValuesFrom>");
402      SOut->PutStrLn("      <owl:Class rdf:ID=\"Cpt" + GetUri(DstCptId, DstCptNm) + "\"/>");
403      SOut->PutStrLn("    </owl:someValuesFrom>");
404      SOut->PutStrLn("  </owl:Restriction></rdfs:subClassOf>");
405      SOut->PutStrLn("</owl:Class>");
406      SOut->PutStrLn("");    
407  }
408  TOntology::TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
409      const TBowSimType& BowSimType): BowDocBs(_BowDocBs), 
410          BowDocWgtBs(_BowDocWgtBs) {
411      BowSim = TBowSim::New(BowSimType);
412      OntoGraph = TGGraph::New();
413      UniqueId = TUniqueId::New(0);
414      GenerateEmptyOnto();
415  }
416  void TOntology::GenerateEmptyOnto() {
417      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
418      POntoConcept RootCpt = TOntoConcept::New(BowDocBs, 
419          BowDocWgtBs, UniqueId->GetNextId(), AllDIdV);
420      RootCpt->SetName("root");
421      AddConcept(RootCpt, -1);
422      OntoGraph->GetPp()->AddPpStr("BoldVNm", "", "root");
423      RltTypeV.Add(TOntoRltType(TOntoRltType::SubCptOfRltStr, true, true));
424      RltTypeV.Add(TOntoRltType(TOntoRltType::SimilarRltStr, false, false));
425  }
426  void TOntology::RefreshCptIdPosH() {
427      CptIdPosH.Clr();
428      for (int CptC = 0; CptC < ConceptV.Len(); CptC++) {
429          const int CptId = ConceptV[CptC]->GetId();
430          IAssertR(!CptIdPosH.IsKey(CptId), "Concept ID not unique!");
431          CptIdPosH.AddDat(CptId, CptC);
432      }
433  }
434  void TOntology::ReconnectToRoot() {
435      for (int CptC = 0; CptC < ConceptV.Len(); CptC++) {
436          const int CptId = ConceptV[CptC]->GetId();
437          if (!IsRootCpt(CptId) && !HasSuperCpt(CptId)) {
438              AddRlt(CptId, 0, TOntoRltType::SubCptOfRltStr);
439          }
440      }
441  }
442  void TOntology::AddRltsFromList(TIntStrPrV& InRltV, 
443          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV) {
444      for (int InEdN = 0; InEdN < InRltV.Len(); InEdN++) {
445          const int CptId1 = InRltV[InEdN].Val1;
446          TStr RltNm1 = InRltV[InEdN].Val2; Assert(IsRltDir(RltNm1));
447          for (int OutEdN = 0; OutEdN < OutRltV.Len(); OutEdN++) {
448              const int CptId2 = OutRltV[OutEdN].Val1;
449              TStr RltNm2 = OutRltV[OutEdN].Val2; Assert(IsRltDir(RltNm2));
450              if (CptId1 != CptId2 && RltNm1 == RltNm2) {
451                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
452                  if (!IsRltTransitive(RltNm1)) continue;
453                  AddRlt(CptId1, CptId2, RltNm1);
454              }
455          }
456      }
457      for (int InEdN = 0; InEdN < UndirRltV.Len(); InEdN++) {
458          const int CptId1 = UndirRltV[InEdN].Val1;
459          TStr RltNm1 = UndirRltV[InEdN].Val2; Assert(!IsRltDir(RltNm1));
460          for (int OutEdN = 0; OutEdN < UndirRltV.Len(); OutEdN++) {
461              const int CptId2 = UndirRltV[OutEdN].Val1;
462              TStr RltNm2 = UndirRltV[OutEdN].Val2; Assert(!IsRltDir(RltNm2));
463              if (CptId1 != CptId2 && RltNm1 == RltNm2) {
464                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
465                  if (!IsRltTransitive(RltNm1)) continue;
466                  AddRlt(CptId1, CptId2, RltNm1);
467              }
468          }
469      }
470  }
471  void TOntology::AddSonDIdV(const int& CptId, TIntV& SonDIdV) {
472      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
473      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
474          const int SubCptId = SubCptIdV[SubCptIdN];
475          TIntV SubCptDIdV; GetCptDIdV(SubCptId, SubCptDIdV);
476          SonDIdV.Union(SubCptDIdV);
477          AddSonDIdV(SubCptId, SonDIdV);
478      }
479  }
480  void TOntology::CfyDIdR(const int& DId, const TIntV& CptIdV, TIntFltKdV& CfyResV) {
481      for (int CptIdN = 0; CptIdN < CptIdV.Len(); CptIdN++) {
482          const int CptId = CptIdV[CptIdN];
483          POntoConcept Cpt = GetConcept(CptId);
484          if (Cpt->IsCptMd()) {
485              bool IsDocInCpt; double Prob;
486              Cpt->CfyDocSpV(BowDocWgtBs->GetSpV(DId), IsDocInCpt, Prob);
487              if (IsDocInCpt) {
488                  CfyResV.Add(TIntFltKd(CptId, Prob));
489                  TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
490                  CfyDIdR(DId, SubCptIdV, CfyResV);
491              }
492          }
493      }
494  }
495  void TOntology::Export(POntoExport OntoExport) {
496      OntoExport->StartExport();
497      TIntV CptIdV; GetCptIdV(CptIdV);
498      TIntIntVH DIdCptIdVH;
499      for (int CptN = 0; CptN < CptIdV.Len(); CptN++) {
500          const int CptId = CptIdV[CptN];
501          TStr CptNm = TXmlDoc::GetXmlStr(GetCptName(CptId));
502          if (OntoExport->IsCptAlwaysSvm()) { ExtractKeywords(CptId); }
503          TIntStrPrV SubCptIdNmV;
504          if (OntoExport->IsCptSubCptLink()) {
505              TIntStrPrV CptInRltV; GetCptInRltV(CptId, CptInRltV);
506              for (int SubCptN = 0; SubCptN < CptInRltV.Len(); SubCptN++) {
507                  TStr RltNm = CptInRltV[SubCptN].Val2;
508                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
509                      const int SubCptId = CptInRltV[SubCptN].Val1;
510                      TStr SubCptNm = GetCptName(SubCptId);
511                      SubCptIdNmV.Add(TIntStrPr(SubCptId, SubCptNm));
512                  }
513              }
514          }
515          TIntStrPrV SuperCptIdNmV;
516          if (OntoExport->IsCptSuperCptLink()) {
517              TIntStrPrV CptOutRltV; GetCptOutRltV(CptId, CptOutRltV);
518              for (int SuperCptN = 0; SuperCptN < CptOutRltV.Len(); SuperCptN++) {
519                  TStr RltNm = CptOutRltV[SuperCptN].Val2;
520                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
521                      const int SuperCptId = CptOutRltV[SuperCptN].Val1;
522                      TStr SuperCptNm = GetCptName(SuperCptId);
523                      SuperCptIdNmV.Add(TIntStrPr(SuperCptId, SuperCptNm));
524                  }
525              }
526          }
527          TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
528          for (int DocN = 0; DocN < CptDIdV.Len(); DocN++) {
529              const int DId = CptDIdV[DocN];
530              if (DIdCptIdVH.IsKey(DId)) {
531                  DIdCptIdVH.GetDat(DId).Add(CptId);
532              } else {
533                  DIdCptIdVH.AddDat(DId, TIntV::GetV(CptId));
534              }
535          }
536          if (!OntoExport->IsCptDocLink()) { CptDIdV.Clr(); }
537          OntoExport->PutCpt(CptId, CptNm, SubCptIdNmV, SuperCptIdNmV, 
538              CptDIdV, BowDocBs, GetConcept(CptId)->GetCentroidSpV(), 
539              GetConcept(CptId)->GetSvmSpV(), TBowSpV::New(-1));
540      }
541      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
542      for (int DocN = 0; DocN < AllDIdV.Len(); DocN++) {
543          const int DId = AllDIdV[DocN];
544          TStr DocTitle = BowDocBs->GetDocNm(DId);
545          TStr DocAbstract = BowDocBs->GetDocStr(DId);
546          TIntStrPrV CptIdNmV;
547          if (DIdCptIdVH.IsKey(DId) && OntoExport->IsDocCptLink()) {
548              TIntV& DocCptIdV = DIdCptIdVH.GetDat(DId);
549              for (int DocCptIdN = 0; DocCptIdN < DocCptIdV.Len(); DocCptIdN++) {
550                  const int CptId = DocCptIdV[DocCptIdN];
551                  TStr CptNm = GetCptName(CptId);
552                  CptIdNmV.Add(TIntStrPr(CptId, CptNm));
553              }
554          }
555          OntoExport->PutDoc(DId, DocTitle, DocAbstract, CptIdNmV);
556      }        
557      if (OntoExport->IsRlt()) {
558          const int RltTypes = GetRltTypes();
559          for (int RltTypeN = 0; RltTypeN < RltTypes; RltTypeN++) {
560              TStr RltTypeNm = GetRltTypeNm(RltTypeN);
561              if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
562                  OntoExport->PutRltType(RltTypeNm, 
563                      IsRltDir(RltTypeNm), IsRltTransitive(RltTypeNm));
564              }
565          }
566          for (int CptN = 0; CptN < CptIdV.Len(); CptN++) {
567              const int SrcCptId = CptIdV[CptN];
568              TStr SrcCptNm = GetCptName(SrcCptId);
569              TIntStrPrV CptOutRltV; GetCptOutRltV(SrcCptId, CptOutRltV);
570              for (int OutRltN = 0; OutRltN < CptOutRltV.Len(); OutRltN++) {
571                  const TStr& RltTypeNm = CptOutRltV[OutRltN].Val2;
572                  if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
573                      const int DstCptId = CptOutRltV[OutRltN].Val1;
574                      OntoExport->PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
575                          DstCptId, GetCptName(DstCptId));
576                  }
577              }
578              TIntStrPrV CptUndirRltV; GetCptUndirRltV(SrcCptId, CptUndirRltV);
579              for (int UndirRltN = 0; UndirRltN < CptUndirRltV.Len(); UndirRltN++) {
580                  const TStr& RltTypeNm = CptUndirRltV[UndirRltN].Val2;
581                  const int DstCptId = CptUndirRltV[UndirRltN].Val1;
582                  if (SrcCptId < DstCptId) {
583                      OntoExport->PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
584                          DstCptId, GetCptName(DstCptId));
585                  }
586              }
587          }
588      }
589      OntoExport->EndExport();
590  }
591  void TOntology::GetCptIdV(TIntV& CptIdV) {
592      CptIdV.Gen(ConceptV.Len(), 0);
593      for (int CptIdN = 0; CptIdN < ConceptV.Len(); CptIdN++) {
594          CptIdV.Add(ConceptV[CptIdN]->GetId());
595      }
596      CptIdV.Sort();
597  }
598  void TOntology::SetCptName(const int& CptId, const TStr& NewName) {
599      GetConcept(CptId)->SetName(NewName);
600      OntoGraph->GetVrtx(CptId)->PutDNm(NewName);
601  }
602  void TOntology::SetCptDIdV(const int& CptId, const TIntV& _NewDIdV, const bool& PropagateP) {
603      if (PropagateP) {
604          TIntV NewDIdV = _NewDIdV;
605          if (!NewDIdV.IsSorted()) { NewDIdV.Sort(); }
606          TIntV OldDIdV; GetCptDIdV(CptId, OldDIdV);
607          TIntV BothDIdV; OldDIdV.Union(NewDIdV, BothDIdV);
608          TIntV AddDIdV; BothDIdV.Diff(OldDIdV, AddDIdV);
609          AddUpDIdV(CptId, AddDIdV);
610          TIntV DelDIdV; BothDIdV.Diff(NewDIdV, DelDIdV);
611          DelDownDIdV(CptId, DelDIdV);
612      } else {
613          GetConcept(CptId)->SetDIdV(BowDocWgtBs, _NewDIdV);
614      }
615  }
616  void TOntology::GetCptSimV(const int& CptId, TFltIntKdV& SimCptIdV) {
617      PBowSpV CptSpV = GetConcept(CptId)->GetCentroidSpV();
618      SimCptIdV.Gen(GetConcepts() - 1, 0);
619      for (int CptN = 0; CptN < GetConcepts(); CptN++) {
620          const int CptId2 = ConceptV[CptN]->GetId();
621          if (CptId != CptId2) {
622              PBowSpV CptSpV2 = ConceptV[CptN]->GetCentroidSpV();
623              SimCptIdV.Add(TFltIntKd(BowSim->GetSim(CptSpV, CptSpV2), CptId2));
624          }
625      }
626      SimCptIdV.Sort(false);
627  }
628  void TOntology::CalcCptMd(const int& CptId, const double& SvmC, 
629          const double& SvmJ, const int& SvmTime) {
630      if (IsRootCpt(CptId)) return;
631      TIntV ContextDIdV; BowDocBs->GetAllDIdV(ContextDIdV);
632      GetConcept(CptId)->CalcCptMd(BowDocBs, ContextDIdV, SvmC, SvmJ, SvmTime);
633  }
634  void TOntology::CfyDId(const int& DId, TIntFltKdV& CfyResV) {
635      const int CptIds = GetConcepts(); CfyResV.Gen(CptIds, 0);
636      for (int CptIdN = 0; CptIdN < CptIds; CptIdN++) {
637          const int CptId = GetCptId(CptIdN);
638          POntoConcept Cpt = GetConcept(CptId);
639          if (Cpt->IsCptMd()) {
640              bool IsDocInCpt; double Prob;
641              Cpt->CfyDocSpV(BowDocWgtBs->GetSpV(DId), IsDocInCpt, Prob);
642              if (IsDocInCpt) {
643                  CfyResV.Add(TIntFltKd(CptId, Prob));
644              } else {
645                  CfyResV.Add(TIntFltKd(CptId, Prob - 1.0));
646              }
647          } else if (IsRootCpt(CptId)) {
648              CfyResV.Add(TIntFltKd(CptId, 1.0));
649          } else {
650              CfyResV.Add(TIntFltKd(CptId, -1.0));
651          }
652      }
653      CfyResV.Sort();
654  }
655  void TOntology::IncludeLnDocs(const TStr& LnDocFNm, TIntV& NewDIdV) {
656      TBowFl::LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, true, -1, true);    
657      NewDIdV.Sort(); ReCalcWgtBs(); 
658      GetRootCpt()->AddDIdV(BowDocWgtBs, NewDIdV); 
659  }
660  void TOntology::IncludeFolder(const TStr& FPath, TIntV& NewDIdV, const bool& RecurseDirP) {
661      TBowFl::LoadHtmlTxt(BowDocBs, FPath, NewDIdV, RecurseDirP, -1, true);
662      NewDIdV.Sort(); ReCalcWgtBs(); 
663      GetRootCpt()->AddDIdV(BowDocWgtBs, NewDIdV); 
664  }
665  void TOntology::AddDocToCptV(const int& DId, const TIntV& CptIdV, const bool& UpdateCentroidP) {
666      for (int CptIdN = 0; CptIdN < CptIdV.Len(); CptIdN++) {
667          const int CptId = CptIdV[CptIdN];
668          if (UpdateCentroidP) {
669              GetConcept(CptId)->AddDId(BowDocWgtBs, DId);
670          } else {
671              GetConcept(CptId)->AddDId(NULL, DId);
672          }
673      }
674  }
675  void TOntology::ResetAllCptKeyWd() {
676      const int CptIds = GetConcepts();
677      for (int CptIdN = 0; CptIdN < CptIds; CptIdN++) {
678          const int CptId = GetCptId(CptIdN);
679          if (!GetConcept(CptId)->IsCentroidValid()) {
680              GetConcept(CptId)->ResetCentroidSpV(BowDocWgtBs);
681          }
682      }
683  }
684  void TOntology::GetSubCptIdV(const int& CptId, TIntV& SubCptIdV) {
685      TIntStrPrV InRltV; GetCptInRltV(CptId, InRltV);
686      SubCptIdV.Gen(InRltV.Len(), 0);
687      for (int InRltN = 0; InRltN < InRltV.Len(); InRltN++) {
688          if (InRltV[InRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
689              SubCptIdV.Add(InRltV[InRltN].Val1);
690          }
691      }
692      SubCptIdV.Sort();
693  }
694  void TOntology::GetSuperCptIdV(const int& CptId, TIntV& SuperCptIdV) {
695      TIntStrPrV OutRltV; GetCptOutRltV(CptId, OutRltV);
696      SuperCptIdV.Gen(OutRltV.Len(), 0);
697      for (int OutRltN = 0; OutRltN < OutRltV.Len(); OutRltN++) {
698          if (OutRltV[OutRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
699              SuperCptIdV.Add(OutRltV[OutRltN].Val1);
700          }
701      }
702      SuperCptIdV.Sort();
703  }
704  void TOntology::GetCptUnusedDIdV(const int& CptId, TIntV& DIdV) {
705      GetConcept(CptId)->GetDIdV(DIdV);
706      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
707      for (int SubCptN = 0; SubCptN < SubCptIdV.Len(); SubCptN++) {
708          const int SubCptId = SubCptIdV[SubCptN];
709          TIntV SubDIdV; GetConcept(SubCptId)->GetDIdV(SubDIdV);
710          DIdV.Diff(SubDIdV);
711      }   
712  }
713  void TOntology::GetCptContextDIdV(const int& CptId, 
714          TIntV& ContextDIdV, const bool& AddSonDIdP) {
715      ContextDIdV.Clr();
716      GetConcept(CptId)->GetDIdV(ContextDIdV);
717      if (HasSuperCpt(CptId)) {
718          TIntV SuperCptIdV, SuperDIdV; GetSuperCptIdV(CptId, SuperCptIdV);
719          for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
720              const int SuperCptId = SuperCptIdV[SuperCptIdN];
721              GetConcept(SuperCptId)->GetDIdV(SuperDIdV);    
722              ContextDIdV.Union(SuperDIdV);
723          }
724      }
725      if (AddSonDIdP) AddSonDIdV(CptId, ContextDIdV);
726  }
727  void TOntology::GetInconsistDIdV(const int& CptId, TIntV& InconsistDIdV) {
728      InconsistDIdV.Clr();
729      TIntV SonDIdV; AddSonDIdV(CptId, SonDIdV);
730      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
731      SonDIdV.Union(CptDIdV); 
732      SonDIdV.Diff(CptDIdV, InconsistDIdV);
733  }
734  void TOntology::GetCptDocSimV(const int& CptId, const TIntV& DIdV, TFltV& CptDocSimV) {
735      PBowSpV CptSpV = GetConcept(CptId)->GetCentroidSpV();
736      const int Docs = DIdV.Len(); CptDocSimV.Gen(Docs, 0);
737      for (int DocN = 0; DocN < Docs; DocN++) {
738          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DIdV[DocN]);
739          CptDocSimV.Add(BowSim->GetSim(CptSpV, DocSpV));
740      }
741  }
742  void TOntology::AddUpDIdV(const int& CptId, const TIntV& SubDIdV) {
743      GetConcept(CptId)->AddDIdV(BowDocWgtBs, SubDIdV);
744      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
745      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
746          const int SuperCptId = SuperCptIdV[SuperCptIdN];
747          if (!IsRootCpt(SuperCptId)) { AddUpDIdV(SuperCptId, SubDIdV); }
748      }
749  }
750  void TOntology::DelUpDIdV(const int& CptId, const TIntV& SubDIdV) {
751      GetConcept(CptId)->DelDIdV(BowDocWgtBs, SubDIdV);
752      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
753      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
754          const int SuperCptId = SuperCptIdV[SuperCptIdN];
755          if (!IsRootCpt(SuperCptId)) { DelUpDIdV(SuperCptId, SubDIdV); }
756      }
757  }
758  void TOntology::DelDownDIdV(const int& CptId, const TIntV& SubDIdV) {
759      GetConcept(CptId)->DelDIdV(BowDocWgtBs, SubDIdV);
760      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
761      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
762          const int SubCptId = SubCptIdV[SubCptIdN];
763          DelDownDIdV(SubCptId, SubDIdV);
764      }
765  }
766  void TOntology::DelDownDId(const int& CptId, const int& DId) {
767      GetConcept(CptId)->DelDId(BowDocWgtBs, DId);
768      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
769      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
770          const int SubCptId = SubCptIdV[SubCptIdN];
771          DelDownDId(SubCptId, DId);
772      }
773  }
774  void TOntology::GetCptInRltV(const int& CptId, TIntStrPrV& InRltV) {
775      POntoConcept Cpt = GetConcept(CptId);
776      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
777      InRltV.Gen(CptVrtx->GetInEIds(), 0);
778      for (int InEIdN = 0; InEIdN < CptVrtx->GetInEIds(); InEIdN++) {
779          PEdge InEdge = OntoGraph->GetEdge(CptVrtx->GetInEId(InEIdN));
780          if (InEdge->IsDir()) 
781              InRltV.Add(TIntStrPr(InEdge->GetOtherVId(CptVrtx), InEdge->GetDNm()));
782      }
783      InRltV.Sort();
784  }
785  void TOntology::GetCptOutRltV(const int& CptId, TIntStrPrV& OutRltV) {
786      POntoConcept Cpt = GetConcept(CptId);
787      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
788      OutRltV.Gen(CptVrtx->GetOutEIds(), 0);
789      for (int OutEIdN = 0; OutEIdN < CptVrtx->GetOutEIds(); OutEIdN++) {
790          PEdge OutEdge = OntoGraph->GetEdge(CptVrtx->GetOutEId(OutEIdN));
791          if (OutEdge->IsDir()) 
792              OutRltV.Add(TIntStrPr(OutEdge->GetOtherVId(CptVrtx), OutEdge->GetDNm()));
793      }
794      OutRltV.Sort();
795  }
796  void TOntology::GetCptUndirRltV(const int& CptId, TIntStrPrV& UndirRltV) {
797      POntoConcept Cpt = GetConcept(CptId);
798      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
799      UndirRltV.Gen(CptVrtx->GetOutEIds(), 0);
800      for (int OutEIdN = 0; OutEIdN < CptVrtx->GetOutEIds(); OutEIdN++) {
801          PEdge OutEdge = OntoGraph->GetEdge(CptVrtx->GetOutEId(OutEIdN));
802          if (!OutEdge->IsDir()) 
803              UndirRltV.Add(TIntStrPr(OutEdge->GetOtherVId(CptVrtx), OutEdge->GetDNm()));
804      }
805      UndirRltV.Sort();
806  }
807  void TOntology::GetCptRltV(const int& CptId, TIntStrPrV& InRltV, 
808          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV) {
809      GetCptInRltV(CptId, InRltV);
810      GetCptOutRltV(CptId, OutRltV); 
811      GetCptUndirRltV(CptId, UndirRltV); 
812  }
813  int TOntology::GetRltTypeN(const TStr& RltTypeNm) const {
814      for (int RltTypeN = 0; RltTypeN < RltTypeV.Len(); RltTypeN++) {
815          if (RltTypeV[RltTypeN].IsType(RltTypeNm)) {
816              return RltTypeN;
817          }
818      }
819      return -1;
820  }
821  bool TOntology::IsRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
822      Assert(IsCptId(CptId1) && IsCptId(CptId2));
823      PEdge Edge; 
824      if (OntoGraph->IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
825          return (Edge->GetDNm() == RltTypeNm);
826      }
827      return false;
828  }
829  void TOntology::AddRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
830      Assert(IsCptId(CptId1) && IsCptId(CptId2));
831      const bool IsDir = IsRltDir(RltTypeNm);
832      PEdge NewEdge = TGEdge::New(OntoGraph->GetVrtx(CptId1), 
833          OntoGraph->GetVrtx(CptId2), RltTypeNm, IsDir);
834      NewEdge->PutDNm(RltTypeNm);
835      OntoGraph->AddEdge(NewEdge);
836  }
837  bool TOntology::DelRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
838      Assert(IsCptId(CptId1) && IsCptId(CptId2));
839      PEdge Edge; bool DeletedP = false;
840      if (OntoGraph->IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
841          if (Edge->GetDNm() == RltTypeNm) {
842              OntoGraph->DelEdge(Edge);
843              DeletedP = true;
844          } else {
845              InfoNotify("There is no such relationship!!");
846          }
847      } else {
848          InfoNotify("There is no such relationship");
849          AssertR(false, TStr("There is no such relationship"));
850      }
851      ReconnectToRoot();
852      return DeletedP;
853  }
854  void TOntology::SuggestConcepts(const TIntV& DIdV, const TOntoSuggestAlgType& AlgType, 
855          const int& NewConceptN, TOntoConceptV& NewConceptV) {
856      NewConceptV.Clr();
857      if ((DIdV.Len() > NewConceptN) || (NewConceptN == -1)) {
858          if (AlgType == osatKMeans) {
859              TOntoAlg::SuggestKMeans(BowDocBs, BowDocWgtBs, DIdV, 
860                  NewConceptN, UniqueId, NewConceptV);
861          } else if (AlgType == osatCat) {
862              TOntoAlg::SuggestCat(BowDocBs, BowDocWgtBs, DIdV, 
863                  UniqueId, NewConceptV);
864          }
865      }
866  }
867  void TOntology::SuggestSubconcepts(const int& CptId, const TOntoSuggestAlgType& AlgType, 
868          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV) {
869      TIntV DIdV; 
870      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
871      else {  GetConcept(CptId)->GetDIdV(DIdV); }
872      SuggestConcepts(DIdV, AlgType, NewConceptN, NewConceptV);
873  }
874  void TOntology::SuggestSubconcepts(const int& CptId, const PLwOntoCfier& LwOntoCfier,
875          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV) {
876      TIntV DIdV; 
877      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
878      else {  GetConcept(CptId)->GetDIdV(DIdV); }
879      NewConceptV.Clr();
880      if (DIdV.Len() > NewConceptN) {
881          TOntoAlg::SuggestLwOntoCfier(BowDocBs, BowDocWgtBs,
882              DIdV, LwOntoCfier, NewConceptN, UniqueId, NewConceptV);
883      }
884  }
885  POntoConcept TOntology::GenSubconcept(const TStr& NewCptNm, const TIntV& NewCptDIdV) {
886      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
887          UniqueId->GetNextId(), NewCptNm, NewCptDIdV);
888  }
889  POntoConcept TOntology::GenSubconcept(const TIntV& NewCptDIdV) {
890      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
891          UniqueId->GetNextId(), NewCptDIdV);
892  }
893  void TOntology::SuggestConceptNm(const int& CptId, const TVec<PLwOntoCfier>& LwOntoCfierV, 
894          const int& MxSuggestNms, TStrV& SuggestNmV, TIntV& SuggestSuppV, TIntV& SuggestVocNV) {
895      TIntPrIntH TermIdVocNFqH; TIntV DIdV; GetCptDIdV(CptId, DIdV); 
896      for (int VocN = 0; VocN < LwOntoCfierV.Len(); VocN++) {
897          PLwOntoCfier LwOntoCfier = LwOntoCfierV[VocN];
898          PLwTermBs LwTermBs = LwOntoCfier->GetLwOnto()->GetTermBs();
899          for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
900              const int DId = DIdV[DIdN];
901              TStr DocStr = BowDocBs->GetDocStr(DId);
902              TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
903              LwOntoCfier->ClassifyStr(DocStr, SimTermIdPrV);
904              const int TermIds = TInt::GetMn(3, SimTermIdPrV.Len());
905              for (int TermIdN = 0; TermIdN < TermIds; TermIdN++) {
906                  const int TermId = SimTermIdPrV[TermIdN].Val2;
907                  TIntPr TermIdVocN(TermId, VocN);
908                  TStr TermNm = LwTermBs->GetTerm(TermId)->GetTermNm();
909                  if (TermIdVocNFqH.IsKey(TermIdVocN)) { TermIdVocNFqH(TermIdVocN)++; } 
910                  else { TermIdVocNFqH.AddDat(TermIdVocN, 1); }
911              }             
912          }
913      }
914      TIntIntPrPrV TermFqIdVocNV; TermIdVocNFqH.GetDatKeyPrV(TermFqIdVocNV); 
915      TermFqIdVocNV.Sort(false);
916      SuggestNmV.Clr(); SuggestSuppV.Clr(); SuggestVocNV.Clr();
917      const int SuggestNms = TInt::GetMn(MxSuggestNms, TermFqIdVocNV.Len());
918      for (int SuggestNmN = 0; SuggestNmN < SuggestNms; SuggestNmN++) {
919          const int TermId = TermFqIdVocNV[SuggestNmN].Val2.Val1;
920          const int Supp = TermFqIdVocNV[SuggestNmN].Val1;
921          const int VocN = TermFqIdVocNV[SuggestNmN].Val2.Val2;
922          PLwTermBs LwTermBs = LwOntoCfierV[VocN]->GetLwOnto()->GetTermBs();
923          TStr TermNm = LwTermBs->GetTerm(TermId)->GetTermNm();
924          SuggestNmV.Add(TermNm); 
925          SuggestSuppV.Add(Supp); 
926          SuggestVocNV.Add(VocN);
927      }
928  }
929  void TOntology::AddConcept(const POntoConcept& NewCpt, const int& FatherCptId) {
930      const int NewCptId = NewCpt->GetId();
<span onclick='openModal()' class='match'>931      IAssertR(!IsCptId(NewCptId), "There already is a conceptwith the same ID!");
932      ConceptV.Add(NewCpt); RefreshCptIdPosH();
933      TStr NewCptIdStr = TStr::Fmt("Cpt%d", NewCptId);
934      PVrtx NewCptVrtx = TGVrtx::New(NewCptId, NewCptIdStr);
935      TStr Name = NewCpt->GetName(); Name.ChangeChAll(' ', '\\');
</span>936      NewCptVrtx->PutDNm(Name); 
937      NewCptVrtx->PutShape("Rect");
938      OntoGraph->AddVrtx(NewCptVrtx);
939      if (FatherCptId >= 0) {
940          IAssertR(IsCptId(FatherCptId), "There is no such concept!");
941          AddRlt(NewCptId, FatherCptId, TOntoRltType::SubCptOfRltStr);
942      } else {
943          IAssert(ConceptV.Len() == 1);
944      }
945  }
946  void TOntology::BreakConcept(const int& OldCptId, const TOntoConceptV& NewCptV) {
947      if (IsRootCpt(OldCptId)) return; 
948      IAssert(!NewCptV.Empty());
949      IAssertR(IsCptId(OldCptId), "There is no such concept!");
950      for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
951          POntoConcept NewCpt = NewCptV[CptC];
952          const int NewCptId = NewCpt->GetId();
953          IAssertR(!IsCptId(NewCptId), 
954              "There already is a concept with the same ID!");
955          ConceptV.Add(NewCpt); RefreshCptIdPosH();
956          TStr Name = NewCpt->GetName(); Name.ChangeStrAll(" ", "\\");
957          PVrtx v = TGVrtx::New(NewCptId, Name.CStr());
958          OntoGraph->AddVrtx(v);
959      }
960      TIntStrPrV InRltV, OutRltV, UndirRltV;
961      GetCptRltV(OldCptId, InRltV, OutRltV, UndirRltV);
962      for (int InRltN = 0; InRltN < InRltV.Len(); InRltN++) { 
963          const int VrtxId1 = InRltV[InRltN].Val1;
964          TStr RltNm = InRltV[InRltN].Val2;
965          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
966              const int NewCptId = NewCptV[CptC]->GetId();
967              AddRlt(VrtxId1, NewCptId, RltNm);
968          }
969      }
970      for (int OutRltN = 0; OutRltN < OutRltV.Len(); OutRltN++) {
971          const int VrtxId2 = OutRltV[OutRltN].Val1;
972          TStr RltNm = OutRltV[OutRltN].Val2;
973          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
974              const int NewCptId = NewCptV[CptC]->GetId();
975              AddRlt(NewCptId, VrtxId2, RltNm);
976          }
977      }
978      for (int UndirRltN = 0; UndirRltN < UndirRltV.Len(); UndirRltN++) {
979          const int VrtxId2 = UndirRltV[UndirRltN].Val1;
980          TStr RltNm = UndirRltV[UndirRltN].Val2;
981          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
982              const int NewCptId = NewCptV[CptC]->GetId();
983              AddRlt(NewCptId, VrtxId2, RltNm);
984          }
985      }
986      ConceptV.Del(CptIdPosH.GetDat(OldCptId)); RefreshCptIdPosH();
987      OntoGraph->DelVrtx(OldCptId); ReconnectToRoot();
988  }
989  void TOntology::PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId) {
990      if (FatherCptId == 0) return; 
991      IAssertR(IsCptId(FatherCptId), "There is no such concept!");
992      TIntV SubCptDIdV; SubCpt->GetDIdV(SubCptDIdV);
993      GetConcept(FatherCptId)->DelDIdV(BowDocWgtBs, SubCptDIdV);
994  }
995  void TOntology::DeleteConcept(const int& CptId, const bool& DoRedirect) {
996      if (IsRootCpt(CptId)) return; 
997      IAssertR(IsCptId(CptId), "There is no such concept!");
998      if (DoRedirect) {
999          TIntStrPrV InRltV, OutRltV, UndirRltV;
1000          GetCptRltV(CptId, InRltV, OutRltV, UndirRltV);
1001          AddRltsFromList(InRltV, OutRltV, UndirRltV);
1002      }
1003      ConceptV.Del(CptIdPosH.GetDat(CptId)); RefreshCptIdPosH();
1004      OntoGraph->DelVrtx(CptId); ReconnectToRoot();
1005  }
1006  void TOntology::UniteConcepts(const int& CptId1, const int& CptId2) {
1007  }
1008  void TOntology::CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP) {
1009      if (IsRootCpt(CptId)) return; 
1010      IAssertR(IsCptId(CptId), "There is no such concept!");
1011      IAssertR(IsCptId(NewFatherCptId), "There is no such concept!");
1012      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
1013      SuperCptIdV.DelIfIn(NewFatherCptId);
1014      if (SuperCptIdV.Empty()) return; 
1015      AddRlt(CptId, NewFatherCptId, TOntoRltType::SubCptOfRltStr);
1016      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
1017          const int SuperCptId = SuperCptIdV[SuperCptIdN];
1018          DelRlt(CptId, SuperCptId, TOntoRltType::SubCptOfRltStr);
1019      }
1020      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1021      if (MoveP) {
1022          for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
1023              const int SuperCptId = SuperCptIdV[SuperCptIdN];
1024              DelUpDIdV(SuperCptId, CptDIdV);
1025          }
1026      }
1027      AddUpDIdV(NewFatherCptId, CptDIdV);
1028  }
1029  void TOntology::NewConcept() {
1030      POntoConcept Cpt = TOntoConcept::New(BowDocBs, 
1031          BowDocWgtBs, UniqueId->GetNextId(), "New Concept", TIntV());
1032      IAssert(ConceptV[0]->GetId() == 0);
1033      AddConcept(Cpt, 0);
1034  }
1035  void TOntology::ExtractKeywords(const int& CptId) {
1036      if (IsRootCpt(CptId)) return;
1037      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1038      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1039      PBowSpV SvmSpV;
1040      if (CptDIdV.Len() > 0) {
1041          SvmSpV = TBowSVMMd::GetKeywords(BowDocBs, ContextDIdV, CptDIdV, 50, 1.0, 5.0);
1042      } else {
1043          SvmSpV = TBowSpV::New();
1044      }
1045      GetConcept(CptId)->SetSvmSpV(SvmSpV);
1046  }
1047  void TOntology::CalcCptCompactness(const int& CptId) {
1048      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1049      if (CptDIdV.Len() > 0) {
1050          PBowSpV CentroidSpV = GetConcept(CptId)->GetCentroidSpV();
1051          double Qual = 0.0; 
1052          for (int DIdN = 0; DIdN < CptDIdV.Len(); DIdN++) {
1053              const int DId = CptDIdV[DIdN];
1054              PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
1055              Qual += BowSim->GetSim(CentroidSpV, DocSpV);
1056          }
1057          GetConcept(CptId)->SetCompactness(Qual / CptDIdV.Len());
1058      } else {
1059          GetConcept(CptId)->SetCompactness(1.0);
1060      }
1061  }
1062  void TOntology::CalcCptClarity(const int& CptId) {
1063      if (IsRootCpt(CptId)) return;
1064      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1065      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1066      if (CptDIdV.Len() > 20) {
1067          TCfyRes CfyRes = TBowSVMMd::CrossValidClsLinear(
1068              5, 1, BowDocBs, BowDocWgtBs, ContextDIdV, CptDIdV, 1, 5.0);
1069          const double Clarity = CfyRes.BreakEvenPoint();
1070          GetConcept(CptId)->SetClarity(Clarity);
1071      }
1072  }
1073  void TOntology::PrepareGraph(const int& SelectedCptId) {
1074      IAssert(GetConcepts() > 0);
1075      if (IsCptId(SelectedCptId)) {
1076          TStr VrtxNm = OntoGraph->GetVrtx(SelectedCptId)->GetDNm();
1077          OntoGraph->GetPp()->PutValStr("BoldVNm", VrtxNm);
1078      }
1079  }
1080  void TOntology::PlaceGraph() {
1081      IAssert(GetConcepts() > 0);
1082      PVrtx RootVrtx = OntoGraph->GetVrtx(0);
1083      OntoGraph->PlaceGraphAsStar(RootVrtx, TOntoRltType::SubCptOfRltStr);
1084      OntoGraph->RescaleXY(0.1, RootVrtx);
1085  }
1086  void TOntology::ExportPTO(const TStr& FNm, const bool& DigLibP) { 
1087      PSOut SOut = TFOut::New(FNm);
1088      TStr BowFNm = FNm + ".bow"; BowDocBs->SaveBin(BowFNm);
1089      POntoExport OntoExport = TOntoExportPTO::New(SOut, DigLibP, BowFNm);
1090      this->Export(OntoExport);
1091  }
1092  void TOntology::ExportProlog(const TStr& FNm) {
1093      PSOut SOut = TFOut::New(FNm);
1094      POntoExport OntoExport = TOntoExportProlog::New(SOut);
1095      this->Export(OntoExport);
1096  }
1097  void TOntology::ExportOwl(const TStr& FNm, const bool& StoreDocsP, const bool& StoreAbstractsP) {
1098      PSOut SOut = TFOut::New(FNm);
1099      POntoExport OntoExport = TOntoExportOWL::New(SOut, StoreDocsP, StoreAbstractsP);
1100      this->Export(OntoExport);
1101  }
1102  POntology TOntology::ImportPTO(const TStr& RdfFNm, const TStr& BowFNm) {
1103      PBowDocBs BowDocBs = TBowDocBs::LoadBin(BowFNm);
1104      const int MnWordFq = BowDocBs->GetDocs() > 111 ? 5 : 3;
1105      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1106          BowDocBs, bwwtLogDFNrmTFIDF, 0.2, MnWordFq);
1107      POntology Onto = TOntology::New(BowDocBs, BowDocWgtBs, bstCos);
1108      PXmlDoc Rdf = TXmlDoc::LoadTxt(RdfFNm);
1109      IAssertR(Rdf->IsOk(), "Wrong RDF format");
1110      TStrIntH TopicUriIdH;
1111      PXmlTok RootTok; IAssert(Rdf->IsTagTok("rdf:RDF", RootTok));
1112      TXmlTokV TopicV; RootTok->GetTagTokV("ptop:Topic", TopicV);
1113      TXmlTokV DocV; RootTok->GetTagTokV("ptop:Document", DocV);
1114      TXmlTokV DocPropV; RootTok->GetTagTokV("jsikm:OntoGenInstanceProperties", DocPropV);
1115      TIntIntVH TopicIdDocIdVH; TopicIdDocIdVH.AddDat(0, TIntV());
1116      for (int TopicN = 0; TopicN < TopicV.Len(); TopicN++) {
1117          PXmlTok TopicTok = TopicV[TopicN];
1118          TStr TopicURI = TopicTok->GetArgVal("rdf:about");
1119          TStr TopicName = TopicTok->GetTagTok("psys:description")->GetTagTokStr("");
1120          int UnderScorePos = TopicURI.SearchCh('_');
1121          TStr TopicURIPrefix = TopicURI.Left(UnderScorePos);
1122          if (TopicURIPrefix != "#Cpt0" && TopicURI != "#TOP_0") {
1123              const int TopicId = Onto->UniqueId->GetNextId(); 
1124              POntoConcept TopicCpt = TOntoConcept::New(Onto->BowDocBs, 
1125                  Onto->BowDocWgtBs, TopicId, TopicName, TIntV());
1126              Onto->AddConcept(TopicCpt, 0);
1127              TopicUriIdH.AddDat(TopicURI, TopicId);
1128              TopicIdDocIdVH.AddDat(TopicId, TIntV());
1129          } else {
1130              Onto->SetCptName(0, TopicName);
1131              TopicUriIdH.AddDat(TopicURI, 0);
1132          }        
1133      }
1134      for (int TopicN = 0; TopicN < TopicV.Len(); TopicN++) {
1135          PXmlTok TopicTok = TopicV[TopicN];
1136          TStr TopicURI = TopicTok->GetArgVal("rdf:about");
1137          const int TopicId = TopicUriIdH.GetDat(TopicURI);
1138          bool ConnectedToRoot = false;
1139          if (TopicId > 0) {
1140              TXmlTokV SuperTopicV; TopicTok->GetTagTokV("ptop:subTopicOf", SuperTopicV);
1141              for (int SupTopN = 0; SupTopN < SuperTopicV.Len(); SupTopN++) {
1142                  TStr SuperTopicURI = SuperTopicV[SupTopN]->GetArgVal("rdf:resource");
1143                  const int SuperTopicId = TopicUriIdH.GetDat(SuperTopicURI);
1144                  if (SuperTopicId == 0) {
1145                      ConnectedToRoot = true;
1146                  } else {            
1147                      Onto->AddRlt(TopicId, SuperTopicId, TOntoRltType::SubCptOfRltStr);
1148                  }
1149              }
1150              if (!ConnectedToRoot) {
1151                  Onto->DelRlt(TopicId, 0, TOntoRltType::SubCptOfRltStr);
1152              }
1153          }
1154      }
1155      TStrIntH DocPropIdH;
1156      for (int DocN = 0; DocN < DocPropV.Len(); DocN++) {
1157          PXmlTok DocPropTok = DocPropV[DocN];
1158          TStr DocPropURI = DocPropTok->GetArgVal("rdf:about");
1159          TStr Link = DocPropTok->GetTagTok("jsikm:locationOfInstance")->GetTagTokStr("");
1160          TStrV LinkPartV; Link.SplitOnAllCh('#', LinkPartV);
1161          IAssert(LinkPartV.Len() == 2);
1162          const int DocId = LinkPartV[1].GetInt();
1163          IAssert(BowDocBs->IsDId(DocId));
1164          DocPropIdH.AddDat(DocPropURI, DocId);
1165      }
1166      for (int DocN = 0; DocN < DocV.Len(); DocN++) {
1167          PXmlTok DocTok = DocV[DocN];
1168          TStr DocPropURI = DocTok->GetTagTok("jsikm:hasOntoGenInstanceProperties")->GetArgVal("rdf:resource");
1169          const int DocId = DocPropIdH.GetDat(DocPropURI);
1170          TopicIdDocIdVH.GetDat(0).Add(DocId);
1171          TXmlTokV SubjectTopicV; DocTok->GetTagTokV("ptop:hasSubject", SubjectTopicV);
1172          for (int SubjectN = 0; SubjectN < SubjectTopicV.Len(); SubjectN++) {
1173              PXmlTok SubjectTok = SubjectTopicV[SubjectN];
1174              TStr SubjectUri = SubjectTok->GetArgVal("rdf:resource");
1175              const int SubjectId = TopicUriIdH.GetDat(SubjectUri);
1176              if (SubjectId > 0) {
1177                  IAssert(TopicIdDocIdVH.IsKey(SubjectId));
1178                  TopicIdDocIdVH.GetDat(SubjectId).Add(DocId);
1179              }
1180          }
1181      }
1182      int KeyId = TopicIdDocIdVH.FFirstKeyId();
1183      while (TopicIdDocIdVH.FNextKeyId(KeyId)) {
1184          const int TopicId = TopicIdDocIdVH.GetKey(KeyId);
1185          Onto->SetCptDIdV(TopicId, TopicIdDocIdVH.GetDat(TopicId), false);
1186      }
1187      return Onto;
1188  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</div>
                </div>
                <div class="column column_space"><pre><code>99    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
100      BLOBNBOX *blob = blob_it.data();
101      const TBOX &box = blob->bounding_box();
102      float y_x = static_cast<float>(box.height()) / box.width();
</pre></code></div>
                <div class="column column_space"><pre><code>931      IAssertR(!IsCptId(NewCptId), "There already is a conceptwith the same ID!");
932      ConceptV.Add(NewCpt); RefreshCptIdPosH();
933      TStr NewCptIdStr = TStr::Fmt("Cpt%d", NewCptId);
934      PVrtx NewCptVrtx = TGVrtx::New(NewCptId, NewCptIdStr);
935      TStr Name = NewCpt->GetName(); Name.ChangeChAll(' ', '\\');
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    