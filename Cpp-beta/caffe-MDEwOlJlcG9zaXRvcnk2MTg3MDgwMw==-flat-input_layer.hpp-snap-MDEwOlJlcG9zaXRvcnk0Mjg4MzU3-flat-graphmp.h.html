
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.418803418803419%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-input_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_INPUT_LAYER_HPP_
2  #define CAFFE_INPUT_LAYER_HPP_
3  #include <vector>
4  #include "caffe/blob.hpp"
5  #include "caffe/layer.hpp"
6  #include "caffe/proto/caffe.pb.h"
7  namespace caffe {
8  template <typename Dtype>
9  class InputLayer : public Layer<Dtype> {
10   public:
11    explicit InputLayer(const LayerParameter& param)
<span onclick='openModal()' class='match'>12        : Layer<Dtype>(param) {}
13    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
14        const vector<Blob<Dtype>*>& top);
</span>15    virtual inline bool ShareInParallel() const { return true; }
16    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
17        const vector<Blob<Dtype>*>& top) {}
18    virtual inline const char* type() const { return "Input"; }
19    virtual inline int ExactNumBottomBlobs() const { return 0; }
20    virtual inline int MinTopBlobs() const { return 1; }
21   protected:
22    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
23        const vector<Blob<Dtype>*>& top) {}
24    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
25        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {}
26  };
27  }  
28  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp.h</h3>
            <pre><code>1  #ifndef GRAPHMP_H
2  #define GRAPHMP_H
3  #ifdef GCC_ATOMIC
4  class TNGraphMP;
5  typedef TPt<TNGraphMP> PNGraphMP;
6  class TNGraphMP {
7  public:
8    typedef TNGraphMP TNet;
9    typedef TPt<TNGraphMP> PNet;
10  public:
11    class TNode {
12    private:
13      TInt Id;
14      TIntV InNIdV, OutNIdV;
15    public:
16      TNode() : Id(-1), InNIdV(), OutNIdV() { }
17      TNode(const int& NId) : Id(NId), InNIdV(), OutNIdV() { }
18      TNode(const TNode& Node) : Id(Node.Id), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
19      TNode(TSIn& SIn) : Id(SIn), InNIdV(SIn), OutNIdV(SIn) { }
20      void Save(TSOut& SOut) const { Id.Save(SOut); InNIdV.Save(SOut); OutNIdV.Save(SOut); }
21      int GetId() const { return Id; }
22      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
23      int GetInDeg() const { return InNIdV.Len(); }
24      int GetOutDeg() const { return OutNIdV.Len(); }
25      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
26      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
27      int GetNbrNId(const int& NodeN) const { return NodeN<GetOutDeg()?GetOutNId(NodeN):GetInNId(NodeN-GetOutDeg()); }
28      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId) != -1; }
29      bool IsOutNId(const int& NId) const { return OutNIdV.SearchBin(NId) != -1; }
30      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
31      void PackOutNIdV() { OutNIdV.Pack(); }
32      void PackNIdV() { InNIdV.Pack(); }
33      void SortNIdV() { InNIdV.Sort(); OutNIdV.Sort();}
34      friend class TNGraphMP;
35    };
36    class TNodeI {
37    private:
38      typedef THashMP<TInt, TNode>::TIter THashIter;
39      THashIter NodeHI;
40    public:
41      TNodeI() : NodeHI() { }
42      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
43      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
44      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
45      TNodeI& operator++ (int) { NodeHI++; return *this; }
46      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
47      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
48      int GetId() const { return NodeHI.GetDat().GetId(); }
49      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
50      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
51      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
52      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
53      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
54      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
55      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
56      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
57      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
58      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
59      friend class TNGraphMP;
60    };
61    class TEdgeI {
62    private:
63      TNodeI CurNode, EndNode;
64      int CurEdge;
65    public:
66      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
67      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
68      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
69      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
70      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
71        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
72      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
73      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
74      int GetId() const { return -1; }
75      int GetSrcNId() const { return CurNode.GetId(); }
76      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
77      friend class TNGraphMP;
78    };
79  private:
80    TCRef CRef;
81    TInt MxNId;
82    THashMP<TInt, TNode> NodeH;
83  private:
84    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
85    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
86  public:
87    TNGraphMP() : CRef(), MxNId(0), NodeH() { }
88    explicit TNGraphMP(const int& Nodes, const int& Edges) : MxNId(0) { Reserve(Nodes, Edges); }
89    TNGraphMP(const TNGraphMP& Graph) : MxNId(Graph.MxNId), NodeH(Graph.NodeH) { }
90    TNGraphMP(TSIn& SIn) : MxNId(SIn), NodeH(SIn) { }
91    void Save(TSOut& SOut) const { MxNId.Save(SOut); NodeH.Save(SOut); }
92    static PNGraphMP New() { return new TNGraphMP(); }
93    static PNGraphMP New(const int& Nodes, const int& Edges) { return new TNGraphMP(Nodes, Edges); }
94    static PNGraphMP Load(TSIn& SIn) { return PNGraphMP(new TNGraphMP(SIn)); }
95    bool HasFlag(const TGraphFlag& Flag) const;
96    TNGraphMP& operator = (const TNGraphMP& Graph) {
97      if (this!=&Graph) { MxNId=Graph.MxNId; NodeH=Graph.NodeH; }  return *this; }
98    int GetNodes() const { return NodeH.Len(); }
99    void SetNodes(const int& Length) { NodeH.SetLen(Length); }
100    int AddNode(int NId = -1);
101    int AddNodeUnchecked(int NId = -1);
<span onclick='openModal()' class='match'>102    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
103    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
104    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
</span>105    void DelNode(const int& NId);
106    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
107    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
108    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
109    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
110    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
111    int GetMxNId() const { return MxNId; }
112    int Reserved() const {return NodeH.GetReservedKeyIds();}
113    int GetEdges() const;
114    int AddEdge(const int& SrcNId, const int& DstNId);
115    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
116    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
117    int AddOutEdge1(int& SrcIdx, const int& SrcNId, const int& DstNId);
118    int AddInEdge1(int& DstIdx, const int& SrcNId, const int& DstNId);
119    void AddOutEdge2(const int& SrcNId, const int& DstNId);
120    void AddInEdge2(const int& SrcNId, const int& DstNId);
121    void AddNodeWithEdges(const TInt& NId, TIntV& InNIdV, TIntV& OutNIdV);
122    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
123    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
124    TEdgeI BegEI() const { TNodeI NI=BegNI(); while(NI<EndNI() && NI.GetOutDeg()==0){NI++;} return TEdgeI(NI, EndNI()); }
125    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
126    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
127    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
128    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
129    void GetNIdV(TIntV& NIdV) const;
130    bool Empty() const { return GetNodes()==0; }
131    void Clr() { MxNId=0; NodeH.Clr(); }
132    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes); } }
133    void ReserveNodeDegs(const int& Idx, const int& InDeg, const int& OutDeg) { if (InDeg > 0) NodeH[Idx].InNIdV.Reserve(InDeg); if (OutDeg > 0) NodeH[Idx].OutNIdV.Reserve(OutDeg); }
134    void ReserveNIdInDeg(const int& NId, const int& InDeg) { GetNode(NId).InNIdV.Reserve(InDeg); }
135    void ReserveNIdOutDeg(const int& NId, const int& OutDeg) { GetNode(NId).OutNIdV.Reserve(OutDeg); }
136    void SortEdges(const int& Idx, const int& InDeg, const int& OutDeg) { if (InDeg > 0) NodeH[Idx].InNIdV.Sort(); if (OutDeg > 0) NodeH[Idx].OutNIdV.Sort(); }
137    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
138    void Defrag(const bool& OnlyNodeLinks=false);
139    bool IsOk(const bool& ThrowExcept=true) const;
140    void Dump(FILE *OutF=stdout) const;
141    static PNGraphMP GetSmallGraph();
142    friend class TPt<TNGraphMP>;
143    friend class TNGraphMPMtx;
144  };
145  namespace TSnap {
146  template <> struct IsDirected<TNGraphMP> { enum { Val = 1 }; };
147  }
148  #else
149  #endif 
150  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-input_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp.h</div>
                </div>
                <div class="column column_space"><pre><code>12        : Layer<Dtype>(param) {}
13    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
14        const vector<Blob<Dtype>*>& top);
</pre></code></div>
                <div class="column column_space"><pre><code>102    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
103    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
104    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    