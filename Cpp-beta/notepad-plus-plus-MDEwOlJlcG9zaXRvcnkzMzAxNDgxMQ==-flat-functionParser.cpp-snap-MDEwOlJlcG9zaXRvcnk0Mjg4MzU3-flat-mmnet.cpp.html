
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.41264967761744%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-functionParser.cpp</h3>
            <pre><code>1  #include <shlwapi.h>
2  #include "ScintillaEditView.h"
3  #include "functionParser.h"
4  #include "BoostRegexSearch.h"
5  using namespace std;
6  FunctionParsersManager::~FunctionParsersManager()
7  {
8  	for (size_t i = 0, len = L_EXTERNAL + nbMaxUserDefined; i < len; ++i)
9  	{
10  		if (_parsers[i] != nullptr)
11  			delete _parsers[i];
12  	}
13  }
14  bool FunctionParsersManager::init(const generic_string& xmlDirPath, const generic_string& xmlInstalledPath, ScintillaEditView ** ppEditView)
15  {
16  	_ppEditView = ppEditView;
17  	_xmlDirPath = xmlDirPath;
18  	_xmlDirInstalledPath = xmlInstalledPath;
19  	bool isOK = getOverrideMapFromXmlTree(_xmlDirPath);
20  	if (isOK)
21  		return true;
22  	else if (_xmlDirPath != _xmlDirInstalledPath && !_xmlDirInstalledPath.empty())
23  		return getOverrideMapFromXmlTree(_xmlDirInstalledPath);
24  	else
25  		return false;
26  }
27  bool FunctionParsersManager::getZonePaserParameters(TiXmlNode *classRangeParser, generic_string &mainExprStr, generic_string &openSymboleStr, generic_string &closeSymboleStr, std::vector<generic_string> &classNameExprArray, generic_string &functionExprStr, std::vector<generic_string> &functionNameExprArray)
28  {
29  	const TCHAR *mainExpr = NULL;
30  	const TCHAR *openSymbole = NULL;
31  	const TCHAR *closeSymbole = NULL;
32  	const TCHAR *functionExpr = NULL;
33  	mainExpr = (classRangeParser->ToElement())->Attribute(TEXT("mainExpr"));
34  	if (!mainExpr || !mainExpr[0])
35  		return false;
36  	mainExprStr = mainExpr;
37  	openSymbole = (classRangeParser->ToElement())->Attribute(TEXT("openSymbole"));
38  	if (openSymbole && openSymbole[0])
39  		openSymboleStr = openSymbole;
40  	closeSymbole = (classRangeParser->ToElement())->Attribute(TEXT("closeSymbole"));
41  	if (closeSymbole && closeSymbole[0])
42  		closeSymboleStr = closeSymbole;
43  	TiXmlNode *classNameParser = classRangeParser->FirstChild(TEXT("className"));
44  	if (classNameParser)
45  	{
46  		for (TiXmlNode *childNode2 = classNameParser->FirstChildElement(TEXT("nameExpr"));
47  			childNode2;
48  			childNode2 = childNode2->NextSibling(TEXT("nameExpr")) )
49  		{
50  			const TCHAR *expr = (childNode2->ToElement())->Attribute(TEXT("expr"));
51  			if (expr && expr[0])
52  				classNameExprArray.push_back(expr);
53  		}
54  	}
55  	TiXmlNode *functionParser = classRangeParser->FirstChild(TEXT("function"));
56  	if (!functionParser)
57  		return false;
58  	functionExpr = (functionParser->ToElement())->Attribute(TEXT("mainExpr"));
59  	if (!functionExpr || !functionExpr[0])
60  		return false;
61  	functionExprStr = functionExpr;
62  	TiXmlNode *functionNameParser = functionParser->FirstChild(TEXT("functionName"));
63  	if (functionNameParser)
64  	{
65  		for (TiXmlNode *childNode3 = functionNameParser->FirstChildElement(TEXT("funcNameExpr"));
66  			childNode3;
67  			childNode3 = childNode3->NextSibling(TEXT("funcNameExpr")) )
68  		{
69  			const TCHAR *expr = (childNode3->ToElement())->Attribute(TEXT("expr"));
70  			if (expr && expr[0])
71  				functionNameExprArray.push_back(expr);
72  		}
73  	}
74  	return true;
75  }
76  bool FunctionParsersManager::getUnitPaserParameters(TiXmlNode *functionParser, generic_string &mainExprStr, std::vector<generic_string> &functionNameExprArray, std::vector<generic_string> &classNameExprArray)
77  {
78  	const TCHAR *mainExpr = (functionParser->ToElement())->Attribute(TEXT("mainExpr"));
79  	if (!mainExpr || !mainExpr[0])
80  		return false;
81  	mainExprStr = mainExpr;
82  	TiXmlNode *functionNameParser = functionParser->FirstChild(TEXT("functionName"));
83  	if (functionNameParser)
84  	{
85  		for (TiXmlNode *childNode = functionNameParser->FirstChildElement(TEXT("nameExpr"));
86  			childNode;
87  			childNode = childNode->NextSibling(TEXT("nameExpr")) )
88  		{
89  			const TCHAR *expr = (childNode->ToElement())->Attribute(TEXT("expr"));
90  			if (expr && expr[0])
91  				functionNameExprArray.push_back(expr);
92  		}
93  	}
94  	TiXmlNode *classNameParser = functionParser->FirstChild(TEXT("className"));
95  	if (classNameParser)
96  	{
97  		for (TiXmlNode *childNode = classNameParser->FirstChildElement(TEXT("nameExpr"));
98  			childNode;
99  			childNode = childNode->NextSibling(TEXT("nameExpr")) )
100  		{
101  			const TCHAR *expr = (childNode->ToElement())->Attribute(TEXT("expr"));
102  			if (expr && expr[0])
103  				classNameExprArray.push_back(expr);
104  		}
<span onclick='openModal()' class='match'>105  	}
106  	return true;
107  }
108  bool FunctionParsersManager::loadFuncListFromXmlTree(const generic_string & xmlDirPath, LangType lType, const generic_string& overrideId, int udlIndex)
109  {
110  	generic_string funcListRulePath = xmlDirPath;
</span>111  	funcListRulePath += TEXT("\\");
112  	int index = -1;
113  	if (lType == L_USER) 
114  	{
115  		if (overrideId.empty())
116  			return false;
117  		if (udlIndex == -1)
118  			return false;
119  		index = udlIndex;
120  		funcListRulePath += overrideId;
121  	}
122  	else 
123  	{
124  		index = lType;
125  		if (overrideId.empty())
126  		{
127  			generic_string lexerName = ScintillaEditView::_langNameInfoArray[lType]._langName;
128  			funcListRulePath += lexerName;
129  			funcListRulePath += TEXT(".xml");
130  		}
131  		else
132  		{
133  			funcListRulePath += overrideId;
134  		}
135  	}
136  	if (index > _currentUDIndex)
137  		return false;
138  	if (_parsers[index] == nullptr)
139  		return false;
140  	TiXmlDocument xmlFuncListDoc(funcListRulePath);
141  	bool loadOK = xmlFuncListDoc.LoadFile();
142  	if (!loadOK)
143  		return false;
144  	TiXmlNode *root = xmlFuncListDoc.FirstChild(TEXT("NotepadPlus"));
145  	if (!root)
146  		return false;
147  	root = root->FirstChild(TEXT("functionList"));
148  	if (!root)
149  		return false;
150  	TiXmlNode *parserRoot = root->FirstChild(TEXT("parser"));
151  	if (!parserRoot)
152  		return false;
153  	const TCHAR *id = (parserRoot->ToElement())->Attribute(TEXT("id"));
154  	if (!id || !id[0])
155  		return false;
156  	generic_string commentExpr(TEXT(""));
157  	const TCHAR *pCommentExpr = (parserRoot->ToElement())->Attribute(TEXT("commentExpr"));
158  	if (pCommentExpr && pCommentExpr[0])
159  		commentExpr = pCommentExpr;
160  	std::vector<generic_string> classNameExprArray;
161  	std::vector<generic_string> functionNameExprArray;
162  	const TCHAR *displayName = (parserRoot->ToElement())->Attribute(TEXT("displayName"));
163  	if (!displayName || !displayName[0])
164  		displayName = id;
165  	TiXmlNode *classRangeParser = parserRoot->FirstChild(TEXT("classRange"));
166  	TiXmlNode *functionParser = parserRoot->FirstChild(TEXT("function"));
167  	if (classRangeParser && functionParser)
168  	{
169  		generic_string mainExpr, openSymbole, closeSymbole, functionExpr;
170  		getZonePaserParameters(classRangeParser, mainExpr, openSymbole, closeSymbole, classNameExprArray, functionExpr, functionNameExprArray);
171  		generic_string mainExpr2;
172  		std::vector<generic_string> classNameExprArray2;
173  		std::vector<generic_string> functionNameExprArray2;
174  		getUnitPaserParameters(functionParser, mainExpr2, functionNameExprArray2, classNameExprArray2);
175  		FunctionUnitParser *funcUnitPaser = new FunctionUnitParser(id, displayName, commentExpr.c_str(), mainExpr2.c_str(), functionNameExprArray2, classNameExprArray2);
176  		_parsers[index]->_parser = new FunctionMixParser(id, displayName, commentExpr.c_str(), mainExpr.c_str(), openSymbole.c_str(), closeSymbole.c_str(), classNameExprArray, functionExpr.c_str(), functionNameExprArray, funcUnitPaser);
177  	}
178  	else if (classRangeParser)
179  	{
180  		generic_string mainExpr, openSymbole, closeSymbole, functionExpr;
181  		getZonePaserParameters(classRangeParser, mainExpr, openSymbole, closeSymbole, classNameExprArray, functionExpr, functionNameExprArray);
182  		_parsers[index]->_parser = new FunctionZoneParser(id, displayName, commentExpr.c_str(), mainExpr.c_str(), openSymbole.c_str(), closeSymbole.c_str(), classNameExprArray, functionExpr.c_str(), functionNameExprArray);
183  	}
184  	else if (functionParser)
185  	{
186  		generic_string  mainExpr;
187  		getUnitPaserParameters(functionParser, mainExpr, functionNameExprArray, classNameExprArray);
188  		_parsers[index]->_parser = new FunctionUnitParser(id, displayName, commentExpr.c_str(), mainExpr.c_str(), functionNameExprArray, classNameExprArray);
189  	}
190  	return true;
191  }
192  bool FunctionParsersManager::getOverrideMapFromXmlTree(const generic_string & xmlDirPath)
193  {
194  	generic_string funcListRulePath = xmlDirPath;
195  	funcListRulePath += TEXT("\\overrideMap.xml");
196  	TiXmlDocument xmlFuncListDoc(funcListRulePath);
197  	bool loadOK = xmlFuncListDoc.LoadFile();
198  	if (!loadOK)
199  		return false;
200  	TiXmlNode *root = xmlFuncListDoc.FirstChild(TEXT("NotepadPlus"));
201  	if (!root) 
202  		return false;
203  	root = root->FirstChild(TEXT("functionList"));
204  	if (!root) 
205  		return false;
206  	TiXmlNode *associationMapRoot = root->FirstChild(TEXT("associationMap"));
207  	if (associationMapRoot) 
208  	{
209  		for (TiXmlNode *childNode = associationMapRoot->FirstChildElement(TEXT("association"));
210  			childNode;
211  			childNode = childNode->NextSibling(TEXT("association")) )
212  		{
213  			int langID;
214  			const TCHAR *langIDStr = (childNode->ToElement())->Attribute(TEXT("langID"), &langID);
215  			const TCHAR *id = (childNode->ToElement())->Attribute(TEXT("id"));
216  			const TCHAR *userDefinedLangName = (childNode->ToElement())->Attribute(TEXT("userDefinedLangName"));
217  			if (!(id && id[0]))
218  				continue;
219  			if (langIDStr && langIDStr[0])
220  			{
221  				_parsers[langID] = new ParserInfo(id);
222  			}
223  			else if (userDefinedLangName && userDefinedLangName[0])
224  			{
225  				if (_currentUDIndex < L_EXTERNAL + nbMaxUserDefined)
226  				{
227  					++_currentUDIndex;
228  					_parsers[_currentUDIndex] = new ParserInfo(id, userDefinedLangName);
229  				}
230  			}
231  		}
232  	}
233  	return true;
234  }
235  FunctionParser * FunctionParsersManager::getParser(const AssociationInfo & assoInfo)
236  {
237  	const unsigned char doNothing = 0;
238  	const unsigned char checkLangID = 1;
239  	const unsigned char checkUserDefined = 2;
240  	unsigned char choice = doNothing;
241  	if (assoInfo._langID != -1 && assoInfo._langID != L_USER)
242  		choice = checkLangID;
243  	else if (assoInfo._langID == L_USER && assoInfo._userDefinedLangName != TEXT(""))
244  		choice = checkUserDefined;
245  	else
246  		return NULL;
247  	switch (choice)
248  	{
249  		case checkLangID:
250  		{
251  			if (_parsers[assoInfo._langID] != nullptr)
252  			{
253  				if (_parsers[assoInfo._langID]->_parser != nullptr)
254  					return _parsers[assoInfo._langID]->_parser;
255  				else
256  				{
257  					if (loadFuncListFromXmlTree(_xmlDirPath, static_cast<LangType>(assoInfo._langID), _parsers[assoInfo._langID]->_id))
258  						return _parsers[assoInfo._langID]->_parser;
259  					else if (_xmlDirPath != _xmlDirInstalledPath && !_xmlDirInstalledPath.empty() && loadFuncListFromXmlTree(_xmlDirInstalledPath, static_cast<LangType>(assoInfo._langID), _parsers[assoInfo._langID]->_id))
260  						return _parsers[assoInfo._langID]->_parser;
261  				}
262  			}
263  			else
264  			{
265  				_parsers[assoInfo._langID] = new ParserInfo;
266  				if (loadFuncListFromXmlTree(_xmlDirPath, static_cast<LangType>(assoInfo._langID), _parsers[assoInfo._langID]->_id))
267  					return _parsers[assoInfo._langID]->_parser;
268  				else if (_xmlDirPath != _xmlDirInstalledPath && !_xmlDirInstalledPath.empty() && loadFuncListFromXmlTree(_xmlDirInstalledPath, static_cast<LangType>(assoInfo._langID), _parsers[assoInfo._langID]->_id))
269  					return _parsers[assoInfo._langID]->_parser;
270  				return nullptr;
271  			}
272  		}
273  		break;
274  		case checkUserDefined:
275  		{
276  			if (_currentUDIndex == L_EXTERNAL) 
277  				return nullptr;
278  			for (int i = L_EXTERNAL + 1; i <= _currentUDIndex; ++i)
279  			{
280  				if (_parsers[i]->_userDefinedLangName == assoInfo._userDefinedLangName)
281  				{
282  					if (_parsers[i]->_parser)
283  					{
284  						return _parsers[i]->_parser;
285  					}
286  					else
287  					{
288  						if (loadFuncListFromXmlTree(_xmlDirPath, static_cast<LangType>(assoInfo._langID), _parsers[i]->_id, i))
289  							return _parsers[i]->_parser;
290  						else if (_xmlDirPath != _xmlDirInstalledPath && !_xmlDirInstalledPath.empty() && loadFuncListFromXmlTree(_xmlDirInstalledPath, static_cast<LangType>(assoInfo._langID), _parsers[i]->_id, i))
291  							return _parsers[i]->_parser;
292  					}
293  					break;
294  				}
295  			}
296  			return nullptr;
297  		}
298  		break;
299  	}
300  	return nullptr;
301  }
302  void FunctionParser::funcParse(std::vector<foundInfo> & foundInfos, size_t begin, size_t end, ScintillaEditView **ppEditView, generic_string classStructName, const std::vector< std::pair<size_t, size_t> > * commentZones)
303  {
304  	if (begin >= end)
305  		return;
306  	if (_functionExpr.length() == 0)
307  		return;
308  	int flags = SCFIND_REGEXP | SCFIND_POSIX | SCFIND_REGEXP_DOTMATCHESNL;
309  	(*ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
310  	intptr_t targetStart = (*ppEditView)->searchInTarget(_functionExpr.c_str(), _functionExpr.length(), begin, end);
311  	intptr_t targetEnd = 0;
312  	while (targetStart >= 0)
313  	{
314  		targetStart = (*ppEditView)->execute(SCI_GETTARGETSTART);
315  		targetEnd = (*ppEditView)->execute(SCI_GETTARGETEND);
316  		if (targetEnd > static_cast<intptr_t>(end)) 
317  		{
318  			break;
319  		}
320  		size_t foundTextLen = targetEnd - targetStart;
321  		if (targetStart + foundTextLen == end)
322              break;
323  		foundInfo fi;
324  		if (!_functionNameExprArray.size() && !_classNameExprArray.size())
325  		{
326  			TCHAR foundData[1024];
327  			(*ppEditView)->getGenericText(foundData, 1024, targetStart, targetEnd);
328  			fi._data = foundData; 
329  			fi._pos = targetStart;
330  		}
331  		else
332  		{
333  			intptr_t foundPos;
334  			if (_functionNameExprArray.size())
335  			{
336  				fi._data = parseSubLevel(targetStart, targetEnd, _functionNameExprArray, foundPos, ppEditView);
337  				fi._pos = foundPos;
338  			}
339  			if (!classStructName.empty())
340  			{
341  				fi._data2 = classStructName;
342  				fi._pos2 = -1; 
343  			}
344  			else if (_classNameExprArray.size())
345  			{
346  				fi._data2 = parseSubLevel(targetStart, targetEnd, _classNameExprArray, foundPos, ppEditView);
347  				fi._pos2 = foundPos;
348  			}
349  		}
350  		if (fi._pos != -1 || fi._pos2 != -1) 
351  		{
352  			if (commentZones != NULL)
353  			{
354  				if (!isInZones(fi._pos, *commentZones) && !isInZones(fi._pos2, *commentZones))
355  					foundInfos.push_back(fi);
356  			}
357  			else
358  				foundInfos.push_back(fi);
359  		}
360  		begin = targetStart + foundTextLen;
361  		targetStart = (*ppEditView)->searchInTarget(_functionExpr.c_str(), _functionExpr.length(), begin, end);
362  	}
363  }
364  generic_string FunctionParser::parseSubLevel(size_t begin, size_t end, std::vector< generic_string > dataToSearch, intptr_t & foundPos, ScintillaEditView **ppEditView)
365  {
366  	if (begin >= end)
367  	{
368  		foundPos = -1;
369  		return generic_string();
370  	}
371  	if (!dataToSearch.size())
372  		return generic_string();
373  	int flags = SCFIND_REGEXP | SCFIND_POSIX  | SCFIND_REGEXP_DOTMATCHESNL;
374  	(*ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
375  	const TCHAR *regExpr2search = dataToSearch[0].c_str();
376  	intptr_t targetStart = (*ppEditView)->searchInTarget(regExpr2search, lstrlen(regExpr2search), begin, end);
377  	if (targetStart < 0)
378  	{
379  		foundPos = -1;
380  		return generic_string();
381  	}
382  	intptr_t targetEnd = (*ppEditView)->execute(SCI_GETTARGETEND);
383  	if (dataToSearch.size() >= 2)
384  	{
385  		dataToSearch.erase(dataToSearch.begin());
386  		return parseSubLevel(targetStart, targetEnd, dataToSearch, foundPos, ppEditView);
387  	}
388  	TCHAR foundStr[1024];
389  	(*ppEditView)->getGenericText(foundStr, 1024, targetStart, targetEnd);
390  	foundPos = targetStart;
391  	return foundStr;
392  }
393  bool FunctionParsersManager::parse(std::vector<foundInfo> & foundInfos, const AssociationInfo & assoInfo)
394  {
395  	FunctionParser *fp = getParser(assoInfo);
396  	if (!fp)
397  		return false;
398  	size_t docLen = (*_ppEditView)->getCurrentDocLen();
399  	fp->parse(foundInfos, 0, docLen, _ppEditView);
400  	return true;
401  }
402  size_t FunctionZoneParser::getBodyClosePos(size_t begin, const TCHAR *bodyOpenSymbol, const TCHAR *bodyCloseSymbol, const std::vector< std::pair<size_t, size_t> > & commentZones, ScintillaEditView **ppEditView)
403  {
404  	size_t cntOpen = 1;
405  	size_t docLen = (*ppEditView)->getCurrentDocLen();
406  	if (begin >= docLen)
407  		return docLen;
408  	generic_string exprToSearch = TEXT("(");
409  	exprToSearch += bodyOpenSymbol;
410  	exprToSearch += TEXT("|");
411  	exprToSearch += bodyCloseSymbol;
412  	exprToSearch += TEXT(")");
413  	int flags = SCFIND_REGEXP | SCFIND_POSIX | SCFIND_REGEXP_DOTMATCHESNL;
414  	(*ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
415  	intptr_t targetStart = (*ppEditView)->searchInTarget(exprToSearch.c_str(), exprToSearch.length(), begin, docLen);
416  	LRESULT targetEnd = 0;
417  	do
418  	{
419  		if (targetStart >= 0) 
420  		{
421  			targetEnd = (*ppEditView)->execute(SCI_GETTARGETEND);
422  			if (!isInZones(targetStart, commentZones))
423  			{
424  				intptr_t tmpStart = (*ppEditView)->searchInTarget(bodyOpenSymbol, lstrlen(bodyOpenSymbol), targetStart, targetEnd);
425  				if (tmpStart >= 0) 
426  				{
427  					++cntOpen;
428  				}
429  				else 
430  				{
431  					--cntOpen;
432  				}
433  			}
434  		}
435  		else 
436  		{
437  			cntOpen = 0; 
438  			targetEnd = begin;
439  		}
440  		targetStart = (*ppEditView)->searchInTarget(exprToSearch.c_str(), exprToSearch.length(), targetEnd, docLen);
441  	} while (cntOpen);
442  	return targetEnd;
443  }
444  void FunctionZoneParser::classParse(vector<foundInfo> & foundInfos, vector< pair<size_t, size_t> > &scannedZones, const std::vector< std::pair<size_t, size_t> > & commentZones, size_t begin, size_t end, ScintillaEditView **ppEditView, generic_string &bsol;*classStructName*/)
445  {
446  	if (begin >= end)
447  		return;
448  	int flags = SCFIND_REGEXP | SCFIND_POSIX | SCFIND_REGEXP_DOTMATCHESNL;
449  	(*ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
450  	intptr_t targetStart = (*ppEditView)->searchInTarget(_rangeExpr.c_str(), _rangeExpr.length(), begin, end);
451  	intptr_t targetEnd = 0;
452  	while (targetStart >= 0)
453  	{
454  		targetEnd = (*ppEditView)->execute(SCI_GETTARGETEND);
455  		intptr_t foundPos = 0;
456  		generic_string subLevelClassStructName = parseSubLevel(targetStart, targetEnd, _classNameExprArray, foundPos, ppEditView);
457  		if (!_openSymbole.empty() && !_closeSymbole.empty())
458  		{
459  			targetEnd = getBodyClosePos(targetEnd, _openSymbole.c_str(), _closeSymbole.c_str(), commentZones, ppEditView);
460  		}
461  		if (targetEnd > static_cast<intptr_t>(end)) 
462  			break;
463  		scannedZones.push_back(pair<size_t, size_t>(targetStart, targetEnd));
464  		size_t foundTextLen = targetEnd - targetStart;
465  		if (targetStart + foundTextLen == end)
466              break;
467  		if (!isInZones(targetStart, commentZones))
468  		{
469  			funcParse(foundInfos, targetStart, targetEnd, ppEditView, subLevelClassStructName, &commentZones);
470  		}
471  		begin = targetStart + (targetEnd - targetStart);
472  		targetStart = (*ppEditView)->searchInTarget(_rangeExpr.c_str(), _rangeExpr.length(), begin, end);
473  	}
474  }
475  void FunctionParser::getCommentZones(vector< pair<size_t, size_t> > & commentZone, size_t begin, size_t end, ScintillaEditView **ppEditView)
476  {
477  	if ((begin >= end) || (_commentExpr.empty()))
478  		return;
479  	int flags = SCFIND_REGEXP | SCFIND_POSIX | SCFIND_REGEXP_DOTMATCHESNL;
480  	(*ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
481  	intptr_t targetStart = (*ppEditView)->searchInTarget(_commentExpr.c_str(), _commentExpr.length(), begin, end);
482  	intptr_t targetEnd = 0;
483  	while (targetStart >= 0)
484  	{
485  		targetStart = (*ppEditView)->execute(SCI_GETTARGETSTART);
486  		targetEnd = (*ppEditView)->execute(SCI_GETTARGETEND);
487  		if (targetEnd > static_cast<intptr_t>(end)) 
488  			break;
489  		commentZone.push_back(pair<size_t, size_t>(targetStart, targetEnd));
490  		intptr_t foundTextLen = targetEnd - targetStart;
491  		if (targetStart + foundTextLen == static_cast<intptr_t>(end))
492              break;
493  		begin = targetStart + foundTextLen;
494  		targetStart = (*ppEditView)->searchInTarget(_commentExpr.c_str(), _commentExpr.length(), begin, end);
495  	}
496  }
497  bool FunctionParser::isInZones(size_t pos2Test, const std::vector< std::pair<size_t, size_t>> & zones)
498  {
499  	for (size_t i = 0, len = zones.size(); i < len; ++i)
500  	{
501  		if (pos2Test >= zones[i].first && pos2Test < zones[i].second)
502  			return true;
503  	}
504  	return false;
505  }
506  void FunctionParser::getInvertZones(vector< pair<size_t, size_t> > &  destZones, vector< pair<size_t, size_t> > &  sourceZones, size_t begin, size_t end)
507  {
508  	if (sourceZones.size() == 0)
509  	{
510  		destZones.push_back(pair<size_t, size_t>(begin, end));
511  	}
512  	else
513  	{
514  		if (begin < sourceZones[0].first)
515  		{
516  			destZones.push_back(pair<size_t, size_t>(begin, sourceZones[0].first - 1));
517  		}
518  		size_t i = 0;
519  		for (size_t len = sourceZones.size() - 1; i < len; ++i)
520  		{
521  			size_t newBegin = sourceZones[i].second + 1;
522  			size_t newEnd = sourceZones[i+1].first - 1;
523  			if (newBegin < newEnd)
524  				destZones.push_back(pair<size_t, size_t>(newBegin, newEnd));
525  		}
526  		size_t lastBegin = sourceZones[i].second + 1;
527  		if (lastBegin < end)
528  			destZones.push_back(pair<size_t, size_t>(lastBegin, end));
529  	}
530  }
531  void FunctionZoneParser::parse(std::vector<foundInfo> & foundInfos, size_t begin, size_t end, ScintillaEditView **ppEditView, generic_string classStructName)
532  {
533  	vector< pair<size_t, size_t> > classZones, commentZones, nonCommentZones;
534  	getCommentZones(commentZones, begin, end, ppEditView);
535  	getInvertZones(nonCommentZones, commentZones, begin, end);
536  	for (size_t i = 0, len = nonCommentZones.size(); i < len; ++i)
537  	{
538  		classParse(foundInfos, classZones, commentZones, nonCommentZones[i].first, nonCommentZones[i].second, ppEditView, classStructName);
539  	}
540  }
541  void FunctionUnitParser::parse(std::vector<foundInfo> & foundInfos, size_t begin, size_t end, ScintillaEditView **ppEditView, generic_string classStructName)
542  {
543  	vector< pair<size_t, size_t> > commentZones, nonCommentZones;
544  	getCommentZones(commentZones, begin, end, ppEditView);
545  	getInvertZones(nonCommentZones, commentZones, begin, end);
546  	for (size_t i = 0, len = nonCommentZones.size(); i < len; ++i)
547  	{
548  		funcParse(foundInfos, nonCommentZones[i].first, nonCommentZones[i].second, ppEditView, classStructName);
549  	}
550  }
551  struct SortZones final
552  {
553  	bool operator() (pair<int, int> & l, pair<int, int> & r)
554  	{
555  		return (l.first < r.first);
556  	}
557  };
558  void FunctionMixParser::parse(std::vector<foundInfo> & foundInfos, size_t begin, size_t end, ScintillaEditView **ppEditView, generic_string classStructName)
559  {
560  	vector< pair<size_t, size_t> > commentZones, scannedZones, nonScannedZones;
561  	getCommentZones(commentZones, begin, end, ppEditView);
562  	classParse(foundInfos, scannedZones, commentZones, begin, end, ppEditView, classStructName);
563  	for (size_t i = 0, len = scannedZones.size(); i < len; ++i)
564  	{
565  		vector< pair<size_t, size_t> > temp;
566  		classParse(foundInfos, temp, commentZones, scannedZones[i].first, scannedZones[i].second, ppEditView, classStructName);
567  	}
568  	getInvertZones(nonScannedZones, scannedZones, begin, end);
569  	if (_funcUnitPaser)
570  	{
571  		for (size_t i = 0, len = nonScannedZones.size(); i < len; ++i)
572  		{
573  			_funcUnitPaser->funcParse(foundInfos, nonScannedZones[i].first, nonScannedZones[i].second, ppEditView, classStructName, &commentZones);
574  		}
575  	}
576  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</h3>
            <pre><code>1  TStr TModeNet::GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const {
2    TStr Cpy(CrossName);
3    if (!isDir || !sameMode) { return Cpy; }
4    if (isOutEdge) {
5      Cpy += ":SRC";
6    } else {
7      Cpy += ":DST";
<span onclick='openModal()' class='match'>8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
</span>13    TInt location = CheckDenseOrSparseN(Name);
14    int index = KeyToIndexTypeN.GetDat(Name).Val2;
15    if (location == 1) {
16      TVec<TIntV> Attrs(MxNId);
17      VecOfIntVecVecsN[index] = Attrs;
18    } else {
19      THash<TInt, TIntV> Attrs;
20      VecOfIntHashVecsN[index] = Attrs;
21    }
22  }
23  void TModeNet::Clr() {
24    TStrV CNets;
25    NeighborTypes.GetKeyV(CNets);
26    for (int i=0; i < CNets.Len(); i++) {
27      MMNet->GetCrossNetByName(CNets[i]).Clr();
28    }
29    TNEANet::Clr();
30  }
31  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const int linkId, const bool sameMode, bool isDir){
32    TStr CrossName = MMNet->GetCrossName(linkId);
33    return AddNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
34  }
35  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
36    if (!NeighborTypes.IsKey(CrossName)) {
37      AddNbrType(CrossName, sameMode, isDir);
38    }
39    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
40    return AppendIntVAttrDatN(NId, EId, Name); 
41  }
42  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
43    if (!NeighborTypes.IsKey(CrossName)) {
44      return -1;
45    }
46    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
47    return DelFromIntVAttrDatN(NId, EId, Name);
48  }
49  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir){
50    TStr CrossName = MMNet->GetCrossName(linkId);
51    return DelNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
52  }
53  void TModeNet::DelNode(const int& NId) {
54    TStrV Names;
55    GetCrossNetNames(Names);
56    for (int i=0; i < Names.Len(); i++) {
57      TCrossNet& Cross = MMNet->GetCrossNetByName(Names[i]);
58      TIntV OutEIds;
59      GetNeighborsByCrossNet(NId, Names[i], OutEIds, true);
60      for (int j=0; j < OutEIds.Len(); j++) {
61        Cross.DelEdge(OutEIds[j].Val);
62      }
63      if (Cross.IsDirect && Cross.Mode1 == Cross.Mode2) {
64        TIntV InEIds;
65        GetNeighborsByCrossNet(NId, Names[i], InEIds, false);
66        for (int j=0; j < InEIds.Len(); j++) {
67          Cross.DelEdge(InEIds[j].Val);
68        }
69      }
70    }
71    TNEANet::DelNode(NId);
72  }
73  void TModeNet::SetParentPointer(TMMNet* parent) {
74    MMNet = parent;
75  }
76  int TModeNet::AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir) {
77    if (NeighborTypes.IsKey(CrossName)) { return -1; } 
78    bool hasSingleVector = (!isDir || !sameMode);
79    NeighborTypes.AddDat(CrossName, hasSingleVector);
80    return 0;
81  }
82  int TModeNet::DelNbrType(const TStr& CrossName) {
83    bool hasSingleVector = NeighborTypes.GetDat(CrossName);
84    NeighborTypes.DelKey(CrossName);
85    if (hasSingleVector) {
86      return DelAttrN(CrossName);
87    } else {
88      TStr InName = GetNeighborCrossName(CrossName, true, true, true);
89      TStr OutName = GetNeighborCrossName(CrossName, false, true, true);
90      if (DelAttrN(InName) == -1 || DelAttrN(OutName) == -1) {
91        return -1;
92      }
93    }
94    return 0;
95  }
96  void TModeNet::GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId) const{
97    TBool hasSingleVector = NeighborTypes.GetDat(Name);
98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
105  int TModeNet::AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense){
106    TInt CurrLen;
107    if (UseDense) {
108      CurrLen = VecOfIntVecVecsN.Len();
109      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
110      KeyToDenseN.AddDat(attr, true);
111      VecOfIntVecVecsN.Add(Attrs);
112    } else {
113      THash<TInt, TIntV> NewHash;
114      CurrLen = VecOfIntHashVecsN.Len();
115      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
116      KeyToDenseN.AddDat(attr, false);
117      for (int i=0; i< Attrs.Len(); i++) {
118        NewHash.AddDat(i, Attrs[i]);
119      }
120      VecOfIntHashVecsN.Add(NewHash);
121    }
122    return 0;
123  }
124  int TModeNet::AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs){
125    TInt CurrLen;
126    THash<TInt, TIntV> NewHash;
127    CurrLen = VecOfIntHashVecsN.Len();
128    KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
129    KeyToDenseN.AddDat(attr, false);
130    for (int i=0; i< Attrs.Len(); i++) {
131      NewHash.AddDat(i, Attrs[i]);
132    }
133    VecOfIntHashVecsN.Add(NewHash);
134    return 0;
135  }
136  void TModeNet::RemoveCrossNets(TModeNet& Result, TStrV& CrossNets) {
137    const TModeNet& self = *this;
138    Result = TModeNet(self, false);
139    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
140      TStr AttrName = it.GetKey();
141      TInt AttrType = it.GetDat().GetVal1();
142      TInt AttrIndex = it.GetDat().GetVal2();
143      if (AttrType != IntVType) {
144        Result.KeyToIndexTypeN.AddDat(AttrName, it.GetDat());
145      } else {
146        TStr WithoutSuffix = AttrName;
147        bool removeSuffix = false;
148        if (AttrName.IsSuffix(":SRC") || AttrName.IsSuffix(":DST")) {
149          WithoutSuffix = AttrName.GetSubStr(0, AttrName.Len()-5);
150          removeSuffix = true;
151        }
152        bool isSingleVNbrAttr = (NeighborTypes.IsKey(AttrName) && NeighborTypes.GetDat(AttrName));
153        bool isMultiVNbrAttr = (removeSuffix && NeighborTypes.IsKey(WithoutSuffix) && !NeighborTypes.GetDat(WithoutSuffix));
154        if (isSingleVNbrAttr || isMultiVNbrAttr) {
155          TStr NbrName = isSingleVNbrAttr ? AttrName : WithoutSuffix;
156          if (CrossNets.IsIn(NbrName)) {
157            Result.AddNbrType(NbrName, removeSuffix, removeSuffix);
158            TInt location = CheckDenseOrSparseN(AttrName);
159            if (location == 1) {
160              TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
161              Result.AddIntVAttrByVecN(AttrName, Attrs);
162            } else {
163              THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
164              Result.AddIntVAttrByHashN(AttrName, Attrs);
165            }
166          }
167        } else {
168          TInt location = CheckDenseOrSparseN(AttrName);
169          if (location == 1) {
170            TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
171            Result.AddIntVAttrByVecN(AttrName, Attrs);
172          } else {
173            THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
174            Result.AddIntVAttrByHashN(AttrName, Attrs);
175          }
176        }
177      }
178    }
179  }
180  int TModeNet::GetAttrTypeN(const TStr& attr) const {
181    if (KeyToIndexTypeN.IsKey(attr)) {
182      return KeyToIndexTypeN.GetDat(attr).Val1;
183    }
184    return -1;
185  }
186  int TCrossNet::GetAttrTypeE(const TStr& attr) const {
187    if (KeyToIndexTypeE.IsKey(attr)) {
188      return KeyToIndexTypeE.GetDat(attr).Val1;
189    }
190    return -1;
191  }
192  void TCrossNet::Clr() {
193    CrossH.Clr();
194    MxEId=0;
195    KeyToIndexTypeE.Clr();
196    IntDefaultsE.Clr();
197    StrDefaultsE.Clr();
198    FltDefaultsE.Clr();
199    VecOfIntVecsE.Clr();
200    VecOfStrVecsE.Clr();
201    VecOfFltVecsE.Clr(); 
202    Net->ClrNbr(Mode1, CrossNetId, true, Mode1==Mode2, IsDirect.Val);
203    Net->ClrNbr(Mode2, CrossNetId, false, Mode1==Mode2, IsDirect.Val); 
204  }
205  int TCrossNet::AddEdge(const int& sourceNId, const int& destNId, int EId){
206    if (EId == -1) { EId = MxEId;  MxEId++; }
207    else { MxEId = TMath::Mx(EId+1, MxEId()); }
208    if (Net != NULL) {
209      TModeNet& M1 = Net->TModeNetH.GetDat(this->Mode1);
210      TModeNet& M2 = Net->TModeNetH.GetDat(this->Mode2);
211      if (!M1.IsNode(sourceNId) || !M2.IsNode(destNId)) { return -1; }
212      TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
213      M1.AddNeighbor(sourceNId, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
214      M2.AddNeighbor(destNId, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
215    }
216    TCrossNet::TCrossEdge newEdge(EId, sourceNId, destNId);
217    CrossH.AddDat(EId, newEdge);
218    int i;
219    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
220      TVec<TInt>& IntVec = VecOfIntVecsE[i];
221      int KeyId = CrossH.GetKeyId(EId);
222      if (IntVec.Len() > KeyId) {
223        IntVec[KeyId] = TInt::Mn;
224      } else {
225        IntVec.Ins(KeyId, TInt::Mn);
226      }
227    }
228    TVec<TStr> DefIntVec = TVec<TStr>();
229    IntDefaultsE.GetKeyV(DefIntVec);
230    for (i = 0; i < DefIntVec.Len(); i++) {
231      TStr attr = DefIntVec[i];
232      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
233      IntVec[CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
234    }
235    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
236      TVec<TStr>& StrVec = VecOfStrVecsE[i];
237      int KeyId = CrossH.GetKeyId(EId);
238      if (StrVec.Len() > KeyId) {
239        StrVec[KeyId] = TStr::GetNullStr();
240      } else {
241        StrVec.Ins(KeyId, TStr::GetNullStr());
242      }
243    }
244    TVec<TStr> DefStrVec = TVec<TStr>();
245    StrDefaultsE.GetKeyV(DefStrVec);
246    for (i = 0; i < DefStrVec.Len(); i++) {
247      TStr attr = DefStrVec[i];
248      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
249      StrVec[CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
250    }
251    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
252      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
253      int KeyId = CrossH.GetKeyId(EId);
254      if (FltVec.Len() > KeyId) {
255        FltVec[KeyId] = TFlt::Mn;
256      } else {
257        FltVec.Ins(KeyId, TFlt::Mn);
258      }
259    }
260    TVec<TStr> DefFltVec = TVec<TStr>();
261    FltDefaultsE.GetKeyV(DefFltVec);
262    for (i = 0; i < DefFltVec.Len(); i++) {
263      TStr attr = DefFltVec[i];
264      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
265      FltVec[CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
266    }
267    return EId;
268  }
269  int TCrossNet::DelEdge(const int& EId) {
270    TCrossEdge& Edge = CrossH.GetDat(EId);
271    int srcNode = Edge.SrcNId;
272    int dstNode = Edge.DstNId;
273    TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
274    Net->GetModeNetById(this->Mode1).DelNeighbor(srcNode, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
275    Net->GetModeNetById(this->Mode2).DelNeighbor(dstNode, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
276    int i;
277    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
278      TVec<TInt>& IntVec = VecOfIntVecsE[i];
279      IntVec[CrossH.GetKeyId(EId)] =  TInt::Mn;
280    }
281    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
282      TVec<TStr>& StrVec = VecOfStrVecsE[i];
283      StrVec[CrossH.GetKeyId(EId)] =  TStr::GetNullStr();
284    }
285    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
286      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
287      FltVec[CrossH.GetKeyId(EId)] = TFlt::Mn;
288    }
289    CrossH.DelKey(EId);
290    return 0;
291  }
292  void TCrossNet::SetParentPointer(TMMNet* parent) {
293    Net = parent;
294  }
295  void TCrossNet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
296    Names = TVec<TStr>();
297    while (!CrossHI.IsEnd()) {
298      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
299        Names.Add(CrossHI.GetKey());
300      }
301      CrossHI++;
302    }  
303  }
304  void TCrossNet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
305    Values = TVec<TStr>();
306    while (!CrossHI.IsEnd()) {
307      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
308        Values.Add(GetEdgeAttrValue(EId, CrossHI));
309      }
310      CrossHI++;
311    }  
312  }
313  void TCrossNet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
314    Names = TVec<TStr>();
315    while (!CrossHI.IsEnd()) {
316      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
317        Names.Add(CrossHI.GetKey());
318      }
319      CrossHI++;
320    }  
321  }
322  void TCrossNet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const {
323    Values = TVec<TInt>();
324    while (!CrossHI.IsEnd()) {
325      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
326        TInt val = (this->VecOfIntVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
327        Values.Add(val);
328      }
329      CrossHI++;
330    }  
331  }
332  void TCrossNet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
333    Names = TVec<TStr>();
334    while (!CrossHI.IsEnd()) {
335      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
336        Names.Add(CrossHI.GetKey());
337      }
338      CrossHI++;
339    }  
340  }
341  void TCrossNet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
342    Values = TVec<TStr>();
343    while (!CrossHI.IsEnd()) {
344      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
345        TStr val = this->VecOfStrVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId);
346        Values.Add(val);
347      }
348      CrossHI++;
349    }  
350  }
351  void TCrossNet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
352    Names = TVec<TStr>();
353    while (!CrossHI.IsEnd()) {
354      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
355        Names.Add(CrossHI.GetKey());
356      }
357      CrossHI++;
358    }  
359  }
360  void TCrossNet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const {
361    Values = TVec<TFlt>();
362    while (!CrossHI.IsEnd()) {
363      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
364        TFlt val = (this->VecOfFltVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
365        Values.Add(val);
366      }
367      CrossHI++;
368    }  
369  }
370  bool TCrossNet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
371    bool IntDel = IsIntAttrDeletedE(EId, attr);
372    bool StrDel = IsStrAttrDeletedE(EId, attr);
373    bool FltDel = IsFltAttrDeletedE(EId, attr);
374    return IntDel || StrDel || FltDel;
375  }
376  bool TCrossNet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
377    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
378  }
379  bool TCrossNet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
380    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
381  }
382  bool TCrossNet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
383    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
384  }
385  bool TCrossNet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
386    bool IntDel = EdgeAttrIsIntDeleted(EId, CrossHI);
387    bool StrDel = EdgeAttrIsStrDeleted(EId, CrossHI);
388    bool FltDel = EdgeAttrIsFltDeleted(EId, CrossHI);
389    return IntDel || StrDel || FltDel;
390  }
391  bool TCrossNet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
392    return (CrossHI.GetDat().Val1 == IntType &&
393      GetIntAttrDefaultE(CrossHI.GetKey()) == this->VecOfIntVecsE.GetVal(
394      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
395  }
396  bool TCrossNet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
397    return (CrossHI.GetDat().Val1 == StrType &&
398      GetStrAttrDefaultE(CrossHI.GetKey()) == this->VecOfStrVecsE.GetVal(
399      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
400  }
401  bool TCrossNet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
402    return (CrossHI.GetDat().Val1 == FltType &&
403      GetFltAttrDefaultE(CrossHI.GetKey()) == this->VecOfFltVecsE.GetVal(
404      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
405  }
406  TStr TCrossNet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
407    if (CrossHI.GetDat().Val1 == IntType) {
408      return (this->VecOfIntVecsE.GetVal(
409        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
410    } else if(CrossHI.GetDat().Val1 == StrType) {
411      return this->VecOfStrVecsE.GetVal(
412      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId));
413    } else if (CrossHI.GetDat().Val1 == FltType) {
414      return (this->VecOfFltVecsE.GetVal(
415        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
416    }
417    return TStr::GetNullStr();
418  }
419  int TCrossNet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
420    int i;
421    TInt CurrLen;
422    if (!IsEdge(EId)) {
423       return -1;
424    }
425    if (KeyToIndexTypeE.IsKey(attr)) {
426      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
427      NewVec[CrossH.GetKeyId(EId)] = value;
428    } else {
429      CurrLen = VecOfIntVecsE.Len();
430      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
431      TVec<TInt> NewVec = TVec<TInt>();
432      for (i = 0; i < MxEId; i++) {
433        NewVec.Ins(i, GetIntAttrDefaultE(attr));
434      }
435      NewVec[CrossH.GetKeyId(EId)] = value;
436      VecOfIntVecsE.Add(NewVec);
437    }
438    return 0;
439  }
440  int TCrossNet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
441    int i;
442    TInt CurrLen;
443    if (!IsEdge(EId)) {
444       return -1;
445    }
446    if (KeyToIndexTypeE.IsKey(attr)) {
447      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
448      NewVec[CrossH.GetKeyId(EId)] = value;
449    } else {
450      CurrLen = VecOfStrVecsE.Len();
451      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
452      TVec<TStr> NewVec = TVec<TStr>();
453      for (i = 0; i < MxEId; i++) {
454        NewVec.Ins(i, GetStrAttrDefaultE(attr));
455      }
456      NewVec[CrossH.GetKeyId(EId)] = value;
457      VecOfStrVecsE.Add(NewVec);
458    }
459    return 0;
460  } 
461  int TCrossNet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
462    int i;
463    TInt CurrLen;
464    if (!IsEdge(EId)) {
465       return -1;
466    }
467    if (KeyToIndexTypeE.IsKey(attr)) {
468      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
469      NewVec[CrossH.GetKeyId(EId)] = value;
470    } else {
471      CurrLen = VecOfFltVecsE.Len();
472      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
473      TVec<TFlt> NewVec = TVec<TFlt>();
474      for (i = 0; i < MxEId; i++) {
475        NewVec.Ins(i, GetFltAttrDefaultE(attr));
476      }
477      NewVec[CrossH.GetKeyId(EId)] = value;
478      VecOfFltVecsE.Add(NewVec);
479    }
480    return 0;
481  }
482  TInt TCrossNet::GetIntAttrDatE(const int& EId, const TStr& attr) {
483    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
484  }
485  TStr TCrossNet::GetStrAttrDatE(const int& EId, const TStr& attr) {
486    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
487  }
488  TFlt TCrossNet::GetFltAttrDatE(const int& EId, const TStr& attr) {
489    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
490  }
491  int TCrossNet::DelAttrDatE(const int& EId, const TStr& attr) {
492    TInt vecType = KeyToIndexTypeE(attr).Val1;
493    if (vecType == IntType) {
494      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
495    } else if (vecType == StrType) {
496      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
497    } else if (vecType == FltType) {
498      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
499    } else {
500      return -1;
501    }
502    return 0;
503  }
504  int TCrossNet::AddIntAttrE(const TStr& attr, TInt defaultValue){
505    int i;
506    TInt CurrLen;
507    TVec<TInt> NewVec;
508    CurrLen = VecOfIntVecsE.Len();
509    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
510    NewVec = TVec<TInt>();
511    for (i = 0; i < MxEId; i++) {
512      NewVec.Ins(i, defaultValue);
513    }
514    VecOfIntVecsE.Add(NewVec);
515    if (!IntDefaultsE.IsKey(attr)) {
516      IntDefaultsE.AddDat(attr, defaultValue);
517    } else {
518      return -1;
519    }
520    return 0;
521  }
522  int TCrossNet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
523    int i;
524    TInt CurrLen;
525    TVec<TStr> NewVec;
526    CurrLen = VecOfStrVecsE.Len();
527    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
528    NewVec = TVec<TStr>();
529    for (i = 0; i < MxEId; i++) {
530      NewVec.Ins(i, defaultValue);
531    }
532    VecOfStrVecsE.Add(NewVec);
533    if (!StrDefaultsE.IsKey(attr)) {
534      StrDefaultsE.AddDat(attr, defaultValue);
535    } else {
536      return -1;
537    }
538    return 0;
539  }
540  int TCrossNet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
541    int i;
542    TInt CurrLen;
543    TVec<TFlt> NewVec;
544    CurrLen = VecOfFltVecsE.Len();
545    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
546    NewVec = TVec<TFlt>();
547    for (i = 0; i < MxEId; i++) {
548      NewVec.Ins(i, defaultValue);
549    }
550    VecOfFltVecsE.Add(NewVec);
551    if (!FltDefaultsE.IsKey(attr)) {
552      FltDefaultsE.AddDat(attr, defaultValue);
553    } else {
554      return -1;
555    }
556    return 0;
557  }
558  int TCrossNet::DelAttrE(const TStr& attr) {
559    TInt vecType = KeyToIndexTypeE(attr).Val1;
560    if (vecType == IntType) {
561      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
562      if (IntDefaultsE.IsKey(attr)) {
563        IntDefaultsE.DelKey(attr);
564      }
565    } else if (vecType == StrType) {
566      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
567      if (StrDefaultsE.IsKey(attr)) {
568        StrDefaultsE.DelKey(attr);
569      }  
570    } else if (vecType == FltType) {
571      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
572      if (FltDefaultsE.IsKey(attr)) {
573        FltDefaultsE.DelKey(attr);
574      }
575    } else {
576      return -1;
577    }
578    KeyToIndexTypeE.DelKey(attr);
579    return 0;
580  }
581  void TMMNet::LoadNetworkShM(TShMIn& ShMIn) {
582    MxModeId = TInt(ShMIn);
583    MxCrossNetId = TInt(ShMIn);
584    TModeNetInit Fm;
585    TModeNetH.LoadShM(ShMIn, Fm);
586    TCrossNetInit Fc;
587    TCrossNetH.LoadShM(ShMIn, Fc);
588    ModeIdToNameH.LoadShM(ShMIn);
589    ModeNameToIdH.LoadShM(ShMIn);
590    CrossIdToNameH.LoadShM(ShMIn);
591    CrossNameToIdH.LoadShM(ShMIn);
592    for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
593      it.GetDat().SetParentPointer(this);
594    }
595    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
596      it.GetDat().SetParentPointer(this);
597    }
598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
604    MxModeId++;
605    ModeIdToNameH.AddDat(ModeId, ModeName);
606    ModeNameToIdH.AddDat(ModeName, ModeId);
607    TModeNet NewGraph(ModeId);
608    NewGraph.SetParentPointer(this);
609    TModeNetH.AddDat(ModeId, NewGraph);
610    return ModeId;
611  }
612  int TMMNet::AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir) {
613    TInt ModeId1 = GetModeId(ModeName1);
614    TInt ModeId2 = GetModeId(ModeName2);
615    return AddCrossNet(ModeId1, ModeId2, CrossNetName, isDir);
616  }
617  int TMMNet::AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir) {
618    if (CrossNameToIdH.IsKey(CrossNetName)) {
619      return -1;
620    }
621    TInt CrossNetId = TInt(MxCrossNetId);
622    MxCrossNetId++;
623    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
624    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
625    TCrossNet Cross = TCrossNet(ModeId1, ModeId2, isDir, CrossNetId);
626    Cross.SetParentPointer(this);
627    TCrossNetH.AddDat(CrossNetId, Cross);
628    TModeNetH.GetDat(ModeId1).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
629    TModeNetH.GetDat(ModeId2).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
630    return CrossNetId;
631  }
632  int TMMNet::DelCrossNet(const TInt& CrossNetId) {
633    return DelCrossNet(CrossIdToNameH.GetDat(CrossNetId));
634  }
635  int TMMNet::DelCrossNet(const TStr& CrossNet) {
636    IAssertR(CrossNameToIdH.IsKey(CrossNet),TStr::Fmt("No such link type: %s", CrossNet.CStr()));
637    TInt CrossNetId = CrossNameToIdH.GetDat(CrossNet);
638    TInt Mode1 = GetCrossNetById(CrossNetId).Mode1;
639    TInt Mode2 = GetCrossNetById(CrossNetId).Mode2;
640    if (GetModeNetById(Mode1).DelNbrType(CrossNet) == -1 || (Mode1 != Mode2 && GetModeNetById(Mode2).DelNbrType(CrossNet) == -1)) {
641      return -1;
642    }
643    CrossNameToIdH.DelKey(CrossNet);
644    CrossIdToNameH.DelKey(CrossNetId);
645    GetCrossNetById(CrossNetId).SetParentPointer(NULL);
646    TCrossNetH.DelKey(CrossNetId);
647    return 0;
648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
653      if (DelCrossNet(CrossNets[i]) == -1) {
654        return -1;
655      }
656    }
657    TStr ModeName = ModeIdToNameH.GetDat(ModeId);
658    ModeNameToIdH.DelKey(ModeName);
659    ModeIdToNameH.DelKey(ModeId);
660    GetModeNetById(ModeId).SetParentPointer(NULL);
661    TModeNetH.DelKey(ModeId);
662    return 0;
663  }
664  int TMMNet::DelModeNet(const TStr& ModeName) {
665    IAssertR(ModeNameToIdH.IsKey(ModeName), TStr::Fmt("No such mode with name: %s", ModeName.CStr()));
666    return DelModeNet(ModeNameToIdH.GetDat(ModeName));
667  }
668  TModeNet& TMMNet::GetModeNetByName(const TStr& ModeName) const {
669    return GetModeNetById(ModeNameToIdH.GetDat(ModeName));
670  }
671  TModeNet& TMMNet::GetModeNetById(const TInt& ModeId) const {
672    TModeNet &Net = (const_cast<TMMNet *>(this))->TModeNetH.GetDat(ModeId);
673    return Net;
674  }
675  TCrossNet& TMMNet::GetCrossNetByName(const TStr& CrossName) const{
676    return GetCrossNetById(CrossNameToIdH.GetDat(CrossName));
677  }
678  TCrossNet& TMMNet::GetCrossNetById(const TInt& CrossId) const{
679    TCrossNet& CrossNet = (const_cast<TMMNet *>(this))->TCrossNetH.GetDat(CrossId);
680    return CrossNet;
681  }
682  int TMMNet::AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet) {
683    ModeIdToNameH.AddDat(ModeId, ModeName);
684    ModeNameToIdH.AddDat(ModeName, ModeId);
685    TModeNetH.AddDat(ModeId, ModeNet);
686    TModeNetH[ModeId].SetParentPointer(this);
687    return ModeId;
688  }
689  int TMMNet::AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet) {
690    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
691    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
692    TCrossNetH.AddDat(CrossNetId, CrossNet);
693    TCrossNetH[CrossNetId].SetParentPointer(this);
694    return CrossNetId;
695  }
696  void TMMNet::ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir) {
697    TStr CrossNetName = CrossIdToNameH[CrossNetId];
698    TModeNetH[ModeId].ClrNbr(CrossNetName, outEdge, sameMode, isDir);
699  }
700  PMMNet TMMNet::GetSubgraphByCrossNet(TStrV& CrossNetTypes) {
701    PMMNet Result = New();
702    TInt MxMode = 0;
703    TInt MxCross = 0;
704    TIntH ModeH;
705    for(int i = 0; i < CrossNetTypes.Len(); i++) {
706      TStr CrossName = CrossNetTypes[i];
707      TInt OldId = CrossNameToIdH.GetDat(CrossName);
708      TInt NewId = MxCross++;
709      TCrossNet NewCrossNet(TCrossNetH.GetDat(OldId));
710      TInt OldModeId1 = NewCrossNet.Mode1;
711      TInt OldModeId2 = NewCrossNet.Mode2;
712      TInt NewModeId1, NewModeId2;
713      if (ModeH.IsKey(OldModeId1)) {
714        NewModeId1 = ModeH.GetDat(OldModeId1);
715      } else {
716        NewModeId1 = MxMode++;
717        ModeH.AddDat(OldModeId1, NewModeId1);
718      }
719      if (ModeH.IsKey(OldModeId2)) {
720        NewModeId2 = ModeH.GetDat(OldModeId2);
721      } else {
722        NewModeId2 = MxMode++;
723        ModeH.AddDat(OldModeId2, NewModeId2);
724      }
725      NewCrossNet.Mode1 = NewModeId1;
726      NewCrossNet.Mode2 = NewModeId2;
727      NewCrossNet.CrossNetId = NewId;
728      Result->AddCrossNet(CrossName, NewId, NewCrossNet);
729    }
730    for(TIntH::TIter it = ModeH.BegI(); it < ModeH.EndI(); it++) {
731      TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
732      TInt NewModeId = it.GetDat();
733      TModeNet NewModeNet;
734      TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, CrossNetTypes);
735      NewModeNet.ModeId = NewModeId;
736      Result->AddMode(ModeName, NewModeId, NewModeNet);
737    }
738    Result->MxModeId = MxMode;
739    Result->MxCrossNetId = MxCross;
740    return Result;
741  }
742  PMMNet TMMNet::GetSubgraphByModeNet(TStrV& ModeNetTypes) {
743    THash<TInt, TBool> ModeTypeIds;
744    for (int i = 0; i < ModeNetTypes.Len(); i++) {
745      ModeTypeIds.AddDat(ModeNameToIdH.GetDat(ModeNetTypes[i]), true);
746    }
747    TStrV CrossNetTypes;
748    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
749      TCrossNet& CrossNet = it.GetDat();
750      if (ModeTypeIds.IsKey(CrossNet.Mode1) && ModeTypeIds.IsKey(CrossNet.Mode2)) {
751        CrossNetTypes.Add(CrossIdToNameH.GetDat(it.GetKey()));
752        ModeTypeIds[CrossNet.Mode1] = false;
753        ModeTypeIds[CrossNet.Mode2] = false;
754      }
755    }
756    PMMNet Result = GetSubgraphByCrossNet(CrossNetTypes);
757    TInt MxMode = Result->MxModeId;
758    TStrV EmptyCrossNetTypes;
759    for (THash<TInt, TBool>::TIter it = ModeTypeIds.BegI(); it < ModeTypeIds.EndI(); it++) {
760      if (it.GetDat().Val) {
761        TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
762        TInt NewModeId = MxMode++;
763        TModeNet NewModeNet;
764        TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, EmptyCrossNetTypes);
765        NewModeNet.ModeId = NewModeId;
766        Result->AddMode(ModeName, NewModeId, NewModeNet);
767      }
768    }
769    Result->MxModeId = MxMode;
770    return Result;
771  }
772  PNEANet TMMNet::ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap) {
773    TIntPrIntH NodeMap;
774    THash<TIntPr, TIntPr> EdgeMap;
775    THashSet<TInt> Modes;
776    PNEANet NewNet = TNEANet::New();
777    for (int i = 0; i < CrossNetTypes.Len(); i++) {
778      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
779      TInt Mode1 = CrossNet.GetMode1();
780      TInt Mode2 = CrossNet.GetMode2();
781      Modes.AddKey(Mode1);
782      Modes.AddKey(Mode2);
783      bool isDirected = CrossNet.IsDirected();
784      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
785        int srcNode = EdgeI.GetSrcNId();
786        int dstNode = EdgeI.GetDstNId();
787        TIntPr SrcNodeMapping(Mode1, srcNode);
788        int srcId = 0;
789        if (NodeMap.IsKey(SrcNodeMapping)) {
790          srcId = NodeMap.GetDat(SrcNodeMapping);
791        } else {
792          srcId = NewNet->AddNode();
793          NodeMap.AddDat(SrcNodeMapping, srcId);
794        }
795        TIntPr DstNodeMapping(Mode2, dstNode);
796        int dstId = 0;
797        if (NodeMap.IsKey(DstNodeMapping)) {
798          dstId = NodeMap.GetDat(DstNodeMapping);
799        } else {
800          dstId = NewNet->AddNode();
801          NodeMap.AddDat(DstNodeMapping, dstId);
802        }
803        int edgeId = EdgeI.GetId();
804        TIntPr EdgeMapping(CrossNetTypes[i], edgeId);
805        int newEId = NewNet->AddEdge(srcId, dstId);
806        int otherEId = -1;
807        if (!isDirected) {
808          otherEId = NewNet->AddEdge(dstId, srcId);
809        }
810        EdgeMap.AddDat(EdgeMapping, TIntPr(newEId, otherEId));
811      }
812    }
813    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
814      TModeNet &ModeNet = GetModeNetById(it.GetKey());
815      TInt ModeId = it.GetKey();
816      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
817        TIntPr NodeKey(ModeId, NodeIt.GetId());
818        if (!NodeMap.IsKey(NodeKey)) {
819          int newId = NewNet->AddNode();
820          NodeMap.AddDat(NodeKey, newId);
821        }
822      }
823    }
824    NewNet->AddIntAttrN(TStr("Mode"));
825    NewNet->AddIntAttrN(TStr("Id"));
826    NewNet->AddIntAttrE(TStr("CrossNet"));
827    NewNet->AddIntAttrE(TStr("Id"));
828    for(TIntPrIntH::TIter it = NodeMap.BegI(); it != NodeMap.EndI(); it++) {
829      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal1(), TStr("Mode"));
830      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal2(), TStr("Id"));
831    }
832    for(THash<TIntPr, TIntPr>::TIter it = EdgeMap.BegI(); it != EdgeMap.EndI(); it++) {
833      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal1(), TStr("CrossNet"));
834      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal2(), TStr("Id"));
835      if (it.GetDat().GetVal2() != -1) {
836        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal1(), TStr("CrossNet"));
837        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal2(), TStr("Id"));
838      }
839    }
840    for (int i = 0; i < NodeAttrMap.Len(); i++) {
841      TInt ModeId = NodeAttrMap[i].Val1;
842      TStr OrigAttr = NodeAttrMap[i].Val2;
843      TStr NewAttr = NodeAttrMap[i].Val3;
844      TModeNet& Net = GetModeNetById(ModeId);
845      int type = Net.GetAttrTypeN(OrigAttr);
846      if (type == TModeNet::IntType) {
847        NewNet->AddIntAttrN(NewAttr, Net.GetIntAttrDefaultN(OrigAttr));
848        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
849          TIntPr OldNId(ModeId, it.GetId());
850          int NewId = NodeMap.GetDat(OldNId);
851          int Val = Net.GetIntAttrDatN(it.GetId(), OrigAttr);
852          NewNet->AddIntAttrDatN(NewId, Val, NewAttr);
853        }
854      } else if (type == TModeNet::FltType) {
855        NewNet->AddFltAttrN(NewAttr, Net.GetFltAttrDefaultN(OrigAttr));
856        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
857          TIntPr OldNId(ModeId, it.GetId());
858          int NewId = NodeMap.GetDat(OldNId);
859          TFlt Val = Net.GetFltAttrDatN(it.GetId(), OrigAttr);
860          NewNet->AddFltAttrDatN(NewId, Val, NewAttr);
861        }
862      } else if (type == TModeNet::StrType) {
863        NewNet->AddStrAttrN(NewAttr, Net.GetStrAttrDefaultN(OrigAttr));
864        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
865          TIntPr OldNId(ModeId, it.GetId());
866          int NewId = NodeMap.GetDat(OldNId);
867          TStr Val = Net.GetStrAttrDatN(it.GetId(), OrigAttr);
868          NewNet->AddStrAttrDatN(NewId, Val, NewAttr);
869        }
870      } else if (type == TModeNet::IntVType) {
871        NewNet->AddIntVAttrN(NewAttr);
872        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
873          TIntPr OldNId(ModeId, it.GetId());
874          int NewId = NodeMap.GetDat(OldNId);
875          TIntV Val = Net.GetIntVAttrDatN(it.GetId(), OrigAttr);
876          NewNet->AddIntVAttrDatN(NewId, Val, NewAttr);
877        }
878      }
879    }
880    for (int i = 0; i < EdgeAttrMap.Len(); i++) {
881      TInt CrossId = EdgeAttrMap[i].Val1;
882      TStr OrigAttr = EdgeAttrMap[i].Val2;
883      TStr NewAttr = EdgeAttrMap[i].Val3;
884      TCrossNet& Net = GetCrossNetById(CrossId);
885      int type = Net.GetAttrTypeE(OrigAttr);
886      if (type == TCrossNet::IntType) {
887        NewNet->AddIntAttrE(NewAttr, Net.GetIntAttrDefaultE(OrigAttr));
888        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
889          TIntPr OldNId(CrossId, it.GetId());
890          TIntPr NewId = EdgeMap.GetDat(OldNId);
891          int Val = Net.GetIntAttrDatE(it.GetId(), OrigAttr);
892          NewNet->AddIntAttrDatE(NewId.Val1, Val, NewAttr);
893          if (NewId.Val2 != -1) {
894            NewNet->AddIntAttrDatE(NewId.Val2, Val, NewAttr);
895          }
896        }
897      } else if (type == TCrossNet::FltType) {
898        NewNet->AddFltAttrE(NewAttr, Net.GetFltAttrDefaultE(OrigAttr));
899        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
900          TIntPr OldNId(CrossId, it.GetId());
901          TIntPr NewId = EdgeMap.GetDat(OldNId);
902          TFlt Val = Net.GetFltAttrDatE(it.GetId(), OrigAttr);
903          NewNet->AddFltAttrDatE(NewId.Val1, Val, NewAttr);
904          if (NewId.Val2 != -1) {
905            NewNet->AddFltAttrDatE(NewId.Val2, Val, NewAttr);
906          }
907        }
908      } else if (type == TCrossNet::StrType) {
909        NewNet->AddStrAttrE(NewAttr, Net.GetStrAttrDefaultE(OrigAttr));
910        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++){
911          TIntPr OldNId(CrossId, it.GetId());
912          TIntPr NewId = EdgeMap.GetDat(OldNId);
913          TStr Val = Net.GetStrAttrDatE(it.GetId(), OrigAttr);
914          NewNet->AddStrAttrDatE(NewId.Val1, Val, NewAttr);
915          if (NewId.Val2 != -1) {
916            NewNet->AddStrAttrDatE(NewId.Val2, Val, NewAttr);
917          }
918        }
919      }
920    }
921    return NewNet;
922  }
923  PNEANet TMMNet::ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap) {
924    TIntPrIntH NodeMap;
925    THashSet<TInt> Modes;
926    PNEANet NewNet = TNEANet::New();
927    NewNet->AddIntAttrN(TStr("Mode"));
928    NewNet->AddIntAttrN(TStr("Id"));
929    NewNet->AddIntAttrE(TStr("CrossNet"));
930    NewNet->AddIntAttrE(TStr("Id"));
931    for (int i = 0; i < CrossNetTypes.Len(); i++) {
932      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
933      TStrPrV CNetAttrs;
934      if (EdgeAttrMap.IsKey(CrossNetTypes[i])) {
935        CNetAttrs = EdgeAttrMap.GetDat(CrossNetTypes[i]);
936      }
937      TInt Mode1 = CrossNet.GetMode1();
938      TInt Mode2 = CrossNet.GetMode2();
939      TModeNet& Mode1Net = GetModeNetById(Mode1);
940      TModeNet& Mode2Net = GetModeNetById(Mode2);
941      TStrPrV Mode1Attrs;
942      if (NodeAttrMap.IsKey(Mode1)) {
943        Mode1Attrs = NodeAttrMap.GetDat(Mode1);
944      }
945      TStrPrV Mode2Attrs;
946      if (NodeAttrMap.IsKey(Mode2)) {
947        Mode2Attrs = NodeAttrMap.GetDat(Mode2);
948      } 
949      Modes.AddKey(Mode1);
950      Modes.AddKey(Mode2);
951      bool isDirected = CrossNet.IsDirected();
952      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
953        int srcNode = EdgeI.GetSrcNId();
954        int dstNode = EdgeI.GetDstNId();
955        TIntPr SrcNodeMapping(Mode1, srcNode);
956        int srcId = 0;
957        if (NodeMap.IsKey(SrcNodeMapping)) {
958          srcId = NodeMap.GetDat(SrcNodeMapping);
959        } else {
960          srcId = NewNet->AddNode();
961          NodeMap.AddDat(SrcNodeMapping, srcId);
962          NewNet->AddIntAttrDatN(srcId, srcNode, TStr("Id"));
963          NewNet->AddIntAttrDatN(srcId, Mode1, TStr("Mode"));
964          AddNodeAttributes(NewNet, Mode1Net, Mode1Attrs, Mode1, srcNode, srcId);
965        }
966        TIntPr DstNodeMapping(Mode2, dstNode);
967        int dstId = 0;
968        if (NodeMap.IsKey(DstNodeMapping)) {
969          dstId = NodeMap.GetDat(DstNodeMapping);
970        } else {
971          dstId = NewNet->AddNode();
972          NodeMap.AddDat(DstNodeMapping, dstId);
973          NewNet->AddIntAttrDatN(dstId, dstNode, TStr("Id"));
974          NewNet->AddIntAttrDatN(dstId, Mode2, TStr("Mode"));
975          AddNodeAttributes(NewNet, Mode2Net, Mode2Attrs, Mode2, dstNode, dstId);
976        }
977        int edgeId = EdgeI.GetId();
978        int newEId = NewNet->AddEdge(srcId, dstId);
979        NewNet->AddIntAttrDatE(newEId, edgeId, TStr("Id"));
980        NewNet->AddIntAttrDatE(newEId, CrossNetTypes[i], TStr("CrossNet"));
981        AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, newEId);
982        if (!isDirected) {
983          int otherEId = NewNet->AddEdge(dstId, srcId);
984          NewNet->AddIntAttrDatE(otherEId, edgeId, TStr("Id"));
985          NewNet->AddIntAttrDatE(otherEId, CrossNetTypes[i], TStr("CrossNet"));
986          AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, otherEId);
987        }
988      }
989    }
990    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
991      TInt ModeId = it.GetKey();
992      TModeNet &ModeNet = GetModeNetById(ModeId);
993      TStrPrV ModeAttrs = NodeAttrMap.GetDat(ModeId);
994      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
995        TIntPr NodeKey(ModeId, NodeIt.GetId());
996        if (!NodeMap.IsKey(NodeKey)) {
997          int newId = NewNet->AddNode();
998          NodeMap.AddDat(NodeKey, newId);
999          AddNodeAttributes(NewNet, ModeNet, ModeAttrs, ModeId, NodeIt.GetId(), newId);
1000        }
1001      }
1002    }
1003    return NewNet;
1004  }
1005  void TMMNet::GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxLen) const {
1006    if (MxLen <= NumPartitions) {
1007        Partitions.Add(TIntPr(0,MxLen));
1008    } else {
1009      TInt PartitionSize = MxLen/NumPartitions;
1010      TInt CurrStart = 0;
1011      bool done = false;
1012      while (!done) {
1013        TInt CurrEnd = CurrStart + PartitionSize;
1014        if (MxLen - CurrEnd < PartitionSize) {
1015          CurrEnd = MxLen;
1016          done = true;
1017        }
1018        Partitions.Add(TIntPr(CurrStart, CurrEnd));
1019        CurrStart = CurrEnd;
1020      }
1021    }
1022  }
1023  #ifdef GCC_ATOMIC
1024  PNEANetMP TMMNet::ToNetworkMP(TStrV& CrossNetNames) {
1025    TStrIntH CrossNetStart;
1026    THashSet<TInt> ModeSet;
1027    int offset = 0;
1028    int NumEdges = 0;
1029    TVec<TCrossNet> CrossNets;
1030    for (int i=0; i < CrossNetNames.Len(); i++) {
1031      CrossNets.Add(GetCrossNetByName(CrossNetNames[i]));
1032      CrossNetStart.AddDat(CrossNetNames[i], offset);
1033      TCrossNet& CrossNet = GetCrossNetByName(CrossNetNames[i]);
1034      int factor = CrossNet.IsDirected() ? 1 : 2;
1035      offset += (CrossNet.GetMxEId() * factor);
1036      NumEdges += (CrossNet.GetEdges() * factor);
1037      ModeSet.AddKey(CrossNet.GetMode1());
1038      ModeSet.AddKey(CrossNet.GetMode2());
1039    }
1040    int MxEId = offset;
1041    int NumNodes = 0;
1042    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1043      TModeNet& ModeNet = GetModeNetById(MI.GetKey());
1044      NumNodes += ModeNet.GetNodes();
1045    }
1046    THashMP<TIntPr, TInt> NodeMap(NumNodes);
1047    THashMP<TIntPr, TIntPr> EdgeMap(NumEdges);
1048    PNEANetMP NewNet = TNEANetMP::New(NumNodes, NumEdges);
1049    int num_threads = omp_get_max_threads();
1050    offset = 0;
1051    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1052      TInt ModeId = MI.GetKey();
1053      TModeNet& ModeNet = GetModeNetById(ModeId);
1054      TIntV KeyIds;
1055      ModeNet.NodeH.GetKeyV(KeyIds);
1056      TIntPrV NodePartitions;
1057      GetPartitionRanges(NodePartitions, num_threads, KeyIds.Len());
1058      int curr_nid;
1059      #pragma omp parallel for schedule(static) private(curr_nid)
1060      for (int i = 0; i < NodePartitions.Len(); i++) {
1061        TInt CurrStart = NodePartitions[i].GetVal1();
1062        TInt CurrEnd = NodePartitions[i].GetVal2();
1063        curr_nid = offset + CurrStart;
1064        for (int idx = CurrStart; idx < CurrEnd ; idx++) {
1065          int n_i = KeyIds[idx];
1066          if (ModeNet.IsNode(n_i)) {
1067            TIntV InNbrs;
1068            TIntV OutNbrs;
1069            for (int j=0; j < CrossNetNames.Len(); j++) {
1070              TStr CrossNetName = TStr(CrossNetNames[j].CStr());
1071              if (ModeNet.NeighborTypes.IsKey(CrossNetName)) {
1072                if (ModeNet.NeighborTypes.GetDat(CrossNetName)) {
1073                  TIntV Neighbors;
1074                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, Neighbors);
1075                  int edge_offset = CrossNetStart.GetDat(CrossNetName);
1076                  TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1077                  bool isDir = CrossNet.IsDirected();
1078                  bool isOutNbr = CrossNet.GetMode1() == ModeId;
1079                  int factor = isDir ? 1 : 2;
1080                  int id_offset = isDir || isOutNbr ? 0 : 1;
1081                  if (!isDir && CrossNet.GetMode1() == CrossNet.GetMode2()) {
1082                    id_offset = n_i == CrossNet.GetEdge(n_i).GetSrcNId() ? 0 : 1;
1083                  }
1084                  for (int k = 0; k < Neighbors.Len(); k++) {
1085                    if (isOutNbr && id_offset == 0) {
1086                      OutNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1087                    } else {
1088                      InNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1089                    }
1090                    if (!isDir) {
1091                      int opp_offset = id_offset == 1 ? 0 : 1;
1092                      if (isOutNbr && id_offset == 0) {
1093                        InNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1094                      } else {
1095                        OutNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1096                      }
1097                    }
1098                  }
1099                } else {
1100                  TIntV TempOut;
1101                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempOut, true);
1102                  OutNbrs.AddV(TempOut);
1103                  TIntV TempIn;
1104                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempIn, false);
1105                  InNbrs.AddV(TempIn);
1106                }
1107              }
1108            }
1109            NewNet->AddNodeWithEdges(curr_nid, InNbrs, OutNbrs);
1110            TIntPr NodeKey(MI.GetKey(), n_i);
1111            NodeMap.AddDat(NodeKey, curr_nid);
1112            curr_nid++;
1113          }
1114        }
1115      }
1116      offset += KeyIds.Len();
1117    }
1118    NewNet->SetNodes(offset);
1119    for (int j=0; j < CrossNetNames.Len(); j++) {
1120      TStr CrossNetName = CrossNetNames[j];
1121      TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1122      TInt CrossNetId = GetCrossId(CrossNetName);
1123      TInt Mode1 = CrossNet.GetMode1();
1124      TInt Mode2 = CrossNet.GetMode2();
1125      TIntPrV EdgePartitions;
1126      GetPartitionRanges(EdgePartitions, num_threads, CrossNet.MxEId);
1127      int curr_eid;
1128      offset = CrossNetStart.GetDat(CrossNetNames[j]);
1129      int factor = CrossNet.IsDirected() ? 1 : 2;
1130      #pragma omp parallel for schedule(static) private(curr_eid)
1131      for (int i = 0; i < EdgePartitions.Len(); i++) {
1132        TInt CurrStart = EdgePartitions[i].GetVal1();
1133        TInt CurrEnd = EdgePartitions[i].GetVal2();
1134        for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) {
1135          curr_eid = offset + factor*e_i;
1136          if (CrossNet.IsEdge(e_i)) {
1137            int new_eid = curr_eid;
1138            TIntPr EdgeKey(CrossNetId, e_i);
1139            TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i);
1140            int srcNode = edge.GetSrcNId();
1141            int dstNode = edge.GetDstNId();
1142            TIntPr NodeKeySrc(Mode1, srcNode);
1143            TIntPr NodeKeyDst(Mode2, dstNode);
1144            int newSrc = NodeMap.GetDat(NodeKeySrc);
1145            int newDst = NodeMap.GetDat(NodeKeyDst);
1146            NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst);
1147            curr_eid++;
1148            int otherEId = -1;
1149            if (!CrossNet.IsDirected()) {
1150              otherEId = curr_eid;
1151              NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc);
1152            }
1153            EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId));
1154          }
1155        }
1156      }
1157    }
1158    NewNet->SetEdges(MxEId);
1159    NewNet->ReserveAttr(2, 0, 0, 2, 0, 0);
1160    NewNet->AddIntAttrN(TStr("Mode"));
1161    NewNet->AddIntAttrN(TStr("Id"));
1162    NewNet->AddIntAttrE(TStr("CrossNet"));
1163    NewNet->AddIntAttrE(TStr("Id"));
1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
1169      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal2(), TStr("Id"));
1170    }
1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1176      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1177      if (EdgeMap.GetDat(NewEdgeIds[i]).GetVal2() != -1) {
1178        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1179        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1180      }
1181    }
1182    return NewNet;
1183  }
1184  #endif 
1185  int TMMNet::AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId) {
1186    for (int i = 0; i < Attrs.Len(); i++) {
1187      TStr OrigAttr = Attrs[i].Val1;
1188      TStr NewAttr = Attrs[i].Val2;
1189      int type = Net.GetAttrTypeN(OrigAttr);
1190      if (type == TModeNet::IntType) {
1191        TIntPr OldNId(ModeId, oldId);
1192        TInt Val = Net.GetIntAttrDatN(oldId, OrigAttr);
1193        NewNet->AddIntAttrDatN(NId, Val, NewAttr);
1194      } else if (type == TModeNet::FltType) {
1195        TIntPr OldNId(ModeId, oldId);
1196        TFlt Val = Net.GetFltAttrDatN(oldId, OrigAttr);
1197        NewNet->AddFltAttrDatN(NId, Val, NewAttr);
1198      } else if (type == TModeNet::StrType) {
1199        TIntPr OldNId(ModeId, oldId);
1200        TStr Val = Net.GetStrAttrDatN(oldId, OrigAttr);
1201        NewNet->AddStrAttrDatN(NId, Val, NewAttr);
1202      } else if (type == TModeNet::IntVType) {
1203        TIntPr OldNId(ModeId, oldId);
1204        TIntV Val = Net.GetIntVAttrDatN(oldId, OrigAttr);
1205        NewNet->AddIntVAttrDatN(NId, Val, NewAttr);
1206      }
1207    }
1208    return 0;
1209  }
1210  int TMMNet::AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId) {
1211    for (int i = 0; i < Attrs.Len(); i++) {
1212      TStr OrigAttr = Attrs[i].Val1;
1213      TStr NewAttr = Attrs[i].Val2;
1214      int type = Net.GetAttrTypeE(OrigAttr);
1215      if (type == TCrossNet::IntType) {
1216        TIntPr OldNId(CrossId, oldId);
1217        TInt Val = Net.GetIntAttrDatE(oldId, OrigAttr);
1218        NewNet->AddIntAttrDatE(EId, Val, NewAttr);
1219      } else if (type == TCrossNet::FltType) {
1220        TIntPr OldNId(CrossId, oldId);
1221        TFlt Val = Net.GetFltAttrDatE(oldId, OrigAttr);
1222        NewNet->AddFltAttrDatE(EId, Val, NewAttr);
1223      } else if (type == TCrossNet::StrType) {
1224        TIntPr OldNId(CrossId, oldId);
1225        TStr Val = Net.GetStrAttrDatE(oldId, OrigAttr);
1226        NewNet->AddStrAttrDatE(EId, Val, NewAttr);
1227      }
1228    }
1229    return 0;
1230  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-functionParser.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>105  	}
106  	return true;
107  }
108  bool FunctionParsersManager::loadFuncListFromXmlTree(const generic_string & xmlDirPath, LangType lType, const generic_string& overrideId, int udlIndex)
109  {
110  	generic_string funcListRulePath = xmlDirPath;
</pre></code></div>
                <div class="column column_space"><pre><code>8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    