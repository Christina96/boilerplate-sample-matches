
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.8783690393918455%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</h3>
            <pre><code>1  #include "corrgr.h"
2  void TCorrGroups::GetCorrSimVV(TFltVV& SimVV) const {
3    int Vars=GetVars();
4    SimVV.Gen(Vars, Vars);
5    for (int VarN1=0; VarN1<Vars; VarN1++){
6      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
7      TNotify::OnStatus(Notify, MsgStr);
8      SimVV.At(VarN1, VarN1)=1;
9      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
10        PCorr Corr=TCorr::New(VarValVV[VarN1], VarValVV[VarN2]);
11        SimVV.At(VarN1, VarN2)=fabs(Corr->GetCorrCf());
12        SimVV.At(VarN2, VarN1)=fabs(Corr->GetCorrCf());
13      }
14    }
15    TNotify::OnStatus(Notify, "\n");
16  }
17  void TCorrGroups::GetEuclSimVV(TFltVV& SimVV) const {
18    int Vars=GetVars();
19    SimVV.Gen(Vars, Vars);
20    for (int VarN1=0; VarN1<Vars; VarN1++){
21      TStr MsgStr=TStr("Var:")+TInt::GetStr(VarN1+1)+"/"+TInt::GetStr(Vars)+"\r";
22      TNotify::OnStatus(Notify, MsgStr);
23      SimVV.At(VarN1, VarN1)=1;
24      for (int VarN2=VarN1+1; VarN2<Vars; VarN2++){
25        double Sim=0;
26        for (int ValN=0; ValN<VarValVV[VarN1].Len(); ValN++){
27          double ValSim=VarValVV[VarN1][ValN]-VarValVV[VarN2][ValN];
28          Sim+=TMath::Sqr(ValSim);
29        }
30        Sim=-sqrt(Sim);
31        SimVV.At(VarN1, VarN2)=Sim;
32        SimVV.At(VarN2, VarN1)=Sim;
33      }
34    }
35    TNotify::OnStatus(Notify, "\n");
36  }
37  void TCorrGroups::GetSimVVFromData(TFltVV& SimVV) const {
38    IAssert(VarValVV[0].Len()==VarValVV.Len());
39    SimVV.Gen(VarValVV.Len(), VarValVV.Len());
40    for (int Y=0; Y<VarValVV.Len(); Y++){
41      for (int X=0; X<VarValVV.Len(); X++){
42        SimVV.At(Y, X)=VarValVV[Y][X];
43      }
44    }
45  }
46  void TCorrGroups::SetGroups(const double& _CorrCfTsh){
47    TNotify::OnNotify(Notify, ntInfo,
48     "Calculating Correlation Groups for Threshold "+TFlt::GetStr(CorrCfTsh));
49    CorrCfTsh=_CorrCfTsh;
50    int Vars=GetVars();
51    TFltVV CorrCfVV; GetCorrSimVV(CorrCfVV);
52    PGraph Graph=TGGraph::New();
53    for (int VarN=0; VarN<Vars; VarN++){
54      TStr VarNm=TInt::GetStr(VarN);
55      PVrtx Vrtx=PVrtx(new TGVrtx(VarNm));
56      Graph->AddVrtx(Vrtx);
57    }
58    int GoodCorrs=0;
59    for (int VarN1=0; VarN1<Vars; VarN1++){
60      for (int VarN2=VarN1; VarN2<Vars; VarN2++){
61        if ((VarN1!=VarN2)&&(fabs(CorrCfVV.At(VarN1, VarN2))>CorrCfTsh)){
62          GoodCorrs++;
63          TStr MsgStr=TStr("Good Correlations:")+TInt::GetStr(GoodCorrs)+"\r";
<span onclick='openModal()' class='match'>64          TNotify::OnStatus(Notify, MsgStr);
65          TStr VrtxNm1=TInt::GetStr(VarN1);
66          TStr VrtxNm2=TInt::GetStr(VarN2);
67          TStr ENm=TFlt::GetStr(CorrCfVV.At(VarN1, VarN2), "%0.2f");
</span>68          PVrtx Vrtx1=Graph->GetVrtx(VrtxNm1);
69          PVrtx Vrtx2=Graph->GetVrtx(VrtxNm2);
70          PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, ENm, false));
71          Graph->AddEdge(Edge);
72        }
73      }
74    }
75    TNotify::OnStatus(Notify, "\n");
76    VarNVV.Clr();
77    TBoolV VarUsedV(Vars);
78    {for (int VarN=0; VarN<Vars; VarN++){
79      if (!VarUsedV[VarN]){
80        VarUsedV[VarN]=true;
81        VarNVV.Add();
82        TStr VrtxNm=TInt::GetStr(VarN);
83        PVrtx Vrtx=Graph->GetVrtx(VrtxNm);
84        TVrtxV ConnVrtxV;
85        Graph->GetConnVrtxV(Vrtx, ConnVrtxV);
86        for (int ConnVrtxN=0; ConnVrtxN<ConnVrtxV.Len(); ConnVrtxN++){
87          PVrtx ConnVrtx=ConnVrtxV[ConnVrtxN];
88          TStr ConnVrtxVNm=ConnVrtx->GetVNm();
89          int ConnVarN=ConnVrtxVNm.GetInt();
90          VarNVV.Last().Add(ConnVarN);
91          VarUsedV[ConnVrtx->GetVId()]=true;
92        }
93      }
94    }}
95    TNotify::OnNotify(Notify, ntInfo, "... Done.");
96  }
97  void TCorrGroups::GetGroupCentroid(const TIntV& VarNV, TMomV& VarValMomV) const {
98    int Recs=GetRecs();
99    TMom::NewV(VarValMomV, Recs);
100    for (int VarNN=0; VarNN<VarNV.Len(); VarNN++){
101      int VarN=VarNV[VarNN];
102      for (int RecN=0; RecN<Recs; RecN++){
103        double Val=VarValVV[VarN][RecN];
104        VarValMomV[RecN]->Add(Val);
105      }
106    }
107    TMom::DefV(VarValMomV);
108  }
109  PGraph TCorrGroups::GetHClustGraph(const TFltVV& SimVV) const {
110    PGraph HClustGraph=TGGraph::New();
111    TVrtxV VrtxV(GetVars()); TVec<TIntV> VarNVV(GetVars());
112    for (int VarN=0; VarN<GetVars(); VarN++){
113      PVrtx Vrtx=PVrtx(new TGVrtx(VarN, GetVarNm(VarN)));
114      HClustGraph->AddVrtx(Vrtx);
115      VrtxV[VarN]=Vrtx; VarNVV[VarN].Add(VarN);
116    }
117    for (int HClustJoinN=0; HClustJoinN<GetVars()-1; HClustJoinN++){
118      printf("Join %d\r", HClustJoinN);
119      bool FirstMx=true; double MxMeanSim=0; int MxVrtxN1=-1; int MxVrtxN2=-1;
120      for (int VrtxN1=0; VrtxN1<VrtxV.Len(); VrtxN1++){
121        PVrtx Vrtx1=VrtxV[VrtxN1];
122        if (!Vrtx1.Empty()){
123          for (int VrtxN2=VrtxN1+1; VrtxN2<VrtxV.Len(); VrtxN2++){
124            PVrtx Vrtx2=VrtxV[VrtxN2];
125            if (!Vrtx2.Empty()){
126              TIntV& VarNV1=VarNVV[VrtxN1];
127              TIntV& VarNV2=VarNVV[VrtxN2];
128              double SumSim=0;
129              for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
130                for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
131                  SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
132                }
133              }
134              double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
135              if ((FirstMx)||(MeanSim>MxMeanSim)){
136                FirstMx=false;
137                MxMeanSim=MeanSim; MxVrtxN1=VrtxN1; MxVrtxN2=VrtxN2;
138              }
139            }
140          }
141        }
142      }
143      PVrtx JoinVrtx=PVrtx(new TGVrtx()); HClustGraph->AddVrtx(JoinVrtx);
144      PEdge JoinEdge1=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN1]));
145      PEdge JoinEdge2=PEdge(new TGEdge(JoinVrtx, VrtxV[MxVrtxN2]));
146      HClustGraph->AddEdge(JoinEdge1); HClustGraph->AddEdge(JoinEdge2);
147      JoinVrtx->PutWgt(MxMeanSim);
148      VrtxV[MxVrtxN1]=JoinVrtx; VrtxV[MxVrtxN2]=NULL;
149      VarNVV[MxVrtxN1].AddV(VarNVV[MxVrtxN2]); VarNVV[MxVrtxN2].Clr();
150    }
151    return HClustGraph;
152  }
153  PGraph TCorrGroups::GetHClustGraph() const {
154    TFltVV SimVV; GetCorrSimVV(SimVV);
155    return GetHClustGraph(SimVV);
156  }
157  void TCorrGroups::SetHClustGroups(const TFltVV& SimVV, const int& Groups){
158    int Vars=GetVars();
159    IAssert((0<Groups)&&(Groups<=Vars));
160    VarNVV.Gen(Vars);
161    for (int VarN=0; VarN<Vars; VarN++){VarNVV[VarN].Add(VarN);}
162    for (int HClustJoinN=0; HClustJoinN<Vars-Groups; HClustJoinN++){
163      printf("Join %d\r", HClustJoinN);
164      bool FirstMx=true; double MxMeanSim=0; int MxVarNVN1=-1; int MxVarNVN2=-1;
165      for (int VarNVN1=0; VarNVN1<VarNVV.Len(); VarNVN1++){
166        for (int VarNVN2=VarNVN1+1; VarNVN2<VarNVV.Len(); VarNVN2++){
167          TIntV& VarNV1=VarNVV[VarNVN1];
168          TIntV& VarNV2=VarNVV[VarNVN2];
169          double SumSim=0;
170          for (int VarNN1=0; VarNN1<VarNV1.Len(); VarNN1++){
171            for (int VarNN2=0; VarNN2<VarNV2.Len(); VarNN2++){
172              SumSim+=SimVV.At(VarNV1[VarNN1], VarNV2[VarNN2]);
173            }
174          }
175          double MeanSim=SumSim/(VarNV1.Len()*VarNV2.Len());
176          if ((FirstMx)||(MeanSim>MxMeanSim)){
177            FirstMx=false;
178            MxMeanSim=MeanSim; MxVarNVN1=VarNVN1; MxVarNVN2=VarNVN2;
179          }
180        }
181      }
182      VarNVV[MxVarNVN1].AddV(VarNVV[MxVarNVN2]);
183      VarNVV.Del(MxVarNVN2);
184    }
185  }
186  void TCorrGroups::SetKMeansGroups(const int& Groups, const int& Trials){
187    TRnd Rnd(1); int Vars=GetVars(); int Recs=GetRecs();
188    IAssert((0<Groups)&&(Groups<=Vars));
189    double BestQual=0; TVec<TIntV> BestVarNVV;
190    for (int TrialN=0; TrialN<Trials; TrialN++){
191      printf("Trial: %d\n", TrialN);
192      TVec<TFltV> CentrVarNV(Groups);
193      for (int CentrN=0; CentrN<Groups; CentrN++){
194        int CentrVarN=Rnd.GetUniDevInt(Vars);
195        CentrVarNV[CentrN]=VarValVV[CentrVarN];
196      }
197      double PrevQual=0; double Qual=0;
198      do {
199        PrevQual=Qual;
200        VarNVV.Gen(Groups);
201        for (int VarN=0; VarN<Vars; VarN++){
202          TFltV SimV(Groups);
203          for (int CentrN=0; CentrN<Groups; CentrN++){
204            PCorr Corr=TCorr::New(CentrVarNV[CentrN], VarValVV[VarN]);
205            SimV[CentrN]=fabs(Corr->GetCorrCf());
206          }
207          int BestGroupN=SimV.GetMxValN();
208          VarNVV[BestGroupN].Add(VarN);
209        }
210        for (int CentrN=0; CentrN<Groups; CentrN++){
211          TMomV VarValMomV; GetGroupCentroid(VarNVV[CentrN], VarValMomV);
212          for (int RecN=0; RecN<Recs; RecN++){
213            if (VarValMomV[RecN]->IsUsable()){
214              CentrVarNV[CentrN][RecN]=VarValMomV[RecN]->GetMedian();
215            } else {
216              CentrVarNV[CentrN][RecN]=0;
217            }
218          }
219        }
220        Qual=0;
221        for (int GroupN=0; GroupN<Groups; GroupN++){
222          int GroupVars=VarNVV[GroupN].Len();
223          for (int VarNN=0; VarNN<GroupVars; VarNN++){
224            int VarN=VarNVV[GroupN][VarNN];
225            PCorr Corr=TCorr::New(CentrVarNV[GroupN], VarValVV[VarN]);
226            double Sim=fabs(Corr->GetCorrCf());
227            Qual+=TMath::Sqr(Sim);
228          }
229        }
230        if ((PrevQual==0)||(Qual<BestQual)){
231          BestQual=Qual; BestVarNVV=VarNVV;
232        }
233        if (PrevQual!=0){
234          printf("   %g (%g)\n", Qual, PrevQual/Qual);}
235      } while ((PrevQual==0)||(PrevQual/Qual<0.9999));
236    }
237    VarNVV=BestVarNVV;
238  }
239  PCorrGroups TCorrGroups::LoadTxtVarCVal(const TStr& FNm){
240    TStrV VarNmV; 
241    TStrV RecNmV; 
242    TVec<TFltV> VarValVV; 
243    TILx Lx(TFIn::New(FNm), TFSet(iloRetEoln, iloSigNum));
244    Lx.GetSym(syInt, syEof); int RecN=0;
245    while (Lx.Sym!=syEof){
246      RecN++; TStr RecNm=TInt::GetStr(RecN);
247      RecNmV.Add(RecNm);
248      int PrevVarN=-1; TStrV CurVarNmV; TFltV VarValV(VarNmV.Len(), 0);
249      while (Lx.Sym!=syEoln){
250        IAssert((PrevVarN==-1)||(PrevVarN+1==Lx.Int));
251        PrevVarN=Lx.Int;
252        TStr VarNm=TInt::GetStr(Lx.Int);
253        CurVarNmV.Add(VarNm);
254        Lx.GetSym(syColon);
255        double VarVal=Lx.GetFlt();
256        VarValV.Add(VarVal);
257        Lx.GetSym(syInt, syEoln);
258      }
259      if (VarNmV.Empty()){VarNmV=CurVarNmV;}
260      else {IAssert(VarNmV==CurVarNmV);}
261      VarValVV.Add(VarValV);
262      Lx.GetSym(syInt, syEof);
263    }
264    PCorrGroups CorrGroups=New(VarNmV, RecNmV, VarValVV, TNotify::StdNotify);
265    return CorrGroups;
266  }
267  void TCorrGroups::SaveTxt(
268   const PSOut& SOut, const bool& CentrP, const bool& SqrtValP) const {
269    SOut->PutStr("==============================="); SOut->PutLn();
270    for (int GroupN=0; GroupN<VarNVV.Len(); GroupN++){
271      SOut->PutStr("Group"); SOut->PutInt(GroupN);
272      SOut->PutInt(VarNVV[GroupN].Len(), "(%d)");
273      SOut->PutStr(":"); SOut->PutLn();
274      for (int VarNN=0; VarNN<VarNVV[GroupN].Len(); VarNN++){
275        int VarN=VarNVV[GroupN][VarNN];
276        SOut->PutStr("   ");
277        SOut->PutStr(GetVarNm(VarN));
278        SOut->PutLn();
279      }
280      VarNVV[GroupN].Sort();
281      if (CentrP){
282        TIntV VarNV; GetGroup(GroupN, VarNV);
283        TMomV VarValMomV; GetGroupCentroid(VarNV, VarValMomV);
284        SOut->PutStr("Centroid:\n");
285        for (int RecN=0; RecN<GetRecs(); RecN++){
286          SOut->PutStr("  ");
287          SOut->PutStr(GetRecNm(RecN));
288          SOut->PutStr(":");
289          if (!VarValMomV[RecN]->IsUsable()){
290            SOut->PutStr("X");
291          } else {
292            if (SqrtValP){
293              SOut->PutFlt(sqrt(VarValMomV[RecN]->GetMean()), "%0.0f");
294            } else {
295              SOut->PutFlt(VarValMomV[RecN]->GetMean());
296            }
297          }
298          if ((RecN+1)%8==0){SOut->PutLn();}
299        }
300        SOut->PutLn();
301      }
302      SOut->PutLn();
303    }
304  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-crc_x86_arm_combined.cc</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdint>
3  #include "absl/base/attributes.h"
4  #include "absl/base/config.h"
5  #include "absl/base/dynamic_annotations.h"
6  #include "absl/base/internal/endian.h"
7  #include "absl/base/prefetch.h"
8  #include "absl/crc/internal/cpu_detect.h"
9  #include "absl/crc/internal/crc.h"
10  #include "absl/crc/internal/crc32_x86_arm_combined_simd.h"
11  #include "absl/crc/internal/crc_internal.h"
12  #include "absl/memory/memory.h"
13  #include "absl/numeric/bits.h"
14  #if defined(ABSL_CRC_INTERNAL_HAVE_ARM_SIMD) || \
15      defined(ABSL_CRC_INTERNAL_HAVE_X86_SIMD)
16  #define ABSL_INTERNAL_CAN_USE_SIMD_CRC32C
17  #endif
18  namespace absl {
19  ABSL_NAMESPACE_BEGIN
20  namespace crc_internal {
21  #if defined(ABSL_INTERNAL_CAN_USE_SIMD_CRC32C)
22  namespace {
23  class CRC32AcceleratedX86ARMCombined : public CRC32 {
24   public:
25    CRC32AcceleratedX86ARMCombined() {}
26    ~CRC32AcceleratedX86ARMCombined() override {}
27    void ExtendByZeroes(uint32_t* crc, size_t length) const override;
28    uint32_t ComputeZeroConstant(size_t length) const;
29   private:
30    CRC32AcceleratedX86ARMCombined(const CRC32AcceleratedX86ARMCombined&) =
31        delete;
32    CRC32AcceleratedX86ARMCombined& operator=(
33        const CRC32AcceleratedX86ARMCombined&) = delete;
34  };
35  constexpr size_t kSmallCutoff = 256;
36  constexpr size_t kMediumCutoff = 2048;
37  #define ABSL_INTERNAL_STEP1(crc)                      \
38    do {                                                \
39      crc = CRC32_u8(static_cast<uint32_t>(crc), *p++); \
40    } while (0)
41  #define ABSL_INTERNAL_STEP2(crc)                                               \
42    do {                                                                         \
43      crc =                                                                      \
44          CRC32_u16(static_cast<uint32_t>(crc), absl::little_endian::Load16(p)); \
45      p += 2;                                                                    \
46    } while (0)
47  #define ABSL_INTERNAL_STEP4(crc)                                               \
48    do {                                                                         \
49      crc =                                                                      \
50          CRC32_u32(static_cast<uint32_t>(crc), absl::little_endian::Load32(p)); \
51      p += 4;                                                                    \
52    } while (0)
53  #define ABSL_INTERNAL_STEP8(crc, data)                  \
54    do {                                                  \
55      crc = CRC32_u64(static_cast<uint32_t>(crc),         \
56                      absl::little_endian::Load64(data)); \
57      data += 8;                                          \
58    } while (0)
59  #define ABSL_INTERNAL_STEP8BY2(crc0, crc1, p0, p1) \
60    do {                                             \
61      ABSL_INTERNAL_STEP8(crc0, p0);                 \
62      ABSL_INTERNAL_STEP8(crc1, p1);                 \
63    } while (0)
64  #define ABSL_INTERNAL_STEP8BY3(crc0, crc1, crc2, p0, p1, p2) \
65    do {                                                       \
66      ABSL_INTERNAL_STEP8(crc0, p0);                           \
67      ABSL_INTERNAL_STEP8(crc1, p1);                           \
68      ABSL_INTERNAL_STEP8(crc2, p2);                           \
69    } while (0)
70  namespace {
<span onclick='openModal()' class='match'>71  uint32_t multiply(uint32_t a, uint32_t b) {
72    V128 shifts = V128_From2x64(0, 1);
73    V128 power = V128_From2x64(0, a);
74    V128 crc = V128_From2x64(0, b);
</span>75    V128 res = V128_PMulLow(power, crc);
76    res = V128_ShiftLeft64(res, shifts);
77    return static_cast<uint32_t>(V128_Extract32<1>(res)) ^
78           CRC32_u32(0, static_cast<uint32_t>(V128_Low64(res)));
79  }
80  constexpr uint32_t kCRC32CPowers[] = {
81      0x82f63b78, 0x6ea2d55c, 0x18b8ea18, 0x510ac59a, 0xb82be955, 0xb8fdb1e7,
82      0x88e56f72, 0x74c360a4, 0xe4172b16, 0x0d65762a, 0x35d73a62, 0x28461564,
83      0xbf455269, 0xe2ea32dc, 0xfe7740e6, 0xf946610b, 0x3c204f8f, 0x538586e3,
84      0x59726915, 0x734d5309, 0xbc1ac763, 0x7d0722cc, 0xd289cabe, 0xe94ca9bc,
85      0x05b74f3f, 0xa51e1f42, 0x40000000, 0x20000000, 0x08000000, 0x00800000,
86      0x00008000, 0x82f63b78, 0x6ea2d55c, 0x18b8ea18, 0x510ac59a, 0xb82be955,
87      0xb8fdb1e7, 0x88e56f72, 0x74c360a4, 0xe4172b16, 0x0d65762a, 0x35d73a62,
88      0x28461564, 0xbf455269, 0xe2ea32dc, 0xfe7740e6, 0xf946610b, 0x3c204f8f,
89      0x538586e3, 0x59726915, 0x734d5309, 0xbc1ac763, 0x7d0722cc, 0xd289cabe,
90      0xe94ca9bc, 0x05b74f3f, 0xa51e1f42, 0x40000000, 0x20000000, 0x08000000,
91      0x00800000, 0x00008000,
92  };
93  }  
94  uint32_t CRC32AcceleratedX86ARMCombined::ComputeZeroConstant(
95      size_t length) const {
96    length >>= 2;
97    int index = absl::countr_zero(length);
98    uint32_t prev = kCRC32CPowers[index];
99    length &= length - 1;
100    while (length) {
101      index = absl::countr_zero(length);
102      prev = multiply(prev, kCRC32CPowers[index]);
103      length &= length - 1;
104    }
105    return prev;
106  }
107  void CRC32AcceleratedX86ARMCombined::ExtendByZeroes(uint32_t* crc,
108                                                      size_t length) const {
109    uint32_t val = *crc;
110    switch (length & 3) {
111      case 0:
112        break;
113      case 1:
114        val = CRC32_u8(val, 0);
115        break;
116      case 2:
117        val = CRC32_u16(val, 0);
118        break;
119      case 3:
120        val = CRC32_u8(val, 0);
121        val = CRC32_u16(val, 0);
122        break;
123    }
124    if (length > 3) {
125      val = multiply(val, ComputeZeroConstant(length));
126    }
127    *crc = val;
128  }
129  constexpr uint64_t kClmulConstants[] = {
130      0x09e4addf8, 0x0ba4fc28e, 0x00d3b6092, 0x09e4addf8, 0x0ab7aff2a,
131      0x102f9b8a2, 0x0b9e02b86, 0x00d3b6092, 0x1bf2e8b8a, 0x18266e456,
132      0x0d270f1a2, 0x0ab7aff2a, 0x11eef4f8e, 0x083348832, 0x0dd7e3b0c,
133      0x0b9e02b86, 0x0271d9844, 0x1b331e26a, 0x06b749fb2, 0x1bf2e8b8a,
134      0x0e6fc4e6a, 0x0ce7f39f4, 0x0d7a4825c, 0x0d270f1a2, 0x026f6a60a,
135      0x12ed0daac, 0x068bce87a, 0x11eef4f8e, 0x1329d9f7e, 0x0b3e32c28,
136      0x0170076fa, 0x0dd7e3b0c, 0x1fae1cc66, 0x010746f3c, 0x086d8e4d2,
137      0x0271d9844, 0x0b3af077a, 0x093a5f730, 0x1d88abd4a, 0x06b749fb2,
138      0x0c9c8b782, 0x0cec3662e, 0x1ddffc5d4, 0x0e6fc4e6a, 0x168763fa6,
139      0x0b0cd4768, 0x19b1afbc4, 0x0d7a4825c, 0x123888b7a, 0x00167d312,
140      0x133d7a042, 0x026f6a60a, 0x000bcf5f6, 0x19d34af3a, 0x1af900c24,
141      0x068bce87a, 0x06d390dec, 0x16cba8aca, 0x1f16a3418, 0x1329d9f7e,
142      0x19fb2a8b0, 0x02178513a, 0x1a0f717c4, 0x0170076fa,
143  };
144  enum class CutoffStrategy {
145    Fold3,
146    Unroll64CRC,
147  };
148  class CRC32AcceleratedX86ARMCombinedMultipleStreamsBase
149      : public CRC32AcceleratedX86ARMCombined {
150   protected:
151    ABSL_ATTRIBUTE_ALWAYS_INLINE void Process64BytesPclmul(
152        const uint8_t* p, V128* partialCRC) const {
153      V128 loopMultiplicands = V128_Load(reinterpret_cast<const V128*>(k1k2));
154      V128 partialCRC1 = partialCRC[0];
155      V128 partialCRC2 = partialCRC[1];
156      V128 partialCRC3 = partialCRC[2];
157      V128 partialCRC4 = partialCRC[3];
158      V128 tmp1 = V128_PMulHi(partialCRC1, loopMultiplicands);
159      V128 tmp2 = V128_PMulHi(partialCRC2, loopMultiplicands);
160      V128 tmp3 = V128_PMulHi(partialCRC3, loopMultiplicands);
161      V128 tmp4 = V128_PMulHi(partialCRC4, loopMultiplicands);
162      V128 data1 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 0));
163      V128 data2 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 1));
164      V128 data3 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 2));
165      V128 data4 = V128_LoadU(reinterpret_cast<const V128*>(p + 16 * 3));
166      partialCRC1 = V128_PMulLow(partialCRC1, loopMultiplicands);
167      partialCRC2 = V128_PMulLow(partialCRC2, loopMultiplicands);
168      partialCRC3 = V128_PMulLow(partialCRC3, loopMultiplicands);
169      partialCRC4 = V128_PMulLow(partialCRC4, loopMultiplicands);
170      partialCRC1 = V128_Xor(tmp1, partialCRC1);
171      partialCRC2 = V128_Xor(tmp2, partialCRC2);
172      partialCRC3 = V128_Xor(tmp3, partialCRC3);
173      partialCRC4 = V128_Xor(tmp4, partialCRC4);
174      partialCRC1 = V128_Xor(partialCRC1, data1);
175      partialCRC2 = V128_Xor(partialCRC2, data2);
176      partialCRC3 = V128_Xor(partialCRC3, data3);
177      partialCRC4 = V128_Xor(partialCRC4, data4);
178      partialCRC[0] = partialCRC1;
179      partialCRC[1] = partialCRC2;
180      partialCRC[2] = partialCRC3;
181      partialCRC[3] = partialCRC4;
182    }
183    ABSL_ATTRIBUTE_ALWAYS_INLINE uint64_t
184    FinalizePclmulStream(V128* partialCRC) const {
185      V128 partialCRC1 = partialCRC[0];
186      V128 partialCRC2 = partialCRC[1];
187      V128 partialCRC3 = partialCRC[2];
188      V128 partialCRC4 = partialCRC[3];
189      V128 reductionMultiplicands =
190          V128_Load(reinterpret_cast<const V128*>(k5k6));
191      V128 low = V128_PMulLow(reductionMultiplicands, partialCRC1);
192      V128 high = V128_PMulHi(reductionMultiplicands, partialCRC1);
193      partialCRC1 = V128_Xor(low, high);
194      partialCRC1 = V128_Xor(partialCRC1, partialCRC2);
195      low = V128_PMulLow(reductionMultiplicands, partialCRC3);
196      high = V128_PMulHi(reductionMultiplicands, partialCRC3);
197      partialCRC3 = V128_Xor(low, high);
198      partialCRC3 = V128_Xor(partialCRC3, partialCRC4);
199      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(k3k4));
200      low = V128_PMulLow(reductionMultiplicands, partialCRC1);
201      high = V128_PMulHi(reductionMultiplicands, partialCRC1);
202      V128 fullCRC = V128_Xor(low, high);
203      fullCRC = V128_Xor(fullCRC, partialCRC3);
204      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(k5k6));
205      V128 mask = V128_Load(reinterpret_cast<const V128*>(kMask));
206      V128 tmp = V128_PMul01(reductionMultiplicands, fullCRC);
207      fullCRC = V128_ShiftRight<8>(fullCRC);
208      fullCRC = V128_Xor(fullCRC, tmp);
209      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(k7k0));
210      tmp = V128_ShiftRight<4>(fullCRC);
211      fullCRC = V128_And(fullCRC, mask);
212      fullCRC = V128_PMulLow(reductionMultiplicands, fullCRC);
213      fullCRC = V128_Xor(tmp, fullCRC);
214      reductionMultiplicands = V128_Load(reinterpret_cast<const V128*>(kPoly));
215      tmp = V128_And(fullCRC, mask);
216      tmp = V128_PMul01(reductionMultiplicands, tmp);
217      tmp = V128_And(tmp, mask);
218      tmp = V128_PMulLow(reductionMultiplicands, tmp);
219      fullCRC = V128_Xor(tmp, fullCRC);
220      return static_cast<uint64_t>(V128_Extract32<1>(fullCRC));
221    }
222    ABSL_ATTRIBUTE_ALWAYS_INLINE uint64_t Process64BytesCRC(const uint8_t* p,
223                                                            uint64_t crc) const {
224      for (int i = 0; i < 8; i++) {
225        crc =
226            CRC32_u64(static_cast<uint32_t>(crc), absl::little_endian::Load64(p));
227        p += 8;
228      }
229      return crc;
230    }
231    alignas(16) static constexpr uint64_t k1k2[2] = {0x0740eef02, 0x09e4addf8};
232    alignas(16) static constexpr uint64_t k3k4[2] = {0x1384aa63a, 0x0ba4fc28e};
233    alignas(16) static constexpr uint64_t k5k6[2] = {0x0f20c0dfe, 0x14cd00bd6};
234    alignas(16) static constexpr uint64_t k7k0[2] = {0x0dd45aab8, 0x000000000};
235    alignas(16) static constexpr uint64_t kPoly[2] = {0x105ec76f0, 0x0dea713f1};
236    alignas(16) static constexpr uint32_t kMask[4] = {~0u, 0u, ~0u, 0u};
237    static constexpr size_t kGroupsSmall = 3;
238    static constexpr size_t kMaxStreams = 3;
239  };
240  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
241  alignas(16) constexpr uint64_t
242      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k1k2[2];
243  alignas(16) constexpr uint64_t
244      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k3k4[2];
245  alignas(16) constexpr uint64_t
246      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k5k6[2];
247  alignas(16) constexpr uint64_t
248      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::k7k0[2];
249  alignas(16) constexpr uint64_t
250      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kPoly[2];
251  alignas(16) constexpr uint32_t
252      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kMask[4];
253  constexpr size_t
254      CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kGroupsSmall;
255  constexpr size_t CRC32AcceleratedX86ARMCombinedMultipleStreamsBase::kMaxStreams;
256  #endif  
257  template <size_t num_crc_streams, size_t num_pclmul_streams,
258            CutoffStrategy strategy>
259  class CRC32AcceleratedX86ARMCombinedMultipleStreams
260      : public CRC32AcceleratedX86ARMCombinedMultipleStreamsBase {
261    ABSL_ATTRIBUTE_HOT
262    void Extend(uint32_t* crc, const void* bytes, size_t length) const override {
263      static_assert(num_crc_streams >= 1 && num_crc_streams <= kMaxStreams,
264                    "Invalid number of crc streams");
265      static_assert(num_pclmul_streams >= 0 && num_pclmul_streams <= kMaxStreams,
266                    "Invalid number of pclmul streams");
267      const uint8_t* p = static_cast<const uint8_t*>(bytes);
268      const uint8_t* e = p + length;
269      uint32_t l = *crc;
270      uint64_t l64;
271      if (length & 8) {
272        ABSL_INTERNAL_STEP8(l, p);
273        length &= ~size_t{8};
274      }
275      if (length & 4) {
276        ABSL_INTERNAL_STEP4(l);
277        length &= ~size_t{4};
278      }
279      if (length & 2) {
280        ABSL_INTERNAL_STEP2(l);
281        length &= ~size_t{2};
282      }
283      if (length & 1) {
284        ABSL_INTERNAL_STEP1(l);
285        length &= ~size_t{1};
286      }
287      if (length == 0) {
288        *crc = l;
289        return;
290      }
291      if (strategy != CutoffStrategy::Unroll64CRC) {
292        if (length < kSmallCutoff) {
293          while (length >= 16) {
294            ABSL_INTERNAL_STEP8(l, p);
295            ABSL_INTERNAL_STEP8(l, p);
296            length -= 16;
297          }
298          *crc = l;
299          return;
300        }
301      }
302      if (length < kMediumCutoff) {
303        l64 = l;
304        if (strategy == CutoffStrategy::Fold3) {
305          uint64_t l641 = 0;
306          uint64_t l642 = 0;
307          const size_t blockSize = 32;
308          size_t bs = static_cast<size_t>(e - p) / kGroupsSmall / blockSize;
309          const uint8_t* p1 = p + bs * blockSize;
310          const uint8_t* p2 = p1 + bs * blockSize;
311          for (size_t i = 0; i + 1 < bs; ++i) {
312            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
313            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
314            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
315            ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
316            PrefetchToLocalCache(
317                reinterpret_cast<const char*>(p + kPrefetchHorizonMedium));
318            PrefetchToLocalCache(
319                reinterpret_cast<const char*>(p1 + kPrefetchHorizonMedium));
320            PrefetchToLocalCache(
321                reinterpret_cast<const char*>(p2 + kPrefetchHorizonMedium));
322          }
323          ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
324          ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
325          ABSL_INTERNAL_STEP8BY3(l64, l641, l642, p, p1, p2);
326          ABSL_INTERNAL_STEP8BY2(l64, l641, p, p1);
327          V128 magic = *(reinterpret_cast<const V128*>(kClmulConstants) + bs - 1);
328          V128 tmp = V128_From2x64(0, l64);
329          V128 res1 = V128_PMulLow(tmp, magic);
330          tmp = V128_From2x64(0, l641);
331          V128 res2 = V128_PMul10(tmp, magic);
332          V128 x = V128_Xor(res1, res2);
333          l64 = static_cast<uint64_t>(V128_Low64(x)) ^
334                absl::little_endian::Load64(p2);
335          l64 = CRC32_u64(static_cast<uint32_t>(l642), l64);
336          p = p2 + 8;
337        } else if (strategy == CutoffStrategy::Unroll64CRC) {
338          while ((e - p) >= 64) {
339            l64 = Process64BytesCRC(p, l64);
340            p += 64;
341          }
342        }
343      } else {
344        const uint8_t* x = RoundUp<8>(p);
345        while (p != x) {
346          ABSL_INTERNAL_STEP1(l);
347        }
348        size_t bs = static_cast<size_t>(e - p) /
349                    (num_crc_streams + num_pclmul_streams) / 64;
350        const uint8_t* crc_streams[kMaxStreams];
351        const uint8_t* pclmul_streams[kMaxStreams];
352        crc_streams[0] = p;
353        for (size_t i = 1; i < num_crc_streams; i++) {
354          crc_streams[i] = crc_streams[i - 1] + bs * 64;
355        }
356        pclmul_streams[0] = crc_streams[num_crc_streams - 1] + bs * 64;
357        for (size_t i = 1; i < num_pclmul_streams; i++) {
358          pclmul_streams[i] = pclmul_streams[i - 1] + bs * 64;
359        }
360        uint64_t l64_crc[kMaxStreams] = {l};
361        uint64_t l64_pclmul[kMaxStreams] = {0};
362        for (size_t i = 0; i < num_crc_streams; i++) {
363          l64_crc[i] = Process64BytesCRC(crc_streams[i], l64_crc[i]);
364          crc_streams[i] += 16 * 4;
365        }
366        V128 partialCRC[kMaxStreams][4];
367        for (size_t i = 0; i < num_pclmul_streams; i++) {
368          partialCRC[i][0] = V128_LoadU(
369              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 0));
370          partialCRC[i][1] = V128_LoadU(
371              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 1));
372          partialCRC[i][2] = V128_LoadU(
373              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 2));
374          partialCRC[i][3] = V128_LoadU(
375              reinterpret_cast<const V128*>(pclmul_streams[i] + 16 * 3));
376          pclmul_streams[i] += 16 * 4;
377        }
378        for (size_t i = 1; i < bs; i++) {
379          for (size_t j = 0; j < num_crc_streams; j++) {
380            PrefetchToLocalCache(
381                reinterpret_cast<const char*>(crc_streams[j] + kPrefetchHorizon));
382          }
383          for (size_t j = 0; j < num_pclmul_streams; j++) {
384            PrefetchToLocalCache(reinterpret_cast<const char*>(pclmul_streams[j] +
385                                                               kPrefetchHorizon));
386          }
387          l64_crc[0] = Process64BytesCRC(crc_streams[0], l64_crc[0]);
388          crc_streams[0] += 16 * 4;
389          if (num_pclmul_streams > 0) {
390            Process64BytesPclmul(pclmul_streams[0], partialCRC[0]);
391            pclmul_streams[0] += 16 * 4;
392          }
393          if (num_crc_streams > 1) {
394            l64_crc[1] = Process64BytesCRC(crc_streams[1], l64_crc[1]);
395            crc_streams[1] += 16 * 4;
396          }
397          if (num_pclmul_streams > 1) {
398            Process64BytesPclmul(pclmul_streams[1], partialCRC[1]);
399            pclmul_streams[1] += 16 * 4;
400          }
401          if (num_crc_streams > 2) {
402            l64_crc[2] = Process64BytesCRC(crc_streams[2], l64_crc[2]);
403            crc_streams[2] += 16 * 4;
404          }
405          if (num_pclmul_streams > 2) {
406            Process64BytesPclmul(pclmul_streams[2], partialCRC[2]);
407            pclmul_streams[2] += 16 * 4;
408          }
409        }
410        for (size_t i = 0; i < num_pclmul_streams; i++) {
411          l64_pclmul[i] = FinalizePclmulStream(partialCRC[i]);
412        }
413        uint32_t magic = ComputeZeroConstant(bs * 64);
414        l64 = l64_crc[0];
415        for (size_t i = 1; i < num_crc_streams; i++) {
416          l64 = multiply(static_cast<uint32_t>(l64), magic);
417          l64 ^= l64_crc[i];
418        }
419        for (size_t i = 0; i < num_pclmul_streams; i++) {
420          l64 = multiply(static_cast<uint32_t>(l64), magic);
421          l64 ^= l64_pclmul[i];
422        }
423        if (num_pclmul_streams > 0) {
424          p = pclmul_streams[num_pclmul_streams - 1];
425        } else {
426          p = crc_streams[num_crc_streams - 1];
427        }
428      }
429      l = static_cast<uint32_t>(l64);
430      while ((e - p) >= 16) {
431        ABSL_INTERNAL_STEP8(l, p);
432        ABSL_INTERNAL_STEP8(l, p);
433      }
434      while (p != e) {
435        ABSL_INTERNAL_STEP1(l);
436      }
437  #undef ABSL_INTERNAL_STEP8BY3
438  #undef ABSL_INTERNAL_STEP8BY2
439  #undef ABSL_INTERNAL_STEP8
440  #undef ABSL_INTERNAL_STEP4
441  #undef ABSL_INTERNAL_STEP2
442  #undef ABSL_INTERNAL_STEP1
443      *crc = l;
444    }
445  };
446  }  
447  CRCImpl* TryNewCRC32AcceleratedX86ARMCombined() {
448    CpuType type = GetCpuType();
449    switch (type) {
450      case CpuType::kIntelHaswell:
451      case CpuType::kAmdRome:
452      case CpuType::kAmdNaples:
453      case CpuType::kAmdMilan:
454        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
455            3, 1, CutoffStrategy::Fold3>();
456      case CpuType::kIntelCascadelakeXeon:
457      case CpuType::kIntelSkylakeXeon:
458      case CpuType::kIntelBroadwell:
459      case CpuType::kIntelSkylake:
460        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
461            3, 2, CutoffStrategy::Fold3>();
462      case CpuType::kIntelIvybridge:
463      case CpuType::kIntelSandybridge:
464      case CpuType::kIntelWestmere:
465        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
466            3, 0, CutoffStrategy::Fold3>();
467      case CpuType::kArmNeoverseN1:
468        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
469            1, 1, CutoffStrategy::Unroll64CRC>();
470  #if defined(__aarch64__)
471      default:
472        if (SupportsArmCRC32PMULL()) {
473          return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
474              1, 1, CutoffStrategy::Unroll64CRC>();
475        } else {
476          return nullptr;
477        }
478  #else
479      default:
480        return new CRC32AcceleratedX86ARMCombinedMultipleStreams<
481            3, 0, CutoffStrategy::Fold3>();
482  #endif
483    }
484  }
485  std::vector<std::unique_ptr<CRCImpl>> NewCRC32AcceleratedX86ARMCombinedAll() {
486    auto ret = std::vector<std::unique_ptr<CRCImpl>>();
487    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
488                      1, 0, CutoffStrategy::Fold3>>());
489    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
490                      1, 1, CutoffStrategy::Fold3>>());
491    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
492                      1, 2, CutoffStrategy::Fold3>>());
493    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
494                      1, 3, CutoffStrategy::Fold3>>());
495    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
496                      2, 0, CutoffStrategy::Fold3>>());
497    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
498                      2, 1, CutoffStrategy::Fold3>>());
499    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
500                      2, 2, CutoffStrategy::Fold3>>());
501    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
502                      2, 3, CutoffStrategy::Fold3>>());
503    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
504                      3, 0, CutoffStrategy::Fold3>>());
505    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
506                      3, 1, CutoffStrategy::Fold3>>());
507    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
508                      3, 2, CutoffStrategy::Fold3>>());
509    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
510                      3, 3, CutoffStrategy::Fold3>>());
511    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
512                      1, 0, CutoffStrategy::Unroll64CRC>>());
513    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
514                      1, 1, CutoffStrategy::Unroll64CRC>>());
515    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
516                      1, 2, CutoffStrategy::Unroll64CRC>>());
517    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
518                      1, 3, CutoffStrategy::Unroll64CRC>>());
519    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
520                      2, 0, CutoffStrategy::Unroll64CRC>>());
521    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
522                      2, 1, CutoffStrategy::Unroll64CRC>>());
523    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
524                      2, 2, CutoffStrategy::Unroll64CRC>>());
525    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
526                      2, 3, CutoffStrategy::Unroll64CRC>>());
527    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
528                      3, 0, CutoffStrategy::Unroll64CRC>>());
529    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
530                      3, 1, CutoffStrategy::Unroll64CRC>>());
531    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
532                      3, 2, CutoffStrategy::Unroll64CRC>>());
533    ret.push_back(absl::make_unique<CRC32AcceleratedX86ARMCombinedMultipleStreams<
534                      3, 3, CutoffStrategy::Unroll64CRC>>());
535    return ret;
536  }
537  #else  
538  std::vector<std::unique_ptr<CRCImpl>> NewCRC32AcceleratedX86ARMCombinedAll() {
539    return std::vector<std::unique_ptr<CRCImpl>>();
540  }
541  CRCImpl* TryNewCRC32AcceleratedX86ARMCombined() { return nullptr; }
542  #endif
543  }  
544  ABSL_NAMESPACE_END
545  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-corrgr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-crc_x86_arm_combined.cc</div>
                </div>
                <div class="column column_space"><pre><code>64          TNotify::OnStatus(Notify, MsgStr);
65          TStr VrtxNm1=TInt::GetStr(VarN1);
66          TStr VrtxNm2=TInt::GetStr(VarN2);
67          TStr ENm=TFlt::GetStr(CorrCfVV.At(VarN1, VarN2), "%0.2f");
</pre></code></div>
                <div class="column column_space"><pre><code>71  uint32_t multiply(uint32_t a, uint32_t b) {
72    V128 shifts = V128_From2x64(0, 1);
73    V128 power = V128_From2x64(0, a);
74    V128 crc = V128_From2x64(0, b);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    