
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.0073260073260073%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-benchmark.hpp</h3>
            <pre><code>1  #ifndef CAFFE_UTIL_BENCHMARK_H_
2  #define CAFFE_UTIL_BENCHMARK_H_
3  #include <boost/date_time/posix_time/posix_time.hpp>
4  #include "caffe/util/device_alternate.hpp"
5  namespace caffe {
6  class Timer {
7   public:
8    Timer();
9    virtual ~Timer();
10    virtual void Start();
11    virtual void Stop();
12    virtual float MilliSeconds();
13    virtual float MicroSeconds();
14    virtual float Seconds();
15    virtual void InitTime();
16    virtual void InitTime(Timer &);
17    virtual float Duration();
18    inline bool initted() { return initted_; }
19    inline bool running() { return running_; }
20    inline bool has_run_at_least_once() { return has_run_at_least_once_; }
21   protected:
<span onclick='openModal()' class='match'>22    void Init();
23    bool initted_;
24    bool running_;
25    bool has_run_at_least_once_;
26  #ifndef CPU_ONLY
27    cudaEvent_t start_gpu_;
28    cudaEvent_t stop_gpu_;
29  #endif
30    boost::posix_time::ptime init_cpu_;
31    boost::posix_time::ptime start_cpu_;
32    boost::posix_time::ptime stop_cpu_;
33    float elapsed_milliseconds_;
34    float elapsed_microseconds_;
</span>35  };
36  class CPUTimer : public Timer {
37   public:
38    explicit CPUTimer();
39    virtual ~CPUTimer() {}
40    virtual void Start();
41    virtual void Stop();
42    virtual float MilliSeconds();
43    virtual float MicroSeconds();
44  };
45  }  
46  #endif   
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascdynetinf.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "cascdynetinf.h"
3  void TNIBs::LoadCascadesTxt(TSIn& SIn) {
4    TStr Line;
5    while (!SIn.Eof()) {
6      SIn.GetNextLn(Line);
7      if (Line=="") { break; }
8      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
9      AddNodeNm(NIdV[0].GetInt(), TNodeInfo(NIdV[1], 0)); 
10    }
11    printf("All nodes read!\n");
12    while (!SIn.Eof()) { SIn.GetNextLn(Line); AddCasc(Line, Model); }
13    printf("All cascades read!\n");
14  }
15  void TNIBs::LoadGroundTruthTxt(TSIn& SIn) {
16    bool verbose = false;
17    TStr Line;
18    Network.Clr(); 
19    while (!SIn.Eof()) {
20      SIn.GetNextLn(Line);
21      if (Line=="") { break; }
22      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
23      Network.AddNode(NIdV[0].GetInt(), NIdV[1]);
24      if (!IsNodeNm(NIdV[0].GetInt())) {
25        AddNodeNm(NIdV[0].GetInt(), TNodeInfo(NIdV[1], 0));
26        DomainsIdH.AddDat(NIdV[1]) = NIdV[0].GetInt();
27      }
28    }
29    while (!SIn.Eof()) {
30      SIn.GetNextLn(Line);
31      TStrV FieldsV; Line.SplitOnAllCh(',', FieldsV);
32      TFltFltH Alphas;
33      if (FieldsV.Len() == 3) { 
34      Alphas.AddDat(0.0) = FieldsV[2].GetFlt(); 
35      } else {
36        for (int i=2; i<FieldsV.Len()-1; i+=2) {
37          Alphas.AddDat(FieldsV[i].GetFlt()) = FieldsV[i+1].GetFlt();
38        }
39      }
40      Network.AddEdge(FieldsV[0].GetInt(), FieldsV[1].GetInt(), Alphas);
41      if (verbose) {
42        printf("Edge %d -> %d: ", FieldsV[0].GetInt(), FieldsV[1].GetInt());
43        TFltFltH &AlphasE = Network.GetEDat(FieldsV[0].GetInt(), FieldsV[1].GetInt());
44        for (int i=0; i<AlphasE.Len(); i+=2) { printf("(%f, %f)", AlphasE.GetKey(i).Val, AlphasE[i].Val); }
45        printf("\n");
46      }
47    }
48    printf("groundtruth nodes:%d edges:%d\n", Network.GetNodes(), Network.GetEdges());
49  }
50  void TNIBs::LoadGroundTruthNodesTxt(TSIn& SIn) {
51    TStr Line;
52    Network.Clr(); 
53    while (!SIn.Eof()) {
54      SIn.GetNextLn(Line);
55      if (Line=="") { break; }
56      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
57      Network.AddNode(NIdV[0].GetInt(), NIdV[1]);
58      if (!IsNodeNm(NIdV[0].GetInt())) {
59        AddNodeNm(NIdV[0].GetInt(), TNodeInfo(NIdV[1], 0));
60        DomainsIdH.AddDat(NIdV[1]) = NIdV[0].GetInt();
61      }
62    }
63    printf("groundtruth nodes:%d\n", Network.GetNodes());
64  }
65  void TNIBs::LoadInferredTxt(TSIn& SIn) {
66    bool verbose = false;
67    TStr Line;
68    InferredNetwork.Clr(); 
69    while (!SIn.Eof()) {
70      SIn.GetNextLn(Line);
71      if (Line=="") { break; }
72      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
73      if (DomainsIdH.IsKey(NIdV[1])) { IAssert(NIdV[0].GetInt()==DomainsIdH.GetDat(NIdV[1])); }
74      InferredNetwork.AddNode(NIdV[0].GetInt(), NIdV[1]);
75      if (!IsNodeNm(NIdV[0].GetInt())) { AddNodeNm(NIdV[0].GetInt(), TNodeInfo(NIdV[1], 0)); }
76      if (!DomainsIdH.IsKey(NIdV[1])) { DomainsIdH.AddDat(NIdV[1]) = NIdV[0].GetInt(); }
77      if (verbose) { printf("Node:%s\n", NIdV[1].CStr()); }
78    }
79    while (!SIn.Eof()) {
80      SIn.GetNextLn(Line);
81      TStrV FieldsV; Line.SplitOnAllCh(',', FieldsV);
82      TFltFltH Alphas;
83      if (FieldsV.Len() == 3) { 
84        Alphas.AddDat(0.0) = FieldsV[2].GetFlt(); 
85      } else {
86        for (int i=2; i<FieldsV.Len()-1; i+=2) {
87          Alphas.AddDat(FieldsV[i].GetFlt()) = FieldsV[i+1].GetFlt();
88        }
89      }
90      InferredNetwork.AddEdge(FieldsV[0].GetInt(), FieldsV[1].GetInt(), Alphas);
91      if (verbose) {
92        printf("Edge %d -> %d: ", FieldsV[0].GetInt(), FieldsV[1].GetInt());
93        TFltFltH &AlphasE = InferredNetwork.GetEDat(FieldsV[0].GetInt(), FieldsV[1].GetInt());
94        for (int i=0; i<AlphasE.Len(); i+=2) { printf("(%f, %f)", AlphasE.GetKey(i).Val, AlphasE[i].Val); }
95        printf("\n");
96      }
97    }
98    printf("inferred nodes:%d edges:%d\n", InferredNetwork.GetNodes(), InferredNetwork.GetEdges());
99  }
100  void TNIBs::LoadInferredNodesTxt(TSIn& SIn) {
101    TStr Line;
102    InferredNetwork.Clr(); 
103    while (!SIn.Eof()) {
104      SIn.GetNextLn(Line);
105      if (Line=="") { break; }
106      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
107      if (DomainsIdH.IsKey(NIdV[1])) { IAssert(NIdV[0].GetInt()==DomainsIdH.GetDat(NIdV[1])); }
108      InferredNetwork.AddNode(NIdV[0].GetInt(), NIdV[1]);
109      if (!IsNodeNm(NIdV[0].GetInt())) { AddNodeNm(NIdV[0].GetInt(), TNodeInfo(NIdV[1], 0)); }
110      if (!DomainsIdH.IsKey(NIdV[1])) { DomainsIdH.AddDat(NIdV[1]) = NIdV[0].GetInt(); }
111    }
112    printf("Nodes:%d\n", InferredNetwork.GetNodes());
113  }
114  void TNIBs::AddCasc(const TStr& CascStr, const TModel& Model) {
115    int CId = CascH.Len();
116    TStrV FieldsV; CascStr.SplitOnAllCh(';', FieldsV);
117    if (FieldsV.Len()==2) { CId = FieldsV[0].GetInt(); }
118      TStrV NIdV; FieldsV[FieldsV.Len()-1].SplitOnAllCh(',', NIdV);
119      TCascade C(CId, Model);
120      for (int i = 0; i < NIdV.Len(); i+=2) {
121        int NId;
122        double Tm; 
123        NId = NIdV[i].GetInt();
124        Tm = NIdV[i+1].GetFlt();
125        GetNodeInfo(NId).Vol = GetNodeInfo(NId).Vol + 1;
126        C.Add(NId, Tm);
127      }
128      C.Sort();
129      AddCasc(C);
130  }
131  void TNIBs::AddCasc(const TIntFltH& Cascade, const int& CId, const TModel& Model) {
132    TCascade C(CId, Model);
133    for (TIntFltH::TIter NI = Cascade.BegI(); NI < Cascade.EndI(); NI++) {
134      GetNodeInfo(NI.GetKey()).Vol = GetNodeInfo(NI.GetKey()).Vol + 1;
135      C.Add(NI.GetKey(), NI.GetDat());
136    }
137    C.Sort();
138    AddCasc(C);
139  }
140  void TNIBs::GenCascade(TCascade& C) {
141    bool verbose = false;
142    TIntFltH InfectedNIdH; TIntH InfectedBy;
143    double GlobalTime, InitTime;
144    double alpha;
145    int StartNId;
146    if (Network.GetNodes() == 0)
147      return;
148          TInt::Rnd.Randomize();
149    while (C.Len() < 2) {
150      C.Clr();
151      InfectedNIdH.Clr();
152      InfectedBy.Clr();
153      InitTime = TFlt::Rnd.GetUniDev() * TotalTime; 
154      GlobalTime = InitTime;
155      StartNId = Network.GetRndNId();
156      InfectedNIdH.AddDat(StartNId) = GlobalTime;
157      while (true) {
158        InfectedNIdH.SortByDat(true);
159        const int& NId = InfectedNIdH.BegI().GetKey();
160        GlobalTime = InfectedNIdH.BegI().GetDat();
161        if ( GlobalTime >= TFlt::GetMn(TotalTime, InitTime+Window) )
162          break;
163        C.Add(NId, GlobalTime);
164        if (verbose) { printf("GlobalTime:%f, infected node:%d\n", GlobalTime, NId); }
165        TStrFltFltHNEDNet::TNodeI NI = Network.GetNI(NId);
166        for (int e = 0; e < NI.GetOutDeg(); e++) {
167          const int DstNId = NI.GetOutNId(e);
168          TFltFltH& Alphas = Network.GetEDat(NId, DstNId);
169          for (int j=0; j<Alphas.Len() && Alphas.GetKey(j)<GlobalTime; j++) { alpha = Alphas[j]; }
170          if (verbose) { printf("GlobalTime:%f, nodes:%d->%d, alpha:%f\n", GlobalTime, NId, DstNId, alpha); }
171          if (alpha<1e-9) { continue; }
172          if (InfectedBy.IsKey(NId) && InfectedBy.GetDat(NId).Val == DstNId)
173            continue;
174          double sigmaT;
175          switch (Model) {
176          case EXP:
177            sigmaT = TInt::Rnd.GetExpDev(alpha);
178            break;
179          case POW:
180            sigmaT = TInt::Rnd.GetPowerDev(1+alpha);
181            while (sigmaT < Delta) { sigmaT = Delta*TInt::Rnd.GetPowerDev(1+alpha); }
182            break;
183          case RAY:
184            sigmaT = TInt::Rnd.GetRayleigh(1/sqrt(alpha));
185            break;
186          default:
187            sigmaT = 1;
188            break;
189          }
190          IAssert(sigmaT >= 0);
191          double t1 = TFlt::GetMn(GlobalTime + sigmaT, TFlt::GetMn(InitTime+Window, TotalTime));
192          if (InfectedNIdH.IsKey(DstNId)) {
193            double t2 = InfectedNIdH.GetDat(DstNId);
194            if ( t2 > t1 && t2 < TFlt::GetMn(InitTime+Window, TotalTime)) {
195              InfectedNIdH.GetDat(DstNId) = t1;
196              InfectedBy.GetDat(DstNId) = NId;
197            }
198          } else {
199            InfectedNIdH.AddDat(DstNId) = t1;
200            InfectedBy.AddDat(DstNId) = NId;
201          }
202        }
203        InfectedNIdH.GetDat(NId) = TFlt::GetMn(InitTime+Window, TotalTime);
204      }
205      }
206    C.Sort();
207  }
208  void TNIBs::GetGroundTruthGraphAtT(const double& Step, PNGraph &GraphAtT) {
209    GraphAtT = TNGraph::New();
210    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) { GraphAtT->AddNode(NI.GetKey()); }
211    for (TStrFltFltHNEDNet::TEdgeI EI = Network.BegEI(); EI < Network.EndEI(); EI++) {
212      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
213      double Alpha = 0.0;
214      if (EI().IsKey(Step)) { Alpha = EI().GetDat(Step); }
215      if (Alpha > MinAlpha) {
216        GraphAtT->AddEdge(EI.GetSrcNId(), EI.GetDstNId());
217      }
218    }
219  }
220  void TNIBs::GetGroundTruthNetworkAtT(const double& Step, PStrFltNEDNet& NetworkAtT) {
221    NetworkAtT = TStrFltNEDNet::New();
222    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) { NetworkAtT->AddNode(NI.GetKey(), NI.GetDat().Name); }
223    for (TStrFltFltHNEDNet::TEdgeI EI = Network.BegEI(); EI < Network.EndEI(); EI++) {
224      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
225      double Alpha = 0.0;
226      if (EI().IsKey(Step)) { Alpha = EI().GetDat(Step); }
227      if (Alpha > MinAlpha) {
228        NetworkAtT->AddEdge(EI.GetSrcNId(), EI.GetDstNId(), Alpha);
229      }
230    }
231  }
232  void TNIBs::GetInferredGraphAtT(const double& Step, PNGraph &GraphAtT) {
233    GraphAtT = TNGraph::New();
234    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) { GraphAtT->AddNode(NI.GetKey()); }
235    for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
236      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
237      double inferredAlpha = 0.0;
238      if (EI().IsKey(Step)) { inferredAlpha = EI().GetDat(Step); }
239      if (inferredAlpha > MinAlpha) {
240        GraphAtT->AddEdge(EI.GetSrcNId(), EI.GetDstNId());
241      }
242    }
243  }
244  void TNIBs::GetInferredNetworkAtT(const double& Step, PStrFltNEDNet& NetworkAtT) {
245    NetworkAtT = TStrFltNEDNet::New();
246    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
247      NetworkAtT->AddNode(NI.GetKey(), NI.GetDat().Name);
248    }
249    for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
250      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
251      double inferredAlpha = 0.0;
252      if (EI().IsKey(Step)) { inferredAlpha = EI().GetDat(Step); }
253      if (inferredAlpha > MinAlpha) {
254        NetworkAtT->AddEdge(EI.GetSrcNId(), EI.GetDstNId(), inferredAlpha);
255      }
256    }
257  }
258  void TNIBs::Init(const TFltV& Steps) {
259    InferredNetwork.Clr();
260    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
261      InferredNetwork.AddNode(NI.GetKey(), NI.GetDat().Name);
262    }
263    PrecisionRecall.Clr();
264    Accuracy.Clr();
265    MAE.Clr();
266    TotalCascadesAlpha.Clr();
267    for (int i=0; i<Steps.Len()-1; i++) {
268      MAE.Add(TFltPr(Steps[i], 0.0));
269      MSE.Add(TFltPr(Steps[i], 0.0));
270      Accuracy.Add(TFltPr(Steps[i], 0.0));
271      PrecisionRecall.Add(TFltPr(0.0,0.0));
272    }
273  }
274  void TNIBs::Reset() {
275    for (int i=0; i<DiffAlphas.Len(); i++) {
276      DiffAlphas[i].Clr();
277    }
278      DiffAlphas.Clr();
279      AveDiffAlphas.Clr();
280      SampledCascadesH.Clr();
281      TotalCascadesAlpha.Clr();
282  }
283  void TNIBs::SG(const int& NId, const int& Iters, const TFltV& Steps, const TSampling& Sampling, const TStr& ParamSampling, const bool& PlotPerformance) {
284    bool verbose = false;
285    int currentCascade = -1;
286    TIntIntH SampledCascades;
287    TStrV ParamSamplingV; ParamSampling.SplitOnAllCh(';', ParamSamplingV);
288    Reset();
289    printf("Node %d\n", NId);
290    for (int t=1; t<Steps.Len(); t++) {
291      TIntFltH CascadesIdx;
292      int num_infections = 0;
293      for (int i=0; i<CascH.Len(); i++) {
294        if (CascH[i].LenBeforeT(Steps[t]) > 1 &&
295          ( (Sampling!=WIN_SAMPLING && Sampling!=WIN_EXP_SAMPLING) ||
296            (Sampling==WIN_SAMPLING && (Steps[t]-CascH[i].GetMinTm()) <= ParamSamplingV[0].GetFlt()) ||
297            (Sampling==WIN_EXP_SAMPLING && (Steps[t]-CascH[i].GetMinTm()) <= ParamSamplingV[0].GetFlt()) )) {
298          num_infections += CascH[i].LenBeforeT(Steps[t]);
299          CascadesIdx.AddDat(i) = CascH[i].GetMinTm();
300        }
301      }
302      if (CascadesIdx.Len()==0) {
303        printf("WARNING: No cascades recorded by %f!\n", Steps[t].Val);
304        if (PlotPerformance) { ComputePerformanceNId(NId, t, Steps); }
305        continue;
306      }
307      CascadesIdx.SortByDat(false);
308      printf("Solving step %f: %d cascades, %d infections\n", Steps[t].Val, CascadesIdx.Len(), num_infections);
309      SampledCascades.Clr();
310      for (int i=0; i < Iters; i++) {
311        switch (Sampling) {
312          case UNIF_SAMPLING:
313            currentCascade = TInt::Rnd.GetUniDevInt(CascadesIdx.Len());
314            break;
315          case WIN_SAMPLING:
316            currentCascade = TInt::Rnd.GetUniDevInt(CascadesIdx.Len());
317            break;
318          case EXP_SAMPLING:
319            do {
320              currentCascade = (int)TFlt::Rnd.GetExpDev(ParamSamplingV[0].GetFlt());
321            } while (currentCascade > CascadesIdx.Len()-1);
322            break;
323          case WIN_EXP_SAMPLING:
324            do {
325              currentCascade = (int)TFlt::Rnd.GetExpDev(ParamSamplingV[1].GetFlt());
326            } while (currentCascade > CascadesIdx.Len()-1);
327            break;
328          case RAY_SAMPLING:
329            do {
330              currentCascade = (int)TFlt::Rnd.GetRayleigh(ParamSamplingV[0].GetFlt());
331            } while (currentCascade > CascadesIdx.Len()-1);
332            break;
333        }
334        if (!SampledCascades.IsKey(currentCascade)) { SampledCascades.AddDat(currentCascade) = 0; }
335        SampledCascades.GetDat(currentCascade)++;
336        if (verbose) { printf("Cascade %d sampled!\n", currentCascade); }
337        TCascade &Cascade = CascH[CascadesIdx.GetKey(currentCascade)];
338        TIntPrV AlphasToUpdate;
339        UpdateDiff(OSG, NId, Cascade, AlphasToUpdate, Steps[t]);
340        for (int j=0; j<AlphasToUpdate.Len(); j++) {
341          if (InferredNetwork.IsEdge(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2) &&
342              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).IsKey(Steps[t])
343            ) {
344            InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) -=
345                (Gamma * AveDiffAlphas.GetDat(AlphasToUpdate[j].Val1)
346                    - (Regularizer==1? Mu*InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) : 0.0));
347            if (InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) < Tol) {
348              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) = Tol;
349            }
350            if (InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) > MaxAlpha) {
351              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) = MaxAlpha;
352            }
353          }
354        }
355        if (verbose) { printf("%d transmission rates updated!\n", AlphasToUpdate.Len()); }
356      }
357      printf("%d different cascades have been sampled for step %f!\n", SampledCascades.Len(), Steps[t].Val);
358      int unchanged = 0;
359      for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
360        if (EI().IsKey(Steps[t]) || t == 0 || !EI().IsKey(Steps[t-1])) { continue; }
361        EI().AddDat(Steps[t]) = Aging*EI().GetDat(Steps[t-1]);
362        unchanged++;
363      }
364      if (verbose) { printf("%d transmission rates that did not changed were 'aged' by %f!\n", unchanged, Aging.Val); }
365      if (PlotPerformance) { ComputePerformanceNId(NId, t, Steps); }
366    }
367  }
368  void TNIBs::BSG(const int& NId, const int& Iters, const TFltV& Steps, const int& BatchLen, const TSampling& Sampling, const TStr& ParamSampling, const bool& PlotPerformance) {
369    bool verbose = false;
370    int currentCascade = -1;
371    TIntIntH SampledCascades;
372    TStrV ParamSamplingV; ParamSampling.SplitOnAllCh(';', ParamSamplingV);
373    Reset();
374    printf("Node %d (|A|: %d)\n", NId, InferredNetwork.GetNodes());
375    for (int t=1; t<Steps.Len(); t++) {
376      TIntFltH CascadesIdx;
377      int num_infections = 0;
378      for (int i = 0; i < CascH.Len(); i++) {
379        if (CascH[i].LenBeforeT(Steps[t]) > 1 &&
380              ( (Sampling!=WIN_SAMPLING && Sampling!=WIN_EXP_SAMPLING) ||
381            (Sampling==WIN_SAMPLING && (Steps[t]-CascH[i].GetMinTm()) <= ParamSamplingV[0].GetFlt()) ||
382            (Sampling==WIN_EXP_SAMPLING && (Steps[t]-CascH[i].GetMinTm()) <= ParamSamplingV[0].GetFlt()) )) {
383          num_infections += CascH[i].LenBeforeT(Steps[t]);
384          CascadesIdx.AddDat(i) = CascH[i].GetMinTm();
385        }
386      }
387      if (CascadesIdx.Len() == 0) {
388        printf("WARNING: No cascades recorded by %f!\n", Steps[t].Val);
389        if (PlotPerformance) { ComputePerformanceNId(NId, t, Steps); }
390        continue;
391      }
392      printf("Solving step %f (%d cascades, %d infections)\n", Steps[t].Val,
393          CascadesIdx.Len(), num_infections);
394      CascadesIdx.SortByDat(false);
395      for (int i=0; i < Iters; i++) {
396        TIntPrV AlphasToUpdate;
397        AveDiffAlphas.Clr();
398        for (int c=0; c<BatchLen; c++) {
399          switch (Sampling) {
400            case UNIF_SAMPLING:
401              currentCascade = TInt::Rnd.GetUniDevInt(CascadesIdx.Len());
402              break;
403            case WIN_SAMPLING:
404              currentCascade = TInt::Rnd.GetUniDevInt(CascadesIdx.Len());
405              break;
406            case EXP_SAMPLING:
407              do {
408                currentCascade = (int)TFlt::Rnd.GetExpDev(ParamSamplingV[0].GetFlt());
409              } while (currentCascade > CascadesIdx.Len()-1);
410              break;
411            case WIN_EXP_SAMPLING:
412              do {
413                currentCascade = (int)TFlt::Rnd.GetExpDev(ParamSamplingV[1].GetFlt());
414              } while (currentCascade > CascadesIdx.Len()-1);
415              break;
416            case RAY_SAMPLING:
417              do {
418                currentCascade = (int)TFlt::Rnd.GetRayleigh(ParamSamplingV[0].GetFlt());
419              } while (currentCascade > CascadesIdx.Len()-1);
420              break;
421          }
422          TCascade &Cascade = CascH[CascadesIdx.GetKey(currentCascade)];
423          if (!SampledCascades.IsKey(currentCascade)) { SampledCascades.AddDat(currentCascade) = 0; }
424          SampledCascades.GetDat(currentCascade)++;
425          UpdateDiff(OBSG, NId, Cascade, AlphasToUpdate, Steps[t]);
426        }
427        for (int j=0; j<AlphasToUpdate.Len(); j++) {
428          if (InferredNetwork.IsEdge(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2) &&
429                InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).IsKey(Steps[t])) {
430            switch (Regularizer) {
431              case 0:
432                InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) -=
433                  Gamma * (1.0/(double)BatchLen) * AveDiffAlphas.GetDat(AlphasToUpdate[j].Val1);
434              case 1:
435                InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) =
436                  InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t])*(1.0-Mu*Gamma/(double)BatchLen)
437                  - Gamma * (1.0/(double)BatchLen) * AveDiffAlphas.GetDat(AlphasToUpdate[j].Val1);
438            }
439            if (InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) < Tol) {
440              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) = Tol;
441            }
442            if (InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) > MaxAlpha) {
443              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) = MaxAlpha;
444            }
445          }
446        }
447        int unchanged = 0;
448        for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
449          if (EI().IsKey(Steps[t]) || t == 0 || !EI().IsKey(Steps[t-1])) { continue; }
450          EI().AddDat(Steps[t]) = EI().GetDat(Steps[t-1]);
451          unchanged++;
452        }
453        if (verbose) { printf("%d unchanged transmission rates updated!\n", unchanged); }
454      }
455      printf("%d different cascades have been sampled for step %f!\n", SampledCascades.Len(), Steps[t].Val);
456      if (PlotPerformance) { ComputePerformanceNId(NId, t, Steps); }
457    }
458  }
459  void TNIBs::FG(const int& NId, const int& Iters, const TFltV& Steps) {
460    bool verbose = false;
461    Reset();
462    printf("Node %d (|A|: %d)\n", NId, InferredNetwork.GetNodes());
463    for (int t=1; t<Steps.Len(); t++) {
464      TIntFltH CascadesIdx;
465      int num_infections = 0;
466      for (int i=0; i<CascH.Len(); i++) {
467        if (CascH[i].LenBeforeT(Steps[t]) > 1) {
468          num_infections += CascH[i].LenBeforeT(Steps[t]);
469          CascadesIdx.AddDat(i) = CascH[i].GetMinTm();
470        }
471      }
472      if (CascadesIdx.Len()==0) {
473        printf("WARNING: No cascades recorded by %f!\n", Steps[t].Val);
474        continue;
475      }
476      printf("Solving step %f (%d cascades, %d infections)\n", Steps[t].Val, CascadesIdx.Len(), num_infections);
477      CascadesIdx.SortByDat(false);
478      for (int i=0; i < Iters; i++) {
479        TIntPrV AlphasToUpdate;
480        AveDiffAlphas.Clr();
481        for (int c=0; c<CascadesIdx.Len(); c++) {
482          TCascade &Cascade = CascH[CascadesIdx.GetKey(c)];
483          UpdateDiff(OBSG, NId, Cascade, AlphasToUpdate, Steps[t]);
484        }
485        for (int j=0; j<AlphasToUpdate.Len(); j++) {
486          if (InferredNetwork.IsEdge(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2) &&
487                InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).IsKey(Steps[t])) {
488            switch (Regularizer) {
489              case 0:
490                InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) -=
491                  Gamma * (1.0/(double)CascadesIdx.Len()) * AveDiffAlphas.GetDat(AlphasToUpdate[j].Val1);
492              case 1:
493                InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) =
494                  InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t])*(1.0-Mu*Gamma/(double)CascadesIdx.Len())
495                  - Gamma * (1.0/(double)CascadesIdx.Len()) * AveDiffAlphas.GetDat(AlphasToUpdate[j].Val1);
496            }
497            if (InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) < Tol) {
498              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) = Tol;
499            }
500            if (InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) > MaxAlpha) {
501              InferredNetwork.GetEDat(AlphasToUpdate[j].Val1, AlphasToUpdate[j].Val2).GetDat(Steps[t]) = MaxAlpha;
502            }
503          }
504        }
505        int unchanged = 0;
506        for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
507          if (EI().IsKey(Steps[t]) || t == 0 || !EI().IsKey(Steps[t-1])) { continue; }
508          EI().AddDat(Steps[t]) = EI().GetDat(Steps[t-1]);
509          unchanged++;
510        }
511        if (verbose) { printf("%d unchanged transmission rates updated!\n", unchanged); }
512      }
513      ComputePerformanceNId(NId, t, Steps);
514    }
515  }
516  void TNIBs::UpdateDiff(const TOptMethod& OptMethod, const int& NId, TCascade& Cascade, TIntPrV& AlphasToUpdate, const double& CurrentTime) {
517    IAssert(InferredNetwork.IsNode(NId));
518    double sum = 0.0;
519    if (Cascade.IsNode(NId) && Cascade.GetTm(NId) <= CurrentTime) {
520      for (THash<TInt, THitInfo>::TIter NI = Cascade.BegI(); NI < Cascade.EndI(); NI++) {
521        if ( (Cascade.GetTm(NId)<=NI.GetDat().Tm) ||
522             (Cascade.GetTm(NId)-Delta<=NI.GetDat().Tm && Model==POW)
523           ) { break; }
524        TIntPr Pair(NI.GetKey(), NId);
525        if (!InferredNetwork.IsEdge(Pair.Val1, Pair.Val2)) { InferredNetwork.AddEdge(Pair.Val1, Pair.Val2, TFltFltH()); }
526        if (!InferredNetwork.GetEDat(Pair.Val1, Pair.Val2).IsKey(CurrentTime)) {
527          InferredNetwork.GetEDat(Pair.Val1, Pair.Val2).AddDat(CurrentTime) = InitAlpha;
528        }
529        switch(Model) {
530          case EXP: 
531            sum += InferredNetwork.GetEDat(Pair.Val1, Pair.Val2).GetDat(CurrentTime).Val;
532            break;
533          case POW: 
534            sum += InferredNetwork.GetEDat(Pair.Val1, Pair.Val2).GetDat(CurrentTime).Val/(Cascade.GetTm(NId)-NI.GetDat().Tm);
535            break;
536          case RAY: 
537            sum += InferredNetwork.GetEDat(Pair.Val1, Pair.Val2).GetDat(CurrentTime).Val*(Cascade.GetTm(NId)-NI.GetDat().Tm);
538            break;
539          default:
540            sum = 0.0;
541        }
542      }
543    }
544    for (THash<TInt, THitInfo>::TIter NI = Cascade.BegI(); NI < Cascade.EndI(); NI++) {
545      if ( Cascade.IsNode(NId) && (Cascade.GetTm(NId)<=NI.GetDat().Tm ||
546          (Cascade.GetTm(NId)-Delta<=NI.GetDat().Tm && Model==POW))
547         ) { break; }
548      if (NI.GetDat().Tm > CurrentTime) { break; }
549      TIntPr Pair(NI.GetKey(), NId); 
550      double val = 0.0;
551      if (Cascade.IsNode(NId) && Cascade.GetTm(NId) <= CurrentTime) {
552        IAssert((Cascade.GetTm(NId) - NI.GetDat().Tm) > 0.0);
553        switch(Model) { 
554          case EXP: 
555            val = (Cascade.GetTm(NId) - NI.GetDat().Tm) - 1.0/sum;
556            break;
557          case POW: 
558            val = log((Cascade.GetTm(NId) - NI.GetDat().Tm)/Delta) - 1.0/((Cascade.GetTm(NId)-NI.GetDat().Tm)*sum);
559            break;
560          case RAY: 
561            val = TMath::Power(Cascade.GetTm(NId)-NI.GetDat().Tm, 2.0)/2.0 - (Cascade.GetTm(NId)-NI.GetDat().Tm)/sum;
562            break;
563          default:
564            val = 0.0;
565        }
566      } else { 
567        IAssert((CurrentTime - NI.GetDat().Tm) >= 0.0);
568        switch(Model) {
569          case EXP: 
570            val = (CurrentTime-NI.GetDat().Tm);
571            if ( (Window > -1) && (CurrentTime-Cascade.GetMinTm() > Window) ) { val = (Cascade.GetMinTm()+Window-NI.GetDat().Tm); }
572            break;
573          case POW: 
574            val = TMath::Mx(log((CurrentTime-NI.GetDat().Tm)/Delta), 0.0);
575            if ( (Window > -1) && (CurrentTime-Cascade.GetMinTm() > Window) ) { val = TMath::Mx(log((Cascade.GetMinTm()+Window-NI.GetDat().Tm)/Delta), 0.0); }
576            break;
577          case RAY: 
578            val = TMath::Power(CurrentTime-NI.GetDat().Tm,2.0)/2.0;
579            if ( (Window > -1) && (CurrentTime-Cascade.GetMinTm() > Window) ) { val = TMath::Power(Cascade.GetMinTm()+Window-NI.GetDat().Tm,2.0)/2.0; }
580            break;
581          default:
582            val = 0.0;
583        }
584      }
585      if (!AveDiffAlphas.IsKey(Pair.Val1)) { AveDiffAlphas.AddDat(Pair.Val1) = 0.0; }
586      switch (OptMethod) {
587        case OBSG:
588        case OEBSG:
589        case OFG:
590          AveDiffAlphas.GetDat(Pair.Val1) += val;
591          break;
592        case OSG:
593        case OESG:
594          AveDiffAlphas.GetDat(Pair.Val1) = val;
595        default:
596          break;
597      }
598      AlphasToUpdate.Add(Pair);
599    }
600    return;
601  }
602  void TNIBs::find_C( int t, TFltV &x, TFltVV &C, const int& k, const double& s, const double& gamma, const double& T ){
603    if ( t >= x.Len() ) return;
604    if ( t == 0 ){
605      C = TFltVV( x.Len(), k );
606    }else{
607      int n = x.Len() - 1;
608      for (int j = 0; j < k; j++){
609        double alpha = ( (x.Len() ) / T ) * pow( s, j );
610        double term_1 = -log(alpha) + alpha * x[t];
611        double term_2 = 0;
612        if ( t == 1 ){
613          term_2 = j * log((double) n) * gamma;
614        }
615        else{
616          bool first = false;
617          for (int l = 0; l < k; l++){
618            double my_val = C(t-1, l);
619            if ( j > l ) my_val += (j - l) * log((double) n) * gamma;
620            if ( !first || my_val < term_2 ){
621              term_2 = my_val;
622              first = true;
623            }
624          }
625        }
626        C( t, j ) = term_1 + term_2;
627      }
628    }
629    find_C( t + 1, x, C, k, s, gamma, T );
630  }
631  void TNIBs::find_min_state( TFltVV &C, TIntV &states, const int& k, const double& s, const double& gamma, const double& T ){
632    states = TIntV( C.GetRows() );
633    states[0] = 0;
634    int n = C.GetRows() - 1;
635    for (int t = C.GetRows() - 1; t > 0; t --){
636      double best_val = 0;
637      int best_state = -1;
638      for (int j = 0; j < C.GetCols(); j++){
639        double c_state = C( t, j );
640        if ( t < C.GetRows() - 2 && states[t+1] > j ){
641          c_state += ( states[t+1] - j ) * gamma * log((double) n);
642        }
643        if ( best_state == -1 || best_val > c_state ){
644          best_state = j;
645          best_val = c_state;
646        }
647      }
648      states[t] = best_state;
649    }
650  }
<span onclick='openModal()' class='match'>651  void TNIBs::LabelBurstAutomaton( const int& SrcId, const int& DstId, TIntV &state_labels, TFltV &state_times, const bool& inferred, const int& k, const double& s, const double& gamma, const TSecTm& MinTime, const TSecTm& MaxTime ){
652    TVec<TSecTm> arrival_times;
</span>653    TFltFltH &LinksEdge = (inferred? InferredNetwork.GetEDat(SrcId, DstId) : Network.GetEDat(SrcId, DstId));
654    for (int i=0; i<LinksEdge.Len(); i++) {
655      if (LinksEdge[i]>MinAlpha) {
656        TSecTm tsecs;
657        tsecs = (uint)LinksEdge.GetKey(i); 
658        if (tsecs > MaxTime || tsecs < MinTime) { continue; }
659        arrival_times.Add(tsecs);
660      }
661    }
662    if ( arrival_times.Len() < 2 ) return;
663    TFltV x;
664    x.Add( 0 );
665    arrival_times.Sort(true);
666    double T = ((double)arrival_times.Last().GetAbsSecs()) - ((double)arrival_times[0].GetAbsSecs());
667    for (int i = 1; i < arrival_times.Len(); i++){
668      x.Add( ((double)arrival_times[i].GetAbsSecs()) - ((double)arrival_times[i-1].GetAbsSecs()) );
669    }
670    TFltVV Cost_matrix;
671    find_C( 0, x, Cost_matrix, k, s, gamma, T);
672    find_min_state( Cost_matrix, state_labels, k, s, gamma, T );
673    for (int i=0; i<state_labels.Len(); i++) { state_times.Add((double)arrival_times[i].GetAbsSecs()); }
674  }
675  void TNIBs::ComputePerformanceNId(const int& NId, const int& t, const TFltV& Steps) {
676    double CurrentMAE = 0.0;
677    double CurrentMSE = 0.0;
678    TFltPr CurrentPrecisionRecall(0.0, 0.0);
679    double CurrentAccD = 0.0;
680    TStrFltFltHNEDNet::TNodeI NI = InferredNetwork.GetNI(NId);
681    for (int i=0; i<NI.GetInDeg(); i++) {
682      double inferredAlpha = InferredNetwork.GetEDat(NI.GetInNId(i), NId).GetDat(Steps[t]);
683      double trueAlpha = 0.0;
684      if (Network.IsEdge(NI.GetInNId(i), NId) && Network.GetEDat(NI.GetInNId(i), NId).IsKey(Steps[t-1])) { trueAlpha = Network.GetEDat(NI.GetInNId(i), NId).GetDat(Steps[t-1]); }
685      CurrentAccD += (double) (inferredAlpha > MinAlpha);
686      CurrentPrecisionRecall.Val2 += (double) (inferredAlpha > MinAlpha && trueAlpha<MinAlpha);
687    }
688    NI = Network.GetNI(NId);
689    int NumEdges = 0;
690    for (int i=0; i<NI.GetInDeg(); i++) {
691      TIntPr Pair(NI.GetInNId(i), NId);
692      double inferredAlpha = 0.0;
693      if (InferredNetwork.IsEdge(NI.GetInNId(i), NId) && InferredNetwork.GetEDat(NI.GetInNId(i), NId).IsKey(Steps[t])) {
694        inferredAlpha = InferredNetwork.GetEDat(NI.GetInNId(i), NId).GetDat(Steps[t]).Val;
695      }
696      double trueAlpha = 0.0;
697      if (Network.GetEDat(NI.GetInNId(i), NId).IsKey(Steps[t-1])) { trueAlpha = Network.GetEDat(NI.GetInNId(i), NId).GetDat(Steps[t-1]); }
698      if (trueAlpha > MinAlpha) {
699        NumEdges++;
700        CurrentMAE += fabs(trueAlpha - TFlt::GetMn(inferredAlpha, MaxAlpha))/trueAlpha;
701      }
702      CurrentMSE += pow(trueAlpha - TFlt::GetMn(inferredAlpha, MaxAlpha), 2.0);
703      CurrentPrecisionRecall.Val1 += (double) (inferredAlpha > MinAlpha && trueAlpha > MinAlpha);
704    }
705    if (NumEdges > 0) {
706      MAE[t-1].Val2 += CurrentMAE / ((double)(NumEdges*Network.GetNodes()));
707      MSE[t-1].Val2 += CurrentMSE / ((double)(NumEdges*Network.GetNodes()));
708      PrecisionRecall[t-1].Val1 += CurrentPrecisionRecall.Val1/(double)(NumEdges*Network.GetNodes());
709    }
710    if (CurrentAccD > 0) {
711      PrecisionRecall[t-1].Val2 += (1.0 - CurrentPrecisionRecall.Val2 / CurrentAccD)/(double)Network.GetNodes();
712    } else {
713      PrecisionRecall[t-1].Val2 += 1.0/(double)Network.GetNodes();
714    }
715    Accuracy[t-1].Val2 = 1.0 - (1.0-PrecisionRecall[t-1].Val2)/(PrecisionRecall[t-1].Val2 * (1.0/PrecisionRecall[t-1].Val2 + 1.0/PrecisionRecall[t-1].Val1)) - (1.0-PrecisionRecall[t-1].Val1)/(PrecisionRecall[t-1].Val1* (1.0/PrecisionRecall[t-1].Val2 + 1.0/PrecisionRecall[t-1].Val1));
716  }
717  void TNIBs::SaveInferredPajek(const TStr& OutFNm, const double& Step, const TIntV& NIdV) {
718      TFOut FOut(OutFNm);
719      FOut.PutStr(TStr::Fmt("*Vertices %d\r\n", NodeNmH.Len()));
720      for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
721        if (NIdV.Len() > 0 && !NIdV.IsIn(NI.GetKey())) { continue; }
722        FOut.PutStr(TStr::Fmt("%d \"%s\" ic Blue\r\n", NI.GetKey().Val+1, NI.GetDat().Name.CStr()));
723      }
724      FOut.PutStr("*Arcs\r\n");
725      for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
726        if (NIdV.Len() > 0 && (!NIdV.IsIn(EI.GetSrcNId()) || !NIdV.IsIn(EI.GetDstNId()))) { continue; }
727        if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
728        double inferredAlpha = 0.0;
729        if (EI().IsKey(Step)) { inferredAlpha = EI().GetDat(Step); }
730        if (inferredAlpha > MinAlpha) {
731          FOut.PutStr(TStr::Fmt("%d %d %f\r\n", EI.GetSrcNId()+1, EI.GetDstNId()+1, (inferredAlpha > MaxAlpha? MaxAlpha.Val : inferredAlpha)));
732        }
733      }
734  }
735  void TNIBs::SaveInferred(const TStr& OutFNm, const TIntV& NIdV) {
736    TFOut FOut(OutFNm);
737    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
738      if (NIdV.Len() > 0 && !NIdV.IsIn(NI.GetKey())) { continue; }
739      FOut.PutStr(TStr::Fmt("%d,%s\r\n", NI.GetKey().Val, NI.GetDat().Name.CStr()));
740    }
741    FOut.PutStr("\r\n");
742    for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
743      if (NIdV.Len() > 0 && (!NIdV.IsIn(EI.GetSrcNId()) || !NIdV.IsIn(EI.GetDstNId()))) { continue; }
744      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
745      if (EI.GetSrcNId() != EI.GetDstNId()) {
746        if (EI().Len() > 0) {
747          TStr Line; bool IsEdge = false;
748          for (int i=0; i<EI().Len(); i++) {
749            if (EI()[i]>MinAlpha) {
750              Line += TStr::Fmt(",%f,%f", EI().GetKey(i).Val, (EI()[i] > MaxAlpha? MaxAlpha.Val : EI()[i].Val) );
751              IsEdge = true;
752            } else { 
753              Line += TStr::Fmt(",%f,0.0", EI().GetKey(i).Val);
754            }
755          }
756          if (IsEdge) {
757            FOut.PutStr(TStr::Fmt("%d,%d", EI.GetSrcNId(), EI.GetDstNId()));
758            FOut.PutStr(Line);
759            FOut.PutStr("\r\n");
760          }
761        }
762        else
763          FOut.PutStr(TStr::Fmt("%d,%d,1\r\n", EI.GetSrcNId(), EI.GetDstNId()));
764      }
765    }
766  }
767  void TNIBs::SaveInferred(const TStr& OutFNm, const double& Step, const TIntV& NIdV) {
768    TFOut FOut(OutFNm);
769    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
770      if (NIdV.Len() > 0 && !NIdV.IsIn(NI.GetKey())) { continue; }
771      FOut.PutStr(TStr::Fmt("%d,%s\r\n", NI.GetKey().Val, NI.GetDat().Name.CStr()));
772    }
773    FOut.PutStr("\r\n");
774    for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
775      if (NIdV.Len() > 0 && (!NIdV.IsIn(EI.GetSrcNId()) || !NIdV.IsIn(EI.GetDstNId()))) { continue; }
776      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
777      if (EI.GetSrcNId() != EI.GetDstNId()) {
778        double inferredAlpha = 0.0;
779        if (EI().IsKey(Step)) { inferredAlpha = EI().GetDat(Step); }
780        if (inferredAlpha > MinAlpha) {
781          FOut.PutStr(TStr::Fmt("%d,%d,%f\r\n", EI.GetSrcNId(), EI.GetDstNId(), (inferredAlpha > MaxAlpha? MaxAlpha.Val : inferredAlpha)));
782        }
783      }
784    }
785  }
786  void TNIBs::SaveInferredEdges(const TStr& OutFNm) {
787    TFOut FOut(OutFNm);
788    for (TStrFltFltHNEDNet::TEdgeI EI = InferredNetwork.BegEI(); EI < InferredNetwork.EndEI(); EI++) {
789      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
790      if (EI.GetSrcNId() != EI.GetDstNId()) {
791        if (EI().Len() > 0) {
792          TStr Line; bool IsEdge = false;
793          for (int i=0; i<EI().Len(); i++) {
794            if (EI()[i]>MinAlpha) {
795              Line += TStr::Fmt(",%f,%f", EI().GetKey(i).Val, (EI()[i] > MaxAlpha? MaxAlpha.Val : EI()[i].Val) );
796              IsEdge = true;
797            } else { 
798              Line += TStr::Fmt(",%f,0.0", EI().GetKey(i).Val);
799            }
800          }
801          if (IsEdge) {
802            FOut.PutStr(TStr::Fmt("%d,%d", EI.GetSrcNId(), EI.GetDstNId()));
803            FOut.PutStr(Line);
804            FOut.PutStr("\r\n");
805          }
806        }
807        else
808          FOut.PutStr(TStr::Fmt("%d,%d,1\r\n", EI.GetSrcNId(), EI.GetDstNId()));
809      }
810    }
811  }
812  void TNIBs::SaveGroundTruth(const TStr& OutFNm) {
813    TFOut FOut(OutFNm);
814    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
815      FOut.PutStr(TStr::Fmt("%d,%s\r\n", NI.GetKey().Val, NI.GetDat().Name.CStr()));
816    }
817    FOut.PutStr("\r\n");
818    for (TStrFltFltHNEDNet::TEdgeI EI = Network.BegEI(); EI < Network.EndEI(); EI++) {
819      if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
820      if (EI.GetSrcNId() != EI.GetDstNId()) {
821        if (EI().Len() > 0) {
822          FOut.PutStr(TStr::Fmt("%d,%d,", EI.GetSrcNId(), EI.GetDstNId()));
823          for (int i=0; i<EI().Len()-1; i++) { FOut.PutStr(TStr::Fmt("%f,%f,", EI().GetKey(i).Val, EI()[i].Val)); }
824          FOut.PutStr(TStr::Fmt("%f,%f", EI().GetKey(EI().Len()-1).Val, EI()[EI().Len()-1].Val));
825          FOut.PutStr("\r\n");
826        }
827        else
828          FOut.PutStr(TStr::Fmt("%d,%d,1\r\n", EI.GetSrcNId(), EI.GetDstNId()));
829      }
830    }
831  }
832  void TNIBs::SaveGroundTruthPajek(const TStr& OutFNm, const double& Step) {
833      TFOut FOut(OutFNm);
834      FOut.PutStr(TStr::Fmt("*Vertices %d\r\n", NodeNmH.Len()));
835      for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
836        FOut.PutStr(TStr::Fmt("%d \"%s\" ic Blue\r\n", NI.GetKey().Val+1, NI.GetDat().Name.CStr()));
837      }
838      FOut.PutStr("*Arcs\r\n");
839      for (TStrFltFltHNEDNet::TEdgeI EI = Network.BegEI(); EI < Network.EndEI(); EI++) {
840        if (!NodeNmH.IsKey(EI.GetSrcNId()) || !NodeNmH.IsKey(EI.GetDstNId())) { continue; }
841        double trueAlpha = 0.0;
842        if (EI().IsKey(Step)) { trueAlpha = EI().GetDat(Step); }
843        else { for (int j=0; j<EI().Len() && EI().GetKey(j)<=Step; j++) { trueAlpha = EI()[j]; } }
844        if (trueAlpha > MinAlpha) {
845          FOut.PutStr(TStr::Fmt("%d %d %f\r\n", EI.GetSrcNId()+1, EI.GetDstNId()+1, (trueAlpha > MaxAlpha? MaxAlpha.Val : trueAlpha)));
846        }
847      }
848  }
849  void TNIBs::SaveSites(const TStr& OutFNm, const TIntFltVH& CascadesPerNode) {
850    TFOut FOut(OutFNm);
851    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
852      FOut.PutStr(TStr::Fmt("%d,%s", NI.GetKey().Val, NI.GetDat().Name.CStr()));
853      if (CascadesPerNode.IsKey(NI.GetKey().Val)) {
854        for (int i=0; i<CascadesPerNode.GetDat(NI.GetKey().Val).Len(); i++) {
855          FOut.PutStr(TStr::Fmt(",%f", CascadesPerNode.GetDat(NI.GetKey().Val)[i].Val));
856        }
857      }
858      FOut.PutStr("\r\n");
859    }
860  }
861  void TNIBs::SaveCascades(const TStr& OutFNm) {
862    TFOut FOut(OutFNm);
863    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
864      FOut.PutStr(TStr::Fmt("%d,%s\r\n", NI.GetKey().Val, NI.GetDat().Name.CStr()));
865    }
866    FOut.PutStr("\r\n");
867    for (THash<TInt, TCascade>::TIter CI = CascH.BegI(); CI < CascH.EndI(); CI++) {
868      TCascade &C = CI.GetDat();
869      int j = 0;
870      for (THash<TInt, THitInfo>::TIter NI = C.NIdHitH.BegI(); NI < C.NIdHitH.EndI(); NI++) {
871        if (!NodeNmH.IsKey(NI.GetDat().NId)) { continue; }
872        if (j > 0) { FOut.PutStr(TStr::Fmt(",%d,%f", NI.GetDat().NId.Val, NI.GetDat().Tm.Val)); }
873        else { FOut.PutStr(TStr::Fmt("%d;%d,%f", CI.GetKey().Val, NI.GetDat().NId.Val, NI.GetDat().Tm.Val)); }
874        j++;
875      }
876      if (j >= 1)
877        FOut.PutStr(TStr::Fmt("\r\n"));
878    }
879  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-benchmark.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascdynetinf.cpp</div>
                </div>
                <div class="column column_space"><pre><code>22    void Init();
23    bool initted_;
24    bool running_;
25    bool has_run_at_least_once_;
26  #ifndef CPU_ONLY
27    cudaEvent_t start_gpu_;
28    cudaEvent_t stop_gpu_;
29  #endif
30    boost::posix_time::ptime init_cpu_;
31    boost::posix_time::ptime start_cpu_;
32    boost::posix_time::ptime stop_cpu_;
33    float elapsed_milliseconds_;
34    float elapsed_microseconds_;
</pre></code></div>
                <div class="column column_space"><pre><code>651  void TNIBs::LabelBurstAutomaton( const int& SrcId, const int& DstId, TIntV &state_labels, TFltV &state_times, const bool& inferred, const int& k, const double& s, const double& gamma, const TSecTm& MinTime, const TSecTm& MaxTime ){
652    TVec<TSecTm> arrival_times;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    