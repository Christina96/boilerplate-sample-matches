
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.336050389032975%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lrn_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_LRN_LAYER_HPP_
2  #define CAFFE_LRN_LAYER_HPP_
3  #include <vector>
4  #include "caffe/blob.hpp"
5  #include "caffe/layer.hpp"
6  #include "caffe/proto/caffe.pb.h"
7  #include "caffe/layers/eltwise_layer.hpp"
8  #include "caffe/layers/pooling_layer.hpp"
9  #include "caffe/layers/power_layer.hpp"
10  #include "caffe/layers/split_layer.hpp"
11  namespace caffe {
12  template <typename Dtype>
13  class LRNLayer : public Layer<Dtype> {
14   public:
15    explicit LRNLayer(const LayerParameter& param)
16        : Layer<Dtype>(param) {}
17    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
18        const vector<Blob<Dtype>*>& top);
19    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
20        const vector<Blob<Dtype>*>& top);
21    virtual inline const char* type() const { return "LRN"; }
22    virtual inline int ExactNumBottomBlobs() const { return 1; }
23    virtual inline int ExactNumTopBlobs() const { return 1; }
24   protected:
25    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
26        const vector<Blob<Dtype>*>& top);
27    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
28        const vector<Blob<Dtype>*>& top);
29    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
30        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
31    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
<span onclick='openModal()' class='match'>32        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
33    virtual void CrossChannelForward_cpu(const vector<Blob<Dtype>*>& bottom,
34        const vector<Blob<Dtype>*>& top);
</span>35    virtual void CrossChannelForward_gpu(const vector<Blob<Dtype>*>& bottom,
36        const vector<Blob<Dtype>*>& top);
37    virtual void WithinChannelForward(const vector<Blob<Dtype>*>& bottom,
38        const vector<Blob<Dtype>*>& top);
39    virtual void CrossChannelBackward_cpu(const vector<Blob<Dtype>*>& top,
40        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
41    virtual void CrossChannelBackward_gpu(const vector<Blob<Dtype>*>& top,
42        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
43    virtual void WithinChannelBackward(const vector<Blob<Dtype>*>& top,
44        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
45    int size_;
46    int pre_pad_;
47    Dtype alpha_;
48    Dtype beta_;
49    Dtype k_;
50    int num_;
51    int channels_;
52    int height_;
53    int width_;
54    Blob<Dtype> scale_;
55    Blob<Dtype> padded_ratio_;   
56    Blob<Dtype> accum_ratio_;    
57    int num_of_threads_;              
58    shared_ptr<SplitLayer<Dtype> > split_layer_;
59    vector<Blob<Dtype>*> split_top_vec_;
60    shared_ptr<PowerLayer<Dtype> > square_layer_;
61    Blob<Dtype> square_input_;
62    Blob<Dtype> square_output_;
63    vector<Blob<Dtype>*> square_bottom_vec_;
64    vector<Blob<Dtype>*> square_top_vec_;
65    shared_ptr<PoolingLayer<Dtype> > pool_layer_;
66    Blob<Dtype> pool_output_;
67    vector<Blob<Dtype>*> pool_top_vec_;
68    shared_ptr<PowerLayer<Dtype> > power_layer_;
69    Blob<Dtype> power_output_;
70    vector<Blob<Dtype>*> power_top_vec_;
71    shared_ptr<EltwiseLayer<Dtype> > product_layer_;
72    Blob<Dtype> product_input_;
73    vector<Blob<Dtype>*> product_bottom_vec_;
74  };
75  }  
76  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-subexport.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <iostream>
3  #include <numeric>
4  #include <cmath>
5  #include <climits>
6  #include "../../config/regmatch.h"
7  #include "../../generator/config/subexport.h"
8  #include "../../generator/template/templates.h"
9  #include "../../handler/settings.h"
10  #include "../../parser/config/proxy.h"
11  #include "../../script/script_quickjs.h"
12  #include "../../utils/bitwise.h"
13  #include "../../utils/file_extra.h"
14  #include "../../utils/ini_reader/ini_reader.h"
15  #include "../../utils/logger.h"
16  #include "../../utils/network.h"
17  #include "../../utils/rapidjson_extra.h"
18  #include "../../utils/regexp.h"
19  #include "../../utils/stl_extra.h"
20  #include "../../utils/urlencode.h"
21  #include "../../utils/yamlcpp_extra.h"
22  #include "nodemanip.h"
23  #include "ruleconvert.h"
24  extern string_array ss_ciphers, ssr_ciphers;
25  const string_array clashr_protocols = {"origin", "auth_sha1_v4", "auth_aes128_md5", "auth_aes128_sha1", "auth_chain_a", "auth_chain_b"};
26  const string_array clashr_obfs = {"plain", "http_simple", "http_post", "random_head", "tls1.2_ticket_auth", "tls1.2_ticket_fastauth"};
27  const string_array clash_ssr_ciphers = {"rc4-md5", "aes-128-ctr", "aes-192-ctr", "aes-256-ctr", "aes-128-cfb", "aes-192-cfb", "aes-256-cfb", "chacha20-ietf", "xchacha20", "none"};
<span onclick='openModal()' class='match'>28  std::string vmessLinkConstruct(const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &path, const std::string &host, const std::string &tls)
29  {
30      rapidjson::StringBuffer sb;
</span>31      rapidjson::Writer<rapidjson::StringBuffer> writer(sb);
32      writer.StartObject();
33      writer.Key("v");
34      writer.String("2");
35      writer.Key("ps");
36      writer.String(remarks.data());
37      writer.Key("add");
38      writer.String(add.data());
39      writer.Key("port");
40      writer.String(port.data());
41      writer.Key("type");
42      writer.String(type.empty() ? "none" : type.data());
43      writer.Key("id");
44      writer.String(id.data());
45      writer.Key("aid");
46      writer.String(aid.data());
47      writer.Key("net");
48      writer.String(net.empty() ? "tcp" : net.data());
49      writer.Key("path");
50      writer.String(path.data());
51      writer.Key("host");
52      writer.String(host.data());
53      writer.Key("tls");
54      writer.String(tls.data());
55      writer.EndObject();
56      return sb.GetString();
57  }
58  bool matchRange(const std::string &range, int target)
59  {
60      string_array vArray = split(range, ",");
61      bool match = false;
62      std::string range_begin_str, range_end_str;
63      int range_begin, range_end;
64      static const std::string reg_num = "-?\\d+", reg_range = "(\\d+)-(\\d+)", reg_not = "\\!-?(\\d+)", reg_not_range = "\\!(\\d+)-(\\d+)", reg_less = "(\\d+)-", reg_more = "(\\d+)\\+";
65      for(std::string &x : vArray)
66      {
67          if(regMatch(x, reg_num))
68          {
69              if(to_int(x, INT_MAX) == target)
70                  match = true;
71          }
72          else if(regMatch(x, reg_range))
73          {
74              regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);
75              range_begin = to_int(range_begin_str, INT_MAX);
76              range_end = to_int(range_end_str, INT_MIN);
77              if(target >= range_begin && target <= range_end)
78                  match = true;
79          }
80          else if(regMatch(x, reg_not))
81          {
82              match = true;
83              if(to_int(regReplace(x, reg_not, "$1"), INT_MAX) == target)
84                  match = false;
85          }
86          else if(regMatch(x, reg_not_range))
87          {
88              match = true;
89              regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);
90              range_begin = to_int(range_begin_str, INT_MAX);
91              range_end = to_int(range_end_str, INT_MIN);
92              if(target >= range_begin && target <= range_end)
93                  match = false;
94          }
95          else if(regMatch(x, reg_less))
96          {
97              if(to_int(regReplace(x, reg_less, "$1"), INT_MAX) >= target)
98                  match = true;
99          }
100          else if(regMatch(x, reg_more))
101          {
102              if(to_int(regReplace(x, reg_more, "$1"), INT_MIN) <= target)
103                  match = true;
104          }
105      }
106      return match;
107  }
108  bool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node)
109  {
110      std::string target, ret_real_rule;
111      static const std::string groupid_regex = R"(^!!(?:GROUPID|INSERT)=([\d\-+!,]+)(?:!!(.*))?$)", group_regex = R"(^!!(?:GROUP)=(.+?)(?:!!(.*))?$)";
112      static const std::string type_regex = R"(^!!(?:TYPE)=(.+?)(?:!!(.*))?$)", port_regex = R"(^!!(?:PORT)=(.+?)(?:!!(.*))?$)", server_regex = R"(^!!(?:SERVER)=(.+?)(?:!!(.*))?$)";
113      static const string_array types = {"", "SS", "SSR", "VMESS", "TROJAN", "SNELL", "HTTP", "HTTPS", "SOCKS5"};
114      if(startsWith(rule, "!!GROUP="))
115      {
116          regGetMatch(rule, group_regex, 3, 0, &target, &ret_real_rule);
117          real_rule = ret_real_rule;
118          return regFind(node.Group, target);
119      }
120      else if(startsWith(rule, "!!GROUPID=") || startsWith(rule, "!!INSERT="))
121      {
122          int dir = startsWith(rule, "!!INSERT=") ? -1 : 1;
123          regGetMatch(rule, groupid_regex, 3, 0, &target, &ret_real_rule);
124          real_rule = ret_real_rule;
125          return matchRange(target, dir * node.GroupId);
126      }
127      else if(startsWith(rule, "!!TYPE="))
128      {
129          regGetMatch(rule, type_regex, 3, 0, &target, &ret_real_rule);
130          real_rule = ret_real_rule;
131          if(node.Type == ProxyType::Unknow)
132              return false;
133          return regMatch(types[node.Type], target);
134      }
135      else if(startsWith(rule, "!!PORT="))
136      {
137          regGetMatch(rule, port_regex, 3, 0, &target, &ret_real_rule);
138          real_rule = ret_real_rule;
139          return matchRange(target, node.Port);
140      }
141      else if(startsWith(rule, "!!SERVER="))
142      {
143          regGetMatch(rule, server_regex, 3, 0, &target, &ret_real_rule);
144          real_rule = ret_real_rule;
145          return regFind(node.Hostname, target);
146      }
147      else
148          real_rule = rule;
149      return true;
150  }
151  void processRemark(std::string &oldremark, std::string &newremark, string_array &remarks_list, bool proc_comma = true)
152  {
153      if(proc_comma)
154      {
155          if(oldremark.find(',') != oldremark.npos)
156          {
157              oldremark.insert(0, "\"");
158              oldremark.append("\"");
159          }
160      }
161      newremark = oldremark;
162      int cnt = 2;
163      while(std::find(remarks_list.begin(), remarks_list.end(), newremark) != remarks_list.end())
164      {
165          newremark = oldremark + " " + std::to_string(cnt);
166          cnt++;
167      }
168      oldremark = newremark;
169  }
170  void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)
171  {
172      std::string real_rule;
173      if(startsWith(rule, "[]") && add_direct)
174      {
175          filtered_nodelist.emplace_back(rule.substr(2));
176      }
177  #ifndef NO_JS_RUNTIME
178      else if(startsWith(rule, "script:") && ext.authorized)
179      {
180          script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){
181              std::string script = fileGet(rule.substr(7), true);
182              try
183              {
184                  ctx.eval(script);
185                  auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval("filter");
186                  std::string result_list = filter(nodelist);
187                  filtered_nodelist = split(regTrim(result_list), "\n");
188              }
189              catch (qjs::exception)
190              {
191                  script_print_stack(ctx);
192              }
193          }, global.scriptCleanContext);
194      }
195  #endif 
196      else
197      {
198          for(Proxy &x : nodelist)
199          {
200              if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())
201                  filtered_nodelist.emplace_back(x.Remark);
202          }
203      }
204  }
205  void proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)
206  {
207      YAML::Node proxies, singleproxy, singlegroup, original_groups;
208      std::vector<Proxy> nodelist;
209      string_array remarks_list, filtered_nodelist;
210      bool block = false, compact = false;
211      switch(hash_(ext.clash_proxies_style))
212      {
213      case "block"_hash:
214          block = true;
215          break;
216      default:
217      case "flow"_hash:
218          break;
219      case "compact"_hash:
220          compact = true;
221          break;
222      }
223      for(Proxy &x : nodes)
224      {
225          singleproxy.reset();
226          std::string type = getProxyTypeName(x.Type);
227          std::string remark, pluginopts = replaceAllDistinct(x.PluginOption, ";", "&");
228          if(ext.append_proxy_type)
229              x.Remark = "[" + type + "] " + x.Remark;
230          processRemark(x.Remark, remark, remarks_list, false);
231          tribool udp = ext.udp;
232          tribool scv = ext.skip_cert_verify;
233          udp.define(x.UDP);
234          scv.define(x.AllowInsecure);
235          singleproxy["name"] = remark;
236          singleproxy["server"] = x.Hostname;
237          singleproxy["port"] = x.Port;
238          switch(x.Type)
239          {
240          case ProxyType::Shadowsocks:
241              if(ext.filter_deprecated && x.EncryptMethod == "chacha20")
242                  continue;
243              singleproxy["type"] = "ss";
244              singleproxy["cipher"] = x.EncryptMethod;
245              singleproxy["password"] = x.Password;
246              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
247                  singleproxy["password"].SetTag("str");
248              switch(hash_(x.Plugin))
249              {
250              case "simple-obfs"_hash:
251              case "obfs-local"_hash:
252                  singleproxy["plugin"] = "obfs";
253                  singleproxy["plugin-opts"]["mode"] = urlDecode(getUrlArg(pluginopts, "obfs"));
254                  singleproxy["plugin-opts"]["host"] = urlDecode(getUrlArg(pluginopts, "obfs-host"));
255                  break;
256              case "v2ray-plugin"_hash:
257                  singleproxy["plugin"] = "v2ray-plugin";
258                  singleproxy["plugin-opts"]["mode"] = getUrlArg(pluginopts, "mode");
259                  singleproxy["plugin-opts"]["host"] = getUrlArg(pluginopts, "host");
260                  singleproxy["plugin-opts"]["path"] = getUrlArg(pluginopts, "path");
261                  singleproxy["plugin-opts"]["tls"] = pluginopts.find("tls") != std::string::npos;
262                  singleproxy["plugin-opts"]["mux"] = pluginopts.find("mux") != std::string::npos;
263                  if(!scv.is_undef())
264                      singleproxy["plugin-opts"]["skip-cert-verify"] = scv.get();
265                  break;
266              }
267              break;
268          case ProxyType::VMess:
269              singleproxy["type"] = "vmess";
270              singleproxy["uuid"] = x.UserId;
271              singleproxy["alterId"] = x.AlterId;
272              singleproxy["cipher"] = x.EncryptMethod;
273              singleproxy["tls"] = x.TLSSecure;
274              if(!scv.is_undef())
275                  singleproxy["skip-cert-verify"] = scv.get();
276              if(!x.ServerName.empty())
277                  singleproxy["servername"] = x.ServerName;
278              switch(hash_(x.TransferProtocol))
279              {
280              case "tcp"_hash:
281                  break;
282              case "ws"_hash:
283                  singleproxy["network"] = x.TransferProtocol;
284                  if(ext.clash_new_field_name)
285                  {
286                      singleproxy["ws-opts"]["path"] = x.Path;
287                      if(!x.Host.empty())
288                          singleproxy["ws-opts"]["headers"]["Host"] = x.Host;
289                      if(!x.Edge.empty())
290                          singleproxy["ws-opts"]["headers"]["Edge"] = x.Edge;
291                  }
292                  else
293                  {
294                      singleproxy["ws-path"] = x.Path;
295                      if(!x.Host.empty())
296                          singleproxy["ws-headers"]["Host"] = x.Host;
297                      if(!x.Edge.empty())
298                          singleproxy["ws-headers"]["Edge"] = x.Edge;
299                  }
300                  break;
301              case "http"_hash:
302                  singleproxy["network"] = x.TransferProtocol;
303                  singleproxy["http-opts"]["method"] = "GET";
304                  singleproxy["http-opts"]["path"].push_back(x.Path);
305                  if(!x.Host.empty())
306                      singleproxy["http-opts"]["headers"]["Host"].push_back(x.Host);
307                  if(!x.Edge.empty())
308                      singleproxy["http-opts"]["headers"]["Edge"].push_back(x.Edge);
309                  break;
310              case "h2"_hash:
311                  singleproxy["network"] = x.TransferProtocol;
312                  singleproxy["h2-opts"]["path"] = x.Path;
313                  if(!x.Host.empty())
314                      singleproxy["h2-opts"]["host"].push_back(x.Host);
315                  break;
316              case "grpc"_hash:
317                  singleproxy["network"] = x.TransferProtocol;
318                  singleproxy["servername"] = x.Host;
319                  singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
320                  break;
321              default:
322                  continue;
323              }
324              break;
325          case ProxyType::ShadowsocksR:
326              if(ext.filter_deprecated)
327              {
328                  if(!clashR && std::find(clash_ssr_ciphers.cbegin(), clash_ssr_ciphers.cend(), x.EncryptMethod) == clash_ssr_ciphers.cend())
329                      continue;
330                  if(std::find(clashr_protocols.cbegin(), clashr_protocols.cend(), x.Protocol) == clashr_protocols.cend())
331                      continue;
332                  if(std::find(clashr_obfs.cbegin(), clashr_obfs.cend(), x.OBFS) == clashr_obfs.cend())
333                      continue;
334              }
335              singleproxy["type"] = "ssr";
336              singleproxy["cipher"] = x.EncryptMethod == "none" ? "dummy" : x.EncryptMethod;
337              singleproxy["password"] = x.Password;
338              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
339                  singleproxy["password"].SetTag("str");
340              singleproxy["protocol"] = x.Protocol;
341              singleproxy["obfs"] = x.OBFS;
342              if(clashR)
343              {
344                  singleproxy["protocolparam"] = x.ProtocolParam;
345                  singleproxy["obfsparam"] = x.OBFSParam;
346              }
347              else
348              {
349                  singleproxy["protocol-param"] = x.ProtocolParam;
350                  singleproxy["obfs-param"] = x.OBFSParam;
351              }
352              break;
353          case ProxyType::SOCKS5:
354              singleproxy["type"] = "socks5";
355              if(!x.Username.empty())
356                  singleproxy["username"] = x.Username;
357              if(!x.Password.empty())
358              {
359                  singleproxy["password"] = x.Password;
360                  if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))
361                      singleproxy["password"].SetTag("str");
362              }
363              if(!scv.is_undef())
364                  singleproxy["skip-cert-verify"] = scv.get();
365              break;
366          case ProxyType::HTTP:
367          case ProxyType::HTTPS:
368              singleproxy["type"] = "http";
369              if(!x.Username.empty())
370                  singleproxy["username"] = x.Username;
371              if(!x.Password.empty())
372              {
373                  singleproxy["password"] = x.Password;
374                  if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))
375                      singleproxy["password"].SetTag("str");
376              }
377              singleproxy["tls"] = x.TLSSecure;
378              if(!scv.is_undef())
379                  singleproxy["skip-cert-verify"] = scv.get();
380              break;
381          case ProxyType::Trojan:
382              singleproxy["type"] = "trojan";
383              singleproxy["password"] = x.Password;
384              if(!x.Host.empty())
385                  singleproxy["sni"] = x.Host;
386              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
387                  singleproxy["password"].SetTag("str");
388              if(!scv.is_undef())
389                  singleproxy["skip-cert-verify"] = scv.get();
390              switch(hash_(x.TransferProtocol))
391              {
392              case "tcp"_hash:
393                  break;
394              case "grpc"_hash:
395                  singleproxy["network"] = x.TransferProtocol;
396                  if(!x.Path.empty())
397                      singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
398                  break;
399              case "ws"_hash:
400                  singleproxy["network"] = x.TransferProtocol;
401                  singleproxy["ws-opts"]["path"] = x.Path;
402                  if(!x.Host.empty())
403                      singleproxy["ws-opts"]["headers"]["Host"] = x.Host;
404                  break;
405              }
406              break;
407          case ProxyType::Snell:
408              singleproxy["type"] = "snell";
409              singleproxy["psk"] = x.Password;
410              if(x.SnellVersion != 0)
411                  singleproxy["version"] = x.SnellVersion;
412              if(!x.OBFS.empty())
413              {
414                  singleproxy["obfs-opts"]["mode"] = x.OBFS;
415                  if(!x.Host.empty())
416                      singleproxy["obfs-opts"]["host"] = x.Host;
417              }
418              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
419                  singleproxy["password"].SetTag("str");
420              break;
421          default:
422              continue;
423          }
424          if(udp)
425              singleproxy["udp"] = true;
426          if(block)
427              singleproxy.SetStyle(YAML::EmitterStyle::Block);
428          else
429              singleproxy.SetStyle(YAML::EmitterStyle::Flow);
430          proxies.push_back(singleproxy);
431          remarks_list.emplace_back(std::move(remark));
432          nodelist.emplace_back(x);
433      }
434      if(compact)
435          proxies.SetStyle(YAML::EmitterStyle::Flow);
436      if(ext.nodelist)
437      {
438          YAML::Node provider;
439          provider["proxies"] = proxies;
440          yamlnode.reset(provider);
441          return;
442      }
443      if(ext.clash_new_field_name)
444          yamlnode["proxies"] = proxies;
445      else
446          yamlnode["Proxy"] = proxies;
447      for(const ProxyGroupConfig &x : extra_proxy_group)
448      {
449          singlegroup.reset();
450          eraseElements(filtered_nodelist);
451          singlegroup["name"] = x.Name;
452          singlegroup["type"] = x.TypeStr();
453          switch(x.Type)
454          {
455          case ProxyGroupType::Select:
456          case ProxyGroupType::Relay:
457              break;
458          case ProxyGroupType::LoadBalance:
459              singlegroup["strategy"] = x.StrategyStr();
460              [[fallthrough]];
461          case ProxyGroupType::URLTest:
462              if(!x.Lazy.is_undef())
463                  singlegroup["lazy"] = x.Lazy.get();
464              [[fallthrough]];
465          case ProxyGroupType::Fallback:
466              singlegroup["url"] = x.Url;
467              if(x.Interval > 0)
468                  singlegroup["interval"] = x.Interval;
469              if(x.Tolerance > 0)
470                  singlegroup["tolerance"] = x.Tolerance;
471              break;
472          default:
473              continue;
474          }
475          if(!x.DisableUdp.is_undef())
476              singlegroup["disable-udp"] = x.DisableUdp.get();
477          for(const auto& y : x.Proxies)
478              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
479          if(!x.UsingProvider.empty())
480              singlegroup["use"] = x.UsingProvider;
481          else
482          {
483              if(filtered_nodelist.empty())
484                  filtered_nodelist.emplace_back("DIRECT");
485          }
486          if(!filtered_nodelist.empty())
487              singlegroup["proxies"] = filtered_nodelist;
488          bool replace_flag = false;
489          for(unsigned int i = 0; i < original_groups.size(); i++)
490          {
491              if(original_groups[i]["name"].as<std::string>() == x.Name)
492              {
493                  original_groups[i] = singlegroup;
494                  replace_flag = true;
495                  break;
496              }
497          }
498          if(!replace_flag)
499              original_groups.push_back(singlegroup);
500      }
501      if(ext.clash_new_field_name)
502          yamlnode["proxy-groups"] = original_groups;
503      else
504          yamlnode["Proxy Group"] = original_groups;
505  }
506  std::string proxyToClash(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)
507  {
508      YAML::Node yamlnode;
509      try
510      {
511          yamlnode = YAML::Load(base_conf);
512      }
513      catch (std::exception &e)
514      {
515          writeLog(0, std::string("Clash base loader failed with error: ") + e.what(), LOG_LEVEL_ERROR);
516          return std::string();
517      }
518      proxyToClash(nodes, yamlnode, extra_proxy_group, clashR, ext);
519      if(ext.nodelist)
520          return YAML::Dump(yamlnode);
521      if(!ext.enable_rule_generator)
522          return YAML::Dump(yamlnode);
523      if(!ext.managed_config_prefix.empty() || ext.clash_script)
524      {
525          if(yamlnode["mode"].IsDefined())
526          {
527              if(ext.clash_new_field_name)
528                  yamlnode["mode"] = ext.clash_script ? "script" : "rule";
529              else
530                  yamlnode["mode"] = ext.clash_script ? "Script" : "Rule";
531          }
532          renderClashScript(yamlnode, ruleset_content_array, ext.managed_config_prefix, ext.clash_script, ext.overwrite_original_rules, ext.clash_classical_ruleset);
533          return YAML::Dump(yamlnode);
534      }
535      std::string output_content = rulesetToClashStr(yamlnode, ruleset_content_array, ext.overwrite_original_rules, ext.clash_new_field_name);
536      output_content.insert(0, YAML::Dump(yamlnode));
537      return output_content;
538  }
539  std::string proxyToSurge(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, int surge_ver, extra_settings &ext)
540  {
541      INIReader ini;
542      std::string proxy;
543      std::string output_nodelist;
544      tribool udp, tfo, scv, tls13;
545      std::vector<Proxy> nodelist;
546      unsigned short local_port = 1080;
547      string_array remarks_list, filtered_nodelist, args;
548      ini.store_any_line = true;
549      ini.AddDirectSaveSection("General");
550      ini.AddDirectSaveSection("Replica");
551      ini.AddDirectSaveSection("Rule");
552      ini.AddDirectSaveSection("MITM");
553      ini.AddDirectSaveSection("Script");
554      ini.AddDirectSaveSection("Host");
555      ini.AddDirectSaveSection("URL Rewrite");
556      ini.AddDirectSaveSection("Header Rewrite");
557      if(ini.Parse(base_conf) != 0 && !ext.nodelist)
558      {
559          writeLog(0, "Surge base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
560          return std::string();
561      }
562      ini.SetCurrentSection("Proxy");
563      ini.EraseSection();
564      ini.Set("{NONAME}", "DIRECT = direct");
565      for(Proxy &x : nodes)
566      {
567          std::string remark;
568          if(ext.append_proxy_type)
569          {
570              std::string type = getProxyTypeName(x.Type);
571              x.Remark = "[" + type + "] " + x.Remark;
572          }
573          processRemark(x.Remark, remark, remarks_list);
574          std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &edge = x.Edge, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption;
575          std::string port = std::to_string(x.Port);
576          bool &tlssecure = x.TLSSecure;
577          udp = ext.udp;
578          tfo = ext.tfo;
579          scv = ext.skip_cert_verify;
580          tls13 = ext.tls13;
581          udp.define(x.UDP);
582          tfo.define(x.TCPFastOpen);
583          scv.define(x.AllowInsecure);
584          tls13.define(x.TLS13);
585          proxy.clear();
586          switch(x.Type)
587          {
588          case ProxyType::Shadowsocks:
589              if(surge_ver >= 3 || surge_ver == -3)
590              {
591                  proxy = "ss, " + hostname + ", " + port + ", encrypt-method=" + method + ", password=" + password;
592              }
593              else
594              {
595                  proxy = "custom, "  + hostname + ", " + port + ", " + method + ", " + password + ", https:&bsol;&bsol;github.com/pobizhe/SSEncrypt/raw/master/SSEncrypt.module";
596              }
597              if(!plugin.empty())
598              {
599                  switch(hash_(plugin))
600                  {
601                  case "simple-obfs"_hash:
602                  case "obfs-local"_hash:
603                      if(!pluginopts.empty())
604                          proxy += "," + replaceAllDistinct(pluginopts, ";", ",");
605                      break;
606                  default:
607                      continue;
608                  }
609              }
610              break;
611          case ProxyType::VMess:
612              if(surge_ver < 4 && surge_ver != -3)
613                  continue;
614              proxy = "vmess, " + hostname + ", " + port + ", username=" + id + ", tls=" + (tlssecure ? "true" : "false") +  ", vmess-aead=" + (x.AlterId == 0 ? "true" : "false");
615              if(tlssecure && !tls13.is_undef())
616                  proxy += ", tls13=" + std::string(tls13 ? "true" : "false");
617              switch(hash_(transproto))
618              {
619              case "tcp"_hash:
620                  break;
621              case "ws"_hash:
622                  if(host.empty())
623                      proxy += ", ws=true, ws-path=" + path + ", sni=" + hostname;
624                  else
625                      proxy += ", ws=true, ws-path=" + path + ", sni=" + hostname + ", ws-headers=Host:" + host;
626                  if(!edge.empty())
627                      proxy += "|Edge:" + edge;
628                  break;
629              default:
630                  continue;
631              }
632              if(!scv.is_undef())
633                  proxy += ", skip-cert-verify=" + scv.get_str();
634              break;
635          case ProxyType::ShadowsocksR:
636              if(ext.surge_ssr_path.empty() || surge_ver < 2)
637                  continue;
638              proxy = "external, exec=\"" + ext.surge_ssr_path + "\", args=\"";
639              args = {"-l", std::to_string(local_port), "-s", hostname, "-p", port, "-m", method, "-k", password, "-o", obfs, "-O", protocol};
640              if(!obfsparam.empty())
641              {
642                  args.emplace_back("-g");
643                  args.emplace_back(std::move(obfsparam));
644              }
645              if(!protoparam.empty())
646              {
647                  args.emplace_back("-G");
648                  args.emplace_back(std::move(protoparam));
649              }
650              proxy += join(args, "\", args=\"");
651              proxy += "\", local-port=" + std::to_string(local_port);
652              if(isIPv4(hostname) || isIPv6(hostname))
653                  proxy += ", addresses=" + hostname;
654              else if(global.surgeResolveHostname)
655                  proxy += ", addresses=" + hostnameToIPAddr(hostname);
656              local_port++;
657              break;
658          case ProxyType::SOCKS5:
659              proxy = "socks5, " + hostname + ", " + port;
660              if(!username.empty())
661                  proxy += ", username=" + username;
662              if(!password.empty())
663                  proxy += ", password=" + password;
664              if(!scv.is_undef())
665                  proxy += ", skip-cert-verify=" + scv.get_str();
666              break;
667          case ProxyType::HTTPS:
668              if(surge_ver == -3)
669              {
670                  proxy = "https, " + hostname + ", " + port + ", " + username + ", " + password;
671                  if(!scv.is_undef())
672                      proxy += ", skip-cert-verify=" + scv.get_str();
673                  break;
674              }
675              [[fallthrough]];
676          case ProxyType::HTTP:
677              proxy = "http, " + hostname + ", " + port;
678              if(!username.empty())
679                  proxy += ", username=" + username;
680              if(!password.empty())
681                  proxy += ", password=" + password;
682              proxy += std::string(", tls=") + (x.TLSSecure ? "true" : "false");
683              if(!scv.is_undef())
684                  proxy += ", skip-cert-verify=" + scv.get_str();
685              break;
686          case ProxyType::Trojan:
687              if(surge_ver < 4 && surge_ver != -3)
688                  continue;
689              proxy = "trojan, " + hostname + ", " + port + ", password=" + password;
690              if(x.SnellVersion != 0)
691                  proxy += ", version=" + std::to_string(x.SnellVersion);
692              if(!host.empty())
693                  proxy += ", sni=" + host;
694              if(!scv.is_undef())
695                  proxy += ", skip-cert-verify=" + scv.get_str();
696              break;
697          case ProxyType::Snell:
698              proxy = "snell, " + hostname + ", " + port + ", psk=" + password;
699              if(!obfs.empty())
700                  proxy += ", obfs=" + obfs + ", obfs-host=" + host;
701              break;
702          default:
703              continue;
704          }
705          if(!tfo.is_undef())
706              proxy += ", tfo=" + tfo.get_str();
707          if(!udp.is_undef())
708              proxy += ", udp-relay=" + udp.get_str();
709          if(ext.nodelist)
710              output_nodelist += remark + " = " + proxy + "\n";
711          else
712          {
713              ini.Set("{NONAME}", remark + " = " + proxy);
714              nodelist.emplace_back(x);
715          }
716          remarks_list.emplace_back(std::move(remark));
717      }
718      if(ext.nodelist)
719          return output_nodelist;
720      ini.SetCurrentSection("Proxy Group");
721      ini.EraseSection();
722      for(const ProxyGroupConfig &x : extra_proxy_group)
723      {
724          eraseElements(filtered_nodelist);
725          proxy.clear();
726          switch(x.Type)
727          {
728          case ProxyGroupType::Select:
729          case ProxyGroupType::URLTest:
730          case ProxyGroupType::Fallback:
731              break;
732          case ProxyGroupType::LoadBalance:
733              if(surge_ver < 1 && surge_ver != -3)
734                  continue;
735              break;
736          case ProxyGroupType::SSID:
737              proxy = x.TypeStr() + ",default=" + x.Proxies[0] + ",";
738              proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), ",");
739              ini.Set("{NONAME}", x.Name + " = " + proxy); 
740              continue;
741          default:
742              continue;
743          }
744          for(const auto &y : x.Proxies)
745              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
746          if(filtered_nodelist.empty())
747              filtered_nodelist.emplace_back("DIRECT");
748          if(filtered_nodelist.size() == 1)
749          {
750              proxy = toLower(filtered_nodelist[0]);
751              switch(hash_(proxy))
752              {
753              case "direct"_hash:
754              case "reject"_hash:
755              case "reject-tinygif"_hash:
756                  ini.Set("Proxy", "{NONAME}", x.Name + " = " + proxy);
757                  continue;
758              }
759          }
760          proxy = x.TypeStr() + ",";
761          proxy += join(filtered_nodelist, ",");
762          if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback || x.Type == ProxyGroupType::LoadBalance)
763          {
764              proxy += ",url=" + x.Url + ",interval=" + std::to_string(x.Interval);
765              if(x.Tolerance > 0)
766                  proxy += ",tolerance=" + std::to_string(x.Tolerance);
767              if(x.Timeout > 0)
768                  proxy += ",timeout=" + std::to_string(x.Timeout);
769              if(!x.Persistent.is_undef())
770                  proxy += ",persistent=" + x.Persistent.get_str();
771              if(!x.EvaluateBeforeUse.is_undef())
772                  proxy += ",evaluate-before-use=" + x.EvaluateBeforeUse.get_str();
773          }
774          ini.Set("{NONAME}", x.Name + " = " + proxy); 
775      }
776      if(ext.enable_rule_generator)
777          rulesetToSurge(ini, ruleset_content_array, surge_ver, ext.overwrite_original_rules, ext.managed_config_prefix);
778      return ini.ToString();
779  }
780  std::string proxyToSingle(std::vector<Proxy> &nodes, int types, extra_settings &ext)
781  {
782      std::string remark, hostname, port, password, method;
783      std::string plugin, pluginopts;
784      std::string protocol, protoparam, obfs, obfsparam;
785      std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret;
786      std::string proxyStr, allLinks;
787      bool ss = GETBIT(types, 1), ssr = GETBIT(types, 2), vmess = GETBIT(types, 3), trojan = GETBIT(types, 4);
788      for(Proxy &x : nodes)
789      {
790          remark = x.Remark;
791          std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &faketype = x.FakeType;
792          bool &tlssecure = x.TLSSecure;
793          std::string port = std::to_string(x.Port);
794          std::string aid = std::to_string(x.AlterId);
795          switch(x.Type)
796          {
797          case ProxyType::Shadowsocks:
798              if(ss)
799              {
800                  proxyStr = "ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port;
801                  if(!plugin.empty() && !pluginopts.empty())
802                  {
803                      proxyStr += "/?plugin=" + urlEncode(plugin + ";" + pluginopts);
804                  }
805                  proxyStr += "#" + urlEncode(remark);
806              }
807              else if(ssr)
808              {
809                  if(std::find(ssr_ciphers.begin(), ssr_ciphers.end(), method) != ssr_ciphers.end() && plugin.empty())
810                      proxyStr = "ssr:&bsol;&bsol;" + urlSafeBase64Encode(hostname + ":" + port + ":origin:" + method + ":plain:" + urlSafeBase64Encode(password) \
811                                 + "/?group=" + urlSafeBase64Encode(x.Group) + "&remarks=" + urlSafeBase64Encode(remark));
812              }
813              else
814                  continue;
815              break;
816          case ProxyType::ShadowsocksR:
817              if(ssr)
818              {
819                  proxyStr = "ssr:&bsol;&bsol;" + urlSafeBase64Encode(hostname + ":" + port + ":" + protocol + ":" + method + ":" + obfs + ":" + urlSafeBase64Encode(password) \
820                             + "/?group=" + urlSafeBase64Encode(x.Group) + "&remarks=" + urlSafeBase64Encode(remark) \
821                             + "&obfsparam=" + urlSafeBase64Encode(obfsparam) + "&protoparam=" + urlSafeBase64Encode(protoparam));
822              }
823              else if(ss)
824              {
825                  if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) != ss_ciphers.end() && protocol == "origin" && obfs == "plain")
826                      proxyStr = "ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port + "#" + urlEncode(remark);
827              }
828              else
829                  continue;
830              break;
831          case ProxyType::VMess:
832              if(!vmess)
833                  continue;
834              proxyStr = "vmess:&bsol;&bsol;" + base64Encode(vmessLinkConstruct(remark, hostname, port, faketype, id, aid, transproto, path, host, tlssecure ? "tls" : ""));
835              break;
836          case ProxyType::Trojan:
837              if(!trojan)
838                  continue;
839              proxyStr = "trojan:&bsol;&bsol;" + password + "@" + hostname + ":" + port + "?allowInsecure=" + (x.AllowInsecure.get() ? "1" : "0");
840              if(!host.empty())
841                  proxyStr += "&sni=" + host;
842              if(transproto == "ws")
843              {
844                  proxyStr += "&ws=1";
845                  if(!path.empty())
846                      proxyStr += "&wspath=" + urlEncode(path);
847              }
848              proxyStr += "#" + urlEncode(remark);
849              break;
850          default:
851              continue;
852          }
853          allLinks += proxyStr + "\n";
854      }
855      if(ext.nodelist)
856          return allLinks;
857      else
858          return base64Encode(allLinks);
859  }
860  std::string proxyToSSSub(std::string base_conf, std::vector<Proxy> &nodes, extra_settings &ext)
861  {
862      rapidjson::Document json, base;
863      std::string remark, hostname, password, method;
864      std::string plugin, pluginopts;
865      std::string protocol, obfs;
866      std::string output_content;
867      rapidjson::Document::AllocatorType &alloc = json.GetAllocator();
868      json.SetObject();
869      json.AddMember("remarks", "", alloc);
870      json.AddMember("server", "", alloc);
871      json.AddMember("server_port", 0, alloc);
872      json.AddMember("method", "", alloc);
873      json.AddMember("password", "", alloc);
874      json.AddMember("plugin", "", alloc);
875      json.AddMember("plugin_opts", "", alloc);
876      base_conf = trimWhitespace(base_conf);
877      if(base_conf.empty())
878          base_conf = "{}";
879      rapidjson::ParseResult result = base.Parse(base_conf.data());
880      if(result)
881      {
882          for(auto iter = base.MemberBegin(); iter != base.MemberEnd(); iter++)
883              json.AddMember(iter->name, iter->value, alloc);
884      }
885      else
886          writeLog(0, std::string("SIP008 base loader failed with error: ") + rapidjson::GetParseError_En(result.Code()) + " (" + std::to_string(result.Offset()) + ")", LOG_LEVEL_ERROR);
887      rapidjson::Value jsondata;
888      jsondata = json.Move();
889      output_content = "[";
890      for(Proxy &x : nodes)
891      {
892          remark = x.Remark;
893          hostname = x.Hostname;
894          std::string &password = x.Password;
895          std::string &method = x.EncryptMethod;
896          std::string &plugin = x.Plugin;
897          std::string &pluginopts = x.PluginOption;
898          std::string &protocol = x.Protocol;
899          std::string &obfs = x.OBFS;
900          switch(x.Type)
901          {
902          case ProxyType::Shadowsocks:
903              if(plugin == "simple-obfs")
904                  plugin = "obfs-local";
905              break;
906          case ProxyType::ShadowsocksR:
907              if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) == ss_ciphers.end() || protocol != "origin" || obfs != "plain")
908                  continue;
909              break;
910          default:
911              continue;
912          }
913          jsondata["remarks"].SetString(rapidjson::StringRef(remark.c_str(), remark.size()));
914          jsondata["server"].SetString(rapidjson::StringRef(hostname.c_str(), hostname.size()));
915          jsondata["server_port"] = x.Port;
916          jsondata["password"].SetString(rapidjson::StringRef(password.c_str(), password.size()));
917          jsondata["method"].SetString(rapidjson::StringRef(method.c_str(), method.size()));
918          jsondata["plugin"].SetString(rapidjson::StringRef(plugin.c_str(), plugin.size()));
919          jsondata["plugin_opts"].SetString(rapidjson::StringRef(pluginopts.c_str(), pluginopts.size()));
920          output_content += SerializeObject(jsondata) + ",";
921      }
922      if(output_content.size() > 1)
923          output_content.erase(output_content.size() - 1);
924      output_content += "]";
925      return output_content;
926  }
927  std::string proxyToQuan(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
928  {
929      INIReader ini;
930      ini.store_any_line = true;
931      if(!ext.nodelist && ini.Parse(base_conf) != 0)
932      {
933          writeLog(0, "Quantumult base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
934          return std::string();
935      }
936      proxyToQuan(nodes, ini, ruleset_content_array, extra_proxy_group, ext);
937      if(ext.nodelist)
938      {
939          string_array allnodes;
940          std::string allLinks;
941          ini.GetAll("SERVER", "{NONAME}", allnodes);
942          if(!allnodes.empty())
943              allLinks = join(allnodes, "\n");
944          return base64Encode(allLinks);
945      }
946      return ini.ToString();
947  }
948  void proxyToQuan(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
949  {
950      std::string type, proxyStr;
951      tribool scv;
952      std::vector<Proxy> nodelist;
953      string_array remarks_list;
954      ini.SetCurrentSection("SERVER");
955      ini.EraseSection();
956      for(Proxy &x : nodes)
957      {
958          std::string remark = x.Remark;
959          if(ext.append_proxy_type)
960          {
961              std::string type = getProxyTypeName(x.Type);
962              x.Remark = "[" + type + "] " + x.Remark;
963          }
964          processRemark(x.Remark, remark, remarks_list);
965          std::string &hostname = x.Hostname, &method = x.EncryptMethod, &password = x.Password, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &edge = x.Edge, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption, &username = x.Username;
966          std::string port = std::to_string(x.Port);
967          bool &tlssecure = x.TLSSecure;
968          switch(x.Type)
969          {
970          case ProxyType::VMess:
971              scv = ext.skip_cert_verify;
972              scv.define(x.AllowInsecure);
973              if(method == "auto")
974                  method = "chacha20-ietf-poly1305";
975              proxyStr = remark + " = vmess, " + hostname + ", " + port + ", " + method + ", \"" + id + "\", group=" + x.Group;
976              if(tlssecure)
977              {
978                  proxyStr += ", over-tls=true, tls-host=" + host;
979                  if(!scv.is_undef())
980                      proxyStr += ", certificate=" + std::string(scv.get() ? "0" : "1");
981              }
982              if(transproto == "ws")
983              {
984                  proxyStr += ", obfs=ws, obfs-path=\"" + path + "\", obfs-header=\"Host: " + host;
985                  if(!edge.empty())
986                      proxyStr += "[Rr][Nn]Edge: " + edge;
987                  proxyStr += "\"";
988              }
989              if(ext.nodelist)
990                  proxyStr = "vmess:&bsol;&bsol;" + urlSafeBase64Encode(proxyStr);
991              break;
992          case ProxyType::ShadowsocksR:
993              if(ext.nodelist)
994              {
995                  proxyStr = "ssr:&bsol;&bsol;" + urlSafeBase64Encode(hostname + ":" + port + ":" + protocol + ":" + method + ":" + obfs + ":" + urlSafeBase64Encode(password) \
996                             + "/?group=" + urlSafeBase64Encode(x.Group) + "&remarks=" + urlSafeBase64Encode(remark) \
997                             + "&obfsparam=" + urlSafeBase64Encode(obfsparam) + "&protoparam=" + urlSafeBase64Encode(protoparam));
998              }
999              else
1000              {
1001                  proxyStr = remark + " = shadowsocksr, " + hostname + ", " + port + ", " + method + ", \"" + password + "\", group=" + x.Group + ", protocol=" + protocol + ", obfs=" + obfs;
1002                  if(!protoparam.empty())
1003                      proxyStr += ", protocol_param=" + protoparam;
1004                  if(!obfsparam.empty())
1005                      proxyStr += ", obfs_param=" + obfsparam;
1006              }
1007              break;
1008          case ProxyType::Shadowsocks:
1009              if(ext.nodelist)
1010              {
1011                  proxyStr = "ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port;
1012                  if(!plugin.empty() && !pluginopts.empty())
1013                  {
1014                      proxyStr += "/?plugin=" + urlEncode(plugin + ";" + pluginopts);
1015                  }
1016                  proxyStr += "&group=" + urlSafeBase64Encode(x.Group) + "#" + urlEncode(remark);
1017              }
1018              else
1019              {
1020                  proxyStr = remark + " = shadowsocks, " + hostname + ", " + port + ", " + method + ", \"" + password + "\", group=" + x.Group;
1021                  if(plugin == "obfs-local" && !pluginopts.empty())
1022                  {
1023                      proxyStr += ", " + replaceAllDistinct(pluginopts, ";", ", ");
1024                  }
1025              }
1026              break;
1027          case ProxyType::HTTP:
1028          case ProxyType::HTTPS:
1029              proxyStr = remark + " = http, upstream-proxy-address=" + hostname + ", upstream-proxy-port=" + port + ", group=" + x.Group;
1030              if(!username.empty() && !password.empty())
1031                  proxyStr += ", upstream-proxy-auth=true, upstream-proxy-username=" + username + ", upstream-proxy-password=" + password;
1032              else
1033                  proxyStr += ", upstream-proxy-auth=false";
1034              if(tlssecure)
1035              {
1036                  proxyStr += ", over-tls=true";
1037                  if(!host.empty())
1038                      proxyStr += ", tls-host=" + host;
1039                  if(!scv.is_undef())
1040                      proxyStr += ", certificate=" + std::string(scv.get() ? "0" : "1");
1041              }
1042              if(ext.nodelist)
1043                  proxyStr = "http:&bsol;&bsol;" + urlSafeBase64Encode(proxyStr);
1044              break;
1045          case ProxyType::SOCKS5:
1046              proxyStr = remark + " = socks, upstream-proxy-address=" + hostname + ", upstream-proxy-port=" + port + ", group=" + x.Group;
1047              if(!username.empty() && !password.empty())
1048                  proxyStr += ", upstream-proxy-auth=true, upstream-proxy-username=" + username + ", upstream-proxy-password=" + password;
1049              else
1050                  proxyStr += ", upstream-proxy-auth=false";
1051              if(tlssecure)
1052              {
1053                  proxyStr += ", over-tls=true";
1054                  if(!host.empty())
1055                      proxyStr += ", tls-host=" + host;
1056                  if(!scv.is_undef())
1057                      proxyStr += ", certificate=" + std::string(scv.get() ? "0" : "1");
1058              }
1059              if(ext.nodelist)
1060                  proxyStr = "socks:&bsol;&bsol;" + urlSafeBase64Encode(proxyStr);
1061              break;
1062          default:
1063              continue;
1064          }
1065          ini.Set("{NONAME}", proxyStr);
1066          remarks_list.emplace_back(std::move(remark));
1067          nodelist.emplace_back(x);
1068      }
1069      if(ext.nodelist)
1070          return;
1071      string_array filtered_nodelist;
1072      ini.SetCurrentSection("POLICY");
1073      ini.EraseSection();
1074      std::string singlegroup;
1075      std::string name, proxies;
1076      for(const ProxyGroupConfig &x : extra_proxy_group)
1077      {
1078          eraseElements(filtered_nodelist);
1079          switch(x.Type)
1080          {
1081          case ProxyGroupType::Select:
1082          case ProxyGroupType::Fallback:
1083              type = "static";
1084              break;
1085          case ProxyGroupType::URLTest:
1086              type = "auto";
1087              break;
1088          case ProxyGroupType::LoadBalance:
1089              type = "balance, round-robin";
1090              break;
1091          case ProxyGroupType::SSID:
1092              {
1093                  singlegroup = x.Name + " : wifi = " + x.Proxies[0];
1094                  std::string content, celluar, celluar_matcher = R"(^(.*?),?celluar\s?=\s?(.*?)(,.*)$)", rem_a, rem_b;
1095                  for(auto iter = x.Proxies.begin() + 1; iter != x.Proxies.end(); iter++)
1096                  {
1097                      if(regGetMatch(*iter, celluar_matcher, 4, 0, &rem_a, &celluar, &rem_b))
1098                      {
1099                          content += *iter + "\n";
1100                          continue;
1101                      }
1102                      content += rem_a + rem_b + "\n";
1103                  }
1104                  if(!celluar.empty())
1105                      singlegroup += ", celluar = " + celluar;
1106                  singlegroup += "\n" + replaceAllDistinct(trimOf(content, ','), ",", "\n");
1107                  ini.Set("{NONAME}", base64Encode(singlegroup)); 
1108              }
1109              continue;
1110          default:
1111              continue;
1112          }
1113          for(const auto &y : x.Proxies)
1114              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
1115          if(filtered_nodelist.empty())
1116              filtered_nodelist.emplace_back("direct");
1117          if(filtered_nodelist.size() < 2) 
1118              type = "static";
1119          proxies = join(filtered_nodelist, "\n");
1120          singlegroup = x.Name + " : " + type;
1121          if(type == "static")
1122              singlegroup += ", " + filtered_nodelist[0];
1123          singlegroup += "\n" + proxies + "\n";
1124          ini.Set("{NONAME}", base64Encode(singlegroup));
1125      }
1126      if(ext.enable_rule_generator)
1127          rulesetToSurge(ini, ruleset_content_array, -2, ext.overwrite_original_rules, std::string());
1128  }
1129  std::string proxyToQuanX(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1130  {
1131      INIReader ini;
1132      ini.store_any_line = true;
1133      ini.AddDirectSaveSection("general");
1134      ini.AddDirectSaveSection("dns");
1135      ini.AddDirectSaveSection("rewrite_remote");
1136      ini.AddDirectSaveSection("rewrite_local");
1137      ini.AddDirectSaveSection("task_local");
1138      ini.AddDirectSaveSection("mitm");
1139      ini.AddDirectSaveSection("server_remote");
1140      if(!ext.nodelist && ini.Parse(base_conf) != 0)
1141      {
1142          writeLog(0, "QuantumultX base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1143          return std::string();
1144      }
1145      proxyToQuanX(nodes, ini, ruleset_content_array, extra_proxy_group, ext);
1146      if(ext.nodelist)
1147      {
1148          string_array allnodes;
1149          std::string allLinks;
1150          ini.GetAll("server_local", "{NONAME}", allnodes);
1151          if(!allnodes.empty())
1152              allLinks = join(allnodes, "\n");
1153          return allLinks;
1154      }
1155      return ini.ToString();
1156  }
1157  void proxyToQuanX(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1158  {
1159      std::string type;
1160      std::string remark, hostname, port, method;
1161      std::string password, plugin, pluginopts;
1162      std::string id, transproto, host, path;
1163      std::string protocol, protoparam, obfs, obfsparam;
1164      std::string proxyStr;
1165      tribool udp, tfo, scv, tls13;
1166      std::vector<Proxy> nodelist;
1167      string_array remarks_list;
1168      ini.SetCurrentSection("server_local");
1169      ini.EraseSection();
1170      for(Proxy &x : nodes)
1171      {
1172          if(ext.append_proxy_type)
1173              x.Remark = "[" + type + "] " + x.Remark;
1174          processRemark(x.Remark, remark, remarks_list);
1175          std::string &hostname = x.Hostname, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &password = x.Password, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &username = x.Username;
1176          std::string port = std::to_string(x.Port);
1177          bool &tlssecure = x.TLSSecure;
1178          udp = ext.udp;
1179          tfo = ext.tfo;
1180          scv = ext.skip_cert_verify;
1181          tls13 = ext.tls13;
1182          udp.define(x.UDP);
1183          tfo.define(x.TCPFastOpen);
1184          scv.define(x.AllowInsecure);
1185          tls13.define(x.TLS13);
1186          switch(x.Type)
1187          {
1188          case ProxyType::VMess:
1189              if(method == "auto")
1190                  method = "chacha20-ietf-poly1305";
1191              proxyStr = "vmess = " + hostname + ":" + port + ", method=" + method + ", password=" + id;
1192              if (x.AlterId != 0)
1193                  proxyStr += ", aead=false";
1194              if(tlssecure && !tls13.is_undef())
1195                  proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1196              if(transproto == "ws")
1197              {
1198                  if(tlssecure)
1199                      proxyStr += ", obfs=wss";
1200                  else
1201                      proxyStr += ", obfs=ws";
1202                  proxyStr += ", obfs-host=" + host + ", obfs-uri=" + path;
1203              }
1204              else if(tlssecure)
1205                  proxyStr += ", obfs=over-tls, obfs-host=" + host;
1206              break;
1207          case ProxyType::Shadowsocks:
1208              proxyStr = "shadowsocks = " + hostname + ":" + port + ", method=" + method + ", password=" + password;
1209              if(!plugin.empty())
1210              {
1211                  switch(hash_(plugin))
1212                  {
1213                      case "simple-obfs"_hash:
1214                      case "obfs-local"_hash:
1215                          if(!pluginopts.empty())
1216                              proxyStr += ", " + replaceAllDistinct(pluginopts, ";", ", ");
1217                          break;
1218                      case "v2ray-plugin"_hash:
1219                          pluginopts = replaceAllDistinct(pluginopts, ";", "&");
1220                          plugin = getUrlArg(pluginopts, "mode") == "websocket" ? "ws" : "";
1221                          host = getUrlArg(pluginopts, "host");
1222                          path = getUrlArg(pluginopts, "path");
1223                          tlssecure = pluginopts.find("tls") != pluginopts.npos;
1224                          if(tlssecure && plugin == "ws")
1225                          {
1226                              plugin += 's';
1227                              if(!tls13.is_undef())
1228                                  proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1229                          }
1230                          proxyStr += ", obfs=" + plugin;
1231                          if(!host.empty())
1232                              proxyStr += ", obfs-host=" + host;
1233                          if(!path.empty())
1234                              proxyStr += ", obfs-uri=" + path;
1235                          break;
1236                      default: continue;
1237                  }
1238              }
1239              break;
1240          case ProxyType::ShadowsocksR:
1241              proxyStr = "shadowsocks = " + hostname + ":" + port + ", method=" + method + ", password=" + password + ", ssr-protocol=" + protocol;
1242              if(!protoparam.empty())
1243                  proxyStr += ", ssr-protocol-param=" + protoparam;
1244              proxyStr += ", obfs=" + obfs;
1245              if(!obfsparam.empty())
1246                  proxyStr += ", obfs-host=" + obfsparam;
1247              break;
1248          case ProxyType::HTTP:
1249          case ProxyType::HTTPS:
1250              proxyStr = "http = " + hostname + ":" + port + ", username=" + (username.empty() ? "none" : username) + ", password=" + (password.empty() ? "none" : password);
1251              if(tlssecure)
1252              {
1253                  proxyStr += ", over-tls=true";
1254                  if(!tls13.is_undef())
1255                      proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1256              }
1257              else
1258              {
1259                  proxyStr += ", over-tls=false";
1260              }
1261              break;
1262          case ProxyType::Trojan:
1263              proxyStr = "trojan = " + hostname + ":" + port + ", password=" + password;
1264              if(tlssecure)
1265              {
1266                  proxyStr += ", over-tls=true, tls-host=" + host;
1267                  if(!tls13.is_undef())
1268                      proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1269              }
1270              else
1271              {
1272                  proxyStr += ", over-tls=false";
1273              }
1274              break;
1275          case ProxyType::SOCKS5:
1276              proxyStr = "socks5 = " + hostname + ":" + port;
1277              if(!username.empty() && !password.empty())
1278              {
1279                  proxyStr += ", username=" + username + ", password=" + password;
1280                  if(tlssecure)
1281                  {
1282                      proxyStr += ", over-tls=true, tls-host=" + host;
1283                      if(!tls13.is_undef())
1284                          proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1285                  }
1286                  else
1287                  {
1288                      proxyStr += ", over-tls=false";
1289                  }
1290              }
1291              break;
1292          default:
1293              continue;
1294          }
1295          if(!tfo.is_undef())
1296              proxyStr += ", fast-open=" + tfo.get_str();
1297          if(!udp.is_undef())
1298              proxyStr += ", udp-relay=" + udp.get_str();
1299          if(tlssecure && !scv.is_undef() && (x.Type != ProxyType::Shadowsocks && x.Type != ProxyType::ShadowsocksR))
1300              proxyStr += ", tls-verification=" + scv.reverse().get_str();
1301          proxyStr += ", tag=" + remark;
1302          ini.Set("{NONAME}", proxyStr);
1303          remarks_list.emplace_back(std::move(remark));
1304          nodelist.emplace_back(x);
1305      }
1306      if(ext.nodelist)
1307          return;
1308      string_multimap original_groups;
1309      ini.SetCurrentSection("policy");
1310      ini.GetItems(original_groups);
1311      ini.EraseSection();
1312      for(const ProxyGroupConfig &x : extra_proxy_group)
1313      {
1314          string_array filtered_nodelist;
1315          switch(x.Type)
1316          {
1317          case ProxyGroupType::Select:
1318              type = "static";
1319              break;
1320          case ProxyGroupType::URLTest:
1321              type = "url-latency-benchmark";
1322              break;
1323          case ProxyGroupType::Fallback:
1324              type = "available";
1325              break;
1326          case ProxyGroupType::LoadBalance:
1327              type = "round-robin";
1328              break;
1329          case ProxyGroupType::SSID:
1330              type = "ssid";
1331              for(auto iter = x.Proxies.begin(); iter != x.Proxies.end(); iter++)
1332                  filtered_nodelist.emplace_back(replaceAllDistinct(*iter, "=", ":"));
1333              break;
1334          default:
1335              continue;
1336          }
1337          if(x.Type != ProxyGroupType::SSID)
1338          {
1339              for(const auto &y : x.Proxies)
1340                  groupGenerate(y, nodelist, filtered_nodelist, true, ext);
1341              if(filtered_nodelist.empty())
1342                  filtered_nodelist.emplace_back("direct");
1343              if(filtered_nodelist.size() < 2) 
1344                  type = "static";
1345          }
1346          auto iter = std::find_if(original_groups.begin(), original_groups.end(), [&](const string_multimap::value_type &n)
1347          {
1348              std::string groupdata = n.second;
1349              std::string::size_type cpos = groupdata.find(",");
1350              if(cpos != groupdata.npos)
1351                  return trim(groupdata.substr(0, cpos)) == x.Name;
1352              else
1353                  return false;
1354          });
1355          if(iter != original_groups.end())
1356          {
1357              string_array vArray = split(iter->second, ",");
1358              if(vArray.size() > 1)
1359              {
1360                  if(trim(vArray[vArray.size() - 1]).find("img-url") == 0)
1361                      filtered_nodelist.emplace_back(trim(vArray[vArray.size() - 1]));
1362              }
1363          }
1364          std::string proxies = join(filtered_nodelist, ", ");
1365          std::string singlegroup = type + "=" + x.Name + ", " + proxies;
1366          ini.Set("{NONAME}", singlegroup);
1367      }
1368      if(ext.enable_rule_generator)
1369          rulesetToSurge(ini, ruleset_content_array, -1, ext.overwrite_original_rules, ext.managed_config_prefix);
1370  }
1371  std::string proxyToSSD(std::vector<Proxy> &nodes, std::string &group, std::string &userinfo, extra_settings &ext)
1372  {
1373      rapidjson::StringBuffer sb;
1374      rapidjson::Writer<rapidjson::StringBuffer> writer(sb);
1375      size_t index = 0;
1376      if(group.empty())
1377          group = "SSD";
1378      writer.StartObject();
1379      writer.Key("airport");
1380      writer.String(group.data());
1381      writer.Key("port");
1382      writer.Int(1);
1383      writer.Key("encryption");
1384      writer.String("aes-128-gcm");
1385      writer.Key("password");
1386      writer.String("password");
1387      if(!userinfo.empty())
1388      {
1389          std::string data = replaceAllDistinct(userinfo, "; ", "&");
1390          std::string upload = getUrlArg(data, "upload"), download = getUrlArg(data, "download"), total = getUrlArg(data, "total"), expiry = getUrlArg(data, "expire");
1391          double used = (to_number(upload, 0.0) + to_number(download, 0.0)) / std::pow(1024, 3) * 1.0, tot = to_number(total, 0.0) / std::pow(1024, 3) * 1.0;
1392          writer.Key("traffic_used");
1393          writer.Double(used);
1394          writer.Key("traffic_total");
1395          writer.Double(tot);
1396          if(!expiry.empty())
1397          {
1398              const time_t rawtime = to_int(expiry);
1399              char buffer[30];
1400              struct tm *dt = localtime(&rawtime);
1401              strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M", dt);
1402              writer.Key("expiry");
1403              writer.String(buffer);
1404          }
1405      }
1406      writer.Key("servers");
1407      writer.StartArray();
1408      for(Proxy &x : nodes)
1409      {
1410          std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &obfs = x.OBFS;
1411          switch(x.Type)
1412          {
1413          case ProxyType::Shadowsocks:
1414              if(plugin == "obfs-local")
1415                  plugin = "simple-obfs";
1416              writer.StartObject();
1417              writer.Key("server");
1418              writer.String(hostname.data());
1419              writer.Key("port");
1420              writer.Int(x.Port);
1421              writer.Key("encryption");
1422              writer.String(method.data());
1423              writer.Key("password");
1424              writer.String(password.data());
1425              writer.Key("plugin");
1426              writer.String(plugin.data());
1427              writer.Key("plugin_options");
1428              writer.String(pluginopts.data());
1429              writer.Key("remarks");
1430              writer.String(x.Remark.data());
1431              writer.Key("id");
1432              writer.Int(index);
1433              writer.EndObject();
1434              break;
1435          case ProxyType::ShadowsocksR:
1436              if(std::count(ss_ciphers.begin(), ss_ciphers.end(), method) > 0 && protocol == "origin" && obfs == "plain")
1437              {
1438                  writer.StartObject();
1439                  writer.Key("server");
1440                  writer.String(hostname.data());
1441                  writer.Key("port");
1442                  writer.Int(x.Port);
1443                  writer.Key("encryption");
1444                  writer.String(method.data());
1445                  writer.Key("password");
1446                  writer.String(password.data());
1447                  writer.Key("remarks");
1448                  writer.String(x.Remark.data());
1449                  writer.Key("id");
1450                  writer.Int(index);
1451                  writer.EndObject();
1452                  break;
1453              }
1454              else
1455                  continue;
1456          default:
1457              continue;
1458          }
1459          index++;
1460      }
1461      writer.EndArray();
1462      writer.EndObject();
1463      return "ssd:&bsol;&bsol;" + base64Encode(sb.GetString());
1464  }
1465  std::string proxyToMellow(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1466  {
1467      INIReader ini;
1468      ini.store_any_line = true;
1469      if(ini.Parse(base_conf) != 0)
1470      {
1471          writeLog(0, "Mellow base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1472          return std::string();
1473      }
1474      proxyToMellow(nodes, ini, ruleset_content_array, extra_proxy_group, ext);
1475      return ini.ToString();
1476  }
1477  void proxyToMellow(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1478  {
1479      std::string proxy;
1480      std::string type, remark, hostname, port, username, password, method;
1481      std::string plugin, pluginopts;
1482      std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret, tlssecure;
1483      std::string url;
1484      tribool tfo, scv;
1485      std::vector<Proxy> nodelist;
1486      string_array vArray, remarks_list, filtered_nodelist;
1487      ini.SetCurrentSection("Endpoint");
1488      for(Proxy &x : nodes)
1489      {
1490          if(ext.append_proxy_type)
1491          {
1492              std::string type = getProxyTypeName(x.Type);
1493              x.Remark = "[" + type + "] " + x.Remark;
1494          }
1495          processRemark(x.Remark, remark, remarks_list);
1496          std::string &hostname = x.Hostname;
1497          port = std::to_string(x.Port);
1498          tfo = ext.tfo;
1499          scv = ext.skip_cert_verify;
1500          tfo.define(x.TCPFastOpen);
1501          scv.define(x.AllowInsecure);
1502          switch(x.Type)
1503          {
1504          case ProxyType::Shadowsocks:
1505              if(!x.Plugin.empty())
1506                  continue;
1507              proxy = remark + ", ss, ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port;
1508              break;
1509          case ProxyType::VMess:
1510              proxy = remark + ", vmess1, vmess1:&bsol;&bsol;" + id + "@" + hostname + ":" + port;
1511              if(!path.empty())
1512                  proxy += path;
1513              proxy += "?network=" + transproto;
1514              switch(hash_(transproto))
1515              {
1516              case "ws"_hash:
1517                  proxy += "&ws.host=" + urlEncode(host);
1518                  break;
1519              case "http"_hash:
1520                  if(!host.empty())
1521                      proxy += "&http.host=" + urlEncode(host);
1522                  break;
1523              case "quic"_hash:
1524                  if(!quicsecure.empty())
1525                      proxy += "&quic.security=" + quicsecure + "&quic.key=" + quicsecret;
1526                  break;
1527              case "kcp"_hash:
1528                  break;
1529              case "tcp"_hash:
1530                  break;
1531              }
1532              proxy += "&tls=" + tlssecure;
1533              if(tlssecure == "true")
1534              {
1535                  if(!host.empty())
1536                      proxy += "&tls.servername=" + urlEncode(host);
1537              }
1538              if(!scv.is_undef())
1539                  proxy += "&tls.allowinsecure=" + scv.get_str();
1540              if(!tfo.is_undef())
1541                  proxy += "&sockopt.tcpfastopen=" + tfo.get_str();
1542              break;
1543          case ProxyType::SOCKS5:
1544              proxy = remark + ", builtin, socks, address=" + hostname + ", port=" + port + ", user=" + username + ", pass=" + password;
1545              break;
1546          case ProxyType::HTTP:
1547              proxy = remark + ", builtin, http, address=" + hostname + ", port=" + port + ", user=" + username + ", pass=" + password;
1548              break;
1549          default:
1550              continue;
1551          }
1552          ini.Set("{NONAME}", proxy);
1553          remarks_list.emplace_back(std::move(remark));
1554          nodelist.emplace_back(x);
1555      }
1556      ini.SetCurrentSection("EndpointGroup");
1557      for(const ProxyGroupConfig &x : extra_proxy_group)
1558      {
1559          eraseElements(filtered_nodelist);
1560          url.clear();
1561          proxy.clear();
1562          switch(x.Type)
1563          {
1564          case ProxyGroupType::Select:
1565          case ProxyGroupType::URLTest:
1566          case ProxyGroupType::Fallback:
1567          case ProxyGroupType::LoadBalance:
1568              break;
1569          default:
1570              continue;
1571          }
1572          for(const auto &y : x.Proxies)
1573              groupGenerate(y, nodelist, filtered_nodelist, false, ext);
1574          if(filtered_nodelist.empty())
1575          {
1576              if(remarks_list.empty())
1577                  filtered_nodelist.emplace_back("DIRECT");
1578              else
1579                  filtered_nodelist = remarks_list;
1580          }
1581          proxy = x.Name + ", ";
1582          proxy += join(filtered_nodelist, ":");
1583          proxy += ", latency, interval=300, timeout=6"; 
1584          ini.Set("{NONAME}", proxy); 
1585      }
1586      if(ext.enable_rule_generator)
1587          rulesetToSurge(ini, ruleset_content_array, 0, ext.overwrite_original_rules, std::string());
1588  }
1589  std::string proxyToLoon(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1590  {
1591      rapidjson::Document json;
1592      INIReader ini;
1593      std::string proxy;
1594      std::string output_nodelist;
1595      tribool scv;
1596      std::vector<Proxy> nodelist;
1597      string_array vArray, remarks_list, filtered_nodelist;
1598      ini.store_any_line = true;
1599      if(ini.Parse(base_conf) != INIREADER_EXCEPTION_NONE && !ext.nodelist)
1600      {
1601          writeLog(0, "Loon base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1602          return std::string();
1603      }
1604      ini.SetCurrentSection("Proxy");
1605      ini.EraseSection();
1606      for(Proxy &x : nodes)
1607      {
1608          if(ext.append_proxy_type)
1609          {
1610              std::string type = getProxyTypeName(x.Type);
1611              x.Remark = "[" + type + "] " + x.Remark;
1612          }
1613          std::string remark = x.Remark;
1614          processRemark(x.Remark, remark, remarks_list);
1615          std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam;
1616          std::string port = std::to_string(x.Port), aid = std::to_string(x.AlterId);
1617          bool &tlssecure = x.TLSSecure;
1618          tribool scv = ext.skip_cert_verify;
1619          scv.define(x.AllowInsecure);
1620          proxy.clear();
1621          switch(x.Type)
1622          {
1623          case ProxyType::Shadowsocks:
1624              proxy = "Shadowsocks," + hostname + "," + port + "," + method + ",\"" + password + "\"";
1625              if(plugin == "simple-obfs" || plugin == "obfs-local")
1626              {
1627                  if(!pluginopts.empty())
1628                      proxy += "," + replaceAllDistinct(replaceAllDistinct(pluginopts, ";obfs-host=", ","), "obfs=", "");
1629              }
1630              else if(!plugin.empty())
1631                  continue;
1632              break;
1633          case ProxyType::VMess:
1634              if(method == "auto")
1635                  method = "chacha20-ietf-poly1305";
1636              proxy = "vmess," + hostname + "," + port + "," + method + ",\"" + id + "\",over-tls:" + (tlssecure ? "true" : "false");
1637              if(tlssecure)
1638                  proxy += ",tls-name:" + host;
1639              switch(hash_(transproto))
1640              {
1641              case "tcp"_hash:
1642                  proxy += ",transport:tcp";
1643                  break;
1644              case "ws"_hash:
1645                  proxy += ",transport:ws,path:" + path + ",host:" + host;
1646                  break;
1647              default:
1648                  continue;
1649              }
1650              if(!scv.is_undef())
1651                  proxy += ",skip-cert-verify:" + std::string(scv.get() ? "1" : "0");
1652              break;
1653          case ProxyType::ShadowsocksR:
1654              proxy = "ShadowsocksR," + hostname + "," + port + "," + method + ",\"" + password + "\"," + protocol + ",{" + protoparam + "}," + obfs + ",{" + obfsparam + "}";
1655              break;
1656          case ProxyType::HTTP:
1657              proxy = "http," + hostname + "," + port + "," + username + "," + password;
1658              break;
1659          case ProxyType::Trojan:
1660              proxy = "trojan," + hostname + "," + port + "," + password;
1661              if(!host.empty())
1662                  proxy += ",tls-name:" + host;
1663              if(!scv.is_undef())
1664                  proxy += ",skip-cert-verify:" + std::string(scv.get() ? "1" : "0");
1665              break;
1666          default:
1667              continue;
1668          }
1669          if(ext.nodelist)
1670              output_nodelist += remark + " = " + proxy + "\n";
1671          else
1672          {
1673              ini.Set("{NONAME}", remark + " = " + proxy);
1674              nodelist.emplace_back(x);
1675              remarks_list.emplace_back(std::move(remark));
1676          }
1677      }
1678      if(ext.nodelist)
1679          return output_nodelist;
1680      ini.SetCurrentSection("Proxy Group");
1681      ini.EraseSection();
1682      for(const ProxyGroupConfig &x : extra_proxy_group)
1683      {
1684          eraseElements(filtered_nodelist);
1685          proxy.clear();
1686          switch(x.Type)
1687          {
1688          case ProxyGroupType::Select:
1689          case ProxyGroupType::URLTest:
1690          case ProxyGroupType::Fallback:
1691              break;
1692          case ProxyGroupType::SSID:
1693              if(x.Proxies.size() < 2)
1694                  continue;
1695              proxy = x.TypeStr() + ",default=" + x.Proxies[0] + ",";
1696              proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), ",");
1697              ini.Set("{NONAME}", x.Name + " = " + proxy); 
1698              continue;
1699          default:
1700              continue;
1701          }
1702          for(const auto &y : x.Proxies)
1703              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
1704          if(filtered_nodelist.empty())
1705              filtered_nodelist.emplace_back("DIRECT");
1706          proxy = x.TypeStr() + ",";
1707          proxy += join(filtered_nodelist, ",");
1708          if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback)
1709              proxy += ",url=" + x.Url + ",interval=" + std::to_string(x.Interval);
1710          ini.Set("{NONAME}", x.Name + " = " + proxy); 
1711      }
1712      if(ext.enable_rule_generator)
1713          rulesetToSurge(ini, ruleset_content_array, -4, ext.overwrite_original_rules, ext.managed_config_prefix);
1714      return ini.ToString();
1715  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-lrn_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-subexport.cpp</div>
                </div>
                <div class="column column_space"><pre><code>32        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
33    virtual void CrossChannelForward_cpu(const vector<Blob<Dtype>*>& bottom,
34        const vector<Blob<Dtype>*>& top);
</pre></code></div>
                <div class="column column_space"><pre><code>28  std::string vmessLinkConstruct(const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &path, const std::string &host, const std::string &tls)
29  {
30      rapidjson::StringBuffer sb;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    