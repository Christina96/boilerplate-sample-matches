
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.178067318132463%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "sir.h"
3  void TEpidemModel::RunModel(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
4    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
5    OutValV.Clr(false);
6    for (int v = 0; v < StartValV.Len(); v++) {
7      OutValV.Add();
8      OutValV[v].Clr(false);
9      OutValV[v].Add(StartValV[v]);
10    }
11    const double h = (StopT-StartT) / NSteps;
12    double x = StartT;
13    for (int k = 0; k < NSteps; k++) {
14      GetDerivs(x, ValV, dydx);
15      RungeKutta(ValV, dydx, x, h, ValV2);
16      for (int v = 0; v < ValV2.Len(); v++) {
17        double X = ValV2[v];
18        if (X < 0 || _isnan(X) || !_finite(X)) { X = 0; }
19        OutValV[v].Add(X);
20      }
21      ValV = ValV2;
22      x += h;
23    }
24  }
25  void TEpidemModel::RunModel10(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
26    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
27    OutValV.Clr(false);
28    for (int v = 0; v < StartValV.Len(); v++) {
29      OutValV.Add();
30      OutValV[v].Clr(false);
31      OutValV[v].Add(StartValV[v]);
32    }
33    const double h = (StopT-StartT) / (10*NSteps);
34    double x = StartT;
35    for (int k = 0; k < 10*NSteps; k++) {
36      GetDerivs(x, ValV, dydx);
37      RungeKutta(ValV, dydx, x, h, ValV2);
38      if (k % 10 == 0) {
39        for (int v = 0; v < ValV2.Len(); v++) {
40          OutValV[v].Add(ValV2[v]); }
41      }
42      ValV = ValV2;
43      x += h;
44    }
45  }
46  void TEpidemModel::RunEuler(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
47    const double h = (StopT-StartT) / NSteps;
48    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
49    for (int v = 0; v < StartValV.Len(); v++) {
50      OutValV.Add();
51      OutValV[v].Clr(false);
52      OutValV[v].Add(StartValV[v]);
53    }
54    OutValV.Add(); 
55    OutValV.Last().Add(StartT);
56    for (double x = StartT; x <= StopT; x += h) {
57      GetDerivs(x, ValV, dydx);
58      for (int v = 0; v < ValV.Len(); v++) {
59        ValV[v] += h*dydx[v];
60        OutValV[v].Add(ValV[v]);
61      }
62      OutValV.Last().Add(x+h);
63    }
64    for (int v = 1; v < OutValV.Len(); v++) {
65      IAssert(OutValV[v].Len()==OutValV[v-1].Len());
66    }
67  }
68  void TEpidemModel::RungeKutta(const TFltV& y, const TFltV& dydx, double x, double h, TFltV& SirOutV) {
69    const int n = y.Len();
70    IAssert(y.Len() == n && dydx.Len() == n);
71    TFltV dym(n), dyt(n), yt(n);
72    int i;
73    double hh=h*0.5;
74    double h6=h/6.0;
75    double xh=x+hh;
76    for (i=0; i < n; i++) {
77      yt[i]=y[i]+hh*dydx[i];
78    }
79    GetDerivs(xh, yt, dyt);
80    for (i=0; i<n; i++) {
81      yt[i]=y[i]+hh*dyt[i];
82    }
83    GetDerivs(xh,yt,dym);
84    for (i=0; i<n; i++) {
85  	  yt[i]=y[i]+h*dym[i];
86  	  dym[i] += dyt[i];
87    }
88    GetDerivs(x+h,yt,dyt);
89    SirOutV.Clr(false);  
90    for (i=0; i<n; i++) {
91      SirOutV.Add(y[i]+h6 * (dydx[i]+dyt[i]+2.0*dym[i]));
92    }
93  }
94  double TEpidemModel::GetErr(const TFltV& TrueV, const TFltV& SimV, const int& SimT0) { 
95    if (SimV.Empty() || TrueV.Empty()) { return -1.0; }
96    double Err = 0.0;
97    double S=0;
98    for (int t=0; t < TrueV.Len(); t++) {
99      if (t-SimT0 >= 0) { S = SimV[t-SimT0]; } else { S = 0; }
100      Err += TMath::Sqr(TrueV[t]-S);
101    }
102    if (Err <= 0) { Err = TFlt::Mx; }
103    return Err;
104  }
105  void TEpidemModel::Plot(const TFltV& TrueV, const TStr& Label1, const TFltV& SimV, const TStr& Label2, const TStr& OutFNm, const TStr& Desc, const TStr& XLabel, const TStr& YLabel) {
106    TGnuPlot GP(OutFNm, Desc);
107    GP.AddPlot(TrueV, gpwLinesPoints, Label1);
108    GP.AddPlot(SimV, gpwLinesPoints, Label2);
109    GP.SetXYLabel(XLabel, YLabel);
110    GP.SavePng();
111  }
112  void TEpidemModel::LoadTxt(const TStr& InFNm, const int& ColId, TFltV& ValV) {
113    ValV.Clr();
114    if (! TFile::Exists(InFNm)) { 
115      printf("*** %s not found!\n", InFNm.CStr());
116      return; 
117    }
118    TSsParser Ss(InFNm, ssfTabSep);
119    while (Ss.Next()) {
120      ValV.Add(Ss.GetFlt(ColId));
121    }
122  }
123  TSirModel::TSirModel(double NZero, TFltTr NZeroP, double IZero, TFltTr IZeroP, double _Beta, TFltTr BetaP, double _Gamma, TFltTr GammaP, int TZero, TFltTr TZeroP, TStr InFNm, int ColId) :
124   N0(NZero), I0(IZero), Beta(_Beta), Gamma(_Gamma), T0(TZero) { 
125    ParamMnMnRngV.Add(NZeroP);
126    ParamMnMnRngV.Add(IZeroP);
127    ParamMnMnRngV.Add(BetaP);
128    ParamMnMnRngV.Add(GammaP);
129    ParamMnMnRngV.Add(TZeroP);
130    TEpidemModel::LoadTxt(InFNm, ColId, TrueInfectV); 
131  }
132  void TSirModel::GetParam(TFltV& ParamV) const { 
133    ParamV.Clr(false); 
134    ParamV.Add(N0);
135    ParamV.Add(I0);
136    ParamV.Add(Beta); 
137    ParamV.Add(Gamma); 
138    ParamV.Add(T0);
139  }
140  void TSirModel::SetParam(const TFltV& ParamV) { 
141    N0 = ParamV[0];
142    I0 = ParamV[1];
143    Beta = ParamV[2]; 
144    Gamma = ParamV[3]; 
145    T0 = int(ParamV[4]); 
146  }
147  void TSirModel::SetPeakT0() {
148    double Max =0;
<span onclick='openModal()' class='match'>149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
151      if (TrueInfectV[i] > Max) { 
152        Max=TrueInfectV[i]; 
153        Peak=i;
154      }
155    }
</span>156    T0 = int(0.9*Peak);
157    ParamMnMnRngV[4].Val1 = Peak - 0.5*abs(Peak); 
158    ParamMnMnRngV[4].Val2 = Peak + 0.5*abs(Peak); 
159    printf("Set peak T0 = %d (%g -- %g)\n", Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2);
160  }
161  void TSirModel::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
162    dxdyV[0] = -Beta*SirValV[0]*SirValV[1];
163    dxdyV[1] = Beta*SirValV[0]*SirValV[1] - Gamma*SirValV[1];
164  }
165  double TSirModel::GetErr() const { 
166    return TEpidemModel::GetErr(TrueInfectV, OutValV[1], T0);
167  }
168  double TSirModel::RunCalcErr(const TFltV& ParamV) {
169    SetParam(ParamV);
170    const int EndT = TrueInfectV.Len() - T0 + 2;
171    RunModel(TFltV::GetV(N0-I0, I0), 0, EndT, EndT, OutValV);
172    return GetErr();
173  }
174  void TSirModel::GetParamRange(TFltTrV& ParamMnMxStepV) const {
175    ParamMnMxStepV = ParamMnMnRngV; 
176  }
177  void TSirModel::GetParamNmV(TStrV& ParamNmV) const {
178    ParamNmV = TStrV::GetV("Beta", "Gamma");
179  }
180  void TSirModel::Plot(const TStr& OutFNm, TStr Desc) const {
181    if (OutValV.Empty()) { printf("EMPTY()");  return; }
182    TFltV V2;
183    for (int t=0; t < TrueInfectV.Len(); t++) {
184      if (t-T0 >= 0) { V2.Add(OutValV[1][t-T0]); } else { V2.Add(0); }
185    }
186    TEpidemModel::Plot(TrueInfectV, "TRUE", V2, "SIR model", OutFNm, Desc+" "+GetStr(), "Time", "Number of infected nodes");
187  }
188  void TSirModel::TestEurlerVsRk() {
189  }
190  TSir2Model::TSir2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
191    int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, double _GammaB, TFltTr GammaBP, 
192    double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, TStr InFNm, int ColId1, int ColId2) : N0M(_N0M), I0M(_I0M), N0B(_N0B), I0B(_I0B), T0(_T0), BetaM(_BetaM), 
193    GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM) { 
194    ParamMnMnRngV.Add(N0MP);
195    ParamMnMnRngV.Add(I0MP);
196    ParamMnMnRngV.Add(N0BP);
197    ParamMnMnRngV.Add(I0BP);
198    ParamMnMnRngV.Add(T0P);
199    ParamMnMnRngV.Add(BetaMP);
200    ParamMnMnRngV.Add(GammaMP);
201    ParamMnMnRngV.Add(BetaBP);
202    ParamMnMnRngV.Add(GammaBP);
203    ParamMnMnRngV.Add(BetaMBP);
204    ParamMnMnRngV.Add(BetaBMP);
205    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
206      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
207      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
208    }
209  }
210  void TSir2Model::GetParam(TFltV& ParamV) const { 
211    ParamV.Clr(false); 
212    ParamV.Add(N0M);
213    ParamV.Add(I0M);
214    ParamV.Add(N0B);
215    ParamV.Add(I0B);
216    ParamV.Add(T0);
217    ParamV.Add(BetaM);
218    ParamV.Add(GammaM);
219    ParamV.Add(BetaB);
220    ParamV.Add(GammaB);
221    ParamV.Add(BetaMB);
222    ParamV.Add(BetaBM);
223  }
224  void TSir2Model::SetParam(const TFltV& ParamV) { 
225    N0M = ParamV[0];
226    I0M = ParamV[1];
227    N0B = ParamV[2];
228    I0B = ParamV[3];
229    T0 = (int) ParamV[4];
230    BetaM = ParamV[5];
231    GammaM = ParamV[6];
232    BetaB = ParamV[7];
233    GammaB = ParamV[8];
234    BetaMB = ParamV[9];
235    BetaBM = ParamV[10];
236  }
237  TStr TSir2Model::GetStr() const { 
238    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g Err: %.2f", 
239      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, GetErr()); 
240  }
241  void TSir2Model::SetPeakT0() {
242    double Max1=0, Max2=0;
243    int Peak1=0, Peak2=0;
244    for (int i = 0; i < MediaV.Len(); i++) {
245      if (MediaV[i] > Max1) { 
246        Max1 = MediaV[i]; Peak1 = i; }
247    }
248    for (int i = 0; i < BlogV.Len(); i++) {
249      if (BlogV[i] > Max2) { 
250        Max2 = BlogV[i]; Peak2 = i; }
251    }
252    int Peak = TMath::Mn(Peak1, Peak2);
253    T0 = int(0.9*Peak);
254    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
255    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
256    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
257      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
258  }
259  void TSir2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
260    IAssert(_MediaV.Len() == _BlogV.Len());
261    MediaV.Clr(false);  BlogV.Clr(false);
262    for (int i = 0; i < _MediaV.Len(); i++) {
263      MediaV.Add(_MediaV[i].Val2);
264      BlogV.Add(_BlogV[i].Val2);
265    }
266  }
267  void TSir2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
268    const TFlt& SM = SirValV[0];
269    const TFlt& SB = SirValV[1];
270    const TFlt& IM = SirValV[2];
271    const TFlt& IB = SirValV[3];
272    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM;
273    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB;
274    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
275    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
276  }
277  double TSir2Model::GetErr() const { 
278    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
279  }
280  double TSir2Model::RunCalcErr(const TFltV& ParamV) {
281    SetParam(ParamV);
282    const int EndT = BlogV.Len() - T0 + 2;
283    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
284    return GetErr();
285  }
286  void TSir2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
287    ParamMnMxStepV = ParamMnMnRngV; 
288  }
289  void TSir2Model::GetParamNmV(TStrV& ParamNmV) const {
290    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM").SplitOnAllCh(',', ParamNmV);
291  }
292  void TSir2Model::Plot(const TStr& OutFNm, TStr Desc) const {
293    if (OutValV.Empty()) { printf("EMPTY()");  return; }
294    TFltV MV, BV;
295    const TFltV& SMediaV = OutValV[2];
296    for (int t=0; t < MediaV.Len(); t++) {
297      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
298    }
299    const TFltV& SBlogV = OutValV[3];
300    for (int t=0; t < BlogV.Len(); t++) {
301      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
302    }
303    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
304    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
305    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
306    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
307    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
308    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
309    GP.SavePng();
310  }
311  TSirSR2Model::TSirSR2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
312   int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
313   double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, 
314   double _DeltaM, TFltTr DeltaMP, double _DeltaB, TFltTr DeltaBP, TStr InFNm, int ColId1, int ColId2) :  N0M(_N0M), I0M(_I0M), N0B(_N0B), 
315   I0B(_I0B), T0(_T0), BetaM(_BetaM), GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM),
316   DeltaM(_DeltaM), DeltaB(DeltaB) { 
317    ParamMnMnRngV.Add(N0MP);
318    ParamMnMnRngV.Add(I0MP);
319    ParamMnMnRngV.Add(N0BP);
320    ParamMnMnRngV.Add(I0BP);
321    ParamMnMnRngV.Add(T0P);
322    ParamMnMnRngV.Add(BetaMP);
323    ParamMnMnRngV.Add(GammaMP);
324    ParamMnMnRngV.Add(BetaBP);
325    ParamMnMnRngV.Add(GammaBP);
326    ParamMnMnRngV.Add(BetaMBP);
327    ParamMnMnRngV.Add(BetaBMP);
328    ParamMnMnRngV.Add(DeltaMP);
329    ParamMnMnRngV.Add(DeltaBP);
330    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
331      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
332      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
333    }
334  }
335  void TSirSR2Model::GetParam(TFltV& ParamV) const { 
336    ParamV.Clr(false); 
337    ParamV.Add(N0M);
338    ParamV.Add(I0M);
339    ParamV.Add(N0B);
340    ParamV.Add(I0B);
341    ParamV.Add(T0);
342    ParamV.Add(BetaM);
343    ParamV.Add(GammaM);
344    ParamV.Add(BetaB);
345    ParamV.Add(GammaB);
346    ParamV.Add(BetaMB);
347    ParamV.Add(BetaBM);
348    ParamV.Add(DeltaM);
349    ParamV.Add(DeltaB);
350  }
351  void TSirSR2Model::SetParam(const TFltV& ParamV) { 
352    N0M = ParamV[0];
353    I0M = ParamV[1];
354    N0B = ParamV[2];
355    I0B = ParamV[3];
356    T0 = (int) ParamV[4];
357    BetaM = ParamV[5];
358    GammaM = ParamV[6];
359    BetaB = ParamV[7];
360    GammaB = ParamV[8];
361    BetaMB = ParamV[9];
362    BetaBM = ParamV[10];
363    DeltaM = ParamV[11];
364    DeltaB = ParamV[12];
365  }
366  TStr TSirSR2Model::GetStr() const { 
367    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g  Delta:%g %g    ERR: %.2f", 
368      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, DeltaM, DeltaB, GetErr()); 
369  }
370  void TSirSR2Model::SetPeakT0() {
371    double Max1=0, Max2=0;
372    int Peak1=0, Peak2=0;
373    for (int i = 0; i < MediaV.Len(); i++) {
374      if (MediaV[i] > Max1) { 
375        Max1 = MediaV[i]; Peak1 = i; }
376    }
377    for (int i = 0; i < BlogV.Len(); i++) {
378      if (BlogV[i] > Max2) { 
379        Max2 = BlogV[i]; Peak2 = i; }
380    }
381    int Peak = TMath::Mn(Peak1, Peak2);
382    T0 = int(0.9*Peak);
383    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
384    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
385    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
386      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
387  }
388  void TSirSR2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
389    IAssert(_MediaV.Len() == _BlogV.Len());
390    MediaV.Clr(false);  BlogV.Clr(false);
391    for (int i = 0; i < _MediaV.Len(); i++) {
392      MediaV.Add(_MediaV[i].Val2);
393      BlogV.Add(_BlogV[i].Val2);
394    }
395  }
396  void TSirSR2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
397    const TFlt& SM = SirValV[0];
398    const TFlt& SB = SirValV[1];
399    const TFlt& IM = SirValV[2];
400    const TFlt& IB = SirValV[3];
401    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM - DeltaM*SM;
402    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB - DeltaB*SB;
403    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
404    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
405  }
406  double TSirSR2Model::GetErr() const { 
407    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
408  }
409  double TSirSR2Model::RunCalcErr(const TFltV& ParamV) {
410    SetParam(ParamV);
411    const int EndT = BlogV.Len() - T0 + 2;
412    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
413    return GetErr();
414  }
415  void TSirSR2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
416    ParamMnMxStepV = ParamMnMnRngV; 
417  }
418  void TSirSR2Model::GetParamNmV(TStrV& ParamNmV) const {
419    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM,DeltaM,DeltaB").SplitOnAllCh(',', ParamNmV);
420  }
421  void TSirSR2Model::Plot(const TStr& OutFNm, TStr Desc) const {
422    if (OutValV.Empty()) { printf("EMPTY()");  return; }
423    TFltV MV, BV;
424    const TFltV& SMediaV = OutValV[2];
425    for (int t=0; t < MediaV.Len(); t++) {
426      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
427    }
428    const TFltV& SBlogV = OutValV[3];
429    for (int t=0; t < BlogV.Len(); t++) {
430      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
431    }
432    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
433    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
434    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
435    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
436    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
437    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
438    GP.SavePng();
439  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ncp.cpp</h3>
            <pre><code>1   #include "stdafx.h"
2  #include "ncp.h"
3  bool TLocClust::Verbose = true;
4  int TLocClust::ApproxPageRank(const int& SeedNode, const double& Eps) {
5    for (int i = 0; i < ProbH.Len(); i++) { ProbH[i]=0.0; }
6    for (int i = 0; i < ResH.Len(); i++) { ResH[i]=0.0; }
7    ProbH.Clr(false, -1, false);
8    ResH.Clr(false, -1, false);
9    ResH.AddDat(SeedNode, 1.0);
10    int iter = 0;
11    double OldRes = 0.0;
12    NodeQ.Clr(false);
13    NodeQ.Push(SeedNode);
14    TExeTm ExeTm;
15    while (! NodeQ.Empty()) {
16      const int NId = NodeQ.Top(); NodeQ.Pop();
17      const TUNGraph::TNodeI& Node = Graph->GetNI(NId);
18      const int NIdDeg = Node.GetOutDeg();
19      const double PushVal = ResH.GetDat(NId) - 0.5*Eps*NIdDeg;
20      const double PutVal = (1.0-Alpha) * PushVal / double(NIdDeg);
21      ProbH.AddDat(NId) += Alpha*PushVal;
22      ResH.AddDat(NId) = 0.5 * Eps * NIdDeg;
23      for (int e = 0; e < NIdDeg; e++) {
24        const int DstNId = Node.GetOutNId(e);
25        const int DstDeg = Graph->GetNI(DstNId).GetOutDeg();
26        double& ResVal = ResH.AddDat(DstNId).Val;
27        OldRes = ResVal;
28        ResVal += PutVal;
29        if (ResVal >= Eps*DstDeg && OldRes < Eps*DstDeg) {
30          NodeQ.Push(DstNId); }
31      }
32      iter++;
33      if (iter % Mega(1) == 0) { 
34        printf(" %d[%s]", NodeQ.Len(), ExeTm.GetStr());
35        if (iter/1000 > Graph->GetNodes() || ExeTm.GetSecs() > 4*3600) { 
36          printf("Too many iterations! Stop to save time.\n");
37          return iter; }
38      }
39    }
40    return iter;
41  }
42  void TLocClust::SupportSweep() {
43    TExeTm ExeTm;
44    VolV.Clr(false);  CutV.Clr(false);  PhiV.Clr(false);
45    if (ProbH.Empty()) { return; }
46    const int TopNId = ProbH.GetKey(0);
47    const int TopNIdDeg = Graph->GetNI(TopNId).GetOutDeg();
48    int Vol = TopNIdDeg, Cut = TopNIdDeg;
49    double Phi = Cut/double(Vol);
50    VolV.Add(Vol);  CutV.Add(Cut);  PhiV.Add(1.0);
51    for (int i = 1; i < ProbH.Len(); i++) {
52      const int NId = ProbH.GetKey(i);
53      const TUNGraph::TNodeI& Node = Graph->GetNI(NId);
54      const int OutDeg = Node.GetOutDeg();
55      int CutSz = OutDeg; 
56      for (int e = 0; e < OutDeg; e++) {
57        const int Rank = ProbH.GetKeyId(Node.GetOutNId(e));
58        if ( Rank > -1 && Rank < i) { CutSz -= 2;  }
59      }
60      Vol += OutDeg;  Cut += CutSz;
61      if (Vol < Edges2) {
62        if (2*Vol > Edges2) { Phi = Cut / double(Edges2-Vol); }
63        else { Phi = Cut / double(Vol); }
64      } else {
65        Phi = 1.0;
66      }
67      IAssert((Phi+1e-6) >= double(1.0)/double(i*(i+1)+1)); 
68      VolV.Add(Vol);  CutV.Add(Cut);  PhiV.Add(Phi);
69    }}
70  void TLocClust::FindBestCut(const int& SeedNode, const int& ClustSz, const double& MinSizeFrac) {
71    double MaxPhi = TFlt::Mx;
72    BestCutIdx = -1;
73    SeedNId = SeedNode;
74    ApproxPageRank(SeedNId, 1.0/double(ClustSz));
75    for (int i = 0; i < ProbH.Len(); i++) {
76      ProbH[i] /= Graph->GetNI(ProbH.GetKey(i)).GetOutDeg(); }
77    ProbH.SortByDat(false);
78    SupportSweep();
79    NIdV.Clr(false);
80    for (int i = 0; i < PhiV.Len(); i++) {
81      const double Phi = PhiV[i];
82      NIdV.Add(ProbH.GetKey(i));
83      if (Phi < MaxPhi) { MaxPhi = Phi;  BestCutIdx = i; }
84    }
85  }
86  void TLocClust::PlotVolDistr(const TStr& OutFNm, TStr Desc) const {
87    TFltPrV RankValV(VolV.Len(), 0);
88    for (int i = 0; i < VolV.Len(); i++) {
89      RankValV.Add(TFltPr(i+1, VolV[i].Val)); }
90    if (Desc.Empty()) { Desc = OutFNm; }
91    TFltPrV NewV;  TLocClustStat::MakeExpBins(RankValV, NewV);
92    TGnuPlot GP(OutFNm+"-VOL", TStr::Fmt("VOLUME. Seed node %d.", SeedNId, Desc.CStr()));
93    GP.AddPlot(NewV, gpwLinesPoints, ""); 
94    GP.SetXYLabel("Rank", "Volume");
95    GP.SavePng();
96  }
97  void TLocClust::PlotCutDistr(const TStr& OutFNm, TStr Desc) const {
98    TFltPrV RankValV(CutV.Len(), 0);
99    for (int i = 0; i < CutV.Len(); i++) {
100      RankValV.Add(TFltPr(i+1, CutV[i].Val)); }
101    if (Desc.Empty()) { Desc = OutFNm; }
102    TFltPrV NewV;  TLocClustStat::MakeExpBins(RankValV, NewV);
103    TGnuPlot GP(OutFNm+"-CUT", TStr::Fmt("CUT SIZE. Seed node %d.", SeedNId, Desc.CStr()));
104    GP.AddPlot(NewV, gpwLinesPoints, ""); 
105    GP.SetXYLabel("Rank", "Cut size");
106    GP.SavePng();
107  }
108  void TLocClust::PlotPhiDistr(const TStr& OutFNm, TStr Desc) const {
109    TFltPrV RankValV(PhiV.Len(), 0);
110    for (int i = 0; i < PhiV.Len(); i++) {
111      RankValV.Add(TFltPr(i+1, PhiV[i])); }
112    if (Desc.Empty()) { Desc = OutFNm; }
113    TFltPrV NewV;  TLocClustStat::MakeExpBins(RankValV, NewV);
114    TGnuPlot GP(OutFNm+"-PHI", TStr::Fmt("CONDUCTANCE (Cut size / Volume). Seed node %d.", SeedNId, Desc.CStr()));
115    GP.AddPlot(NewV, gpwLinesPoints, ""); 
116    GP.SetXYLabel("Rank", "Conductance (Cut size / Volume)");
117    GP.SavePng();
118  }
119  void TLocClust::SavePajek(const TStr& OutFNm) const {
120    FILE *F = fopen(TStr::Fmt("%s.net", OutFNm.CStr()).CStr(), "wt");
121    TIntH NIdToIdH(Graph->GetNodes(), true);
122    TIntH ClustSet(BestCut()+1);
123    const int BucketSz = BestCutNodes()/ 4;
124    TStrV ClrV = TStrV::GetV("Black", "Gray80", "Gray60", "Gray40", "Gray20", "RedViolet");
125    for (int a = 0; a < BestCutNodes(); a++) {
126      ClustSet.AddDat(NIdV[a], (a+1)/BucketSz);
127    }
128    fprintf(F, "*Vertices %d\n", Graph->GetNodes());
129    int i = 0;
130    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
131      const int NId = NI.GetId();
132      if (NId == SeedNId) {
133        fprintf(F, "%d  \"%d\" diamond x_fact 2 y_fact 2 ic Green fos 10\n", i+1, NId); }
134      else if (ClustSet.IsKey(NId)) {
135        fprintf(F, "%d  \"%d\" box x_fact 2 y_fact 2 ic %s fos 10\n", i+1, NId, ClrV[ClustSet.GetDat(NId)].CStr()); }
136      else {
137        fprintf(F, "%d  \"%d\" ellipse x_fact 2 y_fact 2 ic Blue fos 10\n", i+1, NId); }
138      NIdToIdH.AddDat(NId, i+1);
139      i++;
140    }
141    fprintf(F, "*Arcs %d\n", Graph->GetEdges()); 
142    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
143      const int NId = NIdToIdH.GetDat(NI.GetId());
144      for (int e = 0; e < NI.GetOutDeg(); e++) {
145        fprintf(F, "%d %d %g c Tan\n", NId, NIdToIdH.GetDat(NI.GetOutNId(e)).Val, 1.0);
146      }
147    }
148    fclose(F);
149  }
150  void TLocClust::DrawWhiskers(const PUNGraph& Graph, TStr FNmPref, const int& PlotN=10) {
151    TCnComV CnComV;  TSnap::Get1CnCom(Graph, CnComV);
152    CnComV.Sort(false);
153    { TIntH SzCntH;
154    for (int i = 0; i < CnComV.Len(); i++) { SzCntH.AddDat(CnComV[i].Len()) += 1; }
155    TGnuPlot::PlotValCntH(SzCntH, "whiskSz."+FNmPref, TStr::Fmt("%s. G(%d, %d)", FNmPref.CStr(), Graph->GetNodes(),
156      Graph->GetEdges()), "Whisker size (Maximal component connected with a bridge edge)", "Count", gpsLog10XY, false); }
157    int BrNodeId = -1;
158    for (int c = 0; c < TMath::Mn(CnComV.Len(), PlotN); c++) {
159      const PUNGraph BrClust = TSnap::GetSubGraph(Graph, CnComV[c].NIdV);
160      for (TUNGraph::TNodeI NI = BrClust->BegNI(); NI < BrClust->EndNI(); NI++) {
161        if (NI.GetOutDeg() != Graph->GetNI(NI.GetId()).GetOutDeg()) { BrNodeId=NI.GetId(); break; } }
162      TIntStrH ClrH;  ClrH.AddDat(BrNodeId, "red");
163      TSnap::DrawGViz(BrClust, gvlNeato, TStr::Fmt("whisk-%s-%02d.gif", FNmPref.CStr(), c+1),
164        TStr::Fmt("Bridge node id: %d, n=%d, e=%d", BrNodeId, BrClust->GetNodes(), BrClust->GetEdges()), false, ClrH);
165    }
166  }
167  void TLocClust::GetCutStat(const PUNGraph& Graph, const TIntV& NIdV, int& Vol, int& Cut, double& Phi, int GraphEdges) {
168    TIntSet NIdSet(NIdV.Len());
169    for (int i = 0; i < NIdV.Len(); i++) { NIdSet.AddKey(NIdV[i]); }
170    GetCutStat(Graph, NIdSet, Vol, Cut, Phi, GraphEdges);
171  }
172  void TLocClust::GetCutStat(const PUNGraph& Graph, const TIntSet& NIdSet, int& Vol, int& Cut, double& Phi, int GraphEdges) {
173    const int Edges2 = GraphEdges>=0 ? 2*GraphEdges : Graph->GetEdges();
174    Vol=0;  Cut=0; Phi=0.0;
175    for (int i = 0; i < NIdSet.Len(); i++) {
176      if (! Graph->IsNode(NIdSet[i])) { continue; }
177      TUNGraph::TNodeI NI = Graph->GetNI(NIdSet[i]);
178      for (int e = 0; e < NI.GetOutDeg(); e++) {
179        if (! NIdSet.IsKey(NI.GetOutNId(e))) { Cut += 1; }
180      }
181      Vol += NI.GetOutDeg();
182    }
183    if (Vol != Edges2) {
184      if (2*Vol > Edges2) { Phi = Cut / double(Edges2-Vol); }
185      else if (Vol == 0) { Phi = 0.0; }
186      else { Phi = Cut / double(Vol); }
187    } else {
188      if (Vol == Edges2) { Phi = 1.0; }
189    }
190  }
191  void TLocClust::PlotNCP(const PUNGraph& Graph, const TStr& FNm, const TStr Desc, const bool& BagOfWhiskers, const bool& RewireNet, const int& KMin, const int& KMax, const int& Coverage, const bool& SaveTxtStat, const bool& PlotBoltzman) {
192    const double Alpha = 0.001, KFac = 1.5, SizeFrac = 0.001;
193    TLocClustStat ClusStat1(Alpha, KMin, KMax, KFac, Coverage, SizeFrac);
194    ClusStat1.Run(Graph, false, PlotBoltzman, SaveTxtStat);
195    if (BagOfWhiskers) { ClusStat1.AddBagOfWhiskers(); }
196    TLocClustStat ClusStat2(Alpha, KMin, KMax, KFac, Coverage, SizeFrac);
197    ClusStat1.ImposeNCP(ClusStat2, FNm, Desc, "ORIGINAL", "REWIRED"); 
198    if (SaveTxtStat) { 
199      ClusStat1.SaveTxtInfo(FNm, Desc, false);
200    }
201    if (PlotBoltzman) {
202      ClusStat1.PlotBoltzmanCurve(FNm, Desc);
203    }
204    if (RewireNet) {
205      ClusStat2.Run(TSnap::GenRewire(Graph, 50, TInt::Rnd), false, false, false);
206      if (BagOfWhiskers) { ClusStat2.AddBagOfWhiskers(); }
207      ClusStat1.ImposeNCP(ClusStat2, FNm, Desc, "ORIGINAL", "REWIRED"); 
208    }
209  }
210  double TLocClustStat::BinFactor = 1.01;
211  double TLocClustStat::TCutInfo::GetFracDegOut(const PUNGraph& Graph, double& MxFrac, double& AvgFrac, double& MedianFrac, double& Pct9Frac, double& Flake) const {
212    if (CutNIdV.Empty()) {
213      IAssert(Nodes<100 || ! CutNIdV.Empty());
214      MxFrac=1; AvgFrac=1; MedianFrac=1; Pct9Frac=1; Flake=1; 
215      return 1;
216    }
217    TMom FracDegMom;
218    TIntSet InNIdSet(CutNIdV.Len());
219    int NHalfIn=0;
220    for (int i = 0; i < CutNIdV.Len(); i++) { 
221      InNIdSet.AddKey(CutNIdV[i]); }
222    for (int n = 0; n < CutNIdV.Len(); n++) {
223      const TUNGraph::TNodeI NI = Graph->GetNI(CutNIdV[n]);
224      int EdgesOut = 0;
225      for (int i = 0; i < NI.GetDeg(); i++) {
226        if (! InNIdSet.IsKey(NI.GetNbrNId(i))) { EdgesOut++; }
227      }
228      const double FracOut = EdgesOut/double(NI.GetDeg());
229      if (FracOut <= 0.5) { NHalfIn++; }
230      FracDegMom.Add(FracOut);
231    }
232    FracDegMom.Def();
233    MxFrac = FracDegMom.GetMx();
234    AvgFrac = FracDegMom.GetMean();
235    MedianFrac = FracDegMom.GetMedian();
236    Pct9Frac = FracDegMom.GetDecile(9);
237    Flake = 1.0 - double(NHalfIn)/double(CutNIdV.Len());
238    return MxFrac;
239  }
240  TLocClustStat::TLocClustStat(const double& _Alpha, const int& _KMin, const int& _KMax, const double& _KFac,
241    const int& _Coverage, const double& _SizeFrac) : Alpha(_Alpha), SizeFrac(_SizeFrac), KFac(_KFac),
242    KMin(_KMin), KMax(_KMax), Coverage(_Coverage) {
243  }
244  void TLocClustStat::Save(TSOut& SOut) const {
245    Alpha.Save(SOut);
246    SizeFrac.Save(SOut);
247    KFac.Save(SOut);
248    KMin.Save(SOut);
249    KMax.Save(SOut);
250    Coverage.Save(SOut);
251  }
252  void TLocClustStat::Clr() {
253    SweepsV.Clr(false);      
254    SizePhiH.Clr(false);     
255    BestCutH.Clr(false);     
256    BagOfWhiskerV.Clr(false); 
257  }
258  void TLocClustStat::Run(const PUNGraph& _Graph, const bool& SaveAllSweeps, const bool& SaveAllCond, const bool& SaveBestNodesAtK) {
259    Graph = TSnap::GetMxWcc(_Graph);
260    const int Nodes = Graph->GetNodes();
261    const int Edges = Graph->GetEdges();
262    printf("\nLocal clustering: Graph(%d, %d)\n", Nodes, Edges);
263    printf("  Alpha:    %g\n", Alpha());
264    printf("  K: %d -- %g -- %dm\n", KMin(), KFac(), int(KMax/Mega(1)));
265    printf("  Coverage: %d\n", Coverage());
266    printf("  SizeFrac: %g\n\n", SizeFrac());
267    TExeTm TotTm;
268    Clr();
269    TLocClust Clust(Graph, Alpha);
270    BestCut.CutNIdV.Clr(false); 
271    BestCut.CutSz=-1;  BestCut.Edges=-1;
272    double BestPhi = TFlt::Mx;
273    int prevK=-1;
274    bool NextDone=false;
275    if (SaveBestNodesAtK) { 
276      SizeBucketSet.Clr();
277      double PrevBPos = 1, BPos = 1;
278      while (BPos <= Mega(100)) {
279        PrevBPos = (uint) floor(BPos);
280        BPos *= BinFactor;
281        if (floor(BPos) == PrevBPos) { BPos = PrevBPos + 1; }
282        SizeBucketSet.AddKey(int(floor(BPos) - 1));
283      }
284    }
285    for (int K = KMin, cnt=1; K < KMax; K = int(KFac * double(K))+1, cnt++) {
286      if (K == prevK) { K++; } prevK = K;
287      const int Runs = 2 + int(Coverage &bsol;**pow(1.1, cnt)*/ * floor(double(Graph->GetEdges()) / double(K)));
288      printf("%d] K: %d, %d runs\n", cnt+1, K, Runs);
289      if (NextDone) { break; } 
290      if (K+1 > 2*Graph->GetEdges()) { K = Graph->GetEdges(); NextDone=true; }
291      TExeTm ExeTm, IterTm;
292      double MeanSz=0.0, MeanVol=0.0, Count=0.0;
293      for (int run = 0; run < Runs; run++) {
294        const int SeedNId = Graph->GetRndNId();  IterTm.Tick();
295        Clust.FindBestCut(SeedNId, K, SizeFrac);
296        const int Sz = Clust.BestCutNodes();
297        const int Vol = Clust.GetCutVol();
298        const double Phi = TMath::Round(Clust.GetCutPhi(), 4);
299        if (Sz == 0 || Vol == 0 || Phi == 0) { continue; }
300        MeanSz+=Sz;  MeanVol+=Vol;  Count+= 1;
301        if (SaveAllSweeps) { 
302          SweepsV.Add(TNodeSweep(SeedNId, Clust.GetNIdV(), Clust.GetPhiV())); }
303        int SAtBestPhi=-1;
304        for (int s = 0; s < Clust.Len(); s++) {
305          const int size = s+1;
306          const int cut = Clust.GetCut(s);
307          const int edges = (Clust.GetVol(s)-cut)/2;
308          const double phi = Clust.GetPhi(s);
309          if (( Clust.GetPhi(s) != double(cut)/double(2*edges+cut))) { continue; } 
310          IAssert((Clust.GetVol(s) - cut) % 2 == 0);
311          IAssert(phi == double(cut)/double(2*edges+cut));
312          IAssert(phi >= 1.0/double((1+s)*s+1));
313          if (BestPhi >= phi) {
314            BestPhi = phi;
315            BestCut = TCutInfo(size, edges, cut);
316            SAtBestPhi = s;
317          }
318          if (! BestCutH.IsKey(size) || BestCutH.GetDat(size).GetPhi() >= phi) { 
319            BestCutH.AddDat(size, TCutInfo(size, edges, cut));  
320            if (SaveBestNodesAtK) { 
321              if (! SizeBucketSet.Empty() && ! SizeBucketSet.IsKey(size)) { continue; } 
322              Clust.GetNIdV().GetSubValV(0, size-1, BestCutH.GetDat(size).CutNIdV); }
323          }
324          if (SaveAllCond) { 
325            SizePhiH.AddDat(size).Add(phi); }
326        }
327        if (SAtBestPhi != -1) { 
328          const int size = SAtBestPhi+1;
329          Clust.GetNIdV().GetSubValV(0, size-1, BestCut.CutNIdV); 
330        }
331        if (TLocClust::Verbose) {
332          printf(".");
333          if (run % 50 == 0) {
334            printf("\r                                                   %d / %d \r", run, Runs); }
335        }
336      }
337      if (TLocClust::Verbose) {
338        printf("\r  %d / %d: %s                                                   \n", Runs, Runs, ExeTm.GetStr()); 
339      }
340      MeanSz/=Count;  MeanVol/=Count;
341      printf("  Graph(%d, %d)  ", Nodes, Edges);
342      printf("       mean:  sz: %.2f  vol: %.2f [%s] %s\n", MeanSz, MeanVol, ExeTm.GetStr(), TExeTm::GetCurTm());
343    }
344    SizePhiH.SortByKey();
345    for (int k = 0; k < SizePhiH.Len(); k++) { 
346      SizePhiH[k].Sort(); }
347    SweepsV.Sort();
348    BestCutH.SortByKey();
349    printf("DONE. Graph(%d, %d): Total run time: %s\n\n", Nodes, Edges, TotTm.GetStr());
350  }
351  void TLocClustStat::AddBagOfWhiskers() {
352    BagOfWhiskers(Graph, BagOfWhiskerV, BestWhisk); 
353  }
354  void TLocClustStat::AddCut(const TIntV& NIdV) {
355    int Vol, Cut; double Phi;
356    TLocClust::GetCutStat(Graph, NIdV, Vol, Cut, Phi, Graph->GetEdges());
357    SizePhiH.AddDat(NIdV.Len()).Add(Phi);
358  }
359  void TLocClustStat::AddCut(const int& ClustSz, const double& Phi) {
360    SizePhiH.AddDat(ClustSz).Add(Phi);
361  }
362  void TLocClustStat::AddToBestCutH(const PUNGraph& Graph, const TIntV& NIdV, const bool& AddBestCond) {
363    const int K = NIdV.Len();
364    TCutInfo CutInfo(Graph, NIdV, true);
365    printf("new: %d\t%d\t%d\t%f\t%f\n", CutInfo.GetNodes(), CutInfo.GetEdges(), 
366      CutInfo.GetCutSz(), CutInfo.GetPhi(), CutInfo.GetModular(Graph->GetEdges()));
367    if (! BestCutH.IsKey(K)) { BestCutH.AddDat(K, CutInfo);  return; }
368    TCutInfo& CurCut = BestCutH.GetDat(K);
369    if (AddBestCond && CurCut.GetPhi() > CutInfo.GetPhi()) { CurCut=CutInfo; }
370  }
371  const TLocClustStat::TCutInfo& TLocClustStat::FindBestCut(const int& Nodes) const {
372    double bestPhi = 1;
373    int CutId = -1;
374    if (Nodes > 0) {
375      IAssert(BestCutH.IsKey(Nodes));
376      return BestCutH.GetDat(Nodes);
377    } else {
378      for (int n = 0; n < BestCutH.Len(); n++) {
379        if (BestCutH[n].GetPhi() <= bestPhi) {
380          bestPhi = BestCutH[n].GetPhi();  CutId = n; }
381      }
382      IAssert(CutId != -1);
383      IAssert(! BestCutH[CutId].CutNIdV.Empty());
384      return BestCutH[CutId];
385    }
386  }
387  double TLocClustStat::FindBestCut(const int& Nodes, TIntV& ClustNIdV) const {
388    const TCutInfo& Cut = FindBestCut(Nodes);
389    ClustNIdV = Cut.CutNIdV;
390    return Cut.GetPhi();
391  }
392  int TLocClustStat::FindBestCut(const int& Nodes, int& Vol, int& Cut, double& Phi) const {
393    const TCutInfo& CutInfo = FindBestCut(Nodes);
394    Vol = CutInfo.GetVol();
395    Cut = CutInfo.GetCutSz();
396    Phi = CutInfo.GetPhi();
397    return CutInfo.GetNodes();
398  }
399  double TLocClustStat::FindBestCut(const int& Nodes, const TIntSet& TabuNIdSet, int& BestCutId) const {
400    double bestPhi = 1;
401    BestCutId = -1;
402    bool Tabu;
403    IAssert(! SweepsV.Empty());
404    for (int c = 0; c < SweepsV.Len(); c++) {
405      const TNodeSweep& Sweep = SweepsV[c];
406      if (Sweep.Len() < Nodes) { continue; }
407      if (Sweep.Phi(Nodes-1) > bestPhi) { continue; }
408      Tabu = false;
409      for (int i = 0; i < Nodes; i++) {
410        if (TabuNIdSet.IsKey(Sweep.NId(i))) { Tabu=true; break; }
411      }
412      if (Tabu) { continue; }
413      bestPhi = Sweep.Phi(Nodes-1);
414      BestCutId = c;
415    }
416    return bestPhi;
417  }
418  void TLocClustStat::GetCurveStat(TFltPrV& MeanV, TFltPrV& MedV, TFltPrV& Dec1V, TFltPrV& MinV, TFltPrV& MaxV) const {
419    TFltPrV BucketV;
420    MeanV.Clr(false); MedV.Clr(false); Dec1V.Clr(false); MinV.Clr(false); MaxV.Clr(false);
421    if (! SizePhiH.Empty()) { 
422      const THash<TInt, TFltV>& KvH = SizePhiH; 
423      for (int i = 0; i < KvH.Len(); i++) {
424        const double X = KvH.GetKey(i).Val;  IAssert(X >= 1.0);
425        const TFltV& YVec = KvH[i];
426        TMom Mom;
427        for (int j = 0; j < YVec.Len(); j++) { Mom.Add(YVec[j]); }
428        Mom.Def();
429        MeanV.Add(TFltPr(X, Mom.GetMean()));
430        MedV.Add(TFltPr(X, Mom.GetMedian()));
431        Dec1V.Add(TFltPr(X, Mom.GetDecile(1)));
432        MinV.Add(TFltPr(X, Mom.GetMn()));
433        MaxV.Add(TFltPr(X, Mom.GetMx()));
434      }
435      MeanV.Sort(); MedV.Sort();  Dec1V.Sort();  MinV.Sort();  MaxV.Sort();
436      TLocClustStat::MakeExpBins(MeanV, BucketV);  MeanV.Swap(BucketV);
437      TLocClustStat::MakeExpBins(MedV, BucketV);  MedV.Swap(BucketV);
438      TLocClustStat::MakeExpBins(Dec1V, BucketV);  Dec1V.Swap(BucketV);
439      TLocClustStat::MakeExpBins(MinV, BucketV);  MinV.Swap(BucketV);
440      TLocClustStat::MakeExpBins(MaxV, BucketV);  MaxV.Swap(BucketV);
441    } else {
442      for (int i = 0; i < BestCutH.Len(); i++) {
443        MinV.Add(TFltPr(BestCutH.GetKey(i).Val, BestCutH[i].GetPhi()));
444      }
445      MinV.Sort();
446      TLocClustStat::MakeExpBins(MinV, BucketV);  MinV.Swap(BucketV);
447    }
448  }
449  void TLocClustStat::GetBoltzmanCurveStat(const TFltV& TempV, TVec<TFltPrV>& NcpV) const {
450    IAssert(! SizePhiH.Empty()); 
451    NcpV.Gen(TempV.Len());
452    TFltPrV BucketV;
453    for (int t = 0; t < TempV.Len(); t++) {
454      const double T = TempV[t];
455      for (int i = 0; i < SizePhiH.Len(); i++) {
456        const double X = SizePhiH.GetKey(i).Val;  IAssert(X >= 1.0);
457        const TFltV& PhiV = SizePhiH[i];
458        double V = 0.0, SumW = 0.0;
459        for (int j = 0; j < PhiV.Len(); j++) { 
460          V += PhiV[j] * exp(-PhiV[j]/T); 
461          SumW += exp(-PhiV[j]/T); 
462        }
463        V /= SumW;
464        NcpV[t].Add(TFltPr(X, V));
465      }
466      TLocClustStat::MakeExpBins(NcpV[t], BucketV);  NcpV[t].Swap(BucketV);
467    }
468  }
469  TStr TLocClustStat::ParamStr() const {
470    if (Graph.Empty()) {
471      return TStr::Fmt("A=%g, K=%d-%g-%s, Cvr=%d, SzFrc=%g", Alpha(), KMin(), KFac(), TInt::GetMegaStr(KMax()).CStr(), Coverage(), SizeFrac()); }
472    else {
473      return TStr::Fmt("A=%g, K=%d-%g-%s, Cvr=%d, SzFrc=%g G(%d, %d)", Alpha(), KMin(), KFac(), TInt::GetMegaStr(KMax()).CStr(), Coverage(), SizeFrac(),
474        Graph->GetNodes(), Graph->GetEdges());
475    }
476  }
477  void TLocClustStat::PlotNCP(const TStr& OutFNm, TStr Desc) const {
478    if (Desc.Empty()) { Desc = OutFNm; }
479    TFltPrV MeanV, MedV, Dec1V, MinV, MaxV;
480    GetCurveStat(MeanV, MedV, Dec1V, MinV, MaxV);
481    TGnuPlot GP("ncp."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
482    if (! MaxV.Empty()) { GP.AddPlot((MaxV), gpwLines, "MAX"); }
483    if (! MedV.Empty()) { GP.AddPlot((MedV), gpwLines, "MEDIAN"); }
484    if (! MeanV.Empty()) { GP.AddPlot((MeanV), gpwLines, "MEAN"); }
485    if (! Dec1V.Empty()) { GP.AddPlot((Dec1V), gpwLines, "1-st DECILE"); }
486    if (! MinV.Empty()) { 
487      GP.AddPlot((MinV), gpwLines, "MIN"); 
488    }
489    if (! BagOfWhiskerV.Empty()) {
490      GP.AddPlot(BagOfWhiskerV, gpwLines, "Whiskers", "lw 1"); 
491      TFltPrV BestWhiskV;  BestWhiskV.Add(TFltPr(BestWhisk));
492      GP.AddPlot(BestWhiskV, gpwPoints, "Best whisker", "pt 5 ps 2");
493    }
494    GP.SetScale(gpsLog10XY);
495    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
496    GP.SetXRange(1, Graph->GetNodes()/2);
497    GP.SavePng();
498  }
499  void TLocClustStat::PlotNCPModul(const TStr& OutFNm, TStr Desc) const {
500    if (Desc.Empty()) { Desc = OutFNm; }
501    TFltPrV MinV, BucketV;
502    const int GEdges = Graph->GetEdges();
503    for (int i = 0; i < BestCutH.Len(); i++) {
504      MinV.Add(TFltPr(BestCutH.GetKey(i).Val, BestCutH[i].GetModular(GEdges))); }
505    MinV.Sort();
506    TLocClustStat::MakeExpBins(MinV, BucketV);  MinV.Swap(BucketV);
507    TGnuPlot GP("ncpMod."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
508    if (! MinV.Empty()) { 
509      GP.AddPlot((MinV), gpwLines, "MIN"); }
510    GP.SetScale(gpsLog10XY);
511    GP.SetXYLabel("k (number of nodes in the cluster)", "Q (modularity)");
512    GP.SetXRange(1, Graph->GetNodes()/2);
513    GP.SavePng();
514  }
515  void TLocClustStat::PlotNcpTop10(const TStr& OutFNm, TStr Desc, const int& TakeMinN) const {
516    if (Desc.Empty()) { Desc = OutFNm; }
517    const double BinFactor = 1.05;
518    double BinPos=1;
519    int PrevBPos=1, CurBPos=1, CutId;
520    bool AddSome;
521    TVec<TFltPrV> Curves(TakeMinN);
522    while (true) {
523      PrevBPos = CurBPos;
524      BinPos *= BinFactor; 
525      CurBPos = (int) floor(BinPos);
526      if (CurBPos == PrevBPos) { CurBPos=PrevBPos+1;  BinPos=CurBPos; }
527      const int Nodes = CurBPos;
528      TIntSet TabuNIdSet(Graph->GetNodes());
529      AddSome = false;
530      for (int t = 0; t < TakeMinN; t++) {
531        const double Phi = FindBestCut(Nodes, TabuNIdSet, CutId);
532        if (CutId == -1) { break; }
533        Curves[t].Add(TFltPr(Nodes, Phi));
534        for (int n = 0; n < Nodes; n++) {
535          TabuNIdSet.AddKey(SweepsV[CutId].NId(n)); }
536        AddSome = true;
537      }
538      if (! AddSome) { break; }
539    }
540    TGnuPlot GP("ncpTop."+OutFNm, TStr::Fmt("%s. Top disjoint clusters. Take:%d, %s", Desc.CStr(), TakeMinN, ParamStr().CStr()));
541    for (int i = 0; i < Curves.Len(); i++) {
542      GP.AddPlot(Curves[i], gpwLines, TStr::Fmt("MIN %d", i+1), "lw 1"); }
543    GP.SetScale(gpsLog10XY);
544    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
545    GP.SetXRange(1, Graph->GetNodes()/2);
546    GP.SavePng();
547  }
548  void TLocClustStat::PlotPhiInOut(const TStr& OutFNm, TStr Desc) const {
549    IAssert(! BestCutH.Empty() && ! Graph.Empty());
550    TFltPrV PhiInV, PhiBoundV, PhiRatV;
551    FILE *F = fopen(TStr::Fmt("phiInOut.%s-all.tab", OutFNm.CStr()).CStr(), "wt");
552    fprintf(F, "#Nodes\tEdges\tVol\tCut\tPhi\tInNodes\tInEdges\tInVol\tInCut\tInPhi\n");
553    TLocClustStat ClustStat2(Alpha, 1, KMax, KFac, Coverage, SizeFrac);
554    const double IdxFact = 1.05;
555    int curIdx=1, prevIdx=1;
556    while (curIdx <= BestCutH.Len()) {
557      const TCutInfo& CutInfo = BestCutH[curIdx-1];
558      if (CutInfo.GetNodes() > 1) {
559        PUNGraph ClustG = TSnap::GetSubGraph(Graph, CutInfo.CutNIdV);
560        ClustStat2.Run(ClustG);
561        const TCutInfo& InCut = ClustStat2.FindBestCut(-1);
562        PhiInV.Add(TFltPr(CutInfo.GetNodes(), InCut.GetPhi()));
563        PhiBoundV.Add(TFltPr(CutInfo.GetNodes(), CutInfo.GetPhi()));
564        PhiRatV.Add(TFltPr(CutInfo.GetNodes(), InCut.GetPhi()/CutInfo.GetPhi()));
565        fprintf(F, "%d\t%d\t%d\t%d\t%f\t%d\t%d\t%d\t%d\t%f\n", CutInfo.GetNodes(), CutInfo.GetEdges(), CutInfo.GetVol(),
566          CutInfo.GetCutSz(), CutInfo.GetPhi(),  InCut.GetNodes(), InCut.GetEdges(), InCut.GetVol(), InCut.GetCutSz(), InCut.GetPhi());
567        fflush(F);
568      }
569      prevIdx = curIdx;
570      curIdx = (int) TMath::Round(double(curIdx)*IdxFact);
571      if (prevIdx == curIdx) { curIdx++; }
572    }
573    fclose(F);
574    { TGnuPlot GP("phiInOut."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
575    GP.AddPlot(PhiBoundV, gpwLines, "CUT conductance", "lw 1");
576    GP.AddPlot(PhiInV, gpwLines, "INSIDE conductance", "lw 1");
577    GP.SetXRange(1, Graph->GetNodes()/2);  GP.SetScale(gpsLog10XY);
578    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
579    GP.SavePng(); }
580    { TGnuPlot GP("phiInOutRat."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
581    GP.AddPlot(PhiRatV, gpwLines, "RATIO (Inside / Boundary)", "lw 1");
582    GP.SetXRange(1, Graph->GetNodes()/2);  GP.SetScale(gpsLog10XY);
583    GP.SetXYLabel("Nodes", "Conductance ratio (inside/boundary) -- higher better");
584    GP.SavePng(); }
585  }
586  void TLocClustStat::PlotBestClustDens(TStr OutFNm, TStr Desc) const {
587    if (Desc.Empty()) { Desc = OutFNm; }
588    const int len = BestCutH.Len();
589    TFltPrV CutV(len, 0), EdgesV(len, 0), PhiV(len,0);
590    for (int i = 0; i < BestCutH.Len(); i++) {
591      const double size = BestCutH.GetKey(i).Val;
592      CutV.Add(TFltPr(size, BestCutH[i].GetCutSz()));
593      EdgesV.Add(TFltPr(size, BestCutH[i].GetEdges()));
594      PhiV.Add(TFltPr(size, BestCutH[i].GetPhi()));
595    }
596    TGnuPlot GP("cutEdges."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
597    TFltPrV NewV;  TLocClustStat::MakeExpBins(EdgesV, NewV);
598    GP.AddPlot(NewV, gpwLines, "Edges inside");
599    TLocClustStat::MakeExpBins(CutV, NewV);
600    GP.AddPlot(NewV, gpwLines, "Cut edges");
601    TLocClustStat::MakeExpBins(PhiV, NewV);
602    GP.AddPlot(NewV, gpwLines, "Conductance");
603    GP.SetXYLabel("Cluster size", "Edges"); GP.SetScale(gpsLog10XY);
604    GP.AddCmd("set logscale xyy2 10");
605    GP.AddCmd("set y2label \"Conductance\"");
606    GP.SavePng();
607    system(TStr(TStr("replace_all.py cutEdges.")+OutFNm+".plt \"title \\\"Conductance\" \"axis x1y2 title \\\"Conductance\"").CStr());
608    GP.RunGnuPlot();
609  }
610  void TLocClustStat::PlotNCPScatter(const TStr& OutFNm, TStr Desc) const {
611    if (Desc.Empty()) { Desc = OutFNm; }
612    THashSet<TFltPr> PhiSzH;
613    IAssertR(! SizePhiH.Empty(), "Set SaveAllCond=true in TLocClustStat::Run()");
614    for (int k = 0; k < SizePhiH.Len(); k++) {
615      const int K = SizePhiH.GetKey(k);
616      const TFltV& PhiV = SizePhiH[k];
617      for (int p = 0; p < PhiV.Len(); p++) {
618        PhiSzH.AddKey(TFltPr(K, TMath::Round(PhiV[p], 3))); }
619    }
620    TFltPrV PhiSzV;  PhiSzH.GetKeyV(PhiSzV);
621    TGnuPlot GP("ncpScatter."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
622    GP.AddPlot(PhiSzV, gpwPoints, "", "pt 5 ps 0.2");
623    GP.SetScale(gpsLog10XY);
624    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
625    GP.SetXRange(1, Graph->GetNodes()/2);
626    GP.SavePng();
627  }
628  void TLocClustStat::PlotPhiDistr(const int& CmtySz, const TStr& OutFNm, TStr Desc) const {
629    IAssert(! SizePhiH.Empty());
630    const TFltV& PhiV = SizePhiH.GetDat(CmtySz);
631    THash<TFlt, TInt> PhiCntH;
632    for (int i = 0; i < PhiV.Len(); i++) {
633      const double Buck =  TMath::Round(PhiV[i], 3);
634      PhiCntH.AddDat(Buck) += 1;
635    }
636    TGnuPlot::PlotValCntH(PhiCntH, TStr::Fmt("phiDistr%03d.%s", CmtySz, OutFNm.CStr()), 
637      TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()), "{/Symbol \\F} (conductance)",  "Count");
638  }
639  void TLocClustStat::PlotBoltzmanCurve(const TStr& OutFNm, TStr Desc) const {
640    TFltPrV MeanV1, MedV1, Dec1V1, MinV1, MaxV1;
641    GetCurveStat(MeanV1, MedV1, Dec1V1, MinV1, MaxV1);
642    TVec<TFltPrV> NcpV;
643    const TFltV TempV = TFltV::GetV(0.001, 0.005, 0.01, 0.02, 0.05, 0.1, 0.5, 1);
644    GetBoltzmanCurveStat(TempV, NcpV);
645    TGnuPlot GP("ncp."+OutFNm+"-B", TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));  
646    GP.AddPlot(MinV1, gpwLines, TStr::Fmt("%s MIN (%d, %d)", Desc.CStr(), Graph->GetNodes(), Graph->GetEdges()), "lw 1");
647    GP.AddPlot(MeanV1, gpwLines, "Avg", "lw 1");
648    GP.AddPlot(MedV1, gpwLines, "Median", "lw 1");
649    GP.AddPlot(Dec1V1, gpwLines, "Decile-1", "lw 1");
650    for (int t = 0; t < TempV.Len(); t++) {
651      GP.AddPlot(NcpV[t], gpwLines, TStr::Fmt("Temp %g", TempV[t]()), "lw 1");
652    }
653    GP.SetScale(gpsLog10XY);
654    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
655    GP.SavePng();
656    TFltPrV SzNClustV;
657    int kCnt=1;
658    for (int i = 0; i < SizePhiH.Len(); i++) {
659      const int K = SizePhiH.GetKey(i);
660      const TFltV& PhiV = SizePhiH[i];
661      SzNClustV.Add(TFltPr(K, PhiV.Len()));
662      if (K>2 && (pow(10.0, (int)log10((double)K))==K || (K >=10 && K<=100 && K%10==0) || (K >=100 && K<=1000 && K%100==0))) {
663        THash<TFlt, TFlt> CntH;
664        for (int p = 0; p < PhiV.Len(); p++) {
665          CntH.AddDat(TMath::Round(log10(PhiV[p].Val),1)) += 1;
666        }
667        TGnuPlot::PlotValCntH(CntH, TStr::Fmt("ncp.%s-c%02d", OutFNm.CStr(), kCnt++), TStr::Fmt("%s. K=%d, NPieces=%d, %s", 
668          Desc.CStr(), K, PhiV.Len(), ParamStr().CStr()), "log_10 {/Symbol \\F} (conductance)", 
669          TStr::Fmt("Number of pieces of such conductance, K=%d, NPieces=%d)", K, PhiV.Len()));
670      }
671    }
672    TGnuPlot::PlotValV(SzNClustV, "ncp."+OutFNm+"-ClSz", TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()),
673      "k (cluster size)", "c(k) (number of extracted clusters)", gpsLog);
674  }
675  void TLocClustStat::ImposeNCP(const TLocClustStat& LcStat2, TStr OutFNm, TStr Desc, TStr Desc1, TStr Desc2) const {
676    if (Desc.Empty()) { Desc = OutFNm; }
677    TFltPrV MeanV1, MedV1, Dec1V1, MinV1, MaxV1;
678    TFltPrV MeanV2, MedV2, Dec1V2, MinV2, MaxV2;
679    GetCurveStat(MeanV1, MedV1, Dec1V1, MinV1, MaxV1);
680    LcStat2.GetCurveStat(MeanV2, MedV2, Dec1V2, MinV2, MaxV2);
681    TGnuPlot GP("ncp."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
682    if (! MinV1.Empty()) { GP.AddPlot(MinV1, gpwLines, TStr::Fmt("%s MIN (%d, %d)", Desc1.CStr(), Graph->GetNodes(), Graph->GetEdges()), "lw 1"); }
683    if (! MinV2.Empty()) { GP.AddPlot(MinV2, gpwLines, TStr::Fmt("%s MIN (%d, %d)", Desc2.CStr(), LcStat2.Graph->GetNodes(), LcStat2.Graph->GetEdges()), "lw 1"); }
684    if (! BagOfWhiskerV.Empty()) { 
685      GP.AddPlot(BagOfWhiskerV, gpwLines, Desc1+" whiskers", "lw 1"); 
686      TFltPrV BestWhiskV;  BestWhiskV.Add(BestWhisk);
687      GP.AddPlot(BestWhiskV, gpwPoints, Desc1+" Best whisker", "pt 5 ps 2"); }
688    if (! LcStat2.BagOfWhiskerV.Empty()) {
689      GP.AddPlot(LcStat2.BagOfWhiskerV, gpwLines, Desc2+" whiskers", "lw 1"); 
690      TFltPrV BestWhiskV;  BestWhiskV.Add(LcStat2.BestWhisk);
691      GP.AddPlot(BestWhiskV, gpwPoints, Desc2+" Best whisker", "pt 5 ps 2"); }
692    GP.SetScale(gpsLog10XY);
693    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
694    GP.SavePng();
695  }
696  void TLocClustStat::ImposeNCP(const TLocClustStat& LcStat2, const TLocClustStat& LcStat3, TStr OutFNm, TStr Desc, TStr Desc1, TStr Desc2, TStr Desc3) const {
697    if (Desc.Empty()) { Desc = OutFNm; }
698    TFltPrV MeanV1, MedV1, Dec1V1, MinV1, MaxV1;
699    TFltPrV MeanV2, MedV2, Dec1V2, MinV2, MaxV2;
700    TFltPrV MeanV3, MedV3, Dec1V3, MinV3, MaxV3;
701    GetCurveStat(MeanV1, MedV1, Dec1V1, MinV1, MaxV1);
702    LcStat2.GetCurveStat(MeanV2, MedV2, Dec1V2, MinV2, MaxV2);
703    LcStat3.GetCurveStat(MeanV3, MedV3, Dec1V3, MinV3, MaxV3);
704    TGnuPlot GP("phiTR."+OutFNm, TStr::Fmt("%s. %s", Desc.CStr(), ParamStr().CStr()));
705    if (! MinV1.Empty()) { GP.AddPlot(MinV1, gpwLines, Desc1+" MIN", "lw 1"); }
706    if (! MinV2.Empty()) { GP.AddPlot(MinV2, gpwLines, Desc2+" MIN", "lw 1"); }
707    if (! MinV3.Empty()) { GP.AddPlot(MinV3, gpwLines, Desc3+" MIN", "lw 1"); }
708    if (! BagOfWhiskerV.Empty()) { 
709      GP.AddPlot(BagOfWhiskerV, gpwLines, Desc1+" whiskers", "lw 1"); 
710      TFltPrV BestWhiskV;  BestWhiskV.Add(BestWhisk);
711      GP.AddPlot(BestWhiskV, gpwPoints, Desc1+" Best whisker", "pt 5 ps 2"); }
712    if (! LcStat2.BagOfWhiskerV.Empty()) {
713      GP.AddPlot(LcStat2.BagOfWhiskerV, gpwLines, Desc2+" whiskers", "lw 1"); 
714      TFltPrV BestWhiskV;  BestWhiskV.Add(LcStat2.BestWhisk);
715      GP.AddPlot(BestWhiskV, gpwPoints, Desc2+" Best whisker", "pt 5 ps 2"); }
716    if (! LcStat3.BagOfWhiskerV.Empty()) { 
717      GP.AddPlot(LcStat3.BagOfWhiskerV, gpwLines, Desc3+" whiskers", "lw 1"); 
718      TFltPrV BestWhiskV;  BestWhiskV.Add(LcStat3.BestWhisk);
719      GP.AddPlot(BestWhiskV, gpwPoints, Desc3+" Best whisker", "pt 5 ps 2"); }
720    GP.SetScale(gpsLog10XY);
721    GP.SetXYLabel("k (number of nodes in the cluster)", "{/Symbol \\F} (conductance)");
722    GP.SetXRange(1, Graph->GetNodes()/2);
723    GP.SavePng();
724  }
725  void TLocClustStat::SaveTxtInfo(const TStr& OutFNmPref, const TStr& Desc, const bool& SetMaxAt1) const {
726    printf("Save text info...");
727    TExeTm ExeTm;
728    const int GNodes = Graph->GetNodes();
729    const int GEdges = Graph->GetEdges();
730    TVec<TFltV> ColV(17);
731    double MxFrac=0, AvgFrac=0, MedianFrac=0, Pct9Frac=0, Flake=0;
732    for (int i = 0; i < SizeBucketSet.Len(); i++) {
733      if ( !BestCutH.IsKey(SizeBucketSet[i])) { continue; }
734      const TLocClustStat::TCutInfo& C = GetKNodeCut(SizeBucketSet[i]);
735      C.GetFracDegOut(Graph, MxFrac, AvgFrac, MedianFrac, Pct9Frac, Flake);
736      ColV[0].Add(C.Nodes());  ColV[1].Add(C.Edges()); 
737      ColV[2].Add(C.CutSz());  ColV[3].Add(C.GetPhi());
738      ColV[4].Add(C.GetExpansion());       ColV[5].Add(C.GetIntDens()); 
739      ColV[6].Add(C.GetCutRatio(GNodes));  ColV[7].Add(C.GetNormCut(GEdges));
740      ColV[8].Add(MxFrac);       ColV[9].Add(AvgFrac); 
741      ColV[10].Add(MedianFrac);  ColV[11].Add(Pct9Frac);  ColV[12].Add(Flake);
742      ColV[13].Add(double(2.0*C.Edges));  ColV[14].Add(C.GetExpEdgesIn(GEdges));
743      ColV[15].Add(C.GetModular(GEdges)); ColV[16].Add(C.GetModRat(GEdges));
744      printf(".");
745    }
746    if (SetMaxAt1) {
747      for (int c = 1; c < ColV.Len(); c++) {
748        double MaxVal=1e-10;
749        for (int r = 0; r < ColV[c].Len(); r++) { MaxVal = TMath::Mx(MaxVal, ColV[c][r]()); }
750        for (int r = 0; r < ColV[c].Len(); r++) { ColV[c][r] /= MaxVal; }
751      }
752    }
753    const TStr DatFNm = TStr::Fmt("ncp.%s.INFO.tab", OutFNmPref.CStr());
754    FILE *F = fopen(DatFNm.CStr(), "wt");
755    fprintf(F, "# %s %s\n", Desc.CStr(), ParamStr().CStr());
756    fprintf(F, "#N_inside\tE_inside\tE_across\tConductance\tExpansion\tIntDensity\tCutRatio\tNormCut\tMx_FracDegOut\tAvg_FDO\tMedian_FDO\t90Pct_FDO\tFlake_FDO\tVolume\tExpVolume\tModularity\tModRatio\n");
757    for (int r = 0; r < ColV[0].Len(); r++) {
758      fprintf(F, "%g", ColV[0][r]());
759      for (int c = 1; c < ColV.Len(); c++) {
760        fprintf(F, "\t%g", ColV[c][r]()); }
761      fprintf(F, "\n");
762    }
763    fclose(F);
764    printf("[%s]\n", ExeTm.GetStr());
765    TGnuPlot GP(TStr::Fmt("ncp.%s.All", OutFNmPref.CStr()), TStr::Fmt("%s %s", 
766      Desc.CStr(), ParamStr().CStr()));
767    GP.AddPlot(DatFNm, 1, 4, gpwLines, "Conductance", "lw 2");
768    GP.AddPlot(DatFNm, 1, 5, gpwPoints, "Expansion", "pt 3");
769    GP.AddPlot(DatFNm, 1, 6, gpwPoints, "Internal Density", "pt 5 ps 0.8");
770    GP.AddPlot(DatFNm, 1, 7, gpwPoints, "Cut Ratio", "pt 6");
771    GP.AddPlot(DatFNm, 1, 8, gpwPoints, "Normalized Cut", "pt 7");
772    GP.AddPlot(DatFNm, 1, 9, gpwPoints, "Maximum FDO", "pt 9");
773    GP.AddPlot(DatFNm, 1, 10, gpwPoints, "Avg FDO", "pt 11");
774    GP.AddPlot(DatFNm, 1, 13, gpwPoints, "Flake FDO", "pt 13");
775    GP.SetScale(gpsLog10XY);
776    GP.SetXYLabel("k (number of nodes in the cluster)", "Normalized community score (lower is better)");
777    GP.SavePng();
778  }
779  void TLocClustStat::BagOfWhiskers(const PUNGraph& Graph, TFltPrV& SizePhiV, TFltPr& MaxWhisk) {
780    TCnComV Cn1ComV;
781    TSnap::Get1CnCom(Graph, Cn1ComV);
782    TIntPrV SzVolV;
783    int MxSize=0;
784    if (Cn1ComV.Empty()) { printf("** No bridges\n"); SizePhiV.Clr();  return; }
785    printf("  1-connected components: %d\n", Cn1ComV.Len());
786    MaxWhisk = TFltPr(1,1);
787    for (int c = 0; c < Cn1ComV.Len(); c++) {
788      const TIntV& NIdV = Cn1ComV[c].NIdV;
789      const int sz = NIdV.Len();
790      if (sz < 2) { continue; }
791      int vol = 0; 
792      for (int n = 0; n < sz; n++) {
793        vol += Graph->GetNI(NIdV[n]).GetOutDeg(); }
794      SzVolV.Add(TIntPr(sz, vol));
795      MxSize += sz;
796      if (1.0/double(vol) < MaxWhisk.Val2) { MaxWhisk=TFltPr(NIdV.Len(), 1.0/double(vol)); }
797    }
798    SzVolV.Sort(false);
799    THash<TInt, TIntSet> ItemSetH(MxSize, true);
800    THash<TInt, TInt> VolH(MxSize, true);
801    THash<TInt, TFlt> CostH(MxSize, true);
802    ItemSetH.AddKey(0);  VolH.AddKey(0);
803    TExeTm ExeTm;
804    for (int size = 2; size <= TMath::Mn(MxSize, 1000); size++) {
805      for (int item = 0; item <SzVolV.Len(); item++) {
806        const int smallSz = size-SzVolV[item].Val1;
807        if (ItemSetH.IsKey(smallSz)) {
808          const TIntSet& SmallSet = ItemSetH.GetDat(smallSz);
809          if (SmallSet.IsKey(item)) { continue; }
810          const int SmallVol = VolH.GetDat(smallSz);
811          const double curCost = CostH.IsKey(size) ? double(CostH.GetDat(size)) : double(10e10);
812          const double newCost = double(SmallSet.Len()+1) / double(SmallVol+SzVolV[item].Val2);
813          if (curCost < newCost) { continue; }
814          VolH.AddDat(size, SmallVol+SzVolV[item].Val2);
815          ItemSetH.AddDat(size, SmallSet);
816          ItemSetH.GetDat(size).AddKey(item);
817          CostH.AddDat(size, newCost);
818        }
819      }
820      if (VolH.IsKey(size) && size%100==0) {
821        printf("\rSize: %d/%d: vol: %d,  items: %d/%d [%s]", size, MxSize, VolH.GetDat(size).Val,
822          ItemSetH.GetDat(size).Len(), SzVolV.Len(), ExeTm.GetStr());
823      }
824    }
825    printf("\nAdding sizes > 1000 nodes...");
826    int partSz=0; double partVol=0.0;
827    for (int i = 0; i < SzVolV.Len(); i++) {
828      partSz += SzVolV[i].Val1();
829      partVol += SzVolV[i].Val2();
830      if (partSz < 1000) { continue; }
831      const double curCost = CostH.IsKey(partSz) ? double(CostH.GetDat(partSz)) : double(10e10);
832      const double partPhi = double(i+1)/partVol;
833      if (partPhi < curCost) {
834        CostH.AddDat(partSz, partPhi);
835      }
836    }
837    VolH.SortByKey();
838    CostH.SortByKey();
839    SizePhiV.Gen(CostH.Len(), 0);
840    SizePhiV.Add(TFltPr(1, 1));
841    for (int s = 0; s < CostH.Len(); s++) {
842      const int size = CostH.GetKey(s);
843      const double cond = CostH[s]; 
844      SizePhiV.Add(TFltPr(size, cond));
845    }
846    printf("done\n");
847  }
848  void TLocClustStat::BagOfWhiskers2(const PUNGraph& Graph, TFltPrV& SizePhiV) {
849    TCnComV Cn1ComV;
850    TSnap::Get1CnCom(Graph, Cn1ComV);
851    TIntPrV SzVolV;
852    int MxSize=0, TotVol=0;
853    if (Cn1ComV.Empty()) { printf("** No bridges\n");  SizePhiV.Clr();  return; }
854    printf("  1-connected components: %d\n", Cn1ComV.Len());
855    for (int c = 0; c < Cn1ComV.Len(); c++) {
856      const TIntV& NIdV = Cn1ComV[c].NIdV;
857      const int sz = NIdV.Len();
858      if (sz < 2) { continue; }
859      int vol = 0; 
860      for (int n = 0; n < sz; n++) {
861        vol += Graph->GetNI(NIdV[n]).GetOutDeg(); }
862      SzVolV.Add(TIntPr(sz, vol));
863      MxSize += sz;  TotVol += vol;
864    }
865    printf("  Total size: %d\t Total vol: %d\n", MxSize, TotVol);
866    SzVolV.Sort(false);
867    THash<TFlt, TFlt> SizePhiH(MxSize, true);
868    for (int i = 0; i < SzVolV.Len(); i++) {
869      const int Sz = SzVolV[i].Val1();
870      const double Phi = 1.0/double(SzVolV[i].Val2());
871      if ((! SizePhiH.IsKey(Sz)) || SizePhiH.GetDat(Sz) > Phi) {
872        SizePhiH.AddDat(Sz, Phi);  }
873    }
874    double partSz=0.0, partVol=0.0;
875    for (int i = 0; i < SzVolV.Len(); i++) {
876      partSz += SzVolV[i].Val1();
877      partVol += SzVolV[i].Val2();
878      const double partPhi = double(i+1)/partVol;
879      if ((! SizePhiH.IsKey(partSz)) || partPhi < SizePhiH.GetDat(partSz)) {
880        SizePhiH.AddDat(partSz, partPhi); }
881    }
882    SizePhiV.Gen(SizePhiH.Len()+1, 0);
883    SizePhiV.Add(TFltPr(1, 1));
884    SizePhiH.SortByKey();
885    for (int s = 0; s < SizePhiH.Len(); s++) {
886      SizePhiV.Add(TFltPr(SizePhiH.GetKey(s), SizePhiH[s]));
887    }
888  }
889  void TLocClustStat::MakeExpBins(const TFltPrV& ValV, TFltPrV& NewV) {
890    if (ValV.Empty()) { NewV.Clr(false); return; }
891    NewV.Gen(1000, 0);
892    double PrevBPos = 1, BPos = 1;
893    int i = 0;
894    while (BPos <= ValV.Last().Val1) {
895      int MinI=-1;  double MinCnt=TFlt::Mx;
896      while (i < ValV.Len() && ValV[i].Val1 <= BPos) {
897        if (ValV[i].Val2 < MinCnt) { MinCnt=ValV[i].Val2; MinI=i; } i++; }
898      if (MinI>=0 && MinI<ValV.Len()) {
899        NewV.Add(ValV[MinI]); }
900      PrevBPos = (uint) floor(BPos);
901      BPos *= BinFactor;
902      if (floor(BPos) == PrevBPos) { BPos = PrevBPos + 1; }
903    }
904    NewV.Add(ValV.Last());
905  }
906  void TLocClustStat::MakeExpBins(const TFltV& ValV, TFltV& NewV) {
907    if (ValV.Empty()) { NewV.Clr(false); return; }
908    NewV.Gen(1000, 0);
909    double PrevBPos = 1, BPos = 1;
910    int i = 1;
911    NewV.Add(ValV[0]);
912    while (BPos <= ValV.Len()) {
913      int MinI=-1;  double MinCnt=TFlt::Mx;
914      while (i < ValV.Len() && i <= BPos) {
915        if (ValV[i] < MinCnt) { MinCnt=ValV[i]; MinI=i; } i++; }
916      if (MinI>=0 && MinI<ValV.Len()) {
917        NewV.Add(ValV[MinI]); }
918      PrevBPos = (uint) floor(BPos);
919      BPos *= BinFactor;
920      if (floor(BPos) == PrevBPos) { BPos = PrevBPos + 1; }
921    }
922    NewV.Add(ValV.Last());
923  }
924  TNcpGraphsBase::TNcpGraphsBase(const TStr& FNmWc) {
925    TStr FNm;
926    for (TFFile FFile(FNmWc); FFile.Next(FNm); ) {
927      TSsParser Ss(FNm, ssfTabSep, true, false);
928      int TrueNcpId=-1, WhiskId=-1, RewBestWhiskId=-1, RewId=-1, BestWhiskId=-1;
929      while (Ss.Next()) {
930        for (int f = 0; f < Ss.GetFlds(); f++) {
931          if (strstr(Ss[f], "FWD:")) { 
932            TStr S(Ss[f]); const int x = S.SearchStr("FWD:");
933            ParamValV.Add(S.GetSubStr(x+4, S.SearchCh(' ', x+1)-1).GetFlt());
934          }
935          if (strstr(Ss[f], "ORIGINAL MIN")!=NULL) { 
936            GNmV.Add(TStr::Fmt("%s %s", FNm.GetSubStr(FNm.SearchCh('.')+1, FNm.SearchChBack('.')-1).CStr(), strchr(Ss[f], '('))); 
937            int Nodes=0,Edges=0; sscanf(strchr(Ss[f], '(')+1, "%d,%d)", &Nodes, &Edges);
938            GSizeV.Add(TIntPr(Nodes, Edges));
939            printf("%s: %d %d\n", GNmV.Last().CStr(), Nodes, Edges);
940            TrueNcpId=f;
941          }
942          if (strstr(Ss[f], "ORIGINAL whisker")!=NULL || strstr(Ss[f], "TRUE whisker")!=NULL) { WhiskId=f; } 
943          if (strstr(Ss[f], "ORIGINAL Best whisker")!=NULL || strstr(Ss[f], "TRUE Best whisker")!=NULL) { BestWhiskId=f; }
944          if (strstr(Ss[f], "REWIRED MIN")!=NULL || strstr(Ss[f], "RAND MIN")!=NULL) { RewId=f; } 
945          if (strstr(Ss[f], "REWIRED Best whisker")!=NULL || strstr(Ss[f], "RAND Best whisker")!=NULL) { RewBestWhiskId=f; }
946        }
947        if (TrueNcpId!=-1 || WhiskId!=-1) { break; }
948      }
949      if (TrueNcpId < 0) { printf("%s\n", FNm.GetFMid().CStr()); break; }
950      if (BestWhiskId < 0) { WhiskerV.Add(TFltPr(1,1)); }
951      if (RewBestWhiskId < 0) { RewWhiskerV.Add(TFltPr(1,1)); }
952      NcpV.Add(); WhiskNcpV.Add(); RewNcpV.Add();
953      TFltPrV& Ncp = NcpV.Last();
954      TFltPrV& WhiskNcp = WhiskNcpV.Last();
955      TFltPrV& RewNcp = RewNcpV.Last();
956      bool Once=false, Once2=false;
957      while (Ss.Next()) { 
958        if (TrueNcpId < Ss.GetFlds()&& Ss.IsFlt(TrueNcpId)) { Ncp.Add(TFltPr(Ss.GetFlt(TrueNcpId-1), Ss.GetFlt(TrueNcpId))); }
959        if (WhiskId>=0 && WhiskId < Ss.GetFlds() && Ss.IsFlt(WhiskId)) { WhiskNcp.Add(TFltPr(Ss.GetFlt(WhiskId-1), Ss.GetFlt(WhiskId))); }
960        if (RewId >=0 && RewId < Ss.GetFlds()&& Ss.IsFlt(RewId)) { RewNcp.Add(TFltPr(Ss.GetFlt(RewId-1), Ss.GetFlt(RewId))); }
961        if (BestWhiskId>=0 && BestWhiskId < Ss.GetFlds() && ! Once) {  Once=true;
962          int W2=BestWhiskId-1;  while (W2 > 0 && Ss.GetFlt(W2)!=(double)int(Ss.GetFlt(W2))) { W2--; }
963          WhiskerV.Add(TFltPr(Ss.GetFlt(W2), Ss.GetFlt(BestWhiskId))); }
964        if (RewBestWhiskId>=0 && RewBestWhiskId < Ss.GetFlds() && ! Once2) {  Once2=true;
965          int W2=RewBestWhiskId-1;  while (W2 > 0 && Ss.GetFlt(W2)!=(double)int(Ss.GetFlt(W2))) { W2--; }
966          RewWhiskerV.Add(TFltPr(Ss.GetFlt(W2), Ss.GetFlt(RewBestWhiskId))); }
967      }
968      printf("  ncp:%d  whisk:%d  rew:%d\n", NcpV.Last().Len(), WhiskNcpV.Last().Len(), RewNcpV.Last().Len());
969    }
970    IAssert(NcpV.Len() == GSizeV.Len());
971  }
972  TNcpGraphsBase::TNcpGraphsBase(TSIn& SIn) : GNmV(SIn), GSizeV(SIn), WhiskerV(SIn), 
973    RewWhiskerV(SIn),NcpV(SIn), RewNcpV(SIn),WhiskNcpV(SIn) { 
974  }
975  void TNcpGraphsBase::Save(TSOut& SOut) const { 
976    GNmV.Save(SOut); GSizeV.Save(SOut); 
977    WhiskerV.Save(SOut);  RewWhiskerV.Save(SOut); NcpV.Save(SOut); 
978    RewNcpV.Save(SOut); WhiskNcpV.Save(SOut); 
979  }
980  void TNcpGraphsBase::Impose(const TStr& OutFNm, const int& TopN, const bool& Smooth) { 
981    TGnuPlot GP(OutFNm);
982    for (int i = 0; i < TMath::Mn(NcpV.Len(), TopN); i++) {
983      GP.AddPlot(NcpV[i], gpwLines, GNmV[i], Smooth?"smooth csplines":"");
984    }
985    GP.SetScale(gpsLog10XY);
986    GP.SavePng();
987  }
988  double TNcpGraphsBase::GetXAtMinY(const TFltPrV& Ncp, const int& NNodes) {
<span onclick='openModal()' class='match'>989    double MinX1=1, MinY1=1;
990    for (int k = 0; k < Ncp.Len(); k++) {
991      if (Ncp[k].Val2<MinY1) { MinX1=Ncp[k].Val1; MinY1=Ncp[k].Val2; } }
</span>992    return MinX1<1 ? 1 : MinX1;
993  }
994  TFltPr TNcpGraphsBase::GetXYAtMinY(const TFltPrV& Ncp, const int& NNodes) {
995    double MinX1=1, MinY1=1;
996    for (int k = 0; k < Ncp.Len(); k++) {
997      if (Ncp[k].Val2<MinY1) { MinX1=Ncp[k].Val1; MinY1=Ncp[k].Val2; } }
998    return TFltPr(MinX1<1?1:MinX1, MinY1);
999  }
1000  void TNcpGraphsBase::PlotNcpMin(const TStr& OutFNm, const bool& VsGraphN) {
1001    TFltPrV GSzMinK, GSzMinY;
1002    for (int i = 0; i < NcpV.Len(); i++) {
1003      const TFltPr XYAtMinY = GetXYAtMinY(NcpV[i], GSizeV[i].Val1);
1004      const double X = VsGraphN ? (!ParamValV.Empty()?ParamValV[i]():i+1) : GSizeV[i].Val1();
1005      GSzMinK.Add(TFltPr(X, XYAtMinY.Val1));
1006      GSzMinY.Add(TFltPr(X, XYAtMinY.Val2));
1007    }
1008    GSzMinK.Sort();  GSzMinY.Sort();
1009    const TStr XLabel = VsGraphN ? (!ParamValV.Empty()?"parameter value":"network number") : "network size";
1010    TGnuPlot::PlotValV(GSzMinK, TStr("bestK-")+OutFNm, "Network", XLabel, "size of best cluster", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1011    TGnuPlot::PlotValV(GSzMinY, TStr("condAtBestK-")+OutFNm, "Network", XLabel, "conductance of best cluster", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1012  }
1013  void TNcpGraphsBase::SaveTxtNcpMin(const TStr& OutFNm, const bool& VsGraphN) {
1014    TVec<TQuad<TInt, TInt, TFlt, TStr> > GSzMinK;
1015    for (int i = 0; i < NcpV.Len(); i++) {
1016      const TFltPr XYAtMinY = GetXYAtMinY(NcpV[i], GSizeV[i].Val1);
1017      const double X = VsGraphN ? (!ParamValV.Empty()?ParamValV[i]():i+1) : GSizeV[i].Val1();
1018      GSzMinK.Add(TQuad<TInt, TInt, TFlt, TStr>((int)X, (int)XYAtMinY.Val1(), XYAtMinY.Val2, GNmV[i]));
1019    }
1020    GSzMinK.Sort();
1021    FILE *F = fopen(TStr::Fmt("bestK-%s.txt", OutFNm.CStr()).CStr(), "wt");
1022    fprintf(F, "#nodes\tbestK\tcondAtBestK\tgraph name\n");
1023    for (int i = 0; i < GSzMinK.Len(); i++) {
1024      fprintf(F, "%d\t%d\t%f\t%s\n", GSzMinK[i].Val1(), GSzMinK[i].Val2(), GSzMinK[i].Val3(), GSzMinK[i].Val4.CStr());
1025    }
1026    fclose(F);
1027  }
1028  void TNcpGraphsBase::PlotRewNcpMin(const TStr& OutFNm, const bool& VsGraphN) {
1029    TFltPrV GSzMinK, GSzMinY;
1030    for (int i = 0; i < NcpV.Len(); i++) {
1031      const TFltPr XYAtMinY = GetXYAtMinY(RewNcpV[i], GSizeV[i].Val1);
1032      const double X = VsGraphN ? (!ParamValV.Empty()?ParamValV[i]():i+1) : GSizeV[i].Val1();
1033      GSzMinK.Add(TFltPr(X, XYAtMinY.Val1));
1034      GSzMinY.Add(TFltPr(X, XYAtMinY.Val2));
1035    }
1036    GSzMinK.Sort();  GSzMinY.Sort();
1037    const TStr XLabel = VsGraphN ? (!ParamValV.Empty()?"parameter value":"network number") : "network size";
1038    TGnuPlot::PlotValV(GSzMinK, TStr("bestR-")+OutFNm, "Rewired network", XLabel, "size of best cluster", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1039    TGnuPlot::PlotValV(GSzMinY, TStr("condAtBestR-")+OutFNm, "Rewired network", XLabel, "conductance of best cluster", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1040  }
1041  void TNcpGraphsBase::PlotBestWhisker(const TStr& OutFNm, const bool& VsGraphN) {
1042    TFltPrV GSzMinK, GSzMinY;
1043    for (int i = 0; i < GSizeV.Len(); i++) {
1044      if (WhiskerV[i].Val1()>0) {
1045        const double X = VsGraphN ? (!ParamValV.Empty()?ParamValV[i]():i+1) : GSizeV[i].Val1();
1046        GSzMinK.Add(TFltPr(X, WhiskerV[i].Val1()));
1047        GSzMinY.Add(TFltPr(X, WhiskerV[i].Val2()));
1048      }
1049    }
1050    GSzMinK.Sort();  GSzMinY.Sort();
1051    const TStr XLabel = VsGraphN ? (!ParamValV.Empty()?"parameter value":"network number") : "network size";
1052    TGnuPlot::PlotValV(GSzMinK, TStr("bestW-")+OutFNm, "Network", XLabel, "size of best whisker", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1053    TGnuPlot::PlotValV(GSzMinY, TStr("condAtBestW-")+OutFNm, "Network", XLabel, "conductance of best whisker", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1054  }
1055  void TNcpGraphsBase::PlotRewBestWhisker(const TStr& OutFNm, const bool& VsGraphN) {
1056    TFltPrV GSzMinK, GSzMinY;
1057    for (int i = 0; i < GSizeV.Len(); i++) {
1058      if (WhiskerV[i].Val1()>0) {
1059        const double X = VsGraphN ? (!ParamValV.Empty()?ParamValV[i]():i+1) : GSizeV[i].Val1();
1060        GSzMinK.Add(TFltPr(X, RewWhiskerV[i].Val1()));
1061        GSzMinY.Add(TFltPr(X, RewWhiskerV[i].Val2()));
1062      }
1063    }
1064    GSzMinK.Sort();  GSzMinY.Sort();
1065    const TStr XLabel = VsGraphN ? (!ParamValV.Empty()?"parameter value":"network number") : "network size";
1066    TGnuPlot::PlotValV(GSzMinK, TStr("bestWR-")+OutFNm, "Rewired network", XLabel, "size of best rewired whisker", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1067    TGnuPlot::PlotValV(GSzMinY, TStr("condAtBestWR-")+OutFNm, "Rewired network", XLabel, "conductance of best rewired whisker", VsGraphN?gpsLog10Y:gpsLog, false, gpwLinesPoints);
1068  }
1069  void TNcpGraphsBase::PlotAvgNcp(const TStr& OutFNm, const TVec<TFltPrV>& NcpVec, const int& MinSz, const double& MaxMinY) {
1070    THash<TFlt, TMom> MomH;
1071    int Cnt=0;
1072    for (int i = 0; i < NcpVec.Len(); i++) {
1073      if (GSizeV[i].Val1 < MinSz) { continue; }
1074      const TFltPrV& Ncp = NcpVec[i];
1075      double MinX=1, MinY=1;
1076      for (int k = 0; k < Ncp.Len(); k++){
1077        if (Ncp[k].Val2<MinY) { MinX=Ncp[k].Val1; MinY=Ncp[k].Val2; } }
1078      if (MinY > MaxMinY) { continue; }  Cnt++;
1079      for (int k = 0; k < Ncp.Len(); k++){
1080        MomH.AddDat(TMath::Round(exp(TMath::Round(log(Ncp[k].Val1()), 1)),0)).Add(Ncp[k].Val2);
1081      }
1082    }
1083    TGnuPlot::PlotValMomH(MomH, OutFNm, "", "size of the cluster, k", "phi(k)", gpsLog, gpwLines, true, true,true,true);
1084    printf("  minSz: %d, miny %g\t%d\n", MinSz, MaxMinY, Cnt);
1085  }
1086  void TNcpGraphsBase::SaveTxt(const TStr& OutFNm) {
1087    FILE *F=fopen(OutFNm.CStr(), "wt");
1088    fprintf(F, "#Nodes\tEdges\tBestK\tPhi(BestK)\tMaxWhiskN\tPhi(MaxWhisk)\tGraph\n");
1089    for (int i = 0; i < NcpV.Len(); i++) {
1090      const TFltPrV& Ncp = NcpV[i];
1091      double MinX=1, MinY=1;
1092      for (int k = 0; k < Ncp.Len(); k++){
1093        if (Ncp[k].Val2<MinY) { MinX=Ncp[k].Val1; MinY=Ncp[k].Val2; } }
1094      fprintf(F, "%d\t%d\t%d\t%f\t%d\t%f\t%s\n", GSizeV[i].Val1(), GSizeV[i].Val2(), 
1095        int(MinX), MinY, int(WhiskerV[i].Val1), WhiskerV[i].Val2(), GNmV[i].CStr());
1096    }
1097    fclose(F);
1098  }
1099  void TNcpGraphsBase::PlotDataset(const TStr& InFNmWc, const TStr& OutFNm, const bool& ImposeNcp, const bool& VsGraphN) {
1100    TNcpGraphsBase NcpBs(InFNmWc);  
1101    if (ImposeNcp) {
1102      NcpBs.Impose(OutFNm+"5R", 5, false);  NcpBs.Impose(OutFNm+"5S", 5, true); 
1103      NcpBs.Impose(OutFNm+"R", 10, false);  NcpBs.Impose(OutFNm+"S", 10, true); 
1104    }
1105    NcpBs.PlotNcpMin(OutFNm, VsGraphN);
1106    NcpBs.PlotRewNcpMin(OutFNm, VsGraphN);
1107    NcpBs.PlotBestWhisker(OutFNm, VsGraphN);
1108    NcpBs.PlotRewBestWhisker(OutFNm, VsGraphN);
1109  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ncp.cpp</div>
                </div>
                <div class="column column_space"><pre><code>149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
151      if (TrueInfectV[i] > Max) { 
152        Max=TrueInfectV[i]; 
153        Peak=i;
154      }
155    }
</pre></code></div>
                <div class="column column_space"><pre><code>989    double MinX1=1, MinY1=1;
990    for (int k = 0; k < Ncp.Len(); k++) {
991      if (Ncp[k].Val2<MinY1) { MinX1=Ncp[k].Val1; MinY1=Ncp[k].Val2; } }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    