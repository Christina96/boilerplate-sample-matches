
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.76595744680851%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <algorithm>
5  #include <cmath>
6  #include <utility>
7  #include "tablefind.h"
8  #include <allheaders.h>
9  #include "colpartitionset.h"
10  #include "tablerecog.h"
11  namespace tesseract {
12  const int kMaxVerticalSpacing = 500;
13  const int kMaxBlobWidth = 500;
14  const double kSplitPartitionSize = 2.0;
15  const double kAllowTextHeight = 0.5;
16  const double kAllowTextWidth = 0.6;
17  const double kAllowTextArea = 0.8;
18  const double kAllowBlobHeight = 0.3;
19  const double kAllowBlobWidth = 0.4;
20  const double kAllowBlobArea = 0.05;
21  const int kMinBoxesInTextPartition = 10;
22  const int kMaxBoxesInDataPartition = 20;
23  const double kMaxGapInTextPartition = 4.0;
24  const double kMinMaxGapInTextPartition = 0.5;
25  const double kMaxBlobOverlapFactor = 4.0;
26  const double kMaxTableCellXheight = 2.0;
27  const int kMaxColumnHeaderDistance = 4;
28  const double kTableColumnThreshold = 3.0;
29  const double kMinOverlapWithTable = 0.6;
30  const int kSideSpaceMargin = 10;
31  const double kSmallTableProjectionThreshold = 0.35;
32  const double kLargeTableProjectionThreshold = 0.45;
33  const int kLargeTableRowCount = 6;
34  const int kMinRowsInTable = 3;
35  const int kAdjacentLeaderSearchPadding = 2;
36  const double kParagraphEndingPreviousLineRatio = 1.3;
37  const double kMaxParagraphEndingLeftSpaceMultiple = 3.0;
38  const double kMinParagraphEndingTextToWhitespaceRatio = 3.0;
39  const double kMaxXProjectionGapFactor = 2.0;
40  const double kStrokeWidthFractionalTolerance = 0.25;
41  const double kStrokeWidthConstantTolerance = 2.0;
42  #ifndef GRAPHICS_DISABLED
43  static BOOL_VAR(textord_show_tables, false, "Show table regions (ScrollView)");
44  static BOOL_VAR(textord_tablefind_show_mark, false,
45                  "Debug table marking steps in detail (ScrollView)");
46  static BOOL_VAR(textord_tablefind_show_stats, false,
47                  "Show page stats used in table finding (ScrollView)");
48  #endif
49  static BOOL_VAR(textord_tablefind_recognize_tables, false,
50                  "Enables the table recognizer for table layout and filtering.");
51  template <typename T>
52  void DeleteObject(T *object) {
53    delete object;
54  }
55  TableFinder::TableFinder()
56      : resolution_(0),
57        global_median_xheight_(0),
58        global_median_blob_width_(0),
59        global_median_ledding_(0),
60        left_to_right_language_(true) {}
61  TableFinder::~TableFinder() {
62    clean_part_grid_.ClearGridData(&DeleteObject<ColPartition>);
63    leader_and_ruling_grid_.ClearGridData(&DeleteObject<ColPartition>);
64    fragmented_text_grid_.ClearGridData(&DeleteObject<ColPartition>);
65    col_seg_grid_.ClearGridData(&DeleteObject<ColSegment>);
66    table_grid_.ClearGridData(&DeleteObject<ColSegment>);
67  }
68  void TableFinder::set_left_to_right_language(bool order) {
69    left_to_right_language_ = order;
70  }
71  void TableFinder::Init(int grid_size, const ICOORD &bottom_left,
72                         const ICOORD &top_right) {
73    clean_part_grid_.Init(grid_size, bottom_left, top_right);
74    leader_and_ruling_grid_.Init(grid_size, bottom_left, top_right);
75    fragmented_text_grid_.Init(grid_size, bottom_left, top_right);
76    col_seg_grid_.Init(grid_size, bottom_left, top_right);
77    table_grid_.Init(grid_size, bottom_left, top_right);
78  }
79  void TableFinder::InsertCleanPartitions(ColPartitionGrid *grid,
80                                          TO_BLOCK *block) {
81    SetGlobalSpacings(grid);
82    ColPartitionGridSearch gsearch(grid);
83    gsearch.SetUniqueMode(true);
84    gsearch.StartFullSearch();
85    ColPartition *part = nullptr;
86    while ((part = gsearch.NextFullSearch()) != nullptr) {
87      if (part->blob_type() == BRT_NOISE || part->bounding_box().area() <= 0) {
88        continue;
89      }
90      ColPartition *clean_part = part->ShallowCopy();
91      ColPartition *leader_part = nullptr;
92      if (part->IsLineType()) {
93        InsertRulingPartition(clean_part);
94        continue;
95      }
96      if (!part->IsTextType()) {
97        InsertImagePartition(clean_part);
98        continue;
99      }
100      BLOBNBOX_CLIST *part_boxes = part->boxes();
101      BLOBNBOX_C_IT pit(part_boxes);
102      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
103        BLOBNBOX *pblob = pit.data();
104        if (!AllowBlob(*pblob)) {
105          continue;
106        }
107        if (pblob->flow() == BTFT_LEADER) {
108          if (leader_part == nullptr) {
109            leader_part = part->ShallowCopy();
110            leader_part->set_flow(BTFT_LEADER);
111          }
112          leader_part->AddBox(pblob);
113        } else if (pblob->region_type() != BRT_NOISE) {
114          clean_part->AddBox(pblob);
115        }
116      }
117      clean_part->ComputeLimits();
118      ColPartition *fragmented = clean_part->CopyButDontOwnBlobs();
119      InsertTextPartition(clean_part);
120      SplitAndInsertFragmentedTextPartition(fragmented);
121      if (leader_part != nullptr) {
122        leader_part->ComputeLimits();
123        InsertLeaderPartition(leader_part);
124      }
125    }
126    clean_part_grid_.FindPartitionPartners();
127    clean_part_grid_.RefinePartitionPartners(false);
128  }
129  void TableFinder::LocateTables(ColPartitionGrid *grid,
130                                 ColPartitionSet **all_columns,
131                                 WidthCallback width_cb, const FCOORD &reskew) {
132    InitializePartitions(all_columns);
133  #ifndef GRAPHICS_DISABLED
134    if (textord_show_tables) {
135      ScrollView *table_win = MakeWindow(0, 300, "Column Partitions & Neighbors");
136      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
137      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
138                           ScrollView::AQUAMARINE);
139      DisplayColPartitionConnections(table_win, &clean_part_grid_,
140                                     ScrollView::ORANGE);
141      table_win = MakeWindow(100, 300, "Fragmented Text");
142      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE);
143    }
144  #endif 
145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &column_blocks);
148    SetColumnsType(&column_blocks);
149    MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);
150    GridMergeColumnBlocks();
151    ColSegment_LIST table_columns;
152    GetTableColumns(&table_columns);
153    ColSegment_LIST table_regions;
154    GetTableRegions(&table_columns, &table_regions);
155  #ifndef GRAPHICS_DISABLED
156    if (textord_tablefind_show_mark) {
157      ScrollView *table_win = MakeWindow(1200, 300, "Table Columns and Regions");
158      DisplayColSegments(table_win, &table_columns, ScrollView::DARK_TURQUOISE);
159      DisplayColSegments(table_win, &table_regions, ScrollView::YELLOW);
160    }
161  #endif 
162    MoveColSegmentsToGrid(&table_regions, &table_grid_);
163    GridMergeTableRegions();
164    AdjustTableBoundaries();
165    GridMergeTableRegions();
166    if (textord_tablefind_recognize_tables) {
167      DeleteSingleColumnTables();
168  #ifndef GRAPHICS_DISABLED
169      if (textord_show_tables) {
170        ScrollView *table_win = MakeWindow(1200, 300, "Detected Table Locations");
171        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
172        DisplayColSegments(table_win, &table_columns, ScrollView::KHAKI);
173        table_grid_.DisplayBoxes(table_win);
174      }
175  #endif 
176      RecognizeTables();
177      GridMergeTableRegions();
178      RecognizeTables();
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_tables) {
181        ScrollView *table_win = MakeWindow(1400, 600, "Recognized Tables");
182        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
183                             ScrollView::BLUE);
184        table_grid_.DisplayBoxes(table_win);
185      }
186  #endif 
187    } else {
188      DeleteSingleColumnTables();
189  #ifndef GRAPHICS_DISABLED
190      if (textord_show_tables) {
191        ScrollView *table_win = MakeWindow(1500, 300, "Detected Tables");
192        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
193                             ScrollView::BLUE);
194        table_grid_.DisplayBoxes(table_win);
195      }
196  #endif 
197    }
198    MakeTableBlocks(grid, all_columns, width_cb);
199  }
200  int TableFinder::gridsize() const {
201    return clean_part_grid_.gridsize();
202  }
203  int TableFinder::gridwidth() const {
204    return clean_part_grid_.gridwidth();
205  }
206  int TableFinder::gridheight() const {
207    return clean_part_grid_.gridheight();
208  }
209  const ICOORD &TableFinder::bleft() const {
210    return clean_part_grid_.bleft();
211  }
212  const ICOORD &TableFinder::tright() const {
213    return clean_part_grid_.tright();
214  }
215  void TableFinder::InsertTextPartition(ColPartition *part) {
216    ASSERT_HOST(part != nullptr);
217    if (AllowTextPartition(*part)) {
218      clean_part_grid_.InsertBBox(true, true, part);
219    } else {
220      delete part;
221    }
222  }
223  void TableFinder::InsertFragmentedTextPartition(ColPartition *part) {
224    ASSERT_HOST(part != nullptr);
225    if (AllowTextPartition(*part)) {
226      fragmented_text_grid_.InsertBBox(true, true, part);
227    } else {
228      delete part;
229    }
230  }
231  void TableFinder::InsertLeaderPartition(ColPartition *part) {
232    ASSERT_HOST(part != nullptr);
233    if (!part->IsEmpty() && part->bounding_box().area() > 0) {
234      leader_and_ruling_grid_.InsertBBox(true, true, part);
235    } else {
236      delete part;
237    }
238  }
239  void TableFinder::InsertRulingPartition(ColPartition *part) {
240    leader_and_ruling_grid_.InsertBBox(true, true, part);
241  }
242  void TableFinder::InsertImagePartition(ColPartition *part) {
243    clean_part_grid_.InsertBBox(true, true, part);
244  }
245  void TableFinder::SplitAndInsertFragmentedTextPartition(ColPartition *part) {
246    ASSERT_HOST(part != nullptr);
247    if (part->boxes()->empty()) {
248      delete part;
249      return;
250    }
251    ASSERT_HOST(part->median_width() > 0);
252    const double kThreshold = part->median_width() * kSplitPartitionSize;
253    ColPartition *right_part = part;
254    bool found_split = true;
255    while (found_split) {
256      found_split = false;
257      BLOBNBOX_C_IT box_it(right_part->boxes());
258      int previous_right = INT32_MIN;
259      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
260        const TBOX &box = box_it.data()->bounding_box();
261        if (previous_right != INT32_MIN &&
262            box.left() - previous_right > kThreshold) {
263          int mid_x = (box.left() + previous_right) / 2;
264          ColPartition *left_part = right_part;
265          right_part = left_part->SplitAt(mid_x);
266          InsertFragmentedTextPartition(left_part);
267          found_split = true;
268          break;
269        }
270        previous_right = std::max(previous_right, static_cast<int>(box.right()));
271      }
272    }
273    InsertFragmentedTextPartition(right_part);
274  }
275  bool TableFinder::AllowTextPartition(const ColPartition &part) const {
276    const double kHeightRequired = global_median_xheight_ * kAllowTextHeight;
277    const double kWidthRequired = global_median_blob_width_ * kAllowTextWidth;
278    const int median_area = global_median_xheight_ * global_median_blob_width_;
279    const double kAreaPerBlobRequired = median_area * kAllowTextArea;
280    return part.median_height() > kHeightRequired &&
281           part.median_width() > kWidthRequired &&
282           part.bounding_box().area() > kAreaPerBlobRequired * part.boxes_count();
283  }
284  bool TableFinder::AllowBlob(const BLOBNBOX &blob) const {
285    const TBOX &box = blob.bounding_box();
286    const double kHeightRequired = global_median_xheight_ * kAllowBlobHeight;
287    const double kWidthRequired = global_median_blob_width_ * kAllowBlobWidth;
288    const int median_area = global_median_xheight_ * global_median_blob_width_;
289    const double kAreaRequired = median_area * kAllowBlobArea;
290    return box.height() > kHeightRequired && box.width() > kWidthRequired &&
291           box.area() > kAreaRequired;
292  }
293  #ifndef GRAPHICS_DISABLED
294  ScrollView *TableFinder::MakeWindow(int x, int y, const char *window_name) {
295    return clean_part_grid_.MakeWindow(x, y, window_name);
296  }
297  #endif
298  void TableFinder::GetColumnBlocks(ColPartitionSet **all_columns,
299                                    ColSegment_LIST *column_blocks) {
300    for (int i = 0; i < gridheight(); ++i) {
301      ColPartitionSet *columns = all_columns[i];
302      if (columns != nullptr) {
303        ColSegment_LIST new_blocks;
304        columns->GetColumnBoxes(i * gridsize(), (i + 1) * gridsize(),
305                                &new_blocks);
306        GroupColumnBlocks(&new_blocks, column_blocks);
307      }
308    }
309  }
310  void TableFinder::GroupColumnBlocks(ColSegment_LIST *new_blocks,
311                                      ColSegment_LIST *column_blocks) {
312    ColSegment_IT src_it(new_blocks);
313    ColSegment_IT dest_it(column_blocks);
314    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
315      ColSegment *src_seg = src_it.data();
316      const TBOX &src_box = src_seg->bounding_box();
317      bool match_found = false;
318      for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
319        ColSegment *dest_seg = dest_it.data();
320        TBOX dest_box = dest_seg->bounding_box();
321        if (ConsecutiveBoxes(src_box, dest_box)) {
322          dest_seg->InsertBox(src_box);
323          match_found = true;
324          delete src_it.extract();
325          break;
326        }
327      }
328      if (!match_found) {
329        dest_it.add_after_then_move(src_it.extract());
330      }
331    }
332  }
333  bool TableFinder::ConsecutiveBoxes(const TBOX &b1, const TBOX &b2) {
334    int x_margin = 20;
335    int y_margin = 5;
336    return (abs(b1.left() - b2.left()) < x_margin) &&
337           (abs(b1.right() - b2.right()) < x_margin) &&
338           (abs(b1.top() - b2.bottom()) < y_margin ||
339            abs(b2.top() - b1.bottom()) < y_margin);
340  }
341  void TableFinder::InitializePartitions(ColPartitionSet **all_columns) {
342    FindNeighbors();
343    SetPartitionSpacings(&clean_part_grid_, all_columns);
344    SetGlobalSpacings(&clean_part_grid_);
345  }
346  void TableFinder::SetPartitionSpacings(ColPartitionGrid *grid,
347                                         ColPartitionSet **all_columns) {
348    ColPartitionGridSearch gsearch(grid);
349    gsearch.StartFullSearch();
350    ColPartition *part = nullptr;
351    while ((part = gsearch.NextFullSearch()) != nullptr) {
352      ColPartitionSet *columns = all_columns[gsearch.GridY()];
353      TBOX box = part->bounding_box();
354      int y = part->MidY();
355      ColPartition *left_column = columns->ColumnContaining(box.left(), y);
356      ColPartition *right_column = columns->ColumnContaining(box.right(), y);
357      if (left_column) {
358        int left_space = std::max(0, box.left() - left_column->LeftAtY(y));
359        part->set_space_to_left(left_space);
360      }
361      if (right_column) {
362        int right_space = std::max(0, right_column->RightAtY(y) - box.right());
363        part->set_space_to_right(right_space);
364      }
365      ColPartitionGridSearch hsearch(grid);
366      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
367      ColPartition *neighbor = nullptr;
368      while ((neighbor = hsearch.NextSideSearch(true)) != nullptr) {
369        if (neighbor->type() == PT_PULLOUT_IMAGE ||
370            neighbor->type() == PT_FLOWING_IMAGE ||
371            neighbor->type() == PT_HEADING_IMAGE) {
372          int right = neighbor->bounding_box().right();
373          if (right < box.left()) {
374            int space = std::min(box.left() - right, part->space_to_left());
375            part->set_space_to_left(space);
376          }
377        }
378      }
379      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
380      neighbor = nullptr;
381      while ((neighbor = hsearch.NextSideSearch(false)) != nullptr) {
382        if (neighbor->type() == PT_PULLOUT_IMAGE ||
383            neighbor->type() == PT_FLOWING_IMAGE ||
384            neighbor->type() == PT_HEADING_IMAGE) {
385          int left = neighbor->bounding_box().left();
386          if (left > box.right()) {
387            int space = std::min(left - box.right(), part->space_to_right());
388            part->set_space_to_right(space);
389          }
390        }
391      }
392      ColPartition *upper_part = part->SingletonPartner(true);
393      if (upper_part) {
394        int space =
395            std::max(0, static_cast<int>(upper_part->bounding_box().bottom() -
396                                         part->bounding_box().bottom()));
397        part->set_space_above(space);
398      } else {
399        part->set_space_above(INT32_MAX);
400      }
401      ColPartition *lower_part = part->SingletonPartner(false);
402      if (lower_part) {
403        int space =
404            std::max(0, static_cast<int>(part->bounding_box().bottom() -
405                                         lower_part->bounding_box().bottom()));
406        part->set_space_below(space);
407      } else {
408        part->set_space_below(INT32_MAX);
409      }
410    }
411  }
412  void TableFinder::SetVerticalSpacing(ColPartition *part) {
413    TBOX box = part->bounding_box();
414    int top_range =
415        std::min(box.top() + kMaxVerticalSpacing, static_cast<int>(tright().y()));
416    int bottom_range = std::max(box.bottom() - kMaxVerticalSpacing,
417                                static_cast<int>(bleft().y()));
418    box.set_top(top_range);
419    box.set_bottom(bottom_range);
420    TBOX part_box = part->bounding_box();
421    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
422        &clean_part_grid_);
423    rectsearch.StartRectSearch(box);
424    ColPartition *neighbor;
425    int min_space_above = kMaxVerticalSpacing;
426    int min_space_below = kMaxVerticalSpacing;
427    ColPartition *above_neighbor = nullptr;
428    ColPartition *below_neighbor = nullptr;
429    while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
430      if (neighbor == part) {
431        continue;
432      }
433      TBOX neighbor_box = neighbor->bounding_box();
434      if (neighbor_box.major_x_overlap(part_box)) {
435        int gap = abs(part->median_bottom() - neighbor->median_bottom());
436        if (neighbor_box.top() < part_box.bottom() && gap < min_space_below) {
437          min_space_below = gap;
438          below_neighbor = neighbor;
439        } 
440        else if (part_box.top() < neighbor_box.bottom() &&
441                 gap < min_space_above) {
442          min_space_above = gap;
443          above_neighbor = neighbor;
444        }
445      }
446    }
447    part->set_space_above(min_space_above);
448    part->set_space_below(min_space_below);
449    part->set_nearest_neighbor_above(above_neighbor);
450    part->set_nearest_neighbor_below(below_neighbor);
451  }
452  void TableFinder::SetGlobalSpacings(ColPartitionGrid *grid) {
453    STATS xheight_stats(0, kMaxVerticalSpacing);
454    STATS width_stats(0, kMaxBlobWidth);
455    STATS ledding_stats(0, kMaxVerticalSpacing);
456    ColPartitionGridSearch gsearch(grid);
457    gsearch.SetUniqueMode(true);
458    gsearch.StartFullSearch();
459    ColPartition *part = nullptr;
460    while ((part = gsearch.NextFullSearch()) != nullptr) {
461      if (part->IsTextType()) {
462        BLOBNBOX_C_IT it(part->boxes());
463        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
464          xheight_stats.add(it.data()->bounding_box().height(), 1);
465          width_stats.add(it.data()->bounding_box().width(), 1);
466        }
467        ledding_stats.add(part->space_above(), 1);
468        ledding_stats.add(part->space_below(), 1);
469      }
470    }
471    set_global_median_xheight(static_cast<int>(xheight_stats.median() + 0.5));
472    set_global_median_blob_width(static_cast<int>(width_stats.median() + 0.5));
473    set_global_median_ledding(static_cast<int>(ledding_stats.median() + 0.5));
474  #ifndef GRAPHICS_DISABLED
475    if (textord_tablefind_show_stats) {
476      const char *kWindowName = "X-height (R), X-width (G), and ledding (B)";
477      ScrollView *stats_win = MakeWindow(500, 10, kWindowName);
478      xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
479      width_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
480      ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::BLUE);
481    }
482  #endif 
483  }
484  void TableFinder::set_global_median_xheight(int xheight) {
485    global_median_xheight_ = xheight;
486  }
487  void TableFinder::set_global_median_blob_width(int width) {
488    global_median_blob_width_ = width;
489  }
490  void TableFinder::set_global_median_ledding(int ledding) {
491    global_median_ledding_ = ledding;
492  }
493  void TableFinder::FindNeighbors() {
494    ColPartitionGridSearch gsearch(&clean_part_grid_);
495    gsearch.StartFullSearch();
496    ColPartition *part = nullptr;
497    while ((part = gsearch.NextFullSearch()) != nullptr) {
498      ColPartition *upper = part->SingletonPartner(true);
499      if (upper) {
500        part->set_nearest_neighbor_above(upper);
501      }
502      ColPartition *lower = part->SingletonPartner(false);
503      if (lower) {
504        part->set_nearest_neighbor_below(lower);
505      }
506    }
507  }
508  void TableFinder::MarkTablePartitions() {
509    MarkPartitionsUsingLocalInformation();
510  #ifndef GRAPHICS_DISABLED
511    if (textord_tablefind_show_mark) {
512      ScrollView *table_win = MakeWindow(300, 300, "Initial Table Partitions");
513      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
514      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
515                           ScrollView::AQUAMARINE);
516    }
517  #endif
518    FilterFalseAlarms();
519  #ifndef GRAPHICS_DISABLED
520    if (textord_tablefind_show_mark) {
521      ScrollView *table_win = MakeWindow(600, 300, "Filtered Table Partitions");
522      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
523      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
524                           ScrollView::AQUAMARINE);
525    }
526  #endif
527    SmoothTablePartitionRuns();
528  #ifndef GRAPHICS_DISABLED
529    if (textord_tablefind_show_mark) {
530      ScrollView *table_win = MakeWindow(900, 300, "Smoothed Table Partitions");
531      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
532      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
533                           ScrollView::AQUAMARINE);
534    }
535  #endif
536    FilterFalseAlarms();
537  #ifndef GRAPHICS_DISABLED
538    if (textord_tablefind_show_mark || textord_show_tables) {
539      ScrollView *table_win = MakeWindow(900, 300, "Final Table Partitions");
540      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
541      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
542                           ScrollView::AQUAMARINE);
543    }
544  #endif
545  }
546  void TableFinder::MarkPartitionsUsingLocalInformation() {
547    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
548        &clean_part_grid_);
549    gsearch.StartFullSearch();
550    ColPartition *part = nullptr;
551    while ((part = gsearch.NextFullSearch()) != nullptr) {
552      if (!part->IsTextType()) { 
553        continue;
554      }
555      if (part->median_height() > kMaxTableCellXheight * global_median_xheight_) {
556        continue;
557      }
558      if (HasWideOrNoInterWordGap(part) || HasLeaderAdjacent(*part)) {
559        part->set_table_type();
560      }
561    }
562  }
563  bool TableFinder::HasWideOrNoInterWordGap(ColPartition *part) const {
564    ASSERT_HOST(part->IsTextType());
565    BLOBNBOX_CLIST *part_boxes = part->boxes();
566    BLOBNBOX_C_IT it(part_boxes);
567    if (part->bounding_box().width() <
568            kMinBoxesInTextPartition * part->median_height() &&
569        part_boxes->length() < kMinBoxesInTextPartition) {
570      return true;
571    }
572    int current_x0 = -1;
573    int current_x1 = -1;
574    int previous_x1 = -1;
575    int largest_partition_gap_found = -1;
576    const double max_gap = kMaxGapInTextPartition * part->median_height();
577    const double min_gap = kMinMaxGapInTextPartition * part->median_height();
578    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
579      BLOBNBOX *blob = it.data();
580      current_x0 = blob->bounding_box().left();
581      current_x1 = blob->bounding_box().right();
582      if (previous_x1 != -1) {
583        int gap = current_x0 - previous_x1;
584        if (gap < 0) {
585          if (-gap < part->median_height() * kMaxBlobOverlapFactor) {
586            previous_x1 = std::max(previous_x1, current_x1);
587            continue;
588          }
589          else {
590          }
591        }
592        if (gap > max_gap) {
593          return true;
594        }
595        if (gap > largest_partition_gap_found) {
596          largest_partition_gap_found = gap;
597        }
598      }
599      previous_x1 = current_x1;
600    }
601    if (part->bounding_box().width() >
602            kMaxBoxesInDataPartition * part->median_height() ||
603        part_boxes->length() > kMaxBoxesInDataPartition) {
604      return false;
605    }
606    if (largest_partition_gap_found == -1) {
607      return true;
608    }
609    return largest_partition_gap_found < min_gap;
<span onclick='openModal()' class='match'>610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &box = part.bounding_box();
</span>616    const int search_size = kAdjacentLeaderSearchPadding * global_median_xheight_;
617    const int top = box.top() + search_size;
618    const int bottom = box.bottom() - search_size;
619    ColPartitionGridSearch hsearch(&leader_and_ruling_grid_);
620    for (int direction = 0; direction < 2; ++direction) {
621      bool right_to_left = (direction == 0);
622      int x = right_to_left ? box.right() : box.left();
623      hsearch.StartSideSearch(x, bottom, top);
624      ColPartition *leader = nullptr;
625      while ((leader = hsearch.NextSideSearch(right_to_left)) != nullptr) {
626        if (leader->flow() != BTFT_LEADER) {
627          continue;
628        }
629        ASSERT_HOST(&part != leader);
630        if (!part.IsInSameColumnAs(*leader)) {
631          break;
632        }
633        if (!leader->VSignificantCoreOverlap(part)) {
634          continue;
635        }
636        return true;
637      }
638    }
639    return false;
640  }
641  void TableFinder::FilterFalseAlarms() {
642    FilterParagraphEndings();
643    FilterHeaderAndFooter();
644  }
645  void TableFinder::FilterParagraphEndings() {
646    ColPartitionGridSearch gsearch(&clean_part_grid_);
647    gsearch.StartFullSearch();
648    ColPartition *part = nullptr;
649    while ((part = gsearch.NextFullSearch()) != nullptr) {
650      if (part->type() != PT_TABLE) {
651        continue; 
652      }
653      ColPartition *upper_part = part->nearest_neighbor_above();
654      if (!upper_part) {
655        continue;
656      }
657      if (upper_part->type() != PT_FLOWING_TEXT) {
658        continue;
659      }
660      if (upper_part->bounding_box().width() < 2 * part->bounding_box().width()) {
661        continue;
662      }
663      int mid = (part->bounding_box().left() + part->bounding_box().right()) / 2;
664      int upper_mid = (upper_part->bounding_box().left() +
665                       upper_part->bounding_box().right()) /
666                      2;
667      int current_spacing = 0; 
668      int upper_spacing = 0;   
669      if (left_to_right_language_) {
670        int left = std::min(part->bounding_box().left(),
671                            upper_part->bounding_box().left());
672        current_spacing = mid - left;
673        upper_spacing = upper_mid - left;
674      } else {
675        int right = std::max(part->bounding_box().right(),
676                             upper_part->bounding_box().right());
677        current_spacing = right - mid;
678        upper_spacing = right - upper_mid;
679      }
680      if (current_spacing * kParagraphEndingPreviousLineRatio > upper_spacing) {
681        continue;
682      }
683      if (!part->MatchingSizes(*upper_part) ||
684          !part->MatchingStrokeWidth(*upper_part, kStrokeWidthFractionalTolerance,
685                                     kStrokeWidthConstantTolerance)) {
686        continue;
687      }
688      if (part->space_to_left() >
689          kMaxParagraphEndingLeftSpaceMultiple * part->median_height()) {
690        continue;
691      }
692      if (upper_part->bounding_box().width() <
693          kMinParagraphEndingTextToWhitespaceRatio *
694              upper_part->space_to_right()) {
695        continue;
696      }
697      if (part->space_above() >= part->space_below() ||
698          part->space_above() > 2 * global_median_ledding_) {
699        continue;
700      }
701      part->clear_table_type();
702    }
703  }
704  void TableFinder::FilterHeaderAndFooter() {
705    ColPartition *header = nullptr;
706    ColPartition *footer = nullptr;
707    int max_top = INT32_MIN;
708    int min_bottom = INT32_MAX;
709    ColPartitionGridSearch gsearch(&clean_part_grid_);
710    gsearch.StartFullSearch();
711    ColPartition *part = nullptr;
712    while ((part = gsearch.NextFullSearch()) != nullptr) {
713      if (!part->IsTextType()) {
714        continue; 
715      }
716      int top = part->bounding_box().top();
717      int bottom = part->bounding_box().bottom();
718      if (top > max_top) {
719        max_top = top;
720        header = part;
721      }
722      if (bottom < min_bottom) {
723        min_bottom = bottom;
724        footer = part;
725      }
726    }
727    if (header) {
728      header->clear_table_type();
729    }
730    if (footer) {
731      footer->clear_table_type();
732    }
733  }
734  void TableFinder::SmoothTablePartitionRuns() {
735    ColPartitionGridSearch gsearch(&clean_part_grid_);
736    gsearch.StartFullSearch();
737    ColPartition *part = nullptr;
738    while ((part = gsearch.NextFullSearch()) != nullptr) {
739      if (part->type() >= PT_TABLE || part->type() == PT_UNKNOWN) {
740        continue; 
741      }
742      ColPartition *upper_part = part->nearest_neighbor_above();
743      ColPartition *lower_part = part->nearest_neighbor_below();
744      if (!upper_part || !lower_part) {
745        continue;
746      }
747      if (upper_part->type() == PT_TABLE && lower_part->type() == PT_TABLE) {
748        part->set_table_type();
749      }
750    }
751    gsearch.StartFullSearch();
752    part = nullptr;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      if (part->type() != PT_TABLE) {
755        continue; 
756      }
757      ColPartition *upper_part = part->nearest_neighbor_above();
758      ColPartition *lower_part = part->nearest_neighbor_below();
759      if ((upper_part && upper_part->type() != PT_TABLE) &&
760          (lower_part && lower_part->type() != PT_TABLE)) {
761        part->clear_table_type();
762      }
763    }
764  }
765  void TableFinder::SetColumnsType(ColSegment_LIST *column_blocks) {
766    ColSegment_IT it(column_blocks);
767    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
768      ColSegment *seg = it.data();
769      TBOX box = seg->bounding_box();
770      int num_table_cells = 0;
771      int num_text_cells = 0;
772      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rsearch(
773          &clean_part_grid_);
774      rsearch.SetUniqueMode(true);
775      rsearch.StartRectSearch(box);
776      ColPartition *part = nullptr;
777      while ((part = rsearch.NextRectSearch()) != nullptr) {
778        if (part->type() == PT_TABLE) {
779          num_table_cells++;
780        } else if (part->type() == PT_FLOWING_TEXT) {
781          num_text_cells++;
782        }
783      }
784      if (!num_table_cells && !num_text_cells) {
785        delete it.extract();
786      } else {
787        seg->set_num_table_cells(num_table_cells);
788        seg->set_num_text_cells(num_text_cells);
789        seg->set_type();
790      }
791    }
792  }
793  void TableFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
794                                          ColSegmentGrid *col_seg_grid) {
795    ColSegment_IT it(segments);
796    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
797      ColSegment *seg = it.extract();
798      col_seg_grid->InsertBBox(true, true, seg);
799    }
800  }
801  void TableFinder::GridMergeColumnBlocks() {
802    int margin = gridsize();
803    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
804        &col_seg_grid_);
805    gsearch.StartFullSearch();
806    ColSegment *seg;
807    while ((seg = gsearch.NextFullSearch()) != nullptr) {
808      if (seg->type() != COL_TEXT) {
809        continue; 
810      }
811      bool neighbor_found = false;
812      bool modified = false; 
813      do {
814        TBOX box = seg->bounding_box();
815        int top_range =
816            std::min(box.top() + margin, static_cast<int>(tright().y()));
817        int bottom_range =
818            std::max(box.bottom() - margin, static_cast<int>(bleft().y()));
819        box.set_top(top_range);
820        box.set_bottom(bottom_range);
821        neighbor_found = false;
822        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
823            &col_seg_grid_);
824        rectsearch.StartRectSearch(box);
825        ColSegment *neighbor = nullptr;
826        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
827          if (neighbor == seg) {
828            continue;
829          }
830          const TBOX &neighbor_box = neighbor->bounding_box();
831          if (neighbor_box.overlap_fraction(box) >= 0.9) {
832            seg->InsertBox(neighbor_box);
833            modified = true;
834            rectsearch.RemoveBBox();
835            gsearch.RepositionIterator();
836            delete neighbor;
837            continue;
838          }
839          if (neighbor->type() != COL_TABLE) {
840            continue;
841          }
842          if (neighbor_box.major_x_overlap(box) && !box.contains(neighbor_box)) {
843            seg->InsertBox(neighbor_box);
844            neighbor_found = true;
845            modified = true;
846            rectsearch.RemoveBBox();
847            gsearch.RepositionIterator();
848            delete neighbor;
849          }
850        }
851      } while (neighbor_found);
852      if (modified) {
853        gsearch.RemoveBBox();
854        col_seg_grid_.InsertBBox(true, true, seg);
855        gsearch.RepositionIterator();
856      }
857    }
858  }
859  void TableFinder::GetTableColumns(ColSegment_LIST *table_columns) {
860    ColSegment_IT it(table_columns);
861    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
862        &clean_part_grid_);
863    gsearch.StartFullSearch();
864    ColPartition *part;
865    while ((part = gsearch.NextFullSearch()) != nullptr) {
866      if (part->inside_table_column() || part->type() != PT_TABLE) {
867        continue; 
868      }
869      const TBOX &box = part->bounding_box();
870      auto *col = new ColSegment();
871      col->InsertBox(box);
872      part->set_inside_table_column(true);
873      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> vsearch(
874          &clean_part_grid_);
875      vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
876      ColPartition *neighbor = nullptr;
877      bool found_neighbours = false;
878      while ((neighbor = vsearch.NextVerticalSearch(true)) != nullptr) {
879        if (neighbor->inside_table_column()) {
880          continue;
881        }
882        if (neighbor->IsHorizontalLine()) {
883          continue;
884        }
885        if (neighbor->type() != PT_TABLE) {
886          break;
887        }
888        const TBOX &neighbor_box = neighbor->bounding_box();
889        col->InsertBox(neighbor_box);
890        neighbor->set_inside_table_column(true);
891        found_neighbours = true;
892      }
893      if (found_neighbours) {
894        it.add_after_then_move(col);
895      } else {
896        part->set_inside_table_column(false);
897        delete col;
898      }
899    }
900  }
901  void TableFinder::GetTableRegions(ColSegment_LIST *table_columns,
902                                    ColSegment_LIST *table_regions) {
903    ColSegment_IT cit(table_columns);
904    ColSegment_IT rit(table_regions);
905    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
906        &col_seg_grid_);
907    gsearch.StartFullSearch();
908    ColSegment *part;
909    int page_height = tright().y() - bleft().y();
910    ASSERT_HOST(page_height > 0);
911    bool *table_region = new bool[page_height];
912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &part_box = part->bounding_box();
914      for (int i = 0; i < page_height; i++) {
915        table_region[i] = false;
916      }
917      cit.move_to_first();
918      for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
919        TBOX col_box = cit.data()->bounding_box();
920        TBOX intersection_box = col_box.intersection(part_box);
921        for (int i = intersection_box.bottom(); i < intersection_box.top(); i++) {
922          table_region[i - bleft().y()] = true;
923        }
924      }
925      TBOX current_table_box;
926      current_table_box.set_left(part_box.left());
927      current_table_box.set_right(part_box.right());
928      for (int i = 1; i < page_height; i++) {
929        if (!table_region[i - 1] && table_region[i]) {
930          current_table_box.set_bottom(i + bleft().y());
931        }
932        if (table_region[i - 1] && !table_region[i]) {
933          current_table_box.set_top(i + bleft().y());
934          if (!current_table_box.null_box()) {
935            auto *seg = new ColSegment();
936            seg->InsertBox(current_table_box);
937            rit.add_after_then_move(seg);
938          }
939        }
940      }
941    }
942    delete[] table_region;
943  }
944  void TableFinder::GridMergeTableRegions() {
945    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
946        &table_grid_);
947    gsearch.StartFullSearch();
948    ColSegment *seg = nullptr;
949    while ((seg = gsearch.NextFullSearch()) != nullptr) {
950      bool neighbor_found = false;
951      bool modified = false; 
952      do {
953        const TBOX &box = seg->bounding_box();
954        TBOX search_region(box);
955        search_region.set_left(bleft().x());
956        search_region.set_right(tright().x());
957        neighbor_found = false;
958        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
959            &table_grid_);
960        rectsearch.StartRectSearch(search_region);
961        ColSegment *neighbor = nullptr;
962        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
963          if (neighbor == seg) {
964            continue;
965          }
966          const TBOX &neighbor_box = neighbor->bounding_box();
967          if (neighbor_box.overlap_fraction(box) >= 0.9) {
968            seg->InsertBox(neighbor_box);
969            rectsearch.RemoveBBox();
970            gsearch.RepositionIterator();
971            delete neighbor;
972            modified = true;
973            continue;
974          }
975          if (BelongToOneTable(box, neighbor_box)) {
976            seg->InsertBox(neighbor_box);
977            neighbor_found = true;
978            modified = true;
979            rectsearch.RemoveBBox();
980            gsearch.RepositionIterator();
981            delete neighbor;
982          }
983        }
984      } while (neighbor_found);
985      if (modified) {
986        gsearch.RemoveBBox();
987        table_grid_.InsertBBox(true, true, seg);
988        gsearch.RepositionIterator();
989      }
990    }
991  }
992  bool TableFinder::BelongToOneTable(const TBOX &box1, const TBOX &box2) {
993    if (box1.overlap(box2)) {
994      return true;
995    }
996    TBOX bbox = box1.bounding_union(box2);
997    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
998        &clean_part_grid_);
999    rectsearch.StartRectSearch(bbox);
1000    ColPartition *part = nullptr;
1001    while ((part = rectsearch.NextRectSearch()) != nullptr) {
1002      const TBOX &part_box = part->bounding_box();
1003      if (part_box.overlap(box1) && part_box.overlap(box2) &&
1004          !part->IsImageType()) {
1005        return true;
1006      }
1007    }
1008    return false;
1009  }
1010  void TableFinder::AdjustTableBoundaries() {
1011    ColSegment_CLIST adjusted_tables;
1012    ColSegment_C_IT it(&adjusted_tables);
1013    ColSegmentGridSearch gsearch(&table_grid_);
1014    gsearch.StartFullSearch();
1015    ColSegment *table = nullptr;
1016    while ((table = gsearch.NextFullSearch()) != nullptr) {
1017      const TBOX &table_box = table->bounding_box();
1018      TBOX grown_box = table_box;
1019      GrowTableBox(table_box, &grown_box);
1020      if (!grown_box.null_box()) {
1021        auto *col = new ColSegment();
1022        col->InsertBox(grown_box);
1023        it.add_after_then_move(col);
1024      }
1025      gsearch.RemoveBBox();
1026      delete table;
1027    }
1028    table_grid_.Clear();
1029    it.move_to_first();
1030    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1031      ColSegment *seg = it.extract();
1032      table_grid_.InsertBBox(true, true, seg);
1033    }
1034  }
1035  void TableFinder::GrowTableBox(const TBOX &table_box, TBOX *result_box) {
1036    TBOX search_box = table_box;
1037    GrowTableToIncludePartials(table_box, search_box, result_box);
1038    GrowTableToIncludeLines(table_box, search_box, result_box);
1039    IncludeLeftOutColumnHeaders(result_box);
1040  }
1041  void TableFinder::GrowTableToIncludePartials(const TBOX &table_box,
1042                                               const TBOX &search_range,
1043                                               TBOX *result_box) {
1044    for (int i = 0; i < 2; ++i) {
1045      ColPartitionGrid *grid =
1046          (i == 0) ? &fragmented_text_grid_ : &leader_and_ruling_grid_;
1047      ColPartitionGridSearch rectsearch(grid);
1048      rectsearch.StartRectSearch(search_range);
1049      ColPartition *part = nullptr;
1050      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1051        if (part->IsImageType()) {
1052          continue;
1053        }
1054        const TBOX &part_box = part->bounding_box();
1055        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1056          *result_box = result_box->bounding_union(part_box);
1057          continue;
1058        }
1059      }
1060    }
1061  }
1062  void TableFinder::GrowTableToIncludeLines(const TBOX &table_box,
1063                                            const TBOX &search_range,
1064                                            TBOX *result_box) {
1065    ColPartitionGridSearch rsearch(&leader_and_ruling_grid_);
1066    rsearch.SetUniqueMode(true);
1067    rsearch.StartRectSearch(search_range);
1068    ColPartition *part = nullptr;
1069    while ((part = rsearch.NextRectSearch()) != nullptr) {
1070      if (!part->IsLineType()) {
1071        continue;
1072      }
1073      const TBOX &part_box = part->bounding_box();
1074      if (result_box->contains(part_box)) {
1075        continue;
1076      }
1077      if (HLineBelongsToTable(*part, table_box)) {
1078        *result_box = result_box->bounding_union(part_box);
1079      }
1080    }
1081  }
1082  bool TableFinder::HLineBelongsToTable(const ColPartition &part,
1083                                        const TBOX &table_box) {
1084    if (!part.IsHorizontalLine()) {
1085      return false;
1086    }
1087    const TBOX &part_box = part.bounding_box();
1088    if (!part_box.major_x_overlap(table_box)) {
1089      return false;
1090    }
1091    const TBOX bbox = part_box.bounding_union(table_box);
1092    int num_extra_partitions = 0;
1093    int extra_space_to_right = 0;
1094    int extra_space_to_left = 0;
1095    for (int i = 0; i < 2; ++i) {
1096      ColPartitionGrid *grid =
1097          (i == 0) ? &clean_part_grid_ : &leader_and_ruling_grid_;
1098      ColPartitionGridSearch rectsearch(grid);
1099      rectsearch.SetUniqueMode(true);
1100      rectsearch.StartRectSearch(bbox);
1101      ColPartition *extra_part = nullptr;
1102      while ((extra_part = rectsearch.NextRectSearch()) != nullptr) {
1103        const TBOX &extra_part_box = extra_part->bounding_box();
1104        if (extra_part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1105          continue;
1106        }
1107        if (extra_part->IsImageType()) {
1108          continue;
1109        }
1110        num_extra_partitions++;
1111        if (extra_part->type() == PT_TABLE || extra_part->IsLineType()) {
1112          extra_space_to_right++;
1113          extra_space_to_left++;
1114          continue;
1115        }
1116        int space_threshold = kSideSpaceMargin * part.median_height();
1117        if (extra_part->space_to_right() > space_threshold) {
1118          extra_space_to_right++;
1119        }
1120        if (extra_part->space_to_left() > space_threshold) {
1121          extra_space_to_left++;
1122        }
1123      }
1124    }
1125    return (extra_space_to_right > num_extra_partitions / 2) ||
1126           (extra_space_to_left > num_extra_partitions / 2);
1127  }
1128  void TableFinder::IncludeLeftOutColumnHeaders(TBOX *table_box) {
1129    ColPartitionGridSearch vsearch(&clean_part_grid_);
1130    vsearch.StartVerticalSearch(table_box->left(), table_box->right(),
1131                                table_box->top());
1132    ColPartition *neighbor = nullptr;
1133    ColPartition *previous_neighbor = nullptr;
1134    while ((neighbor = vsearch.NextVerticalSearch(false)) != nullptr) {
1135      const int max_distance =
1136          kMaxColumnHeaderDistance * neighbor->median_height();
1137      int table_top = table_box->top();
1138      const TBOX &box = neighbor->bounding_box();
1139      if (box.bottom() - table_top > max_distance) {
1140        break;
1141      }
1142      if (neighbor->type() == PT_TABLE || neighbor->IsLineType()) {
1143        table_box->set_top(box.top());
1144        previous_neighbor = nullptr;
1145        continue;
1146      }
1147      if (previous_neighbor == nullptr) {
1148        previous_neighbor = neighbor;
1149      } else {
1150        const TBOX &previous_box = previous_neighbor->bounding_box();
1151        if (!box.major_y_overlap(previous_box)) {
1152          break;
1153        }
1154      }
1155    }
1156  }
1157  void TableFinder::DeleteSingleColumnTables() {
1158    int page_width = tright().x() - bleft().x();
1159    ASSERT_HOST(page_width > 0);
1160    int *table_xprojection = new int[page_width];
1161    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1162        &table_grid_);
1163    table_search.StartFullSearch();
1164    ColSegment *table;
1165    while ((table = table_search.NextFullSearch()) != nullptr) {
1166      TBOX table_box = table->bounding_box();
1167      for (int i = 0; i < page_width; i++) {
1168        table_xprojection[i] = 0;
1169      }
1170      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1171          &clean_part_grid_);
1172      rectsearch.SetUniqueMode(true);
1173      rectsearch.StartRectSearch(table_box);
1174      ColPartition *part;
1175      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1176        if (!part->IsTextType()) {
1177          continue; 
1178        }
1179        if (part->flow() == BTFT_LEADER) {
1180          continue; 
1181        }
1182        TBOX part_box = part->bounding_box();
1183        if (part_box.overlap_fraction(table_box) < kMinOverlapWithTable) {
1184          continue;
1185        }
1186        BLOBNBOX_CLIST *part_boxes = part->boxes();
1187        BLOBNBOX_C_IT pit(part_boxes);
1188        int next_position_to_write = 0;
1189        for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
1190          BLOBNBOX *pblob = pit.data();
1191          int xstart = pblob->bounding_box().left();
1192          int xend = pblob->bounding_box().right();
1193          xstart = std::max(xstart, next_position_to_write);
1194          for (int i = xstart; i < xend; i++) {
1195            table_xprojection[i - bleft().x()]++;
1196          }
1197          next_position_to_write = xend;
1198        }
1199      }
1200      if (!GapInXProjection(table_xprojection, page_width)) {
1201        table_search.RemoveBBox();
1202        delete table;
1203      }
1204    }
1205    delete[] table_xprojection;
1206  }
1207  bool TableFinder::GapInXProjection(int *xprojection, int length) {
1208    int peak_value = 0;
1209    for (int i = 0; i < length; i++) {
1210      if (xprojection[i] > peak_value) {
1211        peak_value = xprojection[i];
1212      }
1213    }
1214    if (peak_value < kMinRowsInTable) {
1215      return false;
1216    }
1217    double projection_threshold = kSmallTableProjectionThreshold * peak_value;
1218    if (peak_value >= kLargeTableRowCount) {
1219      projection_threshold = kLargeTableProjectionThreshold * peak_value;
1220    }
1221    for (int i = 0; i < length; i++) {
1222      xprojection[i] = (xprojection[i] >= projection_threshold) ? 1 : 0;
1223    }
1224    int largest_gap = 0;
1225    int run_start = -1;
1226    for (int i = 1; i < length; i++) {
1227      if (xprojection[i - 1] && !xprojection[i]) {
1228        run_start = i;
1229      }
1230      if (run_start != -1 && !xprojection[i - 1] && xprojection[i]) {
1231        int gap = i - run_start;
1232        if (gap > largest_gap) {
1233          largest_gap = gap;
1234        }
1235        run_start = -1;
1236      }
1237    }
1238    return largest_gap > kMaxXProjectionGapFactor * global_median_xheight_;
1239  }
1240  void TableFinder::RecognizeTables() {
1241  #ifndef GRAPHICS_DISABLED
1242    ScrollView *table_win = nullptr;
1243    if (textord_show_tables) {
1244      table_win = MakeWindow(0, 0, "Table Structure");
1245      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE,
1246                           ScrollView::LIGHT_BLUE);
1247    }
1248  #endif
1249    TableRecognizer recognizer;
1250    recognizer.Init();
1251    recognizer.set_line_grid(&leader_and_ruling_grid_);
1252    recognizer.set_text_grid(&fragmented_text_grid_);
1253    recognizer.set_max_text_height(global_median_xheight_ * 2.0);
1254    recognizer.set_min_height(1.5 * gridheight());
1255    ColSegment_CLIST good_tables;
1256    ColSegment_C_IT good_it(&good_tables);
1257    ColSegmentGridSearch gsearch(&table_grid_);
1258    gsearch.StartFullSearch();
1259    ColSegment *found_table = nullptr;
1260    while ((found_table = gsearch.NextFullSearch()) != nullptr) {
1261      gsearch.RemoveBBox();
1262      const TBOX &found_box = found_table->bounding_box();
1263      StructuredTable *table_structure = recognizer.RecognizeTable(found_box);
1264      if (table_structure != nullptr) {
1265  #ifndef GRAPHICS_DISABLED
1266        if (textord_show_tables) {
1267          table_structure->Display(table_win, ScrollView::LIME_GREEN);
1268        }
1269  #endif
1270        found_table->set_bounding_box(table_structure->bounding_box());
1271        delete table_structure;
1272        good_it.add_after_then_move(found_table);
1273      } else {
1274        delete found_table;
1275      }
1276    }
1277    for (good_it.mark_cycle_pt(); !good_it.cycled_list(); good_it.forward()) {
1278      table_grid_.InsertBBox(true, true, good_it.extract());
1279    }
1280  }
1281  #ifndef GRAPHICS_DISABLED
1282  void TableFinder::DisplayColSegments(ScrollView *win, ColSegment_LIST *segments,
1283                                       ScrollView::Color color) {
1284    win->Pen(color);
1285    win->Brush(ScrollView::NONE);
1286    ColSegment_IT it(segments);
1287    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1288      ColSegment *col = it.data();
1289      const TBOX &box = col->bounding_box();
1290      int left_x = box.left();
1291      int right_x = box.right();
1292      int top_y = box.top();
1293      int bottom_y = box.bottom();
1294      win->Rectangle(left_x, bottom_y, right_x, top_y);
1295    }
1296    win->UpdateWindow();
1297  }
1298  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1299                                         ScrollView::Color default_color,
1300                                         ScrollView::Color table_color) {
1301    ScrollView::Color color = default_color;
1302    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1303    gsearch.StartFullSearch();
1304    ColPartition *part = nullptr;
1305    while ((part = gsearch.NextFullSearch()) != nullptr) {
1306      color = default_color;
1307      if (part->type() == PT_TABLE) {
1308        color = table_color;
1309      }
1310      const TBOX &box = part->bounding_box();
1311      int left_x = box.left();
1312      int right_x = box.right();
1313      int top_y = box.top();
1314      int bottom_y = box.bottom();
1315      win->Brush(ScrollView::NONE);
1316      win->Pen(color);
1317      win->Rectangle(left_x, bottom_y, right_x, top_y);
1318    }
1319    win->UpdateWindow();
1320  }
1321  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1322                                         ScrollView::Color default_color) {
1323    DisplayColPartitions(win, grid, default_color, ScrollView::YELLOW);
1324  }
1325  void TableFinder::DisplayColPartitionConnections(ScrollView *win,
1326                                                   ColPartitionGrid *grid,
1327                                                   ScrollView::Color color) {
1328    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1329    gsearch.StartFullSearch();
1330    ColPartition *part = nullptr;
1331    while ((part = gsearch.NextFullSearch()) != nullptr) {
1332      const TBOX &box = part->bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part->nearest_neighbor_above();
1338      if (upper_part) {
1339        const TBOX &upper_box = upper_part->bounding_box();
1340        int mid_x = (left_x + right_x) / 2;
1341        int mid_y = (top_y + bottom_y) / 2;
1342        int other_x = (upper_box.left() + upper_box.right()) / 2;
1343        int other_y = (upper_box.top() + upper_box.bottom()) / 2;
1344        win->Brush(ScrollView::NONE);
1345        win->Pen(color);
1346        win->Line(mid_x, mid_y, other_x, other_y);
1347      }
1348      ColPartition *lower_part = part->nearest_neighbor_below();
1349      if (lower_part) {
1350        const TBOX &lower_box = lower_part->bounding_box();
1351        int mid_x = (left_x + right_x) / 2;
1352        int mid_y = (top_y + bottom_y) / 2;
1353        int other_x = (lower_box.left() + lower_box.right()) / 2;
1354        int other_y = (lower_box.top() + lower_box.bottom()) / 2;
1355        win->Brush(ScrollView::NONE);
1356        win->Pen(color);
1357        win->Line(mid_x, mid_y, other_x, other_y);
1358      }
1359    }
1360    win->UpdateWindow();
1361  }
1362  #endif
1363  void TableFinder::MakeTableBlocks(ColPartitionGrid *grid,
1364                                    ColPartitionSet **all_columns,
1365                                    const WidthCallback &width_cb) {
1366    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1367    gsearch.StartFullSearch();
1368    ColPartition *part = nullptr;
1369    while ((part = gsearch.NextFullSearch()) != nullptr) {
1370      if (part->type() == PT_TABLE) {
1371        part->clear_table_type();
1372      }
1373    }
1374    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1375        &table_grid_);
1376    table_search.StartFullSearch();
1377    ColSegment *table;
1378    while ((table = table_search.NextFullSearch()) != nullptr) {
1379      const TBOX &table_box = table->bounding_box();
1380      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1381          grid);
1382      rectsearch.StartRectSearch(table_box);
1383      ColPartition *part;
1384      ColPartition *table_partition = nullptr;
1385      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1386        if (!part->IsTextType()) {
1387          continue;
1388        }
1389        TBOX part_box = part->bounding_box();
1390        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1391          rectsearch.RemoveBBox();
1392          if (table_partition) {
1393            table_partition->Absorb(part, width_cb);
1394          } else {
1395            table_partition = part;
1396          }
1397        }
1398      }
1399      if (table_partition) {
1400        const TBOX &table_box = table_partition->bounding_box();
1401        int grid_x, grid_y;
1402        grid->GridCoords(table_box.left(), table_box.bottom(), &grid_x, &grid_y);
1403        table_partition->SetPartitionType(resolution_, all_columns[grid_y]);
1404        table_partition->set_table_type();
1405        table_partition->set_blob_type(BRT_TEXT);
1406        table_partition->set_flow(BTFT_CHAIN);
1407        table_partition->SetBlobTypes();
1408        grid->InsertBBox(true, true, table_partition);
1409      }
1410    }
1411  }
1412  ColSegment::ColSegment()
1413      : ELIST_LINK(),
1414        num_table_cells_(0),
1415        num_text_cells_(0),
1416        type_(COL_UNKNOWN) {}
1417  ScrollView::Color ColSegment::BoxColor() const {
1418    const ScrollView::Color kBoxColors[PT_COUNT] = {
1419        ScrollView::YELLOW,
1420        ScrollView::BLUE,
1421        ScrollView::YELLOW,
1422        ScrollView::MAGENTA,
1423    };
1424    return kBoxColors[type_];
1425  }
1426  void ColSegment::InsertBox(const TBOX &other) {
1427    bounding_box_ = bounding_box_.bounding_union(other);
1428  }
1429  void ColSegment::set_type() {
1430    if (num_table_cells_ > kTableColumnThreshold * num_text_cells_) {
1431      type_ = COL_TABLE;
1432    } else if (num_text_cells_ > num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
1437  }
1438  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</h3>
            <pre><code>1  TStr TModeNet::GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const {
2    TStr Cpy(CrossName);
3    if (!isDir || !sameMode) { return Cpy; }
4    if (isOutEdge) {
5      Cpy += ":SRC";
6    } else {
7      Cpy += ":DST";
8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
13    TInt location = CheckDenseOrSparseN(Name);
14    int index = KeyToIndexTypeN.GetDat(Name).Val2;
15    if (location == 1) {
16      TVec<TIntV> Attrs(MxNId);
17      VecOfIntVecVecsN[index] = Attrs;
18    } else {
19      THash<TInt, TIntV> Attrs;
20      VecOfIntHashVecsN[index] = Attrs;
21    }
22  }
23  void TModeNet::Clr() {
24    TStrV CNets;
25    NeighborTypes.GetKeyV(CNets);
26    for (int i=0; i < CNets.Len(); i++) {
27      MMNet->GetCrossNetByName(CNets[i]).Clr();
28    }
29    TNEANet::Clr();
30  }
31  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const int linkId, const bool sameMode, bool isDir){
32    TStr CrossName = MMNet->GetCrossName(linkId);
33    return AddNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
34  }
35  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
36    if (!NeighborTypes.IsKey(CrossName)) {
37      AddNbrType(CrossName, sameMode, isDir);
38    }
39    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
40    return AppendIntVAttrDatN(NId, EId, Name); 
41  }
42  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
43    if (!NeighborTypes.IsKey(CrossName)) {
44      return -1;
45    }
46    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
47    return DelFromIntVAttrDatN(NId, EId, Name);
48  }
49  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir){
50    TStr CrossName = MMNet->GetCrossName(linkId);
51    return DelNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
52  }
53  void TModeNet::DelNode(const int& NId) {
54    TStrV Names;
55    GetCrossNetNames(Names);
56    for (int i=0; i < Names.Len(); i++) {
57      TCrossNet& Cross = MMNet->GetCrossNetByName(Names[i]);
58      TIntV OutEIds;
59      GetNeighborsByCrossNet(NId, Names[i], OutEIds, true);
60      for (int j=0; j < OutEIds.Len(); j++) {
61        Cross.DelEdge(OutEIds[j].Val);
62      }
63      if (Cross.IsDirect && Cross.Mode1 == Cross.Mode2) {
64        TIntV InEIds;
65        GetNeighborsByCrossNet(NId, Names[i], InEIds, false);
66        for (int j=0; j < InEIds.Len(); j++) {
67          Cross.DelEdge(InEIds[j].Val);
68        }
69      }
70    }
71    TNEANet::DelNode(NId);
72  }
73  void TModeNet::SetParentPointer(TMMNet* parent) {
74    MMNet = parent;
75  }
76  int TModeNet::AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir) {
77    if (NeighborTypes.IsKey(CrossName)) { return -1; } 
78    bool hasSingleVector = (!isDir || !sameMode);
79    NeighborTypes.AddDat(CrossName, hasSingleVector);
80    return 0;
81  }
82  int TModeNet::DelNbrType(const TStr& CrossName) {
83    bool hasSingleVector = NeighborTypes.GetDat(CrossName);
84    NeighborTypes.DelKey(CrossName);
85    if (hasSingleVector) {
86      return DelAttrN(CrossName);
87    } else {
88      TStr InName = GetNeighborCrossName(CrossName, true, true, true);
89      TStr OutName = GetNeighborCrossName(CrossName, false, true, true);
90      if (DelAttrN(InName) == -1 || DelAttrN(OutName) == -1) {
91        return -1;
92      }
93    }
94    return 0;
95  }
96  void TModeNet::GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId) const{
97    TBool hasSingleVector = NeighborTypes.GetDat(Name);
98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
105  int TModeNet::AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense){
106    TInt CurrLen;
107    if (UseDense) {
108      CurrLen = VecOfIntVecVecsN.Len();
109      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
110      KeyToDenseN.AddDat(attr, true);
111      VecOfIntVecVecsN.Add(Attrs);
112    } else {
113      THash<TInt, TIntV> NewHash;
114      CurrLen = VecOfIntHashVecsN.Len();
115      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
116      KeyToDenseN.AddDat(attr, false);
117      for (int i=0; i< Attrs.Len(); i++) {
118        NewHash.AddDat(i, Attrs[i]);
119      }
120      VecOfIntHashVecsN.Add(NewHash);
121    }
122    return 0;
123  }
124  int TModeNet::AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs){
125    TInt CurrLen;
126    THash<TInt, TIntV> NewHash;
127    CurrLen = VecOfIntHashVecsN.Len();
128    KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
129    KeyToDenseN.AddDat(attr, false);
130    for (int i=0; i< Attrs.Len(); i++) {
131      NewHash.AddDat(i, Attrs[i]);
132    }
133    VecOfIntHashVecsN.Add(NewHash);
134    return 0;
135  }
136  void TModeNet::RemoveCrossNets(TModeNet& Result, TStrV& CrossNets) {
137    const TModeNet& self = *this;
138    Result = TModeNet(self, false);
139    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
140      TStr AttrName = it.GetKey();
141      TInt AttrType = it.GetDat().GetVal1();
142      TInt AttrIndex = it.GetDat().GetVal2();
143      if (AttrType != IntVType) {
144        Result.KeyToIndexTypeN.AddDat(AttrName, it.GetDat());
145      } else {
146        TStr WithoutSuffix = AttrName;
147        bool removeSuffix = false;
148        if (AttrName.IsSuffix(":SRC") || AttrName.IsSuffix(":DST")) {
149          WithoutSuffix = AttrName.GetSubStr(0, AttrName.Len()-5);
150          removeSuffix = true;
151        }
152        bool isSingleVNbrAttr = (NeighborTypes.IsKey(AttrName) && NeighborTypes.GetDat(AttrName));
153        bool isMultiVNbrAttr = (removeSuffix && NeighborTypes.IsKey(WithoutSuffix) && !NeighborTypes.GetDat(WithoutSuffix));
154        if (isSingleVNbrAttr || isMultiVNbrAttr) {
155          TStr NbrName = isSingleVNbrAttr ? AttrName : WithoutSuffix;
156          if (CrossNets.IsIn(NbrName)) {
157            Result.AddNbrType(NbrName, removeSuffix, removeSuffix);
158            TInt location = CheckDenseOrSparseN(AttrName);
159            if (location == 1) {
160              TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
161              Result.AddIntVAttrByVecN(AttrName, Attrs);
162            } else {
163              THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
164              Result.AddIntVAttrByHashN(AttrName, Attrs);
165            }
166          }
167        } else {
168          TInt location = CheckDenseOrSparseN(AttrName);
169          if (location == 1) {
170            TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
171            Result.AddIntVAttrByVecN(AttrName, Attrs);
172          } else {
173            THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
174            Result.AddIntVAttrByHashN(AttrName, Attrs);
175          }
176        }
177      }
178    }
179  }
180  int TModeNet::GetAttrTypeN(const TStr& attr) const {
181    if (KeyToIndexTypeN.IsKey(attr)) {
182      return KeyToIndexTypeN.GetDat(attr).Val1;
183    }
184    return -1;
185  }
186  int TCrossNet::GetAttrTypeE(const TStr& attr) const {
187    if (KeyToIndexTypeE.IsKey(attr)) {
188      return KeyToIndexTypeE.GetDat(attr).Val1;
189    }
190    return -1;
191  }
192  void TCrossNet::Clr() {
193    CrossH.Clr();
194    MxEId=0;
195    KeyToIndexTypeE.Clr();
196    IntDefaultsE.Clr();
197    StrDefaultsE.Clr();
198    FltDefaultsE.Clr();
199    VecOfIntVecsE.Clr();
200    VecOfStrVecsE.Clr();
201    VecOfFltVecsE.Clr(); 
202    Net->ClrNbr(Mode1, CrossNetId, true, Mode1==Mode2, IsDirect.Val);
203    Net->ClrNbr(Mode2, CrossNetId, false, Mode1==Mode2, IsDirect.Val); 
204  }
205  int TCrossNet::AddEdge(const int& sourceNId, const int& destNId, int EId){
206    if (EId == -1) { EId = MxEId;  MxEId++; }
207    else { MxEId = TMath::Mx(EId+1, MxEId()); }
208    if (Net != NULL) {
209      TModeNet& M1 = Net->TModeNetH.GetDat(this->Mode1);
210      TModeNet& M2 = Net->TModeNetH.GetDat(this->Mode2);
211      if (!M1.IsNode(sourceNId) || !M2.IsNode(destNId)) { return -1; }
212      TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
213      M1.AddNeighbor(sourceNId, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
214      M2.AddNeighbor(destNId, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
215    }
216    TCrossNet::TCrossEdge newEdge(EId, sourceNId, destNId);
217    CrossH.AddDat(EId, newEdge);
218    int i;
219    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
220      TVec<TInt>& IntVec = VecOfIntVecsE[i];
221      int KeyId = CrossH.GetKeyId(EId);
222      if (IntVec.Len() > KeyId) {
223        IntVec[KeyId] = TInt::Mn;
224      } else {
225        IntVec.Ins(KeyId, TInt::Mn);
226      }
227    }
228    TVec<TStr> DefIntVec = TVec<TStr>();
229    IntDefaultsE.GetKeyV(DefIntVec);
230    for (i = 0; i < DefIntVec.Len(); i++) {
231      TStr attr = DefIntVec[i];
232      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
233      IntVec[CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
234    }
235    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
236      TVec<TStr>& StrVec = VecOfStrVecsE[i];
237      int KeyId = CrossH.GetKeyId(EId);
238      if (StrVec.Len() > KeyId) {
239        StrVec[KeyId] = TStr::GetNullStr();
240      } else {
241        StrVec.Ins(KeyId, TStr::GetNullStr());
242      }
243    }
244    TVec<TStr> DefStrVec = TVec<TStr>();
245    StrDefaultsE.GetKeyV(DefStrVec);
246    for (i = 0; i < DefStrVec.Len(); i++) {
247      TStr attr = DefStrVec[i];
248      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
249      StrVec[CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
250    }
251    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
252      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
253      int KeyId = CrossH.GetKeyId(EId);
254      if (FltVec.Len() > KeyId) {
255        FltVec[KeyId] = TFlt::Mn;
256      } else {
257        FltVec.Ins(KeyId, TFlt::Mn);
258      }
259    }
260    TVec<TStr> DefFltVec = TVec<TStr>();
261    FltDefaultsE.GetKeyV(DefFltVec);
262    for (i = 0; i < DefFltVec.Len(); i++) {
263      TStr attr = DefFltVec[i];
264      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
265      FltVec[CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
266    }
267    return EId;
268  }
269  int TCrossNet::DelEdge(const int& EId) {
270    TCrossEdge& Edge = CrossH.GetDat(EId);
271    int srcNode = Edge.SrcNId;
272    int dstNode = Edge.DstNId;
273    TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
274    Net->GetModeNetById(this->Mode1).DelNeighbor(srcNode, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
275    Net->GetModeNetById(this->Mode2).DelNeighbor(dstNode, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
276    int i;
277    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
278      TVec<TInt>& IntVec = VecOfIntVecsE[i];
279      IntVec[CrossH.GetKeyId(EId)] =  TInt::Mn;
280    }
281    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
282      TVec<TStr>& StrVec = VecOfStrVecsE[i];
283      StrVec[CrossH.GetKeyId(EId)] =  TStr::GetNullStr();
284    }
285    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
286      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
287      FltVec[CrossH.GetKeyId(EId)] = TFlt::Mn;
288    }
289    CrossH.DelKey(EId);
290    return 0;
291  }
292  void TCrossNet::SetParentPointer(TMMNet* parent) {
293    Net = parent;
294  }
295  void TCrossNet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
296    Names = TVec<TStr>();
297    while (!CrossHI.IsEnd()) {
298      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
299        Names.Add(CrossHI.GetKey());
300      }
301      CrossHI++;
302    }  
303  }
304  void TCrossNet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
305    Values = TVec<TStr>();
306    while (!CrossHI.IsEnd()) {
307      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
308        Values.Add(GetEdgeAttrValue(EId, CrossHI));
309      }
310      CrossHI++;
311    }  
312  }
313  void TCrossNet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
314    Names = TVec<TStr>();
315    while (!CrossHI.IsEnd()) {
316      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
317        Names.Add(CrossHI.GetKey());
318      }
319      CrossHI++;
320    }  
321  }
322  void TCrossNet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const {
323    Values = TVec<TInt>();
324    while (!CrossHI.IsEnd()) {
325      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
326        TInt val = (this->VecOfIntVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
327        Values.Add(val);
328      }
329      CrossHI++;
330    }  
331  }
332  void TCrossNet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
333    Names = TVec<TStr>();
334    while (!CrossHI.IsEnd()) {
335      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
336        Names.Add(CrossHI.GetKey());
337      }
338      CrossHI++;
339    }  
340  }
341  void TCrossNet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
342    Values = TVec<TStr>();
343    while (!CrossHI.IsEnd()) {
344      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
345        TStr val = this->VecOfStrVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId);
346        Values.Add(val);
347      }
348      CrossHI++;
349    }  
350  }
351  void TCrossNet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
352    Names = TVec<TStr>();
353    while (!CrossHI.IsEnd()) {
354      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
355        Names.Add(CrossHI.GetKey());
356      }
357      CrossHI++;
358    }  
359  }
360  void TCrossNet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const {
361    Values = TVec<TFlt>();
362    while (!CrossHI.IsEnd()) {
363      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
364        TFlt val = (this->VecOfFltVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
365        Values.Add(val);
366      }
367      CrossHI++;
368    }  
369  }
370  bool TCrossNet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
371    bool IntDel = IsIntAttrDeletedE(EId, attr);
372    bool StrDel = IsStrAttrDeletedE(EId, attr);
373    bool FltDel = IsFltAttrDeletedE(EId, attr);
374    return IntDel || StrDel || FltDel;
375  }
376  bool TCrossNet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
377    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
378  }
379  bool TCrossNet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
380    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
381  }
382  bool TCrossNet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
383    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
384  }
385  bool TCrossNet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
386    bool IntDel = EdgeAttrIsIntDeleted(EId, CrossHI);
387    bool StrDel = EdgeAttrIsStrDeleted(EId, CrossHI);
388    bool FltDel = EdgeAttrIsFltDeleted(EId, CrossHI);
389    return IntDel || StrDel || FltDel;
390  }
391  bool TCrossNet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
392    return (CrossHI.GetDat().Val1 == IntType &&
393      GetIntAttrDefaultE(CrossHI.GetKey()) == this->VecOfIntVecsE.GetVal(
394      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
395  }
396  bool TCrossNet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
397    return (CrossHI.GetDat().Val1 == StrType &&
398      GetStrAttrDefaultE(CrossHI.GetKey()) == this->VecOfStrVecsE.GetVal(
399      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
400  }
401  bool TCrossNet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
402    return (CrossHI.GetDat().Val1 == FltType &&
403      GetFltAttrDefaultE(CrossHI.GetKey()) == this->VecOfFltVecsE.GetVal(
404      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
405  }
406  TStr TCrossNet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
407    if (CrossHI.GetDat().Val1 == IntType) {
408      return (this->VecOfIntVecsE.GetVal(
409        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
410    } else if(CrossHI.GetDat().Val1 == StrType) {
411      return this->VecOfStrVecsE.GetVal(
412      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId));
413    } else if (CrossHI.GetDat().Val1 == FltType) {
414      return (this->VecOfFltVecsE.GetVal(
415        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
416    }
417    return TStr::GetNullStr();
418  }
419  int TCrossNet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
420    int i;
421    TInt CurrLen;
422    if (!IsEdge(EId)) {
423       return -1;
424    }
425    if (KeyToIndexTypeE.IsKey(attr)) {
426      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
427      NewVec[CrossH.GetKeyId(EId)] = value;
428    } else {
429      CurrLen = VecOfIntVecsE.Len();
430      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
431      TVec<TInt> NewVec = TVec<TInt>();
432      for (i = 0; i < MxEId; i++) {
433        NewVec.Ins(i, GetIntAttrDefaultE(attr));
434      }
435      NewVec[CrossH.GetKeyId(EId)] = value;
436      VecOfIntVecsE.Add(NewVec);
437    }
438    return 0;
439  }
440  int TCrossNet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
441    int i;
442    TInt CurrLen;
443    if (!IsEdge(EId)) {
444       return -1;
445    }
446    if (KeyToIndexTypeE.IsKey(attr)) {
447      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
448      NewVec[CrossH.GetKeyId(EId)] = value;
449    } else {
450      CurrLen = VecOfStrVecsE.Len();
451      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
452      TVec<TStr> NewVec = TVec<TStr>();
453      for (i = 0; i < MxEId; i++) {
454        NewVec.Ins(i, GetStrAttrDefaultE(attr));
455      }
456      NewVec[CrossH.GetKeyId(EId)] = value;
457      VecOfStrVecsE.Add(NewVec);
458    }
459    return 0;
460  } 
461  int TCrossNet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
462    int i;
463    TInt CurrLen;
464    if (!IsEdge(EId)) {
465       return -1;
466    }
467    if (KeyToIndexTypeE.IsKey(attr)) {
468      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
469      NewVec[CrossH.GetKeyId(EId)] = value;
470    } else {
471      CurrLen = VecOfFltVecsE.Len();
472      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
473      TVec<TFlt> NewVec = TVec<TFlt>();
474      for (i = 0; i < MxEId; i++) {
475        NewVec.Ins(i, GetFltAttrDefaultE(attr));
476      }
477      NewVec[CrossH.GetKeyId(EId)] = value;
478      VecOfFltVecsE.Add(NewVec);
479    }
480    return 0;
481  }
482  TInt TCrossNet::GetIntAttrDatE(const int& EId, const TStr& attr) {
483    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
484  }
485  TStr TCrossNet::GetStrAttrDatE(const int& EId, const TStr& attr) {
486    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
487  }
488  TFlt TCrossNet::GetFltAttrDatE(const int& EId, const TStr& attr) {
489    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
490  }
491  int TCrossNet::DelAttrDatE(const int& EId, const TStr& attr) {
492    TInt vecType = KeyToIndexTypeE(attr).Val1;
493    if (vecType == IntType) {
494      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
495    } else if (vecType == StrType) {
496      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
497    } else if (vecType == FltType) {
498      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
499    } else {
500      return -1;
501    }
502    return 0;
503  }
504  int TCrossNet::AddIntAttrE(const TStr& attr, TInt defaultValue){
505    int i;
506    TInt CurrLen;
507    TVec<TInt> NewVec;
508    CurrLen = VecOfIntVecsE.Len();
509    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
510    NewVec = TVec<TInt>();
511    for (i = 0; i < MxEId; i++) {
512      NewVec.Ins(i, defaultValue);
513    }
514    VecOfIntVecsE.Add(NewVec);
515    if (!IntDefaultsE.IsKey(attr)) {
516      IntDefaultsE.AddDat(attr, defaultValue);
517    } else {
518      return -1;
519    }
520    return 0;
521  }
522  int TCrossNet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
523    int i;
524    TInt CurrLen;
525    TVec<TStr> NewVec;
526    CurrLen = VecOfStrVecsE.Len();
527    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
528    NewVec = TVec<TStr>();
529    for (i = 0; i < MxEId; i++) {
530      NewVec.Ins(i, defaultValue);
531    }
532    VecOfStrVecsE.Add(NewVec);
533    if (!StrDefaultsE.IsKey(attr)) {
534      StrDefaultsE.AddDat(attr, defaultValue);
535    } else {
536      return -1;
537    }
538    return 0;
539  }
540  int TCrossNet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
541    int i;
542    TInt CurrLen;
543    TVec<TFlt> NewVec;
544    CurrLen = VecOfFltVecsE.Len();
545    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
546    NewVec = TVec<TFlt>();
547    for (i = 0; i < MxEId; i++) {
548      NewVec.Ins(i, defaultValue);
549    }
550    VecOfFltVecsE.Add(NewVec);
551    if (!FltDefaultsE.IsKey(attr)) {
552      FltDefaultsE.AddDat(attr, defaultValue);
553    } else {
554      return -1;
555    }
556    return 0;
557  }
558  int TCrossNet::DelAttrE(const TStr& attr) {
559    TInt vecType = KeyToIndexTypeE(attr).Val1;
560    if (vecType == IntType) {
561      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
562      if (IntDefaultsE.IsKey(attr)) {
563        IntDefaultsE.DelKey(attr);
564      }
565    } else if (vecType == StrType) {
566      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
567      if (StrDefaultsE.IsKey(attr)) {
568        StrDefaultsE.DelKey(attr);
569      }  
570    } else if (vecType == FltType) {
571      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
572      if (FltDefaultsE.IsKey(attr)) {
573        FltDefaultsE.DelKey(attr);
574      }
575    } else {
576      return -1;
577    }
578    KeyToIndexTypeE.DelKey(attr);
579    return 0;
580  }
581  void TMMNet::LoadNetworkShM(TShMIn& ShMIn) {
582    MxModeId = TInt(ShMIn);
583    MxCrossNetId = TInt(ShMIn);
584    TModeNetInit Fm;
585    TModeNetH.LoadShM(ShMIn, Fm);
586    TCrossNetInit Fc;
587    TCrossNetH.LoadShM(ShMIn, Fc);
588    ModeIdToNameH.LoadShM(ShMIn);
589    ModeNameToIdH.LoadShM(ShMIn);
590    CrossIdToNameH.LoadShM(ShMIn);
591    CrossNameToIdH.LoadShM(ShMIn);
592    for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
593      it.GetDat().SetParentPointer(this);
594    }
595    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
596      it.GetDat().SetParentPointer(this);
597    }
<span onclick='openModal()' class='match'>598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
</span>604    MxModeId++;
605    ModeIdToNameH.AddDat(ModeId, ModeName);
606    ModeNameToIdH.AddDat(ModeName, ModeId);
607    TModeNet NewGraph(ModeId);
608    NewGraph.SetParentPointer(this);
609    TModeNetH.AddDat(ModeId, NewGraph);
610    return ModeId;
611  }
612  int TMMNet::AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir) {
613    TInt ModeId1 = GetModeId(ModeName1);
614    TInt ModeId2 = GetModeId(ModeName2);
615    return AddCrossNet(ModeId1, ModeId2, CrossNetName, isDir);
616  }
617  int TMMNet::AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir) {
618    if (CrossNameToIdH.IsKey(CrossNetName)) {
619      return -1;
620    }
621    TInt CrossNetId = TInt(MxCrossNetId);
622    MxCrossNetId++;
623    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
624    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
625    TCrossNet Cross = TCrossNet(ModeId1, ModeId2, isDir, CrossNetId);
626    Cross.SetParentPointer(this);
627    TCrossNetH.AddDat(CrossNetId, Cross);
628    TModeNetH.GetDat(ModeId1).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
629    TModeNetH.GetDat(ModeId2).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
630    return CrossNetId;
631  }
632  int TMMNet::DelCrossNet(const TInt& CrossNetId) {
633    return DelCrossNet(CrossIdToNameH.GetDat(CrossNetId));
634  }
635  int TMMNet::DelCrossNet(const TStr& CrossNet) {
636    IAssertR(CrossNameToIdH.IsKey(CrossNet),TStr::Fmt("No such link type: %s", CrossNet.CStr()));
637    TInt CrossNetId = CrossNameToIdH.GetDat(CrossNet);
638    TInt Mode1 = GetCrossNetById(CrossNetId).Mode1;
639    TInt Mode2 = GetCrossNetById(CrossNetId).Mode2;
640    if (GetModeNetById(Mode1).DelNbrType(CrossNet) == -1 || (Mode1 != Mode2 && GetModeNetById(Mode2).DelNbrType(CrossNet) == -1)) {
641      return -1;
642    }
643    CrossNameToIdH.DelKey(CrossNet);
644    CrossIdToNameH.DelKey(CrossNetId);
645    GetCrossNetById(CrossNetId).SetParentPointer(NULL);
646    TCrossNetH.DelKey(CrossNetId);
647    return 0;
648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
653      if (DelCrossNet(CrossNets[i]) == -1) {
654        return -1;
655      }
656    }
657    TStr ModeName = ModeIdToNameH.GetDat(ModeId);
658    ModeNameToIdH.DelKey(ModeName);
659    ModeIdToNameH.DelKey(ModeId);
660    GetModeNetById(ModeId).SetParentPointer(NULL);
661    TModeNetH.DelKey(ModeId);
662    return 0;
663  }
664  int TMMNet::DelModeNet(const TStr& ModeName) {
665    IAssertR(ModeNameToIdH.IsKey(ModeName), TStr::Fmt("No such mode with name: %s", ModeName.CStr()));
666    return DelModeNet(ModeNameToIdH.GetDat(ModeName));
667  }
668  TModeNet& TMMNet::GetModeNetByName(const TStr& ModeName) const {
669    return GetModeNetById(ModeNameToIdH.GetDat(ModeName));
670  }
671  TModeNet& TMMNet::GetModeNetById(const TInt& ModeId) const {
672    TModeNet &Net = (const_cast<TMMNet *>(this))->TModeNetH.GetDat(ModeId);
673    return Net;
674  }
675  TCrossNet& TMMNet::GetCrossNetByName(const TStr& CrossName) const{
676    return GetCrossNetById(CrossNameToIdH.GetDat(CrossName));
677  }
678  TCrossNet& TMMNet::GetCrossNetById(const TInt& CrossId) const{
679    TCrossNet& CrossNet = (const_cast<TMMNet *>(this))->TCrossNetH.GetDat(CrossId);
680    return CrossNet;
681  }
682  int TMMNet::AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet) {
683    ModeIdToNameH.AddDat(ModeId, ModeName);
684    ModeNameToIdH.AddDat(ModeName, ModeId);
685    TModeNetH.AddDat(ModeId, ModeNet);
686    TModeNetH[ModeId].SetParentPointer(this);
687    return ModeId;
688  }
689  int TMMNet::AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet) {
690    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
691    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
692    TCrossNetH.AddDat(CrossNetId, CrossNet);
693    TCrossNetH[CrossNetId].SetParentPointer(this);
694    return CrossNetId;
695  }
696  void TMMNet::ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir) {
697    TStr CrossNetName = CrossIdToNameH[CrossNetId];
698    TModeNetH[ModeId].ClrNbr(CrossNetName, outEdge, sameMode, isDir);
699  }
700  PMMNet TMMNet::GetSubgraphByCrossNet(TStrV& CrossNetTypes) {
701    PMMNet Result = New();
702    TInt MxMode = 0;
703    TInt MxCross = 0;
704    TIntH ModeH;
705    for(int i = 0; i < CrossNetTypes.Len(); i++) {
706      TStr CrossName = CrossNetTypes[i];
707      TInt OldId = CrossNameToIdH.GetDat(CrossName);
708      TInt NewId = MxCross++;
709      TCrossNet NewCrossNet(TCrossNetH.GetDat(OldId));
710      TInt OldModeId1 = NewCrossNet.Mode1;
711      TInt OldModeId2 = NewCrossNet.Mode2;
712      TInt NewModeId1, NewModeId2;
713      if (ModeH.IsKey(OldModeId1)) {
714        NewModeId1 = ModeH.GetDat(OldModeId1);
715      } else {
716        NewModeId1 = MxMode++;
717        ModeH.AddDat(OldModeId1, NewModeId1);
718      }
719      if (ModeH.IsKey(OldModeId2)) {
720        NewModeId2 = ModeH.GetDat(OldModeId2);
721      } else {
722        NewModeId2 = MxMode++;
723        ModeH.AddDat(OldModeId2, NewModeId2);
724      }
725      NewCrossNet.Mode1 = NewModeId1;
726      NewCrossNet.Mode2 = NewModeId2;
727      NewCrossNet.CrossNetId = NewId;
728      Result->AddCrossNet(CrossName, NewId, NewCrossNet);
729    }
730    for(TIntH::TIter it = ModeH.BegI(); it < ModeH.EndI(); it++) {
731      TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
732      TInt NewModeId = it.GetDat();
733      TModeNet NewModeNet;
734      TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, CrossNetTypes);
735      NewModeNet.ModeId = NewModeId;
736      Result->AddMode(ModeName, NewModeId, NewModeNet);
737    }
738    Result->MxModeId = MxMode;
739    Result->MxCrossNetId = MxCross;
740    return Result;
741  }
742  PMMNet TMMNet::GetSubgraphByModeNet(TStrV& ModeNetTypes) {
743    THash<TInt, TBool> ModeTypeIds;
744    for (int i = 0; i < ModeNetTypes.Len(); i++) {
745      ModeTypeIds.AddDat(ModeNameToIdH.GetDat(ModeNetTypes[i]), true);
746    }
747    TStrV CrossNetTypes;
748    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
749      TCrossNet& CrossNet = it.GetDat();
750      if (ModeTypeIds.IsKey(CrossNet.Mode1) && ModeTypeIds.IsKey(CrossNet.Mode2)) {
751        CrossNetTypes.Add(CrossIdToNameH.GetDat(it.GetKey()));
752        ModeTypeIds[CrossNet.Mode1] = false;
753        ModeTypeIds[CrossNet.Mode2] = false;
754      }
755    }
756    PMMNet Result = GetSubgraphByCrossNet(CrossNetTypes);
757    TInt MxMode = Result->MxModeId;
758    TStrV EmptyCrossNetTypes;
759    for (THash<TInt, TBool>::TIter it = ModeTypeIds.BegI(); it < ModeTypeIds.EndI(); it++) {
760      if (it.GetDat().Val) {
761        TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
762        TInt NewModeId = MxMode++;
763        TModeNet NewModeNet;
764        TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, EmptyCrossNetTypes);
765        NewModeNet.ModeId = NewModeId;
766        Result->AddMode(ModeName, NewModeId, NewModeNet);
767      }
768    }
769    Result->MxModeId = MxMode;
770    return Result;
771  }
772  PNEANet TMMNet::ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap) {
773    TIntPrIntH NodeMap;
774    THash<TIntPr, TIntPr> EdgeMap;
775    THashSet<TInt> Modes;
776    PNEANet NewNet = TNEANet::New();
777    for (int i = 0; i < CrossNetTypes.Len(); i++) {
778      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
779      TInt Mode1 = CrossNet.GetMode1();
780      TInt Mode2 = CrossNet.GetMode2();
781      Modes.AddKey(Mode1);
782      Modes.AddKey(Mode2);
783      bool isDirected = CrossNet.IsDirected();
784      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
785        int srcNode = EdgeI.GetSrcNId();
786        int dstNode = EdgeI.GetDstNId();
787        TIntPr SrcNodeMapping(Mode1, srcNode);
788        int srcId = 0;
789        if (NodeMap.IsKey(SrcNodeMapping)) {
790          srcId = NodeMap.GetDat(SrcNodeMapping);
791        } else {
792          srcId = NewNet->AddNode();
793          NodeMap.AddDat(SrcNodeMapping, srcId);
794        }
795        TIntPr DstNodeMapping(Mode2, dstNode);
796        int dstId = 0;
797        if (NodeMap.IsKey(DstNodeMapping)) {
798          dstId = NodeMap.GetDat(DstNodeMapping);
799        } else {
800          dstId = NewNet->AddNode();
801          NodeMap.AddDat(DstNodeMapping, dstId);
802        }
803        int edgeId = EdgeI.GetId();
804        TIntPr EdgeMapping(CrossNetTypes[i], edgeId);
805        int newEId = NewNet->AddEdge(srcId, dstId);
806        int otherEId = -1;
807        if (!isDirected) {
808          otherEId = NewNet->AddEdge(dstId, srcId);
809        }
810        EdgeMap.AddDat(EdgeMapping, TIntPr(newEId, otherEId));
811      }
812    }
813    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
814      TModeNet &ModeNet = GetModeNetById(it.GetKey());
815      TInt ModeId = it.GetKey();
816      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
817        TIntPr NodeKey(ModeId, NodeIt.GetId());
818        if (!NodeMap.IsKey(NodeKey)) {
819          int newId = NewNet->AddNode();
820          NodeMap.AddDat(NodeKey, newId);
821        }
822      }
823    }
824    NewNet->AddIntAttrN(TStr("Mode"));
825    NewNet->AddIntAttrN(TStr("Id"));
826    NewNet->AddIntAttrE(TStr("CrossNet"));
827    NewNet->AddIntAttrE(TStr("Id"));
828    for(TIntPrIntH::TIter it = NodeMap.BegI(); it != NodeMap.EndI(); it++) {
829      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal1(), TStr("Mode"));
830      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal2(), TStr("Id"));
831    }
832    for(THash<TIntPr, TIntPr>::TIter it = EdgeMap.BegI(); it != EdgeMap.EndI(); it++) {
833      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal1(), TStr("CrossNet"));
834      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal2(), TStr("Id"));
835      if (it.GetDat().GetVal2() != -1) {
836        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal1(), TStr("CrossNet"));
837        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal2(), TStr("Id"));
838      }
839    }
840    for (int i = 0; i < NodeAttrMap.Len(); i++) {
841      TInt ModeId = NodeAttrMap[i].Val1;
842      TStr OrigAttr = NodeAttrMap[i].Val2;
843      TStr NewAttr = NodeAttrMap[i].Val3;
844      TModeNet& Net = GetModeNetById(ModeId);
845      int type = Net.GetAttrTypeN(OrigAttr);
846      if (type == TModeNet::IntType) {
847        NewNet->AddIntAttrN(NewAttr, Net.GetIntAttrDefaultN(OrigAttr));
848        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
849          TIntPr OldNId(ModeId, it.GetId());
850          int NewId = NodeMap.GetDat(OldNId);
851          int Val = Net.GetIntAttrDatN(it.GetId(), OrigAttr);
852          NewNet->AddIntAttrDatN(NewId, Val, NewAttr);
853        }
854      } else if (type == TModeNet::FltType) {
855        NewNet->AddFltAttrN(NewAttr, Net.GetFltAttrDefaultN(OrigAttr));
856        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
857          TIntPr OldNId(ModeId, it.GetId());
858          int NewId = NodeMap.GetDat(OldNId);
859          TFlt Val = Net.GetFltAttrDatN(it.GetId(), OrigAttr);
860          NewNet->AddFltAttrDatN(NewId, Val, NewAttr);
861        }
862      } else if (type == TModeNet::StrType) {
863        NewNet->AddStrAttrN(NewAttr, Net.GetStrAttrDefaultN(OrigAttr));
864        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
865          TIntPr OldNId(ModeId, it.GetId());
866          int NewId = NodeMap.GetDat(OldNId);
867          TStr Val = Net.GetStrAttrDatN(it.GetId(), OrigAttr);
868          NewNet->AddStrAttrDatN(NewId, Val, NewAttr);
869        }
870      } else if (type == TModeNet::IntVType) {
871        NewNet->AddIntVAttrN(NewAttr);
872        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
873          TIntPr OldNId(ModeId, it.GetId());
874          int NewId = NodeMap.GetDat(OldNId);
875          TIntV Val = Net.GetIntVAttrDatN(it.GetId(), OrigAttr);
876          NewNet->AddIntVAttrDatN(NewId, Val, NewAttr);
877        }
878      }
879    }
880    for (int i = 0; i < EdgeAttrMap.Len(); i++) {
881      TInt CrossId = EdgeAttrMap[i].Val1;
882      TStr OrigAttr = EdgeAttrMap[i].Val2;
883      TStr NewAttr = EdgeAttrMap[i].Val3;
884      TCrossNet& Net = GetCrossNetById(CrossId);
885      int type = Net.GetAttrTypeE(OrigAttr);
886      if (type == TCrossNet::IntType) {
887        NewNet->AddIntAttrE(NewAttr, Net.GetIntAttrDefaultE(OrigAttr));
888        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
889          TIntPr OldNId(CrossId, it.GetId());
890          TIntPr NewId = EdgeMap.GetDat(OldNId);
891          int Val = Net.GetIntAttrDatE(it.GetId(), OrigAttr);
892          NewNet->AddIntAttrDatE(NewId.Val1, Val, NewAttr);
893          if (NewId.Val2 != -1) {
894            NewNet->AddIntAttrDatE(NewId.Val2, Val, NewAttr);
895          }
896        }
897      } else if (type == TCrossNet::FltType) {
898        NewNet->AddFltAttrE(NewAttr, Net.GetFltAttrDefaultE(OrigAttr));
899        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
900          TIntPr OldNId(CrossId, it.GetId());
901          TIntPr NewId = EdgeMap.GetDat(OldNId);
902          TFlt Val = Net.GetFltAttrDatE(it.GetId(), OrigAttr);
903          NewNet->AddFltAttrDatE(NewId.Val1, Val, NewAttr);
904          if (NewId.Val2 != -1) {
905            NewNet->AddFltAttrDatE(NewId.Val2, Val, NewAttr);
906          }
907        }
908      } else if (type == TCrossNet::StrType) {
909        NewNet->AddStrAttrE(NewAttr, Net.GetStrAttrDefaultE(OrigAttr));
910        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++){
911          TIntPr OldNId(CrossId, it.GetId());
912          TIntPr NewId = EdgeMap.GetDat(OldNId);
913          TStr Val = Net.GetStrAttrDatE(it.GetId(), OrigAttr);
914          NewNet->AddStrAttrDatE(NewId.Val1, Val, NewAttr);
915          if (NewId.Val2 != -1) {
916            NewNet->AddStrAttrDatE(NewId.Val2, Val, NewAttr);
917          }
918        }
919      }
920    }
921    return NewNet;
922  }
923  PNEANet TMMNet::ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap) {
924    TIntPrIntH NodeMap;
925    THashSet<TInt> Modes;
926    PNEANet NewNet = TNEANet::New();
927    NewNet->AddIntAttrN(TStr("Mode"));
928    NewNet->AddIntAttrN(TStr("Id"));
929    NewNet->AddIntAttrE(TStr("CrossNet"));
930    NewNet->AddIntAttrE(TStr("Id"));
931    for (int i = 0; i < CrossNetTypes.Len(); i++) {
932      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
933      TStrPrV CNetAttrs;
934      if (EdgeAttrMap.IsKey(CrossNetTypes[i])) {
935        CNetAttrs = EdgeAttrMap.GetDat(CrossNetTypes[i]);
936      }
937      TInt Mode1 = CrossNet.GetMode1();
938      TInt Mode2 = CrossNet.GetMode2();
939      TModeNet& Mode1Net = GetModeNetById(Mode1);
940      TModeNet& Mode2Net = GetModeNetById(Mode2);
941      TStrPrV Mode1Attrs;
942      if (NodeAttrMap.IsKey(Mode1)) {
943        Mode1Attrs = NodeAttrMap.GetDat(Mode1);
944      }
945      TStrPrV Mode2Attrs;
946      if (NodeAttrMap.IsKey(Mode2)) {
947        Mode2Attrs = NodeAttrMap.GetDat(Mode2);
948      } 
949      Modes.AddKey(Mode1);
950      Modes.AddKey(Mode2);
951      bool isDirected = CrossNet.IsDirected();
952      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
953        int srcNode = EdgeI.GetSrcNId();
954        int dstNode = EdgeI.GetDstNId();
955        TIntPr SrcNodeMapping(Mode1, srcNode);
956        int srcId = 0;
957        if (NodeMap.IsKey(SrcNodeMapping)) {
958          srcId = NodeMap.GetDat(SrcNodeMapping);
959        } else {
960          srcId = NewNet->AddNode();
961          NodeMap.AddDat(SrcNodeMapping, srcId);
962          NewNet->AddIntAttrDatN(srcId, srcNode, TStr("Id"));
963          NewNet->AddIntAttrDatN(srcId, Mode1, TStr("Mode"));
964          AddNodeAttributes(NewNet, Mode1Net, Mode1Attrs, Mode1, srcNode, srcId);
965        }
966        TIntPr DstNodeMapping(Mode2, dstNode);
967        int dstId = 0;
968        if (NodeMap.IsKey(DstNodeMapping)) {
969          dstId = NodeMap.GetDat(DstNodeMapping);
970        } else {
971          dstId = NewNet->AddNode();
972          NodeMap.AddDat(DstNodeMapping, dstId);
973          NewNet->AddIntAttrDatN(dstId, dstNode, TStr("Id"));
974          NewNet->AddIntAttrDatN(dstId, Mode2, TStr("Mode"));
975          AddNodeAttributes(NewNet, Mode2Net, Mode2Attrs, Mode2, dstNode, dstId);
976        }
977        int edgeId = EdgeI.GetId();
978        int newEId = NewNet->AddEdge(srcId, dstId);
979        NewNet->AddIntAttrDatE(newEId, edgeId, TStr("Id"));
980        NewNet->AddIntAttrDatE(newEId, CrossNetTypes[i], TStr("CrossNet"));
981        AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, newEId);
982        if (!isDirected) {
983          int otherEId = NewNet->AddEdge(dstId, srcId);
984          NewNet->AddIntAttrDatE(otherEId, edgeId, TStr("Id"));
985          NewNet->AddIntAttrDatE(otherEId, CrossNetTypes[i], TStr("CrossNet"));
986          AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, otherEId);
987        }
988      }
989    }
990    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
991      TInt ModeId = it.GetKey();
992      TModeNet &ModeNet = GetModeNetById(ModeId);
993      TStrPrV ModeAttrs = NodeAttrMap.GetDat(ModeId);
994      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
995        TIntPr NodeKey(ModeId, NodeIt.GetId());
996        if (!NodeMap.IsKey(NodeKey)) {
997          int newId = NewNet->AddNode();
998          NodeMap.AddDat(NodeKey, newId);
999          AddNodeAttributes(NewNet, ModeNet, ModeAttrs, ModeId, NodeIt.GetId(), newId);
1000        }
1001      }
1002    }
1003    return NewNet;
1004  }
1005  void TMMNet::GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxLen) const {
1006    if (MxLen <= NumPartitions) {
1007        Partitions.Add(TIntPr(0,MxLen));
1008    } else {
1009      TInt PartitionSize = MxLen/NumPartitions;
1010      TInt CurrStart = 0;
1011      bool done = false;
1012      while (!done) {
1013        TInt CurrEnd = CurrStart + PartitionSize;
1014        if (MxLen - CurrEnd < PartitionSize) {
1015          CurrEnd = MxLen;
1016          done = true;
1017        }
1018        Partitions.Add(TIntPr(CurrStart, CurrEnd));
1019        CurrStart = CurrEnd;
1020      }
1021    }
1022  }
1023  #ifdef GCC_ATOMIC
1024  PNEANetMP TMMNet::ToNetworkMP(TStrV& CrossNetNames) {
1025    TStrIntH CrossNetStart;
1026    THashSet<TInt> ModeSet;
1027    int offset = 0;
1028    int NumEdges = 0;
1029    TVec<TCrossNet> CrossNets;
1030    for (int i=0; i < CrossNetNames.Len(); i++) {
1031      CrossNets.Add(GetCrossNetByName(CrossNetNames[i]));
1032      CrossNetStart.AddDat(CrossNetNames[i], offset);
1033      TCrossNet& CrossNet = GetCrossNetByName(CrossNetNames[i]);
1034      int factor = CrossNet.IsDirected() ? 1 : 2;
1035      offset += (CrossNet.GetMxEId() * factor);
1036      NumEdges += (CrossNet.GetEdges() * factor);
1037      ModeSet.AddKey(CrossNet.GetMode1());
1038      ModeSet.AddKey(CrossNet.GetMode2());
1039    }
1040    int MxEId = offset;
1041    int NumNodes = 0;
1042    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1043      TModeNet& ModeNet = GetModeNetById(MI.GetKey());
1044      NumNodes += ModeNet.GetNodes();
1045    }
1046    THashMP<TIntPr, TInt> NodeMap(NumNodes);
1047    THashMP<TIntPr, TIntPr> EdgeMap(NumEdges);
1048    PNEANetMP NewNet = TNEANetMP::New(NumNodes, NumEdges);
1049    int num_threads = omp_get_max_threads();
1050    offset = 0;
1051    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1052      TInt ModeId = MI.GetKey();
1053      TModeNet& ModeNet = GetModeNetById(ModeId);
1054      TIntV KeyIds;
1055      ModeNet.NodeH.GetKeyV(KeyIds);
1056      TIntPrV NodePartitions;
1057      GetPartitionRanges(NodePartitions, num_threads, KeyIds.Len());
1058      int curr_nid;
1059      #pragma omp parallel for schedule(static) private(curr_nid)
1060      for (int i = 0; i < NodePartitions.Len(); i++) {
1061        TInt CurrStart = NodePartitions[i].GetVal1();
1062        TInt CurrEnd = NodePartitions[i].GetVal2();
1063        curr_nid = offset + CurrStart;
1064        for (int idx = CurrStart; idx < CurrEnd ; idx++) {
1065          int n_i = KeyIds[idx];
1066          if (ModeNet.IsNode(n_i)) {
1067            TIntV InNbrs;
1068            TIntV OutNbrs;
1069            for (int j=0; j < CrossNetNames.Len(); j++) {
1070              TStr CrossNetName = TStr(CrossNetNames[j].CStr());
1071              if (ModeNet.NeighborTypes.IsKey(CrossNetName)) {
1072                if (ModeNet.NeighborTypes.GetDat(CrossNetName)) {
1073                  TIntV Neighbors;
1074                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, Neighbors);
1075                  int edge_offset = CrossNetStart.GetDat(CrossNetName);
1076                  TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1077                  bool isDir = CrossNet.IsDirected();
1078                  bool isOutNbr = CrossNet.GetMode1() == ModeId;
1079                  int factor = isDir ? 1 : 2;
1080                  int id_offset = isDir || isOutNbr ? 0 : 1;
1081                  if (!isDir && CrossNet.GetMode1() == CrossNet.GetMode2()) {
1082                    id_offset = n_i == CrossNet.GetEdge(n_i).GetSrcNId() ? 0 : 1;
1083                  }
1084                  for (int k = 0; k < Neighbors.Len(); k++) {
1085                    if (isOutNbr && id_offset == 0) {
1086                      OutNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1087                    } else {
1088                      InNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1089                    }
1090                    if (!isDir) {
1091                      int opp_offset = id_offset == 1 ? 0 : 1;
1092                      if (isOutNbr && id_offset == 0) {
1093                        InNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1094                      } else {
1095                        OutNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1096                      }
1097                    }
1098                  }
1099                } else {
1100                  TIntV TempOut;
1101                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempOut, true);
1102                  OutNbrs.AddV(TempOut);
1103                  TIntV TempIn;
1104                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempIn, false);
1105                  InNbrs.AddV(TempIn);
1106                }
1107              }
1108            }
1109            NewNet->AddNodeWithEdges(curr_nid, InNbrs, OutNbrs);
1110            TIntPr NodeKey(MI.GetKey(), n_i);
1111            NodeMap.AddDat(NodeKey, curr_nid);
1112            curr_nid++;
1113          }
1114        }
1115      }
1116      offset += KeyIds.Len();
1117    }
1118    NewNet->SetNodes(offset);
1119    for (int j=0; j < CrossNetNames.Len(); j++) {
1120      TStr CrossNetName = CrossNetNames[j];
1121      TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1122      TInt CrossNetId = GetCrossId(CrossNetName);
1123      TInt Mode1 = CrossNet.GetMode1();
1124      TInt Mode2 = CrossNet.GetMode2();
1125      TIntPrV EdgePartitions;
1126      GetPartitionRanges(EdgePartitions, num_threads, CrossNet.MxEId);
1127      int curr_eid;
1128      offset = CrossNetStart.GetDat(CrossNetNames[j]);
1129      int factor = CrossNet.IsDirected() ? 1 : 2;
1130      #pragma omp parallel for schedule(static) private(curr_eid)
1131      for (int i = 0; i < EdgePartitions.Len(); i++) {
1132        TInt CurrStart = EdgePartitions[i].GetVal1();
1133        TInt CurrEnd = EdgePartitions[i].GetVal2();
1134        for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) {
1135          curr_eid = offset + factor*e_i;
1136          if (CrossNet.IsEdge(e_i)) {
1137            int new_eid = curr_eid;
1138            TIntPr EdgeKey(CrossNetId, e_i);
1139            TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i);
1140            int srcNode = edge.GetSrcNId();
1141            int dstNode = edge.GetDstNId();
1142            TIntPr NodeKeySrc(Mode1, srcNode);
1143            TIntPr NodeKeyDst(Mode2, dstNode);
1144            int newSrc = NodeMap.GetDat(NodeKeySrc);
1145            int newDst = NodeMap.GetDat(NodeKeyDst);
1146            NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst);
1147            curr_eid++;
1148            int otherEId = -1;
1149            if (!CrossNet.IsDirected()) {
1150              otherEId = curr_eid;
1151              NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc);
1152            }
1153            EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId));
1154          }
1155        }
1156      }
1157    }
1158    NewNet->SetEdges(MxEId);
1159    NewNet->ReserveAttr(2, 0, 0, 2, 0, 0);
1160    NewNet->AddIntAttrN(TStr("Mode"));
1161    NewNet->AddIntAttrN(TStr("Id"));
1162    NewNet->AddIntAttrE(TStr("CrossNet"));
1163    NewNet->AddIntAttrE(TStr("Id"));
1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
1169      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal2(), TStr("Id"));
1170    }
1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1176      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1177      if (EdgeMap.GetDat(NewEdgeIds[i]).GetVal2() != -1) {
1178        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1179        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1180      }
1181    }
1182    return NewNet;
1183  }
1184  #endif 
1185  int TMMNet::AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId) {
1186    for (int i = 0; i < Attrs.Len(); i++) {
1187      TStr OrigAttr = Attrs[i].Val1;
1188      TStr NewAttr = Attrs[i].Val2;
1189      int type = Net.GetAttrTypeN(OrigAttr);
1190      if (type == TModeNet::IntType) {
1191        TIntPr OldNId(ModeId, oldId);
1192        TInt Val = Net.GetIntAttrDatN(oldId, OrigAttr);
1193        NewNet->AddIntAttrDatN(NId, Val, NewAttr);
1194      } else if (type == TModeNet::FltType) {
1195        TIntPr OldNId(ModeId, oldId);
1196        TFlt Val = Net.GetFltAttrDatN(oldId, OrigAttr);
1197        NewNet->AddFltAttrDatN(NId, Val, NewAttr);
1198      } else if (type == TModeNet::StrType) {
1199        TIntPr OldNId(ModeId, oldId);
1200        TStr Val = Net.GetStrAttrDatN(oldId, OrigAttr);
1201        NewNet->AddStrAttrDatN(NId, Val, NewAttr);
1202      } else if (type == TModeNet::IntVType) {
1203        TIntPr OldNId(ModeId, oldId);
1204        TIntV Val = Net.GetIntVAttrDatN(oldId, OrigAttr);
1205        NewNet->AddIntVAttrDatN(NId, Val, NewAttr);
1206      }
1207    }
1208    return 0;
1209  }
1210  int TMMNet::AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId) {
1211    for (int i = 0; i < Attrs.Len(); i++) {
1212      TStr OrigAttr = Attrs[i].Val1;
1213      TStr NewAttr = Attrs[i].Val2;
1214      int type = Net.GetAttrTypeE(OrigAttr);
1215      if (type == TCrossNet::IntType) {
1216        TIntPr OldNId(CrossId, oldId);
1217        TInt Val = Net.GetIntAttrDatE(oldId, OrigAttr);
1218        NewNet->AddIntAttrDatE(EId, Val, NewAttr);
1219      } else if (type == TCrossNet::FltType) {
1220        TIntPr OldNId(CrossId, oldId);
1221        TFlt Val = Net.GetFltAttrDatE(oldId, OrigAttr);
1222        NewNet->AddFltAttrDatE(EId, Val, NewAttr);
1223      } else if (type == TCrossNet::StrType) {
1224        TIntPr OldNId(CrossId, oldId);
1225        TStr Val = Net.GetStrAttrDatE(oldId, OrigAttr);
1226        NewNet->AddStrAttrDatE(EId, Val, NewAttr);
1227      }
1228    }
1229    return 0;
1230  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &box = part.bounding_box();
</pre></code></div>
                <div class="column column_space"><pre><code>598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    