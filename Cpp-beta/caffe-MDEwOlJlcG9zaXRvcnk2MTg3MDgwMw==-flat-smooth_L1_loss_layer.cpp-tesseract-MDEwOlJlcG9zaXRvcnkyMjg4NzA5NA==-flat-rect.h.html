
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.134020618556702%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-smooth_L1_loss_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/layers/smooth_L1_loss_layer.hpp"
3  #include "caffe/util/math_functions.hpp"
4  namespace caffe {
5  template <typename Dtype>
6  void SmoothL1LossLayer<Dtype>::LayerSetUp(
7    const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
8    SmoothL1LossParameter loss_param = this->layer_param_.smooth_l1_loss_param();
9    sigma2_ = loss_param.sigma() * loss_param.sigma();
10    has_weights_ = (bottom.size() >= 3);
11    if (has_weights_) {
12      CHECK_EQ(bottom.size(), 4) << "If weights are used, must specify both inside and outside weights";
13    }
14  }
15  template <typename Dtype>
16  void SmoothL1LossLayer<Dtype>::Reshape(
17    const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
18    LossLayer<Dtype>::Reshape(bottom, top);
19    CHECK_EQ(bottom[0]->channels(), bottom[1]->channels());
20    CHECK_EQ(bottom[0]->height(), bottom[1]->height());
21    CHECK_EQ(bottom[0]->width(), bottom[1]->width());
22    if (has_weights_) {
23      CHECK_EQ(bottom[0]->channels(), bottom[2]->channels());
24      CHECK_EQ(bottom[0]->height(), bottom[2]->height());
25      CHECK_EQ(bottom[0]->width(), bottom[2]->width());
26      CHECK_EQ(bottom[0]->channels(), bottom[3]->channels());
27      CHECK_EQ(bottom[0]->height(), bottom[3]->height());
28      CHECK_EQ(bottom[0]->width(), bottom[3]->width());
29    }
<span onclick='openModal()' class='match'>30    diff_.Reshape(bottom[0]->num(), bottom[0]->channels(),
31        bottom[0]->height(), bottom[0]->width());
32    errors_.Reshape(bottom[0]->num(), bottom[0]->channels(),
33        bottom[0]->height(), bottom[0]->width());
34    ones_.Reshape(bottom[0]->num(), bottom[0]->channels(),
35        bottom[0]->height(), bottom[0]->width());
</span>36    for (int i = 0; i < bottom[0]->count(); ++i) {
37      ones_.mutable_cpu_data()[i] = Dtype(1);
38    }
39  }
40  template <typename Dtype>
41  void SmoothL1LossLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) 
42  {
43      int count = bottom[0]->count();
44      caffe_sub(count, bottom[0]->cpu_data(), bottom[1]->cpu_data(), diff_.mutable_cpu_data());    
45      if (has_weights_) {
46          caffe_mul(count, bottom[2]->cpu_data(), diff_.cpu_data(), diff_.mutable_cpu_data());  
47      }
48      for(int i = 0; i < count; i++) {
49          Dtype val = diff_.cpu_data()[i];
50          Dtype abs_val = fabs(val);
51          if (abs_val < 1.0 / sigma2_) {
52             errors_.mutable_cpu_data()[i] = 0.5 * val * val * sigma2_;
53          } 
54          else {
55             errors_.mutable_cpu_data()[i] = abs_val - 0.5 / sigma2_;
56          }
57      }
58      if (has_weights_) {
59          caffe_mul(count, bottom[3]->cpu_data(), errors_.cpu_data(), errors_.mutable_cpu_data());  
60      }
61      Dtype loss = caffe_cpu_dot(count, ones_.cpu_data(), errors_.cpu_data());
62      Dtype normalizer = Dtype(bottom[0]->num());
63      if (this->layer_param_.loss_param().normalization() == LossParameter_NormalizationMode_NONE)
64        normalizer = 1.f;
65  #ifdef USE_MLSL
66      else {
67        normalizer *= mn::get_group_size();
68      }
69  #endif
70      top[0]->mutable_cpu_data()[0] = loss / normalizer;
71  }
72  template <typename Dtype>
73  void SmoothL1LossLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top, const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) 
74  {
75      int count = diff_.count();
76      Dtype normalizer = Dtype(bottom[0]->num());
77      if (this->layer_param_.loss_param().normalization() == LossParameter_NormalizationMode_NONE)
78        normalizer = 1.f;
79  #ifdef USE_MLSL
80      else {
81        normalizer *= mn::get_group_size();
82      }
83  #endif
84      for (int i = 0; i < count; i++) {
85          Dtype val = diff_.cpu_data()[i];
86          Dtype abs_val = fabs(val);
87          if (abs_val < 1.0 / sigma2_) {
88            diff_.mutable_cpu_data()[i] = sigma2_ * val;
89          } 
90          else {
91            diff_.mutable_cpu_data()[i] = (Dtype(0) < val) - (val < Dtype(0));
92          }
93      }
94      for (int i = 0; i < 2; ++i) {
95          if (propagate_down[i])  {
96              const Dtype sign = (i == 0) ? 1 : -1;
97              const Dtype alpha = sign * top[0]->cpu_diff()[0] / normalizer;
98              caffe_cpu_axpby(
99                count,                           
100                alpha,                           
101                diff_.cpu_data(),                
102                Dtype(0),                        
103                bottom[i]->mutable_cpu_diff());  
104              if (has_weights_)  {
105                  caffe_mul(
106                      count,
107                      bottom[2]->cpu_data(),
108                      bottom[i]->cpu_diff(),
109                      bottom[i]->mutable_cpu_diff());
110                  caffe_mul(
111                      count,
112                      bottom[3]->cpu_data(),
113                      bottom[i]->cpu_diff(),
114                      bottom[i]->mutable_cpu_diff());
115              }
116          }
117      }
118  }
119  #ifdef CPU_ONLY
120  STUB_GPU(SmoothL1LossLayer);
121  #endif
122  INSTANTIATE_CLASS(SmoothL1LossLayer);
123  REGISTER_LAYER_CLASS(SmoothL1Loss);
124  }  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-rect.h</h3>
            <pre><code>1  #ifndef RECT_H
2  #define RECT_H
3  #include "points.h"     
4  #include "scrollview.h" 
5  #include "tesstypes.h"  
6  #include "tprintf.h"    
7  #include <tesseract/export.h> 
8  #include <algorithm> 
9  #include <cmath>     
10  #include <cstdint>   
11  #include <cstdio>    
12  #include <string>    
13  namespace tesseract {
14  class TESS_API TBOX { 
15  public:
16    TBOX()
17        : 
18        bot_left(INT16_MAX, INT16_MAX)
19        , top_right(-INT16_MAX, -INT16_MAX) {}
20    TBOX(                  
21        const ICOORD pt1,  
22        const ICOORD pt2); 
23    /&bsol;*********************************************************************
24    /&bsol;*********************************************************************
25    TBOX( 
26        TDimension left, TDimension bottom, TDimension right, TDimension top)
27        : bot_left(left, bottom), top_right(right, top) {}
28    TBOX( 
29        const FCOORD pt);
30    bool null_box() const { 
31      return ((left() >= right()) || (top() <= bottom()));
32    }
33    bool operator==(const TBOX &other) const {
34      return bot_left == other.bot_left && top_right == other.top_right;
35    }
36    TDimension top() const { 
37      return top_right.y();
38    }
39    void set_top(int y) {
40      top_right.set_y(y);
41    }
42    TDimension bottom() const { 
43      return bot_left.y();
44    }
45    void set_bottom(int y) {
46      bot_left.set_y(y);
47    }
48    TDimension left() const { 
49      return bot_left.x();
50    }
51    void set_left(int x) {
52      bot_left.set_x(x);
53    }
54    TDimension right() const { 
55      return top_right.x();
56    }
57    void set_right(int x) {
58      top_right.set_x(x);
59    }
60    int x_middle() const {
61      return (bot_left.x() + top_right.x()) / 2;
62    }
63    int y_middle() const {
64      return (bot_left.y() + top_right.y()) / 2;
65    }
66    const ICOORD &botleft() const { 
67      return bot_left;
68    }
69    ICOORD botright() const { 
70      return ICOORD(top_right.x(), bot_left.y());
71    }
72    ICOORD topleft() const { 
73      return ICOORD(bot_left.x(), top_right.y());
74    }
75    const ICOORD &topright() const { 
76      return top_right;
77    }
78    TDimension height() const { 
79      if (!null_box()) {
80        return top_right.y() - bot_left.y();
81      } else {
82        return 0;
83      }
84    }
85    TDimension width() const { 
86      if (!null_box()) {
87        return top_right.x() - bot_left.x();
88      } else {
89        return 0;
90      }
91    }
92    int32_t area() const { 
93      if (!null_box()) {
94        return width() * height();
95      } else {
96        return 0;
97      }
98    }
99    void pad(int xpad, int ypad) {
100      ICOORD pad(xpad, ypad);
101      bot_left -= pad;
102      top_right += pad;
103    }
104    void move_bottom_edge( 
105        const TDimension y) { 
106      bot_left += ICOORD(0, y);
107    }
108    void move_left_edge(   
109        const TDimension x) { 
110      bot_left += ICOORD(x, 0);
111    }
112    void move_right_edge(  
113        const TDimension x) { 
114      top_right += ICOORD(x, 0);
115    }
116    void move_top_edge(    
117        const TDimension y) { 
118      top_right += ICOORD(0, y);
119    }
120    void move(              
121        const ICOORD vec) { 
122      bot_left += vec;
123      top_right += vec;
124    }
125    void move(              
126        const FCOORD vec) { 
<span onclick='openModal()' class='match'>127      bot_left.set_x(static_cast<TDimension>(std::floor(bot_left.x() + vec.x())));
128      bot_left.set_y(static_cast<TDimension>(std::floor(bot_left.y() + vec.y())));
129      top_right.set_x(static_cast<TDimension>(std::ceil(top_right.x() + vec.x())));
</span>130      top_right.set_y(static_cast<TDimension>(std::ceil(top_right.y() + vec.y())));
131    }
132    void scale(          
133        const float f) { 
134      bot_left.set_x(static_cast<TDimension>(std::floor(bot_left.x() * f)));
135      bot_left.set_y(static_cast<TDimension>(std::floor(bot_left.y() * f)));
136      top_right.set_x(static_cast<TDimension>(std::ceil(top_right.x() * f)));
137      top_right.set_y(static_cast<TDimension>(std::ceil(top_right.y() * f)));
138    }
139    void scale(             
140        const FCOORD vec) { 
141      bot_left.set_x(static_cast<TDimension>(std::floor(bot_left.x() * vec.x())));
142      bot_left.set_y(static_cast<TDimension>(std::floor(bot_left.y() * vec.y())));
143      top_right.set_x(static_cast<TDimension>(std::ceil(top_right.x() * vec.x())));
144      top_right.set_y(static_cast<TDimension>(std::ceil(top_right.y() * vec.y())));
145    }
146    void rotate(const FCOORD &vec) { 
147      bot_left.rotate(vec);
148      top_right.rotate(vec);
149      *this = TBOX(bot_left, top_right);
150    }
151    void rotate_large(const FCOORD &vec);
152    bool contains( 
153        const FCOORD pt) const;
154    bool contains( 
155        const TBOX &box) const;
156    bool overlap( 
157        const TBOX &box) const;
158    bool major_overlap( 
159        const TBOX &box) const;
160    bool x_overlap(const TBOX &box) const;
161    int x_gap(const TBOX &box) const {
162      return std::max(bot_left.x(), box.bot_left.x()) - std::min(top_right.x(), box.top_right.x());
163    }
164    int y_gap(const TBOX &box) const {
165      return std::max(bot_left.y(), box.bot_left.y()) - std::min(top_right.y(), box.top_right.y());
166    }
167    bool major_x_overlap(const TBOX &box) const;
168    bool y_overlap(const TBOX &box) const;
169    bool major_y_overlap(const TBOX &box) const;
170    double overlap_fraction(const TBOX &box) const;
171    double x_overlap_fraction(const TBOX &box) const;
172    double y_overlap_fraction(const TBOX &box) const;
173    bool x_almost_equal(const TBOX &box, int tolerance) const;
174    bool almost_equal(const TBOX &box, int tolerance) const;
175    TBOX intersection( 
176        const TBOX &box) const;
177    TBOX bounding_union( 
178        const TBOX &box) const;
179    void set_to_given_coords(int x_min, int y_min, int x_max, int y_max) {
180      bot_left.set_x(x_min);
181      bot_left.set_y(y_min);
182      top_right.set_x(x_max);
183      top_right.set_y(y_max);
184    }
185    void print() const { 
186      tprintf("Bounding box=(%d,%d)->(%d,%d)\n", left(), bottom(), right(), top());
187    }
188    void print_to_str(std::string &str) const;
189  #ifndef GRAPHICS_DISABLED
190    void plot(                  
191        ScrollView *fd) const { 
192      fd->Rectangle(bot_left.x(), bot_left.y(), top_right.x(), top_right.y());
193    }
194    void plot(                                  
195        ScrollView *fd,                         
196        ScrollView::Color fill_colour,          
197        ScrollView::Color border_colour) const; 
198  #endif
199    bool Serialize(FILE *fp) const;
200    bool Serialize(TFile *fp) const;
201    bool DeSerialize(bool swap, FILE *fp);
202    bool DeSerialize(TFile *fp);
203    friend TBOX &operator+=(TBOX &, const TBOX &);
204    friend TBOX &operator&=(TBOX &, const TBOX &);
205  private:
206    ICOORD bot_left;  
207    ICOORD top_right; 
208  };
209  inline TBOX::TBOX(  
210      const FCOORD pt 
211  ) {
212    bot_left =
213        ICOORD(static_cast<TDimension>(std::floor(pt.x())), static_cast<TDimension>(std::floor(pt.y())));
214    top_right =
215        ICOORD(static_cast<TDimension>(std::ceil(pt.x())), static_cast<TDimension>(std::ceil(pt.y())));
216  }
217  inline bool TBOX::contains(const FCOORD pt) const {
218    return ((pt.x() >= bot_left.x()) && (pt.x() <= top_right.x()) && (pt.y() >= bot_left.y()) &&
219            (pt.y() <= top_right.y()));
220  }
221  inline bool TBOX::contains(const TBOX &box) const {
222    return (contains(box.bot_left) && contains(box.top_right));
223  }
224  inline bool TBOX::overlap( 
225      const TBOX &box) const {
226    return ((box.bot_left.x() <= top_right.x()) && (box.top_right.x() >= bot_left.x()) &&
227            (box.bot_left.y() <= top_right.y()) && (box.top_right.y() >= bot_left.y()));
228  }
229  inline bool TBOX::major_overlap( 
230      const TBOX &box) const {
231    int overlap = std::min(box.top_right.x(), top_right.x());
232    overlap -= std::max(box.bot_left.x(), bot_left.x());
233    overlap += overlap;
234    if (overlap < std::min(box.width(), width())) {
235      return false;
236    }
237    overlap = std::min(box.top_right.y(), top_right.y());
238    overlap -= std::max(box.bot_left.y(), bot_left.y());
239    overlap += overlap;
240    if (overlap < std::min(box.height(), height())) {
241      return false;
242    }
243    return true;
244  }
245  inline double TBOX::overlap_fraction(const TBOX &box) const {
246    double fraction = 0.0;
247    if (this->area()) {
248      fraction = this->intersection(box).area() * 1.0 / this->area();
249    }
250    return fraction;
251  }
252  inline bool TBOX::x_overlap(const TBOX &box) const {
253    return ((box.bot_left.x() <= top_right.x()) && (box.top_right.x() >= bot_left.x()));
254  }
255  inline bool TBOX::major_x_overlap(const TBOX &box) const {
256    TDimension overlap = box.width();
257    if (this->left() > box.left()) {
258      overlap -= this->left() - box.left();
259    }
260    if (this->right() < box.right()) {
261      overlap -= box.right() - this->right();
262    }
263    return (overlap >= box.width() / 2 || overlap >= this->width() / 2);
264  }
265  inline bool TBOX::y_overlap(const TBOX &box) const {
266    return ((box.bot_left.y() <= top_right.y()) && (box.top_right.y() >= bot_left.y()));
267  }
268  inline bool TBOX::major_y_overlap(const TBOX &box) const {
269    TDimension overlap = box.height();
270    if (this->bottom() > box.bottom()) {
271      overlap -= this->bottom() - box.bottom();
272    }
273    if (this->top() < box.top()) {
274      overlap -= box.top() - this->top();
275    }
276    return (overlap >= box.height() / 2 || overlap >= this->height() / 2);
277  }
278  inline double TBOX::x_overlap_fraction(const TBOX &other) const {
279    int low = std::max(left(), other.left());
280    int high = std::min(right(), other.right());
281    int width = right() - left();
282    if (width == 0) {
283      int x = left();
284      if (other.left() <= x && x <= other.right()) {
285        return 1.0;
286      } else {
287        return 0.0;
288      }
289    } else {
290      return std::max(0.0, static_cast<double>(high - low) / width);
291    }
292  }
293  inline double TBOX::y_overlap_fraction(const TBOX &other) const {
294    int low = std::max(bottom(), other.bottom());
295    int high = std::min(top(), other.top());
296    int height = top() - bottom();
297    if (height == 0) {
298      int y = bottom();
299      if (other.bottom() <= y && y <= other.top()) {
300        return 1.0;
301      } else {
302        return 0.0;
303      }
304    } else {
305      return std::max(0.0, static_cast<double>(high - low) / height);
306    }
307  }
308  } 
309  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-smooth_L1_loss_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-rect.h</div>
                </div>
                <div class="column column_space"><pre><code>30    diff_.Reshape(bottom[0]->num(), bottom[0]->channels(),
31        bottom[0]->height(), bottom[0]->width());
32    errors_.Reshape(bottom[0]->num(), bottom[0]->channels(),
33        bottom[0]->height(), bottom[0]->width());
34    ones_.Reshape(bottom[0]->num(), bottom[0]->channels(),
35        bottom[0]->height(), bottom[0]->width());
</pre></code></div>
                <div class="column column_space"><pre><code>127      bot_left.set_x(static_cast<TDimension>(std::floor(bot_left.x() + vec.x())));
128      bot_left.set_y(static_cast<TDimension>(std::floor(bot_left.y() + vec.y())));
129      top_right.set_x(static_cast<TDimension>(std::ceil(top_right.x() + vec.x())));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    