
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.695652173913043%, Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanedg.cpp</h3>
            <pre><code>1  #include "scanedg.h"
2  #include "crakedge.h"
3  #include "edgloop.h"
4  #include "pdblock.h"
5  #include <allheaders.h>
6  #include <memory> 
7  namespace tesseract {
8  #define WHITE_PIX 1 &bsol;*thresholded colours */
9  #define BLACK_PIX 0
10  #define FLIP_COLOUR(pix) (1 - (pix))
11  struct CrackPos {
12    CRACKEDGE **free_cracks; 
13    int x;                   
14    int y;
15  };
<span onclick='openModal()' class='match'>16  static void free_crackedges(CRACKEDGE *start);
17  static void join_edges(CRACKEDGE *edge1, CRACKEDGE *edge2, CRACKEDGE **free_cracks,
18                         C_OUTLINE_IT *outline_it);
19  static void line_edges(TDimension x, TDimension y, TDimension xext, uint8_t uppercolour, uint8_t *bwpos,
20                         CRACKEDGE **prevline, CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it);
21  static void make_margins(PDBLK *block, BLOCK_LINE_IT *line_it, uint8_t *pixels, uint8_t margin,
22                           TDimension left, TDimension right, TDimension y);
</span>23  static CRACKEDGE *h_edge(int sign, CRACKEDGE *join, CrackPos *pos);
24  static CRACKEDGE *v_edge(int sign, CRACKEDGE *join, CrackPos *pos);
25  void block_edges(Image t_pix,   
26                   PDBLK *block, 
27                   C_OUTLINE_IT *outline_it) {
28    ICOORD bleft; 
29    ICOORD tright;
30    BLOCK_LINE_IT line_it = block; 
31    int width = pixGetWidth(t_pix);
32    int height = pixGetHeight(t_pix);
33    int wpl = pixGetWpl(t_pix);
34    std::unique_ptr<CRACKEDGE *[]> ptrline(new CRACKEDGE *[width + 1]);
35    CRACKEDGE *free_cracks = nullptr;
36    block->bounding_box(bleft, tright); 
37    ASSERT_HOST(tright.x() <= width);
38    ASSERT_HOST(tright.y() <= height);
39    int block_width = tright.x() - bleft.x();
40    for (int x = block_width; x >= 0; x--) {
41      ptrline[x] = nullptr; 
42    }
43    std::unique_ptr<uint8_t[]> bwline(new uint8_t[width]);
44    const uint8_t margin = WHITE_PIX;
45    for (int y = tright.y() - 1; y >= bleft.y() - 1; y--) {
46      if (y >= bleft.y() && y < tright.y()) {
47        l_uint32 *line = pixGetData(t_pix) + wpl * (height - 1 - y);
48        for (int x = 0; x < block_width; ++x) {
49          bwline[x] = GET_DATA_BIT(line, x + bleft.x()) ^ 1;
50        }
51        make_margins(block, &line_it, bwline.get(), margin, bleft.x(), tright.x(), y);
52      } else {
53        memset(bwline.get(), margin, block_width * sizeof(bwline[0]));
54      }
55      line_edges(bleft.x(), y, block_width, margin, bwline.get(), ptrline.get(), &free_cracks,
56                 outline_it);
57    }
58    free_crackedges(free_cracks); 
59  }
60  static void make_margins(   
61      PDBLK *block,           
62      BLOCK_LINE_IT *line_it, 
63      uint8_t *pixels,        
64      uint8_t margin,         
65      TDimension left,        
66      TDimension right,
67      TDimension y            
68  ) {
69    ICOORDELT_IT seg_it;
70    if (block->poly_block() != nullptr) {
71      std::unique_ptr<PB_LINE_IT> lines(new PB_LINE_IT(block->poly_block()));
72      const std::unique_ptr<&bsol;*non-const*/ ICOORDELT_LIST> segments(lines->get_line(y));
73      if (!segments->empty()) {
74        seg_it.set_to_list(segments.get());
75        seg_it.mark_cycle_pt();
76        auto start = seg_it.data()->x();
77        auto xext = seg_it.data()->y();
78        for (auto xindex = left; xindex < right; xindex++) {
79          if (xindex >= start && !seg_it.cycled_list()) {
80            xindex = start + xext - 1;
81            seg_it.forward();
82            start = seg_it.data()->x();
83            xext = seg_it.data()->y();
84          } else {
85            pixels[xindex - left] = margin;
86          }
87        }
88      } else {
89        for (auto xindex = left; xindex < right; xindex++) {
90          pixels[xindex - left] = margin;
91        }
92      }
93    } else {
94      TDimension xext;  
95      auto start = line_it->get_line(y, xext);
96      for (auto xindex = left; xindex < start; xindex++) {
97        pixels[xindex - left] = margin;
98      }
99      for (auto xindex = start + xext; xindex < right; xindex++) {
100        pixels[xindex - left] = margin;
101      }
102    }
103  }
104  static void line_edges(TDimension x,         
105                         TDimension y,         
106                         TDimension xext,      
107                         uint8_t uppercolour,  
108                         uint8_t *bwpos,       
109                         CRACKEDGE **prevline, 
110                         CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it) {
111    CrackPos pos = {free_cracks, x, y};
112    int xmax;              
113    int prevcolour;        
114    CRACKEDGE *current;    
115    CRACKEDGE *newcurrent; 
116    xmax = x + xext;          
117    prevcolour = uppercolour; 
118    current = nullptr;        
119    for (; pos.x < xmax; pos.x++, prevline++) {
120      const int colour = *bwpos++; 
121      if (*prevline != nullptr) {
122        uppercolour = FLIP_COLOUR(uppercolour);
123        if (colour == prevcolour) {
124          if (colour == uppercolour) {
125            join_edges(current, *prevline, free_cracks, outline_it);
126            current = nullptr; 
127          } else {
128            current = h_edge(uppercolour - colour, *prevline, &pos);
129          }
130          *prevline = nullptr; 
131        } else {
132          if (colour == uppercolour) {
133            *prevline = v_edge(colour - prevcolour, *prevline, &pos);
134          } else if (colour == WHITE_PIX) {
135            join_edges(current, *prevline, free_cracks, outline_it);
136            current = h_edge(uppercolour - colour, nullptr, &pos);
137            *prevline = v_edge(colour - prevcolour, current, &pos);
138          } else {
139            newcurrent = h_edge(uppercolour - colour, *prevline, &pos);
140            *prevline = v_edge(colour - prevcolour, current, &pos);
141            current = newcurrent; 
142          }
143          prevcolour = colour; 
144        }
145      } else {
146        if (colour != prevcolour) {
147          *prevline = current = v_edge(colour - prevcolour, current, &pos);
148          prevcolour = colour;
149        }
150        if (colour != uppercolour) {
151          current = h_edge(uppercolour - colour, current, &pos);
152        } else {
153          current = nullptr; 
154        }
155      }
156    }
157    if (current != nullptr) {
158      if (*prevline != nullptr) { 
159        join_edges(current, *prevline, free_cracks, outline_it);
160        *prevline = nullptr; 
161      } else {
162        *prevline = v_edge(FLIP_COLOUR(prevcolour) - prevcolour, current, &pos);
163      }
164    } else if (*prevline != nullptr) {
165      *prevline = v_edge(FLIP_COLOUR(prevcolour) - prevcolour, *prevline, &pos);
166    }
167  }
168  static CRACKEDGE *h_edge(int sign,        
169                           CRACKEDGE *join, 
170                           CrackPos *pos) {
171    CRACKEDGE *newpt; 
172    if (*pos->free_cracks != nullptr) {
173      newpt = *pos->free_cracks;
174      *pos->free_cracks = newpt->next; 
175    } else {
176      newpt = new CRACKEDGE;
177    }
178    newpt->pos.set_y(pos->y + 1); 
179    newpt->stepy = 0;             
180    if (sign > 0) {
181      newpt->pos.set_x(pos->x + 1); 
182      newpt->stepx = -1;
183      newpt->stepdir = 0;
184    } else {
185      newpt->pos.set_x(pos->x); 
186      newpt->stepx = 1;
187      newpt->stepdir = 2;
188    }
189    if (join == nullptr) {
190      newpt->next = newpt; 
191      newpt->prev = newpt;
192    } else {
193      if (newpt->pos.x() + newpt->stepx == join->pos.x() && newpt->pos.y() == join->pos.y()) {
194        newpt->prev = join->prev; 
195        newpt->prev->next = newpt;
196        newpt->next = join; 
197        join->prev = newpt;
198      } else {
199        newpt->next = join->next; 
200        newpt->next->prev = newpt;
201        newpt->prev = join; 
202        join->next = newpt;
203      }
204    }
205    return newpt;
206  }
207  static CRACKEDGE *v_edge(int sign, 
208                           CRACKEDGE *join, CrackPos *pos) {
209    CRACKEDGE *newpt; 
210    if (*pos->free_cracks != nullptr) {
211      newpt = *pos->free_cracks;
212      *pos->free_cracks = newpt->next; 
213    } else {
214      newpt = new CRACKEDGE;
215    }
216    newpt->pos.set_x(pos->x); 
217    newpt->stepx = 0;         
218    if (sign > 0) {
219      newpt->pos.set_y(pos->y); 
220      newpt->stepy = 1;
221      newpt->stepdir = 3;
222    } else {
223      newpt->pos.set_y(pos->y + 1); 
224      newpt->stepy = -1;
225      newpt->stepdir = 1;
226    }
227    if (join == nullptr) {
228      newpt->next = newpt; 
229      newpt->prev = newpt;
230    } else {
231      if (newpt->pos.x() == join->pos.x() && newpt->pos.y() + newpt->stepy == join->pos.y()) {
232        newpt->prev = join->prev; 
233        newpt->prev->next = newpt;
234        newpt->next = join; 
235        join->prev = newpt;
236      } else {
237        newpt->next = join->next; 
238        newpt->next->prev = newpt;
239        newpt->prev = join; 
240        join->next = newpt;
241      }
242    }
243    return newpt;
244  }
245  static void join_edges(CRACKEDGE *edge1, 
246                         CRACKEDGE *edge2, 
247                         CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it) {
248    if (edge1->pos.x() + edge1->stepx != edge2->pos.x() ||
249        edge1->pos.y() + edge1->stepy != edge2->pos.y()) {
250      CRACKEDGE *tempedge = edge1;
251      edge1 = edge2; 
252      edge2 = tempedge;
253    }
254    if (edge1->next == edge2) {
255      complete_edge(edge1, outline_it);
256      edge1->prev->next = *free_cracks;
257      *free_cracks = edge1; 
258    } else {
259      edge2->prev->next = edge1->next;
260      edge1->next->prev = edge2->prev;
261      edge1->next = edge2; 
262      edge2->prev = edge1;
263    }
264  }
265  static void free_crackedges(CRACKEDGE *start) {
266    CRACKEDGE *current; 
267    CRACKEDGE *next;    
268    for (current = start; current != nullptr; current = next) {
269      next = current->next;
270      delete current; 
271    }
272  }
273  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-low_level_alloc.cc</h3>
            <pre><code>1  #include "absl/base/internal/low_level_alloc.h"
2  #include <type_traits>
3  #include "absl/base/call_once.h"
4  #include "absl/base/config.h"
5  #include "absl/base/internal/direct_mmap.h"
6  #include "absl/base/internal/scheduling_mode.h"
7  #include "absl/base/macros.h"
8  #include "absl/base/thread_annotations.h"
9  #ifndef ABSL_LOW_LEVEL_ALLOC_MISSING
10  #ifndef _WIN32
11  #include <pthread.h>
12  #include <signal.h>
13  #include <sys/mman.h>
14  #include <unistd.h>
15  #else
16  #include <windows.h>
17  #endif
18  #ifdef __linux__
19  #include <sys/prctl.h>
20  #endif
21  #include <string.h>
22  #include <algorithm>
23  #include <atomic>
24  #include <cerrno>
25  #include <cstddef>
26  #include <new>                   
27  #include "absl/base/dynamic_annotations.h"
28  #include "absl/base/internal/raw_logging.h"
29  #include "absl/base/internal/spinlock.h"
30  #if defined(__APPLE__)
31  #if !defined MAP_ANONYMOUS
32  #define MAP_ANONYMOUS MAP_ANON
33  #endif  
34  #endif  
35  namespace absl {
36  ABSL_NAMESPACE_BEGIN
37  namespace base_internal {
38  static const int kMaxLevel = 30;
39  namespace {
40  struct AllocList {
41    struct Header {
42      uintptr_t size;
43      uintptr_t magic;
44      LowLevelAlloc::Arena *arena;
45      void *dummy_for_alignment;
46    } header;
47    int levels;
48    AllocList *next[kMaxLevel];
49  };
50  }  
51  static int IntLog2(size_t size, size_t base) {
52    int result = 0;
53    for (size_t i = size; i > base; i >>= 1) {  
54      result++;
55    }
56    return result;
57  }
58  static int Random(uint32_t *state) {
59    uint32_t r = *state;
60    int result = 1;
61    while ((((r = r*1103515245 + 12345) >> 30) & 1) == 0) {
62      result++;
63    }
64    *state = r;
65    return result;
66  }
67  static int LLA_SkiplistLevels(size_t size, size_t base, uint32_t *random) {
68    size_t max_fit = (size - offsetof(AllocList, next)) / sizeof(AllocList *);
69    int level = IntLog2(size, base) + (random != nullptr ? Random(random) : 1);
70    if (static_cast<size_t>(level) > max_fit) level = static_cast<int>(max_fit);
71    if (level > kMaxLevel-1) level = kMaxLevel - 1;
72    ABSL_RAW_CHECK(level >= 1, "block not big enough for even one level");
73    return level;
74  }
75  static AllocList *LLA_SkiplistSearch(AllocList *head,
76                                       AllocList *e, AllocList **prev) {
77    AllocList *p = head;
78    for (int level = head->levels - 1; level >= 0; level--) {
79      for (AllocList *n; (n = p->next[level]) != nullptr && n < e; p = n) {
80      }
81      prev[level] = p;
82    }
83    return (head->levels == 0) ? nullptr : prev[0]->next[0];
84  }
85  static void LLA_SkiplistInsert(AllocList *head, AllocList *e,
86                                 AllocList **prev) {
87    LLA_SkiplistSearch(head, e, prev);
88    for (; head->levels < e->levels; head->levels++) {  
89      prev[head->levels] = head;                        
90    }
91    for (int i = 0; i != e->levels; i++) {  
92      e->next[i] = prev[i]->next[i];
93      prev[i]->next[i] = e;
94    }
95  }
96  static void LLA_SkiplistDelete(AllocList *head, AllocList *e,
97                                 AllocList **prev) {
98    AllocList *found = LLA_SkiplistSearch(head, e, prev);
99    ABSL_RAW_CHECK(e == found, "element not in freelist");
100    for (int i = 0; i != e->levels && prev[i]->next[i] == e; i++) {
101      prev[i]->next[i] = e->next[i];
102    }
103    while (head->levels > 0 && head->next[head->levels - 1] == nullptr) {
104      head->levels--;   
105    }
106  }
107  struct LowLevelAlloc::Arena {
<span onclick='openModal()' class='match'>108    explicit Arena(uint32_t flags_value);
109    base_internal::SpinLock mu;
110    AllocList freelist ABSL_GUARDED_BY(mu);
111    int32_t allocation_count ABSL_GUARDED_BY(mu);
112    const uint32_t flags;
113    const size_t pagesize;
114    const size_t round_up;
115    const size_t min_size;
116    uint32_t random ABSL_GUARDED_BY(mu);
</span>117  };
118  namespace {
119  alignas(LowLevelAlloc::Arena) unsigned char default_arena_storage[sizeof(
120      LowLevelAlloc::Arena)];
121  alignas(LowLevelAlloc::Arena) unsigned char unhooked_arena_storage[sizeof(
122      LowLevelAlloc::Arena)];
123  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
124  alignas(
125      LowLevelAlloc::Arena) unsigned char unhooked_async_sig_safe_arena_storage
126      [sizeof(LowLevelAlloc::Arena)];
127  #endif
128  absl::once_flag create_globals_once;
129  void CreateGlobalArenas() {
130    new (&default_arena_storage)
131        LowLevelAlloc::Arena(LowLevelAlloc::kCallMallocHook);
132    new (&unhooked_arena_storage) LowLevelAlloc::Arena(0);
133  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
134    new (&unhooked_async_sig_safe_arena_storage)
135        LowLevelAlloc::Arena(LowLevelAlloc::kAsyncSignalSafe);
136  #endif
137  }
138  LowLevelAlloc::Arena* UnhookedArena() {
139    base_internal::LowLevelCallOnce(&create_globals_once, CreateGlobalArenas);
140    return reinterpret_cast<LowLevelAlloc::Arena*>(&unhooked_arena_storage);
141  }
142  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
143  LowLevelAlloc::Arena *UnhookedAsyncSigSafeArena() {
144    base_internal::LowLevelCallOnce(&create_globals_once, CreateGlobalArenas);
145    return reinterpret_cast<LowLevelAlloc::Arena *>(
146        &unhooked_async_sig_safe_arena_storage);
147  }
148  #endif
149  }  
150  LowLevelAlloc::Arena *LowLevelAlloc::DefaultArena() {
151    base_internal::LowLevelCallOnce(&create_globals_once, CreateGlobalArenas);
152    return reinterpret_cast<LowLevelAlloc::Arena*>(&default_arena_storage);
153  }
154  static const uintptr_t kMagicAllocated = 0x4c833e95U;
155  static const uintptr_t kMagicUnallocated = ~kMagicAllocated;
156  namespace {
157  class ABSL_SCOPED_LOCKABLE ArenaLock {
158   public:
159    explicit ArenaLock(LowLevelAlloc::Arena *arena)
160        ABSL_EXCLUSIVE_LOCK_FUNCTION(arena->mu)
161        : arena_(arena) {
162  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
163      if ((arena->flags & LowLevelAlloc::kAsyncSignalSafe) != 0) {
164        sigset_t all;
165        sigfillset(&all);
166        mask_valid_ = pthread_sigmask(SIG_BLOCK, &all, &mask_) == 0;
167      }
168  #endif
169      arena_->mu.Lock();
170    }
171    ~ArenaLock() { ABSL_RAW_CHECK(left_, "haven't left Arena region"); }
172    void Leave() ABSL_UNLOCK_FUNCTION() {
173      arena_->mu.Unlock();
174  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
175      if (mask_valid_) {
176        const int err = pthread_sigmask(SIG_SETMASK, &mask_, nullptr);
177        if (err != 0) {
178          ABSL_RAW_LOG(FATAL, "pthread_sigmask failed: %d", err);
179        }
180      }
181  #endif
182      left_ = true;
183    }
184   private:
185    bool left_ = false;  
186  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
187    bool mask_valid_ = false;
188    sigset_t mask_;  
189  #endif
190    LowLevelAlloc::Arena *arena_;
191    ArenaLock(const ArenaLock &) = delete;
192    ArenaLock &operator=(const ArenaLock &) = delete;
193  };
194  }  
195  inline static uintptr_t Magic(uintptr_t magic, AllocList::Header *ptr) {
196    return magic ^ reinterpret_cast<uintptr_t>(ptr);
197  }
198  namespace {
199  size_t GetPageSize() {
200  #ifdef _WIN32
201    SYSTEM_INFO system_info;
202    GetSystemInfo(&system_info);
203    return std::max(system_info.dwPageSize, system_info.dwAllocationGranularity);
204  #elif defined(__wasm__) || defined(__asmjs__)
205    return getpagesize();
206  #else
207    return static_cast<size_t>(sysconf(_SC_PAGESIZE));
208  #endif
209  }
210  size_t RoundedUpBlockSize() {
211    size_t round_up = 16;
212    while (round_up < sizeof(AllocList::Header)) {
213      round_up += round_up;
214    }
215    return round_up;
216  }
217  }  
218  LowLevelAlloc::Arena::Arena(uint32_t flags_value)
219      : mu(base_internal::SCHEDULE_KERNEL_ONLY),
220        allocation_count(0),
221        flags(flags_value),
222        pagesize(GetPageSize()),
223        round_up(RoundedUpBlockSize()),
224        min_size(2 * round_up),
225        random(0) {
226    freelist.header.size = 0;
227    freelist.header.magic =
228        Magic(kMagicUnallocated, &freelist.header);
229    freelist.header.arena = this;
230    freelist.levels = 0;
231    memset(freelist.next, 0, sizeof(freelist.next));
232  }
233  LowLevelAlloc::Arena *LowLevelAlloc::NewArena(uint32_t flags) {
234    Arena *meta_data_arena = DefaultArena();
235  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
236    if ((flags & LowLevelAlloc::kAsyncSignalSafe) != 0) {
237      meta_data_arena = UnhookedAsyncSigSafeArena();
238    } else  
239  #endif
240        if ((flags & LowLevelAlloc::kCallMallocHook) == 0) {
241      meta_data_arena = UnhookedArena();
242    }
243    Arena *result =
244      new (AllocWithArena(sizeof (*result), meta_data_arena)) Arena(flags);
245    return result;
246  }
247  bool LowLevelAlloc::DeleteArena(Arena *arena) {
248    ABSL_RAW_CHECK(
249        arena != nullptr && arena != DefaultArena() && arena != UnhookedArena(),
250        "may not delete default arena");
251    ArenaLock section(arena);
252    if (arena->allocation_count != 0) {
253      section.Leave();
254      return false;
255    }
256    while (arena->freelist.next[0] != nullptr) {
257      AllocList *region = arena->freelist.next[0];
258      size_t size = region->header.size;
259      arena->freelist.next[0] = region->next[0];
260      ABSL_RAW_CHECK(
261          region->header.magic == Magic(kMagicUnallocated, &region->header),
262          "bad magic number in DeleteArena()");
263      ABSL_RAW_CHECK(region->header.arena == arena,
264                     "bad arena pointer in DeleteArena()");
265      ABSL_RAW_CHECK(size % arena->pagesize == 0,
266                     "empty arena has non-page-aligned block size");
267      ABSL_RAW_CHECK(reinterpret_cast<uintptr_t>(region) % arena->pagesize == 0,
268                     "empty arena has non-page-aligned block");
269      int munmap_result;
270  #ifdef _WIN32
271      munmap_result = VirtualFree(region, 0, MEM_RELEASE);
272      ABSL_RAW_CHECK(munmap_result != 0,
273                     "LowLevelAlloc::DeleteArena: VitualFree failed");
274  #else
275  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
276      if ((arena->flags & LowLevelAlloc::kAsyncSignalSafe) == 0) {
277        munmap_result = munmap(region, size);
278      } else {
279        munmap_result = base_internal::DirectMunmap(region, size);
280      }
281  #else
282      munmap_result = munmap(region, size);
283  #endif  
284      if (munmap_result != 0) {
285        ABSL_RAW_LOG(FATAL, "LowLevelAlloc::DeleteArena: munmap failed: %d",
286                     errno);
287      }
288  #endif  
289    }
290    section.Leave();
291    arena->~Arena();
292    Free(arena);
293    return true;
294  }
295  static inline uintptr_t CheckedAdd(uintptr_t a, uintptr_t b) {
296    uintptr_t sum = a + b;
297    ABSL_RAW_CHECK(sum >= a, "LowLevelAlloc arithmetic overflow");
298    return sum;
299  }
300  static inline uintptr_t RoundUp(uintptr_t addr, uintptr_t align) {
301    return CheckedAdd(addr, align - 1) & ~(align - 1);
302  }
303  static AllocList *Next(int i, AllocList *prev, LowLevelAlloc::Arena *arena) {
304    ABSL_RAW_CHECK(i < prev->levels, "too few levels in Next()");
305    AllocList *next = prev->next[i];
306    if (next != nullptr) {
307      ABSL_RAW_CHECK(
308          next->header.magic == Magic(kMagicUnallocated, &next->header),
309          "bad magic number in Next()");
310      ABSL_RAW_CHECK(next->header.arena == arena, "bad arena pointer in Next()");
311      if (prev != &arena->freelist) {
312        ABSL_RAW_CHECK(prev < next, "unordered freelist");
313        ABSL_RAW_CHECK(reinterpret_cast<char *>(prev) + prev->header.size <
314                           reinterpret_cast<char *>(next),
315                       "malformed freelist");
316      }
317    }
318    return next;
319  }
320  static void Coalesce(AllocList *a) {
321    AllocList *n = a->next[0];
322    if (n != nullptr && reinterpret_cast<char *>(a) + a->header.size ==
323                            reinterpret_cast<char *>(n)) {
324      LowLevelAlloc::Arena *arena = a->header.arena;
325      a->header.size += n->header.size;
326      n->header.magic = 0;
327      n->header.arena = nullptr;
328      AllocList *prev[kMaxLevel];
329      LLA_SkiplistDelete(&arena->freelist, n, prev);
330      LLA_SkiplistDelete(&arena->freelist, a, prev);
331      a->levels = LLA_SkiplistLevels(a->header.size, arena->min_size,
332                                     &arena->random);
333      LLA_SkiplistInsert(&arena->freelist, a, prev);
334    }
335  }
336  static void AddToFreelist(void *v, LowLevelAlloc::Arena *arena) {
337    AllocList *f = reinterpret_cast<AllocList *>(
338                          reinterpret_cast<char *>(v) - sizeof (f->header));
339    ABSL_RAW_CHECK(f->header.magic == Magic(kMagicAllocated, &f->header),
340                   "bad magic number in AddToFreelist()");
341    ABSL_RAW_CHECK(f->header.arena == arena,
342                   "bad arena pointer in AddToFreelist()");
343    f->levels = LLA_SkiplistLevels(f->header.size, arena->min_size,
344                                   &arena->random);
345    AllocList *prev[kMaxLevel];
346    LLA_SkiplistInsert(&arena->freelist, f, prev);
347    f->header.magic = Magic(kMagicUnallocated, &f->header);
348    Coalesce(f);                  
349    Coalesce(prev[0]);            
350  }
351  void LowLevelAlloc::Free(void *v) {
352    if (v != nullptr) {
353      AllocList *f = reinterpret_cast<AllocList *>(
354                          reinterpret_cast<char *>(v) - sizeof (f->header));
355      LowLevelAlloc::Arena *arena = f->header.arena;
356      ArenaLock section(arena);
357      AddToFreelist(v, arena);
358      ABSL_RAW_CHECK(arena->allocation_count > 0, "nothing in arena to free");
359      arena->allocation_count--;
360      section.Leave();
361    }
362  }
363  static void *DoAllocWithArena(size_t request, LowLevelAlloc::Arena *arena) {
364    void *result = nullptr;
365    if (request != 0) {
366      AllocList *s;       
367      ArenaLock section(arena);
368      size_t req_rnd = RoundUp(CheckedAdd(request, sizeof (s->header)),
369                               arena->round_up);
370      for (;;) {      
371        int i = LLA_SkiplistLevels(req_rnd, arena->min_size, nullptr) - 1;
372        if (i < arena->freelist.levels) {   
373          AllocList *before = &arena->freelist;  
374          while ((s = Next(i, before, arena)) != nullptr &&
375                 s->header.size < req_rnd) {
376            before = s;
377          }
378          if (s != nullptr) {       
379            break;
380          }
381        }
382        arena->mu.Unlock();
383        size_t new_pages_size = RoundUp(req_rnd, arena->pagesize * 16);
384        void *new_pages;
385  #ifdef _WIN32
386        new_pages = VirtualAlloc(nullptr, new_pages_size,
387                                 MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
388        ABSL_RAW_CHECK(new_pages != nullptr, "VirtualAlloc failed");
389  #else
390  #ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
391        if ((arena->flags & LowLevelAlloc::kAsyncSignalSafe) != 0) {
392          new_pages = base_internal::DirectMmap(nullptr, new_pages_size,
393              PROT_WRITE|PROT_READ, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
394        } else {
395          new_pages = mmap(nullptr, new_pages_size, PROT_WRITE | PROT_READ,
396                           MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
397        }
398  #else
399        new_pages = mmap(nullptr, new_pages_size, PROT_WRITE | PROT_READ,
400                         MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
401  #endif  
402        if (new_pages == MAP_FAILED) {
403          ABSL_RAW_LOG(FATAL, "mmap error: %d", errno);
404        }
405  #ifdef __linux__
406  #if defined(PR_SET_VMA) && defined(PR_SET_VMA_ANON_NAME)
407        prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, new_pages, new_pages_size,
408              "absl");
409  #endif
410  #endif  
411  #endif  
412        arena->mu.Lock();
413        s = reinterpret_cast<AllocList *>(new_pages);
414        s->header.size = new_pages_size;
415        s->header.magic = Magic(kMagicAllocated, &s->header);
416        s->header.arena = arena;
417        AddToFreelist(&s->levels, arena);  
418      }
419      AllocList *prev[kMaxLevel];
420      LLA_SkiplistDelete(&arena->freelist, s, prev);    
421      if (CheckedAdd(req_rnd, arena->min_size) <= s->header.size) {
422        AllocList *n = reinterpret_cast<AllocList *>
423                          (req_rnd + reinterpret_cast<char *>(s));
424        n->header.size = s->header.size - req_rnd;
425        n->header.magic = Magic(kMagicAllocated, &n->header);
426        n->header.arena = arena;
427        s->header.size = req_rnd;
428        AddToFreelist(&n->levels, arena);
429      }
430      s->header.magic = Magic(kMagicAllocated, &s->header);
431      ABSL_RAW_CHECK(s->header.arena == arena, "");
432      arena->allocation_count++;
433      section.Leave();
434      result = &s->levels;
435    }
436    ABSL_ANNOTATE_MEMORY_IS_UNINITIALIZED(result, request);
437    return result;
438  }
439  void *LowLevelAlloc::Alloc(size_t request) {
440    void *result = DoAllocWithArena(request, DefaultArena());
441    return result;
442  }
443  void *LowLevelAlloc::AllocWithArena(size_t request, Arena *arena) {
444    ABSL_RAW_CHECK(arena != nullptr, "must pass a valid arena");
445    void *result = DoAllocWithArena(request, arena);
446    return result;
447  }
448  }  
449  ABSL_NAMESPACE_END
450  }  
451  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanedg.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-low_level_alloc.cc</div>
                </div>
                <div class="column column_space"><pre><code>16  static void free_crackedges(CRACKEDGE *start);
17  static void join_edges(CRACKEDGE *edge1, CRACKEDGE *edge2, CRACKEDGE **free_cracks,
18                         C_OUTLINE_IT *outline_it);
19  static void line_edges(TDimension x, TDimension y, TDimension xext, uint8_t uppercolour, uint8_t *bwpos,
20                         CRACKEDGE **prevline, CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it);
21  static void make_margins(PDBLK *block, BLOCK_LINE_IT *line_it, uint8_t *pixels, uint8_t margin,
22                           TDimension left, TDimension right, TDimension y);
</pre></code></div>
                <div class="column column_space"><pre><code>108    explicit Arena(uint32_t flags_value);
109    base_internal::SpinLock mu;
110    AllocList freelist ABSL_GUARDED_BY(mu);
111    int32_t allocation_count ABSL_GUARDED_BY(mu);
112    const uint32_t flags;
113    const size_t pagesize;
114    const size_t round_up;
115    const size_t min_size;
116    uint32_t random ABSL_GUARDED_BY(mu);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    