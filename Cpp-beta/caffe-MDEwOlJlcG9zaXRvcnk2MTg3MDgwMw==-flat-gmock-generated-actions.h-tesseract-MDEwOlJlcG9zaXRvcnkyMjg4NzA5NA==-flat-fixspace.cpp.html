
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.042488619119878%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-generated-actions.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
3  #include "gmock/gmock-actions.h"
4  #include "gmock/internal/gmock-port.h"
5  namespace testing {
6  namespace internal {
7  template <typename Result, typename ArgumentTuple>
8  class InvokeHelper;
9  template <typename R>
10  class InvokeHelper<R, ::std::tr1::tuple<> > {
11   public:
12    template <typename Function>
13    static R Invoke(Function function, const ::std::tr1::tuple<>&) {
14      return function();
15    }
16    template <class Class, typename MethodPtr>
17    static R InvokeMethod(Class* obj_ptr,
18                          MethodPtr method_ptr,
19                          const ::std::tr1::tuple<>&) {
20      return (obj_ptr->*method_ptr)();
21    }
22  };
23  template <typename R, typename A1>
24  class InvokeHelper<R, ::std::tr1::tuple<A1> > {
25   public:
26    template <typename Function>
27    static R Invoke(Function function, const ::std::tr1::tuple<A1>& args) {
28      using ::std::tr1::get;
29      return function(get<0>(args));
30    }
31    template <class Class, typename MethodPtr>
32    static R InvokeMethod(Class* obj_ptr,
33                          MethodPtr method_ptr,
34                          const ::std::tr1::tuple<A1>& args) {
35      using ::std::tr1::get;
36      return (obj_ptr->*method_ptr)(get<0>(args));
37    }
38  };
39  template <typename R, typename A1, typename A2>
40  class InvokeHelper<R, ::std::tr1::tuple<A1, A2> > {
41   public:
42    template <typename Function>
43    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2>& args) {
44      using ::std::tr1::get;
45      return function(get<0>(args), get<1>(args));
46    }
47    template <class Class, typename MethodPtr>
48    static R InvokeMethod(Class* obj_ptr,
49                          MethodPtr method_ptr,
50                          const ::std::tr1::tuple<A1, A2>& args) {
51      using ::std::tr1::get;
52      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args));
53    }
54  };
55  template <typename R, typename A1, typename A2, typename A3>
56  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3> > {
57   public:
58    template <typename Function>
59    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2,
60        A3>& args) {
61      using ::std::tr1::get;
62      return function(get<0>(args), get<1>(args), get<2>(args));
63    }
64    template <class Class, typename MethodPtr>
65    static R InvokeMethod(Class* obj_ptr,
66                          MethodPtr method_ptr,
67                          const ::std::tr1::tuple<A1, A2, A3>& args) {
68      using ::std::tr1::get;
69      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args));
70    }
71  };
72  template <typename R, typename A1, typename A2, typename A3, typename A4>
73  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4> > {
74   public:
75    template <typename Function>
76    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3,
77        A4>& args) {
78      using ::std::tr1::get;
79      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args));
80    }
81    template <class Class, typename MethodPtr>
82    static R InvokeMethod(Class* obj_ptr,
83                          MethodPtr method_ptr,
84                          const ::std::tr1::tuple<A1, A2, A3, A4>& args) {
85      using ::std::tr1::get;
86      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
87          get<3>(args));
88    }
89  };
90  template <typename R, typename A1, typename A2, typename A3, typename A4,
91      typename A5>
92  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4, A5> > {
93   public:
94    template <typename Function>
95    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3, A4,
96        A5>& args) {
97      using ::std::tr1::get;
98      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args),
99          get<4>(args));
100    }
101    template <class Class, typename MethodPtr>
102    static R InvokeMethod(Class* obj_ptr,
103                          MethodPtr method_ptr,
104                          const ::std::tr1::tuple<A1, A2, A3, A4, A5>& args) {
105      using ::std::tr1::get;
106      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
107          get<3>(args), get<4>(args));
108    }
109  };
110  template <typename R, typename A1, typename A2, typename A3, typename A4,
111      typename A5, typename A6>
112  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4, A5, A6> > {
113   public:
114    template <typename Function>
115    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3, A4,
116        A5, A6>& args) {
117      using ::std::tr1::get;
118      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args),
119          get<4>(args), get<5>(args));
120    }
121    template <class Class, typename MethodPtr>
122    static R InvokeMethod(Class* obj_ptr,
123                          MethodPtr method_ptr,
124                          const ::std::tr1::tuple<A1, A2, A3, A4, A5, A6>& args) {
125      using ::std::tr1::get;
126      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
127          get<3>(args), get<4>(args), get<5>(args));
128    }
129  };
130  template <typename R, typename A1, typename A2, typename A3, typename A4,
131      typename A5, typename A6, typename A7>
132  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7> > {
133   public:
134    template <typename Function>
135    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3, A4,
136        A5, A6, A7>& args) {
137      using ::std::tr1::get;
138      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args),
139          get<4>(args), get<5>(args), get<6>(args));
140    }
141    template <class Class, typename MethodPtr>
142    static R InvokeMethod(Class* obj_ptr,
143                          MethodPtr method_ptr,
144                          const ::std::tr1::tuple<A1, A2, A3, A4, A5, A6,
145                              A7>& args) {
146      using ::std::tr1::get;
147      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
148          get<3>(args), get<4>(args), get<5>(args), get<6>(args));
149    }
150  };
151  template <typename R, typename A1, typename A2, typename A3, typename A4,
152      typename A5, typename A6, typename A7, typename A8>
153  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7, A8> > {
154   public:
155    template <typename Function>
156    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3, A4,
157        A5, A6, A7, A8>& args) {
158      using ::std::tr1::get;
159      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args),
160          get<4>(args), get<5>(args), get<6>(args), get<7>(args));
161    }
162    template <class Class, typename MethodPtr>
163    static R InvokeMethod(Class* obj_ptr,
164                          MethodPtr method_ptr,
165                          const ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7,
166                              A8>& args) {
167      using ::std::tr1::get;
168      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
169          get<3>(args), get<4>(args), get<5>(args), get<6>(args), get<7>(args));
170    }
171  };
172  template <typename R, typename A1, typename A2, typename A3, typename A4,
173      typename A5, typename A6, typename A7, typename A8, typename A9>
174  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> > {
175   public:
176    template <typename Function>
177    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3, A4,
178        A5, A6, A7, A8, A9>& args) {
179      using ::std::tr1::get;
180      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args),
181          get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args));
182    }
183    template <class Class, typename MethodPtr>
184    static R InvokeMethod(Class* obj_ptr,
185                          MethodPtr method_ptr,
186                          const ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7, A8,
187                              A9>& args) {
188      using ::std::tr1::get;
189      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
190          get<3>(args), get<4>(args), get<5>(args), get<6>(args), get<7>(args),
191          get<8>(args));
192    }
193  };
194  template <typename R, typename A1, typename A2, typename A3, typename A4,
195      typename A5, typename A6, typename A7, typename A8, typename A9,
196      typename A10>
197  class InvokeHelper<R, ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,
198      A10> > {
199   public:
200    template <typename Function>
201    static R Invoke(Function function, const ::std::tr1::tuple<A1, A2, A3, A4,
202        A5, A6, A7, A8, A9, A10>& args) {
203      using ::std::tr1::get;
204      return function(get<0>(args), get<1>(args), get<2>(args), get<3>(args),
205          get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),
206          get<9>(args));
207    }
208    template <class Class, typename MethodPtr>
209    static R InvokeMethod(Class* obj_ptr,
210                          MethodPtr method_ptr,
211                          const ::std::tr1::tuple<A1, A2, A3, A4, A5, A6, A7, A8,
212                              A9, A10>& args) {
213      using ::std::tr1::get;
214      return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args), get<2>(args),
215          get<3>(args), get<4>(args), get<5>(args), get<6>(args), get<7>(args),
216          get<8>(args), get<9>(args));
217    }
218  };
219  template <typename R>
220  class CallableHelper {
221   public:
222    template <typename Function>
223    static R Call(Function function) { return function(); }
224    template <typename Function, typename A1>
225    static R Call(Function function, A1 a1) { return function(a1); }
226    template <typename Function, typename A1, typename A2>
227    static R Call(Function function, A1 a1, A2 a2) {
228      return function(a1, a2);
229    }
230    template <typename Function, typename A1, typename A2, typename A3>
231    static R Call(Function function, A1 a1, A2 a2, A3 a3) {
232      return function(a1, a2, a3);
233    }
234    template <typename Function, typename A1, typename A2, typename A3,
235        typename A4>
236    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4) {
237      return function(a1, a2, a3, a4);
238    }
239    template <typename Function, typename A1, typename A2, typename A3,
240        typename A4, typename A5>
241    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
242      return function(a1, a2, a3, a4, a5);
243    }
244    template <typename Function, typename A1, typename A2, typename A3,
245        typename A4, typename A5, typename A6>
246    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
247      return function(a1, a2, a3, a4, a5, a6);
248    }
249    template <typename Function, typename A1, typename A2, typename A3,
250        typename A4, typename A5, typename A6, typename A7>
251    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
252        A7 a7) {
253      return function(a1, a2, a3, a4, a5, a6, a7);
254    }
255    template <typename Function, typename A1, typename A2, typename A3,
256        typename A4, typename A5, typename A6, typename A7, typename A8>
257    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
258        A7 a7, A8 a8) {
259      return function(a1, a2, a3, a4, a5, a6, a7, a8);
260    }
261    template <typename Function, typename A1, typename A2, typename A3,
262        typename A4, typename A5, typename A6, typename A7, typename A8,
263        typename A9>
<span onclick='openModal()' class='match'>264    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
265        A7 a7, A8 a8, A9 a9) {
</span>266      return function(a1, a2, a3, a4, a5, a6, a7, a8, a9);
267    }
268    template <typename Function, typename A1, typename A2, typename A3,
269        typename A4, typename A5, typename A6, typename A7, typename A8,
270        typename A9, typename A10>
271    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
272        A7 a7, A8 a8, A9 a9, A10 a10) {
273      return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
274    }
275  };  
276  #define GMOCK_FIELD_(Tuple, N) \
277      typename ::std::tr1::tuple_element<N, Tuple>::type
278  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
279      int k4, int k5, int k6, int k7, int k8, int k9, int k10>
280  class SelectArgs {
281   public:
282    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
283        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
284        GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),
285        GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),
286        GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9),
287        GMOCK_FIELD_(ArgumentTuple, k10));
288    typedef typename Function<type>::ArgumentTuple SelectedArgs;
289    static SelectedArgs Select(const ArgumentTuple& args) {
290      using ::std::tr1::get;
291      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
292          get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),
293          get<k8>(args), get<k9>(args), get<k10>(args));
294    }
295  };
296  template <typename Result, typename ArgumentTuple>
297  class SelectArgs<Result, ArgumentTuple,
298                   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {
299   public:
300    typedef Result type();
301    typedef typename Function<type>::ArgumentTuple SelectedArgs;
302    static SelectedArgs Select(const ArgumentTuple& &bsol;* args */) {
303      using ::std::tr1::get;
304      return SelectedArgs();
305    }
306  };
307  template <typename Result, typename ArgumentTuple, int k1>
308  class SelectArgs<Result, ArgumentTuple,
309                   k1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {
310   public:
311    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1));
312    typedef typename Function<type>::ArgumentTuple SelectedArgs;
313    static SelectedArgs Select(const ArgumentTuple& args) {
314      using ::std::tr1::get;
315      return SelectedArgs(get<k1>(args));
316    }
317  };
318  template <typename Result, typename ArgumentTuple, int k1, int k2>
319  class SelectArgs<Result, ArgumentTuple,
320                   k1, k2, -1, -1, -1, -1, -1, -1, -1, -1> {
321   public:
322    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
323        GMOCK_FIELD_(ArgumentTuple, k2));
324    typedef typename Function<type>::ArgumentTuple SelectedArgs;
325    static SelectedArgs Select(const ArgumentTuple& args) {
326      using ::std::tr1::get;
327      return SelectedArgs(get<k1>(args), get<k2>(args));
328    }
329  };
330  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3>
331  class SelectArgs<Result, ArgumentTuple,
332                   k1, k2, k3, -1, -1, -1, -1, -1, -1, -1> {
333   public:
334    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
335        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3));
336    typedef typename Function<type>::ArgumentTuple SelectedArgs;
337    static SelectedArgs Select(const ArgumentTuple& args) {
338      using ::std::tr1::get;
339      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args));
340    }
341  };
342  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
343      int k4>
344  class SelectArgs<Result, ArgumentTuple,
345                   k1, k2, k3, k4, -1, -1, -1, -1, -1, -1> {
346   public:
347    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
348        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
349        GMOCK_FIELD_(ArgumentTuple, k4));
350    typedef typename Function<type>::ArgumentTuple SelectedArgs;
351    static SelectedArgs Select(const ArgumentTuple& args) {
352      using ::std::tr1::get;
353      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
354          get<k4>(args));
355    }
356  };
357  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
358      int k4, int k5>
359  class SelectArgs<Result, ArgumentTuple,
360                   k1, k2, k3, k4, k5, -1, -1, -1, -1, -1> {
361   public:
362    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
363        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
364        GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5));
365    typedef typename Function<type>::ArgumentTuple SelectedArgs;
366    static SelectedArgs Select(const ArgumentTuple& args) {
367      using ::std::tr1::get;
368      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
369          get<k4>(args), get<k5>(args));
370    }
371  };
372  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
373      int k4, int k5, int k6>
374  class SelectArgs<Result, ArgumentTuple,
375                   k1, k2, k3, k4, k5, k6, -1, -1, -1, -1> {
376   public:
377    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
378        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
379        GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),
380        GMOCK_FIELD_(ArgumentTuple, k6));
381    typedef typename Function<type>::ArgumentTuple SelectedArgs;
382    static SelectedArgs Select(const ArgumentTuple& args) {
383      using ::std::tr1::get;
384      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
385          get<k4>(args), get<k5>(args), get<k6>(args));
386    }
387  };
388  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
389      int k4, int k5, int k6, int k7>
390  class SelectArgs<Result, ArgumentTuple,
391                   k1, k2, k3, k4, k5, k6, k7, -1, -1, -1> {
392   public:
393    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
394        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
395        GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),
396        GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7));
397    typedef typename Function<type>::ArgumentTuple SelectedArgs;
398    static SelectedArgs Select(const ArgumentTuple& args) {
399      using ::std::tr1::get;
400      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
401          get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args));
402    }
403  };
404  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
405      int k4, int k5, int k6, int k7, int k8>
406  class SelectArgs<Result, ArgumentTuple,
407                   k1, k2, k3, k4, k5, k6, k7, k8, -1, -1> {
408   public:
409    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
410        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
411        GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),
412        GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),
413        GMOCK_FIELD_(ArgumentTuple, k8));
414    typedef typename Function<type>::ArgumentTuple SelectedArgs;
415    static SelectedArgs Select(const ArgumentTuple& args) {
416      using ::std::tr1::get;
417      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
418          get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),
419          get<k8>(args));
420    }
421  };
422  template <typename Result, typename ArgumentTuple, int k1, int k2, int k3,
423      int k4, int k5, int k6, int k7, int k8, int k9>
424  class SelectArgs<Result, ArgumentTuple,
425                   k1, k2, k3, k4, k5, k6, k7, k8, k9, -1> {
426   public:
427    typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),
428        GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),
429        GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),
430        GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),
431        GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9));
432    typedef typename Function<type>::ArgumentTuple SelectedArgs;
433    static SelectedArgs Select(const ArgumentTuple& args) {
434      using ::std::tr1::get;
435      return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),
436          get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),
437          get<k8>(args), get<k9>(args));
438    }
439  };
440  #undef GMOCK_FIELD_
441  template <typename InnerAction, int k1 = -1, int k2 = -1, int k3 = -1,
442      int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,
443      int k9 = -1, int k10 = -1>
444  class WithArgsAction {
445   public:
446    explicit WithArgsAction(const InnerAction& action) : action_(action) {}
447    template <typename F>
448    operator Action<F>() const { return MakeAction(new Impl<F>(action_)); }
449   private:
450    template <typename F>
451    class Impl : public ActionInterface<F> {
452     public:
453      typedef typename Function<F>::Result Result;
454      typedef typename Function<F>::ArgumentTuple ArgumentTuple;
455      explicit Impl(const InnerAction& action) : action_(action) {}
456      virtual Result Perform(const ArgumentTuple& args) {
457        return action_.Perform(SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4,
458            k5, k6, k7, k8, k9, k10>::Select(args));
459      }
460     private:
461      typedef typename SelectArgs<Result, ArgumentTuple,
462          k1, k2, k3, k4, k5, k6, k7, k8, k9, k10>::type InnerFunctionType;
463      Action<InnerFunctionType> action_;
464    };
465    const InnerAction action_;
466    GTEST_DISALLOW_ASSIGN_(WithArgsAction);
467  };
468  struct ExcessiveArg {};
469  template <typename Result, class Impl>
470  class ActionHelper {
471   public:
472    static Result Perform(Impl* impl, const ::std::tr1::tuple<>& args) {
473      using ::std::tr1::get;
474      return impl->template gmock_PerformImpl<>(args, ExcessiveArg(),
475          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
476          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
477          ExcessiveArg());
478    }
479    template <typename A0>
480    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0>& args) {
481      using ::std::tr1::get;
482      return impl->template gmock_PerformImpl<A0>(args, get<0>(args),
483          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
484          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
485          ExcessiveArg());
486    }
487    template <typename A0, typename A1>
488    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1>& args) {
489      using ::std::tr1::get;
490      return impl->template gmock_PerformImpl<A0, A1>(args, get<0>(args),
491          get<1>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
492          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
493          ExcessiveArg());
494    }
495    template <typename A0, typename A1, typename A2>
496    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2>& args) {
497      using ::std::tr1::get;
498      return impl->template gmock_PerformImpl<A0, A1, A2>(args, get<0>(args),
499          get<1>(args), get<2>(args), ExcessiveArg(), ExcessiveArg(),
500          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
501          ExcessiveArg());
502    }
503    template <typename A0, typename A1, typename A2, typename A3>
504    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2,
505        A3>& args) {
506      using ::std::tr1::get;
507      return impl->template gmock_PerformImpl<A0, A1, A2, A3>(args, get<0>(args),
508          get<1>(args), get<2>(args), get<3>(args), ExcessiveArg(),
509          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
510          ExcessiveArg());
511    }
512    template <typename A0, typename A1, typename A2, typename A3, typename A4>
513    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2, A3,
514        A4>& args) {
515      using ::std::tr1::get;
516      return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4>(args,
517          get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),
518          ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
519          ExcessiveArg());
520    }
521    template <typename A0, typename A1, typename A2, typename A3, typename A4,
522        typename A5>
523    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2, A3, A4,
524        A5>& args) {
525      using ::std::tr1::get;
526      return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5>(args,
527          get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),
528          get<5>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),
529          ExcessiveArg());
530    }
531    template <typename A0, typename A1, typename A2, typename A3, typename A4,
532        typename A5, typename A6>
533    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2, A3, A4,
534        A5, A6>& args) {
535      using ::std::tr1::get;
536      return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6>(args,
537          get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),
538          get<5>(args), get<6>(args), ExcessiveArg(), ExcessiveArg(),
539          ExcessiveArg());
540    }
541    template <typename A0, typename A1, typename A2, typename A3, typename A4,
542        typename A5, typename A6, typename A7>
543    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2, A3, A4,
544        A5, A6, A7>& args) {
545      using ::std::tr1::get;
546      return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6,
547          A7>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),
548          get<4>(args), get<5>(args), get<6>(args), get<7>(args), ExcessiveArg(),
549          ExcessiveArg());
550    }
551    template <typename A0, typename A1, typename A2, typename A3, typename A4,
552        typename A5, typename A6, typename A7, typename A8>
553    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2, A3, A4,
554        A5, A6, A7, A8>& args) {
555      using ::std::tr1::get;
556      return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7,
557          A8>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),
558          get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),
559          ExcessiveArg());
560    }
561    template <typename A0, typename A1, typename A2, typename A3, typename A4,
562        typename A5, typename A6, typename A7, typename A8, typename A9>
563    static Result Perform(Impl* impl, const ::std::tr1::tuple<A0, A1, A2, A3, A4,
564        A5, A6, A7, A8, A9>& args) {
565      using ::std::tr1::get;
566      return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7, A8,
567          A9>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),
568          get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),
569          get<9>(args));
570    }
571  };
572  }  
573  template <int k1, typename InnerAction>
574  inline internal::WithArgsAction<InnerAction, k1>
575  WithArgs(const InnerAction& action) {
576    return internal::WithArgsAction<InnerAction, k1>(action);
577  }
578  template <int k1, int k2, typename InnerAction>
579  inline internal::WithArgsAction<InnerAction, k1, k2>
580  WithArgs(const InnerAction& action) {
581    return internal::WithArgsAction<InnerAction, k1, k2>(action);
582  }
583  template <int k1, int k2, int k3, typename InnerAction>
584  inline internal::WithArgsAction<InnerAction, k1, k2, k3>
585  WithArgs(const InnerAction& action) {
586    return internal::WithArgsAction<InnerAction, k1, k2, k3>(action);
587  }
588  template <int k1, int k2, int k3, int k4, typename InnerAction>
589  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4>
590  WithArgs(const InnerAction& action) {
591    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4>(action);
592  }
593  template <int k1, int k2, int k3, int k4, int k5, typename InnerAction>
594  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>
595  WithArgs(const InnerAction& action) {
596    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>(action);
597  }
598  template <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerAction>
599  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>
600  WithArgs(const InnerAction& action) {
601    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>(action);
602  }
603  template <int k1, int k2, int k3, int k4, int k5, int k6, int k7,
604      typename InnerAction>
605  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7>
606  WithArgs(const InnerAction& action) {
607    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6,
608        k7>(action);
609  }
610  template <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,
611      typename InnerAction>
612  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8>
613  WithArgs(const InnerAction& action) {
614    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7,
615        k8>(action);
616  }
617  template <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,
618      int k9, typename InnerAction>
619  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8, k9>
620  WithArgs(const InnerAction& action) {
621    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,
622        k9>(action);
623  }
624  template <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,
625      int k9, int k10, typename InnerAction>
626  inline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,
627      k9, k10>
628  WithArgs(const InnerAction& action) {
629    return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,
630        k9, k10>(action);
631  }
632  template <typename Action1, typename Action2>
633  inline internal::DoBothAction<Action1, Action2>
634  DoAll(Action1 a1, Action2 a2) {
635    return internal::DoBothAction<Action1, Action2>(a1, a2);
636  }
637  template <typename Action1, typename Action2, typename Action3>
638  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
639      Action3> >
640  DoAll(Action1 a1, Action2 a2, Action3 a3) {
641    return DoAll(a1, DoAll(a2, a3));
642  }
643  template <typename Action1, typename Action2, typename Action3,
644      typename Action4>
645  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
646      internal::DoBothAction<Action3, Action4> > >
647  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4) {
648    return DoAll(a1, DoAll(a2, a3, a4));
649  }
650  template <typename Action1, typename Action2, typename Action3,
651      typename Action4, typename Action5>
652  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
653      internal::DoBothAction<Action3, internal::DoBothAction<Action4,
654      Action5> > > >
655  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5) {
656    return DoAll(a1, DoAll(a2, a3, a4, a5));
657  }
658  template <typename Action1, typename Action2, typename Action3,
659      typename Action4, typename Action5, typename Action6>
660  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
661      internal::DoBothAction<Action3, internal::DoBothAction<Action4,
662      internal::DoBothAction<Action5, Action6> > > > >
663  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6) {
664    return DoAll(a1, DoAll(a2, a3, a4, a5, a6));
665  }
666  template <typename Action1, typename Action2, typename Action3,
667      typename Action4, typename Action5, typename Action6, typename Action7>
668  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
669      internal::DoBothAction<Action3, internal::DoBothAction<Action4,
670      internal::DoBothAction<Action5, internal::DoBothAction<Action6,
671      Action7> > > > > >
672  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
673      Action7 a7) {
674    return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7));
675  }
676  template <typename Action1, typename Action2, typename Action3,
677      typename Action4, typename Action5, typename Action6, typename Action7,
678      typename Action8>
679  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
680      internal::DoBothAction<Action3, internal::DoBothAction<Action4,
681      internal::DoBothAction<Action5, internal::DoBothAction<Action6,
682      internal::DoBothAction<Action7, Action8> > > > > > >
683  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
684      Action7 a7, Action8 a8) {
685    return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8));
686  }
687  template <typename Action1, typename Action2, typename Action3,
688      typename Action4, typename Action5, typename Action6, typename Action7,
689      typename Action8, typename Action9>
690  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
691      internal::DoBothAction<Action3, internal::DoBothAction<Action4,
692      internal::DoBothAction<Action5, internal::DoBothAction<Action6,
693      internal::DoBothAction<Action7, internal::DoBothAction<Action8,
694      Action9> > > > > > > >
695  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
696      Action7 a7, Action8 a8, Action9 a9) {
697    return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9));
698  }
699  template <typename Action1, typename Action2, typename Action3,
700      typename Action4, typename Action5, typename Action6, typename Action7,
701      typename Action8, typename Action9, typename Action10>
702  inline internal::DoBothAction<Action1, internal::DoBothAction<Action2,
703      internal::DoBothAction<Action3, internal::DoBothAction<Action4,
704      internal::DoBothAction<Action5, internal::DoBothAction<Action6,
705      internal::DoBothAction<Action7, internal::DoBothAction<Action8,
706      internal::DoBothAction<Action9, Action10> > > > > > > > >
707  DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
708      Action7 a7, Action8 a8, Action9 a9, Action10 a10) {
709    return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9, a10));
710  }
711  }  
712  #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
713      const args_type& args GTEST_ATTRIBUTE_UNUSED_, \
714      arg0_type arg0 GTEST_ATTRIBUTE_UNUSED_, \
715      arg1_type arg1 GTEST_ATTRIBUTE_UNUSED_, \
716      arg2_type arg2 GTEST_ATTRIBUTE_UNUSED_, \
717      arg3_type arg3 GTEST_ATTRIBUTE_UNUSED_, \
718      arg4_type arg4 GTEST_ATTRIBUTE_UNUSED_, \
719      arg5_type arg5 GTEST_ATTRIBUTE_UNUSED_, \
720      arg6_type arg6 GTEST_ATTRIBUTE_UNUSED_, \
721      arg7_type arg7 GTEST_ATTRIBUTE_UNUSED_, \
722      arg8_type arg8 GTEST_ATTRIBUTE_UNUSED_, \
723      arg9_type arg9 GTEST_ATTRIBUTE_UNUSED_
724  #define GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(kind0, name0) kind0 name0
725  #define GMOCK_INTERNAL_DECL_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \
726      name1) kind0 name0, kind1 name1
727  #define GMOCK_INTERNAL_DECL_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
728      kind2, name2) kind0 name0, kind1 name1, kind2 name2
729  #define GMOCK_INTERNAL_DECL_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
730      kind2, name2, kind3, name3) kind0 name0, kind1 name1, kind2 name2, \
731      kind3 name3
732  #define GMOCK_INTERNAL_DECL_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
733      kind2, name2, kind3, name3, kind4, name4) kind0 name0, kind1 name1, \
734      kind2 name2, kind3 name3, kind4 name4
735  #define GMOCK_INTERNAL_DECL_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
736      kind2, name2, kind3, name3, kind4, name4, kind5, name5) kind0 name0, \
737      kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5
738  #define GMOCK_INTERNAL_DECL_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
739      kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \
740      name6) kind0 name0, kind1 name1, kind2 name2, kind3 name3, kind4 name4, \
741      kind5 name5, kind6 name6
742  #define GMOCK_INTERNAL_DECL_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
743      kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \
744      kind7, name7) kind0 name0, kind1 name1, kind2 name2, kind3 name3, \
745      kind4 name4, kind5 name5, kind6 name6, kind7 name7
746  #define GMOCK_INTERNAL_DECL_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
747      kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \
748      kind7, name7, kind8, name8) kind0 name0, kind1 name1, kind2 name2, \
749      kind3 name3, kind4 name4, kind5 name5, kind6 name6, kind7 name7, \
750      kind8 name8
751  #define GMOCK_INTERNAL_DECL_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \
752      name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \
753      name6, kind7, name7, kind8, name8, kind9, name9) kind0 name0, \
754      kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5, \
755      kind6 name6, kind7 name7, kind8 name8, kind9 name9
756  #define GMOCK_INTERNAL_LIST_HAS_1_TEMPLATE_PARAMS(kind0, name0) name0
757  #define GMOCK_INTERNAL_LIST_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \
758      name1) name0, name1
759  #define GMOCK_INTERNAL_LIST_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
760      kind2, name2) name0, name1, name2
761  #define GMOCK_INTERNAL_LIST_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
762      kind2, name2, kind3, name3) name0, name1, name2, name3
763  #define GMOCK_INTERNAL_LIST_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
764      kind2, name2, kind3, name3, kind4, name4) name0, name1, name2, name3, \
765      name4
766  #define GMOCK_INTERNAL_LIST_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
767      kind2, name2, kind3, name3, kind4, name4, kind5, name5) name0, name1, \
768      name2, name3, name4, name5
769  #define GMOCK_INTERNAL_LIST_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
770      kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \
771      name6) name0, name1, name2, name3, name4, name5, name6
772  #define GMOCK_INTERNAL_LIST_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
773      kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \
774      kind7, name7) name0, name1, name2, name3, name4, name5, name6, name7
775  #define GMOCK_INTERNAL_LIST_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \
776      kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \
777      kind7, name7, kind8, name8) name0, name1, name2, name3, name4, name5, \
778      name6, name7, name8
779  #define GMOCK_INTERNAL_LIST_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \
780      name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \
781      name6, kind7, name7, kind8, name8, kind9, name9) name0, name1, name2, \
782      name3, name4, name5, name6, name7, name8, name9
783  #define GMOCK_INTERNAL_DECL_TYPE_AND_0_VALUE_PARAMS()
784  #define GMOCK_INTERNAL_DECL_TYPE_AND_1_VALUE_PARAMS(p0) , typename p0##_type
785  #define GMOCK_INTERNAL_DECL_TYPE_AND_2_VALUE_PARAMS(p0, p1) , \
786      typename p0##_type, typename p1##_type
787  #define GMOCK_INTERNAL_DECL_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , \
788      typename p0##_type, typename p1##_type, typename p2##_type
789  #define GMOCK_INTERNAL_DECL_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \
790      typename p0##_type, typename p1##_type, typename p2##_type, \
791      typename p3##_type
792  #define GMOCK_INTERNAL_DECL_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \
793      typename p0##_type, typename p1##_type, typename p2##_type, \
794      typename p3##_type, typename p4##_type
795  #define GMOCK_INTERNAL_DECL_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \
796      typename p0##_type, typename p1##_type, typename p2##_type, \
797      typename p3##_type, typename p4##_type, typename p5##_type
798  #define GMOCK_INTERNAL_DECL_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
799      p6) , typename p0##_type, typename p1##_type, typename p2##_type, \
800      typename p3##_type, typename p4##_type, typename p5##_type, \
801      typename p6##_type
802  #define GMOCK_INTERNAL_DECL_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
803      p6, p7) , typename p0##_type, typename p1##_type, typename p2##_type, \
804      typename p3##_type, typename p4##_type, typename p5##_type, \
805      typename p6##_type, typename p7##_type
806  #define GMOCK_INTERNAL_DECL_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
807      p6, p7, p8) , typename p0##_type, typename p1##_type, typename p2##_type, \
808      typename p3##_type, typename p4##_type, typename p5##_type, \
809      typename p6##_type, typename p7##_type, typename p8##_type
810  #define GMOCK_INTERNAL_DECL_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
811      p6, p7, p8, p9) , typename p0##_type, typename p1##_type, \
812      typename p2##_type, typename p3##_type, typename p4##_type, \
813      typename p5##_type, typename p6##_type, typename p7##_type, \
814      typename p8##_type, typename p9##_type
815  #define GMOCK_INTERNAL_INIT_AND_0_VALUE_PARAMS()\
816      ()
817  #define GMOCK_INTERNAL_INIT_AND_1_VALUE_PARAMS(p0)\
818      (p0##_type gmock_p0) : p0(gmock_p0)
819  #define GMOCK_INTERNAL_INIT_AND_2_VALUE_PARAMS(p0, p1)\
820      (p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), p1(gmock_p1)
821  #define GMOCK_INTERNAL_INIT_AND_3_VALUE_PARAMS(p0, p1, p2)\
822      (p0##_type gmock_p0, p1##_type gmock_p1, \
823          p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2)
824  #define GMOCK_INTERNAL_INIT_AND_4_VALUE_PARAMS(p0, p1, p2, p3)\
825      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
826          p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
827          p3(gmock_p3)
828  #define GMOCK_INTERNAL_INIT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)\
829      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
830          p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), \
831          p2(gmock_p2), p3(gmock_p3), p4(gmock_p4)
832  #define GMOCK_INTERNAL_INIT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)\
833      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
834          p3##_type gmock_p3, p4##_type gmock_p4, \
835          p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
836          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5)
837  #define GMOCK_INTERNAL_INIT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)\
838      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
839          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
840          p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
841          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6)
842  #define GMOCK_INTERNAL_INIT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)\
843      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
844          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
845          p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), \
846          p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \
847          p7(gmock_p7)
848  #define GMOCK_INTERNAL_INIT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
849      p7, p8)\
850      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
851          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
852          p6##_type gmock_p6, p7##_type gmock_p7, \
853          p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
854          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \
855          p8(gmock_p8)
856  #define GMOCK_INTERNAL_INIT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
857      p7, p8, p9)\
858      (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
859          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
860          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \
861          p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
862          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \
863          p8(gmock_p8), p9(gmock_p9)
864  #define GMOCK_INTERNAL_DEFN_AND_0_VALUE_PARAMS()
865  #define GMOCK_INTERNAL_DEFN_AND_1_VALUE_PARAMS(p0) p0##_type p0;
866  #define GMOCK_INTERNAL_DEFN_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0; \
867      p1##_type p1;
868  #define GMOCK_INTERNAL_DEFN_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0; \
869      p1##_type p1; p2##_type p2;
870  #define GMOCK_INTERNAL_DEFN_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0; \
871      p1##_type p1; p2##_type p2; p3##_type p3;
872  #define GMOCK_INTERNAL_DEFN_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \
873      p4) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4;
874  #define GMOCK_INTERNAL_DEFN_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \
875      p5) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \
876      p5##_type p5;
877  #define GMOCK_INTERNAL_DEFN_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
878      p6) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \
879      p5##_type p5; p6##_type p6;
880  #define GMOCK_INTERNAL_DEFN_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
881      p7) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \
882      p5##_type p5; p6##_type p6; p7##_type p7;
883  #define GMOCK_INTERNAL_DEFN_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
884      p7, p8) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \
885      p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8;
886  #define GMOCK_INTERNAL_DEFN_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
887      p7, p8, p9) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \
888      p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8; \
889      p9##_type p9;
890  #define GMOCK_INTERNAL_LIST_AND_0_VALUE_PARAMS()
891  #define GMOCK_INTERNAL_LIST_AND_1_VALUE_PARAMS(p0) p0
892  #define GMOCK_INTERNAL_LIST_AND_2_VALUE_PARAMS(p0, p1) p0, p1
893  #define GMOCK_INTERNAL_LIST_AND_3_VALUE_PARAMS(p0, p1, p2) p0, p1, p2
894  #define GMOCK_INTERNAL_LIST_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0, p1, p2, p3
895  #define GMOCK_INTERNAL_LIST_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) p0, p1, \
896      p2, p3, p4
897  #define GMOCK_INTERNAL_LIST_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) p0, \
898      p1, p2, p3, p4, p5
899  #define GMOCK_INTERNAL_LIST_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
900      p6) p0, p1, p2, p3, p4, p5, p6
901  #define GMOCK_INTERNAL_LIST_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
902      p7) p0, p1, p2, p3, p4, p5, p6, p7
903  #define GMOCK_INTERNAL_LIST_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
904      p7, p8) p0, p1, p2, p3, p4, p5, p6, p7, p8
905  #define GMOCK_INTERNAL_LIST_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
906      p7, p8, p9) p0, p1, p2, p3, p4, p5, p6, p7, p8, p9
907  #define GMOCK_INTERNAL_LIST_TYPE_AND_0_VALUE_PARAMS()
908  #define GMOCK_INTERNAL_LIST_TYPE_AND_1_VALUE_PARAMS(p0) , p0##_type
909  #define GMOCK_INTERNAL_LIST_TYPE_AND_2_VALUE_PARAMS(p0, p1) , p0##_type, \
910      p1##_type
911  #define GMOCK_INTERNAL_LIST_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , p0##_type, \
912      p1##_type, p2##_type
913  #define GMOCK_INTERNAL_LIST_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \
914      p0##_type, p1##_type, p2##_type, p3##_type
915  #define GMOCK_INTERNAL_LIST_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \
916      p0##_type, p1##_type, p2##_type, p3##_type, p4##_type
917  #define GMOCK_INTERNAL_LIST_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \
918      p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type
919  #define GMOCK_INTERNAL_LIST_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
920      p6) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, \
921      p6##_type
922  #define GMOCK_INTERNAL_LIST_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
923      p6, p7) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
924      p5##_type, p6##_type, p7##_type
925  #define GMOCK_INTERNAL_LIST_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
926      p6, p7, p8) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
927      p5##_type, p6##_type, p7##_type, p8##_type
928  #define GMOCK_INTERNAL_LIST_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
929      p6, p7, p8, p9) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
930      p5##_type, p6##_type, p7##_type, p8##_type, p9##_type
931  #define GMOCK_INTERNAL_DECL_AND_0_VALUE_PARAMS()
932  #define GMOCK_INTERNAL_DECL_AND_1_VALUE_PARAMS(p0) p0##_type p0
933  #define GMOCK_INTERNAL_DECL_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0, \
934      p1##_type p1
935  #define GMOCK_INTERNAL_DECL_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0, \
936      p1##_type p1, p2##_type p2
937  #define GMOCK_INTERNAL_DECL_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0, \
938      p1##_type p1, p2##_type p2, p3##_type p3
939  #define GMOCK_INTERNAL_DECL_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \
940      p4) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4
941  #define GMOCK_INTERNAL_DECL_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \
942      p5) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \
943      p5##_type p5
944  #define GMOCK_INTERNAL_DECL_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \
945      p6) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \
946      p5##_type p5, p6##_type p6
947  #define GMOCK_INTERNAL_DECL_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
948      p7) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \
949      p5##_type p5, p6##_type p6, p7##_type p7
950  #define GMOCK_INTERNAL_DECL_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
951      p7, p8) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
952      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8
953  #define GMOCK_INTERNAL_DECL_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
954      p7, p8, p9) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
955      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \
956      p9##_type p9
957  #define GMOCK_INTERNAL_COUNT_AND_0_VALUE_PARAMS()
958  #define GMOCK_INTERNAL_COUNT_AND_1_VALUE_PARAMS(p0) P
959  #define GMOCK_INTERNAL_COUNT_AND_2_VALUE_PARAMS(p0, p1) P2
960  #define GMOCK_INTERNAL_COUNT_AND_3_VALUE_PARAMS(p0, p1, p2) P3
961  #define GMOCK_INTERNAL_COUNT_AND_4_VALUE_PARAMS(p0, p1, p2, p3) P4
962  #define GMOCK_INTERNAL_COUNT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) P5
963  #define GMOCK_INTERNAL_COUNT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) P6
964  #define GMOCK_INTERNAL_COUNT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6) P7
965  #define GMOCK_INTERNAL_COUNT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
966      p7) P8
967  #define GMOCK_INTERNAL_COUNT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
968      p7, p8) P9
969  #define GMOCK_INTERNAL_COUNT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \
970      p7, p8, p9) P10
971  #define GMOCK_ACTION_CLASS_(name, value_params)\
972      GTEST_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)
973  #define ACTION_TEMPLATE(name, template_params, value_params)\
974    template <GMOCK_INTERNAL_DECL_##template_params\
975              GMOCK_INTERNAL_DECL_TYPE_##value_params>\
976    class GMOCK_ACTION_CLASS_(name, value_params) {\
977     public:\
978      GMOCK_ACTION_CLASS_(name, value_params)\
979          GMOCK_INTERNAL_INIT_##value_params {}\
980      template <typename F>\
981      class gmock_Impl : public ::testing::ActionInterface<F> {\
982       public:\
983        typedef F function_type;\
984        typedef typename ::testing::internal::Function<F>::Result return_type;\
985        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
986            args_type;\
987        explicit gmock_Impl GMOCK_INTERNAL_INIT_##value_params {}\
988        virtual return_type Perform(const args_type& args) {\
989          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
990              Perform(this, args);\
991        }\
992        template <typename arg0_type, typename arg1_type, typename arg2_type, \
993            typename arg3_type, typename arg4_type, typename arg5_type, \
994            typename arg6_type, typename arg7_type, typename arg8_type, \
995            typename arg9_type>\
996        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
997            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
998            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
999            arg9_type arg9) const;\
1000        GMOCK_INTERNAL_DEFN_##value_params\
1001       private:\
1002        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1003      };\
1004      template <typename F> operator ::testing::Action<F>() const {\
1005        return ::testing::Action<F>(\
1006            new gmock_Impl<F>(GMOCK_INTERNAL_LIST_##value_params));\
1007      }\
1008      GMOCK_INTERNAL_DEFN_##value_params\
1009     private:\
1010      GTEST_DISALLOW_ASSIGN_(GMOCK_ACTION_CLASS_(name, value_params));\
1011    };\
1012    template <GMOCK_INTERNAL_DECL_##template_params\
1013              GMOCK_INTERNAL_DECL_TYPE_##value_params>\
1014    inline GMOCK_ACTION_CLASS_(name, value_params)<\
1015        GMOCK_INTERNAL_LIST_##template_params\
1016        GMOCK_INTERNAL_LIST_TYPE_##value_params> name(\
1017            GMOCK_INTERNAL_DECL_##value_params) {\
1018      return GMOCK_ACTION_CLASS_(name, value_params)<\
1019          GMOCK_INTERNAL_LIST_##template_params\
1020          GMOCK_INTERNAL_LIST_TYPE_##value_params>(\
1021              GMOCK_INTERNAL_LIST_##value_params);\
1022    }\
1023    template <GMOCK_INTERNAL_DECL_##template_params\
1024              GMOCK_INTERNAL_DECL_TYPE_##value_params>\
1025    template <typename F>\
1026    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1027        typename arg3_type, typename arg4_type, typename arg5_type, \
1028        typename arg6_type, typename arg7_type, typename arg8_type, \
1029        typename arg9_type>\
1030    typename ::testing::internal::Function<F>::Result\
1031        GMOCK_ACTION_CLASS_(name, value_params)<\
1032            GMOCK_INTERNAL_LIST_##template_params\
1033            GMOCK_INTERNAL_LIST_TYPE_##value_params>::gmock_Impl<F>::\
1034                gmock_PerformImpl(\
1035            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1036  #define ACTION(name)\
1037    class name##Action {\
1038     public:\
1039      name##Action() {}\
1040      template <typename F>\
1041      class gmock_Impl : public ::testing::ActionInterface<F> {\
1042       public:\
1043        typedef F function_type;\
1044        typedef typename ::testing::internal::Function<F>::Result return_type;\
1045        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1046            args_type;\
1047        gmock_Impl() {}\
1048        virtual return_type Perform(const args_type& args) {\
1049          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1050              Perform(this, args);\
1051        }\
1052        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1053            typename arg3_type, typename arg4_type, typename arg5_type, \
1054            typename arg6_type, typename arg7_type, typename arg8_type, \
1055            typename arg9_type>\
1056        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1057            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1058            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1059            arg9_type arg9) const;\
1060       private:\
1061        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1062      };\
1063      template <typename F> operator ::testing::Action<F>() const {\
1064        return ::testing::Action<F>(new gmock_Impl<F>());\
1065      }\
1066     private:\
1067      GTEST_DISALLOW_ASSIGN_(name##Action);\
1068    };\
1069    inline name##Action name() {\
1070      return name##Action();\
1071    }\
1072    template <typename F>\
1073    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1074        typename arg3_type, typename arg4_type, typename arg5_type, \
1075        typename arg6_type, typename arg7_type, typename arg8_type, \
1076        typename arg9_type>\
1077    typename ::testing::internal::Function<F>::Result\
1078        name##Action::gmock_Impl<F>::gmock_PerformImpl(\
1079            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1080  #define ACTION_P(name, p0)\
1081    template <typename p0##_type>\
1082    class name##ActionP {\
1083     public:\
1084      name##ActionP(p0##_type gmock_p0) : p0(gmock_p0) {}\
1085      template <typename F>\
1086      class gmock_Impl : public ::testing::ActionInterface<F> {\
1087       public:\
1088        typedef F function_type;\
1089        typedef typename ::testing::internal::Function<F>::Result return_type;\
1090        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1091            args_type;\
1092        explicit gmock_Impl(p0##_type gmock_p0) : p0(gmock_p0) {}\
1093        virtual return_type Perform(const args_type& args) {\
1094          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1095              Perform(this, args);\
1096        }\
1097        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1098            typename arg3_type, typename arg4_type, typename arg5_type, \
1099            typename arg6_type, typename arg7_type, typename arg8_type, \
1100            typename arg9_type>\
1101        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1102            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1103            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1104            arg9_type arg9) const;\
1105        p0##_type p0;\
1106       private:\
1107        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1108      };\
1109      template <typename F> operator ::testing::Action<F>() const {\
1110        return ::testing::Action<F>(new gmock_Impl<F>(p0));\
1111      }\
1112      p0##_type p0;\
1113     private:\
1114      GTEST_DISALLOW_ASSIGN_(name##ActionP);\
1115    };\
1116    template <typename p0##_type>\
1117    inline name##ActionP<p0##_type> name(p0##_type p0) {\
1118      return name##ActionP<p0##_type>(p0);\
1119    }\
1120    template <typename p0##_type>\
1121    template <typename F>\
1122    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1123        typename arg3_type, typename arg4_type, typename arg5_type, \
1124        typename arg6_type, typename arg7_type, typename arg8_type, \
1125        typename arg9_type>\
1126    typename ::testing::internal::Function<F>::Result\
1127        name##ActionP<p0##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1128            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1129  #define ACTION_P2(name, p0, p1)\
1130    template <typename p0##_type, typename p1##_type>\
1131    class name##ActionP2 {\
1132     public:\
1133      name##ActionP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \
1134          p1(gmock_p1) {}\
1135      template <typename F>\
1136      class gmock_Impl : public ::testing::ActionInterface<F> {\
1137       public:\
1138        typedef F function_type;\
1139        typedef typename ::testing::internal::Function<F>::Result return_type;\
1140        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1141            args_type;\
1142        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \
1143            p1(gmock_p1) {}\
1144        virtual return_type Perform(const args_type& args) {\
1145          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1146              Perform(this, args);\
1147        }\
1148        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1149            typename arg3_type, typename arg4_type, typename arg5_type, \
1150            typename arg6_type, typename arg7_type, typename arg8_type, \
1151            typename arg9_type>\
1152        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1153            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1154            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1155            arg9_type arg9) const;\
1156        p0##_type p0;\
1157        p1##_type p1;\
1158       private:\
1159        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1160      };\
1161      template <typename F> operator ::testing::Action<F>() const {\
1162        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1));\
1163      }\
1164      p0##_type p0;\
1165      p1##_type p1;\
1166     private:\
1167      GTEST_DISALLOW_ASSIGN_(name##ActionP2);\
1168    };\
1169    template <typename p0##_type, typename p1##_type>\
1170    inline name##ActionP2<p0##_type, p1##_type> name(p0##_type p0, \
1171        p1##_type p1) {\
1172      return name##ActionP2<p0##_type, p1##_type>(p0, p1);\
1173    }\
1174    template <typename p0##_type, typename p1##_type>\
1175    template <typename F>\
1176    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1177        typename arg3_type, typename arg4_type, typename arg5_type, \
1178        typename arg6_type, typename arg7_type, typename arg8_type, \
1179        typename arg9_type>\
1180    typename ::testing::internal::Function<F>::Result\
1181        name##ActionP2<p0##_type, p1##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1182            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1183  #define ACTION_P3(name, p0, p1, p2)\
1184    template <typename p0##_type, typename p1##_type, typename p2##_type>\
1185    class name##ActionP3 {\
1186     public:\
1187      name##ActionP3(p0##_type gmock_p0, p1##_type gmock_p1, \
1188          p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\
1189      template <typename F>\
1190      class gmock_Impl : public ::testing::ActionInterface<F> {\
1191       public:\
1192        typedef F function_type;\
1193        typedef typename ::testing::internal::Function<F>::Result return_type;\
1194        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1195            args_type;\
1196        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, \
1197            p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\
1198        virtual return_type Perform(const args_type& args) {\
1199          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1200              Perform(this, args);\
1201        }\
1202        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1203            typename arg3_type, typename arg4_type, typename arg5_type, \
1204            typename arg6_type, typename arg7_type, typename arg8_type, \
1205            typename arg9_type>\
1206        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1207            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1208            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1209            arg9_type arg9) const;\
1210        p0##_type p0;\
1211        p1##_type p1;\
1212        p2##_type p2;\
1213       private:\
1214        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1215      };\
1216      template <typename F> operator ::testing::Action<F>() const {\
1217        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2));\
1218      }\
1219      p0##_type p0;\
1220      p1##_type p1;\
1221      p2##_type p2;\
1222     private:\
1223      GTEST_DISALLOW_ASSIGN_(name##ActionP3);\
1224    };\
1225    template <typename p0##_type, typename p1##_type, typename p2##_type>\
1226    inline name##ActionP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \
1227        p1##_type p1, p2##_type p2) {\
1228      return name##ActionP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\
1229    }\
1230    template <typename p0##_type, typename p1##_type, typename p2##_type>\
1231    template <typename F>\
1232    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1233        typename arg3_type, typename arg4_type, typename arg5_type, \
1234        typename arg6_type, typename arg7_type, typename arg8_type, \
1235        typename arg9_type>\
1236    typename ::testing::internal::Function<F>::Result\
1237        name##ActionP3<p0##_type, p1##_type, \
1238            p2##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1239            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1240  #define ACTION_P4(name, p0, p1, p2, p3)\
1241    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1242        typename p3##_type>\
1243    class name##ActionP4 {\
1244     public:\
1245      name##ActionP4(p0##_type gmock_p0, p1##_type gmock_p1, \
1246          p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \
1247          p2(gmock_p2), p3(gmock_p3) {}\
1248      template <typename F>\
1249      class gmock_Impl : public ::testing::ActionInterface<F> {\
1250       public:\
1251        typedef F function_type;\
1252        typedef typename ::testing::internal::Function<F>::Result return_type;\
1253        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1254            args_type;\
1255        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1256            p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1257            p3(gmock_p3) {}\
1258        virtual return_type Perform(const args_type& args) {\
1259          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1260              Perform(this, args);\
1261        }\
1262        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1263            typename arg3_type, typename arg4_type, typename arg5_type, \
1264            typename arg6_type, typename arg7_type, typename arg8_type, \
1265            typename arg9_type>\
1266        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1267            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1268            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1269            arg9_type arg9) const;\
1270        p0##_type p0;\
1271        p1##_type p1;\
1272        p2##_type p2;\
1273        p3##_type p3;\
1274       private:\
1275        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1276      };\
1277      template <typename F> operator ::testing::Action<F>() const {\
1278        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3));\
1279      }\
1280      p0##_type p0;\
1281      p1##_type p1;\
1282      p2##_type p2;\
1283      p3##_type p3;\
1284     private:\
1285      GTEST_DISALLOW_ASSIGN_(name##ActionP4);\
1286    };\
1287    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1288        typename p3##_type>\
1289    inline name##ActionP4<p0##_type, p1##_type, p2##_type, \
1290        p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \
1291        p3##_type p3) {\
1292      return name##ActionP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, p1, \
1293          p2, p3);\
1294    }\
1295    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1296        typename p3##_type>\
1297    template <typename F>\
1298    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1299        typename arg3_type, typename arg4_type, typename arg5_type, \
1300        typename arg6_type, typename arg7_type, typename arg8_type, \
1301        typename arg9_type>\
1302    typename ::testing::internal::Function<F>::Result\
1303        name##ActionP4<p0##_type, p1##_type, p2##_type, \
1304            p3##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1305            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1306  #define ACTION_P5(name, p0, p1, p2, p3, p4)\
1307    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1308        typename p3##_type, typename p4##_type>\
1309    class name##ActionP5 {\
1310     public:\
1311      name##ActionP5(p0##_type gmock_p0, p1##_type gmock_p1, \
1312          p2##_type gmock_p2, p3##_type gmock_p3, \
1313          p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1314          p3(gmock_p3), p4(gmock_p4) {}\
1315      template <typename F>\
1316      class gmock_Impl : public ::testing::ActionInterface<F> {\
1317       public:\
1318        typedef F function_type;\
1319        typedef typename ::testing::internal::Function<F>::Result return_type;\
1320        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1321            args_type;\
1322        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1323            p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), \
1324            p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4) {}\
1325        virtual return_type Perform(const args_type& args) {\
1326          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1327              Perform(this, args);\
1328        }\
1329        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1330            typename arg3_type, typename arg4_type, typename arg5_type, \
1331            typename arg6_type, typename arg7_type, typename arg8_type, \
1332            typename arg9_type>\
1333        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1334            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1335            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1336            arg9_type arg9) const;\
1337        p0##_type p0;\
1338        p1##_type p1;\
1339        p2##_type p2;\
1340        p3##_type p3;\
1341        p4##_type p4;\
1342       private:\
1343        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1344      };\
1345      template <typename F> operator ::testing::Action<F>() const {\
1346        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4));\
1347      }\
1348      p0##_type p0;\
1349      p1##_type p1;\
1350      p2##_type p2;\
1351      p3##_type p3;\
1352      p4##_type p4;\
1353     private:\
1354      GTEST_DISALLOW_ASSIGN_(name##ActionP5);\
1355    };\
1356    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1357        typename p3##_type, typename p4##_type>\
1358    inline name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \
1359        p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
1360        p4##_type p4) {\
1361      return name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \
1362          p4##_type>(p0, p1, p2, p3, p4);\
1363    }\
1364    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1365        typename p3##_type, typename p4##_type>\
1366    template <typename F>\
1367    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1368        typename arg3_type, typename arg4_type, typename arg5_type, \
1369        typename arg6_type, typename arg7_type, typename arg8_type, \
1370        typename arg9_type>\
1371    typename ::testing::internal::Function<F>::Result\
1372        name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \
1373            p4##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1374            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1375  #define ACTION_P6(name, p0, p1, p2, p3, p4, p5)\
1376    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1377        typename p3##_type, typename p4##_type, typename p5##_type>\
1378    class name##ActionP6 {\
1379     public:\
1380      name##ActionP6(p0##_type gmock_p0, p1##_type gmock_p1, \
1381          p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1382          p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1383          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\
1384      template <typename F>\
1385      class gmock_Impl : public ::testing::ActionInterface<F> {\
1386       public:\
1387        typedef F function_type;\
1388        typedef typename ::testing::internal::Function<F>::Result return_type;\
1389        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1390            args_type;\
1391        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1392            p3##_type gmock_p3, p4##_type gmock_p4, \
1393            p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1394            p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\
1395        virtual return_type Perform(const args_type& args) {\
1396          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1397              Perform(this, args);\
1398        }\
1399        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1400            typename arg3_type, typename arg4_type, typename arg5_type, \
1401            typename arg6_type, typename arg7_type, typename arg8_type, \
1402            typename arg9_type>\
1403        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1404            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1405            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1406            arg9_type arg9) const;\
1407        p0##_type p0;\
1408        p1##_type p1;\
1409        p2##_type p2;\
1410        p3##_type p3;\
1411        p4##_type p4;\
1412        p5##_type p5;\
1413       private:\
1414        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1415      };\
1416      template <typename F> operator ::testing::Action<F>() const {\
1417        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5));\
1418      }\
1419      p0##_type p0;\
1420      p1##_type p1;\
1421      p2##_type p2;\
1422      p3##_type p3;\
1423      p4##_type p4;\
1424      p5##_type p5;\
1425     private:\
1426      GTEST_DISALLOW_ASSIGN_(name##ActionP6);\
1427    };\
1428    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1429        typename p3##_type, typename p4##_type, typename p5##_type>\
1430    inline name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \
1431        p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \
1432        p3##_type p3, p4##_type p4, p5##_type p5) {\
1433      return name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \
1434          p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\
1435    }\
1436    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1437        typename p3##_type, typename p4##_type, typename p5##_type>\
1438    template <typename F>\
1439    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1440        typename arg3_type, typename arg4_type, typename arg5_type, \
1441        typename arg6_type, typename arg7_type, typename arg8_type, \
1442        typename arg9_type>\
1443    typename ::testing::internal::Function<F>::Result\
1444        name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1445            p5##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1446            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1447  #define ACTION_P7(name, p0, p1, p2, p3, p4, p5, p6)\
1448    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1449        typename p3##_type, typename p4##_type, typename p5##_type, \
1450        typename p6##_type>\
1451    class name##ActionP7 {\
1452     public:\
1453      name##ActionP7(p0##_type gmock_p0, p1##_type gmock_p1, \
1454          p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1455          p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \
1456          p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \
1457          p6(gmock_p6) {}\
1458      template <typename F>\
1459      class gmock_Impl : public ::testing::ActionInterface<F> {\
1460       public:\
1461        typedef F function_type;\
1462        typedef typename ::testing::internal::Function<F>::Result return_type;\
1463        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1464            args_type;\
1465        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1466            p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
1467            p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1468            p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\
1469        virtual return_type Perform(const args_type& args) {\
1470          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1471              Perform(this, args);\
1472        }\
1473        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1474            typename arg3_type, typename arg4_type, typename arg5_type, \
1475            typename arg6_type, typename arg7_type, typename arg8_type, \
1476            typename arg9_type>\
1477        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1478            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1479            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1480            arg9_type arg9) const;\
1481        p0##_type p0;\
1482        p1##_type p1;\
1483        p2##_type p2;\
1484        p3##_type p3;\
1485        p4##_type p4;\
1486        p5##_type p5;\
1487        p6##_type p6;\
1488       private:\
1489        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1490      };\
1491      template <typename F> operator ::testing::Action<F>() const {\
1492        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \
1493            p6));\
1494      }\
1495      p0##_type p0;\
1496      p1##_type p1;\
1497      p2##_type p2;\
1498      p3##_type p3;\
1499      p4##_type p4;\
1500      p5##_type p5;\
1501      p6##_type p6;\
1502     private:\
1503      GTEST_DISALLOW_ASSIGN_(name##ActionP7);\
1504    };\
1505    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1506        typename p3##_type, typename p4##_type, typename p5##_type, \
1507        typename p6##_type>\
1508    inline name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \
1509        p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \
1510        p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \
1511        p6##_type p6) {\
1512      return name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \
1513          p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\
1514    }\
1515    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1516        typename p3##_type, typename p4##_type, typename p5##_type, \
1517        typename p6##_type>\
1518    template <typename F>\
1519    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1520        typename arg3_type, typename arg4_type, typename arg5_type, \
1521        typename arg6_type, typename arg7_type, typename arg8_type, \
1522        typename arg9_type>\
1523    typename ::testing::internal::Function<F>::Result\
1524        name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1525            p5##_type, p6##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1526            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1527  #define ACTION_P8(name, p0, p1, p2, p3, p4, p5, p6, p7)\
1528    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1529        typename p3##_type, typename p4##_type, typename p5##_type, \
1530        typename p6##_type, typename p7##_type>\
1531    class name##ActionP8 {\
1532     public:\
1533      name##ActionP8(p0##_type gmock_p0, p1##_type gmock_p1, \
1534          p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1535          p5##_type gmock_p5, p6##_type gmock_p6, \
1536          p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1537          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \
1538          p7(gmock_p7) {}\
1539      template <typename F>\
1540      class gmock_Impl : public ::testing::ActionInterface<F> {\
1541       public:\
1542        typedef F function_type;\
1543        typedef typename ::testing::internal::Function<F>::Result return_type;\
1544        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1545            args_type;\
1546        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1547            p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
1548            p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), \
1549            p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), \
1550            p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\
1551        virtual return_type Perform(const args_type& args) {\
1552          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1553              Perform(this, args);\
1554        }\
1555        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1556            typename arg3_type, typename arg4_type, typename arg5_type, \
1557            typename arg6_type, typename arg7_type, typename arg8_type, \
1558            typename arg9_type>\
1559        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1560            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1561            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1562            arg9_type arg9) const;\
1563        p0##_type p0;\
1564        p1##_type p1;\
1565        p2##_type p2;\
1566        p3##_type p3;\
1567        p4##_type p4;\
1568        p5##_type p5;\
1569        p6##_type p6;\
1570        p7##_type p7;\
1571       private:\
1572        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1573      };\
1574      template <typename F> operator ::testing::Action<F>() const {\
1575        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \
1576            p6, p7));\
1577      }\
1578      p0##_type p0;\
1579      p1##_type p1;\
1580      p2##_type p2;\
1581      p3##_type p3;\
1582      p4##_type p4;\
1583      p5##_type p5;\
1584      p6##_type p6;\
1585      p7##_type p7;\
1586     private:\
1587      GTEST_DISALLOW_ASSIGN_(name##ActionP8);\
1588    };\
1589    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1590        typename p3##_type, typename p4##_type, typename p5##_type, \
1591        typename p6##_type, typename p7##_type>\
1592    inline name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \
1593        p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \
1594        p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \
1595        p6##_type p6, p7##_type p7) {\
1596      return name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \
1597          p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \
1598          p6, p7);\
1599    }\
1600    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1601        typename p3##_type, typename p4##_type, typename p5##_type, \
1602        typename p6##_type, typename p7##_type>\
1603    template <typename F>\
1604    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1605        typename arg3_type, typename arg4_type, typename arg5_type, \
1606        typename arg6_type, typename arg7_type, typename arg8_type, \
1607        typename arg9_type>\
1608    typename ::testing::internal::Function<F>::Result\
1609        name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1610            p5##_type, p6##_type, \
1611            p7##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1612            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1613  #define ACTION_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8)\
1614    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1615        typename p3##_type, typename p4##_type, typename p5##_type, \
1616        typename p6##_type, typename p7##_type, typename p8##_type>\
1617    class name##ActionP9 {\
1618     public:\
1619      name##ActionP9(p0##_type gmock_p0, p1##_type gmock_p1, \
1620          p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1621          p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \
1622          p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1623          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \
1624          p8(gmock_p8) {}\
1625      template <typename F>\
1626      class gmock_Impl : public ::testing::ActionInterface<F> {\
1627       public:\
1628        typedef F function_type;\
1629        typedef typename ::testing::internal::Function<F>::Result return_type;\
1630        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1631            args_type;\
1632        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1633            p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
1634            p6##_type gmock_p6, p7##_type gmock_p7, \
1635            p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1636            p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \
1637            p7(gmock_p7), p8(gmock_p8) {}\
1638        virtual return_type Perform(const args_type& args) {\
1639          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1640              Perform(this, args);\
1641        }\
1642        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1643            typename arg3_type, typename arg4_type, typename arg5_type, \
1644            typename arg6_type, typename arg7_type, typename arg8_type, \
1645            typename arg9_type>\
1646        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1647            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1648            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1649            arg9_type arg9) const;\
1650        p0##_type p0;\
1651        p1##_type p1;\
1652        p2##_type p2;\
1653        p3##_type p3;\
1654        p4##_type p4;\
1655        p5##_type p5;\
1656        p6##_type p6;\
1657        p7##_type p7;\
1658        p8##_type p8;\
1659       private:\
1660        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1661      };\
1662      template <typename F> operator ::testing::Action<F>() const {\
1663        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \
1664            p6, p7, p8));\
1665      }\
1666      p0##_type p0;\
1667      p1##_type p1;\
1668      p2##_type p2;\
1669      p3##_type p3;\
1670      p4##_type p4;\
1671      p5##_type p5;\
1672      p6##_type p6;\
1673      p7##_type p7;\
1674      p8##_type p8;\
1675     private:\
1676      GTEST_DISALLOW_ASSIGN_(name##ActionP9);\
1677    };\
1678    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1679        typename p3##_type, typename p4##_type, typename p5##_type, \
1680        typename p6##_type, typename p7##_type, typename p8##_type>\
1681    inline name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \
1682        p4##_type, p5##_type, p6##_type, p7##_type, \
1683        p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
1684        p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \
1685        p8##_type p8) {\
1686      return name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \
1687          p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \
1688          p3, p4, p5, p6, p7, p8);\
1689    }\
1690    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1691        typename p3##_type, typename p4##_type, typename p5##_type, \
1692        typename p6##_type, typename p7##_type, typename p8##_type>\
1693    template <typename F>\
1694    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1695        typename arg3_type, typename arg4_type, typename arg5_type, \
1696        typename arg6_type, typename arg7_type, typename arg8_type, \
1697        typename arg9_type>\
1698    typename ::testing::internal::Function<F>::Result\
1699        name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1700            p5##_type, p6##_type, p7##_type, \
1701            p8##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1702            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1703  #define ACTION_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)\
1704    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1705        typename p3##_type, typename p4##_type, typename p5##_type, \
1706        typename p6##_type, typename p7##_type, typename p8##_type, \
1707        typename p9##_type>\
1708    class name##ActionP10 {\
1709     public:\
1710      name##ActionP10(p0##_type gmock_p0, p1##_type gmock_p1, \
1711          p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \
1712          p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \
1713          p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \
1714          p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \
1715          p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\
1716      template <typename F>\
1717      class gmock_Impl : public ::testing::ActionInterface<F> {\
1718       public:\
1719        typedef F function_type;\
1720        typedef typename ::testing::internal::Function<F>::Result return_type;\
1721        typedef typename ::testing::internal::Function<F>::ArgumentTuple\
1722            args_type;\
1723        gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \
1724            p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \
1725            p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \
1726            p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \
1727            p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \
1728            p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\
1729        virtual return_type Perform(const args_type& args) {\
1730          return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\
1731              Perform(this, args);\
1732        }\
1733        template <typename arg0_type, typename arg1_type, typename arg2_type, \
1734            typename arg3_type, typename arg4_type, typename arg5_type, \
1735            typename arg6_type, typename arg7_type, typename arg8_type, \
1736            typename arg9_type>\
1737        return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \
1738            arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \
1739            arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \
1740            arg9_type arg9) const;\
1741        p0##_type p0;\
1742        p1##_type p1;\
1743        p2##_type p2;\
1744        p3##_type p3;\
1745        p4##_type p4;\
1746        p5##_type p5;\
1747        p6##_type p6;\
1748        p7##_type p7;\
1749        p8##_type p8;\
1750        p9##_type p9;\
1751       private:\
1752        GTEST_DISALLOW_ASSIGN_(gmock_Impl);\
1753      };\
1754      template <typename F> operator ::testing::Action<F>() const {\
1755        return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \
1756            p6, p7, p8, p9));\
1757      }\
1758      p0##_type p0;\
1759      p1##_type p1;\
1760      p2##_type p2;\
1761      p3##_type p3;\
1762      p4##_type p4;\
1763      p5##_type p5;\
1764      p6##_type p6;\
1765      p7##_type p7;\
1766      p8##_type p8;\
1767      p9##_type p9;\
1768     private:\
1769      GTEST_DISALLOW_ASSIGN_(name##ActionP10);\
1770    };\
1771    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1772        typename p3##_type, typename p4##_type, typename p5##_type, \
1773        typename p6##_type, typename p7##_type, typename p8##_type, \
1774        typename p9##_type>\
1775    inline name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \
1776        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \
1777        p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \
1778        p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \
1779        p9##_type p9) {\
1780      return name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \
1781          p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \
1782          p1, p2, p3, p4, p5, p6, p7, p8, p9);\
1783    }\
1784    template <typename p0##_type, typename p1##_type, typename p2##_type, \
1785        typename p3##_type, typename p4##_type, typename p5##_type, \
1786        typename p6##_type, typename p7##_type, typename p8##_type, \
1787        typename p9##_type>\
1788    template <typename F>\
1789    template <typename arg0_type, typename arg1_type, typename arg2_type, \
1790        typename arg3_type, typename arg4_type, typename arg5_type, \
1791        typename arg6_type, typename arg7_type, typename arg8_type, \
1792        typename arg9_type>\
1793    typename ::testing::internal::Function<F>::Result\
1794        name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \
1795            p5##_type, p6##_type, p7##_type, p8##_type, \
1796            p9##_type>::gmock_Impl<F>::gmock_PerformImpl(\
1797            GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
1798  namespace testing {
1799  #ifdef _MSC_VER
1800  # pragma warning(push)
1801  # pragma warning(disable:4100)
1802  #endif
1803  ACTION_TEMPLATE(InvokeArgument,
1804                  HAS_1_TEMPLATE_PARAMS(int, k),
1805                  AND_0_VALUE_PARAMS()) {
1806    return internal::CallableHelper<return_type>::Call(
1807        ::std::tr1::get<k>(args));
1808  }
1809  ACTION_TEMPLATE(InvokeArgument,
1810                  HAS_1_TEMPLATE_PARAMS(int, k),
1811                  AND_1_VALUE_PARAMS(p0)) {
1812    return internal::CallableHelper<return_type>::Call(
1813        ::std::tr1::get<k>(args), p0);
1814  }
1815  ACTION_TEMPLATE(InvokeArgument,
1816                  HAS_1_TEMPLATE_PARAMS(int, k),
1817                  AND_2_VALUE_PARAMS(p0, p1)) {
1818    return internal::CallableHelper<return_type>::Call(
1819        ::std::tr1::get<k>(args), p0, p1);
1820  }
1821  ACTION_TEMPLATE(InvokeArgument,
1822                  HAS_1_TEMPLATE_PARAMS(int, k),
1823                  AND_3_VALUE_PARAMS(p0, p1, p2)) {
1824    return internal::CallableHelper<return_type>::Call(
1825        ::std::tr1::get<k>(args), p0, p1, p2);
1826  }
1827  ACTION_TEMPLATE(InvokeArgument,
1828                  HAS_1_TEMPLATE_PARAMS(int, k),
1829                  AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {
1830    return internal::CallableHelper<return_type>::Call(
1831        ::std::tr1::get<k>(args), p0, p1, p2, p3);
1832  }
1833  ACTION_TEMPLATE(InvokeArgument,
1834                  HAS_1_TEMPLATE_PARAMS(int, k),
1835                  AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {
1836    return internal::CallableHelper<return_type>::Call(
1837        ::std::tr1::get<k>(args), p0, p1, p2, p3, p4);
1838  }
1839  ACTION_TEMPLATE(InvokeArgument,
1840                  HAS_1_TEMPLATE_PARAMS(int, k),
1841                  AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {
1842    return internal::CallableHelper<return_type>::Call(
1843        ::std::tr1::get<k>(args), p0, p1, p2, p3, p4, p5);
1844  }
1845  ACTION_TEMPLATE(InvokeArgument,
1846                  HAS_1_TEMPLATE_PARAMS(int, k),
1847                  AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {
1848    return internal::CallableHelper<return_type>::Call(
1849        ::std::tr1::get<k>(args), p0, p1, p2, p3, p4, p5, p6);
1850  }
1851  ACTION_TEMPLATE(InvokeArgument,
1852                  HAS_1_TEMPLATE_PARAMS(int, k),
1853                  AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {
1854    return internal::CallableHelper<return_type>::Call(
1855        ::std::tr1::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7);
1856  }
1857  ACTION_TEMPLATE(InvokeArgument,
1858                  HAS_1_TEMPLATE_PARAMS(int, k),
1859                  AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
1860    return internal::CallableHelper<return_type>::Call(
1861        ::std::tr1::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8);
1862  }
1863  ACTION_TEMPLATE(InvokeArgument,
1864                  HAS_1_TEMPLATE_PARAMS(int, k),
1865                  AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
1866    return internal::CallableHelper<return_type>::Call(
1867        ::std::tr1::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
1868  }
1869  ACTION_TEMPLATE(ReturnNew,
1870                  HAS_1_TEMPLATE_PARAMS(typename, T),
1871                  AND_0_VALUE_PARAMS()) {
1872    return new T();
1873  }
1874  ACTION_TEMPLATE(ReturnNew,
1875                  HAS_1_TEMPLATE_PARAMS(typename, T),
1876                  AND_1_VALUE_PARAMS(p0)) {
1877    return new T(p0);
1878  }
1879  ACTION_TEMPLATE(ReturnNew,
1880                  HAS_1_TEMPLATE_PARAMS(typename, T),
1881                  AND_2_VALUE_PARAMS(p0, p1)) {
1882    return new T(p0, p1);
1883  }
1884  ACTION_TEMPLATE(ReturnNew,
1885                  HAS_1_TEMPLATE_PARAMS(typename, T),
1886                  AND_3_VALUE_PARAMS(p0, p1, p2)) {
1887    return new T(p0, p1, p2);
1888  }
1889  ACTION_TEMPLATE(ReturnNew,
1890                  HAS_1_TEMPLATE_PARAMS(typename, T),
1891                  AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {
1892    return new T(p0, p1, p2, p3);
1893  }
1894  ACTION_TEMPLATE(ReturnNew,
1895                  HAS_1_TEMPLATE_PARAMS(typename, T),
1896                  AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {
1897    return new T(p0, p1, p2, p3, p4);
1898  }
1899  ACTION_TEMPLATE(ReturnNew,
1900                  HAS_1_TEMPLATE_PARAMS(typename, T),
1901                  AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {
1902    return new T(p0, p1, p2, p3, p4, p5);
1903  }
1904  ACTION_TEMPLATE(ReturnNew,
1905                  HAS_1_TEMPLATE_PARAMS(typename, T),
1906                  AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {
1907    return new T(p0, p1, p2, p3, p4, p5, p6);
1908  }
1909  ACTION_TEMPLATE(ReturnNew,
1910                  HAS_1_TEMPLATE_PARAMS(typename, T),
1911                  AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {
1912    return new T(p0, p1, p2, p3, p4, p5, p6, p7);
1913  }
1914  ACTION_TEMPLATE(ReturnNew,
1915                  HAS_1_TEMPLATE_PARAMS(typename, T),
1916                  AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
1917    return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8);
1918  }
1919  ACTION_TEMPLATE(ReturnNew,
1920                  HAS_1_TEMPLATE_PARAMS(typename, T),
1921                  AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
1922    return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
1923  }
1924  #ifdef _MSC_VER
1925  # pragma warning(pop)
1926  #endif
1927  }  
1928  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-fixspace.cpp</h3>
            <pre><code>1  #include "fixspace.h"
2  #include "blobs.h"          
3  #include "boxword.h"        
4  #include "errcode.h"        
5  #include "normalis.h"       
6  #include "pageres.h"        
7  #include "params.h"         
8  #include "ratngs.h"         
9  #include "rect.h"           
10  #include "stepblob.h"       
11  #include "tesseractclass.h" 
12  #include "tessvars.h"       
13  #include "tprintf.h"        
14  #include "unicharset.h"     
15  #include "werd.h"           
16  #include <tesseract/ocrclass.h> 
17  #include <tesseract/unichar.h>  
18  #include <cstdint> 
19  namespace tesseract {
20  class BLOCK;
21  class ROW;
22  #define PERFECT_WERDS 999
23  static int c_blob_comparator( 
24      const void *blob1p,       
25      const void *blob2p        
26  ) {
27    const C_BLOB *blob1 = *reinterpret_cast<const C_BLOB *const *>(blob1p);
28    const C_BLOB *blob2 = *reinterpret_cast<const C_BLOB *const *>(blob2p);
29    return blob1->bounding_box().left() - blob2->bounding_box().left();
30  }
31  void Tesseract::fix_fuzzy_spaces(ETEXT_DESC *monitor, int32_t word_count, PAGE_RES *page_res) {
32    BLOCK_RES_IT block_res_it;
33    ROW_RES_IT row_res_it;
34    WERD_RES_IT word_res_it_from;
35    WERD_RES_IT word_res_it_to;
36    WERD_RES *word_res;
37    WERD_RES_LIST fuzzy_space_words;
38    int16_t new_length;
39    bool prevent_null_wd_fixsp; 
40    int32_t word_index;         
41    block_res_it.set_to_list(&page_res->block_res_list);
42    word_index = 0;
43    for (block_res_it.mark_cycle_pt(); !block_res_it.cycled_list(); block_res_it.forward()) {
44      row_res_it.set_to_list(&block_res_it.data()->row_res_list);
45      for (row_res_it.mark_cycle_pt(); !row_res_it.cycled_list(); row_res_it.forward()) {
46        word_res_it_from.set_to_list(&row_res_it.data()->word_res_list);
47        while (!word_res_it_from.at_last()) {
48          word_res = word_res_it_from.data();
49          while (!word_res_it_from.at_last() &&
50                 !(word_res->combination ||
51                   word_res_it_from.data_relative(1)->word->flag(W_FUZZY_NON) ||
52                   word_res_it_from.data_relative(1)->word->flag(W_FUZZY_SP))) {
53            fix_sp_fp_word(word_res_it_from, row_res_it.data()->row, block_res_it.data()->block);
54            word_res = word_res_it_from.forward();
55            word_index++;
56            if (monitor != nullptr) {
57              monitor->ocr_alive = true;
58              monitor->progress = 90 + 5 * word_index / word_count;
59              if (monitor->deadline_exceeded() ||
60                  (monitor->cancel != nullptr &&
61                   (*monitor->cancel)(monitor->cancel_this, stats_.dict_words))) {
62                return;
63              }
64            }
65          }
66          if (!word_res_it_from.at_last()) {
67            word_res_it_to = word_res_it_from;
68            prevent_null_wd_fixsp = word_res->word->cblob_list()->empty();
69            if (check_debug_pt(word_res, 60)) {
70              debug_fix_space_level.set_value(10);
71            }
72            word_res_it_to.forward();
73            word_index++;
74            if (monitor != nullptr) {
75              monitor->ocr_alive = true;
76              monitor->progress = 90 + 5 * word_index / word_count;
77              if (monitor->deadline_exceeded() ||
78                  (monitor->cancel != nullptr &&
79                   (*monitor->cancel)(monitor->cancel_this, stats_.dict_words))) {
80                return;
81              }
82            }
83            while (!word_res_it_to.at_last() &&
84                   (word_res_it_to.data_relative(1)->word->flag(W_FUZZY_NON) ||
85                    word_res_it_to.data_relative(1)->word->flag(W_FUZZY_SP))) {
86              if (check_debug_pt(word_res, 60)) {
87                debug_fix_space_level.set_value(10);
88              }
89              if (word_res->word->cblob_list()->empty()) {
90                prevent_null_wd_fixsp = true;
91              }
92              word_res = word_res_it_to.forward();
93            }
94            if (check_debug_pt(word_res, 60)) {
95              debug_fix_space_level.set_value(10);
96            }
97            if (word_res->word->cblob_list()->empty()) {
98              prevent_null_wd_fixsp = true;
99            }
100            if (prevent_null_wd_fixsp) {
101              word_res_it_from = word_res_it_to;
102            } else {
103              fuzzy_space_words.assign_to_sublist(&word_res_it_from, &word_res_it_to);
104              fix_fuzzy_space_list(fuzzy_space_words, row_res_it.data()->row,
105                                   block_res_it.data()->block);
106              new_length = fuzzy_space_words.length();
107              word_res_it_from.add_list_before(&fuzzy_space_words);
108              for (; !word_res_it_from.at_last() && new_length > 0; new_length--) {
109                word_res_it_from.forward();
110              }
111            }
112            if (test_pt) {
113              debug_fix_space_level.set_value(0);
114            }
115          }
116          fix_sp_fp_word(word_res_it_from, row_res_it.data()->row, block_res_it.data()->block);
117        }
118      }
119    }
120  }
121  void Tesseract::fix_fuzzy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block) {
122    int16_t best_score;
123    WERD_RES_LIST current_perm;
124    int16_t current_score;
125    bool improved = false;
126    best_score = eval_word_spacing(best_perm); 
127    dump_words(best_perm, best_score, 1, improved);
128    if (best_score != PERFECT_WERDS) {
129      initialise_search(best_perm, current_perm);
130    }
131    while ((best_score != PERFECT_WERDS) && !current_perm.empty()) {
132      match_current_words(current_perm, row, block);
133      current_score = eval_word_spacing(current_perm);
134      dump_words(current_perm, current_score, 2, improved);
135      if (current_score > best_score) {
136        best_perm.clear();
137        best_perm.deep_copy(&current_perm, &WERD_RES::deep_copy);
138        best_score = current_score;
139        improved = true;
140      }
141      if (current_score < PERFECT_WERDS) {
142        transform_to_next_perm(current_perm);
143      }
144    }
145    dump_words(best_perm, best_score, 3, improved);
146  }
147  void initialise_search(WERD_RES_LIST &src_list, WERD_RES_LIST &new_list) {
148    WERD_RES_IT src_it(&src_list);
149    WERD_RES_IT new_it(&new_list);
150    WERD_RES *src_wd;
151    WERD_RES *new_wd;
152    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
153      src_wd = src_it.data();
154      if (!src_wd->combination) {
155        new_wd = WERD_RES::deep_copy(src_wd);
156        new_wd->combination = false;
157        new_wd->part_of_combo = false;
158        new_it.add_after_then_move(new_wd);
159      }
160    }
161  }
162  void Tesseract::match_current_words(WERD_RES_LIST &words, ROW *row, BLOCK *block) {
163    WERD_RES_IT word_it(&words);
164    WERD_RES *word;
165    prev_word_best_choice_ = nullptr;
166    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
167      word = word_it.data();
168      if ((!word->part_of_combo) && (word->box_word == nullptr)) {
169        WordData word_data(block, row, word);
170        SetupWordPassN(2, &word_data);
171        classify_word_and_language(2, nullptr, &word_data);
172      }
173      prev_word_best_choice_ = word->best_choice;
174    }
175  }
176  int16_t Tesseract::eval_word_spacing(WERD_RES_LIST &word_res_list) {
177    WERD_RES_IT word_res_it(&word_res_list);
178    int16_t total_score = 0;
179    int16_t word_count = 0;
180    int16_t done_word_count = 0;
181    int i;
182    int16_t offset;
183    int16_t prev_word_score = 0;
184    bool prev_word_done = false;
185    bool prev_char_1 = false;     
186    bool prev_char_digit = false; 
187    const char *punct_chars = "!\"`',.:;";
188    bool prev_char_punct = false;
189    do {
190      WERD_RES *word = word_res_it.data();
191      bool word_done = fixspace_thinks_word_done(word);
192      word_count++;
193      if (word->tess_failed) {
194        total_score += prev_word_score;
195        if (prev_word_done) {
196          done_word_count++;
197        }
198        prev_word_score = 0;
199        prev_char_1 = false;
200        prev_char_digit = false;
201        prev_word_done = false;
202      } else {
203        auto word_len = word->reject_map.length();
204        bool current_word_ok_so_far = false;
205        if (!((prev_char_1 && digit_or_numeric_punct(word, 0)) ||
206              (prev_char_digit &&
207               ((word_done && word->best_choice->unichar_lengths().c_str()[0] == 1 &&
208                 word->best_choice->unichar_string()[0] == '1') ||
209                (!word_done &&
210                 conflict_set_I_l_1.contains(word->best_choice->unichar_string()[0])))))) {
211          total_score += prev_word_score;
212          if (prev_word_done) {
213            done_word_count++;
214          }
215          current_word_ok_so_far = word_done;
216        }
217        if (current_word_ok_so_far) {
218          prev_word_done = true;
219          prev_word_score = word_len;
220        } else {
221          prev_word_done = false;
222          prev_word_score = 0;
223        }
224        for (i = 0, prev_char_1 = false; i < word_len; i++) {
225          bool current_char_1 = word->best_choice->unichar_string()[i] == '1';
226          if (prev_char_1 || (current_char_1 && (i > 0))) {
227            total_score++;
228          }
229          prev_char_1 = current_char_1;
230        }
231        if (tessedit_prefer_joined_punct) {
232          for (i = 0, offset = 0, prev_char_punct = false; i < word_len;
233               offset += word->best_choice->unichar_lengths()[i++]) {
234            bool current_char_punct =
235                strchr(punct_chars, word->best_choice->unichar_string()[offset]) != nullptr;
236            if (prev_char_punct || (current_char_punct && i > 0)) {
237              total_score++;
238            }
239            prev_char_punct = current_char_punct;
240          }
241        }
242        prev_char_digit = digit_or_numeric_punct(word, word_len - 1);
243        for (i = 0, offset = 0; i < word_len - 1;
244             offset += word->best_choice->unichar_lengths()[i++]) {
245          ;
246        }
247        prev_char_1 =
248            ((word_done && (word->best_choice->unichar_string()[offset] == '1')) ||
249             (!word_done &&
250              conflict_set_I_l_1.contains(word->best_choice->unichar_string()[offset])));
251      }
252      do {
253        word_res_it.forward();
254      } while (word_res_it.data()->part_of_combo);
255    } while (!word_res_it.at_first());
256    total_score += prev_word_score;
257    if (prev_word_done) {
258      done_word_count++;
259    }
260    if (done_word_count == word_count) {
261      return PERFECT_WERDS;
262    } else {
263      return total_score;
264    }
265  }
266  bool Tesseract::digit_or_numeric_punct(WERD_RES *word, int char_position) {
267    int i;
268    int offset;
269    for (i = 0, offset = 0; i < char_position; offset += word->best_choice->unichar_lengths()[i++]) {
270      ;
271    }
272    return (
273        word->uch_set->get_isdigit(word->best_choice->unichar_string().c_str() + offset,
274                                   word->best_choice->unichar_lengths()[i]) ||
275        (word->best_choice->permuter() == NUMBER_PERM &&
276         numeric_punctuation.contains(word->best_choice->unichar_string().c_str()[offset])));
277  }
278  void transform_to_next_perm(WERD_RES_LIST &words) {
279    WERD_RES_IT word_it(&words);
280    WERD_RES_IT prev_word_it(&words);
281    WERD_RES *word;
282    WERD_RES *prev_word;
283    WERD_RES *combo;
284    WERD *copy_word;
285    int16_t prev_right = -INT16_MAX;
286    TBOX box;
287    int16_t gap;
288    int16_t min_gap = INT16_MAX;
289    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
290      word = word_it.data();
291      if (!word->part_of_combo) {
292        box = word->word->bounding_box();
293        if (prev_right > -INT16_MAX) {
294          gap = box.left() - prev_right;
295          if (gap < min_gap) {
296            min_gap = gap;
297          }
298        }
299        prev_right = box.right();
300      }
301    }
302    if (min_gap < INT16_MAX) {
303      prev_right = -INT16_MAX; 
304      word_it.set_to_list(&words);
305      for (; (prev_right == -INT16_MAX) || !word_it.at_first(); word_it.forward()) {
306        word = word_it.data();
307        if (!word->part_of_combo) {
308          box = word->word->bounding_box();
309          if (prev_right > -INT16_MAX) {
310            gap = box.left() - prev_right;
311            if (gap <= min_gap) {
312              prev_word = prev_word_it.data();
313              if (prev_word->combination) {
314                combo = prev_word;
315              } else {
316                copy_word = new WERD;
317                *copy_word = *(prev_word->word);
318                combo = new WERD_RES(copy_word);
319                combo->combination = true;
320                combo->x_height = prev_word->x_height;
321                prev_word->part_of_combo = true;
322                prev_word_it.add_before_then_move(combo);
323              }
324              combo->word->set_flag(W_EOL, word->word->flag(W_EOL));
325              if (word->combination) {
326                combo->word->join_on(word->word);
327                delete word_it.extract();
328              } else {
329                combo->copy_on(word);
330                word->part_of_combo = true;
331              }
332              combo->done = false;
333              combo->ClearResults();
334            } else {
335              prev_word_it = word_it; 
336            }
337          }
338          prev_right = box.right();
339        }
340      }
341    } else {
342      words.clear(); 
343    }
344  }
345  void Tesseract::dump_words(WERD_RES_LIST &perm, int16_t score, int16_t mode, bool improved) {
346    WERD_RES_IT word_res_it(&perm);
347    if (debug_fix_space_level > 0) {
348      if (mode == 1) {
349        stats_.dump_words_str = "";
350        for (word_res_it.mark_cycle_pt(); !word_res_it.cycled_list(); word_res_it.forward()) {
351          if (!word_res_it.data()->part_of_combo) {
352            stats_.dump_words_str += word_res_it.data()->best_choice->unichar_string();
353            stats_.dump_words_str += ' ';
354          }
355        }
356      }
357      if (debug_fix_space_level > 1) {
358        switch (mode) {
359          case 1:
360            tprintf("EXTRACTED (%d): \"", score);
361            break;
362          case 2:
363            tprintf("TESTED (%d): \"", score);
364            break;
365          case 3:
366            tprintf("RETURNED (%d): \"", score);
367            break;
368        }
369        for (word_res_it.mark_cycle_pt(); !word_res_it.cycled_list(); word_res_it.forward()) {
370          if (!word_res_it.data()->part_of_combo) {
371            tprintf("%s/%1d ", word_res_it.data()->best_choice->unichar_string().c_str(),
372                    static_cast<int>(word_res_it.data()->best_choice->permuter()));
373          }
374        }
375        tprintf("\"\n");
376      } else if (improved) {
377        tprintf("FIX SPACING \"%s\" => \"", stats_.dump_words_str.c_str());
378        for (word_res_it.mark_cycle_pt(); !word_res_it.cycled_list(); word_res_it.forward()) {
379          if (!word_res_it.data()->part_of_combo) {
380            tprintf("%s/%1d ", word_res_it.data()->best_choice->unichar_string().c_str(),
381                    static_cast<int>(word_res_it.data()->best_choice->permuter()));
382          }
383        }
384        tprintf("\"\n");
385      }
386    }
387  }
388  bool Tesseract::fixspace_thinks_word_done(WERD_RES *word) {
389    if (word->done) {
390      return true;
391    }
392    if (fixsp_done_mode > 0 &&
393        (word->tess_accepted || (fixsp_done_mode == 2 && word->reject_map.reject_count() == 0) ||
394         fixsp_done_mode == 3) &&
395        (strchr(word->best_choice->unichar_string().c_str(), ' ') == nullptr) &&
396        ((word->best_choice->permuter() == SYSTEM_DAWG_PERM) ||
397         (word->best_choice->permuter() == FREQ_DAWG_PERM) ||
398         (word->best_choice->permuter() == USER_DAWG_PERM) ||
399         (word->best_choice->permuter() == NUMBER_PERM))) {
400      return true;
401    } else {
402      return false;
403    }
404  }
405  void Tesseract::fix_sp_fp_word(WERD_RES_IT &word_res_it, ROW *row, BLOCK *block) {
406    WERD_RES *word_res;
407    WERD_RES_LIST sub_word_list;
408    WERD_RES_IT sub_word_list_it(&sub_word_list);
409    int16_t blob_index;
410    int16_t new_length;
411    float junk;
412    word_res = word_res_it.data();
413    if (word_res->word->flag(W_REP_CHAR) || word_res->combination || word_res->part_of_combo ||
414        !word_res->word->flag(W_DONT_CHOP)) {
415      return;
416    }
417    blob_index = worst_noise_blob(word_res, &junk);
418    if (blob_index < 0) {
419      return;
420    }
421    if (debug_fix_space_level > 1) {
422      tprintf("FP fixspace working on \"%s\"\n", word_res->best_choice->unichar_string().c_str());
423    }
424    word_res->word->rej_cblob_list()->sort(c_blob_comparator);
425    sub_word_list_it.add_after_stay_put(word_res_it.extract());
426    fix_noisy_space_list(sub_word_list, row, block);
427    new_length = sub_word_list.length();
428    word_res_it.add_list_before(&sub_word_list);
429    for (; !word_res_it.at_last() && new_length > 1; new_length--) {
430      word_res_it.forward();
431    }
432  }
<span onclick='openModal()' class='match'>433  void Tesseract::fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block) {
434    int16_t best_score;
435    WERD_RES_IT best_perm_it(&best_perm);
436    WERD_RES_LIST current_perm;
437    WERD_RES_IT current_perm_it(&current_perm);
438    WERD_RES *old_word_res;
439    int16_t current_score;
440    bool improved = false;
</span>441    best_score = fp_eval_word_spacing(best_perm); 
442    dump_words(best_perm, best_score, 1, improved);
443    old_word_res = best_perm_it.data();
444    old_word_res->combination = true; 
445    current_perm_it.add_to_end(WERD_RES::deep_copy(old_word_res));
446    old_word_res->combination = false; 
447    break_noisiest_blob_word(current_perm);
448    while (best_score != PERFECT_WERDS && !current_perm.empty()) {
449      match_current_words(current_perm, row, block);
450      current_score = fp_eval_word_spacing(current_perm);
451      dump_words(current_perm, current_score, 2, improved);
452      if (current_score > best_score) {
453        best_perm.clear();
454        best_perm.deep_copy(&current_perm, &WERD_RES::deep_copy);
455        best_score = current_score;
456        improved = true;
457      }
458      if (current_score < PERFECT_WERDS) {
459        break_noisiest_blob_word(current_perm);
460      }
461    }
462    dump_words(best_perm, best_score, 3, improved);
463  }
464  void Tesseract::break_noisiest_blob_word(WERD_RES_LIST &words) {
465    WERD_RES_IT word_it(&words);
466    WERD_RES_IT worst_word_it;
467    float worst_noise_score = 9999;
468    int worst_blob_index = -1; 
469    int blob_index;            
470    float noise_score;         
471    WERD_RES *word_res;
472    C_BLOB_IT blob_it;
473    C_BLOB_IT rej_cblob_it;
474    C_BLOB_LIST new_blob_list;
475    C_BLOB_IT new_blob_it;
476    C_BLOB_IT new_rej_cblob_it;
477    WERD *new_word;
478    int16_t start_of_noise_blob;
479    int16_t i;
480    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
481      blob_index = worst_noise_blob(word_it.data(), &noise_score);
482      if (blob_index > -1 && worst_noise_score > noise_score) {
483        worst_noise_score = noise_score;
484        worst_blob_index = blob_index;
485        worst_word_it = word_it;
486      }
487    }
488    if (worst_blob_index < 0) {
489      words.clear(); 
490      return;
491    }
492    word_res = worst_word_it.data();
493    new_blob_it.set_to_list(&new_blob_list);
494    blob_it.set_to_list(word_res->word->cblob_list());
495    for (i = 0; i < worst_blob_index; i++, blob_it.forward()) {
496      new_blob_it.add_after_then_move(blob_it.extract());
497    }
498    start_of_noise_blob = blob_it.data()->bounding_box().left();
499    delete blob_it.extract(); 
500    new_word = new WERD(&new_blob_list, word_res->word);
501    new_word->set_flag(W_EOL, false);
502    word_res->word->set_flag(W_BOL, false);
503    word_res->word->set_blanks(1); 
504    new_rej_cblob_it.set_to_list(new_word->rej_cblob_list());
505    rej_cblob_it.set_to_list(word_res->word->rej_cblob_list());
506    for (; (!rej_cblob_it.empty() &&
507            (rej_cblob_it.data()->bounding_box().left() < start_of_noise_blob));
508         rej_cblob_it.forward()) {
509      new_rej_cblob_it.add_after_then_move(rej_cblob_it.extract());
510    }
511    auto *new_word_res = new WERD_RES(new_word);
512    new_word_res->combination = true;
513    worst_word_it.add_before_then_move(new_word_res);
514    word_res->ClearResults();
515  }
516  int16_t Tesseract::worst_noise_blob(WERD_RES *word_res, float *worst_noise_score) {
517    float noise_score[512];
518    int min_noise_blob; 
519    int max_noise_blob; 
520    int non_noise_count;
521    int worst_noise_blob; 
522    float small_limit = kBlnXHeight * fixsp_small_outlines_size;
523    float non_noise_limit = kBlnXHeight * 0.8;
524    if (word_res->rebuild_word == nullptr) {
525      return -1; 
526    }
527    auto blob_count = word_res->box_word->length();
528    ASSERT_HOST(blob_count <= 512);
529    if (blob_count < 5) {
530      return -1; 
531    }
532  #ifndef SECURE_NAMES
533    if (debug_fix_space_level > 5) {
534      tprintf("FP fixspace Noise metrics for \"%s\": ",
535              word_res->best_choice->unichar_string().c_str());
536    }
537  #endif
538    for (unsigned i = 0; i < blob_count && i < word_res->rebuild_word->NumBlobs(); i++) {
539      TBLOB *blob = word_res->rebuild_word->blobs[i];
540      if (word_res->reject_map[i].accepted()) {
541        noise_score[i] = non_noise_limit;
542      } else {
543        noise_score[i] = blob_noise_score(blob);
544      }
545      if (debug_fix_space_level > 5) {
546        tprintf("%1.1f ", noise_score[i]);
547      }
548    }
549    if (debug_fix_space_level > 5) {
550      tprintf("\n");
551    }
552    non_noise_count = 0;
553    int i;
554    for (i = 0; static_cast<unsigned>(i) < blob_count && non_noise_count < fixsp_non_noise_limit; i++) {
555      if (noise_score[i] >= non_noise_limit) {
556        non_noise_count++;
557      }
558    }
559    if (non_noise_count < fixsp_non_noise_limit) {
560      return -1;
561    }
562    min_noise_blob = i;
563    non_noise_count = 0;
564    for (i = blob_count - 1; i >= 0 && non_noise_count < fixsp_non_noise_limit; i--) {
565      if (noise_score[i] >= non_noise_limit) {
566        non_noise_count++;
567      }
568    }
569    if (non_noise_count < fixsp_non_noise_limit) {
570      return -1;
571    }
572    max_noise_blob = i;
573    if (min_noise_blob > max_noise_blob) {
574      return -1;
575    }
576    *worst_noise_score = small_limit;
577    worst_noise_blob = -1;
578    for (auto i = min_noise_blob; i <= max_noise_blob; i++) {
579      if (noise_score[i] < *worst_noise_score) {
580        worst_noise_blob = i;
581        *worst_noise_score = noise_score[i];
582      }
583    }
584    return worst_noise_blob;
585  }
586  float Tesseract::blob_noise_score(TBLOB *blob) {
587    TBOX box; 
588    int16_t outline_count = 0;
589    int16_t max_dimension;
590    int16_t largest_outline_dimension = 0;
591    for (TESSLINE *ol = blob->outlines; ol != nullptr; ol = ol->next) {
592      outline_count++;
593      box = ol->bounding_box();
594      if (box.height() > box.width()) {
595        max_dimension = box.height();
596      } else {
597        max_dimension = box.width();
598      }
599      if (largest_outline_dimension < max_dimension) {
600        largest_outline_dimension = max_dimension;
601      }
602    }
603    if (outline_count > 5) {
604      largest_outline_dimension *= 2;
605    }
606    box = blob->bounding_box();
607    if (box.bottom() > kBlnBaselineOffset * 4 || box.top() < kBlnBaselineOffset / 2) {
608      largest_outline_dimension /= 2;
609    }
610    return largest_outline_dimension;
611  }
612  void fixspace_dbg(WERD_RES *word) {
613    TBOX box = word->word->bounding_box();
614    const bool show_map_detail = false;
615    int16_t i;
616    box.print();
617    tprintf(" \"%s\" ", word->best_choice->unichar_string().c_str());
618    tprintf("Blob count: %d (word); %d/%d (rebuild word)\n", word->word->cblob_list()->length(),
619            word->rebuild_word->NumBlobs(), word->box_word->length());
620    word->reject_map.print(debug_fp);
621    tprintf("\n");
622    if (show_map_detail) {
623      tprintf("\"%s\"\n", word->best_choice->unichar_string().c_str());
624      for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++) {
625        tprintf("**** \"%c\" ****\n", word->best_choice->unichar_string()[i]);
626        word->reject_map[i].full_print(debug_fp);
627      }
628    }
629    tprintf("Tess Accepted: %s\n", word->tess_accepted ? "TRUE" : "FALSE");
630    tprintf("Done flag: %s\n\n", word->done ? "TRUE" : "FALSE");
631  }
632  int16_t Tesseract::fp_eval_word_spacing(WERD_RES_LIST &word_res_list) {
633    WERD_RES_IT word_it(&word_res_list);
634    WERD_RES *word;
635    int16_t score = 0;
636    float small_limit = kBlnXHeight * fixsp_small_outlines_size;
637    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
638      word = word_it.data();
639      if (word->rebuild_word == nullptr) {
640        continue; 
641      }
642      if (word->done || word->tess_accepted || word->best_choice->permuter() == SYSTEM_DAWG_PERM ||
643          word->best_choice->permuter() == FREQ_DAWG_PERM ||
644          word->best_choice->permuter() == USER_DAWG_PERM || safe_dict_word(word) > 0) {
645        auto num_blobs = word->rebuild_word->NumBlobs();
646        UNICHAR_ID space = word->uch_set->unichar_to_id(" ");
647        for (unsigned i = 0; i < word->best_choice->length() && i < num_blobs; ++i) {
648          TBLOB *blob = word->rebuild_word->blobs[i];
649          if (word->best_choice->unichar_id(i) == space || blob_noise_score(blob) < small_limit) {
650            score -= 1; 
651          } else if (word->reject_map[i].accepted()) {
652            score++;
653          }
654        }
655      }
656    }
657    if (score < 0) {
658      score = 0;
659    }
660    return score;
661  }
662  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-generated-actions.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-fixspace.cpp</div>
                </div>
                <div class="column column_space"><pre><code>264    static R Call(Function function, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
265        A7 a7, A8 a8, A9 a9) {
</pre></code></div>
                <div class="column column_space"><pre><code>433  void Tesseract::fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block) {
434    int16_t best_score;
435    WERD_RES_IT best_perm_it(&best_perm);
436    WERD_RES_LIST current_perm;
437    WERD_RES_IT current_perm_it(&current_perm);
438    WERD_RES *old_word_res;
439    int16_t current_score;
440    bool improved = false;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    