
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.911802853437094%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_inner_product_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "gtest/gtest.h"
3  #include "caffe/blob.hpp"
4  #include "caffe/common.hpp"
5  #include "caffe/filler.hpp"
6  #include "caffe/layers/inner_product_layer.hpp"
7  #include "caffe/test/test_caffe_main.hpp"
8  #include "caffe/test/test_gradient_check_util.hpp"
9  namespace caffe {
10  #ifndef CPU_ONLY
11  extern cudaDeviceProp CAFFE_TEST_CUDA_PROP;
12  #endif
13  template <typename TypeParam>
14  class InnerProductLayerTest : public MultiDeviceTest<TypeParam> {
15    typedef typename TypeParam::Dtype Dtype;
16   protected:
17    InnerProductLayerTest()
18        : blob_bottom_(new Blob<Dtype>(2, 3, 4, 5)),
19          blob_bottom_nobatch_(new Blob<Dtype>(1, 2, 3, 4)),
20          blob_top_(new Blob<Dtype>()) {
21      FillerParameter filler_param;
22      UniformFiller<Dtype> filler(filler_param);
23      filler.Fill(this->blob_bottom_);
24      blob_top_vec_.push_back(blob_top_);
25    }
26    virtual ~InnerProductLayerTest() {
27      delete blob_bottom_;
28      delete blob_bottom_nobatch_;
29      std::for_each(this->blob_top_vec_.begin(), this->blob_top_vec_.end(),
30                                        [](Blob<Dtype>* pPtr) {delete pPtr; });
31    }
32    Blob<Dtype>* const blob_bottom_;
33    Blob<Dtype>* const blob_bottom_nobatch_;
34    Blob<Dtype>* const blob_top_;
35    vector<Blob<Dtype>*> blob_bottom_vec_;
36    vector<Blob<Dtype>*> blob_top_vec_;
37  };
38  TYPED_TEST_CASE(InnerProductLayerTest, TestDtypesAndDevices);
39  TYPED_TEST(InnerProductLayerTest, TestSetUp) {
40    typedef typename TypeParam::Dtype Dtype;
41    this->blob_bottom_vec_.push_back(this->blob_bottom_);
42    LayerParameter layer_param;
43    InnerProductParameter* inner_product_param =
44        layer_param.mutable_inner_product_param();
45    inner_product_param->set_num_output(10);
46    shared_ptr<InnerProductLayer<Dtype> > layer(
47        new InnerProductLayer<Dtype>(layer_param));
48    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
49    EXPECT_EQ(this->blob_top_->num(), 2);
50    EXPECT_EQ(this->blob_top_->height(), 1);
51    EXPECT_EQ(this->blob_top_->width(), 1);
52    EXPECT_EQ(this->blob_top_->channels(), 10);
53  }
54  TYPED_TEST(InnerProductLayerTest, TestSetUpTranposeFalse) {
55    typedef typename TypeParam::Dtype Dtype;
56    this->blob_bottom_vec_.push_back(this->blob_bottom_);
57    LayerParameter layer_param;
58    InnerProductParameter* inner_product_param =
59        layer_param.mutable_inner_product_param();
60    inner_product_param->set_num_output(10);
61    inner_product_param->set_transpose(false);
62    shared_ptr<InnerProductLayer<Dtype> > layer(
63        new InnerProductLayer<Dtype>(layer_param));
64    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
65    EXPECT_EQ(2, this->blob_top_->num());
66    EXPECT_EQ(1, this->blob_top_->height());
67    EXPECT_EQ(1, this->blob_top_->width());
68    EXPECT_EQ(10, this->blob_top_->channels());
69    EXPECT_EQ(2, layer->blobs()[0]->num_axes());
70    EXPECT_EQ(10, layer->blobs()[0]->shape(0));
71    EXPECT_EQ(60, layer->blobs()[0]->shape(1));
72  }
73  TYPED_TEST(InnerProductLayerTest, TestSetUpTranposeTrue) {
74    typedef typename TypeParam::Dtype Dtype;
75    this->blob_bottom_vec_.push_back(this->blob_bottom_);
76    LayerParameter layer_param;
77    InnerProductParameter* inner_product_param =
78        layer_param.mutable_inner_product_param();
79    inner_product_param->set_num_output(10);
80    inner_product_param->set_transpose(true);
81    shared_ptr<InnerProductLayer<Dtype> > layer(
82        new InnerProductLayer<Dtype>(layer_param));
83    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
84    EXPECT_EQ(2, this->blob_top_->num());
85    EXPECT_EQ(1, this->blob_top_->height());
86    EXPECT_EQ(1, this->blob_top_->width());
87    EXPECT_EQ(10, this->blob_top_->channels());
88    EXPECT_EQ(2, layer->blobs()[0]->num_axes());
89    EXPECT_EQ(60, layer->blobs()[0]->shape(0));
90    EXPECT_EQ(10, layer->blobs()[0]->shape(1));
91  }
92  TYPED_TEST(InnerProductLayerTest, TestForward) {
93    typedef typename TypeParam::Dtype Dtype;
94    this->blob_bottom_vec_.push_back(this->blob_bottom_);
95    bool IS_VALID_CUDA = false;
96  #ifndef CPU_ONLY
97    IS_VALID_CUDA = CAFFE_TEST_CUDA_PROP.major >= 2;
98  #endif
99    if (Caffe::mode() == Caffe::CPU ||
100        sizeof(Dtype) == 4 || IS_VALID_CUDA) {
101      LayerParameter layer_param;
102      InnerProductParameter* inner_product_param =
103          layer_param.mutable_inner_product_param();
104      inner_product_param->set_num_output(10);
105      inner_product_param->mutable_weight_filler()->set_type("uniform");
106      inner_product_param->mutable_bias_filler()->set_type("uniform");
107      inner_product_param->mutable_bias_filler()->set_min(1);
108      inner_product_param->mutable_bias_filler()->set_max(2);
109      shared_ptr<InnerProductLayer<Dtype> > layer(
110          new InnerProductLayer<Dtype>(layer_param));
111      layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
112      layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
113      const Dtype* data = this->blob_top_->cpu_data();
114      const int count = this->blob_top_->count();
115      for (int i = 0; i < count; ++i) {
116        EXPECT_GE(data[i], 1.);
117      }
118    } else {
119      LOG(ERROR) << "Skipping test due to old architecture.";
120    }
121  }
122  TYPED_TEST(InnerProductLayerTest, TestForwardTranspose) {
123    typedef typename TypeParam::Dtype Dtype;
124    this->blob_bottom_vec_.push_back(this->blob_bottom_);
125    bool IS_VALID_CUDA = false;
126  #ifndef CPU_ONLY
127    IS_VALID_CUDA = CAFFE_TEST_CUDA_PROP.major >= 2;
128  #endif
129    if (Caffe::mode() == Caffe::CPU ||
130        sizeof(Dtype) == 4 || IS_VALID_CUDA) {
131      LayerParameter layer_param;
132      InnerProductParameter* inner_product_param =
133          layer_param.mutable_inner_product_param();
134      inner_product_param->set_num_output(10);
135      inner_product_param->mutable_weight_filler()->set_type("uniform");
136      inner_product_param->mutable_bias_filler()->set_type("uniform");
137      inner_product_param->mutable_bias_filler()->set_min(1);
138      inner_product_param->mutable_bias_filler()->set_max(2);
139      inner_product_param->set_transpose(false);
140      shared_ptr<InnerProductLayer<Dtype> > layer(
141          new InnerProductLayer<Dtype>(layer_param));
142      layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
143      layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
144      const int count = this->blob_top_->count();
145      Blob<Dtype>* const top = new Blob<Dtype>();
146      top->ReshapeLike(*this->blob_top_);
147      caffe_copy(count, this->blob_top_->cpu_data(), top->mutable_cpu_data());
148      std::for_each(this->blob_top_vec_.begin(), this->blob_top_vec_.end(),
149                                        [](Blob<Dtype>* pPtr) {delete pPtr; });
150      this->blob_top_vec_.clear();
151      this->blob_top_vec_.push_back(new Blob<Dtype>());
152      inner_product_param->set_transpose(true);
153      shared_ptr<InnerProductLayer<Dtype> > ip_t(
154          new InnerProductLayer<Dtype>(layer_param));
155      ip_t->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
156      const int count_w = layer->blobs()[0]->count();
157      EXPECT_EQ(count_w, ip_t->blobs()[0]->count());
158      const Dtype* w = layer->blobs()[0]->cpu_data();
159      Dtype* w_t = ip_t->blobs()[0]->mutable_cpu_data();
160      const int width = layer->blobs()[0]->shape(1);
161      const int width_t = ip_t->blobs()[0]->shape(1);
162      for (int i = 0; i < count_w; ++i) {
163        int r = i / width;
164        int c = i % width;
165        w_t[c*width_t+r] = w[r*width+c];  
166      }
167      ASSERT_EQ(layer->blobs()[1]->count(), ip_t->blobs()[1]->count());
168      caffe_copy(layer->blobs()[1]->count(), layer->blobs()[1]->cpu_data(),
169          ip_t->blobs()[1]->mutable_cpu_data());
170      ip_t->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
171      EXPECT_EQ(count, this->blob_top_vec_[0]->count())
172          << "Invalid count for top blob for IP with transpose.";
173      Blob<Dtype>* const top_t = new Blob<Dtype>();\
174      top_t->ReshapeLike(*this->blob_top_vec_[0]);
175      caffe_copy(count,
176        this->blob_top_vec_[0]->cpu_data(),
177        top_t->mutable_cpu_data());
178      const Dtype* data = top->cpu_data();
179      const Dtype* data_t = top_t->cpu_data();
180      for (int i = 0; i < count; ++i) {
181        EXPECT_FLOAT_EQ(data[i], data_t[i]);
182      }
183      delete top;
184      delete top_t;
185    } else {
186      LOG(ERROR) << "Skipping test due to old architecture.";
187    }
188  }
189  TYPED_TEST(InnerProductLayerTest, TestForwardNoBatch) {
190    typedef typename TypeParam::Dtype Dtype;
191    this->blob_bottom_vec_.push_back(this->blob_bottom_nobatch_);
192    bool IS_VALID_CUDA = false;
193  #ifndef CPU_ONLY
194    IS_VALID_CUDA = CAFFE_TEST_CUDA_PROP.major >= 2;
195  #endif
196    if (Caffe::mode() == Caffe::CPU ||
197        sizeof(Dtype) == 4 || IS_VALID_CUDA) {
198      LayerParameter layer_param;
199      InnerProductParameter* inner_product_param =
200          layer_param.mutable_inner_product_param();
201      inner_product_param->set_num_output(10);
202      inner_product_param->mutable_weight_filler()->set_type("uniform");
203      inner_product_param->mutable_bias_filler()->set_type("uniform");
204      inner_product_param->mutable_bias_filler()->set_min(1);
205      inner_product_param->mutable_bias_filler()->set_max(2);
206      shared_ptr<InnerProductLayer<Dtype> > layer(
207          new InnerProductLayer<Dtype>(layer_param));
208      layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
209      layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
210      const Dtype* data = this->blob_top_->cpu_data();
211      const int count = this->blob_top_->count();
212      for (int i = 0; i < count; ++i) {
213        EXPECT_GE(data[i], 1.);
214      }
215    } else {
216      LOG(ERROR) << "Skipping test due to old architecture.";
217    }
218  }
219  TYPED_TEST(InnerProductLayerTest, TestGradient) {
220    typedef typename TypeParam::Dtype Dtype;
221    this->blob_bottom_vec_.push_back(this->blob_bottom_);
222    bool IS_VALID_CUDA = false;
223  #ifndef CPU_ONLY
224    IS_VALID_CUDA = CAFFE_TEST_CUDA_PROP.major >= 2;
225  #endif
226    if (Caffe::mode() == Caffe::CPU ||
227        sizeof(Dtype) == 4 || IS_VALID_CUDA) {
228      LayerParameter layer_param;
229      InnerProductParameter* inner_product_param =
230          layer_param.mutable_inner_product_param();
231      inner_product_param->set_num_output(10);
232      inner_product_param->mutable_weight_filler()->set_type("gaussian");
233      inner_product_param->mutable_bias_filler()->set_type("gaussian");
234      inner_product_param->mutable_bias_filler()->set_min(1);
235      inner_product_param->mutable_bias_filler()->set_max(2);
236      InnerProductLayer<Dtype> layer(layer_param);
237      GradientChecker<Dtype> checker(1e-2, 1e-3);
238      checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
239          this->blob_top_vec_);
240    } else {
241      LOG(ERROR) << "Skipping test due to old architecture.";
242    }
243  }
244  TYPED_TEST(InnerProductLayerTest, TestGradientTranspose) {
245    typedef typename TypeParam::Dtype Dtype;
246    this->blob_bottom_vec_.push_back(this->blob_bottom_);
247    bool IS_VALID_CUDA = false;
248  #ifndef CPU_ONLY
249    IS_VALID_CUDA = CAFFE_TEST_CUDA_PROP.major >= 2;
250  #endif
251    if (Caffe::mode() == Caffe::CPU ||
252        sizeof(Dtype) == 4 || IS_VALID_CUDA) {
253      LayerParameter layer_param;
254      InnerProductParameter* inner_product_param =
255          layer_param.mutable_inner_product_param();
256      inner_product_param->set_num_output(11);
257      inner_product_param->mutable_weight_filler()->set_type("gaussian");
258      inner_product_param->mutable_bias_filler()->set_type("gaussian");
259      inner_product_param->mutable_bias_filler()->set_min(1);
260      inner_product_param->mutable_bias_filler()->set_max(2);
261      inner_product_param->set_transpose(true);
262      InnerProductLayer<Dtype> layer(layer_param);
263      GradientChecker<Dtype> checker(1e-2, 1e-3);
264      checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
265          this->blob_top_vec_);
266    } else {
267      LOG(ERROR) << "Skipping test due to old architecture.";
268    }
269  }
270  TYPED_TEST(InnerProductLayerTest, TestBackwardTranspose) {
271    typedef typename TypeParam::Dtype Dtype;
272    this->blob_bottom_vec_.push_back(this->blob_bottom_);
273    bool IS_VALID_CUDA = false;
274  #ifndef CPU_ONLY
275    IS_VALID_CUDA = CAFFE_TEST_CUDA_PROP.major >= 2;
276  #endif
277    if (Caffe::mode() == Caffe::CPU ||
278        sizeof(Dtype) == 4 || IS_VALID_CUDA) {
279      LayerParameter layer_param;
280      InnerProductParameter* inner_product_param =
281          layer_param.mutable_inner_product_param();
282      inner_product_param->set_num_output(10);
283      inner_product_param->mutable_weight_filler()->set_type("uniform");
284      inner_product_param->mutable_bias_filler()->set_type("uniform");
285      inner_product_param->mutable_bias_filler()->set_min(1);
286      inner_product_param->mutable_bias_filler()->set_max(2);
287      inner_product_param->set_transpose(false);
288      shared_ptr<InnerProductLayer<Dtype> > layer(
289          new InnerProductLayer<Dtype>(layer_param));
290      layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
291      layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
292      Blob<Dtype>* const top = new Blob<Dtype>();
293      top->CopyFrom(*this->blob_top_, false, true);
294      Blob<Dtype>* const diff = new Blob<Dtype>();
295      diff->ReshapeLike(*this->blob_top_);
296      {
297        FillerParameter filler_param;
298        UniformFiller<Dtype> filler(filler_param);
299        filler.Fill(diff);
300      }
301      caffe_copy(this->blob_top_vec_[0]->count(),
302        diff->cpu_data(),
303        this->blob_top_vec_[0]->mutable_cpu_diff());
304      vector<bool> propagate_down(1, true);
305      layer->Backward(this->blob_top_vec_,
306          propagate_down,
307          this->blob_bottom_vec_);
308      Blob<Dtype>* const w = new Blob<Dtype>();
309      w->CopyFrom(*layer->blobs()[0], false, true);
310      w->CopyFrom(*layer->blobs()[0], true, true);
311      Blob<Dtype>* const bottom_diff = new Blob<Dtype>();
312      bottom_diff->CopyFrom(*this->blob_bottom_vec_[0], true, true);
313      std::for_each(this->blob_top_vec_.begin(), this->blob_top_vec_.end(),
314                                        [](Blob<Dtype>* pPtr) {delete pPtr; });
315      this->blob_top_vec_.clear();
316      this->blob_top_vec_.push_back(new Blob<Dtype>());
317      inner_product_param->set_transpose(true);
318      shared_ptr<InnerProductLayer<Dtype> > ip_t(
319          new InnerProductLayer<Dtype>(layer_param));
320      ip_t->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
321      {
322        const Dtype* w_src = w->cpu_data();
323        Dtype* w_t = ip_t->blobs()[0]->mutable_cpu_data();
324        const int width = layer->blobs()[0]->shape(1);
325        const int width_t = ip_t->blobs()[0]->shape(1);
326        for (int i = 0; i < layer->blobs()[0]->count(); ++i) {
327          int r = i / width;
328          int c = i % width;
329          w_t[c*width_t+r] = w_src[r*width+c];  
330        }
331        ASSERT_EQ(layer->blobs()[1]->count(), ip_t->blobs()[1]->count());
332        caffe_copy(layer->blobs()[1]->count(), layer->blobs()[1]->cpu_data(),
333            ip_t->blobs()[1]->mutable_cpu_data());
334      }
335      ip_t->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
336      caffe_copy(this->blob_top_vec_[0]->count(),
337        diff->cpu_data(),
338        this->blob_top_vec_[0]->mutable_cpu_diff());
<span onclick='openModal()' class='match'>339      ip_t->Backward(this->blob_top_vec_, propagate_down, this->blob_bottom_vec_);
340      const Dtype* data = w->cpu_diff();
341      const Dtype* data_t = ip_t->blobs()[0]->cpu_diff();
342      const int WIDTH = layer->blobs()[0]->shape(1);
</span>343      const int WIDTH_T = ip_t->blobs()[0]->shape(1);
344      for (int i = 0; i < layer->blobs()[0]->count(); ++i) {
345        int r = i / WIDTH;
346        int c = i % WIDTH;
347        EXPECT_NE(Dtype(0.), data[r*WIDTH+c]);
348        EXPECT_FLOAT_EQ(data[r*WIDTH+c], data_t[c*WIDTH_T+r]);
349      }
350      data = bottom_diff->cpu_diff();
351      data_t = this->blob_bottom_vec_[0]->cpu_diff();
352      for (int i = 0; i < this->blob_bottom_vec_[0]->count(); ++i) {
353        EXPECT_NE(Dtype(0.), data[i]);
354        EXPECT_FLOAT_EQ(data[i], data_t[i]);
355      }
356      delete bottom_diff;
357      delete diff;
358      delete w;
359      delete top;
360    } else {
361      LOG(ERROR) << "Skipping test due to old architecture.";
362    }
363  }
364  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_ring.h"
2  #include <cassert>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iostream>
6  #include <limits>
7  #include <memory>
8  #include <string>
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/throw_delegate.h"
11  #include "absl/base/macros.h"
12  #include "absl/container/inlined_vector.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_consume.h"
15  #include "absl/strings/internal/cord_rep_flat.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace cord_internal {
19  namespace {
20  using index_type = CordRepRing::index_type;
21  enum class Direction { kForward, kReversed };
22  inline bool IsFlatOrExternal(CordRep* rep) {
23    return rep->IsFlat() || rep->IsExternal();
24  }
25  inline void CheckCapacity(size_t n, size_t extra) {
26    if (ABSL_PREDICT_FALSE(extra > CordRepRing::kMaxCapacity - n)) {
27      base_internal::ThrowStdLengthError("Maximum capacity exceeded");
28    }
29  }
30  CordRepFlat* CreateFlat(const char* s, size_t n, size_t extra = 0) {  
31    assert(n <= kMaxFlatLength);
32    auto* rep = CordRepFlat::New(n + extra);
33    rep->length = n;
34    memcpy(rep->Data(), s, n);
35    return rep;
36  }
37  void UnrefEntries(const CordRepRing* rep, index_type head, index_type tail) {
38    rep->ForEach(head, tail, [rep](index_type ix) {
39      CordRep* child = rep->entry_child(ix);
40      if (!child->refcount.Decrement()) {
41        if (child->tag >= FLAT) {
42          CordRepFlat::Delete(child->flat());
43        } else {
44          CordRepExternal::Delete(child->external());
45        }
46      }
47    });
48  }
49  }  
50  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep) {
51    s << "  CordRepRing(" << &rep << ", length = " << rep.length
52      << ", head = " << rep.head_ << ", tail = " << rep.tail_
53      << ", cap = " << rep.capacity_ << ", rc = " << rep.refcount.Get()
54      << ", begin_pos_ = " << static_cast<ptrdiff_t>(rep.begin_pos_) << ") {\n";
55    CordRepRing::index_type head = rep.head();
56    do {
57      CordRep* child = rep.entry_child(head);
58      s << " entry[" << head << "] length = " << rep.entry_length(head)
59        << ", child " << child << ", clen = " << child->length
60        << ", tag = " << static_cast<int>(child->tag)
61        << ", rc = " << child->refcount.Get()
62        << ", offset = " << rep.entry_data_offset(head)
63        << ", end_pos = " << static_cast<ptrdiff_t>(rep.entry_end_pos(head))
64        << "\n";
65      head = rep.advance(head);
66    } while (head != rep.tail());
67    return s << "}\n";
68  }
69  void CordRepRing::AddDataOffset(index_type index, size_t n) {
70    entry_data_offset()[index] += static_cast<offset_type>(n);
71  }
72  void CordRepRing::SubLength(index_type index, size_t n) {
73    entry_end_pos()[index] -= n;
74  }
75  class CordRepRing::Filler {
76   public:
77    Filler(CordRepRing* rep, index_type pos) : rep_(rep), head_(pos), pos_(pos) {}
78    index_type head() const { return head_; }
79    index_type pos() const { return pos_; }
80    void Add(CordRep* child, size_t offset, pos_type end_pos) {
81      rep_->entry_end_pos()[pos_] = end_pos;
82      rep_->entry_child()[pos_] = child;
83      rep_->entry_data_offset()[pos_] = static_cast<offset_type>(offset);
84      pos_ = rep_->advance(pos_);
85    }
86   private:
87    CordRepRing* rep_;
88    index_type head_;
89    index_type pos_;
90  };
91  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
92  constexpr size_t CordRepRing::kMaxCapacity;
93  #endif
94  bool CordRepRing::IsValid(std::ostream& output) const {
95    if (capacity_ == 0) {
96      output << "capacity == 0";
97      return false;
98    }
99    if (head_ >= capacity_ || tail_ >= capacity_) {
100      output << "head " << head_ << " and/or tail " << tail_ << "exceed capacity "
101             << capacity_;
102      return false;
103    }
104    const index_type back = retreat(tail_);
105    size_t pos_length = Distance(begin_pos_, entry_end_pos(back));
106    if (pos_length != length) {
107      output << "length " << length << " does not match positional length "
108             << pos_length << " from begin_pos " << begin_pos_ << " and entry["
109             << back << "].end_pos " << entry_end_pos(back);
110      return false;
111    }
112    index_type head = head_;
113    pos_type begin_pos = begin_pos_;
114    do {
115      pos_type end_pos = entry_end_pos(head);
116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
127      if (child->tag < FLAT && child->tag != EXTERNAL) {
128        output << "entry[" << head << "].child has an invalid tag "
129               << static_cast<int>(child->tag);
130        return false;
131      }
132      size_t offset = entry_data_offset(head);
133      if (offset >= child->length || entry_length > child->length - offset) {
134        output << "entry[" << head << "] has offset " << offset
135               << " and entry length " << entry_length
136               << " which are outside of the child's length of " << child->length;
137        return false;
138      }
139      begin_pos = end_pos;
140      head = advance(head);
141    } while (head != tail_);
142    return true;
143  }
144  #ifdef EXTRA_CORD_RING_VALIDATION
145  CordRepRing* CordRepRing::Validate(CordRepRing* rep, const char* file,
146                                     int line) {
147    if (!rep->IsValid(std::cerr)) {
148      std::cerr << "\nERROR: CordRepRing corrupted";
149      if (line) std::cerr << " at line " << line;
150      if (file) std::cerr << " in file " << file;
151      std::cerr << "\nContent = " << *rep;
152      abort();
153    }
154    return rep;
155  }
156  #endif  
157  CordRepRing* CordRepRing::New(size_t capacity, size_t extra) {
158    CheckCapacity(capacity, extra);
159    size_t size = AllocSize(capacity += extra);
160    void* mem = ::operator new(size);
161    auto* rep = new (mem) CordRepRing(static_cast<index_type>(capacity));
162    rep->tag = RING;
163    rep->capacity_ = static_cast<index_type>(capacity);
164    rep->begin_pos_ = 0;
165    return rep;
166  }
167  void CordRepRing::SetCapacityForTesting(size_t capacity) {
168    assert(capacity <= capacity_);
169    assert(head() == 0 || head() < tail());
170    memmove(Layout::Partial(capacity).Pointer<1>(data_) + head(),
171            Layout::Partial(capacity_).Pointer<1>(data_) + head(),
172            entries() * sizeof(Layout::ElementType<1>));
173    memmove(Layout::Partial(capacity, capacity).Pointer<2>(data_) + head(),
174            Layout::Partial(capacity_, capacity_).Pointer<2>(data_) + head(),
175            entries() * sizeof(Layout::ElementType<2>));
176    capacity_ = static_cast<index_type>(capacity);
177  }
178  void CordRepRing::Delete(CordRepRing* rep) {
179    assert(rep != nullptr && rep->IsRing());
180  #if defined(__cpp_sized_deallocation)
181    size_t size = AllocSize(rep->capacity_);
182    rep->~CordRepRing();
183    ::operator delete(rep, size);
184  #else
185    rep->~CordRepRing();
186    ::operator delete(rep);
187  #endif
188  }
189  void CordRepRing::Destroy(CordRepRing* rep) {
190    UnrefEntries(rep, rep->head(), rep->tail());
191    Delete(rep);
192  }
193  template <bool ref>
194  void CordRepRing::Fill(const CordRepRing* src, index_type head,
195                         index_type tail) {
196    this->length = src->length;
197    head_ = 0;
198    tail_ = advance(0, src->entries(head, tail));
199    begin_pos_ = src->begin_pos_;
200    auto* dst_pos = entry_end_pos();
201    auto* dst_child = entry_child();
202    auto* dst_offset = entry_data_offset();
203    src->ForEach(head, tail, [&](index_type index) {
204      *dst_pos++ = src->entry_end_pos(index);
205      CordRep* child = src->entry_child(index);
206      *dst_child++ = ref ? CordRep::Ref(child) : child;
207      *dst_offset++ = src->entry_data_offset(index);
208    });
209  }
210  CordRepRing* CordRepRing::Copy(CordRepRing* rep, index_type head,
211                                 index_type tail, size_t extra) {
212    CordRepRing* newrep = CordRepRing::New(rep->entries(head, tail), extra);
213    newrep->Fill<true>(rep, head, tail);
214    CordRep::Unref(rep);
215    return newrep;
216  }
217  CordRepRing* CordRepRing::Mutable(CordRepRing* rep, size_t extra) {
218    size_t entries = rep->entries();
219    if (!rep->refcount.IsOne()) {
220      return Copy(rep, rep->head(), rep->tail(), extra);
221    } else if (entries + extra > rep->capacity()) {
222      const size_t min_grow = rep->capacity() + rep->capacity() / 2;
223      const size_t min_extra = (std::max)(extra, min_grow - entries);
224      CordRepRing* newrep = CordRepRing::New(entries, min_extra);
225      newrep->Fill<false>(rep, rep->head(), rep->tail());
226      CordRepRing::Delete(rep);
227      return newrep;
228    } else {
229      return rep;
230    }
231  }
232  Span<char> CordRepRing::GetAppendBuffer(size_t size) {
233    assert(refcount.IsOne());
234    index_type back = retreat(tail_);
235    CordRep* child = entry_child(back);
236    if (child->tag >= FLAT && child->refcount.IsOne()) {
237      size_t capacity = child->flat()->Capacity();
<span onclick='openModal()' class='match'>238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
</span>242      if (size_t n = (std::min)(capacity - used, size)) {
243        child->length = data_offset + entry_length + n;
244        entry_end_pos()[back] = end_pos + n;
245        this->length += n;
246        return {child->flat()->Data() + used, n};
247      }
248    }
249    return {nullptr, 0};
250  }
251  Span<char> CordRepRing::GetPrependBuffer(size_t size) {
252    assert(refcount.IsOne());
253    CordRep* child = entry_child(head_);
254    size_t data_offset = entry_data_offset(head_);
255    if (data_offset && child->refcount.IsOne() && child->tag >= FLAT) {
256      size_t n = (std::min)(data_offset, size);
257      this->length += n;
258      begin_pos_ -= n;
259      data_offset -= n;
260      entry_data_offset()[head_] = static_cast<offset_type>(data_offset);
261      return {child->flat()->Data() + data_offset, n};
262    }
263    return {nullptr, 0};
264  }
265  CordRepRing* CordRepRing::CreateFromLeaf(CordRep* child, size_t offset,
266                                           size_t len, size_t extra) {
267    CordRepRing* rep = CordRepRing::New(1, extra);
268    rep->head_ = 0;
269    rep->tail_ = rep->advance(0);
270    rep->length = len;
271    rep->entry_end_pos()[0] = len;
272    rep->entry_child()[0] = child;
273    rep->entry_data_offset()[0] = static_cast<offset_type>(offset);
274    return Validate(rep);
275  }
276  CordRepRing* CordRepRing::CreateSlow(CordRep* child, size_t extra) {
277    CordRepRing* rep = nullptr;
278    Consume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
279      if (IsFlatOrExternal(child_arg)) {
280        rep = rep ? AppendLeaf(rep, child_arg, offset, len)
281                  : CreateFromLeaf(child_arg, offset, len, extra);
282      } else if (rep) {
283        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
284      } else if (offset == 0 && child_arg->length == len) {
285        rep = Mutable(child_arg->ring(), extra);
286      } else {
287        rep = SubRing(child_arg->ring(), offset, len, extra);
288      }
289    });
290    return Validate(rep, nullptr, __LINE__);
291  }
292  CordRepRing* CordRepRing::Create(CordRep* child, size_t extra) {
293    size_t length = child->length;
294    if (IsFlatOrExternal(child)) {
295      return CreateFromLeaf(child, 0, length, extra);
296    }
297    if (child->IsRing()) {
298      return Mutable(child->ring(), extra);
299    }
300    return CreateSlow(child, extra);
301  }
302  template <CordRepRing::AddMode mode>
303  CordRepRing* CordRepRing::AddRing(CordRepRing* rep, CordRepRing* ring,
304                                    size_t offset, size_t len) {
305    assert(offset < ring->length);
306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
310    rep = Mutable(rep, entries);
311    const pos_type delta_length =
312        (append ? rep->begin_pos_ + rep->length : rep->begin_pos_ - len) -
313        ring->entry_begin_pos(head.index) - head.offset;
314    Filler filler(rep, append ? rep->tail_ : rep->retreat(rep->head_, entries));
315    if (ring->refcount.IsOne()) {
316      ring->ForEach(head.index, tail.index, [&](index_type ix) {
317        filler.Add(ring->entry_child(ix), ring->entry_data_offset(ix),
318                   ring->entry_end_pos(ix) + delta_length);
319      });
320      if (head.index != ring->head_) UnrefEntries(ring, ring->head_, head.index);
321      if (tail.index != ring->tail_) UnrefEntries(ring, tail.index, ring->tail_);
322      CordRepRing::Delete(ring);
323    } else {
324      ring->ForEach(head.index, tail.index, [&](index_type ix) {
325        CordRep* child = ring->entry_child(ix);
326        filler.Add(child, ring->entry_data_offset(ix),
327                   ring->entry_end_pos(ix) + delta_length);
328        CordRep::Ref(child);
329      });
330      CordRepRing::Unref(ring);
331    }
332    if (head.offset) {
333      rep->AddDataOffset(filler.head(), head.offset);
334    }
335    if (tail.offset) {
336      rep->SubLength(rep->retreat(filler.pos()), tail.offset);
337    }
338    rep->length += len;
339    if (append) {
340      rep->tail_ = filler.pos();
341    } else {
342      rep->head_ = filler.head();
343      rep->begin_pos_ -= len;
344    }
345    return Validate(rep);
346  }
347  CordRepRing* CordRepRing::AppendSlow(CordRepRing* rep, CordRep* child) {
348    Consume(child, [&rep](CordRep* child_arg, size_t offset, size_t len) {
349      if (child_arg->IsRing()) {
350        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
351      } else {
352        rep = AppendLeaf(rep, child_arg, offset, len);
353      }
354    });
355    return rep;
356  }
357  CordRepRing* CordRepRing::AppendLeaf(CordRepRing* rep, CordRep* child,
358                                       size_t offset, size_t len) {
359    rep = Mutable(rep, 1);
360    index_type back = rep->tail_;
361    const pos_type begin_pos = rep->begin_pos_ + rep->length;
362    rep->tail_ = rep->advance(rep->tail_);
363    rep->length += len;
364    rep->entry_end_pos()[back] = begin_pos + len;
365    rep->entry_child()[back] = child;
366    rep->entry_data_offset()[back] = static_cast<offset_type>(offset);
367    return Validate(rep, nullptr, __LINE__);
368  }
369  CordRepRing* CordRepRing::Append(CordRepRing* rep, CordRep* child) {
370    size_t length = child->length;
371    if (IsFlatOrExternal(child)) {
372      return AppendLeaf(rep, child, 0, length);
373    }
374    if (child->IsRing()) {
375      return AddRing<AddMode::kAppend>(rep, child->ring(), 0, length);
376    }
377    return AppendSlow(rep, child);
378  }
379  CordRepRing* CordRepRing::PrependSlow(CordRepRing* rep, CordRep* child) {
380    ReverseConsume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
381      if (IsFlatOrExternal(child_arg)) {
382        rep = PrependLeaf(rep, child_arg, offset, len);
383      } else {
384        rep = AddRing<AddMode::kPrepend>(rep, child_arg->ring(), offset, len);
385      }
386    });
387    return Validate(rep);
388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
400    return Validate(rep);
401  }
402  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, CordRep* child) {
403    size_t length = child->length;
404    if (IsFlatOrExternal(child)) {
405      return PrependLeaf(rep, child, 0, length);
406    }
407    if (child->IsRing()) {
408      return AddRing<AddMode::kPrepend>(rep, child->ring(), 0, length);
409    }
410    return PrependSlow(rep, child);
411  }
412  CordRepRing* CordRepRing::Append(CordRepRing* rep, absl::string_view data,
413                                   size_t extra) {
414    if (rep->refcount.IsOne()) {
415      Span<char> avail = rep->GetAppendBuffer(data.length());
416      if (!avail.empty()) {
417        memcpy(avail.data(), data.data(), avail.length());
418        data.remove_prefix(avail.length());
419      }
420    }
421    if (data.empty()) return Validate(rep);
422    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
423    rep = Mutable(rep, flats);
424    Filler filler(rep, rep->tail_);
425    pos_type pos = rep->begin_pos_ + rep->length;
426    while (data.length() >= kMaxFlatLength) {
427      auto* flat = CreateFlat(data.data(), kMaxFlatLength);
428      filler.Add(flat, 0, pos += kMaxFlatLength);
429      data.remove_prefix(kMaxFlatLength);
430    }
431    if (data.length()) {
432      auto* flat = CreateFlat(data.data(), data.length(), extra);
433      filler.Add(flat, 0, pos += data.length());
434    }
435    rep->length = pos - rep->begin_pos_;
436    rep->tail_ = filler.pos();
437    return Validate(rep);
438  }
439  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, absl::string_view data,
440                                    size_t extra) {
441    if (rep->refcount.IsOne()) {
442      Span<char> avail = rep->GetPrependBuffer(data.length());
443      if (!avail.empty()) {
444        const char* tail = data.data() + data.length() - avail.length();
445        memcpy(avail.data(), tail, avail.length());
446        data.remove_suffix(avail.length());
447      }
448    }
449    if (data.empty()) return rep;
450    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
451    rep = Mutable(rep, flats);
452    pos_type pos = rep->begin_pos_;
453    Filler filler(rep, rep->retreat(rep->head_, static_cast<index_type>(flats)));
454    size_t first_size = data.size() - (flats - 1) * kMaxFlatLength;
455    CordRepFlat* flat = CordRepFlat::New(first_size + extra);
456    flat->length = first_size + extra;
457    memcpy(flat->Data() + extra, data.data(), first_size);
458    data.remove_prefix(first_size);
459    filler.Add(flat, extra, pos);
460    pos -= first_size;
461    while (!data.empty()) {
462      assert(data.size() >= kMaxFlatLength);
463      flat = CreateFlat(data.data(), kMaxFlatLength);
464      filler.Add(flat, 0, pos);
465      pos -= kMaxFlatLength;
466      data.remove_prefix(kMaxFlatLength);
467    }
468    rep->head_ = filler.head();
469    rep->length += rep->begin_pos_ - pos;
470    rep->begin_pos_ = pos;
471    return Validate(rep);
472  }
473  static constexpr index_type kBinarySearchThreshold = 32;
474  static constexpr index_type kBinarySearchEndCount = 8;
475  template <bool wrap>
476  CordRepRing::index_type CordRepRing::FindBinary(index_type head,
477                                                  index_type tail,
478                                                  size_t offset) const {
479    index_type count = tail + (wrap ? capacity_ : 0) - head;
480    do {
481      count = (count - 1) / 2;
482      assert(count < entries(head, tail_));
483      index_type mid = wrap ? advance(head, count) : head + count;
484      index_type after_mid = wrap ? advance(mid) : mid + 1;
485      bool larger = (offset >= entry_end_offset(mid));
486      head = larger ? after_mid : head;
487      tail = larger ? tail : mid;
488      assert(head != tail);
489    } while (ABSL_PREDICT_TRUE(count > kBinarySearchEndCount));
490    return head;
491  }
492  CordRepRing::Position CordRepRing::FindSlow(index_type head,
493                                              size_t offset) const {
494    index_type tail = tail_;
495    if (tail > head) {
496      index_type count = tail - head;
497      if (count > kBinarySearchThreshold) {
498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
508    while (offset >= Distance(begin_pos_, end_pos)) {
509      head = advance(head);
510      pos = end_pos;
511      end_pos = entry_end_pos(head);
512    }
513    return {head, offset - Distance(begin_pos_, pos)};
514  }
515  CordRepRing::Position CordRepRing::FindTailSlow(index_type head,
516                                                  size_t offset) const {
517    index_type tail = tail_;
518    const size_t tail_offset = offset - 1;
519    if (tail > head) {
520      index_type count = tail - head;
521      if (count > kBinarySearchThreshold) {
522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
532      head = advance(head);
533      end_offset = entry_end_offset(head);
534    }
535    return {advance(head), end_offset - offset};
536  }
537  char CordRepRing::GetCharacter(size_t offset) const {
538    assert(offset < length);
539    Position pos = Find(offset);
540    size_t data_offset = entry_data_offset(pos.index) + pos.offset;
541    return GetRepData(entry_child(pos.index))[data_offset];
542  }
543  CordRepRing* CordRepRing::SubRing(CordRepRing* rep, size_t offset,
544                                    size_t len, size_t extra) {
545    assert(offset <= rep->length);
546    assert(offset <= rep->length - len);
547    if (len == 0) {
548      CordRep::Unref(rep);
549      return nullptr;
550    }
551    Position head = rep->Find(offset);
552    Position tail = rep->FindTail(head.index, offset + len);
553    const size_t new_entries = rep->entries(head.index, tail.index);
554    if (rep->refcount.IsOne() && extra <= (rep->capacity() - new_entries)) {
555      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
556      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
557      rep->head_ = head.index;
558      rep->tail_ = tail.index;
559    } else {
560      rep = Copy(rep, head.index, tail.index, extra);
561      head.index = rep->head_;
562      tail.index = rep->tail_;
563    }
564    rep->length = len;
565    rep->begin_pos_ += offset;
566    if (head.offset) {
567      rep->AddDataOffset(head.index, head.offset);
568    }
569    if (tail.offset) {
570      rep->SubLength(rep->retreat(tail.index), tail.offset);
571    }
572    return Validate(rep);
573  }
574  CordRepRing* CordRepRing::RemovePrefix(CordRepRing* rep, size_t len,
575                                         size_t extra) {
576    assert(len <= rep->length);
577    if (len == rep->length) {
578      CordRep::Unref(rep);
579      return nullptr;
580    }
581    Position head = rep->Find(len);
582    if (rep->refcount.IsOne()) {
583      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
584      rep->head_ = head.index;
585    } else {
586      rep = Copy(rep, head.index, rep->tail_, extra);
587      head.index = rep->head_;
588    }
589    rep->length -= len;
590    rep->begin_pos_ += len;
591    if (head.offset) {
592      rep->AddDataOffset(head.index, head.offset);
593    }
594    return Validate(rep);
595  }
596  CordRepRing* CordRepRing::RemoveSuffix(CordRepRing* rep, size_t len,
597                                         size_t extra) {
598    assert(len <= rep->length);
599    if (len == rep->length) {
600      CordRep::Unref(rep);
601      return nullptr;
602    }
603    Position tail = rep->FindTail(rep->length - len);
604    if (rep->refcount.IsOne()) {
605      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
606      rep->tail_ = tail.index;
607    } else {
608      rep = Copy(rep, rep->head_, tail.index, extra);
609      tail.index = rep->tail_;
610    }
611    rep->length -= len;
612    if (tail.offset) {
613      rep->SubLength(rep->retreat(tail.index), tail.offset);
614    }
615    return Validate(rep);
616  }
617  }  
618  ABSL_NAMESPACE_END
619  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_inner_product_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</div>
                </div>
                <div class="column column_space"><pre><code>339      ip_t->Backward(this->blob_top_vec_, propagate_down, this->blob_bottom_vec_);
340      const Dtype* data = w->cpu_diff();
341      const Dtype* data_t = ip_t->blobs()[0]->cpu_diff();
342      const int WIDTH = layer->blobs()[0]->shape(1);
</pre></code></div>
                <div class="column column_space"><pre><code>238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    