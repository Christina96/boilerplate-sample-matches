
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.98502246630055%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-weightmatrix.cpp</h3>
            <pre><code>1  #include "weightmatrix.h"
2  #include <cassert> 
3  #include "intsimdmatrix.h"
4  #include "simddetect.h" 
5  #include "statistc.h"
6  #include "tprintf.h"    
7  namespace tesseract {
8  #if defined(ANDROID)
9  static inline TFloat log2(TFloat n) {
10    return log(n) / log(2.0);
11  }
12  #endif 
13  const int kAdamCorrectionIterations = 200000;
14  const TFloat kAdamEpsilon = 1e-8;
15  #ifdef FAST_FLOAT
16  static void DoubleToFloat(const GENERIC_2D_ARRAY<double> &src, GENERIC_2D_ARRAY<float> &dst) {
17    const auto dim1 = src.dim1();
18    const auto dim2 = src.dim2();
19    dst.ResizeNoInit(dim1, dim2);
20    for (int i = 0; i < dim1; ++i) {
21      const auto *src_i = src[i];
22      auto *dst_i = dst[i];
23      for (int j = 0; j < dim2; ++j) {
24        dst_i[j] = static_cast<float>(src_i[j]);
25      }
26    }
27  }
28  #endif
29  static void FloatToDouble(const GENERIC_2D_ARRAY<float> &src, GENERIC_2D_ARRAY<double> &dst) {
30    const auto dim1 = src.dim1();
31    const auto dim2 = src.dim2();
32    dst.ResizeNoInit(dim1, dim2);
33    for (int i = 0; i < dim1; ++i) {
34      const auto *src_i = src[i];
35      auto *dst_i = dst[i];
36      for (int j = 0; j < dim2; ++j) {
37        dst_i[j] = static_cast<double>(src_i[j]);
38      }
39    }
40  }
41  static bool DeSerialize(TFile *fp, GENERIC_2D_ARRAY<TFloat> &tfloat_array) {
42  #ifdef FAST_FLOAT
43    GENERIC_2D_ARRAY<double> double_array;
44    if (!double_array.DeSerialize(fp)) {
45      return false;
46    }
47    DoubleToFloat(double_array, tfloat_array);
48    return true;
49  #else
50    return tfloat_array.DeSerialize(fp);
51  #endif
52  }
53  static bool Serialize(TFile *fp, const GENERIC_2D_ARRAY<TFloat> &tfloat_array) {
54  #ifdef FAST_FLOAT
55    GENERIC_2D_ARRAY<double> double_array;
56    FloatToDouble(tfloat_array, double_array);
57    return double_array.Serialize(fp);
58  #else
59    return tfloat_array.Serialize(fp);
60  #endif
61  }
62  static inline void MatrixDotVectorInternal(const GENERIC_2D_ARRAY<TFloat> &w, bool add_bias_fwd,
63                                             bool skip_bias_back, const TFloat *u, TFloat *v) {
64    int num_results = w.dim1() - skip_bias_back;
65    int extent = w.dim2() - add_bias_fwd;
66    for (int i = 0; i < num_results; ++i) {
67      const TFloat *wi = w[i];
68      TFloat total = DotProduct(wi, u, extent);
69      if (add_bias_fwd) {
70        total += wi[extent]; 
71      }
72      v[i] = total;
73    }
74  }
75  void TransposedArray::Transpose(const GENERIC_2D_ARRAY<TFloat> &input) {
76    int width = input.dim1();
77    int num_features = input.dim2();
78    ResizeNoInit(num_features, width);
79    for (int t = 0; t < width; ++t) {
80      WriteStrided(t, input[t]);
81    }
82  }
83  TransposedArray::~TransposedArray() = default;
84  int WeightMatrix::InitWeightsFloat(int no, int ni, bool use_adam, float weight_range,
85                                     TRand *randomizer) {
86    int_mode_ = false;
87    wf_.Resize(no, ni, 0.0);
88    if (randomizer != nullptr) {
89      for (int i = 0; i < no; ++i) {
90        for (int j = 0; j < ni; ++j) {
91          wf_[i][j] = randomizer->SignedRand(weight_range);
92        }
93      }
94    }
95    use_adam_ = use_adam;
96    InitBackward();
97    return ni * no;
98  }
99  int WeightMatrix::RemapOutputs(const std::vector<int> &code_map) {
100    GENERIC_2D_ARRAY<TFloat> old_wf(wf_);
101    int old_no = wf_.dim1();
102    int new_no = code_map.size();
103    int ni = wf_.dim2();
104    std::vector<TFloat> means(ni, 0.0);
105    for (int c = 0; c < old_no; ++c) {
106      const TFloat *weights = wf_[c];
107      for (int i = 0; i < ni; ++i) {
108        means[i] += weights[i];
109      }
110    }
111    for (auto &mean : means) {
112      mean /= old_no;
113    }
114    wf_.Resize(new_no, ni, 0.0);
115    InitBackward();
116    for (int dest = 0; dest < new_no; ++dest) {
117      int src = code_map[dest];
118      const TFloat *src_data = src >= 0 ? old_wf[src] : means.data();
119      memcpy(wf_[dest], src_data, ni * sizeof(*src_data));
120    }
121    return ni * new_no;
122  }
123  void WeightMatrix::ConvertToInt() {
124    wi_.ResizeNoInit(wf_.dim1(), wf_.dim2());
125    scales_.reserve(wi_.dim1());
126    int dim2 = wi_.dim2();
127    for (int t = 0; t < wi_.dim1(); ++t) {
128      TFloat *f_line = wf_[t];
129      int8_t *i_line = wi_[t];
130      TFloat max_abs = 0;
131      for (int f = 0; f < dim2; ++f) {
132        TFloat abs_val = fabs(f_line[f]);
133        if (abs_val > max_abs) {
134          max_abs = abs_val;
135        }
136      }
137      TFloat scale = max_abs / INT8_MAX;
138      scales_.push_back(scale / INT8_MAX);
139      if (scale == 0.0) {
140        scale = 1.0;
141      }
142      for (int f = 0; f < dim2; ++f) {
143        i_line[f] = IntCastRounded(f_line[f] / scale);
144      }
145    }
146    wf_.Resize(1, 1, 0.0);
147    int_mode_ = true;
148    if (IntSimdMatrix::intSimdMatrix) {
149      int32_t rounded_num_out;
150      IntSimdMatrix::intSimdMatrix->Init(wi_, shaped_w_, rounded_num_out);
151      scales_.resize(rounded_num_out);
152    }
153  }
154  void WeightMatrix::InitBackward() {
155    int no = int_mode_ ? wi_.dim1() : wf_.dim1();
156    int ni = int_mode_ ? wi_.dim2() : wf_.dim2();
157    dw_.Resize(no, ni, 0.0);
158    updates_.Resize(no, ni, 0.0);
159    wf_t_.Transpose(wf_);
160    if (use_adam_) {
161      dw_sq_sum_.Resize(no, ni, 0.0);
162    }
163  }
164  const int kInt8Flag = 1;
165  const int kAdamFlag = 4;
166  const int kDoubleFlag = 128;
167  bool WeightMatrix::Serialize(bool training, TFile *fp) const {
168    uint8_t mode = (int_mode_ ? kInt8Flag : 0) | (use_adam_ ? kAdamFlag : 0) | kDoubleFlag;
169    if (!fp->Serialize(&mode)) {
170      return false;
171    }
172    if (int_mode_) {
173      if (!wi_.Serialize(fp)) {
174        return false;
175      }
176      uint32_t size = scales_.size();
177      if (!fp->Serialize(&size)) {
178        return false;
179      }
180      for (auto scale : scales_) {
181        double value = scale * INT8_MAX;
182        if (!fp->Serialize(&value)) {
183          return false;
184        }
185      }
186    } else {
187      if (!tesseract::Serialize(fp, wf_)) {
188        return false;
189      }
190      if (training) {
191        if (!tesseract::Serialize(fp, updates_)) {
192          return false;
193        }
194        if (use_adam_ && !tesseract::Serialize(fp, dw_sq_sum_)) {
195          return false;
196        }
197      }
198    }
199    return true;
200  }
201  bool WeightMatrix::DeSerialize(bool training, TFile *fp) {
202    uint8_t mode;
203    if (!fp->DeSerialize(&mode)) {
204      return false;
205    }
206    int_mode_ = (mode & kInt8Flag) != 0;
207    use_adam_ = (mode & kAdamFlag) != 0;
208    if ((mode & kDoubleFlag) == 0) {
209      return DeSerializeOld(training, fp);
210    }
211    if (int_mode_) {
212      if (!wi_.DeSerialize(fp)) {
213        return false;
214      }
215      uint32_t size;
216      if (!fp->DeSerialize(&size)) {
217        return false;
218      }
219  #ifdef FAST_FLOAT
220      scales_.reserve(size);
221      for (auto n = size; n > 0; n--) {
222        double val;
223        if (!fp->DeSerialize(&val)) {
224          return false;
225        }
226        scales_.push_back(val / INT8_MAX);
227      }
228  #else
229      scales_.resize(size);
230      if (!fp->DeSerialize(&scales_[0], size)) {
231        return false;
232      }
233      for (auto &scale : scales_) {
234        scale /= INT8_MAX;
235      }
236  #endif
237      if (IntSimdMatrix::intSimdMatrix) {
238        int32_t rounded_num_out;
239        IntSimdMatrix::intSimdMatrix->Init(wi_, shaped_w_, rounded_num_out);
240        scales_.resize(rounded_num_out);
241      }
242    } else {
243      if (!tesseract::DeSerialize(fp, wf_)) {
244        return false;
245      }
246      if (training) {
247        InitBackward();
248        if (!tesseract::DeSerialize(fp, updates_)) {
249          return false;
250        }
251        if (use_adam_) {
252          if (!tesseract::DeSerialize(fp, dw_sq_sum_)) {
253            return false;
254          }
255        }
256      }
257    }
258    return true;
259  }
260  bool WeightMatrix::DeSerializeOld(bool training, TFile *fp) {
261  #ifdef FAST_FLOAT
262    ASSERT_HOST(!"not implemented");
263    return false;
264  #else
265    if (int_mode_) {
266      if (!wi_.DeSerialize(fp)) {
267        return false;
268      }
269      std::vector<float> old_scales;
270      if (!fp->DeSerialize(old_scales)) {
271        return false;
272      }
273      scales_.reserve(old_scales.size());
274      for (float old_scale : old_scales) {
275        scales_.push_back(old_scale);
276      }
277    } else {
278      GENERIC_2D_ARRAY<float> float_array;
279      if (!float_array.DeSerialize(fp)) {
280        return false;
281      }
282      FloatToDouble(float_array, wf_);
283    }
284    if (training) {
285      InitBackward();
286      GENERIC_2D_ARRAY<float> float_array;
287      if (!float_array.DeSerialize(fp)) {
288        return false;
289      }
290      FloatToDouble(float_array, updates_);
291      if (!float_array.DeSerialize(fp)) {
292        return false;
293      }
294    }
295    return true;
296  #endif
297  }
298  void WeightMatrix::MatrixDotVector(const TFloat *u, TFloat *v) const {
299    assert(!int_mode_);
300    MatrixDotVectorInternal(wf_, true, false, u, v);
301  }
302  void WeightMatrix::MatrixDotVector(const int8_t *u, TFloat *v) const {
303    assert(int_mode_);
304    if (IntSimdMatrix::intSimdMatrix) {
305      IntSimdMatrix::intSimdMatrix->matrixDotVectorFunction(wi_.dim1(), wi_.dim2(), &shaped_w_[0],
306                                                            &scales_[0], u, v);
307    } else {
<span onclick='openModal()' class='match'>308      IntSimdMatrix::MatrixDotVector(wi_, scales_, u, v);
309    }
310  }
311  void WeightMatrix::MultiplyAccumulate(const TFloat *v, TFloat *inout) {
</span>312    assert(!int_mode_);
313    assert(wf_.dim1() == 1);
314    int n = wf_.dim2();
315    const TFloat *u = wf_[0];
316    for (int i = 0; i < n; ++i) {
317      inout[i] += u[i] * v[i];
318    }
319  }
320  void WeightMatrix::VectorDotMatrix(const TFloat *u, TFloat *v) const {
321    assert(!int_mode_);
322    MatrixDotVectorInternal(wf_t_, false, true, u, v);
323  }
324  void WeightMatrix::SumOuterTransposed(const TransposedArray &u, const TransposedArray &v,
325                                        bool in_parallel) {
326    assert(!int_mode_);
327    int num_outputs = dw_.dim1();
328    assert(u.dim1() == num_outputs);
329    assert(u.dim2() == v.dim2());
330    int num_inputs = dw_.dim2() - 1;
331    int num_samples = u.dim2();
332    assert(v.dim1() == num_inputs);
333  #ifdef _OPENMP
334  #  pragma omp parallel for num_threads(4) if (in_parallel)
335  #endif
336    for (int i = 0; i < num_outputs; ++i) {
337      TFloat *dwi = dw_[i];
338      const TFloat *ui = u[i];
339      for (int j = 0; j < num_inputs; ++j) {
340        dwi[j] = DotProduct(ui, v[j], num_samples);
341      }
342      TFloat total = 0;
343      for (int k = 0; k < num_samples; ++k) {
344        total += ui[k];
345      }
346      dwi[num_inputs] = total;
347    }
348  }
349  void WeightMatrix::Update(float learning_rate, float momentum, float adam_beta, int num_samples) {
350    assert(!int_mode_);
351    if (use_adam_ && momentum > 0.0f && num_samples > 0 && num_samples < kAdamCorrectionIterations) {
352      learning_rate *= sqrt(1.0f - pow(adam_beta, num_samples));
353      learning_rate /= 1.0f - pow(momentum, num_samples);
354    }
355    if (use_adam_ && num_samples > 0 && momentum > 0.0f) {
356      dw_sq_sum_.SumSquares(dw_, adam_beta);
357      dw_ *= learning_rate * (1.0f - momentum);
358      updates_ *= momentum;
359      updates_ += dw_;
360      wf_.AdamUpdate(updates_, dw_sq_sum_, learning_rate * kAdamEpsilon);
361    } else {
362      dw_ *= learning_rate;
363      updates_ += dw_;
364      if (momentum > 0.0f) {
365        wf_ += updates_;
366      }
367      if (momentum >= 0.0f) {
368        updates_ *= momentum;
369      }
370    }
371    wf_t_.Transpose(wf_);
372  }
373  void WeightMatrix::AddDeltas(const WeightMatrix &other) {
374    assert(dw_.dim1() == other.dw_.dim1());
375    assert(dw_.dim2() == other.dw_.dim2());
376    dw_ += other.dw_;
377  }
378  void WeightMatrix::CountAlternators(const WeightMatrix &other, TFloat *same,
379                                      TFloat *changed) const {
380    int num_outputs = updates_.dim1();
381    int num_inputs = updates_.dim2();
382    assert(num_outputs == other.updates_.dim1());
383    assert(num_inputs == other.updates_.dim2());
384    for (int i = 0; i < num_outputs; ++i) {
385      const TFloat *this_i = updates_[i];
386      const TFloat *other_i = other.updates_[i];
387      for (int j = 0; j < num_inputs; ++j) {
388        TFloat product = this_i[j] * other_i[j];
389        if (product < 0.0) {
390          *changed -= product;
391        } else {
392          *same += product;
393        }
394      }
395    }
396  }
397  const int kHistogramBuckets = 16;
398  static void HistogramWeight(TFloat weight, STATS *histogram) {
399    int bucket = kHistogramBuckets - 1;
400    if (weight != 0.0) {
401      TFloat logval = -log2(fabs(weight));
402      bucket = ClipToRange(IntCastRounded(logval), 0, kHistogramBuckets - 1);
403    }
404    histogram->add(bucket, 1);
405  }
406  void WeightMatrix::Debug2D(const char *msg) {
407    STATS histogram(0, kHistogramBuckets - 1);
408    if (int_mode_) {
409      for (int i = 0; i < wi_.dim1(); ++i) {
410        for (int j = 0; j < wi_.dim2(); ++j) {
411          HistogramWeight(wi_[i][j] * scales_[i], &histogram);
412        }
413      }
414    } else {
415      for (int i = 0; i < wf_.dim1(); ++i) {
416        for (int j = 0; j < wf_.dim2(); ++j) {
417          HistogramWeight(wf_[i][j], &histogram);
418        }
419      }
420    }
421    tprintf("%s\n", msg);
422    histogram.print();
423  }
424  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-soap.cpp</h3>
            <pre><code>1  void TSoapTb::Append(const PSoapTb& SoapTb){
2    for (int RowN=0; RowN<SoapTb->GetRows(); RowN++){
3      AddRow();
4      for (int ColN=0; ColN<SoapTb->GetCols(); ColN++){
5        TStr ColNm, ColVal;
6        if (SoapTb->IsGetColNmVal(RowN, ColN, ColNm, ColVal)){
7          AddVal(ColNm, ColVal);
8        }
9      }
10    }
11  }
12  void TSoapTb::GetValV(const int& ColN, TStrV& ValStrV) const {
13    ValStrV.Clr();
14    int Rows=GetRows();
15    for (int RowN=0; RowN<Rows; RowN++){
16      ValStrV.Add(GetVal(RowN, ColN));
17    }
18  }
19  void TSoapTb::GetValPrV(const int& ColN1, const int& ColN2, TStrPrV& ValStrPrV) const {
20    ValStrPrV.Clr();
21    int Rows=GetRows();
22    for (int RowN=0; RowN<Rows; RowN++){
23      ValStrPrV.Add(TStrPr(GetVal(RowN, ColN1), GetVal(RowN, ColN2)));
24    }
25  }
26  int TSoapTb::GetRowN(const TStr& WhereColNm, const TStr& WhereValStr) const {
27    int Rows=GetRows();
28    for (int RowN=0; RowN<Rows; RowN++){
29      int RowVals=GetRowVals(RowN);
30      TStr ColNm; TStr ValStr;
31      for (int ValN=0; ValN<RowVals; ValN++){
32        GetColNmVal(RowN, ValN, ColNm, ValStr);
33        if ((ColNm==WhereColNm)&&(ValStr==WhereValStr)){
34          return RowN;
35        }
36      }
37    }
38    return -1;
39  }
40  void TSoapTb::SelectValStrV(const TStr& SelColNm, TStrV& SelValStrV,
41   const TStr& WhereColNm, const TStr& WhereValStr) const {
42    SelValStrV.Clr();
43    int Rows=GetRows();
44    for (int RowN=0; RowN<Rows; RowN++){
45      int RowVals=GetRowVals(RowN);
46      TStr ColNm; TStr ValStr;
47      TStr CurSelValStr; TStr CurWhereValStr;
48      for (int ValN=0; ValN<RowVals; ValN++){
49        GetColNmVal(RowN, ValN, ColNm, ValStr);
50        if (ColNm==SelColNm){CurSelValStr=ValStr;}
51        if (ColNm==WhereColNm){CurWhereValStr=ValStr;}
52      }
53      if (CurWhereValStr==WhereValStr){
54        SelValStrV.Add(CurSelValStr);
55      }
56    }
57  }
58  void TSoapTb::SelectValStrV(const TStr& SelColNm, TStrV& SelValStrV,
59   const TStr& WhereColNm1, const TStr& WhereValStr1,
60   const TStr& WhereColNm2, const TStr& WhereValStr2) const {
61    SelValStrV.Clr();
62    int Rows=GetRows();
63    for (int RowN=0; RowN<Rows; RowN++){
64      int RowVals=GetRowVals(RowN);
65      TStr ColNm; TStr ValStr;
66      TStr CurSelValStr; TStr CurWhereValStr1; TStr CurWhereValStr2;
67      for (int ValN=0; ValN<RowVals; ValN++){
68        GetColNmVal(RowN, ValN, ColNm, ValStr);
69        if (ColNm==SelColNm){
70          CurSelValStr=ValStr;}
71        if (ColNm==WhereColNm1){
72          CurWhereValStr1=ValStr;}
73        if (ColNm==WhereColNm2){
74          CurWhereValStr2=ValStr;}
75      }
76      if ((CurWhereValStr1==WhereValStr1)&&(CurWhereValStr2==WhereValStr2)){
77        SelValStrV.Add(CurSelValStr);
78      }
79    }
80  }
81  void TSoapTb::SelectValStr(const TStr& SelColNm, TStr& SelValStr,
82   const TStr& WhereColNm1, const TStr& WhereValStr1,
83   const TStr& WhereColNm2, const TStr& WhereValStr2) const {
84    TStrV SelValStrV;
85    SelectValStrV(SelColNm, SelValStrV, WhereColNm1, WhereValStr1, WhereColNm2, WhereValStr2);
86    if (SelValStrV.Empty()){SelValStr="";}
87    else {SelValStr=SelValStrV[0];}
88  }
89  void TSoapTb::SelectValStr(const TStr& SelColNm, TStr& SelValStr,
90   const TStr& WhereColNm, const TStr& WhereValStr) const {
91    TStrV SelValStrV;
92    SelectValStrV(SelColNm, SelValStrV, WhereColNm, WhereValStr);
93    if (SelValStrV.Empty()){SelValStr="";}
94    else {SelValStr=SelValStrV[0];}
95  }
96  void TSoapTb::Dump(const TStr& FNm) const {
97    TStr D;
98    for (int ColN=0; ColN<GetCols(); ColN++){
99      D+="C"+TInt::GetStr(ColN)+":["+GetColNm(ColN)+"]";}
100    D+="\n";
101    for (int RowN=0; RowN<GetRows(); RowN++){
102      D+="R"+TInt::GetStr(RowN)+":";
103      int Vals=GetRowVals(RowN); TStr ColNm; TStr ValStr;
104      for (int ValN=0; ValN<Vals; ValN++){
105        GetColNmVal(RowN, ValN, ColNm, ValStr);
106        D+=" ["+ColNm+":"+ValStr+"]";
107      }
108      D+="\n";
109    }
110    TFOut F(FNm); F.PutStr(D);
111  }
112  TSoapEnv::TSoapEnv(const TStrPrV& FldNmValPrV):
113    FldNmToValH(), FldNmToValVH(), FldNmToSoapTbH(){
114    int Flds=FldNmValPrV.Len(); int FldN=0;
115    while (FldN<Flds){
116      if (TSoap::IsVecFld(FldN, FldNmValPrV)){
117        TStr FldNm; TStrV FldValV;
118        FldN=TSoap::GetVecFld(FldN, FldNm, FldValV, FldNmValPrV);
119        FldNmToValVH.AddDat(FldNm, FldValV);
120      } else
121      if (TSoap::IsTbFld(FldN, FldNmValPrV)){
122        TStr FldNm; PSoapTb SoapTb;
123        FldN=TSoap::GetTbFld(FldN, FldNm, SoapTb, FldNmValPrV);
124        FldNmToSoapTbH.AddDat(FldNm, SoapTb);
125      } else {
126        TStr FldNm=FldNmValPrV[FldN].Val1;
127        TStr FldVal=FldNmValPrV[FldN].Val2;
128        FldNmToValH.AddDat(FldNm, FldVal);
129        FldN++;
130      }
131    }
132  }
133  void TSoapEnv::CopySoapTbH(const TSoapEnv& SoapEnv){
134    FldNmToSoapTbH.Clr();
135    int KeyId=SoapEnv.FldNmToSoapTbH.FFirstKeyId();
136    while (SoapEnv.FldNmToSoapTbH.FNextKeyId(KeyId)){
137      TStr TbNm; PSoapTb SrcSoapTb;
138      SoapEnv.FldNmToSoapTbH.GetKeyDat(KeyId, TbNm, SrcSoapTb);
139      PSoapTb DestSoapTb=PSoapTb(new TSoapTb(*SrcSoapTb));
140      FldNmToSoapTbH.AddDat(TbNm, DestSoapTb);
141    }
142  }
143  void TSoapEnv::MergeSoapEnv(const PSoapEnv& SoapEnv, const bool& AppendSoapTbP){
144    {int KeyId=SoapEnv->FldNmToValH.FFirstKeyId();
145    while (SoapEnv->FldNmToValH.FNextKeyId(KeyId)){
146      TStr FldNm=SoapEnv->FldNmToValH.GetKey(KeyId);
147      TStr FldVal=SoapEnv->FldNmToValH[KeyId];
148      FldNmToValH.AddDat(FldNm, FldVal);
149    }}
150    {int KeyId=SoapEnv->FldNmToValVH.FFirstKeyId();
151    while (SoapEnv->FldNmToValVH.FNextKeyId(KeyId)){
152      TStr FldNm=SoapEnv->FldNmToValVH.GetKey(KeyId);
153      TStrV& FldValV=SoapEnv->FldNmToValVH[KeyId];
154      FldNmToValVH.AddDat(FldNm, FldValV);
155    }}
156    {int KeyId=SoapEnv->FldNmToSoapTbH.FFirstKeyId();
157    while (SoapEnv->FldNmToSoapTbH.FNextKeyId(KeyId)){
158      TStr FldNm=SoapEnv->FldNmToSoapTbH.GetKey(KeyId);
159      PSoapTb SoapTb=SoapEnv->FldNmToSoapTbH[KeyId];
160      if (AppendSoapTbP&&FldNmToSoapTbH.IsKey(FldNm)){
161        FldNmToSoapTbH.GetDat(FldNm)->Append(SoapTb);
162      } else {
163        FldNmToSoapTbH.AddDat(FldNm, SoapTb);
164      }
165    }}
166  }
167  void TSoapEnv::AddFlattened(TStrPrV& FldNmValPrV) const {
168    for (int FldN=0; FldN<FldNmToValH.Len(); FldN++){
169      TStr FldNm=FldNmToValH.GetKey(FldN);
170      TStr FldVal=FldNmToValH[FldN];
171      FldNmValPrV.Add(TStrPr(FldNm, FldVal));
172    }
173    for (int FldN=0; FldN<FldNmToValVH.Len(); FldN++){
174      TStr FldNm=FldNmToValVH.GetKey(FldN);
175      const TStrV& FldValV=FldNmToValVH[FldN];
176      TSoap::AddVecFld(FldNm, FldValV, FldNmValPrV);
177    }
178    for (int FldN=0; FldN<FldNmToSoapTbH.Len(); FldN++){
179      TStr FldNm=FldNmToSoapTbH.GetKey(FldN);
180      PSoapTb SoapTb=FldNmToSoapTbH[FldN];
181      TSoap::AddTbFld(FldNm, SoapTb, FldNmValPrV);
182    }
183  }
184  const TStr TSoap::ResponseStr="Response";
185  const TStr TSoap::VersionMismatchCodeNm="env:VersionMismatch";
186  const TStr TSoap::MustUnderstandCodeNm="env:MustUnderstand";
187  const TStr TSoap::DataEncodingUnknownCodeNm="env:DataEncodingUnknown";
188  const TStr TSoap::SenderCodeNm="env:Sender";
189  const TStr TSoap::ReceiverCodeNm="env:Receiver";
190  void TSoap::GetFromXmlStr(
191   const TStr& XmlStr, const bool& RespP,
192   TBool& Ok, bool& FaultP,
193   TStr& FuncNm, TStrPrV& FldNmValPrV,
194   TStr& FaultCodeNm, TStr& FaultReasonStr){
195    Ok=false; FaultP=true;
196    FuncNm=""; FldNmValPrV.Clr();
197    FaultCodeNm=""; FaultReasonStr="";
198    PSIn SIn=TStrIn::New(XmlStr);
199    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
200    if (XmlDoc->IsOk()){
201      PXmlTok EnvTok=XmlDoc->GetTok();
202      if (EnvTok->IsTag("env:Envelope")){
203        PXmlTok BodyTok;
204        if (EnvTok->IsSubTag("env:Body", BodyTok)){
205          PXmlTok FaultTok;
206          if (RespP&&(BodyTok->IsSubTag("env:Fault", FaultTok))){
207            FaultP=true;
208            FaultCodeNm=FaultTok->GetTagTokStr("env:Code|env:Value");
209            FaultReasonStr=FaultTok->GetTagTokStr("env:Reason|env:Text");
210            Ok=(!FaultCodeNm.Empty());
211          } else {
212            PXmlTok FuncTok;
213            for (int TokN=0; TokN<BodyTok->GetSubToks(); TokN++){
214              PXmlTok Tok=BodyTok->GetSubTok(TokN);
215              if (Tok->IsTag()){
216                TStr TagNm=Tok->GetTagNm();
217                if (RespP){
218                  if (TagNm.IsSuffix(TSoap::ResponseStr)){
219                    Ok=true; FaultP=false;
220                    FuncTok=Tok;
221                    FuncNm=TagNm.GetSubStr(0,
222                     TagNm.Len()-1-TStr(TSoap::ResponseStr).Len());
223                    break;
224                  }
225                } else {
226                  Ok=true; FaultP=false;
227                  FuncTok=Tok;
228                  FuncNm=TagNm;
229                }
230              }
231            }
232            if (!FuncTok.Empty()){
233              for (int TokN=0; TokN<FuncTok->GetSubToks(); TokN++){
234                PXmlTok FldTok=FuncTok->GetSubTok(TokN);
235                if (FldTok->IsTag()){
236                  TStr FldNm=FldTok->GetTagNm();
237                  TStr FldVal=FldTok->GetTagTokStr("");
238                  FldNmValPrV.Add(TStrPr(FldNm, FldVal));
239                }
240              }
241            }
242          }
243        }
244      }
245    }
246  }
247  TStr TSoap::GetUrlPathStr(
248   const TStr& FuncNm, const bool& RespP,
249   const TStrPrV& FldNmValPrV){
250    TChA ChA;
251    TStr UrlFuncNm=TUrl::GetUrlSearchStr(FuncNm);
252    ChA+=UrlFuncNm; if (RespP){ChA+="Response";} ChA+="?";
253    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
254      if (FldN>0){ChA+='&';}
255      TStr UrlFldNm=TUrl::GetUrlSearchStr(FldNmValPrV[FldN].Val1);
256      TStr UrlFldVal=TUrl::GetUrlSearchStr(FldNmValPrV[FldN].Val2);
257      ChA+=UrlFldNm; ChA+="="; ChA+=UrlFldVal;
258    }
259    return ChA;
260  }
261  TStr TSoap::GetUrlPathStr(
262   const TStr& FuncNm, const bool& RespP,
263   const TStr& FldNm1, const TStr& FldVal1,
264   const TStr& FldNm2, const TStr& FldVal2){
265    TStrPrV FldNmValPrV(2, 0);
266    if (!FldNm1.Empty()){
267      FldNmValPrV.Add(TStrPr(FldNm1, FldVal1));}
268    if (!FldNm2.Empty()){
269      FldNmValPrV.Add(TStrPr(FldNm2, FldVal2));}
270    return GetUrlPathStr(FuncNm, RespP, FldNmValPrV);
271  }
272  TStr TSoap::GetXmlStr(
273   const TStr& FuncNm, const bool& RespP,
274   const TStrPrV& FldNmValPrV){
275    TStr FuncXmlNm=FuncNm.GetTrunc(); 
276    TChA ChA;
277    ChA+="<?xml version='1.0' ?>\n";
278    ChA+="<env:Envelope xmlns:env=\"http:&bsol;&bsol;www.w3.org/2003/05/soap-envelope\">\n";
279    ChA+="  <env:Body>\n";
280    ChA+="    <"; ChA+=FuncXmlNm; if (RespP){ChA+="Response";} ChA+=">\n";
281    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
282      TStr FldNm=FldNmValPrV[FldN].Val1.GetTrunc(); 
283      TStr FldVal=TXmlLx::GetXmlStrFromPlainStr(FldNmValPrV[FldN].Val2);
284      ChA+="      <"; ChA+=FldNm; ChA+=">";
285      ChA+=FldVal;
286      ChA+="</"; ChA+=FldNm;ChA+=">\n";
287    }
288    ChA+="    </"; ChA+=FuncXmlNm; if (RespP){ChA+="Response";} ChA+=">\n";
289    ChA+="  </env:Body>\n";
290    ChA+="</env:Envelope>\n";
291    return ChA;
292  }
293  TStr TSoap::GetXmlStr(
294   const TStr& FuncNm, const bool& RespP){
295    TStrPrV FldNmValPrV;
296    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
297  }
298  TStr TSoap::GetXmlStr(
299   const TStr& FuncNm, const bool& RespP,
300   const TStr& FldNm, const TStr& FldVal){
301    TStrPrV FldNmValPrV;
302    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
303    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
304  }
305  TStr TSoap::GetXmlStr(
306   const TStr& FuncNm, const bool& RespP,
307   const TStr& FldNm1, const TStr& FldVal1,
308   const TStr& FldNm2, const TStr& FldVal2){
309    TStrPrV FldNmValPrV;
310    FldNmValPrV.Add(TStrPr(FldNm1, FldVal1));
311    FldNmValPrV.Add(TStrPr(FldNm2, FldVal2));
312    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
313  }
314  TStr TSoap::GetFaultXmlStr(const TStr& CodeNm, const TStr& ReasonStr){
315    TStr ReasonXmlStr=TXmlLx::GetXmlStrFromPlainStr(ReasonStr);
316    TChA ChA;
317    ChA+="<?xml version='1.0' ?>\n";
318    ChA+="<env:Envelope\n";
319    ChA+=" xmlns:env=\"http:&bsol;&bsol;www.w3.org/2003/05/soap-envelope\"\n";
320    ChA+=" xmlns:rpc='http:&bsol;&bsol;www.w3.org/2003/05/soap-rpc'>\n";
321    ChA+="  <env:Body>\n";
322    ChA+="    <env:Fault>\n";
323    ChA+="      <env:Code>\n";
324    ChA+="        <env:Value>"; ChA+=CodeNm; ChA+="</env:Value>\n";
325    ChA+="      </env:Code>\n";
326    ChA+="      <env:Reason>\n";
327    ChA+="        <env:Text>"; ChA+=ReasonXmlStr; ChA+="</env:Text>\n";
328    ChA+="      </env:Reason>\n";
329    ChA+="    </env:Fault>\n";
330    ChA+="  </env:Body>\n";
331    ChA+="</env:Envelope>";
332    return ChA;
333  }
334  bool TSoap::IsVecFld(const int& FldN, const TStrPrV& FldNmValPrV){
335    return FldNmValPrV[FldN].Val1.IsSuffix("_VecBeg");
336  }
337  bool TSoap::IsVecFld(const TStr& FldNm, const TStrPrV& FldNmValPrV){
338    TStr VecBeg_FldNm=FldNm+"_VecBeg";
339    int Flds=FldNmValPrV.Len();
340    for (int FldN=0; FldN<Flds; FldN++){
341      if (FldNmValPrV[FldN].Val1==VecBeg_FldNm){return true;}
342    }
343    return false;
344  }
345  void TSoap::AddVecFld(const TStr& FldNm, const TStrV& FldValV, TStrPrV& FldNmValPrV){
346    FldNmValPrV.Add(TStrPr(FldNm+"_VecBeg", TInt::GetStr(FldValV.Len())));
347    for (int ValN=0; ValN<FldValV.Len(); ValN++){
348      FldNmValPrV.Add(TStrPr(FldNm+"_"+TInt::GetStr(ValN), FldValV[ValN]));
349    }
350    FldNmValPrV.Add(TStrPr(FldNm+"_VecEnd", TInt::GetStr(FldValV.Len())));
351  }
352  void TSoap::GetVecFld(const TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
353    TStr VecBeg_FldNm=FldNm+"_VecBeg";
354    int Flds=FldNmValPrV.Len(); int FldN=0;
355    while (FldN<Flds){
356      if (FldNmValPrV[FldN].Val1==VecBeg_FldNm){break;}
357      FldN++;
358    }
359    if (FldN==Flds){
360      FldValV.Clr();
361    } else {
<span onclick='openModal()' class='match'>362      TStr _FldNm; GetVecFld(FldN, _FldNm, FldValV, FldNmValPrV);
363    }
364  }
365  int TSoap::GetVecFld(
366   const int& _FldN, TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
</span>367    IAssert(IsVecFld(_FldN, FldNmValPrV));
368    int Flds=FldNmValPrV.Len();
369    int FldN=_FldN;
370    FldNm=FldNmValPrV[FldN].Val1;
371    FldNm=FldNm.GetSubStr(0, FldNm.Len()-TStr("_VecBeg").Len()-1);
372    TStr VecEnd_FldNm=FldNm+"_VecEnd";
373    FldValV.Clr(); FldN++;
374    while (FldN<Flds){
375      if (FldNmValPrV[FldN].Val1==VecEnd_FldNm){FldN++; break;}
376      else {FldValV.Add(FldNmValPrV[FldN].Val2);}
377      FldN++;
378    }
379    return FldN;
380  }
381  bool TSoap::IsTbFld(const int& FldN, const TStrPrV& FldNmValPrV){
382    return FldNmValPrV[FldN].Val1.IsSuffix("_TbBeg");
383  }
384  bool TSoap::IsTbFld(const TStr& FldNm, const TStrPrV& FldNmValPrV){
385    TStr BTbFldNm=FldNm+"_TbBeg";
386    int Flds=FldNmValPrV.Len();
387    for (int FldN=0; FldN<Flds; FldN++){
388      if (FldNmValPrV[FldN].Val1==BTbFldNm){return true;}
389    }
390    return false;
391  }
392  void TSoap::AddTbFld(const TStr& TbFldNm, const PSoapTb& SoapTb, TStrPrV& FldNmValPrV){
393    int Rows=SoapTb->GetRows();
394    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbBeg", TInt::GetStr(SoapTb->GetRows())));
395    for (int RowN=0; RowN<Rows; RowN++){
396      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowBeg_"+TInt::GetStr(RowN), TStr()));
397      int RowVals=SoapTb->GetRowVals(RowN); TStr ColNm; TStr ValStr;
398      for (int RowValN=0; RowValN<RowVals; RowValN++){
399        SoapTb->GetColNmVal(RowN, RowValN, ColNm, ValStr);
400        FldNmValPrV.Add(TStrPr(TbFldNm+"_"+ColNm+"_"+TInt::GetStr(RowN), ValStr));
401      }
402      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowEnd_"+TInt::GetStr(RowN), TStr()));
403    }
404    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbEnd", TInt::GetStr(SoapTb->GetRows())));
405  }
406  void TSoap::GetTbFld(const TStr& TbFldNm, PSoapTb& SoapTb, const TStrPrV& FldNmValPrV){
407    TStr TbBeg_FldNm=TbFldNm+"_TbBeg";
408    int Flds=FldNmValPrV.Len(); int FldN=0;
409    while (FldN<Flds){
410      if (FldNmValPrV[FldN].Val1==TbBeg_FldNm){break;}
411      FldN++;
412    }
413    if (FldN==Flds){
414      SoapTb=TSoapTb::New();
415    } else {
416      TStr _FldNm; GetTbFld(FldN, _FldNm, SoapTb, FldNmValPrV);
417    }
418  }
419  int TSoap::GetTbFld(
420   const int& _FldN, TStr& TbFldNm, PSoapTb& SoapTb, const TStrPrV& FldNmValPrV){
421    IAssert(IsTbFld(_FldN, FldNmValPrV));
422    int Flds=FldNmValPrV.Len();
423    int FldN=_FldN;
424    TbFldNm=FldNmValPrV[FldN].Val1;
425    TbFldNm=TbFldNm.GetSubStr(0, TbFldNm.Len()-TStr("_TbBeg").Len()-1);
426    TStr TbEnd_FldNm=TbFldNm+"_TbEnd";
427    TStr TbRowBeg_FldNm=TbFldNm+"_TbRowBeg_"; 
428    TStr TbRowEnd_FldNm=TbFldNm+"_TbRowEnd_";
429    SoapTb=TSoapTb::New(); FldN++;
430    while (FldN<Flds){
431      TStr FldNm=FldNmValPrV[FldN].Val1;
432      TStr FldVal=FldNmValPrV[FldN].Val2;
433      if (FldNm==TbEnd_FldNm){FldN++; break;}
434      else if (FldNm.IsStrIn(TbRowBeg_FldNm)){SoapTb->AddRow();}
435      else if (FldNm.IsStrIn(TbRowEnd_FldNm)){}
436      else {
437        TStr FNmPrefix=TbFldNm+"_";
438        TStr FNmSuffix="_"+TInt::GetStr(SoapTb->GetRows()-1);
439        if (FldNm.IsPrefix(FNmPrefix)&&FldNm.IsSuffix(FNmSuffix)){
440          FldNm=FldNm.GetSubStr(FNmPrefix.Len(), FldNm.Len()-1-FNmSuffix.Len());
441        } else {WarnNotify("Invalid Field-Name Prefix/Suffix in Soap Table "+TbFldNm);}
442        SoapTb->AddVal(FldNm, FldVal);
443      }
444      FldN++;
445    }
446    return FldN;
447  }
448  PSoapRq TSoapRq::New(const TStr& FuncNm,
449   const TStr& FldNm, const TStr& FldVal){
450    PSoapRq SoapRq=TSoapRq::New(FuncNm);
451    SoapRq->AddFldNmVal(FldNm, FldVal);
452    return SoapRq;
453  }
454  PSoapRq TSoapRq::New(const TStr& FuncNm,
455   const TStr& FldNm1, const TStr& FldVal1,
456   const TStr& FldNm2, const TStr& FldVal2){
457    PSoapRq SoapRq=TSoapRq::New(FuncNm);
458    SoapRq->AddFldNmVal(FldNm1, FldVal1);
459    SoapRq->AddFldNmVal(FldNm2, FldVal2);
460    return SoapRq;
461  }
462  PSoapRq TSoapRq::New(const TStr& FuncNm,
463   const TStr& FldNm1, const TStr& FldVal1,
464   const TStr& FldNm2, const TStr& FldVal2,
465   const TStr& FldNm3, const TStr& FldVal3){
466    PSoapRq SoapRq=TSoapRq::New(FuncNm);
467    SoapRq->AddFldNmVal(FldNm1, FldVal1);
468    SoapRq->AddFldNmVal(FldNm2, FldVal2);
469    SoapRq->AddFldNmVal(FldNm3, FldVal3);
470    return SoapRq;
471  }
472  PSoapRq TSoapRq::New(const TStr& FuncNm,
473   const TStr& FldNm1, const TStr& FldVal1,
474   const TStr& FldNm2, const TStr& FldVal2,
475   const TStr& FldNm3, const TStr& FldVal3,
476   const TStr& FldNm4, const TStr& FldVal4){
477    PSoapRq SoapRq=TSoapRq::New(FuncNm);
478    SoapRq->AddFldNmVal(FldNm1, FldVal1);
479    SoapRq->AddFldNmVal(FldNm2, FldVal2);
480    SoapRq->AddFldNmVal(FldNm3, FldVal3);
481    SoapRq->AddFldNmVal(FldNm4, FldVal4);
482    return SoapRq;
483  }
484  PSoapRq TSoapRq::New(const TStr& FuncNm,
485   const TStr& FldNm1, const TStr& FldVal1,
486   const TStr& FldNm2, const TStr& FldVal2,
487   const TStr& FldNm3, const TStr& FldVal3,
488   const TStr& FldNm4, const TStr& FldVal4,
489   const TStr& FldNm5, const TStr& FldVal5){
490    PSoapRq SoapRq=TSoapRq::New(FuncNm);
491    SoapRq->AddFldNmVal(FldNm1, FldVal1);
492    SoapRq->AddFldNmVal(FldNm2, FldVal2);
493    SoapRq->AddFldNmVal(FldNm3, FldVal3);
494    SoapRq->AddFldNmVal(FldNm4, FldVal4);
495    SoapRq->AddFldNmVal(FldNm5, FldVal5);
496    return SoapRq;
497  }
498  void TSoapRq::AddFldNmVal(const TStr& FldNm, const TStr& FldVal){
499    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
500      if (FldNmValPrV[FldN].Val1==FldNm){
501        FldNmValPrV[FldN].Val2=FldVal; return;
502      }
503    }
504    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
505  }
506  bool TSoapRq::IsFldNm(const TStr& FldNm) const {
507    int Flds=GetFlds();
508    TStr _FldNm; TStr FldVal;
509    for (int FldN=0; FldN<Flds; FldN++){
510      GetFldNmVal(FldN, _FldNm, FldVal);
511      if (FldNm==_FldNm){return true;}
512    }
513    return false;
514  }
515  bool TSoapRq::IsFldNmVal(const TStr& FldNm, const TStr& FldVal) const {
516    int Flds=GetFlds();
517    TStr _FldNm; TStr _FldVal;
518    for (int FldN=0; FldN<Flds; FldN++){
519      GetFldNmVal(FldN, _FldNm, _FldVal);
520      if ((FldNm==_FldNm)&&(FldVal==_FldVal)){return true;}
521    }
522    return false;
523  }
524  TStr TSoapRq::GetFldVal(const TStr& FldNm) const {
525    int Flds=GetFlds();
526    TStr _FldNm; TStr FldVal;
527    for (int FldN=0; FldN<Flds; FldN++){
528      GetFldNmVal(FldN, _FldNm, FldVal);
529      if (FldNm==_FldNm){return FldVal;}
530    }
531    return "";
532  }
533  TSoapRq::TSoapRq(const PHttpRq& HttpRq):
534    Ok(false){
535    if (HttpRq->IsOk()){
536      if (HttpRq->IsContType(THttp::AppSoapXmlFldVal)){
537        TStr XmlStr=HttpRq->GetBodyAsStr();
538        bool _FaultP; TStr _FaultCodeNm; TStr _FaultReasonStr;
539        TSoap::GetFromXmlStr(
540         XmlStr, false, Ok, _FaultP,
541         FuncNm, FldNmValPrV, _FaultCodeNm, _FaultReasonStr);
542      } else {
543        PUrl Url=HttpRq->GetUrl();
544        if (Url->GetPathSegs()>0){
545          FuncNm=Url->GetPathSeg(Url->GetPathSegs()-1);}
546        if (FuncNm.Empty()){
547          FuncNm="Info";
548        } else {
549          PUrlEnv UrlEnv=HttpRq->GetUrlEnv();
550          for (int KeyN=0; KeyN<UrlEnv->GetKeys(); KeyN++){
551            TStr FldNm=UrlEnv->GetKeyNm(KeyN);
552            TStr FldVal=UrlEnv->GetVal(FldNm);
553            FldNmValPrV.Add(TStrPr(FldNm, FldVal));
554          }
555        }
556        Ok=true;
557      }
558    }
559  }
560  TSoapResp::TSoapResp(const PHttpResp& HttpResp):
561    Ok(false){
562    if (HttpResp->IsOk()){
563      if (HttpResp->IsContType(THttp::AppSoapXmlFldVal)){
564        TStr XmlStr=HttpResp->GetBodyAsStr();
565        TSoap::GetFromXmlStr(
566         XmlStr, true, Ok, FaultP,
567         FuncNm, FldNmValPrV, FaultCodeNm, FaultReasonStr);
568      }
569    }
570  }
571  void TSoapResp::AddFldNmVal(const TStr& FldNm, const TStr& FldVal){
572    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
573      if (FldNmValPrV[FldN].Val1==FldNm){
574        FldNmValPrV[FldN].Val2=FldVal; return;
575      }
576    }
577    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
578  }
579  void TSoapResp::GetFldNmValKdV(TStrKdV& FldNmValKdV) const {
580    FldNmValKdV.Clr();
581    for (int FldN=0; FldN<GetFlds(); FldN++){
582      TStr FldNm; TStr FldVal; GetFldNmVal(FldN, FldNm, FldVal);
583      FldNmValKdV.Add(TStrKd(FldNm, FldVal));
584    }
585  }
586  bool TSoapResp::IsFldNm(const TStr& FldNm) const {
587    int Flds=GetFlds();
588    TStr _FldNm; TStr FldVal;
589    for (int FldN=0; FldN<Flds; FldN++){
590      GetFldNmVal(FldN, _FldNm, FldVal);
591      if (FldNm==_FldNm){return true;}
592    }
593    return false;
594  }
595  TStr TSoapResp::GetFldVal(const TStr& FldNm) const {
596    int Flds=GetFlds();
597    TStr _FldNm; TStr FldVal;
598    for (int FldN=0; FldN<Flds; FldN++){
599      GetFldNmVal(FldN, _FldNm, FldVal);
600      if (FldNm==_FldNm){return FldVal;}
601    }
602    return "";
603  }
604  TStr TSoapResp::GetRespStr() const {
605    if (IsOk()){
606      if (IsResult()){
607        return GetRespStr(FuncNm, FldNmValPrV);
608      } else {
609        return GetFaultRespStr(FaultCodeNm, FaultReasonStr);
610      }
611    } else {
612      return GetFaultRespStr(TSoap::DataEncodingUnknownCodeNm, "Unknown Error.");
613    }
614  }
615  TStr TSoapResp::GetAsUrlPathStr() const {
616    if (IsResult()){
617      return TSoap::GetUrlPathStr(FuncNm, true, FldNmValPrV);
618    } else
619    if (IsFault()){
620      return TSoap::GetUrlPathStr("Fault", true,
621       "FaultCode", GetFaultCodeNm(),
622       "FaultReason", GetFaultReasonStr());
623    } else {
624      return TSoap::GetUrlPathStr("Fault", true);
625    }
626  }
627  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
628   const TStr& FldNm1, const TStr& FldVal1,
629   const TStr& FldNm2, const TStr& FldVal2,
630   const TStr& FldNm3, const TStr& FldVal3){
631    PSoapResp SoapResp=TSoapResp::New(FuncNm);
632    SoapResp->AddFldNmVal(FldNm1, FldVal1);
633    SoapResp->AddFldNmVal(FldNm2, FldVal2);
634    SoapResp->AddFldNmVal(FldNm3, FldVal3);
635    return SoapResp->GetHttpResp();
636  }
637  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
638   const TStr& FldNm1, const TStr& FldVal1,
639   const TStr& FldNm2, const TStr& FldVal2,
640   const TStr& FldNm3, const TStr& FldVal3,
641   const TStr& FldNm4, const TStr& FldVal4){
642    PSoapResp SoapResp=TSoapResp::New(FuncNm);
643    SoapResp->AddFldNmVal(FldNm1, FldVal1);
644    SoapResp->AddFldNmVal(FldNm2, FldVal2);
645    SoapResp->AddFldNmVal(FldNm3, FldVal3);
646    SoapResp->AddFldNmVal(FldNm4, FldVal4);
647    return SoapResp->GetHttpResp();
648  }
649  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
650   const TStr& FldNm1, const TStr& FldVal1,
651   const TStr& FldNm2, const TStr& FldVal2,
652   const TStr& FldNm3, const TStr& FldVal3,
653   const TStr& FldNm4, const TStr& FldVal4,
654   const TStr& FldNm5, const TStr& FldVal5){
655    PSoapResp SoapResp=TSoapResp::New(FuncNm);
656    SoapResp->AddFldNmVal(FldNm1, FldVal1);
657    SoapResp->AddFldNmVal(FldNm2, FldVal2);
658    SoapResp->AddFldNmVal(FldNm3, FldVal3);
659    SoapResp->AddFldNmVal(FldNm4, FldVal4);
660    SoapResp->AddFldNmVal(FldNm5, FldVal5);
661    return SoapResp->GetHttpResp();
662  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-weightmatrix.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-soap.cpp</div>
                </div>
                <div class="column column_space"><pre><code>308      IntSimdMatrix::MatrixDotVector(wi_, scales_, u, v);
309    }
310  }
311  void WeightMatrix::MultiplyAccumulate(const TFloat *v, TFloat *inout) {
</pre></code></div>
                <div class="column column_space"><pre><code>362      TStr _FldNm; GetVecFld(FldN, _FldNm, FldValV, FldNmValPrV);
363    }
364  }
365  int TSoap::GetVecFld(
366   const int& _FldN, TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    