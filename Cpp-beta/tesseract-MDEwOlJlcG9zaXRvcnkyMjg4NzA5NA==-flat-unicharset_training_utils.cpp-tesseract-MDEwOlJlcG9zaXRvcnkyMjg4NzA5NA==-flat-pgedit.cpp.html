
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.5547240411599623%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset_training_utils.cpp</h3>
            <pre><code>1  #include "unicharset_training_utils.h"
2  #include <cstdlib>
3  #include <cstring>
4  #include <string>
5  #include <vector>
6  #include <tesseract/unichar.h>
7  #include "fileio.h"
8  #include "icuerrorcode.h"
9  #include "normstrngs.h"
10  #include "statistc.h"
11  #include "unicharset.h"
12  #include "unicode/uchar.h"   
13  #include "unicode/uscript.h" 
14  namespace tesseract {
15  void SetupBasicProperties(bool report_errors, bool decompose, UNICHARSET *unicharset) {
16    for (size_t unichar_id = 0; unichar_id < unicharset->size(); ++unichar_id) {
17      const char *unichar_str = unicharset->id_to_unichar(unichar_id);
18      for (int i = 0; UNICHARSET::kCustomLigatures[i][0] != nullptr; ++i) {
19        if (!strcmp(UNICHARSET::kCustomLigatures[i][1], unichar_str)) {
20          unichar_str = UNICHARSET::kCustomLigatures[i][0];
21          break;
22        }
23      }
24      std::vector<char32> uni_vector = UNICHAR::UTF8ToUTF32(unichar_str);
<span onclick='openModal()' class='match'>25      bool unichar_isalpha = false;
26      bool unichar_islower = false;
27      bool unichar_isupper = false;
28      bool unichar_isdigit = false;
29      bool unichar_ispunct = false;
</span>30      for (char32 u_ch : uni_vector) {
31        if (u_isalpha(u_ch)) {
32          unichar_isalpha = true;
33        }
34        if (u_islower(u_ch)) {
35          unichar_islower = true;
36        }
37        if (u_isupper(u_ch)) {
38          unichar_isupper = true;
39        }
40        if (u_isdigit(u_ch)) {
41          unichar_isdigit = true;
42        }
43        if (u_ispunct(u_ch)) {
44          unichar_ispunct = true;
45        }
46      }
47      unicharset->set_isalpha(unichar_id, unichar_isalpha);
48      unicharset->set_islower(unichar_id, unichar_islower);
49      unicharset->set_isupper(unichar_id, unichar_isupper);
50      unicharset->set_isdigit(unichar_id, unichar_isdigit);
51      unicharset->set_ispunctuation(unichar_id, unichar_ispunct);
52      tesseract::IcuErrorCode err;
53      unicharset->set_script(unichar_id, uscript_getName(uscript_getScript(uni_vector[0], err)));
54      const int num_code_points = uni_vector.size();
55      unicharset->set_other_case(unichar_id, unichar_id);
56      if (unichar_islower || unichar_isupper) {
57        std::vector<char32> other_case(num_code_points, 0);
58        for (int i = 0; i < num_code_points; ++i) {
59          other_case[i] = unichar_islower ? u_toupper(uni_vector[i]) : u_tolower(uni_vector[i]);
60        }
61        std::string other_case_uch = UNICHAR::UTF32ToUTF8(other_case);
62        UNICHAR_ID other_case_id = unicharset->unichar_to_id(other_case_uch.c_str());
63        if (other_case_id != INVALID_UNICHAR_ID) {
64          unicharset->set_other_case(unichar_id, other_case_id);
65        } else if (unichar_id >= SPECIAL_UNICHAR_CODES_COUNT && report_errors) {
66          tprintf("Other case %s of %s is not in unicharset\n", other_case_uch.c_str(), unichar_str);
67        }
68      }
69      std::vector<char32> mirrors(num_code_points, 0);
70      for (int i = 0; i < num_code_points; ++i) {
71        mirrors[i] = u_charMirror(uni_vector[i]);
72        if (i == 0) { 
73          unicharset->set_direction(
74              unichar_id, static_cast<UNICHARSET::Direction>(u_charDirection(uni_vector[i])));
75        }
76      }
77      std::string mirror_uch = UNICHAR::UTF32ToUTF8(mirrors);
78      UNICHAR_ID mirror_uch_id = unicharset->unichar_to_id(mirror_uch.c_str());
79      if (mirror_uch_id != INVALID_UNICHAR_ID) {
80        unicharset->set_mirror(unichar_id, mirror_uch_id);
81      } else if (report_errors) {
82        tprintf("Mirror %s of %s is not in unicharset\n", mirror_uch.c_str(), unichar_str);
83      }
84      std::string normed_str;
85      if (unichar_id != 0 &&
86          tesseract::NormalizeUTF8String(
87              decompose ? tesseract::UnicodeNormMode::kNFD : tesseract::UnicodeNormMode::kNFC,
88              tesseract::OCRNorm::kNormalize, tesseract::GraphemeNorm::kNone, unichar_str,
89              &normed_str) &&
90          !normed_str.empty()) {
91        unicharset->set_normed(unichar_id, normed_str.c_str());
92      } else {
93        unicharset->set_normed(unichar_id, unichar_str);
94      }
95      ASSERT_HOST(unicharset->get_other_case(unichar_id) < unicharset->size());
96    }
97    unicharset->post_load_setup();
98  }
99  void SetScriptProperties(const std::string &script_dir, UNICHARSET *unicharset) {
100    for (int s = 0; s < unicharset->get_script_table_size(); ++s) {
101      std::string filename =
102          script_dir + "/" + unicharset->get_script_from_script_id(s) + ".unicharset";
103      UNICHARSET script_set;
104      if (script_set.load_from_file(filename.c_str())) {
105        unicharset->SetPropertiesFromOther(script_set);
106      } else if (s != unicharset->common_sid() && s != unicharset->null_sid()) {
107        tprintf("Failed to load script unicharset from:%s\n", filename.c_str());
108      }
109    }
110    for (int c = SPECIAL_UNICHAR_CODES_COUNT; c < unicharset->size(); ++c) {
111      if (unicharset->PropertiesIncomplete(c)) {
112        tprintf("Warning: properties incomplete for index %d = %s\n", c,
113                unicharset->id_to_unichar(c));
114      }
115    }
116  }
117  std::string GetXheightString(const std::string &script_dir, const UNICHARSET &unicharset) {
118    std::string xheights_str;
119    for (int s = 0; s < unicharset.get_script_table_size(); ++s) {
120      std::string filename = script_dir + "/" + unicharset.get_script_from_script_id(s) + ".xheights";
121      std::string script_heights;
122      if (File::ReadFileToString(filename, &script_heights)) {
123        xheights_str += script_heights;
124      }
125    }
126    return xheights_str;
127  }
128  void SetPropertiesForInputFile(const std::string &script_dir,
129                                 const std::string &input_unicharset_file,
130                                 const std::string &output_unicharset_file,
131                                 const std::string &output_xheights_file) {
132    UNICHARSET unicharset;
133    unicharset.load_from_file(input_unicharset_file.c_str());
134    tprintf("Loaded unicharset of size %zu from file %s\n", unicharset.size(),
135            input_unicharset_file.c_str());
136    tprintf("Setting unichar properties\n");
137    SetupBasicProperties(true, false, &unicharset);
138    tprintf("Setting script properties\n");
139    SetScriptProperties(script_dir, &unicharset);
140    if (!output_xheights_file.empty()) {
141      std::string xheights_str = GetXheightString(script_dir, unicharset);
142      File::WriteStringToFileOrDie(xheights_str, output_xheights_file);
143    }
144    tprintf("Writing unicharset to file %s\n", output_unicharset_file.c_str());
145    unicharset.save_to_file(output_unicharset_file.c_str());
146  }
147  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pgedit.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "pgedit.h"
5  #include "blread.h"
6  #include "control.h"
7  #include "pageres.h"
8  #include "paramsd.h"
9  #include "scrollview.h"
10  #include "statistc.h"
11  #include "svmnode.h"
12  #include "tesseractclass.h"
13  #include "tordmain.h"
14  #include "werdit.h"
15  #include <cctype>
16  #include <cmath>
17  #include <iomanip> 
18  #include <locale>  
19  #include <sstream> 
20  #ifndef GRAPHICS_DISABLED
21  namespace tesseract {
22  #  define ASC_HEIGHT (2 * kBlnBaselineOffset + kBlnXHeight)
23  #  define X_HEIGHT (kBlnBaselineOffset + kBlnXHeight)
24  #  define BL_HEIGHT kBlnBaselineOffset
25  #  define DESC_HEIGHT 0
26  enum CMD_EVENTS {
27    NULL_CMD_EVENT,
28    CHANGE_DISP_CMD_EVENT,
29    DUMP_WERD_CMD_EVENT,
30    SHOW_POINT_CMD_EVENT,
31    SHOW_BLN_WERD_CMD_EVENT,
32    DEBUG_WERD_CMD_EVENT,
33    BLAMER_CMD_EVENT,
34    BOUNDING_BOX_CMD_EVENT,
35    CORRECT_TEXT_CMD_EVENT,
36    POLYGONAL_CMD_EVENT,
37    BL_NORM_CMD_EVENT,
38    BITMAP_CMD_EVENT,
39    IMAGE_CMD_EVENT,
40    BLOCKS_CMD_EVENT,
41    BASELINES_CMD_EVENT,
42    UNIFORM_DISP_CMD_EVENT,
43    REFRESH_CMD_EVENT,
44    QUIT_CMD_EVENT,
45    RECOG_WERDS,
46    RECOG_PSEUDO,
47    SHOW_BLOB_FEATURES,
48    SHOW_SUBSCRIPT_CMD_EVENT,
49    SHOW_SUPERSCRIPT_CMD_EVENT,
50    SHOW_ITALIC_CMD_EVENT,
51    SHOW_BOLD_CMD_EVENT,
52    SHOW_UNDERLINE_CMD_EVENT,
53    SHOW_FIXEDPITCH_CMD_EVENT,
54    SHOW_SERIF_CMD_EVENT,
55    SHOW_SMALLCAPS_CMD_EVENT,
56    SHOW_DROPCAPS_CMD_EVENT,
57  };
58  enum ColorationMode {
59    CM_RAINBOW,
60    CM_SUBSCRIPT,
61    CM_SUPERSCRIPT,
62    CM_ITALIC,
63    CM_BOLD,
64    CM_UNDERLINE,
65    CM_FIXEDPITCH,
66    CM_SERIF,
67    CM_SMALLCAPS,
68    CM_DROPCAPS
69  };
70  static ScrollView *image_win;
71  static ParamsEditor *pe;
72  static bool stillRunning = false;
73  static ScrollView *bln_word_window = nullptr; 
74  static CMD_EVENTS mode = CHANGE_DISP_CMD_EVENT; 
75  static bool recog_done = false; 
76  static std::bitset<16> word_display_mode;
<span onclick='openModal()' class='match'>77  static ColorationMode color_mode = CM_RAINBOW;
78  static bool display_image = false;
79  static bool display_blocks = false;
80  static bool display_baselines = false;
81  static PAGE_RES *current_page_res = nullptr;
</span>82  STRING_VAR(editor_image_win_name, "EditorImage", "Editor image window name");
83  INT_VAR(editor_image_xpos, 590, "Editor image X Pos");
84  INT_VAR(editor_image_ypos, 10, "Editor image Y Pos");
85  static INT_VAR(editor_image_menuheight, 50, "Add to image height for menu bar");
86  INT_VAR(editor_image_word_bb_color, ScrollView::BLUE, "Word bounding box colour");
87  INT_VAR(editor_image_blob_bb_color, ScrollView::YELLOW, "Blob bounding box colour");
88  STRING_VAR(editor_word_name, "BlnWords", "BL normalized word window");
89  INT_VAR(editor_word_xpos, 60, "Word window X Pos");
90  INT_VAR(editor_word_ypos, 510, "Word window Y Pos");
91  INT_VAR(editor_word_height, 240, "Word window height");
92  INT_VAR(editor_word_width, 655, "Word window width");
93  static void show_point(PAGE_RES *page_res, float x, float y) {
94    FCOORD pt(x, y);
95    PAGE_RES_IT pr_it(page_res);
96    std::stringstream msg;
97    msg.imbue(std::locale::classic());
98    msg << std::fixed << std::setprecision(3) << "Pt:(" << x << ", " << y << ") ";
99    for (WERD_RES *word = pr_it.word(); word != nullptr; word = pr_it.forward()) {
100      if (pr_it.row() != pr_it.prev_row() && pr_it.row()->row->bounding_box().contains(pt)) {
101        msg << "BL(x)=" << pr_it.row()->row->base_line(x) << ' ';
102      }
103      if (word->word->bounding_box().contains(pt)) {
104        TBOX box = word->word->bounding_box();
105        msg << "Wd(" << box.left() << ", " << box.bottom() << ")/("
106            << box.right() << ", " << box.top() << ") ";
107        C_BLOB_IT cblob_it(word->word->cblob_list());
108        for (cblob_it.mark_cycle_pt(); !cblob_it.cycled_list(); cblob_it.forward()) {
109          C_BLOB *cblob = cblob_it.data();
110          box = cblob->bounding_box();
111          if (box.contains(pt)) {
112            msg << "CBlb(" << box.left() << ", " << box.bottom() << ")/("
113                << box.right() << ", " << box.top() << ") ";
114          }
115        }
116      }
117    }
118    image_win->AddMessage(msg.str().c_str());
119  }
120  static void pgeditor_msg( 
121      const char *msg) {
122    image_win->AddMessage(msg);
123  }
124  class BlnEventHandler : public SVEventHandler {
125  public:
126    void Notify(const SVEvent *sv_event) override {
127      if (sv_event->type == SVET_DESTROY) {
128        bln_word_window = nullptr;
129      } else if (sv_event->type == SVET_CLICK) {
130        show_point(current_page_res, sv_event->x, sv_event->y);
131      }
132    }
133  };
134  static ScrollView *bln_word_window_handle() { 
135    if (bln_word_window == nullptr) {
136      pgeditor_msg("Creating BLN word window...");
137      bln_word_window = new ScrollView(editor_word_name.c_str(), editor_word_xpos, editor_word_ypos,
138                                       editor_word_width, editor_word_height, 4000, 4000, true);
139      auto *a = new BlnEventHandler();
140      bln_word_window->AddEventHandler(a);
141      pgeditor_msg("Creating BLN word window...Done");
142    }
143    return bln_word_window;
144  }
145  static void build_image_window(int width, int height) {
146    delete image_win;
147    image_win = new ScrollView(editor_image_win_name.c_str(), editor_image_xpos, editor_image_ypos,
148                               width + 1, height + editor_image_menuheight + 1, width, height, true);
149  }
150  static void display_bln_lines(ScrollView *window, ScrollView::Color colour, float scale_factor,
151                                float y_offset, float minx, float maxx) {
152    window->Pen(colour);
153    window->Line(minx, y_offset + scale_factor * DESC_HEIGHT, maxx,
154                 y_offset + scale_factor * DESC_HEIGHT);
155    window->Line(minx, y_offset + scale_factor * BL_HEIGHT, maxx,
156                 y_offset + scale_factor * BL_HEIGHT);
157    window->Line(minx, y_offset + scale_factor * X_HEIGHT, maxx, y_offset + scale_factor * X_HEIGHT);
158    window->Line(minx, y_offset + scale_factor * ASC_HEIGHT, maxx,
159                 y_offset + scale_factor * ASC_HEIGHT);
160  }
161  void PGEventHandler::Notify(const SVEvent *event) {
162    char myval = '0';
163    if (event->type == SVET_POPUP) {
164      pe->Notify(event);
165    } 
166    else if (event->type == SVET_EXIT) {
167      stillRunning = false;
168    } else if (event->type == SVET_MENU) {
169      if (strcmp(event->parameter, "true") == 0) {
170        myval = 'T';
171      } else if (strcmp(event->parameter, "false") == 0) {
172        myval = 'F';
173      }
174      tess_->process_cmd_win_event(event->command_id, &myval);
175    } else {
176      tess_->process_image_event(*event);
177    }
178  }
179  SVMenuNode *Tesseract::build_menu_new() {
180    SVMenuNode *parent_menu;
181    auto *root_menu_item = new SVMenuNode();
182    SVMenuNode *modes_menu_item = root_menu_item->AddChild("MODES");
183    modes_menu_item->AddChild("Change Display", CHANGE_DISP_CMD_EVENT);
184    modes_menu_item->AddChild("Dump Word", DUMP_WERD_CMD_EVENT);
185    modes_menu_item->AddChild("Show Point", SHOW_POINT_CMD_EVENT);
186    modes_menu_item->AddChild("Show BL Norm Word", SHOW_BLN_WERD_CMD_EVENT);
187    modes_menu_item->AddChild("Config Words", DEBUG_WERD_CMD_EVENT);
188    modes_menu_item->AddChild("Recog Words", RECOG_WERDS);
189    modes_menu_item->AddChild("Recog Blobs", RECOG_PSEUDO);
190    modes_menu_item->AddChild("Show Blob Features", SHOW_BLOB_FEATURES);
191    parent_menu = root_menu_item->AddChild("DISPLAY");
192    parent_menu->AddChild("Blamer", BLAMER_CMD_EVENT, false);
193    parent_menu->AddChild("Bounding Boxes", BOUNDING_BOX_CMD_EVENT, false);
194    parent_menu->AddChild("Correct Text", CORRECT_TEXT_CMD_EVENT, false);
195    parent_menu->AddChild("Polygonal Approx", POLYGONAL_CMD_EVENT, false);
196    parent_menu->AddChild("Baseline Normalized", BL_NORM_CMD_EVENT, false);
197    parent_menu->AddChild("Edge Steps", BITMAP_CMD_EVENT, true);
198    parent_menu->AddChild("Subscripts", SHOW_SUBSCRIPT_CMD_EVENT);
199    parent_menu->AddChild("Superscripts", SHOW_SUPERSCRIPT_CMD_EVENT);
200    parent_menu->AddChild("Italics", SHOW_ITALIC_CMD_EVENT);
201    parent_menu->AddChild("Bold", SHOW_BOLD_CMD_EVENT);
202    parent_menu->AddChild("Underline", SHOW_UNDERLINE_CMD_EVENT);
203    parent_menu->AddChild("FixedPitch", SHOW_FIXEDPITCH_CMD_EVENT);
204    parent_menu->AddChild("Serifs", SHOW_SERIF_CMD_EVENT);
205    parent_menu->AddChild("SmallCaps", SHOW_SMALLCAPS_CMD_EVENT);
206    parent_menu->AddChild("DropCaps", SHOW_DROPCAPS_CMD_EVENT);
207    parent_menu = root_menu_item->AddChild("OTHER");
208    parent_menu->AddChild("Quit", QUIT_CMD_EVENT);
209    parent_menu->AddChild("Show Image", IMAGE_CMD_EVENT, false);
210    parent_menu->AddChild("ShowBlock Outlines", BLOCKS_CMD_EVENT, false);
211    parent_menu->AddChild("Show Baselines", BASELINES_CMD_EVENT, false);
212    parent_menu->AddChild("Uniform Display", UNIFORM_DISP_CMD_EVENT);
213    parent_menu->AddChild("Refresh Display", REFRESH_CMD_EVENT);
214    return root_menu_item;
215  }
216  void Tesseract::do_re_display(bool (tesseract::Tesseract::*word_painter)(PAGE_RES_IT *pr_it)) {
217    int block_count = 1;
218    image_win->Clear();
219    if (display_image) {
220      image_win->Draw(pix_binary_, 0, 0);
221    }
222    image_win->Brush(ScrollView::NONE);
223    PAGE_RES_IT pr_it(current_page_res);
224    for (WERD_RES *word = pr_it.word(); word != nullptr; word = pr_it.forward()) {
225      (this->*word_painter)(&pr_it);
226      if (display_baselines && pr_it.row() != pr_it.prev_row()) {
227        pr_it.row()->row->plot_baseline(image_win, ScrollView::GREEN);
228      }
229      if (display_blocks && pr_it.block() != pr_it.prev_block()) {
230        pr_it.block()->block->pdblk.plot(image_win, block_count++, ScrollView::RED);
231      }
232    }
233    image_win->Update();
234  }
235  void Tesseract::pgeditor_main(int width, int height, PAGE_RES *page_res) {
236    current_page_res = page_res;
237    if (current_page_res->block_res_list.empty()) {
238      return;
239    }
240    recog_done = false;
241    stillRunning = true;
242    build_image_window(width, height);
243    word_display_mode.set(DF_EDGE_STEP);
244    do_re_display(&tesseract::Tesseract::word_set_display);
245  #  ifndef GRAPHICS_DISABLED
246    pe = new ParamsEditor(this, image_win);
247  #  endif
248    PGEventHandler pgEventHandler(this);
249    image_win->AddEventHandler(&pgEventHandler);
250    image_win->AddMessageBox();
251    SVMenuNode *svMenuRoot = build_menu_new();
252    svMenuRoot->BuildMenu(image_win);
253    image_win->SetVisible(true);
254    image_win->AwaitEvent(SVET_DESTROY);
255    image_win->AddEventHandler(nullptr);
256  }
257  bool Tesseract::process_cmd_win_event( 
258      int32_t cmd_event,                 
259      char *new_value                    
260  ) {
261    char msg[160];
262    bool exit = false;
263    color_mode = CM_RAINBOW;
264    switch (cmd_event) {
265      case BLAMER_CMD_EVENT:
266      case SHOW_SUBSCRIPT_CMD_EVENT:
267      case SHOW_SUPERSCRIPT_CMD_EVENT:
268      case SHOW_ITALIC_CMD_EVENT:
269      case SHOW_BOLD_CMD_EVENT:
270      case SHOW_UNDERLINE_CMD_EVENT:
271      case SHOW_FIXEDPITCH_CMD_EVENT:
272      case SHOW_SERIF_CMD_EVENT:
273      case SHOW_SMALLCAPS_CMD_EVENT:
274      case SHOW_DROPCAPS_CMD_EVENT:
275        if (!recog_done) {
276          recog_all_words(current_page_res, nullptr, nullptr, nullptr, 0);
277          recog_done = true;
278        }
279        break;
280      default:
281        break;
282    }
283    char *parameter;
284    switch (cmd_event) {
285      case NULL_CMD_EVENT:
286        break;
287      case CHANGE_DISP_CMD_EVENT:
288      case DUMP_WERD_CMD_EVENT:
289      case SHOW_POINT_CMD_EVENT:
290      case SHOW_BLN_WERD_CMD_EVENT:
291      case RECOG_WERDS:
292      case RECOG_PSEUDO:
293      case SHOW_BLOB_FEATURES:
294        mode = static_cast<CMD_EVENTS>(cmd_event);
295        break;
296      case DEBUG_WERD_CMD_EVENT:
297        mode = DEBUG_WERD_CMD_EVENT;
298        parameter = image_win->ShowInputDialog("Config File Name");
299        word_config_ = parameter;
300        delete[] parameter;
301        break;
302      case BOUNDING_BOX_CMD_EVENT:
303        if (new_value[0] == 'T') {
304          word_display_mode.set(DF_BOX);
305        } else {
306          word_display_mode.reset(DF_BOX);
307        }
308        mode = CHANGE_DISP_CMD_EVENT;
309        break;
310      case BLAMER_CMD_EVENT:
311        if (new_value[0] == 'T') {
312          word_display_mode.set(DF_BLAMER);
313        } else {
314          word_display_mode.reset(DF_BLAMER);
315        }
316        do_re_display(&tesseract::Tesseract::word_display);
317        mode = CHANGE_DISP_CMD_EVENT;
318        break;
319      case CORRECT_TEXT_CMD_EVENT:
320        if (new_value[0] == 'T') {
321          word_display_mode.set(DF_TEXT);
322        } else {
323          word_display_mode.reset(DF_TEXT);
324        }
325        mode = CHANGE_DISP_CMD_EVENT;
326        break;
327      case POLYGONAL_CMD_EVENT:
328        if (new_value[0] == 'T') {
329          word_display_mode.set(DF_POLYGONAL);
330        } else {
331          word_display_mode.reset(DF_POLYGONAL);
332        }
333        mode = CHANGE_DISP_CMD_EVENT;
334        break;
335      case BL_NORM_CMD_EVENT:
336        if (new_value[0] == 'T') {
337          word_display_mode.set(DF_BN_POLYGONAL);
338        } else {
339          word_display_mode.reset(DF_BN_POLYGONAL);
340        }
341        mode = CHANGE_DISP_CMD_EVENT;
342        break;
343      case BITMAP_CMD_EVENT:
344        if (new_value[0] == 'T') {
345          word_display_mode.set(DF_EDGE_STEP);
346        } else {
347          word_display_mode.reset(DF_EDGE_STEP);
348        }
349        mode = CHANGE_DISP_CMD_EVENT;
350        break;
351      case UNIFORM_DISP_CMD_EVENT:
352        do_re_display(&tesseract::Tesseract::word_set_display);
353        break;
354      case IMAGE_CMD_EVENT:
355        display_image = (new_value[0] == 'T');
356        do_re_display(&tesseract::Tesseract::word_display);
357        break;
358      case BLOCKS_CMD_EVENT:
359        display_blocks = (new_value[0] == 'T');
360        do_re_display(&tesseract::Tesseract::word_display);
361        break;
362      case BASELINES_CMD_EVENT:
363        display_baselines = (new_value[0] == 'T');
364        do_re_display(&tesseract::Tesseract::word_display);
365        break;
366      case SHOW_SUBSCRIPT_CMD_EVENT:
367        color_mode = CM_SUBSCRIPT;
368        do_re_display(&tesseract::Tesseract::word_display);
369        break;
370      case SHOW_SUPERSCRIPT_CMD_EVENT:
371        color_mode = CM_SUPERSCRIPT;
372        do_re_display(&tesseract::Tesseract::word_display);
373        break;
374      case SHOW_ITALIC_CMD_EVENT:
375        color_mode = CM_ITALIC;
376        do_re_display(&tesseract::Tesseract::word_display);
377        break;
378      case SHOW_BOLD_CMD_EVENT:
379        color_mode = CM_BOLD;
380        do_re_display(&tesseract::Tesseract::word_display);
381        break;
382      case SHOW_UNDERLINE_CMD_EVENT:
383        color_mode = CM_UNDERLINE;
384        do_re_display(&tesseract::Tesseract::word_display);
385        break;
386      case SHOW_FIXEDPITCH_CMD_EVENT:
387        color_mode = CM_FIXEDPITCH;
388        do_re_display(&tesseract::Tesseract::word_display);
389        break;
390      case SHOW_SERIF_CMD_EVENT:
391        color_mode = CM_SERIF;
392        do_re_display(&tesseract::Tesseract::word_display);
393        break;
394      case SHOW_SMALLCAPS_CMD_EVENT:
395        color_mode = CM_SMALLCAPS;
396        do_re_display(&tesseract::Tesseract::word_display);
397        break;
398      case SHOW_DROPCAPS_CMD_EVENT:
399        color_mode = CM_DROPCAPS;
400        do_re_display(&tesseract::Tesseract::word_display);
401        break;
402      case REFRESH_CMD_EVENT:
403        do_re_display(&tesseract::Tesseract::word_display);
404        break;
405      case QUIT_CMD_EVENT:
406        exit = true;
407        ScrollView::Exit();
408        break;
409      default:
410        snprintf(msg, sizeof(msg), "Unrecognised event %" PRId32 "(%s)", cmd_event, new_value);
411        image_win->AddMessage(msg);
412        break;
413    }
414    return exit;
415  }
416  void Tesseract::process_image_event( 
417      const SVEvent &event) {
418    static ICOORD down;
419    ICOORD up;
420    TBOX selection_box;
421    char msg[80];
422    switch (event.type) {
423      case SVET_SELECTION:
424        if (event.type == SVET_SELECTION) {
425          down.set_x(event.x + event.x_size);
426          down.set_y(event.y + event.y_size);
427          if (mode == SHOW_POINT_CMD_EVENT) {
428            show_point(current_page_res, event.x, event.y);
429          }
430        }
431        up.set_x(event.x);
432        up.set_y(event.y);
433        selection_box = TBOX(down, up);
434        switch (mode) {
435          case CHANGE_DISP_CMD_EVENT:
436            process_selected_words(current_page_res, selection_box,
437                                   &tesseract::Tesseract::word_blank_and_set_display);
438            break;
439          case DUMP_WERD_CMD_EVENT:
440            process_selected_words(current_page_res, selection_box,
441                                   &tesseract::Tesseract::word_dumper);
442            break;
443          case SHOW_BLN_WERD_CMD_EVENT:
444            process_selected_words(current_page_res, selection_box,
445                                   &tesseract::Tesseract::word_bln_display);
446            break;
447          case DEBUG_WERD_CMD_EVENT:
448            debug_word(current_page_res, selection_box);
449            break;
450          case SHOW_POINT_CMD_EVENT:
451            break; 
452          case RECOG_WERDS:
453  #  ifndef DISABLED_LEGACY_ENGINE
454            image_win->AddMessage("Recogging selected words");
455            this->process_selected_words(current_page_res, selection_box,
456                                         &Tesseract::recog_interactive);
457  #  endif 
458            break;
459          case RECOG_PSEUDO:
460            image_win->AddMessage("Recogging selected blobs");
461            recog_pseudo_word(current_page_res, selection_box);
462            break;
463          case SHOW_BLOB_FEATURES:
464            blob_feature_display(current_page_res, selection_box);
465            break;
466          default:
467            snprintf(msg, sizeof(msg), "Mode %d not yet implemented", mode);
468            image_win->AddMessage(msg);
469            break;
470        }
471      default:
472        break;
473    }
474  }
475  void Tesseract::debug_word(PAGE_RES *page_res, const TBOX &selection_box) {
476  #  ifndef DISABLED_LEGACY_ENGINE
477    ResetAdaptiveClassifier();
478  #  endif
479    recog_all_words(page_res, nullptr, &selection_box, word_config_.c_str(), 0);
480  }
481  bool Tesseract::word_blank_and_set_display(PAGE_RES_IT *pr_it) {
482    pr_it->word()->word->bounding_box().plot(image_win, ScrollView::BLACK, ScrollView::BLACK);
483    return word_set_display(pr_it);
484  }
485  bool Tesseract::word_bln_display(PAGE_RES_IT *pr_it) {
486    WERD_RES *word_res = pr_it->word();
487    if (word_res->chopped_word == nullptr) {
488      word_res->SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode, nullptr,
489                                    classify_bln_numeric_mode, textord_use_cjk_fp_model,
490                                    poly_allow_detailed_fx, pr_it->row()->row, pr_it->block()->block);
491    }
492    bln_word_window_handle()->Clear();
493    display_bln_lines(bln_word_window_handle(), ScrollView::CYAN, 1.0, 0.0f, -1000.0f, 1000.0f);
494    C_BLOB_IT it(word_res->word->cblob_list());
495    ScrollView::Color color = WERD::NextColor(ScrollView::BLACK);
496    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
497      it.data()->plot_normed(word_res->denorm, color, ScrollView::BROWN, bln_word_window_handle());
498      color = WERD::NextColor(color);
499    }
500    bln_word_window_handle()->Update();
501    return true;
502  }
503  bool Tesseract::word_display(PAGE_RES_IT *pr_it) {
504    WERD_RES *word_res = pr_it->word();
505    WERD *word = word_res->word;
506    TBOX word_bb;    
507    int word_height; 
508    bool displayed_something = false;
509    float shift; 
510    if (color_mode != CM_RAINBOW && word_res->box_word != nullptr) {
511  #  ifndef DISABLED_LEGACY_ENGINE
512      BoxWord *box_word = word_res->box_word;
513      WERD_CHOICE *best_choice = word_res->best_choice;
514      int length = box_word->length();
515      if (word_res->fontinfo == nullptr) {
516        return false;
517      }
518      const FontInfo &font_info = *word_res->fontinfo;
519      for (int i = 0; i < length; ++i) {
520        ScrollView::Color color = ScrollView::GREEN;
521        switch (color_mode) {
522          case CM_SUBSCRIPT:
523            if (best_choice->BlobPosition(i) == SP_SUBSCRIPT) {
524              color = ScrollView::RED;
525            }
526            break;
527          case CM_SUPERSCRIPT:
528            if (best_choice->BlobPosition(i) == SP_SUPERSCRIPT) {
529              color = ScrollView::RED;
530            }
531            break;
532          case CM_ITALIC:
533            if (font_info.is_italic()) {
534              color = ScrollView::RED;
535            }
536            break;
537          case CM_BOLD:
538            if (font_info.is_bold()) {
539              color = ScrollView::RED;
540            }
541            break;
542          case CM_FIXEDPITCH:
543            if (font_info.is_fixed_pitch()) {
544              color = ScrollView::RED;
545            }
546            break;
547          case CM_SERIF:
548            if (font_info.is_serif()) {
549              color = ScrollView::RED;
550            }
551            break;
552          case CM_SMALLCAPS:
553            if (word_res->small_caps) {
554              color = ScrollView::RED;
555            }
556            break;
557          case CM_DROPCAPS:
558            if (best_choice->BlobPosition(i) == SP_DROPCAP) {
559              color = ScrollView::RED;
560            }
561            break;
562          case CM_UNDERLINE:
563          default:
564            break;
565        }
566        image_win->Pen(color);
567        TBOX box = box_word->BlobBox(i);
568        image_win->Rectangle(box.left(), box.bottom(), box.right(), box.top());
569      }
570      return true;
571  #  else
572      return false;
573  #  endif 
574    }
575    if (word->display_flag(DF_BOX)) {
576      word->bounding_box().plot(image_win,
577                                static_cast<ScrollView::Color>((int32_t)editor_image_word_bb_color),
578                                static_cast<ScrollView::Color>((int32_t)editor_image_word_bb_color));
579      auto c = static_cast<ScrollView::Color>((int32_t)editor_image_blob_bb_color);
580      image_win->Pen(c);
581      C_BLOB_IT c_it(word->cblob_list());
582      for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
583        c_it.data()->bounding_box().plot(image_win);
584      }
585      displayed_something = true;
586    }
587    if (word->display_flag(DF_EDGE_STEP)) { 
588      word->plot(image_win);                
589      displayed_something = true;
590    }
591    if (word->display_flag(DF_POLYGONAL)) {
592      TWERD *tword = TWERD::PolygonalCopy(poly_allow_detailed_fx, word);
593      tword->plot(image_win);
594      delete tword;
595      displayed_something = true;
596    }
597    std::string text;
598    std::string blame;
599    if (word->display_flag(DF_TEXT) && word->text() != nullptr) {
600      text = word->text();
601    }
602    if (word->display_flag(DF_BLAMER) &&
603        !(word_res->blamer_bundle != nullptr &&
604          word_res->blamer_bundle->incorrect_result_reason() == IRR_CORRECT)) {
605      text = "";
606      const BlamerBundle *blamer_bundle = word_res->blamer_bundle;
607      if (blamer_bundle == nullptr) {
608        text += "NULL";
609      } else {
610        text = blamer_bundle->TruthString();
611      }
612      text += " -> ";
613      std::string best_choice_str;
614      if (word_res->best_choice == nullptr) {
615        best_choice_str = "NULL";
616      } else {
617        word_res->best_choice->string_and_lengths(&best_choice_str, nullptr);
618      }
619      text += best_choice_str;
620      IncorrectResultReason reason =
621          (blamer_bundle == nullptr) ? IRR_PAGE_LAYOUT : blamer_bundle->incorrect_result_reason();
622      ASSERT_HOST(reason < IRR_NUM_REASONS);
623      blame += " [";
624      blame += BlamerBundle::IncorrectReasonName(reason);
625      blame += "]";
626    }
627    if (text.length() > 0) {
628      word_bb = word->bounding_box();
629      image_win->Pen(ScrollView::RED);
630      word_height = word_bb.height();
631      int text_height = 0.50 * word_height;
632      if (text_height > 20) {
633        text_height = 20;
634      }
635      image_win->TextAttributes("Arial", text_height, false, false, false);
636      shift = (word_height < word_bb.width()) ? 0.25 * word_height : 0.0f;
637      image_win->Text(word_bb.left() + shift, word_bb.bottom() + 0.25 * word_height, text.c_str());
638      if (blame.length() > 0) {
639        image_win->Text(word_bb.left() + shift, word_bb.bottom() + 0.25 * word_height - text_height,
640                        blame.c_str());
641      }
642      displayed_something = true;
643    }
644    if (!displayed_something) { 
645      word->bounding_box().plot(image_win,
646                                static_cast<ScrollView::Color>((int32_t)editor_image_word_bb_color),
647                                static_cast<ScrollView::Color>((int32_t)editor_image_word_bb_color));
648    }
649    return true;
650  }
651  } 
652  #endif 
653  namespace tesseract {
654  bool Tesseract::word_dumper(PAGE_RES_IT *pr_it) {
655    if (pr_it->block()->block != nullptr) {
656      tprintf("\nBlock data...\n");
657      pr_it->block()->block->print(nullptr, false);
658    }
659    tprintf("\nRow data...\n");
660    pr_it->row()->row->print(nullptr);
661    tprintf("\nWord data...\n");
662    WERD_RES *word_res = pr_it->word();
663    word_res->word->print();
664    if (word_res->blamer_bundle != nullptr && wordrec_debug_blamer &&
665        word_res->blamer_bundle->incorrect_result_reason() != IRR_CORRECT) {
666      tprintf("Current blamer debug: %s\n", word_res->blamer_bundle->debug().c_str());
667    }
668    return true;
669  }
670  #ifndef GRAPHICS_DISABLED
671  bool Tesseract::word_set_display(PAGE_RES_IT *pr_it) {
672    WERD *word = pr_it->word()->word;
673    word->set_display_flag(DF_BOX, word_display_mode[DF_BOX]);
674    word->set_display_flag(DF_TEXT, word_display_mode[DF_TEXT]);
675    word->set_display_flag(DF_POLYGONAL, word_display_mode[DF_POLYGONAL]);
676    word->set_display_flag(DF_EDGE_STEP, word_display_mode[DF_EDGE_STEP]);
677    word->set_display_flag(DF_BN_POLYGONAL, word_display_mode[DF_BN_POLYGONAL]);
678    word->set_display_flag(DF_BLAMER, word_display_mode[DF_BLAMER]);
679    return word_display(pr_it);
680  }
681  void Tesseract::blob_feature_display(PAGE_RES *page_res, const TBOX &selection_box) {
682  #  ifndef DISABLED_LEGACY_ENGINE
683    PAGE_RES_IT *it = make_pseudo_word(page_res, selection_box);
684    if (it != nullptr) {
685      WERD_RES *word_res = it->word();
686      word_res->x_height = it->row()->row->x_height();
687      word_res->SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode, nullptr,
688                                    classify_bln_numeric_mode, textord_use_cjk_fp_model,
689                                    poly_allow_detailed_fx, it->row()->row, it->block()->block);
690      TWERD *bln_word = word_res->chopped_word;
691      TBLOB *bln_blob = bln_word->blobs[0];
692      INT_FX_RESULT_STRUCT fx_info;
693      std::vector<INT_FEATURE_STRUCT> bl_features;
694      std::vector<INT_FEATURE_STRUCT> cn_features;
695      Classify::ExtractFeatures(*bln_blob, classify_nonlinear_norm, &bl_features, &cn_features,
696                                &fx_info, nullptr);
697      ScrollView *bl_win = CreateFeatureSpaceWindow("BL Features", 512, 0);
698      ClearFeatureSpaceWindow(baseline, bl_win);
699      for (auto &bl_feature : bl_features) {
700        RenderIntFeature(bl_win, &bl_feature, ScrollView::GREEN);
701      }
702      bl_win->Update();
703      ScrollView *cn_win = CreateFeatureSpaceWindow("CN Features", 512, 0);
704      ClearFeatureSpaceWindow(character, cn_win);
705      for (auto &cn_feature : cn_features) {
706        RenderIntFeature(cn_win, &cn_feature, ScrollView::GREEN);
707      }
708      cn_win->Update();
709      it->DeleteCurrentWord();
710      delete it;
711    }
712  #  endif 
713  }
714  #endif 
715  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset_training_utils.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pgedit.cpp</div>
                </div>
                <div class="column column_space"><pre><code>25      bool unichar_isalpha = false;
26      bool unichar_islower = false;
27      bool unichar_isupper = false;
28      bool unichar_isdigit = false;
29      bool unichar_ispunct = false;
</pre></code></div>
                <div class="column column_space"><pre><code>77  static ColorationMode color_mode = CM_RAINBOW;
78  static bool display_image = false;
79  static bool display_blocks = false;
80  static bool display_baselines = false;
81  static PAGE_RES *current_page_res = nullptr;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    