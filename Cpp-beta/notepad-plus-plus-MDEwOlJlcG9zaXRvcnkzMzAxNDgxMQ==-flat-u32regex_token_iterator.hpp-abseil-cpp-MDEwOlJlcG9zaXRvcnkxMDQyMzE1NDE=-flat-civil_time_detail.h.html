
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.670663469224621%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-u32regex_token_iterator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_U32REGEX_TOKEN_ITERATOR_HPP
2  #define BOOST_REGEX_V5_U32REGEX_TOKEN_ITERATOR_HPP
3  namespace boost{
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #  pragma warning(disable:4700)
7  #endif
8  template <class BidirectionalIterator>
9  class u32regex_token_iterator_implementation 
10  {
11     typedef u32regex                              regex_type;
12     typedef sub_match<BidirectionalIterator>      value_type;
13     match_results<BidirectionalIterator> what;   
14     BidirectionalIterator                end;    
15     BidirectionalIterator                base;   
16     const regex_type                     re;     
17     match_flag_type                      flags;  
18     value_type                           result; 
19     int                                  N;      
20     std::vector<int>                     subs;   
21  public:
22     u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
23        : end(last), re(*p), flags(f){ subs.push_back(sub); }
24     u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector<int>& v, match_flag_type f)
25        : end(last), re(*p), flags(f), subs(v){}
26     template <std::size_t CN>
27     u32regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&submatches)[CN], match_flag_type f)
28        : end(last), re(*p), flags(f)
29     {
30        for(std::size_t i = 0; i < CN; ++i)
31        {
32           subs.push_back(submatches[i]);
33        }
34     }
35     bool init(BidirectionalIterator first)
36     {
37        base = first;
38        N = 0;
39        if(u32regex_search(first, end, what, re, flags, base) == true)
40        {
41           N = 0;
42           result = ((subs[N] == -1) ? what.prefix() : what[(int)subs[N]]);
43           return true;
44        }
45        else if((subs[N] == -1) && (first != end))
46        {
47           result.first = first;
48           result.second = end;
49           result.matched = (first != end);
50           N = -1;
51           return true;
52        }
53        return false;
54     }
55     bool compare(const u32regex_token_iterator_implementation& that)
56     {
57        if(this == &that) return true;
58        return (&re.get_data() == &that.re.get_data()) 
59           && (end == that.end) 
60           && (flags == that.flags) 
61           && (N == that.N) 
62           && (what[0].first == that.what[0].first) 
63           && (what[0].second == that.what[0].second);
64     }
65     const value_type& get()
66     { return result; }
67     bool next()
68     {
69        if(N == -1)
70           return false;
71        if(N+1 < (int)subs.size())
72        {
73           ++N;
74           result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
75           return true;
76        }
77        BidirectionalIterator last_end(what[0].second);
78        if(u32regex_search(last_end, end, what, re, ((what[0].first == what[0].second) ? flags | regex_constants::match_not_initial_null : flags), base))
79        {
80           N =0;
81           result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
82           return true;
83        }
84        else if((last_end != end) && (subs[0] == -1))
85        {
86           N =-1;
87           result.first = last_end;
88           result.second = end;
89           result.matched = (last_end != end);
90           return true;
91        }
92        return false;
93     }
94  private:
95     u32regex_token_iterator_implementation& operator=(const u32regex_token_iterator_implementation&);
96  };
97  template <class BidirectionalIterator>
98  class u32regex_token_iterator 
99  {
100  private:
101     typedef u32regex_token_iterator_implementation<BidirectionalIterator> impl;
102     typedef std::shared_ptr<impl> pimpl;
103  public:
104     typedef          u32regex                                                regex_type;
105     typedef          sub_match<BidirectionalIterator>                        value_type;
106     typedef typename std::iterator_traits<BidirectionalIterator>::difference_type 
107                                                                              difference_type;
108     typedef          const value_type*                                       pointer;
109     typedef          const value_type&                                       reference; 
110     typedef          std::forward_iterator_tag                               iterator_category;
111     u32regex_token_iterator(){}
112     u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, 
113                          int submatch = 0, match_flag_type m = match_default)
114                          : pdata(new impl(&re, b, submatch, m))
115     {
116        if(!pdata->init(a))
117           pdata.reset();
118     }
119     u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re, 
120                          const std::vector<int>& submatches, match_flag_type m = match_default)
121                          : pdata(new impl(&re, b, submatches, m))
122     {
123        if(!pdata->init(a))
124           pdata.reset();
125     }
126     template <std::size_t N>
127     u32regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type& re,
128                          const int (&submatches)[N], match_flag_type m = match_default)
129                          : pdata(new impl(&re, b, submatches, m))
130     {
131        if(!pdata->init(a))
132           pdata.reset();
133     }
134     u32regex_token_iterator(const u32regex_token_iterator& that)
135        : pdata(that.pdata) {}
136     u32regex_token_iterator& operator=(const u32regex_token_iterator& that)
137     {
138        pdata = that.pdata;
139        return *this;
140     }
141     bool operator==(const u32regex_token_iterator& that)const
142     { 
143        if((pdata.get() == 0) || (that.pdata.get() == 0))
144           return pdata.get() == that.pdata.get();
145        return pdata->compare(*(that.pdata.get())); 
146     }
147     bool operator!=(const u32regex_token_iterator& that)const
148     { return !(*this == that); }
149     const value_type& operator*()const
150     { return pdata->get(); }
151     const value_type* operator->()const
152     { return &(pdata->get()); }
153     u32regex_token_iterator& operator++()
154     {
155        cow();
156        if(0 == pdata->next())
157        {
158           pdata.reset();
159        }
160        return *this;
161     }
162     u32regex_token_iterator operator++(int)
163     {
164        u32regex_token_iterator result(*this);
165        ++(*this);
166        return result;
167     }
168  private:
169     pimpl pdata;
170     void cow()
171     {
172        if(pdata.get() && (pdata.use_count() > 1))
173        {
174           pdata.reset(new impl(*(pdata.get())));
175        }
176     }
177  };
178  typedef u32regex_token_iterator<const char*> utf8regex_token_iterator;
179  typedef u32regex_token_iterator<const UChar*> utf16regex_token_iterator;
180  typedef u32regex_token_iterator<const UChar32*> utf32regex_token_iterator;
181  inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
182  {
183     return u32regex_token_iterator<const char*>(p, p+std::strlen(p), e, submatch, m);
184  }
185  #ifndef BOOST_NO_WREGEX
186  inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
187  {
188     return u32regex_token_iterator<const wchar_t*>(p, p+std::wcslen(p), e, submatch, m);
189  }
190  #endif
191  #if !defined(BOOST_REGEX_UCHAR_IS_WCHAR_T)
192  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
193  {
194     return u32regex_token_iterator<const UChar*>(p, p+u_strlen(p), e, submatch, m);
195  }
196  #endif
197  template <class charT, class Traits, class Alloc>
198  inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
199  {
200     typedef typename std::basic_string<charT, Traits, Alloc>::const_iterator iter_type;
<span onclick='openModal()' class='match'>201     return u32regex_token_iterator<iter_type>(p.begin(), p.end(), e, submatch, m);
202  }
203  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
</span>204  {
205     return u32regex_token_iterator<const UChar*>(s.getBuffer(), s.getBuffer() + s.length(), e, submatch, m);
206  }
207  template <std::size_t N>
208  inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
209  {
210     return u32regex_token_iterator<const char*>(p, p+std::strlen(p), e, submatch, m);
211  }
212  #ifndef BOOST_NO_WREGEX
213  template <std::size_t N>
214  inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
215  {
216     return u32regex_token_iterator<const wchar_t*>(p, p+std::wcslen(p), e, submatch, m);
217  }
218  #endif
219  #if !defined(BOOST_REGEX_UCHAR_IS_WCHAR_T)
220  template <std::size_t N>
221  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
222  {
223     return u32regex_token_iterator<const UChar*>(p, p+u_strlen(p), e, submatch, m);
224  }
225  #endif
226  template <class charT, class Traits, class Alloc, std::size_t N>
227  inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
228  {
229     typedef typename std::basic_string<charT, Traits, Alloc>::const_iterator iter_type;
230     return u32regex_token_iterator<iter_type>(p.begin(), p.end(), e, submatch, m);
231  }
232  template <std::size_t N>
233  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const int (&submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
234  {
235     return u32regex_token_iterator<const UChar*>(s.getBuffer(), s.getBuffer() + s.length(), e, submatch, m);
236  }
237  inline u32regex_token_iterator<const char*> make_u32regex_token_iterator(const char* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
238  {
239     return u32regex_token_iterator<const char*>(p, p+std::strlen(p), e, submatch, m);
240  }
241  #ifndef BOOST_NO_WREGEX
242  inline u32regex_token_iterator<const wchar_t*> make_u32regex_token_iterator(const wchar_t* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
243  {
244     return u32regex_token_iterator<const wchar_t*>(p, p+std::wcslen(p), e, submatch, m);
245  }
246  #endif
247  #if !defined(U_WCHAR_IS_UTF16) && (U_SIZEOF_WCHAR_T != 2)
248  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const UChar* p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
249  {
250     return u32regex_token_iterator<const UChar*>(p, p+u_strlen(p), e, submatch, m);
251  }
252  #endif
253  template <class charT, class Traits, class Alloc>
254  inline u32regex_token_iterator<typename std::basic_string<charT, Traits, Alloc>::const_iterator> make_u32regex_token_iterator(const std::basic_string<charT, Traits, Alloc>& p, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
255  {
256     typedef typename std::basic_string<charT, Traits, Alloc>::const_iterator iter_type;
257     return u32regex_token_iterator<iter_type>(p.begin(), p.end(), e, submatch, m);
258  }
259  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, const std::vector<int>& submatch, regex_constants::match_flag_type m = regex_constants::match_default)
260  {
261     return u32regex_token_iterator<const UChar*>(s.getBuffer(), s.getBuffer() + s.length(), e, submatch, m);
262  }
263  #ifdef BOOST_REGEX_MSVC
264  #  pragma warning(pop)
265  #endif
266  } 
267  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_detail.h</h3>
            <pre><code>1  #ifndef ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
2  #define ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
3  #include <cstdint>
4  #include <limits>
5  #include <ostream>
6  #include <type_traits>
7  #include "absl/base/config.h"
8  #if __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)
9  #define CONSTEXPR_D constexpr  
10  #define CONSTEXPR_F constexpr  
11  #define CONSTEXPR_M constexpr  
12  #else
13  #define CONSTEXPR_D const
14  #define CONSTEXPR_F inline
15  #define CONSTEXPR_M
16  #endif
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace time_internal {
20  namespace cctz {
21  using year_t = std::int_fast64_t;
22  using diff_t = std::int_fast64_t;
23  namespace detail {
24  using month_t = std::int_fast8_t;   
25  using day_t = std::int_fast8_t;     
26  using hour_t = std::int_fast8_t;    
27  using minute_t = std::int_fast8_t;  
28  using second_t = std::int_fast8_t;  
29  struct fields {
30    CONSTEXPR_M fields(year_t year, month_t month, day_t day, hour_t hour,
31                       minute_t minute, second_t second)
32        : y(year), m(month), d(day), hh(hour), mm(minute), ss(second) {}
33    std::int_least64_t y;
34    std::int_least8_t m;
35    std::int_least8_t d;
36    std::int_least8_t hh;
37    std::int_least8_t mm;
38    std::int_least8_t ss;
39  };
40  struct second_tag {};
41  struct minute_tag : second_tag {};
42  struct hour_tag : minute_tag {};
43  struct day_tag : hour_tag {};
44  struct month_tag : day_tag {};
45  struct year_tag : month_tag {};
46  namespace impl {
47  CONSTEXPR_F bool is_leap_year(year_t y) noexcept {
48    return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
49  }
50  CONSTEXPR_F int year_index(year_t y, month_t m) noexcept {
51    const int yi = static_cast<int>((y + (m > 2)) % 400);
52    return yi < 0 ? yi + 400 : yi;
53  }
54  CONSTEXPR_F int days_per_century(int yi) noexcept {
55    return 36524 + (yi == 0 || yi > 300);
56  }
57  CONSTEXPR_F int days_per_4years(int yi) noexcept {
58    return 1460 + (yi == 0 || yi > 300 || (yi - 1) % 100 < 96);
59  }
60  CONSTEXPR_F int days_per_year(year_t y, month_t m) noexcept {
61    return is_leap_year(y + (m > 2)) ? 366 : 365;
62  }
63  CONSTEXPR_F int days_per_month(year_t y, month_t m) noexcept {
64    CONSTEXPR_D int k_days_per_month[1 + 12] = {
65        -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  
66    };
67    return k_days_per_month[m] + (m == 2 && is_leap_year(y));
68  }
69  CONSTEXPR_F fields n_day(year_t y, month_t m, diff_t d, diff_t cd, hour_t hh,
70                           minute_t mm, second_t ss) noexcept {
71    year_t ey = y % 400;
72    const year_t oey = ey;
73    ey += (cd / 146097) * 400;
74    cd %= 146097;
75    if (cd < 0) {
76      ey -= 400;
77      cd += 146097;
78    }
79    ey += (d / 146097) * 400;
80    d = d % 146097 + cd;
81    if (d > 0) {
82      if (d > 146097) {
83        ey += 400;
84        d -= 146097;
85      }
86    } else {
87      if (d > -365) {
88        ey -= 1;
89        d += days_per_year(ey, m);
90      } else {
91        ey -= 400;
92        d += 146097;
93      }
94    }
95    if (d > 365) {
96      int yi = year_index(ey, m);  
97      for (;;) {
98        int n = days_per_century(yi);
99        if (d <= n) break;
100        d -= n;
101        ey += 100;
102        yi += 100;
103        if (yi >= 400) yi -= 400;
104      }
105      for (;;) {
106        int n = days_per_4years(yi);
107        if (d <= n) break;
108        d -= n;
109        ey += 4;
110        yi += 4;
111        if (yi >= 400) yi -= 400;
112      }
113      for (;;) {
114        int n = days_per_year(ey, m);
115        if (d <= n) break;
116        d -= n;
117        ++ey;
118      }
119    }
120    if (d > 28) {
121      for (;;) {
122        int n = days_per_month(ey, m);
123        if (d <= n) break;
124        d -= n;
125        if (++m > 12) {
126          ++ey;
127          m = 1;
128        }
129      }
130    }
131    return fields(y + (ey - oey), m, static_cast<day_t>(d), hh, mm, ss);
132  }
133  CONSTEXPR_F fields n_mon(year_t y, diff_t m, diff_t d, diff_t cd, hour_t hh,
134                           minute_t mm, second_t ss) noexcept {
135    if (m != 12) {
136      y += m / 12;
137      m %= 12;
138      if (m <= 0) {
139        y -= 1;
140        m += 12;
141      }
142    }
<span onclick='openModal()' class='match'>143    return n_day(y, static_cast<month_t>(m), d, cd, hh, mm, ss);
144  }
145  CONSTEXPR_F fields n_hour(year_t y, diff_t m, diff_t d, diff_t cd, diff_t hh,
</span>146                            minute_t mm, second_t ss) noexcept {
147    cd += hh / 24;
148    hh %= 24;
149    if (hh < 0) {
150      cd -= 1;
151      hh += 24;
152    }
153    return n_mon(y, m, d, cd, static_cast<hour_t>(hh), mm, ss);
154  }
155  CONSTEXPR_F fields n_min(year_t y, diff_t m, diff_t d, diff_t hh, diff_t ch,
156                           diff_t mm, second_t ss) noexcept {
157    ch += mm / 60;
158    mm %= 60;
159    if (mm < 0) {
160      ch -= 1;
161      mm += 60;
162    }
163    return n_hour(y, m, d, hh / 24 + ch / 24, hh % 24 + ch % 24,
164                  static_cast<minute_t>(mm), ss);
165  }
166  CONSTEXPR_F fields n_sec(year_t y, diff_t m, diff_t d, diff_t hh, diff_t mm,
167                           diff_t ss) noexcept {
168    if (0 <= ss && ss < 60) {
169      const second_t nss = static_cast<second_t>(ss);
170      if (0 <= mm && mm < 60) {
171        const minute_t nmm = static_cast<minute_t>(mm);
172        if (0 <= hh && hh < 24) {
173          const hour_t nhh = static_cast<hour_t>(hh);
174          if (1 <= d && d <= 28 && 1 <= m && m <= 12) {
175            const day_t nd = static_cast<day_t>(d);
176            const month_t nm = static_cast<month_t>(m);
177            return fields(y, nm, nd, nhh, nmm, nss);
178          }
179          return n_mon(y, m, d, 0, nhh, nmm, nss);
180        }
181        return n_hour(y, m, d, hh / 24, hh % 24, nmm, nss);
182      }
183      return n_min(y, m, d, hh, mm / 60, mm % 60, nss);
184    }
185    diff_t cm = ss / 60;
186    ss %= 60;
187    if (ss < 0) {
188      cm -= 1;
189      ss += 60;
190    }
191    return n_min(y, m, d, hh, mm / 60 + cm / 60, mm % 60 + cm % 60,
192                 static_cast<second_t>(ss));
193  }
194  }  
195  CONSTEXPR_F fields step(second_tag, fields f, diff_t n) noexcept {
196    return impl::n_sec(f.y, f.m, f.d, f.hh, f.mm + n / 60, f.ss + n % 60);
197  }
198  CONSTEXPR_F fields step(minute_tag, fields f, diff_t n) noexcept {
199    return impl::n_min(f.y, f.m, f.d, f.hh + n / 60, 0, f.mm + n % 60, f.ss);
200  }
201  CONSTEXPR_F fields step(hour_tag, fields f, diff_t n) noexcept {
202    return impl::n_hour(f.y, f.m, f.d + n / 24, 0, f.hh + n % 24, f.mm, f.ss);
203  }
204  CONSTEXPR_F fields step(day_tag, fields f, diff_t n) noexcept {
205    return impl::n_day(f.y, f.m, f.d, n, f.hh, f.mm, f.ss);
206  }
207  CONSTEXPR_F fields step(month_tag, fields f, diff_t n) noexcept {
208    return impl::n_mon(f.y + n / 12, f.m + n % 12, f.d, 0, f.hh, f.mm, f.ss);
209  }
210  CONSTEXPR_F fields step(year_tag, fields f, diff_t n) noexcept {
211    return fields(f.y + n, f.m, f.d, f.hh, f.mm, f.ss);
212  }
213  namespace impl {
214  CONSTEXPR_F diff_t scale_add(diff_t v, diff_t f, diff_t a) noexcept {
215    return (v < 0) ? ((v + 1) * f + a) - f : ((v - 1) * f + a) + f;
216  }
217  CONSTEXPR_F diff_t ymd_ord(year_t y, month_t m, day_t d) noexcept {
218    const diff_t eyear = (m <= 2) ? y - 1 : y;
219    const diff_t era = (eyear >= 0 ? eyear : eyear - 399) / 400;
220    const diff_t yoe = eyear - era * 400;
221    const diff_t doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;
222    const diff_t doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
223    return era * 146097 + doe - 719468;
224  }
225  CONSTEXPR_F diff_t day_difference(year_t y1, month_t m1, day_t d1, year_t y2,
226                                    month_t m2, day_t d2) noexcept {
227    const diff_t a_c4_off = y1 % 400;
228    const diff_t b_c4_off = y2 % 400;
229    diff_t c4_diff = (y1 - a_c4_off) - (y2 - b_c4_off);
230    diff_t delta = ymd_ord(a_c4_off, m1, d1) - ymd_ord(b_c4_off, m2, d2);
231    if (c4_diff > 0 && delta < 0) {
232      delta += 2 * 146097;
233      c4_diff -= 2 * 400;
234    } else if (c4_diff < 0 && delta > 0) {
235      delta -= 2 * 146097;
236      c4_diff += 2 * 400;
237    }
238    return (c4_diff / 400 * 146097) + delta;
239  }
240  }  
241  CONSTEXPR_F diff_t difference(year_tag, fields f1, fields f2) noexcept {
242    return f1.y - f2.y;
243  }
244  CONSTEXPR_F diff_t difference(month_tag, fields f1, fields f2) noexcept {
245    return impl::scale_add(difference(year_tag{}, f1, f2), 12, (f1.m - f2.m));
246  }
247  CONSTEXPR_F diff_t difference(day_tag, fields f1, fields f2) noexcept {
248    return impl::day_difference(f1.y, f1.m, f1.d, f2.y, f2.m, f2.d);
249  }
250  CONSTEXPR_F diff_t difference(hour_tag, fields f1, fields f2) noexcept {
251    return impl::scale_add(difference(day_tag{}, f1, f2), 24, (f1.hh - f2.hh));
252  }
253  CONSTEXPR_F diff_t difference(minute_tag, fields f1, fields f2) noexcept {
254    return impl::scale_add(difference(hour_tag{}, f1, f2), 60, (f1.mm - f2.mm));
255  }
256  CONSTEXPR_F diff_t difference(second_tag, fields f1, fields f2) noexcept {
257    return impl::scale_add(difference(minute_tag{}, f1, f2), 60, f1.ss - f2.ss);
258  }
259  CONSTEXPR_F fields align(second_tag, fields f) noexcept { return f; }
260  CONSTEXPR_F fields align(minute_tag, fields f) noexcept {
261    return fields{f.y, f.m, f.d, f.hh, f.mm, 0};
262  }
263  CONSTEXPR_F fields align(hour_tag, fields f) noexcept {
264    return fields{f.y, f.m, f.d, f.hh, 0, 0};
265  }
266  CONSTEXPR_F fields align(day_tag, fields f) noexcept {
267    return fields{f.y, f.m, f.d, 0, 0, 0};
268  }
269  CONSTEXPR_F fields align(month_tag, fields f) noexcept {
270    return fields{f.y, f.m, 1, 0, 0, 0};
271  }
272  CONSTEXPR_F fields align(year_tag, fields f) noexcept {
273    return fields{f.y, 1, 1, 0, 0, 0};
274  }
275  namespace impl {
276  template <typename H>
277  H AbslHashValueImpl(second_tag, H h, fields f) {
278    return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm, f.ss);
279  }
280  template <typename H>
281  H AbslHashValueImpl(minute_tag, H h, fields f) {
282    return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm);
283  }
284  template <typename H>
285  H AbslHashValueImpl(hour_tag, H h, fields f) {
286    return H::combine(std::move(h), f.y, f.m, f.d, f.hh);
287  }
288  template <typename H>
289  H AbslHashValueImpl(day_tag, H h, fields f) {
290    return H::combine(std::move(h), f.y, f.m, f.d);
291  }
292  template <typename H>
293  H AbslHashValueImpl(month_tag, H h, fields f) {
294    return H::combine(std::move(h), f.y, f.m);
295  }
296  template <typename H>
297  H AbslHashValueImpl(year_tag, H h, fields f) {
298    return H::combine(std::move(h), f.y);
299  }
300  }  
301  template <typename T>
302  class civil_time {
303   public:
304    explicit CONSTEXPR_M civil_time(year_t y, diff_t m = 1, diff_t d = 1,
305                                    diff_t hh = 0, diff_t mm = 0,
306                                    diff_t ss = 0) noexcept
307        : civil_time(impl::n_sec(y, m, d, hh, mm, ss)) {}
308    CONSTEXPR_M civil_time() noexcept : f_{1970, 1, 1, 0, 0, 0} {}
309    civil_time(const civil_time&) = default;
310    civil_time& operator=(const civil_time&) = default;
311    template <typename U, typename S>
312    using preserves_data =
313        typename std::enable_if<std::is_base_of<U, S>::value>::type;
314    template <typename U>
315    CONSTEXPR_M civil_time(const civil_time<U>& ct,
316                           preserves_data<T, U>* = nullptr) noexcept
317        : civil_time(ct.f_) {}
318    template <typename U>
319    explicit CONSTEXPR_M civil_time(const civil_time<U>& ct,
320                                    preserves_data<U, T>* = nullptr) noexcept
321        : civil_time(ct.f_) {}
322    static CONSTEXPR_F civil_time(max)() {
323      const auto max_year = (std::numeric_limits<std::int_least64_t>::max)();
324      return civil_time(max_year, 12, 31, 23, 59, 59);
325    }
326    static CONSTEXPR_F civil_time(min)() {
327      const auto min_year = (std::numeric_limits<std::int_least64_t>::min)();
328      return civil_time(min_year, 1, 1, 0, 0, 0);
329    }
330    CONSTEXPR_M year_t year() const noexcept { return f_.y; }
331    CONSTEXPR_M int month() const noexcept { return f_.m; }
332    CONSTEXPR_M int day() const noexcept { return f_.d; }
333    CONSTEXPR_M int hour() const noexcept { return f_.hh; }
334    CONSTEXPR_M int minute() const noexcept { return f_.mm; }
335    CONSTEXPR_M int second() const noexcept { return f_.ss; }
336    CONSTEXPR_M civil_time& operator+=(diff_t n) noexcept {
337      return *this = *this + n;
338    }
339    CONSTEXPR_M civil_time& operator-=(diff_t n) noexcept {
340      return *this = *this - n;
341    }
342    CONSTEXPR_M civil_time& operator++() noexcept { return *this += 1; }
343    CONSTEXPR_M civil_time operator++(int) noexcept {
344      const civil_time a = *this;
345      ++*this;
346      return a;
347    }
348    CONSTEXPR_M civil_time& operator--() noexcept { return *this -= 1; }
349    CONSTEXPR_M civil_time operator--(int) noexcept {
350      const civil_time a = *this;
351      --*this;
352      return a;
353    }
354    friend CONSTEXPR_F civil_time operator+(civil_time a, diff_t n) noexcept {
355      return civil_time(step(T{}, a.f_, n));
356    }
357    friend CONSTEXPR_F civil_time operator+(diff_t n, civil_time a) noexcept {
358      return a + n;
359    }
360    friend CONSTEXPR_F civil_time operator-(civil_time a, diff_t n) noexcept {
361      return n != (std::numeric_limits<diff_t>::min)()
362                 ? civil_time(step(T{}, a.f_, -n))
363                 : civil_time(step(T{}, step(T{}, a.f_, -(n + 1)), 1));
364    }
365    friend CONSTEXPR_F diff_t operator-(civil_time lhs, civil_time rhs) noexcept {
366      return difference(T{}, lhs.f_, rhs.f_);
367    }
368    template <typename H>
369    friend H AbslHashValue(H h, civil_time a) {
370      return impl::AbslHashValueImpl(T{}, std::move(h), a.f_);
371    }
372   private:
373    template <typename U>
374    friend class civil_time;
375    explicit CONSTEXPR_M civil_time(fields f) noexcept : f_(align(T{}, f)) {}
376    fields f_;
377  };
378  template <typename T, typename U>
379  CONSTEXPR_F diff_t operator-(civil_time<T>, civil_time<U>) = delete;
380  using civil_year = civil_time<year_tag>;
381  using civil_month = civil_time<month_tag>;
382  using civil_day = civil_time<day_tag>;
383  using civil_hour = civil_time<hour_tag>;
384  using civil_minute = civil_time<minute_tag>;
385  using civil_second = civil_time<second_tag>;
386  template <typename T1, typename T2>
387  CONSTEXPR_F bool operator<(const civil_time<T1>& lhs,
388                             const civil_time<T2>& rhs) noexcept {
389    return (
390        lhs.year() < rhs.year() ||
391        (lhs.year() == rhs.year() &&
392         (lhs.month() < rhs.month() ||
393          (lhs.month() == rhs.month() &&
394           (lhs.day() < rhs.day() || (lhs.day() == rhs.day() &&
395                                      (lhs.hour() < rhs.hour() ||
396                                       (lhs.hour() == rhs.hour() &&
397                                        (lhs.minute() < rhs.minute() ||
398                                         (lhs.minute() == rhs.minute() &&
399                                          (lhs.second() < rhs.second())))))))))));
400  }
401  template <typename T1, typename T2>
402  CONSTEXPR_F bool operator<=(const civil_time<T1>& lhs,
403                              const civil_time<T2>& rhs) noexcept {
404    return !(rhs < lhs);
405  }
406  template <typename T1, typename T2>
407  CONSTEXPR_F bool operator>=(const civil_time<T1>& lhs,
408                              const civil_time<T2>& rhs) noexcept {
409    return !(lhs < rhs);
410  }
411  template <typename T1, typename T2>
412  CONSTEXPR_F bool operator>(const civil_time<T1>& lhs,
413                             const civil_time<T2>& rhs) noexcept {
414    return rhs < lhs;
415  }
416  template <typename T1, typename T2>
417  CONSTEXPR_F bool operator==(const civil_time<T1>& lhs,
418                              const civil_time<T2>& rhs) noexcept {
419    return lhs.year() == rhs.year() && lhs.month() == rhs.month() &&
420           lhs.day() == rhs.day() && lhs.hour() == rhs.hour() &&
421           lhs.minute() == rhs.minute() && lhs.second() == rhs.second();
422  }
423  template <typename T1, typename T2>
424  CONSTEXPR_F bool operator!=(const civil_time<T1>& lhs,
425                              const civil_time<T2>& rhs) noexcept {
426    return !(lhs == rhs);
427  }
428  enum class weekday {
429    monday,
430    tuesday,
431    wednesday,
432    thursday,
433    friday,
434    saturday,
435    sunday,
436  };
437  CONSTEXPR_F weekday get_weekday(const civil_second& cs) noexcept {
438    CONSTEXPR_D weekday k_weekday_by_mon_off[13] = {
439        weekday::monday,    weekday::tuesday,  weekday::wednesday,
440        weekday::thursday,  weekday::friday,   weekday::saturday,
441        weekday::sunday,    weekday::monday,   weekday::tuesday,
442        weekday::wednesday, weekday::thursday, weekday::friday,
443        weekday::saturday,
444    };
445    CONSTEXPR_D int k_weekday_offsets[1 + 12] = {
446        -1, 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4,
447    };
448    year_t wd = 2400 + (cs.year() % 400) - (cs.month() < 3);
449    wd += wd / 4 - wd / 100 + wd / 400;
450    wd += k_weekday_offsets[cs.month()] + cs.day();
451    return k_weekday_by_mon_off[wd % 7 + 6];
452  }
453  CONSTEXPR_F civil_day next_weekday(civil_day cd, weekday wd) noexcept {
454    CONSTEXPR_D weekday k_weekdays_forw[14] = {
455        weekday::monday,    weekday::tuesday,  weekday::wednesday,
456        weekday::thursday,  weekday::friday,   weekday::saturday,
457        weekday::sunday,    weekday::monday,   weekday::tuesday,
458        weekday::wednesday, weekday::thursday, weekday::friday,
459        weekday::saturday,  weekday::sunday,
460    };
461    weekday base = get_weekday(cd);
462    for (int i = 0;; ++i) {
463      if (base == k_weekdays_forw[i]) {
464        for (int j = i + 1;; ++j) {
465          if (wd == k_weekdays_forw[j]) {
466            return cd + (j - i);
467          }
468        }
469      }
470    }
471  }
472  CONSTEXPR_F civil_day prev_weekday(civil_day cd, weekday wd) noexcept {
473    CONSTEXPR_D weekday k_weekdays_back[14] = {
474        weekday::sunday,   weekday::saturday,  weekday::friday,
475        weekday::thursday, weekday::wednesday, weekday::tuesday,
476        weekday::monday,   weekday::sunday,    weekday::saturday,
477        weekday::friday,   weekday::thursday,  weekday::wednesday,
478        weekday::tuesday,  weekday::monday,
479    };
480    weekday base = get_weekday(cd);
481    for (int i = 0;; ++i) {
482      if (base == k_weekdays_back[i]) {
483        for (int j = i + 1;; ++j) {
484          if (wd == k_weekdays_back[j]) {
485            return cd - (j - i);
486          }
487        }
488      }
489    }
490  }
491  CONSTEXPR_F int get_yearday(const civil_second& cs) noexcept {
492    CONSTEXPR_D int k_month_offsets[1 + 12] = {
493        -1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
494    };
495    const int feb29 = (cs.month() > 2 && impl::is_leap_year(cs.year()));
496    return k_month_offsets[cs.month()] + feb29 + cs.day();
497  }
498  std::ostream& operator<<(std::ostream& os, const civil_year& y);
499  std::ostream& operator<<(std::ostream& os, const civil_month& m);
500  std::ostream& operator<<(std::ostream& os, const civil_day& d);
501  std::ostream& operator<<(std::ostream& os, const civil_hour& h);
502  std::ostream& operator<<(std::ostream& os, const civil_minute& m);
503  std::ostream& operator<<(std::ostream& os, const civil_second& s);
504  std::ostream& operator<<(std::ostream& os, weekday wd);
505  }  
506  }  
507  }  
508  ABSL_NAMESPACE_END
509  }  
510  #undef CONSTEXPR_M
511  #undef CONSTEXPR_F
512  #undef CONSTEXPR_D
513  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-u32regex_token_iterator.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_detail.h</div>
                </div>
                <div class="column column_space"><pre><code>201     return u32regex_token_iterator<iter_type>(p.begin(), p.end(), e, submatch, m);
202  }
203  inline u32regex_token_iterator<const UChar*> make_u32regex_token_iterator(const U_NAMESPACE_QUALIFIER UnicodeString& s, const u32regex& e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
</pre></code></div>
                <div class="column column_space"><pre><code>143    return n_day(y, static_cast<month_t>(m), d, cd, hh, mm, ss);
144  }
145  CONSTEXPR_F fields n_hour(year_t y, diff_t m, diff_t d, diff_t cd, diff_t hh,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    