
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.339641770868537%, Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_test_17.cc</h3>
            <pre><code>1  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
2  #include <iomanip>
3  #include <limits>
4  #include <sstream>
5  #include <string>
6  #include <type_traits>
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  namespace absl {
10  ABSL_NAMESPACE_BEGIN
11  namespace time_internal {
12  namespace cctz {
13  namespace {
14  template <typename T>
15  std::string Format(const T& t) {
16    std::stringstream ss;
17    ss << t;
18    return ss.str();
19  }
20  }  
21  #if __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)
22  TEST(CivilTime, Normal) {
23    constexpr civil_second css(2016, 1, 28, 17, 14, 12);
24    static_assert(css.second() == 12, "Normal.second");
25    constexpr civil_minute cmm(2016, 1, 28, 17, 14);
26    static_assert(cmm.minute() == 14, "Normal.minute");
27    constexpr civil_hour chh(2016, 1, 28, 17);
28    static_assert(chh.hour() == 17, "Normal.hour");
29    constexpr civil_day cd(2016, 1, 28);
30    static_assert(cd.day() == 28, "Normal.day");
31    constexpr civil_month cm(2016, 1);
32    static_assert(cm.month() == 1, "Normal.month");
33    constexpr civil_year cy(2016);
34    static_assert(cy.year() == 2016, "Normal.year");
35  }
36  TEST(CivilTime, Conversion) {
37    constexpr civil_year cy(2016);
38    static_assert(cy.year() == 2016, "Conversion.year");
39    constexpr civil_month cm(cy);
40    static_assert(cm.month() == 1, "Conversion.month");
41    constexpr civil_day cd(cm);
42    static_assert(cd.day() == 1, "Conversion.day");
43    constexpr civil_hour chh(cd);
44    static_assert(chh.hour() == 0, "Conversion.hour");
45    constexpr civil_minute cmm(chh);
46    static_assert(cmm.minute() == 0, "Conversion.minute");
47    constexpr civil_second css(cmm);
48    static_assert(css.second() == 0, "Conversion.second");
49  }
50  TEST(CivilTime, Normalized) {
51    constexpr civil_second cs(2016, 1, 28, 17, 14, 12);
52    static_assert(cs.year() == 2016, "Normalized.year");
53    static_assert(cs.month() == 1, "Normalized.month");
54    static_assert(cs.day() == 28, "Normalized.day");
55    static_assert(cs.hour() == 17, "Normalized.hour");
56    static_assert(cs.minute() == 14, "Normalized.minute");
57    static_assert(cs.second() == 12, "Normalized.second");
58  }
59  TEST(CivilTime, SecondOverflow) {
60    constexpr civil_second cs(2016, 1, 28, 17, 14, 121);
61    static_assert(cs.year() == 2016, "SecondOverflow.year");
62    static_assert(cs.month() == 1, "SecondOverflow.month");
63    static_assert(cs.day() == 28, "SecondOverflow.day");
64    static_assert(cs.hour() == 17, "SecondOverflow.hour");
65    static_assert(cs.minute() == 16, "SecondOverflow.minute");
66    static_assert(cs.second() == 1, "SecondOverflow.second");
67  }
68  TEST(CivilTime, SecondUnderflow) {
69    constexpr civil_second cs(2016, 1, 28, 17, 14, -121);
70    static_assert(cs.year() == 2016, "SecondUnderflow.year");
71    static_assert(cs.month() == 1, "SecondUnderflow.month");
72    static_assert(cs.day() == 28, "SecondUnderflow.day");
73    static_assert(cs.hour() == 17, "SecondUnderflow.hour");
74    static_assert(cs.minute() == 11, "SecondUnderflow.minute");
75    static_assert(cs.second() == 59, "SecondUnderflow.second");
76  }
77  TEST(CivilTime, MinuteOverflow) {
78    constexpr civil_second cs(2016, 1, 28, 17, 121, 12);
79    static_assert(cs.year() == 2016, "MinuteOverflow.year");
80    static_assert(cs.month() == 1, "MinuteOverflow.month");
81    static_assert(cs.day() == 28, "MinuteOverflow.day");
82    static_assert(cs.hour() == 19, "MinuteOverflow.hour");
83    static_assert(cs.minute() == 1, "MinuteOverflow.minute");
84    static_assert(cs.second() == 12, "MinuteOverflow.second");
85  }
86  TEST(CivilTime, MinuteUnderflow) {
87    constexpr civil_second cs(2016, 1, 28, 17, -121, 12);
88    static_assert(cs.year() == 2016, "MinuteUnderflow.year");
89    static_assert(cs.month() == 1, "MinuteUnderflow.month");
90    static_assert(cs.day() == 28, "MinuteUnderflow.day");
91    static_assert(cs.hour() == 14, "MinuteUnderflow.hour");
92    static_assert(cs.minute() == 59, "MinuteUnderflow.minute");
93    static_assert(cs.second() == 12, "MinuteUnderflow.second");
94  }
95  TEST(CivilTime, HourOverflow) {
96    constexpr civil_second cs(2016, 1, 28, 49, 14, 12);
97    static_assert(cs.year() == 2016, "HourOverflow.year");
98    static_assert(cs.month() == 1, "HourOverflow.month");
99    static_assert(cs.day() == 30, "HourOverflow.day");
100    static_assert(cs.hour() == 1, "HourOverflow.hour");
101    static_assert(cs.minute() == 14, "HourOverflow.minute");
102    static_assert(cs.second() == 12, "HourOverflow.second");
103  }
104  TEST(CivilTime, HourUnderflow) {
105    constexpr civil_second cs(2016, 1, 28, -49, 14, 12);
106    static_assert(cs.year() == 2016, "HourUnderflow.year");
107    static_assert(cs.month() == 1, "HourUnderflow.month");
108    static_assert(cs.day() == 25, "HourUnderflow.day");
109    static_assert(cs.hour() == 23, "HourUnderflow.hour");
110    static_assert(cs.minute() == 14, "HourUnderflow.minute");
111    static_assert(cs.second() == 12, "HourUnderflow.second");
112  }
113  TEST(CivilTime, MonthOverflow) {
114    constexpr civil_second cs(2016, 25, 28, 17, 14, 12);
115    static_assert(cs.year() == 2018, "MonthOverflow.year");
116    static_assert(cs.month() == 1, "MonthOverflow.month");
117    static_assert(cs.day() == 28, "MonthOverflow.day");
118    static_assert(cs.hour() == 17, "MonthOverflow.hour");
119    static_assert(cs.minute() == 14, "MonthOverflow.minute");
120    static_assert(cs.second() == 12, "MonthOverflow.second");
121  }
122  TEST(CivilTime, MonthUnderflow) {
123    constexpr civil_second cs(2016, -25, 28, 17, 14, 12);
124    static_assert(cs.year() == 2013, "MonthUnderflow.year");
125    static_assert(cs.month() == 11, "MonthUnderflow.month");
126    static_assert(cs.day() == 28, "MonthUnderflow.day");
127    static_assert(cs.hour() == 17, "MonthUnderflow.hour");
128    static_assert(cs.minute() == 14, "MonthUnderflow.minute");
129    static_assert(cs.second() == 12, "MonthUnderflow.second");
130  }
131  TEST(CivilTime, C4Overflow) {
132    constexpr civil_second cs(2016, 1, 292195, 17, 14, 12);
133    static_assert(cs.year() == 2816, "C4Overflow.year");
134    static_assert(cs.month() == 1, "C4Overflow.month");
135    static_assert(cs.day() == 1, "C4Overflow.day");
136    static_assert(cs.hour() == 17, "C4Overflow.hour");
137    static_assert(cs.minute() == 14, "C4Overflow.minute");
138    static_assert(cs.second() == 12, "C4Overflow.second");
139  }
140  TEST(CivilTime, C4Underflow) {
141    constexpr civil_second cs(2016, 1, -292195, 17, 14, 12);
142    static_assert(cs.year() == 1215, "C4Underflow.year");
143    static_assert(cs.month() == 12, "C4Underflow.month");
144    static_assert(cs.day() == 30, "C4Underflow.day");
145    static_assert(cs.hour() == 17, "C4Underflow.hour");
146    static_assert(cs.minute() == 14, "C4Underflow.minute");
147    static_assert(cs.second() == 12, "C4Underflow.second");
148  }
149  TEST(CivilTime, MixedNormalization) {
150    constexpr civil_second cs(2016, -42, 122, 99, -147, 4949);
151    static_assert(cs.year() == 2012, "MixedNormalization.year");
152    static_assert(cs.month() == 10, "MixedNormalization.month");
153    static_assert(cs.day() == 4, "MixedNormalization.day");
154    static_assert(cs.hour() == 1, "MixedNormalization.hour");
155    static_assert(cs.minute() == 55, "MixedNormalization.minute");
156    static_assert(cs.second() == 29, "MixedNormalization.second");
157  }
158  TEST(CivilTime, Less) {
159    constexpr civil_second cs1(2016, 1, 28, 17, 14, 12);
160    constexpr civil_second cs2(2016, 1, 28, 17, 14, 13);
161    constexpr bool less = cs1 < cs2;
162    static_assert(less, "Less");
163  }
164  TEST(CivilTime, Addition) {
165    constexpr civil_second cs1(2016, 1, 28, 17, 14, 12);
166    constexpr civil_second cs2 = cs1 + 50;
167    static_assert(cs2.year() == 2016, "Addition.year");
168    static_assert(cs2.month() == 1, "Addition.month");
169    static_assert(cs2.day() == 28, "Addition.day");
170    static_assert(cs2.hour() == 17, "Addition.hour");
171    static_assert(cs2.minute() == 15, "Addition.minute");
172    static_assert(cs2.second() == 2, "Addition.second");
173  }
174  TEST(CivilTime, Subtraction) {
175    constexpr civil_second cs1(2016, 1, 28, 17, 14, 12);
176    constexpr civil_second cs2 = cs1 - 50;
177    static_assert(cs2.year() == 2016, "Subtraction.year");
178    static_assert(cs2.month() == 1, "Subtraction.month");
179    static_assert(cs2.day() == 28, "Subtraction.day");
180    static_assert(cs2.hour() == 17, "Subtraction.hour");
181    static_assert(cs2.minute() == 13, "Subtraction.minute");
182    static_assert(cs2.second() == 22, "Subtraction.second");
183  }
184  TEST(CivilTime, Difference) {
185    constexpr civil_day cd1(2016, 1, 28);
186    constexpr civil_day cd2(2015, 1, 28);
187    constexpr int diff = cd1 - cd2;
188    static_assert(diff == 365, "Difference");
189  }
190  TEST(CivilTime, ConstructionWithHugeYear) {
191    constexpr civil_hour h(-9223372036854775807, 1, 1, -1);
192    static_assert(h.year() == -9223372036854775807 - 1,
193                  "ConstructionWithHugeYear");
194    static_assert(h.month() == 12, "ConstructionWithHugeYear");
195    static_assert(h.day() == 31, "ConstructionWithHugeYear");
196    static_assert(h.hour() == 23, "ConstructionWithHugeYear");
197  }
198  TEST(CivilTime, DifferenceWithHugeYear) {
199    {
200      constexpr civil_day d1(9223372036854775807, 1, 1);
201      constexpr civil_day d2(9223372036854775807, 12, 31);
202      static_assert(d2 - d1 == 364, "DifferenceWithHugeYear");
203    }
204    {
205      constexpr civil_day d1(-9223372036854775807 - 1, 1, 1);
206      constexpr civil_day d2(-9223372036854775807 - 1, 12, 31);
207      static_assert(d2 - d1 == 365, "DifferenceWithHugeYear");
208    }
209    {
210      constexpr civil_day d1(9223372036854775807, 1, 1);
211      constexpr civil_day d2(9198119301927009252, 6, 6);
212      static_assert(d1 - d2 == 9223372036854775807, "DifferenceWithHugeYear");
213      static_assert((d2 - 1) - d1 == -9223372036854775807 - 1,
214                    "DifferenceWithHugeYear");
215    }
216    {
217      constexpr civil_day d1(-9223372036854775807 - 1, 1, 1);
218      constexpr civil_day d2(-9198119301927009254, 7, 28);
219      static_assert(d2 - d1 == 9223372036854775807, "DifferenceWithHugeYear");
220      static_assert(d1 - (d2 + 1) == -9223372036854775807 - 1,
221                    "DifferenceWithHugeYear");
222    }
223    {
224      constexpr civil_day d1(-12626367463883278, 9, 3);
225      constexpr civil_day d2(12626367463883277, 3, 28);
226      static_assert(d2 - d1 == 9223372036854775807, "DifferenceWithHugeYear");
227      static_assert(d1 - (d2 + 1) == -9223372036854775807 - 1,
228                    "DifferenceWithHugeYear");
229    }
230  }
231  TEST(CivilTime, DifferenceNoIntermediateOverflow) {
232    {
233      constexpr civil_second s1(-292277022657, 1, 27, 8, 29 - 1, 52);
234      constexpr civil_second s2(1970, 1, 1, 0, 0 - 1, 0);
235      static_assert(s1 - s2 == -9223372036854775807 - 1,
236                    "DifferenceNoIntermediateOverflow");
237    }
238    {
239      constexpr civil_second s1(292277026596, 12, 4, 15, 30, 7 - 7);
240      constexpr civil_second s2(1970, 1, 1, 0, 0, 0 - 7);
241      static_assert(s1 - s2 == 9223372036854775807,
242                    "DifferenceNoIntermediateOverflow");
243    }
244  }
245  TEST(CivilTime, WeekDay) {
246    constexpr civil_day cd(2016, 1, 28);
247    constexpr weekday wd = get_weekday(cd);
248    static_assert(wd == weekday::thursday, "Weekday");
249  }
250  TEST(CivilTime, NextWeekDay) {
251    constexpr civil_day cd(2016, 1, 28);
252    constexpr civil_day next = next_weekday(cd, weekday::thursday);
253    static_assert(next.year() == 2016, "NextWeekDay.year");
254    static_assert(next.month() == 2, "NextWeekDay.month");
255    static_assert(next.day() == 4, "NextWeekDay.day");
256  }
257  TEST(CivilTime, PrevWeekDay) {
258    constexpr civil_day cd(2016, 1, 28);
259    constexpr civil_day prev = prev_weekday(cd, weekday::thursday);
260    static_assert(prev.year() == 2016, "PrevWeekDay.year");
261    static_assert(prev.month() == 1, "PrevWeekDay.month");
262    static_assert(prev.day() == 21, "PrevWeekDay.day");
263  }
264  TEST(CivilTime, YearDay) {
265    constexpr civil_day cd(2016, 1, 28);
266    constexpr int yd = get_yearday(cd);
267    static_assert(yd == 28, "YearDay");
268  }
269  #endif  
270  TEST(CivilTime, DefaultConstruction) {
271    civil_second ss;
272    EXPECT_EQ("1970-01-01T00:00:00", Format(ss));
273    civil_minute mm;
274    EXPECT_EQ("1970-01-01T00:00", Format(mm));
275    civil_hour hh;
276    EXPECT_EQ("1970-01-01T00", Format(hh));
277    civil_day d;
278    EXPECT_EQ("1970-01-01", Format(d));
279    civil_month m;
280    EXPECT_EQ("1970-01", Format(m));
281    civil_year y;
282    EXPECT_EQ("1970", Format(y));
283  }
284  TEST(CivilTime, StructMember) {
285    struct S {
286      civil_day day;
287    };
288    S s = {};
289    EXPECT_EQ(civil_day{}, s.day);
290  }
291  TEST(CivilTime, FieldsConstruction) {
292    EXPECT_EQ("2015-01-02T03:04:05", Format(civil_second(2015, 1, 2, 3, 4, 5)));
293    EXPECT_EQ("2015-01-02T03:04:00", Format(civil_second(2015, 1, 2, 3, 4)));
294    EXPECT_EQ("2015-01-02T03:00:00", Format(civil_second(2015, 1, 2, 3)));
295    EXPECT_EQ("2015-01-02T00:00:00", Format(civil_second(2015, 1, 2)));
296    EXPECT_EQ("2015-01-01T00:00:00", Format(civil_second(2015, 1)));
297    EXPECT_EQ("2015-01-01T00:00:00", Format(civil_second(2015)));
298    EXPECT_EQ("2015-01-02T03:04", Format(civil_minute(2015, 1, 2, 3, 4, 5)));
299    EXPECT_EQ("2015-01-02T03:04", Format(civil_minute(2015, 1, 2, 3, 4)));
300    EXPECT_EQ("2015-01-02T03:00", Format(civil_minute(2015, 1, 2, 3)));
301    EXPECT_EQ("2015-01-02T00:00", Format(civil_minute(2015, 1, 2)));
302    EXPECT_EQ("2015-01-01T00:00", Format(civil_minute(2015, 1)));
303    EXPECT_EQ("2015-01-01T00:00", Format(civil_minute(2015)));
304    EXPECT_EQ("2015-01-02T03", Format(civil_hour(2015, 1, 2, 3, 4, 5)));
305    EXPECT_EQ("2015-01-02T03", Format(civil_hour(2015, 1, 2, 3, 4)));
306    EXPECT_EQ("2015-01-02T03", Format(civil_hour(2015, 1, 2, 3)));
307    EXPECT_EQ("2015-01-02T00", Format(civil_hour(2015, 1, 2)));
308    EXPECT_EQ("2015-01-01T00", Format(civil_hour(2015, 1)));
309    EXPECT_EQ("2015-01-01T00", Format(civil_hour(2015)));
310    EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2, 3, 4, 5)));
311    EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2, 3, 4)));
312    EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2, 3)));
313    EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2)));
314    EXPECT_EQ("2015-01-01", Format(civil_day(2015, 1)));
315    EXPECT_EQ("2015-01-01", Format(civil_day(2015)));
316    EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2, 3, 4, 5)));
317    EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2, 3, 4)));
318    EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2, 3)));
319    EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2)));
320    EXPECT_EQ("2015-01", Format(civil_month(2015, 1)));
321    EXPECT_EQ("2015-01", Format(civil_month(2015)));
322    EXPECT_EQ("2015", Format(civil_year(2015, 1, 2, 3, 4, 5)));
323    EXPECT_EQ("2015", Format(civil_year(2015, 1, 2, 3, 4)));
324    EXPECT_EQ("2015", Format(civil_year(2015, 1, 2, 3)));
325    EXPECT_EQ("2015", Format(civil_year(2015, 1, 2)));
326    EXPECT_EQ("2015", Format(civil_year(2015, 1)));
327    EXPECT_EQ("2015", Format(civil_year(2015)));
328  }
329  TEST(CivilTime, FieldsConstructionLimits) {
330    const int kIntMax = std::numeric_limits<int>::max();
331    EXPECT_EQ("2038-01-19T03:14:07",
332              Format(civil_second(1970, 1, 1, 0, 0, kIntMax)));
333    EXPECT_EQ("6121-02-11T05:21:07",
334              Format(civil_second(1970, 1, 1, 0, kIntMax, kIntMax)));
335    EXPECT_EQ("251104-11-20T12:21:07",
336              Format(civil_second(1970, 1, 1, kIntMax, kIntMax, kIntMax)));
337    EXPECT_EQ("6130715-05-30T12:21:07",
338              Format(civil_second(1970, 1, kIntMax, kIntMax, kIntMax, kIntMax)));
339    EXPECT_EQ(
340        "185087685-11-26T12:21:07",
341        Format(civil_second(1970, kIntMax, kIntMax, kIntMax, kIntMax, kIntMax)));
342    const int kIntMin = std::numeric_limits<int>::min();
343    EXPECT_EQ("1901-12-13T20:45:52",
344              Format(civil_second(1970, 1, 1, 0, 0, kIntMin)));
345    EXPECT_EQ("-2182-11-20T18:37:52",
346              Format(civil_second(1970, 1, 1, 0, kIntMin, kIntMin)));
347    EXPECT_EQ("-247165-02-11T10:37:52",
348              Format(civil_second(1970, 1, 1, kIntMin, kIntMin, kIntMin)));
349    EXPECT_EQ("-6126776-08-01T10:37:52",
350              Format(civil_second(1970, 1, kIntMin, kIntMin, kIntMin, kIntMin)));
351    EXPECT_EQ(
352        "-185083747-10-31T10:37:52",
353        Format(civil_second(1970, kIntMin, kIntMin, kIntMin, kIntMin, kIntMin)));
354  }
355  TEST(CivilTime, ImplicitCrossAlignment) {
356    civil_year year(2015);
357    civil_month month = year;
358    civil_day day = month;
359    civil_hour hour = day;
360    civil_minute minute = hour;
361    civil_second second = minute;
362    second = year;
363    EXPECT_EQ(second, year);
364    second = month;
365    EXPECT_EQ(second, month);
366    second = day;
367    EXPECT_EQ(second, day);
368    second = hour;
369    EXPECT_EQ(second, hour);
370    second = minute;
371    EXPECT_EQ(second, minute);
372    minute = year;
373    EXPECT_EQ(minute, year);
374    minute = month;
375    EXPECT_EQ(minute, month);
376    minute = day;
377    EXPECT_EQ(minute, day);
378    minute = hour;
379    EXPECT_EQ(minute, hour);
380    hour = year;
381    EXPECT_EQ(hour, year);
382    hour = month;
383    EXPECT_EQ(hour, month);
384    hour = day;
385    EXPECT_EQ(hour, day);
386    day = year;
387    EXPECT_EQ(day, year);
388    day = month;
389    EXPECT_EQ(day, month);
390    month = year;
391    EXPECT_EQ(month, year);
392    EXPECT_FALSE((std::is_convertible<civil_second, civil_minute>::value));
393    EXPECT_FALSE((std::is_convertible<civil_second, civil_hour>::value));
394    EXPECT_FALSE((std::is_convertible<civil_second, civil_day>::value));
395    EXPECT_FALSE((std::is_convertible<civil_second, civil_month>::value));
396    EXPECT_FALSE((std::is_convertible<civil_second, civil_year>::value));
397    EXPECT_FALSE((std::is_convertible<civil_minute, civil_hour>::value));
398    EXPECT_FALSE((std::is_convertible<civil_minute, civil_day>::value));
399    EXPECT_FALSE((std::is_convertible<civil_minute, civil_month>::value));
400    EXPECT_FALSE((std::is_convertible<civil_minute, civil_year>::value));
401    EXPECT_FALSE((std::is_convertible<civil_hour, civil_day>::value));
402    EXPECT_FALSE((std::is_convertible<civil_hour, civil_month>::value));
403    EXPECT_FALSE((std::is_convertible<civil_hour, civil_year>::value));
404    EXPECT_FALSE((std::is_convertible<civil_day, civil_month>::value));
405    EXPECT_FALSE((std::is_convertible<civil_day, civil_year>::value));
406    EXPECT_FALSE((std::is_convertible<civil_month, civil_year>::value));
407  }
408  TEST(CivilTime, ExplicitCrossAlignment) {
409    civil_second second(2015, 1, 2, 3, 4, 5);
410    EXPECT_EQ("2015-01-02T03:04:05", Format(second));
411    civil_minute minute(second);
412    EXPECT_EQ("2015-01-02T03:04", Format(minute));
413    civil_hour hour(minute);
414    EXPECT_EQ("2015-01-02T03", Format(hour));
415    civil_day day(hour);
416    EXPECT_EQ("2015-01-02", Format(day));
417    civil_month month(day);
418    EXPECT_EQ("2015-01", Format(month));
419    civil_year year(month);
420    EXPECT_EQ("2015", Format(year));
421    month = civil_month(year);
422    EXPECT_EQ("2015-01", Format(month));
423    day = civil_day(month);
424    EXPECT_EQ("2015-01-01", Format(day));
425    hour = civil_hour(day);
426    EXPECT_EQ("2015-01-01T00", Format(hour));
427    minute = civil_minute(hour);
428    EXPECT_EQ("2015-01-01T00:00", Format(minute));
429    second = civil_second(minute);
430    EXPECT_EQ("2015-01-01T00:00:00", Format(second));
431  }
432  template <typename T1, typename T2>
433  struct HasDifference {
434    template <typename U1, typename U2>
435    static std::false_type test(...);
436    template <typename U1, typename U2>
437    static std::true_type test(decltype(std::declval<U1>() - std::declval<U2>()));
438    static constexpr bool value = decltype(test<T1, T2>(0))::value;
439  };
440  TEST(CivilTime, DisallowCrossAlignedDifference) {
441    static_assert(HasDifference<civil_second, civil_second>::value, "");
442    static_assert(HasDifference<civil_minute, civil_minute>::value, "");
443    static_assert(HasDifference<civil_hour, civil_hour>::value, "");
444    static_assert(HasDifference<civil_day, civil_day>::value, "");
445    static_assert(HasDifference<civil_month, civil_month>::value, "");
446    static_assert(HasDifference<civil_year, civil_year>::value, "");
447    static_assert(!HasDifference<civil_second, civil_minute>::value, "");
448    static_assert(!HasDifference<civil_second, civil_hour>::value, "");
449    static_assert(!HasDifference<civil_second, civil_day>::value, "");
450    static_assert(!HasDifference<civil_second, civil_month>::value, "");
451    static_assert(!HasDifference<civil_second, civil_year>::value, "");
452    static_assert(!HasDifference<civil_minute, civil_hour>::value, "");
453    static_assert(!HasDifference<civil_minute, civil_day>::value, "");
454    static_assert(!HasDifference<civil_minute, civil_month>::value, "");
455    static_assert(!HasDifference<civil_minute, civil_year>::value, "");
456    static_assert(!HasDifference<civil_hour, civil_day>::value, "");
457    static_assert(!HasDifference<civil_hour, civil_month>::value, "");
458    static_assert(!HasDifference<civil_hour, civil_year>::value, "");
459    static_assert(!HasDifference<civil_day, civil_month>::value, "");
460    static_assert(!HasDifference<civil_day, civil_year>::value, "");
461    static_assert(!HasDifference<civil_month, civil_year>::value, "");
462  }
463  TEST(CivilTime, ValueSemantics) {
464    const civil_hour a(2015, 1, 2, 3);
465    const civil_hour b = a;
466    const civil_hour c(b);
467    civil_hour d;
468    d = c;
469    EXPECT_EQ("2015-01-02T03", Format(d));
470  }
471  TEST(CivilTime, Relational) {
472    const civil_year year(2014);
473    const civil_month month(year);
474    EXPECT_EQ(year, month);
475  #define TEST_RELATIONAL(OLDER, YOUNGER) \
476    do {                                  \
477      EXPECT_FALSE(OLDER < OLDER);        \
478      EXPECT_FALSE(OLDER > OLDER);        \
479      EXPECT_TRUE(OLDER >= OLDER);        \
480      EXPECT_TRUE(OLDER <= OLDER);        \
481      EXPECT_FALSE(YOUNGER < YOUNGER);    \
482      EXPECT_FALSE(YOUNGER > YOUNGER);    \
483      EXPECT_TRUE(YOUNGER >= YOUNGER);    \
484      EXPECT_TRUE(YOUNGER <= YOUNGER);    \
485      EXPECT_EQ(OLDER, OLDER);            \
486      EXPECT_NE(OLDER, YOUNGER);          \
487      EXPECT_LT(OLDER, YOUNGER);          \
488      EXPECT_LE(OLDER, YOUNGER);          \
489      EXPECT_GT(YOUNGER, OLDER);          \
490      EXPECT_GE(YOUNGER, OLDER);          \
491    } while (0)
492    TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
493                    civil_second(2015, 1, 1, 0, 0, 0));
494    TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
495                    civil_second(2014, 2, 1, 0, 0, 0));
496    TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
497                    civil_second(2014, 1, 2, 0, 0, 0));
498    TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
499                    civil_second(2014, 1, 1, 1, 0, 0));
500    TEST_RELATIONAL(civil_second(2014, 1, 1, 1, 0, 0),
501                    civil_second(2014, 1, 1, 1, 1, 0));
502    TEST_RELATIONAL(civil_second(2014, 1, 1, 1, 1, 0),
503                    civil_second(2014, 1, 1, 1, 1, 1));
504    TEST_RELATIONAL(civil_day(2014, 1, 1), civil_minute(2014, 1, 1, 1, 1));
505    TEST_RELATIONAL(civil_day(2014, 1, 1), civil_month(2014, 2));
506  #undef TEST_RELATIONAL
507  }
508  TEST(CivilTime, Arithmetic) {
509    civil_second second(2015, 1, 2, 3, 4, 5);
510    EXPECT_EQ("2015-01-02T03:04:06", Format(second += 1));
511    EXPECT_EQ("2015-01-02T03:04:07", Format(second + 1));
512    EXPECT_EQ("2015-01-02T03:04:08", Format(2 + second));
513    EXPECT_EQ("2015-01-02T03:04:05", Format(second - 1));
514    EXPECT_EQ("2015-01-02T03:04:05", Format(second -= 1));
515    EXPECT_EQ("2015-01-02T03:04:05", Format(second++));
516    EXPECT_EQ("2015-01-02T03:04:07", Format(++second));
517    EXPECT_EQ("2015-01-02T03:04:07", Format(second--));
518    EXPECT_EQ("2015-01-02T03:04:05", Format(--second));
519    civil_minute minute(2015, 1, 2, 3, 4);
520    EXPECT_EQ("2015-01-02T03:05", Format(minute += 1));
521    EXPECT_EQ("2015-01-02T03:06", Format(minute + 1));
522    EXPECT_EQ("2015-01-02T03:07", Format(2 + minute));
523    EXPECT_EQ("2015-01-02T03:04", Format(minute - 1));
524    EXPECT_EQ("2015-01-02T03:04", Format(minute -= 1));
525    EXPECT_EQ("2015-01-02T03:04", Format(minute++));
526    EXPECT_EQ("2015-01-02T03:06", Format(++minute));
527    EXPECT_EQ("2015-01-02T03:06", Format(minute--));
528    EXPECT_EQ("2015-01-02T03:04", Format(--minute));
529    civil_hour hour(2015, 1, 2, 3);
530    EXPECT_EQ("2015-01-02T04", Format(hour += 1));
531    EXPECT_EQ("2015-01-02T05", Format(hour + 1));
532    EXPECT_EQ("2015-01-02T06", Format(2 + hour));
533    EXPECT_EQ("2015-01-02T03", Format(hour - 1));
534    EXPECT_EQ("2015-01-02T03", Format(hour -= 1));
535    EXPECT_EQ("2015-01-02T03", Format(hour++));
536    EXPECT_EQ("2015-01-02T05", Format(++hour));
537    EXPECT_EQ("2015-01-02T05", Format(hour--));
538    EXPECT_EQ("2015-01-02T03", Format(--hour));
539    civil_day day(2015, 1, 2);
540    EXPECT_EQ("2015-01-03", Format(day += 1));
541    EXPECT_EQ("2015-01-04", Format(day + 1));
542    EXPECT_EQ("2015-01-05", Format(2 + day));
543    EXPECT_EQ("2015-01-02", Format(day - 1));
544    EXPECT_EQ("2015-01-02", Format(day -= 1));
545    EXPECT_EQ("2015-01-02", Format(day++));
546    EXPECT_EQ("2015-01-04", Format(++day));
547    EXPECT_EQ("2015-01-04", Format(day--));
548    EXPECT_EQ("2015-01-02", Format(--day));
549    civil_month month(2015, 1);
550    EXPECT_EQ("2015-02", Format(month += 1));
551    EXPECT_EQ("2015-03", Format(month + 1));
552    EXPECT_EQ("2015-04", Format(2 + month));
553    EXPECT_EQ("2015-01", Format(month - 1));
554    EXPECT_EQ("2015-01", Format(month -= 1));
555    EXPECT_EQ("2015-01", Format(month++));
556    EXPECT_EQ("2015-03", Format(++month));
557    EXPECT_EQ("2015-03", Format(month--));
558    EXPECT_EQ("2015-01", Format(--month));
559    civil_year year(2015);
560    EXPECT_EQ("2016", Format(year += 1));
561    EXPECT_EQ("2017", Format(year + 1));
562    EXPECT_EQ("2018", Format(2 + year));
563    EXPECT_EQ("2015", Format(year - 1));
564    EXPECT_EQ("2015", Format(year -= 1));
565    EXPECT_EQ("2015", Format(year++));
566    EXPECT_EQ("2017", Format(++year));
567    EXPECT_EQ("2017", Format(year--));
568    EXPECT_EQ("2015", Format(--year));
569  }
570  TEST(CivilTime, ArithmeticLimits) {
571    const int kIntMax = std::numeric_limits<int>::max();
572    const int kIntMin = std::numeric_limits<int>::min();
573    civil_second second(1970, 1, 1, 0, 0, 0);
574    second += kIntMax;
575    EXPECT_EQ("2038-01-19T03:14:07", Format(second));
576    second -= kIntMax;
577    EXPECT_EQ("1970-01-01T00:00:00", Format(second));
578    second += kIntMin;
579    EXPECT_EQ("1901-12-13T20:45:52", Format(second));
580    second -= kIntMin;
581    EXPECT_EQ("1970-01-01T00:00:00", Format(second));
582    civil_minute minute(1970, 1, 1, 0, 0);
583    minute += kIntMax;
584    EXPECT_EQ("6053-01-23T02:07", Format(minute));
585    minute -= kIntMax;
586    EXPECT_EQ("1970-01-01T00:00", Format(minute));
587    minute += kIntMin;
588    EXPECT_EQ("-2114-12-08T21:52", Format(minute));
589    minute -= kIntMin;
590    EXPECT_EQ("1970-01-01T00:00", Format(minute));
591    civil_hour hour(1970, 1, 1, 0);
592    hour += kIntMax;
593    EXPECT_EQ("246953-10-09T07", Format(hour));
594    hour -= kIntMax;
595    EXPECT_EQ("1970-01-01T00", Format(hour));
596    hour += kIntMin;
597    EXPECT_EQ("-243014-03-24T16", Format(hour));
598    hour -= kIntMin;
599    EXPECT_EQ("1970-01-01T00", Format(hour));
600    civil_day day(1970, 1, 1);
601    day += kIntMax;
602    EXPECT_EQ("5881580-07-11", Format(day));
603    day -= kIntMax;
604    EXPECT_EQ("1970-01-01", Format(day));
605    day += kIntMin;
606    EXPECT_EQ("-5877641-06-23", Format(day));
607    day -= kIntMin;
608    EXPECT_EQ("1970-01-01", Format(day));
609    civil_month month(1970, 1);
610    month += kIntMax;
611    EXPECT_EQ("178958940-08", Format(month));
612    month -= kIntMax;
613    EXPECT_EQ("1970-01", Format(month));
614    month += kIntMin;
615    EXPECT_EQ("-178955001-05", Format(month));
616    month -= kIntMin;
617    EXPECT_EQ("1970-01", Format(month));
618    civil_year year(0);
619    year += kIntMax;
620    EXPECT_EQ("2147483647", Format(year));
621    year -= kIntMax;
622    EXPECT_EQ("0", Format(year));
623    year += kIntMin;
624    EXPECT_EQ("-2147483648", Format(year));
625    year -= kIntMin;
626    EXPECT_EQ("0", Format(year));
627  }
628  TEST(CivilTime, ArithmeticDifference) {
629    civil_second second(2015, 1, 2, 3, 4, 5);
630    EXPECT_EQ(0, second - second);
631    EXPECT_EQ(10, (second + 10) - second);
632    EXPECT_EQ(-10, (second - 10) - second);
633    civil_minute minute(2015, 1, 2, 3, 4);
634    EXPECT_EQ(0, minute - minute);
635    EXPECT_EQ(10, (minute + 10) - minute);
636    EXPECT_EQ(-10, (minute - 10) - minute);
637    civil_hour hour(2015, 1, 2, 3);
638    EXPECT_EQ(0, hour - hour);
639    EXPECT_EQ(10, (hour + 10) - hour);
640    EXPECT_EQ(-10, (hour - 10) - hour);
641    civil_day day(2015, 1, 2);
642    EXPECT_EQ(0, day - day);
643    EXPECT_EQ(10, (day + 10) - day);
644    EXPECT_EQ(-10, (day - 10) - day);
645    civil_month month(2015, 1);
646    EXPECT_EQ(0, month - month);
647    EXPECT_EQ(10, (month + 10) - month);
648    EXPECT_EQ(-10, (month - 10) - month);
649    civil_year year(2015);
650    EXPECT_EQ(0, year - year);
651    EXPECT_EQ(10, (year + 10) - year);
652    EXPECT_EQ(-10, (year - 10) - year);
653  }
654  TEST(CivilTime, DifferenceLimits) {
655    const int kIntMax = std::numeric_limits<int>::max();
656    const int kIntMin = std::numeric_limits<int>::min();
657    const civil_day max_day(kIntMax, 12, 31);
658    EXPECT_EQ(1, max_day - (max_day - 1));
659    EXPECT_EQ(-1, (max_day - 1) - max_day);
660    const civil_day min_day(kIntMin, 1, 1);
661    EXPECT_EQ(1, (min_day + 1) - min_day);
662    EXPECT_EQ(-1, min_day - (min_day + 1));
663    const civil_day d1(1970, 1, 1);
664    const civil_day d2(5881580, 7, 11);
665    EXPECT_EQ(kIntMax, d2 - d1);
666    EXPECT_EQ(kIntMin, d1 - (d2 + 1));
667  }
668  TEST(CivilTime, Properties) {
669    civil_second ss(2015, 2, 3, 4, 5, 6);
670    EXPECT_EQ(2015, ss.year());
671    EXPECT_EQ(2, ss.month());
672    EXPECT_EQ(3, ss.day());
673    EXPECT_EQ(4, ss.hour());
674    EXPECT_EQ(5, ss.minute());
675    EXPECT_EQ(6, ss.second());
676    EXPECT_EQ(weekday::tuesday, get_weekday(ss));
677    EXPECT_EQ(34, get_yearday(ss));
678    civil_minute mm(2015, 2, 3, 4, 5, 6);
679    EXPECT_EQ(2015, mm.year());
680    EXPECT_EQ(2, mm.month());
681    EXPECT_EQ(3, mm.day());
682    EXPECT_EQ(4, mm.hour());
683    EXPECT_EQ(5, mm.minute());
684    EXPECT_EQ(0, mm.second());
685    EXPECT_EQ(weekday::tuesday, get_weekday(mm));
686    EXPECT_EQ(34, get_yearday(mm));
687    civil_hour hh(2015, 2, 3, 4, 5, 6);
688    EXPECT_EQ(2015, hh.year());
689    EXPECT_EQ(2, hh.month());
690    EXPECT_EQ(3, hh.day());
691    EXPECT_EQ(4, hh.hour());
692    EXPECT_EQ(0, hh.minute());
693    EXPECT_EQ(0, hh.second());
694    EXPECT_EQ(weekday::tuesday, get_weekday(hh));
695    EXPECT_EQ(34, get_yearday(hh));
696    civil_day d(2015, 2, 3, 4, 5, 6);
697    EXPECT_EQ(2015, d.year());
698    EXPECT_EQ(2, d.month());
699    EXPECT_EQ(3, d.day());
700    EXPECT_EQ(0, d.hour());
701    EXPECT_EQ(0, d.minute());
702    EXPECT_EQ(0, d.second());
703    EXPECT_EQ(weekday::tuesday, get_weekday(d));
704    EXPECT_EQ(34, get_yearday(d));
705    civil_month m(2015, 2, 3, 4, 5, 6);
706    EXPECT_EQ(2015, m.year());
707    EXPECT_EQ(2, m.month());
708    EXPECT_EQ(1, m.day());
709    EXPECT_EQ(0, m.hour());
710    EXPECT_EQ(0, m.minute());
711    EXPECT_EQ(0, m.second());
712    EXPECT_EQ(weekday::sunday, get_weekday(m));
713    EXPECT_EQ(32, get_yearday(m));
714    civil_year y(2015, 2, 3, 4, 5, 6);
715    EXPECT_EQ(2015, y.year());
716    EXPECT_EQ(1, y.month());
717    EXPECT_EQ(1, y.day());
718    EXPECT_EQ(0, y.hour());
719    EXPECT_EQ(0, y.minute());
720    EXPECT_EQ(0, y.second());
721    EXPECT_EQ(weekday::thursday, get_weekday(y));
<span onclick='openModal()' class='match'>722    EXPECT_EQ(1, get_yearday(y));
723  }
724  TEST(CivilTime, OutputStream) {
725    EXPECT_EQ("2016", Format(civil_year(2016)));
726    EXPECT_EQ("123", Format(civil_year(123)));
727    EXPECT_EQ("0", Format(civil_year(0)));
728    EXPECT_EQ("-1", Format(civil_year(-1)));
729    EXPECT_EQ("2016-02", Format(civil_month(2016, 2)));
730    EXPECT_EQ("2016-02-03", Format(civil_day(2016, 2, 3)));
731    EXPECT_EQ("2016-02-03T04", Format(civil_hour(2016, 2, 3, 4)));
</span>732    EXPECT_EQ("2016-02-03T04:05", Format(civil_minute(2016, 2, 3, 4, 5)));
733    EXPECT_EQ("2016-02-03T04:05:06", Format(civil_second(2016, 2, 3, 4, 5, 6)));
734    EXPECT_EQ("Monday", Format(weekday::monday));
735    EXPECT_EQ("Tuesday", Format(weekday::tuesday));
736    EXPECT_EQ("Wednesday", Format(weekday::wednesday));
737    EXPECT_EQ("Thursday", Format(weekday::thursday));
738    EXPECT_EQ("Friday", Format(weekday::friday));
739    EXPECT_EQ("Saturday", Format(weekday::saturday));
740    EXPECT_EQ("Sunday", Format(weekday::sunday));
741  }
742  TEST(CivilTime, OutputStreamLeftFillWidth) {
743    civil_second cs(2016, 2, 3, 4, 5, 6);
744    {
745      std::stringstream ss;
746      ss << std::left << std::setfill('.');
747      ss << std::setw(3) << 'X';
748      ss << std::setw(21) << civil_year(cs);
749      ss << std::setw(3) << 'X';
750      EXPECT_EQ("X..2016.................X..", ss.str());
751    }
752    {
753      std::stringstream ss;
754      ss << std::left << std::setfill('.');
755      ss << std::setw(3) << 'X';
756      ss << std::setw(21) << civil_month(cs);
757      ss << std::setw(3) << 'X';
758      EXPECT_EQ("X..2016-02..............X..", ss.str());
759    }
760    {
761      std::stringstream ss;
762      ss << std::left << std::setfill('.');
763      ss << std::setw(3) << 'X';
764      ss << std::setw(21) << civil_day(cs);
765      ss << std::setw(3) << 'X';
766      EXPECT_EQ("X..2016-02-03...........X..", ss.str());
767    }
768    {
769      std::stringstream ss;
770      ss << std::left << std::setfill('.');
771      ss << std::setw(3) << 'X';
772      ss << std::setw(21) << civil_hour(cs);
773      ss << std::setw(3) << 'X';
774      EXPECT_EQ("X..2016-02-03T04........X..", ss.str());
775    }
776    {
777      std::stringstream ss;
778      ss << std::left << std::setfill('.');
779      ss << std::setw(3) << 'X';
780      ss << std::setw(21) << civil_minute(cs);
781      ss << std::setw(3) << 'X';
782      EXPECT_EQ("X..2016-02-03T04:05.....X..", ss.str());
783    }
784    {
785      std::stringstream ss;
786      ss << std::left << std::setfill('.');
787      ss << std::setw(3) << 'X';
788      ss << std::setw(21) << civil_second(cs);
789      ss << std::setw(3) << 'X';
790      EXPECT_EQ("X..2016-02-03T04:05:06..X..", ss.str());
791    }
792  }
793  TEST(CivilTime, NextPrevWeekday) {
794    const civil_day thursday(1970, 1, 1);
795    EXPECT_EQ(weekday::thursday, get_weekday(thursday));
796    civil_day d = next_weekday(thursday, weekday::thursday);
797    EXPECT_EQ(7, d - thursday) << Format(d);
798    EXPECT_EQ(d - 14, prev_weekday(thursday, weekday::thursday));
799    d = next_weekday(thursday, weekday::friday);
800    EXPECT_EQ(1, d - thursday) << Format(d);
801    EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::friday));
802    d = next_weekday(thursday, weekday::saturday);
803    EXPECT_EQ(2, d - thursday) << Format(d);
804    EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::saturday));
805    d = next_weekday(thursday, weekday::sunday);
806    EXPECT_EQ(3, d - thursday) << Format(d);
807    EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::sunday));
808    d = next_weekday(thursday, weekday::monday);
809    EXPECT_EQ(4, d - thursday) << Format(d);
810    EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::monday));
811    d = next_weekday(thursday, weekday::tuesday);
812    EXPECT_EQ(5, d - thursday) << Format(d);
813    EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::tuesday));
814    d = next_weekday(thursday, weekday::wednesday);
815    EXPECT_EQ(6, d - thursday) << Format(d);
816    EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::wednesday));
817  }
818  TEST(CivilTime, NormalizeWithHugeYear) {
819    civil_month c(9223372036854775807, 1);
820    EXPECT_EQ("9223372036854775807-01", Format(c));
821    c = c - 1;  
822    EXPECT_EQ("9223372036854775806-12", Format(c));
823    c = civil_month(-9223372036854775807 - 1, 1);
824    EXPECT_EQ("-9223372036854775808-01", Format(c));
825    c = c + 12;  
826    EXPECT_EQ("-9223372036854775807-01", Format(c));
827  }
828  TEST(CivilTime, LeapYears) {
829    const struct {
830      int year;
831      int days;
832      struct {
833        int month;
834        int day;
835      } leap_day;  
836    } kLeapYearTable[]{
837        {1900, 365, {3, 1}},  {1999, 365, {3, 1}},
838        {2000, 366, {2, 29}},  
839        {2001, 365, {3, 1}},  {2002, 365, {3, 1}},
840        {2003, 365, {3, 1}},  {2004, 366, {2, 29}},  
841        {2005, 365, {3, 1}},  {2006, 365, {3, 1}},
842        {2007, 365, {3, 1}},  {2008, 366, {2, 29}},  
843        {2009, 365, {3, 1}},  {2100, 365, {3, 1}},
844    };
845    for (const auto& e : kLeapYearTable) {
846      const civil_day feb28(e.year, 2, 28);
847      const civil_day next_day = feb28 + 1;
848      EXPECT_EQ(e.leap_day.month, next_day.month());
849      EXPECT_EQ(e.leap_day.day, next_day.day());
850      const civil_year year(feb28);
851      const civil_year next_year = year + 1;
852      EXPECT_EQ(e.days, civil_day(next_year) - civil_day(year));
853    }
854  }
855  TEST(CivilTime, FirstThursdayInMonth) {
856    const civil_day nov1(2014, 11, 1);
857    const civil_day thursday = next_weekday(nov1 - 1, weekday::thursday);
858    EXPECT_EQ("2014-11-06", Format(thursday));
859    const civil_day thanksgiving = thursday + 7 * 3;
860    EXPECT_EQ("2014-11-27", Format(thanksgiving));
861  }
862  }  
863  }  
864  ABSL_NAMESPACE_END
865  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfast.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmfast.h"
3  #include "Snap.h"
4  #include "agm.h"
5  void TAGMFast::Save(TSOut& SOut) {
6    G->Save(SOut);
7    F.Save(SOut);
8    NIDV.Save(SOut);
9    RegCoef.Save(SOut);
10    SumFV.Save(SOut);
11    NodesOk.Save(SOut);
12    MinVal.Save(SOut);
13    MaxVal.Save(SOut);
14    NegWgt.Save(SOut);
15    NumComs.Save(SOut);
16    HOVIDSV.Save(SOut);
<span onclick='openModal()' class='match'>17    PNoCom.Save(SOut);
18  }
19  void TAGMFast::Load(TSIn& SIn, const int& RndSeed) {
20    G->Load(SIn);
21    F.Load(SIn);
22    NIDV.Load(SIn);
23    RegCoef.Load(SIn);
24    SumFV.Load(SIn);
25    NodesOk.Load(SIn);
26    MinVal.Load(SIn);
27    MaxVal.Load(SIn);
28    NegWgt.Load(SIn);
29    NumComs.Load(SIn);
30    HOVIDSV.Load(SIn);
31    PNoCom.Load(SIn);
32    Rnd.PutSeed(RndSeed);
</span>33  }
34  void TAGMFast::RandomInit(const int InitComs) {
35    F.Gen(G->GetNodes());
36    SumFV.Gen(InitComs);
37    NumComs = InitComs;
38    for (int u = 0; u < F.Len(); u++) {
39      int Mem = G->GetNI(u).GetDeg();
40      if (Mem > 10) { Mem = 10; }
41      for (int c = 0; c < Mem; c++) {
42        int CID = Rnd.GetUniDevInt(InitComs);
43        AddCom(u, CID, Rnd.GetUniDev());
44      }
45    }
46    for (int c = 0; c < SumFV.Len(); c++) {
47      if (SumFV[c] == 0.0) {
48        int UID = Rnd.GetUniDevInt(G->GetNodes());
49        AddCom(UID, c, Rnd.GetUniDev());
50      }
51    }
52  }
53  void TAGMFast::NeighborComInit(const int InitComs) {
54    F.Gen(G->GetNodes());
55    SumFV.Gen(InitComs);
56    NumComs = InitComs;
57    const int Edges = G->GetEdges();
58    TFltIntPrV NIdPhiV(F.Len(), 0);
59    TIntSet InvalidNIDS(F.Len());
60    TIntV ChosenNIDV(InitComs, 0); 
61    TExeTm RunTm;
62    for (int u = 0; u < F.Len(); u++) {
63      TIntSet NBCmty(G->GetNI(u).GetDeg() + 1);
64      double Phi;
65      if (G->GetNI(u).GetDeg() < 5) { 
66        Phi = 1.0; 
67      } else {
68        TAGMUtil::GetNbhCom(G, u, NBCmty);
69        IAssert(NBCmty.Len() == G->GetNI(u).GetDeg() + 1);
70        Phi = TAGMUtil::GetConductance(G, NBCmty, Edges);
71      }
72      NIdPhiV.Add(TFltIntPr(Phi, u));
73    }
74    NIdPhiV.Sort(true);
75    printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
76    fflush(stdout);
77    int CurCID = 0;
78    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
79      int UID = NIdPhiV[ui].Val2;
80      fflush(stdout);
81      if (InvalidNIDS.IsKey(UID)) { continue; }
82      ChosenNIDV.Add(UID); 
83      AddCom(UID, CurCID, 1.0);
84      TUNGraph::TNodeI NI = G->GetNI(UID);
85      fflush(stdout);
86      for (int e = 0; e < NI.GetDeg(); e++) {
87        AddCom(NI.GetNbrNId(e), CurCID, 1.0);
88      }
89      for (int e = 0; e < NI.GetDeg(); e++) {
90        InvalidNIDS.AddKey(NI.GetNbrNId(e));
91      }
92      CurCID++;
93      fflush(stdout);
94      if (CurCID >= NumComs) { break;  }
95    }
96    if (NumComs > CurCID) {
97      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
98    }
99    for (int c = 0; c < SumFV.Len(); c++) {
100      if (SumFV[c] == 0.0) {
101        int ComSz = 10;
102        for (int u = 0; u < ComSz; u++) {
103          int UID = Rnd.GetUniDevInt(G->GetNodes());
104          AddCom(UID, c, Rnd.GetUniDev());
105        }
106      }
107    }
108  }
109  void TAGMFast::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
110    F.Gen(G->GetNodes());
111    SumFV.Gen(CmtyVV.Len());
112    NumComs = CmtyVV.Len();
113    TIntH NIDIdxH(NIDV.Len());
114    if (! NodesOk) {
115      for (int u = 0; u < NIDV.Len(); u++) {
116        NIDIdxH.AddDat(NIDV[u], u);
117      }
118    }
119    for (int c = 0; c < CmtyVV.Len(); c++) {
120      for (int u = 0; u < CmtyVV[c].Len(); u++) {
121        int UID = CmtyVV[c][u];
122        if (! NodesOk) { UID = NIDIdxH.GetDat(UID); }
123        if (G->IsNode(UID)) { 
124          AddCom(UID, c, 1.0);
125        }
126      }
127    }
128  }
129  void TAGMFast::SetGraph(const PUNGraph& GraphPt) {
130    G = GraphPt;
131    HOVIDSV.Gen(G->GetNodes());  
132    NodesOk = true;
133    GraphPt->GetNIdV(NIDV);
134    for (int nid = 0; nid < GraphPt->GetNodes(); nid++) {
135      if (! GraphPt->IsNode(nid)) { 
136        NodesOk = false; 
137        break; 
138      } 
139    }
140    if (! NodesOk) {
141      printf("rearrage nodes\n");
142      G = TSnap::GetSubGraph(GraphPt, NIDV, true);
143      for (int nid = 0; nid < G->GetNodes(); nid++) {
144        IAssert(G->IsNode(nid)); 
145      }
146    }
147    TSnap::DelSelfEdges(G);
148    PNoCom = 1.0 / (double) G->GetNodes();
149    DoParallel = false;
150    if (1.0 / PNoCom > sqrt(TFlt::Mx)) { PNoCom = 0.99 / sqrt(TFlt::Mx); } 
151    NegWgt = 1.0;
152  }
153  double TAGMFast::Likelihood(const bool _DoParallel) { 
154    TExeTm ExeTm;
155    double L = 0.0;
156    if (_DoParallel) {
157    #pragma omp parallel for 
158      for (int u = 0; u < F.Len(); u++) {
159        double LU = LikelihoodForRow(u);
160        #pragma omp atomic
161          L += LU;
162      }
163    }
164    else {
165      for (int u = 0; u < F.Len(); u++) {
166        double LU = LikelihoodForRow(u);
167          L += LU;
168      }
169    }
170    return L;
171  }
172  double TAGMFast::LikelihoodForRow(const int UID) {
173    return LikelihoodForRow(UID, F[UID]);
174  }
175  double TAGMFast::LikelihoodForRow(const int UID, const TIntFltH& FU) {
176    double L = 0.0;
177    TFltV HOSumFV; 
178    if (HOVIDSV[UID].Len() > 0) {
179      HOSumFV.Gen(SumFV.Len());
180      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
181        for (int c = 0; c < SumFV.Len(); c++) {
182          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
183        }
184      }
185    }
186    TUNGraph::TNodeI NI = G->GetNI(UID);
187    if (DoParallel && NI.GetDeg() > 10) {
188  #pragma omp parallel for schedule(static, 1)
189      for (int e = 0; e < NI.GetDeg(); e++) {
190        int v = NI.GetNbrNId(e);
191        if (v == UID) { continue; }
192        if (HOVIDSV[UID].IsKey(v)) { continue; }
193        double LU = log (1.0 - Prediction(FU, F[v])) + NegWgt * DotProduct(FU, F[v]);
194  #pragma omp atomic
195        L += LU;
196      }
197      for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
198        double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[HI.GetKey()].Val: 0.0;
199        double LU = NegWgt * (SumFV[HI.GetKey()] - HOSum - GetCom(UID, HI.GetKey())) * HI.GetDat();
200        L -= LU;
201      }
202    } else {
203      for (int e = 0; e < NI.GetDeg(); e++) {
204        int v = NI.GetNbrNId(e);
205        if (v == UID) { continue; }
206        if (HOVIDSV[UID].IsKey(v)) { continue; }
207        L += log (1.0 - Prediction(FU, F[v])) + NegWgt * DotProduct(FU, F[v]);
208      }
209      for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
210        double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[HI.GetKey()].Val: 0.0;
211        L -= NegWgt * (SumFV[HI.GetKey()] - HOSum - GetCom(UID, HI.GetKey())) * HI.GetDat();
212      }
213    }
214    if (RegCoef > 0.0) { 
215      L -= RegCoef * Sum(FU);
216    }
217    if (RegCoef < 0.0) { 
218      L += RegCoef * Norm2(FU);
219    }
220    return L;
221  }
222  void TAGMFast::GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet) {
223    GradU.Gen(CIDSet.Len());
224    TFltV HOSumFV; 
225    if (HOVIDSV[UID].Len() > 0) {
226      HOSumFV.Gen(SumFV.Len());
227      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
228        for (int c = 0; c < SumFV.Len(); c++) {
229          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
230        }
231      }
232    }
233    TUNGraph::TNodeI NI = G->GetNI(UID);
234    int Deg = NI.GetDeg();
235    TFltV PredV(Deg), GradV(CIDSet.Len());
236    TIntV CIDV(CIDSet.Len());
237    if (DoParallel && Deg + CIDSet.Len() > 10) {
238  #pragma omp parallel for schedule(static, 1)
239      for (int e = 0; e < Deg; e++) {
240        if (NI.GetNbrNId(e) == UID) { continue; }
241        if (HOVIDSV[UID].IsKey(NI.GetNbrNId(e))) { continue; }
242        PredV[e] = Prediction(UID, NI.GetNbrNId(e));
243      }
244  #pragma omp parallel for schedule(static, 1)
245      for (int c = 0; c < CIDSet.Len(); c++) {
246        int CID = CIDSet.GetKey(c);
247        double Val = 0.0;
248        for (int e = 0; e < Deg; e++) {
249          int VID = NI.GetNbrNId(e);
250          if (VID == UID) { continue; }
251          if (HOVIDSV[UID].IsKey(VID)) { continue; }
252          Val += PredV[e] * GetCom(VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(VID, CID);
253        }
254        double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[CID].Val: 0.0;
255        Val -= NegWgt * (SumFV[CID] - HOSum - GetCom(UID, CID));
256        CIDV[c] = CID;
257        GradV[c] = Val;
258      }
259    } 
260    else {
261      for (int e = 0; e < Deg; e++) {
262        if (NI.GetNbrNId(e) == UID) { continue; }
263        if (HOVIDSV[UID].IsKey(NI.GetNbrNId(e))) { continue; }
264        PredV[e] = Prediction(UID, NI.GetNbrNId(e));
265      }
266      for (int c = 0; c < CIDSet.Len(); c++) {
267        int CID = CIDSet.GetKey(c);
268        double Val = 0.0;
269        for (int e = 0; e < Deg; e++) {
270          int VID = NI.GetNbrNId(e);
271          if (VID == UID) { continue; }
272          if (HOVIDSV[UID].IsKey(VID)) { continue; }
273          Val += PredV[e] * GetCom(VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(VID, CID);
274        }
275        double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[CID].Val: 0.0;
276        Val -= NegWgt * (SumFV[CID] - HOSum - GetCom(UID, CID));
277        CIDV[c] = CID;
278        GradV[c] = Val;
279      }
280    }
281    if (RegCoef > 0.0) { 
282      for (int c = 0; c < GradV.Len(); c++) {
283        GradV[c] -= RegCoef; 
284      }
285    }
286    if (RegCoef < 0.0) { 
287      for (int c = 0; c < GradV.Len(); c++) {
288        GradV[c] += 2 * RegCoef * GetCom(UID, CIDV[c]); 
289      }
290    }
291    for (int c = 0; c < GradV.Len(); c++) {
292      if (GetCom(UID, CIDV[c]) == 0.0 && GradV[c] < 0.0) { continue; }
293      if (fabs(GradV[c]) < 0.0001) { continue; }
294      GradU.AddDat(CIDV[c], GradV[c]);
295    }
296    for (int c = 0; c < GradU.Len(); c++) {
297      if (GradU[c] >= 10) { GradU[c] = 10; }
298      if (GradU[c] <= -10) { GradU[c] = -10; }
299      IAssert(GradU[c] >= -10);
300    }
301  }
302  double TAGMFast::GradientForOneVar(const TFltV& AlphaKV, const int UID, const int CID, const double& Val) {
303    TUNGraph::TNodeI UI = G->GetNI(UID);
304    double Grad = 0.0, PNoEdge;
305    int VID = 0;
306    for (int e = 0; e < UI.GetDeg(); e++) {
307      VID = UI.GetNbrNId(e);
308      if (HOVIDSV[UID].IsKey(UI.GetNbrNId(e))) { continue; }
309      if (! F[VID].IsKey(CID)) { continue; }
310      PNoEdge = AlphaKV[e] * exp (- F[VID].GetDat(CID) * Val);
311      IAssert(PNoEdge <= 1.0 && PNoEdge >= 0.0);
312      Grad += ((PNoEdge * F[VID].GetDat(CID)) / (1.0 - PNoEdge) + NegWgt * F[VID].GetDat(CID));
313    }
314    Grad -= NegWgt * (SumFV[CID] - GetCom(UID, CID));
315    if (RegCoef > 0.0) { 
316      Grad -= RegCoef; 
317    }
318    if (RegCoef < 0.0) { 
319      Grad += 2 * RegCoef * Val; 
320    }
321    return Grad;
322  }
323  double TAGMFast::LikelihoodForOneVar(const TFltV& AlphaKV, const int UID, const int CID, const double& Val) {
324    TUNGraph::TNodeI UI = G->GetNI(UID);
325    double L = 0.0, PNoEdge;
326    int VID = 0;
327    for (int e = 0; e < UI.GetDeg(); e++) {
328      VID = UI.GetNbrNId(e);
329      if (HOVIDSV[UID].IsKey(UI.GetNbrNId(e))) { continue; }
330      if (! F[VID].IsKey(CID)) { 
331        PNoEdge = AlphaKV[e];
332      } else {
333        PNoEdge = AlphaKV[e] * exp (- F[VID].GetDat(CID) * Val);
334      }
335      IAssert(PNoEdge <= 1.0 && PNoEdge >= 0.0);
336      L += log(1.0 - PNoEdge) + NegWgt * GetCom(VID, CID) * Val;
337    }
338    L -= NegWgt * (SumFV[CID] - GetCom(UID, CID)) * Val;
339    if (RegCoef > 0.0) { 
340      L -= RegCoef * Val;
341    }
342    if (RegCoef < 0.0) { 
343      L += RegCoef * Val * Val; 
344    }
345    return L;
346  }
347  double TAGMFast::HessianForOneVar(const TFltV& AlphaKV, const int UID, const int CID, const double& Val) {
348    TUNGraph::TNodeI UI = G->GetNI(UID);
349    double H = 0.0, PNoEdge;
350    int VID = 0;
351    for (int e = 0; e < UI.GetDeg(); e++) {
352      VID = UI.GetNbrNId(e);
353      if (HOVIDSV[UID].IsKey(UI.GetNbrNId(e))) { continue; }
354      if (! F[VID].IsKey(CID)) { continue; }
355      PNoEdge = AlphaKV[e] * exp (- F[VID].GetDat(CID) * Val);
356      IAssert(PNoEdge <= 1.0 && PNoEdge >= 0.0);
357      H += (- PNoEdge * F[VID].GetDat(CID) * F[VID].GetDat(CID)) / (1.0 - PNoEdge) / (1.0 - PNoEdge);
358    }
359    if (RegCoef < 0.0) { 
360      H += 2 * RegCoef; 
361    }
362    IAssert (H <= 0.0);
363    return H;
364  }
365  int TAGMFast::MLENewton(const double& Thres, const int& MaxIter, const TStr& PlotNm) {
366    TExeTm ExeTm;
367    int iter = 0, PrevIter = 0;
368    TIntFltPrV IterLV;
369    double PrevL = TFlt::Mn, CurL;
370    TUNGraph::TNodeI UI;
371    TIntV NIdxV;
372    G->GetNIdV(NIdxV);
373    int CID, UID, NewtonIter;
374    double Fuc;
375    double Grad, H;
376    while(iter < MaxIter) {
377      NIdxV.Shuffle(Rnd);
378      for (int ui = 0; ui < F.Len(); ui++, iter++) {
379        if (! PlotNm.Empty() && iter % G->GetNodes() == 0) {
380          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
381        }
382        UID = NIdxV[ui];
383        TIntSet CIDSet;
384        UI = G->GetNI(UID);
385        if (UI.GetDeg() == 0) { 
386          if (! F[UID].Empty()) { F[UID].Clr(); }
387          continue;
388        }
389        for (int e = 0; e < UI.GetDeg(); e++) {
390          if (HOVIDSV[UID].IsKey(UI.GetNbrNId(e))) { continue; }
391          TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
392          for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
393            CIDSet.AddKey(CI.GetKey());
394          }
395        }
396        for (TIntFltH::TIter CI = F[UID].BegI(); CI < F[UID].EndI(); CI++) { 
397          if (! CIDSet.IsKey(CI.GetKey())) {
398            DelCom(UID, CI.GetKey());
399          }
400        }
401        if (CIDSet.Empty()) { continue; }
402        for (TIntSet::TIter CI = CIDSet.BegI(); CI < CIDSet.EndI(); CI++) {
403          CID = CI.GetKey();
404          TFltV AlphaKV(UI.GetDeg());
405          for (int e = 0; e < UI.GetDeg(); e++) {
406            if (HOVIDSV[UID].IsKey(UI.GetNbrNId(e))) { continue; }
407            AlphaKV[e] = (1 - PNoCom) * exp(- DotProduct(UID, UI.GetNbrNId(e)) + GetCom(UI.GetNbrNId(e), CID) * GetCom(UID, CID));
408            IAssertR(AlphaKV[e] <= 1.0, TStr::Fmt("AlphaKV=%f, %f, %f", AlphaKV[e].Val, PNoCom.Val, GetCom(UI.GetNbrNId(e), CID)));
409          }
410          Fuc = GetCom(UID, CID);
411          Grad = GradientForOneVar(AlphaKV, UID, CID, Fuc), H = 0.0;
412          if (Grad <= 1e-3 && Grad >= -0.1) { continue; }
413          NewtonIter = 0;
414          while (NewtonIter++ < 10) {
415            Grad = GradientForOneVar(AlphaKV, UID, CID, Fuc), H = 0.0;
416            H = HessianForOneVar(AlphaKV, UID, CID, Fuc);
417            if (Fuc == 0.0 && Grad <= 0.0) { Grad = 0.0; }
418            if (fabs(Grad) < 1e-3) { break; }
419            if (H == 0.0) { Fuc = 0.0; break; }
420            double NewtonStep = - Grad / H;
421            if (NewtonStep < -0.5) { NewtonStep = - 0.5; }
422            Fuc += NewtonStep;
423            if (Fuc < 0.0) { Fuc = 0.0; }
424          }
425          if (Fuc == 0.0) {
426            DelCom(UID, CID);
427          }
428          else {
429            AddCom(UID, CID, Fuc);
430          }
431        }
432      }
433      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
434        PrevIter = iter;
435        CurL = Likelihood();
436        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
437          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
438        }
439        fflush(stdout);
440        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
441        else { PrevL = CurL; }
442      }
443    }
444    if (! PlotNm.Empty()) {
445      printf("\nMLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
446      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
447    }
448    return iter;
449  }
450  void TAGMFast::GetCmtyVV(TVec<TIntV>& CmtyVV) {
451    GetCmtyVV(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
452  }
453  void TAGMFast::GetCmtyVV(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
454    CmtyVV.Gen(NumComs, 0);
455    TIntFltH CIDSumFH(NumComs);
456    for (int c = 0; c < SumFV.Len(); c++) {
457      CIDSumFH.AddDat(c, SumFV[c]);
458    }
459    CIDSumFH.SortByDat(false);
460    for (int c = 0; c < NumComs; c++) {
461      int CID = CIDSumFH.GetKey(c);
462      TIntFltH NIDFucH(F.Len() / 10);
463      TIntV CmtyV;
464      IAssert(SumFV[CID] == CIDSumFH.GetDat(CID));
465      if (SumFV[CID] < Thres) { continue; }
466      for (int u = 0; u < F.Len(); u++) {
467        int NID = u;
468        if (! NodesOk) { NID = NIDV[u]; }
469        if (GetCom(u, CID) >= Thres) { NIDFucH.AddDat(NID, GetCom(u, CID)); }
470      }
471      NIDFucH.SortByDat(false);
472      NIDFucH.GetKeyV(CmtyV);
473      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
474    }
475    if ( NumComs != CmtyVV.Len()) {
476      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
477    }
478  }
479  int TAGMFast::FindComsByCV(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr& OutFNm, const double StepAlpha, const double StepBeta) {
480      double ComsGap = exp(TMath::Log((double) MaxComs / (double) MinComs) / (double) DivComs);
481      TIntV ComsV;
482      ComsV.Add(MinComs);
483      while (ComsV.Len() < DivComs) {
484        int NewComs = int(ComsV.Last() * ComsGap);
485        if (NewComs == ComsV.Last().Val) { NewComs++; }
486        ComsV.Add(NewComs);
487      }
488      if (ComsV.Last() < MaxComs) { ComsV.Add(MaxComs); }
489      return FindComsByCV(ComsV, 0.1, NumThreads, OutFNm + ".CV.likelihood", StepAlpha, StepBeta);
490  }
491  int TAGMFast::FindComsByCV(TIntV& ComsV, const double HOFrac, const int NumThreads, const TStr& PlotLFNm, const double StepAlpha, const double StepBeta) {
492    if (ComsV.Len() == 0) {
493      int MaxComs = G->GetNodes() / 5;
494      ComsV.Add(2);
495      while(ComsV.Last() < MaxComs) { ComsV.Add(ComsV.Last() * 2); }
496    }
497    TIntPrV EdgeV(G->GetEdges(), 0);
498    for (TUNGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
499      EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
500    }
501    EdgeV.Shuffle(Rnd);
502    int MaxIterCV = 3;
503    TVec<TVec<TIntSet> > HoldOutSets(MaxIterCV);
504    if (EdgeV.Len() > 50) { 
505      printf("generating hold out set\n");
506      TIntV NIdV1, NIdV2;
507      G->GetNIdV(NIdV1);
508      G->GetNIdV(NIdV2);
509      for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
510        HoldOutSets[IterCV].Gen(G->GetNodes());
511        const int HOTotal = int(HOFrac * G->GetNodes() * (G->GetNodes() - 1) / 2.0);
512        int HOCnt = 0;
513        int HOEdges = (int) TMath::Round(HOFrac * G->GetEdges());
514        printf("holding out %d edges...\n", HOEdges);
515        for (int he = 0; he < (int) HOEdges; he++) {
516          HoldOutSets[IterCV][EdgeV[he].Val1].AddKey(EdgeV[he].Val2);
517          HoldOutSets[IterCV][EdgeV[he].Val2].AddKey(EdgeV[he].Val1);
518          HOCnt++;
519        }
520        printf("%d Edges hold out\n", HOCnt);
521        while(HOCnt++ < HOTotal) {
522          int SrcNID = Rnd.GetUniDevInt(G->GetNodes());
523          int DstNID = Rnd.GetUniDevInt(G->GetNodes());
524          HoldOutSets[IterCV][SrcNID].AddKey(DstNID);
525          HoldOutSets[IterCV][DstNID].AddKey(SrcNID);
526        }
527      }
528      printf("hold out set generated\n");
529    }
530    TFltV HOLV(ComsV.Len());
531    TIntFltPrV ComsLV;
532    for (int c = 0; c < ComsV.Len(); c++) {
533      const int Coms = ComsV[c];
534      printf("Try number of Coms:%d\n", Coms);
535      NeighborComInit(Coms);
536      printf("Initialized\n");
537      if (EdgeV.Len() > 50) { 
538        for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
539          HOVIDSV = HoldOutSets[IterCV];
540          if (NumThreads == 1) {
541            printf("MLE without parallelization begins\n");
542            MLEGradAscent(0.05, 10 * G->GetNodes(), "", StepAlpha, StepBeta);
543          } else {
544            printf("MLE with parallelization begins\n");
545            MLEGradAscentParallel(0.05, 100, NumThreads, "", StepAlpha, StepBeta);
546          }
547          double HOL = LikelihoodHoldOut();
548          HOL = HOL < 0? HOL: TFlt::Mn;
549          HOLV[c] += HOL;
550        }
551      }
552      else {
553        HOVIDSV.Gen(G->GetNodes());
554        MLEGradAscent(0.0001, 100 * G->GetNodes(), "");
555        double BIC = 2 * Likelihood() - (double) G->GetNodes() * Coms * 2.0 * log ( (double) G->GetNodes());
556        HOLV[c] = BIC;
557      }
558    }
559    int EstComs = 2;
560    double MaxL = TFlt::Mn;
561    printf("\n");
562    for (int c = 0; c < ComsV.Len(); c++) {
563      ComsLV.Add(TIntFltPr(ComsV[c].Val, HOLV[c].Val));
564      printf("%d(%f)\t", ComsV[c].Val, HOLV[c].Val);
565      if (MaxL < HOLV[c]) {
566        MaxL = HOLV[c];
567        EstComs = ComsV[c];
568      }
569    }
570    printf("\n");
571    RandomInit(EstComs);
572    HOVIDSV.Gen(G->GetNodes());
573    if (! PlotLFNm.Empty()) {
574      TGnuPlot::PlotValV(ComsLV, PlotLFNm, "hold-out likelihood", "communities", "likelihood");
575    }
576    return EstComs;
577  }
578  double TAGMFast::LikelihoodHoldOut(const bool DoParallel) { 
579    double L = 0.0;
580    for (int u = 0; u < HOVIDSV.Len(); u++) {
581      for (int e = 0; e < HOVIDSV[u].Len(); e++) {
582        int VID = HOVIDSV[u][e];
583        if (VID == u) { continue; } 
584        double Pred = Prediction(u, VID);
585        if (G->IsEdge(u, VID)) {
586          L += log(1.0 - Pred);
587        }
588        else {
589          L += NegWgt * log(Pred);
590        }
591      }
592    }
593    return L;
594  }
595  double TAGMFast::GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter) {
596    double StepSize = 1.0;
597    double InitLikelihood = LikelihoodForRow(UID);
598    TIntFltH NewVarV(DeltaV.Len());
599    for(int iter = 0; iter < MaxIter; iter++) {
600      for (int i = 0; i < DeltaV.Len(); i++){
601        int CID = DeltaV.GetKey(i);
602        double NewVal = GetCom(UID, CID) + StepSize * DeltaV.GetDat(CID);
603        if (NewVal < MinVal) { NewVal = MinVal; }
604        if (NewVal > MaxVal) { NewVal = MaxVal; }
605        NewVarV.AddDat(CID, NewVal);
606      }
607      if (LikelihoodForRow(UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
608        StepSize *= Beta;
609      } else {
610        break;
611      }
612      if (iter == MaxIter - 1) { 
613        StepSize = 0.0;
614        break;
615      }
616    }
617    return StepSize;
618  }
619  int TAGMFast::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr& PlotNm, const double StepAlpha, const double StepBeta) {
620    time_t InitTime = time(NULL);
621    TExeTm ExeTm, CheckTm;
622    int iter = 0, PrevIter = 0;
623    TIntFltPrV IterLV;
624    TUNGraph::TNodeI UI;
625    double PrevL = TFlt::Mn, CurL = 0.0;
626    TIntV NIdxV(F.Len(), 0);
627    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
628    IAssert(NIdxV.Len() == F.Len());
629    TIntFltH GradV;
630    while(iter < MaxIter) {
631      NIdxV.Shuffle(Rnd);
632      for (int ui = 0; ui < F.Len(); ui++, iter++) {
633        int u = NIdxV[ui]; 
634        UI = G->GetNI(u);
635        TIntSet CIDSet(5 * UI.GetDeg());
636        for (int e = 0; e < UI.GetDeg(); e++) {
637          if (HOVIDSV[u].IsKey(UI.GetNbrNId(e))) { continue; }
638          TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
639          for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
640            CIDSet.AddKey(CI.GetKey());
641          }
642        }
643        for (TIntFltH::TIter CI = F[u].BegI(); CI < F[u].EndI(); CI++) { 
644          if (! CIDSet.IsKey(CI.GetKey())) {
645            DelCom(u, CI.GetKey());
646          }
647        }
648        if (CIDSet.Empty()) { continue; }
649        GradientForRow(u, GradV, CIDSet);
650        if (Norm2(GradV) < 1e-4) { continue; }
651        double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
652        if (LearnRate == 0.0) { continue; }
653        for (int ci = 0; ci < GradV.Len(); ci++) {
654          int CID = GradV.GetKey(ci);
655          double Change = LearnRate * GradV.GetDat(CID);
656          double NewFuc = GetCom(u, CID) + Change;
657          if (NewFuc <= 0.0) {
658            DelCom(u, CID);
659          } else {
660            AddCom(u, CID, NewFuc);
661          }
662        }
663        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
664          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
665        }
666      }
667      printf("\r%d iterations (%f) [%lu sec]", iter, CurL, time(NULL) - InitTime);
668      fflush(stdout);
669      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
670        PrevIter = iter;
671        CurL = Likelihood();
672        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
673          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
674        }
675        fflush(stdout);
676        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
677        else { PrevL = CurL; }
678      }
679    }
680    printf("\n");
681    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
682    if (! PlotNm.Empty()) {
683      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
684    }
685    return iter;
686  }
687  int TAGMFast::MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr& PlotNm, const double StepAlpha, const double StepBeta) {
688    time_t InitTime = time(NULL);
689    uint64 StartTm = TSecTm::GetCurTm().GetAbsSecs();
690    TExeTm ExeTm, CheckTm;
691    double PrevL = Likelihood(true);
692    TIntFltPrV IterLV;
693    int PrevIter = 0;
694    int iter = 0;
695    TIntV NIdxV(F.Len(), 0);
696    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
697    TIntV NIDOPTV(F.Len()); 
698    NIDOPTV.PutAll(0);
699    TVec<TIntFltH> NewF(ChunkNum * ChunkSize);
700    TIntV NewNIDV(ChunkNum * ChunkSize);
701    for (iter = 0; iter < MaxIter; iter++) {
702      NIdxV.Clr(false);
703      for (int i = 0; i < F.Len(); i++) { 
704        if (NIDOPTV[i] == 0) {  NIdxV.Add(i); }
705      }
706      IAssert (NIdxV.Len() <= F.Len());
707      NIdxV.Shuffle(Rnd);
708  #pragma omp parallel for schedule(static, 1)
709      for (int TIdx = 0; TIdx < ChunkNum; TIdx++) {
710        TIntFltH GradV;
711        for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) {
712          NewNIDV[ui] = -1;
713          if (ui > NIdxV.Len()) { continue; }
714          int u = NIdxV[ui]; 
715          TUNGraph::TNodeI UI = G->GetNI(u);
716          TIntSet CIDSet(5 * UI.GetDeg());
717          TIntFltH CurFU = F[u];
718          for (int e = 0; e < UI.GetDeg(); e++) {
719            if (HOVIDSV[u].IsKey(UI.GetNbrNId(e))) { continue; }
720            TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
721            for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
722              CIDSet.AddKey(CI.GetKey());
723            }
724          }
725          if (CIDSet.Empty()) { 
726            CurFU.Clr();
727          }
728          else {
729            for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) { 
730              if (! CIDSet.IsKey(CI.GetKey())) {
731                CurFU.DelIfKey(CI.GetKey());
732              }
733            }
734            GradientForRow(u, GradV, CIDSet);
735            if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; }
736            double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta, 5);
737            if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; }
738            for (int ci = 0; ci < GradV.Len(); ci++) {
739              int CID = GradV.GetKey(ci);
740              double Change = LearnRate * GradV.GetDat(CID);
741              double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change;
742              if (NewFuc <= 0.0) {
743                CurFU.DelIfKey(CID);
744              } else {
745                CurFU.AddDat(CID) = NewFuc;
746              }
747            }
748            CurFU.Defrag();
749          }
750          NewF[ui] = CurFU;
751          NewNIDV[ui] = u;
752        }
753      }
754      int NumNoChangeGrad = 0;
755      int NumNoChangeStepSize = 0;
756      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
757        int NewNID = NewNIDV[ui];
758        if (NewNID == -1) { NumNoChangeGrad++; continue; }
759        if (NewNID == -2) { NumNoChangeStepSize++; continue; }
760        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
761          SumFV[CI.GetKey()] -= CI.GetDat();
762        }
763      }
764  #pragma omp parallel for
765      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
766        int NewNID = NewNIDV[ui];
767        if (NewNID < 0) { continue; }
768        F[NewNID] = NewF[ui];
769      }
770      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
771        int NewNID = NewNIDV[ui];
772        if (NewNID < 0) { continue; }
773        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
774          SumFV[CI.GetKey()] += CI.GetDat();
775        }
776      }
777      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
778        int NewNID = NewNIDV[ui];
779        if (NewNID < 0) { continue; }
780        TUNGraph::TNodeI UI = G->GetNI(NewNID);
781        NIDOPTV[NewNID] = 0;
782        for (int e = 0; e < UI.GetDeg(); e++) {
783          NIDOPTV[UI.GetNbrNId(e)] = 0;
784        }
785      }
786      int OPTCnt = 0;
787      for (int i = 0; i < NIDOPTV.Len(); i++) { if (NIDOPTV[i] == 1) { OPTCnt++; } }
788      if (! PlotNm.Empty()) {
789        printf("\r%d iterations [%s] %d secs", iter * ChunkSize * ChunkNum, ExeTm.GetTmStr(), int(TSecTm::GetCurTm().GetAbsSecs() - StartTm));
790        if (PrevL > TFlt::Mn) { printf(" (%f) %d g %d s %d OPT", PrevL, NumNoChangeGrad, NumNoChangeStepSize, OPTCnt); }
791        fflush(stdout);
792      }
793      if ((iter - PrevIter) * ChunkSize * ChunkNum >= G->GetNodes()) {
794        PrevIter = iter;
795        double CurL = Likelihood(true);
796        IterLV.Add(TIntFltPr(iter * ChunkSize * ChunkNum, CurL));
797        printf("\r%d iterations, Likelihood: %f, Diff: %f [%d secs]", iter, CurL,  CurL - PrevL, int(time(NULL) - InitTime));
798         fflush(stdout);
799        if (CurL - PrevL <= Thres * fabs(PrevL)) { 
800          break;
801        }
802        else {
803          PrevL = CurL;
804        }
805      }
806    }
807    if (! PlotNm.Empty()) {
808      printf("\nMLE completed with %d iterations(%d secs)\n", iter, int(TSecTm::GetCurTm().GetAbsSecs() - StartTm));
809      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
810    } else {
811      printf("\rMLE completed with %d iterations(%d secs)", iter, int(time(NULL) - InitTime));
812      fflush(stdout);
813    }
814    return iter;
815  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_test_17.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfast.cpp</div>
                </div>
                <div class="column column_space"><pre><code>722    EXPECT_EQ(1, get_yearday(y));
723  }
724  TEST(CivilTime, OutputStream) {
725    EXPECT_EQ("2016", Format(civil_year(2016)));
726    EXPECT_EQ("123", Format(civil_year(123)));
727    EXPECT_EQ("0", Format(civil_year(0)));
728    EXPECT_EQ("-1", Format(civil_year(-1)));
729    EXPECT_EQ("2016-02", Format(civil_month(2016, 2)));
730    EXPECT_EQ("2016-02-03", Format(civil_day(2016, 2, 3)));
731    EXPECT_EQ("2016-02-03T04", Format(civil_hour(2016, 2, 3, 4)));
</pre></code></div>
                <div class="column column_space"><pre><code>17    PNoCom.Save(SOut);
18  }
19  void TAGMFast::Load(TSIn& SIn, const int& RndSeed) {
20    G->Load(SIn);
21    F.Load(SIn);
22    NIDV.Load(SIn);
23    RegCoef.Load(SIn);
24    SumFV.Load(SIn);
25    NodesOk.Load(SIn);
26    MinVal.Load(SIn);
27    MaxVal.Load(SIn);
28    NegWgt.Load(SIn);
29    NumComs.Load(SIn);
30    HOVIDSV.Load(SIn);
31    PNoCom.Load(SIn);
32    Rnd.PutSeed(RndSeed);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    