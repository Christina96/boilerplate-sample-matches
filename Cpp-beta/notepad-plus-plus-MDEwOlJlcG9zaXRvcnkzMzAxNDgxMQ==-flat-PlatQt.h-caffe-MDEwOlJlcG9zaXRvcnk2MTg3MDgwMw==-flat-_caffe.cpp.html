
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8634361233480177%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatQt.h</h3>
            <pre><code>1  #ifndef PLATQT_H
2  #define PLATQT_H
3  #include <cstddef>
4  #include <string_view>
5  #include <vector>
6  #include <optional>
7  #include <memory>
8  #include "Debugging.h"
9  #include "Geometry.h"
10  #include "ScintillaTypes.h"
11  #include "ScintillaMessages.h"
12  #include "Platform.h"
13  #include <QUrl>
14  #include <QPaintDevice>
15  #include <QPainter>
16  #include <QHash>
17  #include <QTextCodec>
18  namespace Scintilla::Internal {
19  const char *CharacterSetID(Scintilla::CharacterSet characterSet);
20  inline QColor QColorFromColourRGBA(ColourRGBA ca)
21  {
22  	return QColor(ca.GetRed(), ca.GetGreen(), ca.GetBlue(), ca.GetAlpha());
23  }
24  inline QRect QRectFromPRect(PRectangle pr)
25  {
26  	return QRect(pr.left, pr.top, pr.Width(), pr.Height());
27  }
28  inline QRectF QRectFFromPRect(PRectangle pr)
29  {
30  	return QRectF(pr.left, pr.top, pr.Width(), pr.Height());
31  }
32  inline PRectangle PRectFromQRect(QRect qr)
33  {
34  	return PRectangle(qr.x(), qr.y(), qr.x() + qr.width(), qr.y() + qr.height());
35  }
36  inline Point PointFromQPoint(QPoint qp)
37  {
38  	return Point(qp.x(), qp.y());
39  }
40  inline QPointF QPointFFromPoint(Point qp)
41  {
42  	return QPointF(qp.x, qp.y);
43  }
44  constexpr PRectangle RectangleInset(PRectangle rc, XYPOSITION delta) noexcept {
45  	return PRectangle(rc.left + delta, rc.top + delta, rc.right - delta, rc.bottom - delta);
46  }
47  class SurfaceImpl : public Surface {
48  private:
49  	QPaintDevice *device = nullptr;
50  	QPainter *painter = nullptr;
51  	bool deviceOwned = false;
52  	bool painterOwned = false;
53  	SurfaceMode mode;
54  	const char *codecName = nullptr;
55  	QTextCodec *codec = nullptr;
<span onclick='openModal()' class='match'>56  	void Clear();
57  public:
58  	SurfaceImpl();
59  	SurfaceImpl(int width, int height, SurfaceMode mode_);
60  	virtual ~SurfaceImpl();
61  	void Init(WindowID wid) override;
62  	void Init(SurfaceID sid, WindowID wid) override;
</span>63  	std::unique_ptr<Surface> AllocatePixMap(int width, int height) override;
64  	void SetMode(SurfaceMode mode) override;
65  	void Release() noexcept override;
66  	int SupportsFeature(Scintilla::Supports feature) noexcept override;
67  	bool Initialised() override;
68  	void PenColour(ColourRGBA fore);
69  	void PenColourWidth(ColourRGBA fore, XYPOSITION strokeWidth);
70  	int LogPixelsY() override;
71  	int PixelDivisions() override;
72  	int DeviceHeightFont(int points) override;
73  	void LineDraw(Point start, Point end, Stroke stroke) override;
74  	void PolyLine(const Point *pts, size_t npts, Stroke stroke) override;
75  	void Polygon(const Point *pts, size_t npts, FillStroke fillStroke) override;
76  	void RectangleDraw(PRectangle rc, FillStroke fillStroke) override;
77  	void RectangleFrame(PRectangle rc, Stroke stroke) override;
78  	void FillRectangle(PRectangle rc, Fill fill) override;
79  	void FillRectangleAligned(PRectangle rc, Fill fill) override;
80  	void FillRectangle(PRectangle rc, Surface &surfacePattern) override;
81  	void RoundedRectangle(PRectangle rc, FillStroke fillStroke) override;
82  	void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke) override;
83  	void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options) override;
84  	void DrawRGBAImage(PRectangle rc, int width, int height,
85  		const unsigned char *pixelsImage) override;
86  	void Ellipse(PRectangle rc, FillStroke fillStroke) override;
87  	void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends) override;
88  	void Copy(PRectangle rc, Point from, Surface &surfaceSource) override;
89  	std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) override;
90  	void DrawTextNoClip(PRectangle rc, const Font *font, XYPOSITION ybase,
91  		std::string_view text, ColourRGBA fore, ColourRGBA back) override;
92  	void DrawTextClipped(PRectangle rc, const Font *font, XYPOSITION ybase,
93  		std::string_view text, ColourRGBA fore, ColourRGBA back) override;
94  	void DrawTextTransparent(PRectangle rc, const Font *font, XYPOSITION ybase,
95  		std::string_view text, ColourRGBA fore) override;
96  	void MeasureWidths(const Font *font, std::string_view text,
97  		XYPOSITION *positions) override;
98  	XYPOSITION WidthText(const Font *font, std::string_view text) override;
99  	void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase,
100  		std::string_view text, ColourRGBA fore, ColourRGBA back) override;
101  	void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase,
102  		std::string_view text, ColourRGBA fore, ColourRGBA back) override;
103  	void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase,
104  		std::string_view text, ColourRGBA fore) override;
105  	void MeasureWidthsUTF8(const Font *font_, std::string_view text,
106  		XYPOSITION *positions) override;
107  	XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) override;
108  	XYPOSITION Ascent(const Font *font) override;
109  	XYPOSITION Descent(const Font *font) override;
110  	XYPOSITION InternalLeading(const Font *font) override;
111  	XYPOSITION Height(const Font *font) override;
112  	XYPOSITION AverageCharWidth(const Font *font) override;
113  	void SetClip(PRectangle rc) override;
114  	void PopClip() override;
115  	void FlushCachedState() override;
116  	void FlushDrawing() override;
117  	void BrushColour(ColourRGBA back);
118  	void SetCodec(const Font *font);
119  	void SetFont(const Font *font);
120  	QPaintDevice *GetPaintDevice();
121  	void SetPainter(QPainter *painter);
122  	QPainter *GetPainter();
123  };
124  }
125  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-_caffe.cpp</h3>
            <pre><code>1  #include <Python.h>  
2  #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
3  #include <boost/make_shared.hpp>
4  #include <boost/python.hpp>
5  #include <boost/python/raw_function.hpp>
6  #include <boost/python/suite/indexing/vector_indexing_suite.hpp>
7  #include <boost/python/suite/indexing/map_indexing_suite.hpp>
8  #include <numpy/arrayobject.h>
9  #include <string>  
10  #include <vector>  
11  #include <fstream>  
12  #include "caffe/caffe.hpp"
13  #include "caffe/layers/memory_data_layer.hpp"
14  #include "caffe/layers/python_layer.hpp"
15  #include "caffe/sgd_solvers.hpp"
16  #ifdef USE_MLSL
17  #include "caffe/multinode/mlsl.hpp"
18  #include "caffe/multinode/multi_sync.hpp"
19  #endif
20  #ifndef NPY_ARRAY_C_CONTIGUOUS
21  #define NPY_ARRAY_C_CONTIGUOUS NPY_C_CONTIGUOUS
22  #define PyArray_SetBaseObject(arr, x) (PyArray_BASE(arr) = (x))
23  #endif
24  #define BP_REGISTER_SHARED_PTR_TO_PYTHON(PTR) do { \
25    const boost::python::type_info info = \
26      boost::python::type_id<shared_ptr<PTR > >(); \
27    const boost::python::converter::registration* reg = \
28      boost::python::converter::registry::query(info); \
29    if (reg == NULL) { \
30      bp::register_ptr_to_python<shared_ptr<PTR > >(); \
31    } else if ((*reg).m_to_python == NULL) { \
32      bp::register_ptr_to_python<shared_ptr<PTR > >(); \
33    } \
34  } while (0)
35  namespace bp = boost::python;
36  namespace caffe {
37  typedef float Dtype;
38  const int NPY_DTYPE = NPY_FLOAT32;
39  void set_mode_cpu() { Caffe::set_mode(Caffe::CPU); }
40  void set_mode_gpu() { Caffe::set_mode(Caffe::GPU); }
41  #ifdef USE_MLSL
42  void InitMultinode() {
43    int argc = 0;
44    char **argv = NULL;
45    mn::init(&argc, &argv);
46  }
47  #endif
48  int NodeId() {
49  #if USE_MLSL
50    return mn::get_node_id();
51  #else
52    return 0;
53  #endif
54  }
55  int NumNodes() {
56  #if USE_MLSL
57    return mn::get_nodes_count();
58  #else
59    return 1;
60  #endif
61  }
62  void Barrier() {
63  #if USE_MLSL
64    mn::Distribution * distrib = mn::get_distrib();
65    distrib->barrier<MLSL::GT_DATA>();
66  #endif
67  }
68  void InitLog() {
69    ::google::InitGoogleLogging("");
70    ::google::InstallFailureSignalHandler();
71  }
72  void InitLogLevel(int level) {
73    FLAGS_minloglevel = level;
74    InitLog();
75  }
76  void InitLogLevelPipe(int level, bool std_err) {
77    FLAGS_minloglevel = level;
78    FLAGS_logtostderr = std_err;
79    InitLog();
80  }
81  void Log(const string& s) {
82    LOG(INFO) << s;
83  }
84  void set_random_seed(unsigned int seed) { Caffe::set_random_seed(seed); }
85  string  compile_net(const string& raw_net_prototxt, int phase, const string& engine_str = "MKLDNN") {
86    NetParameter raw_net_param;
87    NetParameter compiled_net_param;
88    ReadNetParamsFromTextFileOrDie(raw_net_prototxt, &raw_net_param);
89    raw_net_param.mutable_state()->set_phase(static_cast<Phase>(phase));
90    raw_net_param.mutable_compile_net_state()->set_is_init(true);
91    raw_net_param.set_engine(engine_str);
92    Net<Dtype>::CompileNet(raw_net_param, &compiled_net_param);
93    return compiled_net_param.DebugString();
94  }
95  static void CheckFile(const string& filename) {
96      std::ifstream f(filename.c_str());
97      if (!f.good()) {
98        f.close();
99        throw std::runtime_error("Could not open file " + filename);
100      }
101      f.close();
102  }
103  void CheckContiguousArray(PyArrayObject* arr, string name,
104      int channels, int height, int width) {
105    if (!(PyArray_FLAGS(arr) & NPY_ARRAY_C_CONTIGUOUS)) {
106      throw std::runtime_error(name + " must be C contiguous");
107    }
108    if (PyArray_NDIM(arr) != 4) {
109      throw std::runtime_error(name + " must be 4-d");
110    }
111    if (PyArray_TYPE(arr) != NPY_FLOAT32) {
112      throw std::runtime_error(name + " must be float32");
113    }
114    if (PyArray_DIMS(arr)[1] != channels) {
115      throw std::runtime_error(name + " has wrong number of channels");
116    }
117    if (PyArray_DIMS(arr)[2] != height) {
118      throw std::runtime_error(name + " has wrong height");
119    }
120    if (PyArray_DIMS(arr)[3] != width) {
121      throw std::runtime_error(name + " has wrong width");
122    }
123  }
124  shared_ptr<Net<Dtype> > Net_Init(string network_file, int phase,
125      const int level, const bp::object& stages,
126      const bp::object& weights,
127      const bp::object& engine) {
128    CheckFile(network_file);
129    string engine_str = "";
130    if (!engine.is_none()) {
131      engine_str = bp::extract<std::string>(engine);
132    }
133    vector<string> stages_vector;
134    if (!stages.is_none()) {
135      for (int i = 0; i < len(stages); i++) {
136        stages_vector.push_back(bp::extract<string>(stages[i]));
137      }
138    }
139    shared_ptr<Net<Dtype> > net(new Net<Dtype>(network_file,
140          static_cast<Phase>(phase), level, &stages_vector, NULL, engine_str));
141    if (!weights.is_none()) {
142      std::string weights_file_str = bp::extract<std::string>(weights);
143      CheckFile(weights_file_str);
144      net->CopyTrainedLayersFrom(weights_file_str);
145    }
146    return net;
147  }
148  shared_ptr<Net<Dtype> > Net_Init_Load(
149      string param_file, string pretrained_param_file, int phase) {
150    LOG(WARNING) << "DEPRECATION WARNING - deprecated use of Python interface";
151    LOG(WARNING) << "Use this instead (with the named \"weights\""
152      << " parameter):";
153    LOG(WARNING) << "Net('" << param_file << "', " << phase
154      << ", weights='" << pretrained_param_file << "')";
155    CheckFile(param_file);
156    CheckFile(pretrained_param_file);
157    shared_ptr<Net<Dtype> > net(new Net<Dtype>(param_file,
158        static_cast<Phase>(phase)));
159    net->CopyTrainedLayersFrom(pretrained_param_file);
160    return net;
161  }
162  void Net_Save(const Net<Dtype>& net, string filename) {
163    NetParameter net_param;
164    net.ToProto(&net_param, false);
165    WriteProtoToBinaryFile(net_param, filename.c_str());
166  }
167  void Net_SaveHDF5(const Net<Dtype>& net, string filename) {
168    net.ToHDF5(filename);
169  }
170  void Net_LoadHDF5(Net<Dtype>* net, string filename) {
171    net->CopyTrainedLayersFromHDF5(filename.c_str());
172  }
173  void Net_SetInputArrays(Net<Dtype>* net, bp::object data_obj,
174      bp::object labels_obj) {
175    shared_ptr<MemoryDataLayer<Dtype> > md_layer =
176      boost::dynamic_pointer_cast<MemoryDataLayer<Dtype> >(net->layers()[0]);
177    if (!md_layer) {
178      throw std::runtime_error("set_input_arrays may only be called if the"
179          " first layer is a MemoryDataLayer");
180    }
181    PyArrayObject* data_arr =
182        reinterpret_cast<PyArrayObject*>(data_obj.ptr());
183    PyArrayObject* labels_arr =
184        reinterpret_cast<PyArrayObject*>(labels_obj.ptr());
185    CheckContiguousArray(data_arr, "data array", md_layer->channels(),
186        md_layer->height(), md_layer->width());
187    CheckContiguousArray(labels_arr, "labels array", 1, 1, 1);
188    if (PyArray_DIMS(data_arr)[0] != PyArray_DIMS(labels_arr)[0]) {
189      throw std::runtime_error("data and labels must have the same first"
190          " dimension");
191    }
192    if (PyArray_DIMS(data_arr)[0] % md_layer->batch_size() != 0) {
193      throw std::runtime_error("first dimensions of input arrays must be a"
194          " multiple of batch size");
195    }
196    md_layer->Reset(static_cast<Dtype*>(PyArray_DATA(data_arr)),
197        static_cast<Dtype*>(PyArray_DATA(labels_arr)),
198        PyArray_DIMS(data_arr)[0]);
199  }
200  Solver<Dtype>* GetSolverFromFile(const string& filename) {
201    SolverParameter param;
202    ReadSolverParamsFromTextFileOrDie(filename, &param);
203    return SolverRegistry<Dtype>::CreateSolver(param);
204  }
205  struct NdarrayConverterGenerator {
206    template <typename T> struct apply;
207  };
208  template <>
209  struct NdarrayConverterGenerator::apply<Dtype*> {
210    struct type {
211      PyObject* operator() (Dtype* data) const {
212        return PyArray_SimpleNewFromData(0, NULL, NPY_DTYPE, data);
213      }
214      const PyTypeObject* get_pytype() {
215        return &PyArray_Type;
216      }
217    };
218  };
219  struct NdarrayCallPolicies : public bp::default_call_policies {
220    typedef NdarrayConverterGenerator result_converter;
221    PyObject* postcall(PyObject* pyargs, PyObject* result) {
222      bp::object pyblob = bp::extract<bp::tuple>(pyargs)()[0];
223      shared_ptr<Blob<Dtype> > blob =
224        bp::extract<shared_ptr<Blob<Dtype> > >(pyblob);
225      void* data = PyArray_DATA(reinterpret_cast<PyArrayObject*>(result));
226      Py_DECREF(result);
227      const int num_axes = blob->num_axes();
228      vector<npy_intp> dims(blob->shape().begin(), blob->shape().end());
229      PyObject *arr_obj = PyArray_SimpleNewFromData(num_axes, dims.data(),
230                                                    NPY_FLOAT32, data);
231      Py_INCREF(pyblob.ptr());
232      PyArray_SetBaseObject(reinterpret_cast<PyArrayObject*>(arr_obj),
233          pyblob.ptr());
234      return arr_obj;
235    }
236  };
237  bp::object Blob_Reshape(bp::tuple args, bp::dict kwargs) {
238    if (bp::len(kwargs) > 0) {
239      throw std::runtime_error("Blob.reshape takes no kwargs");
240    }
241    Blob<Dtype>* self = bp::extract<Blob<Dtype>*>(args[0]);
242    vector<int> shape(bp::len(args) - 1);
243    for (int i = 1; i < bp::len(args); ++i) {
244      shape[i - 1] = bp::extract<int>(args[i]);
245    }
246    self->Reshape(shape);
247    return bp::object();
248  }
249  bp::object BlobVec_add_blob(bp::tuple args, bp::dict kwargs) {
250    if (bp::len(kwargs) > 0) {
251      throw std::runtime_error("BlobVec.add_blob takes no kwargs");
252    }
253    typedef vector<shared_ptr<Blob<Dtype> > > BlobVec;
254    BlobVec* self = bp::extract<BlobVec*>(args[0]);
255    vector<int> shape(bp::len(args) - 1);
256    for (int i = 1; i < bp::len(args); ++i) {
257      shape[i - 1] = bp::extract<int>(args[i]);
258    }
259    self->push_back(shared_ptr<Blob<Dtype> >(new Blob<Dtype>(shape)));
260    return bp::object();
261  }
262  template<typename Dtype>
263  class PythonCallback: public Solver<Dtype>::Callback {
264   protected:
265    bp::object on_start_, on_gradients_ready_;
266   public:
267    PythonCallback(bp::object on_start, bp::object on_gradients_ready)
268      : on_start_(on_start), on_gradients_ready_(on_gradients_ready) { }
269    virtual void on_gradients_ready() {
270      on_gradients_ready_();
271    }
272    virtual void on_start() {
273      on_start_();
274    }
275  };
276  template<typename Dtype>
277  void Solver_add_callback(Solver<Dtype> * solver, bp::object on_start,
278    bp::object on_gradients_ready) {
279    solver->add_callback(new PythonCallback<Dtype>(on_start, on_gradients_ready));
280  }
281  #ifdef USE_MLSL
282  template<typename Dtype>
283  void MultiSolverBackward(MultiSolver<Dtype> * solver)
284  {
285    solver->Backward();
286  }
287  #ifdef FW_OVERLAP_OPT
288  template<typename Dtype>
289  Dtype MultiSolverUpdateAndForward(MultiSolver<Dtype> * solver)
290  {
291    return solver->UpdateAndForward();
292  }
293  #endif
294  #endif
295  BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(SolveOverloads, Solve, 0, 1);
296  BOOST_PYTHON_MODULE(_caffe) {
297    bp::scope().attr("__version__") = AS_STRING(CAFFE_VERSION);
298  #ifdef USE_MLSL
299    InitMultinode();
300    bp::class_<MultiSolver<Dtype>, shared_ptr<MultiSolver<Dtype> >, boost::noncopyable>(
301      "MultiSolver", bp::init<shared_ptr<Solver<Dtype>>>())
302      .def("update", &MultiSolver<Dtype>::WaitAndUpdate)
303  #ifdef FW_OVERLAP_OPT
304      .def("update_and_forward", &MultiSolverUpdateAndForward<Dtype>)
305  #endif
306      .def("forward", &MultiSolver<Dtype>::Forward)
307      .def("backward", &MultiSolverBackward<Dtype>)
308      .def("clear_param_diffs", &MultiSolver<Dtype>::ClearParamDiffs);
309    bp::class_<MultiSync<Dtype>> ( "MultiSync", bp::init<shared_ptr<Solver<Dtype>>>())
310       .def("init", &MultiSync<Dtype>::init)
311       .add_property("solver", &MultiSync<Dtype>::get_solver);
312  #endif
<span onclick='openModal()' class='match'>313    bp::def("_node_id", &NodeId);
314    bp::def("_num_nodes", &NumNodes);
315    bp::def("_barrier", &Barrier);
316    bp::def("init_log", &InitLog);
317    bp::def("init_log", &InitLogLevel);
318    bp::def("init_log", &InitLogLevelPipe);
319    bp::def("log", &Log);
320    bp::def("set_mode_cpu", &set_mode_cpu);
321    bp::def("set_mode_gpu", &set_mode_gpu);
322    bp::def("set_random_seed", &set_random_seed);
323    bp::def("set_device", &Caffe::SetDevice);
324    bp::def("compile_net", &compile_net);
325    bp::def("layer_type_list", &LayerRegistry<Dtype>::LayerTypeList);
</span>326    bp::class_<Net<Dtype>, shared_ptr<Net<Dtype> >, boost::noncopyable >("Net",
327      bp::no_init)
328      .def("__init__", bp::make_constructor(&Net_Init,
329            bp::default_call_policies(), (bp::arg("network_file"), "phase",
330              bp::arg("level")=0, bp::arg("stages")=bp::object(),
331              bp::arg("weights")=bp::object(),
332              bp::arg("engine")=bp::object())))
333      .def("__init__", bp::make_constructor(&Net_Init_Load))
334      .def("_forward", &Net<Dtype>::ForwardFromTo)
335      .def("_backward", &Net<Dtype>::BackwardFromTo)
336      .def("reshape", &Net<Dtype>::Reshape)
337      .def("clear_param_diffs", static_cast<void (Net<Dtype>::*)(void)>(
338      &Net<Dtype>::ClearParamDiffs))
339      .def("copy_from", static_cast<void (Net<Dtype>::*)(const string)>(
340          &Net<Dtype>::CopyTrainedLayersFrom))
341      .def("share_with", &Net<Dtype>::ShareTrainedLayersWith)
342      .add_property("_blob_loss_weights", bp::make_function(
343          &Net<Dtype>::blob_loss_weights, bp::return_internal_reference<>()))
344      .def("_bottom_ids", bp::make_function(&Net<Dtype>::bottom_ids,
345          bp::return_value_policy<bp::copy_const_reference>()))
346      .def("_top_ids", bp::make_function(&Net<Dtype>::top_ids,
347          bp::return_value_policy<bp::copy_const_reference>()))
348      .add_property("_blobs", bp::make_function(&Net<Dtype>::blobs,
349          bp::return_internal_reference<>()))
350      .add_property("layers", bp::make_function(&Net<Dtype>::layers,
351          bp::return_internal_reference<>()))
352      .add_property("_blob_names", bp::make_function(&Net<Dtype>::blob_names,
353          bp::return_value_policy<bp::copy_const_reference>()))
354      .add_property("_layer_names", bp::make_function(&Net<Dtype>::layer_names,
355          bp::return_value_policy<bp::copy_const_reference>()))
356      .add_property("_inputs", bp::make_function(&Net<Dtype>::input_blob_indices,
357          bp::return_value_policy<bp::copy_const_reference>()))
358      .add_property("_outputs",
359          bp::make_function(&Net<Dtype>::output_blob_indices,
360          bp::return_value_policy<bp::copy_const_reference>()))
361      .def("_set_input_arrays", &Net_SetInputArrays,
362          bp::with_custodian_and_ward<1, 2, bp::with_custodian_and_ward<1, 3> >())
363      .def("save", &Net_Save)
364      .def("save_hdf5", &Net_SaveHDF5)
365      .def("load_hdf5", &Net_LoadHDF5)
366      .add_property("_blob_names_index", bp::make_function(&Net<Dtype>::blob_names_index,
367          bp::return_value_policy<bp::copy_const_reference>()));
368    BP_REGISTER_SHARED_PTR_TO_PYTHON(Net<Dtype>);
369    bp::class_<Blob<Dtype>, shared_ptr<Blob<Dtype> >, boost::noncopyable>(
370      "Blob", bp::no_init)
371      .add_property("shape",
372          bp::make_function(
373              static_cast<const vector<int>& (Blob<Dtype>::*)() const>(
374                  &Blob<Dtype>::shape),
375              bp::return_value_policy<bp::copy_const_reference>()))
376      .add_property("num",      &Blob<Dtype>::num)
377      .add_property("channels", &Blob<Dtype>::channels)
378      .add_property("height",   &Blob<Dtype>::height)
379      .add_property("width",    &Blob<Dtype>::width)
380      .add_property("count",    static_cast<long (Blob<Dtype>::*)() const>(
381          &Blob<Dtype>::count))
382      .def("reshape",           bp::raw_function(&Blob_Reshape))
383      .add_property("data",     bp::make_function(&Blob<Dtype>::mutable_cpu_data,
384            NdarrayCallPolicies()))
385      .add_property("diff",     bp::make_function(&Blob<Dtype>::mutable_cpu_diff,
386            NdarrayCallPolicies()))
387  #ifdef CO_SIM
388      .add_property("data_ro",     bp::make_function(&Blob<Dtype>::cpu_data_cosim,
389            NdarrayCallPolicies()))
390      .add_property("diff_ro",     bp::make_function(&Blob<Dtype>::cpu_diff_cosim,
391            NdarrayCallPolicies()))
392  #endif
393      ;
394    BP_REGISTER_SHARED_PTR_TO_PYTHON(Blob<Dtype>);
395    bp::class_<Layer<Dtype>, shared_ptr<PythonLayer<Dtype> >,
396      boost::noncopyable>("Layer", bp::init<const LayerParameter&>())
397      .add_property("blobs", bp::make_function(&Layer<Dtype>::blobs,
398            bp::return_internal_reference<>()))
399      .def("setup", &Layer<Dtype>::LayerSetUp)
400      .def("reshape", &Layer<Dtype>::Reshape)
401      .add_property("type", bp::make_function(&Layer<Dtype>::type));
402    BP_REGISTER_SHARED_PTR_TO_PYTHON(Layer<Dtype>);
403    bp::class_<LayerParameter>("LayerParameter", bp::no_init);
404    void (Solver<Dtype>::*apply_update_function_pointer)(void) = &Solver<Dtype>::ApplyUpdate;
405    bp::class_<Solver<Dtype>, shared_ptr<Solver<Dtype> >, boost::noncopyable>(
406      "Solver", bp::no_init)
407      .add_property("net", &Solver<Dtype>::net)
408      .add_property("test_nets", bp::make_function(&Solver<Dtype>::test_nets,
409            bp::return_internal_reference<>()))
410      .add_property("iter", &Solver<Dtype>::iter)
411      .def("add_callback", &Solver_add_callback<Dtype>)
412      .def("solve", static_cast<void (Solver<Dtype>::*)(const char*)>(
413            &Solver<Dtype>::Solve), SolveOverloads())
414      .def("step", &Solver<Dtype>::Step)
415      .def("restore", &Solver<Dtype>::Restore)
416      .def("snapshot", &Solver<Dtype>::Snapshot)
417      .def("apply_update", apply_update_function_pointer)
418      .def("increment_iter", &Solver<Dtype>::increment_iter);
419    BP_REGISTER_SHARED_PTR_TO_PYTHON(Solver<Dtype>);
420    bp::class_<SGDSolver<Dtype>, bp::bases<Solver<Dtype> >,
421      shared_ptr<SGDSolver<Dtype> >, boost::noncopyable>(
422          "SGDSolver", bp::init<string>());
423    bp::class_<NesterovSolver<Dtype>, bp::bases<Solver<Dtype> >,
424      shared_ptr<NesterovSolver<Dtype> >, boost::noncopyable>(
425          "NesterovSolver", bp::init<string>());
426    bp::class_<AdaGradSolver<Dtype>, bp::bases<Solver<Dtype> >,
427      shared_ptr<AdaGradSolver<Dtype> >, boost::noncopyable>(
428          "AdaGradSolver", bp::init<string>());
429    bp::class_<RMSPropSolver<Dtype>, bp::bases<Solver<Dtype> >,
430      shared_ptr<RMSPropSolver<Dtype> >, boost::noncopyable>(
431          "RMSPropSolver", bp::init<string>());
432    bp::class_<AdaDeltaSolver<Dtype>, bp::bases<Solver<Dtype> >,
433      shared_ptr<AdaDeltaSolver<Dtype> >, boost::noncopyable>(
434          "AdaDeltaSolver", bp::init<string>());
435    bp::class_<AdamSolver<Dtype>, bp::bases<Solver<Dtype> >,
436      shared_ptr<AdamSolver<Dtype> >, boost::noncopyable>(
437          "AdamSolver", bp::init<string>());
438    bp::def("get_solver", &GetSolverFromFile,
439        bp::return_value_policy<bp::manage_new_object>());
440    bp::class_<std::map<string, int> >("MapStringInt")
441          .def(bp::map_indexing_suite<std::map<string, int> >() );
442    bp::class_<vector<shared_ptr<Blob<Dtype> > > >("BlobVec")
443      .def(bp::vector_indexing_suite<vector<shared_ptr<Blob<Dtype> > >, true>())
444      .def("add_blob", bp::raw_function(&BlobVec_add_blob));
445    bp::class_<vector<Blob<Dtype>*> >("RawBlobVec")
446      .def(bp::vector_indexing_suite<vector<Blob<Dtype>*>, true>());
447    bp::class_<vector<shared_ptr<Layer<Dtype> > > >("LayerVec")
448      .def(bp::vector_indexing_suite<vector<shared_ptr<Layer<Dtype> > >, true>());
449    bp::class_<vector<string> >("StringVec")
450      .def(bp::vector_indexing_suite<vector<string> >());
451    bp::class_<vector<int> >("IntVec")
452      .def(bp::vector_indexing_suite<vector<int> >());
453    bp::class_<vector<Dtype> >("DtypeVec")
454      .def(bp::vector_indexing_suite<vector<Dtype> >());
455    bp::class_<vector<shared_ptr<Net<Dtype> > > >("NetVec")
456      .def(bp::vector_indexing_suite<vector<shared_ptr<Net<Dtype> > >, true>());
457    bp::class_<vector<bool> >("BoolVec")
458      .def(bp::vector_indexing_suite<vector<bool> >());
459    import_array1();
460  }
461  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-PlatQt.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-_caffe.cpp</div>
                </div>
                <div class="column column_space"><pre><code>56  	void Clear();
57  public:
58  	SurfaceImpl();
59  	SurfaceImpl(int width, int height, SurfaceMode mode_);
60  	virtual ~SurfaceImpl();
61  	void Init(WindowID wid) override;
62  	void Init(SurfaceID sid, WindowID wid) override;
</pre></code></div>
                <div class="column column_space"><pre><code>313    bp::def("_node_id", &NodeId);
314    bp::def("_num_nodes", &NumNodes);
315    bp::def("_barrier", &Barrier);
316    bp::def("init_log", &InitLog);
317    bp::def("init_log", &InitLogLevel);
318    bp::def("init_log", &InitLogLevelPipe);
319    bp::def("log", &Log);
320    bp::def("set_mode_cpu", &set_mode_cpu);
321    bp::def("set_mode_gpu", &set_mode_gpu);
322    bp::def("set_random_seed", &set_random_seed);
323    bp::def("set_device", &Caffe::SetDevice);
324    bp::def("compile_net", &compile_net);
325    bp::def("layer_type_list", &LayerRegistry<Dtype>::LayerTypeList);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    