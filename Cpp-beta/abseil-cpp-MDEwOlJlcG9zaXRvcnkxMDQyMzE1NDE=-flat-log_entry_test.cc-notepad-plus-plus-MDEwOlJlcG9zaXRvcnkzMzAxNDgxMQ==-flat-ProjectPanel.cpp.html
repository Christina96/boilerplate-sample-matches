
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.650273224043716%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_entry_test.cc</h3>
            <pre><code>1  #include "absl/log/log_entry.h"
2  #include <stddef.h>
3  #include <stdint.h>
4  #include <cstring>
5  #include <limits>
6  #include <string>
7  #include <type_traits>
8  #include <utility>
9  #include <vector>
10  #include "gmock/gmock.h"
11  #include "gtest/gtest.h"
12  #include "absl/base/attributes.h"
13  #include "absl/base/config.h"
14  #include "absl/base/log_severity.h"
15  #include "absl/log/internal/append_truncated.h"
16  #include "absl/log/internal/log_format.h"
17  #include "absl/log/internal/test_helpers.h"
18  #include "absl/strings/numbers.h"
19  #include "absl/strings/str_split.h"
20  #include "absl/strings/string_view.h"
21  #include "absl/time/civil_time.h"
22  #include "absl/time/time.h"
23  #include "absl/types/span.h"
24  namespace {
25  using ::absl::log_internal::LogEntryTestPeer;
26  using ::testing::Eq;
27  using ::testing::IsTrue;
28  using ::testing::StartsWith;
29  using ::testing::StrEq;
30  auto* test_env ABSL_ATTRIBUTE_UNUSED = ::testing::AddGlobalTestEnvironment(
31      new absl::log_internal::LogTestEnvironment);
32  }  
33  namespace absl {
34  ABSL_NAMESPACE_BEGIN
35  namespace log_internal {
36  class LogEntryTestPeer {
37   public:
38    LogEntryTestPeer(absl::string_view base_filename, int line, bool prefix,
39                     absl::LogSeverity severity, absl::string_view timestamp,
40                     absl::LogEntry::tid_t tid, PrefixFormat format,
41                     absl::string_view text_message)
42        : format_{format}, buf_(15000, '\0') {
43      entry_.base_filename_ = base_filename;
44      entry_.line_ = line;
45      entry_.prefix_ = prefix;
46      entry_.severity_ = severity;
47      std::string time_err;
48      EXPECT_THAT(
49          absl::ParseTime("%Y-%m-%d%ET%H:%M:%E*S", timestamp,
50                          absl::LocalTimeZone(), &entry_.timestamp_, &time_err),
51          IsTrue())
52          << "Failed to parse time " << timestamp << ": " << time_err;
53      entry_.tid_ = tid;
54      std::pair<absl::string_view, std::string> timestamp_bits =
55          absl::StrSplit(timestamp, absl::ByChar('.'));
56      EXPECT_THAT(absl::ParseCivilTime(timestamp_bits.first, &ci_.cs), IsTrue())
57          << "Failed to parse time " << timestamp_bits.first;
58      timestamp_bits.second.resize(9, '0');
59      int64_t nanos = 0;
60      EXPECT_THAT(absl::SimpleAtoi(timestamp_bits.second, &nanos), IsTrue())
61          << "Failed to parse time " << timestamp_bits.first;
62      ci_.subsecond = absl::Nanoseconds(nanos);
63      absl::Span<char> view = absl::MakeSpan(buf_);
64      view.remove_suffix(2);
65      entry_.prefix_len_ =
66          entry_.prefix_
67              ? log_internal::FormatLogPrefix(
68                    entry_.log_severity(), entry_.timestamp(), entry_.tid(),
69                    entry_.source_basename(), entry_.source_line(), format_, view)
70              : 0;
71      EXPECT_THAT(entry_.prefix_len_,
72                  Eq(static_cast<size_t>(view.data() - buf_.data())));
73      log_internal::AppendTruncated(text_message, view);
74      view = absl::Span<char>(view.data(), view.size() + 2);
75      view[0] = '\n';
76      view[1] = '\0';
77      view.remove_prefix(2);
78      buf_.resize(static_cast<size_t>(view.data() - buf_.data()));
79      entry_.text_message_with_prefix_and_newline_and_nul_ = absl::MakeSpan(buf_);
80    }
81    LogEntryTestPeer(const LogEntryTestPeer&) = delete;
82    LogEntryTestPeer& operator=(const LogEntryTestPeer&) = delete;
83    std::string FormatLogMessage() const {
84      return log_internal::FormatLogMessage(
85          entry_.log_severity(), ci_.cs, ci_.subsecond, entry_.tid(),
86          entry_.source_basename(), entry_.source_line(), format_,
87          entry_.text_message());
88    }
89    std::string FormatPrefixIntoSizedBuffer(size_t sz) {
90      std::string str(sz, '\0');
91      absl::Span<char> buf(&str[0], str.size());
92      const size_t prefix_size = log_internal::FormatLogPrefix(
93          entry_.log_severity(), entry_.timestamp(), entry_.tid(),
94          entry_.source_basename(), entry_.source_line(), format_, buf);
95      EXPECT_THAT(prefix_size, Eq(static_cast<size_t>(buf.data() - str.data())));
96      str.resize(prefix_size);
97      return str;
98    }
99    const absl::LogEntry& entry() const { return entry_; }
100   private:
101    absl::LogEntry entry_;
102    PrefixFormat format_;
103    absl::TimeZone::CivilInfo ci_;
104    std::vector<char> buf_;
105  };
106  }  
107  ABSL_NAMESPACE_END
108  }  
109  namespace {
110  constexpr bool kUsePrefix = true, kNoPrefix = false;
111  TEST(LogEntryTest, Baseline) {
112    LogEntryTestPeer entry("foo.cc", 1234, kUsePrefix, absl::LogSeverity::kInfo,
113                           "2020-01-02T03:04:05.6789", 451,
114                           absl::log_internal::PrefixFormat::kNotRaw,
115                           "hello world");
116    EXPECT_THAT(entry.FormatLogMessage(),
117                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world"));
118    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
119                Eq("I0102 03:04:05.678900     451 foo.cc:1234] "));
120    for (size_t sz = strlen("I0102 03:04:05.678900     451 foo.cc:1234] ") + 20;
121         sz != std::numeric_limits<size_t>::max(); sz--)
122      EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:1234] ",
123                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
124    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
125                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world\n"));
126    EXPECT_THAT(
127        entry.entry().text_message_with_prefix_and_newline_c_str(),
128        StrEq("I0102 03:04:05.678900     451 foo.cc:1234] hello world\n"));
129    EXPECT_THAT(entry.entry().text_message_with_prefix(),
130                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world"));
131    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
132  }
133  TEST(LogEntryTest, NoPrefix) {
134    LogEntryTestPeer entry("foo.cc", 1234, kNoPrefix, absl::LogSeverity::kInfo,
135                           "2020-01-02T03:04:05.6789", 451,
136                           absl::log_internal::PrefixFormat::kNotRaw,
137                           "hello world");
138    EXPECT_THAT(entry.FormatLogMessage(),
139                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world"));
140    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
141                Eq("I0102 03:04:05.678900     451 foo.cc:1234] "));
142    for (size_t sz = strlen("I0102 03:04:05.678900     451 foo.cc:1234] ") + 20;
143         sz != std::numeric_limits<size_t>::max(); sz--)
144      EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:1234] ",
145                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
146    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
147                Eq("hello world\n"));
148    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline_c_str(),
149                StrEq("hello world\n"));
150    EXPECT_THAT(entry.entry().text_message_with_prefix(), Eq("hello world"));
151    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
152  }
153  TEST(LogEntryTest, EmptyFields) {
154    LogEntryTestPeer entry("", 0, kUsePrefix, absl::LogSeverity::kInfo,
155                           "2020-01-02T03:04:05", 0,
156                           absl::log_internal::PrefixFormat::kNotRaw, "");
157    const std::string format_message = entry.FormatLogMessage();
158    EXPECT_THAT(format_message, Eq("I0102 03:04:05.000000       0 :0] "));
159    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000), Eq(format_message));
160    for (size_t sz = format_message.size() + 20;
161         sz != std::numeric_limits<size_t>::max(); sz--)
162      EXPECT_THAT(format_message,
163                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
164    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
165                Eq("I0102 03:04:05.000000       0 :0] \n"));
166    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline_c_str(),
167                StrEq("I0102 03:04:05.000000       0 :0] \n"));
168    EXPECT_THAT(entry.entry().text_message_with_prefix(),
169                Eq("I0102 03:04:05.000000       0 :0] "));
170    EXPECT_THAT(entry.entry().text_message(), Eq(""));
171  }
172  TEST(LogEntryTest, NegativeFields) {
173    if (std::is_signed<absl::LogEntry::tid_t>::value) {
174      LogEntryTestPeer entry(
175          "foo.cc", -1234, kUsePrefix, absl::LogSeverity::kInfo,
176          "2020-01-02T03:04:05.6789", static_cast<absl::LogEntry::tid_t>(-451),
177          absl::log_internal::PrefixFormat::kNotRaw, "hello world");
178      EXPECT_THAT(entry.FormatLogMessage(),
179                  Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world"));
180      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
181                  Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] "));
182      for (size_t sz =
183               strlen("I0102 03:04:05.678900    -451 foo.cc:-1234] ") + 20;
184           sz != std::numeric_limits<size_t>::max(); sz--)
185        EXPECT_THAT("I0102 03:04:05.678900    -451 foo.cc:-1234] ",
186                    StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
187      EXPECT_THAT(
188          entry.entry().text_message_with_prefix_and_newline(),
189          Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world\n"));
190      EXPECT_THAT(
191          entry.entry().text_message_with_prefix_and_newline_c_str(),
192          StrEq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world\n"));
193      EXPECT_THAT(entry.entry().text_message_with_prefix(),
194                  Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world"));
195      EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
196    } else {
197      LogEntryTestPeer entry("foo.cc", -1234, kUsePrefix,
198                             absl::LogSeverity::kInfo, "2020-01-02T03:04:05.6789",
199                             451, absl::log_internal::PrefixFormat::kNotRaw,
200                             "hello world");
201      EXPECT_THAT(entry.FormatLogMessage(),
202                  Eq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world"));
203      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
204                  Eq("I0102 03:04:05.678900     451 foo.cc:-1234] "));
205      for (size_t sz =
206               strlen("I0102 03:04:05.678900     451 foo.cc:-1234] ") + 20;
207           sz != std::numeric_limits<size_t>::max(); sz--)
208        EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:-1234] ",
209                    StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
210      EXPECT_THAT(
211          entry.entry().text_message_with_prefix_and_newline(),
212          Eq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world\n"));
213      EXPECT_THAT(
214          entry.entry().text_message_with_prefix_and_newline_c_str(),
215          StrEq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world\n"));
216      EXPECT_THAT(entry.entry().text_message_with_prefix(),
217                  Eq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world"));
218      EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
219    }
220  }
221  TEST(LogEntryTest, LongFields) {
222    LogEntryTestPeer entry(
223        "I am the very model of a modern Major-General / "
224        "I've information vegetable, animal, and mineral.",
225        2147483647, kUsePrefix, absl::LogSeverity::kInfo,
226        "2020-01-02T03:04:05.678967896789", 2147483647,
227        absl::log_internal::PrefixFormat::kNotRaw,
228        "I know the kings of England, and I quote the fights historical / "
229        "From Marathon to Waterloo, in order categorical.");
230    EXPECT_THAT(entry.FormatLogMessage(),
231                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
232                   "modern Major-General / I've information vegetable, animal, "
233                   "and mineral.:2147483647] I know the kings of England, and I "
234                   "quote the fights historical / From Marathon to Waterloo, in "
235                   "order categorical."));
236    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
237                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
238                   "modern Major-General / I've information vegetable, animal, "
239                   "and mineral.:2147483647] "));
240    for (size_t sz =
241             strlen("I0102 03:04:05.678967 2147483647 I am the very model of a "
242                    "modern Major-General / I've information vegetable, animal, "
243                    "and mineral.:2147483647] ") +
244             20;
245         sz != std::numeric_limits<size_t>::max(); sz--)
246      EXPECT_THAT(
247          "I0102 03:04:05.678967 2147483647 I am the very model of a "
248          "modern Major-General / I've information vegetable, animal, "
249          "and mineral.:2147483647] ",
250          StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
251    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
252                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
253                   "modern Major-General / I've information vegetable, animal, "
254                   "and mineral.:2147483647] I know the kings of England, and I "
255                   "quote the fights historical / From Marathon to Waterloo, in "
256                   "order categorical.\n"));
257    EXPECT_THAT(
258        entry.entry().text_message_with_prefix_and_newline_c_str(),
259        StrEq("I0102 03:04:05.678967 2147483647 I am the very model of a "
260              "modern Major-General / I've information vegetable, animal, "
261              "and mineral.:2147483647] I know the kings of England, and I "
262              "quote the fights historical / From Marathon to Waterloo, in "
263              "order categorical.\n"));
264    EXPECT_THAT(entry.entry().text_message_with_prefix(),
<span onclick='openModal()' class='match'>265                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
266                   "modern Major-General / I've information vegetable, animal, "
267                   "and mineral.:2147483647] I know the kings of England, and I "
268                   "quote the fights historical / From Marathon to Waterloo, in "
269                   "order categorical."));
270    EXPECT_THAT(
271        entry.entry().text_message(),
272        Eq("I know the kings of England, and I quote the fights historical / "
273           "From Marathon to Waterloo, in order categorical."));
274  }
275  TEST(LogEntryTest, LongNegativeFields) {
276    if (std::is_signed<absl::LogEntry::tid_t>::value) {
</span>277      LogEntryTestPeer entry(
278          "I am the very model of a modern Major-General / "
279          "I've information vegetable, animal, and mineral.",
280          -2147483647, kUsePrefix, absl::LogSeverity::kInfo,
281          "2020-01-02T03:04:05.678967896789",
282          static_cast<absl::LogEntry::tid_t>(-2147483647),
283          absl::log_internal::PrefixFormat::kNotRaw,
284          "I know the kings of England, and I quote the fights historical / "
285          "From Marathon to Waterloo, in order categorical.");
286      EXPECT_THAT(
287          entry.FormatLogMessage(),
288          Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
289             "modern Major-General / I've information vegetable, animal, "
290             "and mineral.:-2147483647] I know the kings of England, and I "
291             "quote the fights historical / From Marathon to Waterloo, in "
292             "order categorical."));
293      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
294                  Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
295                     "modern Major-General / I've information vegetable, animal, "
296                     "and mineral.:-2147483647] "));
297      for (size_t sz =
298               strlen(
299                   "I0102 03:04:05.678967 -2147483647 I am the very model of a "
300                   "modern Major-General / I've information vegetable, animal, "
301                   "and mineral.:-2147483647] ") +
302               20;
303           sz != std::numeric_limits<size_t>::max(); sz--)
304        EXPECT_THAT(
305            "I0102 03:04:05.678967 -2147483647 I am the very model of a "
306            "modern Major-General / I've information vegetable, animal, "
307            "and mineral.:-2147483647] ",
308            StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
309      EXPECT_THAT(
310          entry.entry().text_message_with_prefix_and_newline(),
311          Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
312             "modern Major-General / I've information vegetable, animal, "
313             "and mineral.:-2147483647] I know the kings of England, and I "
314             "quote the fights historical / From Marathon to Waterloo, in "
315             "order categorical.\n"));
316      EXPECT_THAT(
317          entry.entry().text_message_with_prefix_and_newline_c_str(),
318          StrEq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
319                "modern Major-General / I've information vegetable, animal, "
320                "and mineral.:-2147483647] I know the kings of England, and I "
321                "quote the fights historical / From Marathon to Waterloo, in "
322                "order categorical.\n"));
323      EXPECT_THAT(
324          entry.entry().text_message_with_prefix(),
325          Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
326             "modern Major-General / I've information vegetable, animal, "
327             "and mineral.:-2147483647] I know the kings of England, and I "
328             "quote the fights historical / From Marathon to Waterloo, in "
329             "order categorical."));
330      EXPECT_THAT(
331          entry.entry().text_message(),
332          Eq("I know the kings of England, and I quote the fights historical / "
333             "From Marathon to Waterloo, in order categorical."));
334    } else {
335      LogEntryTestPeer entry(
336          "I am the very model of a modern Major-General / "
337          "I've information vegetable, animal, and mineral.",
338          -2147483647, kUsePrefix, absl::LogSeverity::kInfo,
339          "2020-01-02T03:04:05.678967896789", 2147483647,
340          absl::log_internal::PrefixFormat::kNotRaw,
341          "I know the kings of England, and I quote the fights historical / "
342          "From Marathon to Waterloo, in order categorical.");
343      EXPECT_THAT(
344          entry.FormatLogMessage(),
345          Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
346             "modern Major-General / I've information vegetable, animal, "
347             "and mineral.:-2147483647] I know the kings of England, and I "
348             "quote the fights historical / From Marathon to Waterloo, in "
349             "order categorical."));
350      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
351                  Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
352                     "modern Major-General / I've information vegetable, animal, "
353                     "and mineral.:-2147483647] "));
354      for (size_t sz =
355               strlen(
356                   "I0102 03:04:05.678967 2147483647 I am the very model of a "
357                   "modern Major-General / I've information vegetable, animal, "
358                   "and mineral.:-2147483647] ") +
359               20;
360           sz != std::numeric_limits<size_t>::max(); sz--)
361        EXPECT_THAT(
362            "I0102 03:04:05.678967 2147483647 I am the very model of a "
363            "modern Major-General / I've information vegetable, animal, "
364            "and mineral.:-2147483647] ",
365            StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
366      EXPECT_THAT(
367          entry.entry().text_message_with_prefix_and_newline(),
368          Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
369             "modern Major-General / I've information vegetable, animal, "
370             "and mineral.:-2147483647] I know the kings of England, and I "
371             "quote the fights historical / From Marathon to Waterloo, in "
372             "order categorical.\n"));
373      EXPECT_THAT(
374          entry.entry().text_message_with_prefix_and_newline_c_str(),
375          StrEq("I0102 03:04:05.678967 2147483647 I am the very model of a "
376                "modern Major-General / I've information vegetable, animal, "
377                "and mineral.:-2147483647] I know the kings of England, and I "
378                "quote the fights historical / From Marathon to Waterloo, in "
379                "order categorical.\n"));
380      EXPECT_THAT(
381          entry.entry().text_message_with_prefix(),
382          Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
383             "modern Major-General / I've information vegetable, animal, "
384             "and mineral.:-2147483647] I know the kings of England, and I "
385             "quote the fights historical / From Marathon to Waterloo, in "
386             "order categorical."));
387      EXPECT_THAT(
388          entry.entry().text_message(),
389          Eq("I know the kings of England, and I quote the fights historical / "
390             "From Marathon to Waterloo, in order categorical."));
391    }
392  }
393  TEST(LogEntryTest, Raw) {
394    LogEntryTestPeer entry("foo.cc", 1234, kUsePrefix, absl::LogSeverity::kInfo,
395                           "2020-01-02T03:04:05.6789", 451,
396                           absl::log_internal::PrefixFormat::kRaw, "hello world");
397    EXPECT_THAT(
398        entry.FormatLogMessage(),
399        Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world"));
400    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
401                Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: "));
402    for (size_t sz =
403             strlen("I0102 03:04:05.678900     451 foo.cc:1234] RAW: ") + 20;
404         sz != std::numeric_limits<size_t>::max(); sz--)
405      EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:1234] RAW: ",
406                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
407    EXPECT_THAT(
408        entry.entry().text_message_with_prefix_and_newline(),
409        Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world\n"));
410    EXPECT_THAT(
411        entry.entry().text_message_with_prefix_and_newline_c_str(),
412        StrEq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world\n"));
413    EXPECT_THAT(
414        entry.entry().text_message_with_prefix(),
415        Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world"));
416    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
417  }
418  }  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</h3>
            <pre><code>1  #include <windowsx.h>
2  #include "ProjectPanel.h"
3  #include "resource.h"
4  #include "CustomFileDialog.h"
5  #include "localization.h"
6  #include "Parameters.h"
7  #define INDEX_CLEAN_ROOT     0
8  #define INDEX_DIRTY_ROOT     1
9  #define INDEX_PROJECT        2
10  #define INDEX_OPEN_NODE	     3
11  #define INDEX_CLOSED_NODE    4
12  #define INDEX_LEAF           5
13  #define INDEX_LEAF_INVALID   6
14  ProjectPanel::~ProjectPanel()
15  {
16  	for (const auto& s : fullPathStrs)
17  	{
18  		delete s;
19  	}
20  }
21  intptr_t CALLBACK ProjectPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
22  {
23  	switch (message)
24  	{
25  		case WM_INITDIALOG :
26  		{
27  			ProjectPanel::initMenus();
28  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST;
29  			_hToolbarMenu = CreateWindowEx(0,TOOLBARCLASSNAME,NULL, style,
30  								   0,0,0,0,_hSelf, nullptr, _hInst, nullptr);
31  			TBBUTTON tbButtons[2]{};
32  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
33  			generic_string workspace_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 0, PM_WORKSPACEMENUENTRY);
34  			generic_string edit_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 1, PM_EDITMENUENTRY);
35  			tbButtons[0].idCommand = IDB_PROJECT_BTN;
36  			tbButtons[0].iBitmap = I_IMAGENONE;
37  			tbButtons[0].fsState = TBSTATE_ENABLED;
38  			tbButtons[0].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
39  			tbButtons[0].iString = (intptr_t)workspace_entry.c_str();
40  			tbButtons[1].idCommand = IDB_EDIT_BTN;
41  			tbButtons[1].iBitmap = I_IMAGENONE;
42  			tbButtons[1].fsState = TBSTATE_ENABLED;
43  			tbButtons[1].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
44  			tbButtons[1].iString = (intptr_t)edit_entry.c_str();
45  			SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
46  			SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
47  			SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0); 
48  			ShowWindow(_hToolbarMenu, SW_SHOW);
49  			_treeView.init(_hInst, _hSelf, ID_PROJECTTREEVIEW);
50  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 7, IDI_PROJECT_WORKSPACE, IDI_PROJECT_WORKSPACEDIRTY, IDI_PROJECT_PROJECT, IDI_PROJECT_FOLDEROPEN, IDI_PROJECT_FOLDERCLOSE, IDI_PROJECT_FILE, IDI_PROJECT_FILEINVALID);
51  			_treeView.addCanNotDropInList(INDEX_LEAF);
52  			_treeView.addCanNotDropInList(INDEX_LEAF_INVALID);
53  			_treeView.addCanNotDragOutList(INDEX_CLEAN_ROOT);
54  			_treeView.addCanNotDragOutList(INDEX_DIRTY_ROOT);
55  			_treeView.addCanNotDragOutList(INDEX_PROJECT);
56  			_treeView.display();
57  			if (!openWorkSpace(_workSpaceFilePath.c_str(), true))
58  				newWorkSpace();
59  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
60  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
61  			return TRUE;
62  		}
63  		case NPPM_INTERNAL_REFRESHDARKMODE:
64  		{
65  			if (static_cast<BOOL>(lParam) != TRUE)
66  			{
67  				NppDarkMode::autoThemeChildControls(_hSelf);
68  			}
69  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
70  			return TRUE;
71  		}
72  		case WM_MOUSEMOVE:
73  			if (_treeView.isDragging())
74  				_treeView.dragItem(_hSelf, LOWORD(lParam), HIWORD(lParam));
75  			break;
76  		case WM_LBUTTONUP:
77  			if (_treeView.isDragging())
78  				if (_treeView.dropItem())
79  					setWorkSpaceDirty(true);
80  			break;
81  		case WM_NOTIFY:
82  		{
83  			notified((LPNMHDR)lParam);
84  		}
85  		return TRUE;
86  		case WM_SIZE:
87  		{
88  			int width = LOWORD(lParam);
89  			int height = HIWORD(lParam);
90  			RECT toolbarMenuRect{};
91  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
92  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
93  			HWND hwnd = _treeView.getHSelf();
94  			if (hwnd)
95  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + 2, width, height - toolbarMenuRect.bottom - 2, TRUE);
96  			break;
97  		}
98  		case WM_CONTEXTMENU:
99  			if (!_treeView.isDragging())
100  			{
101  				int xPos = GET_X_LPARAM(lParam);
102  				int yPos = GET_Y_LPARAM(lParam);
103  				if (xPos == -1 && yPos == -1)
104  				{
105  					HTREEITEM selectedItem = _treeView.getSelection();
106  					if (selectedItem)
107  					{
108  						RECT selectedItemRect{};
109  						if (TreeView_GetItemRect(_treeView.getHSelf(), selectedItem, &selectedItemRect, TRUE))
110  						{
111  							showContextMenuFromMenuKey(selectedItem, (selectedItemRect.left + selectedItemRect.right) / 2, (selectedItemRect.top + selectedItemRect.bottom) / 2);
112  						}
113  					}
114  				}
115  				else
116  				{
117  					showContextMenu(xPos, yPos);
118  				}
119  			}
120  		return TRUE;
121  		case WM_COMMAND:
122  		{
123  			popupMenuCmd(LOWORD(wParam));
124  			break;
125  		}
126  		case WM_DESTROY:
127  		{
128  			_treeView.destroy();
129  			destroyMenus();
130  			::DestroyWindow(_hToolbarMenu);
131  			break;
132  		}
133  		default :
134  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
135  	}
136  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
137  }
138  bool ProjectPanel::checkIfNeedSave()
139  {
140  	if (_isDirty)
141  	{
142  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
143  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
144  		int res = pNativeSpeaker->messageBox("ProjectPanelChanged",
145  			_hSelf,
146  			TEXT("The workspace was modified. Do you want to save it?"),
147  			TEXT("$STR_REPLACE$"),
148  			MB_YESNOCANCEL | MB_ICONQUESTION,
149  			0,
150  			title);
151  		if (res == IDYES)
152  		{
153  			if (!saveWorkSpace())
154  				return false;
155  		}
156  		else if (res == IDNO)
157  		{
158  		}
159  		else
160  		{
161  			return false;
162  		}
163  	}
164  	return true;
165  }
166  void ProjectPanel::initMenus()
167  {
168  	_hWorkSpaceMenu = ::CreatePopupMenu();
169  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
170  	generic_string new_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWWS, PM_NEWWORKSPACE);
171  	generic_string open_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_OPENWS, PM_OPENWORKSPACE);
172  	generic_string reload_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_RELOADWS, PM_RELOADWORKSPACE);
173  	generic_string save_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEWS, PM_SAVEWORKSPACE);
174  	generic_string saveas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEASWS, PM_SAVEASWORKSPACE);
175  	generic_string saveacopyas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEACOPYASWS, PM_SAVEACOPYASWORKSPACE);
176  	generic_string newproject_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWPROJECT, PM_NEWPROJECTWORKSPACE);
177  	generic_string findinprojects_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_FINDINPROJECTSWS, PM_FINDINFILESWORKSPACE);
178  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWWS, new_workspace.c_str());
179  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_OPENWS, open_workspace.c_str());
180  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RELOADWS, reload_workspace.c_str());
181  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEWS, save_workspace.c_str());
182  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEASWS, saveas_workspace.c_str());
183  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEACOPYASWS, saveacopyas_workspace.c_str());
184  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
185  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWPROJECT, newproject_workspace.c_str());
186  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
187  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_FINDINPROJECTSWS, findinprojects_workspace.c_str());
188  	generic_string edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
189  	generic_string edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
190  	generic_string edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
191  	generic_string edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
192  	generic_string edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
193  	generic_string edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
194  	generic_string edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
195  	_hProjectMenu = ::CreatePopupMenu();
196  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
197  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
198  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
199  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
200  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER, edit_addfolder.c_str());
201  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES, edit_addfiles.c_str());
202  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
203  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER, edit_remove.c_str());
204  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
205  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
206  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
207  	edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
208  	edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
209  	edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
210  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
211  	_hFolderMenu = ::CreatePopupMenu();
212  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP,        edit_moveup.c_str());
213  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN,      edit_movedown.c_str());
214  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
215  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME,        edit_rename.c_str());
216  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER,     edit_addfolder.c_str());
217  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES,      edit_addfiles.c_str());
218  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
219  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER,  edit_remove.c_str());
220  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
221  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
222  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
223  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_DELETEFILE, PM_EDITREMOVE);
224  	generic_string edit_modifyfile = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MODIFYFILEPATH, PM_EDITMODIFYFILE);
225  	_hFileMenu = ::CreatePopupMenu();
226  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
227  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
228  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
229  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
230  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFILE, edit_remove.c_str());
231  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MODIFYFILEPATH, edit_modifyfile.c_str());
232  }
233  void ProjectPanel::destroyMenus() 
234  {
<span onclick='openModal()' class='match'>235  	::DestroyMenu(_hWorkSpaceMenu);
236  	::DestroyMenu(_hProjectMenu);
237  	::DestroyMenu(_hFolderMenu);
238  	::DestroyMenu(_hFileMenu);
239  }
240  bool ProjectPanel::openWorkSpace(const TCHAR *projectFileName, bool force)
241  {
242  	if ((!force) && (_workSpaceFilePath.length() > 0))
</span>243  	{ 
244  		generic_string newWorkspace = projectFileName;
245  		if (newWorkspace == _workSpaceFilePath)
246  			return true;
247  		if (!saveWorkspaceRequest())
248  			return true;
249  	}
250  	TiXmlDocument *pXmlDocProject = new TiXmlDocument(projectFileName);
251  	bool loadOkay = pXmlDocProject->LoadFile();
252  	if (!loadOkay)
253  	{
254  		delete pXmlDocProject;
255  		return false;
256  	}
257  	TiXmlNode *root = pXmlDocProject->FirstChild(TEXT("NotepadPlus"));
258  	if (!root) 
259  	{
260  		delete pXmlDocProject;
261  		return false;
262  	}
263  	TiXmlNode *childNode = root->FirstChildElement(TEXT("Project"));
264  	if (!childNode) 
265  	{
266  		delete pXmlDocProject;
267  		return false;
268  	}
269  	if (!::PathFileExists(projectFileName))
270  	{
271  		delete pXmlDocProject;
272  		return false;
273  	}
274  	_treeView.removeAllItems();
275  	_workSpaceFilePath = projectFileName;
276  	TCHAR * fileName = PathFindFileName(projectFileName);
277  	HTREEITEM rootItem = _treeView.addItem(fileName, TVI_ROOT, INDEX_CLEAN_ROOT);
278  	for ( ; childNode ; childNode = childNode->NextSibling(TEXT("Project")))
279  	{
280  		HTREEITEM projectItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), rootItem, INDEX_PROJECT);
281  		buildTreeFrom(childNode, projectItem);
282  	}
283  	setWorkSpaceDirty(false);
284  	_treeView.expand(rootItem);
285  	delete pXmlDocProject;
286  	return loadOkay;
287  }
288  void ProjectPanel::newWorkSpace()
289  {
290  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
291  	generic_string workspace = pNativeSpeaker->getAttrNameStr(PM_WORKSPACEROOTNAME, "ProjectManager", "WorkspaceRootName");
292  	_treeView.addItem(workspace.c_str(), TVI_ROOT, INDEX_CLEAN_ROOT);
293  	setWorkSpaceDirty(false);
294  	_workSpaceFilePath = TEXT("");
295  }
296  bool ProjectPanel::saveWorkSpace()
297  {
298  	if (_workSpaceFilePath == TEXT(""))
299  	{
300  		return saveWorkSpaceAs(false);
301  	}
302  	else
303  	{
304  		if (!writeWorkSpace())
305  			return false;
306  		setWorkSpaceDirty(false);
307  		return true;
308  	} 
309  }
310  bool ProjectPanel::writeWorkSpace(const TCHAR *projectFileName, bool doUpdateGUI)
311  {
312  	const TCHAR * fn2write = projectFileName?projectFileName:_workSpaceFilePath.c_str();
313  	TiXmlDocument projDoc(fn2write);
314  	TiXmlNode *root = projDoc.InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
315  	TCHAR textBuffer[MAX_PATH] = { '\0' };
316  	TVITEM tvItem{};
317  	tvItem.mask = TVIF_TEXT;
318  	tvItem.pszText = textBuffer;
319  	tvItem.cchTextMax = MAX_PATH;
320  	HTREEITEM tvRoot = _treeView.getRoot();
321  	if (!tvRoot)
322  		return false;
323  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
324  		tvProj != NULL;
325  		tvProj = _treeView.getNextSibling(tvProj))
326  	{
327  		tvItem.hItem = tvProj;
328  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
329  		TiXmlNode *projRoot = root->InsertEndChild(TiXmlElement(TEXT("Project")));
330  		projRoot->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
331  		buildProjectXml(projRoot, tvProj, fn2write);
332  	}
333  	if (!projDoc.SaveFile())
334  	{
335  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
336  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
337  		pNativeSpeaker->messageBox("ProjectPanelSaveError",
338  		_hSelf,
339  		TEXT("An error occurred while writing your workspace file.\nYour workspace has not been saved."),
340  		TEXT("$STR_REPLACE$"),
341  		MB_OK | MB_ICONERROR,
342  		0,
343  		title);
344  		return false;
345  	}
346  	TCHAR * fileName = PathFindFileName(fn2write);
347  	if (doUpdateGUI)
348  	{
349  		_treeView.renameItem(tvRoot, fileName);
350  	}
351  	return true;
352  }
353  void ProjectPanel::buildProjectXml(TiXmlNode *node, HTREEITEM hItem, const TCHAR* fn2write)
354  {
355  	TCHAR textBuffer[MAX_PATH] = { '\0' };
356  	TVITEM tvItem{};
357  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
358  	tvItem.pszText = textBuffer;
359  	tvItem.cchTextMax = MAX_PATH;
360  	for (HTREEITEM hItemNode = _treeView.getChildFrom(hItem);
361  		hItemNode != NULL;
362  		hItemNode = _treeView.getNextSibling(hItemNode))
363  	{
364  		tvItem.hItem = hItemNode;
365  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
366  		if (tvItem.lParam)
367  		{
368  			generic_string *fn = (generic_string *)tvItem.lParam;
369  			generic_string newFn = getRelativePath(*fn, fn2write);
370  			TiXmlNode *fileLeaf = node->InsertEndChild(TiXmlElement(TEXT("File")));
371  			fileLeaf->ToElement()->SetAttribute(TEXT("name"), newFn.c_str());
372  		}
373  		else
374  		{
375  			TiXmlNode *folderNode = node->InsertEndChild(TiXmlElement(TEXT("Folder")));
376  			folderNode->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
377  			buildProjectXml(folderNode, hItemNode, fn2write);
378  		}
379  	}
380  }
381  bool ProjectPanel::enumWorkSpaceFiles(HTREEITEM tvFrom, const std::vector<generic_string> & patterns, std::vector<generic_string> & fileNames)
382  {
383  	TCHAR textBuffer[MAX_PATH] = { '\0' };
384  	TVITEM tvItem{};
385  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
386  	tvItem.pszText = textBuffer;
387  	tvItem.cchTextMax = MAX_PATH;
388  	HTREEITEM tvRoot = tvFrom ? tvFrom : _treeView.getRoot();
389  	if (!tvRoot) return false;
390  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
391  		tvProj != NULL;
392  		tvProj = _treeView.getNextSibling(tvProj))
393  	{
394  		tvItem.hItem = tvProj;
395  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
396  		if (tvItem.lParam)
397  		{
398  			if (matchInList(tvItem.pszText, patterns))
399  			{
400  				generic_string *fn = (generic_string *)tvItem.lParam;
401  				fileNames.push_back (*fn);
402  			}
403  		}
404  		else
405  		{
406  			if (!enumWorkSpaceFiles (tvProj, patterns, fileNames)) return false;
407  		}
408  	}
409  	return true;
410  }
411  generic_string ProjectPanel::getRelativePath(const generic_string & filePath, const TCHAR *workSpaceFileName)
412  {
413  	TCHAR wsfn[MAX_PATH] = { '\0' };
414  	wcscpy_s(wsfn, workSpaceFileName);
415  	::PathRemoveFileSpec(wsfn);
416  	size_t pos_found = filePath.find(wsfn);
417  	if (pos_found == generic_string::npos)
418  		return filePath;
419  	const TCHAR *relativeFile = filePath.c_str() + lstrlen(wsfn);
420  	if (relativeFile[0] == '\\')
421  		++relativeFile;
422  	return relativeFile;
423  }
424  bool ProjectPanel::buildTreeFrom(TiXmlNode *projectRoot, HTREEITEM hParentItem)
425  {
426  	for (TiXmlNode *childNode = projectRoot->FirstChildElement();
427  		childNode ;
428  		childNode = childNode->NextSibling())
429  	{
430  		const TCHAR *v = childNode->Value();
431  		if (lstrcmp(TEXT("Folder"), v) == 0)
432  		{
433  			HTREEITEM addedItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), hParentItem, INDEX_CLOSED_NODE);
434  			if (!childNode->NoChildren())
435  			{
436  				bool isOK = buildTreeFrom(childNode, addedItem);
437  				if (!isOK)
438  					return false;
439  			}
440  		}
441  		else if (lstrcmp(TEXT("File"), v) == 0)
442  		{
443  			const TCHAR *strValue = (childNode->ToElement())->Attribute(TEXT("name"));
444  			generic_string fullPath = getAbsoluteFilePath(strValue);
445  			TCHAR *strValueLabel = ::PathFindFileName(strValue);
446  			int iImage = ::PathFileExists(fullPath.c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
447  			generic_string* fullPathStr = new generic_string(fullPath);
448  			fullPathStrs.push_back(fullPathStr);
449  			LPARAM lParamFullPathStr = reinterpret_cast<LPARAM>(fullPathStr);
450  			_treeView.addItem(strValueLabel, hParentItem, iImage, lParamFullPathStr);
451  		}
452  	}
453  	return true;
454  }
455  generic_string ProjectPanel::getAbsoluteFilePath(const TCHAR * relativePath)
456  {
457  	if (!::PathIsRelative(relativePath))
458  		return relativePath;
459  	TCHAR absolutePath[MAX_PATH] = { '\0' };
460  	wcscpy_s(absolutePath, _workSpaceFilePath.c_str());
461  	::PathRemoveFileSpec(absolutePath);
462  	::PathAppend(absolutePath, relativePath);
463  	return absolutePath;
464  }
465  void ProjectPanel::openSelectFile()
466  {
467  	TVITEM tvItem{};
468  	tvItem.mask = TVIF_PARAM;
469  	tvItem.hItem = _treeView.getSelection();
470  	::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
471  	NodeType nType = getNodeType(tvItem.hItem);
472  	generic_string *fn = (generic_string *)tvItem.lParam;
473  	if (nType == nodeType_file && fn)
474  	{
475  		tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
476  		if (::PathFileExists(fn->c_str()))
477  		{
478  			::PostMessage(_hParent, NPPM_DOOPEN, 0, reinterpret_cast<LPARAM>(fn->c_str()));
479  			tvItem.iImage = INDEX_LEAF;
480  			tvItem.iSelectedImage = INDEX_LEAF;
481  		}
482  		else
483  		{
484  			tvItem.iImage = INDEX_LEAF_INVALID;
485  			tvItem.iSelectedImage = INDEX_LEAF_INVALID;
486  		}
487  		TreeView_SetItem(_treeView.getHSelf(), &tvItem);
488  	}
489  }
490  void ProjectPanel::notified(LPNMHDR notification)
491  {
492  	if (notification->code == DMN_CLOSE)
493  	{
494  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_PROJECT_PANEL_1 + _panelID, 0);
495  		SetWindowLongPtr (getHSelf(), DWLP_MSGRESULT, _isClosed ? 0 : 1);
496  	}
497  	else if (notification->hwndFrom == _treeView.getHSelf())
498  	{
499  		TCHAR textBuffer[MAX_PATH] = { '\0' };
500  		TVITEM tvItem{};
501  		tvItem.mask = TVIF_TEXT | TVIF_PARAM;
502  		tvItem.pszText = textBuffer;
503  		tvItem.cchTextMax = MAX_PATH;
504  		switch (notification->code)
505  		{
506  			case NM_DBLCLK:
507  			{
508  				openSelectFile();
509  			}
510  			break;
511  			case NM_RETURN:
512  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1);
513  			break;
514  			case TVN_ENDLABELEDIT:
515  			{
516  				LPNMTVDISPINFO tvnotif = (LPNMTVDISPINFO)notification;
517  				if (!tvnotif->item.pszText)
518  					return;
519  				if (getNodeType(tvnotif->item.hItem) == nodeType_root)
520  					return;
521  				if (tvnotif->item.lParam) 
522  				{
523  					tvItem.hItem = _treeView.getSelection();
524  					::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
525  					size_t len = lstrlen(tvItem.pszText);
526  					generic_string *filePath = (generic_string *)tvnotif->item.lParam;
527  					size_t found = filePath->rfind(tvItem.pszText);
528  					if (found != generic_string::npos)
529  						filePath->replace(found, len, tvnotif->item.pszText);
530  					tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
531  					if (::PathFileExists(filePath->c_str()))
532  					{
533  						tvItem.iImage = INDEX_LEAF;
534  						tvItem.iSelectedImage = INDEX_LEAF;
535  					}
536  					else
537  					{
538  						tvItem.iImage = INDEX_LEAF_INVALID;
539  						tvItem.iSelectedImage = INDEX_LEAF_INVALID;
540  					}
541  					TreeView_SetItem(_treeView.getHSelf(), &tvItem);
542  				}
543  				::SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&(tvnotif->item)));
544  				setWorkSpaceDirty(true);
545  			}
546  			break;
547  			case TVN_GETINFOTIP:
548  			{
549  				LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)notification;
550  				generic_string *str = NULL ;
551  				if (_treeView.getRoot() == lpGetInfoTip->hItem)
552  				{
553  					str = &_workSpaceFilePath;
554  				}
555  				else
556  				{
557  					str = (generic_string *)lpGetInfoTip->lParam;
558  					if (!str)
559  						return;
560  				}
561  				lpGetInfoTip->pszText = (LPTSTR)str->c_str();
562  				lpGetInfoTip->cchTextMax = static_cast<int32_t>(str->size());
563  			}
564  			break;
565  			case TVN_KEYDOWN:
566  			{
567  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
568  				if (ptvkd->wVKey == VK_DELETE)
569  				{
570  					HTREEITEM hItem = _treeView.getSelection();
571  					NodeType nType = getNodeType(hItem);
572  					if (nType == nodeType_project || nType == nodeType_folder)
573  						popupMenuCmd(IDM_PROJECT_DELETEFOLDER);
574  					else if (nType == nodeType_file)
575  						popupMenuCmd(IDM_PROJECT_DELETEFILE);
576  				}
577  				else if (ptvkd->wVKey == VK_RETURN)
578  				{
579  					HTREEITEM hItem = _treeView.getSelection();
580  					NodeType nType = getNodeType(hItem);
581  					if (nType == nodeType_file)
582  						openSelectFile();
583  					else
584  						_treeView.toggleExpandCollapse(hItem);
585  				}
586  				else if (ptvkd->wVKey == VK_UP)
587  				{
588  					if (0x80 & GetKeyState(VK_CONTROL))
589  					{
590  						popupMenuCmd(IDM_PROJECT_MOVEUP);
591  					}
592  				}
593  				else if (ptvkd->wVKey == VK_DOWN)
594  				{
595  					if (0x80 & GetKeyState(VK_CONTROL))
596  					{
597  						popupMenuCmd(IDM_PROJECT_MOVEDOWN);
598  					}
599  				}
600  				else if (ptvkd->wVKey == VK_F2)
601  					popupMenuCmd(IDM_PROJECT_RENAME);
602  			}
603  			break;
604  			case TVN_ITEMEXPANDED:
605  			{
606  				LPNMTREEVIEW nmtv = (LPNMTREEVIEW)notification;
607  				tvItem.hItem = nmtv->itemNew.hItem;
608  				tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
609  				if (getNodeType(nmtv->itemNew.hItem) == nodeType_folder)
610  				{
611  					if (nmtv->action == TVE_COLLAPSE)
612  					{
613  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
614  					}
615  					else if (nmtv->action == TVE_EXPAND)
616  					{
617  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
618  					}
619  				}
620  			}
621  			break;
622  			case TVN_BEGINDRAG:
623  			{
624  				_treeView.beginDrag((LPNMTREEVIEW)notification);
625  			}
626  			break;
627  		}
628  	}
629  }
630  void ProjectPanel::setWorkSpaceDirty(bool isDirty)
631  {
632  	_isDirty = isDirty;
633  	int iImg = _isDirty?INDEX_DIRTY_ROOT:INDEX_CLEAN_ROOT;
634  	_treeView.setItemImage(_treeView.getRoot(), iImg, iImg);
635  }
636  NodeType ProjectPanel::getNodeType(HTREEITEM hItem)
637  {
638  	TVITEM tvItem{};
639  	tvItem.hItem = hItem;
640  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
641  	SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
642  	if (tvItem.iImage == INDEX_CLEAN_ROOT || tvItem.iImage == INDEX_DIRTY_ROOT)
643  	{
644  		return nodeType_root;
645  	}
646  	else if (tvItem.iImage == INDEX_PROJECT)
647  	{
648  		return nodeType_project;
649  	}
650  	else if (!tvItem.lParam)
651  	{
652  		return nodeType_folder;
653  	}
654  	else
655  	{
656  		return nodeType_file;
657  	}
658  }
659  void ProjectPanel::showContextMenu(int x, int y)
660  {
661  	TVHITTESTINFO tvHitInfo{};
662  	tvHitInfo.pt.x = x;
663  	tvHitInfo.pt.y = y;
664  	tvHitInfo.flags = 0;
665  	ScreenToClient(_treeView.getHSelf(), &(tvHitInfo.pt));
666  	TreeView_HitTest(_treeView.getHSelf(), &tvHitInfo);
667  	if (tvHitInfo.hItem != NULL)
668  	{
669  		_treeView.selectItem(tvHitInfo.hItem);
670  		HMENU hMenu = getMenuHandler(tvHitInfo.hItem);
671  		TrackPopupMenu(hMenu,
672  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
673  			x, y, 0, _hSelf, NULL);
674  	}
675  }
676  void ProjectPanel::showContextMenuFromMenuKey(HTREEITEM selectedItem, int x, int y)
677  {
678  	POINT p{};
679  	p.x = x;
680  	p.y = y;
681  	ClientToScreen(_treeView.getHSelf(), &p);
682  	if (selectedItem != NULL)
683  	{
684  		HMENU hMenu = getMenuHandler(selectedItem);
685  		TrackPopupMenu(hMenu,
686  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
687  			x, y, 0, _hSelf, NULL);
688  	}
689  }
690  HMENU ProjectPanel::getMenuHandler(HTREEITEM selectedItem)
691  {
692  	NodeType nodeType = getNodeType(selectedItem);
693  	HMENU hMenu = NULL;
694  	if (nodeType == nodeType_root)
695  		hMenu = _hWorkSpaceMenu;
696  	else if (nodeType == nodeType_project)
697  		hMenu = _hProjectMenu;
698  	else if (nodeType == nodeType_folder)
699  		hMenu = _hFolderMenu;
700  	else 
701  		hMenu = _hFileMenu;
702  	return hMenu;
703  }
704  POINT ProjectPanel::getMenuDisplayPoint(int iButton)
705  {
706  	POINT p{};
707  	RECT btnRect{};
708  	SendMessage(_hToolbarMenu, TB_GETITEMRECT, iButton, reinterpret_cast<LPARAM>(&btnRect));
709  	p.x = btnRect.left;
710  	p.y = btnRect.top + btnRect.bottom;
711  	ClientToScreen(_hToolbarMenu, &p);
712  	return p;
713  }
714  HTREEITEM ProjectPanel::addFolder(HTREEITEM hTreeItem, const TCHAR *folderName)
715  {
716  	HTREEITEM addedItem = _treeView.addItem(folderName, hTreeItem, INDEX_CLOSED_NODE);
717  	TreeView_Expand(_treeView.getHSelf(), hTreeItem, TVE_EXPAND);
718  	TreeView_EditLabel(_treeView.getHSelf(), addedItem);
719  	if (getNodeType(hTreeItem) == nodeType_folder)
720  		_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
721  	return addedItem;
722  }
723  bool ProjectPanel::saveWorkspaceRequest()
724  { 
725  	if (_isDirty)
726  	{
727  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
728  		int res = pNativeSpeaker->messageBox("ProjectPanelOpenDoSaveDirtyWsOrNot",
729  					_hSelf,
730  					TEXT("The current workspace was modified. Do you want to save the current project?"),
731  					TEXT("Open Workspace"),
732  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
733  		if (res == IDYES)
734  		{
735  			if (!saveWorkSpace())
736  				return false;
737  		}
738  		else if (res == IDNO)
739  		{
740  		}
741  		else if (res == IDCANCEL) 
742  		{
743  			return false;
744  		}
745  	}
746  	return true;
747  }
748  void ProjectPanel::popupMenuCmd(int cmdID)
749  {
750  	HTREEITEM hTreeItem = _treeView.getSelection();
751  	if (!hTreeItem)
752  		return;
753  	switch (cmdID)
754  	{
755  		case IDB_PROJECT_BTN:
756  		{
757  		  POINT p = getMenuDisplayPoint(0);
758  		  TrackPopupMenu(_hWorkSpaceMenu,
759  			  NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
760  			  p.x, p.y, 0, _hSelf, NULL);
761  		}
762  		break;
763  		case IDB_EDIT_BTN:
764  		{
765  			POINT p = getMenuDisplayPoint(1);
766  			HMENU hMenu = NULL;
767  			NodeType nodeType = getNodeType(hTreeItem);
768  			if (nodeType == nodeType_project)
769  				hMenu = _hProjectMenu;
770  			else if (nodeType == nodeType_folder)
771  				hMenu = _hFolderMenu;
772  			else if (nodeType == nodeType_file)
773  				hMenu = _hFileMenu;
774  			if (hMenu)
775  				TrackPopupMenu(hMenu,
776  					NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
777  					p.x, p.y, 0, _hSelf, NULL);
778  		}
779  		break;
780  		case IDM_PROJECT_NEWPROJECT :
781  		{
782  			HTREEITEM root = _treeView.getRoot();
783  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
784  			generic_string newProjectLabel = pNativeSpeaker->getAttrNameStr(PM_NEWPROJECTNAME, "ProjectManager", "NewProjectName");
785  			HTREEITEM addedItem = _treeView.addItem(newProjectLabel.c_str(),  root, INDEX_PROJECT);
786  			setWorkSpaceDirty(true);
787  			_treeView.expand(hTreeItem);
788  			TreeView_EditLabel(_treeView.getHSelf(), addedItem);
789  		}
790  		break;
791  		case IDM_PROJECT_NEWWS :
792  		{
793  			if (_isDirty)
794  			{
795  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
796  				int res = pNativeSpeaker->messageBox("ProjectPanelNewDoSaveDirtyWsOrNot",
797  					_hSelf,
798  					TEXT("The current workspace was modified. Do you want to save the current project?"),
799  					TEXT("New Workspace"),
800  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
801  				if (res == IDYES)
802  				{
803  					if (!saveWorkSpace())
804  						return;
805  				}
806  				else if (res == IDNO)
807  				{
808  				}
809  				else if (res == IDCANCEL) 
810  				{
811  					return;
812  				}
813  			}
814  			_treeView.removeAllItems();
815  			newWorkSpace();
816  		}
817  		break;
818  		case IDM_PROJECT_RENAME :
819  			TreeView_EditLabel(_treeView.getHSelf(), hTreeItem);
820  		break;
821  		case IDM_PROJECT_NEWFOLDER :
822  		{
823  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
824  			generic_string newFolderLabel = pNativeSpeaker->getAttrNameStr(PM_NEWFOLDERNAME, "ProjectManager", "NewFolderName");
825  			addFolder(hTreeItem, newFolderLabel.c_str());
826  			setWorkSpaceDirty(true);
827  		}
828  		break;
829  		case IDM_PROJECT_MOVEDOWN :
830  		{
831  			if (_treeView.moveDown(hTreeItem))
832  				setWorkSpaceDirty(true);
833  		}
834  		break;
835  		case IDM_PROJECT_MOVEUP :
836  		{
837  			if (_treeView.moveUp(hTreeItem))
838  				setWorkSpaceDirty(true);
839  		}
840  		break;
841  		case IDM_PROJECT_ADDFILES :
842  		{
843  			addFiles(hTreeItem);
844  			if (getNodeType(hTreeItem) == nodeType_folder)
845  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
846  		}
847  		break;
848  		case IDM_PROJECT_ADDFILESRECUSIVELY :
849  		{
850  			addFilesFromDirectory(hTreeItem);
851  			if (getNodeType(hTreeItem) == nodeType_folder)
852  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
853  		}
854  		break;
855  		case IDM_PROJECT_OPENWS:
856  		{
857  			if (!saveWorkspaceRequest())
858  				break;
859  			CustomFileDialog fDlg(_hSelf);
860  			setFileExtFilter(fDlg);
861  			const generic_string fn = fDlg.doOpenSingleFileDlg();
862  			if (!fn.empty())
863  			{
864  				if (!openWorkSpace(fn.c_str(), true))
865  				{
866  					NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
867  					pNativeSpeaker->messageBox("ProjectPanelOpenFailed",
868  						_hSelf,
869  						TEXT("The workspace could not be opened.\rIt seems the file to open is not a valid project file."),
870  						TEXT("Open Workspace"),
871  						MB_OK);
872  					return;
873  				}
874  			}
875  		}
876  		break;
877  		case IDM_PROJECT_RELOADWS:
878  		{
879  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
880  			bool forceOpen = false;
881  			if (_isDirty)
882  			{
883  				int res = pNativeSpeaker->messageBox("ProjectPanelReloadDirty",
884  					_hSelf,
885  					TEXT("The current workspace was modified. Reloading will discard all modifications.\rDo you want to continue?"),
886  					TEXT("Reload Workspace"),
887  					MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);
888  				if (res == IDYES)
889  				{
890  					forceOpen = true;
891  				}
892  				else if (res == IDNO)
893  				{
894  					return;
895  				}
896  			}
897  			if (::PathFileExists(_workSpaceFilePath.c_str()))
898  			{
899  				openWorkSpace(_workSpaceFilePath.c_str(), forceOpen);
900  			}
901  			else
902  			{
903  				pNativeSpeaker->messageBox("ProjectPanelReloadError",
904  					_hSelf,
905  					TEXT("Cannot find the file to reload."),
906  					TEXT("Reload Workspace"),
907  					MB_OK);
908  			}
909  		}
910  		break;
911  		case IDM_PROJECT_SAVEWS:
912  			saveWorkSpace();
913  		break;
914  		case IDM_PROJECT_SAVEACOPYASWS:
915  		case IDM_PROJECT_SAVEASWS:
916  		{
917  			saveWorkSpaceAs(cmdID == IDM_PROJECT_SAVEACOPYASWS);
918  		}
919  		break;
920  		case IDM_PROJECT_FINDINPROJECTSWS:
921  		{
922  			::SendMessage(_hParent, NPPM_INTERNAL_FINDINPROJECTS, (WPARAM) 1 << _panelID, 0);
923  		}
924  		break;
925  		case IDM_PROJECT_DELETEFOLDER :
926  		{
927  			HTREEITEM parent = _treeView.getParent(hTreeItem);
928  			if (_treeView.getChildFrom(hTreeItem) != NULL)
929  			{
930  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
931  				int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFolderFromProject",
932  					_hSelf,
933  					TEXT("All the sub-items will be removed.\rAre you sure you want to remove this folder from the project?"),
934  					TEXT("Remove folder from project"),
935  					MB_YESNO);
936  				if (res == IDYES)
937  				{
938  					_treeView.removeItem(hTreeItem);
939  					setWorkSpaceDirty(true);
940  				}
941  			}
942  			else
943  			{
944  				_treeView.removeItem(hTreeItem);
945  				setWorkSpaceDirty(true);
946  			}
947  			if (getNodeType(parent) == nodeType_folder)
948  				_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
949  		}
950  		break;
951  		case IDM_PROJECT_DELETEFILE :
952  		{
953  			HTREEITEM parent = _treeView.getParent(hTreeItem);
954  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
955  			int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFileFromProject",
956  				_hSelf,
957  				TEXT("Are you sure you want to remove this file from the project?"),
958  				TEXT("Remove file from project"),
959  				MB_YESNO);
960  			if (res == IDYES)
961  			{
962  				_treeView.removeItem(hTreeItem);
963  				setWorkSpaceDirty(true);
964  				if (getNodeType(parent) == nodeType_folder)
965  					_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
966  			}
967  		}
968  		break;
969  		case IDM_PROJECT_MODIFYFILEPATH :
970  		{
971  			FileRelocalizerDlg fileRelocalizerDlg;
972  			fileRelocalizerDlg.init(_hInst, _hParent);
973  			TCHAR textBuffer[MAX_PATH] = { '\0' };
974  			TVITEM tvItem{};
975  			tvItem.hItem = hTreeItem;
976  			tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
977  			tvItem.pszText = textBuffer;
978  			tvItem.cchTextMax = MAX_PATH;
979  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
980  			if (!tvItem.lParam)
981  				return;
982  			generic_string * fn = (generic_string *)tvItem.lParam;
983  			if (fileRelocalizerDlg.doDialog(fn->c_str()) == 0)
984  			{
985  				generic_string newValue = fileRelocalizerDlg.getFullFilePath();
986  				if (*fn == newValue)
987  					return;
988  				*fn = newValue;
989  				TCHAR *strValueLabel = ::PathFindFileName(fn->c_str());
990  				wcscpy_s(textBuffer, strValueLabel);
991  				int iImage = ::PathFileExists(fn->c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
992  				tvItem.iImage = tvItem.iSelectedImage = iImage;
993  				SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
994  				setWorkSpaceDirty(true);
995  			}
996  		}
997  		break;
998  	}
999  }
1000  bool ProjectPanel::saveWorkSpaceAs(bool saveCopyAs)
1001  {
1002  	CustomFileDialog fDlg(_hSelf);
1003  	setFileExtFilter(fDlg);
1004  	fDlg.setExtIndex(0);		
1005  	const generic_string fn = fDlg.doSaveDlg();
1006  	if (fn.empty())
1007  		return false;
1008  	if (!writeWorkSpace(fn.c_str(), !saveCopyAs))
1009  		return false;
1010  	if (!saveCopyAs)
1011  	{
1012  		_workSpaceFilePath = fn;
1013  		setWorkSpaceDirty(false);
1014  	}
1015  	return true;
1016  }
1017  void ProjectPanel::setFileExtFilter(CustomFileDialog & fDlg)
1018  {
1019  	const TCHAR *ext = NppParameters::getInstance().getNppGUI()._definedWorkspaceExt.c_str();
1020  	generic_string workspaceExt = TEXT("");
1021  	if (*ext != '\0')
1022  	{
1023  		if (*ext != '.')
1024  			workspaceExt += TEXT(".");
1025  		workspaceExt += ext;
1026  		fDlg.setExtFilter(TEXT("Workspace file"), workspaceExt.c_str());
1027  		fDlg.setDefExt(ext);
1028  	}
1029  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1030  }
1031  void ProjectPanel::addFiles(HTREEITEM hTreeItem)
1032  {
1033  	CustomFileDialog fDlg(_hSelf);
1034  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1035  	const auto& fns = fDlg.doOpenMultiFilesDlg();
1036  	if (!fns.empty())
1037  	{
1038  		size_t sz = fns.size();
1039  		for (size_t i = 0 ; i < sz ; ++i)
1040  		{
1041  			TCHAR *strValueLabel = ::PathFindFileName(fns.at(i).c_str());
1042  			generic_string* pathFileStr = new generic_string(fns.at(i));
1043  			fullPathStrs.push_back(pathFileStr);
1044  			LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1045  			_treeView.addItem(strValueLabel, hTreeItem, INDEX_LEAF, lParamPathFileStr);
1046  		}
1047  		_treeView.expand(hTreeItem);
1048  		setWorkSpaceDirty(true);
1049  	}
1050  }
1051  void ProjectPanel::recursiveAddFilesFrom(const TCHAR *folderPath, HTREEITEM hTreeItem)
1052  {
1053  	bool isRecursive = true;
1054  	bool isInHiddenDir = false;
1055  	generic_string dirFilter(folderPath);
1056  	if (folderPath[lstrlen(folderPath)-1] != '\\')
1057  		dirFilter += TEXT("\\");
1058  	dirFilter += TEXT("*.*");
1059  	WIN32_FIND_DATA foundData;
1060  	std::vector<generic_string> files;
1061  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
1062  	do {
1063  		if (hFile == INVALID_HANDLE_VALUE)
1064  			break;
1065  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1066  		{
1067  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1068  			{
1069  			}
1070  			else if (isRecursive)
1071  			{
1072  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0))
1073  				{
1074  					generic_string pathDir(folderPath);
1075  					if (folderPath[lstrlen(folderPath)-1] != '\\')
1076  						pathDir += TEXT("\\");
1077  					pathDir += foundData.cFileName;
1078  					pathDir += TEXT("\\");
1079  					HTREEITEM addedItem = addFolder(hTreeItem, foundData.cFileName);
1080  					recursiveAddFilesFrom(pathDir.c_str(), addedItem);
1081  				}
1082  			}
1083  		}
1084  		else
1085  		{
1086  			files.push_back(foundData.cFileName);
1087  		}
1088  	} while (::FindNextFile(hFile, &foundData));
1089  	for (size_t i = 0, len = files.size() ; i < len ; ++i)
1090  	{
1091  		generic_string pathFile(folderPath);
1092  		if (folderPath[lstrlen(folderPath)-1] != '\\')
1093  			pathFile += TEXT("\\");
1094  		pathFile += files[i];
1095  		generic_string* pathFileStr = new generic_string(pathFile);
1096  		fullPathStrs.push_back(pathFileStr);
1097  		LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1098  		_treeView.addItem(files[i].c_str(), hTreeItem, INDEX_LEAF, lParamPathFileStr);
1099  	}
1100  	::FindClose(hFile);
1101  }
1102  void ProjectPanel::addFilesFromDirectory(HTREEITEM hTreeItem)
1103  {
1104  	if (_selDirOfFilesFromDirDlg == TEXT("") && _workSpaceFilePath != TEXT(""))
1105  	{
1106  		TCHAR dir[MAX_PATH] = { '\0' };
1107  		wcscpy_s(dir, _workSpaceFilePath.c_str());
1108  		::PathRemoveFileSpec(dir);
1109  		_selDirOfFilesFromDirDlg = dir;
1110  	}
1111  	generic_string dirPath;
1112  	if (_selDirOfFilesFromDirDlg != TEXT(""))
1113  		dirPath = getFolderName(_hSelf, _selDirOfFilesFromDirDlg.c_str());
1114  	else
1115  		dirPath = getFolderName(_hSelf);
1116  	if (dirPath != TEXT(""))
1117  	{
1118  		recursiveAddFilesFrom(dirPath.c_str(), hTreeItem);
1119  		_treeView.expand(hTreeItem);
1120  		setWorkSpaceDirty(true);
1121  		_selDirOfFilesFromDirDlg = dirPath;
1122  	}
1123  }
1124  intptr_t CALLBACK FileRelocalizerDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM) 
1125  {
1126  	switch (Message)
1127  	{
1128  		case WM_INITDIALOG:
1129  		{
1130  			::SetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, _fullFilePath.c_str());
1131  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
1132  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
1133  			return TRUE;
1134  		}
1135  		case WM_ERASEBKGND:
1136  		{
1137  			if (NppDarkMode::isEnabled())
1138  			{
1139  				RECT rect{};
1140  				GetClientRect(_hSelf, &rect);
1141  				::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
1142  				return TRUE;
1143  			}
1144  			break;
1145  		}
1146  		case WM_CTLCOLOREDIT:
1147  		{
1148  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1149  		}
1150  		case WM_PRINTCLIENT:
1151  		{
1152  			if (NppDarkMode::isEnabled())
1153  			{
1154  				return TRUE;
1155  			}
1156  			break;
1157  		}
1158  		case WM_COMMAND:
1159  		{
1160  			switch (wParam)
1161  			{
1162  				case IDOK :
1163  				{
1164  					TCHAR textBuf[MAX_PATH] = { '\0' };
1165  					::GetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, textBuf, MAX_PATH);
1166  					_fullFilePath = textBuf;
1167  					::EndDialog(_hSelf, 0);
1168  				}
1169  				return TRUE;
1170  				case IDCANCEL :
1171  					::EndDialog(_hSelf, -1);
1172  				return TRUE;
1173  				default:
1174  					return FALSE;
1175  			}
1176  		}
1177  		default :
1178  			return FALSE;
1179  	}
1180  	return FALSE;
1181  }
1182  int FileRelocalizerDlg::doDialog(const TCHAR *fn, bool isRTL)
1183  {
1184  	_fullFilePath = fn;
1185  	if (isRTL)
1186  	{
1187  		DLGTEMPLATE *pMyDlgTemplate = NULL;
1188  		HGLOBAL hMyDlgTemplate = makeRTLResource(IDD_FILERELOCALIZER_DIALOG, &pMyDlgTemplate);
1189  		int result = static_cast<int32_t>(::DialogBoxIndirectParam(_hInst, pMyDlgTemplate, _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1190  		::GlobalFree(hMyDlgTemplate);
1191  		return result;
1192  	}
1193  	return static_cast<int32_t>(::DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_FILERELOCALIZER_DIALOG), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_entry_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>265                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
266                   "modern Major-General / I've information vegetable, animal, "
267                   "and mineral.:2147483647] I know the kings of England, and I "
268                   "quote the fights historical / From Marathon to Waterloo, in "
269                   "order categorical."));
270    EXPECT_THAT(
271        entry.entry().text_message(),
272        Eq("I know the kings of England, and I quote the fights historical / "
273           "From Marathon to Waterloo, in order categorical."));
274  }
275  TEST(LogEntryTest, LongNegativeFields) {
276    if (std::is_signed<absl::LogEntry::tid_t>::value) {
</pre></code></div>
                <div class="column column_space"><pre><code>235  	::DestroyMenu(_hWorkSpaceMenu);
236  	::DestroyMenu(_hProjectMenu);
237  	::DestroyMenu(_hFolderMenu);
238  	::DestroyMenu(_hFileMenu);
239  }
240  bool ProjectPanel::openWorkSpace(const TCHAR *projectFileName, bool force)
241  {
242  	if ((!force) && (_workSpaceFilePath.length() > 0))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    