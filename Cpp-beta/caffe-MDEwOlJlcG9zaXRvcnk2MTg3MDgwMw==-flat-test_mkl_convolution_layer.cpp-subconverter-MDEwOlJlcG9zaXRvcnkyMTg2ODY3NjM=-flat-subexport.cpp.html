
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.336609336609335%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_convolution_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkl_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  void caffe_conv(const Blob<Dtype>* in, ConvolutionParameter* conv_param,
13      const vector<shared_ptr<Blob<Dtype> > >& weights,
14      Blob<Dtype>* out) {
15    const bool has_depth = (out->num_axes() == 5);
16    if (!has_depth) { CHECK_EQ(4, out->num_axes()); }
17    int kernel_h, kernel_w;
18    if (conv_param->has_kernel_h() || conv_param->has_kernel_w()) {
19      kernel_h = conv_param->kernel_h();
20      kernel_w = conv_param->kernel_w();
21    } else {
22      kernel_h = kernel_w = conv_param->kernel_size(0);
23    }
24    int pad_h, pad_w;
25    if (conv_param->has_pad_h() || conv_param->has_pad_w()) {
26      pad_h = conv_param->pad_h();
27      pad_w = conv_param->pad_w();
28    } else {
29      pad_h = pad_w = conv_param->pad_size() ? conv_param->pad(0) : 0;
30    }
31    int stride_h, stride_w;
32    if (conv_param->has_stride_h() || conv_param->has_stride_w()) {
33      stride_h = conv_param->stride_h();
34      stride_w = conv_param->stride_w();
35    } else {
36      stride_h = stride_w = conv_param->stride_size() ? conv_param->stride(0) : 1;
37    }
38    int dilation_h, dilation_w;
39    dilation_h = dilation_w = conv_param->dilation_size() ?
40                              conv_param->dilation(0) : 1;
41    int kernel_d, pad_d, stride_d, dilation_d;
42    if (has_depth) {
43      kernel_d = kernel_h;
44      stride_d = stride_h;
45      pad_d = pad_h;
46      dilation_d = dilation_h;
47    } else {
48      kernel_d = stride_d = dilation_d = 1;
49      pad_d = 0;
50    }
51    int groups = conv_param->group();
52    int o_g = out->shape(1) / groups;
53    int k_g = in->shape(1) / groups;
54    int o_head, k_head;
55    vector<int> weight_offset(4 + has_depth);
56    vector<int> in_offset(4 + has_depth);
57    vector<int> out_offset(4 + has_depth);
58    Dtype* out_data = out->mutable_cpu_data();
59    for (int n = 0; n < out->shape(0); n++) {
60      for (int g = 0; g < groups; g++) {
61        o_head = o_g * g;
62        k_head = k_g * g;
63        for (int o = 0; o < o_g; o++) {
64          for (int k = 0; k < k_g; k++) {
65            for (int z = 0; z < (has_depth ? out->shape(2) : 1); z++) {
66              for (int y = 0; y < out->shape(2 + has_depth); y++) {
67                for (int x = 0; x < out->shape(3 + has_depth); x++) {
68                  for (int r = 0; r < kernel_d; r++) {
69                    for (int p = 0; p < kernel_h; p++) {
70                      for (int q = 0; q < kernel_w; q++) {
71                        int in_z = z * stride_d - pad_d + r * dilation_d;
72                        int in_y = y * stride_h - pad_h + p * dilation_h;
73                        int in_x = x * stride_w - pad_w + q * dilation_w;
74                        if (in_z >= 0 && in_z < (has_depth ? in->shape(2) : 1)
75                            && in_y >= 0 && in_y < in->shape(2 + has_depth)
76                            && in_x >= 0 && in_x < in->shape(3 + has_depth)) {
77                          weight_offset[0] = o + o_head;
78                          weight_offset[1] = k;
79                          if (has_depth) { weight_offset[2] = r; }
80                          weight_offset[2 + has_depth] = p;
81                          weight_offset[3 + has_depth] = q;
82                          in_offset[0] = n;
83                          in_offset[1] = k + k_head;
84                          if (has_depth) { in_offset[2] = in_z; }
85                          in_offset[2 + has_depth] = in_y;
86                          in_offset[3 + has_depth] = in_x;
87                          out_offset[0] = n;
88                          out_offset[1] = o + o_head;
89                          if (has_depth) { out_offset[2] = z; }
90                          out_offset[2 + has_depth] = y;
91                          out_offset[3 + has_depth] = x;
92                          out_data[out->offset(out_offset)] +=
93                              in->data_at(in_offset)
94                              * weights[0]->data_at(weight_offset);
95                        }
96                      }
97                    }
98                  }
99                }
100              }
101            }
102          }
103        }
104      }
105    }
106    if (conv_param->bias_term()) {
107      const Dtype* bias_data = weights[1]->cpu_data();
108      for (int n = 0; n < out->shape(0); n++) {
109        for (int o = 0; o < out->shape(1); o++) {
110          for (int z = 0; z < (has_depth ? out->shape(2) : 1); z++) {
111            for (int y = 0; y < out->shape(2 + has_depth); y++) {
112              for (int x = 0; x < out->shape(3 + has_depth); x++) {
113                out_offset[0] = n;
114                out_offset[1] = o;
115                if (has_depth) { out_offset[2] = z; }
116                out_offset[2 + has_depth] = y;
117                out_offset[3 + has_depth] = x;
118                out_data[out->offset(out_offset)] += bias_data[o];
119              }
120            }
121          }
122        }
123      }
124    }
125    if (conv_param->relu()) {
126      for (int n = 0; n < out->shape(0); n++) {
127        for (int o = 0; o < out->shape(1); o++) {
128          for (int z = 0; z < (has_depth ? out->shape(2) : 1); z++) {
129            for (int y = 0; y < out->shape(2 + has_depth); y++) {
130              for (int x = 0; x < out->shape(3 + has_depth); x++) {
131                out_offset[0] = n;
132                out_offset[1] = o;
133                if (has_depth) { out_offset[2] = z; }
134                out_offset[2 + has_depth] = y;
135                out_offset[3 + has_depth] = x;
136                if(out_data[out->offset(out_offset)] < 0) out_data[out->offset(out_offset)] = 0;
137              }
138            }
139          }
140        }
141      }
142    }
143  }
144  template void caffe_conv(const Blob<float>* in,
145      ConvolutionParameter* conv_param,
146      const vector<shared_ptr<Blob<float> > >& weights,
147      Blob<float>* out);
148  template void caffe_conv(const Blob<double>* in,
149      ConvolutionParameter* conv_param,
150      const vector<shared_ptr<Blob<double> > >& weights,
151      Blob<double>* out);
152  template <typename TypeParam>
153  class MKLConvolutionLayerTest : public MultiDeviceTest<TypeParam> {
154    typedef typename TypeParam::Dtype Dtype;
155   protected:
156    MKLConvolutionLayerTest()
157        : blob_bottom_(new Blob<Dtype>(2, 3, 6, 4)),
158          blob_bottom_2_(new Blob<Dtype>(2, 3, 6, 4)),
159          blob_top_(new Blob<Dtype>()),
160          blob_top_2_(new Blob<Dtype>()) {}
161    virtual void SetUp() {
162      FillerParameter filler_param;
163      filler_param.set_value(1.);
164      GaussianFiller<Dtype> filler(filler_param);
165      filler.Fill(this->blob_bottom_);
166      filler.Fill(this->blob_bottom_2_);
167      blob_bottom_vec_.push_back(blob_bottom_);
168      blob_top_vec_.push_back(blob_top_);
169    }
170    virtual ~MKLConvolutionLayerTest() {
171      delete blob_bottom_;
172      delete blob_bottom_2_;
173      delete blob_top_;
174      delete blob_top_2_;
175    }
176    virtual Blob<Dtype>* MakeReferenceTop(Blob<Dtype>* top) {
177      this->ref_blob_top_.reset(new Blob<Dtype>());
178      this->ref_blob_top_->ReshapeLike(*top);
179      return this->ref_blob_top_.get();
180    }
181    Blob<Dtype>* const blob_bottom_;
182    Blob<Dtype>* const blob_bottom_2_;
183    Blob<Dtype>* const blob_top_;
184    Blob<Dtype>* const blob_top_2_;
185    shared_ptr<Blob<Dtype> > ref_blob_top_;
186    vector<Blob<Dtype>*> blob_bottom_vec_;
187    vector<Blob<Dtype>*> blob_top_vec_;
188  };
189  typedef ::testing::Types<CPUDevice<float>,
190                           CPUDevice<double> > TestDtypesCPU;
191  TYPED_TEST_CASE(MKLConvolutionLayerTest, TestDtypesCPU);
192  TYPED_TEST(MKLConvolutionLayerTest, TestSetupMKL) {
193    typedef typename TypeParam::Dtype Dtype;
194    LayerParameter layer_param;
195    ConvolutionParameter* convolution_param =
196        layer_param.mutable_convolution_param();
197    convolution_param->add_kernel_size(3);
198    convolution_param->add_stride(2);
199    convolution_param->set_num_output(4);
200    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
201    this->blob_top_vec_.push_back(this->blob_top_2_);
202    shared_ptr<Layer<Dtype> > layer(
203        new MKLConvolutionLayer<Dtype>(layer_param));
204    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
205    EXPECT_EQ(this->blob_top_->num(), 2);
206    EXPECT_EQ(this->blob_top_->channels(), 4);
207    EXPECT_EQ(this->blob_top_->height(), 2);
208    EXPECT_EQ(this->blob_top_->width(), 1);
209    EXPECT_EQ(this->blob_top_2_->num(), 2);
210    EXPECT_EQ(this->blob_top_2_->channels(), 4);
211    EXPECT_EQ(this->blob_top_2_->height(), 2);
212    EXPECT_EQ(this->blob_top_2_->width(), 1);
213    convolution_param->set_num_output(3);
214    convolution_param->set_group(3);
215    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
216    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
217    EXPECT_EQ(this->blob_top_->num(), 2);
218    EXPECT_EQ(this->blob_top_->channels(), 3);
219    EXPECT_EQ(this->blob_top_->height(), 2);
220    EXPECT_EQ(this->blob_top_->width(), 1);
221    EXPECT_EQ(this->blob_top_2_->num(), 2);
222    EXPECT_EQ(this->blob_top_2_->channels(), 3);
223    EXPECT_EQ(this->blob_top_2_->height(), 2);
224    EXPECT_EQ(this->blob_top_2_->width(), 1);
225  }
226  TYPED_TEST(MKLConvolutionLayerTest, TestSimpleConvolutionMKL) {
227    typedef typename TypeParam::Dtype Dtype;
228    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
229    this->blob_top_vec_.push_back(this->blob_top_2_);
230    LayerParameter layer_param;
231    ConvolutionParameter* convolution_param =
232        layer_param.mutable_convolution_param();
233    convolution_param->add_kernel_size(3);
234    convolution_param->add_stride(2);
235    convolution_param->set_num_output(4);
236    convolution_param->mutable_weight_filler()->set_type("gaussian");
237    convolution_param->mutable_bias_filler()->set_type("constant");
238    convolution_param->mutable_bias_filler()->set_value(0.1);
239    shared_ptr<Layer<Dtype> > layer(
240        new MKLConvolutionLayer<Dtype>(layer_param));
241    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
242    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
243    const Dtype* top_data;
244    const Dtype* ref_top_data;
245    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
246        this->MakeReferenceTop(this->blob_top_));
247    top_data = this->blob_top_->cpu_data();
248    ref_top_data = this->ref_blob_top_->cpu_data();
249    for (int i = 0; i < this->blob_top_->count(); ++i) {
250      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
251    }
252  #if 0   
253    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
254        this->MakeReferenceTop(this->blob_top_2_));
255    top_data = this->blob_top_2_->cpu_data();
256    ref_top_data = this->ref_blob_top_->cpu_data();
257    for (int i = 0; i < this->blob_top_->count(); ++i) {
258      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
259    }
260  #endif
261  }
262  #if 0
263  TYPED_TEST(MKLConvolutionLayerTest, TestDilatedConvolutionMKL) {
264    typedef typename TypeParam::Dtype Dtype;
265    vector<int> bottom_shape;
266    bottom_shape.push_back(2);
267    bottom_shape.push_back(3);
268    bottom_shape.push_back(8);
269    bottom_shape.push_back(7);
270    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
271    this->blob_top_vec_.push_back(this->blob_top_2_);
272    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
273      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
274    }
275    LayerParameter layer_param;
276    ConvolutionParameter* convolution_param =
277        layer_param.mutable_convolution_param();
278    convolution_param->add_kernel_size(3);
279    convolution_param->add_dilation(2);
280    convolution_param->set_num_output(4);
281    convolution_param->mutable_weight_filler()->set_type("gaussian");
282    convolution_param->mutable_bias_filler()->set_type("constant");
283    convolution_param->mutable_bias_filler()->set_value(0.1);
284    shared_ptr<Layer<Dtype> > layer(
285        new MKLConvolutionLayer<Dtype>(layer_param));
286    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
287    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
288    const Dtype* top_data;
289    const Dtype* ref_top_data;
290    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
291               this->MakeReferenceTop(this->blob_top_));
292    top_data = this->blob_top_->cpu_data();
293    ref_top_data = this->ref_blob_top_->cpu_data();
294    for (int i = 0; i < this->blob_top_->count(); ++i) {
295      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
296    }
297  #if 0   
298    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
299               this->MakeReferenceTop(this->blob_top_2_));
300    top_data = this->blob_top_2_->cpu_data();
301    ref_top_data = this->ref_blob_top_->cpu_data();
302    for (int i = 0; i < this->blob_top_->count(); ++i) {
303      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
304    }
305  #endif
306  }
307  #endif
308  #if 0
309  TYPED_TEST(MKLConvolutionLayerTest, Test0DConvolutionMKL) {
310    typedef typename TypeParam::Dtype Dtype;
311    LayerParameter layer_param;
312    ConvolutionParameter* convolution_param =
313        layer_param.mutable_convolution_param();
314    const int kNumOutput = 3;
315    convolution_param->set_num_output(kNumOutput);
316    convolution_param->set_axis(3);
317    convolution_param->mutable_weight_filler()->set_type("gaussian");
318    convolution_param->mutable_bias_filler()->set_type("gaussian");
319    shared_ptr<Layer<Dtype> > layer(
320        new MKLConvolutionLayer<Dtype>(layer_param));
321    vector<int> top_shape = this->blob_bottom_->shape();
322    top_shape[3] = kNumOutput;
323    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
324    EXPECT_EQ(top_shape, this->blob_top_->shape());
325    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
326    vector<int> weight_offset(2);
327    const Blob<Dtype>* weight = layer->blobs()[0].get();
328    const Blob<Dtype>* bias = layer->blobs()[1].get();
329    const int num = this->blob_top_->count(3);
330    const int dim = this->blob_top_->shape(3);
331    const int bottom_dim = this->blob_bottom_->shape(3);
332    for (int n = 0; n < num; ++n) {
333      for (int d = 0; d < dim; ++d) {
334        weight_offset[0] = d;
335        Dtype value = bias->cpu_data()[d];
336        for (int bottom_d = 0; bottom_d < bottom_dim; ++bottom_d) {
337          weight_offset[1] = bottom_d;
338          value += weight->data_at(weight_offset) *
339                   this->blob_bottom_->cpu_data()[n * bottom_dim + bottom_d];
340        }
341        EXPECT_NEAR(value, this->blob_top_->cpu_data()[n * dim + d], 1e-4);
342      }
343    }
344  }
345  #endif
346  #if 0
347  TYPED_TEST(MKLConvolutionLayerTest, TestSimple3DConvolution) {
348    typedef typename TypeParam::Dtype Dtype;
349    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
350    this->blob_top_vec_.push_back(this->blob_top_2_);
351    vector<int> bottom_shape(5);
352    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
353    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
354    bottom_shape[2] = 5;
355    bottom_shape[3] = this->blob_bottom_vec_[0]->shape(2);
356    bottom_shape[4] = this->blob_bottom_vec_[0]->shape(3);
357    FillerParameter filler_param;
358    GaussianFiller<Dtype> filler(filler_param);
359    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
360      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
361      filler.Fill(this->blob_bottom_vec_[i]);
362    }
363    LayerParameter layer_param;
364    ConvolutionParameter* convolution_param =
365        layer_param.mutable_convolution_param();
366    convolution_param->add_kernel_size(3);
367    convolution_param->add_stride(2);
368    convolution_param->set_num_output(4);
369    convolution_param->mutable_weight_filler()->set_type("gaussian");
370    convolution_param->mutable_bias_filler()->set_type("gaussian");
371    shared_ptr<Layer<Dtype> > layer(
372        new MKLConvolutionLayer<Dtype>(layer_param));
373    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
374    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
375    const Dtype* top_data;
376    const Dtype* ref_top_data;
377    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
378        this->MakeReferenceTop(this->blob_top_));
379    top_data = this->blob_top_->cpu_data();
380    ref_top_data = this->ref_blob_top_->cpu_data();
381    for (int i = 0; i < this->blob_top_->count(); ++i) {
382      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
383    }
384  #if 0   
385    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
386        this->MakeReferenceTop(this->blob_top_2_));
387    top_data = this->blob_top_2_->cpu_data();
388    ref_top_data = this->ref_blob_top_->cpu_data();
389    for (int i = 0; i < this->blob_top_->count(); ++i) {
390      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
391    }
392  #endif
393  }
394  #endif
395  #if 0
396  TYPED_TEST(MKLConvolutionLayerTest, TestDilated3DConvolution) {
397    typedef typename TypeParam::Dtype Dtype;
398    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
399    this->blob_top_vec_.push_back(this->blob_top_2_);
400    vector<int> bottom_shape(5);
401    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
402    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
403    bottom_shape[2] = 6;
404    bottom_shape[3] = 7;
405    bottom_shape[4] = 8;
406    FillerParameter filler_param;
407    GaussianFiller<Dtype> filler(filler_param);
408    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
409      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
410      filler.Fill(this->blob_bottom_vec_[i]);
411    }
412    LayerParameter layer_param;
413    ConvolutionParameter* convolution_param =
414        layer_param.mutable_convolution_param();
415    convolution_param->add_kernel_size(3);
416    convolution_param->add_dilation(2);
417    convolution_param->set_num_output(4);
418    convolution_param->mutable_weight_filler()->set_type("gaussian");
419    convolution_param->mutable_bias_filler()->set_type("gaussian");
420    shared_ptr<Layer<Dtype> > layer(
421        new MKLConvolutionLayer<Dtype>(layer_param));
422    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
423    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
424    const Dtype* top_data;
425    const Dtype* ref_top_data;
426    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
427               this->MakeReferenceTop(this->blob_top_));
428    top_data = this->blob_top_->cpu_data();
429    ref_top_data = this->ref_blob_top_->cpu_data();
430    for (int i = 0; i < this->blob_top_->count(); ++i) {
431      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
432    }
433    caffe_conv(this->blob_bottom_2_, convolution_param, layer->blobs(),
434               this->MakeReferenceTop(this->blob_top_2_));
435    top_data = this->blob_top_2_->cpu_data();
436    ref_top_data = this->ref_blob_top_->cpu_data();
437    for (int i = 0; i < this->blob_top_->count(); ++i) {
438      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
439    }
440  }
441  #endif
442  TYPED_TEST(MKLConvolutionLayerTest, Test1x1Convolution) {
443    typedef typename TypeParam::Dtype Dtype;
444    LayerParameter layer_param;
445    ConvolutionParameter* convolution_param =
446        layer_param.mutable_convolution_param();
447    convolution_param->add_kernel_size(1);
448    convolution_param->add_stride(1);
449    convolution_param->set_num_output(4);
450    convolution_param->mutable_weight_filler()->set_type("gaussian");
451    convolution_param->mutable_bias_filler()->set_type("constant");
452    convolution_param->mutable_bias_filler()->set_value(0.1);
453    shared_ptr<Layer<Dtype> > layer(
454        new MKLConvolutionLayer<Dtype>(layer_param));
455    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
456    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
457    const Dtype* top_data;
458    const Dtype* ref_top_data;
459    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
460        this->MakeReferenceTop(this->blob_top_));
461    top_data = this->blob_top_->cpu_data();
462    ref_top_data = this->ref_blob_top_->cpu_data();
463    for (int i = 0; i < this->blob_top_->count(); ++i) {
464      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
465    }
466  }
467  TYPED_TEST(MKLConvolutionLayerTest, TestSimpleConvolutionGroup) {
468    typedef typename TypeParam::Dtype Dtype;
469    LayerParameter layer_param;
470    ConvolutionParameter* convolution_param =
471        layer_param.mutable_convolution_param();
472    convolution_param->add_kernel_size(3);
473    convolution_param->add_stride(2);
474    convolution_param->set_num_output(3);
475    convolution_param->set_group(3);
476    convolution_param->mutable_weight_filler()->set_type("gaussian");
477    convolution_param->mutable_bias_filler()->set_type("constant");
478    convolution_param->mutable_bias_filler()->set_value(0.1);
479    shared_ptr<Layer<Dtype> > layer(
480        new MKLConvolutionLayer<Dtype>(layer_param));
481    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
482    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
483    const Dtype* top_data;
484    const Dtype* ref_top_data;
485    caffe_conv(this->blob_bottom_, convolution_param, layer->blobs(),
486        this->MakeReferenceTop(this->blob_top_));
487    top_data = this->blob_top_->cpu_data();
488    ref_top_data = this->ref_blob_top_->cpu_data();
489    for (int i = 0; i < this->blob_top_->count(); ++i) {
490      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
491    }
492  }
493  #if 0
494  TYPED_TEST(MKLConvolutionLayerTest, TestSobelConvolution) {
495    typedef typename TypeParam::Dtype Dtype;
496    shared_ptr<GaussianFiller<Dtype> > filler;
497    FillerParameter filler_param;
498    filler_param.set_value(1.);
499    filler.reset(new GaussianFiller<Dtype>(filler_param));
500    filler->Fill(this->blob_bottom_);
501    this->blob_bottom_2_->CopyFrom(*this->blob_bottom_);
502    LayerParameter layer_param;
503    ConvolutionParameter* convolution_param =
504        layer_param.mutable_convolution_param();
505    convolution_param->add_kernel_size(3);
506    convolution_param->add_stride(2);
507    convolution_param->set_num_output(1);
508    convolution_param->set_bias_term(false);
509    shared_ptr<Layer<Dtype> > layer(
510        new MKLConvolutionLayer<Dtype>(layer_param));
511    layer->blobs().resize(1);
512    layer->blobs()[0].reset(new Blob<Dtype>(1, 3, 3, 3));
513    Dtype* weights = layer->blobs()[0]->mutable_cpu_data();
514    for (int c = 0; c < 3; ++c) {
515      int i = c * 9;  
516      weights[i +  0] = -1;
517      weights[i +  1] =  0;
518      weights[i +  2] =  1;
519      weights[i +  3] = -2;
520      weights[i +  4] =  0;
521      weights[i +  5] =  2;
522      weights[i +  6] = -1;
523      weights[i +  7] =  0;
524      weights[i +  8] =  1;
525    }
526    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
527    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
528    vector<Blob<Dtype>*> sep_blob_bottom_vec;
529    vector<Blob<Dtype>*> sep_blob_top_vec;
530    shared_ptr<Blob<Dtype> > blob_sep(new Blob<Dtype>());
<span onclick='openModal()' class='match'>531    sep_blob_bottom_vec.push_back(this->blob_bottom_2_);
532    sep_blob_top_vec.push_back(this->blob_top_2_);
533    convolution_param->clear_kernel_size();
534    convolution_param->clear_stride();
535    convolution_param->set_kernel_h(3);
536    convolution_param->set_kernel_w(1);
537    convolution_param->set_stride_h(2);
538    convolution_param->set_stride_w(1);
539    convolution_param->set_num_output(1);
540    convolution_param->set_bias_term(false);
541    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
</span>542    layer->blobs().resize(1);
543    layer->blobs()[0].reset(new Blob<Dtype>(1, 3, 3, 1));
544    Dtype* weights_1 = layer->blobs()[0]->mutable_cpu_data();
545    for (int c = 0; c < 3; ++c) {
546      int i = c * 3;  
547      weights_1[i +  0] = 1;
548      weights_1[i +  1] = 2;
549      weights_1[i +  2] = 1;
550    }
551    layer->SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
552    layer->Forward(sep_blob_bottom_vec, sep_blob_top_vec);
553    blob_sep->CopyFrom(*this->blob_top_2_, false, true);
554    sep_blob_bottom_vec.clear();
555    sep_blob_bottom_vec.push_back(blob_sep.get());
556    convolution_param->set_kernel_h(1);
557    convolution_param->set_kernel_w(3);
558    convolution_param->set_stride_h(1);
559    convolution_param->set_stride_w(2);
560    convolution_param->set_num_output(1);
561    convolution_param->set_bias_term(false);
562    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
563    layer->blobs().resize(1);
564    layer->blobs()[0].reset(new Blob<Dtype>(1, 1, 1, 3));
565    Dtype* weights_2 = layer->blobs()[0]->mutable_cpu_data();
566    weights_2[0] = -1;
567    weights_2[1] =  0;
568    weights_2[2] =  1;
569    layer->SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
570    layer->Forward(sep_blob_bottom_vec, sep_blob_top_vec);
571    const Dtype* top_data = this->blob_top_->cpu_data();
572    const Dtype* sep_top_data = this->blob_top_2_->cpu_data();
573    for (int i = 0; i < this->blob_top_->count(); ++i) {
574      EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
575    }
576  }
577  #endif
578  #if 0
579  TYPED_TEST(MKLConvolutionLayerTest, TestNDAgainst2D) {
580    typedef typename TypeParam::Dtype Dtype;
581    const int kernel_h = 11;
582    const int kernel_w = 13;
583    vector<int> bottom_shape(4);
584    bottom_shape[0] = 15;
585    bottom_shape[1] = 18;
586    bottom_shape[2] = kernel_h * 2;
587    bottom_shape[3] = kernel_w * 2;
588    FillerParameter filler_param;
589    GaussianFiller<Dtype> filler(filler_param);
590    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
591      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
592      filler.Fill(this->blob_bottom_vec_[i]);
593    }
594    LayerParameter layer_param;
595    ConvolutionParameter* convolution_param =
596        layer_param.mutable_convolution_param();
597    convolution_param->set_num_output(12);
598    convolution_param->set_bias_term(false);
599    convolution_param->set_group(6);
600    convolution_param->set_kernel_h(kernel_h);
601    convolution_param->set_kernel_w(kernel_w);
602    convolution_param->mutable_weight_filler()->set_type("gaussian");
603    Blob<Dtype> weights;
604    Blob<Dtype> top_diff;
605    bool copy_diff;
606    bool reshape;
607    {
608      MKLConvolutionLayer<Dtype> layer(layer_param);
609      layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
610      top_diff.ReshapeLike(*this->blob_top_);
611      filler.Fill(&top_diff);
612      ASSERT_EQ(1, layer.blobs().size());
613      copy_diff = false; reshape = true;
614      weights.CopyFrom(*layer.blobs()[0], copy_diff, reshape);
615    }
616    vector<bool> propagate_down(1, true);
617    Blob<Dtype> result_2d;
618    Blob<Dtype> backward_result_2d;
619    Blob<Dtype> backward_weight_result_2d;
620    {
621      caffe_set(this->blob_top_->count(), Dtype(0),
622                this->blob_top_->mutable_cpu_data());
623      caffe_set(this->blob_bottom_->count(), Dtype(0),
624                this->blob_bottom_->mutable_cpu_diff());
625      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
626      convolution_param->set_force_nd_im2col(false);
627      MKLConvolutionLayer<Dtype> layer_2d(layer_param);
628      layer_2d.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
629      ASSERT_EQ(1, layer_2d.blobs().size());
630      copy_diff = false; reshape = false;
631      layer_2d.blobs()[0]->CopyFrom(weights, copy_diff, reshape);
632      layer_2d.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
633      copy_diff = false; reshape = true;
634      result_2d.CopyFrom(*this->blob_top_, copy_diff, reshape);
635      ASSERT_EQ(this->blob_top_->shape(), top_diff.shape());
636      caffe_copy(top_diff.count(), top_diff.cpu_data(),
637                 this->blob_top_->mutable_cpu_diff());
638      layer_2d.Backward(this->blob_top_vec_, propagate_down,
639                        this->blob_bottom_vec_);
640      copy_diff = true; reshape = true;
641      backward_result_2d.CopyFrom(*this->blob_bottom_, copy_diff, reshape);
642      backward_weight_result_2d.CopyFrom(weights, copy_diff, reshape);
643    }
644    Blob<Dtype> result_nd;
645    Blob<Dtype> backward_result_nd;
646    Blob<Dtype> backward_weight_result_nd;
647    {
648      caffe_set(this->blob_top_->count(), Dtype(0),
649                this->blob_top_->mutable_cpu_data());
650      caffe_set(this->blob_bottom_->count(), Dtype(0),
651                this->blob_bottom_->mutable_cpu_diff());
652      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
653      convolution_param->set_force_nd_im2col(true);
654      MKLConvolutionLayer<Dtype> layer_nd(layer_param);
655      layer_nd.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
656      ASSERT_EQ(1, layer_nd.blobs().size());
657      copy_diff = false; reshape = false;
658      layer_nd.blobs()[0]->CopyFrom(weights, copy_diff, reshape);
659      layer_nd.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
660      copy_diff = false; reshape = true;
661      result_nd.CopyFrom(*this->blob_top_, copy_diff, reshape);
662      ASSERT_EQ(this->blob_top_->shape(), top_diff.shape());
663      caffe_copy(top_diff.count(), top_diff.cpu_data(),
664                 this->blob_top_->mutable_cpu_diff());
665      layer_nd.Backward(this->blob_top_vec_, propagate_down,
666                        this->blob_bottom_vec_);
667      copy_diff = true; reshape = true;
668      backward_result_nd.CopyFrom(*this->blob_bottom_, copy_diff, reshape);
669      backward_weight_result_nd.CopyFrom(weights, copy_diff, reshape);
670    }
671    ASSERT_EQ(result_nd.count(), result_2d.count());
672    for (int i = 0; i < result_2d.count(); ++i)  {
673      EXPECT_EQ(result_2d.cpu_data()[i], result_nd.cpu_data()[i]);
674    }
675    ASSERT_EQ(backward_result_nd.count(), backward_result_2d.count());
676    for (int i = 0; i < backward_result_2d.count(); ++i) {
677      EXPECT_EQ(backward_result_2d.cpu_diff()[i],
678                backward_result_nd.cpu_diff()[i]);
679    }
680    ASSERT_EQ(backward_weight_result_nd.count(),
681              backward_weight_result_2d.count());
682    for (int i = 0; i < backward_weight_result_2d.count(); ++i) {
683      EXPECT_EQ(backward_weight_result_2d.cpu_diff()[i],
684                backward_weight_result_nd.cpu_diff()[i]);
685    }
686  }
687  #endif
688  TYPED_TEST(MKLConvolutionLayerTest, TestGradient) {
689    typedef typename TypeParam::Dtype Dtype;
690    LayerParameter layer_param;
691    ConvolutionParameter* convolution_param =
692        layer_param.mutable_convolution_param();
693    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
694    this->blob_top_vec_.push_back(this->blob_top_2_);
695    convolution_param->add_kernel_size(3);
696    convolution_param->add_stride(2);
697    convolution_param->set_num_output(2);
698    convolution_param->mutable_weight_filler()->set_type("gaussian");
699    convolution_param->mutable_bias_filler()->set_type("gaussian");
700    MKLConvolutionLayer<Dtype> layer(layer_param);
701    GradientChecker<Dtype> checker(1e-2, 1e-3);
702    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
703        this->blob_top_vec_);
704  }
705  #if 0
706  TYPED_TEST(MKLConvolutionLayerTest, TestDilatedGradient) {
707    typedef typename TypeParam::Dtype Dtype;
708    LayerParameter layer_param;
709    ConvolutionParameter* convolution_param =
710        layer_param.mutable_convolution_param();
711    vector<int> bottom_shape;
712    bottom_shape.push_back(2);
713    bottom_shape.push_back(3);
714    bottom_shape.push_back(5);
715    bottom_shape.push_back(6);
716    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
717      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
718    }
719    convolution_param->add_kernel_size(3);
720    convolution_param->add_dilation(2);
721    convolution_param->set_num_output(2);
722    convolution_param->mutable_weight_filler()->set_type("gaussian");
723    convolution_param->mutable_bias_filler()->set_type("gaussian");
724    MKLConvolutionLayer<Dtype> layer(layer_param);
725    GradientChecker<Dtype> checker(1e-2, 1e-3);
726    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
727                                    this->blob_top_vec_);
728  }
729  #endif
730  #if 0
731  TYPED_TEST(MKLConvolutionLayerTest, TestGradient3D) {
732    typedef typename TypeParam::Dtype Dtype;
733    LayerParameter layer_param;
734    ConvolutionParameter* convolution_param =
735        layer_param.mutable_convolution_param();
736    vector<int> bottom_shape(5);
737    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
738    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
739    bottom_shape[2] = 5;
740    bottom_shape[3] = this->blob_bottom_vec_[0]->shape(2);
741    bottom_shape[4] = this->blob_bottom_vec_[0]->shape(3);
742    FillerParameter filler_param;
743    GaussianFiller<Dtype> filler(filler_param);
744    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
745      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
746      filler.Fill(this->blob_bottom_vec_[i]);
747    }
748    convolution_param->add_kernel_size(3);
749    convolution_param->add_stride(2);
750    convolution_param->set_num_output(2);
751    convolution_param->mutable_weight_filler()->set_type("gaussian");
752    convolution_param->mutable_bias_filler()->set_type("gaussian");
753    MKLConvolutionLayer<Dtype> layer(layer_param);
754    GradientChecker<Dtype> checker(1e-2, 1e-3);
755    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
756        this->blob_top_vec_);
757  }
758  #endif
759  TYPED_TEST(MKLConvolutionLayerTest, Test1x1Gradient) {
760    typedef typename TypeParam::Dtype Dtype;
761    LayerParameter layer_param;
762    ConvolutionParameter* convolution_param =
763        layer_param.mutable_convolution_param();
764    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
765    this->blob_top_vec_.push_back(this->blob_top_2_);
766    convolution_param->add_kernel_size(1);
767    convolution_param->add_stride(1);
768    convolution_param->set_num_output(2);
769    convolution_param->mutable_weight_filler()->set_type("gaussian");
770    convolution_param->mutable_bias_filler()->set_type("gaussian");
771    MKLConvolutionLayer<Dtype> layer(layer_param);
772    GradientChecker<Dtype> checker(1e-2, 1e-3);
773    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
774        this->blob_top_vec_);
775  }
776  TYPED_TEST(MKLConvolutionLayerTest, TestGradientGroup) {
777    typedef typename TypeParam::Dtype Dtype;
778    LayerParameter layer_param;
779    ConvolutionParameter* convolution_param =
780        layer_param.mutable_convolution_param();
781    convolution_param->add_kernel_size(3);
782    convolution_param->add_stride(2);
783    convolution_param->set_num_output(3);
784    convolution_param->set_group(3);
785    convolution_param->mutable_weight_filler()->set_type("gaussian");
786    convolution_param->mutable_bias_filler()->set_type("gaussian");
787    MKLConvolutionLayer<Dtype> layer(layer_param);
788    GradientChecker<Dtype> checker(1e-2, 1e-3);
789    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
790        this->blob_top_vec_);
791  }
792  }  
793  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-subexport.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <iostream>
3  #include <numeric>
4  #include <cmath>
5  #include <climits>
6  #include "../../config/regmatch.h"
7  #include "../../generator/config/subexport.h"
8  #include "../../generator/template/templates.h"
9  #include "../../handler/settings.h"
10  #include "../../parser/config/proxy.h"
11  #include "../../script/script_quickjs.h"
12  #include "../../utils/bitwise.h"
13  #include "../../utils/file_extra.h"
14  #include "../../utils/ini_reader/ini_reader.h"
15  #include "../../utils/logger.h"
16  #include "../../utils/network.h"
17  #include "../../utils/rapidjson_extra.h"
18  #include "../../utils/regexp.h"
19  #include "../../utils/stl_extra.h"
20  #include "../../utils/urlencode.h"
21  #include "../../utils/yamlcpp_extra.h"
22  #include "nodemanip.h"
23  #include "ruleconvert.h"
24  extern string_array ss_ciphers, ssr_ciphers;
25  const string_array clashr_protocols = {"origin", "auth_sha1_v4", "auth_aes128_md5", "auth_aes128_sha1", "auth_chain_a", "auth_chain_b"};
26  const string_array clashr_obfs = {"plain", "http_simple", "http_post", "random_head", "tls1.2_ticket_auth", "tls1.2_ticket_fastauth"};
27  const string_array clash_ssr_ciphers = {"rc4-md5", "aes-128-ctr", "aes-192-ctr", "aes-256-ctr", "aes-128-cfb", "aes-192-cfb", "aes-256-cfb", "chacha20-ietf", "xchacha20", "none"};
28  std::string vmessLinkConstruct(const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &path, const std::string &host, const std::string &tls)
29  {
30      rapidjson::StringBuffer sb;
31      rapidjson::Writer<rapidjson::StringBuffer> writer(sb);
32      writer.StartObject();
33      writer.Key("v");
34      writer.String("2");
35      writer.Key("ps");
36      writer.String(remarks.data());
37      writer.Key("add");
38      writer.String(add.data());
39      writer.Key("port");
40      writer.String(port.data());
41      writer.Key("type");
42      writer.String(type.empty() ? "none" : type.data());
43      writer.Key("id");
44      writer.String(id.data());
45      writer.Key("aid");
46      writer.String(aid.data());
47      writer.Key("net");
48      writer.String(net.empty() ? "tcp" : net.data());
49      writer.Key("path");
50      writer.String(path.data());
51      writer.Key("host");
52      writer.String(host.data());
53      writer.Key("tls");
54      writer.String(tls.data());
55      writer.EndObject();
56      return sb.GetString();
57  }
58  bool matchRange(const std::string &range, int target)
59  {
60      string_array vArray = split(range, ",");
61      bool match = false;
62      std::string range_begin_str, range_end_str;
63      int range_begin, range_end;
64      static const std::string reg_num = "-?\\d+", reg_range = "(\\d+)-(\\d+)", reg_not = "\\!-?(\\d+)", reg_not_range = "\\!(\\d+)-(\\d+)", reg_less = "(\\d+)-", reg_more = "(\\d+)\\+";
65      for(std::string &x : vArray)
66      {
67          if(regMatch(x, reg_num))
68          {
69              if(to_int(x, INT_MAX) == target)
70                  match = true;
71          }
72          else if(regMatch(x, reg_range))
73          {
74              regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);
75              range_begin = to_int(range_begin_str, INT_MAX);
76              range_end = to_int(range_end_str, INT_MIN);
77              if(target >= range_begin && target <= range_end)
78                  match = true;
79          }
80          else if(regMatch(x, reg_not))
81          {
82              match = true;
83              if(to_int(regReplace(x, reg_not, "$1"), INT_MAX) == target)
84                  match = false;
85          }
86          else if(regMatch(x, reg_not_range))
87          {
88              match = true;
89              regGetMatch(x, reg_range, 3, 0, &range_begin_str, &range_end_str);
90              range_begin = to_int(range_begin_str, INT_MAX);
91              range_end = to_int(range_end_str, INT_MIN);
92              if(target >= range_begin && target <= range_end)
93                  match = false;
94          }
95          else if(regMatch(x, reg_less))
96          {
97              if(to_int(regReplace(x, reg_less, "$1"), INT_MAX) >= target)
98                  match = true;
99          }
100          else if(regMatch(x, reg_more))
101          {
102              if(to_int(regReplace(x, reg_more, "$1"), INT_MIN) <= target)
103                  match = true;
104          }
105      }
106      return match;
107  }
108  bool applyMatcher(const std::string &rule, std::string &real_rule, const Proxy &node)
109  {
110      std::string target, ret_real_rule;
111      static const std::string groupid_regex = R"(^!!(?:GROUPID|INSERT)=([\d\-+!,]+)(?:!!(.*))?$)", group_regex = R"(^!!(?:GROUP)=(.+?)(?:!!(.*))?$)";
112      static const std::string type_regex = R"(^!!(?:TYPE)=(.+?)(?:!!(.*))?$)", port_regex = R"(^!!(?:PORT)=(.+?)(?:!!(.*))?$)", server_regex = R"(^!!(?:SERVER)=(.+?)(?:!!(.*))?$)";
113      static const string_array types = {"", "SS", "SSR", "VMESS", "TROJAN", "SNELL", "HTTP", "HTTPS", "SOCKS5"};
114      if(startsWith(rule, "!!GROUP="))
115      {
116          regGetMatch(rule, group_regex, 3, 0, &target, &ret_real_rule);
117          real_rule = ret_real_rule;
118          return regFind(node.Group, target);
119      }
120      else if(startsWith(rule, "!!GROUPID=") || startsWith(rule, "!!INSERT="))
121      {
122          int dir = startsWith(rule, "!!INSERT=") ? -1 : 1;
123          regGetMatch(rule, groupid_regex, 3, 0, &target, &ret_real_rule);
124          real_rule = ret_real_rule;
125          return matchRange(target, dir * node.GroupId);
126      }
127      else if(startsWith(rule, "!!TYPE="))
128      {
129          regGetMatch(rule, type_regex, 3, 0, &target, &ret_real_rule);
130          real_rule = ret_real_rule;
131          if(node.Type == ProxyType::Unknow)
132              return false;
133          return regMatch(types[node.Type], target);
134      }
135      else if(startsWith(rule, "!!PORT="))
136      {
137          regGetMatch(rule, port_regex, 3, 0, &target, &ret_real_rule);
138          real_rule = ret_real_rule;
139          return matchRange(target, node.Port);
140      }
141      else if(startsWith(rule, "!!SERVER="))
142      {
143          regGetMatch(rule, server_regex, 3, 0, &target, &ret_real_rule);
144          real_rule = ret_real_rule;
145          return regFind(node.Hostname, target);
146      }
147      else
148          real_rule = rule;
149      return true;
150  }
151  void processRemark(std::string &oldremark, std::string &newremark, string_array &remarks_list, bool proc_comma = true)
152  {
153      if(proc_comma)
154      {
155          if(oldremark.find(',') != oldremark.npos)
156          {
157              oldremark.insert(0, "\"");
158              oldremark.append("\"");
159          }
160      }
161      newremark = oldremark;
162      int cnt = 2;
163      while(std::find(remarks_list.begin(), remarks_list.end(), newremark) != remarks_list.end())
164      {
165          newremark = oldremark + " " + std::to_string(cnt);
166          cnt++;
167      }
168      oldremark = newremark;
169  }
170  void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)
171  {
172      std::string real_rule;
173      if(startsWith(rule, "[]") && add_direct)
174      {
175          filtered_nodelist.emplace_back(rule.substr(2));
176      }
177  #ifndef NO_JS_RUNTIME
178      else if(startsWith(rule, "script:") && ext.authorized)
179      {
180          script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){
181              std::string script = fileGet(rule.substr(7), true);
182              try
183              {
184                  ctx.eval(script);
185                  auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval("filter");
186                  std::string result_list = filter(nodelist);
187                  filtered_nodelist = split(regTrim(result_list), "\n");
188              }
189              catch (qjs::exception)
190              {
191                  script_print_stack(ctx);
192              }
193          }, global.scriptCleanContext);
194      }
195  #endif 
196      else
197      {
198          for(Proxy &x : nodelist)
199          {
200              if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())
201                  filtered_nodelist.emplace_back(x.Remark);
202          }
203      }
204  }
205  void proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)
206  {
207      YAML::Node proxies, singleproxy, singlegroup, original_groups;
208      std::vector<Proxy> nodelist;
209      string_array remarks_list, filtered_nodelist;
210      bool block = false, compact = false;
211      switch(hash_(ext.clash_proxies_style))
212      {
213      case "block"_hash:
214          block = true;
215          break;
216      default:
217      case "flow"_hash:
218          break;
219      case "compact"_hash:
220          compact = true;
221          break;
222      }
223      for(Proxy &x : nodes)
224      {
225          singleproxy.reset();
226          std::string type = getProxyTypeName(x.Type);
227          std::string remark, pluginopts = replaceAllDistinct(x.PluginOption, ";", "&");
228          if(ext.append_proxy_type)
229              x.Remark = "[" + type + "] " + x.Remark;
230          processRemark(x.Remark, remark, remarks_list, false);
231          tribool udp = ext.udp;
232          tribool scv = ext.skip_cert_verify;
233          udp.define(x.UDP);
234          scv.define(x.AllowInsecure);
235          singleproxy["name"] = remark;
236          singleproxy["server"] = x.Hostname;
237          singleproxy["port"] = x.Port;
238          switch(x.Type)
239          {
240          case ProxyType::Shadowsocks:
241              if(ext.filter_deprecated && x.EncryptMethod == "chacha20")
242                  continue;
243              singleproxy["type"] = "ss";
244              singleproxy["cipher"] = x.EncryptMethod;
245              singleproxy["password"] = x.Password;
246              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
247                  singleproxy["password"].SetTag("str");
248              switch(hash_(x.Plugin))
249              {
250              case "simple-obfs"_hash:
251              case "obfs-local"_hash:
252                  singleproxy["plugin"] = "obfs";
253                  singleproxy["plugin-opts"]["mode"] = urlDecode(getUrlArg(pluginopts, "obfs"));
254                  singleproxy["plugin-opts"]["host"] = urlDecode(getUrlArg(pluginopts, "obfs-host"));
255                  break;
256              case "v2ray-plugin"_hash:
257                  singleproxy["plugin"] = "v2ray-plugin";
258                  singleproxy["plugin-opts"]["mode"] = getUrlArg(pluginopts, "mode");
259                  singleproxy["plugin-opts"]["host"] = getUrlArg(pluginopts, "host");
260                  singleproxy["plugin-opts"]["path"] = getUrlArg(pluginopts, "path");
261                  singleproxy["plugin-opts"]["tls"] = pluginopts.find("tls") != std::string::npos;
262                  singleproxy["plugin-opts"]["mux"] = pluginopts.find("mux") != std::string::npos;
263                  if(!scv.is_undef())
264                      singleproxy["plugin-opts"]["skip-cert-verify"] = scv.get();
265                  break;
266              }
267              break;
268          case ProxyType::VMess:
269              singleproxy["type"] = "vmess";
270              singleproxy["uuid"] = x.UserId;
271              singleproxy["alterId"] = x.AlterId;
272              singleproxy["cipher"] = x.EncryptMethod;
273              singleproxy["tls"] = x.TLSSecure;
274              if(!scv.is_undef())
275                  singleproxy["skip-cert-verify"] = scv.get();
276              if(!x.ServerName.empty())
277                  singleproxy["servername"] = x.ServerName;
278              switch(hash_(x.TransferProtocol))
279              {
280              case "tcp"_hash:
281                  break;
282              case "ws"_hash:
283                  singleproxy["network"] = x.TransferProtocol;
284                  if(ext.clash_new_field_name)
285                  {
286                      singleproxy["ws-opts"]["path"] = x.Path;
287                      if(!x.Host.empty())
288                          singleproxy["ws-opts"]["headers"]["Host"] = x.Host;
289                      if(!x.Edge.empty())
290                          singleproxy["ws-opts"]["headers"]["Edge"] = x.Edge;
291                  }
292                  else
293                  {
294                      singleproxy["ws-path"] = x.Path;
295                      if(!x.Host.empty())
296                          singleproxy["ws-headers"]["Host"] = x.Host;
297                      if(!x.Edge.empty())
298                          singleproxy["ws-headers"]["Edge"] = x.Edge;
299                  }
300                  break;
301              case "http"_hash:
302                  singleproxy["network"] = x.TransferProtocol;
303                  singleproxy["http-opts"]["method"] = "GET";
304                  singleproxy["http-opts"]["path"].push_back(x.Path);
305                  if(!x.Host.empty())
306                      singleproxy["http-opts"]["headers"]["Host"].push_back(x.Host);
307                  if(!x.Edge.empty())
308                      singleproxy["http-opts"]["headers"]["Edge"].push_back(x.Edge);
309                  break;
310              case "h2"_hash:
311                  singleproxy["network"] = x.TransferProtocol;
312                  singleproxy["h2-opts"]["path"] = x.Path;
313                  if(!x.Host.empty())
314                      singleproxy["h2-opts"]["host"].push_back(x.Host);
315                  break;
316              case "grpc"_hash:
317                  singleproxy["network"] = x.TransferProtocol;
318                  singleproxy["servername"] = x.Host;
319                  singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
320                  break;
321              default:
322                  continue;
323              }
324              break;
325          case ProxyType::ShadowsocksR:
326              if(ext.filter_deprecated)
327              {
328                  if(!clashR && std::find(clash_ssr_ciphers.cbegin(), clash_ssr_ciphers.cend(), x.EncryptMethod) == clash_ssr_ciphers.cend())
329                      continue;
330                  if(std::find(clashr_protocols.cbegin(), clashr_protocols.cend(), x.Protocol) == clashr_protocols.cend())
331                      continue;
332                  if(std::find(clashr_obfs.cbegin(), clashr_obfs.cend(), x.OBFS) == clashr_obfs.cend())
333                      continue;
334              }
335              singleproxy["type"] = "ssr";
336              singleproxy["cipher"] = x.EncryptMethod == "none" ? "dummy" : x.EncryptMethod;
337              singleproxy["password"] = x.Password;
338              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
339                  singleproxy["password"].SetTag("str");
340              singleproxy["protocol"] = x.Protocol;
341              singleproxy["obfs"] = x.OBFS;
342              if(clashR)
343              {
344                  singleproxy["protocolparam"] = x.ProtocolParam;
345                  singleproxy["obfsparam"] = x.OBFSParam;
346              }
347              else
348              {
349                  singleproxy["protocol-param"] = x.ProtocolParam;
350                  singleproxy["obfs-param"] = x.OBFSParam;
351              }
352              break;
353          case ProxyType::SOCKS5:
354              singleproxy["type"] = "socks5";
355              if(!x.Username.empty())
356                  singleproxy["username"] = x.Username;
357              if(!x.Password.empty())
358              {
359                  singleproxy["password"] = x.Password;
360                  if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))
361                      singleproxy["password"].SetTag("str");
362              }
363              if(!scv.is_undef())
364                  singleproxy["skip-cert-verify"] = scv.get();
365              break;
366          case ProxyType::HTTP:
367          case ProxyType::HTTPS:
368              singleproxy["type"] = "http";
369              if(!x.Username.empty())
370                  singleproxy["username"] = x.Username;
371              if(!x.Password.empty())
372              {
373                  singleproxy["password"] = x.Password;
374                  if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit))
375                      singleproxy["password"].SetTag("str");
376              }
377              singleproxy["tls"] = x.TLSSecure;
378              if(!scv.is_undef())
379                  singleproxy["skip-cert-verify"] = scv.get();
380              break;
381          case ProxyType::Trojan:
382              singleproxy["type"] = "trojan";
383              singleproxy["password"] = x.Password;
384              if(!x.Host.empty())
385                  singleproxy["sni"] = x.Host;
386              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
387                  singleproxy["password"].SetTag("str");
388              if(!scv.is_undef())
389                  singleproxy["skip-cert-verify"] = scv.get();
390              switch(hash_(x.TransferProtocol))
391              {
392              case "tcp"_hash:
393                  break;
394              case "grpc"_hash:
395                  singleproxy["network"] = x.TransferProtocol;
396                  if(!x.Path.empty())
397                      singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
398                  break;
399              case "ws"_hash:
400                  singleproxy["network"] = x.TransferProtocol;
401                  singleproxy["ws-opts"]["path"] = x.Path;
402                  if(!x.Host.empty())
403                      singleproxy["ws-opts"]["headers"]["Host"] = x.Host;
404                  break;
405              }
406              break;
407          case ProxyType::Snell:
408              singleproxy["type"] = "snell";
409              singleproxy["psk"] = x.Password;
410              if(x.SnellVersion != 0)
411                  singleproxy["version"] = x.SnellVersion;
412              if(!x.OBFS.empty())
413              {
414                  singleproxy["obfs-opts"]["mode"] = x.OBFS;
415                  if(!x.Host.empty())
416                      singleproxy["obfs-opts"]["host"] = x.Host;
417              }
418              if(std::all_of(x.Password.begin(), x.Password.end(), ::isdigit) && !x.Password.empty())
419                  singleproxy["password"].SetTag("str");
420              break;
421          default:
422              continue;
423          }
424          if(udp)
425              singleproxy["udp"] = true;
426          if(block)
427              singleproxy.SetStyle(YAML::EmitterStyle::Block);
428          else
429              singleproxy.SetStyle(YAML::EmitterStyle::Flow);
430          proxies.push_back(singleproxy);
431          remarks_list.emplace_back(std::move(remark));
432          nodelist.emplace_back(x);
433      }
434      if(compact)
435          proxies.SetStyle(YAML::EmitterStyle::Flow);
436      if(ext.nodelist)
437      {
438          YAML::Node provider;
439          provider["proxies"] = proxies;
440          yamlnode.reset(provider);
441          return;
442      }
443      if(ext.clash_new_field_name)
444          yamlnode["proxies"] = proxies;
445      else
446          yamlnode["Proxy"] = proxies;
447      for(const ProxyGroupConfig &x : extra_proxy_group)
448      {
449          singlegroup.reset();
450          eraseElements(filtered_nodelist);
451          singlegroup["name"] = x.Name;
452          singlegroup["type"] = x.TypeStr();
453          switch(x.Type)
454          {
455          case ProxyGroupType::Select:
456          case ProxyGroupType::Relay:
457              break;
458          case ProxyGroupType::LoadBalance:
459              singlegroup["strategy"] = x.StrategyStr();
460              [[fallthrough]];
461          case ProxyGroupType::URLTest:
462              if(!x.Lazy.is_undef())
463                  singlegroup["lazy"] = x.Lazy.get();
464              [[fallthrough]];
465          case ProxyGroupType::Fallback:
466              singlegroup["url"] = x.Url;
467              if(x.Interval > 0)
468                  singlegroup["interval"] = x.Interval;
469              if(x.Tolerance > 0)
470                  singlegroup["tolerance"] = x.Tolerance;
471              break;
472          default:
473              continue;
474          }
475          if(!x.DisableUdp.is_undef())
476              singlegroup["disable-udp"] = x.DisableUdp.get();
477          for(const auto& y : x.Proxies)
478              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
479          if(!x.UsingProvider.empty())
480              singlegroup["use"] = x.UsingProvider;
481          else
482          {
483              if(filtered_nodelist.empty())
484                  filtered_nodelist.emplace_back("DIRECT");
485          }
486          if(!filtered_nodelist.empty())
487              singlegroup["proxies"] = filtered_nodelist;
488          bool replace_flag = false;
489          for(unsigned int i = 0; i < original_groups.size(); i++)
490          {
491              if(original_groups[i]["name"].as<std::string>() == x.Name)
492              {
493                  original_groups[i] = singlegroup;
494                  replace_flag = true;
495                  break;
496              }
497          }
498          if(!replace_flag)
499              original_groups.push_back(singlegroup);
500      }
501      if(ext.clash_new_field_name)
502          yamlnode["proxy-groups"] = original_groups;
503      else
504          yamlnode["Proxy Group"] = original_groups;
505  }
506  std::string proxyToClash(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, bool clashR, extra_settings &ext)
507  {
508      YAML::Node yamlnode;
509      try
510      {
511          yamlnode = YAML::Load(base_conf);
512      }
513      catch (std::exception &e)
514      {
515          writeLog(0, std::string("Clash base loader failed with error: ") + e.what(), LOG_LEVEL_ERROR);
516          return std::string();
517      }
518      proxyToClash(nodes, yamlnode, extra_proxy_group, clashR, ext);
519      if(ext.nodelist)
520          return YAML::Dump(yamlnode);
521      if(!ext.enable_rule_generator)
522          return YAML::Dump(yamlnode);
523      if(!ext.managed_config_prefix.empty() || ext.clash_script)
524      {
525          if(yamlnode["mode"].IsDefined())
526          {
527              if(ext.clash_new_field_name)
528                  yamlnode["mode"] = ext.clash_script ? "script" : "rule";
529              else
530                  yamlnode["mode"] = ext.clash_script ? "Script" : "Rule";
531          }
532          renderClashScript(yamlnode, ruleset_content_array, ext.managed_config_prefix, ext.clash_script, ext.overwrite_original_rules, ext.clash_classical_ruleset);
533          return YAML::Dump(yamlnode);
534      }
535      std::string output_content = rulesetToClashStr(yamlnode, ruleset_content_array, ext.overwrite_original_rules, ext.clash_new_field_name);
536      output_content.insert(0, YAML::Dump(yamlnode));
537      return output_content;
538  }
539  std::string proxyToSurge(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, int surge_ver, extra_settings &ext)
540  {
541      INIReader ini;
542      std::string proxy;
543      std::string output_nodelist;
544      tribool udp, tfo, scv, tls13;
545      std::vector<Proxy> nodelist;
546      unsigned short local_port = 1080;
547      string_array remarks_list, filtered_nodelist, args;
548      ini.store_any_line = true;
549      ini.AddDirectSaveSection("General");
550      ini.AddDirectSaveSection("Replica");
551      ini.AddDirectSaveSection("Rule");
552      ini.AddDirectSaveSection("MITM");
553      ini.AddDirectSaveSection("Script");
554      ini.AddDirectSaveSection("Host");
555      ini.AddDirectSaveSection("URL Rewrite");
556      ini.AddDirectSaveSection("Header Rewrite");
557      if(ini.Parse(base_conf) != 0 && !ext.nodelist)
558      {
559          writeLog(0, "Surge base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
560          return std::string();
561      }
562      ini.SetCurrentSection("Proxy");
563      ini.EraseSection();
564      ini.Set("{NONAME}", "DIRECT = direct");
565      for(Proxy &x : nodes)
566      {
567          std::string remark;
568          if(ext.append_proxy_type)
569          {
570              std::string type = getProxyTypeName(x.Type);
571              x.Remark = "[" + type + "] " + x.Remark;
572          }
573          processRemark(x.Remark, remark, remarks_list);
574          std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &edge = x.Edge, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption;
575          std::string port = std::to_string(x.Port);
576          bool &tlssecure = x.TLSSecure;
577          udp = ext.udp;
578          tfo = ext.tfo;
579          scv = ext.skip_cert_verify;
580          tls13 = ext.tls13;
581          udp.define(x.UDP);
582          tfo.define(x.TCPFastOpen);
583          scv.define(x.AllowInsecure);
584          tls13.define(x.TLS13);
585          proxy.clear();
586          switch(x.Type)
587          {
588          case ProxyType::Shadowsocks:
589              if(surge_ver >= 3 || surge_ver == -3)
590              {
591                  proxy = "ss, " + hostname + ", " + port + ", encrypt-method=" + method + ", password=" + password;
592              }
593              else
594              {
595                  proxy = "custom, "  + hostname + ", " + port + ", " + method + ", " + password + ", https:&bsol;&bsol;github.com/pobizhe/SSEncrypt/raw/master/SSEncrypt.module";
596              }
597              if(!plugin.empty())
598              {
599                  switch(hash_(plugin))
600                  {
601                  case "simple-obfs"_hash:
602                  case "obfs-local"_hash:
603                      if(!pluginopts.empty())
604                          proxy += "," + replaceAllDistinct(pluginopts, ";", ",");
605                      break;
606                  default:
607                      continue;
608                  }
609              }
610              break;
611          case ProxyType::VMess:
612              if(surge_ver < 4 && surge_ver != -3)
613                  continue;
614              proxy = "vmess, " + hostname + ", " + port + ", username=" + id + ", tls=" + (tlssecure ? "true" : "false") +  ", vmess-aead=" + (x.AlterId == 0 ? "true" : "false");
615              if(tlssecure && !tls13.is_undef())
616                  proxy += ", tls13=" + std::string(tls13 ? "true" : "false");
617              switch(hash_(transproto))
618              {
619              case "tcp"_hash:
620                  break;
621              case "ws"_hash:
622                  if(host.empty())
623                      proxy += ", ws=true, ws-path=" + path + ", sni=" + hostname;
624                  else
625                      proxy += ", ws=true, ws-path=" + path + ", sni=" + hostname + ", ws-headers=Host:" + host;
626                  if(!edge.empty())
627                      proxy += "|Edge:" + edge;
628                  break;
629              default:
630                  continue;
631              }
632              if(!scv.is_undef())
633                  proxy += ", skip-cert-verify=" + scv.get_str();
634              break;
635          case ProxyType::ShadowsocksR:
636              if(ext.surge_ssr_path.empty() || surge_ver < 2)
637                  continue;
638              proxy = "external, exec=\"" + ext.surge_ssr_path + "\", args=\"";
639              args = {"-l", std::to_string(local_port), "-s", hostname, "-p", port, "-m", method, "-k", password, "-o", obfs, "-O", protocol};
640              if(!obfsparam.empty())
641              {
642                  args.emplace_back("-g");
643                  args.emplace_back(std::move(obfsparam));
644              }
645              if(!protoparam.empty())
646              {
647                  args.emplace_back("-G");
648                  args.emplace_back(std::move(protoparam));
649              }
650              proxy += join(args, "\", args=\"");
651              proxy += "\", local-port=" + std::to_string(local_port);
652              if(isIPv4(hostname) || isIPv6(hostname))
653                  proxy += ", addresses=" + hostname;
654              else if(global.surgeResolveHostname)
655                  proxy += ", addresses=" + hostnameToIPAddr(hostname);
656              local_port++;
657              break;
658          case ProxyType::SOCKS5:
659              proxy = "socks5, " + hostname + ", " + port;
660              if(!username.empty())
661                  proxy += ", username=" + username;
662              if(!password.empty())
663                  proxy += ", password=" + password;
664              if(!scv.is_undef())
665                  proxy += ", skip-cert-verify=" + scv.get_str();
666              break;
667          case ProxyType::HTTPS:
668              if(surge_ver == -3)
669              {
670                  proxy = "https, " + hostname + ", " + port + ", " + username + ", " + password;
671                  if(!scv.is_undef())
672                      proxy += ", skip-cert-verify=" + scv.get_str();
673                  break;
674              }
675              [[fallthrough]];
676          case ProxyType::HTTP:
677              proxy = "http, " + hostname + ", " + port;
678              if(!username.empty())
679                  proxy += ", username=" + username;
680              if(!password.empty())
681                  proxy += ", password=" + password;
682              proxy += std::string(", tls=") + (x.TLSSecure ? "true" : "false");
683              if(!scv.is_undef())
684                  proxy += ", skip-cert-verify=" + scv.get_str();
685              break;
686          case ProxyType::Trojan:
687              if(surge_ver < 4 && surge_ver != -3)
688                  continue;
689              proxy = "trojan, " + hostname + ", " + port + ", password=" + password;
690              if(x.SnellVersion != 0)
691                  proxy += ", version=" + std::to_string(x.SnellVersion);
692              if(!host.empty())
693                  proxy += ", sni=" + host;
694              if(!scv.is_undef())
695                  proxy += ", skip-cert-verify=" + scv.get_str();
696              break;
697          case ProxyType::Snell:
698              proxy = "snell, " + hostname + ", " + port + ", psk=" + password;
699              if(!obfs.empty())
700                  proxy += ", obfs=" + obfs + ", obfs-host=" + host;
701              break;
702          default:
703              continue;
704          }
705          if(!tfo.is_undef())
706              proxy += ", tfo=" + tfo.get_str();
707          if(!udp.is_undef())
708              proxy += ", udp-relay=" + udp.get_str();
709          if(ext.nodelist)
710              output_nodelist += remark + " = " + proxy + "\n";
711          else
712          {
713              ini.Set("{NONAME}", remark + " = " + proxy);
714              nodelist.emplace_back(x);
715          }
716          remarks_list.emplace_back(std::move(remark));
717      }
718      if(ext.nodelist)
719          return output_nodelist;
720      ini.SetCurrentSection("Proxy Group");
721      ini.EraseSection();
722      for(const ProxyGroupConfig &x : extra_proxy_group)
723      {
724          eraseElements(filtered_nodelist);
725          proxy.clear();
726          switch(x.Type)
727          {
728          case ProxyGroupType::Select:
729          case ProxyGroupType::URLTest:
730          case ProxyGroupType::Fallback:
731              break;
732          case ProxyGroupType::LoadBalance:
733              if(surge_ver < 1 && surge_ver != -3)
734                  continue;
735              break;
736          case ProxyGroupType::SSID:
737              proxy = x.TypeStr() + ",default=" + x.Proxies[0] + ",";
738              proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), ",");
739              ini.Set("{NONAME}", x.Name + " = " + proxy); 
740              continue;
741          default:
742              continue;
743          }
744          for(const auto &y : x.Proxies)
745              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
746          if(filtered_nodelist.empty())
747              filtered_nodelist.emplace_back("DIRECT");
748          if(filtered_nodelist.size() == 1)
749          {
750              proxy = toLower(filtered_nodelist[0]);
751              switch(hash_(proxy))
752              {
753              case "direct"_hash:
754              case "reject"_hash:
755              case "reject-tinygif"_hash:
756                  ini.Set("Proxy", "{NONAME}", x.Name + " = " + proxy);
757                  continue;
758              }
759          }
760          proxy = x.TypeStr() + ",";
761          proxy += join(filtered_nodelist, ",");
762          if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback || x.Type == ProxyGroupType::LoadBalance)
763          {
764              proxy += ",url=" + x.Url + ",interval=" + std::to_string(x.Interval);
765              if(x.Tolerance > 0)
766                  proxy += ",tolerance=" + std::to_string(x.Tolerance);
767              if(x.Timeout > 0)
768                  proxy += ",timeout=" + std::to_string(x.Timeout);
769              if(!x.Persistent.is_undef())
770                  proxy += ",persistent=" + x.Persistent.get_str();
771              if(!x.EvaluateBeforeUse.is_undef())
772                  proxy += ",evaluate-before-use=" + x.EvaluateBeforeUse.get_str();
773          }
774          ini.Set("{NONAME}", x.Name + " = " + proxy); 
775      }
776      if(ext.enable_rule_generator)
777          rulesetToSurge(ini, ruleset_content_array, surge_ver, ext.overwrite_original_rules, ext.managed_config_prefix);
778      return ini.ToString();
779  }
780  std::string proxyToSingle(std::vector<Proxy> &nodes, int types, extra_settings &ext)
781  {
782      std::string remark, hostname, port, password, method;
783      std::string plugin, pluginopts;
784      std::string protocol, protoparam, obfs, obfsparam;
785      std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret;
786      std::string proxyStr, allLinks;
787      bool ss = GETBIT(types, 1), ssr = GETBIT(types, 2), vmess = GETBIT(types, 3), trojan = GETBIT(types, 4);
788      for(Proxy &x : nodes)
789      {
790          remark = x.Remark;
791          std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &faketype = x.FakeType;
792          bool &tlssecure = x.TLSSecure;
793          std::string port = std::to_string(x.Port);
794          std::string aid = std::to_string(x.AlterId);
795          switch(x.Type)
796          {
797          case ProxyType::Shadowsocks:
798              if(ss)
799              {
800                  proxyStr = "ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port;
801                  if(!plugin.empty() && !pluginopts.empty())
802                  {
803                      proxyStr += "/?plugin=" + urlEncode(plugin + ";" + pluginopts);
804                  }
805                  proxyStr += "#" + urlEncode(remark);
806              }
807              else if(ssr)
808              {
809                  if(std::find(ssr_ciphers.begin(), ssr_ciphers.end(), method) != ssr_ciphers.end() && plugin.empty())
810                      proxyStr = "ssr:&bsol;&bsol;" + urlSafeBase64Encode(hostname + ":" + port + ":origin:" + method + ":plain:" + urlSafeBase64Encode(password) \
811                                 + "/?group=" + urlSafeBase64Encode(x.Group) + "&remarks=" + urlSafeBase64Encode(remark));
812              }
813              else
814                  continue;
815              break;
816          case ProxyType::ShadowsocksR:
817              if(ssr)
818              {
819                  proxyStr = "ssr:&bsol;&bsol;" + urlSafeBase64Encode(hostname + ":" + port + ":" + protocol + ":" + method + ":" + obfs + ":" + urlSafeBase64Encode(password) \
820                             + "/?group=" + urlSafeBase64Encode(x.Group) + "&remarks=" + urlSafeBase64Encode(remark) \
821                             + "&obfsparam=" + urlSafeBase64Encode(obfsparam) + "&protoparam=" + urlSafeBase64Encode(protoparam));
822              }
823              else if(ss)
824              {
825                  if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) != ss_ciphers.end() && protocol == "origin" && obfs == "plain")
826                      proxyStr = "ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port + "#" + urlEncode(remark);
827              }
828              else
829                  continue;
830              break;
831          case ProxyType::VMess:
832              if(!vmess)
833                  continue;
834              proxyStr = "vmess:&bsol;&bsol;" + base64Encode(vmessLinkConstruct(remark, hostname, port, faketype, id, aid, transproto, path, host, tlssecure ? "tls" : ""));
835              break;
836          case ProxyType::Trojan:
837              if(!trojan)
838                  continue;
839              proxyStr = "trojan:&bsol;&bsol;" + password + "@" + hostname + ":" + port + "?allowInsecure=" + (x.AllowInsecure.get() ? "1" : "0");
840              if(!host.empty())
841                  proxyStr += "&sni=" + host;
842              if(transproto == "ws")
843              {
844                  proxyStr += "&ws=1";
845                  if(!path.empty())
846                      proxyStr += "&wspath=" + urlEncode(path);
847              }
848              proxyStr += "#" + urlEncode(remark);
849              break;
850          default:
851              continue;
852          }
853          allLinks += proxyStr + "\n";
854      }
855      if(ext.nodelist)
856          return allLinks;
857      else
858          return base64Encode(allLinks);
859  }
860  std::string proxyToSSSub(std::string base_conf, std::vector<Proxy> &nodes, extra_settings &ext)
861  {
862      rapidjson::Document json, base;
863      std::string remark, hostname, password, method;
864      std::string plugin, pluginopts;
865      std::string protocol, obfs;
866      std::string output_content;
867      rapidjson::Document::AllocatorType &alloc = json.GetAllocator();
868      json.SetObject();
869      json.AddMember("remarks", "", alloc);
870      json.AddMember("server", "", alloc);
871      json.AddMember("server_port", 0, alloc);
872      json.AddMember("method", "", alloc);
873      json.AddMember("password", "", alloc);
874      json.AddMember("plugin", "", alloc);
875      json.AddMember("plugin_opts", "", alloc);
876      base_conf = trimWhitespace(base_conf);
877      if(base_conf.empty())
878          base_conf = "{}";
879      rapidjson::ParseResult result = base.Parse(base_conf.data());
880      if(result)
881      {
882          for(auto iter = base.MemberBegin(); iter != base.MemberEnd(); iter++)
883              json.AddMember(iter->name, iter->value, alloc);
884      }
885      else
886          writeLog(0, std::string("SIP008 base loader failed with error: ") + rapidjson::GetParseError_En(result.Code()) + " (" + std::to_string(result.Offset()) + ")", LOG_LEVEL_ERROR);
887      rapidjson::Value jsondata;
888      jsondata = json.Move();
889      output_content = "[";
890      for(Proxy &x : nodes)
891      {
892          remark = x.Remark;
893          hostname = x.Hostname;
894          std::string &password = x.Password;
895          std::string &method = x.EncryptMethod;
896          std::string &plugin = x.Plugin;
897          std::string &pluginopts = x.PluginOption;
898          std::string &protocol = x.Protocol;
899          std::string &obfs = x.OBFS;
900          switch(x.Type)
901          {
902          case ProxyType::Shadowsocks:
903              if(plugin == "simple-obfs")
904                  plugin = "obfs-local";
905              break;
906          case ProxyType::ShadowsocksR:
907              if(std::find(ss_ciphers.begin(), ss_ciphers.end(), method) == ss_ciphers.end() || protocol != "origin" || obfs != "plain")
908                  continue;
909              break;
910          default:
911              continue;
912          }
913          jsondata["remarks"].SetString(rapidjson::StringRef(remark.c_str(), remark.size()));
914          jsondata["server"].SetString(rapidjson::StringRef(hostname.c_str(), hostname.size()));
915          jsondata["server_port"] = x.Port;
916          jsondata["password"].SetString(rapidjson::StringRef(password.c_str(), password.size()));
917          jsondata["method"].SetString(rapidjson::StringRef(method.c_str(), method.size()));
918          jsondata["plugin"].SetString(rapidjson::StringRef(plugin.c_str(), plugin.size()));
919          jsondata["plugin_opts"].SetString(rapidjson::StringRef(pluginopts.c_str(), pluginopts.size()));
920          output_content += SerializeObject(jsondata) + ",";
921      }
922      if(output_content.size() > 1)
923          output_content.erase(output_content.size() - 1);
924      output_content += "]";
925      return output_content;
926  }
927  std::string proxyToQuan(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
928  {
929      INIReader ini;
930      ini.store_any_line = true;
931      if(!ext.nodelist && ini.Parse(base_conf) != 0)
932      {
933          writeLog(0, "Quantumult base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
934          return std::string();
935      }
936      proxyToQuan(nodes, ini, ruleset_content_array, extra_proxy_group, ext);
937      if(ext.nodelist)
938      {
939          string_array allnodes;
940          std::string allLinks;
941          ini.GetAll("SERVER", "{NONAME}", allnodes);
942          if(!allnodes.empty())
943              allLinks = join(allnodes, "\n");
944          return base64Encode(allLinks);
945      }
946      return ini.ToString();
947  }
948  void proxyToQuan(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
949  {
950      std::string type, proxyStr;
951      tribool scv;
952      std::vector<Proxy> nodelist;
953      string_array remarks_list;
954      ini.SetCurrentSection("SERVER");
955      ini.EraseSection();
956      for(Proxy &x : nodes)
957      {
958          std::string remark = x.Remark;
959          if(ext.append_proxy_type)
960          {
961              std::string type = getProxyTypeName(x.Type);
962              x.Remark = "[" + type + "] " + x.Remark;
963          }
964          processRemark(x.Remark, remark, remarks_list);
965          std::string &hostname = x.Hostname, &method = x.EncryptMethod, &password = x.Password, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &edge = x.Edge, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &plugin = x.Plugin, &pluginopts = x.PluginOption, &username = x.Username;
966          std::string port = std::to_string(x.Port);
967          bool &tlssecure = x.TLSSecure;
968          switch(x.Type)
969          {
970          case ProxyType::VMess:
971              scv = ext.skip_cert_verify;
972              scv.define(x.AllowInsecure);
973              if(method == "auto")
974                  method = "chacha20-ietf-poly1305";
975              proxyStr = remark + " = vmess, " + hostname + ", " + port + ", " + method + ", \"" + id + "\", group=" + x.Group;
976              if(tlssecure)
977              {
978                  proxyStr += ", over-tls=true, tls-host=" + host;
979                  if(!scv.is_undef())
980                      proxyStr += ", certificate=" + std::string(scv.get() ? "0" : "1");
981              }
982              if(transproto == "ws")
983              {
984                  proxyStr += ", obfs=ws, obfs-path=\"" + path + "\", obfs-header=\"Host: " + host;
985                  if(!edge.empty())
986                      proxyStr += "[Rr][Nn]Edge: " + edge;
987                  proxyStr += "\"";
988              }
989              if(ext.nodelist)
990                  proxyStr = "vmess:&bsol;&bsol;" + urlSafeBase64Encode(proxyStr);
991              break;
992          case ProxyType::ShadowsocksR:
993              if(ext.nodelist)
994              {
995                  proxyStr = "ssr:&bsol;&bsol;" + urlSafeBase64Encode(hostname + ":" + port + ":" + protocol + ":" + method + ":" + obfs + ":" + urlSafeBase64Encode(password) \
996                             + "/?group=" + urlSafeBase64Encode(x.Group) + "&remarks=" + urlSafeBase64Encode(remark) \
997                             + "&obfsparam=" + urlSafeBase64Encode(obfsparam) + "&protoparam=" + urlSafeBase64Encode(protoparam));
998              }
999              else
1000              {
1001                  proxyStr = remark + " = shadowsocksr, " + hostname + ", " + port + ", " + method + ", \"" + password + "\", group=" + x.Group + ", protocol=" + protocol + ", obfs=" + obfs;
1002                  if(!protoparam.empty())
1003                      proxyStr += ", protocol_param=" + protoparam;
1004                  if(!obfsparam.empty())
1005                      proxyStr += ", obfs_param=" + obfsparam;
1006              }
1007              break;
1008          case ProxyType::Shadowsocks:
1009              if(ext.nodelist)
1010              {
1011                  proxyStr = "ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port;
1012                  if(!plugin.empty() && !pluginopts.empty())
1013                  {
1014                      proxyStr += "/?plugin=" + urlEncode(plugin + ";" + pluginopts);
1015                  }
1016                  proxyStr += "&group=" + urlSafeBase64Encode(x.Group) + "#" + urlEncode(remark);
1017              }
1018              else
1019              {
1020                  proxyStr = remark + " = shadowsocks, " + hostname + ", " + port + ", " + method + ", \"" + password + "\", group=" + x.Group;
1021                  if(plugin == "obfs-local" && !pluginopts.empty())
1022                  {
1023                      proxyStr += ", " + replaceAllDistinct(pluginopts, ";", ", ");
1024                  }
1025              }
1026              break;
1027          case ProxyType::HTTP:
1028          case ProxyType::HTTPS:
1029              proxyStr = remark + " = http, upstream-proxy-address=" + hostname + ", upstream-proxy-port=" + port + ", group=" + x.Group;
1030              if(!username.empty() && !password.empty())
1031                  proxyStr += ", upstream-proxy-auth=true, upstream-proxy-username=" + username + ", upstream-proxy-password=" + password;
1032              else
1033                  proxyStr += ", upstream-proxy-auth=false";
1034              if(tlssecure)
1035              {
1036                  proxyStr += ", over-tls=true";
1037                  if(!host.empty())
1038                      proxyStr += ", tls-host=" + host;
1039                  if(!scv.is_undef())
1040                      proxyStr += ", certificate=" + std::string(scv.get() ? "0" : "1");
1041              }
1042              if(ext.nodelist)
1043                  proxyStr = "http:&bsol;&bsol;" + urlSafeBase64Encode(proxyStr);
1044              break;
1045          case ProxyType::SOCKS5:
1046              proxyStr = remark + " = socks, upstream-proxy-address=" + hostname + ", upstream-proxy-port=" + port + ", group=" + x.Group;
1047              if(!username.empty() && !password.empty())
1048                  proxyStr += ", upstream-proxy-auth=true, upstream-proxy-username=" + username + ", upstream-proxy-password=" + password;
1049              else
1050                  proxyStr += ", upstream-proxy-auth=false";
1051              if(tlssecure)
1052              {
1053                  proxyStr += ", over-tls=true";
1054                  if(!host.empty())
1055                      proxyStr += ", tls-host=" + host;
1056                  if(!scv.is_undef())
1057                      proxyStr += ", certificate=" + std::string(scv.get() ? "0" : "1");
1058              }
1059              if(ext.nodelist)
1060                  proxyStr = "socks:&bsol;&bsol;" + urlSafeBase64Encode(proxyStr);
1061              break;
1062          default:
1063              continue;
1064          }
1065          ini.Set("{NONAME}", proxyStr);
1066          remarks_list.emplace_back(std::move(remark));
1067          nodelist.emplace_back(x);
1068      }
1069      if(ext.nodelist)
1070          return;
1071      string_array filtered_nodelist;
1072      ini.SetCurrentSection("POLICY");
1073      ini.EraseSection();
1074      std::string singlegroup;
1075      std::string name, proxies;
1076      for(const ProxyGroupConfig &x : extra_proxy_group)
1077      {
1078          eraseElements(filtered_nodelist);
1079          switch(x.Type)
1080          {
1081          case ProxyGroupType::Select:
1082          case ProxyGroupType::Fallback:
1083              type = "static";
1084              break;
1085          case ProxyGroupType::URLTest:
1086              type = "auto";
1087              break;
1088          case ProxyGroupType::LoadBalance:
1089              type = "balance, round-robin";
1090              break;
1091          case ProxyGroupType::SSID:
1092              {
1093                  singlegroup = x.Name + " : wifi = " + x.Proxies[0];
1094                  std::string content, celluar, celluar_matcher = R"(^(.*?),?celluar\s?=\s?(.*?)(,.*)$)", rem_a, rem_b;
1095                  for(auto iter = x.Proxies.begin() + 1; iter != x.Proxies.end(); iter++)
1096                  {
1097                      if(regGetMatch(*iter, celluar_matcher, 4, 0, &rem_a, &celluar, &rem_b))
1098                      {
1099                          content += *iter + "\n";
1100                          continue;
1101                      }
1102                      content += rem_a + rem_b + "\n";
1103                  }
1104                  if(!celluar.empty())
1105                      singlegroup += ", celluar = " + celluar;
1106                  singlegroup += "\n" + replaceAllDistinct(trimOf(content, ','), ",", "\n");
1107                  ini.Set("{NONAME}", base64Encode(singlegroup)); 
1108              }
1109              continue;
1110          default:
1111              continue;
1112          }
1113          for(const auto &y : x.Proxies)
1114              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
1115          if(filtered_nodelist.empty())
1116              filtered_nodelist.emplace_back("direct");
1117          if(filtered_nodelist.size() < 2) 
1118              type = "static";
1119          proxies = join(filtered_nodelist, "\n");
1120          singlegroup = x.Name + " : " + type;
1121          if(type == "static")
1122              singlegroup += ", " + filtered_nodelist[0];
1123          singlegroup += "\n" + proxies + "\n";
1124          ini.Set("{NONAME}", base64Encode(singlegroup));
1125      }
1126      if(ext.enable_rule_generator)
1127          rulesetToSurge(ini, ruleset_content_array, -2, ext.overwrite_original_rules, std::string());
1128  }
1129  std::string proxyToQuanX(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1130  {
1131      INIReader ini;
1132      ini.store_any_line = true;
1133      ini.AddDirectSaveSection("general");
1134      ini.AddDirectSaveSection("dns");
1135      ini.AddDirectSaveSection("rewrite_remote");
1136      ini.AddDirectSaveSection("rewrite_local");
1137      ini.AddDirectSaveSection("task_local");
1138      ini.AddDirectSaveSection("mitm");
1139      ini.AddDirectSaveSection("server_remote");
1140      if(!ext.nodelist && ini.Parse(base_conf) != 0)
1141      {
1142          writeLog(0, "QuantumultX base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1143          return std::string();
1144      }
1145      proxyToQuanX(nodes, ini, ruleset_content_array, extra_proxy_group, ext);
1146      if(ext.nodelist)
1147      {
1148          string_array allnodes;
1149          std::string allLinks;
1150          ini.GetAll("server_local", "{NONAME}", allnodes);
1151          if(!allnodes.empty())
1152              allLinks = join(allnodes, "\n");
1153          return allLinks;
1154      }
1155      return ini.ToString();
1156  }
1157  void proxyToQuanX(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1158  {
1159      std::string type;
1160      std::string remark, hostname, port, method;
1161      std::string password, plugin, pluginopts;
1162      std::string id, transproto, host, path;
1163      std::string protocol, protoparam, obfs, obfsparam;
1164      std::string proxyStr;
1165      tribool udp, tfo, scv, tls13;
1166      std::vector<Proxy> nodelist;
1167      string_array remarks_list;
1168      ini.SetCurrentSection("server_local");
1169      ini.EraseSection();
1170      for(Proxy &x : nodes)
1171      {
1172          if(ext.append_proxy_type)
1173              x.Remark = "[" + type + "] " + x.Remark;
1174          processRemark(x.Remark, remark, remarks_list);
1175          std::string &hostname = x.Hostname, &method = x.EncryptMethod, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &password = x.Password, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam, &username = x.Username;
1176          std::string port = std::to_string(x.Port);
1177          bool &tlssecure = x.TLSSecure;
1178          udp = ext.udp;
1179          tfo = ext.tfo;
1180          scv = ext.skip_cert_verify;
1181          tls13 = ext.tls13;
1182          udp.define(x.UDP);
1183          tfo.define(x.TCPFastOpen);
1184          scv.define(x.AllowInsecure);
1185          tls13.define(x.TLS13);
1186          switch(x.Type)
1187          {
1188          case ProxyType::VMess:
1189              if(method == "auto")
1190                  method = "chacha20-ietf-poly1305";
1191              proxyStr = "vmess = " + hostname + ":" + port + ", method=" + method + ", password=" + id;
1192              if (x.AlterId != 0)
1193                  proxyStr += ", aead=false";
1194              if(tlssecure && !tls13.is_undef())
1195                  proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1196              if(transproto == "ws")
1197              {
1198                  if(tlssecure)
1199                      proxyStr += ", obfs=wss";
1200                  else
1201                      proxyStr += ", obfs=ws";
1202                  proxyStr += ", obfs-host=" + host + ", obfs-uri=" + path;
1203              }
1204              else if(tlssecure)
1205                  proxyStr += ", obfs=over-tls, obfs-host=" + host;
1206              break;
1207          case ProxyType::Shadowsocks:
1208              proxyStr = "shadowsocks = " + hostname + ":" + port + ", method=" + method + ", password=" + password;
1209              if(!plugin.empty())
1210              {
1211                  switch(hash_(plugin))
1212                  {
1213                      case "simple-obfs"_hash:
1214                      case "obfs-local"_hash:
1215                          if(!pluginopts.empty())
1216                              proxyStr += ", " + replaceAllDistinct(pluginopts, ";", ", ");
1217                          break;
1218                      case "v2ray-plugin"_hash:
1219                          pluginopts = replaceAllDistinct(pluginopts, ";", "&");
1220                          plugin = getUrlArg(pluginopts, "mode") == "websocket" ? "ws" : "";
1221                          host = getUrlArg(pluginopts, "host");
1222                          path = getUrlArg(pluginopts, "path");
1223                          tlssecure = pluginopts.find("tls") != pluginopts.npos;
1224                          if(tlssecure && plugin == "ws")
1225                          {
1226                              plugin += 's';
1227                              if(!tls13.is_undef())
1228                                  proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1229                          }
1230                          proxyStr += ", obfs=" + plugin;
1231                          if(!host.empty())
1232                              proxyStr += ", obfs-host=" + host;
1233                          if(!path.empty())
1234                              proxyStr += ", obfs-uri=" + path;
1235                          break;
1236                      default: continue;
1237                  }
1238              }
1239              break;
1240          case ProxyType::ShadowsocksR:
1241              proxyStr = "shadowsocks = " + hostname + ":" + port + ", method=" + method + ", password=" + password + ", ssr-protocol=" + protocol;
1242              if(!protoparam.empty())
1243                  proxyStr += ", ssr-protocol-param=" + protoparam;
1244              proxyStr += ", obfs=" + obfs;
1245              if(!obfsparam.empty())
1246                  proxyStr += ", obfs-host=" + obfsparam;
1247              break;
1248          case ProxyType::HTTP:
1249          case ProxyType::HTTPS:
1250              proxyStr = "http = " + hostname + ":" + port + ", username=" + (username.empty() ? "none" : username) + ", password=" + (password.empty() ? "none" : password);
1251              if(tlssecure)
1252              {
1253                  proxyStr += ", over-tls=true";
1254                  if(!tls13.is_undef())
1255                      proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1256              }
1257              else
1258              {
1259                  proxyStr += ", over-tls=false";
1260              }
1261              break;
1262          case ProxyType::Trojan:
1263              proxyStr = "trojan = " + hostname + ":" + port + ", password=" + password;
1264              if(tlssecure)
1265              {
1266                  proxyStr += ", over-tls=true, tls-host=" + host;
1267                  if(!tls13.is_undef())
1268                      proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1269              }
1270              else
1271              {
1272                  proxyStr += ", over-tls=false";
1273              }
1274              break;
1275          case ProxyType::SOCKS5:
1276              proxyStr = "socks5 = " + hostname + ":" + port;
1277              if(!username.empty() && !password.empty())
1278              {
1279                  proxyStr += ", username=" + username + ", password=" + password;
1280                  if(tlssecure)
1281                  {
1282                      proxyStr += ", over-tls=true, tls-host=" + host;
1283                      if(!tls13.is_undef())
1284                          proxyStr += ", tls13=" + std::string(tls13 ? "true" : "false");
1285                  }
1286                  else
1287                  {
1288                      proxyStr += ", over-tls=false";
1289                  }
1290              }
1291              break;
1292          default:
1293              continue;
1294          }
1295          if(!tfo.is_undef())
1296              proxyStr += ", fast-open=" + tfo.get_str();
1297          if(!udp.is_undef())
1298              proxyStr += ", udp-relay=" + udp.get_str();
1299          if(tlssecure && !scv.is_undef() && (x.Type != ProxyType::Shadowsocks && x.Type != ProxyType::ShadowsocksR))
1300              proxyStr += ", tls-verification=" + scv.reverse().get_str();
1301          proxyStr += ", tag=" + remark;
1302          ini.Set("{NONAME}", proxyStr);
1303          remarks_list.emplace_back(std::move(remark));
1304          nodelist.emplace_back(x);
1305      }
1306      if(ext.nodelist)
1307          return;
1308      string_multimap original_groups;
1309      ini.SetCurrentSection("policy");
1310      ini.GetItems(original_groups);
1311      ini.EraseSection();
1312      for(const ProxyGroupConfig &x : extra_proxy_group)
1313      {
1314          string_array filtered_nodelist;
1315          switch(x.Type)
1316          {
1317          case ProxyGroupType::Select:
1318              type = "static";
1319              break;
1320          case ProxyGroupType::URLTest:
1321              type = "url-latency-benchmark";
1322              break;
1323          case ProxyGroupType::Fallback:
1324              type = "available";
1325              break;
1326          case ProxyGroupType::LoadBalance:
1327              type = "round-robin";
1328              break;
1329          case ProxyGroupType::SSID:
1330              type = "ssid";
1331              for(auto iter = x.Proxies.begin(); iter != x.Proxies.end(); iter++)
1332                  filtered_nodelist.emplace_back(replaceAllDistinct(*iter, "=", ":"));
1333              break;
1334          default:
1335              continue;
1336          }
1337          if(x.Type != ProxyGroupType::SSID)
1338          {
1339              for(const auto &y : x.Proxies)
1340                  groupGenerate(y, nodelist, filtered_nodelist, true, ext);
1341              if(filtered_nodelist.empty())
1342                  filtered_nodelist.emplace_back("direct");
1343              if(filtered_nodelist.size() < 2) 
1344                  type = "static";
1345          }
1346          auto iter = std::find_if(original_groups.begin(), original_groups.end(), [&](const string_multimap::value_type &n)
1347          {
1348              std::string groupdata = n.second;
1349              std::string::size_type cpos = groupdata.find(",");
1350              if(cpos != groupdata.npos)
1351                  return trim(groupdata.substr(0, cpos)) == x.Name;
1352              else
1353                  return false;
1354          });
1355          if(iter != original_groups.end())
1356          {
1357              string_array vArray = split(iter->second, ",");
1358              if(vArray.size() > 1)
1359              {
1360                  if(trim(vArray[vArray.size() - 1]).find("img-url") == 0)
1361                      filtered_nodelist.emplace_back(trim(vArray[vArray.size() - 1]));
1362              }
1363          }
1364          std::string proxies = join(filtered_nodelist, ", ");
1365          std::string singlegroup = type + "=" + x.Name + ", " + proxies;
1366          ini.Set("{NONAME}", singlegroup);
1367      }
1368      if(ext.enable_rule_generator)
1369          rulesetToSurge(ini, ruleset_content_array, -1, ext.overwrite_original_rules, ext.managed_config_prefix);
1370  }
1371  std::string proxyToSSD(std::vector<Proxy> &nodes, std::string &group, std::string &userinfo, extra_settings &ext)
1372  {
1373      rapidjson::StringBuffer sb;
1374      rapidjson::Writer<rapidjson::StringBuffer> writer(sb);
1375      size_t index = 0;
1376      if(group.empty())
1377          group = "SSD";
1378      writer.StartObject();
1379      writer.Key("airport");
1380      writer.String(group.data());
1381      writer.Key("port");
1382      writer.Int(1);
1383      writer.Key("encryption");
1384      writer.String("aes-128-gcm");
1385      writer.Key("password");
1386      writer.String("password");
1387      if(!userinfo.empty())
1388      {
1389          std::string data = replaceAllDistinct(userinfo, "; ", "&");
1390          std::string upload = getUrlArg(data, "upload"), download = getUrlArg(data, "download"), total = getUrlArg(data, "total"), expiry = getUrlArg(data, "expire");
1391          double used = (to_number(upload, 0.0) + to_number(download, 0.0)) / std::pow(1024, 3) * 1.0, tot = to_number(total, 0.0) / std::pow(1024, 3) * 1.0;
1392          writer.Key("traffic_used");
1393          writer.Double(used);
1394          writer.Key("traffic_total");
1395          writer.Double(tot);
1396          if(!expiry.empty())
1397          {
1398              const time_t rawtime = to_int(expiry);
1399              char buffer[30];
1400              struct tm *dt = localtime(&rawtime);
1401              strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M", dt);
1402              writer.Key("expiry");
1403              writer.String(buffer);
1404          }
1405      }
1406      writer.Key("servers");
1407      writer.StartArray();
1408      for(Proxy &x : nodes)
1409      {
1410          std::string &hostname = x.Hostname, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &protocol = x.Protocol, &obfs = x.OBFS;
1411          switch(x.Type)
1412          {
1413          case ProxyType::Shadowsocks:
1414              if(plugin == "obfs-local")
1415                  plugin = "simple-obfs";
<span onclick='openModal()' class='match'>1416              writer.StartObject();
1417              writer.Key("server");
1418              writer.String(hostname.data());
1419              writer.Key("port");
1420              writer.Int(x.Port);
1421              writer.Key("encryption");
1422              writer.String(method.data());
1423              writer.Key("password");
1424              writer.String(password.data());
</span>1425              writer.Key("plugin");
1426              writer.String(plugin.data());
1427              writer.Key("plugin_options");
1428              writer.String(pluginopts.data());
1429              writer.Key("remarks");
1430              writer.String(x.Remark.data());
1431              writer.Key("id");
1432              writer.Int(index);
1433              writer.EndObject();
1434              break;
1435          case ProxyType::ShadowsocksR:
1436              if(std::count(ss_ciphers.begin(), ss_ciphers.end(), method) > 0 && protocol == "origin" && obfs == "plain")
1437              {
1438                  writer.StartObject();
1439                  writer.Key("server");
1440                  writer.String(hostname.data());
1441                  writer.Key("port");
1442                  writer.Int(x.Port);
1443                  writer.Key("encryption");
1444                  writer.String(method.data());
1445                  writer.Key("password");
1446                  writer.String(password.data());
1447                  writer.Key("remarks");
1448                  writer.String(x.Remark.data());
1449                  writer.Key("id");
1450                  writer.Int(index);
1451                  writer.EndObject();
1452                  break;
1453              }
1454              else
1455                  continue;
1456          default:
1457              continue;
1458          }
1459          index++;
1460      }
1461      writer.EndArray();
1462      writer.EndObject();
1463      return "ssd:&bsol;&bsol;" + base64Encode(sb.GetString());
1464  }
1465  std::string proxyToMellow(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1466  {
1467      INIReader ini;
1468      ini.store_any_line = true;
1469      if(ini.Parse(base_conf) != 0)
1470      {
1471          writeLog(0, "Mellow base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1472          return std::string();
1473      }
1474      proxyToMellow(nodes, ini, ruleset_content_array, extra_proxy_group, ext);
1475      return ini.ToString();
1476  }
1477  void proxyToMellow(std::vector<Proxy> &nodes, INIReader &ini, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1478  {
1479      std::string proxy;
1480      std::string type, remark, hostname, port, username, password, method;
1481      std::string plugin, pluginopts;
1482      std::string id, aid, transproto, faketype, host, path, quicsecure, quicsecret, tlssecure;
1483      std::string url;
1484      tribool tfo, scv;
1485      std::vector<Proxy> nodelist;
1486      string_array vArray, remarks_list, filtered_nodelist;
1487      ini.SetCurrentSection("Endpoint");
1488      for(Proxy &x : nodes)
1489      {
1490          if(ext.append_proxy_type)
1491          {
1492              std::string type = getProxyTypeName(x.Type);
1493              x.Remark = "[" + type + "] " + x.Remark;
1494          }
1495          processRemark(x.Remark, remark, remarks_list);
1496          std::string &hostname = x.Hostname;
1497          port = std::to_string(x.Port);
1498          tfo = ext.tfo;
1499          scv = ext.skip_cert_verify;
1500          tfo.define(x.TCPFastOpen);
1501          scv.define(x.AllowInsecure);
1502          switch(x.Type)
1503          {
1504          case ProxyType::Shadowsocks:
1505              if(!x.Plugin.empty())
1506                  continue;
1507              proxy = remark + ", ss, ss:&bsol;&bsol;" + urlSafeBase64Encode(method + ":" + password) + "@" + hostname + ":" + port;
1508              break;
1509          case ProxyType::VMess:
1510              proxy = remark + ", vmess1, vmess1:&bsol;&bsol;" + id + "@" + hostname + ":" + port;
1511              if(!path.empty())
1512                  proxy += path;
1513              proxy += "?network=" + transproto;
1514              switch(hash_(transproto))
1515              {
1516              case "ws"_hash:
1517                  proxy += "&ws.host=" + urlEncode(host);
1518                  break;
1519              case "http"_hash:
1520                  if(!host.empty())
1521                      proxy += "&http.host=" + urlEncode(host);
1522                  break;
1523              case "quic"_hash:
1524                  if(!quicsecure.empty())
1525                      proxy += "&quic.security=" + quicsecure + "&quic.key=" + quicsecret;
1526                  break;
1527              case "kcp"_hash:
1528                  break;
1529              case "tcp"_hash:
1530                  break;
1531              }
1532              proxy += "&tls=" + tlssecure;
1533              if(tlssecure == "true")
1534              {
1535                  if(!host.empty())
1536                      proxy += "&tls.servername=" + urlEncode(host);
1537              }
1538              if(!scv.is_undef())
1539                  proxy += "&tls.allowinsecure=" + scv.get_str();
1540              if(!tfo.is_undef())
1541                  proxy += "&sockopt.tcpfastopen=" + tfo.get_str();
1542              break;
1543          case ProxyType::SOCKS5:
1544              proxy = remark + ", builtin, socks, address=" + hostname + ", port=" + port + ", user=" + username + ", pass=" + password;
1545              break;
1546          case ProxyType::HTTP:
1547              proxy = remark + ", builtin, http, address=" + hostname + ", port=" + port + ", user=" + username + ", pass=" + password;
1548              break;
1549          default:
1550              continue;
1551          }
1552          ini.Set("{NONAME}", proxy);
1553          remarks_list.emplace_back(std::move(remark));
1554          nodelist.emplace_back(x);
1555      }
1556      ini.SetCurrentSection("EndpointGroup");
1557      for(const ProxyGroupConfig &x : extra_proxy_group)
1558      {
1559          eraseElements(filtered_nodelist);
1560          url.clear();
1561          proxy.clear();
1562          switch(x.Type)
1563          {
1564          case ProxyGroupType::Select:
1565          case ProxyGroupType::URLTest:
1566          case ProxyGroupType::Fallback:
1567          case ProxyGroupType::LoadBalance:
1568              break;
1569          default:
1570              continue;
1571          }
1572          for(const auto &y : x.Proxies)
1573              groupGenerate(y, nodelist, filtered_nodelist, false, ext);
1574          if(filtered_nodelist.empty())
1575          {
1576              if(remarks_list.empty())
1577                  filtered_nodelist.emplace_back("DIRECT");
1578              else
1579                  filtered_nodelist = remarks_list;
1580          }
1581          proxy = x.Name + ", ";
1582          proxy += join(filtered_nodelist, ":");
1583          proxy += ", latency, interval=300, timeout=6"; 
1584          ini.Set("{NONAME}", proxy); 
1585      }
1586      if(ext.enable_rule_generator)
1587          rulesetToSurge(ini, ruleset_content_array, 0, ext.overwrite_original_rules, std::string());
1588  }
1589  std::string proxyToLoon(std::vector<Proxy> &nodes, const std::string &base_conf, std::vector<RulesetContent> &ruleset_content_array, const ProxyGroupConfigs &extra_proxy_group, extra_settings &ext)
1590  {
1591      rapidjson::Document json;
1592      INIReader ini;
1593      std::string proxy;
1594      std::string output_nodelist;
1595      tribool scv;
1596      std::vector<Proxy> nodelist;
1597      string_array vArray, remarks_list, filtered_nodelist;
1598      ini.store_any_line = true;
1599      if(ini.Parse(base_conf) != INIREADER_EXCEPTION_NONE && !ext.nodelist)
1600      {
1601          writeLog(0, "Loon base loader failed with error: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1602          return std::string();
1603      }
1604      ini.SetCurrentSection("Proxy");
1605      ini.EraseSection();
1606      for(Proxy &x : nodes)
1607      {
1608          if(ext.append_proxy_type)
1609          {
1610              std::string type = getProxyTypeName(x.Type);
1611              x.Remark = "[" + type + "] " + x.Remark;
1612          }
1613          std::string remark = x.Remark;
1614          processRemark(x.Remark, remark, remarks_list);
1615          std::string &hostname = x.Hostname, &username = x.Username, &password = x.Password, &method = x.EncryptMethod, &plugin = x.Plugin, &pluginopts = x.PluginOption, &id = x.UserId, &transproto = x.TransferProtocol, &host = x.Host, &path = x.Path, &protocol = x.Protocol, &protoparam = x.ProtocolParam, &obfs = x.OBFS, &obfsparam = x.OBFSParam;
1616          std::string port = std::to_string(x.Port), aid = std::to_string(x.AlterId);
1617          bool &tlssecure = x.TLSSecure;
1618          tribool scv = ext.skip_cert_verify;
1619          scv.define(x.AllowInsecure);
1620          proxy.clear();
1621          switch(x.Type)
1622          {
1623          case ProxyType::Shadowsocks:
1624              proxy = "Shadowsocks," + hostname + "," + port + "," + method + ",\"" + password + "\"";
1625              if(plugin == "simple-obfs" || plugin == "obfs-local")
1626              {
1627                  if(!pluginopts.empty())
1628                      proxy += "," + replaceAllDistinct(replaceAllDistinct(pluginopts, ";obfs-host=", ","), "obfs=", "");
1629              }
1630              else if(!plugin.empty())
1631                  continue;
1632              break;
1633          case ProxyType::VMess:
1634              if(method == "auto")
1635                  method = "chacha20-ietf-poly1305";
1636              proxy = "vmess," + hostname + "," + port + "," + method + ",\"" + id + "\",over-tls:" + (tlssecure ? "true" : "false");
1637              if(tlssecure)
1638                  proxy += ",tls-name:" + host;
1639              switch(hash_(transproto))
1640              {
1641              case "tcp"_hash:
1642                  proxy += ",transport:tcp";
1643                  break;
1644              case "ws"_hash:
1645                  proxy += ",transport:ws,path:" + path + ",host:" + host;
1646                  break;
1647              default:
1648                  continue;
1649              }
1650              if(!scv.is_undef())
1651                  proxy += ",skip-cert-verify:" + std::string(scv.get() ? "1" : "0");
1652              break;
1653          case ProxyType::ShadowsocksR:
1654              proxy = "ShadowsocksR," + hostname + "," + port + "," + method + ",\"" + password + "\"," + protocol + ",{" + protoparam + "}," + obfs + ",{" + obfsparam + "}";
1655              break;
1656          case ProxyType::HTTP:
1657              proxy = "http," + hostname + "," + port + "," + username + "," + password;
1658              break;
1659          case ProxyType::Trojan:
1660              proxy = "trojan," + hostname + "," + port + "," + password;
1661              if(!host.empty())
1662                  proxy += ",tls-name:" + host;
1663              if(!scv.is_undef())
1664                  proxy += ",skip-cert-verify:" + std::string(scv.get() ? "1" : "0");
1665              break;
1666          default:
1667              continue;
1668          }
1669          if(ext.nodelist)
1670              output_nodelist += remark + " = " + proxy + "\n";
1671          else
1672          {
1673              ini.Set("{NONAME}", remark + " = " + proxy);
1674              nodelist.emplace_back(x);
1675              remarks_list.emplace_back(std::move(remark));
1676          }
1677      }
1678      if(ext.nodelist)
1679          return output_nodelist;
1680      ini.SetCurrentSection("Proxy Group");
1681      ini.EraseSection();
1682      for(const ProxyGroupConfig &x : extra_proxy_group)
1683      {
1684          eraseElements(filtered_nodelist);
1685          proxy.clear();
1686          switch(x.Type)
1687          {
1688          case ProxyGroupType::Select:
1689          case ProxyGroupType::URLTest:
1690          case ProxyGroupType::Fallback:
1691              break;
1692          case ProxyGroupType::SSID:
1693              if(x.Proxies.size() < 2)
1694                  continue;
1695              proxy = x.TypeStr() + ",default=" + x.Proxies[0] + ",";
1696              proxy += join(x.Proxies.begin() + 1, x.Proxies.end(), ",");
1697              ini.Set("{NONAME}", x.Name + " = " + proxy); 
1698              continue;
1699          default:
1700              continue;
1701          }
1702          for(const auto &y : x.Proxies)
1703              groupGenerate(y, nodelist, filtered_nodelist, true, ext);
1704          if(filtered_nodelist.empty())
1705              filtered_nodelist.emplace_back("DIRECT");
1706          proxy = x.TypeStr() + ",";
1707          proxy += join(filtered_nodelist, ",");
1708          if(x.Type == ProxyGroupType::URLTest || x.Type == ProxyGroupType::Fallback)
1709              proxy += ",url=" + x.Url + ",interval=" + std::to_string(x.Interval);
1710          ini.Set("{NONAME}", x.Name + " = " + proxy); 
1711      }
1712      if(ext.enable_rule_generator)
1713          rulesetToSurge(ini, ruleset_content_array, -4, ext.overwrite_original_rules, ext.managed_config_prefix);
1714      return ini.ToString();
1715  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_convolution_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-subexport.cpp</div>
                </div>
                <div class="column column_space"><pre><code>531    sep_blob_bottom_vec.push_back(this->blob_bottom_2_);
532    sep_blob_top_vec.push_back(this->blob_top_2_);
533    convolution_param->clear_kernel_size();
534    convolution_param->clear_stride();
535    convolution_param->set_kernel_h(3);
536    convolution_param->set_kernel_w(1);
537    convolution_param->set_stride_h(2);
538    convolution_param->set_stride_w(1);
539    convolution_param->set_num_output(1);
540    convolution_param->set_bias_term(false);
541    layer.reset(new MKLConvolutionLayer<Dtype>(layer_param));
</pre></code></div>
                <div class="column column_space"><pre><code>1416              writer.StartObject();
1417              writer.Key("server");
1418              writer.String(hostname.data());
1419              writer.Key("port");
1420              writer.Int(x.Port);
1421              writer.Key("encryption");
1422              writer.String(method.data());
1423              writer.Key("password");
1424              writer.String(password.data());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    