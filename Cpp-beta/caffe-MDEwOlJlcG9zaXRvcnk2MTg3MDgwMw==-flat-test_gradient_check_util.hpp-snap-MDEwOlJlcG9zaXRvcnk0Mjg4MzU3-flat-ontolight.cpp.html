
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.143329658213892%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_gradient_check_util.hpp</h3>
            <pre><code>1  #ifndef CAFFE_TEST_GRADIENT_CHECK_UTIL_H_
2  #define CAFFE_TEST_GRADIENT_CHECK_UTIL_H_
3  #include <glog/logging.h>
4  #include <gtest/gtest.h>
5  #include <algorithm>
6  #include <cmath>
7  #include <vector>
8  #include "caffe/layer.hpp"
9  #include "caffe/net.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  class GradientChecker {
13   public:
14    GradientChecker(const Dtype stepsize, const Dtype threshold,
15        const unsigned int seed = 1701, const Dtype kink = 0.,
16        const Dtype kink_range = -1)
17        : stepsize_(stepsize), threshold_(threshold), seed_(seed),
18          kink_(kink), kink_range_(kink_range) {}
19    void CheckGradient(Layer<Dtype>* layer, const vector<Blob<Dtype>*>& bottom,
20        const vector<Blob<Dtype>*>& top, int check_bottom = -1) {
21        layer->SetUp(bottom, top);
22        CheckGradientSingle(layer, bottom, top, check_bottom, -1, -1);
23    }
24    void CheckGradientExhaustive(Layer<Dtype>* layer,
25        const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
26        int check_bottom = -1);
27    void CheckGradientEltwise(Layer<Dtype>* layer,
28        const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top);
29    void CheckGradientSingle(Layer<Dtype>* layer,
30        const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
31        int check_bottom, int top_id, int top_data_id, bool element_wise = false);
32    void CheckGradientNet(const Net<Dtype>& net,
33        const vector<Blob<Dtype>*>& input);
34   protected:
35    Dtype GetObjAndGradient(const Layer<Dtype>& layer,
36        const vector<Blob<Dtype>*>& top, int top_id = -1, int top_data_id = -1);
37    Dtype stepsize_;
38    Dtype threshold_;
39    unsigned int seed_;
40    Dtype kink_;
41    Dtype kink_range_;
42  };
43  template <typename Dtype>
44  void GradientChecker<Dtype>::CheckGradientSingle(Layer<Dtype>* layer,
45      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
46      int check_bottom, int top_id, int top_data_id, bool element_wise) {
47    if (element_wise) {
48      CHECK_EQ(0, layer->blobs().size());
49      CHECK_LE(0, top_id);
50      CHECK_LE(0, top_data_id);
51      const int top_count = top[top_id]->count();
52      for (int blob_id = 0; blob_id < bottom.size(); ++blob_id) {
53        CHECK_EQ(top_count, bottom[blob_id]->count());
54      }
55    }
56    vector<Blob<Dtype>*> blobs_to_check;
57    vector<bool> propagate_down(bottom.size(), check_bottom == -1);
58    for (int i = 0; i < layer->blobs().size(); ++i) {
59      Blob<Dtype>* blob = layer->blobs()[i].get();
60      caffe_set(blob->count(), static_cast<Dtype>(0), blob->mutable_cpu_diff());
61      blobs_to_check.push_back(blob);
62    }
63    if (check_bottom == -1) {
64      for (int i = 0; i < bottom.size(); ++i) {
65        blobs_to_check.push_back(bottom[i]);
66      }
67    } else if (check_bottom >= 0) {
68      CHECK_LT(check_bottom, bottom.size());
69      blobs_to_check.push_back(bottom[check_bottom]);
70      propagate_down[check_bottom] = true;
71    }
72    CHECK_GT(blobs_to_check.size(), 0) << "No blobs to check.";
73    Caffe::set_random_seed(seed_);
74    layer->Forward(bottom, top);
75    GetObjAndGradient(*layer, top, top_id, top_data_id);
76    layer->Backward(top, propagate_down, bottom);
77    vector<shared_ptr<Blob<Dtype> > >
78        computed_gradient_blobs(blobs_to_check.size());
79    for (int blob_id = 0; blob_id < blobs_to_check.size(); ++blob_id) {
80      Blob<Dtype>* current_blob = blobs_to_check[blob_id];
81      computed_gradient_blobs[blob_id].reset(new Blob<Dtype>());
82      computed_gradient_blobs[blob_id]->ReshapeLike(*current_blob);
83      const int count = blobs_to_check[blob_id]->count();
84      const Dtype* diff = blobs_to_check[blob_id]->cpu_diff();
85      Dtype* computed_gradients =
86          computed_gradient_blobs[blob_id]->mutable_cpu_data();
87      caffe_copy(count, diff, computed_gradients);
88    }
89    for (int blob_id = 0; blob_id < blobs_to_check.size(); ++blob_id) {
90      Blob<Dtype>* current_blob = blobs_to_check[blob_id];
91      const Dtype* computed_gradients =
92          computed_gradient_blobs[blob_id]->cpu_data();
93      for (int feat_id = 0; feat_id < current_blob->count(); ++feat_id) {
94        Dtype estimated_gradient = 0;
95        Dtype positive_objective = 0;
96        Dtype negative_objective = 0;
97        if (!element_wise || (feat_id == top_data_id)) {
98          current_blob->mutable_cpu_data()[feat_id] += stepsize_;
99          Caffe::set_random_seed(seed_);
100          layer->Forward(bottom, top);
101          positive_objective =
102              GetObjAndGradient(*layer, top, top_id, top_data_id);
103          current_blob->mutable_cpu_data()[feat_id] -= stepsize_ * 2;
104          Caffe::set_random_seed(seed_);
105          layer->Forward(bottom, top);
106          negative_objective =
107              GetObjAndGradient(*layer, top, top_id, top_data_id);
108          current_blob->mutable_cpu_data()[feat_id] += stepsize_;
109          estimated_gradient = (positive_objective - negative_objective) /
110              stepsize_ / 2.;
111        }
112        Dtype computed_gradient = computed_gradients[feat_id];
<span onclick='openModal()' class='match'>113        Dtype feature = current_blob->cpu_data()[feat_id];
114        if (kink_ - kink_range_ > fabs(feature)
115            || fabs(feature) > kink_ + kink_range_) {
116          Dtype scale = std::max<Dtype>(
117              std::max(fabs(computed_gradient), fabs(estimated_gradient)),
</span>118              Dtype(1.));
119          EXPECT_NEAR(computed_gradient, estimated_gradient, threshold_ * scale)
120            << "debug: (top_id, top_data_id, blob_id, feat_id)="
121            << top_id << "," << top_data_id << "," << blob_id << "," << feat_id
122            << "; feat = " << feature
123            << "; objective+ = " << positive_objective
124            << "; objective- = " << negative_objective;
125        }
126      }
127    }
128  }
129  template <typename Dtype>
130  void GradientChecker<Dtype>::CheckGradientExhaustive(Layer<Dtype>* layer,
131      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
132      int check_bottom) {
133    layer->SetUp(bottom, top);
134    CHECK_GT(top.size(), 0) << "Exhaustive mode requires at least one top blob.";
135    for (int i = 0; i < top.size(); ++i) {
136      for (int j = 0; j < top[i]->count(); ++j) {
137        CheckGradientSingle(layer, bottom, top, check_bottom, i, j);
138      }
139    }
140  }
141  template <typename Dtype>
142  void GradientChecker<Dtype>::CheckGradientEltwise(Layer<Dtype>* layer,
143      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
144    layer->SetUp(bottom, top);
145    CHECK_GT(top.size(), 0) << "Eltwise mode requires at least one top blob.";
146    const int check_bottom = -1;
147    const bool element_wise = true;
148    for (int i = 0; i < top.size(); ++i) {
149      for (int j = 0; j < top[i]->count(); ++j) {
150        CheckGradientSingle(layer, bottom, top, check_bottom, i, j, element_wise);
151      }
152    }
153  }
154  template <typename Dtype>
155  void GradientChecker<Dtype>::CheckGradientNet(
156      const Net<Dtype>& net, const vector<Blob<Dtype>*>& input) {
157    const vector<shared_ptr<Layer<Dtype> > >& layers = net.layers();
158    vector<vector<Blob<Dtype>*> >& bottom_vecs = net.bottom_vecs();
159    vector<vector<Blob<Dtype>*> >& top_vecs = net.top_vecs();
160    for (int i = 0; i < layers.size(); ++i) {
161      net.Forward(input);
162      LOG(ERROR) << "Checking gradient for " << layers[i]->layer_param().name();
163      CheckGradientExhaustive(*(layers[i].get()), bottom_vecs[i], top_vecs[i]);
164    }
165  }
166  template <typename Dtype>
167  Dtype GradientChecker<Dtype>::GetObjAndGradient(const Layer<Dtype>& layer,
168      const vector<Blob<Dtype>*>& top, int top_id, int top_data_id) {
169    Dtype loss = 0;
170    if (top_id < 0) {
171      for (int i = 0; i < top.size(); ++i) {
172        Blob<Dtype>* top_blob = top[i];
173        const Dtype* top_blob_data = top_blob->cpu_data();
174        Dtype* top_blob_diff = top_blob->mutable_cpu_diff();
175        int count = top_blob->count();
176        for (int j = 0; j < count; ++j) {
177          loss += top_blob_data[j] * top_blob_data[j];
178        }
179        caffe_copy(top_blob->count(), top_blob_data, top_blob_diff);
180      }
181      loss /= 2.;
182    } else {
183      for (int i = 0; i < top.size(); ++i) {
184        Blob<Dtype>* top_blob = top[i];
185        Dtype* top_blob_diff = top_blob->mutable_cpu_diff();
186        caffe_set(top_blob->count(), Dtype(0), top_blob_diff);
187      }
188      const Dtype loss_weight = 2;
189      loss = top[top_id]->cpu_data()[top_data_id] * loss_weight;
190      top[top_id]->mutable_cpu_diff()[top_data_id] = loss_weight;
191    }
192    return loss;
193  }
194  }  
195  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ontolight.cpp</h3>
            <pre><code>1  void TLwLangBs::SaveTxt(FILE* fOut){
2    fprintf(fOut, "===LwLangBs-Begin====================\n");
3    for (int LangN=0; LangN<GetLangs(); LangN++){
4      int LangId=GetLangId(LangN);
5      fprintf(fOut, "N:%d Id:%d Nm:'%s' Desc:'%s'\n",
6       LangN, LangId, GetLangNm(LangId).CStr(), GetLangDesc(LangId).CStr());
7    }
8    fprintf(fOut, "===LwLangBs-End======================\n");
9  }
10  void TLwTermType::SaveTxt(FILE* fOut){
11    fprintf(fOut, "Id:%d Nm:'%s' LangId:%d Desc:'%s'\n",
12      GetTermTypeId(), GetTermTypeNm().CStr(), GetLangId(), GetDescStr().CStr());
13  }
14  void TLwTerm::SaveTxt(FILE* fOut){
15    fprintf(fOut, "Id:%d Nm:'%s' LangId:%d TermTypeId:%d Desc:'%s'\n",
16     GetTermId(), GetTermNm().CStr(), GetLangId(), GetTermTypeId(), GetDescStr().CStr());
17  }
18  int TLwTermTypeBs::AddTermType(const PLwTermType& LwTermType){
19    IAssert(!IsTermTypeId(LwTermType->GetTermTypeId()));
20    IdToTermTypeVH.AddDat(LwTermType->GetTermTypeId()).Add(LwTermType);
21    TStrIntPr TermTypeNmLangIdPr=
22     TStrIntPr(LwTermType->GetTermTypeNm(), LwTermType->GetLangId());
23    TermTypeNmLangIdToIdH.AddDat(TermTypeNmLangIdPr, LwTermType->GetTermTypeId());
24    return LwTermType->GetTermTypeId();
25  }
26  void TLwTermTypeBs::SaveTxt(FILE* fOut){
27    fprintf(fOut, "===LwTermTypeBs-Begin================\n");
28    for (int TermTypeN=0; TermTypeN<GetTermTypes(); TermTypeN++){
29      fprintf(fOut, "N:%d ", TermTypeN);
30      GetTermType(GetTermTypeId(TermTypeN))->SaveTxt(fOut);
31    }
32    fprintf(fOut, "===LwTermTypeBs-End==================\n");
33  }
34  void TLwTermBs::AddTerm(const PLwTerm& Term){
35    IAssert(Onto->GetLangBs()->IsLangId(Term->GetLangId()));
36    if (Term->GetTermId()>MxTermId){MxTermId=Term->GetTermId();}
37    IdToTermVH.AddDat(Term->GetTermId()).Add(Term);
38    TermNmLangIdToToTermIdH.AddDat(
39     TStrIntPr(Term->GetTermNm(), Term->GetLangId()), Term->GetTermId());
40  }
41  int TLwTermBs::AddTermGetTermId(const PLwTerm& Term){
42    IAssert(Term->GetTermId()==-1);
43    Term->PutTermId(MxTermId+1);
44    AddTerm(Term);
45    return Term->GetTermId();
46  }
47  PLwTerm TLwTermBs::GetTerm(const int& TermId){
<span onclick='openModal()' class='match'>48    TLwTermV TermV=IdToTermVH.GetDat(TermId);
49    if (Onto->GetLangBs()->IsLangNm("EN")){
50      int EnLangId=Onto->GetLangBs()->GetLangId("EN");
</span>51      for (int TermN=0; TermN<TermV.Len(); TermN++){
52        if (TermV[TermN]->GetLangId()==EnLangId){return TermV[TermN];}
53      }
54    }
55    return TermV[0];
56  }
57  void TLwTermBs::SaveTxt(FILE* fOut){
58    fprintf(fOut, "===LwTermBs-Begin====================\n");
59    for (int TermN=0; TermN<GetTerms(); TermN++){
60      TLwTermV TermV; GetTermV(GetTermId(TermN), TermV);
61      for (int SubTermN=0; SubTermN<TermV.Len(); SubTermN++){
62        if (TermV.Len()==1){fprintf(fOut, "N:%d ", TermN);}
63        else {fprintf(fOut, "N:%d/%d ", TermN, SubTermN);}
64        TermV[SubTermN]->SaveTxt(fOut);
65      }
66      Onto->GetLinkBs()->SaveTxt(fOut, GetTermId(TermN), "   ");
67    }
68    fprintf(fOut, "===LwTermBs-End======================\n");
69  }
70  void TLwLinkType::SaveTxt(FILE* fOut){
71    fprintf(fOut, "Id:%d Nm:'%s' LangId:%d SDesc:'%s' Desc:'%s' RevLinkTypeId:%d ParentLinkTypeId:%d\n",
72     GetLinkTypeId(), GetLinkTypeNm().CStr(), GetLangId(),
73     GetSDescStr().CStr(), GetDescStr().CStr(),
74     GetReverseLinkTypeId(), GetParentLinkTypeId());
75  }
76  void TLwLinkTypeBs::AddLinkType(const PLwLinkType& LwLinkType){
77    IdToLinkTypeVH.AddDat(LwLinkType->GetLinkTypeId()).Add(LwLinkType);
78    TStrIntPr LinkTypeNmLangIdPr(LwLinkType->GetLinkTypeNm(), LwLinkType->GetLangId());
79    IAssert(!LinkTypeNmLangIdToIdH.IsKey(LinkTypeNmLangIdPr));
80    LinkTypeNmLangIdToIdH.AddDat(LinkTypeNmLangIdPr, LwLinkType->GetLinkTypeId());
81  }
82  void TLwLinkTypeBs::SaveTxt(FILE* fOut){
83    fprintf(fOut, "===LwLinkTypeBs-Begin================\n");
84    for (int LinkTypeN=0; LinkTypeN<GetLinkTypes(); LinkTypeN++){
85      fprintf(fOut, "N:%d ", LinkTypeN);
86      GetLinkType(GetLinkTypeId(LinkTypeN))->SaveTxt(fOut);
87    }
88    fprintf(fOut, "===LwLinkTypeBs-End==================\n");
89  }
90  int TLwLinkBs::GetLinks() const {
91    int Links=0;
92    int TermIds=FromTermIdToLinkTypeIdTermIdPrVH.Len();
93    for (int TermIdN=0; TermIdN<TermIds; TermIdN++){
94      Links+=FromTermIdToLinkTypeIdTermIdPrVH[TermIdN].Len();}
95    return Links;
96  }
97  void TLwLinkBs::AddLink(const int TermId1, int LinkTypeId, int TermId2){
98    IAssert(Onto->GetTermBs()->IsTermId(TermId1));
99    IAssert(Onto->GetLinkTypeBs()->IsLinkTypeId(LinkTypeId));
100    IAssert(Onto->GetTermBs()->IsTermId(TermId2));
101    FromTermIdToLinkTypeIdTermIdPrVH.AddDat(TermId1).Add(TIntPr(LinkTypeId, TermId2));
102    IntoTermIdToLinkTypeIdTermIdPrVH.AddDat(TermId2).Add(TIntPr(LinkTypeId, TermId1));
103  }
104  int TLwLinkBs::GetFromLinks(const int SrcTermId) const {
105    if (FromTermIdToLinkTypeIdTermIdPrVH.IsKey(SrcTermId)){
106      return FromTermIdToLinkTypeIdTermIdPrVH.GetDat(SrcTermId).Len();
107    } else {return 0;}
108  }
109  void TLwLinkBs::GetFromLink(
110   const int SrcTermId, const int& LinkN, int& LinkTypeId, int& DstTermId){
111    TIntPr& LinkTypeIdDstTermIdPr=
112     FromTermIdToLinkTypeIdTermIdPrVH.GetDat(SrcTermId)[LinkN];
113    LinkTypeId=LinkTypeIdDstTermIdPr.Val1;
114    DstTermId=LinkTypeIdDstTermIdPr.Val2;
115  }
116  int TLwLinkBs::GetIntoLinks(const int DstTermId) const {
117    if (IntoTermIdToLinkTypeIdTermIdPrVH.IsKey(DstTermId)){
118      return IntoTermIdToLinkTypeIdTermIdPrVH.GetDat(DstTermId).Len();
119    } else {return 0;}
120  }
121  void TLwLinkBs::GetIntoLink(
122   const int DstTermId, const int& LinkN, int& LinkTypeId, int& SrcTermId){
123    TIntPr& LinkTypeIdSrcTermIdPr=
124     IntoTermIdToLinkTypeIdTermIdPrVH.GetDat(DstTermId)[LinkN];
125    LinkTypeId=LinkTypeIdSrcTermIdPr.Val1;
126    SrcTermId=LinkTypeIdSrcTermIdPr.Val2;
127  }
128  void TLwLinkBs::SaveTxt(FILE* fOut, const int& TermId, const TStr& IndentStr){
129    for (int LinkN=0; LinkN<GetFromLinks(TermId); LinkN++){
130      int LinkTypeId; int DstTermId;
131      GetFromLink(TermId, LinkN, LinkTypeId, DstTermId);
132      TStr LinkTypeNm=Onto->GetLinkTypeBs()->GetLinkType(LinkTypeId)->GetLinkTypeNm();
133      TStr DstTermNm=Onto->GetTermBs()->GetTerm(DstTermId)->GetTermNm();
134      fprintf(fOut, "%s-->%s--> DstTermId:%d DstTermNm:'%s'\n", IndentStr.CStr(),
135       LinkTypeNm.CStr(), DstTermId, DstTermNm.CStr());
136    }
137    for (int LinkN=0; LinkN<GetIntoLinks(TermId); LinkN++){
138      int LinkTypeId; int SrcTermId;
139      GetIntoLink(TermId, LinkN, LinkTypeId, SrcTermId);
140      TStr LinkTypeNm=Onto->GetLinkTypeBs()->GetLinkType(LinkTypeId)->GetLinkTypeNm();
141      TStr SrcTermNm=Onto->GetTermBs()->GetTerm(SrcTermId)->GetTermNm();
142      fprintf(fOut, "%s<--%s<-- SrcTermId:%d SrcTermNm:'%s'\n", IndentStr.CStr(),
143       LinkTypeNm.CStr(), SrcTermId, SrcTermNm.CStr());
144    }
145  }
146  void TLwOnto::SaveTxt(const TStr& FNm){
147    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
148    fprintf(fOut, "===LwOnto-Begin======================\n");
149    GetLangBs()->SaveTxt(fOut);
150    fprintf(fOut, "\n");
151    GetTermTypeBs()->SaveTxt(fOut);
152    fprintf(fOut, "\n");
153    GetLinkTypeBs()->SaveTxt(fOut);
154    fprintf(fOut, "\n");
155    GetTermBs()->SaveTxt(fOut);
156    fprintf(fOut, "===LwOnto-End========================\n");
157  }
158  PLwOnto TLwOnto::LoadAgroVoc(const TStr& FPath){
159    TStr NrFPath=TStr::GetNrFPath(FPath);
160    PLwOnto LwOnto=TLwOnto::New();
161    {TStr AvLangFNm=NrFPath+"language.txt";
162    printf("Loading '%s' ...", AvLangFNm.CStr());
163    PSs AvLangSs=TSs::LoadTxt(ssfCommaSep, AvLangFNm);
164    int AvLangSs_LangNmFldN=AvLangSs->GetFldX("languagecode");
165    int AvLangSs_LangDescFldN=AvLangSs->GetFldX("name");
166    for (int Y=1; Y<AvLangSs->GetYLen(); Y++){
167      TStr LangNm=AvLangSs->GetVal(AvLangSs_LangNmFldN, Y);
168      TStr LangDesc=AvLangSs->GetVal(AvLangSs_LangDescFldN, Y);
169      LwOnto->GetLangBs()->AddLang(LangNm, LangDesc);
170    }
171    printf(" Done. (%d)\n", AvLangSs->GetYLen()-1);}
172    {TStr AvTermFNm=NrFPath+"agrovocterm.txt";
173    printf("Loading '%s' ...", AvTermFNm.CStr());
174    PSs AvTermSs=TSs::LoadTxt(ssfCommaSep, AvTermFNm);
175    int AvTermSs_TermIdFldN=AvTermSs->GetFldX("termcode");
176    int AvTermSs_LangNmFldN=AvTermSs->GetFldX("languagecode");
177    int AvTermSs_TermSpellFldN=AvTermSs->GetFldX("termspell");
178    for (int Y=1; Y<AvTermSs->GetYLen(); Y++){
179      int TermId=AvTermSs->GetVal(AvTermSs_TermIdFldN, Y).GetInt();
180      TStr LangNm=AvTermSs->GetVal(AvTermSs_LangNmFldN, Y);
181      TStr TermNm=AvTermSs->GetVal(AvTermSs_TermSpellFldN, Y);
182      int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
183      PLwTerm Term=TLwTerm::New(TermId, TermNm, LangId);
184      LwOnto->GetTermBs()->AddTerm(Term);
185    }
186    printf(" Done. (%d)\n", AvTermSs->GetYLen()-1);}
187    {TStr AvLinkTypeFNm=NrFPath+"linktype.txt";
188    printf("Loading '%s' ...", AvLinkTypeFNm.CStr());
189    PSs AvLinkTypeSs=TSs::LoadTxt(ssfCommaSep, AvLinkTypeFNm);
190    int AvLinkTypeSs_LinkTypeIdFldN=AvLinkTypeSs->GetFldX("linktypeid");
191    int AvLinkTypeSs_LangIdFldN=AvLinkTypeSs->GetFldX("languagecode");
192    int AvLinkTypeSs_LinkSDescFldN=AvLinkTypeSs->GetFldX("linkdesc");
193    int AvLinkTypeSs_LinkNmFldN=AvLinkTypeSs->GetFldX("linkabr");
194    int AvLinkTypeSs_LinkDescFldN=AvLinkTypeSs->GetFldX("linkdescription");
195    int AvLinkTypeSs_ReverseLinkIdFldN=AvLinkTypeSs->GetFldX("rlinkcode");
196    int AvLinkTypeSs_ParentLinkTypeIdFldN=AvLinkTypeSs->GetFldX("parentlinktypeid");
197    for (int Y=1; Y<AvLinkTypeSs->GetYLen(); Y++){
198      int LinkTypeId=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkTypeIdFldN, Y).GetInt();
199      TStr LinkTypeNm=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkNmFldN, Y);
200      TStr LangNm=AvLinkTypeSs->GetVal(AvLinkTypeSs_LangIdFldN, Y);
201      TStr SDescStr=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkSDescFldN, Y);
202      TStr DescStr=AvLinkTypeSs->GetVal(AvLinkTypeSs_LinkDescFldN, Y);
203      int ReverseLinkTypeId=AvLinkTypeSs->GetVal(AvLinkTypeSs_ReverseLinkIdFldN, Y).GetInt(-1);
204      int ParentLinkTypeId=AvLinkTypeSs->GetVal(AvLinkTypeSs_ParentLinkTypeIdFldN, Y).GetInt(-1);
205      int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
206      PLwLinkType LwLinkType=TLwLinkType::New();
207      LwLinkType->PutLinkTypeId(LinkTypeId);
208      LwLinkType->PutLinkTypeNm(LinkTypeNm);
209      LwLinkType->PutLangId(LangId);
210      LwLinkType->PutSDescStr(SDescStr);
211      LwLinkType->PutDescStr(DescStr);
212      LwLinkType->PutReverseLinkTypeId(ReverseLinkTypeId);
213      LwLinkType->PutParentLinkTypeId(ParentLinkTypeId);
214      LwOnto->GetLinkTypeBs()->AddLinkType(LwLinkType);
215    }
216    printf(" Done. (%d)\n", AvLinkTypeSs->GetYLen()-1);}
217    {TStr AvTermLinkFNm=NrFPath+"termlink.txt";
218    printf("Loading '%s' ...", AvTermLinkFNm.CStr());
219    PSs AvTermLinkSs=TSs::LoadTxt(ssfCommaSep, AvTermLinkFNm);
220    int AvTermLinkSs_TermId1FldN=AvTermLinkSs->GetFldX("termcode1");
221    int AvTermLinkSs_TermId2FldN=AvTermLinkSs->GetFldX("termcode2");
222    int AvTermLinkSs_LinkTypeIdFldN=AvTermLinkSs->GetFldX("linktypeid");
223    for (int Y=1; Y<AvTermLinkSs->GetYLen(); Y++){
224      int TermId1=AvTermLinkSs->GetVal(AvTermLinkSs_TermId1FldN, Y).GetInt();
225      int TermId2=AvTermLinkSs->GetVal(AvTermLinkSs_TermId2FldN, Y).GetInt();
226      int LinkTypeId=AvTermLinkSs->GetVal(AvTermLinkSs_LinkTypeIdFldN, Y).GetInt();
227      if (!LwOnto->GetTermBs()->IsTermId(TermId1)){printf("#"); continue;}
228      if (!LwOnto->GetTermBs()->IsTermId(TermId2)){printf("*"); continue;}
229      LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
230    }
231    printf(" Done. (%d)\n", AvTermLinkSs->GetYLen()-1);}
232    return LwOnto;
233  }
234  PLwOnto TLwOnto::LoadEuroVoc(const TStr& FPath){
235    TStr NrFPath=TStr::GetNrFPath(FPath);
236    PLwOnto LwOnto=TLwOnto::New();
237    TStr EvTermFNm=NrFPath+"listMultiLg_All.txt";
238    printf("Loading '%s' ...\n", EvTermFNm.CStr());
239    PSs EvTermSs=TSs::LoadTxt(ssfTabSep, EvTermFNm);
240    int EvTermSs_TermIdFldN=EvTermSs->GetFldX("ID"); IAssert(EvTermSs_TermIdFldN==0);
241    int XLen=EvTermSs->GetXLen(EvTermSs_TermIdFldN);
242    for (int X=1; X<XLen; X++){
243      TStr LangNm=EvTermSs->GetVal(X, 0); 
244      LwOnto->GetLangBs()->AddLang(LangNm, LangNm); 
245    }
246    int EnLangId=LwOnto->GetLangBs()->GetLangId("EN");
247    PLwTermType D_TermType=TLwTermType::New(0, "Descriptor", EnLangId);
248    PLwTermType ND_TermType=TLwTermType::New(1, "Non-descriptor", EnLangId);
249    LwOnto->GetTermTypeBs()->AddTermType(D_TermType);
250    LwOnto->GetTermTypeBs()->AddTermType(ND_TermType);
251    for (int Y=1; Y<EvTermSs->GetYLen(); Y++){
252      printf("%d/%d\r", Y, EvTermSs->GetYLen());
253      int TermId=EvTermSs->GetVal(EvTermSs_TermIdFldN, Y).GetInt();
254      for (int X=1; X<XLen; X++){
255        TStr LangNm=EvTermSs->GetVal(X, 0);
256        TStr TermNm=EvTermSs->GetVal(X, Y);
257        int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
258        PLwTerm Term=TLwTerm::New(TermId, TermNm, LangId, D_TermType->GetTermTypeId());
259        LwOnto->GetTermBs()->AddTerm(Term);
260      }
261    }
262    printf("\nDone. (%d)\n", EvTermSs->GetYLen()-1);
263    {PLwLinkType BT_LinkType=TLwLinkType::New(0, "BT", EnLangId, "Broader-Term");
264    PLwLinkType NT_LinkType=TLwLinkType::New(1, "NT", EnLangId, "Narrower-Term");
265    PLwLinkType MT_LinkType=TLwLinkType::New(2, "MT", EnLangId, "Micro-Theory");
266    PLwLinkType RT_LinkType=TLwLinkType::New(3, "RT", EnLangId, "Related-Term");
267    PLwLinkType UF_LinkType=TLwLinkType::New(4, "UF", EnLangId, "Used-For");
268    LwOnto->GetLinkTypeBs()->AddLinkType(BT_LinkType);
269    LwOnto->GetLinkTypeBs()->AddLinkType(NT_LinkType);
270    LwOnto->GetLinkTypeBs()->AddLinkType(MT_LinkType);
271    LwOnto->GetLinkTypeBs()->AddLinkType(RT_LinkType);
272    LwOnto->GetLinkTypeBs()->AddLinkType(UF_LinkType);}
273    {TStr EvLinkFNm=NrFPath+"eurovoc.txt";
274    printf("Loading '%s' ...", EvLinkFNm.CStr());
275    PSs EvLinkSs=TSs::LoadTxt(ssfTabSep, EvLinkFNm);
276    int EvLinkSs_TermId1FldN=EvLinkSs->GetFldX("term");
277    int EvLinkSs_LinkTypeNmFldN=EvLinkSs->GetFldX("link");
278    int EvLinkSs_TermId2FldN=EvLinkSs->GetFldX("subterm");
279    int EvLinkSs_TermNmFldN=EvLinkSs->GetFldX("name");
280    int EnLangId=LwOnto->GetLangBs()->GetLangId("EN");
281    for (int Y=1; Y<EvLinkSs->GetYLen(); Y++){
282      int TermId1=EvLinkSs->GetVal(EvLinkSs_TermId1FldN, Y).GetInt();
283      TStr LinkTypeNm=EvLinkSs->GetVal(EvLinkSs_LinkTypeNmFldN, Y);
284      int TermId2=EvLinkSs->GetVal(EvLinkSs_TermId2FldN, Y).GetInt();
285      TStr TermNm=EvLinkSs->GetVal(EvLinkSs_TermNmFldN, Y);
286      if (LinkTypeNm=="UF"){
287        IAssert(TermId2==-1);
288        PLwTerm Term=TLwTerm::New(-1, TermNm, EnLangId, ND_TermType->GetTermTypeId());
289        TermId2=LwOnto->GetTermBs()->AddTermGetTermId(Term);
290        int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(LinkTypeNm, EnLangId);
291        LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
292      } else {
293        if (LinkTypeNm=="NT1"){LinkTypeNm="NT";}
294        if (LinkTypeNm=="BT1"){LinkTypeNm="BT";}
295        if ((LinkTypeNm=="BT")||(LinkTypeNm=="NT")||(LinkTypeNm=="RT")){
296          int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(LinkTypeNm, EnLangId);
297          LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
298        }
299      }
300    }
301    printf(" Done. (%d)\n", EvLinkSs->GetYLen()-1);}
302    return LwOnto;
303  }
304  PLwOnto TLwOnto::LoadAsfaVoc(const TStr& FPath){
305    TStr NrFPath=TStr::GetNrFPath(FPath);
306    PLwOnto LwOnto=TLwOnto::New();
307    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
308    {PLwTermType D_TermType=TLwTermType::New(0, "Descriptor", EnLangId);
309    PLwTermType ND_TermType=TLwTermType::New(1, "Non-descriptor", EnLangId);
310    LwOnto->GetTermTypeBs()->AddTermType(D_TermType);
311    LwOnto->GetTermTypeBs()->AddTermType(ND_TermType);}
312    {PLwLinkType BT_LinkType=TLwLinkType::New(0, "BT", EnLangId, "Broader-Term");
313    PLwLinkType NT_LinkType=TLwLinkType::New(1, "NT", EnLangId, "Narrower-Term");
314    PLwLinkType RT_LinkType=TLwLinkType::New(2, "RT", EnLangId, "Related-Term");
315    PLwLinkType UF_LinkType=TLwLinkType::New(3, "UF", EnLangId, "Used-For");
316    PLwLinkType USE_LinkType=TLwLinkType::New(4, "USE", EnLangId, "Used-By");
317    LwOnto->GetLinkTypeBs()->AddLinkType(BT_LinkType);
318    LwOnto->GetLinkTypeBs()->AddLinkType(NT_LinkType);
319    LwOnto->GetLinkTypeBs()->AddLinkType(RT_LinkType);
320    LwOnto->GetLinkTypeBs()->AddLinkType(UF_LinkType);
321    LwOnto->GetLinkTypeBs()->AddLinkType(USE_LinkType);}
322    TStr AsfaOntoFNm=NrFPath+"asfa_xml_20060522.xml";
323    printf("Loading '%s' ...", AsfaOntoFNm.CStr());
324    PXmlDoc AsfaXmlDoc=TXmlDoc::LoadTxt(AsfaOntoFNm);
325    IAssert(AsfaXmlDoc->IsOk());
326    TXmlTokV ConceptXmlTokV;
327    AsfaXmlDoc->GetTagTokV("THESAURUS|CONCEPT", ConceptXmlTokV);
328    printf(" Done.\n");
329    {printf("Creating terms ...");
330    for (int ConceptN=0; ConceptN<ConceptXmlTokV.Len(); ConceptN++){
331      PXmlTok ConceptXmlTok=ConceptXmlTokV[ConceptN];
332      TStr TermNm;
333      if (ConceptXmlTok->IsSubTag("NON-DESCRIPTOR")){
334        TermNm=ConceptXmlTok->GetTagTokStr("NON-DESCRIPTOR");}
335      else if (ConceptXmlTok->IsSubTag("DESCRIPTOR")){
336        TermNm=ConceptXmlTok->GetTagTokStr("DESCRIPTOR");}
337      TStr TermTypeNm=ConceptXmlTok->GetTagTokStr("TYP");
338      int TermTypeId=LwOnto->GetTermTypeBs()->GetTermTypeId(TermTypeNm, EnLangId);
339      TStr DescStr;
340      if (ConceptXmlTok->IsSubTag("SN")){
341        DescStr=ConceptXmlTok->GetTagTokStr("SN");
342        DescStr.ChangeChAll('\r', ' '); DescStr.ChangeChAll('\n', ' ');
343        DescStr.ChangeStrAll("  ", " "); DescStr.ToTrunc();
344      }
345      PLwTerm Term=TLwTerm::New(-1, TermNm, EnLangId, TermTypeId, DescStr);
346      LwOnto->GetTermBs()->AddTermGetTermId(Term);
347    }
348    printf(" Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
349    {printf("Creating links ...");
350    for (int ConceptN=0; ConceptN<ConceptXmlTokV.Len(); ConceptN++){
351      PXmlTok ConceptXmlTok=ConceptXmlTokV[ConceptN];
352      TStr TermNm1;
353      if (ConceptXmlTok->IsSubTag("NON-DESCRIPTOR")){
354        TermNm1=ConceptXmlTok->GetTagTokStr("NON-DESCRIPTOR");}
355      else if (ConceptXmlTok->IsSubTag("DESCRIPTOR")){
356        TermNm1=ConceptXmlTok->GetTagTokStr("DESCRIPTOR");}
357      int TermId1=LwOnto->GetTermBs()->GetTermId(TermNm1, EnLangId);
358      for (int SubTokN=0; SubTokN<ConceptXmlTok->GetSubToks(); SubTokN++){
359        PXmlTok SubTok=ConceptXmlTok->GetSubTok(SubTokN);
360        if (SubTok->IsTag()){
361          TStr LinkTypeNm=SubTok->GetTagNm();
362          if (LwOnto->GetLinkTypeBs()->IsLinkType(LinkTypeNm, EnLangId)){
363            TStr TermNm2=ConceptXmlTok->GetTagTokStr(LinkTypeNm);
364            int TermId2=LwOnto->GetTermBs()->GetTermId(TermNm2, EnLangId);
365            int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(LinkTypeNm, EnLangId);
366            LwOnto->GetLinkBs()->AddLink(TermId1, LinkTypeId, TermId2);
367          }
368        }
369      }
370    }
371    printf(" Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
372    return LwOnto;
373  }
374  PLwOnto TLwOnto::LoadDMozVoc(const TStr& DMozBinFBase, const TStr& FPath){
375    PDMozBs DMozBs=TDMozBs::LoadBin(DMozBinFBase, FPath);
376    int Cats=DMozBs->GetCats();
377    PLwOnto LwOnto=TLwOnto::New();
378    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
379    PLwTermType Cat_TermType=TLwTermType::New(0, "Category", EnLangId);
380    LwOnto->GetTermTypeBs()->AddTermType(Cat_TermType);
381    PLwLinkType NT_LinkType=TLwLinkType::New(0, "NT", EnLangId, "Narrow");
382    PLwLinkType RT_LinkType=TLwLinkType::New(1, "RT", EnLangId, "Related");
383    PLwLinkType SL_LinkType=TLwLinkType::New(2, "SL", EnLangId, "Symbolic");
384    LwOnto->GetLinkTypeBs()->AddLinkType(NT_LinkType);
385    LwOnto->GetLinkTypeBs()->AddLinkType(RT_LinkType);
386    LwOnto->GetLinkTypeBs()->AddLinkType(SL_LinkType);
387    {printf("Creating terms ...\n");
388    for (int CatId=0; CatId<Cats; CatId++){
389      if (CatId%1000==0){printf("%d/%d\r", CatId, Cats);}
390      TStr TermNm=DMozBs->GetCatNm(CatId);
391      PLwTerm Term=TLwTerm::New(CatId, TermNm, EnLangId, Cat_TermType->GetTermTypeId());
392      LwOnto->GetTermBs()->AddTerm(Term);
393    }
394    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
395    {printf("Creating links ...\n"); 
396    for (int CatId=0; CatId<Cats; CatId++){
397      TStr CatNm=DMozBs->GetCatNm(CatId);
398      if (CatId%1000==0){printf("%d/%d\r", CatId, Cats);}
399      TUIntV SubCatTypeIdPrV; DMozBs->GetSubCatTypeIdPrV(CatId, SubCatTypeIdPrV);
400      for (int SubCatN=0; SubCatN<SubCatTypeIdPrV.Len(); SubCatN++){
401        int SubCatId; TDMozSubCatType SubCatType;
402        TDMozBs::GetSubCatTypeCatId(SubCatTypeIdPrV[SubCatN], SubCatType, SubCatId);
403        TStr SubCatNm=DMozBs->GetCatNm(SubCatId);
404        int LinkTypeId=-1;
405        switch (SubCatType){
406          case dmsctNarrow: LinkTypeId=NT_LinkType->GetLinkTypeId(); break;
407          case dmsctRelated: LinkTypeId=RT_LinkType->GetLinkTypeId(); break;
408          case dmsctSymbolic: LinkTypeId=SL_LinkType->GetLinkTypeId(); break;
409          default: LinkTypeId=-1;
410        }
411        if (LinkTypeId!=-1){
412          LwOnto->GetLinkBs()->AddLink(CatId, LinkTypeId, SubCatId);
413        }
414      }
415    }
416    printf(" Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
417    return LwOnto;
418  }
419  PLwOnto TLwOnto::LoadVoc(const TStr& FNm) {
420    PLwOnto LwOnto = TLwOnto::New();
421    int EnLangId = LwOnto->GetLangBs()->AddLang("EN", "English");
422    PLwTermType TermType = TLwTermType::New(0, "Term", EnLangId);
423    LwOnto->GetTermTypeBs()->AddTermType(TermType);
424    {printf("Creating terms ...\n");
425    TStr VocFileStr = TStr::LoadTxt(FNm); 
426    VocFileStr.DelChAll('\r');
427    TStrV TermNmV; VocFileStr.SplitOnAllCh('\n', TermNmV);
428    const int Terms = TermNmV.Len();
429    for (int TermId = 0; TermId<Terms; TermId++){
430      if (TermId%1000==0){printf("%d/%d\r", TermId, Terms);}
431      TStr TermNm = TermNmV[TermId];
432      PLwTerm Term=TLwTerm::New(TermId, TermNm, EnLangId, TermType->GetTermTypeId());
433      LwOnto->GetTermBs()->AddTerm(Term);
434    }
435    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
436    return LwOnto;
437  }
438  void TLwOntoGround::SaveTxt(const TStr& FNm){
439    PLwTermBs TermBs=LwOnto->GetTermBs();
440    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
441    fprintf(fOut, "===LwOnto-Begin======================\n");
442    for (int TermN=0; TermN<TermBs->GetTerms(); TermN++){
443      int TermId=TermBs->GetTermId(TermN);
444      TStr TermNm=TermBs->GetTerm(TermId)->GetTermNm();
445      fprintf(fOut, "TermId:%d TermNm:'%s'", TermId, TermNm.CStr());
446      if (TermIdToConceptSpVH.IsKey(TermId)){
447        PBowSpV ConceptSpV=TermIdToConceptSpVH.GetDat(TermId);
448        TStr ConceptSpVStr=ConceptSpV->GetStr(BowDocBs, 15, 0.66);
449        fprintf(fOut, " ConceptSpV:%s", ConceptSpVStr.CStr());
450      }
451      fprintf(fOut, "\n");
452    }
453  }
454  PLwOntoGround TLwOntoGround::GetOntoGround(
455   const PLwOnto& LwOnto, const PBowDocBs& BowDocBs,
456   const TStr& LangNm, const bool& DocCatIsTermIdP,
457   const double& CutWordWgtSumPrc){
458    printf("Generating Ontology-Classifier...\n");
459    PLwTermBs TermBs=LwOnto->GetTermBs();
460    int Terms=TermBs->GetTerms();
461    PLwLinkBs LinkBs=LwOnto->GetLinkBs();
462    PLwLinkTypeBs LinkTypeBs=LwOnto->GetLinkTypeBs();
463    int LangId=LwOnto->GetLangBs()->GetLangId(LangNm);
464    int Docs=BowDocBs->GetDocs();
465    printf("  Creating BowDocWgtBs ...");
466    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
467    PBowSim BowSim=TBowSim::New(bstCos);
468    printf(" Done.\n");
469    printf("  Collecting documents per ontology-term ...\n");
470    TIntIntVH TermIdToDIdVH; int PosCats=0; int NegCats=0;
471    for (int DId=0; DId<Docs; DId++){
472      printf("    Docs:%d/%d Pos:%d Neg:%d\r", 1+DId, Docs, PosCats, NegCats);
473      for (int DocCIdN=0; DocCIdN<BowDocBs->GetDocCIds(DId); DocCIdN++){
474        int CId=BowDocBs->GetDocCId(DId, DocCIdN);
475        TStr CatNm=BowDocBs->GetCatNm(CId);
476        if (DocCatIsTermIdP){
477          int TermId=CatNm.GetInt();
478          if (TermBs->IsTermId(TermId)){
479            TermIdToDIdVH.AddDat(TermId).Add(DId); PosCats++;
480          } else {NegCats++;}
481        } else {
482          if (TermBs->IsTermId(CatNm, LangId)){
483            int TermId=TermBs->GetTermId(CatNm, LangId);
484            TermIdToDIdVH.AddDat(TermId).Add(DId); PosCats++;
485          } else {NegCats++;}
486        }
487      }
488    }
489    printf("    Docs:%d/%d Pos:%d Neg:%d\n", Docs, Docs, PosCats, NegCats);
490    printf("  Done.\n");
491    printf("  Creating sub-terms & up-terms vectors ...");
492    TIntIntVH Const_TermIdToSubTermIdVH;
493    TIntIntVH TermIdToSubTermIdVH;
494    TIntIntVH TermIdToUpTermIdVH;
495    for (int TermN=0; TermN<Terms; TermN++){
496      int TermId=TermBs->GetTermId(TermN);
497      for (int LinkN=0; LinkN<LinkBs->GetFromLinks(TermId); LinkN++){
498        int LinkTypeId; int DstTermId;
499        LinkBs->GetFromLink(TermId, LinkN, LinkTypeId, DstTermId);
500        TStr LinkTypeNm=LinkTypeBs->GetLinkType(LinkTypeId)->GetLinkTypeNm();
501        if (LinkTypeNm=="NT"){
502          Const_TermIdToSubTermIdVH.AddDat(TermId).Add(DstTermId);
503          TermIdToSubTermIdVH.AddDat(TermId).Add(DstTermId);
504          TermIdToUpTermIdVH.AddDat(DstTermId).Add(TermId);
505        }
506      }
507    }
508    printf("   Done.\n");
509    printf("  Creating centroids ...\n");
510    THash<TInt, PBowSpV> TermIdToConceptSpVH;
511    TIntIntVH TermIdToSubTermDIdVH;
512    TIntH ProcTermIdH;
513    int PrevActiveTerms=-1;
514    forever{
515      int ActiveTerms=0;
516      for (int TermN=0; TermN<Terms; TermN++){
517        int TermId=TermBs->GetTermId(TermN);
518        if ((TermIdToSubTermIdVH.IsKey(TermId))&&
519         (TermIdToSubTermIdVH.GetDat(TermId).Len()>0)){
520          ActiveTerms++;
521        }
522      }
523      printf("    Active-Terms:%d\n", ActiveTerms);
524      if (ActiveTerms==PrevActiveTerms){break;}
525      PrevActiveTerms=ActiveTerms;
526      for (int TermN=0; TermN<Terms; TermN++){
527        int TermId=TermBs->GetTermId(TermN);
528        if (ProcTermIdH.IsKey(TermId)){continue;}
529        if ((!TermIdToSubTermIdVH.IsKey(TermId))||
530         (TermIdToSubTermIdVH.GetDat(TermId).Len()==0)){
531          printf("    %d/%d\r", 1+TermN, Terms);
532          ProcTermIdH.AddKey(TermId);
533          TIntV TermDIdV;
534          if (TermIdToDIdVH.IsKey(TermId)){
535            TermDIdV.AddV(TermIdToDIdVH.GetDat(TermId));}
536          if (TermIdToSubTermDIdVH.IsKey(TermId)){
537            TermDIdV.AddV(TermIdToSubTermDIdVH.GetDat(TermId));}
538          if (TermDIdV.Len()>0){
539            PBowSpV ConceptSpV=
540             TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, TermDIdV, CutWordWgtSumPrc);
541            TermIdToConceptSpVH.AddDat(TermId, ConceptSpV);
542          }
543          if (TermIdToUpTermIdVH.IsKey(TermId)){
544            TIntV& UpTermIdV=TermIdToUpTermIdVH.GetDat(TermId);
545            for (int UpTermIdN=0; UpTermIdN<UpTermIdV.Len(); UpTermIdN++){
546              int UpTermId=UpTermIdV[UpTermIdN];
547              TermIdToSubTermIdVH.GetDat(UpTermId).DelIfIn(TermId);
548              if (TermDIdV.Len()>0){
549                TermIdToSubTermDIdVH.AddDat(UpTermId).AddV(TermDIdV);}
550            }
551          }
552        }
553      }
554    }
555    printf("  Done.\n");
556    PLwOntoGround OntoGround=
557     TLwOntoGround::New(LwOnto, BowDocBs, BowDocWgtBs, TermIdToConceptSpVH);
558    printf("Done.\n");
559    return OntoGround;
560  }
561  PLwOntoGround TLwOntoGround::GetOntoGroundNN(const PLwOnto& LwOnto, 
562          const PBowDocBs& BowDocBs, const TStr& LangNm) {
563      printf("Generating Ontology-Classifier...\n");
564      PLwTermBs TermBs=LwOnto->GetTermBs();
565      const int Terms = TermBs->GetTerms();
566      const int LangId = LwOnto->GetLangBs()->GetLangId(LangNm);
567      const int Words = BowDocBs->GetWords();
568      printf("  Creating BowDocWgtBs ...");
569      PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
570      PBowSim BowSim=TBowSim::New(bstCos);
571      printf(" Done.\n");
572      printf("  Collecting documents per ontology-term ... ");
573      THash<TInt, PBowSpV> TermIdToConceptSpVH;
574      for (int TermN = 0; TermN < Terms; TermN++){
575          int TermId = TermBs->GetTermId(TermN);
576          PLwTerm Term = TermBs->GetTerm(TermId);
577          if (Term->GetLangId() != LangId) { continue; }
578          PBowSpV TermSpV = BowDocBs->GetSpVFromHtmlStr(
579              Term->GetTermNm(), BowDocWgtBs);
580          TFltIntKdV SimDIdKdV;
581          BowDocWgtBs->GetSimDIdV(TermSpV, BowSim, SimDIdKdV, false);
582          TFltV TermV(Words); TermV.PutAll(0.0);
583          for (int SimDIdKdN = 0; SimDIdKdN < SimDIdKdV.Len(); SimDIdKdN++) {
584              PBowSpV DocSpV = BowDocWgtBs->GetSpV(SimDIdKdV[SimDIdKdN].Dat);
585              const double Sim = SimDIdKdV[SimDIdKdN].Key;
586              TBowLinAlg::AddVec(Sim, DocSpV, TermV);
587          }
588          TermIdToConceptSpVH.AddDat(TermId, TBowSpV::New(-1, TermV, TFlt::Eps));
589      }
590      printf("  Done.\n");
591      PLwOntoGround OntoGround = TLwOntoGround::New(LwOnto, 
592          BowDocBs, BowDocWgtBs, TermIdToConceptSpVH);
593      printf("Done.\n");
594      return OntoGround;
595  }
596  void TLwOntoGround::ClassifySpV(
597   const PBowSpV& QueryBowSpV, TSimTermIdPrV& SimTermIdPrV) const {
598    PBowSim BowSim=TBowSim::New(bstCos);
599    SimTermIdPrV.Clr();
600    for (int TermN=0; TermN<TermIdToConceptSpVH.Len(); TermN++){
601      int TermId=TermIdToConceptSpVH.GetKey(TermN);
602      PBowSpV ConceptSpV=TermIdToConceptSpVH[TermN];
603      double Sim=BowSim->GetSim(QueryBowSpV, ConceptSpV);
604      TStr TermNm = GetLwOnto()->GetTermBs()->GetTerm(TermId)->GetTermNm();
605      if (Sim > 0.0) { SimTermIdPrV.Add(TFltIntPr(Sim, TermId)); } 
606    }
607    SimTermIdPrV.Sort(false);
608  }
609  void TLwOntoGround::ClassifyStr(
610   const TStr& QueryStr, TSimTermIdPrV& SimTermIdPrV) const {
611    PBowDocBs BowDocBs=GetBowDocBs();
612    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs();
613    PBowSpV QueryBowSpV=
614     BowDocBs->GetSpVFromHtmlStr(QueryStr, BowDocWgtBs);
615    ClassifySpV(QueryBowSpV, SimTermIdPrV);
616  }
617  void TLwOntoGround::ClassifyHtmlFNm(
618   const TStr& QueryHtmlFNm, TSimTermIdPrV& SimTermIdPrV) const {
619    PBowDocBs BowDocBs=GetBowDocBs();
620    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs();
621    PBowSpV QueryBowSpV=
622     BowDocBs->GetSpVFromHtmlFile(QueryHtmlFNm, BowDocWgtBs);
623    ClassifySpV(QueryBowSpV, SimTermIdPrV);
624  }
625  void TLwOntoGround::SaveCfySetTxt(
626   FILE* fTxt, TSimTermIdPrV& SimTermIdPrV, const int& MxRank){
627    int Terms=(MxRank==-1) ? SimTermIdPrV.Len() : MxRank;
628    for (int TermN=0; TermN<Terms; TermN++){
629      double Sim=SimTermIdPrV[TermN].Val1;
630      int TermId=SimTermIdPrV[TermN].Val2;
631      TStr TermNm=LwOnto->GetTermBs()->GetTerm(TermId)->GetTermNm();
632      fprintf(fTxt, "%2d. %.3f %s\n", 1+TermN, Sim, TermNm.CStr());
633    }
634  }
635  void TLwOntoGround::SaveCfySetXml(
636   FILE* fXml, TSimTermIdPrV& SimTermIdPrV, const int& MxRank){
637    fprintf(fXml, "<OntoClassify>\n");
638    int Terms=(MxRank==-1) ? SimTermIdPrV.Len() : MxRank;
639    for (int TermN=0; TermN<Terms; TermN++){
640      double Sim=SimTermIdPrV[TermN].Val1;
641      int TermId=SimTermIdPrV[TermN].Val2;
642      TStr TermNm=LwOnto->GetTermBs()->GetTerm(TermId)->GetTermNm();
643      fprintf(fXml, "<Term Rank=\"%d\" Sim=\"%.3f\">%s</Term>\n",
644       1+TermN, Sim, TermNm.CStr());
645    }
646    fprintf(fXml, "</OntoClassify>\n");
647  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_gradient_check_util.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ontolight.cpp</div>
                </div>
                <div class="column column_space"><pre><code>113        Dtype feature = current_blob->cpu_data()[feat_id];
114        if (kink_ - kink_range_ > fabs(feature)
115            || fabs(feature) > kink_ + kink_range_) {
116          Dtype scale = std::max<Dtype>(
117              std::max(fabs(computed_gradient), fabs(estimated_gradient)),
</pre></code></div>
                <div class="column column_space"><pre><code>48    TLwTermV TermV=IdToTermVH.GetDat(TermId);
49    if (Onto->GetLangBs()->IsLangNm("EN")){
50      int EnLangId=Onto->GetLangBs()->GetLangId("EN");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    