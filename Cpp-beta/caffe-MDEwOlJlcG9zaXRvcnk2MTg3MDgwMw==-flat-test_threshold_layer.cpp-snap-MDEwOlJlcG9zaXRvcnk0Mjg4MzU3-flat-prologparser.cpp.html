
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.222648752399232%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_threshold_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "gtest/gtest.h"
3  #include "caffe/blob.hpp"
4  #include "caffe/common.hpp"
5  #include "caffe/filler.hpp"
6  #include "caffe/layers/threshold_layer.hpp"
7  #include "caffe/test/test_caffe_main.hpp"
8  namespace caffe {
9  template <typename TypeParam>
10  class ThresholdLayerTest : public MultiDeviceTest<TypeParam> {
11    typedef typename TypeParam::Dtype Dtype;
12   protected:
13    ThresholdLayerTest()
14        : blob_bottom_(new Blob<Dtype>(2, 3, 6, 5)),
15          blob_top_(new Blob<Dtype>()) {
16      Caffe::set_random_seed(1701);
17      FillerParameter filler_param;
18      GaussianFiller<Dtype> filler(filler_param);
19      filler.Fill(this->blob_bottom_);
20      blob_bottom_vec_.push_back(blob_bottom_);
21      blob_top_vec_.push_back(blob_top_);
22    }
23    virtual ~ThresholdLayerTest() { delete blob_bottom_; delete blob_top_; }
24    Blob<Dtype>* const blob_bottom_;
25    Blob<Dtype>* const blob_top_;
26    vector<Blob<Dtype>*> blob_bottom_vec_;
27    vector<Blob<Dtype>*> blob_top_vec_;
28  };
29  TYPED_TEST_CASE(ThresholdLayerTest, TestDtypesAndDevices);
30  TYPED_TEST(ThresholdLayerTest, TestSetup) {
31    typedef typename TypeParam::Dtype Dtype;
32    LayerParameter layer_param;
33    ThresholdLayer<Dtype> layer(layer_param);
<span onclick='openModal()' class='match'>34    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
35    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
36    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
37    EXPECT_EQ(this->blob_top_->height(), this->blob_bottom_->height());
38    EXPECT_EQ(this->blob_top_->width(), this->blob_bottom_->width());
39  }
40  TYPED_TEST(ThresholdLayerTest, Test) {
</span>41    typedef typename TypeParam::Dtype Dtype;
42    LayerParameter layer_param;
43    ThresholdLayer<Dtype> layer(layer_param);
44    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
45    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
46    const Dtype* bottom_data = this->blob_bottom_->cpu_data();
47    const Dtype* top_data = this->blob_top_->cpu_data();
48    const Dtype threshold_ = layer_param.threshold_param().threshold();
49    for (int i = 0; i < this->blob_bottom_->count(); ++i) {
50      EXPECT_GE(top_data[i], 0.);
51      EXPECT_LE(top_data[i], 1.);
52      if (top_data[i] == 0) {
53        EXPECT_LE(bottom_data[i], threshold_);
54      }
55      if (top_data[i] == 1) {
56        EXPECT_GT(bottom_data[i], threshold_);
57      }
58    }
59  }
60  TYPED_TEST(ThresholdLayerTest, Test2) {
61    typedef typename TypeParam::Dtype Dtype;
62    LayerParameter layer_param;
63    ThresholdParameter* threshold_param =
64      layer_param.mutable_threshold_param();
65    threshold_param->set_threshold(0.5);
66    ThresholdLayer<Dtype> layer(layer_param);
67    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
68    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
69    const Dtype* bottom_data = this->blob_bottom_->cpu_data();
70    const Dtype* top_data = this->blob_top_->cpu_data();
71    const Dtype threshold_ = layer_param.threshold_param().threshold();
72    EXPECT_FLOAT_EQ(threshold_, 0.5);
73    for (int i = 0; i < this->blob_bottom_->count(); ++i) {
74      EXPECT_GE(top_data[i], 0.);
75      EXPECT_LE(top_data[i], 1.);
76      if (top_data[i] == 0) {
77        EXPECT_LE(bottom_data[i], threshold_);
78      }
79      if (top_data[i] == 1) {
80        EXPECT_GT(bottom_data[i], threshold_);
81      }
82    }
83  }
84  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-prologparser.cpp</h3>
            <pre><code>1  #include "prologparser.h"
2  TPlChDef::TPlChDef(){
3    ChTypeV.Gen(TPlChDef::MxChar-TPlChDef::MnChar+1);
4    IAssert(TPlChDef::MnChar==0); IAssert(TPlChDef::MxChar==255);
5    for (int Ch=MnChar; Ch<=MxChar; Ch++){ChTypeV[Ch]=plctUnDef;}
6    for (int Ch=MnChar; Ch<=' '; Ch++){ChTypeV[Ch]=plctBl;}
7    ChTypeV[EofCh]=plctEof;
8    ChTypeV['!']=plctSolo;
9    ChTypeV['"']=plctDQuo;
10    ChTypeV['#']=plctSym;
11    ChTypeV['$']=plctSym;
12    ChTypeV['%']=plctComm;
13    ChTypeV['&']=plctSym;
14    ChTypeV['\'']=plctSQuo;
15    ChTypeV['(']=plctMeta;
16    ChTypeV[')']=plctMeta;
17    ChTypeV['*']=plctSym;
18    ChTypeV['+']=plctSym;
19    ChTypeV[',']=plctSolo;
20    ChTypeV['-']=plctSym;
21    ChTypeV['.']=plctSym;
22    ChTypeV['/']=plctSym;
23    for (int Ch='0'; Ch<='9'; Ch++){ChTypeV[Ch]=plctNum;}
24    ChTypeV[':']=plctSym;
25    ChTypeV[';']=plctSolo;
26    ChTypeV['<']=plctSym;
27    ChTypeV['=']=plctSym;
28    ChTypeV['>']=plctSym;
29    ChTypeV['?']=plctSym;
30    ChTypeV['@']=plctSym;
31    for (int Ch='A'; Ch<='Z'; Ch++){ChTypeV[Ch]=plctUpCs;}
32    ChTypeV['[']=plctMeta;
33    ChTypeV['\\']=plctSym;
34    ChTypeV[']']=plctMeta;
35    ChTypeV['^']=plctSym;
36    ChTypeV['_']=plctUnderLn;
37    ChTypeV['`']=plctSym;
38    for (int Ch='a'; Ch<='z'; Ch++){ChTypeV[Ch]=plctLwCs;}
39    ChTypeV['{']=plctMeta;
40    ChTypeV['|']=plctMeta;
41    ChTypeV['}']=plctMeta;
42    ChTypeV['~']=plctSym;
43    ChTypeV[DelCh]=plctBl;
44    IdChPV.Gen(MxChar-MnChar+1);
45    for (int Ch=MnChar; Ch<=MxChar; Ch++){IdChPV[Ch]=false;}
46    for (int Ch='0'; Ch<='9'; Ch++){IdChPV[Ch]=true;}
47    for (int Ch='A'; Ch<='Z'; Ch++){IdChPV[Ch]=true;}
48    IdChPV['_']=true;
49    for (int Ch='a'; Ch<='z'; Ch++){IdChPV[Ch]=true;}
50    ChEscChPV.Gen(MxChar-MnChar+1);
51    for (int Ch=MnChar; Ch<=MxChar; Ch++){ChEscChPV[Ch]=false;}
52    ChEscChPV[HTabCh]=true;
53    ChEscChPV[' ']=true;
54    for (int Ch=MnPrintableCh; Ch<=MxPrintableCh; Ch++){ChEscChPV[Ch]=true;}
55  }
56  void TPlAtomDef::SetOp(const TPlOpType& OpType, const uint& OpPrec){
57    switch (OpType){
58      case plot_fx: (AtomFSet&=AFlgOpPrefixReset)|=AFlgOp_fx; PrefixOpPrec=OpPrec; break;
59      case plot_fy: (AtomFSet&=AFlgOpPrefixReset)|=AFlgOp_fy; PrefixOpPrec=OpPrec; break;
60      case plot_yfx: (AtomFSet&=AFlgOpInfixReset)|=AFlgOp_yfx; InfixOpPrec=OpPrec; break;
61      case plot_xfx: (AtomFSet&=AFlgOpInfixReset)|=AFlgOp_xfx; InfixOpPrec=OpPrec; break;
62      case plot_xfy: (AtomFSet&=AFlgOpInfixReset)|=AFlgOp_xfy; InfixOpPrec=OpPrec; break;
63      case plot_xf: (AtomFSet&=AFlgOpPostfixReset)|=AFlgOp_xf; PostfixOpPrec=OpPrec; break;
64      case plot_yf: (AtomFSet&=AFlgOpPostfixReset)|=AFlgOp_yf; PostfixOpPrec=OpPrec; break;
65      default: Fail;
66    }
67  }
68  void TPlAtomBs::PrepImpAtoms(){
69    ImpAtomIdV.Gen(plaMx);
70    ImpAtomIdV[pla_Impl]=AddAtomStr(":-");
71    ImpAtomIdV[pla_ImplDCG]=AddAtomStr("-->");
72    ImpAtomIdV[pla_Query]=AddAtomStr("?-");
73    ImpAtomIdV[pla_Mode]=AddAtomStr("mode");
74    ImpAtomIdV[pla_Public]=AddAtomStr("public");
75    ImpAtomIdV[pla_Dynamic]=AddAtomStr("dynamic");
76    ImpAtomIdV[pla_MultiFile]=AddAtomStr("multifile");
77    ImpAtomIdV[pla_MetaPredicate]=AddAtomStr("meta_predicate");
78    ImpAtomIdV[pla_Semicolon]=AddAtomStr(";");
79    ImpAtomIdV[pla_VerticalBar]=AddAtomStr("|");
80    ImpAtomIdV[pla_If]=AddAtomStr("->");
81    ImpAtomIdV[pla_Comma]=AddAtomStr(",");
82    ImpAtomIdV[pla_Not]=AddAtomStr("\\+");
83    ImpAtomIdV[pla_Spy]=AddAtomStr("spy");
84    ImpAtomIdV[pla_NoSpy]=AddAtomStr("nospy");
85    ImpAtomIdV[pla_Unify]=AddAtomStr("=");
86    ImpAtomIdV[pla_Is]=AddAtomStr("is");
87    ImpAtomIdV[pla_Uni]=AddAtomStr("=..");
88    ImpAtomIdV[pla_Identical]=AddAtomStr("==");
89    ImpAtomIdV[pla_NotIdentical]=AddAtomStr("\\==");
90    ImpAtomIdV[pla_SOLess]=AddAtomStr("@<");
91    ImpAtomIdV[pla_SOGreater]=AddAtomStr("@>");
92    ImpAtomIdV[pla_SOLessOrEqual]=AddAtomStr("@=<");
93    ImpAtomIdV[pla_SOGreaterOrEqual]=AddAtomStr("@>=");
94    ImpAtomIdV[pla_AEqual]=AddAtomStr("=:=");
95    ImpAtomIdV[pla_ANotEqual]=AddAtomStr("=\\=");
96    ImpAtomIdV[pla_ALess]=AddAtomStr("<");
97    ImpAtomIdV[pla_AGreater]=AddAtomStr(">");
98    ImpAtomIdV[pla_ALessOrEqual]=AddAtomStr("=<");
99    ImpAtomIdV[pla_AGreaterOrEqual]=AddAtomStr(">=");
100    ImpAtomIdV[pla_Colon]=AddAtomStr(":");
101    ImpAtomIdV[pla_Plus]=AddAtomStr("+");
102    ImpAtomIdV[pla_Minus]=AddAtomStr("-");
103    ImpAtomIdV[pla_BitOr]=AddAtomStr("\\/");
104    ImpAtomIdV[pla_BitAnd]=AddAtomStr("/\\");
105    ImpAtomIdV[pla_Divide]=AddAtomStr("/");
106    ImpAtomIdV[pla_IntDivide]=AddAtomStr("&bsol;&bsol;");
107    ImpAtomIdV[pla_Times]=AddAtomStr("*");
108    ImpAtomIdV[pla_ShiftLeft]=AddAtomStr("<<");
109    ImpAtomIdV[pla_ShiftRight]=AddAtomStr(">>");
110    ImpAtomIdV[pla_Mod]=AddAtomStr("mod");
111    ImpAtomIdV[pla_ExistQuantifier]=AddAtomStr("^");
112    ImpAtomIdV[pla_ExclPoint]=AddAtomStr("!");
113    ImpAtomIdV[pla_EmptyList]=AddAtomStr("[]");
114    ImpAtomIdV[pla_EmptyBrace]=AddAtomStr("{}");
115    ImpAtomIdV[pla_EmptyParen]=AddAtomStr("()");
116    ImpAtomIdV[pla_Period]=AddAtomStr(".");
117    ImpAtomIdV[pla_VAR_N]=AddAtomStr("$VAR");
118    ImpAtomIdV[pla_EndOfFile]=AddAtomStr("end_of_file");
119    GetAtomDef(ImpAtomIdV[pla_Impl]).SetOp(plot_xfx, 1200);
120    GetAtomDef(ImpAtomIdV[pla_ImplDCG]).SetOp(plot_xfx, 1200);
121    GetAtomDef(ImpAtomIdV[pla_Impl]).SetOp(plot_fx, 1200);
122    GetAtomDef(ImpAtomIdV[pla_Query]).SetOp(plot_fx, 1200);
123    GetAtomDef(ImpAtomIdV[pla_Mode]).SetOp(plot_fx, 1150);
124    GetAtomDef(ImpAtomIdV[pla_Public]).SetOp(plot_fx, 1150);
125    GetAtomDef(ImpAtomIdV[pla_Dynamic]).SetOp(plot_fx, 1150);
126    GetAtomDef(ImpAtomIdV[pla_MultiFile]).SetOp(plot_fx, 1150);
127    GetAtomDef(ImpAtomIdV[pla_MetaPredicate]).SetOp(plot_fx, 1150);
128    GetAtomDef(ImpAtomIdV[pla_Semicolon]).SetOp(plot_xfy, 1100);
129    GetAtomDef(ImpAtomIdV[pla_VerticalBar]).SetOp(plot_xfy, 1100);
130    GetAtomDef(ImpAtomIdV[pla_If]).SetOp(plot_xfy, 1050);
131    GetAtomDef(ImpAtomIdV[pla_Comma]).SetOp(plot_xfy, 1000);
132    GetAtomDef(ImpAtomIdV[pla_Not]).SetOp(plot_fy, 900);
133    GetAtomDef(ImpAtomIdV[pla_Spy]).SetOp(plot_fy, 900);
134    GetAtomDef(ImpAtomIdV[pla_NoSpy]).SetOp(plot_fy, 900);
135    GetAtomDef(ImpAtomIdV[pla_Unify]).SetOp(plot_xfx, 700);
136    GetAtomDef(ImpAtomIdV[pla_Is]).SetOp(plot_xfx, 700);
137    GetAtomDef(ImpAtomIdV[pla_Uni]).SetOp(plot_xfx, 700);
138    GetAtomDef(ImpAtomIdV[pla_Identical]).SetOp(plot_xfx, 700);
139    GetAtomDef(ImpAtomIdV[pla_NotIdentical]).SetOp(plot_xfx, 700);
140    GetAtomDef(ImpAtomIdV[pla_SOLess]).SetOp(plot_xfx, 700);
141    GetAtomDef(ImpAtomIdV[pla_SOGreater]).SetOp(plot_xfx, 700);
142    GetAtomDef(ImpAtomIdV[pla_SOLessOrEqual]).SetOp(plot_xfx, 700);
143    GetAtomDef(ImpAtomIdV[pla_SOGreaterOrEqual]).SetOp(plot_xfx, 700);
144    GetAtomDef(ImpAtomIdV[pla_AEqual]).SetOp(plot_xfx, 700);
145    GetAtomDef(ImpAtomIdV[pla_ANotEqual]).SetOp(plot_xfx, 700);
146    GetAtomDef(ImpAtomIdV[pla_ALess]).SetOp(plot_xfx, 700);
147    GetAtomDef(ImpAtomIdV[pla_AGreater]).SetOp(plot_xfx, 700);
148    GetAtomDef(ImpAtomIdV[pla_ALessOrEqual]).SetOp(plot_xfx, 700);
149    GetAtomDef(ImpAtomIdV[pla_AGreaterOrEqual]).SetOp(plot_xfx, 700);
150    GetAtomDef(ImpAtomIdV[pla_Colon]).SetOp(plot_xfy, 600);
151    GetAtomDef(ImpAtomIdV[pla_Plus]).SetOp(plot_yfx, 500);
152    GetAtomDef(ImpAtomIdV[pla_Minus]).SetOp(plot_yfx, 500);
153    GetAtomDef(ImpAtomIdV[pla_BitOr]).SetOp(plot_yfx, 500);
154    GetAtomDef(ImpAtomIdV[pla_BitAnd]).SetOp(plot_yfx, 500);
155    GetAtomDef(ImpAtomIdV[pla_Plus]).SetOp(plot_fx, 500);
156    GetAtomDef(ImpAtomIdV[pla_Minus]).SetOp(plot_fx, 500);
157    GetAtomDef(ImpAtomIdV[pla_Divide]).SetOp(plot_yfx, 400);
158    GetAtomDef(ImpAtomIdV[pla_IntDivide]).SetOp(plot_yfx, 400);
<span onclick='openModal()' class='match'>159    GetAtomDef(ImpAtomIdV[pla_Times]).SetOp(plot_yfx, 400);
160    GetAtomDef(ImpAtomIdV[pla_ShiftLeft]).SetOp(plot_yfx, 400);
161    GetAtomDef(ImpAtomIdV[pla_ShiftRight]).SetOp(plot_yfx, 400);
162    GetAtomDef(ImpAtomIdV[pla_Mod]).SetOp(plot_xfx, 300);
163    GetAtomDef(ImpAtomIdV[pla_ExistQuantifier]).SetOp(plot_xfy, 200);
164  }
165  TPlAtomBs::TPlAtomBs():
</span>166    StrToAtomDefH(), ImpAtomIdV(){
167    PrepImpAtoms();
168  }
169  TPlLx::TPlLx(const PSIn& _SIn, const PPlAtomBs& _AtomBs, const PPlVarBs& _VarBs):
170    ChDef(), SIn(_SIn), RSIn(*SIn),
171    CCh(' '), NCh(' '), ChX(0), ChEscBf(), ChType(plctBl), Sym(plstUndef),
172    AtomBs(_AtomBs), VarBs(_VarBs){}
173  void TPlLx::EThrow(const TStr& MsgStr) const {
174    TChA FPosChA;
175    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
176    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(ChX);
177    FPosChA+="]";
178    TStr FullMsgStr=MsgStr+FPosChA;
179    TExcept::Throw(FullMsgStr);
180  }
181  void TPlLx::SkipComment(){
182    while (!((CCh=='*')&&(NCh=='/'))){
183      if ((CCh=='/')&&(NCh=='*')){
184        GetCh(); GetCh(); SkipComment();
185      } else {
186        GetCh();
187        if (CCh==TPlChDef::EofCh){EThrow("Comment not concluded with '*/'");}
188      }
189    }
190    GetCh(); GetCh();
191  }
192  void TPlLx::SkipWs(){
193    forever {
194      while (ChType==plctBl){GetCh();}
195      if ((CCh=='/')&&(NCh=='*')){
196        GetCh(); GetCh(); SkipComment();
197      } else
198      if (CCh=='%'){
199        forever{
200          GetCh();
201          if ((CCh==TPlChDef::CrCh)||(CCh==TPlChDef::LfCh)||(CCh==TPlChDef::EofCh)){break;}
202        }
203        if (CCh==TPlChDef::EofCh){break;} else {GetCh();}
204      } else {
205        break;
206      }
207    }
208  }
209  void TPlLx::GetChEscBf(){
210    ChEscBf.Clr(); GetCh();
211    switch (toupper(CCh)){
212      case 'B': ChEscBf+=TPlChDef::BsCh; GetCh(); break;
213      case 'T': ChEscBf+=TPlChDef::HTabCh; GetCh(); break;
214      case 'N': ChEscBf+=TPlChDef::LfCh; GetCh(); break;
215      case 'V': ChEscBf+=TPlChDef::VTabCh; GetCh(); break;
216      case 'F': ChEscBf+=TPlChDef::FfCh; GetCh(); break;
217      case 'R': ChEscBf+=TPlChDef::CrCh; GetCh(); break;
218      case 'E': ChEscBf+=TPlChDef::EscCh; GetCh(); break;
219      case 'D': ChEscBf+=TPlChDef::DelCh; GetCh(); break;
220      case '0': case '1': case '2': case '3':
221      case '4': case '5': case '6': case '7': 
222        {int Cd=0; int Chs=0;
223        forever{
224          Chs++;
225          Cd=Cd*8+(CCh-48);
226          if (Cd>TPlChDef::MxChar){EThrow("Octal number overflow");}
227          GetCh();
228          if ((Chs==3)||(CCh<'0')||(CCh>'7')){break;}
229        }
230        ChEscBf+=char(Cd); GetCh(); break;}
231      case '^': 
232        GetCh();
233        if ((CCh<'@')||(CCh>'_')){
234          EThrow("Invalid escaped control character");}
235        ChEscBf+=CCh-'@'; GetCh(); break;
236      case 'C' : 
237        forever{
238          GetCh();
239          if (CCh==TPlChDef::EofCh){EThrow("Unexpected end-of-file");}
240          if ((CCh>=TPlChDef::MnPrintableCh)&&(CCh<=TPlChDef::MxPrintableCh)){
241            break;}
242        }
243      default:
244        ChEscBf+=CCh; GetCh(); break;
245    }
246  }
247  void TPlLx::GetVar(){
248    Sym=plsyVar; ChA.Clr();
249    do {
250      ChA+=CCh; GetCh();
251    } while (ChDef.IsIdCh(CCh));
252    VarId=VarBs->AddVarStr(ChA);
253  }
254  void TPlLx::GetAtomNm(){
255    Sym=plsyAtom; ChA.Clr();
256    do {
257      ChA+=CCh; GetCh();
258    } while (ChDef.IsIdCh(CCh));
259    if (CCh=='('){GetCh(); Sym=plsyFAtom;}
260    AtomId=AtomBs->AddAtomStr(ChA);
261  }
262  void TPlLx::GetAtomSym(){
263    Sym=plsyAtom; ChA.Clr();
264    do {
265      ChA+=CCh; GetCh();
266    } while (ChType==plctSym);
267    if (CCh=='('){GetCh(); Sym=plsyFAtom;}
268    AtomId=AtomBs->AddAtomStr(ChA);
269  }
270  void TPlLx::GetAtomQ(){
271    Sym=plsyAtom; ChA.Clr();
272    GetCh();
273    forever{
274      if ((CCh=='\'')&&(NCh!='\'')){GetCh(); break;}
275      if ((CCh=='\'')&&(NCh=='\'')){GetCh();}
276      if (ChEscapingP&&(CCh==ChDef.StartChEscCh)){
277        GetChEscBf(); ChA+=ChEscBf;
278      } else {
279        ChA+=CCh; GetCh();
280      }
281    }
282    if (CCh=='('){GetCh(); Sym=plsyFAtom;}
283    AtomId=AtomBs->AddAtomStr(ChA);
284    AtomBs->GetAtomDef(AtomId).AtomFSet|=TPlAtomDef::AFlgWriteQ;
285  }
286  void TPlLx::GetListStr(){
287    Sym=plsyList; ChA.Clr();
288    GetCh();
289    forever{
290      if ((CCh=='"')&&(NCh!='"')){GetCh(); break;}
291      if ((CCh=='"')&&(NCh=='"')){GetCh();}
292      if (ChEscapingP&&(CCh==ChDef.StartChEscCh)){
293        GetChEscBf(); ChA+=ChEscBf;
294      } else {
295        ChA+=CCh; GetCh();
296      }
297    }
298  }
299  void TPlLx::GetNum(){
300    Sym=plsyInt; ChA.Clr(); Int=0;
301    do {
302      Int=Int*10+CCh; ChA+=CCh; GetCh();
303    } while (ChType==plctNum);
304    if (CCh=='\''){ 
305      int IntBase=Int;
306      if (IntBase>MxIntBase){EThrow("Integer-Base too large.");}
307      GetCh();
308      if (IntBase==0){ 
309        if (ChEscapingP&&(CCh==ChDef.StartChEscCh)){
310          GetChEscBf();
311          if (ChEscBf.Len()>0){Int=ChEscBf[0];} else {Int=0;}
312        } else {
313          Int=uint(CCh); GetCh();
314        }
315      } else { 
316        Int=0;
317        do {
318          int Digit=0;
319          if (ChType==plctNum){ 
320            Digit=CCh-'0';
321          } else
322          if ((ChType==plctUpCs)||(ChType==plctLwCs)){ 
323            Digit=toupper(CCh)-'A'+10;
324          }
325          if (Digit>=IntBase){EThrow("To large digit for integer base.");}
326          Int=Int*IntBase+Digit;
327          GetCh();
328        } while ((ChType==plctNum)||(ChType==plctUpCs)||(ChType==plctLwCs));
329      }
330    } else
331    if ((CCh=='.')||(CCh=='e')||(CCh=='E')){
332      if (CCh=='.'){
333        do {
334          ChA+=CCh; GetCh();
335        } while (ChType==plctNum);
336      }
337      if ((CCh=='e')||(CCh=='E')){
338        ChA+=CCh; GetCh();
339        if ((CCh=='+')||(CCh=='-')){ChA+=CCh; GetCh();}
340        while (ChType==plctNum){ChA+=CCh; GetCh();}
341      }
342      Sym=plsyFlt; Flt=atof(ChA.CStr());
343    }
344  }
345  TPlLxSym TPlLx::GetSym(){
346    SkipWs();
347    switch (ChType){
348      case plctUpCs: 
349        GetVar(); break;
350      case plctUnderLn: 
351        if (ChDef.IsIdCh(CCh)){GetVar();}
352        else {Sym=plsyVoid; GetCh();}
353        break;
354      case plctLwCs: 
355        GetAtomNm(); break;
356      case plctSym: 
357        if ((CCh=='-')&&(ChDef.GetChType(NCh)==plctNum)){
358          GetCh(); GetNum();
359          if (Sym==plsyInt){Int=-Int;}
360          else if (Sym==plsyFlt){Flt=-Flt;}
361        } else
362        if ((CCh=='.')&&(NCh<=' ')){
363          Sym=plsyFullStop; GetCh();
364        } else {
365          GetAtomSym();
366        }
367        break;
368      case plctSolo: 
369        Sym=plsyAtom;
370        if (CCh=='!'){AtomId=AtomBs->GetImpAtomId(pla_ExclPoint);}
371        else if (CCh==';'){AtomId=AtomBs->GetImpAtomId(pla_Semicolon);}
372        else if (CCh==','){AtomId=AtomBs->GetImpAtomId(pla_Comma);}
373        else {Fail;}
374        GetCh(); break;
375      case plctSQuo: 
376        GetAtomQ(); break;
377      case plctDQuo: 
378        GetListStr(); break;
379      case plctMeta: 
380        switch (CCh){
381          case '(':
382            GetCh(); SkipWs();
383            if (CCh==')'){
384              Sym=plsyAtom; AtomId=AtomBs->GetImpAtomId(pla_EmptyParen); GetCh();
385            } else {
386              Sym=plsyLPar;
387            }
388            break;
389          case ')':
390            Sym=plsyRPar; GetCh(); break;
391          case '[':
392            GetCh(); SkipWs();
393            if (CCh==']'){
394              Sym==plsyAtom; AtomId=AtomBs->GetImpAtomId(pla_EmptyList); GetCh();
395            } else {
396              Sym=plsyLBracket;
397            }
398            break;
399          case ']':
400            Sym=plsyRBracket; GetCh(); break;
401          case '{':
402            GetCh(); SkipWs();
403            if (CCh=='}'){
404              Sym=plsyAtom; AtomId=AtomBs->GetImpAtomId(pla_EmptyBrace); GetCh();
405            } else {
406              Sym=plsyLBrace;
407            }
408            break;
409          case '}':
410            Sym=plsyRBrace; GetCh(); break;
411          case '|':
412            if (ParseInsideListExpP){
413              Sym=plsyVBar; GetCh();
414            } else {
415              Sym=plsyAtom; AtomId=AtomBs->GetImpAtomId(pla_VerticalBar); GetCh();
416            }
417            break;
418          default:
419            EThrow("Unknown meta character.");
420        }
421      case plctNum: 
422        GetNum(); break;
423      case plctEof: 
424        Sym=plsyEof; break;
425      default:
426        EThrow("Invalid character type");
427    }
428    return Sym;
429  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_threshold_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-prologparser.cpp</div>
                </div>
                <div class="column column_space"><pre><code>34    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
35    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
36    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
37    EXPECT_EQ(this->blob_top_->height(), this->blob_bottom_->height());
38    EXPECT_EQ(this->blob_top_->width(), this->blob_bottom_->width());
39  }
40  TYPED_TEST(ThresholdLayerTest, Test) {
</pre></code></div>
                <div class="column column_space"><pre><code>159    GetAtomDef(ImpAtomIdV[pla_Times]).SetOp(plot_yfx, 400);
160    GetAtomDef(ImpAtomIdV[pla_ShiftLeft]).SetOp(plot_yfx, 400);
161    GetAtomDef(ImpAtomIdV[pla_ShiftRight]).SetOp(plot_yfx, 400);
162    GetAtomDef(ImpAtomIdV[pla_Mod]).SetOp(plot_xfx, 300);
163    GetAtomDef(ImpAtomIdV[pla_ExistQuantifier]).SetOp(plot_xfy, 200);
164  }
165  TPlAtomBs::TPlAtomBs():
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    