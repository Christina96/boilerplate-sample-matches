
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 59.19439579684763%, Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-message_deserializer.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/node/common.hpp>
3  #include <nano/node/messages.hpp>
4  #include <memory>
5  #include <vector>
6  namespace nano
7  {
8  namespace transport
9  {
10  	class message_deserializer : public std::enable_shared_from_this<nano::transport::message_deserializer>
11  	{
12  	public:
13  		enum class parse_status
14  		{
<span onclick='openModal()' class='match'>15  			none,
16  			success,
17  			insufficient_work,
18  			invalid_header,
19  			invalid_message_type,
20  			invalid_keepalive_message,
21  			invalid_publish_message,
22  			invalid_confirm_req_message,
23  			invalid_confirm_ack_message,
24  			invalid_node_id_handshake_message,
25  			invalid_telemetry_req_message,
26  			invalid_telemetry_ack_message,
27  			invalid_bulk_pull_message,
28  			invalid_bulk_pull_account_message,
29  			invalid_frontier_req_message,
30  			invalid_asc_pull_req_message,
31  			invalid_asc_pull_ack_message,
32  			invalid_network,
</span>33  			outdated_version,
34  			duplicate_publish_message,
35  			message_size_too_big,
36  		};
37  		using callback_type = std::function<void (boost::system::error_code, std::unique_ptr<nano::message>)>;
38  		parse_status status;
39  		using read_query = std::function<void (std::shared_ptr<std::vector<uint8_t>> const &, size_t, std::function<void (boost::system::error_code const &, std::size_t)>)>;
40  		message_deserializer (network_constants const &, network_filter &, block_uniquer &, vote_uniquer &, read_query read_op);
41  		void read (callback_type const && callback);
42  	private:
43  		void received_header (callback_type const && callback);
44  		void received_message (nano::message_header header, std::size_t payload_size, callback_type const && callback);
45  		std::unique_ptr<nano::message> deserialize (nano::message_header header, std::size_t payload_size);
46  		std::unique_ptr<nano::keepalive> deserialize_keepalive (nano::stream &, nano::message_header const &);
47  		std::unique_ptr<nano::publish> deserialize_publish (nano::stream &, nano::message_header const &, nano::uint128_t const & = 0);
48  		std::unique_ptr<nano::confirm_req> deserialize_confirm_req (nano::stream &, nano::message_header const &);
49  		std::unique_ptr<nano::confirm_ack> deserialize_confirm_ack (nano::stream &, nano::message_header const &);
50  		std::unique_ptr<nano::node_id_handshake> deserialize_node_id_handshake (nano::stream &, nano::message_header const &);
51  		std::unique_ptr<nano::telemetry_req> deserialize_telemetry_req (nano::stream &, nano::message_header const &);
52  		std::unique_ptr<nano::telemetry_ack> deserialize_telemetry_ack (nano::stream &, nano::message_header const &);
53  		std::unique_ptr<nano::bulk_pull> deserialize_bulk_pull (nano::stream &, nano::message_header const &);
54  		std::unique_ptr<nano::bulk_pull_account> deserialize_bulk_pull_account (nano::stream &, nano::message_header const &);
55  		std::unique_ptr<nano::bulk_push> deserialize_bulk_push (nano::stream &, nano::message_header const &);
56  		std::unique_ptr<nano::frontier_req> deserialize_frontier_req (nano::stream &, nano::message_header const &);
57  		std::unique_ptr<nano::asc_pull_req> deserialize_asc_pull_req (nano::stream &, nano::message_header const &);
58  		std::unique_ptr<nano::asc_pull_ack> deserialize_asc_pull_ack (nano::stream &, nano::message_header const &);
59  		std::shared_ptr<std::vector<uint8_t>> read_buffer;
60  	private: 
61  		static constexpr std::size_t HEADER_SIZE = 8;
62  		static constexpr std::size_t MAX_MESSAGE_SIZE = 1024 * 65;
63  	private: 
64  		nano::network_constants const & network_constants_m;
65  		nano::network_filter & publish_filter_m;
66  		nano::block_uniquer & block_uniquer_m;
67  		nano::vote_uniquer & vote_uniquer_m;
68  		read_query read_op;
69  	public:
70  		static stat::detail to_stat_detail (parse_status);
71  		static std::string to_string (parse_status);
72  	};
73  }
74  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-capi.h</h3>
            <pre><code>1  #ifndef API_CAPI_H_
2  #define API_CAPI_H_
3  #include "export.h"
4  #ifdef __cplusplus
5  #  include <tesseract/baseapi.h>
6  #  include <tesseract/ocrclass.h>
7  #  include <tesseract/pageiterator.h>
8  #  include <tesseract/renderer.h>
9  #  include <tesseract/resultiterator.h>
10  #endif
11  #include <stdbool.h>
12  #include <stdio.h>
13  #ifdef __cplusplus
14  extern "C" {
15  #endif
16  #ifndef BOOL
17  #  define BOOL int
18  #  define TRUE 1
19  #  define FALSE 0
20  #endif
21  #ifdef __cplusplus
22  typedef tesseract::TessResultRenderer TessResultRenderer;
23  typedef tesseract::TessBaseAPI TessBaseAPI;
24  typedef tesseract::PageIterator TessPageIterator;
25  typedef tesseract::ResultIterator TessResultIterator;
26  typedef tesseract::MutableIterator TessMutableIterator;
27  typedef tesseract::ChoiceIterator TessChoiceIterator;
28  typedef tesseract::OcrEngineMode TessOcrEngineMode;
29  typedef tesseract::PageSegMode TessPageSegMode;
30  typedef tesseract::PageIteratorLevel TessPageIteratorLevel;
31  typedef tesseract::Orientation TessOrientation;
32  typedef tesseract::ParagraphJustification TessParagraphJustification;
33  typedef tesseract::WritingDirection TessWritingDirection;
34  typedef tesseract::TextlineOrder TessTextlineOrder;
35  typedef tesseract::PolyBlockType TessPolyBlockType;
36  typedef tesseract::ETEXT_DESC ETEXT_DESC;
37  #else
38  typedef struct TessResultRenderer TessResultRenderer;
39  typedef struct TessBaseAPI TessBaseAPI;
40  typedef struct TessPageIterator TessPageIterator;
41  typedef struct TessResultIterator TessResultIterator;
42  typedef struct TessMutableIterator TessMutableIterator;
43  typedef struct TessChoiceIterator TessChoiceIterator;
44  typedef enum TessOcrEngineMode {
45    OEM_TESSERACT_ONLY,
46    OEM_LSTM_ONLY,
47    OEM_TESSERACT_LSTM_COMBINED,
48    OEM_DEFAULT
49  } TessOcrEngineMode;
50  typedef enum TessPageSegMode {
51    PSM_OSD_ONLY,
52    PSM_AUTO_OSD,
53    PSM_AUTO_ONLY,
54    PSM_AUTO,
55    PSM_SINGLE_COLUMN,
56    PSM_SINGLE_BLOCK_VERT_TEXT,
57    PSM_SINGLE_BLOCK,
58    PSM_SINGLE_LINE,
59    PSM_SINGLE_WORD,
60    PSM_CIRCLE_WORD,
61    PSM_SINGLE_CHAR,
62    PSM_SPARSE_TEXT,
63    PSM_SPARSE_TEXT_OSD,
64    PSM_RAW_LINE,
65    PSM_COUNT
66  } TessPageSegMode;
67  typedef enum TessPageIteratorLevel {
68    RIL_BLOCK,
69    RIL_PARA,
70    RIL_TEXTLINE,
71    RIL_WORD,
72    RIL_SYMBOL
73  } TessPageIteratorLevel;
74  typedef enum TessPolyBlockType {
75    PT_UNKNOWN,
76    PT_FLOWING_TEXT,
77    PT_HEADING_TEXT,
78    PT_PULLOUT_TEXT,
79    PT_EQUATION,
80    PT_INLINE_EQUATION,
81    PT_TABLE,
82    PT_VERTICAL_TEXT,
83    PT_CAPTION_TEXT,
84    PT_FLOWING_IMAGE,
85    PT_HEADING_IMAGE,
86    PT_PULLOUT_IMAGE,
87    PT_HORZ_LINE,
88    PT_VERT_LINE,
89    PT_NOISE,
90    PT_COUNT
91  } TessPolyBlockType;
92  typedef enum TessOrientation {
93    ORIENTATION_PAGE_UP,
94    ORIENTATION_PAGE_RIGHT,
95    ORIENTATION_PAGE_DOWN,
96    ORIENTATION_PAGE_LEFT
97  } TessOrientation;
98  typedef enum TessParagraphJustification {
99    JUSTIFICATION_UNKNOWN,
100    JUSTIFICATION_LEFT,
101    JUSTIFICATION_CENTER,
102    JUSTIFICATION_RIGHT
103  } TessParagraphJustification;
104  typedef enum TessWritingDirection {
105    WRITING_DIRECTION_LEFT_TO_RIGHT,
106    WRITING_DIRECTION_RIGHT_TO_LEFT,
107    WRITING_DIRECTION_TOP_TO_BOTTOM
108  } TessWritingDirection;
109  typedef enum TessTextlineOrder {
110    TEXTLINE_ORDER_LEFT_TO_RIGHT,
111    TEXTLINE_ORDER_RIGHT_TO_LEFT,
112    TEXTLINE_ORDER_TOP_TO_BOTTOM
113  } TessTextlineOrder;
114  typedef struct ETEXT_DESC ETEXT_DESC;
115  #endif
116  typedef bool (*TessCancelFunc)(void *cancel_this, int words);
117  typedef bool (*TessProgressFunc)(ETEXT_DESC *ths, int left, int right, int top,
118                                   int bottom);
119  struct Pix;
120  struct Boxa;
121  struct Pixa;
122  TESS_API const char *TessVersion();
123  TESS_API void TessDeleteText(const char *text);
124  TESS_API void TessDeleteTextArray(char **arr);
125  TESS_API void TessDeleteIntArray(const int *arr);
126  TESS_API TessResultRenderer *TessTextRendererCreate(const char *outputbase);
127  TESS_API TessResultRenderer *TessHOcrRendererCreate(const char *outputbase);
128  TESS_API TessResultRenderer *TessHOcrRendererCreate2(const char *outputbase,
129                                                       BOOL font_info);
130  TESS_API TessResultRenderer *TessAltoRendererCreate(const char *outputbase);
131  TESS_API TessResultRenderer *TessTsvRendererCreate(const char *outputbase);
132  TESS_API TessResultRenderer *TessPDFRendererCreate(const char *outputbase,
133                                                     const char *datadir,
134                                                     BOOL textonly);
135  TESS_API TessResultRenderer *TessUnlvRendererCreate(const char *outputbase);
136  TESS_API TessResultRenderer *TessBoxTextRendererCreate(const char *outputbase);
137  TESS_API TessResultRenderer *TessLSTMBoxRendererCreate(const char *outputbase);
138  TESS_API TessResultRenderer *TessWordStrBoxRendererCreate(
139      const char *outputbase);
140  TESS_API void TessDeleteResultRenderer(TessResultRenderer *renderer);
141  TESS_API void TessResultRendererInsert(TessResultRenderer *renderer,
142                                         TessResultRenderer *next);
143  TESS_API TessResultRenderer *TessResultRendererNext(
144      TessResultRenderer *renderer);
145  TESS_API BOOL TessResultRendererBeginDocument(TessResultRenderer *renderer,
146                                                const char *title);
147  TESS_API BOOL TessResultRendererAddImage(TessResultRenderer *renderer,
148                                           TessBaseAPI *api);
149  TESS_API BOOL TessResultRendererEndDocument(TessResultRenderer *renderer);
150  TESS_API const char *TessResultRendererExtention(TessResultRenderer *renderer);
151  TESS_API const char *TessResultRendererTitle(TessResultRenderer *renderer);
152  TESS_API int TessResultRendererImageNum(TessResultRenderer *renderer);
153  TESS_API TessBaseAPI *TessBaseAPICreate();
154  TESS_API void TessBaseAPIDelete(TessBaseAPI *handle);
155  TESS_API size_t TessBaseAPIGetOpenCLDevice(TessBaseAPI *handle, void **device);
156  TESS_API void TessBaseAPISetInputName(TessBaseAPI *handle, const char *name);
157  TESS_API const char *TessBaseAPIGetInputName(TessBaseAPI *handle);
158  TESS_API void TessBaseAPISetInputImage(TessBaseAPI *handle, struct Pix *pix);
159  TESS_API struct Pix *TessBaseAPIGetInputImage(TessBaseAPI *handle);
160  TESS_API int TessBaseAPIGetSourceYResolution(TessBaseAPI *handle);
161  TESS_API const char *TessBaseAPIGetDatapath(TessBaseAPI *handle);
162  TESS_API void TessBaseAPISetOutputName(TessBaseAPI *handle, const char *name);
163  TESS_API BOOL TessBaseAPISetVariable(TessBaseAPI *handle, const char *name,
164                                       const char *value);
165  TESS_API BOOL TessBaseAPISetDebugVariable(TessBaseAPI *handle, const char *name,
166                                            const char *value);
167  TESS_API BOOL TessBaseAPIGetIntVariable(const TessBaseAPI *handle,
168                                          const char *name, int *value);
169  TESS_API BOOL TessBaseAPIGetBoolVariable(const TessBaseAPI *handle,
170                                           const char *name, BOOL *value);
171  TESS_API BOOL TessBaseAPIGetDoubleVariable(const TessBaseAPI *handle,
172                                             const char *name, double *value);
173  TESS_API const char *TessBaseAPIGetStringVariable(const TessBaseAPI *handle,
174                                                    const char *name);
175  TESS_API void TessBaseAPIPrintVariables(const TessBaseAPI *handle, FILE *fp);
176  TESS_API BOOL TessBaseAPIPrintVariablesToFile(const TessBaseAPI *handle,
177                                                const char *filename);
178  TESS_API int TessBaseAPIInit1(TessBaseAPI *handle, const char *datapath,
179                                const char *language, TessOcrEngineMode oem,
180                                char **configs, int configs_size);
181  TESS_API int TessBaseAPIInit2(TessBaseAPI *handle, const char *datapath,
182                                const char *language, TessOcrEngineMode oem);
183  TESS_API int TessBaseAPIInit3(TessBaseAPI *handle, const char *datapath,
184                                const char *language);
185  TESS_API int TessBaseAPIInit4(TessBaseAPI *handle, const char *datapath,
186                                const char *language, TessOcrEngineMode mode,
187                                char **configs, int configs_size, char **vars_vec,
188                                char **vars_values, size_t vars_vec_size,
189                                BOOL set_only_non_debug_params);
190  TESS_API int TessBaseAPIInit5(TessBaseAPI *handle, const char *data, int data_size,
191                                const char *language, TessOcrEngineMode mode,
192                                char **configs, int configs_size, char **vars_vec,
193                                char **vars_values, size_t vars_vec_size,
194                                BOOL set_only_non_debug_params);
195  TESS_API const char *TessBaseAPIGetInitLanguagesAsString(
196      const TessBaseAPI *handle);
197  TESS_API char **TessBaseAPIGetLoadedLanguagesAsVector(
198      const TessBaseAPI *handle);
199  TESS_API char **TessBaseAPIGetAvailableLanguagesAsVector(
200      const TessBaseAPI *handle);
201  TESS_API void TessBaseAPIInitForAnalysePage(TessBaseAPI *handle);
202  TESS_API void TessBaseAPIReadConfigFile(TessBaseAPI *handle,
203                                          const char *filename);
204  TESS_API void TessBaseAPIReadDebugConfigFile(TessBaseAPI *handle,
205                                               const char *filename);
206  TESS_API void TessBaseAPISetPageSegMode(TessBaseAPI *handle,
207                                          TessPageSegMode mode);
208  TESS_API TessPageSegMode TessBaseAPIGetPageSegMode(const TessBaseAPI *handle);
209  TESS_API char *TessBaseAPIRect(TessBaseAPI *handle,
210                                 const unsigned char *imagedata,
211                                 int bytes_per_pixel, int bytes_per_line,
212                                 int left, int top, int width, int height);
213  TESS_API void TessBaseAPIClearAdaptiveClassifier(TessBaseAPI *handle);
214  TESS_API void TessBaseAPISetImage(TessBaseAPI *handle,
215                                    const unsigned char *imagedata, int width,
216                                    int height, int bytes_per_pixel,
217                                    int bytes_per_line);
218  TESS_API void TessBaseAPISetImage2(TessBaseAPI *handle, struct Pix *pix);
219  TESS_API void TessBaseAPISetSourceResolution(TessBaseAPI *handle, int ppi);
220  TESS_API void TessBaseAPISetRectangle(TessBaseAPI *handle, int left, int top,
<span onclick='openModal()' class='match'>221                                        int width, int height);
222  TESS_API struct Pix *TessBaseAPIGetThresholdedImage(TessBaseAPI *handle);
223  TESS_API struct Boxa *TessBaseAPIGetRegions(TessBaseAPI *handle,
224                                              struct Pixa **pixa);
225  TESS_API struct Boxa *TessBaseAPIGetTextlines(TessBaseAPI *handle,
226                                                struct Pixa **pixa,
227                                                int **blockids);
228  TESS_API struct Boxa *TessBaseAPIGetTextlines1(TessBaseAPI *handle,
229                                                 BOOL raw_image, int raw_padding,
230                                                 struct Pixa **pixa,
231                                                 int **blockids, int **paraids);
232  TESS_API struct Boxa *TessBaseAPIGetStrips(TessBaseAPI *handle,
233                                             struct Pixa **pixa, int **blockids);
234  TESS_API struct Boxa *TessBaseAPIGetWords(TessBaseAPI *handle,
</span>235                                            struct Pixa **pixa);
236  TESS_API struct Boxa *TessBaseAPIGetConnectedComponents(TessBaseAPI *handle,
237                                                          struct Pixa **cc);
238  TESS_API struct Boxa *TessBaseAPIGetComponentImages(TessBaseAPI *handle,
239                                                      TessPageIteratorLevel level,
240                                                      BOOL text_only,
241                                                      struct Pixa **pixa,
242                                                      int **blockids);
243  TESS_API struct Boxa *TessBaseAPIGetComponentImages1(
244      TessBaseAPI *handle, TessPageIteratorLevel level, BOOL text_only,
245      BOOL raw_image, int raw_padding, struct Pixa **pixa, int **blockids,
246      int **paraids);
247  TESS_API int TessBaseAPIGetThresholdedImageScaleFactor(
248      const TessBaseAPI *handle);
249  TESS_API TessPageIterator *TessBaseAPIAnalyseLayout(TessBaseAPI *handle);
250  TESS_API int TessBaseAPIRecognize(TessBaseAPI *handle, ETEXT_DESC *monitor);
251  TESS_API BOOL TessBaseAPIProcessPages(TessBaseAPI *handle, const char *filename,
252                                        const char *retry_config,
253                                        int timeout_millisec,
254                                        TessResultRenderer *renderer);
255  TESS_API BOOL TessBaseAPIProcessPage(TessBaseAPI *handle, struct Pix *pix,
256                                       int page_index, const char *filename,
257                                       const char *retry_config,
258                                       int timeout_millisec,
259                                       TessResultRenderer *renderer);
260  TESS_API TessResultIterator *TessBaseAPIGetIterator(TessBaseAPI *handle);
261  TESS_API TessMutableIterator *TessBaseAPIGetMutableIterator(
262      TessBaseAPI *handle);
263  TESS_API char *TessBaseAPIGetUTF8Text(TessBaseAPI *handle);
264  TESS_API char *TessBaseAPIGetHOCRText(TessBaseAPI *handle, int page_number);
265  TESS_API char *TessBaseAPIGetAltoText(TessBaseAPI *handle, int page_number);
266  TESS_API char *TessBaseAPIGetTsvText(TessBaseAPI *handle, int page_number);
267  TESS_API char *TessBaseAPIGetBoxText(TessBaseAPI *handle, int page_number);
268  TESS_API char *TessBaseAPIGetLSTMBoxText(TessBaseAPI *handle, int page_number);
269  TESS_API char *TessBaseAPIGetWordStrBoxText(TessBaseAPI *handle,
270                                              int page_number);
271  TESS_API char *TessBaseAPIGetUNLVText(TessBaseAPI *handle);
272  TESS_API int TessBaseAPIMeanTextConf(TessBaseAPI *handle);
273  TESS_API int *TessBaseAPIAllWordConfidences(TessBaseAPI *handle);
274  #ifndef DISABLED_LEGACY_ENGINE
275  TESS_API BOOL TessBaseAPIAdaptToWordStr(TessBaseAPI *handle,
276                                          TessPageSegMode mode,
277                                          const char *wordstr);
278  #endif 
279  TESS_API void TessBaseAPIClear(TessBaseAPI *handle);
280  TESS_API void TessBaseAPIEnd(TessBaseAPI *handle);
281  TESS_API int TessBaseAPIIsValidWord(TessBaseAPI *handle, const char *word);
282  TESS_API BOOL TessBaseAPIGetTextDirection(TessBaseAPI *handle, int *out_offset,
283                                            float *out_slope);
284  TESS_API const char *TessBaseAPIGetUnichar(TessBaseAPI *handle, int unichar_id);
285  TESS_API void TessBaseAPIClearPersistentCache(TessBaseAPI *handle);
286  #ifndef DISABLED_LEGACY_ENGINE
287  TESS_API BOOL TessBaseAPIDetectOrientationScript(TessBaseAPI *handle,
288                                                   int *orient_deg,
289                                                   float *orient_conf,
290                                                   const char **script_name,
291                                                   float *script_conf);
292  #endif 
293  TESS_API void TessBaseAPISetMinOrientationMargin(TessBaseAPI *handle,
294                                                   double margin);
295  TESS_API int TessBaseAPINumDawgs(const TessBaseAPI *handle);
296  TESS_API TessOcrEngineMode TessBaseAPIOem(const TessBaseAPI *handle);
297  TESS_API void TessBaseGetBlockTextOrientations(TessBaseAPI *handle,
298                                                 int **block_orientation,
299                                                 bool **vertical_writing);
300  TESS_API void TessPageIteratorDelete(TessPageIterator *handle);
301  TESS_API TessPageIterator *TessPageIteratorCopy(const TessPageIterator *handle);
302  TESS_API void TessPageIteratorBegin(TessPageIterator *handle);
303  TESS_API BOOL TessPageIteratorNext(TessPageIterator *handle,
304                                     TessPageIteratorLevel level);
305  TESS_API BOOL TessPageIteratorIsAtBeginningOf(const TessPageIterator *handle,
306                                                TessPageIteratorLevel level);
307  TESS_API BOOL TessPageIteratorIsAtFinalElement(const TessPageIterator *handle,
308                                                 TessPageIteratorLevel level,
309                                                 TessPageIteratorLevel element);
310  TESS_API BOOL TessPageIteratorBoundingBox(const TessPageIterator *handle,
311                                            TessPageIteratorLevel level,
312                                            int *left, int *top, int *right,
313                                            int *bottom);
314  TESS_API TessPolyBlockType
315  TessPageIteratorBlockType(const TessPageIterator *handle);
316  TESS_API struct Pix *TessPageIteratorGetBinaryImage(
317      const TessPageIterator *handle, TessPageIteratorLevel level);
318  TESS_API struct Pix *TessPageIteratorGetImage(const TessPageIterator *handle,
319                                                TessPageIteratorLevel level,
320                                                int padding,
321                                                struct Pix *original_image,
322                                                int *left, int *top);
323  TESS_API BOOL TessPageIteratorBaseline(const TessPageIterator *handle,
324                                         TessPageIteratorLevel level, int *x1,
325                                         int *y1, int *x2, int *y2);
326  TESS_API void TessPageIteratorOrientation(
327      TessPageIterator *handle, TessOrientation *orientation,
328      TessWritingDirection *writing_direction, TessTextlineOrder *textline_order,
329      float *deskew_angle);
330  TESS_API void TessPageIteratorParagraphInfo(
331      TessPageIterator *handle, TessParagraphJustification *justification,
332      BOOL *is_list_item, BOOL *is_crown, int *first_line_indent);
333  TESS_API void TessResultIteratorDelete(TessResultIterator *handle);
334  TESS_API TessResultIterator *TessResultIteratorCopy(
335      const TessResultIterator *handle);
336  TESS_API TessPageIterator *TessResultIteratorGetPageIterator(
337      TessResultIterator *handle);
338  TESS_API const TessPageIterator *TessResultIteratorGetPageIteratorConst(
339      const TessResultIterator *handle);
340  TESS_API TessChoiceIterator *TessResultIteratorGetChoiceIterator(
341      const TessResultIterator *handle);
342  TESS_API BOOL TessResultIteratorNext(TessResultIterator *handle,
343                                       TessPageIteratorLevel level);
344  TESS_API char *TessResultIteratorGetUTF8Text(const TessResultIterator *handle,
345                                               TessPageIteratorLevel level);
346  TESS_API float TessResultIteratorConfidence(const TessResultIterator *handle,
347                                              TessPageIteratorLevel level);
348  TESS_API const char *TessResultIteratorWordRecognitionLanguage(
349      const TessResultIterator *handle);
350  TESS_API const char *TessResultIteratorWordFontAttributes(
351      const TessResultIterator *handle, BOOL *is_bold, BOOL *is_italic,
352      BOOL *is_underlined, BOOL *is_monospace, BOOL *is_serif, BOOL *is_smallcaps,
353      int *pointsize, int *font_id);
354  TESS_API BOOL
355  TessResultIteratorWordIsFromDictionary(const TessResultIterator *handle);
356  TESS_API BOOL TessResultIteratorWordIsNumeric(const TessResultIterator *handle);
357  TESS_API BOOL
358  TessResultIteratorSymbolIsSuperscript(const TessResultIterator *handle);
359  TESS_API BOOL
360  TessResultIteratorSymbolIsSubscript(const TessResultIterator *handle);
361  TESS_API BOOL
362  TessResultIteratorSymbolIsDropcap(const TessResultIterator *handle);
363  TESS_API void TessChoiceIteratorDelete(TessChoiceIterator *handle);
364  TESS_API BOOL TessChoiceIteratorNext(TessChoiceIterator *handle);
365  TESS_API const char *TessChoiceIteratorGetUTF8Text(
366      const TessChoiceIterator *handle);
367  TESS_API float TessChoiceIteratorConfidence(const TessChoiceIterator *handle);
368  TESS_API ETEXT_DESC *TessMonitorCreate();
369  TESS_API void TessMonitorDelete(ETEXT_DESC *monitor);
370  TESS_API void TessMonitorSetCancelFunc(ETEXT_DESC *monitor,
371                                         TessCancelFunc cancelFunc);
372  TESS_API void TessMonitorSetCancelThis(ETEXT_DESC *monitor, void *cancelThis);
373  TESS_API void *TessMonitorGetCancelThis(ETEXT_DESC *monitor);
374  TESS_API void TessMonitorSetProgressFunc(ETEXT_DESC *monitor,
375                                           TessProgressFunc progressFunc);
376  TESS_API int TessMonitorGetProgress(ETEXT_DESC *monitor);
377  TESS_API void TessMonitorSetDeadlineMSecs(ETEXT_DESC *monitor, int deadline);
378  #ifdef __cplusplus
379  }
380  #endif
381  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-message_deserializer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-capi.h</div>
                </div>
                <div class="column column_space"><pre><code>15  			none,
16  			success,
17  			insufficient_work,
18  			invalid_header,
19  			invalid_message_type,
20  			invalid_keepalive_message,
21  			invalid_publish_message,
22  			invalid_confirm_req_message,
23  			invalid_confirm_ack_message,
24  			invalid_node_id_handshake_message,
25  			invalid_telemetry_req_message,
26  			invalid_telemetry_ack_message,
27  			invalid_bulk_pull_message,
28  			invalid_bulk_pull_account_message,
29  			invalid_frontier_req_message,
30  			invalid_asc_pull_req_message,
31  			invalid_asc_pull_ack_message,
32  			invalid_network,
</pre></code></div>
                <div class="column column_space"><pre><code>221                                        int width, int height);
222  TESS_API struct Pix *TessBaseAPIGetThresholdedImage(TessBaseAPI *handle);
223  TESS_API struct Boxa *TessBaseAPIGetRegions(TessBaseAPI *handle,
224                                              struct Pixa **pixa);
225  TESS_API struct Boxa *TessBaseAPIGetTextlines(TessBaseAPI *handle,
226                                                struct Pixa **pixa,
227                                                int **blockids);
228  TESS_API struct Boxa *TessBaseAPIGetTextlines1(TessBaseAPI *handle,
229                                                 BOOL raw_image, int raw_padding,
230                                                 struct Pixa **pixa,
231                                                 int **blockids, int **paraids);
232  TESS_API struct Boxa *TessBaseAPIGetStrips(TessBaseAPI *handle,
233                                             struct Pixa **pixa, int **blockids);
234  TESS_API struct Boxa *TessBaseAPIGetWords(TessBaseAPI *handle,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    