
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.7924528301886795%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-port.h</h3>
            <pre><code>1  #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_
2  #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_
3  #include <ctype.h>   
4  #include <stddef.h>  
5  #include <stdlib.h>
6  #include <stdio.h>
7  #include <string.h>
8  #ifndef _WIN32_WCE
9  # include <sys/types.h>
10  # include <sys/stat.h>
11  #endif  
12  #if defined __APPLE__
13  # include <AvailabilityMacros.h>
14  # include <TargetConditionals.h>
15  #endif
16  #include <iostream>  
17  #include <sstream>  
18  #include <string>  
19  #define GTEST_DEV_EMAIL_ "googletestframework@@googlegroups.com"
20  #define GTEST_FLAG_PREFIX_ "gtest_"
21  #define GTEST_FLAG_PREFIX_DASH_ "gtest-"
22  #define GTEST_FLAG_PREFIX_UPPER_ "GTEST_"
23  #define GTEST_NAME_ "Google Test"
24  #define GTEST_PROJECT_URL_ "http:&bsol;&bsol;code.google.com/p/googletest/"
25  #ifdef __GNUC__
26  # define GTEST_GCC_VER_ \
27      (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)
28  #endif  
29  #ifdef __CYGWIN__
30  # define GTEST_OS_CYGWIN 1
31  #elif defined __SYMBIAN32__
32  # define GTEST_OS_SYMBIAN 1
33  #elif defined _WIN32
34  # define GTEST_OS_WINDOWS 1
35  # ifdef _WIN32_WCE
36  #  define GTEST_OS_WINDOWS_MOBILE 1
37  # elif defined(__MINGW__) || defined(__MINGW32__)
38  #  define GTEST_OS_WINDOWS_MINGW 1
39  # else
40  #  define GTEST_OS_WINDOWS_DESKTOP 1
41  # endif  
42  #elif defined __APPLE__
43  # define GTEST_OS_MAC 1
44  # if TARGET_OS_IPHONE
45  #  define GTEST_OS_IOS 1
46  #  if TARGET_IPHONE_SIMULATOR
47  #   define GTEST_OS_IOS_SIMULATOR 1
48  #  endif
49  # endif
50  #elif defined __linux__
51  # define GTEST_OS_LINUX 1
52  # if defined __ANDROID__
53  #  define GTEST_OS_LINUX_ANDROID 1
54  # endif
55  #elif defined __MVS__
56  # define GTEST_OS_ZOS 1
57  #elif defined(__sun) && defined(__SVR4)
58  # define GTEST_OS_SOLARIS 1
59  #elif defined(_AIX)
60  # define GTEST_OS_AIX 1
61  #elif defined(__hpux)
62  # define GTEST_OS_HPUX 1
63  #elif defined __native_client__
64  # define GTEST_OS_NACL 1
65  #elif defined __OpenBSD__
66  # define GTEST_OS_OPENBSD 1
67  #elif defined __QNX__
68  # define GTEST_OS_QNX 1
69  #endif  
70  #ifndef GTEST_LANG_CXX11
71  # if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L
72  #  define GTEST_LANG_CXX11 1
73  # else
74  #  define GTEST_LANG_CXX11 0
75  # endif
76  #endif
77  #if !GTEST_OS_WINDOWS
78  # include <unistd.h>
79  # include <strings.h>
80  #elif !GTEST_OS_WINDOWS_MOBILE
81  # include <direct.h>
82  # include <io.h>
83  #endif
84  #if GTEST_OS_LINUX_ANDROID
85  #  include <android/api-level.h>  
86  #endif
87  #ifndef GTEST_HAS_POSIX_RE
88  # if GTEST_OS_LINUX_ANDROID
89  #  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)
90  # else
91  #  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)
92  # endif
93  #endif
94  #if GTEST_HAS_POSIX_RE
95  # include <regex.h>  
96  # define GTEST_USES_POSIX_RE 1
97  #elif GTEST_OS_WINDOWS
98  # define GTEST_USES_SIMPLE_RE 1
99  #else
100  # define GTEST_USES_SIMPLE_RE 1
101  #endif  
102  #ifndef GTEST_HAS_EXCEPTIONS
103  # if defined(_MSC_VER) || defined(__BORLANDC__)
104  #  ifndef _HAS_EXCEPTIONS
105  #   define _HAS_EXCEPTIONS 1
106  #  endif  
107  #  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS
108  # elif defined(__GNUC__) && __EXCEPTIONS
109  #  define GTEST_HAS_EXCEPTIONS 1
110  # elif defined(__SUNPRO_CC)
111  #  define GTEST_HAS_EXCEPTIONS 1
112  # elif defined(__IBMCPP__) && __EXCEPTIONS
113  #  define GTEST_HAS_EXCEPTIONS 1
114  # elif defined(__HP_aCC)
115  #  define GTEST_HAS_EXCEPTIONS 1
116  # else
117  #  define GTEST_HAS_EXCEPTIONS 0
118  # endif  
119  #endif  
120  #if !defined(GTEST_HAS_STD_STRING)
121  # define GTEST_HAS_STD_STRING 1
122  #elif !GTEST_HAS_STD_STRING
123  # error "Google Test cannot be used where ::std::string isn't available."
124  #endif  
125  #ifndef GTEST_HAS_GLOBAL_STRING
126  # define GTEST_HAS_GLOBAL_STRING 0
127  #endif  
128  #ifndef GTEST_HAS_STD_WSTRING
129  # define GTEST_HAS_STD_WSTRING \
130      (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS))
131  #endif  
132  #ifndef GTEST_HAS_GLOBAL_WSTRING
133  # define GTEST_HAS_GLOBAL_WSTRING \
134      (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)
135  #endif  
136  #ifndef GTEST_HAS_RTTI
137  # ifdef _MSC_VER
138  #  ifdef _CPPRTTI  
139  #   define GTEST_HAS_RTTI 1
140  #  else
141  #   define GTEST_HAS_RTTI 0
142  #  endif
143  # elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)
144  #  ifdef __GXX_RTTI
145  #   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \
146         !defined(__EXCEPTIONS)
147  #    define GTEST_HAS_RTTI 0
148  #   else
149  #    define GTEST_HAS_RTTI 1
150  #   endif  
151  #  else
152  #   define GTEST_HAS_RTTI 0
153  #  endif  
154  # elif defined(__clang__)
155  #  define GTEST_HAS_RTTI __has_feature(cxx_rtti)
156  # elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)
157  #  ifdef __RTTI_ALL__
158  #   define GTEST_HAS_RTTI 1
159  #  else
160  #   define GTEST_HAS_RTTI 0
161  #  endif
162  # else
163  #  define GTEST_HAS_RTTI 1
164  # endif  
165  #endif  
166  #if GTEST_HAS_RTTI
167  # include <typeinfo>
168  #endif
169  #ifndef GTEST_HAS_PTHREAD
170  # define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \
171      || GTEST_OS_QNX)
172  #endif  
173  #if GTEST_HAS_PTHREAD
174  # include <pthread.h>  
175  # include <time.h>  
176  #endif
177  #ifndef GTEST_HAS_TR1_TUPLE
178  # if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)
179  #  define GTEST_HAS_TR1_TUPLE 0
180  # else
181  #  define GTEST_HAS_TR1_TUPLE 1
182  # endif
183  #endif  
184  #ifndef GTEST_USE_OWN_TR1_TUPLE
185  # if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \
186        && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600
187  #  define GTEST_ENV_HAS_TR1_TUPLE_ 1
188  # endif
189  # if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)
190  #  define GTEST_ENV_HAS_STD_TUPLE_ 1
191  # endif
192  # if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_
193  #  define GTEST_USE_OWN_TR1_TUPLE 0
194  # else
195  #  define GTEST_USE_OWN_TR1_TUPLE 1
196  # endif
197  #endif  
198  #if GTEST_HAS_TR1_TUPLE
199  # if GTEST_USE_OWN_TR1_TUPLE
200  #  include "gtest/internal/gtest-tuple.h"
201  # elif GTEST_ENV_HAS_STD_TUPLE_
202  #  include <tuple>
203  namespace std {
204  namespace tr1 {
205  using ::std::get;
206  using ::std::make_tuple;
207  using ::std::tuple;
208  using ::std::tuple_element;
209  using ::std::tuple_size;
210  }
211  }
212  # elif GTEST_OS_SYMBIAN
213  #  ifdef BOOST_HAS_TR1_TUPLE
214  #   undef BOOST_HAS_TR1_TUPLE
215  #  endif  
216  #  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED
217  #  include <tuple>
218  # elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)
219  #  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302
220  #   define _TR1_FUNCTIONAL 1
221  #   include <tr1/tuple>
222  #   undef _TR1_FUNCTIONAL  
223  #  else
224  #   include <tr1/tuple>  
225  #  endif  
226  # else
227  #  include <tuple>  
228  # endif  
229  #endif  
230  #ifndef GTEST_HAS_CLONE
231  # if GTEST_OS_LINUX && !defined(__ia64__)
232  #  if GTEST_OS_LINUX_ANDROID
233  #    if defined(__arm__) && __ANDROID_API__ >= 9
234  #     define GTEST_HAS_CLONE 1
235  #    else
236  #     define GTEST_HAS_CLONE 0
237  #    endif
238  #  else
239  #   define GTEST_HAS_CLONE 1
240  #  endif
241  # else
242  #  define GTEST_HAS_CLONE 0
243  # endif  
244  #endif  
245  #ifndef GTEST_HAS_STREAM_REDIRECTION
246  # if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN
247  #  define GTEST_HAS_STREAM_REDIRECTION 0
248  # else
249  #  define GTEST_HAS_STREAM_REDIRECTION 1
250  # endif  
251  #endif  
252  #if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \
253       (GTEST_OS_MAC && !GTEST_OS_IOS) || GTEST_OS_IOS_SIMULATOR || \
254       (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \
255       GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \
256       GTEST_OS_OPENBSD || GTEST_OS_QNX)
257  # define GTEST_HAS_DEATH_TEST 1
258  # include <vector>  
259  #endif
260  #define GTEST_HAS_PARAM_TEST 1
261  #if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \
262      defined(__IBMCPP__) || defined(__HP_aCC)
263  # define GTEST_HAS_TYPED_TEST 1
264  # define GTEST_HAS_TYPED_TEST_P 1
265  #endif
266  #if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)
267  # define GTEST_HAS_COMBINE 1
268  #endif
269  #define GTEST_WIDE_STRING_USES_UTF16_ \
270      (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)
271  #if GTEST_OS_LINUX
272  # define GTEST_CAN_STREAM_RESULTS_ 1
273  #endif
274  #ifdef __INTEL_COMPILER
275  # define GTEST_AMBIGUOUS_ELSE_BLOCKER_
276  #else
277  # define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  
278  #endif
279  #if defined(__GNUC__) && !defined(COMPILER_ICC)
280  # define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))
281  #else
282  # define GTEST_ATTRIBUTE_UNUSED_
283  #endif
284  #define GTEST_DISALLOW_ASSIGN_(type)\
285    void operator=(type const &)
286  #define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\
287    type(type const &);\
288    GTEST_DISALLOW_ASSIGN_(type)
289  #if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)
290  # define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))
291  #else
292  # define GTEST_MUST_USE_RESULT_
293  #endif  
294  #ifndef GTEST_HAS_SEH
295  # if defined(_MSC_VER) || defined(__BORLANDC__)
296  #  define GTEST_HAS_SEH 1
297  # else
298  #  define GTEST_HAS_SEH 0
299  # endif
300  #endif  
301  #ifdef _MSC_VER
302  # if GTEST_LINKED_AS_SHARED_LIBRARY
303  #  define GTEST_API_ __declspec(dllimport)
304  # elif GTEST_CREATE_SHARED_LIBRARY
305  #  define GTEST_API_ __declspec(dllexport)
306  # endif
307  #endif  
308  #ifndef GTEST_API_
309  # define GTEST_API_
310  #endif
311  #ifdef __GNUC__
312  # define GTEST_NO_INLINE_ __attribute__((noinline))
313  #else
314  # define GTEST_NO_INLINE_
315  #endif
316  #if defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)
317  # define GTEST_HAS_CXXABI_H_ 1
318  #else
319  # define GTEST_HAS_CXXABI_H_ 0
320  #endif
321  namespace testing {
322  class Message;
323  namespace internal {
324  class Secret;
325  template <bool>
326  struct CompileAssert {
327  };
328  #define GTEST_COMPILE_ASSERT_(expr, msg) \
329    typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \
330        msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_
331  template <typename T1, typename T2>
332  struct StaticAssertTypeEqHelper;
333  template <typename T>
334  struct StaticAssertTypeEqHelper<T, T> {};
335  #if GTEST_HAS_GLOBAL_STRING
336  typedef ::string string;
337  #else
338  typedef ::std::string string;
339  #endif  
340  #if GTEST_HAS_GLOBAL_WSTRING
341  typedef ::wstring wstring;
342  #elif GTEST_HAS_STD_WSTRING
343  typedef ::std::wstring wstring;
344  #endif  
345  GTEST_API_ bool IsTrue(bool condition);
346  template <typename T>
347  class scoped_ptr {
348   public:
349    typedef T element_type;
350    explicit scoped_ptr(T* p = NULL) : ptr_(p) {}
<span onclick='openModal()' class='match'>351    ~scoped_ptr() { reset(); }
352    T& operator*() const { return *ptr_; }
353    T* operator->() const { return ptr_; }
354    T* get() const { return ptr_; }
</span>355    T* release() {
356      T* const ptr = ptr_;
357      ptr_ = NULL;
358      return ptr;
359    }
360    void reset(T* p = NULL) {
361      if (p != ptr_) {
362        if (IsTrue(sizeof(T) > 0)) {  
363          delete ptr_;
364        }
365        ptr_ = p;
366      }
367    }
368   private:
369    T* ptr_;
370    GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);
371  };
372  class GTEST_API_ RE {
373   public:
374    RE(const RE& other) { Init(other.pattern()); }
375    RE(const ::std::string& regex) { Init(regex.c_str()); }  
376  #if GTEST_HAS_GLOBAL_STRING
377    RE(const ::string& regex) { Init(regex.c_str()); }  
378  #endif  
379    RE(const char* regex) { Init(regex); }  
380    ~RE();
381    const char* pattern() const { return pattern_; }
382    static bool FullMatch(const ::std::string& str, const RE& re) {
383      return FullMatch(str.c_str(), re);
384    }
385    static bool PartialMatch(const ::std::string& str, const RE& re) {
386      return PartialMatch(str.c_str(), re);
387    }
388  #if GTEST_HAS_GLOBAL_STRING
389    static bool FullMatch(const ::string& str, const RE& re) {
390      return FullMatch(str.c_str(), re);
391    }
392    static bool PartialMatch(const ::string& str, const RE& re) {
393      return PartialMatch(str.c_str(), re);
394    }
395  #endif  
396    static bool FullMatch(const char* str, const RE& re);
397    static bool PartialMatch(const char* str, const RE& re);
398   private:
399    void Init(const char* regex);
400    const char* pattern_;
401    bool is_valid_;
402  #if GTEST_USES_POSIX_RE
403    regex_t full_regex_;     
404    regex_t partial_regex_;  
405  #else  
406    const char* full_pattern_;  
407  #endif
408    GTEST_DISALLOW_ASSIGN_(RE);
409  };
410  GTEST_API_ ::std::string FormatFileLocation(const char* file, int line);
411  GTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,
412                                                                 int line);
413  enum GTestLogSeverity {
414    GTEST_INFO,
415    GTEST_WARNING,
416    GTEST_ERROR,
417    GTEST_FATAL
418  };
419  class GTEST_API_ GTestLog {
420   public:
421    GTestLog(GTestLogSeverity severity, const char* file, int line);
422    ~GTestLog();
423    ::std::ostream& GetStream() { return ::std::cerr; }
424   private:
425    const GTestLogSeverity severity_;
426    GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);
427  };
428  #define GTEST_LOG_(severity) \
429      ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \
430                                    __FILE__, __LINE__).GetStream()
431  inline void LogToStderr() {}
432  inline void FlushInfoLog() { fflush(NULL); }
433  #define GTEST_CHECK_(condition) \
434      GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
435      if (::testing::internal::IsTrue(condition)) \
436        ; \
437      else \
438        GTEST_LOG_(FATAL) << "Condition " #condition " failed. "
439  #define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \
440    if (const int gtest_error = (posix_call)) \
441      GTEST_LOG_(FATAL) << #posix_call << "failed with error " \
442                        << gtest_error
443  template<typename To>
444  inline To ImplicitCast_(To x) { return x; }
445  template<typename To, typename From>  
446  inline To DownCast_(From* f) {  
447    if (false) {
448      const To to = NULL;
449      ::testing::internal::ImplicitCast_<From*>(to);
450    }
451  #if GTEST_HAS_RTTI
452    GTEST_CHECK_(f == NULL || dynamic_cast<To>(f) != NULL);
453  #endif
454    return static_cast<To>(f);
455  }
456  template <class Derived, class Base>
457  Derived* CheckedDowncastToActualType(Base* base) {
458  #if GTEST_HAS_RTTI
459    GTEST_CHECK_(typeid(*base) == typeid(Derived));
460    return dynamic_cast<Derived*>(base);  
461  #else
462    return static_cast<Derived*>(base);  
463  #endif
464  }
465  #if GTEST_HAS_STREAM_REDIRECTION
466  GTEST_API_ void CaptureStdout();
467  GTEST_API_ std::string GetCapturedStdout();
468  GTEST_API_ void CaptureStderr();
469  GTEST_API_ std::string GetCapturedStderr();
470  #endif  
471  #if GTEST_HAS_DEATH_TEST
472  const ::std::vector<testing::internal::string>& GetInjectableArgvs();
473  void SetInjectableArgvs(const ::std::vector<testing::internal::string>*
474                               new_argvs);
475  extern ::std::vector<testing::internal::string> g_argvs;
476  #endif  
477  #if GTEST_HAS_PTHREAD
478  inline void SleepMilliseconds(int n) {
479    const timespec time = {
480      0,                  
481      n * 1000L * 1000L,  
482    };
483    nanosleep(&time, NULL);
484  }
485  class Notification {
486   public:
487    Notification() : notified_(false) {
488      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));
489    }
490    ~Notification() {
491      pthread_mutex_destroy(&mutex_);
492    }
493    void Notify() {
494      pthread_mutex_lock(&mutex_);
495      notified_ = true;
496      pthread_mutex_unlock(&mutex_);
497    }
498    void WaitForNotification() {
499      for (;;) {
500        pthread_mutex_lock(&mutex_);
501        const bool notified = notified_;
502        pthread_mutex_unlock(&mutex_);
503        if (notified)
504          break;
505        SleepMilliseconds(10);
506      }
507    }
508   private:
509    pthread_mutex_t mutex_;
510    bool notified_;
511    GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);
512  };
513  class ThreadWithParamBase {
514   public:
515    virtual ~ThreadWithParamBase() {}
516    virtual void Run() = 0;
517  };
518  extern "C" inline void* ThreadFuncWithCLinkage(void* thread) {
519    static_cast<ThreadWithParamBase*>(thread)->Run();
520    return NULL;
521  }
522  template <typename T>
523  class ThreadWithParam : public ThreadWithParamBase {
524   public:
525    typedef void (*UserThreadFunc)(T);
526    ThreadWithParam(
527        UserThreadFunc func, T param, Notification* thread_can_start)
528        : func_(func),
529          param_(param),
530          thread_can_start_(thread_can_start),
531          finished_(false) {
532      ThreadWithParamBase* const base = this;
533      GTEST_CHECK_POSIX_SUCCESS_(
534          pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));
535    }
536    ~ThreadWithParam() { Join(); }
537    void Join() {
538      if (!finished_) {
539        GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));
540        finished_ = true;
541      }
542    }
543    virtual void Run() {
544      if (thread_can_start_ != NULL)
545        thread_can_start_->WaitForNotification();
546      func_(param_);
547    }
548   private:
549    const UserThreadFunc func_;  
550    const T param_;  
551    Notification* const thread_can_start_;
552    bool finished_;  
553    pthread_t thread_;  
554    GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);
555  };
556  class MutexBase {
557   public:
558    void Lock() {
559      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));
560      owner_ = pthread_self();
561      has_owner_ = true;
562    }
563    void Unlock() {
564      has_owner_ = false;
565      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));
566    }
567    void AssertHeld() const {
568      GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))
569          << "The current thread is not holding the mutex @" << this;
570    }
571   public:
572    pthread_mutex_t mutex_;  
573    bool has_owner_;
574    pthread_t owner_;  
575  };
576  # define GTEST_DECLARE_STATIC_MUTEX_(mutex) \
577      extern ::testing::internal::MutexBase mutex
578  # define GTEST_DEFINE_STATIC_MUTEX_(mutex) \
579      ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false }
580  class Mutex : public MutexBase {
581   public:
582    Mutex() {
583      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));
584      has_owner_ = false;
585    }
586    ~Mutex() {
587      GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));
588    }
589   private:
590    GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);
591  };
592  class GTestMutexLock {
593   public:
594    explicit GTestMutexLock(MutexBase* mutex)
595        : mutex_(mutex) { mutex_->Lock(); }
596    ~GTestMutexLock() { mutex_->Unlock(); }
597   private:
598    MutexBase* const mutex_;
599    GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);
600  };
601  typedef GTestMutexLock MutexLock;
602  class ThreadLocalValueHolderBase {
603   public:
604    virtual ~ThreadLocalValueHolderBase() {}
605  };
606  extern "C" inline void DeleteThreadLocalValue(void* value_holder) {
607    delete static_cast<ThreadLocalValueHolderBase*>(value_holder);
608  }
609  template <typename T>
610  class ThreadLocal {
611   public:
612    ThreadLocal() : key_(CreateKey()),
613                    default_() {}
614    explicit ThreadLocal(const T& value) : key_(CreateKey()),
615                                           default_(value) {}
616    ~ThreadLocal() {
617      DeleteThreadLocalValue(pthread_getspecific(key_));
618      GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));
619    }
620    T* pointer() { return GetOrCreateValue(); }
621    const T* pointer() const { return GetOrCreateValue(); }
622    const T& get() const { return *pointer(); }
623    void set(const T& value) { *pointer() = value; }
624   private:
625    class ValueHolder : public ThreadLocalValueHolderBase {
626     public:
627      explicit ValueHolder(const T& value) : value_(value) {}
628      T* pointer() { return &value_; }
629     private:
630      T value_;
631      GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);
632    };
633    static pthread_key_t CreateKey() {
634      pthread_key_t key;
635      GTEST_CHECK_POSIX_SUCCESS_(
636          pthread_key_create(&key, &DeleteThreadLocalValue));
637      return key;
638    }
639    T* GetOrCreateValue() const {
640      ThreadLocalValueHolderBase* const holder =
641          static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));
642      if (holder != NULL) {
643        return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();
644      }
645      ValueHolder* const new_holder = new ValueHolder(default_);
646      ThreadLocalValueHolderBase* const holder_base = new_holder;
647      GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));
648      return new_holder->pointer();
649    }
650    const pthread_key_t key_;
651    const T default_;  
652    GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);
653  };
654  # define GTEST_IS_THREADSAFE 1
655  #else  
656  class Mutex {
657   public:
658    Mutex() {}
659    void Lock() {}
660    void Unlock() {}
661    void AssertHeld() const {}
662  };
663  # define GTEST_DECLARE_STATIC_MUTEX_(mutex) \
664    extern ::testing::internal::Mutex mutex
665  # define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex
666  class GTestMutexLock {
667   public:
668    explicit GTestMutexLock(Mutex*) {}  
669  };
670  typedef GTestMutexLock MutexLock;
671  template <typename T>
672  class ThreadLocal {
673   public:
674    ThreadLocal() : value_() {}
675    explicit ThreadLocal(const T& value) : value_(value) {}
676    T* pointer() { return &value_; }
677    const T* pointer() const { return &value_; }
678    const T& get() const { return value_; }
679    void set(const T& value) { value_ = value; }
680   private:
681    T value_;
682  };
683  # define GTEST_IS_THREADSAFE 0
684  #endif  
685  GTEST_API_ size_t GetThreadCount();
686  #if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)
687  # define GTEST_ELLIPSIS_NEEDS_POD_ 1
688  #else
689  # define GTEST_CAN_COMPARE_NULL 1
690  #endif
691  #if defined(__SYMBIAN32__) || defined(__IBMCPP__)
692  # define GTEST_NEEDS_IS_POINTER_ 1
693  #endif
694  template <bool bool_value>
695  struct bool_constant {
696    typedef bool_constant<bool_value> type;
697    static const bool value = bool_value;
698  };
699  template <bool bool_value> const bool bool_constant<bool_value>::value;
700  typedef bool_constant<false> false_type;
701  typedef bool_constant<true> true_type;
702  template <typename T>
703  struct is_pointer : public false_type {};
704  template <typename T>
705  struct is_pointer<T*> : public true_type {};
706  template <typename Iterator>
707  struct IteratorTraits {
708    typedef typename Iterator::value_type value_type;
709  };
710  template <typename T>
711  struct IteratorTraits<T*> {
712    typedef T value_type;
713  };
714  template <typename T>
715  struct IteratorTraits<const T*> {
716    typedef T value_type;
717  };
718  #if GTEST_OS_WINDOWS
719  # define GTEST_PATH_SEP_ "\\"
720  # define GTEST_HAS_ALT_PATH_SEP_ 1
721  typedef __int64 BiggestInt;
722  #else
723  # define GTEST_PATH_SEP_ "/"
724  # define GTEST_HAS_ALT_PATH_SEP_ 0
725  typedef long long BiggestInt;  
726  #endif  
727  inline bool IsAlpha(char ch) {
728    return isalpha(static_cast<unsigned char>(ch)) != 0;
729  }
730  inline bool IsAlNum(char ch) {
731    return isalnum(static_cast<unsigned char>(ch)) != 0;
732  }
733  inline bool IsDigit(char ch) {
734    return isdigit(static_cast<unsigned char>(ch)) != 0;
735  }
736  inline bool IsLower(char ch) {
737    return islower(static_cast<unsigned char>(ch)) != 0;
738  }
739  inline bool IsSpace(char ch) {
740    return isspace(static_cast<unsigned char>(ch)) != 0;
741  }
742  inline bool IsUpper(char ch) {
743    return isupper(static_cast<unsigned char>(ch)) != 0;
744  }
745  inline bool IsXDigit(char ch) {
746    return isxdigit(static_cast<unsigned char>(ch)) != 0;
747  }
748  inline bool IsXDigit(wchar_t ch) {
749    const unsigned char low_byte = static_cast<unsigned char>(ch);
750    return ch == low_byte && isxdigit(low_byte) != 0;
751  }
752  inline char ToLower(char ch) {
753    return static_cast<char>(tolower(static_cast<unsigned char>(ch)));
754  }
755  inline char ToUpper(char ch) {
756    return static_cast<char>(toupper(static_cast<unsigned char>(ch)));
757  }
758  namespace posix {
759  #if GTEST_OS_WINDOWS
760  typedef struct _stat StatStruct;
761  # ifdef __BORLANDC__
762  inline int IsATTY(int fd) { return isatty(fd); }
763  inline int StrCaseCmp(const char* s1, const char* s2) {
764    return stricmp(s1, s2);
765  }
766  inline char* StrDup(const char* src) { return strdup(src); }
767  # else  
768  #  if GTEST_OS_WINDOWS_MOBILE
769  inline int IsATTY(int &bsol;* fd */) { return 0; }
770  #  else
771  inline int IsATTY(int fd) { return _isatty(fd); }
772  #  endif  
773  inline int StrCaseCmp(const char* s1, const char* s2) {
774    return _stricmp(s1, s2);
775  }
776  inline char* StrDup(const char* src) { return _strdup(src); }
777  # endif  
778  # if GTEST_OS_WINDOWS_MOBILE
779  inline int FileNo(FILE* file) { return reinterpret_cast<int>(_fileno(file)); }
780  # else
781  inline int FileNo(FILE* file) { return _fileno(file); }
782  inline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }
783  inline int RmDir(const char* dir) { return _rmdir(dir); }
784  inline bool IsDir(const StatStruct& st) {
785    return (_S_IFDIR & st.st_mode) != 0;
786  }
787  # endif  
788  #else
789  typedef struct stat StatStruct;
790  inline int FileNo(FILE* file) { return fileno(file); }
791  inline int IsATTY(int fd) { return isatty(fd); }
792  inline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }
793  inline int StrCaseCmp(const char* s1, const char* s2) {
794    return strcasecmp(s1, s2);
795  }
796  inline char* StrDup(const char* src) { return strdup(src); }
797  inline int RmDir(const char* dir) { return rmdir(dir); }
798  inline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }
799  #endif  
800  #ifdef _MSC_VER
801  # pragma warning(push)
802  # pragma warning(disable:4996)
803  #endif
804  inline const char* StrNCpy(char* dest, const char* src, size_t n) {
805    return strncpy(dest, src, n);
806  }
807  #if !GTEST_OS_WINDOWS_MOBILE
808  inline int ChDir(const char* dir) { return chdir(dir); }
809  #endif
810  inline FILE* FOpen(const char* path, const char* mode) {
811    return fopen(path, mode);
812  }
813  #if !GTEST_OS_WINDOWS_MOBILE
814  inline FILE *FReopen(const char* path, const char* mode, FILE* stream) {
815    return freopen(path, mode, stream);
816  }
817  inline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }
818  #endif
819  inline int FClose(FILE* fp) { return fclose(fp); }
820  #if !GTEST_OS_WINDOWS_MOBILE
821  inline int Read(int fd, void* buf, unsigned int count) {
822    return static_cast<int>(read(fd, buf, count));
823  }
824  inline int Write(int fd, const void* buf, unsigned int count) {
825    return static_cast<int>(write(fd, buf, count));
826  }
827  inline int Close(int fd) { return close(fd); }
828  inline const char* StrError(int errnum) { return strerror(errnum); }
829  #endif
830  inline const char* GetEnv(const char* name) {
831  #if GTEST_OS_WINDOWS_MOBILE
832    return NULL;
833  #elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)
834    const char* const env = getenv(name);
835    return (env != NULL && env[0] != '\0') ? env : NULL;
836  #else
837    return getenv(name);
838  #endif
839  }
840  #ifdef _MSC_VER
841  # pragma warning(pop)  
842  #endif
843  #if GTEST_OS_WINDOWS_MOBILE
844  void Abort();
845  #else
846  inline void Abort() { abort(); }
847  #endif  
848  }  
849  #if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE
850  # define GTEST_SNPRINTF_(buffer, size, format, ...) \
851       _snprintf_s(buffer, size, size, format, __VA_ARGS__)
852  #elif defined(_MSC_VER)
853  # define GTEST_SNPRINTF_ _snprintf
854  #else
855  # define GTEST_SNPRINTF_ snprintf
856  #endif
857  const BiggestInt kMaxBiggestInt =
858      ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));
859  template <size_t size>
860  class TypeWithSize {
861   public:
862    typedef void UInt;
863  };
864  template <>
865  class TypeWithSize<4> {
866   public:
867    typedef int Int;
868    typedef unsigned int UInt;
869  };
870  template <>
871  class TypeWithSize<8> {
872   public:
873  #if GTEST_OS_WINDOWS
874    typedef __int64 Int;
875    typedef unsigned __int64 UInt;
876  #else
877    typedef long long Int;  
878    typedef unsigned long long UInt;  
879  #endif  
880  };
881  typedef TypeWithSize<4>::Int Int32;
882  typedef TypeWithSize<4>::UInt UInt32;
883  typedef TypeWithSize<8>::Int Int64;
884  typedef TypeWithSize<8>::UInt UInt64;
885  typedef TypeWithSize<8>::Int TimeInMillis;  
886  #define GTEST_FLAG(name) FLAGS_gtest_##name
887  #define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)
888  #define GTEST_DECLARE_int32_(name) \
889      GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)
890  #define GTEST_DECLARE_string_(name) \
891      GTEST_API_ extern ::std::string GTEST_FLAG(name)
892  #define GTEST_DEFINE_bool_(name, default_val, doc) \
893      GTEST_API_ bool GTEST_FLAG(name) = (default_val)
894  #define GTEST_DEFINE_int32_(name, default_val, doc) \
895      GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)
896  #define GTEST_DEFINE_string_(name, default_val, doc) \
897      GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)
898  #define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)
899  #define GTEST_LOCK_EXCLUDED_(locks)
900  bool ParseInt32(const Message& src_text, const char* str, Int32* value);
901  bool BoolFromGTestEnv(const char* flag, bool default_val);
902  GTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);
903  const char* StringFromGTestEnv(const char* flag, const char* default_val);
904  }  
905  }  
906  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tbhc.h</h3>
            <pre><code>1  #ifndef TbHc_h
2  #define TbHc_h
3  #include "base.h"
4  #include "tb.h"
5  #include "hc.h"
6  class THTbVar: public TTbVar{
7  private:
8    TStr Nm;
9    PTbVarType VarType;
10  public:
11    THTbVar(const TStr& _Nm, const PTbVarType& _VarType):
12      TTbVar(), Nm(_Nm), VarType(_VarType){}
13    THTbVar(TSIn& SIn): TTbVar(SIn), Nm(SIn){}
14    void Save(TSOut& SOut){TTbVar::Save(SOut); Nm.Save(SOut);}
15    THTbVar& operator=(const THTbVar& HTbVar){
<span onclick='openModal()' class='match'>16      TTbVar::operator=(HTbVar); Nm=HTbVar.Nm; VarType=HTbVar.VarType; return *this;}
17    TStr GetNm() const {return Nm;}
18    PTbVarType GetVarType() const {return VarType;}
19    TB32Set GetActVTSet() const {return VarType->GetAlwVTSet();}
</span>20    void DefVarType(){Fail;}
21    TTbVal GetDscVal(const TStr& Str){return VarType->GetDscVal(Str);}
22    TTbVal GetDscVal(const int& Dsc){return VarType->GetDscVal(Dsc);}
23    TTbVal GetFltVal(const double& Flt){return VarType->GetFltVal(Flt);}
24    TTbVal GetVal(const TTbVal& Val){return VarType->GetVal(Val);}
25  };
26  class THTb: public TTb{
27  protected:
28    PHcBase HcBase;
29    TIntV VarNToWordIdV, WordIdToVarNV;
30    TIntV TupNToDocIdV, DocIdToTupNV;
31  public:
32    THTb(const PHcBase& _HcBase);
33    THTb(TSIn& SIn):
34      TTb(SIn), HcBase(SIn),
35      VarNToWordIdV(SIn), WordIdToVarNV(SIn),
36      TupNToDocIdV(SIn), DocIdToTupNV(SIn){}
37    void Save(TSOut& SOut){
38      TTb::Save(SOut); HcBase.Save(SOut);
39      VarNToWordIdV.Save(SOut); WordIdToVarNV.Save(SOut);
40      TupNToDocIdV.Save(SOut); DocIdToTupNV.Save(SOut);}
41    int AddVar(const PTbVar&){Fail; return -1;}
42    void DefVarTypes(){Fail;}
43    int GetVars(){return VarNToWordIdV.Len();}
44    int GetVarN(const TStr& Nm){return WordIdToVarNV[HcBase->GetWordId(Nm)];}
45    int AddTup(const TStr&){Fail; return -1;}
46    int GetTups(){return TupNToDocIdV.Len();}
47    TStr GetTupNm(const int& TupN){return HcBase->GetDocNm(TupNToDocIdV[TupN]);}
48    int GetTupN(const TStr& Nm){return DocIdToTupNV[HcBase->GetWordId&bsol;**/(Nm)];}
49    void PutDsc(const int&, const int&, const TStr&){Fail;}
50    void PutDsc(const int&, const int&, const int&){Fail;}
51    void PutFlt(const int&, const int&, const double&){Fail;}
52    void PutVal(const int&, const int&, const TTbVal&){Fail;}
53    TStr GetValStr(const int& TupN, const int& VarN){
54      return GetVal(TupN, VarN).GetStr();}
55  };
56  class THBTb: public THTb{
57  private:
58    TVec<PBSet> TupV;
59  public:
60    THBTb(const PHcBase& _HcBase);
61    THBTb(TSIn& SIn): THTb(SIn), TupV(SIn){SIn.LoadCs();}
62    void Save(TSOut& SOut){THTb::Save(SOut); TupV.Save(SOut); SOut.SaveCs();}
63    PTbVar GetVar(const int& VarN){
64      return new THTbVar(HcBase->GetWordStr&bsol;**/(VarN), TTbVarType::GetDscBoolVarType());}
65    TTbVal GetVal(const int& TupN, const int& VarN){
66      return TTbVal(TupV[TupN]->In(VarN));}
67  };
68  class THSTb: public THTb{
69  private:
70    TVec<TIntV> TupV;
71  public:
72    THSTb(const PHcBase& _HcBase);
73    THSTb(TSIn& SIn): THTb(SIn), TupV(SIn){SIn.LoadCs();}
74    void Save(TSOut& SOut){THTb::Save(SOut); TupV.Save(SOut); SOut.SaveCs();}
75    PTbVar GetVar(const int& VarN){
76      return new THTbVar(HcBase->GetWordStr&bsol;**/(VarN), TTbVarType::GetFltVarType());}
77    TTbVal GetVal(const int& TupN, const int& VarN){
78      return TTbVal(TupV[TupN].SearchBin(VarNToWordIdV[VarN])!=-1);}
79  };
80  class THFTb: public THTb{
81  private:
82    TVec<TVec<TIntPr> > TupV;
83  public:
84    THFTb(const PHcBase& _HcBase);
85    THFTb(TSIn& SIn): THTb(SIn), TupV(SIn){SIn.LoadCs();}
86    void Save(TSOut& SOut){THTb::Save(SOut); TupV.Save(SOut); SOut.SaveCs();}
87    PTbVar GetVar(const int& VarN){
88      return new THTbVar(HcBase->GetWordStr&bsol;**/(VarN), TTbVarType::GetFltVarType());}
89    TTbVal GetVal(const int& TupN, const int& VarN){
90      int WordOccN=TupV[TupN].SearchBin(TIntPr(VarNToWordIdV[VarN], TInt(-1)));
91      if (WordOccN==-1){return TTbVal((double)0);}
92      else {return TTbVal((double)TupV[TupN][WordOccN].Val2);}}
93  };
94  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-port.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tbhc.h</div>
                </div>
                <div class="column column_space"><pre><code>351    ~scoped_ptr() { reset(); }
352    T& operator*() const { return *ptr_; }
353    T* operator->() const { return ptr_; }
354    T* get() const { return ptr_; }
</pre></code></div>
                <div class="column column_space"><pre><code>16      TTbVar::operator=(HTbVar); Nm=HTbVar.Nm; VarType=HTbVar.VarType; return *this;}
17    TStr GetNm() const {return Nm;}
18    PTbVarType GetVarType() const {return VarType;}
19    TB32Set GetActVTSet() const {return VarType->GetAlwVTSet();}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    