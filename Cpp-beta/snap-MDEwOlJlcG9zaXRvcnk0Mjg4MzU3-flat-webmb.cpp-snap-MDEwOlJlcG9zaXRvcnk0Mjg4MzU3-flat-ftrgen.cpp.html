
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.640878701050621%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webmb.cpp</h3>
            <pre><code>1  #include "webmb.h"
2  #include "webold.h"
3  const TStr TWebMemBs::WebMemBsFNm="WebMemBs.Txt";
4  const int TWebMemBs::ExpectedWebPgs=10000;
5  void TWebMemBs::OnSave(const int& WebPgId, const PXWebPg& WebPg){
6    for (int UrlStrN=0; UrlStrN<WebPg->GetUrls(); UrlStrN++){
7      TStr UrlStr=WebPg->GetUrlStr(UrlStrN);
8      if (IsWebPg(UrlStr)){
9        int PrevWebPgId=UrlStrToWebPgIdH.GetDat(UrlStr);
10        TStrV PrevUrlStrV=WebPgIdToUrlStrVH.GetDat(PrevWebPgId);
11        for (int UrlStrN=0; UrlStrN<PrevUrlStrV.Len(); UrlStrN++){
12          UrlStrToWebPgIdH.DelKey(PrevUrlStrV[UrlStrN]);}
13        WebPgIdToUrlStrVH.DelKey(PrevWebPgId);
14        if (WebPgIdToRefUrlStrVH.IsKey(PrevWebPgId)){
15          WebPgIdToRefUrlStrVH.DelKey(PrevWebPgId);}
16        TFile::Del(GetWebPgFNm(PrevWebPgId));
17      }
18    }
19    {for (int UrlStrN=0; UrlStrN<WebPg->GetUrls(); UrlStrN++){
20      UrlStrToWebPgIdH.AddDat(WebPg->GetUrlStr(UrlStrN), WebPgId);}}
21    WebPgIdToUrlStrVH.AddDat(WebPgId, WebPg->GetUrlStrV());
22    if (IsGenRef()){
23      WebPgIdToRefUrlStrVH.AddDat(WebPgId, WebPg->GetRefUrlStrV());}
24    PSOut SOut=new TFOut(GetWebPgFNm(WebPgId));
25    WebPg->SaveTxt(SOut);
26    Modified=true;
<span onclick='openModal()' class='match'>27    if (GetWebPgs()%1000==0){SaveTxt();}
28  }
29  void TWebMemBs::OnFetch(const int& WebPgId, const PXWebPg& WebPg){
30    bool DoSave;
</span>31    OnWebPg(WebPgId, WebPg, DoSave);
32    if (DoSave){OnSave(WebPgId, WebPg);}
33    if (IsCheckMode()){
34      for (int UrlStrN=0; UrlStrN<WebPg->GetUrls(); UrlStrN++){
35        TStr UrlStr=WebPg->GetUrlStr(UrlStrN);
36        CheckedUrlStrToWebPgIdH.AddDat(UrlStr, WebPgId);
37      }
38    }
39  }
40  TWebMemBs::TWebMemBs(const TStr& _FPath, const bool& _CheckMode):
41    TXWebBs(_FPath, _CheckMode),
42    UrlStrToWebPgIdH(ExpectedWebPgs),
43    CheckedUrlStrToWebPgIdH(IsCheckMode()?ExpectedWebPgs:0),
44    WebPgIdToUrlStrVH(ExpectedWebPgs),
45    WebPgIdToRefUrlStrVH(ExpectedWebPgs),
46    Modified(false){
47    PSIn SIn=new TFIn(GetFPath()+WebMemBsFNm);
48    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum);
49    while (Lx.GetSym(syInt, syEof)==syInt){
50      int WebPgId=Lx.Int;
51      Lx.GetSym(syColon);
52      while (Lx.GetSym(syQStr, sySemicolon)==syQStr){
53        UrlStrToWebPgIdH.AddDat(Lx.Str, WebPgId);
54        WebPgIdToUrlStrVH.AddDat(WebPgId).Add(Lx.Str);
55      }
56      WebPgIdToRefUrlStrVH.AddKey(WebPgId);
57      while (Lx.GetSym(syQStr, syEoln)==syQStr){
58        WebPgIdToRefUrlStrVH.GetDat(WebPgId).AddMerged(Lx.Str);
59      }
60    }
61  }
62  void TWebMemBs::SaveTxt(){
63    TXWebBs::SaveTxt();
64    PSOut SOut=new TFOut(GetFPath()+WebMemBsFNm);
65    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
66    int WebPgIdToUrlStrVP=WebPgIdToUrlStrVH.FFirstKeyId();
67    while (WebPgIdToUrlStrVH.FNextKeyId(WebPgIdToUrlStrVP)){
68      int WebPgId=WebPgIdToUrlStrVH.GetKey(WebPgIdToUrlStrVP);
69      TStrV UrlStrV=WebPgIdToUrlStrVH.GetDat(WebPgId);
70      TStrV RefUrlStrV;
71      if (WebPgIdToRefUrlStrVH.IsKey(WebPgId)){
72        RefUrlStrV=WebPgIdToRefUrlStrVH.GetDat(WebPgId);}
73      Lx.PutInt(WebPgId); Lx.PutSym(syColon);
74      for (int UrlStrN=0; UrlStrN<UrlStrV.Len(); UrlStrN++){
75        Lx.PutQStr(UrlStrV[UrlStrN]);}
76      Lx.PutSym(sySemicolon);
77      for (int RefUrlStrN=0; RefUrlStrN<RefUrlStrV.Len(); RefUrlStrN++){
78        Lx.PutQStr(RefUrlStrV[RefUrlStrN]);}
79      Lx.PutLn();
80    }
81  }
82  int TWebMemBs::AddWebPg(const TStr& RelUrlStr, const TStr& BaseUrlStr){
83    PUrl Url=new TUrl(RelUrlStr, BaseUrlStr);
84    if (Url->IsOk(usHttp)){
85      if (IsWebPg(Url->GetUrlStr(), IsCheckMode())){
86        AddWebPgRef(Url->GetUrlStr(), BaseUrlStr); return -1;
87      } else {
88        return FetchWebPg(RelUrlStr, BaseUrlStr);
89      }
90    } else {
91      TStr ErrStr=TStr("Invalid URL [")+RelUrlStr+"] + ["+BaseUrlStr+"]";
92      OnError(-1, ErrStr);
93      return -1;
94    }
95  }
96  bool TWebMemBs::IsWebPg(const TStr& UrlStr){
97    return UrlStrToWebPgIdH.IsKey(UrlStr);
98  }
99  bool TWebMemBs::IsWebPg(const TStr& UrlStr, const bool& Check){
100    if (Check){return CheckedUrlStrToWebPgIdH.IsKey(UrlStr);}
101    else {return IsWebPg(UrlStr);}
102  }
103  PXWebPg TWebMemBs::GetWebPg(const int& WebPgId){
104    TStrV UrlStrV=WebPgIdToUrlStrVH.GetDat(WebPgId);
105    TStrV RefUrlStrV;
106    if (WebPgIdToRefUrlStrVH.IsKey(WebPgId)){
107      RefUrlStrV=WebPgIdToRefUrlStrVH.GetDat(WebPgId);}
108    PSIn SIn=new TFIn(GetWebPgFNm(WebPgId));
109    return TXWebPg::LoadTxt(SIn, UrlStrV, RefUrlStrV);
110  }
111  PXWebPg TWebMemBs::GetWebPg(const TStr& UrlStr){
112    int WebPgId=UrlStrToWebPgIdH.GetDat(UrlStr);
113    return GetWebPg(WebPgId);
114  }
115  void TWebMemBs::AddWebPgRef(const TStr& UrlStr, const TStr& RefUrlStr){
116    if (IsGenRef()){
117      int WebPgId=UrlStrToWebPgIdH.GetDat(UrlStr);
118      PUrl RefUrl=new TUrl(RefUrlStr); IAssert(RefUrl->IsOk(usHttp));
119      WebPgIdToRefUrlStrVH.GetDat(WebPgId).AddMerged(RefUrl->GetUrlStr());
120      Modified=true;
121    }
122  }
123  bool TWebMemBs::DoStillFetchUrl(const TStr& UrlStr){
124    if (IsCheckMode()){
125      return !CheckedUrlStrToWebPgIdH.IsKey(UrlStr);
126    } else {
127      return !UrlStrToWebPgIdH.IsKey(UrlStr);
128    }
129  }
130  bool TWebMemBs::DoFetchRedirUrl(const PUrl& RedirUrl, const TUrlV& UrlV){
131    TStr RedirUrlStr=RedirUrl->GetUrlStr();
132    if (UrlStrToWebPgIdH.IsKey(RedirUrlStr)){
133      int WebPgId=UrlStrToWebPgIdH.GetDat(RedirUrlStr);
134      for (int UrlN=0; UrlN<UrlV.Len(); UrlN++){
135        TStr UrlStr=UrlV[UrlN]->GetUrlStr();
136        UrlStrToWebPgIdH.AddDat(UrlStr, WebPgId);
137        WebPgIdToUrlStrVH.GetDat(WebPgId).AddMerged(UrlStr);
138      }
139      return false;
140    } else {
141      return true;
142    }
143  }
144  int TWebMemBs::FFirstWebPg(){
145    return WebPgIdToUrlStrVH.FFirstKeyId();
146  }
147  bool TWebMemBs::FNextWebPg(int& WebPgP, int& WebPgId){
148    if (WebPgIdToUrlStrVH.FNextKeyId(WebPgP)){
149      WebPgId=WebPgIdToUrlStrVH.GetKey(WebPgP);
150      return true;
151    } else {
152      return false;
153    }
154  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ftrgen.cpp</h3>
            <pre><code>1  THash<TStr, TFtrGen::TFtrGenLoadF> TFtrGen::TypeToLoadFH;
2  bool TFtrGen::Reg(const TStr& TypeNm, const TFtrGenLoadF& LoadF){
3  	IAssert(!TypeToLoadFH.IsKey(TypeNm));
4  	TypeToLoadFH.AddDat(TypeNm, LoadF);
5  	return true;
6  }
7  PFtrGen TFtrGen::Load(TSIn& SIn) {
8  	TStr TypeNm(SIn);
9  	int TypeKeyId = -1;
10  	if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
11  		TFtrGenLoadF LoadF = TypeToLoadFH[TypeKeyId];
12  		return (*LoadF())(SIn);
13  	} else {
14  		TExcept::Throw("Unknown feature generator " + TypeNm);
15  		return NULL;
16  	}
17  }
18  void TFtrGen::AddWds(const TStr& Prefix, 
19          const PBowDocBs& BowDocBs, int& Offset) const {
20      const int Vals = GetVals();
21      for (int ValN = 0; ValN < Vals; ValN++) {
22          const int WId = BowDocBs->AddWordStr(
23              TStr::Fmt("%s-%s", Prefix.CStr(), GetVal(ValN).CStr()));
24          IAssert(Offset == WId); Offset++;
25      }
26  }
27  bool TFtrGenNumeric::IsReg = TFtrGenNumeric::MkReg();
28  double TFtrGenNumeric::Trans(const double& Val) const { 
29          return MnVal != MxVal ? (double(Val) - MnVal) / (MxVal - MnVal) : 0.0; 
30  }
31  double TFtrGenNumeric::GetFlt(const TStr& Str) const {
32      double Val = 0.0;
33      if (!Str.IsFlt(Val)) { 
34          TExcept::Throw(TStr::Fmt("Number expected  but '%s' found!", Str.CStr())); }
35      return Val;
36  }
37  void TFtrGenNumeric::Update(const TStr& Val) { 
38      double Flt = GetFlt(Val);
39      MnVal = TFlt::GetMn(MnVal, Flt); 
40      MxVal = TFlt::GetMx(MxVal, Flt); 
41  }
42  void TFtrGenNumeric::Add(
43          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
44      double Flt = GetFlt(Val);
45      SpV.Add(TIntFltKd(Offset, Trans(Flt))); 
46      Offset++; 
47  }
48  bool TFtrGenNominal::IsReg = TFtrGenNominal::MkReg();
49  void TFtrGenNominal::Update(const TStr& Val) { 
<span onclick='openModal()' class='match'>50      if (!Val.Empty()) { ValH.AddKey(Val); }
51  }
52  void TFtrGenNominal::Add(
53          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
</span>54      if (ValH.IsKey(Val)) { 
55          SpV.Add(TIntFltKd(Offset + ValH.GetKeyId(Val), 1.0)); 
56      } 
57      Offset += ValH.Len(); 
58  }
59  bool TFtrGenToken::IsReg = TFtrGenToken::MkReg();
60  void TFtrGenToken::GetTokenV(const TStr& Str, TStrV& TokenStrV) const {
61      THtmlLx HtmlLx(TStrIn::New(Str));
62      while (HtmlLx.Sym != hsyEof){
63          if (HtmlLx.Sym == hsyStr){ 
64              TStr TokenStr = HtmlLx.UcChA;
65              if (SwSet.Empty() || !SwSet->IsIn(TokenStr)) { 
66                  if (!Stemmer.Empty()) { 
67                      TokenStr = Stemmer->GetStem(TokenStr); } 
68                  TokenStrV.Add(TokenStr);
69              }
70          }
71          HtmlLx.GetSym();
72      }
73  }
74  TFtrGenToken::TFtrGenToken(TSIn& SIn): TFtrGen(SIn) { 
75  	SwSet = PSwSet(SIn);
76  	Stemmer = PStemmer(SIn);
77  	Docs.Load(SIn);
78  	TokenH.Load(SIn);
79  }
80  void TFtrGenToken::Save(TSOut& SOut) const { 
81  	TFtrGen::Save(SOut);
82  	SwSet.Save(SOut);
83  	Stemmer.Save(SOut);
84  	Docs.Save(SOut);
85  	TokenH.Save(SOut);
86  }
87  void TFtrGenToken::Update(const TStr& Val) {
88      TStrV TokenStrV; GetTokenV(Val, TokenStrV); TStrH TokenStrH;
89      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
90          const TStr& TokenStr = TokenStrV[TokenStrN];
91          TokenStrH.AddKey(TokenStr);
92      }
93      int KeyId = TokenStrH.FFirstKeyId();
94      while (TokenStrH.FNextKeyId(KeyId)) {
95          const TStr& TokenStr = TokenStrH.GetKey(KeyId);
96          TokenH.AddDat(TokenStr)++;
97      }
98      Docs++;
99  }
100  void TFtrGenToken::Add(const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
101      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
102      TIntH TokenFqH;
103      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
104          const TStr& TokenStr = TokenStrV[TokenStrN];
105          if (TokenH.IsKey(TokenStr)) { 
106              const int TokenId = TokenH.GetKeyId(TokenStr);
107              TokenFqH.AddDat(TokenId)++;
108          }
109      }
110      TIntFltKdV ValSpV(TokenFqH.Len(), 0);
111      int KeyId = TokenFqH.FFirstKeyId();
112      while (TokenFqH.FNextKeyId(KeyId)) {
113          const int TokenId = TokenFqH.GetKey(KeyId);
114          const int TokenFq = TokenFqH[KeyId];
115          const int TokenDocFq = TokenH[TokenId];
116          const double IDF = log(double(Docs) / double(TokenDocFq));
117          ValSpV.Add(TIntFltKd(TokenId, double(TokenFq) * IDF));
118      }
119      ValSpV.Sort(); TLinAlg::NormalizeL1(ValSpV);
120      for (int ValSpN = 0; ValSpN < ValSpV.Len(); ValSpN++) {
121          const int Key = ValSpV[ValSpN].Key + Offset;
122          const double Dat = ValSpV[ValSpN].Dat;
123          SpV.Add(TIntFltKd(Key, Dat));
124      }
125      Offset += TokenH.Len(); 
126  }
127  bool TFtrGenSparseNumeric::IsReg = TFtrGenSparseNumeric::MkReg();
128  void TFtrGenSparseNumeric::Split(
129          const TStr& Str, int& Id, TStr& Val) const {
130      if (!Str.IsChIn(':')) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
131      TStr IdStr; Str.SplitOnCh(IdStr, ':', Val);
132      if (!IdStr.IsInt(Id)) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
133  }
134  void TFtrGenSparseNumeric::Update(const TStr& Str) { 
135      TStrV EltV; Str.SplitOnAllCh(';', EltV);
136      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
137          int Id; TStr Val; Split(EltV[EltN], Id, Val);
138          MxId = TInt::GetMx(Id, MxId);
139          FtrGen->Update(Val);
140      }
141  }
142  void TFtrGenSparseNumeric::Add(const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
143      TStrV EltV; Str.SplitOnAllCh(';', EltV); TIntH UsedIdH;
144      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
145          int Id; TStr Val; Split(EltV[EltN], Id, Val);
146          EAssertR(!UsedIdH.IsKey(Id), "Field ID repeated in '" + Str + "'!");
147          int TmpOffset = Offset + Id;
148          FtrGen->Add(Val, SpV, TmpOffset);
149          UsedIdH.AddKey(Id);
150      }
151      Offset += GetVals();
152  }
153  TStr TFtrGenSparseNumeric::GetVal(const int& ValN, const bool& PrefixP) const { 
154      const int FtrGenId = ValN / FtrGen->GetVals();
155      const int FtrGenValN = ValN % FtrGen->GetVals();
156      return TStr::Fmt("SP-%d-%d-%s", FtrGenId, 
157          FtrGenValN, FtrGen->GetVal(FtrGenValN));
158  }
159  bool TFtrGenMultiNom::IsReg = TFtrGenMultiNom::MkReg();
160  void TFtrGenMultiNom::Update(const TStr& Str) { 
161      TStrV EltV; Str.SplitOnAllCh(';', EltV);
162      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
163          FtrGen->Update(EltV[EltN]);
164      }
165  }
166  void TFtrGenMultiNom::Add(const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
167      TStrV EltV; Str.SplitOnAllCh(';', EltV);
168      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
169          int TmpOffset = Offset;
170          FtrGen->Add(EltV[EltN], SpV, TmpOffset);
171      }
172      Offset += GetVals();
173  }
174  TStr TFtrGenMultiNom::GetVal(const int& ValN, const bool& PrefixP) const { 
175      return PrefixP ? 
176  		TStr::Fmt("MULTI-%d-%s", ValN, FtrGen->GetVal(ValN).CStr()) :
177  		FtrGen->GetVal(ValN, PrefixP);
178  }
179  void TFtrGenMultiNom::GetValV(const TStr& Str, TStrV& ValV) const {
180      TStrV EltV; Str.SplitOnAllCh(';', EltV); ValV.Clr();
181      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
182          const TStr& Val = EltV[EltN];
183          TStrV SubValV; FtrGen->GetValV(Val, SubValV);
184          ValV.AddV(SubValV);
185      }
186  }
187  TFtrGenBs::TFtrGenBs(TSIn& SIn) {
188  	State = TFtrGenState(TInt(SIn).Val);
189  	FtrGenV.Load(SIn);
190  	ClsFtrGen = PFtrGen(SIn);
191  }
192  void TFtrGenBs::Save(TSOut& SOut) const {
193  	TInt(State).Save(SOut);
194  	FtrGenV.Save(SOut);
195  	ClsFtrGen.Save(SOut);
196  }
197  int TFtrGenBs::AddFtrGen(const PFtrGen& FtrGen) { 
198  	EAssert(State == fgsInit);
199  	return FtrGenV.Add(FtrGen);
200  }
201  void TFtrGenBs::PutClsFtrGen(const PFtrGen& FtrGen) {
202  	EAssert(State == fgsInit); 
203  	ClsFtrGen = FtrGen; 
204  }
205  void TFtrGenBs::Update(const TStrV& FtrValV) {
206  	EAssert(State == fgsUpdate);
207  	EAssert(FtrValV.Len() == FtrGenV.Len());
208  	try {
209  		for (int FtrValN = 0; FtrValN < FtrValV.Len(); FtrValN++) {
210  			FtrGenV[FtrValN]->Update(FtrValV[FtrValN]);
211  		}
212  	} catch (PExcept Ex) {
213  		TExcept::Throw(TStr::Fmt("Error feature generation: '%s'!", Ex->GetMsgStr().CStr()));
214  	}
215  }
216  void TFtrGenBs::UpdateCls(const TStr& ClsFtrVal) {
217  	EAssert(State == fgsUpdate);
218  	EAssert(!ClsFtrGen.Empty());
219  	try {
220  		ClsFtrGen->Update(ClsFtrVal);
221  	} catch (PExcept Ex) {
222  		TExcept::Throw(TStr::Fmt("Error feature generation: '%s'!", Ex->GetMsgStr().CStr()));
223  	}
224  }
225  void TFtrGenBs::GenFtrV(const TStrV& FtrValV, TIntFltKdV& FtrSpV) const {
226  	EAssert(State == fgsGen);
227  	EAssert(FtrValV.Len() == FtrGenV.Len());
228      try {
229  		int Offset = 0;
230          for (int FtrValN = 0; FtrValN < FtrValV.Len(); FtrValN++) {
231  			const PFtrGen& FtrGen = FtrGenV[FtrValN];
232  			const TStr& FtrVal = FtrValV[FtrValN];
233              FtrGen->Add(FtrVal, FtrSpV, Offset);
234          }
235      } catch (PExcept Ex) {
236  		TExcept::Throw(TStr::Fmt("Error feature generation: '%s'!", Ex->GetMsgStr().CStr()));
237      }
238  }
239  void TFtrGenBs::GenClsV(const TStr& ClsFtrVal, TStrV& ClsV) const {
240  	EAssert(State == fgsGen);
241  	EAssert(!ClsFtrGen.Empty());
242      try {
243          ClsFtrGen->GetValV(ClsFtrVal, ClsV);
244      } catch (PExcept Ex) {
245  		TExcept::Throw(TStr::Fmt("Error feature generation: '%s'!", Ex->GetMsgStr().CStr()));
246      }
247  }
248  PBowDocBs TFtrGenBs::MakeBowDocBs() const { 
249  	EAssert(State == fgsGen);
250  	PBowDocBs BowDocBs = TBowDocBs::New();
251      int WdsOffset = 0;
252  	for (int FtrGenN = 0; FtrGenN < FtrGenV.Len(); FtrGenN++) {
253          const PFtrGen& FtrGen = FtrGenV[FtrGenN];
254  		TStr Prefix = TInt::GetStr(FtrGenN);
255          FtrGen->AddWds(Prefix, BowDocBs, WdsOffset);
256      }
257  	return BowDocBs;
258  }
259  void TFtrGenBs::AddBowDoc(const PBowDocBs& BowDocBs,
260  		const TStr& DocNm, const TStrV& FtrValV) const {
261      TIntFltKdV FtrSpV; GenFtrV(FtrValV, FtrSpV);
262      const int WIds = FtrSpV.Len(); TIntFltPrV WIdWgtPrV(WIds, 0);
263      for (int WIdN = 0; WIdN < WIds; WIdN++) {
264          WIdWgtPrV.Add(TIntFltPr(FtrSpV[WIdN].Key, FtrSpV[WIdN].Dat));
265      }
266      BowDocBs->AddDoc(DocNm, TStrV(), WIdWgtPrV);
267  }
268  void TFtrGenBs::AddBowDoc(const PBowDocBs& BowDocBs, const TStr& DocNm,
269  		const TStrV& FtrValV, const TStr& ClsFtrVal) const {
270      TIntFltKdV FtrSpV; GenFtrV(FtrValV, FtrSpV);
271  	TStrV CatNmV; GenClsV(ClsFtrVal, CatNmV);
272      const int WIds = FtrSpV.Len(); TIntFltPrV WIdWgtPrV(WIds, 0);
273      for (int WIdN = 0; WIdN < WIds; WIdN++) {
274          WIdWgtPrV.Add(TIntFltPr(FtrSpV[WIdN].Key, FtrSpV[WIdN].Dat));
275      }
276  	if (!WIdWgtPrV.Empty()) { BowDocBs->AddDoc(DocNm, CatNmV, WIdWgtPrV); }
277  }
278  void TFtrGenBs::GetAllCatNmV(TStrV& CatNmV) const {
279  	const int Vals = ClsFtrGen->GetVals();
280  	for (int ValN = 0; ValN < Vals; ValN++) {
281  		CatNmV.Add(ClsFtrGen->GetVal(ValN, false));
282  	}
283  }
284  PBowDocBs TFtrGenBs::LoadCsv(TStr& FNm, const int& ClassId, 
285          const TIntV& IgnoreIdV, const int& TrainLen) {
286  	PFtrGenBs FtrGenBs = TFtrGenBs::New();
287      PSIn SIn = TFIn::New(FNm); 
288      char SsCh = ' '; TStrV FldValV;
289      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);  
290      for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
291          const TStr& FldVal = FldValV[FldValN];
292          if (FldValN == ClassId) { 
293              if (FldVal == "NOM") {
294                  FtrGenBs->PutClsFtrGen(TFtrGenNominal::New());
295              } else if (FldVal == "MULTI-NOM") {
296                  FtrGenBs->PutClsFtrGen(TFtrGenMultiNom::New());
297              } else {
298                  TExcept::Throw("Wrong class type '" + FldVal + "', should be NOM or MULTI-NOM!");
299              }
300          } else if (!IgnoreIdV.IsIn(FldValN)) {
301              if (FldVal == TFtrGenNumeric::GetType()) {
302  				FtrGenBs->AddFtrGen(TFtrGenNumeric::New());
303              } else if (FldVal == TFtrGenNominal::GetType()) { 
304  				FtrGenBs->AddFtrGen(TFtrGenNominal::New());
305              } else if (FldVal == TFtrGenToken::GetType()) { 
306  				FtrGenBs->AddFtrGen(TFtrGenToken::New(
307                      TSwSet::New(swstNone), TStemmer::New(stmtNone)));
308              } else if (FldVal == TFtrGenSparseNumeric::GetType()) { 
309  				FtrGenBs->AddFtrGen(TFtrGenSparseNumeric::New());
310              } else if (FldVal == TFtrGenMultiNom::GetType()) { 
311  				FtrGenBs->AddFtrGen(TFtrGenMultiNom::New());
312              } else {
313                  TExcept::Throw("Wrong type '" + FldVal + "'!");
314              }
315          }
316      }
317      const int Flds = FldValV.Len();
318      int Recs = 0;
319      while (!SIn->Eof()) {
320          if (Recs == TrainLen) { break; }
321          Recs++; printf("%7d\r", Recs);
322          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
323          EAssertR(FldValV.Len() == Flds, 
324              TStr::Fmt("Wrong number of fields in line %d! Found %d and expected %d!",
325              Recs + 1, FldValV.Len(), Flds));
326          try {
327  			TStrV FtrValV;
328              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
329                  const TStr& FldVal = FldValV[FldValN];
330                  if (FldValN == ClassId) { 
331  					FtrGenBs->UpdateCls(FldVal);
332                  } else if (!IgnoreIdV.IsIn(FldValN)) {
333                      FtrValV.Add(FldVal);
334                  }
335              }
336  			FtrGenBs->Update(FtrValV);
337          } catch (PExcept Ex) {
338              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!", 
339                  Recs+1, Ex->GetMsgStr().CStr()));
340          }
341      }
342      PBowDocBs BowDocBs = FtrGenBs->MakeBowDocBs();
343      SIn = TFIn::New(FNm); SsCh = ' ';
344      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);  
345      Recs = 0;
346      while (!SIn->Eof()){
347          Recs++; printf("%7d\r", Recs);
348          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
349          EAssertR(FldValV.Len() == Flds, 
350              TStr::Fmt("Wrong number of fields in line %s! Found %d and expected %d!",
351              Recs + 1, FldValV.Len(), Flds));
352  		TStrV FtrValV; TStr ClsFtrVal;
353          try {
354              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
355                  const TStr& FldVal = FldValV[FldValN];
356                  if (FldValN == ClassId) { 
357                      ClsFtrVal = FldVal;
358                  } else if (!IgnoreIdV.IsIn(FldValN)) {
359                      FtrValV.Add(FldVal);
360                  }
361              }
362          } catch (PExcept Ex) {
363              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!", 
364                  Recs+1, Ex->GetMsgStr().CStr()));
365          }
366  		FtrGenBs->AddBowDoc(BowDocBs, TStr::Fmt("Line-%d", Recs), FtrValV, ClsFtrVal);
367      }
368  	TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); IAssert(AllDIdV.IsSorted());
369  	TIntV TrainDIdV = AllDIdV; TrainDIdV.Trunc(TrainLen);
370  	BowDocBs->PutTrainDIdV(TrainDIdV);
371  	TIntV TestDIdV = AllDIdV; TestDIdV.Minus(TrainDIdV);
372  	BowDocBs->PutTestDIdV(TestDIdV);
373      return BowDocBs;
374  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webmb.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ftrgen.cpp</div>
                </div>
                <div class="column column_space"><pre><code>27    if (GetWebPgs()%1000==0){SaveTxt();}
28  }
29  void TWebMemBs::OnFetch(const int& WebPgId, const PXWebPg& WebPg){
30    bool DoSave;
</pre></code></div>
                <div class="column column_space"><pre><code>50      if (!Val.Empty()) { ValH.AddKey(Val); }
51  }
52  void TFtrGenNominal::Add(
53          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    