
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.3076923076923075%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ligature_table.cpp</h3>
            <pre><code>1  #include "ligature_table.h"
2  #include <tesseract/unichar.h>
3  #include "pango_font_info.h"
4  #include "tlog.h"
5  #include "unicharset.h"
6  #include "unicode/errorcode.h" 
7  #include "unicode/normlzr.h"   
8  #include "unicode/unistr.h"    
9  #include "unicode/utypes.h"    
10  #include <utility>
11  namespace tesseract {
12  static std::string EncodeAsUTF8(const char32 ch32) {
13    UNICHAR uni_ch(ch32);
14    return std::string(uni_ch.utf8(), uni_ch.utf8_len());
15  }
16  const int kMinLigature = 0xfb00;
17  const int kMaxLigature = 0xfb17; 
18  std::unique_ptr<LigatureTable> LigatureTable::instance_;
19  LigatureTable *LigatureTable::Get() {
20    if (instance_ == nullptr) {
21      instance_.reset(new LigatureTable());
22      instance_->Init();
23    }
24    return instance_.get();
25  }
26  LigatureTable::LigatureTable()
27      : min_lig_length_(0), max_lig_length_(0), min_norm_length_(0), max_norm_length_(0) {}
28  void LigatureTable::Init() {
29    if (norm_to_lig_table_.empty()) {
30      for (char32 lig = kMinLigature; lig <= kMaxLigature; ++lig) {
31        std::string lig8 = EncodeAsUTF8(lig);
32        icu::UnicodeString unicode_lig8(static_cast<UChar32>(lig));
33        icu::UnicodeString normed8_result;
34        icu::ErrorCode status;
35        icu::Normalizer::normalize(unicode_lig8, UNORM_NFC, 0, normed8_result, status);
36        std::string normed8;
37        normed8_result.toUTF8String(normed8);
38        int lig_length = lig8.length();
39        int norm_length = normed8.size();
40        if (normed8 != lig8 && lig_length > 1 && norm_length > 1) {
41          norm_to_lig_table_[normed8] = lig8;
42          lig_to_norm_table_[lig8] = normed8;
43          if (min_lig_length_ == 0 || lig_length < min_lig_length_) {
44            min_lig_length_ = lig_length;
45          }
46          if (lig_length > max_lig_length_) {
47            max_lig_length_ = lig_length;
48          }
49          if (min_norm_length_ == 0 || norm_length < min_norm_length_) {
50            min_norm_length_ = norm_length;
51          }
52          if (norm_length > max_norm_length_) {
53            max_norm_length_ = norm_length;
54          }
55        }
56      }
57      for (int i = 0; UNICHARSET::kCustomLigatures[i][0] != nullptr; ++i) {
58        norm_to_lig_table_[UNICHARSET::kCustomLigatures[i][0]] = UNICHARSET::kCustomLigatures[i][1];
59        int norm_length = strlen(UNICHARSET::kCustomLigatures[i][0]);
60        if (min_norm_length_ == 0 || norm_length < min_norm_length_) {
61          min_norm_length_ = norm_length;
62        }
63        if (norm_length > max_norm_length_) {
64          max_norm_length_ = norm_length;
65        }
66        lig_to_norm_table_[UNICHARSET::kCustomLigatures[i][1]] = UNICHARSET::kCustomLigatures[i][0];
67      }
68    }
69  }
70  std::string LigatureTable::RemoveLigatures(const std::string &str) const {
71    std::string result;
72    UNICHAR::const_iterator it_begin = UNICHAR::begin(str.c_str(), str.length());
73    UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
74    char tmp[5];
75    int len;
76    for (UNICHAR::const_iterator it = it_begin; it != it_end; ++it) {
77      len = it.get_utf8(tmp);
78      tmp[len] = '\0';
79      auto lig_it = lig_to_norm_table_.find(tmp);
80      if (lig_it != lig_to_norm_table_.end()) {
81        result += lig_it->second;
82      } else {
83        result += tmp;
84      }
85    }
86    return result;
87  }
88  std::string LigatureTable::RemoveCustomLigatures(const std::string &str) const {
89    std::string result;
<span onclick='openModal()' class='match'>90    UNICHAR::const_iterator it_begin = UNICHAR::begin(str.c_str(), str.length());
91    UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
92    char tmp[5];
93    int len;
94    int norm_ind;
</span>95    for (UNICHAR::const_iterator it = it_begin; it != it_end; ++it) {
96      len = it.get_utf8(tmp);
97      tmp[len] = '\0';
98      norm_ind = -1;
99      for (int i = 0; UNICHARSET::kCustomLigatures[i][0] != nullptr && norm_ind < 0; ++i) {
100        if (!strcmp(tmp, UNICHARSET::kCustomLigatures[i][1])) {
101          norm_ind = i;
102        }
103      }
104      if (norm_ind >= 0) {
105        result += UNICHARSET::kCustomLigatures[norm_ind][0];
106      } else {
107        result += tmp;
108      }
109    }
110    return result;
111  }
112  std::string LigatureTable::AddLigatures(const std::string &str, const PangoFontInfo *font) const {
113    std::string result;
114    int len = str.size();
115    int step = 0;
116    int i = 0;
117    for (i = 0; i < len - min_norm_length_ + 1; i += step) {
118      step = 0;
119      for (int liglen = max_norm_length_; liglen >= min_norm_length_; --liglen) {
120        if (i + liglen <= len) {
121          std::string lig_cand = str.substr(i, liglen);
122          auto it = norm_to_lig_table_.find(lig_cand);
123          if (it != norm_to_lig_table_.end()) {
124            tlog(3, "Considering %s -> %s\n", lig_cand.c_str(), it->second.c_str());
125            if (font) {
126              if (!font->CanRenderString(it->second.data(), it->second.length())) {
127                continue; 
128              }
129            }
130            step = liglen;
131            result += it->second;
132            tlog(2, "Substituted %s -> %s\n", lig_cand.c_str(), it->second.c_str());
133            break;
134          }
135        }
136      }
137      if (step == 0) {
138        result += str[i];
139        step = 1;
140      }
141    }
142    result += str.substr(i, len - i);
143    return result;
144  }
145  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_test.cc</h3>
            <pre><code>1  #include "absl/strings/charconv.h"
2  #include <cstdlib>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/strings/internal/pow10_helper.h"
7  #include "absl/strings/str_cat.h"
8  #include "absl/strings/str_format.h"
9  #ifdef _MSC_FULL_VER
10  #define ABSL_COMPILER_DOES_EXACT_ROUNDING 0
11  #define ABSL_STRTOD_HANDLES_NAN_CORRECTLY 0
12  #else
13  #define ABSL_COMPILER_DOES_EXACT_ROUNDING 1
14  #define ABSL_STRTOD_HANDLES_NAN_CORRECTLY 1
15  #endif
16  namespace {
17  using absl::strings_internal::Pow10;
18  #if ABSL_COMPILER_DOES_EXACT_ROUNDING
19  void TestDoubleParse(absl::string_view str, double expected_number) {
20    SCOPED_TRACE(str);
21    double actual_number = 0.0;
22    absl::from_chars_result result =
23        absl::from_chars(str.data(), str.data() + str.length(), actual_number);
24    EXPECT_EQ(result.ec, std::errc());
25    EXPECT_EQ(result.ptr, str.data() + str.length());
26    EXPECT_EQ(actual_number, expected_number);
27  }
28  void TestFloatParse(absl::string_view str, float expected_number) {
29    SCOPED_TRACE(str);
30    float actual_number = 0.0;
31    absl::from_chars_result result =
32        absl::from_chars(str.data(), str.data() + str.length(), actual_number);
33    EXPECT_EQ(result.ec, std::errc());
34    EXPECT_EQ(result.ptr, str.data() + str.length());
35    EXPECT_EQ(actual_number, expected_number);
36  }
37  #define FROM_CHARS_TEST_DOUBLE(number)     \
38    {                                        \
39      TestDoubleParse(#number, number);      \
40      TestDoubleParse("-" #number, -number); \
41    }
42  #define FROM_CHARS_TEST_FLOAT(number)        \
43    {                                          \
44      TestFloatParse(#number, number##f);      \
45      TestFloatParse("-" #number, -number##f); \
46    }
47  TEST(FromChars, NearRoundingCases) {
48    FROM_CHARS_TEST_DOUBLE(5.e125);
49    FROM_CHARS_TEST_DOUBLE(69.e267);
50    FROM_CHARS_TEST_DOUBLE(999.e-026);
51    FROM_CHARS_TEST_DOUBLE(7861.e-034);
52    FROM_CHARS_TEST_DOUBLE(75569.e-254);
53    FROM_CHARS_TEST_DOUBLE(928609.e-261);
54    FROM_CHARS_TEST_DOUBLE(9210917.e080);
55    FROM_CHARS_TEST_DOUBLE(84863171.e114);
56    FROM_CHARS_TEST_DOUBLE(653777767.e273);
57    FROM_CHARS_TEST_DOUBLE(5232604057.e-298);
58    FROM_CHARS_TEST_DOUBLE(27235667517.e-109);
59    FROM_CHARS_TEST_DOUBLE(653532977297.e-123);
60    FROM_CHARS_TEST_DOUBLE(3142213164987.e-294);
61    FROM_CHARS_TEST_DOUBLE(46202199371337.e-072);
62    FROM_CHARS_TEST_DOUBLE(231010996856685.e-073);
63    FROM_CHARS_TEST_DOUBLE(9324754620109615.e212);
64    FROM_CHARS_TEST_DOUBLE(78459735791271921.e049);
65    FROM_CHARS_TEST_DOUBLE(272104041512242479.e200);
66    FROM_CHARS_TEST_DOUBLE(6802601037806061975.e198);
67    FROM_CHARS_TEST_DOUBLE(20505426358836677347.e-221);
68    FROM_CHARS_TEST_DOUBLE(836168422905420598437.e-234);
69    FROM_CHARS_TEST_DOUBLE(4891559871276714924261.e222);
70    FROM_CHARS_TEST_FLOAT(5.e-20);
71    FROM_CHARS_TEST_FLOAT(67.e14);
72    FROM_CHARS_TEST_FLOAT(985.e15);
73    FROM_CHARS_TEST_FLOAT(7693.e-42);
74    FROM_CHARS_TEST_FLOAT(55895.e-16);
75    FROM_CHARS_TEST_FLOAT(996622.e-44);
76    FROM_CHARS_TEST_FLOAT(7038531.e-32);
77    FROM_CHARS_TEST_FLOAT(60419369.e-46);
78    FROM_CHARS_TEST_FLOAT(702990899.e-20);
79    FROM_CHARS_TEST_FLOAT(6930161142.e-48);
80    FROM_CHARS_TEST_FLOAT(25933168707.e-13);
81    FROM_CHARS_TEST_FLOAT(596428896559.e20);
82    FROM_CHARS_TEST_DOUBLE(9.e-265);
83    FROM_CHARS_TEST_DOUBLE(85.e-037);
84    FROM_CHARS_TEST_DOUBLE(623.e100);
85    FROM_CHARS_TEST_DOUBLE(3571.e263);
86    FROM_CHARS_TEST_DOUBLE(81661.e153);
87    FROM_CHARS_TEST_DOUBLE(920657.e-023);
88    FROM_CHARS_TEST_DOUBLE(4603285.e-024);
89    FROM_CHARS_TEST_DOUBLE(87575437.e-309);
90    FROM_CHARS_TEST_DOUBLE(245540327.e122);
91    FROM_CHARS_TEST_DOUBLE(6138508175.e120);
92    FROM_CHARS_TEST_DOUBLE(83356057653.e193);
93    FROM_CHARS_TEST_DOUBLE(619534293513.e124);
94    FROM_CHARS_TEST_DOUBLE(2335141086879.e218);
95    FROM_CHARS_TEST_DOUBLE(36167929443327.e-159);
96    FROM_CHARS_TEST_DOUBLE(609610927149051.e-255);
97    FROM_CHARS_TEST_DOUBLE(3743626360493413.e-165);
98    FROM_CHARS_TEST_DOUBLE(94080055902682397.e-242);
99    FROM_CHARS_TEST_DOUBLE(899810892172646163.e283);
100    FROM_CHARS_TEST_DOUBLE(7120190517612959703.e120);
101    FROM_CHARS_TEST_DOUBLE(25188282901709339043.e-252);
102    FROM_CHARS_TEST_DOUBLE(308984926168550152811.e-052);
103    FROM_CHARS_TEST_DOUBLE(6372891218502368041059.e064);
104    FROM_CHARS_TEST_FLOAT(3.e-23);
105    FROM_CHARS_TEST_FLOAT(57.e18);
106    FROM_CHARS_TEST_FLOAT(789.e-35);
107    FROM_CHARS_TEST_FLOAT(2539.e-18);
108    FROM_CHARS_TEST_FLOAT(76173.e28);
109    FROM_CHARS_TEST_FLOAT(887745.e-11);
110    FROM_CHARS_TEST_FLOAT(5382571.e-37);
111    FROM_CHARS_TEST_FLOAT(82381273.e-35);
112    FROM_CHARS_TEST_FLOAT(750486563.e-38);
113    FROM_CHARS_TEST_FLOAT(3752432815.e-39);
114    FROM_CHARS_TEST_FLOAT(75224575729.e-45);
115    FROM_CHARS_TEST_FLOAT(459926601011.e15);
116  }
117  #undef FROM_CHARS_TEST_DOUBLE
118  #undef FROM_CHARS_TEST_FLOAT
119  #endif
120  float ToFloat(absl::string_view s) {
121    float f;
122    absl::from_chars(s.data(), s.data() + s.size(), f);
123    return f;
124  }
125  double ToDouble(absl::string_view s) {
126    double d;
127    absl::from_chars(s.data(), s.data() + s.size(), d);
128    return d;
129  }
130  TEST(FromChars, NearRoundingCasesExplicit) {
131    EXPECT_EQ(ToDouble("5.e125"), ldexp(6653062250012735, 365));
132    EXPECT_EQ(ToDouble("69.e267"), ldexp(4705683757438170, 841));
133    EXPECT_EQ(ToDouble("999.e-026"), ldexp(6798841691080350, -129));
134    EXPECT_EQ(ToDouble("7861.e-034"), ldexp(8975675289889240, -153));
135    EXPECT_EQ(ToDouble("75569.e-254"), ldexp(6091718967192243, -880));
136    EXPECT_EQ(ToDouble("928609.e-261"), ldexp(7849264900213743, -900));
137    EXPECT_EQ(ToDouble("9210917.e080"), ldexp(8341110837370930, 236));
138    EXPECT_EQ(ToDouble("84863171.e114"), ldexp(4625202867375927, 353));
139    EXPECT_EQ(ToDouble("653777767.e273"), ldexp(5068902999763073, 884));
140    EXPECT_EQ(ToDouble("5232604057.e-298"), ldexp(5741343011915040, -1010));
141    EXPECT_EQ(ToDouble("27235667517.e-109"), ldexp(6707124626673586, -380));
142    EXPECT_EQ(ToDouble("653532977297.e-123"), ldexp(7078246407265384, -422));
143    EXPECT_EQ(ToDouble("3142213164987.e-294"), ldexp(8219991337640559, -988));
144    EXPECT_EQ(ToDouble("46202199371337.e-072"), ldexp(5224462102115359, -246));
145    EXPECT_EQ(ToDouble("231010996856685.e-073"), ldexp(5224462102115359, -247));
146    EXPECT_EQ(ToDouble("9324754620109615.e212"), ldexp(5539753864394442, 705));
147    EXPECT_EQ(ToDouble("78459735791271921.e049"), ldexp(8388176519442766, 166));
148    EXPECT_EQ(ToDouble("272104041512242479.e200"), ldexp(5554409530847367, 670));
149    EXPECT_EQ(ToDouble("6802601037806061975.e198"), ldexp(5554409530847367, 668));
150    EXPECT_EQ(ToDouble("20505426358836677347.e-221"),
151              ldexp(4524032052079546, -722));
152    EXPECT_EQ(ToDouble("836168422905420598437.e-234"),
153              ldexp(5070963299887562, -760));
154    EXPECT_EQ(ToDouble("4891559871276714924261.e222"),
155              ldexp(6452687840519111, 757));
156    EXPECT_EQ(ToFloat("5.e-20"), ldexpf(15474250, -88));
157    EXPECT_EQ(ToFloat("67.e14"), ldexpf(12479722, 29));
158    EXPECT_EQ(ToFloat("985.e15"), ldexpf(14333636, 36));
159    EXPECT_EQ(ToFloat("7693.e-42"), ldexpf(10979816, -150));
160    EXPECT_EQ(ToFloat("55895.e-16"), ldexpf(12888509, -61));
161    EXPECT_EQ(ToFloat("996622.e-44"), ldexpf(14224264, -150));
162    EXPECT_EQ(ToFloat("7038531.e-32"), ldexpf(11420669, -107));
163    EXPECT_EQ(ToFloat("60419369.e-46"), ldexpf(8623340, -150));
164    EXPECT_EQ(ToFloat("702990899.e-20"), ldexpf(16209866, -61));
165    EXPECT_EQ(ToFloat("6930161142.e-48"), ldexpf(9891056, -150));
166    EXPECT_EQ(ToFloat("25933168707.e-13"), ldexpf(11138211, -32));
167    EXPECT_EQ(ToFloat("596428896559.e20"), ldexpf(12333860, 82));
168    EXPECT_EQ(ToDouble("9.e-265"), ldexp(8168427841980010, -930));
169    EXPECT_EQ(ToDouble("85.e-037"), ldexp(6360455125664090, -169));
170    EXPECT_EQ(ToDouble("623.e100"), ldexp(6263531988747231, 289));
171    EXPECT_EQ(ToDouble("3571.e263"), ldexp(6234526311072170, 833));
172    EXPECT_EQ(ToDouble("81661.e153"), ldexp(6696636728760206, 472));
173    EXPECT_EQ(ToDouble("920657.e-023"), ldexp(5975405561110124, -109));
174    EXPECT_EQ(ToDouble("4603285.e-024"), ldexp(5975405561110124, -110));
175    EXPECT_EQ(ToDouble("87575437.e-309"), ldexp(8452160731874668, -1053));
176    EXPECT_EQ(ToDouble("245540327.e122"), ldexp(4985336549131723, 381));
177    EXPECT_EQ(ToDouble("6138508175.e120"), ldexp(4985336549131723, 379));
178    EXPECT_EQ(ToDouble("83356057653.e193"), ldexp(5986732817132056, 625));
179    EXPECT_EQ(ToDouble("619534293513.e124"), ldexp(4798406992060657, 399));
180    EXPECT_EQ(ToDouble("2335141086879.e218"), ldexp(5419088166961646, 713));
181    EXPECT_EQ(ToDouble("36167929443327.e-159"), ldexp(8135819834632444, -536));
182    EXPECT_EQ(ToDouble("609610927149051.e-255"), ldexp(4576664294594737, -850));
183    EXPECT_EQ(ToDouble("3743626360493413.e-165"), ldexp(6898586531774201, -549));
184    EXPECT_EQ(ToDouble("94080055902682397.e-242"), ldexp(6273271706052298, -800));
185    EXPECT_EQ(ToDouble("899810892172646163.e283"), ldexp(7563892574477827, 947));
186    EXPECT_EQ(ToDouble("7120190517612959703.e120"), ldexp(5385467232557565, 409));
187    EXPECT_EQ(ToDouble("25188282901709339043.e-252"),
188              ldexp(5635662608542340, -825));
189    EXPECT_EQ(ToDouble("308984926168550152811.e-052"),
190              ldexp(5644774693823803, -157));
191    EXPECT_EQ(ToDouble("6372891218502368041059.e064"),
192              ldexp(4616868614322430, 233));
193    EXPECT_EQ(ToFloat("3.e-23"), ldexpf(9507380, -98));
194    EXPECT_EQ(ToFloat("57.e18"), ldexpf(12960300, 42));
195    EXPECT_EQ(ToFloat("789.e-35"), ldexpf(10739312, -130));
196    EXPECT_EQ(ToFloat("2539.e-18"), ldexpf(11990089, -72));
197    EXPECT_EQ(ToFloat("76173.e28"), ldexpf(9845130, 86));
198    EXPECT_EQ(ToFloat("887745.e-11"), ldexpf(9760860, -40));
199    EXPECT_EQ(ToFloat("5382571.e-37"), ldexpf(11447463, -124));
200    EXPECT_EQ(ToFloat("82381273.e-35"), ldexpf(8554961, -113));
201    EXPECT_EQ(ToFloat("750486563.e-38"), ldexpf(9975678, -120));
202    EXPECT_EQ(ToFloat("3752432815.e-39"), ldexpf(9975678, -121));
203    EXPECT_EQ(ToFloat("75224575729.e-45"), ldexpf(13105970, -137));
204    EXPECT_EQ(ToFloat("459926601011.e15"), ldexpf(12466336, 65));
205  }
206  template <typename FloatType>
207  void TestHalfwayValue(const std::string& mantissa, int exponent,
208                        FloatType expected_low, FloatType expected_high,
209                        FloatType expected_half) {
210    std::string low_rep = mantissa;
211    low_rep[low_rep.size() - 1] -= 1;
212    absl::StrAppend(&low_rep, std::string(1000, '9'), "e", exponent);
213    FloatType actual_low = 0;
214    absl::from_chars(low_rep.data(), low_rep.data() + low_rep.size(), actual_low);
215    EXPECT_EQ(expected_low, actual_low);
216    std::string high_rep =
217        absl::StrCat(mantissa, std::string(1000, '0'), "1e", exponent);
218    FloatType actual_high = 0;
219    absl::from_chars(high_rep.data(), high_rep.data() + high_rep.size(),
220                     actual_high);
221    EXPECT_EQ(expected_high, actual_high);
222    std::string halfway_rep = absl::StrCat(mantissa, "e", exponent);
223    FloatType actual_half = 0;
224    absl::from_chars(halfway_rep.data(), halfway_rep.data() + halfway_rep.size(),
225                     actual_half);
226    EXPECT_EQ(expected_half, actual_half);
227  }
228  TEST(FromChars, DoubleRounding) {
229    const double zero = 0.0;
230    const double first_subnormal = nextafter(zero, 1.0);
231    const double second_subnormal = nextafter(first_subnormal, 1.0);
232    const double first_normal = DBL_MIN;
233    const double last_subnormal = nextafter(first_normal, 0.0);
234    const double second_normal = nextafter(first_normal, 1.0);
235    const double last_normal = DBL_MAX;
236    const double penultimate_normal = nextafter(last_normal, 0.0);
237    TestHalfwayValue(
238        "2."
239        "470328229206232720882843964341106861825299013071623822127928412503377536"
240        "351043759326499181808179961898982823477228588654633283551779698981993873"
241        "980053909390631503565951557022639229085839244910518443593180284993653615"
242        "250031937045767824921936562366986365848075700158576926990370631192827955"
243        "855133292783433840935197801553124659726357957462276646527282722005637400"
244        "648549997709659947045402082816622623785739345073633900796776193057750674"
245        "017632467360096895134053553745851666113422376667860416215968046191446729"
246        "184030053005753084904876539171138659164623952491262365388187963623937328"
247        "042389101867234849766823508986338858792562830275599565752445550725518931"
248        "369083625477918694866799496832404970582102851318545139621383772282614543"
249        "7693412532098591327667236328125",
250        -324, zero, first_subnormal, zero);
251    TestHalfwayValue(
252        "7."
253        "410984687618698162648531893023320585475897039214871466383785237510132609"
254        "053131277979497545424539885696948470431685765963899850655339096945981621"
255        "940161728171894510697854671067917687257517734731555330779540854980960845"
256        "750095811137303474765809687100959097544227100475730780971111893578483867"
257        "565399878350301522805593404659373979179073872386829939581848166016912201"
258        "945649993128979841136206248449867871357218035220901702390328579173252022"
259        "052897402080290685402160661237554998340267130003581248647904138574340187"
260        "552090159017259254714629617513415977493871857473787096164563890871811984"
261        "127167305601704549300470526959016576377688490826798697257336652176556794"
262        "107250876433756084600398490497214911746308553955635418864151316847843631"
263        "3080237596295773983001708984375",
264        -324, first_subnormal, second_subnormal, second_subnormal);
265    TestHalfwayValue(
266        "2."
267        "225073858507201136057409796709131975934819546351645648023426109724822222"
268        "021076945516529523908135087914149158913039621106870086438694594645527657"
269        "207407820621743379988141063267329253552286881372149012981122451451889849"
270        "057222307285255133155755015914397476397983411801999323962548289017107081"
271        "850690630666655994938275772572015763062690663332647565300009245888316433"
272        "037779791869612049497390377829704905051080609940730262937128958950003583"
273        "799967207254304360284078895771796150945516748243471030702609144621572289"
274        "880258182545180325707018860872113128079512233426288368622321503775666622"
275        "503982534335974568884423900265498198385487948292206894721689831099698365"
276        "846814022854243330660339850886445804001034933970427567186443383770486037"
277        "86162277173854562306587467901408672332763671875",
278        -308, last_subnormal, first_normal, first_normal);
279    TestHalfwayValue(
280        "2."
281        "225073858507201630123055637955676152503612414573018013083228724049586647"
282        "606759446192036794116886953213985520549032000903434781884412325572184367"
283        "563347617020518175998922941393629966742598285899994830148971433555578567"
284        "693279306015978183162142425067962460785295885199272493577688320732492479"
285        "924816869232247165964934329258783950102250973957579510571600738343645738"
286        "494324192997092179207389919761694314131497173265255020084997973676783743"
287        "155205818804439163810572367791175177756227497413804253387084478193655533"
288        "073867420834526162513029462022730109054820067654020201547112002028139700"
289        "141575259123440177362244273712468151750189745559978653234255886219611516"
290        "335924167958029604477064946470184777360934300451421683607013647479513962"
291        "13837722826145437693412532098591327667236328125",
292        -308, first_normal, second_normal, first_normal);
293    TestHalfwayValue(
294        "1."
295        "797693134862315608353258760581052985162070023416521662616611746258695532"
296        "672923265745300992879465492467506314903358770175220871059269879629062776"
297        "047355692132901909191523941804762171253349609463563872612866401980290377"
298        "995141836029815117562837277714038305214839639239356331336428021390916694"
299        "57927874464075218944",
300        308, penultimate_normal, last_normal, penultimate_normal);
301  }
302  TEST(FromChars, FloatRounding) {
303    const float zero = 0.0;
304    const float first_subnormal = nextafterf(zero, 1.0);
305    const float second_subnormal = nextafterf(first_subnormal, 1.0);
306    const float first_normal = FLT_MIN;
307    const float last_subnormal = nextafterf(first_normal, 0.0);
308    const float second_normal = nextafterf(first_normal, 1.0);
309    const float last_normal = FLT_MAX;
310    const float penultimate_normal = nextafterf(last_normal, 0.0);
311    TestHalfwayValue(
312        "7."
313        "006492321624085354618647916449580656401309709382578858785341419448955413"
314        "42930300743319094181060791015625",
315        -46, zero, first_subnormal, zero);
316    TestHalfwayValue(
317        "2."
318        "101947696487225606385594374934874196920392912814773657635602425834686624"
319        "028790902229957282543182373046875",
320        -45, first_subnormal, second_subnormal, second_subnormal);
321    TestHalfwayValue(
322        "1."
323        "175494280757364291727882991035766513322858992758990427682963118425003064"
324        "9651730385585324256680905818939208984375",
325        -38, last_subnormal, first_normal, first_normal);
326    TestHalfwayValue(
327        "1."
328        "175494420887210724209590083408724842314472120785184615334540294131831453"
329        "9442813071445925743319094181060791015625",
330        -38, first_normal, second_normal, first_normal);
331    TestHalfwayValue("3.40282336497324057985868971510891282432", 38,
332                     penultimate_normal, last_normal, penultimate_normal);
333  }
334  TEST(FromChars, Underflow) {
335    double d;
336    float f;
337    absl::from_chars_result result;
338    std::string negative_underflow = "-1e-1000";
339    const char* begin = negative_underflow.data();
340    const char* end = begin + negative_underflow.size();
341    d = 100.0;
342    result = absl::from_chars(begin, end, d);
343    EXPECT_EQ(result.ptr, end);
344    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
345    EXPECT_TRUE(std::signbit(d));  
346    EXPECT_GE(d, -std::numeric_limits<double>::min());
347    f = 100.0;
348    result = absl::from_chars(begin, end, f);
349    EXPECT_EQ(result.ptr, end);
350    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
351    EXPECT_TRUE(std::signbit(f));  
352    EXPECT_GE(f, -std::numeric_limits<float>::min());
353    std::string positive_underflow = "1e-1000";
354    begin = positive_underflow.data();
355    end = begin + positive_underflow.size();
356    d = -100.0;
357    result = absl::from_chars(begin, end, d);
358    EXPECT_EQ(result.ptr, end);
359    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
360    EXPECT_FALSE(std::signbit(d));  
361    EXPECT_LE(d, std::numeric_limits<double>::min());
362    f = -100.0;
363    result = absl::from_chars(begin, end, f);
364    EXPECT_EQ(result.ptr, end);
365    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
366    EXPECT_FALSE(std::signbit(f));  
367    EXPECT_LE(f, std::numeric_limits<float>::min());
368  }
369  TEST(FromChars, Overflow) {
370    double d;
371    float f;
372    absl::from_chars_result result;
373    std::string negative_overflow = "-1e1000";
374    const char* begin = negative_overflow.data();
375    const char* end = begin + negative_overflow.size();
376    d = 100.0;
377    result = absl::from_chars(begin, end, d);
378    EXPECT_EQ(result.ptr, end);
379    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
380    EXPECT_TRUE(std::signbit(d));  
381    EXPECT_EQ(d, -std::numeric_limits<double>::max());
382    f = 100.0;
383    result = absl::from_chars(begin, end, f);
384    EXPECT_EQ(result.ptr, end);
385    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
386    EXPECT_TRUE(std::signbit(f));  
387    EXPECT_EQ(f, -std::numeric_limits<float>::max());
388    std::string positive_overflow = "1e1000";
389    begin = positive_overflow.data();
390    end = begin + positive_overflow.size();
391    d = -100.0;
392    result = absl::from_chars(begin, end, d);
393    EXPECT_EQ(result.ptr, end);
394    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
395    EXPECT_FALSE(std::signbit(d));  
396    EXPECT_EQ(d, std::numeric_limits<double>::max());
397    f = -100.0;
398    result = absl::from_chars(begin, end, f);
399    EXPECT_EQ(result.ptr, end);
400    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
401    EXPECT_FALSE(std::signbit(f));  
402    EXPECT_EQ(f, std::numeric_limits<float>::max());
403  }
404  TEST(FromChars, RegressionTestsFromFuzzer) {
405    absl::string_view src = "0x21900000p00000000099";
406    float f;
407    auto result = absl::from_chars(src.data(), src.data() + src.size(), f);
408    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
409  }
410  TEST(FromChars, ReturnValuePtr) {
411    double d;
412    absl::from_chars_result result;
413    std::string normal = "3.14@#$%@#$%";
414    result = absl::from_chars(normal.data(), normal.data() + normal.size(), d);
415    EXPECT_EQ(result.ec, std::errc());
416    EXPECT_EQ(result.ptr - normal.data(), 4);
417    std::string overflow = "1e1000@#$%@#$%";
418    result = absl::from_chars(overflow.data(),
419                              overflow.data() + overflow.size(), d);
420    EXPECT_EQ(result.ec, std::errc::result_out_of_range);
421    EXPECT_EQ(result.ptr - overflow.data(), 6);
422    std::string garbage = "#$%@#$%";
423    result = absl::from_chars(garbage.data(),
424                              garbage.data() + garbage.size(), d);
425    EXPECT_EQ(result.ec, std::errc::invalid_argument);
426    EXPECT_EQ(result.ptr - garbage.data(), 0);
427  }
428  TEST(FromChars, TestVersusStrtod) {
429    for (int mantissa = 1000000; mantissa <= 9999999; mantissa += 501) {
430      for (int exponent = -300; exponent < 300; ++exponent) {
431        std::string candidate = absl::StrCat(mantissa, "e", exponent);
432        double strtod_value = strtod(candidate.c_str(), nullptr);
433        double absl_value = 0;
434        absl::from_chars(candidate.data(), candidate.data() + candidate.size(),
435                         absl_value);
436        ASSERT_EQ(strtod_value, absl_value) << candidate;
437      }
438    }
439  }
440  TEST(FromChars, TestVersusStrtof) {
441    for (int mantissa = 1000000; mantissa <= 9999999; mantissa += 501) {
442      for (int exponent = -43; exponent < 32; ++exponent) {
443        std::string candidate = absl::StrCat(mantissa, "e", exponent);
444        float strtod_value = strtof(candidate.c_str(), nullptr);
445        float absl_value = 0;
446        absl::from_chars(candidate.data(), candidate.data() + candidate.size(),
447                         absl_value);
448        ASSERT_EQ(strtod_value, absl_value) << candidate;
449      }
450    }
451  }
452  template <typename Float>
453  bool Identical(Float a, Float b) {
454    return 0 == memcmp(&a, &b, sizeof(Float));
455  }
456  TEST(FromChars, NaNDoubles) {
457    for (std::string n_char_sequence :
458         {"", "1", "2", "3", "fff", "FFF", "200000", "400000", "4000000000000",
459          "8000000000000", "abc123", "legal_but_unexpected",
460          "99999999999999999999999", "_"}) {
461      std::string input = absl::StrCat("nan(", n_char_sequence, ")");
462      SCOPED_TRACE(input);
463      double from_chars_double;
<span onclick='openModal()' class='match'>464      absl::from_chars(input.data(), input.data() + input.size(),
465                       from_chars_double);
466      double std_nan_double = std::nan(n_char_sequence.c_str());
467      EXPECT_TRUE(Identical(from_chars_double, std_nan_double));
468  #if ABSL_STRTOD_HANDLES_NAN_CORRECTLY
469      double strtod_double = strtod(input.c_str(), nullptr);
</span>470      EXPECT_TRUE(Identical(from_chars_double, strtod_double));
471  #endif  
472      std::string negative_input = "-" + input;
473      double negative_from_chars_double;
474      absl::from_chars(negative_input.data(),
475                       negative_input.data() + negative_input.size(),
476                       negative_from_chars_double);
477      EXPECT_TRUE(std::signbit(negative_from_chars_double));
478      EXPECT_FALSE(Identical(negative_from_chars_double, from_chars_double));
479      from_chars_double = std::copysign(from_chars_double, -1.0);
480      EXPECT_TRUE(Identical(negative_from_chars_double, from_chars_double));
481    }
482  }
483  TEST(FromChars, NaNFloats) {
484    for (std::string n_char_sequence :
485         {"", "1", "2", "3", "fff", "FFF", "200000", "400000", "4000000000000",
486          "8000000000000", "abc123", "legal_but_unexpected",
487          "99999999999999999999999", "_"}) {
488      std::string input = absl::StrCat("nan(", n_char_sequence, ")");
489      SCOPED_TRACE(input);
490      float from_chars_float;
491      absl::from_chars(input.data(), input.data() + input.size(),
492                       from_chars_float);
493      float std_nan_float = std::nanf(n_char_sequence.c_str());
494      EXPECT_TRUE(Identical(from_chars_float, std_nan_float));
495  #if ABSL_STRTOD_HANDLES_NAN_CORRECTLY
496      float strtof_float = strtof(input.c_str(), nullptr);
497      EXPECT_TRUE(Identical(from_chars_float, strtof_float));
498  #endif  
499      std::string negative_input = "-" + input;
500      float negative_from_chars_float;
501      absl::from_chars(negative_input.data(),
502                       negative_input.data() + negative_input.size(),
503                       negative_from_chars_float);
504      EXPECT_TRUE(std::signbit(negative_from_chars_float));
505      EXPECT_FALSE(Identical(negative_from_chars_float, from_chars_float));
506      from_chars_float = std::copysign(from_chars_float, -1.0f);
507      EXPECT_TRUE(Identical(negative_from_chars_float, from_chars_float));
508    }
509  }
510  int NextStep(int step) {
511    return step + (step >> 2) + 1;
512  }
513  template <typename Float>
514  void TestOverflowAndUnderflow(
515      const std::function<std::string(int)>& input_generator,
516      const std::function<Float(int)>& expected_generator, int lower_bound,
517      int upper_bound) {
518    int index, step;
519    for (index = lower_bound, step = 1; index < upper_bound;
520         index += step, step = NextStep(step)) {
521      std::string input = input_generator(index);
522      SCOPED_TRACE(input);
523      Float expected = expected_generator(index);
524      Float actual;
525      auto result =
526          absl::from_chars(input.data(), input.data() + input.size(), actual);
527      EXPECT_EQ(result.ec, std::errc());
528      EXPECT_EQ(expected, actual)
529          << absl::StrFormat("%a vs %a", expected, actual);
530    }
531    for (index = upper_bound, step = 1; index > lower_bound;
532         index -= step, step = NextStep(step)) {
533      std::string input = input_generator(index);
534      SCOPED_TRACE(input);
535      Float expected = expected_generator(index);
536      Float actual;
537      auto result =
538          absl::from_chars(input.data(), input.data() + input.size(), actual);
539      EXPECT_EQ(result.ec, std::errc());
540      EXPECT_EQ(expected, actual)
541          << absl::StrFormat("%a vs %a", expected, actual);
542    }
543    for (index = lower_bound - 1, step = 1; index > -1000000;
544         index -= step, step = NextStep(step)) {
545      std::string input = input_generator(index);
546      SCOPED_TRACE(input);
547      Float actual;
548      auto result =
549          absl::from_chars(input.data(), input.data() + input.size(), actual);
550      EXPECT_EQ(result.ec, std::errc::result_out_of_range);
551      EXPECT_LT(actual, 1.0);  
552    }
553    for (index = upper_bound + 1, step = 1; index < 1000000;
554         index += step, step = NextStep(step)) {
555      std::string input = input_generator(index);
556      SCOPED_TRACE(input);
557      Float actual;
558      auto result =
559          absl::from_chars(input.data(), input.data() + input.size(), actual);
560      EXPECT_EQ(result.ec, std::errc::result_out_of_range);
561      EXPECT_GT(actual, 1.0);  
562    }
563  }
564  TEST(FromChars, HexdecimalDoubleLimits) {
565    auto input_gen = [](int index) { return absl::StrCat("0x1.0p", index); };
566    auto expected_gen = [](int index) { return std::ldexp(1.0, index); };
567    TestOverflowAndUnderflow<double>(input_gen, expected_gen, -1074, 1023);
568  }
569  TEST(FromChars, HexdecimalFloatLimits) {
570    auto input_gen = [](int index) { return absl::StrCat("0x1.0p", index); };
571    auto expected_gen = [](int index) { return std::ldexp(1.0f, index); };
572    TestOverflowAndUnderflow<float>(input_gen, expected_gen, -149, 127);
573  }
574  TEST(FromChars, DecimalDoubleLimits) {
575    auto input_gen = [](int index) { return absl::StrCat("1.0e", index); };
576    auto expected_gen = [](int index) { return Pow10(index); };
577    TestOverflowAndUnderflow<double>(input_gen, expected_gen, -323, 308);
578  }
579  TEST(FromChars, DecimalFloatLimits) {
580    auto input_gen = [](int index) { return absl::StrCat("1.0e", index); };
581    auto expected_gen = [](int index) { return Pow10(index); };
582    TestOverflowAndUnderflow<float>(input_gen, expected_gen, -45, 38);
583  }
584  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ligature_table.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>90    UNICHAR::const_iterator it_begin = UNICHAR::begin(str.c_str(), str.length());
91    UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
92    char tmp[5];
93    int len;
94    int norm_ind;
</pre></code></div>
                <div class="column column_space"><pre><code>464      absl::from_chars(input.data(), input.data() + input.size(),
465                       from_chars_double);
466      double std_nan_double = std::nan(n_char_sequence.c_str());
467      EXPECT_TRUE(Identical(from_chars_double, std_nan_double));
468  #if ABSL_STRTOD_HANDLES_NAN_CORRECTLY
469      double strtod_double = strtod(input.c_str(), nullptr);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    