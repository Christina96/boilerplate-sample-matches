
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.837338262476895%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-sgd_solver.cpp</h3>
            <pre><code>1  #include <string>
2  #include <vector>
3  #include "caffe/sgd_solvers.hpp"
4  #include "caffe/util/hdf5.hpp"
5  #include "caffe/util/io.hpp"
6  #include "caffe/util/upgrade_proto.hpp"
7  namespace caffe {
8  #ifdef CAFFE_PER_LAYER_TIMINGS
9  #define LAYER_UPDATE_TIMING_START(index) do { \
10    if (this->net()->phase() == TRAIN) { \
11      this->net()->update_start_time_per_layer[index] = this->net()->timer.Duration(); \
12    } \
13  }while(0)
14  #define LAYER_UPDATE_TIMING_STOP(index) do { \
15    if (this->net()->phase() == TRAIN) { \
16      this->net()->update_stop_time_per_layer[index] = this->net()->timer.Duration(); \
17      this->net()->update_time_per_layer[index] += (this->net()->update_stop_time_per_layer[index] - this->net()->update_start_time_per_layer[index]); \
18    } \
19  }while(0)
20  #else
21  #define LAYER_UPDATE_TIMING_START(index)
22  #define LAYER_UPDATE_TIMING_STOP(index)
23  #endif
24  template <typename Dtype>
25  Dtype SGDSolver<Dtype>::GetWarmUpLR(int cur_iter, int warmup_iter, Dtype warmup_start_lr) {
26    if (cur_iter < 0) {
27      cur_iter = 0;
28    }
29    return (cur_iter * this->param_.base_lr() +
30            (warmup_iter - cur_iter) * warmup_start_lr) / warmup_iter;
31  }
32  template <typename Dtype>
33  Dtype SGDSolver<Dtype>::GetLearningRate() {
34    Dtype rate;
35    const string& lr_policy = this->param_.lr_policy();
36    if (this->param_.warmup_iter() > 0 &&
37        this->iter_ < this->param_.warmup_iter()) {
38      rate = GetWarmUpLR(this->iter_, this->param_.warmup_iter(),
39                         this->param_.warmup_start_lr());
40    } else if (lr_policy == "fixed") {
41      rate = this->param_.base_lr();
42    } else if (lr_policy == "step") {
43      this->current_step_ = this->iter_ / this->param_.stepsize();
44      rate = this->param_.base_lr() *
45          pow(this->param_.gamma(), this->current_step_);
46    } else if (lr_policy == "exp") {
47      rate = this->param_.base_lr() * pow(this->param_.gamma(), this->iter_);
48    } else if (lr_policy == "inv") {
49      rate = this->param_.base_lr() *
50          pow(Dtype(1) + this->param_.gamma() * this->iter_,
51              - this->param_.power());
52    } else if (lr_policy == "multistep") {
53      if (this->current_step_ < this->param_.stepvalue_size() &&
54            this->iter_ >= this->param_.stepvalue(this->current_step_)) {
55        this->current_step_++;
56        LOG(INFO) << "MultiStep Status: Iteration " <<
57        this->iter_ << ", step = " << this->current_step_;
58      }
59      rate = this->param_.base_lr() *
60          pow(this->param_.gamma(), this->current_step_);
61    } else if (lr_policy == "poly") {
62      rate = this->param_.base_lr() * pow(Dtype(1.) -
63          (Dtype(this->iter_) / Dtype(this->param_.max_iter())),
64          this->param_.power());
65    } else if (lr_policy == "sigmoid") {
66      rate = this->param_.base_lr() * (Dtype(1.) /
67          (Dtype(1.) + exp(-this->param_.gamma() * (Dtype(this->iter_) -
68            Dtype(this->param_.stepsize())))));
69    } else if (lr_policy == "plateau") {
70      if (this->smoothed_loss_ < this->minimum_loss_) {
71        this->minimum_loss_ = this->smoothed_loss_;
72        this->iter_last_event_ = this->iter_;
73      }
74      if (this->current_step_ < this->param_.plateau_winsize_size()) {
75        int iter_next_update = this->iter_last_event_
76              + this->param_.plateau_winsize(this->current_step_);
77        if (this->iter_ >= iter_next_update) {
78          this->current_step_++;
79          this->iter_last_event_ = this->iter_;
80          LOG(INFO) << "Plateau Status: Iteration " << this->iter_
81                    << ", step = " << this->current_step_;
82        }
83      }
84      if (this->param_.display() && this->iter_ % this->param_.display() == 0
85          && this->iter_last_event_ > (this->iter_ - this->param_.display())) {
86        LOG(INFO) << "Plateau Status: Iteration " << this->iter_
87                  << ", current minimum_loss = " << this->minimum_loss_;
88      }
89      rate = this->param_.base_lr() *
90          pow(this->param_.gamma(), this->current_step_);
91    } else if (lr_policy == "multifixed") {
92        CHECK_EQ(this->param_.stageiter_size(), this->param_.stagelr_size());
93        int num_stages = this->param_.stagelr_size();
94        int stage = 0;
95        for (; stage < num_stages; ++stage) {
96            if (this->iter_ <= this->param_.stageiter(stage))
97                break;
98        }
99        stage = (stage == num_stages) ? stage - 1 : stage;
100        rate = this->param_.stagelr(stage);
101    } else {
102      LOG(FATAL) << "Unknown learning rate policy: " << lr_policy;
103    }
104    return rate;
105  }
106  template <typename Dtype>
107  void SGDSolver<Dtype>::PreSolve() {
108    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
109    history_.clear();
110    update_.clear();
111    temp_.clear();
112    for (int i = 0; i < net_params.size(); ++i) {
113      const vector<int>& shape = net_params[i]->shape();
114      history_.push_back(shared_ptr<Blob<Dtype> >(new Blob<Dtype>(shape)));
115      update_.push_back(shared_ptr<Blob<Dtype> >(new Blob<Dtype>(shape)));
116      temp_.push_back(shared_ptr<Blob<Dtype> >(new Blob<Dtype>(shape)));
117    }
118    this->minimum_loss_ = std::numeric_limits<float>::max();
119  }
120  template <typename Dtype>
121  void SGDSolver<Dtype>::ClipGradients() {
122    const Dtype clip_gradients = this->param_.clip_gradients();
123    if (clip_gradients < 0) { return; }
124    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
125    Dtype sumsq_diff = 0;
126    for (int i = 0; i < net_params.size(); ++i) {
127      sumsq_diff += net_params[i]->sumsq_diff();
128    }
129    const Dtype l2norm_diff = std::sqrt(sumsq_diff);
130    if (l2norm_diff > clip_gradients) {
131      Dtype scale_factor = clip_gradients / l2norm_diff;
132      LOG(INFO) << "Gradient clipping: scaling down gradients (L2 norm "
133          << l2norm_diff << " > " << clip_gradients << ") "
134          << "by scale factor " << scale_factor;
135      for (int i = 0; i < net_params.size(); ++i) {
136        net_params[i]->scale_diff(scale_factor);
137      }
138    }
139  }
140  template <typename Dtype>
141  void SGDSolver<Dtype>::PrintLearningRate() {
142    CHECK(Caffe::root_solver());
143    Dtype rate = GetLearningRate();
144    if (this->param_.display() && this->iter_ % this->param_.display() == 0) {
145      LOG(INFO) << "Iteration " << this->iter_ << ", lr = " << rate;
146    }
147  }
148  template <typename Dtype>
149  void SGDSolver<Dtype>::ApplyUpdate() {
150    PrintLearningRate();
151    ClipGradients();
152  #ifdef CAFFE_PER_LAYER_TIMINGS
153  #ifdef USE_MLSL
154    CHECK(mn::is_multinode() == false);
155  #endif
156    for (int i=0; i<this->net_->layers().size(); i++) {
157      const std::vector<int> param_ids = this->net_->get_layer_learnable_param_ids(i);
158      LAYER_UPDATE_TIMING_START(i);
159      for (int param_id = 0; param_id < param_ids.size(); ++param_id) {
160        ApplyUpdate(param_ids[param_id]);
161      }
162      LAYER_UPDATE_TIMING_STOP(i);
163    }
164  #else
165    for (int param_id = 0; param_id < this->net_->learnable_params().size();
166         ++param_id) {
167      ApplyUpdate(param_id);
168    }
169  #endif
170  }
171  template <typename Dtype>
172  void SGDSolver<Dtype>::ApplyUpdate(int param_id) {
173    CHECK(Caffe::root_solver());
174    Dtype rate = GetLearningRate();
175    LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], diff, param_id, "ApplyUpdate: raw delwt:");
176    if (this->net_->params_lr()[param_id] == 0) {
177      return;
178    }
179  #ifdef ENABLE_SGD_FUSION
180    if ((Caffe::mode() == Caffe::CPU) && (this->type() == string("SGD")))
181    {
182      SGDFusion(param_id, rate);
183      return;
184    }
185  #endif &bsol;* ENABLE_SGD_FUSION */
186    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
187    bool need_sync_data_back_to_prv = false;
188    bool need_sync_diff_back_to_prv = false;
189    if (net_params[param_id]->prv_data()
190        && (net_params[param_id]->prv_data_count()
191            != net_params[param_id]->count())) {
192      need_sync_data_back_to_prv = true;
193    }
194    if (net_params[param_id]->prv_diff()
195        && (net_params[param_id]->prv_diff_count()
196            != net_params[param_id]->count())) {
197      need_sync_diff_back_to_prv = true;
198    }
199    Normalize(param_id);
200    LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], diff, param_id, "ApplyUpdate: delwt after Normalize:");
201    if (strcmp(this->type(), "SGD")) {
202      Regularize(param_id);
203      LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], diff, param_id, "ApplyUpdate: delwt after Regularize:");
204    }
205    ComputeUpdateValue(param_id, rate);
206    LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], diff, param_id, "ApplyUpdate: wtinc:");
207    LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], data, param_id, "ApplyUpdate: weight before update:");
208    this->net_->learnable_params()[param_id]->Update();
209    if (need_sync_diff_back_to_prv) {
210      net_params[param_id]->mutable_prv_diff();
211    }
212    if (need_sync_data_back_to_prv) {
213      net_params[param_id]->mutable_prv_data();
214    }
215    LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], data, param_id, "ApplyUpdate: weight after update:");
216  }
217  #ifdef ENABLE_SGD_FUSION
218  template <typename Dtype>
219  void axpy_axpby_copy(size_t count, const Dtype decay, const Dtype* net_params_data, Dtype *net_params_diff,
220                       const Dtype rate, const Dtype momentum, Dtype* history_data);
221  template <>
222  void axpy_axpby_copy<float>(size_t count, const float decay, const float* net_params_data, float *net_params_diff,
223                              const float rate, const float momentum, float* history_data)
224  {
225  #ifdef _OPENMP
226  #pragma omp parallel for simd schedule(static)
227  #endif  
228    for (size_t i = 0; i < count; ++i) {
229      history_data[i] = rate * (decay * net_params_data[i] + net_params_diff[i]) + momentum * history_data[i];
230      net_params_diff[i] = history_data[i];
231    }
232  }
233  template <>
234  void axpy_axpby_copy<double>(size_t count, const double decay, const double* net_params_data, double *net_params_diff,
235                               const double rate, const double momentum, double* history_data)
236  {
237  #ifdef _OPENMP
238  #pragma omp parallel for simd schedule(static)
239  #endif  
240    for (size_t i = 0; i < count; ++i) {
241      history_data[i] = rate * (decay * net_params_data[i] + net_params_diff[i]) + momentum * history_data[i];
242      net_params_diff[i] = history_data[i];
243    }
244  }
245  template <typename Dtype>
246  void axpy_axpby_copy_axpy(size_t count, const Dtype decay, Dtype* net_params_data, Dtype *net_params_diff,
247                       const Dtype rate, const Dtype momentum, Dtype* history_data, const Dtype update_param);
248  template <>
249  void axpy_axpby_copy_axpy<float>(size_t count, const float decay, float* net_params_data, float *net_params_diff,
250                              const float rate, const float momentum, float* history_data, const float update_param)
251  {
252  #ifdef _OPENMP
253  #pragma omp parallel for simd schedule(static)
254  #endif  
255    for (size_t i = 0; i < count; ++i) {
256      history_data[i] = rate * (decay * net_params_data[i] + net_params_diff[i]) + momentum * history_data[i];
257      net_params_data[i] = update_param * history_data[i] + net_params_data[i];
258    }
259  }
260  template <>
261  void axpy_axpby_copy_axpy<double>(size_t count, const double decay, double* net_params_data, double *net_params_diff,
262                               const double rate, const double momentum, double* history_data, const double update_param)
263  {
264  #ifdef _OPENMP
265  #pragma omp parallel for simd schedule(static)
266  #endif  
267    for (size_t i = 0; i < count; ++i) {
268      history_data[i] = rate * (decay * net_params_data[i] + net_params_diff[i]) + momentum * history_data[i];
269      net_params_data[i] = update_param * history_data[i] + net_params_data[i];
270    }
271  }
272  template <typename Dtype>
273  void SGDSolver<Dtype>::SGDFusion(int param_id, Dtype rate) {
274    bool skip_Normalize_stage_flag = false;
275    if (this->param_.iter_size() == 1) { skip_Normalize_stage_flag = true; }
276    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
277    const vector<float>& net_params_weight_decay =
278      this->net_->params_weight_decay();
279    Dtype weight_decay = this->param_.weight_decay();
280    string regularization_type = this->param_.regularization_type();
281    Dtype local_decay = weight_decay * net_params_weight_decay[param_id];
282    Dtype momentum = this->param_.momentum();
283    bool prv_diff_condition_flag = false;
284    bool need_sync_data_back_to_prv = false;
285    bool need_sync_diff_back_to_prv = false;
286    if (net_params[param_id]->prv_diff()
287      && (net_params[param_id]->prv_diff_count()
288      == net_params[param_id]->count())) {
289        prv_diff_condition_flag = true;
290    }
291    if (net_params[param_id]->prv_diff()
292      && (net_params[param_id]->prv_diff_count()
293      != net_params[param_id]->count())) {
294        need_sync_diff_back_to_prv = true;
295    }
296    if (net_params[param_id]->prv_data()
297      && (net_params[param_id]->prv_data_count()
298      != net_params[param_id]->count())) {
299        need_sync_data_back_to_prv = true;
300    }
301    if (skip_Normalize_stage_flag == false)
302    {
303      const Dtype accum_normalization = Dtype(1.) / this->param_.iter_size();
304      if (prv_diff_condition_flag) {
305        caffe_scal(net_params[param_id]->prv_diff_count(), accum_normalization,
306          net_params[param_id]->mutable_prv_diff());
307      }
308      else {
309        caffe_scal(net_params[param_id]->count(), accum_normalization,
310          net_params[param_id]->mutable_cpu_diff());
311      }
312    }
313    Dtype local_rate = rate * GetLocalRate(param_id);
314    bool is_separate_ComputeUpdateValue_Update = true;
315    if (local_decay) {
316      if (regularization_type == "L2") {
317        if (net_params[param_id]->prv_data() && net_params[param_id]->prv_diff()
318          && (net_params[param_id]->prv_data_count()
319          == net_params[param_id]->count()) &&
320              net_params[param_id]->get_prv_data_descriptor()->layout_compare(
321              net_params[param_id]->get_prv_diff_descriptor())) {
322            if (prv_diff_condition_flag) {
323              axpy_axpby_copy_axpy(net_params[param_id]->prv_data_count(), local_decay,
324                                  net_params[param_id]->mutable_prv_data(), net_params[param_id]->mutable_prv_diff(),
325                                  local_rate, momentum, history_[param_id]->mutable_cpu_data(), Dtype(-1));
326              is_separate_ComputeUpdateValue_Update = false;
327            }
328        } else {
329          if (!prv_diff_condition_flag)
330          {
331            axpy_axpby_copy_axpy(net_params[param_id]->count(), local_decay,
332                                  net_params[param_id]->mutable_cpu_data(), net_params[param_id]->mutable_cpu_diff(),
333                                  local_rate, momentum, history_[param_id]->mutable_cpu_data(), Dtype(-1));
334            is_separate_ComputeUpdateValue_Update = false;
335          }
336        }
337      } else if (regularization_type == "L1") {
338        caffe_cpu_sign(net_params[param_id]->count(),
339                        net_params[param_id]->cpu_data(),
340                        temp_[param_id]->mutable_cpu_data());
341        axpy_axpby_copy(net_params[param_id]->count(), local_decay,
342                                  temp_[param_id]->cpu_data(), net_params[param_id]->mutable_cpu_diff(),
343                                  local_rate, momentum, history_[param_id]->mutable_cpu_data());
344        is_separate_ComputeUpdateValue_Update = false;
345        net_params[param_id]->Update();
346      } else {
347        LOG(FATAL) << "Unknown regularization type: " << regularization_type;
348      }
349    }
350    if (is_separate_ComputeUpdateValue_Update == true)
351    {
352      if (prv_diff_condition_flag) {
353        caffe_cpu_axpby(net_params[param_id]->prv_diff_count(), local_rate,
354                        net_params[param_id]->prv_diff(), momentum,
355                        history_[param_id]->mutable_cpu_data());
356        caffe_copy(net_params[param_id]->count(),
357                    history_[param_id]->cpu_data(),
358                    net_params[param_id]->mutable_prv_diff());
359      } else {
360        caffe_cpu_axpby(net_params[param_id]->count(), local_rate,
361                        net_params[param_id]->cpu_diff(), momentum,
362                        history_[param_id]->mutable_cpu_data());
363        caffe_copy(net_params[param_id]->count(),
364                    history_[param_id]->cpu_data(),
365                    net_params[param_id]->mutable_cpu_diff());
366      }
367      net_params[param_id]->Update();
368    }
369    if (need_sync_data_back_to_prv) {
370      net_params[param_id]->mutable_prv_data();
371    }
372    if (need_sync_diff_back_to_prv) {
373      net_params[param_id]->mutable_prv_diff();
374    }
375  }
376  #endif &bsol;* ENABLE_SGD_FUSION */
377  template <typename Dtype>
378  void SGDSolver<Dtype>::Normalize(int param_id) {
379    if (this->param_.iter_size() == 1) { 
380      return;
381    }
382    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
383    const Dtype accum_normalization = Dtype(1.) / this->param_.iter_size();
384    switch (Caffe::mode()) {
385    case Caffe::CPU: {
386      if (net_params[param_id]->prv_diff()
387          && (net_params[param_id]->prv_diff_count()
388              == net_params[param_id]->count())) {
389          caffe_scal(net_params[param_id]->prv_diff_count(), accum_normalization,
390              net_params[param_id]->mutable_prv_diff());
391      }
392      else {
393          caffe_scal(net_params[param_id]->count(), accum_normalization,
394              net_params[param_id]->mutable_cpu_diff());
395      }
396      break;
397    }
398    case Caffe::GPU: {
399  #ifndef CPU_ONLY
400      caffe_gpu_scal(net_params[param_id]->count(), accum_normalization,
401          net_params[param_id]->mutable_gpu_diff());
402  #else
403      NO_GPU;
404  #endif
405      break;
406    }
407    default:
408      LOG(FATAL) << "Unknown caffe mode: " << Caffe::mode();
409    }
410  }
411  template <typename Dtype>
412  void SGDSolver<Dtype>::Regularize(int param_id) {
413    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
414    const vector<float>& net_params_weight_decay =
415        this->net_->params_weight_decay();
416    Dtype weight_decay = this->param_.weight_decay();
417    string regularization_type = this->param_.regularization_type();
418    Dtype local_decay = weight_decay * net_params_weight_decay[param_id];
419    switch (Caffe::mode()) {
420    case Caffe::CPU: {
421      if (local_decay) {
422        if (regularization_type == "L2") {
423          if (net_params[param_id]->prv_data() && net_params[param_id]->prv_diff()
424               && (net_params[param_id]->prv_data_count()
425                   == net_params[param_id]->count()) &&
426              net_params[param_id]->get_prv_data_descriptor()->layout_compare(
427              net_params[param_id]->get_prv_diff_descriptor())) {
428            caffe_axpy(net_params[param_id]->prv_data_count(),
429                       local_decay,
430                       net_params[param_id]->prv_data(),
431                       net_params[param_id]->mutable_prv_diff());
432          } else {
433            caffe_axpy(net_params[param_id]->count(),
434                local_decay,
435                net_params[param_id]->cpu_data(),
436                net_params[param_id]->mutable_cpu_diff());
437          }
438        } else if (regularization_type == "L1") {
439          caffe_cpu_sign(net_params[param_id]->count(),
440              net_params[param_id]->cpu_data(),
441              temp_[param_id]->mutable_cpu_data());
442          caffe_axpy(net_params[param_id]->count(),
443              local_decay,
444              temp_[param_id]->cpu_data(),
445              net_params[param_id]->mutable_cpu_diff());
446        } else {
447          LOG(FATAL) << "Unknown regularization type: " << regularization_type;
448        }
449      }
450      break;
451    }
452    case Caffe::GPU: {
453  #ifndef CPU_ONLY
454      if (local_decay) {
455        if (regularization_type == "L2") {
456          caffe_gpu_axpy(net_params[param_id]->count(),
457              local_decay,
458              net_params[param_id]->gpu_data(),
459              net_params[param_id]->mutable_gpu_diff());
460        } else if (regularization_type == "L1") {
461          caffe_gpu_sign(net_params[param_id]->count(),
462              net_params[param_id]->gpu_data(),
463              temp_[param_id]->mutable_gpu_data());
464          caffe_gpu_axpy(net_params[param_id]->count(),
465              local_decay,
466              temp_[param_id]->gpu_data(),
467              net_params[param_id]->mutable_gpu_diff());
468        } else {
469          LOG(FATAL) << "Unknown regularization type: " << regularization_type;
470        }
471      }
472  #else
473      NO_GPU;
474  #endif
475      break;
476    }
477    default:
478      LOG(FATAL) << "Unknown caffe mode: " << Caffe::mode();
479    }
480  }
481  #ifndef CPU_ONLY
482  template <typename Dtype>
483  void sgd_update_gpu(int N, Dtype* g, Dtype* h, Dtype momentum,
484      Dtype local_rate);
485  #endif
486  template <typename Dtype>
487  void SGDSolver<Dtype>::ComputeUpdateValue(int param_id, Dtype rate) {
488    const vector<Blob<Dtype>*>& net_params = this->net_->learnable_params();
489    Dtype momentum = this->param_.momentum();
490    Dtype local_rate = rate * GetLocalRate(param_id);
491    Regularize(param_id);
492    LOG_PARAM_BLOB(this->net_->learnable_params()[param_id], diff, param_id, "ApplyUpdate: delwt after Regularize:");
493    if (this->param_.warmup_iter() > 0 &&
494        this->iter_ < this->param_.warmup_iter()) {
495      Dtype prev_rate = GetWarmUpLR(this->iter_ - 1, this->param_.warmup_iter(),
496                                    this->param_.warmup_start_lr());
497      momentum = momentum * (rate / prev_rate);
498    }
499    switch (Caffe::mode()) {
500    case Caffe::CPU: {
501      if (net_params[param_id]->prv_diff()
502          && (net_params[param_id]->prv_diff_count()
503              == net_params[param_id]->count())) {
504        caffe_cpu_axpby(net_params[param_id]->prv_diff_count(), local_rate,
505                        net_params[param_id]->prv_diff(), momentum,
506                        history_[param_id]->mutable_cpu_data());
507        caffe_copy(net_params[param_id]->count(),
508                   history_[param_id]->cpu_data(),
509                   net_params[param_id]->mutable_prv_diff());
510      } else {
511        caffe_cpu_axpby(net_params[param_id]->count(), local_rate,
512                       net_params[param_id]->cpu_diff(), momentum,
513                       history_[param_id]->mutable_cpu_data());
514        caffe_copy(net_params[param_id]->count(),
515                   history_[param_id]->cpu_data(),
516                   net_params[param_id]->mutable_cpu_diff());
517      }
518      break;
519    }
520    case Caffe::GPU: {
521  #ifndef CPU_ONLY
522      sgd_update_gpu(net_params[param_id]->count(),
523          net_params[param_id]->mutable_gpu_diff(),
524          history_[param_id]->mutable_gpu_data(),
525          momentum, local_rate);
526  #else
527      NO_GPU;
528  #endif
529      break;
530    }
531    default:
532      LOG(FATAL) << "Unknown caffe mode: " << Caffe::mode();
533    }
534  }
535  template <typename Dtype>
536  Dtype SGDSolver<Dtype>::GetLocalRate(int param_id) const {
537    const vector<float>& net_params_lr = this->net_->params_lr();
538    float local_lr = net_params_lr[param_id];
539    if (this->param_.local_lr_auto()) {
540      Blob<Dtype>* param = this->net_->learnable_params()[param_id];
541      const float w_norm = std::sqrt(param->sumsq_data());
542      const float wgrad_norm = std::sqrt(param->sumsq_diff());
543      const float gw_ratio = this->param_.local_gw_ratio();
544      float rate = 1.F;
545      float weight_decay = this->param_.weight_decay();
546      if (w_norm > 0.F && wgrad_norm > 0.F) {
547        rate = gw_ratio * w_norm / (wgrad_norm + weight_decay * w_norm);
548      }
549      if (local_lr > 0.F) {
550        local_lr = rate;
551      }
552  #ifdef DEBUG
553      if (Caffe::root_solver()
554          && this->param_.display()
555          && (this->iter_ % this->param_.display() == 0)) {
<span onclick='openModal()' class='match'>556        const int layer_id = this->net_->param_layer_indices(param_id).first;
557        const string& layer_name = this->net_->layer_names()[layer_id];
558        const int blob_id = this->net_->param_layer_indices(param_id).second;
559        LOG(INFO) << layer_name << "." << blob_id << " lr=" << local_lr
560          << ".\t  w=" << w_norm << "\t  dw=" << wgrad_norm;
561      }
562  #endif
563    }
</span>564    return local_lr;
565  }
566  template <typename Dtype>
567  void SGDSolver<Dtype>::SnapshotSolverState(const string& model_filename) {
568    switch (this->param_.snapshot_format()) {
569      case caffe::SolverParameter_SnapshotFormat_BINARYPROTO:
570        SnapshotSolverStateToBinaryProto(model_filename);
571        break;
572      case caffe::SolverParameter_SnapshotFormat_HDF5:
573        SnapshotSolverStateToHDF5(model_filename);
574        break;
575      default:
576        LOG(FATAL) << "Unsupported snapshot format.";
577    }
578  }
579  template <typename Dtype>
580  void SGDSolver<Dtype>::SnapshotSolverStateToBinaryProto(
581      const string& model_filename) {
582  #ifdef USE_MLSL
583    if (mn::is_root()) {
584  #endif
585    SolverState state;
586    state.set_iter(this->iter_);
587    state.set_learned_net(model_filename);
588    state.set_current_step(this->current_step_);
589    state.set_iter_last_event(this->iter_last_event_);
590    state.set_minimum_loss(this->minimum_loss_);
591    state.clear_history();
592    for (int i = 0; i < history_.size(); ++i) {
593      BlobProto* history_blob = state.add_history();
594      history_[i]->ToProto(history_blob);
595    }
596    string snapshot_filename = Solver<Dtype>::SnapshotFilename(".solverstate");
597    LOG(INFO)
598      << "Snapshotting solver state to binary proto file " << snapshot_filename;
599    WriteProtoToBinaryFile(state, snapshot_filename.c_str());
600  #ifdef USE_MLSL
601    }
602  #endif
603  }
604  template <typename Dtype>
605  void SGDSolver<Dtype>::SnapshotSolverStateToHDF5(
606      const string& model_filename) {
607  #ifdef USE_MLSL
608    if (mn::is_root()) {
609  #endif
610    string snapshot_filename =
611        Solver<Dtype>::SnapshotFilename(".solverstate.h5");
612    LOG(INFO) << "Snapshotting solver state to HDF5 file " << snapshot_filename;
613    hid_t file_hid = H5Fcreate(snapshot_filename.c_str(), H5F_ACC_TRUNC,
614        H5P_DEFAULT, H5P_DEFAULT);
615    CHECK_GE(file_hid, 0)
616        << "Couldn't open " << snapshot_filename << " to save solver state.";
617    hdf5_save_int(file_hid, "iter", this->iter_);
618    hdf5_save_string(file_hid, "learned_net", model_filename);
619    hdf5_save_int(file_hid, "current_step", this->current_step_);
620    hdf5_save_int(file_hid, "iter_last_event", this->iter_last_event_);
621    hdf5_save_float<Dtype>(file_hid, "minimum_loss", this->minimum_loss_);
622    hid_t history_hid = H5Gcreate2(file_hid, "history", H5P_DEFAULT, H5P_DEFAULT,
623        H5P_DEFAULT);
624    CHECK_GE(history_hid, 0)
625        << "Error saving solver state to " << snapshot_filename << ".";
626    for (int i = 0; i < history_.size(); ++i) {
627      ostringstream oss;
628      oss << i;
629      hdf5_save_nd_dataset<Dtype>(history_hid, oss.str(), *history_[i]);
630    }
631    H5Gclose(history_hid);
632    H5Fclose(file_hid);
633  #ifdef USE_MLSL
634    }
635  #endif
636  }
637  template <typename Dtype>
638  void SGDSolver<Dtype>::RestoreSolverStateFromBinaryProto(
639      const string& state_file) {
640    SolverState state;
641    ReadProtoFromBinaryFile(state_file, &state);
642    this->iter_ = state.iter();
643    if (state.has_learned_net()) {
644      NetParameter net_param;
645      ReadNetParamsFromBinaryFileOrDie(state.learned_net().c_str(), &net_param);
646      this->net_->CopyTrainedLayersFrom(net_param);
647    }
648    this->current_step_ = state.current_step();
649    this->iter_last_event_ = state.iter_last_event();
650    this->minimum_loss_ = state.minimum_loss();
651    CHECK_EQ(state.history_size(), history_.size())
652        << "Incorrect length of history blobs.";
653    LOG(INFO) << "SGDSolver: restoring history";
654    for (int i = 0; i < history_.size(); ++i) {
655      history_[i]->FromProto(state.history(i));
656    }
657  }
658  template <typename Dtype>
659  void SGDSolver<Dtype>::RestoreSolverStateFromHDF5(const string& state_file) {
660    hid_t file_hid = H5Fopen(state_file.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
661    CHECK_GE(file_hid, 0) << "Couldn't open solver state file " << state_file;
662    this->iter_ = hdf5_load_int(file_hid, "iter");
663    if (H5LTfind_dataset(file_hid, "learned_net")) {
664      string learned_net = hdf5_load_string(file_hid, "learned_net");
665      this->net_->CopyTrainedLayersFrom(learned_net);
666    }
667    this->current_step_ = hdf5_load_int(file_hid, "current_step");
668    this->iter_last_event_ = hdf5_load_int(file_hid, "iter_last_event");
669    this->minimum_loss_ = hdf5_load_float<Dtype>(file_hid, "minimum_loss");
670    hid_t history_hid = H5Gopen2(file_hid, "history", H5P_DEFAULT);
671    CHECK_GE(history_hid, 0) << "Error reading history from " << state_file;
672    int state_history_size = hdf5_get_num_links(history_hid);
673    CHECK_EQ(state_history_size, history_.size())
674        << "Incorrect length of history blobs.";
675    for (int i = 0; i < history_.size(); ++i) {
676      ostringstream oss;
677      oss << i;
678      hdf5_load_nd_dataset<Dtype>(history_hid, oss.str().c_str(), 0,
679                                  kMaxBlobAxes, history_[i].get());
680    }
681    H5Gclose(history_hid);
682    H5Fclose(file_hid);
683  }
684  INSTANTIATE_CLASS(SGDSolver);
685  REGISTER_SOLVER_CLASS(SGD);
686  }  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</h3>
            <pre><code>1  #include <deque>
2  #include <algorithm>
3  #include <time.h>
4  #include <locale>
5  #include <codecvt>
6  #include <sys/stat.h>
7  #include "Buffer.h"
8  #include "Scintilla.h"
9  #include "ILexer.h"
10  #include "Lexilla.h"
11  #include "Parameters.h"
12  #include "Notepad_plus.h"
13  #include "ScintillaEditView.h"
14  #include "EncodingMapper.h"
15  #include "uchardet.h"
16  #include "FileInterface.h"
17  static const int blockSize = 128 * 1024 + 4;
18  static const int CR = 0x0D;
19  static const int LF = 0x0A;
20  long Buffer::_recentTagCtr = 0;
21  namespace 
22  {
23  	static EolType getEOLFormatForm(const char* const data, size_t length, EolType defvalue = EolType::osdefault)
24  	{
25  		assert(length == 0 || (data != nullptr && "invalid buffer for getEOLFormatForm()"));
26  		for (size_t i = 0; i != length; ++i)
27  		{
28  			if (data[i] == CR)
29  			{
30  				if (i + 1 < length && data[i + 1] == LF)
31  					return EolType::windows;
32  				return EolType::macos;
33  			}
34  			if (data[i] == LF)
35  				return EolType::unix;
36  		}
37  		return defvalue; 
38  	}
39  } 
40  Buffer::Buffer(FileManager * pManager, BufferID id, Document doc, DocFileStatus type, const TCHAR *fileName, bool isLargeFile)
41  	: _pManager(pManager) , _id(id), _doc(doc), _lang(L_TEXT), _isLargeFile(isLargeFile)
42  {
43  	NppParameters& nppParamInst = NppParameters::getInstance();
44  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
45  	_eolFormat = ndds._format;
46  	_unicodeMode = ndds._unicodeMode;
47  	_encoding = ndds._codepage;
48  	if (_encoding != -1)
49  		_unicodeMode = uniCookie;
50  	_currentStatus = type;
51  	setFileName(fileName);
52  	updateTimeStamp();
53  	checkFileState();
54  	_canNotify = true;
55  }
56  void Buffer::doNotify(int mask)
57  {
58  	if (_canNotify)
59  	{
60  		assert(_pManager != nullptr);
61  		_pManager->beNotifiedOfBufferChange(this, mask);
62  	}
63  }
64  void Buffer::setDirty(bool dirty)
65  {
66  	_isDirty = dirty;
67  	doNotify(BufferChangeDirty);
68  }
69  void Buffer::setEncoding(int encoding)
70  {
71  	_encoding = encoding;
72  	doNotify(BufferChangeUnicode | BufferChangeDirty);
73  }
74  void Buffer::setUnicodeMode(UniMode mode)
75  {
76  	_unicodeMode = mode;
77  	doNotify(BufferChangeUnicode | BufferChangeDirty);
78  }
79  void Buffer::setLangType(LangType lang, const TCHAR* userLangName)
80  {
81  	if (lang == _lang && lang != L_USER)
82  		return;
83  	_lang = lang;
84  	if (_lang == L_USER)
85  		_userLangExt = userLangName;
86  	_needLexer = true;	
87  	doNotify(BufferChangeLanguage|BufferChangeLexing);
88  }
89  void Buffer::updateTimeStamp()
90  {
91  	FILETIME timeStampLive = {};
92  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
93  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
94  	{
95  		timeStampLive = attributes.ftLastWriteTime;
96  	}
97  	LONG res = CompareFileTime(&_timeStamp, &timeStampLive);
98  	if (res == -1 || res == 1)
99  	{
100  		if (res == 1)
101  		{
102  			NppParameters& nppParam = NppParameters::getInstance();
103  			if (nppParam.doNppLogNetworkDriveIssue())
104  			{
105  				generic_string issueFn = nppLogNetworkDriveIssue;
106  				issueFn += TEXT(".log");
107  				generic_string nppIssueLog = nppParam.getUserPath();
108  				pathAppend(nppIssueLog, issueFn);
109  				std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
110  				std::string msg = converter.to_bytes(_fullPathName);
111  				char buf[1024];
112  				sprintf(buf, "  in updateTimeStamp(): timeStampLive (%lu/%lu) < _timeStamp (%lu/%lu)", timeStampLive.dwLowDateTime, timeStampLive.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
113  				msg += buf;
114  				writeLog(nppIssueLog.c_str(), msg.c_str());
115  			}
116  		}
117  		_timeStamp = timeStampLive;
118  		doNotify(BufferChangeTimestamp);
119  	}
120  }
121  void Buffer::setFileName(const TCHAR *fn)
122  {
123  	NppParameters& nppParamInst = NppParameters::getInstance();
124  	if (_fullPathName == fn)
125  	{
126  		updateTimeStamp();
127  		doNotify(BufferChangeTimestamp);
128  		return;
129  	}
130  	_fullPathName = fn;
131  	_fileName = PathFindFileName(_fullPathName.c_str());
132  	LangType determinatedLang = L_TEXT;
133  	TCHAR *ext = PathFindExtension(_fullPathName.c_str());
134  	if (*ext == '.') 
135  	{
136  		ext += 1;
137  		const TCHAR* langName = nppParamInst.getUserDefinedLangNameFromExt(ext, _fileName);
138  		if (langName)
139  		{
140  			determinatedLang = L_USER;
141  			_userLangExt = langName;
142  		}
143  		else 
144  		{
145  			_userLangExt.clear();
146  			determinatedLang = nppParamInst.getLangFromExt(ext);
147  		}
148  	}
149  	if (determinatedLang == L_TEXT)	
150  	{
151  		if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("makefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("GNUmakefile")) == 0))
152  			determinatedLang = L_MAKEFILE;
153  		else if (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("CmakeLists.txt")) == 0)
154  			determinatedLang = L_CMAKE;
155  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConstruct")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConscript")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("wscript")) == 0))
156  			determinatedLang = L_PYTHON;
157  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Rakefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Vagrantfile")) == 0))
158  			determinatedLang = L_RUBY;
159  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("crontab")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("PKGBUILD")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("APKBUILD")) == 0))
160  			determinatedLang = L_BASH;
161  	}
162  	updateTimeStamp();
163  	BufferStatusInfo lang2Change = BufferChangeNone;
164  	if (!_hasLangBeenSetFromMenu && (determinatedLang != _lang || _lang == L_USER))
165  	{
166  		if (_isLargeFile)
167  		{
168  			_lang = L_TEXT;
169  		}
170  		else
171  		{
172  			_lang = determinatedLang;
173  			lang2Change = BufferChangeLanguage;
174  		}
175  	}
176  	doNotify(BufferChangeFilename | BufferChangeTimestamp | lang2Change);
177  }
178  bool Buffer::checkFileState() 
179  {
180  	if (_currentStatus == DOC_UNNAMED || isMonitoringOn())
181  		return false;
182  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
183  	bool isWow64Off = false;
184  	NppParameters& nppParam = NppParameters::getInstance();
185  	if (!PathFileExists(_fullPathName.c_str()))
186  	{
187  		nppParam.safeWow64EnableWow64FsRedirection(FALSE);
188  		isWow64Off = true;
189  	}
190  	bool isOK = false;
191  	if (_currentStatus != DOC_DELETED && !PathFileExists(_fullPathName.c_str()))	
192  	{
193  		_currentStatus = DOC_DELETED;
194  		_isFileReadOnly = false;
195  		_isDirty = true;	
196  		_timeStamp = {};
197  		doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
198  		isOK = true;
199  	}
200  	else if (_currentStatus == DOC_DELETED && PathFileExists(_fullPathName.c_str()))
201  	{	
202  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
203  		{
204  			_isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
205  			_currentStatus = DOC_MODIFIED;
206  			_timeStamp = attributes.ftLastWriteTime;
207  			if (_reloadFromDiskRequestGuard.try_lock())
208  			{
209  				doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
210  				_reloadFromDiskRequestGuard.unlock();
211  			}
212  			isOK = true;
213  		}
214  	}
215  	else if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
216  	{
217  		int mask = 0;	
218  		bool isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
219  		if (isFileReadOnly != _isFileReadOnly)
220  		{
221  			_isFileReadOnly = isFileReadOnly;
222  			mask |= BufferChangeReadonly;
223  		}
224  		LONG res = CompareFileTime(&_timeStamp, &attributes.ftLastWriteTime);
225  		if (res == -1 || res == 1)
226  		{
227  			if (res == 1)
228  			{
229  				NppParameters& nppParam = NppParameters::getInstance();
230  				if (nppParam.doNppLogNetworkDriveIssue())
231  				{
232  					generic_string issueFn = nppLogNetworkDriveIssue;
233  					issueFn += TEXT(".log");
234  					generic_string nppIssueLog = nppParam.getUserPath();
235  					pathAppend(nppIssueLog, issueFn);
236  					std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
237  					std::string msg = converter.to_bytes(_fullPathName);
238  					char buf[1024];
239  					sprintf(buf, "  in checkFileState(): attributes.ftLastWriteTime (%lu/%lu) < _timeStamp (%lu/%lu)", attributes.ftLastWriteTime.dwLowDateTime, attributes.ftLastWriteTime.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
240  					msg += buf;
241  					writeLog(nppIssueLog.c_str(), msg.c_str());
242  				}
243  			}
244  			_timeStamp = attributes.ftLastWriteTime;
245  			mask |= BufferChangeTimestamp;
246  			_currentStatus = DOC_MODIFIED;
247  			mask |= BufferChangeStatus;	
248  		}
249  		if (mask != 0)
250  		{
251  			if (_reloadFromDiskRequestGuard.try_lock())
252  			{
253  				doNotify(mask);
254  				_reloadFromDiskRequestGuard.unlock();
255  				return true;
256  			}
257  		}
258  		return false;
259  	}
260  	if (isWow64Off)
261  	{
262  		nppParam.safeWow64EnableWow64FsRedirection(TRUE);
263  	}
264  	return isOK;
265  }
266  void Buffer::reload()
267  {
268  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
269  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
270  	{
271  		_timeStamp = attributes.ftLastWriteTime;
272  		_currentStatus = DOC_NEEDRELOAD;
273  		doNotify(BufferChangeTimestamp | BufferChangeStatus);
274  	}
275  }
276  int64_t Buffer::getFileLength() const
277  {
278  	if (_currentStatus == DOC_UNNAMED)
279  		return -1;
280  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
281  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
282  	{
283  		LARGE_INTEGER size{};
284  		size.LowPart = attributes.nFileSizeLow;
285  		size.HighPart = attributes.nFileSizeHigh;
286  		return size.QuadPart;
287  	}
288  	return -1;
289  }
290  generic_string Buffer::getFileTime(fileTimeType ftt) const
291  {
292  	generic_string result;
293  	if (_currentStatus != DOC_UNNAMED)
294  	{
295  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
296  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
297  		{
298  			FILETIME rawtime;
299  			switch (ftt)
300  			{
301  				case ft_created:
302  					rawtime = attributes.ftCreationTime;
303  					break;
304  				case ft_modified:
305  					rawtime = attributes.ftLastWriteTime;
306  					break;
307  				default:
308  					rawtime = attributes.ftLastAccessTime;
309  					break;
310  			}
311  			SYSTEMTIME utcSystemTime, localSystemTime;
312  			FileTimeToSystemTime(&rawtime, &utcSystemTime);
313  			SystemTimeToTzSpecificLocalTime(nullptr, &utcSystemTime, &localSystemTime);
314  			const size_t dateTimeStrLen = 256;
315  			TCHAR bufDate[dateTimeStrLen] = {'\0'};
316  			GetDateFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufDate, dateTimeStrLen);
317  			result += bufDate;
318  			result += ' ';
319  			TCHAR bufTime[dateTimeStrLen] = {'\0'};
320  			GetTimeFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufTime, dateTimeStrLen);
321  			result += bufTime;
322  		}
323  	}
324  	return result;
325  }
326  void Buffer::setPosition(const Position & pos, ScintillaEditView * identifier)
327  {
328  	int index = indexOfReference(identifier);
329  	if (index == -1)
330  		return;
331  	_positions[index] = pos;
332  }
333  Position& Buffer::getPosition(ScintillaEditView* identifier)
334  {
335  	int index = indexOfReference(identifier);
336  	return _positions.at(index);
337  }
338  void Buffer::setHeaderLineState(const std::vector<size_t> & folds, ScintillaEditView * identifier)
339  {
340  	int index = indexOfReference(identifier);
341  	if (index == -1)
342  		return;
343  	std::vector<size_t> & local = _foldStates[index];
344  	local.clear();
345  	size_t size = folds.size();
346  	for (size_t i = 0; i < size; ++i)
347  		local.push_back(folds[i]);
348  }
349  const std::vector<size_t> & Buffer::getHeaderLineState(const ScintillaEditView * identifier) const
350  {
351  	int index = indexOfReference(identifier);
352  	return _foldStates.at(index);
353  }
354  Lang * Buffer::getCurrentLang() const
355  {
356  	NppParameters& nppParam = NppParameters::getInstance();
357  	int i = 0;
358  	Lang *l = nppParam.getLangFromIndex(i);
359  	++i;
360  	while (l)
361  	{
362  		if (l->_langID == _lang)
363  			return l;
364  		l = nppParam.getLangFromIndex(i);
365  		++i;
366  	}
367  	return nullptr;
368  }
369  int Buffer::indexOfReference(const ScintillaEditView * identifier) const
370  {
371  	size_t size = _referees.size();
372  	for (size_t i = 0; i < size; ++i)
373  	{
374  		if (_referees[i] == identifier)
375  			return static_cast<int>(i);
376  	}
377  	return -1;	
378  }
379  int Buffer::addReference(ScintillaEditView * identifier)
380  {
381  	if (indexOfReference(identifier) != -1)
382  		return _references;
383  	_referees.push_back(identifier);
384  	_positions.push_back(Position());
385  	_foldStates.push_back(std::vector<size_t>());
386  	++_references;
387  	return _references;
388  }
389  int Buffer::removeReference(ScintillaEditView * identifier)
390  {
391  	int indexToPop = indexOfReference(identifier);
392  	if (indexToPop == -1)
393  		return _references;
394  	_referees.erase(_referees.begin() + indexToPop);
395  	_positions.erase(_positions.begin() + indexToPop);
396  	_foldStates.erase(_foldStates.begin() + indexToPop);
397  	_references--;
398  	return _references;
399  }
400  void Buffer::setHideLineChanged(bool isHide, size_t location)
401  {
402  	for (int i = 0; i < _references; ++i)
403  		_referees.at(i)->notifyMarkers(this, isHide, location, false); 
404  	if (!isHide) 
405  	{
406  		for (int i = 0; i < _references; ++i)
407  			_referees.at(i)->notifyMarkers(this, isHide, location, true);
408  	}
409  }
410  void Buffer::setDeferredReload() 
411  {
412  	_isDirty = false;	
413  	_needReloading = true;
414  	doNotify(BufferChangeDirty);
415  }
416  bool Buffer::allowBraceMach() const
417  {
418  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
419  	return (!_isLargeFile || nppGui._largeFileRestriction._allowBraceMatch) || !nppGui._largeFileRestriction._isEnabled;
420  }
421  bool Buffer::allowAutoCompletion() const
422  {
423  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
424  	return (!_isLargeFile || nppGui._largeFileRestriction._allowAutoCompletion) || !nppGui._largeFileRestriction._isEnabled;
425  }
426  bool Buffer::allowSmartHilite() const
427  {
428  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
429  	return (!_isLargeFile || nppGui._largeFileRestriction._allowSmartHilite) || !nppGui._largeFileRestriction._isEnabled;
430  }
431  bool Buffer::allowClickableLink() const
432  {
433  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
434  	return (!_isLargeFile || nppGui._largeFileRestriction._allowClickableLink) || !nppGui._largeFileRestriction._isEnabled;
435  }
436  FileManager::~FileManager()
437  {
438  	for (std::vector<Buffer *>::iterator it = _buffers.begin(), end = _buffers.end(); it != end; ++it)
439  	{
440  		delete *it;
441  	}
442  }
443  void FileManager::init(Notepad_plus * pNotepadPlus, ScintillaEditView * pscratchTilla)
444  {
445  	_pNotepadPlus = pNotepadPlus;
446  	_pscratchTilla = pscratchTilla;
447  	_pscratchTilla->execute(SCI_SETUNDOCOLLECTION, false);	
448  	_scratchDocDefault = (Document)_pscratchTilla->execute(SCI_GETDOCPOINTER);
449  	_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, _scratchDocDefault);
450  }
451  void FileManager::checkFilesystemChanges(bool bCheckOnlyCurrentBuffer)
452  {
453  	if (bCheckOnlyCurrentBuffer)
454  	{
455  		Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
456  		buffer->checkFileState();
457  	}
458  	else
459  	{
460  		for (int i = int(_nbBufs) - 1; i >= 0; i--)
461  		{
462  			if (i >= int(_nbBufs))
463  			{
464  				if (_nbBufs == 0)
465  					return;
466  				i = int(_nbBufs) - 1;
467  			}
468  			_buffers[i]->checkFileState();	
469  		}
470  	}
471  }
472  size_t FileManager::getNbDirtyBuffers() const
473  {
474  	size_t nb_dirtyBufs = 0;
475  	for (size_t i = 0; i < _nbBufs; ++i)
476  	{
477  		if (_buffers[i]->_isDirty)
478  			++nb_dirtyBufs;
479  	}
480  	return nb_dirtyBufs;
481  }
482  int FileManager::getBufferIndexByID(BufferID id)
483  {
484  	for (size_t i = 0; i < _nbBufs; ++i)
485  	{
486  		if (_buffers[i]->_id == id)
487  			return static_cast<int>(i);
488  	}
489  	return -1;
490  }
491  Buffer* FileManager::getBufferByIndex(size_t index)
492  {
493  	if (index >= _buffers.size())
494  		return nullptr;
495  	return _buffers.at(index);
496  }
497  void FileManager::beNotifiedOfBufferChange(Buffer* theBuf, int mask)
498  {
499  	_pNotepadPlus->notifyBufferChanged(theBuf, mask);
500  }
501  void FileManager::addBufferReference(BufferID buffer, ScintillaEditView * identifier)
502  {
503  	Buffer* buf = getBufferByID(buffer);
504  	buf->addReference(identifier);
505  }
506  void FileManager::closeBuffer(BufferID id, ScintillaEditView * identifier)
507  {
508  	int index = getBufferIndexByID(id);
509  	Buffer* buf = getBufferByIndex(index);
510  	int refs = buf->removeReference(identifier);
511  	if (!refs) 
512  	{
513  		_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, buf->_doc);	
514  		_buffers.erase(_buffers.begin() + index);
515  		delete buf;
516  		_nbBufs--;
517  	}
518  }
519  BufferID FileManager::loadFile(const TCHAR* filename, Document doc, int encoding, const TCHAR* backupFileName, FILETIME fileNameTimestamp)
520  {
521  	if (!filename)
522  		return BUFFER_INVALID;
523  	int64_t fileSize = -1;
524  	const TCHAR* pPath = filename;
525  	if (!::PathFileExists(pPath))
526  	{
527  		pPath = backupFileName;
528  	}
529  	if (pPath)
530  	{
531  		FILE* fp = _wfopen(pPath, TEXT("rb"));
532  		if (fp)
533  		{
534  			_fseeki64(fp, 0, SEEK_END);
535  			fileSize = _ftelli64(fp);
536  			fclose(fp);
537  		}
538  	}
539  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
540  	bool isLargeFile = false;
541  	if (nppGui._largeFileRestriction._isEnabled)
542  		isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
543  	if (isLargeFile && nppGui._largeFileRestriction._deactivateWordWrap)
544  	{
545  		bool isWrap = _pNotepadPlus->_pEditView->isWrap();
546  		if (isWrap)
547  		{
548  			_pNotepadPlus->command(IDM_VIEW_WRAP);
549  		}
550  	}
551  	bool ownDoc = false;
552  	if (!doc)
553  	{
554  		doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT, 0, isLargeFile ? SC_DOCUMENTOPTION_STYLES_NONE | SC_DOCUMENTOPTION_TEXT_LARGE : 0);
555  		ownDoc = true;
556  	}
557  	WCHAR fullpath[MAX_PATH] = { 0 };
558  	if (isWin32NamespacePrefixedFileName(filename))
559  	{
560  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
561  	}
562  	else
563  	{
564  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
565  		if (wcschr(fullpath, '~'))
566  		{
567  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
568  		}
569  	}
570  	bool isSnapshotMode = backupFileName != NULL && PathFileExists(backupFileName);
571  	if (isSnapshotMode && !PathFileExists(fullpath)) 
572  	{
573  		wcscpy_s(fullpath, MAX_PATH, filename); 
574  	}
575  	Utf8_16_Read UnicodeConvertor;	
576  	char* data = new char[blockSize + 8]; 
577  	LoadedFileFormat loadedFileFormat;
578  	loadedFileFormat._encoding = encoding;
579  	loadedFileFormat._eolFormat = EolType::unknown;
580  	loadedFileFormat._language = L_TEXT;
581  	bool res = loadFileData(doc, fileSize, backupFileName ? backupFileName : fullpath, data, &UnicodeConvertor, loadedFileFormat);
582  	delete[] data;
583  	if (res)
584  	{
585  		Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_REGULAR, fullpath, isLargeFile);
586  		BufferID id = newBuf;
587  		newBuf->_id = id;
588  		if (backupFileName != NULL)
589  		{
590  			newBuf->_backupFileName = backupFileName;
591  			if (!PathFileExists(fullpath))
592  				newBuf->_currentStatus = DOC_UNNAMED;
593  		}
594  		const FILETIME zeroTimeStamp = {};
595  		LONG res = CompareFileTime(&fileNameTimestamp, &zeroTimeStamp);
596  		if (res != 0) 
597  			newBuf->_timeStamp = fileNameTimestamp;
598  		_buffers.push_back(newBuf);
599  		++_nbBufs;
600  		Buffer* buf = _buffers.at(_nbBufs - 1);
601  		buf->setEncoding(-1);
602  		if (!newBuf->_isLargeFile && ((buf->getLangType() == L_TEXT) && (loadedFileFormat._language != L_TEXT)))
603  			buf->setLangType(loadedFileFormat._language);
604  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
605  		++_nextBufferID;
606  		return id;
607  	}
608  	else 
609  	{
610  		if (ownDoc)
611  			_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, doc);	
612  		return BUFFER_INVALID;
613  	}
614  }
615  bool FileManager::reloadBuffer(BufferID id)
616  {
617  	Buffer* buf = getBufferByID(id);
618  	Document doc = buf->getDocument();
619  	Utf8_16_Read UnicodeConvertor;
620  	LoadedFileFormat loadedFileFormat;
621  	loadedFileFormat._encoding = buf->getEncoding();
622  	loadedFileFormat._eolFormat = EolType::unknown;
623  	loadedFileFormat._language = buf->getLangType();
624  	buf->setLoadedDirty(false);	
625  	FILE* fp = _wfopen(buf->getFullPathName(), TEXT("rb"));
626  	if (!fp)
627  		return false;
628  	_fseeki64(fp, 0, SEEK_END);
629  	int64_t fileSize = _ftelli64(fp);
630  	fclose(fp);
631  	char* data = new char[blockSize + 8]; 
632  	buf->_canNotify = false;	
633  	bool res = loadFileData(doc, fileSize, buf->getFullPathName(), data, &UnicodeConvertor, loadedFileFormat);
634  	buf->_canNotify = true;
635  	delete[] data;
636  	if (res)
637  	{
638  		buf->setUnsync(false);
639  		buf->setDirty(false); 
640  		buf->setSavePointDirty(false);
641  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
642  	}
643  	return res;
644  }
645  void FileManager::setLoadedBufferEncodingAndEol(Buffer* buf, const Utf8_16_Read& UnicodeConvertor, int encoding, EolType bkformat)
646  {
647  	if (encoding == -1)
648  	{
649  		NppParameters& nppParamInst = NppParameters::getInstance();
650  		const NewDocDefaultSettings & ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
651  		UniMode um = UnicodeConvertor.getEncoding();
652  		if (um == uni7Bit)
653  			um = (ndds._openAnsiAsUtf8) ? uniCookie : uni8Bit;
654  		buf->setUnicodeMode(um);
655  	}
656  	else
657  	{
658  		buf->setEncoding((encoding == SC_CP_UTF8)?-1:encoding);
659  		buf->setUnicodeMode(uniCookie);
660  	}
661  	if (bkformat != EolType::unknown)
662  		buf->setEolFormat(bkformat);
663  }
664  bool FileManager::reloadBufferDeferred(BufferID id)
665  {
666  	Buffer* buf = getBufferByID(id);
667  	buf->setDeferredReload();
668  	return true;
669  }
670  bool FileManager::deleteFile(BufferID id)
671  {
672  	Buffer* buf = getBufferByID(id);
673  	generic_string fileNamePath = buf->getFullPathName();
674  	fileNamePath.append(1, '\0');
675  	if (!PathFileExists(fileNamePath.c_str()))
676  		return false;
677  	SHFILEOPSTRUCT fileOpStruct = {};
678  	fileOpStruct.hwnd = NULL;
679  	fileOpStruct.pFrom = fileNamePath.c_str();
680  	fileOpStruct.pTo = NULL;
681  	fileOpStruct.wFunc = FO_DELETE;
682  	fileOpStruct.fFlags = FOF_ALLOWUNDO;
683  	fileOpStruct.fAnyOperationsAborted = false;
684  	fileOpStruct.hNameMappings         = NULL;
685  	fileOpStruct.lpszProgressTitle     = NULL;
686  	return SHFileOperation(&fileOpStruct) == 0;
687  }
688  bool FileManager::moveFile(BufferID id, const TCHAR * newFileName)
689  {
690  	Buffer* buf = getBufferByID(id);
691  	const TCHAR *fileNamePath = buf->getFullPathName();
692  	if (::MoveFileEx(fileNamePath, newFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH) == 0)
693  		return false;
694  	buf->setFileName(newFileName);
695  	return true;
696  }
697  std::mutex backup_mutex;
698  bool FileManager::backupCurrentBuffer()
699  {
700  	Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
701  	if (buffer->isLargeFile())
702  		return false;
703  	std::lock_guard<std::mutex> lock(backup_mutex);
704  	bool result = false;
705  	bool hasModifForSession = false;
706  	if (buffer->isDirty())
707  	{
708  		if (buffer->isModified()) 
709  		{
710  			UniMode mode = buffer->getUnicodeMode();
711  			if (mode == uniCookie)
712  				mode = uni8Bit;	
713  			Utf8_16_Write UnicodeConvertor;
714  			UnicodeConvertor.setEncoding(mode);
715  			int encoding = buffer->getEncoding();
716  			generic_string backupFilePath = buffer->getBackupFileName();
717  			if (backupFilePath.empty())
718  			{
719  				backupFilePath = NppParameters::getInstance().getUserPath();
720  				backupFilePath += TEXT("\\backup\\");
721  				if (!PathFileExists(backupFilePath.c_str()))
722  				{
723  					::CreateDirectory(backupFilePath.c_str(), NULL);
724  				}
725  				backupFilePath += buffer->getFileName();
726  				const int temBufLen = 32;
727  				TCHAR tmpbuf[temBufLen];
728  				time_t ltime = time(0);
729  				struct tm* today = localtime(&ltime);
730  				if (!today)
731  					return false;
732  				wcsftime(tmpbuf, temBufLen, L"%Y-%m-%d_%H%M%S", today);
733  				backupFilePath += L"@";
734  				backupFilePath += tmpbuf;
735  				buffer->setBackupFileName(backupFilePath);
736  				hasModifForSession = true;
737  			}
738  			TCHAR fullpath[MAX_PATH];
739  			::GetFullPathName(backupFilePath.c_str(), MAX_PATH, fullpath, NULL);
740  			if (wcschr(fullpath, '~'))
741  			{
742  				::GetLongPathName(fullpath, fullpath, MAX_PATH);
743  			}
744  			DWORD dwFileAttribs = ::GetFileAttributes(fullpath);
745  			if (dwFileAttribs & FILE_ATTRIBUTE_READONLY) 
746  			{
747  				dwFileAttribs ^= FILE_ATTRIBUTE_READONLY;
748  				::SetFileAttributes(fullpath, dwFileAttribs);
749  			}
750  			if (UnicodeConvertor.openFile(fullpath))
751  			{
752  				size_t lengthDoc = _pNotepadPlus->_pEditView->getCurrentDocLen();
753  				char* buf = (char*)_pNotepadPlus->_pEditView->execute(SCI_GETCHARACTERPOINTER);	
754  				boolean isWrittenSuccessful = false;
755  				if (encoding == -1) 
756  				{
757  					isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
758  					if (lengthDoc == 0)
759  						isWrittenSuccessful = true;
760  				}
761  				else
762  				{
763  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
764  					size_t grabSize;
765  					for (size_t i = 0; i < lengthDoc; i += grabSize)
766  					{
767  						grabSize = lengthDoc - i;
768  						if (grabSize > blockSize)
769  							grabSize = blockSize;
770  						int newDataLen = 0;
771  						int incompleteMultibyteChar = 0;
772  						const char *newData = wmc.encode(SC_CP_UTF8, encoding, buf+i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
773  						grabSize -= incompleteMultibyteChar;
774  						isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
775  					}
776  					if (lengthDoc == 0)
777  						isWrittenSuccessful = true;
778  				}
779  				UnicodeConvertor.closeFile();
780  				if (isWrittenSuccessful) 
781  				{
782  					buffer->setModifiedStatus(false);
783  					result = true;	
784  				}
785  			}
786  		}
787  		else 
788  		{
789  			result = true;
790  		}
791  	}
792  	else 
793  	{
794  		generic_string backupFilePath = buffer->getBackupFileName();
795  		if (!backupFilePath.empty())
796  		{
797  			generic_string file2Delete = buffer->getBackupFileName();
798  			buffer->setBackupFileName(generic_string());
799  			result = (::DeleteFile(file2Delete.c_str()) != 0);
800  			hasModifForSession = true;
801  		}
802  		result = true; 
803  	}
804  	if (result && hasModifForSession)
805  	{
806  		_pNotepadPlus->saveCurrentSession();
807  	}
808  	return result;
809  }
810  bool FileManager::deleteBufferBackup(BufferID id)
811  {
812  	Buffer* buffer = getBufferByID(id);
813  	bool result = true;
814  	generic_string backupFilePath = buffer->getBackupFileName();
815  	if (!backupFilePath.empty())
816  	{
817  		buffer->setBackupFileName(generic_string());
818  		result = (::DeleteFile(backupFilePath.c_str()) != 0);
819  	}
820  	return result;
821  }
822  std::mutex save_mutex;
823  SavingStatus FileManager::saveBuffer(BufferID id, const TCHAR * filename, bool isCopy)
824  {
825  	std::lock_guard<std::mutex> lock(save_mutex);
826  	Buffer* buffer = getBufferByID(id);
827  	bool isHiddenOrSys = false;
828  	DWORD attrib = 0;
829  	WCHAR fullpath[MAX_PATH] = { 0 };
830  	if (isWin32NamespacePrefixedFileName(filename))
831  	{
832  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
833  	}
834  	else
835  	{
836  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
837  		if (wcschr(fullpath, '~'))
838  		{
839  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
840  		}
841  	}
842  	if (PathFileExists(fullpath))
843  	{
844  		attrib = ::GetFileAttributes(fullpath);
845  		if (attrib != INVALID_FILE_ATTRIBUTES)
846  		{
847  			isHiddenOrSys = (attrib & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != 0;
848  			if (isHiddenOrSys)
849  				::SetFileAttributes(filename, attrib & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));
850  		}
851  	}
852  	UniMode mode = buffer->getUnicodeMode();
853  	if (mode == uniCookie)
854  		mode = uni8Bit;	
855  	Utf8_16_Write UnicodeConvertor;
856  	UnicodeConvertor.setEncoding(mode);
857  	int encoding = buffer->getEncoding();
858  	if (UnicodeConvertor.openFile(fullpath))
859  	{
860  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);	
861  		size_t lengthDoc = _pscratchTilla->getCurrentDocLen();
862  		char* buf = (char*)_pscratchTilla->execute(SCI_GETCHARACTERPOINTER);	
863  		boolean isWrittenSuccessful = false;
864  		if (encoding == -1) 
865  		{
866  			isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
867  			if (lengthDoc == 0)
868  				isWrittenSuccessful = true;
869  		}
870  		else
871  		{
872  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
873  			if (lengthDoc == 0)
874  			{
875  				isWrittenSuccessful = UnicodeConvertor.writeFile(buf, 0);
876  			}
877  			else
878  			{
879  				size_t grabSize;
880  				for (size_t i = 0; i < lengthDoc; i += grabSize)
881  				{
882  					grabSize = lengthDoc - i;
883  					if (grabSize > blockSize)
884  						grabSize = blockSize;
885  					int newDataLen = 0;
886  					int incompleteMultibyteChar = 0;
887  					const char* newData = wmc.encode(SC_CP_UTF8, encoding, buf + i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
888  					grabSize -= incompleteMultibyteChar;
889  					isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
890  				}
891  			}
892  		}
893  		UnicodeConvertor.closeFile();
894  		if (!isWrittenSuccessful)
895  		{
896  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
897  			return SavingStatus::SaveWritingFailed;
898  		}
899  		if (isHiddenOrSys)
900  			::SetFileAttributes(fullpath, attrib);
901  		if (isCopy) 
902  		{
903  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
904  			return SavingStatus::SaveOK;	
905  		}
906  		buffer->setFileName(fullpath);
907  		if (!buffer->isLargeFile() && buffer->_lang == L_TEXT)
908  		{
909  			LangType detectedLang = detectLanguageFromTextBegining((unsigned char*)buf, lengthDoc);
910  			if (detectedLang != L_TEXT)
911  			{
912  				buffer->_lang = detectedLang;
913  				buffer->doNotify(BufferChangeFilename | BufferChangeTimestamp | BufferChangeLanguage);
914  			}
915  		}
916  		buffer->setDirty(false);
917  		buffer->setUnsync(false);
918  		buffer->setSavePointDirty(false);
919  		buffer->setStatus(DOC_REGULAR);
920  		buffer->checkFileState();
921  		_pscratchTilla->execute(SCI_SETSAVEPOINT);
922  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
923  		generic_string backupFilePath = buffer->getBackupFileName();
924  		if (!backupFilePath.empty())
925  		{
926  			buffer->setBackupFileName(generic_string());
927  			::DeleteFile(backupFilePath.c_str());
928  		}
929  		return SavingStatus::SaveOK;
930  	}
931  	else
932  	{
933  		return SavingStatus::SaveOpenFailed;
934  	}
935  }
936  size_t FileManager::nextUntitledNewNumber() const
937  {
938  	std::vector<size_t> usedNumbers;
939  	for (size_t i = 0; i < _buffers.size(); i++)
940  	{
941  		Buffer *buf = _buffers.at(i);
942  		if (buf->isUntitled())
943  		{
944  			bool isVisible = false;
945  			for (size_t k = 0; k < buf->_referees.size(); k++)
946  			{
947  				if (buf->_referees[k]->isVisible())
948  				{
949  					isVisible = true;
950  					break;
951  				}
952  			}
953  			if (isVisible)
954  			{
955  				if (buf->indexOfReference(_pNotepadPlus->_pEditView) > -1 || buf->indexOfReference(_pNotepadPlus->_pNonEditView) > -1)
956  				{
<span onclick='openModal()' class='match'>957  					generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
958  					TCHAR* numberStr = buf->_fileName + newTitle.length();
959  					int usedNumber = _wtoi(numberStr);
960  					usedNumbers.push_back(usedNumber);
961  				}
962  			}
</span>963  		}
964  	}
965  	size_t newNumber = 1;
966  	bool numberAvailable = true;
967  	bool found = false;
968  	do
969  	{
970  		for (size_t j = 0; j < usedNumbers.size(); j++)
971  		{
972  			numberAvailable = true;
973  			found = false;
974  			if (usedNumbers[j] == newNumber)
975  			{
976  				numberAvailable = false;
977  				found = true;
978  				break;
979  			}
980  		}
981  		if (!numberAvailable)
982  			newNumber++;
983  		if (!found)
984  			break;
985  	} while (!numberAvailable);
986  	return newNumber;
987  }
988  BufferID FileManager::newEmptyDocument()
989  {
990  	generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
991  	TCHAR nb[10];
992  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
993  	newTitle += nb;
994  	Document doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT);	
995  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
996  	NppParameters& nppParamInst = NppParameters::getInstance();
997  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
998  	newBuf->_lang = ndds._lang;
999  	BufferID id = newBuf;
1000  	newBuf->_id = id;
1001  	_buffers.push_back(newBuf);
1002  	++_nbBufs;
1003  	++_nextBufferID;
1004  	return id;
1005  }
1006  BufferID FileManager::bufferFromDocument(Document doc, bool dontIncrease, bool dontRef)
1007  {
1008  	NppParameters& nppParamInst = NppParameters::getInstance();
1009  	generic_string newTitle = (nppParamInst.getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
1010  	TCHAR nb[10];
1011  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
1012  	newTitle += nb;
1013  	if (!dontRef)
1014  		_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, doc);	
1015  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
1016  	BufferID id = newBuf;
1017  	newBuf->_id = id;
1018  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
1019  	newBuf->_lang = ndds._lang;
1020  	_buffers.push_back(newBuf);
1021  	++_nbBufs;
1022  	if (!dontIncrease)
1023  		++_nextBufferID;
1024  	return id;
1025  }
1026  int FileManager::detectCodepage(char* buf, size_t len)
1027  {
1028  	int codepage = -1;
1029  	uchardet_t ud = uchardet_new();
1030  	uchardet_handle_data(ud, buf, len);
1031  	uchardet_data_end(ud);
1032  	const char* cs = uchardet_get_charset(ud);
1033  	if (stricmp(cs, "TIS-620") != 0) 
1034  		codepage = EncodingMapper::getInstance().getEncodingFromString(cs);
1035  	uchardet_delete(ud);
1036  	return codepage;
1037  }
1038  LangType FileManager::detectLanguageFromTextBegining(const unsigned char *data, size_t dataLen)
1039  {
1040  	struct FirstLineLanguages
1041  	{
1042  		std::string pattern;
1043  		LangType lang;
1044  	};
1045  	if (dataLen <= 3)
1046  		return L_TEXT;
1047  	size_t i = 0;
1048  	if ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) || 
1049  		(data[0] == 0xFE && data[1] == 0xFF && data[2] == 0x00) || 
1050  		(data[0] == 0xFF && data[1] == 0xFE && data[2] == 0x00))   
1051  		i += 3;
1052  	for (; i < dataLen; ++i)
1053  	{
1054  		if (data[i] != ' ' && data[i] != '\t' && data[i] != '\n' && data[i] != '\r')
1055  			break;
1056  	}
1057  	const size_t longestLength = 40; 
1058  	std::string buf2Test = std::string((const char *)data + i, longestLength);
1059  	auto cr = buf2Test.find("\r");
1060  	auto nl = buf2Test.find("\n");
1061  	auto crnl = std::min<size_t>(cr, nl);
1062  	if (crnl != std::string::npos && crnl < longestLength)
1063  		buf2Test = std::string((const char *)data + i, crnl);
1064  	std::string shebang = "#!";
1065  	size_t foundPos = buf2Test.find(shebang);
1066  	if (foundPos == 0)
1067  	{
1068  		const size_t NB_SHEBANG_LANGUAGES = 6;
1069  		FirstLineLanguages ShebangLangs[NB_SHEBANG_LANGUAGES] = {
1070  			{ "sh",		L_BASH },
1071  			{ "python", L_PYTHON },
1072  			{ "perl",	L_PERL },
1073  			{ "php",	L_PHP },
1074  			{ "ruby",	L_RUBY },
1075  			{ "node",	L_JAVASCRIPT }
1076  		};
1077  		for (i = 0; i < NB_SHEBANG_LANGUAGES; ++i)
1078  		{
1079  			if (buf2Test.find(ShebangLangs[i].pattern) != std::string::npos)
1080  			{
1081  				return ShebangLangs[i].lang;
1082  			}
1083  		}
1084  		return L_TEXT;
1085  	}
1086  	const size_t NB_FIRST_LINE_LANGUAGES = 5;
1087  	FirstLineLanguages languages[NB_FIRST_LINE_LANGUAGES] = {
1088  		{ "<?xml",			L_XML },
1089  		{ "<?php",			L_PHP },
1090  		{ "<html",			L_HTML },
1091  		{ "<!DOCTYPE html",	L_HTML },
1092  		{ "<?",				L_PHP } 
1093  	};
1094  	for (i = 0; i < NB_FIRST_LINE_LANGUAGES; ++i)
1095  	{
1096  		foundPos = buf2Test.find(languages[i].pattern);
1097  		if (foundPos == 0)
1098  		{
1099  			return languages[i].lang;
1100  		}
1101  	}
1102  	return L_TEXT;
1103  }
1104  bool FileManager::loadFileData(Document doc, int64_t fileSize, const TCHAR * filename, char* data, Utf8_16_Read * unicodeConvertor, LoadedFileFormat& fileFormat)
1105  {
1106  	FILE *fp = _wfopen(filename, TEXT("rb"));
1107  	if (!fp)
1108  		return false;
1109  	int64_t bufferSizeRequested = fileSize + std::min<int64_t>(1LL << 20, fileSize / 6);
1110  	NppParameters& nppParam = NppParameters::getInstance();
1111  	NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1112  	if (bufferSizeRequested > INT_MAX)
1113  	{
1114  		if (nppParam.archType() == IMAGE_FILE_MACHINE_I386)
1115  		{
1116  			pNativeSpeaker->messageBox("FileTooBigToOpen",
1117  				_pNotepadPlus->_pEditView->getHSelf(),
1118  				TEXT("File is too big to be opened by Notepad++"),
1119  				TEXT("File size problem"),
1120  				MB_OK | MB_APPLMODAL);
1121  			fclose(fp);
1122  			return false;
1123  		}
1124  		else 
1125  		{
1126  			int res = pNativeSpeaker->messageBox("WantToOpenHugeFile",
1127  				_pNotepadPlus->_pEditView->getHSelf(),
1128  				TEXT("Opening a huge file of 2GB+ could take several minutes.\nDo you want to open it?"),
1129  				TEXT("Opening huge file warning"),
1130  				MB_YESNO | MB_APPLMODAL);
1131  			if (res == IDYES)
1132  			{
1133  			}
1134  			else
1135  			{
1136  				fclose(fp);
1137  				return false;
1138  			}
1139  		}
1140  	}
1141  	_pscratchTilla->execute(SCI_SETSTATUS, SC_STATUS_OK); 
1142  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, doc);
1143  	bool ro = _pscratchTilla->execute(SCI_GETREADONLY) != 0;
1144  	if (ro)
1145  	{
1146  		_pscratchTilla->execute(SCI_SETREADONLY, false);
1147  	}
1148  	_pscratchTilla->execute(SCI_CLEARALL);
1149  	if (fileFormat._language < L_EXTERNAL)
1150  	{
1151  		const char* lexerNameID = ScintillaEditView::_langNameInfoArray[fileFormat._language]._lexerID;
1152  		_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(CreateLexer(lexerNameID)));
1153  	}
1154  	else
1155  	{
1156  		int id = fileFormat._language - L_EXTERNAL;
1157  		ExternalLangContainer& externalLexer = nppParam.getELCFromIndex(id);
1158  		const char* lexerName = externalLexer._name.c_str();
1159  		if (externalLexer.fnCL)
1160  			_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(externalLexer.fnCL(lexerName)));
1161  	}
1162  	if (fileFormat._encoding != -1)
1163  		_pscratchTilla->execute(SCI_SETCODEPAGE, SC_CP_UTF8);
1164  	bool success = true;
1165  	EolType format = EolType::unknown;
1166  	int sciStatus = SC_STATUS_OK;
1167  	TCHAR szException[64] = { '\0' };
1168  	__try
1169  	{
1170  		_pscratchTilla->execute(SCI_ALLOCATE, WPARAM(bufferSizeRequested));
1171  		sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1172  		if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1173  			throw std::runtime_error("Scintilla error");
1174  		size_t lenFile = 0;
1175  		size_t lenConvert = 0;	
1176  		bool isFirstTime = true;
1177  		int incompleteMultibyteChar = 0;
1178  		do
1179  		{
1180  			lenFile = fread(data + incompleteMultibyteChar, 1, blockSize - incompleteMultibyteChar, fp) + incompleteMultibyteChar;
1181  			if (ferror(fp) != 0)
1182  			{
1183  				success = false;
1184  				break;
1185  			}
1186  			if (lenFile == 0) break;
1187              if (isFirstTime)
1188              {
1189  				NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
1190                  if (Utf8_16_Read::determineEncoding((unsigned char *)data, lenFile) != uni8Bit)
1191                  {
1192  					fileFormat._encoding = -1;
1193  				}
1194  				else if (fileFormat._encoding == -1)
1195  				{
1196  					if (nppGui._detectEncoding)
1197  						fileFormat._encoding = detectCodepage(data, lenFile);
1198                  }
1199  				bool isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
1200  				if (!isLargeFile && fileFormat._language == L_TEXT)
1201  				{
1202  					fileFormat._language = detectLanguageFromTextBegining((unsigned char *)data, lenFile);
1203  				}
1204                  isFirstTime = false;
1205              }
1206  			if (fileFormat._encoding != -1)
1207  			{
1208  				if (fileFormat._encoding == SC_CP_UTF8)
1209  				{
1210  					_pscratchTilla->execute(SCI_APPENDTEXT, lenFile, reinterpret_cast<LPARAM>(data));
1211  				}
1212  				else
1213  				{
1214  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1215  					int newDataLen = 0;
1216  					const char *newData = wmc.encode(fileFormat._encoding, SC_CP_UTF8, data, static_cast<int32_t>(lenFile), &newDataLen, &incompleteMultibyteChar);
1217  					_pscratchTilla->execute(SCI_APPENDTEXT, newDataLen, reinterpret_cast<LPARAM>(newData));
1218  				}
1219  				if (format == EolType::unknown)
1220  					format = getEOLFormatForm(data, lenFile, EolType::unknown);
1221  			}
1222  			else
1223  			{
1224  				lenConvert = unicodeConvertor->convert(data, lenFile);
1225  				_pscratchTilla->execute(SCI_APPENDTEXT, lenConvert, reinterpret_cast<LPARAM>(unicodeConvertor->getNewBuf()));
1226  				if (format == EolType::unknown)
1227  					format = getEOLFormatForm(unicodeConvertor->getNewBuf(), unicodeConvertor->getNewSize(), EolType::unknown);
1228  			}
1229  			sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1230  			if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1231  				throw std::runtime_error("Scintilla error");
1232  			if (incompleteMultibyteChar != 0)
1233  			{
1234  				memcpy(data, data + blockSize - incompleteMultibyteChar, incompleteMultibyteChar);
1235  			}
1236  		}
1237  		while (lenFile > 0);
1238  	}
1239  	__except(EXCEPTION_EXECUTE_HANDLER)
1240  	{
1241  		switch (sciStatus)
1242  		{
1243  			case SC_STATUS_OK:
1244  #if defined(__GNUC__)
1245  				_stprintf_s(szException, _countof(szException), TEXT("unknown exception"));
1246  #else
1247  				_stprintf_s(szException, _countof(szException), TEXT("0x%X (SEH)"), ::GetExceptionCode());
1248  #endif
1249  				break;
1250  			case SC_STATUS_BADALLOC:
1251  			{
1252  				pNativeSpeaker->messageBox("FileTooBigToOpen",
1253  					_pNotepadPlus->_pEditView->getHSelf(),
1254  					TEXT("File is too big to be opened by Notepad++"),
1255  					TEXT("Exception: File size problem"),
1256  					MB_OK | MB_APPLMODAL);
1257  			}
1258  			[[fallthrough]];
1259  			case SC_STATUS_FAILURE:
1260  			default:
1261  				_stprintf_s(szException, _countof(szException), TEXT("%d (Scintilla)"), sciStatus);
1262  				break;
1263  		}
1264  		if (sciStatus != SC_STATUS_BADALLOC)
1265  		{
1266  			pNativeSpeaker->messageBox("FileLoadingException",
1267  				_pNotepadPlus->_pEditView->getHSelf(),
1268  				TEXT("An error occurred while loading the file!"),
1269  				TEXT("Exception code: $STR_REPLACE$"),
1270  				MB_OK | MB_APPLMODAL,
1271  				0,
1272  				szException);
1273  		}
1274  		success = false;
1275  	}
1276  	fclose(fp);
1277  	if (format == EolType::unknown)
1278  	{
1279  		const NewDocDefaultSettings & ndds = (nppParam.getNppGUI()).getNewDocDefaultSettings(); 
1280  		fileFormat._eolFormat = ndds._format;
1281  		if ((fileSize == 0) && (fileFormat._encoding < 1))
1282  		{
1283  			if (ndds._unicodeMode == uniCookie && ndds._openAnsiAsUtf8)
1284  				fileFormat._encoding = SC_CP_UTF8;
1285  		}
1286  	}
1287  	else
1288  	{
1289  		fileFormat._eolFormat = format;
1290  	}
1291  	_pscratchTilla->execute(SCI_EMPTYUNDOBUFFER);
1292  	_pscratchTilla->execute(SCI_SETSAVEPOINT);
1293  	if (ro)
1294  		_pscratchTilla->execute(SCI_SETREADONLY, true);
1295  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
1296  	return success;
1297  }
1298  BufferID FileManager::getBufferFromName(const TCHAR* name)
1299  {
1300  	for (auto buf : _buffers)
1301  	{
1302  		if (OrdinalIgnoreCaseCompareStrings(name, buf->getFullPathName()) == 0)
1303  		{
1304  			if (buf->_referees[0]->isVisible())
1305  			{
1306  				return buf->getID();
1307  			}
1308  		}
1309  	}
1310  	return BUFFER_INVALID;
1311  }
1312  BufferID FileManager::getBufferFromDocument(Document doc)
1313  {
1314  	for (size_t i = 0; i < _nbBufs; ++i)
1315  	{
1316  		if (_buffers[i]->_doc == doc)
1317  			return _buffers[i]->_id;
1318  	}
1319  	return BUFFER_INVALID;
1320  }
1321  bool FileManager::createEmptyFile(const TCHAR * path)
1322  {
1323  	Win32_IO_File file(path);
1324  	return file.isOpened();
1325  }
1326  int FileManager::getFileNameFromBuffer(BufferID id, TCHAR * fn2copy)
1327  {
1328  	if (getBufferIndexByID(id) == -1)
1329  		return -1;
1330  	Buffer* buf = getBufferByID(id);
1331  	if (fn2copy)
1332  		lstrcpy(fn2copy, buf->getFullPathName());
1333  	return lstrlen(buf->getFullPathName());
1334  }
1335  size_t FileManager::docLength(Buffer* buffer) const
1336  {
1337  	Document curDoc = _pscratchTilla->execute(SCI_GETDOCPOINTER);
1338  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);
1339  	size_t docLen = _pscratchTilla->getCurrentDocLen();
1340  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, curDoc);
1341  	return docLen;
1342  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-sgd_solver.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>556        const int layer_id = this->net_->param_layer_indices(param_id).first;
557        const string& layer_name = this->net_->layer_names()[layer_id];
558        const int blob_id = this->net_->param_layer_indices(param_id).second;
559        LOG(INFO) << layer_name << "." << blob_id << " lr=" << local_lr
560          << ".\t  w=" << w_norm << "\t  dw=" << wgrad_norm;
561      }
562  #endif
563    }
</pre></code></div>
                <div class="column column_space"><pre><code>957  					generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
958  					TCHAR* numberStr = buf->_fileName + newTitle.length();
959  					int usedNumber = _wtoi(numberStr);
960  					usedNumbers.push_back(usedNumber);
961  				}
962  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    