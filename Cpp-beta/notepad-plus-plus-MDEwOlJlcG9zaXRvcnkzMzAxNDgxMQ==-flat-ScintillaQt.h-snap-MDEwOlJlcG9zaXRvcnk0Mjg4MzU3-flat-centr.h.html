
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.138888888888888%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.h</h3>
            <pre><code>1  #ifndef SCINTILLAQT_H
2  #define SCINTILLAQT_H
3  #include <cstddef>
4  #include <cstdlib>
5  #include <cstdint>
6  #include <cassert>
7  #include <cstring>
8  #include <cctype>
9  #include <cstdio>
10  #include <ctime>
11  #include <cmath>
12  #include <stdexcept>
13  #include <string>
14  #include <string_view>
15  #include <vector>
16  #include <map>
17  #include <set>
18  #include <optional>
19  #include <algorithm>
20  #include <memory>
21  #include "ScintillaTypes.h"
22  #include "ScintillaMessages.h"
23  #include "ScintillaStructures.h"
24  #include "Scintilla.h"
25  #include "Debugging.h"
26  #include "Geometry.h"
27  #include "Platform.h"
28  #include "ILoader.h"
29  #include "ILexer.h"
30  #include "CharacterCategoryMap.h"
31  #include "Position.h"
32  #include "UniqueString.h"
33  #include "SplitVector.h"
34  #include "Partitioning.h"
35  #include "RunStyles.h"
36  #include "ContractionState.h"
37  #include "CellBuffer.h"
38  #include "CallTip.h"
39  #include "KeyMap.h"
40  #include "Indicator.h"
41  #include "LineMarker.h"
42  #include "Style.h"
43  #include "AutoComplete.h"
44  #include "ViewStyle.h"
45  #include "CharClassify.h"
46  #include "Decoration.h"
47  #include "CaseFolder.h"
48  #include "Document.h"
49  #include "Selection.h"
50  #include "PositionCache.h"
51  #include "EditModel.h"
52  #include "MarginView.h"
53  #include "EditView.h"
54  #include "Editor.h"
55  #include "ScintillaBase.h"
56  #include "CaseConvert.h"
57  #include <QObject>
58  #include <QAbstractScrollArea>
59  #include <QAction>
60  #include <QClipboard>
61  #include <QPaintEvent>
62  class ScintillaEditBase;
63  namespace Scintilla::Internal {
64  class ScintillaQt : public QObject, public ScintillaBase {
65  	Q_OBJECT
66  public:
67  	explicit ScintillaQt(QAbstractScrollArea *parent);
68  	virtual ~ScintillaQt();
69  signals:
70  	void horizontalScrolled(int value);
71  	void verticalScrolled(int value);
72  	void horizontalRangeChanged(int max, int page);
73  	void verticalRangeChanged(int max, int page);
74  	void notifyParent(Scintilla::NotificationData scn);
75  	void notifyChange();
76  	void aboutToCopy(QMimeData *data);
77  	void command(Scintilla::uptr_t wParam, Scintilla::sptr_t lParam);
78  private slots:
79  	void onIdle();
80  	void execCommand(QAction *action);
81  	void SelectionChanged();
82  private:
83  	void Init();
84  	void Finalise() override;
85  	bool DragThreshold(Point ptStart, Point ptNow) override;
86  	bool ValidCodePage(int codePage) const override;
87  	std::string UTF8FromEncoded(std::string_view encoded) const override;
88  	std::string EncodedFromUTF8(std::string_view utf8) const override;
89  private:
90  	void ScrollText(Sci::Line linesToMove) override;
91  	void SetVerticalScrollPos() override;
92  	void SetHorizontalScrollPos() override;
93  	bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) override;
94  	void ReconfigureScrollBars() override;
95  	void CopyToModeClipboard(const SelectionText &selectedText, QClipboard::Mode clipboardMode_);
96  	void Copy() override;
97  	void CopyToClipboard(const SelectionText &selectedText) override;
98  	void PasteFromMode(QClipboard::Mode clipboardMode_);
99  	void Paste() override;
100  	void ClaimSelection() override;
101  	void NotifyChange() override;
102  	void NotifyFocus(bool focus) override;
103  	void NotifyParent(Scintilla::NotificationData scn) override;
104  	void NotifyURIDropped(const char *uri);
105  	int timers[static_cast<size_t>(TickReason::dwell)+1]{};
106  	bool FineTickerRunning(TickReason reason) override;
<span onclick='openModal()' class='match'>107  	void FineTickerStart(TickReason reason, int millis, int tolerance) override;
108  	void CancelTimers();
109  	void FineTickerCancel(TickReason reason) override;
110  	bool ChangeIdle(bool on);
111  	bool SetIdle(bool on) override;
</span>112  	void SetMouseCapture(bool on) override;
113  	bool HaveMouseCapture() override;
114  	void StartDrag() override;
115  	Scintilla::CharacterSet CharacterSetOfDocument() const;
116  	const char *CharacterSetIDOfDocument() const;
117  	QString StringFromDocument(const char *s) const;
118  	QByteArray BytesForDocument(const QString &text) const;
119  	std::unique_ptr<CaseFolder> CaseFolderForEncoding() override;
120  	std::string CaseMapString(const std::string &s, CaseMapping caseMapping) override;
121  	void CreateCallTipWindow(PRectangle rc) override;
122  	void AddToPopUp(const char *label, int cmd, bool enabled) override;
123  	sptr_t WndProc(Scintilla::Message iMessage, uptr_t wParam, sptr_t lParam) override;
124  	sptr_t DefWndProc(Scintilla::Message iMessage, uptr_t wParam, sptr_t lParam) override;
125  	static sptr_t DirectFunction(sptr_t ptr,
126  				     unsigned int iMessage, uptr_t wParam, sptr_t lParam);
127  	static sptr_t DirectStatusFunction(sptr_t ptr,
128  				     unsigned int iMessage, uptr_t wParam, sptr_t lParam, int *pStatus);
129  protected:
130  	void PartialPaint(const PRectangle &rect);
131  	void DragEnter(const Point &point);
132  	void DragMove(const Point &point);
133  	void DragLeave();
134  	void Drop(const Point &point, const QMimeData *data, bool move);
135  	void DropUrls(const QMimeData *data);
136  	void timerEvent(QTimerEvent *event) override;
137  private:
138  	QAbstractScrollArea *scrollArea;
139  	int vMax, hMax;   
140  	int vPage, hPage; 
141  	bool haveMouseCapture;
142  	bool dragWasDropped;
143  	int rectangularSelectionModifier;
144  	friend class ::ScintillaEditBase;
145  };
146  }
147  #endif &bsol;* SCINTILLAQT_H */
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-centr.h</h3>
            <pre><code>1  namespace TSnap {
2  double GetDegreeCentr(const PUNGraph& Graph, const int& NId);
3  double GetGroupDegreeCentr(const PUNGraph& Graph, const TIntH& GroupNodes);
4  double GetGroupClosenessCentr(const PUNGraph& Graph, const TIntH& GroupNodes);
5  TIntH MaxCPGreedyBetter(const PUNGraph& Graph, const int k);
6  TIntH MaxCPGreedyBetter1(const PUNGraph& Graph, const int k);
7  TIntH MaxCPGreedyBetter2(const PUNGraph& Graph, const int k);
8  TIntH MaxCPGreedyBetter3(const PUNGraph& Graph, const int k);
9  TIntFltH EventImportance(const PNGraph& Graph, const int k);
10  int Intersect(TUNGraph::TNodeI Node, TIntH NNodes);
11  int Intersect(TUNGraph::TNodeI Node, TStr NNodes);
12  int Intersect(TUNGraph::TNodeI Node, int *NNodes, int NNodes_br);
13  int Intersect1(TUNGraph::TNodeI Node, TStr NNodes);
14  TIntH LoadNodeList(TStr InFNmNodes);
15  template <class PGraph> double GetFarnessCentr(const PGraph& Graph, const int& NId, const bool& Normalized=true, const bool& IsDir=false);
16  template <class PGraph> double GetFarnessCentrMP(const PGraph& Graph, const int& NId, const bool& Normalized=true, const bool& IsDir=false);
17  double GetWeightedFarnessCentr(const PNEANet Graph, const int& NId, const TFltV& Attr, const bool& Normalized=true, const bool& IsDir=false);
18  template <class PGraph> double GetClosenessCentr(const PGraph& Graph, const int& NId, const bool& Normalized=true, const bool& IsDir=false);
19  template <class PGraph> double GetClosenessCentrMP(const PGraph& Graph, const int& NId, const bool& Normalized=true, const bool& IsDir=false);
20  double GetWeightedClosenessCentr(const PNEANet Graph, const int& NId, const TFltV& Attr, const bool& Normalized=true, const bool& IsDir=false);
21  template <class PGraph> int GetNodeEcc(const PGraph& Graph, const int& NId, const bool& IsDir=false);
<span onclick='openModal()' class='match'>22  template<class PGraph> void GetBetweennessCentr(const PGraph& Graph, TIntFltH& NIdBtwH, const double& NodeFrac=1.0, const bool& IsDir=false);
23  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntFltH& NIdBtwH, const TFltV& Attr, const double& NodeFrac=1.0, const bool& IsDir=false);
</span>24  template<class PGraph> void GetBetweennessCentr(const PGraph& Graph, TIntPrFltH& EdgeBtwH, const double& NodeFrac=1.0, const bool& IsDir=false);
25  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntPrFltH& EdgeBtwH, const TFltV& Attr, const double& NodeFrac=1.0, const bool& IsDir=false);
26  template<class PGraph> void GetBetweennessCentr(const PGraph& Graph, TIntFltH& NIdBtwH, TIntPrFltH& EdgeBtwH, const double& NodeFrac=1.0, const bool& IsDir=false);
27  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntFltH& NIdBtwH, TIntPrFltH& EdgeBtwH, const TFltV& Attr, const double& NodeFrac=1.0, const bool& IsDir=false);
28  template<class PGraph> void GetBetweennessCentr(const PGraph& Graph, const TIntV& BtwNIdV, TIntFltH& NodeBtwH, const bool& DoNodeCent, TIntPrFltH& EdgeBtwH, const bool& DoEdgeCent, const bool& IsDir);
29  void GetWeightedBetweennessCentr(const PNEANet Graph, const TIntV& BtwNIdV, TIntFltH& NodeBtwH, const bool& DoNodeCent, TIntPrFltH& EdgeBtwH, const bool& DoEdgeCent, const TFltV& Attr, const bool& IsDir);
30  void GetEigenVectorCentr(const PUNGraph& Graph, TIntFltH& NIdEigenH, const double& Eps=1e-4, const int& MaxIter=100);
31  template<class PGraph> void GetPageRank(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
32  template<class PGraph> void GetPageRank_v1(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
33  #ifdef USE_OPENMP
34  template<class PGraph> void GetPageRankMP(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
35  #endif
36  int GetWeightedPageRank(const PNEANet Graph, TIntFltH& PRankH, const TStr& Attr, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
37  #ifdef USE_OPENMP
38  int GetWeightedPageRankMP(const PNEANet Graph, TIntFltH& PRankH, const TStr& Attr, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
39  #endif
40  template<class PGraph> void GetHits(const PGraph& Graph, TIntFltH& NIdHubH, TIntFltH& NIdAuthH, const int& MaxIter=20);
41  #ifdef USE_OPENMP
42  template<class PGraph> void GetHitsMP(const PGraph& Graph, TIntFltH& NIdHubH, TIntFltH& NIdAuthH, const int& MaxIter=20);
43  #endif
44  int GetWeightedShortestPath(const PNEANet Graph, const int& SrcNId, TIntFltH& NIdDistH, const TFltV& Attr);
45  template <class PGraph>
46  double GetFarnessCentr(const PGraph& Graph, const int& NId, const bool& Normalized, const bool& IsDir) {
47    TIntH NDistH(Graph->GetNodes());
48    TSnap::GetShortPath<PGraph>(Graph, NId, NDistH, IsDir, TInt::Mx);  
49    double sum = 0;
50    for (TIntH::TIter I = NDistH.BegI(); I < NDistH.EndI(); I++) {
51      sum += I->Dat();
52    }
53    if (NDistH.Len() > 1) { 
54      double centr = sum/double(NDistH.Len()-1); 
55      if (Normalized) {
56        centr *= (Graph->GetNodes() - 1)/double(NDistH.Len()-1);
57      }
58      return centr;
59    }
60    else { return 0.0; }
61  }
62  template <class PGraph>
63  double GetFarnessCentrMP(const PGraph& Graph, const int& NId, const bool& Normalized, const bool& IsDir) {
64    TIntH NDistH(Graph->GetNodes());
65    TSnap::GetShortPath<PGraph>(Graph, NId, NDistH, IsDir, TInt::Mx);  
66    double sum = 0;
67    for (TIntH::TIter I = NDistH.BegI(); I < NDistH.EndI(); I++) {
68      sum += I->Dat();
69    }
70    if (NDistH.Len() > 1) { 
71      double centr = sum/double(NDistH.Len()-1); 
72      if (Normalized) {
73        centr *= (Graph->GetNodes() - 1)/double(NDistH.Len()-1);
74      }
75      return centr;
76    }
77    else { return 0.0; }
78  }
79  template <class PGraph>
80  double GetClosenessCentr(const PGraph& Graph, const int& NId, const bool& Normalized, const bool& IsDir) {
81    const double Farness = GetFarnessCentr<PGraph> (Graph, NId, Normalized, IsDir);
82    if (Farness != 0.0) { return 1.0/Farness; }
83    else { return 0.0; }
84    return 0.0;
85  }
86  template <class PGraph>
87  double GetClosenessCentrMP(const PGraph& Graph, const int& NId, const bool& Normalized, const bool& IsDir) {
88    const double Farness = GetFarnessCentrMP<PGraph> (Graph, NId, Normalized, IsDir);
89    if (Farness != 0.0) { return 1.0/Farness; }
90    else { return 0.0; }
91    return 0.0;
92  }
93  template <class PGraph>
94  int GetNodeEcc(const PGraph& Graph, const int& NId, const bool& IsDir) {
95    int NodeEcc;
96    int Dist;
97    TBreathFS<PGraph> BFS(Graph);
98    BFS.DoBfs(NId, true, ! IsDir, -1, TInt::Mx);
99    NodeEcc = 0;
100    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
101      Dist = BFS.NIdDistH[i];
102      if (Dist > NodeEcc) {
103        NodeEcc = Dist;
104      }
105    }
106    return NodeEcc;
107  }
108  template<class PGraph>
109  void GetPageRank_v1(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
110    const int NNodes = Graph->GetNodes();
111    PRankH.Gen(NNodes);
112    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
113      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
114    }
115    TFltV TmpV(NNodes);
116    for (int iter = 0; iter < MaxIter; iter++) {
117      int j = 0;
118      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++, j++) {
119        TmpV[j] = 0;
120        for (int e = 0; e < NI.GetInDeg(); e++) {
121          const int InNId = NI.GetInNId(e);
122          const int OutDeg = Graph->GetNI(InNId).GetOutDeg();
123          if (OutDeg > 0) {
124            TmpV[j] += PRankH.GetDat(InNId) / OutDeg; }
125        }
126        TmpV[j] =  C*TmpV[j]; 
127      }
128      double diff=0, sum=0, NewVal;
129      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
130      const double Leaked = (1.0-sum) / double(NNodes);
131      for (int i = 0; i < PRankH.Len(); i++) { 
132        NewVal = TmpV[i] + Leaked; 
133        diff += fabs(NewVal-PRankH[i]);
134        PRankH[i] = NewVal;
135      }
136      if (diff < Eps) { break; }
137    }
138  }
139  template<class PGraph>
140  void GetPageRank(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
141    const int NNodes = Graph->GetNodes();
142    TVec<typename PGraph::TObj::TNodeI> NV;
143    PRankH.Gen(NNodes);
144    int MxId = -1;
145    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
146      NV.Add(NI);
147      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
148      int Id = NI.GetId();
149      if (Id > MxId) {
150        MxId = Id;
151      }
152    }
153    TFltV PRankV(MxId+1);
154    TIntV OutDegV(MxId+1);
155    for (int j = 0; j < NNodes; j++) {
156      typename PGraph::TObj::TNodeI NI = NV[j];
157      int Id = NI.GetId();
158      PRankV[Id] = 1.0/NNodes;
159      OutDegV[Id] = NI.GetOutDeg();
160    }
161    TFltV TmpV(NNodes);
162    for (int iter = 0; iter < MaxIter; iter++) {
163      for (int j = 0; j < NNodes; j++) {
164        typename PGraph::TObj::TNodeI NI = NV[j];
165        TFlt Tmp = 0;
166        for (int e = 0; e < NI.GetInDeg(); e++) {
167          const int InNId = NI.GetInNId(e);
168          const int OutDeg = OutDegV[InNId];
169          if (OutDeg > 0) {
170            Tmp += PRankV[InNId] / OutDeg;
171          }
172        }
173        TmpV[j] =  C*Tmp; 
174      }
175      double sum = 0;
176      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
177      const double Leaked = (1.0-sum) / double(NNodes);
178      double diff = 0;
179      for (int i = 0; i < NNodes; i++) {
180        typename PGraph::TObj::TNodeI NI = NV[i];
181        double NewVal = TmpV[i] + Leaked; 
182        int Id = NI.GetId();
183        diff += fabs(NewVal-PRankV[Id]);
184        PRankV[Id] = NewVal;
185      }
186      if (diff < Eps) { break; }
187    }
188    for (int i = 0; i < NNodes; i++) {
189      typename PGraph::TObj::TNodeI NI = NV[i];
190      PRankH[i] = PRankV[NI.GetId()];
191    }
192  }
193  #ifdef USE_OPENMP
194  template<class PGraph>
195  void GetPageRankMP(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
196    const int NNodes = Graph->GetNodes();
197    TVec<typename PGraph::TObj::TNodeI> NV;
198    PRankH.Gen(NNodes);
199    int MxId = -1;
200    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
201      NV.Add(NI);
202      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
203      int Id = NI.GetId();
204      if (Id > MxId) {
205        MxId = Id;
206      }
207    }
208    TFltV PRankV(MxId+1);
209    TIntV OutDegV(MxId+1);
210    #pragma omp parallel for schedule(dynamic,10000)
211    for (int j = 0; j < NNodes; j++) {
212      typename PGraph::TObj::TNodeI NI = NV[j];
213      int Id = NI.GetId();
214      PRankV[Id] = 1.0/NNodes;
215      OutDegV[Id] = NI.GetOutDeg();
216    }
217    TFltV TmpV(NNodes);
218    for (int iter = 0; iter < MaxIter; iter++) {
219      #pragma omp parallel for schedule(dynamic,10000)
220      for (int j = 0; j < NNodes; j++) {
221        typename PGraph::TObj::TNodeI NI = NV[j];
222        TFlt Tmp = 0;
223        for (int e = 0; e < NI.GetInDeg(); e++) {
224          const int InNId = NI.GetInNId(e);
225          const int OutDeg = OutDegV[InNId];
226          if (OutDeg > 0) {
227            Tmp += PRankV[InNId] / OutDeg;
228          }
229        }
230        TmpV[j] =  C*Tmp; 
231      }
232      double sum = 0;
233      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
234      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
235      const double Leaked = (1.0-sum) / double(NNodes);
236      double diff = 0;
237      #pragma omp parallel for reduction(+:diff) schedule(dynamic,10000)
238      for (int i = 0; i < NNodes; i++) {
239        double NewVal = TmpV[i] + Leaked; 
240        int Id = NV[i].GetId();
241        diff += fabs(NewVal-PRankV[Id]);
242        PRankV[Id] = NewVal;
243      }
244      if (diff < Eps) { break; }
245    }
246    #pragma omp parallel for schedule(dynamic,10000)
247    for (int i = 0; i < NNodes; i++) {
248      typename PGraph::TObj::TNodeI NI = NV[i];
249      PRankH[i] = PRankV[NI.GetId()];
250    }
251  }
252  #endif 
253  template<class PGraph>
254  void GetBetweennessCentr(const PGraph& Graph, const TIntV& BtwNIdV, TIntFltH& NodeBtwH, const bool& DoNodeCent, TIntPrFltH& EdgeBtwH, const bool& DoEdgeCent, const bool& IsDir) {
255    if (DoNodeCent) { NodeBtwH.Clr(); }
256    if (DoEdgeCent) { EdgeBtwH.Clr(); }
257    const int nodes = Graph->GetNodes();
258    TIntS S(nodes);
259    TIntQ Q(nodes);
260    TIntIntVH P(nodes); 
261    TIntFltH delta(nodes);
262    TIntH sigma(nodes), d(nodes);
263    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
264      if (DoNodeCent) {
265        NodeBtwH.AddDat(NI.GetId(), 0); }
266      if (DoEdgeCent) {
267        for (int e = 0; e < NI.GetOutDeg(); e++) {
268          if (Graph->HasFlag(gfDirected) && IsDir) {
269            EdgeBtwH.AddDat(TIntPr(NI.GetId(), NI.GetOutNId(e)), 0); 
270          } else {
271            if (NI.GetId() < NI.GetOutNId(e)) {
272              EdgeBtwH.AddDat(TIntPr(NI.GetId(), NI.GetOutNId(e)), 0); 
273            }
274          }
275        }
276        if (Graph->HasFlag(gfDirected) && !IsDir) {
277          for (int e = 0; e < NI.GetInDeg(); e++) {
278            if (NI.GetId() < NI.GetInNId(e)  &&
279                !Graph->IsEdge(NI.GetId(), NI.GetInNId(e))) {
280              EdgeBtwH.AddDat(TIntPr(NI.GetId(), NI.GetInNId(e)), 0); 
281            }
282          }
283        }
284      }
285      sigma.AddDat(NI.GetId(), 0);
286      d.AddDat(NI.GetId(), -1);
287      P.AddDat(NI.GetId(), TIntV());
288      delta.AddDat(NI.GetId(), 0);
289    }
290    for (int k=0; k < BtwNIdV.Len(); k++) {
291      const typename PGraph::TObj::TNodeI NI = Graph->GetNI(BtwNIdV[k]);
292      for (int i = 0; i < sigma.Len(); i++) {
293        sigma[i]=0;  d[i]=-1;  delta[i]=0;  P[i].Clr(false);
294      }
295      S.Clr(false);
296      Q.Clr(false);
297      sigma.AddDat(NI.GetId(), 1);
298      d.AddDat(NI.GetId(), 0);
299      Q.Push(NI.GetId());
300      while (! Q.Empty()) {
301        const int v = Q.Top();  Q.Pop();
302        const typename PGraph::TObj::TNodeI NI2 = Graph->GetNI(v);
303        S.Push(v);
304        const int VDat = d.GetDat(v);
305        for (int e = 0; e < NI2.GetOutDeg(); e++) {
306          const int w = NI2.GetOutNId(e);
307          if (d.GetDat(w) < 0) { 
308            Q.Push(w);
309            d.AddDat(w, VDat+1);
310          }
311          if (d.GetDat(w) == VDat+1) {
312            sigma.AddDat(w) += sigma.GetDat(v);
313            P.GetDat(w).Add(v);
314          }
315        }
316        if (Graph->HasFlag(gfDirected) && !IsDir) {
317          for (int e = 0; e < NI2.GetInDeg(); e++) {
318            const int w = NI2.GetInNId(e);
319            if (Graph->IsEdge(NI2.GetId(), w)) {
320              continue;
321            }
322            if (d.GetDat(w) < 0) { 
323              Q.Push(w);
324              d.AddDat(w, VDat+1);
325            }
326            if (d.GetDat(w) == VDat+1) {
327              sigma.AddDat(w) += sigma.GetDat(v);
328              P.GetDat(w).Add(v);
329            }
330          }
331        }
332      }
333      while (! S.Empty()) {
334        const int w = S.Top();
335        const double SigmaW = sigma.GetDat(w);
336        const double DeltaW = delta.GetDat(w);
337        const TIntV NIdV = P.GetDat(w);
338        S.Pop();
339        for (int i = 0; i < NIdV.Len(); i++) {
340          const int NId = NIdV[i];
341          const double c = (sigma.GetDat(NId)*1.0/SigmaW) * (1+DeltaW);
342          delta.AddDat(NId) += c;
343          if (DoEdgeCent) {
344            if (Graph->HasFlag(gfDirected) && IsDir) {
345              EdgeBtwH.AddDat(TIntPr(NId, w)) += c;
346            } else {
347              EdgeBtwH.AddDat(TIntPr(TMath::Mn(NId, w), TMath::Mx(NId, w))) += c;
348            }
349          }
350        }
351        if (DoNodeCent && w != NI.GetId()) {
352          NodeBtwH.AddDat(w) += delta.GetDat(w)/2.0; }
353      }
354    }
355  }
356  template<class PGraph>
357  void GetBetweennessCentr(const PGraph& Graph, TIntFltH& NodeBtwH, const double& NodeFrac, const bool& IsDir) {
358    TIntPrFltH EdgeBtwH;
359    TIntV NIdV;  Graph->GetNIdV(NIdV);
360    if (NodeFrac < 1.0) { 
361      NIdV.Shuffle(TInt::Rnd);
362      for (int i = int((1.0-NodeFrac)*NIdV.Len()); i > 0; i--) {
363        NIdV.DelLast(); }
364    }
365    GetBetweennessCentr<PGraph> (Graph, NIdV, NodeBtwH, true, EdgeBtwH, false, IsDir);
366  }
367  template<class PGraph>
368  void GetBetweennessCentr(const PGraph& Graph, TIntPrFltH& EdgeBtwH, const double& NodeFrac, const bool& IsDir) {
369    TIntFltH NodeBtwH;
370    TIntV NIdV;  Graph->GetNIdV(NIdV);
371    if (NodeFrac < 1.0) { 
372      NIdV.Shuffle(TInt::Rnd);
373      for (int i = int((1.0-NodeFrac)*NIdV.Len()); i > 0; i--) {
374        NIdV.DelLast(); }
375    }
376    GetBetweennessCentr<PGraph> (Graph, NIdV, NodeBtwH, false, EdgeBtwH, true, IsDir);
377  }
378  template<class PGraph>
379  void GetBetweennessCentr(const PGraph& Graph, TIntFltH& NodeBtwH, TIntPrFltH& EdgeBtwH, const double& NodeFrac, const bool& IsDir) {
380    TIntV NIdV;  Graph->GetNIdV(NIdV);
381    if (NodeFrac < 1.0) { 
382      NIdV.Shuffle(TInt::Rnd);
383      for (int i = int((1.0-NodeFrac)*NIdV.Len()); i > 0; i--) {
384        NIdV.DelLast(); }
385    }
386    GetBetweennessCentr<PGraph> (Graph, NIdV, NodeBtwH, true, EdgeBtwH, true, IsDir);
387  }
388  template<class PGraph>
389  void GetHits(const PGraph& Graph, TIntFltH& NIdHubH, TIntFltH& NIdAuthH, const int& MaxIter) {
390    const int NNodes = Graph->GetNodes();
391    NIdHubH.Gen(NNodes);
392    NIdAuthH.Gen(NNodes);
393    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
394      NIdHubH.AddDat(NI.GetId(), 1.0);
395      NIdAuthH.AddDat(NI.GetId(), 1.0);
396    }
397    double Norm=0;
398    for (int iter = 0; iter < MaxIter; iter++) {
399      Norm = 0;
400      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
401        double& Auth = NIdAuthH.GetDat(NI.GetId()).Val;
402        Auth = 0;
403        for (int e = 0; e < NI.GetInDeg(); e++) {
404          Auth +=  NIdHubH.GetDat(NI.GetInNId(e)); }
405        Norm += Auth*Auth;
406      }
407      Norm = sqrt(Norm);
408      for (int i = 0; i < NIdAuthH.Len(); i++) { NIdAuthH[i] /= Norm; }
409      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
410        double& Hub = NIdHubH.GetDat(NI.GetId()).Val;
411        Hub = 0;
412        for (int e = 0; e < NI.GetOutDeg(); e++) {
413          Hub += NIdAuthH.GetDat(NI.GetOutNId(e)); }
414        Norm += Hub*Hub;
415      }
416      Norm = sqrt(Norm);
417      for (int i = 0; i < NIdHubH.Len(); i++) { NIdHubH[i] /= Norm; }
418    }
419    Norm = 0.0;
420    for (int i = 0; i < NIdHubH.Len(); i++) { Norm += TMath::Sqr(NIdHubH[i]); }
421    Norm = sqrt(Norm);
422    for (int i = 0; i < NIdHubH.Len(); i++) { NIdHubH[i] /= Norm; }
423    Norm = 0.0;
424    for (int i = 0; i < NIdAuthH.Len(); i++) { Norm += TMath::Sqr(NIdAuthH[i]); }
425    Norm = sqrt(Norm);
426    for (int i = 0; i < NIdAuthH.Len(); i++) { NIdAuthH[i] /= Norm; }
427  }
428  #ifdef USE_OPENMP
429  template<class PGraph>
430  void GetHitsMP(const PGraph& Graph, TIntFltH& NIdHubH, TIntFltH& NIdAuthH, const int& MaxIter) {
431    const int NNodes = Graph->GetNodes();
432    TIntV NV;
433    NIdHubH.Gen(NNodes);
434    NIdAuthH.Gen(NNodes);
435    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
436      NV.Add(NI.GetId());
437      NIdHubH.AddDat(NI.GetId(), 1.0);
438      NIdAuthH.AddDat(NI.GetId(), 1.0);
439    }
440    double Norm=0;
441    for (int iter = 0; iter < MaxIter; iter++) {
442      Norm = 0;
443      #pragma omp parallel for reduction(+:Norm) schedule(dynamic,1000)
444      for (int i = 0; i < NNodes; i++) {
445        typename PGraph::TObj::TNodeI NI = Graph->GetNI(NV[i]);
446        double& Auth = NIdAuthH.GetDat(NI.GetId()).Val;
447        Auth = 0;
448        for (int e = 0; e < NI.GetInDeg(); e++) {
449          Auth +=  NIdHubH.GetDat(NI.GetInNId(e)); }
450        Norm = Norm + Auth*Auth;
451      }
452      Norm = sqrt(Norm);
453      for (int i = 0; i < NIdAuthH.Len(); i++) { NIdAuthH[i] /= Norm; }
454      #pragma omp parallel for reduction(+:Norm) schedule(dynamic,1000)
455      for (int i = 0; i < NNodes; i++) {
456        typename PGraph::TObj::TNodeI NI = Graph->GetNI(NV[i]);
457        double& Hub = NIdHubH.GetDat(NI.GetId()).Val;
458        Hub = 0;
459        for (int e = 0; e < NI.GetOutDeg(); e++) {
460          Hub += NIdAuthH.GetDat(NI.GetOutNId(e)); }
461        Norm = Norm + Hub*Hub;
462      }
463      Norm = sqrt(Norm);
464      for (int i = 0; i < NIdHubH.Len(); i++) { NIdHubH[i] /= Norm; }
465    }
466    Norm = 0.0;
467    for (int i = 0; i < NIdHubH.Len(); i++) { Norm += TMath::Sqr(NIdHubH[i]); }
468    Norm = sqrt(Norm);
469    for (int i = 0; i < NIdHubH.Len(); i++) { NIdHubH[i] /= Norm; }
470    Norm = 0.0;
471    for (int i = 0; i < NIdAuthH.Len(); i++) { Norm += TMath::Sqr(NIdAuthH[i]); }
472    Norm = sqrt(Norm);
473    for (int i = 0; i < NIdAuthH.Len(); i++) { NIdAuthH[i] /= Norm; }
474  }
475  #endif
476  template <class PGraph>
477  void MapPageRank(const TVec<PGraph>& GraphSeq, TVec<PTable>& TableSeq,
478      TTableContext* Context,
479      const double& C, const double& Eps, const int& MaxIter) {
480    int NumGraphs = GraphSeq.Len();
481    TableSeq.Reserve(NumGraphs, NumGraphs);
482    for (TInt i = 0; i < NumGraphs; i++) {
483      TIntFltH PRankH;
484      GetPageRank(GraphSeq[i], PRankH, C, Eps, MaxIter);
485      TableSeq[i] = TTable::TableFromHashMap(PRankH, "NodeId", "PageRank", Context, false);
486    }
487  }
488  template <class PGraph>
489  void MapHits(const TVec<PGraph>& GraphSeq, TVec<PTable>& TableSeq,
490      TTableContext* Context,
491      const int& MaxIter) {
492    int NumGraphs = GraphSeq.Len();
493    TableSeq.Reserve(NumGraphs, NumGraphs);
494    for (TInt i = 0; i < NumGraphs; i++) {
495      TIntFltH HubH;
496      TIntFltH AuthH;
497      GetHits(GraphSeq[i], HubH, AuthH, MaxIter);
498      PTable HubT =  TTable::TableFromHashMap(HubH, "NodeId", "Hub", Context, false);
499      PTable AuthT =  TTable::TableFromHashMap(AuthH, "NodeId", "Authority", Context, false);
500      PTable HitsT = HubT->Join("NodeId", AuthT, "NodeId");
501      HitsT->Rename("1.NodeId", "NodeId");
502      HitsT->Rename("1.Hub", "Hub");
503      HitsT->Rename("2.Authority", "Authority");
504      TStrV V = TStrV(3, 0);
505      V.Add("NodeId");
506      V.Add("Hub");
507      V.Add("Authority");
508      HitsT->ProjectInPlace(V);
509      TableSeq[i] = HitsT;
510    }
511  }
512  }; 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-centr.h</div>
                </div>
                <div class="column column_space"><pre><code>107  	void FineTickerStart(TickReason reason, int millis, int tolerance) override;
108  	void CancelTimers();
109  	void FineTickerCancel(TickReason reason) override;
110  	bool ChangeIdle(bool on);
111  	bool SetIdle(bool on) override;
</pre></code></div>
                <div class="column column_space"><pre><code>22  template<class PGraph> void GetBetweennessCentr(const PGraph& Graph, TIntFltH& NIdBtwH, const double& NodeFrac=1.0, const bool& IsDir=false);
23  void GetWeightedBetweennessCentr(const PNEANet Graph, TIntFltH& NIdBtwH, const TFltV& Attr, const double& NodeFrac=1.0, const bool& IsDir=false);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    