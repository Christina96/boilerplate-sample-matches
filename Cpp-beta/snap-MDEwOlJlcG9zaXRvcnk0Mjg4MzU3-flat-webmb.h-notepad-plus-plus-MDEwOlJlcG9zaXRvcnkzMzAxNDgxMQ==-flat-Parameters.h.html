
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.409106470386854%, Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webmb.h</h3>
            <pre><code>1  #ifndef webmb_h
2  #define webmb_h
3  #include "webold.h"
4  class TWebMemBs: public TXWebBs{
5  private:
<span onclick='openModal()' class='match'>6    static const TStr WebMemBsFNm;
7    static const int ExpectedWebPgs;
8    TStrIntH UrlStrToWebPgIdH;
9    TStrIntH CheckedUrlStrToWebPgIdH;
10    TIntStrVH WebPgIdToUrlStrVH;
11    TIntStrVH WebPgIdToRefUrlStrVH;
12    bool Modified;
13    void OnSave(const int& WebPgId, const PXWebPg& WebPg);
14    void OnFetch(const int& WebPgId, const PXWebPg& WebPg);
15  public:
16    TWebMemBs(const int& MxConns, const TStr& FPath, const bool& GenRef):
</span>17      TXWebBs(MxConns, FPath, GenRef),
18      UrlStrToWebPgIdH(ExpectedWebPgs),
19      CheckedUrlStrToWebPgIdH(),
20      WebPgIdToUrlStrVH(ExpectedWebPgs),
21      WebPgIdToRefUrlStrVH(ExpectedWebPgs),
22      Modified(false){}
23    TWebMemBs(const TStr& _FPath, const bool& _CheckMode=false);
24    void SaveTxt();
25    virtual ~TWebMemBs(){if (Modified){SaveTxt();}}
26    TWebMemBs& operator=(const TWebMemBs&){Fail; return *this;}
27    TStr GetWebPgFNm(const int& WebPgId){
28      return GetFPath()+TInt::GetStr(WebPgId)+".http";}
29    int GetWebPgs(){return WebPgIdToUrlStrVH.Len();}
30    int GetCheckedUrls(){return CheckedUrlStrToWebPgIdH.Len();}
31    int AddWebPg(const TStr& RelUrlStr, const TStr& BaseUrlStr=TStr());
32    bool IsWebPg(const TStr& UrlStr);
33    bool IsWebPg(const TStr& UrlStr, const bool& Check);
34    PXWebPg GetWebPg(const int& WebPgId);
35    PXWebPg GetWebPg(const TStr& UrlStr);
36    void AddWebPgRef(const TStr& UrlStr, const TStr& RefUrlStr);
37    bool DoStillFetchUrl(const TStr& UrlStr);
38    bool DoFetchRedirUrl(const PUrl& RedirUrl, const TUrlV& UrlV);
39    bool IsUrlStr(const TStr& UrlStr){
40      return UrlStrToWebPgIdH.IsKey(UrlStr);}
41    int GetUrlStrs(const int& WebPgId){
42      return WebPgIdToUrlStrVH.GetDat(WebPgId).Len();}
43    TStr GetUrlStr(const int& WebPgId, const int& UrlStrN=0){
44      return WebPgIdToUrlStrVH.GetDat(WebPgId)[UrlStrN];}
45    TStr GetUrlStr(const TStr& UrlStr){
46      int UrlStrToWebPgIdP=UrlStrToWebPgIdH.GetKeyId(UrlStr);
47      return UrlStrToWebPgIdH.GetKey(UrlStrToWebPgIdP);}
48    int GetWebPgId(const TStr& UrlStr){
49      return UrlStrToWebPgIdH.GetDat(UrlStr);}
50    int FFirstWebPg();
51    bool FNextWebPg(int& WebPgP, int& WebPgId);
52  };
53  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.h</h3>
            <pre><code>1  #pragma once
2  #include "tinyxmlA.h"
3  #include "tinyxml.h"
4  #include "Scintilla.h"
5  #include "ScintillaRef.h"
6  #include "ToolBar.h"
7  #include "UserDefineLangReference.h"
8  #include "colors.h"
9  #include "shortcut.h"
10  #include "ContextMenu.h"
11  #include "dpiManager.h"
12  #include "NppDarkMode.h"
13  #include <assert.h>
14  #include <tchar.h>
15  #include <map>
16  #include "ILexer.h"
17  #include "Lexilla.h"
18  #ifdef _WIN64
19  #ifdef _M_ARM64
20  #define ARCH_TYPE IMAGE_FILE_MACHINE_ARM64
21  #else
22  #define ARCH_TYPE IMAGE_FILE_MACHINE_AMD64
23  #endif
24  #else
25  #define ARCH_TYPE IMAGE_FILE_MACHINE_I386
26  #endif
27  #define CMD_INTERPRETER TEXT("%COMSPEC%")
28  class NativeLangSpeaker;
29  const bool POS_VERTICAL = true;
30  const bool POS_HORIZOTAL = false;
31  const int UDD_SHOW   = 1; 
32  const int UDD_DOCKED = 2; 
33  const int TAB_DRAWTOPBAR = 1;      
34  const int TAB_DRAWINACTIVETAB = 2; 
35  const int TAB_DRAGNDROP = 4;       
36  const int TAB_REDUCE = 8;          
37  const int TAB_CLOSEBUTTON = 16;    
38  const int TAB_DBCLK2CLOSE = 32;    
39  const int TAB_VERTICAL = 64;       
40  const int TAB_MULTILINE = 128;     
41  const int TAB_HIDE = 256;          
42  const int TAB_QUITONEMPTY = 512;   
43  const int TAB_ALTICONS = 1024;     
44  const bool activeText = true;
45  const bool activeNumeric = false;
46  enum class EolType: std::uint8_t
47  {
48  	windows,
49  	macos,
50  	unix,
51  	unknown, 
52  	osdefault = windows,
53  };
54  EolType convertIntToFormatType(int value, EolType defvalue = EolType::osdefault);
55  enum UniMode {uni8Bit=0, uniUTF8=1, uni16BE=2, uni16LE=3, uniCookie=4, uni7Bit=5, uni16BE_NoBOM=6, uni16LE_NoBOM=7, uniEnd};
56  enum ChangeDetect { cdDisabled = 0x0, cdEnabledOld = 0x01, cdEnabledNew = 0x02, cdAutoUpdate = 0x04, cdGo2end = 0x08 };
57  enum BackupFeature {bak_none = 0, bak_simple = 1, bak_verbose = 2};
58  enum OpenSaveDirSetting {dir_followCurrent = 0, dir_last = 1, dir_userDef = 2};
59  enum MultiInstSetting {monoInst = 0, multiInstOnSession = 1, multiInst = 2};
60  enum writeTechnologyEngine {defaultTechnology = 0, directWriteTechnology = 1};
61  enum urlMode {urlDisable = 0, urlNoUnderLineFg, urlUnderLineFg, urlNoUnderLineBg, urlUnderLineBg,
62                urlMin = urlDisable,
63                urlMax = urlUnderLineBg};
64  const int LANG_INDEX_INSTR = 0;
65  const int LANG_INDEX_INSTR2 = 1;
66  const int LANG_INDEX_TYPE = 2;
67  const int LANG_INDEX_TYPE2 = 3;
68  const int LANG_INDEX_TYPE3 = 4;
69  const int LANG_INDEX_TYPE4 = 5;
70  const int LANG_INDEX_TYPE5 = 6;
71  const int LANG_INDEX_TYPE6 = 7;
72  const int LANG_INDEX_TYPE7 = 8;
73  const int COPYDATA_PARAMS = 0;
74  const int COPYDATA_FILENAMESW = 2;
75  const int COPYDATA_FULL_CMDLINE = 3;
76  #define PURE_LC_NONE	0
77  #define PURE_LC_BOL	 1
78  #define PURE_LC_WSP	 2
79  #define DECSEP_DOT	  0
80  #define DECSEP_COMMA	1
81  #define DECSEP_BOTH	 2
82  #define DROPBOX_AVAILABLE 1
83  #define ONEDRIVE_AVAILABLE 2
84  #define GOOGLEDRIVE_AVAILABLE 4
85  #define NPP_STYLING_FILESIZE_LIMIT_DEFAULT (200 * 1024 * 1024) 
86  const TCHAR fontSizeStrs[][3] = {TEXT(""), TEXT("5"), TEXT("6"), TEXT("7"), TEXT("8"), TEXT("9"), TEXT("10"), TEXT("11"), TEXT("12"), TEXT("14"), TEXT("16"), TEXT("18"), TEXT("20"), TEXT("22"), TEXT("24"), TEXT("26"), TEXT("28")};
87  const TCHAR localConfFile[] = TEXT("doLocalConf.xml");
88  const TCHAR notepadStyleFile[] = TEXT("asNotepad.xml");
89  const TCHAR nppLogNetworkDriveIssue[] = TEXT("nppLogNetworkDriveIssue");
90  const TCHAR nppLogNulContentCorruptionIssue[] = TEXT("nppLogNulContentCorruptionIssue");
91  void cutString(const TCHAR *str2cut, std::vector<generic_string> & patternVect);
92  void cutStringBy(const TCHAR *str2cut, std::vector<generic_string> & patternVect, char byChar, bool allowEmptyStr);
93  const wchar_t g_npcStyleName[] = L"Non-printing characters custom color";
94  struct Position
95  {
96  	intptr_t _firstVisibleLine = 0;
97  	intptr_t _startPos = 0;
98  	intptr_t _endPos = 0;
99  	intptr_t _xOffset = 0;
100  	intptr_t _selMode = 0;
101  	intptr_t _scrollWidth = 1;
102  	intptr_t _offset = 0;
103  	intptr_t _wrapCount = 0;
104  };
105  struct MapPosition
106  {
107  private:
108  	intptr_t _maxPeekLenInKB = 512; 
109  public:
110  	intptr_t _firstVisibleDisplayLine = -1;
111  	intptr_t _firstVisibleDocLine = -1; 
112  	intptr_t _lastVisibleDocLine = -1;  
113  	intptr_t _nbLine = -1;              
114  	intptr_t _higherPos = -1;           
115  	intptr_t _width = -1;
116  	intptr_t _height = -1;
117  	intptr_t _wrapIndentMode = -1;
118  	intptr_t _KByteInDoc = _maxPeekLenInKB;
119  	bool _isWrap = false;
120  	bool isValid() const { return (_firstVisibleDisplayLine != -1); };
121  	bool canScroll() const { return (_KByteInDoc < _maxPeekLenInKB); }; 
122  };
123  struct sessionFileInfo : public Position
124  {
125  	sessionFileInfo(const wchar_t* fn, const TCHAR *ln, int encoding, bool userReadOnly, const Position& pos, const TCHAR *backupFilePath, FILETIME originalFileLastModifTimestamp, const MapPosition & mapPos) :
126  		Position(pos), _encoding(encoding), _isUserReadOnly(userReadOnly), _originalFileLastModifTimestamp(originalFileLastModifTimestamp), _mapPos(mapPos)
127  	{
128  		if (fn) _fileName = fn;
129  		if (ln)	_langName = ln;
130  		if (backupFilePath) _backupFilePath = backupFilePath;
131  	}
132  	sessionFileInfo(std::wstring fn) : _fileName(fn) {}
133  	std::wstring _fileName;
134  	std::wstring _langName;
135  	std::vector<size_t> _marks;
136  	std::vector<size_t> _foldStates;
137  	int	_encoding = -1;
138  	bool _isUserReadOnly = false;
139  	bool _isMonitoring = false;
140  	int _individualTabColour = -1;
141  	std::wstring _backupFilePath;
142  	FILETIME _originalFileLastModifTimestamp {};
143  	MapPosition _mapPos;
144  };
145  struct Session
146  {
147  	size_t nbMainFiles() const {return _mainViewFiles.size();};
148  	size_t nbSubFiles() const {return _subViewFiles.size();};
149  	size_t _activeView = 0;
150  	size_t _activeMainIndex = 0;
151  	size_t _activeSubIndex = 0;
152  	bool _includeFileBrowser = false;
153  	generic_string _fileBrowserSelectedItem;
154  	std::vector<sessionFileInfo> _mainViewFiles;
155  	std::vector<sessionFileInfo> _subViewFiles;
156  	std::vector<generic_string> _fileBrowserRoots;
157  };
158  struct CmdLineParams
159  {
160  	bool _isNoPlugin = false;
161  	bool _isReadOnly = false;
162  	bool _isNoSession = false;
163  	bool _isNoTab = false;
164  	bool _isPreLaunch = false;
165  	bool _showLoadingTime = false;
166  	bool _alwaysOnTop = false;
167  	intptr_t _line2go   = -1;
168  	intptr_t _column2go = -1;
169  	intptr_t _pos2go = -1;
170  	POINT _point = {};
171  	bool _isPointXValid = false;
172  	bool _isPointYValid = false;
173  	bool _isSessionFile = false;
174  	bool _isRecursive = false;
175  	bool _openFoldersAsWorkspace = false;
176  	bool _monitorFiles = false;
177  	LangType _langType = L_EXTERNAL;
178  	generic_string _localizationPath;
179  	generic_string _udlName;
180  	generic_string _pluginMessage;
181  	generic_string _easterEggName;
182  	unsigned char _quoteType = 0;
183  	int _ghostTypingSpeed = -1; 
184  	CmdLineParams()
185  	{
186  		_point.x = 0;
187  		_point.y = 0;
188  	}
189  	bool isPointValid() const
190  	{
191  		return _isPointXValid && _isPointYValid;
192  	}
193  };
194  struct CmdLineParamsDTO
195  {
196  	bool _isReadOnly = false;
197  	bool _isNoSession = false;
198  	bool _isSessionFile = false;
199  	bool _isRecursive = false;
200  	bool _openFoldersAsWorkspace = false;
201  	bool _monitorFiles = false;
202  	intptr_t _line2go = 0;
203  	intptr_t _column2go = 0;
204  	intptr_t _pos2go = 0;
205  	LangType _langType = L_EXTERNAL;
206  	wchar_t _udlName[MAX_PATH] = {'\0'};
207  	wchar_t _pluginMessage[MAX_PATH] = {'\0'};
208  	static CmdLineParamsDTO FromCmdLineParams(const CmdLineParams& params)
209  	{
210  		CmdLineParamsDTO dto;
211  		dto._isReadOnly = params._isReadOnly;
212  		dto._isNoSession = params._isNoSession;
213  		dto._isSessionFile = params._isSessionFile;
214  		dto._isRecursive = params._isRecursive;
215  		dto._openFoldersAsWorkspace = params._openFoldersAsWorkspace;
216  		dto._monitorFiles = params._monitorFiles;
217  		dto._line2go = params._line2go;
218  		dto._column2go = params._column2go;
219  		dto._pos2go = params._pos2go;
220  		dto._langType = params._langType;
221  		wcsncpy(dto._udlName, params._udlName.c_str(), MAX_PATH);
222  		wcsncpy(dto._pluginMessage, params._pluginMessage.c_str(), MAX_PATH);
223  		return dto;
224  	}
225  };
226  struct FloatingWindowInfo
227  {
228  	int _cont = 0;
229  	RECT _pos = {};
230  	FloatingWindowInfo(int cont, int x, int y, int w, int h)
231  		: _cont(cont)
232  	{
233  		_pos.left	= x;
234  		_pos.top	= y;
235  		_pos.right	= w;
236  		_pos.bottom = h;
237  	}
238  };
239  struct PluginDlgDockingInfo final
240  {
241  	generic_string _name;
242  	int _internalID = -1;
243  	int _currContainer = -1;
244  	int _prevContainer = -1;
245  	bool _isVisible = false;
246  	PluginDlgDockingInfo(const TCHAR* pluginName, int id, int curr, int prev, bool isVis)
247  		: _name(pluginName), _internalID(id), _currContainer(curr), _prevContainer(prev), _isVisible(isVis)
248  	{}
249  	bool operator == (const PluginDlgDockingInfo& rhs) const
250  	{
251  		return _internalID == rhs._internalID and _name == rhs._name;
252  	}
253  };
254  struct ContainerTabInfo final
255  {
256  	int _cont = 0;
257  	int _activeTab = 0;
258  	ContainerTabInfo(int cont, int activeTab) : _cont(cont), _activeTab(activeTab) {};
259  };
260  struct DockingManagerData final
261  {
262  	int _leftWidth = 200;
263  	int _rightWidth = 200;
264  	int _topHeight = 200;
265  	int _bottomHight = 200;
266  	std::vector<FloatingWindowInfo> _flaotingWindowInfo;
267  	std::vector<PluginDlgDockingInfo> _pluginDockInfo;
268  	std::vector<ContainerTabInfo> _containerTabInfo;
269  	bool getFloatingRCFrom(int floatCont, RECT& rc) const
270  	{
271  		for (size_t i = 0, fwiLen = _flaotingWindowInfo.size(); i < fwiLen; ++i)
272  		{
273  			if (_flaotingWindowInfo[i]._cont == floatCont)
274  			{
275  				rc.left   = _flaotingWindowInfo[i]._pos.left;
276  				rc.top	= _flaotingWindowInfo[i]._pos.top;
277  				rc.right  = _flaotingWindowInfo[i]._pos.right;
278  				rc.bottom = _flaotingWindowInfo[i]._pos.bottom;
279  				return true;
280  			}
281  		}
282  		return false;
283  	}
284  };
285  const int FONTSTYLE_NONE = 0;
286  const int FONTSTYLE_BOLD = 1;
287  const int FONTSTYLE_ITALIC = 2;
288  const int FONTSTYLE_UNDERLINE = 4;
289  const int STYLE_NOT_USED = -1;
290  const int COLORSTYLE_FOREGROUND = 0x01;
291  const int COLORSTYLE_BACKGROUND = 0x02;
292  const int COLORSTYLE_ALL = COLORSTYLE_FOREGROUND|COLORSTYLE_BACKGROUND;
293  struct Style final
294  {
295  	int _styleID = STYLE_NOT_USED;
296  	generic_string _styleDesc;
297  	COLORREF _fgColor = COLORREF(STYLE_NOT_USED);
298  	COLORREF _bgColor = COLORREF(STYLE_NOT_USED);
299  	int _colorStyle = COLORSTYLE_ALL;
300  	bool _isFontEnabled = false;
301  	generic_string _fontName;
302  	int _fontStyle = STYLE_NOT_USED;
303  	int _fontSize = STYLE_NOT_USED;
304  	int _nesting = FONTSTYLE_NONE;
305  	int _keywordClass = STYLE_NOT_USED;
306  	generic_string _keywords;
307  };
308  struct GlobalOverride final
309  {
310  	bool isEnable() const {return (enableFg || enableBg || enableFont || enableFontSize || enableBold || enableItalic || enableUnderLine);}
311  	bool enableFg = false;
312  	bool enableBg = false;
313  	bool enableFont = false;
314  	bool enableFontSize = false;
315  	bool enableBold = false;
316  	bool enableItalic = false;
317  	bool enableUnderLine = false;
318  };
319  struct StyleArray
320  {
321  	auto begin() { return _styleVect.begin(); };
322  	auto end() { return _styleVect.end(); };
323  	void clear() { _styleVect.clear(); };
324  	Style& getStyler(size_t index) {
325  		assert(index < _styleVect.size());
326  		return _styleVect[index];
327  	};
328  	void addStyler(int styleID, TiXmlNode *styleNode);
329  	void addStyler(int styleID, const generic_string& styleName) {
330  		_styleVect.emplace_back();
331  		Style& s = _styleVect.back();
332  		s._styleID = styleID;
333  		s._styleDesc = styleName;
334  		s._fgColor = black;
335  		s._bgColor = white;
336  	};
337  	Style* findByID(int id) {
338  		for (size_t i = 0; i < _styleVect.size(); ++i)
339  		{
340  			if (_styleVect[i]._styleID == id)
341  				return &(_styleVect[i]);
342  		}
343  		return nullptr;
344  	};
345  	Style* findByName(const generic_string& name) {
346  		for (size_t i = 0; i < _styleVect.size(); ++i)
347  		{
348  			if (_styleVect[i]._styleDesc == name)
349  				return &(_styleVect[i]);
350  		}
351  		return nullptr;
352  	};
353  protected:
354  	std::vector<Style> _styleVect;
355  };
356  struct LexerStyler : public StyleArray
357  {
358  public:
359  	LexerStyler & operator=(const LexerStyler & ls)
360  	{
361  		if (this != &ls)
362  		{
363  			*(static_cast<StyleArray *>(this)) = ls;
364  			this->_lexerName = ls._lexerName;
365  			this->_lexerDesc = ls._lexerDesc;
366  			this->_lexerUserExt = ls._lexerUserExt;
367  		}
368  		return *this;
369  	}
370  	void setLexerName(const TCHAR *lexerName)
371  	{
372  		_lexerName = lexerName;
373  	}
374  	void setLexerDesc(const TCHAR *lexerDesc)
375  	{
376  		_lexerDesc = lexerDesc;
377  	}
378  	void setLexerUserExt(const TCHAR *lexerUserExt) {
379  		_lexerUserExt = lexerUserExt;
380  	};
381  	const TCHAR * getLexerName() const {return _lexerName.c_str();};
382  	const TCHAR * getLexerDesc() const {return _lexerDesc.c_str();};
383  	const TCHAR * getLexerUserExt() const {return _lexerUserExt.c_str();};
384  private :
385  	generic_string _lexerName;
386  	generic_string _lexerDesc;
387  	generic_string _lexerUserExt;
388  };
389  struct SortLexersInAlphabeticalOrder {
390  	bool operator() (LexerStyler& l, LexerStyler& r) {
391  		if (!lstrcmp(l.getLexerDesc(), TEXT("Search result")))
392  			return false;
393  		if (!lstrcmp(r.getLexerDesc(), TEXT("Search result")))
394  			return true;
395  		return lstrcmp(l.getLexerDesc(), r.getLexerDesc()) < 0;
396  	}
397  };
398  struct LexerStylerArray
399  {
400  	size_t getNbLexer() const { return _lexerStylerVect.size(); }
401  	void clear() { _lexerStylerVect.clear(); }
402  	LexerStyler & getLexerFromIndex(size_t index)
403  	{
404  		assert(index < _lexerStylerVect.size());
405  		return _lexerStylerVect[index];
406  	};
407  	const TCHAR * getLexerNameFromIndex(size_t index) const { return _lexerStylerVect[index].getLexerName(); }
408  	const TCHAR * getLexerDescFromIndex(size_t index) const { return _lexerStylerVect[index].getLexerDesc(); }
409  	LexerStyler * getLexerStylerByName(const TCHAR *lexerName) {
410  		if (!lexerName) return nullptr;
411  		for (size_t i = 0 ; i < _lexerStylerVect.size() ; ++i)
412  		{
413  			if (!lstrcmp(_lexerStylerVect[i].getLexerName(), lexerName))
414  				return &(_lexerStylerVect[i]);
415  		}
416  		return nullptr;
417  	};
418  	void addLexerStyler(const TCHAR *lexerName, const TCHAR *lexerDesc, const TCHAR *lexerUserExt, TiXmlNode *lexerNode);
419  	void sort() {
420  		std::sort(_lexerStylerVect.begin(), _lexerStylerVect.end(), SortLexersInAlphabeticalOrder());
421  	};
422  private :
423  	std::vector<LexerStyler> _lexerStylerVect;
424  };
425  struct NewDocDefaultSettings final
426  {
427  	EolType _format = EolType::osdefault;
428  	UniMode _unicodeMode = uniCookie;
429  	bool _openAnsiAsUtf8 = true;
430  	LangType _lang = L_TEXT;
431  	int _codepage = -1; 
432  	bool _addNewDocumentOnStartup = false;
433  };
434  struct LangMenuItem final
435  {
436  	LangType _langType = L_TEXT;
437  	int	_cmdID = -1;
438  	std::wstring _langName;
439  	LangMenuItem(LangType lt, int cmdID = 0, const std::wstring& langName = TEXT("")):
440  	_langType(lt), _cmdID(cmdID), _langName(langName){};
441  };
442  struct PrintSettings final {
443  	bool _printLineNumber = true;
444  	int _printOption = SC_PRINT_COLOURONWHITE;
445  	std::wstring _headerLeft;
446  	std::wstring _headerMiddle;
447  	std::wstring _headerRight;
448  	std::wstring _headerFontName;
449  	int _headerFontStyle = 0;
450  	int _headerFontSize = 0;
451  	std::wstring _footerLeft;
452  	std::wstring _footerMiddle;
453  	std::wstring _footerRight;
454  	std::wstring _footerFontName;
455  	int _footerFontStyle = 0;
456  	int _footerFontSize = 0;
457  	RECT _marge = {};
458  	PrintSettings() {
459  		_marge.left = 0; _marge.top = 0; _marge.right = 0; _marge.bottom = 0;
460  	};
461  	bool isHeaderPresent() const {
462  		return ((_headerLeft != TEXT("")) || (_headerMiddle != TEXT("")) || (_headerRight != TEXT("")));
463  	};
464  	bool isFooterPresent() const {
465  		return ((_footerLeft != TEXT("")) || (_footerMiddle != TEXT("")) || (_footerRight != TEXT("")));
466  	};
467  	bool isUserMargePresent() const {
468  		return ((_marge.left != 0) || (_marge.top != 0) || (_marge.right != 0) || (_marge.bottom != 0));
469  	};
470  };
471  class Date final
472  {
473  public:
474  	Date() = default;
475  	Date(unsigned long year, unsigned long month, unsigned long day)
476  		: _year(year)
477  		, _month(month)
478  		, _day(day)
479  	{
480  		assert(year > 0 && year <= 9999); 
481  		assert(month > 0 && month <= 12);
482  		assert(day > 0 && day <= 31);
483  		assert(!(month == 2 && day > 29) &&
484  			   !(month == 4 && day > 30) &&
485  			   !(month == 6 && day > 30) &&
486  			   !(month == 9 && day > 30) &&
487  			   !(month == 11 && day > 30));
488  	}
489  	explicit Date(const TCHAR *dateStr);
490  	Date(int nbDaysFromNow);
491  	void now();
492  	generic_string toString() const 
493  	{
494  		TCHAR dateStr[16];
495  		wsprintf(dateStr, TEXT("%04u%02u%02u"), _year, _month, _day);
496  		return dateStr;
497  	}
498  	bool operator < (const Date & compare) const
499  	{
500  		if (this->_year != compare._year)
501  			return (this->_year < compare._year);
502  		if (this->_month != compare._month)
503  			return (this->_month < compare._month);
504  		return (this->_day < compare._day);
505  	}
506  	bool operator > (const Date & compare) const
507  	{
508  		if (this->_year != compare._year)
509  			return (this->_year > compare._year);
510  		if (this->_month != compare._month)
511  			return (this->_month > compare._month);
512  		return (this->_day > compare._day);
513  	}
514  	bool operator == (const Date & compare) const
515  	{
516  		if (this->_year != compare._year)
517  			return false;
518  		if (this->_month != compare._month)
519  			return false;
520  		return (this->_day == compare._day);
521  	}
522  	bool operator != (const Date & compare) const
523  	{
524  		if (this->_year != compare._year)
525  			return true;
526  		if (this->_month != compare._month)
527  			return true;
528  		return (this->_day != compare._day);
529  	}
530  private:
531  	unsigned long _year  = 2008;
532  	unsigned long _month = 4;
533  	unsigned long _day   = 26;
534  };
535  class MatchedPairConf final
536  {
537  public:
538  	bool hasUserDefinedPairs() const { return _matchedPairs.size() != 0; }
539  	bool hasDefaultPairs() const { return _doParentheses||_doBrackets||_doCurlyBrackets||_doQuotes||_doDoubleQuotes||_doHtmlXmlTag; }
540  	bool hasAnyPairsPair() const { return hasUserDefinedPairs() || hasDefaultPairs(); }
541  public:
542  	std::vector<std::pair<char, char>> _matchedPairs;
543  	std::vector<std::pair<char, char>> _matchedPairsInit; 
544  	bool _doHtmlXmlTag = false;
545  	bool _doParentheses = false;
546  	bool _doBrackets = false;
547  	bool _doCurlyBrackets = false;
548  	bool _doQuotes = false;
549  	bool _doDoubleQuotes = false;
550  };
551  struct DarkModeConf final
552  {
553  	bool _isEnabled = false;
554  	bool _isEnabledPlugin = true;
555  	NppDarkMode::ColorTone _colorTone = NppDarkMode::blackTone;
556  	NppDarkMode::Colors _customColors = NppDarkMode::getDarkModeDefaultColors();
557  	NppDarkMode::AdvancedOptions _advOptions{};
558  };
559  struct LargeFileRestriction final
560  {
561  	int64_t _largeFileSizeDefInByte = NPP_STYLING_FILESIZE_LIMIT_DEFAULT;
562  	bool _isEnabled = true;
563  	bool _deactivateWordWrap = true;
564  	bool _allowBraceMatch = false;
565  	bool _allowAutoCompletion = false;
566  	bool _allowSmartHilite = false;
567  	bool _allowClickableLink = false;
568  };
569  struct NppGUI final
570  {
571  	NppGUI()
572  	{
573  		_appPos.left = 0;
574  		_appPos.top = 0;
575  		_appPos.right = 1100;
576  		_appPos.bottom = 700;
577  		_findWindowPos.left = 0;
578  		_findWindowPos.top = 0;
579  		_findWindowPos.right = 0;
580  		_findWindowPos.bottom = 0;
581  		_defaultDir[0] = 0;
582  		_defaultDirExp[0] = 0;
583  	}
584  	toolBarStatusType _toolBarStatus = TB_STANDARD;
585  	bool _toolbarShow = true;
586  	bool _statusBarShow = true;
587  	bool _menuBarShow = true;
588  	int _tabStatus = (TAB_DRAWTOPBAR | TAB_DRAWINACTIVETAB | TAB_DRAGNDROP | TAB_REDUCE | TAB_CLOSEBUTTON);
589  	bool _splitterPos = POS_VERTICAL;
590  	int _userDefineDlgStatus = UDD_DOCKED;
591  	int _tabSize = 4;
592  	bool _tabReplacedBySpace = false;
593  	bool _finderLinesAreCurrentlyWrapped = false;
594  	bool _finderPurgeBeforeEverySearch = false;
595  	bool _finderShowOnlyOneEntryPerFoundLine = true;
596  	int _fileAutoDetection = cdEnabledNew;
597  	bool _checkHistoryFiles = false;
598  	RECT _appPos = {};
599  	RECT _findWindowPos = {};
600  	bool _findWindowLessMode = false;
601  	bool _isMaximized = false;
602  	bool _isMinimizedToTray = false;
603  	bool _rememberLastSession = true; 
604  	bool _isCmdlineNosessionActivated = false; 
605  	bool _detectEncoding = true;
606  	bool _saveAllConfirm = true;
607  	bool _setSaveDlgExtFiltToAllTypes = false;
608  	bool _doTaskList = true;
609  	bool _maitainIndent = true;
610  	bool _enableSmartHilite = true;
611  	bool _smartHiliteCaseSensitive = false;
612  	bool _smartHiliteWordOnly = true;
613  	bool _smartHiliteUseFindSettings = false;
614  	bool _smartHiliteOnAnotherView = false;
615  	bool _markAllCaseSensitive = false;
616  	bool _markAllWordOnly = true;
617  	bool _disableSmartHiliteTmp = false;
618  	bool _enableTagsMatchHilite = true;
619  	bool _enableTagAttrsHilite = true;
620  	bool _enableHiliteNonHTMLZone = false;
621  	bool _styleMRU = true;
622  	char _leftmostDelimiter = '(';
623  	char _rightmostDelimiter = ')';
624  	bool _delimiterSelectionOnEntireDocument = false;
625  	bool _backSlashIsEscapeCharacterForSql = true;
626  	bool _fillFindFieldWithSelected = true;
627  	bool _fillFindFieldSelectCaret = true;
628  	bool _monospacedFontFindDlg = false;
629  	bool _findDlgAlwaysVisible = false;
630  	bool _confirmReplaceInAllOpenDocs = true;
631  	bool _replaceStopsWithoutFindingNext = false;
632  	bool _muteSounds = false;
633  	bool _enableFoldCmdToggable = false;
634  	bool _hideMenuRightShortcuts = false;
635  	writeTechnologyEngine _writeTechnologyEngine = defaultTechnology;
636  	bool _isWordCharDefault = true;
637  	std::string _customWordChars;
638  	urlMode _styleURL = urlUnderLineFg;
639  	generic_string _uriSchemes = TEXT("svn:&bsol;&bsol; cvs:&bsol;&bsol; git:&bsol;&bsol; imap:&bsol;&bsol; irc:&bsol;&bsol; irc6:&bsol;&bsol; ircs:&bsol;&bsol; ldap:&bsol;&bsol; ldaps:&bsol;&bsol; news: telnet:&bsol;&bsol; gopher:&bsol;&bsol; ssh:&bsol;&bsol; sftp:&bsol;&bsol; smb:&bsol;&bsol; skype: snmp:&bsol;&bsol; spotify: steam:&bsol;&bsol; sms: slack:&bsol;&bsol; chrome:&bsol;&bsol; bitcoin:");
640  	NewDocDefaultSettings _newDocDefaultSettings;
641  	generic_string _dateTimeFormat = TEXT("yyyy-MM-dd HH:mm:ss");
642  	bool _dateTimeReverseDefaultOrder = false;
643  	void setTabReplacedBySpace(bool b) {_tabReplacedBySpace = b;};
644  	const NewDocDefaultSettings & getNewDocDefaultSettings() const {return _newDocDefaultSettings;};
645  	std::vector<LangMenuItem> _excludedLangList;
646  	bool _isLangMenuCompact = true;
647  	PrintSettings _printSettings;
648  	BackupFeature _backup = bak_none;
649  	bool _useDir = false;
650  	generic_string _backupDir;
651  	DockingManagerData _dockingData;
652  	GlobalOverride _globalOverride;
653  	enum AutocStatus{autoc_none, autoc_func, autoc_word, autoc_both};
654  	AutocStatus _autocStatus = autoc_both;
655  	UINT  _autocFromLen = 1;
656  	bool _autocIgnoreNumbers = true;
657  	bool _autocInsertSelectedUseENTER = true;
658  	bool _autocInsertSelectedUseTAB = true;
659  	bool _autocBrief = false;
660  	bool _funcParams = true;
661  	MatchedPairConf _matchedPairConf;
662  	generic_string _definedSessionExt;
663  	generic_string _definedWorkspaceExt;
664  	generic_string _commandLineInterpreter = CMD_INTERPRETER;
665  	struct AutoUpdateOptions
666  	{
667  		bool _doAutoUpdate = true;
668  		int _intervalDays = 15;
669  		Date _nextUpdateDate;
670  		AutoUpdateOptions(): _nextUpdateDate(Date()) {};
671  	}
672  	_autoUpdateOpt;
673  	bool _doesExistUpdater = false;
674  	int _caretBlinkRate = 600;
675  	int _caretWidth = 1;
676  	bool _enableMultiSelection = false;
677  	bool _shortTitlebar = false;
678  	OpenSaveDirSetting _openSaveDir = dir_followCurrent;
679  	TCHAR _defaultDir[MAX_PATH];
680  	TCHAR _defaultDirExp[MAX_PATH];	
681  	generic_string _themeName;
682  	MultiInstSetting _multiInstSetting = monoInst;
683  	bool _clipboardHistoryPanelKeepState = false;
684  	bool _docListKeepState = false;
685  	bool _charPanelKeepState = false;
686  	bool _fileBrowserKeepState = false;
687  	bool _projectPanelKeepState = false;
688  	bool _docMapKeepState = false;
689  	bool _funcListKeepState = false;
690  	bool _pluginPanelKeepState = false;
691  	bool _fileSwitcherWithoutExtColumn = false;
692  	int _fileSwitcherExtWidth = 50;
693  	bool _fileSwitcherWithoutPathColumn = true;
694  	int _fileSwitcherPathWidth = 50;
695  	bool _fileSwitcherDisableListViewGroups = false;
696  	bool isSnapshotMode() const {return _isSnapshotMode && _rememberLastSession && !_isCmdlineNosessionActivated;};
697  	bool _isSnapshotMode = true;
698  	size_t _snapshotBackupTiming = 7000;
699  	generic_string _cloudPath; 
700  	unsigned char _availableClouds = '\0'; 
701  	enum SearchEngineChoice{ se_custom = 0, se_duckDuckGo = 1, se_google = 2, se_bing = 3, se_yahoo = 4, se_stackoverflow = 5 };
702  	SearchEngineChoice _searchEngineChoice = se_google;
703  	generic_string _searchEngineCustom;
704  	bool _isFolderDroppedOpenFiles = false;
705  	bool _isDocPeekOnTab = false;
706  	bool _isDocPeekOnMap = false;
707  	bool _shouldSortFunctionList = false;
708  	DarkModeConf _darkmode;
709  	LargeFileRestriction _largeFileRestriction;
710  };
711  struct ScintillaViewParams
712  {
713  	bool _lineNumberMarginShow = true;
714  	bool _lineNumberMarginDynamicWidth = true;
715  	bool _bookMarkMarginShow = true;
716  	bool _isChangeHistoryEnabled = true;
717  	bool _isChangeHistoryEnabled4NextSession = true;
718  	folderStyle  _folderStyle = FOLDER_STYLE_BOX; 
719  	lineWrapMethod _lineWrapMethod = LINEWRAP_ALIGNED;
720  	bool _foldMarginShow = true;
721  	bool _indentGuideLineShow = true;
722  	lineHiliteMode _currentLineHiliteMode = LINEHILITE_HILITE;
723  	unsigned char _currentLineFrameWidth = 1; 
724  	bool _wrapSymbolShow = false;
725  	bool _doWrap = false;
726  	bool _isEdgeBgMode = false;
727  	std::vector<size_t> _edgeMultiColumnPos;
728  	intptr_t _zoom = 0;
729  	intptr_t _zoom2 = 0;
730  	bool _whiteSpaceShow = false;
731  	bool _eolShow = false;
732  	enum crlfMode {plainText = 0, roundedRectangleText = 1, plainTextCustomColor = 2, roundedRectangleTextCustomColor = 3};
733  	crlfMode _eolMode = roundedRectangleText;
734  	bool _npcShow = false;
735  	enum npcMode { identity = 0, abbreviation = 1, codepoint = 2 };
736  	npcMode _npcMode = abbreviation;
737  	bool _npcCustomColor = false;
738  	bool _npcIncludeCcUniEol = false;
739  	bool _ccUniEolShow = true;
740  	int _borderWidth = 2;
741  	bool _virtualSpace = false;
742  	bool _scrollBeyondLastLine = true;
743  	bool _rightClickKeepsSelection = false;
744  	bool _disableAdvancedScrolling = false;
745  	bool _doSmoothFont = false;
746  	bool _showBorderEdge = true;
747  	unsigned char _paddingLeft = 0;  
748  	unsigned char _paddingRight = 0; 
749  	unsigned char _distractionFreeDivPart = 4;     
750  	int getDistractionFreePadding(int editViewWidth) const {
751  		const int defaultDiviser = 4;
752  		int diviser = _distractionFreeDivPart > 2 ? _distractionFreeDivPart : defaultDiviser;
753  		int paddingLen = editViewWidth / diviser;
754  		if (paddingLen <= 0)
755  			paddingLen = editViewWidth / defaultDiviser;
756  		return paddingLen;
757  	};
758  };
759  const int NB_LIST = 20;
760  const int NB_MAX_LRF_FILE = 30;
761  const int NB_MAX_USER_LANG = 30;
762  const int NB_MAX_EXTERNAL_LANG = 30;
763  const int NB_MAX_IMPORTED_UDL = 50;
764  constexpr int NB_DEFAULT_LRF_CUSTOMLENGTH = 100;
765  constexpr int NB_MAX_LRF_CUSTOMLENGTH = MAX_PATH - 1;
766  const int NB_MAX_FINDHISTORY_FIND	= 30;
767  const int NB_MAX_FINDHISTORY_REPLACE = 30;
768  const int NB_MAX_FINDHISTORY_PATH	= 30;
769  const int NB_MAX_FINDHISTORY_FILTER  = 20;
770  const int MASK_ReplaceBySpc = 0x80;
771  const int MASK_TabSize = 0x7F;
772  struct Lang final
773  {
774  	LangType _langID = L_TEXT;
775  	generic_string _langName;
776  	const TCHAR* _defaultExtList = nullptr;
777  	const TCHAR* _langKeyWordList[NB_LIST];
778  	const TCHAR* _pCommentLineSymbol = nullptr;
779  	const TCHAR* _pCommentStart = nullptr;
780  	const TCHAR* _pCommentEnd = nullptr;
781  	bool _isTabReplacedBySpace = false;
782  	int _tabSize = -1;
783  	Lang()
784  	{
785  		for (int i = 0 ; i < NB_LIST ; _langKeyWordList[i] = NULL, ++i);
786  	}
787  	Lang(LangType langID, const TCHAR *name) : _langID(langID), _langName(name ? name : TEXT(""))
788  	{
789  		for (int i = 0 ; i < NB_LIST ; _langKeyWordList[i] = NULL, ++i);
790  	}
791  	~Lang() = default;
792  	void setDefaultExtList(const TCHAR *extLst){
793  		_defaultExtList = extLst;
794  	}
795  	void setCommentLineSymbol(const TCHAR *commentLine){
796  		_pCommentLineSymbol = commentLine;
797  	}
798  	void setCommentStart(const TCHAR *commentStart){
799  		_pCommentStart = commentStart;
800  	}
801  	void setCommentEnd(const TCHAR *commentEnd){
802  		_pCommentEnd = commentEnd;
803  	}
804  	void setTabInfo(int tabInfo)
805  	{
806  		if (tabInfo != -1 && tabInfo & MASK_TabSize)
807  		{
808  			_isTabReplacedBySpace = (tabInfo & MASK_ReplaceBySpc) != 0;
809  			_tabSize = tabInfo & MASK_TabSize;
810  		}
811  	}
812  	const TCHAR * getDefaultExtList() const {
813  		return _defaultExtList;
814  	}
815  	void setWords(const TCHAR *words, int index) {
816  		_langKeyWordList[index] = words;
817  	}
818  	const TCHAR * getWords(int index) const {
819  		return _langKeyWordList[index];
820  	}
821  	LangType getLangID() const {return _langID;};
822  	const TCHAR * getLangName() const {return _langName.c_str();};
823  	int getTabInfo() const
824  	{
825  		if (_tabSize == -1) return -1;
826  		return (_isTabReplacedBySpace?0x80:0x00) | _tabSize;
827  	}
828  };
829  class UserLangContainer final
830  {
831  public:
832  	UserLangContainer() :_name(TEXT("new user define")), _ext(TEXT("")), _udlVersion(TEXT("")) {
833  		for (int i = 0; i < SCE_USER_KWLIST_TOTAL; ++i) *_keywordLists[i] = '\0';
834  	}
835  	UserLangContainer(const TCHAR *name, const TCHAR *ext, bool isDarkModeTheme, const TCHAR *udlVer):
836  		_name(name), _ext(ext), _isDarkModeTheme(isDarkModeTheme), _udlVersion(udlVer) {
837  		for (int i = 0; i < SCE_USER_KWLIST_TOTAL; ++i) *_keywordLists[i] = '\0';
838  	}
839  	UserLangContainer & operator = (const UserLangContainer & ulc)
840  	{
841  		if (this != &ulc)
842  		{
843  			this->_name = ulc._name;
844  			this->_ext = ulc._ext;
845  			this->_isDarkModeTheme = ulc._isDarkModeTheme;
846  			this->_udlVersion = ulc._udlVersion;
847  			this->_isCaseIgnored = ulc._isCaseIgnored;
848  			this->_styles = ulc._styles;
849  			this->_allowFoldOfComments = ulc._allowFoldOfComments;
850  			this->_forcePureLC = ulc._forcePureLC;
851  			this->_decimalSeparator = ulc._decimalSeparator;
852  			this->_foldCompact = ulc._foldCompact;
853  			for (Style & st : this->_styles)
854  			{
855  				if (st._bgColor == COLORREF(-1))
856  					st._bgColor = white;
857  				if (st._fgColor == COLORREF(-1))
858  					st._fgColor = black;
859  			}
860  			for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
861  				wcscpy_s(this->_keywordLists[i], ulc._keywordLists[i]);
862  			for (int i = 0 ; i < SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
863  				_isPrefix[i] = ulc._isPrefix[i];
864  		}
865  		return *this;
866  	}
867  	const TCHAR * getName() {return _name.c_str();};
868  	const TCHAR * getExtention() {return _ext.c_str();};
869  	const TCHAR * getUdlVersion() {return _udlVersion.c_str();};
870  private:
871  	StyleArray _styles;
872  	generic_string _name;
873  	generic_string _ext;
874  	bool _isDarkModeTheme = false;
875  	generic_string _udlVersion;
876  	TCHAR _keywordLists[SCE_USER_KWLIST_TOTAL][max_char];
877  	bool _isPrefix[SCE_USER_TOTAL_KEYWORD_GROUPS] = {false};
878  	bool _isCaseIgnored = false;
879  	bool _allowFoldOfComments = false;
880  	int  _forcePureLC = PURE_LC_NONE;
881  	int _decimalSeparator = DECSEP_DOT;
882  	bool _foldCompact = false;
883  	friend class Notepad_plus;
884  	friend class ScintillaEditView;
885  	friend class NppParameters;
886  	friend class SharedParametersDialog;
887  	friend class FolderStyleDialog;
888  	friend class KeyWordsStyleDialog;
889  	friend class CommentStyleDialog;
890  	friend class SymbolsStyleDialog;
891  	friend class UserDefineDialog;
892  	friend class StylerDlg;
893  };
894  #define MAX_EXTERNAL_LEXER_NAME_LEN 128
895  class ExternalLangContainer final
896  {
897  public:
898  	std::string _name;
899  	Lexilla::CreateLexerFn fnCL = nullptr;
900  	ExternalLexerAutoIndentMode _autoIndentMode = ExternalLexerAutoIndentMode::Standard;
901  };
902  struct FindHistory final
903  {
904  	enum searchMode{normal, extended, regExpr};
905  	enum transparencyMode{none, onLossingFocus, persistant};
906  	bool _isSearch2ButtonsMode = false;
907  	int _nbMaxFindHistoryPath    = 10;
908  	int _nbMaxFindHistoryFilter  = 10;
909  	int _nbMaxFindHistoryFind    = 10;
910  	int _nbMaxFindHistoryReplace = 10;
911  	std::vector<generic_string> _findHistoryPaths;
912  	std::vector<generic_string> _findHistoryFilters;
913  	std::vector<generic_string> _findHistoryFinds;
914  	std::vector<generic_string> _findHistoryReplaces;
915  	bool _isMatchWord = false;
916  	bool _isMatchCase = false;
917  	bool _isWrap = true;
918  	bool _isDirectionDown = true;
919  	bool _dotMatchesNewline = false;
920  	bool _isFifRecuisive = true;
921  	bool _isFifInHiddenFolder = false;
922      bool _isFifProjectPanel_1 = false;
923      bool _isFifProjectPanel_2 = false;
924      bool _isFifProjectPanel_3 = false;
925  	searchMode _searchMode = normal;
926  	transparencyMode _transparencyMode = onLossingFocus;
927  	int _transparency = 150;
928  	bool _isFilterFollowDoc = false;
929  	bool _isFolderFollowDoc = false;
930  	bool _isBookmarkLine = false;
931  	bool _isPurge = false;
932  	bool _regexBackward4PowerUser = false;
933  };
934  struct ColumnEditorParam final
935  {
936  	enum leadingChoice : UCHAR { noneLeading, zeroLeading, spaceLeading };
937  	bool _mainChoice = activeNumeric;
938  	std::wstring _insertedTextContent;
939  	int _initialNum = -1;
940  	int _increaseNum = -1;
941  	int _repeatNum = -1;
942  	int _formatChoice = 0; 
943  	leadingChoice _leadingChoice = noneLeading;
944  };
945  class LocalizationSwitcher final
946  {
947  friend class NppParameters;
948  public:
949  	struct LocalizationDefinition
950  	{
951  		const wchar_t *_langName = nullptr;
952  		const wchar_t *_xmlFileName = nullptr;
953  	};
954  	bool addLanguageFromXml(const std::wstring& xmlFullPath);
955  	std::wstring getLangFromXmlFileName(const wchar_t *fn) const;
956  	std::wstring getXmlFilePathFromLangName(const wchar_t *langName) const;
957  	bool switchToLang(const wchar_t *lang2switch) const;
958  	size_t size() const
959  	{
960  		return _localizationList.size();
961  	}
962  	std::pair<std::wstring, std::wstring> getElementFromIndex(size_t index) const
963  	{
964  		if (index >= _localizationList.size())
965  			return std::pair<std::wstring, std::wstring>(std::wstring(), std::wstring());
966  		return _localizationList[index];
967  	}
968  	void setFileName(const char *fn)
969  	{
970  		if (fn)
971  			_fileName = fn;
972  	}
973  	std::string getFileName() const
974  	{
975  		return _fileName;
976  	}
977  private:
978  	std::vector< std::pair< std::wstring, std::wstring > > _localizationList;
979  	std::wstring _nativeLangPath;
980  	std::string _fileName;
981  };
982  class ThemeSwitcher final
983  {
984  friend class NppParameters;
985  public:
986  	void addThemeFromXml(const generic_string& xmlFullPath) {
987  		_themeList.push_back(std::pair<generic_string, generic_string>(getThemeFromXmlFileName(xmlFullPath.c_str()), xmlFullPath));
988  	}
989  	void addDefaultThemeFromXml(const generic_string& xmlFullPath) {
990  		_themeList.push_back(std::pair<generic_string, generic_string>(_defaultThemeLabel, xmlFullPath));
991  	}
992  	generic_string getThemeFromXmlFileName(const TCHAR *fn) const;
993  	generic_string getXmlFilePathFromThemeName(const TCHAR *themeName) const {
994  		if (!themeName || themeName[0])
995  			return generic_string();
996  		generic_string themePath = _stylesXmlPath;
997  		return themePath;
998  	}
999  	bool themeNameExists(const TCHAR *themeName) {
1000  		for (size_t i = 0; i < _themeList.size(); ++i )
1001  		{
1002  			auto& themeNameOnList = getElementFromIndex(i).first;
1003  			if (lstrcmp(themeName, themeNameOnList.c_str()) == 0)
1004  				return true;
1005  		}
1006  		return false;
1007  	}
1008  	size_t size() const { return _themeList.size(); }
1009  	std::pair<generic_string, generic_string> & getElementFromIndex(size_t index)
1010  	{
1011  		assert(index < _themeList.size());
1012  		return _themeList[index];
1013  	}
1014  	void setThemeDirPath(generic_string themeDirPath) { _themeDirPath = themeDirPath; }
1015  	generic_string getThemeDirPath() const { return _themeDirPath; }
1016  	generic_string getDefaultThemeLabel() const { return _defaultThemeLabel; }
1017  	generic_string getSavePathFrom(const generic_string& path) const {
1018  		const auto iter = _themeStylerSavePath.find(path);
1019  		if (iter == _themeStylerSavePath.end())
1020  		{
1021  			return TEXT("");
1022  		}
1023  		else
1024  		{
1025  			return iter->second;
1026  		}
1027  	};
1028  	void addThemeStylerSavePath(generic_string key, generic_string val) {
1029  		_themeStylerSavePath[key] = val;
1030  	};
1031  private:
1032  	std::vector<std::pair<generic_string, generic_string>> _themeList;
1033  	std::map<generic_string, generic_string> _themeStylerSavePath;
1034  	generic_string _themeDirPath;
1035  	const generic_string _defaultThemeLabel = TEXT("Default (stylers.xml)");
1036  	generic_string _stylesXmlPath;
1037  };
1038  struct UdlXmlFileState final {
1039  	TiXmlDocument* _udlXmlDoc = nullptr;
1040  	bool _isDirty = false;
1041  	bool _isInDefaultSharedContainer = false; 
1042  	std::pair<unsigned char, unsigned char> _indexRange;
1043  	UdlXmlFileState(TiXmlDocument* doc, bool isDirty, bool isInDefaultSharedContainer, std::pair<unsigned char, unsigned char> range)
1044  		: _udlXmlDoc(doc), _isDirty(isDirty), _isInDefaultSharedContainer(isInDefaultSharedContainer), _indexRange(range) {};
1045  };
1046  const int NB_LANG = 100;
1047  const int RECENTFILES_SHOWFULLPATH = -1;
1048  const int RECENTFILES_SHOWONLYFILENAME = 0;
1049  class DynamicMenu final
1050  {
1051  public:
1052  	bool attach(HMENU hMenu, unsigned int posBase, int lastCmd, const generic_string& lastCmdLabel);
1053  	bool createMenu() const;
1054  	bool clearMenu() const;
1055  	int getTopLevelItemNumber() const;
1056  	void push_back(const MenuItemUnit& m) {
1057  		_menuItems.push_back(m);
1058  	};
1059  	MenuItemUnit& getItemFromIndex(size_t i) {
1060  		return _menuItems[i];
1061  	};
1062  	void erase(size_t i) {
1063  		_menuItems.erase(_menuItems.begin() + i);
1064  	}
1065  	unsigned int getPosBase() const { return _posBase; };
1066  	generic_string getLastCmdLabel() const { return _lastCmdLabel; };
1067  private:
1068  	std::vector<MenuItemUnit> _menuItems;
1069  	HMENU _hMenu = nullptr;
1070  	unsigned int _posBase = 0;
1071  	int _lastCmd = 0;
1072  	generic_string _lastCmdLabel;
1073  };
1074  class NppParameters final
1075  {
1076  private:
1077  	static NppParameters* getInstancePointer() {
1078  		static NppParameters* instance = new NppParameters;
1079  		return instance;
1080  	};
1081  public:
1082  	static NppParameters& getInstance() {
1083  		return *getInstancePointer();
1084  	};
1085  	static LangType getLangIDFromStr(const TCHAR *langName);
1086  	static generic_string getLocPathFromStr(const generic_string & localizationCode);
1087  	bool load();
1088  	bool reloadLang();
1089  	bool reloadStylers(const TCHAR *stylePath = nullptr);
1090  	void destroyInstance();
1091  	generic_string getSettingsFolder();
1092  	bool _isTaskListRBUTTONUP_Active = false;
1093  	int L_END;
1094  	NppGUI & getNppGUI() {
1095  		return _nppGUI;
1096  	}
1097  	const TCHAR * getWordList(LangType langID, int typeIndex) const
1098  	{
1099  		Lang *pLang = getLangFromID(langID);
1100  		if (!pLang) return nullptr;
1101  		return pLang->getWords(typeIndex);
1102  	}
1103  	Lang * getLangFromID(LangType langID) const
1104  	{
1105  		for (int i = 0 ; i < _nbLang ; ++i)
1106  		{
1107  			if ( _langList[i] && _langList[i]->_langID == langID )
1108  				return _langList[i];
1109  		}
1110  		return nullptr;
1111  	}
1112  	Lang * getLangFromIndex(size_t i) const {
1113  		return (i < size_t(_nbLang)) ? _langList[i] : nullptr;
1114  	}
1115  	int getNbLang() const {return _nbLang;};
1116  	LangType getLangFromExt(const TCHAR *ext);
1117  	const TCHAR * getLangExtFromName(const TCHAR *langName) const
1118  	{
1119  		for (int i = 0 ; i < _nbLang ; ++i)
1120  		{
1121  			if (_langList[i]->_langName == langName)
1122  				return _langList[i]->_defaultExtList;
1123  		}
1124  		return nullptr;
1125  	}
1126  	const TCHAR * getLangExtFromLangType(LangType langType) const
1127  	{
1128  		for (int i = 0 ; i < _nbLang ; ++i)
1129  		{
1130  			if (_langList[i]->_langID == langType)
1131  				return _langList[i]->_defaultExtList;
1132  		}
1133  		return nullptr;
1134  	}
1135  	int getNbLRFile() const {return _nbRecentFile;};
1136  	generic_string *getLRFile(int index) const {
1137  		return _LRFileList[index];
1138  	};
1139  	void setNbMaxRecentFile(UINT nb) {
1140  		_nbMaxRecentFile = nb;
1141  	};
1142  	UINT getNbMaxRecentFile() const {return _nbMaxRecentFile;};
1143  	void setPutRecentFileInSubMenu(bool doSubmenu) {
1144  		_putRecentFileInSubMenu = doSubmenu;
1145  	}
1146  	bool putRecentFileInSubMenu() const {return _putRecentFileInSubMenu;};
1147  	void setRecentFileCustomLength(int len) {
1148  		_recentFileCustomLength = len;
1149  	}
1150  	int getRecentFileCustomLength() const {return _recentFileCustomLength;};
1151  	const ScintillaViewParams& getSVP() const {
1152  		return _svp;
1153  	}
1154  	bool writeRecentFileHistorySettings(int nbMaxFile = -1) const;
1155  	bool writeHistory(const TCHAR *fullpath);
1156  	bool writeProjectPanelsSettings() const;
1157  	bool writeColumnEditorSettings() const;
1158  	bool writeFileBrowserSettings(const std::vector<generic_string> & rootPath, const generic_string & latestSelectedItemPath) const;
1159  	TiXmlNode* getChildElementByAttribut(TiXmlNode *pere, const TCHAR *childName, const TCHAR *attributName, const TCHAR *attributVal) const;
1160  	bool writeScintillaParams();
1161  	void createXmlTreeFromGUIParams();
1162  	generic_string writeStyles(LexerStylerArray & lexersStylers, StyleArray & globalStylers); 
1163  	bool insertTabInfo(const TCHAR *langName, int tabInfo);
1164  	LexerStylerArray & getLStylerArray() {return _lexerStylerVect;};
1165  	StyleArray & getGlobalStylers() {return _widgetStyleArray;};
1166  	StyleArray & getMiscStylerArray() {return _widgetStyleArray;};
1167  	GlobalOverride & getGlobalOverrideStyle() {return _nppGUI._globalOverride;};
1168  	COLORREF getCurLineHilitingColour();
1169  	void setCurLineHilitingColour(COLORREF colour2Set);
1170  	void setFontList(HWND hWnd);
1171  	bool isInFontList(const generic_string& fontName2Search) const;
1172  	const std::vector<generic_string>& getFontList() const { return _fontlist; }
1173  	enum class DefaultFontType { menu, status, message, caption, smcaption };
1174  	static LOGFONT getDefaultGUIFont(DefaultFontType type = DefaultFontType::message);
1175  	int getNbUserLang() const {return _nbUserLang;}
1176  	UserLangContainer & getULCFromIndex(size_t i) {return *_userLangArray[i];};
1177  	UserLangContainer * getULCFromName(const TCHAR *userLangName);
1178  	int getNbExternalLang() const {return _nbExternalLang;};
1179  	int getExternalLangIndexFromName(const TCHAR *externalLangName) const;
1180  	ExternalLangContainer & getELCFromIndex(int i) {return *_externalLangArray[i];};
1181  	bool ExternalLangHasRoom() const {return _nbExternalLang < NB_MAX_EXTERNAL_LANG;};
1182  	void getExternalLexerFromXmlTree(TiXmlDocument* externalLexerDoc);
1183  	std::vector<TiXmlDocument *> * getExternalLexerDoc() { return &_pXmlExternalLexerDoc; };
1184  	void writeDefaultUDL();
1185  	void writeNonDefaultUDL();
1186  	void writeNeed2SaveUDL();
1187  	void writeShortcuts();
1188  	void writeSession(const Session & session, const TCHAR *fileName = NULL);
1189  	bool writeFindHistory();
1190  	bool isExistingUserLangName(const TCHAR *newName) const
1191  	{
1192  		if ((!newName) || (!newName[0]))
1193  			return true;
1194  		for (int i = 0 ; i < _nbUserLang ; ++i)
1195  		{
1196  			if (!lstrcmp(_userLangArray[i]->_name.c_str(), newName))
1197  				return true;
1198  		}
1199  		return false;
1200  	}
<span onclick='openModal()' class='match'>1201  	const TCHAR * getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const;
1202  	int addUserLangToEnd(const UserLangContainer & userLang, const TCHAR *newName);
1203  	void removeUserLang(size_t index);
1204  	bool isExistingExternalLangName(const char* newName) const;
1205  	int addExternalLangToEnd(ExternalLangContainer * externalLang);
1206  	TiXmlDocumentA * getNativeLangA() const {return _pXmlNativeLangDocA;};
</span>1207  	TiXmlDocument * getCustomizedToolIcons() const {return _pXmlToolIconsDoc;};
1208  	bool isTransparentAvailable() const {
1209  		return (_winVersion >= WV_VISTA);
1210  	}
1211  	void SetTransparent(HWND hwnd, int percent);
1212  	void removeTransparent(HWND hwnd);
1213  	void setCmdlineParam(const CmdLineParamsDTO & cmdLineParams)
1214  	{
1215  		_cmdLineParams = cmdLineParams;
1216  	}
1217  	const CmdLineParamsDTO & getCmdLineParams() const {return _cmdLineParams;};
1218  	const generic_string& getCmdLineString() const { return _cmdLineString; }
1219  	void setCmdLineString(const generic_string& str) { _cmdLineString = str; }
1220  	void setFileSaveDlgFilterIndex(int ln) {_fileSaveDlgFilterIndex = ln;};
1221  	int getFileSaveDlgFilterIndex() const {return _fileSaveDlgFilterIndex;};
1222  	bool isRemappingShortcut() const {return _shortcuts.size() != 0;};
1223  	std::vector<CommandShortcut> & getUserShortcuts() { return _shortcuts; };
1224  	std::vector<size_t> & getUserModifiedShortcuts() { return _customizedShortcuts; };
1225  	void addUserModifiedIndex(size_t index);
1226  	std::vector<MacroShortcut> & getMacroList() { return _macros; };
1227  	std::vector<UserCommand> & getUserCommandList() { return _userCommands; };
1228  	std::vector<PluginCmdShortcut> & getPluginCommandList() { return _pluginCommands; };
1229  	std::vector<size_t> & getPluginModifiedKeyIndices() { return _pluginCustomizedCmds; };
1230  	void addPluginModifiedIndex(size_t index);
1231  	std::vector<ScintillaKeyMap> & getScintillaKeyList() { return _scintillaKeyCommands; };
1232  	std::vector<int> & getScintillaModifiedKeyIndices() { return _scintillaModifiedKeyIndices; };
1233  	void addScintillaModifiedIndex(int index);
1234  	const Session & getSession() const {return _session;};
1235  	std::vector<MenuItemUnit>& getContextMenuItems() { return _contextMenuItems; };
1236  	std::vector<MenuItemUnit>& getTabContextMenuItems() { return _tabContextMenuItems; };
1237  	DynamicMenu& getMacroMenuItems() { return _macroMenuItems; };
1238  	DynamicMenu& getRunMenuItems() { return _runMenuItems; };
1239  	bool hasCustomContextMenu() const {return !_contextMenuItems.empty();};
1240  	bool hasCustomTabContextMenu() const {return !_tabContextMenuItems.empty();};
1241  	void setAccelerator(Accelerator *pAccel) {_pAccelerator = pAccel;};
1242  	Accelerator * getAccelerator() {return _pAccelerator;};
1243  	void setScintillaAccelerator(ScintillaAccelerator *pScintAccel) {_pScintAccelerator = pScintAccel;};
1244  	ScintillaAccelerator * getScintillaAccelerator() {return _pScintAccelerator;};
1245  	generic_string getNppPath() const {return _nppPath;};
1246  	generic_string getContextMenuPath() const {return _contextMenuPath;};
1247  	const TCHAR * getAppDataNppDir() const {return _appdataNppDir.c_str();};
1248  	const TCHAR * getPluginRootDir() const { return _pluginRootDir.c_str(); };
1249  	const TCHAR * getPluginConfDir() const { return _pluginConfDir.c_str(); };
1250  	const TCHAR * getUserPluginConfDir() const { return _userPluginConfDir.c_str(); };
1251  	const TCHAR * getWorkingDir() const {return _currentDirectory.c_str();};
1252  	const TCHAR * getWorkSpaceFilePath(int i) const {
1253  		if (i < 0 || i > 2) return nullptr;
1254  		return _workSpaceFilePathes[i].c_str();
1255  	};
1256  	const std::vector<generic_string> getFileBrowserRoots() const { return _fileBrowserRoot; };
1257  	generic_string getFileBrowserSelectedItemPath() const { return _fileBrowserSelectedItemPath; };
1258  	void setWorkSpaceFilePath(int i, const TCHAR *wsFile);
1259  	void setWorkingDir(const TCHAR * newPath);
1260  	void setStartWithLocFileName(const generic_string& locPath) {
1261  		_startWithLocFileName = locPath;
1262  	};
1263  	void setFunctionListExportBoolean(bool doIt) {
1264  		_doFunctionListExport = doIt;
1265  	};
1266  	bool doFunctionListExport() const {
1267  		return _doFunctionListExport;
1268  	};
1269  	void setPrintAndExitBoolean(bool doIt) {
1270  		_doPrintAndExit = doIt;
1271  	};
1272  	bool doPrintAndExit() const {
1273  		return _doPrintAndExit;
1274  	};
1275  	bool loadSession(Session & session, const TCHAR *sessionFileName);
1276  	void setLoadedSessionFilePath(const generic_string & loadedSessionFilePath) {
1277  		_loadedSessionFullFilePath = loadedSessionFilePath;
1278  	};
1279  	generic_string getLoadedSessionFilePath() {
1280  		return _loadedSessionFullFilePath;
1281  	};
1282  	int langTypeToCommandID(LangType lt) const;
1283  	struct FindDlgTabTitiles final {
1284  		generic_string _find;
1285  		generic_string _replace;
1286  		generic_string _findInFiles;
1287  		generic_string _findInProjects;
1288  		generic_string _mark;
1289  	};
1290  	FindDlgTabTitiles & getFindDlgTabTitiles() { return _findDlgTabTitiles;};
1291  	bool asNotepadStyle() const {return _asNotepadStyle;};
1292  	bool reloadPluginCmds() {
1293  		return getPluginCmdsFromXmlTree();
1294  	}
1295  	bool getContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu, bool isEditCM = true);
1296  	bool reloadContextMenuFromXmlTree(HMENU mainMenuHadle, HMENU pluginsMenu);
1297  	winVer getWinVersion() const {return _winVersion;};
1298  	generic_string getWinVersionStr() const;
1299  	generic_string getWinVerBitStr() const;
1300  	FindHistory & getFindHistory() {return _findHistory;};
1301  	bool _isFindReplacing = false; 
1302  	void safeWow64EnableWow64FsRedirection(BOOL Wow64FsEnableRedirection);
1303  	LocalizationSwitcher & getLocalizationSwitcher() {
1304  		return _localizationSwitcher;
1305  	}
1306  	ThemeSwitcher & getThemeSwitcher() {
1307  		return _themeSwitcher;
1308  	}
1309  	std::vector<generic_string> & getBlackList() { return _blacklist; };
1310  	bool isInBlackList(TCHAR *fn) const
1311  	{
1312  		for (auto& element: _blacklist)
1313  		{
1314  			if (element == fn)
1315  				return true;
1316  		}
1317  		return false;
1318  	}
1319  	bool importUDLFromFile(const generic_string& sourceFile);
1320  	bool exportUDLToFile(size_t langIndex2export, const generic_string& fileName2save);
1321  	NativeLangSpeaker* getNativeLangSpeaker() {
1322  		return _pNativeLangSpeaker;
1323  	}
1324  	void setNativeLangSpeaker(NativeLangSpeaker *nls) {
1325  		_pNativeLangSpeaker = nls;
1326  	}
1327  	bool isLocal() const {
1328  		return _isLocal;
1329  	}
1330  	bool isCloud() const {
1331  		return _isCloud;
1332  	}
1333  	void saveConfig_xml();
1334  	generic_string getUserPath() const {
1335  		return _userPath;
1336  	}
1337  	generic_string getUserDefineLangFolderPath() const {
1338  		return _userDefineLangsFolderPath;
1339  	}
1340  	generic_string getUserDefineLangPath() const {
1341  		return _userDefineLangPath;
1342  	}
1343  	bool writeSettingsFilesOnCloudForThe1stTime(const generic_string & cloudSettingsPath);
1344  	void setCloudChoice(const TCHAR *pathChoice);
1345  	void removeCloudChoice();
1346  	bool isCloudPathChanged() const;
1347  	int archType() const { return ARCH_TYPE; };
1348  	COLORREF getCurrentDefaultBgColor() const {
1349  		return _currentDefaultBgColor;
1350  	}
1351  	COLORREF getCurrentDefaultFgColor() const {
1352  		return _currentDefaultFgColor;
1353  	}
1354  	void setCurrentDefaultBgColor(COLORREF c) {
1355  		_currentDefaultBgColor = c;
1356  	}
1357  	void setCurrentDefaultFgColor(COLORREF c) {
1358  		_currentDefaultFgColor = c;
1359  	}
1360  	void setCmdSettingsDir(const generic_string& settingsDir) {
1361  		_cmdSettingsDir = settingsDir;
1362  	};
1363  	void setTitleBarAdd(const generic_string& titleAdd) {
1364  		_titleBarAdditional = titleAdd;
1365  	}
1366  	const generic_string& getTitleBarAdd() const {
1367  		return _titleBarAdditional;
1368  	}
1369  	DPIManager _dpiManager;
1370  	generic_string static getSpecialFolderLocation(int folderKind);
1371  	void setUdlXmlDirtyFromIndex(size_t i);
1372  	void setUdlXmlDirtyFromXmlDoc(const TiXmlDocument* xmlDoc);
1373  	void removeIndexFromXmlUdls(size_t i);
1374  	bool isStylerDocLoaded() const { return _pXmlUserStylerDoc != nullptr; };
1375  	ColumnEditorParam _columnEditParam;
1376  private:
1377  	NppParameters();
1378  	~NppParameters();
1379  	NppParameters(const NppParameters&) = delete;
1380  	NppParameters& operator=(const NppParameters&) = delete;
1381  	NppParameters(NppParameters&&) = delete;
1382  	NppParameters& operator=(NppParameters&&) = delete;
1383  	TiXmlDocument *_pXmlDoc = nullptr; 
1384  	TiXmlDocument *_pXmlUserDoc = nullptr; 
1385  	TiXmlDocument *_pXmlUserStylerDoc = nullptr; 
1386  	TiXmlDocument *_pXmlUserLangDoc = nullptr; 
1387  	std::vector<UdlXmlFileState> _pXmlUserLangsDoc; 
1388  	TiXmlDocument *_pXmlToolIconsDoc = nullptr; 
1389  	TiXmlDocumentA *_pXmlShortcutDocA = nullptr; 
1390  	TiXmlDocumentA *_pXmlNativeLangDocA = nullptr; 
1391  	TiXmlDocumentA *_pXmlContextMenuDocA = nullptr; 
1392  	TiXmlDocumentA *_pXmlTabContextMenuDocA = nullptr; 
1393  	std::vector<TiXmlDocument *> _pXmlExternalLexerDoc; 
1394  	NppGUI _nppGUI;
1395  	ScintillaViewParams _svp;
1396  	Lang* _langList[NB_LANG] = { nullptr };
1397  	int _nbLang = 0;
1398  	generic_string* _LRFileList[NB_MAX_LRF_FILE] = { nullptr };
1399  	int _nbRecentFile = 0;
1400  	UINT _nbMaxRecentFile = 10;
1401  	bool _putRecentFileInSubMenu = false;
1402  	int _recentFileCustomLength = RECENTFILES_SHOWFULLPATH;	
1403  	FindHistory _findHistory;
1404  	UserLangContainer* _userLangArray[NB_MAX_USER_LANG] = { nullptr };
1405  	unsigned char _nbUserLang = 0; 
1406  	generic_string _userDefineLangsFolderPath;
1407  	generic_string _userDefineLangPath;
1408  	ExternalLangContainer* _externalLangArray[NB_MAX_EXTERNAL_LANG] = { nullptr };
1409  	int _nbExternalLang = 0;
1410  	CmdLineParamsDTO _cmdLineParams;
1411  	generic_string _cmdLineString;
1412  	int _fileSaveDlgFilterIndex = -1;
1413  	LexerStylerArray _lexerStylerVect;
1414  	StyleArray _widgetStyleArray;
1415  	std::vector<generic_string> _fontlist;
1416  	std::vector<generic_string> _blacklist;
1417  	bool _isLocal = false;
1418  	bool _isx64 = false; 
1419  	bool _isCloud = false;
1420  	generic_string _cmdSettingsDir;
1421  	generic_string _titleBarAdditional;
1422  	generic_string _loadedSessionFullFilePath;
1423  public:
1424  	void setShortcutDirty() { _isAnyShortcutModified = true; };
1425  	void setAdminMode(bool isAdmin) { _isAdminMode = isAdmin; }
1426  	bool isAdmin() const { return _isAdminMode; }
1427  	bool regexBackward4PowerUser() const { return _findHistory._regexBackward4PowerUser; }
1428  	bool isSelectFgColorEnabled() const { return _isSelectFgColorEnabled; };
1429  private:
1430  	bool _isAnyShortcutModified = false;
1431  	std::vector<CommandShortcut> _shortcuts;			
1432  	std::vector<size_t> _customizedShortcuts;			
1433  	std::vector<MacroShortcut> _macros;				
1434  	std::vector<UserCommand> _userCommands;			
1435  	std::vector<PluginCmdShortcut> _pluginCommands;	
1436  	std::vector<size_t> _pluginCustomizedCmds;			
1437  	std::vector<ScintillaKeyMap> _scintillaKeyCommands;	
1438  	std::vector<int> _scintillaModifiedKeyIndices;		
1439  	LocalizationSwitcher _localizationSwitcher;
1440  	generic_string _startWithLocFileName;
1441  	bool _doFunctionListExport = false;
1442  	bool _doPrintAndExit = false;
1443  	ThemeSwitcher _themeSwitcher;
1444  	std::vector<MenuItemUnit> _contextMenuItems;
1445  	std::vector<MenuItemUnit> _tabContextMenuItems;
1446  	DynamicMenu _macroMenuItems;
1447  	DynamicMenu _runMenuItems;
1448  	Session _session;
1449  	generic_string _shortcutsPath;
1450  	generic_string _contextMenuPath;
1451  	generic_string _tabContextMenuPath;
1452  	generic_string _sessionPath;
1453  	generic_string _nppPath;
1454  	generic_string _userPath;
1455  	generic_string _stylerPath;
1456  	generic_string _appdataNppDir; 
1457  	generic_string _pluginRootDir; 
1458  	generic_string _pluginConfDir; 
1459  	generic_string _userPluginConfDir; 
1460  	generic_string _currentDirectory;
1461  	generic_string _workSpaceFilePathes[3];
1462  	std::vector<generic_string> _fileBrowserRoot;
1463  	generic_string _fileBrowserSelectedItemPath;
1464  	Accelerator* _pAccelerator = nullptr;
1465  	ScintillaAccelerator* _pScintAccelerator = nullptr;
1466  	FindDlgTabTitiles _findDlgTabTitiles;
1467  	bool _asNotepadStyle = false;
1468  	winVer _winVersion = WV_UNKNOWN;
1469  	Platform _platForm = PF_UNKNOWN;
1470  	NativeLangSpeaker *_pNativeLangSpeaker = nullptr;
1471  	COLORREF _currentDefaultBgColor = RGB(0xFF, 0xFF, 0xFF);
1472  	COLORREF _currentDefaultFgColor = RGB(0x00, 0x00, 0x00);
1473  	generic_string _initialCloudChoice;
1474  	generic_string _wingupFullPath;
1475  	generic_string _wingupParams;
1476  	generic_string _wingupDir;
1477  	bool _isElevationRequired = false;
1478  	bool _isAdminMode = false;
1479  	bool _isSelectFgColorEnabled = false;
1480  	bool _doNppLogNetworkDriveIssue = false;
1481  	bool _doNppLogNulContentCorruptionIssue = false;
1482  	bool _isEndSessionStarted = false;
1483  	bool _isEndSessionCritical = false;
1484  public:
1485  	generic_string getWingupFullPath() const { return _wingupFullPath; };
1486  	generic_string getWingupParams() const { return _wingupParams; };
1487  	generic_string getWingupDir() const { return _wingupDir; };
1488  	bool shouldDoUAC() const { return _isElevationRequired; };
1489  	void setWingupFullPath(const generic_string& val2set) { _wingupFullPath = val2set; };
1490  	void setWingupParams(const generic_string& val2set) { _wingupParams = val2set; };
1491  	void setWingupDir(const generic_string& val2set) { _wingupDir = val2set; };
1492  	void setElevationRequired(bool val2set) { _isElevationRequired = val2set; };
1493  	bool doNppLogNetworkDriveIssue() { return _doNppLogNetworkDriveIssue; };
1494  	bool doNppLogNulContentCorruptionIssue() { return _doNppLogNulContentCorruptionIssue; };
1495  	void endSessionStart() { _isEndSessionStarted = true; };
1496  	bool isEndSessionStarted() { return _isEndSessionStarted; };
1497  	void makeEndSessionCritical() { _isEndSessionCritical = true; };
1498  	bool isEndSessionCritical() { return _isEndSessionCritical; };
1499  private:
1500  	void getLangKeywordsFromXmlTree();
1501  	bool getUserParametersFromXmlTree();
1502  	bool getUserStylersFromXmlTree();
1503  	std::pair<unsigned char, unsigned char> addUserDefineLangsFromXmlTree(TiXmlDocument *tixmldoc);
1504  	bool getShortcutsFromXmlTree();
1505  	bool getMacrosFromXmlTree();
1506  	bool getUserCmdsFromXmlTree();
1507  	bool getPluginCmdsFromXmlTree();
1508  	bool getScintKeysFromXmlTree();
1509  	bool getSessionFromXmlTree(TiXmlDocument *pSessionDoc, Session& session);
1510  	void feedGUIParameters(TiXmlNode *node);
1511  	void feedKeyWordsParameters(TiXmlNode *node);
1512  	void feedFileListParameters(TiXmlNode *node);
1513  	void feedScintillaParam(TiXmlNode *node);
1514  	void feedDockingManager(TiXmlNode *node);
1515  	void duplicateDockingManager(TiXmlNode *dockMngNode, TiXmlElement* dockMngElmt2Clone);
1516  	void feedFindHistoryParameters(TiXmlNode *node);
1517  	void feedProjectPanelsParameters(TiXmlNode *node);
1518  	void feedFileBrowserParameters(TiXmlNode *node);
1519  	void feedColumnEditorParameters(TiXmlNode *node);
1520  	bool feedStylerArray(TiXmlNode *node);
1521  	std::pair<unsigned char, unsigned char> feedUserLang(TiXmlNode *node);
1522  	void feedUserStyles(TiXmlNode *node);
1523  	void feedUserKeywordList(TiXmlNode *node);
1524  	void feedUserSettings(TiXmlNode *node);
1525  	void feedShortcut(TiXmlNodeA *node);
1526  	void feedMacros(TiXmlNodeA *node);
1527  	void feedUserCmds(TiXmlNodeA *node);
1528  	void feedPluginCustomizedCmds(TiXmlNodeA *node);
1529  	void feedScintKeys(TiXmlNodeA *node);
1530  	void getActions(TiXmlNodeA *node, Macro & macro);
1531  	bool getShortcuts(TiXmlNodeA *node, Shortcut & sc, std::string* folderName = nullptr);
1532  	void writeStyle2Element(const Style & style2Write, Style & style2Sync, TiXmlElement *element);
1533  	void insertUserLang2Tree(TiXmlNode *node, UserLangContainer *userLang);
1534  	void insertCmd(TiXmlNodeA *cmdRoot, const CommandShortcut & cmd);
1535  	void insertMacro(TiXmlNodeA *macrosRoot, const MacroShortcut & macro, const std::string& folderName);
1536  	void insertUserCmd(TiXmlNodeA *userCmdRoot, const UserCommand & userCmd, const std::string& folderName);
1537  	void insertScintKey(TiXmlNodeA *scintKeyRoot, const ScintillaKeyMap & scintKeyMap);
1538  	void insertPluginCmd(TiXmlNodeA *pluginCmdRoot, const PluginCmdShortcut & pluginCmd);
1539  	TiXmlElement * insertGUIConfigBoolNode(TiXmlNode *r2w, const TCHAR *name, bool bVal);
1540  	void insertDockingParamNode(TiXmlNode *GUIRoot);
1541  	void writeExcludedLangList(TiXmlElement *element);
1542  	void writePrintSetting(TiXmlElement *element);
1543  	void initMenuKeys();		
1544  	void initScintillaKeys();	
1545  	int getCmdIdFromMenuEntryItemName(HMENU mainMenuHadle, const generic_string& menuEntryName, const generic_string& menuItemName); 
1546  	int getPluginCmdIdFromMenuEntryItemName(HMENU pluginsMenu, const generic_string& pluginName, const generic_string& pluginCmdName); 
1547  	winVer getWindowsVersion();
1548  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webmb.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Parameters.h</div>
                </div>
                <div class="column column_space"><pre><code>6    static const TStr WebMemBsFNm;
7    static const int ExpectedWebPgs;
8    TStrIntH UrlStrToWebPgIdH;
9    TStrIntH CheckedUrlStrToWebPgIdH;
10    TIntStrVH WebPgIdToUrlStrVH;
11    TIntStrVH WebPgIdToRefUrlStrVH;
12    bool Modified;
13    void OnSave(const int& WebPgId, const PXWebPg& WebPg);
14    void OnFetch(const int& WebPgId, const PXWebPg& WebPg);
15  public:
16    TWebMemBs(const int& MxConns, const TStr& FPath, const bool& GenRef):
</pre></code></div>
                <div class="column column_space"><pre><code>1201  	const TCHAR * getUserDefinedLangNameFromExt(TCHAR *ext, TCHAR *fullName) const;
1202  	int addUserLangToEnd(const UserLangContainer & userLang, const TCHAR *newName);
1203  	void removeUserLang(size_t index);
1204  	bool isExistingExternalLangName(const char* newName) const;
1205  	int addExternalLangToEnd(ExternalLangContainer * externalLang);
1206  	TiXmlDocumentA * getNativeLangA() const {return _pXmlNativeLangDocA;};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    