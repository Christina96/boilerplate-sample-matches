
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.213944603629416%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanedg.cpp</h3>
            <pre><code>1  #include "scanedg.h"
2  #include "crakedge.h"
3  #include "edgloop.h"
4  #include "pdblock.h"
5  #include <allheaders.h>
6  #include <memory> 
7  namespace tesseract {
8  #define WHITE_PIX 1 &bsol;*thresholded colours */
9  #define BLACK_PIX 0
10  #define FLIP_COLOUR(pix) (1 - (pix))
11  struct CrackPos {
12    CRACKEDGE **free_cracks; 
13    int x;                   
14    int y;
15  };
16  static void free_crackedges(CRACKEDGE *start);
17  static void join_edges(CRACKEDGE *edge1, CRACKEDGE *edge2, CRACKEDGE **free_cracks,
18                         C_OUTLINE_IT *outline_it);
19  static void line_edges(TDimension x, TDimension y, TDimension xext, uint8_t uppercolour, uint8_t *bwpos,
20                         CRACKEDGE **prevline, CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it);
21  static void make_margins(PDBLK *block, BLOCK_LINE_IT *line_it, uint8_t *pixels, uint8_t margin,
<span onclick='openModal()' class='match'>22                           TDimension left, TDimension right, TDimension y);
23  static CRACKEDGE *h_edge(int sign, CRACKEDGE *join, CrackPos *pos);
24  static CRACKEDGE *v_edge(int sign, CRACKEDGE *join, CrackPos *pos);
25  void block_edges(Image t_pix,   
26                   PDBLK *block, 
27                   C_OUTLINE_IT *outline_it) {
28    ICOORD bleft; 
29    ICOORD tright;
30    BLOCK_LINE_IT line_it = block; 
</span>31    int width = pixGetWidth(t_pix);
32    int height = pixGetHeight(t_pix);
33    int wpl = pixGetWpl(t_pix);
34    std::unique_ptr<CRACKEDGE *[]> ptrline(new CRACKEDGE *[width + 1]);
35    CRACKEDGE *free_cracks = nullptr;
36    block->bounding_box(bleft, tright); 
37    ASSERT_HOST(tright.x() <= width);
38    ASSERT_HOST(tright.y() <= height);
39    int block_width = tright.x() - bleft.x();
40    for (int x = block_width; x >= 0; x--) {
41      ptrline[x] = nullptr; 
42    }
43    std::unique_ptr<uint8_t[]> bwline(new uint8_t[width]);
44    const uint8_t margin = WHITE_PIX;
45    for (int y = tright.y() - 1; y >= bleft.y() - 1; y--) {
46      if (y >= bleft.y() && y < tright.y()) {
47        l_uint32 *line = pixGetData(t_pix) + wpl * (height - 1 - y);
48        for (int x = 0; x < block_width; ++x) {
49          bwline[x] = GET_DATA_BIT(line, x + bleft.x()) ^ 1;
50        }
51        make_margins(block, &line_it, bwline.get(), margin, bleft.x(), tright.x(), y);
52      } else {
53        memset(bwline.get(), margin, block_width * sizeof(bwline[0]));
54      }
55      line_edges(bleft.x(), y, block_width, margin, bwline.get(), ptrline.get(), &free_cracks,
56                 outline_it);
57    }
58    free_crackedges(free_cracks); 
59  }
60  static void make_margins(   
61      PDBLK *block,           
62      BLOCK_LINE_IT *line_it, 
63      uint8_t *pixels,        
64      uint8_t margin,         
65      TDimension left,        
66      TDimension right,
67      TDimension y            
68  ) {
69    ICOORDELT_IT seg_it;
70    if (block->poly_block() != nullptr) {
71      std::unique_ptr<PB_LINE_IT> lines(new PB_LINE_IT(block->poly_block()));
72      const std::unique_ptr<&bsol;*non-const*/ ICOORDELT_LIST> segments(lines->get_line(y));
73      if (!segments->empty()) {
74        seg_it.set_to_list(segments.get());
75        seg_it.mark_cycle_pt();
76        auto start = seg_it.data()->x();
77        auto xext = seg_it.data()->y();
78        for (auto xindex = left; xindex < right; xindex++) {
79          if (xindex >= start && !seg_it.cycled_list()) {
80            xindex = start + xext - 1;
81            seg_it.forward();
82            start = seg_it.data()->x();
83            xext = seg_it.data()->y();
84          } else {
85            pixels[xindex - left] = margin;
86          }
87        }
88      } else {
89        for (auto xindex = left; xindex < right; xindex++) {
90          pixels[xindex - left] = margin;
91        }
92      }
93    } else {
94      TDimension xext;  
95      auto start = line_it->get_line(y, xext);
96      for (auto xindex = left; xindex < start; xindex++) {
97        pixels[xindex - left] = margin;
98      }
99      for (auto xindex = start + xext; xindex < right; xindex++) {
100        pixels[xindex - left] = margin;
101      }
102    }
103  }
104  static void line_edges(TDimension x,         
105                         TDimension y,         
106                         TDimension xext,      
107                         uint8_t uppercolour,  
108                         uint8_t *bwpos,       
109                         CRACKEDGE **prevline, 
110                         CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it) {
111    CrackPos pos = {free_cracks, x, y};
112    int xmax;              
113    int prevcolour;        
114    CRACKEDGE *current;    
115    CRACKEDGE *newcurrent; 
116    xmax = x + xext;          
117    prevcolour = uppercolour; 
118    current = nullptr;        
119    for (; pos.x < xmax; pos.x++, prevline++) {
120      const int colour = *bwpos++; 
121      if (*prevline != nullptr) {
122        uppercolour = FLIP_COLOUR(uppercolour);
123        if (colour == prevcolour) {
124          if (colour == uppercolour) {
125            join_edges(current, *prevline, free_cracks, outline_it);
126            current = nullptr; 
127          } else {
128            current = h_edge(uppercolour - colour, *prevline, &pos);
129          }
130          *prevline = nullptr; 
131        } else {
132          if (colour == uppercolour) {
133            *prevline = v_edge(colour - prevcolour, *prevline, &pos);
134          } else if (colour == WHITE_PIX) {
135            join_edges(current, *prevline, free_cracks, outline_it);
136            current = h_edge(uppercolour - colour, nullptr, &pos);
137            *prevline = v_edge(colour - prevcolour, current, &pos);
138          } else {
139            newcurrent = h_edge(uppercolour - colour, *prevline, &pos);
140            *prevline = v_edge(colour - prevcolour, current, &pos);
141            current = newcurrent; 
142          }
143          prevcolour = colour; 
144        }
145      } else {
146        if (colour != prevcolour) {
147          *prevline = current = v_edge(colour - prevcolour, current, &pos);
148          prevcolour = colour;
149        }
150        if (colour != uppercolour) {
151          current = h_edge(uppercolour - colour, current, &pos);
152        } else {
153          current = nullptr; 
154        }
155      }
156    }
157    if (current != nullptr) {
158      if (*prevline != nullptr) { 
159        join_edges(current, *prevline, free_cracks, outline_it);
160        *prevline = nullptr; 
161      } else {
162        *prevline = v_edge(FLIP_COLOUR(prevcolour) - prevcolour, current, &pos);
163      }
164    } else if (*prevline != nullptr) {
165      *prevline = v_edge(FLIP_COLOUR(prevcolour) - prevcolour, *prevline, &pos);
166    }
167  }
168  static CRACKEDGE *h_edge(int sign,        
169                           CRACKEDGE *join, 
170                           CrackPos *pos) {
171    CRACKEDGE *newpt; 
172    if (*pos->free_cracks != nullptr) {
173      newpt = *pos->free_cracks;
174      *pos->free_cracks = newpt->next; 
175    } else {
176      newpt = new CRACKEDGE;
177    }
178    newpt->pos.set_y(pos->y + 1); 
179    newpt->stepy = 0;             
180    if (sign > 0) {
181      newpt->pos.set_x(pos->x + 1); 
182      newpt->stepx = -1;
183      newpt->stepdir = 0;
184    } else {
185      newpt->pos.set_x(pos->x); 
186      newpt->stepx = 1;
187      newpt->stepdir = 2;
188    }
189    if (join == nullptr) {
190      newpt->next = newpt; 
191      newpt->prev = newpt;
192    } else {
193      if (newpt->pos.x() + newpt->stepx == join->pos.x() && newpt->pos.y() == join->pos.y()) {
194        newpt->prev = join->prev; 
195        newpt->prev->next = newpt;
196        newpt->next = join; 
197        join->prev = newpt;
198      } else {
199        newpt->next = join->next; 
200        newpt->next->prev = newpt;
201        newpt->prev = join; 
202        join->next = newpt;
203      }
204    }
205    return newpt;
206  }
207  static CRACKEDGE *v_edge(int sign, 
208                           CRACKEDGE *join, CrackPos *pos) {
209    CRACKEDGE *newpt; 
210    if (*pos->free_cracks != nullptr) {
211      newpt = *pos->free_cracks;
212      *pos->free_cracks = newpt->next; 
213    } else {
214      newpt = new CRACKEDGE;
215    }
216    newpt->pos.set_x(pos->x); 
217    newpt->stepx = 0;         
218    if (sign > 0) {
219      newpt->pos.set_y(pos->y); 
220      newpt->stepy = 1;
221      newpt->stepdir = 3;
222    } else {
223      newpt->pos.set_y(pos->y + 1); 
224      newpt->stepy = -1;
225      newpt->stepdir = 1;
226    }
227    if (join == nullptr) {
228      newpt->next = newpt; 
229      newpt->prev = newpt;
230    } else {
231      if (newpt->pos.x() == join->pos.x() && newpt->pos.y() + newpt->stepy == join->pos.y()) {
232        newpt->prev = join->prev; 
233        newpt->prev->next = newpt;
234        newpt->next = join; 
235        join->prev = newpt;
236      } else {
237        newpt->next = join->next; 
238        newpt->next->prev = newpt;
239        newpt->prev = join; 
240        join->next = newpt;
241      }
242    }
243    return newpt;
244  }
245  static void join_edges(CRACKEDGE *edge1, 
246                         CRACKEDGE *edge2, 
247                         CRACKEDGE **free_cracks, C_OUTLINE_IT *outline_it) {
248    if (edge1->pos.x() + edge1->stepx != edge2->pos.x() ||
249        edge1->pos.y() + edge1->stepy != edge2->pos.y()) {
250      CRACKEDGE *tempedge = edge1;
251      edge1 = edge2; 
252      edge2 = tempedge;
253    }
254    if (edge1->next == edge2) {
255      complete_edge(edge1, outline_it);
256      edge1->prev->next = *free_cracks;
257      *free_cracks = edge1; 
258    } else {
259      edge2->prev->next = edge1->next;
260      edge1->next->prev = edge2->prev;
261      edge1->next = edge2; 
262      edge2->prev = edge1;
263    }
264  }
265  static void free_crackedges(CRACKEDGE *start) {
266    CRACKEDGE *current; 
267    CRACKEDGE *next;    
268    for (current = start; current != nullptr; current = next) {
269      next = current->next;
270      delete current; 
271    }
272  }
273  } 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Platform.h</h3>
            <pre><code>1  #ifndef PLATFORM_H
2  #define PLATFORM_H
3  #define PLAT_GTK 0
4  #define PLAT_GTK_WIN32 0
5  #define PLAT_GTK_MACOSX 0
6  #define PLAT_MACOSX 0
7  #define PLAT_WIN 0
8  #define PLAT_WX  0
9  #define PLAT_QT 0
10  #define PLAT_QT_QML 0
11  #define PLAT_FOX 0
12  #define PLAT_CURSES 0
13  #define PLAT_TK 0
14  #define PLAT_HAIKU 0
15  #if defined(FOX)
16  #undef PLAT_FOX
17  #define PLAT_FOX 1
18  #elif defined(__WX__)
19  #undef PLAT_WX
20  #define PLAT_WX  1
21  #elif defined(CURSES)
22  #undef PLAT_CURSES
23  #define PLAT_CURSES 1
24  #elif defined(__HAIKU__)
25  #undef PLAT_HAIKU
26  #define PLAT_HAIKU 1
27  #elif defined(SCINTILLA_QT)
28  #undef PLAT_QT
29  #define PLAT_QT 1
30  #elif defined(SCINTILLA_QT_QML)
31  #undef PLAT_QT_QML
32  #define PLAT_QT_QML 1
33  #elif defined(TK)
34  #undef PLAT_TK
35  #define PLAT_TK 1
36  #elif defined(GTK)
37  #undef PLAT_GTK
38  #define PLAT_GTK 1
39  #if defined(__WIN32__) || defined(_MSC_VER)
40  #undef PLAT_GTK_WIN32
41  #define PLAT_GTK_WIN32 1
42  #endif
43  #if defined(__APPLE__)
44  #undef PLAT_GTK_MACOSX
45  #define PLAT_GTK_MACOSX 1
46  #endif
47  #elif defined(__APPLE__)
48  #undef PLAT_MACOSX
49  #define PLAT_MACOSX 1
50  #else
51  #undef PLAT_WIN
52  #define PLAT_WIN 1
53  #endif
54  namespace Scintilla::Internal {
55  typedef void *SurfaceID;
56  typedef void *WindowID;
57  typedef void *MenuID;
58  typedef void *TickerID;
59  typedef void *Function;
60  typedef void *IdlerID;
61  constexpr const char *localeNameDefault = "en-us";
62  struct FontParameters {
<span onclick='openModal()' class='match'>63  	const char *faceName;
64  	XYPOSITION size;
65  	Scintilla::FontWeight weight;
66  	bool italic;
67  	Scintilla::FontQuality extraFontFlag;
68  	Scintilla::Technology technology;
69  	Scintilla::CharacterSet characterSet;
70  	const char *localeName;
71  	constexpr FontParameters(
72  		const char *faceName_,
73  		XYPOSITION size_=10,
74  		Scintilla::FontWeight weight_= Scintilla::FontWeight::Normal,
75  		bool italic_=false,
76  		Scintilla::FontQuality extraFontFlag_= Scintilla::FontQuality::QualityDefault,
77  		Scintilla::Technology technology_= Scintilla::Technology::Default,
</span>78  		Scintilla::CharacterSet characterSet_= Scintilla::CharacterSet::Ansi,
79  		const char *localeName_=localeNameDefault) noexcept :
80  		faceName(faceName_),
81  		size(size_),
82  		weight(weight_),
83  		italic(italic_),
84  		extraFontFlag(extraFontFlag_),
85  		technology(technology_),
86  		characterSet(characterSet_),
87  		localeName(localeName_)
88  	{
89  	}
90  };
91  class Font {
92  public:
93  	Font() noexcept = default;
94  	Font(const Font &) = delete;
95  	Font(Font &&) = delete;
96  	Font &operator=(const Font &) = delete;
97  	Font &operator=(Font &&) = delete;
98  	virtual ~Font() noexcept = default;
99  	static std::shared_ptr<Font> Allocate(const FontParameters &fp);
100  };
101  class IScreenLine {
102  public:
103  	virtual std::string_view Text() const = 0;
104  	virtual size_t Length() const = 0;
105  	virtual size_t RepresentationCount() const = 0;
106  	virtual XYPOSITION Width() const = 0;
107  	virtual XYPOSITION Height() const = 0;
108  	virtual XYPOSITION TabWidth() const = 0;
109  	virtual XYPOSITION TabWidthMinimumPixels() const = 0;
110  	virtual const Font *FontOfPosition(size_t position) const = 0;
111  	virtual XYPOSITION RepresentationWidth(size_t position) const = 0;
112  	virtual XYPOSITION TabPositionAfter(XYPOSITION xPosition) const = 0;
113  };
114  class IScreenLineLayout {
115  public:
116  	virtual ~IScreenLineLayout() noexcept = default;
117  	virtual size_t PositionFromX(XYPOSITION xDistance, bool charPosition) = 0;
118  	virtual XYPOSITION XFromPosition(size_t caretPosition) = 0;
119  	virtual std::vector<Interval> FindRangeIntervals(size_t start, size_t end) = 0;
120  };
121  struct SurfaceMode {
122  	int codePage = 0;
123  	bool bidiR2L = false;
124  	SurfaceMode() = default;
125  	explicit SurfaceMode(int codePage_, bool bidiR2L_) noexcept : codePage(codePage_), bidiR2L(bidiR2L_) {
126  	}
127  };
128  class Surface {
129  public:
130  	Surface() noexcept = default;
131  	Surface(const Surface &) = delete;
132  	Surface(Surface &&) = delete;
133  	Surface &operator=(const Surface &) = delete;
134  	Surface &operator=(Surface &&) = delete;
135  	virtual ~Surface() noexcept = default;
136  	static std::unique_ptr<Surface> Allocate(Scintilla::Technology technology);
137  	virtual void Init(WindowID wid)=0;
138  	virtual void Init(SurfaceID sid, WindowID wid)=0;
139  	virtual std::unique_ptr<Surface> AllocatePixMap(int width, int height)=0;
140  	virtual void SetMode(SurfaceMode mode)=0;
141  	enum class Ends {
142  		semiCircles = 0x0,
143  		leftFlat = 0x1,
144  		leftAngle = 0x2,
145  		rightFlat = 0x10,
146  		rightAngle = 0x20,
147  	};
148  	virtual void Release() noexcept=0;
149  	virtual int SupportsFeature(Scintilla::Supports feature) noexcept=0;
150  	virtual bool Initialised()=0;
151  	virtual int LogPixelsY()=0;
152  	virtual int PixelDivisions()=0;
153  	virtual int DeviceHeightFont(int points)=0;
154  	virtual void LineDraw(Point start, Point end, Stroke stroke)=0;
155  	virtual void PolyLine(const Point *pts, size_t npts, Stroke stroke)=0;
156  	virtual void Polygon(const Point *pts, size_t npts, FillStroke fillStroke)=0;
157  	virtual void RectangleDraw(PRectangle rc, FillStroke fillStroke)=0;
158  	virtual void RectangleFrame(PRectangle rc, Stroke stroke)=0;
159  	virtual void FillRectangle(PRectangle rc, Fill fill)=0;
160  	virtual void FillRectangleAligned(PRectangle rc, Fill fill)=0;
161  	virtual void FillRectangle(PRectangle rc, Surface &surfacePattern)=0;
162  	virtual void RoundedRectangle(PRectangle rc, FillStroke fillStroke)=0;
163  	virtual void AlphaRectangle(PRectangle rc, XYPOSITION cornerSize, FillStroke fillStroke)=0;
164  	enum class GradientOptions { leftToRight, topToBottom };
165  	virtual void GradientRectangle(PRectangle rc, const std::vector<ColourStop> &stops, GradientOptions options)=0;
166  	virtual void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage) = 0;
167  	virtual void Ellipse(PRectangle rc, FillStroke fillStroke)=0;
168  	virtual void Stadium(PRectangle rc, FillStroke fillStroke, Ends ends)=0;
169  	virtual void Copy(PRectangle rc, Point from, Surface &surfaceSource)=0;
170  	virtual std::unique_ptr<IScreenLineLayout> Layout(const IScreenLine *screenLine) = 0;
171  	virtual void DrawTextNoClip(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
172  	virtual void DrawTextClipped(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
173  	virtual void DrawTextTransparent(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) = 0;
174  	virtual void MeasureWidths(const Font *font_, std::string_view text, XYPOSITION *positions) = 0;
175  	virtual XYPOSITION WidthText(const Font *font_, std::string_view text) = 0;
176  	virtual void DrawTextNoClipUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
177  	virtual void DrawTextClippedUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore, ColourRGBA back) = 0;
178  	virtual void DrawTextTransparentUTF8(PRectangle rc, const Font *font_, XYPOSITION ybase, std::string_view text, ColourRGBA fore) = 0;
179  	virtual void MeasureWidthsUTF8(const Font *font_, std::string_view text, XYPOSITION *positions) = 0;
180  	virtual XYPOSITION WidthTextUTF8(const Font *font_, std::string_view text) = 0;
181  	virtual XYPOSITION Ascent(const Font *font_)=0;
182  	virtual XYPOSITION Descent(const Font *font_)=0;
183  	virtual XYPOSITION InternalLeading(const Font *font_)=0;
184  	virtual XYPOSITION Height(const Font *font_)=0;
185  	virtual XYPOSITION AverageCharWidth(const Font *font_)=0;
186  	virtual void SetClip(PRectangle rc)=0;
187  	virtual void PopClip()=0;
188  	virtual void FlushCachedState()=0;
189  	virtual void FlushDrawing()=0;
190  };
191  class Window {
192  protected:
193  	WindowID wid;
194  public:
195  	Window() noexcept : wid(nullptr), cursorLast(Cursor::invalid) {
196  	}
197  	Window(const Window &source) = delete;
198  	Window(Window &&) = delete;
199  	Window &operator=(WindowID wid_) noexcept {
200  		wid = wid_;
201  		cursorLast = Cursor::invalid;
202  		return *this;
203  	}
204  	Window &operator=(const Window &) = delete;
205  	Window &operator=(Window &&) = delete;
206  	virtual ~Window() noexcept;
207  	WindowID GetID() const noexcept { return wid; }
208  	bool Created() const noexcept { return wid != nullptr; }
209  	void Destroy() noexcept;
210  	PRectangle GetPosition() const;
211  	void SetPosition(PRectangle rc);
212  	void SetPositionRelative(PRectangle rc, const Window *relativeTo);
213  	PRectangle GetClientPosition() const;
214  	void Show(bool show=true);
215  	void InvalidateAll();
216  	void InvalidateRectangle(PRectangle rc);
217  	enum class Cursor { invalid, text, arrow, up, wait, horizontal, vertical, reverseArrow, hand };
218  	void SetCursor(Cursor curs);
219  	PRectangle GetMonitorRect(Point pt);
220  private:
221  	Cursor cursorLast;
222  };
223  struct ListBoxEvent {
224  	enum class EventType { selectionChange, doubleClick } event;
225  	ListBoxEvent(EventType event_) noexcept : event(event_) {
226  	}
227  };
228  class IListBoxDelegate {
229  public:
230  	virtual void ListNotify(ListBoxEvent *plbe)=0;
231  };
232  struct ListOptions {
233  	std::optional<ColourRGBA> fore;
234  	std::optional<ColourRGBA> back;
235  	std::optional<ColourRGBA> foreSelected;
236  	std::optional<ColourRGBA> backSelected;
237  	AutoCompleteOption options=AutoCompleteOption::Normal;
238  };
239  class ListBox : public Window {
240  public:
241  	ListBox() noexcept;
242  	~ListBox() noexcept override;
243  	static std::unique_ptr<ListBox> Allocate();
244  	virtual void SetFont(const Font *font)=0;
245  	virtual void Create(Window &parent, int ctrlID, Point location, int lineHeight_, bool unicodeMode_, Scintilla::Technology technology_)=0;
246  	virtual void SetAverageCharWidth(int width)=0;
247  	virtual void SetVisibleRows(int rows)=0;
248  	virtual int GetVisibleRows() const=0;
249  	virtual PRectangle GetDesiredRect()=0;
250  	virtual int CaretFromEdge()=0;
251  	virtual void Clear() noexcept=0;
252  	virtual void Append(char *s, int type = -1)=0;
253  	virtual int Length()=0;
254  	virtual void Select(int n)=0;
255  	virtual int GetSelection()=0;
256  	virtual int Find(const char *prefix)=0;
257  	virtual std::string GetValue(int n)=0;
258  	virtual void RegisterImage(int type, const char *xpm_data)=0;
259  	virtual void RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) = 0;
260  	virtual void ClearRegisteredImages()=0;
261  	virtual void SetDelegate(IListBoxDelegate *lbDelegate)=0;
262  	virtual void SetList(const char* list, char separator, char typesep)=0;
263  	virtual void SetOptions(ListOptions options_)=0;
264  };
265  class Menu {
266  	MenuID mid;
267  public:
268  	Menu() noexcept;
269  	MenuID GetID() const noexcept { return mid; }
270  	void CreatePopUp();
271  	void Destroy() noexcept;
272  	void Show(Point pt, const Window &w);
273  };
274  namespace Platform {
275  ColourRGBA Chrome();
276  ColourRGBA ChromeHighlight();
277  const char *DefaultFont();
278  int DefaultFontSize();
279  unsigned int DoubleClickTime();
280  constexpr long LongFromTwoShorts(short a,short b) noexcept {
281  	return (a) | ((b) << 16);
282  }
283  }
284  }
285  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanedg.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Platform.h</div>
                </div>
                <div class="column column_space"><pre><code>22                           TDimension left, TDimension right, TDimension y);
23  static CRACKEDGE *h_edge(int sign, CRACKEDGE *join, CrackPos *pos);
24  static CRACKEDGE *v_edge(int sign, CRACKEDGE *join, CrackPos *pos);
25  void block_edges(Image t_pix,   
26                   PDBLK *block, 
27                   C_OUTLINE_IT *outline_it) {
28    ICOORD bleft; 
29    ICOORD tright;
30    BLOCK_LINE_IT line_it = block; 
</pre></code></div>
                <div class="column column_space"><pre><code>63  	const char *faceName;
64  	XYPOSITION size;
65  	Scintilla::FontWeight weight;
66  	bool italic;
67  	Scintilla::FontQuality extraFontFlag;
68  	Scintilla::Technology technology;
69  	Scintilla::CharacterSet characterSet;
70  	const char *localeName;
71  	constexpr FontParameters(
72  		const char *faceName_,
73  		XYPOSITION size_=10,
74  		Scintilla::FontWeight weight_= Scintilla::FontWeight::Normal,
75  		bool italic_=false,
76  		Scintilla::FontQuality extraFontFlag_= Scintilla::FontQuality::QualityDefault,
77  		Scintilla::Technology technology_= Scintilla::Technology::Default,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    