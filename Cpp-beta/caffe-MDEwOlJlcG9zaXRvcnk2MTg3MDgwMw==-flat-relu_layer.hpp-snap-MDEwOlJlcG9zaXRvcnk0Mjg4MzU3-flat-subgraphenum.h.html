
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.271604938271604%, Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-relu_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_RELU_LAYER_HPP_
2  #define CAFFE_RELU_LAYER_HPP_
3  #include <vector>
4  #include "caffe/blob.hpp"
5  #include "caffe/layer.hpp"
6  #include "caffe/proto/caffe.pb.h"
7  #include "caffe/layers/neuron_layer.hpp"
8  namespace caffe {
9  template <typename Dtype>
10  class ReLULayer : public NeuronLayer<Dtype> {
11   public:
12    explicit ReLULayer(const LayerParameter& param)
13        : NeuronLayer<Dtype>(param) {}
14    virtual inline const char* type() const { return "ReLU"; }
15   protected:
<span onclick='openModal()' class='match'>16    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
17        const vector<Blob<Dtype>*>& top);
18    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
19        const vector<Blob<Dtype>*>& top);
20    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
</span>21        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
22    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
23        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
24  };
25  }  
26  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-subgraphenum.h</h3>
            <pre><code>1  #ifndef Snap_SubGraphEnum_h
2  #define Snap_SubGraphEnum_h
3  #include "Snap.h"
4  template<class TGraphCounter>
5  class TSubGraphEnum {
6  private:
7  	class TSSet {
8  	protected:
9  		int m_capacity;
10  		int m_size;
11  		bool *m_nodes;
12  	public:
13  		TSSet(int capacity) {
14  			m_nodes = (bool *)malloc(capacity); memset(m_nodes, 0, capacity);
15  			m_capacity = capacity; m_size = 0; }
16  		TSSet(const TSSet &set) {
17  			m_nodes = (bool *)malloc(set.m_capacity); memcpy(m_nodes, set.m_nodes, set.m_capacity);
18  			m_capacity = set.m_capacity; m_size = set.m_size; }
19  		~TSSet() { free(m_nodes); }
20  	public:
21  		inline void Add(int i) { if(!m_nodes[i]) m_size++; m_nodes[i]=true; }
22  		inline void Remove(int i) { m_nodes[i]=false; m_size--; }
23  		inline bool IsKey(int i) const { return m_nodes[i]; }
24  		inline int Capacity() const { return m_capacity; }
25  		inline int Size() const { return m_size; }
26  		inline bool operator[](int i) const { return m_nodes[i]; }
27  	};
28  	class TSVec {
29  	protected:
30  		int m_capacity;
31  		int m_size;
32  		int *m_arr;
33  		TIntV m_v;
34  	public:
35  		TSVec(int capacity) {
36  			m_v.Gen(capacity); m_arr = (int *) m_v.BegI();
37        for(int i=0; i<capacity; i++) { m_arr[i]=-1; }
38  			m_capacity = capacity; m_size = 0; }
39  	public:
40  		inline bool Contains(int nodeId) const {
41  			for(int i=0; i<m_size; i++) { if(m_arr[i]==nodeId) return true; } return false; }
42  	public:
43  		inline void Push(int nodeId) { m_arr[m_size]=nodeId; m_size++; }
44  		inline void Pop() { m_size--; m_arr[m_size]=-1; }
45  		inline int Capacity() const { return m_capacity; }
46  		inline int Size() const { return m_size; }
47  		inline const TIntV &getVec() const { return m_v; }
48  		inline int operator[](int i) const { return m_arr[i]; }
49  	};
50  private:
<span onclick='openModal()' class='match'>51  	PNGraph m_graph;
52  	int m_nodes;
53  	int m_subGraphSz;
54  	TGraphCounter *m_functor;
55  private:
56  	void GetSubGraphs_recursive(TSVec &sg, const TSSet &sgNbrs, TSSet &ext, int vId);
57  	void GetSubGraphs_recursive(TSVec &sg, const TSSet &sgNbrs, TSSet &ext);
</span>58  public: 
59    TSubGraphEnum() { }
60  	void GetSubGraphs(PNGraph &Graph, int SubGraphSz, TGraphCounter& Counter);
61  	void GetSubGraphs(PNGraph &Graph, int NId, int SubGraphSz, TGraphCounter& Counter);
62  };
63  template <class TGraphCounter>
64  void TSubGraphEnum<TGraphCounter>::GetSubGraphs_recursive(TSVec &sg, const TSSet &sgNbrs, TSSet &ext, int vId) {
65  	if(sg.Size() == m_subGraphSz) { (*m_functor)(m_graph, sg.getVec()); return; }
66  	for(int i=0; i<ext.Capacity(); i++) {
67  		while(ext[i] == false) {
68  			i++;
69  			if(i == ext.Capacity()) return;
70  		}
71  		int wId = i;
72  		TNGraph::TNodeI wIt = m_graph->GetNI(wId);
73  		int wDeg = wIt.GetDeg();
74  		ext.Remove(wId);
75  		TSSet newExt = ext;
76  		TSSet newSgNbrs = sgNbrs;
77  		for(int j=0; j<wDeg; j++) {
78  			int nbrId = wIt.GetNbrNId(j);
79  			if(nbrId > vId && !sgNbrs.IsKey(nbrId) && !sg.Contains(nbrId)) {
80  				newExt.Add(nbrId);
81  				newSgNbrs.Add(nbrId);
82  			}
83  		}
84  		sg.Push(wId);
85  		GetSubGraphs_recursive(sg, newSgNbrs, newExt, vId);
86  		sg.Pop();
87  	}
88  }
89  template <class TGraphCounter>
90  void TSubGraphEnum<TGraphCounter>::GetSubGraphs(PNGraph &Graph, int SubGraphSz, TGraphCounter &Functor) {
91  	m_graph = Graph;
92  	m_nodes = m_graph->GetNodes();
93  	m_subGraphSz = SubGraphSz;
94  	m_functor = &Functor;
95  	TExeTm extime;
96  	for(TNGraph::TNodeI it=m_graph->BegNI(); it<m_graph->EndNI(); it++) {
97  		int vId = it.GetId();
98  		int vDeg = it.GetDeg();
99  		TSVec sg(SubGraphSz);
100  		sg.Push(vId);
101  		TSSet ext(m_nodes);
102  		for(int i=0; i<vDeg; i++) {
103  			int nbrId = it.GetNbrNId(i);
104  			if(nbrId > vId) 
105  				ext.Add(nbrId);
106  		}
107  		TSSet sgNbrs = ext;
108  		GetSubGraphs_recursive(sg, sgNbrs, ext, vId);
109  	}
110  }
111  template <class TGraphCounter>
112  void TSubGraphEnum<TGraphCounter>::GetSubGraphs_recursive(TSVec &sg, const TSSet &sgNbrs, TSSet &ext) {
113  	if(sg.Size() == m_subGraphSz) { (*m_functor)(m_graph, sg.getVec()); return; }
114  	for(int i=0; i<ext.Capacity(); i++) {
115  		while(ext[i] == false) {
116  			i++;
117  			if(i == ext.Capacity()) return;
118  		}
119  		int wId = i;
120  		TNGraph::TNodeI wIt = m_graph->GetNI(wId);
121  		int wDeg = wIt.GetDeg();
122  		ext.Remove(wId);
123  		TSSet newExt = ext;
124  		TSSet newSgNbrs = sgNbrs;
125  		for(int j=0; j<wDeg; j++) {
126  			int nbrId = wIt.GetNbrNId(j);
127  			if(!sgNbrs.IsKey(nbrId) && !sg.Contains(nbrId)) {
128  				newExt.Add(nbrId);
129  				newSgNbrs.Add(nbrId);
130  			}
131  		}
132  		sg.Push(wId);
133  		GetSubGraphs_recursive(sg, newSgNbrs, newExt);
134  		sg.Pop();
135  	}
136  }
137  template <class TGraphCounter>
138  void TSubGraphEnum<TGraphCounter>::GetSubGraphs(PNGraph &Graph, int NId, int SubGraphSz, TGraphCounter &Functor) {
139  	m_graph = Graph;
140  	m_nodes = m_graph->GetNodes();
141  	m_subGraphSz = SubGraphSz;
142  	m_functor = &Functor;
143  	TNGraph::TNodeI it=m_graph->GetNI(NId);
144  	int vId = NId;
145  	int vDeg = it.GetDeg();
146  	TSVec sg(SubGraphSz);
147  	sg.Push(vId);
148  	TSSet ext(m_nodes);
149  	for(int i=0; i<vDeg; i++) {
150  		int nbrId = it.GetNbrNId(i);
151  		ext.Add(nbrId);
152  	}
153  	TSSet sgNbrs = ext;
154  	TExeTm extime;
155  	GetSubGraphs_recursive(sg, sgNbrs, ext);
156  	printf("secs: %llf\n", extime.GetSecs());
157  }
158  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-relu_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-subgraphenum.h</div>
                </div>
                <div class="column column_space"><pre><code>16    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
17        const vector<Blob<Dtype>*>& top);
18    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
19        const vector<Blob<Dtype>*>& top);
20    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
</pre></code></div>
                <div class="column column_space"><pre><code>51  	PNGraph m_graph;
52  	int m_nodes;
53  	int m_subGraphSz;
54  	TGraphCounter *m_functor;
55  private:
56  	void GetSubGraphs_recursive(TSVec &sg, const TSSet &sgNbrs, TSSet &ext, int vId);
57  	void GetSubGraphs_recursive(TSVec &sg, const TSSet &sgNbrs, TSSet &ext);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    