
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.7135278514588856%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpc_connection.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/boost/asio/ip/tcp.hpp>
3  #include <nano/boost/asio/strand.hpp>
4  #include <nano/boost/beast/core/flat_buffer.hpp>
5  #include <nano/boost/beast/http.hpp>
6  #include <boost/algorithm/string/predicate.hpp>
7  #include <atomic>
8  #if BOOST_VERSION < 107000
9  using socket_type = boost::asio::ip::tcp::socket;
10  #else
11  using socket_type = boost::asio::basic_stream_socket<boost::asio::ip::tcp, boost::asio::io_context::executor_type>;
12  #endif
13  namespace nano
14  {
15  class logger_mt;
16  class rpc_config;
17  class rpc_handler_interface;
18  class rpc_connection : public std::enable_shared_from_this<nano::rpc_connection>
19  {
20  public:
21  	rpc_connection (nano::rpc_config const & rpc_config, boost::asio::io_context & io_ctx, nano::logger_mt & logger, nano::rpc_handler_interface & rpc_handler_interface_a);
<span onclick='openModal()' class='match'>22  	virtual ~rpc_connection () = default;
23  	virtual void parse_connection ();
24  	virtual void write_completion_handler (std::shared_ptr<nano::rpc_connection> const & rpc_connection);
25  	void prepare_head (unsigned version, boost::beast::http::status status = boost::beast::http::status::ok);
26  	void write_result (std::string body, unsigned version, boost::beast::http::status status = boost::beast::http::status::ok);
</span>27  	socket_type socket;
28  	boost::beast::flat_buffer buffer;
29  	boost::beast::http::response<boost::beast::http::string_body> res;
30  	boost::asio::strand<boost::asio::io_context::executor_type> strand;
31  	std::atomic_flag responded;
32  	boost::asio::io_context & io_ctx;
33  	nano::logger_mt & logger;
34  	nano::rpc_config const & rpc_config;
35  	nano::rpc_handler_interface & rpc_handler_interface;
36  protected:
37  	template <typename STREAM_TYPE>
38  	void read (STREAM_TYPE & stream);
39  	template <typename STREAM_TYPE>
40  	void parse_request (STREAM_TYPE & stream, std::shared_ptr<boost::beast::http::request_parser<boost::beast::http::empty_body>> const & header_parser);
41  };
42  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKLDNN_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkldnn_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MKLDNNPoolingLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MKLDNNPoolingLayerTest()
16        : blob_bottom_(new Blob<Dtype>()),
17          blob_top_(new Blob<Dtype>()),
18          blob_top_mask_(new Blob<size_t>()) {}
19    virtual void SetUp() {
20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
23      GaussianFiller<Dtype> filler(filler_param);
24      filler.Fill(this->blob_bottom_);
25      blob_bottom_vec_.push_back(blob_bottom_);
26      blob_top_vec_.push_back(blob_top_);
27    }
<span onclick='openModal()' class='match'>28    virtual ~MKLDNNPoolingLayerTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31      delete blob_top_mask_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    Blob<size_t>* const blob_top_mask_;
36    vector<Blob<Dtype>*> blob_bottom_vec_;
37    vector<Blob<Dtype>*> blob_top_vec_;
</span>38    void TestForwardSquare() {
39      LayerParameter layer_param;
40      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
41      pooling_param->set_kernel_size(2);
42      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
43      const int num = 2;
44      const int channels = 2;
45      blob_bottom_->Reshape(num, channels, 3, 5);
46      for (int i = 0; i < 15 * num * channels; i += 15) {
47        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
48        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
49        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
50        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
52        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
53        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
54        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
55        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
57        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
58        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
59        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
60        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
62      }
63      MKLDNNPoolingLayer<Dtype> layer(layer_param);
64      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
65      EXPECT_EQ(blob_top_->num(), num);
66      EXPECT_EQ(blob_top_->channels(), channels);
67      EXPECT_EQ(blob_top_->height(), 2);
68      EXPECT_EQ(blob_top_->width(), 4);
69      if (blob_top_vec_.size() > 1) {
70        EXPECT_EQ(blob_top_mask_->num(), num);
71        EXPECT_EQ(blob_top_mask_->channels(), channels);
72        EXPECT_EQ(blob_top_mask_->height(), 2);
73        EXPECT_EQ(blob_top_mask_->width(), 4);
74      }
75      layer.Forward(blob_bottom_vec_, blob_top_vec_);
76      for (int i = 0; i < 8 * num * channels; i += 8) {
77        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
78        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
79        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
85      }
86      if (blob_top_vec_.size() > 1) {
87        uint32_t *mask = reinterpret_cast<uint32_t*>(blob_top_mask_->mutable_cpu_data());
88        for (int i = 0; i < 8 * num * channels; i += 8) {
89          EXPECT_EQ(mask[i + 0],  5);
90          EXPECT_EQ(mask[i + 1],  2);
91          EXPECT_EQ(mask[i + 2],  2);
92          EXPECT_EQ(mask[i + 3],  9);
93          EXPECT_EQ(mask[i + 4],  5);
94          EXPECT_EQ(mask[i + 5], 12);
95          EXPECT_EQ(mask[i + 6], 12);
96          EXPECT_EQ(mask[i + 7],  9);
97        }
98      }
99    }
100    void TestForwardRectHigh() {
101      LayerParameter layer_param;
102      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
103      pooling_param->set_kernel_h(3);
104      pooling_param->set_kernel_w(2);
105      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
106      const int num = 2;
107      const int channels = 2;
108      blob_bottom_->Reshape(num, channels, 6, 6);
109      for (int i = 0; i < 36 * num * channels; i += 36) {
110        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
111        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
112        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
113        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
114        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
115        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
116        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
117        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
118        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
119        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
120        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
121        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
122        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
123        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
124        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
125        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
126        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
127        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
128        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
129        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
130        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
131        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
132        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
133        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
134        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
135        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
136        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
137        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
138        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
139        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
140        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
141        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
142        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
143        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
144        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
145        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
146      }
147      MKLDNNPoolingLayer<Dtype> layer(layer_param);
148      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
149      EXPECT_EQ(blob_top_->num(), num);
150      EXPECT_EQ(blob_top_->channels(), channels);
151      EXPECT_EQ(blob_top_->height(), 4);
152      EXPECT_EQ(blob_top_->width(), 5);
153      if (blob_top_vec_.size() > 1) {
154        EXPECT_EQ(blob_top_mask_->num(), num);
155        EXPECT_EQ(blob_top_mask_->channels(), channels);
156        EXPECT_EQ(blob_top_mask_->height(), 4);
157        EXPECT_EQ(blob_top_mask_->width(), 5);
158      }
159      layer.Forward(blob_bottom_vec_, blob_top_vec_);
160      for (int i = 0; i < 20 * num * channels; i += 20) {
161        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
162        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
170        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
171        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
180        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
181      }
182      if (blob_top_vec_.size() > 1) {
183      uint32_t *mask = reinterpret_cast<uint32_t*>(blob_top_mask_->mutable_cpu_data());
184        for (int i = 0; i < 20 * num * channels; i += 20) {
185          EXPECT_EQ(mask[i +  0],  0);
186          EXPECT_EQ(mask[i +  1],  7);
187          EXPECT_EQ(mask[i +  2],  3);
188          EXPECT_EQ(mask[i +  3], 16);
189          EXPECT_EQ(mask[i +  4], 16);
190          EXPECT_EQ(mask[i +  5],  7);
191          EXPECT_EQ(mask[i +  6], 20);
192          EXPECT_EQ(mask[i +  7], 20);
193          EXPECT_EQ(mask[i +  8], 16);
194          EXPECT_EQ(mask[i +  9], 16);
195          EXPECT_EQ(mask[i + 10], 12);
196          EXPECT_EQ(mask[i + 11], 26);
197          EXPECT_EQ(mask[i + 12], 26);
198          EXPECT_EQ(mask[i + 13], 16);
199          EXPECT_EQ(mask[i + 14], 16);
200          EXPECT_EQ(mask[i + 15], 31);
201          EXPECT_EQ(mask[i + 16], 31);
202          EXPECT_EQ(mask[i + 17], 26);
203          EXPECT_EQ(mask[i + 18], 34);
204          EXPECT_EQ(mask[i + 19], 34);
205        }
206      }
207    }
208    void TestForwardRectWide() {
209      LayerParameter layer_param;
210      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
211      pooling_param->set_kernel_h(2);
212      pooling_param->set_kernel_w(3);
213      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
214      const int num = 2;
215      const int channels = 2;
216      blob_bottom_->Reshape(num, channels, 6, 6);
217      for (int i = 0; i < 36 * num * channels; i += 36) {
218        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
219        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
220        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
221        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
222        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
223        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
224        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
225        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
226        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
227        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
228        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
229        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
230        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
231        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
232        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
233        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
234        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
235        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
236        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
237        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
238        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
239        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
240        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
241        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
242        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
243        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
244        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
245        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
246        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
247        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
248        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
249        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
250        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
251        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
252        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
253        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
254      }
255      MKLDNNPoolingLayer<Dtype> layer(layer_param);
256      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
257      EXPECT_EQ(blob_top_->num(), num);
258      EXPECT_EQ(blob_top_->channels(), channels);
259      EXPECT_EQ(blob_top_->height(), 5);
260      EXPECT_EQ(blob_top_->width(), 4);
261      if (blob_top_vec_.size() > 1) {
262        EXPECT_EQ(blob_top_mask_->num(), num);
263        EXPECT_EQ(blob_top_mask_->channels(), channels);
264        EXPECT_EQ(blob_top_mask_->height(), 5);
265        EXPECT_EQ(blob_top_mask_->width(), 4);
266      }
267      layer.Forward(blob_bottom_vec_, blob_top_vec_);
268      for (int i = 0; i < 20 * num * channels; i += 20) {
269        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
277        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
287        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
288        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
289      }
290      if (blob_top_vec_.size() > 1) {
291        uint32_t *mask = reinterpret_cast<uint32_t*>(blob_top_mask_->mutable_cpu_data());
292        for (int i = 0; i < 20 * num * channels; i += 20) {
293          EXPECT_EQ(mask[i +  0],  0);
294          EXPECT_EQ(mask[i +  1],  7);
295          EXPECT_EQ(mask[i +  2],  3);
296          EXPECT_EQ(mask[i +  3],  3);
297          EXPECT_EQ(mask[i +  4],  7);
298          EXPECT_EQ(mask[i +  5],  7);
299          EXPECT_EQ(mask[i +  6], 16);
300          EXPECT_EQ(mask[i +  7], 16);
301          EXPECT_EQ(mask[i +  8], 20);
302          EXPECT_EQ(mask[i +  9], 20);
303          EXPECT_EQ(mask[i + 10], 20);
304          EXPECT_EQ(mask[i + 11], 16);
305          EXPECT_EQ(mask[i + 12], 26);
306          EXPECT_EQ(mask[i + 13], 26);
307          EXPECT_EQ(mask[i + 14], 26);
308          EXPECT_EQ(mask[i + 15], 21);
309          EXPECT_EQ(mask[i + 16], 31);
310          EXPECT_EQ(mask[i + 17], 31);
311          EXPECT_EQ(mask[i + 18], 26);
312          EXPECT_EQ(mask[i + 19], 34);
313        }
314      }
315    }
316  };
317  typedef ::testing::Types<CPUDevice<float> > TestDtypesCPU;
318  TYPED_TEST_CASE(MKLDNNPoolingLayerTest, TestDtypesCPU);
319  TYPED_TEST(MKLDNNPoolingLayerTest, TestSetup) {
320    typedef typename TypeParam::Dtype Dtype;
321    LayerParameter layer_param;
322    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
323    pooling_param->set_kernel_size(3);
324    pooling_param->set_stride(2);
325    MKLDNNPoolingLayer<Dtype> layer(layer_param);
326    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
327    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
328    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
329    EXPECT_EQ(this->blob_top_->height(), 3);
330    EXPECT_EQ(this->blob_top_->width(), 2);
331  }
332  TYPED_TEST(MKLDNNPoolingLayerTest, TestSetupPadded) {
333    typedef typename TypeParam::Dtype Dtype;
334    LayerParameter layer_param;
335    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
336    pooling_param->set_kernel_size(3);
337    pooling_param->set_stride(2);
338    pooling_param->set_pad(1);
339    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
340    MKLDNNPoolingLayer<Dtype> layer(layer_param);
341    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
342    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
343    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
344    EXPECT_EQ(this->blob_top_->height(), 4);
345    EXPECT_EQ(this->blob_top_->width(), 3);
346  }
347  TYPED_TEST(MKLDNNPoolingLayerTest, TestSetupGlobalPooling) {
348    typedef typename TypeParam::Dtype Dtype;
349    LayerParameter layer_param;
350    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
351    pooling_param->set_global_pooling(true);
352    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
353    MKLDNNPoolingLayer<Dtype> layer(layer_param);
354    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
355    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
356    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
357    EXPECT_EQ(this->blob_top_->height(), 1);
358    EXPECT_EQ(this->blob_top_->width(), 1);
359  }
360  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardMax) {
361    this->TestForwardSquare();
362    this->TestForwardRectHigh();
363    this->TestForwardRectWide();
364  }
365  #if 0
366  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardMaxTopMask) {
367    typedef typename TypeParam::Dtype Dtype;
368    this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
369            (this->blob_top_mask_));
370    this->TestForwardSquare();
371    this->TestForwardRectHigh();
372    this->TestForwardRectWide();
373  }
374  #endif
375  TYPED_TEST(MKLDNNPoolingLayerTest, TestGradientMax) {
376    typedef typename TypeParam::Dtype Dtype;
377    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
378      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
379        LayerParameter layer_param;
380        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
381        pooling_param->set_kernel_h(kernel_h);
382        pooling_param->set_kernel_w(kernel_w);
383        pooling_param->set_stride(2);
384        pooling_param->set_pad(1);
385        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
386        MKLDNNPoolingLayer<Dtype> layer(layer_param);
387        GradientChecker<Dtype> checker(1e-4, 1e-2);
388        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
389            this->blob_top_vec_);
390      }
391    }
392  }
393  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardMaxPadded) {
394    typedef typename TypeParam::Dtype Dtype;
395    LayerParameter layer_param;
396    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
397    pooling_param->set_kernel_size(3);
398    pooling_param->set_stride(2);
399    pooling_param->set_pad(2);
400    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
401    this->blob_bottom_->Reshape(1, 1, 3, 3);
402    this->blob_bottom_->mutable_cpu_data()[0] = 1;
403    this->blob_bottom_->mutable_cpu_data()[1] = 2;
404    this->blob_bottom_->mutable_cpu_data()[2] = 4;
405    this->blob_bottom_->mutable_cpu_data()[3] = 2;
406    this->blob_bottom_->mutable_cpu_data()[4] = 3;
407    this->blob_bottom_->mutable_cpu_data()[5] = 2;
408    this->blob_bottom_->mutable_cpu_data()[6] = 4;
409    this->blob_bottom_->mutable_cpu_data()[7] = 2;
410    this->blob_bottom_->mutable_cpu_data()[8] = 1;
411    MKLDNNPoolingLayer<Dtype> layer(layer_param);
412    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
413    EXPECT_EQ(this->blob_top_->num(), 1);
414    EXPECT_EQ(this->blob_top_->channels(), 1);
415    EXPECT_EQ(this->blob_top_->height(), 3);
416    EXPECT_EQ(this->blob_top_->width(), 3);
417    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
418    Dtype epsilon = 1e-8;
419    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
422    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
423    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
424    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
425    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
426    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
427    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
428  }
429  #if 0
430  TYPED_TEST(MKLDNNPoolingLayerTest, TestGradientMaxTopMask) {
431    typedef typename TypeParam::Dtype Dtype;
432    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
433      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
434        LayerParameter layer_param;
435        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
436        pooling_param->set_kernel_h(kernel_h);
437        pooling_param->set_kernel_w(kernel_w);
438        pooling_param->set_stride(2);
439        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
440        this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
441                (this->blob_top_mask_));
442        MKLDNNPoolingLayer<Dtype> layer(layer_param);
443        GradientChecker<Dtype> checker(1e-4, 1e-2);
444        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
445            this->blob_top_vec_);
446        this->blob_top_vec_.pop_back();
447      }
448    }
449  }
450  #endif
451  TYPED_TEST(MKLDNNPoolingLayerTest, TestForwardAve) {
452    typedef typename TypeParam::Dtype Dtype;
453    LayerParameter layer_param;
454    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
455    pooling_param->set_kernel_size(3);
456    pooling_param->set_stride(1);
457    pooling_param->set_pad(1);
458    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
459    this->blob_bottom_->Reshape(1, 1, 3, 3);
460    FillerParameter filler_param;
461    filler_param.set_value(Dtype(2));
462    ConstantFiller<Dtype> filler(filler_param);
463    filler.Fill(this->blob_bottom_);
464    MKLDNNPoolingLayer<Dtype> layer(layer_param);
465    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
466    EXPECT_EQ(this->blob_top_->num(), 1);
467    EXPECT_EQ(this->blob_top_->channels(), 1);
468    EXPECT_EQ(this->blob_top_->height(), 3);
469    EXPECT_EQ(this->blob_top_->width(), 3);
470    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
471    Dtype epsilon = 1e-5;
472  #if 0
473    cout << "bottom blob [0]: " << this->blob_bottom_->cpu_data()[0] << endl;
474    cout << "bottom blob [1]: " << this->blob_bottom_->cpu_data()[1] << endl;
475    cout << "bottom blob [2]: " << this->blob_bottom_->cpu_data()[2] << endl;
476    cout << "bottom blob [3]: " << this->blob_bottom_->cpu_data()[3] << endl;
477    cout << "bottom blob [4]: " << this->blob_bottom_->cpu_data()[4] << endl;
478    cout << "bottom blob [5]: " << this->blob_bottom_->cpu_data()[5] << endl;
479    cout << "bottom blob [6]: " << this->blob_bottom_->cpu_data()[6] << endl;
480    cout << "bottom blob [7]: " << this->blob_bottom_->cpu_data()[7] << endl;
481    cout << "bottom blob [8]: " << this->blob_bottom_->cpu_data()[8] << endl;
482    cout << "top blob [0]: " << this->blob_top_->cpu_data()[0] << endl;
483    cout << "top blob [1]: " << this->blob_top_->cpu_data()[1] << endl;
484    cout << "top blob [2]: " << this->blob_top_->cpu_data()[2] << endl;
485    cout << "top blob [3]: " << this->blob_top_->cpu_data()[3] << endl;
486    cout << "top blob [4]: " << this->blob_top_->cpu_data()[4] << endl;
487    cout << "top blob [5]: " << this->blob_top_->cpu_data()[5] << endl;
488    cout << "top blob [6]: " << this->blob_top_->cpu_data()[6] << endl;
489    cout << "top blob [7]: " << this->blob_top_->cpu_data()[7] << endl;
490    cout << "top blob [8]: " << this->blob_top_->cpu_data()[8] << endl;
491  #endif
492    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
493    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 12.0 / 9, epsilon);
494    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
495    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 12.0 / 9, epsilon);
496    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
497    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 12.0 / 9, epsilon);
498    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
499    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 12.0 / 9, epsilon);
500    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
501  }
502  #if 0
503  TYPED_TEST(MKLDNNPoolingLayerTest, DISABLED_TestGradientAve) {
504    typedef typename TypeParam::Dtype Dtype;
505    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
506      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
507        LayerParameter layer_param;
508        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
509        pooling_param->set_kernel_h(kernel_h);
510        pooling_param->set_kernel_w(kernel_w);
511        pooling_param->set_stride(2);
512        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
513        MKLDNNPoolingLayer<Dtype> layer(layer_param);
514        GradientChecker<Dtype> checker(1e-2, 1e-2);
515        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
516            this->blob_top_vec_);
517      }
518    }
519  }
520  #endif
521  TYPED_TEST(MKLDNNPoolingLayerTest, TestGradientAvePadded) {
522    typedef typename TypeParam::Dtype Dtype;
523    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
524      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
525        LayerParameter layer_param;
526        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
527        pooling_param->set_kernel_h(kernel_h);
528        pooling_param->set_kernel_w(kernel_w);
529        pooling_param->set_stride(2);
530        pooling_param->set_pad(2);
531        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
532        MKLDNNPoolingLayer<Dtype> layer(layer_param);
533        GradientChecker<Dtype> checker(1e-2, 1e-2);
534        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
535            this->blob_top_vec_);
536      }
537    }
538  }
539  }  
540  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpc_connection.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_pooling_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>22  	virtual ~rpc_connection () = default;
23  	virtual void parse_connection ();
24  	virtual void write_completion_handler (std::shared_ptr<nano::rpc_connection> const & rpc_connection);
25  	void prepare_head (unsigned version, boost::beast::http::status status = boost::beast::http::status::ok);
26  	void write_result (std::string body, unsigned version, boost::beast::http::status status = boost::beast::http::status::ok);
</pre></code></div>
                <div class="column column_space"><pre><code>28    virtual ~MKLDNNPoolingLayerTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31      delete blob_top_mask_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    Blob<size_t>* const blob_top_mask_;
36    vector<Blob<Dtype>*> blob_bottom_vec_;
37    vector<Blob<Dtype>*> blob_top_vec_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    