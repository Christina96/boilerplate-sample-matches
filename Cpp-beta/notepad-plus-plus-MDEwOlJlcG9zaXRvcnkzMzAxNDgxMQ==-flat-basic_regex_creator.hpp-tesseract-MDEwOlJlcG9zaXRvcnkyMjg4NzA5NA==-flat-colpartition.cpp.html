
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.1479229989868287%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_creator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_CREATOR_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_CREATOR_HPP
3  #ifdef BOOST_REGEX_MSVC
4  #  pragma warning(push)
5  #pragma warning(disable:4459)
6  #if BOOST_REGEX_MSVC < 1910
7  #pragma warning(disable:4800)
8  #endif
9  #endif
10  #include <set>
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template <class charT>
14  struct digraph : public std::pair<charT, charT>
15  {
16     digraph() : std::pair<charT, charT>(charT(0), charT(0)){}
17     digraph(charT c1) : std::pair<charT, charT>(c1, charT(0)){}
18     digraph(charT c1, charT c2) : std::pair<charT, charT>(c1, c2)
19     {}
20     digraph(const digraph<charT>& d) : std::pair<charT, charT>(d.first, d.second){}
21     digraph<charT>& operator=(const digraph<charT>&) = default;
22     template <class Seq>
23     digraph(const Seq& s) : std::pair<charT, charT>()
24     {
25        BOOST_REGEX_ASSERT(s.size() <= 2);
26        BOOST_REGEX_ASSERT(s.size());
27        this->first = s[0];
28        this->second = (s.size() > 1) ? s[1] : 0;
29     }
30  };
31  template <class charT, class traits>
32  class basic_char_set
33  {
34  public:
35     typedef digraph<charT>                   digraph_type;
36     typedef typename traits::string_type     string_type;
37     typedef typename traits::char_class_type m_type;
38     basic_char_set()
39     {
40        m_negate = false;
41        m_has_digraphs = false;
42        m_classes = 0;
43        m_negated_classes = 0;
44        m_empty = true;
45     }
46     void add_single(const digraph_type& s)
47     {
48        m_singles.insert(s);
49        if(s.second)
50           m_has_digraphs = true;
51        m_empty = false;
52     }
53     void add_range(const digraph_type& first, const digraph_type& end)
54     {
55        m_ranges.push_back(first);
56        m_ranges.push_back(end);
57        if(first.second)
58        {
59           m_has_digraphs = true;
60           add_single(first);
61        }
62        if(end.second)
63        {
64           m_has_digraphs = true;
65           add_single(end);
66        }
67        m_empty = false;
68     }
69     void add_class(m_type m)
70     {
71        m_classes |= m;
72        m_empty = false;
73     }
74     void add_negated_class(m_type m)
75     {
76        m_negated_classes |= m;
77        m_empty = false;
78     }
79     void add_equivalent(const digraph_type& s)
80     {
81        m_equivalents.insert(s);
82        if(s.second)
83        {
84           m_has_digraphs = true;
85           add_single(s);
86        }
87        m_empty = false;
88     }
89     void negate()
90     { 
91        m_negate = true;
92     }
93     bool has_digraphs()const
94     {
95        return m_has_digraphs;
96     }
97     bool is_negated()const
98     {
99        return m_negate;
100     }
101     typedef typename std::vector<digraph_type>::const_iterator  list_iterator;
102     typedef typename std::set<digraph_type>::const_iterator     set_iterator;
103     set_iterator singles_begin()const
104     {
105        return m_singles.begin();
106     }
107     set_iterator singles_end()const
108     {
109        return m_singles.end();
110     }
111     list_iterator ranges_begin()const
112     {
113        return m_ranges.begin();
114     }
115     list_iterator ranges_end()const
116     {
117        return m_ranges.end();
118     }
119     set_iterator equivalents_begin()const
120     {
121        return m_equivalents.begin();
122     }
123     set_iterator equivalents_end()const
124     {
125        return m_equivalents.end();
126     }
127     m_type classes()const
128     {
129        return m_classes;
130     }
131     m_type negated_classes()const
132     {
133        return m_negated_classes;
134     }
135     bool empty()const
136     {
137        return m_empty;
138     }
139  private:
140     std::set<digraph_type>    m_singles;         
141     std::vector<digraph_type> m_ranges;          
142     bool                      m_negate;          
143     bool                      m_has_digraphs;    
144     m_type                    m_classes;         
145     m_type                    m_negated_classes; 
146     bool                      m_empty;           
147     std::set<digraph_type>    m_equivalents;     
148  };
149  template <class charT, class traits>
150  class basic_regex_creator
151  {
152  public:
153     basic_regex_creator(regex_data<charT, traits>* data);
154     std::ptrdiff_t getoffset(void* addr)
155     {
156        return getoffset(addr, m_pdata->m_data.data());
157     }
158     std::ptrdiff_t getoffset(const void* addr, const void* base)
159     {
160        return static_cast<const char*>(addr) - static_cast<const char*>(base);
161     }
162     re_syntax_base* getaddress(std::ptrdiff_t off)
163     {
164        return getaddress(off, m_pdata->m_data.data());
165     }
166     re_syntax_base* getaddress(std::ptrdiff_t off, void* base)
167     {
168        return static_cast<re_syntax_base*>(static_cast<void*>(static_cast<char*>(base) + off));
169     }
170     void init(unsigned l_flags)
171     {
172        m_pdata->m_flags = l_flags;
173        m_icase = l_flags & regex_constants::icase;
174     }
175     regbase::flag_type flags()
176     {
177        return m_pdata->m_flags;
178     }
179     void flags(regbase::flag_type f)
180     {
181        m_pdata->m_flags = f;
182        if(m_icase != static_cast<bool>(f & regbase::icase))
183        {
184           m_icase = static_cast<bool>(f & regbase::icase);
185        }
186     }
187     re_syntax_base* append_state(syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
188     re_syntax_base* insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s = sizeof(re_syntax_base));
189     re_literal* append_literal(charT c);
190     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set);
191     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, false>*);
192     re_syntax_base* append_set(const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, true>*);
193     void finalize(const charT* p1, const charT* p2);
194  protected:
195     regex_data<charT, traits>*    m_pdata;              
196     const ::boost::regex_traits_wrapper<traits>&  
197                                   m_traits;             
198     re_syntax_base*               m_last_state;         
199     bool                          m_icase;              
200     unsigned                      m_repeater_id;        
201     bool                          m_has_backrefs;       
202     std::uintmax_t                m_bad_repeats;        
203     bool                          m_has_recursions;     
204     std::vector<unsigned char>    m_recursion_checks;   
205     typename traits::char_class_type m_word_mask;       
206     typename traits::char_class_type m_mask_space;      
207     typename traits::char_class_type m_lower_mask;       
208     typename traits::char_class_type m_upper_mask;      
209     typename traits::char_class_type m_alpha_mask;      
210  private:
211     basic_regex_creator& operator=(const basic_regex_creator&);
212     basic_regex_creator(const basic_regex_creator&);
213     void fixup_pointers(re_syntax_base* state);
214     void fixup_recursions(re_syntax_base* state);
215     void create_startmaps(re_syntax_base* state);
216     int calculate_backstep(re_syntax_base* state);
217     void create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask);
218     unsigned get_restart_type(re_syntax_base* state);
219     void set_all_masks(unsigned char* bits, unsigned char);
220     bool is_bad_repeat(re_syntax_base* pt);
221     void set_bad_repeat(re_syntax_base* pt);
222     syntax_element_type get_repeat_type(re_syntax_base* state);
223     void probe_leading_repeat(re_syntax_base* state);
224  };
225  template <class charT, class traits>
226  basic_regex_creator<charT, traits>::basic_regex_creator(regex_data<charT, traits>* data)
227     : m_pdata(data), m_traits(*(data->m_ptraits)), m_last_state(0), m_icase(false), m_repeater_id(0), 
228     m_has_backrefs(false), m_bad_repeats(0), m_has_recursions(false), m_word_mask(0), m_mask_space(0), m_lower_mask(0), m_upper_mask(0), m_alpha_mask(0)
229  {
230     m_pdata->m_data.clear();
231     m_pdata->m_status = ::boost::regex_constants::error_ok;
232     static const charT w = 'w';
233     static const charT s = 's';
234     static const charT l[5] = { 'l', 'o', 'w', 'e', 'r', };
235     static const charT u[5] = { 'u', 'p', 'p', 'e', 'r', };
236     static const charT a[5] = { 'a', 'l', 'p', 'h', 'a', };
237     m_word_mask = m_traits.lookup_classname(&w, &w +1);
238     m_mask_space = m_traits.lookup_classname(&s, &s +1);
239     m_lower_mask = m_traits.lookup_classname(l, l + 5);
240     m_upper_mask = m_traits.lookup_classname(u, u + 5);
241     m_alpha_mask = m_traits.lookup_classname(a, a + 5);
242     m_pdata->m_word_mask = m_word_mask;
243     BOOST_REGEX_ASSERT(m_word_mask != 0); 
244     BOOST_REGEX_ASSERT(m_mask_space != 0); 
245     BOOST_REGEX_ASSERT(m_lower_mask != 0); 
246     BOOST_REGEX_ASSERT(m_upper_mask != 0); 
247     BOOST_REGEX_ASSERT(m_alpha_mask != 0); 
248  }
249  template <class charT, class traits>
250  re_syntax_base* basic_regex_creator<charT, traits>::append_state(syntax_element_type t, std::size_t s)
251  {
252     if(t == syntax_element_backref)
253        this->m_has_backrefs = true;
254     m_pdata->m_data.align();
255     if(m_last_state)
256        m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);
257     m_last_state = static_cast<re_syntax_base*>(m_pdata->m_data.extend(s));
258     m_last_state->next.i = 0;
259     m_last_state->type = t;
260     return m_last_state;
261  }
262  template <class charT, class traits>
263  re_syntax_base* basic_regex_creator<charT, traits>::insert_state(std::ptrdiff_t pos, syntax_element_type t, std::size_t s)
264  {
265     m_pdata->m_data.align();
266     if(m_last_state)
267        m_last_state->next.i = m_pdata->m_data.size() - getoffset(m_last_state);
268     std::ptrdiff_t off = getoffset(m_last_state) + s;
269     re_syntax_base* new_state = static_cast<re_syntax_base*>(m_pdata->m_data.insert(pos, s));
270     new_state->next.i = s;
271     new_state->type = t;
272     m_last_state = getaddress(off);
273     return new_state;
274  }
275  template <class charT, class traits>
276  re_literal* basic_regex_creator<charT, traits>::append_literal(charT c)
277  {
278     re_literal* result;
279     if((0 == m_last_state) || (m_last_state->type != syntax_element_literal))
280     {
281        result = static_cast<re_literal*>(append_state(syntax_element_literal, sizeof(re_literal) + sizeof(charT)));
282        result->length = 1;
283        *static_cast<charT*>(static_cast<void*>(result+1)) = m_traits.translate(c, m_icase);
284     }
285     else
286     {
287        std::ptrdiff_t off = getoffset(m_last_state);
288        m_pdata->m_data.extend(sizeof(charT));
289        m_last_state = result = static_cast<re_literal*>(getaddress(off));
290        charT* characters = static_cast<charT*>(static_cast<void*>(result+1));
291        characters[result->length] = m_traits.translate(c, m_icase);
292        result->length += 1;
293     }
294     return result;
295  }
296  template <class charT, class traits>
297  inline re_syntax_base* basic_regex_creator<charT, traits>::append_set(
298     const basic_char_set<charT, traits>& char_set)
299  {
300     typedef std::integral_constant<bool, (sizeof(charT) == 1) > truth_type;
301     return char_set.has_digraphs() 
302        ? append_set(char_set, static_cast<std::integral_constant<bool, false>*>(0))
303        : append_set(char_set, static_cast<truth_type*>(0));
304  }
305  template <class charT, class traits>
306  re_syntax_base* basic_regex_creator<charT, traits>::append_set(
307     const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, false>*)
308  {
309     typedef typename traits::string_type string_type;
310     typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
311     typedef typename basic_char_set<charT, traits>::set_iterator  set_iterator;
312     typedef typename traits::char_class_type m_type;
313     re_set_long<m_type>* result = static_cast<re_set_long<m_type>*>(append_state(syntax_element_long_set, sizeof(re_set_long<m_type>)));
314     result->csingles = static_cast<unsigned int>(std::distance(char_set.singles_begin(), char_set.singles_end()));
315     result->cranges = static_cast<unsigned int>(std::distance(char_set.ranges_begin(), char_set.ranges_end())) / 2;
316     result->cequivalents = static_cast<unsigned int>(std::distance(char_set.equivalents_begin(), char_set.equivalents_end()));
317     result->cclasses = char_set.classes();
318     result->cnclasses = char_set.negated_classes();
319     if(flags() & regbase::icase)
320     {
321        if(((result->cclasses & m_lower_mask) == m_lower_mask) || ((result->cclasses & m_upper_mask) == m_upper_mask))
322           result->cclasses |= m_alpha_mask;
323        if(((result->cnclasses & m_lower_mask) == m_lower_mask) || ((result->cnclasses & m_upper_mask) == m_upper_mask))
324           result->cnclasses |= m_alpha_mask;
325     }
326     result->isnot = char_set.is_negated();
327     result->singleton = !char_set.has_digraphs();
328     std::ptrdiff_t offset = getoffset(result);
329     item_iterator first, last;
330     set_iterator sfirst, slast;
331     sfirst = char_set.singles_begin();
332     slast = char_set.singles_end();
333     while(sfirst != slast)
334     {
335        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (sfirst->first == static_cast<charT>(0) ? 1 : sfirst->second ? 3 : 2)));
336        p[0] = m_traits.translate(sfirst->first, m_icase);
337        if(sfirst->first == static_cast<charT>(0))
338        {
339           p[0] = 0;
340        }
341        else if(sfirst->second)
342        {
343           p[1] = m_traits.translate(sfirst->second, m_icase);
344           p[2] = 0;
345        }
346        else
347           p[1] = 0;
348        ++sfirst;
349     }
350     first = char_set.ranges_begin();
351     last = char_set.ranges_end();
352     while(first != last)
353     {
354        digraph<charT> c1 = *first;
355        c1.first = this->m_traits.translate(c1.first, this->m_icase);
356        c1.second = this->m_traits.translate(c1.second, this->m_icase);
357        ++first;
358        digraph<charT> c2 = *first;
359        c2.first = this->m_traits.translate(c2.first, this->m_icase);
360        c2.second = this->m_traits.translate(c2.second, this->m_icase);
361        ++first;
362        string_type s1, s2;
363        if(flags() & regex_constants::collate)
364        {
365           charT a1[3] = { c1.first, c1.second, charT(0), };
366           charT a2[3] = { c2.first, c2.second, charT(0), };
367           s1 = this->m_traits.transform(a1, (a1[1] ? a1+2 : a1+1));
368           s2 = this->m_traits.transform(a2, (a2[1] ? a2+2 : a2+1));
369           if(s1.empty())
370              s1 = string_type(1, charT(0));
371           if(s2.empty())
372              s2 = string_type(1, charT(0));
373        }
374        else
375        {
376           if(c1.second)
377           {
378              s1.insert(s1.end(), c1.first);
379              s1.insert(s1.end(), c1.second);
380           }
381           else
382              s1 = string_type(1, c1.first);
383           if(c2.second)
384           {
385              s2.insert(s2.end(), c2.first);
386              s2.insert(s2.end(), c2.second);
387           }
388           else
389              s2.insert(s2.end(), c2.first);
390        }
391        if(s1 > s2)
392        {
393           return 0;
394        }
395        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s1.size() + s2.size() + 2) ) );
396        BOOST_REGEX_DETAIL_NS::copy(s1.begin(), s1.end(), p);
397        p[s1.size()] = charT(0);
398        p += s1.size() + 1;
399        BOOST_REGEX_DETAIL_NS::copy(s2.begin(), s2.end(), p);
400        p[s2.size()] = charT(0);
401     }
402     sfirst = char_set.equivalents_begin();
403     slast = char_set.equivalents_end();
404     while(sfirst != slast)
405     {
406        string_type s;
407        if(sfirst->second)
408        {
409           charT cs[3] = { sfirst->first, sfirst->second, charT(0), };
410           s = m_traits.transform_primary(cs, cs+2);
411        }
412        else
413           s = m_traits.transform_primary(&sfirst->first, &sfirst->first+1);
414        if(s.empty())
415           return 0;  
416        charT* p = static_cast<charT*>(this->m_pdata->m_data.extend(sizeof(charT) * (s.size()+1) ) );
417        BOOST_REGEX_DETAIL_NS::copy(s.begin(), s.end(), p);
418        p[s.size()] = charT(0);
419        ++sfirst;
420     }
421     m_last_state = result = static_cast<re_set_long<m_type>*>(getaddress(offset));
422     return result;
423  }
424  template<class T>
425  inline bool char_less(T t1, T t2)
426  {
427     return t1 < t2;
428  }
429  inline bool char_less(char t1, char t2)
430  {
431     return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
432  }
433  inline bool char_less(signed char t1, signed char t2)
434  {
435     return static_cast<unsigned char>(t1) < static_cast<unsigned char>(t2);
436  }
437  template <class charT, class traits>
438  re_syntax_base* basic_regex_creator<charT, traits>::append_set(
439     const basic_char_set<charT, traits>& char_set, std::integral_constant<bool, true>*)
440  {
441     typedef typename traits::string_type string_type;
442     typedef typename basic_char_set<charT, traits>::list_iterator item_iterator;
443     typedef typename basic_char_set<charT, traits>::set_iterator set_iterator;
<span onclick='openModal()' class='match'>444     re_set* result = static_cast<re_set*>(append_state(syntax_element_set, sizeof(re_set)));
445     bool negate = char_set.is_negated();
446     std::memset(result->_map, 0, sizeof(result->_map));
447     item_iterator first, last;
</span>448     set_iterator sfirst, slast;
449     sfirst = char_set.singles_begin();
450     slast = char_set.singles_end();
451     while(sfirst != slast)
452     {
453        for(unsigned int i = 0; i < (1 << CHAR_BIT); ++i)
454        {
455           if(this->m_traits.translate(static_cast<charT>(i), this->m_icase)
456              == this->m_traits.translate(sfirst->first, this->m_icase))
457              result->_map[i] = true;
458        }
459        ++sfirst;
460     }
461     first = char_set.ranges_begin();
462     last = char_set.ranges_end();
463     while(first != last)
464     {
465        charT c1 = this->m_traits.translate(first->first, this->m_icase);
466        ++first;
467        charT c2 = this->m_traits.translate(first->first, this->m_icase);
468        ++first;
469        if(flags() & regex_constants::collate)
470        {
471           charT c3[2] = { c1, charT(0), };
472           string_type s1 = this->m_traits.transform(c3, c3+1);
473           c3[0] = c2;
474           string_type s2 = this->m_traits.transform(c3, c3+1);
475           if(s1 > s2)
476           {
477              return 0;
478           }
479           BOOST_REGEX_ASSERT(c3[1] == charT(0));
480           for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
481           {
482              c3[0] = static_cast<charT>(i);
483              string_type s3 = this->m_traits.transform(c3, c3 +1);
484              if((s1 <= s3) && (s3 <= s2))
485                 result->_map[i] = true;
486           }
487        }
488        else
489        {
490           if(char_less(c2, c1))
491           {
492              return 0;
493           }
494           std::memset(result->_map + static_cast<unsigned char>(c1), true, static_cast<unsigned char>(1u) + static_cast<unsigned char>(static_cast<unsigned char>(c2) - static_cast<unsigned char>(c1)));
495        }
496     }
497     typedef typename traits::char_class_type m_type;
498     m_type m = char_set.classes();
499     if(flags() & regbase::icase)
500     {
501        if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
502           m |= m_alpha_mask;
503     }
504     if(m != 0)
505     {
506        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
507        {
508           if(this->m_traits.isctype(static_cast<charT>(i), m))
509              result->_map[i] = true;
510        }
511     }
512     m = char_set.negated_classes();
513     if(flags() & regbase::icase)
514     {
515        if(((m & m_lower_mask) == m_lower_mask) || ((m & m_upper_mask) == m_upper_mask))
516           m |= m_alpha_mask;
517     }
518     if(m != 0)
519     {
520        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
521        {
522           if(0 == this->m_traits.isctype(static_cast<charT>(i), m))
523              result->_map[i] = true;
524        }
525     }
526     sfirst = char_set.equivalents_begin();
527     slast = char_set.equivalents_end();
528     while(sfirst != slast)
529     {
530        string_type s;
531        BOOST_REGEX_ASSERT(static_cast<charT>(0) == sfirst->second);
532        s = m_traits.transform_primary(&sfirst->first, &sfirst->first+1);
533        if(s.empty())
534           return 0;  
535        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
536        {
537           charT c[2] = { (static_cast<charT>(i)), charT(0), };
538           string_type s2 = this->m_traits.transform_primary(c, c+1);
539           if(s == s2)
540              result->_map[i] = true;
541        }
542        ++sfirst;
543     }
544     if(negate)
545     {
546        for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
547        {
548           result->_map[i] = !(result->_map[i]);
549        }
550     }
551     return result;
552  }
553  template <class charT, class traits>
554  void basic_regex_creator<charT, traits>::finalize(const charT* p1, const charT* p2)
555  {
556     if(this->m_pdata->m_status)
557        return;
558     append_state(syntax_element_match);
559     std::ptrdiff_t len = p2 - p1;
560     m_pdata->m_expression_len = len;
561     charT* ps = static_cast<charT*>(m_pdata->m_data.extend(sizeof(charT) * (1 + (p2 - p1))));
562     m_pdata->m_expression = ps;
563     BOOST_REGEX_DETAIL_NS::copy(p1, p2, ps);
564     ps[p2 - p1] = 0;
565     m_pdata->m_status = 0;
566     m_pdata->m_first_state = static_cast<re_syntax_base*>(m_pdata->m_data.data());
567     fixup_pointers(m_pdata->m_first_state);
568     if(m_has_recursions)
569     {
570        m_pdata->m_has_recursions = true;
571        fixup_recursions(m_pdata->m_first_state);
572        if(this->m_pdata->m_status)
573           return;
574     }
575     else
576        m_pdata->m_has_recursions = false;
577     create_startmaps(m_pdata->m_first_state);
578     std::memset(m_pdata->m_startmap, 0, sizeof(m_pdata->m_startmap));
579     m_pdata->m_can_be_null = 0;
580     m_bad_repeats = 0;
581     if(m_has_recursions)
582        m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
583     create_startmap(m_pdata->m_first_state, m_pdata->m_startmap, &(m_pdata->m_can_be_null), mask_all);
584     m_pdata->m_restart_type = get_restart_type(m_pdata->m_first_state);
585     probe_leading_repeat(m_pdata->m_first_state);
586  }
587  template <class charT, class traits>
588  void basic_regex_creator<charT, traits>::fixup_pointers(re_syntax_base* state)
589  {
590     while(state)
591     {
592        switch(state->type)
593        {
594        case syntax_element_recurse:
595           m_has_recursions = true;
596           if(state->next.i)
597              state->next.p = getaddress(state->next.i, state);
598           else
599              state->next.p = 0;
600           break;
601        case syntax_element_rep:
602        case syntax_element_dot_rep:
603        case syntax_element_char_rep:
604        case syntax_element_short_set_rep:
605        case syntax_element_long_set_rep:
606           static_cast<re_repeat*>(state)->state_id = m_repeater_id++;
607           BOOST_REGEX_FALLTHROUGH;
608        case syntax_element_alt:
609           std::memset(static_cast<re_alt*>(state)->_map, 0, sizeof(static_cast<re_alt*>(state)->_map));
610           static_cast<re_alt*>(state)->can_be_null = 0;
611           BOOST_REGEX_FALLTHROUGH;
612        case syntax_element_jump:
613           static_cast<re_jump*>(state)->alt.p = getaddress(static_cast<re_jump*>(state)->alt.i, state);
614           BOOST_REGEX_FALLTHROUGH;
615        default:
616           if(state->next.i)
617              state->next.p = getaddress(state->next.i, state);
618           else
619              state->next.p = 0;
620        }
621        state = state->next.p;
622     }
623  }
624  template <class charT, class traits>
625  void basic_regex_creator<charT, traits>::fixup_recursions(re_syntax_base* state)
626  {
627     re_syntax_base* base = state;
628     while(state)
629     {
630        switch(state->type)
631        {
632        case syntax_element_assert_backref:
633           {
634              int idx = static_cast<const re_brace*>(state)->index;
635              if(idx < 0)
636              {
637                 idx = -idx-1;
638                 if(idx >= hash_value_mask)
639                 {
640                    idx = m_pdata->get_id(idx);
641                    if(idx <= 0)
642                    {
643                       if(0 == this->m_pdata->m_status) 
644                          this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
645                       this->m_pdata->m_expression = 0;
646                       this->m_pdata->m_expression_len = 0;
647                       if(0 == (this->flags() & regex_constants::no_except))
648                       {
649                          std::string message = "Encountered a forward reference to a marked sub-expression that does not exist.";
650                          boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
651                          e.raise();
652                       }
653                    }
654                 }
655              }
656           }
657           break;
658        case syntax_element_recurse:
659           {
660              bool ok = false;
661              re_syntax_base* p = base;
662              std::ptrdiff_t idx = static_cast<re_jump*>(state)->alt.i;
663              if(idx >= hash_value_mask)
664              {
665                 idx = m_pdata->get_id(static_cast<int>(idx));
666              }
667              if(idx < 0)
668              {
669                 ok = false;
670              }
671              else
672              {
673                 while(p)
674                 {
675                    if((p->type == syntax_element_startmark) && (static_cast<re_brace*>(p)->index == idx))
676                    {
677                       static_cast<re_jump*>(state)->alt.p = p;
678                       ok = true;
679                       p = p->next.p;
680                       int next_rep_id = 0;
681                       while(p)
682                       {
683                          switch(p->type)
684                          {
685                          case syntax_element_rep:
686                          case syntax_element_dot_rep:
687                          case syntax_element_char_rep:
688                          case syntax_element_short_set_rep:
689                          case syntax_element_long_set_rep:
690                             next_rep_id = static_cast<re_repeat*>(p)->state_id;
691                             break;
692                          case syntax_element_endmark:
693                             if(static_cast<const re_brace*>(p)->index == idx)
694                                next_rep_id = -1;
695                             break;
696                          default:
697                             break;
698                          }
699                          if(next_rep_id)
700                             break;
701                          p = p->next.p;
702                       }
703                       if(next_rep_id > 0)
704                       {
705                          static_cast<re_recurse*>(state)->state_id = next_rep_id - 1;
706                       }
707                       break;
708                    }
709                    p = p->next.p;
710                 }
711              }
712              if(!ok)
713              {
714                 if(0 == this->m_pdata->m_status) 
715                    this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
716                 this->m_pdata->m_expression = 0;
717                 this->m_pdata->m_expression_len = 0;
718                 if(0 == (this->flags() & regex_constants::no_except))
719                 {
720                    std::string message = "Encountered a forward reference to a recursive sub-expression that does not exist.";
721                    boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
722                    e.raise();
723                 }
724              }
725           }
726           break;
727        default:
728           break;
729        }
730        state = state->next.p;
731     }
732  }
733  template <class charT, class traits>
734  void basic_regex_creator<charT, traits>::create_startmaps(re_syntax_base* state)
735  {
736     bool l_icase = m_icase;
737     std::vector<std::pair<bool, re_syntax_base*> > v;
738     while(state)
739     {
740        switch(state->type)
741        {
742        case syntax_element_toggle_case:
743           m_icase = static_cast<re_case*>(state)->icase;
744           state = state->next.p;
745           continue;
746        case syntax_element_alt:
747        case syntax_element_rep:
748        case syntax_element_dot_rep:
749        case syntax_element_char_rep:
750        case syntax_element_short_set_rep:
751        case syntax_element_long_set_rep:
752           v.push_back(std::pair<bool, re_syntax_base*>(m_icase, state));
753           state = state->next.p;
754           break;
755        case syntax_element_backstep:
756           static_cast<re_brace*>(state)->index
757              = this->calculate_backstep(state->next.p);
758           if(static_cast<re_brace*>(state)->index < 0)
759           {
760              if(0 == this->m_pdata->m_status) 
761                 this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
762              this->m_pdata->m_expression = 0;
763              this->m_pdata->m_expression_len = 0;
764              if(0 == (this->flags() & regex_constants::no_except))
765              {
766                 std::string message = "Invalid lookbehind assertion encountered in the regular expression.";
767                 boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
768                 e.raise();
769              }
770           }
771           BOOST_REGEX_FALLTHROUGH;
772        default:
773           state = state->next.p;
774        }
775     }
776     while(!v.empty())
777     {
778        if(m_has_recursions)
779           m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
780        const std::pair<bool, re_syntax_base*>& p = v.back();
781        m_icase = p.first;
782        state = p.second;
783        v.pop_back();
784        m_bad_repeats = 0;
785        create_startmap(state->next.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_take);
786        m_bad_repeats = 0;
787        if(m_has_recursions)
788           m_recursion_checks.assign(1 + m_pdata->m_mark_count, 0u);
789        create_startmap(static_cast<re_alt*>(state)->alt.p, static_cast<re_alt*>(state)->_map, &static_cast<re_alt*>(state)->can_be_null, mask_skip);
790        state->type = this->get_repeat_type(state);
791     }
792     m_icase = l_icase;
793  }
794  template <class charT, class traits>
795  int basic_regex_creator<charT, traits>::calculate_backstep(re_syntax_base* state)
796  {
797     typedef typename traits::char_class_type m_type;
798     int result = 0;
799     while(state)
800     {
801        switch(state->type)
802        {
803        case syntax_element_startmark:
804           if((static_cast<re_brace*>(state)->index == -1)
805              || (static_cast<re_brace*>(state)->index == -2))
806           {
807              state = static_cast<re_jump*>(state->next.p)->alt.p->next.p;
808              continue;
809           }
810           else if(static_cast<re_brace*>(state)->index == -3)
811           {
812              state = state->next.p->next.p;
813              continue;
814           }
815           break;
816        case syntax_element_endmark:
817           if((static_cast<re_brace*>(state)->index == -1)
818              || (static_cast<re_brace*>(state)->index == -2))
819              return result;
820           break;
821        case syntax_element_literal:
822           result += static_cast<re_literal*>(state)->length;
823           break;
824        case syntax_element_wild:
825        case syntax_element_set:
826           result += 1;
827           break;
828        case syntax_element_dot_rep:
829        case syntax_element_char_rep:
830        case syntax_element_short_set_rep:
831        case syntax_element_backref:
832        case syntax_element_rep:
833        case syntax_element_combining:
834        case syntax_element_long_set_rep:
835        case syntax_element_backstep:
836           {
837              re_repeat* rep = static_cast<re_repeat *>(state);
838              state->type = this->get_repeat_type(state);
839              if((state->type == syntax_element_dot_rep) 
840                 || (state->type == syntax_element_char_rep)
841                 || (state->type == syntax_element_short_set_rep))
842              {
843                 if(rep->max != rep->min)
844                    return -1;
845                 if (static_cast<std::size_t>((std::numeric_limits<int>::max)() - result) < rep->min)
846                    return -1; 
847                 result += static_cast<int>(rep->min);
848                 state = rep->alt.p;
849                 continue;
850              }
851              else if(state->type == syntax_element_long_set_rep)
852              {
853                 BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_long_set);
854                 if(static_cast<re_set_long<m_type>*>(rep->next.p)->singleton == 0)
855                    return -1;
856                 if(rep->max != rep->min)
857                    return -1;
858                 result += static_cast<int>(rep->min);
859                 state = rep->alt.p;
860                 continue;
861              }
862           }
863           return -1;
864        case syntax_element_long_set:
865           if(static_cast<re_set_long<m_type>*>(state)->singleton == 0)
866              return -1;
867           result += 1;
868           break;
869        case syntax_element_jump:
870           state = static_cast<re_jump*>(state)->alt.p;
871           continue;
872        case syntax_element_alt:
873           {
874              int r1 = calculate_backstep(state->next.p);
875              int r2 = calculate_backstep(static_cast<re_alt*>(state)->alt.p);
876              if((r1 < 0) || (r1 != r2))
877                 return -1;
878              return result + r1;
879           }
880        default:
881           break;
882        }
883        state = state->next.p;
884     }
885     return -1;
886  }
887  struct recursion_saver
888  {
889     std::vector<unsigned char> saved_state;
890     std::vector<unsigned char>* state;
891     recursion_saver(std::vector<unsigned char>* p) : saved_state(*p), state(p) {}
892     ~recursion_saver()
893     {
894        state->swap(saved_state);
895     }
896  };
897  template <class charT, class traits>
898  void basic_regex_creator<charT, traits>::create_startmap(re_syntax_base* state, unsigned char* l_map, unsigned int* pnull, unsigned char mask)
899  {
900     recursion_saver saved_recursions(&m_recursion_checks);
901     int not_last_jump = 1;
902     re_syntax_base* recursion_start = 0;
903     int recursion_sub = 0;
904     re_syntax_base* recursion_restart = 0;
905     bool l_icase = m_icase;
906     while(state)
907     {
908        switch(state->type)
909        {
910        case syntax_element_toggle_case:
911           l_icase = static_cast<re_case*>(state)->icase;
912           state = state->next.p;
913           break;
914        case syntax_element_literal:
915        {
916           if(l_map)
917           {
918              l_map[0] |= mask_init;
919              charT first_char = *static_cast<charT*>(static_cast<void*>(static_cast<re_literal*>(state) + 1));
920              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
921              {
922                 if(m_traits.translate(static_cast<charT>(i), l_icase) == first_char)
923                    l_map[i] |= mask;
924              }
925           }
926           return;
927        }
928        case syntax_element_end_line:
929        {
930           if(l_map)
931           {
932              l_map[0] |= mask_init;
933              l_map[static_cast<unsigned>('\n')] |= mask;
934              l_map[static_cast<unsigned>('\r')] |= mask;
935              l_map[static_cast<unsigned>('\f')] |= mask;
936              l_map[0x85] |= mask;
937           }
938           if(pnull)
939              create_startmap(state->next.p, 0, pnull, mask);
940           return;
941        }
942        case syntax_element_recurse:
943           {
944              BOOST_REGEX_ASSERT(static_cast<const re_jump*>(state)->alt.p->type == syntax_element_startmark);
945              recursion_sub = static_cast<re_brace*>(static_cast<const re_jump*>(state)->alt.p)->index;
946              if(m_recursion_checks[recursion_sub] & 1u)
947              {
948                 if(0 == this->m_pdata->m_status) 
949                    this->m_pdata->m_status = boost::regex_constants::error_bad_pattern;
950                 this->m_pdata->m_expression = 0;
951                 this->m_pdata->m_expression_len = 0;
952                 if(0 == (this->flags() & regex_constants::no_except))
953                 {
954                    std::string message = "Encountered an infinite recursion.";
955                    boost::regex_error e(message, boost::regex_constants::error_bad_pattern, 0);
956                    e.raise();
957                 }
958              }
959              else if(recursion_start == 0)
960              {
961                 recursion_start = state;
962                 recursion_restart = state->next.p;
963                 state = static_cast<re_jump*>(state)->alt.p;
964                 m_recursion_checks[recursion_sub] |= 1u;
965                 break;
966              }
967              m_recursion_checks[recursion_sub] |= 1u;
968              BOOST_REGEX_FALLTHROUGH;
969           }
970        case syntax_element_backref:
971           if(pnull)
972              *pnull |= mask;
973           BOOST_REGEX_FALLTHROUGH;
974        case syntax_element_wild:
975        {
976           set_all_masks(l_map, mask);
977           return;
978        }
979        case syntax_element_accept:
980        case syntax_element_match:
981        {
982           set_all_masks(l_map, mask);
983           if(pnull)
984              *pnull |= mask;
985           return;
986        }
987        case syntax_element_word_start:
988        {
989           create_startmap(state->next.p, l_map, pnull, mask);
990           if(l_map)
991           {
992              l_map[0] |= mask_init;
993              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
994              {
995                 if(!m_traits.isctype(static_cast<charT>(i), m_word_mask))
996                    l_map[i] &= static_cast<unsigned char>(~mask);
997              }
998           }
999           return;
1000        }
1001        case syntax_element_word_end:
1002        {
1003           create_startmap(state->next.p, l_map, pnull, mask);
1004           if(l_map)
1005           {
1006              l_map[0] |= mask_init;
1007              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1008              {
1009                 if(m_traits.isctype(static_cast<charT>(i), m_word_mask))
1010                    l_map[i] &= static_cast<unsigned char>(~mask);
1011              }
1012           }
1013           return;
1014        }
1015        case syntax_element_buffer_end:
1016        {
1017           if(pnull)
1018              *pnull |= mask;
1019           return;
1020        }
1021        case syntax_element_long_set:
1022           if(l_map)
1023           {
1024              typedef typename traits::char_class_type m_type;
1025              if(static_cast<re_set_long<m_type>*>(state)->singleton)
1026              {
1027                 l_map[0] |= mask_init;
1028                 for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1029                 {
1030                    charT c = static_cast<charT>(i);
1031                    if(&c != re_is_set_member(&c, &c + 1, static_cast<re_set_long<m_type>*>(state), *m_pdata, l_icase))
1032                       l_map[i] |= mask;
1033                 }
1034              }
1035              else
1036                 set_all_masks(l_map, mask);
1037           }
1038           return;
1039        case syntax_element_set:
1040           if(l_map)
1041           {
1042              l_map[0] |= mask_init;
1043              for(unsigned int i = 0; i < (1u << CHAR_BIT); ++i)
1044              {
1045                 if(static_cast<re_set*>(state)->_map[
1046                    static_cast<unsigned char>(m_traits.translate(static_cast<charT>(i), l_icase))])
1047                    l_map[i] |= mask;
1048              }
1049           }
1050           return;
1051        case syntax_element_jump:
1052           state = static_cast<re_alt*>(state)->alt.p;
1053           not_last_jump = -1;
1054           break;
1055        case syntax_element_alt:
1056        case syntax_element_rep:
1057        case syntax_element_dot_rep:
1058        case syntax_element_char_rep:
1059        case syntax_element_short_set_rep:
1060        case syntax_element_long_set_rep:
1061           {
1062              re_alt* rep = static_cast<re_alt*>(state);
1063              if(rep->_map[0] & mask_init)
1064              {
1065                 if(l_map)
1066                 {
1067                    l_map[0] |= mask_init;
1068                    for(unsigned int i = 0; i <= UCHAR_MAX; ++i)
1069                    {
1070                       if(rep->_map[i] & mask_any)
1071                          l_map[i] |= mask;
1072                    }
1073                 }
1074                 if(pnull)
1075                 {
1076                    if(rep->can_be_null & mask_any)
1077                       *pnull |= mask;
1078                 }
1079              }
1080              else
1081              {
1082                 if(is_bad_repeat(state))
1083                 {
1084                    set_all_masks(l_map, mask);
1085                    if(pnull)
1086                       *pnull |= mask;
1087                    return;
1088                 }
1089                 set_bad_repeat(state);
1090                 create_startmap(state->next.p, l_map, pnull, mask);
1091                 if((state->type == syntax_element_alt)
1092                    || (static_cast<re_repeat*>(state)->min == 0)
1093                    || (not_last_jump == 0))
1094                    create_startmap(rep->alt.p, l_map, pnull, mask);
1095              }
1096           }
1097           return;
1098        case syntax_element_soft_buffer_end:
1099           if(l_map)
1100           {
1101              l_map[0] |= mask_init;
1102              l_map[static_cast<unsigned>('\n')] |= mask;
1103              l_map[static_cast<unsigned>('\r')] |= mask;
1104           }
1105           if(pnull)
1106              *pnull |= mask;
1107           return;
1108        case syntax_element_endmark:
1109           if(static_cast<re_brace*>(state)->index < 0)
1110           {
1111              set_all_masks(l_map, mask);
1112              if(pnull)
1113                 *pnull |= mask;
1114              return;
1115           }
1116           else if(recursion_start && (recursion_sub != 0) && (recursion_sub == static_cast<re_brace*>(state)->index))
1117           {
1118              recursion_start = 0;
1119              state = recursion_restart;
1120              break;
1121           }
1122           if(m_pdata->m_has_recursions && static_cast<re_brace*>(state)->index)
1123           {
1124              bool ok = false;
1125              re_syntax_base* p = m_pdata->m_first_state;
1126              while(p)
1127              {
1128                 if(p->type == syntax_element_recurse)
1129                 {
1130                    re_brace* p2 = static_cast<re_brace*>(static_cast<re_jump*>(p)->alt.p);
1131                    if((p2->type == syntax_element_startmark) && (p2->index == static_cast<re_brace*>(state)->index))
1132                    {
1133                       ok = true;
1134                       break;
1135                    }
1136                 }
1137                 p = p->next.p;
1138              }
1139              if(ok && ((m_recursion_checks[static_cast<re_brace*>(state)->index] & 2u) == 0))
1140              {
1141                 m_recursion_checks[static_cast<re_brace*>(state)->index] |= 2u;
1142                 create_startmap(p->next.p, l_map, pnull, mask);
1143              }
1144           }
1145           state = state->next.p;
1146           break;
1147        case syntax_element_commit:
1148           set_all_masks(l_map, mask);
1149           state = state->next.p;
1150           break;
1151        case syntax_element_startmark:
1152           if(static_cast<re_brace*>(state)->index == -3)
1153           {
1154              state = state->next.p->next.p;
1155              break;
1156           }
1157           BOOST_REGEX_FALLTHROUGH;
1158        default:
1159           state = state->next.p;
1160        }
1161        ++not_last_jump;
1162     }
1163  }
1164  template <class charT, class traits>
1165  unsigned basic_regex_creator<charT, traits>::get_restart_type(re_syntax_base* state)
1166  {
1167     while(state)
1168     {
1169        switch(state->type)
1170        {
1171        case syntax_element_startmark:
1172        case syntax_element_endmark:
1173           state = state->next.p;
1174           continue;
1175        case syntax_element_start_line:
1176           return regbase::restart_line;
1177        case syntax_element_word_start:
1178           return regbase::restart_word;
1179        case syntax_element_buffer_start:
1180           return regbase::restart_buf;
1181        case syntax_element_restart_continue:
1182           return regbase::restart_continue;
1183        default:
1184           state = 0;
1185           continue;
1186        }
1187     }
1188     return regbase::restart_any;
1189  }
1190  template <class charT, class traits>
1191  void basic_regex_creator<charT, traits>::set_all_masks(unsigned char* bits, unsigned char mask)
1192  {
1193     if(bits)
1194     {
1195        if(bits[0] == 0)
1196           (std::memset)(bits, mask, 1u << CHAR_BIT);
1197        else
1198        {
1199           for(unsigned i = 0; i < (1u << CHAR_BIT); ++i)
1200              bits[i] |= mask;
1201        }
1202        bits[0] |= mask_init;
1203     }
1204  }
1205  template <class charT, class traits>
1206  bool basic_regex_creator<charT, traits>::is_bad_repeat(re_syntax_base* pt)
1207  {
1208     switch(pt->type)
1209     {
1210     case syntax_element_rep:
1211     case syntax_element_dot_rep:
1212     case syntax_element_char_rep:
1213     case syntax_element_short_set_rep:
1214     case syntax_element_long_set_rep:
1215        {
1216           unsigned state_id = static_cast<re_repeat*>(pt)->state_id;
1217           if(state_id >= sizeof(m_bad_repeats) * CHAR_BIT)
1218              return true;  
1219           static const std::uintmax_t one = 1uL;
1220           return m_bad_repeats & (one << state_id);
1221        }
1222     default:
1223        return false;
1224     }
1225  }
1226  template <class charT, class traits>
1227  void basic_regex_creator<charT, traits>::set_bad_repeat(re_syntax_base* pt)
1228  {
1229     switch(pt->type)
1230     {
1231     case syntax_element_rep:
1232     case syntax_element_dot_rep:
1233     case syntax_element_char_rep:
1234     case syntax_element_short_set_rep:
1235     case syntax_element_long_set_rep:
1236        {
1237           unsigned state_id = static_cast<re_repeat*>(pt)->state_id;
1238           static const std::uintmax_t one = 1uL;
1239           if(state_id <= sizeof(m_bad_repeats) * CHAR_BIT)
1240              m_bad_repeats |= (one << state_id);
1241        }
1242        break;
1243     default:
1244        break;
1245     }
1246  }
1247  template <class charT, class traits>
1248  syntax_element_type basic_regex_creator<charT, traits>::get_repeat_type(re_syntax_base* state)
1249  {
1250     typedef typename traits::char_class_type m_type;
1251     if(state->type == syntax_element_rep)
1252     {
1253        if(state->next.p->next.p->next.p == static_cast<re_alt*>(state)->alt.p)
1254        {
1255           switch(state->next.p->type)
1256           {
1257           case BOOST_REGEX_DETAIL_NS::syntax_element_wild:
1258              return BOOST_REGEX_DETAIL_NS::syntax_element_dot_rep;
1259           case BOOST_REGEX_DETAIL_NS::syntax_element_literal:
1260              return BOOST_REGEX_DETAIL_NS::syntax_element_char_rep;
1261           case BOOST_REGEX_DETAIL_NS::syntax_element_set:
1262              return BOOST_REGEX_DETAIL_NS::syntax_element_short_set_rep;
1263           case BOOST_REGEX_DETAIL_NS::syntax_element_long_set:
1264              if(static_cast<BOOST_REGEX_DETAIL_NS::re_set_long<m_type>*>(state->next.p)->singleton)
1265                 return BOOST_REGEX_DETAIL_NS::syntax_element_long_set_rep;
1266              break;
1267           default:
1268              break;
1269           }
1270        }
1271     }
1272     return state->type;
1273  }
1274  template <class charT, class traits>
1275  void basic_regex_creator<charT, traits>::probe_leading_repeat(re_syntax_base* state)
1276  {
1277     do
1278     {
1279        switch(state->type)
1280        {
1281        case syntax_element_startmark:
1282           if(static_cast<re_brace*>(state)->index >= 0)
1283           {
1284              state = state->next.p;
1285              continue;
1286           }
1287  #ifdef BOOST_REGEX_MSVC
1288  #  pragma warning(push)
1289  #pragma warning(disable:6011)
1290  #endif
1291           if((static_cast<re_brace*>(state)->index == -1)
1292              || (static_cast<re_brace*>(state)->index == -2))
1293           {
1294              state = static_cast<const re_jump*>(state->next.p)->alt.p->next.p;
1295              continue;
1296           }
1297  #ifdef BOOST_REGEX_MSVC
1298  #  pragma warning(pop)
1299  #endif
1300           if(static_cast<re_brace*>(state)->index == -3)
1301           {
1302              state = state->next.p->next.p;
1303              continue;
1304           }
1305           return;
1306        case syntax_element_endmark:
1307        case syntax_element_start_line:
1308        case syntax_element_end_line:
1309        case syntax_element_word_boundary:
1310        case syntax_element_within_word:
1311        case syntax_element_word_start:
1312        case syntax_element_word_end:
1313        case syntax_element_buffer_start:
1314        case syntax_element_buffer_end:
1315        case syntax_element_restart_continue:
1316           state = state->next.p;
1317           break;
1318        case syntax_element_dot_rep:
1319        case syntax_element_char_rep:
1320        case syntax_element_short_set_rep:
1321        case syntax_element_long_set_rep:
1322           if(this->m_has_backrefs == 0)
1323              static_cast<re_repeat*>(state)->leading = true;
1324           BOOST_REGEX_FALLTHROUGH;
1325        default:
1326           return;
1327        }
1328     }while(state);
1329  }
1330  } 
1331  } 
1332  #ifdef BOOST_REGEX_MSVC
1333  #  pragma warning(pop)
1334  #endif
1335  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartition.h"
5  #include "colpartitiongrid.h"
6  #include "colpartitionset.h"
7  #include "detlinefit.h"
8  #include "dppoint.h"
9  #include "helpers.h" 
10  #include "host.h"    
11  #include "imagefind.h"
12  #include "workingpartset.h"
13  #include <algorithm>
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part->set_type(block_type);
57    part->set_flow(flow);
58    part->AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part->set_left_margin(box.left());
60    part->set_right_margin(box.right());
61    part->SetBlobTypes();
62    part->ComputeLimits();
63    part->ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box->set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single->set_flow(BTFT_NONE);
71    single->AddBox(box);
72    single->ComputeLimits();
73    single->ClaimBoxes();
74    single->SetBlobTypes();
75    single->set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()->RemovePartner(false, this);
86    }
87    it.set_to_list(&lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()->RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
96    part->bounding_box_ = TBOX(left, bottom, right, top);
97    part->median_bottom_ = bottom;
98    part->median_top_ = top;
99    part->median_height_ = top - bottom;
100    part->median_left_ = left;
101    part->median_right_ = right;
102    part->median_width_ = right - left;
103    part->left_key_ = part->BoxLeftKey();
104    part->right_key_ = part->BoxRightKey();
105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox->bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom<BLOBNBOX>);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom<BLOBNBOX>, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft<BLOBNBOX>);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft<BLOBNBOX>, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf("Added box (%d,%d)->(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n",
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox->bounding_box().width() > biggest->bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox->bounding_box().height() > biggest->bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()->bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob->owner();
183      if (other == nullptr) {
184        bblob->set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob->owner() == this || bblob->owner() == nullptr);
195      bblob->set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob->owner() == this) {
203        bblob->set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob->flow() != BTFT_LEADER) {
212        if (bblob->owner() == this) {
213          bblob->set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob->remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ && !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() > bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf("Bounding box invalid\n");
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ > bounding_box_.left() ||
255        right_margin_ < bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf("Margins invalid\n");
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ > BoxLeftKey() || right_key_ < BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf("Key inside box: %d v %d or %d v %d\n", left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &other) const {
285    if (color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise &&
286        other.color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o < kMaxColorDistance && d_this2_o < kMaxColorDistance &&
298           d_o1_this < kMaxColorDistance && d_o2_this < kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &other) const {
308    if (bounding_box_.right() < other.bounding_box_.left() &&
309        bounding_box_.right() < other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() < bounding_box_.left() &&
313        other.bounding_box_.right() < LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() > other.bounding_box_.right() &&
317        bounding_box_.left() > other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() > bounding_box_.right() &&
321        other.bounding_box_.left() > RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
332    BLOBNBOX_C_IT other_it(const_cast<BLOBNBOX_CLIST *>(&other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() && !other_it.cycled_list()) {
336      if (box_it.data()->MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count > nonmatch_count;
346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob->IsDiacritic()) {
355        if (debug) {
356          tprintf("Blob is not a diacritic:");
357          blob->bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob->base_char_top() < min_top) {
362        min_top = blob->base_char_top();
363      }
364      if (blob->base_char_bottom() > max_bottom) {
365        max_bottom = blob->base_char_bottom();
366      }
367    }
368    bool result =
369        min_top > candidate.median_bottom_ && max_bottom < candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf("OKDiacritic!\n");
373      } else {
374        tprintf("y ranges don\'t overlap: %d-%d / %d-%d\n", max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector->sort_key();
383      left_key_tab_ = left_key_ <= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector->sort_key();
394      right_key_tab_ = right_key_ >= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ > bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ < bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
428    return it.data()->left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
432    it.move_to_last();
433    return it.data()->right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type < BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type < BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob->special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type < BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob->special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner->lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
477    } else {
478      partner->upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &upper_partners_ : &lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
494    if (!partners->singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &cb) {
501    ASSERT_HOST(owns_blobs() == other->owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other->bounding_box_.left(),
505                                  other->bounding_box_.bottom())) {
506      tprintf("Merging:");
507      Print();
508      other->Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type < BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other->boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other->special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) > 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&boxes_);
522    BLOBNBOX_C_IT it2(&other->boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2->owner();
526      if (prev_owner != other && prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2->set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other->left_margin_);
536    right_margin_ = std::max(right_margin_, other->right_margin_);
537    if (other->left_key_ < left_key_) {
538      left_key_ = other->left_key_;
539      left_key_tab_ = other->left_key_tab_;
540    }
541    if (other->right_key_ > right_key_) {
542      right_key_ = other->right_key_;
543      right_key_tab_ = other->right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other->flow_)) {
546      flow_ = other->flow_;
547      blob_type_ = other->blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom<BLOBNBOX>);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft<BLOBNBOX>);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper < 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&partners);
561      part_it.add_list_after(upper ? &other->upper_partners_
562                                   : &other->lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner->RemovePartner(!upper, other);
566        partner->RemovePartner(!upper, this);
567        partner->AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &merge1,
576                                    const ColPartition &merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf("Vertical partition\n");
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf("Voverlap %d (%d)\n", merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() < median_top_ && merged_box.top() > median_bottom_ &&
594        merged_box.bottom() < bounding_box_.top() - ok_box_overlap &&
595        merged_box.top() > bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf("Excessive box overlap\n");
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&boxes_);
608    TBOX left_box(it.data()->bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox->bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part->set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox->owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part->boxes_.empty()) {
627        split_part->AddBox(it.extract());
628        if (owns_blobs() && prev_owner != nullptr) {
629          bbox->set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part->IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part->left_key_tab_ = false;
640    ComputeLimits();
641    split_part->ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x <= bounding_box_.left() || split_x >= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part->set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox->owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &box = bbox->bounding_box();
656      if (box.left() >= split_x) {
657        split_part->AddBox(it.extract());
658        if (owns_blobs() && prev_owner != nullptr) {
659          bbox->set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&split_part->boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part->IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part->left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part->left_margin_ = split_x;
675    ComputeLimits();
676    split_part->ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox->bounding_box();
693        if (bbox->flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ > BoxLeftKey() && textord_debug_bugs) {
702      tprintf("Computed left-illegal partition\n");
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ < BoxRightKey() && textord_debug_bugs) {
709      tprintf("Computed right-illegal partition\n");
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox->flow() != BTFT_LEADER) {
733          const TBOX &box = bbox->bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast<int>(top_stats.median() + 0.5);
744      median_bottom_ = static_cast<int>(bottom_stats.median() + 0.5);
745      median_height_ = static_cast<int>(height_stats.median() + 0.5);
746      median_left_ = static_cast<int>(left_stats.median() + 0.5);
747      median_right_ = static_cast<int>(right_stats.median() + 0.5);
748      median_width_ = static_cast<int>(width_stats.median() + 0.5);
749    }
750    if (right_margin_ < bounding_box_.right() && textord_debug_bugs) {
751      tprintf("Made partition with bad right coords, %d < %d\n", right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ > bounding_box_.left() && textord_debug_bugs) {
756      tprintf("Made partition with bad left coords, %d > %d\n", left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper < 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&partners);
763      part_it.add_list_after(upper ? &upper_partners_ : &lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner->RemovePartner(!upper, this);
767        partner->AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf("Recomputed box for partition %p\n", static_cast<void *>(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &box) {
777    BLOBNBOX_C_IT it(&boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox->bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns->SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &first_column_, &last_column_,
793        &first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ < last_column_ && span_type == CST_PULLOUT &&
796        !IsLineType()) {
797      if (first_spanned_col >= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ & 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ & 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE && blob_type_ != BRT_VLINE &&
815          blob_type_ != BRT_RECTIMAGE && blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!"Undefined flow type for image!");
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!"Undefined flow type for text!");
854        }
855    }
856    ASSERT_HOST(!"Should never get here!");
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns->SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT && left_key_tab_ && right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob->set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob->bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob->bounding_box().left();
887      int right = blob->bounding_box().right();
888      gap_stats.add(left - prev_blob->bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob->set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind >= 4) {
900      tprintf("gap iqr = %g, blob_count=%d, limits=%g,%g\n", gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr < max_width * kMaxLeaderGapFractionOfMax &&
905        gap_iqr < min_width * kMaxLeaderGapFractionOfMin &&
906        blob_count >= kMinLeaderCount) {
<span onclick='openModal()' class='match'>907      int offset = static_cast<int>(ceil(gap_iqr * 2));
908      int min_step = static_cast<int>(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
</span>910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob->bounding_box().left();
917        int right = blob->bounding_box().right();
918        int height = blob->bounding_box().height();
919        for (int x = left; x < right; ++x) {
920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr && best_end->total_cost() < blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)->bounding_box().left() -
933                      blob->bounding_box().right();
934            if (blob->bounding_box().width() + gap > max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob->bounding_box().left() -
942                      it.data_relative(-1)->bounding_box().right();
943            if (blob->bounding_box().width() + gap > max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob->set_region_type(BRT_TEXT);
950          blob->set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf("No path\n");
960        } else {
961          tprintf("Total cost = %d vs allowed %d\n", best_end->total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob->NoisyNeighbours();
980      good_blob_score_ += blob->GoodTextBlob();
981      if (blob->region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob->region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count > vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count > hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value < -1 || 1 < value) {
997      int long_side;
998      int short_side;
999      if (value > 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count >= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side > kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect < long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) >= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) >= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN && strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN && value < 0 && strong_score < 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count >= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf("RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,",
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(" Projection value=%d, flow=%d, blob_type=%d\n", value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob->flow() != BTFT_LEADER) {
1053        blob->set_flow(flow_);
1054      }
1055      blob->set_region_type(blob_type_);
1056      ASSERT_HOST(blob->owner() == nullptr || blob->owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&boxes_);
1066    TBOX box(it.data()->bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob->bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()->bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()->bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob->bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()->bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&start_pt, &end_pt);
1107    return error < max_error && coverage >= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr && partner->working_set_ != nullptr) {
1120      working_set_ = partner->working_set_;
1121      working_set_->AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr && textord_debug_bugs) {
1125      tprintf("Partition with partner has no working set!:");
1126      Print();
1127      partner->Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() && col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind >= 2) {
1137      tprintf("Match is %s for:", (col_index & 1) ? "Real" : "Between");
1138      Print();
1139    }
1140    if (it.cycled_list() && textord_debug_bugs) {
1141      tprintf("Target column=%d, only had %d\n", first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() && last_column_ != first_column_ && !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() && col_index <= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &completed_blocks, &to_blocks);
1153      }
1154      work_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set->AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part->boxes()->empty());
1172      STATS side_steps(0, part->bounding_box().height() - 1);
1173      if (part->bounding_box().height() > max_line_height) {
1174        max_line_height = part->bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part->boxes());
1177      int prev_bottom = blob_it.data()->bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob->bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step < 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part->set_side_step(static_cast<int>(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part->set_bottom_spacing(part->median_bottom() -
1192                                 next_part->median_bottom());
1193        part->set_top_spacing(part->median_top() - next_part->median_top());
1194      } else {
1195        part->set_bottom_spacing(page_height);
1196        part->set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part->Print();
1200        tprintf("side step = %.2f, top spacing = %d, bottom spacing=%d\n",
1201                side_steps.median(), part->top_spacing(), part->bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part->bottom_spacing() > same_block_threshold ||
1219          !part->SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() && part->bottom_spacing() <= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                "Spacings unequal: upper:%d/%d, lower:%d/%d,"
1226                " sizes %d %d %d\n",
1227                part->top_spacing(), part->bottom_spacing(),
1228                next_part->top_spacing(), next_part->bottom_spacing(),
1229                part->median_height(), next_part->median_height(),
1230                third_part != nullptr ? third_part->median_height() : 0);
1231          }
1232          if (part->SizesSimilar(*next_part) &&
1233              next_part->median_height() * kMaxSameBlockLineSpacing >
1234                  part->bottom_spacing() &&
1235              part->median_height() * kMaxSameBlockLineSpacing >
1236                  part->top_spacing()) {
1237            if (third_part == nullptr || !next_part->SizesSimilar(*third_part) ||
1238                third_part->median_height() * kMaxSameBlockLineSpacing <=
1239                    next_part->bottom_spacing() ||
1240                next_part->median_height() * kMaxSameBlockLineSpacing <=
1241                    next_part->top_spacing() ||
1242                next_part->bottom_spacing() > part->bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf("Added line to current block.\n");
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block->block);
1255        }
1256        sp_block_it.set_to_list(&spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind && !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf("Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n",
1261                  part->top_spacing(), part->bottom_spacing(),
1262                  next_part->top_spacing(), next_part->bottom_spacing(),
1263                  part->median_height(), next_part->median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &bleft, const ICOORD &tright, ICOORD *pos) {
1269    if (pos->x() < bleft.x()) {
1270      pos->set_x(bleft.x());
1271    }
1272    if (pos->x() > tright.x()) {
1273      pos->set_x(tright.x());
1274    }
1275    if (pos->y() < bleft.y()) {
1276      pos->set_y(bleft.y());
1277    }
1278    if (pos->y() > tright.y()) {
1279      pos->set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block->pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block->pdblk.poly_block()->IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&to_block->blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part->boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob->owner() != part) {
1297          tprintf("Ownership incorrect for blob:");
1298          bblob->bounding_box().print();
1299          tprintf("Part=");
1300          part->Print();
1301          if (bblob->owner() == nullptr) {
1302            tprintf("Not owned\n");
1303          } else {
1304            tprintf("Owner part:");
1305            bblob->owner()->Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob->owner() == part);
1309        ASSERT_HOST(!text_type || bblob->region_type() >= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob->cblob()->out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()->pathlength() > 0);
1313        if (vertical_text) {
1314          sizes.add(bblob->bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob->bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type && blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block->line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block->pdblk.bounding_box().width();
1330      if (block_width < line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block->line_spacing = static_cast<float>(line_spacing);
1334      to_block->max_blob_size = static_cast<float>(block_width + 1);
1335    } else {
1336      int block_height = block->pdblk.bounding_box().height();
1337      if (block_height < line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block->line_spacing = static_cast<float>(line_spacing);
1341      to_block->max_blob_size = static_cast<float>(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &bleft, const ICOORD &tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts->empty()) {
1349      return nullptr; 
1350    }
1351    block_parts->sort(&ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part->type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part->bottom_spacing();
1359    if (line_spacing < part->median_height()) {
1360      line_spacing = part->bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&it, &start, &end);
1373      } else {
1374        ColPartition::RightEdgeRun(&it, &start, &end);
1375      }
1376      ClipCoord(bleft, tright, &start);
1377      ClipCoord(bleft, tright, &end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &min_x, &max_x);
1381      UpdateRange(end.x(), &min_x, &max_x);
1382      UpdateRange(start.y(), &min_y, &max_y);
1383      UpdateRange(end.y(), &min_y, &max_y);
1384      if ((iteration == 0 && it.at_first()) || (iteration == 1 && it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration < 2);
1389    if (textord_debug_tabfind) {
1390      tprintf("Making block at (%d,%d)->(%d,%d)\n", min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK("", true, 0, 0, min_x, min_y, max_x, max_y);
1393    block->pdblk.set_poly_block(new POLY_BLOCK(&vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &bleft,
1397                                                const ICOORD &tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts->empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part->bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()->type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()->bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf("Making block at:");
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK("", true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block->pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob->bounding_box().top();
1427      int bottom = blob->bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast<float>(top), static_cast<float>(bottom),
1431                       static_cast<float>(line_size));
1432      } else {
1433        row->add_blob(blob, static_cast<float>(top), static_cast<float>(bottom),
1434                      static_cast<float>(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part->left_margin_ = left_margin_;
1442    part->right_margin_ = right_margin_;
1443    part->bounding_box_ = bounding_box_;
1444    memcpy(part->special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part->median_bottom_ = median_bottom_;
1447    part->median_top_ = median_top_;
1448    part->median_height_ = median_height_;
1449    part->median_left_ = median_left_;
1450    part->median_right_ = median_right_;
1451    part->median_width_ = median_width_;
1452    part->good_width_ = good_width_;
1453    part->good_column_ = good_column_;
1454    part->left_key_tab_ = left_key_tab_;
1455    part->right_key_tab_ = right_key_tab_;
1456    part->type_ = type_;
1457    part->flow_ = flow_;
1458    part->left_key_ = left_key_;
1459    part->right_key_ = right_key_;
1460    part->first_column_ = first_column_;
1461    part->last_column_ = last_column_;
1462    part->owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy->set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy->boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = "NHSRIUVT";
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        "ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)->(%dB-%d%c-%dM/%d,%d/%d)"
1489        " w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d"
1490        " ts=%d bs=%d ls=%d rs=%d\n",
1491        boxes_.empty() ? 'E' : ' ', left_margin_, left_key_tab_ ? 'T' : 'B',
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? 'T' : 'B', right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf("Colors:(%d, %d, %d)%d -> (%d, %d, %d)\n", color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner->SingletonPartner(false)) {
1512      if (partner->type_ > max_type) {
1513        max_type = partner->type_;
1514      }
1515      if (column_set_ == partner->column_set_) {
1516        left_stats.add(partner->first_column_, 1);
1517        right_stats.add(partner->last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ < first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner->SingletonPartner(false)) {
1529      partner->type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner->column_set_) {
1532        partner->first_column_ = first_column_;
1533        partner->last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &upper_partners_);
1545      RefinePartnersByType(false, &lower_partners_);
1546      if (!upper_partners_.empty() && !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &upper_partners_);
1548      }
1549      if (!lower_partners_.empty() && !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
1557    if (!partners->empty() && !partners->singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners->empty() && !partners->singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners->empty() && !partners->singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) && get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners->empty() && !partners->singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners->empty() && !partners->singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf("Refining %d %s partners by type for:\n", partners->length(),
1581              upper ? "Upper" : "Lower");
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() && !IsLineType() && type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner->type_)) {
1589          if (debug) {
1590            tprintf("Removing partner:");
1591            partner->Print();
1592          }
1593          partner->RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf("Keeping partner:");
1597          partner->Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner->blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf("Removing partner:");
1607            partner->Print();
1608          }
1609          partner->RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf("Keeping partner:");
1613          partner->Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &a->upper_partners_ : &a->lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a->RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2->RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any && !partners->empty() && !partners->singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf("Refining %d %s partners by merge for:\n", partners->length(),
1662              upper ? "Upper" : "Lower");
1663      Print();
1664    }
1665    while (!partners->empty() && !partners->singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part->first_column_ == candidate->last_column_ &&
1673            part->last_column_ == candidate->first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid->BestMergeCandidate(
1679          part, &candidates, debug, nullptr, &overlap_increase);
1680      if (candidate != nullptr && (overlap_increase <= 0 || desperate)) {
1681        if (debug) {
1682          tprintf("Merging:hoverlap=%d, voverlap=%d, OLI=%d\n",
1683                  part->HCoreOverlap(*candidate), part->VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid->RemoveBBox(candidate);
1687        grid->RemoveBBox(part);
1688        part->Absorb(candidate, nullptr);
1689        grid->InsertBBox(true, true, part);
1690        if (overlap_increase > 0) {
1691          part->desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf("Refining %d %s partners by overlap for:\n", partners->length(),
1704              upper ? "Upper" : "Lower");
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner->bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner->bounding_box_.left());
1715      if (overlap > best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf("Removing partner:");
1725          partner->Print();
1726        }
1727        partner->RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &other) {
1734    const TBOX &box = bbox->bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left < left_margin_ || right > right_margin_) {
1738      return false;
1739    }
1740    if (left < other.left_margin_ || right > other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf("Unique on (%d,%d)->(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n",
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss < other_miss) {
1758      return true;
1759    }
1760    if (this_miss > other_miss) {
1761      return false;
1762    }
1763    if (this_overlap > other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap < other_overlap) {
1767      return false;
1768    }
1769    return median_top_ >= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part->bottom_spacing(), 1);
1777      stats.add(part->top_spacing(), 1);
1778    }
1779    return static_cast<int>(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &part) const {
1782    return (last_column_ >= part.first_column_) &&
1783           (first_column_ <= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i < PN_COUNT; ++i) {
1794      if (i < PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]->SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &&
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &&
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]->SpacingEqual(median_space, resolution)) &&
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]->SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper->bottom_spacing();
1827          total_top += upper->top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count > 0) {
1833          int top_spacing = static_cast<int>(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast<int>(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf("Spacing run ended. Cause:");
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf("No more lines\n");
1839            } else {
1840              tprintf("Spacing change. Spacings:\n");
1841              for (int i = 0; i < PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf("NULL");
1844                  if (i > 0 && neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]->SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(" Lower partner:");
1848                      neighbourhood[i - 1]->SingletonPartner(false)->Print();
1849                    } else {
1850                      tprintf(" nullptr lower partner:\n");
1851                    }
1852                  } else {
1853                    tprintf("\n");
1854                  }
1855                } else {
1856                  tprintf("Top = %d, bottom = %d\n",
1857                          neighbourhood[i]->top_spacing(),
1858                          neighbourhood[i]->bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf("Mean spacing = %d/%d\n", top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper->set_top_spacing(top_spacing);
1868            upper->set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf("Setting mean on:");
1871              upper->Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j < PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]->SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &&
1897           ((parts[PN_ABOVE1] != nullptr &&
1898             parts[PN_ABOVE1]->SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &&
1900             parts[PN_BELOW1]->SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &&
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &&
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &&
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &&
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast<int>(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast<int>(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &other) const {
1940    return median_height_ <= other.median_height_ * kMaxSizeRatio &&
1941           other.median_height_ <= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key <= *margin_right && right_key >= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it->data();
1964    ColPartition *start_part = part;
1965    int start_y = part->bounding_box_.top();
1966    if (!part_it->at_first()) {
1967      int prev_bottom = part_it->data_relative(-1)->bounding_box_.bottom();
1968      if (prev_bottom < start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom > start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part->bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &margin_left, &margin_right);
1978    do {
1979      part_it->forward();
1980      part = part_it->data();
1981    } while (!part_it->at_first() &&
1982             UpdateLeftMargin(*part, &margin_left, &margin_right));
1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &next_margin_left, &next_margin_right);
1986    if (next_margin_left > margin_right) {
1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &&
1992               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1993      do {
1994        part_it->backward();
1995        part = part_it->data();
1996      } while (part != start_part &&
1997               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1998      part_it->forward();
1999    }
2000    part = part_it->data_relative(-1);
2001    end_y = part->bounding_box_.bottom();
2002    if (!part_it->at_first() && part_it->data()->bounding_box_.top() < end_y) {
2003      end_y = (end_y + part_it->data()->bounding_box_.top()) / 2;
2004    }
2005    start->set_y(start_y);
2006    start->set_x(part->XAtY(margin_right, start_y));
2007    end->set_y(end_y);
2008    end->set_x(part->XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind && !part_it->at_first()) {
2010      tprintf("Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2011              start_y, end_y, part->XAtY(margin_left, end_y), end->x(),
2012              part->left_margin_, part->bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key <= *margin_right && right_key >= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it->data();
2036    ColPartition *start_part = part;
2037    int start_y = part->bounding_box_.bottom();
2038    if (!part_it->at_last()) {
2039      int next_y = part_it->data_relative(1)->bounding_box_.top();
2040      if (next_y > start_y) {
2041        start_y = next_y;
2042      } else if (next_y < start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part->bounding_box_.top();
2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &margin_left, &margin_right);
2050    do {
2051      part_it->backward();
2052      part = part_it->data();
2053    } while (!part_it->at_last() &&
2054             UpdateRightMargin(*part, &margin_left, &margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &next_margin_left, &next_margin_right);
2058    if (next_margin_right < margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &&
2064               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2065      do {
2066        part_it->forward();
2067        part = part_it->data();
2068      } while (part != start_part &&
2069               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2070      part_it->backward();
2071    }
2072    part = part_it->data_relative(1);
2073    end_y = part->bounding_box().top();
2074    if (!part_it->at_last() && part_it->data()->bounding_box_.bottom() > end_y) {
2075      end_y = (end_y + part_it->data()->bounding_box_.bottom()) / 2;
2076    }
2077    start->set_y(start_y);
2078    start->set_x(part->XAtY(margin_left, start_y));
2079    end->set_y(end_y);
2080    end->set_x(part->XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind && !part_it->at_last()) {
2082      tprintf("Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2083              start_y, end_y, end->x(), part->XAtY(margin_right, end_y),
2084              part->bounding_box_.right(), part->right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex_creator.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                </div>
                <div class="column column_space"><pre><code>444     re_set* result = static_cast<re_set*>(append_state(syntax_element_set, sizeof(re_set)));
445     bool negate = char_set.is_negated();
446     std::memset(result->_map, 0, sizeof(result->_map));
447     item_iterator first, last;
</pre></code></div>
                <div class="column column_space"><pre><code>907      int offset = static_cast<int>(ceil(gap_iqr * 2));
908      int min_step = static_cast<int>(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    