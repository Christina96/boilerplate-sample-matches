
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.097719869706841%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_evaluate_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_DETECTION_EVALUATE_LAYER_HPP_
2  #define CAFFE_DETECTION_EVALUATE_LAYER_HPP_
3  #include <utility>
4  #include <vector>
5  #include "caffe/blob.hpp"
6  #include "caffe/layer.hpp"
7  #include "caffe/proto/caffe.pb.h"
8  namespace caffe {
9  template <typename Dtype>
10  class DetectionEvaluateLayer : public Layer<Dtype> {
11   public:
12    explicit DetectionEvaluateLayer(const LayerParameter& param)
13        : Layer<Dtype>(param) {}
<span onclick='openModal()' class='match'>14    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
15        const vector<Blob<Dtype>*>& top);
16    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
</span>17        const vector<Blob<Dtype>*>& top);
18    virtual inline const char* type() const { return "DetectionEvaluate"; }
19    virtual inline int ExactBottomBlobs() const { return 2; }
20    virtual inline int ExactNumTopBlobs() const { return 1; }
21   protected:
22    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
23        const vector<Blob<Dtype>*>& top);
24    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
25        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
26      NOT_IMPLEMENTED;
27    }
28    int num_classes_;
29    int background_label_id_;
30    float overlap_threshold_;
31    bool evaluate_difficult_gt_;
32    vector<pair<int, int> > sizes_;
33    int count_;
34    bool use_normalized_bbox_;
35    bool has_resize_;
36    ResizeParameter resize_param_;
37  };
38  }  
39  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_unbounded.cpp</h3>
            <pre><code>1  #include <nano/lib/stats.hpp>
2  #include <nano/node/confirmation_height_unbounded.hpp>
3  #include <nano/node/logging.hpp>
4  #include <nano/node/write_database_queue.hpp>
5  #include <nano/secure/ledger.hpp>
6  #include <boost/format.hpp>
7  #include <numeric>
<span onclick='openModal()' class='match'>8  nano::confirmation_height_unbounded::confirmation_height_unbounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
8  nano::confirmation_height_unbounded::confirmation_height_unbounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
</span>9  	ledger (ledger_a),
10  	write_database_queue (write_database_queue_a),
11  	batch_separate_pending_min_time (batch_separate_pending_min_time_a),
12  	logging (logging_a),
13  	logger (logger_a),
14  	stopped (stopped_a),
15  	batch_write_size (batch_write_size_a),
16  	notify_observers_callback (notify_observers_callback_a),
17  	notify_block_already_cemented_observers_callback (notify_block_already_cemented_observers_callback_a),
18  	awaiting_processing_size_callback (awaiting_processing_size_callback_a)
19  {
20  }
21  void nano::confirmation_height_unbounded::process (std::shared_ptr<nano::block> original_block)
22  {
23  	if (pending_empty ())
24  	{
25  		clear_process_vars ();
26  		timer.restart ();
27  	}
28  	std::shared_ptr<conf_height_details> receive_details;
29  	auto current = original_block->hash ();
30  	std::vector<nano::block_hash> orig_block_callback_data;
31  	std::vector<receive_source_pair> receive_source_pairs;
32  	release_assert (receive_source_pairs.empty ());
33  	bool first_iter = true;
34  	auto read_transaction (ledger.store.tx_begin_read ());
35  	do
36  	{
37  		if (!receive_source_pairs.empty ())
38  		{
39  			receive_details = receive_source_pairs.back ().receive_details;
40  			current = receive_source_pairs.back ().source_hash;
41  		}
42  		else
43  		{
44  			if (receive_details)
45  			{
46  				current = original_block->hash ();
47  				receive_details = nullptr;
48  			}
49  		}
50  		std::shared_ptr<nano::block> block;
51  		if (first_iter)
52  		{
53  			debug_assert (current == original_block->hash ());
54  			block = original_block;
55  			nano::lock_guard<nano::mutex> guard (block_cache_mutex);
56  			block_cache[original_block->hash ()] = original_block;
57  		}
58  		else
59  		{
60  			block = get_block_and_sideband (current, read_transaction);
61  		}
62  		if (!block)
63  		{
64  			auto error_str = (boost::format ("Ledger mismatch trying to set confirmation height for block %1% (unbounded processor)") % current.to_string ()).str ();
65  			logger.always_log (error_str);
66  			std::cerr << error_str << std::endl;
67  		}
68  		release_assert (block);
69  		nano::account account (block->account ());
70  		if (account.is_zero ())
71  		{
72  			account = block->sideband ().account;
73  		}
74  		auto block_height = block->sideband ().height;
75  		uint64_t confirmation_height = 0;
76  		auto account_it = confirmed_iterated_pairs.find (account);
77  		if (account_it != confirmed_iterated_pairs.cend ())
78  		{
79  			confirmation_height = account_it->second.confirmed_height;
80  		}
81  		else
82  		{
83  			nano::confirmation_height_info confirmation_height_info;
84  			ledger.store.confirmation_height.get (read_transaction, account, confirmation_height_info);
85  			confirmation_height = confirmation_height_info.height;
86  			if (first_iter && confirmation_height >= block_height)
87  			{
88  				debug_assert (current == original_block->hash ());
89  				notify_block_already_cemented_observers_callback (original_block->hash ());
90  			}
91  		}
92  		auto iterated_height = confirmation_height;
93  		if (account_it != confirmed_iterated_pairs.cend () && account_it->second.iterated_height > iterated_height)
94  		{
95  			iterated_height = account_it->second.iterated_height;
96  		}
97  		auto count_before_receive = receive_source_pairs.size ();
98  		std::vector<nano::block_hash> block_callback_datas_required;
99  		auto already_traversed = iterated_height >= block_height;
100  		if (!already_traversed)
101  		{
102  			collect_unconfirmed_receive_and_sources_for_account (block_height, iterated_height, block, current, account, read_transaction, receive_source_pairs, block_callback_datas_required, orig_block_callback_data, original_block);
103  		}
104  		if (stopped)
105  		{
106  			break;
107  		}
108  		read_transaction.reset ();
109  		auto confirmed_receives_pending = (count_before_receive != receive_source_pairs.size ());
110  		if (!confirmed_receives_pending)
111  		{
112  			preparation_data preparation_data{ block_height, confirmation_height, iterated_height, account_it, account, receive_details, already_traversed, current, block_callback_datas_required, orig_block_callback_data };
113  			prepare_iterated_blocks_for_cementing (preparation_data);
114  			if (!receive_source_pairs.empty ())
115  			{
116  				receive_source_pairs.erase (receive_source_pairs.end () - 1);
117  			}
118  		}
119  		else if (block_height > iterated_height)
120  		{
121  			if (account_it != confirmed_iterated_pairs.cend ())
122  			{
123  				account_it->second.iterated_height = block_height;
124  			}
125  			else
126  			{
127  				confirmed_iterated_pairs.emplace (std::piecewise_construct, std::forward_as_tuple (account), std::forward_as_tuple (confirmation_height, block_height));
128  				++confirmed_iterated_pairs_size;
129  			}
130  		}
131  		auto max_write_size_reached = (pending_writes.size () >= confirmation_height::unbounded_cutoff);
132  		auto min_time_exceeded = (timer.since_start () >= batch_separate_pending_min_time);
133  		auto finished_iterating = receive_source_pairs.empty ();
134  		auto no_pending = awaiting_processing_size_callback () == 0;
135  		auto should_output = finished_iterating && (no_pending || min_time_exceeded);
136  		auto total_pending_write_block_count = std::accumulate (pending_writes.cbegin (), pending_writes.cend (), uint64_t (0), [] (uint64_t total, conf_height_details const & receive_details_a) {
137  			return total += receive_details_a.num_blocks_confirmed;
138  		});
139  		auto force_write = total_pending_write_block_count > batch_write_size;
140  		if ((max_write_size_reached || should_output || force_write) && !pending_writes.empty ())
141  		{
142  			if (write_database_queue.process (nano::writer::confirmation_height))
143  			{
144  				auto scoped_write_guard = write_database_queue.pop ();
145  				cement_blocks (scoped_write_guard);
146  			}
147  			else if (force_write)
148  			{
149  				auto scoped_write_guard = write_database_queue.wait (nano::writer::confirmation_height);
150  				cement_blocks (scoped_write_guard);
151  			}
152  		}
153  		first_iter = false;
154  		read_transaction.renew ();
155  	} while ((!receive_source_pairs.empty () || current != original_block->hash ()) && !stopped);
156  }
157  void nano::confirmation_height_unbounded::collect_unconfirmed_receive_and_sources_for_account (uint64_t block_height_a, uint64_t confirmation_height_a, std::shared_ptr<nano::block> const & block_a, nano::block_hash const & hash_a, nano::account const & account_a, nano::read_transaction const & transaction_a, std::vector<receive_source_pair> & receive_source_pairs_a, std::vector<nano::block_hash> & block_callback_data_a, std::vector<nano::block_hash> & orig_block_callback_data_a, std::shared_ptr<nano::block> original_block)
158  {
159  	debug_assert (block_a->hash () == hash_a);
160  	auto hash (hash_a);
161  	auto num_to_confirm = block_height_a - confirmation_height_a;
162  	auto is_original_block = (hash == original_block->hash ());
163  	auto hit_receive = false;
164  	auto first_iter = true;
165  	while ((num_to_confirm > 0) && !hash.is_zero () && !stopped)
166  	{
167  		std::shared_ptr<nano::block> block;
168  		if (first_iter)
169  		{
170  			debug_assert (hash == hash_a);
171  			block = block_a;
172  			nano::lock_guard<nano::mutex> guard (block_cache_mutex);
173  			block_cache[hash] = block_a;
174  		}
175  		else
176  		{
177  			block = get_block_and_sideband (hash, transaction_a);
178  		}
179  		if (block)
180  		{
181  			auto source (block->source ());
182  			if (source.is_zero ())
183  			{
184  				source = block->link ().as_block_hash ();
185  			}
186  			if (!source.is_zero () && !ledger.is_epoch_link (source) && ledger.store.block.exists (transaction_a, source))
187  			{
188  				if (!hit_receive && !block_callback_data_a.empty ())
189  				{
190  					debug_assert (!receive_source_pairs_a.empty ());
191  					auto & last_receive_details = receive_source_pairs_a.back ().receive_details;
192  					last_receive_details->source_block_callback_data.assign (block_callback_data_a.begin (), block_callback_data_a.end ());
193  					block_callback_data_a.clear ();
194  				}
195  				is_original_block = false;
196  				hit_receive = true;
197  				auto block_height = confirmation_height_a + num_to_confirm;
198  				receive_source_pairs_a.emplace_back (std::make_shared<conf_height_details> (account_a, hash, block_height, 1, std::vector<nano::block_hash>{ hash }), source);
199  			}
200  			else if (is_original_block)
201  			{
202  				orig_block_callback_data_a.push_back (hash);
203  			}
204  			else
205  			{
206  				if (!hit_receive)
207  				{
208  					block_callback_data_a.push_back (hash);
209  				}
210  				else
211  				{
212  					auto & last_receive_details = receive_source_pairs_a.back ().receive_details;
213  					++last_receive_details->num_blocks_confirmed;
214  					last_receive_details->block_callback_data.push_back (hash);
215  					implicit_receive_cemented_mapping[hash] = std::weak_ptr<conf_height_details> (last_receive_details);
216  					implicit_receive_cemented_mapping_size = implicit_receive_cemented_mapping.size ();
217  				}
218  			}
219  			hash = block->previous ();
220  		}
221  		--num_to_confirm;
222  		first_iter = false;
223  	}
224  }
225  void nano::confirmation_height_unbounded::prepare_iterated_blocks_for_cementing (preparation_data & preparation_data_a)
226  {
227  	auto receive_details = preparation_data_a.receive_details;
228  	auto block_height = preparation_data_a.block_height;
229  	if (block_height > preparation_data_a.confirmation_height)
230  	{
231  		if (preparation_data_a.account_it != confirmed_iterated_pairs.cend ())
232  		{
233  			preparation_data_a.account_it->second.confirmed_height = block_height;
234  			if (block_height > preparation_data_a.iterated_height)
235  			{
236  				preparation_data_a.account_it->second.iterated_height = block_height;
237  			}
238  		}
239  		else
240  		{
241  			confirmed_iterated_pairs.emplace (std::piecewise_construct, std::forward_as_tuple (preparation_data_a.account), std::forward_as_tuple (block_height, block_height));
242  			++confirmed_iterated_pairs_size;
243  		}
244  		auto num_blocks_confirmed = block_height - preparation_data_a.confirmation_height;
245  		auto block_callback_data = preparation_data_a.block_callback_data;
246  		if (block_callback_data.empty ())
247  		{
248  			if (!receive_details)
249  			{
250  				block_callback_data = preparation_data_a.orig_block_callback_data;
251  			}
252  			else
253  			{
254  				debug_assert (receive_details);
255  				if (preparation_data_a.already_traversed && receive_details->source_block_callback_data.empty ())
256  				{
257  					auto & above_receive_details_w = implicit_receive_cemented_mapping[preparation_data_a.current];
258  					debug_assert (!above_receive_details_w.expired ());
259  					auto above_receive_details = above_receive_details_w.lock ();
260  					auto num_blocks_already_confirmed = above_receive_details->num_blocks_confirmed - (above_receive_details->height - preparation_data_a.confirmation_height);
261  					auto end_it = above_receive_details->block_callback_data.begin () + above_receive_details->block_callback_data.size () - (num_blocks_already_confirmed);
262  					auto start_it = end_it - num_blocks_confirmed;
263  					block_callback_data.assign (start_it, end_it);
264  				}
265  				else
266  				{
267  					block_callback_data = receive_details->source_block_callback_data;
268  				}
269  				auto num_to_remove = block_callback_data.size () - num_blocks_confirmed;
270  				block_callback_data.erase (std::next (block_callback_data.rbegin (), num_to_remove).base (), block_callback_data.end ());
271  				receive_details->source_block_callback_data.clear ();
272  			}
273  		}
274  		pending_writes.emplace_back (preparation_data_a.account, preparation_data_a.current, block_height, num_blocks_confirmed, block_callback_data);
275  		++pending_writes_size;
276  	}
277  	if (receive_details)
278  	{
279  		auto const & receive_account = receive_details->account;
280  		auto receive_account_it = confirmed_iterated_pairs.find (receive_account);
281  		if (receive_account_it != confirmed_iterated_pairs.cend ())
282  		{
283  			auto current_height = receive_account_it->second.confirmed_height;
284  			receive_account_it->second.confirmed_height = receive_details->height;
285  			auto const orig_num_blocks_confirmed = receive_details->num_blocks_confirmed;
286  			receive_details->num_blocks_confirmed = receive_details->height - current_height;
287  			auto block_callbacks_to_remove = orig_num_blocks_confirmed - receive_details->num_blocks_confirmed;
288  			receive_details->block_callback_data.erase (std::next (receive_details->block_callback_data.rbegin (), block_callbacks_to_remove).base (), receive_details->block_callback_data.end ());
289  			debug_assert (receive_details->block_callback_data.size () == receive_details->num_blocks_confirmed);
290  		}
291  		else
292  		{
293  			confirmed_iterated_pairs.emplace (std::piecewise_construct, std::forward_as_tuple (receive_account), std::forward_as_tuple (receive_details->height, receive_details->height));
294  			++confirmed_iterated_pairs_size;
295  		}
296  		pending_writes.push_back (*receive_details);
297  		++pending_writes_size;
298  	}
299  }
300  void nano::confirmation_height_unbounded::cement_blocks (nano::write_guard & scoped_write_guard_a)
301  {
302  	nano::timer<std::chrono::milliseconds> cemented_batch_timer;
303  	std::vector<std::shared_ptr<nano::block>> cemented_blocks;
304  	auto error = false;
305  	{
306  		auto transaction (ledger.store.tx_begin_write ({}, { nano::tables::confirmation_height }));
307  		cemented_batch_timer.start ();
308  		while (!pending_writes.empty ())
309  		{
310  			auto & pending = pending_writes.front ();
311  			nano::confirmation_height_info confirmation_height_info;
312  			ledger.store.confirmation_height.get (transaction, pending.account, confirmation_height_info);
313  			auto confirmation_height = confirmation_height_info.height;
314  			if (pending.height > confirmation_height)
315  			{
316  				auto block = ledger.store.block.get (transaction, pending.hash);
317  				debug_assert (ledger.pruning || block != nullptr);
318  				debug_assert (ledger.pruning || block->sideband ().height == pending.height);
319  				if (!block)
320  				{
321  					if (ledger.pruning && ledger.store.pruned.exists (transaction, pending.hash))
322  					{
323  						pending_writes.erase (pending_writes.begin ());
324  						--pending_writes_size;
325  						continue;
326  					}
327  					else
328  					{
329  						auto error_str = (boost::format ("Failed to write confirmation height for block %1% (unbounded processor)") % pending.hash.to_string ()).str ();
330  						logger.always_log (error_str);
331  						std::cerr << error_str << std::endl;
332  						error = true;
333  						break;
334  					}
335  				}
336  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in, pending.height - confirmation_height);
337  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in, pending.height - confirmation_height);
338  				debug_assert (pending.num_blocks_confirmed == pending.height - confirmation_height);
339  				confirmation_height = pending.height;
340  				ledger.cache.cemented_count += pending.num_blocks_confirmed;
341  				ledger.store.confirmation_height.put (transaction, pending.account, { confirmation_height, pending.hash });
342  				std::reverse (pending.block_callback_data.begin (), pending.block_callback_data.end ());
343  				nano::lock_guard<nano::mutex> guard (block_cache_mutex);
344  				std::transform (pending.block_callback_data.begin (), pending.block_callback_data.end (), std::back_inserter (cemented_blocks), [&block_cache = block_cache] (auto const & hash_a) {
345  					debug_assert (block_cache.count (hash_a) == 1);
346  					return block_cache.at (hash_a);
347  				});
348  			}
349  			pending_writes.erase (pending_writes.begin ());
350  			--pending_writes_size;
351  		}
352  	}
353  	auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
354  	if (logging.timing_logging () && time_spent_cementing > 50)
355  	{
356  		logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (unbounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
357  	}
358  	scoped_write_guard_a.release ();
359  	notify_observers_callback (cemented_blocks);
360  	release_assert (!error);
361  	debug_assert (pending_writes.empty ());
362  	debug_assert (pending_writes_size == 0);
363  	timer.restart ();
364  }
365  std::shared_ptr<nano::block> nano::confirmation_height_unbounded::get_block_and_sideband (nano::block_hash const & hash_a, nano::transaction const & transaction_a)
366  {
367  	nano::lock_guard<nano::mutex> guard (block_cache_mutex);
368  	auto block_cache_it = block_cache.find (hash_a);
369  	if (block_cache_it != block_cache.cend ())
370  	{
371  		return block_cache_it->second;
372  	}
373  	else
374  	{
375  		auto block (ledger.store.block.get (transaction_a, hash_a));
376  		block_cache.emplace (hash_a, block);
377  		return block;
378  	}
379  }
380  bool nano::confirmation_height_unbounded::pending_empty () const
381  {
382  	return pending_writes.empty ();
383  }
384  void nano::confirmation_height_unbounded::clear_process_vars ()
385  {
386  	confirmed_iterated_pairs.clear ();
387  	confirmed_iterated_pairs_size = 0;
388  	implicit_receive_cemented_mapping.clear ();
389  	implicit_receive_cemented_mapping_size = 0;
390  	{
391  		nano::lock_guard<nano::mutex> guard (block_cache_mutex);
392  		block_cache.clear ();
393  	}
394  }
395  bool nano::confirmation_height_unbounded::has_iterated_over_block (nano::block_hash const & hash_a) const
396  {
397  	nano::lock_guard<nano::mutex> guard (block_cache_mutex);
398  	return block_cache.count (hash_a) == 1;
399  }
400  uint64_t nano::confirmation_height_unbounded::block_cache_size () const
401  {
402  	nano::lock_guard<nano::mutex> guard (block_cache_mutex);
403  	return block_cache.size ();
404  }
405  nano::confirmation_height_unbounded::conf_height_details::conf_height_details (nano::account const & account_a, nano::block_hash const & hash_a, uint64_t height_a, uint64_t num_blocks_confirmed_a, std::vector<nano::block_hash> const & block_callback_data_a) :
406  	account (account_a),
407  	hash (hash_a),
408  	height (height_a),
409  	num_blocks_confirmed (num_blocks_confirmed_a),
410  	block_callback_data (block_callback_data_a)
411  {
412  }
413  nano::confirmation_height_unbounded::receive_source_pair::receive_source_pair (std::shared_ptr<conf_height_details> const & receive_details_a, const block_hash & source_a) :
414  	receive_details (receive_details_a),
415  	source_hash (source_a)
416  {
417  }
418  nano::confirmation_height_unbounded::confirmed_iterated_pair::confirmed_iterated_pair (uint64_t confirmed_height_a, uint64_t iterated_height_a) :
419  	confirmed_height (confirmed_height_a),
420  	iterated_height (iterated_height_a)
421  {
422  }
423  std::unique_ptr<nano::container_info_component> nano::collect_container_info (confirmation_height_unbounded & confirmation_height_unbounded, std::string const & name_a)
424  {
425  	auto composite = std::make_unique<container_info_composite> (name_a);
426  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "confirmed_iterated_pairs", confirmation_height_unbounded.confirmed_iterated_pairs_size, sizeof (decltype (confirmation_height_unbounded.confirmed_iterated_pairs)::value_type) }));
427  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "pending_writes", confirmation_height_unbounded.pending_writes_size, sizeof (decltype (confirmation_height_unbounded.pending_writes)::value_type) }));
428  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "implicit_receive_cemented_mapping", confirmation_height_unbounded.implicit_receive_cemented_mapping_size, sizeof (decltype (confirmation_height_unbounded.implicit_receive_cemented_mapping)::value_type) }));
429  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "block_cache", confirmation_height_unbounded.block_cache_size (), sizeof (decltype (confirmation_height_unbounded.block_cache)::value_type) }));
430  	return composite;
431  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_evaluate_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_unbounded.cpp</div>
                </div>
                <div class="column column_space"><pre><code>14    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
15        const vector<Blob<Dtype>*>& top);
16    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
</pre></code></div>
                <div class="column column_space"><pre><code>8  nano::confirmation_height_unbounded::confirmation_height_unbounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
8  nano::confirmation_height_unbounded::confirmation_height_unbounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    