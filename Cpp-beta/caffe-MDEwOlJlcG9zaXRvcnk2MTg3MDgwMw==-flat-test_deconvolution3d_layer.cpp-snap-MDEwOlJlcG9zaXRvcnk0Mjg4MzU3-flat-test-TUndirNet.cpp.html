
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.146681539319577%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_deconvolution3d_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include <iostream>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/deconv_layer.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  int initial_list[]={2,3,6,4,6};
12  vector<int> initial_vector(initial_list,initial_list+5);
13  template <typename TypeParam>
14  class DeconvolutionLayerTest3d : public MultiDeviceTest<TypeParam> {
15    typedef typename TypeParam::Dtype Dtype;
16   protected:
17    DeconvolutionLayerTest3d()
18        : blob_bottom_(new Blob<Dtype>(initial_vector)),
19          blob_bottom_2_(new Blob<Dtype>(initial_vector)),
20          blob_top_(new Blob<Dtype>()),
21          blob_top_2_(new Blob<Dtype>()) {}
22    virtual void SetUp() {
23      FillerParameter filler_param;
24      filler_param.set_value(1.);
25      GaussianFiller<Dtype> filler(filler_param);
26      filler.Fill(this->blob_bottom_);
27      filler.Fill(this->blob_bottom_2_);
28      blob_bottom_vec_.push_back(blob_bottom_);
29      blob_top_vec_.push_back(blob_top_);
30    }
31    virtual ~DeconvolutionLayerTest3d() {
32      delete blob_bottom_;
33      delete blob_bottom_2_;
34      delete blob_top_;
35      delete blob_top_2_;
36    }
37    Blob<Dtype>* const blob_bottom_;
38    Blob<Dtype>* const blob_bottom_2_;
39    Blob<Dtype>* const blob_top_;
40    Blob<Dtype>* const blob_top_2_;
41    vector<Blob<Dtype>*> blob_bottom_vec_;
42    vector<Blob<Dtype>*> blob_top_vec_;
43  };
44  TYPED_TEST_CASE(DeconvolutionLayerTest3d, TestDtypesAndDevices);
45  TYPED_TEST(DeconvolutionLayerTest3d, TestSetup) {
46    typedef typename TypeParam::Dtype Dtype;
47    LayerParameter layer_param;
48    ConvolutionParameter* convolution_param =
49        layer_param.mutable_convolution_param();
50    convolution_param->add_kernel_size(3);
51    convolution_param->add_stride(2);
52    convolution_param->set_num_output(4);
53    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
54    this->blob_top_vec_.push_back(this->blob_top_2_);
55    shared_ptr<Layer<Dtype> > layer(
56        new DeconvolutionLayer<Dtype>(layer_param));
57    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
58    int iarray[] = {2,4,13,9,13};
59    vector<int> desired_shape(iarray, iarray+5);
60    for(size_t i=0; i<desired_shape.size();i++){
61      EXPECT_EQ(this->blob_top_->shape()[i], desired_shape[i]);
62      EXPECT_EQ(this->blob_top_2_->shape()[i], desired_shape[i]);
63    }
64    convolution_param->set_num_output(3);
65    convolution_param->set_group(3);
66    layer.reset(new DeconvolutionLayer<Dtype>(layer_param));
67    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
68    desired_shape[1]=3;
69    for(size_t i=0; i<desired_shape.size();i++){
70      EXPECT_EQ(this->blob_top_->shape()[i], desired_shape[i]);
71      EXPECT_EQ(this->blob_top_2_->shape()[i], desired_shape[i]);
72    }
73  }
74  TYPED_TEST(DeconvolutionLayerTest3d, TestSimpleDeconvolution) {
75    typedef typename TypeParam::Dtype Dtype;
76    float fill_weight = 0.85;
77    this->blob_bottom_vec_.push_back(this->blob_bottom_2_);
78    this->blob_top_vec_.push_back(this->blob_top_2_);
79    LayerParameter layer_param;
80    ConvolutionParameter* convolution_param =
81        layer_param.mutable_convolution_param();
82    convolution_param->add_kernel_size(3);
83    convolution_param->add_stride(2);
84    convolution_param->set_num_output(4);
85    convolution_param->mutable_weight_filler()->set_type("constant");
86    convolution_param->mutable_weight_filler()->set_value(fill_weight);
87    convolution_param->mutable_bias_filler()->set_type("constant");
88    convolution_param->mutable_bias_filler()->set_value(0.1);
89    shared_ptr<Layer<Dtype> > layer(
90        new DeconvolutionLayer<Dtype>(layer_param));
91    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
92    FillerParameter filler_param;
93    filler_param.set_value(1.);
94    ConstantFiller<Dtype> filler(filler_param);
95    filler.Fill(this->blob_bottom_);
96    filler.Fill(this->blob_bottom_2_);
97    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
98    const Dtype* top_data = this->blob_top_->cpu_data();
99    for (int n = 0; n < this->blob_top_->shape()[0]; ++n) {
100      for (int c = 0; c < this->blob_top_->shape()[1]; ++c) {
101        for (int d = 0; d < this->blob_top_->shape()[2]; ++d) {
102          for (int h = 0; h < this->blob_top_->shape()[3]; ++h) {
103            for (int w = 0; w < this->blob_top_->shape()[4]; ++w) {
104              Dtype expected = 0.1 + 3 * fill_weight;
105              bool d_overlap = d % 2 == 0 && d > 0
106                && d < this->blob_top_->shape()[2] - 1;
107              bool h_overlap = h % 2 == 0 && h > 0
108                && h < this->blob_top_->shape()[3] - 1;
109              bool w_overlap = w % 2 == 0 && w > 0
110                && w < this->blob_top_->shape()[4] - 1;
111              if (d_overlap && h_overlap && w_overlap){
112                expected += 21 * fill_weight;
113              } else if ((d_overlap && h_overlap) || (d_overlap && w_overlap) || (h_overlap && w_overlap)){
114                expected += 9 * fill_weight;
115              } else if (d_overlap || h_overlap || w_overlap){
116                expected += 3 * fill_weight;
117              }
118              int off_list[]={n,c,d,h,w};
119              vector<int> off_set(off_list, off_list + 5);
120              EXPECT_NEAR(top_data[this->blob_top_->offset(off_set)], expected, 1e-4);
121            }
122          }
123        }
124      }
125    }
126    convolution_param->clear_kernel_size();
127    convolution_param->add_kernel_size(2);
128    convolution_param->clear_stride();
129    convolution_param->add_stride(1);
130    convolution_param->set_num_output(3);
131    layer.reset(new DeconvolutionLayer<Dtype>(layer_param));
132    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
133    filler_param.set_value(1.);
134    caffe_set(this->blob_bottom_->count(), Dtype(0), this->blob_bottom_->mutable_cpu_data());
135    caffe_set(this->blob_bottom_2_->count(), Dtype(0), this->blob_bottom_2_->mutable_cpu_data());
136    caffe_set(this->blob_top_->count(), Dtype(0), this->blob_top_->mutable_cpu_data());
137    caffe_set(this->blob_top_2_->count(), Dtype(0), this->blob_top_2_->mutable_cpu_data());
138    filler.Fill(this->blob_bottom_);
139    filler.Fill(this->blob_bottom_2_);
140    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
141    top_data = this->blob_top_->cpu_data();
142    for (int n = 0; n < this->blob_top_->shape()[0]; ++n) {
143      for (int c = 0; c < this->blob_top_->shape()[1]; ++c) {
144        for (int d = 0; d < this->blob_top_->shape()[2]; ++d) {
145          for (int h = 0; h < this->blob_top_->shape()[3]; ++h) {
146            for (int w = 0; w < this->blob_top_->shape()[4]; ++w) {
147              Dtype expected = 0.1 + 3 * fill_weight;
148              bool d_overlap = d > 0 && d < this->blob_top_->shape()[2] - 1;
149              bool h_overlap = h > 0 && h < this->blob_top_->shape()[3] - 1;
150              bool w_overlap = w > 0 && w < this->blob_top_->shape()[4] - 1;
151              if (d_overlap && h_overlap && w_overlap){
152                expected += 21 * fill_weight;
153              } else if ((d_overlap && h_overlap) || (d_overlap && w_overlap) || (h_overlap && w_overlap)){
154                expected += 9 * fill_weight;
155              } else if (d_overlap || h_overlap || w_overlap){
156                expected += 3 * fill_weight;
157              }
158              int off_list[]={n,c,d,h,w};
159              vector<int> off_set(off_list, off_list + 5);
160              EXPECT_NEAR(top_data[this->blob_top_->offset(off_set)], expected, 1e-4);
161            }
162          }
163        }
164      }
165    }
166    convolution_param->clear_kernel_size();
167    convolution_param->add_kernel_size(3);
168    convolution_param->clear_stride();
169    convolution_param->add_stride(1);
170    convolution_param->clear_pad();
171    convolution_param->add_pad(1);
172    convolution_param->set_num_output(5);
173    layer.reset(new DeconvolutionLayer<Dtype>(layer_param));
174    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
175    filler_param.set_value(1.);
176    caffe_set(this->blob_bottom_->count(), Dtype(0), this->blob_bottom_->mutable_cpu_data());
177    caffe_set(this->blob_bottom_2_->count(), Dtype(0), this->blob_bottom_2_->mutable_cpu_data());
178    caffe_set(this->blob_top_->count(), Dtype(0), this->blob_top_->mutable_cpu_data());
179    caffe_set(this->blob_top_2_->count(), Dtype(0), this->blob_top_2_->mutable_cpu_data());
180    filler.Fill(this->blob_bottom_);
181    filler.Fill(this->blob_bottom_2_);
182    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
183    top_data = this->blob_top_->cpu_data();
184    for (int n = 0; n < this->blob_top_->shape()[0]; ++n) {
185      for (int c = 0; c < this->blob_top_->shape()[1]; ++c) {
186        for (int d = 0; d < this->blob_top_->shape()[2]; ++d) {
187          for (int h = 0; h < this->blob_top_->shape()[3]; ++h) {
188            for (int w = 0; w < this->blob_top_->shape()[4]; ++w) {
189              Dtype expected = 0.1 + 3 * 8 * fill_weight;
190              bool d_overlap = d > 0 && d < this->blob_top_->shape()[2] - 1;
191              bool h_overlap = h > 0 && h < this->blob_top_->shape()[3] - 1;
192              bool w_overlap = w > 0 && w < this->blob_top_->shape()[4] - 1;
193              if (d_overlap && h_overlap && w_overlap){
194                expected += 3 * 19 * fill_weight;
195              } else if ((d_overlap && h_overlap) || (d_overlap && w_overlap) || (h_overlap && w_overlap)){
196                expected += 3 * 10 * fill_weight;
197              } else if (d_overlap || h_overlap || w_overlap){
198                expected += 3 * 4 * fill_weight;
199              }
200              int off_list[]={n,c,d,h,w};
201              vector<int> off_set(off_list, off_list + 5);
202              EXPECT_NEAR(top_data[this->blob_top_->offset(off_set)], expected, 1e-4);
203            }
204          }
205        }
206      }
<span onclick='openModal()' class='match'>207    }
208    convolution_param->clear_kernel_size();
209    convolution_param->add_kernel_size(2);
210    convolution_param->clear_stride();
211    convolution_param->add_stride(2);
212    convolution_param->clear_pad();
213    convolution_param->set_num_output(4);
214    convolution_param->mutable_weight_filler()->set_type("gaussian");
215    convolution_param->mutable_weight_filler()->set_mean(0.0);
</span>216    convolution_param->mutable_weight_filler()->set_std(0.1);
217    layer.reset(new DeconvolutionLayer<Dtype>(layer_param));
218    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
219    filler_param.set_value(1.);
220    caffe_set(this->blob_bottom_->count(), Dtype(0), this->blob_bottom_->mutable_cpu_data());
221    caffe_set(this->blob_bottom_2_->count(), Dtype(0), this->blob_bottom_2_->mutable_cpu_data());
222    caffe_set(this->blob_top_->count(), Dtype(0), this->blob_top_->mutable_cpu_data());
223    caffe_set(this->blob_top_2_->count(), Dtype(0), this->blob_top_2_->mutable_cpu_data());
224    filler.Fill(this->blob_bottom_);
225    filler.Fill(this->blob_bottom_2_);
226    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
227    Dtype* gaussian_weight = layer->blobs()[0]->mutable_cpu_data();
228    EXPECT_EQ(layer->blobs()[0]->count(), 96);
229    top_data = this->blob_top_->cpu_data();
230    const Dtype* bottom_data = this->blob_bottom_->cpu_data();
231    for (int n = 0; n < this->blob_top_->shape()[0]; ++n) {
232      for (int c = 0; c < this->blob_top_->shape()[1]; ++c) {
233        for (int d = 0; d < this->blob_top_->shape()[2]; ++d) {
234          for (int h = 0; h < this->blob_top_->shape()[3]; ++h) {
235            for (int w = 0; w < this->blob_top_->shape()[4]; ++w) {
236              Dtype expected = 0.1;
237              for (int u = 0; u <= 1; u++) {
238                for (int v = 0; v <= 1; v++) {
239                  for (int l = 0; l <= 1; l++) {
240                    bool in_zone = ((d - u) >= 0 && (d - u) / 2 < this->blob_bottom_->shape()[2]) \
241                                && ((h - v) >= 0 && (h - v) / 2 < this->blob_bottom_->shape()[3]) \
242                                && ((w - l) >= 0 && (w - l) / 2 < this->blob_bottom_->shape()[4]);
243                    bool at_pixel = ((d - u) % 2 == 0) && ((h - v) % 2 == 0) && ((w - l) % 2 == 0);
244                    if (in_zone && at_pixel) {
245                      for (int cb = 0; cb < this->blob_bottom_->shape()[1]; cb++) {
246                        int bottom_list[] = {n, cb, (d - u) / 2, (h - v) / 2, (w - l) / 2};
247                        vector<int> bottom_offset(bottom_list, bottom_list + 5);
248                        int weight_offset = (((cb * this->blob_top_->shape()[1] + c) * 2 + u) * 2 + v) * 2 + l;
249                        expected += gaussian_weight[weight_offset] * bottom_data[this->blob_bottom_->offset(bottom_offset)];
250                      }
251                    }
252                  }
253                }
254              }
255              int off_list[] = {n, c, d, h, w};
256              vector<int> off_set(off_list, off_list + 5);
257              EXPECT_NEAR(top_data[this->blob_top_->offset(off_set)], expected, 1e-4);
258            }
259          }
260        }
261      }
262    }
263    convolution_param->clear_kernel_size();
264    convolution_param->add_kernel_size(3);
265    convolution_param->clear_stride();
266    convolution_param->add_stride(2);
267    convolution_param->clear_pad();
268    convolution_param->add_pad(1);
269    convolution_param->set_num_output(4);
270    convolution_param->mutable_weight_filler()->set_type("gaussian");
271    convolution_param->mutable_weight_filler()->set_mean(0.0);
272    convolution_param->mutable_weight_filler()->set_std(0.1);  
273    layer.reset(new DeconvolutionLayer<Dtype>(layer_param));
274    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
275    filler_param.set_value(1.);
276    caffe_set(this->blob_bottom_->count(), Dtype(0), this->blob_bottom_->mutable_cpu_data());
277    caffe_set(this->blob_bottom_2_->count(), Dtype(0), this->blob_bottom_2_->mutable_cpu_data());
278    caffe_set(this->blob_top_->count(), Dtype(0), this->blob_top_->mutable_cpu_data());
279    caffe_set(this->blob_top_2_->count(), Dtype(0), this->blob_top_2_->mutable_cpu_data());
280    filler.Fill(this->blob_bottom_);
281    filler.Fill(this->blob_bottom_2_);
282    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
283    gaussian_weight = layer->blobs()[0]->mutable_cpu_data();
284    EXPECT_EQ(layer->blobs()[0]->count(), 324);
285    top_data = this->blob_top_->cpu_data();
286    bottom_data = this->blob_bottom_->cpu_data();
287    for (int n = 0; n < this->blob_top_->shape()[0]; ++n) {
288      for (int c = 0; c < this->blob_top_->shape()[1]; ++c) {
289        for (int d = 0; d < this->blob_top_->shape()[2]; ++d) {
290          for (int h = 0; h < this->blob_top_->shape()[3]; ++h) {
291            for (int w = 0; w < this->blob_top_->shape()[4]; ++w) {
292              Dtype expected = 0.1;
293              for (int u = 0; u <= 2; u++) {
294                for (int v = 0; v <= 2; v++) {
295                  for (int l = 0; l <= 2; l++) {
296                    bool in_zone = ((d + 1 - u) >= 0 && (d + 1 - u) / 2 < this->blob_bottom_->shape()[2]) \
297                                && ((h + 1 - v) >= 0 && (h + 1 - v) / 2 < this->blob_bottom_->shape()[3]) \
298                                && ((w + 1 - l) >= 0 && (w + 1 - l) / 2 < this->blob_bottom_->shape()[4]);
299                    bool at_pixel = ((d + 1 - u) % 2 == 0) && ((h + 1 - v) % 2 == 0) && ((w + 1 - l) % 2 == 0);
300                    if (in_zone && at_pixel) {
301                      for (int cb = 0; cb < this->blob_bottom_->shape()[1]; cb++) {
302                        int bottom_list[] = {n, cb, (d + 1 - u) / 2, (h + 1 - v) / 2, (w + 1 - l) / 2};
303                        vector<int> bottom_offset(bottom_list, bottom_list + 5);
304                        int weight_offset = (((cb * this->blob_top_->shape()[1] + c) * 3 + u) * 3 + v) * 3 + l;
305                        expected += gaussian_weight[weight_offset] * bottom_data[this->blob_bottom_->offset(bottom_offset)];
306                      }
307                    }
308                  }
309                }
310              }
311              int off_list[] = {n, c, d, h, w};
312              vector<int> off_set(off_list, off_list + 5);
313              EXPECT_NEAR(top_data[this->blob_top_->offset(off_set)], expected, 1e-4);
314            }
315          }
316        }
317      }
318    }
319  }
320  TYPED_TEST(DeconvolutionLayerTest3d, TestGradient3D) {
321    typedef typename TypeParam::Dtype Dtype;
322    vector<int> bottom_shape(5);
323    bottom_shape[0] = this->blob_bottom_vec_[0]->shape(0);
324    bottom_shape[1] = this->blob_bottom_vec_[0]->shape(1);
325    bottom_shape[2] = 2;
326    bottom_shape[3] = 3;
327    bottom_shape[4] = 2;
328    FillerParameter filler_param;
329    GaussianFiller<Dtype> filler(filler_param);
330    for (int i = 0; i < this->blob_bottom_vec_.size(); ++i) {
331      this->blob_bottom_vec_[i]->Reshape(bottom_shape);
332      filler.Fill(this->blob_bottom_vec_[i]);
333    }
334    LayerParameter layer_param;
335    ConvolutionParameter* convolution_param =
336        layer_param.mutable_convolution_param();
337    convolution_param->add_kernel_size(2);
338    convolution_param->add_stride(2);
339    convolution_param->add_pad(1);
340    convolution_param->set_num_output(2);
341    convolution_param->mutable_weight_filler()->set_type("gaussian");
342    convolution_param->mutable_bias_filler()->set_type("gaussian");
343    DeconvolutionLayer<Dtype> layer(layer_param);
344    GradientChecker<Dtype> checker(1e-2, 1e-3);
345    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_, this->blob_top_vec_);
346  }
347  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-TUndirNet.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  TEST(TUndirNet, DefaultConstructor) {
4    PUndirNet Graph;
5    Graph = TUndirNet::New();
6    EXPECT_EQ(0,Graph->GetNodes());
7    EXPECT_EQ(0,Graph->GetEdges());
8    EXPECT_EQ(1,Graph->IsOk());
9    EXPECT_EQ(1,Graph->Empty());
10    EXPECT_EQ(0,Graph->HasFlag(gfDirected));
11  }
12  TEST(TUndirNet, ManipulateNodesEdges) {
13    int NNodes = 10000;
14    int NEdges = 100000;
15    const char *FName = "test.graph.dat";
16    PUndirNet Graph;
17    PUndirNet Graph1;
18    PUndirNet Graph2;
19    int i;
20    int n;
21    int NCount;
22    int LCount;
23    int x,y;
24    int Deg, InDeg, OutDeg;
25    Graph = TUndirNet::New();
26    EXPECT_EQ(1,Graph->Empty());
27    for (i = 0; i < NNodes; i++) {
28      Graph->AddNode(i);
29    }
30    EXPECT_EQ(0,Graph->Empty());
31    EXPECT_EQ(NNodes,Graph->GetNodes());
32    NCount = NEdges;
33    LCount = 0;
34    while (NCount > 0) {
35      x = (long) (drand48() * NNodes);
36      y = (long) (drand48() * NNodes);
37      if (!Graph->IsEdge(x,y)) {
38        n = Graph->AddEdge(x, y);
39        NCount--;
40        if (x == y) {
41          LCount++;
42        }
43      }
44    }
45    EXPECT_EQ(NEdges,Graph->GetEdges());
46    EXPECT_EQ(0,Graph->Empty());
47    EXPECT_EQ(1,Graph->IsOk());
48    for (i = 0; i < NNodes; i++) {
49      EXPECT_EQ(1,Graph->IsNode(i));
50    }
51    EXPECT_EQ(0,Graph->IsNode(NNodes));
52    EXPECT_EQ(0,Graph->IsNode(NNodes+1));
53    EXPECT_EQ(0,Graph->IsNode(2*NNodes));
54    NCount = 0;
55    for (TUndirNet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
56      NCount++;
57    }
58    EXPECT_EQ(NNodes,NCount);
59    NCount = 0;
60    for (TUndirNet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
61      for (int e = 0; e < NI.GetOutDeg(); e++) {
62        NCount++;
63      }
64    }
65    EXPECT_EQ(NEdges*2-LCount,NCount);
66    NCount = 0;
67    for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
68      NCount++;
69    }
70    EXPECT_EQ(NEdges,NCount);
71    for (TUndirNet::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
72      Deg = NI.GetDeg();
73      InDeg = NI.GetInDeg();
74      OutDeg = NI.GetOutDeg();
75      EXPECT_EQ(Deg,InDeg);
76      EXPECT_EQ(Deg,OutDeg);
77    }
78    Graph1 = TUndirNet::New();
79    *Graph1 = *Graph;
80    EXPECT_EQ(NNodes,Graph1->GetNodes());
81    EXPECT_EQ(NEdges,Graph1->GetEdges());
82    EXPECT_EQ(0,Graph1->Empty());
83    EXPECT_EQ(1,Graph1->IsOk());
84    {
85      TFOut FOut(FName);
86      Graph->Save(FOut);
87      FOut.Flush();
88    }
89    {
90      TFIn FIn(FName);
91      Graph2 = TUndirNet::Load(FIn);
92    }
93    EXPECT_EQ(NNodes,Graph2->GetNodes());
94    EXPECT_EQ(NEdges,Graph2->GetEdges());
95    EXPECT_EQ(0,Graph2->Empty());
96    EXPECT_EQ(1,Graph2->IsOk());
97    for (i = 0; i < NNodes; i++) {
98      n = Graph->GetRndNId();
99      Graph->DelNode(n);
<span onclick='openModal()' class='match'>100    }
101    EXPECT_EQ(0,Graph->GetNodes());
102    EXPECT_EQ(0,Graph->GetEdges());
103    EXPECT_EQ(1,Graph->IsOk());
104    EXPECT_EQ(1,Graph->Empty());
105    Graph1->Clr();
106    EXPECT_EQ(0,Graph1->GetNodes());
107    EXPECT_EQ(0,Graph1->GetEdges());
108    EXPECT_EQ(1,Graph1->IsOk());
109    EXPECT_EQ(1,Graph1->Empty());
</span>110  }
111  TEST(TUndirNet, ManipulateEdges) {
112    int Iterations = 100;
113    int NNodes;
114    int NNodesStart = 8;
115    int NNodesEnd = 25;
116    int NEdges;
117    int NEdgesStart = 0;
118    int NEdgesEnd = 50;
119    PUndirNet Graph;
120    PUndirNet Graph1;
121    PUndirNet Graph2;
122    int NCount, ECount;
123    int x,y;
124    TIntV NodeIds;
125    THashSet<TIntPr> EdgeSet;
126    TInt::Rnd.PutSeed(0);
127    for (int i = 0; i < Iterations; i++) {
128      for (NEdges = NEdgesStart; NEdges <= NEdgesEnd; NEdges++) {
129        for (NNodes = NNodesStart; NNodes <= NNodesEnd; NNodes++) {
130          if (NEdges > (NNodes * (NNodes+1)/2)) {
131            continue;
132          }
133          Graph = TUndirNet::New();
134          EXPECT_TRUE(Graph->Empty());
135          NodeIds.Gen(NNodes);
136          for (int n = 0; n < NNodes; n++) {
137            NodeIds[n] = n;
138          }
139          NodeIds.Shuffle(TInt::Rnd);
140          for (int n = 0; n < NodeIds.Len(); n++) {
141            Graph->AddNode(NodeIds[n]);
142          }
143          EXPECT_FALSE(Graph->Empty());
144          EdgeSet.Clr();
145          NCount = NEdges;
146          while (NCount > 0) {
147            x = (long) (drand48() * NNodes);
148            y = (long) (drand48() * NNodes);
149            if (!Graph->IsEdge(x,y)) {
150              Graph->AddEdge(x, y);
151              EdgeSet.AddKey(TIntPr(x, y));
152              EdgeSet.AddKey(TIntPr(y, x));
153              NCount--;
154            }
155          }
156          TIntPrV DelEdgeV;
157          for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
158            TIntPr Edge(EI.GetSrcNId(), EI.GetDstNId());
159            TIntPr EdgeR(EI.GetDstNId(), EI.GetSrcNId());
160            EXPECT_TRUE(EdgeSet.IsKey(Edge) || EdgeSet.IsKey(EdgeR));
161            if (EdgeSet.IsKey(Edge)) {
162                EdgeSet.DelKey(Edge);
163            }
164            if (EdgeSet.IsKey(EdgeR)) {
165              EdgeSet.DelKey(EdgeR);
166            }
167            DelEdgeV.Add(Edge);
168          }
169          EXPECT_TRUE(EdgeSet.Empty());
170          EXPECT_TRUE(DelEdgeV.Len() == NEdges);
171          NodeIds.Shuffle(TInt::Rnd);
172          for (int n = 0; n < NNodes; n++) {
173            TIntPrV DelEdgeNodeV;
174            int DelNodeId = NodeIds[n];
175            int EdgesBeforeDel;
176            EdgesBeforeDel = Graph->GetEdges();
177            for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
178              if (EI.GetSrcNId() == DelNodeId || EI.GetDstNId() == DelNodeId) {
179                DelEdgeNodeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
180              }
181            }
182            Graph->DelNode(DelNodeId);
183            EXPECT_TRUE(EdgesBeforeDel == DelEdgeNodeV.Len() + Graph->GetEdges());
184            EXPECT_FALSE(Graph->IsNode(DelNodeId));
185            EXPECT_TRUE(Graph->IsOk());
186            for (int e = 0; e < DelEdgeNodeV.Len(); e++) {
187              EXPECT_FALSE(Graph->IsEdge(DelEdgeNodeV[e].Val1, DelEdgeNodeV[e].Val2));
188            }
189            ECount = 0;
190            for (TUndirNet::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
191              EXPECT_FALSE(EI.GetSrcNId() == DelNodeId || EI.GetDstNId() == DelNodeId);
192              ECount++;
193            }
194            EXPECT_TRUE(ECount == Graph->GetEdges());
195          }
196          EXPECT_TRUE(0 == Graph->GetEdges());
197          Graph->Clr();
198          EXPECT_TRUE(Graph->Empty());
199        }
200      }
201    }
202  }
203  TEST(TUndirNet, GetSmallGraph) {
204    PUndirNet Graph;
205    Graph = TUndirNet::GetSmallGraph();
206    EXPECT_EQ(5,Graph->GetNodes());
207    EXPECT_EQ(5,Graph->GetEdges());
208    EXPECT_EQ(1,Graph->IsOk());
209    EXPECT_EQ(0,Graph->Empty());
210    EXPECT_EQ(0,Graph->HasFlag(gfDirected));
211  }
212  TEST(TUndirNet, AddSAttrN) {
213    PUndirNet Graph;
214    Graph = TUndirNet::New();
215    TInt AttrId;
216    int status = Graph->AddSAttrN("TestInt", atInt, AttrId);
217    EXPECT_EQ(0, status);
218    EXPECT_EQ(0, AttrId.Val);
219    status = Graph->AddSAttrN("TestFlt", atFlt, AttrId);
220    EXPECT_EQ(0, status);
221    EXPECT_EQ(1, AttrId.Val);
222    status = Graph->AddSAttrN("TestStr", atStr, AttrId);
223    EXPECT_EQ(0, status);
224    EXPECT_EQ(2, AttrId.Val);
225  }
226  TEST(TUndirNet, GetSAttrIdN) {
227    PUndirNet Graph;
228    Graph = TUndirNet::New();
229    TInt AttrId;
230    Graph->AddSAttrN("TestInt", atInt, AttrId);
231    Graph->AddSAttrN("TestFlt", atFlt, AttrId);
232    Graph->AddSAttrN("TestStr", atStr, AttrId);
233    TAttrType AttrType;
234    int status = Graph->GetSAttrIdN(TStr("TestInt"), AttrId, AttrType);
235    EXPECT_EQ(0, status);
236    EXPECT_EQ(atInt, AttrType);
237    EXPECT_EQ(0, AttrId.Val);
238    status = Graph->GetSAttrIdN(TStr("TestFlt"), AttrId, AttrType);
239    EXPECT_EQ(0, status);
240    EXPECT_EQ(atFlt, AttrType);
241    EXPECT_EQ(1, AttrId.Val);
242    status = Graph->GetSAttrIdN(TStr("TestStr"), AttrId, AttrType);
243    EXPECT_EQ(0, status);
244    EXPECT_EQ(atStr, AttrType);
245    EXPECT_EQ(2, AttrId.Val);
246    status = Graph->GetSAttrIdN(TStr("TestError"), AttrId, AttrType);
247    EXPECT_EQ(-1, status);
248  }
249  TEST(TUndirNet, GetSAttrNameN) {
250    PUndirNet Graph;
251    Graph = TUndirNet::New();
252    TInt AttrId;
253    Graph->AddSAttrN("TestInt", atInt, AttrId);
254    Graph->AddSAttrN("TestFlt", atFlt, AttrId);
255    Graph->AddSAttrN("TestStr", atStr, AttrId);
256    TAttrType AttrType;
257    TStr Name;
258    int status = Graph->GetSAttrNameN(0, Name, AttrType);
259    EXPECT_EQ(0, status);
260    EXPECT_EQ(atInt, AttrType);
261    EXPECT_STREQ("TestInt", Name.CStr());
262    status = Graph->GetSAttrNameN(1, Name, AttrType);
263    EXPECT_EQ(0, status);
264    EXPECT_EQ(atFlt, AttrType);
265    EXPECT_STREQ("TestFlt", Name.CStr());
266    status = Graph->GetSAttrNameN(2, Name, AttrType);
267    EXPECT_EQ(0, status);
268    EXPECT_EQ(atStr, AttrType);
269    EXPECT_STREQ("TestStr", Name.CStr());
270    status = Graph->GetSAttrNameN(3, Name, AttrType);
271    EXPECT_EQ(-1, status);
272  }
273  TEST(TUndirNet, AddSAttrDatN_int) {
274    PUndirNet Graph;
275    Graph = TUndirNet::New();
276    Graph->AddNode(0);
277    TInt Val(5);
278    TInt Id(0);
279    int status = Graph->AddSAttrDatN(Id, 1, Val);
280    EXPECT_EQ(-1, status);
281    TInt AttrId;
282    TStr AttrName("TestInt");
283    Graph->AddSAttrN(AttrName, atInt, AttrId);
284    TFlt ErrorVal(1);
285    status = Graph->AddSAttrDatN(Id, AttrId, ErrorVal);
286    EXPECT_EQ(-2, status);
287    status = Graph->AddSAttrDatN(Id, AttrId, Val);
288    EXPECT_EQ(0, status);
289    status = Graph->AddSAttrDatN(Id, AttrName, Val);
290    EXPECT_EQ(0, status);
291    TStr NewName("TestInt2");
292    status = Graph->AddSAttrDatN(Id, NewName, Val);
293    EXPECT_EQ(0, status);
294    TInt ErrorId(1);
295    status = Graph->AddSAttrDatN(ErrorId, AttrId, Val);
296    EXPECT_EQ(-1, status);
297  }
298  TEST(TUndirNet, AddSAttrDatN_flt) {
299    PUndirNet Graph;
300    Graph = TUndirNet::New();
301    Graph->AddNode(0);
302    TFlt Val(5.0);
303    TInt Id(0);
304    int status = Graph->AddSAttrDatN(Id, 1, Val);
305    EXPECT_EQ(-1, status);
306    TInt AttrId;
307    TStr AttrName("TestFlt");
308    Graph->AddSAttrN(AttrName, atFlt, AttrId);
309    TInt ErrorVal(1);
310    status = Graph->AddSAttrDatN(Id, AttrId, ErrorVal);
311    EXPECT_EQ(-2, status);
312    status = Graph->AddSAttrDatN(Id, AttrId, Val);
313    EXPECT_EQ(0, status);
314    status = Graph->AddSAttrDatN(Id, AttrName, Val);
315    EXPECT_EQ(0, status);
316    TStr NewName("TestFlt2");
317    status = Graph->AddSAttrDatN(Id, NewName, Val);
318    EXPECT_EQ(0, status);
319    TInt ErrorId(1);
320    status = Graph->AddSAttrDatN(ErrorId, AttrId, Val);
321    EXPECT_EQ(-1, status);
322  }
323  TEST(TUndirNet, AddSAttrDatN_str) {
324    PUndirNet Graph;
325    Graph = TUndirNet::New();
326    Graph->AddNode(0);
327    TStr Val("5");
328    TInt Id(0);
329    int status = Graph->AddSAttrDatN(Id, 1, Val);
330    EXPECT_EQ(-1, status);
331    TInt AttrId;
332    TStr AttrName("TestFlt");
333    Graph->AddSAttrN(AttrName, atStr, AttrId);
334    TInt ErrorVal(1);
335    status = Graph->AddSAttrDatN(Id, AttrId, ErrorVal);
336    EXPECT_EQ(-2, status);
337    status = Graph->AddSAttrDatN(Id, AttrId, Val);
338    EXPECT_EQ(0, status);
339    status = Graph->AddSAttrDatN(Id, AttrName, Val);
340    EXPECT_EQ(0, status);
341    TStr NewName("TestStr2");
342    status = Graph->AddSAttrDatN(Id, NewName, Val);
343    EXPECT_EQ(0, status);
344    TInt ErrorId(1);
345    status = Graph->AddSAttrDatN(ErrorId, AttrId, Val);
346    EXPECT_EQ(-1, status);
347  }
348  TEST(TUndirNet, GetSAttrDatN_int) {
349    PUndirNet Graph;
350    Graph = TUndirNet::New();
351    Graph->AddNode(0);
352    TInt Val;
353    TInt AttrId(0);
354    TStr AttrName("TestInt");
355    TInt NId(0);
356    int status = Graph->GetSAttrDatN(NId, AttrName, Val);
357    EXPECT_EQ(-1, status);
358    status = Graph->GetSAttrDatN(NId, AttrId, Val);
359    EXPECT_EQ(-1, status);
360    Graph->AddSAttrN(AttrName, atInt, AttrId);
361    TInt TestVal(5);
362    Graph->AddSAttrDatN(NId, AttrId, TestVal);
363    status = Graph->GetSAttrDatN(NId, AttrId, Val);
364    EXPECT_EQ(0, status);
365    EXPECT_EQ(TestVal.Val, Val.Val);
366    status = Graph->GetSAttrDatN(NId, AttrName, Val);
367    EXPECT_EQ(0, status);
368    EXPECT_EQ(TestVal.Val, Val.Val);
369    TInt ErrorId(1);
370    status = Graph->GetSAttrDatN(ErrorId, AttrId, Val);
371    EXPECT_EQ(-1, status);
372  }
373  TEST(TUndirNet, GetSAttrDatN_flt) {
374    PUndirNet Graph;
375    Graph = TUndirNet::New();
376    Graph->AddNode(0);
377    TFlt Val;
378    TInt AttrId(0);
379    TStr AttrName("TestInt");
380    TInt NId(0);
381    int status = Graph->GetSAttrDatN(NId, AttrName, Val);
382    EXPECT_EQ(-1, status);
383    status = Graph->GetSAttrDatN(NId, AttrId, Val);
384    EXPECT_EQ(-1, status);
385    Graph->AddSAttrN(AttrName, atFlt, AttrId);
386    TFlt TestVal(5.0);
387    Graph->AddSAttrDatN(NId, AttrId, TestVal);
388    status = Graph->GetSAttrDatN(NId, AttrId, Val);
389    EXPECT_EQ(0, status);
390    EXPECT_EQ(TestVal.Val, Val.Val);
391    status = Graph->GetSAttrDatN(NId, AttrName, Val);
392    EXPECT_EQ(0, status);
393    EXPECT_EQ(TestVal.Val, Val.Val);
394    TInt ErrorId(1);
395    status = Graph->GetSAttrDatN(ErrorId, AttrId, Val);
396    EXPECT_EQ(-1, status);
397  }
398  TEST(TUndirNet, GetSAttrDatN_str) {
399    PUndirNet Graph;
400    Graph = TUndirNet::New();
401    Graph->AddNode(0);
402    TStr Val;
403    TInt AttrId(0);
404    TStr AttrName("TestInt");
405    TInt NId(0);
406    int status = Graph->GetSAttrDatN(NId, AttrName, Val);
407    EXPECT_EQ(-1, status);
408    status = Graph->GetSAttrDatN(NId, AttrId, Val);
409    EXPECT_EQ(-1, status);
410    Graph->AddSAttrN(AttrName, atStr, AttrId);
411    TStr TestVal("5");
412    Graph->AddSAttrDatN(NId, AttrId, TestVal);
413    status = Graph->GetSAttrDatN(NId, AttrId, Val);
414    EXPECT_EQ(0, status);
415    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
416    status = Graph->GetSAttrDatN(NId, AttrName, Val);
417    EXPECT_EQ(0, status);
418    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
419    TInt ErrorId(1);
420    status = Graph->GetSAttrDatN(ErrorId, AttrId, Val);
421    EXPECT_EQ(-1, status);
422  }
423  TEST(TUndirNet, DelSAttrDatN) {
424    PUndirNet Graph;
425    Graph = TUndirNet::New();
426    Graph->AddNode(0);
427    TStr IntAttr("TestInt");
428    TInt IntId;
429    Graph->AddSAttrN(IntAttr, atInt, IntId);
430    TStr FltAttr("TestFlt");
431    TInt FltId;
432    Graph->AddSAttrN(FltAttr, atFlt, FltId);
433    TStr StrAttr("TestStr");
434    TInt StrId;
435    Graph->AddSAttrN(StrAttr, atStr, StrId);
436    TInt Id(0);
437    int status = Graph->DelSAttrDatN(Id, IntAttr);
438    EXPECT_EQ(-1, status);
439    status = Graph->DelSAttrDatN(Id, IntId);
440    EXPECT_EQ(-1, status);
441    TInt IntVal(5);
442    Graph->AddSAttrDatN(Id, IntId, IntVal);
443    status = Graph->DelSAttrDatN(Id, IntAttr);
444    EXPECT_EQ(0, status);
445    Graph->AddSAttrDatN(Id, IntId, IntVal);
446    status = Graph->DelSAttrDatN(Id, IntId);
447    EXPECT_EQ(0, status);
448    status = Graph->DelSAttrDatN(Id, IntId);
449    EXPECT_EQ(-1, status);
450    TInt ErrorId(1);
451    status = Graph->DelSAttrDatN(ErrorId, IntId);
452    EXPECT_EQ(-1, status);
453    TFlt FltVal(5.0);
454    Graph->AddSAttrDatN(Id, FltId, FltVal);
455    status = Graph->DelSAttrDatN(Id, FltAttr);
456    EXPECT_EQ(0, status);
457    Graph->AddSAttrDatN(Id, FltId, FltVal);
458    status = Graph->DelSAttrDatN(Id, FltId);
459    EXPECT_EQ(0, status);
460    status = Graph->DelSAttrDatN(Id, FltId);
461    EXPECT_EQ(-1, status);
462    status = Graph->DelSAttrDatN(ErrorId, FltId);
463    EXPECT_EQ(-1, status);
464    TStr StrVal("5");
465    Graph->AddSAttrDatN(Id, StrId, StrVal);
466    status = Graph->DelSAttrDatN(Id, StrAttr);
467    EXPECT_EQ(0, status);
468    Graph->AddSAttrDatN(Id, StrId, StrVal);
469    status = Graph->DelSAttrDatN(Id, StrId);
470    EXPECT_EQ(0, status);
471    status = Graph->DelSAttrDatN(Id, StrId);
472    EXPECT_EQ(-1, status);
473    status = Graph->DelSAttrDatN(ErrorId, StrId);
474    EXPECT_EQ(-1, status);
475  }
476  TEST(TUndirNet, GetSAttrVN) {
477    PUndirNet Graph;
478    Graph = TUndirNet::New();
479    Graph->AddNode(0);
480    TStr IntAttr("TestInt");
481    TInt IntId;
482    Graph->AddSAttrN(IntAttr, atInt, IntId);
483    TStr FltAttr("TestFlt");
484    TInt FltId;
485    Graph->AddSAttrN(FltAttr, atFlt, FltId);
486    TStr StrAttr("TestStr");
487    TInt StrId;
488    Graph->AddSAttrN(StrAttr, atStr, StrId);
489    TInt Id(0);
490    TInt IntVal(5);
491    Graph->AddSAttrDatN(Id, IntId, IntVal);
492    TFlt FltVal(5.0);
493    Graph->AddSAttrDatN(Id, FltId, FltVal);
494    TStr StrVal("5");
495    Graph->AddSAttrDatN(Id, StrId, StrVal);
496    TAttrPrV AttrV;
497    int status = Graph->GetSAttrVN(Id, atInt, AttrV);
498    EXPECT_EQ(0, status);
499    EXPECT_EQ(1, AttrV.Len());
500    status = Graph->GetSAttrVN(Id, atFlt, AttrV);
501    EXPECT_EQ(0, status);
502    EXPECT_EQ(1, AttrV.Len());
503    status = Graph->GetSAttrVN(Id, atStr, AttrV);
504    EXPECT_EQ(0, status);
505    EXPECT_EQ(1, AttrV.Len());
506  }
507  TEST(TUndirNet, GetIdVSAttrN) {
508    PUndirNet Graph;
509    Graph = TUndirNet::New();
510    TStr IntAttr("TestInt");
511    TInt IntId;
512    Graph->AddSAttrN(IntAttr, atInt, IntId);
513    TStr FltAttr("TestFlt");
514    TInt FltId;
515    Graph->AddSAttrN(FltAttr, atFlt, FltId);
516    TStr StrAttr("TestStr");
517    TInt StrId;
518    Graph->AddSAttrN(StrAttr, atStr, StrId);
519    TInt IntVal(0);
520    TFlt FltVal(0);
521    TStr StrVal("test");
522    for (int i = 0; i < 10; i++) {
523      Graph->AddNode(i);
524      TInt Id(i);
525      Graph->AddSAttrDatN(Id, IntId, IntVal);
526      if (i%2 == 0) {
527        Graph->AddSAttrDatN(Id, FltId, FltVal);
528      }
529    }
530    Graph->AddSAttrDatN(0, StrId, StrVal);
531    TIntV IdV;
532    Graph->GetIdVSAttrN(IntAttr, IdV);
533    EXPECT_EQ(10, IdV.Len());
534    Graph->GetIdVSAttrN(IntId, IdV);
535    EXPECT_EQ(10, IdV.Len());
536    Graph->GetIdVSAttrN(FltAttr, IdV);
537    EXPECT_EQ(5, IdV.Len());
538    Graph->GetIdVSAttrN(FltId, IdV);
539    EXPECT_EQ(5, IdV.Len());
540    Graph->GetIdVSAttrN(StrAttr, IdV);
541    EXPECT_EQ(1, IdV.Len());
542    Graph->GetIdVSAttrN(StrId, IdV);
543    EXPECT_EQ(1, IdV.Len());
544  }
545  TEST(TUndirNet, AddSAttrE) {
546    PUndirNet Graph;
547    Graph = TUndirNet::New();
548    TInt AttrId;
549    int status = Graph->AddSAttrE("TestInt", atInt, AttrId);
550    EXPECT_EQ(0, status);
551    EXPECT_EQ(0, AttrId.Val);
552    status = Graph->AddSAttrE("TestFlt", atFlt, AttrId);
553    EXPECT_EQ(0, status);
554    EXPECT_EQ(1, AttrId.Val);
555    status = Graph->AddSAttrE("TestStr", atStr, AttrId);
556    EXPECT_EQ(0, status);
557    EXPECT_EQ(2, AttrId.Val);
558  }
559  TEST(TUndirNet, GetSAttrIdE) {
560    PUndirNet Graph;
561    Graph = TUndirNet::New();
562    TInt AttrId;
563    Graph->AddSAttrE("TestInt", atInt, AttrId);
564    Graph->AddSAttrE("TestFlt", atFlt, AttrId);
565    Graph->AddSAttrE("TestStr", atStr, AttrId);
566    TAttrType AttrType;
567    int status = Graph->GetSAttrIdE(TStr("TestInt"), AttrId, AttrType);
568    EXPECT_EQ(0, status);
569    EXPECT_EQ(atInt, AttrType);
570    EXPECT_EQ(0, AttrId.Val);
571    status = Graph->GetSAttrIdE(TStr("TestFlt"), AttrId, AttrType);
572    EXPECT_EQ(0, status);
573    EXPECT_EQ(atFlt, AttrType);
574    EXPECT_EQ(1, AttrId.Val);
575    status = Graph->GetSAttrIdE(TStr("TestStr"), AttrId, AttrType);
576    EXPECT_EQ(0, status);
577    EXPECT_EQ(atStr, AttrType);
578    EXPECT_EQ(2, AttrId.Val);
579    status = Graph->GetSAttrIdE(TStr("TestError"), AttrId, AttrType);
580    EXPECT_EQ(-1, status);
581  }
582  TEST(TUndirNet, GetSAttrNameE) {
583    PUndirNet Graph;
584    Graph = TUndirNet::New();
585    TInt AttrId;
586    Graph->AddSAttrE("TestInt", atInt, AttrId);
587    Graph->AddSAttrE("TestFlt", atFlt, AttrId);
588    Graph->AddSAttrE("TestStr", atStr, AttrId);
589    TAttrType AttrType;
590    TStr Name;
591    int status = Graph->GetSAttrNameE(0, Name, AttrType);
592    EXPECT_EQ(0, status);
593    EXPECT_EQ(atInt, AttrType);
594    EXPECT_STREQ("TestInt", Name.CStr());
595    status = Graph->GetSAttrNameE(1, Name, AttrType);
596    EXPECT_EQ(0, status);
597    EXPECT_EQ(atFlt, AttrType);
598    EXPECT_STREQ("TestFlt", Name.CStr());
599    status = Graph->GetSAttrNameE(2, Name, AttrType);
600    EXPECT_EQ(0, status);
601    EXPECT_EQ(atStr, AttrType);
602    EXPECT_STREQ("TestStr", Name.CStr());
603    status = Graph->GetSAttrNameE(3, Name, AttrType);
604    EXPECT_EQ(-1, status);
605  }
606  TEST(TUndirNet, AddSAttrDatE_int) {
607    PUndirNet Graph;
608    Graph = TUndirNet::New();
609    Graph->AddNode(0);
610    Graph->AddNode(1);
611    Graph->AddEdge(0, 1);
612    TInt Val(5);
613    int SrcId = 0;
614    int DstId = 1;
615    int status = Graph->AddSAttrDatE(SrcId, DstId, 1, Val);
616    EXPECT_EQ(-1, status);
617    TInt AttrId;
618    TStr AttrName("TestInt");
619    Graph->AddSAttrE(AttrName, atInt, AttrId);
620    TFlt ErrorVal(1);
621    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, ErrorVal);
622    EXPECT_EQ(-2, status);
623    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, Val);
624    EXPECT_EQ(0, status);
625    status = Graph->AddSAttrDatE(SrcId, DstId, AttrName, Val);
626    EXPECT_EQ(0, status);
627    TStr NewName("TestInt2");
628    status = Graph->AddSAttrDatE(SrcId, DstId, NewName, Val);
629    EXPECT_EQ(0, status);
630    int ErrorId = 5;
631    status = Graph->AddSAttrDatE(SrcId, ErrorId, AttrId, Val);
632    EXPECT_EQ(-1, status);
633  }
634  TEST(TUndirNet, AddSAttrDatE_flt) {
635    PUndirNet Graph;
636    Graph = TUndirNet::New();
637    Graph->AddNode(0);
638    Graph->AddNode(1);
639    Graph->AddEdge(0, 1);
640    TFlt Val(5.0);
641    int SrcId = 0;
642    int DstId = 1;
643    int status = Graph->AddSAttrDatE(SrcId, DstId, 1, Val);
644    EXPECT_EQ(-1, status);
645    TInt AttrId;
646    TStr AttrName("TestFlt");
647    Graph->AddSAttrE(AttrName, atFlt, AttrId);
648    TInt ErrorVal(1);
649    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, ErrorVal);
650    EXPECT_EQ(-2, status);
651    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, Val);
652    EXPECT_EQ(0, status);
653    status = Graph->AddSAttrDatE(SrcId, DstId, AttrName, Val);
654    EXPECT_EQ(0, status);
655    TStr NewName("TestFlt2");
656    status = Graph->AddSAttrDatE(SrcId, DstId, NewName, Val);
657    EXPECT_EQ(0, status);
658    int ErrorId = 5;
659    status = Graph->AddSAttrDatE(SrcId, ErrorId, AttrId, Val);
660    EXPECT_EQ(-1, status);
661  }
662  TEST(TUndirNet, AddSAttrDatE_str) {
663    PUndirNet Graph;
664    Graph = TUndirNet::New();
665    Graph->AddNode(0);
666    Graph->AddNode(1);
667    Graph->AddEdge(0, 1);
668    TStr Val("5");
669    int SrcId = 0;
670    int DstId = 1;
671    int status = Graph->AddSAttrDatE(SrcId, DstId, 1, Val);
672    EXPECT_EQ(-1, status);
673    TInt AttrId;
674    TStr AttrName("TestFlt");
675    Graph->AddSAttrE(AttrName, atStr, AttrId);
676    TInt ErrorVal(1);
677    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, ErrorVal);
678    EXPECT_EQ(-2, status);
679    status = Graph->AddSAttrDatE(SrcId, DstId, AttrId, Val);
680    EXPECT_EQ(0, status);
681    status = Graph->AddSAttrDatE(SrcId, DstId, AttrName, Val);
682    EXPECT_EQ(0, status);
683    TStr NewName("TestStr2");
684    status = Graph->AddSAttrDatE(SrcId, DstId, NewName, Val);
685    EXPECT_EQ(0, status);
686    int ErrorId = 5;
687    status = Graph->AddSAttrDatE(SrcId, ErrorId, AttrId, Val);
688    EXPECT_EQ(-1, status);
689  }
690  TEST(TUndirNet, GetSAttrDatE_int) {
691    PUndirNet Graph;
692    Graph = TUndirNet::New();
693    Graph->AddNode(0);
694    Graph->AddNode(1);
695    Graph->AddEdge(0, 1);
696    TInt Val;
697    TInt AttrId(0);
698    TStr AttrName("TestInt");
699    int SrcId = 0;
700    int DstId = 1;
701    int status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
702    EXPECT_EQ(-1, status);
703    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
704    EXPECT_EQ(-1, status);
705    Graph->AddSAttrE(AttrName, atInt, AttrId);
706    TInt TestVal(5);
707    Graph->AddSAttrDatE(SrcId, DstId, AttrId, TestVal);
708    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
709    EXPECT_EQ(0, status);
710    EXPECT_EQ(TestVal.Val, Val.Val);
711    status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
712    EXPECT_EQ(0, status);
713    EXPECT_EQ(TestVal.Val, Val.Val);
714    int ErrorId = 5;
715    status = Graph->GetSAttrDatE(SrcId, ErrorId, AttrId, Val);
716    EXPECT_EQ(-1, status);
717  }
718  TEST(TUndirNet, GetSAttrDatE_flt) {
719    PUndirNet Graph;
720    Graph = TUndirNet::New();
721    Graph->AddNode(0);
722    Graph->AddNode(1);
723    Graph->AddEdge(0, 1);
724    TFlt Val;
725    TInt AttrId(0);
726    TStr AttrName("TestInt");
727    int SrcId = 0;
728    int DstId = 1;
729    int status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
730    EXPECT_EQ(-1, status);
731    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
732    EXPECT_EQ(-1, status);
733    Graph->AddSAttrE(AttrName, atFlt, AttrId);
734    TFlt TestVal(5.0);
735    Graph->AddSAttrDatE(SrcId, DstId, AttrId, TestVal);
736    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
737    EXPECT_EQ(0, status);
738    EXPECT_EQ(TestVal.Val, Val.Val);
739    status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
740    EXPECT_EQ(0, status);
741    EXPECT_EQ(TestVal.Val, Val.Val);
742    int ErrorId = 5;
743    status = Graph->GetSAttrDatE(SrcId, ErrorId, AttrId, Val);
744    EXPECT_EQ(-1, status);
745  }
746  TEST(TUndirNet, GetSAttrDatE_str) {
747    PUndirNet Graph;
748    Graph = TUndirNet::New();
749    Graph->AddNode(0);
750    Graph->AddNode(1);
751    Graph->AddEdge(0, 1);
752    TStr Val;
753    TInt AttrId(0);
754    TStr AttrName("TestInt");
755    int SrcId = 0;
756    int DstId = 1;
757    int status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
758    EXPECT_EQ(-1, status);
759    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
760    EXPECT_EQ(-1, status);
761    Graph->AddSAttrE(AttrName, atStr, AttrId);
762    TStr TestVal("5");
763    Graph->AddSAttrDatE(SrcId, DstId, AttrId, TestVal);
764    status = Graph->GetSAttrDatE(SrcId, DstId, AttrId, Val);
765    EXPECT_EQ(0, status);
766    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
767    status = Graph->GetSAttrDatE(SrcId, DstId, AttrName, Val);
768    EXPECT_EQ(0, status);
769    EXPECT_STREQ(TestVal.CStr(), Val.CStr());
770    int ErrorId = 5;
771    status = Graph->GetSAttrDatE(SrcId, ErrorId, AttrId, Val);
772    EXPECT_EQ(-1, status);
773  }
774  TEST(TUndirNet, DelSAttrDatE) {
775    PUndirNet Graph;
776    Graph = TUndirNet::New();
777    Graph->AddNode(0);
778    Graph->AddNode(1);
779    Graph->AddEdge(0, 1);
780    TStr IntAttr("TestInt");
781    TInt IntId;
782    Graph->AddSAttrE(IntAttr, atInt, IntId);
783    TStr FltAttr("TestFlt");
784    TInt FltId;
785    Graph->AddSAttrE(FltAttr, atFlt, FltId);
786    TStr StrAttr("TestStr");
787    TInt StrId;
788    Graph->AddSAttrE(StrAttr, atStr, StrId);
789    int SrcId = 0;
790    int DstId = 1;
791    int status = Graph->DelSAttrDatE(SrcId, DstId, IntAttr);
792    EXPECT_EQ(-1, status);
793    status = Graph->DelSAttrDatE(SrcId, DstId, IntId);
794    EXPECT_EQ(-1, status);
795    TInt IntVal(5);
796    Graph->AddSAttrDatE(SrcId, DstId, IntId, IntVal);
797    status = Graph->DelSAttrDatE(SrcId, DstId, IntAttr);
798    EXPECT_EQ(0, status);
799    Graph->AddSAttrDatE(SrcId, DstId, IntId, IntVal);
800    status = Graph->DelSAttrDatE(SrcId, DstId, IntId);
801    EXPECT_EQ(0, status);
802    status = Graph->DelSAttrDatE(SrcId, DstId, IntId);
803    EXPECT_EQ(-1, status);
804    int ErrorId = 5;
805    status = Graph->DelSAttrDatE(SrcId, ErrorId, IntId);
806    EXPECT_EQ(-1, status);
807    TFlt FltVal(5.0);
808    Graph->AddSAttrDatE(SrcId, DstId, FltId, FltVal);
809    status = Graph->DelSAttrDatE(SrcId, DstId, FltAttr);
810    EXPECT_EQ(0, status);
811    Graph->AddSAttrDatE(SrcId, DstId, FltId, FltVal);
812    status = Graph->DelSAttrDatE(SrcId, DstId, FltId);
813    EXPECT_EQ(0, status);
814    status = Graph->DelSAttrDatE(SrcId, DstId, FltId);
815    EXPECT_EQ(-1, status);
816    status = Graph->DelSAttrDatE(SrcId, ErrorId, FltId);
817    EXPECT_EQ(-1, status);
818    TStr StrVal("5");
819    Graph->AddSAttrDatE(SrcId, DstId, StrId, StrVal);
820    status = Graph->DelSAttrDatE(SrcId, DstId, StrAttr);
821    EXPECT_EQ(0, status);
822    Graph->AddSAttrDatE(SrcId, DstId, StrId, StrVal);
823    status = Graph->DelSAttrDatE(SrcId, DstId, StrId);
824    EXPECT_EQ(0, status);
825    status = Graph->DelSAttrDatE(SrcId, DstId, StrId);
826    EXPECT_EQ(-1, status);
827    status = Graph->DelSAttrDatE(SrcId, ErrorId, StrId);
828    EXPECT_EQ(-1, status);
829  }
830  TEST(TUndirNet, GetSAttrVE) {
831    PUndirNet Graph;
832    Graph = TUndirNet::New();
833    Graph->AddNode(0);
834    Graph->AddNode(1);
835    Graph->AddEdge(0, 1);
836    TStr IntAttr("TestInt");
837    TInt IntId;
838    Graph->AddSAttrE(IntAttr, atInt, IntId);
839    TStr FltAttr("TestFlt");
840    TInt FltId;
841    Graph->AddSAttrE(FltAttr, atFlt, FltId);
842    TStr StrAttr("TestStr");
843    TInt StrId;
844    Graph->AddSAttrE(StrAttr, atStr, StrId);
845    int SrcId = 0;
846    int DstId = 1;
847    TInt IntVal(5);
848    Graph->AddSAttrDatE(SrcId, DstId, IntId, IntVal);
849    TFlt FltVal(5.0);
850    Graph->AddSAttrDatE(SrcId, DstId, FltId, FltVal);
851    TStr StrVal("5");
852    Graph->AddSAttrDatE(SrcId, DstId, StrId, StrVal);
853    TAttrPrV AttrV;
854    int status = Graph->GetSAttrVE(SrcId, DstId, atInt, AttrV);
855    EXPECT_EQ(0, status);
856    EXPECT_EQ(1, AttrV.Len());
857    status = Graph->GetSAttrVE(SrcId, DstId, atFlt, AttrV);
858    EXPECT_EQ(0, status);
859    EXPECT_EQ(1, AttrV.Len());
860    status = Graph->GetSAttrVE(SrcId, DstId, atStr, AttrV);
861    EXPECT_EQ(0, status);
862    EXPECT_EQ(1, AttrV.Len());
863  }
864  TEST(TUndirNet, GetIdVSAttrE) {
865    PUndirNet Graph;
866    Graph = TUndirNet::New();
867    TStr IntAttr("TestInt");
868    TInt IntId;
869    Graph->AddSAttrE(IntAttr, atInt, IntId);
870    TStr FltAttr("TestFlt");
871    TInt FltId;
872    Graph->AddSAttrE(FltAttr, atFlt, FltId);
873    TStr StrAttr("TestStr");
874    TInt StrId;
875    Graph->AddSAttrE(StrAttr, atStr, StrId);
876    TInt IntVal(0);
877    TFlt FltVal(0);
878    TStr StrVal("test");
879    Graph->AddNode(0);
880    for (int i = 0; i < 10; i++) {
881      Graph->AddNode(i+1);
882      Graph->AddEdge(i, i+1);
883      Graph->AddSAttrDatE(i, i+1, IntId, IntVal);
884      if (i%2 == 0) {
885        Graph->AddSAttrDatE(i, i+1, FltId, FltVal);
886      }
887    }
888    Graph->AddSAttrDatE(0, 1, StrId, StrVal);
889    TIntPrV IdV;
890    Graph->GetIdVSAttrE(IntAttr, IdV);
891    EXPECT_EQ(10, IdV.Len());
892    Graph->GetIdVSAttrE(IntId, IdV);
893    EXPECT_EQ(10, IdV.Len());
894    Graph->GetIdVSAttrE(FltAttr, IdV);
895    EXPECT_EQ(5, IdV.Len());
896    Graph->GetIdVSAttrE(FltId, IdV);
897    EXPECT_EQ(5, IdV.Len());
898    Graph->GetIdVSAttrE(StrAttr, IdV);
899    EXPECT_EQ(1, IdV.Len());
900    Graph->GetIdVSAttrE(StrId, IdV);
901    EXPECT_EQ(1, IdV.Len());
902  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_deconvolution3d_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-TUndirNet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>207    }
208    convolution_param->clear_kernel_size();
209    convolution_param->add_kernel_size(2);
210    convolution_param->clear_stride();
211    convolution_param->add_stride(2);
212    convolution_param->clear_pad();
213    convolution_param->set_num_output(4);
214    convolution_param->mutable_weight_filler()->set_type("gaussian");
215    convolution_param->mutable_weight_filler()->set_mean(0.0);
</pre></code></div>
                <div class="column column_space"><pre><code>100    }
101    EXPECT_EQ(0,Graph->GetNodes());
102    EXPECT_EQ(0,Graph->GetEdges());
103    EXPECT_EQ(1,Graph->IsOk());
104    EXPECT_EQ(1,Graph->Empty());
105    Graph1->Clr();
106    EXPECT_EQ(0,Graph1->GetNodes());
107    EXPECT_EQ(0,Graph1->GetEdges());
108    EXPECT_EQ(1,Graph1->IsOk());
109    EXPECT_EQ(1,Graph1->Empty());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    