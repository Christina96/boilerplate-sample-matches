
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.0%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</h3>
            <pre><code>1  #include "absl/strings/ascii.h"
2  #include <algorithm>
3  #include <cctype>
4  #include <clocale>
5  #include <cstring>
6  #include <string>
7  #include "gtest/gtest.h"
8  #include "absl/base/macros.h"
9  #include "absl/base/port.h"
10  namespace {
11  TEST(AsciiIsFoo, All) {
12    for (int i = 0; i < 256; i++) {
13      const auto c = static_cast<unsigned char>(i);
14      if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
15        EXPECT_TRUE(absl::ascii_isalpha(c)) << ": failed on " << c;
16      else
17        EXPECT_TRUE(!absl::ascii_isalpha(c)) << ": failed on " << c;
18    }
19    for (int i = 0; i < 256; i++) {
20      const auto c = static_cast<unsigned char>(i);
21      if ((c >= '0' && c <= '9'))
22        EXPECT_TRUE(absl::ascii_isdigit(c)) << ": failed on " << c;
23      else
24        EXPECT_TRUE(!absl::ascii_isdigit(c)) << ": failed on " << c;
25    }
26    for (int i = 0; i < 256; i++) {
27      const auto c = static_cast<unsigned char>(i);
28      if (absl::ascii_isalpha(c) || absl::ascii_isdigit(c))
29        EXPECT_TRUE(absl::ascii_isalnum(c)) << ": failed on " << c;
30      else
31        EXPECT_TRUE(!absl::ascii_isalnum(c)) << ": failed on " << c;
32    }
33    for (int i = 0; i < 256; i++) {
34      const auto c = static_cast<unsigned char>(i);
35      if (i != '\0' && strchr(" \r\n\t\v\f", i))
36        EXPECT_TRUE(absl::ascii_isspace(c)) << ": failed on " << c;
37      else
38        EXPECT_TRUE(!absl::ascii_isspace(c)) << ": failed on " << c;
39    }
40    for (int i = 0; i < 256; i++) {
41      const auto c = static_cast<unsigned char>(i);
42      if (i >= 32 && i < 127)
43        EXPECT_TRUE(absl::ascii_isprint(c)) << ": failed on " << c;
44      else
45        EXPECT_TRUE(!absl::ascii_isprint(c)) << ": failed on " << c;
46    }
47    for (int i = 0; i < 256; i++) {
48      const auto c = static_cast<unsigned char>(i);
49      if (absl::ascii_isprint(c) && !absl::ascii_isspace(c) &&
50          !absl::ascii_isalnum(c)) {
51        EXPECT_TRUE(absl::ascii_ispunct(c)) << ": failed on " << c;
52      } else {
53        EXPECT_TRUE(!absl::ascii_ispunct(c)) << ": failed on " << c;
54      }
55    }
56    for (int i = 0; i < 256; i++) {
57      const auto c = static_cast<unsigned char>(i);
58      if (i == ' ' || i == '\t')
59        EXPECT_TRUE(absl::ascii_isblank(c)) << ": failed on " << c;
60      else
61        EXPECT_TRUE(!absl::ascii_isblank(c)) << ": failed on " << c;
62    }
63    for (int i = 0; i < 256; i++) {
64      const auto c = static_cast<unsigned char>(i);
65      if (i < 32 || i == 127)
66        EXPECT_TRUE(absl::ascii_iscntrl(c)) << ": failed on " << c;
67      else
68        EXPECT_TRUE(!absl::ascii_iscntrl(c)) << ": failed on " << c;
69    }
70    for (int i = 0; i < 256; i++) {
71      const auto c = static_cast<unsigned char>(i);
72      if (absl::ascii_isdigit(c) || (i >= 'A' && i <= 'F') ||
73          (i >= 'a' && i <= 'f')) {
74        EXPECT_TRUE(absl::ascii_isxdigit(c)) << ": failed on " << c;
75      } else {
76        EXPECT_TRUE(!absl::ascii_isxdigit(c)) << ": failed on " << c;
77      }
78    }
79    for (int i = 0; i < 256; i++) {
80      const auto c = static_cast<unsigned char>(i);
81      if (i > 32 && i < 127)
82        EXPECT_TRUE(absl::ascii_isgraph(c)) << ": failed on " << c;
83      else
84        EXPECT_TRUE(!absl::ascii_isgraph(c)) << ": failed on " << c;
85    }
86    for (int i = 0; i < 256; i++) {
87      const auto c = static_cast<unsigned char>(i);
88      if (i >= 'A' && i <= 'Z')
89        EXPECT_TRUE(absl::ascii_isupper(c)) << ": failed on " << c;
90      else
91        EXPECT_TRUE(!absl::ascii_isupper(c)) << ": failed on " << c;
92    }
93    for (int i = 0; i < 256; i++) {
94      const auto c = static_cast<unsigned char>(i);
95      if (i >= 'a' && i <= 'z')
96        EXPECT_TRUE(absl::ascii_islower(c)) << ": failed on " << c;
97      else
98        EXPECT_TRUE(!absl::ascii_islower(c)) << ": failed on " << c;
99    }
100    for (unsigned char c = 0; c < 128; c++) {
101      EXPECT_TRUE(absl::ascii_isascii(c)) << ": failed on " << c;
102    }
103    for (int i = 128; i < 256; i++) {
104      const auto c = static_cast<unsigned char>(i);
105      EXPECT_TRUE(!absl::ascii_isascii(c)) << ": failed on " << c;
106    }
107  }
108  TEST(AsciiIsFoo, SameAsIsFoo) {
109  #ifndef __ANDROID__
110    const char* old_locale = setlocale(LC_CTYPE, "C");
111    ASSERT_TRUE(old_locale != nullptr);
112  #endif
113    for (int i = 0; i < 256; i++) {
114      const auto c = static_cast<unsigned char>(i);
115      EXPECT_EQ(isalpha(c) != 0, absl::ascii_isalpha(c)) << c;
116      EXPECT_EQ(isdigit(c) != 0, absl::ascii_isdigit(c)) << c;
117      EXPECT_EQ(isalnum(c) != 0, absl::ascii_isalnum(c)) << c;
<span onclick='openModal()' class='match'>118      EXPECT_EQ(isspace(c) != 0, absl::ascii_isspace(c)) << c;
119      EXPECT_EQ(ispunct(c) != 0, absl::ascii_ispunct(c)) << c;
120      EXPECT_EQ(isblank(c) != 0, absl::ascii_isblank(c)) << c;
121      EXPECT_EQ(iscntrl(c) != 0, absl::ascii_iscntrl(c)) << c;
</span>122      EXPECT_EQ(isxdigit(c) != 0, absl::ascii_isxdigit(c)) << c;
123      EXPECT_EQ(isprint(c) != 0, absl::ascii_isprint(c)) << c;
124      EXPECT_EQ(isgraph(c) != 0, absl::ascii_isgraph(c)) << c;
125      EXPECT_EQ(isupper(c) != 0, absl::ascii_isupper(c)) << c;
126      EXPECT_EQ(islower(c) != 0, absl::ascii_islower(c)) << c;
127      EXPECT_EQ(isascii(c) != 0, absl::ascii_isascii(c)) << c;
128    }
129  #ifndef __ANDROID__
130    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
131  #endif
132  }
133  TEST(AsciiToFoo, All) {
134  #ifndef __ANDROID__
135    const char* old_locale = setlocale(LC_CTYPE, "C");
136    ASSERT_TRUE(old_locale != nullptr);
137  #endif
138    for (int i = 0; i < 256; i++) {
139      const auto c = static_cast<unsigned char>(i);
140      if (absl::ascii_islower(c))
141        EXPECT_EQ(absl::ascii_toupper(c), 'A' + (i - 'a')) << c;
142      else
143        EXPECT_EQ(absl::ascii_toupper(c), static_cast<char>(i)) << c;
144      if (absl::ascii_isupper(c))
145        EXPECT_EQ(absl::ascii_tolower(c), 'a' + (i - 'A')) << c;
146      else
147        EXPECT_EQ(absl::ascii_tolower(c), static_cast<char>(i)) << c;
148      EXPECT_EQ(static_cast<char>(tolower(i)), absl::ascii_tolower(c)) << c;
149      EXPECT_EQ(static_cast<char>(toupper(i)), absl::ascii_toupper(c)) << c;
150    }
151  #ifndef __ANDROID__
152    ASSERT_TRUE(setlocale(LC_CTYPE, old_locale));
153  #endif
154  }
155  TEST(AsciiStrTo, Lower) {
156    const char buf[] = "ABCDEF";
157    const std::string str("GHIJKL");
158    const std::string str2("MNOPQR");
159    const absl::string_view sp(str2);
160    std::string mutable_str("_`?@[{AMNOPQRSTUVWXYZ");
161    EXPECT_EQ("abcdef", absl::AsciiStrToLower(buf));
162    EXPECT_EQ("ghijkl", absl::AsciiStrToLower(str));
163    EXPECT_EQ("mnopqr", absl::AsciiStrToLower(sp));
164    absl::AsciiStrToLower(&mutable_str);
165    EXPECT_EQ("_`?@[{amnopqrstuvwxyz", mutable_str);
166    char mutable_buf[] = "Mutable";
167    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
168                   mutable_buf, absl::ascii_tolower);
169    EXPECT_STREQ("mutable", mutable_buf);
170  }
171  TEST(AsciiStrTo, Upper) {
172    const char buf[] = "abcdef";
173    const std::string str("ghijkl");
174    const std::string str2("_`?@[{amnopqrstuvwxyz");
175    const absl::string_view sp(str2);
176    EXPECT_EQ("ABCDEF", absl::AsciiStrToUpper(buf));
177    EXPECT_EQ("GHIJKL", absl::AsciiStrToUpper(str));
178    EXPECT_EQ("_`?@[{AMNOPQRSTUVWXYZ", absl::AsciiStrToUpper(sp));
179    char mutable_buf[] = "Mutable";
180    std::transform(mutable_buf, mutable_buf + strlen(mutable_buf),
181                   mutable_buf, absl::ascii_toupper);
182    EXPECT_STREQ("MUTABLE", mutable_buf);
183  }
184  TEST(StripLeadingAsciiWhitespace, FromStringView) {
185    EXPECT_EQ(absl::string_view{},
186              absl::StripLeadingAsciiWhitespace(absl::string_view{}));
187    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace({"foo"}));
188    EXPECT_EQ("foo", absl::StripLeadingAsciiWhitespace({"\t  \n\f\r\n\vfoo"}));
189    EXPECT_EQ("foo foo\n ",
190              absl::StripLeadingAsciiWhitespace({"\t  \n\f\r\n\vfoo foo\n "}));
191    EXPECT_EQ(absl::string_view{}, absl::StripLeadingAsciiWhitespace(
192                                       {"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
193  }
194  TEST(StripLeadingAsciiWhitespace, InPlace) {
195    std::string str;
196    absl::StripLeadingAsciiWhitespace(&str);
197    EXPECT_EQ("", str);
198    str = "foo";
199    absl::StripLeadingAsciiWhitespace(&str);
200    EXPECT_EQ("foo", str);
201    str = "\t  \n\f\r\n\vfoo";
202    absl::StripLeadingAsciiWhitespace(&str);
203    EXPECT_EQ("foo", str);
204    str = "\t  \n\f\r\n\vfoo foo\n ";
205    absl::StripLeadingAsciiWhitespace(&str);
206    EXPECT_EQ("foo foo\n ", str);
207    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
208    absl::StripLeadingAsciiWhitespace(&str);
209    EXPECT_EQ(absl::string_view{}, str);
210  }
211  TEST(StripTrailingAsciiWhitespace, FromStringView) {
212    EXPECT_EQ(absl::string_view{},
213              absl::StripTrailingAsciiWhitespace(absl::string_view{}));
214    EXPECT_EQ("foo", absl::StripTrailingAsciiWhitespace({"foo"}));
215    EXPECT_EQ("foo", absl::StripTrailingAsciiWhitespace({"foo\t  \n\f\r\n\v"}));
216    EXPECT_EQ(" \nfoo foo",
217              absl::StripTrailingAsciiWhitespace({" \nfoo foo\t  \n\f\r\n\v"}));
218    EXPECT_EQ(absl::string_view{}, absl::StripTrailingAsciiWhitespace(
219                                       {"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
220  }
221  TEST(StripTrailingAsciiWhitespace, InPlace) {
222    std::string str;
223    absl::StripTrailingAsciiWhitespace(&str);
224    EXPECT_EQ("", str);
225    str = "foo";
226    absl::StripTrailingAsciiWhitespace(&str);
227    EXPECT_EQ("foo", str);
228    str = "foo\t  \n\f\r\n\v";
229    absl::StripTrailingAsciiWhitespace(&str);
230    EXPECT_EQ("foo", str);
231    str = " \nfoo foo\t  \n\f\r\n\v";
232    absl::StripTrailingAsciiWhitespace(&str);
233    EXPECT_EQ(" \nfoo foo", str);
234    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
235    absl::StripTrailingAsciiWhitespace(&str);
236    EXPECT_EQ(absl::string_view{}, str);
237  }
238  TEST(StripAsciiWhitespace, FromStringView) {
239    EXPECT_EQ(absl::string_view{},
240              absl::StripAsciiWhitespace(absl::string_view{}));
241    EXPECT_EQ("foo", absl::StripAsciiWhitespace({"foo"}));
242    EXPECT_EQ("foo",
243              absl::StripAsciiWhitespace({"\t  \n\f\r\n\vfoo\t  \n\f\r\n\v"}));
244    EXPECT_EQ("foo foo", absl::StripAsciiWhitespace(
245                             {"\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v"}));
246    EXPECT_EQ(absl::string_view{},
247              absl::StripAsciiWhitespace({"\t  \n\f\r\v\n\t  \n\f\r\v\n"}));
248  }
249  TEST(StripAsciiWhitespace, InPlace) {
250    std::string str;
251    absl::StripAsciiWhitespace(&str);
252    EXPECT_EQ("", str);
253    str = "foo";
254    absl::StripAsciiWhitespace(&str);
255    EXPECT_EQ("foo", str);
256    str = "\t  \n\f\r\n\vfoo\t  \n\f\r\n\v";
257    absl::StripAsciiWhitespace(&str);
258    EXPECT_EQ("foo", str);
259    str = "\t  \n\f\r\n\vfoo foo\t  \n\f\r\n\v";
260    absl::StripAsciiWhitespace(&str);
261    EXPECT_EQ("foo foo", str);
262    str = "\t  \n\f\r\v\n\t  \n\f\r\v\n";
263    absl::StripAsciiWhitespace(&str);
264    EXPECT_EQ(absl::string_view{}, str);
265  }
266  TEST(RemoveExtraAsciiWhitespace, InPlace) {
267    const char* inputs[] = {"No extra space",
268                            "  Leading whitespace",
269                            "Trailing whitespace  ",
270                            "  Leading and trailing  ",
271                            " Whitespace \t  in\v   middle  ",
272                            "'Eeeeep!  \n Newlines!\n",
273                            "nospaces",
274                            "",
275                            "\n\t a\t\n\nb \t\n"};
276    const char* outputs[] = {
277        "No extra space",
278        "Leading whitespace",
279        "Trailing whitespace",
280        "Leading and trailing",
281        "Whitespace in middle",
282        "'Eeeeep! Newlines!",
283        "nospaces",
284        "",
285        "a\nb",
286    };
287    const int NUM_TESTS = ABSL_ARRAYSIZE(inputs);
288    for (int i = 0; i < NUM_TESTS; i++) {
289      std::string s(inputs[i]);
290      absl::RemoveExtraAsciiWhitespace(&s);
291      EXPECT_EQ(outputs[i], s);
292    }
293  }
294  }  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-curve25519-donna-32bit.h</h3>
            <pre><code>1  typedef uint32_t bignum25519[10];
2  typedef uint32_t bignum25519align16[12];
3  static const uint32_t reduce_mask_25 = (1 << 25) - 1;
4  static const uint32_t reduce_mask_26 = (1 << 26) - 1;
5  DONNA_INLINE static void
6  curve25519_copy(bignum25519 out, const bignum25519 in) {
7  	out[0] = in[0];
8  	out[1] = in[1];
9  	out[2] = in[2];
10  	out[3] = in[3];
11  	out[4] = in[4];
12  	out[5] = in[5];
13  	out[6] = in[6];
14  	out[7] = in[7];
15  	out[8] = in[8];
16  	out[9] = in[9];
17  }
18  DONNA_INLINE static void
19  curve25519_add(bignum25519 out, const bignum25519 a, const bignum25519 b) {
20  	out[0] = a[0] + b[0];
21  	out[1] = a[1] + b[1];
22  	out[2] = a[2] + b[2];
23  	out[3] = a[3] + b[3];
24  	out[4] = a[4] + b[4];
25  	out[5] = a[5] + b[5];
26  	out[6] = a[6] + b[6];
27  	out[7] = a[7] + b[7];
28  	out[8] = a[8] + b[8];
29  	out[9] = a[9] + b[9];
30  }
31  DONNA_INLINE static void 
32  curve25519_add_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
33  	uint32_t c;
34  	out[0] = a[0] + b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
35  	out[1] = a[1] + b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
36  	out[2] = a[2] + b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
37  	out[3] = a[3] + b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
38  	out[4] = a[4] + b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
39  	out[5] = a[5] + b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
40  	out[6] = a[6] + b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
41  	out[7] = a[7] + b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
42  	out[8] = a[8] + b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
43  	out[9] = a[9] + b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
44  	out[0] += 19 * c;
45  }
46  DONNA_INLINE static void
47  curve25519_add_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
48  	uint32_t c;
49  	out[0] = a[0] + b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
50  	out[1] = a[1] + b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
51  	out[2] = a[2] + b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
52  	out[3] = a[3] + b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
53  	out[4] = a[4] + b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
54  	out[5] = a[5] + b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
55  	out[6] = a[6] + b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
56  	out[7] = a[7] + b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
57  	out[8] = a[8] + b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
58  	out[9] = a[9] + b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
59  	out[0] += 19 * c;
60  }
61  static const uint32_t twoP0       = 0x07ffffda;
62  static const uint32_t twoP13579   = 0x03fffffe;
63  static const uint32_t twoP2468    = 0x07fffffe;
64  static const uint32_t fourP0      = 0x0fffffb4;
65  static const uint32_t fourP13579  = 0x07fffffc;
66  static const uint32_t fourP2468   = 0x0ffffffc;
67  DONNA_INLINE static void
68  curve25519_sub(bignum25519 out, const bignum25519 a, const bignum25519 b) {
69  	uint32_t c;
70  	out[0] = twoP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
71  	out[1] = twoP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
72  	out[2] = twoP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
73  	out[3] = twoP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
74  	out[4] = twoP2468  + a[4] - b[4] + c;
75  	out[5] = twoP13579 + a[5] - b[5]    ;
76  	out[6] = twoP2468  + a[6] - b[6]    ;
77  	out[7] = twoP13579 + a[7] - b[7]    ;
78  	out[8] = twoP2468  + a[8] - b[8]    ;
79  	out[9] = twoP13579 + a[9] - b[9]    ;
80  }
81  DONNA_INLINE static void
82  curve25519_sub_after_basic(bignum25519 out, const bignum25519 a, const bignum25519 b) {
83  	uint32_t c;
84  	out[0] = fourP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
85  	out[1] = fourP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
86  	out[2] = fourP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
87  	out[3] = fourP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
88  	out[4] = fourP2468  + a[4] - b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
89  	out[5] = fourP13579 + a[5] - b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
90  	out[6] = fourP2468  + a[6] - b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
91  	out[7] = fourP13579 + a[7] - b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
92  	out[8] = fourP2468  + a[8] - b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
93  	out[9] = fourP13579 + a[9] - b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
94  	out[0] += 19 * c;
95  }
96  DONNA_INLINE static void
97  curve25519_sub_reduce(bignum25519 out, const bignum25519 a, const bignum25519 b) {
98  	uint32_t c;
99  	out[0] = fourP0     + a[0] - b[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
100  	out[1] = fourP13579 + a[1] - b[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
101  	out[2] = fourP2468  + a[2] - b[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
102  	out[3] = fourP13579 + a[3] - b[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
103  	out[4] = fourP2468  + a[4] - b[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
104  	out[5] = fourP13579 + a[5] - b[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
105  	out[6] = fourP2468  + a[6] - b[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
106  	out[7] = fourP13579 + a[7] - b[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
107  	out[8] = fourP2468  + a[8] - b[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
108  	out[9] = fourP13579 + a[9] - b[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
109  	out[0] += 19 * c;
110  }
111  DONNA_INLINE static void
112  curve25519_neg(bignum25519 out, const bignum25519 a) {
113  	uint32_t c;
114  	out[0] = twoP0     - a[0]    ; c = (out[0] >> 26); out[0] &= reduce_mask_26;
115  	out[1] = twoP13579 - a[1] + c; c = (out[1] >> 25); out[1] &= reduce_mask_25;
116  	out[2] = twoP2468  - a[2] + c; c = (out[2] >> 26); out[2] &= reduce_mask_26;
117  	out[3] = twoP13579 - a[3] + c; c = (out[3] >> 25); out[3] &= reduce_mask_25;
118  	out[4] = twoP2468  - a[4] + c; c = (out[4] >> 26); out[4] &= reduce_mask_26;
119  	out[5] = twoP13579 - a[5] + c; c = (out[5] >> 25); out[5] &= reduce_mask_25;
120  	out[6] = twoP2468  - a[6] + c; c = (out[6] >> 26); out[6] &= reduce_mask_26;
121  	out[7] = twoP13579 - a[7] + c; c = (out[7] >> 25); out[7] &= reduce_mask_25;
122  	out[8] = twoP2468  - a[8] + c; c = (out[8] >> 26); out[8] &= reduce_mask_26;
123  	out[9] = twoP13579 - a[9] + c; c = (out[9] >> 25); out[9] &= reduce_mask_25;
124  	out[0] += 19 * c;
125  }
126  #define curve25519_mul_noinline curve25519_mul
127  static void
128  curve25519_mul(bignum25519 out, const bignum25519 a, const bignum25519 b) {
129  	uint32_t r0,r1,r2,r3,r4,r5,r6,r7,r8,r9;
130  	uint32_t s0,s1,s2,s3,s4,s5,s6,s7,s8,s9;
131  	uint64_t m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,c;
132  	uint32_t p;
133  	r0 = b[0];
134  	r1 = b[1];
135  	r2 = b[2];
136  	r3 = b[3];
137  	r4 = b[4];
138  	r5 = b[5];
139  	r6 = b[6];
140  	r7 = b[7];
141  	r8 = b[8];
142  	r9 = b[9];
143  	s0 = a[0];
144  	s1 = a[1];
145  	s2 = a[2];
146  	s3 = a[3];
147  	s4 = a[4];
148  	s5 = a[5];
149  	s6 = a[6];
150  	s7 = a[7];
151  	s8 = a[8];
152  	s9 = a[9];
153  	m1 = mul32x32_64(r0, s1) + mul32x32_64(r1, s0);
154  	m3 = mul32x32_64(r0, s3) + mul32x32_64(r1, s2) + mul32x32_64(r2, s1) + mul32x32_64(r3, s0);
155  	m5 = mul32x32_64(r0, s5) + mul32x32_64(r1, s4) + mul32x32_64(r2, s3) + mul32x32_64(r3, s2) + mul32x32_64(r4, s1) + mul32x32_64(r5, s0);
156  	m7 = mul32x32_64(r0, s7) + mul32x32_64(r1, s6) + mul32x32_64(r2, s5) + mul32x32_64(r3, s4) + mul32x32_64(r4, s3) + mul32x32_64(r5, s2) + mul32x32_64(r6, s1) + mul32x32_64(r7, s0);
157  	m9 = mul32x32_64(r0, s9) + mul32x32_64(r1, s8) + mul32x32_64(r2, s7) + mul32x32_64(r3, s6) + mul32x32_64(r4, s5) + mul32x32_64(r5, s4) + mul32x32_64(r6, s3) + mul32x32_64(r7, s2) + mul32x32_64(r8, s1) + mul32x32_64(r9, s0);
158  	r1 *= 2;
159  	r3 *= 2;
160  	r5 *= 2;
161  	r7 *= 2;
162  	m0 = mul32x32_64(r0, s0);
163  	m2 = mul32x32_64(r0, s2) + mul32x32_64(r1, s1) + mul32x32_64(r2, s0);
164  	m4 = mul32x32_64(r0, s4) + mul32x32_64(r1, s3) + mul32x32_64(r2, s2) + mul32x32_64(r3, s1) + mul32x32_64(r4, s0);
165  	m6 = mul32x32_64(r0, s6) + mul32x32_64(r1, s5) + mul32x32_64(r2, s4) + mul32x32_64(r3, s3) + mul32x32_64(r4, s2) + mul32x32_64(r5, s1) + mul32x32_64(r6, s0);
<span onclick='openModal()' class='match'>166  	m8 = mul32x32_64(r0, s8) + mul32x32_64(r1, s7) + mul32x32_64(r2, s6) + mul32x32_64(r3, s5) + mul32x32_64(r4, s4) + mul32x32_64(r5, s3) + mul32x32_64(r6, s2) + mul32x32_64(r7, s1) + mul32x32_64(r8, s0);
166  	m8 = mul32x32_64(r0, s8) + mul32x32_64(r1, s7) + mul32x32_64(r2, s6) + mul32x32_64(r3, s5) + mul32x32_64(r4, s4) + mul32x32_64(r5, s3) + mul32x32_64(r6, s2) + mul32x32_64(r7, s1) + mul32x32_64(r8, s0);
</span>167  	r1 *= 19;
168  	r2 *= 19;
169  	r3 = (r3 / 2) * 19;
170  	r4 *= 19;
171  	r5 = (r5 / 2) * 19;
172  	r6 *= 19;
173  	r7 = (r7 / 2) * 19;
174  	r8 *= 19;
175  	r9 *= 19;
176  	m1 += (mul32x32_64(r9, s2) + mul32x32_64(r8, s3) + mul32x32_64(r7, s4) + mul32x32_64(r6, s5) + mul32x32_64(r5, s6) + mul32x32_64(r4, s7) + mul32x32_64(r3, s8) + mul32x32_64(r2, s9));
177  	m3 += (mul32x32_64(r9, s4) + mul32x32_64(r8, s5) + mul32x32_64(r7, s6) + mul32x32_64(r6, s7) + mul32x32_64(r5, s8) + mul32x32_64(r4, s9));
178  	m5 += (mul32x32_64(r9, s6) + mul32x32_64(r8, s7) + mul32x32_64(r7, s8) + mul32x32_64(r6, s9));
179  	m7 += (mul32x32_64(r9, s8) + mul32x32_64(r8, s9));
180  	r3 *= 2;
181  	r5 *= 2;
182  	r7 *= 2;
183  	r9 *= 2;
184  	m0 += (mul32x32_64(r9, s1) + mul32x32_64(r8, s2) + mul32x32_64(r7, s3) + mul32x32_64(r6, s4) + mul32x32_64(r5, s5) + mul32x32_64(r4, s6) + mul32x32_64(r3, s7) + mul32x32_64(r2, s8) + mul32x32_64(r1, s9));
185  	m2 += (mul32x32_64(r9, s3) + mul32x32_64(r8, s4) + mul32x32_64(r7, s5) + mul32x32_64(r6, s6) + mul32x32_64(r5, s7) + mul32x32_64(r4, s8) + mul32x32_64(r3, s9));
186  	m4 += (mul32x32_64(r9, s5) + mul32x32_64(r8, s6) + mul32x32_64(r7, s7) + mul32x32_64(r6, s8) + mul32x32_64(r5, s9));
187  	m6 += (mul32x32_64(r9, s7) + mul32x32_64(r8, s8) + mul32x32_64(r7, s9));
188  	m8 += (mul32x32_64(r9, s9));
189  	                             r0 = (uint32_t)m0 & reduce_mask_26; c = (m0 >> 26);
190  	m1 += c;                     r1 = (uint32_t)m1 & reduce_mask_25; c = (m1 >> 25);
191  	m2 += c;                     r2 = (uint32_t)m2 & reduce_mask_26; c = (m2 >> 26);
192  	m3 += c;                     r3 = (uint32_t)m3 & reduce_mask_25; c = (m3 >> 25);
193  	m4 += c;                     r4 = (uint32_t)m4 & reduce_mask_26; c = (m4 >> 26);
194  	m5 += c;                     r5 = (uint32_t)m5 & reduce_mask_25; c = (m5 >> 25);
195  	m6 += c;                     r6 = (uint32_t)m6 & reduce_mask_26; c = (m6 >> 26);
196  	m7 += c;                     r7 = (uint32_t)m7 & reduce_mask_25; c = (m7 >> 25);
197  	m8 += c;                     r8 = (uint32_t)m8 & reduce_mask_26; c = (m8 >> 26);
198  	m9 += c;                     r9 = (uint32_t)m9 & reduce_mask_25; p = (uint32_t)(m9 >> 25);
199  	m0 = r0 + mul32x32_64(p,19); r0 = (uint32_t)m0 & reduce_mask_26; p = (uint32_t)(m0 >> 26);
200  	r1 += p;
201  	out[0] = r0;
202  	out[1] = r1;
203  	out[2] = r2;
204  	out[3] = r3;
205  	out[4] = r4;
206  	out[5] = r5;
207  	out[6] = r6;
208  	out[7] = r7;
209  	out[8] = r8;
210  	out[9] = r9;
211  }
212  static void
213  curve25519_square(bignum25519 out, const bignum25519 in) {
214  	uint32_t r0,r1,r2,r3,r4,r5,r6,r7,r8,r9;
215  	uint32_t d6,d7,d8,d9;
216  	uint64_t m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,c;
217  	uint32_t p;
218  	r0 = in[0];
219  	r1 = in[1];
220  	r2 = in[2];
221  	r3 = in[3];
222  	r4 = in[4];
223  	r5 = in[5];
224  	r6 = in[6];
225  	r7 = in[7];
226  	r8 = in[8];
227  	r9 = in[9];
228  	m0 = mul32x32_64(r0, r0);
229  	r0 *= 2;
230  	m1 = mul32x32_64(r0, r1);
231  	m2 = mul32x32_64(r0, r2) + mul32x32_64(r1, r1 * 2);
232  	r1 *= 2;
233  	m3 = mul32x32_64(r0, r3) + mul32x32_64(r1, r2    );
234  	m4 = mul32x32_64(r0, r4) + mul32x32_64(r1, r3 * 2) + mul32x32_64(r2, r2);
235  	r2 *= 2;
236  	m5 = mul32x32_64(r0, r5) + mul32x32_64(r1, r4    ) + mul32x32_64(r2, r3);
237  	m6 = mul32x32_64(r0, r6) + mul32x32_64(r1, r5 * 2) + mul32x32_64(r2, r4) + mul32x32_64(r3, r3 * 2);
238  	r3 *= 2;
239  	m7 = mul32x32_64(r0, r7) + mul32x32_64(r1, r6    ) + mul32x32_64(r2, r5) + mul32x32_64(r3, r4    );
240  	m8 = mul32x32_64(r0, r8) + mul32x32_64(r1, r7 * 2) + mul32x32_64(r2, r6) + mul32x32_64(r3, r5 * 2) + mul32x32_64(r4, r4    );
241  	m9 = mul32x32_64(r0, r9) + mul32x32_64(r1, r8    ) + mul32x32_64(r2, r7) + mul32x32_64(r3, r6    ) + mul32x32_64(r4, r5 * 2);
242  	d6 = r6 * 19;
243  	d7 = r7 * 2 * 19;
244  	d8 = r8 * 19;
245  	d9 = r9 * 2 * 19;
246  	m0 += (mul32x32_64(d9, r1    ) + mul32x32_64(d8, r2    ) + mul32x32_64(d7, r3    ) + mul32x32_64(d6, r4 * 2) + mul32x32_64(r5, r5 * 2 * 19));
247  	m1 += (mul32x32_64(d9, r2 / 2) + mul32x32_64(d8, r3    ) + mul32x32_64(d7, r4    ) + mul32x32_64(d6, r5 * 2));
248  	m2 += (mul32x32_64(d9, r3    ) + mul32x32_64(d8, r4 * 2) + mul32x32_64(d7, r5 * 2) + mul32x32_64(d6, r6    ));
249  	m3 += (mul32x32_64(d9, r4    ) + mul32x32_64(d8, r5 * 2) + mul32x32_64(d7, r6    ));
250  	m4 += (mul32x32_64(d9, r5 * 2) + mul32x32_64(d8, r6 * 2) + mul32x32_64(d7, r7    ));
251  	m5 += (mul32x32_64(d9, r6    ) + mul32x32_64(d8, r7 * 2));
252  	m6 += (mul32x32_64(d9, r7 * 2) + mul32x32_64(d8, r8    ));
253  	m7 += (mul32x32_64(d9, r8    ));
254  	m8 += (mul32x32_64(d9, r9    ));
255  	                             r0 = (uint32_t)m0 & reduce_mask_26; c = (m0 >> 26);
256  	m1 += c;                     r1 = (uint32_t)m1 & reduce_mask_25; c = (m1 >> 25);
257  	m2 += c;                     r2 = (uint32_t)m2 & reduce_mask_26; c = (m2 >> 26);
258  	m3 += c;                     r3 = (uint32_t)m3 & reduce_mask_25; c = (m3 >> 25);
259  	m4 += c;                     r4 = (uint32_t)m4 & reduce_mask_26; c = (m4 >> 26);
260  	m5 += c;                     r5 = (uint32_t)m5 & reduce_mask_25; c = (m5 >> 25);
261  	m6 += c;                     r6 = (uint32_t)m6 & reduce_mask_26; c = (m6 >> 26);
262  	m7 += c;                     r7 = (uint32_t)m7 & reduce_mask_25; c = (m7 >> 25);
263  	m8 += c;                     r8 = (uint32_t)m8 & reduce_mask_26; c = (m8 >> 26);
264  	m9 += c;                     r9 = (uint32_t)m9 & reduce_mask_25; p = (uint32_t)(m9 >> 25);
265  	m0 = r0 + mul32x32_64(p,19); r0 = (uint32_t)m0 & reduce_mask_26; p = (uint32_t)(m0 >> 26);
266  	r1 += p;
267  	out[0] = r0;
268  	out[1] = r1;
269  	out[2] = r2;
270  	out[3] = r3;
271  	out[4] = r4;
272  	out[5] = r5;
273  	out[6] = r6;
274  	out[7] = r7;
275  	out[8] = r8;
276  	out[9] = r9;
277  }
278  static void
279  curve25519_square_times(bignum25519 out, const bignum25519 in, int count) {
280  	uint32_t r0,r1,r2,r3,r4,r5,r6,r7,r8,r9;
281  	uint32_t d6,d7,d8,d9;
282  	uint64_t m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,c;
283  	uint32_t p;
284  	r0 = in[0];
285  	r1 = in[1];
286  	r2 = in[2];
287  	r3 = in[3];
288  	r4 = in[4];
289  	r5 = in[5];
290  	r6 = in[6];
291  	r7 = in[7];
292  	r8 = in[8];
293  	r9 = in[9];
294  	do {
295  		m0 = mul32x32_64(r0, r0);
296  		r0 *= 2;
297  		m1 = mul32x32_64(r0, r1);
298  		m2 = mul32x32_64(r0, r2) + mul32x32_64(r1, r1 * 2);
299  		r1 *= 2;
300  		m3 = mul32x32_64(r0, r3) + mul32x32_64(r1, r2    );
301  		m4 = mul32x32_64(r0, r4) + mul32x32_64(r1, r3 * 2) + mul32x32_64(r2, r2);
302  		r2 *= 2;
303  		m5 = mul32x32_64(r0, r5) + mul32x32_64(r1, r4    ) + mul32x32_64(r2, r3);
304  		m6 = mul32x32_64(r0, r6) + mul32x32_64(r1, r5 * 2) + mul32x32_64(r2, r4) + mul32x32_64(r3, r3 * 2);
305  		r3 *= 2;
306  		m7 = mul32x32_64(r0, r7) + mul32x32_64(r1, r6    ) + mul32x32_64(r2, r5) + mul32x32_64(r3, r4    );
307  		m8 = mul32x32_64(r0, r8) + mul32x32_64(r1, r7 * 2) + mul32x32_64(r2, r6) + mul32x32_64(r3, r5 * 2) + mul32x32_64(r4, r4    );
308  		m9 = mul32x32_64(r0, r9) + mul32x32_64(r1, r8    ) + mul32x32_64(r2, r7) + mul32x32_64(r3, r6    ) + mul32x32_64(r4, r5 * 2);
309  		d6 = r6 * 19;
310  		d7 = r7 * 2 * 19;
311  		d8 = r8 * 19;
312  		d9 = r9 * 2 * 19;
313  		m0 += (mul32x32_64(d9, r1    ) + mul32x32_64(d8, r2    ) + mul32x32_64(d7, r3    ) + mul32x32_64(d6, r4 * 2) + mul32x32_64(r5, r5 * 2 * 19));
314  		m1 += (mul32x32_64(d9, r2 / 2) + mul32x32_64(d8, r3    ) + mul32x32_64(d7, r4    ) + mul32x32_64(d6, r5 * 2));
315  		m2 += (mul32x32_64(d9, r3    ) + mul32x32_64(d8, r4 * 2) + mul32x32_64(d7, r5 * 2) + mul32x32_64(d6, r6    ));
316  		m3 += (mul32x32_64(d9, r4    ) + mul32x32_64(d8, r5 * 2) + mul32x32_64(d7, r6    ));
317  		m4 += (mul32x32_64(d9, r5 * 2) + mul32x32_64(d8, r6 * 2) + mul32x32_64(d7, r7    ));
318  		m5 += (mul32x32_64(d9, r6    ) + mul32x32_64(d8, r7 * 2));
319  		m6 += (mul32x32_64(d9, r7 * 2) + mul32x32_64(d8, r8    ));
320  		m7 += (mul32x32_64(d9, r8    ));
321  		m8 += (mul32x32_64(d9, r9    ));
322  		                             r0 = (uint32_t)m0 & reduce_mask_26; c = (m0 >> 26);
323  		m1 += c;                     r1 = (uint32_t)m1 & reduce_mask_25; c = (m1 >> 25);
324  		m2 += c;                     r2 = (uint32_t)m2 & reduce_mask_26; c = (m2 >> 26);
325  		m3 += c;                     r3 = (uint32_t)m3 & reduce_mask_25; c = (m3 >> 25);
326  		m4 += c;                     r4 = (uint32_t)m4 & reduce_mask_26; c = (m4 >> 26);
327  		m5 += c;                     r5 = (uint32_t)m5 & reduce_mask_25; c = (m5 >> 25);
328  		m6 += c;                     r6 = (uint32_t)m6 & reduce_mask_26; c = (m6 >> 26);
329  		m7 += c;                     r7 = (uint32_t)m7 & reduce_mask_25; c = (m7 >> 25);
330  		m8 += c;                     r8 = (uint32_t)m8 & reduce_mask_26; c = (m8 >> 26);
331  		m9 += c;                     r9 = (uint32_t)m9 & reduce_mask_25; p = (uint32_t)(m9 >> 25);
332  		m0 = r0 + mul32x32_64(p,19); r0 = (uint32_t)m0 & reduce_mask_26; p = (uint32_t)(m0 >> 26);
333  		r1 += p;
334  	} while (--count);
335  	out[0] = r0;
336  	out[1] = r1;
337  	out[2] = r2;
338  	out[3] = r3;
339  	out[4] = r4;
340  	out[5] = r5;
341  	out[6] = r6;
342  	out[7] = r7;
343  	out[8] = r8;
344  	out[9] = r9;
345  }
346  static void
347  curve25519_expand(bignum25519 out, const unsigned char in[32]) {
348  	static const union { uint8_t b[2]; uint16_t s; } endian_check = {{1,0}};
349  	uint32_t x0,x1,x2,x3,x4,x5,x6,x7;
350  	if (endian_check.s == 1) {
351  		x0 = *(uint32_t *)(in + 0);
352  		x1 = *(uint32_t *)(in + 4);
353  		x2 = *(uint32_t *)(in + 8);
354  		x3 = *(uint32_t *)(in + 12);
355  		x4 = *(uint32_t *)(in + 16);
356  		x5 = *(uint32_t *)(in + 20);
357  		x6 = *(uint32_t *)(in + 24);
358  		x7 = *(uint32_t *)(in + 28);
359      } else {
360  		#define F(s)                         \
361  			((((uint32_t)in[s + 0])      ) | \
362  			 (((uint32_t)in[s + 1]) <<  8) | \
363  			 (((uint32_t)in[s + 2]) << 16) | \
364  			 (((uint32_t)in[s + 3]) << 24))
365  		x0 = F(0);
366  		x1 = F(4);
367  		x2 = F(8);
368  		x3 = F(12);
369  		x4 = F(16);
370  		x5 = F(20);
371  		x6 = F(24);
372  		x7 = F(28);
373  		#undef F
374  	}
375  	out[0] = (                        x0       ) & 0x3ffffff;
376  	out[1] = ((((uint64_t)x1 << 32) | x0) >> 26) & 0x1ffffff;
377  	out[2] = ((((uint64_t)x2 << 32) | x1) >> 19) & 0x3ffffff;
378  	out[3] = ((((uint64_t)x3 << 32) | x2) >> 13) & 0x1ffffff;
379  	out[4] = ((                       x3) >>  6) & 0x3ffffff;
380  	out[5] = (                        x4       ) & 0x1ffffff;
381  	out[6] = ((((uint64_t)x5 << 32) | x4) >> 25) & 0x3ffffff;
382  	out[7] = ((((uint64_t)x6 << 32) | x5) >> 19) & 0x1ffffff;
383  	out[8] = ((((uint64_t)x7 << 32) | x6) >> 12) & 0x3ffffff;
384  	out[9] = ((                       x7) >>  6) & 0x1ffffff;
385  }
386  static void
387  curve25519_contract(unsigned char out[32], const bignum25519 in) {
388  	bignum25519 f;
389  	curve25519_copy(f, in);
390  	#define carry_pass() \
391  		f[1] += f[0] >> 26; f[0] &= reduce_mask_26; \
392  		f[2] += f[1] >> 25; f[1] &= reduce_mask_25; \
393  		f[3] += f[2] >> 26; f[2] &= reduce_mask_26; \
394  		f[4] += f[3] >> 25; f[3] &= reduce_mask_25; \
395  		f[5] += f[4] >> 26; f[4] &= reduce_mask_26; \
396  		f[6] += f[5] >> 25; f[5] &= reduce_mask_25; \
397  		f[7] += f[6] >> 26; f[6] &= reduce_mask_26; \
398  		f[8] += f[7] >> 25; f[7] &= reduce_mask_25; \
399  		f[9] += f[8] >> 26; f[8] &= reduce_mask_26;
400  	#define carry_pass_full() \
401  		carry_pass() \
402  		f[0] += 19 * (f[9] >> 25); f[9] &= reduce_mask_25;
403  	#define carry_pass_final() \
404  		carry_pass() \
405  		f[9] &= reduce_mask_25;
406  	carry_pass_full()
407  	carry_pass_full()
408  	f[0] += 19;
409  	carry_pass_full()
410  	f[0] += (reduce_mask_26 + 1) - 19;
411  	f[1] += (reduce_mask_25 + 1) - 1;
412  	f[2] += (reduce_mask_26 + 1) - 1;
413  	f[3] += (reduce_mask_25 + 1) - 1;
414  	f[4] += (reduce_mask_26 + 1) - 1;
415  	f[5] += (reduce_mask_25 + 1) - 1;
416  	f[6] += (reduce_mask_26 + 1) - 1;
417  	f[7] += (reduce_mask_25 + 1) - 1;
418  	f[8] += (reduce_mask_26 + 1) - 1;
419  	f[9] += (reduce_mask_25 + 1) - 1;
420  	carry_pass_final()
421  	#undef carry_pass
422  	#undef carry_full
423  	#undef carry_final
424  	f[1] <<= 2;
425  	f[2] <<= 3;
426  	f[3] <<= 5;
427  	f[4] <<= 6;
428  	f[6] <<= 1;
429  	f[7] <<= 3;
430  	f[8] <<= 4;
431  	f[9] <<= 6;
432  	#define F(i, s) \
433  		out[s+0] |= (unsigned char )(f[i] & 0xff); \
434  		out[s+1] = (unsigned char )((f[i] >> 8) & 0xff); \
435  		out[s+2] = (unsigned char )((f[i] >> 16) & 0xff); \
436  		out[s+3] = (unsigned char )((f[i] >> 24) & 0xff);
437  	out[0] = 0;
438  	out[16] = 0;
439  	F(0,0);
440  	F(1,3);
441  	F(2,6);
442  	F(3,9);
443  	F(4,12);
444  	F(5,16);
445  	F(6,19);
446  	F(7,22);
447  	F(8,25);
448  	F(9,28);
449  	#undef F
450  }
451  DONNA_INLINE static void
452  curve25519_move_conditional_bytes(uint8_t out[96], const uint8_t in[96], uint32_t flag) {
453  	const uint32_t nb = flag - 1, b = ~nb;
454  	const uint32_t *inl = (const uint32_t *)in;
455  	uint32_t *outl = (uint32_t *)out;
456  	outl[0] = (outl[0] & nb) | (inl[0] & b);
457  	outl[1] = (outl[1] & nb) | (inl[1] & b);
458  	outl[2] = (outl[2] & nb) | (inl[2] & b);
459  	outl[3] = (outl[3] & nb) | (inl[3] & b);
460  	outl[4] = (outl[4] & nb) | (inl[4] & b);
461  	outl[5] = (outl[5] & nb) | (inl[5] & b);
462  	outl[6] = (outl[6] & nb) | (inl[6] & b);
463  	outl[7] = (outl[7] & nb) | (inl[7] & b);
464  	outl[8] = (outl[8] & nb) | (inl[8] & b);
465  	outl[9] = (outl[9] & nb) | (inl[9] & b);
466  	outl[10] = (outl[10] & nb) | (inl[10] & b);
467  	outl[11] = (outl[11] & nb) | (inl[11] & b);
468  	outl[12] = (outl[12] & nb) | (inl[12] & b);
469  	outl[13] = (outl[13] & nb) | (inl[13] & b);
470  	outl[14] = (outl[14] & nb) | (inl[14] & b);
471  	outl[15] = (outl[15] & nb) | (inl[15] & b);
472  	outl[16] = (outl[16] & nb) | (inl[16] & b);
473  	outl[17] = (outl[17] & nb) | (inl[17] & b);
474  	outl[18] = (outl[18] & nb) | (inl[18] & b);
475  	outl[19] = (outl[19] & nb) | (inl[19] & b);
476  	outl[20] = (outl[20] & nb) | (inl[20] & b);
477  	outl[21] = (outl[21] & nb) | (inl[21] & b);
478  	outl[22] = (outl[22] & nb) | (inl[22] & b);
479  	outl[23] = (outl[23] & nb) | (inl[23] & b);
480  }
481  DONNA_INLINE static void
482  curve25519_swap_conditional(bignum25519 a, bignum25519 b, uint32_t iswap) {
483  	const uint32_t swap = (uint32_t)(-(int32_t)iswap);
484  	uint32_t x0,x1,x2,x3,x4,x5,x6,x7,x8,x9;
485  	x0 = swap & (a[0] ^ b[0]); a[0] ^= x0; b[0] ^= x0;
486  	x1 = swap & (a[1] ^ b[1]); a[1] ^= x1; b[1] ^= x1;
487  	x2 = swap & (a[2] ^ b[2]); a[2] ^= x2; b[2] ^= x2;
488  	x3 = swap & (a[3] ^ b[3]); a[3] ^= x3; b[3] ^= x3;
489  	x4 = swap & (a[4] ^ b[4]); a[4] ^= x4; b[4] ^= x4;
490  	x5 = swap & (a[5] ^ b[5]); a[5] ^= x5; b[5] ^= x5;
491  	x6 = swap & (a[6] ^ b[6]); a[6] ^= x6; b[6] ^= x6;
492  	x7 = swap & (a[7] ^ b[7]); a[7] ^= x7; b[7] ^= x7;
493  	x8 = swap & (a[8] ^ b[8]); a[8] ^= x8; b[8] ^= x8;
494  	x9 = swap & (a[9] ^ b[9]); a[9] ^= x9; b[9] ^= x9;
495  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-ascii_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-curve25519-donna-32bit.h</div>
                </div>
                <div class="column column_space"><pre><code>118      EXPECT_EQ(isspace(c) != 0, absl::ascii_isspace(c)) << c;
119      EXPECT_EQ(ispunct(c) != 0, absl::ascii_ispunct(c)) << c;
120      EXPECT_EQ(isblank(c) != 0, absl::ascii_isblank(c)) << c;
121      EXPECT_EQ(iscntrl(c) != 0, absl::ascii_iscntrl(c)) << c;
</pre></code></div>
                <div class="column column_space"><pre><code>166  	m8 = mul32x32_64(r0, s8) + mul32x32_64(r1, s7) + mul32x32_64(r2, s6) + mul32x32_64(r3, s5) + mul32x32_64(r4, s4) + mul32x32_64(r5, s3) + mul32x32_64(r6, s2) + mul32x32_64(r7, s1) + mul32x32_64(r8, s0);
166  	m8 = mul32x32_64(r0, s8) + mul32x32_64(r1, s7) + mul32x32_64(r2, s6) + mul32x32_64(r3, s5) + mul32x32_64(r4, s4) + mul32x32_64(r5, s3) + mul32x32_64(r6, s2) + mul32x32_64(r7, s1) + mul32x32_64(r8, s0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    