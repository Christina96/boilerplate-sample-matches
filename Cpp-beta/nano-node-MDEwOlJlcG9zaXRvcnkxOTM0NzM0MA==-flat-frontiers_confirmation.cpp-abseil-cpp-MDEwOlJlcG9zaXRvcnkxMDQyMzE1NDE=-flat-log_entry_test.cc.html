
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.723926380368098%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-frontiers_confirmation.cpp</h3>
            <pre><code>1  #include <nano/node/active_transactions.hpp>
2  #include <nano/test_common/system.hpp>
3  #include <nano/test_common/testutil.hpp>
4  #include <gtest/gtest.h>
5  using namespace std::chrono_literals;
6  TEST (frontiers_confirmation, mode)
7  {
8  	nano::keypair key;
9  	nano::block_builder builder;
10  	nano::node_flags node_flags;
11  	{
12  		nano::test::system system;
13  		nano::node_config node_config = system.default_config ();
14  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::always;
15  		auto node = system.add_node (node_config, node_flags);
16  		auto send = builder
17  					.state ()
18  					.account (nano::dev::genesis_key.pub)
19  					.previous (nano::dev::genesis->hash ())
20  					.representative (nano::dev::genesis_key.pub)
21  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
22  					.link (key.pub)
23  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
24  					.work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
25  					.build ();
26  		{
27  			auto transaction = node->store.tx_begin_write ();
28  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
29  		}
30  		ASSERT_TIMELY (5s, node->active.size () == 1);
31  	}
32  	{
33  		nano::test::system system;
34  		nano::node_config node_config = system.default_config ();
35  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::automatic;
36  		auto node = system.add_node (node_config, node_flags);
<span onclick='openModal()' class='match'>37  		auto send = builder
38  					.state ()
39  					.account (nano::dev::genesis_key.pub)
40  					.previous (nano::dev::genesis->hash ())
41  					.representative (nano::dev::genesis_key.pub)
42  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
43  					.link (key.pub)
44  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
45  					.work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
</span>46  					.build ();
47  		{
48  			auto transaction = node->store.tx_begin_write ();
49  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
50  		}
51  		ASSERT_TIMELY (5s, node->active.size () == 1);
52  	}
53  	{
54  		nano::test::system system;
55  		nano::node_config node_config = system.default_config ();
56  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
57  		auto node = system.add_node (node_config, node_flags);
58  		auto send = builder
59  					.state ()
60  					.account (nano::dev::genesis_key.pub)
61  					.previous (nano::dev::genesis->hash ())
62  					.representative (nano::dev::genesis_key.pub)
63  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
64  					.link (key.pub)
65  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
66  					.work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
67  					.build ();
68  		{
69  			auto transaction = node->store.tx_begin_write ();
70  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
71  		}
72  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
73  		std::this_thread::sleep_for (std::chrono::seconds (1));
74  		ASSERT_EQ (0, node->active.size ());
75  	}
76  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_entry_test.cc</h3>
            <pre><code>1  #include "absl/log/log_entry.h"
2  #include <stddef.h>
3  #include <stdint.h>
4  #include <cstring>
5  #include <limits>
6  #include <string>
7  #include <type_traits>
8  #include <utility>
9  #include <vector>
10  #include "gmock/gmock.h"
11  #include "gtest/gtest.h"
12  #include "absl/base/attributes.h"
13  #include "absl/base/config.h"
14  #include "absl/base/log_severity.h"
15  #include "absl/log/internal/append_truncated.h"
16  #include "absl/log/internal/log_format.h"
17  #include "absl/log/internal/test_helpers.h"
18  #include "absl/strings/numbers.h"
19  #include "absl/strings/str_split.h"
20  #include "absl/strings/string_view.h"
21  #include "absl/time/civil_time.h"
22  #include "absl/time/time.h"
23  #include "absl/types/span.h"
24  namespace {
25  using ::absl::log_internal::LogEntryTestPeer;
26  using ::testing::Eq;
27  using ::testing::IsTrue;
28  using ::testing::StartsWith;
29  using ::testing::StrEq;
30  auto* test_env ABSL_ATTRIBUTE_UNUSED = ::testing::AddGlobalTestEnvironment(
31      new absl::log_internal::LogTestEnvironment);
32  }  
33  namespace absl {
34  ABSL_NAMESPACE_BEGIN
35  namespace log_internal {
36  class LogEntryTestPeer {
37   public:
38    LogEntryTestPeer(absl::string_view base_filename, int line, bool prefix,
39                     absl::LogSeverity severity, absl::string_view timestamp,
40                     absl::LogEntry::tid_t tid, PrefixFormat format,
41                     absl::string_view text_message)
42        : format_{format}, buf_(15000, '\0') {
43      entry_.base_filename_ = base_filename;
44      entry_.line_ = line;
45      entry_.prefix_ = prefix;
46      entry_.severity_ = severity;
47      std::string time_err;
48      EXPECT_THAT(
49          absl::ParseTime("%Y-%m-%d%ET%H:%M:%E*S", timestamp,
50                          absl::LocalTimeZone(), &entry_.timestamp_, &time_err),
51          IsTrue())
52          << "Failed to parse time " << timestamp << ": " << time_err;
53      entry_.tid_ = tid;
54      std::pair<absl::string_view, std::string> timestamp_bits =
55          absl::StrSplit(timestamp, absl::ByChar('.'));
56      EXPECT_THAT(absl::ParseCivilTime(timestamp_bits.first, &ci_.cs), IsTrue())
57          << "Failed to parse time " << timestamp_bits.first;
58      timestamp_bits.second.resize(9, '0');
59      int64_t nanos = 0;
60      EXPECT_THAT(absl::SimpleAtoi(timestamp_bits.second, &nanos), IsTrue())
61          << "Failed to parse time " << timestamp_bits.first;
62      ci_.subsecond = absl::Nanoseconds(nanos);
63      absl::Span<char> view = absl::MakeSpan(buf_);
64      view.remove_suffix(2);
65      entry_.prefix_len_ =
66          entry_.prefix_
67              ? log_internal::FormatLogPrefix(
68                    entry_.log_severity(), entry_.timestamp(), entry_.tid(),
69                    entry_.source_basename(), entry_.source_line(), format_, view)
70              : 0;
71      EXPECT_THAT(entry_.prefix_len_,
72                  Eq(static_cast<size_t>(view.data() - buf_.data())));
73      log_internal::AppendTruncated(text_message, view);
74      view = absl::Span<char>(view.data(), view.size() + 2);
75      view[0] = '\n';
76      view[1] = '\0';
77      view.remove_prefix(2);
78      buf_.resize(static_cast<size_t>(view.data() - buf_.data()));
79      entry_.text_message_with_prefix_and_newline_and_nul_ = absl::MakeSpan(buf_);
80    }
81    LogEntryTestPeer(const LogEntryTestPeer&) = delete;
82    LogEntryTestPeer& operator=(const LogEntryTestPeer&) = delete;
83    std::string FormatLogMessage() const {
84      return log_internal::FormatLogMessage(
85          entry_.log_severity(), ci_.cs, ci_.subsecond, entry_.tid(),
86          entry_.source_basename(), entry_.source_line(), format_,
87          entry_.text_message());
88    }
89    std::string FormatPrefixIntoSizedBuffer(size_t sz) {
90      std::string str(sz, '\0');
91      absl::Span<char> buf(&str[0], str.size());
92      const size_t prefix_size = log_internal::FormatLogPrefix(
93          entry_.log_severity(), entry_.timestamp(), entry_.tid(),
94          entry_.source_basename(), entry_.source_line(), format_, buf);
95      EXPECT_THAT(prefix_size, Eq(static_cast<size_t>(buf.data() - str.data())));
96      str.resize(prefix_size);
97      return str;
98    }
99    const absl::LogEntry& entry() const { return entry_; }
100   private:
101    absl::LogEntry entry_;
102    PrefixFormat format_;
103    absl::TimeZone::CivilInfo ci_;
104    std::vector<char> buf_;
105  };
106  }  
107  ABSL_NAMESPACE_END
108  }  
109  namespace {
110  constexpr bool kUsePrefix = true, kNoPrefix = false;
111  TEST(LogEntryTest, Baseline) {
112    LogEntryTestPeer entry("foo.cc", 1234, kUsePrefix, absl::LogSeverity::kInfo,
113                           "2020-01-02T03:04:05.6789", 451,
114                           absl::log_internal::PrefixFormat::kNotRaw,
115                           "hello world");
116    EXPECT_THAT(entry.FormatLogMessage(),
117                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world"));
118    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
119                Eq("I0102 03:04:05.678900     451 foo.cc:1234] "));
120    for (size_t sz = strlen("I0102 03:04:05.678900     451 foo.cc:1234] ") + 20;
121         sz != std::numeric_limits<size_t>::max(); sz--)
122      EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:1234] ",
123                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
124    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
125                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world\n"));
126    EXPECT_THAT(
127        entry.entry().text_message_with_prefix_and_newline_c_str(),
128        StrEq("I0102 03:04:05.678900     451 foo.cc:1234] hello world\n"));
129    EXPECT_THAT(entry.entry().text_message_with_prefix(),
130                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world"));
131    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
132  }
133  TEST(LogEntryTest, NoPrefix) {
134    LogEntryTestPeer entry("foo.cc", 1234, kNoPrefix, absl::LogSeverity::kInfo,
135                           "2020-01-02T03:04:05.6789", 451,
136                           absl::log_internal::PrefixFormat::kNotRaw,
137                           "hello world");
138    EXPECT_THAT(entry.FormatLogMessage(),
139                Eq("I0102 03:04:05.678900     451 foo.cc:1234] hello world"));
140    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
141                Eq("I0102 03:04:05.678900     451 foo.cc:1234] "));
142    for (size_t sz = strlen("I0102 03:04:05.678900     451 foo.cc:1234] ") + 20;
143         sz != std::numeric_limits<size_t>::max(); sz--)
144      EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:1234] ",
145                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
<span onclick='openModal()' class='match'>146    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
147                Eq("hello world\n"));
148    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline_c_str(),
149                StrEq("hello world\n"));
150    EXPECT_THAT(entry.entry().text_message_with_prefix(), Eq("hello world"));
151    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
</span>152  }
153  TEST(LogEntryTest, EmptyFields) {
154    LogEntryTestPeer entry("", 0, kUsePrefix, absl::LogSeverity::kInfo,
155                           "2020-01-02T03:04:05", 0,
156                           absl::log_internal::PrefixFormat::kNotRaw, "");
157    const std::string format_message = entry.FormatLogMessage();
158    EXPECT_THAT(format_message, Eq("I0102 03:04:05.000000       0 :0] "));
159    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000), Eq(format_message));
160    for (size_t sz = format_message.size() + 20;
161         sz != std::numeric_limits<size_t>::max(); sz--)
162      EXPECT_THAT(format_message,
163                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
164    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
165                Eq("I0102 03:04:05.000000       0 :0] \n"));
166    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline_c_str(),
167                StrEq("I0102 03:04:05.000000       0 :0] \n"));
168    EXPECT_THAT(entry.entry().text_message_with_prefix(),
169                Eq("I0102 03:04:05.000000       0 :0] "));
170    EXPECT_THAT(entry.entry().text_message(), Eq(""));
171  }
172  TEST(LogEntryTest, NegativeFields) {
173    if (std::is_signed<absl::LogEntry::tid_t>::value) {
174      LogEntryTestPeer entry(
175          "foo.cc", -1234, kUsePrefix, absl::LogSeverity::kInfo,
176          "2020-01-02T03:04:05.6789", static_cast<absl::LogEntry::tid_t>(-451),
177          absl::log_internal::PrefixFormat::kNotRaw, "hello world");
178      EXPECT_THAT(entry.FormatLogMessage(),
179                  Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world"));
180      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
181                  Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] "));
182      for (size_t sz =
183               strlen("I0102 03:04:05.678900    -451 foo.cc:-1234] ") + 20;
184           sz != std::numeric_limits<size_t>::max(); sz--)
185        EXPECT_THAT("I0102 03:04:05.678900    -451 foo.cc:-1234] ",
186                    StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
187      EXPECT_THAT(
188          entry.entry().text_message_with_prefix_and_newline(),
189          Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world\n"));
190      EXPECT_THAT(
191          entry.entry().text_message_with_prefix_and_newline_c_str(),
192          StrEq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world\n"));
193      EXPECT_THAT(entry.entry().text_message_with_prefix(),
194                  Eq("I0102 03:04:05.678900    -451 foo.cc:-1234] hello world"));
195      EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
196    } else {
197      LogEntryTestPeer entry("foo.cc", -1234, kUsePrefix,
198                             absl::LogSeverity::kInfo, "2020-01-02T03:04:05.6789",
199                             451, absl::log_internal::PrefixFormat::kNotRaw,
200                             "hello world");
201      EXPECT_THAT(entry.FormatLogMessage(),
202                  Eq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world"));
203      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
204                  Eq("I0102 03:04:05.678900     451 foo.cc:-1234] "));
205      for (size_t sz =
206               strlen("I0102 03:04:05.678900     451 foo.cc:-1234] ") + 20;
207           sz != std::numeric_limits<size_t>::max(); sz--)
208        EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:-1234] ",
209                    StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
210      EXPECT_THAT(
211          entry.entry().text_message_with_prefix_and_newline(),
212          Eq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world\n"));
213      EXPECT_THAT(
214          entry.entry().text_message_with_prefix_and_newline_c_str(),
215          StrEq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world\n"));
216      EXPECT_THAT(entry.entry().text_message_with_prefix(),
217                  Eq("I0102 03:04:05.678900     451 foo.cc:-1234] hello world"));
218      EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
219    }
220  }
221  TEST(LogEntryTest, LongFields) {
222    LogEntryTestPeer entry(
223        "I am the very model of a modern Major-General / "
224        "I've information vegetable, animal, and mineral.",
225        2147483647, kUsePrefix, absl::LogSeverity::kInfo,
226        "2020-01-02T03:04:05.678967896789", 2147483647,
227        absl::log_internal::PrefixFormat::kNotRaw,
228        "I know the kings of England, and I quote the fights historical / "
229        "From Marathon to Waterloo, in order categorical.");
230    EXPECT_THAT(entry.FormatLogMessage(),
231                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
232                   "modern Major-General / I've information vegetable, animal, "
233                   "and mineral.:2147483647] I know the kings of England, and I "
234                   "quote the fights historical / From Marathon to Waterloo, in "
235                   "order categorical."));
236    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
237                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
238                   "modern Major-General / I've information vegetable, animal, "
239                   "and mineral.:2147483647] "));
240    for (size_t sz =
241             strlen("I0102 03:04:05.678967 2147483647 I am the very model of a "
242                    "modern Major-General / I've information vegetable, animal, "
243                    "and mineral.:2147483647] ") +
244             20;
245         sz != std::numeric_limits<size_t>::max(); sz--)
246      EXPECT_THAT(
247          "I0102 03:04:05.678967 2147483647 I am the very model of a "
248          "modern Major-General / I've information vegetable, animal, "
249          "and mineral.:2147483647] ",
250          StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
251    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
252                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
253                   "modern Major-General / I've information vegetable, animal, "
254                   "and mineral.:2147483647] I know the kings of England, and I "
255                   "quote the fights historical / From Marathon to Waterloo, in "
256                   "order categorical.\n"));
257    EXPECT_THAT(
258        entry.entry().text_message_with_prefix_and_newline_c_str(),
259        StrEq("I0102 03:04:05.678967 2147483647 I am the very model of a "
260              "modern Major-General / I've information vegetable, animal, "
261              "and mineral.:2147483647] I know the kings of England, and I "
262              "quote the fights historical / From Marathon to Waterloo, in "
263              "order categorical.\n"));
264    EXPECT_THAT(entry.entry().text_message_with_prefix(),
265                Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
266                   "modern Major-General / I've information vegetable, animal, "
267                   "and mineral.:2147483647] I know the kings of England, and I "
268                   "quote the fights historical / From Marathon to Waterloo, in "
269                   "order categorical."));
270    EXPECT_THAT(
271        entry.entry().text_message(),
272        Eq("I know the kings of England, and I quote the fights historical / "
273           "From Marathon to Waterloo, in order categorical."));
274  }
275  TEST(LogEntryTest, LongNegativeFields) {
276    if (std::is_signed<absl::LogEntry::tid_t>::value) {
277      LogEntryTestPeer entry(
278          "I am the very model of a modern Major-General / "
279          "I've information vegetable, animal, and mineral.",
280          -2147483647, kUsePrefix, absl::LogSeverity::kInfo,
281          "2020-01-02T03:04:05.678967896789",
282          static_cast<absl::LogEntry::tid_t>(-2147483647),
283          absl::log_internal::PrefixFormat::kNotRaw,
284          "I know the kings of England, and I quote the fights historical / "
285          "From Marathon to Waterloo, in order categorical.");
286      EXPECT_THAT(
287          entry.FormatLogMessage(),
288          Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
289             "modern Major-General / I've information vegetable, animal, "
290             "and mineral.:-2147483647] I know the kings of England, and I "
291             "quote the fights historical / From Marathon to Waterloo, in "
292             "order categorical."));
293      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
294                  Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
295                     "modern Major-General / I've information vegetable, animal, "
296                     "and mineral.:-2147483647] "));
297      for (size_t sz =
298               strlen(
299                   "I0102 03:04:05.678967 -2147483647 I am the very model of a "
300                   "modern Major-General / I've information vegetable, animal, "
301                   "and mineral.:-2147483647] ") +
302               20;
303           sz != std::numeric_limits<size_t>::max(); sz--)
304        EXPECT_THAT(
305            "I0102 03:04:05.678967 -2147483647 I am the very model of a "
306            "modern Major-General / I've information vegetable, animal, "
307            "and mineral.:-2147483647] ",
308            StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
309      EXPECT_THAT(
310          entry.entry().text_message_with_prefix_and_newline(),
311          Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
312             "modern Major-General / I've information vegetable, animal, "
313             "and mineral.:-2147483647] I know the kings of England, and I "
314             "quote the fights historical / From Marathon to Waterloo, in "
315             "order categorical.\n"));
316      EXPECT_THAT(
317          entry.entry().text_message_with_prefix_and_newline_c_str(),
318          StrEq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
319                "modern Major-General / I've information vegetable, animal, "
320                "and mineral.:-2147483647] I know the kings of England, and I "
321                "quote the fights historical / From Marathon to Waterloo, in "
322                "order categorical.\n"));
323      EXPECT_THAT(
324          entry.entry().text_message_with_prefix(),
325          Eq("I0102 03:04:05.678967 -2147483647 I am the very model of a "
326             "modern Major-General / I've information vegetable, animal, "
327             "and mineral.:-2147483647] I know the kings of England, and I "
328             "quote the fights historical / From Marathon to Waterloo, in "
329             "order categorical."));
330      EXPECT_THAT(
331          entry.entry().text_message(),
332          Eq("I know the kings of England, and I quote the fights historical / "
333             "From Marathon to Waterloo, in order categorical."));
334    } else {
335      LogEntryTestPeer entry(
336          "I am the very model of a modern Major-General / "
337          "I've information vegetable, animal, and mineral.",
338          -2147483647, kUsePrefix, absl::LogSeverity::kInfo,
339          "2020-01-02T03:04:05.678967896789", 2147483647,
340          absl::log_internal::PrefixFormat::kNotRaw,
341          "I know the kings of England, and I quote the fights historical / "
342          "From Marathon to Waterloo, in order categorical.");
343      EXPECT_THAT(
344          entry.FormatLogMessage(),
345          Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
346             "modern Major-General / I've information vegetable, animal, "
347             "and mineral.:-2147483647] I know the kings of England, and I "
348             "quote the fights historical / From Marathon to Waterloo, in "
349             "order categorical."));
350      EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
351                  Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
352                     "modern Major-General / I've information vegetable, animal, "
353                     "and mineral.:-2147483647] "));
354      for (size_t sz =
355               strlen(
356                   "I0102 03:04:05.678967 2147483647 I am the very model of a "
357                   "modern Major-General / I've information vegetable, animal, "
358                   "and mineral.:-2147483647] ") +
359               20;
360           sz != std::numeric_limits<size_t>::max(); sz--)
361        EXPECT_THAT(
362            "I0102 03:04:05.678967 2147483647 I am the very model of a "
363            "modern Major-General / I've information vegetable, animal, "
364            "and mineral.:-2147483647] ",
365            StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
366      EXPECT_THAT(
367          entry.entry().text_message_with_prefix_and_newline(),
368          Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
369             "modern Major-General / I've information vegetable, animal, "
370             "and mineral.:-2147483647] I know the kings of England, and I "
371             "quote the fights historical / From Marathon to Waterloo, in "
372             "order categorical.\n"));
373      EXPECT_THAT(
374          entry.entry().text_message_with_prefix_and_newline_c_str(),
375          StrEq("I0102 03:04:05.678967 2147483647 I am the very model of a "
376                "modern Major-General / I've information vegetable, animal, "
377                "and mineral.:-2147483647] I know the kings of England, and I "
378                "quote the fights historical / From Marathon to Waterloo, in "
379                "order categorical.\n"));
380      EXPECT_THAT(
381          entry.entry().text_message_with_prefix(),
382          Eq("I0102 03:04:05.678967 2147483647 I am the very model of a "
383             "modern Major-General / I've information vegetable, animal, "
384             "and mineral.:-2147483647] I know the kings of England, and I "
385             "quote the fights historical / From Marathon to Waterloo, in "
386             "order categorical."));
387      EXPECT_THAT(
388          entry.entry().text_message(),
389          Eq("I know the kings of England, and I quote the fights historical / "
390             "From Marathon to Waterloo, in order categorical."));
391    }
392  }
393  TEST(LogEntryTest, Raw) {
394    LogEntryTestPeer entry("foo.cc", 1234, kUsePrefix, absl::LogSeverity::kInfo,
395                           "2020-01-02T03:04:05.6789", 451,
396                           absl::log_internal::PrefixFormat::kRaw, "hello world");
397    EXPECT_THAT(
398        entry.FormatLogMessage(),
399        Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world"));
400    EXPECT_THAT(entry.FormatPrefixIntoSizedBuffer(1000),
401                Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: "));
402    for (size_t sz =
403             strlen("I0102 03:04:05.678900     451 foo.cc:1234] RAW: ") + 20;
404         sz != std::numeric_limits<size_t>::max(); sz--)
405      EXPECT_THAT("I0102 03:04:05.678900     451 foo.cc:1234] RAW: ",
406                  StartsWith(entry.FormatPrefixIntoSizedBuffer(sz)));
407    EXPECT_THAT(
408        entry.entry().text_message_with_prefix_and_newline(),
409        Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world\n"));
410    EXPECT_THAT(
411        entry.entry().text_message_with_prefix_and_newline_c_str(),
412        StrEq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world\n"));
413    EXPECT_THAT(
414        entry.entry().text_message_with_prefix(),
415        Eq("I0102 03:04:05.678900     451 foo.cc:1234] RAW: hello world"));
416    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
417  }
418  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-frontiers_confirmation.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_entry_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>37  		auto send = builder
38  					.state ()
39  					.account (nano::dev::genesis_key.pub)
40  					.previous (nano::dev::genesis->hash ())
41  					.representative (nano::dev::genesis_key.pub)
42  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
43  					.link (key.pub)
44  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
45  					.work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
</pre></code></div>
                <div class="column column_space"><pre><code>146    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline(),
147                Eq("hello world\n"));
148    EXPECT_THAT(entry.entry().text_message_with_prefix_and_newline_c_str(),
149                StrEq("hello world\n"));
150    EXPECT_THAT(entry.entry().text_message_with_prefix(), Eq("hello world"));
151    EXPECT_THAT(entry.entry().text_message(), Eq("hello world"));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    