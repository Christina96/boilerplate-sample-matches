
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 41.05263157894737%, Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-telemetry_41.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/utility.hpp>
3  #include <nano/node/common.hpp>
4  #include <nano/node/messages.hpp>
5  #include <nano/node/nodeconfig.hpp>
6  #include <nano/secure/common.hpp>
7  #include <boost/multi_index/hashed_index.hpp>
8  #include <boost/multi_index/member.hpp>
9  #include <boost/multi_index/ordered_index.hpp>
10  #include <boost/multi_index_container.hpp>
11  #include <functional>
12  #include <memory>
13  #include <optional>
14  #include <thread>
15  namespace mi = boost::multi_index;
16  namespace nano
17  {
18  class node;
19  class network;
20  class node_observers;
21  class stats;
22  class ledger;
23  class thread_pool;
24  class unchecked_map;
25  namespace transport
26  {
27  	class channel;
28  }
29  class telemetry
30  {
31  public:
32  	struct config
33  	{
34  		bool enable_ongoing_requests{ true };
35  		bool enable_ongoing_broadcasts{ true };
36  		config (nano::node_config const & config, nano::node_flags const & flags) :
37  			enable_ongoing_requests{ !flags.disable_ongoing_telemetry_requests },
38  			enable_ongoing_broadcasts{ !flags.disable_providing_telemetry_metrics }
39  		{
40  		}
41  	};
42  public:
43  	telemetry (config const &, nano::node &, nano::network &, nano::node_observers &, nano::network_params &, nano::stats &);
44  	~telemetry ();
45  	void start ();
46  	void stop ();
47  	void process (nano::telemetry_ack const &, std::shared_ptr<nano::transport::channel> const &);
48  	void trigger ();
49  	std::size_t size () const;
50  	std::optional<nano::telemetry_data> get_telemetry (nano::endpoint const &) const;
51  	std::unordered_map<nano::endpoint, nano::telemetry_data> get_all_telemetries () const;
52  public: 
53  	std::unique_ptr<nano::container_info_component> collect_container_info (std::string const & name);
54  private: 
55  	nano::node & node;
56  	nano::network & network;
57  	nano::node_observers & observers;
58  	nano::network_params & network_params;
59  	nano::stats & stats;
60  	const config config_m;
61  private:
62  	struct entry
63  	{
64  		nano::endpoint endpoint;
65  		nano::telemetry_data data;
66  		std::chrono::steady_clock::time_point last_updated;
67  		std::shared_ptr<nano::transport::channel> channel;
68  	};
69  private:
<span onclick='openModal()' class='match'>70  	bool request_predicate () const;
71  	bool broadcast_predicate () const;
72  	void run ();
73  	void run_requests ();
74  	void run_broadcasts ();
75  	void cleanup ();
76  	void request (std::shared_ptr<nano::transport::channel> &);
77  	void broadcast (std::shared_ptr<nano::transport::channel> &, nano::telemetry_data const &);
78  	bool verify (nano::telemetry_ack const &, std::shared_ptr<nano::transport::channel> const &) const;
79  	bool check_timeout (entry const &) const;
</span>80  private:
81  	class tag_sequenced {};
82  	class tag_endpoint {};
83  	using ordered_telemetries = boost::multi_index_container<entry,
84  	mi::indexed_by<
85  		mi::sequenced<mi::tag<tag_sequenced>>,
86  		mi::hashed_unique<mi::tag<tag_endpoint>,
87  			mi::member<entry, nano::endpoint, &entry::endpoint>>
88  	>>;
89  	ordered_telemetries telemetries;
90  	bool triggered{ false };
91  	std::chrono::steady_clock::time_point last_request{};
92  	std::chrono::steady_clock::time_point last_broadcast{};
93  	bool stopped{ false };
94  	mutable nano::mutex mutex{ mutex_identifier (mutexes::telemetry) };
95  	nano::condition_variable condition;
96  	std::thread thread;
97  private:
98  	static std::size_t constexpr max_size = 1024;
99  };
100  nano::telemetry_data consolidate_telemetry_data (std::vector<telemetry_data> const & telemetry_data);
101  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tomlconfig.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/configbase.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <boost/filesystem/path.hpp>
5  #include <boost/lexical_cast.hpp>
6  #include <boost/optional.hpp>
7  #include <cpptoml.h>
8  namespace boost
9  {
10  namespace asio
11  {
12  	namespace ip
13  	{
14  		class address_v6;
15  	}
16  }
17  }
18  namespace nano
19  {
20  class error;
21  class tomlconfig : public nano::configbase
22  {
23  public:
24  	tomlconfig ();
25  	tomlconfig (std::shared_ptr<cpptoml::table> const & tree_a, std::shared_ptr<nano::error> const & error_a = nullptr);
26  	void doc (std::string const & key, std::string const & doc);
27  	nano::error & read (boost::filesystem::path const & path_a);
28  	nano::error & read (std::istream & stream_overrides, boost::filesystem::path const & path_a);
29  	nano::error & read (std::istream & stream_a);
30  	nano::error & read (std::istream & stream_first_a, std::istream & stream_second_a);
31  	void write (boost::filesystem::path const & path_a);
32  	void write (std::ostream & stream_a) const;
33  	void open_or_create (std::fstream & stream_a, std::string const & path_a);
<span onclick='openModal()' class='match'>34  	std::shared_ptr<cpptoml::table> get_tree ();
35  	bool empty () const;
36  	boost::optional<tomlconfig> get_optional_child (std::string const & key_a);
37  	tomlconfig get_required_child (std::string const & key_a);
38  	tomlconfig & put_child (std::string const & key_a, nano::tomlconfig & conf_a);
39  	tomlconfig & replace_child (std::string const & key_a, nano::tomlconfig & conf_a);
40  	bool has_key (std::string const & key_a);
41  	tomlconfig & erase (std::string const & key_a);
</span>42  	std::shared_ptr<cpptoml::array> create_array (std::string const & key, boost::optional<char const *> documentation_a);
43  	void erase_default_values (tomlconfig & defaults_a);
44  	std::string to_string ();
45  	std::string to_string_commented_entries ();
46  	template <typename T>
47  	tomlconfig & put (std::string const & key, T const & value, boost::optional<char const *> documentation_a = boost::none)
48  	{
49  		tree->insert (key, value);
50  		if (documentation_a)
51  		{
52  			doc (key, *documentation_a);
53  		}
54  		return *this;
55  	}
56  	template <typename T>
57  	tomlconfig & push (std::string const & key, T const & value)
58  	{
59  		if (!has_key (key))
60  		{
61  			auto arr = cpptoml::make_array ();
62  			tree->insert (key, arr);
63  		}
64  		auto arr = tree->get_qualified (key)->as_array ();
65  		arr->push_back (value);
66  		return *this;
67  	}
68  	template <typename T>
69  	tomlconfig & array_entries_required (std::string const & key, std::function<void (T)> callback)
70  	{
71  		if (tree->contains_qualified (key))
72  		{
73  			auto items = tree->get_qualified_array_of<T> (key);
74  			for (auto & item : *items)
75  			{
76  				callback (item);
77  			}
78  		}
79  		else
80  		{
81  			conditionally_set_error<T> (nano::error_config::missing_value, false, key);
82  		}
83  		return *this;
84  	}
85  	template <typename T>
86  	tomlconfig & get_optional (std::string const & key, T & target, T default_value)
87  	{
88  		get_config (true, key, target, default_value);
89  		return *this;
90  	}
91  	template <typename T>
92  	tomlconfig & get_optional (std::string const & key, T & target)
93  	{
94  		get_config (true, key, target, target);
95  		return *this;
96  	}
97  	template <typename T>
98  	boost::optional<T> get_optional (std::string const & key)
99  	{
100  		boost::optional<T> res;
101  		if (has_key (key))
102  		{
103  			T target{};
104  			get_config (true, key, target, target);
105  			res = target;
106  		}
107  		return res;
108  	}
109  	template <typename T>
110  	tomlconfig & get (std::string const & key, T & target)
111  	{
112  		get_config (true, key, target, target);
113  		return *this;
114  	}
115  	template <typename T>
116  	T get (std::string const & key)
117  	{
118  		T target{};
119  		get_config (true, key, target, target);
120  		return target;
121  	}
122  	template <typename T>
123  	tomlconfig & get_required (std::string const & key, T & target)
124  	{
125  		get_config (false, key, target);
126  		return *this;
127  	}
128  	template <typename T>
129  	tomlconfig & get_required (std::string const & key, T & target, T const & default_value)
130  	{
131  		get_config (false, key, target, default_value);
132  		return *this;
133  	}
134  protected:
135  	template <typename T, typename = std::enable_if_t<nano::is_lexical_castable<T>::value>>
136  	tomlconfig & get_config (bool optional, std::string const & key, T & target, T default_value = T ())
137  	{
138  		try
139  		{
140  			if (tree->contains_qualified (key))
141  			{
142  				auto val (tree->get_qualified_as<std::string> (key));
143  				if (!boost::conversion::try_lexical_convert<T> (*val, target))
144  				{
145  					conditionally_set_error<T> (nano::error_config::invalid_value, optional, key);
146  				}
147  			}
148  			else if (!optional)
149  			{
150  				conditionally_set_error<T> (nano::error_config::missing_value, optional, key);
151  			}
152  			else
153  			{
154  				target = default_value;
155  			}
156  		}
157  		catch (std::runtime_error & ex)
158  		{
159  			conditionally_set_error<T> (ex, optional, key);
160  		}
161  		return *this;
162  	}
163  	tomlconfig & get_config (bool optional, std::string const & key, uint8_t & target, uint8_t default_value = uint8_t ());
164  	tomlconfig & get_config (bool optional, std::string const & key, bool & target, bool default_value = false);
165  	tomlconfig & get_config (bool optional, std::string key, boost::asio::ip::address_v6 & target, boost::asio::ip::address_v6 const & default_value);
166  private:
167  	std::shared_ptr<cpptoml::table> tree;
168  	void erase_defaults (std::shared_ptr<cpptoml::table> const & base, std::shared_ptr<cpptoml::table> const & other, std::shared_ptr<cpptoml::table> const & update_target);
169  };
170  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-telemetry_41.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tomlconfig.hpp</div>
                </div>
                <div class="column column_space"><pre><code>70  	bool request_predicate () const;
71  	bool broadcast_predicate () const;
72  	void run ();
73  	void run_requests ();
74  	void run_broadcasts ();
75  	void cleanup ();
76  	void request (std::shared_ptr<nano::transport::channel> &);
77  	void broadcast (std::shared_ptr<nano::transport::channel> &, nano::telemetry_data const &);
78  	bool verify (nano::telemetry_ack const &, std::shared_ptr<nano::transport::channel> const &) const;
79  	bool check_timeout (entry const &) const;
</pre></code></div>
                <div class="column column_space"><pre><code>34  	std::shared_ptr<cpptoml::table> get_tree ();
35  	bool empty () const;
36  	boost::optional<tomlconfig> get_optional_child (std::string const & key_a);
37  	tomlconfig get_required_child (std::string const & key_a);
38  	tomlconfig & put_child (std::string const & key_a, nano::tomlconfig & conf_a);
39  	tomlconfig & replace_child (std::string const & key_a, nano::tomlconfig & conf_a);
40  	bool has_key (std::string const & key_a);
41  	tomlconfig & erase (std::string const & key_a);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    