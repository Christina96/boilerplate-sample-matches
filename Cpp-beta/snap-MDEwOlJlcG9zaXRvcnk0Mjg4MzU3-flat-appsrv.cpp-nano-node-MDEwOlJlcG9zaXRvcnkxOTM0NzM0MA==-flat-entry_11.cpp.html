
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.968973747016706%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-appsrv.cpp</h3>
            <pre><code>1  TStr TAppCS::A_Result="Result";
2  TStr TAppCS::A_Msg="Msg";
3  TStr TAppCS::A_MsgType="MsgType";
4  TStr TAppCS::A_Continue="Continue";
5  TStr TAppCS::A_Browse="Browse";
6  TStr TAppCS::A_SesId="SesId";
7  TStr TAppCS::A_FetchId="FetchId";
8  TStr TAppCS::A_Redir="Redir";
9  TStr TAppCS::A_Agent="Agent";
10  TStr TAppCS::A_HostNm="HostNm";
11  TStr TAppCS::A_PortN="PortN";
12  TStr TAppCS::A_UsrNm="UsrNm";
13  TStr TAppCS::A_PwdStr="PwdStr";
14  TStr TAppCS::A_PrivNm="PrivNm";
15  TStr TAppCS::A_PrivId="PrivId";
16  TStr TAppCS::A_CltNm="CltNm";
17  TStr TAppCS::A_CltType="CltType";
18  TStr TAppCS::A_State="State";
19  TStr TAppCS::A_PrevState="PrevState";
20  TStr TAppCS::A_OldState="OldState";
21  TStr TAppCS::A_NewState="NewState";
22  TStr TAppCS::A_AbortState="AbortState";
23  TStr TAppCS::A_SetStateTm="SetStateTm";
24  TStr TAppCS::A_LogNm="LogNm";
25  TStr TAppCS::F_Info="Info";
26  TStr TAppCS::F_GetStateInfo="GetStateInfo";
27  TStr TAppCS::F_GetCltList="GetCltList";
28  TStr TAppCS::F_GetCltInfo="GetCltInfo";
29  TStr TAppCS::F_GetCltDesc="GetCltDesc";
30  TStr TAppCS::F_IsAlive="IsAlive";
31  TStr TAppCS::F_IsConn="IsConn";
32  TStr TAppCS::F_Log="Log";
33  TStr TAppCS::F_Connect="Connect";
34  TStr TAppCS::F_Disconnect="Disconnect";
35  TStr TAppCS::F_DelayTimer="DelayTimer";
36  TStr TAppCS::F_RegAgent="RegAgent";
37  TStr TAppCS::F_Confirm="Confirm";
38  TStr TAppCS::F_Cancel="Cancel";
39  TStr TAppCS::F_Notify="Notify";
40  TStr TAppCS::F_NotifyStateChange="NotifyStateChange";
41  TStr TAppCS::F_Abort="Abort";
42  TStr TAppCS::F_HBeatTimer="HBeatTimer";
43  TStr TAppCS::TmA_TimerId="TimerId";
44  TStr TAppCS::TmA_CtxNm="CtxNm";
45  TStr TAppCS::TmA_Ticks="Ticks";
46  TStr TAppCS::F_Broadcast="Broadcast";
47  TStr TAppCS::BcA_Cm="Cm";
48  TStr TAppCS::BcA_FldNm="FldNm";
49  TStr TAppCS::BcA_FldVal="FldVal";
50  TStr TAppCS::BcA_Msg="Msg";
51  TStr TAppCS::F_NotifyEvent="Log::NotifyEvent";
52  TStr TAppCS::F_NotifyRawEvent="Log::NotifyRawEvent";
53  TStr TAppCS::LogA_EventTypeNm="EventTypeNm";
54  TStr TAppCS::LogA_TestMode="TestMode";
55  TStr TAppCS::LogA_CreatorNm="CreatorNm";
56  TStr TAppCS::LogA_CreatorTime="CreatorTime";
57  int TAppCS::DTmrA_DelayTimerTout=2*1000;
58  TStr TAppCS::S_Start="Start";
59  TStr TAppCS::S_End="End";
60  TStr TAppCS::S_ConnectRq="ConnectRq";
61  TStr TAppCS::S_ConnectResp="ConnectResp";
62  TStr TAppCS::S_Connected="Connected";
63  TStr TAppCS::S_Server="Server";
64  TAppCSLog::TAppCSLog(
65  const TStr& _LogFNm, const int64& _MxFLen, const PNotify& _Notify):
66    Notify(_Notify),
67    LogFNm(_LogFNm), LogSOut(), fLog(NULL), MxFLen(_MxFLen){
68    if (LogFNm.Empty()){
69      TNotify::OnNotify(Notify, ntInfo, "Log-File Not Generated.");
70    } else {
71      if (LogFNm.GetFPath().Empty()){
72        LogFNm=GetHomeNrFPath()+LogFNm;}
73      if (false&&TFile::Exists(LogFNm)){
74        LogSOut=TFOut::New(LogFNm, true); fLog=LogSOut->GetFileId();
75        TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" opened.");
76      } else {
77        LogSOut=TFOut::New(LogFNm); fLog=LogSOut->GetFileId();
78        TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" created.");
79      }
80      PutLogHd();
81    }
82  }
83  void TAppCSLog::ResetLogIfTooBig(){
84    if ((fLog!=NULL)&&(MxFLen!=-1)){
85      int64 FLen=ftell(fLog);
86      if (FLen>MxFLen){
87        LogSOut=NULL; 
88        try {
89          TStr OldLogFNm=LogFNm+".Old";
90          TFile::Del(OldLogFNm, false);
91          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+OldLogFNm+" deleted.");
92          TFile::Rename(LogFNm, OldLogFNm);
93          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" renamed.");
94          LogSOut=TFOut::New(LogFNm, true);
95          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" opened.");
96          PutLogHd();
97        } catch (PExcept Except){
98          TNotify::OnNotify(Notify, ntErr, Except->GetMsgStr());
99        }
100      }
101    }
102  }
103  void TAppCSLog::PutLogHd(){
104    TTm CurTm=TTm::GetCurUniTm();
105    if (fLog!=NULL){
106      fprintf(fLog, "#Software: Quintelligence Application-Web-Server 1.0\n");
107      fprintf(fLog, "#Version: 1.0\n");
108      fprintf(fLog, "#Date: %s %s\n",
109       CurTm.GetWebLogDateStr().CStr(), CurTm.GetWebLogTimeStr().CStr());
110      fprintf(fLog, "#Fields: date time c-ip cs-method cs-uri sc-status\n");
111      fflush(fLog);
112    }
113    ResetLogIfTooBig();
114  }
115  void TAppCSLog::PutLogRec(
116   const PHttpRq& HttpRq, const PHttpResp& HttpResp, const TStr& PeerHostNm){
117    TTm CurTm=TTm::GetCurUniTm();
118    if (fLog!=NULL){
119      fprintf(fLog, "%s %s %s %s %s %s\n",
<span onclick='openModal()' class='match'>120       CurTm.GetWebLogDateStr().CStr(),
121       CurTm.GetWebLogTimeStr().CStr(),
122       PeerHostNm.CStr(),
123       HttpRq->GetMethodNm().CStr(),
124       HttpRq->GetUrl()->GetUrlStr().CStr(),
125       TInt::GetStr(HttpResp->GetStatusCd()).CStr());
126      fflush(fLog);
</span>127    }
128    TStr MsgStr=TStr("Http: ")+
129     PeerHostNm+" requested "+HttpRq->GetUrl()->GetUrlStr()+
130     " responding "+THttp::GetReasonPhrase(HttpResp->GetStatusCd())
131     +" ["+CurTm.GetStr()+"]";
132    TNotify::OnNotify(Notify, ntInfo, MsgStr);
133    ResetLogIfTooBig();
134  }
135  void TAppCSLog::PutLogMsg(const TStr& MsgType, const TStr& MsgStr){
136    TTm CurTm=TTm::GetCurUniTm();
137    if (fLog!=NULL){
138      fprintf(fLog, "#%s: %s\n",
139       MsgType.CStr(),
140       MsgStr.CStr());
141      fflush(fLog);
142    }
143    TNotify::OnNotify(
144     Notify, ntInfo, MsgType+": "+MsgStr&bsol;*+" ["+CurTm.GetStr()+"]"*/);
145    ResetLogIfTooBig();
146  }
147  void TAppCSLog::PutLogMsg(
148   const TStr& MsgType, const TStr& MsgStr, const TStr& MsgArg){
149    PutLogMsg(MsgType, MsgStr+" ("+MsgArg+").");
150  }
151  TAppCSTimer::TAppCSTimer(
152   const TStr& _TimerNm, const TStr& _CtxNm,
153   const int& TimerTout, const bool& _RepeatP, TWebNetSrv* _WebNetSrv):
154    TTTimer(TimerTout), WebNetSrv(_WebNetSrv),
155    TimerNm(_TimerNm), RepeatP(_RepeatP), CtxNm(_CtxNm){
156    IAssertR(TXmlLx::IsTagNm(TimerNm),
157     TStr("Timer-name is not XML-Tag-Name (")+TimerNm+").");
158  }
159  void TAppCSTimer::OnTimeOut(){
160    if (!RepeatP){
161      StopTimer();}
162    PSoapRq SoapRq=TSoapRq::New(TimerNm,
163     TAppCS::TmA_TimerId, TInt::GetStr(GetTimerId()),
164     TAppCS::TmA_CtxNm, CtxNm,
165     TAppCS::TmA_Ticks, TInt::GetStr(GetTicks()));
166    PUrl Url=SoapRq->GetAsUrl("localhost");
167    PHttpRq HttpRq=THttpRq::New(Url);
168    WebNetSrv->OnHttpRq(-1, HttpRq);
169  }
170  TAppCSState::TAppCSState(const PAppCSLog& _Log):
171    StateId(), Log(_Log){
172    PrepState();
173  }
174  void TAppCSState::PrepState(){
175    SoapEnv=TSoapEnv::New();
176    SetState(TAppCS::S_Start);
177  }
178  void TAppCSState::SetState(const TStr& _StateId){
179    TStr PrevStateId=StateId;
180    StateId=_StateId;
181    if (!Log.Empty()){
182      Log->PutLogMsg("SetState", "From '"+PrevStateId+"' to '"+StateId+"'");
183    }
184  }
185  TAppSrv::TAppSrv(
186   const int& PortN, const TStr& LogFNm, const int& HBeatTimerTout,
187   const PNotify& Notify):
188    TWebNetSrv(PortN, true), 
189    TWebNetCltV(), 
190    Log(TAppCSLog::New(LogFNm, -1, Notify)), 
191    SesIdToCltDescH(), 
192    CltNmToSesIdH(), 
193    HBeatTimer(), 
194    ActConnBs(TAppCSActConnBs::New()), 
195    NmToLogH(),
196    Proxy(new TWebNetProxy(PortN+11,TStr("http:&bsol;&bsol;127.0.0.1:")+TInt::GetStr(PortN))) {
197    HBeatTimer=TAppCSTimer::New(TAppCS::F_HBeatTimer,
198     "Srv", HBeatTimerTout, true, this);
199  }
200  TAppSrv::~TAppSrv(){
201    HBeatTimer->StopTimer();
202  }
203  bool TAppSrv::IsLogSoapFuncNm(const TStr& SoapFuncNm){
204    return
205     (!SoapFuncNm.IsPrefix(TAppCS::F_Log))&&
206     (SoapFuncNm!=TAppCS::F_HBeatTimer)&&
207     (SoapFuncNm!=TAppCS::F_IsAlive);
208  }
209  TStr TAppSrv::GetNewSesId(){
210    TStr SesId;
211    do {
212      SesId=TTm::GetCurUniTm().GetIdStr();
213    } while (SesIdToCltDescH.IsKey(SesId));
214    return SesId;
215  }
216  bool TAppSrv::IsGetCltDescBySesId(
217   const TStr& SesId, PAppCltDesc& CltDesc) const {
218    return SesIdToCltDescH.IsKeyGetDat(SesId, CltDesc);
219  }
220  bool TAppSrv::IsGetCltDescBySockId(
221   const int& SockId, PAppCltDesc& CltDesc) const {
222    int SesIdToCltDescP=SesIdToCltDescH.FFirstKeyId();
223    while (SesIdToCltDescH.FNextKeyId(SesIdToCltDescP)){
224      CltDesc=SesIdToCltDescH[SesIdToCltDescP];
225      if (CltDesc->SockId==SockId){
226        return true;}
227    }
228    CltDesc=NULL;
229    return false;
230  }
231  bool TAppSrv::IsGetCltDescByCltNm(
232   const TStr& CltNm, PAppCltDesc& CltDesc) const {
233    TStr SesId;
234    if (CltNmToSesIdH.IsKeyGetDat(CltNm, SesId)){
235      return IsGetCltDescBySesId(SesId, CltDesc);
236    } else {
237      return false;
238    }
239  }
240  PAppCltDesc TAppSrv::AddNewCltDesc(
241   const TStr& HostNm, const int& PortN, const int& SockId,
242   const TStr& CltNm, const TStr& CltType){
243    TStr SesId=GetNewSesId();
244    PAppCltDesc CltDesc=TAppCltDesc::New(SesId, HostNm, PortN);
245    CltDesc->SockId=SockId;
246    CltDesc->CltNm=CltNm;
247    CltDesc->CltType=CltType;
248    SesIdToCltDescH.AddDat(SesId, CltDesc);
249    TStr PrevSesId;
250    if (CltNmToSesIdH.IsKeyGetDat(CltNm, PrevSesId)){
251      DelIfCltDesc(PrevSesId);}
252    CltNmToSesIdH.AddDat(CltNm, SesId);
253    CltDesc->CltType=CltType;
254    return CltDesc;
255  }
256  void TAppSrv::DelIfCltDesc(const TStr& SesId){
257    PAppCltDesc CltDesc; TStr CltNm;
258    if (IsGetCltDescBySesId(SesId, CltDesc)){
259      CltNm=CltDesc->CltNm;
260      CltNmToSesIdH.DelIfKey(CltDesc->CltNm);
261    }
262    SesIdToCltDescH.DelIfKey(SesId);
263    Log->PutLogMsg("Info",
264     TStr::Fmt("Delete client '%s' with session '%s'.", CltNm.CStr(), SesId.CStr()));
265  }
266  void TAppSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
267    TTm CurTm=TTm::GetCurUniTm(); 
268    TStr FetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm); 
269    PUrl Url=HttpRq->GetUrl(); 
270    TStr UrlStr=Url->GetUrlStr(); 
271    TStr PeerHostNm=GetPeerHostNm(SockId); 
272    PSoapRq SoapRq=TSoapRq::New(HttpRq); 
273    TStr SoapFuncNm=SoapRq->GetFuncNm();
274    TStr SoapRqMsgStr=UrlStr+" from "+PeerHostNm; 
275    if (IsLogSoapFuncNm(SoapFuncNm)){
276      Log->PutLogMsg("SoapRequest", SoapRqMsgStr);}
277    PHttpResp HttpResp;
278    if (SoapRq->IsOk()){
279      if (SoapFuncNm==TAppCS::F_Info){
280        HttpResp=OnHttpRq_Info();
281      } else
282      if (SoapFuncNm==TAppCS::F_GetCltList){
283        HttpResp=OnHttpRq_GetCltList(SoapRq);
284      } else
285      if ((SoapFuncNm==TAppCS::F_GetCltInfo)||(SoapFuncNm==TAppCS::F_GetCltDesc)){
286        HttpResp=OnHttpRq_GetCltInfo(SoapRq);
287      } else
288      if (SoapFuncNm==TAppCS::F_Connect){
289        HttpResp=OnHttpRq_Connect(SoapRq, PeerHostNm, SockId);
290      } else
291      if (SoapFuncNm==TAppCS::F_Disconnect){
292        HttpResp=OnHttpRq_Disconnect(SoapRq, PeerHostNm);
293      } else
294      if (SoapFuncNm==TAppCS::F_Log){
295        HttpResp=OnHttpRq_OnLog(SoapRq);
296      } else
297      if (SoapFuncNm==TAppCS::F_HBeatTimer){
298        OnHttpRq_OnHBeatTimer();
299      } else
300      if (IsCltOk(SoapRq, PeerHostNm)){
301        if (SoapFuncNm==TAppCS::F_IsAlive){
302          HttpResp=TSoapResp::GetHttpResp(TAppCS::F_IsAlive);
303        } else
304        if (SoapFuncNm==TAppCS::F_Broadcast){
305          HttpResp=OnHttpRq_Broadcast(SoapRq);
306        } else {
307          HttpResp=OnFuncRq(SockId, SoapRq, Url);
308        }
309      } else {
310        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
311         "Client admin info mismatch.");
312      }
313    } else {
314      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::DataEncodingUnknownCodeNm,
315       "Invalid SOAP HTTP Request.");
316    }
317    if (SockId!=-1){
318      if (HttpResp.Empty()){
319        Log->PutLogMsg("Warning", TStr("Empty Http-Response for ")+SoapRqMsgStr);
320        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, "Empty Response.");
321      }
322      if (!FetchIdStr.Empty()){
323        HttpResp->AddFldVal(THttp::FetchIdFldNm, FetchIdStr);}
324      SendHttpResp(SockId, HttpResp);
325      if (IsLogSoapFuncNm(SoapFuncNm)){
326        Log->PutLogRec(HttpRq, HttpResp, PeerHostNm);
327        PSoapResp SoapResp=TSoapResp::New(HttpResp);
328        if (SoapResp->IsOk()){
329          Log->PutLogMsg("SoapResponse", SoapResp->GetAsUrlPathStr());
330        }
331      }
332    }
333  }
334  void TAppSrv::OnHttpRqError(const int& SockId, const TStr& MsgStr){
335    Log->PutLogMsg("HttpRqError", MsgStr);
336    PAppCltDesc CltDesc;
337    if (IsGetCltDescBySockId(SockId, CltDesc)){
338      DelIfCltDesc(CltDesc->SesId);
339    }
340  }
341  TStr TAppSrv::GetPeerHostNm(const int& SockId) const {
342    if (SockId==-1){
343      return "internal";
344    } else {
345      TStr PeerHostNm=GetCltSock(SockId)->GetPeerIpNum();
346  #if 0
347      if ((PeerHostNm.GetLc()=="localhost")||(PeerHostNm=="127.0.0.1")){
348        PSockHost LocalSockHost=TSockHost::GetLocalSockHost();
349        if (LocalSockHost->IsOk()){
350          return LocalSockHost->GetIpNum();
351        }
352      }
353  #else
354      if (PeerHostNm.GetLc()=="localhost") PeerHostNm="127.0.0.1";
355  #endif
356      return PeerHostNm;
357    }
358  }
359  void TAppSrv::ResolveCltIP(const PAppCltDesc CltDesc, int SockId, TStr &DestHost, TStr &DestProxy) {
360    static const TStr LoopbackIP("127.0.0.1");
361    static const TStr LocalhostNm("localhost");
362    if (SockId==-1) {
363      DestHost=LoopbackIP;
364    } else {
365      PSockHost Localhost=TSockHost::GetLocalSockHost();
366      PSock Sock=GetCltSock(SockId);
367      TStr PeerIP=Sock->GetPeerIpNum();
368      TStr AdapterIP=Sock->GetLocalIpNum();
369      TStr CltHostNm = CltDesc->HostNm;
370      bool LocalPeerP = (Localhost->HasIpNum(PeerIP)||(PeerIP==LoopbackIP)||(PeerIP==LocalhostNm));
371      bool LocalRedirP = (Localhost->HasIpNum(CltHostNm)||(CltHostNm==LoopbackIP)||(CltHostNm==LocalhostNm));
372      if (LocalRedirP) { 
373        DestHost=LocalPeerP?LoopbackIP:AdapterIP;
374        IAssert(LocalPeerP||(AdapterIP!=LoopbackIP));
375      } else { 
376        DestHost=CltHostNm;
377        if (!LocalPeerP) {
378          unsigned long PeerAddr = ntohl(inet_addr(PeerIP.CStr()));
379          unsigned long DestAddr = ntohl(inet_addr(DestHost.CStr()));
380          if (((PeerAddr^DestAddr) & 0xFFFFFF00) != 0) {
381            DestProxy=AdapterIP;
382          }
383        }
384      }
385    }
386  }
387  bool TAppSrv::IsCltOk(const PSoapRq& SoapRq, const TStr& PeerHostNm) const {
388    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
389    PAppCltDesc CltDesc;
390    if (IsGetCltDescBySesId(SesId, CltDesc)){
391  #if 0
392      if (PeerHostNm==CltDesc->HostNm) {
393        return true;
394      }
395  #else
396      return true;
397  #endif
398    }
399    return false;
400  }
401  PHttpResp TAppSrv::OnHttpRq_Info() const {
402    TTm CurTm=TTm::GetCurUniTm();
403    TChA HtmlChA;
404    HtmlChA+="<html><head><title>Application Server Status</title></head>";
405    HtmlChA+="<body>";
406    HtmlChA+="<h1>Application Server Status</h1>";
407    HtmlChA+="GMT-Time: ";
408    HtmlChA+=CurTm.GetWebLogDateStr()+" "+CurTm.GetWebLogTimeStr();
409    HtmlChA+="<br>";
410    HtmlChA+="Active Clients: "; HtmlChA+=TInt::GetStr(GetClts());
411    HtmlChA+="<br>";
412    HtmlChA+="Server Port: ";
413    HtmlChA+=TInt::GetStr(GetPortN());
414    HtmlChA+="<br>";
415    HtmlChA+="Server Up-Time (secs): ";
416    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetSecs());
417    HtmlChA+="<br>";
418    HtmlChA+="Log-File-Name: ";
419    HtmlChA+=GetLog()->GetLogFNm();
420    HtmlChA+="<br>";
421    HtmlChA+="Heart-Beat-TimeOut (msecs): ";
422    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTimeOut());
423    HtmlChA+="<br>";
424    HtmlChA+="Heart-Beat-Ticks: ";
425    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTicks());
426    HtmlChA+="<br>";
427    HtmlChA+="</body>";
428    HtmlChA+="</html>";
429    PHttpResp HttpResp=THttpResp::New(
430     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, TStrIn::New(HtmlChA));
431    return HttpResp;
432  }
433  PHttpResp TAppSrv::OnHttpRq_GetCltList(const PSoapRq& SoapRq){
434    PSoapResp SoapResp=TSoapResp::New(SoapRq->GetFuncNm());
435    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
436    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
437      PAppCltDesc CltDesc=CltDescV[CltDescN];
438      if (!CltDesc->CltNm.Empty()){
439        SoapResp->AddFldNmVal(CltDesc->CltNm,
440         CltDesc->HostNm+"/"+TInt::GetStr(CltDesc->PortN));
441      }
442    }
443    return SoapResp->GetHttpResp();
444  }
445  PHttpResp TAppSrv::OnHttpRq_GetCltInfo(const PSoapRq& SoapRq){
446    PHttpResp HttpResp;
447    TStr CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
448    PAppCltDesc CltDesc;
449    if (IsGetCltDescByCltNm(CltNm, CltDesc)){
450      HttpResp=TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
451       TAppCS::A_Result, "T",
452       TAppCS::A_HostNm, CltDesc->HostNm,
453       TAppCS::A_PortN, TInt::GetStr(CltDesc->PortN),
454       TAppCS::A_CltNm, CltDesc->CltNm,
455       TAppCS::A_CltType, CltDesc->CltType);
456    } else {
457      HttpResp=TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
458       TAppCS::A_Result, "F",
459       TAppCS::A_Msg, TStr::Fmt("Client '%s' not registered.", CltNm.CStr()));
460    }
461    return HttpResp;
462  }
463  PHttpResp TAppSrv::OnHttpRq_Connect(
464   const PSoapRq& SoapRq, const TStr& PeerHostNm, const int& SockId){
465    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Connect);
466    int CltPortN=SoapRq->GetFldVal(TAppCS::A_PortN).GetInt(-1);
467    if (CltPortN==-1){
468      return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
469       "Port parameter missing in Login function call.");
470    } else {
471      TStr CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
472      TStr CltType=SoapRq->GetFldVal(TAppCS::A_CltType);
473      if (!IsCltByCltNm(CltNm)){
474        PAppCltDesc CltDesc=AddNewCltDesc(PeerHostNm, CltPortN, SockId, CltNm, CltType);
475        return TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
476         TAppCS::A_SesId, CltDesc->SesId);
477      } else {
478        return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
479         TStr::Fmt("Client '%s' already registered.", CltNm.CStr()));
480      }
481    }
482  }
483  PHttpResp TAppSrv::OnHttpRq_Disconnect( 
484   const PSoapRq& SoapRq, const TStr& PeerHostNm){
485    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Disconnect);
486    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId); PAppCltDesc CltDesc;
487    if (!SesId.Empty()&&IsGetCltDescBySesId(SesId, CltDesc)){
488      DelIfCltDesc(CltDesc->SesId);
489      return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
490    } else {
491      return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
492       "Invalid disconnect request.");
493    }
494  }
495  PHttpResp TAppSrv::OnHttpRq_OnLog(const PSoapRq& SoapRq){
496    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Log);
497    PAppCSLog CltLog;
498    TStr LogNm=SoapRq->GetFldVal(TAppCS::A_LogNm);
499    if (!NmToLogH.IsKeyGetDat(LogNm, CltLog)){
500      CltLog=TAppCSLog::New(LogNm+".Log", -1, NULL);
501      NmToLogH.AddDat(LogNm, CltLog);
502    }
503    TStr MsgTypeNm=SoapRq->GetFldVal(TAppCS::A_MsgType);
504    TStr MsgStr=SoapRq->GetFldVal(TAppCS::A_Msg);
505    CltLog->PutLogMsg(MsgTypeNm, MsgStr);
506    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
507  }
508  void TAppSrv::OnHttpRq_OnHBeatTimer(){
509    TTm CurTm=TTm::GetCurUniTm();
510    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
511    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
512      PAppCltDesc CltDesc=CltDescV[CltDescN];
513      TTm LastHBeatTm=CltDesc->LastHBeatTm;
514      if (TTm::GetDiffMSecs(CurTm, LastHBeatTm)>HBeatTimer->GetTimeOut()){
515        if (CltDesc->ActiveHBeatRqP){
516          DelIfCltDesc(CltDesc->SesId);
517        } else {
518          CltDesc->ActiveHBeatRqP=true;
519          FetchSoapRq(CltDesc, TSoapRq::New(TAppCS::F_IsAlive));
520        }
521      }
522    }
523  }
524  PHttpResp TAppSrv::OnHttpRq_Broadcast(const PSoapRq& SoapRq){
525    IAssert(SoapRq->GetFuncNm()=="Broadcast");
526    TStr BcCmNm=SoapRq->GetFldVal("Cm");
527    TStr BcFldNm=SoapRq->GetFldVal("FldNm");
528    TStr BcFldVal=SoapRq->GetFldVal("FldVal");
529    TStr BcMsgStr=SoapRq->GetFldVal("Msg");
530    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
531    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
532      PAppCltDesc CltDesc=CltDescV[CltDescN];
533      FetchSoapRq(CltDesc, TSoapRq::New("Broadcast",
534       "Cm", BcCmNm, "FldNm", BcFldNm, "FldVal", BcFldVal, "Msg", BcMsgStr));
535    }
536    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
537  }
538  PHttpResp TAppSrv::OnFuncRq(const int &SockId, const PSoapRq& SoapRq, const PUrl& Url){
539    TStr FuncNm=SoapRq->GetFuncNm();
540    TStr CltNm;
541    if (SoapRq->IsFldNm(TAppCS::A_CltNm)){
542      CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
543    }
544    if (CltNm.Empty()){
545      TStr _CltFuncNm; FuncNm.SplitOnStr(CltNm, "::", _CltFuncNm);
546    }
547    PHttpResp HttpResp;
548    if (!CltNm.Empty()){
549      PAppCltDesc CltDesc;
550      if (IsGetCltDescByCltNm(CltNm, CltDesc)){
551        {TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
552        PAppCltDesc SoapRqCltDesc;
553        if (IsGetCltDescBySesId(SesId, SoapRqCltDesc)){
554          SoapRq->AddFldNmVal(TAppCS::LogA_CreatorNm, SoapRqCltDesc->CltNm);
555        }}
556        SoapRq->AddFldNmVal(TAppCS::A_Redir, "T");
557  #if 0
558        TStr RedirUrlStr=TStr()+
559         "http:&bsol;&bsol;"+CltDesc->HostNm+":"+TInt::GetStr(CltDesc->PortN)+"/"+
560         SoapRq->GetAsUrlPathStr();
561        HttpResp=THttpResp::New(300, "", false, NULL, RedirUrlStr);
562  #else
563        TStr DestHost, DestProxy, RedirHost;
564        ResolveCltIP(CltDesc,SockId,DestHost,DestProxy);
565        DestHost += ":"+TInt::GetStr(CltDesc->PortN);
566        if (!DestProxy.Empty()) {
567          DestProxy += ":"+TInt::GetStr(Proxy->GetPortN());
568          RedirHost=DestProxy;
569        } else {
570          RedirHost=DestHost;
571        }
572        TStr RedirUrlStr=TStr()+"http:&bsol;&bsol;"+RedirHost+"/"+SoapRq->GetAsUrlPathStr();
573        Log->PutLogMsg("Redirect", TStr()+GetPeerHostNm(SockId)+" -> "+RedirUrlStr);
574        HttpResp=THttpResp::New(300, "", false, NULL, RedirUrlStr);
575        if (!DestProxy.Empty()) HttpResp->AddFldVal(THttp::HostFldNm,DestHost);
576  #endif
577      } else {
578        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
579         TStr()+"Client for function call not active: "+CltNm, FuncNm);
580      }
581    } else {
582      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
583       "Unknown SOAP function call", FuncNm);
584    }
585    return HttpResp;
586  }
587  int TAppSrv::FetchSoapRq(const PAppCltDesc& CltDesc, const PSoapRq& SoapRq){
588    SoapRq->AddFldNmVal(TAppCS::A_SesId, CltDesc->SesId);
589    PUrl SoapRqUrl=SoapRq->GetAsUrl(CltDesc->HostNm, CltDesc->PortN);
590    int FetchId=FetchUrl(SoapRqUrl);
591    ActConnBs->AddActConn(FetchId,
592     TAppCSActConn::New(SoapRq, CltDesc->HostNm, CltDesc->PortN,1));
593    Log->PutLogMsg("FetchSoapRq",
594     TInt::GetStr(FetchId, "[FetchId:%d]")+SoapRq->GetAsUrlPathStr());
595    return FetchId;
596  }
597  void TAppSrv::OnHttpResp(const int& FetchId, const PHttpResp& HttpResp){
598    PSoapResp SoapResp=TSoapResp::New(HttpResp);
599    if (SoapResp->IsOk()){
600      if (SoapResp->IsResult()){
601        TStr SoapRespFuncNm=SoapResp->GetFuncNm();
602        TStr SoapRespResultVal=SoapResp->GetFldVal(TAppCS::A_Result);
603        PSoapRq SoapRq=ActConnBs->GetActConn(FetchId)->GetSoapRq();
604        TStr SoapRqFuncNm=SoapRq->GetFuncNm();
605        IAssert(SoapRqFuncNm==SoapRespFuncNm);
606        ActConnBs->DelActConn(FetchId);
607        if (SoapRespFuncNm==TAppCS::F_IsAlive){
608          TStr SoapRqSesId=SoapRq->GetFldVal(TAppCS::A_SesId); 
609          TStr SoapRespSesId=SoapResp->GetFldVal(TAppCS::A_SesId); 
610          if (SoapRqSesId==SoapRespSesId){
611            PAppCltDesc CltDesc;
612            if (IsGetCltDescBySesId(SoapRespSesId, CltDesc)){ 
613              CltDesc->LastHBeatTm=TTm::GetCurUniTm(); 
614              CltDesc->ActiveHBeatRqP=false; 
615            }
616          } else {
617            Log->PutLogMsg("Warning",
618             "Session numbers (request & response) for IsAlive don't match.");
619          }
620        } else {
621          Log->PutLogMsg("Warning",
622           "Unhandled Soap-Response", SoapResp->GetAsUrlPathStr());
623        }
624      } else {
625        IAssert(SoapResp->IsFault());
626        OnHttpRespError(FetchId, TStr("SoapFault: ")+SoapResp->GetFaultReasonStr());
627      }
628    } else {
629      PSoapResp SoapResp=TSoapResp::New(HttpResp);
630      OnHttpRespError(FetchId, "Invalid SOAP Response");
631    }
632  }
633  void TAppSrv::OnHttpRespError(const int& FetchId, const TStr& MsgStr){
634    PSoapRq SoapRq=ActConnBs->GetActConn(FetchId)->GetSoapRq();
635    Log->PutLogMsg("Error", MsgStr, SoapRq->GetAsUrlPathStr());
636    ActConnBs->DelActConn(FetchId);
637    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
638    DelIfCltDesc(SesId);
639  }
640  const int TAppSrv::DfPortN=8888;
641  TAppClt::TAppClt(
642   const TStr& LogFNm,
643   const TStr& _CltNm,
644   const TStr& _CltType,
645   const int& HBeatTimerTout,
646   const bool& _AgentP,
647   const TStr& _SrvHostNm,
648   const int& _SrvPortN,
649   const int& CltPortN,
650   const PNotify& Notify):
651    TWebNetSrv(CltPortN, false), 
652    TWebNetCltV(), 
653    Log(TAppCSLog::New(LogFNm, -1, Notify)), 
654    CltNm(_CltNm), 
655    CltType(_CltType), 
656    SrvHostNm(_SrvHostNm), SrvPortN(_SrvPortN), 
657    AgentP(_AgentP), 
658    AgentHostNmPortNPrV(), 
659    HBeatTimer(), 
660    LastHBeatTm(TTm::GetCurUniTm()), 
661    ActiveIsAliveFId(-1), 
662    ActConnBs(TAppCSActConnBs::New()), 
663    SesId(), 
664    State(TAppCSState::New(Log)), 
665    DelayTimer(), 
666    FuncFetchIdH(){ 
667    HBeatTimer=TAppCSTimer::New(TAppCS::F_HBeatTimer,
668     CltNm, HBeatTimerTout, true, this);
669    DelayTimer=TAppCSTimer::New(TAppCS::F_DelayTimer, CltNm, 0, false, this);
670  }
671  TAppClt::~TAppClt(){
672    HBeatTimer->StopTimer();
673  }
674  const int TAppClt::DfPortN=TAppSrv::DfPortN+1;
675  void TAppClt::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
676    TTm CurTm=TTm::GetCurUniTm(); 
677    TStr FetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm);
678    PUrl Url=HttpRq->GetUrl(); 
679    TStr UrlStr=Url->GetUrlStr(); 
680    TStr PeerHostNm=GetPeerHostNm(SockId); 
681    PSoapRq SoapRq=TSoapRq::New(HttpRq); 
682    TStr SoapFuncNm=SoapRq->GetFuncNm();
683    TStr SoapRqMsgStr=UrlStr+" from "+PeerHostNm; 
684    if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
685      PutLogMsg("SoapRequest", SoapRqMsgStr, true);}
686    PHttpResp HttpResp;
687    if (SoapRq->IsOk()){
688      if (SoapFuncNm==TAppCS::F_Info){
689        HttpResp=OnHttpRq_Info();
690      } else
691      if (SoapFuncNm==TAppCS::F_GetStateInfo){
692        HttpResp=OnHttpRq_GetStateInfo(SoapRq);
693      } else
694      if (SoapFuncNm==TAppCS::F_HBeatTimer){
695        OnHttpRq_OnHBeatTimer();
696      } else
697      if ((SoapFuncNm==TAppCS::F_IsAlive)||(SoapFuncNm==TAppCS::F_IsConn)){
698        HttpResp=TSoapResp::GetHttpResp(SoapFuncNm, TAppCS::A_SesId, SesId);
699      } else
700      if (SoapFuncNm==TAppCS::F_RegAgent){
701        HttpResp=OnHttpRq_RegAgent(SoapRq, PeerHostNm);
702      } else {
703        bool RedirP=SoapRq->GetFldVal(TAppCS::A_Redir)=="T";
704        bool AgentP=SoapRq->GetFldVal(TAppCS::A_Agent)=="T";
705        if ((SockId!=-1)&&(!RedirP)&&(!AgentP)&&(!IsSesId())){
706          HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
707           "Session not defined.");
708        } else
709        if ((SockId!=-1)&&(!RedirP)&&(!AgentP)&&
710         (GetSesId()!=SoapRq->GetFldVal(TAppCS::A_SesId))){
711          TStr SesId1=GetSesId();
712          TStr SesId2=SoapRq->GetFldVal(TAppCS::A_SesId);
713          HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
714           "Session-ids don't match.");
715        } else {
716          HttpResp=OnFuncRq(SoapRq);
717        }
718      }
719    } else {
720      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::DataEncodingUnknownCodeNm,
721       "Invalid SOAP HTTP Request.");
722    }
723    if (SockId!=-1){
724      if (HttpResp.Empty()){
725        PutLogMsg("Warning", TStr("Empty Http-Response for ")+SoapRqMsgStr, true);
726        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, "Empty Response.");
727      }
728      if (!FetchIdStr.Empty()){
729        HttpResp->AddFldVal(THttp::FetchIdFldNm, FetchIdStr);}
730      SendHttpResp(SockId, HttpResp);
731      if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
732        Log->PutLogRec(HttpRq, HttpResp, PeerHostNm);
733        PSoapResp SoapResp=TSoapResp::New(HttpResp);
734        if (SoapResp->IsOk()){
735          PutLogMsg("SoapResponse", SoapResp->GetAsUrlPathStr(), true);
736        }
737      }
738    }
739  }
740  void TAppClt::OnHttpRqError(const int& SockId, const TStr& MsgStr){
741  }
742  TStr TAppClt::GetPeerHostNm(const int& SockId) const {
743    if (SockId==-1){
744      return "internal";
745    } else {
746      TStr PeerHostNm=GetCltSock(SockId)->GetPeerIpNum();
747      if ((PeerHostNm.GetLc()=="localhost")||(PeerHostNm=="127.0.0.1")){
748        PSockHost LocalSockHost=TSockHost::GetLocalSockHost();
749        if (LocalSockHost->IsOk()){
750          return LocalSockHost->GetIpNum();
751        } else {
752          return PeerHostNm;
753        }
754      } else {
755        return PeerHostNm;
756      }
757    }
758  }
759  PHttpResp TAppClt::OnHttpRq_Info() const {
760    TTm CurTm=TTm::GetCurUniTm();
761    TChA HtmlChA;
762    HtmlChA+="<html><head><title>Application Client Status</title></head>";
763    HtmlChA+="<body>";
764    HtmlChA+="<h1>Application Client Status</h1>";
765    HtmlChA+="GMT-Time: ";
766    HtmlChA+=CurTm.GetWebLogDateStr()+" "+CurTm.GetWebLogTimeStr();
767    HtmlChA+="<br>";
768    HtmlChA+="Client Port: ";
769    HtmlChA+=TInt::GetStr(GetPortN());
770    HtmlChA+="<br>";
771    HtmlChA+="Client Up-Time (secs): ";
772    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetSecs());
773    HtmlChA+="<br>";
774    HtmlChA+="Server-Host-Name: ";
775    HtmlChA+=GetSrvHostNm();
776    HtmlChA+="<br>";
777    HtmlChA+="Server-Host-Name: ";
778    HtmlChA+=TInt::GetStr(SrvPortN);
779    HtmlChA+="<br>";
780    HtmlChA+="Log-File-Name: ";
781    HtmlChA+=GetLog()->GetLogFNm();
782    HtmlChA+="<br>";
783    HtmlChA+="Heart-Beat-TimeOut (msecs): ";
784    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTimeOut());
785    HtmlChA+="<br>";
786    HtmlChA+="Heart-Beat-Ticks: ";
787    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTicks());
788    HtmlChA+="<br>";
789    HtmlChA+="</body>";
790    HtmlChA+="</html>";
791    PHttpResp HttpResp=THttpResp::New(
792     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, TStrIn::New(HtmlChA));
793    return HttpResp;
794  }
795  PHttpResp TAppClt::OnHttpRq_GetStateInfo(const PSoapRq& SoapRq) const {
796    PSoapResp SoapResp=TSoapResp::New(SoapRq->GetFuncNm());
797    SoapResp->AddFldNmVal("StateId", State->GetStateId());
798    return SoapResp->GetHttpResp();
799  }
800  void TAppClt::OnHttpRq_OnHBeatTimer(){
801    if (IsSesId()){
802      if (ActiveIsAliveFId==-1){
803        ActiveIsAliveFId=FetchSoapRq(TSoapRq::New(TAppCS::F_IsAlive));
804      }
805    }
806  }
807  PHttpResp TAppClt::OnHttpRq_RegAgent(
808   const PSoapRq& SoapRq, const TStr& PeerHostNm){
809    TStr AgentHostNm=PeerHostNm;
810    int AgentPortN=SoapRq->GetFldVal(TAppCS::A_PortN).GetInt(0);
811    AgentHostNmPortNPrV.AddUnique(TStrIntPr(AgentHostNm, AgentPortN));
812    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm(), TAppCS::A_Result, "T");
813  }
814  void TAppClt::OnHttpResp(const int& FetchId, const PHttpResp& HttpResp){
815    PAppCSActConn ActConn=ActConnBs->GetActConn(FetchId);
816    PSoapRq SoapRq=ActConn->GetSoapRq();
817    TStr SoapFuncNm=SoapRq->GetFuncNm();
818    PSoapResp SoapResp=TSoapResp::New(HttpResp);
819    ActConnBs->DelActConn(FetchId);
820    if (ActConn->GetRetryCnt()!=3) {
821      PutLogMsg("OnFetch",
822       TStr::Fmt("[FetchId:%d] %s", FetchId,
823        (TStr()+"SoapRq retry count="+TInt::GetStr(3-ActConn->GetRetryCnt())).CStr()), false);
824    }
825    if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
826      PutLogMsg("OnFetch",
827       TStr::Fmt("[FetchId:%d] %s", FetchId, SoapResp->GetAsUrlPathStr().CStr()), false);
828    }
829    if (!SoapResp->IsOk()){
830      PHttpResp HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
831       "Invalid SOAP Response format.");
832      SoapResp=TSoapResp::New(HttpResp);
833    }
834    if ((ActiveIsAliveFId!=-1)&&(FetchId==ActiveIsAliveFId)){
835      TStr SoapRespFuncNm=SoapResp->GetFuncNm();
836      if (SoapRespFuncNm==TAppCS::F_IsAlive){
837        LastHBeatTm=TTm::GetCurUniTm(); 
838        ActiveIsAliveFId=-1; 
839      } else {
840        SesId=""; 
841        ActiveIsAliveFId=-1; 
842        SetState(TAppCS::S_Start); 
843      }
844    }
845    SoapResp->AddFldNmVal(TAppCS::A_FetchId, TInt::GetStr(FetchId));
846    OnFetchSoapResp(SoapRq, SoapResp);
847  }
848  void TAppClt::OnHttpRespError(const int& FetchId, const TStr& MsgStr){
849    PAppCSActConn ActConn=ActConnBs->GetActConn(FetchId);
850    PSoapRq SoapRq=ActConn->GetSoapRq();
851    int RetryCnt=ActConn->GetRetryCnt();
852    if (--RetryCnt>0) {
853      ActConnBs->DelActConn(FetchId);
854      IAssert(FetchId==FetchSoapRq(SoapRq,ActConn->GetHostNm(),ActConn->GetPortN(),RetryCnt,FetchId));
855      return;
856    }
857    PHttpResp HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, MsgStr);
858    PSoapResp SoapResp=TSoapResp::New(HttpResp);
859    PutLogMsg("OnFetchError",
860     TStr::Fmt("[FetchId:%d] %s", FetchId, MsgStr.CStr()), false);
861    if ((ActiveIsAliveFId!=-1)&&(FetchId==ActiveIsAliveFId)){
862      SesId=""; 
863      ActiveIsAliveFId=-1; 
864      SetState(TAppCS::S_Start); 
865    }
866    ActConnBs->DelActConn(FetchId);
867    SoapResp->AddFldNmVal(TAppCS::A_FetchId, TInt::GetStr(FetchId));
868    OnFetchSoapResp(SoapRq, SoapResp);
869  }
870  int TAppClt::FetchSoapRq(
871   const PSoapRq& SoapRq, const TStr& HostNm, const int& PortN, const int &RetryCnt, const int &_FetchId){
872    if (IsSesId()){
873      SoapRq->AddFldNmVal(TAppCS::A_SesId, GetSesId());}
874    if (IsAgent()){
875      SoapRq->AddFldNmVal(TAppCS::A_Agent, "T");}
876    PUrl SoapRqUrl;
877    if (HostNm.Empty()){
878      SoapRqUrl=SoapRq->GetAsUrl(SrvHostNm, SrvPortN);
879    } else {
880      SoapRqUrl=SoapRq->GetAsUrl(HostNm, PortN);
881    }
882  #if 0
883    TStr CltNm, FuncNm=SoapRq->GetFuncNm();
884    if ((FuncNm!=TAppCS::F_Connect)&&SoapRq->IsFldNm(TAppCS::A_CltNm)){
885      CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
886    }
887    if (CltNm.Empty()){
888      TStr _CltFuncNm;
889      FuncNm.SplitOnStr(CltNm, "::", _CltFuncNm);
890      if (_CltFuncNm.Empty()) CltNm.Clr();
891    }
892    int FetchId=FetchUrl(SoapRqUrl,_FetchId,CltNm);
893  #else
894    int FetchId=FetchUrl(SoapRqUrl,_FetchId);
895  #endif  
896    if (TAppSrv::IsLogSoapFuncNm(SoapRq->GetFuncNm())){
897      PutLogMsg("FetchSoapRq",
898       TInt::GetStr(FetchId, "[FetchId:%d]")+SoapRq->GetAsUrlPathStr(), false);
899    }
900    ActConnBs->AddActConn(FetchId,
901     TAppCSActConn::New(SoapRq, SoapRqUrl->GetHostNm(), SoapRqUrl->GetPortN(), RetryCnt));
902    return FetchId;
903  }
904  void TAppClt::OnFetchSoapResp(const PSoapRq& SoapRq, const PSoapResp& SoapResp){
905    IAssert(SoapRq->IsOk());
906    IAssert(SoapResp->IsOk());
907    if (SoapResp->IsResult()){
908      TStr SoapRespFuncNm=SoapResp->GetFuncNm();
909      if (SoapRespFuncNm==TAppCS::F_Connect){
910        SesId=SoapResp->GetFldVal(TAppCS::A_SesId); 
911        OnStateExe(setSoapResp, SoapRq, SoapResp); 
912      } else
913      if (SoapRespFuncNm==TAppCS::F_IsAlive){
914      } else
915      if (SoapRespFuncNm==TAppCS::F_NotifyStateChange){
916      } else
917      if (SoapRespFuncNm==TAppCS::F_NotifyEvent){
918      } else
919      if (SoapRespFuncNm==TAppCS::F_Log){
920      } else {
921        OnFuncResp(SoapRq, SoapResp);
922      }
923    } else {
924      IAssert(SoapResp->IsFault());
925      OnStateExe(setSoapResp, SoapRq, SoapResp); 
926    }
927  }
928  void TAppClt::PutLogMsg(
929   const TStr& MsgType, const TStr& MsgStr, const bool& SendToSrvP){
930    Log->PutLogMsg(MsgType, MsgStr);
931    if ((false)&&(SendToSrvP)){
932      FetchSoapRq(TSoapRq::New(TAppCS::F_Log,
933       TAppCS::A_LogNm, CltNm,
934       TAppCS::A_MsgType, MsgType,
935       TAppCS::A_Msg, MsgStr));
936    }
937  }
938  PHttpResp TAppClt::OnConnectRqAndResp(
939   const TStr& NextSId,
940   const TAppCsSET& ExeType, const PSoapRq& SoapRq, const PSoapResp& SoapResp,
941   bool& BreakLoopP){
942    PAppCSLog Log; PAppCSState State; TStr StateId;
943    TStr RqFuncNm; TStr RespFuncNm; TStr RespFetchId; bool RespResultP;
944    GetStateExeShortcuts(Log, State, StateId,
945     SoapRq, RqFuncNm, SoapResp, RespFuncNm, RespFetchId, RespResultP);
946    BreakLoopP=true;
947    if (StateId==TAppCS::S_ConnectRq){
948      if (IsSesId()){
949        SesId="";
950      }
951      FetchSoapRqSaveFId(TSoapRq::New(TAppCS::F_Connect,
952       TAppCS::A_PortN, TInt::GetStr(GetPortN()),
953       TAppCS::A_CltNm, GetCltNm()));
954      SetState(TAppCS::S_ConnectResp);
955      return NULL;
956    } else
957    if (StateId==TAppCS::S_ConnectResp){
958      if ((GetFId(TAppCS::F_Connect)==RespFetchId)&&(RespResultP)){
959        SetState(NextSId);
960      } else {
961        StartDelayTimer();
962        SetState(TAppCS::S_ConnectRq);
963        return NULL;
964      }
965    }
966    BreakLoopP=false;
967    return NULL;
968  }
969  void TAppClt::StartDelayTimer(const int& DelayTout){
970    if (DelayTout==-1){
971      DelayTimer->StartTimer(TAppCS::DTmrA_DelayTimerTout);
972    } else {
973      DelayTimer->StartTimer(DelayTout);
974    }
975  }
976  void TAppClt::StopDelayTimer(){
977    DelayTimer->StopTimer();
978  }
979  int TAppClt::FetchSoapRqSaveFId(
980   const PSoapRq& SoapRq, const TStr& HostNm, const int& PortN){
981    int FetchId=FetchSoapRq(SoapRq, HostNm, PortN);
982    PutFId(SoapRq->GetFuncNm(), TInt::GetStr(FetchId));
983    return FetchId;
984  }
985  void TAppClt::GetStateExeShortcuts(
986   PAppCSLog& Log,
987   PAppCSState& State, TStr& StateId,
988   const PSoapRq& SoapRq, TStr& SoapRqFuncNm,
989   const PSoapResp& SoapResp, TStr& SoapRespFuncNm, TStr& SoapRespFetchId,
990   bool& SoapRespResultP){
991    Log=GetLog();
992    State=GetState();
993    StateId=State->GetStateId();
994    if (SoapRq.Empty()){
995      SoapRqFuncNm="";
996    } else {
997      SoapRqFuncNm=SoapRq->GetFuncNm();
998    }
999    if (SoapResp.Empty()){
1000      SoapRespFuncNm="";
1001      SoapRespFetchId="";
1002      SoapRespResultP=false;
1003    } else {
1004      SoapRespFuncNm=SoapResp->GetFuncNm();
1005      SoapRespFetchId=SoapResp->GetFldVal(TAppCS::A_FetchId);
1006      SoapRespResultP=SoapResp->IsResult();
1007    }
1008  }
1009  void TAppClt::BroadcastToAgents(const PSoapRq& SoapRq){
1010    if (GetAgents()>0){
1011      SoapRq->AddFldNmVal(TAppCS::A_Agent, "T");
1012      for (int AgentN=0; AgentN<GetAgents(); AgentN++){
1013        TStr HostNm; int PortN; GetAgentHostNmPortN(AgentN, HostNm, PortN);
1014        FetchSoapRq(SoapRq, HostNm, PortN);
1015      }
1016    }
1017  }
1018  void TAppClt::SetState(const TStr& StateId, const TStr& MsgStr,
1019   const TStr& TbNm1, const PSoapTb& Tb1,
1020   const TStr& TbNm2, const PSoapTb& Tb2){
1021    TStr OldStateId=State->GetStateId();
1022    State->SetState(StateId);
1023    TStr NewStateId=State->GetStateId();
1024    if (GetAgents()>0){
1025    }
1026  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_11.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/cli.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <nano/nano_node/daemon.hpp>
5  #include <nano/node/cli.hpp>
6  #include <nano/node/daemonconfig.hpp>
7  #include <nano/node/ipc/ipc_server.hpp>
8  #include <nano/node/json_handler.hpp>
9  #include <nano/node/node.hpp>
10  #include <nano/node/transport/inproc.hpp>
11  #include <boost/dll/runtime_symbol_info.hpp>
12  #include <boost/filesystem/operations.hpp>
13  #include <boost/format.hpp>
14  #include <boost/lexical_cast.hpp>
15  #include <boost/program_options.hpp>
16  #include <boost/range/adaptor/reversed.hpp>
17  #ifdef _WIN32
18  #ifndef NOMINMAX
19  #define NOMINMAX
20  #endif
21  #endif
22  #include <boost/stacktrace.hpp>
23  #include <boost/unordered_map.hpp>
24  #include <boost/unordered_set.hpp>
25  #include <numeric>
26  #include <sstream>
27  #include <argon2.h>
28  namespace
29  {
30  class uint64_from_hex 
31  {
32  public:
33  	uint64_t value;
34  };
35  std::istream & operator>> (std::istream & in, uint64_from_hex & out_val);
36  class address_library_pair
37  {
38  public:
39  	uint64_t address;
40  	std::string library;
41  	address_library_pair (uint64_t address, std::string library);
42  	bool operator< (const address_library_pair & other) const;
43  	bool operator== (const address_library_pair & other) const;
44  };
45  }
46  int main (int argc, char * const * argv)
47  {
48  	nano::set_umask ();
49  	nano::node_singleton_memory_pool_purge_guard memory_pool_cleanup_guard;
50  	boost::program_options::options_description description ("Command line options");
<span onclick='openModal()' class='match'>51  	description.add_options ()
51  	description.add_options ()
</span>52  		("help", "Print out options")
53  		("version", "Prints out version")
54  		("config", boost::program_options::value<std::vector<nano::config_key_value_pair>>()->multitoken(), "Pass node configuration values. This takes precedence over any values in the configuration file. This option can be repeated multiple times.")
55  		("rpcconfig", boost::program_options::value<std::vector<nano::config_key_value_pair>>()->multitoken(), "Pass rpc configuration values. This takes precedence over any values in the configuration file. This option can be repeated multiple times.")
56  		("daemon", "Start node daemon")
57  		("compare_rep_weights", "Display a summarized comparison between the hardcoded bootstrap weights and representative weights from the ledger. Full comparison is output to logs")
58  		("debug_block_dump", "Display all the blocks in the ledger in text format")
59  		("debug_block_count", "Display the number of blocks")
60  		("debug_bootstrap_generate", "Generate bootstrap sequence of blocks")
61  		("debug_dump_frontier_unchecked_dependents", "Dump frontiers which have matching unchecked keys")
62  		("debug_dump_trended_weight", "Dump trended weights table")
63  		("debug_dump_representatives", "List representatives and weights")
64  		("debug_account_count", "Display the number of accounts")
65  		("debug_profile_generate", "Profile work generation")
66  		("debug_profile_validate", "Profile work validation")
67  		("debug_opencl", "OpenCL work generation")
68  		("debug_profile_kdf", "Profile kdf function")
69  		("debug_output_last_backtrace_dump", "Displays the contents of the latest backtrace in the event of a nano_node crash")
70  		("debug_generate_crash_report", "Consolidates the nano_node_backtrace.dump file. Requires addr2line installed on Linux")
71  		("debug_sys_logging", "Test the system logger")
72  		("debug_verify_profile", "Profile signature verification")
73  		("debug_verify_profile_batch", "Profile batch signature verification")
74  		("debug_profile_bootstrap", "Profile bootstrap style blocks processing (at least 10GB of free storage space required)")
75  		("debug_profile_sign", "Profile signature generation")
76  		("debug_profile_process", "Profile active blocks processing (only for nano_dev_network)")
77  		("debug_profile_votes", "Profile votes processing (only for nano_dev_network)")
78  		("debug_profile_frontiers_confirmation", "Profile frontiers confirmation speed (only for nano_dev_network)")
79  		("debug_random_feed", "Generates output to RNG test suites")
80  		("debug_rpc", "Read an RPC command from stdin and invoke it. Network operations will have no effect.")
81  		("debug_peers", "Display peer IPv6:port connections")
82  		("debug_cemented_block_count", "Displays the number of cemented (confirmed) blocks")
83  		("debug_stacktrace", "Display an example stacktrace")
84  		("debug_account_versions", "Display the total counts of each version for all accounts (including unpocketed)")
85  		("debug_unconfirmed_frontiers", "Displays the account, height (sorted), frontier and cemented frontier for all accounts which are not fully confirmed")
86  		("validate_blocks,debug_validate_blocks", "Check all blocks for correct hash, signature, work value")
87  		("debug_prune", "Prune accounts up to last confirmed blocks (EXPERIMENTAL)")
88  		("platform", boost::program_options::value<std::string> (), "Defines the <platform> for OpenCL commands")
89  		("device", boost::program_options::value<std::string> (), "Defines <device> for OpenCL command")
90  		("threads", boost::program_options::value<std::string> (), "Defines <threads> count for various commands")
91  		("difficulty", boost::program_options::value<std::string> (), "Defines <difficulty> for OpenCL command, HEX")
92  		("multiplier", boost::program_options::value<std::string> (), "Defines <multiplier> for work generation. Overrides <difficulty>")
93  		("count", boost::program_options::value<std::string> (), "Defines <count> for various commands")
94  		("pow_sleep_interval", boost::program_options::value<std::string> (), "Defines the amount to sleep inbetween each pow calculation attempt")
95  		("address_column", boost::program_options::value<std::string> (), "Defines which column the addresses are located, 0 indexed (check --debug_output_last_backtrace_dump output)")
96  		("silent", "Silent command execution");
97  	nano::add_node_options (description);
98  	nano::add_node_flag_options (description);
99  	boost::program_options::variables_map vm;
100  	try
101  	{
102  		boost::program_options::store (boost::program_options::parse_command_line (argc, argv, description), vm);
103  	}
104  	catch (boost::program_options::error const & err)
105  	{
106  		std::cerr << err.what () << std::endl;
107  		return 1;
108  	}
109  	boost::program_options::notify (vm);
110  	int result (0);
111  	auto network (vm.find ("network"));
112  	if (network != vm.end ())
113  	{
114  		auto err (nano::network_constants::set_active_network (network->second.as<std::string> ()));
115  		if (err)
116  		{
117  			std::cerr << nano::network_constants::active_network_err_msg << std::endl;
118  			std::exit (1);
119  		}
120  	}
121  	nano::network_params network_params{ nano::network_constants::active_network };
122  	auto data_path_it = vm.find ("data_path");
123  	boost::filesystem::path data_path ((data_path_it != vm.end ()) ? data_path_it->second.as<std::string> () : nano::working_path ());
124  	auto ec = nano::handle_node_options (vm);
125  	if (ec == nano::error_cli::unknown_command)
126  	{
127  		if (vm.count ("daemon") > 0)
128  		{
129  			nano_daemon::daemon daemon;
130  			nano::node_flags flags;
131  			auto flags_ec = nano::update_flags (flags, vm);
132  			if (flags_ec)
133  			{
134  				std::cerr << flags_ec.message () << std::endl;
135  				std::exit (1);
136  			}
137  			daemon.run (data_path, flags);
138  		}
139  		else if (vm.count ("compare_rep_weights"))
140  		{
141  			if (nano::network_constants::active_network != nano::networks::nano_dev_network)
142  			{
143  				auto node_flags = nano::inactive_node_flag_defaults ();
144  				nano::update_flags (node_flags, vm);
145  				node_flags.generate_cache.reps = true;
146  				nano::inactive_node inactive_node (data_path, node_flags);
147  				auto node = inactive_node.node;
148  				auto const bootstrap_weights = node->get_bootstrap_weights ();
149  				auto const & hardcoded = bootstrap_weights.second;
150  				auto const hardcoded_height = bootstrap_weights.first;
151  				auto const ledger_unfiltered = node->ledger.cache.rep_weights.get_rep_amounts ();
152  				auto const ledger_height = node->ledger.cache.block_count.load ();
153  				auto get_total = [] (decltype (bootstrap_weights.second) const & reps) -> nano::uint128_union {
154  					return std::accumulate (reps.begin (), reps.end (), nano::uint128_t{ 0 }, [] (auto sum, auto const & rep) { return sum + rep.second; });
155  				};
156  				std::remove_const_t<decltype (ledger_unfiltered)> ledger;
157  				{
158  					std::vector<std::pair<nano::account, nano::uint128_t>> sorted;
159  					sorted.reserve (ledger_unfiltered.size ());
160  					std::copy (ledger_unfiltered.begin (), ledger_unfiltered.end (), std::back_inserter (sorted));
161  					std::sort (sorted.begin (), sorted.end (), [] (auto const & left, auto const & right) { return left.second > right.second; });
162  					auto const total_unfiltered = get_total (ledger_unfiltered);
163  					nano::uint128_t sum{ 0 };
164  					auto target = (total_unfiltered.number () / 100) * 99;
165  					for (auto i (sorted.begin ()), n (sorted.end ()); i != n && sum <= target; sum += i->second, ++i)
166  					{
167  						ledger.insert (*i);
168  					}
169  				}
170  				auto const total_ledger = get_total (ledger);
171  				auto const total_hardcoded = get_total (hardcoded);
172  				struct mismatched_t
173  				{
174  					nano::account rep;
175  					nano::uint128_union hardcoded;
176  					nano::uint128_union ledger;
177  					nano::uint128_union diff;
178  					std::string get_entry () const
179  					{
180  						return boost::str (boost::format ("representative %1% hardcoded %2% ledger %3% mismatch %4%")
181  						% rep.to_account () % hardcoded.format_balance (nano::Mxrb_ratio, 0, true) % ledger.format_balance (nano::Mxrb_ratio, 0, true) % diff.format_balance (nano::Mxrb_ratio, 0, true));
182  					}
183  				};
184  				std::vector<mismatched_t> mismatched;
185  				mismatched.reserve (hardcoded.size ());
186  				std::transform (hardcoded.begin (), hardcoded.end (), std::back_inserter (mismatched), [&ledger] (auto const & rep) {
187  					auto ledger_rep (ledger.find (rep.first));
188  					nano::uint128_t ledger_weight = (ledger_rep == ledger.end () ? 0 : ledger_rep->second);
189  					auto absolute = ledger_weight > rep.second ? ledger_weight - rep.second : rep.second - ledger_weight;
190  					return mismatched_t{ rep.first, rep.second, ledger_weight, absolute };
191  				});
192  				std::sort (mismatched.begin (), mismatched.end (), [] (mismatched_t const & left, mismatched_t const & right) { return left.diff > right.diff; });
193  				nano::uint128_union const mismatch_total = std::accumulate (mismatched.begin (), mismatched.end (), nano::uint128_t{ 0 }, [] (auto sum, mismatched_t const & sample) { return sum + sample.diff.number (); });
194  				nano::uint128_union const mismatch_mean = mismatch_total.number () / mismatched.size ();
195  				nano::uint512_union mismatch_variance = std::accumulate (mismatched.begin (), mismatched.end (), nano::uint512_t (0), [M = mismatch_mean.number (), N = mismatched.size ()] (nano::uint512_t sum, mismatched_t const & sample) {
196  					auto x = sample.diff.number ();
197  					nano::uint512_t const mean_diff = x > M ? x - M : M - x;
198  					nano::uint512_t const sqr = mean_diff * mean_diff;
199  					return sum + sqr;
200  				})
201  				/ mismatched.size ();
202  				nano::uint128_union const mismatch_stddev = nano::narrow_cast<nano::uint128_t> (boost::multiprecision::sqrt (mismatch_variance.number ()));
203  				auto const outlier_threshold = std::max (nano::Gxrb_ratio, mismatch_mean.number () + 1 * mismatch_stddev.number ());
204  				decltype (mismatched) outliers;
205  				std::copy_if (mismatched.begin (), mismatched.end (), std::back_inserter (outliers), [outlier_threshold] (mismatched_t const & sample) {
206  					return sample.diff > outlier_threshold;
207  				});
208  				auto const newcomer_threshold = std::max (nano::Gxrb_ratio, mismatch_mean.number ());
209  				std::vector<std::pair<nano::account, nano::uint128_t>> newcomers;
210  				std::copy_if (ledger.begin (), ledger.end (), std::back_inserter (newcomers), [&hardcoded] (auto const & rep) {
211  					return !hardcoded.count (rep.first) && rep.second;
212  				});
213  				std::sort (newcomers.begin (), newcomers.end (), [] (auto const & left, auto const & right) { return left.second > right.second; });
214  				auto newcomer_entry = [] (auto const & rep) {
215  					return boost::str (boost::format ("representative %1% hardcoded --- ledger %2%") % rep.first.to_account () % nano::uint128_union (rep.second).format_balance (nano::Mxrb_ratio, 0, true));
216  				};
217  				std::cout << boost::str (boost::format ("hardcoded weight %1% Mnano at %2% blocks\nledger weight %3% Mnano at %4% blocks\nmismatched\n\tsamples %5%\n\ttotal %6% Mnano\n\tmean %7% Mnano\n\tsigma %8% Mnano\n")
218  				% total_hardcoded.format_balance (nano::Mxrb_ratio, 0, true)
219  				% hardcoded_height
220  				% total_ledger.format_balance (nano::Mxrb_ratio, 0, true)
221  				% ledger_height
222  				% mismatched.size ()
223  				% mismatch_total.format_balance (nano::Mxrb_ratio, 0, true)
224  				% mismatch_mean.format_balance (nano::Mxrb_ratio, 0, true)
225  				% mismatch_stddev.format_balance (nano::Mxrb_ratio, 0, true));
226  				if (!outliers.empty ())
227  				{
228  					std::cout << "outliers\n";
229  					for (auto const & outlier : outliers)
230  					{
231  						std::cout << '\t' << outlier.get_entry () << '\n';
232  					}
233  				}
234  				if (!newcomers.empty ())
235  				{
236  					std::cout << "newcomers\n";
237  					for (auto const & newcomer : newcomers)
238  					{
239  						if (newcomer.second > newcomer_threshold)
240  						{
241  							std::cout << '\t' << newcomer_entry (newcomer) << '\n';
242  						}
243  					}
244  				}
245  				auto const log_threshold = nano::Gxrb_ratio;
246  				for (auto const & sample : mismatched)
247  				{
248  					if (sample.diff > log_threshold)
249  					{
250  						node->logger.always_log (sample.get_entry ());
251  					}
252  				}
253  				for (auto const & newcomer : newcomers)
254  				{
255  					if (newcomer.second > log_threshold)
256  					{
257  						node->logger.always_log (newcomer_entry (newcomer));
258  					}
259  				}
260  			}
261  			else
262  			{
263  				std::cout << "Not available for the test network" << std::endl;
264  				result = -1;
265  			}
266  		}
267  		else if (vm.count ("debug_block_dump"))
268  		{
269  			auto inactive_node = nano::default_inactive_node (data_path, vm);
270  			auto transaction = inactive_node->node->store.tx_begin_read ();
271  			auto i = inactive_node->node->store.block.begin (transaction);
272  			auto end = inactive_node->node->store.block.end ();
273  			for (; i != end; ++i)
274  			{
275  				nano::block_hash hash = i->first;
276  				nano::block_w_sideband sideband = i->second;
277  				std::shared_ptr<nano::block> b = sideband.block;
278  				std::cout << hash.to_string () << std::endl
279  						  << b->to_json ();
280  			}
281  		}
282  		else if (vm.count ("debug_block_count"))
283  		{
284  			auto node_flags = nano::inactive_node_flag_defaults ();
285  			nano::update_flags (node_flags, vm);
286  			node_flags.generate_cache.block_count = true;
287  			nano::inactive_node inactive_node (data_path, node_flags);
288  			auto node = inactive_node.node;
289  			std::cout << boost::str (boost::format ("Block count: %1%\n") % node->ledger.cache.block_count);
290  		}
291  		else if (vm.count ("debug_bootstrap_generate"))
292  		{
293  			auto key_it = vm.find ("key");
294  			if (key_it != vm.end ())
295  			{
296  				nano::uint256_union key;
297  				if (!key.decode_hex (key_it->second.as<std::string> ()))
298  				{
299  					nano::keypair genesis (key.to_string ());
300  					nano::work_pool work{ network_params.network, std::numeric_limits<unsigned>::max () };
301  					std::cout << "Genesis: " << genesis.prv.to_string () << "\n"
302  							  << "Public: " << genesis.pub.to_string () << "\n"
303  							  << "Account: " << genesis.pub.to_account () << "\n";
304  					nano::keypair landing;
305  					std::cout << "Landing: " << landing.prv.to_string () << "\n"
306  							  << "Public: " << landing.pub.to_string () << "\n"
307  							  << "Account: " << landing.pub.to_account () << "\n";
308  					for (auto i (0); i != 32; ++i)
309  					{
310  						nano::keypair rep;
311  						std::cout << "Rep" << i << ": " << rep.prv.to_string () << "\n"
312  								  << "Public: " << rep.pub.to_string () << "\n"
313  								  << "Account: " << rep.pub.to_account () << "\n";
314  					}
315  					nano::uint128_t balance (std::numeric_limits<nano::uint128_t>::max ());
316  					nano::open_block genesis_block (reinterpret_cast<nano::block_hash const &> (genesis.pub), genesis.pub, genesis.pub, genesis.prv, genesis.pub, *work.generate (nano::work_version::work_1, genesis.pub, network_params.work.epoch_1));
317  					std::cout << genesis_block.to_json ();
318  					std::cout.flush ();
319  					nano::block_hash previous (genesis_block.hash ());
320  					for (auto i (0); i != 8; ++i)
321  					{
322  						nano::uint128_t yearly_distribution (nano::uint128_t (1) << (127 - (i == 7 ? 6 : i)));
323  						auto weekly_distribution (yearly_distribution / 52);
324  						for (auto j (0); j != 52; ++j)
325  						{
326  							debug_assert (balance > weekly_distribution);
327  							balance = balance < (weekly_distribution * 2) ? 0 : balance - weekly_distribution;
328  							nano::send_block send (previous, landing.pub, balance, genesis.prv, genesis.pub, *work.generate (nano::work_version::work_1, previous, network_params.work.epoch_1));
329  							previous = send.hash ();
330  							std::cout << send.to_json ();
331  							std::cout.flush ();
332  						}
333  					}
334  				}
335  				else
336  				{
337  					std::cerr << "Invalid key\n";
338  					result = -1;
339  				}
340  			}
341  			else
342  			{
343  				std::cerr << "Bootstrapping requires one <key> option\n";
344  				result = -1;
345  			}
346  		}
347  		else if (vm.count ("debug_dump_trended_weight"))
348  		{
349  			auto inactive_node = nano::default_inactive_node (data_path, vm);
350  			auto node = inactive_node->node;
351  			auto current (node->online_reps.trended ());
352  			std::cout << boost::str (boost::format ("Trended Weight %1%\n") % current);
353  			auto transaction (node->store.tx_begin_read ());
354  			for (auto i (node->store.online_weight.begin (transaction)), n (node->store.online_weight.end ()); i != n; ++i)
355  			{
356  				using time_point = std::chrono::system_clock::time_point;
357  				time_point ts (std::chrono::duration_cast<time_point::duration> (std::chrono::nanoseconds (i->first)));
358  				std::time_t timestamp = std::chrono::system_clock::to_time_t (ts);
359  				std::string weight;
360  				i->second.encode_dec (weight);
361  				std::cout << boost::str (boost::format ("Timestamp %1% Weight %2%\n") % ctime (&timestamp) % weight);
362  			}
363  		}
364  		else if (vm.count ("debug_dump_representatives"))
365  		{
366  			auto node_flags = nano::inactive_node_flag_defaults ();
367  			nano::update_flags (node_flags, vm);
368  			node_flags.generate_cache.reps = true;
369  			nano::inactive_node inactive_node (data_path, node_flags);
370  			auto node = inactive_node.node;
371  			auto transaction (node->store.tx_begin_read ());
372  			nano::uint128_t total;
373  			auto rep_amounts = node->ledger.cache.rep_weights.get_rep_amounts ();
374  			std::map<nano::account, nano::uint128_t> ordered_reps (rep_amounts.begin (), rep_amounts.end ());
375  			for (auto const & rep : ordered_reps)
376  			{
377  				total += rep.second;
378  				std::cout << boost::str (boost::format ("%1% %2% %3%\n") % rep.first.to_account () % rep.second.convert_to<std::string> () % total.convert_to<std::string> ());
379  			}
380  		}
381  		else if (vm.count ("debug_dump_frontier_unchecked_dependents"))
382  		{
383  			auto inactive_node = nano::default_inactive_node (data_path, vm);
384  			auto node = inactive_node->node;
385  			std::cout << "Outputting any frontier hashes which have associated key hashes in the unchecked table (may take some time)...\n";
386  			auto transaction (node->store.tx_begin_read ());
387  			std::unordered_set<nano::block_hash> frontier_hashes;
388  			for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
389  			{
390  				frontier_hashes.insert (i->second.head);
391  			}
392  			node->unchecked.for_each ([&frontier_hashes] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
393  				auto it = frontier_hashes.find (key.key ());
394  				if (it != frontier_hashes.cend ())
395  				{
396  					std::cout << it->to_string () << "\n";
397  				}
398  			});
399  		}
400  		else if (vm.count ("debug_account_count"))
401  		{
402  			auto node_flags = nano::inactive_node_flag_defaults ();
403  			nano::update_flags (node_flags, vm);
404  			node_flags.generate_cache.account_count = true;
405  			nano::inactive_node inactive_node (data_path, node_flags);
406  			std::cout << boost::str (boost::format ("Frontier count: %1%\n") % inactive_node.node->ledger.cache.account_count);
407  		}
408  		else if (vm.count ("debug_profile_kdf"))
409  		{
410  			auto inactive_node = nano::default_inactive_node (data_path, vm);
411  			nano::uint256_union result;
412  			nano::uint256_union salt (0);
413  			std::string password ("");
414  			while (true)
415  			{
416  				auto begin1 (std::chrono::high_resolution_clock::now ());
417  				auto success (argon2_hash (1, inactive_node->node->network_params.kdf_work, 1, password.data (), password.size (), salt.bytes.data (), salt.bytes.size (), result.bytes.data (), result.bytes.size (), NULL, 0, Argon2_d, 0x10));
418  				(void)success;
419  				auto end1 (std::chrono::high_resolution_clock::now ());
420  				std::cerr << boost::str (boost::format ("Derivation time: %1%us\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
421  			}
422  		}
423  		else if (vm.count ("debug_profile_generate"))
424  		{
425  			uint64_t difficulty{ nano::work_thresholds::publish_full.base };
426  			auto multiplier_it = vm.find ("multiplier");
427  			if (multiplier_it != vm.end ())
428  			{
429  				try
430  				{
431  					auto multiplier (boost::lexical_cast<double> (multiplier_it->second.as<std::string> ()));
432  					difficulty = nano::difficulty::from_multiplier (multiplier, difficulty);
433  				}
434  				catch (boost::bad_lexical_cast &)
435  				{
436  					std::cerr << "Invalid multiplier\n";
437  					return -1;
438  				}
439  			}
440  			else
441  			{
442  				auto difficulty_it = vm.find ("difficulty");
443  				if (difficulty_it != vm.end ())
444  				{
445  					if (nano::from_string_hex (difficulty_it->second.as<std::string> (), difficulty))
446  					{
447  						std::cerr << "Invalid difficulty\n";
448  						return -1;
449  					}
450  				}
451  			}
452  			auto pow_rate_limiter = std::chrono::nanoseconds (0);
453  			auto pow_sleep_interval_it = vm.find ("pow_sleep_interval");
454  			if (pow_sleep_interval_it != vm.cend ())
455  			{
456  				pow_rate_limiter = std::chrono::nanoseconds (boost::lexical_cast<uint64_t> (pow_sleep_interval_it->second.as<std::string> ()));
457  			}
458  			nano::work_pool work{ network_params.network, std::numeric_limits<unsigned>::max (), pow_rate_limiter };
459  			nano::change_block block (0, 0, nano::keypair ().prv, 0, 0);
460  			if (!result)
461  			{
462  				std::cerr << boost::str (boost::format ("Starting generation profiling. Difficulty: %1$#x (%2%x from base difficulty %3$#x)\n") % difficulty % nano::to_string (nano::difficulty::to_multiplier (difficulty, nano::work_thresholds::publish_full.base), 4) % nano::work_thresholds::publish_full.base);
463  				while (!result)
464  				{
465  					block.hashables.previous.qwords[0] += 1;
466  					auto begin1 (std::chrono::high_resolution_clock::now ());
467  					block.block_work_set (*work.generate (nano::work_version::work_1, block.root (), difficulty));
468  					auto end1 (std::chrono::high_resolution_clock::now ());
469  					std::cerr << boost::str (boost::format ("%|1$ 12d|\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
470  				}
471  			}
472  		}
473  		else if (vm.count ("debug_profile_validate"))
474  		{
475  			uint64_t difficulty{ nano::work_thresholds::publish_full.base };
476  			std::cerr << "Starting validation profile" << std::endl;
477  			auto start (std::chrono::steady_clock::now ());
478  			bool valid{ false };
479  			nano::block_hash hash{ 0 };
480  			uint64_t count{ 10000000U }; 
481  			for (uint64_t i (0); i < count; ++i)
482  			{
483  				valid = network_params.work.value (hash, i) > difficulty;
484  			}
485  			std::ostringstream oss (valid ? "true" : "false"); 
486  			auto total_time (std::chrono::duration_cast<std::chrono::nanoseconds> (std::chrono::steady_clock::now () - start).count ());
487  			uint64_t average (total_time / count);
488  			std::cout << "Average validation time: " << std::to_string (average) << " ns (" << std::to_string (static_cast<unsigned> (count * 1e9 / total_time)) << " validations/s)" << std::endl;
489  		}
490  		else if (vm.count ("debug_opencl"))
491  		{
492  			bool error (false);
493  			nano::opencl_environment environment (error);
494  			if (!error)
495  			{
496  				unsigned short platform (0);
497  				auto platform_it = vm.find ("platform");
498  				if (platform_it != vm.end ())
499  				{
500  					try
501  					{
502  						platform = boost::lexical_cast<unsigned short> (platform_it->second.as<std::string> ());
503  					}
504  					catch (boost::bad_lexical_cast &)
505  					{
506  						std::cerr << "Invalid platform id\n";
507  						return -1;
508  					}
509  				}
510  				unsigned short device (0);
511  				auto device_it = vm.find ("device");
512  				if (device_it != vm.end ())
513  				{
514  					try
515  					{
516  						device = boost::lexical_cast<unsigned short> (device_it->second.as<std::string> ());
517  					}
518  					catch (boost::bad_lexical_cast &)
519  					{
520  						std::cerr << "Invalid device id\n";
521  						return -1;
522  					}
523  				}
524  				unsigned threads (1024 * 1024);
525  				auto threads_it = vm.find ("threads");
526  				if (threads_it != vm.end ())
527  				{
528  					try
529  					{
530  						threads = boost::lexical_cast<unsigned> (threads_it->second.as<std::string> ());
531  					}
532  					catch (boost::bad_lexical_cast &)
533  					{
534  						std::cerr << "Invalid threads count\n";
535  						return -1;
536  					}
537  				}
538  				uint64_t difficulty (nano::work_thresholds::publish_full.base);
539  				auto multiplier_it = vm.find ("multiplier");
540  				if (multiplier_it != vm.end ())
541  				{
542  					try
543  					{
544  						auto multiplier (boost::lexical_cast<double> (multiplier_it->second.as<std::string> ()));
545  						difficulty = nano::difficulty::from_multiplier (multiplier, difficulty);
546  					}
547  					catch (boost::bad_lexical_cast &)
548  					{
549  						std::cerr << "Invalid multiplier\n";
550  						return -1;
551  					}
552  				}
553  				else
554  				{
555  					auto difficulty_it = vm.find ("difficulty");
556  					if (difficulty_it != vm.end ())
557  					{
558  						if (nano::from_string_hex (difficulty_it->second.as<std::string> (), difficulty))
559  						{
560  							std::cerr << "Invalid difficulty\n";
561  							return -1;
562  						}
563  					}
564  				}
565  				if (!result)
566  				{
567  					error |= platform >= environment.platforms.size ();
568  					if (!error)
569  					{
570  						error |= device >= environment.platforms[platform].devices.size ();
571  						if (!error)
572  						{
573  							nano::logger_mt logger;
574  							nano::opencl_config config (platform, device, threads);
575  							auto opencl (nano::opencl_work::create (true, config, logger, network_params.work));
576  							nano::work_pool work_pool{ network_params.network, 0, std::chrono::nanoseconds (0), opencl ? [&opencl] (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, std::atomic<int> &) {
577  														  return opencl->generate_work (version_a, root_a, difficulty_a);
578  													  }
579  																													   : std::function<boost::optional<uint64_t> (nano::work_version const, nano::root const &, uint64_t, std::atomic<int> &)> (nullptr) };
580  							nano::change_block block (0, 0, nano::keypair ().prv, 0, 0);
581  							std::cerr << boost::str (boost::format ("Starting OpenCL generation profiling. Platform: %1%. Device: %2%. Threads: %3%. Difficulty: %4$#x (%5%x from base difficulty %6$#x)\n") % platform % device % threads % difficulty % nano::to_string (nano::difficulty::to_multiplier (difficulty, nano::work_thresholds::publish_full.base), 4) % nano::work_thresholds::publish_full.base);
582  							for (uint64_t i (0); true; ++i)
583  							{
584  								block.hashables.previous.qwords[0] += 1;
585  								auto begin1 (std::chrono::high_resolution_clock::now ());
586  								block.block_work_set (*work_pool.generate (nano::work_version::work_1, block.root (), difficulty));
587  								auto end1 (std::chrono::high_resolution_clock::now ());
588  								std::cerr << boost::str (boost::format ("%|1$ 12d|\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
589  							}
590  						}
591  						else
592  						{
593  							std::cout << "Not available device id\n"
594  									  << std::endl;
595  							result = -1;
596  						}
597  					}
598  					else
599  					{
600  						std::cout << "Not available platform id\n"
601  								  << std::endl;
602  						result = -1;
603  					}
604  				}
605  			}
606  			else
607  			{
608  				std::cout << "Error initializing OpenCL" << std::endl;
609  				result = -1;
610  			}
611  		}
612  		else if (vm.count ("debug_output_last_backtrace_dump"))
613  		{
614  			if (boost::filesystem::exists ("nano_node_backtrace.dump"))
615  			{
616  				std::ifstream ifs ("nano_node_backtrace.dump");
617  				boost::stacktrace::stacktrace st = boost::stacktrace::stacktrace::from_dump (ifs);
618  				std::cout << "Latest crash backtrace:\n"
619  						  << st << std::endl;
620  			}
621  		}
622  		else if (vm.count ("debug_generate_crash_report"))
623  		{
624  			if (boost::filesystem::exists ("nano_node_backtrace.dump"))
625  			{
626  				std::ifstream ifs ("nano_node_backtrace.dump");
627  				boost::stacktrace::stacktrace st = boost::stacktrace::stacktrace::from_dump (ifs);
628  				std::string crash_report_filename = "nano_node_crash_report.txt";
629  #if defined(_WIN32) || defined(__APPLE__)
630  				std::ofstream ofs (crash_report_filename);
631  				ofs << st;
632  #else
633  				boost::system::error_code err;
634  				auto running_executable_filepath = boost::dll::program_location (err);
635  				if (!err)
636  				{
637  					auto num = 0;
638  					auto format = boost::format ("nano_node_crash_load_address_dump_%1%.txt");
639  					std::vector<address_library_pair> base_addresses;
640  					uint64_from_hex base_address;
641  					std::string line;
642  					if (boost::filesystem::exists (boost::str (format % num)))
643  					{
644  						std::getline (std::ifstream (boost::str (format % num)), line);
645  						if (boost::conversion::try_lexical_convert (line, base_address))
646  						{
647  							base_addresses.emplace_back (base_address.value, running_executable_filepath.string ());
648  						}
649  					}
650  					++num;
651  					while (boost::filesystem::exists (boost::str (format % num)))
652  					{
653  						std::ifstream ifs_dump_filename (boost::str (format % num));
654  						std::string dynamic_lib_path;
655  						std::getline (ifs_dump_filename, dynamic_lib_path);
656  						std::getline (ifs_dump_filename, line);
657  						if (boost::conversion::try_lexical_convert (line, base_address))
658  						{
659  							base_addresses.emplace_back (base_address.value, dynamic_lib_path);
660  						}
661  						++num;
662  					}
663  					std::sort (base_addresses.begin (), base_addresses.end ());
664  					auto address_column_it = vm.find ("address_column");
665  					auto column = -1;
666  					if (address_column_it != vm.end ())
667  					{
668  						if (!boost::conversion::try_lexical_convert (address_column_it->second.as<std::string> (), column))
669  						{
670  							std::cerr << "Error: Invalid address column\n";
671  							result = -1;
672  						}
673  					}
674  					std::stringstream stacktrace_ss;
675  					stacktrace_ss << st;
676  					std::vector<uint64_t> backtrace_addresses;
677  					while (std::getline (stacktrace_ss, line))
678  					{
679  						std::istringstream iss (line);
680  						std::vector<std::string> results (std::istream_iterator<std::string>{ iss }, std::istream_iterator<std::string> ());
681  						if (column != -1)
682  						{
683  							if (column < results.size ())
684  							{
685  								uint64_from_hex address_hex;
686  								if (boost::conversion::try_lexical_convert (results[column], address_hex))
687  								{
688  									backtrace_addresses.push_back (address_hex.value);
689  								}
690  								else
691  								{
692  									std::cerr << "Error: Address column does not point to valid addresses\n";
693  									result = -1;
694  								}
695  							}
696  							else
697  							{
698  								std::cerr << "Error: Address column too high\n";
699  								result = -1;
700  							}
701  						}
702  						else
703  						{
704  							for (auto const & text : results)
705  							{
706  								uint64_from_hex address_hex;
707  								if (boost::conversion::try_lexical_convert (text, address_hex))
708  								{
709  									backtrace_addresses.push_back (address_hex.value);
710  									break;
711  								}
712  							}
713  						}
714  					}
715  					boost::filesystem::remove (crash_report_filename);
716  					{
717  						std::ofstream ofs (crash_report_filename);
718  						nano::set_secure_perm_file (crash_report_filename);
719  					}
720  					std::vector<int> system_codes;
721  					auto run_addr2line = [&backtrace_addresses, &base_addresses, &system_codes, &crash_report_filename] (bool use_relative_addresses) {
722  						for (auto backtrace_address : backtrace_addresses)
723  						{
724  							for (auto base_address : boost::adaptors::reverse (base_addresses))
725  							{
726  								if (backtrace_address > base_address.address)
727  								{
728  									auto address = use_relative_addresses ? backtrace_address - base_address.address : backtrace_address;
729  									std::stringstream ss;
730  									ss << std::uppercase << std::hex << address;
731  									auto res = std::system (boost::str (boost::format ("addr2line -fCi %1% -e %2% >> %3%") % ss.str () % base_address.library % crash_report_filename).c_str ());
732  									system_codes.push_back (res);
733  									break;
734  								}
735  							}
736  						}
737  					};
738  					run_addr2line (false);
739  					{
740  						std::ofstream ofs (crash_report_filename, std::ios_base::out | std::ios_base::app);
741  						ofs << std::endl
742  							<< "Using relative addresses:" << std::endl; 
743  					}
744  					run_addr2line (true);
745  					if (std::find (system_codes.begin (), system_codes.end (), 0) == system_codes.end ())
746  					{
747  						std::cerr << "Error: Check that addr2line is installed and that nano_node_crash_load_address_dump_*.txt files exist." << std::endl;
748  						result = -1;
749  					}
750  				}
751  				else
752  				{
753  					std::cerr << "Error: Could not determine running executable path" << std::endl;
754  					result = -1;
755  				}
756  #endif
757  				if (result == 0)
758  				{
759  					std::cout << (boost::format ("%1% created") % crash_report_filename).str () << std::endl;
760  				}
761  			}
762  			else
763  			{
764  				std::cerr << "Error: nano_node_backtrace.dump could not be found";
765  				result = -1;
766  			}
767  		}
768  		else if (vm.count ("debug_verify_profile"))
769  		{
770  			nano::keypair key;
771  			nano::uint256_union message;
772  			auto signature = nano::sign_message (key.prv, key.pub, message);
773  			auto begin (std::chrono::high_resolution_clock::now ());
774  			for (auto i (0u); i < 1000; ++i)
775  			{
776  				nano::validate_message (key.pub, message, signature);
777  			}
778  			auto end (std::chrono::high_resolution_clock::now ());
779  			std::cerr << "Signature verifications " << std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count () << std::endl;
780  		}
781  		else if (vm.count ("debug_verify_profile_batch"))
782  		{
783  			nano::keypair key;
784  			size_t batch_count (1000);
785  			nano::uint256_union message;
786  			nano::uint512_union signature (nano::sign_message (key.prv, key.pub, message));
787  			std::vector<unsigned char const *> messages (batch_count, message.bytes.data ());
788  			std::vector<size_t> lengths (batch_count, sizeof (message));
789  			std::vector<unsigned char const *> pub_keys (batch_count, key.pub.bytes.data ());
790  			std::vector<unsigned char const *> signatures (batch_count, signature.bytes.data ());
791  			std::vector<int> verifications;
792  			verifications.resize (batch_count);
793  			auto begin (std::chrono::high_resolution_clock::now ());
794  			nano::validate_message_batch (messages.data (), lengths.data (), pub_keys.data (), signatures.data (), batch_count, verifications.data ());
795  			auto end (std::chrono::high_resolution_clock::now ());
796  			std::cerr << "Batch signature verifications " << std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count () << std::endl;
797  		}
798  		else if (vm.count ("debug_profile_sign"))
799  		{
800  			std::cerr << "Starting blocks signing profiling\n";
801  			while (true)
802  			{
803  				nano::keypair key;
804  				nano::block_builder builder;
805  				nano::block_hash latest (0);
806  				auto begin1 (std::chrono::high_resolution_clock::now ());
807  				for (uint64_t balance (0); balance < 1000; ++balance)
808  				{
809  					auto send = builder
810  								.send ()
811  								.previous (latest)
812  								.destination (key.pub)
813  								.balance (balance)
814  								.sign (key.prv, key.pub)
815  								.work (0)
816  								.build ();
817  					latest = send->hash ();
818  				}
819  				auto end1 (std::chrono::high_resolution_clock::now ());
820  				std::cerr << boost::str (boost::format ("%|1$ 12d|\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
821  			}
822  		}
823  		else if (vm.count ("debug_profile_process"))
824  		{
825  			nano::block_builder builder;
826  			size_t num_accounts (100000);
827  			size_t num_iterations (5); 
828  			size_t max_blocks (2 * num_accounts * num_iterations + num_accounts * 2); 
829  			std::cout << boost::str (boost::format ("Starting pregenerating %1% blocks\n") % max_blocks);
830  			nano::node_flags node_flags;
831  			nano::update_flags (node_flags, vm);
832  			nano::inactive_node inactive_node (nano::unique_path (), data_path, node_flags);
833  			auto node = inactive_node.node;
834  			nano::block_hash genesis_latest (node->latest (nano::dev::genesis_key.pub));
835  			nano::uint128_t genesis_balance (std::numeric_limits<nano::uint128_t>::max ());
836  			std::vector<nano::keypair> keys (num_accounts);
837  			std::vector<nano::root> frontiers (num_accounts);
838  			std::vector<nano::uint128_t> balances (num_accounts, 1000000000);
839  			std::deque<std::shared_ptr<nano::block>> blocks;
840  			for (auto i (0); i != num_accounts; ++i)
841  			{
842  				genesis_balance = genesis_balance - 1000000000;
843  				auto send = builder.state ()
844  							.account (nano::dev::genesis_key.pub)
845  							.previous (genesis_latest)
846  							.representative (nano::dev::genesis_key.pub)
847  							.balance (genesis_balance)
848  							.link (keys[i].pub)
849  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
850  							.work (*node->work.generate (nano::work_version::work_1, genesis_latest, node->network_params.work.epoch_1))
851  							.build ();
852  				genesis_latest = send->hash ();
853  				blocks.push_back (std::move (send));
854  				auto open = builder.state ()
855  							.account (keys[i].pub)
856  							.previous (0)
857  							.representative (keys[i].pub)
858  							.balance (balances[i])
859  							.link (genesis_latest)
860  							.sign (keys[i].prv, keys[i].pub)
861  							.work (*node->work.generate (nano::work_version::work_1, keys[i].pub, node->network_params.work.epoch_1))
862  							.build ();
863  				frontiers[i] = open->hash ();
864  				blocks.push_back (std::move (open));
865  			}
866  			for (auto i (0); i != num_iterations; ++i)
867  			{
868  				for (auto j (0); j != num_accounts; ++j)
869  				{
870  					size_t other (num_accounts - j - 1);
871  					--balances[j];
872  					auto send = builder.state ()
873  								.account (keys[j].pub)
874  								.previous (frontiers[j].as_block_hash ())
875  								.representative (keys[j].pub)
876  								.balance (balances[j])
877  								.link (keys[other].pub)
878  								.sign (keys[j].prv, keys[j].pub)
879  								.work (*node->work.generate (nano::work_version::work_1, frontiers[j], node->network_params.work.epoch_1))
880  								.build ();
881  					frontiers[j] = send->hash ();
882  					blocks.push_back (std::move (send));
883  					++balances[other];
884  					auto receive = builder.state ()
885  								   .account (keys[other].pub)
886  								   .previous (frontiers[other].as_block_hash ())
887  								   .representative (keys[other].pub)
888  								   .balance (balances[other])
889  								   .link (frontiers[j].as_block_hash ())
890  								   .sign (keys[other].prv, keys[other].pub)
891  								   .work (*node->work.generate (nano::work_version::work_1, frontiers[other], node->network_params.work.epoch_1))
892  								   .build ();
893  					frontiers[other] = receive->hash ();
894  					blocks.push_back (std::move (receive));
895  				}
896  			}
897  			std::cout << boost::str (boost::format ("Starting processing %1% blocks\n") % max_blocks);
898  			auto begin (std::chrono::high_resolution_clock::now ());
899  			while (!blocks.empty ())
900  			{
901  				auto block (blocks.front ());
902  				node->process_active (block);
903  				blocks.pop_front ();
904  			}
905  			nano::timer<std::chrono::seconds> timer_l (nano::timer_state::started);
906  			while (node->ledger.cache.block_count != max_blocks + 1)
907  			{
908  				std::this_thread::sleep_for (std::chrono::milliseconds (10));
909  				if (timer_l.after_deadline (std::chrono::seconds (15)))
910  				{
911  					timer_l.restart ();
912  					std::cout << boost::str (boost::format ("%1% (%2%) blocks processed (unchecked), %3% remaining") % node->ledger.cache.block_count % node->unchecked.count () % node->block_processor.size ()) << std::endl;
913  				}
914  			}
915  			node->block_processor.flush ();
916  			auto end (std::chrono::high_resolution_clock::now ());
917  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
918  			node->stop ();
919  			std::cout << boost::str (boost::format ("%|1$ 12d| us \n%2% blocks per second\n") % time % (max_blocks * 1000000 / time));
920  			release_assert (node->ledger.cache.block_count == max_blocks + 1);
921  		}
922  		else if (vm.count ("debug_profile_votes"))
923  		{
924  			nano::block_builder builder;
925  			size_t num_elections (40000);
926  			size_t num_representatives (25);
927  			size_t max_votes (num_elections * num_representatives); 
928  			std::cerr << boost::str (boost::format ("Starting pregenerating %1% votes\n") % max_votes);
929  			nano::node_flags node_flags;
930  			nano::update_flags (node_flags, vm);
931  			nano::node_wrapper node_wrapper (nano::unique_path (), data_path, node_flags);
932  			auto node = node_wrapper.node;
933  			nano::block_hash genesis_latest (node->latest (nano::dev::genesis_key.pub));
934  			nano::uint128_t genesis_balance (std::numeric_limits<nano::uint128_t>::max ());
935  			std::vector<nano::keypair> keys (num_representatives);
936  			nano::uint128_t balance ((node->config.online_weight_minimum.number () / num_representatives) + 1);
937  			for (auto i (0); i != num_representatives; ++i)
938  			{
939  				auto transaction (node->store.tx_begin_write ());
940  				genesis_balance = genesis_balance - balance;
941  				auto send = builder.state ()
942  							.account (nano::dev::genesis_key.pub)
943  							.previous (genesis_latest)
944  							.representative (nano::dev::genesis_key.pub)
945  							.balance (genesis_balance)
946  							.link (keys[i].pub)
947  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
948  							.work (*node->work.generate (nano::work_version::work_1, genesis_latest, node->network_params.work.epoch_1))
949  							.build ();
950  				genesis_latest = send->hash ();
951  				node->ledger.process (transaction, *send);
952  				auto open = builder.state ()
953  							.account (keys[i].pub)
954  							.previous (0)
955  							.representative (keys[i].pub)
956  							.balance (balance)
957  							.link (genesis_latest)
958  							.sign (keys[i].prv, keys[i].pub)
959  							.work (*node->work.generate (nano::work_version::work_1, keys[i].pub, node->network_params.work.epoch_1))
960  							.build ();
961  				node->ledger.process (transaction, *open);
962  			}
963  			std::deque<std::shared_ptr<nano::block>> blocks;
964  			for (auto i (0); i != num_elections; ++i)
965  			{
966  				genesis_balance = genesis_balance - 1;
967  				nano::keypair destination;
968  				auto send = builder.state ()
969  							.account (nano::dev::genesis_key.pub)
970  							.previous (genesis_latest)
971  							.representative (nano::dev::genesis_key.pub)
972  							.balance (genesis_balance)
973  							.link (destination.pub)
974  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
975  							.work (*node->work.generate (nano::work_version::work_1, genesis_latest, node->network_params.work.epoch_1))
976  							.build ();
977  				genesis_latest = send->hash ();
978  				blocks.push_back (std::move (send));
979  			}
980  			std::deque<std::shared_ptr<nano::vote>> votes;
981  			for (auto j (0); j != num_representatives; ++j)
982  			{
983  				uint64_t sequence (1);
984  				for (auto & i : blocks)
985  				{
986  					auto vote (std::make_shared<nano::vote> (keys[j].pub, keys[j].prv, sequence, 0, std::vector<nano::block_hash> (1, i->hash ())));
987  					votes.push_back (vote);
988  					sequence++;
989  				}
990  			}
991  			while (!blocks.empty ())
992  			{
993  				auto block (blocks.front ());
994  				node->process_active (block);
995  				blocks.pop_front ();
996  			}
997  			node->block_processor.flush ();
998  			std::cerr << boost::str (boost::format ("Starting processing %1% votes\n") % max_votes);
999  			auto begin (std::chrono::high_resolution_clock::now ());
1000  			while (!votes.empty ())
1001  			{
1002  				auto vote (votes.front ());
1003  				auto channel (std::make_shared<nano::transport::inproc::channel> (*node, *node));
1004  				node->vote_processor.vote (vote, channel);
1005  				votes.pop_front ();
1006  			}
1007  			while (!node->active.empty ())
1008  			{
1009  				std::this_thread::sleep_for (std::chrono::milliseconds (100));
1010  			}
1011  			auto end (std::chrono::high_resolution_clock::now ());
1012  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
1013  			node->stop ();
1014  			std::cerr << boost::str (boost::format ("%|1$ 12d| us \n%2% votes per second\n") % time % (max_votes * 1000000 / time));
1015  		}
1016  		else if (vm.count ("debug_profile_frontiers_confirmation"))
1017  		{
1018  			nano::block_builder builder;
1019  			size_t count (32 * 1024);
1020  			auto count_it = vm.find ("count");
1021  			if (count_it != vm.end ())
1022  			{
1023  				try
1024  				{
1025  					count = boost::lexical_cast<size_t> (count_it->second.as<std::string> ());
1026  				}
1027  				catch (boost::bad_lexical_cast &)
1028  				{
1029  					std::cerr << "Invalid count\n";
1030  					return -1;
1031  				}
1032  			}
1033  			std::cout << boost::str (boost::format ("Starting generating %1% blocks...\n") % (count * 2));
1034  			boost::asio::io_context io_ctx1;
1035  			boost::asio::io_context io_ctx2;
1036  			nano::work_pool work{ network_params.network, std::numeric_limits<unsigned>::max () };
1037  			nano::logging logging;
1038  			auto path1 (nano::unique_path ());
1039  			auto path2 (nano::unique_path ());
1040  			logging.init (path1);
1041  			std::vector<std::string> config_overrides;
1042  			auto config (vm.find ("config"));
1043  			if (config != vm.end ())
1044  			{
1045  				config_overrides = nano::config_overrides (config->second.as<std::vector<nano::config_key_value_pair>> ());
1046  			}
1047  			nano::daemon_config daemon_config{ data_path, network_params };
1048  			auto error = nano::read_node_config_toml (data_path, daemon_config, config_overrides);
1049  			nano::node_config config1 = daemon_config.node;
1050  			config1.peering_port = 24000;
1051  			nano::node_flags flags;
1052  			nano::update_flags (flags, vm);
1053  			flags.disable_lazy_bootstrap = true;
1054  			flags.disable_legacy_bootstrap = true;
1055  			flags.disable_wallet_bootstrap = true;
1056  			flags.disable_bootstrap_listener = true;
1057  			auto node1 (std::make_shared<nano::node> (io_ctx1, path1, config1, work, flags, 0));
1058  			nano::block_hash genesis_latest (node1->latest (nano::dev::genesis_key.pub));
1059  			nano::uint128_t genesis_balance (std::numeric_limits<nano::uint128_t>::max ());
1060  			std::deque<std::shared_ptr<nano::block>> blocks;
1061  			for (auto i (0); i != count; ++i)
1062  			{
1063  				nano::keypair key;
1064  				genesis_balance = genesis_balance - 1;
1065  				auto send = builder.state ()
1066  							.account (nano::dev::genesis_key.pub)
1067  							.previous (genesis_latest)
1068  							.representative (nano::dev::genesis_key.pub)
1069  							.balance (genesis_balance)
1070  							.link (key.pub)
1071  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1072  							.work (*work.generate (nano::work_version::work_1, genesis_latest, nano::dev::network_params.work.epoch_1))
1073  							.build ();
1074  				genesis_latest = send->hash ();
1075  				auto open = builder.state ()
1076  							.account (key.pub)
1077  							.previous (0)
1078  							.representative (key.pub)
1079  							.balance (1)
1080  							.link (genesis_latest)
1081  							.sign (key.prv, key.pub)
1082  							.work (*work.generate (nano::work_version::work_1, key.pub, nano::dev::network_params.work.epoch_1))
1083  							.build ();
1084  				blocks.push_back (std::move (send));
1085  				blocks.push_back (std::move (open));
1086  				if (i % 20000 == 0 && i != 0)
1087  				{
1088  					std::cout << boost::str (boost::format ("%1% blocks generated\n") % (i * 2));
1089  				}
1090  			}
1091  			node1->start ();
1092  			nano::thread_runner runner1 (io_ctx1, node1->config.io_threads);
1093  			std::cout << boost::str (boost::format ("Processing %1% blocks\n") % (count * 2));
1094  			for (auto & block : blocks)
1095  			{
1096  				node1->block_processor.add (block);
1097  			}
1098  			node1->block_processor.flush ();
1099  			auto iteration (0);
1100  			while (node1->ledger.cache.block_count != count * 2 + 1)
1101  			{
1102  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1103  				if (++iteration % 60 == 0)
1104  				{
1105  					std::cout << boost::str (boost::format ("%1% blocks processed\n") % node1->ledger.cache.block_count);
1106  				}
1107  			}
1108  			for (auto & block : blocks)
1109  			{
1110  				node1->confirmation_height_processor.add (block);
1111  			}
1112  			while (node1->ledger.cache.cemented_count != node1->ledger.cache.block_count)
1113  			{
1114  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1115  				if (++iteration % 60 == 0)
1116  				{
1117  					std::cout << boost::str (boost::format ("%1% blocks cemented\n") % node1->ledger.cache.cemented_count);
1118  				}
1119  			}
1120  			nano::node_config config2 = daemon_config.node;
1121  			config1.peering_port = 24001;
1122  			if (error)
1123  			{
1124  				std::cerr << "\n"
1125  						  << error.get_message () << std::endl;
1126  				std::exit (1);
1127  			}
1128  			else
1129  			{
1130  				config2.frontiers_confirmation = daemon_config.node.frontiers_confirmation;
1131  				config2.active_elections_size = daemon_config.node.active_elections_size;
1132  			}
1133  			auto node2 (std::make_shared<nano::node> (io_ctx2, path2, config2, work, flags, 1));
1134  			node2->start ();
1135  			nano::thread_runner runner2 (io_ctx2, node2->config.io_threads);
1136  			std::cout << boost::str (boost::format ("Processing %1% blocks (test node)\n") % (count * 2));
1137  			while (!blocks.empty ())
1138  			{
1139  				auto block (blocks.front ());
1140  				node2->block_processor.add (block);
1141  				blocks.pop_front ();
1142  			}
1143  			node2->block_processor.flush ();
1144  			while (node2->ledger.cache.block_count != count * 2 + 1)
1145  			{
1146  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1147  				if (++iteration % 60 == 0)
1148  				{
1149  					std::cout << boost::str (boost::format ("%1% blocks processed\n") % node2->ledger.cache.block_count);
1150  				}
1151  			}
1152  			std::cout << "Initializing representative\n";
1153  			auto wallet (node1->wallets.create (nano::random_wallet_id ()));
1154  			wallet->insert_adhoc (nano::dev::genesis_key.prv);
1155  			node2->network.merge_peer (node1->network.endpoint ());
1156  			while (node2->rep_crawler.representative_count () == 0)
1157  			{
1158  				std::this_thread::sleep_for (std::chrono::milliseconds (10));
1159  				if (++iteration % 500 == 0)
1160  				{
1161  					std::cout << "Representative initialization iteration...\n";
1162  				}
1163  			}
1164  			auto begin (std::chrono::high_resolution_clock::now ());
1165  			std::cout << boost::str (boost::format ("Starting confirming %1% frontiers (test node)\n") % (count + 1));
1166  			while (node2->ledger.cache.cemented_count != node2->ledger.cache.block_count)
1167  			{
1168  				std::this_thread::sleep_for (std::chrono::milliseconds (25));
1169  				if (++iteration % 1200 == 0)
1170  				{
1171  					std::cout << boost::str (boost::format ("%1% blocks confirmed\n") % node2->ledger.cache.cemented_count);
1172  				}
1173  			}
1174  			auto end (std::chrono::high_resolution_clock::now ());
1175  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
1176  			std::cout << boost::str (boost::format ("%|1$ 12d| us \n%2% frontiers per second\n") % time % ((count + 1) * 1000000 / time));
1177  			io_ctx1.stop ();
1178  			io_ctx2.stop ();
1179  			runner1.join ();
1180  			runner2.join ();
1181  			node1->stop ();
1182  			node2->stop ();
1183  		}
1184  		else if (vm.count ("debug_random_feed"))
1185  		{
1186  			nano::raw_key seed;
1187  			for (;;)
1188  			{
1189  				nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
1190  				std::cout.write (reinterpret_cast<char const *> (seed.bytes.data ()), seed.bytes.size ());
1191  			}
1192  		}
1193  		else if (vm.count ("debug_rpc"))
1194  		{
1195  			std::string rpc_input_l;
1196  			std::ostringstream command_l;
1197  			while (std::cin >> rpc_input_l)
1198  			{
1199  				command_l << rpc_input_l;
1200  			}
1201  			auto response_handler_l ([] (std::string const & response_a) {
1202  				std::cout << response_a;
1203  				std::exit (0);
1204  			});
1205  			auto node_flags = nano::inactive_node_flag_defaults ();
1206  			nano::update_flags (node_flags, vm);
1207  			node_flags.generate_cache.enable_all ();
1208  			nano::inactive_node inactive_node_l (data_path, node_flags);
1209  			nano::node_rpc_config config;
1210  			nano::ipc::ipc_server server (*inactive_node_l.node, config);
1211  			auto handler_l (std::make_shared<nano::json_handler> (*inactive_node_l.node, config, command_l.str (), response_handler_l));
1212  			handler_l->process_request ();
1213  		}
1214  		else if (vm.count ("validate_blocks") || vm.count ("debug_validate_blocks"))
1215  		{
1216  			nano::timer<std::chrono::seconds> timer;
1217  			timer.start ();
1218  			auto node_flags = nano::inactive_node_flag_defaults ();
1219  			nano::update_flags (node_flags, vm);
1220  			node_flags.generate_cache.block_count = true;
1221  			nano::inactive_node inactive_node (data_path, node_flags);
1222  			auto node = inactive_node.node;
1223  			bool const silent (vm.count ("silent"));
1224  			unsigned threads_count (1);
1225  			auto threads_it = vm.find ("threads");
1226  			if (threads_it != vm.end ())
1227  			{
1228  				if (!boost::conversion::try_lexical_convert (threads_it->second.as<std::string> (), threads_count))
1229  				{
1230  					std::cerr << "Invalid threads count\n";
1231  					return -1;
1232  				}
1233  			}
1234  			threads_count = std::max (1u, threads_count);
1235  			std::vector<std::thread> threads;
1236  			nano::mutex mutex;
1237  			nano::condition_variable condition;
1238  			std::atomic<bool> finished (false);
1239  			std::deque<std::pair<nano::account, nano::account_info>> accounts;
1240  			std::atomic<size_t> count (0);
1241  			std::atomic<uint64_t> block_count (0);
1242  			std::atomic<uint64_t> errors (0);
1243  			auto print_error_message = [&silent, &errors] (std::string const & error_message_a) {
1244  				if (!silent)
1245  				{
1246  					static nano::mutex cerr_mutex;
1247  					nano::lock_guard<nano::mutex> lock{ cerr_mutex };
1248  					std::cerr << error_message_a;
1249  				}
1250  				++errors;
1251  			};
1252  			auto start_threads = [node, &threads_count, &threads, &mutex, &condition, &finished] (auto const & function_a, auto & deque_a) {
1253  				for (auto i (0U); i < threads_count; ++i)
1254  				{
1255  					threads.emplace_back ([&function_a, node, &mutex, &condition, &finished, &deque_a] () {
1256  						auto transaction (node->store.tx_begin_read ());
1257  						nano::unique_lock<nano::mutex> lock{ mutex };
1258  						while (!deque_a.empty () || !finished)
1259  						{
1260  							while (deque_a.empty () && !finished)
1261  							{
1262  								condition.wait (lock);
1263  							}
1264  							if (!deque_a.empty ())
1265  							{
1266  								auto pair (deque_a.front ());
1267  								deque_a.pop_front ();
1268  								lock.unlock ();
1269  								function_a (node, transaction, pair.first, pair.second);
1270  								lock.lock ();
1271  							}
1272  						}
1273  					});
1274  				}
1275  			};
1276  			auto check_account = [&print_error_message, &silent, &count, &block_count] (std::shared_ptr<nano::node> const & node, nano::read_transaction const & transaction, nano::account const & account, nano::account_info const & info) {
1277  				++count;
1278  				if (!silent && (count % 20000) == 0)
1279  				{
1280  					std::cout << boost::str (boost::format ("%1% accounts validated\n") % count);
1281  				}
1282  				nano::confirmation_height_info confirmation_height_info;
1283  				node->store.confirmation_height.get (transaction, account, confirmation_height_info);
1284  				if (confirmation_height_info.height > info.block_count)
1285  				{
1286  					print_error_message (boost::str (boost::format ("Confirmation height %1% greater than block count %2% for account: %3%\n") % confirmation_height_info.height % info.block_count % account.to_account ()));
1287  				}
1288  				auto hash (info.open_block);
1289  				nano::block_hash calculated_hash (0);
1290  				auto block (node->store.block.get (transaction, hash)); 
1291  				uint64_t height (0);
1292  				if (node->ledger.pruning && confirmation_height_info.height != 0)
1293  				{
1294  					hash = confirmation_height_info.frontier;
1295  					block = node->store.block.get (transaction, hash);
1296  					bool pruned_block (false);
1297  					while (!pruned_block && !block->previous ().is_zero ())
1298  					{
1299  						auto previous_block (node->store.block.get (transaction, block->previous ()));
1300  						if (previous_block != nullptr)
1301  						{
1302  							hash = previous_block->hash ();
1303  							block = previous_block;
1304  						}
1305  						else
1306  						{
1307  							pruned_block = true;
1308  							if (!node->store.pruned.exists (transaction, block->previous ()))
1309  							{
1310  								print_error_message (boost::str (boost::format ("Pruned previous block does not exist %1%\n") % block->previous ().to_string ()));
1311  							}
1312  						}
1313  					}
1314  					calculated_hash = block->previous ();
1315  					height = block->sideband ().height - 1;
1316  					if (!node->ledger.block_or_pruned_exists (transaction, info.open_block))
1317  					{
1318  						print_error_message (boost::str (boost::format ("Open block does not exist %1%\n") % info.open_block.to_string ()));
1319  					}
1320  				}
1321  				uint64_t previous_timestamp (0);
1322  				nano::account calculated_representative{};
1323  				while (!hash.is_zero () && block != nullptr)
1324  				{
1325  					++block_count;
1326  					auto const & sideband (block->sideband ());
1327  					if (block->type () == nano::block_type::open || block->type () == nano::block_type::state)
1328  					{
1329  						if (block->account () != account)
1330  						{
1331  							print_error_message (boost::str (boost::format ("Incorrect account field for block %1%\n") % hash.to_string ()));
1332  						}
1333  					}
1334  					else if (sideband.account != account)
1335  					{
1336  						print_error_message (boost::str (boost::format ("Incorrect sideband account for block %1%\n") % hash.to_string ()));
1337  					}
1338  					if (calculated_hash != block->previous ())
1339  					{
1340  						print_error_message (boost::str (boost::format ("Incorrect previous field for block %1%\n") % hash.to_string ()));
1341  					}
1342  					if (height == 0 && !block->previous ().is_zero ())
1343  					{
1344  						print_error_message (boost::str (boost::format ("Incorrect previous for open block %1%\n") % hash.to_string ()));
1345  					}
1346  					if (height == 0 && block->type () != nano::block_type::open && block->type () != nano::block_type::state)
1347  					{
1348  						print_error_message (boost::str (boost::format ("Incorrect type for open block %1%\n") % hash.to_string ()));
1349  					}
1350  					calculated_hash = block->hash ();
1351  					if (calculated_hash != hash)
1352  					{
1353  						print_error_message (boost::str (boost::format ("Invalid data inside block %1% calculated hash: %2%\n") % hash.to_string () % calculated_hash.to_string ()));
1354  					}
1355  					if (validate_message (account, hash, block->block_signature ()))
1356  					{
1357  						bool invalid (true);
1358  						if (block->type () == nano::block_type::state)
1359  						{
1360  							auto & state_block (static_cast<nano::state_block &> (*block.get ()));
1361  							nano::amount prev_balance (0);
1362  							bool error_or_pruned (false);
1363  							if (!state_block.hashables.previous.is_zero ())
1364  							{
1365  								prev_balance = node->ledger.balance_safe (transaction, state_block.hashables.previous, error_or_pruned);
1366  							}
1367  							if (node->ledger.is_epoch_link (state_block.hashables.link))
1368  							{
1369  								if ((state_block.hashables.balance == prev_balance && !error_or_pruned) || (node->ledger.pruning && error_or_pruned && block->sideband ().details.is_epoch))
1370  								{
1371  									invalid = validate_message (node->ledger.epoch_signer (block->link ()), hash, block->block_signature ());
1372  								}
1373  							}
1374  						}
1375  						if (invalid)
1376  						{
1377  							print_error_message (boost::str (boost::format ("Invalid signature for block %1%\n") % hash.to_string ()));
1378  						}
1379  					}
1380  					bool block_details_error = false;
1381  					if (block->type () != nano::block_type::state)
1382  					{
1383  						block_details_error = sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1384  					}
1385  					else
1386  					{
1387  						bool error_or_pruned (false);
1388  						auto prev_balance (node->ledger.balance_safe (transaction, block->previous (), error_or_pruned));
1389  						if (!node->ledger.pruning || !error_or_pruned)
1390  						{
1391  							if (block->balance () < prev_balance)
1392  							{
1393  								block_details_error = !sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1394  							}
1395  							else
1396  							{
1397  								if (block->link ().is_zero ())
1398  								{
1399  									block_details_error = sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1400  								}
1401  								else if (block->balance () == prev_balance && node->ledger.is_epoch_link (block->link ()))
1402  								{
1403  									block_details_error = !sideband.details.is_epoch || sideband.details.is_send || sideband.details.is_receive;
1404  								}
1405  								else
1406  								{
1407  									block_details_error = !sideband.details.is_receive || sideband.details.is_send || sideband.details.is_epoch;
1408  									block_details_error |= !node->ledger.block_or_pruned_exists (transaction, block->link ().as_block_hash ());
1409  								}
1410  							}
1411  						}
1412  						else if (!node->store.pruned.exists (transaction, block->previous ()))
1413  						{
1414  							print_error_message (boost::str (boost::format ("Previous pruned block does not exist %1%\n") % block->previous ().to_string ()));
1415  						}
1416  					}
1417  					if (block_details_error)
1418  					{
1419  						print_error_message (boost::str (boost::format ("Incorrect sideband block details for block %1%\n") % hash.to_string ()));
1420  					}
1421  					if (sideband.details.is_receive && (!node->ledger.pruning || !node->store.pruned.exists (transaction, block->link ().as_block_hash ())))
1422  					{
1423  						if (sideband.source_epoch != node->store.block.version (transaction, block->link ().as_block_hash ()))
1424  						{
1425  							print_error_message (boost::str (boost::format ("Incorrect source epoch for block %1%\n") % hash.to_string ()));
1426  						}
1427  					}
1428  					if (node->network_params.work.difficulty (*block) < node->network_params.work.threshold (block->work_version (), block->sideband ().details))
1429  					{
1430  						print_error_message (boost::str (boost::format ("Invalid work for block %1% value: %2%\n") % hash.to_string () % nano::to_string_hex (block->block_work ())));
1431  					}
1432  					++height;
1433  					if (sideband.height != height)
1434  					{
1435  						print_error_message (boost::str (boost::format ("Incorrect sideband height for block %1%. Sideband: %2%. Expected: %3%\n") % hash.to_string () % sideband.height % height));
1436  					}
1437  					if (sideband.timestamp < previous_timestamp)
1438  					{
1439  						print_error_message (boost::str (boost::format ("Incorrect sideband timestamp for block %1%\n") % hash.to_string ()));
1440  					}
1441  					previous_timestamp = sideband.timestamp;
1442  					if (block->type () == nano::block_type::open || block->type () == nano::block_type::change || block->type () == nano::block_type::state)
1443  					{
1444  						calculated_representative = block->representative ();
1445  					}
1446  					hash = node->store.block.successor (transaction, hash);
1447  					if (!hash.is_zero ())
1448  					{
1449  						block = node->store.block.get (transaction, hash);
1450  					}
1451  				}
1452  				if (!hash.is_zero () && block == nullptr)
1453  				{
1454  					print_error_message (boost::str (boost::format ("Required block in account %1% chain was not found in ledger: %2%\n") % account.to_account () % hash.to_string ()));
1455  				}
1456  				if (info.block_count != height)
1457  				{
1458  					print_error_message (boost::str (boost::format ("Incorrect block count for account %1%. Actual: %2%. Expected: %3%\n") % account.to_account () % height % info.block_count));
1459  				}
1460  				if (info.head != calculated_hash)
1461  				{
1462  					print_error_message (boost::str (boost::format ("Incorrect frontier for account %1%. Actual: %2%. Expected: %3%\n") % account.to_account () % calculated_hash.to_string () % info.head.to_string ()));
1463  				}
1464  				if (info.representative != calculated_representative)
1465  				{
1466  					print_error_message (boost::str (boost::format ("Incorrect representative for account %1%. Actual: %2%. Expected: %3%\n") % account.to_account () % calculated_representative.to_string () % info.representative.to_string ()));
1467  				}
1468  			};
1469  			start_threads (check_account, accounts);
1470  			if (!silent)
1471  			{
1472  				std::cout << boost::str (boost::format ("Performing %1% threads blocks hash, signature, work validation...\n") % threads_count);
1473  			}
1474  			size_t const accounts_deque_overflow (32 * 1024);
1475  			auto transaction (node->store.tx_begin_read ());
1476  			for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
1477  			{
1478  				{
1479  					nano::unique_lock<nano::mutex> lock{ mutex };
1480  					if (accounts.size () > accounts_deque_overflow)
1481  					{
1482  						auto wait_ms (250 * accounts.size () / accounts_deque_overflow);
1483  						auto const wakeup (std::chrono::steady_clock::now () + std::chrono::milliseconds (wait_ms));
1484  						condition.wait_until (lock, wakeup);
1485  					}
1486  					accounts.emplace_back (i->first, i->second);
1487  				}
1488  				condition.notify_all ();
1489  			}
1490  			{
1491  				nano::lock_guard<nano::mutex> lock{ mutex };
1492  				finished = true;
1493  			}
1494  			condition.notify_all ();
1495  			for (auto & thread : threads)
1496  			{
1497  				thread.join ();
1498  			}
1499  			threads.clear ();
1500  			if (!silent)
1501  			{
1502  				std::cout << boost::str (boost::format ("%1% accounts validated\n") % count);
1503  			}
1504  			auto ledger_block_count (node->store.block.count (transaction));
1505  			if (node->flags.enable_pruning)
1506  			{
1507  				block_count += 1; 
1508  			}
1509  			if (block_count != ledger_block_count)
1510  			{
1511  				print_error_message (boost::str (boost::format ("Incorrect total block count. Blocks validated %1%. Block count in database: %2%\n") % block_count % ledger_block_count));
1512  			}
1513  			count = 0;
1514  			finished = false;
1515  			std::deque<std::pair<nano::pending_key, nano::pending_info>> pending;
1516  			auto check_pending = [&print_error_message, &silent, &count] (std::shared_ptr<nano::node> const & node, nano::read_transaction const & transaction, nano::pending_key const & key, nano::pending_info const & info) {
1517  				++count;
1518  				if (!silent && (count % 500000) == 0)
1519  				{
1520  					std::cout << boost::str (boost::format ("%1% pending blocks validated\n") % count);
1521  				}
1522  				auto block (node->store.block.get_no_sideband (transaction, key.hash));
1523  				bool pruned (false);
1524  				if (block == nullptr)
1525  				{
1526  					pruned = node->ledger.pruning && node->store.pruned.exists (transaction, key.hash);
1527  					if (!pruned)
1528  					{
1529  						print_error_message (boost::str (boost::format ("Pending block does not exist %1%\n") % key.hash.to_string ()));
1530  					}
1531  				}
1532  				else
1533  				{
1534  					nano::account destination{};
1535  					bool previous_pruned = node->ledger.pruning && node->store.pruned.exists (transaction, block->previous ());
1536  					if (previous_pruned)
1537  					{
1538  						block = node->store.block.get (transaction, key.hash);
1539  					}
1540  					if (auto state = dynamic_cast<nano::state_block *> (block.get ()))
1541  					{
1542  						if (node->ledger.is_send (transaction, *state))
1543  						{
1544  							destination = state->hashables.link.as_account ();
1545  						}
1546  					}
1547  					else if (auto send = dynamic_cast<nano::send_block *> (block.get ()))
1548  					{
1549  						destination = send->hashables.destination;
1550  					}
1551  					else
1552  					{
1553  						print_error_message (boost::str (boost::format ("Incorrect type for pending block %1%\n") % key.hash.to_string ()));
1554  					}
1555  					if (key.account != destination)
1556  					{
1557  						print_error_message (boost::str (boost::format ("Incorrect destination for pending block %1%\n") % key.hash.to_string ()));
1558  					}
1559  					auto account (node->ledger.account (transaction, key.hash));
1560  					if (info.source != account && !pruned)
1561  					{
1562  						print_error_message (boost::str (boost::format ("Incorrect source for pending block %1%\n") % key.hash.to_string ()));
1563  					}
1564  					if (!pruned && !previous_pruned)
1565  					{
1566  						auto amount (node->ledger.amount (transaction, key.hash));
1567  						if (info.amount != amount)
1568  						{
1569  							print_error_message (boost::str (boost::format ("Incorrect amount for pending block %1%\n") % key.hash.to_string ()));
1570  						}
1571  					}
1572  				}
1573  			};
1574  			start_threads (check_pending, pending);
1575  			size_t const pending_deque_overflow (64 * 1024);
1576  			for (auto i (node->store.pending.begin (transaction)), n (node->store.pending.end ()); i != n; ++i)
1577  			{
1578  				{
1579  					nano::unique_lock<nano::mutex> lock{ mutex };
1580  					if (pending.size () > pending_deque_overflow)
1581  					{
1582  						auto wait_ms (50 * pending.size () / pending_deque_overflow);
1583  						auto const wakeup (std::chrono::steady_clock::now () + std::chrono::milliseconds (wait_ms));
1584  						condition.wait_until (lock, wakeup);
1585  					}
1586  					pending.emplace_back (i->first, i->second);
1587  				}
1588  				condition.notify_all ();
1589  			}
1590  			{
1591  				nano::lock_guard<nano::mutex> lock{ mutex };
1592  				finished = true;
1593  			}
1594  			condition.notify_all ();
1595  			for (auto & thread : threads)
1596  			{
1597  				thread.join ();
1598  			}
1599  			if (!silent)
1600  			{
1601  				std::cout << boost::str (boost::format ("%1% pending blocks validated\n") % count);
1602  				timer.stop ();
1603  				std::cout << boost::str (boost::format ("%1% %2% validation time\n") % timer.value ().count () % timer.unit ());
1604  			}
1605  			if (errors == 0)
1606  			{
1607  				std::cout << "Validation status: Ok\n";
1608  			}
1609  			else
1610  			{
1611  				std::cout << boost::str (boost::format ("Validation status: Failed\n%1% errors found\n") % errors);
1612  			}
1613  		}
1614  		else if (vm.count ("debug_profile_bootstrap"))
1615  		{
1616  			auto node_flags = nano::inactive_node_flag_defaults ();
1617  			node_flags.read_only = false;
1618  			nano::update_flags (node_flags, vm);
1619  			nano::inactive_node node (nano::unique_path (), node_flags);
1620  			auto begin (std::chrono::high_resolution_clock::now ());
1621  			uint64_t block_count (0);
1622  			size_t count (0);
1623  			std::deque<std::shared_ptr<nano::block>> epoch_open_blocks;
1624  			{
1625  				auto node_flags = nano::inactive_node_flag_defaults ();
1626  				nano::update_flags (node_flags, vm);
1627  				node_flags.generate_cache.block_count = true;
1628  				nano::inactive_node inactive_node (data_path, node_flags);
1629  				auto source_node = inactive_node.node;
1630  				auto transaction (source_node->store.tx_begin_read ());
1631  				block_count = source_node->ledger.cache.block_count;
1632  				std::cout << boost::str (boost::format ("Performing bootstrap emulation, %1% blocks in ledger...") % block_count) << std::endl;
1633  				for (auto i (source_node->store.account.begin (transaction)), n (source_node->store.account.end ()); i != n; ++i)
1634  				{
1635  					nano::account const & account (i->first);
1636  					nano::account_info const & info (i->second);
1637  					auto hash (info.head);
1638  					while (!hash.is_zero ())
1639  					{
1640  						auto block (source_node->store.block.get_no_sideband (transaction, hash));
1641  						if (block != nullptr)
1642  						{
1643  							++count;
1644  							if ((count % 500000) == 0)
1645  							{
1646  								std::cout << boost::str (boost::format ("%1% blocks retrieved") % count) << std::endl;
1647  							}
1648  							node.node->block_processor.add (block);
1649  							if (block->type () == nano::block_type::state && block->previous ().is_zero () && source_node->ledger.is_epoch_link (block->link ()))
1650  							{
1651  								epoch_open_blocks.push_back (block);
1652  							}
1653  							hash = block->previous ();
1654  						}
1655  					}
1656  				}
1657  			}
1658  			nano::timer<std::chrono::seconds> timer_l (nano::timer_state::started);
1659  			while (node.node->ledger.cache.block_count != block_count)
1660  			{
1661  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1662  				if (node.node->block_processor.size () == 0)
1663  				{
1664  					for (auto & block : epoch_open_blocks)
1665  					{
1666  						node.node->block_processor.add (block);
1667  					}
1668  				}
1669  				if (timer_l.after_deadline (std::chrono::seconds (60)))
1670  				{
1671  					timer_l.restart ();
1672  					std::cout << boost::str (boost::format ("%1% (%2%) blocks processed (unchecked)") % node.node->ledger.cache.block_count % node.node->unchecked.count ()) << std::endl;
1673  				}
1674  			}
1675  			node.node->block_processor.flush ();
1676  			auto end (std::chrono::high_resolution_clock::now ());
1677  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
1678  			auto us_in_second (1000000);
1679  			auto seconds (time / us_in_second);
1680  			nano::remove_temporary_directories ();
1681  			std::cout << boost::str (boost::format ("%|1$ 12d| seconds \n%2% blocks per second") % seconds % (block_count * us_in_second / time)) << std::endl;
1682  			release_assert (node.node->ledger.cache.block_count == block_count);
1683  		}
1684  		else if (vm.count ("debug_peers"))
1685  		{
1686  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1687  			auto node = inactive_node->node;
1688  			auto transaction (node->store.tx_begin_read ());
1689  			for (auto i (node->store.peer.begin (transaction)), n (node->store.peer.end ()); i != n; ++i)
1690  			{
1691  				std::cout << boost::str (boost::format ("%1%\n") % nano::endpoint (boost::asio::ip::address_v6 (i->first.address_bytes ()), i->first.port ()));
1692  			}
1693  		}
1694  		else if (vm.count ("debug_cemented_block_count"))
1695  		{
1696  			auto node_flags = nano::inactive_node_flag_defaults ();
1697  			node_flags.generate_cache.cemented_count = true;
1698  			nano::update_flags (node_flags, vm);
1699  			nano::inactive_node node (data_path, node_flags);
1700  			std::cout << "Total cemented block count: " << node.node->ledger.cache.cemented_count << std::endl;
1701  		}
1702  		else if (vm.count ("debug_prune"))
1703  		{
1704  			auto node_flags = nano::inactive_node_flag_defaults ();
1705  			node_flags.read_only = false;
1706  			nano::update_flags (node_flags, vm);
1707  			nano::inactive_node inactive_node (data_path, node_flags);
1708  			auto node = inactive_node.node;
1709  			node->ledger_pruning (node_flags.block_processor_batch_size != 0 ? node_flags.block_processor_batch_size : 16 * 1024, true, true);
1710  		}
1711  		else if (vm.count ("debug_stacktrace"))
1712  		{
1713  			std::cout << boost::stacktrace::stacktrace ();
1714  		}
1715  		else if (vm.count ("debug_sys_logging"))
1716  		{
1717  #ifdef BOOST_WINDOWS
1718  			if (!nano::event_log_reg_entry_exists () && !nano::is_windows_elevated ())
1719  			{
1720  				std::cerr << "The event log requires the HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Nano\\Nano registry entry, run again as administator to create it.\n";
1721  				return 1;
1722  			}
1723  #endif
1724  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1725  			inactive_node->node->logger.always_log (nano::severity_level::error, "Testing system logger");
1726  		}
1727  		else if (vm.count ("debug_account_versions"))
1728  		{
1729  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1730  			auto node = inactive_node->node;
1731  			auto const epoch_count = nano::normalized_epoch (nano::epoch::max) + static_cast<std::underlying_type<nano::epoch>::type> (1);
1732  			nano::locked<std::vector<boost::unordered_set<nano::account>>> opened_account_versions_shared (epoch_count);
1733  			using opened_account_versions_t = decltype (opened_account_versions_shared)::value_type;
1734  			node->store.account.for_each_par (
1735  			[&opened_account_versions_shared, epoch_count] (nano::read_transaction const & &bsol;*unused*/, nano::store_iterator<nano::account, nano::account_info> i, nano::store_iterator<nano::account, nano::account_info> n) {
1736  				opened_account_versions_t opened_account_versions_l (epoch_count);
1737  				for (; i != n; ++i)
1738  				{
1739  					auto const & account (i->first);
1740  					auto const & account_info (i->second);
1741  					auto epoch_idx = nano::normalized_epoch (account_info.epoch ());
1742  					opened_account_versions_l[epoch_idx].emplace (account);
1743  				}
1744  				auto opened_account_versions = opened_account_versions_shared.lock ();
1745  				debug_assert (opened_account_versions->size () == opened_account_versions_l.size ());
1746  				for (auto idx (0); idx < opened_account_versions_l.size (); ++idx)
1747  				{
1748  					auto & accounts = opened_account_versions->at (idx);
1749  					auto const & accounts_l = opened_account_versions_l.at (idx);
1750  					accounts.insert (accounts_l.begin (), accounts_l.end ());
1751  				}
1752  			});
1753  			boost::unordered_set<nano::account> opened_accounts;
1754  			{
1755  				auto opened_account_versions = opened_account_versions_shared.lock ();
1756  				for (auto const & account_version : *opened_account_versions)
1757  				{
1758  					opened_accounts.insert (account_version.cbegin (), account_version.cend ());
1759  				}
1760  			}
1761  			nano::locked<boost::unordered_map<nano::account, std::underlying_type_t<nano::epoch>>> unopened_highest_pending_shared;
1762  			using unopened_highest_pending_t = decltype (unopened_highest_pending_shared)::value_type;
1763  			node->store.pending.for_each_par (
1764  			[&unopened_highest_pending_shared, &opened_accounts] (nano::read_transaction const & &bsol;*unused*/, nano::store_iterator<nano::pending_key, nano::pending_info> i, nano::store_iterator<nano::pending_key, nano::pending_info> n) {
1765  				unopened_highest_pending_t unopened_highest_pending_l;
1766  				for (; i != n; ++i)
1767  				{
1768  					nano::pending_key const & key (i->first);
1769  					nano::pending_info const & info (i->second);
1770  					auto & account = key.account;
1771  					auto exists = opened_accounts.find (account) != opened_accounts.end ();
1772  					if (!exists)
1773  					{
1774  						auto epoch = nano::normalized_epoch (info.epoch);
1775  						auto & existing_or_new = unopened_highest_pending_l[key.account];
1776  						existing_or_new = std::max (epoch, existing_or_new);
1777  					}
1778  				}
1779  				auto unopened_highest_pending = unopened_highest_pending_shared.lock ();
1780  				for (auto const & [account, epoch] : unopened_highest_pending_l)
1781  				{
1782  					auto & existing_or_new = unopened_highest_pending->operator[] (account);
1783  					existing_or_new = std::max (epoch, existing_or_new);
1784  				}
1785  			});
1786  			auto output_account_version_number = [] (auto version, auto num_accounts) {
1787  				std::cout << "Account version " << version << " num accounts: " << num_accounts << "\n";
1788  			};
1789  			auto const & opened_account_versions = *opened_account_versions_shared.lock ();
1790  			auto const & unopened_highest_pending = *unopened_highest_pending_shared.lock ();
1791  			std::cout << "Opened accounts:\n";
1792  			for (auto i = 0u; i < opened_account_versions.size (); ++i)
1793  			{
1794  				output_account_version_number (i, opened_account_versions[i].size ());
1795  			}
1796  			std::vector<size_t> unopened_account_version_totals (epoch_count);
1797  			for (auto const & [account, epoch] : unopened_highest_pending)
1798  			{
1799  				++unopened_account_version_totals[epoch];
1800  			}
1801  			std::cout << "\nUnopened accounts:\n";
1802  			for (auto i = 0u; i < unopened_account_version_totals.size (); ++i)
1803  			{
1804  				output_account_version_number (i, unopened_account_version_totals[i]);
1805  			}
1806  		}
1807  		else if (vm.count ("debug_unconfirmed_frontiers"))
1808  		{
1809  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1810  			auto node = inactive_node->node;
1811  			auto unconfirmed_frontiers = node->ledger.unconfirmed_frontiers ();
1812  			std::cout << "Account: Height delta | Frontier | Confirmed frontier\n";
1813  			for (auto const & [height_delta, unconfirmed_info] : unconfirmed_frontiers)
1814  			{
1815  				std::cout << (boost::format ("%1%: %2% %3% %4%\n") % unconfirmed_info.account.to_account () % height_delta % unconfirmed_info.frontier.to_string () % unconfirmed_info.cemented_frontier.to_string ()).str ();
1816  			}
1817  			std::cout << "\nNumber of unconfirmed frontiers: " << unconfirmed_frontiers.size () << std::endl;
1818  		}
1819  		else if (vm.count ("version"))
1820  		{
1821  			std::cout << "Version " << NANO_VERSION_STRING << "\n"
1822  					  << "Build Info " << BUILD_INFO << std::endl;
1823  		}
1824  		else
1825  		{
1826  			boost::program_options::options_description sorted_description ("Command line options");
1827  			nano::sort_options_description (description, sorted_description);
1828  			std::cout << sorted_description << std::endl;
1829  			result = -1;
1830  		}
1831  	}
1832  	return result;
1833  }
1834  namespace
1835  {
1836  std::istream & operator>> (std::istream & in, uint64_from_hex & out_val)
1837  {
1838  	in >> std::hex >> out_val.value;
1839  	return in;
1840  }
1841  address_library_pair::address_library_pair (uint64_t address, std::string library) :
1842  	address (address), library (library)
1843  {
1844  }
1845  bool address_library_pair::operator< (const address_library_pair & other) const
1846  {
1847  	return address < other.address;
1848  }
1849  bool address_library_pair::operator== (const address_library_pair & other) const
1850  {
1851  	return address == other.address;
1852  }
1853  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-appsrv.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_11.cpp</div>
                </div>
                <div class="column column_space"><pre><code>120       CurTm.GetWebLogDateStr().CStr(),
121       CurTm.GetWebLogTimeStr().CStr(),
122       PeerHostNm.CStr(),
123       HttpRq->GetMethodNm().CStr(),
124       HttpRq->GetUrl()->GetUrlStr().CStr(),
125       TInt::GetStr(HttpResp->GetStatusCd()).CStr());
126      fflush(fLog);
</pre></code></div>
                <div class="column column_space"><pre><code>51  	description.add_options ()
51  	description.add_options ()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    