
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.384615384615383%, Tokens: 30, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-base_data_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_DATA_LAYERS_HPP_
2  #define CAFFE_DATA_LAYERS_HPP_
3  #include <vector>
4  #include "caffe/blob.hpp"
5  #include "caffe/data_transformer.hpp"
6  #include "caffe/internal_thread.hpp"
7  #include "caffe/layer.hpp"
8  #include "caffe/proto/caffe.pb.h"
9  #include "caffe/util/blocking_queue.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  class BaseDataLayer : public Layer<Dtype> {
13   public:
14    explicit BaseDataLayer(const LayerParameter& param);
15    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
16        const vector<Blob<Dtype>*>& top);
17    virtual inline bool ShareInParallel() const { return true; }
18    virtual void DataLayerSetUp(const vector<Blob<Dtype>*>& bottom,
19        const vector<Blob<Dtype>*>& top) {}
20    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
21        const vector<Blob<Dtype>*>& top) {}
22    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
23        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {}
24    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
25        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {}
26   protected:
27    TransformationParameter transform_param_;
28    shared_ptr<DataTransformer<Dtype> > data_transformer_;
29    bool output_labels_;
30    bool box_label_;
31  };
32  template <typename Dtype>
33  class Batch {
34   public:
35    Blob<Dtype> data_, label_;
36    vector<shared_ptr<Blob<Dtype> > > multi_label_;
37  };
38  template <typename Dtype>
39  class BasePrefetchingDataLayer :
40      public BaseDataLayer<Dtype>, public InternalThread {
41   public:
<span onclick='openModal()' class='match'>42    explicit BasePrefetchingDataLayer(const LayerParameter& param);
43    void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
44        const vector<Blob<Dtype>*>& top);
45    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
46        const vector<Blob<Dtype>*>& top);
47    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
48        const vector<Blob<Dtype>*>& top);
49    static const int PREFETCH_COUNT = 3;
</span>50   protected:
51    virtual void InternalThreadEntry();
52    virtual void load_batch(Batch<Dtype>* batch) = 0;
53    virtual void GetBatch();
54    Batch<Dtype> prefetch_[PREFETCH_COUNT];
55    BlockingQueue<Batch<Dtype>*> prefetch_free_;
56    BlockingQueue<Batch<Dtype>*> prefetch_full_;
57    Blob<Dtype> transformed_data_;
58  };
59  }  
60  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pageres.h</h3>
            <pre><code>1  #ifndef PAGERES_H
2  #define PAGERES_H
3  #include "blamer.h"        
4  #include "clst.h"          
5  #include "elst.h"          
6  #include "genericvector.h" 
7  #include "matrix.h"        
8  #include "normalis.h"      
9  #include "ratngs.h"        
10  #include "rect.h"          
11  #include "rejctmap.h"      
12  #include "unicharset.h"    
13  #include "werd.h"          
14  #include <tesseract/unichar.h> 
15  #include <cstdint>    
16  #include <functional> 
17  #include <set>        
18  #include <vector>     
19  #include <sys/types.h> 
20  struct Pix;
21  namespace tesseract {
22  class BLOCK;
23  class BLOCK_LIST;
24  class BLOCK_RES;
25  class ROW;
26  class ROW_RES;
27  class SEAM;
28  class WERD_RES;
29  struct TWERD;
30  class BoxWord;
31  class Tesseract;
32  struct FontInfo;
33  class BLOCK_RES;
34  ELISTIZEH(BLOCK_RES)
35  CLISTIZEH(BLOCK_RES)
36  class ROW_RES;
37  ELISTIZEH(ROW_RES)
38  class WERD_RES;
39  ELISTIZEH(WERD_RES)
40  class PAGE_RES { 
41  public:
42    int32_t char_count;
43    int32_t rej_count;
44    BLOCK_RES_LIST block_res_list;
45    bool rejected;
46    WERD_CHOICE **prev_word_best_choice;
47    std::vector<int> blame_reasons;
48    std::vector<std::string> misadaption_log;
49    inline void Init() {
50      char_count = 0;
51      rej_count = 0;
52      rejected = false;
53      prev_word_best_choice = nullptr;
54      blame_reasons.clear();
55      blame_reasons.resize(IRR_NUM_REASONS);
56    }
57    PAGE_RES() {
58      Init();
59    } 
60    PAGE_RES(bool merge_similar_words,
61             BLOCK_LIST *block_list, 
62             WERD_CHOICE **prev_word_best_choice_ptr);
63    ~PAGE_RES() = default;
64  };
65  class BLOCK_RES : public ELIST_LINK {
66  public:
67    BLOCK *block;       
68    int32_t char_count; 
69    int32_t rej_count;  
70    int16_t font_class; 
71    int16_t row_count;
72    float x_height;
73    bool font_assigned; 
74    ROW_RES_LIST row_res_list;
75    BLOCK_RES() = default;
76    BLOCK_RES(bool merge_similar_words, BLOCK *the_block); 
77    ~BLOCK_RES() = default;
78  };
79  class ROW_RES : public ELIST_LINK {
80  public:
81    ROW *row;                     
82    int32_t char_count;           
83    int32_t rej_count;            
84    int32_t whole_word_rej_count; 
85    WERD_RES_LIST word_res_list;
86    ROW_RES() = default;
87    ROW_RES(bool merge_similar_words, ROW *the_row); 
88    ~ROW_RES() = default;
89  };
90  enum CRUNCH_MODE { CR_NONE, CR_KEEP_SPACE, CR_LOOSE_SPACE, CR_DELETE };
91  class TESS_API WERD_RES : public ELIST_LINK {
92  public:
93    WERD *word = nullptr; 
94    tesseract::BoxWord *bln_boxes = nullptr; 
95    ROW *blob_row = nullptr;
96    DENORM denorm; 
97    const UNICHARSET *uch_set = nullptr; 
98    TWERD *chopped_word = nullptr; 
99    std::vector<SEAM *> seam_array;
100    std::vector<int> blob_widths;
101    std::vector<int> blob_gaps;
102    std::vector<std::vector<std::pair<const char *, float>>> timesteps;
103    std::vector<std::vector<std::vector<std::pair<const char *, float>>>>
104        segmented_timesteps;
105    std::vector<std::vector<std::pair<const char *, float>>> CTC_symbol_choices;
106    bool leading_space = false;
107    int end = 0;
108    MATRIX *ratings = nullptr; 
109    WERD_CHOICE *best_choice = nullptr; 
110    WERD_CHOICE *raw_choice = nullptr; 
111    WERD_CHOICE_LIST best_choices;
112    BlamerBundle *blamer_bundle = nullptr;
113    TWERD *rebuild_word = nullptr; 
114    tesseract::BoxWord *box_word = nullptr; 
115    tesseract::Tesseract *tesseract = nullptr;
116    std::vector<int> best_state; 
117    std::vector<std::string> correct_text;
118    WERD_CHOICE *ep_choice = nullptr; 
119    REJMAP reject_map;                
120    bool tess_failed = false;
121    bool tess_accepted = false;    
122    bool tess_would_adapt = false; 
123    bool done = false;             
124    bool small_caps = false;       
125    bool odd_size = false;         
126    const FontInfo *fontinfo = nullptr;
127    const FontInfo *fontinfo2 = nullptr;
128    int8_t fontinfo_id_count = 0;  
129    int8_t fontinfo_id2_count = 0; 
130    bool guessed_x_ht = true;
131    bool guessed_caps_ht = true;
132    CRUNCH_MODE unlv_crunch_mode = CR_NONE;
133    float x_height = 0.0f;       
134    float caps_height = 0.0f;    
135    float baseline_shift = 0.0f; 
136    float space_certainty = 0.0f;
137    bool combination = false;   
138    bool part_of_combo = false; 
139    bool reject_spaces = false; 
140    WERD_RES() = default;
141    WERD_RES(WERD *the_word) {
142      word = the_word;
143    }
144    WERD_RES(const WERD_RES &source) : ELIST_LINK(source) {
145      combination = false;
146      *this = source; 
147    }
148    ~WERD_RES();
149    const char *BestUTF8(unsigned blob_index, bool in_rtl_context) const {
150      if (best_choice == nullptr || blob_index >= best_choice->length()) {
151        return nullptr;
152      }
153      UNICHAR_ID id = best_choice->unichar_id(blob_index);
154      if (static_cast<unsigned>(id) >= uch_set->size()) {
155        return nullptr;
156      }
157      UNICHAR_ID mirrored = uch_set->get_mirror(id);
158      if (in_rtl_context && mirrored > 0) {
159        id = mirrored;
160      }
161      return uch_set->id_to_unichar_ext(id);
162    }
163    const char *RawUTF8(unsigned blob_index) const {
164      if (blob_index >= raw_choice->length()) {
165        return nullptr;
166      }
167      UNICHAR_ID id = raw_choice->unichar_id(blob_index);
168      if (static_cast<unsigned>(id) >= uch_set->size()) {
169        return nullptr;
170      }
171      return uch_set->id_to_unichar(id);
172    }
173    UNICHARSET::Direction SymbolDirection(unsigned blob_index) const {
174      if (best_choice == nullptr || blob_index >= best_choice->length()) {
175        return UNICHARSET::U_OTHER_NEUTRAL;
176      }
177      return uch_set->get_direction(best_choice->unichar_id(blob_index));
178    }
179    bool AnyRtlCharsInWord() const {
180      if (uch_set == nullptr || best_choice == nullptr ||
181          best_choice->length() < 1) {
182        return false;
183      }
184      for (unsigned id = 0; id < best_choice->length(); id++) {
185        unsigned unichar_id = best_choice->unichar_id(id);
186        if (unichar_id >= uch_set->size()) {
187          continue; 
188        }
189        UNICHARSET::Direction dir = uch_set->get_direction(unichar_id);
190        if (dir == UNICHARSET::U_RIGHT_TO_LEFT ||
191            dir == UNICHARSET::U_RIGHT_TO_LEFT_ARABIC) {
192          return true;
193        }
194      }
195      return false;
196    }
197    bool AnyLtrCharsInWord() const {
198      if (uch_set == nullptr || best_choice == nullptr ||
199          best_choice->length() < 1) {
200        return false;
201      }
202      for (unsigned id = 0; id < best_choice->length(); id++) {
203        unsigned unichar_id = best_choice->unichar_id(id);
204        if (unichar_id >= uch_set->size()) {
205          continue; 
206        }
207        UNICHARSET::Direction dir = uch_set->get_direction(unichar_id);
208        if (dir == UNICHARSET::U_LEFT_TO_RIGHT ||
209            dir == UNICHARSET::U_ARABIC_NUMBER) {
210          return true;
211        }
212      }
213      return false;
214    }
215    bool UnicharsInReadingOrder() const {
216      return best_choice->unichars_in_script_order();
217    }
218    void Clear();
219    void ClearResults();
220    void ClearWordChoices();
221    void ClearRatings();
<span onclick='openModal()' class='match'>222    WERD_RES &operator=(const WERD_RES &source); 
223    void CopySimpleFields(const WERD_RES &source);
224    void InitForRetryRecognition(const WERD_RES &source);
225    bool SetupForRecognition(const UNICHARSET &unicharset_in,
226                             tesseract::Tesseract *tesseract, Image pix,
227                             int norm_mode, const TBOX *norm_box,
228                             bool numeric_mode, bool use_body_size,
229                             bool allow_detailed_fx, ROW *row,
230                             const BLOCK *block);
231    void SetupBasicsFromChoppedWord(const UNICHARSET &unicharset_in);
232    void SetupFake(const UNICHARSET &uch);
233    void SetupWordScript(const UNICHARSET &unicharset_in);
234    void SetupBlamerBundle();
235    void SetupBlobWidthsAndGaps();
236    void InsertSeam(int blob_number, SEAM *seam);
237    bool AlternativeChoiceAdjustmentsWorseThan(float threshold) const;
238    bool IsAmbiguous();
239    bool StatesAllValid();
240    void DebugWordChoices(bool debug, const char *word_to_debug);
241    void DebugTopChoice(const char *msg) const;
242    void FilterWordChoices(int debug_level);
243    void ComputeAdaptionThresholds(float certainty_scale, float min_rating,
244                                   float max_rating, float rating_margin,
245                                   float *thresholds);
246    bool LogNewRawChoice(WERD_CHOICE *word_choice);
247    bool LogNewCookedChoice(int max_num_choices, bool debug,
</span>248                            WERD_CHOICE *word_choice);
249    void PrintBestChoices() const;
250    int GetBlobsWidth(int start_blob, int last_blob) const;
251    int GetBlobsGap(unsigned blob_index) const;
252    BLOB_CHOICE *GetBlobChoice(unsigned index) const;
253    BLOB_CHOICE_LIST *GetBlobChoices(int index) const;
254    void ConsumeWordResults(WERD_RES *word);
255    void ReplaceBestChoice(WERD_CHOICE *choice);
256    void RebuildBestState();
257    void CloneChoppedToRebuild();
258    void SetupBoxWord();
259    void SetScriptPositions();
260    void SetAllScriptPositions(tesseract::ScriptPos position);
261    void FakeClassifyWord(unsigned blob_count, BLOB_CHOICE **choices);
262    void FakeWordFromRatings(PermuterType permuter);
263    void BestChoiceToCorrectText();
264    bool ConditionalBlobMerge(
265        const std::function<UNICHAR_ID(UNICHAR_ID, UNICHAR_ID)> &class_cb,
266        const std::function<bool(const TBOX &, const TBOX &)> &box_cb);
267    void MergeAdjacentBlobs(unsigned index);
268    UNICHAR_ID BothQuotes(UNICHAR_ID id1, UNICHAR_ID id2);
269    void fix_quotes();
270    UNICHAR_ID BothHyphens(UNICHAR_ID id1, UNICHAR_ID id2);
271    bool HyphenBoxesOverlap(const TBOX &box1, const TBOX &box2);
272    void fix_hyphens();
273    UNICHAR_ID BothSpaces(UNICHAR_ID id1, UNICHAR_ID id2);
274    void merge_tess_fails();
275    static WERD_RES *deep_copy(const WERD_RES *src) {
276      auto *result = new WERD_RES(*src);
277      if (src->ratings != nullptr) {
278        result->ratings = src->ratings->DeepCopy();
279      }
280      return result;
281    }
282    void copy_on(WERD_RES *word_res) { 
283      word->set_flag(W_BOL, word->flag(W_BOL) || word_res->word->flag(W_BOL));
284      word->set_flag(W_EOL, word->flag(W_EOL) || word_res->word->flag(W_EOL));
285      word->copy_on(word_res->word);
286    }
287    bool PiecesAllNatural(int start, int count) const;
288  };
289  class TESS_API PAGE_RES_IT {
290  public:
291    PAGE_RES *page_res; 
292    PAGE_RES_IT() = default;
293    PAGE_RES_IT(PAGE_RES *the_page_res) { 
294      page_res = the_page_res;
295      restart_page(); 
296    }
297    bool operator==(const PAGE_RES_IT &other) const {
298      return word_res == other.word_res && row_res == other.row_res &&
299             block_res == other.block_res;
300    }
301    bool operator!=(const PAGE_RES_IT &other) const {
302      return !(*this == other);
303    }
304    int cmp(const PAGE_RES_IT &other) const;
305    WERD_RES *restart_page() {
306      return start_page(false); 
307    }
308    WERD_RES *restart_page_with_empties() {
309      return start_page(true); 
310    }
311    WERD_RES *start_page(bool empty_ok);
312    WERD_RES *restart_row();
313    WERD_RES *InsertSimpleCloneWord(const WERD_RES &clone_res, WERD *new_word);
314    void ReplaceCurrentWord(PointerVector<WERD_RES> *words);
315    void DeleteCurrentWord();
316    void MakeCurrentWordFuzzy();
317    WERD_RES *forward() { 
318      return internal_forward(false, false);
319    }
320    WERD_RES *forward_with_empties() {
321      return internal_forward(false, true);
322    }
323    WERD_RES *forward_paragraph(); 
324    WERD_RES *forward_block();     
325    WERD_RES *prev_word() const { 
326      return prev_word_res;
327    }
328    ROW_RES *prev_row() const { 
329      return prev_row_res;
330    }
331    BLOCK_RES *prev_block() const { 
332      return prev_block_res;
333    }
334    WERD_RES *word() const { 
335      return word_res;
336    }
337    ROW_RES *row() const { 
338      return row_res;
339    }
340    BLOCK_RES *block() const { 
341      return block_res;
342    }
343    WERD_RES *next_word() const { 
344      return next_word_res;
345    }
346    ROW_RES *next_row() const { 
347      return next_row_res;
348    }
349    BLOCK_RES *next_block() const { 
350      return next_block_res;
351    }
352    void rej_stat_word(); 
353    void ResetWordIterator();
354  private:
355    WERD_RES *internal_forward(bool new_block, bool empty_ok);
356    WERD_RES *prev_word_res;   
357    ROW_RES *prev_row_res;     
358    BLOCK_RES *prev_block_res; 
359    WERD_RES *word_res;   
360    ROW_RES *row_res;     
361    BLOCK_RES *block_res; 
362    WERD_RES *next_word_res;   
363    ROW_RES *next_row_res;     
364    BLOCK_RES *next_block_res; 
365    BLOCK_RES_IT block_res_it; 
366    ROW_RES_IT row_res_it;
367    WERD_RES_IT word_res_it;
368    WERD_RES_IT wr_it_of_current_word;
369    WERD_RES_IT wr_it_of_next_word;
370  };
371  } 
372  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-base_data_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pageres.h</div>
                </div>
                <div class="column column_space"><pre><code>42    explicit BasePrefetchingDataLayer(const LayerParameter& param);
43    void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
44        const vector<Blob<Dtype>*>& top);
45    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
46        const vector<Blob<Dtype>*>& top);
47    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
48        const vector<Blob<Dtype>*>& top);
49    static const int PREFETCH_COUNT = 3;
</pre></code></div>
                <div class="column column_space"><pre><code>222    WERD_RES &operator=(const WERD_RES &source); 
223    void CopySimpleFields(const WERD_RES &source);
224    void InitForRetryRecognition(const WERD_RES &source);
225    bool SetupForRecognition(const UNICHARSET &unicharset_in,
226                             tesseract::Tesseract *tesseract, Image pix,
227                             int norm_mode, const TBOX *norm_box,
228                             bool numeric_mode, bool use_body_size,
229                             bool allow_detailed_fx, ROW *row,
230                             const BLOCK *block);
231    void SetupBasicsFromChoppedWord(const UNICHARSET &unicharset_in);
232    void SetupFake(const UNICHARSET &uch);
233    void SetupWordScript(const UNICHARSET &unicharset_in);
234    void SetupBlamerBundle();
235    void SetupBlobWidthsAndGaps();
236    void InsertSeam(int blob_number, SEAM *seam);
237    bool AlternativeChoiceAdjustmentsWorseThan(float threshold) const;
238    bool IsAmbiguous();
239    bool StatesAllValid();
240    void DebugWordChoices(bool debug, const char *word_to_debug);
241    void DebugTopChoice(const char *msg) const;
242    void FilterWordChoices(int debug_level);
243    void ComputeAdaptionThresholds(float certainty_scale, float min_rating,
244                                   float max_rating, float rating_margin,
245                                   float *thresholds);
246    bool LogNewRawChoice(WERD_CHOICE *word_choice);
247    bool LogNewCookedChoice(int max_num_choices, bool debug,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    