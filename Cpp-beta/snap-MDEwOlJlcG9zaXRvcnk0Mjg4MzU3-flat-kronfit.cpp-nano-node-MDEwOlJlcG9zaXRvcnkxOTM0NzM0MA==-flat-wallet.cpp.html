
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.362058993637941%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronfit.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "kronecker.h"
3  int main(int argc, char* argv[]) {
4    Env = TEnv(argc, argv, TNotify::StdNotify);
5    Env.PrepArgs(TStr::Fmt("Kronecker graphs. build: %s, %s. Time: %s", __TIME__, __DATE__, TExeTm::GetCurTm()));
6    TExeTm ExeTm;
7    Try
8    Env = TEnv(argc, argv, TNotify::StdNotify);
9    const TStr InFNm = Env.GetIfArgPrefixStr("-i:", "../as20graph.txt", "Input graph file (single directed edge per line)");
10    TStr OutFNm = Env.GetIfArgPrefixStr("-o:", "", "Output file prefix");
11    const TInt NZero = Env.GetIfArgPrefixInt("-n0:", 2, "Innitiator matrix size");
12    const TStr InitMtx = Env.GetIfArgPrefixStr("-m:", "0.9 0.7; 0.5 0.2", "Init Gradient Descent Matrix (R=random)").GetLc();
13    const TStr Perm = Env.GetIfArgPrefixStr("-p:", "d", "Initial node permutation: d:Degree, r:Random, o:Order").GetLc();
14    const TInt GradIter = Env.GetIfArgPrefixInt("-gi:", 50, "Gradient descent iterations");
15    const TFlt LrnRate = Env.GetIfArgPrefixFlt("-l:", 1e-5, "Learning rate");
16    const TFlt MnStep = Env.GetIfArgPrefixFlt("-mns:", 0.005, "Minimum gradient step");
<span onclick='openModal()' class='match'>17    const TFlt MxStep = Env.GetIfArgPrefixFlt("-mxs:", 0.05, "Maximum gradient step");
18    const TInt WarmUp =  Env.GetIfArgPrefixInt("-w:", 10000, "Samples to warm up");
19    const TInt NSamples = Env.GetIfArgPrefixInt("-s:", 100000, "Samples per gradient estimation");
20    const bool ScaleInitMtx = Env.GetIfArgPrefixBool("-sim:", true, "Scale the initiator to match the number of edges");
</span>21    const TFlt PermSwapNodeProb = Env.GetIfArgPrefixFlt("-nsp:", 1.0, "Probability of using NodeSwap (vs. EdgeSwap) MCMC proposal distribution");
22    if (OutFNm.Empty()) { OutFNm = TStr::Fmt("%s-fit%d", InFNm.GetFMid().CStr(), NZero()); }
23    PNGraph G;
24    if (InFNm.GetFExt().GetLc()==".ungraph") {
25      TFIn FIn(InFNm);  G=TSnap::ConvertGraph<PNGraph>(TUNGraph::Load(FIn), true); }
26    else if (InFNm.GetFExt().GetLc()==".ngraph") {
27      TFIn FIn(InFNm);  G=TNGraph::Load(FIn); }
28    else {
29      G = TSnap::LoadEdgeList<PNGraph>(InFNm, 0, 1);
30    }
31    TKronMtx InitKronMtx = InitMtx=="r" ? TKronMtx::GetRndMtx(NZero, 0.1) : TKronMtx::GetMtx(InitMtx);
32    InitKronMtx.Dump("INIT PARAM", true);
33    TKroneckerLL KronLL(G, InitKronMtx, PermSwapNodeProb);
34    if (ScaleInitMtx) {
35      InitKronMtx.SetForEdges(G->GetNodes(), G->GetEdges()); }
36    KronLL.InitLL(G, InitKronMtx);
37    InitKronMtx.Dump("SCALED PARAM", true);
38    KronLL.SetPerm(Perm.GetCh(0));
39    double LogLike = 0;
40    LogLike = KronLL.GradDescent(GradIter, LrnRate, MnStep, MxStep, WarmUp, NSamples);
41    const TKronMtx& FitMtx = KronLL.GetProbMtx();
42    FILE *F = fopen(OutFNm.CStr(), "w");
43    fprintf(F, "Input\t%s\n", InFNm.CStr());
44    TStrV ParamV; Env.GetCmLn().SplitOnAllCh(' ', ParamV);
45    fprintf(F, "Command line options\n");
46    for (int i = 0; i < ParamV.Len(); i++) {
47      fprintf(F, "\t%s\n", ParamV[i].CStr()+(ParamV[i][0]=='-'?1:0)); }
48    fprintf(F, "Loglikelihood\t%10.2f\n", LogLike);
49    fprintf(F, "Absolute error (based on expected number of edges)\t%f\n", KronLL.GetAbsErr());
50    fprintf(F, "RunTime\t%g\n", ExeTm.GetSecs());
51    fprintf(F, "Estimated initiator\t%s\n", FitMtx.GetMtxStr().CStr());
52    fclose(F);
53    Catch
54    printf("\nrun time: %s (%s)\n", ExeTm.GetTmStr(), TSecTm::GetCurTm().GetTmStr().CStr());
55    return 0;
56  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallet.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/node/lmdb/wallet_value.hpp>
4  #include <nano/test_common/system.hpp>
5  #include <nano/test_common/testutil.hpp>
6  #include <gtest/gtest.h>
7  #include <boost/filesystem.hpp>
8  using namespace std::chrono_literals;
9  unsigned constexpr nano::wallet_store::version_current;
10  TEST (wallet, no_special_keys_accounts)
11  {
12  	bool init;
13  	nano::mdb_env env (init, nano::unique_path ());
14  	ASSERT_FALSE (init);
15  	auto transaction (env.tx_begin_write ());
16  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
17  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
18  	ASSERT_FALSE (init);
19  	nano::keypair key1;
20  	ASSERT_FALSE (wallet.exists (transaction, key1.pub));
21  	wallet.insert_adhoc (transaction, key1.prv);
22  	ASSERT_TRUE (wallet.exists (transaction, key1.pub));
23  	for (uint64_t account = 0; account < nano::wallet_store::special_count; account++)
24  	{
25  		nano::account account_l (account);
26  		ASSERT_FALSE (wallet.exists (transaction, account_l));
27  	}
28  }
29  TEST (wallet, no_key)
30  {
31  	bool init;
32  	nano::mdb_env env (init, nano::unique_path ());
33  	ASSERT_FALSE (init);
34  	auto transaction (env.tx_begin_write ());
35  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
36  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
37  	ASSERT_FALSE (init);
38  	nano::keypair key1;
39  	nano::raw_key prv1;
40  	ASSERT_TRUE (wallet.fetch (transaction, key1.pub, prv1));
41  	ASSERT_TRUE (wallet.valid_password (transaction));
42  }
43  TEST (wallet, fetch_locked)
44  {
45  	bool init;
46  	nano::mdb_env env (init, nano::unique_path ());
47  	ASSERT_FALSE (init);
48  	auto transaction (env.tx_begin_write ());
49  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
50  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
51  	ASSERT_TRUE (wallet.valid_password (transaction));
52  	nano::keypair key1;
53  	ASSERT_EQ (key1.pub, wallet.insert_adhoc (transaction, key1.prv));
54  	auto key2 (wallet.deterministic_insert (transaction));
55  	ASSERT_FALSE (key2.is_zero ());
56  	nano::raw_key key3;
57  	key3 = 1;
58  	wallet.password.value_set (key3);
59  	ASSERT_FALSE (wallet.valid_password (transaction));
60  	nano::raw_key key4;
61  	ASSERT_TRUE (wallet.fetch (transaction, key1.pub, key4));
62  	ASSERT_TRUE (wallet.fetch (transaction, key2, key4));
63  }
64  TEST (wallet, retrieval)
65  {
66  	bool init;
67  	nano::mdb_env env (init, nano::unique_path ());
68  	ASSERT_FALSE (init);
69  	auto transaction (env.tx_begin_write ());
70  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
71  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
72  	ASSERT_FALSE (init);
73  	nano::keypair key1;
74  	ASSERT_TRUE (wallet.valid_password (transaction));
75  	wallet.insert_adhoc (transaction, key1.prv);
76  	nano::raw_key prv1;
77  	ASSERT_FALSE (wallet.fetch (transaction, key1.pub, prv1));
78  	ASSERT_TRUE (wallet.valid_password (transaction));
79  	ASSERT_EQ (key1.prv, prv1);
80  	wallet.password.values[0]->bytes[16] ^= 1;
81  	nano::raw_key prv2;
82  	ASSERT_TRUE (wallet.fetch (transaction, key1.pub, prv2));
83  	ASSERT_FALSE (wallet.valid_password (transaction));
84  }
85  TEST (wallet, empty_iteration)
86  {
87  	bool init;
88  	nano::mdb_env env (init, nano::unique_path ());
89  	ASSERT_FALSE (init);
90  	auto transaction (env.tx_begin_write ());
91  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
92  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
93  	ASSERT_FALSE (init);
94  	auto i (wallet.begin (transaction));
95  	auto j (wallet.end ());
96  	ASSERT_EQ (i, j);
97  }
98  TEST (wallet, one_item_iteration)
99  {
100  	bool init;
101  	nano::mdb_env env (init, nano::unique_path ());
102  	ASSERT_FALSE (init);
103  	auto transaction (env.tx_begin_write ());
104  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
105  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
106  	ASSERT_FALSE (init);
107  	nano::keypair key1;
108  	wallet.insert_adhoc (transaction, key1.prv);
109  	for (auto i (wallet.begin (transaction)), j (wallet.end ()); i != j; ++i)
110  	{
111  		ASSERT_EQ (key1.pub, nano::uint256_union (i->first));
112  		nano::raw_key password;
113  		wallet.wallet_key (password, transaction);
114  		nano::raw_key key;
115  		key.decrypt (nano::wallet_value (i->second).key, password, (nano::uint256_union (i->first)).owords[0].number ());
116  		ASSERT_EQ (key1.prv, key);
117  	}
118  }
119  TEST (wallet, two_item_iteration)
120  {
121  	bool init;
122  	nano::mdb_env env (init, nano::unique_path ());
123  	ASSERT_FALSE (init);
124  	nano::keypair key1;
125  	nano::keypair key2;
126  	ASSERT_NE (key1.pub, key2.pub);
127  	std::unordered_set<nano::public_key> pubs;
128  	std::unordered_set<nano::raw_key> prvs;
129  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
130  	{
131  		auto transaction (env.tx_begin_write ());
132  		nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
133  		ASSERT_FALSE (init);
134  		wallet.insert_adhoc (transaction, key1.prv);
135  		wallet.insert_adhoc (transaction, key2.prv);
136  		for (auto i (wallet.begin (transaction)), j (wallet.end ()); i != j; ++i)
137  		{
138  			pubs.insert (i->first);
139  			nano::raw_key password;
140  			wallet.wallet_key (password, transaction);
141  			nano::raw_key key;
142  			key.decrypt (nano::wallet_value (i->second).key, password, (i->first).owords[0].number ());
143  			prvs.insert (key);
144  		}
145  	}
146  	ASSERT_EQ (2, pubs.size ());
147  	ASSERT_EQ (2, prvs.size ());
148  	ASSERT_NE (pubs.end (), pubs.find (key1.pub));
149  	ASSERT_NE (prvs.end (), prvs.find (key1.prv));
150  	ASSERT_NE (pubs.end (), pubs.find (key2.pub));
151  	ASSERT_NE (prvs.end (), prvs.find (key2.prv));
152  }
153  TEST (wallet, insufficient_spend_one)
154  {
155  	nano::test::system system (1);
156  	nano::keypair key1;
157  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
158  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 500));
159  	ASSERT_NE (nullptr, block);
160  	ASSERT_EQ (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, nano::dev::constants.genesis_amount));
161  }
162  TEST (wallet, spend_all_one)
163  {
164  	nano::test::system system (1);
165  	auto & node1 (*system.nodes[0]);
166  	nano::block_hash latest1 (node1.latest (nano::dev::genesis_key.pub));
167  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
168  	nano::keypair key2;
169  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, std::numeric_limits<nano::uint128_t>::max ()));
170  	auto transaction (node1.store.tx_begin_read ());
171  	auto info2 = node1.ledger.account_info (transaction, nano::dev::genesis_key.pub);
172  	ASSERT_NE (latest1, info2->head);
173  	auto block (node1.store.block.get (transaction, info2->head));
174  	ASSERT_NE (nullptr, block);
175  	ASSERT_EQ (latest1, block->previous ());
176  	ASSERT_TRUE (info2->balance.is_zero ());
177  	ASSERT_EQ (0, node1.balance (nano::dev::genesis_key.pub));
178  }
179  TEST (wallet, send_async)
180  {
181  	nano::test::system system (1);
182  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
183  	nano::keypair key2;
184  	std::thread thread ([&system] () {
185  		ASSERT_TIMELY (10s, system.nodes[0]->balance (nano::dev::genesis_key.pub).is_zero ());
186  	});
187  	std::atomic<bool> success (false);
188  	system.wallet (0)->send_async (nano::dev::genesis_key.pub, key2.pub, std::numeric_limits<nano::uint128_t>::max (), [&success] (std::shared_ptr<nano::block> const & block_a) { ASSERT_NE (nullptr, block_a); success = true; });
189  	thread.join ();
190  	ASSERT_TIMELY (2s, success);
191  }
192  TEST (wallet, spend)
193  {
194  	nano::test::system system (1);
195  	auto & node1 (*system.nodes[0]);
196  	nano::block_hash latest1 (node1.latest (nano::dev::genesis_key.pub));
197  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
198  	nano::keypair key2;
199  	ASSERT_EQ (nullptr, system.wallet (0)->send_action (0, key2.pub, 0));
200  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, std::numeric_limits<nano::uint128_t>::max ()));
201  	auto transaction (node1.store.tx_begin_read ());
202  	auto info2 = node1.ledger.account_info (transaction, nano::dev::genesis_key.pub);
203  	ASSERT_TRUE (info2);
204  	ASSERT_NE (latest1, info2->head);
205  	auto block (node1.store.block.get (transaction, info2->head));
206  	ASSERT_NE (nullptr, block);
207  	ASSERT_EQ (latest1, block->previous ());
208  	ASSERT_TRUE (info2->balance.is_zero ());
209  	ASSERT_EQ (0, node1.balance (nano::dev::genesis_key.pub));
210  }
211  TEST (wallet, change)
212  {
213  	nano::test::system system (1);
214  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
215  	nano::keypair key2;
216  	auto block1 (system.nodes[0]->rep_block (nano::dev::genesis_key.pub));
217  	ASSERT_FALSE (block1.is_zero ());
218  	ASSERT_NE (nullptr, system.wallet (0)->change_action (nano::dev::genesis_key.pub, key2.pub));
219  	auto block2 (system.nodes[0]->rep_block (nano::dev::genesis_key.pub));
220  	ASSERT_FALSE (block2.is_zero ());
221  	ASSERT_NE (block1, block2);
222  }
223  TEST (wallet, partial_spend)
224  {
225  	nano::test::system system (1);
226  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
227  	nano::keypair key2;
228  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 500));
229  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - 500, system.nodes[0]->balance (nano::dev::genesis_key.pub));
230  }
231  TEST (wallet, spend_no_previous)
232  {
233  	nano::test::system system (1);
234  	{
235  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
236  		auto transaction (system.nodes[0]->store.tx_begin_read ());
237  		auto info1 = system.nodes[0]->ledger.account_info (transaction, nano::dev::genesis_key.pub);
238  		ASSERT_TRUE (info1);
239  		for (auto i (0); i < 50; ++i)
240  		{
241  			nano::keypair key;
242  			system.wallet (0)->insert_adhoc (key.prv);
243  		}
244  	}
245  	nano::keypair key2;
246  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, 500));
247  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - 500, system.nodes[0]->balance (nano::dev::genesis_key.pub));
248  }
249  TEST (wallet, find_none)
250  {
251  	bool init;
252  	nano::mdb_env env (init, nano::unique_path ());
253  	ASSERT_FALSE (init);
254  	auto transaction (env.tx_begin_write ());
255  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
256  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
257  	ASSERT_FALSE (init);
258  	nano::account account (1000);
259  	ASSERT_EQ (wallet.end (), wallet.find (transaction, account));
260  }
261  TEST (wallet, find_existing)
262  {
263  	bool init;
264  	nano::mdb_env env (init, nano::unique_path ());
265  	ASSERT_FALSE (init);
266  	auto transaction (env.tx_begin_write ());
267  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
268  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
269  	ASSERT_FALSE (init);
270  	nano::keypair key1;
271  	ASSERT_FALSE (wallet.exists (transaction, key1.pub));
272  	wallet.insert_adhoc (transaction, key1.prv);
273  	ASSERT_TRUE (wallet.exists (transaction, key1.pub));
274  	auto existing (wallet.find (transaction, key1.pub));
275  	ASSERT_NE (wallet.end (), existing);
276  	++existing;
277  	ASSERT_EQ (wallet.end (), existing);
278  }
279  TEST (wallet, rekey)
280  {
281  	bool init;
282  	nano::mdb_env env (init, nano::unique_path ());
283  	ASSERT_FALSE (init);
284  	auto transaction (env.tx_begin_write ());
285  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
286  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
287  	ASSERT_FALSE (init);
288  	nano::raw_key password;
289  	wallet.password.value (password);
290  	ASSERT_TRUE (password.is_zero ());
291  	ASSERT_FALSE (init);
292  	nano::keypair key1;
293  	wallet.insert_adhoc (transaction, key1.prv);
294  	nano::raw_key prv1;
295  	wallet.fetch (transaction, key1.pub, prv1);
296  	ASSERT_EQ (key1.prv, prv1);
297  	ASSERT_FALSE (wallet.rekey (transaction, "1"));
298  	wallet.password.value (password);
299  	nano::raw_key password1;
300  	wallet.derive_key (password1, transaction, "1");
301  	ASSERT_EQ (password1, password);
302  	nano::raw_key prv2;
303  	wallet.fetch (transaction, key1.pub, prv2);
304  	ASSERT_EQ (key1.prv, prv2);
305  	*wallet.password.values[0] = 2;
306  	ASSERT_TRUE (wallet.rekey (transaction, "2"));
307  }
308  TEST (account, encode_zero)
309  {
310  	nano::account number0{};
311  	std::string str0;
312  	number0.encode_account (str0);
313  	ASSERT_EQ ((str0.front () == 'x') ? 64 : 65, str0.size ());
314  	ASSERT_EQ (65, str0.size ());
315  	nano::account number1;
316  	ASSERT_FALSE (number1.decode_account (str0));
317  	ASSERT_EQ (number0, number1);
318  }
319  TEST (account, encode_all)
320  {
321  	nano::account number0;
322  	number0.decode_hex ("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
323  	std::string str0;
324  	number0.encode_account (str0);
325  	ASSERT_EQ ((str0.front () == 'x') ? 64 : 65, str0.size ());
326  	nano::account number1;
327  	ASSERT_FALSE (number1.decode_account (str0));
328  	ASSERT_EQ (number0, number1);
329  }
330  TEST (account, encode_fail)
331  {
332  	nano::account number0{};
333  	std::string str0;
334  	number0.encode_account (str0);
335  	str0[16] ^= 1;
336  	nano::account number1;
337  	ASSERT_TRUE (number1.decode_account (str0));
338  }
339  TEST (wallet, hash_password)
340  {
341  	bool init;
342  	nano::mdb_env env (init, nano::unique_path ());
343  	ASSERT_FALSE (init);
344  	auto transaction (env.tx_begin_write ());
345  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
346  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
347  	ASSERT_FALSE (init);
348  	nano::raw_key hash1;
349  	wallet.derive_key (hash1, transaction, "");
350  	nano::raw_key hash2;
351  	wallet.derive_key (hash2, transaction, "");
352  	ASSERT_EQ (hash1, hash2);
353  	nano::raw_key hash3;
354  	wallet.derive_key (hash3, transaction, "a");
355  	ASSERT_NE (hash1, hash3);
356  }
357  TEST (fan, reconstitute)
358  {
359  	nano::raw_key value0 (0);
360  	nano::fan fan (value0, 1024);
361  	for (auto & i : fan.values)
362  	{
363  		ASSERT_NE (value0, *i);
364  	}
365  	nano::raw_key value1;
366  	fan.value (value1);
367  	ASSERT_EQ (value0, value1);
368  }
369  TEST (fan, change)
370  {
371  	nano::raw_key value0;
372  	value0 = 0;
373  	nano::raw_key value1;
374  	value1 = 1;
375  	ASSERT_NE (value0, value1);
376  	nano::fan fan (value0, 1024);
377  	ASSERT_EQ (1024, fan.values.size ());
378  	nano::raw_key value2;
379  	fan.value (value2);
380  	ASSERT_EQ (value0, value2);
381  	fan.value_set (value1);
382  	fan.value (value2);
383  	ASSERT_EQ (value1, value2);
384  }
385  TEST (wallet, reopen_default_password)
386  {
387  	bool init;
388  	nano::mdb_env env (init, nano::unique_path ());
389  	auto transaction (env.tx_begin_write ());
390  	ASSERT_FALSE (init);
391  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
392  	{
393  		nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
394  		ASSERT_FALSE (init);
395  		ASSERT_TRUE (wallet.valid_password (transaction));
396  	}
397  	{
398  		bool init;
399  		nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
400  		ASSERT_FALSE (init);
401  		ASSERT_TRUE (wallet.valid_password (transaction));
402  	}
403  	{
404  		nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
405  		ASSERT_FALSE (init);
406  		wallet.rekey (transaction, "");
407  		ASSERT_TRUE (wallet.valid_password (transaction));
408  	}
409  	{
410  		bool init;
411  		nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
412  		ASSERT_FALSE (init);
413  		ASSERT_FALSE (wallet.valid_password (transaction));
414  		wallet.attempt_password (transaction, " ");
415  		ASSERT_FALSE (wallet.valid_password (transaction));
416  		wallet.attempt_password (transaction, "");
417  		ASSERT_TRUE (wallet.valid_password (transaction));
418  	}
419  }
420  TEST (wallet, representative)
421  {
422  	auto error (false);
423  	nano::mdb_env env (error, nano::unique_path ());
424  	ASSERT_FALSE (error);
425  	auto transaction (env.tx_begin_write ());
426  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
427  	nano::wallet_store wallet (error, kdf, transaction, nano::dev::genesis->account (), 1, "0");
428  	ASSERT_FALSE (error);
429  	ASSERT_FALSE (wallet.is_representative (transaction));
430  	ASSERT_EQ (nano::dev::genesis->account (), wallet.representative (transaction));
431  	ASSERT_FALSE (wallet.is_representative (transaction));
432  	nano::keypair key;
433  	wallet.representative_set (transaction, key.pub);
434  	ASSERT_FALSE (wallet.is_representative (transaction));
435  	ASSERT_EQ (key.pub, wallet.representative (transaction));
436  	ASSERT_FALSE (wallet.is_representative (transaction));
437  	wallet.insert_adhoc (transaction, key.prv);
438  	ASSERT_TRUE (wallet.is_representative (transaction));
439  }
440  TEST (wallet, serialize_json_empty)
441  {
442  	auto error (false);
443  	nano::mdb_env env (error, nano::unique_path ());
444  	ASSERT_FALSE (error);
445  	auto transaction (env.tx_begin_write ());
446  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
447  	nano::wallet_store wallet1 (error, kdf, transaction, nano::dev::genesis->account (), 1, "0");
448  	ASSERT_FALSE (error);
449  	std::string serialized;
450  	wallet1.serialize_json (transaction, serialized);
451  	nano::wallet_store wallet2 (error, kdf, transaction, nano::dev::genesis->account (), 1, "1", serialized);
452  	ASSERT_FALSE (error);
453  	nano::raw_key password1;
454  	nano::raw_key password2;
455  	wallet1.wallet_key (password1, transaction);
456  	wallet2.wallet_key (password2, transaction);
457  	ASSERT_EQ (password1, password2);
458  	ASSERT_EQ (wallet1.salt (transaction), wallet2.salt (transaction));
459  	ASSERT_EQ (wallet1.check (transaction), wallet2.check (transaction));
460  	ASSERT_EQ (wallet1.representative (transaction), wallet2.representative (transaction));
461  	ASSERT_EQ (wallet1.end (), wallet1.begin (transaction));
462  	ASSERT_EQ (wallet2.end (), wallet2.begin (transaction));
463  }
464  TEST (wallet, serialize_json_one)
465  {
466  	auto error (false);
467  	nano::mdb_env env (error, nano::unique_path ());
468  	ASSERT_FALSE (error);
469  	auto transaction (env.tx_begin_write ());
470  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
471  	nano::wallet_store wallet1 (error, kdf, transaction, nano::dev::genesis->account (), 1, "0");
472  	ASSERT_FALSE (error);
473  	nano::keypair key;
474  	wallet1.insert_adhoc (transaction, key.prv);
475  	std::string serialized;
476  	wallet1.serialize_json (transaction, serialized);
477  	nano::wallet_store wallet2 (error, kdf, transaction, nano::dev::genesis->account (), 1, "1", serialized);
478  	ASSERT_FALSE (error);
479  	nano::raw_key password1;
480  	nano::raw_key password2;
481  	wallet1.wallet_key (password1, transaction);
482  	wallet2.wallet_key (password2, transaction);
483  	ASSERT_EQ (password1, password2);
484  	ASSERT_EQ (wallet1.salt (transaction), wallet2.salt (transaction));
485  	ASSERT_EQ (wallet1.check (transaction), wallet2.check (transaction));
486  	ASSERT_EQ (wallet1.representative (transaction), wallet2.representative (transaction));
487  	ASSERT_TRUE (wallet2.exists (transaction, key.pub));
488  	nano::raw_key prv;
489  	wallet2.fetch (transaction, key.pub, prv);
490  	ASSERT_EQ (key.prv, prv);
491  }
492  TEST (wallet, serialize_json_password)
493  {
494  	auto error (false);
495  	nano::mdb_env env (error, nano::unique_path ());
496  	ASSERT_FALSE (error);
497  	auto transaction (env.tx_begin_write ());
498  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
499  	nano::wallet_store wallet1 (error, kdf, transaction, nano::dev::genesis->account (), 1, "0");
500  	ASSERT_FALSE (error);
501  	nano::keypair key;
502  	wallet1.rekey (transaction, "password");
503  	wallet1.insert_adhoc (transaction, key.prv);
504  	std::string serialized;
505  	wallet1.serialize_json (transaction, serialized);
506  	nano::wallet_store wallet2 (error, kdf, transaction, nano::dev::genesis->account (), 1, "1", serialized);
507  	ASSERT_FALSE (error);
508  	ASSERT_FALSE (wallet2.valid_password (transaction));
509  	ASSERT_FALSE (wallet2.attempt_password (transaction, "password"));
510  	ASSERT_TRUE (wallet2.valid_password (transaction));
511  	nano::raw_key password1;
512  	nano::raw_key password2;
513  	wallet1.wallet_key (password1, transaction);
514  	wallet2.wallet_key (password2, transaction);
515  	ASSERT_EQ (password1, password2);
516  	ASSERT_EQ (wallet1.salt (transaction), wallet2.salt (transaction));
517  	ASSERT_EQ (wallet1.check (transaction), wallet2.check (transaction));
518  	ASSERT_EQ (wallet1.representative (transaction), wallet2.representative (transaction));
519  	ASSERT_TRUE (wallet2.exists (transaction, key.pub));
520  	nano::raw_key prv;
521  	wallet2.fetch (transaction, key.pub, prv);
522  	ASSERT_EQ (key.prv, prv);
523  }
524  TEST (wallet_store, move)
525  {
526  	auto error (false);
527  	nano::mdb_env env (error, nano::unique_path ());
528  	ASSERT_FALSE (error);
529  	auto transaction (env.tx_begin_write ());
530  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
531  	nano::wallet_store wallet1 (error, kdf, transaction, nano::dev::genesis->account (), 1, "0");
532  	ASSERT_FALSE (error);
533  	nano::keypair key1;
534  	wallet1.insert_adhoc (transaction, key1.prv);
535  	nano::wallet_store wallet2 (error, kdf, transaction, nano::dev::genesis->account (), 1, "1");
536  	ASSERT_FALSE (error);
537  	nano::keypair key2;
538  	wallet2.insert_adhoc (transaction, key2.prv);
539  	ASSERT_FALSE (wallet1.exists (transaction, key2.pub));
540  	ASSERT_TRUE (wallet2.exists (transaction, key2.pub));
541  	std::vector<nano::public_key> keys;
542  	keys.push_back (key2.pub);
543  	ASSERT_FALSE (wallet1.move (transaction, wallet2, keys));
544  	ASSERT_TRUE (wallet1.exists (transaction, key2.pub));
545  	ASSERT_FALSE (wallet2.exists (transaction, key2.pub));
546  }
547  TEST (wallet_store, import)
548  {
549  	nano::test::system system (2);
550  	auto wallet1 (system.wallet (0));
551  	auto wallet2 (system.wallet (1));
552  	nano::keypair key1;
553  	wallet1->insert_adhoc (key1.prv);
554  	std::string json;
555  	wallet1->serialize (json);
556  	ASSERT_FALSE (wallet2->exists (key1.pub));
557  	auto error (wallet2->import (json, ""));
558  	ASSERT_FALSE (error);
559  	ASSERT_TRUE (wallet2->exists (key1.pub));
560  }
561  TEST (wallet_store, fail_import_bad_password)
562  {
563  	nano::test::system system (2);
564  	auto wallet1 (system.wallet (0));
565  	auto wallet2 (system.wallet (1));
566  	nano::keypair key1;
567  	wallet1->insert_adhoc (key1.prv);
568  	std::string json;
569  	wallet1->serialize (json);
570  	ASSERT_FALSE (wallet2->exists (key1.pub));
571  	auto error (wallet2->import (json, "1"));
572  	ASSERT_TRUE (error);
573  }
574  TEST (wallet_store, fail_import_corrupt)
575  {
576  	nano::test::system system (2);
577  	auto wallet1 (system.wallet (1));
578  	std::string json;
579  	auto error (wallet1->import (json, "1"));
580  	ASSERT_TRUE (error);
581  }
582  TEST (wallet, work)
583  {
584  	nano::test::system system (1);
585  	auto wallet (system.wallet (0));
586  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
587  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
588  	auto done (false);
589  	system.deadline_set (20s);
590  	while (!done)
591  	{
592  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
593  		uint64_t work (0);
594  		if (!wallet->store.work_get (transaction, nano::dev::genesis_key.pub, work))
595  		{
596  			done = nano::dev::network_params.work.difficulty (nano::dev::genesis->work_version (), nano::dev::genesis->hash (), work) >= system.nodes[0]->default_difficulty (nano::dev::genesis->work_version ());
597  		}
598  		ASSERT_NO_ERROR (system.poll ());
599  	}
600  }
601  TEST (wallet, work_generate)
602  {
603  	nano::test::system system (1);
604  	auto & node1 (*system.nodes[0]);
605  	auto wallet (system.wallet (0));
606  	nano::uint128_t amount1 (node1.balance (nano::dev::genesis_key.pub));
607  	uint64_t work1;
608  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
609  	nano::account account1;
610  	{
611  		auto transaction (node1.wallets.tx_begin_read ());
612  		account1 = system.account (transaction, 0);
613  	}
614  	nano::keypair key;
615  	auto block (wallet->send_action (nano::dev::genesis_key.pub, key.pub, 100));
616  	auto transaction (node1.store.tx_begin_read ());
617  	ASSERT_TIMELY (10s, node1.ledger.account_balance (transaction, nano::dev::genesis_key.pub) != amount1);
618  	system.deadline_set (10s);
619  	auto again (true);
620  	while (again)
621  	{
622  		ASSERT_NO_ERROR (system.poll ());
623  		auto block_transaction (node1.store.tx_begin_read ());
624  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
625  		again = wallet->store.work_get (transaction, account1, work1) || nano::dev::network_params.work.difficulty (block->work_version (), node1.ledger.latest_root (block_transaction, account1), work1) < node1.default_difficulty (block->work_version ());
626  	}
627  }
628  TEST (wallet, work_cache_delayed)
629  {
630  	nano::test::system system (1);
631  	auto & node1 (*system.nodes[0]);
632  	auto wallet (system.wallet (0));
633  	uint64_t work1;
634  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
635  	nano::account account1;
636  	{
637  		auto transaction (node1.wallets.tx_begin_read ());
638  		account1 = system.account (transaction, 0);
639  	}
640  	nano::keypair key;
641  	auto block1 (wallet->send_action (nano::dev::genesis_key.pub, key.pub, 100));
642  	ASSERT_EQ (block1->hash (), node1.latest (nano::dev::genesis_key.pub));
643  	auto block2 (wallet->send_action (nano::dev::genesis_key.pub, key.pub, 100));
644  	ASSERT_EQ (block2->hash (), node1.latest (nano::dev::genesis_key.pub));
645  	ASSERT_EQ (block2->hash (), node1.wallets.delayed_work->operator[] (nano::dev::genesis_key.pub).as_block_hash ());
646  	auto threshold (node1.default_difficulty (nano::work_version::work_1));
647  	auto again (true);
648  	system.deadline_set (10s);
649  	while (again)
650  	{
651  		ASSERT_NO_ERROR (system.poll ());
652  		if (!wallet->store.work_get (node1.wallets.tx_begin_read (), account1, work1))
653  		{
654  			again = nano::dev::network_params.work.difficulty (nano::work_version::work_1, block2->hash (), work1) < threshold;
655  		}
656  	}
657  	ASSERT_GE (nano::dev::network_params.work.difficulty (nano::work_version::work_1, block2->hash (), work1), threshold);
658  }
659  TEST (wallet, insert_locked)
660  {
661  	nano::test::system system (1);
662  	auto wallet (system.wallet (0));
663  	{
664  		auto transaction (wallet->wallets.tx_begin_write ());
665  		wallet->store.rekey (transaction, "1");
666  		ASSERT_TRUE (wallet->store.valid_password (transaction));
667  		wallet->enter_password (transaction, "");
668  	}
669  	auto transaction (wallet->wallets.tx_begin_read ());
670  	ASSERT_FALSE (wallet->store.valid_password (transaction));
671  	ASSERT_TRUE (wallet->insert_adhoc (nano::keypair ().prv).is_zero ());
672  }
673  TEST (wallet, deterministic_keys)
674  {
675  	bool init;
676  	nano::mdb_env env (init, nano::unique_path ());
677  	ASSERT_FALSE (init);
678  	auto transaction (env.tx_begin_write ());
679  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
680  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
681  	auto key1 = wallet.deterministic_key (transaction, 0);
682  	auto key2 = wallet.deterministic_key (transaction, 0);
683  	ASSERT_EQ (key1, key2);
684  	auto key3 = wallet.deterministic_key (transaction, 1);
685  	ASSERT_NE (key1, key3);
686  	ASSERT_EQ (0, wallet.deterministic_index_get (transaction));
687  	wallet.deterministic_index_set (transaction, 1);
688  	ASSERT_EQ (1, wallet.deterministic_index_get (transaction));
689  	auto key4 (wallet.deterministic_insert (transaction));
690  	nano::raw_key key5;
691  	ASSERT_FALSE (wallet.fetch (transaction, key4, key5));
692  	ASSERT_EQ (key3, key5);
693  	ASSERT_EQ (2, wallet.deterministic_index_get (transaction));
694  	wallet.deterministic_index_set (transaction, 1);
695  	ASSERT_EQ (1, wallet.deterministic_index_get (transaction));
696  	wallet.erase (transaction, key4);
697  	ASSERT_FALSE (wallet.exists (transaction, key4));
698  	auto key8 (wallet.deterministic_insert (transaction));
699  	ASSERT_EQ (key4, key8);
700  	auto key6 (wallet.deterministic_insert (transaction));
701  	nano::raw_key key7;
702  	ASSERT_FALSE (wallet.fetch (transaction, key6, key7));
703  	ASSERT_NE (key5, key7);
704  	ASSERT_EQ (3, wallet.deterministic_index_get (transaction));
705  	nano::keypair key9;
706  	ASSERT_EQ (key9.pub, wallet.insert_adhoc (transaction, key9.prv));
707  	ASSERT_TRUE (wallet.exists (transaction, key9.pub));
708  	wallet.deterministic_clear (transaction);
709  	ASSERT_EQ (0, wallet.deterministic_index_get (transaction));
710  	ASSERT_FALSE (wallet.exists (transaction, key4));
711  	ASSERT_FALSE (wallet.exists (transaction, key6));
712  	ASSERT_FALSE (wallet.exists (transaction, key8));
713  	ASSERT_TRUE (wallet.exists (transaction, key9.pub));
714  }
715  TEST (wallet, reseed)
716  {
717  	bool init;
718  	nano::mdb_env env (init, nano::unique_path ());
719  	ASSERT_FALSE (init);
720  	auto transaction (env.tx_begin_write ());
721  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
722  	nano::wallet_store wallet (init, kdf, transaction, nano::dev::genesis->account (), 1, "0");
723  	nano::raw_key seed1;
724  	seed1 = 1;
725  	nano::raw_key seed2;
726  	seed2 = 2;
727  	wallet.seed_set (transaction, seed1);
728  	nano::raw_key seed3;
729  	wallet.seed (seed3, transaction);
730  	ASSERT_EQ (seed1, seed3);
731  	auto key1 (wallet.deterministic_insert (transaction));
732  	ASSERT_EQ (1, wallet.deterministic_index_get (transaction));
733  	wallet.seed_set (transaction, seed2);
734  	ASSERT_EQ (0, wallet.deterministic_index_get (transaction));
735  	nano::raw_key seed4;
736  	wallet.seed (seed4, transaction);
737  	ASSERT_EQ (seed2, seed4);
738  	auto key2 (wallet.deterministic_insert (transaction));
739  	ASSERT_NE (key1, key2);
740  	wallet.seed_set (transaction, seed1);
741  	nano::raw_key seed5;
742  	wallet.seed (seed5, transaction);
743  	ASSERT_EQ (seed1, seed5);
744  	auto key3 (wallet.deterministic_insert (transaction));
745  	ASSERT_EQ (key1, key3);
746  }
747  TEST (wallet, insert_deterministic_locked)
748  {
749  	nano::test::system system (1);
750  	auto wallet (system.wallet (0));
751  	auto transaction (wallet->wallets.tx_begin_write ());
752  	wallet->store.rekey (transaction, "1");
753  	ASSERT_TRUE (wallet->store.valid_password (transaction));
754  	wallet->enter_password (transaction, "");
755  	ASSERT_FALSE (wallet->store.valid_password (transaction));
756  	ASSERT_TRUE (wallet->deterministic_insert (transaction).is_zero ());
757  }
758  TEST (wallet, no_work)
759  {
760  	nano::test::system system (1);
761  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv, false);
762  	nano::keypair key2;
763  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, std::numeric_limits<nano::uint128_t>::max (), false));
764  	ASSERT_NE (nullptr, block);
765  	ASSERT_NE (0, block->block_work ());
766  	ASSERT_GE (nano::dev::network_params.work.difficulty (*block), nano::dev::network_params.work.threshold (block->work_version (), block->sideband ().details));
767  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
768  	uint64_t cached_work (0);
769  	system.wallet (0)->store.work_get (transaction, nano::dev::genesis_key.pub, cached_work);
770  	ASSERT_EQ (0, cached_work);
771  }
772  TEST (wallet, send_race)
773  {
774  	nano::test::system system (1);
775  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
776  	nano::keypair key2;
777  	for (auto i (1); i < 60; ++i)
778  	{
779  		ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, nano::Gxrb_ratio));
780  		ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * i, system.nodes[0]->balance (nano::dev::genesis_key.pub));
781  	}
782  }
783  TEST (wallet, password_race)
784  {
785  	nano::test::system system (1);
786  	nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
787  	auto wallet = system.wallet (0);
788  	std::thread thread ([&wallet] () {
789  		for (int i = 0; i < 100; i++)
790  		{
791  			auto transaction (wallet->wallets.tx_begin_write ());
792  			wallet->store.rekey (transaction, std::to_string (i));
793  		}
794  	});
795  	for (int i = 0; i < 100; i++)
796  	{
797  		auto transaction (wallet->wallets.tx_begin_read ());
798  		bool ok = wallet->store.valid_password (transaction);
799  		EXPECT_TRUE (ok);
800  		if (!ok)
801  		{
802  			break;
803  		}
804  	}
805  	thread.join ();
806  	system.stop ();
807  	runner.join ();
808  }
809  TEST (wallet, password_race_corrupt_seed)
810  {
811  	nano::test::system system (1);
812  	nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
813  	auto wallet = system.wallet (0);
814  	nano::raw_key seed;
815  	{
816  		auto transaction (wallet->wallets.tx_begin_write ());
817  		ASSERT_FALSE (wallet->store.rekey (transaction, "4567"));
818  		wallet->store.seed (seed, transaction);
819  		ASSERT_FALSE (wallet->store.attempt_password (transaction, "4567"));
820  	}
821  	std::vector<std::thread> threads;
822  	for (int i = 0; i < 100; i++)
823  	{
824  		threads.emplace_back ([&wallet] () {
825  			for (int i = 0; i < 10; i++)
826  			{
827  				auto transaction (wallet->wallets.tx_begin_write ());
828  				wallet->store.rekey (transaction, "0000");
829  			}
830  		});
831  		threads.emplace_back ([&wallet] () {
832  			for (int i = 0; i < 10; i++)
833  			{
834  				auto transaction (wallet->wallets.tx_begin_write ());
835  				wallet->store.rekey (transaction, "1234");
836  			}
837  		});
838  		threads.emplace_back ([&wallet] () {
839  			for (int i = 0; i < 10; i++)
840  			{
841  				auto transaction (wallet->wallets.tx_begin_read ());
842  				wallet->store.attempt_password (transaction, "1234");
843  			}
844  		});
845  	}
846  	for (auto & thread : threads)
847  	{
848  		thread.join ();
849  	}
850  	system.stop ();
851  	runner.join ();
852  	{
853  		auto transaction (wallet->wallets.tx_begin_write ());
854  		if (!wallet->store.attempt_password (transaction, "1234"))
855  		{
856  			nano::raw_key seed_now;
857  			wallet->store.seed (seed_now, transaction);
858  			ASSERT_TRUE (seed_now == seed);
859  		}
860  		else if (!wallet->store.attempt_password (transaction, "0000"))
861  		{
862  			nano::raw_key seed_now;
863  			wallet->store.seed (seed_now, transaction);
864  			ASSERT_TRUE (seed_now == seed);
865  		}
866  		else if (!wallet->store.attempt_password (transaction, "4567"))
867  		{
868  			nano::raw_key seed_now;
869  			wallet->store.seed (seed_now, transaction);
870  			ASSERT_TRUE (seed_now == seed);
871  		}
872  		else
873  		{
874  			ASSERT_FALSE (true);
875  		}
876  	}
877  }
878  TEST (wallet, change_seed)
879  {
880  	nano::test::system system (1);
881  	auto wallet (system.wallet (0));
882  	wallet->enter_initial_password ();
883  	nano::raw_key seed1;
884  	seed1 = 1;
885  	nano::public_key pub;
886  	uint32_t index (4);
887  	auto prv = nano::deterministic_key (seed1, index);
888  	pub = nano::pub_key (prv);
889  	wallet->insert_adhoc (nano::dev::genesis_key.prv, false);
890  	auto block (wallet->send_action (nano::dev::genesis_key.pub, pub, 100));
891  	ASSERT_NE (nullptr, block);
892  	system.nodes[0]->block_processor.flush ();
893  	{
894  		auto transaction (wallet->wallets.tx_begin_write ());
895  		wallet->change_seed (transaction, seed1);
896  		nano::raw_key seed2;
897  		wallet->store.seed (seed2, transaction);
898  		ASSERT_EQ (seed1, seed2);
899  		ASSERT_EQ (index + 1, wallet->store.deterministic_index_get (transaction));
900  	}
901  	ASSERT_TRUE (wallet->exists (pub));
902  }
903  TEST (wallet, deterministic_restore)
904  {
905  	nano::test::system system (1);
906  	auto wallet (system.wallet (0));
907  	wallet->enter_initial_password ();
908  	nano::raw_key seed1;
909  	seed1 = 1;
910  	nano::public_key pub;
911  	uint32_t index (4);
912  	{
913  		auto transaction (wallet->wallets.tx_begin_write ());
914  		wallet->change_seed (transaction, seed1);
915  		nano::raw_key seed2;
916  		wallet->store.seed (seed2, transaction);
917  		ASSERT_EQ (seed1, seed2);
918  		ASSERT_EQ (1, wallet->store.deterministic_index_get (transaction));
919  		auto prv = nano::deterministic_key (seed1, index);
920  		pub = nano::pub_key (prv);
921  	}
922  	wallet->insert_adhoc (nano::dev::genesis_key.prv, false);
923  	auto block (wallet->send_action (nano::dev::genesis_key.pub, pub, 100));
924  	ASSERT_NE (nullptr, block);
925  	system.nodes[0]->block_processor.flush ();
926  	{
927  		auto transaction (wallet->wallets.tx_begin_write ());
928  		wallet->deterministic_restore (transaction);
929  		ASSERT_EQ (index + 1, wallet->store.deterministic_index_get (transaction));
930  	}
931  	ASSERT_TRUE (wallet->exists (pub));
932  }
933  TEST (wallet, epoch_2_validation)
934  {
935  	nano::test::system system (1);
936  	auto & node (*system.nodes[0]);
937  	auto & wallet (*system.wallet (0));
938  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (node, nano::epoch::epoch_1));
939  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (node, nano::epoch::epoch_2));
940  	wallet.insert_adhoc (nano::dev::genesis_key.prv, false);
941  	auto tries = 0;
942  	auto max_tries = 20;
943  	auto amount = node.config.receive_minimum.number ();
944  	while (++tries < max_tries)
945  	{
946  		auto send = wallet.send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, amount, 1);
947  		ASSERT_NE (nullptr, send);
948  		ASSERT_EQ (nano::epoch::epoch_2, send->sideband ().details.epoch);
949  		ASSERT_EQ (nano::epoch::epoch_0, send->sideband ().source_epoch); 
950  		auto receive = wallet.receive_action (send->hash (), nano::dev::genesis_key.pub, amount, send->link ().as_account (), 1);
951  		ASSERT_NE (nullptr, receive);
952  		if (nano::dev::network_params.work.difficulty (*receive) < node.network_params.work.base)
953  		{
954  			ASSERT_GE (nano::dev::network_params.work.difficulty (*receive), node.network_params.work.epoch_2_receive);
955  			ASSERT_EQ (nano::epoch::epoch_2, receive->sideband ().details.epoch);
956  			ASSERT_EQ (nano::epoch::epoch_2, receive->sideband ().source_epoch);
957  			break;
958  		}
959  	}
960  	ASSERT_LT (tries, max_tries);
961  	ASSERT_NE (nullptr, wallet.change_action (nano::dev::genesis_key.pub, nano::keypair ().pub, 1));
962  }
963  TEST (wallet, epoch_2_receive_propagation)
964  {
965  	auto tries = 0;
966  	auto const max_tries = 20;
967  	while (++tries < max_tries)
968  	{
969  		nano::test::system system;
970  		nano::node_flags node_flags;
971  		node_flags.disable_request_loop = true;
972  		auto & node (*system.add_node (node_flags));
973  		auto & wallet (*system.wallet (0));
974  		auto epoch1 = system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
975  		ASSERT_NE (nullptr, epoch1);
976  		nano::keypair key;
977  		nano::state_block_builder builder;
978  		wallet.insert_adhoc (nano::dev::genesis_key.prv, false);
979  		wallet.insert_adhoc (key.prv, false);
980  		auto amount = node.config.receive_minimum.number ();
981  		auto send1 = wallet.send_action (nano::dev::genesis_key.pub, key.pub, amount, 1);
982  		ASSERT_NE (nullptr, send1);
983  		ASSERT_NE (nullptr, wallet.receive_action (send1->hash (), nano::dev::genesis_key.pub, amount, send1->link ().as_account (), 1));
984  		auto epoch2 = system.upgrade_genesis_epoch (node, nano::epoch::epoch_2);
985  		ASSERT_NE (nullptr, epoch2);
986  		auto send2 = wallet.send_action (nano::dev::genesis_key.pub, key.pub, amount, 1);
987  		ASSERT_NE (nullptr, send2);
988  		auto receive2 = wallet.receive_action (send2->hash (), key.pub, amount, send2->link ().as_account (), 1);
989  		ASSERT_NE (nullptr, receive2);
990  		if (nano::dev::network_params.work.difficulty (*receive2) < node.network_params.work.base)
991  		{
992  			ASSERT_GE (nano::dev::network_params.work.difficulty (*receive2), node.network_params.work.epoch_2_receive);
993  			ASSERT_EQ (nano::epoch::epoch_2, node.store.block.version (node.store.tx_begin_read (), receive2->hash ()));
994  			ASSERT_EQ (nano::epoch::epoch_2, receive2->sideband ().source_epoch);
995  			break;
996  		}
997  	}
998  	ASSERT_LT (tries, max_tries);
999  }
1000  TEST (wallet, epoch_2_receive_unopened)
1001  {
1002  	auto tries = 0;
1003  	auto const max_tries = 20;
1004  	while (++tries < max_tries)
1005  	{
1006  		nano::test::system system;
1007  		nano::node_flags node_flags;
1008  		node_flags.disable_request_loop = true;
1009  		auto & node (*system.add_node (node_flags));
1010  		auto & wallet (*system.wallet (0));
1011  		auto epoch1 = system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
1012  		ASSERT_NE (nullptr, epoch1);
1013  		nano::keypair key;
1014  		nano::state_block_builder builder;
1015  		wallet.insert_adhoc (nano::dev::genesis_key.prv, false);
1016  		auto amount = node.config.receive_minimum.number ();
1017  		auto send1 = wallet.send_action (nano::dev::genesis_key.pub, key.pub, amount, 1);
1018  		auto epoch2_unopened = builder
1019  							   .account (key.pub)
1020  							   .previous (0)
1021  							   .representative (0)
1022  							   .balance (0)
1023  							   .link (node.network_params.ledger.epochs.link (nano::epoch::epoch_2))
1024  							   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1025  							   .work (*system.work.generate (key.pub, node.network_params.work.epoch_2))
1026  							   .build ();
1027  		ASSERT_EQ (nano::process_result::progress, node.process (*epoch2_unopened).code);
1028  		wallet.insert_adhoc (key.prv, false);
1029  		auto receive1 = wallet.receive_action (send1->hash (), key.pub, amount, send1->link ().as_account (), 1);
1030  		ASSERT_NE (nullptr, receive1);
1031  		if (nano::dev::network_params.work.difficulty (*receive1) < node.network_params.work.base)
1032  		{
1033  			ASSERT_GE (nano::dev::network_params.work.difficulty (*receive1), node.network_params.work.epoch_2_receive);
1034  			ASSERT_EQ (nano::epoch::epoch_2, node.store.block.version (node.store.tx_begin_read (), receive1->hash ()));
1035  			ASSERT_EQ (nano::epoch::epoch_1, receive1->sideband ().source_epoch);
1036  			break;
1037  		}
1038  	}
1039  	ASSERT_LT (tries, max_tries);
1040  }
1041  TEST (wallet, foreach_representative_deadlock)
1042  {
1043  	nano::test::system system (1);
1044  	auto & node (*system.nodes[0]);
1045  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1046  	node.wallets.compute_reps ();
1047  	ASSERT_EQ (1, node.wallets.reps ().voting);
1048  	bool set = false;
1049  	node.wallets.foreach_representative ([&node, &set, &system] (nano::public_key const & pub, nano::raw_key const & prv) {
1050  		node.wallets.foreach_representative ([&node, &set, &system] (nano::public_key const & pub, nano::raw_key const & prv) {
1051  			ASSERT_TIMELY (5s, node.wallets.mutex.try_lock () == 1);
1052  			node.wallets.mutex.unlock ();
1053  			set = true;
1054  		});
1055  	});
1056  	ASSERT_TRUE (set);
1057  }
1058  TEST (wallet, search_receivable)
1059  {
1060  	nano::test::system system;
1061  	nano::node_config config = system.default_config ();
1062  	config.enable_voting = false;
1063  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1064  	nano::node_flags flags;
1065  	flags.disable_search_pending = true;
1066  	auto & node (*system.add_node (config, flags));
1067  	auto & wallet (*system.wallet (0));
1068  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
1069  	nano::block_builder builder;
1070  	auto send = builder.state ()
1071  				.account (nano::dev::genesis->account ())
1072  				.previous (nano::dev::genesis->hash ())
1073  				.representative (nano::dev::genesis->account ())
1074  				.balance (nano::dev::constants.genesis_amount - node.config.receive_minimum.number ())
1075  				.link (nano::dev::genesis->account ())
1076  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1077  				.work (*system.work.generate (nano::dev::genesis->hash ()))
1078  				.build ();
1079  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1080  	ASSERT_TRUE (node.active.empty ());
1081  	ASSERT_FALSE (wallet.search_receivable (wallet.wallets.tx_begin_read ()));
1082  	auto election = node.active.election (send->qualified_root ());
1083  	ASSERT_NE (nullptr, election);
1084  	wallet.store.erase (node.wallets.tx_begin_write (), nano::dev::genesis->account ());
1085  	election->force_confirm ();
1086  	ASSERT_TIMELY (5s, node.block_confirmed (send->hash ()) && node.active.empty ());
1087  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
1088  	ASSERT_EQ (2, node.ledger.cache.block_count);
1089  	ASSERT_FALSE (wallet.search_receivable (wallet.wallets.tx_begin_read ()));
1090  	ASSERT_TIMELY (3s, node.balance (nano::dev::genesis->account ()) == nano::dev::constants.genesis_amount);
1091  	auto receive_hash = node.ledger.latest (node.store.tx_begin_read (), nano::dev::genesis->account ());
1092  	auto receive = node.block (receive_hash);
1093  	ASSERT_NE (nullptr, receive);
1094  	ASSERT_EQ (receive->sideband ().height, 3);
1095  	ASSERT_EQ (send->hash (), receive->link ().as_block_hash ());
1096  }
1097  TEST (wallet, receive_pruned)
1098  {
1099  	nano::test::system system;
1100  	nano::node_flags node_flags;
1101  	node_flags.disable_request_loop = true;
1102  	auto & node1 = *system.add_node (node_flags);
1103  	node_flags.enable_pruning = true;
1104  	nano::node_config config = system.default_config ();
1105  	config.enable_voting = false; 
<span onclick='openModal()' class='match'>1106  	auto & node2 = *system.add_node (config, node_flags);
1107  	auto & wallet1 = *system.wallet (0);
1108  	auto & wallet2 = *system.wallet (1);
1109  	nano::keypair key;
</span>1110  	nano::state_block_builder builder;
1111  	wallet1.insert_adhoc (nano::dev::genesis_key.prv, false);
1112  	auto amount = node2.config.receive_minimum.number ();
1113  	auto send1 = wallet1.send_action (nano::dev::genesis_key.pub, key.pub, amount, 1);
1114  	auto send2 = wallet1.send_action (nano::dev::genesis_key.pub, key.pub, 1, 1);
1115  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 3);
1116  	{
1117  		auto transaction = node2.store.tx_begin_write ();
1118  		ASSERT_EQ (1, node2.ledger.pruning_action (transaction, send1->hash (), 2));
1119  	}
1120  	ASSERT_EQ (1, node2.ledger.cache.pruned_count);
1121  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1->hash ()));
1122  	ASSERT_FALSE (node2.store.block.exists (node2.store.tx_begin_read (), send1->hash ()));
1123  	wallet2.insert_adhoc (key.prv, false);
1124  	auto open1 = wallet2.receive_action (send1->hash (), key.pub, amount, send1->link ().as_account (), 1);
1125  	ASSERT_NE (nullptr, open1);
1126  	ASSERT_EQ (amount, node2.ledger.balance (node2.store.tx_begin_read (), open1->hash ()));
1127  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 4);
1128  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronfit.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>17    const TFlt MxStep = Env.GetIfArgPrefixFlt("-mxs:", 0.05, "Maximum gradient step");
18    const TInt WarmUp =  Env.GetIfArgPrefixInt("-w:", 10000, "Samples to warm up");
19    const TInt NSamples = Env.GetIfArgPrefixInt("-s:", 100000, "Samples per gradient estimation");
20    const bool ScaleInitMtx = Env.GetIfArgPrefixBool("-sim:", true, "Scale the initiator to match the number of edges");
</pre></code></div>
                <div class="column column_space"><pre><code>1106  	auto & node2 = *system.add_node (config, node_flags);
1107  	auto & wallet1 = *system.wallet (0);
1108  	auto & wallet2 = *system.wallet (1);
1109  	nano::keypair key;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    