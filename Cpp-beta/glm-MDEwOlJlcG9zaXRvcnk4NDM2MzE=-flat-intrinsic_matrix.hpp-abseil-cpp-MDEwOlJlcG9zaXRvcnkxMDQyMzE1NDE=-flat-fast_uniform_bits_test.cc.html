
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.637362637362637%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-intrinsic_matrix.hpp</h3>
            <pre><code>1  #ifndef glm_detail_intrinsic_matrix
2  #define glm_detail_intrinsic_matrix
3  #include "setup.hpp"
4  #if((GLM_ARCH & GLM_ARCH_SSE2) != GLM_ARCH_SSE2)
5  #	error "SSE2 instructions not supported or enabled"
6  #else
7  #include "intrinsic_geometric.hpp"
8  namespace glm{
9  namespace detail
10  {
<span onclick='openModal()' class='match'>11  	void sse_add_ps(__m128 in1[4], __m128 in2[4], __m128 out[4]);
12  	void sse_sub_ps(__m128 in1[4], __m128 in2[4], __m128 out[4]);
13  	__m128 sse_mul_ps(__m128 m[4], __m128 v);
14  	__m128 sse_mul_ps(__m128 v, __m128 m[4]);
15  	void sse_mul_ps(__m128 const in1[4], __m128 const in2[4], __m128 out[4]);
</span>16  	void sse_transpose_ps(__m128 const in[4], __m128 out[4]);
17  	void sse_inverse_ps(__m128 const in[4], __m128 out[4]);
18  	void sse_rotate_ps(__m128 const in[4], float Angle, float const v[3], __m128 out[4]);
19  	__m128 sse_det_ps(__m128 const m[4]);
20  	__m128 sse_slow_det_ps(__m128 const m[4]);
21  }
22  }
23  #include "intrinsic_matrix.inl"
24  #endif
25  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fast_uniform_bits_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/fast_uniform_bits.h"
2  #include <random>
3  #include "gtest/gtest.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace random_internal {
7  namespace {
8  template <typename IntType>
9  class FastUniformBitsTypedTest : public ::testing::Test {};
10  using IntTypes = ::testing::Types<uint8_t, uint16_t, uint32_t, uint64_t>;
11  TYPED_TEST_SUITE(FastUniformBitsTypedTest, IntTypes);
12  TYPED_TEST(FastUniformBitsTypedTest, BasicTest) {
13    using Limits = std::numeric_limits<TypeParam>;
14    using FastBits = FastUniformBits<TypeParam>;
15    EXPECT_EQ(0, (FastBits::min)());
16    EXPECT_EQ((Limits::max)(), (FastBits::max)());
17    constexpr int kIters = 10000;
18    std::random_device rd;
19    std::mt19937 gen(rd());
20    FastBits fast;
21    for (int i = 0; i < kIters; i++) {
22      const auto v = fast(gen);
23      EXPECT_LE(v, (FastBits::max)());
24      EXPECT_GE(v, (FastBits::min)());
25    }
26  }
27  template <typename UIntType, UIntType Lo, UIntType Hi, UIntType Val = Lo>
28  struct FakeUrbg {
29    using result_type = UIntType;
30    FakeUrbg() = default;
31    explicit FakeUrbg(bool r) : reject(r) {}
32    static constexpr result_type(max)() { return Hi; }
33    static constexpr result_type(min)() { return Lo; }
34    result_type operator()() {
35      return ((++calls % 2) == 1 && reject) ? Hi : Val;
36    }
37    bool reject = false;
38    size_t calls = 0;
39  };
40  TEST(FastUniformBitsTest, IsPowerOfTwoOrZero) {
41    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{0}));
42    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{1}));
43    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{2}));
44    EXPECT_FALSE(IsPowerOfTwoOrZero(uint8_t{3}));
45    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{4}));
46    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{16}));
47    EXPECT_FALSE(IsPowerOfTwoOrZero(uint8_t{17}));
48    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint8_t>::max)()));
49    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{0}));
50    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{1}));
51    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{2}));
52    EXPECT_FALSE(IsPowerOfTwoOrZero(uint16_t{3}));
53    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{4}));
54    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{16}));
55    EXPECT_FALSE(IsPowerOfTwoOrZero(uint16_t{17}));
56    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint16_t>::max)()));
57    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{0}));
58    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{1}));
59    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{2}));
60    EXPECT_FALSE(IsPowerOfTwoOrZero(uint32_t{3}));
61    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{32}));
62    EXPECT_FALSE(IsPowerOfTwoOrZero(uint32_t{17}));
63    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint32_t>::max)()));
64    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{0}));
65    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{1}));
66    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{2}));
67    EXPECT_FALSE(IsPowerOfTwoOrZero(uint64_t{3}));
68    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{4}));
69    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{64}));
70    EXPECT_FALSE(IsPowerOfTwoOrZero(uint64_t{17}));
71    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint64_t>::max)()));
72  }
73  TEST(FastUniformBitsTest, IntegerLog2) {
74    EXPECT_EQ(0, IntegerLog2(uint16_t{0}));
75    EXPECT_EQ(0, IntegerLog2(uint16_t{1}));
76    EXPECT_EQ(1, IntegerLog2(uint16_t{2}));
77    EXPECT_EQ(1, IntegerLog2(uint16_t{3}));
78    EXPECT_EQ(2, IntegerLog2(uint16_t{4}));
79    EXPECT_EQ(2, IntegerLog2(uint16_t{5}));
80    EXPECT_EQ(2, IntegerLog2(uint16_t{7}));
81    EXPECT_EQ(3, IntegerLog2(uint16_t{8}));
82    EXPECT_EQ(63, IntegerLog2((std::numeric_limits<uint64_t>::max)()));
83  }
84  TEST(FastUniformBitsTest, RangeSize) {
85    EXPECT_EQ(2, (RangeSize<FakeUrbg<uint8_t, 0, 1>>()));
86    EXPECT_EQ(3, (RangeSize<FakeUrbg<uint8_t, 0, 2>>()));
87    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint8_t, 0, 3>>()));
88    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint8_t, 2, 5>>()));
89    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint8_t, 2, 6>>()));
90    EXPECT_EQ(9, (RangeSize<FakeUrbg<uint8_t, 2, 10>>()));
91    EXPECT_EQ(
92        0, (RangeSize<
93               FakeUrbg<uint8_t, 0, (std::numeric_limits<uint8_t>::max)()>>()));
94    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint16_t, 0, 3>>()));
95    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint16_t, 2, 5>>()));
96    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint16_t, 2, 6>>()));
97    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint16_t, 1000, 1017>>()));
98    EXPECT_EQ(
99        0, (RangeSize<
100               FakeUrbg<uint16_t, 0, (std::numeric_limits<uint16_t>::max)()>>()));
101    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint32_t, 0, 3>>()));
102    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint32_t, 2, 5>>()));
103    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint32_t, 2, 6>>()));
104    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint32_t, 1000, 1017>>()));
105    EXPECT_EQ(0, (RangeSize<FakeUrbg<uint32_t, 0, 0xffffffff>>()));
106    EXPECT_EQ(0xffffffff, (RangeSize<FakeUrbg<uint32_t, 1, 0xffffffff>>()));
107    EXPECT_EQ(0xfffffffe, (RangeSize<FakeUrbg<uint32_t, 1, 0xfffffffe>>()));
108    EXPECT_EQ(0xfffffffd, (RangeSize<FakeUrbg<uint32_t, 2, 0xfffffffe>>()));
109    EXPECT_EQ(
110        0, (RangeSize<
111               FakeUrbg<uint32_t, 0, (std::numeric_limits<uint32_t>::max)()>>()));
112    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint64_t, 0, 3>>()));
113    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint64_t, 2, 5>>()));
114    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint64_t, 2, 6>>()));
115    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint64_t, 1000, 1017>>()));
116    EXPECT_EQ(0x100000000, (RangeSize<FakeUrbg<uint64_t, 0, 0xffffffff>>()));
117    EXPECT_EQ(0xffffffff, (RangeSize<FakeUrbg<uint64_t, 1, 0xffffffff>>()));
118    EXPECT_EQ(0xfffffffe, (RangeSize<FakeUrbg<uint64_t, 1, 0xfffffffe>>()));
119    EXPECT_EQ(0xfffffffd, (RangeSize<FakeUrbg<uint64_t, 2, 0xfffffffe>>()));
120    EXPECT_EQ(0, (RangeSize<FakeUrbg<uint64_t, 0, 0xffffffffffffffff>>()));
121    EXPECT_EQ(0xffffffffffffffff,
122              (RangeSize<FakeUrbg<uint64_t, 1, 0xffffffffffffffff>>()));
123    EXPECT_EQ(0xfffffffffffffffe,
124              (RangeSize<FakeUrbg<uint64_t, 1, 0xfffffffffffffffe>>()));
125    EXPECT_EQ(0xfffffffffffffffd,
126              (RangeSize<FakeUrbg<uint64_t, 2, 0xfffffffffffffffe>>()));
127    EXPECT_EQ(
128        0, (RangeSize<
129               FakeUrbg<uint64_t, 0, (std::numeric_limits<uint64_t>::max)()>>()));
130  }
131  using Urng1_5bit = FakeUrbg<uint8_t, 0, 2, 0>;  
132  using Urng4bits = FakeUrbg<uint8_t, 1, 0x10, 2>;
133  using Urng22bits = FakeUrbg<uint32_t, 0, 0x3fffff, 0x301020>;
134  using Urng31bits = FakeUrbg<uint32_t, 1, 0xfffffffe, 0x60070f03>;  
135  using Urng32bits = FakeUrbg<uint32_t, 0, 0xffffffff, 0x74010f01>;
136  using Urng33bits =
137      FakeUrbg<uint64_t, 1, 0x1ffffffff, 0x013301033>;  
138  using Urng63bits = FakeUrbg<uint64_t, 1, 0xfffffffffffffffe,
139                              0xfedcba9012345678>;  
140  using Urng64bits =
141      FakeUrbg<uint64_t, 0, 0xffffffffffffffff, 0x123456780fedcba9>;
142  TEST(FastUniformBitsTest, OutputsUpTo32Bits) {
143    Urng1_5bit urng1_5;
144    Urng4bits urng4;
145    Urng22bits urng22;
146    Urng31bits urng31;
147    Urng32bits urng32;
148    Urng33bits urng33;
149    Urng63bits urng63;
150    Urng64bits urng64;
151    {
152      FastUniformBits<uint8_t> fast8;
153      EXPECT_EQ(0x0, fast8(urng1_5));
154      EXPECT_EQ(0x11, fast8(urng4));
155      EXPECT_EQ(0x20, fast8(urng22));
156      EXPECT_EQ(0x2, fast8(urng31));
157      EXPECT_EQ(0x1, fast8(urng32));
158      EXPECT_EQ(0x32, fast8(urng33));
159      EXPECT_EQ(0x77, fast8(urng63));
160      EXPECT_EQ(0xa9, fast8(urng64));
161    }
162    {
163      FastUniformBits<uint16_t> fast16;
164      EXPECT_EQ(0x0, fast16(urng1_5));
165      EXPECT_EQ(0x1111, fast16(urng4));
166      EXPECT_EQ(0x1020, fast16(urng22));
167      EXPECT_EQ(0x0f02, fast16(urng31));
168      EXPECT_EQ(0x0f01, fast16(urng32));
169      EXPECT_EQ(0x1032, fast16(urng33));
170      EXPECT_EQ(0x5677, fast16(urng63));
171      EXPECT_EQ(0xcba9, fast16(urng64));
172    }
173    {
174      FastUniformBits<uint32_t> fast32;
175      EXPECT_EQ(0x0, fast32(urng1_5));
176      EXPECT_EQ(0x11111111, fast32(urng4));
177      EXPECT_EQ(0x08301020, fast32(urng22));
178      EXPECT_EQ(0x0f020f02, fast32(urng31));
179      EXPECT_EQ(0x74010f01, fast32(urng32));
180      EXPECT_EQ(0x13301032, fast32(urng33));
181      EXPECT_EQ(0x12345677, fast32(urng63));
182      EXPECT_EQ(0x0fedcba9, fast32(urng64));
183    }
184  }
<span onclick='openModal()' class='match'>185  TEST(FastUniformBitsTest, Outputs64Bits) {
186    FastUniformBits<uint64_t> fast64;
187    {
188      FakeUrbg<uint8_t, 0, 1, 0> urng0;
189      FakeUrbg<uint8_t, 0, 1, 1> urng1;
190      Urng4bits urng4;
191      Urng22bits urng22;
192      Urng31bits urng31;
193      Urng32bits urng32;
194      Urng33bits urng33;
195      Urng63bits urng63;
196      Urng64bits urng64;
</span>197      EXPECT_EQ(0x0, fast64(urng0));
198      EXPECT_EQ(64, urng0.calls);
199      EXPECT_EQ(0xffffffffffffffff, fast64(urng1));
200      EXPECT_EQ(64, urng1.calls);
201      EXPECT_EQ(0x1111111111111111, fast64(urng4));
202      EXPECT_EQ(16, urng4.calls);
203      EXPECT_EQ(0x01020c0408301020, fast64(urng22));
204      EXPECT_EQ(3, urng22.calls);
205      EXPECT_EQ(0x387811c3c0870f02, fast64(urng31));
206      EXPECT_EQ(3, urng31.calls);
207      EXPECT_EQ(0x74010f0174010f01, fast64(urng32));
208      EXPECT_EQ(2, urng32.calls);
209      EXPECT_EQ(0x808194040cb01032, fast64(urng33));
210      EXPECT_EQ(3, urng33.calls);
211      EXPECT_EQ(0x1234567712345677, fast64(urng63));
212      EXPECT_EQ(2, urng63.calls);
213      EXPECT_EQ(0x123456780fedcba9, fast64(urng64));
214      EXPECT_EQ(1, urng64.calls);
215    }
216    {
217      Urng1_5bit urng1_5;
218      EXPECT_EQ(0x0, fast64(urng1_5));
219      EXPECT_EQ(65, urng1_5.calls);
220    }
221    {
222      Urng1_5bit urng1_5(true);
223      Urng31bits urng31(true);
224      Urng33bits urng33(true);
225      Urng63bits urng63(true);
226      EXPECT_EQ(0, fast64(urng1_5));
227      EXPECT_EQ(128, urng1_5.calls);
228      EXPECT_EQ(0x387811c3c0870f02, fast64(urng31));
229      EXPECT_EQ(6, urng31.calls);
230      EXPECT_EQ(0x808194040cb01032, fast64(urng33));
231      EXPECT_EQ(6, urng33.calls);
232      EXPECT_EQ(0x1234567712345677, fast64(urng63));
233      EXPECT_EQ(4, urng63.calls);
234    }
235  }
236  TEST(FastUniformBitsTest, URBG32bitRegression) {
237    EXPECT_EQ(2147483646, RangeSize<std::minstd_rand>());
238    EXPECT_EQ(30, IntegerLog2(RangeSize<std::minstd_rand>()));
239    std::minstd_rand gen(1);
240    FastUniformBits<uint64_t> fast64;
241    EXPECT_EQ(0x05e47095f8791f45, fast64(gen));
242    EXPECT_EQ(0x028be17e3c07c122, fast64(gen));
243    EXPECT_EQ(0x55d2847c1626e8c2, fast64(gen));
244  }
245  }  
246  }  
247  ABSL_NAMESPACE_END
248  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-intrinsic_matrix.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fast_uniform_bits_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>11  	void sse_add_ps(__m128 in1[4], __m128 in2[4], __m128 out[4]);
12  	void sse_sub_ps(__m128 in1[4], __m128 in2[4], __m128 out[4]);
13  	__m128 sse_mul_ps(__m128 m[4], __m128 v);
14  	__m128 sse_mul_ps(__m128 v, __m128 m[4]);
15  	void sse_mul_ps(__m128 const in1[4], __m128 const in2[4], __m128 out[4]);
</pre></code></div>
                <div class="column column_space"><pre><code>185  TEST(FastUniformBitsTest, Outputs64Bits) {
186    FastUniformBits<uint64_t> fast64;
187    {
188      FakeUrbg<uint8_t, 0, 1, 0> urng0;
189      FakeUrbg<uint8_t, 0, 1, 1> urng1;
190      Urng4bits urng4;
191      Urng22bits urng22;
192      Urng31bits urng31;
193      Urng32bits urng32;
194      Urng33bits urng33;
195      Urng63bits urng63;
196      Urng64bits urng64;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    