
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.290091930541369%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-asio.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/boost/asio/write.hpp>
3  namespace nano
4  {
5  class shared_const_buffer
6  {
7  public:
<span onclick='openModal()' class='match'>8  	using value_type = boost::asio::const_buffer;
9  	using const_iterator = boost::asio::const_buffer const *;
10  	explicit shared_const_buffer (std::vector<uint8_t> const & data);
11  	explicit shared_const_buffer (uint8_t data);
12  	explicit shared_const_buffer (std::string const & data);
13  	explicit shared_const_buffer (std::vector<uint8_t> && data);
</span>14  	explicit shared_const_buffer (std::shared_ptr<std::vector<uint8_t>> const & data);
15  	boost::asio::const_buffer const * begin () const;
16  	boost::asio::const_buffer const * end () const;
17  	std::size_t size () const;
18  	std::vector<uint8_t> to_bytes () const;
19  private:
20  	std::shared_ptr<std::vector<uint8_t>> m_data;
21  	boost::asio::const_buffer m_buffer;
22  };
23  static_assert (boost::asio::is_const_buffer_sequence<shared_const_buffer>::value, "Not ConstBufferSequence compliant");
24  template <typename AsyncWriteStream, typename WriteHandler>
25  BOOST_ASIO_INITFN_RESULT_TYPE (WriteHandler, void (boost::system::error_code, std::size_t))
26  async_write (AsyncWriteStream & s, nano::shared_const_buffer const & buffer, WriteHandler && handler)
27  {
28  	return boost::asio::async_write (s, buffer, std::forward<WriteHandler> (handler));
29  }
30  template <typename AsyncWriteStream, typename BufferType, typename WriteHandler>
31  BOOST_ASIO_INITFN_RESULT_TYPE (WriteHandler, void (boost::system::error_code, std::size_t))
32  unsafe_async_write (AsyncWriteStream & s, BufferType && buffer, WriteHandler && handler)
33  {
34  	return boost::asio::async_write (s, buffer, std::forward<WriteHandler> (handler));
35  }
36  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascnetinf.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "cascnetinf.h"
3  double TCascade::TransProb(const int& NId1, const int& NId2) const {
4    if (!IsNode(NId1) || !IsNode(NId2)) { return Eps.Val; }
5    if (GetTm(NId1) >= GetTm(NId2)) { return Eps.Val; }
6    if (Model==0)
7      return Alpha*exp(-Alpha*(GetTm(NId2)-GetTm(NId1))); 
8    else if (Model==1)
9      return (Alpha-1)*pow((GetTm(NId2)-GetTm(NId1)), -Alpha); 
10    else
11      return Alpha*(GetTm(NId2)-GetTm(NId1))*exp(-0.5*Alpha*pow(GetTm(NId2)-GetTm(NId1), 2)); 
12    return (-1);
13  }
14  double TCascade::GetProb(const PNGraph& G) {
15      double P = 0;
16      for (int n = 0; n < Len(); n++) {
17        const int DstNId = GetNode(n);
18        const double DstTm = GetTm(DstNId);
19        TNGraph::TNodeI NI = G->GetNI(DstNId);
20        double MxProb = log(Eps);
21        int BestParent = -1;
22        for (int e = 0; e < NI.GetInDeg(); e++) {
23          const int SrcNId = NI.GetInNId(e);
24          if (IsNode(SrcNId) && GetTm(SrcNId) < DstTm) {
25            const double Prob = log(TransProb(SrcNId, DstNId));
26            if (MxProb < Prob) { MxProb = Prob;  BestParent = SrcNId; }
27          }
28        }
29        NIdHitH.GetDat(DstNId).Parent = BestParent;
30        P += MxProb;
31      }
32      return P;
33  }
34  void TCascade::InitProb() {
35      CurProb = log(Eps) * Len();
36      for (int i = 0; i < Len(); i++) {
37        NIdHitH[i].Parent = -1; }
38  }
39  double TCascade::UpdateProb(const int& N1, const int& N2, const bool& UpdateProb) {
40      if (!IsNode(N1) || !IsNode(N2)) { return CurProb; }
41      if (GetTm(N1) >= GetTm(N2)) { return CurProb; }
42      const double P1 = log(TransProb(GetParent(N2), N2));
43      const double P2 = log(TransProb(N1, N2)); 
44      if (P1 < P2) {
45        if (UpdateProb) { 
46          CurProb = CurProb - P1 + P2;
47          NIdHitH.GetDat(N2).Parent = N1;
48        } else {
49          return CurProb - P1 + P2; }
50      }
51      return CurProb;
52  }
53  void TNetInfBs::LoadCascadesTxt(TSIn& SIn, const int& Model, const double& alpha) {
54    TStr Line;
55    while (!SIn.Eof()) {
56      SIn.GetNextLn(Line);
57      if (Line=="") { break; }
58      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
59        AddNodeNm(NIdV[0].GetInt(), TNodeInfo(NIdV[1], 0)); 
60    }
61    printf("All nodes read!\n");
62    while (!SIn.Eof()) { SIn.GetNextLn(Line); AddCasc(Line, Model, alpha); }
63    printf("All cascades read!\n");
64  }
65  void TNetInfBs::LoadGroundTruthTxt(TSIn& SIn) {
66    GroundTruth = TNGraph::New(); TStr Line;
67    while (!SIn.Eof()) {
68      SIn.GetNextLn(Line);
69      if (Line=="") { break; }
70      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
71      GroundTruth->AddNode(NIdV[0].GetInt());
72    }
73    while (!SIn.Eof()) {
74      SIn.GetNextLn(Line);
75      TStrV NIdV; Line.SplitOnAllCh(',', NIdV);
76      GroundTruth->AddEdge(NIdV[0].GetInt(), NIdV[1].GetInt());
77      if (NIdV.Len()>2) { Alphas.AddDat(TIntPr(NIdV[0].GetInt(), NIdV[1].GetInt())) = NIdV[2].GetFlt(); }
78      else { Alphas.AddDat(TIntPr(NIdV[0].GetInt(), NIdV[1].GetInt())) = 1.0; }
79    }
80    printf("groundtruth nodes:%d edges:%d\n", GroundTruth->GetNodes(), GroundTruth->GetEdges());
81  }
82  void TNetInfBs::AddCasc(const TStr& CascStr, const int& Model, const double& alpha) {
83      TStrV NIdV; CascStr.SplitOnAllCh(',', NIdV);
84      TCascade C(alpha, Model);
85      for (int i = 0; i < NIdV.Len(); i+=2) {
86        int NId;
87        double Tm; 
88        NId = NIdV[i].GetInt();
89        Tm = NIdV[i+1].GetFlt();
90        GetNodeInfo(NId).Vol = GetNodeInfo(NId).Vol + 1;
91        C.Add(NId, Tm);
92      }
93      C.Sort();
94      CascV.Add(C);
95  }
<span onclick='openModal()' class='match'>96  void TNetInfBs::GenCascade(TCascade& C, const int& TModel, const double &window, TIntPrIntH& EdgesUsed, const double& delta,
97                 const double& std_waiting_time, const double& std_beta) {
98    TIntFltH InfectedNIdH; TIntH InfectedBy;
99    double GlobalTime; int StartNId;
100    double alpha, beta;
</span>101    if (GroundTruth->GetNodes() == 0)
102      return;
103    while (C.Len() < 2) {
104      C.Clr();
105      InfectedNIdH.Clr();
106      InfectedBy.Clr();
107      GlobalTime = 0;
108      StartNId = GroundTruth->GetRndNId();
109      InfectedNIdH.AddDat(StartNId) = GlobalTime;
110      while (true) {
111        InfectedNIdH.SortByDat(true);
112        const int& NId = InfectedNIdH.BegI().GetKey();
113        GlobalTime = InfectedNIdH.BegI().GetDat();
114        if (GlobalTime >= window)
115          break;
116        C.Add(NId, GlobalTime);
117        const TNGraph::TNodeI NI = GroundTruth->GetNI(NId);
118        for (int e = 0; e < NI.GetOutDeg(); e++) {
119          const int DstNId = NI.GetOutNId(e);
120          beta = Betas.GetDat(TIntPr(NId, DstNId));
121          if (TInt::Rnd.GetUniDev() > beta+std_beta*TFlt::Rnd.GetNrmDev())
122            continue;
123          alpha = Alphas.GetDat(TIntPr(NId, DstNId));
124          if (InfectedBy.IsKey(NId) && InfectedBy.GetDat(NId).Val == DstNId)
125            continue;
126          double sigmaT;
127          switch (TModel) {
128          case 0:
129            sigmaT = TInt::Rnd.GetExpDev(alpha);
130            break;
131          case 1:
132            sigmaT = TInt::Rnd.GetPowerDev(alpha);
133            while (sigmaT < delta) { sigmaT = TInt::Rnd.GetPowerDev(alpha); }
134            break;
135          case 2:
136            sigmaT = TInt::Rnd.GetRayleigh(1/sqrt(alpha));
137            break;
138          default:
139            sigmaT = 1;
140            break;
141          }
142          if (std_waiting_time > 0)
143            sigmaT = TFlt::GetMx(0.0, sigmaT + std_waiting_time*TFlt::Rnd.GetNrmDev());
144          double t1 = GlobalTime + sigmaT;
145          if (InfectedNIdH.IsKey(DstNId)) {
146            double t2 = InfectedNIdH.GetDat(DstNId);
147            if (t2 > t1 && t2 != window) {
148              InfectedNIdH.GetDat(DstNId) = t1;
149              InfectedBy.GetDat(DstNId) = NId;
150            }
151          } else {
152            InfectedNIdH.AddDat(DstNId) = t1;
153            InfectedBy.AddDat(DstNId) = NId;
154          }
155        }
156        InfectedNIdH.GetDat(NId) = window;
157      }
158    }
159    C.Sort();
160    for (TIntH::TIter EI = InfectedBy.BegI(); EI < InfectedBy.EndI(); EI++) {
161      TIntPr Edge(EI.GetDat().Val, EI.GetKey().Val);
162      if (!EdgesUsed.IsKey(Edge)) EdgesUsed.AddDat(Edge) = 0;
163      EdgesUsed.GetDat(Edge) += 1;
164    }
165  }
166  void TNetInfBs::Init() {
167    THash<TInt, TIntV> CascPN;
168      Graph = TNGraph::New();
169      EdgeGainV.Clr();
170      CascPerEdge.Clr();
171      PrecisionRecall.Clr();
172      for (int c = 0; c < CascV.Len(); c++) {
173        for (int i = 0; i < CascV[c].Len(); i++) {
174          if (!Graph->IsNode(CascV[c].GetNode(i))) Graph->AddNode(CascV[c].GetNode(i));
175          if (!CascPN.IsKey(CascV[c].GetNode(i))) CascPN.AddDat(CascV[c].GetNode(i)) = TIntV();
176          CascPN.GetDat(CascV[c].GetNode(i)).Add(c);
177        }
178        CascV[c].InitProb();
179      }
180      for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
181        TIntV &Cascs = CascPN.GetDat(NI.GetId());
182        for (int c = 0; c < Cascs.Len(); c++) {
183          for (int i=0; i < CascV[Cascs[c]].Len(); i++) {
184            if (CascV[Cascs[c]].GetNode(i)==NI.GetId())
185              continue;
186            if (CascV[Cascs[c]].GetTm(CascV[Cascs[c]].GetNode(i)) < CascV[Cascs[c]].GetTm(NI.GetId()) ) {
187              if (!CascPerEdge.IsKey(TIntPr(CascV[Cascs[c]].GetNode(i), NI.GetId()))) {
188                EdgeGainV.Add(TPair<TFlt, TIntPr>(TFlt::Mx, TIntPr(CascV[Cascs[c]].GetNode(i), NI.GetId())));
189                CascPerEdge.AddDat(TIntPr(CascV[Cascs[c]].GetNode(i), NI.GetId())) = TIntV();
190              }
191              CascPerEdge.GetDat(TIntPr(CascV[Cascs[c]].GetNode(i), NI.GetId())).Add(Cascs[c]);
192            }
193          }
194        }
195      }
196  }
197  double TNetInfBs::GetAllCascProb(const int& EdgeN1, const int& EdgeN2) {
198      double P = 0.0;
199      if (EdgeN1==-1 && EdgeN2==-1) {
200        for (int c = 0; c < CascV.Len(); c++) {
201              P += CascV[c].UpdateProb(EdgeN1, EdgeN2, false); } 
202        return P;
203      }
204      TIntV &CascsEdge = CascPerEdge.GetDat(TIntPr(EdgeN1, EdgeN2)); 
205      for (int c = 0; c < CascsEdge.Len(); c++) {
206        P += (CascV[CascsEdge[c]].UpdateProb(EdgeN1, EdgeN2, false) - CascV[CascsEdge[c]].CurProb); } 
207      return P;
208  }
209  TIntPr TNetInfBs::GetBestEdge(double& CurProb, double& LastGain, bool& msort, int &attempts) {
210    TIntPr BestE;
211    TVec<TInt> KeysV;
212    TVec<TPair<TFlt, TIntPr> > EdgeGainCopyToSortV;
213    TIntV EdgeZero;
214    double BestGain = TFlt::Mn;
215    int BestGainIndex = -1;
216      if (msort) {
217        for (int i=0; i<TMath::Mn(attempts-1, EdgeGainV.Len()); i++)
218            EdgeGainCopyToSortV.Add(EdgeGainV[i]);
219        EdgeGainCopyToSortV.Sort(false);
220        for (int i=0, ii=0, j=0; ii < EdgeGainCopyToSortV.Len(); j++) {
221          if ( (i+EdgeGainCopyToSortV.Len() < EdgeGainV.Len()) && (EdgeGainCopyToSortV[ii].Val1 < EdgeGainV[i+EdgeGainCopyToSortV.Len()].Val1) ) {
222            EdgeGainV[j] = EdgeGainV[i+EdgeGainCopyToSortV.Len()];
223            i++;
224          } else {
225            EdgeGainV[j] = EdgeGainCopyToSortV[ii];
226            ii++;
227          }
228        }
229      }
230      attempts = 0;
231    for (int e = 0; e < EdgeGainV.Len(); e++) {
232      const TIntPr& Edge = EdgeGainV[e].Val2;
233      if (Graph->IsEdge(Edge.Val1, Edge.Val2)) { continue; } 
234      const double EProb = GetAllCascProb(Edge.Val1, Edge.Val2);
235      EdgeGainV[e].Val1 = EProb; 
236      if (BestGain < EProb) {
237      BestGain = EProb;
238      BestGainIndex = e;
239      BestE = Edge;
240      }
241      attempts++;
242      if (!Graph->IsEdge(Edge.Val1, Edge.Val2) && Graph->GetEdges() > 1) {
243        if (EProb == 0)
244          EdgeZero.Add(e);
245      }
246      if (e+1 == EdgeGainV.Len() || BestGain >= EdgeGainV[e+1].Val1) {
247      CurProb += BestGain;
248      if (BestGain == 0)
249        return TIntPr(-1, -1);
250      EdgeGainV.Del(BestGainIndex);
251      for (int i=EdgeZero.Len()-1; i>=0; i--) {
252        if (EdgeZero[i] > BestGainIndex)
253          EdgeGainV.Del(EdgeZero[i]-1);
254        else
255          EdgeGainV.Del(EdgeZero[i]);
256      }
257      if (EdgeZero.Len() > 2) { attempts -= (EdgeZero.Len()-1); }
258      msort = (attempts > 1);
259      LastGain = BestGain;
260      return BestE;
261      }
262    }
263    printf("Edges exhausted!\n");
264    return TIntPr(-1, -1);
265  }
266  double TNetInfBs::GetBound(const TIntPr& Edge, double& CurProb) {
267    double Bound = 0;
268    TFltV Bounds;
269    for (int e=0; e < EdgeGainV.Len(); e++) {
270      const TIntPr& EE = EdgeGainV[e].Val2;
271      if (EE != Edge && !Graph->IsEdge(EE.Val1, EE.Val2)) {
272        const double EProb = GetAllCascProb(EE.Val1, EE.Val2);
273        if (EProb > CurProb) Bounds.Add(EProb - CurProb); }
274    }
275    Bounds.Sort(false);
276    for (int i=0; i<Graph->GetEdges() && i<Bounds.Len(); i++) Bound += Bounds[i];
277    return Bound;
278  }
279  void TNetInfBs::GreedyOpt(const int& MxEdges) {
280      double CurProb = GetAllCascProb(-1, -1);
281      double LastGain = TFlt::Mx;
282      int attempts = 0;
283      bool msort = false;
284      for (int k = 0; k < MxEdges && EdgeGainV.Len() > 0; k++) {
285        const TIntPr BestE = GetBestEdge(CurProb, LastGain, msort, attempts);
286        if (BestE == TIntPr(-1, -1)) 
287          break;
288        if (CompareGroundTruth) {
289          double precision = 0, recall = 0;
290          if (PrecisionRecall.Len() > 1) {
291            precision = PrecisionRecall[PrecisionRecall.Len()-1].Val2.Val;
292            recall = PrecisionRecall[PrecisionRecall.Len()-1].Val1.Val;
293          }
294          if (GroundTruth->IsEdge(BestE.Val1, BestE.Val2)) {
295            recall++;
296          } else {
297            precision++;
298          }
299          PrecisionRecall.Add(TPair<TFlt, TFlt>(recall, precision));
300        }
301        Graph->AddEdge(BestE.Val1, BestE.Val2); 
302        TIntV &CascsEdge = CascPerEdge.GetDat(BestE); 
303        for (int c = 0; c < CascsEdge.Len(); c++) {
304          CascV[CascsEdge[c]].UpdateProb(BestE.Val1, BestE.Val2, true); 
305        }
306        TInt Vol; TFlt AverageTimeDiff; TFltV TimeDiffs;
307        Vol = 0; AverageTimeDiff = 0;
308        for (int i=0; i< CascV.Len(); i++) {
309          if (CascV[i].IsNode(BestE.Val2) && CascV[i].GetParent(BestE.Val2) == BestE.Val1) {
310            Vol += 1; TimeDiffs.Add(CascV[i].GetTm(BestE.Val2)-CascV[i].GetTm(BestE.Val1));
311            AverageTimeDiff += TimeDiffs[TimeDiffs.Len()-1]; }
312        }
313        AverageTimeDiff /= Vol;
314        if (TimeDiffs.Len() > 0)
315          TimeDiffs.Sort();
316        else
317          TimeDiffs.Add(0);
318        EdgeInfoH.AddDat(BestE) = TEdgeInfo(Vol,
319                        LastGain,
320                        0.0,
321                        TimeDiffs[(int)(TimeDiffs.Len()/2)],
322                        AverageTimeDiff);
323      }
324      if (CompareGroundTruth) {
325        for (int i=0; i<PrecisionRecall.Len(); i++) {
326          PrecisionRecall[i].Val2 = 1.0 - PrecisionRecall[i].Val2/(PrecisionRecall[i].Val2+PrecisionRecall[i].Val1);
327          PrecisionRecall[i].Val1 /= (double)GroundTruth->GetEdges();
328        }
329      }
330  }
331  void TNetInfBs::SavePajek(const TStr& OutFNm) {
332      TIntSet NIdSet;
333      FILE *F = fopen(OutFNm.CStr(), "wt");
334      fprintf(F, "*Vertices %d\r\n", NIdSet.Len());
335      for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
336        const TNodeInfo& I = NI.GetDat();
337        fprintf(F, "%d \"%s\" ic Blue x_fact %f y_fact %f\r\n", NI.GetKey().Val,
338          I.Name.CStr(), TMath::Mx<double>(log((double)I.Vol)-5,1), TMath::Mx<double>(log((double)I.Vol)-5,1));
339      }
340      fprintf(F, "*Arcs\r\n");
341      for (TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
342        fprintf(F, "%d %d 1\r\n", EI.GetSrcNId(), EI.GetDstNId());
343      }
344      fclose(F);
345  }
346  void TNetInfBs::SavePlaneTextNet(const TStr& OutFNm) {
347    TIntSet NIdSet;
348    FILE *F = fopen(OutFNm.CStr(), "wt");
349    for (THash<TInt, TNodeInfo>::TIter NI = NodeNmH.BegI(); NI < NodeNmH.EndI(); NI++) {
350      fprintf(F, "%d,%d\r\n", NI.GetKey().Val, NI.GetKey().Val);
351    }
352    fprintf(F, "\r\n");
353    for (TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
354      fprintf(F, "%d,%d\r\n", EI.GetSrcNId(), EI.GetDstNId());
355    }
356    fclose(F);
357  }
358  void TNetInfBs::SaveEdgeInfo(const TStr& OutFNm) {
359    FILE *F = fopen(OutFNm.CStr(), "wt");
360    fprintf(F, "src dst vol marginal_gain median_timediff average_timediff\n");
361    for (THash<TIntPr, TEdgeInfo>::TIter EI = EdgeInfoH.BegI(); EI < EdgeInfoH.EndI(); EI++) {
362      TEdgeInfo &EdgeInfo = EI.GetDat();
363      fprintf(F, "%s/%s/%d/%f/%f/%f\n",
364          NodeNmH.GetDat(EI.GetKey().Val1.Val).Name.CStr(), NodeNmH.GetDat(EI.GetKey().Val2.Val).Name.CStr(),
365          EdgeInfo.Vol.Val, EdgeInfo.MarginalGain.Val,
366          EdgeInfo.MedianTimeDiff.Val,
367          EdgeInfo.AverageTimeDiff.Val);
368    }
369    fclose(F);
370  }
371  void TNetInfBs::SaveObjInfo(const TStr& OutFNm) {
372    TGnuPlot GnuPlot(OutFNm);
373    TFltV Objective;
374    for (THash<TIntPr, TEdgeInfo>::TIter EI = EdgeInfoH.BegI(); EI < EdgeInfoH.EndI(); EI++) {
375      if (Objective.Len()==0) { Objective.Add(EI.GetDat().MarginalGain); 
376      } else {
377        Objective.Add(Objective[Objective.Len()-1]+EI.GetDat().MarginalGain);
378      }
379    }
380    GnuPlot.AddPlot(Objective, gpwLinesPoints);
381    GnuPlot.SavePng();
382  }
383  void TNetInfBs::SaveGroundTruth(const TStr& OutFNm) {
384    TFOut FOut(OutFNm);
385    for (TNGraph::TNodeI NI = GroundTruth->BegNI(); NI < GroundTruth->EndNI(); NI++) {
386      FOut.PutStr(TStr::Fmt("%d,%d\r\n", NI.GetId(), NI.GetId())); 
387    }
388    FOut.PutStr("\r\n");
389    for (TNGraph::TEdgeI EI = GroundTruth->BegEI(); EI < GroundTruth->EndEI(); EI++) {
390      if (EI.GetSrcNId() != EI.GetDstNId()) {
391        if (Alphas.IsKey(TIntPr(EI.GetSrcNId(), EI.GetDstNId())))
392          FOut.PutStr(TStr::Fmt("%d,%d,%f\r\n", EI.GetSrcNId(), EI.GetDstNId(), Alphas.GetDat(TIntPr(EI.GetSrcNId(), EI.GetDstNId())).Val));
393        else
394          FOut.PutStr(TStr::Fmt("%d,%d,1\r\n", EI.GetSrcNId(), EI.GetDstNId()));
395      }
396    }
397  }
398  void TNetInfBs::SaveCascades(const TStr& OutFNm) {
399    TFOut FOut(OutFNm);
400    for (TNGraph::TNodeI NI = GroundTruth->BegNI(); NI < GroundTruth->EndNI(); NI++) {
401      FOut.PutStr(TStr::Fmt("%d,%d\r\n", NI.GetId(), NI.GetId())); 
402    }
403    FOut.PutStr("\r\n");
404    for (int i=0; i<CascV.Len(); i++) {
405      TCascade &C = CascV[i];
406      int j = 0;
407      for (THash<TInt, THitInfo>::TIter NI = C.NIdHitH.BegI(); NI < C.NIdHitH.EndI(); NI++, j++) {
408        if (j > 0)
409          FOut.PutStr(TStr::Fmt(",%d,%f", NI.GetDat().NId.Val, NI.GetDat().Tm.Val));
410        else
411          FOut.PutStr(TStr::Fmt("%d,%f", NI.GetDat().NId.Val, NI.GetDat().Tm.Val));
412      }
413      if (C.Len() >= 1)
414        FOut.PutStr(TStr::Fmt("\r\n"));
415    }
416  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-asio.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascnetinf.cpp</div>
                </div>
                <div class="column column_space"><pre><code>8  	using value_type = boost::asio::const_buffer;
9  	using const_iterator = boost::asio::const_buffer const *;
10  	explicit shared_const_buffer (std::vector<uint8_t> const & data);
11  	explicit shared_const_buffer (uint8_t data);
12  	explicit shared_const_buffer (std::string const & data);
13  	explicit shared_const_buffer (std::vector<uint8_t> && data);
</pre></code></div>
                <div class="column column_space"><pre><code>96  void TNetInfBs::GenCascade(TCascade& C, const int& TModel, const double &window, TIntPrIntH& EdgesUsed, const double& delta,
97                 const double& std_waiting_time, const double& std_beta) {
98    TIntFltH InfectedNIdH; TIntH InfectedBy;
99    double GlobalTime; int StartNId;
100    double alpha, beta;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    