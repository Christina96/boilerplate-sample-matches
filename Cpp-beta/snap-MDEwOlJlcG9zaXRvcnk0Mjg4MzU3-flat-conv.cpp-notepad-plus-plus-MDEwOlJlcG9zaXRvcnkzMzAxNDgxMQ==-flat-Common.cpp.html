
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.0133578995854444%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-conv.cpp</h3>
            <pre><code>1  namespace TSnap {
2  int LoadModeNetToNet(PMMNet Graph, const TStr& Name, PTable Table, const TStr& NCol,
3    TStrV& NodeAttrV) {
4    Graph->AddModeNet(Name);
5    TModeNet& Net = Graph->GetModeNetByName(Name);
6    return LoadMode(Net, Table, NCol, NodeAttrV);
<span onclick='openModal()' class='match'>7  }
8  int LoadMode(TModeNet& Graph, PTable Table, const TStr& NCol,
9    TStrV& NodeAttrV) {
10    const TAttrType NodeType = Table->GetColType(NCol);
11    const TInt NColIdx = Table->GetColIdx(NCol);
</span>12    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
13      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
14        continue;
15      }
16      TInt NVal;
17      if (NodeType == atFlt) {
18        return -1;
19      } else if (NodeType == atInt || NodeType == atStr) {
20        if (NodeType == atInt) {
21          NVal = (Table->IntCols)[NColIdx][CurrRowIdx];
22        } else {
23          NVal = (Table->StrColMaps)[NColIdx][CurrRowIdx];
24          if (strlen(Table->GetContextKey(NVal)) == 0) { continue; }  
25        }
26        if (!Graph.IsNode(NVal)) {Graph.AddNode(NVal); }
27      }
28      for (TInt i = 0; i < NodeAttrV.Len(); i++) {
29        TStr ColName = NodeAttrV[i];
30        TAttrType T = Table->GetColType(ColName);
31        TInt Index = Table->GetColIdx(ColName);
32        switch (T) {
33          case atInt:
34            Graph.AddIntAttrDatN(NVal, Table->IntCols[Index][CurrRowIdx], ColName);
35            break;
36          case atFlt:
37            Graph.AddFltAttrDatN(NVal, Table->FltCols[Index][CurrRowIdx], ColName);
38            break;
39          case atStr:
40            Graph.AddStrAttrDatN(NVal, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
41            break;
42        }
43      }
44    }
45    return 1;
46  }
47  int LoadCrossNetToNet(PMMNet Graph, const TStr& Mode1, const TStr& Mode2, const TStr& CrossName,
48   PTable Table, const TStr& SrcCol, const TStr& DstCol, TStrV& EdgeAttrV)
49  {
50    Graph->AddCrossNet(Mode1, Mode2, CrossName);
51    TCrossNet& Net = Graph->GetCrossNetByName(CrossName);
52    return LoadCrossNet(Net, Table, SrcCol, DstCol, EdgeAttrV);
53  }
54  int LoadCrossNet(TCrossNet& Graph, PTable Table, const TStr& SrcCol, const TStr& DstCol,
55    TStrV& EdgeAttrV)
56  {
57    const TAttrType NodeType = Table->GetColType(SrcCol);
58    Assert(NodeType == Table->GetColType(DstCol));
59    const TInt SrcColIdx = Table->GetColIdx(SrcCol);
60    const TInt DstColIdx = Table->GetColIdx(DstCol);
61    THash<TFlt, TInt> FltNodeVals;
62    for (int CurrRowIdx = 0; CurrRowIdx < (Table->Next).Len(); CurrRowIdx++) {
63      if ((Table->Next)[CurrRowIdx] == Table->Invalid) {
64        continue;
65      }
66      TInt SVal, DVal;
67      if (NodeType == atFlt) {
68        return -1;
69      } else if (NodeType == atInt || NodeType == atStr) {
70        if (NodeType == atInt) {
71          SVal = (Table->IntCols)[SrcColIdx][CurrRowIdx];
72          DVal = (Table->IntCols)[DstColIdx][CurrRowIdx];
73        } else {
74          SVal = (Table->StrColMaps)[SrcColIdx][CurrRowIdx];
75          if (strlen(Table->GetContextKey(SVal)) == 0) { continue; }  
76          DVal = (Table->StrColMaps)[DstColIdx][CurrRowIdx];
77          if (strlen(Table->GetContextKey(DVal)) == 0) { continue; }  
78        }
79      }
80      if (Graph.AddEdge(SVal, DVal, CurrRowIdx) == -1) { return -1; }
81      for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
82        TStr ColName = EdgeAttrV[i];
83        TAttrType T = Table->GetColType(ColName);
84        TInt Index = Table->GetColIdx(ColName);
85        switch (T) {
86          case atInt:
87            Graph.AddIntAttrDatE(CurrRowIdx, Table->IntCols[Index][CurrRowIdx], ColName);
88            break;
89          case atFlt:
90            Graph.AddFltAttrDatE(CurrRowIdx, Table->FltCols[Index][CurrRowIdx], ColName);
91            break;
92          case atStr:
93            Graph.AddStrAttrDatE(CurrRowIdx, Table->GetStrValIdx(Index, CurrRowIdx), ColName);
94            break;
95        }
96      }
97    }
98    return 1;
99  }
100  }; 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Common.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <stdexcept>
3  #include <shlwapi.h>
4  #include <uxtheme.h>
5  #include <cassert>
6  #include <codecvt>
7  #include <locale>
8  #include "StaticDialog.h"
9  #include "CustomFileDialog.h"
10  #include "FileInterface.h"
11  #include "Common.h"
12  #include "Utf8.h"
13  #include <Parameters.h>
14  #include "Buffer.h"
15  void printInt(int int2print)
16  {
17  	TCHAR str[32];
18  	wsprintf(str, TEXT("%d"), int2print);
19  	::MessageBox(NULL, str, TEXT(""), MB_OK);
20  }
21  void printStr(const TCHAR *str2print)
22  {
23  	::MessageBox(NULL, str2print, TEXT(""), MB_OK);
24  }
25  generic_string commafyInt(size_t n)
26  {
27  	generic_stringstream ss;
28  	ss.imbue(std::locale(""));
29  	ss << n;
30  	return ss.str();
31  }
32  std::string getFileContent(const TCHAR *file2read)
33  {
34  	if (!::PathFileExists(file2read))
35  		return "";
36  	const size_t blockSize = 1024;
37  	char data[blockSize];
38  	std::string wholeFileContent = "";
39  	FILE *fp = _wfopen(file2read, TEXT("rb"));
40  	size_t lenFile = 0;
41  	do
42  	{
43  		lenFile = fread(data, 1, blockSize, fp);
44  		if (lenFile <= 0) break;
45  		wholeFileContent.append(data, lenFile);
46  	}
47  	while (lenFile > 0);
48  	fclose(fp);
49  	return wholeFileContent;
50  }
51  char getDriveLetter()
52  {
53  	char drive = '\0';
54  	TCHAR current[MAX_PATH];
55  	::GetCurrentDirectory(MAX_PATH, current);
56  	int driveNbr = ::PathGetDriveNumber(current);
57  	if (driveNbr != -1)
58  		drive = 'A' + char(driveNbr);
59  	return drive;
60  }
61  generic_string relativeFilePathToFullFilePath(const TCHAR *relativeFilePath)
62  {
63  	generic_string fullFilePathName;
64  	TCHAR fullFileName[MAX_PATH];
65  	BOOL isRelative = ::PathIsRelative(relativeFilePath);
66  	if (isRelative)
67  	{
68  		::GetFullPathName(relativeFilePath, MAX_PATH, fullFileName, NULL);
69  		fullFilePathName += fullFileName;
70  	}
71  	else
72  	{
73  		if ((relativeFilePath[0] == '\\' && relativeFilePath[1] != '\\') || relativeFilePath[0] == '/')
74  		{
75  			fullFilePathName += getDriveLetter();
76  			fullFilePathName += ':';
77  		}
78  		fullFilePathName += relativeFilePath;
79  	}
80  	return fullFilePathName;
81  }
82  void writeFileContent(const TCHAR *file2write, const char *content2write)
83  {
84  	Win32_IO_File file(file2write);
85  	if (file.isOpened())
86  		file.writeStr(content2write);
87  }
88  void writeLog(const TCHAR *logFileName, const char *log2write)
89  {
90  	const DWORD accessParam{ GENERIC_READ | GENERIC_WRITE };
91  	const DWORD shareParam{ FILE_SHARE_READ | FILE_SHARE_WRITE };
92  	const DWORD dispParam{ OPEN_ALWAYS }; 
93  	const DWORD attribParam{ FILE_ATTRIBUTE_NORMAL };
94  	HANDLE hFile = ::CreateFileW(logFileName, accessParam, shareParam, NULL, dispParam, attribParam, NULL);
95  	if (hFile != INVALID_HANDLE_VALUE)
96  	{
97  		LARGE_INTEGER offset{};
98  		offset.QuadPart = 0;
99  		::SetFilePointerEx(hFile, offset, NULL, FILE_END);
100  		SYSTEMTIME currentTime = {};
101  		::GetLocalTime(&currentTime);
102  		generic_string dateTimeStrW = getDateTimeStrFrom(TEXT("yyyy-MM-dd HH:mm:ss"), currentTime);
103  		std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
104  		std::string log2writeStr = converter.to_bytes(dateTimeStrW);
105  		log2writeStr += "  ";
106  		log2writeStr += log2write;
107  		log2writeStr += "\n";
108  		DWORD bytes_written = 0;
109  		::WriteFile(hFile, log2writeStr.c_str(), static_cast<DWORD>(log2writeStr.length()), &bytes_written, NULL);
110  		::FlushFileBuffers(hFile);
111  		::CloseHandle(hFile);
112  	}
113  }
114  generic_string folderBrowser(HWND parent, const generic_string & title, int outputCtrlID, const TCHAR *defaultStr)
115  {
116  	generic_string folderName;
117  	CustomFileDialog dlg(parent);
118  	dlg.setTitle(title.c_str());
119  	TCHAR directory[MAX_PATH] = {};
120  	if (outputCtrlID != 0)
121  		::GetDlgItemText(parent, outputCtrlID, directory, _countof(directory));
122  	directory[_countof(directory) - 1] = '\0';
123  	if (!directory[0] && defaultStr)
124  		dlg.setFolder(defaultStr);
125  	else if (directory[0])
126  		dlg.setFolder(directory);
127  	folderName = dlg.pickFolder();
128  	if (!folderName.empty())
129  	{
130  		if (outputCtrlID != 0)
131  			::SetDlgItemText(parent, outputCtrlID, folderName.c_str());
132  	}
133  	return folderName;
134  }
135  generic_string getFolderName(HWND parent, const TCHAR *defaultDir)
136  {
137  	return folderBrowser(parent, TEXT("Select a folder"), 0, defaultDir);
138  }
139  void ClientRectToScreenRect(HWND hWnd, RECT* rect)
140  {
141  	POINT		pt{};
142  	pt.x		 = rect->left;
143  	pt.y		 = rect->top;
144  	::ClientToScreen( hWnd, &pt );
145  	rect->left   = pt.x;
146  	rect->top    = pt.y;
147  	pt.x		 = rect->right;
148  	pt.y		 = rect->bottom;
149  	::ClientToScreen( hWnd, &pt );
150  	rect->right  = pt.x;
151  	rect->bottom = pt.y;
152  }
153  std::vector<generic_string> tokenizeString(const generic_string & tokenString, const char delim)
154  {
155  	std::vector<generic_string> tokens;
156  	generic_string::size_type lastPos = tokenString.find_first_not_of(delim, 0);
157      generic_string::size_type pos     = tokenString.find_first_of(delim, lastPos);
158      while (pos != std::string::npos || lastPos != std::string::npos)
159      {
160          tokens.push_back(tokenString.substr(lastPos, pos - lastPos));
161          lastPos = tokenString.find_first_not_of(delim, pos);
162          pos = tokenString.find_first_of(delim, lastPos);
163      }
164  	return tokens;
165  }
166  void ScreenRectToClientRect(HWND hWnd, RECT* rect)
167  {
168  	POINT		pt{};
169  	pt.x		 = rect->left;
170  	pt.y		 = rect->top;
171  	::ScreenToClient( hWnd, &pt );
172  	rect->left   = pt.x;
173  	rect->top    = pt.y;
174  	pt.x		 = rect->right;
175  	pt.y		 = rect->bottom;
176  	::ScreenToClient( hWnd, &pt );
177  	rect->right  = pt.x;
178  	rect->bottom = pt.y;
179  }
180  int filter(unsigned int code, struct _EXCEPTION_POINTERS *)
181  {
182      if (code == EXCEPTION_ACCESS_VIOLATION)
183          return EXCEPTION_EXECUTE_HANDLER;
184      return EXCEPTION_CONTINUE_SEARCH;
185  }
186  bool isInList(const TCHAR *token, const TCHAR *list)
187  {
188  	if ((!token) || (!list))
189  		return false;
190  	const size_t wordLen = 64;
191  	size_t listLen = lstrlen(list);
192  	TCHAR word[wordLen] = { '\0' };
193  	size_t i = 0;
194  	size_t j = 0;
195  	for (; i <= listLen; ++i)
196  	{
197  		if ((list[i] == ' ')||(list[i] == '\0'))
198  		{
199  			if (j != 0)
200  			{
201  				word[j] = '\0';
202  				j = 0;
203  				if (!wcsicmp(token, word))
204  					return true;
205  			}
206  		}
207  		else
208  		{
209  			word[j] = list[i];
210  			++j;
211  			if (j >= wordLen)
212  				return false;
213  		}
214  	}
215  	return false;
216  }
217  generic_string purgeMenuItemString(const TCHAR * menuItemStr, bool keepAmpersand)
218  {
219  	const size_t cleanedNameLen = 64;
220  	TCHAR cleanedName[cleanedNameLen] = TEXT("");
221  	size_t j = 0;
222  	size_t menuNameLen = lstrlen(menuItemStr);
223  	if (menuNameLen >= cleanedNameLen)
224  		menuNameLen = cleanedNameLen - 1;
225  	for (size_t k = 0 ; k < menuNameLen ; ++k)
226  	{
227  		if (menuItemStr[k] == '\t')
228  		{
229  			cleanedName[k] = 0;
230  			break;
231  		}
232  		else
233  		{
234  			if (menuItemStr[k] == '&')
235  			{
236  				if (keepAmpersand)
237  					cleanedName[j++] = menuItemStr[k];
238  			}
239  			else
240  				cleanedName[j++] = menuItemStr[k];
241  		}
242  	}
243  	cleanedName[j] = 0;
244  	return cleanedName;
245  }
246  const wchar_t * WcharMbcsConvertor::char2wchar(const char * mbcs2Convert, size_t codepage, int lenMbcs, int* pLenWc, int* pBytesNotProcessed)
247  {
248  	if (!mbcs2Convert)
249  		return nullptr;
250  	if (lenMbcs == 0 || (lenMbcs == -1 && mbcs2Convert[0] == 0))
251  	{
252  		_wideCharStr.empty();
253  		return _wideCharStr;
254  	}
255  	UINT cp = static_cast<UINT>(codepage);
256  	int bytesNotProcessed = 0;
257  	int lenWc = 0;
258  	if (lenMbcs == -1)
259  	{
260  		lenWc = MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs, NULL, 0);
261  	}
262  	else if (lenMbcs != -1 && cp == CP_UTF8) 
263  	{
264  		int indexOfLastChar = Utf8::characterStart(mbcs2Convert, lenMbcs-1); 
265  		if (indexOfLastChar != 0 && !Utf8::isValid(mbcs2Convert+indexOfLastChar, lenMbcs-indexOfLastChar)) 
266  		{
267  			bytesNotProcessed = lenMbcs-indexOfLastChar;
268  		}
269  		lenWc = MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs-bytesNotProcessed, NULL, 0);
270  	}
271  	else 
272  	{
273  		lenWc = MultiByteToWideChar(cp, (lenMbcs == -1) ? 0 : MB_ERR_INVALID_CHARS, mbcs2Convert, lenMbcs, NULL, 0);
274  		if (lenWc == 0 && GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
275  		{
276  			if (lenMbcs > 1) lenWc = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, mbcs2Convert, lenMbcs-1, NULL, 0);
277  			if (lenWc == 0) 
278  			{
279  				lenWc = MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs, NULL, 0);
280  			}
281  			else
282  			{
283  				bytesNotProcessed = 1;
284  			}
285  		}
286  	}
287  	if (lenWc > 0)
288  	{
289  		_wideCharStr.sizeTo(lenWc);
290  		MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs-bytesNotProcessed, _wideCharStr, lenWc);
291  	}
292  	else
293  		_wideCharStr.empty();
294  	if (pLenWc)
295  		*pLenWc = lenWc;
296  	if (pBytesNotProcessed)
297  		*pBytesNotProcessed = bytesNotProcessed;
298  	return _wideCharStr;
299  }
300  const wchar_t * WcharMbcsConvertor::char2wchar(const char * mbcs2Convert, size_t codepage, intptr_t* mstart, intptr_t* mend)
301  {
302  	if (!mbcs2Convert) return NULL;
303  	UINT cp = static_cast<UINT>(codepage);
304  	int len = MultiByteToWideChar(cp, 0, mbcs2Convert, -1, NULL, 0);
305  	if (len > 0)
306  	{
307  		_wideCharStr.sizeTo(len);
308  		len = MultiByteToWideChar(cp, 0, mbcs2Convert, -1, _wideCharStr, len);
309  		if ((size_t)*mstart < strlen(mbcs2Convert) && (size_t)*mend <= strlen(mbcs2Convert))
310  		{
311  			*mstart = MultiByteToWideChar(cp, 0, mbcs2Convert, static_cast<int>(*mstart), _wideCharStr, 0);
312  			*mend   = MultiByteToWideChar(cp, 0, mbcs2Convert, static_cast<int>(*mend), _wideCharStr, 0);
313  			if (*mstart >= len || *mend >= len)
314  			{
315  				*mstart = 0;
316  				*mend = 0;
317  			}
318  		}
319  	}
320  	else
321  	{
322  		_wideCharStr.empty();
323  		*mstart = 0;
324  		*mend = 0;
325  	}
326  	return _wideCharStr;
327  }
328  const char* WcharMbcsConvertor::wchar2char(const wchar_t * wcharStr2Convert, size_t codepage, int lenWc, int* pLenMbcs)
329  {
330  	if (!wcharStr2Convert)
331  		return nullptr;
332  	UINT cp = static_cast<UINT>(codepage);
333  	int lenMbcs = WideCharToMultiByte(cp, 0, wcharStr2Convert, lenWc, NULL, 0, NULL, NULL);
334  	if (lenMbcs > 0)
335  	{
336  		_multiByteStr.sizeTo(lenMbcs);
337  		WideCharToMultiByte(cp, 0, wcharStr2Convert, lenWc, _multiByteStr, lenMbcs, NULL, NULL);
338  	}
339  	else
340  		_multiByteStr.empty();
341  	if (pLenMbcs)
342  		*pLenMbcs = lenMbcs;
343  	return _multiByteStr;
344  }
345  const char * WcharMbcsConvertor::wchar2char(const wchar_t * wcharStr2Convert, size_t codepage, intptr_t* mstart, intptr_t* mend)
346  {
347  	if (!wcharStr2Convert)
348  		return nullptr;
349  	UINT cp = static_cast<UINT>(codepage);
350  	int len = WideCharToMultiByte(cp, 0, wcharStr2Convert, -1, NULL, 0, NULL, NULL);
351  	if (len > 0)
352  	{
353  		_multiByteStr.sizeTo(len);
354  		len = WideCharToMultiByte(cp, 0, wcharStr2Convert, -1, _multiByteStr, len, NULL, NULL); 
355          if (*mstart < lstrlenW(wcharStr2Convert) && *mend < lstrlenW(wcharStr2Convert))
356          {
357  			*mstart = WideCharToMultiByte(cp, 0, wcharStr2Convert, (int)*mstart, NULL, 0, NULL, NULL);
358  			*mend = WideCharToMultiByte(cp, 0, wcharStr2Convert, (int)*mend, NULL, 0, NULL, NULL);
359  			if (*mstart >= len || *mend >= len)
360  			{
361  				*mstart = 0;
362  				*mend = 0;
363  			}
364  		}
365  	}
366  	else
367  		_multiByteStr.empty();
368  	return _multiByteStr;
369  }
370  std::wstring string2wstring(const std::string & rString, UINT codepage)
371  {
372  	int len = MultiByteToWideChar(codepage, 0, rString.c_str(), -1, NULL, 0);
373  	if (len > 0)
374  	{
375  		std::vector<wchar_t> vw(len);
376  		MultiByteToWideChar(codepage, 0, rString.c_str(), -1, &vw[0], len);
377  		return &vw[0];
378  	}
379  	return std::wstring();
380  }
381  std::string wstring2string(const std::wstring & rwString, UINT codepage)
382  {
383  	int len = WideCharToMultiByte(codepage, 0, rwString.c_str(), -1, NULL, 0, NULL, NULL);
384  	if (len > 0)
385  	{
386  		std::vector<char> vw(len);
387  		WideCharToMultiByte(codepage, 0, rwString.c_str(), -1, &vw[0], len, NULL, NULL);
388  		return &vw[0];
389  	}
390  	return std::string();
391  }
392  template <typename T>
393  generic_string convertFileName(T beg, T end)
394  {
395  	generic_string strTmp;
396  	for (T it = beg; it != end; ++it)
397  	{
398  		if (*it == '&') strTmp.push_back('&');
399  		strTmp.push_back(*it);
400  	}
401  	return strTmp;
402  }
403  generic_string intToString(int val)
404  {
405  	std::vector<TCHAR> vt;
406  	bool isNegative = val < 0;
407  	vt.push_back('0' + static_cast<TCHAR>(std::abs(val % 10)));
408  	val /= 10;
409  	while (val != 0)
410  	{
411  		vt.push_back('0' + static_cast<TCHAR>(std::abs(val % 10)));
412  		val /= 10;
413  	}
414  	if (isNegative)
415  		vt.push_back('-');
416  	return generic_string(vt.rbegin(), vt.rend());
417  }
418  generic_string uintToString(unsigned int val)
419  {
420  	std::vector<TCHAR> vt;
421  	vt.push_back('0' + static_cast<TCHAR>(val % 10));
422  	val /= 10;
423  	while (val != 0)
424  	{
425  		vt.push_back('0' + static_cast<TCHAR>(val % 10));
426  		val /= 10;
427  	}
428  	return generic_string(vt.rbegin(), vt.rend());
429  }
430  generic_string BuildMenuFileName(int filenameLen, unsigned int pos, const generic_string &filename, bool ordinalNumber)
431  {
432  	generic_string strTemp;
433  	if (ordinalNumber)
434  	{
435  		if (pos < 9)
436  		{
437  			strTemp.push_back('&');
438  			strTemp.push_back('1' + static_cast<TCHAR>(pos));
439  		}
440  		else if (pos == 9)
441  		{
442  			strTemp.append(TEXT("1&0"));
443  		}
444  		else
445  		{
446  			div_t splitDigits = div(pos + 1, 10);
447  			strTemp.append(uintToString(splitDigits.quot));
448  			strTemp.push_back('&');
449  			strTemp.append(uintToString(splitDigits.rem));
450  		}
451  		strTemp.append(TEXT(": "));
452  	}
453  	else
454  	{
455  		strTemp.push_back('&');
456  	}
457  	if (filenameLen > 0)
458  	{
459  		std::vector<TCHAR> vt(filenameLen + 1);
460  		PathCompactPathEx(&vt[0], filename.c_str(), filenameLen + 1, 0);
461  		strTemp.append(convertFileName(vt.begin(), vt.begin() + lstrlen(&vt[0])));
462  	}
463  	else
464  	{
465  		generic_string::const_iterator it = filename.begin();
466  		if (filenameLen == 0)
467  			it += PathFindFileName(filename.c_str()) - filename.c_str();
468  		if (filename.end() - it < MAX_PATH)
469  		{
470  			strTemp.append(convertFileName(it, filename.end()));
471  		}
472  		else
473  		{
474  			strTemp.append(convertFileName(it, it + MAX_PATH / 2 - 3));
475  			strTemp.append(TEXT("..."));
476  			strTemp.append(convertFileName(filename.end() - MAX_PATH / 2, filename.end()));
477  		}
478  	}
479  	return strTemp;
480  }
481  generic_string PathRemoveFileSpec(generic_string& path)
482  {
483      generic_string::size_type lastBackslash = path.find_last_of(TEXT('\\'));
484      if (lastBackslash == generic_string::npos)
485      {
486          if (path.size() >= 2 && path[1] == TEXT(':'))  
487              path.erase(2);
488          else
489              path.erase();
490      }
491      else
492      {
493          if (lastBackslash == 2 && path[1] == TEXT(':') && path.size() >= 3)  
494              path.erase(3);
495          else if (lastBackslash == 0 && path.size() > 1) 
496              path.erase(1);
497          else
498              path.erase(lastBackslash);
499      }
500  	return path;
501  }
502  generic_string pathAppend(generic_string& strDest, const generic_string& str2append)
503  {
504  	if (strDest.empty() && str2append.empty()) 
505  	{
506  		strDest = TEXT("\\");
507  		return strDest;
508  	}
509  	if (strDest.empty() && !str2append.empty()) 
510  	{
511  		strDest = str2append;
512  		return strDest;
513  	}
514  	if (strDest[strDest.length() - 1] == '\\' && (!str2append.empty() && str2append[0] == '\\')) 
515  	{
516  		strDest.erase(strDest.length() - 1, 1);
517  		strDest += str2append;
518  		return strDest;
519  	}
520  	if ((strDest[strDest.length() - 1] == '\\' && (!str2append.empty() && str2append[0] != '\\')) 
521  		|| (strDest[strDest.length() - 1] != '\\' && (!str2append.empty() && str2append[0] == '\\'))) 
522  	{
523  		strDest += str2append;
524  		return strDest;
525  	}
526  	strDest += TEXT("\\");
527  	strDest += str2append;
528  	return strDest;
529  }
530  COLORREF getCtrlBgColor(HWND hWnd)
531  {
532  	COLORREF crRet = CLR_INVALID;
533  	if (hWnd && IsWindow(hWnd))
534  	{
535  		RECT rc;
536  		if (GetClientRect(hWnd, &rc))
537  		{
538  			HDC hDC = GetDC(hWnd);
539  			if (hDC)
540  			{
541  				HDC hdcMem = CreateCompatibleDC(hDC);
542  				if (hdcMem)
543  				{
544  					HBITMAP hBmp = CreateCompatibleBitmap(hDC,
545  					rc.right, rc.bottom);
546  					if (hBmp)
547  					{
548  						HGDIOBJ hOld = SelectObject(hdcMem, hBmp);
549  						if (hOld)
550  						{
551  							if (SendMessage(hWnd, WM_ERASEBKGND, reinterpret_cast<WPARAM>(hdcMem), 0))
552  							{
553  								crRet = GetPixel(hdcMem, 2, 2); 
554  							}
555  							SelectObject(hdcMem, hOld);
556  						}
557  						DeleteObject(hBmp);
558  					}
559  					DeleteDC(hdcMem);
560  				}
561  				ReleaseDC(hWnd, hDC);
562  			}
563  		}
564  	}
565  	return crRet;
566  }
567  generic_string stringToUpper(generic_string strToConvert)
568  {
569      std::transform(strToConvert.begin(), strToConvert.end(), strToConvert.begin(), 
570          [](wchar_t ch){ return static_cast<wchar_t>(towupper(ch)); }
571      );
572      return strToConvert;
573  }
574  generic_string stringToLower(generic_string strToConvert)
575  {
576      std::transform(strToConvert.begin(), strToConvert.end(), strToConvert.begin(), ::towlower);
577      return strToConvert;
578  }
579  generic_string stringReplace(generic_string subject, const generic_string& search, const generic_string& replace)
580  {
581  	size_t pos = 0;
582  	while ((pos = subject.find(search, pos)) != std::string::npos)
583  	{
584  		subject.replace(pos, search.length(), replace);
585  		pos += replace.length();
586  	}
587  	return subject;
588  }
589  std::vector<generic_string> stringSplit(const generic_string& input, const generic_string& delimiter)
590  {
591  	size_t start = 0U;
592  	size_t end = input.find(delimiter);
593  	std::vector<generic_string> output;
594  	const size_t delimiterLength = delimiter.length();
595  	while (end != std::string::npos)
596  	{
597  		output.push_back(input.substr(start, end - start));
598  		start = end + delimiterLength;
599  		end = input.find(delimiter, start);
600  	}
601  	output.push_back(input.substr(start, end));
602  	return output;
603  }
604  bool str2numberVector(generic_string str2convert, std::vector<size_t>& numVect)
605  {
606  	numVect.clear();
607  	for (auto i : str2convert)
608  	{
609  		switch (i)
610  		{
611  		case ' ':
612  		case '0': case '1':	case '2': case '3':	case '4':
613  		case '5': case '6':	case '7': case '8':	case '9':
614  		{
615  		}
616  		break;
617  		default:
618  			return false;
619  		}
620  	}
621  	std::vector<generic_string> v = stringSplit(str2convert, TEXT(" "));
622  	for (const auto& i : v)
623  	{
624  		if (!i.empty() && i.length() < 5)
625  		{
626  			numVect.push_back(std::stoi(i));
627  		}
628  	}
629  	return true;
630  }
631  generic_string stringJoin(const std::vector<generic_string>& strings, const generic_string& separator)
632  {
633  	generic_string joined;
634  	size_t length = strings.size();
635  	for (size_t i = 0; i < length; ++i)
636  	{
637  		joined += strings.at(i);
638  		if (i != length - 1)
639  		{
640  			joined += separator;
641  		}
642  	}
643  	return joined;
644  }
645  generic_string stringTakeWhileAdmissable(const generic_string& input, const generic_string& admissable)
646  {
647  	size_t idx = input.find_first_not_of(admissable);
648  	if (idx == std::string::npos)
649  	{
650  		return input;
651  	}
652  	else
653  	{
654  		return input.substr(0, idx);
655  	}
656  }
657  double stodLocale(const generic_string& str, [[maybe_unused]] _locale_t loc, size_t* idx)
658  {
659  	const wchar_t* ptr = str.c_str();
660  	errno = 0;
661  	wchar_t* eptr;
662  #ifdef __MINGW32__
663  	double ans = ::wcstod(ptr, &eptr);
664  #else
665  	double ans = ::_wcstod_l(ptr, &eptr, loc);
666  #endif
667  	if (ptr == eptr)
668  		throw std::invalid_argument("invalid stod argument");
669  	if (errno == ERANGE)
670  		throw std::out_of_range("stod argument out of range");
671  	if (idx != NULL)
672  		*idx = (size_t)(eptr - ptr);
673  	return ans;
674  }
675  static TCHAR ToUpperInvariant(TCHAR input)
676  {
677  	TCHAR result;
678  	LONG lres = LCMapString(LOCALE_INVARIANT, LCMAP_UPPERCASE, &input, 1, &result, 1);
679  	if (lres == 0)
680  	{
681  		assert(false and "LCMapString failed to convert a character to upper case");
682  		result = input;
683  	}
684  	return result;
685  }
686  int OrdinalIgnoreCaseCompareStrings(LPCTSTR sz1, LPCTSTR sz2)
687  {
688  	if (sz1 == sz2)
689  	{
690  		return 0;
691  	}
692  	if (sz1 == nullptr) sz1 = _T("");
693  	if (sz2 == nullptr) sz2 = _T("");
694  	for (;; sz1++, sz2++)
695  	{
696  		const TCHAR c1 = *sz1;
697  		const TCHAR c2 = *sz2;
698  		if (c1 == c2)
699  		{
700  			if (c1 == 0)
701  			{
702  				return 0; 
703  			}
704  		}
705  		else
706  		{
707  			if (c1 == 0 || c2 == 0)
708  			{
709  				return (c1-c2); 
710  			}
711  			const TCHAR u1 = ToUpperInvariant(c1);
712  			const TCHAR u2 = ToUpperInvariant(c2);
713  			if (u1 != u2)
714  			{
715  				return (u1-u2); 
716  			}
717  		}
718  	}
719  }
720  bool str2Clipboard(const generic_string &str2cpy, HWND hwnd)
721  {
722  	size_t len2Allocate = (str2cpy.size() + 1) * sizeof(TCHAR);
723  	HGLOBAL hglbCopy = ::GlobalAlloc(GMEM_MOVEABLE, len2Allocate);
724  	if (hglbCopy == NULL)
725  	{
726  		return false;
727  	}
728  	if (!::OpenClipboard(hwnd))
729  	{
730  		::GlobalFree(hglbCopy);
731  		::CloseClipboard();
732  		return false;
733  	}
734  	if (!::EmptyClipboard())
735  	{
736  		::GlobalFree(hglbCopy);
737  		::CloseClipboard();
738  		return false;
739  	}
740  	TCHAR *pStr = (TCHAR *)::GlobalLock(hglbCopy);
741  	if (pStr == NULL)
742  	{
743  		::GlobalUnlock(hglbCopy);
744  		::GlobalFree(hglbCopy);
745  		::CloseClipboard();
746  		return false;
747  	}
748  	wcscpy_s(pStr, len2Allocate / sizeof(TCHAR), str2cpy.c_str());
749  	::GlobalUnlock(hglbCopy);
750  	unsigned int clipBoardFormat = CF_UNICODETEXT;
751  	if (::SetClipboardData(clipBoardFormat, hglbCopy) == NULL)
752  	{
753  		::GlobalFree(hglbCopy);
754  		::CloseClipboard();
755  		return false;
756  	}
757  	if (!::CloseClipboard())
758  	{
759  		return false;
760  	}
761  	return true;
762  }
763  bool buf2Clipborad(const std::vector<Buffer*>& buffers, bool isFullPath, HWND hwnd)
764  {
765  	const generic_string crlf = _T("\r\n");
766  	generic_string selection;
767  	for (auto&& buf : buffers)
768  	{
769  		if (buf)
770  		{
771  			const TCHAR* fileName = isFullPath ? buf->getFullPathName() : buf->getFileName();
772  			if (fileName)
773  				selection += fileName;
774  		}
775  		if (!selection.empty() && !selection.ends_with(crlf))
776  			selection += crlf;
777  	}
778  	if (!selection.empty())
779  		return str2Clipboard(selection, hwnd);
780  	return false;
781  }
782  bool matchInList(const TCHAR *fileName, const std::vector<generic_string> & patterns)
783  {
784  	bool is_matched = false;
785  	for (size_t i = 0, len = patterns.size(); i < len; ++i)
786  	{
787  		if (patterns[i].length() > 1 && patterns[i][0] == '!')
788  		{
789  			if (PathMatchSpec(fileName, patterns[i].c_str() + 1))
790  				return false;
791  			continue;
792  		} 
793  		if (PathMatchSpec(fileName, patterns[i].c_str()))
794  			is_matched = true;
795  	}
796  	return is_matched;
797  }
798  bool matchInExcludeDirList(const TCHAR* dirName, const std::vector<generic_string>& patterns, size_t level)
799  {
800  	for (size_t i = 0, len = patterns.size(); i < len; ++i)
801  	{
802  		size_t patterLen = patterns[i].length();
803  		if (patterLen > 3 && patterns[i][0] == '!' && patterns[i][1] == '+' && patterns[i][2] == '\\') 
804  		{
805  			if (PathMatchSpec(dirName, patterns[i].c_str() + 3))
806  				return true;
807  		}
808  		else if (patterLen > 2 && patterns[i][0] == '!' && patterns[i][1] == '\\') 
809  		{
810  			if (level == 1)
811  				if (PathMatchSpec(dirName, patterns[i].c_str() + 2))
812  					return true;
813  		}
814  	}
815  	return false;
816  }
817  bool allPatternsAreExclusion(const std::vector<generic_string> patterns)
818  {
819  	bool oneInclusionPatternFound = false;
820  	for (size_t i = 0, len = patterns.size(); i < len; ++i)
821  	{
822  		if (patterns[i][0] != '!')
823  		{
824  			oneInclusionPatternFound = true;
825  			break;
826  		}
827  	}
828  	return !oneInclusionPatternFound;
829  }
830  generic_string GetLastErrorAsString(DWORD errorCode)
831  {
832  	generic_string errorMsg(_T(""));
833  	if (errorCode == 0)
834  		errorCode = GetLastError();
835  	if (errorCode == 0)
836  		return errorMsg; 
837  	LPWSTR messageBuffer = nullptr;
838  	FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
839  		nullptr, errorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&messageBuffer, 0, nullptr);
840  	errorMsg += messageBuffer;
841  	LocalFree(messageBuffer);
842  	return errorMsg;
843  }
844  HWND CreateToolTip(int toolID, HWND hDlg, HINSTANCE hInst, const PTSTR pszText, bool isRTL)
845  {
846  	if (!toolID || !hDlg || !pszText)
847  	{
848  		return NULL;
849  	}
850  	HWND hwndTool = GetDlgItem(hDlg, toolID);
851  	if (!hwndTool)
852  	{
853  		return NULL;
854  	}
855  	HWND hwndTip = CreateWindowEx(isRTL ? WS_EX_LAYOUTRTL : 0, TOOLTIPS_CLASS, NULL,
856  		WS_POPUP | TTS_ALWAYSTIP | TTS_BALLOON,
857  		CW_USEDEFAULT, CW_USEDEFAULT,
858  		CW_USEDEFAULT, CW_USEDEFAULT,
859  		hDlg, NULL,
860  		hInst, NULL);
861  	if (!hwndTip)
862  	{
863  		return NULL;
864  	}
865  	NppDarkMode::setDarkTooltips(hwndTip, NppDarkMode::ToolTipsType::tooltip);
866  	TOOLINFO toolInfo = {};
867  	toolInfo.cbSize = sizeof(toolInfo);
868  	toolInfo.hwnd = hDlg;
869  	toolInfo.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
870  	toolInfo.uId = (UINT_PTR)hwndTool;
871  	toolInfo.lpszText = pszText;
872  	if (!SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&toolInfo))
873  	{
874  		DestroyWindow(hwndTip);
875  		return NULL;
876  	}
877  	SendMessage(hwndTip, TTM_ACTIVATE, TRUE, 0);
878  	SendMessage(hwndTip, TTM_SETMAXTIPWIDTH, 0, 200);
879  	SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((15000), (0)));
880  	return hwndTip;
881  }
882  HWND CreateToolTipRect(int toolID, HWND hWnd, HINSTANCE hInst, const PTSTR pszText, const RECT rc)
883  {
884  	if (!toolID || !hWnd || !pszText)
885  	{
886  		return NULL;
887  	}
888  	HWND hwndTip = CreateWindowEx(0, TOOLTIPS_CLASS, NULL,
889  		WS_POPUP | TTS_ALWAYSTIP | TTS_BALLOON,
890  		CW_USEDEFAULT, CW_USEDEFAULT,
891  		CW_USEDEFAULT, CW_USEDEFAULT,
892  		hWnd, NULL,
893  		hInst, NULL);
894  	if (!hwndTip)
895  	{
896  		return NULL;
897  	}
898  	TOOLINFO toolInfo = {};
899  	toolInfo.cbSize = sizeof(toolInfo);
900  	toolInfo.hwnd = hWnd;
901  	toolInfo.uFlags = TTF_SUBCLASS;
902  	toolInfo.uId = toolID;
903  	toolInfo.lpszText = pszText;
904  	toolInfo.rect = rc;
905  	if (!SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&toolInfo))
906  	{
907  		DestroyWindow(hwndTip);
908  		return NULL;
909  	}
910  	SendMessage(hwndTip, TTM_ACTIVATE, TRUE, 0);
911  	SendMessage(hwndTip, TTM_SETMAXTIPWIDTH, 0, 200);
912  	SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((15000), (0)));
913  	return hwndTip;
914  }
915  bool isCertificateValidated(const generic_string & fullFilePath, const generic_string & subjectName2check)
916  {
917  	bool isOK = false;
918  	HCERTSTORE hStore = NULL;
919  	HCRYPTMSG hMsg = NULL;
920  	PCCERT_CONTEXT pCertContext = NULL;
921  	BOOL result = FALSE;
922  	DWORD dwEncoding = 0;
923  	DWORD dwContentType = 0;
924  	DWORD dwFormatType = 0;
925  	PCMSG_SIGNER_INFO pSignerInfo = NULL;
926  	DWORD dwSignerInfo = 0;
927  	CERT_INFO CertInfo{};
928  	LPTSTR szName = NULL;
929  	generic_string subjectName;
930  	try {
931  		result = CryptQueryObject(CERT_QUERY_OBJECT_FILE,
932  			fullFilePath.c_str(),
933  			CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
934  			CERT_QUERY_FORMAT_FLAG_BINARY,
935  			0,
936  			&dwEncoding,
937  			&dwContentType,
938  			&dwFormatType,
939  			&hStore,
940  			&hMsg,
941  			NULL);
942  		if (!result)
943  		{
944  			generic_string errorMessage = TEXT("Check certificate of ") + fullFilePath + TEXT(" : ");
945  			errorMessage += GetLastErrorAsString(GetLastError());
946  			throw errorMessage;
947  		}
948  		result = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &dwSignerInfo);
949  		if (!result)
950  		{
951  			generic_string errorMessage = TEXT("CryptMsgGetParam first call: ");
952  			errorMessage += GetLastErrorAsString(GetLastError());
953  			throw errorMessage;
954  		}
955  		pSignerInfo = (PCMSG_SIGNER_INFO)LocalAlloc(LPTR, dwSignerInfo);
956  		if (!pSignerInfo)
957  		{
958  			generic_string errorMessage = TEXT("CryptMsgGetParam memory allocation problem: ");
959  			errorMessage += GetLastErrorAsString(GetLastError());
960  			throw errorMessage;
961  		}
962  		result = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pSignerInfo, &dwSignerInfo);
963  		if (!result)
964  		{
965  			generic_string errorMessage = TEXT("CryptMsgGetParam: ");
966  			errorMessage += GetLastErrorAsString(GetLastError());
967  			throw errorMessage;
968  		}
969  		CertInfo.Issuer = pSignerInfo->Issuer;
970  		CertInfo.SerialNumber = pSignerInfo->SerialNumber;
971  		pCertContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_CERT, (PVOID)&CertInfo, NULL);
972  		if (!pCertContext)
973  		{
974  			generic_string errorMessage = TEXT("Certificate context: ");
975  			errorMessage += GetLastErrorAsString(GetLastError());
976  			throw errorMessage;
977  		}
978  		DWORD dwData;
979  		dwData = CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);
980  		if (dwData <= 1)
981  		{
982  			throw generic_string(TEXT("Certificate checking error: getting data size problem."));
983  		}
984  		szName = (LPTSTR)LocalAlloc(LPTR, dwData * sizeof(TCHAR));
985  		if (!szName)
986  		{
987  			throw generic_string(TEXT("Certificate checking error: memory allocation problem."));
988  		}
989  		if (CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, szName, dwData) <= 1)
990  		{
991  			throw generic_string(TEXT("Cannot get certificate info."));
992  		}
993  		subjectName = szName;
994  		if (subjectName != subjectName2check)
995  		{
996  			throw generic_string(TEXT("Certificate checking error: the certificate is not matched."));
997  		}
998  		isOK = true;
999  	}
1000  	catch (const generic_string& s)
1001  	{
1002  		MessageBox(NULL, s.c_str(), TEXT("Certificate checking"), MB_OK);
1003  	}
1004  	catch (...)
1005  	{
1006  		generic_string errorMessage = TEXT("Unknown exception occured. ");
1007  		errorMessage += GetLastErrorAsString(GetLastError());
1008  		MessageBox(NULL, errorMessage.c_str(), TEXT("Certificate checking"), MB_OK);
1009  	}
1010  	if (pSignerInfo != NULL) LocalFree(pSignerInfo);
1011  	if (pCertContext != NULL) CertFreeCertificateContext(pCertContext);
1012  	if (hStore != NULL) CertCloseStore(hStore, 0);
1013  	if (hMsg != NULL) CryptMsgClose(hMsg);
1014  	if (szName != NULL) LocalFree(szName);
1015  	return isOK;
1016  }
1017  bool isAssoCommandExisting(LPCTSTR FullPathName)
1018  {
1019  	bool isAssoCommandExisting = false;
1020  	bool isFileExisting = PathFileExists(FullPathName) != FALSE;
1021  	if (isFileExisting)
1022  	{
1023  		PTSTR ext = PathFindExtension(FullPathName);
1024  		HRESULT hres;
1025  		wchar_t buffer[MAX_PATH] = TEXT("");
1026  		DWORD bufferLen = MAX_PATH;
1027  		hres = AssocQueryString(ASSOCF_VERIFY|ASSOCF_INIT_IGNOREUNKNOWN, ASSOCSTR_COMMAND, ext, NULL, buffer, &bufferLen);
1028          isAssoCommandExisting = (hres == S_OK)                  
1029  			&& (wcsstr(buffer, TEXT("notepad++.exe")) == NULL); 
1030  	}
1031  	return isAssoCommandExisting;
1032  }
1033  std::wstring s2ws(const std::string& str)
1034  {
1035  	using convert_typeX = std::codecvt_utf8<wchar_t>;
1036  	std::wstring_convert<convert_typeX, wchar_t> converterX("Error in Notepad++ string conversion s2ws!", L"Error in Notepad++ string conversion s2ws!");
1037  	return converterX.from_bytes(str);
1038  }
1039  std::string ws2s(const std::wstring& wstr)
1040  {
1041  	using convert_typeX = std::codecvt_utf8<wchar_t>;
1042  	std::wstring_convert<convert_typeX, wchar_t> converterX("Error in Notepad++ string conversion ws2s!", L"Error in Notepad++ string conversion ws2s!");
1043  	return converterX.to_bytes(wstr);
1044  }
1045  bool deleteFileOrFolder(const generic_string& f2delete)
1046  {
1047  	auto len = f2delete.length();
1048  	TCHAR* actionFolder = new TCHAR[len + 2];
1049  	wcscpy_s(actionFolder, len + 2, f2delete.c_str());
1050  	actionFolder[len] = 0;
1051  	actionFolder[len + 1] = 0;
1052  	SHFILEOPSTRUCT fileOpStruct = {};
1053  	fileOpStruct.hwnd = NULL;
1054  	fileOpStruct.pFrom = actionFolder;
1055  	fileOpStruct.pTo = NULL;
1056  	fileOpStruct.wFunc = FO_DELETE;
1057  	fileOpStruct.fFlags = FOF_NOCONFIRMATION | FOF_SILENT | FOF_ALLOWUNDO;
1058  	fileOpStruct.fAnyOperationsAborted = false;
1059  	fileOpStruct.hNameMappings = NULL;
1060  	fileOpStruct.lpszProgressTitle = NULL;
1061  	int res = SHFileOperation(&fileOpStruct);
1062  	delete[] actionFolder;
1063  	return (res == 0);
1064  }
1065  void getFilesInFolder(std::vector<generic_string>& files, const generic_string& extTypeFilter, const generic_string& inFolder)
1066  {
1067  	generic_string filter = inFolder;
1068  	pathAppend(filter, extTypeFilter);
1069  	WIN32_FIND_DATA foundData;
1070  	HANDLE hFindFile = ::FindFirstFile(filter.c_str(), &foundData);
1071  	if (hFindFile != INVALID_HANDLE_VALUE && !(foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
1072  	{
1073  		generic_string foundFullPath = inFolder;
1074  		pathAppend(foundFullPath, foundData.cFileName);
1075  		files.push_back(foundFullPath);
1076  		while (::FindNextFile(hFindFile, &foundData))
1077  		{
1078  			generic_string foundFullPath2 = inFolder;
1079  			pathAppend(foundFullPath2, foundData.cFileName);
1080  			files.push_back(foundFullPath2);
1081  		}
1082  	}
1083  	::FindClose(hFindFile);
1084  }
1085  void trim(generic_string& str)
1086  {
1087  	generic_string::size_type pos = str.find_last_not_of(' ');
1088  	if (pos != generic_string::npos)
1089  	{
1090  		str.erase(pos + 1);
1091  		pos = str.find_first_not_of(' ');
1092  		if (pos != generic_string::npos) str.erase(0, pos);
1093  	}
1094  	else str.erase(str.begin(), str.end());
1095  }
1096  int nbDigitsFromNbLines(size_t nbLines)
1097  {
1098  	int nbDigits = 0; 
1099  	if (nbLines < 10) nbDigits = 1;
1100  	else if (nbLines < 100) nbDigits = 2;
1101  	else if (nbLines < 1000) nbDigits = 3;
1102  	else if (nbLines < 10000) nbDigits = 4;
1103  	else if (nbLines < 100000) nbDigits = 5;
1104  	else if (nbLines < 1000000) nbDigits = 6;
1105  	else 
1106  	{
1107  		nbDigits = 7;
1108  		nbLines /= 10000000;
1109  		while (nbLines)
1110  		{
1111  			nbLines /= 10;
1112  			++nbDigits;
1113  		}
1114  	}
1115  	return nbDigits;
1116  }
1117  namespace
1118  {
1119  	constexpr TCHAR timeFmtEscapeChar = 0x1;
1120  	constexpr TCHAR middayFormat[] = _T("tt");
1121  	generic_string getMiddayString(const TCHAR* localeName, const SYSTEMTIME& st)
1122  	{
1123  		generic_string midday;
1124  		midday.resize(MAX_PATH);
1125  		int ret = GetTimeFormatEx(localeName, 0, &st, middayFormat, &midday[0], static_cast<int>(midday.size()));
1126  		if (ret > 0)
1127  			midday.resize(ret - 1); 
1128  		else
1129  			midday.clear();
1130  		return midday;
1131  	}
1132  	bool escapeTimeFormat(generic_string& format)
1133  	{
1134  		bool modified = false;
1135  		for (auto& ch : format)
1136  		{
1137  			if (ch == middayFormat[0])
1138  			{
1139  				ch = timeFmtEscapeChar;
1140  				modified = true;
1141  			}
1142  		}
1143  		return modified;
1144  	}
1145  	void unescapeTimeFormat(generic_string& format, const generic_string& midday)
1146  	{
1147  		if (midday.empty())
1148  		{
1149  			auto it = std::remove(format.begin(), format.end(), timeFmtEscapeChar);
1150  			if (it != format.end())
1151  				format.erase(it, format.end());
1152  		}
1153  		else
1154  		{
1155  			size_t i = 0;
1156  			while ((i = format.find(timeFmtEscapeChar, i)) != generic_string::npos)
1157  			{
1158  				if (i + 1 < format.size() && format[i + 1] == timeFmtEscapeChar)
1159  				{
1160  					format.erase(i, std::size(middayFormat) - 1);
1161  					format.insert(i, midday);
1162  				}
1163  				else
1164  				{
1165  					format[i] = midday[0];
1166  				}
1167  			}
1168  		}
1169  	}
1170  }
1171  generic_string getDateTimeStrFrom(const generic_string& dateTimeFormat, const SYSTEMTIME& st)
1172  {
1173  	const TCHAR* localeName = LOCALE_NAME_USER_DEFAULT;
1174  	const DWORD flags = 0;
1175  	constexpr int bufferSize = MAX_PATH;
1176  	TCHAR buffer[bufferSize] = {};
1177  	int ret = 0;
1178  	generic_string newFormat = dateTimeFormat;
1179  	const bool hasMiddayFormat = escapeTimeFormat(newFormat);
1180  	ret = GetTimeFormatEx(localeName, flags, &st, newFormat.c_str(), buffer, bufferSize);
1181  	if (ret != 0)
1182  	{
1183  		ret = GetDateFormatEx(localeName, flags, &st, buffer, buffer, bufferSize, nullptr);
1184  	}
1185  	if (ret != 0)
1186  	{
1187  		if (hasMiddayFormat)
1188  		{
1189  			const generic_string midday = getMiddayString(localeName, st);
1190  			generic_string result = buffer;
1191  			unescapeTimeFormat(result, midday);
1192  			return result;
1193  		}
1194  		return buffer;
1195  	}
1196  	return {};
<span onclick='openModal()' class='match'>1197  }
1198  HFONT createFont(const TCHAR* fontName, int fontSize, bool isBold, HWND hDestParent)
1199  {
1200  	HDC hdc = GetDC(hDestParent);
1201  	LOGFONT logFont = {};
</span>1202  	logFont.lfHeight = -MulDiv(fontSize, GetDeviceCaps(hdc, LOGPIXELSY), 72);
1203  	if (isBold)
1204  		logFont.lfWeight = FW_BOLD;
1205  	wcscpy_s(logFont.lfFaceName, fontName);
1206  	HFONT newFont = CreateFontIndirect(&logFont);
1207  	ReleaseDC(hDestParent, hdc);
1208  	return newFont;
1209  }
1210  bool isWin32NamespacePrefixedFileName(const generic_string& fileName)
1211  {
1212  	return (fileName.starts_with(TEXT("\\\\?\\")) || fileName.starts_with(TEXT("&bsol;&bsol;?/")));
1213  }
1214  bool isWin32NamespacePrefixedFileName(const TCHAR* szFileName)
1215  {
1216  	const generic_string fileName = szFileName;
1217  	return isWin32NamespacePrefixedFileName(fileName);
1218  }
1219  bool isUnsupportedFileName(const generic_string& fileName)
1220  {
1221  	bool isUnsupported = true;
1222  	if ((fileName.size() > 0) && (fileName.size() < MAX_PATH))
1223  	{
1224  		if (!fileName.ends_with(_T('.')) && !fileName.ends_with(_T(' ')))
1225  		{
1226  			bool invalidASCIIChar = false;
1227  			for (size_t pos = 0; pos < fileName.size(); ++pos)
1228  			{
1229  				TCHAR c = fileName.at(pos);
1230  				if (c <= 31)
1231  				{
1232  					invalidASCIIChar = true;
1233  				}
1234  				else
1235  				{
1236  					switch (c)
1237  					{
1238  						case '<':
1239  						case '>':
1240  						case '"':
1241  						case '|':
1242  							invalidASCIIChar = true;
1243  							break;
1244  					}
1245  				}
1246  				if (invalidASCIIChar)
1247  					break;
1248  			}
1249  			if (!invalidASCIIChar)
1250  			{
1251  				generic_string fileNameOnly;
1252  				size_t pos = fileName.find_first_of(TEXT("."));
1253  				if (pos != std::string::npos)
1254  					fileNameOnly = fileName.substr(0, pos);
1255  				else
1256  					fileNameOnly = fileName;
1257  				pos = fileNameOnly.find_last_of(TEXT("\\"));
1258  				if (pos == std::string::npos)
1259  					pos = fileNameOnly.find_last_of(TEXT("/"));
1260  				if (pos != std::string::npos)
1261  					fileNameOnly = fileNameOnly.substr(pos + 1);
1262  				const std::vector<generic_string>  reservedWin32NamespaceDeviceList{
1263  				TEXT("CON"), TEXT("PRN"), TEXT("AUX"), TEXT("NUL"),
1264  				TEXT("COM1"), TEXT("COM2"), TEXT("COM3"), TEXT("COM4"), TEXT("COM5"), TEXT("COM6"), TEXT("COM7"), TEXT("COM8"), TEXT("COM9"),
1265  				TEXT("LPT1"), TEXT("LPT2"), TEXT("LPT3"), TEXT("LPT4"), TEXT("LPT5"), TEXT("LPT6"), TEXT("LPT7"), TEXT("LPT8"), TEXT("LPT9")
1266  				};
1267  				if (std::find(reservedWin32NamespaceDeviceList.begin(), reservedWin32NamespaceDeviceList.end(), fileNameOnly) == reservedWin32NamespaceDeviceList.end())
1268  				{
1269  					isUnsupported = false;
1270  				}
1271  			}
1272  		}
1273  	}
1274  	return isUnsupported;
1275  }
1276  bool isUnsupportedFileName(const TCHAR* szFileName)
1277  {
1278  	const generic_string fileName = szFileName;
1279  	return isUnsupportedFileName(fileName);
1280  }
1281  Version::Version(const generic_string& versionStr)
1282  {
1283  	try {
1284  		auto ss = tokenizeString(versionStr, '.');
1285  		if (ss.size() > 4)
1286  		{
1287  			std::wstring msg(L"\"");
1288  			msg += versionStr;
1289  			msg += L"\"";
1290  			msg += TEXT(": Version parts are more than 4. The string to parse is not a valid version format. Let's make it default value in catch block.");
1291  			throw msg;
1292  		}
1293  		int i = 0;
1294  		std::vector<unsigned long*> v = { &_major, &_minor, &_patch, &_build };
1295  		for (const auto& s : ss)
1296  		{
1297  			if (!isNumber(s))
1298  			{
1299  				std::wstring msg(L"\"");
1300  				msg += versionStr;
1301  				msg += L"\"";
1302  				msg += TEXT(": One of version character is not number. The string to parse is not a valid version format. Let's make it default value in catch block.");
1303  				throw msg;
1304  			}
1305  			*(v[i]) = std::stoi(s);
1306  			++i;
1307  		}
1308  	}
1309  #ifdef DEBUG
1310  	catch (const std::wstring& s)
1311  	{
1312  		_major = 0;
1313  		_minor = 0;
1314  		_patch = 0;
1315  		_build = 0;
1316  		throw s;
1317  	}
1318  #endif
1319  	catch (...)
1320  	{
1321  		_major = 0;
1322  		_minor = 0;
1323  		_patch = 0;
1324  		_build = 0;
1325  #ifdef DEBUG
1326  		throw std::wstring(TEXT("Unknown exception from \"Version::Version(const generic_string& versionStr)\""));
1327  #endif
1328  	}
1329  }
1330  void Version::setVersionFrom(const generic_string& filePath)
1331  {
1332  	if (!filePath.empty() && ::PathFileExists(filePath.c_str()))
1333  	{
1334  		DWORD uselessArg = 0; 
1335  		DWORD bufferSize = ::GetFileVersionInfoSize(filePath.c_str(), &uselessArg);
1336  		if (bufferSize <= 0)
1337  			return;
1338  		unsigned char* buffer = new unsigned char[bufferSize];
1339  		::GetFileVersionInfo(filePath.c_str(), 0, bufferSize, buffer);
1340  		VS_FIXEDFILEINFO* lpFileInfo = nullptr;
1341  		UINT cbFileInfo = 0;
1342  		VerQueryValue(buffer, TEXT("\\"), reinterpret_cast<LPVOID*>(&lpFileInfo), &cbFileInfo);
1343  		if (cbFileInfo)
1344  		{
1345  			_major = (lpFileInfo->dwFileVersionMS & 0xFFFF0000) >> 16;
1346  			_minor = lpFileInfo->dwFileVersionMS & 0x0000FFFF;
1347  			_patch = (lpFileInfo->dwFileVersionLS & 0xFFFF0000) >> 16;
1348  			_build = lpFileInfo->dwFileVersionLS & 0x0000FFFF;
1349  		}
1350  		delete[] buffer;
1351  	}
1352  }
1353  generic_string Version::toString()
1354  {
1355  	if (_build == 0 && _patch == 0 && _minor == 0 && _major == 0) 
1356  	{
1357  		return TEXT("");
1358  	}
1359  	else if (_build == 0 && _patch == 0 && _minor == 0) 
1360  	{
1361  		return std::to_wstring(_major);
1362  	}
1363  	else if (_build == 0 && _patch == 0) 
1364  	{
1365  		std::wstring v = std::to_wstring(_major);
1366  		v += TEXT(".");
1367  		v += std::to_wstring(_minor);
1368  		return v;
1369  	}
1370  	else if (_build == 0) 
1371  	{
1372  		std::wstring v = std::to_wstring(_major);
1373  		v += TEXT(".");
1374  		v += std::to_wstring(_minor);
1375  		v += TEXT(".");
1376  		v += std::to_wstring(_patch);
1377  		return v;
1378  	}
1379  	std::wstring ver = std::to_wstring(_major);
1380  	ver += TEXT(".");
1381  	ver += std::to_wstring(_minor);
1382  	ver += TEXT(".");
1383  	ver += std::to_wstring(_patch);
1384  	ver += TEXT(".");
1385  	ver += std::to_wstring(_build);
1386  	return ver;
1387  }
1388  int Version::compareTo(const Version& v2c) const
1389  {
1390  	if (_major > v2c._major)
1391  		return 1;
1392  	else if (_major < v2c._major)
1393  		return -1;
1394  	else 
1395  	{
1396  		if (_minor > v2c._minor)
1397  			return 1;
1398  		else if (_minor < v2c._minor)
1399  			return -1;
1400  		else 
1401  		{
1402  			if (_patch > v2c._patch)
1403  				return 1;
1404  			else if (_patch < v2c._patch)
1405  				return -1;
1406  			else 
1407  			{
1408  				if (_build > v2c._build)
1409  					return 1;
1410  				else if (_build < v2c._build)
1411  					return -1;
1412  				else 
1413  				{
1414  					return 0;
1415  				}
1416  			}
1417  		}
1418  	}
1419  }
1420  bool Version::isCompatibleTo(const Version& from, const Version& to) const
1421  {
1422  	if (empty()) 
1423  		return false;
1424  	if (from.empty() && to.empty()) 
1425  	{
1426  		return true;
1427  	}
1428  	if (from <= *this && to >= *this) 
1429  	{
1430  		return true;
1431  	}
1432  	if (from <= *this && to.empty()) 
1433  	{
1434  		return true;
1435  	}
1436  	return false;
1437  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-conv.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Common.cpp</div>
                </div>
                <div class="column column_space"><pre><code>7  }
8  int LoadMode(TModeNet& Graph, PTable Table, const TStr& NCol,
9    TStrV& NodeAttrV) {
10    const TAttrType NodeType = Table->GetColType(NCol);
11    const TInt NColIdx = Table->GetColIdx(NCol);
</pre></code></div>
                <div class="column column_space"><pre><code>1197  }
1198  HFONT createFont(const TCHAR* fontName, int fontSize, bool isBold, HWND hDestParent)
1199  {
1200  	HDC hdc = GetDC(hDestParent);
1201  	LOGFONT logFont = {};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    