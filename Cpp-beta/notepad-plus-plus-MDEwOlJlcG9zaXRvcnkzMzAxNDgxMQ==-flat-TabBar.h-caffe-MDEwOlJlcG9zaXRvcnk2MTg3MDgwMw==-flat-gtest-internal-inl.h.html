
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 24.078624078624077%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TabBar.h</h3>
            <pre><code>1  #pragma once
2  #ifndef _WIN32_IE
3  #define _WIN32_IE	0x0600
4  #endif 
5  #include "menuCmdID.h"
6  #include "resource.h"
7  #include <stdint.h>
8  #include <windows.h>
9  #include <commctrl.h>
10  #include "Window.h"
11  #define TCN_TABDROPPED (TCN_FIRST - 10)
12  #define TCN_TABDROPPEDOUTSIDE (TCN_FIRST - 11)
13  #define TCN_TABDELETE (TCN_FIRST - 12)
14  #define TCN_MOUSEHOVERING (TCN_FIRST - 13)
15  #define TCN_MOUSELEAVING (TCN_FIRST - 14)
16  #define TCN_MOUSEHOVERSWITCHING (TCN_FIRST - 15)
17  #define WM_TABSETSTYLE	(WM_APP + 0x024)
18  const int marge = 8;
19  const int nbCtrlMax = 10;
20  const TCHAR TABBAR_ACTIVEFOCUSEDINDCATOR[64] = TEXT("Active tab focused indicator");
21  const TCHAR TABBAR_ACTIVEUNFOCUSEDINDCATOR[64] = TEXT("Active tab unfocused indicator");
22  const TCHAR TABBAR_ACTIVETEXT[64] = TEXT("Active tab text");
23  const TCHAR TABBAR_INACTIVETEXT[64] = TEXT("Inactive tabs");
24  constexpr int g_TabIconSize = 16;
25  constexpr int g_TabHeight = 22;
26  constexpr int g_TabHeightLarge = 25;
27  constexpr int g_TabWidth = 45;
28  constexpr int g_TabWidthCloseBtn = 60;
29  constexpr int g_TabCloseBtnSize = 11;
30  struct TBHDR
31  {
32  	NMHDR _hdr{};
33  	int _tabOrigin = 0;
34  };
35  class TabBar : public Window
36  {
37  public:
38  	TabBar() = default;
39  	virtual ~TabBar() = default;
40  	void destroy() override;
41  	virtual void init(HINSTANCE hInst, HWND hwnd, bool isVertical = false, bool isMultiLine = false);
42  	void reSizeTo(RECT& rc2Ajust) override;
43  	int insertAtEnd(const TCHAR *subTabName);
44  	void activateAt(int index) const;
45  	void getCurrentTitle(TCHAR *title, int titleLen);
46  	int32_t getCurrentTabIndex() const {
47  		return static_cast<int32_t>(SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
48  	};
49  	int32_t getItemCount() const {
50  		return static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETITEMCOUNT, 0, 0));
51  	}
52  	void deletItemAt(size_t index);
53  	void deletAllItem() {
54  		::SendMessage(_hSelf, TCM_DELETEALLITEMS, 0, 0);
55  		_nbItem = 0;
56  	};
57  	void setImageList(HIMAGELIST himl);
58      size_t nbItem() const {
59          return _nbItem;
60      }
61  	void setFont(const TCHAR *fontName, int fontSize);
<span onclick='openModal()' class='match'>62  	void setVertical(bool b) {
63  		_isVertical = b;
64  	};
65  	void setMultiLine(bool b) {
66  		_isMultiLine = b;
67  	};
68  	HFONT& getFont(bool isReduced = true) {
</span>69  		return isReduced ? _hFont : _hLargeFont;
70  	}
71  protected:
72  	size_t _nbItem = 0;
73  	bool _hasImgLst = false;
74  	HFONT _hFont = nullptr;
75  	HFONT _hLargeFont = nullptr;
76  	HFONT _hVerticalFont = nullptr;
77  	HFONT _hVerticalLargeFont = nullptr;
78  	int _ctrlID = 0;
79  	bool _isVertical = false;
80  	bool _isMultiLine = false;
81  	long getRowCount() const {
82  		return long(::SendMessage(_hSelf, TCM_GETROWCOUNT, 0, 0));
83  	}
84  };
85  struct CloseButtonZone
86  {
87  	CloseButtonZone();
88  	bool isHit(int x, int y, const RECT & tabRect, bool isVertical) const;
89  	RECT getButtonRectFrom(const RECT & tabRect, bool isVertical) const;
90  	int _width = 0;
91  	int _height = 0;
92  };
93  class TabBarPlus : public TabBar
94  {
95  public :
96  	TabBarPlus() = default;
97  	enum tabColourIndex {
98  		activeText, activeFocusedTop, activeUnfocusedTop, inactiveText, inactiveBg
99  	};
100  	static void doDragNDrop(bool justDoIt) {
101          _doDragNDrop = justDoIt;
102      };
103  	void init(HINSTANCE hInst, HWND hwnd, bool isVertical = false, bool isMultiLine = false) override;
104  	void destroy() override;
105      static bool doDragNDropOrNot() {
106          return _doDragNDrop;
107      };
108  	int getSrcTabIndex() const {
109          return _nSrcTab;
110      };
111      int getTabDraggedIndex() const {
112          return _nTabDragged;
113      };
114  	POINT getDraggingPoint() const {
115  		return _draggingPoint;
116  	};
117  	void resetDraggingPoint() {
118  		_draggingPoint.x = 0;
119  		_draggingPoint.y = 0;
120  	};
121  	static void doOwnerDrawTab();
122  	static void doVertical();
123  	static void doMultiLine();
124  	static bool isOwnerDrawTab() {return true;};
125  	static bool drawTopBar() {return _drawTopBar;};
126  	static bool drawInactiveTab() {return _drawInactiveTab;};
127  	static bool drawTabCloseButton() {return _drawTabCloseButton;};
128  	static bool isDbClk2Close() {return _isDbClk2Close;};
129  	static bool isVertical() { return _isCtrlVertical;};
130  	static bool isMultiLine() { return _isCtrlMultiLine;};
131  	static void setDrawTopBar(bool b) {
132  		_drawTopBar = b;
133  		doOwnerDrawTab();
134  	}
135  	static void setDrawInactiveTab(bool b) {
136  		_drawInactiveTab = b;
137  		doOwnerDrawTab();
138  	}
139  	static void setDrawTabCloseButton(bool b) {
140  		_drawTabCloseButton = b;
141  		doOwnerDrawTab();
142  	}
143  	static void setDbClk2Close(bool b) {
144  		_isDbClk2Close = b;
145  	}
146  	static void setVertical(bool b) {
147  		_isCtrlVertical = b;
148  		doVertical();
149  	}
150  	static void setMultiLine(bool b) {
151  		_isCtrlMultiLine = b;
152  		doMultiLine();
153  	}
154  	static void setColour(COLORREF colour2Set, tabColourIndex i);
155  	virtual int getIndividualTabColour(int tabIndex) = 0;
156  protected:
157      static bool _doDragNDrop;
158  	bool _mightBeDragging = false;
159  	int _dragCount = 0;
160  	bool _isDragging = false;
161  	bool _isDraggingInside = false;
162      int _nSrcTab = -1;
163  	int _nTabDragged = -1;
164  	int _previousTabSwapped = -1;
165  	POINT _draggingPoint{}; 
166  	WNDPROC _tabBarDefaultProc = nullptr;
167  	RECT _currentHoverTabRect{};
168  	int _currentHoverTabItem = -1; 
169  	CloseButtonZone _closeButtonZone;
170  	bool _isCloseHover = false;
171  	int _whichCloseClickDown = -1;
172  	bool _lmbdHit = false; 
173  	HWND _tooltips = nullptr;
174  	LRESULT runProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
175  	static LRESULT CALLBACK TabBarPlus_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam) {
176  		return (((TabBarPlus *)(::GetWindowLongPtr(hwnd, GWLP_USERDATA)))->runProc(hwnd, Message, wParam, lParam));
177  	};
178  	void setActiveTab(int tabIndex);
179  	void exchangeTabItemData(int oldTab, int newTab);
180  	void exchangeItemData(POINT point);
181  	static bool _drawInactiveTab;
182  	static bool _drawTopBar;
183  	static bool _drawTabCloseButton;
184  	static bool _isDbClk2Close;
185  	static bool _isCtrlVertical;
186  	static bool _isCtrlMultiLine;
187  	static COLORREF _activeTextColour;
188  	static COLORREF _activeTopBarFocusedColour;
189  	static COLORREF _activeTopBarUnfocusedColour;
190  	static COLORREF _inactiveTextColour;
191  	static COLORREF _inactiveBgColour;
192  	static int _nbCtrl;
193  	static HWND _hwndArray[nbCtrlMax];
194  	void drawItem(DRAWITEMSTRUCT *pDrawItemStruct, bool isDarkMode = false);
195  	void draggingCursor(POINT screenPoint);
196  	int getTabIndexAt(const POINT & p)
197  	{
198  		return getTabIndexAt(p.x, p.y);
199  	}
200  	int32_t getTabIndexAt(int x, int y)
201  	{
202  		TCHITTESTINFO hitInfo{};
203  		hitInfo.pt.x = x;
204  		hitInfo.pt.y = y;
205  		return static_cast<int32_t>(::SendMessage(_hSelf, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&hitInfo)));
206  	}
207  	bool isPointInParentZone(POINT screenPoint) const
208  	{
209  		RECT parentZone{};
210          ::GetWindowRect(_hParent, &parentZone);
211  	    return (((screenPoint.x >= parentZone.left) && (screenPoint.x <= parentZone.right)) &&
212  			    (screenPoint.y >= parentZone.top) && (screenPoint.y <= parentZone.bottom));
213      }
214  	void notify(int notifyCode, int tabIndex);
215  	void trackMouseEvent(DWORD event2check);
216  };
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal-inl.h</h3>
            <pre><code>1  #ifndef GTEST_SRC_GTEST_INTERNAL_INL_H_
2  #define GTEST_SRC_GTEST_INTERNAL_INL_H_
3  #if !GTEST_IMPLEMENTATION_
4  # error "gtest-internal-inl.h is part of Google Test's internal implementation."
5  # error "It must not be included except by Google Test itself."
6  #endif  
7  #ifndef _WIN32_WCE
8  # include <errno.h>
9  #endif  
10  #include <stddef.h>
11  #include <stdlib.h>  
12  #include <string.h>  
13  #include <algorithm>
14  #include <string>
15  #include <vector>
16  #include "gtest/internal/gtest-port.h"
17  #if GTEST_CAN_STREAM_RESULTS_
18  # include <arpa/inet.h>  
19  # include <netdb.h>  
20  #endif
21  #if GTEST_OS_WINDOWS
22  # include <windows.h>  
23  #endif  
24  #include "gtest/gtest.h"  
25  #include "gtest/gtest-spi.h"
26  namespace testing {
27  GTEST_DECLARE_bool_(death_test_use_fork);
28  namespace internal {
29  GTEST_API_ extern const TypeId kTestTypeIdInGoogleTest;
30  const char kAlsoRunDisabledTestsFlag[] = "also_run_disabled_tests";
31  const char kBreakOnFailureFlag[] = "break_on_failure";
32  const char kCatchExceptionsFlag[] = "catch_exceptions";
33  const char kColorFlag[] = "color";
34  const char kFilterFlag[] = "filter";
35  const char kListTestsFlag[] = "list_tests";
36  const char kOutputFlag[] = "output";
37  const char kPrintTimeFlag[] = "print_time";
38  const char kRandomSeedFlag[] = "random_seed";
39  const char kRepeatFlag[] = "repeat";
40  const char kShuffleFlag[] = "shuffle";
41  const char kStackTraceDepthFlag[] = "stack_trace_depth";
42  const char kStreamResultToFlag[] = "stream_result_to";
43  const char kThrowOnFailureFlag[] = "throw_on_failure";
44  const int kMaxRandomSeed = 99999;
45  GTEST_API_ extern bool g_help_flag;
46  GTEST_API_ TimeInMillis GetTimeInMillis();
47  GTEST_API_ bool ShouldUseColor(bool stdout_is_tty);
48  GTEST_API_ std::string FormatTimeInMillisAsSeconds(TimeInMillis ms);
49  GTEST_API_ std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms);
50  GTEST_API_ bool ParseInt32Flag(
51      const char* str, const char* flag, Int32* value);
52  inline int GetRandomSeedFromFlag(Int32 random_seed_flag) {
53    const unsigned int raw_seed = (random_seed_flag == 0) ?
54        static_cast<unsigned int>(GetTimeInMillis()) :
55        static_cast<unsigned int>(random_seed_flag);
56    const int normalized_seed =
57        static_cast<int>((raw_seed - 1U) %
58                         static_cast<unsigned int>(kMaxRandomSeed)) + 1;
59    return normalized_seed;
60  }
61  inline int GetNextRandomSeed(int seed) {
62    GTEST_CHECK_(1 <= seed && seed <= kMaxRandomSeed)
63        << "Invalid random seed " << seed << " - must be in [1, "
64        << kMaxRandomSeed << "].";
65    const int next_seed = seed + 1;
66    return (next_seed > kMaxRandomSeed) ? 1 : next_seed;
67  }
68  class GTestFlagSaver {
69   public:
70    GTestFlagSaver() {
71      also_run_disabled_tests_ = GTEST_FLAG(also_run_disabled_tests);
72      break_on_failure_ = GTEST_FLAG(break_on_failure);
73      catch_exceptions_ = GTEST_FLAG(catch_exceptions);
74      color_ = GTEST_FLAG(color);
75      death_test_style_ = GTEST_FLAG(death_test_style);
76      death_test_use_fork_ = GTEST_FLAG(death_test_use_fork);
77      filter_ = GTEST_FLAG(filter);
78      internal_run_death_test_ = GTEST_FLAG(internal_run_death_test);
79      list_tests_ = GTEST_FLAG(list_tests);
80      output_ = GTEST_FLAG(output);
81      print_time_ = GTEST_FLAG(print_time);
82      random_seed_ = GTEST_FLAG(random_seed);
83      repeat_ = GTEST_FLAG(repeat);
84      shuffle_ = GTEST_FLAG(shuffle);
85      stack_trace_depth_ = GTEST_FLAG(stack_trace_depth);
86      stream_result_to_ = GTEST_FLAG(stream_result_to);
87      throw_on_failure_ = GTEST_FLAG(throw_on_failure);
88    }
89    ~GTestFlagSaver() {
90      GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;
91      GTEST_FLAG(break_on_failure) = break_on_failure_;
92      GTEST_FLAG(catch_exceptions) = catch_exceptions_;
93      GTEST_FLAG(color) = color_;
94      GTEST_FLAG(death_test_style) = death_test_style_;
95      GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;
96      GTEST_FLAG(filter) = filter_;
97      GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;
98      GTEST_FLAG(list_tests) = list_tests_;
99      GTEST_FLAG(output) = output_;
100      GTEST_FLAG(print_time) = print_time_;
101      GTEST_FLAG(random_seed) = random_seed_;
102      GTEST_FLAG(repeat) = repeat_;
103      GTEST_FLAG(shuffle) = shuffle_;
104      GTEST_FLAG(stack_trace_depth) = stack_trace_depth_;
105      GTEST_FLAG(stream_result_to) = stream_result_to_;
106      GTEST_FLAG(throw_on_failure) = throw_on_failure_;
107    }
108   private:
109    bool also_run_disabled_tests_;
110    bool break_on_failure_;
111    bool catch_exceptions_;
112    std::string color_;
113    std::string death_test_style_;
114    bool death_test_use_fork_;
115    std::string filter_;
116    std::string internal_run_death_test_;
117    bool list_tests_;
118    std::string output_;
119    bool print_time_;
120    internal::Int32 random_seed_;
121    internal::Int32 repeat_;
122    bool shuffle_;
123    internal::Int32 stack_trace_depth_;
124    std::string stream_result_to_;
125    bool throw_on_failure_;
126  } GTEST_ATTRIBUTE_UNUSED_;
127  GTEST_API_ std::string CodePointToUtf8(UInt32 code_point);
128  GTEST_API_ std::string WideStringToUtf8(const wchar_t* str, int num_chars);
129  void WriteToShardStatusFileIfNeeded();
130  GTEST_API_ bool ShouldShard(const char* total_shards_str,
131                              const char* shard_index_str,
132                              bool in_subprocess_for_death_test);
133  GTEST_API_ Int32 Int32FromEnvOrDie(const char* env_var, Int32 default_val);
134  GTEST_API_ bool ShouldRunTestOnShard(
135      int total_shards, int shard_index, int test_id);
136  template <class Container, typename Predicate>
137  inline int CountIf(const Container& c, Predicate predicate) {
138    int count = 0;
139    for (typename Container::const_iterator it = c.begin(); it != c.end(); ++it) {
140      if (predicate(*it))
141        ++count;
142    }
143    return count;
144  }
145  template <class Container, typename Functor>
146  void ForEach(const Container& c, Functor functor) {
147    std::for_each(c.begin(), c.end(), functor);
148  }
149  template <typename E>
150  inline E GetElementOr(const std::vector<E>& v, int i, E default_value) {
151    return (i < 0 || i >= static_cast<int>(v.size())) ? default_value : v[i];
152  }
153  template <typename E>
154  void ShuffleRange(internal::Random* random, int begin, int end,
155                    std::vector<E>* v) {
156    const int size = static_cast<int>(v->size());
157    GTEST_CHECK_(0 <= begin && begin <= size)
158        << "Invalid shuffle range start " << begin << ": must be in range [0, "
159        << size << "].";
160    GTEST_CHECK_(begin <= end && end <= size)
161        << "Invalid shuffle range finish " << end << ": must be in range ["
162        << begin << ", " << size << "].";
163    for (int range_width = end - begin; range_width >= 2; range_width--) {
164      const int last_in_range = begin + range_width - 1;
165      const int selected = begin + random->Generate(range_width);
166      std::swap((*v)[selected], (*v)[last_in_range]);
167    }
168  }
169  template <typename E>
170  inline void Shuffle(internal::Random* random, std::vector<E>* v) {
171    ShuffleRange(random, 0, static_cast<int>(v->size()), v);
172  }
173  template <typename T>
174  static void Delete(T* x) {
175    delete x;
176  }
177  class TestPropertyKeyIs {
178   public:
179    explicit TestPropertyKeyIs(const std::string& key) : key_(key) {}
180    bool operator()(const TestProperty& test_property) const {
181      return test_property.key() == key_;
182    }
183   private:
184    std::string key_;
185  };
186  class GTEST_API_ UnitTestOptions {
187   public:
188    static std::string GetOutputFormat();
189    static std::string GetAbsolutePathToOutputFile();
190    static bool PatternMatchesString(const char *pattern, const char *str);
191    static bool FilterMatchesTest(const std::string &test_case_name,
192                                  const std::string &test_name);
193  #if GTEST_OS_WINDOWS
194    static int GTestShouldProcessSEH(DWORD exception_code);
195  #endif  
196    static bool MatchesFilter(const std::string& name, const char* filter);
197  };
198  GTEST_API_ FilePath GetCurrentExecutableName();
199  class OsStackTraceGetterInterface {
200   public:
201    OsStackTraceGetterInterface() {}
202    virtual ~OsStackTraceGetterInterface() {}
203    virtual string CurrentStackTrace(int max_depth, int skip_count) = 0;
204    virtual void UponLeavingGTest() = 0;
205   private:
206    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetterInterface);
207  };
208  class OsStackTraceGetter : public OsStackTraceGetterInterface {
209   public:
210    OsStackTraceGetter() : caller_frame_(NULL) {}
211    virtual string CurrentStackTrace(int max_depth, int skip_count)
212        GTEST_LOCK_EXCLUDED_(mutex_);
213    virtual void UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_);
214    static const char* const kElidedFramesMarker;
215   private:
216    Mutex mutex_;  
217    void* caller_frame_;
218    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetter);
219  };
220  struct TraceInfo {
221    const char* file;
222    int line;
223    std::string message;
224  };
225  class DefaultGlobalTestPartResultReporter
226    : public TestPartResultReporterInterface {
227   public:
228    explicit DefaultGlobalTestPartResultReporter(UnitTestImpl* unit_test);
229    virtual void ReportTestPartResult(const TestPartResult& result);
230   private:
231    UnitTestImpl* const unit_test_;
232    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultGlobalTestPartResultReporter);
233  };
234  class DefaultPerThreadTestPartResultReporter
235      : public TestPartResultReporterInterface {
236   public:
237    explicit DefaultPerThreadTestPartResultReporter(UnitTestImpl* unit_test);
238    virtual void ReportTestPartResult(const TestPartResult& result);
239   private:
240    UnitTestImpl* const unit_test_;
241    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultPerThreadTestPartResultReporter);
242  };
243  class GTEST_API_ UnitTestImpl {
244   public:
245    explicit UnitTestImpl(UnitTest* parent);
246    virtual ~UnitTestImpl();
247    TestPartResultReporterInterface* GetGlobalTestPartResultReporter();
248    void SetGlobalTestPartResultReporter(
249        TestPartResultReporterInterface* reporter);
250    TestPartResultReporterInterface* GetTestPartResultReporterForCurrentThread();
251    void SetTestPartResultReporterForCurrentThread(
252        TestPartResultReporterInterface* reporter);
253    int successful_test_case_count() const;
254    int failed_test_case_count() const;
255    int total_test_case_count() const;
256    int test_case_to_run_count() const;
257    int successful_test_count() const;
258    int failed_test_count() const;
259    int reportable_disabled_test_count() const;
260    int disabled_test_count() const;
261    int reportable_test_count() const;
262    int total_test_count() const;
263    int test_to_run_count() const;
264    TimeInMillis start_timestamp() const { return start_timestamp_; }
265    TimeInMillis elapsed_time() const { return elapsed_time_; }
266    bool Passed() const { return !Failed(); }
267    bool Failed() const {
268      return failed_test_case_count() > 0 || ad_hoc_test_result()->Failed();
269    }
270    const TestCase* GetTestCase(int i) const {
271      const int index = GetElementOr(test_case_indices_, i, -1);
272      return index < 0 ? NULL : test_cases_[i];
273    }
274    TestCase* GetMutableTestCase(int i) {
275      const int index = GetElementOr(test_case_indices_, i, -1);
276      return index < 0 ? NULL : test_cases_[index];
277    }
278    TestEventListeners* listeners() { return &listeners_; }
279    TestResult* current_test_result();
280    const TestResult* ad_hoc_test_result() const { return &ad_hoc_test_result_; }
281    void set_os_stack_trace_getter(OsStackTraceGetterInterface* getter);
282    OsStackTraceGetterInterface* os_stack_trace_getter();
283    std::string CurrentOsStackTraceExceptTop(int skip_count) GTEST_NO_INLINE_;
284    TestCase* GetTestCase(const char* test_case_name,
285                          const char* type_param,
286                          Test::SetUpTestCaseFunc set_up_tc,
287                          Test::TearDownTestCaseFunc tear_down_tc);
288    void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,
289                     Test::TearDownTestCaseFunc tear_down_tc,
290                     TestInfo* test_info) {
291      if (original_working_dir_.IsEmpty()) {
292        original_working_dir_.Set(FilePath::GetCurrentDir());
293        GTEST_CHECK_(!original_working_dir_.IsEmpty())
294            << "Failed to get the current working directory.";
295      }
296      GetTestCase(test_info->test_case_name(),
297                  test_info->type_param(),
298                  set_up_tc,
299                  tear_down_tc)->AddTestInfo(test_info);
300    }
301  #if GTEST_HAS_PARAM_TEST
302    internal::ParameterizedTestCaseRegistry& parameterized_test_registry() {
303      return parameterized_test_registry_;
304    }
305  #endif  
<span onclick='openModal()' class='match'>306    void set_current_test_case(TestCase* a_current_test_case) {
307      current_test_case_ = a_current_test_case;
308    }
309    void set_current_test_info(TestInfo* a_current_test_info) {
310      current_test_info_ = a_current_test_info;
311    }
312    void RegisterParameterizedTests();
313    bool RunAllTests();
314    void ClearNonAdHocTestResult() {
</span>315      ForEach(test_cases_, TestCase::ClearTestCaseResult);
316    }
317    void ClearAdHocTestResult() {
318      ad_hoc_test_result_.Clear();
319    }
320    void RecordProperty(const TestProperty& test_property);
321    enum ReactionToSharding {
322      HONOR_SHARDING_PROTOCOL,
323      IGNORE_SHARDING_PROTOCOL
324    };
325    int FilterTests(ReactionToSharding shard_tests);
326    void ListTestsMatchingFilter();
327    const TestCase* current_test_case() const { return current_test_case_; }
328    TestInfo* current_test_info() { return current_test_info_; }
329    const TestInfo* current_test_info() const { return current_test_info_; }
330    std::vector<Environment*>& environments() { return environments_; }
331    std::vector<TraceInfo>& gtest_trace_stack() {
332      return *(gtest_trace_stack_.pointer());
333    }
334    const std::vector<TraceInfo>& gtest_trace_stack() const {
335      return gtest_trace_stack_.get();
336    }
337  #if GTEST_HAS_DEATH_TEST
338    void InitDeathTestSubprocessControlInfo() {
339      internal_run_death_test_flag_.reset(ParseInternalRunDeathTestFlag());
340    }
341    const InternalRunDeathTestFlag* internal_run_death_test_flag() const {
342      return internal_run_death_test_flag_.get();
343    }
344    internal::DeathTestFactory* death_test_factory() {
345      return death_test_factory_.get();
346    }
347    void SuppressTestEventsIfInSubprocess();
348    friend class ReplaceDeathTestFactory;
349  #endif  
350    void ConfigureXmlOutput();
351  #if GTEST_CAN_STREAM_RESULTS_
352    void ConfigureStreamingOutput();
353  #endif
354    void PostFlagParsingInit();
355    int random_seed() const { return random_seed_; }
356    internal::Random* random() { return &random_; }
357    void ShuffleTests();
358    void UnshuffleTests();
359    bool catch_exceptions() const { return catch_exceptions_; }
360   private:
361    friend class ::testing::UnitTest;
362    void set_catch_exceptions(bool value) { catch_exceptions_ = value; }
363    UnitTest* const parent_;
364    internal::FilePath original_working_dir_;
365    DefaultGlobalTestPartResultReporter default_global_test_part_result_reporter_;
366    DefaultPerThreadTestPartResultReporter
367        default_per_thread_test_part_result_reporter_;
368    TestPartResultReporterInterface* global_test_part_result_repoter_;
369    internal::Mutex global_test_part_result_reporter_mutex_;
370    internal::ThreadLocal<TestPartResultReporterInterface*>
371        per_thread_test_part_result_reporter_;
372    std::vector<Environment*> environments_;
373    std::vector<TestCase*> test_cases_;
374    std::vector<int> test_case_indices_;
375  #if GTEST_HAS_PARAM_TEST
376    internal::ParameterizedTestCaseRegistry parameterized_test_registry_;
377    bool parameterized_tests_registered_;
378  #endif  
379    int last_death_test_case_;
380    TestCase* current_test_case_;
381    TestInfo* current_test_info_;
382    TestResult ad_hoc_test_result_;
383    TestEventListeners listeners_;
384    OsStackTraceGetterInterface* os_stack_trace_getter_;
385    bool post_flag_parse_init_performed_;
386    int random_seed_;
387    internal::Random random_;
388    TimeInMillis start_timestamp_;
389    TimeInMillis elapsed_time_;
390  #if GTEST_HAS_DEATH_TEST
391    internal::scoped_ptr<InternalRunDeathTestFlag> internal_run_death_test_flag_;
392    internal::scoped_ptr<internal::DeathTestFactory> death_test_factory_;
393  #endif  
394    internal::ThreadLocal<std::vector<TraceInfo> > gtest_trace_stack_;
395    bool catch_exceptions_;
396    GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTestImpl);
397  };  
398  inline UnitTestImpl* GetUnitTestImpl() {
399    return UnitTest::GetInstance()->impl();
400  }
401  #if GTEST_USES_SIMPLE_RE
402  GTEST_API_ bool IsInSet(char ch, const char* str);
403  GTEST_API_ bool IsAsciiDigit(char ch);
404  GTEST_API_ bool IsAsciiPunct(char ch);
405  GTEST_API_ bool IsRepeat(char ch);
406  GTEST_API_ bool IsAsciiWhiteSpace(char ch);
407  GTEST_API_ bool IsAsciiWordChar(char ch);
408  GTEST_API_ bool IsValidEscape(char ch);
409  GTEST_API_ bool AtomMatchesChar(bool escaped, char pattern, char ch);
410  GTEST_API_ bool ValidateRegex(const char* regex);
411  GTEST_API_ bool MatchRegexAtHead(const char* regex, const char* str);
412  GTEST_API_ bool MatchRepetitionAndRegexAtHead(
413      bool escaped, char ch, char repeat, const char* regex, const char* str);
414  GTEST_API_ bool MatchRegexAnywhere(const char* regex, const char* str);
415  #endif  
416  GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, char** argv);
417  GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv);
418  #if GTEST_HAS_DEATH_TEST
419  GTEST_API_ std::string GetLastErrnoDescription();
420  # if GTEST_OS_WINDOWS
421  class AutoHandle {
422   public:
423    AutoHandle() : handle_(INVALID_HANDLE_VALUE) {}
424    explicit AutoHandle(HANDLE handle) : handle_(handle) {}
425    ~AutoHandle() { Reset(); }
426    HANDLE Get() const { return handle_; }
427    void Reset() { Reset(INVALID_HANDLE_VALUE); }
428    void Reset(HANDLE handle) {
429      if (handle != handle_) {
430        if (handle_ != INVALID_HANDLE_VALUE)
431          ::CloseHandle(handle_);
432        handle_ = handle;
433      }
434    }
435   private:
436    HANDLE handle_;
437    GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);
438  };
439  # endif  
440  template <typename Integer>
441  bool ParseNaturalNumber(const ::std::string& str, Integer* number) {
442    if (str.empty() || !IsDigit(str[0])) {
443      return false;
444    }
445    errno = 0;
446    char* end;
447  # if GTEST_OS_WINDOWS && !defined(__GNUC__)
448    typedef unsigned __int64 BiggestConvertible;
449    const BiggestConvertible parsed = _strtoui64(str.c_str(), &end, 10);
450  # else
451    typedef unsigned long long BiggestConvertible;  
452    const BiggestConvertible parsed = strtoull(str.c_str(), &end, 10);
453  # endif  
454    const bool parse_success = *end == '\0' && errno == 0;
455    GTEST_CHECK_(sizeof(Integer) <= sizeof(parsed));
456    const Integer result = static_cast<Integer>(parsed);
457    if (parse_success && static_cast<BiggestConvertible>(result) == parsed) {
458      *number = result;
459      return true;
460    }
461    return false;
462  }
463  #endif  
464  class TestResultAccessor {
465   public:
466    static void RecordProperty(TestResult* test_result,
467                               const std::string& xml_element,
468                               const TestProperty& property) {
469      test_result->RecordProperty(xml_element, property);
470    }
471    static void ClearTestPartResults(TestResult* test_result) {
472      test_result->ClearTestPartResults();
473    }
474    static const std::vector<testing::TestPartResult>& test_part_results(
475        const TestResult& test_result) {
476      return test_result.test_part_results();
477    }
478  };
479  #if GTEST_CAN_STREAM_RESULTS_
480  class StreamingListener : public EmptyTestEventListener {
481   public:
482    class AbstractSocketWriter {
483     public:
484      virtual ~AbstractSocketWriter() {}
485      virtual void Send(const string& message) = 0;
486      virtual void CloseConnection() {}
487      void SendLn(const string& message) {
488        Send(message + "\n");
489      }
490    };
491    class SocketWriter : public AbstractSocketWriter {
492     public:
493      SocketWriter(const string& host, const string& port)
494          : sockfd_(-1), host_name_(host), port_num_(port) {
495        MakeConnection();
496      }
497      virtual ~SocketWriter() {
498        if (sockfd_ != -1)
499          CloseConnection();
500      }
501      virtual void Send(const string& message) {
502        GTEST_CHECK_(sockfd_ != -1)
503            << "Send() can be called only when there is a connection.";
504        const int len = static_cast<int>(message.length());
505        if (write(sockfd_, message.c_str(), len) != len) {
506          GTEST_LOG_(WARNING)
507              << "stream_result_to: failed to stream to "
508              << host_name_ << ":" << port_num_;
509        }
510      }
511     private:
512      void MakeConnection();
513      void CloseConnection() {
514        GTEST_CHECK_(sockfd_ != -1)
515            << "CloseConnection() can be called only when there is a connection.";
516        close(sockfd_);
517        sockfd_ = -1;
518      }
519      int sockfd_;  
520      const string host_name_;
521      const string port_num_;
522      GTEST_DISALLOW_COPY_AND_ASSIGN_(SocketWriter);
523    };  
524    static string UrlEncode(const char* str);
525    StreamingListener(const string& host, const string& port)
526        : socket_writer_(new SocketWriter(host, port)) { Start(); }
527    explicit StreamingListener(AbstractSocketWriter* socket_writer)
528        : socket_writer_(socket_writer) { Start(); }
529    void OnTestProgramStart(const UnitTest& &bsol;* unit_test */) {
530      SendLn("event=TestProgramStart");
531    }
532    void OnTestProgramEnd(const UnitTest& unit_test) {
533      SendLn("event=TestProgramEnd&passed=" + FormatBool(unit_test.Passed()));
534      socket_writer_->CloseConnection();
535    }
536    void OnTestIterationStart(const UnitTest& &bsol;* unit_test */, int iteration) {
537      SendLn("event=TestIterationStart&iteration=" +
538             StreamableToString(iteration));
539    }
540    void OnTestIterationEnd(const UnitTest& unit_test, int &bsol;* iteration */) {
541      SendLn("event=TestIterationEnd&passed=" +
542             FormatBool(unit_test.Passed()) + "&elapsed_time=" +
543             StreamableToString(unit_test.elapsed_time()) + "ms");
544    }
545    void OnTestCaseStart(const TestCase& test_case) {
546      SendLn(std::string("event=TestCaseStart&name=") + test_case.name());
547    }
548    void OnTestCaseEnd(const TestCase& test_case) {
549      SendLn("event=TestCaseEnd&passed=" + FormatBool(test_case.Passed())
550             + "&elapsed_time=" + StreamableToString(test_case.elapsed_time())
551             + "ms");
552    }
553    void OnTestStart(const TestInfo& test_info) {
554      SendLn(std::string("event=TestStart&name=") + test_info.name());
555    }
556    void OnTestEnd(const TestInfo& test_info) {
557      SendLn("event=TestEnd&passed=" +
558             FormatBool((test_info.result())->Passed()) +
559             "&elapsed_time=" +
560             StreamableToString((test_info.result())->elapsed_time()) + "ms");
561    }
562    void OnTestPartResult(const TestPartResult& test_part_result) {
563      const char* file_name = test_part_result.file_name();
564      if (file_name == NULL)
565        file_name = "";
566      SendLn("event=TestPartResult&file=" + UrlEncode(file_name) +
567             "&line=" + StreamableToString(test_part_result.line_number()) +
568             "&message=" + UrlEncode(test_part_result.message()));
569    }
570   private:
571    void SendLn(const string& message) { socket_writer_->SendLn(message); }
572    void Start() { SendLn("gtest_streaming_protocol_version=1.0"); }
573    string FormatBool(bool value) { return value ? "1" : "0"; }
574    const scoped_ptr<AbstractSocketWriter> socket_writer_;
575    GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamingListener);
576  };  
577  #endif  
578  }  
579  }  
580  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TabBar.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal-inl.h</div>
                </div>
                <div class="column column_space"><pre><code>62  	void setVertical(bool b) {
63  		_isVertical = b;
64  	};
65  	void setMultiLine(bool b) {
66  		_isMultiLine = b;
67  	};
68  	HFONT& getFont(bool isReduced = true) {
</pre></code></div>
                <div class="column column_space"><pre><code>306    void set_current_test_case(TestCase* a_current_test_case) {
307      current_test_case_ = a_current_test_case;
308    }
309    void set_current_test_info(TestInfo* a_current_test_info) {
310      current_test_info_ = a_current_test_info;
311    }
312    void RegisterParameterizedTests();
313    bool RunAllTests();
314    void ClearNonAdHocTestResult() {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    