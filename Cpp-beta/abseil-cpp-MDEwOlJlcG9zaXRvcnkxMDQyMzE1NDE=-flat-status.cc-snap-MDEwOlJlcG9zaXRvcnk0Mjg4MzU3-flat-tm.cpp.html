
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.330588594083562%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-status.cc</h3>
            <pre><code>1  #include "absl/status/status.h"
2  #include <errno.h>
3  #include <cassert>
4  #include <utility>
5  #include "absl/base/internal/raw_logging.h"
6  #include "absl/base/internal/strerror.h"
7  #include "absl/base/macros.h"
8  #include "absl/debugging/stacktrace.h"
9  #include "absl/debugging/symbolize.h"
10  #include "absl/status/status_payload_printer.h"
11  #include "absl/strings/escaping.h"
12  #include "absl/strings/str_cat.h"
13  #include "absl/strings/str_format.h"
14  #include "absl/strings/str_split.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  std::string StatusCodeToString(StatusCode code) {
18    switch (code) {
19      case StatusCode::kOk:
20        return "OK";
21      case StatusCode::kCancelled:
22        return "CANCELLED";
23      case StatusCode::kUnknown:
24        return "UNKNOWN";
25      case StatusCode::kInvalidArgument:
26        return "INVALID_ARGUMENT";
27      case StatusCode::kDeadlineExceeded:
28        return "DEADLINE_EXCEEDED";
29      case StatusCode::kNotFound:
30        return "NOT_FOUND";
31      case StatusCode::kAlreadyExists:
32        return "ALREADY_EXISTS";
33      case StatusCode::kPermissionDenied:
34        return "PERMISSION_DENIED";
35      case StatusCode::kUnauthenticated:
36        return "UNAUTHENTICATED";
37      case StatusCode::kResourceExhausted:
38        return "RESOURCE_EXHAUSTED";
39      case StatusCode::kFailedPrecondition:
40        return "FAILED_PRECONDITION";
41      case StatusCode::kAborted:
42        return "ABORTED";
43      case StatusCode::kOutOfRange:
44        return "OUT_OF_RANGE";
45      case StatusCode::kUnimplemented:
46        return "UNIMPLEMENTED";
47      case StatusCode::kInternal:
48        return "INTERNAL";
49      case StatusCode::kUnavailable:
50        return "UNAVAILABLE";
51      case StatusCode::kDataLoss:
52        return "DATA_LOSS";
53      default:
54        return "";
55    }
56  }
57  std::ostream& operator<<(std::ostream& os, StatusCode code) {
58    return os << StatusCodeToString(code);
59  }
60  namespace status_internal {
61  static absl::optional<size_t> FindPayloadIndexByUrl(
62      const Payloads* payloads, absl::string_view type_url) {
63    if (payloads == nullptr) return absl::nullopt;
64    for (size_t i = 0; i < payloads->size(); ++i) {
65      if ((*payloads)[i].type_url == type_url) return i;
66    }
67    return absl::nullopt;
68  }
69  absl::StatusCode MapToLocalCode(int value) {
70    absl::StatusCode code = static_cast<absl::StatusCode>(value);
71    switch (code) {
72      case absl::StatusCode::kOk:
73      case absl::StatusCode::kCancelled:
74      case absl::StatusCode::kUnknown:
75      case absl::StatusCode::kInvalidArgument:
76      case absl::StatusCode::kDeadlineExceeded:
77      case absl::StatusCode::kNotFound:
78      case absl::StatusCode::kAlreadyExists:
79      case absl::StatusCode::kPermissionDenied:
80      case absl::StatusCode::kResourceExhausted:
81      case absl::StatusCode::kFailedPrecondition:
82      case absl::StatusCode::kAborted:
83      case absl::StatusCode::kOutOfRange:
84      case absl::StatusCode::kUnimplemented:
85      case absl::StatusCode::kInternal:
86      case absl::StatusCode::kUnavailable:
87      case absl::StatusCode::kDataLoss:
88      case absl::StatusCode::kUnauthenticated:
89        return code;
90      default:
91        return absl::StatusCode::kUnknown;
92    }
93  }
94  }  
95  absl::optional<absl::Cord> Status::GetPayload(
96      absl::string_view type_url) const {
97    const auto* payloads = GetPayloads();
98    absl::optional<size_t> index =
99        status_internal::FindPayloadIndexByUrl(payloads, type_url);
100    if (index.has_value()) return (*payloads)[index.value()].payload;
101    return absl::nullopt;
102  }
103  void Status::SetPayload(absl::string_view type_url, absl::Cord payload) {
104    if (ok()) return;
105    PrepareToModify();
106    status_internal::StatusRep* rep = RepToPointer(rep_);
107    if (!rep->payloads) {
108      rep->payloads = absl::make_unique<status_internal::Payloads>();
109    }
110    absl::optional<size_t> index =
111        status_internal::FindPayloadIndexByUrl(rep->payloads.get(), type_url);
112    if (index.has_value()) {
113      (*rep->payloads)[index.value()].payload = std::move(payload);
114      return;
115    }
116    rep->payloads->push_back({std::string(type_url), std::move(payload)});
117  }
118  bool Status::ErasePayload(absl::string_view type_url) {
119    absl::optional<size_t> index =
120        status_internal::FindPayloadIndexByUrl(GetPayloads(), type_url);
121    if (index.has_value()) {
122      PrepareToModify();
123      GetPayloads()->erase(GetPayloads()->begin() + index.value());
124      if (GetPayloads()->empty() && message().empty()) {
125        StatusCode c = static_cast<StatusCode>(raw_code());
126        Unref(rep_);
127        rep_ = CodeToInlinedRep(c);
128      }
129      return true;
130    }
131    return false;
132  }
133  void Status::ForEachPayload(
134      absl::FunctionRef<void(absl::string_view, const absl::Cord&)> visitor)
135      const {
136    if (auto* payloads = GetPayloads()) {
137      bool in_reverse =
138          payloads->size() > 1 && reinterpret_cast<uintptr_t>(payloads) % 13 > 6;
139      for (size_t index = 0; index < payloads->size(); ++index) {
140        const auto& elem =
141            (*payloads)[in_reverse ? payloads->size() - 1 - index : index];
142  #ifdef NDEBUG
143        visitor(elem.type_url, elem.payload);
144  #else
145        visitor(std::string(elem.type_url), elem.payload);
146  #endif  
147      }
148    }
149  }
150  const std::string* Status::EmptyString() {
151    static union EmptyString {
152      std::string str;
153      ~EmptyString() {}
154    } empty = {{}};
155    return &empty.str;
156  }
157  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
158  constexpr const char Status::kMovedFromString[];
159  #endif
160  const std::string* Status::MovedFromString() {
161    static std::string* moved_from_string = new std::string(kMovedFromString);
162    return moved_from_string;
163  }
164  void Status::UnrefNonInlined(uintptr_t rep) {
165    status_internal::StatusRep* r = RepToPointer(rep);
166    if (r->ref.load(std::memory_order_acquire) == 1 ||
167        r->ref.fetch_sub(1, std::memory_order_acq_rel) - 1 == 0) {
168      delete r;
169    }
170  }
171  Status::Status(absl::StatusCode code, absl::string_view msg)
172      : rep_(CodeToInlinedRep(code)) {
173    if (code != absl::StatusCode::kOk && !msg.empty()) {
174      rep_ = PointerToRep(new status_internal::StatusRep(code, msg, nullptr));
175    }
176  }
177  int Status::raw_code() const {
178    if (IsInlined(rep_)) {
179      return static_cast<int>(InlinedRepToCode(rep_));
180    }
181    status_internal::StatusRep* rep = RepToPointer(rep_);
182    return static_cast<int>(rep->code);
183  }
184  absl::StatusCode Status::code() const {
185    return status_internal::MapToLocalCode(raw_code());
186  }
187  void Status::PrepareToModify() {
188    ABSL_RAW_CHECK(!ok(), "PrepareToModify shouldn't be called on OK status.");
189    if (IsInlined(rep_)) {
190      rep_ = PointerToRep(new status_internal::StatusRep(
191          static_cast<absl::StatusCode>(raw_code()), absl::string_view(),
192          nullptr));
193      return;
194    }
195    uintptr_t rep_i = rep_;
196    status_internal::StatusRep* rep = RepToPointer(rep_);
197    if (rep->ref.load(std::memory_order_acquire) != 1) {
198      std::unique_ptr<status_internal::Payloads> payloads;
199      if (rep->payloads) {
200        payloads = absl::make_unique<status_internal::Payloads>(*rep->payloads);
201      }
202      status_internal::StatusRep* const new_rep = new status_internal::StatusRep(
203          rep->code, message(), std::move(payloads));
204      rep_ = PointerToRep(new_rep);
205      UnrefNonInlined(rep_i);
206    }
207  }
208  bool Status::EqualsSlow(const absl::Status& a, const absl::Status& b) {
209    if (IsInlined(a.rep_) != IsInlined(b.rep_)) return false;
210    if (a.message() != b.message()) return false;
211    if (a.raw_code() != b.raw_code()) return false;
212    if (a.GetPayloads() == b.GetPayloads()) return true;
213    const status_internal::Payloads no_payloads;
214    const status_internal::Payloads* larger_payloads =
215        a.GetPayloads() ? a.GetPayloads() : &no_payloads;
216    const status_internal::Payloads* smaller_payloads =
217        b.GetPayloads() ? b.GetPayloads() : &no_payloads;
218    if (larger_payloads->size() < smaller_payloads->size()) {
219      std::swap(larger_payloads, smaller_payloads);
220    }
221    if ((larger_payloads->size() - smaller_payloads->size()) > 1) return false;
222    for (const auto& payload : *larger_payloads) {
223      bool found = false;
224      for (const auto& other_payload : *smaller_payloads) {
225        if (payload.type_url == other_payload.type_url) {
226          if (payload.payload != other_payload.payload) {
227            return false;
228          }
229          found = true;
230          break;
231        }
232      }
233      if (!found) return false;
234    }
235    return true;
236  }
237  std::string Status::ToStringSlow(StatusToStringMode mode) const {
238    std::string text;
239    absl::StrAppend(&text, absl::StatusCodeToString(code()), ": ", message());
240    const bool with_payload = (mode & StatusToStringMode::kWithPayload) ==
241                              StatusToStringMode::kWithPayload;
242    if (with_payload) {
243      status_internal::StatusPayloadPrinter printer =
244          status_internal::GetStatusPayloadPrinter();
245      this->ForEachPayload([&](absl::string_view type_url,
246                               const absl::Cord& payload) {
247        absl::optional<std::string> result;
248        if (printer) result = printer(type_url, payload);
249        absl::StrAppend(
250            &text, " [", type_url, "='",
251            result.has_value() ? *result : absl::CHexEscape(std::string(payload)),
252            "']");
253      });
254    }
255    return text;
256  }
257  std::ostream& operator<<(std::ostream& os, const Status& x) {
258    os << x.ToString(StatusToStringMode::kWithEverything);
259    return os;
260  }
261  Status AbortedError(absl::string_view message) {
<span onclick='openModal()' class='match'>262    return Status(absl::StatusCode::kAborted, message);
263  }
264  Status AlreadyExistsError(absl::string_view message) {
265    return Status(absl::StatusCode::kAlreadyExists, message);
266  }
267  Status CancelledError(absl::string_view message) {
268    return Status(absl::StatusCode::kCancelled, message);
269  }
270  Status DataLossError(absl::string_view message) {
</span>271    return Status(absl::StatusCode::kDataLoss, message);
272  }
273  Status DeadlineExceededError(absl::string_view message) {
274    return Status(absl::StatusCode::kDeadlineExceeded, message);
275  }
276  Status FailedPreconditionError(absl::string_view message) {
277    return Status(absl::StatusCode::kFailedPrecondition, message);
278  }
279  Status InternalError(absl::string_view message) {
280    return Status(absl::StatusCode::kInternal, message);
281  }
282  Status InvalidArgumentError(absl::string_view message) {
283    return Status(absl::StatusCode::kInvalidArgument, message);
284  }
285  Status NotFoundError(absl::string_view message) {
286    return Status(absl::StatusCode::kNotFound, message);
287  }
288  Status OutOfRangeError(absl::string_view message) {
289    return Status(absl::StatusCode::kOutOfRange, message);
290  }
291  Status PermissionDeniedError(absl::string_view message) {
292    return Status(absl::StatusCode::kPermissionDenied, message);
293  }
294  Status ResourceExhaustedError(absl::string_view message) {
295    return Status(absl::StatusCode::kResourceExhausted, message);
296  }
297  Status UnauthenticatedError(absl::string_view message) {
298    return Status(absl::StatusCode::kUnauthenticated, message);
299  }
300  Status UnavailableError(absl::string_view message) {
301    return Status(absl::StatusCode::kUnavailable, message);
302  }
303  Status UnimplementedError(absl::string_view message) {
304    return Status(absl::StatusCode::kUnimplemented, message);
305  }
306  Status UnknownError(absl::string_view message) {
307    return Status(absl::StatusCode::kUnknown, message);
308  }
309  bool IsAborted(const Status& status) {
310    return status.code() == absl::StatusCode::kAborted;
311  }
312  bool IsAlreadyExists(const Status& status) {
313    return status.code() == absl::StatusCode::kAlreadyExists;
314  }
315  bool IsCancelled(const Status& status) {
316    return status.code() == absl::StatusCode::kCancelled;
317  }
318  bool IsDataLoss(const Status& status) {
319    return status.code() == absl::StatusCode::kDataLoss;
320  }
321  bool IsDeadlineExceeded(const Status& status) {
322    return status.code() == absl::StatusCode::kDeadlineExceeded;
323  }
324  bool IsFailedPrecondition(const Status& status) {
325    return status.code() == absl::StatusCode::kFailedPrecondition;
326  }
327  bool IsInternal(const Status& status) {
328    return status.code() == absl::StatusCode::kInternal;
329  }
330  bool IsInvalidArgument(const Status& status) {
331    return status.code() == absl::StatusCode::kInvalidArgument;
332  }
333  bool IsNotFound(const Status& status) {
334    return status.code() == absl::StatusCode::kNotFound;
335  }
336  bool IsOutOfRange(const Status& status) {
337    return status.code() == absl::StatusCode::kOutOfRange;
338  }
339  bool IsPermissionDenied(const Status& status) {
340    return status.code() == absl::StatusCode::kPermissionDenied;
341  }
342  bool IsResourceExhausted(const Status& status) {
343    return status.code() == absl::StatusCode::kResourceExhausted;
344  }
345  bool IsUnauthenticated(const Status& status) {
346    return status.code() == absl::StatusCode::kUnauthenticated;
347  }
348  bool IsUnavailable(const Status& status) {
349    return status.code() == absl::StatusCode::kUnavailable;
350  }
351  bool IsUnimplemented(const Status& status) {
352    return status.code() == absl::StatusCode::kUnimplemented;
353  }
354  bool IsUnknown(const Status& status) {
355    return status.code() == absl::StatusCode::kUnknown;
356  }
357  StatusCode ErrnoToStatusCode(int error_number) {
358    switch (error_number) {
359      case 0:
360        return StatusCode::kOk;
361      case EINVAL:        
362      case ENAMETOOLONG:  
363      case E2BIG:         
364      case EDESTADDRREQ:  
365      case EDOM:          
366      case EFAULT:        
367      case EILSEQ:        
368      case ENOPROTOOPT:   
369      case ENOSTR:        
370      case ENOTSOCK:      
371      case ENOTTY:        
372      case EPROTOTYPE:    
373      case ESPIPE:        
374        return StatusCode::kInvalidArgument;
375      case ETIMEDOUT:  
376      case ETIME:      
377        return StatusCode::kDeadlineExceeded;
378      case ENODEV:  
379      case ENOENT:  
380  #ifdef ENOMEDIUM
381      case ENOMEDIUM:  
382  #endif
383      case ENXIO:  
384      case ESRCH:  
385        return StatusCode::kNotFound;
386      case EEXIST:         
387      case EADDRNOTAVAIL:  
388      case EALREADY:       
389  #ifdef ENOTUNIQ
390      case ENOTUNIQ:  
391  #endif
392        return StatusCode::kAlreadyExists;
393      case EPERM:   
394      case EACCES:  
395  #ifdef ENOKEY
396      case ENOKEY:  
397  #endif
398      case EROFS:  
399        return StatusCode::kPermissionDenied;
400      case ENOTEMPTY:   
401      case EISDIR:      
402      case ENOTDIR:     
403      case EADDRINUSE:  
404      case EBADF:       
405  #ifdef EBADFD
406      case EBADFD:  
407  #endif
408      case EBUSY:    
409      case ECHILD:   
410      case EISCONN:  
411  #ifdef EISNAM
412      case EISNAM:  
413  #endif
414  #ifdef ENOTBLK
415      case ENOTBLK:  
416  #endif
417      case ENOTCONN:  
418      case EPIPE:     
419  #ifdef ESHUTDOWN
420      case ESHUTDOWN:  
421  #endif
422      case ETXTBSY:  
423  #ifdef EUNATCH
424      case EUNATCH:  
425  #endif
426        return StatusCode::kFailedPrecondition;
427      case ENOSPC:  
428  #ifdef EDQUOT
429      case EDQUOT:  
430  #endif
431      case EMFILE:   
432      case EMLINK:   
433      case ENFILE:   
434      case ENOBUFS:  
435      case ENODATA:  
436      case ENOMEM:   
437      case ENOSR:    
438  #ifdef EUSERS
439      case EUSERS:  
440  #endif
441        return StatusCode::kResourceExhausted;
442  #ifdef ECHRNG
443      case ECHRNG:  
444  #endif
445      case EFBIG:      
446      case EOVERFLOW:  
447      case ERANGE:     
448        return StatusCode::kOutOfRange;
449  #ifdef ENOPKG
450      case ENOPKG:  
451  #endif
452      case ENOSYS:        
453      case ENOTSUP:       
454      case EAFNOSUPPORT:  
455  #ifdef EPFNOSUPPORT
456      case EPFNOSUPPORT:  
457  #endif
458      case EPROTONOSUPPORT:  
459  #ifdef ESOCKTNOSUPPORT
460      case ESOCKTNOSUPPORT:  
461  #endif
462      case EXDEV:  
463        return StatusCode::kUnimplemented;
464      case EAGAIN:  
465  #ifdef ECOMM
466      case ECOMM:  
467  #endif
468      case ECONNREFUSED:  
469      case ECONNABORTED:  
470      case ECONNRESET:    
471      case EINTR:         
472  #ifdef EHOSTDOWN
473      case EHOSTDOWN:  
474  #endif
475      case EHOSTUNREACH:  
476      case ENETDOWN:      
477      case ENETRESET:     
478      case ENETUNREACH:   
479      case ENOLCK:        
480      case ENOLINK:       
481  #ifdef ENONET
482      case ENONET:  
483  #endif
484        return StatusCode::kUnavailable;
485      case EDEADLK:  
486  #ifdef ESTALE
487      case ESTALE:  
488  #endif
489        return StatusCode::kAborted;
490      case ECANCELED:  
491        return StatusCode::kCancelled;
492      default:
493        return StatusCode::kUnknown;
494    }
495  }
496  namespace {
497  std::string MessageForErrnoToStatus(int error_number,
498                                      absl::string_view message) {
499    return absl::StrCat(message, ": ",
500                        absl::base_internal::StrError(error_number));
501  }
502  }  
503  Status ErrnoToStatus(int error_number, absl::string_view message) {
504    return Status(ErrnoToStatusCode(error_number),
505                  MessageForErrnoToStatus(error_number, message));
506  }
507  namespace status_internal {
508  std::string* MakeCheckFailString(const absl::Status* status,
509                                   const char* prefix) {
510    return new std::string(
511        absl::StrCat(prefix, " (",
512                     status->ToString(StatusToStringMode::kWithEverything), ")"));
513  }
514  }  
515  const char* StatusMessageAsCStr(const Status& status) {
516    auto sv_message = status.message();
517    return sv_message.empty() ? "" : sv_message.data();
518  }
519  ABSL_NAMESPACE_END
520  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tm.cpp</h3>
            <pre><code>1  bool TTmInfo::InitP=false;
2  TStrV TTmInfo::UsMonthNmV;
3  TStrV TTmInfo::SiMonthNmV;
4  TStrV TTmInfo::UsDayOfWeekNmV;
5  TStrV TTmInfo::SiDayOfWeekNmV;
6  void TTmInfo::InitMonthNmV(){
7    UsMonthNmV.Add("jan"); UsMonthNmV.Add("feb"); UsMonthNmV.Add("mar");
8    UsMonthNmV.Add("apr"); UsMonthNmV.Add("may"); UsMonthNmV.Add("jun");
9    UsMonthNmV.Add("jul"); UsMonthNmV.Add("aug"); UsMonthNmV.Add("sep");
10    UsMonthNmV.Add("oct"); UsMonthNmV.Add("nov"); UsMonthNmV.Add("dec");
11    IAssert(UsMonthNmV.Len()==12);
12    SiMonthNmV.Add("jan"); SiMonthNmV.Add("feb"); SiMonthNmV.Add("mar");
13    SiMonthNmV.Add("apr"); SiMonthNmV.Add("maj"); SiMonthNmV.Add("jun");
14    SiMonthNmV.Add("jul"); SiMonthNmV.Add("avg"); SiMonthNmV.Add("sep");
15    SiMonthNmV.Add("okt"); SiMonthNmV.Add("nov"); SiMonthNmV.Add("dec");
16    IAssert(SiMonthNmV.Len()==12);
17  }
18  void TTmInfo::InitDayOfWeekNmV(){
19    UsDayOfWeekNmV.Add("sun"); UsDayOfWeekNmV.Add("mon");
20    UsDayOfWeekNmV.Add("tue"); UsDayOfWeekNmV.Add("wed");
21    UsDayOfWeekNmV.Add("thu"); UsDayOfWeekNmV.Add("fri");
22    UsDayOfWeekNmV.Add("sat");
23    IAssert(UsDayOfWeekNmV.Len()==7);
24    SiDayOfWeekNmV.Add("ned"); SiDayOfWeekNmV.Add("pon");
25    SiDayOfWeekNmV.Add("tor"); SiDayOfWeekNmV.Add("sre");
26    SiDayOfWeekNmV.Add("cet"); SiDayOfWeekNmV.Add("pet");
27    SiDayOfWeekNmV.Add("sob");
28    IAssert(SiDayOfWeekNmV.Len()==7);
29  }
30  int TTmInfo::GetMonthN(const TStr& MonthNm, const TLoc& Loc){
31    EnsureInit();
32    int MonthN=-1;
33    switch (Loc){
34      case lUs: MonthN=UsMonthNmV.SearchForw(MonthNm.GetLc()); break;
35      case lSi: MonthN=SiMonthNmV.SearchForw(MonthNm.GetLc()); break;
36      default: Fail;
37    }
38    if (MonthN==-1){return -1;} else {return MonthN+1;}
39  }
40  TStr TTmInfo::GetMonthNm(const int& MonthN, const TLoc& Loc){
41    EnsureInit();
42    IAssert((1<=MonthN)&&(MonthN<=12));
43    switch (Loc){
44      case lUs: return UsMonthNmV[MonthN-1];
45      case lSi: return SiMonthNmV[MonthN-1];
46      default: Fail; return TStr();
47    }
48  }
49  int TTmInfo::GetDayOfWeekN(const TStr& DayOfWeekNm, const TLoc& Loc){
50    EnsureInit();
51    int DayOfWeekN=-1;
52    switch (Loc){
53      case lUs: DayOfWeekN=UsDayOfWeekNmV.SearchForw(DayOfWeekNm.GetLc()); break;
54      case lSi: DayOfWeekN=SiDayOfWeekNmV.SearchForw(DayOfWeekNm.GetLc()); break;
55      default: Fail;
56    }
57    if (DayOfWeekN==-1){return -1;} else {return DayOfWeekN+1;}
58  }
59  TStr TTmInfo::GetDayOfWeekNm(const int& DayOfWeekN, const TLoc& Loc){
60    EnsureInit();
61    IAssert((1<=DayOfWeekN)&&(DayOfWeekN<=7));
62    switch (Loc){
63      case lUs: return UsDayOfWeekNmV[DayOfWeekN-1];
64      case lSi: return SiDayOfWeekNmV[DayOfWeekN-1];
65      default: Fail; return TStr();
66    }
67  }
68  TStr TTmInfo::GetHmFromMins(const int& Mins){
69    return TInt::GetStr(Mins/60, "%02d")+":"+TInt::GetStr(Mins%60, "%02d");
70  }
71  int TTmInfo::GetTmUnitSecs(const TTmUnit& TmUnit) {
72    switch(TmUnit) {
73      case tmuYear : return 365*24*3600;
74      case tmuMonth : return 31*24*3600;
75      case tmuWeek : return 7*24*3600;
76      case tmuDay : return 24*3600;
77      case tmu12Hour : return 12*3600;
78      case tmu6Hour : return 6*3600;
79      case tmu4Hour : return 4*3600;
80      case tmu2Hour : return 2*3600;
81      case tmu1Hour : return 1*3600;
82      case tmu30Min : return 30*60;
83      case tmu15Min : return 15*60;
84      case tmu10Min : return 10*60;
85      case tmu1Min : return 60;
86      case tmu1Sec : return 1;
87      case tmuNodes : Fail;
88      case tmuEdges : Fail;
89      default: Fail;
90    }
91    return -1;
92  }
93  TStr TTmInfo::GetTmUnitStr(const TTmUnit& TmUnit) {
94    switch(TmUnit) {
95      case tmuYear : return "Year";
96      case tmuMonth : return "Month";
97      case tmuWeek : return "Week";
98      case tmuDay : return "Day";
99      case tmu12Hour : return "12 Hours";
100      case tmu6Hour : return "6 Hours";
101      case tmu4Hour : return "4 Hours";
102      case tmu2Hour : return "2 Hours";
103      case tmu1Hour : return "1 Hour";
104      case tmu30Min : return "30 Minutes";
105      case tmu15Min : return "15 Minutes";
106      case tmu10Min : return "10 Minutes";
107      case tmu1Min : return "Minute";
108      case tmu1Sec : return "Second";
109      case tmuNodes : return "Nodes";
110      case tmuEdges : return "Edges";
111      default: Fail;
112    }
113    return TStr::GetNullStr();
114  }
115  TStr TTmInfo::GetTmZoneDiffStr(const TStr& TmZoneStr){
116    if (TmZoneStr=="A"){&bsol;* Alpha Time Zone Military*/ return "+1000";}
117    if (TmZoneStr=="ACDT"){&bsol;* Australian Central Daylight Time	Australia */ return "+1030";}
118    if (TmZoneStr=="ACST"){&bsol;* Australian Central Standard Time	Australia */ return "+0930";}
119    if (TmZoneStr=="ADT"){&bsol;* Atlantic Daylight Time	North America */ return "-0300";}
120    if (TmZoneStr=="AEDT"){&bsol;* Australian Eastern Daylight Time or Australian Eastern Summer Time	Australia */ return "+1100";}
121    if (TmZoneStr=="AEST"){&bsol;* Australian Eastern Standard Time	Australia */ return "+1000";}
122    if (TmZoneStr=="AKDT"){&bsol;* Alaska Daylight Time	North America */ return "-0800";}
123    if (TmZoneStr=="AKST"){&bsol;* Alaska Standard Time	North America */ return "-0900";}
124    if (TmZoneStr=="AST"){&bsol;* Atlantic Standard Time	North America */ return "-0400";}
125    if (TmZoneStr=="AWDT"){&bsol;* Australian Western Daylight Time	Australia */ return "+0900";}
126    if (TmZoneStr=="AWST"){&bsol;* Australian Western Standard Time	Australia */ return "+0800";}
127    if (TmZoneStr=="B"){&bsol;* Bravo Time Zone	Military */ return "+0200";}
128    if (TmZoneStr=="BST"){&bsol;* British Summer Time	Europe */ return "+0100";}
129    if (TmZoneStr=="C"){&bsol;* Charlie Time Zone	Military */ return "+0300";}
130    if (TmZoneStr=="CDT"){&bsol;* Central Daylight Time	North America */ return "-0500";}
131    if (TmZoneStr=="CDT"){&bsol;* Central Daylight Time	Australia */ return "+1030";}
132    if (TmZoneStr=="CEDT"){&bsol;* Central European Daylight Time	Europe */ return "+0200";}
133    if (TmZoneStr=="CEST"){&bsol;* Central European Summer Time	Europe */ return "+0200";}
134    if (TmZoneStr=="CET"){&bsol;* Central European Time	Europe */ return "+0100";}
135    if (TmZoneStr=="CST"){&bsol;* Central Standard Time	North America */ return "-0600";}
136    if (TmZoneStr=="CST"){&bsol;* Central Summer Time	Australia */ return "+1030";}
137    if (TmZoneStr=="CST"){&bsol;* Central Standard Time	Australia */ return "+0930";}
138    if (TmZoneStr=="CXT"){&bsol;* Christmas Island Time	Australia */ return "+0700";}
139    if (TmZoneStr=="D"){&bsol;* Delta Time Zone	Military */ return "+0400";}
140    if (TmZoneStr=="E"){&bsol;* Echo Time Zone	Military */ return "+0500";}
141    if (TmZoneStr=="EDT"){&bsol;* Eastern Daylight Time	North America */ return "-0400";}
142    if (TmZoneStr=="EDT"){&bsol;* Eastern Daylight Time	Australia */ return "+1100";}
143    if (TmZoneStr=="EEDT"){&bsol;* Eastern European Daylight Time	Europe */ return "+0300";}
144    if (TmZoneStr=="EEST"){&bsol;* Eastern European Summer Time	Europe */ return "+0300";}
145    if (TmZoneStr=="EET"){&bsol;* Eastern European Time	Europe */ return "+0200";}
146    if (TmZoneStr=="EST"){&bsol;* Eastern Standard Time	North America */ return "-0500";}
147    if (TmZoneStr=="EST"){&bsol;* Eastern Summer Time	Australia */ return "+1100";}
148    if (TmZoneStr=="EST"){&bsol;* Eastern Standard Time	Australia */ return "+1000";}
149    if (TmZoneStr=="F"){&bsol;* Foxtrot Time Zone	Military */ return "+0600";}
150    if (TmZoneStr=="G"){&bsol;* Golf Time Zone	Military */ return "+0700";}
151    if (TmZoneStr=="GMT"){&bsol;* Greenwich Mean Time	Europe */ return "+0000";}
152    if (TmZoneStr=="H"){&bsol;* Hotel Time Zone	Military */ return "+0800";}
153    if (TmZoneStr=="HAA"){&bsol;* Heure Avancee de l'Atlantique	North America */ return "-0300";}
154    if (TmZoneStr=="HAC"){&bsol;* Heure Avancee du Centre	North America */ return "-0500";}
155    if (TmZoneStr=="HADT"){&bsol;* Hawaii-Aleutian Daylight Time	North America */ return "-0900";}
156    if (TmZoneStr=="HAE"){&bsol;* Heure Avancee de l'Est	North America */ return "-0400";}
157    if (TmZoneStr=="HAP"){&bsol;* Heure Avancee du Pacifique	North America */ return "-0700";}
158    if (TmZoneStr=="HAR"){&bsol;* Heure Avancee des Rocheuses	North America */ return "-0600";}
159    if (TmZoneStr=="HAST"){&bsol;* Hawaii-Aleutian Standard Time	North America */ return "-1000";}
160    if (TmZoneStr=="HAT"){&bsol;* Heure Avancee de Terre-Neuve	North America */ return "-0230";}
161    if (TmZoneStr=="HAY"){&bsol;* Heure Avancee du Yukon	North America */ return "-0800";}
162    if (TmZoneStr=="HNA"){&bsol;* Heure Normale de l'Atlantique	North America */ return "-0400";}
163    if (TmZoneStr=="HNC"){&bsol;* Heure Normale du Centre	North America */ return "-0600";}
164    if (TmZoneStr=="HNE"){&bsol;* Heure Normale de l'Est	North America */ return "-0500";}
165    if (TmZoneStr=="HNP"){&bsol;* Heure Normale du Pacifique	North America */ return "-0800";}
166    if (TmZoneStr=="HNR"){&bsol;* Heure Normale des Rocheuses	North America */ return "-0700";}
167    if (TmZoneStr=="HNT"){&bsol;* Heure Normale de Terre-Neuve	North America */ return "-0330";}
168    if (TmZoneStr=="HNY"){&bsol;* Heure Normale du Yukon	North America */ return "-0900";}
169    if (TmZoneStr=="I"){&bsol;* India Time Zone	Military */ return "+0900";}
170    if (TmZoneStr=="IST"){&bsol;* Irish Summer Time	Europe */ return "+0100";}
171    if (TmZoneStr=="K"){&bsol;* Kilo Time Zone	Military */ return "+1000";}
172    if (TmZoneStr=="L"){&bsol;* Lima Time Zone	Military */ return "+1100";}
173    if (TmZoneStr=="M"){&bsol;* Mike Time Zone	Military */ return "+1200";}
174    if (TmZoneStr=="MDT"){&bsol;* Mountain Daylight Time	North America */ return "-0600";}
175    if (TmZoneStr=="MESZ"){&bsol;* Mitteleuropeische Sommerzeit	Europe */ return "+0200";}
176    if (TmZoneStr=="MEZ"){&bsol;* Mitteleuropeische Zeit	Europe */ return "+0100";}
177    if (TmZoneStr=="MSD"){&bsol;* Moscow Daylight Time	Europe */ return "+0400";}
178    if (TmZoneStr=="MSK"){&bsol;* Moscow Standard Time	Europe */ return "+0300";}
179    if (TmZoneStr=="MST"){&bsol;* Mountain Standard Time	North America */ return "-0700";}
180    if (TmZoneStr=="N"){&bsol;* November Time Zone	Military */ return "-0100";}
181    if (TmZoneStr=="NDT"){&bsol;* Newfoundland Daylight Time	North America */ return "-0230";}
182    if (TmZoneStr=="NFT"){&bsol;* Norfolk (Island) Time	Australia */ return "+ 11:30";}
183    if (TmZoneStr=="NST"){&bsol;* Newfoundland Standard Time	North America */ return "-0330";}
184    if (TmZoneStr=="O"){&bsol;* Oscar Time Zone	Military */ return "-0200";}
185    if (TmZoneStr=="P"){&bsol;* Papa Time Zone	Military */ return "-0300";}
186    if (TmZoneStr=="PDT"){&bsol;* Pacific Daylight Time	North America */ return "-0700";}
187    if (TmZoneStr=="PST"){&bsol;* Pacific Standard Time	North America */ return "-0800";}
188    if (TmZoneStr=="Q"){&bsol;* Quebec Time Zone	Military */ return "-0400";}
189    if (TmZoneStr=="R"){&bsol;* Romeo Time Zone	Military */ return "-0500";}
190    if (TmZoneStr=="S"){&bsol;* Sierra Time Zone	Military */ return "-0600";}
191    if (TmZoneStr=="T"){&bsol;* Tango Time Zone	Military */ return "-0700";}
192    if (TmZoneStr=="U"){&bsol;* Uniform Time Zone	Military */ return "-0800";}
193    if (TmZoneStr=="UTC"){&bsol;* Coordinated Universal Time Europe */ return "+0000";}
194    if (TmZoneStr=="V"){&bsol;* Victor Time Zone	Military */ return "-0900";}
195    if (TmZoneStr=="W"){&bsol;* Whiskey Time Zone	Military */ return "-1000";}
196    if (TmZoneStr=="WDT"){&bsol;* Western Daylight Time	Australia */ return "+0900";}
197    if (TmZoneStr=="WEDT"){&bsol;* Western European Daylight Time	Europe */ return "+0100";}
198    if (TmZoneStr=="WEST"){&bsol;* Western European Summer Time	Europe */ return "+0100";}
199    if (TmZoneStr=="WET"){&bsol;* Western European Time	Europe */ return "+0000";}
200    if (TmZoneStr=="WST"){&bsol;* Western Summer Time	Australia */ return "+0900";}
201    if (TmZoneStr=="WST"){&bsol;* Western Standard Time	Australia */ return "+0800";}
202    if (TmZoneStr=="X"){&bsol;* X-ray Time Zone	Military */ return "-1100";}
203    if (TmZoneStr=="Y"){&bsol;* Yankee Time Zone	Military */ return "-1200";}
204    if (TmZoneStr=="Z"){&bsol;* Zulu Time Zone	Military */ return "+0000";}
205    return "-0000";
206  }
207  const int TTmInfo::SunN=1; const int TTmInfo::MonN=2;
208  const int TTmInfo::TueN=3; const int TTmInfo::WedN=4;
209  const int TTmInfo::ThuN=5; const int TTmInfo::FriN=6;
210  const int TTmInfo::SatN=7;
211  const int TTmInfo::JanN=1; const int TTmInfo::FebN=2;
212  const int TTmInfo::MarN=3; const int TTmInfo::AprN=4;
213  const int TTmInfo::MayN=5; const int TTmInfo::JunN=6;
214  const int TTmInfo::JulN=7; const int TTmInfo::AugN=8;
215  const int TTmInfo::SepN=9; const int TTmInfo::OctN=10;
216  const int TTmInfo::NovN=11; const int TTmInfo::DecN=12;
217  int TJulianDate::LastJulianDate=15821004; &bsol;* last day to use Julian calendar */
218  int TJulianDate::LastJulianDateN=2299160; &bsol;* jdn of same */
219  int TJulianDate::GetJulianDateN(int d, int m, int y){
220    IAssert(y != 0);
221    int julian = -1;
222    long jdn;
223    if (julian < 0){ &bsol;* set Julian flag if auto set */
224      julian = (((y * 100L) + m) * 100 + d  <=  LastJulianDate);}
225    if (y < 0){ &bsol;* adjust BC year */
226      y++;}
227    if (julian){
228      jdn = 367L * y - 7 * (y + 5001L + (m - 9) / 7) / 4
229       + 275 * m / 9 + d + 1729777L;
230    } else {
231      jdn = (long)(d - 32076)
232       + 1461L * (y + 4800L + (m - 14) / 12) / 4
233       + 367 * (m - 2 - (m - 14) / 12 * 12) / 12
234       - 3 * ((y + 4900L + (m - 14) / 12) / 100) / 4
235       + 1;            &bsol;* correction by rdg */
236    }
237    return (int) jdn;
238  }
239  void TJulianDate::GetCalendarDate(int jdn, int& dd, int& mm, int& yy){
240    int julian = -1;
241    long x, z, m, d, y;
242    long daysPer400Years = 146097L;
243    long fudgedDaysPer4000Years = 1460970L + 31;
244    if (julian < 0){ &bsol;* set Julian flag if auto set */
245      julian = (jdn <= LastJulianDateN);}
246    x = jdn + 68569L;
247    if (julian){
248      x+=38;
249      daysPer400Years = 146100L;
250      fudgedDaysPer4000Years = 1461000L + 1;
251    }
252    z = 4 * x / daysPer400Years;
253    x = x - (daysPer400Years * z + 3) / 4;
254    y = 4000 * (x + 1) / fudgedDaysPer4000Years;
255    x = x - 1461 * y / 4 + 31;
256    m = 80 * x / 2447;
257    d = x - 2447 * m / 80;
258    x = m / 11;
259    m = m + 2 - 12 * x;
260    y = 100 * (z - 49) + y + x;
261    yy = (int)y;
262    mm = (int)m;
263    dd = (int)d;
264    if (yy <= 0){ &bsol;* adjust BC years */
265     (yy)--;}
266  }
267  bool TSecTm::GetTmSec(const int& YearN, const int& MonthN, const int& DayN, const int& HourN, const int& MinN, const int& SecN, uint& AbsSec) {
268    AbsSec = 0;
269    struct tm Tm;
270    Tm.tm_year=YearN-1900; Tm.tm_mon=MonthN-1; Tm.tm_mday=DayN;
271    Tm.tm_hour=HourN; Tm.tm_min=MinN; Tm.tm_sec=SecN;
272    Tm.tm_wday=1;  Tm.tm_yday=1;
273    Tm.tm_isdst=-1;
274    return TSecTm::GetTmSec(Tm, AbsSec);
275  }
276  time_t TSecTm::MkGmTime(struct tm *t) {
277    static const int m_to_d[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
278    short month, year;
279    time_t result;
280    month = t->tm_mon;
281    year = t->tm_year + month / 12 + 1900;
282    month %= 12;
283    if (month < 0) {
284      year -= 1;
285      month += 12; }
286    result = (year - 1970) * 365 + (year - 1969) / 4 + m_to_d[month];
287    result = (year - 1970) * 365 + m_to_d[month];
288    if (month <= 1) { year -= 1; }
289    result += (year - 1968) / 4;
290    result -= (year - 1900) / 100;
291    result += (year - 1600) / 400;
292    result += t->tm_mday;
293    result -= 1;
294    result *= 24;
295    result += t->tm_hour;
296    result *= 60;
297    result += t->tm_min;
298    result *= 60;
299    result += t->tm_sec;
300    return result;
301  }
302  bool TSecTm::GetTmSec(struct tm& Tm, uint& AbsSec) {
303    const time_t GmtTime = MkGmTime(&Tm);
304    EAssertR(uint(GmtTime) < TUInt::Mx,
305      TStr::Fmt("Time out of range: %d/%d/%d %02d:%02d:%02d",
306      Tm.tm_year, Tm.tm_mon, Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec).CStr());
307    AbsSec = uint(GmtTime);
308    return GmtTime >= 0;
309  }
310  bool TSecTm::GetTmStruct(const uint& AbsSec, struct tm& Tm) {
311    const time_t TimeT = time_t(AbsSec);
312    #if defined(GLib_MSC)
313    return _gmtime64_s(&Tm, &TimeT) == 0;
314    #elif defined(GLib_BCB)
315    Tm=*gmtime(&TimeT); return true;
316    #else
317    return gmtime_r(&TimeT, &Tm) != NULL;
318    #endif
319  }
320  TSecTm::TSecTm(const int& YearN, const int& MonthN, const int& DayN,
321   const int& HourN, const int& MinN, const int& SecN) : AbsSecs(TUInt::Mx){
322    GetTmSec(YearN, MonthN, DayN, HourN, MinN, SecN, AbsSecs.Val);
323  }
324  TSecTm::TSecTm(const TTm& Tm): AbsSecs(
325   TSecTm(Tm.GetYear(), Tm.GetMonth(), Tm.GetDay(), Tm.GetHour(),
326     Tm.GetMin(), Tm.GetSec()).GetAbsSecs()) { }
327  TSecTm::TSecTm(const PXmlTok& XmlTok) {
328    const int Year = XmlTok->GetIntArgVal("Year");
329    const int Month = XmlTok->GetIntArgVal("Month");
330    const int Day = XmlTok->GetIntArgVal("Day");
331    const int Hour = XmlTok->GetIntArgVal("Hour");
332    const int Min = XmlTok->GetIntArgVal("Min");
333    const int Sec = XmlTok->GetIntArgVal("Sec");
334    AbsSecs = TSecTm(Year, Month, Day, Hour, Min, Sec).GetAbsSecs();
335  }
336  PXmlTok TSecTm::GetXmlTok() const {
337    PXmlTok NodeTok = TXmlTok::New("NodeTime");
338    NodeTok->AddArg("Year", GetYearN());
339    NodeTok->AddArg("Month", GetMonthN());
340    NodeTok->AddArg("Day", GetDayN());
341    NodeTok->AddArg("Hour", GetHourN());
342    NodeTok->AddArg("Min", GetMinN());
343    NodeTok->AddArg("Sec", GetSecN());
344    return NodeTok;
345  }
346  TStr TSecTm::GetStr(const TLoc& Loc) const {
347    if (IsDef()) {
348      struct tm Tm;
349      IAssert(GetTmStruct(AbsSecs(), Tm));
350      return TStr::Fmt("%s %s %d %02d:%02d:%02d %d",
351        TTmInfo::GetDayOfWeekNm(Tm.tm_wday + 1, Loc).CStr(),
352        TTmInfo::GetMonthNm(Tm.tm_mon + 1, Loc).CStr(),
353        Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec, Tm.tm_year+1900);
354    } else {
355      return "Undef";
356    }
357  }
358  TStr TSecTm::GetStr(const TTmUnit& TmUnit) const {
359    if (TmUnit == tmuYear) {
360      return TInt::GetStr(GetYearN()); }
361    else if (TmUnit == tmuMonth) {
362      return TStr::Fmt("%04d-%02d", GetYearN(), GetMonthN()); }
363    else if (TmUnit == tmuDay) {
364      return TStr::Fmt("%04d-%02d-%02d", GetYearN(), GetMonthN(), GetDayN()); }
365    else {
366      return TStr::Fmt("%04d-%02d-%02d %02d:%02d:%02d",
367        GetYearN(), GetMonthN(), GetDayN(), GetHourN(), GetMinN(), GetSecN());
368    }
369  }
370  TStr TSecTm::GetDtStr(const TLoc& Loc) const {
371    if (IsDef()){
372      struct tm Tm;
373      IAssert(GetTmStruct(AbsSecs(), Tm));
374      return TStr::Fmt("%s %s %d %d",
375        TTmInfo::GetDayOfWeekNm(Tm.tm_wday + 1, Loc).CStr(),
376        TTmInfo::GetMonthNm(Tm.tm_mon + 1, Loc).CStr(), Tm.tm_year+1900);
377    } else {
378      return "Undef";
379    }
380  }
381  TStr TSecTm::GetDtMdyStr() const {
382    struct tm Tm;
383    IAssert(GetTmStruct(AbsSecs(), Tm));
384    return TStr::Fmt("%02d/%02d%/%04d", Tm.tm_mon+1, Tm.tm_mday, Tm.tm_year+1900);
385  }
386  TStr TSecTm::GetDtYmdStr() const {
387    struct tm Tm;
388    IAssert(GetTmStruct(AbsSecs(), Tm));
389    return TStr::Fmt("%04d-%02d-%02d", Tm.tm_year+1900, Tm.tm_mon+1, Tm.tm_mday);
390  }
391  TStr TSecTm::GetYmdTmStr() const {
392    struct tm Tm;
393    IAssert(GetTmStruct(AbsSecs(), Tm));
394    return TStr::Fmt("%04d-%02d-%02d %02d:%02d:%02d", Tm.tm_year+1900, Tm.tm_mon+1, Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec);
395  }
396  TStr TSecTm::GetYmdTmStr2() const {
397    struct tm Tm;
398    IAssert(GetTmStruct(AbsSecs(), Tm));
399    return TStr::Fmt("%04d-%02d-%02d-%02d:%02d:%02d", Tm.tm_year+1900, Tm.tm_mon+1, Tm.tm_mday, Tm.tm_hour, Tm.tm_min, Tm.tm_sec);
400  }
401  TStr TSecTm::GetTmStr() const {
402    if (IsDef()){
403      struct tm Tm;
404      IAssert(GetTmStruct(AbsSecs(), Tm));
405      return TStr::Fmt("%02d:%02d:%02d", Tm.tm_hour, Tm.tm_min, Tm.tm_sec);
406    } else {
407      return "Undef";
408    }
409  }
410  TStr TSecTm::GetTmMinStr() const {
411    if (IsDef()){
412      struct tm Tm;
413      IAssert(GetTmStruct(AbsSecs(), Tm));
414      return TStr::Fmt("%02d:%02d", Tm.tm_min, Tm.tm_sec);
415    } else {
416      return "Undef";
417    }
418  }
419  TStr TSecTm::GetDtTmSortStr() const {
420    return
421      TInt::GetStr(GetYearN(), "%04d")+"/"+
422      TInt::GetStr(GetMonthN(), "%02d")+"/"+
423      TInt::GetStr(GetDayN(), "%02d")+" "+
424      TInt::GetStr(GetHourN(), "%02d")+":"+
425      TInt::GetStr(GetMinN(), "%02d")+":"+
426      TInt::GetStr(GetSecN(), "%02d");
427  }
428  TStr TSecTm::GetDtTmSortFNmStr() const {
429    return
430      TInt::GetStr(GetYearN(), "%04d")+"-"+
431      TInt::GetStr(GetMonthN(), "%02d")+"-"+
432      TInt::GetStr(GetDayN(), "%02d")+"_"+
433      TInt::GetStr(GetHourN(), "%02d")+"-"+
434      TInt::GetStr(GetMinN(), "%02d")+"-"+
435      TInt::GetStr(GetSecN(), "%02d");
436  }
437  int TSecTm::GetYearN() const {
438    struct tm Tm;
439    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
440    return Tm.tm_year+1900;
441  }
442  int TSecTm::GetMonthN() const {
443    struct tm Tm;
444    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
445    return Tm.tm_mon+1;
446  }
447  TStr TSecTm::GetMonthNm(const TLoc& Loc) const {
448    struct tm Tm;
449    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
450    return TTmInfo::GetMonthNm(Tm.tm_mon+1, Loc);
451  }
452  int TSecTm::GetDayN() const {
453    struct tm Tm;
454    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
455    return Tm.tm_mday;
456  }
457  int TSecTm::GetDayOfWeekN() const {
458    struct tm Tm;
459    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
460    return Tm.tm_wday + 1;
461  }
462  TStr TSecTm::GetDayOfWeekNm(const TLoc& Loc) const {
463    struct tm Tm;
464    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
465    return TTmInfo::GetDayOfWeekNm(Tm.tm_wday+1, Loc);
466  }
467  int TSecTm::GetHourN() const {
468    struct tm Tm;
469    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
470    return Tm.tm_hour;
471  }
472  int TSecTm::GetMinN() const {
473    struct tm Tm;
474    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
475    return Tm.tm_min;
476  }
477  int TSecTm::GetSecN() const {
478    struct tm Tm;
479    IAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
480    return Tm.tm_sec;
481  }
482  void TSecTm::GetComps(int& Year, int& Month, int& Day, int& Hour, int& Min, int& Sec) const {
483    struct tm Tm;
484    EAssert(IsDef() && GetTmStruct(AbsSecs(), Tm));
485    Year = Tm.tm_year+1900;
486    Month = Tm.tm_mon+1;
487    Day = Tm.tm_mday;
488    Hour = Tm.tm_hour;
489    Min = Tm.tm_min;
490    Sec = Tm.tm_sec;
491  }
492  TSecTm TSecTm::Round(const TTmUnit& TmUnit) const {
493    if (TmUnit == tmu1Sec) { return *this; }
494    struct tm Time;
495    IAssert(IsDef() && GetTmStruct(AbsSecs(), Time));
496    switch (TmUnit) {
497      case tmu1Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, Time.tm_min, 0);
498      case tmu10Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 10*(Time.tm_min/10), 0);
499      case tmu15Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 15*(Time.tm_min/15), 0);
500      case tmu30Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 30*(Time.tm_min/30), 0);
501      case tmu1Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 0, 0);
502      case tmu2Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 2*(Time.tm_hour/2), 0, 0);
503      case tmu4Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 4*(Time.tm_hour/4), 0, 0);
504      case tmu6Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 6*(Time.tm_hour/6), 0, 0);
505      case tmu12Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 12*(Time.tm_hour/12), 0, 0);
506      case tmuDay : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 0, 0, 0);
507      case tmuMonth : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, 1, 0, 0, 0);
508      case tmuYear : return TSecTm(Time.tm_year+1900, 1, 1, 0, 0, 0);
509      case tmuWeek : { int dd=1, mm=1, yy=1;
510        const int Day = TJulianDate::GetJulianDateN(Time.tm_mday, Time.tm_mon+1, 1900+Time.tm_year);
511        TJulianDate::GetCalendarDate(3+7*(Day/7), dd, mm, yy);  return TSecTm(yy, mm, dd, 0, 0, 0); }
512      default : Fail;
513    }
514    return TSecTm();
515  }
516  uint TSecTm::GetInUnits(const TTmUnit& TmUnit) const {
517    static const int DayZero = TJulianDate::GetJulianDateN(1, 1, 1970);
518    if (TmUnit == tmu1Sec) { return AbsSecs; }
519    struct tm Time;
520    IAssert(IsDef() && GetTmStruct(AbsSecs(), Time));
521    switch (TmUnit) {
522      case tmu1Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, Time.tm_min, 0).GetAbsSecs()/60;
523      case tmu10Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 10*(Time.tm_min/10), 0).GetAbsSecs()/(10*60);
524      case tmu15Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 15*(Time.tm_min/15), 0).GetAbsSecs()/(15*60);
525      case tmu30Min : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 30*(Time.tm_min/30), 0).GetAbsSecs()/(30*60);
526      case tmu1Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, Time.tm_hour, 0, 0).GetAbsSecs()/3600;
527      case tmu2Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 2*(Time.tm_hour/2), 0, 0).GetAbsSecs()/(2*3600);
528      case tmu4Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 4*(Time.tm_hour/4), 0, 0).GetAbsSecs()/(4*3600);
529      case tmu6Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 6*(Time.tm_hour/6), 0, 0).GetAbsSecs()/(6*3600);
530      case tmu12Hour : return TSecTm(Time.tm_year+1900, Time.tm_mon+1, Time.tm_mday, 12*(Time.tm_hour/12), 0, 0).GetAbsSecs()/(12*3600);
531      case tmuDay : return TJulianDate::GetJulianDateN(Time.tm_mday, Time.tm_mon+1, 1900+Time.tm_year) - DayZero;
532      case tmuWeek : return (TJulianDate::GetJulianDateN(Time.tm_mday, Time.tm_mon+1, 1900+Time.tm_year)-DayZero)/7;
533      case tmuMonth : return 12*(Time.tm_year-70)+Time.tm_mon+1;
534      case tmuYear : return Time.tm_year+1900;
535      default : Fail;
536    }
537    return TUInt::Mx;
538  }
539  TStr TSecTm::GetDayPart() const {
540    const int Hour = GetHourN();
541    if (0 <= Hour && Hour < 6) { return "Night"; }
542    else if (6 <= Hour && Hour < 12) { return "Morning"; }
543    else if (12 <= Hour && Hour < 18) { return "Afternoon"; }
544    else if (18 <= Hour && Hour < 24) { return "Evening"; }
545    return "";
546  }
547  uint TSecTm::GetDSecs(const TSecTm& SecTm1, const TSecTm& SecTm2){
548    IAssert(SecTm1.IsDef()&&SecTm2.IsDef());
549    const time_t Time1= time_t(SecTm1.AbsSecs());
550    const time_t Time2= time_t(SecTm2.AbsSecs());
551    return uint(difftime(Time2, Time1));
552  }
553  TSecTm TSecTm::GetZeroWeekTm(){
554    TSecTm ZeroWeekTm=GetZeroTm();
555    while (ZeroWeekTm.GetDayOfWeekN()!=TTmInfo::MonN){
556      ZeroWeekTm.AddDays(1);}
557    return ZeroWeekTm;
558  }
559  TSecTm TSecTm::GetCurTm(){
560    const time_t TmSec = time(NULL);
561    struct tm LocTm;
562    uint AbsSec = TUInt::Mx;
563    #if defined(GLib_MSN)
564    localtime_s(&LocTm, &TmSec);
565    #elif defined(GLib_BCB)
566    LocTm = *localtime(&TmSec);
567    #else
568    LocTm = *localtime(&TmSec);
569    #endif
570    IAssert(TSecTm::GetTmSec(LocTm, AbsSec));
571    return TSecTm(AbsSec);
572  }
573  TSecTm TSecTm::GetDtTmFromHmsStr(const TStr& HmsStr){
574    int HmsStrLen=HmsStr.Len();
575    TChA ChA; int ChN=0;
576    while ((ChN<HmsStrLen)&&(HmsStr[ChN]!=':')){ChA+=HmsStr[ChN]; ChN++;}
577    TStr HourStr=ChA;
578    ChA.Clr(); ChN++;
579    while ((ChN<HmsStrLen)&&(HmsStr[ChN]!=':')){ChA+=HmsStr[ChN]; ChN++;}
580    TStr MinStr=ChA;
581    ChA.Clr(); ChN++;
582    while (ChN<HmsStrLen){ChA+=HmsStr[ChN]; ChN++;}
583    TStr SecStr=ChA;
584    int HourN=HourStr.GetInt();
585    int MinN=MinStr.GetInt();
586    int SecN=SecStr.GetInt();
587    TSecTm Tm=TSecTm::GetZeroTm();
588    Tm.AddHours(HourN);
589    Tm.AddMins(MinN);
590    Tm.AddSecs(SecN);
591    return Tm;
592  }
593  TSecTm TSecTm::GetDtTmFromMdyStr(const TStr& MdyStr){
594    int MdyStrLen=MdyStr.Len();
595    TChA ChA; int ChN=0;
596    while ((ChN<MdyStrLen)&&(MdyStr[ChN]!='/')){
597      ChA+=MdyStr[ChN]; ChN++;}
598    TStr MonthStr=ChA;
599    ChA.Clr(); ChN++;
600    while ((ChN<MdyStrLen)&&(MdyStr[ChN]!='/')){
601      ChA+=MdyStr[ChN]; ChN++;}
602    TStr DayStr=ChA;
603    ChA.Clr(); ChN++;
604    while (ChN<MdyStrLen){
605      ChA+=MdyStr[ChN]; ChN++;}
606    TStr YearStr=ChA;
607    int MonthN=MonthStr.GetInt();
608    int DayN=DayStr.GetInt();
609    int YearN=YearStr.GetInt();
610    if (YearN<1000){
611      if (YearN<70){YearN+=2000;} else {YearN+=1900;}}
612    return GetDtTm(YearN, MonthN, DayN);
613  }
614  TSecTm TSecTm::GetDtTmFromDmyStr(const TStr& DmyStr){
615    int DmyStrLen=DmyStr.Len();
616    TChA ChA; int ChN=0;
617    while ((ChN<DmyStrLen)&&(DmyStr[ChN]!='/')&&(DmyStr[ChN]!='-')){
618      ChA+=DmyStr[ChN]; ChN++;}
619    TStr DayStr=ChA;
620    ChA.Clr(); ChN++;
621    while ((ChN<DmyStrLen)&&(DmyStr[ChN]!='/')&&(DmyStr[ChN]!='-')){
622      ChA+=DmyStr[ChN]; ChN++;}
623    TStr MonthStr=ChA;
624    ChA.Clr(); ChN++;
625    while (ChN<DmyStrLen){
626      ChA+=DmyStr[ChN]; ChN++;}
627    TStr YearStr=ChA;
628    int DayN=DayStr.GetInt(-1);
629    int MonthN=MonthStr.GetInt(-1);
630    int YearN=YearStr.GetInt(-1);
631    if (MonthN == -1){
632      MonthN = TTmInfo::GetMonthN(MonthStr.ToCap()); }
633    if ((DayN==-1)||(MonthN==-1)||(YearN==-1)){
634      return TSecTm();
635    } else {
636      if (YearN<1000){
637        if (YearN<70){YearN+=2000;} else {YearN+=1900;}}
638      return GetDtTm(YearN, MonthN, DayN);
639    }
640    return TSecTm();
641  }
642  TSecTm TSecTm::GetDtTmFromMdyHmsPmStr(const TStr& MdyHmsPmStr,
643   const char& DateSepCh, const char& TimeSepCh){
644    int MdyHmsPmStrLen=MdyHmsPmStr.Len();
645    TChA ChA; int ChN=0;
646    while ((ChN<MdyHmsPmStrLen)&&(MdyHmsPmStr[ChN]!=DateSepCh)){
647      ChA+=MdyHmsPmStr[ChN]; ChN++;}
648    TStr MonthStr=ChA;
649    ChA.Clr(); ChN++;
650    while ((ChN<MdyHmsPmStrLen)&&(MdyHmsPmStr[ChN]!=DateSepCh)){
651      ChA+=MdyHmsPmStr[ChN]; ChN++;}
652    TStr DayStr=ChA;
653    ChA.Clr(); ChN++;
654    while ((ChN<MdyHmsPmStrLen)&&(MdyHmsPmStr[ChN]!=' ')){
655      ChA+=MdyHmsPmStr[ChN]; ChN++;}
656    TStr YearStr=ChA;
657    ChA.Clr(); ChN++;
658    while ((ChN<MdyHmsPmStrLen)&&(MdyHmsPmStr[ChN]!=TimeSepCh)){
659      ChA+=MdyHmsPmStr[ChN]; ChN++;}
660    TStr HourStr=ChA;
661    ChA.Clr(); ChN++;
662    while ((ChN<MdyHmsPmStrLen)&&(MdyHmsPmStr[ChN]!=TimeSepCh)){
663      ChA+=MdyHmsPmStr[ChN]; ChN++;}
664    TStr MinStr=ChA;
665    ChA.Clr(); ChN++;
666    while ((ChN<MdyHmsPmStrLen)&&(MdyHmsPmStr[ChN]!=' ')){
667      ChA+=MdyHmsPmStr[ChN]; ChN++;}
668    TStr SecStr=ChA;
669    ChA.Clr(); ChN++;
670    while (ChN<MdyHmsPmStrLen){
671      ChA+=MdyHmsPmStr[ChN]; ChN++;}
672    TStr AmPmStr=ChA;
673    int MonthN=MonthStr.GetInt();
674    int DayN=DayStr.GetInt();
675    int YearN=YearStr.GetInt();
676    int HourN; int MinN; int SecN;
677    if (HourStr.IsInt()){
678      HourN=HourStr.GetInt();
679      MinN=MinStr.GetInt();
680      SecN=SecStr.GetInt();
681      if (AmPmStr=="AM"){} else if (AmPmStr=="PM"){HourN+=12;} else {Fail;}
682    } else {
683      HourN=0; MinN=0; SecN=0;
684    }
685    TSecTm Tm=TSecTm::GetDtTm(YearN, MonthN, DayN);
686    Tm.AddHours(HourN);
687    Tm.AddMins(MinN);
688    Tm.AddSecs(SecN);
689    return Tm;
690  }
691  TSecTm TSecTm::GetDtTmFromYmdHmsStr(const TStr& YmdHmsPmStr,
692   const char& DateSepCh, const char& TimeSepCh){
693    int YmdHmsPmStrLen=YmdHmsPmStr.Len();
694    TChA ChA; int ChN=0;
695    while ((ChN<YmdHmsPmStrLen)&&(YmdHmsPmStr[ChN]!=DateSepCh)){
696      ChA+=YmdHmsPmStr[ChN]; ChN++;}
697    TStr YearStr=ChA;
698    ChA.Clr(); ChN++;
699    while ((ChN<YmdHmsPmStrLen)&&(YmdHmsPmStr[ChN]!=DateSepCh)){
700      ChA+=YmdHmsPmStr[ChN]; ChN++;}
701    TStr MonthStr=ChA;
702    ChA.Clr(); ChN++;
703    while ((ChN<YmdHmsPmStrLen)&&(YmdHmsPmStr[ChN]!=' ')){
704      ChA+=YmdHmsPmStr[ChN]; ChN++;}
705    TStr DayStr=ChA;
706    ChA.Clr(); ChN++;
707    while ((ChN<YmdHmsPmStrLen)&&(YmdHmsPmStr[ChN]!=TimeSepCh)){
708      ChA+=YmdHmsPmStr[ChN]; ChN++;}
709    TStr HourStr=ChA;
710    ChA.Clr(); ChN++;
711    while ((ChN<YmdHmsPmStrLen)&&(YmdHmsPmStr[ChN]!=TimeSepCh)){
712      ChA+=YmdHmsPmStr[ChN]; ChN++;}
713    TStr MinStr=ChA;
714    ChA.Clr(); ChN++;
715    while (ChN<YmdHmsPmStrLen){
716      ChA+=YmdHmsPmStr[ChN]; ChN++;}
717    TStr SecStr=ChA;
718    int MonthN=MonthStr.GetInt();
719    int DayN=DayStr.GetInt();
720    int YearN=YearStr.GetInt();
721    int HourN; int MinN; int SecN;
722    if (HourStr.IsInt()){
723      HourN=HourStr.GetInt();
724      MinN=MinStr.GetInt();
725      SecN=SecStr.GetInt();
726    } else {
727      HourN=0; MinN=0; SecN=0;
728    }
729    TSecTm Tm=TSecTm::GetDtTm(YearN, MonthN, DayN);
730    Tm.AddHours(HourN);
731    Tm.AddMins(MinN);
732    Tm.AddSecs(SecN);
733    return Tm;
734  }
735  TSecTm TSecTm::GetDtTmFromStr(const TChA& YmdHmsPmStr, const int& YearId, const int& MonId,
736   const int& DayId, const int& HourId, const int& MinId, const int& SecId) {
737    TChA Tmp = YmdHmsPmStr;
738    TVec<char *> FldV;
739    for (char *c = (char *) Tmp.CStr(); *c; c++) {
740      if (TCh::IsNum(*c)) {
741        FldV.Add(c);
742        while (TCh::IsNum(*c)) { c++; }
743        c--;
744      } else { *c = 0; }
745    }
746    const int Y = atoi(FldV[YearId]);
747    const int M = atoi(FldV[MonId]);
748    const int D = atoi(FldV[DayId]);
749    const int H = atoi(FldV[HourId]);
750    const int m = atoi(FldV[MinId]);
751    const int S = atoi(FldV[SecId]);
752    IAssert(Y>0 && M>0 && D>0 && M<13 && D<32);
753    IAssert(H>=0 && H<24 && m>=0 && m<60 && S>=0 && S<60);
754    return TSecTm(Y,M,D,H,m,S);
755  }
756  TSecTm TSecTm::GetDtTm(const int& YearN, const int& MonthN, const int& DayN){
757    uint AbsSecs;
758    TSecTm::GetTmSec(YearN, MonthN, DayN, 0, 0, 0, AbsSecs);
759    return TSecTm(AbsSecs);
760  }
761  TSecTm TSecTm::GetDtTm(const TSecTm& Tm){
762    int DaySecs=Tm.GetHourN()*3600+Tm.GetMinN()*60+Tm.GetSecN();
763    TSecTm DtTm(Tm.AbsSecs-DaySecs);
764    return DtTm;
765  }
766  TSecTm TSecTm::LoadTxt(TILx& Lx){
767    return TSecTm(Lx.GetInt());
768  }
769  void TSecTm::SaveTxt(TOLx& Lx) const {
770    IAssert(int(AbsSecs) < TInt::Mx);
771    Lx.PutInt((int)AbsSecs);
772  }
773  TStr TTm::GetStr(const bool& MSecP) const {
774    TChA ChA;
775    ChA+=TInt::GetStr(Year, "%04d"); ChA+='-';
776    ChA+=TInt::GetStr(Month, "%02d"); ChA+='-';
777    ChA+=TInt::GetStr(Day, "%02d"); ChA+=' ';
778    ChA+=TInt::GetStr(Hour, "%02d"); ChA+=':';
779    ChA+=TInt::GetStr(Min, "%02d"); ChA+=':';
780    ChA+=TInt::GetStr(Sec, "%02d");
781    if (MSecP){ChA+='.'; ChA+=TInt::GetStr(MSec, "%03d");}
782    return ChA;
783  }
784  TStr TTm::GetYMDDashStr() const {
785    TChA ChA;
786    ChA+=TInt::GetStr(Year, "%04d");
787    ChA+='-'; ChA+=TInt::GetStr(Month, "%02d");
788    ChA+='-'; ChA+=TInt::GetStr(Day, "%02d");
789    return ChA;
790  }
791  TStr TTm::GetHMSTColonDotStr(const bool& FullP, const bool& MSecP) const {
792    TChA ChA;
793    ChA+=TInt::GetStr(Hour, "%02d");
794    ChA+=':'; ChA+=TInt::GetStr(Min, "%02d");
795    if (FullP||((Sec!=0)||(MSec!=0))){
796      ChA+=':'; ChA+=TInt::GetStr(Sec, "%02d");
797      if ((MSecP)&&(FullP||(MSec!=0))){
798        ChA+='.'; ChA+=TInt::GetStr(MSec, "%d");
799      }
800    }
801    return ChA;
802  }
803  TStr TTm::GetIdStr() const {
804    TChA ChA;
805    ChA+=TInt::GetStr(Year%100, "%02d");
806    ChA+=TInt::GetStr(Month, "%02d");
807    ChA+=TInt::GetStr(Day, "%02d");
808    ChA+=TInt::GetStr(Hour, "%02d");
809    ChA+=TInt::GetStr(Min, "%02d");
810    ChA+=TInt::GetStr(Sec, "%02d");
811    ChA+=TInt::GetStr(MSec, "%03d");
812    return ChA;
813  }
814  void TTm::AddTime(const int& Hours,
815   const int& Mins, const int& Secs, const int& MSecs){
816    uint64 TmMSecs=TTm::GetMSecsFromTm(*this);
817    TmMSecs+=(uint64(Hours)*uint64(3600)*uint64(1000));
818    TmMSecs+=(uint64(Mins)*uint64(60)*uint64(1000));
819    TmMSecs+=(uint64(Secs)*uint64(1000));
820    TmMSecs+=uint64(MSecs);
821    *this=GetTmFromMSecs(TmMSecs);
822  }
823  void TTm::SubTime(const int& Hours,
824   const int& Mins, const int& Secs, const int& MSecs){
825    uint64 TmMSecs=TTm::GetMSecsFromTm(*this);
826    TmMSecs-=(uint64(Hours)*uint64(3600)*uint64(1000));
827    TmMSecs-=(uint64(Mins)*uint64(60)*uint64(1000));
828    TmMSecs-=(uint64(Secs)*uint64(1000));
829    TmMSecs-=(uint64(MSecs));
830    *this=GetTmFromMSecs(TmMSecs);
831  }
832  TTm TTm::GetCurUniTm(){
833    return TSysTm::GetCurUniTm();
834  }
835  TTm TTm::GetUniqueCurUniTm(){
836    static TTm LastUniqueTm=TSysTm::GetCurUniTm();
837    TTm CurUniqueTm=TSysTm::GetCurUniTm();
838    if (CurUniqueTm<LastUniqueTm){CurUniqueTm=LastUniqueTm;}
839    if (CurUniqueTm==LastUniqueTm){CurUniqueTm.AddTime(0, 0, 0, 1);}
840    LastUniqueTm=CurUniqueTm;
841    return CurUniqueTm;
842  }
843  TTm TTm::GetUniqueCurUniTm(const int& UniqueSpaces, const int& UniqueSpaceN){
844    static uint64 LastMUniqueTmMSecs=TSysTm::GetCurUniMSecs();
845    Assert(UniqueSpaces>=1&&UniqueSpaceN>=0&&UniqueSpaceN<UniqueSpaces);
846    uint64 CurUniqueTmMSecs=TSysTm::GetCurUniMSecs();
847    if (CurUniqueTmMSecs<LastMUniqueTmMSecs){CurUniqueTmMSecs=LastMUniqueTmMSecs;}
848    CurUniqueTmMSecs-=CurUniqueTmMSecs%UniqueSpaces; CurUniqueTmMSecs+=UniqueSpaceN;
849    if (CurUniqueTmMSecs<=LastMUniqueTmMSecs){
850      CurUniqueTmMSecs+=UniqueSpaces;
851    }
852    LastMUniqueTmMSecs=CurUniqueTmMSecs;
853    return GetTmFromMSecs(CurUniqueTmMSecs);
854  }
855  TTm TTm::GetCurLocTm(){
856    return TSysTm::GetCurLocTm();
857  }
858  uint64 TTm::GetCurUniMSecs(){
859    return TSysTm::GetCurUniMSecs();
860  }
861  uint64 TTm::GetCurLocMSecs(){
<span onclick='openModal()' class='match'>862    return TSysTm::GetCurLocMSecs();
863  }
864  uint64 TTm::GetMSecsFromTm(const TTm& Tm){
865    return TSysTm::GetMSecsFromTm(Tm);
866  }
867  TTm TTm::GetTmFromMSecs(const uint64& MSecs){
868    return TSysTm::GetTmFromMSecs(MSecs);
869  }
870  uint TTm::GetMSecsFromOsStart(){
</span>871    return TSysTm::GetMSecsFromOsStart();
872  }
873  uint64 TTm::GetPerfTimerFq(){
874    return TSysTm::GetPerfTimerFq();
875  }
876  uint64 TTm::GetPerfTimerTicks(){
877    return TSysTm::GetPerfTimerTicks();
878  }
879  void TTm::GetDiff(const TTm& Tm1, const TTm& Tm2, int& Days, 
880  	  int& Hours, int& Mins, int& Secs, int& MSecs) {
881  	const uint64 DiffMSecs = TTm::GetDiffMSecs(Tm1, Tm2);
882  	const uint64 DiffSecs = DiffMSecs / 1000;
883  	const uint64 DiffMins = DiffSecs / 60;
884  	const uint64 DiffHours = DiffMins / 60;	
885  	MSecs = int(DiffMSecs % 1000);
886  	Secs = int(DiffSecs % 60);
887  	Mins = int(DiffMins % 60);
888  	Hours = int(DiffHours % 24);
889  	Days = int((int)DiffHours / 24);
890  }
891  uint64 TTm::GetDiffMSecs(const TTm& Tm1, const TTm& Tm2){
892    uint64 Tm1MSecs=GetMSecsFromTm(Tm1);
893    uint64 Tm2MSecs=GetMSecsFromTm(Tm2);
894    if (Tm1MSecs>Tm2MSecs){
895      return Tm1MSecs-Tm2MSecs;
896    } else {
897      return Tm2MSecs-Tm1MSecs;
898    }
899  }
900  TTm TTm::GetLocTmFromUniTm(const TTm& Tm){
901    return TSysTm::GetLocTmFromUniTm(Tm);
902  }
903  TTm TTm::GetUniTmFromLocTm(const TTm& Tm){
904    return TSysTm::GetUniTmFromLocTm(Tm);
905  }
906  TTm TTm::GetTmFromWebLogTimeStr(const TStr& TimeStr,
907   const char TimeSepCh, const char MSecSepCh){
908    int TimeStrLen=TimeStr.Len();
909    TChA ChA; int ChN=0;
910    while ((ChN<TimeStrLen)&&(TimeStr[ChN]!=TimeSepCh)){
911      ChA+=TimeStr[ChN]; ChN++;}
912    TStr HourStr=ChA;
913    ChA.Clr(); ChN++;
914    while ((ChN<TimeStrLen)&&(TimeStr[ChN]!=TimeSepCh)){
915      ChA+=TimeStr[ChN]; ChN++;}
916    TStr MinStr=ChA;
917    ChA.Clr(); ChN++;
918    while ((ChN<TimeStrLen)&&(TimeStr[ChN]!=MSecSepCh)){
919      ChA+=TimeStr[ChN]; ChN++;}
920    TStr SecStr=ChA;
921    ChA.Clr(); ChN++;
922    while (ChN<TimeStrLen){
923      ChA+=TimeStr[ChN]; ChN++;}
924    TStr MSecStr=ChA;
925    int HourN=HourStr.GetInt(0);
926    int MinN=MinStr.GetInt(0);
927    int SecN=SecStr.GetInt(0);
928    int MSecN=MSecStr.GetInt(0);
929    TTm Tm(-1, -1, -1, -1, HourN, MinN, SecN, MSecN);
930    return Tm;
931  }
932  TTm TTm::GetTmFromWebLogDateTimeStr(const TStr& DateTimeStr,
933   const char DateSepCh, const char TimeSepCh, const char MSecSepCh,
934   const char DateTimeSepCh){
935    int DateTimeStrLen=DateTimeStr.Len();
936    TChA ChA; int ChN=0;
937    while ((ChN<DateTimeStrLen)&&(DateTimeStr[ChN]!=DateSepCh)){
938      ChA+=DateTimeStr[ChN]; ChN++;}
939    TStr YearStr=ChA;
940    ChA.Clr(); ChN++;
941    while ((ChN<DateTimeStrLen)&&(DateTimeStr[ChN]!=DateSepCh)){
942      ChA+=DateTimeStr[ChN]; ChN++;}
943    TStr MonthStr=ChA;
944    ChA.Clr(); ChN++;
945    while ((ChN<DateTimeStrLen)&&(DateTimeStr[ChN]!=DateTimeSepCh)){
946      ChA+=DateTimeStr[ChN]; ChN++;}
947    TStr DayStr=ChA;
948    ChA.Clr(); ChN++;
949    while ((ChN<DateTimeStrLen)&&(DateTimeStr[ChN]!=TimeSepCh)){
950      ChA+=DateTimeStr[ChN]; ChN++;}
951    TStr HourStr=ChA;
952    ChA.Clr(); ChN++;
953    while ((ChN<DateTimeStrLen)&&(DateTimeStr[ChN]!=TimeSepCh)){
954      ChA+=DateTimeStr[ChN]; ChN++;}
955    TStr MinStr=ChA;
956    ChA.Clr(); ChN++;
957    while ((ChN<DateTimeStrLen)&&(DateTimeStr[ChN]!=MSecSepCh)){
958      ChA+=DateTimeStr[ChN]; ChN++;}
959    TStr SecStr=ChA;
960    ChA.Clr(); ChN++;
961    while (ChN<DateTimeStrLen){
962      ChA+=DateTimeStr[ChN]; ChN++;}
963    TStr MSecStr=ChA;
964    int YearN=YearStr.GetInt(-1);
965    int MonthN=MonthStr.GetInt(-1);
966    int DayN=DayStr.GetInt(-1);
967    int HourN=HourStr.GetInt(0);
968    int MinN=MinStr.GetInt(0);
969    int SecN=SecStr.GetInt(0);
970    int MSecN=MSecStr.GetInt(0);
971    TTm Tm;
972    if ((YearN!=-1)&&(MonthN!=-1)&&(DayN!=-1)){
973      Tm=TTm(YearN, MonthN, DayN, -1, HourN, MinN, SecN, MSecN);
974    }
975    return Tm;
976  }
977  TTm TTm::GetTmFromIdStr(const TStr& IdStr){
978    TChA IdChA=IdStr;
979    if (IdChA.Len()==14){
980      IdChA.Ins(0, "0");}
981    IAssert(IdChA.Len()==15);
982    for (int ChN=0; ChN<IdChA.Len(); ChN++){
983      IAssert(TCh::IsNum(IdChA[ChN]));}
984    int YearN=2000+(TStr(IdChA[0])+TStr(IdChA[1])).GetInt();
985    int MonthN=(TStr(IdChA[2])+TStr(IdChA[3])).GetInt();
986    int DayN=(TStr(IdChA[4])+TStr(IdChA[5])).GetInt();
987    int HourN=(TStr(IdChA[6])+TStr(IdChA[7])).GetInt();
988    int MinN=(TStr(IdChA[8])+TStr(IdChA[9])).GetInt();
989    int SecN=(TStr(IdChA[10])+TStr(IdChA[11])).GetInt();
990    int MSecN=(TStr(IdChA[12])+TStr(IdChA[13])+TStr(IdChA[14])).GetInt();
991    TTm Tm=TTm(YearN, MonthN, DayN, -1, HourN, MinN, SecN, MSecN);
992    return Tm;
993  }
994  uint TTm::GetDateTimeInt(const int& Year, const int& Month,
995        const int& Day, const int& Hour, const int& Min, const int& Sec) {
996  	return TSecTm(Year, Month, Day, Hour, Min, Sec).GetAbsSecs();
997  }
998  uint TTm::GetDateIntFromTm(const TTm& Tm) {
999      return Tm.IsDef() ? GetDateTimeInt(Tm.GetYear(), Tm.GetMonth(), Tm.GetDay()) : 0;
1000  }
1001  uint TTm::GetMonthIntFromTm(const TTm& Tm) {
1002      return Tm.IsDef() ? GetDateTimeInt(Tm.GetYear(), Tm.GetMonth()) : 0;
1003  }
1004  uint TTm::GetYearIntFromTm(const TTm& Tm) {
1005      return Tm.IsDef() ? GetDateTimeInt(Tm.GetYear()) : 0;
1006  }
1007  uint TTm::GetDateTimeIntFromTm(const TTm& Tm) {
1008      return Tm.IsDef() ? 
1009  		GetDateTimeInt(Tm.GetYear(), Tm.GetMonth(),
1010          Tm.GetDay(), Tm.GetHour(), Tm.GetMin(), Tm.GetSec()) : 0;
1011  }
1012  TTm TTm::GetTmFromDateTimeInt(const uint& DateTimeInt) {
1013  	if (DateTimeInt == 0) { return TTm(); }
1014  	return TTm(TSecTm(DateTimeInt));
1015  }
1016  TSecTm TTm::GetSecTmFromDateTimeInt(const uint& DateTimeInt) {
1017  	if (DateTimeInt == 0) { return TSecTm(); }
1018  	return TSecTm(DateTimeInt);
1019  }
1020  int TTmProfiler::AddTimer(const TStr& TimerNm) { 
1021  	MxNmLen = TInt::GetMx(MxNmLen, TimerNm.Len());
1022  	return TimerH.AddKey(TimerNm); 
1023  }
1024  void TTmProfiler::ResetAll() {
1025      int TimerId = GetTimerIdFFirst();
1026  	while (GetTimerIdFNext(TimerId)) {
1027  		ResetTimer(TimerId);
1028  	}
1029  }
1030  double TTmProfiler::GetTimerSumSec() const {
1031  	double Sum = 0.0;
1032      int TimerId = GetTimerIdFFirst();
1033  	while (GetTimerIdFNext(TimerId)) {
1034  		Sum += GetTimerSec(TimerId);
1035  	}
1036      return Sum;
1037  }
1038  double TTmProfiler::GetTimerSec(const int& TimerId) const {
1039      return TimerH[TimerId].GetSec();
1040  }
1041  void TTmProfiler::PrintReport(const TStr& ProfileNm) const {
1042      const double TimerSumSec = GetTimerSumSec();
1043  	printf("-- %s --\n", ProfileNm.CStr());
1044      printf("Sum: (%.2f sec):\n", TimerSumSec);
1045      int TimerId = GetTimerIdFFirst();
1046  	while (GetTimerIdFNext(TimerId)) {
1047          TStr TimerNm = GetTimerNm(TimerId);
1048          TimerNm = TStr::GetSpaceStr(TimerNm.Len() - MxNmLen) + TimerNm;
1049          if (TimerSumSec > 0.0) {
1050              const double TimerSec = GetTimerSec(TimerId);
1051              const double TimerPerc =  TimerSec / TimerSumSec * 100.0;
1052              printf(" %s: %.2fs [%.2f%%]\n", TimerNm.CStr(), TimerSec, TimerPerc);
1053          } else {
1054              printf(" %s: -\n", TimerNm.CStr());
1055          }
1056      }
1057  	printf("--\n");
1058  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-status.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tm.cpp</div>
                </div>
                <div class="column column_space"><pre><code>262    return Status(absl::StatusCode::kAborted, message);
263  }
264  Status AlreadyExistsError(absl::string_view message) {
265    return Status(absl::StatusCode::kAlreadyExists, message);
266  }
267  Status CancelledError(absl::string_view message) {
268    return Status(absl::StatusCode::kCancelled, message);
269  }
270  Status DataLossError(absl::string_view message) {
</pre></code></div>
                <div class="column column_space"><pre><code>862    return TSysTm::GetCurLocMSecs();
863  }
864  uint64 TTm::GetMSecsFromTm(const TTm& Tm){
865    return TSysTm::GetMSecsFromTm(Tm);
866  }
867  TTm TTm::GetTmFromMSecs(const uint64& MSecs){
868    return TSysTm::GetTmFromMSecs(MSecs);
869  }
870  uint TTm::GetMSecsFromOsStart(){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    