
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.204610951008646%, Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-equationdetect_test.cc</h3>
            <pre><code>1  #include "include_gunit.h"
2  #include "colpartitiongrid.h"
3  #include "equationdetect.h"
4  #include "tesseractclass.h"
5  #include <allheaders.h>
6  #include <memory>
7  #include <string>
8  #include <utility>
9  #define ENABLE_IdentifySpecialText_TEST 0
10  #if ENABLE_IdentifySpecialText_TEST
11  #  define EQU_TRAINEDDATA_NAME "equ"
12  #else
13  #  define EQU_TRAINEDDATA_NAME "equINTENTIONALLY_MISSING_FILE"
14  #endif
15  namespace tesseract {
16  class TestableEquationDetect : public EquationDetect {
17  public:
18    TestableEquationDetect(const char *tessdata, Tesseract *lang_tesseract)
19        : EquationDetect(tessdata, EQU_TRAINEDDATA_NAME) {
20      SetLangTesseract(lang_tesseract);
21    }
22    void AddMathDigitBlobs(const int math_blobs, const int digit_blobs, const int total_blobs,
23                           ColPartition *part) {
24      CHECK(part != nullptr);
25      CHECK_LE(math_blobs + digit_blobs, total_blobs);
26      int count = 0;
27      for (int i = 0; i < math_blobs; i++, count++) {
28        auto *blob = new BLOBNBOX();
29        blob->set_special_text_type(BSTT_MATH);
30        part->AddBox(blob);
31      }
32      for (int i = 0; i < digit_blobs; i++, count++) {
33        auto *blob = new BLOBNBOX();
34        blob->set_special_text_type(BSTT_DIGIT);
35        part->AddBox(blob);
36      }
37      for (int i = count; i < total_blobs; i++) {
38        auto *blob = new BLOBNBOX();
39        blob->set_special_text_type(BSTT_NONE);
40        part->AddBox(blob);
41      }
42    }
43    void SetPixBinary(Image pix) {
44      CHECK_EQ(1, pixGetDepth(pix));
45      *(lang_tesseract_->mutable_pix_binary()) = pix;
46    }
47    void RunIdentifySpecialText(BLOBNBOX *blob, const int height_th) {
48      IdentifySpecialText(blob, height_th);
49    }
50    BlobSpecialTextType RunEstimateTypeForUnichar(const char *val) {
51      const UNICHARSET &unicharset = lang_tesseract_->unicharset;
52      return EstimateTypeForUnichar(unicharset, unicharset.unichar_to_id(val));
53    }
54    EquationDetect::IndentType RunIsIndented(ColPartitionGrid *part_grid, ColPartition *part) {
55      this->part_grid_ = part_grid;
56      return IsIndented(part);
57    }
58    bool RunIsNearSmallNeighbor(const TBOX &seed_box, const TBOX &part_box) {
59      return IsNearSmallNeighbor(seed_box, part_box);
60    }
61    bool RunCheckSeedBlobsCount(ColPartition *part) {
62      return CheckSeedBlobsCount(part);
63    }
64    float RunComputeForegroundDensity(const TBOX &tbox) {
65      return ComputeForegroundDensity(tbox);
66    }
67    int RunCountAlignment(const std::vector<int> &sorted_vec, const int val) {
68      return CountAlignment(sorted_vec, val);
69    }
70    void RunSplitCPHorLite(ColPartition *part, std::vector<TBOX> *splitted_boxes) {
71      SplitCPHorLite(part, splitted_boxes);
72    }
73    void RunSplitCPHor(ColPartition *part, std::vector<ColPartition *> *parts_splitted) {
74      SplitCPHor(part, parts_splitted);
75    }
76    void TestComputeCPsSuperBBox(const TBOX &box, ColPartitionGrid *part_grid) {
77      CHECK(part_grid != nullptr);
78      part_grid_ = part_grid;
79      ComputeCPsSuperBBox();
80      EXPECT_TRUE(*cps_super_bbox_ == box);
81    }
82  };
83  class EquationFinderTest : public testing::Test {
84  protected:
85    std::unique_ptr<TestableEquationDetect> equation_det_;
86    std::unique_ptr<Tesseract> tesseract_;
87    std::string testdata_dir_;
88    void SetUp() override {
89      std::locale::global(std::locale(""));
90      tesseract_ = std::make_unique<Tesseract>();
91      tesseract_->init_tesseract(TESSDATA_DIR, "eng", OEM_TESSERACT_ONLY);
92      tesseract_->set_source_resolution(300);
93      equation_det_ = std::make_unique<TestableEquationDetect>(TESSDATA_DIR, tesseract_.get());
94      equation_det_->SetResolution(300);
95      testdata_dir_ = TESTDATA_DIR;
96    }
97    void TearDown() override {
98      tesseract_.reset(nullptr);
99      equation_det_.reset(nullptr);
100    }
101    void AddPageBlock(Image pix, BLOCK_LIST *blocks) {
102      CHECK(pix != nullptr);
103      CHECK(blocks != nullptr);
104      BLOCK_IT block_it(blocks);
105      auto *block = new BLOCK("", true, 0, 0, 0, 0, pixGetWidth(pix), pixGetHeight(pix));
106      block_it.add_to_end(block);
107    }
108    void CreateColParts(const int rows, const int cols, ColPartitionGrid *part_grid,
109                        std::vector<ColPartition *> *all_parts) {
110      const int kWidth = 10, kHeight = 10;
111      ClearParts(all_parts);
112      for (int y = 0; y < rows; ++y) {
113        for (int x = 0; x < cols; ++x) {
114          int left = x * kWidth * 2, bottom = y * kHeight * 2;
115          TBOX box(left, bottom, left + kWidth, bottom + kHeight);
116          ColPartition *part = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
117          part_grid->InsertBBox(true, true, part);
118          all_parts->push_back(part);
119        }
120      }
121    }
122    void ClearParts(std::vector<ColPartition *> *all_parts) {
123      for (auto &all_part : *all_parts) {
124        all_part->DeleteBoxes();
125        delete all_part;
126      }
127    }
128    void AddBlobIntoPart(const TBOX &tbox, ColPartition *part) {
129      CHECK(part != nullptr);
130      auto *blob = new BLOBNBOX();
131      blob->set_bounding_box(tbox);
132      part->AddBox(blob);
133    }
134  };
135  TEST_F(EquationFinderTest, IdentifySpecialText) {
136  #if !ENABLE_IdentifySpecialText_TEST
137    GTEST_SKIP();
138  #else 
139    std::string imagefile = file::JoinPath(testdata_dir_, "equ_gt1.tif");
140    Image pix_binary = pixRead(imagefile.c_str());
141    CHECK(pix_binary != nullptr && pixGetDepth(pix_binary) == 1);
142    BLOCK_LIST blocks;
143    TO_BLOCK_LIST to_blocks;
144    AddPageBlock(pix_binary, &blocks);
145    Textord *textord = tesseract_->mutable_textord();
146    textord->find_components(pix_binary, &blocks, &to_blocks);
147    TO_BLOCK_IT to_block_it(&to_blocks);
148    std::map<int, int> stt_count;
149    for (to_block_it.mark_cycle_pt(); !to_block_it.cycled_list(); to_block_it.forward()) {
150      TO_BLOCK *to_block = to_block_it.data();
151      BLOBNBOX_IT blob_it(&(to_block->blobs));
152      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
153        BLOBNBOX *blob = blob_it.data();
154        equation_det_->RunIdentifySpecialText(blob, 0);
155        tensorflow::gtl::InsertIfNotPresent(&stt_count, blob->special_text_type(), 0);
156        stt_count[blob->special_text_type()]++;
157      }
158    }
159    const int kCountRange = 3;
160    EXPECT_GE(39 + kCountRange, stt_count[BSTT_NONE]);
161    EXPECT_LE(39 - kCountRange, stt_count[BSTT_NONE]);
162    EXPECT_GE(45 + kCountRange, stt_count[BSTT_ITALIC]);
163    EXPECT_LE(45 - kCountRange, stt_count[BSTT_ITALIC]);
164    EXPECT_GE(41 + kCountRange, stt_count[BSTT_DIGIT]);
165    EXPECT_LE(41 - kCountRange, stt_count[BSTT_DIGIT]);
166    EXPECT_GE(50 + kCountRange, stt_count[BSTT_MATH]);
167    EXPECT_LE(50 - kCountRange, stt_count[BSTT_MATH]);
168    EXPECT_GE(10 + kCountRange, stt_count[BSTT_UNCLEAR]);
169    EXPECT_LE(10 - kCountRange, stt_count[BSTT_UNCLEAR]);
170    pix_binary.destroy();
171  #endif
172  }
173  TEST_F(EquationFinderTest, EstimateTypeForUnichar) {
174    EXPECT_EQ(BSTT_NONE, equation_det_->RunEstimateTypeForUnichar("a"));
175    EXPECT_EQ(BSTT_NONE, equation_det_->RunEstimateTypeForUnichar("c"));
176    EXPECT_EQ(BSTT_NONE, equation_det_->RunEstimateTypeForUnichar("'"));
177    EXPECT_EQ(BSTT_NONE, equation_det_->RunEstimateTypeForUnichar(","));
178    EXPECT_EQ(BSTT_DIGIT, equation_det_->RunEstimateTypeForUnichar("1"));
179    EXPECT_EQ(BSTT_DIGIT, equation_det_->RunEstimateTypeForUnichar("4"));
180    EXPECT_EQ(BSTT_DIGIT, equation_det_->RunEstimateTypeForUnichar("|"));
181    EXPECT_EQ(BSTT_MATH, equation_det_->RunEstimateTypeForUnichar("("));
182    EXPECT_EQ(BSTT_MATH, equation_det_->RunEstimateTypeForUnichar("+"));
183  }
184  TEST_F(EquationFinderTest, IsIndented) {
185    ColPartitionGrid part_grid(10, ICOORD(0, 0), ICOORD(1000, 1000));
186    TBOX box1(0, 950, 999, 999);
187    ColPartition *part1 = ColPartition::FakePartition(box1, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
188    part_grid.InsertBBox(true, true, part1);
189    TBOX box2(300, 920, 900, 940);
190    ColPartition *part2 = ColPartition::FakePartition(box2, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
191    part_grid.InsertBBox(true, true, part2);
192    TBOX box3(0, 900, 600, 910);
193    ColPartition *part3 = ColPartition::FakePartition(box3, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
194    part_grid.InsertBBox(true, true, part3);
195    TBOX box4(300, 890, 600, 899);
196    ColPartition *part4 = ColPartition::FakePartition(box4, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
197    part_grid.InsertBBox(true, true, part4);
198    TBOX box5(300, 500, 900, 510);
199    ColPartition *part5 = ColPartition::FakePartition(box5, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
200    part_grid.InsertBBox(true, true, part5);
201    EXPECT_EQ(EquationDetect::NO_INDENT, equation_det_->RunIsIndented(&part_grid, part1));
202    EXPECT_EQ(EquationDetect::LEFT_INDENT, equation_det_->RunIsIndented(&part_grid, part2));
203    EXPECT_EQ(EquationDetect::RIGHT_INDENT, equation_det_->RunIsIndented(&part_grid, part3));
204    EXPECT_EQ(EquationDetect::BOTH_INDENT, equation_det_->RunIsIndented(&part_grid, part4));
205    EXPECT_EQ(EquationDetect::NO_INDENT, equation_det_->RunIsIndented(&part_grid, part5));
206    part1->DeleteBoxes();
207    delete (part1);
208    part2->DeleteBoxes();
209    delete (part2);
210    part3->DeleteBoxes();
211    delete (part3);
212    part4->DeleteBoxes();
213    delete (part4);
214    part5->DeleteBoxes();
215    delete (part5);
216  }
217  TEST_F(EquationFinderTest, IsNearSmallNeighbor) {
218    TBOX box1(0, 950, 499, 999);
219    TBOX box2(500, 950, 999, 998);
220    TBOX box3(0, 900, 499, 949);
221    TBOX box4(0, 550, 499, 590);
222    EXPECT_TRUE(equation_det_->RunIsNearSmallNeighbor(box1, box2));
223    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box2, box1));
224    EXPECT_TRUE(equation_det_->RunIsNearSmallNeighbor(box1, box3));
225    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box2, box3));
226    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box2, box3));
227    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box3, box2));
228    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box1, box4));
229    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box2, box4));
230    EXPECT_FALSE(equation_det_->RunIsNearSmallNeighbor(box3, box4));
231  }
232  TEST_F(EquationFinderTest, CheckSeedBlobsCount) {
233    TBOX box(0, 950, 999, 999);
234    ColPartition *part1 = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
235    ColPartition *part2 = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
236    ColPartition *part3 = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
237    ColPartition *part4 = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
238    equation_det_->AddMathDigitBlobs(8, 0, 20, part1);
239    EXPECT_TRUE(equation_det_->RunCheckSeedBlobsCount(part1));
240    equation_det_->AddMathDigitBlobs(1, 8, 20, part2);
241    EXPECT_FALSE(equation_det_->RunCheckSeedBlobsCount(part2));
242    equation_det_->AddMathDigitBlobs(3, 8, 20, part3);
243    EXPECT_TRUE(equation_det_->RunCheckSeedBlobsCount(part3));
244    equation_det_->AddMathDigitBlobs(0, 0, 8, part4);
245    EXPECT_FALSE(equation_det_->RunCheckSeedBlobsCount(part4));
246    part1->DeleteBoxes();
247    delete (part1);
248    part2->DeleteBoxes();
249    delete (part2);
250    part3->DeleteBoxes();
251    delete (part3);
252    part4->DeleteBoxes();
253    delete (part4);
254  }
255  TEST_F(EquationFinderTest, ComputeForegroundDensity) {
256    int width = 1024, height = 768;
257    Image pix = pixCreate(width, height, 1);
258    pixRasterop(pix, 0, 0, width, height / 2, PIX_SET, nullptr, 0, 0);
259    TBOX box1(100, 0, 140, 140), box2(100, height / 2 - 20, 140, height / 2 + 20),
260        box3(100, height - 40, 140, height);
261    equation_det_->SetPixBinary(pix);
262    EXPECT_NEAR(0.0, equation_det_->RunComputeForegroundDensity(box1), 0.0001f);
263    EXPECT_NEAR(0.5, equation_det_->RunComputeForegroundDensity(box2), 0.0001f);
264    EXPECT_NEAR(1.0, equation_det_->RunComputeForegroundDensity(box3), 0.0001f);
265  }
266  TEST_F(EquationFinderTest, CountAlignment) {
267    std::vector<int> vec;
268    vec.push_back(1);
269    vec.push_back(1);
270    vec.push_back(1);
271    vec.push_back(100);
272    vec.push_back(200);
273    vec.push_back(200);
274    EXPECT_EQ(3, equation_det_->RunCountAlignment(vec, 1));
275    EXPECT_EQ(1, equation_det_->RunCountAlignment(vec, 100));
276    EXPECT_EQ(2, equation_det_->RunCountAlignment(vec, 200));
277    EXPECT_EQ(3, equation_det_->RunCountAlignment(vec, 3));
278    EXPECT_EQ(1, equation_det_->RunCountAlignment(vec, 99));
279    EXPECT_EQ(2, equation_det_->RunCountAlignment(vec, 202));
280    EXPECT_EQ(0, equation_det_->RunCountAlignment(vec, 150));
281    EXPECT_EQ(0, equation_det_->RunCountAlignment(vec, 50));
282    EXPECT_EQ(0, equation_det_->RunCountAlignment(vec, 250));
283  }
284  TEST_F(EquationFinderTest, ComputeCPsSuperBBox) {
285    Image pix = pixCreate(1001, 1001, 1);
286    equation_det_->SetPixBinary(pix);
287    ColPartitionGrid part_grid(10, ICOORD(0, 0), ICOORD(1000, 1000));
288    TBOX box1(0, 0, 999, 99);
289    ColPartition *part1 = ColPartition::FakePartition(box1, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
290    TBOX box2(0, 100, 499, 199);
291    ColPartition *part2 = ColPartition::FakePartition(box2, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
292    TBOX box3(500, 100, 999, 199);
293    ColPartition *part3 = ColPartition::FakePartition(box3, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
294    TBOX box4(0, 200, 999, 299);
295    ColPartition *part4 = ColPartition::FakePartition(box4, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
296    TBOX box5(0, 900, 999, 999);
297    ColPartition *part5 = ColPartition::FakePartition(box5, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
298    part_grid.InsertBBox(true, true, part1);
299    part_grid.InsertBBox(true, true, part2);
300    part_grid.InsertBBox(true, true, part3);
301    TBOX super_box(0, 0, 999, 199);
302    equation_det_->TestComputeCPsSuperBBox(super_box, &part_grid);
303    part_grid.InsertBBox(true, true, part4);
304    TBOX super_box2(0, 0, 999, 299);
305    equation_det_->TestComputeCPsSuperBBox(super_box2, &part_grid);
306    part_grid.InsertBBox(true, true, part5);
307    TBOX super_box3(0, 0, 999, 999);
308    equation_det_->TestComputeCPsSuperBBox(super_box3, &part_grid);
309    part1->DeleteBoxes();
310    delete (part1);
311    part2->DeleteBoxes();
312    delete (part2);
313    part3->DeleteBoxes();
314    delete (part3);
315    part4->DeleteBoxes();
316    delete (part4);
317    part5->DeleteBoxes();
318    delete (part5);
319  }
320  TEST_F(EquationFinderTest, SplitCPHorLite) {
321    TBOX box(0, 0, 999, 99);
322    ColPartition *part = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
323    part->DeleteBoxes();
324    part->set_median_width(10);
325    std::vector<TBOX> splitted_boxes;
326    equation_det_->RunSplitCPHorLite(part, &splitted_boxes);
327    EXPECT_TRUE(splitted_boxes.empty());
328    AddBlobIntoPart(TBOX(0, 0, 10, 50), part);
329    equation_det_->RunSplitCPHorLite(part, &splitted_boxes);
330    EXPECT_EQ(1, splitted_boxes.size());
331    EXPECT_TRUE(TBOX(0, 0, 10, 50) == splitted_boxes[0]);
332    AddBlobIntoPart(TBOX(11, 0, 20, 60), part);
333    AddBlobIntoPart(TBOX(25, 0, 30, 55), part); 
334    AddBlobIntoPart(TBOX(100, 0, 110, 15), part);
335    AddBlobIntoPart(TBOX(125, 0, 140, 45), part); 
336    AddBlobIntoPart(TBOX(500, 0, 540, 35), part); 
337    equation_det_->RunSplitCPHorLite(part, &splitted_boxes);
338    EXPECT_EQ(3, splitted_boxes.size());
339    EXPECT_TRUE(TBOX(0, 0, 30, 60) == splitted_boxes[0]);
340    EXPECT_TRUE(TBOX(100, 0, 140, 45) == splitted_boxes[1]);
341    EXPECT_TRUE(TBOX(500, 0, 540, 35) == splitted_boxes[2]);
342    part->DeleteBoxes();
343    delete (part);
344  }
345  TEST_F(EquationFinderTest, SplitCPHor) {
346    TBOX box(0, 0, 999, 99);
347    ColPartition *part = ColPartition::FakePartition(box, PT_FLOWING_TEXT, BRT_TEXT, BTFT_NONE);
348    part->DeleteBoxes();
349    part->set_median_width(10);
<span onclick='openModal()' class='match'>350    std::vector<ColPartition *> parts_splitted;
351    equation_det_->RunSplitCPHor(part, &parts_splitted);
352    EXPECT_TRUE(parts_splitted.empty());
353    AddBlobIntoPart(TBOX(0, 0, 10, 50), part);
354    equation_det_->RunSplitCPHor(part, &parts_splitted);
355    EXPECT_EQ(1, parts_splitted.size());
356    EXPECT_TRUE(TBOX(0, 0, 10, 50) == parts_splitted[0]->bounding_box());
357    AddBlobIntoPart(TBOX(11, 0, 20, 60), part);
358    AddBlobIntoPart(TBOX(25, 0, 30, 55), part); 
359    AddBlobIntoPart(TBOX(100, 0, 110, 15), part);
360    AddBlobIntoPart(TBOX(125, 0, 140, 45), part); 
361    AddBlobIntoPart(TBOX(500, 0, 540, 35), part); 
362    equation_det_->RunSplitCPHor(part, &parts_splitted);
363    EXPECT_EQ(3, parts_splitted.size());
364    EXPECT_TRUE(TBOX(0, 0, 30, 60) == parts_splitted[0]->bounding_box());
365    EXPECT_TRUE(TBOX(100, 0, 140, 45) == parts_splitted[1]->bounding_box());
</span>366    EXPECT_TRUE(TBOX(500, 0, 540, 35) == parts_splitted[2]->bounding_box());
367    for (auto part_splitted : parts_splitted) {
368      delete part_splitted;
369    }
370    part->DeleteBoxes();
371    delete (part);
372  }
373  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.h</h3>
            <pre><code>1  #ifndef NETWORKMP_H
2  #define NETWORKMP_H
3  #ifdef GCC_ATOMIC
4  class TNEANetMP;
5  typedef TPt<TNEANetMP> PNEANetMP;
6  class TNEANetMP {
7  public:
8    typedef TNEANetMP TNet;
9    typedef TPt<TNEANetMP> PNet;
10  public:
11    class TNode {
12    private:
13      TInt Id;
14      TIntV InEIdV, OutEIdV;
15    public:
16      TNode() : Id(-1), InEIdV(), OutEIdV() { }
17      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV() { }
18      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV) { }
19      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn) { }
20      void Save(TSOut& SOut) const { Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut); }
21      int GetId() const { return Id; }
22      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
23      int GetInDeg() const { return InEIdV.Len(); }
24      int GetOutDeg() const { return OutEIdV.Len(); }
25      int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
26      int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
27      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
28      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
29      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
30      friend class TNEANetMP;
31    };
32    class TEdge {
33    private:
34      TInt Id, SrcNId, DstNId;
35    public:
36      TEdge() : Id(-1), SrcNId(-1), DstNId(-1) { }
37      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
38      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
39      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn) { }
40      void Save(TSOut& SOut) const { Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
41      int GetId() const { return Id; }
42      int GetSrcNId() const { return SrcNId; }
43      int GetDstNId() const { return DstNId; }
44      friend class TNEANetMP;
45    };
46    class TNodeI {
47    private:
48      typedef THashMP<TInt, TNode>::TIter THashIter;
49      THashIter NodeHI;
50      const TNEANetMP *Graph;
51    public:
52      TNodeI() : NodeHI(), Graph(NULL) { }
53      TNodeI(const THashIter& NodeHIter, const TNEANetMP* GraphPt) : NodeHI(NodeHIter), Graph(GraphPt) { }
54      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Graph(NodeI.Graph) { }
55      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
56      TNodeI& operator++ (int) { NodeHI++; return *this; }
57      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
58      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
59      int GetId() const { return NodeHI.GetDat().GetId(); }
60      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
61      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
62      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
63      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
64      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
65      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN)); return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
66      bool IsInNId(const int& NId) const;
67      bool IsOutNId(const int& NId) const;
68      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
69      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
70      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
71      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
72      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
73      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
74      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
75      void GetAttrNames(TStrV& Names) const { Graph->AttrNameNI(GetId(), Names); }
76      void GetAttrVal(TStrV& Val) const { Graph->AttrValueNI(GetId(), Val); }
77      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameNI(GetId(), Names); }
78      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueNI(GetId(), Val); }
79      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameNI(GetId(), Names); }
80      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueNI(GetId(), Val); }
81      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameNI(GetId(), Names); }
82      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueNI(GetId(), Val); }
83      friend class TNEANetMP;
84    };
85    class TEdgeI {
86    private:
87      typedef THashMP<TInt, TEdge>::TIter THashIter;
88      THashIter EdgeHI;
89      const TNEANetMP *Graph;
90    public:
91      TEdgeI() : EdgeHI(), Graph(NULL) { }
92      TEdgeI(const THashIter& EdgeHIter, const TNEANetMP *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
93      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
94      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
95      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
96      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
97      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
98      int GetId() const { return EdgeHI.GetDat().GetId(); }
99      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
100      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
101      void GetAttrNames(TStrV& Names) const { Graph->AttrNameEI(GetId(), Names); }
102      void GetAttrVal(TStrV& Val) const { Graph->AttrValueEI(GetId(), Val); }
103      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameEI(GetId(), Names); }
104      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueEI(GetId(), Val); }
105      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameEI(GetId(), Names); }
106      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueEI(GetId(), Val); }
107      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameEI(GetId(), Names); }
108      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueEI(GetId(), Val); }
109      friend class TNEANetMP;
110    };
111    class TAIntI {
112    private:
113      typedef TIntV::TIter TIntVecIter;
114      TIntVecIter HI;
115      bool isNode;
116      TStr attr;
117      const TNEANetMP *Graph;
118    public:
119      TAIntI() : HI(), attr(), Graph(NULL) { }
120      TAIntI(const TIntVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANetMP* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
121      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
122      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
123      bool operator < (const TAIntI& I) const { return HI < I.HI; }
124      bool operator == (const TAIntI& I) const { return HI == I.HI; }
125      TInt GetDat() const { return HI[0]; }
126      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetIntAttrDefaultN(attr) : GetDat() == Graph->GetIntAttrDefaultE(attr); };
127      TAIntI& operator++(int) { HI++; return *this; }
128      friend class TNEANetMP;
129    };
130    class TAStrI {
131    private:
132      typedef TStrV::TIter TStrVecIter;
133      TStrVecIter HI;
134      bool isNode;
135      TStr attr;
136      const TNEANetMP *Graph;
137    public:
138      TAStrI() : HI(), attr(), Graph(NULL) { }
139      TAStrI(const TStrVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANetMP* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
140      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
141      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
142      bool operator < (const TAStrI& I) const { return HI < I.HI; }
143      bool operator == (const TAStrI& I) const { return HI == I.HI; }
144      TStr GetDat() const { return HI[0]; }
145      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetStrAttrDefaultN(attr) : GetDat() == Graph->GetStrAttrDefaultE(attr); };
146      TAStrI& operator++(int) { HI++; return *this; }
147      friend class TNEANetMP;
148    };
149    class TAFltI {
150    private:
151      typedef TFltV::TIter TFltVecIter;
152      TFltVecIter HI;
153      bool isNode;
154      TStr attr;
155      const TNEANetMP *Graph;
156    public:
157      TAFltI() : HI(), attr(), Graph(NULL) { }
158      TAFltI(const TFltVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANetMP* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
159      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
160      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
161      bool operator < (const TAFltI& I) const { return HI < I.HI; }
162      bool operator == (const TAFltI& I) const { return HI == I.HI; }
163      TFlt GetDat() const { return HI[0]; }
164      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetFltAttrDefaultN(attr) : GetDat() == Graph->GetFltAttrDefaultE(attr); };
165      TAFltI& operator++(int) { HI++; return *this; }
166      friend class TNEANetMP;
167    };
168  private:
169    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
170    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
171    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
172    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
173    TInt GetIntAttrDefaultN(const TStr& attribute) const { return IntDefaultsN.IsKey(attribute) ? IntDefaultsN.GetDat(attribute) : (TInt) TInt::Mn; }
174    TStr GetStrAttrDefaultN(const TStr& attribute) const { return StrDefaultsN.IsKey(attribute) ? StrDefaultsN.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
175    TFlt GetFltAttrDefaultN(const TStr& attribute) const { return FltDefaultsN.IsKey(attribute) ? FltDefaultsN.GetDat(attribute) : (TFlt) TFlt::Mn; }
176    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
177    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
178    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
179  private:
180    TCRef CRef;
181    TInt MxNId, MxEId;
182    THashMP<TInt, TNode> NodeH;
183    THashMP<TInt, TEdge> EdgeH;
184    TStrIntPrH KeyToIndexTypeN, KeyToIndexTypeE;
185    THashMP<TStr, TInt> IntDefaultsN, IntDefaultsE;
186    THashMP<TStr, TStr> StrDefaultsN, StrDefaultsE;
187    THashMP<TStr, TFlt> FltDefaultsN, FltDefaultsE;
188    TVec<TIntV> VecOfIntVecsN, VecOfIntVecsE;
189    TVec<TStrV> VecOfStrVecsN, VecOfStrVecsE;
190    TVec<TFltV> VecOfFltVecsN, VecOfFltVecsE;
191    enum { IntType, StrType, FltType };
192  public:
193    TNEANetMP() : CRef(), MxNId(0), MxEId(0), NodeH(), EdgeH(),
194      KeyToIndexTypeN(), KeyToIndexTypeE(), IntDefaultsN(), IntDefaultsE(),
195      StrDefaultsN(), StrDefaultsE(), FltDefaultsN(), FltDefaultsE(),
196      VecOfIntVecsN(), VecOfIntVecsE(), VecOfStrVecsN(), VecOfStrVecsE(),
197      VecOfFltVecsN(), VecOfFltVecsE() { }
198    explicit TNEANetMP(const int& Nodes, const int& Edges) : CRef(),
199      MxNId(0), MxEId(0), NodeH(), EdgeH(), KeyToIndexTypeN(), KeyToIndexTypeE(),
200      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
201      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
202      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE()
203      { Reserve(Nodes, Edges); }
204    TNEANetMP(const TNEANetMP& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
205      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(), KeyToIndexTypeE(),
206      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
207      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
208      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE() { }
209    TNEANetMP(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn),
210      KeyToIndexTypeN(SIn), KeyToIndexTypeE(SIn), IntDefaultsN(SIn), IntDefaultsE(SIn),
211      StrDefaultsN(SIn), StrDefaultsE(SIn), FltDefaultsN(SIn), FltDefaultsE(SIn),
212      VecOfIntVecsN(SIn), VecOfIntVecsE(SIn), VecOfStrVecsN(SIn),VecOfStrVecsE(SIn),
213      VecOfFltVecsN(SIn), VecOfFltVecsE(SIn) { }
<span onclick='openModal()' class='match'>214    void Save(TSOut& SOut) const {
215      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
216      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
217      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
218      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
219      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
220      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
221      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
222      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut); }
</span>223    static PNEANetMP New() { return PNEANetMP(new TNEANetMP()); }
224    static PNEANetMP New(const int& Nodes, const int& Edges) { return PNEANetMP(new TNEANetMP(Nodes, Edges)); }
225    static PNEANetMP Load(TSIn& SIn) { return PNEANetMP(new TNEANetMP(SIn)); }
226    bool HasFlag(const TGraphFlag& Flag) const;
227    TNEANetMP& operator = (const TNEANetMP& Graph) { if (this!=&Graph) {
228      MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH; }
229      return *this; }
230    int GetNodes() const { return NodeH.Len(); }
231    void SetNodes(const int& Length) { NodeH.SetLen(Length); }
232    int AddNode(int NId = -1);
233    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
234    void AddNodeWithEdges(const TInt& NId, TIntV& InEIdV, TIntV& OutEIdV);
235    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
236    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
237    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
238    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
239    TAIntI BegNAIntI(const TStr& attr) const {
240      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
241    TAIntI EndNAIntI(const TStr& attr) const {
242      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
243    TAIntI GetNAIntI(const TStr& attr, const int& NId) const {
244      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
245    TAStrI BegNAStrI(const TStr& attr) const {
246      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
247    TAStrI EndNAStrI(const TStr& attr) const {
248      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
249    TAStrI GetNAStrI(const TStr& attr, const int& NId) const {
250      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
251    TAFltI BegNAFltI(const TStr& attr) const {
252      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
253    TAFltI EndNAFltI(const TStr& attr) const {
254      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
255    TAFltI GetNAFltI(const TStr& attr, const int& NId) const {
256      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
257    void AttrNameNI(const TInt& NId, TStrV& Names) const {
258      AttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
259    void AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
260    void AttrValueNI(const TInt& NId, TStrV& Values) const {
261      AttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
262    void AttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
263    void IntAttrNameNI(const TInt& NId, TStrV& Names) const {
264      IntAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
265    void IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
266    void IntAttrValueNI(const TInt& NId, TIntV& Values) const {
267      IntAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
268    void IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const;
269    void StrAttrNameNI(const TInt& NId, TStrV& Names) const {
270      StrAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
271    void StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
272    void StrAttrValueNI(const TInt& NId, TStrV& Values) const {
273      StrAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
274    void StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
275    void FltAttrNameNI(const TInt& NId, TStrV& Names) const {
276      FltAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
277    void FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
278    void FltAttrValueNI(const TInt& NId, TFltV& Values) const {
279      FltAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
280    void FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const;
281    void AttrNameEI(const TInt& EId, TStrV& Names) const {
282      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
283    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
284    void AttrValueEI(const TInt& EId, TStrV& Values) const {
285      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
286    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
287    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
288      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
289    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
290    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
291      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
292    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const;
293    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
294      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
295    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
296    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
297      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
298    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
299    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
300      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
301    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
302    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
303      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
304    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const;
305    TAIntI BegEAIntI(const TStr& attr) const {
306      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
307    }
308    TAIntI EndEAIntI(const TStr& attr) const {
309      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
310    }
311    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
312      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
313    }
314    TAStrI BegEAStrI(const TStr& attr) const {
315      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);   }
316    TAStrI EndEAStrI(const TStr& attr) const {
317      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
318    }
319    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
320      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
321    }
322    TAFltI BegEAFltI(const TStr& attr) const {
323      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
324    }
325    TAFltI EndEAFltI(const TStr& attr) const {
326      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
327    }
328    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
329      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
330    }
331    int GetMxNId() const { return MxNId; }
332    int GetMxEId() const { return MxEId; }
333    int Reserved() const {return NodeH.GetReservedKeyIds();}
334    int ReservedE() const {return EdgeH.GetReservedKeyIds();}
335    int GetEdges() const { return EdgeH.Len(); }
336    void SetEdges(const int& Length) { EdgeH.SetLen(Length); }
337    void SetMxEId(const TInt& Id) { MxEId = Id; }
338    int AddEdge(const int& SrcNId, const int& DstNId, int EId  = -1);
339    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId()); }
340    void AddEdgeUnchecked(const TInt& EId, const int SrcNId, const int DstNId);
341    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
342    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
343    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
344    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
345    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
346    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
347    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
348    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
349    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
350    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
351    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
352    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
353    void GetNIdV(TIntV& NIdV) const;
354    void GetEIdV(TIntV& EIdV) const;
355    bool Empty() const { return GetNodes()==0; }
356    void Clr() { MxNId=0; MxEId=0; NodeH.Clr(); EdgeH.Clr(),
357      KeyToIndexTypeN.Clr(), KeyToIndexTypeE.Clr(), IntDefaultsN.Clr(), IntDefaultsE.Clr(),
358      StrDefaultsN.Clr(), StrDefaultsE.Clr(), FltDefaultsN.Clr(), FltDefaultsE.Clr(),
359      VecOfIntVecsN.Clr(), VecOfIntVecsE.Clr(), VecOfStrVecsN.Clr(), VecOfStrVecsE.Clr(),
360      VecOfFltVecsN.Clr(), VecOfFltVecsE.Clr();}
361    void Reserve(const int& Nodes, const int& Edges) {
362      if (Nodes>0) { NodeH.Gen(Nodes); } if (Edges>0) { EdgeH.Gen(Edges); } }
363    void ReserveAttr(const int& NIntAttr, const int& NFltAttr, const int& NStrAttr, const int& EIntAttr,
364         const int& EFltAttr, const int& EStrAttr) {
365      if (NIntAttr > 0) { IntDefaultsN.Gen(NIntAttr); }
366      if (NFltAttr > 0) { FltDefaultsN.Gen(NFltAttr); }
367      if (NStrAttr > 0) { StrDefaultsN.Gen(NStrAttr); }
368      if (EIntAttr > 0) { IntDefaultsE.Gen(EIntAttr); }
369      if (EFltAttr > 0) { FltDefaultsE.Gen(EFltAttr); }
370      if (EStrAttr > 0) { StrDefaultsE.Gen(EStrAttr); }
371    }
372    void Defrag(const bool& OnlyNodeLinks=false);
373    bool IsOk(const bool& ThrowExcept=true) const;
374    void Dump(FILE *OutF=stdout) const;
375    int AddIntAttrDatN(const TNodeI& NodeId, const TInt& value, const TStr& attr) { return AddIntAttrDatN(NodeId.GetId(), value, attr); }
376    int AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr);
377    int AddStrAttrDatN(const TNodeI& NodeId, const TStr& value, const TStr& attr) { return AddStrAttrDatN(NodeId.GetId(), value, attr); }
378    int AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr);
379    int AddFltAttrDatN(const TNodeI& NodeId, const TFlt& value, const TStr& attr) { return AddFltAttrDatN(NodeId.GetId(), value, attr); }
380    int AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr);
381    int AddIntAttrDatE(const TEdgeI& EdgeId, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeId.GetId(), value, attr); }
382    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
383    int AddStrAttrDatE(const TEdgeI& EdgeId, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeId.GetId(), value, attr); }
384    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
385    int AddFltAttrDatE(const TEdgeI& EdgeId, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeId.GetId(), value, attr); }
386    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
387    TInt GetIntAttrDatN(const TNodeI& NodeId, const TStr& attr) { return GetIntAttrDatN(NodeId.GetId(), attr); }
388    TInt GetIntAttrDatN(const int& NId, const TStr& attr);
389    TStr GetStrAttrDatN(const TNodeI& NodeId, const TStr& attr) { return GetStrAttrDatN(NodeId.GetId(), attr); }
390    TStr GetStrAttrDatN(const int& NId, const TStr& attr);
391    TFlt GetFltAttrDatN(const TNodeI& NodeId, const TStr& attr) { return GetFltAttrDatN(NodeId.GetId(), attr); }
392    TFlt GetFltAttrDatN(const int& NId, const TStr& attr);
393    int GetIntAttrIndN(const TStr& attr);
394    TInt GetIntAttrIndDatN(const TNodeI& NodeId, const int& index) { return GetIntAttrIndDatN(NodeId.GetId(), index); }
395    TInt GetIntAttrIndDatN(const int& NId, const int& index);
396    TInt GetIntAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return GetIntAttrDatE(EdgeId.GetId(), attr); }
397    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
398    TStr GetStrAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return GetStrAttrDatE(EdgeId.GetId(), attr); }
399    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
400    TFlt GetFltAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return GetFltAttrDatE(EdgeId.GetId(), attr); }
401    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
402    int GetIntAttrIndE(const TStr& attr);
403    TInt GetIntAttrIndDatE(const TEdgeI& EdgeId, const int &index) { return GetIntAttrIndDatE(EdgeId.GetId(), index); }
404    TInt GetIntAttrIndDatE(const int& EId, const int& index);
405    int DelAttrDatN(const TNodeI& NodeId, const TStr& attr) { return DelAttrDatN(NodeId.GetId(), attr); }
406    int DelAttrDatN(const int& NId, const TStr& attr);
407    int DelAttrDatE(const TEdgeI& EdgeId, const TStr& attr) { return DelAttrDatE(EdgeId.GetId(), attr); }
408    int DelAttrDatE(const int& EId, const TStr& attr);
409    int AddIntAttrN(const TStr& attr, TInt defaultValue=TInt::Mn);
410    int AddStrAttrN(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
411    int AddFltAttrN(const TStr& attr, TFlt defaultValue=TFlt::Mn);
412    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
413    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
414    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
415    bool NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
416    bool NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
417    bool NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
418    bool NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
419    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
420    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
421    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
422    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
423    TStr GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
424    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
425    TFlt GetWeightOutEdges(const TNodeI& NI, const TStr& attr);
426    bool IsFltAttrE(const TStr& attr);
427    bool IsIntAttrE(const TStr& attr);
428    bool IsStrAttrE(const TStr& attr);
429    TVec<TFlt>& GetFltAttrVecE(const TStr& attr);
430    int GetFltKeyIdE(const int& EId);
431    void GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) ;
432    friend class TPt<TNEANetMP>;
433  };
434  namespace TSnap {
435  template <> struct IsMultiGraph<TNEANetMP> { enum { Val = 1 }; };
436  template <> struct IsDirected<TNEANetMP> { enum { Val = 1 }; };
437  }
438  #else
439  #endif 
440  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-equationdetect_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.h</div>
                </div>
                <div class="column column_space"><pre><code>350    std::vector<ColPartition *> parts_splitted;
351    equation_det_->RunSplitCPHor(part, &parts_splitted);
352    EXPECT_TRUE(parts_splitted.empty());
353    AddBlobIntoPart(TBOX(0, 0, 10, 50), part);
354    equation_det_->RunSplitCPHor(part, &parts_splitted);
355    EXPECT_EQ(1, parts_splitted.size());
356    EXPECT_TRUE(TBOX(0, 0, 10, 50) == parts_splitted[0]->bounding_box());
357    AddBlobIntoPart(TBOX(11, 0, 20, 60), part);
358    AddBlobIntoPart(TBOX(25, 0, 30, 55), part); 
359    AddBlobIntoPart(TBOX(100, 0, 110, 15), part);
360    AddBlobIntoPart(TBOX(125, 0, 140, 45), part); 
361    AddBlobIntoPart(TBOX(500, 0, 540, 35), part); 
362    equation_det_->RunSplitCPHor(part, &parts_splitted);
363    EXPECT_EQ(3, parts_splitted.size());
364    EXPECT_TRUE(TBOX(0, 0, 30, 60) == parts_splitted[0]->bounding_box());
365    EXPECT_TRUE(TBOX(100, 0, 140, 45) == parts_splitted[1]->bounding_box());
</pre></code></div>
                <div class="column column_space"><pre><code>214    void Save(TSOut& SOut) const {
215      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
216      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
217      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
218      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
219      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
220      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
221      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
222      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    