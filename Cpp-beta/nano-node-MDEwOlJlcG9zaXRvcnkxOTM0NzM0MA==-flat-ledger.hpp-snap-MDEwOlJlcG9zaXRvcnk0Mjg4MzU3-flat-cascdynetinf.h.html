
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 47.26426076833528%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ledger.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/rep_weights.hpp>
3  #include <nano/lib/timer.hpp>
4  #include <nano/secure/common.hpp>
5  #include <map>
6  namespace nano
7  {
8  class store;
9  class stats;
10  class write_transaction;
11  using tally_t = std::map<nano::uint128_t, std::shared_ptr<nano::block>, std::greater<nano::uint128_t>>;
12  class uncemented_info
13  {
14  public:
15  	uncemented_info (nano::block_hash const & cemented_frontier, nano::block_hash const & frontier, nano::account const & account);
16  	nano::block_hash cemented_frontier;
17  	nano::block_hash frontier;
18  	nano::account account;
19  };
20  class ledger final
21  {
22  public:
23  	ledger (nano::store &, nano::stats &, nano::ledger_constants & constants, nano::generate_cache const & = nano::generate_cache ());
24  	nano::account account (nano::transaction const &, nano::block_hash const &) const;
25  	std::optional<nano::account_info> account_info (nano::transaction const & transaction, nano::account const & account) const;
26  	nano::account account_safe (nano::transaction const &, nano::block_hash const &, bool &) const;
27  	nano::account account_safe (nano::transaction const &, nano::block_hash const &) const;
28  	nano::uint128_t amount (nano::transaction const &, nano::account const &);
29  	nano::uint128_t amount (nano::transaction const &, nano::block_hash const &);
30  	nano::uint128_t amount_safe (nano::transaction const &, nano::block_hash const & hash_a, bool &) const;
31  	nano::uint128_t balance (nano::transaction const &, nano::block_hash const &) const;
32  	nano::uint128_t balance_safe (nano::transaction const &, nano::block_hash const &, bool &) const;
33  	nano::uint128_t account_balance (nano::transaction const &, nano::account const &, bool = false);
34  	nano::uint128_t account_receivable (nano::transaction const &, nano::account const &, bool = false);
35  	nano::uint128_t weight (nano::account const &);
36  	std::shared_ptr<nano::block> successor (nano::transaction const &, nano::qualified_root const &);
37  	std::shared_ptr<nano::block> forked_block (nano::transaction const &, nano::block const &);
38  	std::shared_ptr<nano::block> head_block (nano::transaction const &, nano::account const &);
39  	bool block_confirmed (nano::transaction const &, nano::block_hash const &) const;
40  	nano::block_hash latest (nano::transaction const &, nano::account const &);
41  	nano::root latest_root (nano::transaction const &, nano::account const &);
42  	nano::block_hash representative (nano::transaction const &, nano::block_hash const &);
43  	nano::block_hash representative_calculated (nano::transaction const &, nano::block_hash const &);
44  	bool block_or_pruned_exists (nano::block_hash const &) const;
45  	bool block_or_pruned_exists (nano::transaction const &, nano::block_hash const &) const;
46  	bool root_exists (nano::transaction const &, nano::root const &);
47  	std::string block_text (char const *);
<span onclick='openModal()' class='match'>48  	std::string block_text (nano::block_hash const &);
49  	bool is_send (nano::transaction const &, nano::block const &) const;
50  	nano::account const & block_destination (nano::transaction const &, nano::block const &);
51  	nano::block_hash block_source (nano::transaction const &, nano::block const &);
</span>52  	std::pair<nano::block_hash, nano::block_hash> hash_root_random (nano::transaction const &) const;
53  	std::optional<nano::pending_info> pending_info (nano::transaction const & transaction, nano::pending_key const & key) const;
54  	nano::process_return process (nano::write_transaction const &, nano::block &);
55  	bool rollback (nano::write_transaction const &, nano::block_hash const &, std::vector<std::shared_ptr<nano::block>> &);
56  	bool rollback (nano::write_transaction const &, nano::block_hash const &);
57  	void update_account (nano::write_transaction const &, nano::account const &, nano::account_info const &, nano::account_info const &);
58  	uint64_t pruning_action (nano::write_transaction &, nano::block_hash const &, uint64_t const);
59  	void dump_account_chain (nano::account const &, std::ostream & = std::cout);
60  	bool could_fit (nano::transaction const &, nano::block const &) const;
61  	bool dependents_confirmed (nano::transaction const &, nano::block const &) const;
62  	bool is_epoch_link (nano::link const &) const;
63  	std::array<nano::block_hash, 2> dependent_blocks (nano::transaction const &, nano::block const &) const;
64  	std::shared_ptr<nano::block> find_receive_block_by_send_hash (nano::transaction const & transaction, nano::account const & destination, nano::block_hash const & send_block_hash);
65  	nano::account const & epoch_signer (nano::link const &) const;
66  	nano::link const & epoch_link (nano::epoch) const;
67  	std::multimap<uint64_t, uncemented_info, std::greater<>> unconfirmed_frontiers () const;
68  	bool migrate_lmdb_to_rocksdb (boost::filesystem::path const &) const;
69  	bool bootstrap_weight_reached () const;
70  	static nano::uint128_t const unit;
71  	nano::ledger_constants & constants;
72  	nano::store & store;
73  	nano::ledger_cache cache;
74  	nano::stats & stats;
75  	std::unordered_map<nano::account, nano::uint128_t> bootstrap_weights;
76  	uint64_t bootstrap_weight_max_blocks{ 1 };
77  	std::atomic<bool> check_bootstrap_weights;
78  	bool pruning{ false };
79  private:
80  	void initialize (nano::generate_cache const &);
81  };
82  std::unique_ptr<container_info_component> collect_container_info (ledger & ledger, std::string const & name);
83  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascdynetinf.h</h3>
            <pre><code>1  #ifndef snap_cascdynetinf_h
2  #define snap_cascdynetinf_h
3  #include "Snap.h"
4  typedef enum {
5    EXP, 
6    POW, 
7    RAY, 
8    WEI 
9  } TModel;
10  typedef enum {
11    CONSTANT, 
12    LINEAR, 
13    EXPONENTIAL, 
14    RAYLEIGH, 
15    SLAB, 
16    SQUARE, 
17    CHAINSAW, 
18    RANDOM 
19  } TVarying;
20  typedef enum {
21    OSG,    
22    OWSG,    
23    OESG,   
24    OWESG,  
25    ORSG,  
26    OBSG,   
27    OWBSG,   
28    OEBSG,  
29    ORBSG,  
30    OFG
31  } TOptMethod;
32  typedef enum {
33    UNIF_SAMPLING,
34    WIN_SAMPLING,
35    EXP_SAMPLING,
36    WIN_EXP_SAMPLING,
37    RAY_SAMPLING
38  } TSampling;
39  typedef enum {
40    NONE, 
41    L2REG 
42  } TRegularizer;
43  typedef enum {
44    TIME_STEP, 
45    INFECTION_STEP, 
46    CASCADE_STEP, 
47    SINGLE_STEP
48  } TRunningMode;
49  typedef TNodeEDatNet<TStr, TFltFltH> TStrFltFltHNEDNet;
50  typedef TPt<TStrFltFltHNEDNet> PStrFltFltHNEDNet;
51  typedef TNodeEDatNet<TStr, TFlt> TStrFltNEDNet;
52  typedef TPt<TStrFltNEDNet> PStrFltNEDNet;
53  class THitInfo {
54  public:
55    TInt NId;
56    TFlt Tm;
57    TIntV Keywords;
58  public:
59    THitInfo(const int& NodeId=-1, const double& HitTime=0) : NId(NodeId), Tm(HitTime) { }
60    THitInfo(TSIn& SIn) : NId(SIn), Tm(SIn), Keywords(SIn) { }
61    void AddKeyword(const int& KId) { Keywords.AddUnique(KId); }
62    void DelKeywords() { Keywords.Clr(); }
63    void Save(TSOut& SOut) const { NId.Save(SOut); Tm.Save(SOut); Keywords.Save(SOut); }
64    bool operator < (const THitInfo& Hit) const {
65      return Tm < Hit.Tm; }
66  };
67  class TCascade {
68  public:
69    TInt CId; 
70    THash<TInt, THitInfo> NIdHitH; 
71    TInt Model; 
72  public:
73    TCascade() : CId(0), NIdHitH(), Model(0) { }
74    TCascade(const int &model) : NIdHitH() { Model = model; }
75    TCascade(const int &cid, const int& model) : NIdHitH() { CId = cid; Model = model; }
76    TCascade(TSIn& SIn) : CId(SIn), NIdHitH(SIn), Model(SIn) { }
77    void Save(TSOut& SOut) const  { CId.Save(SOut); NIdHitH.Save(SOut); Model.Save(SOut); }
78    void Clr() { NIdHitH.Clr(); }
79    int GetId() { return CId; }
80    int Len() const { return NIdHitH.Len(); }
81    int LenBeforeT(const double& T) { int len = 0; while (len < NIdHitH.Len() && NIdHitH[len].Tm <= T) { len++; } return len; }
82    int LenAfterT(const double& T) { int len = 0; while (len < NIdHitH.Len() && NIdHitH[NIdHitH.Len()-1-len].Tm >= T) { len++; } return len; }
83    int GetNode(const int& i) const { return NIdHitH.GetKey(i); }
84    THash<TInt, THitInfo>::TIter BegI() const { return NIdHitH.BegI(); }
85    THash<TInt, THitInfo>::TIter EndI() const { return NIdHitH.EndI(); }
86    int GetModel() const { return Model; }
87    double GetTm(const int& NId) const { return NIdHitH.GetDat(NId).Tm; }
88    double GetMaxTm() const { return NIdHitH[NIdHitH.Len()-1].Tm; } 
89    double GetMinTm() const { return NIdHitH[0].Tm; } 
90    void Add(const int& NId, const double& HitTm) { NIdHitH.AddDat(NId, THitInfo(NId, HitTm)); }
91    void Del(const int& NId) { NIdHitH.DelKey(NId); }
92    bool IsNode(const int& NId) const { return NIdHitH.IsKey(NId); }
93    void Sort() { NIdHitH.SortByDat(true); }
94    bool operator < (const TCascade& Cascade) const {
95        return Len() < Cascade.Len(); }
96  };
97  class TNodeInfo {
98  public:
99    TStr Name;
100    TInt Vol;
101  public:
102    TNodeInfo() { }
103    TNodeInfo(const TStr& NodeNm, const int& Volume) : Name(NodeNm), Vol(Volume) { }
104    TNodeInfo(TSIn& SIn) : Name(SIn), Vol(SIn) { }
105    void Save(TSOut& SOut) const { Name.Save(SOut); Vol.Save(SOut); }
106    bool operator < (const TNodeInfo& NodeInfo) const {
107        return Vol < NodeInfo.Vol; }
108  };
109  class TNIBs {
110  public:
111    THash<TInt, TCascade> CascH; 
112    THash<TInt, TNodeInfo> NodeNmH; 
113    TStrIntH DomainsIdH; 
114    TStrIntH CascadeIdH; 
115    THash<TIntPr, TIntV> CascPerEdge;
116    TStrFltFltHNEDNet Network;
117    TModel Model;
118    TFlt Window, TotalTime;
119    TFlt Delta, K;
120    TFlt Gamma, Mu, Aging;
121    TRegularizer Regularizer;
122    TFlt Tol, MaxAlpha, MinAlpha, InitAlpha;
123    TStrFltFltHNEDNet InferredNetwork;
124    TIntFltH TotalCascadesAlpha;
125    TIntFltH AveDiffAlphas;
126    THash<TInt, TIntFltH> DiffAlphas;
127    TIntIntPrH SampledCascadesH;
128    TFltPrV PrecisionRecall;
129    TFltPrV Accuracy, MAE, MSE;
130  public:
131    TNIBs( ) { }
132    TNIBs(TSIn& SIn) : CascH(SIn), NodeNmH(SIn), CascPerEdge(SIn), InferredNetwork(SIn) { Model = EXP; }
133    void Save(TSOut& SOut) const { CascH.Save(SOut); NodeNmH.Save(SOut); CascPerEdge.Save(SOut); InferredNetwork.Save(SOut); }
134    void LoadCascadesTxt(TSIn& SIn);
135    void LoadGroundTruthTxt(TSIn& SIn);
136    void LoadGroundTruthNodesTxt(TSIn& SIn);
137    void LoadInferredTxt(TSIn& SIn);
138    void LoadInferredNodesTxt(TSIn& SIn);
139    void SetTotalTime(const float& tt) { TotalTime = tt; }
140    void SetModel(const TModel& model) { Model = model; }
141    void SetWindow(const double& window) { Window = window; }
142    void SetDelta(const double& delta) { Delta = delta; }
143    void SetK(const double& k) { K = k; }
144    void SetGamma(const double& gamma) { Gamma = gamma; }
145    void SetAging(const double& aging) { Aging = aging; }
146    void SetRegularizer(const TRegularizer& reg) { Regularizer = reg; }
147    void SetMu(const double& mu) { Mu = mu; }
148    void SetTolerance(const double& tol) { Tol = tol; }
149    void SetMaxAlpha(const double& ma) { MaxAlpha = ma; }
150    void SetMinAlpha(const double& ma) { MinAlpha = ma; }
151    void SetInitAlpha(const double& ia) { InitAlpha = ia; }
152    void AddCasc(const TStr& CascStr, const TModel& Model=EXP);
153    void AddCasc(const TCascade& Cascade) { CascH.AddDat(Cascade.CId) = Cascade; }
154    void AddCasc(const TIntFltH& Cascade, const int& CId=-1, const TModel& Model=EXP);
155    void GenCascade(TCascade& C);
156    bool IsCascade(int c) { return CascH.IsKey(c); }
157    TCascade & GetCasc(int c) { return CascH.GetDat(c); }
158    int GetCascs() { return CascH.Len(); }
159    int GetCascadeId(const TStr& Cascade) { return CascadeIdH.GetDat(Cascade); }
160    int GetNodes() { return InferredNetwork.GetNodes(); }
161    void AddNodeNm(const int& NId, const TNodeInfo& Info) { NodeNmH.AddDat(NId, Info); }
162    TStr GetNodeNm(const int& NId) const { return NodeNmH.GetDat(NId).Name; }
163    TNodeInfo GetNodeInfo(const int& NId) const { return NodeNmH.GetDat(NId); }
164    bool IsNodeNm(const int& NId) const { return NodeNmH.IsKey(NId); }
165    void SortNodeNmByVol(const bool& asc=false) { NodeNmH.SortByDat(asc); }
166    void AddDomainNm(const TStr& Domain, const int& DomainId=-1) { DomainsIdH.AddDat(Domain) = TInt(DomainId==-1? DomainsIdH.Len() : DomainId); }
167    bool IsDomainNm(const TStr& Domain) const { return DomainsIdH.IsKey(Domain); }
168    int GetDomainId(const TStr& Domain) { return DomainsIdH.GetDat(Domain); }
169    void GetGroundTruthGraphAtT(const double& Step, PNGraph &GraphAtT);
170    void GetGroundTruthNetworkAtT(const double& Step, PStrFltNEDNet& NetworkAtT);
171    void GetInferredGraphAtT(const double& Step, PNGraph &GraphAtT);
172    void GetInferredNetworkAtT(const double& Step, PStrFltNEDNet& NetworkAtT);
173    void Reset();
174    void Init(const TFltV& Steps);
175    void SG(const int& NId, const int& Iters, const TFltV& Steps, const TSampling& Sampling, const TStr& ParamSampling=TStr(""), const bool& PlotPerformance=false);
176    void BSG(const int& NId, const int& Iters, const TFltV& Steps, const int& BatchLen, const TSampling& Sampling, const TStr& ParamSampling=TStr(""), const bool& PlotPerformance=false);
177    void FG(const int& NId, const int& Iters, const TFltV& Steps);
178    void UpdateDiff(const TOptMethod& OptMethod, const int& NId, TCascade& Cascade, TIntPrV& AlphasToUpdate, const double& CurrentTime=TFlt::Mx);
179    void find_C( int t, TFltV &x, TFltVV &C, const int& k, const double& s, const double& gamma, const double& T );
180    void find_min_state( TFltVV &C, TIntV &states, const int& k, const double& s, const double& gamma, const double& T );
181    void LabelBurstAutomaton(const int& SrcId, const int& DstId, TIntV &state_labels, TFltV &state_times, const bool& inferred=false, const int& k = 5, const double& s = 2.0, const double& gamma = 1.0, const TSecTm& MinTime=TSecTm(), const TSecTm& MaxTime=TSecTm() );
182    void ComputePerformanceNId(const int& NId, const int& Step, const TFltV& Steps);
183    void SaveInferredPajek(const TStr& OutFNm, const double& Step, const TIntV& NIdV=TIntV());
184    void SaveInferred(const TStr& OutFNm, const TIntV& NIdV=TIntV());
185    void SaveInferred(const TStr& OutFNm, const double& Step, const TIntV& NIdV=TIntV());
<span onclick='openModal()' class='match'>186    void SaveInferredEdges(const TStr& OutFNm);
187    void SaveGroundTruthPajek(const TStr& OutFNm, const double& Step);
188    void SaveGroundTruth(const TStr& OutFNm);
189    void SaveSites(const TStr& OutFNm, const TIntFltVH& CascadesPerNode=TIntFltVH());
</span>190    void SaveCascades(const TStr& OutFNm);
191  };
192  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ledger.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cascdynetinf.h</div>
                </div>
                <div class="column column_space"><pre><code>48  	std::string block_text (nano::block_hash const &);
49  	bool is_send (nano::transaction const &, nano::block const &) const;
50  	nano::account const & block_destination (nano::transaction const &, nano::block const &);
51  	nano::block_hash block_source (nano::transaction const &, nano::block const &);
</pre></code></div>
                <div class="column column_space"><pre><code>186    void SaveInferredEdges(const TStr& OutFNm);
187    void SaveGroundTruthPajek(const TStr& OutFNm, const double& Step);
188    void SaveGroundTruth(const TStr& OutFNm);
189    void SaveSites(const TStr& OutFNm, const TIntFltVH& CascadesPerNode=TIntFltVH());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    