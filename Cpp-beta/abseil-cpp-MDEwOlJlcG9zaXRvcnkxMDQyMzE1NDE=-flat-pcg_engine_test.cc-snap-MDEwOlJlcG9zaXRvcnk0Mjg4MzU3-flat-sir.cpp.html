
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1720856463124503%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-pcg_engine_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/pcg_engine.h"
2  #include <algorithm>
3  #include <bitset>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/random/internal/explicit_seed_seq.h"
9  #include "absl/time/clock.h"
10  #define UPDATE_GOLDEN 0
11  namespace {
12  using absl::random_internal::ExplicitSeedSeq;
13  using absl::random_internal::pcg32_2018_engine;
14  using absl::random_internal::pcg64_2018_engine;
15  template <typename EngineType>
16  class PCGEngineTest : public ::testing::Test {};
17  using EngineTypes = ::testing::Types<pcg64_2018_engine, pcg32_2018_engine>;
18  TYPED_TEST_SUITE(PCGEngineTest, EngineTypes);
19  TYPED_TEST(PCGEngineTest, VerifyReseedChangesAllValues) {
20    using engine_type = TypeParam;
21    using result_type = typename engine_type::result_type;
22    const size_t kNumOutputs = 16;
23    engine_type engine;
24    {
25      std::seed_seq seq1{1, 2, 3, 4, 5, 6, 7};
26      engine.seed(seq1);
27    }
28    result_type a[kNumOutputs];
29    std::generate(std::begin(a), std::end(a), std::ref(engine));
30    {
31      std::random_device rd;
32      std::seed_seq seq2{rd(), rd(), rd()};
33      engine.seed(seq2);
34    }
35    result_type b[kNumOutputs];
<span onclick='openModal()' class='match'>36    std::generate(std::begin(b), std::end(b), std::ref(engine));
37    size_t changed_bits = 0;
38    size_t unchanged_bits = 0;
39    size_t total_set = 0;
40    size_t total_bits = 0;
</span>41    size_t equal_count = 0;
42    for (size_t i = 0; i < kNumOutputs; ++i) {
43      equal_count += (a[i] == b[i]) ? 1 : 0;
44      std::bitset<sizeof(result_type) * 8> bitset(a[i] ^ b[i]);
45      changed_bits += bitset.count();
46      unchanged_bits += bitset.size() - bitset.count();
47      std::bitset<sizeof(result_type) * 8> a_set(a[i]);
48      std::bitset<sizeof(result_type) * 8> b_set(b[i]);
49      total_set += a_set.count() + b_set.count();
50      total_bits += 2 * 8 * sizeof(result_type);
51    }
52    EXPECT_LE(changed_bits, 0.60 * (changed_bits + unchanged_bits));
53    EXPECT_GE(changed_bits, 0.40 * (changed_bits + unchanged_bits));
54    EXPECT_NEAR(total_set, total_bits * 0.5, 4 * std::sqrt(total_bits))
55        << "@" << total_set / static_cast<double>(total_bits);
56    const double kExpected = kNumOutputs / (1.0 * sizeof(result_type) * 8);
57    EXPECT_LE(equal_count, 1.0 + kExpected);
58  }
59  constexpr size_t kTwoBufferValues = 16;
60  TYPED_TEST(PCGEngineTest, VerifyDiscard) {
61    using engine_type = TypeParam;
62    for (size_t num_used = 0; num_used < kTwoBufferValues; ++num_used) {
63      engine_type engine_used;
64      for (size_t i = 0; i < num_used; ++i) {
65        engine_used();
66      }
67      for (size_t num_discard = 0; num_discard < kTwoBufferValues;
68           ++num_discard) {
69        engine_type engine1 = engine_used;
70        engine_type engine2 = engine_used;
71        for (size_t i = 0; i < num_discard; ++i) {
72          engine1();
73        }
74        engine2.discard(num_discard);
75        for (size_t i = 0; i < kTwoBufferValues; ++i) {
76          const auto r1 = engine1();
77          const auto r2 = engine2();
78          ASSERT_EQ(r1, r2) << "used=" << num_used << " discard=" << num_discard;
79        }
80      }
81    }
82  }
83  TYPED_TEST(PCGEngineTest, StreamOperatorsResult) {
84    using engine_type = TypeParam;
85    std::wostringstream os;
86    std::wistringstream is;
87    engine_type engine;
88    EXPECT_EQ(&(os << engine), &os);
89    EXPECT_EQ(&(is >> engine), &is);
90  }
91  TYPED_TEST(PCGEngineTest, StreamSerialization) {
92    using engine_type = TypeParam;
93    for (size_t discard = 0; discard < kTwoBufferValues; ++discard) {
94      ExplicitSeedSeq seed_sequence{12, 34, 56};
95      engine_type engine(seed_sequence);
96      engine.discard(discard);
97      std::stringstream stream;
98      stream << engine;
99      engine_type new_engine;
100      stream >> new_engine;
101      for (size_t i = 0; i < 64; ++i) {
102        EXPECT_EQ(engine(), new_engine()) << " " << i;
103      }
104    }
105  }
106  constexpr size_t kNumGoldenOutputs = 127;
107  TYPED_TEST(PCGEngineTest, RandomNumberEngineInterface) {
108    using engine_type = TypeParam;
109    using E = engine_type;
110    using T = typename E::result_type;
111    static_assert(std::is_copy_constructible<E>::value,
112                  "engine_type must be copy constructible");
113    static_assert(absl::is_copy_assignable<E>::value,
114                  "engine_type must be copy assignable");
115    static_assert(std::is_move_constructible<E>::value,
116                  "engine_type must be move constructible");
117    static_assert(absl::is_move_assignable<E>::value,
118                  "engine_type must be move assignable");
119    static_assert(std::is_same<decltype(std::declval<E>()()), T>::value,
120                  "return type of operator() must be result_type");
121    E e, v;
122    const E x, y;
123    T s = 1;
124    std::seed_seq q{1, 2, 3};
125    unsigned long long z = 1;  
126    std::wostringstream os;
127    std::wistringstream is;
128    E{};
129    E{x};
130    E{s};
131    E{q};
132    e.seed();
133    EXPECT_TRUE(e == x);
134    e.seed(q);
135    {
136      E tmp(q);
137      EXPECT_TRUE(e == tmp);
138    }
139    e();
140    {
141      E tmp(q);
142      EXPECT_TRUE(e != tmp);
143    }
144    e.discard(z);
145    static_assert(std::is_same<decltype(x == y), bool>::value,
146                  "return type of operator== must be bool");
147    static_assert(std::is_same<decltype(x != y), bool>::value,
148                  "return type of operator== must be bool");
149  }
150  TYPED_TEST(PCGEngineTest, RandenEngineSFINAETest) {
151    using engine_type = TypeParam;
152    using result_type = typename engine_type::result_type;
153    {
154      engine_type engine(result_type(1));
155      engine.seed(result_type(1));
156    }
157    {
158      result_type n = 1;
159      engine_type engine(n);
160      engine.seed(n);
161    }
162    {
163      engine_type engine(1);
164      engine.seed(1);
165    }
166    {
167      int n = 1;
168      engine_type engine(n);
169      engine.seed(n);
170    }
171    {
172      std::seed_seq seed_seq;
173      engine_type engine(seed_seq);
174      engine.seed(seed_seq);
175    }
176    {
177      engine_type engine{std::seed_seq()};
178      engine.seed(std::seed_seq());
179    }
180  }
181  TEST(PCG642018EngineTest, VerifyGolden) {
182    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
183        0x01070196e695f8f1, 0x703ec840c59f4493, 0xe54954914b3a44fa,
184        0x96130ff204b9285e, 0x7d9fdef535ceb21a, 0x666feed42e1219a0,
185        0x981f685721c8326f, 0xad80710d6eab4dda, 0xe202c480b037a029,
186        0x5d3390eaedd907e2, 0x0756befb39c6b8aa, 0x1fb44ba6634d62a3,
187        0x8d20423662426642, 0x34ea910167a39fb4, 0x93010b43a80d0ab6,
188        0x663db08a98fc568a, 0x720b0a1335956fae, 0x2c35483e31e1d3ba,
189        0x429f39776337409d, 0xb46d99e638687344, 0x105370b96aedcaee,
190        0x3999e92f811cff71, 0xd230f8bcb591cfc9, 0x0dce3db2ba7bdea5,
191        0xcf2f52c91eec99af, 0x2bc7c24a8b998a39, 0xbd8af1b0d599a19c,
192        0x56bc45abc66059f5, 0x170a46dc170f7f1e, 0xc25daf5277b85fad,
193        0xe629c2e0c948eadb, 0x1720a796915542ed, 0x22fb0caa4f909951,
194        0x7e0c0f4175acd83d, 0xd9fcab37ff2a860c, 0xab2280fb2054bad1,
195        0x58e8a06f37fa9e99, 0xc3a52a30b06528c7, 0x0175f773a13fc1bd,
196        0x731cfc584b00e840, 0x404cc7b2648069cb, 0x5bc29153b0b7f783,
197        0x771310a38cc999d1, 0x766a572f0a71a916, 0x90f450fb4fc48348,
198        0xf080ea3e1c7b1a0d, 0x15471a4507d66a44, 0x7d58e55a78f3df69,
199        0x0130a094576ac99c, 0x46669cb2d04b1d87, 0x17ab5bed20191840,
200        0x95b177d260adff3e, 0x025fb624b6ee4c07, 0xb35de4330154a95f,
201        0xe8510fff67e24c79, 0x132c3cbcd76ed2d3, 0x35e7cc145a093904,
202        0x9f5b5b5f81583b79, 0x3ee749a533966233, 0x4af85886cdeda8cd,
203        0x0ca5380ecb3ef3aa, 0x4f674eb7661d3192, 0x88a29aad00cd7733,
204        0x70b627ca045ffac6, 0x5912b43ea887623d, 0x95dc9fc6f62cf221,
205        0x926081a12a5c905b, 0x9c57d4cd7dfce651, 0x85ab2cbf23e3bb5d,
206        0xc5cd669f63023152, 0x3067be0fad5d898e, 0x12b56f444cb53d05,
207        0xbc2e5a640c3434fc, 0x9280bff0e4613fe1, 0x98819094c528743e,
208        0x999d1c98d829df33, 0x9ff82a012dc89242, 0xf99183ed39c8be94,
209        0xf0f59161cd421c55, 0x3c705730c2f6c48d, 0x66ad85c6e9278a61,
210        0x2a3428e4a428d5d0, 0x79207d68fd04940d, 0xea7f2b402edc8430,
211        0xa06b419ac857f63b, 0xcb1dd0e6fbc47e1c, 0x4f55229200ada6a4,
212        0x9647b5e6359c927f, 0x30bf8f9197c7efe5, 0xa79519529cc384d0,
213        0xbb22c4f339ad6497, 0xd7b9782f59d14175, 0x0dff12fff2ec0118,
214        0xa331ad8305343a7c, 0x48dad7e3f17e0862, 0x324c6fb3fd3c9665,
215        0xf0e4350e7933dfc4, 0x7ccda2f30b8b03b6, 0xa0afc6179005de40,
216        0xee65da6d063b3a30, 0xb9506f42f2bfe87a, 0xc9a2e26b0ef5baa0,
217        0x39fa9d4f495011d6, 0xbecc21a45d023948, 0x6bf484c6593f737f,
218        0x8065e0070cadc3b7, 0x9ef617ed8d419799, 0xac692cf8c233dd15,
219        0xd2ed87583c4ebb98, 0xad95ba1bebfedc62, 0x9b60b160a8264e43,
220        0x0bc8c45f71fcf25b, 0x4a78035cdf1c9931, 0x4602dc106667e029,
221        0xb335a3c250498ac8, 0x0256ebc4df20cab8, 0x0c61efd153f0c8d9,
222        0xe5d0150a4f806f88, 0x99d6521d351e7d87, 0x8d4888c9f80f4325,
223        0x106c5735c1ba868d, 0x73414881b880a878, 0x808a9a58a3064751,
224        0x339a29f3746de3d5, 0x5410d7fa4f873896, 0xd84623c81d7b8a03,
225        0x1f7c7e7a7f47f462,
226    };
227    pcg64_2018_engine engine(0);
228  #if UPDATE_GOLDEN
229    (void)kGolden;  
230    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
231      printf("0x%016lx, ", engine());
232      if (i % 3 == 2) {
233        printf("\n");
234      }
235    }
236    printf("\n\n\n");
237  #else
238    for (const auto& elem : kGolden) {
239      EXPECT_EQ(elem, engine());
240    }
241    engine.seed();
242    for (const auto& elem : kGolden) {
243      EXPECT_EQ(elem, engine());
244    }
245  #endif
246  }
247  TEST(PCG642018EngineTest, VerifyGoldenSeeded) {
248    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
249        0xb03988f1e39691ee, 0xbd2a1eb5ac31e97a, 0x8f00d6d433634d02,
250        0x1823c28d483d5776, 0x000c3ee3e1aeb74a, 0xfa82ef27a4f3df9c,
251        0xc6f382308654e454, 0x414afb1a238996c2, 0x4703a4bc252eb411,
252        0x99d64f62c8f7f654, 0xbb07ebe11a34fa44, 0x79eb06a363c06131,
253        0xf66ad3756f1c6b21, 0x130c01d5e869f457, 0x5ca2b9963aecbc81,
254        0xfef7bebc1de27e6c, 0x1d174faa5ed2cdbf, 0xd75b7a773f2bb889,
255        0xc35c872327a170a5, 0x46da6d88646a42fe, 0x4622985e0442dae2,
256        0xbe3cbd67297f1f9b, 0xe7c37b4a4798bfd1, 0x173d5dfad15a25c3,
257        0x0eb6849ba2961522, 0xb0ff7246e6700d73, 0x88cb9c42d3afa577,
258        0xb609731dbd94d917, 0xd3941cda04b40081, 0x28d140f7409bea3a,
259        0x3c96699a920a124a, 0xdb28be521958b2fd, 0x0a3f44db3d4c5124,
260        0x7ac8e60ba13b70d2, 0x75f03a41ded5195a, 0xaed10ac7c4e4825d,
261        0xb92a3b18aadb7adc, 0xda45e0081f2bca46, 0x74d39ab3753143fc,
262        0xb686038018fac9ca, 0x4cc309fe99542dbb, 0xf3e1a4fcb311097c,
263        0x58763d6fa698d69d, 0xd11c365dbecd8d60, 0x2c15d55725b1dee7,
264        0x89805f254d85658c, 0x2374c44dfc62158b, 0x9a8350fa7995328d,
265        0x198f838970cf91da, 0x96aff569562c0e53, 0xd76c8c52b7ec6e3f,
266        0x23a01cd9ae4baa81, 0x3adb366b6d02a893, 0xb3313e2a4c5b333f,
267        0x04c11230b96a5425, 0x1f7f7af04787d571, 0xaddb019365275ec7,
268        0x5c960468ccb09f42, 0x8438db698c69a44a, 0x492be1e46111637e,
269        0x9c6c01e18100c610, 0xbfe48e75b7d0aceb, 0xb5e0b89ec1ce6a00,
270        0x9d280ecbc2fe8997, 0x290d9e991ba5fcab, 0xeec5bec7d9d2a4f0,
271        0x726e81488f19150e, 0x1a6df7955a7e462c, 0x37a12d174ba46bb5,
272        0x3cdcdffd96b1b5c5, 0x2c5d5ac10661a26e, 0xa742ed18f22e50c4,
273        0x00e0ed88ff0d8a35, 0x3d3c1718cb1efc0b, 0x1d70c51ffbccbf11,
274        0xfbbb895132a4092f, 0x619d27f2fb095f24, 0x69af68200985e5c4,
275        0xbee4885f57373f8d, 0x10b7a6bfe0587e40, 0xa885e6cf2f7e5f0a,
276        0x59f879464f767550, 0x24e805d69056990d, 0x860970b911095891,
277        0xca3189954f84170d, 0x6652a5edd4590134, 0x5e1008cef76174bf,
278        0xcbd417881f2bcfe5, 0xfd49fc9d706ecd17, 0xeebf540221ebd066,
279        0x46af7679464504cb, 0xd4028486946956f1, 0xd4f41864b86c2103,
280        0x7af090e751583372, 0x98cdaa09278cb642, 0xffd42b921215602f,
281        0x1d05bec8466b1740, 0xf036fa78a0132044, 0x787880589d1ecc78,
282        0x5644552cfef33230, 0x0a97e275fe06884b, 0x96d1b13333d470b5,
283        0xc8b3cdad52d3b034, 0x091357b9db7376fd, 0xa5fe4232555edf8c,
284        0x3371bc3b6ada76b5, 0x7deeb2300477c995, 0x6fc6d4244f2849c1,
285        0x750e8cc797ca340a, 0x81728613cd79899f, 0x3467f4ee6f9aeb93,
286        0x5ef0a905f58c640f, 0x432db85e5101c98a, 0x6488e96f46ac80c2,
287        0x22fddb282625048c, 0x15b287a0bc2d4c5d, 0xa7e2343ef1f28bce,
288        0xc87ee1aa89bed09e, 0x220610107812c5e9, 0xcbdab6fcd640f586,
289        0x8d41047970928784, 0x1aa431509ec1ade0, 0xac3f0be53f518ddc,
290        0x16f4428ad81d0cbb, 0x675b13c2736fc4bb, 0x6db073afdd87e32d,
291        0x572f3ca2f1a078c6,
292    };
293    ExplicitSeedSeq seed_sequence{12, 34, 56};
294    pcg64_2018_engine engine(seed_sequence);
295  #if UPDATE_GOLDEN
296    (void)kGolden;  
297    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
298      printf("0x%016lx, ", engine());
299      if (i % 3 == 2) {
300        printf("\n");
301      }
302    }
303    printf("\n\n\n");
304  #else
305    for (const auto& elem : kGolden) {
306      EXPECT_EQ(elem, engine());
307    }
308    engine.seed(seed_sequence);
309    for (const auto& elem : kGolden) {
310      EXPECT_EQ(elem, engine());
311    }
312  #endif
313  }
314  TEST(PCG642018EngineTest, VerifyGoldenFromDeserializedEngine) {
315    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
316        0xdd425b47b4113dea, 0x1b07176479d444b0, 0x6b391027586f2e42,
317        0xa166f2b15f4a2143, 0xffb6dbd7a179ee97, 0xb2c00035365bf0b1,
318        0x8fbb518b45855521, 0xfc789a55ddf87c3b, 0x429531f0f17ff355,
319        0xbe708560d603d283, 0x5bff415175c5cb6b, 0xe813491f4ad45394,
320        0xa853f4506d55880d, 0x7e538453e568172e, 0xe101f1e098ddd0ec,
321        0x6ee31266ee4c766d, 0xa8786d92d66b39d7, 0xfee622a2acf5e5b0,
322        0x5fe8e82c102fa7b3, 0x01f10be4cdb53c9d, 0xbe0545366f857022,
323        0x12e74f010a339bca, 0xb10d85ca40d5ce34, 0xe80d6feba5054875,
324        0x2b7c1ee6d567d4ee, 0x2a9cd043bfd03b66, 0x5cfc531bd239f3f1,
325        0x1c4734e4647d70f5, 0x85a8f60f006b5760, 0x6a4239ce76dca387,
326        0x8da0f86d7339335c, 0xf055b0468551374d, 0x486e8567e9bea9a0,
327        0x4cb531b8405192dd, 0xf813b1ee3157110b, 0x214c2a664a875d8e,
328        0x74531237b29b35f7, 0xa6f0267bb77a771e, 0x64b552bff54184a4,
329        0xa2d6f7af2d75b6fc, 0x460a10018e03b5ab, 0x76fd1fdcb81d0800,
330        0x76f5f81805070d9d, 0x1fb75cb1a70b289a, 0x9dfd25a022c4b27f,
331        0x9a31a14a80528e9e, 0x910dc565ddc25820, 0xd6aef8e2b0936c10,
332        0xe1773c507fe70225, 0xe027fd7aadd632bc, 0xc1fecb427089c8b8,
333        0xb5c74c69fa9dbf26, 0x71bf9b0e4670227d, 0x25f48fad205dcfdd,
334        0x905248ec4d689c56, 0x5c2b7631b0de5c9d, 0x9f2ee0f8f485036c,
335        0xfd6ce4ebb90bf7ea, 0xd435d20046085574, 0x6b7eadcb0625f986,
336        0x679d7d44b48be89e, 0x49683b8e1cdc49de, 0x4366cf76e9a2f4ca,
337        0x54026ec1cdad7bed, 0xa9a04385207f28d3, 0xc8e66de4eba074b2,
338        0x40b08c42de0f4cc0, 0x1d4c5e0e93c5bbc0, 0x19b80792e470ae2d,
339        0x6fcaaeaa4c2a5bd9, 0xa92cb07c4238438e, 0x8bb5c918a007e298,
340        0x7cd671e944874cf4, 0x88166470b1ba3cac, 0xd013d476eaeeade6,
341        0xcee416947189b3c3, 0x5d7c16ab0dce6088, 0xd3578a5c32b13d27,
342        0x3875db5adc9cc973, 0xfbdaba01c5b5dc56, 0xffc4fdd391b231c3,
343        0x2334520ecb164fec, 0x361c115e7b6de1fa, 0xeee58106cc3563d7,
344        0x8b7f35a8db25ebb8, 0xb29d00211e2cafa6, 0x22a39fe4614b646b,
345        0x92ca6de8b998506d, 0x40922fe3d388d1db, 0x9da47f1e540f802a,
346        0x811dceebf16a25db, 0xf6524ae22e0e53a9, 0x52d9e780a16eb99d,
347        0x4f504286bb830207, 0xf6654d4786bd5cc3, 0x00bd98316003a7e1,
348        0xefda054a6ab8f5f3, 0x46cfb0f4c1872827, 0xc22b316965c0f3b2,
349        0xd1a28087c7e7562a, 0xaa4f6a094b7f5cff, 0xfe2bc853a041f7da,
350        0xe9d531402a83c3ba, 0xe545d8663d3ce4dd, 0xfa2dcd7d91a13fa8,
351        0xda1a080e52a127b8, 0x19c98f1f809c3d84, 0x2cef109af4678c88,
352        0x53462accab3b9132, 0x176b13a80415394e, 0xea70047ef6bc178b,
353        0x57bca80506d6dcdf, 0xd853ba09ff09f5c4, 0x75f4df3a7ddd4775,
354        0x209c367ade62f4fe, 0xa9a0bbc74d5f4682, 0x5dfe34bada86c21a,
355        0xc2c05bbcd38566d1, 0x6de8088e348c916a, 0x6a7001c6000c2196,
356        0xd9fb51865fc4a367, 0x12f320e444ece8ff, 0x6d56f7f793d65035,
357        0x138f31b7a865f8aa, 0x58fc68b4026b9adf, 0xcd48954b79fb6436,
358        0x27dfce4a0232af87,
359    };
360  #if UPDATE_GOLDEN
361    (void)kGolden;  
362    std::seed_seq seed_sequence{1, 2, 3};
363    pcg64_2018_engine engine(seed_sequence);
364    std::ostringstream stream;
365    stream << engine;
366    auto str = stream.str();
367    printf("%s\n\n", str.c_str());
368    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
369      printf("0x%016lx, ", engine());
370      if (i % 3 == 2) {
371        printf("\n");
372      }
373    }
374    printf("\n\n\n");
375  #else
376    pcg64_2018_engine engine;
377    std::istringstream stream(
378        "2549297995355413924 4865540595714422341 6364136223846793005 "
379        "1442695040888963407 18088519957565336995 4845369368158826708");
380    stream >> engine;
381    for (const auto& elem : kGolden) {
382      EXPECT_EQ(elem, engine());
383    }
384  #endif
385  }
386  TEST(PCG322018EngineTest, VerifyGolden) {
387    constexpr uint32_t kGolden[kNumGoldenOutputs] = {
388        0x7a7ecbd9, 0x89fd6c06, 0xae646aa8, 0xcd3cf945, 0x6204b303, 0x198c8585,
389        0x49fce611, 0xd1e9297a, 0x142d9440, 0xee75f56b, 0x473a9117, 0xe3a45903,
390        0xbce807a1, 0xe54e5f4d, 0x497d6c51, 0x61829166, 0xa740474b, 0x031912a8,
391        0x9de3defa, 0xd266dbf1, 0x0f38bebb, 0xec3c4f65, 0x07c5057d, 0xbbce03c8,
392        0xfd2ac7a8, 0xffcf4773, 0x5b10affb, 0xede1c842, 0xe22b01b7, 0xda133c8c,
393        0xaf89b0f4, 0x25d1b8bc, 0x9f625482, 0x7bfd6882, 0x2e2210c0, 0x2c8fb9a6,
394        0x42cb3b83, 0x40ce0dab, 0x644a3510, 0x36230ef2, 0xe2cb6d43, 0x1012b343,
395        0x746c6c9f, 0x36714cf8, 0xed1f5026, 0x8bbbf83e, 0xe98710f4, 0x8a2afa36,
396        0x09035349, 0x6dc1a487, 0x682b634b, 0xc106794f, 0x7dd78beb, 0x628c262b,
397        0x852fb232, 0xb153ac4c, 0x4f169d1b, 0xa69ab774, 0x4bd4b6f2, 0xdc351dd3,
398        0x93ff3c8c, 0xa30819ab, 0xff07758c, 0x5ab13c62, 0xd16d7fb5, 0xc4950ffa,
399        0xd309ae49, 0xb9677a87, 0x4464e317, 0x90dc44f1, 0xc694c1d4, 0x1d5e1168,
400        0xadf37a2d, 0xda38990d, 0x1ec4bd33, 0x36ca25ce, 0xfa0dc76a, 0x968a9d43,
401        0x6950ac39, 0xdd3276bc, 0x06d5a71e, 0x1f6f282d, 0x5c626c62, 0xdde3fc31,
402        0x152194ce, 0xc35ed14c, 0xb1f7224e, 0x47f76bb8, 0xb34fdd08, 0x7011395e,
403        0x162d2a49, 0x0d1bf09f, 0x9428a952, 0x03c5c344, 0xd3525616, 0x7816fff3,
404        0x6bceb8a8, 0x8345a081, 0x366420fd, 0x182abeda, 0x70f82745, 0xaf15ded8,
405        0xc7f52ca2, 0xa98db9c5, 0x919d99ba, 0x9c376c1c, 0xed8d34c2, 0x716ae9f5,
406        0xef062fa5, 0xee3b6c56, 0x52325658, 0x61afa9c3, 0xfdaf02f0, 0x961cf3ab,
407        0x9f291565, 0x4fbf3045, 0x0590c899, 0xde901385, 0x45005ffb, 0x509db162,
408        0x262fa941, 0x4c421653, 0x4b17c21e, 0xea0d1530, 0xde803845, 0x61bfd515,
409        0x438523ef,
410    };
411    pcg32_2018_engine engine(0);
412  #if UPDATE_GOLDEN
413    (void)kGolden;  
414    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
415      printf("0x%08x, ", engine());
416      if (i % 6 == 5) {
417        printf("\n");
418      }
419    }
420    printf("\n\n\n");
421  #else
422    for (const auto& elem : kGolden) {
423      EXPECT_EQ(elem, engine());
424    }
425    engine.seed();
426    for (const auto& elem : kGolden) {
427      EXPECT_EQ(elem, engine());
428    }
429  #endif
430  }
431  TEST(PCG322018EngineTest, VerifyGoldenSeeded) {
432    constexpr uint32_t kGolden[kNumGoldenOutputs] = {
433        0x60b5a64c, 0x978502f9, 0x80a75f60, 0x241f1158, 0xa4cd1dbb, 0xe7284017,
434        0x3b678da5, 0x5223ec99, 0xe4bdd5d9, 0x72190e6d, 0xe6e702c9, 0xff80c768,
435        0xcf126ed3, 0x1fbd20ab, 0x60980489, 0xbc72bf89, 0x407ac6c0, 0x00bf3c51,
436        0xf9087897, 0x172e4eb6, 0xe9e4f443, 0x1a6098bf, 0xbf44f8c2, 0xdd84a0e5,
437        0xd9a52364, 0xc0e2e786, 0x061ae2ba, 0x9facb8e3, 0x6109432d, 0xd4e0a013,
438        0xbd8eb9a6, 0x7e86c3b6, 0x629c0e68, 0x05337430, 0xb495b9f4, 0x11ccd65d,
439        0xb578db25, 0x66f1246d, 0x6ef20a7f, 0x5e429812, 0x11772130, 0xb944b5c2,
440        0x01624128, 0xa2385ab7, 0xd3e10d35, 0xbe570ec3, 0xc951656f, 0xbe8944a0,
441        0x7be41062, 0x5709f919, 0xd745feda, 0x9870b9ae, 0xb44b8168, 0x19e7683b,
442        0xded8017f, 0xc6e4d544, 0x91ae4225, 0xd6745fba, 0xb992f284, 0x65b12b33,
443        0xa9d5fdb4, 0xf105ce1a, 0x35ca1a6e, 0x2ff70dd0, 0xd8335e49, 0xfb71ddf2,
444        0xcaeabb89, 0x5c6f5f84, 0x9a811a7d, 0xbcecbbd1, 0x0f661ba0, 0x9ad93b9d,
445        0xedd23e0b, 0x42062f48, 0xd38dd7e4, 0x6cd63c9c, 0x640b98ae, 0x4bff5653,
446        0x12626371, 0x13266017, 0xe7a698d8, 0x39c74667, 0xe8fdf2e3, 0x52803bf8,
447        0x2af6895b, 0x91335b7b, 0x699e4961, 0x00a40fff, 0x253ff2b6, 0x4a6cf672,
448        0x9584e85f, 0xf2a5000c, 0x4d58aba8, 0xb8513e6a, 0x767fad65, 0x8e326f9e,
449        0x182f15a1, 0x163dab52, 0xdf99c780, 0x047282a1, 0xee4f90dd, 0xd50394ae,
450        0x6c9fd5f0, 0xb06a9194, 0x387e3840, 0x04a9487b, 0xf678a4c2, 0xd0a78810,
451        0xd502c97e, 0xd6a9b12a, 0x4accc5dc, 0x416ed53e, 0x50411536, 0xeeb89c24,
452        0x813a7902, 0x034ebca6, 0xffa52e7c, 0x7ecd3d0e, 0xfa37a0d2, 0xb1fbe2c1,
453        0xb7efc6d1, 0xefa4ccee, 0xf6f80424, 0x2283f3d9, 0x68732284, 0x94f3b5c8,
454        0xbbdeceb9,
455    };
456    ExplicitSeedSeq seed_sequence{12, 34, 56};
457    pcg32_2018_engine engine(seed_sequence);
458  #if UPDATE_GOLDEN
459    (void)kGolden;  
460    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
461      printf("0x%08x, ", engine());
462      if (i % 6 == 5) {
463        printf("\n");
464      }
465    }
466    printf("\n\n\n");
467  #else
468    for (const auto& elem : kGolden) {
469      EXPECT_EQ(elem, engine());
470    }
471    engine.seed(seed_sequence);
472    for (const auto& elem : kGolden) {
473      EXPECT_EQ(elem, engine());
474    }
475  #endif
476  }
477  TEST(PCG322018EngineTest, VerifyGoldenFromDeserializedEngine) {
478    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
479        0x780f7042, 0xba137215, 0x43ab6f22, 0x0cb55f46, 0x44b2627d, 0x835597af,
480        0xea973ea1, 0x0d2abd35, 0x4fdd601c, 0xac4342fe, 0x7db7e93c, 0xe56ebcaf,
481        0x3596470a, 0x7770a9ad, 0x9b893320, 0x57db3415, 0xb432de54, 0xa02baf71,
482        0xa256aadb, 0x88921fc7, 0xa35fa6b3, 0xde3eca46, 0x605739a7, 0xa890b82b,
483        0xe457b7ad, 0x335fb903, 0xeb06790c, 0xb3c54bf6, 0x6141e442, 0xa599a482,
484        0xb78987cc, 0xc61dfe9d, 0x0f1d6ace, 0x17460594, 0x8f6a5061, 0x083dc354,
485        0xe9c337fb, 0xcfd105f7, 0x926764b6, 0x638d24dc, 0xeaac650a, 0x67d2cb9c,
486        0xd807733c, 0x205fc52e, 0xf5399e2e, 0x6c46ddcc, 0xb603e875, 0xce113a25,
487        0x3c8d4813, 0xfb584db8, 0xf6d255ff, 0xea80954f, 0x42e8be85, 0xb2feee72,
488        0x62bd8d16, 0x1be4a142, 0x97dca1a4, 0xdd6e7333, 0xb2caa20e, 0xa12b1588,
489        0xeb3a5a1a, 0x6fa5ba89, 0x077ea931, 0x8ddb1713, 0x0dd03079, 0x2c2ba965,
490        0xa77fac17, 0xc8325742, 0x8bb893bf, 0xc2315741, 0xeaceee92, 0x81dd2ee2,
491        0xe5214216, 0x1b9b8fb2, 0x01646d03, 0x24facc25, 0xd8c0e0bb, 0xa33fe106,
492        0xf34fe976, 0xb3b4b44e, 0x65618fed, 0x032c6192, 0xa9dd72ce, 0xf391887b,
493        0xf41c6a6e, 0x05c4bd6d, 0x37fa260e, 0x46b05659, 0xb5f6348a, 0x62d26d89,
494        0x39f6452d, 0xb17b30a2, 0xbdd82743, 0x38ecae3b, 0xfe90f0a2, 0xcb2d226d,
495        0xcf8a0b1c, 0x0eed3d4d, 0xa1f69cfc, 0xd7ac3ba5, 0xce9d9a6b, 0x121deb4c,
496        0x4a0d03f3, 0xc1821ed1, 0x59c249ac, 0xc0abb474, 0x28149985, 0xfd9a82ba,
497        0x5960c3b2, 0xeff00cba, 0x6073aa17, 0x25dc0919, 0x9976626e, 0xdd2ccc33,
498        0x39ecb6ec, 0xc6e15d13, 0xfac94cfd, 0x28cfd34f, 0xf2d2c32d, 0x51c23d08,
499        0x4fdb2f48, 0x97baa807, 0xf2c1004c, 0xc4ae8136, 0x71f31c94, 0x8c92d601,
500        0x36caf5cd,
501    };
502  #if UPDATE_GOLDEN
503    (void)kGolden;  
504    std::seed_seq seed_sequence{1, 2, 3};
505    pcg32_2018_engine engine(seed_sequence);
506    std::ostringstream stream;
507    stream << engine;
508    auto str = stream.str();
509    printf("%s\n\n", str.c_str());
510    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
511      printf("0x%08x, ", engine());
512      if (i % 6 == 5) {
513        printf("\n");
514      }
515    }
516    printf("\n\n\n");
517    EXPECT_FALSE(true);
518  #else
519    pcg32_2018_engine engine;
520    std::istringstream stream(
521        "6364136223846793005 1442695040888963407 6537028157270659894");
522    stream >> engine;
523    for (const auto& elem : kGolden) {
524      EXPECT_EQ(elem, engine());
525    }
526  #endif
527  }
528  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "sir.h"
3  void TEpidemModel::RunModel(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
4    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
5    OutValV.Clr(false);
6    for (int v = 0; v < StartValV.Len(); v++) {
7      OutValV.Add();
8      OutValV[v].Clr(false);
9      OutValV[v].Add(StartValV[v]);
10    }
11    const double h = (StopT-StartT) / NSteps;
12    double x = StartT;
13    for (int k = 0; k < NSteps; k++) {
14      GetDerivs(x, ValV, dydx);
15      RungeKutta(ValV, dydx, x, h, ValV2);
16      for (int v = 0; v < ValV2.Len(); v++) {
17        double X = ValV2[v];
18        if (X < 0 || _isnan(X) || !_finite(X)) { X = 0; }
19        OutValV[v].Add(X);
20      }
21      ValV = ValV2;
22      x += h;
23    }
24  }
25  void TEpidemModel::RunModel10(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
26    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
27    OutValV.Clr(false);
28    for (int v = 0; v < StartValV.Len(); v++) {
29      OutValV.Add();
30      OutValV[v].Clr(false);
31      OutValV[v].Add(StartValV[v]);
32    }
33    const double h = (StopT-StartT) / (10*NSteps);
34    double x = StartT;
35    for (int k = 0; k < 10*NSteps; k++) {
36      GetDerivs(x, ValV, dydx);
37      RungeKutta(ValV, dydx, x, h, ValV2);
38      if (k % 10 == 0) {
39        for (int v = 0; v < ValV2.Len(); v++) {
40          OutValV[v].Add(ValV2[v]); }
41      }
42      ValV = ValV2;
43      x += h;
44    }
45  }
46  void TEpidemModel::RunEuler(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
47    const double h = (StopT-StartT) / NSteps;
48    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
49    for (int v = 0; v < StartValV.Len(); v++) {
50      OutValV.Add();
51      OutValV[v].Clr(false);
52      OutValV[v].Add(StartValV[v]);
53    }
54    OutValV.Add(); 
55    OutValV.Last().Add(StartT);
56    for (double x = StartT; x <= StopT; x += h) {
57      GetDerivs(x, ValV, dydx);
58      for (int v = 0; v < ValV.Len(); v++) {
59        ValV[v] += h*dydx[v];
60        OutValV[v].Add(ValV[v]);
61      }
62      OutValV.Last().Add(x+h);
63    }
64    for (int v = 1; v < OutValV.Len(); v++) {
65      IAssert(OutValV[v].Len()==OutValV[v-1].Len());
66    }
67  }
68  void TEpidemModel::RungeKutta(const TFltV& y, const TFltV& dydx, double x, double h, TFltV& SirOutV) {
69    const int n = y.Len();
70    IAssert(y.Len() == n && dydx.Len() == n);
71    TFltV dym(n), dyt(n), yt(n);
72    int i;
73    double hh=h*0.5;
74    double h6=h/6.0;
75    double xh=x+hh;
76    for (i=0; i < n; i++) {
77      yt[i]=y[i]+hh*dydx[i];
78    }
79    GetDerivs(xh, yt, dyt);
80    for (i=0; i<n; i++) {
81      yt[i]=y[i]+hh*dyt[i];
82    }
83    GetDerivs(xh,yt,dym);
84    for (i=0; i<n; i++) {
85  	  yt[i]=y[i]+h*dym[i];
86  	  dym[i] += dyt[i];
87    }
88    GetDerivs(x+h,yt,dyt);
89    SirOutV.Clr(false);  
90    for (i=0; i<n; i++) {
91      SirOutV.Add(y[i]+h6 * (dydx[i]+dyt[i]+2.0*dym[i]));
92    }
93  }
94  double TEpidemModel::GetErr(const TFltV& TrueV, const TFltV& SimV, const int& SimT0) { 
95    if (SimV.Empty() || TrueV.Empty()) { return -1.0; }
96    double Err = 0.0;
97    double S=0;
98    for (int t=0; t < TrueV.Len(); t++) {
99      if (t-SimT0 >= 0) { S = SimV[t-SimT0]; } else { S = 0; }
100      Err += TMath::Sqr(TrueV[t]-S);
101    }
102    if (Err <= 0) { Err = TFlt::Mx; }
103    return Err;
104  }
105  void TEpidemModel::Plot(const TFltV& TrueV, const TStr& Label1, const TFltV& SimV, const TStr& Label2, const TStr& OutFNm, const TStr& Desc, const TStr& XLabel, const TStr& YLabel) {
106    TGnuPlot GP(OutFNm, Desc);
107    GP.AddPlot(TrueV, gpwLinesPoints, Label1);
108    GP.AddPlot(SimV, gpwLinesPoints, Label2);
109    GP.SetXYLabel(XLabel, YLabel);
110    GP.SavePng();
111  }
112  void TEpidemModel::LoadTxt(const TStr& InFNm, const int& ColId, TFltV& ValV) {
113    ValV.Clr();
114    if (! TFile::Exists(InFNm)) { 
115      printf("*** %s not found!\n", InFNm.CStr());
116      return; 
117    }
118    TSsParser Ss(InFNm, ssfTabSep);
119    while (Ss.Next()) {
120      ValV.Add(Ss.GetFlt(ColId));
121    }
122  }
123  TSirModel::TSirModel(double NZero, TFltTr NZeroP, double IZero, TFltTr IZeroP, double _Beta, TFltTr BetaP, double _Gamma, TFltTr GammaP, int TZero, TFltTr TZeroP, TStr InFNm, int ColId) :
124   N0(NZero), I0(IZero), Beta(_Beta), Gamma(_Gamma), T0(TZero) { 
125    ParamMnMnRngV.Add(NZeroP);
126    ParamMnMnRngV.Add(IZeroP);
127    ParamMnMnRngV.Add(BetaP);
128    ParamMnMnRngV.Add(GammaP);
129    ParamMnMnRngV.Add(TZeroP);
130    TEpidemModel::LoadTxt(InFNm, ColId, TrueInfectV); 
131  }
132  void TSirModel::GetParam(TFltV& ParamV) const { 
133    ParamV.Clr(false); 
134    ParamV.Add(N0);
135    ParamV.Add(I0);
136    ParamV.Add(Beta); 
137    ParamV.Add(Gamma); 
138    ParamV.Add(T0);
139  }
140  void TSirModel::SetParam(const TFltV& ParamV) { 
141    N0 = ParamV[0];
142    I0 = ParamV[1];
143    Beta = ParamV[2]; 
144    Gamma = ParamV[3]; 
145    T0 = int(ParamV[4]); 
146  }
147  void TSirModel::SetPeakT0() {
148    double Max =0;
149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
151      if (TrueInfectV[i] > Max) { 
152        Max=TrueInfectV[i]; 
153        Peak=i;
154      }
155    }
156    T0 = int(0.9*Peak);
157    ParamMnMnRngV[4].Val1 = Peak - 0.5*abs(Peak); 
158    ParamMnMnRngV[4].Val2 = Peak + 0.5*abs(Peak); 
159    printf("Set peak T0 = %d (%g -- %g)\n", Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2);
160  }
161  void TSirModel::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
162    dxdyV[0] = -Beta*SirValV[0]*SirValV[1];
163    dxdyV[1] = Beta*SirValV[0]*SirValV[1] - Gamma*SirValV[1];
164  }
165  double TSirModel::GetErr() const { 
166    return TEpidemModel::GetErr(TrueInfectV, OutValV[1], T0);
167  }
168  double TSirModel::RunCalcErr(const TFltV& ParamV) {
169    SetParam(ParamV);
170    const int EndT = TrueInfectV.Len() - T0 + 2;
171    RunModel(TFltV::GetV(N0-I0, I0), 0, EndT, EndT, OutValV);
172    return GetErr();
173  }
174  void TSirModel::GetParamRange(TFltTrV& ParamMnMxStepV) const {
175    ParamMnMxStepV = ParamMnMnRngV; 
176  }
177  void TSirModel::GetParamNmV(TStrV& ParamNmV) const {
178    ParamNmV = TStrV::GetV("Beta", "Gamma");
179  }
180  void TSirModel::Plot(const TStr& OutFNm, TStr Desc) const {
181    if (OutValV.Empty()) { printf("EMPTY()");  return; }
182    TFltV V2;
183    for (int t=0; t < TrueInfectV.Len(); t++) {
184      if (t-T0 >= 0) { V2.Add(OutValV[1][t-T0]); } else { V2.Add(0); }
185    }
186    TEpidemModel::Plot(TrueInfectV, "TRUE", V2, "SIR model", OutFNm, Desc+" "+GetStr(), "Time", "Number of infected nodes");
187  }
188  void TSirModel::TestEurlerVsRk() {
189  }
190  TSir2Model::TSir2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
191    int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, double _GammaB, TFltTr GammaBP, 
192    double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, TStr InFNm, int ColId1, int ColId2) : N0M(_N0M), I0M(_I0M), N0B(_N0B), I0B(_I0B), T0(_T0), BetaM(_BetaM), 
193    GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM) { 
194    ParamMnMnRngV.Add(N0MP);
195    ParamMnMnRngV.Add(I0MP);
196    ParamMnMnRngV.Add(N0BP);
197    ParamMnMnRngV.Add(I0BP);
198    ParamMnMnRngV.Add(T0P);
199    ParamMnMnRngV.Add(BetaMP);
200    ParamMnMnRngV.Add(GammaMP);
201    ParamMnMnRngV.Add(BetaBP);
202    ParamMnMnRngV.Add(GammaBP);
203    ParamMnMnRngV.Add(BetaMBP);
204    ParamMnMnRngV.Add(BetaBMP);
205    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
206      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
207      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
208    }
209  }
210  void TSir2Model::GetParam(TFltV& ParamV) const { 
211    ParamV.Clr(false); 
212    ParamV.Add(N0M);
213    ParamV.Add(I0M);
214    ParamV.Add(N0B);
215    ParamV.Add(I0B);
216    ParamV.Add(T0);
217    ParamV.Add(BetaM);
218    ParamV.Add(GammaM);
219    ParamV.Add(BetaB);
220    ParamV.Add(GammaB);
221    ParamV.Add(BetaMB);
222    ParamV.Add(BetaBM);
223  }
224  void TSir2Model::SetParam(const TFltV& ParamV) { 
225    N0M = ParamV[0];
226    I0M = ParamV[1];
227    N0B = ParamV[2];
228    I0B = ParamV[3];
229    T0 = (int) ParamV[4];
230    BetaM = ParamV[5];
231    GammaM = ParamV[6];
232    BetaB = ParamV[7];
233    GammaB = ParamV[8];
234    BetaMB = ParamV[9];
235    BetaBM = ParamV[10];
236  }
237  TStr TSir2Model::GetStr() const { 
238    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g Err: %.2f", 
239      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, GetErr()); 
240  }
241  void TSir2Model::SetPeakT0() {
242    double Max1=0, Max2=0;
243    int Peak1=0, Peak2=0;
244    for (int i = 0; i < MediaV.Len(); i++) {
245      if (MediaV[i] > Max1) { 
246        Max1 = MediaV[i]; Peak1 = i; }
247    }
248    for (int i = 0; i < BlogV.Len(); i++) {
249      if (BlogV[i] > Max2) { 
250        Max2 = BlogV[i]; Peak2 = i; }
251    }
252    int Peak = TMath::Mn(Peak1, Peak2);
253    T0 = int(0.9*Peak);
254    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
255    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
256    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
257      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
258  }
259  void TSir2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
260    IAssert(_MediaV.Len() == _BlogV.Len());
261    MediaV.Clr(false);  BlogV.Clr(false);
262    for (int i = 0; i < _MediaV.Len(); i++) {
263      MediaV.Add(_MediaV[i].Val2);
264      BlogV.Add(_BlogV[i].Val2);
265    }
266  }
<span onclick='openModal()' class='match'>267  void TSir2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
268    const TFlt& SM = SirValV[0];
269    const TFlt& SB = SirValV[1];
270    const TFlt& IM = SirValV[2];
271    const TFlt& IB = SirValV[3];
</span>272    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM;
273    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB;
274    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
275    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
276  }
277  double TSir2Model::GetErr() const { 
278    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
279  }
280  double TSir2Model::RunCalcErr(const TFltV& ParamV) {
281    SetParam(ParamV);
282    const int EndT = BlogV.Len() - T0 + 2;
283    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
284    return GetErr();
285  }
286  void TSir2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
287    ParamMnMxStepV = ParamMnMnRngV; 
288  }
289  void TSir2Model::GetParamNmV(TStrV& ParamNmV) const {
290    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM").SplitOnAllCh(',', ParamNmV);
291  }
292  void TSir2Model::Plot(const TStr& OutFNm, TStr Desc) const {
293    if (OutValV.Empty()) { printf("EMPTY()");  return; }
294    TFltV MV, BV;
295    const TFltV& SMediaV = OutValV[2];
296    for (int t=0; t < MediaV.Len(); t++) {
297      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
298    }
299    const TFltV& SBlogV = OutValV[3];
300    for (int t=0; t < BlogV.Len(); t++) {
301      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
302    }
303    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
304    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
305    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
306    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
307    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
308    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
309    GP.SavePng();
310  }
311  TSirSR2Model::TSirSR2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
312   int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
313   double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, 
314   double _DeltaM, TFltTr DeltaMP, double _DeltaB, TFltTr DeltaBP, TStr InFNm, int ColId1, int ColId2) :  N0M(_N0M), I0M(_I0M), N0B(_N0B), 
315   I0B(_I0B), T0(_T0), BetaM(_BetaM), GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM),
316   DeltaM(_DeltaM), DeltaB(DeltaB) { 
317    ParamMnMnRngV.Add(N0MP);
318    ParamMnMnRngV.Add(I0MP);
319    ParamMnMnRngV.Add(N0BP);
320    ParamMnMnRngV.Add(I0BP);
321    ParamMnMnRngV.Add(T0P);
322    ParamMnMnRngV.Add(BetaMP);
323    ParamMnMnRngV.Add(GammaMP);
324    ParamMnMnRngV.Add(BetaBP);
325    ParamMnMnRngV.Add(GammaBP);
326    ParamMnMnRngV.Add(BetaMBP);
327    ParamMnMnRngV.Add(BetaBMP);
328    ParamMnMnRngV.Add(DeltaMP);
329    ParamMnMnRngV.Add(DeltaBP);
330    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
331      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
332      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
333    }
334  }
335  void TSirSR2Model::GetParam(TFltV& ParamV) const { 
336    ParamV.Clr(false); 
337    ParamV.Add(N0M);
338    ParamV.Add(I0M);
339    ParamV.Add(N0B);
340    ParamV.Add(I0B);
341    ParamV.Add(T0);
342    ParamV.Add(BetaM);
343    ParamV.Add(GammaM);
344    ParamV.Add(BetaB);
345    ParamV.Add(GammaB);
346    ParamV.Add(BetaMB);
347    ParamV.Add(BetaBM);
348    ParamV.Add(DeltaM);
349    ParamV.Add(DeltaB);
350  }
351  void TSirSR2Model::SetParam(const TFltV& ParamV) { 
352    N0M = ParamV[0];
353    I0M = ParamV[1];
354    N0B = ParamV[2];
355    I0B = ParamV[3];
356    T0 = (int) ParamV[4];
357    BetaM = ParamV[5];
358    GammaM = ParamV[6];
359    BetaB = ParamV[7];
360    GammaB = ParamV[8];
361    BetaMB = ParamV[9];
362    BetaBM = ParamV[10];
363    DeltaM = ParamV[11];
364    DeltaB = ParamV[12];
365  }
366  TStr TSirSR2Model::GetStr() const { 
367    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g  Delta:%g %g    ERR: %.2f", 
368      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, DeltaM, DeltaB, GetErr()); 
369  }
370  void TSirSR2Model::SetPeakT0() {
371    double Max1=0, Max2=0;
372    int Peak1=0, Peak2=0;
373    for (int i = 0; i < MediaV.Len(); i++) {
374      if (MediaV[i] > Max1) { 
375        Max1 = MediaV[i]; Peak1 = i; }
376    }
377    for (int i = 0; i < BlogV.Len(); i++) {
378      if (BlogV[i] > Max2) { 
379        Max2 = BlogV[i]; Peak2 = i; }
380    }
381    int Peak = TMath::Mn(Peak1, Peak2);
382    T0 = int(0.9*Peak);
383    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
384    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
385    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
386      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
387  }
388  void TSirSR2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
389    IAssert(_MediaV.Len() == _BlogV.Len());
390    MediaV.Clr(false);  BlogV.Clr(false);
391    for (int i = 0; i < _MediaV.Len(); i++) {
392      MediaV.Add(_MediaV[i].Val2);
393      BlogV.Add(_BlogV[i].Val2);
394    }
395  }
396  void TSirSR2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
397    const TFlt& SM = SirValV[0];
398    const TFlt& SB = SirValV[1];
399    const TFlt& IM = SirValV[2];
400    const TFlt& IB = SirValV[3];
401    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM - DeltaM*SM;
402    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB - DeltaB*SB;
403    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
404    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
405  }
406  double TSirSR2Model::GetErr() const { 
407    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
408  }
409  double TSirSR2Model::RunCalcErr(const TFltV& ParamV) {
410    SetParam(ParamV);
411    const int EndT = BlogV.Len() - T0 + 2;
412    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
413    return GetErr();
414  }
415  void TSirSR2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
416    ParamMnMxStepV = ParamMnMnRngV; 
417  }
418  void TSirSR2Model::GetParamNmV(TStrV& ParamNmV) const {
419    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM,DeltaM,DeltaB").SplitOnAllCh(',', ParamNmV);
420  }
421  void TSirSR2Model::Plot(const TStr& OutFNm, TStr Desc) const {
422    if (OutValV.Empty()) { printf("EMPTY()");  return; }
423    TFltV MV, BV;
424    const TFltV& SMediaV = OutValV[2];
425    for (int t=0; t < MediaV.Len(); t++) {
426      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
427    }
428    const TFltV& SBlogV = OutValV[3];
429    for (int t=0; t < BlogV.Len(); t++) {
430      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
431    }
432    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
433    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
434    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
435    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
436    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
437    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
438    GP.SavePng();
439  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-pcg_engine_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</div>
                </div>
                <div class="column column_space"><pre><code>36    std::generate(std::begin(b), std::end(b), std::ref(engine));
37    size_t changed_bits = 0;
38    size_t unchanged_bits = 0;
39    size_t total_set = 0;
40    size_t total_bits = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>267  void TSir2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
268    const TFlt& SM = SirValV[0];
269    const TFlt& SB = SirValV[1];
270    const TFlt& IM = SirValV[2];
271    const TFlt& IB = SirValV[3];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    