
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.090361445783133%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baseapi.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "boxword.h"    
6  #include "coutln.h"     
7  #include "dawg_cache.h" 
8  #include "dict.h"       
9  #include "elst.h"       
10  #include "environ.h"    
11  #ifndef DISABLED_LEGACY_ENGINE
12  #include "equationdetect.h" 
13  #endif 
14  #include "errcode.h" 
15  #include "helpers.h" 
16  #include "host.h"    
17  #include "imageio.h" 
18  #ifndef DISABLED_LEGACY_ENGINE
19  #  include "intfx.h" 
20  #endif
21  #include "mutableiterator.h" 
22  #include "normalis.h"        
23  #if defined(USE_OPENCL)
24  #  include "openclwrapper.h" 
25  #endif
26  #include "pageres.h"         
27  #include "paragraphs.h"      
28  #include "params.h"          
29  #include "pdblock.h"         
30  #include "points.h"          
31  #include "polyblk.h"         
32  #include "rect.h"            
33  #include "stepblob.h"        
34  #include "tessdatamanager.h" 
35  #include "tesseractclass.h"  
36  #include "tprintf.h"         
37  #include "werd.h"            
38  #include "thresholder.h"     
39  #include <tesseract/baseapi.h>
40  #include <tesseract/ocrclass.h>       
41  #include <tesseract/osdetect.h>       
42  #include <tesseract/renderer.h>       
43  #include <tesseract/resultiterator.h> 
44  #include <cmath>    
45  #include <cstdint>  
46  #include <cstring>  
47  #include <fstream>  
48  #include <iostream> 
49  #include <locale>   
50  #include <memory>   
51  #include <set>      
52  #include <sstream>  
53  #include <vector>   
54  #include <allheaders.h> 
55  #ifdef HAVE_LIBCURL
56  #  include <curl/curl.h>
57  #endif
58  #ifdef __linux__
59  #  include <csignal> 
60  #endif
61  #if defined(_WIN32)
62  #  include <fcntl.h>
63  #  include <io.h>
64  #else
65  #  include <dirent.h> 
66  #  include <libgen.h>
67  #  include <sys/stat.h> 
68  #  include <sys/types.h>
69  #  include <unistd.h>
70  #endif 
71  namespace tesseract {
72  static BOOL_VAR(stream_filelist, false, "Stream a filelist from stdin");
73  static STRING_VAR(document_title, "", "Title of output document (used for hOCR and PDF output)");
74  #ifdef HAVE_LIBCURL
75  static INT_VAR(curl_timeout, 0, "Timeout for curl in seconds");
76  #endif
77  const int kMinRectSize = 10;
78  const char kTesseractReject = '~';
79  const char kUNLVReject = '~';
80  const char kUNLVSuspect = '^';
81  static const char *kOldVarsFile = "failed_vars.txt";
82  #ifndef DISABLED_LEGACY_ENGINE
83  static const char *kInputFile = "noname.tif";
84  static const char kUnknownFontName[] = "UnknownFont";
85  static STRING_VAR(classify_font_name, kUnknownFontName,
86                    "Default font name to be used in training");
87  static void ExtractFontName(const char* filename, std::string* fontname) {
88    *fontname = classify_font_name;
89    if (*fontname == kUnknownFontName) {
90      const char *basename = strrchr(filename, '/');
91      const char *firstdot = strchr(basename ? basename : filename, '.');
92      const char *lastdot  = strrchr(filename, '.');
93      if (firstdot != lastdot && firstdot != nullptr && lastdot != nullptr) {
94        ++firstdot;
95        *fontname = firstdot;
96        fontname->resize(lastdot - firstdot);
97      }
98    }
99  }
100  #endif
101  static void addAvailableLanguages(const std::string &datadir, const std::string &base,
102                                    std::vector<std::string> *langs) {
103    auto base2 = base;
104    if (!base2.empty()) {
105      base2 += "/";
106    }
107    const size_t extlen = sizeof(kTrainedDataSuffix);
108  #ifdef _WIN32
109    WIN32_FIND_DATA data;
110    HANDLE handle = FindFirstFile((datadir + base2 + "*").c_str(), &data);
111    if (handle != INVALID_HANDLE_VALUE) {
112      BOOL result = TRUE;
113      for (; result;) {
114        char *name = data.cFileName;
115        if (name[0] != '.') {
116          if ((data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) {
117            addAvailableLanguages(datadir, base2 + name, langs);
118          } else {
119            size_t len = strlen(name);
120            if (len > extlen && name[len - extlen] == '.' &&
121                strcmp(&name[len - extlen + 1], kTrainedDataSuffix) == 0) {
122              name[len - extlen] = '\0';
123              langs->push_back(base2 + name);
124            }
125          }
126        }
127        result = FindNextFile(handle, &data);
128      }
129      FindClose(handle);
130    }
131  #else 
132    DIR *dir = opendir((datadir + base).c_str());
133    if (dir != nullptr) {
134      dirent *de;
135      while ((de = readdir(dir))) {
136        char *name = de->d_name;
137        if (name[0] != '.') {
138          struct stat st;
139          if (stat((datadir + base2 + name).c_str(), &st) == 0 && (st.st_mode & S_IFDIR) == S_IFDIR) {
140            addAvailableLanguages(datadir, base2 + name, langs);
141          } else {
142            size_t len = strlen(name);
143            if (len > extlen && name[len - extlen] == '.' &&
144                strcmp(&name[len - extlen + 1], kTrainedDataSuffix) == 0) {
145              name[len - extlen] = '\0';
146              langs->push_back(base2 + name);
147            }
148          }
149        }
150      }
151      closedir(dir);
152    }
153  #endif
154  }
155  TessBaseAPI::TessBaseAPI()
156      : tesseract_(nullptr)
157      , osd_tesseract_(nullptr)
158      , equ_detect_(nullptr)
159      , reader_(nullptr)
160      ,
161      thresholder_(nullptr)
162      , paragraph_models_(nullptr)
163      , block_list_(nullptr)
164      , page_res_(nullptr)
165      , last_oem_requested_(OEM_DEFAULT)
166      , recognition_done_(false)
167      , rect_left_(0)
168      , rect_top_(0)
169      , rect_width_(0)
170      , rect_height_(0)
171      , image_width_(0)
172      , image_height_(0) {
173  }
174  TessBaseAPI::~TessBaseAPI() {
175    End();
176  }
177  const char *TessBaseAPI::Version() {
178    return TESSERACT_VERSION_STR;
179  }
180  size_t TessBaseAPI::getOpenCLDevice(void **data) {
181  #ifdef USE_OPENCL
182    ds_device device = OpenclDevice::getDeviceSelection();
183    if (device.type == DS_DEVICE_OPENCL_DEVICE) {
184      *data = new cl_device_id;
185      memcpy(*data, &device.oclDeviceID, sizeof(cl_device_id));
186      return sizeof(cl_device_id);
187    }
188  #endif
189    *data = nullptr;
190    return 0;
191  }
192  void TessBaseAPI::SetInputName(const char *name) {
193    input_file_ = name ? name : "";
194  }
195  void TessBaseAPI::SetOutputName(const char *name) {
196    output_file_ = name ? name : "";
197  }
198  bool TessBaseAPI::SetVariable(const char *name, const char *value) {
199    if (tesseract_ == nullptr) {
200      tesseract_ = new Tesseract;
201    }
202    return ParamUtils::SetParam(name, value, SET_PARAM_CONSTRAINT_NON_INIT_ONLY,
203                                tesseract_->params());
204  }
205  bool TessBaseAPI::SetDebugVariable(const char *name, const char *value) {
206    if (tesseract_ == nullptr) {
207      tesseract_ = new Tesseract;
208    }
209    return ParamUtils::SetParam(name, value, SET_PARAM_CONSTRAINT_DEBUG_ONLY, tesseract_->params());
210  }
211  bool TessBaseAPI::GetIntVariable(const char *name, int *value) const {
212    auto *p = ParamUtils::FindParam<IntParam>(name, GlobalParams()->int_params,
213                                              tesseract_->params()->int_params);
214    if (p == nullptr) {
215      return false;
216    }
217    *value = (int32_t)(*p);
218    return true;
219  }
220  bool TessBaseAPI::GetBoolVariable(const char *name, bool *value) const {
221    auto *p = ParamUtils::FindParam<BoolParam>(name, GlobalParams()->bool_params,
222                                               tesseract_->params()->bool_params);
223    if (p == nullptr) {
224      return false;
225    }
226    *value = bool(*p);
227    return true;
228  }
229  const char *TessBaseAPI::GetStringVariable(const char *name) const {
230    auto *p = ParamUtils::FindParam<StringParam>(name, GlobalParams()->string_params,
231                                                 tesseract_->params()->string_params);
232    return (p != nullptr) ? p->c_str() : nullptr;
233  }
234  bool TessBaseAPI::GetDoubleVariable(const char *name, double *value) const {
235    auto *p = ParamUtils::FindParam<DoubleParam>(name, GlobalParams()->double_params,
236                                                 tesseract_->params()->double_params);
237    if (p == nullptr) {
238      return false;
239    }
240    *value = (double)(*p);
241    return true;
242  }
243  bool TessBaseAPI::GetVariableAsString(const char *name, std::string *val) const {
244    return ParamUtils::GetParamAsString(name, tesseract_->params(), val);
245  }
246  #ifndef DISABLED_LEGACY_ENGINE
247  void TessBaseAPI::PrintFontsTable(FILE *fp) const {
248    const int fontinfo_size = tesseract_->get_fontinfo_table().size();
249    for (int font_index = 1; font_index < fontinfo_size; ++font_index) {
250      FontInfo font = tesseract_->get_fontinfo_table().at(font_index);
251      fprintf(fp, "ID=%3d: %s is_italic=%s is_bold=%s"
252                  " is_fixed_pitch=%s is_serif=%s is_fraktur=%s\n",
253                  font_index, font.name,
254                  font.is_italic() ? "true" : "false",
255                  font.is_bold() ? "true" : "false",
256                  font.is_fixed_pitch() ? "true" : "false",
257                  font.is_serif() ? "true" : "false",
258                  font.is_fraktur() ? "true" : "false");
259    }
260  }
261  #endif
262  void TessBaseAPI::PrintVariables(FILE *fp) const {
263    ParamUtils::PrintParams(fp, tesseract_->params());
264  }
265  int TessBaseAPI::Init(const char *datapath, const char *language, OcrEngineMode oem, char **configs,
266                        int configs_size, const std::vector<std::string> *vars_vec,
267                        const std::vector<std::string> *vars_values, bool set_only_non_debug_params) {
268    return Init(datapath, 0, language, oem, configs, configs_size, vars_vec, vars_values,
269                set_only_non_debug_params, nullptr);
270  }
271  int TessBaseAPI::Init(const char *data, int data_size, const char *language, OcrEngineMode oem,
272                        char **configs, int configs_size, const std::vector<std::string> *vars_vec,
273                        const std::vector<std::string> *vars_values, bool set_only_non_debug_params,
274                        FileReader reader) {
275    if (language == nullptr) {
276      language = "";
277    }
278    if (data == nullptr) {
279      data = "";
280    }
281    std::string datapath = data_size == 0 ? data : language;
282    if (tesseract_ != nullptr &&
283        (datapath_.empty() || language_.empty() || datapath_ != datapath ||
284         last_oem_requested_ != oem || (language_ != language && tesseract_->lang != language))) {
285      delete tesseract_;
286      tesseract_ = nullptr;
287    }
288  #ifdef USE_OPENCL
289    OpenclDevice od;
290    od.InitEnv();
291  #endif
292    bool reset_classifier = true;
293    if (tesseract_ == nullptr) {
294      reset_classifier = false;
295      tesseract_ = new Tesseract;
296      if (reader != nullptr) {
297        reader_ = reader;
298      }
299      TessdataManager mgr(reader_);
300      if (data_size != 0) {
301        mgr.LoadMemBuffer(language, data, data_size);
302      }
303      if (tesseract_->init_tesseract(datapath, output_file_, language, oem, configs,
304                                     configs_size, vars_vec, vars_values, set_only_non_debug_params,
305                                     &mgr) != 0) {
306        return -1;
307      }
308    }
309    datapath_ = datapath;
310    if (datapath_.empty() && !tesseract_->datadir.empty()) {
311      datapath_ = tesseract_->datadir;
312    }
313    language_ = language;
314    last_oem_requested_ = oem;
315  #ifndef DISABLED_LEGACY_ENGINE
316    if (reset_classifier) {
317      tesseract_->ResetAdaptiveClassifier();
318    }
319  #endif 
320    return 0;
321  }
322  const char *TessBaseAPI::GetInitLanguagesAsString() const {
323    return language_.c_str();
324  }
325  void TessBaseAPI::GetLoadedLanguagesAsVector(std::vector<std::string> *langs) const {
326    langs->clear();
327    if (tesseract_ != nullptr) {
328      langs->push_back(tesseract_->lang);
329      int num_subs = tesseract_->num_sub_langs();
330      for (int i = 0; i < num_subs; ++i) {
331        langs->push_back(tesseract_->get_sub_lang(i)->lang);
332      }
333    }
334  }
335  void TessBaseAPI::GetAvailableLanguagesAsVector(std::vector<std::string> *langs) const {
336    langs->clear();
337    if (tesseract_ != nullptr) {
338      addAvailableLanguages(tesseract_->datadir, "", langs);
339      std::sort(langs->begin(), langs->end());
340    }
341  }
342  void TessBaseAPI::InitForAnalysePage() {
343    if (tesseract_ == nullptr) {
344      tesseract_ = new Tesseract;
345  #ifndef DISABLED_LEGACY_ENGINE
346      tesseract_->InitAdaptiveClassifier(nullptr);
347  #endif
348    }
349  }
350  void TessBaseAPI::ReadConfigFile(const char *filename) {
351    tesseract_->read_config_file(filename, SET_PARAM_CONSTRAINT_NON_INIT_ONLY);
352  }
353  void TessBaseAPI::ReadDebugConfigFile(const char *filename) {
354    tesseract_->read_config_file(filename, SET_PARAM_CONSTRAINT_DEBUG_ONLY);
355  }
356  void TessBaseAPI::SetPageSegMode(PageSegMode mode) {
357    if (tesseract_ == nullptr) {
358      tesseract_ = new Tesseract;
359    }
360    tesseract_->tessedit_pageseg_mode.set_value(mode);
361  }
362  PageSegMode TessBaseAPI::GetPageSegMode() const {
363    if (tesseract_ == nullptr) {
364      return PSM_SINGLE_BLOCK;
365    }
366    return static_cast<PageSegMode>(static_cast<int>(tesseract_->tessedit_pageseg_mode));
367  }
368  char *TessBaseAPI::TesseractRect(const unsigned char *imagedata, int bytes_per_pixel,
369                                   int bytes_per_line, int left, int top, int width, int height) {
370    if (tesseract_ == nullptr || width < kMinRectSize || height < kMinRectSize) {
371      return nullptr; 
372    }
373    int bits_per_pixel = bytes_per_pixel == 0 ? 1 : bytes_per_pixel * 8;
374    SetImage(imagedata, bytes_per_line * 8 / bits_per_pixel, height + top, bytes_per_pixel,
375             bytes_per_line);
376    SetRectangle(left, top, width, height);
377    return GetUTF8Text();
378  }
379  #ifndef DISABLED_LEGACY_ENGINE
380  void TessBaseAPI::ClearAdaptiveClassifier() {
381    if (tesseract_ == nullptr) {
382      return;
383    }
384    tesseract_->ResetAdaptiveClassifier();
385    tesseract_->ResetDocumentDictionary();
386  }
387  #endif 
388  void TessBaseAPI::SetImage(const unsigned char *imagedata, int width, int height,
389                             int bytes_per_pixel, int bytes_per_line) {
390    if (InternalSetImage()) {
391      thresholder_->SetImage(imagedata, width, height, bytes_per_pixel, bytes_per_line);
392      SetInputImage(thresholder_->GetPixRect());
393    }
394  }
395  void TessBaseAPI::SetSourceResolution(int ppi) {
396    if (thresholder_) {
397      thresholder_->SetSourceYResolution(ppi);
398    } else {
399      tprintf("Please call SetImage before SetSourceResolution.\n");
400    }
401  }
402  void TessBaseAPI::SetImage(Pix *pix) {
403    if (InternalSetImage()) {
404      if (pixGetSpp(pix) == 4 && pixGetInputFormat(pix) == IFF_PNG) {
405        Pix *p1 = pixRemoveAlpha(pix);
406        pixSetSpp(p1, 3);
407        (void)pixCopy(pix, p1);
408        pixDestroy(&p1);
409      }
410      thresholder_->SetImage(pix);
411      SetInputImage(thresholder_->GetPixRect());
412    }
413  }
414  void TessBaseAPI::SetRectangle(int left, int top, int width, int height) {
415    if (thresholder_ == nullptr) {
416      return;
417    }
418    thresholder_->SetRectangle(left, top, width, height);
419    ClearResults();
420  }
421  Pix *TessBaseAPI::GetThresholdedImage() {
422    if (tesseract_ == nullptr || thresholder_ == nullptr) {
423      return nullptr;
424    }
425    if (tesseract_->pix_binary() == nullptr && !Threshold(&tesseract_->mutable_pix_binary()->pix_)) {
426      return nullptr;
427    }
428    return tesseract_->pix_binary().clone();
429  }
430  Boxa *TessBaseAPI::GetRegions(Pixa **pixa) {
431    return GetComponentImages(RIL_BLOCK, false, pixa, nullptr);
432  }
433  Boxa *TessBaseAPI::GetTextlines(const bool raw_image, const int raw_padding, Pixa **pixa,
434                                  int **blockids, int **paraids) {
435    return GetComponentImages(RIL_TEXTLINE, true, raw_image, raw_padding, pixa, blockids, paraids);
436  }
437  Boxa *TessBaseAPI::GetStrips(Pixa **pixa, int **blockids) {
438    return GetComponentImages(RIL_TEXTLINE, false, pixa, blockids);
439  }
440  Boxa *TessBaseAPI::GetWords(Pixa **pixa) {
441    return GetComponentImages(RIL_WORD, true, pixa, nullptr);
442  }
443  Boxa *TessBaseAPI::GetConnectedComponents(Pixa **pixa) {
<span onclick='openModal()' class='match'>444    return GetComponentImages(RIL_SYMBOL, true, pixa, nullptr);
445  }
446  Boxa *TessBaseAPI::GetComponentImages(PageIteratorLevel level, bool text_only, bool raw_image,
447                                        const int raw_padding, Pixa **pixa, int **blockids,
</span>448                                        int **paraids) {
449     std::unique_ptr< PageIterator> page_it(GetIterator());
450    if (page_it == nullptr) {
451      page_it.reset(AnalyseLayout());
452    }
453    if (page_it == nullptr) {
454      return nullptr; 
455    }
456    int component_count = 0;
457    int left, top, right, bottom;
458    if (raw_image) {
459      do {
460        if (page_it->BoundingBox(level, raw_padding, &left, &top, &right, &bottom) &&
461            (!text_only || PTIsTextType(page_it->BlockType()))) {
462          ++component_count;
463        }
464      } while (page_it->Next(level));
465    } else {
466      do {
467        if (page_it->BoundingBoxInternal(level, &left, &top, &right, &bottom) &&
468            (!text_only || PTIsTextType(page_it->BlockType()))) {
469          ++component_count;
470        }
471      } while (page_it->Next(level));
472    }
473    Boxa *boxa = boxaCreate(component_count);
474    if (pixa != nullptr) {
475      *pixa = pixaCreate(component_count);
476    }
477    if (blockids != nullptr) {
478      *blockids = new int[component_count];
479    }
480    if (paraids != nullptr) {
481      *paraids = new int[component_count];
482    }
483    int blockid = 0;
484    int paraid = 0;
485    int component_index = 0;
486    page_it->Begin();
487    do {
488      bool got_bounding_box;
489      if (raw_image) {
490        got_bounding_box = page_it->BoundingBox(level, raw_padding, &left, &top, &right, &bottom);
491      } else {
492        got_bounding_box = page_it->BoundingBoxInternal(level, &left, &top, &right, &bottom);
493      }
494      if (got_bounding_box && (!text_only || PTIsTextType(page_it->BlockType()))) {
495        Box *lbox = boxCreate(left, top, right - left, bottom - top);
496        boxaAddBox(boxa, lbox, L_INSERT);
497        if (pixa != nullptr) {
498          Pix *pix = nullptr;
499          if (raw_image) {
500            pix = page_it->GetImage(level, raw_padding, GetInputImage(), &left, &top);
501          } else {
502            pix = page_it->GetBinaryImage(level);
503          }
504          pixaAddPix(*pixa, pix, L_INSERT);
505          pixaAddBox(*pixa, lbox, L_CLONE);
506        }
507        if (paraids != nullptr) {
508          (*paraids)[component_index] = paraid;
509          if (page_it->IsAtFinalElement(RIL_PARA, level)) {
510            ++paraid;
511          }
512        }
513        if (blockids != nullptr) {
514          (*blockids)[component_index] = blockid;
515          if (page_it->IsAtFinalElement(RIL_BLOCK, level)) {
516            ++blockid;
517            paraid = 0;
518          }
519        }
520        ++component_index;
521      }
522    } while (page_it->Next(level));
523    return boxa;
524  }
525  int TessBaseAPI::GetThresholdedImageScaleFactor() const {
526    if (thresholder_ == nullptr) {
527      return 0;
528    }
529    return thresholder_->GetScaleFactor();
530  }
531  PageIterator *TessBaseAPI::AnalyseLayout() {
532    return AnalyseLayout(false);
533  }
534  PageIterator *TessBaseAPI::AnalyseLayout(bool merge_similar_words) {
535    if (FindLines() == 0) {
536      if (block_list_->empty()) {
537        return nullptr; 
538      }
539      page_res_ = new PAGE_RES(merge_similar_words, block_list_, nullptr);
540      DetectParagraphs(false);
541      return new PageIterator(page_res_, tesseract_, thresholder_->GetScaleFactor(),
542                              thresholder_->GetScaledYResolution(), rect_left_, rect_top_,
543                              rect_width_, rect_height_);
544    }
545    return nullptr;
546  }
547  int TessBaseAPI::Recognize(ETEXT_DESC *monitor) {
548    if (tesseract_ == nullptr) {
549      return -1;
550    }
551    if (FindLines() != 0) {
552      return -1;
553    }
554    delete page_res_;
555    if (block_list_->empty()) {
556      page_res_ = new PAGE_RES(false, block_list_, &tesseract_->prev_word_best_choice_);
557      return 0; 
558    }
559    tesseract_->SetBlackAndWhitelist();
560    recognition_done_ = true;
561  #ifndef DISABLED_LEGACY_ENGINE
562    if (tesseract_->tessedit_resegment_from_line_boxes) {
563      page_res_ = tesseract_->ApplyBoxes(input_file_.c_str(), true, block_list_);
564    } else if (tesseract_->tessedit_resegment_from_boxes) {
565      page_res_ = tesseract_->ApplyBoxes(input_file_.c_str(), false, block_list_);
566    } else
567  #endif 
568    {
569      page_res_ =
570          new PAGE_RES(tesseract_->AnyLSTMLang(), block_list_, &tesseract_->prev_word_best_choice_);
571    }
572    if (page_res_ == nullptr) {
573      return -1;
574    }
575    if (tesseract_->tessedit_train_line_recognizer) {
576      if (!tesseract_->TrainLineRecognizer(input_file_.c_str(), output_file_, block_list_)) {
577        return -1;
578      }
579      tesseract_->CorrectClassifyWords(page_res_);
580      return 0;
581    }
582  #ifndef DISABLED_LEGACY_ENGINE
583    if (tesseract_->tessedit_make_boxes_from_boxes) {
584      tesseract_->CorrectClassifyWords(page_res_);
585      return 0;
586    }
587  #endif 
588    int result = 0;
589    if (tesseract_->interactive_display_mode) {
590  #ifndef GRAPHICS_DISABLED
591      tesseract_->pgeditor_main(rect_width_, rect_height_, page_res_);
592  #endif 
593      delete page_res_;
594      page_res_ = nullptr;
595      return -1;
596  #ifndef DISABLED_LEGACY_ENGINE
597    } else if (tesseract_->tessedit_train_from_boxes) {
598      std::string fontname;
599      ExtractFontName(output_file_.c_str(), &fontname);
600      tesseract_->ApplyBoxTraining(fontname, page_res_);
601    } else if (tesseract_->tessedit_ambigs_training) {
602      FILE *training_output_file = tesseract_->init_recog_training(input_file_.c_str());
603      tesseract_->recog_training_segmented(input_file_.c_str(), page_res_, monitor,
604                                           training_output_file);
605      fclose(training_output_file);
606  #endif 
607    } else {
608      bool wait_for_text = true;
609      GetBoolVariable("paragraph_text_based", &wait_for_text);
610      if (!wait_for_text) {
611        DetectParagraphs(false);
612      }
613      if (tesseract_->recog_all_words(page_res_, monitor, nullptr, nullptr, 0)) {
614        if (wait_for_text) {
615          DetectParagraphs(true);
616        }
617      } else {
618        result = -1;
619      }
620    }
621    return result;
622  }
623  void TessBaseAPI::SetInputImage(Pix *pix) {
624    tesseract_->set_pix_original(pix);
625  }
626  Pix *TessBaseAPI::GetInputImage() {
627    return tesseract_->pix_original();
628  }
629  const char *TessBaseAPI::GetInputName() {
630    if (!input_file_.empty()) {
631      return input_file_.c_str();
632    }
633    return nullptr;
634  }
635  const char *TessBaseAPI::GetDatapath() {
636    return tesseract_->datadir.c_str();
637  }
638  int TessBaseAPI::GetSourceYResolution() {
639    if (thresholder_ == nullptr)
640      return -1;
641    return thresholder_->GetSourceYResolution();
642  }
643  bool TessBaseAPI::ProcessPagesFileList(FILE *flist, std::string *buf, const char *retry_config,
644                                         int timeout_millisec, TessResultRenderer *renderer,
645                                         int tessedit_page_number) {
646    if (!flist && !buf) {
647      return false;
648    }
649    unsigned page = (tessedit_page_number >= 0) ? tessedit_page_number : 0;
650    char pagename[MAX_PATH];
651    std::vector<std::string> lines;
652    if (!flist) {
653      std::string line;
654      for (const auto ch : *buf) {
655        if (ch == '\n') {
656          lines.push_back(line);
657          line.clear();
658        } else {
659          line.push_back(ch);
660        }
661      }
662      if (!line.empty()) {
663        lines.push_back(line);
664      }
665      if (lines.empty()) {
666        return false;
667      }
668    }
669    for (unsigned i = 0; i < page; i++) {
670      if (flist) {
671        if (fgets(pagename, sizeof(pagename), flist) == nullptr) {
672          break;
673        }
674      }
675    }
676    if (renderer && !renderer->BeginDocument(document_title.c_str())) {
677      return false;
678    }
679    while (true) {
680      if (flist) {
681        if (fgets(pagename, sizeof(pagename), flist) == nullptr) {
682          break;
683        }
684      } else {
685        if (page >= lines.size()) {
686          break;
687        }
688        snprintf(pagename, sizeof(pagename), "%s", lines[page].c_str());
689      }
690      chomp_string(pagename);
691      Pix *pix = pixRead(pagename);
692      if (pix == nullptr) {
693        tprintf("Image file %s cannot be read!\n", pagename);
694        return false;
695      }
696      tprintf("Page %u : %s\n", page, pagename);
697      bool r = ProcessPage(pix, page, pagename, retry_config, timeout_millisec, renderer);
698      pixDestroy(&pix);
699      if (!r) {
700        return false;
701      }
702      if (tessedit_page_number >= 0) {
703        break;
704      }
705      ++page;
706    }
707    if (renderer && !renderer->EndDocument()) {
708      return false;
709    }
710    return true;
711  }
712  bool TessBaseAPI::ProcessPagesMultipageTiff(const l_uint8 *data, size_t size, const char *filename,
713                                              const char *retry_config, int timeout_millisec,
714                                              TessResultRenderer *renderer,
715                                              int tessedit_page_number) {
716    Pix *pix = nullptr;
717    int page = (tessedit_page_number >= 0) ? tessedit_page_number : 0;
718    size_t offset = 0;
719    for (;; ++page) {
720      if (tessedit_page_number >= 0) {
721        page = tessedit_page_number;
722        pix = (data) ? pixReadMemTiff(data, size, page) : pixReadTiff(filename, page);
723      } else {
724        pix = (data) ? pixReadMemFromMultipageTiff(data, size, &offset)
725                     : pixReadFromMultipageTiff(filename, &offset);
726      }
727      if (pix == nullptr) {
728        break;
729      }
730      if (offset || page > 0) {
731        tprintf("Page %d\n", page + 1);
732      }
733      auto page_string = std::to_string(page);
734      SetVariable("applybox_page", page_string.c_str());
735      bool r = ProcessPage(pix, page, filename, retry_config, timeout_millisec, renderer);
736      pixDestroy(&pix);
737      if (!r) {
738        return false;
739      }
740      if (tessedit_page_number >= 0) {
741        break;
742      }
743      if (!offset) {
744        break;
745      }
746    }
747    return true;
748  }
749  bool TessBaseAPI::ProcessPages(const char *filename, const char *retry_config, int timeout_millisec,
750                                 TessResultRenderer *renderer) {
751    bool result = ProcessPagesInternal(filename, retry_config, timeout_millisec, renderer);
752  #ifndef DISABLED_LEGACY_ENGINE
753    if (result) {
754      if (tesseract_->tessedit_train_from_boxes && !tesseract_->WriteTRFile(output_file_.c_str())) {
755        tprintf("Write of TR file failed: %s\n", output_file_.c_str());
756        return false;
757      }
758    }
759  #endif 
760    return result;
761  }
762  #ifdef HAVE_LIBCURL
763  static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
764    size = size * nmemb;
765    auto *buf = reinterpret_cast<std::string *>(userp);
766    buf->append(reinterpret_cast<const char *>(contents), size);
767    return size;
768  }
769  #endif
770  bool TessBaseAPI::ProcessPagesInternal(const char *filename, const char *retry_config,
771                                         int timeout_millisec, TessResultRenderer *renderer) {
772    bool stdInput = !strcmp(filename, "stdin") || !strcmp(filename, "-");
773    if (stdInput) {
774  #ifdef WIN32
775      if (_setmode(_fileno(stdin), _O_BINARY) == -1)
776        tprintf("ERROR: cin to binary: %s", strerror(errno));
777  #endif 
778    }
779    if (stream_filelist) {
780      return ProcessPagesFileList(stdin, nullptr, retry_config, timeout_millisec, renderer,
781                                  tesseract_->tessedit_page_number);
782    }
783    std::string buf;
784    const l_uint8 *data = nullptr;
785    if (stdInput) {
786      buf.assign((std::istreambuf_iterator<char>(std::cin)), (std::istreambuf_iterator<char>()));
787      data = reinterpret_cast<const l_uint8 *>(buf.data());
788    } else if (strstr(filename, ":&bsol;&bsol;") != nullptr) {
789  #ifdef HAVE_LIBCURL
790      CURL *curl = curl_easy_init();
791      if (curl == nullptr) {
792        fprintf(stderr, "Error, curl_easy_init failed\n");
793        return false;
794      } else {
795        CURLcode curlcode;
796        auto error = [curl, &curlcode](const char *function) {
797          fprintf(stderr, "Error, %s failed with error %s\n", function, curl_easy_strerror(curlcode));
798          curl_easy_cleanup(curl);
799          return false;
800        };
801        curlcode = curl_easy_setopt(curl, CURLOPT_URL, filename);
802        if (curlcode != CURLE_OK) {
803          return error("curl_easy_setopt");
804        }
805        curlcode = curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
806        if (curlcode != CURLE_OK) {
807          return error("curl_easy_setopt");
808        }
809        curlcode = curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 8);
810        if (curlcode != CURLE_OK) {
811          return error("curl_easy_setopt");
812        }
813        int timeout = curl_timeout;
814        if (timeout > 0) {
815          curlcode = curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
816          if (curlcode != CURLE_OK) {
817            return error("curl_easy_setopt");
818          }
819          curlcode = curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);
820          if (curlcode != CURLE_OK) {
821            return error("curl_easy_setopt");
822          }
823        }
824        curlcode = curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
825        if (curlcode != CURLE_OK) {
826          return error("curl_easy_setopt");
827        }
828        curlcode = curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buf);
829        if (curlcode != CURLE_OK) {
830          return error("curl_easy_setopt");
831        }
832        curlcode = curl_easy_perform(curl);
833        if (curlcode != CURLE_OK) {
834          return error("curl_easy_perform");
835        }
836        curl_easy_cleanup(curl);
837        data = reinterpret_cast<const l_uint8 *>(buf.data());
838      }
839  #else
840      fprintf(stderr, "Error, this tesseract has no URL support\n");
841      return false;
842  #endif
843    } else {
844      if (FILE *file = fopen(filename, "rb")) {
845        fclose(file);
846      } else {
847        fprintf(stderr, "Error, cannot read input file %s: %s\n", filename, strerror(errno));
848        return false;
849      }
850    }
851    int format;
852    int r =
853        (data != nullptr) ? findFileFormatBuffer(data, &format) : findFileFormat(filename, &format);
854    if (r != 0 || format == IFF_UNKNOWN) {
855      std::string s;
856      if (data != nullptr) {
857        s = buf.c_str();
858      } else {
859        std::ifstream t(filename);
860        std::string u((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
861        s = u.c_str();
862      }
863      return ProcessPagesFileList(nullptr, &s, retry_config, timeout_millisec, renderer,
864                                  tesseract_->tessedit_page_number);
865    }
866    bool tiff = (format == IFF_TIFF || format == IFF_TIFF_PACKBITS || format == IFF_TIFF_RLE ||
867                 format == IFF_TIFF_G3 || format == IFF_TIFF_G4 || format == IFF_TIFF_LZW ||
868  #if LIBLEPT_MAJOR_VERSION > 1 || LIBLEPT_MINOR_VERSION > 76
869                 format == IFF_TIFF_JPEG ||
870  #endif
871                 format == IFF_TIFF_ZIP);
872    Pix *pix = nullptr;
873    if (!tiff) {
874      pix = (data != nullptr) ? pixReadMem(data, buf.size()) : pixRead(filename);
875      if (pix == nullptr) {
876        return false;
877      }
878    }
879    if (renderer && !renderer->BeginDocument(document_title.c_str())) {
880      pixDestroy(&pix);
881      return false;
882    }
883    r = (tiff) ? ProcessPagesMultipageTiff(data, buf.size(), filename, retry_config, timeout_millisec,
884                                           renderer, tesseract_->tessedit_page_number)
885               : ProcessPage(pix, 0, filename, retry_config, timeout_millisec, renderer);
886    pixDestroy(&pix);
887    if (!r || (renderer && !renderer->EndDocument())) {
888      return false;
889    }
890    return true;
891  }
892  bool TessBaseAPI::ProcessPage(Pix *pix, int page_index, const char *filename,
893                                const char *retry_config, int timeout_millisec,
894                                TessResultRenderer *renderer) {
895    SetInputName(filename);
896    SetImage(pix);
897    bool failed = false;
898    if (tesseract_->tessedit_pageseg_mode == PSM_AUTO_ONLY) {
899      if (! std::unique_ptr<const PageIterator>(AnalyseLayout())) {
900        failed = true;
901      }
902    } else if (tesseract_->tessedit_pageseg_mode == PSM_OSD_ONLY) {
903      failed = FindLines() != 0;
904    } else if (timeout_millisec > 0) {
905      ETEXT_DESC monitor;
906      monitor.cancel = nullptr;
907      monitor.cancel_this = nullptr;
908      monitor.set_deadline_msecs(timeout_millisec);
909      failed = Recognize(&monitor) < 0;
910    } else {
911      failed = Recognize(nullptr) < 0;
912    }
913    if (tesseract_->tessedit_write_images) {
914      Pix *page_pix = GetThresholdedImage();
915      std::string output_filename = output_file_ + ".processed";
916      if (page_index > 0) {
917        output_filename += std::to_string(page_index);
918      }
919      output_filename += ".tif";
920      pixWrite(output_filename.c_str(), page_pix, IFF_TIFF_G4);
921      pixDestroy(&page_pix);
922    }
923    if (failed && retry_config != nullptr && retry_config[0] != '\0') {
924      FILE *fp = fopen(kOldVarsFile, "wb");
925      if (fp == nullptr) {
926        tprintf("Error, failed to open file \"%s\"\n", kOldVarsFile);
927      } else {
928        PrintVariables(fp);
929        fclose(fp);
930      }
931      ReadConfigFile(retry_config);
932      SetImage(pix);
933      Recognize(nullptr);
934      ReadConfigFile(kOldVarsFile);
935    }
936    if (renderer && !failed) {
937      failed = !renderer->AddImage(this);
938    }
939    return !failed;
940  }
941  LTRResultIterator *TessBaseAPI::GetLTRIterator() {
942    if (tesseract_ == nullptr || page_res_ == nullptr) {
943      return nullptr;
944    }
945    return new LTRResultIterator(page_res_, tesseract_, thresholder_->GetScaleFactor(),
946                                 thresholder_->GetScaledYResolution(), rect_left_, rect_top_,
947                                 rect_width_, rect_height_);
948  }
949  ResultIterator *TessBaseAPI::GetIterator() {
950    if (tesseract_ == nullptr || page_res_ == nullptr) {
951      return nullptr;
952    }
953    return ResultIterator::StartOfParagraph(LTRResultIterator(
954        page_res_, tesseract_, thresholder_->GetScaleFactor(), thresholder_->GetScaledYResolution(),
955        rect_left_, rect_top_, rect_width_, rect_height_));
956  }
957  MutableIterator *TessBaseAPI::GetMutableIterator() {
958    if (tesseract_ == nullptr || page_res_ == nullptr) {
959      return nullptr;
960    }
961    return new MutableIterator(page_res_, tesseract_, thresholder_->GetScaleFactor(),
962                               thresholder_->GetScaledYResolution(), rect_left_, rect_top_,
963                               rect_width_, rect_height_);
964  }
965  char *TessBaseAPI::GetUTF8Text() {
966    if (tesseract_ == nullptr || (!recognition_done_ && Recognize(nullptr) < 0)) {
967      return nullptr;
968    }
969    std::string text("");
970    const std::unique_ptr<&bsol;*non-const*/ ResultIterator> it(GetIterator());
971    do {
972      if (it->Empty(RIL_PARA)) {
973        continue;
974      }
975      auto block_type = it->BlockType();
976      switch (block_type) {
977        case PT_FLOWING_IMAGE:
978        case PT_HEADING_IMAGE:
979        case PT_PULLOUT_IMAGE:
980        case PT_HORZ_LINE:
981        case PT_VERT_LINE:
982          continue;
983        case PT_NOISE:
984          tprintf("TODO: Please report image which triggers the noise case.\n");
985          ASSERT_HOST(false);
986        default:
987          break;
988      }
989      const std::unique_ptr<const char[]> para_text(it->GetUTF8Text(RIL_PARA));
990      text += para_text.get();
991    } while (it->Next(RIL_PARA));
992    char *result = new char[text.length() + 1];
993    strncpy(result, text.c_str(), text.length() + 1);
994    return result;
995  }
996  static void AddBoxToTSV(const PageIterator *it, PageIteratorLevel level, std::string &text) {
997    int left, top, right, bottom;
998    it->BoundingBox(level, &left, &top, &right, &bottom);
999    text += "\t" + std::to_string(left);
1000    text += "\t" + std::to_string(top);
1001    text += "\t" + std::to_string(right - left);
1002    text += "\t" + std::to_string(bottom - top);
1003  }
1004  char *TessBaseAPI::GetTSVText(int page_number) {
1005    if (tesseract_ == nullptr || (page_res_ == nullptr && Recognize(nullptr) < 0)) {
1006      return nullptr;
1007    }
1008    int lcnt = 1, bcnt = 1, pcnt = 1, wcnt = 1;
1009    int page_id = page_number + 1; 
1010    int page_num = page_id;
1011    int block_num = 0;
1012    int par_num = 0;
1013    int line_num = 0;
1014    int word_num = 0;
1015    std::string tsv_str;
1016    tsv_str += "1\t" + std::to_string(page_num); 
1017    tsv_str += "\t" + std::to_string(block_num);
1018    tsv_str += "\t" + std::to_string(par_num);
1019    tsv_str += "\t" + std::to_string(line_num);
1020    tsv_str += "\t" + std::to_string(word_num);
1021    tsv_str += "\t" + std::to_string(rect_left_);
1022    tsv_str += "\t" + std::to_string(rect_top_);
1023    tsv_str += "\t" + std::to_string(rect_width_);
1024    tsv_str += "\t" + std::to_string(rect_height_);
1025    tsv_str += "\t-1\t\n";
1026    const std::unique_ptr<&bsol;*non-const*/ ResultIterator> res_it(GetIterator());
1027    while (!res_it->Empty(RIL_BLOCK)) {
1028      if (res_it->Empty(RIL_WORD)) {
1029        res_it->Next(RIL_WORD);
1030        continue;
1031      }
1032      if (res_it->IsAtBeginningOf(RIL_BLOCK)) {
1033        block_num++;
1034        par_num = 0;
1035        line_num = 0;
1036        word_num = 0;
1037        tsv_str += "2\t" + std::to_string(page_num); 
1038        tsv_str += "\t" + std::to_string(block_num);
1039        tsv_str += "\t" + std::to_string(par_num);
1040        tsv_str += "\t" + std::to_string(line_num);
1041        tsv_str += "\t" + std::to_string(word_num);
1042        AddBoxToTSV(res_it.get(), RIL_BLOCK, tsv_str);
1043        tsv_str += "\t-1\t\n"; 
1044      }
1045      if (res_it->IsAtBeginningOf(RIL_PARA)) {
1046        par_num++;
1047        line_num = 0;
1048        word_num = 0;
1049        tsv_str += "3\t" + std::to_string(page_num); 
1050        tsv_str += "\t" + std::to_string(block_num);
1051        tsv_str += "\t" + std::to_string(par_num);
1052        tsv_str += "\t" + std::to_string(line_num);
1053        tsv_str += "\t" + std::to_string(word_num);
1054        AddBoxToTSV(res_it.get(), RIL_PARA, tsv_str);
1055        tsv_str += "\t-1\t\n"; 
1056      }
1057      if (res_it->IsAtBeginningOf(RIL_TEXTLINE)) {
1058        line_num++;
1059        word_num = 0;
1060        tsv_str += "4\t" + std::to_string(page_num); 
1061        tsv_str += "\t" + std::to_string(block_num);
1062        tsv_str += "\t" + std::to_string(par_num);
1063        tsv_str += "\t" + std::to_string(line_num);
1064        tsv_str += "\t" + std::to_string(word_num);
1065        AddBoxToTSV(res_it.get(), RIL_TEXTLINE, tsv_str);
1066        tsv_str += "\t-1\t\n"; 
1067      }
1068      int left, top, right, bottom;
1069      res_it->BoundingBox(RIL_WORD, &left, &top, &right, &bottom);
1070      word_num++;
1071      tsv_str += "5\t" + std::to_string(page_num); 
1072      tsv_str += "\t" + std::to_string(block_num);
1073      tsv_str += "\t" + std::to_string(par_num);
1074      tsv_str += "\t" + std::to_string(line_num);
1075      tsv_str += "\t" + std::to_string(word_num);
1076      tsv_str += "\t" + std::to_string(left);
1077      tsv_str += "\t" + std::to_string(top);
1078      tsv_str += "\t" + std::to_string(right - left);
1079      tsv_str += "\t" + std::to_string(bottom - top);
1080      tsv_str += "\t" + std::to_string(res_it->Confidence(RIL_WORD));
1081      tsv_str += "\t";
1082      if (res_it->IsAtFinalElement(RIL_TEXTLINE, RIL_WORD)) {
1083        lcnt++;
1084      }
1085      if (res_it->IsAtFinalElement(RIL_PARA, RIL_WORD)) {
1086        pcnt++;
1087      }
1088      if (res_it->IsAtFinalElement(RIL_BLOCK, RIL_WORD)) {
1089        bcnt++;
1090      }
1091      do {
1092        tsv_str += std::unique_ptr<const char[]>(res_it->GetUTF8Text(RIL_SYMBOL)).get();
1093        res_it->Next(RIL_SYMBOL);
1094      } while (!res_it->Empty(RIL_BLOCK) && !res_it->IsAtBeginningOf(RIL_WORD));
1095      tsv_str += "\n"; 
1096      wcnt++;
1097    }
1098    char *ret = new char[tsv_str.length() + 1];
1099    strcpy(ret, tsv_str.c_str());
1100    return ret;
1101  }
1102  const int kNumbersPerBlob = 5;
1103  const int kBytesPerNumber = 5;
1104  const int kBytesPerBoxFileLine = (kBytesPerNumber + 1) * kNumbersPerBlob + 1;
1105  const int kBytesPer64BitNumber = 20;
1106  const int kMaxBytesPerLine = kNumbersPerBlob * (kBytesPer64BitNumber + 1) + 1 + UNICHAR_LEN;
1107  char *TessBaseAPI::GetBoxText(int page_number) {
1108    if (tesseract_ == nullptr || (!recognition_done_ && Recognize(nullptr) < 0)) {
1109      return nullptr;
1110    }
1111    int blob_count;
1112    int utf8_length = TextLength(&blob_count);
1113    int total_length = blob_count * kBytesPerBoxFileLine + utf8_length + kMaxBytesPerLine;
1114    char *result = new char[total_length];
1115    result[0] = '\0';
1116    int output_length = 0;
1117    LTRResultIterator *it = GetLTRIterator();
1118    do {
1119      int left, top, right, bottom;
1120      if (it->BoundingBox(RIL_SYMBOL, &left, &top, &right, &bottom)) {
1121        const std::unique_ptr<&bsol;*non-const*/ char[]> text(it->GetUTF8Text(RIL_SYMBOL));
1122        for (int i = 0; text[i] != '\0'; ++i) {
1123          if (text[i] == ' ') {
1124            text[i] = kTesseractReject;
1125          }
1126        }
1127        snprintf(result + output_length, total_length - output_length, "%s %d %d %d %d %d\n",
1128                 text.get(), left, image_height_ - bottom, right, image_height_ - top, page_number);
1129        output_length += strlen(result + output_length);
1130        if (output_length + kMaxBytesPerLine > total_length) {
1131          break;
1132        }
1133      }
1134    } while (it->Next(RIL_SYMBOL));
1135    delete it;
1136    return result;
1137  }
1138  const int kUniChs[] = {0x20ac, 0x201c, 0x201d, 0x2018, 0x2019, 0x2022, 0x2014, 0};
1139  const int kLatinChs[] = {0x00a2, 0x0022, 0x0022, 0x0027, 0x0027, 0x00b7, 0x002d, 0};
1140  char *TessBaseAPI::GetUNLVText() {
1141    if (tesseract_ == nullptr || (!recognition_done_ && Recognize(nullptr) < 0)) {
1142      return nullptr;
1143    }
1144    bool tilde_crunch_written = false;
1145    bool last_char_was_newline = true;
1146    bool last_char_was_tilde = false;
1147    int total_length = TextLength(nullptr);
1148    PAGE_RES_IT page_res_it(page_res_);
1149    char *result = new char[total_length];
1150    char *ptr = result;
1151    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1152      WERD_RES *word = page_res_it.word();
1153      if (word->unlv_crunch_mode != CR_NONE) {
1154        if (word->unlv_crunch_mode != CR_DELETE &&
1155            (!tilde_crunch_written ||
1156             (word->unlv_crunch_mode == CR_KEEP_SPACE && word->word->space() > 0 &&
1157              !word->word->flag(W_FUZZY_NON) && !word->word->flag(W_FUZZY_SP)))) {
1158          if (!word->word->flag(W_BOL) && word->word->space() > 0 && !word->word->flag(W_FUZZY_NON) &&
1159              !word->word->flag(W_FUZZY_SP)) {
1160            *ptr++ = ' ';
1161            last_char_was_tilde = false;
1162          }
1163          if (!last_char_was_tilde) {
1164            last_char_was_tilde = true;
1165            *ptr++ = kUNLVReject;
1166            tilde_crunch_written = true;
1167            last_char_was_newline = false;
1168          }
1169        }
1170      } else {
1171        tilde_crunch_written = false;
1172        tesseract_->set_unlv_suspects(word);
1173        const char *wordstr = word->best_choice->unichar_string().c_str();
1174        const auto &lengths = word->best_choice->unichar_lengths();
1175        int length = lengths.length();
1176        int i = 0;
1177        int offset = 0;
1178        if (last_char_was_tilde && word->word->space() == 0 && wordstr[offset] == ' ') {
1179          offset = lengths[i++];
1180        }
1181        if (i < length && wordstr[offset] != 0) {
1182          if (!last_char_was_newline) {
1183            *ptr++ = ' ';
1184          } else {
1185            last_char_was_newline = false;
1186          }
1187          for (; i < length; offset += lengths[i++]) {
1188            if (wordstr[offset] == ' ' || wordstr[offset] == kTesseractReject) {
1189              *ptr++ = kUNLVReject;
1190              last_char_was_tilde = true;
1191            } else {
1192              if (word->reject_map[i].rejected()) {
1193                *ptr++ = kUNLVSuspect;
1194              }
1195              UNICHAR ch(wordstr + offset, lengths[i]);
1196              int uni_ch = ch.first_uni();
1197              for (int j = 0; kUniChs[j] != 0; ++j) {
1198                if (kUniChs[j] == uni_ch) {
1199                  uni_ch = kLatinChs[j];
1200                  break;
1201                }
1202              }
1203              if (uni_ch <= 0xff) {
1204                *ptr++ = static_cast<char>(uni_ch);
1205                last_char_was_tilde = false;
1206              } else {
1207                *ptr++ = kUNLVReject;
1208                last_char_was_tilde = true;
1209              }
1210            }
1211          }
1212        }
1213      }
1214      if (word->word->flag(W_EOL) && !last_char_was_newline) {
1215        *ptr++ = '\n';
1216        tilde_crunch_written = false;
1217        last_char_was_newline = true;
1218        last_char_was_tilde = false;
1219      }
1220    }
1221    *ptr++ = '\n';
1222    *ptr = '\0';
1223    return result;
1224  }
1225  #ifndef DISABLED_LEGACY_ENGINE
1226  bool TessBaseAPI::DetectOrientationScript(int *orient_deg, float *orient_conf,
1227                                            const char **script_name, float *script_conf) {
1228    OSResults osr;
1229    bool osd = DetectOS(&osr);
1230    if (!osd) {
1231      return false;
1232    }
1233    int orient_id = osr.best_result.orientation_id;
1234    int script_id = osr.get_best_script(orient_id);
1235    if (orient_conf) {
1236      *orient_conf = osr.best_result.oconfidence;
1237    }
1238    if (orient_deg) {
1239      *orient_deg = orient_id * 90; 
1240    }
1241    if (script_name) {
1242      const char *script = osr.unicharset->get_script_from_script_id(script_id);
1243      *script_name = script;
1244    }
1245    if (script_conf) {
1246      *script_conf = osr.best_result.sconfidence;
1247    }
1248    return true;
1249  }
1250  char *TessBaseAPI::GetOsdText(int page_number) {
1251    int orient_deg;
1252    float orient_conf;
1253    const char *script_name;
1254    float script_conf;
1255    if (!DetectOrientationScript(&orient_deg, &orient_conf, &script_name, &script_conf)) {
1256      return nullptr;
1257    }
1258    int rotate = OrientationIdToValue(orient_deg / 90);
1259    std::stringstream stream;
1260    stream.imbue(std::locale::classic());
1261    stream.precision(2);
1262    stream << std::fixed << "Page number: " << page_number << "\n"
1263           << "Orientation in degrees: " << orient_deg << "\n"
1264           << "Rotate: " << rotate << "\n"
1265           << "Orientation confidence: " << orient_conf << "\n"
1266           << "Script: " << script_name << "\n"
1267           << "Script confidence: " << script_conf << "\n";
1268    const std::string &text = stream.str();
1269    char *result = new char[text.length() + 1];
1270    strcpy(result, text.c_str());
1271    return result;
1272  }
1273  #endif 
1274  int TessBaseAPI::MeanTextConf() {
1275    int *conf = AllWordConfidences();
1276    if (!conf) {
1277      return 0;
1278    }
1279    int sum = 0;
1280    int *pt = conf;
1281    while (*pt >= 0) {
1282      sum += *pt++;
1283    }
1284    if (pt != conf) {
1285      sum /= pt - conf;
1286    }
1287    delete[] conf;
1288    return sum;
1289  }
1290  int *TessBaseAPI::AllWordConfidences() {
1291    if (tesseract_ == nullptr || (!recognition_done_ && Recognize(nullptr) < 0)) {
1292      return nullptr;
1293    }
1294    int n_word = 0;
1295    PAGE_RES_IT res_it(page_res_);
1296    for (res_it.restart_page(); res_it.word() != nullptr; res_it.forward()) {
1297      n_word++;
1298    }
1299    int *conf = new int[n_word + 1];
1300    n_word = 0;
1301    for (res_it.restart_page(); res_it.word() != nullptr; res_it.forward()) {
1302      WERD_RES *word = res_it.word();
1303      WERD_CHOICE *choice = word->best_choice;
1304      int w_conf = static_cast<int>(100 + 5 * choice->certainty());
1305      if (w_conf < 0) {
1306        w_conf = 0;
1307      }
1308      if (w_conf > 100) {
1309        w_conf = 100;
1310      }
1311      conf[n_word++] = w_conf;
1312    }
1313    conf[n_word] = -1;
1314    return conf;
1315  }
1316  #ifndef DISABLED_LEGACY_ENGINE
1317  bool TessBaseAPI::AdaptToWordStr(PageSegMode mode, const char *wordstr) {
1318    int debug = 0;
1319    GetIntVariable("applybox_debug", &debug);
1320    bool success = true;
1321    PageSegMode current_psm = GetPageSegMode();
1322    SetPageSegMode(mode);
1323    SetVariable("classify_enable_learning", "0");
1324    const std::unique_ptr<const char[]> text(GetUTF8Text());
1325    if (debug) {
1326      tprintf("Trying to adapt \"%s\" to \"%s\"\n", text.get(), wordstr);
1327    }
1328    if (text != nullptr) {
1329      PAGE_RES_IT it(page_res_);
1330      WERD_RES *word_res = it.word();
1331      if (word_res != nullptr) {
1332        word_res->word->set_text(wordstr);
1333        int w = 0;
1334        int t;
1335        for (t = 0; text[t] != '\0'; ++t) {
1336          if (text[t] == '\n' || text[t] == ' ') {
1337            continue;
1338          }
1339          while (wordstr[w] == ' ') {
1340            ++w;
1341          }
1342          if (text[t] != wordstr[w]) {
1343            break;
1344          }
1345          ++w;
1346        }
1347        if (text[t] != '\0' || wordstr[w] != '\0') {
1348          delete page_res_;
1349          std::vector<TBOX> boxes;
1350          page_res_ = tesseract_->SetupApplyBoxes(boxes, block_list_);
1351          tesseract_->ReSegmentByClassification(page_res_);
1352          tesseract_->TidyUp(page_res_);
1353          PAGE_RES_IT pr_it(page_res_);
1354          if (pr_it.word() == nullptr) {
1355            success = false;
1356          } else {
1357            word_res = pr_it.word();
1358          }
1359        } else {
1360          word_res->BestChoiceToCorrectText();
1361        }
1362        if (success) {
1363          tesseract_->EnableLearning = true;
1364          tesseract_->LearnWord(nullptr, word_res);
1365        }
1366      } else {
1367        success = false;
1368      }
1369    } else {
1370      success = false;
1371    }
1372    SetPageSegMode(current_psm);
1373    return success;
1374  }
1375  #endif 
1376  void TessBaseAPI::Clear() {
1377    if (thresholder_ != nullptr) {
1378      thresholder_->Clear();
1379    }
1380    ClearResults();
1381    if (tesseract_ != nullptr) {
1382      SetInputImage(nullptr);
1383    }
1384  }
1385  void TessBaseAPI::End() {
1386    Clear();
1387    delete thresholder_;
1388    thresholder_ = nullptr;
1389    delete page_res_;
1390    page_res_ = nullptr;
1391    delete block_list_;
1392    block_list_ = nullptr;
1393    if (paragraph_models_ != nullptr) {
1394      for (auto model : *paragraph_models_) {
1395        delete model;
1396      }
1397      delete paragraph_models_;
1398      paragraph_models_ = nullptr;
1399    }
1400  #ifndef DISABLED_LEGACY_ENGINE
1401    if (osd_tesseract_ == tesseract_) {
1402      osd_tesseract_ = nullptr;
1403    }
1404    delete osd_tesseract_;
1405    osd_tesseract_ = nullptr;
1406    delete equ_detect_;
1407    equ_detect_ = nullptr;
1408  #endif 
1409    delete tesseract_;
1410    tesseract_ = nullptr;
1411    input_file_.clear();
1412    output_file_.clear();
1413    datapath_.clear();
1414    language_.clear();
1415  }
1416  void TessBaseAPI::ClearPersistentCache() {
1417    Dict::GlobalDawgCache()->DeleteUnusedDawgs();
1418  }
1419  int TessBaseAPI::IsValidWord(const char *word) const {
1420    return tesseract_->getDict().valid_word(word);
1421  }
1422  bool TessBaseAPI::IsValidCharacter(const char *utf8_character) const {
1423    return tesseract_->unicharset.contains_unichar(utf8_character);
1424  }
1425  bool TessBaseAPI::GetTextDirection(int *out_offset, float *out_slope) {
1426    const std::unique_ptr<const PageIterator> it(AnalyseLayout());
1427    if (it == nullptr) {
1428      return false;
1429    }
1430    int x1, x2, y1, y2;
1431    it->Baseline(RIL_TEXTLINE, &x1, &y1, &x2, &y2);
1432    if (x2 <= x1) {
1433      x2 = x1 + 1;
1434    }
1435    *out_slope = static_cast<float>(y2 - y1) / (x2 - x1);
1436    *out_offset = static_cast<int>(y1 - *out_slope * x1);
1437    int left, top, right, bottom;
1438    if (!it->BoundingBox(RIL_TEXTLINE, &left, &top, &right, &bottom)) {
1439      return false;
1440    }
1441    int left_y = IntCastRounded(*out_slope * left + *out_offset);
1442    int right_y = IntCastRounded(*out_slope * right + *out_offset);
1443    *out_offset += bottom - std::max(left_y, right_y);
1444    *out_slope = -*out_slope;
1445    *out_offset = rect_height_ - *out_offset;
1446    return true;
1447  }
1448  void TessBaseAPI::SetDictFunc(DictFunc f) {
1449    if (tesseract_ != nullptr) {
1450      tesseract_->getDict().letter_is_okay_ = f;
1451    }
1452  }
1453  void TessBaseAPI::SetProbabilityInContextFunc(ProbabilityInContextFunc f) {
1454    if (tesseract_ != nullptr) {
1455      tesseract_->getDict().probability_in_context_ = f;
1456      int num_subs = tesseract_->num_sub_langs();
1457      for (int i = 0; i < num_subs; ++i) {
1458        tesseract_->get_sub_lang(i)->getDict().probability_in_context_ = f;
1459      }
1460    }
1461  }
1462  bool TessBaseAPI::InternalSetImage() {
1463    if (tesseract_ == nullptr) {
1464      tprintf("Please call Init before attempting to set an image.\n");
1465      return false;
1466    }
1467    if (thresholder_ == nullptr) {
1468      thresholder_ = new ImageThresholder;
1469    }
1470    ClearResults();
1471    return true;
1472  }
1473  bool TessBaseAPI::Threshold(Pix **pix) {
1474    ASSERT_HOST(pix != nullptr);
1475    if (*pix != nullptr) {
1476      pixDestroy(pix);
1477    }
1478    int user_dpi = 0;
1479    GetIntVariable("user_defined_dpi", &user_dpi);
1480    int y_res = thresholder_->GetScaledYResolution();
1481    if (user_dpi && (user_dpi < kMinCredibleResolution || user_dpi > kMaxCredibleResolution)) {
1482      tprintf(
1483          "Warning: User defined image dpi is outside of expected range "
1484          "(%d - %d)!\n",
1485          kMinCredibleResolution, kMaxCredibleResolution);
1486    }
1487    if (user_dpi) {
1488      thresholder_->SetSourceYResolution(user_dpi);
1489    } else if (y_res < kMinCredibleResolution || y_res > kMaxCredibleResolution) {
1490      if (y_res != 0) {
1491        tprintf("Warning: Invalid resolution %d dpi. Using %d instead.\n",
1492                y_res, kMinCredibleResolution);
1493      }
1494      thresholder_->SetSourceYResolution(kMinCredibleResolution);
1495    }
1496    auto thresholding_method = static_cast<ThresholdMethod>(static_cast<int>(tesseract_->thresholding_method));
1497    if (thresholding_method == ThresholdMethod::Otsu) {
1498      Image pix_binary(*pix);
1499      if (!thresholder_->ThresholdToPix(&pix_binary)) {
1500        return false;
1501      }
1502      *pix = pix_binary;
1503      if (!thresholder_->IsBinary()) {
1504        tesseract_->set_pix_thresholds(thresholder_->GetPixRectThresholds());
1505        tesseract_->set_pix_grey(thresholder_->GetPixRectGrey());
1506      } else {
1507        tesseract_->set_pix_thresholds(nullptr);
1508        tesseract_->set_pix_grey(nullptr);
1509      }
1510    } else {
1511      auto [ok, pix_grey, pix_binary, pix_thresholds] = thresholder_->Threshold(this, thresholding_method);
1512      if (!ok) {
1513        return false;
1514      }
1515      *pix = pix_binary;
1516      tesseract_->set_pix_thresholds(pix_thresholds);
1517      tesseract_->set_pix_grey(pix_grey);
1518    }
1519    thresholder_->GetImageSizes(&rect_left_, &rect_top_, &rect_width_, &rect_height_, &image_width_,
1520                                &image_height_);
1521    int estimated_res = ClipToRange(thresholder_->GetScaledEstimatedResolution(),
1522                                    kMinCredibleResolution, kMaxCredibleResolution);
1523    if (estimated_res != thresholder_->GetScaledEstimatedResolution()) {
1524      tprintf(
1525          "Estimated internal resolution %d out of range! "
1526          "Corrected to %d.\n",
1527          thresholder_->GetScaledEstimatedResolution(), estimated_res);
1528    }
1529    tesseract_->set_source_resolution(estimated_res);
1530    return true;
1531  }
1532  int TessBaseAPI::FindLines() {
1533    if (thresholder_ == nullptr || thresholder_->IsEmpty()) {
1534      tprintf("Please call SetImage before attempting recognition.\n");
1535      return -1;
1536    }
1537    if (recognition_done_) {
1538      ClearResults();
1539    }
1540    if (!block_list_->empty()) {
1541      return 0;
1542    }
1543    if (tesseract_ == nullptr) {
1544      tesseract_ = new Tesseract;
1545  #ifndef DISABLED_LEGACY_ENGINE
1546      tesseract_->InitAdaptiveClassifier(nullptr);
1547  #endif
1548    }
1549    if (tesseract_->pix_binary() == nullptr && !Threshold(&tesseract_->mutable_pix_binary()->pix_)) {
1550      return -1;
1551    }
1552    tesseract_->PrepareForPageseg();
1553  #ifndef DISABLED_LEGACY_ENGINE
1554    if (tesseract_->textord_equation_detect) {
1555      if (equ_detect_ == nullptr && !datapath_.empty()) {
1556        equ_detect_ = new EquationDetect(datapath_.c_str(), nullptr);
1557      }
1558      if (equ_detect_ == nullptr) {
1559        tprintf("Warning: Could not set equation detector\n");
1560      } else {
1561        tesseract_->SetEquationDetect(equ_detect_);
1562      }
1563    }
1564  #endif 
1565    Tesseract *osd_tess = osd_tesseract_;
1566    OSResults osr;
1567  #ifndef DISABLED_LEGACY_ENGINE
1568    if (PSM_OSD_ENABLED(tesseract_->tessedit_pageseg_mode) && osd_tess == nullptr) {
1569      if (strcmp(language_.c_str(), "osd") == 0) {
1570        osd_tess = tesseract_;
1571      } else {
1572        osd_tesseract_ = new Tesseract;
1573        TessdataManager mgr(reader_);
1574        if (datapath_.empty()) {
1575          tprintf(
1576              "Warning: Auto orientation and script detection requested,"
1577              " but data path is undefined\n");
1578          delete osd_tesseract_;
1579          osd_tesseract_ = nullptr;
1580        } else if (osd_tesseract_->init_tesseract(datapath_, "", "osd", OEM_TESSERACT_ONLY,
1581                                                  nullptr, 0, nullptr, nullptr, false, &mgr) == 0) {
1582          osd_tess = osd_tesseract_;
1583          osd_tesseract_->set_source_resolution(thresholder_->GetSourceYResolution());
1584        } else {
1585          tprintf(
1586              "Warning: Auto orientation and script detection requested,"
1587              " but osd language failed to load\n");
1588          delete osd_tesseract_;
1589          osd_tesseract_ = nullptr;
1590        }
1591      }
1592    }
1593  #endif 
1594    if (tesseract_->SegmentPage(input_file_.c_str(), block_list_, osd_tess, &osr) < 0) {
1595      return -1;
1596    }
1597    tesseract_->PrepareForTessOCR(block_list_, osd_tess, &osr);
1598    return 0;
1599  }
1600  void TessBaseAPI::ClearResults() {
1601    if (tesseract_ != nullptr) {
1602      tesseract_->Clear();
1603    }
1604    delete page_res_;
1605    page_res_ = nullptr;
1606    recognition_done_ = false;
1607    if (block_list_ == nullptr) {
1608      block_list_ = new BLOCK_LIST;
1609    } else {
1610      block_list_->clear();
1611    }
1612    if (paragraph_models_ != nullptr) {
1613      for (auto model : *paragraph_models_) {
1614        delete model;
1615      }
1616      delete paragraph_models_;
1617      paragraph_models_ = nullptr;
1618    }
1619  }
1620  int TessBaseAPI::TextLength(int *blob_count) const {
1621    if (tesseract_ == nullptr || page_res_ == nullptr) {
1622      return 0;
1623    }
1624    PAGE_RES_IT page_res_it(page_res_);
1625    int total_length = 2;
1626    int total_blobs = 0;
1627    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1628      WERD_RES *word = page_res_it.word();
1629      WERD_CHOICE *choice = word->best_choice;
1630      if (choice != nullptr) {
1631        total_blobs += choice->length() + 2;
1632        total_length += choice->unichar_string().length() + 2;
1633        for (int i = 0; i < word->reject_map.length(); ++i) {
1634          if (word->reject_map[i].rejected()) {
1635            ++total_length;
1636          }
1637        }
1638      }
1639    }
1640    if (blob_count != nullptr) {
1641      *blob_count = total_blobs;
1642    }
1643    return total_length;
1644  }
1645  #ifndef DISABLED_LEGACY_ENGINE
1646  bool TessBaseAPI::DetectOS(OSResults *osr) {
1647    if (tesseract_ == nullptr) {
1648      return false;
1649    }
1650    ClearResults();
1651    if (tesseract_->pix_binary() == nullptr && !Threshold(&tesseract_->mutable_pix_binary()->pix_)) {
1652      return false;
1653    }
1654    if (input_file_.empty()) {
1655      input_file_ = kInputFile;
1656    }
1657    return orientation_and_script_detection(input_file_.c_str(), osr, tesseract_) > 0;
1658  }
1659  #endif 
1660  void TessBaseAPI::set_min_orientation_margin(double margin) {
1661    tesseract_->min_orientation_margin.set_value(margin);
1662  }
1663  void TessBaseAPI::GetBlockTextOrientations(int **block_orientation, bool **vertical_writing) {
1664    delete[] * block_orientation;
1665    *block_orientation = nullptr;
1666    delete[] * vertical_writing;
1667    *vertical_writing = nullptr;
1668    BLOCK_IT block_it(block_list_);
1669    block_it.move_to_first();
1670    int num_blocks = 0;
1671    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
1672      if (!block_it.data()->pdblk.poly_block()->IsText()) {
1673        continue;
1674      }
1675      ++num_blocks;
1676    }
1677    if (!num_blocks) {
1678      tprintf("WARNING: Found no blocks\n");
1679      return;
1680    }
1681    *block_orientation = new int[num_blocks];
1682    *vertical_writing = new bool[num_blocks];
1683    block_it.move_to_first();
1684    int i = 0;
1685    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
1686      if (!block_it.data()->pdblk.poly_block()->IsText()) {
1687        continue;
1688      }
1689      FCOORD re_rotation = block_it.data()->re_rotation();
1690      float re_theta = re_rotation.angle();
1691      FCOORD classify_rotation = block_it.data()->classify_rotation();
1692      float classify_theta = classify_rotation.angle();
1693      double rot_theta = -(re_theta - classify_theta) * 2.0 / M_PI;
1694      if (rot_theta < 0) {
1695        rot_theta += 4;
1696      }
1697      int num_rotations = static_cast<int>(rot_theta + 0.5);
1698      (*block_orientation)[i] = num_rotations;
1699      (*vertical_writing)[i] = classify_rotation.y() != 0.0f;
1700      ++i;
1701    }
1702  }
1703  void TessBaseAPI::DetectParagraphs(bool after_text_recognition) {
1704    int debug_level = 0;
1705    GetIntVariable("paragraph_debug_level", &debug_level);
1706    if (paragraph_models_ == nullptr) {
1707      paragraph_models_ = new std::vector<ParagraphModel *>;
1708    }
1709    MutableIterator *result_it = GetMutableIterator();
1710    do { 
1711      std::vector<ParagraphModel *> models;
1712      ::tesseract::DetectParagraphs(debug_level, after_text_recognition, result_it, &models);
1713      paragraph_models_->insert(paragraph_models_->end(), models.begin(), models.end());
1714    } while (result_it->Next(RIL_BLOCK));
1715    delete result_it;
1716  }
1717  const char *TessBaseAPI::GetUnichar(int unichar_id) const {
1718    return tesseract_->unicharset.id_to_unichar(unichar_id);
1719  }
1720  const Dawg *TessBaseAPI::GetDawg(int i) const {
1721    if (tesseract_ == nullptr || i >= NumDawgs()) {
1722      return nullptr;
1723    }
1724    return tesseract_->getDict().GetDawg(i);
1725  }
1726  int TessBaseAPI::NumDawgs() const {
1727    return tesseract_ == nullptr ? 0 : tesseract_->getDict().NumDawgs();
1728  }
1729  std::string HOcrEscape(const char *text) {
1730    std::string ret;
1731    const char *ptr;
1732    for (ptr = text; *ptr; ptr++) {
1733      switch (*ptr) {
1734        case '<':
1735          ret += "&lt;";
1736          break;
1737        case '>':
1738          ret += "&gt;";
1739          break;
1740        case '&':
1741          ret += "&amp;";
1742          break;
1743        case '"':
1744          ret += "&quot;";
1745          break;
1746        case '\'':
1747          ret += "&#39;";
1748          break;
1749        default:
1750          ret += *ptr;
1751      }
1752    }
1753    return ret;
1754  }
1755  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-makerow.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "makerow.h"
5  #include "blkocc.h"
6  #include "blobbox.h"
7  #include "ccstruct.h"
8  #include "detlinefit.h"
9  #include "drawtord.h"
10  #include "oldbasel.h"
11  #include "sortflts.h"
12  #include "statistc.h"
13  #include "textord.h"
14  #include "tordmain.h"
15  #include "tovars.h"
16  #include "tprintf.h"
17  #include "underlin.h"
18  #include <algorithm>
19  #include <cmath>
20  #include <vector> 
21  namespace tesseract {
22  BOOL_VAR(textord_heavy_nr, false, "Vigorously remove noise");
23  BOOL_VAR(textord_show_initial_rows, false, "Display row accumulation");
24  BOOL_VAR(textord_show_parallel_rows, false, "Display page correlated rows");
25  BOOL_VAR(textord_show_expanded_rows, false, "Display rows after expanding");
26  BOOL_VAR(textord_show_final_rows, false, "Display rows after final fitting");
27  BOOL_VAR(textord_show_final_blobs, false, "Display blob bounds after pre-ass");
28  BOOL_VAR(textord_test_landscape, false, "Tests refer to land/port");
29  BOOL_VAR(textord_parallel_baselines, true, "Force parallel baselines");
30  BOOL_VAR(textord_straight_baselines, false, "Force straight baselines");
31  BOOL_VAR(textord_old_baselines, true, "Use old baseline algorithm");
32  BOOL_VAR(textord_old_xheight, false, "Use old xheight algorithm");
33  BOOL_VAR(textord_fix_xheight_bug, true, "Use spline baseline");
34  BOOL_VAR(textord_fix_makerow_bug, true, "Prevent multiple baselines");
35  BOOL_VAR(textord_debug_xheights, false, "Test xheight algorithms");
36  static BOOL_VAR(textord_biased_skewcalc, true, "Bias skew estimates with line length");
37  static BOOL_VAR(textord_interpolating_skew, true, "Interpolate across gaps");
38  static INT_VAR(textord_skewsmooth_offset, 4, "For smooth factor");
39  static INT_VAR(textord_skewsmooth_offset2, 1, "For smooth factor");
40  INT_VAR(textord_test_x, -INT32_MAX, "coord of test pt");
41  INT_VAR(textord_test_y, -INT32_MAX, "coord of test pt");
42  INT_VAR(textord_min_blobs_in_row, 4, "Min blobs before gradient counted");
43  INT_VAR(textord_spline_minblobs, 8, "Min blobs in each spline segment");
44  INT_VAR(textord_spline_medianwin, 6, "Size of window for spline segmentation");
45  static INT_VAR(textord_max_blob_overlaps, 4, "Max number of blobs a big blob can overlap");
46  INT_VAR(textord_min_xheight, 10, "Min credible pixel xheight");
47  double_VAR(textord_spline_shift_fraction, 0.02, "Fraction of line spacing for quad");
48  double_VAR(textord_skew_ile, 0.5, "Ile of gradients for page skew");
49  double_VAR(textord_skew_lag, 0.02, "Lag for skew on row accumulation");
50  double_VAR(textord_linespace_iqrlimit, 0.2, "Max iqr/median for linespace");
51  double_VAR(textord_width_limit, 8, "Max width of blobs to make rows");
52  double_VAR(textord_chop_width, 1.5, "Max width before chopping");
53  static double_VAR(textord_expansion_factor, 1.0, "Factor to expand rows by in expand_rows");
54  static double_VAR(textord_overlap_x, 0.375, "Fraction of linespace for good overlap");
55  double_VAR(textord_minxh, 0.25, "fraction of linesize for min xheight");
56  double_VAR(textord_min_linesize, 1.25, "* blob height for initial linesize");
57  double_VAR(textord_excess_blobsize, 1.3, "New row made if blob makes row this big");
58  double_VAR(textord_occupancy_threshold, 0.4, "Fraction of neighbourhood");
59  double_VAR(textord_underline_width, 2.0, "Multiple of line_size for underline");
60  double_VAR(textord_min_blob_height_fraction, 0.75,
61             "Min blob height/top to include blob top into xheight stats");
62  double_VAR(textord_xheight_mode_fraction, 0.4, "Min pile height to make xheight");
63  double_VAR(textord_ascheight_mode_fraction, 0.08, "Min pile height to make ascheight");
64  static double_VAR(textord_descheight_mode_fraction, 0.08, "Min pile height to make descheight");
65  double_VAR(textord_ascx_ratio_min, 1.25, "Min cap/xheight");
66  double_VAR(textord_ascx_ratio_max, 1.8, "Max cap/xheight");
67  double_VAR(textord_descx_ratio_min, 0.25, "Min desc/xheight");
68  double_VAR(textord_descx_ratio_max, 0.6, "Max desc/xheight");
69  double_VAR(textord_xheight_error_margin, 0.1, "Accepted variation");
70  INT_VAR(textord_lms_line_trials, 12, "Number of linew fits to do");
71  BOOL_VAR(textord_new_initial_xheight, true, "Use test xheight mechanism");
72  BOOL_VAR(textord_debug_blob, false, "Print test blob information");
73  #define MAX_HEIGHT_MODES 12
74  const int kMinLeaderCount = 5;
75  static int row_y_order(       
76      const void *item1, 
77      const void *item2) {
78    const TO_ROW *row1 = *reinterpret_cast<const TO_ROW *const *>(item1);
79    const TO_ROW *row2 = *reinterpret_cast<const TO_ROW *const *>(item2);
80    if (row1->parallel_c() > row2->parallel_c()) {
81      return -1;
82    } else if (row1->parallel_c() < row2->parallel_c()) {
83      return 1;
84    } else {
85      return 0;
86    }
87  }
88  static int row_spacing_order( 
89      const TO_ROW *row1, 
90      const TO_ROW *row2) {
91    return row1->spacing < row2->spacing;
92  }
93  static float MakeRowFromBlobs(float line_size, BLOBNBOX_IT *blob_it, TO_ROW_IT *row_it) {
94    blob_it->sort(blob_x_order);
95    blob_it->move_to_first();
96    TO_ROW *row = nullptr;
97    float total_size = 0.0f;
98    int blob_count = 0;
99    for (; !blob_it->empty(); blob_it->forward()) {
100      BLOBNBOX *blob = blob_it->extract();
101      int top = blob->bounding_box().top();
102      int bottom = blob->bounding_box().bottom();
103      if (row == nullptr) {
104        row = new TO_ROW(blob, top, bottom, line_size);
105        row_it->add_before_then_move(row);
106      } else {
107        row->add_blob(blob, top, bottom, line_size);
108      }
109      total_size += top - bottom;
110      ++blob_count;
111    }
112    return blob_count > 0 ? total_size / blob_count : total_size;
113  }
114  static float MakeRowFromSubBlobs(TO_BLOCK *block, C_BLOB *blob, TO_ROW_IT *row_it) {
115    BLOBNBOX_IT bb_it(&block->small_blobs);
116    C_OUTLINE_IT ol_it(blob->out_list());
117    ol_it.set_to_list(ol_it.data()->child());
118    if (ol_it.empty()) {
119      return 0.0f;
120    }
121    for (ol_it.mark_cycle_pt(); !ol_it.cycled_list(); ol_it.forward()) {
122      blob = new C_BLOB(C_OUTLINE::deep_copy(ol_it.data()));
123      blob->CheckInverseFlagAndDirection();
124      auto *bbox = new BLOBNBOX(blob);
125      bb_it.add_after_then_move(bbox);
126    }
127    return MakeRowFromBlobs(block->line_size, &bb_it, row_it);
128  }
129  float make_single_row(ICOORD page_tr, bool allow_sub_blobs, TO_BLOCK *block,
130                        TO_BLOCK_LIST *blocks) {
131    BLOBNBOX_IT blob_it = &block->blobs;
132    TO_ROW_IT row_it = block->get_rows();
133    blob_it.add_list_after(&block->small_blobs);
134    blob_it.add_list_after(&block->noise_blobs);
135    blob_it.add_list_after(&block->large_blobs);
136    if (block->blobs.singleton() && allow_sub_blobs) {
137      blob_it.move_to_first();
138      float size = MakeRowFromSubBlobs(block, blob_it.data()->cblob(), &row_it);
139      if (size > block->line_size) {
140        block->line_size = size;
141      }
142    } else if (block->blobs.empty()) {
143      C_BLOB *blob = C_BLOB::FakeBlob(block->block->pdblk.bounding_box());
144      auto *bblob = new BLOBNBOX(blob);
145      blob_it.add_after_then_move(bblob);
146    }
147    MakeRowFromBlobs(block->line_size, &blob_it, &row_it);
148    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
149      fit_lms_line(row_it.data());
150    }
151    float gradient;
152    float fit_error;
153    compute_page_skew(blocks, gradient, fit_error);
154    return gradient;
155  }
156  float make_rows(ICOORD page_tr, TO_BLOCK_LIST *port_blocks) {
157    float port_m;         
158    float port_err;       
159    TO_BLOCK_IT block_it; 
160    block_it.set_to_list(port_blocks);
161    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
162      make_initial_textrows(page_tr, block_it.data(), FCOORD(1.0f, 0.0f), !textord_test_landscape);
163    }
164    compute_page_skew(port_blocks, port_m, port_err);
165    block_it.set_to_list(port_blocks);
166    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
167      cleanup_rows_making(page_tr, block_it.data(), port_m, FCOORD(1.0f, 0.0f),
168                          block_it.data()->block->pdblk.bounding_box().left(),
169                          !textord_test_landscape);
170    }
171    return port_m; 
172  }
173  void make_initial_textrows( 
174      ICOORD page_tr,
175      TO_BLOCK *block, 
176      FCOORD rotation, 
177      bool testing_on  
178  ) {
179    TO_ROW_IT row_it = block->get_rows();
180  #ifndef GRAPHICS_DISABLED
181    ScrollView::Color colour; 
182    if (textord_show_initial_rows && testing_on) {
183      if (to_win == nullptr) {
184        create_to_win(page_tr);
185      }
186    }
187  #endif
188    assign_blobs_to_rows(block, nullptr, 0, true, true, textord_show_initial_rows && testing_on);
189    row_it.move_to_first();
190    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
191      fit_lms_line(row_it.data());
192    }
193  #ifndef GRAPHICS_DISABLED
194    if (textord_show_initial_rows && testing_on) {
195      colour = ScrollView::RED;
196      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
197        plot_to_row(row_it.data(), colour, rotation);
198        colour = static_cast<ScrollView::Color>(colour + 1);
199        if (colour > ScrollView::MAGENTA) {
200          colour = ScrollView::RED;
201        }
202      }
203    }
204  #endif
205  }
206  void fit_lms_line(TO_ROW *row) {
207    float m, c; 
208    tesseract::DetLineFit lms;
209    BLOBNBOX_IT blob_it = row->blob_list();
210    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
211      const TBOX &box = blob_it.data()->bounding_box();
212      lms.Add(ICOORD((box.left() + box.right()) / 2, box.bottom()));
213    }
214    double error = lms.Fit(&m, &c);
215    row->set_line(m, c, error);
216  }
217  void compute_page_skew(    
218      TO_BLOCK_LIST *blocks, 
219      float &page_m,         
220      float &page_err        
221  ) {
222    int32_t row_count;             
223    int32_t blob_count;            
224    int32_t row_err;               
225    int32_t row_index;             
226    TO_ROW *row;                   
227    TO_BLOCK_IT block_it = blocks; 
228    row_count = 0;
229    blob_count = 0;
230    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
231      POLY_BLOCK *pb = block_it.data()->block->pdblk.poly_block();
232      if (pb != nullptr && !pb->IsText()) {
233        continue; 
234      }
235      row_count += block_it.data()->get_rows()->length();
236      TO_ROW_IT row_it(block_it.data()->get_rows());
237      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
238        blob_count += row_it.data()->blob_list()->length();
239      }
240    }
241    if (row_count == 0) {
242      page_m = 0.0f;
243      page_err = 0.0f;
244      return;
245    }
246    std::vector<float> gradients(blob_count);
247    std::vector<float> errors(blob_count);
248    row_index = 0;
249    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
250      POLY_BLOCK *pb = block_it.data()->block->pdblk.poly_block();
251      if (pb != nullptr && !pb->IsText()) {
252        continue; 
253      }
254      TO_ROW_IT row_it(block_it.data()->get_rows());
255      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
256        row = row_it.data();
257        blob_count = row->blob_list()->length();
258        row_err = static_cast<int32_t>(std::ceil(row->line_error()));
259        if (row_err <= 0) {
260          row_err = 1;
261        }
262        if (textord_biased_skewcalc) {
263          blob_count /= row_err;
264          for (blob_count /= row_err; blob_count > 0; blob_count--) {
265            gradients[row_index] = row->line_m();
266            errors[row_index] = row->line_error();
267            row_index++;
268          }
269        } else if (blob_count >= textord_min_blobs_in_row) {
270          gradients[row_index] = row->line_m();
271          errors[row_index] = row->line_error();
272          row_index++;
273        }
274      }
275    }
276    if (row_index == 0) {
277      for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
278        POLY_BLOCK *pb = block_it.data()->block->pdblk.poly_block();
279        if (pb != nullptr && !pb->IsText()) {
280          continue; 
281        }
282        TO_ROW_IT row_it(block_it.data()->get_rows());
283        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
284          row = row_it.data();
285          gradients[row_index] = row->line_m();
286          errors[row_index] = row->line_error();
287          row_index++;
288        }
289      }
290    }
291    row_count = row_index;
292    row_index = static_cast<int32_t>(row_count * textord_skew_ile);
293    gradients.resize(row_count);
294    std::nth_element(gradients.begin(), gradients.begin() + row_index, gradients.end());
295    page_m = gradients[row_index];
296    row_index = static_cast<int32_t>(row_count * textord_skew_ile);
297    errors.resize(row_count);
298    std::nth_element(errors.begin(), errors.begin() + row_index, errors.end());
299    page_err = errors[row_index];
300  }
301  const double kNoiseSize = 0.5; 
302  const int kMinSize = 8;        
303  static bool dot_of_i(BLOBNBOX *dot, BLOBNBOX *i, TO_ROW *row) {
304    const TBOX &ibox = i->bounding_box();
305    const TBOX &dotbox = dot->bounding_box();
306    int overlap = std::min(dotbox.right(), ibox.right()) - std::max(dotbox.left(), ibox.left());
307    if (ibox.height() <= 2 * dotbox.height() ||
308        (overlap * 2 < ibox.width() && overlap < dotbox.width())) {
309      return false;
310    }
311    if (ibox.height() > ibox.width() * 2) {
312      return true; 
313    }
314    const double kHeightFraction = 0.6;
315    double target_height = std::min(dotbox.bottom(), ibox.top());
316    target_height -= row->line_m() * dotbox.left() + row->line_c();
317    target_height *= kHeightFraction;
318    int left_min = dotbox.left() - dotbox.width();
319    int middle = (dotbox.left() + dotbox.right()) / 2;
320    int right_max = dotbox.right() + dotbox.width();
321    int left_miny = 0;
322    int left_maxy = 0;
323    int right_miny = 0;
324    int right_maxy = 0;
325    bool found_left = false;
326    bool found_right = false;
327    bool in_left = false;
328    bool in_right = false;
329    C_BLOB *blob = i->cblob();
330    C_OUTLINE_IT o_it = blob->out_list();
331    for (o_it.mark_cycle_pt(); !o_it.cycled_list(); o_it.forward()) {
332      C_OUTLINE *outline = o_it.data();
333      int length = outline->pathlength();
334      ICOORD pos = outline->start_pos();
335      for (int step = 0; step < length; pos += outline->step(step++)) {
336        int x = pos.x();
337        int y = pos.y();
338        if (x >= left_min && x < middle && !found_left) {
339          if (in_left) {
340            if (y > left_maxy) {
341              left_maxy = y;
342            }
343            if (y < left_miny) {
344              left_miny = y;
345            }
346          } else {
347            left_maxy = left_miny = y;
348            in_left = true;
349          }
350        } else if (in_left) {
351          if (left_maxy - left_miny > target_height) {
352            if (found_right) {
353              return true;
354            }
355            found_left = true;
356          }
357          in_left = false;
358        }
359        if (x <= right_max && x > middle && !found_right) {
360          if (in_right) {
361            if (y > right_maxy) {
362              right_maxy = y;
363            }
364            if (y < right_miny) {
365              right_miny = y;
366            }
367          } else {
368            right_maxy = right_miny = y;
369            in_right = true;
370          }
371        } else if (in_right) {
372          if (right_maxy - right_miny > target_height) {
373            if (found_left) {
374              return true;
375            }
376            found_right = true;
377          }
378          in_right = false;
379        }
380      }
381    }
382    return false;
383  }
384  void vigorous_noise_removal(TO_BLOCK *block) {
385    TO_ROW_IT row_it = block->get_rows();
386    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
387      TO_ROW *row = row_it.data();
388      BLOBNBOX_IT b_it = row->blob_list();
389      int max_height = 0;
390      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
391        BLOBNBOX *blob = b_it.data();
392        if (blob->bounding_box().height() > max_height) {
393          max_height = blob->bounding_box().height();
394        }
395      }
396      STATS hstats(0, max_height);
397      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
398        BLOBNBOX *blob = b_it.data();
399        int height = blob->bounding_box().height();
400        if (height >= kMinSize) {
401          hstats.add(blob->bounding_box().height(), 1);
402        }
403      }
404      float xheight = hstats.median();
405      BLOBNBOX *prev = nullptr;
406      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
407        BLOBNBOX *blob = b_it.data();
408        const TBOX &box = blob->bounding_box();
409        if (box.height() < kNoiseSize * xheight) {
410          if (prev != nullptr) {
411            if (dot_of_i(blob, prev, row)) {
412              continue; 
413            }
414          }
415          if (!b_it.at_last()) {
416            BLOBNBOX *next = b_it.data_relative(1);
417            if (dot_of_i(blob, next, row)) {
418              continue; 
419            }
420          }
421          delete blob->remove_cblob();
422          delete b_it.extract();
423        } else {
424          prev = blob;
425        }
426      }
427    }
428  }
429  void cleanup_rows_making( 
430      ICOORD page_tr,       
431      TO_BLOCK *block,      
432      float gradient,       
433      FCOORD rotation,      
434      int32_t block_edge,   
435      bool testing_on       
436  ) {
437    BLOBNBOX_IT blob_it = &block->blobs;
438    TO_ROW_IT row_it = block->get_rows();
439  #ifndef GRAPHICS_DISABLED
440    if (textord_show_parallel_rows && testing_on) {
441      if (to_win == nullptr) {
442        create_to_win(page_tr);
443      }
444    }
445  #endif
446    fit_parallel_rows(block, gradient, rotation, block_edge,
447                      textord_show_parallel_rows && testing_on);
448    delete_non_dropout_rows(block, gradient, rotation, block_edge,
449                            textord_show_parallel_rows && testing_on);
450    expand_rows(page_tr, block, gradient, rotation, block_edge, testing_on);
451    blob_it.set_to_list(&block->blobs);
452    row_it.set_to_list(block->get_rows());
453    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
454      blob_it.add_list_after(row_it.data()->blob_list());
455    }
456    assign_blobs_to_rows(block, &gradient, 1, false, false, false);
457    blob_it.set_to_list(&block->blobs);
458    blob_it.add_list_after(&block->large_blobs);
459    assign_blobs_to_rows(block, &gradient, 2, true, true, false);
460    blob_it.set_to_list(&block->blobs);
461    blob_it.add_list_after(&block->noise_blobs);
462    blob_it.add_list_after(&block->small_blobs);
463    assign_blobs_to_rows(block, &gradient, 3, false, false, false);
464  }
465  void delete_non_dropout_rows( 
466      TO_BLOCK *block,          
467      float gradient,           
468      FCOORD rotation,          
469      int32_t block_edge,       
470      bool testing_on           
471  ) {
472    TBOX block_box; 
473    int32_t max_y;  
474    int32_t min_y;
475    int32_t line_index; 
476    int32_t line_count; 
477    int32_t distance;   
478    int32_t xleft;      
479    int32_t ybottom;    
480    TO_ROW *row;        
481    TO_ROW_IT row_it = block->get_rows();
482    BLOBNBOX_IT blob_it = &block->blobs;
483    if (row_it.empty()) {
484      return; 
485    }
486    block_box = deskew_block_coords(block, gradient);
487    xleft = block->block->pdblk.bounding_box().left();
488    ybottom = block->block->pdblk.bounding_box().bottom();
489    min_y = block_box.bottom() - 1;
490    max_y = block_box.top() + 1;
491    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
492      line_index = static_cast<int32_t>(std::floor(row_it.data()->intercept()));
493      if (line_index <= min_y) {
494        min_y = line_index - 1;
495      }
496      if (line_index >= max_y) {
497        max_y = line_index + 1;
498      }
499    }
500    line_count = max_y - min_y + 1;
501    if (line_count <= 0) {
502      return; 
503    }
504    std::vector<int32_t> deltas(line_count);
505    std::vector<int32_t> occupation(line_count);
506    compute_line_occupation(block, gradient, min_y, max_y, &occupation[0], &deltas[0]);
507    compute_occupation_threshold(
508        static_cast<int32_t>(ceil(block->line_spacing * (tesseract::CCStruct::kDescenderFraction +
509                                                         tesseract::CCStruct::kAscenderFraction))),
510        static_cast<int32_t>(ceil(block->line_spacing * (tesseract::CCStruct::kXHeightFraction +
511                                                         tesseract::CCStruct::kAscenderFraction))),
512        max_y - min_y + 1, &occupation[0], &deltas[0]);
513  #ifndef GRAPHICS_DISABLED
514    if (testing_on) {
515      draw_occupation(xleft, ybottom, min_y, max_y, &occupation[0], &deltas[0]);
516    }
517  #endif
518    compute_dropout_distances(&occupation[0], &deltas[0], line_count);
519    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
520      row = row_it.data();
521      line_index = static_cast<int32_t>(std::floor(row->intercept()));
522      distance = deltas[line_index - min_y];
523      if (find_best_dropout_row(row, distance, block->line_spacing / 2, line_index, &row_it,
524                                testing_on)) {
525  #ifndef GRAPHICS_DISABLED
526        if (testing_on) {
527          plot_parallel_row(row, gradient, block_edge, ScrollView::WHITE, rotation);
528        }
529  #endif
530        blob_it.add_list_after(row_it.data()->blob_list());
531        delete row_it.extract(); 
532      }
533    }
534    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
535      blob_it.add_list_after(row_it.data()->blob_list());
536    }
537  }
538  bool find_best_dropout_row( 
539      TO_ROW *row,            
540      int32_t distance,       
541      float dist_limit,       
542      int32_t line_index,     
543      TO_ROW_IT *row_it,      
544      bool testing_on         
545  ) {
546    int32_t next_index; 
547    int32_t row_offset; 
548    int32_t abs_dist;   
549    int8_t row_inc;     
550    TO_ROW *next_row;   
551    if (testing_on) {
552      tprintf("Row at %g(%g), dropout dist=%d,", row->intercept(), row->parallel_c(), distance);
553    }
554    if (distance < 0) {
555      row_inc = 1;
556      abs_dist = -distance;
557    } else {
558      row_inc = -1;
559      abs_dist = distance;
560    }
561    if (abs_dist > dist_limit) {
562      if (testing_on) {
563        tprintf(" too far - deleting\n");
564      }
565      return true;
566    }
567    if ((distance < 0 && !row_it->at_last()) || (distance >= 0 && !row_it->at_first())) {
568      row_offset = row_inc;
569      do {
570        next_row = row_it->data_relative(row_offset);
571        next_index = static_cast<int32_t>(std::floor(next_row->intercept()));
572        if ((distance < 0 && next_index < line_index &&
573             next_index > line_index + distance + distance) ||
574            (distance >= 0 && next_index > line_index &&
575             next_index < line_index + distance + distance)) {
576          if (testing_on) {
577            tprintf(" nearer neighbour (%d) at %g\n", line_index + distance - next_index,
578                    next_row->intercept());
579          }
580          return true; 
581        } else if (next_index == line_index || next_index == line_index + distance + distance) {
582          if (row->believability() <= next_row->believability()) {
583            if (testing_on) {
584              tprintf(" equal but more believable at %g (%g/%g)\n", next_row->intercept(),
585                      row->believability(), next_row->believability());
586            }
587            return true; 
588          }
589        }
590        row_offset += row_inc;
591      } while ((next_index == line_index || next_index == line_index + distance + distance) &&
592               row_offset < row_it->length());
593      if (testing_on) {
594        tprintf(" keeping\n");
595      }
596    }
597    return false;
598  }
599  TBOX deskew_block_coords( 
600      TO_BLOCK *block,      
601      float gradient        
602  ) {
603    TBOX result;     
604    TBOX blob_box;   
605    FCOORD rotation; 
606    float length;    
607    TO_ROW_IT row_it = block->get_rows();
608    TO_ROW *row;         
609    BLOBNBOX *blob;      
610    BLOBNBOX_IT blob_it; 
611    length = std::sqrt(gradient * gradient + 1);
612    rotation = FCOORD(1 / length, -gradient / length);
613    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
614      row = row_it.data();
615      blob_it.set_to_list(row->blob_list());
616      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
617        blob = blob_it.data();
618        blob_box = blob->bounding_box();
619        blob_box.rotate(rotation); 
620        result += blob_box;
621      }
622    }
623    return result;
624  }
625  void compute_line_occupation( 
626      TO_BLOCK *block,          
627      float gradient,           
628      int32_t min_y,            
629      int32_t max_y,            
630      int32_t *occupation,      
631      int32_t *deltas           
632  ) {
633    int32_t line_count; 
634    int32_t line_index; 
635    int index;          
636    TO_ROW *row;        
637    TO_ROW_IT row_it = block->get_rows();
638    BLOBNBOX *blob;      
639    BLOBNBOX_IT blob_it; 
640    float length;        
641    TBOX blob_box;       
642    FCOORD rotation;     
643    line_count = max_y - min_y + 1;
644    length = std::sqrt(gradient * gradient + 1);
645    rotation = FCOORD(1 / length, -gradient / length);
646    for (line_index = 0; line_index < line_count; line_index++) {
647      deltas[line_index] = 0;
648    }
649    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
650      row = row_it.data();
651      blob_it.set_to_list(row->blob_list());
652      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
653        blob = blob_it.data();
654        blob_box = blob->bounding_box();
655        blob_box.rotate(rotation); 
656        int32_t width = blob_box.right() - blob_box.left();
657        index = blob_box.bottom() - min_y;
658        ASSERT_HOST(index >= 0 && index < line_count);
659        deltas[index] += width;
660        index = blob_box.top() - min_y;
661        ASSERT_HOST(index >= 0 && index < line_count);
662        deltas[index] -= width;
663      }
664    }
665    occupation[0] = deltas[0];
666    for (line_index = 1; line_index < line_count; line_index++) {
667      occupation[line_index] = occupation[line_index - 1] + deltas[line_index];
668    }
669  }
670  void compute_occupation_threshold( 
671      int32_t low_window,            
672      int32_t high_window,           
673      int32_t line_count,            
674      int32_t *occupation,           
675      int32_t *thresholds            
676  ) {
677    int32_t line_index; 
678    int32_t low_index;  
679    int32_t high_index; 
680    int32_t sum;        
681    int32_t divisor;    
682    int32_t min_index;  
683    int32_t min_occ;    
684    int32_t test_index; 
685    divisor = static_cast<int32_t>(ceil((low_window + high_window) / textord_occupancy_threshold));
686    if (low_window + high_window < line_count) {
687      for (sum = 0, high_index = 0; high_index < low_window; high_index++) {
688        sum += occupation[high_index];
689      }
690      for (low_index = 0; low_index < high_window; low_index++, high_index++) {
691        sum += occupation[high_index];
692      }
693      min_occ = occupation[0];
694      min_index = 0;
695      for (test_index = 1; test_index < high_index; test_index++) {
696        if (occupation[test_index] <= min_occ) {
697          min_occ = occupation[test_index];
698          min_index = test_index; 
699        }
700      }
701      for (line_index = 0; line_index < low_window; line_index++) {
702        thresholds[line_index] = (sum - min_occ) / divisor + min_occ;
703      }
704      for (low_index = 0; high_index < line_count; low_index++, high_index++) {
705        sum -= occupation[low_index];
706        sum += occupation[high_index];
707        if (occupation[high_index] <= min_occ) {
708          min_occ = occupation[high_index];
709          min_index = high_index;
710        }
711        if (min_index <= low_index) {
712          min_occ = occupation[low_index + 1];
713          min_index = low_index + 1;
714          for (test_index = low_index + 2; test_index <= high_index; test_index++) {
715            if (occupation[test_index] <= min_occ) {
716              min_occ = occupation[test_index];
717              min_index = test_index;
718            }
719          }
720        }
721        thresholds[line_index++] = (sum - min_occ) / divisor + min_occ;
722      }
723    } else {
724      min_occ = occupation[0];
725      min_index = 0;
726      for (sum = 0, low_index = 0; low_index < line_count; low_index++) {
727        if (occupation[low_index] < min_occ) {
728          min_occ = occupation[low_index];
729          min_index = low_index;
730        }
731        sum += occupation[low_index];
732      }
733      line_index = 0;
734    }
735    for (; line_index < line_count; line_index++) {
736      thresholds[line_index] = (sum - min_occ) / divisor + min_occ;
737    }
738  }
739  void compute_dropout_distances( 
740      int32_t *occupation,        
741      int32_t *thresholds,        
742      int32_t line_count          
743  ) {
744    int32_t line_index;     
745    int32_t distance;       
746    int32_t next_dist;      
747    int32_t back_index;     
748    int32_t prev_threshold; 
749    distance = -line_count;
750    line_index = 0;
751    do {
752      do {
753        distance--;
754        prev_threshold = thresholds[line_index];
755        thresholds[line_index] = distance;
756        line_index++;
757      } while (line_index < line_count && (occupation[line_index] < thresholds[line_index] ||
758                                           occupation[line_index - 1] >= prev_threshold));
759      if (line_index < line_count) {
760        back_index = line_index - 1;
761        next_dist = 1;
762        while (next_dist < -distance && back_index >= 0) {
763          thresholds[back_index] = next_dist;
764          back_index--;
765          next_dist++;
766          distance++;
767        }
768        distance = 1;
769      }
770    } while (line_index < line_count);
771  }
772  void expand_rows(       
773      ICOORD page_tr,     
774      TO_BLOCK *block,    
775      float gradient,     
776      FCOORD rotation,    
777      int32_t block_edge, 
778      bool testing_on     
779  ) {
780    bool swallowed_row;    
781    float y_max, y_min;    
782    float y_bottom, y_top; 
783    TO_ROW *test_row;      
784    TO_ROW *row;           
785    BLOBNBOX_IT blob_it = &block->blobs;
786    TO_ROW_IT row_it = block->get_rows();
787  #ifndef GRAPHICS_DISABLED
788    if (textord_show_expanded_rows && testing_on) {
789      if (to_win == nullptr) {
790        create_to_win(page_tr);
791      }
792    }
793  #endif
794    adjust_row_limits(block); 
795    if (textord_new_initial_xheight) {
796      if (block->get_rows()->empty()) {
797        return;
798      }
799      compute_row_stats(block, textord_show_expanded_rows && testing_on);
800    }
801    assign_blobs_to_rows(block, &gradient, 4, true, false, false);
802    if (block->get_rows()->empty()) {
803      return;
804    }
805    fit_parallel_rows(block, gradient, rotation, block_edge,
806                      textord_show_expanded_rows && testing_on);
807    if (!textord_new_initial_xheight) {
808      compute_row_stats(block, textord_show_expanded_rows && testing_on);
809    }
810    row_it.move_to_last();
811    do {
812      row = row_it.data();
813      y_max = row->max_y(); 
814      y_min = row->min_y();
815      y_bottom = row->intercept() - block->line_size * textord_expansion_factor *
816                                        tesseract::CCStruct::kDescenderFraction;
817      y_top = row->intercept() +
818              block->line_size * textord_expansion_factor *
819                  (tesseract::CCStruct::kXHeightFraction + tesseract::CCStruct::kAscenderFraction);
820      if (y_min > y_bottom) { 
821        if (textord_show_expanded_rows && testing_on) {
822          tprintf("Expanding bottom of row at %f from %f to %f\n", row->intercept(), y_min, y_bottom);
823        }
824        swallowed_row = true;
825        while (swallowed_row && !row_it.at_last()) {
826          swallowed_row = false;
827          test_row = row_it.data_relative(1);
828          if (test_row->max_y() > y_bottom) {
829            if (test_row->min_y() > y_bottom) {
830              if (textord_show_expanded_rows && testing_on) {
831                tprintf("Eating row below at %f\n", test_row->intercept());
832              }
833              row_it.forward();
834  #ifndef GRAPHICS_DISABLED
835              if (textord_show_expanded_rows && testing_on) {
836                plot_parallel_row(test_row, gradient, block_edge, ScrollView::WHITE, rotation);
837              }
838  #endif
839              blob_it.set_to_list(row->blob_list());
840              blob_it.add_list_after(test_row->blob_list());
841              delete row_it.extract();
842              row_it.backward();
843              swallowed_row = true;
844            } else if (test_row->max_y() < y_min) {
845              y_bottom = test_row->max_y();
846              if (textord_show_expanded_rows && testing_on) {
847                tprintf("Truncating limit to %f due to touching row at %f\n", y_bottom,
848                        test_row->intercept());
849              }
850            } else {
851              y_bottom = y_min; 
852              if (textord_show_expanded_rows && testing_on) {
853                tprintf("Not expanding limit beyond %f due to touching row at %f\n", y_bottom,
854                        test_row->intercept());
855              }
856            }
857          }
858        }
859        y_min = y_bottom; 
860      }
861      if (y_max < y_top) { 
862        if (textord_show_expanded_rows && testing_on) {
863          tprintf("Expanding top of row at %f from %f to %f\n", row->intercept(), y_max, y_top);
864        }
865        swallowed_row = true;
866        while (swallowed_row && !row_it.at_first()) {
867          swallowed_row = false;
868          test_row = row_it.data_relative(-1);
869          if (test_row->min_y() < y_top) {
870            if (test_row->max_y() < y_top) {
871              if (textord_show_expanded_rows && testing_on) {
872                tprintf("Eating row above at %f\n", test_row->intercept());
873              }
874              row_it.backward();
875              blob_it.set_to_list(row->blob_list());
876  #ifndef GRAPHICS_DISABLED
877              if (textord_show_expanded_rows && testing_on) {
878                plot_parallel_row(test_row, gradient, block_edge, ScrollView::WHITE, rotation);
879              }
880  #endif
881              blob_it.add_list_after(test_row->blob_list());
882              delete row_it.extract();
883              row_it.forward();
884              swallowed_row = true;
885            } else if (test_row->min_y() < y_max) {
886              y_top = test_row->min_y();
887              if (textord_show_expanded_rows && testing_on) {
888                tprintf("Truncating limit to %f due to touching row at %f\n", y_top,
889                        test_row->intercept());
890              }
891            } else {
892              y_top = y_max; 
893              if (textord_show_expanded_rows && testing_on) {
894                tprintf("Not expanding limit beyond %f due to touching row at %f\n", y_top,
895                        test_row->intercept());
896              }
897            }
898          }
899        }
900        y_max = y_top;
901      }
902      row->set_limits(y_min, y_max);
903      row_it.backward();
904    } while (!row_it.at_last());
905  }
906  void adjust_row_limits( 
907      TO_BLOCK *block     
908  ) {
909    TO_ROW *row; 
910    float size;  
911    float ymax;  
912    float ymin;  
913    TO_ROW_IT row_it = block->get_rows();
914    if (textord_show_expanded_rows) {
915      tprintf("Adjusting row limits for block(%d,%d)\n", block->block->pdblk.bounding_box().left(),
916              block->block->pdblk.bounding_box().top());
917    }
918    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
919      row = row_it.data();
920      size = row->max_y() - row->min_y();
921      if (textord_show_expanded_rows) {
922        tprintf("Row at %f has min %f, max %f, size %f\n", row->intercept(), row->min_y(),
923                row->max_y(), size);
924      }
925      size /= tesseract::CCStruct::kXHeightFraction + tesseract::CCStruct::kAscenderFraction +
926              tesseract::CCStruct::kDescenderFraction;
927      ymax = size * (tesseract::CCStruct::kXHeightFraction + tesseract::CCStruct::kAscenderFraction);
928      ymin = -size * tesseract::CCStruct::kDescenderFraction;
929      row->set_limits(row->intercept() + ymin, row->intercept() + ymax);
930      row->merged = false;
931    }
932  }
933  void compute_row_stats( 
934      TO_BLOCK *block,    
935      bool testing_on     
936  ) {
937    int32_t row_index; 
938    TO_ROW *row;       
939    TO_ROW *prev_row;  
940    float iqr;         
941    TO_ROW_IT row_it = block->get_rows();
942    int16_t rowcount = row_it.length();
943    std::vector<TO_ROW *> rows(rowcount);
944    rowcount = 0;
945    prev_row = nullptr;
946    row_it.move_to_last(); 
947    do {
948      row = row_it.data();
949      if (prev_row != nullptr) {
950        rows[rowcount++] = prev_row;
951        prev_row->spacing = row->intercept() - prev_row->intercept();
952        if (prev_row->spacing < 0.1 && prev_row->spacing > -0.1) {
953          prev_row->spacing = 0;
954        }
955        if (testing_on) {
956          tprintf("Row at %g yields spacing of %g\n", row->intercept(), prev_row->spacing);
957        }
958      }
959      prev_row = row;
960      row_it.backward();
961    } while (!row_it.at_last());
962    block->key_row = prev_row;
963    block->baseline_offset = std::fmod(prev_row->parallel_c(), block->line_spacing);
964    if (testing_on) {
965      tprintf("Blob based spacing=(%g,%g), offset=%g", block->line_size, block->line_spacing,
966              block->baseline_offset);
967    }
968    if (rowcount > 0) {
969      rows.resize(rowcount);
970      row_index = rowcount * 3 / 4;
971      std::nth_element(rows.begin(), rows.begin() + row_index, rows.end(), row_spacing_order);
972      iqr = rows[row_index]->spacing;
973      row_index = rowcount / 4;
974      std::nth_element(rows.begin(), rows.begin() + row_index, rows.end(), row_spacing_order);
975      iqr -= rows[row_index]->spacing;
976      row_index = rowcount / 2;
977      std::nth_element(rows.begin(), rows.begin() + row_index, rows.end(), row_spacing_order);
978      block->key_row = rows[row_index];
979      if (testing_on) {
980        tprintf(" row based=%g(%g)", rows[row_index]->spacing, iqr);
981      }
982      if (rowcount > 2 && iqr < rows[row_index]->spacing * textord_linespace_iqrlimit) {
983        if (!textord_new_initial_xheight) {
984          if (rows[row_index]->spacing < block->line_spacing &&
985              rows[row_index]->spacing > block->line_size) {
986            block->line_size = rows[row_index]->spacing;
987          } else if (rows[row_index]->spacing > block->line_spacing) {
988            block->line_size = block->line_spacing;
989          }
990        } else {
991          if (rows[row_index]->spacing < block->line_spacing) {
992            block->line_size = rows[row_index]->spacing;
993          } else {
994            block->line_size = block->line_spacing;
995          }
996        }
997        if (block->line_size < textord_min_xheight) {
998          block->line_size = (float)textord_min_xheight;
999        }
1000        block->line_spacing = rows[row_index]->spacing;
1001        block->max_blob_size = block->line_spacing * textord_excess_blobsize;
1002      }
1003      block->baseline_offset = std::fmod(rows[row_index]->intercept(), block->line_spacing);
1004    }
1005    if (testing_on) {
1006      tprintf("\nEstimate line size=%g, spacing=%g, offset=%g\n", block->line_size,
1007              block->line_spacing, block->baseline_offset);
1008    }
1009  }
1010  void Textord::compute_block_xheight(TO_BLOCK *block, float gradient) {
1011    TO_ROW *row; 
1012    float asc_frac_xheight = CCStruct::kAscenderFraction / CCStruct::kXHeightFraction;
1013    float desc_frac_xheight = CCStruct::kDescenderFraction / CCStruct::kXHeightFraction;
1014    int32_t min_height, max_height; 
1015    TO_ROW_IT row_it = block->get_rows();
1016    if (row_it.empty()) {
1017      return; 
1018    }
1019    get_min_max_xheight(block->line_size, &min_height, &max_height);
1020    STATS row_asc_xheights(min_height, max_height);
1021    STATS row_asc_ascrise(static_cast<int>(min_height * asc_frac_xheight),
1022                          static_cast<int>(max_height * asc_frac_xheight));
1023    int min_desc_height = static_cast<int>(min_height * desc_frac_xheight);
1024    int max_desc_height = static_cast<int>(max_height * desc_frac_xheight);
1025    STATS row_asc_descdrop(min_desc_height, max_desc_height);
1026    STATS row_desc_xheights(min_height, max_height);
1027    STATS row_desc_descdrop(min_desc_height, max_desc_height);
1028    STATS row_cap_xheights(min_height, max_height);
1029    STATS row_cap_floating_xheights(min_height, max_height);
1030    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1031      row = row_it.data();
1032      if (row->xheight <= 0) {
1033        compute_row_xheight(row, block->block->classify_rotation(), gradient, block->line_size);
1034      }
1035      ROW_CATEGORY row_category = get_row_category(row);
1036      if (row_category == ROW_ASCENDERS_FOUND) {
1037        row_asc_xheights.add(static_cast<int32_t>(row->xheight), row->xheight_evidence);
1038        row_asc_ascrise.add(static_cast<int32_t>(row->ascrise), row->xheight_evidence);
1039        row_asc_descdrop.add(static_cast<int32_t>(-row->descdrop), row->xheight_evidence);
1040      } else if (row_category == ROW_DESCENDERS_FOUND) {
1041        row_desc_xheights.add(static_cast<int32_t>(row->xheight), row->xheight_evidence);
1042        row_desc_descdrop.add(static_cast<int32_t>(-row->descdrop), row->xheight_evidence);
1043      } else if (row_category == ROW_UNKNOWN) {
1044        fill_heights(row, gradient, min_height, max_height, &row_cap_xheights,
1045                     &row_cap_floating_xheights);
1046      }
1047    }
1048    float xheight = 0.0;
1049    float ascrise = 0.0;
1050    float descdrop = 0.0;
1051    if (row_asc_xheights.get_total() > 0) {
1052      xheight = row_asc_xheights.median();
1053      ascrise = row_asc_ascrise.median();
1054      descdrop = -row_asc_descdrop.median();
1055    } else if (row_desc_xheights.get_total() > 0) {
1056      xheight = row_desc_xheights.median();
1057      descdrop = -row_desc_descdrop.median();
1058    } else if (row_cap_xheights.get_total() > 0) {
1059      compute_xheight_from_modes(
1060          &row_cap_xheights, &row_cap_floating_xheights,
1061          textord_single_height_mode && block->block->classify_rotation().y() == 0.0, min_height,
1062          max_height, &(xheight), &(ascrise));
1063      if (ascrise == 0) { 
1064        xheight = row_cap_xheights.median() * CCStruct::kXHeightCapRatio;
1065      }
1066    } else { 
1067      xheight = block->line_size * CCStruct::kXHeightFraction;
1068    }
1069    bool corrected_xheight = false;
1070    if (xheight < textord_min_xheight) {
1071      xheight = static_cast<float>(textord_min_xheight);
1072      corrected_xheight = true;
1073    }
1074    if (corrected_xheight || ascrise <= 0) {
1075      ascrise = xheight * asc_frac_xheight;
1076    }
1077    if (corrected_xheight || descdrop >= 0) {
1078      descdrop = -(xheight * desc_frac_xheight);
1079    }
1080    block->xheight = xheight;
1081    if (textord_debug_xheights) {
1082      tprintf("Block average xheight=%.4f, ascrise=%.4f, descdrop=%.4f\n", xheight, ascrise,
1083              descdrop);
1084    }
1085    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1086      correct_row_xheight(row_it.data(), xheight, ascrise, descdrop);
1087    }
1088  }
1089  void Textord::compute_row_xheight(TO_ROW *row, 
1090                                    const FCOORD &rotation,
1091                                    float gradient, 
1092                                    int block_line_size) {
1093    if (!row->rep_chars_marked()) {
1094      mark_repeated_chars(row);
1095    }
1096    int min_height, max_height;
1097    get_min_max_xheight(block_line_size, &min_height, &max_height);
1098    STATS heights(min_height, max_height);
1099    STATS floating_heights(min_height, max_height);
1100    fill_heights(row, gradient, min_height, max_height, &heights, &floating_heights);
1101    row->ascrise = 0.0f;
1102    row->xheight = 0.0f;
1103    row->xheight_evidence = compute_xheight_from_modes(
1104        &heights, &floating_heights, textord_single_height_mode && rotation.y() == 0.0, min_height,
1105        max_height, &(row->xheight), &(row->ascrise));
1106    row->descdrop = 0.0f;
1107    if (row->xheight > 0) {
1108      row->descdrop =
1109          static_cast<float>(compute_row_descdrop(row, gradient, row->xheight_evidence, &heights));
1110    }
1111  }
1112  void fill_heights(TO_ROW *row, float gradient, int min_height, int max_height, STATS *heights,
1113                    STATS *floating_heights) {
1114    float xcentre;  
1115    float top;      
1116    float height;   
1117    BLOBNBOX *blob; 
1118    int repeated_set;
1119    BLOBNBOX_IT blob_it = row->blob_list();
1120    if (blob_it.empty()) {
1121      return; 
1122    }
1123    bool has_rep_chars = row->rep_chars_marked() && row->num_repeated_sets() > 0;
1124    do {
1125      blob = blob_it.data();
1126      if (!blob->joined_to_prev()) {
1127        xcentre = (blob->bounding_box().left() + blob->bounding_box().right()) / 2.0f;
1128        top = blob->bounding_box().top();
1129        height = blob->bounding_box().height();
1130        if (textord_fix_xheight_bug) {
1131          top -= row->baseline.y(xcentre);
1132        } else {
1133          top -= gradient * xcentre + row->parallel_c();
1134        }
1135        if (top >= min_height && top <= max_height) {
1136          heights->add(static_cast<int32_t>(floor(top + 0.5)), 1);
1137          if (height / top < textord_min_blob_height_fraction) {
1138            floating_heights->add(static_cast<int32_t>(floor(top + 0.5)), 1);
1139          }
1140        }
1141      }
1142      if (has_rep_chars && blob->repeated_set() != 0) {
1143        repeated_set = blob->repeated_set();
1144        blob_it.forward();
1145        while (!blob_it.at_first() && blob_it.data()->repeated_set() == repeated_set) {
1146          blob_it.forward();
1147          if (textord_debug_xheights) {
1148            tprintf("Skipping repeated char when computing xheight\n");
1149          }
1150        }
1151      } else {
1152        blob_it.forward();
1153      }
1154    } while (!blob_it.at_first());
1155  }
1156  int compute_xheight_from_modes(STATS *heights, STATS *floating_heights, bool cap_only,
1157                                 int min_height, int max_height, float *xheight, float *ascrise) {
1158    int blob_index = heights->mode();                 
1159    int blob_count = heights->pile_count(blob_index); 
1160    if (textord_debug_xheights) {
1161      tprintf("min_height=%d, max_height=%d, mode=%d, count=%d, total=%d\n", min_height, max_height,
1162              blob_index, blob_count, heights->get_total());
1163      heights->print();
1164      floating_heights->print();
1165    }
1166    if (blob_count == 0) {
1167      return 0;
1168    }
1169    int modes[MAX_HEIGHT_MODES]; 
1170    bool in_best_pile = false;
1171    int prev_size = -INT32_MAX;
1172    int best_count = 0;
1173    int mode_count = compute_height_modes(heights, min_height, max_height, modes, MAX_HEIGHT_MODES);
1174    if (cap_only && mode_count > 1) {
1175      mode_count = 1;
1176    }
1177    int x;
1178    if (textord_debug_xheights) {
1179      tprintf("found %d modes: ", mode_count);
1180      for (x = 0; x < mode_count; x++) {
1181        tprintf("%d ", modes[x]);
1182      }
1183      tprintf("\n");
1184    }
1185    for (x = 0; x < mode_count - 1; x++) {
1186      if (modes[x] != prev_size + 1) {
1187        in_best_pile = false; 
1188      }
1189      int modes_x_count = heights->pile_count(modes[x]) - floating_heights->pile_count(modes[x]);
1190      if ((modes_x_count >= blob_count * textord_xheight_mode_fraction) &&
1191          (in_best_pile || modes_x_count > best_count)) {
1192        for (int asc = x + 1; asc < mode_count; asc++) {
1193          float ratio = static_cast<float>(modes[asc]) / static_cast<float>(modes[x]);
1194          if (textord_ascx_ratio_min < ratio && ratio < textord_ascx_ratio_max &&
1195              (heights->pile_count(modes[asc]) >= blob_count * textord_ascheight_mode_fraction)) {
1196            if (modes_x_count > best_count) {
1197              in_best_pile = true;
1198              best_count = modes_x_count;
1199            }
1200            if (textord_debug_xheights) {
1201              tprintf("X=%d, asc=%d, count=%d, ratio=%g\n", modes[x], modes[asc] - modes[x],
1202                      modes_x_count, ratio);
1203            }
1204            prev_size = modes[x];
1205            *xheight = static_cast<float>(modes[x]);
1206            *ascrise = static_cast<float>(modes[asc] - modes[x]);
1207          }
1208        }
1209      }
1210    }
1211    if (*xheight == 0) { 
1212      if (floating_heights->get_total() > 0) {
1213        for (x = min_height; x < max_height; ++x) {
1214          heights->add(x, -(floating_heights->pile_count(x)));
1215        }
1216        blob_index = heights->mode(); 
1217        for (x = min_height; x < max_height; ++x) {
1218          heights->add(x, floating_heights->pile_count(x));
1219        }
1220      }
1221      *xheight = static_cast<float>(blob_index);
1222      *ascrise = 0.0f;
1223      best_count = heights->pile_count(blob_index);
1224      if (textord_debug_xheights) {
1225        tprintf("Single mode xheight set to %g\n", *xheight);
1226      }
1227    } else if (textord_debug_xheights) {
1228      tprintf("Multi-mode xheight set to %g, asc=%g\n", *xheight, *ascrise);
1229    }
1230    return best_count;
1231  }
1232  int32_t compute_row_descdrop(TO_ROW *row, float gradient, int xheight_blob_count,
1233                               STATS *asc_heights) {
1234    int i_min = asc_heights->min_bucket();
1235    if ((i_min / row->xheight) < textord_ascx_ratio_min) {
1236      i_min = static_cast<int>(floor(row->xheight * textord_ascx_ratio_min + 0.5));
1237    }
1238    int i_max = asc_heights->max_bucket();
1239    if ((i_max / row->xheight) > textord_ascx_ratio_max) {
1240      i_max = static_cast<int>(floor(row->xheight * textord_ascx_ratio_max));
1241    }
1242    int num_potential_asc = 0;
1243    for (int i = i_min; i <= i_max; ++i) {
1244      num_potential_asc += asc_heights->pile_count(i);
1245    }
1246    auto min_height = static_cast<int32_t>(floor(row->xheight * textord_descx_ratio_min + 0.5));
1247    auto max_height = static_cast<int32_t>(floor(row->xheight * textord_descx_ratio_max));
1248    float xcentre; 
1249    float height;  
1250    BLOBNBOX_IT blob_it = row->blob_list();
1251    BLOBNBOX *blob; 
1252    STATS heights(min_height, max_height);
1253    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1254      blob = blob_it.data();
1255      if (!blob->joined_to_prev()) {
1256        xcentre = (blob->bounding_box().left() + blob->bounding_box().right()) / 2.0f;
1257        height = (gradient * xcentre + row->parallel_c() - blob->bounding_box().bottom());
1258        if (height >= min_height && height <= max_height) {
1259          heights.add(static_cast<int>(floor(height + 0.5)), 1);
1260        }
1261      }
1262    }
1263    int blob_index = heights.mode();                 
1264    int blob_count = heights.pile_count(blob_index); 
1265    float total_fraction = (textord_descheight_mode_fraction + textord_ascheight_mode_fraction);
1266    if (static_cast<float>(blob_count + num_potential_asc) < xheight_blob_count * total_fraction) {
1267      blob_count = 0;
1268    }
1269    int descdrop = blob_count > 0 ? -blob_index : 0;
1270    if (textord_debug_xheights) {
1271      tprintf("Descdrop: %d (potential ascenders %d, descenders %d)\n", descdrop, num_potential_asc,
1272              blob_count);
1273      heights.print();
1274    }
1275    return descdrop;
1276  }
1277  int32_t compute_height_modes(STATS *heights,     
1278                               int32_t min_height, 
1279                               int32_t max_height, 
1280                               int32_t *modes,     
1281                               int32_t maxmodes) { 
1282    int32_t pile_count;                            
1283    int32_t src_count;                             
1284    int32_t src_index;                             
1285    int32_t least_count;                           
1286    int32_t least_index;                           
1287    int32_t dest_count;                            
1288    src_count = max_height + 1 - min_height;
1289    dest_count = 0;
1290    least_count = INT32_MAX;
1291    least_index = -1;
1292    for (src_index = 0; src_index < src_count; src_index++) {
1293      pile_count = heights->pile_count(min_height + src_index);
1294      if (pile_count > 0) {
1295        if (dest_count < maxmodes) {
1296          if (pile_count < least_count) {
1297            least_count = pile_count;
1298            least_index = dest_count;
1299          }
1300          modes[dest_count++] = min_height + src_index;
1301        } else if (pile_count >= least_count) {
1302          while (least_index < maxmodes - 1) {
1303            modes[least_index] = modes[least_index + 1];
1304            least_index++;
1305          }
1306          modes[maxmodes - 1] = min_height + src_index;
1307          if (pile_count == least_count) {
1308            least_index = maxmodes - 1;
1309          } else {
1310            least_count = heights->pile_count(modes[0]);
1311            least_index = 0;
1312            for (dest_count = 1; dest_count < maxmodes; dest_count++) {
1313              pile_count = heights->pile_count(modes[dest_count]);
1314              if (pile_count < least_count) {
1315                least_count = pile_count;
1316                least_index = dest_count;
1317              }
1318            }
1319          }
1320        }
1321      }
1322    }
1323    return dest_count;
1324  }
1325  void correct_row_xheight(TO_ROW *row, float xheight, float ascrise, float descdrop) {
1326    ROW_CATEGORY row_category = get_row_category(row);
1327    if (textord_debug_xheights) {
1328      tprintf(
1329          "correcting row xheight: row->xheight %.4f"
1330          ", row->acrise %.4f row->descdrop %.4f\n",
1331          row->xheight, row->ascrise, row->descdrop);
1332    }
1333    bool normal_xheight = within_error_margin(row->xheight, xheight, textord_xheight_error_margin);
1334    bool cap_xheight =
1335        within_error_margin(row->xheight, xheight + ascrise, textord_xheight_error_margin);
1336    if (row_category == ROW_ASCENDERS_FOUND) {
1337      if (row->descdrop >= 0) {
1338        row->descdrop = row->xheight * (descdrop / xheight);
1339      }
1340    } else if (row_category == ROW_INVALID ||
1341               (row_category == ROW_DESCENDERS_FOUND && (normal_xheight || cap_xheight)) ||
1342               (row_category == ROW_UNKNOWN && normal_xheight)) {
1343      if (textord_debug_xheights) {
1344        tprintf("using average xheight\n");
1345      }
1346      row->xheight = xheight;
1347      row->ascrise = ascrise;
1348      row->descdrop = descdrop;
1349    } else if (row_category == ROW_DESCENDERS_FOUND) {
1350      if (textord_debug_xheights) {
1351        tprintf("lowercase, corrected ascrise\n");
1352      }
1353      row->ascrise = row->xheight * (ascrise / xheight);
1354    } else if (row_category == ROW_UNKNOWN) {
1355      row->all_caps = true;
1356      if (cap_xheight) { 
1357        if (textord_debug_xheights) {
1358          tprintf("all caps\n");
1359        }
1360        row->xheight = xheight;
1361        row->ascrise = ascrise;
1362        row->descdrop = descdrop;
1363      } else { 
1364        if (textord_debug_xheights) {
1365          if (row->xheight < xheight + ascrise && row->xheight > xheight) {
1366            tprintf("small caps\n");
1367          } else {
1368            tprintf("all caps with irregular xheight\n");
1369          }
1370        }
1371        row->ascrise = row->xheight * (ascrise / (xheight + ascrise));
1372        row->xheight -= row->ascrise;
1373        row->descdrop = row->xheight * (descdrop / xheight);
1374      }
1375    }
1376    if (textord_debug_xheights) {
1377      tprintf(
1378          "corrected row->xheight = %.4f, row->acrise = %.4f, row->descdrop"
1379          " = %.4f\n",
1380          row->xheight, row->ascrise, row->descdrop);
1381    }
1382  }
1383  static int CountOverlaps(const TBOX &box, int min_height, BLOBNBOX_LIST *blobs) {
1384    int overlaps = 0;
1385    BLOBNBOX_IT blob_it(blobs);
1386    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1387      BLOBNBOX *blob = blob_it.data();
1388      const TBOX &blob_box = blob->bounding_box();
1389      if (blob_box.height() >= min_height && box.major_overlap(blob_box)) {
1390        ++overlaps;
1391      }
1392    }
1393    return overlaps;
1394  }
1395  void separate_underlines(TO_BLOCK *block,   
1396                           float gradient,    
1397                           FCOORD rotation,   
1398                           bool testing_on) { 
1399    BLOBNBOX *blob;                           
1400    C_BLOB *rotated_blob;                     
1401    TO_ROW *row;                              
1402    float length;                             
1403    TBOX blob_box;
1404    FCOORD blob_rotation; 
1405    FCOORD g_vec;         
1406    BLOBNBOX_IT blob_it;  
1407    BLOBNBOX_IT under_it = &block->underlines;
1408    BLOBNBOX_IT large_it = &block->large_blobs;
1409    TO_ROW_IT row_it = block->get_rows();
1410    int min_blob_height = static_cast<int>(textord_min_blob_height_fraction * block->line_size + 0.5);
1411    length = std::sqrt(1 + gradient * gradient);
1412    g_vec = FCOORD(1 / length, -gradient / length);
1413    blob_rotation = FCOORD(rotation.x(), -rotation.y());
1414    blob_rotation.rotate(g_vec); 
1415    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1416      row = row_it.data();
1417      blob_it.set_to_list(row->blob_list());
1418      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1419        blob = blob_it.data();
1420        blob_box = blob->bounding_box();
1421        if (blob_box.width() > block->line_size * textord_underline_width) {
1422          ASSERT_HOST(blob->cblob() != nullptr);
1423          rotated_blob = crotate_cblob(blob->cblob(), blob_rotation);
1424          if (test_underline(testing_on && textord_show_final_rows, rotated_blob,
1425                             static_cast<int16_t>(row->intercept()),
1426                             static_cast<int16_t>(block->line_size *
1427                                                  (tesseract::CCStruct::kXHeightFraction +
1428                                                   tesseract::CCStruct::kAscenderFraction / 2.0f)))) {
1429            under_it.add_after_then_move(blob_it.extract());
1430            if (testing_on && textord_show_final_rows) {
1431              tprintf("Underlined blob at:");
1432              rotated_blob->bounding_box().print();
1433              tprintf("Was:");
1434              blob_box.print();
1435            }
1436          } else if (CountOverlaps(blob->bounding_box(), min_blob_height, row->blob_list()) >
1437                     textord_max_blob_overlaps) {
1438            large_it.add_after_then_move(blob_it.extract());
1439            if (testing_on && textord_show_final_rows) {
1440              tprintf("Large blob overlaps %d blobs at:",
1441                      CountOverlaps(blob_box, min_blob_height, row->blob_list()));
1442              blob_box.print();
1443            }
1444          }
1445          delete rotated_blob;
1446        }
1447      }
1448    }
1449  }
1450  void pre_associate_blobs( 
1451      ICOORD page_tr,       
1452      TO_BLOCK *block,      
1453      FCOORD rotation,      
1454      bool testing_on       
1455  ) {
1456  #ifndef GRAPHICS_DISABLED
1457    ScrollView::Color colour; 
1458  #endif
1459    BLOBNBOX *blob;     
1460    BLOBNBOX *nextblob; 
1461    TBOX blob_box;
1462    FCOORD blob_rotation; 
1463    BLOBNBOX_IT blob_it;  
1464    BLOBNBOX_IT start_it; 
1465    TO_ROW_IT row_it = block->get_rows();
1466  #ifndef GRAPHICS_DISABLED
1467    colour = ScrollView::RED;
1468  #endif
1469    blob_rotation = FCOORD(rotation.x(), -rotation.y());
1470    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1471      blob_it.set_to_list(row_it.data()->blob_list());
1472      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1473        blob = blob_it.data();
1474        blob_box = blob->bounding_box();
1475        start_it = blob_it; 
1476        bool overlap;
1477        do {
1478          overlap = false;
1479          if (!blob_it.at_last()) {
1480            nextblob = blob_it.data_relative(1);
1481            overlap = blob_box.major_x_overlap(nextblob->bounding_box());
1482            if (overlap) {
1483              blob->merge(nextblob);           
1484              blob_box = blob->bounding_box(); 
1485              blob_it.forward();
1486            }
1487          }
1488        } while (overlap);
1489        blob->chop(&start_it, &blob_it, blob_rotation,
1490                   block->line_size * tesseract::CCStruct::kXHeightFraction * textord_chop_width);
1491      }
1492  #ifndef GRAPHICS_DISABLED
1493      if (testing_on && textord_show_final_blobs) {
1494        if (to_win == nullptr) {
1495          create_to_win(page_tr);
1496        }
1497        to_win->Pen(colour);
1498        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1499          blob = blob_it.data();
1500          blob_box = blob->bounding_box();
1501          blob_box.rotate(rotation);
1502          if (!blob->joined_to_prev()) {
1503            to_win->Rectangle(blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
1504          }
1505        }
1506        colour = static_cast<ScrollView::Color>(colour + 1);
1507        if (colour > ScrollView::MAGENTA) {
1508          colour = ScrollView::RED;
1509        }
1510      }
1511  #endif
1512    }
1513  }
1514  void fit_parallel_rows( 
1515      TO_BLOCK *block,    
1516      float gradient,     
1517      FCOORD rotation,    
1518      int32_t block_edge, 
1519      bool testing_on     
1520  ) {
1521  #ifndef GRAPHICS_DISABLED
1522    ScrollView::Color colour; 
1523  #endif
1524    TO_ROW_IT row_it = block->get_rows();
1525    row_it.move_to_first();
1526    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1527      if (row_it.data()->blob_list()->empty()) {
1528        delete row_it.extract(); 
1529      } else {
1530        fit_parallel_lms(gradient, row_it.data());
1531      }
1532    }
1533  #ifndef GRAPHICS_DISABLED
1534    if (testing_on) {
1535      colour = ScrollView::RED;
1536      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1537        plot_parallel_row(row_it.data(), gradient, block_edge, colour, rotation);
1538        colour = static_cast<ScrollView::Color>(colour + 1);
1539        if (colour > ScrollView::MAGENTA) {
1540          colour = ScrollView::RED;
1541        }
1542      }
1543    }
1544  #endif
<span onclick='openModal()' class='match'>1545    row_it.sort(row_y_order); 
1546  }
1547  void fit_parallel_lms(float gradient, TO_ROW *row) {
1548    float c;       
1549    int blobcount; 
1550    tesseract::DetLineFit lms;
1551    BLOBNBOX_IT blob_it = row->blob_list();
</span>1552    blobcount = 0;
1553    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1554      if (!blob_it.data()->joined_to_prev()) {
1555        const TBOX &box = blob_it.data()->bounding_box();
1556        lms.Add(ICOORD((box.left() + box.right()) / 2, box.bottom()));
1557        blobcount++;
1558      }
1559    }
1560    double error = lms.ConstrainedFit(gradient, &c);
1561    row->set_parallel_line(gradient, c, error);
1562    if (textord_straight_baselines && blobcount > textord_lms_line_trials) {
1563      error = lms.Fit(&gradient, &c);
1564    }
1565    row->set_line(gradient, c, error);
1566  }
1567  void Textord::make_spline_rows(TO_BLOCK *block, 
1568                                 float gradient,  
1569                                 bool testing_on) {
1570  #ifndef GRAPHICS_DISABLED
1571    ScrollView::Color colour; 
1572    if (testing_on && to_win == nullptr) {
1573      create_to_win(page_tr_);
1574    }
1575  #endif
1576    TO_ROW_IT row_it = block->get_rows();
1577    row_it.move_to_first();
1578    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1579      if (row_it.data()->blob_list()->empty()) {
1580        delete row_it.extract(); 
1581      } else {
1582        make_baseline_spline(row_it.data(), block);
1583      }
1584    }
1585    if (textord_old_baselines) {
1586  #ifndef GRAPHICS_DISABLED
1587      if (testing_on) {
1588        colour = ScrollView::RED;
1589        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1590          row_it.data()->baseline.plot(to_win, colour);
1591          colour = static_cast<ScrollView::Color>(colour + 1);
1592          if (colour > ScrollView::MAGENTA) {
1593            colour = ScrollView::RED;
1594          }
1595        }
1596      }
1597  #endif
1598      make_old_baselines(block, testing_on, gradient);
1599    }
1600  #ifndef GRAPHICS_DISABLED
1601    if (testing_on) {
1602      colour = ScrollView::RED;
1603      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1604        row_it.data()->baseline.plot(to_win, colour);
1605        colour = static_cast<ScrollView::Color>(colour + 1);
1606        if (colour > ScrollView::MAGENTA) {
1607          colour = ScrollView::RED;
1608        }
1609      }
1610    }
1611  #endif
1612  }
1613  void make_baseline_spline(TO_ROW *row, 
1614                            TO_BLOCK *block) {
1615    double *coeffs;   
1616    int32_t segments; 
1617    auto *xstarts = new int32_t[row->blob_list()->length() + 1];
1618    if (segment_baseline(row, block, segments, xstarts) && !textord_straight_baselines &&
1619        !textord_parallel_baselines) {
1620      coeffs = linear_spline_baseline(row, block, segments, xstarts);
1621    } else {
1622      xstarts[1] = xstarts[segments];
1623      segments = 1;
1624      coeffs = new double[3];
1625      coeffs[0] = 0;
1626      coeffs[1] = row->line_m();
1627      coeffs[2] = row->line_c();
1628    }
1629    row->baseline = QSPLINE(segments, xstarts, coeffs);
1630    delete[] coeffs;
1631    delete[] xstarts;
1632  }
1633  bool segment_baseline( 
1634      TO_ROW *row,       
1635      TO_BLOCK *block,   
1636      int32_t &segments, 
1637      int32_t *xstarts   
1638  ) {
1639    bool needs_curve; 
1640    int blobcount;    
1641    int blobindex;    
1642    int last_state;   
1643    int state;        
1644    float yshift;     
1645    TBOX box;         
1646    TBOX new_box;     
1647    float middle;     
1648    BLOBNBOX_IT blob_it = row->blob_list();
1649    BLOBNBOX_IT new_it = blob_it; 
1650    SORTED_FLOATS yshifts;        
1651    needs_curve = false;
1652    box = box_next_pre_chopped(&blob_it);
1653    xstarts[0] = box.left();
1654    segments = 1;
1655    blobcount = row->blob_list()->length();
1656    if (textord_oldbl_debug) {
1657      tprintf("Segmenting baseline of %d blobs at (%d,%d)\n", blobcount, box.left(), box.bottom());
1658    }
1659    if (blobcount <= textord_spline_medianwin || blobcount < textord_spline_minblobs) {
1660      blob_it.move_to_last();
1661      box = blob_it.data()->bounding_box();
1662      xstarts[1] = box.right();
1663      return false;
1664    }
1665    last_state = 0;
1666    new_it.mark_cycle_pt();
1667    for (blobindex = 0; blobindex < textord_spline_medianwin; blobindex++) {
1668      new_box = box_next_pre_chopped(&new_it);
1669      middle = (new_box.left() + new_box.right()) / 2.0;
1670      yshift = new_box.bottom() - row->line_m() * middle - row->line_c();
1671      yshifts.add(yshift, blobindex);
1672      if (new_it.cycled_list()) {
1673        xstarts[1] = new_box.right();
1674        return false;
1675      }
1676    }
1677    for (blobcount = 0; blobcount < textord_spline_medianwin / 2; blobcount++) {
1678      box = box_next_pre_chopped(&blob_it);
1679    }
1680    do {
1681      new_box = box_next_pre_chopped(&new_it);
1682      yshift = yshifts[textord_spline_medianwin / 2];
1683      if (yshift > textord_spline_shift_fraction * block->line_size) {
1684        state = 1;
1685      } else if (-yshift > textord_spline_shift_fraction * block->line_size) {
1686        state = -1;
1687      } else {
1688        state = 0;
1689      }
1690      if (state != 0) {
1691        needs_curve = true;
1692      }
1693      if (state != last_state && blobcount > textord_spline_minblobs) {
1694        xstarts[segments++] = box.left();
1695        blobcount = 0;
1696      }
1697      last_state = state;
1698      yshifts.remove(blobindex - textord_spline_medianwin);
1699      box = box_next_pre_chopped(&blob_it);
1700      middle = (new_box.left() + new_box.right()) / 2.0;
1701      yshift = new_box.bottom() - row->line_m() * middle - row->line_c();
1702      yshifts.add(yshift, blobindex);
1703      blobindex++;
1704      blobcount++;
1705    } while (!new_it.cycled_list());
1706    if (blobcount > textord_spline_minblobs || segments == 1) {
1707      xstarts[segments] = new_box.right();
1708    } else {
1709      xstarts[--segments] = new_box.right();
1710    }
1711    if (textord_oldbl_debug) {
1712      tprintf("Made %d segments on row at (%d,%d)\n", segments, box.right(), box.bottom());
1713    }
1714    return needs_curve;
1715  }
1716  double *linear_spline_baseline( 
1717      TO_ROW *row,                
1718      TO_BLOCK *block,            
1719      int32_t &segments,          
1720      int32_t xstarts[]           
1721  ) {
1722    int blobcount;         
1723    int blobindex;         
1724    int index1, index2;    
1725    int blobs_per_segment; 
1726    TBOX box;              
1727    TBOX new_box;          
1728    BLOBNBOX_IT blob_it = row->blob_list();
1729    BLOBNBOX_IT new_it = blob_it; 
1730    float b, c;                   
1731    tesseract::DetLineFit lms;
1732    int32_t segment; 
1733    box = box_next_pre_chopped(&blob_it);
1734    xstarts[0] = box.left();
1735    blobcount = 1;
1736    while (!blob_it.at_first()) {
1737      blobcount++;
1738      box = box_next_pre_chopped(&blob_it);
1739    }
1740    segments = blobcount / textord_spline_medianwin;
1741    if (segments < 1) {
1742      segments = 1;
1743    }
1744    blobs_per_segment = blobcount / segments;
1745    auto *coeffs = new double[segments * 3];
1746    if (textord_oldbl_debug) {
1747      tprintf(
1748          "Linear splining baseline of %d blobs at (%d,%d), into %d segments of "
1749          "%d blobs\n",
1750          blobcount, box.left(), box.bottom(), segments, blobs_per_segment);
1751    }
1752    segment = 1;
1753    for (index2 = 0; index2 < blobs_per_segment / 2; index2++) {
1754      box_next_pre_chopped(&new_it);
1755    }
1756    index1 = 0;
1757    blobindex = index2;
1758    do {
1759      blobindex += blobs_per_segment;
1760      lms.Clear();
1761      while (index1 < blobindex || (segment == segments && index1 < blobcount)) {
1762        box = box_next_pre_chopped(&blob_it);
1763        int middle = (box.left() + box.right()) / 2;
1764        lms.Add(ICOORD(middle, box.bottom()));
1765        index1++;
1766        if (index1 == blobindex - blobs_per_segment / 2 || index1 == blobcount - 1) {
1767          xstarts[segment] = box.left();
1768        }
1769      }
1770      lms.Fit(&b, &c);
1771      coeffs[segment * 3 - 3] = 0;
1772      coeffs[segment * 3 - 2] = b;
1773      coeffs[segment * 3 - 1] = c;
1774      segment++;
1775      if (segment > segments) {
1776        break;
1777      }
1778      blobindex += blobs_per_segment;
1779      lms.Clear();
1780      while (index2 < blobindex || (segment == segments && index2 < blobcount)) {
1781        new_box = box_next_pre_chopped(&new_it);
1782        int middle = (new_box.left() + new_box.right()) / 2;
1783        lms.Add(ICOORD(middle, new_box.bottom()));
1784        index2++;
1785        if (index2 == blobindex - blobs_per_segment / 2 || index2 == blobcount - 1) {
1786          xstarts[segment] = new_box.left();
1787        }
1788      }
1789      lms.Fit(&b, &c);
1790      coeffs[segment * 3 - 3] = 0;
1791      coeffs[segment * 3 - 2] = b;
1792      coeffs[segment * 3 - 1] = c;
1793      segment++;
1794    } while (segment <= segments);
1795    return coeffs;
1796  }
1797  void assign_blobs_to_rows( 
1798      TO_BLOCK *block,       
1799      float *gradient,       
1800      int pass,              
1801      bool reject_misses,    
1802      bool make_new_rows,    
1803      bool drawing_skew      
1804  ) {
1805    OVERLAP_STATE overlap_result; 
1806    float ycoord;                 
1807    float top, bottom;            
1808    float g_length = 1.0f;        
1809    int16_t row_count;            
1810    int16_t left_x;               
1811    int16_t last_x;               
1812    float block_skew;             
1813    float smooth_factor;          
1814    float near_dist;              
1815    ICOORD testpt;                
1816    BLOBNBOX *blob;               
1817    TO_ROW *row;                  
1818    TO_ROW *dest_row = nullptr;   
1819    BLOBNBOX_IT blob_it = &block->blobs;
1820    TO_ROW_IT row_it = block->get_rows();
1821    ycoord =
1822        (block->block->pdblk.bounding_box().bottom() + block->block->pdblk.bounding_box().top()) /
1823        2.0f;
1824    if (gradient != nullptr) {
1825      g_length = std::sqrt(1 + *gradient * *gradient);
1826    }
1827  #ifndef GRAPHICS_DISABLED
1828    if (drawing_skew) {
1829      to_win->SetCursor(block->block->pdblk.bounding_box().left(), ycoord);
1830    }
1831  #endif
1832    testpt = ICOORD(textord_test_x, textord_test_y);
1833    blob_it.sort(blob_x_order);
1834    smooth_factor = 1.0;
1835    block_skew = 0.0f;
1836    row_count = row_it.length(); 
1837    if (!blob_it.empty()) {
1838      left_x = blob_it.data()->bounding_box().left();
1839    } else {
1840      left_x = block->block->pdblk.bounding_box().left();
1841    }
1842    last_x = left_x;
1843    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1844      blob = blob_it.data();
1845      if (gradient != nullptr) {
1846        block_skew = (1 - 1 / g_length) * blob->bounding_box().bottom() +
1847                     *gradient / g_length * blob->bounding_box().left();
1848      } else if (blob->bounding_box().left() - last_x > block->line_size / 2 &&
1849                 last_x - left_x > block->line_size * 2 && textord_interpolating_skew) {
1850        block_skew *= static_cast<float>(blob->bounding_box().left() - left_x) / (last_x - left_x);
1851      }
1852      last_x = blob->bounding_box().left();
1853      top = blob->bounding_box().top() - block_skew;
1854      bottom = blob->bounding_box().bottom() - block_skew;
1855  #ifndef GRAPHICS_DISABLED
1856      if (drawing_skew) {
1857        to_win->DrawTo(blob->bounding_box().left(), ycoord + block_skew);
1858      }
1859  #endif
1860      if (!row_it.empty()) {
1861        for (row_it.move_to_first(); !row_it.at_last() && row_it.data()->min_y() > top;
1862             row_it.forward()) {
1863        }
1864        row = row_it.data();
1865        if (row->min_y() <= top && row->max_y() >= bottom) {
1866          dest_row = row;
1867          overlap_result = most_overlapping_row(&row_it, dest_row, top, bottom, block->line_size,
1868                                                blob->bounding_box().contains(testpt));
1869          if (overlap_result == NEW_ROW && !reject_misses) {
1870            overlap_result = ASSIGN;
1871          }
1872        } else {
1873          overlap_result = NEW_ROW;
1874          if (!make_new_rows) {
1875            near_dist = row_it.data_relative(-1)->min_y() - top;
1876            if (bottom < row->min_y()) {
1877              if (row->min_y() - bottom <= (block->line_spacing - block->line_size) *
1878                                               tesseract::CCStruct::kDescenderFraction) {
1879                overlap_result = ASSIGN;
1880                dest_row = row;
1881              }
1882            } else if (near_dist > 0 && near_dist < bottom - row->max_y()) {
1883              row_it.backward();
1884              dest_row = row_it.data();
1885              if (dest_row->min_y() - bottom <= (block->line_spacing - block->line_size) *
1886                                                    tesseract::CCStruct::kDescenderFraction) {
1887                overlap_result = ASSIGN;
1888              }
1889            } else {
1890              if (top - row->max_y() <=
1891                  (block->line_spacing - block->line_size) *
1892                      (textord_overlap_x + tesseract::CCStruct::kAscenderFraction)) {
1893                overlap_result = ASSIGN;
1894                dest_row = row;
1895              }
1896            }
1897          }
1898        }
1899        if (overlap_result == ASSIGN) {
1900          dest_row->add_blob(blob_it.extract(), top, bottom, block->line_size);
1901        }
1902        if (overlap_result == NEW_ROW) {
1903          if (make_new_rows && top - bottom < block->max_blob_size) {
1904            dest_row = new TO_ROW(blob_it.extract(), top, bottom, block->line_size);
1905            row_count++;
1906            if (bottom > row_it.data()->min_y()) {
1907              row_it.add_before_then_move(dest_row);
1908            } else {
1909              row_it.add_after_then_move(dest_row);
1910            }
1911            smooth_factor = 1.0 / (row_count * textord_skew_lag + textord_skewsmooth_offset);
1912          } else {
1913            overlap_result = REJECT;
1914          }
1915        }
1916      } else if (make_new_rows && top - bottom < block->max_blob_size) {
1917        overlap_result = NEW_ROW;
1918        dest_row = new TO_ROW(blob_it.extract(), top, bottom, block->line_size);
1919        row_count++;
1920        row_it.add_after_then_move(dest_row);
1921        smooth_factor = 1.0 / (row_count * textord_skew_lag + textord_skewsmooth_offset2);
1922      } else {
1923        overlap_result = REJECT;
1924      }
1925      if (blob->bounding_box().contains(testpt) && textord_debug_blob) {
1926        if (overlap_result != REJECT) {
1927          tprintf("Test blob assigned to row at (%g,%g) on pass %d\n", dest_row->min_y(),
1928                  dest_row->max_y(), pass);
1929        } else {
1930          tprintf("Test blob assigned to no row on pass %d\n", pass);
1931        }
1932      }
1933      if (overlap_result != REJECT) {
1934        while (!row_it.at_first() && row_it.data()->min_y() > row_it.data_relative(-1)->min_y()) {
1935          row = row_it.extract();
1936          row_it.backward();
1937          row_it.add_before_then_move(row);
1938        }
1939        while (!row_it.at_last() && row_it.data()->min_y() < row_it.data_relative(1)->min_y()) {
1940          row = row_it.extract();
1941          row_it.forward();
1942          row_it.add_after_then_move(row);
1943        }
1944        BLOBNBOX_IT added_blob_it(dest_row->blob_list());
1945        added_blob_it.move_to_last();
1946        TBOX prev_box = added_blob_it.data_relative(-1)->bounding_box();
1947        if (dest_row->blob_list()->singleton() || !prev_box.major_x_overlap(blob->bounding_box())) {
1948          block_skew = (1 - smooth_factor) * block_skew +
1949                       smooth_factor * (blob->bounding_box().bottom() - dest_row->initial_min_y());
1950        }
1951      }
1952    }
1953    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
1954      if (row_it.data()->blob_list()->empty()) {
1955        delete row_it.extract(); 
1956      }
1957    }
1958  }
1959  OVERLAP_STATE most_overlapping_row( 
1960      TO_ROW_IT *row_it,              
1961      TO_ROW *&best_row,              
1962      float top,                      
1963      float bottom,                   
1964      float rowsize,                  
1965      bool testing_blob               
1966  ) {
1967    OVERLAP_STATE result;          
1968    float overlap;                 
1969    float bestover;                
1970    float merge_top, merge_bottom; 
1971    ICOORD testpt;                 
1972    TO_ROW *row;                   
1973    TO_ROW *test_row;              
1974    BLOBNBOX_IT blob_it;           
1975    result = ASSIGN;
1976    row = row_it->data();
1977    bestover = top - bottom;
1978    if (top > row->max_y()) {
1979      bestover -= top - row->max_y();
1980    }
1981    if (bottom < row->min_y()) {
1982      bestover -= row->min_y() - bottom;
1983    }
1984    if (testing_blob && textord_debug_blob) {
1985      tprintf("Test blob y=(%g,%g), row=(%f,%f), size=%g, overlap=%f\n", bottom, top, row->min_y(),
1986              row->max_y(), rowsize, bestover);
1987    }
1988    test_row = row;
1989    do {
1990      if (!row_it->at_last()) {
1991        row_it->forward();
1992        test_row = row_it->data();
1993        if (test_row->min_y() <= top && test_row->max_y() >= bottom) {
1994          merge_top = test_row->max_y() > row->max_y() ? test_row->max_y() : row->max_y();
1995          merge_bottom = test_row->min_y() < row->min_y() ? test_row->min_y() : row->min_y();
1996          if (merge_top - merge_bottom <= rowsize) {
1997            if (testing_blob && textord_debug_blob) {
1998              tprintf("Merging rows at (%g,%g), (%g,%g)\n", row->min_y(), row->max_y(),
1999                      test_row->min_y(), test_row->max_y());
2000            }
2001            test_row->set_limits(merge_bottom, merge_top);
2002            blob_it.set_to_list(test_row->blob_list());
2003            blob_it.add_list_after(row->blob_list());
2004            blob_it.sort(blob_x_order);
2005            row_it->backward();
2006            delete row_it->extract();
2007            row_it->forward();
2008            bestover = -1.0f; 
2009          }
2010          overlap = top - bottom;
2011          if (top > test_row->max_y()) {
2012            overlap -= top - test_row->max_y();
2013          }
2014          if (bottom < test_row->min_y()) {
2015            overlap -= test_row->min_y() - bottom;
2016          }
2017          if (bestover >= rowsize - 1 && overlap >= rowsize - 1) {
2018            result = REJECT;
2019          }
2020          if (overlap > bestover) {
2021            bestover = overlap; 
2022            row = test_row;
2023          }
2024          if (testing_blob && textord_debug_blob) {
2025            tprintf("Test blob y=(%g,%g), row=(%f,%f), size=%g, overlap=%f->%f\n", bottom, top,
2026                    test_row->min_y(), test_row->max_y(), rowsize, overlap, bestover);
2027          }
2028        }
2029      }
2030    } while (!row_it->at_last() && test_row->min_y() <= top && test_row->max_y() >= bottom);
2031    while (row_it->data() != row) {
2032      row_it->backward(); 
2033    }
2034    if (top - bottom - bestover > rowsize * textord_overlap_x &&
2035        (!textord_fix_makerow_bug || bestover < rowsize * textord_overlap_x) && result == ASSIGN) {
2036      result = NEW_ROW; 
2037    }
2038    best_row = row;
2039    return result;
2040  }
2041  int blob_x_order(      
2042      const void *item1, 
2043      const void *item2) {
2044    const BLOBNBOX *blob1 = *reinterpret_cast<const BLOBNBOX *const *>(item1);
2045    const BLOBNBOX *blob2 = *reinterpret_cast<const BLOBNBOX *const *>(item2);
2046    if (blob1->bounding_box().left() < blob2->bounding_box().left()) {
2047      return -1;
2048    } else if (blob1->bounding_box().left() > blob2->bounding_box().left()) {
2049      return 1;
2050    } else {
2051      return 0;
2052    }
2053  }
2054  void mark_repeated_chars(TO_ROW *row) {
2055    BLOBNBOX_IT box_it(row->blob_list()); 
2056    int num_repeated_sets = 0;
2057    if (!box_it.empty()) {
2058      do {
2059        BLOBNBOX *bblob = box_it.data();
2060        int repeat_length = 1;
2061        if (bblob->flow() == BTFT_LEADER && !bblob->joined_to_prev() && bblob->cblob() != nullptr) {
2062          BLOBNBOX_IT test_it(box_it);
2063          for (test_it.forward(); !test_it.at_first();) {
2064            bblob = test_it.data();
2065            if (bblob->flow() != BTFT_LEADER) {
2066              break;
2067            }
2068            test_it.forward();
2069            bblob = test_it.data();
2070            if (bblob->joined_to_prev() || bblob->cblob() == nullptr) {
2071              repeat_length = 0;
2072              break;
2073            }
2074            ++repeat_length;
2075          }
2076        }
2077        if (repeat_length >= kMinLeaderCount) {
2078          num_repeated_sets++;
2079          for (; repeat_length > 0; box_it.forward(), --repeat_length) {
2080            bblob = box_it.data();
2081            bblob->set_repeated_set(num_repeated_sets);
2082          }
2083        } else {
2084          bblob->set_repeated_set(0);
2085          box_it.forward();
2086        }
2087      } while (!box_it.at_first()); 
2088    }
2089    row->set_num_repeated_sets(num_repeated_sets);
2090  }
2091  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baseapi.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-makerow.cpp</div>
                </div>
                <div class="column column_space"><pre><code>444    return GetComponentImages(RIL_SYMBOL, true, pixa, nullptr);
445  }
446  Boxa *TessBaseAPI::GetComponentImages(PageIteratorLevel level, bool text_only, bool raw_image,
447                                        const int raw_padding, Pixa **pixa, int **blockids,
</pre></code></div>
                <div class="column column_space"><pre><code>1545    row_it.sort(row_y_order); 
1546  }
1547  void fit_parallel_lms(float gradient, TO_ROW *row) {
1548    float c;       
1549    int blobcount; 
1550    tesseract::DetLineFit lms;
1551    BLOBNBOX_IT blob_it = row->blob_list();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    