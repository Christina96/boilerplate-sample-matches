
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.728538283062645%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-functionListPanel.cpp</h3>
            <pre><code>1  #include "json.hpp"
2  #include "functionListPanel.h"
3  #include "ScintillaEditView.h"
4  #include "localization.h"
5  #include <fstream>
6  using nlohmann::json;
7  using namespace std;
8  #define INDEX_ROOT        0
9  #define INDEX_NODE        1
10  #define INDEX_LEAF        2
11  #define FL_PREFERENCES_INITIALSORT_ID   1
12  FunctionListPanel::~FunctionListPanel()
13  {
14  	for (const auto s : _posStrs)
15  	{
16  		delete s;
17  	}
18  	if (_hFontSearchEdit != nullptr)
19  	{
20  		::DeleteObject(_hFontSearchEdit);
21  		_hFontSearchEdit = nullptr;
22  	}
23  }
24  void FunctionListPanel::addEntry(const TCHAR *nodeName, const TCHAR *displayText, size_t pos)
25  {
26  	HTREEITEM itemParent = NULL;
27  	std::wstring posStr = std::to_wstring(pos);
28  	HTREEITEM root = _treeView.getRoot();
29  	if (nodeName != NULL && *nodeName != '\0')
30  	{
31  		itemParent = _treeView.searchSubItemByName(nodeName, root);
32  		if (!itemParent)
33  		{
34  			generic_string* invalidValueStr = new generic_string(posStr);
35  			_posStrs.push_back(invalidValueStr);
36  			LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
37  			itemParent = _treeView.addItem(nodeName, root, INDEX_NODE, lParamInvalidPosStr);
38  		}
39  	}
40  	else
41  		itemParent = root;
42  	generic_string* posString = new generic_string(posStr);
43  	_posStrs.push_back(posString);
44  	LPARAM lParamPosStr = reinterpret_cast<LPARAM>(posString);
45  	_treeView.addItem(displayText, itemParent, INDEX_LEAF, lParamPosStr);
46  }
47  void FunctionListPanel::removeAllEntries()
48  {
49  	_treeView.removeAllItems();
50  }
51  size_t FunctionListPanel::getBodyClosePos(size_t begin, const TCHAR *bodyOpenSymbol, const TCHAR *bodyCloseSymbol)
52  {
53  	size_t cntOpen = 1;
54  	size_t docLen = (*_ppEditView)->getCurrentDocLen();
55  	if (begin >= docLen)
56  		return docLen;
57  	generic_string exprToSearch = TEXT("(");
58  	exprToSearch += bodyOpenSymbol;
59  	exprToSearch += TEXT("|");
60  	exprToSearch += bodyCloseSymbol;
61  	exprToSearch += TEXT(")");
62  	int flags = SCFIND_REGEXP | SCFIND_POSIX;
63  	(*_ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
64  	intptr_t targetStart = (*_ppEditView)->searchInTarget(exprToSearch.c_str(), exprToSearch.length(), begin, docLen);
65  	intptr_t targetEnd = 0;
66  	do
67  	{
68  		if (targetStart >= 0) 
69  		{
70  			targetEnd = (*_ppEditView)->execute(SCI_GETTARGETEND);
71  			intptr_t tmpStart = (*_ppEditView)->searchInTarget(bodyOpenSymbol, lstrlen(bodyOpenSymbol), targetStart, targetEnd);
72  			if (tmpStart >= 0) 
73  			{
74  				++cntOpen;
75  			}
76  			else 
77  			{
78  				--cntOpen;
79  			}
80  		}
81  		else 
82  		{
83  			cntOpen = 0; 
84  			targetEnd = begin;
85  		}
86  		targetStart = (*_ppEditView)->searchInTarget(exprToSearch.c_str(), exprToSearch.length(), targetEnd, docLen);
87  	} while (cntOpen);
88  	return targetEnd;
89  }
90  generic_string FunctionListPanel::parseSubLevel(size_t begin, size_t end, std::vector< generic_string > dataToSearch, intptr_t& foundPos)
91  {
92  	if (begin >= end)
93  	{
94  		foundPos = -1;
95  		return TEXT("");
96  	}
97  	if (!dataToSearch.size())
98  		return TEXT("");
99  	int flags = SCFIND_REGEXP | SCFIND_POSIX;
100  	(*_ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
101  	const TCHAR *regExpr2search = dataToSearch[0].c_str();
102  	intptr_t targetStart = (*_ppEditView)->searchInTarget(regExpr2search, lstrlen(regExpr2search), begin, end);
103  	if (targetStart < 0)
104  	{
105  		foundPos = -1;
106  		return TEXT("");
107  	}
108  	intptr_t targetEnd = (*_ppEditView)->execute(SCI_GETTARGETEND);
109  	if (dataToSearch.size() >= 2)
110  	{
111  		dataToSearch.erase(dataToSearch.begin());
112  		return parseSubLevel(targetStart, targetEnd, dataToSearch, foundPos);
113  	}
114  	else 
115  	{
116  		TCHAR foundStr[1024]{};
117  		(*_ppEditView)->getGenericText(foundStr, 1024, targetStart, targetEnd);
118  		foundPos = targetStart;
119  		return foundStr;
120  	}
121  }
122  void FunctionListPanel::addInStateArray(TreeStateNode tree2Update, const TCHAR *searchText, bool isSorted)
123  {
124  	bool found = false;
125  	for (size_t i = 0, len = _treeParams.size(); i < len; ++i)
126  	{
127  		if (_treeParams[i]._treeState._extraData == tree2Update._extraData)
128  		{
129  			_treeParams[i]._searchParameters._text2Find = searchText;
130  			_treeParams[i]._searchParameters._doSort = isSorted;
131  			_treeParams[i]._treeState = tree2Update;
132  			found = true;
133  		}
134  	}
135  	if (!found)
136  	{
137  		TreeParams params;
138  		params._treeState = tree2Update;
139  		params._searchParameters._text2Find = searchText;
140  		params._searchParameters._doSort = isSorted;
141  		_treeParams.push_back(params);
142  	}
143  }
144  TreeParams* FunctionListPanel::getFromStateArray(generic_string fullFilePath)
145  {
146  	for (size_t i = 0, len = _treeParams.size(); i < len; ++i)
147  	{
148  		if (_treeParams[i]._treeState._extraData == fullFilePath)
149  			return &_treeParams[i];
150  	}
151  	return NULL;
152  }
153  void FunctionListPanel::sortOrUnsort()
154  {
155  	bool doSort = shouldSort();
156  	if (doSort)
157  		_pTreeView->sort(_pTreeView->getRoot(), true);
158  	else
159  	{
160  		TCHAR text2search[MAX_PATH] = { '\0' };
161  		::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2search));
162  		if (text2search[0] == '\0') 
163  		{
164  			_pTreeView->customSorting(_pTreeView->getRoot(), categorySortFunc, 0, true);
165  		}
166  		else 
167  		{
168  			reload();
169  			if (_treeView.getRoot() == NULL)
170  				return;
171  			_treeViewSearchResult.removeAllItems();
172  			const TCHAR *fn = ((*_ppEditView)->getCurrentBuffer())->getFileName();
173  			generic_string* invalidValueStr = new generic_string(TEXT("-1"));
174  			_posStrs.push_back(invalidValueStr);
175  			LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
176  			_treeViewSearchResult.addItem(fn, NULL, INDEX_ROOT, lParamInvalidPosStr);
177  			_treeView.searchLeafAndBuildTree(_treeViewSearchResult, text2search, INDEX_LEAF);
178  			_treeViewSearchResult.display(true);
179  			_treeViewSearchResult.expand(_treeViewSearchResult.getRoot());
180  			_treeView.display(false);
181  			_pTreeView = &_treeViewSearchResult;
182  		}
183  	}
184  }
185  int CALLBACK FunctionListPanel::categorySortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM &bsol;*lParamSort*/)
186  {
187  	generic_string* posString1 = reinterpret_cast<generic_string*>(lParam1);
<span onclick='openModal()' class='match'>188  	generic_string* posString2 = reinterpret_cast<generic_string*>(lParam2);
189  	size_t pos1 = _wtoi(posString1->c_str());
190  	size_t pos2 = _wtoi(posString2->c_str());
</span>191  	if (pos1 > pos2)
192  		return 1;
193  	else 
194  		return -1;
195  }
196  bool FunctionListPanel::serialize(const generic_string & outputFilename)
197  {
198  	Buffer* currentBuf = (*_ppEditView)->getCurrentBuffer();
199  	const TCHAR* fileNameLabel = currentBuf->getFileName();
200  	generic_string fname2write;
201  	if (outputFilename.empty()) 
202  	{
203  		const TCHAR *fullFilePath = currentBuf->getFullPathName();
204  		bool exportFuncntionList = (NppParameters::getInstance()).doFunctionListExport();
205  		if (exportFuncntionList && ::PathFileExists(fullFilePath))
206  		{
207  			fname2write = fullFilePath;
208  			fname2write += TEXT(".result");
209  			fname2write += TEXT(".json");
210  		}
211  		else
212  			return false;
213  	}
214  	else
215  	{
216  		fname2write = outputFilename;
217  	}
218  	const char* rootLabel = "root";
219  	const char* nodesLabel = "nodes";
220  	const char* leavesLabel = "leaves";
221  	const char* nameLabel = "name";
222  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
223  	json j;
224  	j[rootLabel] = wmc.wchar2char(fileNameLabel, CP_ACP);
225  	for (const auto & info : _foundFuncInfos)
226  	{
227  		std::string leafName = wmc.wchar2char(info._data.c_str(), CP_ACP);
228  		if (!info._data2.empty()) 
229  		{
230  			bool isFound = false;
231  			std::string nodeName = wmc.wchar2char(info._data2.c_str(), CP_ACP);
232  			for (auto & i : j[nodesLabel])
233  			{
234  				if (nodeName == std::string{ i[nameLabel] })
235  				{
236  					i[leavesLabel].push_back(leafName.c_str());
237  					isFound = true;
238  					break;
239  				}
240  			}
241  			if (!isFound)
242  			{
243  				json aNode = { { leavesLabel, json::array() },{ nameLabel, nodeName.c_str() } };
244  				aNode[leavesLabel].push_back(leafName.c_str());
245  				j[nodesLabel].push_back(aNode);
246  			}
247  		}
248  		else 
249  		{
250  			j[leavesLabel].push_back(leafName.c_str());
251  		}
252  	}
253  	std::ofstream file(wmc.wchar2char(fname2write.c_str(), CP_ACP));
254  	file << j;
255  	return true;
256  }
257  void FunctionListPanel::reload()
258  {
259  	bool isScrollBarOn = GetWindowLongPtr(_treeView.getHSelf(), GWL_STYLE) & WS_VSCROLL;
260  	if (isScrollBarOn)
261  	{
262  		GetScrollInfo(_treeView.getHSelf(), SB_VERT, &si);
263  	}
264  	_findLine = -1;
265  	_findEndLine = -1;
266  	TreeStateNode currentTree;
267  	bool isOK = _treeView.retrieveFoldingStateTo(currentTree, _treeView.getRoot());
268  	if (isOK)
269  	{
270  		TCHAR text2Search[MAX_PATH] = { '\0' };
271  		::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2Search));
272  		bool isSorted =  shouldSort();
273  		addInStateArray(currentTree, text2Search, isSorted);
274  	}
275  	removeAllEntries();
276  	::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
277  	setSort(false);
278  	_foundFuncInfos.clear();
279  	Buffer* currentBuf = (*_ppEditView)->getCurrentBuffer();
280  	const TCHAR *fn = currentBuf->getFileName();
281  	LangType langID = currentBuf->getLangType();
282  	if (langID == L_JS)
283  		langID = L_JAVASCRIPT;
284  	const TCHAR *udln = NULL;
285  	if (langID == L_USER)
286  	{
287  		udln = currentBuf->getUserDefineLangName();
288  	}
289  	TCHAR *ext = ::PathFindExtension(fn);
290  	bool parsedOK = _funcParserMgr.parse(_foundFuncInfos, AssociationInfo(-1, langID, ext, udln));
291  	if (parsedOK)
292  	{
293  		generic_string* invalidValueStr = new generic_string(TEXT("-1"));
294  		_posStrs.push_back(invalidValueStr);
295  		LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
296  		_treeView.addItem(fn, NULL, INDEX_ROOT, lParamInvalidPosStr);
297  	}
298  	for (size_t i = 0, len = _foundFuncInfos.size(); i < len; ++i)
299  	{
300  		addEntry(_foundFuncInfos[i]._data2.c_str(), _foundFuncInfos[i]._data.c_str(), _foundFuncInfos[i]._pos);
301  	}
302  	HTREEITEM root = _treeView.getRoot();
303  	if (root)
304  	{
305  		currentBuf = (*_ppEditView)->getCurrentBuffer();
306  		const TCHAR *fullFilePath = currentBuf->getFullPathName();
307  		generic_string* fullPathStr = new generic_string(fullFilePath);
308  		_posStrs.push_back(fullPathStr);
309  		LPARAM lParamFullPathStr = reinterpret_cast<LPARAM>(fullPathStr);
310  		_treeView.setItemParam(root, lParamFullPathStr);
311  		TreeParams *previousParams = getFromStateArray(fullFilePath);
312  		if (!previousParams)
313  		{
314  			::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
315  			setSort(NppParameters::getInstance().getNppGUI()._shouldSortFunctionList);
316  			sortOrUnsort();
317  			_treeView.expand(root);
318  		}
319  		else
320  		{
321  			::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>((previousParams->_searchParameters)._text2Find.c_str()));
322  			bool isSort = (previousParams->_searchParameters)._doSort;
323  			setSort(isSort);
324  			if (isSort)
325  				_pTreeView->sort(_pTreeView->getRoot(), true);
326  			_treeView.restoreFoldingStateFrom(previousParams->_treeState, root);
327  		}
328  	}
329  	::InvalidateRect(_hSearchEdit, NULL, TRUE);
330  	if (isScrollBarOn)
331  	{
332  		SetScrollInfo(_treeView.getHSelf(), SB_VERT, &si, TRUE);
333  	}
334  }
335  void FunctionListPanel::initPreferencesMenu()
336  {
337  	NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
338  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
339  	generic_string shouldSortFunctionListStr = pNativeSpeaker->getAttrNameStr(TEXT("Sort functions (A to Z) by default"), FL_FUCTIONLISTROOTNODE, FL_PREFERENCE_INITIALSORT);
340  	_hPreferencesMenu = ::CreatePopupMenu();
341  	::InsertMenu(_hPreferencesMenu, 0, MF_BYCOMMAND, FL_PREFERENCES_INITIALSORT_ID, shouldSortFunctionListStr.c_str());
342  	::CheckMenuItem(_hPreferencesMenu, FL_PREFERENCES_INITIALSORT_ID, MF_BYCOMMAND | (nppGUI._shouldSortFunctionList ? MF_CHECKED : MF_UNCHECKED));
343  }
344  void FunctionListPanel::showPreferencesMenu()
345  {
346  	RECT rectToolbar{};
347  	RECT rectPreferencesButton{};
348  	::GetWindowRect(_hToolbarMenu, &rectToolbar);
349  	::SendMessage(_hToolbarMenu, TB_GETRECT, IDC_PREFERENCEBUTTON_FUNCLIST, (LPARAM)&rectPreferencesButton);
350  	::TrackPopupMenu(_hPreferencesMenu,
351  		NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
352  		rectToolbar.left + rectPreferencesButton.left,
353  		rectToolbar.top + rectPreferencesButton.bottom,
354  		0, _hSelf, NULL);
355  }
356  void FunctionListPanel::markEntry()
357  {
358  	LONG lineNr = static_cast<LONG>((*_ppEditView)->getCurrentLineNumber());
359  	HTREEITEM root = _treeView.getRoot();
360  	if (_findLine != -1 && _findEndLine != -1 && lineNr >= _findLine && lineNr < _findEndLine)
361  		return;
362  	_findLine = -1;
363  	_findEndLine = -1;
364  	findMarkEntry(root, lineNr);
365  	if (_findLine != -1)
366  	{
367  		_treeView.selectItem(_findItem);
368  	}
369  	else
370  	{
371  		_treeView.selectItem(root);
372  	}
373  }
374  void FunctionListPanel::findMarkEntry(HTREEITEM htItem, LONG line)
375  {
376  	HTREEITEM cItem{};
377  	TVITEM tvItem{};
378  	for (; htItem != NULL; htItem = _treeView.getNextSibling(htItem))
379  	{
380  		cItem = _treeView.getChildFrom(htItem);
381  		if (cItem != NULL)
382  		{
383  			findMarkEntry(cItem, line);
384  		}
385  		else
386  		{
387  			tvItem.hItem = htItem;
388  			tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
389  			::SendMessage(_treeViewSearchResult.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
390  			generic_string *posStr = reinterpret_cast<generic_string *>(tvItem.lParam);
391  			if (posStr)
392  			{
393  				int pos = _wtoi(posStr->c_str());
394  				if (pos != -1)
395  				{
396  					LONG sci_line = static_cast<LONG>((*_ppEditView)->execute(SCI_LINEFROMPOSITION, pos));
397  					if (line >= sci_line)
398  					{
399  						if (sci_line > _findLine || _findLine == -1)
400  						{
401  							_findLine = sci_line;
402  							_findItem = htItem;
403  						}
404  					}
405  					else
406  					{
407  						if (sci_line < _findEndLine)
408  							_findEndLine = sci_line;
409  					}
410  				}
411  			}
412  		}
413  	}
414  }
415  void FunctionListPanel::init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView)
416  {
417  	DockingDlgInterface::init(hInst, hPere);
418  	_ppEditView = ppEditView;
419  	NppParameters& nppParams = NppParameters::getInstance();
420  	generic_string funcListXmlPath = nppParams.getUserPath();
421  	pathAppend(funcListXmlPath, TEXT("functionList"));
422  	generic_string funcListDefaultXmlPath = nppParams.getNppPath();
423  	pathAppend(funcListDefaultXmlPath, TEXT("functionList"));
424  	bool doLocalConf = nppParams.isLocal();
425  	if (!doLocalConf)
426  	{
427  		if (!PathFileExists(funcListXmlPath.c_str()))
428  		{
429  			if (PathFileExists(funcListDefaultXmlPath.c_str()))
430  			{
431  				::CopyFile(funcListDefaultXmlPath.c_str(), funcListXmlPath.c_str(), TRUE);
432  				_funcParserMgr.init(funcListXmlPath, funcListDefaultXmlPath, ppEditView);
433  			}
434  		}
435  		else
436  		{
437  			_funcParserMgr.init(funcListXmlPath, funcListDefaultXmlPath, ppEditView);
438  		}
439  	}
440  	else
441  	{
442  		generic_string funcListDefaultXmlPath = nppParams.getNppPath();
443  		pathAppend(funcListDefaultXmlPath, TEXT("functionList"));
444  		if (PathFileExists(funcListDefaultXmlPath.c_str()))
445  		{
446  			_funcParserMgr.init(funcListDefaultXmlPath, funcListDefaultXmlPath, ppEditView);
447  		}
448  	}
449  	ZeroMemory(&si, sizeof(si));
450  	si.cbSize = sizeof(si);
451  	si.fMask = SIF_POS;
452  }
453  bool FunctionListPanel::openSelection(const TreeView & treeView)
454  {
455  	TVITEM tvItem{};
456  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
457  	tvItem.hItem = treeView.getSelection();
458  	::SendMessage(treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
459  	if (tvItem.iImage == INDEX_ROOT || tvItem.iImage == INDEX_NODE)
460  	{
461  		return false;
462  	}
463  	generic_string *posStr = reinterpret_cast<generic_string *>(tvItem.lParam);
464  	if (!posStr)
465  		return false;
466  	int pos = _wtoi(posStr->c_str());
467  	if (pos == -1)
468  		return false;
469  	auto sci_line = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, pos);
470  	(*_ppEditView)->execute(SCI_ENSUREVISIBLE, sci_line);
471  	(*_ppEditView)->scrollPosToCenter(pos);
472  	return true;
473  }
474  void FunctionListPanel::notified(LPNMHDR notification)
475  {
476  	if (notification->code == TTN_GETDISPINFO)
477  	{
478  		LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)notification;
479  		lpttt->hinst = NULL;
480  		if (notification->idFrom == IDC_SORTBUTTON_FUNCLIST)
481  		{
482  			wcscpy_s(lpttt->szText, _sortTipStr.c_str());
483  		}
484  		else if (notification->idFrom == IDC_RELOADBUTTON_FUNCLIST)
485  		{
486  			wcscpy_s(lpttt->szText, _reloadTipStr.c_str());
487  		}
488  		else if (notification->idFrom == IDC_PREFERENCEBUTTON_FUNCLIST)
489  		{
490  			wcscpy_s(lpttt->szText, _preferenceTipStr.c_str());
491  		}
492  	}
493  	else if (notification->hwndFrom == _treeView.getHSelf() || notification->hwndFrom == _treeViewSearchResult.getHSelf())
494  	{
495  		const TreeView & treeView = notification->hwndFrom == _treeView.getHSelf()?_treeView:_treeViewSearchResult;
496  		switch (notification->code)
497  		{
498  			case NM_DBLCLK:
499  			{
500  				openSelection(treeView);
501  				PostMessage(_hParent, WM_COMMAND, SCEN_SETFOCUS << 16, reinterpret_cast<LPARAM>((*_ppEditView)->getHSelf()));
502  			}
503  			break;
504  			case NM_RETURN:
505  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1); 
506  			break;
507  			case TVN_KEYDOWN:
508  			{
509  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
510  				if (ptvkd->wVKey == VK_RETURN)
511  				{
512  					if (!openSelection(treeView))
513  					{
514  						HTREEITEM hItem = treeView.getSelection();
515  						treeView.toggleExpandCollapse(hItem);
516  						break;
517  					}
518  					PostMessage(_hParent, WM_COMMAND, SCEN_SETFOCUS << 16, reinterpret_cast<LPARAM>((*_ppEditView)->getHSelf()));
519  				}
520  				else if (ptvkd->wVKey == VK_TAB)
521  				{
522  					::SetFocus(_hSearchEdit);
523  					SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1); 
524  				}
525  				else if (ptvkd->wVKey == VK_ESCAPE)
526  				{
527  					::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
528  					SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1); 
529  					PostMessage(_hParent, WM_COMMAND, SCEN_SETFOCUS << 16, reinterpret_cast<LPARAM>((*_ppEditView)->getHSelf()));
530  				}
531  			}
532  			break;
533  		}
534  	}
535  	else if (notification->code == DMN_SWITCHIN)
536  	{
537  		reload();
538  	}
539  	else if (notification->code == DMN_CLOSE)
540  	{
541  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FUNC_LIST, 0);
542  	}
543  }
544  void FunctionListPanel::searchFuncAndSwitchView()
545  {
546  	TCHAR text2search[MAX_PATH] = { '\0' };
547  	::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2search));
548  	if (text2search[0] == '\0')
549  	{
550  		_treeViewSearchResult.display(false);
551  		_treeView.display(true);
552  		_pTreeView = &_treeView;
553  	}
554  	else
555  	{
556  		if (_treeView.getRoot() == NULL)
557  			return;
558  		_treeViewSearchResult.removeAllItems();
559  		const TCHAR *fn = ((*_ppEditView)->getCurrentBuffer())->getFileName();
560  		generic_string* invalidValueStr = new generic_string(TEXT("-1"));
561  		_posStrs.push_back(invalidValueStr);
562  		LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
563  		_treeViewSearchResult.addItem(fn, NULL, INDEX_ROOT, lParamInvalidPosStr);
564  		_treeView.searchLeafAndBuildTree(_treeViewSearchResult, text2search, INDEX_LEAF);
565  		_treeViewSearchResult.display(true);
566  		_treeViewSearchResult.expand(_treeViewSearchResult.getRoot());
567  		_treeView.display(false);
568  		_pTreeView = &_treeViewSearchResult;
569  		::InvalidateRect(_hSearchEdit, NULL, TRUE);
570  	}
571  	if (shouldSort())
572  		_pTreeView->sort(_pTreeView->getRoot(), true);
573  	else
574  		_pTreeView->customSorting(_pTreeView->getRoot(), categorySortFunc, 0, true);
575  }
576  static WNDPROC oldFunclstToolbarProc = NULL;
577  static LRESULT CALLBACK funclstToolbarProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
578  {
579  	switch (message)
580  	{
581  		case WM_CTLCOLOREDIT :
582  		{
583  			return ::SendMessage(::GetParent(hwnd), WM_CTLCOLOREDIT, wParam, lParam);
584  		}
585  	}
586  	return oldFunclstToolbarProc(hwnd, message, wParam, lParam);
587  }
588  static WNDPROC oldFunclstSearchEditProc = NULL;
589  static LRESULT CALLBACK funclstSearchEditProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
590  {
591  	switch (message)
592  	{
593  		case WM_CHAR:
594  		{
595  			if (wParam == VK_ESCAPE)
596  			{
597  				::SendMessage(hwnd, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
598  				return FALSE;
599  			}
600  			else if (wParam == VK_TAB)
601  			{
602  				::SendMessage(GetParent(hwnd), WM_COMMAND, VK_TAB, 1);
603  				return FALSE;
604  			}
605  		}
606  	}
607  	return oldFunclstSearchEditProc(hwnd, message, wParam, lParam);
608  }
609  bool FunctionListPanel::shouldSort()
610  {
611  	TBBUTTONINFO tbbuttonInfo{};
612  	tbbuttonInfo.cbSize = sizeof(TBBUTTONINFO);
613  	tbbuttonInfo.dwMask = TBIF_STATE;
614  	::SendMessage(_hToolbarMenu, TB_GETBUTTONINFO, IDC_SORTBUTTON_FUNCLIST, reinterpret_cast<LPARAM>(&tbbuttonInfo));
615  	return (tbbuttonInfo.fsState & TBSTATE_CHECKED) != 0;
616  }
617  void FunctionListPanel::setSort(bool isEnabled)
618  {
619  	TBBUTTONINFO tbbuttonInfo{};
620  	tbbuttonInfo.cbSize = sizeof(TBBUTTONINFO);
621  	tbbuttonInfo.dwMask = TBIF_STATE;
622  	tbbuttonInfo.fsState = isEnabled ? TBSTATE_ENABLED | TBSTATE_CHECKED : TBSTATE_ENABLED;
623  	::SendMessage(_hToolbarMenu, TB_SETBUTTONINFO, IDC_SORTBUTTON_FUNCLIST, reinterpret_cast<LPARAM>(&tbbuttonInfo));
624  }
625  intptr_t CALLBACK FunctionListPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
626  {
627  	switch (message)
628  	{
629  		case WM_CTLCOLOREDIT :
630  		{
631  			TCHAR text2search[MAX_PATH] = { '\0' };
632  			::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2search));
633  			bool textFound = false;
634  			if (text2search[0] == '\0')
635  			{
636  				textFound = true; 
637  			}
638  			if (!textFound)
639  			{
640  				HTREEITEM searchViewRoot = _treeViewSearchResult.getRoot();
641  				if (searchViewRoot)
642  				{
643  					if (_treeViewSearchResult.getChildFrom(searchViewRoot))
644  					{
645  						textFound = true; 
646  					}
647  				}
648  				else
649  				{
650  					textFound = true; 
651  				}
652  			}
653  			auto hdc = reinterpret_cast<HDC>(wParam);
654  			if (NppDarkMode::isEnabled())
655  			{
656  				if (textFound)
657  				{
658  					return NppDarkMode::onCtlColorSofter(hdc);
659  				}
660  				else 
661  				{
662  					return NppDarkMode::onCtlColorError(hdc);
663  				}
664  			}
665  			if (textFound)
666  			{
667  				return FALSE;
668  			}
669  			static HBRUSH hBrushBackground = CreateSolidBrush(BCKGRD_COLOR);
670  			SetTextColor(hdc, TXT_COLOR);
671  			SetBkColor(hdc, BCKGRD_COLOR);
672  			return reinterpret_cast<LRESULT>(hBrushBackground);
673  		}
674  		case WM_INITDIALOG :
675  		{
676  			FunctionListPanel::initPreferencesMenu();
677  			NppParameters& nppParams = NppParameters::getInstance();
678  			int editWidth = nppParams._dpiManager.scaleX(100);
679  			int editWidthSep = nppParams._dpiManager.scaleX(105); 
680  			int editHeight = nppParams._dpiManager.scaleY(20);
681  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_TRANSPARENT | BTNS_AUTOSIZE | BTNS_SEP | TBSTYLE_TOOLTIPS;
682  			_hToolbarMenu = CreateWindowEx(0,TOOLBARCLASSNAME,NULL, style,
683  								0,0,0,0,_hSelf,nullptr, _hInst, NULL);
684  			oldFunclstToolbarProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hToolbarMenu, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(funclstToolbarProc)));
685  			int iconSizeDyn = nppParams._dpiManager.scaleX(16);
686  			::SendMessage(_hToolbarMenu, TB_SETBITMAPSIZE, 0, MAKELPARAM(iconSizeDyn, iconSizeDyn));
687  			TBADDBITMAP addbmp = { 0, 0 };
688  			const int nbIcons = 3;
689  			int iconIDs[nbIcons] = { IDI_FUNCLIST_SORTBUTTON, IDI_FUNCLIST_RELOADBUTTON, IDI_FUNCLIST_PREFERENCEBUTTON };
690  			int iconDarkModeIDs[nbIcons] = { IDI_FUNCLIST_SORTBUTTON_DM, IDI_FUNCLIST_RELOADBUTTON_DM, IDI_FUNCLIST_PREFERENCEBUTTON_DM };
691  			for (size_t i = 0; i < nbIcons; ++i)
692  			{
693  				int icoID = NppDarkMode::isEnabled() ? iconDarkModeIDs[i] : iconIDs[i];
694  				HBITMAP hBmp = static_cast<HBITMAP>(::LoadImage(_hInst, MAKEINTRESOURCE(icoID), IMAGE_BITMAP, iconSizeDyn, iconSizeDyn, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT));
695  				addbmp.nID = reinterpret_cast<UINT_PTR>(hBmp);
696  				::SendMessage(_hToolbarMenu, TB_ADDBITMAP, 1, reinterpret_cast<LPARAM>(&addbmp));
697  			}
698  			TBBUTTON tbButtons[1 + nbIcons]{};
699  			tbButtons[0].idCommand = 0;
700  			tbButtons[0].iBitmap = editWidthSep;
701  			tbButtons[0].fsState = TBSTATE_ENABLED;
702  			tbButtons[0].fsStyle = BTNS_SEP; 
703  			tbButtons[0].iString = 0;
704  			tbButtons[1].idCommand = IDC_SORTBUTTON_FUNCLIST;
705  			tbButtons[1].iBitmap = 0;
706  			tbButtons[1].fsState = TBSTATE_ENABLED;
707  			tbButtons[1].fsStyle = BTNS_CHECK | BTNS_AUTOSIZE;
708  			tbButtons[1].iString = reinterpret_cast<intptr_t>(TEXT(""));
709  			tbButtons[2].idCommand = IDC_RELOADBUTTON_FUNCLIST;
710  			tbButtons[2].iBitmap = 1;
711  			tbButtons[2].fsState = TBSTATE_ENABLED;
712  			tbButtons[2].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
713  			tbButtons[2].iString = reinterpret_cast<intptr_t>(TEXT(""));
714  			tbButtons[3].idCommand = IDC_PREFERENCEBUTTON_FUNCLIST;
715  			tbButtons[3].iBitmap = 2;
716  			tbButtons[3].fsState = TBSTATE_ENABLED;
717  			tbButtons[3].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
718  			tbButtons[3].iString = reinterpret_cast<intptr_t>(TEXT(""));
719  			::SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
720  			::SendMessage(_hToolbarMenu, TB_SETBUTTONSIZE, 0, MAKELONG(nppParams._dpiManager.scaleX(16), nppParams._dpiManager.scaleY(16)));
721  			::SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
722  			::SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0);
723  			ShowWindow(_hToolbarMenu, SW_SHOW);
724  			NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
725  			_sortTipStr = pNativeSpeaker->getAttrNameStr(_sortTipStr.c_str(), FL_FUCTIONLISTROOTNODE, FL_SORTLOCALNODENAME);
726  			_reloadTipStr = pNativeSpeaker->getAttrNameStr(_reloadTipStr.c_str(), FL_FUCTIONLISTROOTNODE, FL_RELOADLOCALNODENAME);
727  			_preferenceTipStr = pNativeSpeaker->getAttrNameStr(_preferenceTipStr.c_str(), FL_FUCTIONLISTROOTNODE, FL_PREFERENCESLOCALNODENAME);
728  			_hSearchEdit = CreateWindowEx(WS_EX_CLIENTEDGE, L"Edit", NULL,
729  								WS_CHILD | WS_VISIBLE | ES_AUTOVSCROLL,
730  								2, 2, editWidth, editHeight,
731  								_hToolbarMenu, reinterpret_cast<HMENU>(IDC_SEARCHFIELD_FUNCLIST), _hInst, 0 );
732  			oldFunclstSearchEditProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSearchEdit, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(funclstSearchEditProc)));
733  			if (_hFontSearchEdit == nullptr)
734  			{
735  				LOGFONT lf{ NppParameters::getDefaultGUIFont() };
736  				_hFontSearchEdit = ::CreateFontIndirect(&lf);
737  			}
738  			if (_hFontSearchEdit != nullptr)
739  			{
740  				::SendMessage(_hSearchEdit, WM_SETFONT, reinterpret_cast<WPARAM>(_hFontSearchEdit), MAKELPARAM(TRUE, 0));
741  			}
742  			_treeView.init(_hInst, _hSelf, IDC_LIST_FUNCLIST);
743  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 3, IDI_FUNCLIST_ROOT, IDI_FUNCLIST_NODE, IDI_FUNCLIST_LEAF);
744  			_treeViewSearchResult.init(_hInst, _hSelf, IDC_LIST_FUNCLIST_AUX);
745  			_treeViewSearchResult.setImageList(CX_BITMAP, 3, CY_BITMAP, IDI_FUNCLIST_ROOT, IDI_FUNCLIST_NODE, IDI_FUNCLIST_LEAF);
746  			_treeView.makeLabelEditable(false);
747  			_treeView.display();
748  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
749  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
750  			return TRUE;
751  		}
752  		case NPPM_INTERNAL_REFRESHDARKMODE:
753  		{
754  			if (static_cast<BOOL>(lParam) != TRUE)
755  			{
756  				NppDarkMode::autoThemeChildControls(_hSelf);
757  			}
758  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
759  			return TRUE;
760  		}
761  		case WM_DESTROY:
762  			_treeView.destroy();
763  			_treeViewSearchResult.destroy();
764  			::DestroyMenu(_hPreferencesMenu);
765  			::DestroyWindow(_hToolbarMenu);
766  			break;
767  		case WM_COMMAND :
768  		{
769  			if (HIWORD(wParam) == EN_CHANGE)
770  			{
771  				switch (LOWORD(wParam))
772  				{
773  					case  IDC_SEARCHFIELD_FUNCLIST:
774  					{
775  						searchFuncAndSwitchView();
776  						return TRUE;
777  					}
778  				}
779  			}
780  			else if (wParam == VK_TAB)
781  			{
782  				if (_treeViewSearchResult.isVisible())
783  					::SetFocus(_treeViewSearchResult.getHSelf());
784  				else
785  					::SetFocus(_treeView.getHSelf());
786  				return TRUE;
787  			}
788  			switch (LOWORD(wParam))
789  			{
790  				case IDC_SORTBUTTON_FUNCLIST:
791  				{
792  					sortOrUnsort();
793  				}
794  				return TRUE;
795  				case IDC_RELOADBUTTON_FUNCLIST:
796  				{
797  					reload();
798  				}
799  				return TRUE;
800  				case IDC_PREFERENCEBUTTON_FUNCLIST:
801  				{
802  					showPreferencesMenu();
803  				}
804  				return TRUE;
805  				case FL_PREFERENCES_INITIALSORT_ID:
806  				{
807  					bool& shouldSortFunctionList = NppParameters::getInstance().getNppGUI()._shouldSortFunctionList;
808  					shouldSortFunctionList = !shouldSortFunctionList;
809  					::CheckMenuItem(_hPreferencesMenu, FL_PREFERENCES_INITIALSORT_ID, MF_BYCOMMAND | (shouldSortFunctionList ? MF_CHECKED : MF_UNCHECKED));
810  				}
811  				return TRUE;
812  			}
813  		}
814  		break;
815  		case WM_NOTIFY:
816  		{
817  			notified((LPNMHDR)lParam);
818  		}
819  		return TRUE;
820  		case WM_SIZE:
821  		{
822  			int width = LOWORD(lParam);
823  			int height = HIWORD(lParam);
824  			int extraValue = NppParameters::getInstance()._dpiManager.scaleX(4);
825  			RECT toolbarMenuRect;
826  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
827  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
828  			HWND hwnd = _treeView.getHSelf();
829  			if (hwnd)
830  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + extraValue, width, height - toolbarMenuRect.bottom - extraValue, TRUE);
831  			HWND hwnd_aux = _treeViewSearchResult.getHSelf();
832  			if (hwnd_aux)
833  				::MoveWindow(hwnd_aux, 0, toolbarMenuRect.bottom + extraValue, width, height - toolbarMenuRect.bottom - extraValue, TRUE);
834  			break;
835  		}
836  		default :
837  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
838  	}
839  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
840  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-columnEditor.cpp</h3>
            <pre><code>1  #include "columnEditor.h"
2  #include "ScintillaEditView.h"
3  void ColumnEditorDlg::init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView)
4  {
5  	Window::init(hInst, hPere);
6  	if (!ppEditView)
7  		throw std::runtime_error("StaticDialog::init : ppEditView is null.");
8  	_ppEditView = ppEditView;
9  }
10  void ColumnEditorDlg::display(bool toShow) const
11  {
12      Window::display(toShow);
13      if (toShow)
14          ::SetFocus(::GetDlgItem(_hSelf, ID_GOLINE_EDIT));
15  }
16  intptr_t CALLBACK ColumnEditorDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
17  {
18  	switch (message)
19  	{
20  		case WM_INITDIALOG :
21  		{
22  			ColumnEditorParam colEditParam = NppParameters::getInstance()._columnEditParam;
23  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
24  			::SetDlgItemText(_hSelf, IDC_COL_TEXT_EDIT, colEditParam._insertedTextContent.c_str());
25  			if (colEditParam._initialNum != -1)
26  				::SetDlgItemInt(_hSelf, IDC_COL_INITNUM_EDIT, colEditParam._initialNum, FALSE);
27  			if (colEditParam._increaseNum != -1)
28  				::SetDlgItemInt(_hSelf, IDC_COL_INCREASENUM_EDIT, colEditParam._increaseNum, FALSE);
29  			if (colEditParam._repeatNum != -1)
30  				::SetDlgItemInt(_hSelf, IDC_COL_REPEATNUM_EDIT, colEditParam._repeatNum, FALSE);
31  			::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("None")));
32  			::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Zeros")));
33  			::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Spaces")));
34  			WPARAM curSel = 0;
35  			switch (colEditParam._leadingChoice)
36  			{
37  				case ColumnEditorParam::noneLeading: { curSel = 0; break; }
38  				case ColumnEditorParam::zeroLeading : { curSel = 1; break; }
39  				case ColumnEditorParam::spaceLeading : { curSel = 2; break; }
40  				default : { curSel = 0; break; }
41  			}
42  			::SendMessage(::GetDlgItem(_hSelf, IDC_COL_LEADING_COMBO), CB_SETCURSEL, curSel, 0);
43  			int format = IDC_COL_DEC_RADIO;
44  			if (colEditParam._formatChoice == 1)
45  				format = IDC_COL_HEX_RADIO;
46  			else if (colEditParam._formatChoice == 2)
47  				format = IDC_COL_OCT_RADIO;
48  			else if (colEditParam._formatChoice == 3)
49  				format = IDC_COL_BIN_RADIO;
50  			::SendDlgItemMessage(_hSelf, format, BM_SETCHECK,  TRUE, 0);
51  			switchTo(colEditParam._mainChoice);
52  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
53  			return TRUE;
54  		}
55  		case WM_CTLCOLOREDIT:
56  		{
57  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
58  		}
59  		case WM_CTLCOLORLISTBOX:
60  		{
61  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
62  		}
63  		case WM_CTLCOLORDLG:
64  		{
65  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
66  		}
67  		case WM_CTLCOLORSTATIC:
68  		{
<span onclick='openModal()' class='match'>69  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
70  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
</span>71  			bool isStaticText = (dlgCtrlID == IDC_COL_INITNUM_STATIC ||
72  				dlgCtrlID == IDC_COL_INCRNUM_STATIC ||
73  				dlgCtrlID == IDC_COL_REPEATNUM_STATIC ||
74  				dlgCtrlID == IDC_COL_LEADING_STATIC);
75  			if (isStaticText)
76  			{
77  				bool isTextEnabled = isCheckedOrNot(IDC_COL_NUM_RADIO);
78  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
79  			}
80  			return NppDarkMode::onCtlColorDarker(hdcStatic);
81  		}
82  		case WM_PRINTCLIENT:
83  		{
84  			if (NppDarkMode::isEnabled())
85  			{
86  				return TRUE;
87  			}
88  			break;
89  		}
90  		case WM_ERASEBKGND:
91  		{
92  			if (NppDarkMode::isEnabled())
93  			{
94  				RECT rc{};
95  				getClientRect(rc);
96  				::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
97  				return TRUE;
98  			}
99  			break;
100  		}
101  		case NPPM_INTERNAL_REFRESHDARKMODE:
102  		{
103  			if (NppDarkMode::isEnabled())
104  			{
105  				const ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
106  				::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_FORMAT_GRP_STATIC), colEditParam._mainChoice == activeNumeric);
107  			}
108  			NppDarkMode::autoThemeChildControls(_hSelf);
109  			return TRUE;
110  		}
111  		case WM_COMMAND:
112  		{
113  			switch (wParam)
114  			{
115  				case IDCANCEL : 
116  					display(false);
117  					return TRUE;
118  				case IDOK :
119                  {
120  					(*_ppEditView)->execute(SCI_BEGINUNDOACTION);
121  					constexpr int stringSize = 1024;
122  					TCHAR str[stringSize]{};
123  					bool isTextMode = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_COL_TEXT_RADIO, BM_GETCHECK, 0, 0));
124  					if (isTextMode)
125  					{
126  						::SendDlgItemMessage(_hSelf, IDC_COL_TEXT_EDIT, WM_GETTEXT, stringSize, reinterpret_cast<LPARAM>(str));
127  						display(false);
128  						if ((*_ppEditView)->execute(SCI_SELECTIONISRECTANGLE) || (*_ppEditView)->execute(SCI_GETSELECTIONS) > 1)
129  						{
130  							ColumnModeInfos colInfos = (*_ppEditView)->getColumnModeSelectInfo();
131  							std::sort(colInfos.begin(), colInfos.end(), SortInPositionOrder());
132  							(*_ppEditView)->columnReplace(colInfos, str);
133  							std::sort(colInfos.begin(), colInfos.end(), SortInSelectOrder());
134  							(*_ppEditView)->setMultiSelections(colInfos);
135  						}
136  						else
137  						{
138  							auto cursorPos = (*_ppEditView)->execute(SCI_GETCURRENTPOS);
139  							auto cursorCol = (*_ppEditView)->execute(SCI_GETCOLUMN, cursorPos);
140  							auto cursorLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, cursorPos);
141  							auto endPos = (*_ppEditView)->execute(SCI_GETLENGTH);
142  							auto endLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, endPos);
143  							constexpr int lineAllocatedLen = 1024;
144  							TCHAR *line = new TCHAR[lineAllocatedLen];
145  							for (size_t i = cursorLine ; i <= static_cast<size_t>(endLine); ++i)
146  							{
147  								auto lineBegin = (*_ppEditView)->execute(SCI_POSITIONFROMLINE, i);
148  								auto lineEnd = (*_ppEditView)->execute(SCI_GETLINEENDPOSITION, i);
149  								auto lineEndCol = (*_ppEditView)->execute(SCI_GETCOLUMN, lineEnd);
150  								auto lineLen = lineEnd - lineBegin + 1;
151  								if (lineLen > lineAllocatedLen)
152  								{
153  									delete [] line;
154  									line = new TCHAR[lineLen];
155  								}
156  								(*_ppEditView)->getGenericText(line, lineLen, lineBegin, lineEnd);
157  								generic_string s2r(line);
158  								if (lineEndCol < cursorCol)
159  								{
160  									generic_string s_space(cursorCol - lineEndCol, ' ');
161  									s2r.append(s_space);
162  									s2r.append(str);
163  								}
164  								else
165  								{
166  									auto posAbs2Start = (*_ppEditView)->execute(SCI_FINDCOLUMN, i, cursorCol);
167  									auto posRelative2Start = posAbs2Start - lineBegin;
168  									if (posRelative2Start > static_cast<long long>(s2r.length()))
169  										posRelative2Start = s2r.length();
170  									s2r.insert(posRelative2Start, str);
171  								}
172  								(*_ppEditView)->replaceTarget(s2r.c_str(), lineBegin, lineEnd);
173  							}
174  							delete [] line;
175  						}
176  					}
177  					else
178  					{
179  						int initialNumber = ::GetDlgItemInt(_hSelf, IDC_COL_INITNUM_EDIT, NULL, TRUE);
180  						int increaseNumber = ::GetDlgItemInt(_hSelf, IDC_COL_INCREASENUM_EDIT, NULL, TRUE);
181  						int repeat = ::GetDlgItemInt(_hSelf, IDC_COL_REPEATNUM_EDIT, NULL, TRUE);
182  						if (repeat == 0)
183  						{
184  							repeat = 1; 
185  						}
186  						UCHAR format = getFormat();
187  						display(false);
188  						if ((*_ppEditView)->execute(SCI_SELECTIONISRECTANGLE) || (*_ppEditView)->execute(SCI_GETSELECTIONS) > 1)
189  						{
190  							ColumnModeInfos colInfos = (*_ppEditView)->getColumnModeSelectInfo();
191  							if (colInfos.size() > 0)
192  							{
193  								std::sort(colInfos.begin(), colInfos.end(), SortInPositionOrder());
194  								(*_ppEditView)->columnReplace(colInfos, initialNumber, increaseNumber, repeat, format, getLeading());
195  								std::sort(colInfos.begin(), colInfos.end(), SortInSelectOrder());
196  								(*_ppEditView)->setMultiSelections(colInfos);
197  							}
198  						}
199  						else
200  						{
201  							auto cursorPos = (*_ppEditView)->execute(SCI_GETCURRENTPOS);
202  							auto cursorCol = (*_ppEditView)->execute(SCI_GETCOLUMN, cursorPos);
203  							auto cursorLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, cursorPos);
204  							auto endPos = (*_ppEditView)->execute(SCI_GETLENGTH);
205  							auto endLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, endPos);
206  							std::vector<int> numbers;
207  							{
208  								int curNumber = initialNumber;
209  								const size_t kiMaxSize = 1 + (size_t)endLine - (size_t)cursorLine;
210  								while (numbers.size() < kiMaxSize)
211  								{
212  									for (int i = 0; i < repeat; i++)
213  									{
214  										numbers.push_back(curNumber);
215  										if (numbers.size() >= kiMaxSize)
216  										{
217  											break;
218  										}
219  									}
220  									curNumber += increaseNumber;
221  								}
222  							}
223  							assert(numbers.size() > 0);
224  							constexpr int lineAllocatedLen = 1024;
225  							TCHAR *line = new TCHAR[lineAllocatedLen];
226  							UCHAR f = format & MASK_FORMAT;
227  							int base = 10;
228  							if (f == BASE_16)
229  								base = 16;
230  							else if (f == BASE_08)
231  								base = 8;
232  							else if (f == BASE_02)
233  								base = 2;
234  							int endNumber = *numbers.rbegin();
235  							int nbEnd = getNbDigits(endNumber, base);
236  							int nbInit = getNbDigits(initialNumber, base);
237  							int nb = std::max<int>(nbInit, nbEnd);
238  							for (size_t i = cursorLine ; i <= size_t(endLine) ; ++i)
239  							{
240  								auto lineBegin = (*_ppEditView)->execute(SCI_POSITIONFROMLINE, i);
241  								auto lineEnd = (*_ppEditView)->execute(SCI_GETLINEENDPOSITION, i);
242  								auto lineEndCol = (*_ppEditView)->execute(SCI_GETCOLUMN, lineEnd);
243  								auto lineLen = lineEnd - lineBegin + 1;
244  								if (lineLen > lineAllocatedLen)
245  								{
246  									delete [] line;
247  									line = new TCHAR[lineLen];
248  								}
249  								(*_ppEditView)->getGenericText(line, lineLen, lineBegin, lineEnd);
250  								generic_string s2r(line);
251  								int2str(str, stringSize, numbers.at(i - cursorLine), base, nb, getLeading());
252  								if (lineEndCol < cursorCol)
253  								{
254  									generic_string s_space(cursorCol - lineEndCol, ' ');
255  									s2r.append(s_space);
256  									s2r.append(str);
257  								}
258  								else
259  								{
260  									auto posAbs2Start = (*_ppEditView)->execute(SCI_FINDCOLUMN, i, cursorCol);
261  									auto posRelative2Start = posAbs2Start - lineBegin;
262  									if (posRelative2Start > static_cast<long long>(s2r.length()))
263  										posRelative2Start = s2r.length();
264  									s2r.insert(posRelative2Start, str);
265  								}
266  								(*_ppEditView)->replaceTarget(s2r.c_str(), int(lineBegin), int(lineEnd));
267  							}
268  							delete [] line;
269  						}
270  					}
271  					(*_ppEditView)->execute(SCI_ENDUNDOACTION);
272                      (*_ppEditView)->getFocus();
273                      return TRUE;
274                  }
275  				case IDC_COL_TEXT_RADIO :
276  				case IDC_COL_NUM_RADIO :
277  				{
278  					ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
279  					colEditParam._mainChoice = (wParam == IDC_COL_TEXT_RADIO) ? activeText : activeNumeric;
280  					switchTo(colEditParam._mainChoice);
281  					return TRUE;
282  				}
283  				case IDC_COL_DEC_RADIO:
284  				case IDC_COL_OCT_RADIO:
285  				case IDC_COL_HEX_RADIO:
286  				case IDC_COL_BIN_RADIO:
287  				{
288  					ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
289  					colEditParam._formatChoice = 0; 
290  					if (wParam == IDC_COL_HEX_RADIO)
291  						colEditParam._formatChoice = 1;
292  					else if (wParam == IDC_COL_OCT_RADIO)
293  						colEditParam._formatChoice = 2;
294  					else if (wParam == IDC_COL_BIN_RADIO)
295  						colEditParam._formatChoice = 3;
296  					return TRUE;
297  				}
298  				default :
299  				{
300  					switch (HIWORD(wParam))
301  					{
302  						case EN_CHANGE:
303  						{
304  							ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
305  							constexpr int stringSize = MAX_PATH;
306  							TCHAR str[stringSize]{};
307  							switch (LOWORD(wParam))
308  							{
309  								case IDC_COL_TEXT_EDIT:
310  								{
311  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
312  									colEditParam._insertedTextContent = str;
313  									::EnableWindow(::GetDlgItem(_hSelf, IDOK), str[0]);
314  									return TRUE;
315  								}
316  								case IDC_COL_INITNUM_EDIT:
317  								{
318  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
319  									if (lstrcmp(str, TEXT("")) == 0)
320  									{
321  										colEditParam._initialNum = -1;
322  										return TRUE;
323  									}
324  									int num = ::GetDlgItemInt(_hSelf, LOWORD(wParam), NULL, TRUE);
325  									colEditParam._initialNum = num;
326  									return TRUE;
327  								}
328  								case IDC_COL_INCREASENUM_EDIT:
329  								{
330  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
331  									if (lstrcmp(str, TEXT("")) == 0)
332  									{
333  										colEditParam._increaseNum = -1;
334  										return TRUE;
335  									}
336  									int num = ::GetDlgItemInt(_hSelf, LOWORD(wParam), NULL, TRUE);
337  									colEditParam._increaseNum = num;
338  									return TRUE;
339  								}
340  								case IDC_COL_REPEATNUM_EDIT:
341  								{
342  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
343  									if (lstrcmp(str, TEXT("")) == 0)
344  									{
345  										colEditParam._repeatNum = -1;
346  										return TRUE;
347  									}
348  									int num = ::GetDlgItemInt(_hSelf, LOWORD(wParam), NULL, TRUE);
349  									colEditParam._repeatNum = num;
350  									return TRUE;
351  								}
352  							}
353  						}
354  						break;
355  						case CBN_SELCHANGE:
356  						{
357  							if (LOWORD(wParam) == IDC_COL_LEADING_COMBO)
358  							{
359  								ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
360  								colEditParam._leadingChoice = getLeading();
361  								return TRUE;
362  							}
363  						}
364  						break;
365  					}
366  					break;
367  				}
368  			}
369  			break;
370  		}
371  		default :
372  			return FALSE;
373  	}
374  	return FALSE;
375  }
376  void ColumnEditorDlg::switchTo(bool toText)
377  {
378  	HWND hText = ::GetDlgItem(_hSelf, IDC_COL_TEXT_EDIT);
379  	::EnableWindow(hText, toText);
380  	::SendDlgItemMessage(_hSelf, IDC_COL_TEXT_RADIO, BM_SETCHECK, toText, 0);
381  	HWND hNum = ::GetDlgItem(_hSelf, IDC_COL_INITNUM_EDIT);
382  	::SendDlgItemMessage(_hSelf, IDC_COL_NUM_RADIO, BM_SETCHECK, !toText, 0);
383  	::EnableWindow(hNum, !toText);
384  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_INCREASENUM_EDIT), !toText);
385  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_REPEATNUM_EDIT), !toText);
386  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_DEC_RADIO), !toText);
387  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_HEX_RADIO), !toText);
388  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_OCT_RADIO), !toText);
389  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_BIN_RADIO), !toText);
390  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_LEADING_COMBO), !toText);
391  	::EnableWindow(::GetDlgItem(_hSelf, IDOK), !toText || !NppParameters::getInstance()._columnEditParam._insertedTextContent.empty());
392  	::SetFocus(toText?hText:hNum);
393  	redrawDlgItem(IDC_COL_INITNUM_STATIC);
394  	redrawDlgItem(IDC_COL_INCRNUM_STATIC);
395  	redrawDlgItem(IDC_COL_REPEATNUM_STATIC);
396  	redrawDlgItem(IDC_COL_LEADING_STATIC);
397  	if (NppDarkMode::isEnabled())
398  	{
399  		::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_FORMAT_GRP_STATIC), !toText);
400  		redrawDlgItem(IDC_COL_FORMAT_GRP_STATIC);
401  	}
402  }
403  UCHAR ColumnEditorDlg::getFormat()
404  {
405  	UCHAR f = 0; 
406  	if (isCheckedOrNot(IDC_COL_HEX_RADIO))
407  		f = 1;
408  	else if (isCheckedOrNot(IDC_COL_OCT_RADIO))
409  		f = 2;
410  	else if (isCheckedOrNot(IDC_COL_BIN_RADIO))
411  		f = 3;
412  	return f;
413  }
414  ColumnEditorParam::leadingChoice ColumnEditorDlg::getLeading()
415  {
416  	ColumnEditorParam::leadingChoice leading = ColumnEditorParam::noneLeading;
417  	int curSel = static_cast<int>(::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_GETCURSEL, 0, 0));
418  	switch (curSel)
419  	{
420  		case 0:
421  		default:
422  		{
423  			leading = ColumnEditorParam::noneLeading;
424  			break;
425  		}
426  		case 1:
427  		{
428  			leading = ColumnEditorParam::zeroLeading;
429  			break;
430  		}
431  		case 2:
432  		{
433  			leading = ColumnEditorParam::spaceLeading;
434  			break;
435  		}
436  	}
437  	return leading;
438  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-functionListPanel.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-columnEditor.cpp</div>
                </div>
                <div class="column column_space"><pre><code>188  	generic_string* posString2 = reinterpret_cast<generic_string*>(lParam2);
189  	size_t pos1 = _wtoi(posString1->c_str());
190  	size_t pos2 = _wtoi(posString2->c_str());
</pre></code></div>
                <div class="column column_space"><pre><code>69  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
70  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    