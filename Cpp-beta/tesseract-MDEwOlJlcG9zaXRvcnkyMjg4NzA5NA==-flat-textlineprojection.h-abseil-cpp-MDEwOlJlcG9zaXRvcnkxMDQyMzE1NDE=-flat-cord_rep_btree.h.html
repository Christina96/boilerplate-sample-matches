
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.8380355276907%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-textlineprojection.h</h3>
            <pre><code>1  #ifndef TESSERACT_TEXTORD_TEXTLINEPROJECTION_H_
2  #define TESSERACT_TEXTORD_TEXTLINEPROJECTION_H_
3  #include "blobgrid.h" 
4  struct Pix;
5  namespace tesseract {
6  class DENORM;
7  struct TPOINT;
8  class ColPartition;
9  class TESS_API TextlineProjection {
10  public:
11    explicit TextlineProjection(int resolution);
12    ~TextlineProjection();
13    void ConstructProjection(TO_BLOCK *input_block, const FCOORD &rotation, Image nontext_map);
14    void PlotGradedBlobs(BLOBNBOX_LIST *blobs, ScrollView *win);
15    void MoveNonTextlineBlobs(BLOBNBOX_LIST *blobs, BLOBNBOX_LIST *small_blobs) const;
16    void DisplayProjection() const;
17    int DistanceOfBoxFromPartition(const TBOX &box, const ColPartition &part, const DENORM *denorm,
18                                   bool debug) const;
19    int DistanceOfBoxFromBox(const TBOX &from_box, const TBOX &to_box, bool horizontal_textline,
20                             const DENORM *denorm, bool debug) const;
21    int VerticalDistance(bool debug, int x, int y1, int y2) const;
22    int HorizontalDistance(bool debug, int x1, int x2, int y) const;
23    bool BoxOutOfHTextline(const TBOX &box, const DENORM *denorm, bool debug) const;
24    int EvaluateColPartition(const ColPartition &part, const DENORM *denorm, bool debug) const;
25    int EvaluateBox(const TBOX &box, const DENORM *denorm, bool debug) const;
26  private:
27    int EvaluateBoxInternal(const TBOX &box, const DENORM *denorm, bool debug, int *hgrad1,
28                            int *hgrad2, int *vgrad1, int *vgrad2) const;
29    int BestMeanGradientInRow(const DENORM *denorm, int16_t min_x, int16_t max_x, int16_t y,
30                              bool best_is_max) const;
31    int BestMeanGradientInColumn(const DENORM *denorm, int16_t x, int16_t min_y, int16_t max_y,
32                                 bool best_is_max) const;
33    int MeanPixelsInLineSegment(const DENORM *denorm, int offset, TPOINT start_pt,
34                                TPOINT end_pt) const;
35    void IncrementRectangle8Bit(const TBOX &box);
36    void ProjectBlobs(BLOBNBOX_LIST *blobs, const FCOORD &rotation, const TBOX &image_box,
37                      Image nontext_map);
<span onclick='openModal()' class='match'>38    bool PadBlobBox(BLOBNBOX *blob, TBOX *bbox);
39    void TransformToPixCoords(const DENORM *denorm, TPOINT *pt) const;
40    void TruncateToImageBounds(TPOINT *pt) const;
41    int ImageXToProjectionX(int x) const;
42    int ImageYToProjectionY(int y) const;
43    int scale_factor_;
44    int x_origin_;
45    int y_origin_;
46    Image pix_;
</span>47  };
48  } 
49  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_H_
2  #define ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_H_
3  #include <cassert>
4  #include <cstdint>
5  #include <iosfwd>
6  #include "absl/base/config.h"
7  #include "absl/base/internal/raw_logging.h"
8  #include "absl/base/optimization.h"
9  #include "absl/strings/internal/cord_data_edge.h"
10  #include "absl/strings/internal/cord_internal.h"
11  #include "absl/strings/internal/cord_rep_flat.h"
12  #include "absl/strings/string_view.h"
13  #include "absl/types/span.h"
14  namespace absl {
15  ABSL_NAMESPACE_BEGIN
16  namespace cord_internal {
17  void SetCordBtreeExhaustiveValidation(bool do_exaustive_validation);
18  bool IsCordBtreeExhaustiveValidationEnabled();
19  class CordRepBtreeNavigator;
20  class CordRepBtree : public CordRep {
21   public:
22    enum class EdgeType { kFront, kBack };
23    static constexpr EdgeType kFront = EdgeType::kFront;
24    static constexpr EdgeType kBack = EdgeType::kBack;
25    static constexpr size_t kMaxCapacity = 6;
26    static constexpr size_t kMaxDepth = 12;
27    static constexpr int kMaxHeight = static_cast<int>(kMaxDepth - 1);
28    enum Action { kSelf, kCopied, kPopped };
29    struct OpResult {
30      CordRepBtree* tree;
31      Action action;
32    };
33    struct CopyResult {
34      CordRep* edge;
35      int height;
36    };
37    struct Position {
38      size_t index;
39      size_t n;
40    };
41    static CordRepBtree* Create(CordRep* rep);
42    static void Destroy(CordRepBtree* tree);
43    static void Delete(CordRepBtree* tree) { delete tree; }
44    using CordRep::Unref;
45    static void Unref(absl::Span<CordRep* const> edges);
46    static CordRepBtree* Append(CordRepBtree* tree, CordRep* rep);
47    static CordRepBtree* Prepend(CordRepBtree* tree, CordRep* rep);
48    static CordRepBtree* Append(CordRepBtree* tree, string_view data,
49                                size_t extra = 0);
50    static CordRepBtree* Prepend(CordRepBtree* tree, string_view data,
51                                 size_t extra = 0);
52    CordRep* SubTree(size_t offset, size_t n);
53    static CordRep* RemoveSuffix(CordRepBtree* tree, size_t n);
54    char GetCharacter(size_t offset) const;
55    bool IsFlat(absl::string_view* fragment) const;
56    bool IsFlat(size_t offset, size_t n, absl::string_view* fragment) const;
57    Span<char> GetAppendBuffer(size_t size);
58    static ExtractResult ExtractAppendBuffer(CordRepBtree* tree,
59                                             size_t extra_capacity = 1);
60    int height() const { return static_cast<int>(storage[0]); }
61    size_t begin() const { return static_cast<size_t>(storage[1]); }
62    size_t back() const { return static_cast<size_t>(storage[2]) - 1; }
63    size_t end() const { return static_cast<size_t>(storage[2]); }
64    size_t index(EdgeType edge) const {
65      return edge == kFront ? begin() : back();
66    }
67    size_t size() const { return end() - begin(); }
68    size_t capacity() const { return kMaxCapacity; }
<span onclick='openModal()' class='match'>69    inline CordRep* Edge(size_t index) const;
70    inline CordRep* Edge(EdgeType edge_type) const;
71    inline absl::Span<CordRep* const> Edges() const;
72    inline absl::Span<CordRep* const> Edges(size_t begin, size_t end) const;
</span>73    inline absl::string_view Data(size_t index) const;
74    static bool IsValid(const CordRepBtree* tree, bool shallow = false);
75    static CordRepBtree* AssertValid(CordRepBtree* tree, bool shallow = true);
76    static const CordRepBtree* AssertValid(const CordRepBtree* tree,
77                                           bool shallow = true);
78    static void Dump(const CordRep* rep, std::ostream& stream);
79    static void Dump(const CordRep* rep, absl::string_view label,
80                     std::ostream& stream);
81    static void Dump(const CordRep* rep, absl::string_view label,
82                     bool include_contents, std::ostream& stream);
83    template <EdgeType edge_type>
84    inline OpResult AddEdge(bool owned, CordRep* edge, size_t delta);
85    template <EdgeType edge_type>
86    OpResult SetEdge(bool owned, CordRep* edge, size_t delta);
87    static CordRepBtree* New(int height = 0);
88    static CordRepBtree* New(CordRep* rep);
89    static CordRepBtree* New(CordRepBtree* front, CordRepBtree* back);
90    static CordRepBtree* Rebuild(CordRepBtree* tree);
91   private:
92    CordRepBtree() = default;
93    ~CordRepBtree() = default;
94    inline void InitInstance(int height, size_t begin = 0, size_t end = 0);
95    void set_begin(size_t begin) { storage[1] = static_cast<uint8_t>(begin); }
96    void set_end(size_t end) { storage[2] = static_cast<uint8_t>(end); }
97    size_t sub_fetch_begin(size_t n) {
98      storage[1] -= static_cast<uint8_t>(n);
99      return storage[1];
100    }
101    size_t fetch_add_end(size_t n) {
102      const uint8_t current = storage[2];
103      storage[2] = static_cast<uint8_t>(current + n);
104      return current;
105    }
106    Position IndexOf(size_t offset) const;
107    Position IndexBefore(size_t offset) const;
108    Position IndexOfLength(size_t n) const;
109    Position IndexBefore(Position front, size_t offset) const;
110    Position IndexBeyond(size_t offset) const;
111    template <EdgeType edge_type>
112    static CordRepBtree* NewLeaf(absl::string_view data, size_t extra);
113    CordRepBtree* CopyRaw(size_t new_length) const;
114    CordRepBtree* Copy() const;
115    CordRepBtree* CopyBeginTo(size_t end, size_t new_length) const;
116    static CordRepBtree* ConsumeBeginTo(CordRepBtree* tree, size_t end,
117                                        size_t new_length);
118    CordRepBtree* CopyToEndFrom(size_t begin, size_t new_length) const;
119    static CordRep* ExtractFront(CordRepBtree* tree);
120    static CordRepBtree* MergeTrees(CordRepBtree* left, CordRepBtree* right);
121    static CordRepBtree* CreateSlow(CordRep* rep);
122    static CordRepBtree* AppendSlow(CordRepBtree*, CordRep* rep);
123    static CordRepBtree* PrependSlow(CordRepBtree*, CordRep* rep);
124    static void Rebuild(CordRepBtree** stack, CordRepBtree* tree, bool consume);
125    inline void AlignBegin();
126    inline void AlignEnd();
127    template <EdgeType edge_type>
128    inline void Add(CordRep* rep);
129    template <EdgeType edge_type>
130    inline void Add(absl::Span<CordRep* const>);
131    template <EdgeType edge_type>
132    absl::string_view AddData(absl::string_view data, size_t extra);
133    template <EdgeType edge_type>
134    inline void SetEdge(CordRep* edge);
135    CopyResult CopyPrefix(size_t n, bool allow_folding = true);
136    CopyResult CopySuffix(size_t offset);
137    inline OpResult ToOpResult(bool owned);
138    template <EdgeType edge_type>
139    static CordRepBtree* AddCordRep(CordRepBtree* tree, CordRep* rep);
140    template <EdgeType edge_type>
141    static CordRepBtree* AddData(CordRepBtree* tree, absl::string_view data,
142                                 size_t extra = 0);
143    template <EdgeType edge_type>
144    static CordRepBtree* Merge(CordRepBtree* dst, CordRepBtree* src);
145    Span<char> GetAppendBufferSlow(size_t size);
146    CordRep* edges_[kMaxCapacity];
147    friend class CordRepBtreeTestPeer;
148    friend class CordRepBtreeNavigator;
149  };
150  inline CordRepBtree* CordRep::btree() {
151    assert(IsBtree());
152    return static_cast<CordRepBtree*>(this);
153  }
154  inline const CordRepBtree* CordRep::btree() const {
155    assert(IsBtree());
156    return static_cast<const CordRepBtree*>(this);
157  }
158  inline void CordRepBtree::InitInstance(int height, size_t begin, size_t end) {
159    tag = BTREE;
160    storage[0] = static_cast<uint8_t>(height);
161    storage[1] = static_cast<uint8_t>(begin);
162    storage[2] = static_cast<uint8_t>(end);
163  }
164  inline CordRep* CordRepBtree::Edge(size_t index) const {
165    assert(index >= begin());
166    assert(index < end());
167    return edges_[index];
168  }
169  inline CordRep* CordRepBtree::Edge(EdgeType edge_type) const {
170    return edges_[edge_type == kFront ? begin() : back()];
171  }
172  inline absl::Span<CordRep* const> CordRepBtree::Edges() const {
173    return {edges_ + begin(), size()};
174  }
175  inline absl::Span<CordRep* const> CordRepBtree::Edges(size_t begin,
176                                                        size_t end) const {
177    assert(begin <= end);
178    assert(begin >= this->begin());
179    assert(end <= this->end());
180    return {edges_ + begin, static_cast<size_t>(end - begin)};
181  }
182  inline absl::string_view CordRepBtree::Data(size_t index) const {
183    assert(height() == 0);
184    return EdgeData(Edge(index));
185  }
186  inline CordRepBtree* CordRepBtree::New(int height) {
187    CordRepBtree* tree = new CordRepBtree;
188    tree->length = 0;
189    tree->InitInstance(height);
190    return tree;
191  }
192  inline CordRepBtree* CordRepBtree::New(CordRep* rep) {
193    CordRepBtree* tree = new CordRepBtree;
194    int height = rep->IsBtree() ? rep->btree()->height() + 1 : 0;
195    tree->length = rep->length;
196    tree->InitInstance(height, &bsol;*begin=*/0, &bsol;*end=*/1);
197    tree->edges_[0] = rep;
198    return tree;
199  }
200  inline CordRepBtree* CordRepBtree::New(CordRepBtree* front,
201                                         CordRepBtree* back) {
202    assert(front->height() == back->height());
203    CordRepBtree* tree = new CordRepBtree;
204    tree->length = front->length + back->length;
205    tree->InitInstance(front->height() + 1, &bsol;*begin=*/0, &bsol;*end=*/2);
206    tree->edges_[0] = front;
207    tree->edges_[1] = back;
208    return tree;
209  }
210  inline void CordRepBtree::Unref(absl::Span<CordRep* const> edges) {
211    for (CordRep* edge : edges) {
212      if (ABSL_PREDICT_FALSE(!edge->refcount.Decrement())) {
213        CordRep::Destroy(edge);
214      }
215    }
216  }
217  inline CordRepBtree* CordRepBtree::CopyRaw(size_t new_length) const {
218    CordRepBtree* tree = new CordRepBtree;
219    tree->length = new_length;
220    uint8_t* dst = &tree->tag;
221    const uint8_t* src = &tag;
222    const ptrdiff_t offset = src - reinterpret_cast<const uint8_t*>(this);
223    memcpy(dst, src, sizeof(CordRepBtree) - static_cast<size_t>(offset));
224    return tree;
225  }
226  inline CordRepBtree* CordRepBtree::Copy() const {
227    CordRepBtree* tree = CopyRaw(length);
228    for (CordRep* rep : Edges()) CordRep::Ref(rep);
229    return tree;
230  }
231  inline CordRepBtree* CordRepBtree::CopyToEndFrom(size_t begin,
232                                                   size_t new_length) const {
233    assert(begin >= this->begin());
234    assert(begin <= this->end());
235    CordRepBtree* tree = CopyRaw(new_length);
236    tree->set_begin(begin);
237    for (CordRep* edge : tree->Edges()) CordRep::Ref(edge);
238    return tree;
239  }
240  inline CordRepBtree* CordRepBtree::CopyBeginTo(size_t end,
241                                                 size_t new_length) const {
242    assert(end <= capacity());
243    assert(end >= this->begin());
244    CordRepBtree* tree = CopyRaw(new_length);
245    tree->set_end(end);
246    for (CordRep* edge : tree->Edges()) CordRep::Ref(edge);
247    return tree;
248  }
249  inline void CordRepBtree::AlignBegin() {
250    const size_t delta = begin();
251    if (ABSL_PREDICT_FALSE(delta != 0)) {
252      const size_t new_end = end() - delta;
253      set_begin(0);
254      set_end(new_end);
255      ABSL_ASSUME(new_end <= kMaxCapacity);
256  #ifdef __clang__
257  #pragma unroll 1
258  #endif
259      for (size_t i = 0; i < new_end; ++i) {
260        edges_[i] = edges_[i + delta];
261      }
262    }
263  }
264  inline void CordRepBtree::AlignEnd() {
265    const size_t delta = capacity() - end();
266    if (delta != 0) {
267      const size_t new_begin = begin() + delta;
268      const size_t new_end = end() + delta;
269      set_begin(new_begin);
270      set_end(new_end);
271      ABSL_ASSUME(new_end <= kMaxCapacity);
272  #ifdef __clang__
273  #pragma unroll 1
274  #endif
275      for (size_t i = new_end - 1; i >= new_begin; --i) {
276        edges_[i] = edges_[i - delta];
277      }
278    }
279  }
280  template <>
281  inline void CordRepBtree::Add<CordRepBtree::kBack>(CordRep* rep) {
282    AlignBegin();
283    edges_[fetch_add_end(1)] = rep;
284  }
285  template <>
286  inline void CordRepBtree::Add<CordRepBtree::kBack>(
287      absl::Span<CordRep* const> edges) {
288    AlignBegin();
289    size_t new_end = end();
290    for (CordRep* edge : edges) edges_[new_end++] = edge;
291    set_end(new_end);
292  }
293  template <>
294  inline void CordRepBtree::Add<CordRepBtree::kFront>(CordRep* rep) {
295    AlignEnd();
296    edges_[sub_fetch_begin(1)] = rep;
297  }
298  template <>
299  inline void CordRepBtree::Add<CordRepBtree::kFront>(
300      absl::Span<CordRep* const> edges) {
301    AlignEnd();
302    size_t new_begin = begin() - edges.size();
303    set_begin(new_begin);
304    for (CordRep* edge : edges) edges_[new_begin++] = edge;
305  }
306  template <CordRepBtree::EdgeType edge_type>
307  inline void CordRepBtree::SetEdge(CordRep* edge) {
308    const int idx = edge_type == kFront ? begin() : back();
309    CordRep::Unref(edges_[idx]);
310    edges_[idx] = edge;
311  }
312  inline CordRepBtree::OpResult CordRepBtree::ToOpResult(bool owned) {
313    return owned ? OpResult{this, kSelf} : OpResult{Copy(), kCopied};
314  }
315  inline CordRepBtree::Position CordRepBtree::IndexOf(size_t offset) const {
316    assert(offset < length);
317    size_t index = begin();
318    while (offset >= edges_[index]->length) offset -= edges_[index++]->length;
319    return {index, offset};
320  }
321  inline CordRepBtree::Position CordRepBtree::IndexBefore(size_t offset) const {
322    assert(offset > 0);
323    assert(offset <= length);
324    size_t index = begin();
325    while (offset > edges_[index]->length) offset -= edges_[index++]->length;
326    return {index, offset};
327  }
328  inline CordRepBtree::Position CordRepBtree::IndexBefore(Position front,
329                                                          size_t offset) const {
330    size_t index = front.index;
331    offset = offset + front.n;
332    while (offset > edges_[index]->length) offset -= edges_[index++]->length;
333    return {index, offset};
334  }
335  inline CordRepBtree::Position CordRepBtree::IndexOfLength(size_t n) const {
336    assert(n <= length);
337    size_t index = back();
338    size_t strip = length - n;
339    while (strip >= edges_[index]->length) strip -= edges_[index--]->length;
340    return {index, edges_[index]->length - strip};
341  }
342  inline CordRepBtree::Position CordRepBtree::IndexBeyond(
343      const size_t offset) const {
344    size_t off = 0;
345    size_t index = begin();
346    while (offset > off) off += edges_[index++]->length;
347    return {index, off - offset};
348  }
349  inline CordRepBtree* CordRepBtree::Create(CordRep* rep) {
350    if (IsDataEdge(rep)) return New(rep);
351    return CreateSlow(rep);
352  }
353  inline Span<char> CordRepBtree::GetAppendBuffer(size_t size) {
354    assert(refcount.IsOne());
355    CordRepBtree* tree = this;
356    const int height = this->height();
357    CordRepBtree* n1 = tree;
358    CordRepBtree* n2 = tree;
359    CordRepBtree* n3 = tree;
360    switch (height) {
361      case 3:
362        tree = tree->Edge(kBack)->btree();
363        if (!tree->refcount.IsOne()) return {};
364        n2 = tree;
365        ABSL_FALLTHROUGH_INTENDED;
366      case 2:
367        tree = tree->Edge(kBack)->btree();
368        if (!tree->refcount.IsOne()) return {};
369        n1 = tree;
370        ABSL_FALLTHROUGH_INTENDED;
371      case 1:
372        tree = tree->Edge(kBack)->btree();
373        if (!tree->refcount.IsOne()) return {};
374        ABSL_FALLTHROUGH_INTENDED;
375      case 0:
376        CordRep* edge = tree->Edge(kBack);
377        if (!edge->refcount.IsOne()) return {};
378        if (edge->tag < FLAT) return {};
379        size_t avail = edge->flat()->Capacity() - edge->length;
380        if (avail == 0) return {};
381        size_t delta = (std::min)(size, avail);
382        Span<char> span = {edge->flat()->Data() + edge->length, delta};
383        edge->length += delta;
384        switch (height) {
385          case 3:
386            n3->length += delta;
387            ABSL_FALLTHROUGH_INTENDED;
388          case 2:
389            n2->length += delta;
390            ABSL_FALLTHROUGH_INTENDED;
391          case 1:
392            n1->length += delta;
393            ABSL_FALLTHROUGH_INTENDED;
394          case 0:
395            tree->length += delta;
396            return span;
397        }
398        break;
399    }
400    return GetAppendBufferSlow(size);
401  }
402  extern template CordRepBtree* CordRepBtree::AddCordRep<CordRepBtree::kBack>(
403      CordRepBtree* tree, CordRep* rep);
404  extern template CordRepBtree* CordRepBtree::AddCordRep<CordRepBtree::kFront>(
405      CordRepBtree* tree, CordRep* rep);
406  inline CordRepBtree* CordRepBtree::Append(CordRepBtree* tree, CordRep* rep) {
407    if (ABSL_PREDICT_TRUE(IsDataEdge(rep))) {
408      return CordRepBtree::AddCordRep<kBack>(tree, rep);
409    }
410    return AppendSlow(tree, rep);
411  }
412  inline CordRepBtree* CordRepBtree::Prepend(CordRepBtree* tree, CordRep* rep) {
413    if (ABSL_PREDICT_TRUE(IsDataEdge(rep))) {
414      return CordRepBtree::AddCordRep<kFront>(tree, rep);
415    }
416    return PrependSlow(tree, rep);
417  }
418  #ifdef NDEBUG
419  inline CordRepBtree* CordRepBtree::AssertValid(CordRepBtree* tree,
420                                                 bool &bsol;* shallow */) {
421    return tree;
422  }
423  inline const CordRepBtree* CordRepBtree::AssertValid(const CordRepBtree* tree,
424                                                       bool &bsol;* shallow */) {
425    return tree;
426  }
427  #endif
428  }  
429  ABSL_NAMESPACE_END
430  }  
431  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-textlineprojection.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree.h</div>
                </div>
                <div class="column column_space"><pre><code>38    bool PadBlobBox(BLOBNBOX *blob, TBOX *bbox);
39    void TransformToPixCoords(const DENORM *denorm, TPOINT *pt) const;
40    void TruncateToImageBounds(TPOINT *pt) const;
41    int ImageXToProjectionX(int x) const;
42    int ImageYToProjectionY(int y) const;
43    int scale_factor_;
44    int x_origin_;
45    int y_origin_;
46    Image pix_;
</pre></code></div>
                <div class="column column_space"><pre><code>69    inline CordRep* Edge(size_t index) const;
70    inline CordRep* Edge(EdgeType edge_type) const;
71    inline absl::Span<CordRep* const> Edges() const;
72    inline absl::Span<CordRep* const> Edges(size_t begin, size_t end) const;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    