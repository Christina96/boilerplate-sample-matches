
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8426395939086295%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-demo-gio.cpp</h3>
            <pre><code>1  #include "Snap.h"
2  template <class PGraph>
3  void PrintGStats(const char s[], PGraph Graph) {
4    printf("graph %s, nodes %d, edges %d, empty %s\n",
5           s, Graph->GetNodes(), Graph->GetEdges(),
6           Graph->Empty() ? "yes" : "no");
7  }
8  void PrintGStats(const char s[], PBPGraph Graph) {
9    printf("graph %s, right nodes %d, left nodes %d, edges %d, empty %s\n",
10           s, Graph->GetRNodes(), Graph->GetLNodes(),
11           Graph->GetEdges(), Graph->Empty() ? "yes" : "no");
12  }
13  using namespace TSnap;
14  void SaveLoadEdgeList() {
15    const int NNodes = 500;
16    const int NEdges = 2000;
17    const char *FName = "demo.pngraph.dat";
18    const char *Desc = "Randomly generated graph for input/output.";
19    PNGraph GOut, GIn;
20    GOut = GenRndGnm<PNGraph>(NNodes, NEdges);
21    SaveEdgeList(GOut, FName, Desc);
22    GIn = LoadEdgeList<PNGraph>(FName);
23    THashSet<TInt> OutNIdH, InNIdH;
24    for (TNGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
25      if (NI.GetDeg() > 0) {
26        OutNIdH.AddKey(NI.GetId());
27      }
28    }
29    for (TNGraph::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
30      InNIdH.AddKey(NI.GetId());
31    }
32    PrintGStats<PNGraph>("EdgeList - Out", GOut);
33    PrintGStats<PNGraph>("EdgeList - In", GIn);
34  }
35  void IOEdgeListStr() {
36    const int NNodes = 1000;
37    const int NEdges = 5000;
38    const char *FName = "demo1.pnegraph.dat";
39    PNEGraph GOut, GIn;      
40    GOut = GenRndGnm<PNEGraph>(NNodes, NEdges);
41    TIntStrH OutNIdStrH;
42    TStrHash<TInt> OutStrNIdH;
43    TStr RandStr;
44    for (TNEGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
45      do {
46        RandStr.Clr();
47        RandStr += "node-";
48        TInt RandLen = TInt::Rnd.GetUniDevInt(3, 6);
49        for (int i = 0; i < RandLen; i++) {
50          TStr RandChar(TInt::Rnd.GetUniDevInt(48, 57));
51          RandStr += RandChar;
52        }
53      }
54      while (OutStrNIdH.IsKey(RandStr) || RandStr[0] == '#'); 
55      OutNIdStrH.AddDat(NI.GetId(), RandStr);
56      OutStrNIdH.AddDat(RandStr, NI.GetId());
57    }
58    FILE *F = fopen(FName, "w");
59    for (TNEGraph::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
60      TInt Src = EI.GetSrcNId();
61      TInt Dst = EI.GetDstNId();
62      fprintf(F, "%s %s\n", OutNIdStrH[Src].CStr(), OutNIdStrH[Dst].CStr());
63    }
64    fclose(F);
65    TStrHash<TInt> InStrToNIdH;
66    GIn = LoadEdgeListStr<PNEGraph>(FName, 0, 1, InStrToNIdH);
67    PrintGStats<PNEGraph>("EdgeListStr - Out", GOut);
68    PrintGStats<PNEGraph>("EdgeListStr - In", GIn);
69    for (TNEGraph::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
70      int NId = NI.GetId();
71      TStr NameStr = InStrToNIdH.GetKey(NId);
72      printf("node ID %d is string %s\n", NId, NameStr.CStr());
73    }
74    for (TNEGraph::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
75      TStr NameStr = InStrToNIdH.GetKey(NI.GetId());
76      int NId = InStrToNIdH.GetKeyId(NameStr);
77      printf("string %s has node ID %d\n", NameStr.CStr(), NId);
78    }
79  }
80  void IOConnList() {
81    const int NNodes = 500;
82    const int NEdges = 2000;
83    const char *FName = "demo2.pnegraph.dat";
84    PNEGraph GOut, GIn;
85    GOut = GenRndGnm<PNEGraph>(NNodes, NEdges);
86    FILE *F = fopen(FName, "w");
87    for (TNEGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
88      fprintf(F, "%d", NI.GetId());
89      for (int i = 0; i < NI.GetOutDeg(); i++) {
90        fprintf(F, " %d", NI.GetOutNId(i));
91      }
92      fprintf(F, "\n");
93    }
94    fclose(F);
95    GIn = LoadConnList<PNEGraph>(FName);
96    PrintGStats("ConnList - Out", GOut);
97    PrintGStats("ConnList - In", GIn);
98  }
99  void IOConnListStr() {
100    const int NNodes = 500;
101    const int NEdges = 2000;
102    const char *FName = "demo.pungraph.dat";
103    PUNGraph GOut, GIn;
104    GOut = GenRndGnm<PUNGraph>(NNodes, NEdges);
105    TIntStrH OutNIdStrH;
106    TStrHash<TInt> OutStrNIdH;
107    for (TUNGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
108      TStr RandStr = "";
109      do {
110        TInt RandLen = TInt::Rnd.GetUniDevInt(5, 10);
111        for (int i = 0; i < RandLen; i++) {
112          TStr RandChar(TInt::Rnd.GetUniDevInt(97, 122));
113          RandStr += RandChar;
114        }
115      }
116      while (OutStrNIdH.IsKey(RandStr) || RandStr[0] == '#');
117      OutNIdStrH.AddDat(NI.GetId(), RandStr);
118      OutStrNIdH.AddDat(RandStr, NI.GetId());
119    }
120    FILE *F = fopen(FName, "w");
<span onclick='openModal()' class='match'>121    for (TUNGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
122      fprintf(F, "%s", OutNIdStrH[NI.GetId()].CStr());
123      for (int e = 0; e < NI.GetOutDeg(); e++) {
124        fprintf(F, " %s", OutNIdStrH[NI.GetOutNId(e)].CStr());
</span>125      }
126      fprintf(F, "\n");
127    }
128    fclose(F);
129    TStrHash<TInt> InStrToNIdH;
130    GIn = LoadConnListStr<PUNGraph>(FName, InStrToNIdH);
131    PrintGStats("ConnListStr - Out", GOut);
132    PrintGStats("ConnListStr - In", GIn);
133  }
134  void IOPajek() {
135    const int NNodes = 500;
136    const int NEdges = 2000;
137    const char *FName = "demo.paj.dat";
138    PNEGraph GOut, GIn;
139    GOut = GenRndGnm<PNEGraph>(NNodes, NEdges);
140    SavePajek(GOut, FName);
141    GIn = LoadPajek<PNEGraph>(FName);
142    TIntV OutNIdV, InNIdV;
143    GOut->GetNIdV(OutNIdV);
144    for (int i = 0; i < OutNIdV.Len(); i++) {
145      OutNIdV[i]++;
146    }
147    GIn->GetNIdV(InNIdV);
148    PrintGStats("Pajek - Out", GOut);
149    PrintGStats("Pajek - In", GIn);
150  }
151  void IOMatlabSparseMtx() {
152    const int NNodes = 500;
153    const int NEdges = 2000;
154    const char *FName = "demo.matlab.dat";
155    PNGraph GOut, GIn;
156    GOut = GenRndGnm<PNGraph>(NNodes, NEdges);
157    SaveMatlabSparseMtx(GOut, FName);
158    GIn = TNGraph::New();
159    GIn->Reserve(NNodes, NEdges);
160    FILE *F = fopen(FName, "r");
161    while (! feof(F)) {
162      int Src, Dst, Edge;
163      fscanf(F, "%d %d %d\n", &Src, &Dst, &Edge);
164      Src--; Dst--;             
165      if (not GIn->IsNode(Src)) {
166        GIn->AddNode(Src);
167      }
168      if (not GIn->IsNode(Dst)) {
169        GIn->AddNode(Dst);
170      }
171      GIn->AddEdge(Src, Dst);
172    }
173    fclose(F);
174    THashSet<TInt> OutNIdH, InNIdH;
175    for (TNGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
176      if (NI.GetDeg() > 0) {
177        OutNIdH.AddKey(NI.GetId());
178      }
179    }
180    for (TNGraph::TNodeI NI = GIn->BegNI(); NI < GIn->EndNI(); NI++) {
181      InNIdH.AddKey(NI.GetId());
182    }
183    PrintGStats("Matlab - Out", GOut);
184    PrintGStats("Matlab - In", GIn);
185  }
186  void IOGViz() {
187    const int NNodes = 500;
188    const int NEdges = 2000;
189    const char *FName1 = "demo1.dot.dat", *FName2 = "demo2.dot.dat";
190    const char *Desc = "Randomly generated GgraphVizp for input/output.";
191    PNGraph GOut;     
192    GOut = GenRndGnm<PNGraph>(NNodes, NEdges);
193    SaveGViz(GOut, FName1);
194    TIntStrH NIdLabelH;
195    for (TNGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
196      NIdLabelH.AddDat(NI.GetId(), TStr::Fmt("Node%d", NI.GetId()));
197    }
198    SaveGViz(GOut, FName2, Desc, NIdLabelH);
199    PrintGStats("IOGViz - In", GOut);
200  }
201  void IODyNet() {
202    const int NNodes = 500;
203    const int NEdges = 2000;
204    const char *FName = "demo.xml.dat";
205    PNGraph GOut, GIn;
206    GOut = GenRndGnm<PNGraph>(NNodes, NEdges);
207    FILE *F = fopen(FName, "w");
208    fprintf(F, "<network>\n");
209    for (TNGraph::TEdgeI EI = GOut->BegEI(); EI < GOut->EndEI(); EI++) {
210      TInt Src = EI.GetSrcNId();
211      TInt Dst = EI.GetDstNId();
212      fprintf(F, "\t<link source=\"%d\" target=\"%d\"/>\n", Src.Val, Dst.Val);
213    }
214    fprintf(F, "</network>\n");
215    fclose(F);
216    GIn = LoadDyNet(FName);
217    PrintGStats("DyNet - Out", GOut);
218    PrintGStats("DyNet - In", GIn);
219  }
220  int main(int argc, char* argv[]) {
221    SaveLoadEdgeList();
222    IOEdgeListStr();
223    IOConnList();
224    IOConnListStr();
225    IOPajek();
226    IOMatlabSparseMtx();
227    IOGViz();
228    IODyNet();
229  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-googlex.cpp</h3>
            <pre><code>1  #include "google.h"
2  TMd5Sig TGgSchRef::GetMd5Sig() const {
3    TChA ChA;
4    ChA+=TitleStr;
5    for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
6      ChA+=';'; ChA+=AuthNmV[AuthN];}
7    ChA+=';'; ChA+=PubNm;
8    ChA+=';'; ChA+=YearStr;
9    return TMd5Sig(ChA);
10  }
11  void TGgSchRef::GetAuthNmVPubStr(
12   const TStr& AuthNmVPubStr, TStrV& AuthNmV, TStr& PubNm, TStr& PubYearStr){
13    TStr AuthNmVStr; TStr PubStr;
14    AuthNmVPubStr.SplitOnStr(AuthNmVStr, " - ", PubStr);
15    AuthNmVStr.SplitOnAllCh(',', AuthNmV, true);
16    for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
17      AuthNmV[AuthN].ToTrunc();
18    }
19    if ((!AuthNmV.Empty())&&
20     ((AuthNmV.Last().IsStrIn("..."))||(AuthNmV.Last().Len()<=2))){
21      AuthNmV.DelLast();
22    }
23    TStr OriginStr; TStr LinkStr;
24    PubStr.SplitOnStr(OriginStr, " - ", LinkStr);
25    OriginStr.SplitOnLastCh(PubNm, ',', PubYearStr);
26    PubNm.ToTrunc(); PubYearStr.ToTrunc();
27    if ((PubYearStr.Len()>=4)&&(PubYearStr.GetSubStr(0, 3).IsInt())){
28      PubYearStr=PubYearStr.GetSubStr(0, 3);
29    } else
30    if ((PubNm.Len()>=4)&&(PubNm.GetSubStr(0, 3).IsInt())){
31      PubYearStr=PubNm.GetSubStr(0, 3); PubNm="";
32    } else {
33      PubYearStr="";
34    }
35  }
36  void TGgSchRef::SaveXml(FILE* fOut, const int& RefN){
37    if (RefN==-1){
38      fprintf(fOut, "    <Ref>\n");
39    } else {
40      fprintf(fOut, "    <Ref Num=\"%d\">\n", RefN);
41    }
42    fprintf(fOut, "    <MD5>%s</MD5>\n", GetMd5Sig().GetStr().CStr());
43    fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(TitleStr).CStr());
44    if (AuthNmV.Len()>0){
45      fprintf(fOut, "      <Authors>");
46      for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
47        fprintf(fOut, "<Author>%s</Author>", TXmlLx::GetXmlStrFromPlainStr(AuthNmV[AuthN]).CStr());
48      }
49      fprintf(fOut, "</Authors>\n");
50    }
51    if (!PubNm.Empty()){
52      fprintf(fOut, "      <Pub>%s</Pub>\n", TXmlLx::GetXmlStrFromPlainStr(PubNm).CStr());}
53    if (!YearStr.Empty()){
54      fprintf(fOut, "      <Year>%s</Year>\n", TXmlLx::GetXmlStrFromPlainStr(YearStr).CStr());}
55    fprintf(fOut, "      <Citations>%d</Citations>\n", Citations);
56    if (!CitedByUrlStr.Empty()){
57      fprintf(fOut, "      <CitedByUrl>%s</CitedByUrl>\n", TXmlLx::GetXmlStrFromPlainStr(CitedByUrlStr).CStr());}
58    fprintf(fOut, "    </Ref>\n");
59  }
60  PGgSchRSet TGgSchRSet::NewScholar(const TStr& UrlStr, const TStr& HtmlStr){
61    PGgSchRSet RSet=TGgSchRSet::New();
62    PSIn HtmlSIn=TStrIn::New(HtmlStr);
63    THtmlLx HtmlLx(HtmlSIn);
64    HtmlLx.MoveToStrOrEof("Results");
65    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
66    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
67    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
68    AllHitsStr.DelChAll(',');
69    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
70    HtmlLx.MoveToBTagOrEof("<P>");
71    forever {
72      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<P>"))){break;}
73      HtmlLx.GetSym();
74      if (HtmlLx.Sym==hsyBTag){
75        TStr FullBTagStr=HtmlLx.GetFullBTagStr();
76        if (FullBTagStr=="<FONT SIZE=\"-2\">"){
77          TStr PubTypeNm=HtmlLx.GetStrInTag("<B>", true);
78        } else
79        if (FullBTagStr=="<SPAN CLASS=\"w\">"){
80        } else {
81          break;
82        }
83        TStr TitleStr=HtmlLx.GetStrToBTag("<BR>", true).GetTrunc();
84        if (TitleStr.IsPrefix("[PS] ")){
85          TitleStr=TitleStr.GetSubStr(5, TitleStr.Len()).GetTrunc();}
86        TStr AuthNmVPubStr=HtmlLx.GetStrToBTag("<BR>", true);
87        TStrV AuthNmV; TStr PubNm; TStr PubYearStr;
88        TGgSchRef::GetAuthNmVPubStr(AuthNmVPubStr, AuthNmV, PubNm, PubYearStr);
89        TStr CitedByUrlStr; int Citations=0;
90        HtmlLx.MoveToBTag3OrEof("<A>", "<P>", "<DIV>");
91        if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.ChA=="<A>")){
92          TStr CitedByRelUrlStr=HtmlLx.GetArg("HREF");
93          TStr AStr=HtmlLx.GetStrToETag("<A>", true);
94          if (AStr.IsPrefix("Cited by ")){
95            PUrl CitedByUrl=TUrl::New(CitedByRelUrlStr, UrlStr);
96            if (CitedByUrl->IsOk()){
97              CitedByUrlStr=CitedByUrl->GetUrlStr();
98              Citations=AStr.GetSubStr(TStr("Cited by ").Len(), AStr.Len()).GetInt(0);
99            }
100          }
101          HtmlLx.MoveToBTag2OrEof("<P>", "<DIV>");
102        }
103        PGgSchRef Ref=
104         TGgSchRef::New(TitleStr, AuthNmV, PubNm, PubYearStr, Citations, CitedByUrlStr);
105        RSet->AddHit(Ref);
106      } else {
107        break;
108      }
109    }
110    TStr NextUrlStr;
111    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
112      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
113      if (!NextRelUrlStr.Empty()){
114        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
115        if (NextUrl->IsOk()){
116          NextUrlStr=NextUrl->GetUrlStr();
117        }
118      }
119    }
120    RSet->PutUrlStr(UrlStr);
121    RSet->PutNextUrlStr(NextUrlStr);
122    RSet->PutQueryStr(QueryStr);
123    RSet->PutAllHits(AllHitsStr.GetInt(-1));
124    return RSet;
125  }
126  PGgSchRSet TGgSchRSet::NewScholar(const PWebPg& WebPg){
127    TStr UrlStr=WebPg->GetUrlStr();
128    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
129    return TGgSchRSet::NewScholar(UrlStr, HtmlStr);
130  }
131  void TGgSchRSet::Merge(const PGgSchRSet& RSet){
132    if (RSet.Empty()){return;}
133    TStrH TitleStrH(GetHits());
134    for (int HitN=0; HitN<GetHits(); HitN++){
135      TitleStrH.AddKey(GetHit(HitN)->TitleStr);
136    }
137    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
138      PGgSchRef Ref=RSet->GetHit(HitN);
139      if (!TitleStrH.IsKey(Ref->TitleStr)){
140        AddHit(Ref);
141        TitleStrH.AddKey(Ref->TitleStr);
142      }
143    }
144    PutNextUrlStr("");
145    PutAllHits(-1);
146  }
147  PBowDocBs TGgSchRSet::GetBowDocBs() const {
148    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
149    PStemmer Stemmer=TStemmer::New(stmtPorter, true);
150    TStrV HtmlStrV(GetHits(), 0);
151    for (int HitN=0; HitN<GetHits(); HitN++){
152      TStr HtmlStr=GetHit(HitN)->TitleStr;
153      HtmlStrV.Add(HtmlStr);
154    }
155    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
156     HtmlStrV, 3, 3, SwSet, Stemmer);
157    printf("Create Bag-Of-Words Base ... ");
<span onclick='openModal()' class='match'>158    PBowDocBs BowDocBs=TBowDocBs::New();
159    BowDocBs->PutNGramBs(NGramBs);
160    for (int HitN=0; HitN<GetHits(); HitN++){
161      BowDocBs->AddHtmlDoc(TInt::GetStr(HitN), TStrV(), HtmlStrV[HitN]);
</span>162    }
163    BowDocBs->AssertOk();
164    printf("Done.\n");
165    return BowDocBs;
166  }
167  void TGgSchRSet::SaveBin(const TStr& FNm, const PGgSchRSet& GgSchRSet){
168    if (GgSchRSet.Empty()){
169      PGgSchRSet RSet=TGgSchRSet::New();
170      GgSchRSet->SaveBin(FNm);
171    } else {
172      GgSchRSet->SaveBin(FNm);
173    }
174  }
175  void TGgSchRSet::SaveXml(const TStr& FNm, const PGgSchRSet& GgSchRSet){
176    if (GgSchRSet.Empty()){
177      TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
178      fprintf(fOut, "<GgSchRSets>\n");
179      fprintf(fOut, "  <Error/>\n");
180      fprintf(fOut, "</GgSchRSets>");
181    } else {
182      GgSchRSet->SaveXml(FNm);
183    }
184  }
185  void TGgSchRSet::SaveXml(const TStr& FNm){
186    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
187    fprintf(fOut, "<RSet>\n");
188    if (!GetUrlStr().Empty()){
189      fprintf(fOut, "  <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(GetUrlStr()).CStr());}
190    if (!GetNextUrlStr().Empty()){
191      fprintf(fOut, "  <NextUrl>%s</NextUrl>\n", TXmlLx::GetXmlStrFromPlainStr(GetNextUrlStr()).CStr());}
192    if (!GetQueryStr().Empty()){
193      fprintf(fOut, "  <Query>%s</Query>\n", TXmlLx::GetXmlStrFromPlainStr(GetQueryStr()).CStr());}
194    if (GetAllHits()!=-1){
195      fprintf(fOut, "  <AllHits>%d</AllHits>\n", GetAllHits());}
196    fprintf(fOut, "  <Hits Size=\"%d\">\n", GetHits());
197    for (int HitN=0; HitN<GetHits(); HitN++){
198      PGgSchRef Ref=GetHit(HitN);
199      Ref->SaveXml(fOut, 1+HitN);
200    }
201    fprintf(fOut, "  </Hits>\n");
202    fprintf(fOut, "</RSet>");
203  }
204  void TGgSchRSet::LoadRSetsBin(const TStr& FNm, TGgSchRSetV& RSetV){
205    TFIn SIn(FNm); RSetV.Clr(); int RSets=0;
206    while (!SIn.Eof()){
207      RSets++; if (RSets%100==0){printf("%d\r", RSets);}
208      PGgSchRSet RSet(SIn);
209      RSetV.Add(RSet);
210    }
211  }
212  void TGgSchRSet::SaveRSetsBin(const TStr& FNm, TGgSchRSetV& RSetV){
213    TFOut SOut(FNm);
214    for (int RSetN=0; RSetN<RSetV.Len(); RSetN++){
215      RSetV[RSetN].Save(SOut);
216    }
217  }
218  void TGgSchBs::AddRef(const PGgSchRef& Ref){
219    TMd5Sig Sig=Ref->GetMd5Sig();
220    if (!RefMd5ToRefH.IsKey(Sig)){
221      RefMd5ToRefH.AddDat(Sig)=Ref;
222      RefMd5ToRefCiteCrawlPH.AddDat(Sig)=false;
223      for (int AuthN=0; AuthN<Ref->AuthNmV.Len(); AuthN++){
224        TStr LcAuthNm=Ref->AuthNmV[AuthN].GetLc();
225        if ((!LcAuthNm.Empty())&&(!AuthNmToCrawlPH.IsKey(LcAuthNm))){
226          AuthNmToCrawlPH.AddDat(LcAuthNm)=false;
227        }
228      }
229      TStr LcPubNm=Ref->PubNm.GetLc();
230      if ((!Ref->PubNm.Empty())&&(!AuthNmToCrawlPH.IsKey(LcPubNm))){
231        PubNmToCrawlPH.AddDat(LcPubNm)=false;
232      }
233    }
234  }
235  void TGgSchBs::AddRSet(const PGgSchRSet& RSet){
236    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
237      PGgSchRef Ref=RSet->GetHit(HitN);
238      AddRef(Ref);
239    }
240  }
241  TStr TGgSchBs::GetAuthNmToCrawl() const {
242    TStr AuthNm;
243    for (int AuthN=0; AuthN<AuthNmToCrawlPH.Len(); AuthN++){
244      if (!AuthNmToCrawlPH[AuthN]){
245        AuthNm=AuthNmToCrawlPH.GetKey(AuthN); break;
246      }
247    }
248    return AuthNm;
249  }
250  void TGgSchBs::SetAuthCrawled(const TStr& AuthNm){
251    AuthNmToCrawlPH.AddDat(AuthNm.GetLc())=true;
252  }
253  void TGgSchBs::SaveXml(const TStr& FNm){
254    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
255    fprintf(fOut, "<GgSchBs>\n");
256    for (int RefN=0; RefN<GetRefs(); RefN++){
257      PGgSchRef Ref=GetRef(RefN);
258      Ref->SaveXml(fOut, 1+RefN);
259    }
260    fprintf(fOut, "</GgSchBs>");
261  }
262  PRSet TRSet::NewWeb(const TStr& UrlStr, const TStr& HtmlStr){
263    PRSet RSet=TRSet::New();
264    PSIn HtmlSIn=TStrIn::New(HtmlStr);
265    THtmlLx HtmlLx(HtmlSIn);
266    HtmlLx.MoveToStrOrEof("Results");
267    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
268    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
269    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
270    AllHitsStr.DelChAll(',');
271    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
272    forever {
273      HtmlLx.MoveToBTagOrEof("<P>", "CLASS", "g", "<DIV>", "CLASS", "n");
274      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<P>"))){break;}
275      HtmlLx.MoveToBTagOrEof("<A>");
276      if (HtmlLx.Sym!=hsyBTag){break;}
277      TStr HitUrlStr=HtmlLx.GetArg("HREF");
278      TStr HitTitleStr=HtmlLx.GetStrToETag("<A>", true);
279      HtmlLx.MoveToBTagOrEof("<FONT>");
280      TStr HitCtxStr=HtmlLx.GetStrToBTag("<FONT>", "COLOR", "#008000", true);
281      RSet->AddHit(HitUrlStr, HitTitleStr, "", HitCtxStr);
282    }
283    TStr NextUrlStr;
284    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
285      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
286      if (!NextRelUrlStr.Empty()){
287        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
288        if (NextUrl->IsOk()){
289          NextUrlStr=NextUrl->GetUrlStr();
290        }
291      }
292    }
293    RSet->PutUrlStr(UrlStr);
294    RSet->PutNextUrlStr(NextUrlStr);
295    RSet->PutQueryStr(QueryStr);
296    RSet->PutAllHits(AllHitsStr.GetInt(-1));
297    return RSet;
298  }
299  PRSet TRSet::NewWeb(const PWebPg& WebPg){
300    TStr UrlStr=WebPg->GetUrlStr();
301    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
302    return TRSet::NewWeb(UrlStr, HtmlStr);
303  }
304  PRSet TRSet::NewNews(const TStr& UrlStr, const TStr& HtmlStr){
305    PRSet RSet=TRSet::New();
306    PSIn HtmlSIn=TStrIn::New(HtmlStr);
307    THtmlLx HtmlLx(HtmlSIn);
308    HtmlLx.MoveToStrOrEof("Results");
309    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
310    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
311    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
312    AllHitsStr.DelChAll(',');
313    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
314    forever {
315      HtmlLx.MoveToBTagOrEof("<TABLE>", "WIDTH", "75%", "<DIV>", "CLASS", "n");
316      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<TABLE>"))){break;}
317      HtmlLx.MoveToBTagOrEof("<A>");
318      if (HtmlLx.Sym!=hsyBTag){break;}
319      TStr HitUrlStr=HtmlLx.GetArg("HREF");
320      TStr IdStr=HtmlLx.GetArg("ID");
321      if ((!IdStr.Empty())&&(IdStr.LastCh()=='i')){
322        HtmlLx.MoveToBTagOrEof("<A>");
323        if (HtmlLx.Sym!=hsyBTag){break;}
324        HitUrlStr=HtmlLx.GetArg("HREF");
325      }
326      TStr HitTitleStr=HtmlLx.GetStrToETag("<A>", true);
327      TStr HitSrcNm=HtmlLx.GetStrToBTag("<NOBR>", true);
328      if (HitSrcNm.IsSuffix(" -")){
329        HitSrcNm=HitSrcNm.GetSubStr(0, HitSrcNm.Len()-3);}
330      HtmlLx.MoveToETagOrEof("<NOBR>");
331      TStr HitCtxStr=HtmlLx.GetStrToETag("<TABLE>", true);
332      RSet->AddHit(HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
333    }
334    TStr NextUrlStr;
335    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
336      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
337      if (!NextRelUrlStr.Empty()){
338        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
339        if (NextUrl->IsOk()){
340          NextUrlStr=NextUrl->GetUrlStr();
341        }
342      }
343    }
344    RSet->PutUrlStr(UrlStr);
345    RSet->PutNextUrlStr(NextUrlStr);
346    RSet->PutQueryStr(QueryStr);
347    RSet->PutAllHits(AllHitsStr.GetInt(-1));
348    return RSet;
349  }
350  PRSet TRSet::NewNews(const PWebPg& WebPg){
351    TStr UrlStr=WebPg->GetUrlStr();
352    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
353    return TRSet::NewNews(UrlStr, HtmlStr);
354  }
355  int TRSet::GetHitN(const TStr& UrlStr, const bool& LcP) const {
356    int Hits=GetHits();
357    TStr LcUrlStr=UrlStr.GetLc();
358    for (int HitN=0; HitN<Hits; HitN++){
359      if (LcP){
360        if (GetHitUrlStr(HitN).GetLc()==LcUrlStr){return HitN;}
361      } else {
362        if (GetHitUrlStr(HitN)==UrlStr){return HitN;}
363      }
364    }
365    return -1;
366  }
367  void TRSet::Merge(const PRSet& RSet){
368    if (RSet.Empty()){return;}
369    TStrH UrlStrH(GetHits());
370    for (int HitN=0; HitN<GetHits(); HitN++){
371      UrlStrH.AddKey(GetHitUrlStr(HitN));
372    }
373    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
374      TStr HitUrlStr; TStr HitTitleStr; TStr HitSrcNm; TStr HitCtxStr;
375      RSet->GetHit(HitN, HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
376      if (!UrlStrH.IsKey(HitUrlStr)){
377        AddHit(HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
378        UrlStrH.AddKey(HitUrlStr);
379      }
380    }
381    PutNextUrlStr("");
382    PutAllHits(-1);
383  }
384  PBowDocBs TRSet::GetBowDocBs() const {
385    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
386    PStemmer Stemmer=TStemmer::New(stmtPorter, true);
387    TStrV HtmlStrV(GetHits(), 0);
388    for (int HitN=0; HitN<GetHits(); HitN++){
389      TStr TitleStr=GetHitTitleStr(HitN);
390      TStr CtxStr=GetHitCtxStr(HitN);
391      TStr HtmlStr=TitleStr+". "+CtxStr;
392      HtmlStrV.Add(HtmlStr);
393    }
394    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
395     HtmlStrV, 3, 3, SwSet, Stemmer);
396    printf("Create Bag-Of-Words Base ... ");
397    PBowDocBs BowDocBs=TBowDocBs::New();
398    BowDocBs->PutNGramBs(NGramBs);
399    for (int HitN=0; HitN<GetHits(); HitN++){
400      BowDocBs->AddHtmlDoc(GetHitUrlStr(HitN), TStrV(), HtmlStrV[HitN]);
401    }
402    BowDocBs->AssertOk();
403    printf("Done.\n");
404    return BowDocBs;
405  }
406  void TRSet::SaveBin(const TStr& FNm, const PRSet& RSet){
407    if (RSet.Empty()){
408      PRSet RSet=TRSet::New();
409      RSet->SaveBin(FNm);
410    } else {
411      RSet->SaveBin(FNm);
412    }
413  }
414  void TRSet::SaveXml(const TStr& FNm, const PRSet& RSet){
415    if (RSet.Empty()){
416      TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
417      fprintf(fOut, "<RSets>\n");
418      fprintf(fOut, "  <Error/>\n");
419      fprintf(fOut, "</RSets>");
420    } else {
421      RSet->SaveXml(FNm);
422    }
423  }
424  void TRSet::SaveXml(const TStr& FNm){
425    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
426    fprintf(fOut, "<RSet>\n");
427    if (!GetUrlStr().Empty()){
428      fprintf(fOut, "  <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(GetUrlStr()).CStr());}
429    if (!GetNextUrlStr().Empty()){
430      fprintf(fOut, "  <NextUrl>%s</NextUrl>\n", TXmlLx::GetXmlStrFromPlainStr(GetNextUrlStr()).CStr());}
431    if (!GetQueryStr().Empty()){
432      fprintf(fOut, "  <Query>%s</Query>\n", TXmlLx::GetXmlStrFromPlainStr(GetQueryStr()).CStr());}
433    if (GetAllHits()!=-1){
434      fprintf(fOut, "  <AllHits>%d</AllHits>\n", GetAllHits());}
435    fprintf(fOut, "  <Hits Size=\"%d\">\n", GetHits());
436    for (int HitN=0; HitN<GetHits(); HitN++){
437      TStr HitUrlStr; TStr HitTitleStr; TStr HitSrcNm; TStr HitCtxStr;
438      GetHit(HitN, HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
439      fprintf(fOut, "    <Hit Num=\"%d\">\n", 1+HitN);
440      fprintf(fOut, "      <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(HitUrlStr).CStr());
441      fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(HitTitleStr).CStr());
442      if (!HitSrcNm.Empty()){
443        fprintf(fOut, "      <Source>%s</Source>\n", TXmlLx::GetXmlStrFromPlainStr(HitSrcNm).CStr());}
444      fprintf(fOut, "      <Snippet>%s</Snippet>\n", TXmlLx::GetXmlStrFromPlainStr(HitCtxStr).CStr());
445      fprintf(fOut, "    </Hit>\n");
446    }
447    fprintf(fOut, "  </Hits>\n");
448    fprintf(fOut, "</RSet>");
449  }
450  void TRSet::LoadRSetsBin(const TStr& FNm, TRSetV& RSetV){
451    TFIn SIn(FNm); RSetV.Clr(); int RSets=0;
452    while (!SIn.Eof()){
453      RSets++; if (RSets%100==0){printf("%d\r", RSets);}
454      PRSet RSet(SIn);
455      RSetV.Add(RSet);
456    }
457  }
458  void TRSet::SaveRSetsBin(const TStr& FNm, TRSetV& RSetV){
459    TFOut SOut(FNm);
460    for (int RSetN=0; RSetN<RSetV.Len(); RSetN++){
461      RSetV[RSetN].Save(SOut);
462    }
463  }
464  void TGgWebFetchSaver::OnFetch(const int&, const PWebPg& WebPg){
465    printf("Fetched [Wait:%d Conn.:%d]: %s\n",
466     GetWaitUrls(), GetConnUrls(), WebPg->GetUrlStr().CStr());
467    WebPgV.Add(WebPg);
468    if (Empty()){
469      TSysMsg::Quit();}
470  }
471  void TGgWebFetchSaver::OnError(const int&, const TStr& MsgStr){
472    printf("Error [Wait:%d Conn.:%d]: %s\n",
473     GetWaitUrls(), GetConnUrls(), MsgStr.CStr());
474    if (Empty()){
475      TSysMsg::Quit();}
476  }
477  PWebPg TGgWebFetchSaver::GetWebPg(const TStr& UrlStr) const {
478    for (int WebPgN=0; WebPgN<GetWebPgs(); WebPgN++){
479      if (GetWebPg(WebPgN)->GetUrlStr(0)==UrlStr){
480        return GetWebPg(WebPgN);}
481    }
482    return NULL;
483  }
484  PGgFCrawl TGgFCrawl::GetFCrawl(
485   const TStr& SrcUrlStr, const int& MxCands, const TStr& ProxyStr){
486    printf("Expand source URL: %s\n", SrcUrlStr.CStr());
487    PRSet SrcUrlRSet=
488     TGg::WebSearch(TStr("related:")+SrcUrlStr, -1, TNotify::NullNotify, ProxyStr);
489    PGgFCrawl FCrawl=TGgFCrawl::New();
490    FCrawl->SrcUrlStr=SrcUrlStr;
491    FCrawl->DstRSet=TRSet::New(SrcUrlRSet);
492    for (int HitN=0; HitN<SrcUrlRSet->GetHits(); HitN++){
493      if ((MxCands!=-1)&&(FCrawl->DstRSet->GetHits()>MxCands)){break;}
494      TStr HitUrlStr=SrcUrlRSet->GetHitUrlStr(HitN);
495      printf("Expand URL: %s\n", HitUrlStr.CStr());
496      PRSet RelUrlRSet=
497       TGg::WebSearch(TStr("related:")+HitUrlStr, -1, TNotify::NullNotify, ProxyStr);
498      FCrawl->DstRSet->Merge(RelUrlRSet);
499    }
500    TGgWebFetchSaver WebFetchSaver(100);
501    WebFetchSaver.PutProxyStr(ProxyStr);
502    {bool Ok; TStr MsgStr;
503    TWebFetchBlocking::GetWebPg(
504     SrcUrlStr, Ok, MsgStr, FCrawl->SrcWebPg, NULL, ProxyStr);
505    if (!Ok){FCrawl->SrcWebPg=NULL;}}
506    int FetchHits=FCrawl->DstRSet->GetHits();
507    if ((MxCands!=-1)&&(MxCands<FetchHits)){FetchHits=MxCands;}
508    for (int HitN=0; HitN<FetchHits; HitN++){
509      TStr HitUrlStr=FCrawl->DstRSet->GetHitUrlStr(HitN);
510      WebFetchSaver.FetchUrl(HitUrlStr);
511    }
512    TSysMsg::Loop();
513    for (int WebPgN=0; WebPgN<WebFetchSaver.GetWebPgs(); WebPgN++){
514      PWebPg WebPg=WebFetchSaver.GetWebPg(WebPgN);
515      FCrawl->UrlStrToWebPgH.AddDat(WebPg->GetUrlStr(), WebPg);
516    }
517    FCrawl->BowDocBs=TBowDocBs::New();
518    FCrawl->SrcDId=FCrawl->BowDocBs->AddHtmlDoc(
519     SrcUrlStr, TStrV(), FCrawl->SrcWebPg->GetHttpBodyAsStr());
520    for (int WebPgN=0; WebPgN<WebFetchSaver.GetWebPgs(); WebPgN++){
521      PWebPg WebPg=WebFetchSaver.GetWebPg(WebPgN);
522      FCrawl->BowDocBs->AddHtmlDoc(
523       WebPg->GetUrlStr(0), TStrV(), WebPg->GetHttpBodyAsStr());
524    }
525    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(FCrawl->BowDocBs, bwwtNrmTFIDF);
526    PBowSim BowSim=TBowSim::New(bstCos);
527    FCrawl->SimDIdKdV; FCrawl->SumSim=0;
528    for (int DIdN=0; DIdN<BowDocWgtBs->GetDocs(); DIdN++){
529      int DId=BowDocWgtBs->GetDId(DIdN);
530      if (DId!=FCrawl->SrcDId){
531        double Sim=BowSim->GetSim(
532         BowDocWgtBs->GetSpV(FCrawl->SrcDId), BowDocWgtBs->GetSpV(DId));
533        FCrawl->SimDIdKdV.Add(TFltIntKd(Sim, DId));
534        FCrawl->SumSim+=Sim;
535      }
536    }
537    FCrawl->SimDIdKdV.Sort(false);
538    FCrawl->Ok=true;
539    return FCrawl;
540  }
541  void TGgFCrawl::SaveXml(const TStr& FNm, const bool& SaveDocP){
542    if (!Ok){return;}
543    PSOut SOut=TFOut::New(FNm);
544    FILE* fOut=SOut->GetFileId();
545    fprintf(fOut, "<FocusedCrawl>\n");
546    fprintf(fOut, "  <SourceWebPage>\n");
547    fprintf(fOut, "    <Url>%s</Url>\n", SrcUrlStr.CStr());
548    if (SaveDocP){
549      THtmlDoc::SaveHtmlToXml(SrcWebPg->GetHttpBodyAsStr(), SOut,
550       SrcUrlStr, false, false, true, false, false);
551    }
552    fprintf(fOut, "  </SourceWebPage>\n");
553    fprintf(fOut, "  <FocusedWebPages>\n", SimDIdKdV.Len());
554    double SumSimSF=0;
555    for (int DIdN=0; DIdN<SimDIdKdV.Len(); DIdN++){
556      double Sim=SimDIdKdV[DIdN].Key;
557      SumSimSF+=Sim; if ((SumSim==0)||(SumSimSF>SumSim*0.99)){break;}
558      int DId=SimDIdKdV[DIdN].Dat;
559      TStr UrlStr=BowDocBs->GetDocNm(DId);
560      printf("%d. %.3f %s\n", 1+DIdN, Sim, UrlStr.CStr());
561      int HitN=DstRSet->GetHitN(UrlStr); IAssert(HitN!=-1);
562      fprintf(fOut, "    <WebPage Rank=\"%d\" Sim=\"%.3f\">\n", 1+DIdN, Sim, UrlStr.CStr());
563      fprintf(fOut, "      <Url>%s</Url>\n", UrlStr.CStr());
564      fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(DstRSet->GetHitTitleStr(HitN)).CStr());
565      fprintf(fOut, "      <Context>%s</Context>\n", TXmlLx::GetXmlStrFromPlainStr(DstRSet->GetHitCtxStr(HitN)).CStr());
566      if (SaveDocP){
567        PWebPg WebPg=UrlStrToWebPgH.GetDat(UrlStr);
568        THtmlDoc::SaveHtmlToXml(WebPg->GetHttpBodyAsStr(), SOut,
569         SrcUrlStr, false, false, true, false, false);
570      }
571      fprintf(fOut, "    </WebPage>\n");
572    }
573    printf("\n");
574    fprintf(fOut, "  </FocusedWebPages>\n");
575    fprintf(fOut, "</FocusedCrawl>\n");
576  }
577  void TGgFCrawl::SaveTxt(const TStr& FNm){
578    PSOut SOut=TFOut::New(FNm);
579    FILE* fOut=SOut->GetFileId();
580    if (Ok){
581      fprintf(fOut, "<SourceWebPage>\n");
582      fprintf(fOut, "%s\n", SrcUrlStr.CStr());
583      double SumSimSF=0;
584      for (int DIdN=0; DIdN<SimDIdKdV.Len(); DIdN++){
585        double Sim=SimDIdKdV[DIdN].Key;
586        SumSimSF+=Sim; if ((SumSim==0)||(SumSimSF>SumSim*0.99)){break;}
587        int DId=SimDIdKdV[DIdN].Dat;
588        TStr UrlStr=BowDocBs->GetDocNm(DId);
589        printf("%d. %.3f %s\n", 1+DIdN, Sim, UrlStr.CStr());
590        int HitN=DstRSet->GetHitN(UrlStr); IAssert(HitN!=-1);
591        TStr TitleStr=DstRSet->GetHitTitleStr(HitN);
592        TitleStr.ChangeChAll('\n', ' ');
593        TStr CtxStr=DstRSet->GetHitCtxStr(HitN);
594        CtxStr.ChangeChAll('\n', ' ');
595        fprintf(fOut, "<ResultWebPage>\n");
596        fprintf(fOut, "%s\n", UrlStr.CStr());
597        fprintf(fOut, "%s\n", TitleStr.CStr());
598        fprintf(fOut, "%s\n", CtxStr.CStr());
599      }
600    } else {
601      fprintf(fOut, "<Error>\n");
602    }
603    fprintf(fOut, "<End>\n");
604  }
605  PGgCtxGraph TGgCtxGraph::GetCtxGraph(const TStr& FocusUrlStr){
606    PGgCtxGraph CtxGraph=TGgCtxGraph::New();
607    CtxGraph->Ok=false;
608    CtxGraph->FocusUrlStr=FocusUrlStr;
609    {bool Ok; TStr MsgStr;
610    TWebFetchBlocking::GetWebPg(
611     CtxGraph->FocusUrlStr, Ok, MsgStr, CtxGraph->FocusWebPg, TNotify::StdNotify);
612    if (!Ok){return CtxGraph;}}
613    PRSet InRSet=
614     TGg::WebSearch(TStr("link:")+CtxGraph->FocusUrlStr, -1, TNotify::StdNotify);
615    for (int HitN=0; HitN<InRSet->GetHits(); HitN++){
616      TStr UrlStr; TStr TitleStr; TStr SrcNm; TStr CtxStr;
617      InRSet->GetHit(HitN, UrlStr, TitleStr, SrcNm, CtxStr);
618      TitleStr.ChangeChAll('\n', ' ');
619      CtxGraph->InUrlCtxStrPrV.Add(TStrPr(UrlStr, TitleStr));
620    }
621    TStrKdV OutDescUrlStrKdV;
622    CtxGraph->FocusWebPg->GetOutDescUrlStrKdV(OutDescUrlStrKdV);
623    for (int UrlN=0; UrlN<OutDescUrlStrKdV.Len(); UrlN++){
624      OutDescUrlStrKdV[UrlN].Key.ChangeChAll('\n', ' ');
625      CtxGraph->OutUrlCtxStrPrV.Add(
626       TStrPr(OutDescUrlStrKdV[UrlN].Dat, OutDescUrlStrKdV[UrlN].Key));
627    }
628    CtxGraph->Ok=true;
629    return CtxGraph;
630  }
631  void TGgCtxGraph::SaveTxt(const TStr& FNm){
632    PSOut SOut=TFOut::New(FNm);
633    FILE* fOut=SOut->GetFileId();
634    if (Ok){
635      fprintf(fOut, "<FocusWebPage>\n");
636      fprintf(fOut, "%s\n", FocusUrlStr.CStr());
637      for (int UrlN=0; UrlN<InUrlCtxStrPrV.Len(); UrlN++){
638        fprintf(fOut, "<InWebPage>\n");
639        fprintf(fOut, "%s\n", InUrlCtxStrPrV[UrlN].Val1.CStr());
640        fprintf(fOut, "%s\n", InUrlCtxStrPrV[UrlN].Val2.CStr());
641      }
642      for (int UrlN=0; UrlN<OutUrlCtxStrPrV.Len(); UrlN++){
643        fprintf(fOut, "<OutWebPage>\n");
644        fprintf(fOut, "%s\n", OutUrlCtxStrPrV[UrlN].Val1.CStr());
645        fprintf(fOut, "%s\n", OutUrlCtxStrPrV[UrlN].Val2.CStr());
646      }
647    } else {
648      fprintf(fOut, "<Error>\n");
649    }
650    fprintf(fOut, "<End>\n");
651  }
652  TStr TGg::GetWebSearchUrlStr(const TStr& QueryStr){
653    TStr SearchUrlStr=
654     "http:&bsol;&bsol;www.google.com/search?num=100&q="+
655     TUrl::GetUrlSearchStr(QueryStr);
656    return SearchUrlStr;
657  }
658  TStr TGg::GetNewsSearchUrlStr(const TStr& QueryStr){
659    TStr SearchUrlStr=
660     "http:&bsol;&bsol;news.google.com/news?num=100&q="+
661     TUrl::GetUrlSearchStr(QueryStr);
662    return SearchUrlStr;
663  }
664  TStr TGg::GetScholarSearchUrlStr(const TStr& QueryStr){
665    TStr SearchUrlStr=
666     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q="+
667     TUrl::GetUrlSearchStr(QueryStr);
668    return SearchUrlStr;
669  }
670  TStr TGg::GetScholarAuthorSearchUrlStr(const TStr& QueryStr){
671    TStr AuthorQueryStr=TStr("author:\"")+QueryStr+"\"";
672    TStr SearchUrlStr=
673     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q="+
674     TUrl::GetUrlSearchStr(AuthorQueryStr);
675    return SearchUrlStr;
676  }
677  TStr TGg::GetScholarPublicationSearchUrlStr(const TStr& QueryStr){
678    TStr PublicationQueryStr=TStr("\"")+QueryStr+"\"";
679    TStr SearchUrlStr=
680     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q=&as_publication="+
681     TUrl::GetUrlSearchStr(PublicationQueryStr);
682    return SearchUrlStr;
683  }
684  PRSet TGg::WebSearch(const TStr& QueryStr, const int& MxHits,
685   const PNotify& Notify, const TStr& ProxyStr){
686    TStr SearchUrlStr=TGg::GetWebSearchUrlStr(QueryStr);
687    bool Ok; TStr MsgStr; PWebPg WebPg;
688    TWebFetchBlocking::GetWebPg(
689     SearchUrlStr, Ok, MsgStr, WebPg, Notify, ProxyStr);
690    if (Ok){
691      PRSet RSet=TRSet::NewWeb(WebPg);
692      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
693      while (!NextSearchUrlStr.Empty()){
694        if ((MxHits!=-1)&&(RSet->GetHits()>=MxHits)){break;}
695        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
696        TWebFetchBlocking::GetWebPg(
697         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify, ProxyStr);
698        if (NextOk){
699          PRSet NextRSet=TRSet::NewWeb(NextWebPg);
700          RSet->Merge(NextRSet);
701          NextSearchUrlStr=NextRSet->GetNextUrlStr();
702        } else {
703          NextSearchUrlStr="";
704        }
705      }
706      RSet->Trunc(MxHits);
707      RSet->PutQueryStr(QueryStr);
708      return RSet;
709    } else {
710      return TRSet::New();
711    }
712  }
713  PRSet TGg::WebSearchExternal(
714   const TStr& QueryStr, const int& MxHits, const PNotify& Notify, const TStr& ProxyStr){
715    TStr ExeFPath=Env.GetExeFPath();
716    TStr ExeFNm=TStr::GetNrFPath(ExeFPath)+"Google2RSet.exe";
717    TStr RSetFNm=TStr::GetNrFPath(ExeFPath)+TTm::GetCurUniTm().GetIdStr()+".RSet";
718    TStr CmLn=
719     TStr::GetStr(QueryStr, " -iwq:%s")+
720     TInt::GetStr(MxHits, " -hits:%d")+
721     TStr::GetStr(RSetFNm, " -obin:\"%s\" -oxml: -obow: -ssilent")+
722     TStr::GetStr(ProxyStr, " -proxy:%s");
723    if (TSysProc::ExeProc(ExeFNm, CmLn)){
724      PRSet RSet;
725      {TFIn RSetFIn(RSetFNm);
726      RSet=TRSet::Load(RSetFIn);}
727      TFile::Del(RSetFNm);
728      return RSet;
729    } else {
730      return TRSet::New();
731    }
732  }
733  #ifdef MIHA_BLAZ_DOTNET_PROXY
734  PRSet TGg::WebSearchProxy(const TStr& QueryStr, const int& MxHits,
735   const PNotify& Notify, const TStr& ProxyStr){
736    TStr SearchUrlStr=TGg::GetWebSearchUrlStr(QueryStr);
737    char* WebPgHtmlCStr = fetchWebPage(SearchUrlStr.CStr(), ProxyStr.CStr());
738    TStr WebPgHtmlStr = TStr(WebPgHtmlCStr); GlobalFree(WebPgHtmlCStr);
739    bool Ok = (WebPgHtmlCStr != NULL);
740    if (Ok){
741      PRSet RSet=TRSet::NewWeb(SearchUrlStr, WebPgHtmlStr);
742      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
743      while (!NextSearchUrlStr.Empty()){
744        if ((MxHits!=-1)&&(RSet->GetHits()>=MxHits)){break;}
745        char* NextWebPgHtmlCStr = fetchWebPage(NextSearchUrlStr.CStr(), ProxyStr.CStr());
746        TStr NextWebPgHtmlStr = TStr(NextWebPgHtmlCStr); GlobalFree(NextWebPgHtmlCStr);
747        bool NextOk = (NextWebPgHtmlCStr != NULL);
748        if (NextOk){
749          PRSet NextRSet=TRSet::NewWeb(NextSearchUrlStr, NextWebPgHtmlStr);
750          RSet->Merge(NextRSet);
751          NextSearchUrlStr=NextRSet->GetNextUrlStr();
752        } else {
753          NextSearchUrlStr="";
754        }
755      }
756      RSet->Trunc(MxHits);
757      RSet->PutQueryStr(QueryStr);
758      return RSet;
759    } else {
760      return TRSet::New();
761    }
762  }
763  #endif
764  PRSet TGg::NewsSearch(const TStr& QueryStr, const PNotify& Notify){
765    TStr SearchUrlStr=TGg::GetNewsSearchUrlStr(QueryStr);
766    bool Ok; TStr MsgStr; PWebPg WebPg;
767    TWebFetchBlocking::GetWebPg(
768     SearchUrlStr, Ok, MsgStr, WebPg, Notify);
769    if (Ok){
770      PRSet RSet=TRSet::NewNews(WebPg);
771      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
772      while (!NextSearchUrlStr.Empty()){
773        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
774        TWebFetchBlocking::GetWebPg(
775         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify);
776        if (NextOk){
777          PRSet NextRSet=TRSet::NewNews(NextWebPg);
778          RSet->Merge(NextRSet);
779          NextSearchUrlStr=NextRSet->GetNextUrlStr();
780        } else {
781          NextSearchUrlStr="";
782        }
783      }
784      return RSet;
785    } else {
786      return TRSet::New();
787    }
788  }
789  PGgSchRSet TGg::_ScholarSearch(
790   const TStr& SearchUrlStr, const PNotify& Notify){
791    bool Ok; TStr MsgStr; PWebPg WebPg;
792    TWebFetchBlocking::GetWebPg(
793     SearchUrlStr, Ok, MsgStr, WebPg, Notify);
794    if (Ok){
795      PGgSchRSet GgSchRSet=TGgSchRSet::NewScholar(WebPg);
796      TStr NextSearchUrlStr=GgSchRSet->GetNextUrlStr();
797      TRnd Rnd(0);
798      while (!NextSearchUrlStr.Empty()){
799        int WaitMSecs=int(1*1000*(Rnd.GetUniDev()+0.5));
800        TSysProc::Sleep(WaitMSecs);
801        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
802        TWebFetchBlocking::GetWebPg(
803         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify);
804        if (NextOk){
805          PGgSchRSet NextRSet=TGgSchRSet::NewScholar(NextWebPg);
806          GgSchRSet->Merge(NextRSet);
807          NextSearchUrlStr=NextRSet->GetNextUrlStr();
808        } else {
809          NextSearchUrlStr="";
810        }
811      }
812      return GgSchRSet;
813    } else {
814      return TGgSchRSet::New();
815    }
816  }
817  PGgSchRSet TGg::ScholarSearch(const TStr& QueryStr, const PNotify& Notify){
818    TStr SearchUrlStr=GetScholarSearchUrlStr(QueryStr);
819    return _ScholarSearch(SearchUrlStr, Notify);
820  }
821  PGgSchRSet TGg::ScholarAuthorSearch(const TStr& AuthorNm, const PNotify& Notify){
822    TStr SearchUrlStr=GetScholarAuthorSearchUrlStr(AuthorNm);
823    return _ScholarSearch(SearchUrlStr, Notify);
824  }
825  PGgSchRSet TGg::ScholarPublicationSearch(const TStr& PublicationNm, const PNotify& Notify){
826    TStr SearchUrlStr=GetScholarPublicationSearchUrlStr(PublicationNm);
827    return _ScholarSearch(SearchUrlStr, Notify);
828  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-demo-gio.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-googlex.cpp</div>
                </div>
                <div class="column column_space"><pre><code>121    for (TUNGraph::TNodeI NI = GOut->BegNI(); NI < GOut->EndNI(); NI++) {
122      fprintf(F, "%s", OutNIdStrH[NI.GetId()].CStr());
123      for (int e = 0; e < NI.GetOutDeg(); e++) {
124        fprintf(F, " %s", OutNIdStrH[NI.GetOutNId(e)].CStr());
</pre></code></div>
                <div class="column column_space"><pre><code>158    PBowDocBs BowDocBs=TBowDocBs::New();
159    BowDocBs->PutNGramBs(NGramBs);
160    for (int HitN=0; HitN<GetHits(); HitN++){
161      BowDocBs->AddHtmlDoc(TInt::GetStr(HitN), TStrV(), HtmlStrV[HitN]);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    