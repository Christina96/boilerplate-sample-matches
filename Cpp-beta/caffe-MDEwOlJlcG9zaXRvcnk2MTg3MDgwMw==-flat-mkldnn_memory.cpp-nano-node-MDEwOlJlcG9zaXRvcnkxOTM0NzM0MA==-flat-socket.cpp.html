
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.1417270929466055%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_memory.cpp</h3>
            <pre><code>1  #ifdef MKLDNN_SUPPORTED
2  #include "caffe/mkldnn_memory.hpp"
3  #include "caffe/util/performance.hpp"
4  namespace caffe {
5  template <typename Dtype>
6  MKLDNNMemoryDescriptorBase<Dtype>::MKLDNNMemoryDescriptorBase(shared_ptr<memory::primitive_desc> usr_memory_pd
7                                                              , shared_ptr<memory::primitive_desc> prv_memory_pd
8                                                              , Blob<Dtype>* blob
9                                                              , MKLDNNLayer<Dtype>* mkldnn_layer
10                                                              , std::vector<float> scale
11                                                              , int mask
12                                                              , bool is_sum
13                                                              , bool is_wino
14                                                              , bool is_weight
15                                                              , std::string _name)
16                                      : _reorder_usr2prv_pd(), _reorder_prv2usr_pd(), _reorder_extprv2prv_pd()
17                                      ,_prv_memory(), _internal_ptr(NULL), _usr_memory(), _cpu_ptr(NULL)
18                                      , _mkldnn_layer(NULL), _is_weight(is_weight)
19  {
20      set_usr_memory_pd(usr_memory_pd, scale);
21      set_prv_memory_pd(prv_memory_pd, scale, mask, is_wino, is_weight);
22      set_mkldnn_layer(mkldnn_layer);
23      this->set_scale(scale);
24      this->set_sum(is_sum);
25      this->_blob = blob;
26      this->name.assign(_name);
27  }
28  template <typename Dtype>
29  void MKLDNNMemoryDescriptorBase<Dtype>::check_usr_with_prv_descriptors()
30  {
31      CHECK(_usr_memory_pd);
32      CHECK(_prv_memory_pd);
33      int32_t ndims = _usr_memory_pd->desc().data.ndims;
34      CHECK_EQ(ndims, _prv_memory_pd->desc().data.ndims)
35              << "MKLDNNMemoryDescriptorBase: Usr and Prv memory must have same dimensions number";
36      for (int32_t dim = 0; dim < ndims; ++dim) {
37          CHECK_EQ(_usr_memory_pd->desc().data.dims[dim]
38                  , _prv_memory_pd->desc().data.dims[dim])
39                  << "MKLDNNMemoryDescriptorBase: Usr and Prv memory must have same dimensions";
40      }
41  }
42  template <typename Dtype>
<span onclick='openModal()' class='match'>43  void MKLDNNMemoryDescriptorBase<Dtype>::create_reorder_descriptors(std::vector<float> scale, int mask, std::vector<float> scale_ext, bool is_sum, bool is_wino, bool is_weight)
44  {
45      CHECK(_usr_memory_pd);
46      CHECK(_prv_memory_pd);
47      primitive_attr attri;
48      int count = scale.size();
</span>49      if ( *_usr_memory_pd != *_prv_memory_pd) {
50          std::vector<float> scales_u2p(count);
51          #ifdef _OPENMP
52          #pragma omp parallel for if (count > 1)
53          #endif
54          for(int i=0; i < count; i++){
55              scales_u2p[i] = scale[i];
56          }
57          attri.set_output_scales(mask, scales_u2p);
58          attri.set_int_output_round_mode(round_nearest);
59          _reorder_usr2prv_pd = shared_ptr<reorder::primitive_desc>(
60                  new reorder::primitive_desc(*_usr_memory_pd, *_prv_memory_pd, attri));
61          std::vector<float> scales_p2u(count);
62          #ifdef _OPENMP
63          #pragma omp parallel for if (count > 1)
64          #endif
65          for(int i=0; i < count; i++){
66              scales_p2u[i] = (1. / scale[i]);
67          }
68          attri.set_output_scales(mask, scales_p2u); 
69          attri.set_int_output_round_mode(round_nearest);
70          if(!is_wino && !is_weight){
71              _reorder_prv2usr_pd = shared_ptr<reorder::primitive_desc>(
72                      new reorder::primitive_desc(*_prv_memory_pd, *_usr_memory_pd, attri));
73          }
74      }
75      if ( _extprv_memory_pd && (*_prv_memory_pd != *_extprv_memory_pd || scale != scale_ext)) {
76          if(is_sum == true && scale == scale_ext && _extprv_memory_pd->desc().data.data_type == memory::data_type::s8 && _prv_memory_pd->desc().data.data_type == memory::data_type::u8){
77  #ifdef DEBUG
78              LOG(INFO) << "skip s8 to u8 reorder....";
79  #endif
80              _reorder_extprv2prv_pd = NULL;
81          }else{
82              std::vector<float> scales_e2p(count);
83              float shift_scale;
84              #ifdef _OPENMP
85              #pragma omp parallel for if (count > 1)
86              #endif
87              for(int i=0; i < count; i++){
88                  shift_scale = scale[i] / scale_ext[i]; 
89                  scales_e2p[i] = shift_scale;
90              }
91              attri.set_output_scales(mask, scales_e2p);
92              attri.set_int_output_round_mode(round_nearest);
93              _reorder_extprv2prv_pd = shared_ptr<reorder::primitive_desc>(new reorder::primitive_desc(*_extprv_memory_pd, *_prv_memory_pd, attri));
94          }
95      }
96  }
97  template <typename Dtype, bool is_diff>
98   MKLDNNMemoryDescriptor<Dtype, is_diff>::MKLDNNMemoryDescriptor(shared_ptr<memory::primitive_desc> usr_memory_pd
99                          , shared_ptr<memory::primitive_desc> prv_memory_pd
100                          , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
101                          , std::vector<float> scale
102                          , int mask
103                          , bool is_sum
104                          , bool is_wino
105                          , bool is_weight
106                          , std::string name)
107          : MKLDNNMemoryDescriptorBase<Dtype>(usr_memory_pd, prv_memory_pd, blob, mkldnn_layer, scale, mask, is_sum, is_wino, is_weight, name)
108  {
109      const Dtype* prv_ptr = is_diff ?  blob->prv_diff() : blob->prv_data();
110      if (prv_ptr != NULL) {
111          shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > blob_prv_mkldnn_mem_descr = get_mkldnn_prv_descriptor<Dtype, is_diff>(blob);
112  #ifdef DEBUG        
113          LOG(INFO) << "Format of blob-prv-memory-pd: " << blob_prv_mkldnn_mem_descr->prv_memory_pd()->desc().data.format;
114          LOG(INFO) << "Format of this-prv-memory-pd: " << this->prv_memory_pd()->desc().data.format;
115  #endif
116          if (blob_prv_mkldnn_mem_descr->prv_memory_pd()->desc().data.format !=  this->prv_memory_pd()->desc().data.format || blob_prv_mkldnn_mem_descr->prv_memory_pd()->desc().data.data_type !=  this->prv_memory_pd()->desc().data.data_type || blob_prv_mkldnn_mem_descr->get_scale() != this->get_scale()) {
117  #ifdef DEBUG
118              LOG(INFO) << "Formats of blob-prv-memory-pd and this-prv-memory-pd are not equal !";
119  #endif
120              if (!is_wino)
121                this->set_extprv_memory_pd(blob_prv_mkldnn_mem_descr->prv_memory_pd(), scale, blob_prv_mkldnn_mem_descr->get_scale(), blob_prv_mkldnn_mem_descr->get_sum());
122              else
123                if (is_diff) blob->mutable_cpu_diff(); else blob->mutable_cpu_data();
124          }
125      }
126  }
127  template <typename Dtype, bool is_diff>
128  void MKLDNNMemoryDescriptor<Dtype, is_diff>::create_reorder_to_prv(void* cpu_ptr)
129  {
130      CHECK(cpu_ptr);
131      CHECK(this->_usr_memory_pd);
132      CHECK(this->_prv_memory_pd);
133      CHECK(this->_reorder_usr2prv_pd);
134      if(this->_usr_memory == NULL || this->_cpu_ptr != cpu_ptr)
135          this->_usr_memory.reset(new memory(*this->_usr_memory_pd, cpu_ptr));
136      if(this->_reorder_usr2prv.aprimitive == NULL || this->_cpu_ptr != cpu_ptr)
137          this->_reorder_usr2prv.reset(new reorder(*this->_reorder_usr2prv_pd, *this->_usr_memory, *this->get_prv_memory()));
138      this->_cpu_ptr = cpu_ptr;
139  }
140  template <typename Dtype, bool is_diff>
141  void MKLDNNMemoryDescriptor<Dtype, is_diff>::convert_to_prv(void* cpu_ptr)
142  {
143  #ifdef DEBUG
144      LOG(INFO) << "--- MKLDNNMemoryDescriptorBase<Dtype>::convert_to_prv --- " << this->name;
145  #endif
146      create_reorder_to_prv(cpu_ptr);
147      VLOG(1) << "--- MKLDNNMemoryDescriptorBase<Dtype>::convert_to_prv --- " << this->name;
148  #ifdef DEBUG
149      LOG(INFO) << "Reorder: from usr to prv.";
150      LOG(INFO) << "Format of _usr_memory_pd: " << this->_usr_memory_pd->desc().data.format << "   Data_type of _usr_memory_pd: " << this->_usr_memory_pd->desc().data.data_type;
151      LOG(INFO) << "Format of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.format << "   Data_type of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.data_type;
152  #endif
153      PERFORMANCE_MEASUREMENT_BEGIN();
154      this->_reorder_usr2prv.submit();
155      PERFORMANCE_MEASUREMENT_END_STATIC("mkldnn_conversion");
156  }
157  #ifdef CO_SIM
158  template <typename Dtype, bool is_diff>
159  void MKLDNNMemoryDescriptor<Dtype, is_diff>::convert_from_prv_cosim(void* cpu_ptr_cosim)
160  {
161      if(this->_reorder_prv2usr_pd == NULL)
162          return;
163      create_reorder_from_prv_cosim(cpu_ptr_cosim);
164      this->_reorder_prv2usr_cosim.submit();
165  }
166  template <typename Dtype, bool is_diff>
167  void MKLDNNMemoryDescriptor<Dtype, is_diff>::create_reorder_from_prv_cosim(void* cpu_ptr_cosim)
168  {
169      CHECK(cpu_ptr_cosim);
170      CHECK(this->_usr_memory_pd);
171      CHECK(this->_prv_memory_pd);
172      CHECK(this->_reorder_prv2usr_pd);
173      this->_usr_memory_cosim = this->_usr_memory;
174      this->_reorder_prv2usr_cosim.aprimitive = this->_reorder_prv2usr.aprimitive;
175      this->_prv_memory_cosim.reset(new memory(*this->_prv_memory_pd));
176      memcpy(this->_prv_memory_cosim->get_data_handle(), this->get_prv_ptr(), this->prv_size());
177      this->at_prv_cosim.reset(new primitive::at(*this->_prv_memory_cosim));
178      if(this->_usr_memory == NULL || this->_cpu_ptr != cpu_ptr_cosim)
179          this->_usr_memory_cosim.reset(new memory(*this->_usr_memory_pd, cpu_ptr_cosim));
180      if(this->_reorder_prv2usr.aprimitive == NULL || this->_cpu_ptr != cpu_ptr_cosim){
181          this->_reorder_prv2usr_cosim.aprimitive.reset(new reorder(*this->_reorder_prv2usr_pd, *this->at_prv_cosim, *this->_usr_memory_cosim));
182      }
183  }
184  #endif
185  template <typename Dtype, bool is_diff>
186  void MKLDNNMemoryDescriptor<Dtype, is_diff>::create_reorder_from_prv(void* cpu_ptr)
187  {
188      CHECK(cpu_ptr);
189      CHECK(this->_usr_memory_pd);
190      CHECK(this->_prv_memory_pd);
191      CHECK(this->_reorder_prv2usr_pd);
192      if(this->_usr_memory == NULL || this->_cpu_ptr != cpu_ptr)
193          this->_usr_memory.reset(new memory(*this->_usr_memory_pd, cpu_ptr));
194      if(this->_reorder_prv2usr.aprimitive == NULL || this->_cpu_ptr != cpu_ptr) {
195          CHECK(this->aprimitive());
196          this->_reorder_prv2usr.aprimitive.reset(new reorder(*this->_reorder_prv2usr_pd, *this->aprimitive(), *this->_usr_memory));
197      }
198      this->_cpu_ptr = cpu_ptr;
199  }
200  template <typename Dtype, bool is_diff>
201  void MKLDNNMemoryDescriptor<Dtype, is_diff>::convert_from_prv(void* cpu_ptr)
202  {
203  #ifdef DEBUG
204      LOG(INFO) << "--- MKLDNNMemoryDescriptorBase<Dtype>::convert_from_prv --- " << this->name;
205  #endif
206      CHECK(cpu_ptr);
207      if(this->_reorder_prv2usr_pd == NULL)
208          return;
209      create_reorder_from_prv(cpu_ptr);
210      VLOG(1) << "--- MKLDNNMemoryDescriptorBase<Dtype>::convert_from_prv --- " << this->name;
211  #ifdef DEBUG
212      LOG(INFO) << "Reorder: from prv to usr.";
213      LOG(INFO) << "Format of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.format;
214      LOG(INFO) << "Format of _usr_memory_pd: " << this->_usr_memory_pd->desc().data.format;
215      LOG(INFO) << "Format of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.format << "   Data_type of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.data_type;
216      LOG(INFO) << "Format of _usr_memory_pd: " << this->_usr_memory_pd->desc().data.format << "   Data_type of _usr_memory_pd: " << this->_usr_memory_pd->desc().data.data_type;
217  #endif
218      PERFORMANCE_MEASUREMENT_BEGIN();
219      this->_reorder_prv2usr.submit();
220      PERFORMANCE_MEASUREMENT_END_STATIC("mkldnn_conversion");
221  }
222  template <typename Dtype, bool is_diff>
223  void MKLDNNMemoryDescriptor<Dtype, is_diff>::create_reorder_from_extprv(shared_ptr<primitive> aprimitive)
224  {
225      CHECK(aprimitive);
226      CHECK(this->_extprv_memory_pd);
227      CHECK(this->_prv_memory_pd);
228      CHECK(this->_reorder_extprv2prv_pd);
229      if(this->_reorder_extprv2prv.aprimitive == NULL)
230          this->_reorder_extprv2prv.reset(new reorder(*this->_reorder_extprv2prv_pd, *aprimitive, *this->get_prv_memory()));
231  }
232  template <typename Dtype, bool is_diff>
233  void MKLDNNMemoryDescriptor<Dtype, is_diff>::convert_from_extprv(shared_ptr<primitive> aprimitive)
234  {
235  #ifdef DEBUG
236      LOG(INFO) << "--- MKLDNNMemoryDescriptorBase<Dtype>::convert_from_extprv --- " << this->name;
237  #endif
238      CHECK(aprimitive);
239      if(this->_reorder_extprv2prv_pd == NULL)
240          return;
241      create_reorder_from_extprv(aprimitive);
242      VLOG(1) << "--- MKLDNNMemoryDescriptorBase<Dtype>::convert_from_extprv --- " << this->name;
243  #ifdef DEBUG
244      LOG(INFO) << "Reorder: from extprv to prv.";
245      LOG(INFO) << "Format of _extprv_memory_pd: " << this->_extprv_memory_pd->desc().data.format << "   Data_type of _extprv_memory_pd: " << this->_extprv_memory_pd->desc().data.data_type;
246      LOG(INFO) << "Format of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.format<< "   Data_type of _prv_memory_pd: " << this->_prv_memory_pd->desc().data.data_type;
247  #endif
248      PERFORMANCE_MEASUREMENT_BEGIN();
249      this->_reorder_extprv2prv.submit();
250      void* prv_mem = this->get_prv_memory()->get_data_handle();
251      if(prv_mem) {
252        CircleBuf::Instance()->DecRefCnt(prv_mem);
253      } 
254      PERFORMANCE_MEASUREMENT_END_STATIC("mkldnn_conversion");
255  }
256  template <typename Dtype, bool is_diff>
257  bool MKLDNNMemoryDescriptor<Dtype, is_diff>::on_to_cpu()
258  {
259      CHECK(this->mkldnn_layer());
260      if (StreamHolder::Instance().current_stream() != NULL && StreamHolder::Instance().current_stream()->ready()) {
261          VLOG(1) << "- MKLDNNMemoryDescriptorBase<Dtype>::" << __FUNCTION__ << ": stream.wait() - " << this->name;
262          StreamHolder::Instance().current_stream()->wait();
263      }
264      return true;
265  }
266  template <typename Dtype>
267  bool MKLDNNMemoryDescriptorBase<Dtype>::layout_compare(shared_ptr<PrvMemDescr> other)
268  {
269      CHECK_EQ(other->get_descr_type(),
270                PrvMemDescr::PRV_DESCR_MKLDNN);
271      shared_ptr<MKLDNNMemoryDescriptorBase<Dtype> > other_descr =
272          boost::static_pointer_cast<MKLDNNMemoryDescriptorBase<Dtype> >(other);
273      return (*other_descr->prv_memory_pd() == *this->prv_memory_pd());
274  }
275  template <typename Dtype>
276  void MKLDNNMemoryDescriptorBase<Dtype>::convert_from_other(shared_ptr<PrvMemDescr> other)
277  {
278      NOT_IMPLEMENTED;
279  }
280  template <typename Dtype, bool is_diff>
281  shared_ptr<primitive> MKLDNNMemoryDescriptor<Dtype, is_diff>::get_blob_prv_primitive(Blob<Dtype>* blob
282                                              ,bool set_prv_ptr, bool convert
283                                              ,MKLDNNMemoryDescriptor<Dtype,is_diff>* converted_in_fwd)
284  {
285  #ifdef DEBUG        
286      LOG(INFO) << "GET_BLOB_PRV_PRIMITIVE";
287  #endif
288      if (!this->conversion_needed()) {
289          return shared_ptr<primitive>(); 
290      }
291      const Dtype* prv_ptr = is_diff ?  blob->prv_diff() : blob->prv_data();
292      if (prv_ptr == NULL) {
293          if (converted_in_fwd) {
294              NOT_IMPLEMENTED;
295          }
296          if(convert) {
297              this->convert_to_prv(const_cast<Dtype*>(is_diff ? blob->cpu_diff() : blob->cpu_data()));
298          }
299          else {
300              this->create_reorder_to_prv(const_cast<Dtype*>(is_diff ? blob->cpu_diff() : blob->cpu_data()));
301          }
302          if (set_prv_ptr) {
303              if (is_diff) {
304                  blob->set_prv_diff_descriptor(this->get_shared_ptr(), false);
305                  blob->set_prv_diff_descriptor(NULL);
306              } else {
307                  blob->set_prv_data_descriptor(this->get_shared_ptr(), false);
308                  blob->set_prv_data_descriptor(NULL);
309              }
310          }
311          return this->reorder_usr2prv();
312      } else {
313          shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > blob_prv_mkldnn_mem_descr = get_mkldnn_prv_descriptor<Dtype, is_diff>(blob);
314          if ((*blob_prv_mkldnn_mem_descr->prv_memory_pd() !=  *this->prv_memory_pd() || blob_prv_mkldnn_mem_descr->get_scale() != this->get_scale()) && this->_reorder_extprv2prv_pd != NULL) {
315              if(convert) {
316                  LOG(INFO) << "BAD CONVERT";
317                  this->convert_from_extprv(blob_prv_mkldnn_mem_descr->aprimitive());
318              }
319              else {
320                  this->create_reorder_from_extprv(blob_prv_mkldnn_mem_descr->aprimitive());
321              }
322              return this->reorder_extprv2prv();
323          } else if (blob_prv_mkldnn_mem_descr.get() != this) {
324              VLOG(1) << "layout OK " << blob_prv_mkldnn_mem_descr->name << " == " << this->name;
325          }
326          return blob_prv_mkldnn_mem_descr->aprimitive();
327      }
328      NOT_IMPLEMENTED;
329      return shared_ptr<mkldnn::primitive>();
330  }
331  template <typename Dtype, bool is_diff>
332  void MKLDNNMemoryDescriptor<Dtype, is_diff>::sync_before_read()
333  {
334  #ifdef DEBUG        
335      LOG(INFO) << "SYNC_BEFORE_READ";
336  #endif
337      if (!this->conversion_needed()) {
338          return;
339      }
340      const Dtype* prv_ptr = is_diff ?  this->_blob->prv_diff() : this->_blob->prv_data();
341      if (prv_ptr == NULL) {
342          this->convert_to_prv(const_cast<Dtype*>(is_diff ? this->_blob->cpu_diff() : this->_blob->cpu_data()));
343          if (is_diff) {
344              this->_blob->set_prv_diff_descriptor(this->get_shared_ptr(), false);
345          } else {
346              this->_blob->set_prv_data_descriptor(this->get_shared_ptr(), true);     
347          }
348      } else {
349          shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > blob_prv_mkldnn_mem_descr = get_mkldnn_prv_descriptor<Dtype, is_diff>(this->_blob);
350          if (*blob_prv_mkldnn_mem_descr->prv_memory_pd() !=  *this->prv_memory_pd() || blob_prv_mkldnn_mem_descr->get_scale() != this->get_scale()) {
351  #ifdef DEBUG
352          LOG(INFO) << "Convert from extprv";
353  #endif
354              this->convert_from_extprv(blob_prv_mkldnn_mem_descr->aprimitive());
355          } else {
356              if (is_diff) {
357                  this->_blob->mutable_prv_diff();
358              } else {
359                  this->_blob->mutable_prv_data();
360              }
361          }
362      }
363  }
364  template <typename Dtype, bool is_diff>
365  void MKLDNNMemoryDescriptor<Dtype, is_diff>::sync_before_write(bool inplace)
366  {
367      if(!inplace) {
368          if(is_diff) {
369              this->_blob->set_prv_diff_descriptor(this->get_shared_ptr(), this->conversion_needed() ? false : true);
370          } else {
371              this->_blob->set_prv_data_descriptor(this->get_shared_ptr(), this->conversion_needed() ? false : true);
372          }
373      }
374  }
375  template <typename Dtype, bool is_diff>
376  shared_ptr<primitive> MKLDNNMemoryDescriptor<Dtype, is_diff>::create_input(Blob<Dtype> * blob, bool set_prv_ptr)
377  {
378      shared_ptr<mkldnn::primitive> pres;
379      if (this->conversion_needed()) {
380          pres = this->get_blob_prv_primitive(blob, set_prv_ptr, false);
381      } else {
382          pres.reset(new memory(*this->usr_memory_pd(), const_cast<Dtype*>(is_diff ?  blob->cpu_diff() : blob->cpu_data())));
383      }
384      return pres;
385  }
386  template <typename Dtype, bool is_diff>
387  shared_ptr<memory> MKLDNNMemoryDescriptor<Dtype, is_diff>::create_output_memory(Blob<Dtype> * blob, bool inplace)
388  {
389      shared_ptr<memory> omem;
390      if (this->conversion_needed()) {
391          shared_ptr<PrvMemDescr> blob_prv_mem_descriptor = is_diff ?
392              (blob->get_prv_diff_descriptor()) : (blob->get_prv_data_descriptor());
393          if(blob_prv_mem_descriptor != NULL) {
394              shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > current_descr = get_mkldnn_prv_descriptor<Dtype, is_diff>(blob);
395              omem = current_descr->get_prv_memory();
396              this->set_prv_memory(omem);
397          } else {
398              omem = this->get_prv_memory();
399          }
400      } else {
401          omem.reset(new memory(*this->usr_memory_pd(), is_diff ? blob->mutable_cpu_diff() : blob->mutable_cpu_data()));
402      }
403      return omem;
404  }
405  template <typename Dtype, bool is_diff>
406  shared_ptr<primitive> MKLDNNMemoryDescriptor<Dtype, is_diff>::create_input(bool set_prv_ptr)
407  {
408      return create_input(this->_blob, set_prv_ptr);
409  }
410  template <typename Dtype, bool is_diff>
411  shared_ptr<memory> MKLDNNMemoryDescriptor<Dtype, is_diff>::create_output_memory(bool inplace)
412  {
413      shared_ptr<memory> omem = create_output_memory(this->_blob);
414      if(!inplace) {
415          if(is_diff) {
416              this->_blob->set_prv_diff_descriptor(this->get_shared_ptr(), this->conversion_needed() ? false : true);
417          } else {
418              this->_blob->set_prv_data_descriptor(this->get_shared_ptr(), this->conversion_needed() ? false : true);
419          }
420      }
421      return omem;
422  }
423  template <typename Dtype, bool is_diff>
424  Dtype* MKLDNNMemoryDescriptor<Dtype, is_diff>::get_memory_ptr(long offset) {
425      if (this->conversion_needed()) {
426        if (this->prv_ptr() != NULL) return (Dtype*)this->prv_ptr() + offset;
427        else return is_diff ?
428               (Dtype*)this->_blob->prv_diff() + offset :
429               (Dtype*)this->_blob->prv_data() + offset;
430      } else {
431        return const_cast<Dtype*>(
432          is_diff ? this->_blob->cpu_diff() + offset : this->_blob->cpu_data() + offset);
433      }
434  }
435  template <typename Dtype, bool is_diff>
436  shared_ptr<memory::desc> MKLDNNMemoryDescriptor<Dtype, is_diff>::get_memory_desc() {
437      shared_ptr<memory::desc> desc;
438      if (this->conversion_needed()) {
439          desc.reset(new memory::desc(this->prv_memory_pd()->desc()));
440      } else {
441          desc.reset(new memory::desc(this->usr_memory_pd()->desc()));
442      }
443      return desc;
444  }
445  template <typename Dtype, bool is_diff>
446  size_t MKLDNNMemoryDescriptor<Dtype, is_diff>::get_memory_count() {
447    if (this->conversion_needed()) {
448      return this->prv_count();
449    } else {
450      return this->_blob->count();
451    }
452  }
453  template <typename Dtype, bool is_diff>
454  shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > get_mkldnn_prv_descriptor(Blob<Dtype>* blob)
455  {
456      shared_ptr<PrvMemDescr> blob_prv_mem_descriptor = is_diff ?
457              (blob->get_prv_diff_descriptor()) : (blob->get_prv_data_descriptor());
458      CHECK_EQ(blob_prv_mem_descriptor->get_descr_type(), PrvMemDescr::PRV_DESCR_MKLDNN);
459      shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > blob_prv_mkldnn_mem_descr =
460              boost::static_pointer_cast<MKLDNNMemoryDescriptor<Dtype, is_diff> >(blob_prv_mem_descriptor);
461      CHECK(blob_prv_mkldnn_mem_descr != NULL);
462      return blob_prv_mkldnn_mem_descr;
463  }
464  template class MKLDNNMemoryDescriptor<double, true>;
465  template class MKLDNNMemoryDescriptor<float, true>;
466  template class MKLDNNMemoryDescriptor<float, false>;
467  template class MKLDNNMemoryDescriptor<double, false>;
468  template class MKLDNNMemoryDescriptorBase<float>;
469  template class MKLDNNMemoryDescriptorBase<double>;
470  template
471  shared_ptr<MKLDNNMemoryDescriptor<double, true> > get_mkldnn_prv_descriptor<double, true>(Blob<double>* blob);
472  template
473  shared_ptr<MKLDNNMemoryDescriptor<float, true> > get_mkldnn_prv_descriptor<float, true>(Blob<float>* blob);
474  template
475  shared_ptr<MKLDNNMemoryDescriptor<double, false> > get_mkldnn_prv_descriptor<double, false>(Blob<double>* blob);
476  template
477  shared_ptr<MKLDNNMemoryDescriptor<float, false> > get_mkldnn_prv_descriptor<float, false>(Blob<float>* blob);
478  }  
479  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.cpp</h3>
            <pre><code>1  #include <nano/boost/asio/ip/address_v6.hpp>
2  #include <nano/boost/asio/ip/network_v6.hpp>
3  #include <nano/lib/threading.hpp>
4  #include <nano/node/transport/socket.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  #include <boost/asio/read.hpp>
9  #include <map>
10  #include <memory>
11  #include <utility>
12  #include <vector>
13  using namespace std::chrono_literals;
14  TEST (socket, max_connections)
15  {
16  	nano::test::system system;
17  	auto node = system.add_node ();
18  	auto server_port = system.get_available_port ();
19  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
20  	auto server_socket = std::make_shared<nano::transport::server_socket> (*node, listen_endpoint, 2);
21  	boost::system::error_code ec;
22  	server_socket->start (ec);
23  	ASSERT_FALSE (ec);
24  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket->listening_port () };
25  	std::vector<std::shared_ptr<nano::transport::socket>> server_sockets;
26  	server_socket->on_connection ([&server_sockets] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
27  		server_sockets.push_back (new_connection);
28  		return true;
29  	});
30  	std::atomic<size_t> connection_attempts = 0;
31  	auto connect_handler = [&connection_attempts] (boost::system::error_code const & ec_a) {
32  		ASSERT_EQ (ec_a.value (), 0);
33  		++connection_attempts;
34  	};
35  	auto client1 = std::make_shared<nano::transport::client_socket> (*node);
36  	client1->async_connect (dst_endpoint, connect_handler);
37  	auto client2 = std::make_shared<nano::transport::client_socket> (*node);
38  	client2->async_connect (dst_endpoint, connect_handler);
39  	auto client3 = std::make_shared<nano::transport::client_socket> (*node);
40  	client3->async_connect (dst_endpoint, connect_handler);
41  	auto get_tcp_accept_failures = [&node] () {
42  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_failure, nano::stat::dir::in);
43  	};
44  	auto get_tcp_accept_successes = [&node] () {
45  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
46  	};
47  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 1);
48  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 2);
49  	ASSERT_TIMELY_EQ (5s, connection_attempts, 3);
50  	server_sockets[0].reset ();
51  	auto client4 = std::make_shared<nano::transport::client_socket> (*node);
52  	client4->async_connect (dst_endpoint, connect_handler);
53  	auto client5 = std::make_shared<nano::transport::client_socket> (*node);
54  	client5->async_connect (dst_endpoint, connect_handler);
55  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 2);
56  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 3);
57  	ASSERT_TIMELY_EQ (5s, connection_attempts, 5);
58  	server_sockets[1].reset ();
59  	server_sockets[2].reset ();
60  	ASSERT_EQ (server_sockets.size (), 3);
61  	auto client6 = std::make_shared<nano::transport::client_socket> (*node);
62  	client6->async_connect (dst_endpoint, connect_handler);
63  	auto client7 = std::make_shared<nano::transport::client_socket> (*node);
64  	client7->async_connect (dst_endpoint, connect_handler);
65  	auto client8 = std::make_shared<nano::transport::client_socket> (*node);
66  	client8->async_connect (dst_endpoint, connect_handler);
67  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 3);
68  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 5);
69  	ASSERT_TIMELY_EQ (5s, connection_attempts, 8); 
70  	ASSERT_TIMELY_EQ (5s, server_sockets.size (), 5); 
71  	node->stop ();
72  }
73  TEST (socket, max_connections_per_ip)
74  {
75  	nano::test::system system;
76  	auto node = system.add_node ();
77  	ASSERT_FALSE (node->flags.disable_max_peers_per_ip);
78  	auto server_port = system.get_available_port ();
79  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
80  	const auto max_ip_connections = node->network_params.network.max_peers_per_ip;
81  	ASSERT_TRUE (max_ip_connections >= 1);
82  	const auto max_global_connections = 1000;
83  	auto server_socket = std::make_shared<nano::transport::server_socket> (*node, listen_endpoint, max_global_connections);
84  	boost::system::error_code ec;
85  	server_socket->start (ec);
86  	ASSERT_FALSE (ec);
87  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket->listening_port () };
88  	std::vector<std::shared_ptr<nano::transport::socket>> server_sockets;
89  	server_socket->on_connection ([&server_sockets] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
90  		server_sockets.push_back (new_connection);
91  		return true;
92  	});
93  	std::atomic<size_t> connection_attempts = 0;
94  	auto connect_handler = [&connection_attempts] (boost::system::error_code const & ec_a) {
95  		ASSERT_EQ (ec_a.value (), 0);
96  		++connection_attempts;
97  	};
98  	std::vector<std::shared_ptr<nano::transport::socket>> client_list;
99  	client_list.reserve (max_ip_connections + 1);
100  	for (auto idx = 0; idx < max_ip_connections + 1; ++idx)
101  	{
102  		auto client = std::make_shared<nano::transport::client_socket> (*node);
103  		client->async_connect (dst_endpoint, connect_handler);
104  		client_list.push_back (client);
105  	}
106  	auto get_tcp_max_per_ip = [&node] () {
107  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::in);
108  	};
109  	auto get_tcp_accept_successes = [&node] () {
110  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
111  	};
112  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_ip_connections);
113  	ASSERT_TIMELY (5s, get_tcp_max_per_ip () == 1);
114  	ASSERT_TIMELY (5s, connection_attempts == max_ip_connections + 1);
115  	node->stop ();
116  }
117  TEST (socket, limited_subnet_address)
118  {
119  	auto address = boost::asio::ip::make_address ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713");
120  	auto network = nano::transport::socket_functions::get_ipv6_subnet_address (address.to_v6 (), 32); 
121  	ASSERT_EQ ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713/32", network.to_string ());
122  	ASSERT_EQ ("a41d:b7b2::/32", network.canonical ().to_string ());
123  }
124  TEST (socket, first_ipv6_subnet_address)
125  {
126  	auto address = boost::asio::ip::make_address ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713");
127  	auto first_address = nano::transport::socket_functions::first_ipv6_subnet_address (address.to_v6 (), 32); 
128  	ASSERT_EQ ("a41d:b7b2::", first_address.to_string ());
129  }
130  TEST (socket, last_ipv6_subnet_address)
131  {
132  	auto address = boost::asio::ip::make_address ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713");
133  	auto last_address = nano::transport::socket_functions::last_ipv6_subnet_address (address.to_v6 (), 32); 
134  	ASSERT_EQ ("a41d:b7b2:ffff:ffff:ffff:ffff:ffff:ffff", last_address.to_string ());
135  }
136  TEST (socket, count_subnetwork_connections)
137  {
138  	nano::test::system system;
139  	auto node = system.add_node ();
140  	auto address0 = boost::asio::ip::make_address ("a41d:b7b1:ffff:ffff:ffff:ffff:ffff:ffff"); 
141  	auto address1 = boost::asio::ip::make_address ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713"); 
142  	auto address2 = boost::asio::ip::make_address ("a41d:b7b2::"); 
143  	auto address3 = boost::asio::ip::make_address ("a41d:b7b2::1");
144  	auto address4 = boost::asio::ip::make_address ("a41d:b7b2:ffff:ffff:ffff:ffff:ffff:ffff"); 
145  	auto address5 = boost::asio::ip::make_address ("a41d:b7b3::"); 
146  	auto address6 = boost::asio::ip::make_address ("a41d:b7b3::1"); 
147  	auto connection0 = std::make_shared<nano::transport::client_socket> (*node);
148  	auto connection1 = std::make_shared<nano::transport::client_socket> (*node);
149  	auto connection2 = std::make_shared<nano::transport::client_socket> (*node);
150  	auto connection3 = std::make_shared<nano::transport::client_socket> (*node);
151  	auto connection4 = std::make_shared<nano::transport::client_socket> (*node);
152  	auto connection5 = std::make_shared<nano::transport::client_socket> (*node);
153  	auto connection6 = std::make_shared<nano::transport::client_socket> (*node);
154  	nano::transport::address_socket_mmap connections_per_address;
155  	connections_per_address.emplace (address0, connection0);
156  	connections_per_address.emplace (address1, connection1);
157  	connections_per_address.emplace (address2, connection2);
158  	connections_per_address.emplace (address3, connection3);
159  	connections_per_address.emplace (address4, connection4);
160  	connections_per_address.emplace (address5, connection5);
161  	connections_per_address.emplace (address6, connection6);
162  	ASSERT_EQ (4, nano::transport::socket_functions::count_subnetwork_connections (connections_per_address, address1.to_v6 (), 32));
163  }
164  TEST (socket, max_connections_per_subnetwork)
165  {
166  	nano::test::system system;
167  	nano::node_flags node_flags;
168  	node_flags.disable_max_peers_per_ip = true;
169  	node_flags.disable_max_peers_per_subnetwork = false;
170  	auto node = system.add_node (node_flags);
171  	ASSERT_TRUE (node->flags.disable_max_peers_per_ip);
172  	ASSERT_FALSE (node->flags.disable_max_peers_per_subnetwork);
173  	auto server_port = system.get_available_port ();
174  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
175  	const auto max_subnetwork_connections = node->network_params.network.max_peers_per_subnetwork;
176  	ASSERT_TRUE (max_subnetwork_connections >= 1);
177  	const auto max_global_connections = 1000;
178  	auto server_socket = std::make_shared<nano::transport::server_socket> (*node, listen_endpoint, max_global_connections);
179  	boost::system::error_code ec;
180  	server_socket->start (ec);
181  	ASSERT_FALSE (ec);
182  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket->listening_port () };
183  	std::vector<std::shared_ptr<nano::transport::socket>> server_sockets;
184  	server_socket->on_connection ([&server_sockets] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
185  		server_sockets.push_back (new_connection);
186  		return true;
187  	});
188  	std::atomic<size_t> connection_attempts = 0;
189  	auto connect_handler = [&connection_attempts] (boost::system::error_code const & ec_a) {
190  		ASSERT_EQ (ec_a.value (), 0);
191  		++connection_attempts;
192  	};
193  	std::vector<std::shared_ptr<nano::transport::socket>> client_list;
194  	client_list.reserve (max_subnetwork_connections + 1);
195  	for (auto idx = 0; idx < max_subnetwork_connections + 1; ++idx)
196  	{
197  		auto client = std::make_shared<nano::transport::client_socket> (*node);
198  		client->async_connect (dst_endpoint, connect_handler);
199  		client_list.push_back (client);
200  	}
201  	auto get_tcp_max_per_subnetwork = [&node] () {
202  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_subnetwork, nano::stat::dir::in);
203  	};
204  	auto get_tcp_accept_successes = [&node] () {
205  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
206  	};
207  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_subnetwork_connections);
208  	ASSERT_TIMELY (5s, get_tcp_max_per_subnetwork () == 1);
209  	ASSERT_TIMELY (5s, connection_attempts == max_subnetwork_connections + 1);
210  	node->stop ();
211  }
212  TEST (socket, disabled_max_peers_per_ip)
213  {
214  	nano::test::system system;
215  	nano::node_flags node_flags;
216  	node_flags.disable_max_peers_per_ip = true;
217  	auto node = system.add_node (node_flags);
218  	ASSERT_TRUE (node->flags.disable_max_peers_per_ip);
219  	auto server_port = system.get_available_port ();
220  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
221  	const auto max_ip_connections = node->network_params.network.max_peers_per_ip;
222  	ASSERT_TRUE (max_ip_connections >= 1);
223  	const auto max_global_connections = 1000;
224  	auto server_socket = std::make_shared<nano::transport::server_socket> (*node, listen_endpoint, max_global_connections);
225  	boost::system::error_code ec;
226  	server_socket->start (ec);
227  	ASSERT_FALSE (ec);
228  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket->listening_port () };
229  	std::vector<std::shared_ptr<nano::transport::socket>> server_sockets;
230  	server_socket->on_connection ([&server_sockets] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
231  		server_sockets.push_back (new_connection);
232  		return true;
233  	});
234  	std::atomic<size_t> connection_attempts = 0;
235  	auto connect_handler = [&connection_attempts] (boost::system::error_code const & ec_a) {
236  		ASSERT_EQ (ec_a.value (), 0);
237  		++connection_attempts;
238  	};
239  	std::vector<std::shared_ptr<nano::transport::socket>> client_list;
240  	client_list.reserve (max_ip_connections + 1);
241  	for (auto idx = 0; idx < max_ip_connections + 1; ++idx)
242  	{
243  		auto client = std::make_shared<nano::transport::client_socket> (*node);
244  		client->async_connect (dst_endpoint, connect_handler);
245  		client_list.push_back (client);
246  	}
247  	auto get_tcp_max_per_ip = [&node] () {
248  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::in);
249  	};
250  	auto get_tcp_accept_successes = [&node] () {
251  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
252  	};
253  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_ip_connections + 1);
254  	ASSERT_TIMELY (5s, get_tcp_max_per_ip () == 0);
255  	ASSERT_TIMELY (5s, connection_attempts == max_ip_connections + 1);
256  	node->stop ();
257  }
258  TEST (socket, disconnection_of_silent_connections)
259  {
260  	nano::test::system system;
261  	nano::node_config config;
262  	config.tcp_io_timeout = std::chrono::seconds::max ();
263  	config.network_params.network.idle_timeout = std::chrono::seconds::max ();
264  	config.network_params.network.silent_connection_tolerance_time = std::chrono::seconds{ 5 };
265  	auto node = system.add_node (config);
266  	auto server_port = system.get_available_port ();
267  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
268  	auto server_socket = std::make_shared<nano::transport::server_socket> (*node, listen_endpoint, 1);
269  	boost::system::error_code ec;
270  	server_socket->start (ec);
271  	ASSERT_FALSE (ec);
272  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket->listening_port () };
273  	std::shared_ptr<nano::transport::socket> server_data_socket;
274  	server_socket->on_connection ([&server_data_socket] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
275  		server_data_socket = new_connection;
276  		return true;
277  	});
278  	auto client_socket = std::make_shared<nano::transport::client_socket> (*node);
279  	std::atomic<bool> connected{ false };
280  	client_socket->async_connect (dst_endpoint, [client_socket, &connected] (boost::system::error_code const & ec_a) {
281  		ASSERT_FALSE (ec_a);
282  		connected = true;
283  	});
284  	ASSERT_TIMELY (4s, connected);
285  	ASSERT_TIMELY (10s, server_data_socket != nullptr);
286  	ASSERT_TIMELY (10s, server_data_socket->is_closed ());
287  	auto get_tcp_io_timeout_drops = [&node] () {
288  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::in);
289  	};
290  	auto get_tcp_silent_connection_drops = [&node] () {
291  		return node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_silent_connection_drop, nano::stat::dir::in);
292  	};
293  	ASSERT_EQ (0, get_tcp_io_timeout_drops ());
294  	ASSERT_EQ (1, get_tcp_silent_connection_drops ());
295  	node->stop ();
296  }
297  TEST (socket, drop_policy)
298  {
299  	nano::test::system system;
300  	auto node_flags = nano::inactive_node_flag_defaults ();
301  	node_flags.read_only = false;
302  	nano::inactive_node inactivenode (nano::unique_path (), node_flags);
303  	auto node = inactivenode.node;
304  	nano::thread_runner runner (node->io_ctx, 1);
305  	std::vector<std::shared_ptr<nano::transport::socket>> connections;
<span onclick='openModal()' class='match'>306  	auto func = [&] (size_t total_message_count, nano::transport::buffer_drop_policy drop_policy) {
307  		auto server_port (system.get_available_port ());
308  		boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
</span>309  		auto server_socket = std::make_shared<nano::transport::server_socket> (*node, endpoint, 1);
310  		boost::system::error_code ec;
311  		server_socket->start (ec);
312  		ASSERT_FALSE (ec);
313  		server_socket->on_connection ([&connections] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
314  			connections.push_back (new_connection);
315  			return true;
316  		});
317  		auto client = std::make_shared<nano::transport::client_socket> (*node);
318  		nano::transport::channel_tcp channel{ *node, client };
319  		nano::test::counted_completion write_completion (static_cast<unsigned> (total_message_count));
320  		client->async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), server_socket->listening_port ()),
321  		[&channel, total_message_count, node, &write_completion, &drop_policy, client] (boost::system::error_code const & ec_a) mutable {
322  			for (int i = 0; i < total_message_count; i++)
323  			{
324  				std::vector<uint8_t> buff (1);
325  				channel.send_buffer (
326  				nano::shared_const_buffer (std::move (buff)), [&write_completion, client] (boost::system::error_code const & ec, size_t size_a) mutable {
327  					client.reset ();
328  					write_completion.increment ();
329  				},
330  				drop_policy);
331  			}
332  		});
333  		ASSERT_FALSE (write_completion.await_count_for (std::chrono::seconds (5)));
334  		ASSERT_EQ (1, client.use_count ());
335  	};
336  	func (nano::transport::socket::default_max_queue_size * 2 + 1, nano::transport::buffer_drop_policy::no_socket_drop);
337  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_no_socket_drop, nano::stat::dir::out));
338  	ASSERT_EQ (0, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_drop, nano::stat::dir::out));
339  	func (nano::transport::socket::default_max_queue_size + 1, nano::transport::buffer_drop_policy::limiter);
340  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_no_socket_drop, nano::stat::dir::out));
341  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_drop, nano::stat::dir::out));
342  	node->stop ();
343  	runner.stop_event_processing ();
344  	runner.join ();
345  }
346  TEST (socket, concurrent_writes)
347  {
348  	nano::test::system system;
349  	auto node_flags = nano::inactive_node_flag_defaults ();
350  	node_flags.read_only = false;
351  	node_flags.disable_max_peers_per_ip = true;
352  	node_flags.disable_max_peers_per_subnetwork = true;
353  	nano::inactive_node inactivenode (nano::unique_path (), node_flags);
354  	auto node = inactivenode.node;
355  	nano::thread_runner runner (node->io_ctx, 1);
356  	constexpr size_t max_connections = 4;
357  	constexpr size_t client_count = max_connections;
358  	constexpr size_t message_count = 4;
359  	constexpr size_t total_message_count = client_count * message_count;
360  	nano::test::counted_completion read_count_completion (total_message_count);
361  	std::function<void (std::shared_ptr<nano::transport::socket> const &)> reader = [&read_count_completion, &total_message_count, &reader] (std::shared_ptr<nano::transport::socket> const & socket_a) {
362  		auto buff (std::make_shared<std::vector<uint8_t>> ());
363  		buff->resize (1);
364  		socket_a->async_read (buff, 1, [&read_count_completion, &reader, &total_message_count, socket_a, buff] (boost::system::error_code const & ec, size_t size_a) {
365  			if (!ec)
366  			{
367  				if (read_count_completion.increment () < total_message_count)
368  				{
369  					reader (socket_a);
370  				}
371  			}
372  			else if (ec != boost::asio::error::eof)
373  			{
374  				std::cerr << "async_read: " << ec.message () << std::endl;
375  			}
376  		});
377  	};
378  	auto server_port (system.get_available_port ());
379  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
380  	auto server_socket = std::make_shared<nano::transport::server_socket> (*node, endpoint, max_connections);
381  	boost::system::error_code ec;
382  	server_socket->start (ec);
383  	ASSERT_FALSE (ec);
384  	std::vector<std::shared_ptr<nano::transport::socket>> connections;
385  	server_socket->on_connection ([&connections, &reader] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
386  		if (ec_a)
387  		{
388  			std::cerr << "on_connection: " << ec_a.message () << std::endl;
389  		}
390  		else
391  		{
392  			connections.push_back (new_connection);
393  			reader (new_connection);
394  		}
395  		return true;
396  	});
397  	nano::test::counted_completion connection_count_completion (client_count);
398  	std::vector<std::shared_ptr<nano::transport::socket>> clients;
399  	for (unsigned i = 0; i < client_count; i++)
400  	{
401  		auto client = std::make_shared<nano::transport::client_socket> (*node);
402  		clients.push_back (client);
403  		client->async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v4::loopback (), server_socket->listening_port ()),
404  		[&connection_count_completion] (boost::system::error_code const & ec_a) {
405  			if (ec_a)
406  			{
407  				std::cerr << "async_connect: " << ec_a.message () << std::endl;
408  			}
409  			else
410  			{
411  				connection_count_completion.increment ();
412  			}
413  		});
414  	}
415  	ASSERT_FALSE (connection_count_completion.await_count_for (10s));
416  	auto client (clients[0]);
417  	std::vector<std::thread> client_threads;
418  	for (int i = 0; i < client_count; i++)
419  	{
420  		client_threads.emplace_back ([&client, &message_count] () {
421  			for (int i = 0; i < message_count; i++)
422  			{
423  				std::vector<uint8_t> buff;
424  				buff.push_back ('A' + i);
425  				client->async_write (nano::shared_const_buffer (std::move (buff)));
426  			}
427  		});
428  	}
429  	ASSERT_FALSE (read_count_completion.await_count_for (10s));
430  	node->stop ();
431  	runner.stop_event_processing ();
432  	runner.join ();
433  	ASSERT_EQ (node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in), client_count);
434  	ASSERT_LT (node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_failure, nano::stat::dir::in), client_count);
435  	for (auto & t : client_threads)
436  	{
437  		t.join ();
438  	}
439  }
440  TEST (socket_timeout, connect)
441  {
442  	nano::test::system system (1);
443  	std::shared_ptr<nano::node> node = system.nodes[0];
444  	node->config.tcp_io_timeout = std::chrono::seconds (1);
445  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::make_address_v6 ("::ffff:10.255.254.253"), 1234);
446  	auto socket = std::make_shared<nano::transport::client_socket> (*node);
447  	std::atomic<bool> done = false;
448  	boost::system::error_code ec;
449  	socket->async_connect (endpoint, [&ec, &done] (boost::system::error_code const & ec_a) {
450  		if (ec_a)
451  		{
452  			ec = ec_a;
453  			done = true;
454  		}
455  	});
456  	ASSERT_TIMELY (6s, done == true);
457  	ASSERT_TRUE (ec);
458  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_connect_error, nano::stat::dir::in));
459  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
460  }
461  TEST (socket_timeout, read)
462  {
463  	nano::test::system system (1);
464  	std::shared_ptr<nano::node> node = system.nodes[0];
465  	node->config.tcp_io_timeout = std::chrono::seconds (2);
466  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
467  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
468  	acceptor.open (endpoint.protocol ());
469  	acceptor.bind (endpoint);
470  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
471  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
472  	acceptor.async_accept (newsock, [] (boost::system::error_code const & ec_a) {
473  		EXPECT_FALSE (ec_a);
474  	});
475  	auto socket = std::make_shared<nano::transport::client_socket> (*node);
476  	std::atomic<bool> done = false;
477  	boost::system::error_code ec;
478  	socket->async_connect (acceptor.local_endpoint (), [&socket, &ec, &done] (boost::system::error_code const & ec_a) {
479  		EXPECT_FALSE (ec_a);
480  		auto buffer = std::make_shared<std::vector<uint8_t>> (1);
481  		socket->async_read (buffer, 1, [&ec, &done] (boost::system::error_code const & ec_a, size_t size_a) {
482  			if (ec_a)
483  			{
484  				ec = ec_a;
485  				done = true;
486  			}
487  		});
488  	});
489  	ASSERT_TIMELY (10s, done == true);
490  	ASSERT_TRUE (ec);
491  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_read_error, nano::stat::dir::in));
492  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
493  }
494  TEST (socket_timeout, write)
495  {
496  	nano::test::system system (1);
497  	std::shared_ptr<nano::node> node = system.nodes[0];
498  	node->config.tcp_io_timeout = std::chrono::seconds (2);
499  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
500  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
501  	acceptor.open (endpoint.protocol ());
502  	acceptor.bind (endpoint);
503  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
504  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
505  	acceptor.async_accept (newsock, [] (boost::system::error_code const & ec_a) {
506  		EXPECT_FALSE (ec_a);
507  	});
508  	auto socket = std::make_shared<nano::transport::client_socket> (*node, 1024 * 64); 
509  	std::atomic<bool> done = false;
510  	boost::system::error_code ec;
511  	socket->async_connect (acceptor.local_endpoint (), [&socket, &ec, &done] (boost::system::error_code const & ec_a) {
512  		EXPECT_FALSE (ec_a);
513  		auto buffer = std::make_shared<std::vector<uint8_t>> (128 * 1024);
514  		for (auto i = 0; i < 1024; ++i)
515  		{
516  			socket->async_write (nano::shared_const_buffer{ buffer }, [&ec, &done] (boost::system::error_code const & ec_a, size_t size_a) {
517  				if (ec_a)
518  				{
519  					ec = ec_a;
520  					done = true;
521  				}
522  			});
523  		}
524  	});
525  	ASSERT_TIMELY (10s, done == true);
526  	ASSERT_TRUE (ec);
527  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
528  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
529  }
530  TEST (socket_timeout, read_overlapped)
531  {
532  	nano::test::system system (1);
533  	std::shared_ptr<nano::node> node = system.nodes[0];
534  	node->config.tcp_io_timeout = std::chrono::seconds (2);
535  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
536  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
537  	acceptor.open (endpoint.protocol ());
538  	acceptor.bind (endpoint);
539  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
540  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
541  	acceptor.async_accept (newsock, [&newsock] (boost::system::error_code const & ec_a) {
542  		EXPECT_FALSE (ec_a);
543  		auto buffer = std::make_shared<std::vector<uint8_t>> (1);
544  		nano::async_write (newsock, nano::shared_const_buffer (buffer), [] (boost::system::error_code const & ec_a, size_t size_a) {
545  			debug_assert (!ec_a);
546  			debug_assert (size_a == 1);
547  		});
548  	});
549  	auto socket = std::make_shared<nano::transport::client_socket> (*node);
550  	std::atomic<bool> done = false;
551  	boost::system::error_code ec;
552  	socket->async_connect (acceptor.local_endpoint (), [&socket, &ec, &done] (boost::system::error_code const & ec_a) {
553  		EXPECT_FALSE (ec_a);
554  		auto buffer = std::make_shared<std::vector<uint8_t>> (1);
555  		socket->async_read (buffer, 1, [] (boost::system::error_code const & ec_a, size_t size_a) {
556  			debug_assert (size_a == 1);
557  		});
558  		socket->async_read (buffer, 1, [&ec, &done] (boost::system::error_code const & ec_a, size_t size_a) {
559  			debug_assert (size_a == 0);
560  			if (ec_a)
561  			{
562  				ec = ec_a;
563  				done = true;
564  			}
565  		});
566  	});
567  	ASSERT_TIMELY (10s, done == true);
568  	ASSERT_TRUE (ec);
569  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_read_error, nano::stat::dir::in));
570  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
571  }
572  TEST (socket_timeout, write_overlapped)
573  {
574  	nano::test::system system (1);
575  	std::shared_ptr<nano::node> node = system.nodes[0];
576  	node->config.tcp_io_timeout = std::chrono::seconds (2);
577  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
578  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
579  	acceptor.open (endpoint.protocol ());
580  	acceptor.bind (endpoint);
581  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
582  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
583  	auto buffer = std::make_shared<std::vector<uint8_t>> (1);
584  	acceptor.async_accept (newsock, [&newsock, &buffer] (boost::system::error_code const & ec_a) {
585  		EXPECT_FALSE (ec_a);
586  		boost::asio::async_read (newsock, boost::asio::buffer (buffer->data (), buffer->size ()), [] (boost::system::error_code const & ec_a, size_t size_a) {
587  			debug_assert (size_a == 1);
588  		});
589  	});
590  	auto socket = std::make_shared<nano::transport::client_socket> (*node, 1024 * 64); 
591  	std::atomic<bool> done = false;
592  	boost::system::error_code ec;
593  	socket->async_connect (acceptor.local_endpoint (), [&socket, &ec, &done] (boost::system::error_code const & ec_a) {
594  		EXPECT_FALSE (ec_a);
595  		auto buffer1 = std::make_shared<std::vector<uint8_t>> (1);
596  		auto buffer2 = std::make_shared<std::vector<uint8_t>> (128 * 1024);
597  		socket->async_write (nano::shared_const_buffer{ buffer1 }, [] (boost::system::error_code const & ec_a, size_t size_a) {
598  			debug_assert (size_a == 1);
599  		});
600  		for (auto i = 0; i < 1024; ++i)
601  		{
602  			socket->async_write (nano::shared_const_buffer{ buffer2 }, [&ec, &done] (boost::system::error_code const & ec_a, size_t size_a) {
603  				if (ec_a)
604  				{
605  					ec = ec_a;
606  					done = true;
607  				}
608  			});
609  		}
610  	});
611  	ASSERT_TIMELY (10s, done == true);
612  	ASSERT_TRUE (ec);
613  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
614  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
615  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_memory.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.cpp</div>
                </div>
                <div class="column column_space"><pre><code>43  void MKLDNNMemoryDescriptorBase<Dtype>::create_reorder_descriptors(std::vector<float> scale, int mask, std::vector<float> scale_ext, bool is_sum, bool is_wino, bool is_weight)
44  {
45      CHECK(_usr_memory_pd);
46      CHECK(_prv_memory_pd);
47      primitive_attr attri;
48      int count = scale.size();
</pre></code></div>
                <div class="column column_space"><pre><code>306  	auto func = [&] (size_t total_message_count, nano::transport::buffer_drop_policy drop_policy) {
307  		auto server_port (system.get_available_port ());
308  		boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    