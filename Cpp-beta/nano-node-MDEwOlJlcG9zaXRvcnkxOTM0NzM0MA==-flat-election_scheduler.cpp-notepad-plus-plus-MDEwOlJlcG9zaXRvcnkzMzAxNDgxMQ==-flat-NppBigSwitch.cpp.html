
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4200518582541055%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-election_scheduler.cpp</h3>
            <pre><code>1  #include <nano/node/scheduler/buckets.hpp>
2  #include <nano/node/scheduler/component.hpp>
3  #include <nano/test_common/system.hpp>
4  #include <nano/test_common/testutil.hpp>
5  #include <gtest/gtest.h>
6  #include <chrono>
7  using namespace std::chrono_literals;
8  TEST (election_scheduler, construction)
9  {
10  	nano::test::system system{ 1 };
11  }
12  TEST (election_scheduler, activate_one_timely)
13  {
14  	nano::test::system system{ 1 };
<span onclick='openModal()' class='match'>15  	nano::state_block_builder builder;
16  	auto send1 = builder.make_block ()
</span>17  				 .account (nano::dev::genesis_key.pub)
18  				 .previous (nano::dev::genesis->hash ())
19  				 .representative (nano::dev::genesis_key.pub)
20  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
21  				 .link (nano::dev::genesis_key.pub)
22  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
23  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
24  				 .build_shared ();
25  	system.nodes[0]->ledger.process (system.nodes[0]->store.tx_begin_write (), *send1);
26  	system.nodes[0]->scheduler.buckets.activate (nano::dev::genesis_key.pub, system.nodes[0]->store.tx_begin_read ());
27  	ASSERT_TIMELY (5s, system.nodes[0]->active.election (send1->qualified_root ()));
28  }
29  TEST (election_scheduler, activate_one_flush)
30  {
31  	nano::test::system system{ 1 };
32  	nano::state_block_builder builder;
33  	auto send1 = builder.make_block ()
34  				 .account (nano::dev::genesis_key.pub)
35  				 .previous (nano::dev::genesis->hash ())
36  				 .representative (nano::dev::genesis_key.pub)
37  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
38  				 .link (nano::dev::genesis_key.pub)
39  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
40  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
41  				 .build_shared ();
42  	system.nodes[0]->ledger.process (system.nodes[0]->store.tx_begin_write (), *send1);
43  	system.nodes[0]->scheduler.buckets.activate (nano::dev::genesis_key.pub, system.nodes[0]->store.tx_begin_read ());
44  	ASSERT_TIMELY (5s, system.nodes[0]->active.election (send1->qualified_root ()));
45  }
46  TEST (election_scheduler, no_vacancy)
47  {
48  	nano::test::system system{};
49  	nano::node_config config = system.default_config ();
50  	config.active_elections_size = 1;
51  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
52  	auto & node = *system.add_node (config);
53  	nano::state_block_builder builder{};
54  	nano::keypair key{};
55  	auto send = builder.make_block ()
56  				.account (nano::dev::genesis_key.pub)
57  				.previous (nano::dev::genesis->hash ())
58  				.representative (nano::dev::genesis_key.pub)
59  				.link (key.pub)
60  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
61  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
62  				.work (*system.work.generate (nano::dev::genesis->hash ()))
63  				.build_shared ();
64  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
65  	node.process_confirmed (nano::election_status{ send });
66  	auto receive = builder.make_block ()
67  				   .account (key.pub)
68  				   .previous (0)
69  				   .representative (key.pub)
70  				   .link (send->hash ())
71  				   .balance (nano::Gxrb_ratio)
72  				   .sign (key.prv, key.pub)
73  				   .work (*system.work.generate (key.pub))
74  				   .build_shared ();
75  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
76  	node.process_confirmed (nano::election_status{ receive });
77  	auto block1 = builder.make_block ()
78  				  .account (nano::dev::genesis_key.pub)
79  				  .previous (send->hash ())
80  				  .representative (nano::dev::genesis_key.pub)
81  				  .link (nano::dev::genesis_key.pub)
82  				  .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
83  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
84  				  .work (*system.work.generate (send->hash ()))
85  				  .build_shared ();
86  	ASSERT_EQ (nano::process_result::progress, node.process (*block1).code);
87  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
88  	std::shared_ptr<nano::election> election{};
89  	ASSERT_TIMELY (5s, (election = node.active.election (block1->qualified_root ())) != nullptr);
90  	auto block2 = builder.make_block ()
91  				  .account (key.pub)
92  				  .previous (receive->hash ())
93  				  .representative (key.pub)
94  				  .link (key.pub)
95  				  .balance (0)
96  				  .sign (key.prv, key.pub)
97  				  .work (*system.work.generate (receive->hash ()))
98  				  .build_shared ();
99  	ASSERT_EQ (nano::process_result::progress, node.process (*block2).code);
100  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
101  	ASSERT_TIMELY (5s, node.scheduler.buckets.size () == 1);
102  	ASSERT_TRUE (node.active.election (block2->qualified_root ()) == nullptr);
103  	election->force_confirm ();
104  	ASSERT_TIMELY (5s, node.active.election (block2->qualified_root ()) != nullptr);
105  	ASSERT_TRUE (node.scheduler.buckets.empty ());
106  }
107  TEST (election_scheduler, flush_vacancy)
108  {
109  	nano::test::system system;
110  	nano::node_config config = system.default_config ();
111  	config.active_elections_size = 0;
112  	auto & node = *system.add_node (config);
113  	nano::state_block_builder builder;
114  	nano::keypair key;
115  	auto send = builder.make_block ()
116  				.account (nano::dev::genesis_key.pub)
117  				.previous (nano::dev::genesis->hash ())
118  				.representative (nano::dev::genesis_key.pub)
119  				.link (key.pub)
120  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
121  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
122  				.work (*system.work.generate (nano::dev::genesis->hash ()))
123  				.build_shared ();
124  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
125  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
126  	node.scheduler.buckets.flush ();
127  	ASSERT_EQ (0, node.active.size ());
128  	ASSERT_EQ (1, node.scheduler.buckets.size ());
129  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppBigSwitch.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <shlwapi.h>
3  #include <uxtheme.h> 
4  #include "Notepad_plus_Window.h"
5  #include "TaskListDlg.h"
6  #include "ImageListSet.h"
7  #include "ShortcutMapper.h"
8  #include "ansiCharPanel.h"
9  #include "clipboardHistoryPanel.h"
10  #include "VerticalFileSwitcher.h"
11  #include "ProjectPanel.h"
12  #include "documentMap.h"
13  #include "functionListPanel.h"
14  #include "fileBrowser.h"
15  #include "NppDarkMode.h"
16  using namespace std;
17  #define WM_DPICHANGED 0x02E0
18  struct SortTaskListPred final
19  {
20  	DocTabView *_views[2];
21  	SortTaskListPred(DocTabView &p, DocTabView &s)
22  	{
23  		_views[MAIN_VIEW] = &p;
24  		_views[SUB_VIEW] = &s;
25  	}
26  	bool operator()(const TaskLstFnStatus &l, const TaskLstFnStatus &r) const {
27  		BufferID lID = _views[l._iView]->getBufferByIndex(l._docIndex);
28  		BufferID rID = _views[r._iView]->getBufferByIndex(r._docIndex);
29  		Buffer * bufL = MainFileManager.getBufferByID(lID);
30  		Buffer * bufR = MainFileManager.getBufferByID(rID);
31  		return bufL->getRecentTag() > bufR->getRecentTag();
32  	}
33  };
34  LRESULT CALLBACK Notepad_plus_Window::Notepad_plus_Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
35  {
36  	if (hwnd == NULL)
37  		return FALSE;
38  	switch(message)
39  	{
40  		case WM_NCCREATE:
41  		{
42  			Notepad_plus_Window *pM30ide = static_cast<Notepad_plus_Window *>((reinterpret_cast<LPCREATESTRUCT>(lParam))->lpCreateParams);
43  			pM30ide->_hSelf = hwnd;
44  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pM30ide));
45  			if (NppDarkMode::isExperimentalSupported())
46  			{
47  				NppDarkMode::enableDarkScrollBarForWindowAndChildren(hwnd);
48  			}
49  			return TRUE;
50  		}
51  		default:
52  		{
53  			return (reinterpret_cast<Notepad_plus_Window *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA))->runProc(hwnd, message, wParam, lParam));
54  		}
55  	}
56  }
57  LRESULT Notepad_plus_Window::runProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
58  {
59  	switch (message)
60  	{
61  		case WM_CREATE:
62  		{
63  			try
64  			{
65  				NppDarkMode::setDarkTitleBar(hwnd);
66  				_notepad_plus_plus_core._pPublicInterface = this;
67  				LRESULT lRet = _notepad_plus_plus_core.init(hwnd);
68  				if (NppDarkMode::isEnabled() && NppDarkMode::isExperimentalSupported())
69  				{
70  					RECT rcClient;
71  					GetWindowRect(hwnd, &rcClient);
72  					SetWindowPos(hwnd,
73  						NULL,
74  						rcClient.left, rcClient.top,
75  						rcClient.right - rcClient.left, rcClient.bottom - rcClient.top,
76  						SWP_FRAMECHANGED);
77  				}
78  				return lRet;
79  			}
80  			catch (std::exception& ex)
81  			{
82  				::MessageBoxA(hwnd, ex.what(), "Exception On WM_CREATE", MB_OK);
83  				exit(-1);
84  			}
85  			break;
86  		}
87  		default:
88  		{
89  			return _notepad_plus_plus_core.process(hwnd, message, wParam, lParam);
90  		}
91  	}
92  }
93  int CharacterIs(TCHAR c, const TCHAR *any)
94  {
95  	int i;
96  	for (i = 0; any[i] != 0; i++)
97  	{
98  		if (any[i] == c) return TRUE;
99  	}
100  	return FALSE;
101  }
102  LRESULT Notepad_plus::process(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
103  {
104  	LRESULT result = FALSE;
105  	NppParameters& nppParam = NppParameters::getInstance();
106  	if (NppDarkMode::isDarkMenuEnabled() && NppDarkMode::isEnabled() && NppDarkMode::runUAHWndProc(hwnd, message, wParam, lParam, &result))
107  	{
108  		return result;
109  	}
110  	switch (message)
111  	{
112  		case WM_NCACTIVATE:
113  		{
114  			::SendMessage(_dockingManager.getHSelf(), WM_NCACTIVATE, wParam, -1);
115  			result = ::DefWindowProc(hwnd, message, wParam, lParam);
116  			if (NppDarkMode::isDarkMenuEnabled() && NppDarkMode::isEnabled())
117  			{
118  				NppDarkMode::drawUAHMenuNCBottomLine(hwnd);
119  			}
120  			NppDarkMode::calculateTreeViewStyle();
121  			return result;
122  		}
123  		case WM_NCPAINT:
124  		{
125  			result = ::DefWindowProc(hwnd, message, wParam, lParam);
126  			if (NppDarkMode::isDarkMenuEnabled() && NppDarkMode::isEnabled())
127  			{
128  				NppDarkMode::drawUAHMenuNCBottomLine(hwnd);
129  			}
130  			return result;
131  		}
132  		case WM_ERASEBKGND:
133  		{
134  			if (NppDarkMode::isEnabled())
135  			{
136  				RECT rc = {};
137  				GetClientRect(hwnd, &rc);
138  				::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
139  				return 0;
140  			}
141  			else
142  			{
143  				return ::DefWindowProc(hwnd, message, wParam, lParam);
144  			}
145  		}
146  		case WM_SETTINGCHANGE:
147  		{
148  			NppDarkMode::handleSettingChange(hwnd, lParam);
149  			const bool enableDarkMode = NppDarkMode::isExperimentalActive();
150  			NppParameters& nppParam = NppParameters::getInstance();
151  			NppGUI& nppGUI = nppParam.getNppGUI();
152  			if (NppDarkMode::isWindowsModeEnabled() && (enableDarkMode != NppDarkMode::isEnabled()))
153  			{
154  				nppGUI._darkmode._isEnabled = enableDarkMode;
155  				if (!_preference.isCreated())
156  				{
157  					const int iconState = NppDarkMode::getToolBarIconSet(NppDarkMode::isEnabled());
158  					toolBarStatusType state = (iconState == -1) ? _toolBar.getState() : static_cast<toolBarStatusType>(iconState);
159  					switch (state)
160  					{
161  						case TB_SMALL:
162  							_toolBar.reduce();
163  							break;
164  						case TB_LARGE:
165  							_toolBar.enlarge();
166  							break;
167  						case TB_SMALL2:
168  							_toolBar.reduceToSet2();
169  							break;
170  						case TB_LARGE2:
171  							_toolBar.enlargeToSet2();
172  							break;
173  						case TB_STANDARD:
174  							_toolBar.setToBmpIcons();
175  							break;
176  					}
177  					NppDarkMode::refreshDarkMode(hwnd, false);
178  				}
179  				else
180  				{
181  					HWND hSubDlg = _preference._darkModeSubDlg.getHSelf();
182  					::SendMessage(hSubDlg, WM_COMMAND, IDC_RADIO_DARKMODE_DARKMODE, 0);
183  				}
184  			}
185  			return ::DefWindowProc(hwnd, message, wParam, lParam);
186  		}
187  		case NPPM_INTERNAL_REFRESHDARKMODE:
188  		{
189  			refreshDarkMode(static_cast<bool>(wParam));
190  			SCNotification scnN{};
191  			scnN.nmhdr.code = NPPN_DARKMODECHANGED;
192  			scnN.nmhdr.hwndFrom = hwnd;
193  			scnN.nmhdr.idFrom = 0;
194  			_pluginsManager.notify(&scnN);
195  			return TRUE;
196  		}
197  		case WM_DRAWITEM:
198  		{
199  			DRAWITEMSTRUCT *dis = reinterpret_cast<DRAWITEMSTRUCT *>(lParam);
200  			if (dis->CtlType == ODT_TAB)
201  				return ::SendMessage(dis->hwndItem, WM_DRAWITEM, wParam, lParam);
202  			break;
203  		}
204  		case WM_DOCK_USERDEFINE_DLG:
205  		{
206  			dockUserDlg();
207  			return TRUE;
208  		}
209  		case WM_UNDOCK_USERDEFINE_DLG:
210  		{
211  			undockUserDlg();
212  			return TRUE;
213  		}
214  		case WM_REMOVE_USERLANG:
215  		{
216  			TCHAR *userLangName = reinterpret_cast<TCHAR *>(lParam);
217  			if (!userLangName || !userLangName[0])
218  				return FALSE;
219  			generic_string name{userLangName};
220  			for (size_t i = 0; i < MainFileManager.getNbBuffers(); ++i)
221  			{
222  				Buffer* buf = MainFileManager.getBufferByIndex(i);
223  				if (buf->getLangType() == L_USER && name == buf->getUserDefineLangName())
224  					buf->setLangType(L_USER, TEXT(""));
225  			}
226  			return TRUE;
227  		}
228  		case WM_RENAME_USERLANG:
229  		{
230  			if (!lParam || !((reinterpret_cast<TCHAR *>(lParam))[0]) || !wParam || !((reinterpret_cast<TCHAR *>(wParam))[0]))
231  				return FALSE;
232  			generic_string oldName{ reinterpret_cast<TCHAR *>(lParam) };
233  			generic_string newName{ reinterpret_cast<TCHAR *>(wParam) };
234  			for (size_t i = 0; i < MainFileManager.getNbBuffers(); ++i)
235  			{
236  				Buffer* buf = MainFileManager.getBufferByIndex(i);
237  				if (buf->getLangType() == L_USER && oldName == buf->getUserDefineLangName())
238  					buf->setLangType(L_USER, newName.c_str());
239  			}
240  			return TRUE;
241  		}
242  		case WM_CLOSE_USERDEFINE_DLG:
243  		{
244  			checkMenuItem(IDM_LANG_USER_DLG, false);
245  			_toolBar.setCheck(IDM_LANG_USER_DLG, false);
246  			return TRUE;
247  		}
248  		case WM_REPLACEALL_INOPENEDDOC:
249  		{
250  			replaceInOpenedFiles();
251  			return TRUE;
252  		}
253  		case WM_FINDALL_INOPENEDDOC:
254  		{
255  			findInOpenedFiles();
256  			return TRUE;
257  		}
258  		case WM_FINDALL_INCURRENTDOC:
259  		{
260  			const bool isEntireDoc = wParam == 0;
261  			return findInCurrentFile(isEntireDoc);
262  		}
263  		case WM_FINDINFILES:
264  		{
265  			return findInFiles();
266  		}
267  		case WM_FINDINPROJECTS:
268  		{
269  			return findInProjects();
270  		}
271  		case WM_FINDALL_INCURRENTFINDER:
272  		{
273  			FindersInfo *findInFolderInfo = reinterpret_cast<FindersInfo *>(wParam);
274  			Finder * newFinder = _findReplaceDlg.createFinder();
275  			findInFolderInfo->_pDestFinder = newFinder;
276  			bool isOK = findInFinderFiles(findInFolderInfo);
277  			return isOK;
278  		}
279  		case WM_REPLACEINFILES:
280  		{
281  			replaceInFiles();
282  			return TRUE;
283  		}
284  		case WM_REPLACEINPROJECTS:
285  		{
286  			replaceInProjects();
287  			return TRUE;
288  		}
289  		case NPPM_LAUNCHFINDINFILESDLG:
290  		{
291  			const int strSize = FINDREPLACE_MAXLENGTH;
292  			TCHAR str[strSize];
293  			bool isFirstTime = !_findReplaceDlg.isCreated();
294  			_findReplaceDlg.doDialog(FIND_DLG, _nativeLangSpeaker.isRTL());
295  			const NppGUI & nppGui = nppParam.getNppGUI();
296  			if (nppGui._fillFindFieldWithSelected)
297  			{
298  				_pEditView->getGenericSelectedText(str, strSize, nppGui._fillFindFieldSelectCaret);
299  				_findReplaceDlg.setSearchText(str);
300  			}
301  			if (isFirstTime)
302  				_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
303  			_findReplaceDlg.launchFindInFilesDlg();
304  			setFindReplaceFolderFilter(reinterpret_cast<const TCHAR*>(wParam), reinterpret_cast<const TCHAR*>(lParam));
305  			return TRUE;
306  		}
307  		case NPPM_INTERNAL_FINDINPROJECTS:
308  		{
309  			const int strSize = FINDREPLACE_MAXLENGTH;
310  			TCHAR str[strSize];
311  			bool isFirstTime = not _findReplaceDlg.isCreated();
312  			_findReplaceDlg.doDialog(FIND_DLG, _nativeLangSpeaker.isRTL());
313  			_pEditView->getGenericSelectedText(str, strSize);
314  			_findReplaceDlg.setSearchText(str);
315  			if (isFirstTime)
316  				_nativeLangSpeaker.changeDlgLang(_findReplaceDlg.getHSelf(), "Find");
317  			_findReplaceDlg.launchFindInProjectsDlg();
318  			_findReplaceDlg.setProjectCheckmarks(NULL, (int) wParam);
319  			return TRUE;
320  		}
321  		case NPPM_INTERNAL_FINDINFINDERDLG:
322  		{
323  			const int strSize = FINDREPLACE_MAXLENGTH;
324  			TCHAR str[strSize];
<span onclick='openModal()' class='match'>325  			Finder *launcher = reinterpret_cast<Finder *>(wParam);
326  			bool isFirstTime = !_findInFinderDlg.isCreated();
327  			_findInFinderDlg.doDialog(launcher, _nativeLangSpeaker.isRTL());
328  			_pEditView->getGenericSelectedText(str, strSize);
329  			_findReplaceDlg.setSearchText(str);
330  			setFindReplaceFolderFilter(NULL, NULL);
</span>331  			if (isFirstTime)
332  				_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
333  			return TRUE;
334  		}
335  		case NPPM_DOOPEN:
336  		case WM_DOOPEN:
337  		{
338  			BufferID id = doOpen(reinterpret_cast<const TCHAR *>(lParam));
339  			if (id != BUFFER_INVALID)
340  				return switchToFile(id);
341  			break;
342  		}
343  		case NPPM_INTERNAL_SETFILENAME:
344  		{
345  			if (!lParam && !wParam)
346  				return FALSE;
347  			BufferID id = (BufferID)wParam;
348  			Buffer * b = MainFileManager.getBufferByID(id);
349  			if (b && b->getStatus() == DOC_UNNAMED)
350  			{
351  				b->setFileName(reinterpret_cast<const TCHAR*>(lParam));
352  				return TRUE;
353  			}
354  			return FALSE;
355  		}
356  		case NPPM_GETBUFFERLANGTYPE:
357  		{
358  			if (!wParam)
359  				return -1;
360  			BufferID id = (BufferID)wParam;
361  			Buffer * b = MainFileManager.getBufferByID(id);
362  			return b->getLangType();
363  		}
364  		case NPPM_SETBUFFERLANGTYPE:
365  		{
366  			if (!wParam)
367  				return FALSE;
368  			if (lParam < L_TEXT || lParam >= L_EXTERNAL || lParam == L_USER)
369  				return FALSE;
370  			BufferID id = (BufferID)wParam;
371  			Buffer * b = MainFileManager.getBufferByID(id);
372  			b->setLangType((LangType)lParam);
373  			return TRUE;
374  		}
375  		case NPPM_GETBUFFERENCODING:
376  		{
377  			if (!wParam)
378  				return -1;
379  			BufferID id = (BufferID)wParam;
380  			Buffer * b = MainFileManager.getBufferByID(id);
381  			return b->getUnicodeMode();
382  		}
383  		case NPPM_SETBUFFERENCODING:
384  		{
385  			if (!wParam)
386  				return FALSE;
387  			if (lParam < uni8Bit || lParam >= uniEnd)
388  				return FALSE;
389  			BufferID id = (BufferID)wParam;
390  			Buffer * b = MainFileManager.getBufferByID(id);
391  			if (b->getStatus() != DOC_UNNAMED || b->isDirty())	
392  				return FALSE;
393  			b->setUnicodeMode((UniMode)lParam);
394  			return TRUE;
395  		}
396  		case NPPM_GETBUFFERFORMAT:
397  		{
398  			if (!wParam)
399  				return -1;
400  			BufferID id = (BufferID)wParam;
401  			Buffer * b = MainFileManager.getBufferByID(id);
402  			return static_cast<LRESULT>(b->getEolFormat());
403  		}
404  		case NPPM_SETBUFFERFORMAT:
405  		{
406  			if (!wParam)
407  				return FALSE;
408  			EolType newFormat = convertIntToFormatType(static_cast<int>(lParam), EolType::unknown);
409  			if (EolType::unknown == newFormat)
410  			{
411  				assert(false and "invalid buffer format message");
412  				return FALSE;
413  			}
414  			BufferID id = (BufferID)wParam;
415  			Buffer * b = MainFileManager.getBufferByID(id);
416  			b->setEolFormat(newFormat);
417  			return TRUE;
418  		}
419  		case NPPM_GETBUFFERIDFROMPOS:
420  		{
421  			DocTabView* pView = nullptr;
422  			if (lParam == MAIN_VIEW)
423  				pView = &_mainDocTab;
424  			else if (lParam == SUB_VIEW)
425  				pView = &_subDocTab;
426  			else
427  				return reinterpret_cast<LRESULT>(BUFFER_INVALID);
428  			if ((size_t)wParam < pView->nbItem())
429  				return reinterpret_cast<LRESULT>(pView->getBufferByIndex(wParam));
430  			return reinterpret_cast<LRESULT>(BUFFER_INVALID);
431  		}
432  		case NPPM_GETCURRENTBUFFERID:
433  		{
434  			return reinterpret_cast<LRESULT>(_pEditView->getCurrentBufferID());
435  		}
436  		case NPPM_RELOADBUFFERID:
437  		{
438  			if (!wParam)
439  				return FALSE;
440  			return doReload(reinterpret_cast<BufferID>(wParam), lParam != 0);
441  		}
442  		case NPPM_RELOADFILE:
443  		{
444  			TCHAR longNameFullpath[MAX_PATH];
445  			const TCHAR* pFilePath = reinterpret_cast<const TCHAR*>(lParam);
446  			wcscpy_s(longNameFullpath, MAX_PATH, pFilePath);
447  			if (wcschr(longNameFullpath, '~'))
448  			{
449  				::GetLongPathName(longNameFullpath, longNameFullpath, MAX_PATH);
450  			}
451  			BufferID id = MainFileManager.getBufferFromName(longNameFullpath);
452  			if (id != BUFFER_INVALID)
453  				doReload(id, wParam != 0);
454  			break;
455  		}
456  		case NPPM_SWITCHTOFILE :
457  		{
458  			BufferID id = MainFileManager.getBufferFromName(reinterpret_cast<const TCHAR *>(lParam));
459  			if (id != BUFFER_INVALID)
460  				return switchToFile(id);
461  			return false;
462  		}
463  		case NPPM_SAVECURRENTFILE:
464  		{
465  			return fileSave();
466  		}
467  		case NPPM_SAVECURRENTFILEAS:
468  		{
469  			BufferID currentBufferID = _pEditView->getCurrentBufferID();
470  			bool asCopy = wParam == TRUE;
471  			const TCHAR *filename = reinterpret_cast<const TCHAR *>(lParam);
472  			if (!filename) return FALSE;
473  			return doSave(currentBufferID, filename, asCopy);
474  		}
475  		case NPPM_SAVEALLFILES:
476  		{
477  			return fileSaveAll();
478  		}
479  		case NPPM_SAVEFILE:
480  		{
481  			return fileSaveSpecific(reinterpret_cast<const TCHAR *>(lParam));
482  		}
483  		case NPPM_GETCURRENTNATIVELANGENCODING:
484  		{
485  			return _nativeLangSpeaker.getLangEncoding();
486  		}
487  		case NPPM_INTERNAL_DOCORDERCHANGED :
488  		{
489  			if (_pDocumentListPanel)
490  			{
491  				_pDocumentListPanel->updateTabOrder();
492  			}
493  			BufferID id = _pEditView->getCurrentBufferID();
494  			SCNotification scnN{};
495  			scnN.nmhdr.code = NPPN_DOCORDERCHANGED;
496  			scnN.nmhdr.hwndFrom = reinterpret_cast<void *>(lParam);
497  			scnN.nmhdr.idFrom = reinterpret_cast<uptr_t>(id);
498  			_pluginsManager.notify(&scnN);
499  			return TRUE;
500  		}
501  		case NPPM_INTERNAL_EXPORTFUNCLISTANDQUIT:
502  		{
503  			checkMenuItem(IDM_VIEW_FUNC_LIST, true);
504  			_toolBar.setCheck(IDM_VIEW_FUNC_LIST, true);
505  			launchFunctionList();
506  			_pFuncList->setClosed(false);
507  			_pFuncList->serialize();
508  			::PostMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_FILE_EXIT, 0);
509  		}
510  		break;
511  		case NPPM_INTERNAL_PRNTANDQUIT:
512  		{
513  			::PostMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_FILE_PRINTNOW, 0);
514  			::PostMessage(_pPublicInterface->getHSelf(), WM_COMMAND, IDM_FILE_EXIT, 0);
515  		}
516  		break;
517  		case NPPM_DISABLEAUTOUPDATE:
518  		{
519  			NppGUI & nppGUI = nppParam.getNppGUI();
520  			nppGUI._autoUpdateOpt._doAutoUpdate = false;
521  			return TRUE;
522  		}
523  		case WM_SIZE:
524  		{
525  			RECT rc;
526  			_pPublicInterface->getClientRect(rc);
527  			if (lParam == 0)
528  				lParam = MAKELPARAM(rc.right - rc.left, rc.bottom - rc.top);
529  			::MoveWindow(_rebarTop.getHSelf(), 0, 0, rc.right, _rebarTop.getHeight(), TRUE);
530  			_statusBar.adjustParts(rc.right);
531  			::SendMessage(_statusBar.getHSelf(), WM_SIZE, wParam, lParam);
532  			int rebarBottomHeight = _rebarBottom.getHeight();
533  			int statusBarHeight = _statusBar.getHeight();
534  			::MoveWindow(_rebarBottom.getHSelf(), 0, rc.bottom - rebarBottomHeight - statusBarHeight, rc.right, rebarBottomHeight, TRUE);
535  			getMainClientRect(rc);
536  			_dockingManager.reSizeTo(rc);
537  			if (_pDocMap)
538  			{
539  				_pDocMap->doMove();
540  				_pDocMap->reloadMap();
541  			}
542  			result = TRUE;
543  			break;
544  		}
545  		case WM_MOVE:
546  		{
547  			result = TRUE;
548  			break;
549  		}
550  		case WM_MOVING:
551  		{
552  			if (_pDocMap)
553  			{
554  				_pDocMap->doMove();
555  			}
556  			result = FALSE;
557  			break;
558  		}
559  		case WM_SIZING:
560  		{
561  			result = FALSE;
562  			break;
563  		}
564  		case WM_COPYDATA:
565  		{
566  			COPYDATASTRUCT *pCopyData = reinterpret_cast<COPYDATASTRUCT *>(lParam);
567  			switch (pCopyData->dwData)
568  			{
569  				case COPYDATA_FULL_CMDLINE:
570  				{
571  					nppParam.setCmdLineString(static_cast<wchar_t*>(pCopyData->lpData));
572  					break;
573  				}
574  				case COPYDATA_PARAMS:
575  				{
576  					const CmdLineParamsDTO *cmdLineParam = static_cast<const CmdLineParamsDTO *>(pCopyData->lpData); 
577  					const DWORD cmdLineParamsSize = pCopyData->cbData;  
578  					if (sizeof(CmdLineParamsDTO) == cmdLineParamsSize) 
579  					{
580  						nppParam.setCmdlineParam(*cmdLineParam);
581  						generic_string pluginMessage { nppParam.getCmdLineParams()._pluginMessage };
582  						if (!pluginMessage.empty())
583  						{
584  							SCNotification scnN{};
585  							scnN.nmhdr.code = NPPN_CMDLINEPLUGINMSG;
586  							scnN.nmhdr.hwndFrom = hwnd;
587  							scnN.nmhdr.idFrom = reinterpret_cast<uptr_t>(pluginMessage.c_str());
588  							_pluginsManager.notify(&scnN);
589  						}
590  					}
591  					else
592  					{
593  #ifdef DEBUG 
594  						printStr(TEXT("sizeof(CmdLineParams) != cmdLineParamsSize\rCmdLineParams is formed by an instance of another version,\rwhereas your CmdLineParams has been modified in this instance."));
595  #endif
596  					}
597  					NppGUI nppGui = (NppGUI)nppParam.getNppGUI();
598  					nppGui._isCmdlineNosessionActivated = cmdLineParam->_isNoSession;
599  					break;
600  				}
601  				case COPYDATA_FILENAMESW:
602  				{
603  					wchar_t *fileNamesW = static_cast<wchar_t *>(pCopyData->lpData);
604  					const CmdLineParamsDTO & cmdLineParams = nppParam.getCmdLineParams();
605  					loadCommandlineParams(fileNamesW, &cmdLineParams);
606  					break;
607  				}
608  			}
609  			return TRUE;
610  		}
611  		case WM_COMMAND:
612  		{
613  			if (HIWORD(wParam) == SCEN_SETFOCUS)
614  			{
615  				HWND hMain = _mainEditView.getHSelf(), hSec = _subEditView.getHSelf();
616  				HWND hFocus = reinterpret_cast<HWND>(lParam);
617  				if (hMain == hFocus)
618  					switchEditViewTo(MAIN_VIEW);
619  				else if (hSec == hFocus)
620  					switchEditViewTo(SUB_VIEW);
621  				else
622  				{
623  				}
624  				return TRUE;
625  			}
626  			else
627  			{
628  				command(LOWORD(wParam));
629  			}
630  			return TRUE;
631  		}
632  		case NPPM_INTERNAL_SAVECURRENTSESSION:
633  		{
634  			const NppGUI& nppGui = nppParam.getNppGUI();
635  			if (nppGui._rememberLastSession && !nppGui._isCmdlineNosessionActivated)
636  			{
637  				Session currentSession;
638  				getCurrentOpenedFiles(currentSession, true);
639  				nppParam.writeSession(currentSession);
640  			}
641  			return TRUE;
642  		}
643  		case NPPM_INTERNAL_SAVEBACKUP:
644  		{
645  			if (NppParameters::getInstance().getNppGUI().isSnapshotMode())
646  			{
647  				MainFileManager.backupCurrentBuffer();
648  			}
649  			return TRUE;
650  		}
651  		case NPPM_INTERNAL_CHANGETABBAEICONS:
652  		{
653  			_mainDocTab.changeIcons(static_cast<unsigned char>(lParam));
654  			_subDocTab.changeIcons(static_cast<unsigned char>(lParam));
655  			if (_pDocumentListPanel)
656  			{
657  				if (!_pDocumentListPanel->isClosed()) 
658  				{
659  					_pDocumentListPanel->display(false);
660  					_pDocumentListPanel->destroy();
661  					_pDocumentListPanel = nullptr;
662  					launchDocumentListPanel(static_cast<bool>(wParam));
663  				}
664  				else 
665  				{
666  					_pDocumentListPanel->destroy();
667  					_pDocumentListPanel = nullptr;
668  					launchDocumentListPanel(static_cast<bool>(wParam));
669  					if (_pDocumentListPanel)
670  					{
671  						_pDocumentListPanel->display(false);
672  						_pDocumentListPanel->setClosed(true);
673  						checkMenuItem(IDM_VIEW_DOCLIST, false);
674  						_toolBar.setCheck(IDM_VIEW_DOCLIST, false);
675  					}
676  				}
677  			}
678  			return TRUE;
679  		}
680  		case NPPM_INTERNAL_RELOADNATIVELANG:
681  		{
682  			reloadLang();
683  			return TRUE;
684  		}
685  		case NPPM_INTERNAL_RELOADSTYLERS:
686  		{
687  			loadStyles();
688  			return TRUE;
689  		}
690  		case NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED:
691  		{
692  			SCNotification scnN{};
693  			scnN.nmhdr.code = NPPN_SHORTCUTREMAPPED;
694  			scnN.nmhdr.hwndFrom = reinterpret_cast<void *>(lParam); 
695  			scnN.nmhdr.idFrom = (uptr_t)wParam; 
696  			_pluginsManager.notify(&scnN);
697  			return TRUE;
698  		}
699  		case NPPM_GETSHORTCUTBYCMDID:
700  		{
701  			int cmdID = static_cast<int32_t>(wParam); 
702  			ShortcutKey *sk = reinterpret_cast<ShortcutKey *>(lParam); 
703  			return _pluginsManager.getShortcutByCmdID(cmdID, sk);
704  		}
705  		case NPPM_MENUCOMMAND:
706  		{
707  			command(static_cast<int32_t>(lParam));
708  			return TRUE;
709  		}
710  		case NPPM_GETFULLCURRENTPATH:
711  		case NPPM_GETCURRENTDIRECTORY:
712  		case NPPM_GETFILENAME:
713  		case NPPM_GETNAMEPART:
714  		case NPPM_GETEXTPART:
715  		{
716  			TCHAR str[MAX_PATH] = { '\0' };
717  			wcscpy_s(str, _pEditView->getCurrentBuffer()->getFullPathName());
718  			TCHAR* fileStr = str;
719  			if (message == NPPM_GETCURRENTDIRECTORY)
720  				PathRemoveFileSpec(str);
721  			else if (message == NPPM_GETFILENAME)
722  				fileStr = PathFindFileName(str);
723  			else if (message == NPPM_GETNAMEPART)
724  			{
725  				fileStr = PathFindFileName(str);
726  				PathRemoveExtension(fileStr);
727  			}
728  			else if (message == NPPM_GETEXTPART)
729  				fileStr = PathFindExtension(str);
730  			if (wParam != 0)
731  			{
732  				if (lstrlen(fileStr) >= int(wParam))
733  				{
734  					return FALSE;
735  				}
736  			}
737  			lstrcpy(reinterpret_cast<TCHAR *>(lParam), fileStr);
738  			return TRUE;
739  		}
740  		case NPPM_GETCURRENTWORD:
741  		case NPPM_GETCURRENTLINESTR:
742  		{
743  			const int strSize = CURRENTWORD_MAXLENGTH;
744  			TCHAR str[strSize] = { '\0' };
745  			TCHAR *pTchar = reinterpret_cast<TCHAR *>(lParam);
746  			if (message == NPPM_GETCURRENTWORD)
747  				_pEditView->getGenericSelectedText(str, strSize);
748  			else if (message == NPPM_GETCURRENTLINESTR)
749  				_pEditView->getLine(_pEditView->getCurrentLineNumber(), str, strSize);
750  			if (wParam != 0)
751  			{
752  				if (lstrlen(str) >= int(wParam))	
753  				{
754  					return FALSE;
755  				}
756  				else 
757  				{
758  					lstrcpyn(pTchar, str, static_cast<int32_t>(wParam));
759  					return TRUE;
760  				}
761  			}
762  			lstrcpy(pTchar, str);
763  			return TRUE;
764  		}
765  		case NPPM_GETFILENAMEATCURSOR: 
766  		{
767  			const int strSize = CURRENTWORD_MAXLENGTH;
768  			TCHAR str[strSize];
769  			TCHAR strLine[strSize];
770  			size_t lineNumber;
771  			intptr_t col;
772  			int hasSlash;
773  			TCHAR *pTchar = reinterpret_cast<TCHAR *>(lParam);
774  			_pEditView->getGenericSelectedText(str, strSize); 
775  			hasSlash = FALSE;
776  			for (int i = 0; str[i] != 0; i++)
777  				if (CharacterIs(str[i], TEXT("\\/")))
778  					hasSlash = TRUE;
779  			if (hasSlash == FALSE)
780  			{
781  				intptr_t start;
782  				intptr_t end;
783  				const TCHAR *delimiters;
784  				lineNumber = _pEditView->getCurrentLineNumber();
785  				col = _pEditView->getCurrentColumnNumber();
786  				_pEditView->getLine(lineNumber, strLine, strSize);
787  				start = col;
788  				delimiters = TEXT(" \t[(\"<>");
789  				while ((start > 0) && (CharacterIs(strLine[start], delimiters) == FALSE))
790  					start--;
791  				if (CharacterIs(strLine[start], delimiters)) start++;
792  				end = col;
793  				delimiters = TEXT(" \t:()[]<>\"\r\n");
794  				while ((strLine[end] != 0) && (CharacterIs(strLine[end], delimiters) == FALSE)) end++;
795  				lstrcpyn(str, &strLine[start], static_cast<int>(end - start + 1));
796  			}
797  			if (lstrlen(str) >= int(wParam))	
798  			{
799  				return FALSE;
800  			}
801  			else 
802  			{
803  				lstrcpyn(pTchar, str, static_cast<int32_t>(wParam));
804  				return TRUE;
805  			}
806  		}
807  		case NPPM_GETNPPFULLFILEPATH:
808  		case NPPM_GETNPPDIRECTORY:
809  		{
810  			const int strSize = MAX_PATH;
811  			TCHAR str[strSize];
812  			::GetModuleFileName(NULL, str, strSize);
813  			if (message == NPPM_GETNPPDIRECTORY)
814  				PathRemoveFileSpec(str);
815  			if (wParam != 0)
816  			{
817  				if (lstrlen(str) >= int(wParam))
818  				{
819  					return FALSE;
820  				}
821  			}
822  			lstrcpy(reinterpret_cast<TCHAR *>(lParam), str);
823  			return TRUE;
824  		}
825  		case NPPM_GETCURRENTLINE:
826  		{
827  			return _pEditView->getCurrentLineNumber();
828  		}
829  		case NPPM_GETCURRENTCOLUMN:
830  		{
831  			return _pEditView->getCurrentColumnNumber();
832  		}
833  		case NPPM_GETCURRENTSCINTILLA:
834  		{
835  			int *id = reinterpret_cast<int *>(lParam);
836  			if (_pEditView == &_mainEditView)
837  				*id = MAIN_VIEW;
838  			else if (_pEditView == &_subEditView)
839  				*id = SUB_VIEW;
840  			else
841  				*id = -1;
842  			return TRUE;
843  		}
844  		case NPPM_GETCURRENTLANGTYPE:
845  		{
846  			*(reinterpret_cast<LangType *>(lParam)) = _pEditView->getCurrentBuffer()->getLangType();
847  			return TRUE;
848  		}
849  		case NPPM_SETCURRENTLANGTYPE:
850  		{
851  			_pEditView->getCurrentBuffer()->setLangType(static_cast<LangType>(lParam));
852  			return TRUE;
853  		}
854  		case NPPM_GETNBOPENFILES:
855  		{
856  			size_t nbDocPrimary = _mainDocTab.nbItem();
857  			size_t nbDocSecond = _subDocTab.nbItem();
858  			if (lParam == ALL_OPEN_FILES)
859  				return nbDocPrimary + nbDocSecond;
860  			else if (lParam == PRIMARY_VIEW)
861  				return nbDocPrimary;
862  			else if (lParam == SECOND_VIEW)
863  				return nbDocSecond;
864  			else
865  				return 0;
866  		}
867  		case NPPM_GETOPENFILENAMESPRIMARY:
868  		case NPPM_GETOPENFILENAMESSECOND:
869  		case NPPM_GETOPENFILENAMES:
870  		{
871  			if (!wParam)
872  				return 0;
873  			TCHAR** fileNames = reinterpret_cast<TCHAR**>(wParam);
874  			size_t nbFileNames = static_cast<size_t>(lParam);
875  			size_t j = 0;
876  			if (message != NPPM_GETOPENFILENAMESSECOND)
877  			{
878  				for (size_t i = 0; i < _mainDocTab.nbItem() && j < nbFileNames; ++i)
879  				{
880  					BufferID id = _mainDocTab.getBufferByIndex(i);
881  					Buffer * buf = MainFileManager.getBufferByID(id);
882  					lstrcpy(fileNames[j++], buf->getFullPathName());
883  				}
884  			}
885  			if (message != NPPM_GETOPENFILENAMESPRIMARY)
886  			{
887  				for (size_t i = 0; i < _subDocTab.nbItem() && j < nbFileNames; ++i)
888  				{
889  					BufferID id = _subDocTab.getBufferByIndex(i);
890  					Buffer * buf = MainFileManager.getBufferByID(id);
891  					lstrcpy(fileNames[j++], buf->getFullPathName());
892  				}
893  			}
894  			return j;
895  		}
896  		case WM_GETTASKLISTINFO:
897  		{
898  			if (!wParam)
899  				return 0;
900  			TaskListInfo * tli = reinterpret_cast<TaskListInfo *>(wParam);
901  			getTaskListInfo(tli);
902  			if (lParam != 0)
903  			{
904  				for (size_t idx = 0; idx < tli->_tlfsLst.size(); ++idx)
905  				{
906  					if (tli->_tlfsLst[idx]._iView == currentView() &&
907  						tli->_tlfsLst[idx]._docIndex == _pDocTab->getCurrentTabIndex())
908  					{
909  						tli->_currentIndex = static_cast<int>(idx);
910  						break;
911  					}
912  				}
913  				return TRUE;
914  			}
915  			if (NppParameters::getInstance().getNppGUI()._styleMRU)
916  			{
917  				tli->_currentIndex = 0;
918  				std::sort(tli->_tlfsLst.begin(),tli->_tlfsLst.end(),SortTaskListPred(_mainDocTab,_subDocTab));
919  			}
920  			else
921  			{
922  				for (size_t idx = 0; idx < tli->_tlfsLst.size(); ++idx)
923  				{
924  					if (tli->_tlfsLst[idx]._iView == currentView() &&
925  					    tli->_tlfsLst[idx]._docIndex == _pDocTab->getCurrentTabIndex())
926  					{
927  						tli->_currentIndex = static_cast<int>(idx);
928  						break;
929  					}
930  				}
931  			}
932  			return TRUE;
933  		}
934  		case WM_MOUSEWHEEL:
935  		{
936  			if (0 != (LOWORD(wParam) & MK_RBUTTON))
937  			{
938  				nppParam._isTaskListRBUTTONUP_Active = true;
939  				short zDelta = (short) HIWORD(wParam);
940  				return ::SendMessage(hwnd, WM_COMMAND, zDelta>0?IDC_PREV_DOC:IDC_NEXT_DOC, 0);
941  			}
942  			return TRUE;
943  		}
944  		case WM_APPCOMMAND:
945  		{
946  			switch(GET_APPCOMMAND_LPARAM(lParam))
947  			{
948  				case APPCOMMAND_BROWSER_BACKWARD:
949  				case APPCOMMAND_BROWSER_FORWARD:
950  				{
951  					size_t nbDoc = viewVisible(MAIN_VIEW) ? _mainDocTab.nbItem() : 0;
952  					nbDoc += viewVisible(SUB_VIEW)?_subDocTab.nbItem():0;
953  					if (nbDoc > 1)
954  						activateNextDoc((GET_APPCOMMAND_LPARAM(lParam) == APPCOMMAND_BROWSER_FORWARD)?dirDown:dirUp);
955  					_linkTriggered = true;
956  					break;
957  				}
958  			}
959  			return ::DefWindowProc(hwnd, message, wParam, lParam);
960  		}
961  		case NPPM_GETNBSESSIONFILES:
962  		{
963  			const TCHAR *sessionFileName = reinterpret_cast<const TCHAR *>(lParam);
964  			if ((!sessionFileName) || (sessionFileName[0] == '\0'))
965  				return 0;
966  			Session session2Load;
967  			if (nppParam.loadSession(session2Load, sessionFileName))
968  				return session2Load.nbMainFiles() + session2Load.nbSubFiles();
969  			return 0;
970  		}
971  		case NPPM_GETSESSIONFILES:
972  		{
973  			const TCHAR *sessionFileName = reinterpret_cast<const TCHAR *>(lParam);
974  			TCHAR **sessionFileArray = reinterpret_cast<TCHAR **>(wParam);
975  			if ((!sessionFileName) || (sessionFileName[0] == '\0'))
976  				return FALSE;
977  			Session session2Load;
978  			if (nppParam.loadSession(session2Load, sessionFileName))
979  			{
980  				size_t i = 0;
981  				for ( ; i < session2Load.nbMainFiles() ; )
982  				{
983  					const TCHAR *pFn = session2Load._mainViewFiles[i]._fileName.c_str();
984  					lstrcpy(sessionFileArray[i++], pFn);
985  				}
986  				for (size_t j = 0, len = session2Load.nbSubFiles(); j < len ; ++j)
987  				{
988  					const TCHAR *pFn = session2Load._subViewFiles[j]._fileName.c_str();
989  					lstrcpy(sessionFileArray[i++], pFn);
990  				}
991  				return TRUE;
992  			}
993  			return FALSE;
994  		}
995  		case NPPM_DECODESCI:
996  		{
997  			ScintillaEditView *pSci;
998  			if (wParam == MAIN_VIEW)
999  				pSci = &_mainEditView;
1000  			else if (wParam == SUB_VIEW)
1001  				pSci = &_subEditView;
1002  			else
1003  				return -1;
1004  			auto length = pSci->execute(SCI_GETTEXTLENGTH, 0, 0) + 1;
1005  			char* buffer = new char[length];
1006  			pSci->execute(SCI_GETTEXT, length, reinterpret_cast<LPARAM>(buffer));
1007  			UniMode unicodeMode = pSci->getCurrentBuffer()->getUnicodeMode();
1008  			Utf8_16_Write UnicodeConvertor;
1009  			UnicodeConvertor.setEncoding(unicodeMode);
1010  			length = UnicodeConvertor.convert(buffer, length-1);
1011  			pSci->execute(SCI_CLEARALL);
1012  			pSci->addText(length, UnicodeConvertor.getNewBuf());
1013  			pSci->execute(SCI_EMPTYUNDOBUFFER);
1014  			pSci->execute(SCI_SETCODEPAGE);
1015  			pSci->execute(SCI_GOTOPOS);
1016  			delete [] buffer;
1017  			return unicodeMode;
1018  		}
1019  		case NPPM_ENCODESCI:
1020  		{
1021  			ScintillaEditView *pSci;
1022  			if (wParam == MAIN_VIEW)
1023  				pSci = &_mainEditView;
1024  			else if (wParam == SUB_VIEW)
1025  				pSci = &_subEditView;
1026  			else
1027  				return -1;
1028  			auto length = pSci->execute(SCI_GETTEXTLENGTH, 0, 0) + 1;
1029  			char* buffer = new char[length];
1030  			pSci->execute(SCI_GETTEXT, length, reinterpret_cast<LPARAM>(buffer));
1031  			Utf8_16_Read UnicodeConvertor;
1032  			length = UnicodeConvertor.convert(buffer, length-1);
1033  			pSci->execute(SCI_CLEARALL);
1034  			pSci->addText(length, UnicodeConvertor.getNewBuf());
1035  			pSci->execute(SCI_EMPTYUNDOBUFFER);
1036  			pSci->execute(SCI_GOTOPOS);
1037  			delete [] buffer;
1038  			UniMode um = UnicodeConvertor.getEncoding();
1039  			(pSci->getCurrentBuffer())->setUnicodeMode(um);
1040  			(pSci->getCurrentBuffer())->setDirty(true);
1041  			return um;
1042  		}
1043  		case NPPM_ACTIVATEDOC:
1044  		case NPPM_TRIGGERTABBARCONTEXTMENU:
1045  		{
1046  			int whichView = ((wParam != MAIN_VIEW) && (wParam != SUB_VIEW)) ? currentView() : static_cast<int32_t>(wParam);
1047  			int index = static_cast<int32_t>(lParam);
1048  			switchEditViewTo(whichView);
1049  			activateDoc(index);
1050  			if (message == NPPM_TRIGGERTABBARCONTEXTMENU)
1051  			{
1052  				NMHDR	nmhdr{};
1053  				nmhdr.code = NM_RCLICK;
1054  				nmhdr.hwndFrom = (whichView == MAIN_VIEW)?_mainDocTab.getHSelf():_subDocTab.getHSelf();
1055  				nmhdr.idFrom = ::GetDlgCtrlID(nmhdr.hwndFrom);
1056  				::SendMessage(hwnd, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1057  			}
1058  			return TRUE;
1059  		}
1060  		case NPPM_INTERNAL_CLOSEDOC:
1061  		{
1062  			int whichView = ((wParam != MAIN_VIEW) && (wParam != SUB_VIEW)) ? currentView() : static_cast<int32_t>(wParam);
1063  			int index = static_cast<int32_t>(lParam);
1064  			switchEditViewTo(whichView);
1065  			fileClose(_pDocTab->getBufferByIndex(index), whichView);
1066  			return TRUE;
1067  		}
1068  		case NPPM_GETNPPVERSION:
1069  		{
1070  			const TCHAR* verStr = VERSION_VALUE;
1071  			TCHAR mainVerStr[16]{};
1072  			TCHAR auxVerStr[16]{};
1073  			bool isDot = false;
1074  			int j = 0;
1075  			int k = 0;
1076  			for (int i = 0; verStr[i]; ++i)
1077  			{
1078  				if (verStr[i] == '.')
1079  				{
1080  					isDot = true;
1081  				}
1082  				else
1083  				{
1084  					if (!isDot)
1085  						mainVerStr[j++] = verStr[i];
1086  					else
1087  						auxVerStr[k++] = verStr[i];
1088  				}
1089  			}
1090  			mainVerStr[j] = '\0';
1091  			auxVerStr[k] = '\0';
1092  			bool addZeroPadding = wParam == TRUE;
1093  			if (addZeroPadding)
1094  			{
1095  				size_t nbDigit = lstrlen(auxVerStr);
1096  				if (nbDigit > 0 && nbDigit <= 3)
1097  				{
1098  					if (nbDigit == 3)
1099  					{
1100  					}
1101  					else if (nbDigit == 2)
1102  					{
1103  						auxVerStr[2] = '0';
1104  						auxVerStr[3] = '\0';
1105  					}
1106  					else 
1107  					{
1108  						auxVerStr[1] = '0';
1109  						auxVerStr[2] = '0';
1110  						auxVerStr[3] = '\0';
1111  					}
1112  				}
1113  			}
1114  			int mainVer = 0, auxVer = 0;
1115  			if (mainVerStr[0])
1116  				mainVer = _wtoi(mainVerStr);
1117  			if (auxVerStr[0])
1118  				auxVer = _wtoi(auxVerStr);
1119  			return MAKELONG(auxVer, mainVer);
1120  		}
1121  		case NPPM_GETCURRENTMACROSTATUS:
1122  		{
1123  			if (_recordingMacro)
1124  				return static_cast<LRESULT>(MacroStatus::RecordInProgress);
1125  			if (_playingBackMacro)
1126  				return static_cast<LRESULT>(MacroStatus::PlayingBack);
1127  			return (_macro.empty()) ? static_cast<LRESULT>(MacroStatus::Idle) : static_cast<LRESULT>(MacroStatus::RecordingStopped);
1128  		}
1129  		case NPPM_GETCURRENTCMDLINE:
1130  		{
1131  			generic_string cmdLineString = nppParam.getCmdLineString();
1132  			if (lParam != 0)
1133  			{
1134  				if (cmdLineString.length() >= static_cast<size_t>(wParam))
1135  				{
1136  					return 0;
1137  				}
1138  				lstrcpy(reinterpret_cast<TCHAR*>(lParam), cmdLineString.c_str());
1139  			}
1140  			return cmdLineString.length();
1141  		}
1142  		case NPPM_CREATELEXER:
1143  		{
1144  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1145  			const char* lexer_name = wmc.wchar2char(reinterpret_cast<TCHAR*>(lParam), CP_ACP);
1146  			return (LRESULT) CreateLexer(lexer_name);
1147  		}
1148  		case WM_FRSAVE_INT:
1149  		{
1150  			_macro.push_back(recordedMacroStep(static_cast<int32_t>(wParam), 0, lParam, NULL, recordedMacroStep::mtSavedSnR));
1151  			break;
1152  		}
1153  		case WM_FRSAVE_STR:
1154  		{
1155  			_macro.push_back(recordedMacroStep(static_cast<int32_t>(wParam), 0, 0, reinterpret_cast<const char *>(lParam), recordedMacroStep::mtSavedSnR));
1156  			break;
1157  		}
1158  		case WM_MACRODLGRUNMACRO:
1159  		{
1160  			if (!_recordingMacro) 
1161  			{
1162  				int times = _runMacroDlg.isMulti() ? _runMacroDlg.getTimes() : -1;
1163  				int counter = 0;
1164  				intptr_t lastLine = _pEditView->execute(SCI_GETLINECOUNT) - 1;
1165  				intptr_t currLine = _pEditView->getCurrentLineNumber();
1166  				int indexMacro = _runMacroDlg.getMacro2Exec();
1167  				intptr_t deltaLastLine = 0;
1168  				intptr_t deltaCurrLine = 0;
1169  				bool cursorMovedUp = false;
1170  				Macro m = _macro;
1171  				if (indexMacro != -1)
1172  				{
1173  					vector<MacroShortcut> & ms = nppParam.getMacroList();
1174  					m = ms[indexMacro].getMacro();
1175  				}
1176  				_pEditView->execute(SCI_BEGINUNDOACTION);
1177  				for (;;)
1178  				{
1179  					macroPlayback(m);
1180  					++counter;
1181  					if ( times >= 0 )
1182  					{
1183  						if ( counter >= times )
1184  							break;
1185  					}
1186  					else 
1187  					{
1188  						if (counter > 2 && cursorMovedUp != (deltaCurrLine < 0) && deltaLastLine >= 0)
1189  						{
1190  							break;
1191  						}
1192  						cursorMovedUp = deltaCurrLine < 0;
1193  						deltaLastLine = _pEditView->execute(SCI_GETLINECOUNT) - 1 - lastLine;
1194  						deltaCurrLine = _pEditView->getCurrentLineNumber() - currLine;
1195  						if (( deltaCurrLine == 0 )	
1196  							&& (deltaLastLine >= 0))  
1197  							break; 
1198  						if (deltaLastLine < deltaCurrLine)
1199  							lastLine += deltaLastLine;
1200  						currLine += deltaCurrLine;
1201  						if ((currLine > lastLine) || (currLine < 0)
1202  							|| ((deltaCurrLine == 0) && (currLine == 0) && ((deltaLastLine >= 0) || cursorMovedUp)))
1203  						{
1204  							break;
1205  						}
1206  					}
1207  				}
1208  				_pEditView->execute(SCI_ENDUNDOACTION);
1209  			}
1210  			break;
1211  		}
1212  		case NPPM_CREATESCINTILLAHANDLE:
1213  		{
1214  			return (LRESULT)_scintillaCtrls4Plugins.createSintilla((lParam ? reinterpret_cast<HWND>(lParam) : hwnd));
1215  		}
1216  		case NPPM_INTERNAL_GETSCINTEDTVIEW:
1217  		{
1218  			return (LRESULT)_scintillaCtrls4Plugins.getScintillaEditViewFrom(reinterpret_cast<HWND>(lParam));
1219  		}
1220  		case NPPM_INTERNAL_ENABLESNAPSHOT:
1221  		{
1222  			launchDocumentBackupTask();
1223  			return TRUE;
1224  		}
1225  		case NPPM_DESTROYSCINTILLAHANDLE:
1226  		{
1227  			return true;
1228  		}
1229  		case NPPM_GETNBUSERLANG:
1230  		{
1231  			if (lParam)
1232  				*(reinterpret_cast<int *>(lParam)) = IDM_LANG_USER;
1233  			return nppParam.getNbUserLang();
1234  		}
1235  		case NPPM_GETCURRENTDOCINDEX:
1236  		{
1237  			if (lParam == SUB_VIEW)
1238  			{
1239  				if (!viewVisible(SUB_VIEW))
1240  					return -1;
1241  				return _subDocTab.getCurrentTabIndex();
1242  			}
1243  			else 
1244  			{
1245  				if (!viewVisible(MAIN_VIEW))
1246  					return -1;
1247  				return _mainDocTab.getCurrentTabIndex();
1248  			}
1249  		}
1250  		case NPPM_SETSTATUSBAR:
1251  		{
1252  			TCHAR *str2set = reinterpret_cast<TCHAR *>(lParam);
1253  			if (!str2set || !str2set[0])
1254  				return FALSE;
1255  			switch (wParam)
1256  			{
1257  				case STATUSBAR_DOC_TYPE:
1258  				case STATUSBAR_DOC_SIZE:
1259  				case STATUSBAR_CUR_POS:
1260  				case STATUSBAR_EOF_FORMAT:
1261  				case STATUSBAR_UNICODE_TYPE:
1262  				case STATUSBAR_TYPING_MODE:
1263  					_statusBar.setText(str2set, static_cast<int32_t>(wParam));
1264  					return TRUE;
1265  				default :
1266  					return FALSE;
1267  			}
1268  		}
1269  		case NPPM_GETMENUHANDLE:
1270  		{
1271  			if (wParam == NPPPLUGINMENU)
1272  				return (LRESULT)_pluginsManager.getMenuHandle();
1273  			else if (wParam == NPPMAINMENU)
1274  				return (LRESULT)_mainMenuHandle;
1275  			else
1276  				return static_cast<LRESULT>(NULL);
1277  		}
1278  		case NPPM_LOADSESSION:
1279  		{
1280  			fileLoadSession(reinterpret_cast<const TCHAR *>(lParam));
1281  			return TRUE;
1282  		}
1283  		case NPPM_SAVECURRENTSESSION:
1284  		{
1285  			return (LRESULT)fileSaveSession(0, NULL, reinterpret_cast<const TCHAR *>(lParam));
1286  		}
1287  		case NPPM_SAVESESSION:
1288  		{
1289  			sessionInfo *pSi = reinterpret_cast<sessionInfo *>(lParam);
1290  			return (LRESULT)fileSaveSession(pSi->nbFile, pSi->files, pSi->sessionFilePathName);
1291  		}
1292  		case NPPM_INTERNAL_CLEARSCINTILLAKEY:
1293  		{
1294  			_mainEditView.execute(SCI_CLEARCMDKEY, wParam);
1295  			_subEditView.execute(SCI_CLEARCMDKEY, wParam);
1296  			return TRUE;
1297  		}
1298  		case NPPM_INTERNAL_BINDSCINTILLAKEY:
1299  		{
1300  			_mainEditView.execute(SCI_ASSIGNCMDKEY, wParam, lParam);
1301  			_subEditView.execute(SCI_ASSIGNCMDKEY, wParam, lParam);
1302  			return TRUE;
1303  		}
1304  		case NPPM_INTERNAL_CMDLIST_MODIFIED:
1305  		{
1306  			::DrawMenuBar(hwnd);
1307  			return TRUE;
1308  		}
1309  		case NPPM_INTERNAL_MACROLIST_MODIFIED:
1310  		{
1311  			return TRUE;
1312  		}
1313  		case NPPM_INTERNAL_USERCMDLIST_MODIFIED:
1314  		{
1315  			return TRUE;
1316  		}
1317  		case NPPM_INTERNAL_FINDKEYCONFLICTS:
1318  		{
1319  			if (!wParam || !lParam) 
1320  			{
1321  				delete _pShortcutMapper;
1322  				_pShortcutMapper = nullptr;
1323  				return TRUE;
1324  			}
1325  			if (_pShortcutMapper == nullptr) 
1326  			{
1327  				_pShortcutMapper = new ShortcutMapper;
1328  				if (_pShortcutMapper == nullptr)
1329  					break;
1330  			}
1331  			*reinterpret_cast<bool*>(lParam) = _pShortcutMapper->findKeyConflicts(nullptr, *reinterpret_cast<KeyCombo*>(wParam), (size_t)-1);
1332  			return TRUE;
1333  		}
1334  		case NPPM_INTERNAL_SETCARETWIDTH:
1335  		{
1336  			const NppGUI & nppGUI = nppParam.getNppGUI();
1337  			if (nppGUI._caretWidth < 4)
1338  			{
1339  				_mainEditView.execute(SCI_SETCARETSTYLE, CARETSTYLE_LINE);
1340  				_subEditView.execute(SCI_SETCARETSTYLE, CARETSTYLE_LINE);
1341  				_mainEditView.execute(SCI_SETCARETWIDTH, nppGUI._caretWidth);
1342  				_subEditView.execute(SCI_SETCARETWIDTH, nppGUI._caretWidth);
1343  			}
1344  			else if (nppGUI._caretWidth == 4)
1345  			{
1346  				_mainEditView.execute(SCI_SETCARETWIDTH, 1);
1347  				_subEditView.execute(SCI_SETCARETWIDTH, 1);
1348  				_mainEditView.execute(SCI_SETCARETSTYLE, CARETSTYLE_BLOCK);
1349  				_subEditView.execute(SCI_SETCARETSTYLE, CARETSTYLE_BLOCK);
1350  			}
1351  			else 
1352  			{
1353  				_mainEditView.execute(SCI_SETCARETWIDTH, 1);
1354  				_subEditView.execute(SCI_SETCARETWIDTH, 1);
1355  				_mainEditView.execute(SCI_SETCARETSTYLE, CARETSTYLE_BLOCK | CARETSTYLE_BLOCK_AFTER);
1356  				_subEditView.execute(SCI_SETCARETSTYLE, CARETSTYLE_BLOCK | CARETSTYLE_BLOCK_AFTER);
1357  			}
1358  			return TRUE;
1359  		}
1360  		case NPPM_SETSMOOTHFONT:
1361  		{
1362  			int param = (lParam == 0 ? SC_EFF_QUALITY_DEFAULT : SC_EFF_QUALITY_LCD_OPTIMIZED);
1363  			_mainEditView.execute(SCI_SETFONTQUALITY, param);
1364  			_subEditView.execute(SCI_SETFONTQUALITY, param);
1365  			return TRUE;
1366  		}
1367  		case NPPM_INTERNAL_CARETLINEFRAME:
1368  		{
1369  			_mainEditView.execute(SCI_SETCARETLINEFRAME, lParam);
1370  			_subEditView.execute(SCI_SETCARETLINEFRAME, lParam);
1371  			return TRUE;
1372  		}
1373  		case NPPM_SETEDITORBORDEREDGE:
1374  		{
1375  			bool withBorderEdge = (lParam == 1);
1376  			_mainEditView.setBorderEdge(withBorderEdge);
1377  			_subEditView.setBorderEdge(withBorderEdge);
1378  			return TRUE;
1379  		}
1380  		case NPPM_INTERNAL_VIRTUALSPACE:
1381  		{
1382  			const bool virtualSpace = (nppParam.getSVP())._virtualSpace;
1383  			int virtualSpaceOptions = SCVS_RECTANGULARSELECTION;
1384  			if(virtualSpace)
1385  				virtualSpaceOptions |= SCVS_USERACCESSIBLE | SCVS_NOWRAPLINESTART;
1386  			_mainEditView.execute(SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions);
1387  			_subEditView.execute(SCI_SETVIRTUALSPACEOPTIONS, virtualSpaceOptions);
1388  			return TRUE;
1389  		}
1390  		case NPPM_INTERNAL_SCROLLBEYONDLASTLINE:
1391  		{
1392  			const bool endAtLastLine = !(nppParam.getSVP())._scrollBeyondLastLine;
1393  			_mainEditView.execute(SCI_SETENDATLASTLINE, endAtLastLine);
1394  			_subEditView.execute(SCI_SETENDATLASTLINE, endAtLastLine);
1395  			return TRUE;
1396  		}
1397  		case NPPM_INTERNAL_SETWORDCHARS:
1398  		{
1399  			_mainEditView.setWordChars();
1400  			_subEditView.setWordChars();
1401  			return TRUE;
1402  		}
1403  		case NPPM_INTERNAL_SETNPC:
1404  		{
1405  			const auto& svp = nppParam.getSVP();
1406  			const bool isFromIncCcUniEolCtrl = wParam == IDC_CHECK_NPC_INCLUDECCUNIEOL;
1407  			if (isFromIncCcUniEolCtrl || svp._npcIncludeCcUniEol)
1408  			{
1409  				const bool isShown = svp._ccUniEolShow;
1410  				_mainEditView.showCcUniEol(isShown);
1411  				_subEditView.showCcUniEol(isShown);
1412  			}
1413  			if (!isFromIncCcUniEolCtrl)
1414  			{
1415  				const bool isShown = svp._npcShow;
1416  				_mainEditView.showNpc(isShown);
1417  				_subEditView.showNpc(isShown);
1418  				_findReplaceDlg.updateFinderScintillaForNpc();
1419  			}
1420  			return TRUE;
1421  		}
1422  		case NPPM_INTERNAL_SETMULTISELCTION:
1423  		{
1424  			const NppGUI & nppGUI = nppParam.getNppGUI();
1425  			_mainEditView.execute(SCI_SETMULTIPLESELECTION, nppGUI._enableMultiSelection);
1426  			_subEditView.execute(SCI_SETMULTIPLESELECTION, nppGUI._enableMultiSelection);
1427  			return TRUE;
1428  		}
1429  		case NPPM_INTERNAL_SETCARETBLINKRATE:
1430  		{
1431  			const NppGUI & nppGUI = nppParam.getNppGUI();
1432  			_mainEditView.execute(SCI_SETCARETPERIOD, nppGUI._caretBlinkRate);
1433  			_subEditView.execute(SCI_SETCARETPERIOD, nppGUI._caretBlinkRate);
1434  			return TRUE;
1435  		}
1436  		case NPPM_INTERNAL_ISTABBARREDUCED:
1437  		{
1438  			return _toReduceTabBar?TRUE:FALSE;
1439  		}
1440  		case NPPM_MODELESSDIALOG:
1441  		{
1442  			if (wParam == MODELESSDIALOGADD)
1443  			{
1444  				for (size_t i = 0, len = _hModelessDlgs.size() ; i < len ; ++i)
1445  				{
1446  					if (_hModelessDlgs[i] == reinterpret_cast<HWND>(lParam))
1447  						return static_cast<LRESULT>(NULL);
1448  				}
1449  				_hModelessDlgs.push_back(reinterpret_cast<HWND>(lParam));
1450  				return lParam;
1451  			}
1452  			else
1453  			{
1454  				if (wParam == MODELESSDIALOGREMOVE)
1455  				{
1456  					for (size_t i = 0, len = _hModelessDlgs.size(); i < len ; ++i)
1457  					{
1458  						if (_hModelessDlgs[i] == reinterpret_cast<HWND>(lParam))
1459  						{
1460  							vector<HWND>::iterator hDlg = _hModelessDlgs.begin() + i;
1461  							_hModelessDlgs.erase(hDlg);
1462  							return static_cast<LRESULT>(NULL);
1463  						}
1464  					}
1465  					return lParam;
1466  				}
1467  			}
1468  			return TRUE;
1469  		}
1470  		case WM_CONTEXTMENU:
1471  		{
1472  			if (nppParam._isTaskListRBUTTONUP_Active)
1473  			{
1474  				nppParam._isTaskListRBUTTONUP_Active = false;
1475  			}
1476  			else
1477  			{
1478  				if ((HWND(wParam) == _mainEditView.getHSelf()) || (HWND(wParam) == _subEditView.getHSelf()))
1479  				{
1480  					if ((HWND(wParam) == _mainEditView.getHSelf()))
1481  						switchEditViewTo(MAIN_VIEW);
1482  					else
1483  						switchEditViewTo(SUB_VIEW);
1484  					POINT p;
1485  					::GetCursorPos(&p);
1486  					ContextMenu scintillaContextmenu;
1487  					std::vector<MenuItemUnit>& tmp = nppParam.getContextMenuItems();
1488  					bool copyLink = (_pEditView->getSelectedTextCount() == 0) && _pEditView->getIndicatorRange(URL_INDIC);
1489  					scintillaContextmenu.create(hwnd, tmp, _mainMenuHandle, copyLink);
1490  					scintillaContextmenu.display(p);
1491  					return TRUE;
1492  				}
1493  			}
1494  			return ::DefWindowProc(hwnd, message, wParam, lParam);
1495  		}
1496  		case WM_NOTIFY:
1497  		{
1498  			NMHDR* nmhdr = reinterpret_cast<NMHDR*>(lParam);
1499  			if (nmhdr->code == NM_CUSTOMDRAW && (nmhdr->hwndFrom == _toolBar.getHSelf()))
1500  			{
1501  				NMTBCUSTOMDRAW* nmtbcd = reinterpret_cast<NMTBCUSTOMDRAW*>(lParam);
1502  				if (nmtbcd->nmcd.dwDrawStage == CDDS_PREERASE)
1503  				{
1504  					if (NppDarkMode::isEnabled())
1505  					{
1506  						FillRect(nmtbcd->nmcd.hdc, &nmtbcd->nmcd.rc, NppDarkMode::getDarkerBackgroundBrush());
1507  						nmtbcd->clrText = NppDarkMode::getTextColor();
1508  						SetTextColor(nmtbcd->nmcd.hdc, NppDarkMode::getTextColor());
1509  						return CDRF_SKIPDEFAULT;
1510  					}
1511  					else
1512  					{
1513  						return CDRF_DODEFAULT;
1514  					}
1515  				}
1516  			}
1517  			SCNotification *notification = reinterpret_cast<SCNotification *>(lParam);
1518  			if (notification->nmhdr.code == SCN_UPDATEUI)
1519  			{
1520  				checkClipboard(); 
1521  				checkUndoState(); 
1522  			}
1523  			if (wParam == LINKTRIGGERED)
1524  				notification->wParam = LINKTRIGGERED;
1525  			_pluginsManager.notify(notification);
1526  			return notify(notification);
1527  		}
1528  		case WM_ACTIVATEAPP:
1529  		{
1530  			if (wParam == TRUE) 
1531  			{
1532  				::PostMessage(hwnd, NPPM_INTERNAL_CHECKDOCSTATUS, 0, 0);
1533  			}
1534  			return FALSE;
1535  		}
1536  		case NPPM_INTERNAL_CHECKDOCSTATUS:
1537  		{
1538  			Buffer* currBuf = getCurrentBuffer();
1539  			if (currBuf && currBuf->isMonitoringOn())
1540  				::PathFileExists(currBuf->getFullPathName());
1541  			const NppGUI & nppgui = nppParam.getNppGUI();
1542  			if (nppgui._fileAutoDetection != cdDisabled)
1543  			{
1544  				bool bCheckOnlyCurrentBuffer = (nppgui._fileAutoDetection & cdEnabledNew) ? true : false;
1545  				checkModifiedDocument(bCheckOnlyCurrentBuffer);
1546  				return TRUE;
1547  			}
1548  			return FALSE;
1549  		}
1550  		case NPPM_INTERNAL_RELOADSCROLLTOEND:
1551  		{
1552  			Buffer *buf = reinterpret_cast<Buffer *>(wParam);
1553  			buf->reload();
1554  			return TRUE;
1555  		}
1556  		case NPPM_INTERNAL_STOPMONITORING:
1557  		{
1558  			Buffer *buf = reinterpret_cast<Buffer *>(wParam);
1559  			monitoringStartOrStopAndUpdateUI(buf, false);
1560  			return TRUE;
1561  		}
1562  		case NPPM_GETPOSFROMBUFFERID:
1563  		{
1564  			int i;
1565  			if (lParam == SUB_VIEW)
1566  			{
1567  				if ((i = _subDocTab.getIndexByBuffer((BufferID)wParam)) != -1)
1568  				{
1569  					long view = SUB_VIEW;
1570  					view <<= 30;
1571  					return view|i;
1572  				}
1573  				if ((i = _mainDocTab.getIndexByBuffer((BufferID)wParam)) != -1)
1574  				{
1575  					long view = MAIN_VIEW;
1576  					view <<= 30;
1577  					return view|i;
1578  				}
1579  			}
1580  			else
1581  			{
1582  				if ((i = _mainDocTab.getIndexByBuffer((BufferID)wParam)) != -1)
1583  				{
1584  					long view = MAIN_VIEW;
1585  					view <<= 30;
1586  					return view|i;
1587  				}
1588  				if ((i = _subDocTab.getIndexByBuffer((BufferID)wParam)) != -1)
1589  				{
1590  					long view = SUB_VIEW;
1591  					view <<= 30;
1592  					return view|i;
1593  				}
1594  			}
1595  			return -1;
1596  		}
1597  		case NPPM_GETFULLPATHFROMBUFFERID:
1598  		{
1599  			return MainFileManager.getFileNameFromBuffer(reinterpret_cast<BufferID>(wParam), reinterpret_cast<TCHAR *>(lParam));
1600  		}
1601  		case NPPM_INTERNAL_ENABLECHECKDOCOPT:
1602  		{
1603  			NppGUI& nppgui = nppParam.getNppGUI();
1604  			if (wParam == CHECKDOCOPT_NONE)
1605  				nppgui._fileAutoDetection = cdDisabled;
1606  			else if (wParam == CHECKDOCOPT_UPDATESILENTLY)
1607  				nppgui._fileAutoDetection = (cdEnabledOld | cdAutoUpdate);
1608  			else if (wParam == CHECKDOCOPT_UPDATEGO2END)
1609  				nppgui._fileAutoDetection = (cdEnabledOld | cdGo2end);
1610  			else if (wParam == (CHECKDOCOPT_UPDATESILENTLY | CHECKDOCOPT_UPDATEGO2END))
1611  				nppgui._fileAutoDetection = (cdEnabledOld | cdGo2end | cdAutoUpdate);
1612  			return TRUE;
1613  		}
1614  		case WM_ACTIVATE:
1615  		{
1616  			if (wParam != WA_INACTIVE && _pEditView && _pNonEditView)
1617  			{
1618  				_pEditView->getFocus();
1619  				auto x = _pEditView->execute(SCI_GETXOFFSET);
1620  				_pEditView->execute(SCI_SETXOFFSET, x);
1621  				x = _pNonEditView->execute(SCI_GETXOFFSET);
1622  				_pNonEditView->execute(SCI_SETXOFFSET, x);
1623  			}
1624  			return TRUE;
1625  		}
1626  		case WM_SYNCPAINT:
1627  		{
1628  			RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
1629  			break;
1630  		}
1631  		case WM_DROPFILES:
1632  		{
1633  			dropFiles(reinterpret_cast<HDROP>(wParam));
1634  			return TRUE;
1635  		}
1636  		case WM_UPDATESCINTILLAS:
1637  		{
1638  			_mainEditView.defineDocType(_mainEditView.getCurrentBuffer()->getLangType());
1639  			_mainEditView.performGlobalStyles();
1640  			addHotSpot(& _mainEditView);
1641  			_subEditView.defineDocType(_subEditView.getCurrentBuffer()->getLangType());
1642  			_subEditView.performGlobalStyles();
1643  			addHotSpot(& _subEditView);
1644  			_findReplaceDlg.updateFinderScintilla();
1645  			drawTabbarColoursFromStylerArray();
1646  			drawDocumentMapColoursFromStylerArray();
1647  			const Style* pStyle = NppParameters::getInstance().getGlobalStylers().findByID(STYLE_DEFAULT);
1648  			if (pStyle)
1649  			{
1650  				NppParameters::getInstance().setCurrentDefaultFgColor(pStyle->_fgColor);
1651  				NppParameters::getInstance().setCurrentDefaultBgColor(pStyle->_bgColor);
1652  				drawAutocompleteColoursFromTheme(pStyle->_fgColor, pStyle->_bgColor);
1653  			}
1654  			AutoCompletion::drawAutocomplete(_pEditView);
1655  			AutoCompletion::drawAutocomplete(_pNonEditView);
1656  			NppDarkMode::calculateTreeViewStyle();
1657  			auto refreshOnlyTreeView = static_cast<LPARAM>(TRUE);
1658  			if (pStyle && _pFuncList)
1659  			{
1660  				_pFuncList->setBackgroundColor(pStyle->_bgColor);
1661  				_pFuncList->setForegroundColor(pStyle->_fgColor);
1662  				::SendMessage(_pFuncList->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, refreshOnlyTreeView);
1663  			}
1664  			if (pStyle && _pAnsiCharPanel)
1665  			{
1666  				_pAnsiCharPanel->setBackgroundColor(pStyle->_bgColor);
1667  				_pAnsiCharPanel->setForegroundColor(pStyle->_fgColor);
1668  			}
1669  			if (pStyle && _pDocumentListPanel)
1670  			{
1671  				_pDocumentListPanel->setBackgroundColor(pStyle->_bgColor);
1672  				_pDocumentListPanel->setForegroundColor(pStyle->_fgColor);
1673  			}
1674  			if (pStyle && _pClipboardHistoryPanel)
1675  			{
1676  				_pClipboardHistoryPanel->setBackgroundColor(pStyle->_bgColor);
1677  				_pClipboardHistoryPanel->setForegroundColor(pStyle->_fgColor);
1678  				_pClipboardHistoryPanel->redraw(true);
1679  			}
1680  			if (pStyle && _pProjectPanel_1)
1681  			{
1682  				_pProjectPanel_1->setBackgroundColor(pStyle->_bgColor);
1683  				_pProjectPanel_1->setForegroundColor(pStyle->_fgColor);
1684  				::SendMessage(_pProjectPanel_1->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, refreshOnlyTreeView);
1685  			}
1686  			if (pStyle && _pProjectPanel_2)
1687  			{
1688  				_pProjectPanel_2->setBackgroundColor(pStyle->_bgColor);
1689  				_pProjectPanel_2->setForegroundColor(pStyle->_fgColor);
1690  				::SendMessage(_pProjectPanel_2->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, refreshOnlyTreeView);
1691  			}
1692  			if (pStyle && _pProjectPanel_3)
1693  			{
1694  				_pProjectPanel_3->setBackgroundColor(pStyle->_bgColor);
1695  				_pProjectPanel_3->setForegroundColor(pStyle->_fgColor);
1696  				::SendMessage(_pProjectPanel_3->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, refreshOnlyTreeView);
1697  			}
1698  			if (pStyle && _pFileBrowser)
1699  			{
1700  				_pFileBrowser->setBackgroundColor(pStyle->_bgColor);
1701  				_pFileBrowser->setForegroundColor(pStyle->_fgColor);
1702  				::SendMessage(_pFileBrowser->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, refreshOnlyTreeView);
1703  			}
1704  			if (_pDocMap)
1705  				_pDocMap->setSyntaxHiliting();
1706  			SCNotification scnN{};
1707  			scnN.nmhdr.code = NPPN_WORDSTYLESUPDATED;
1708  			scnN.nmhdr.hwndFrom = hwnd;
1709  			scnN.nmhdr.idFrom = (uptr_t) _pEditView->getCurrentBufferID();
1710  			_pluginsManager.notify(&scnN);
1711  			return TRUE;
1712  		}
1713  		case WM_UPDATEMAINMENUBITMAPS:
1714  		{
1715  			setupColorSampleBitmapsOnMainMenuItems();
1716  			return TRUE;
1717  		}
1718  		case NPPM_INTERNAL_WINDOWSSESSIONEXIT:
1719  		{
1720  			int answer = _nativeLangSpeaker.messageBox("WindowsSessionExit",
1721  				_pPublicInterface->getHSelf(),
1722  				TEXT("Windows session is about to be terminated but you have some data unsaved. Do you want to exit Notepad++ now?"),
1723  				TEXT("Notepad++ - Windows session exit"),
1724  				MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);
1725  			if (answer == IDYES)
1726  				::PostMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
1727  			return TRUE;
1728  		}
1729  		case NPPM_INTERNAL_EXTERNALLEXERBUFFER:
1730  		{
1731  			SCNotification scnN{};
1732  			scnN.nmhdr.code = NPPN_EXTERNALLEXERBUFFER;
1733  			scnN.nmhdr.hwndFrom = hwnd;
1734  			scnN.nmhdr.idFrom = lParam;
1735  			_pluginsManager.notify(&scnN);
1736  			return TRUE;
1737  		}
1738  		case WM_QUERYENDSESSION:
1739  		{
1740  			bool isFirstQueryEndSession = !nppParam.isEndSessionStarted();
1741  			bool isForcedShuttingDown = (lParam & ENDSESSION_CRITICAL);
1742  			nppParam.endSessionStart();
1743  			if (isForcedShuttingDown)
1744  				nppParam.makeEndSessionCritical();
1745  			if (nppParam.doNppLogNulContentCorruptionIssue())
1746  			{
1747  				generic_string issueFn = nppLogNulContentCorruptionIssue;
1748  				issueFn += TEXT(".log");
1749  				generic_string nppIssueLog = nppParam.getUserPath();
1750  				pathAppend(nppIssueLog, issueFn);
1751  				string wmqesType = std::to_string(lParam);
1752  				if (lParam == 0)
1753  				{
1754  					wmqesType += " - ordinary system shutdown/restart";
1755  				}
1756  				else
1757  				{
1758  					if (lParam & ENDSESSION_CLOSEAPP)
1759  						wmqesType += " - ENDSESSION_CLOSEAPP";
1760  					if (lParam & ENDSESSION_CRITICAL)
1761  						wmqesType += " - ENDSESSION_CRITICAL";
1762  					if (lParam & ENDSESSION_LOGOFF)
1763  						wmqesType += " - ENDSESSION_LOGOFF";
1764  				}
1765  				string msg = "WM_QUERYENDSESSION (lParam: " + wmqesType + ") =====================================";
1766  				writeLog(nppIssueLog.c_str(), msg.c_str());
1767  			}
1768  			if (::IsWindowEnabled(hwnd))
1769  			{
1770  				if (MainFileManager.getNbDirtyBuffers() > 0)
1771  				{
1772  					if (!isForcedShuttingDown && isFirstQueryEndSession && !nppParam.getNppGUI().isSnapshotMode())
1773  					{
1774  						if (::IsIconic(hwnd))
1775  						{
1776  							::ShowWindow(hwnd, SW_RESTORE);
1777  						}
1778  						else
1779  						{
1780  							if (!::IsWindowVisible(hwnd))
1781  							{
1782  								::ShowWindow(hwnd, SW_SHOW);
1783  								::SendMessage(hwnd, WM_SIZE, 0, 0);	
1784  							}
1785  						}
1786  						::PostMessage(hwnd, NPPM_INTERNAL_WINDOWSSESSIONEXIT, 0, 0); 
1787  						return FALSE; 
1788  					}
1789  				}
1790  			}
1791  			else
1792  			{
1793  				if (!isForcedShuttingDown && isFirstQueryEndSession)
1794  					return FALSE; 
1795  				string strLog = "Main Notepad++ wnd is disabled by (an active modal-dlg?):  ";
1796  				char szBuf[MAX_PATH + 128] = { 0 };
1797  				HWND hActiveWnd = ::GetActiveWindow();
1798  				if (hActiveWnd)
1799  				{
1800  					if (::GetWindowTextA(hActiveWnd, szBuf, _countof(szBuf)))
1801  						strLog += szBuf;
1802  					::SendMessage(hActiveWnd, WM_CLOSE, 0, 0);
1803  				}
1804  				else
1805  				{
1806  					hActiveWnd = ::GetLastActivePopup(hwnd);
1807  					if (hActiveWnd)
1808  					{
1809  						if (::GetWindowTextA(hActiveWnd, szBuf, _countof(szBuf)))
1810  							strLog += szBuf;
1811  						::GetClassNameA(hActiveWnd, szBuf, _countof(szBuf));
1812  						if (lstrcmpiA("#32770", szBuf) == 0)
1813  							strLog += " (MessageBox)";
1814  						if (!::EndDialog(hActiveWnd, 0))
1815  						{
1816  							strLog += "  -> EndDialog failed with ErrorCode: ";
1817  							strLog += std::to_string(::GetLastError());
1818  							::SendMessage(hActiveWnd, WM_SYSCOMMAND, SC_CLOSE, 0);
1819  						}
1820  					}
1821  					else
1822  					{
1823  						strLog += "???";
1824  					}
1825  				}
1826  				if (::IsWindowEnabled(hwnd))
1827  					strLog += "  -> Main Notepad++ wnd has been successfully reenabled.";
1828  				if (nppParam.doNppLogNulContentCorruptionIssue())
1829  				{
1830  					generic_string issueFn = nppLogNulContentCorruptionIssue;
1831  					issueFn += TEXT(".log");
1832  					generic_string nppIssueLog = nppParam.getUserPath();
1833  					pathAppend(nppIssueLog, issueFn);
1834  					writeLog(nppIssueLog.c_str(), strLog.c_str());
1835  				}
1836  			}
1837  			return TRUE; 
1838  		}
1839  		case WM_ENDSESSION:
1840  		{
1841  			if (nppParam.doNppLogNulContentCorruptionIssue())
1842  			{
1843  				generic_string issueFn = nppLogNulContentCorruptionIssue;
1844  				issueFn += TEXT(".log");
1845  				generic_string nppIssueLog = nppParam.getUserPath();
1846  				pathAppend(nppIssueLog, issueFn);
1847  				string wmesType = std::to_string(lParam);
1848  				if (lParam == 0)
1849  				{
1850  					wmesType += " - ordinary system shutdown/restart";
1851  				}
1852  				else
1853  				{
1854  					if (lParam & ENDSESSION_CLOSEAPP)
1855  						wmesType += " - ENDSESSION_CLOSEAPP";
1856  					if (lParam & ENDSESSION_CRITICAL)
1857  						wmesType += " - ENDSESSION_CRITICAL";
1858  					if (lParam & ENDSESSION_LOGOFF)
1859  						wmesType += " - ENDSESSION_LOGOFF";
1860  				}
1861  				string msg = "WM_ENDSESSION (wParam: ";
1862  				if (wParam)
1863  					msg += "TRUE, lParam: ";
1864  				else
1865  					msg += "FALSE, lParam: ";
1866  				msg += wmesType + ")";
1867  				writeLog(nppIssueLog.c_str(), msg.c_str());
1868  			}
1869  			if (wParam == FALSE)
1870  			{
1871  				return 0; 
1872  			}
1873  			else
1874  			{
1875  				nppParam.endSessionStart(); 
1876  				nppParam.makeEndSessionCritical(); 
1877  				[[fallthrough]];
1878  			}
1879  		} 
1880  		case WM_CLOSE:
1881  		{
1882  			if (nppParam.doNppLogNulContentCorruptionIssue() && nppParam.isEndSessionStarted() && (message == WM_CLOSE))
1883  			{
1884  				generic_string issueFn = nppLogNulContentCorruptionIssue;
1885  				issueFn += TEXT(".log");
1886  				generic_string nppIssueLog = nppParam.getUserPath();
1887  				pathAppend(nppIssueLog, issueFn);
1888  				writeLog(nppIssueLog.c_str(), "WM_CLOSE (isEndSessionStarted == true)");
1889  			}
1890  			if (_pPublicInterface->isPrelaunch())
1891  			{
1892  				SendMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);
1893  			}
1894  			else
1895  			{
1896  				SCNotification scnN{};
1897  				scnN.nmhdr.hwndFrom = hwnd;
1898  				scnN.nmhdr.idFrom = 0;
1899  				scnN.nmhdr.code = NPPN_BEFORESHUTDOWN;
1900  				_pluginsManager.notify(&scnN);
1901  				if (_pTrayIco)
1902  					_pTrayIco->doTrayIcon(REMOVE);
1903  				const NppGUI & nppgui = nppParam.getNppGUI();
1904  				bool isSnapshotMode = nppgui.isSnapshotMode();
1905  				if (isSnapshotMode)
1906  				{
1907  					::LockWindowUpdate(hwnd);
1908  					MainFileManager.backupCurrentBuffer();
1909  				}
1910  				Session currentSession;
1911  				if (!((nppgui._multiInstSetting == monoInst) && !nppgui._rememberLastSession))
1912  					getCurrentOpenedFiles(currentSession, true);
1913  				if (nppgui._rememberLastSession)
1914  				{
1915  					_lastRecentFileList.setLock(true);	
1916  				}
1917  				_isAttemptingCloseOnQuit = true;
1918  				bool allClosed = fileCloseAll(false, isSnapshotMode);	
1919  				_isAttemptingCloseOnQuit = false;
1920  				if (nppgui._rememberLastSession)
1921  					_lastRecentFileList.setLock(false);	
1922  				if (!saveProjectPanelsParams()) allClosed = false; 
1923  				saveFileBrowserParam();
1924  				saveColumnEditorParams();
1925  				if (!allClosed && !nppParam.isEndSessionCritical())
1926  				{
1927  					scnN.nmhdr.code = NPPN_CANCELSHUTDOWN;
1928  					_pluginsManager.notify(&scnN);
1929  					if (isSnapshotMode)
1930  						::LockWindowUpdate(NULL);
1931  					return 0; 
1932  				}
1933  				if (_beforeSpecialView._isFullScreen)	
1934  					fullScreenToggle();
1935  				if (_beforeSpecialView._isPostIt)		
1936  					postItToggle();
1937  				if (_configStyleDlg.isCreated() && ::IsWindowVisible(_configStyleDlg.getHSelf()))
1938  					_configStyleDlg.restoreGlobalOverrideValues();
1939  				scnN.nmhdr.code = NPPN_SHUTDOWN;
1940  				_pluginsManager.notify(&scnN);
1941  				saveScintillasZoom(); 
1942  				saveGUIParams(); 
1943  				saveFindHistory(); 
1944  				_lastRecentFileList.saveLRFL(); 
1945  				nppParam.saveConfig_xml();
1946  				saveUserDefineLangs();
1947  				saveShortcuts();
1948  				if (!_isNppSessionSavedAtExit)
1949  				{
1950  					_isNppSessionSavedAtExit = true; 
1951  					if (nppgui._rememberLastSession && !nppgui._isCmdlineNosessionActivated)
1952  						saveSession(currentSession);
1953  					generic_string loadedSessionFilePath = nppParam.getLoadedSessionFilePath();
1954  					if (!loadedSessionFilePath.empty() && PathFileExists(loadedSessionFilePath.c_str()))
1955  						nppParam.writeSession(currentSession, loadedSessionFilePath.c_str());
1956  				}
1957  				if (nppgui._cloudPath != TEXT("") && nppParam.isCloudPathChanged())
1958  				{
1959  					bool isOK = nppParam.writeSettingsFilesOnCloudForThe1stTime(nppgui._cloudPath);
1960  					if (!isOK)
1961  					{
1962  						_nativeLangSpeaker.messageBox("SettingsOnCloudError",
1963  							hwnd,
1964  							TEXT("It seems the path of settings on cloud is set on a read only drive,\ror on a folder needed privilege right for writing access.\rYour settings on cloud will be canceled. Please reset a coherent value via Preference dialog."),
1965  							TEXT("Settings on Cloud"),
1966  							MB_OK | MB_APPLMODAL);
1967  						nppParam.removeCloudChoice();
1968  					}
1969  				}
1970  				if (isSnapshotMode)
1971  					::LockWindowUpdate(NULL);
1972  				::DestroyWindow(hwnd);
1973  				if (!nppParam.isEndSessionCritical())
1974  				{
1975  					generic_string updaterFullPath = nppParam.getWingupFullPath();
1976  					if (!updaterFullPath.empty())
1977  					{
1978  						Process updater(updaterFullPath.c_str(), nppParam.getWingupParams().c_str(), nppParam.getWingupDir().c_str());
1979  						updater.run(nppParam.shouldDoUAC());
1980  					}
1981  				}
1982  			}
1983  			return 0; 
1984  		}
1985  		case WM_DESTROY:
1986  		{
1987  			if (nppParam.isEndSessionStarted() && nppParam.doNppLogNulContentCorruptionIssue())
1988  			{
1989  				generic_string issueFn = nppLogNulContentCorruptionIssue;
1990  				issueFn += TEXT(".log");
1991  				generic_string nppIssueLog = nppParam.getUserPath();
1992  				pathAppend(nppIssueLog, issueFn);
1993  				writeLog(nppIssueLog.c_str(), "WM_DESTROY (isEndSessionStarted == true)");
1994  			}
1995  			killAllChildren();
1996  			::PostQuitMessage(0);
1997  			_pPublicInterface->gNppHWND = NULL;
1998  			return TRUE;
1999  		}
2000  		case NPPM_INTERNAL_RESTOREFROMTRAY:
2001  		{
2002  			if (_pTrayIco != nullptr && _pTrayIco->isInTray())
2003  			{
2004  				::SendMessage(hwnd, NPPM_INTERNAL_MINIMIZED_TRAY, 0, WM_LBUTTONUP);
2005  				return TRUE;
2006  			}
2007  			return FALSE;
2008  		}
2009  		case WM_SYSCOMMAND:
2010  		{
2011  			const NppGUI & nppgui = (nppParam.getNppGUI());
2012  			if ((nppgui._isMinimizedToTray || _pPublicInterface->isPrelaunch()) && (wParam == SC_MINIMIZE))
2013  			{
2014  				if (nullptr == _pTrayIco)
2015  				{
2016  					HICON icon = nullptr;
2017  					Notepad_plus_Window::loadTrayIcon(_pPublicInterface->getHinst(), &icon);
2018  					_pTrayIco = new trayIconControler(hwnd, IDI_M30ICON, NPPM_INTERNAL_MINIMIZED_TRAY, icon, TEXT(""));
2019  				}
2020  				_pTrayIco->doTrayIcon(ADD);
2021  				_dockingManager.showFloatingContainers(false);
2022  				minimizeDialogs();
2023  				::ShowWindow(hwnd, SW_HIDE);
2024  				return TRUE;
2025  			}
2026  			if (wParam == SC_KEYMENU && lParam == VK_SPACE)
2027  			{
2028  				_sysMenuEntering = true;
2029  			}
2030  			else if (wParam == 0xF093) 
2031  			{
2032  				_sysMenuEntering = true;
2033  			}
2034  			return ::DefWindowProc(hwnd, message, wParam, lParam);
2035  		}
2036  		case WM_LBUTTONDBLCLK:
2037  		{
2038  			::SendMessage(hwnd, WM_COMMAND, IDM_FILE_NEW, 0);
2039  			return TRUE;
2040  		}
2041  		case NPPM_INTERNAL_MINIMIZED_TRAY:
2042  		{
2043  			switch (lParam)
2044  			{
2045  				case WM_LBUTTONUP :
2046  				{
2047  					_pEditView->getFocus();
2048  					::ShowWindow(hwnd, SW_SHOW);
2049  					_dockingManager.showFloatingContainers(true);
2050  					restoreMinimizeDialogs();
2051  					if (!_pPublicInterface->isPrelaunch())
2052  						_pTrayIco->doTrayIcon(REMOVE);
2053  					::SendMessage(hwnd, WM_SIZE, 0, 0);
2054  					return TRUE;
2055  				}
2056  				case WM_MBUTTONUP:
2057  				{
2058  					command(IDM_SYSTRAYPOPUP_NEW_AND_PASTE);
2059  					return TRUE;
2060  				}
2061  				case WM_RBUTTONUP:
2062  				{
2063  					POINT p;
2064  					GetCursorPos(&p);
2065  					HMENU hmenu;            
2066  					HMENU hTrayIconMenu;  
2067  					hmenu = ::LoadMenu(_pPublicInterface->getHinst(), MAKEINTRESOURCE(IDR_SYSTRAYPOPUP_MENU));
2068  					hTrayIconMenu = ::GetSubMenu(hmenu, 0);
2069  					_nativeLangSpeaker.changeLangTrayIconContexMenu(hTrayIconMenu);
2070  					SetForegroundWindow(hwnd);
2071  					TrackPopupMenu(hTrayIconMenu, TPM_LEFTALIGN, p.x, p.y, 0, hwnd, NULL);
2072  					PostMessage(hwnd, WM_NULL, 0, 0);
2073  					DestroyMenu(hmenu);
2074  					return TRUE;
2075  				}
2076  			}
2077  			return TRUE;
2078  		}
2079  		case NPPM_DMMSHOW:
2080  		{
2081  			_dockingManager.showDockableDlg(reinterpret_cast<HWND>(lParam), SW_SHOW);
2082  			return TRUE;
2083  		}
2084  		case NPPM_DMMHIDE:
2085  		{
2086  			_dockingManager.showDockableDlg(reinterpret_cast<HWND>(lParam), SW_HIDE);
2087  			return TRUE;
2088  		}
2089  		case NPPM_DMMUPDATEDISPINFO:
2090  		{
2091  			if (::IsWindowVisible(reinterpret_cast<HWND>(lParam)))
2092  				_dockingManager.updateContainerInfo(reinterpret_cast<HWND>(lParam));
2093  			return TRUE;
2094  		}
2095  		case NPPM_DMMREGASDCKDLG:
2096  		{
2097  			tTbData *pData = reinterpret_cast<tTbData *>(lParam);
2098  			int		iCont	= -1;
2099  			bool	isVisible	= false;
2100  			getIntegralDockingData(*pData, iCont, isVisible);
2101  			_dockingManager.createDockableDlg(*pData, iCont, isVisible);
2102  			return TRUE;
2103  		}
2104  		case NPPM_DMMVIEWOTHERTAB:
2105  		{
2106  			_dockingManager.showDockableDlg(reinterpret_cast<TCHAR *>(lParam), SW_SHOW);
2107  			return TRUE;
2108  		}
2109  		case NPPM_DMMGETPLUGINHWNDBYNAME : 
2110  		{
2111  			if (!lParam)
2112  				return static_cast<LRESULT>(NULL);
2113  			TCHAR *moduleName = reinterpret_cast<TCHAR *>(lParam);
2114  			TCHAR *windowName = reinterpret_cast<TCHAR *>(wParam);
2115  			std::vector<DockingCont *> dockContainer = _dockingManager.getContainerInfo();
2116  			for (size_t i = 0, len = dockContainer.size(); i < len ; ++i)
2117  			{
2118  				std::vector<tTbData *> tbData = dockContainer[i]->getDataOfAllTb();
2119  				for (size_t j = 0, len2 = tbData.size() ; j < len2 ; ++j)
2120  				{
2121  					if (wcsicmp(moduleName, tbData[j]->pszModuleName) == 0)
2122  					{
2123  						if (!windowName)
2124  							return (LRESULT)tbData[j]->hClient;
2125  						if (wcsicmp(windowName, tbData[j]->pszName) == 0)
2126  							return (LRESULT)tbData[j]->hClient;
2127  					}
2128  				}
2129  			}
2130  			return static_cast<LRESULT>(NULL);
2131  		}
2132  		case NPPM_ADDTOOLBARICON_DEPRECATED:
2133  		{
2134  			_toolBar.registerDynBtn(static_cast<UINT>(wParam), reinterpret_cast<toolbarIcons*>(lParam), _pPublicInterface->getAbsentIcoHandle());
2135  			return TRUE;
2136  		}
2137  		case NPPM_ADDTOOLBARICON_FORDARKMODE:
2138  		{
2139  			_toolBar.registerDynBtnDM(static_cast<UINT>(wParam), reinterpret_cast<toolbarIconsWithDarkMode*>(lParam));
2140  			return TRUE;
2141  		}
2142  		case NPPM_SETMENUITEMCHECK:
2143  		{
2144  			::CheckMenuItem(_mainMenuHandle, static_cast<UINT>(wParam), MF_BYCOMMAND | (static_cast<BOOL>(lParam) ? MF_CHECKED : MF_UNCHECKED));
2145  			_toolBar.setCheck(static_cast<int>(wParam), lParam != 0);
2146  			return TRUE;
2147  		}
2148  		case NPPM_GETWINDOWSVERSION:
2149  		{
2150  			return (NppParameters::getInstance()).getWinVersion();
2151  		}
2152  		case NPPM_MAKECURRENTBUFFERDIRTY:
2153  		{
2154  			_pEditView->getCurrentBuffer()->setDirty(true);
2155  			return TRUE;
2156  		}
2157  		case NPPM_GETENABLETHEMETEXTUREFUNC_DEPRECATED:
2158  		{
2159  			return reinterpret_cast<LRESULT>(&EnableThemeDialogTexture);
2160  		}
2161  		case NPPM_GETPLUGINSCONFIGDIR:
2162  		{
2163  			generic_string userPluginConfDir = nppParam.getUserPluginConfDir();
2164  			if (lParam != 0)
2165  			{
2166  				if (userPluginConfDir.length() >= static_cast<size_t>(wParam))
2167  				{
2168  					return 0;
2169  				}
2170  				lstrcpy(reinterpret_cast<TCHAR *>(lParam), userPluginConfDir.c_str());
2171  				return TRUE;
2172  			}
2173  			return userPluginConfDir.length();
2174  		}
2175  		case NPPM_GETPLUGINHOMEPATH:
2176  		{
2177  			generic_string pluginHomePath = nppParam.getPluginRootDir();
2178  			if (lParam != 0)
2179  			{
2180  				if (pluginHomePath.length() >= static_cast<size_t>(wParam))
2181  				{
2182  					return 0;
2183  				}
2184  				lstrcpy(reinterpret_cast<TCHAR *>(lParam), pluginHomePath.c_str());
2185  			}
2186  			return pluginHomePath.length();
2187  		}
2188  		case NPPM_GETSETTINGSONCLOUDPATH:
2189  		{
2190  			const NppGUI & nppGUI = nppParam.getNppGUI();
2191  			generic_string settingsOnCloudPath = nppGUI._cloudPath;
2192  			if (lParam != 0)
2193  			{
2194  				if (settingsOnCloudPath.length() >= static_cast<size_t>(wParam))
2195  				{
2196  					return 0;
2197  				}
2198  				lstrcpy(reinterpret_cast<TCHAR *>(lParam), settingsOnCloudPath.c_str());
2199  			}
2200  			return settingsOnCloudPath.length();
2201  		}
2202  		case NPPM_SETLINENUMBERWIDTHMODE:
2203  		{
2204  			if (lParam != LINENUMWIDTH_DYNAMIC && lParam != LINENUMWIDTH_CONSTANT)
2205  				return FALSE;
2206  			ScintillaViewParams &svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
2207  			svp._lineNumberMarginDynamicWidth = lParam == LINENUMWIDTH_DYNAMIC;
2208  			::SendMessage(hwnd, WM_COMMAND, IDM_VIEW_LINENUMBER, 0);
2209  			return TRUE;
2210  		}
2211  		case NPPM_GETLINENUMBERWIDTHMODE:
2212  		{
2213  			const ScintillaViewParams &svp = nppParam.getSVP();
2214  			return svp._lineNumberMarginDynamicWidth ? LINENUMWIDTH_DYNAMIC : LINENUMWIDTH_CONSTANT;
2215  		}
2216  		case NPPM_MSGTOPLUGIN :
2217  		{
2218  			return _pluginsManager.relayPluginMessages(message, wParam, lParam);
2219  		}
2220  		case NPPM_ALLOCATESUPPORTED:
2221  		{
2222  			return TRUE;
2223  		}
2224  		case NPPM_ALLOCATECMDID:
2225  		{
2226  			return _pluginsManager.allocateCmdID(static_cast<int32_t>(wParam), reinterpret_cast<int *>(lParam));
2227  		}
2228  		case NPPM_ALLOCATEMARKER:
2229  		{
2230  			return _pluginsManager.allocateMarker(static_cast<int32_t>(wParam), reinterpret_cast<int *>(lParam));
2231  		}
2232  		case NPPM_GETBOOKMARKID:
2233  		{
2234  			return MARK_BOOKMARK;
2235  		}
2236  		case NPPM_HIDETABBAR:
2237  		{
2238  			bool hide = (lParam != 0);
2239  			bool oldVal = DocTabView::getHideTabBarStatus();
2240  			if (hide == oldVal) return oldVal;
2241  			DocTabView::setHideTabBarStatus(hide);
2242  			::SendMessage(hwnd, WM_SIZE, 0, 0);
2243  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
2244  			if (hide)
2245  				nppGUI._tabStatus |= TAB_HIDE;
2246  			else
2247  				nppGUI._tabStatus &= ~TAB_HIDE;
2248  			return oldVal;
2249  		}
2250  		case NPPM_ISTABBARHIDDEN:
2251  		{
2252  			return _mainDocTab.getHideTabBarStatus();
2253  		}
2254  		case NPPM_HIDETOOLBAR:
2255  		{
2256  			bool show = (lParam != TRUE);
2257  			bool currentStatus = _rebarTop.getIDVisible(REBAR_BAR_TOOLBAR);
2258  			if (show != currentStatus)
2259  				_rebarTop.setIDVisible(REBAR_BAR_TOOLBAR, show);
2260  			return currentStatus;
2261  		}
2262  		case NPPM_ISTOOLBARHIDDEN :
2263  		{
2264  			return !_rebarTop.getIDVisible(REBAR_BAR_TOOLBAR);
2265  		}
2266  		case NPPM_HIDEMENU:
2267  		{
2268  			bool hide = (lParam == TRUE);
2269  			bool isHidden = ::GetMenu(hwnd) == NULL;
2270  			if (hide == isHidden)
2271  				return isHidden;
2272  			NppGUI & nppGUI = nppParam.getNppGUI();
2273  			nppGUI._menuBarShow = !hide;
2274  			if (nppGUI._menuBarShow)
2275  				::SetMenu(hwnd, _mainMenuHandle);
2276  			else
2277  				::SetMenu(hwnd, NULL);
2278  			return isHidden;
2279  		}
2280  		case NPPM_ISMENUHIDDEN:
2281  		{
2282  			return (::GetMenu(hwnd) == NULL);
2283  		}
2284  		case NPPM_HIDESTATUSBAR:
2285  		{
2286  			bool show = (lParam != TRUE);
2287  			NppGUI & nppGUI = nppParam.getNppGUI();
2288  			bool oldVal = nppGUI._statusBarShow;
2289  			if (show == oldVal)
2290  				return oldVal;
2291  			RECT rc;
2292  			_pPublicInterface->getClientRect(rc);
2293  			nppGUI._statusBarShow = show;
2294  			_statusBar.display(nppGUI._statusBarShow);
2295  			::SendMessage(hwnd, WM_SIZE, SIZE_RESTORED, MAKELONG(rc.bottom, rc.right));
2296  			return oldVal;
2297  		}
2298  		case NPPM_ISSTATUSBARHIDDEN:
2299  		{
2300  			const NppGUI & nppGUI = nppParam.getNppGUI();
2301  			return !nppGUI._statusBarShow;
2302  		}
2303  		case NPPM_GETCURRENTVIEW:
2304  		{
2305  			return _activeView;
2306  		}
2307  		case NPPM_INTERNAL_ISFOCUSEDTAB:
2308  		{
2309  			HWND hTabToTest = (currentView() == MAIN_VIEW)?_mainDocTab.getHSelf():_subDocTab.getHSelf();
2310  			return reinterpret_cast<HWND>(lParam) == hTabToTest;
2311  		}
2312  		case NPPM_INTERNAL_GETMENU:
2313  		{
2314  			return (LRESULT)_mainMenuHandle;
2315  		}
2316  		case NPPM_INTERNAL_CLEARINDICATOR:
2317  		{
2318  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_SMART);
2319  			return TRUE;
2320  		}
2321  		case NPPM_INTERNAL_CLEARINDICATORTAGMATCH:
2322  		{
2323  			_pEditView->clearIndicator(SCE_UNIVERSAL_TAGMATCH);
2324  			_pEditView->clearIndicator(SCE_UNIVERSAL_TAGATTR);
2325  			return TRUE;
2326  		}
2327  		case NPPM_INTERNAL_CLEARINDICATORTAGATTR:
2328  		{
2329  			_pEditView->clearIndicator(SCE_UNIVERSAL_TAGATTR);
2330  			return TRUE;
2331  		}
2332  		case NPPM_INTERNAL_SWITCHVIEWFROMHWND:
2333  		{
2334  			HWND handle = reinterpret_cast<HWND>(lParam);
2335  			if (_mainEditView.getHSelf() == handle || _mainDocTab.getHSelf() == handle)
2336  			{
2337  				switchEditViewTo(MAIN_VIEW);
2338  			}
2339  			else if (_subEditView.getHSelf() == handle || _subDocTab.getHSelf() == handle)
2340  			{
2341  				switchEditViewTo(SUB_VIEW);
2342  			}
2343  			return TRUE;
2344  		}
2345  		case NPPM_INTERNAL_UPDATETITLEBAR:
2346  		{
2347  			setTitle();
2348  			return TRUE;
2349  		}
2350  		case NPPM_INTERNAL_CRLFFORMCHANGED:
2351  		{
2352  			_mainEditView.setCRLF();
2353  			_subEditView.setCRLF();
2354  			return TRUE;
2355  		}
2356  		case NPPM_INTERNAL_NPCFORMCHANGED:
2357  		{
2358  			_mainEditView.setNpcAndCcUniEOL();
2359  			_subEditView.setNpcAndCcUniEOL();
2360  			const auto& svp = NppParameters::getInstance().getSVP();
2361  			if (svp._npcShow)
2362  			{
2363  				_findReplaceDlg.updateFinderScintillaForNpc(true);
2364  			}
2365  			return TRUE;
2366  		}
2367  		case NPPM_INTERNAL_ENABLECHANGEHISTORY:
2368  		{
2369  			const ScintillaViewParams& svp = nppParam.getSVP();
2370  			int enabledCH = svp._isChangeHistoryEnabled ? (SC_CHANGE_HISTORY_ENABLED | SC_CHANGE_HISTORY_MARKERS) : SC_CHANGE_HISTORY_DISABLED;
2371  			_mainEditView.execute(SCI_SETCHANGEHISTORY, enabledCH);
2372  			_subEditView.execute(SCI_SETCHANGEHISTORY, enabledCH);
2373  			_mainEditView.showChangeHistoryMargin(svp._isChangeHistoryEnabled);
2374  			_subEditView.showChangeHistoryMargin(svp._isChangeHistoryEnabled);
2375  			return TRUE;
2376  		}
2377  		case NPPM_INTERNAL_CLEANBRACEMATCH:
2378  		{
2379  			_mainEditView.execute(SCI_SETHIGHLIGHTGUIDE, 0);
2380  			_subEditView.execute(SCI_SETHIGHLIGHTGUIDE, 0);
2381  			_mainEditView.execute(SCI_BRACEBADLIGHT, WPARAM(-1));
2382  			_subEditView.execute(SCI_BRACEBADLIGHT, WPARAM(-1));
2383  			return TRUE;
2384  		}
2385  		case NPPM_INTERNAL_CLEANSMARTHILITING:
2386  		{
2387  			_mainEditView.clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_SMART);
2388  			_subEditView.clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_SMART);
2389  			return TRUE;
2390  		}
2391  		case NPPM_INTERNAL_CRLFLAUNCHSTYLECONF:
2392  		{
2393  			command(IDM_LANGSTYLE_CONFIG_DLG);
2394  			_configStyleDlg.goToSection(TEXT("Global Styles:EOL custom color"));
2395  			return TRUE;
2396  		}
2397  		case NPPM_INTERNAL_NPCLAUNCHSTYLECONF:
2398  		{
2399  			command(IDM_LANGSTYLE_CONFIG_DLG);
2400  			generic_string npcStr = L"Global Styles:";
2401  			npcStr += g_npcStyleName;
2402  			_configStyleDlg.goToSection(npcStr.c_str());
2403  			return TRUE;
2404  		}
2405  		case NPPM_INTERNAL_LAUNCHPREFERENCES:
2406  		{
2407  			command(IDM_SETTING_PREFERENCE);
2408  			_preference.goToSection(wParam, lParam);
2409  			return TRUE;
2410  		}
2411  		case NPPM_INTERNAL_DISABLEAUTOUPDATE:
2412  		{
2413  			NppGUI & nppGUI = nppParam.getNppGUI();
2414  			nppGUI._autoUpdateOpt._doAutoUpdate = false;
2415  			return TRUE;
2416  		}
2417  		case NPPM_GETLANGUAGENAME:
2418  		{
2419  			generic_string langName = getLangDesc((LangType)wParam, true);
2420  			if (lParam)
2421  				lstrcpy((LPTSTR)lParam, langName.c_str());
2422  			return langName.length();
2423  		}
2424  		case NPPM_GETLANGUAGEDESC:
2425  		{
2426  			generic_string langDesc = getLangDesc((LangType)wParam, false);
2427  			if (lParam)
2428  				lstrcpy((LPTSTR)lParam, langDesc.c_str());
2429  			return langDesc.length();
2430  		}
2431  		case NPPM_GETEXTERNALLEXERAUTOINDENTMODE:
2432  		{
2433  			int index = nppParam.getExternalLangIndexFromName(reinterpret_cast<TCHAR*>(wParam));
2434  			if (index < 0)
2435  				return FALSE;
2436  			*(reinterpret_cast<ExternalLexerAutoIndentMode*>(lParam)) = nppParam.getELCFromIndex(index)._autoIndentMode;
2437  			return TRUE;
2438  		}
2439  		case NPPM_SETEXTERNALLEXERAUTOINDENTMODE:
2440  		{
2441  			int index = nppParam.getExternalLangIndexFromName(reinterpret_cast<TCHAR*>(wParam));
2442  			if (index < 0)
2443  				return FALSE;
2444  			nppParam.getELCFromIndex(index)._autoIndentMode = static_cast<ExternalLexerAutoIndentMode>(lParam);
2445  			return TRUE;
2446  		}
2447  		case NPPM_ISAUTOINDENTON:
2448  		{
2449  			return nppParam.getNppGUI()._maitainIndent;
2450  		}
2451  		case NPPM_ISDARKMODEENABLED:
2452  		{
2453  			return NppDarkMode::isEnabled();
2454  		}
2455  		case NPPM_GETDARKMODECOLORS:
2456  		{
2457  			if (static_cast<size_t>(wParam) != sizeof(NppDarkMode::Colors))
2458  				return static_cast<LRESULT>(false);
2459  			NppDarkMode::Colors* currentColors = reinterpret_cast<NppDarkMode::Colors*>(lParam);
2460  			if (currentColors != NULL)
2461  			{
2462  				currentColors->background = NppDarkMode::getBackgroundColor();
2463  				currentColors->softerBackground = NppDarkMode::getSofterBackgroundColor();
2464  				currentColors->hotBackground = NppDarkMode::getHotBackgroundColor();
2465  				currentColors->pureBackground = NppDarkMode::getDarkerBackgroundColor();
2466  				currentColors->errorBackground = NppDarkMode::getErrorBackgroundColor();
2467  				currentColors->text = NppDarkMode::getTextColor();
2468  				currentColors->darkerText = NppDarkMode::getDarkerTextColor();
2469  				currentColors->disabledText = NppDarkMode::getDisabledTextColor();
2470  				currentColors->linkText = NppDarkMode::getLinkTextColor();
2471  				currentColors->edge = NppDarkMode::getEdgeColor();
2472  				currentColors->hotEdge = NppDarkMode::getHotEdgeColor();
2473  				currentColors->disabledEdge = NppDarkMode::getDisabledEdgeColor();
2474  				return static_cast<LRESULT>(true);
2475  			}
2476  			return static_cast<LRESULT>(false);
2477  		}
2478  		case NPPM_DARKMODESUBCLASSANDTHEME:
2479  		{
2480  			return static_cast<LRESULT>(NppDarkMode::autoSubclassAndThemePlugin(reinterpret_cast<HWND>(lParam), static_cast<ULONG>(wParam)));
2481  		}
2482  		case NPPM_DOCLISTDISABLEPATHCOLUMN:
2483  		case NPPM_DOCLISTDISABLEEXTCOLUMN:
2484  		{
2485  			BOOL isOff = static_cast<BOOL>(lParam);
2486  			NppGUI & nppGUI = nppParam.getNppGUI();
2487  			if (message == NPPM_DOCLISTDISABLEEXTCOLUMN)
2488  				nppGUI._fileSwitcherWithoutExtColumn = isOff == TRUE;
2489  			else
2490  				nppGUI._fileSwitcherWithoutPathColumn = isOff == TRUE;
2491  			if (_pDocumentListPanel)
2492  			{
2493  				_pDocumentListPanel->reload();
2494  			}
2495  			return TRUE;
2496  		}
2497  		case NPPM_GETEDITORDEFAULTFOREGROUNDCOLOR:
2498  		case NPPM_GETEDITORDEFAULTBACKGROUNDCOLOR:
2499  		{
2500  			return (message == NPPM_GETEDITORDEFAULTFOREGROUNDCOLOR
2501  					?(NppParameters::getInstance()).getCurrentDefaultFgColor()
2502  					:(NppParameters::getInstance()).getCurrentDefaultBgColor());
2503  		}
2504  		case NPPM_SHOWDOCLIST:
2505  		{
2506  			BOOL toShow = static_cast<BOOL>(lParam);
2507  			if (toShow)
2508  			{
2509  				if (!_pDocumentListPanel || !_pDocumentListPanel->isVisible())
2510  					launchDocumentListPanel();
2511  			}
2512  			else
2513  			{
2514  				if (_pDocumentListPanel)
2515  					_pDocumentListPanel->display(false);
2516  			}
2517  			return TRUE;
2518  		}
2519  		case NPPM_ISDOCLISTSHOWN:
2520  		{
2521  			if (!_pDocumentListPanel)
2522  				return FALSE;
2523  			return _pDocumentListPanel->isVisible();
2524  		}
2525  		case NPPM_GETAPPDATAPLUGINSALLOWED: 
2526  		{
2527  			const TCHAR *appDataNpp = nppParam.getAppDataNppDir();
2528  			if (appDataNpp[0]) 
2529  			{
2530  				return TRUE;
2531  			}
2532  			return FALSE;
2533  		}
2534  		case NPPM_REMOVESHORTCUTBYCMDID:
2535  		{
2536  			int cmdID = static_cast<int32_t>(wParam);
2537  			return _pluginsManager.removeShortcutByCmdID(cmdID);
2538  		}
2539  		case NPPM_INTERNAL_SETTING_HISTORY_SIZE:
2540  		{
2541  			_lastRecentFileList.setUserMaxNbLRF(nppParam.getNbMaxRecentFile());
2542  			break;
2543  		}
2544  		case NPPM_INTERNAL_EDGEMULTISETSIZE:
2545  		{
2546  			_mainEditView.execute(SCI_MULTIEDGECLEARALL);
2547  			_subEditView.execute(SCI_MULTIEDGECLEARALL);
2548  			ScintillaViewParams &svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
2549  			COLORREF multiEdgeColor = liteGrey;
2550  			const Style * pStyle = NppParameters::getInstance().getMiscStylerArray().findByName(TEXT("Edge colour"));
2551  			if (pStyle)
2552  			{
2553  				multiEdgeColor = pStyle->_fgColor;
2554  			}
2555  			const size_t twoPower13 = 8192;
2556  			size_t nbColAdded = 0;
2557  			for (auto i : svp._edgeMultiColumnPos)
2558  			{
2559  				if (i > twoPower13)
2560  					continue;
2561  				_mainEditView.execute(SCI_MULTIEDGEADDLINE, i, multiEdgeColor);
2562  				_subEditView.execute(SCI_MULTIEDGEADDLINE, i, multiEdgeColor);
2563  				++nbColAdded;
2564  			}
2565  			int mode;
2566  			switch (nbColAdded)
2567  			{
2568  				case 0:
2569  				{
2570  					mode = EDGE_NONE;
2571  					break;
2572  				}
2573  				case 1:
2574  				{
2575  					if (svp._isEdgeBgMode)
2576  					{
2577  						mode = EDGE_BACKGROUND;
2578  						_mainEditView.execute(SCI_SETEDGECOLUMN, svp._edgeMultiColumnPos[0]);
2579  						_subEditView.execute(SCI_SETEDGECOLUMN, svp._edgeMultiColumnPos[0]);
2580  					}
2581  					else
2582  					{
2583  						mode = EDGE_MULTILINE;
2584  					}
2585  					break;
2586  				}
2587  				default:
2588  					mode = EDGE_MULTILINE;
2589  			}
2590  			_mainEditView.execute(SCI_SETEDGEMODE, mode);
2591  			_subEditView.execute(SCI_SETEDGEMODE, mode);
2592  		}
2593  		break;
2594  		case NPPM_INTERNAL_SETTING_TAB_REPLCESPACE:
2595  		case NPPM_INTERNAL_SETTING_TAB_SIZE:
2596  		{
2597  			_pEditView->setTabSettings(_pEditView->getCurrentBuffer()->getCurrentLang());
2598  			break;
2599  		}
2600  		case NPPM_INTERNAL_RECENTFILELIST_UPDATE:
2601  		{
2602  			_lastRecentFileList.updateMenu();
2603  			break;
2604  		}
2605  		case NPPM_INTERNAL_RECENTFILELIST_SWITCH:
2606  		{
2607  			_lastRecentFileList.switchMode();
2608  			_lastRecentFileList.updateMenu();
2609  			break;
2610  		}
2611  		case WM_INITMENUPOPUP:
2612  		{
2613  			_windowsMenu.initPopupMenu(reinterpret_cast<HMENU>(wParam), _pDocTab);
2614  			return TRUE;
2615  		}
2616  		case WM_ENTERMENULOOP:
2617  		{
2618  			const NppGUI & nppgui = nppParam.getNppGUI();
2619  			if (!nppgui._menuBarShow && !wParam && !_sysMenuEntering)
2620  				::SetMenu(hwnd, _mainMenuHandle);
2621  			return TRUE;
2622  		}
2623  		case WM_EXITMENULOOP:
2624  		{
2625  			const NppGUI & nppgui = nppParam.getNppGUI();
2626  			if (!nppgui._menuBarShow && !wParam && !_sysMenuEntering)
2627  				::SetMenu(hwnd, NULL);
2628  			_sysMenuEntering = false;
2629  			return FALSE;
2630  		}
2631  		case WM_DPICHANGED:
2632  		{
2633  			return TRUE;
2634  		}
2635  		case NPPM_INTERNAL_UPDATECLICKABLELINKS:
2636  		{
2637  			ScintillaEditView* pView = reinterpret_cast<ScintillaEditView*>(wParam);
2638  			if (pView == NULL)
2639  			{
2640  				addHotSpot(_pEditView);
2641  				addHotSpot(_pNonEditView);
2642  			}
2643  			else
2644  			{
2645  				addHotSpot(pView);
2646  			}
2647  			return TRUE;
2648  		}
2649  		case NPPM_INTERNAL_UPDATETEXTZONEPADDING:
2650  		{
2651  			ScintillaViewParams &svp = const_cast<ScintillaViewParams &>(nppParam.getSVP());
2652  			if (_beforeSpecialView._isDistractionFree)
2653  			{
2654  				int paddingLen = svp.getDistractionFreePadding(_pEditView->getWidth());
2655  				_pEditView->execute(SCI_SETMARGINLEFT, 0, paddingLen);
2656  				_pEditView->execute(SCI_SETMARGINRIGHT, 0, paddingLen);
2657  			}
2658  			else
2659  			{
2660  				_mainEditView.execute(SCI_SETMARGINLEFT, 0, svp._paddingLeft);
2661  				_mainEditView.execute(SCI_SETMARGINRIGHT, 0, svp._paddingRight);
2662  				_subEditView.execute(SCI_SETMARGINLEFT, 0, svp._paddingLeft);
2663  				_subEditView.execute(SCI_SETMARGINRIGHT, 0, svp._paddingRight);
2664  			}
2665  			return TRUE;
2666  		}
2667  		case NPPM_INTERNAL_REFRESHWORKDIR:
2668  		{
2669  			const Buffer* buf = _pEditView->getCurrentBuffer();
2670  			generic_string path = buf ? buf->getFullPathName() : _T("");
2671  			PathRemoveFileSpec(path);
2672  			setWorkingDir(path.c_str());
2673  			return TRUE;
2674  		}
2675  		default:
2676  		{
2677  			if (message == WDN_NOTIFY)
2678  			{
2679  				NMWINDLG* nmdlg = reinterpret_cast<NMWINDLG*>(lParam);
2680  				switch (nmdlg->type)
2681  				{
2682  					case WDT_ACTIVATE:
2683  					{
2684  						activateDoc(nmdlg->curSel);
2685  						nmdlg->processed = TRUE;
2686  						break;
2687  					}
2688  					case WDT_SAVE:
2689  					{
2690  						for (unsigned int i = 0; i < nmdlg->nItems; ++i)
2691  						{
2692  							fileSave(_pDocTab->getBufferByIndex(nmdlg->Items[i]));
2693  						}
2694  						nmdlg->processed = TRUE;
2695  						break;
2696  					}
2697  					case WDT_CLOSE:
2698  					{
2699  						for (unsigned int i = 0; i < nmdlg->nItems; ++i)
2700  						{
2701  							bool closed = fileClose(_pDocTab->getBufferByIndex(nmdlg->Items[i]), currentView());
2702  							UINT pos = nmdlg->Items[i];
2703  							if (closed)
2704  							{
2705  								nmdlg->Items[i] = 0xFFFFFFFF; 
2706  								for (unsigned int j = i + 1; j < nmdlg->nItems; ++j)
2707  								{
2708  									if (nmdlg->Items[j] > pos)
2709  										nmdlg->Items[j]--;
2710  								}
2711  							}
2712  						}
2713  						nmdlg->processed = TRUE;
2714  						break;
2715  					}
2716  					case WDT_SORT:
2717  					{
2718  						if (nmdlg->nItems != _pDocTab->nbItem())	
2719  							break;
2720  						std::vector<BufferID> tempBufs;
2721  						for (unsigned int i = 0; i < nmdlg->nItems; ++i)
2722  						{
2723  							tempBufs.push_back(_pDocTab->getBufferByIndex(i));
2724  						}
2725  						for (unsigned int i = 0; i < nmdlg->nItems; ++i)
2726  						{
2727  							_pDocTab->setBuffer(i, tempBufs[nmdlg->Items[i]]);
2728  						}
2729  						activateBuffer(_pDocTab->getBufferByIndex(_pDocTab->getCurrentTabIndex()), currentView());
2730  						::SendMessage(_pDocTab->getHParent(), NPPM_INTERNAL_DOCORDERCHANGED, 0, _pDocTab->getCurrentTabIndex());
2731  						break;
2732  					}
2733  				}
2734  				return TRUE;
2735  			}
2736  			return ::DefWindowProc(hwnd, message, wParam, lParam);
2737  		}
2738  	}
2739  	_pluginsManager.relayNppMessages(message, wParam, lParam);
2740  	return result;
2741  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-election_scheduler.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppBigSwitch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>15  	nano::state_block_builder builder;
16  	auto send1 = builder.make_block ()
</pre></code></div>
                <div class="column column_space"><pre><code>325  			Finder *launcher = reinterpret_cast<Finder *>(wParam);
326  			bool isFirstTime = !_findInFinderDlg.isCreated();
327  			_findInFinderDlg.doDialog(launcher, _nativeLangSpeaker.isRTL());
328  			_pEditView->getGenericSelectedText(str, strSize);
329  			_findReplaceDlg.setSearchText(str);
330  			setFindReplaceFolderFilter(NULL, NULL);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    