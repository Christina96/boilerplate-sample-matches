
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.68206820682068%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fast_uniform_bits_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/fast_uniform_bits.h"
2  #include <random>
3  #include "gtest/gtest.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace random_internal {
7  namespace {
8  template <typename IntType>
9  class FastUniformBitsTypedTest : public ::testing::Test {};
10  using IntTypes = ::testing::Types<uint8_t, uint16_t, uint32_t, uint64_t>;
11  TYPED_TEST_SUITE(FastUniformBitsTypedTest, IntTypes);
12  TYPED_TEST(FastUniformBitsTypedTest, BasicTest) {
13    using Limits = std::numeric_limits<TypeParam>;
14    using FastBits = FastUniformBits<TypeParam>;
15    EXPECT_EQ(0, (FastBits::min)());
16    EXPECT_EQ((Limits::max)(), (FastBits::max)());
17    constexpr int kIters = 10000;
18    std::random_device rd;
19    std::mt19937 gen(rd());
20    FastBits fast;
21    for (int i = 0; i < kIters; i++) {
22      const auto v = fast(gen);
23      EXPECT_LE(v, (FastBits::max)());
24      EXPECT_GE(v, (FastBits::min)());
25    }
26  }
27  template <typename UIntType, UIntType Lo, UIntType Hi, UIntType Val = Lo>
28  struct FakeUrbg {
29    using result_type = UIntType;
30    FakeUrbg() = default;
31    explicit FakeUrbg(bool r) : reject(r) {}
32    static constexpr result_type(max)() { return Hi; }
33    static constexpr result_type(min)() { return Lo; }
34    result_type operator()() {
35      return ((++calls % 2) == 1 && reject) ? Hi : Val;
36    }
37    bool reject = false;
38    size_t calls = 0;
39  };
40  TEST(FastUniformBitsTest, IsPowerOfTwoOrZero) {
41    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{0}));
42    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{1}));
43    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{2}));
44    EXPECT_FALSE(IsPowerOfTwoOrZero(uint8_t{3}));
45    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{4}));
46    EXPECT_TRUE(IsPowerOfTwoOrZero(uint8_t{16}));
47    EXPECT_FALSE(IsPowerOfTwoOrZero(uint8_t{17}));
48    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint8_t>::max)()));
49    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{0}));
50    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{1}));
51    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{2}));
52    EXPECT_FALSE(IsPowerOfTwoOrZero(uint16_t{3}));
53    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{4}));
54    EXPECT_TRUE(IsPowerOfTwoOrZero(uint16_t{16}));
55    EXPECT_FALSE(IsPowerOfTwoOrZero(uint16_t{17}));
56    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint16_t>::max)()));
57    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{0}));
58    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{1}));
59    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{2}));
60    EXPECT_FALSE(IsPowerOfTwoOrZero(uint32_t{3}));
61    EXPECT_TRUE(IsPowerOfTwoOrZero(uint32_t{32}));
62    EXPECT_FALSE(IsPowerOfTwoOrZero(uint32_t{17}));
63    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint32_t>::max)()));
64    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{0}));
65    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{1}));
66    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{2}));
67    EXPECT_FALSE(IsPowerOfTwoOrZero(uint64_t{3}));
68    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{4}));
69    EXPECT_TRUE(IsPowerOfTwoOrZero(uint64_t{64}));
70    EXPECT_FALSE(IsPowerOfTwoOrZero(uint64_t{17}));
71    EXPECT_FALSE(IsPowerOfTwoOrZero((std::numeric_limits<uint64_t>::max)()));
72  }
73  TEST(FastUniformBitsTest, IntegerLog2) {
74    EXPECT_EQ(0, IntegerLog2(uint16_t{0}));
75    EXPECT_EQ(0, IntegerLog2(uint16_t{1}));
76    EXPECT_EQ(1, IntegerLog2(uint16_t{2}));
77    EXPECT_EQ(1, IntegerLog2(uint16_t{3}));
78    EXPECT_EQ(2, IntegerLog2(uint16_t{4}));
79    EXPECT_EQ(2, IntegerLog2(uint16_t{5}));
80    EXPECT_EQ(2, IntegerLog2(uint16_t{7}));
81    EXPECT_EQ(3, IntegerLog2(uint16_t{8}));
82    EXPECT_EQ(63, IntegerLog2((std::numeric_limits<uint64_t>::max)()));
83  }
84  TEST(FastUniformBitsTest, RangeSize) {
85    EXPECT_EQ(2, (RangeSize<FakeUrbg<uint8_t, 0, 1>>()));
86    EXPECT_EQ(3, (RangeSize<FakeUrbg<uint8_t, 0, 2>>()));
87    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint8_t, 0, 3>>()));
88    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint8_t, 2, 5>>()));
89    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint8_t, 2, 6>>()));
90    EXPECT_EQ(9, (RangeSize<FakeUrbg<uint8_t, 2, 10>>()));
91    EXPECT_EQ(
92        0, (RangeSize<
93               FakeUrbg<uint8_t, 0, (std::numeric_limits<uint8_t>::max)()>>()));
94    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint16_t, 0, 3>>()));
95    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint16_t, 2, 5>>()));
96    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint16_t, 2, 6>>()));
97    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint16_t, 1000, 1017>>()));
98    EXPECT_EQ(
99        0, (RangeSize<
100               FakeUrbg<uint16_t, 0, (std::numeric_limits<uint16_t>::max)()>>()));
101    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint32_t, 0, 3>>()));
102    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint32_t, 2, 5>>()));
103    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint32_t, 2, 6>>()));
104    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint32_t, 1000, 1017>>()));
105    EXPECT_EQ(0, (RangeSize<FakeUrbg<uint32_t, 0, 0xffffffff>>()));
106    EXPECT_EQ(0xffffffff, (RangeSize<FakeUrbg<uint32_t, 1, 0xffffffff>>()));
107    EXPECT_EQ(0xfffffffe, (RangeSize<FakeUrbg<uint32_t, 1, 0xfffffffe>>()));
108    EXPECT_EQ(0xfffffffd, (RangeSize<FakeUrbg<uint32_t, 2, 0xfffffffe>>()));
109    EXPECT_EQ(
110        0, (RangeSize<
111               FakeUrbg<uint32_t, 0, (std::numeric_limits<uint32_t>::max)()>>()));
112    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint64_t, 0, 3>>()));
113    EXPECT_EQ(4, (RangeSize<FakeUrbg<uint64_t, 2, 5>>()));
114    EXPECT_EQ(5, (RangeSize<FakeUrbg<uint64_t, 2, 6>>()));
115    EXPECT_EQ(18, (RangeSize<FakeUrbg<uint64_t, 1000, 1017>>()));
116    EXPECT_EQ(0x100000000, (RangeSize<FakeUrbg<uint64_t, 0, 0xffffffff>>()));
117    EXPECT_EQ(0xffffffff, (RangeSize<FakeUrbg<uint64_t, 1, 0xffffffff>>()));
118    EXPECT_EQ(0xfffffffe, (RangeSize<FakeUrbg<uint64_t, 1, 0xfffffffe>>()));
119    EXPECT_EQ(0xfffffffd, (RangeSize<FakeUrbg<uint64_t, 2, 0xfffffffe>>()));
120    EXPECT_EQ(0, (RangeSize<FakeUrbg<uint64_t, 0, 0xffffffffffffffff>>()));
121    EXPECT_EQ(0xffffffffffffffff,
122              (RangeSize<FakeUrbg<uint64_t, 1, 0xffffffffffffffff>>()));
123    EXPECT_EQ(0xfffffffffffffffe,
124              (RangeSize<FakeUrbg<uint64_t, 1, 0xfffffffffffffffe>>()));
125    EXPECT_EQ(0xfffffffffffffffd,
126              (RangeSize<FakeUrbg<uint64_t, 2, 0xfffffffffffffffe>>()));
127    EXPECT_EQ(
128        0, (RangeSize<
129               FakeUrbg<uint64_t, 0, (std::numeric_limits<uint64_t>::max)()>>()));
130  }
131  using Urng1_5bit = FakeUrbg<uint8_t, 0, 2, 0>;  
132  using Urng4bits = FakeUrbg<uint8_t, 1, 0x10, 2>;
133  using Urng22bits = FakeUrbg<uint32_t, 0, 0x3fffff, 0x301020>;
134  using Urng31bits = FakeUrbg<uint32_t, 1, 0xfffffffe, 0x60070f03>;  
135  using Urng32bits = FakeUrbg<uint32_t, 0, 0xffffffff, 0x74010f01>;
136  using Urng33bits =
137      FakeUrbg<uint64_t, 1, 0x1ffffffff, 0x013301033>;  
138  using Urng63bits = FakeUrbg<uint64_t, 1, 0xfffffffffffffffe,
139                              0xfedcba9012345678>;  
140  using Urng64bits =
141      FakeUrbg<uint64_t, 0, 0xffffffffffffffff, 0x123456780fedcba9>;
142  TEST(FastUniformBitsTest, OutputsUpTo32Bits) {
143    Urng1_5bit urng1_5;
144    Urng4bits urng4;
145    Urng22bits urng22;
146    Urng31bits urng31;
147    Urng32bits urng32;
148    Urng33bits urng33;
<span onclick='openModal()' class='match'>149    Urng63bits urng63;
150    Urng64bits urng64;
151    {
152      FastUniformBits<uint8_t> fast8;
153      EXPECT_EQ(0x0, fast8(urng1_5));
154      EXPECT_EQ(0x11, fast8(urng4));
155      EXPECT_EQ(0x20, fast8(urng22));
156      EXPECT_EQ(0x2, fast8(urng31));
157      EXPECT_EQ(0x1, fast8(urng32));
158      EXPECT_EQ(0x32, fast8(urng33));
159      EXPECT_EQ(0x77, fast8(urng63));
160      EXPECT_EQ(0xa9, fast8(urng64));
161    }
162    {
163      FastUniformBits<uint16_t> fast16;
</span>164      EXPECT_EQ(0x0, fast16(urng1_5));
165      EXPECT_EQ(0x1111, fast16(urng4));
166      EXPECT_EQ(0x1020, fast16(urng22));
167      EXPECT_EQ(0x0f02, fast16(urng31));
168      EXPECT_EQ(0x0f01, fast16(urng32));
169      EXPECT_EQ(0x1032, fast16(urng33));
170      EXPECT_EQ(0x5677, fast16(urng63));
171      EXPECT_EQ(0xcba9, fast16(urng64));
172    }
173    {
174      FastUniformBits<uint32_t> fast32;
175      EXPECT_EQ(0x0, fast32(urng1_5));
176      EXPECT_EQ(0x11111111, fast32(urng4));
177      EXPECT_EQ(0x08301020, fast32(urng22));
178      EXPECT_EQ(0x0f020f02, fast32(urng31));
179      EXPECT_EQ(0x74010f01, fast32(urng32));
180      EXPECT_EQ(0x13301032, fast32(urng33));
181      EXPECT_EQ(0x12345677, fast32(urng63));
182      EXPECT_EQ(0x0fedcba9, fast32(urng64));
183    }
184  }
185  TEST(FastUniformBitsTest, Outputs64Bits) {
186    FastUniformBits<uint64_t> fast64;
187    {
188      FakeUrbg<uint8_t, 0, 1, 0> urng0;
189      FakeUrbg<uint8_t, 0, 1, 1> urng1;
190      Urng4bits urng4;
191      Urng22bits urng22;
192      Urng31bits urng31;
193      Urng32bits urng32;
194      Urng33bits urng33;
195      Urng63bits urng63;
196      Urng64bits urng64;
197      EXPECT_EQ(0x0, fast64(urng0));
198      EXPECT_EQ(64, urng0.calls);
199      EXPECT_EQ(0xffffffffffffffff, fast64(urng1));
200      EXPECT_EQ(64, urng1.calls);
201      EXPECT_EQ(0x1111111111111111, fast64(urng4));
202      EXPECT_EQ(16, urng4.calls);
203      EXPECT_EQ(0x01020c0408301020, fast64(urng22));
204      EXPECT_EQ(3, urng22.calls);
205      EXPECT_EQ(0x387811c3c0870f02, fast64(urng31));
206      EXPECT_EQ(3, urng31.calls);
207      EXPECT_EQ(0x74010f0174010f01, fast64(urng32));
208      EXPECT_EQ(2, urng32.calls);
209      EXPECT_EQ(0x808194040cb01032, fast64(urng33));
210      EXPECT_EQ(3, urng33.calls);
211      EXPECT_EQ(0x1234567712345677, fast64(urng63));
212      EXPECT_EQ(2, urng63.calls);
213      EXPECT_EQ(0x123456780fedcba9, fast64(urng64));
214      EXPECT_EQ(1, urng64.calls);
215    }
216    {
217      Urng1_5bit urng1_5;
218      EXPECT_EQ(0x0, fast64(urng1_5));
219      EXPECT_EQ(65, urng1_5.calls);
220    }
221    {
222      Urng1_5bit urng1_5(true);
223      Urng31bits urng31(true);
224      Urng33bits urng33(true);
225      Urng63bits urng63(true);
226      EXPECT_EQ(0, fast64(urng1_5));
227      EXPECT_EQ(128, urng1_5.calls);
228      EXPECT_EQ(0x387811c3c0870f02, fast64(urng31));
229      EXPECT_EQ(6, urng31.calls);
230      EXPECT_EQ(0x808194040cb01032, fast64(urng33));
231      EXPECT_EQ(6, urng33.calls);
232      EXPECT_EQ(0x1234567712345677, fast64(urng63));
233      EXPECT_EQ(4, urng63.calls);
234    }
235  }
236  TEST(FastUniformBitsTest, URBG32bitRegression) {
237    EXPECT_EQ(2147483646, RangeSize<std::minstd_rand>());
238    EXPECT_EQ(30, IntegerLog2(RangeSize<std::minstd_rand>()));
239    std::minstd_rand gen(1);
240    FastUniformBits<uint64_t> fast64;
241    EXPECT_EQ(0x05e47095f8791f45, fast64(gen));
242    EXPECT_EQ(0x028be17e3c07c122, fast64(gen));
243    EXPECT_EQ(0x55d2847c1626e8c2, fast64(gen));
244  }
245  }  
246  }  
247  ABSL_NAMESPACE_END
248  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-span_test.cc</h3>
            <pre><code>1  #include "absl/types/span.h"
2  #include <array>
3  #include <initializer_list>
4  #include <numeric>
5  #include <stdexcept>
6  #include <string>
7  #include <type_traits>
8  #include <vector>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/config.h"
13  #include "absl/base/internal/exception_testing.h"
14  #include "absl/base/options.h"
15  #include "absl/container/fixed_array.h"
16  #include "absl/container/inlined_vector.h"
17  #include "absl/hash/hash_testing.h"
18  #include "absl/strings/str_cat.h"
19  namespace {
20  MATCHER_P(DataIs, data,
21            absl::StrCat("data() ", negation ? "isn't " : "is ",
22                         testing::PrintToString(data))) {
23    return arg.data() == data;
24  }
25  template <typename T>
26  auto SpanIs(T data, size_t size)
27      -> decltype(testing::AllOf(DataIs(data), testing::SizeIs(size))) {
28    return testing::AllOf(DataIs(data), testing::SizeIs(size));
29  }
30  template <typename Container>
31  auto SpanIs(const Container& c) -> decltype(SpanIs(c.data(), c.size())) {
32    return SpanIs(c.data(), c.size());
33  }
34  std::vector<int> MakeRamp(int len, int offset = 0) {
35    std::vector<int> v(len);
36    std::iota(v.begin(), v.end(), offset);
37    return v;
38  }
39  TEST(IntSpan, EmptyCtors) {
40    absl::Span<int> s;
41    EXPECT_THAT(s, SpanIs(nullptr, 0));
42  }
43  TEST(IntSpan, PtrLenCtor) {
44    int a[] = {1, 2, 3};
45    absl::Span<int> s(&a[0], 2);
46    EXPECT_THAT(s, SpanIs(a, 2));
47  }
48  TEST(IntSpan, ArrayCtor) {
49    int a[] = {1, 2, 3};
50    absl::Span<int> s(a);
51    EXPECT_THAT(s, SpanIs(a, 3));
52    EXPECT_TRUE((std::is_constructible<absl::Span<const int>, int[3]>::value));
53    EXPECT_TRUE(
54        (std::is_constructible<absl::Span<const int>, const int[3]>::value));
55    EXPECT_FALSE((std::is_constructible<absl::Span<int>, const int[3]>::value));
56    EXPECT_TRUE((std::is_convertible<int[3], absl::Span<const int>>::value));
57    EXPECT_TRUE(
58        (std::is_convertible<const int[3], absl::Span<const int>>::value));
59  }
60  template <typename T>
61  void TakesGenericSpan(absl::Span<T>) {}
62  TEST(IntSpan, ContainerCtor) {
63    std::vector<int> empty;
64    absl::Span<int> s_empty(empty);
65    EXPECT_THAT(s_empty, SpanIs(empty));
66    std::vector<int> filled{1, 2, 3};
67    absl::Span<int> s_filled(filled);
68    EXPECT_THAT(s_filled, SpanIs(filled));
69    absl::Span<int> s_from_span(filled);
70    EXPECT_THAT(s_from_span, SpanIs(s_filled));
71    absl::Span<const int> const_filled = filled;
72    EXPECT_THAT(const_filled, SpanIs(filled));
73    absl::Span<const int> const_from_span = s_filled;
74    EXPECT_THAT(const_from_span, SpanIs(s_filled));
75    EXPECT_TRUE(
76        (std::is_convertible<std::vector<int>&, absl::Span<const int>>::value));
77    EXPECT_TRUE(
78        (std::is_convertible<absl::Span<int>&, absl::Span<const int>>::value));
79    TakesGenericSpan(absl::Span<int>(filled));
80  }
81  struct ContainerWithShallowConstData {
82    std::vector<int> storage;
83    int* data() const { return const_cast<int*>(storage.data()); }
84    int size() const { return storage.size(); }
85  };
86  TEST(IntSpan, ShallowConstness) {
87    const ContainerWithShallowConstData c{MakeRamp(20)};
88    absl::Span<int> s(
89        c);  
90    s[0] = -1;
91    EXPECT_EQ(c.storage[0], -1);
92  }
93  TEST(CharSpan, StringCtor) {
94    std::string empty = "";
95    absl::Span<char> s_empty(empty);
96    EXPECT_THAT(s_empty, SpanIs(empty));
97    std::string abc = "abc";
98    absl::Span<char> s_abc(abc);
99    EXPECT_THAT(s_abc, SpanIs(abc));
100    absl::Span<const char> s_const_abc = abc;
101    EXPECT_THAT(s_const_abc, SpanIs(abc));
102    EXPECT_FALSE((std::is_constructible<absl::Span<int>, std::string>::value));
103    EXPECT_FALSE(
104        (std::is_constructible<absl::Span<const int>, std::string>::value));
105    EXPECT_TRUE(
106        (std::is_convertible<std::string, absl::Span<const char>>::value));
107  }
108  TEST(IntSpan, FromConstPointer) {
109    EXPECT_TRUE((std::is_constructible<absl::Span<const int* const>,
110                                       std::vector<int*>>::value));
111    EXPECT_TRUE((std::is_constructible<absl::Span<const int* const>,
112                                       std::vector<const int*>>::value));
113    EXPECT_FALSE((
114        std::is_constructible<absl::Span<const int*>, std::vector<int*>>::value));
115    EXPECT_FALSE((
116        std::is_constructible<absl::Span<int*>, std::vector<const int*>>::value));
117  }
118  struct TypeWithMisleadingData {
119    int& data() { return i; }
120    int size() { return 1; }
121    int i;
122  };
123  struct TypeWithMisleadingSize {
124    int* data() { return &i; }
125    const char* size() { return "1"; }
126    int i;
127  };
128  TEST(IntSpan, EvilTypes) {
129    EXPECT_FALSE(
130        (std::is_constructible<absl::Span<int>, TypeWithMisleadingData&>::value));
131    EXPECT_FALSE(
132        (std::is_constructible<absl::Span<int>, TypeWithMisleadingSize&>::value));
133  }
134  struct Base {
135    int* data() { return &i; }
136    int size() { return 1; }
137    int i;
138  };
139  struct Derived : Base {};
140  TEST(IntSpan, SpanOfDerived) {
141    EXPECT_TRUE((std::is_constructible<absl::Span<int>, Base&>::value));
142    EXPECT_TRUE((std::is_constructible<absl::Span<int>, Derived&>::value));
143    EXPECT_FALSE(
144        (std::is_constructible<absl::Span<Base>, std::vector<Derived>>::value));
145  }
146  void TestInitializerList(absl::Span<const int> s, const std::vector<int>& v) {
147    EXPECT_TRUE(std::equal(s.begin(), s.end(), v.begin(), v.end()));
148  }
149  TEST(ConstIntSpan, InitializerListConversion) {
150    TestInitializerList({}, {});
151    TestInitializerList({1}, {1});
152    TestInitializerList({1, 2, 3}, {1, 2, 3});
153    EXPECT_FALSE((std::is_constructible<absl::Span<int>,
154                                        std::initializer_list<int>>::value));
155    EXPECT_FALSE((
156        std::is_convertible<absl::Span<int>, std::initializer_list<int>>::value));
157  }
158  TEST(IntSpan, Data) {
159    int i;
160    absl::Span<int> s(&i, 1);
161    EXPECT_EQ(&i, s.data());
162  }
163  TEST(IntSpan, SizeLengthEmpty) {
164    absl::Span<int> empty;
165    EXPECT_EQ(empty.size(), 0);
166    EXPECT_TRUE(empty.empty());
167    EXPECT_EQ(empty.size(), empty.length());
168    auto v = MakeRamp(10);
169    absl::Span<int> s(v);
170    EXPECT_EQ(s.size(), 10);
171    EXPECT_FALSE(s.empty());
172    EXPECT_EQ(s.size(), s.length());
173  }
174  TEST(IntSpan, ElementAccess) {
175    auto v = MakeRamp(10);
176    absl::Span<int> s(v);
177    for (int i = 0; i < s.size(); ++i) {
178      EXPECT_EQ(s[i], s.at(i));
179    }
180    EXPECT_EQ(s.front(), s[0]);
181    EXPECT_EQ(s.back(), s[9]);
182  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
183    EXPECT_DEATH_IF_SUPPORTED(s[-1], "");
184    EXPECT_DEATH_IF_SUPPORTED(s[10], "");
185  #endif
186  }
187  TEST(IntSpan, AtThrows) {
188    auto v = MakeRamp(10);
189    absl::Span<int> s(v);
190    EXPECT_EQ(s.at(9), 9);
191    ABSL_BASE_INTERNAL_EXPECT_FAIL(s.at(10), std::out_of_range,
192                                   "failed bounds check");
193  }
194  TEST(IntSpan, RemovePrefixAndSuffix) {
195    auto v = MakeRamp(20, 1);
196    absl::Span<int> s(v);
197    EXPECT_EQ(s.size(), 20);
198    s.remove_suffix(0);
199    s.remove_prefix(0);
200    EXPECT_EQ(s.size(), 20);
201    s.remove_prefix(1);
202    EXPECT_EQ(s.size(), 19);
203    EXPECT_EQ(s[0], 2);
204    s.remove_suffix(1);
205    EXPECT_EQ(s.size(), 18);
206    EXPECT_EQ(s.back(), 19);
207    s.remove_prefix(7);
208    EXPECT_EQ(s.size(), 11);
209    EXPECT_EQ(s[0], 9);
210    s.remove_suffix(11);
211    EXPECT_EQ(s.size(), 0);
212    EXPECT_EQ(v, MakeRamp(20, 1));
213  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
214    absl::Span<int> prefix_death(v);
215    EXPECT_DEATH_IF_SUPPORTED(prefix_death.remove_prefix(21), "");
216    absl::Span<int> suffix_death(v);
217    EXPECT_DEATH_IF_SUPPORTED(suffix_death.remove_suffix(21), "");
218  #endif
219  }
<span onclick='openModal()' class='match'>220  TEST(IntSpan, Subspan) {
221    std::vector<int> empty;
222    EXPECT_EQ(absl::MakeSpan(empty).subspan(), empty);
223    EXPECT_THAT(absl::MakeSpan(empty).subspan(0, 0), SpanIs(empty));
224    EXPECT_THAT(absl::MakeSpan(empty).subspan(0, absl::Span<const int>::npos),
225                SpanIs(empty));
226    auto ramp = MakeRamp(10);
</span>227    EXPECT_THAT(absl::MakeSpan(ramp).subspan(), SpanIs(ramp));
228    EXPECT_THAT(absl::MakeSpan(ramp).subspan(0, 10), SpanIs(ramp));
229    EXPECT_THAT(absl::MakeSpan(ramp).subspan(0, absl::Span<const int>::npos),
230                SpanIs(ramp));
231    EXPECT_THAT(absl::MakeSpan(ramp).subspan(0, 3), SpanIs(ramp.data(), 3));
232    EXPECT_THAT(absl::MakeSpan(ramp).subspan(5, absl::Span<const int>::npos),
233                SpanIs(ramp.data() + 5, 5));
234    EXPECT_THAT(absl::MakeSpan(ramp).subspan(3, 3), SpanIs(ramp.data() + 3, 3));
235    EXPECT_THAT(absl::MakeSpan(ramp).subspan(10, 5), SpanIs(ramp.data() + 10, 0));
236  #ifdef ABSL_HAVE_EXCEPTIONS
237    EXPECT_THROW(absl::MakeSpan(ramp).subspan(11, 5), std::out_of_range);
238  #else
239    EXPECT_DEATH_IF_SUPPORTED(absl::MakeSpan(ramp).subspan(11, 5), "");
240  #endif
241  }
242  TEST(IntSpan, First) {
243    std::vector<int> empty;
244    EXPECT_THAT(absl::MakeSpan(empty).first(0), SpanIs(empty));
245    auto ramp = MakeRamp(10);
246    EXPECT_THAT(absl::MakeSpan(ramp).first(0), SpanIs(ramp.data(), 0));
247    EXPECT_THAT(absl::MakeSpan(ramp).first(10), SpanIs(ramp));
248    EXPECT_THAT(absl::MakeSpan(ramp).first(3), SpanIs(ramp.data(), 3));
249  #ifdef ABSL_HAVE_EXCEPTIONS
250    EXPECT_THROW(absl::MakeSpan(ramp).first(11), std::out_of_range);
251  #else
252    EXPECT_DEATH_IF_SUPPORTED(absl::MakeSpan(ramp).first(11), "");
253  #endif
254  }
255  TEST(IntSpan, Last) {
256    std::vector<int> empty;
257    EXPECT_THAT(absl::MakeSpan(empty).last(0), SpanIs(empty));
258    auto ramp = MakeRamp(10);
259    EXPECT_THAT(absl::MakeSpan(ramp).last(0), SpanIs(ramp.data() + 10, 0));
260    EXPECT_THAT(absl::MakeSpan(ramp).last(10), SpanIs(ramp));
261    EXPECT_THAT(absl::MakeSpan(ramp).last(3), SpanIs(ramp.data() + 7, 3));
262  #ifdef ABSL_HAVE_EXCEPTIONS
263    EXPECT_THROW(absl::MakeSpan(ramp).last(11), std::out_of_range);
264  #else
265    EXPECT_DEATH_IF_SUPPORTED(absl::MakeSpan(ramp).last(11), "");
266  #endif
267  }
268  TEST(IntSpan, MakeSpanPtrLength) {
269    std::vector<int> empty;
270    auto s_empty = absl::MakeSpan(empty.data(), empty.size());
271    EXPECT_THAT(s_empty, SpanIs(empty));
272    std::array<int, 3> a{{1, 2, 3}};
273    auto s = absl::MakeSpan(a.data(), a.size());
274    EXPECT_THAT(s, SpanIs(a));
275    EXPECT_THAT(absl::MakeConstSpan(empty.data(), empty.size()), SpanIs(s_empty));
276    EXPECT_THAT(absl::MakeConstSpan(a.data(), a.size()), SpanIs(s));
277  }
278  TEST(IntSpan, MakeSpanTwoPtrs) {
279    std::vector<int> empty;
280    auto s_empty = absl::MakeSpan(empty.data(), empty.data());
281    EXPECT_THAT(s_empty, SpanIs(empty));
282    std::vector<int> v{1, 2, 3};
283    auto s = absl::MakeSpan(v.data(), v.data() + 1);
284    EXPECT_THAT(s, SpanIs(v.data(), 1));
285    EXPECT_THAT(absl::MakeConstSpan(empty.data(), empty.data()), SpanIs(s_empty));
286    EXPECT_THAT(absl::MakeConstSpan(v.data(), v.data() + 1), SpanIs(s));
287  }
288  TEST(IntSpan, MakeSpanContainer) {
289    std::vector<int> empty;
290    auto s_empty = absl::MakeSpan(empty);
291    EXPECT_THAT(s_empty, SpanIs(empty));
292    std::vector<int> v{1, 2, 3};
293    auto s = absl::MakeSpan(v);
294    EXPECT_THAT(s, SpanIs(v));
295    EXPECT_THAT(absl::MakeConstSpan(empty), SpanIs(s_empty));
296    EXPECT_THAT(absl::MakeConstSpan(v), SpanIs(s));
297    EXPECT_THAT(absl::MakeSpan(s), SpanIs(s));
298    EXPECT_THAT(absl::MakeConstSpan(s), SpanIs(s));
299  }
300  TEST(CharSpan, MakeSpanString) {
301    std::string empty = "";
302    auto s_empty = absl::MakeSpan(empty);
303    EXPECT_THAT(s_empty, SpanIs(empty));
304    std::string str = "abc";
305    auto s_str = absl::MakeSpan(str);
306    EXPECT_THAT(s_str, SpanIs(str));
307    EXPECT_THAT(absl::MakeConstSpan(empty), SpanIs(s_empty));
308    EXPECT_THAT(absl::MakeConstSpan(str), SpanIs(s_str));
309  }
310  TEST(IntSpan, MakeSpanArray) {
311    int a[] = {1, 2, 3};
312    auto s = absl::MakeSpan(a);
313    EXPECT_THAT(s, SpanIs(a, 3));
314    const int ca[] = {1, 2, 3};
315    auto s_ca = absl::MakeSpan(ca);
316    EXPECT_THAT(s_ca, SpanIs(ca, 3));
317    EXPECT_THAT(absl::MakeConstSpan(a), SpanIs(s));
318    EXPECT_THAT(absl::MakeConstSpan(ca), SpanIs(s_ca));
319  }
320  template <typename Expected, typename T>
321  void CheckType(const T& &bsol;* value */) {
322    testing::StaticAssertTypeEq<Expected, T>();
323  }
324  TEST(IntSpan, MakeSpanTypes) {
325    std::vector<int> vec;
326    const std::vector<int> cvec;
327    int a[1];
328    const int ca[] = {1};
329    int* ip = a;
330    const int* cip = ca;
331    std::string s = "";
332    const std::string cs = "";
333    CheckType<absl::Span<int>>(absl::MakeSpan(vec));
334    CheckType<absl::Span<const int>>(absl::MakeSpan(cvec));
335    CheckType<absl::Span<int>>(absl::MakeSpan(ip, ip + 1));
336    CheckType<absl::Span<int>>(absl::MakeSpan(ip, 1));
337    CheckType<absl::Span<const int>>(absl::MakeSpan(cip, cip + 1));
338    CheckType<absl::Span<const int>>(absl::MakeSpan(cip, 1));
339    CheckType<absl::Span<int>>(absl::MakeSpan(a));
340    CheckType<absl::Span<int>>(absl::MakeSpan(a, a + 1));
341    CheckType<absl::Span<int>>(absl::MakeSpan(a, 1));
342    CheckType<absl::Span<const int>>(absl::MakeSpan(ca));
343    CheckType<absl::Span<const int>>(absl::MakeSpan(ca, ca + 1));
344    CheckType<absl::Span<const int>>(absl::MakeSpan(ca, 1));
345    CheckType<absl::Span<char>>(absl::MakeSpan(s));
346    CheckType<absl::Span<const char>>(absl::MakeSpan(cs));
347  }
348  TEST(ConstIntSpan, MakeConstSpanTypes) {
349    std::vector<int> vec;
350    const std::vector<int> cvec;
351    int array[1];
352    const int carray[] = {0};
353    int* ptr = array;
354    const int* cptr = carray;
355    std::string s = "";
356    std::string cs = "";
357    CheckType<absl::Span<const int>>(absl::MakeConstSpan(vec));
358    CheckType<absl::Span<const int>>(absl::MakeConstSpan(cvec));
359    CheckType<absl::Span<const int>>(absl::MakeConstSpan(ptr, ptr + 1));
360    CheckType<absl::Span<const int>>(absl::MakeConstSpan(ptr, 1));
361    CheckType<absl::Span<const int>>(absl::MakeConstSpan(cptr, cptr + 1));
362    CheckType<absl::Span<const int>>(absl::MakeConstSpan(cptr, 1));
363    CheckType<absl::Span<const int>>(absl::MakeConstSpan(array));
364    CheckType<absl::Span<const int>>(absl::MakeConstSpan(carray));
365    CheckType<absl::Span<const char>>(absl::MakeConstSpan(s));
366    CheckType<absl::Span<const char>>(absl::MakeConstSpan(cs));
367  }
368  TEST(IntSpan, Equality) {
369    const int arr1[] = {1, 2, 3, 4, 5};
370    int arr2[] = {1, 2, 3, 4, 5};
371    std::vector<int> vec1(std::begin(arr1), std::end(arr1));
372    std::vector<int> vec2 = vec1;
373    std::vector<int> other_vec = {2, 4, 6, 8, 10};
374    const absl::Span<const int> from1 = vec1;
375    const absl::Span<const int> from2 = vec2;
376    EXPECT_EQ(from1, from1);
377    EXPECT_FALSE(from1 != from1);
378    EXPECT_EQ(from1, from2);
379    EXPECT_FALSE(from1 != from2);
380    const absl::Span<const int> from_other = other_vec;
381    EXPECT_NE(from1, from_other);
382    EXPECT_FALSE(from1 == from_other);
383    EXPECT_EQ(vec1, from1);
384    EXPECT_FALSE(vec1 != from1);
385    EXPECT_EQ(from1, vec1);
386    EXPECT_FALSE(from1 != vec1);
387    const absl::Span<int> mutable_from1(vec1);
388    const absl::Span<int> mutable_from2(vec2);
389    EXPECT_EQ(from1, mutable_from1);
390    EXPECT_EQ(mutable_from1, from1);
391    EXPECT_EQ(mutable_from1, mutable_from2);
392    EXPECT_EQ(mutable_from2, mutable_from1);
393    EXPECT_EQ(vec1, mutable_from1);
394    EXPECT_FALSE(vec1 != mutable_from1);
395    EXPECT_EQ(mutable_from1, vec1);
396    EXPECT_FALSE(mutable_from1 != vec1);
397    EXPECT_TRUE(arr1 == mutable_from1);
398    EXPECT_FALSE(arr1 != mutable_from1);
399    EXPECT_TRUE(mutable_from1 == arr1);
400    EXPECT_FALSE(mutable_from1 != arr1);
401    EXPECT_TRUE(arr2 == from1);
402    EXPECT_FALSE(arr2 != from1);
403    EXPECT_TRUE(from1 == arr2);
404    EXPECT_FALSE(from1 != arr2);
405    EXPECT_NE(from1, absl::Span<const int>(from1).subspan(0, from1.size() - 1));
406    ++vec2.back();
407    EXPECT_NE(from1, from2);
408  }
409  class IntSpanOrderComparisonTest : public testing::Test {
410   public:
411    IntSpanOrderComparisonTest()
412        : arr_before_{1, 2, 3},
413          arr_after_{1, 2, 4},
414          carr_after_{1, 2, 4},
415          vec_before_(std::begin(arr_before_), std::end(arr_before_)),
416          vec_after_(std::begin(arr_after_), std::end(arr_after_)),
417          before_(vec_before_),
418          after_(vec_after_),
419          cbefore_(vec_before_),
420          cafter_(vec_after_) {}
421   protected:
422    int arr_before_[3], arr_after_[3];
423    const int carr_after_[3];
424    std::vector<int> vec_before_, vec_after_;
425    absl::Span<int> before_, after_;
426    absl::Span<const int> cbefore_, cafter_;
427  };
428  TEST_F(IntSpanOrderComparisonTest, CompareSpans) {
429    EXPECT_TRUE(cbefore_ < cafter_);
430    EXPECT_TRUE(cbefore_ <= cafter_);
431    EXPECT_TRUE(cafter_ > cbefore_);
432    EXPECT_TRUE(cafter_ >= cbefore_);
433    EXPECT_FALSE(cbefore_ > cafter_);
434    EXPECT_FALSE(cafter_ < cbefore_);
435    EXPECT_TRUE(before_ < after_);
436    EXPECT_TRUE(before_ <= after_);
437    EXPECT_TRUE(after_ > before_);
438    EXPECT_TRUE(after_ >= before_);
439    EXPECT_FALSE(before_ > after_);
440    EXPECT_FALSE(after_ < before_);
441    EXPECT_TRUE(cbefore_ < after_);
442    EXPECT_TRUE(cbefore_ <= after_);
443    EXPECT_TRUE(after_ > cbefore_);
444    EXPECT_TRUE(after_ >= cbefore_);
445    EXPECT_FALSE(cbefore_ > after_);
446    EXPECT_FALSE(after_ < cbefore_);
447  }
448  TEST_F(IntSpanOrderComparisonTest, SpanOfConstAndContainer) {
449    EXPECT_TRUE(cbefore_ < vec_after_);
450    EXPECT_TRUE(cbefore_ <= vec_after_);
451    EXPECT_TRUE(vec_after_ > cbefore_);
452    EXPECT_TRUE(vec_after_ >= cbefore_);
453    EXPECT_FALSE(cbefore_ > vec_after_);
454    EXPECT_FALSE(vec_after_ < cbefore_);
455    EXPECT_TRUE(arr_before_ < cafter_);
456    EXPECT_TRUE(arr_before_ <= cafter_);
457    EXPECT_TRUE(cafter_ > arr_before_);
458    EXPECT_TRUE(cafter_ >= arr_before_);
459    EXPECT_FALSE(arr_before_ > cafter_);
460    EXPECT_FALSE(cafter_ < arr_before_);
461  }
462  TEST_F(IntSpanOrderComparisonTest, SpanOfMutableAndContainer) {
463    EXPECT_TRUE(vec_before_ < after_);
464    EXPECT_TRUE(vec_before_ <= after_);
465    EXPECT_TRUE(after_ > vec_before_);
466    EXPECT_TRUE(after_ >= vec_before_);
467    EXPECT_FALSE(vec_before_ > after_);
468    EXPECT_FALSE(after_ < vec_before_);
469    EXPECT_TRUE(before_ < carr_after_);
470    EXPECT_TRUE(before_ <= carr_after_);
471    EXPECT_TRUE(carr_after_ > before_);
472    EXPECT_TRUE(carr_after_ >= before_);
473    EXPECT_FALSE(before_ > carr_after_);
474    EXPECT_FALSE(carr_after_ < before_);
475  }
476  TEST_F(IntSpanOrderComparisonTest, EqualSpans) {
477    EXPECT_FALSE(before_ < before_);
478    EXPECT_TRUE(before_ <= before_);
479    EXPECT_FALSE(before_ > before_);
480    EXPECT_TRUE(before_ >= before_);
481  }
482  TEST_F(IntSpanOrderComparisonTest, Subspans) {
483    auto subspan = before_.subspan(0, 1);
484    EXPECT_TRUE(subspan < before_);
485    EXPECT_TRUE(subspan <= before_);
486    EXPECT_TRUE(before_ > subspan);
487    EXPECT_TRUE(before_ >= subspan);
488    EXPECT_FALSE(subspan > before_);
489    EXPECT_FALSE(before_ < subspan);
490  }
491  TEST_F(IntSpanOrderComparisonTest, EmptySpans) {
492    absl::Span<int> empty;
493    EXPECT_FALSE(empty < empty);
494    EXPECT_TRUE(empty <= empty);
495    EXPECT_FALSE(empty > empty);
496    EXPECT_TRUE(empty >= empty);
497    EXPECT_TRUE(empty < before_);
498    EXPECT_TRUE(empty <= before_);
499    EXPECT_TRUE(before_ > empty);
500    EXPECT_TRUE(before_ >= empty);
501    EXPECT_FALSE(empty > before_);
502    EXPECT_FALSE(before_ < empty);
503  }
504  TEST(IntSpan, ExposesContainerTypesAndConsts) {
505    absl::Span<int> slice;
506    CheckType<absl::Span<int>::iterator>(slice.begin());
507    EXPECT_TRUE((std::is_convertible<decltype(slice.begin()),
508                                     absl::Span<int>::const_iterator>::value));
509    CheckType<absl::Span<int>::const_iterator>(slice.cbegin());
510    EXPECT_TRUE((std::is_convertible<decltype(slice.end()),
511                                     absl::Span<int>::const_iterator>::value));
512    CheckType<absl::Span<int>::const_iterator>(slice.cend());
513    CheckType<absl::Span<int>::reverse_iterator>(slice.rend());
514    EXPECT_TRUE(
515        (std::is_convertible<decltype(slice.rend()),
516                             absl::Span<int>::const_reverse_iterator>::value));
517    CheckType<absl::Span<int>::const_reverse_iterator>(slice.crend());
518    testing::StaticAssertTypeEq<int, absl::Span<int>::value_type>();
519    testing::StaticAssertTypeEq<int, absl::Span<const int>::value_type>();
520    testing::StaticAssertTypeEq<int, absl::Span<int>::element_type>();
521    testing::StaticAssertTypeEq<const int, absl::Span<const int>::element_type>();
522    testing::StaticAssertTypeEq<int*, absl::Span<int>::pointer>();
523    testing::StaticAssertTypeEq<const int*, absl::Span<const int>::pointer>();
524    testing::StaticAssertTypeEq<int&, absl::Span<int>::reference>();
525    testing::StaticAssertTypeEq<const int&, absl::Span<const int>::reference>();
526    testing::StaticAssertTypeEq<const int&, absl::Span<int>::const_reference>();
527    testing::StaticAssertTypeEq<const int&,
528                                absl::Span<const int>::const_reference>();
529    EXPECT_EQ(static_cast<absl::Span<int>::size_type>(-1), absl::Span<int>::npos);
530  }
531  TEST(IntSpan, IteratorsAndReferences) {
532    auto accept_pointer = [](int*) {};
533    auto accept_reference = [](int&) {};
534    auto accept_iterator = [](absl::Span<int>::iterator) {};
535    auto accept_const_iterator = [](absl::Span<int>::const_iterator) {};
536    auto accept_reverse_iterator = [](absl::Span<int>::reverse_iterator) {};
537    auto accept_const_reverse_iterator =
538        [](absl::Span<int>::const_reverse_iterator) {};
539    int a[1];
540    absl::Span<int> s = a;
541    accept_pointer(s.data());
542    accept_iterator(s.begin());
543    accept_const_iterator(s.begin());
544    accept_const_iterator(s.cbegin());
545    accept_iterator(s.end());
546    accept_const_iterator(s.end());
547    accept_const_iterator(s.cend());
548    accept_reverse_iterator(s.rbegin());
549    accept_const_reverse_iterator(s.rbegin());
550    accept_const_reverse_iterator(s.crbegin());
551    accept_reverse_iterator(s.rend());
552    accept_const_reverse_iterator(s.rend());
553    accept_const_reverse_iterator(s.crend());
554    accept_reference(s[0]);
555    accept_reference(s.at(0));
556    accept_reference(s.front());
557    accept_reference(s.back());
558  }
559  TEST(IntSpan, IteratorsAndReferences_Const) {
560    auto accept_pointer = [](int*) {};
561    auto accept_reference = [](int&) {};
562    auto accept_iterator = [](absl::Span<int>::iterator) {};
563    auto accept_const_iterator = [](absl::Span<int>::const_iterator) {};
564    auto accept_reverse_iterator = [](absl::Span<int>::reverse_iterator) {};
565    auto accept_const_reverse_iterator =
566        [](absl::Span<int>::const_reverse_iterator) {};
567    int a[1];
568    const absl::Span<int> s = a;
569    accept_pointer(s.data());
570    accept_iterator(s.begin());
571    accept_const_iterator(s.begin());
572    accept_const_iterator(s.cbegin());
573    accept_iterator(s.end());
574    accept_const_iterator(s.end());
575    accept_const_iterator(s.cend());
576    accept_reverse_iterator(s.rbegin());
577    accept_const_reverse_iterator(s.rbegin());
578    accept_const_reverse_iterator(s.crbegin());
579    accept_reverse_iterator(s.rend());
580    accept_const_reverse_iterator(s.rend());
581    accept_const_reverse_iterator(s.crend());
582    accept_reference(s[0]);
583    accept_reference(s.at(0));
584    accept_reference(s.front());
585    accept_reference(s.back());
586  }
587  TEST(IntSpan, NoexceptTest) {
588    int a[] = {1, 2, 3};
589    std::vector<int> v;
590    EXPECT_TRUE(noexcept(absl::Span<const int>()));
591    EXPECT_TRUE(noexcept(absl::Span<const int>(a, 2)));
592    EXPECT_TRUE(noexcept(absl::Span<const int>(a)));
593    EXPECT_TRUE(noexcept(absl::Span<const int>(v)));
594    EXPECT_TRUE(noexcept(absl::Span<int>(v)));
595    EXPECT_TRUE(noexcept(absl::Span<const int>({1, 2, 3})));
596    EXPECT_TRUE(noexcept(absl::MakeSpan(v)));
597    EXPECT_TRUE(noexcept(absl::MakeSpan(a)));
598    EXPECT_TRUE(noexcept(absl::MakeSpan(a, 2)));
599    EXPECT_TRUE(noexcept(absl::MakeSpan(a, a + 1)));
600    EXPECT_TRUE(noexcept(absl::MakeConstSpan(v)));
601    EXPECT_TRUE(noexcept(absl::MakeConstSpan(a)));
602    EXPECT_TRUE(noexcept(absl::MakeConstSpan(a, 2)));
603    EXPECT_TRUE(noexcept(absl::MakeConstSpan(a, a + 1)));
604    absl::Span<int> s(v);
605    EXPECT_TRUE(noexcept(s.data()));
606    EXPECT_TRUE(noexcept(s.size()));
607    EXPECT_TRUE(noexcept(s.length()));
608    EXPECT_TRUE(noexcept(s.empty()));
609    EXPECT_TRUE(noexcept(s[0]));
610    EXPECT_TRUE(noexcept(s.front()));
611    EXPECT_TRUE(noexcept(s.back()));
612    EXPECT_TRUE(noexcept(s.begin()));
613    EXPECT_TRUE(noexcept(s.cbegin()));
614    EXPECT_TRUE(noexcept(s.end()));
615    EXPECT_TRUE(noexcept(s.cend()));
616    EXPECT_TRUE(noexcept(s.rbegin()));
617    EXPECT_TRUE(noexcept(s.crbegin()));
618    EXPECT_TRUE(noexcept(s.rend()));
619    EXPECT_TRUE(noexcept(s.crend()));
620    EXPECT_TRUE(noexcept(s.remove_prefix(0)));
621    EXPECT_TRUE(noexcept(s.remove_suffix(0)));
622  }
623  template <int i>
624  struct ConstexprTester {};
625  #define ABSL_TEST_CONSTEXPR(expr)                       \
626    do {                                                  \
627      ABSL_ATTRIBUTE_UNUSED ConstexprTester<(expr, 1)> t; \
628    } while (0)
629  struct ContainerWithConstexprMethods {
630    constexpr int size() const { return 1; }
631    constexpr const int* data() const { return &i; }
632    const int i;
633  };
634  TEST(ConstIntSpan, ConstexprTest) {
635    static constexpr int a[] = {1, 2, 3};
636    static constexpr int sized_arr[2] = {1, 2};
637    static constexpr ContainerWithConstexprMethods c{1};
638    ABSL_TEST_CONSTEXPR(absl::Span<const int>());
639    ABSL_TEST_CONSTEXPR(absl::Span<const int>(a, 2));
640    ABSL_TEST_CONSTEXPR(absl::Span<const int>(sized_arr));
641    ABSL_TEST_CONSTEXPR(absl::Span<const int>(c));
642    ABSL_TEST_CONSTEXPR(absl::MakeSpan(&a[0], 1));
643    ABSL_TEST_CONSTEXPR(absl::MakeSpan(c));
644    ABSL_TEST_CONSTEXPR(absl::MakeSpan(a));
645    ABSL_TEST_CONSTEXPR(absl::MakeConstSpan(&a[0], 1));
646    ABSL_TEST_CONSTEXPR(absl::MakeConstSpan(c));
647    ABSL_TEST_CONSTEXPR(absl::MakeConstSpan(a));
648    constexpr absl::Span<const int> span = c;
649    ABSL_TEST_CONSTEXPR(span.data());
650    ABSL_TEST_CONSTEXPR(span.size());
651    ABSL_TEST_CONSTEXPR(span.length());
652    ABSL_TEST_CONSTEXPR(span.empty());
653    ABSL_TEST_CONSTEXPR(span.begin());
654    ABSL_TEST_CONSTEXPR(span.cbegin());
655    ABSL_TEST_CONSTEXPR(span.subspan(0, 0));
656    ABSL_TEST_CONSTEXPR(span.first(1));
657    ABSL_TEST_CONSTEXPR(span.last(1));
658    ABSL_TEST_CONSTEXPR(span[0]);
659  }
660  struct BigStruct {
661    char bytes[10000];
662  };
663  TEST(Span, SpanSize) {
664    EXPECT_LE(sizeof(absl::Span<int>), 2 * sizeof(void*));
665    EXPECT_LE(sizeof(absl::Span<BigStruct>), 2 * sizeof(void*));
666  }
667  TEST(Span, Hash) {
668    int array[] = {1, 2, 3, 4};
669    int array2[] = {1, 2, 3};
670    using T = absl::Span<const int>;
671    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
672        {
673         T(), T(nullptr, 0), T(array, 0), T(array2, 0),
674         T(array, 3), T(array2), T({1, 2, 3}),
675         T(array, 1), T(array, 2),
676         T(array + 1, 2), T(array + 2, 2)}));
677  }
678  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-fast_uniform_bits_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-span_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>149    Urng63bits urng63;
150    Urng64bits urng64;
151    {
152      FastUniformBits<uint8_t> fast8;
153      EXPECT_EQ(0x0, fast8(urng1_5));
154      EXPECT_EQ(0x11, fast8(urng4));
155      EXPECT_EQ(0x20, fast8(urng22));
156      EXPECT_EQ(0x2, fast8(urng31));
157      EXPECT_EQ(0x1, fast8(urng32));
158      EXPECT_EQ(0x32, fast8(urng33));
159      EXPECT_EQ(0x77, fast8(urng63));
160      EXPECT_EQ(0xa9, fast8(urng64));
161    }
162    {
163      FastUniformBits<uint16_t> fast16;
</pre></code></div>
                <div class="column column_space"><pre><code>220  TEST(IntSpan, Subspan) {
221    std::vector<int> empty;
222    EXPECT_EQ(absl::MakeSpan(empty).subspan(), empty);
223    EXPECT_THAT(absl::MakeSpan(empty).subspan(0, 0), SpanIs(empty));
224    EXPECT_THAT(absl::MakeSpan(empty).subspan(0, absl::Span<const int>::npos),
225                SpanIs(empty));
226    auto ramp = MakeRamp(10);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    