
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.064356435643564%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_bounded.cpp</h3>
            <pre><code>1  #include <nano/lib/logger_mt.hpp>
2  #include <nano/lib/stats.hpp>
3  #include <nano/node/confirmation_height_bounded.hpp>
4  #include <nano/node/logging.hpp>
5  #include <nano/node/write_database_queue.hpp>
6  #include <nano/secure/ledger.hpp>
7  #include <boost/format.hpp>
8  #include <numeric>
9  nano::confirmation_height_bounded::confirmation_height_bounded (nano::ledger & ledger_a, nano::write_database_queue & write_database_queue_a, std::chrono::milliseconds batch_separate_pending_min_time_a, nano::logging const & logging_a, nano::logger_mt & logger_a, std::atomic<bool> & stopped_a, uint64_t & batch_write_size_a, std::function<void (std::vector<std::shared_ptr<nano::block>> const &)> const & notify_observers_callback_a, std::function<void (nano::block_hash const &)> const & notify_block_already_cemented_observers_callback_a, std::function<uint64_t ()> const & awaiting_processing_size_callback_a) :
10  	ledger (ledger_a),
11  	write_database_queue (write_database_queue_a),
12  	batch_separate_pending_min_time (batch_separate_pending_min_time_a),
13  	logging (logging_a),
14  	logger (logger_a),
15  	stopped (stopped_a),
16  	batch_write_size (batch_write_size_a),
17  	notify_observers_callback (notify_observers_callback_a),
18  	notify_block_already_cemented_observers_callback (notify_block_already_cemented_observers_callback_a),
19  	awaiting_processing_size_callback (awaiting_processing_size_callback_a)
20  {
21  }
22  nano::confirmation_height_bounded::top_and_next_hash nano::confirmation_height_bounded::get_next_block (boost::optional<top_and_next_hash> const & next_in_receive_chain_a, boost::circular_buffer_space_optimized<nano::block_hash> const & checkpoints_a, boost::circular_buffer_space_optimized<receive_source_pair> const & receive_source_pairs, boost::optional<receive_chain_details> & receive_details_a, nano::block const & original_block)
23  {
24  	top_and_next_hash next;
25  	if (next_in_receive_chain_a.is_initialized ())
26  	{
27  		next = *next_in_receive_chain_a;
28  	}
29  	else if (!receive_source_pairs.empty ())
30  	{
31  		auto next_receive_source_pair = receive_source_pairs.back ();
32  		receive_details_a = next_receive_source_pair.receive_details;
33  		next = { next_receive_source_pair.source_hash, receive_details_a->next, receive_details_a->height + 1 };
34  	}
35  	else if (!checkpoints_a.empty ())
36  	{
37  		next = { checkpoints_a.back (), boost::none, 0 };
38  	}
39  	else
40  	{
41  		next = { original_block.hash (), boost::none, 0 };
42  	}
43  	return next;
44  }
45  void nano::confirmation_height_bounded::process (std::shared_ptr<nano::block> original_block)
46  {
47  	if (pending_empty ())
48  	{
49  		clear_process_vars ();
50  		timer.restart ();
51  	}
52  	boost::optional<top_and_next_hash> next_in_receive_chain;
53  	boost::circular_buffer_space_optimized<nano::block_hash> checkpoints{ max_items };
54  	boost::circular_buffer_space_optimized<receive_source_pair> receive_source_pairs{ max_items };
55  	nano::block_hash current;
56  	bool first_iter = true;
57  	auto transaction (ledger.store.tx_begin_read ());
58  	do
59  	{
60  		boost::optional<receive_chain_details> receive_details;
61  		auto hash_to_process = get_next_block (next_in_receive_chain, checkpoints, receive_source_pairs, receive_details, *original_block);
62  		current = hash_to_process.top;
63  		auto top_level_hash = current;
64  		std::shared_ptr<nano::block> block;
65  		if (first_iter)
66  		{
67  			debug_assert (current == original_block->hash ());
68  			block = original_block;
69  		}
70  		else
71  		{
72  			block = ledger.store.block.get (transaction, current);
73  		}
74  		if (!block)
75  		{
76  			if (ledger.pruning && ledger.store.pruned.exists (transaction, current))
77  			{
78  				if (!receive_source_pairs.empty ())
79  				{
80  					receive_source_pairs.pop_back ();
81  				}
82  				continue;
83  			}
84  			else
85  			{
86  				auto error_str = (boost::format ("Ledger mismatch trying to set confirmation height for block %1% (bounded processor)") % current.to_string ()).str ();
87  				logger.always_log (error_str);
88  				std::cerr << error_str << std::endl;
89  				release_assert (block);
90  			}
91  		}
92  		nano::account account (block->account ());
93  		if (account.is_zero ())
94  		{
95  			account = block->sideband ().account;
96  		}
97  		nano::confirmation_height_info confirmation_height_info;
98  		auto account_it = accounts_confirmed_info.find (account);
99  		if (account_it != accounts_confirmed_info.cend ())
100  		{
101  			confirmation_height_info.height = account_it->second.confirmed_height;
102  			confirmation_height_info.frontier = account_it->second.iterated_frontier;
103  		}
104  		else
105  		{
106  			ledger.store.confirmation_height.get (transaction, account, confirmation_height_info);
107  			if (first_iter && confirmation_height_info.height >= block->sideband ().height && current == original_block->hash ())
108  			{
109  				notify_block_already_cemented_observers_callback (original_block->hash ());
110  			}
111  		}
112  		auto block_height = block->sideband ().height;
113  		bool already_cemented = confirmation_height_info.height >= block_height;
114  		if (!already_cemented && block_height - confirmation_height_info.height > 1)
115  		{
116  			if (block_height - confirmation_height_info.height == 2)
117  			{
118  				current = block->previous ();
119  				--block_height;
120  			}
121  			else if (!next_in_receive_chain.is_initialized ())
122  			{
123  				current = get_least_unconfirmed_hash_from_top_level (transaction, current, account, confirmation_height_info, block_height);
124  			}
125  			else
126  			{
127  				current = *hash_to_process.next;
128  				block_height = hash_to_process.next_height;
129  			}
130  		}
131  		auto top_most_non_receive_block_hash = current;
132  		bool hit_receive = false;
133  		if (!already_cemented)
134  		{
135  			hit_receive = iterate (transaction, block_height, current, checkpoints, top_most_non_receive_block_hash, top_level_hash, receive_source_pairs, account);
136  		}
137  		if (stopped)
138  		{
139  			break;
140  		}
141  		auto is_set = next_in_receive_chain.is_initialized ();
142  		next_in_receive_chain = boost::none;
143  		if (!hit_receive || (receive_source_pairs.size () == 1 && top_most_non_receive_block_hash != current))
144  		{
145  			preparation_data preparation_data{ transaction, top_most_non_receive_block_hash, already_cemented, checkpoints, account_it, confirmation_height_info, account, block_height, current, receive_details, next_in_receive_chain };
146  			prepare_iterated_blocks_for_cementing (preparation_data);
147  			if (!is_set && !receive_source_pairs.empty ())
148  			{
149  				receive_source_pairs.pop_back ();
150  			}
151  			auto total_pending_write_block_count = std::accumulate (pending_writes.cbegin (), pending_writes.cend (), uint64_t (0), [] (uint64_t total, auto const & write_details_a) {
152  				return total += write_details_a.top_height - write_details_a.bottom_height + 1;
153  			});
154  			auto max_batch_write_size_reached = (total_pending_write_block_count >= batch_write_size);
155  			auto min_time_exceeded = (timer.since_start () >= batch_separate_pending_min_time);
156  			auto finished_iterating = current == original_block->hash ();
157  			auto non_awaiting_processing = awaiting_processing_size_callback () == 0;
158  			auto should_output = finished_iterating && (non_awaiting_processing || min_time_exceeded);
159  			auto force_write = pending_writes.size () >= pending_writes_max_size || accounts_confirmed_info.size () >= pending_writes_max_size;
160  			if ((max_batch_write_size_reached || should_output || force_write) && !pending_writes.empty ())
161  			{
162  				if (write_database_queue.process (nano::writer::confirmation_height))
163  				{
164  					auto scoped_write_guard = write_database_queue.pop ();
165  					cement_blocks (scoped_write_guard);
166  				}
167  				else if (force_write)
168  				{
169  					auto scoped_write_guard = write_database_queue.wait (nano::writer::confirmation_height);
170  					cement_blocks (scoped_write_guard);
171  				}
172  			}
173  		}
174  		first_iter = false;
175  		transaction.refresh ();
176  	} while ((!receive_source_pairs.empty () || current != original_block->hash ()) && !stopped);
177  	debug_assert (checkpoints.empty ());
178  }
179  nano::block_hash nano::confirmation_height_bounded::get_least_unconfirmed_hash_from_top_level (nano::transaction const & transaction_a, nano::block_hash const & hash_a, nano::account const & account_a, nano::confirmation_height_info const & confirmation_height_info_a, uint64_t & block_height_a)
180  {
181  	nano::block_hash least_unconfirmed_hash = hash_a;
182  	if (confirmation_height_info_a.height != 0)
183  	{
184  		if (block_height_a > confirmation_height_info_a.height)
185  		{
186  			auto block (ledger.store.block.get (transaction_a, confirmation_height_info_a.frontier));
187  			release_assert (block != nullptr);
188  			least_unconfirmed_hash = block->sideband ().successor;
189  			block_height_a = block->sideband ().height + 1;
190  		}
191  	}
192  	else
193  	{
194  		auto info = ledger.account_info (transaction_a, account_a);
195  		release_assert (info);
196  		least_unconfirmed_hash = info->open_block;
197  		block_height_a = 1;
198  	}
199  	return least_unconfirmed_hash;
200  }
201  bool nano::confirmation_height_bounded::iterate (nano::read_transaction const & transaction_a, uint64_t bottom_height_a, nano::block_hash const & bottom_hash_a, boost::circular_buffer_space_optimized<nano::block_hash> & checkpoints_a, nano::block_hash & top_most_non_receive_block_hash_a, nano::block_hash const & top_level_hash_a, boost::circular_buffer_space_optimized<receive_source_pair> & receive_source_pairs_a, nano::account const & account_a)
202  {
203  	bool reached_target = false;
204  	bool hit_receive = false;
205  	auto hash = bottom_hash_a;
206  	uint64_t num_blocks = 0;
207  	while (!hash.is_zero () && !reached_target && !stopped)
208  	{
209  		++num_blocks;
210  		auto block = ledger.store.block.get (transaction_a, hash);
211  		auto source (block->source ());
212  		if (source.is_zero ())
213  		{
214  			source = block->link ().as_block_hash ();
215  		}
216  		if (!source.is_zero () && !ledger.is_epoch_link (source) && ledger.store.block.exists (transaction_a, source))
217  		{
218  			hit_receive = true;
219  			reached_target = true;
220  			auto const & sideband (block->sideband ());
221  			auto next = !sideband.successor.is_zero () && sideband.successor != top_level_hash_a ? boost::optional<nano::block_hash> (sideband.successor) : boost::none;
222  			receive_source_pairs_a.push_back ({ receive_chain_details{ account_a, sideband.height, hash, top_level_hash_a, next, bottom_height_a, bottom_hash_a }, source });
223  			if (receive_source_pairs_a.size () % max_items == 0)
224  			{
225  				checkpoints_a.push_back (top_level_hash_a);
226  			}
227  		}
228  		else
229  		{
230  			top_most_non_receive_block_hash_a = hash;
231  			if (hash == top_level_hash_a)
232  			{
233  				reached_target = true;
234  			}
235  			else
236  			{
237  				hash = block->sideband ().successor;
238  			}
239  		}
240  		if ((num_blocks > 0) && num_blocks % batch_read_size == 0)
241  		{
242  			transaction_a.refresh ();
243  		}
244  	}
245  	return hit_receive;
246  }
247  void nano::confirmation_height_bounded::prepare_iterated_blocks_for_cementing (preparation_data & preparation_data_a)
248  {
249  	if (!preparation_data_a.already_cemented)
250  	{
251  		auto block_height = (ledger.store.block.account_height (preparation_data_a.transaction, preparation_data_a.top_most_non_receive_block_hash));
252  		if (block_height > preparation_data_a.confirmation_height_info.height)
253  		{
254  			confirmed_info confirmed_info_l{ block_height, preparation_data_a.top_most_non_receive_block_hash };
255  			if (preparation_data_a.account_it != accounts_confirmed_info.cend ())
256  			{
257  				preparation_data_a.account_it->second = confirmed_info_l;
258  			}
259  			else
260  			{
261  				accounts_confirmed_info.emplace (preparation_data_a.account, confirmed_info_l);
262  				++accounts_confirmed_info_size;
263  			}
264  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), preparation_data_a.top_most_non_receive_block_hash), preparation_data_a.checkpoints.end ());
265  			pending_writes.emplace_back (preparation_data_a.account, preparation_data_a.bottom_height, preparation_data_a.bottom_most, block_height, preparation_data_a.top_most_non_receive_block_hash);
266  			++pending_writes_size;
267  		}
268  	}
269  	auto & receive_details = preparation_data_a.receive_details;
270  	if (receive_details)
271  	{
272  		auto receive_confirmed_info_it = accounts_confirmed_info.find (receive_details->account);
273  		if (receive_confirmed_info_it != accounts_confirmed_info.cend ())
274  		{
275  			auto & receive_confirmed_info = receive_confirmed_info_it->second;
276  			receive_confirmed_info.confirmed_height = receive_details->height;
277  			receive_confirmed_info.iterated_frontier = receive_details->hash;
278  		}
279  		else
280  		{
281  			accounts_confirmed_info.emplace (std::piecewise_construct, std::forward_as_tuple (receive_details->account), std::forward_as_tuple (receive_details->height, receive_details->hash));
282  			++accounts_confirmed_info_size;
283  		}
284  		if (receive_details->next.is_initialized ())
285  		{
286  			preparation_data_a.next_in_receive_chain = top_and_next_hash{ receive_details->top_level, receive_details->next, receive_details->height + 1 };
287  		}
288  		else
289  		{
290  			preparation_data_a.checkpoints.erase (std::remove (preparation_data_a.checkpoints.begin (), preparation_data_a.checkpoints.end (), receive_details->hash), preparation_data_a.checkpoints.end ());
291  		}
292  		pending_writes.emplace_back (receive_details->account, receive_details->bottom_height, receive_details->bottom_most, receive_details->height, receive_details->hash);
293  		++pending_writes_size;
294  	}
295  }
296  void nano::confirmation_height_bounded::cement_blocks (nano::write_guard & scoped_write_guard_a)
297  {
298  	std::vector<std::shared_ptr<nano::block>> cemented_blocks;
299  	auto const maximum_batch_write_time = 250; 
300  	auto const maximum_batch_write_time_increase_cutoff = maximum_batch_write_time - (maximum_batch_write_time / 5);
301  	auto const amount_to_change = batch_write_size / 10; 
302  	auto const minimum_batch_write_size = 16384u;
303  	nano::timer<> cemented_batch_timer;
304  	auto error = false;
305  	{
306  		auto transaction (ledger.store.tx_begin_write ({}, { nano::tables::confirmation_height }));
307  		cemented_batch_timer.start ();
308  		while (!error && !pending_writes.empty ())
309  		{
310  			auto const & pending = pending_writes.front ();
311  			auto const & account = pending.account;
312  			auto write_confirmation_height = [&account, &ledger = ledger, &transaction] (uint64_t num_blocks_cemented, uint64_t confirmation_height, nano::block_hash const & confirmed_frontier) {
313  #ifndef NDEBUG
314  				nano::confirmation_height_info confirmation_height_info;
315  				ledger.store.confirmation_height.get (transaction, account, confirmation_height_info);
316  				auto block (ledger.store.block.get (transaction, confirmed_frontier));
317  				debug_assert (block != nullptr);
318  				debug_assert (block->sideband ().height == confirmation_height_info.height + num_blocks_cemented);
319  #endif
320  				ledger.store.confirmation_height.put (transaction, account, nano::confirmation_height_info{ confirmation_height, confirmed_frontier });
321  				ledger.cache.cemented_count += num_blocks_cemented;
322  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in, num_blocks_cemented);
323  				ledger.stats.add (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in, num_blocks_cemented);
324  			};
325  			nano::confirmation_height_info confirmation_height_info;
326  			ledger.store.confirmation_height.get (transaction, pending.account, confirmation_height_info);
327  			if (pending.top_height > confirmation_height_info.height)
328  			{
329  				nano::block_hash new_cemented_frontier;
330  				uint64_t num_blocks_confirmed = 0;
331  				uint64_t start_height = 0;
332  				if (pending.bottom_height > confirmation_height_info.height)
333  				{
334  					new_cemented_frontier = pending.bottom_hash;
335  					debug_assert (pending.bottom_height == confirmation_height_info.height + 1);
336  					num_blocks_confirmed = pending.top_height - pending.bottom_height + 1;
337  					start_height = pending.bottom_height;
338  				}
339  				else
340  				{
341  					auto block = ledger.store.block.get (transaction, confirmation_height_info.frontier);
342  					new_cemented_frontier = block->sideband ().successor;
343  					num_blocks_confirmed = pending.top_height - confirmation_height_info.height;
344  					start_height = confirmation_height_info.height + 1;
345  				}
346  				auto total_blocks_cemented = 0;
347  				auto block = ledger.store.block.get (transaction, new_cemented_frontier);
348  				for (auto num_blocks_iterated = 0; num_blocks_confirmed - num_blocks_iterated != 0; ++num_blocks_iterated)
349  				{
350  					if (!block)
351  					{
352  						auto error_str = (boost::format ("Failed to write confirmation height for block %1% (bounded processor)") % new_cemented_frontier.to_string ()).str ();
353  						logger.always_log (error_str);
354  						std::cerr << error_str << std::endl;
355  						cemented_blocks.erase (cemented_blocks.end () - num_blocks_iterated, cemented_blocks.end ());
356  						error = true;
357  						break;
358  					}
359  					auto last_iteration = (num_blocks_confirmed - num_blocks_iterated) == 1;
360  					cemented_blocks.emplace_back (block);
361  					if (cemented_blocks.size () > batch_write_size + (batch_write_size / 10))
362  					{
363  						auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
364  						auto num_blocks_cemented = num_blocks_iterated - total_blocks_cemented + 1;
365  						total_blocks_cemented += num_blocks_cemented;
366  						write_confirmation_height (num_blocks_cemented, start_height + total_blocks_cemented - 1, new_cemented_frontier);
367  						transaction.commit ();
368  						if (logging.timing_logging ())
369  						{
370  							logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (bounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
371  						}
372  						if (time_spent_cementing > maximum_batch_write_time)
373  						{
374  							batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
375  						}
376  						else if (time_spent_cementing < maximum_batch_write_time_increase_cutoff)
377  						{
378  							batch_write_size += amount_to_change;
379  						}
380  						scoped_write_guard_a.release ();
381  						notify_observers_callback (cemented_blocks);
382  						cemented_blocks.clear ();
383  						if (!(last_iteration && pending_writes.size () == 1))
384  						{
385  							scoped_write_guard_a = write_database_queue.wait (nano::writer::confirmation_height);
386  							transaction.renew ();
387  						}
388  						cemented_batch_timer.restart ();
389  					}
390  					if (!last_iteration)
391  					{
392  						new_cemented_frontier = block->sideband ().successor;
393  						block = ledger.store.block.get (transaction, new_cemented_frontier);
394  					}
395  					else
396  					{
397  						debug_assert (new_cemented_frontier == pending.top_hash);
398  					}
399  				}
400  				if (error)
401  				{
402  					break;
403  				}
404  				auto num_blocks_cemented = num_blocks_confirmed - total_blocks_cemented;
405  				if (num_blocks_cemented > 0)
406  				{
407  					write_confirmation_height (num_blocks_cemented, pending.top_height, new_cemented_frontier);
408  				}
409  			}
<span onclick='openModal()' class='match'>410  			auto it = accounts_confirmed_info.find (pending.account);
411  			if (it != accounts_confirmed_info.cend () && it->second.confirmed_height == pending.top_height)
412  			{
413  				accounts_confirmed_info.erase (pending.account);
414  				--accounts_confirmed_info_size;
415  			}
416  			pending_writes.pop_front ();
</span>417  			--pending_writes_size;
418  		}
419  	}
420  	auto time_spent_cementing = cemented_batch_timer.since_start ().count ();
421  	if (logging.timing_logging () && time_spent_cementing > 50)
422  	{
423  		logger.always_log (boost::str (boost::format ("Cemented %1% blocks in %2% %3% (bounded processor)") % cemented_blocks.size () % time_spent_cementing % cemented_batch_timer.unit ()));
424  	}
425  	if (scoped_write_guard_a.is_owned () && !cemented_blocks.empty ())
426  	{
427  		scoped_write_guard_a.release ();
428  		notify_observers_callback (cemented_blocks);
429  	}
430  	release_assert (!error);
431  	if (time_spent_cementing > maximum_batch_write_time)
432  	{
433  		batch_write_size = std::max<uint64_t> (minimum_batch_write_size, batch_write_size - amount_to_change);
434  	}
435  	debug_assert (pending_writes.empty ());
436  	debug_assert (pending_writes_size == 0);
437  	timer.restart ();
438  }
439  bool nano::confirmation_height_bounded::pending_empty () const
440  {
441  	return pending_writes.empty ();
442  }
443  void nano::confirmation_height_bounded::clear_process_vars ()
444  {
445  	accounts_confirmed_info.clear ();
446  	accounts_confirmed_info_size = 0;
447  }
448  nano::confirmation_height_bounded::receive_chain_details::receive_chain_details (nano::account const & account_a, uint64_t height_a, nano::block_hash const & hash_a, nano::block_hash const & top_level_a, boost::optional<nano::block_hash> next_a, uint64_t bottom_height_a, nano::block_hash const & bottom_most_a) :
449  	account (account_a),
450  	height (height_a),
451  	hash (hash_a),
452  	top_level (top_level_a),
453  	next (next_a),
454  	bottom_height (bottom_height_a),
455  	bottom_most (bottom_most_a)
456  {
457  }
458  nano::confirmation_height_bounded::write_details::write_details (nano::account const & account_a, uint64_t bottom_height_a, nano::block_hash const & bottom_hash_a, uint64_t top_height_a, nano::block_hash const & top_hash_a) :
459  	account (account_a),
460  	bottom_height (bottom_height_a),
461  	bottom_hash (bottom_hash_a),
462  	top_height (top_height_a),
463  	top_hash (top_hash_a)
464  {
465  }
466  nano::confirmation_height_bounded::receive_source_pair::receive_source_pair (confirmation_height_bounded::receive_chain_details const & receive_details_a, const block_hash & source_a) :
467  	receive_details (receive_details_a),
468  	source_hash (source_a)
469  {
470  }
471  nano::confirmation_height_bounded::confirmed_info::confirmed_info (uint64_t confirmed_height_a, nano::block_hash const & iterated_frontier_a) :
472  	confirmed_height (confirmed_height_a),
473  	iterated_frontier (iterated_frontier_a)
474  {
475  }
476  std::unique_ptr<nano::container_info_component> nano::collect_container_info (confirmation_height_bounded & confirmation_height_bounded, std::string const & name_a)
477  {
478  	auto composite = std::make_unique<container_info_composite> (name_a);
479  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "pending_writes", confirmation_height_bounded.pending_writes_size, sizeof (decltype (confirmation_height_bounded.pending_writes)::value_type) }));
480  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "accounts_confirmed_info", confirmation_height_bounded.accounts_confirmed_info_size, sizeof (decltype (confirmation_height_bounded.accounts_confirmed_info)::value_type) }));
481  	return composite;
482  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stringrenderer.cpp</h3>
            <pre><code>1  #include "stringrenderer.h"
2  #include <allheaders.h> 
3  #include "boxchar.h"
4  #include "helpers.h" 
5  #include "ligature_table.h"
6  #include "normstrngs.h"
7  #include "tlog.h"
8  #include <tesseract/unichar.h>
9  #include "pango/pango-font.h"
10  #include "pango/pango-glyph-item.h"
11  #include "unicode/uchar.h" 
12  #include <algorithm>
13  #include <cassert>
14  #include <cstdio>
15  #include <cstring>
16  #include <map>
17  #include <utility>
18  #include <vector>
19  #define DISABLE_HEAP_LEAK_CHECK
20  namespace tesseract {
21  static const int kDefaultOutputResolution = 300;
22  static const char *kWordJoinerUTF8 = "\u2060";
23  static bool IsCombiner(int ch) {
24    const int char_type = u_charType(ch);
25    return ((char_type == U_NON_SPACING_MARK) || (char_type == U_ENCLOSING_MARK) ||
26            (char_type == U_COMBINING_SPACING_MARK));
27  }
28  static std::string EncodeAsUTF8(const char32 ch32) {
29    UNICHAR uni_ch(ch32);
30    return std::string(uni_ch.utf8(), uni_ch.utf8_len());
31  }
32  static bool RandBool(const double prob, TRand *rand) {
33    if (prob == 1.0) {
34      return true;
35    }
36    if (prob == 0.0) {
37      return false;
38    }
39    return rand->UnsignedRand(1.0) < prob;
40  }
41  static Image CairoARGB32ToPixFormat(cairo_surface_t *surface) {
42    if (cairo_image_surface_get_format(surface) != CAIRO_FORMAT_ARGB32) {
43      printf("Unexpected surface format %d\n", cairo_image_surface_get_format(surface));
44      return nullptr;
45    }
46    const int width = cairo_image_surface_get_width(surface);
47    const int height = cairo_image_surface_get_height(surface);
48    Image pix = pixCreate(width, height, 32);
49    int byte_stride = cairo_image_surface_get_stride(surface);
50    for (int i = 0; i < height; ++i) {
51      memcpy(reinterpret_cast<unsigned char *>(pixGetData(pix) + i * pixGetWpl(pix)) + 1,
52             cairo_image_surface_get_data(surface) + i * byte_stride,
53             byte_stride - ((i == height - 1) ? 1 : 0));
54    }
55    return pix;
56  }
57  StringRenderer::StringRenderer(const std::string &font_desc, int page_width, int page_height)
58      : font_(font_desc)
59      , page_width_(page_width)
60      , page_height_(page_height)
61      , h_margin_(50)
62      , v_margin_(50)
63      , pen_color_{0.0, 0.0, 0.0}
64      , char_spacing_(0)
65      , leading_(0)
66      , vertical_text_(false)
67      , gravity_hint_strong_(false)
68      , render_fullwidth_latin_(false)
69      , underline_start_prob_(0)
70      , underline_continuation_prob_(0)
71      , underline_style_(PANGO_UNDERLINE_SINGLE)
72      , drop_uncovered_chars_(true)
73      , strip_unrenderable_words_(false)
74      , add_ligatures_(false)
75      , output_word_boxes_(false)
76      , surface_(nullptr)
77      , cr_(nullptr)
78      , layout_(nullptr)
79      , start_box_(0)
80      , page_(0)
81      , box_padding_(0)
82      , page_boxes_(nullptr)
83      , total_chars_(0)
84      , font_index_(0)
85      , last_offset_(0) {
86    set_resolution(kDefaultOutputResolution);
87    set_font(font_desc);
88  }
89  bool StringRenderer::set_font(const std::string &desc) {
90    bool success = font_.ParseFontDescriptionName(desc);
91    font_.set_resolution(resolution_);
92    return success;
93  }
94  void StringRenderer::set_resolution(const int resolution) {
95    resolution_ = resolution;
96    font_.set_resolution(resolution);
97  }
98  void StringRenderer::set_underline_start_prob(const double frac) {
99    underline_start_prob_ = std::min(std::max(frac, 0.0), 1.0);
100  }
101  void StringRenderer::set_underline_continuation_prob(const double frac) {
102    underline_continuation_prob_ = std::min(std::max(frac, 0.0), 1.0);
103  }
104  StringRenderer::~StringRenderer() {
105    ClearBoxes();
106    FreePangoCairo();
107  }
108  void StringRenderer::InitPangoCairo() {
109    FreePangoCairo();
110    surface_ = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, page_width_, page_height_);
111    cr_ = cairo_create(surface_);
112    {
113      DISABLE_HEAP_LEAK_CHECK;
114      layout_ = pango_cairo_create_layout(cr_);
115    }
116    if (vertical_text_) {
117      PangoContext *context = pango_layout_get_context(layout_);
118      pango_context_set_base_gravity(context, PANGO_GRAVITY_EAST);
119      if (gravity_hint_strong_) {
120        pango_context_set_gravity_hint(context, PANGO_GRAVITY_HINT_STRONG);
121      }
122      pango_layout_context_changed(layout_);
123    }
124    SetLayoutProperties();
125  }
126  void StringRenderer::SetLayoutProperties() {
127    std::string font_desc = font_.DescriptionName();
128    PangoFontDescription *desc = pango_font_description_from_string(font_desc.c_str());
129    pango_layout_set_font_description(layout_, desc);
130    pango_font_description_free(desc); 
131    pango_cairo_context_set_resolution(pango_layout_get_context(layout_), resolution_);
132    int max_width = page_width_ - 2 * h_margin_;
133    int max_height = page_height_ - 2 * v_margin_;
134    tlog(3, "max_width = %d, max_height = %d\n", max_width, max_height);
135    if (vertical_text_) {
136      using std::swap;
137      swap(max_width, max_height);
138    }
139    pango_layout_set_width(layout_, max_width * PANGO_SCALE);
140    pango_layout_set_wrap(layout_, PANGO_WRAP_WORD_CHAR);
141    PangoAttrList *attr_list = pango_attr_list_new();
142    if (char_spacing_) {
143      PangoAttribute *spacing_attr = pango_attr_letter_spacing_new(char_spacing_ * PANGO_SCALE);
144      spacing_attr->start_index = 0;
145      spacing_attr->end_index = static_cast<guint>(-1);
146      pango_attr_list_change(attr_list, spacing_attr);
147    }
148    if (add_ligatures_) {
149      set_features("liga, clig, dlig, hlig");
150      PangoAttribute *feature_attr = pango_attr_font_features_new(features_.c_str());
151      pango_attr_list_change(attr_list, feature_attr);
152    }
153    pango_layout_set_attributes(layout_, attr_list);
154    pango_attr_list_unref(attr_list);
155    if (leading_) {
156      pango_layout_set_spacing(layout_, leading_ * PANGO_SCALE);
157    }
158  }
159  void StringRenderer::FreePangoCairo() {
160    if (layout_) {
161      g_object_unref(layout_);
162      layout_ = nullptr;
163    }
164    if (cr_) {
165      cairo_destroy(cr_);
166      cr_ = nullptr;
167    }
168    if (surface_) {
169      cairo_surface_destroy(surface_);
170      surface_ = nullptr;
171    }
172  }
173  void StringRenderer::SetWordUnderlineAttributes(const std::string &page_text) {
174    if (underline_start_prob_ == 0) {
175      return;
176    }
177    PangoAttrList *attr_list = pango_layout_get_attributes(layout_);
178    const char *text = page_text.c_str();
179    size_t offset = 0;
180    TRand rand;
181    bool started_underline = false;
182    PangoAttribute *und_attr = nullptr;
183    while (offset < page_text.length()) {
184      offset += SpanUTF8Whitespace(text + offset);
185      if (offset == page_text.length()) {
186        break;
187      }
188      int word_start = offset;
189      int word_len = SpanUTF8NotWhitespace(text + offset);
190      offset += word_len;
191      if (started_underline) {
192        if (RandBool(underline_continuation_prob_, &rand)) {
193          und_attr->end_index = word_start + word_len;
194        } else {
195          pango_attr_list_insert(attr_list, und_attr);
196          started_underline = false;
197          und_attr = nullptr;
198        }
199      }
200      if (!started_underline && RandBool(underline_start_prob_, &rand)) {
201        und_attr = pango_attr_underline_new(underline_style_);
202        und_attr->start_index = word_start;
203        und_attr->end_index = word_start + word_len;
204        started_underline = true;
205      }
206    }
207    if (started_underline) {
208      und_attr->end_index = page_text.length();
209      pango_attr_list_insert(attr_list, und_attr);
210    }
211  }
212  int StringRenderer::FindFirstPageBreakOffset(const char *text, int text_length) {
213    if (!text_length) {
214      return 0;
215    }
216    const int max_height = (page_height_ - 2 * v_margin_);
217    const int max_width = (page_width_ - 2 * h_margin_);
218    const int max_layout_height = vertical_text_ ? max_width : max_height;
219    UNICHAR::const_iterator it = UNICHAR::begin(text, text_length);
220    const UNICHAR::const_iterator it_end = UNICHAR::end(text, text_length);
221    const int kMaxUnicodeBufLength = 15000;
222    for (int i = 0; i < kMaxUnicodeBufLength && it != it_end; ++it, ++i) {
223      ;
224    }
225    int buf_length = it.utf8_data() - text;
226    tlog(1, "len = %d  buf_len = %d\n", text_length, buf_length);
227    pango_layout_set_text(layout_, text, buf_length);
228    PangoLayoutIter *line_iter = nullptr;
229    { 
230      DISABLE_HEAP_LEAK_CHECK;
231      line_iter = pango_layout_get_iter(layout_);
232    }
233    bool first_page = true;
234    int page_top = 0;
235    int offset = buf_length;
236    do {
237      PangoRectangle line_ink_rect;
238      pango_layout_iter_get_line_extents(line_iter, &line_ink_rect, nullptr);
239      pango_extents_to_pixels(&line_ink_rect, nullptr);
240      PangoLayoutLine *line = pango_layout_iter_get_line_readonly(line_iter);
241      if (first_page) {
242        page_top = line_ink_rect.y;
243        first_page = false;
244      }
245      int line_bottom = line_ink_rect.y + line_ink_rect.height;
246      if (line_bottom - page_top > max_layout_height) {
247        offset = line->start_index;
248        tlog(1, "Found offset = %d\n", offset);
249        break;
250      }
251    } while (pango_layout_iter_next_line(line_iter));
252    pango_layout_iter_free(line_iter);
253    return offset;
254  }
255  const std::vector<BoxChar *> &StringRenderer::GetBoxes() const {
256    return boxchars_;
257  }
258  Boxa *StringRenderer::GetPageBoxes() const {
259    return page_boxes_;
260  }
261  void StringRenderer::RotatePageBoxes(float rotation) {
262    BoxChar::RotateBoxes(rotation, page_width_ / 2, page_height_ / 2, start_box_, boxchars_.size(),
263                         &boxchars_);
264  }
265  void StringRenderer::ClearBoxes() {
266    for (auto &boxchar : boxchars_) {
267      delete boxchar;
268    }
269    boxchars_.clear();
270    boxaDestroy(&page_boxes_);
271  }
272  std::string StringRenderer::GetBoxesStr() {
273    BoxChar::PrepareToWrite(&boxchars_);
274    return BoxChar::GetTesseractBoxStr(page_height_, boxchars_);
275  }
276  void StringRenderer::WriteAllBoxes(const std::string &filename) {
277    BoxChar::PrepareToWrite(&boxchars_);
278    BoxChar::WriteTesseractBoxFile(filename, page_height_, boxchars_);
279  }
280  bool StringRenderer::GetClusterStrings(std::vector<std::string> *cluster_text) {
281    std::map<int, std::string> start_byte_to_text;
282    PangoLayoutIter *run_iter = pango_layout_get_iter(layout_);
283    const char *full_text = pango_layout_get_text(layout_);
284    do {
285      PangoLayoutRun *run = pango_layout_iter_get_run_readonly(run_iter);
286      if (!run) {
287        tlog(2, "Found end of line marker\n");
288        continue;
289      }
290      PangoGlyphItemIter cluster_iter;
291      gboolean have_cluster;
292      for (have_cluster = pango_glyph_item_iter_init_start(&cluster_iter, run, full_text);
293           have_cluster; have_cluster = pango_glyph_item_iter_next_cluster(&cluster_iter)) {
294        const int start_byte_index = cluster_iter.start_index;
295        const int end_byte_index = cluster_iter.end_index;
<span onclick='openModal()' class='match'>296        std::string text =
297            std::string(full_text + start_byte_index, end_byte_index - start_byte_index);
298        if (IsUTF8Whitespace(text.c_str())) {
299          tlog(2, "Found whitespace\n");
300          text = " ";
301        }
302        tlog(2, "start_byte=%d end_byte=%d : '%s'\n", start_byte_index, end_byte_index, text.c_str());
</span>303        if (add_ligatures_) {
304          text = LigatureTable::Get()->AddLigatures(text, nullptr);
305        }
306        start_byte_to_text[start_byte_index] = text;
307      }
308    } while (pango_layout_iter_next_run(run_iter));
309    pango_layout_iter_free(run_iter);
310    cluster_text->clear();
311    for (auto it = start_byte_to_text.begin(); it != start_byte_to_text.end(); ++it) {
312      cluster_text->push_back(it->second);
313    }
314    return !cluster_text->empty();
315  }
316  static void MergeBoxCharsToWords(std::vector<BoxChar *> *boxchars) {
317    std::vector<BoxChar *> result;
318    bool started_word = false;
319    for (auto &boxchar : *boxchars) {
320      if (boxchar->ch() == " " || boxchar->box() == nullptr) {
321        result.push_back(boxchar);
322        boxchar = nullptr;
323        started_word = false;
324        continue;
325      }
326      if (!started_word) {
327        started_word = true;
328        result.push_back(boxchar);
329        boxchar = nullptr;
330      } else {
331        BoxChar *last_boxchar = result.back();
332        const Box *box = boxchar->box();
333        Box *last_box = last_boxchar->mutable_box();
334        int left = std::min(last_box->x, box->x);
335        int right = std::max(last_box->x + last_box->w, box->x + box->w);
336        int top = std::min(last_box->y, box->y);
337        int bottom = std::max(last_box->y + last_box->h, box->y + box->h);
338        if (right - left > last_box->w + 5 * box->w) {
339          tlog(1, "Found line break after '%s'", last_boxchar->ch().c_str());
340          result.push_back(new BoxChar(" ", 1));
341          result.push_back(boxchar);
342          boxchar = nullptr;
343          continue;
344        }
345        last_boxchar->mutable_ch()->append(boxchar->ch());
346        last_box->x = left;
347        last_box->w = right - left;
348        last_box->y = top;
349        last_box->h = bottom - top;
350        delete boxchar;
351        boxchar = nullptr;
352      }
353    }
354    boxchars->swap(result);
355  }
356  void StringRenderer::ComputeClusterBoxes() {
357    const char *text = pango_layout_get_text(layout_);
358    PangoLayoutIter *cluster_iter = pango_layout_get_iter(layout_);
359    std::vector<int> cluster_start_indices;
360    do {
361      cluster_start_indices.push_back(pango_layout_iter_get_index(cluster_iter));
362      tlog(3, "Added %d\n", cluster_start_indices.back());
363    } while (pango_layout_iter_next_cluster(cluster_iter));
364    pango_layout_iter_free(cluster_iter);
365    cluster_start_indices.push_back(strlen(text));
366    tlog(3, "Added last index %d\n", cluster_start_indices.back());
367    std::sort(cluster_start_indices.begin(), cluster_start_indices.end());
368    std::map<int, int> cluster_start_to_end_index;
369    for (size_t i = 0; i + 1 < cluster_start_indices.size(); ++i) {
370      cluster_start_to_end_index[cluster_start_indices[i]] = cluster_start_indices[i + 1];
371    }
372    cluster_iter = pango_layout_get_iter(layout_);
373    std::map<int, BoxChar *> start_byte_to_box;
374    do {
375      PangoRectangle cluster_rect;
376      pango_layout_iter_get_cluster_extents(cluster_iter, &cluster_rect, nullptr);
377      pango_extents_to_pixels(&cluster_rect, nullptr);
378      const int start_byte_index = pango_layout_iter_get_index(cluster_iter);
379      const int end_byte_index = cluster_start_to_end_index[start_byte_index];
380      std::string cluster_text =
381          std::string(text + start_byte_index, end_byte_index - start_byte_index);
382      if (!cluster_text.empty() && cluster_text[0] == '\n') {
383        tlog(2, "Skipping newlines at start of text.\n");
384        continue;
385      }
386      if (!cluster_rect.width || !cluster_rect.height || IsUTF8Whitespace(cluster_text.c_str())) {
387        tlog(2, "Skipping whitespace with boxdim (%d,%d) '%s'\n", cluster_rect.width,
388             cluster_rect.height, cluster_text.c_str());
389        auto *boxchar = new BoxChar(" ", 1);
390        boxchar->set_page(page_);
391        start_byte_to_box[start_byte_index] = boxchar;
392        continue;
393      }
394      tlog(2, "[%d %d], %d, %d : start_byte=%d end_byte=%d : '%s'\n", cluster_rect.x, cluster_rect.y,
395           cluster_rect.width, cluster_rect.height, start_byte_index, end_byte_index,
396           cluster_text.c_str());
397      ASSERT_HOST_MSG(cluster_rect.width, "cluster_text:%s  start_byte_index:%d\n",
398                      cluster_text.c_str(), start_byte_index);
399      ASSERT_HOST_MSG(cluster_rect.height, "cluster_text:%s  start_byte_index:%d\n",
400                      cluster_text.c_str(), start_byte_index);
401      if (box_padding_) {
402        cluster_rect.x = std::max(0, cluster_rect.x - box_padding_);
403        cluster_rect.width += 2 * box_padding_;
404        cluster_rect.y = std::max(0, cluster_rect.y - box_padding_);
405        cluster_rect.height += 2 * box_padding_;
406      }
407      if (add_ligatures_) {
408        cluster_text = LigatureTable::Get()->AddLigatures(cluster_text, nullptr);
409      }
410      auto *boxchar = new BoxChar(cluster_text.c_str(), cluster_text.size());
411      boxchar->set_page(page_);
412      boxchar->AddBox(cluster_rect.x, cluster_rect.y, cluster_rect.width, cluster_rect.height);
413      start_byte_to_box[start_byte_index] = boxchar;
414    } while (pango_layout_iter_next_cluster(cluster_iter));
415    pango_layout_iter_free(cluster_iter);
416    std::vector<std::string> cluster_text;
417    if (GetClusterStrings(&cluster_text)) {
418      ASSERT_HOST(cluster_text.size() == start_byte_to_box.size());
419      int ind = 0;
420      for (auto it = start_byte_to_box.begin(); it != start_byte_to_box.end(); ++it, ++ind) {
421        it->second->mutable_ch()->swap(cluster_text[ind]);
422      }
423    }
424    std::vector<BoxChar *> page_boxchars;
425    page_boxchars.reserve(start_byte_to_box.size());
426    std::string last_ch;
427    for (auto it = start_byte_to_box.begin(); it != start_byte_to_box.end(); ++it) {
428      if (it->second->ch() == kWordJoinerUTF8) {
429        delete it->second;
430      } else {
431        page_boxchars.push_back(it->second);
432      }
433    }
434    CorrectBoxPositionsToLayout(&page_boxchars);
435    if (render_fullwidth_latin_) {
436      for (auto &it : start_byte_to_box) {
437        std::string half(ConvertFullwidthLatinToBasicLatin(it.second->ch()));
438        it.second->mutable_ch()->swap(half);
439      }
440    }
441    if (output_word_boxes_) {
442      MergeBoxCharsToWords(&page_boxchars);
443    }
444    boxchars_.insert(boxchars_.end(), page_boxchars.begin(), page_boxchars.end());
445    Box *page_box = nullptr;
446    Boxa *all_boxes = nullptr;
447    for (auto &page_boxchar : page_boxchars) {
448      if (page_boxchar->box() == nullptr) {
449        continue;
450      }
451      if (all_boxes == nullptr) {
452        all_boxes = boxaCreate(0);
453      }
454      boxaAddBox(all_boxes, page_boxchar->mutable_box(), L_CLONE);
455    }
456    if (all_boxes != nullptr) {
457      boxaGetExtent(all_boxes, nullptr, nullptr, &page_box);
458      boxaDestroy(&all_boxes);
459      if (page_boxes_ == nullptr) {
460        page_boxes_ = boxaCreate(0);
461      }
462      boxaAddBox(page_boxes_, page_box, L_INSERT);
463    }
464  }
465  void StringRenderer::CorrectBoxPositionsToLayout(std::vector<BoxChar *> *boxchars) {
466    if (vertical_text_) {
467      const double rotation = -pango_gravity_to_rotation(
468          pango_context_get_base_gravity(pango_layout_get_context(layout_)));
469      BoxChar::TranslateBoxes(page_width_ - h_margin_, v_margin_, boxchars);
470      BoxChar::RotateBoxes(rotation, page_width_ - h_margin_, v_margin_, 0, boxchars->size(),
471                           boxchars);
472    } else {
473      BoxChar::TranslateBoxes(h_margin_, v_margin_, boxchars);
474    }
475  }
476  int StringRenderer::StripUnrenderableWords(std::string *utf8_text) const {
477    std::string output_text;
478    std::string unrenderable_words;
479    const char *text = utf8_text->c_str();
480    size_t offset = 0;
481    int num_dropped = 0;
482    while (offset < utf8_text->length()) {
483      int space_len = SpanUTF8Whitespace(text + offset);
484      output_text.append(text + offset, space_len);
485      offset += space_len;
486      if (offset == utf8_text->length()) {
487        break;
488      }
489      int word_len = SpanUTF8NotWhitespace(text + offset);
490      if (font_.CanRenderString(text + offset, word_len)) {
491        output_text.append(text + offset, word_len);
492      } else {
493        ++num_dropped;
494        unrenderable_words.append(text + offset, word_len);
495        unrenderable_words.append(" ");
496      }
497      offset += word_len;
498    }
499    utf8_text->swap(output_text);
500    if (num_dropped > 0) {
501      tprintf("Stripped %d unrenderable word(s): '%s'\n", num_dropped, unrenderable_words.c_str());
502    }
503    return num_dropped;
504  }
505  int StringRenderer::RenderToGrayscaleImage(const char *text, int text_length, Image *pix) {
506    Image orig_pix = nullptr;
507    int offset = RenderToImage(text, text_length, &orig_pix);
508    if (orig_pix) {
509      *pix = pixConvertTo8(orig_pix, false);
510      orig_pix.destroy();
511    }
512    return offset;
513  }
514  int StringRenderer::RenderToBinaryImage(const char *text, int text_length, int threshold,
515                                          Image *pix) {
516    Image orig_pix = nullptr;
517    int offset = RenderToImage(text, text_length, &orig_pix);
518    if (orig_pix) {
519      Image gray_pix = pixConvertTo8(orig_pix, false);
520      orig_pix.destroy();
521      *pix = pixThresholdToBinary(gray_pix, threshold);
522      gray_pix.destroy();
523    } else {
524      *pix = orig_pix;
525    }
526    return offset;
527  }
528  std::string StringRenderer::InsertWordJoiners(const std::string &text) {
529    std::string out_str;
530    const UNICHAR::const_iterator it_end = UNICHAR::end(text.c_str(), text.length());
531    for (UNICHAR::const_iterator it = UNICHAR::begin(text.c_str(), text.length()); it != it_end;
532         ++it) {
533      out_str.append(it.utf8_data(), it.utf8_len());
534      UNICHAR::const_iterator next_it = it;
535      ++next_it;
536      bool next_char_is_boundary = (next_it == it_end || *next_it == ' ');
537      bool next_char_is_combiner = (next_it == it_end) ? false : IsCombiner(*next_it);
538      if (*it != ' ' && *it != '\n' && !next_char_is_boundary && !next_char_is_combiner) {
539        out_str += kWordJoinerUTF8;
540      }
541    }
542    return out_str;
543  }
544  std::string StringRenderer::ConvertBasicLatinToFullwidthLatin(const std::string &str) {
545    std::string full_str;
546    const UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
547    for (UNICHAR::const_iterator it = UNICHAR::begin(str.c_str(), str.length()); it != it_end; ++it) {
548      if (IsInterchangeValid7BitAscii(*it) && isprint(*it) && !isspace(*it)) {
549        char32 full_char = *it + 0xFEE0;
550        full_str.append(EncodeAsUTF8(full_char));
551      } else {
552        full_str.append(it.utf8_data(), it.utf8_len());
553      }
554    }
555    return full_str;
556  }
557  std::string StringRenderer::ConvertFullwidthLatinToBasicLatin(const std::string &str) {
558    std::string half_str;
559    UNICHAR::const_iterator it_end = UNICHAR::end(str.c_str(), str.length());
560    for (UNICHAR::const_iterator it = UNICHAR::begin(str.c_str(), str.length()); it != it_end; ++it) {
561      char32 half_char = FullwidthToHalfwidth(*it);
562      if (IsInterchangeValid7BitAscii(half_char) && isprint(half_char) && !isspace(half_char)) {
563        half_str.append(EncodeAsUTF8(half_char));
564      } else {
565        half_str.append(it.utf8_data(), it.utf8_len());
566      }
567    }
568    return half_str;
569  }
570  int StringRenderer::RenderToImage(const char *text, int text_length, Image *pix) {
571    if (pix && *pix) {
572      pix->destroy();
573    }
574    InitPangoCairo();
575    const int page_offset = FindFirstPageBreakOffset(text, text_length);
576    if (!page_offset) {
577      return 0;
578    }
579    start_box_ = boxchars_.size();
580    if (!vertical_text_) {
581      cairo_translate(cr_, h_margin_, v_margin_);
582    } else {
583      cairo_translate(cr_, page_width_ - h_margin_, v_margin_);
584      double rotation = -pango_gravity_to_rotation(
585          pango_context_get_base_gravity(pango_layout_get_context(layout_)));
586      tlog(2, "Rotating by %f radians\n", rotation);
587      cairo_rotate(cr_, rotation);
588      pango_cairo_update_layout(cr_, layout_);
589    }
590    std::string page_text(text, page_offset);
591    if (render_fullwidth_latin_) {
592      page_text = ConvertBasicLatinToFullwidthLatin(page_text);
593    }
594    if (strip_unrenderable_words_) {
595      StripUnrenderableWords(&page_text);
596    }
597    if (drop_uncovered_chars_ && !font_.CoversUTF8Text(page_text.c_str(), page_text.length())) {
598      int num_dropped = font_.DropUncoveredChars(&page_text);
599      if (num_dropped) {
600        tprintf("WARNING: Dropped %d uncovered characters\n", num_dropped);
601      }
602    }
603    if (add_ligatures_) {
604      page_text = LigatureTable::Get()->AddLigatures(page_text, &font_);
605    }
606    if (underline_start_prob_ > 0) {
607      SetWordUnderlineAttributes(page_text);
608    }
609    pango_layout_set_text(layout_, page_text.c_str(), page_text.length());
610    if (pix) {
611      cairo_set_source_rgb(cr_, 1.0, 1.0, 1.0); 
612      cairo_paint(cr_);
613      cairo_set_source_rgb(cr_, pen_color_[0], pen_color_[1], pen_color_[2]);
614      pango_cairo_update_layout(cr_, layout_);
615      {
616        DISABLE_HEAP_LEAK_CHECK; 
617        pango_cairo_show_layout(cr_, layout_);
618      }
619      *pix = CairoARGB32ToPixFormat(surface_);
620    }
621    ComputeClusterBoxes();
622    FreePangoCairo();
623    ++page_;
624    return page_offset;
625  }
626  int StringRenderer::RenderAllFontsToImage(double min_coverage, const char *text, int text_length,
627                                            std::string *font_used, Image *image) {
628    *image = nullptr;
629    const char kTitleTemplate[] = "%s : %d hits = %.2f%%, raw = %d = %.2f%%";
630    std::string title_font;
631    if (!FontUtils::SelectFont(kTitleTemplate, strlen(kTitleTemplate), &title_font, nullptr)) {
632      tprintf("WARNING: Could not find a font to render image title with!\n");
633      title_font = "Arial";
634    }
635    title_font += " 8";
636    tlog(1, "Selected title font: %s\n", title_font.c_str());
637    if (font_used) {
638      font_used->clear();
639    }
640    std::string orig_font = font_.DescriptionName();
641    if (char_map_.empty()) {
642      total_chars_ = 0;
643      for (UNICHAR::const_iterator it = UNICHAR::begin(text, text_length);
644           it != UNICHAR::end(text, text_length); ++it) {
645        ++total_chars_;
646        ++char_map_[*it];
647      }
648      tprintf("Total chars = %d\n", total_chars_);
649    }
650    const std::vector<std::string> &all_fonts = FontUtils::ListAvailableFonts();
651    for (size_t i = font_index_; i < all_fonts.size(); ++i) {
652      ++font_index_;
653      int raw_score = 0;
654      int ok_chars = FontUtils::FontScore(char_map_, all_fonts[i], &raw_score, nullptr);
655      if (ok_chars > 0 && ok_chars >= total_chars_ * min_coverage) {
656        set_font(all_fonts[i]);
657        int offset = RenderToBinaryImage(text, text_length, 128, image);
658        ClearBoxes(); 
659        const int kMaxTitleLength = 1024;
660        char title[kMaxTitleLength];
661        snprintf(title, kMaxTitleLength, kTitleTemplate, all_fonts[i].c_str(), ok_chars,
662                 100.0 * ok_chars / total_chars_, raw_score, 100.0 * raw_score / char_map_.size());
663        tprintf("%s\n", title);
664        if (offset) {
665          last_offset_ = offset;
666          if (font_used) {
667            *font_used = all_fonts[i];
668          }
669        }
670        set_font(title_font);
671        v_margin_ /= 8;
672        Image title_image = nullptr;
673        RenderToBinaryImage(title, strlen(title), 128, &title_image);
674        *image |= title_image;
675        title_image.destroy();
676        v_margin_ *= 8;
677        set_font(orig_font);
678        return 0;
679      } else {
680        tprintf("Font %s failed with %d hits = %.2f%%\n", all_fonts[i].c_str(), ok_chars,
681                100.0 * ok_chars / total_chars_);
682      }
683    }
684    font_index_ = 0;
685    char_map_.clear();
686    return last_offset_ == 0 ? -1 : last_offset_;
687  }
688  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-confirmation_height_bounded.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stringrenderer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>410  			auto it = accounts_confirmed_info.find (pending.account);
411  			if (it != accounts_confirmed_info.cend () && it->second.confirmed_height == pending.top_height)
412  			{
413  				accounts_confirmed_info.erase (pending.account);
414  				--accounts_confirmed_info_size;
415  			}
416  			pending_writes.pop_front ();
</pre></code></div>
                <div class="column column_space"><pre><code>296        std::string text =
297            std::string(full_text + start_byte_index, end_byte_index - start_byte_index);
298        if (IsUTF8Whitespace(text.c_str())) {
299          tlog(2, "Found whitespace\n");
300          text = " ";
301        }
302        tlog(2, "start_byte=%d end_byte=%d : '%s'\n", start_byte_index, end_byte_index, text.c_str());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    