
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.2948929159802307%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrblock.h</h3>
            <pre><code>1  #ifndef OCRBLOCK_H
2  #define OCRBLOCK_H
3  #include "ocrpara.h"
4  #include "ocrrow.h"
5  #include "pdblock.h"
6  namespace tesseract {
7  class BLOCK; 
8  ELISTIZEH(BLOCK)
9  class TESS_API BLOCK : public ELIST_LINK
10  {
11    friend class BLOCK_RECT_IT; 
12  public:
13    BLOCK() : re_rotation_(1.0f, 0.0f), classify_rotation_(1.0f, 0.0f), skew_(1.0f, 0.0f) {}
14    BLOCK(const char *name, 
15          bool prop,        
16          int16_t kern,     
17          int16_t space,    
18          TDimension xmin,  
19          TDimension ymin,
20          TDimension xmax,  
21          TDimension ymax);
22    ~BLOCK() = default;
23    void set_stats(bool prop, int16_t kern, int16_t space, int16_t ch_pitch) {
24      proportional = prop;
25      kerning = static_cast<int8_t>(kern);
26      spacing = space;
27      pitch = ch_pitch;
28    }
29    void set_xheight(int32_t height) {
30      xheight = height;
31    }
32    void set_font_class(int16_t font) {
33      font_class = font;
34    }
35    bool prop() const {
36      return proportional;
37    }
38    bool right_to_left() const {
39      return right_to_left_;
40    }
41    void set_right_to_left(bool value) {
42      right_to_left_ = value;
43    }
44    int32_t fixed_pitch() const {
45      return pitch;
46    }
47    int16_t kern() const {
48      return kerning;
49    }
50    int16_t font() const {
51      return font_class;
52    }
53    int16_t space() const {
54      return spacing;
55    }
56    const char *name() const {
57      return filename.c_str();
58    }
59    int32_t x_height() const {
60      return xheight;
61    }
62    float cell_over_xheight() const {
63      return cell_over_xheight_;
64    }
65    void set_cell_over_xheight(float ratio) {
66      cell_over_xheight_ = ratio;
67    }
68    ROW_LIST *row_list() {
69      return &rows;
70    }
71    void compute_row_margins();
72    PARA_LIST *para_list() {
73      return &paras_;
74    }
75    C_BLOB_LIST *blob_list() {
76      return &c_blobs;
77    }
78    C_BLOB_LIST *reject_blobs() {
79      return &rej_blobs;
80    }
81    FCOORD re_rotation() const {
82      return re_rotation_; 
83    }
84    void set_re_rotation(const FCOORD &rotation) {
85      re_rotation_ = rotation;
86    }
87    FCOORD classify_rotation() const {
88      return classify_rotation_; 
89    }
90    void set_classify_rotation(const FCOORD &rotation) {
91      classify_rotation_ = rotation;
92    }
93    FCOORD skew() const {
94      return skew_; 
95    }
96    void set_skew(const FCOORD &skew) {
97      skew_ = skew;
98    }
99    const ICOORD &median_size() const {
100      return median_size_;
101    }
102    void set_median_size(int x, int y) {
103      median_size_.set_x(x);
104      median_size_.set_y(y);
105    }
106    Image render_mask(TBOX *mask_box) {
107      return pdblk.render_mask(re_rotation_, mask_box);
108    }
<span onclick='openModal()' class='match'>109    TBOX restricted_bounding_box(bool upper_dots, bool lower_dots) const;
110    void reflect_polygon_in_y_axis();
111    void rotate(const FCOORD &rotation);
112    void sort_rows();
113    void compress();
114    void check_pitch();
115    void compress(const ICOORD vec);
116    void print(FILE *fp, bool dump);
117    BLOCK &operator=(const BLOCK &source);
118    PDBLK pdblk; 
119  private:
120    bool proportional = false;       
</span>121    bool right_to_left_ = false;     
122    int8_t kerning = 0;              
123    int16_t spacing = 0;             
124    int16_t pitch = 0;               
125    int16_t font_class = 0;          
126    int32_t xheight = 0;             
127    float cell_over_xheight_ = 0.0f; 
128    std::string filename;            
129    ROW_LIST rows;                   
130    PARA_LIST paras_;                
131    C_BLOB_LIST c_blobs;             
132    C_BLOB_LIST rej_blobs;           
133    FCOORD re_rotation_;             
134    FCOORD classify_rotation_;       
135    FCOORD skew_;                    
136    ICOORD median_size_;             
137  };
138  void PrintSegmentationStats(BLOCK_LIST *block_list);
139  void ExtractBlobsFromSegmentation(BLOCK_LIST *blocks, C_BLOB_LIST *output_blob_list);
140  void RefreshWordBlobsFromNewBlobs(BLOCK_LIST *block_list, C_BLOB_LIST *new_blobs,
141                                    C_BLOB_LIST *not_found_blobs);
142  } 
143  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intfx.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include "intfx.h"
3  #include "classify.h"
4  #include "intmatcher.h"
5  #include "linlsq.h"
6  #include "normalis.h"
7  #include "statistc.h"
8  #include "trainingsample.h"
9  #include "helpers.h"
10  #include <allheaders.h>
11  #include <cmath> 
12  #include <mutex> 
13  namespace tesseract {
14  static float cos_table[INT_CHAR_NORM_RANGE];
15  static float sin_table[INT_CHAR_NORM_RANGE];
16  void InitIntegerFX() {
17    static std::mutex atan_table_mutex;
18    static bool atan_table_init = false;
19    std::lock_guard<std::mutex> guard(atan_table_mutex);
20    if (!atan_table_init) {
21      for (int i = 0; i < INT_CHAR_NORM_RANGE; ++i) {
22        cos_table[i] = cos(i * 2 * M_PI / INT_CHAR_NORM_RANGE + M_PI);
23        sin_table[i] = sin(i * 2 * M_PI / INT_CHAR_NORM_RANGE + M_PI);
24      }
25      atan_table_init = true;
26    }
27  }
28  FCOORD FeatureDirection(uint8_t theta) {
29    return FCOORD(cos_table[theta], sin_table[theta]);
30  }
31  TrainingSample *BlobToTrainingSample(const TBLOB &blob, bool nonlinear_norm,
32                                       INT_FX_RESULT_STRUCT *fx_info,
33                                       std::vector<INT_FEATURE_STRUCT> *bl_features) {
34    std::vector<INT_FEATURE_STRUCT> cn_features;
35    Classify::ExtractFeatures(blob, nonlinear_norm, bl_features, &cn_features, fx_info, nullptr);
36    TBOX box = blob.bounding_box();
37    TrainingSample *sample = nullptr;
38    int num_features = fx_info->NumCN;
39    if (num_features > 0) {
40      sample = TrainingSample::CopyFromFeatures(*fx_info, box, &cn_features[0], num_features);
41    }
42    if (sample != nullptr) {
43      TPOINT topleft, botright;
44      topleft.x = box.left();
45      topleft.y = box.top();
46      botright.x = box.right();
47      botright.y = box.bottom();
48      TPOINT original_topleft, original_botright;
49      blob.denorm().DenormTransform(nullptr, topleft, &original_topleft);
50      blob.denorm().DenormTransform(nullptr, botright, &original_botright);
51      sample->set_bounding_box(
52          TBOX(original_topleft.x, original_botright.y, original_botright.x, original_topleft.y));
53    }
54    return sample;
55  }
56  void Classify::SetupBLCNDenorms(const TBLOB &blob, bool nonlinear_norm, DENORM *bl_denorm,
57                                  DENORM *cn_denorm, INT_FX_RESULT_STRUCT *fx_info) {
58    FCOORD center, second_moments;
59    int length = blob.ComputeMoments(&center, &second_moments);
60    if (fx_info != nullptr) {
61      fx_info->Length = length;
62      fx_info->Rx = IntCastRounded(second_moments.y());
63      fx_info->Ry = IntCastRounded(second_moments.x());
64      fx_info->Xmean = IntCastRounded(center.x());
65      fx_info->Ymean = IntCastRounded(center.y());
66    }
67    bl_denorm->SetupNormalization(nullptr, nullptr, &blob.denorm(), center.x(), 128.0f, 1.0f, 1.0f,
68                                  128.0f, 128.0f);
69    if (nonlinear_norm) {
70      std::vector<std::vector<int>> x_coords;
71      std::vector<std::vector<int>> y_coords;
72      TBOX box;
73      blob.GetPreciseBoundingBox(&box);
74      box.pad(1, 1);
75      blob.GetEdgeCoords(box, x_coords, y_coords);
76      cn_denorm->SetupNonLinear(&blob.denorm(), box, UINT8_MAX, UINT8_MAX, 0.0f, 0.0f, x_coords,
77                                y_coords);
78    } else {
79      cn_denorm->SetupNormalization(nullptr, nullptr, &blob.denorm(), center.x(), center.y(),
80                                    51.2f / second_moments.x(), 51.2f / second_moments.y(), 128.0f,
81                                    128.0f);
82    }
83  }
84  static uint8_t NormalizeDirection(uint8_t dir, const FCOORD &unnormed_pos, const DENORM &denorm,
85                                    const DENORM *root_denorm) {
86    FCOORD unnormed_end;
87    unnormed_end.from_direction(dir);
88    unnormed_end += unnormed_pos;
89    FCOORD normed_pos, normed_end;
90    denorm.NormTransform(root_denorm, unnormed_pos, &normed_pos);
91    denorm.NormTransform(root_denorm, unnormed_end, &normed_end);
92    normed_end -= normed_pos;
93    return normed_end.to_direction();
94  }
95  static FCOORD MeanDirectionVector(const LLSQ &point_diffs, const LLSQ &dirs, const FCOORD &start_pt,
96                                    const FCOORD &end_pt) {
97    FCOORD fit_vector;
98    if (dirs.count() > 0) {
99      FCOORD mean_pt = dirs.mean_point();
100      double mean_dir = 0.0;
101      if (dirs.x_variance() <= dirs.y_variance()) {
102        mean_dir = mean_pt.x();
103      } else {
104        mean_dir = mean_pt.y() + 128;
105      }
106      fit_vector.from_direction(Modulo(IntCastRounded(mean_dir), 256));
107    } else {
108      FCOORD feature_dir(end_pt - start_pt);
109      fit_vector = point_diffs.vector_fit();
110      if (fit_vector.x() == 0.0f && fit_vector.y() == 0.0f) {
111        fit_vector = feature_dir;
112      } else {
113        FCOORD fit_vector2 = !fit_vector;
114        if (fit_vector % feature_dir < 0.0) {
115          fit_vector = -fit_vector;
116        }
117        if (fit_vector2 % feature_dir < 0.0) {
118          fit_vector2 = -fit_vector2;
119        }
120        if (fit_vector2 % feature_dir > fit_vector % feature_dir) {
121          fit_vector = fit_vector2;
122        }
123      }
124    }
125    return fit_vector;
126  }
127  static int ComputeFeatures(const FCOORD &start_pt, const FCOORD &end_pt, double feature_length,
128                             std::vector<INT_FEATURE_STRUCT> *features) {
129    FCOORD feature_vector(end_pt - start_pt);
130    if (feature_vector.x() == 0.0f && feature_vector.y() == 0.0f) {
131      return 0;
132    }
133    uint8_t theta = feature_vector.to_direction();
134    double target_length = feature_vector.length();
135    int num_features = IntCastRounded(target_length / feature_length);
136    if (num_features == 0) {
137      return 0;
138    }
139    double lambda_step = 1.0 / num_features;
140    double lambda = lambda_step / 2.0;
141    for (int f = 0; f < num_features; ++f, lambda += lambda_step) {
142      FCOORD feature_pt(start_pt);
143      feature_pt += feature_vector * lambda;
144      INT_FEATURE_STRUCT feature(feature_pt, theta);
145      features->push_back(feature);
146    }
147    return num_features;
148  }
<span onclick='openModal()' class='match'>149  static int GatherPoints(const C_OUTLINE *outline, double feature_length, const DENORM &denorm,
150                          const DENORM *root_denorm, int start_index, int end_index, ICOORD *pos,
151                          FCOORD *pos_normed, LLSQ *points, LLSQ *dirs) {
152    int step_length = outline->pathlength();
</span>153    ICOORD step = outline->step(start_index % step_length);
154    FCOORD prev_normed;
155    points->clear();
156    dirs->clear();
157    int num_points = 0;
158    int index;
159    for (index = start_index; index <= end_index; ++index, *pos += step) {
160      step = outline->step(index % step_length);
161      int edge_weight = outline->edge_strength_at_index(index % step_length);
162      if (edge_weight == 0) {
163        continue;
164      }
165      FCOORD f_pos = outline->sub_pixel_pos_at_index(*pos, index % step_length);
166      denorm.NormTransform(root_denorm, f_pos, pos_normed);
167      if (num_points == 0) {
168        prev_normed = *pos_normed;
169      } else {
170        FCOORD offset = *pos_normed - prev_normed;
171        float length = offset.length();
172        if (length > feature_length) {
173          return index;
174        }
175      }
176      points->add(pos_normed->x(), pos_normed->y(), edge_weight);
177      int direction = outline->direction_at_index(index % step_length);
178      if (direction >= 0) {
179        direction = NormalizeDirection(direction, f_pos, denorm, root_denorm);
180        dirs->add(direction, Modulo(direction + 128, 256));
181      }
182      ++num_points;
183    }
184    return index;
185  }
186  static void ExtractFeaturesFromRun(const EDGEPT *startpt, const EDGEPT *lastpt,
187                                     const DENORM &denorm, double feature_length, bool force_poly,
188                                     std::vector<INT_FEATURE_STRUCT> *features) {
189    const EDGEPT *endpt = lastpt->next;
190    const C_OUTLINE *outline = startpt->src_outline;
191    if (outline != nullptr && !force_poly) {
192      const DENORM *root_denorm = denorm.RootDenorm();
193      int total_features = 0;
194      int step_length = outline->pathlength();
195      int start_index = startpt->start_step;
196      ICOORD pos = outline->position_at_index(start_index);
197      int end_index = lastpt->start_step + lastpt->step_count;
198      if (end_index <= start_index) {
199        end_index += step_length;
200      }
201      LLSQ prev_points;
202      LLSQ prev_dirs;
203      FCOORD prev_normed_pos = outline->sub_pixel_pos_at_index(pos, start_index);
204      denorm.NormTransform(root_denorm, prev_normed_pos, &prev_normed_pos);
205      LLSQ points;
206      LLSQ dirs;
207      FCOORD normed_pos(0.0f, 0.0f);
208      int index = GatherPoints(outline, feature_length, denorm, root_denorm, start_index, end_index,
209                               &pos, &normed_pos, &points, &dirs);
210      while (index <= end_index) {
211        LLSQ next_points;
212        LLSQ next_dirs;
213        FCOORD next_normed_pos(0.0f, 0.0f);
214        index = GatherPoints(outline, feature_length, denorm, root_denorm, index, end_index, &pos,
215                             &next_normed_pos, &next_points, &next_dirs);
216        LLSQ sum_points(prev_points);
217        LLSQ sum_dirs(dirs);
218        sum_points.add(points);
219        sum_points.add(next_points);
220        sum_dirs.add(next_dirs);
221        bool made_features = false;
222        if (sum_points.count() > 0) {
223          FCOORD fit_pt = sum_points.mean_point();
224          FCOORD fit_vector = MeanDirectionVector(sum_points, sum_dirs, prev_normed_pos, normed_pos);
225          FCOORD start_pos = prev_normed_pos.nearest_pt_on_line(fit_pt, fit_vector);
226          FCOORD end_pos = normed_pos.nearest_pt_on_line(fit_pt, fit_vector);
227          if (total_features == 0 && startpt != endpt) {
228            FCOORD poly_pos(startpt->pos.x, startpt->pos.y);
229            denorm.LocalNormTransform(poly_pos, &start_pos);
230          }
231          if (index > end_index && startpt != endpt) {
232            FCOORD poly_pos(endpt->pos.x, endpt->pos.y);
233            denorm.LocalNormTransform(poly_pos, &end_pos);
234          }
235          int num_features = ComputeFeatures(start_pos, end_pos, feature_length, features);
236          if (num_features > 0) {
237            prev_points = points;
238            prev_dirs = dirs;
239            prev_normed_pos = normed_pos;
240            points = next_points;
241            dirs = next_dirs;
242            made_features = true;
243            total_features += num_features;
244          }
245          normed_pos = next_normed_pos;
246        }
247        if (!made_features) {
248          points.add(next_points);
249          dirs.add(next_dirs);
250        }
251      }
252    } else {
253      const EDGEPT *pt = startpt;
254      do {
255        FCOORD start_pos(pt->pos.x, pt->pos.y);
256        FCOORD end_pos(pt->next->pos.x, pt->next->pos.y);
257        denorm.LocalNormTransform(start_pos, &start_pos);
258        denorm.LocalNormTransform(end_pos, &end_pos);
259        ComputeFeatures(start_pos, end_pos, feature_length, features);
260      } while ((pt = pt->next) != endpt);
261    }
262  }
263  void Classify::ExtractFeatures(const TBLOB &blob, bool nonlinear_norm,
264                                 std::vector<INT_FEATURE_STRUCT> *bl_features,
265                                 std::vector<INT_FEATURE_STRUCT> *cn_features,
266                                 INT_FX_RESULT_STRUCT *results,
267                                 std::vector<int> *outline_cn_counts) {
268    DENORM bl_denorm, cn_denorm;
269    tesseract::Classify::SetupBLCNDenorms(blob, nonlinear_norm, &bl_denorm, &cn_denorm, results);
270    if (outline_cn_counts != nullptr) {
271      outline_cn_counts->clear();
272    }
273    for (TESSLINE *ol = blob.outlines; ol != nullptr; ol = ol->next) {
274      EDGEPT *loop_pt = ol->FindBestStartPt();
275      EDGEPT *pt = loop_pt;
276      if (pt == nullptr) {
277        continue;
278      }
279      do {
280        if (pt->IsHidden()) {
281          continue;
282        }
283        EDGEPT *last_pt = pt;
284        do {
285          last_pt = last_pt->next;
286        } while (last_pt != loop_pt && !last_pt->IsHidden() &&
287                 last_pt->src_outline == pt->src_outline);
288        last_pt = last_pt->prev;
289        ExtractFeaturesFromRun(pt, last_pt, bl_denorm, kStandardFeatureLength, true, bl_features);
290        ExtractFeaturesFromRun(pt, last_pt, cn_denorm, kStandardFeatureLength, false, cn_features);
291        pt = last_pt;
292      } while ((pt = pt->next) != loop_pt);
293      if (outline_cn_counts != nullptr) {
294        outline_cn_counts->push_back(cn_features->size());
295      }
296    }
297    results->NumBL = bl_features->size();
298    results->NumCN = cn_features->size();
299    results->YBottom = blob.bounding_box().bottom();
300    results->YTop = blob.bounding_box().top();
301    results->Width = blob.bounding_box().width();
302  }
303  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrblock.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intfx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>109    TBOX restricted_bounding_box(bool upper_dots, bool lower_dots) const;
110    void reflect_polygon_in_y_axis();
111    void rotate(const FCOORD &rotation);
112    void sort_rows();
113    void compress();
114    void check_pitch();
115    void compress(const ICOORD vec);
116    void print(FILE *fp, bool dump);
117    BLOCK &operator=(const BLOCK &source);
118    PDBLK pdblk; 
119  private:
120    bool proportional = false;       
</pre></code></div>
                <div class="column column_space"><pre><code>149  static int GatherPoints(const C_OUTLINE *outline, double feature_length, const DENORM &denorm,
150                          const DENORM *root_denorm, int start_index, int end_index, ICOORD *pos,
151                          FCOORD *pos_normed, LLSQ *points, LLSQ *dirs) {
152    int step_length = outline->pathlength();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    