
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.298507462686567%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wordnet.cpp</h3>
            <pre><code>1  #include "wordnet.h"
2  void TWnSynSet::GetDstSynSetPV(
3   const TWnRelType& RelType, TIntV& DstSynSetPV) const {
4    DstSynSetPV.Clr();
5    for (int RelN=0; RelN<RelIntIntTrV.Len(); RelN++){
6      TWnRelType CurRelType=TWnRelType(RelIntIntTrV[RelN].Val1.Val);
7      if (RelType==CurRelType){
8        int DstSynSetP=RelIntIntTrV[RelN].Val3;
9        DstSynSetPV.Add(DstSynSetP);
10      }
11    }
12  }
13  TWnSynSetType TWnBs::GetSynSetTypeFromStr(const TStr& SynSetTypeStr){
14    if (SynSetTypeStr=="n"){return wsstNoun;}
15    if (SynSetTypeStr=="v"){return wsstVerb;}
16    if (SynSetTypeStr=="a"){return wsstAdjective;}
17    if (SynSetTypeStr=="s"){return wsstAdjectiveSatellite;}
18    if (SynSetTypeStr=="r"){return wsstAdverb;}
19    Fail; return wsstUndef;
20  }
21  void TWnBs::AddRel(const TWnRelType& RelType, const TStr& SrcSynSetId, const TStr& DstSynSetId){
22    IAssert(IsSynSetId(SrcSynSetId)); IAssert(IsSynSetId(DstSynSetId));
23    int SrcSynSetP=GetSynSetP(SrcSynSetId);
24    int DstSynSetP=GetSynSetP(DstSynSetId);
25    PWnSynSet SrcSynSet=GetSynSet(SrcSynSetId);
26    PWnSynSet DstSynSet=GetSynSet(DstSynSetId);
27    SrcSynSet->AddRel(RelType, SrcSynSetP, DstSynSetP);
28    DstSynSet->AddInvRel(RelType, SrcSynSetP, DstSynSetP);
29  }
30  TStr TWnBs::GetRelTypeNm(const TWnRelType& RelType){
31    switch (RelType){
32      case wrtUndef: return "Undef";
33      case wrtSenseKey: return "SenseKey";
34      case wrtGloss: return "Gloss";
35      case wrtSyntax: return "Syntax";
36      case wrtHypernym: return "Hypernym";
37      case wrtInstance: return "Instance";
38      case wrtEntailment: return "Entailment";
39      case wrtSimilar: return "Similar";
40      case wrtMemberMeronym: return "MemberMeronym";
41      case wrtSubstanceMeronym: return "SubstanceMeronym";
42      case wrtPartMeronym: return "PartMeronym";
43      case wrtDerivation: return "Derivation";
44      case wrtClass: return "Class";
45      case wrtCause: return "Cause";
46      case wrtVerbGroup: return "VerbGroup";
47      case wrtAttribute: return "Attribute";
48      case wrtAntonym: return "Antonym";
49      case wrtAdditionalInfo: return "AdditionalInfo";
50      case wrtParticiple: return "Participle";
51      case wrtPosRel: return "PosRel";
52      case wrtFrame: return "Frame";
53      default: Fail; return "";
54    }
55  }
56  void TWnBs::LoadFromPlBs(const PPlBs& PlBs){
57    printf("Loading from Prolog-Base ...\n");
58    int S6_RelId=PlBs->GetRelId("s", 6);
59    int S4_RelId=PlBs->GetRelId("s", 4);
60    printf("  ... collect counts ...\n");
61    TStrIntSH SynSetIdToMxWordNSH;
62    TStrIntSH WordStrToMxSynSetNSH;
63    for (int RelId=0; RelId<PlBs->GetRels(); RelId++){
64      if ((RelId!=S6_RelId)&&(RelId!=S4_RelId)){continue;}
65      for (int TupN=0; TupN<PlBs->GetRelTups(RelId); TupN++){
66        int TupId=PlBs->GetRelTupId(RelId, TupN);
67        PPlTup Tup=PlBs->GetTup(TupId);
68        TStr SynSetId=TInt::GetStr(Tup->GetVal(0).GetInt());
69        int SynSetWordN=Tup->GetVal(1).GetInt();
70        TStr WordStr=PlBs->GetAtomStr(Tup->GetVal(2).GetAtomId());
71        TStr SynSetTypeStr=PlBs->GetAtomStr(Tup->GetVal(3).GetAtomId());
72        int WordSynSetN=(Tup->GetVals()>4) ? Tup->GetVal(4).GetInt() : 1;
73        TStr EWordStr=GetEWordStr(WordStr, SynSetTypeStr);
74        TInt& MxSynSetWordN=SynSetIdToMxWordNSH.AddDat(SynSetId);
75        if (SynSetWordN>MxSynSetWordN){MxSynSetWordN=SynSetWordN;}
76        TInt& MxWordSynSetN=WordStrToMxSynSetNSH.AddDat(EWordStr);
77        if (WordSynSetN>MxWordSynSetN){MxWordSynSetN=WordSynSetN;}
78      }
79    }
80    printf("  ... create synsets ...\n");
81    for (int RelId=0; RelId<PlBs->GetRels(); RelId++){
82      if ((RelId!=S6_RelId)&&(RelId!=S4_RelId)){continue;}
83      for (int TupN=0; TupN<PlBs->GetRelTups(RelId); TupN++){
84        int TupId=PlBs->GetRelTupId(RelId, TupN);
85        PPlTup Tup=PlBs->GetTup(TupId);
86        TStr SynSetId=TInt::GetStr(Tup->GetVal(0).GetInt());
87        int SynSetWordN=Tup->GetVal(1).GetInt();
88        TStr WordStr=PlBs->GetAtomStr(Tup->GetVal(2).GetAtomId());
89        TStr SynSetTypeStr=PlBs->GetAtomStr(Tup->GetVal(3).GetAtomId());
90        TWnSynSetType SynSetType=GetSynSetTypeFromStr(SynSetTypeStr);
91        int WordSynSetN=(Tup->GetVals()>4) ? Tup->GetVal(4).GetInt() : 1;
92        TStr EWordStr=GetEWordStr(WordStr, SynSetTypeStr);
93        int SynSetP=-1;
94        if (IdToWnSynSetSH.IsKey(SynSetId)){
95          SynSetP=IdToWnSynSetSH.GetKeyId(SynSetId);
96        } else {
97          SynSetP=IdToWnSynSetSH.AddKey(SynSetId);
98          IdToWnSynSetSH[SynSetP]=TWnSynSet::New();
99          IdToWnSynSetSH[SynSetP]->SynSetType=SynSetType;
100          int MxSynSetWordN=SynSetIdToMxWordNSH.GetDat(SynSetId);
101          IdToWnSynSetSH[SynSetP]->WordStrPV.Gen(MxSynSetWordN);
102          IdToWnSynSetSH[SynSetP]->WordStrPV.PutAll(-1);
103        }
104        int WordStrP=-1;
105        if (EWordStrToSynSetPVSH.IsKey(EWordStr)){
106          WordStrP=EWordStrToSynSetPVSH.GetKeyId(EWordStr);
107        } else {
108          WordStrP=EWordStrToSynSetPVSH.AddKey(EWordStr);
109          int MxWordSynSetN=WordStrToMxSynSetNSH.GetDat(EWordStr);
110          EWordStrToSynSetPVSH[WordStrP].Gen(MxWordSynSetN);
111          EWordStrToSynSetPVSH[WordStrP].PutAll(-1);
112        }
113        if (IdToWnSynSetSH[SynSetP]->WordStrPV[SynSetWordN-1]==-1){
114          IdToWnSynSetSH[SynSetP]->WordStrPV[SynSetWordN-1]=WordStrP;
115        } else {
116          int TestWordP=IdToWnSynSetSH[SynSetP]->WordStrPV[SynSetWordN-1];
117          TStr TestEWordStr=EWordStrToSynSetPVSH.GetKey(TestWordP);
118          IAssert(EWordStr==TestEWordStr);
119        }
120        if (EWordStrToSynSetPVSH[WordStrP][WordSynSetN-1]==-1){
121          EWordStrToSynSetPVSH[WordStrP][WordSynSetN-1]=SynSetP;
122        } else {
123          int TestSynSetP=EWordStrToSynSetPVSH[WordStrP][WordSynSetN-1];
124          TStr TestSynSetId=IdToWnSynSetSH.GetKey(TestSynSetP);
125          IAssert(SynSetId==TestSynSetId);
126        }
127      }
128    }
129    printf("  ... create relations ...\n");
<span onclick='openModal()' class='match'>130    int Sk_RelId=PlBs->GetRelId("sk", 3);
131    int G_RelId=PlBs->GetRelId("g", 2);
132    int Syntax_RelId=PlBs->GetRelId("syntax", 3);
133    int Hyp_RelId=PlBs->GetRelId("hyp", 2);
</span>134    int Ins_RelId=PlBs->GetRelId("ins", 2);
135    int Ent_RelId=PlBs->GetRelId("ent", 2);
136    int Sim_RelId=PlBs->GetRelId("sim", 2);
137    int Mm_RelId=PlBs->GetRelId("mm", 2);
138    int Ms_RelId=PlBs->GetRelId("ms", 2);
139    int Mp_RelId=PlBs->GetRelId("mp", 2);
140    int Der_RelId=PlBs->GetRelId("der", 4);
141    int Cls_RelId=PlBs->GetRelId("cls", 5);
142    int Cs_RelId=PlBs->GetRelId("cs", 2);
143    int Vgp_RelId=PlBs->GetRelId("vgp", 4);
144    int At_RelId=PlBs->GetRelId("at", 2);
145    int Ant_RelId=PlBs->GetRelId("ant", 4);
146    int Sa_RelId=PlBs->GetRelId("sa", 4);
147    int Ppl_RelId=PlBs->GetRelId("ppl", 4);
148    int Per_RelId=PlBs->GetRelId("per", 4);
149    int Fr_RelId=PlBs->GetRelId("fr", 3);
150    for (int RelId=0; RelId<PlBs->GetRels(); RelId++){
151      TWnRelType RelType=wrtUndef; int SrcSynSetIdArgN=-1; int DstSynSetIdArgN=-1;
152      if (RelId==S6_RelId){RelType=wrtUndef;}
153      else if (RelId==S4_RelId){RelType=wrtUndef;}
154      else if (RelId==Sk_RelId){RelType=wrtUndef;}
155      else if (RelId==G_RelId){RelType=wrtUndef;}
156      else if (RelId==Syntax_RelId){RelType=wrtUndef;}
157      else if (RelId==Hyp_RelId){RelType=wrtHypernym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
158      else if (RelId==Ins_RelId){RelType=wrtInstance; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
159      else if (RelId==Ent_RelId){RelType=wrtEntailment; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
160      else if (RelId==Sim_RelId){RelType=wrtSimilar; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
161      else if (RelId==Mm_RelId){RelType=wrtMemberMeronym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
162      else if (RelId==Ms_RelId){RelType=wrtSubstanceMeronym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
163      else if (RelId==Mp_RelId){RelType=wrtPartMeronym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
164      else if (RelId==Der_RelId){RelType=wrtDerivation; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
165      else if (RelId==Cls_RelId){RelType=wrtClass; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
166      else if (RelId==Cs_RelId){RelType=wrtCause; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
167      else if (RelId==Vgp_RelId){RelType=wrtVerbGroup; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
168      else if (RelId==At_RelId){RelType=wrtAttribute; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
169      else if (RelId==Ant_RelId){RelType=wrtAntonym; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
170      else if (RelId==Sa_RelId){RelType=wrtAdditionalInfo; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
171      else if (RelId==Ppl_RelId){RelType=wrtParticiple; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
172      else if (RelId==Per_RelId){RelType=wrtPosRel; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
173      else if (RelId==Fr_RelId){RelType=wrtUndef;}
174      else {TStr FuncArityStr=PlBs->GetFuncArityStr(RelId); Fail;}
175      if (RelType!=wrtUndef){
176        for (int TupN=0; TupN<PlBs->GetRelTups(RelId); TupN++){
177          int TupId=PlBs->GetRelTupId(RelId, TupN);
178          PPlTup Tup=PlBs->GetTup(TupId);
179          TStr SrcSynSetId=TInt::GetStr(Tup->GetVal(SrcSynSetIdArgN).GetInt());
180          TStr DstSynSetId=TInt::GetStr(Tup->GetVal(DstSynSetIdArgN).GetInt());
181          if (IsSynSetId(SrcSynSetId)&&IsSynSetId(DstSynSetId)){
182            AddRel(RelType, SrcSynSetId, DstSynSetId);
183          }
184        }
185      }
186    }
187    printf("Done.\n");
188  }
189  void TWnBs::SaveTxtSynSet(const int& SynSetP, FILE* fOut, const int& LevelN){
190    TStr SynSetId=GetSynSetId(SynSetP);
191    PWnSynSet SynSet=GetSynSet(SynSetId);
192    fprintf(fOut, "%s%s:", TStr::GetSpaceStr(LevelN*2).CStr(), SynSetId.CStr());
193    for (int WordN=0; WordN<SynSet->GetWords(); WordN++){
194      int EWordStrP=SynSet->GetWordStrP(WordN);
195      TStr WordStr=GetEWordStrP(EWordStrP);
196      fprintf(fOut, " '%s'", WordStr.CStr());
197    }
198    fprintf(fOut, "\n");
199  }
200  void TWnBs::SaveTxtRel(const TWnRelType& RelType, const int& SynSetP,
201   const bool& Recurse, FILE* fOut, const int& LevelN, TIntS& SynSetPS){
202    PWnSynSet SynSet=GetSynSetFromP(SynSetP);
203    TIntV SubSynSetPV; SynSet->GetDstSynSetPV(RelType, SubSynSetPV);
204    if ((LevelN==0)&&(!SubSynSetPV.Empty())){
205      TStr RelTypeNm=GetRelTypeNm(RelType);
206      fprintf(fOut, "  ---%s--------------------------\n", RelTypeNm.CStr());
207    }
208    for (int SubSynSetPN=0; SubSynSetPN<SubSynSetPV.Len(); SubSynSetPN++){
209      int SubSynSetP=SubSynSetPV[SubSynSetPN];
210      SaveTxtSynSet(SubSynSetP, fOut, LevelN+1);
211      if (Recurse){
212        if (!SynSetPS.IsIn(SubSynSetP)){
213          SynSetPS.Push(SubSynSetP);
214          SaveTxtRel(RelType, SubSynSetP, Recurse, fOut, LevelN+1, SynSetPS);
215          SynSetPS.Pop();
216        } else {
217          fprintf(fOut, "  ***Cycling\n");
218        }
219      }
220    }
221  }
222  void TWnBs::SaveTxt(const TStr& FNm){
223    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
224    for (int SynSetP=0; SynSetP<GetSynSets(); SynSetP++){
225      fprintf(fOut, "=====================================\n");
226      SaveTxtSynSet(SynSetP, fOut);
227      SaveTxtRel(wrtHypernym, SynSetP, true, fOut);
228      SaveTxtRel(wrtInstance, SynSetP, false, fOut);
229      SaveTxtRel(wrtEntailment, SynSetP, false, fOut);
230      SaveTxtRel(wrtSimilar, SynSetP, false, fOut);
231      SaveTxtRel(wrtMemberMeronym, SynSetP, false, fOut);
232      SaveTxtRel(wrtSubstanceMeronym, SynSetP, false, fOut);
233      SaveTxtRel(wrtPartMeronym, SynSetP, false, fOut);
234      SaveTxtRel(wrtDerivation, SynSetP, false, fOut);
235      SaveTxtRel(wrtClass, SynSetP, false, fOut);
236      SaveTxtRel(wrtCause, SynSetP, false, fOut);
237      SaveTxtRel(wrtVerbGroup, SynSetP, false, fOut);
238      SaveTxtRel(wrtAttribute, SynSetP, false, fOut);
239      SaveTxtRel(wrtAntonym, SynSetP, false, fOut);
240      SaveTxtRel(wrtAdditionalInfo, SynSetP, false, fOut);
241      SaveTxtRel(wrtParticiple, SynSetP, false, fOut);
242      SaveTxtRel(wrtPosRel, SynSetP, false, fOut);
243      fprintf(fOut, "=====================================\n\n");
244    }
245  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-google.cpp</h3>
            <pre><code>1  #include "google.h"
2  TMd5Sig TGgSchRef::GetMd5Sig() const {
3    TChA ChA;
4    ChA+=TitleStr;
5    for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
6      ChA+=';'; ChA+=AuthNmV[AuthN];}
7    ChA+=';'; ChA+=PubNm;
8    ChA+=';'; ChA+=YearStr;
9    return TMd5Sig(ChA);
10  }
11  void TGgSchRef::GetAuthNmVPubStr(
12   const TStr& AuthNmVPubStr, TStrV& AuthNmV, TStr& PubNm, TStr& PubYearStr){
13    TStr AuthNmVStr; TStr PubStr;
14    AuthNmVPubStr.SplitOnStr(AuthNmVStr, " - ", PubStr);
15    AuthNmVStr.SplitOnAllCh(',', AuthNmV, true);
16    for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
17      AuthNmV[AuthN].ToTrunc();
18    }
19    if ((!AuthNmV.Empty())&&
20     ((AuthNmV.Last().IsStrIn("..."))||(AuthNmV.Last().Len()<=2))){
21      AuthNmV.DelLast();
22    }
23    TStr OriginStr; TStr LinkStr;
24    PubStr.SplitOnStr(OriginStr, " - ", LinkStr);
25    OriginStr.SplitOnLastCh(PubNm, ',', PubYearStr);
26    PubNm.ToTrunc(); PubYearStr.ToTrunc();
27    if ((PubYearStr.Len()>=4)&&(PubYearStr.GetSubStr(0, 3).IsInt())){
28      PubYearStr=PubYearStr.GetSubStr(0, 3);
29    } else
30    if ((PubNm.Len()>=4)&&(PubNm.GetSubStr(0, 3).IsInt())){
31      PubYearStr=PubNm.GetSubStr(0, 3); PubNm="";
32    } else {
33      PubYearStr="";
34    }
35  }
36  void TGgSchRef::SaveXml(FILE* fOut, const int& RefN){
37    if (RefN==-1){
38      fprintf(fOut, "    <Ref>\n");
39    } else {
40      fprintf(fOut, "    <Ref Num=\"%d\">\n", RefN);
41    }
42    fprintf(fOut, "    <MD5>%s</MD5>\n", GetMd5Sig().GetStr().CStr());
43    fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(TitleStr).CStr());
44    if (AuthNmV.Len()>0){
45      fprintf(fOut, "      <Authors>");
46      for (int AuthN=0; AuthN<AuthNmV.Len(); AuthN++){
47        fprintf(fOut, "<Author>%s</Author>", TXmlLx::GetXmlStrFromPlainStr(AuthNmV[AuthN]).CStr());
48      }
49      fprintf(fOut, "</Authors>\n");
50    }
51    if (!PubNm.Empty()){
52      fprintf(fOut, "      <Pub>%s</Pub>\n", TXmlLx::GetXmlStrFromPlainStr(PubNm).CStr());}
53    if (!YearStr.Empty()){
54      fprintf(fOut, "      <Year>%s</Year>\n", TXmlLx::GetXmlStrFromPlainStr(YearStr).CStr());}
55    fprintf(fOut, "      <Citations>%d</Citations>\n", Citations);
56    if (!CitedByUrlStr.Empty()){
57      fprintf(fOut, "      <CitedByUrl>%s</CitedByUrl>\n", TXmlLx::GetXmlStrFromPlainStr(CitedByUrlStr).CStr());}
58    fprintf(fOut, "    </Ref>\n");
59  }
60  PGgSchRSet TGgSchRSet::NewScholar(const TStr& UrlStr, const TStr& HtmlStr){
61    PGgSchRSet RSet=TGgSchRSet::New();
62    PSIn HtmlSIn=TStrIn::New(HtmlStr);
63    THtmlLx HtmlLx(HtmlSIn);
64    HtmlLx.MoveToStrOrEof("Results");
65    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
66    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
67    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
68    AllHitsStr.DelChAll(',');
69    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
70    HtmlLx.MoveToBTagOrEof("<P>");
71    forever {
72      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<P>"))){break;}
73      HtmlLx.GetSym();
74      if (HtmlLx.Sym==hsyBTag){
75        TStr FullBTagStr=HtmlLx.GetFullBTagStr();
76        if (FullBTagStr=="<FONT SIZE=\"-2\">"){
77          TStr PubTypeNm=HtmlLx.GetStrInTag("<B>", true);
78        } else
79        if (FullBTagStr=="<SPAN CLASS=\"w\">"){
80        } else {
81          break;
82        }
83        TStr TitleStr=HtmlLx.GetStrToBTag("<BR>", true).GetTrunc();
84        if (TitleStr.IsPrefix("[PS] ")){
85          TitleStr=TitleStr.GetSubStr(5, TitleStr.Len()).GetTrunc();}
86        TStr AuthNmVPubStr=HtmlLx.GetStrToBTag("<BR>", true);
87        TStrV AuthNmV; TStr PubNm; TStr PubYearStr;
88        TGgSchRef::GetAuthNmVPubStr(AuthNmVPubStr, AuthNmV, PubNm, PubYearStr);
89        TStr CitedByUrlStr; int Citations=0;
90        HtmlLx.MoveToBTag3OrEof("<A>", "<P>", "<DIV>");
91        if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.ChA=="<A>")){
92          TStr CitedByRelUrlStr=HtmlLx.GetArg("HREF");
93          TStr AStr=HtmlLx.GetStrToETag("<A>", true);
94          if (AStr.IsPrefix("Cited by ")){
95            PUrl CitedByUrl=TUrl::New(CitedByRelUrlStr, UrlStr);
96            if (CitedByUrl->IsOk()){
97              CitedByUrlStr=CitedByUrl->GetUrlStr();
98              Citations=AStr.GetSubStr(TStr("Cited by ").Len(), AStr.Len()).GetInt(0);
99            }
100          }
101          HtmlLx.MoveToBTag2OrEof("<P>", "<DIV>");
102        }
103        PGgSchRef Ref=
104         TGgSchRef::New(TitleStr, AuthNmV, PubNm, PubYearStr, Citations, CitedByUrlStr);
105        RSet->AddHit(Ref);
106      } else {
107        break;
108      }
109    }
110    TStr NextUrlStr;
111    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
112      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
113      if (!NextRelUrlStr.Empty()){
114        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
115        if (NextUrl->IsOk()){
116          NextUrlStr=NextUrl->GetUrlStr();
117        }
118      }
119    }
120    RSet->PutUrlStr(UrlStr);
121    RSet->PutNextUrlStr(NextUrlStr);
122    RSet->PutQueryStr(QueryStr);
123    RSet->PutAllHits(AllHitsStr.GetInt(-1));
124    return RSet;
125  }
126  PGgSchRSet TGgSchRSet::NewScholar(const PWebPg& WebPg){
127    TStr UrlStr=WebPg->GetUrlStr();
128    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
129    return TGgSchRSet::NewScholar(UrlStr, HtmlStr);
130  }
131  void TGgSchRSet::Merge(const PGgSchRSet& RSet){
132    if (RSet.Empty()){return;}
133    TStrH TitleStrH(GetHits());
134    for (int HitN=0; HitN<GetHits(); HitN++){
135      TitleStrH.AddKey(GetHit(HitN)->TitleStr);
136    }
137    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
138      PGgSchRef Ref=RSet->GetHit(HitN);
139      if (!TitleStrH.IsKey(Ref->TitleStr)){
140        AddHit(Ref);
141        TitleStrH.AddKey(Ref->TitleStr);
142      }
143    }
144    PutNextUrlStr("");
145    PutAllHits(-1);
146  }
147  PBowDocBs TGgSchRSet::GetBowDocBs() const {
148    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
149    PStemmer Stemmer=TStemmer::New(stmtPorter, true);
150    TStrV HtmlStrV(GetHits(), 0);
151    for (int HitN=0; HitN<GetHits(); HitN++){
152      TStr HtmlStr=GetHit(HitN)->TitleStr;
153      HtmlStrV.Add(HtmlStr);
154    }
155    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
156     HtmlStrV, 3, 3, SwSet, Stemmer);
157    printf("Create Bag-Of-Words Base ... ");
158    PBowDocBs BowDocBs=TBowDocBs::New();
159    BowDocBs->PutNGramBs(NGramBs);
160    for (int HitN=0; HitN<GetHits(); HitN++){
161      BowDocBs->AddHtmlDoc(TInt::GetStr(HitN), TStrV(), HtmlStrV[HitN], true);
162    }
163    BowDocBs->AssertOk();
164    printf("Done.\n");
165    return BowDocBs;
166  }
167  void TGgSchRSet::SaveBin(const TStr& FNm, const PGgSchRSet& GgSchRSet){
168    if (GgSchRSet.Empty()){
169      PGgSchRSet RSet=TGgSchRSet::New();
170      GgSchRSet->SaveBin(FNm);
171    } else {
172      GgSchRSet->SaveBin(FNm);
173    }
174  }
175  void TGgSchRSet::SaveXml(const TStr& FNm, const PGgSchRSet& GgSchRSet){
176    if (GgSchRSet.Empty()){
177      TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
178      fprintf(fOut, "<GgSchRSets>\n");
179      fprintf(fOut, "  <Error/>\n");
180      fprintf(fOut, "</GgSchRSets>");
181    } else {
182      GgSchRSet->SaveXml(FNm);
183    }
184  }
185  void TGgSchRSet::SaveXml(const TStr& FNm){
186    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
187    fprintf(fOut, "<RSet>\n");
188    if (!GetUrlStr().Empty()){
189      fprintf(fOut, "  <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(GetUrlStr()).CStr());}
190    if (!GetNextUrlStr().Empty()){
191      fprintf(fOut, "  <NextUrl>%s</NextUrl>\n", TXmlLx::GetXmlStrFromPlainStr(GetNextUrlStr()).CStr());}
192    if (!GetQueryStr().Empty()){
193      fprintf(fOut, "  <Query>%s</Query>\n", TXmlLx::GetXmlStrFromPlainStr(GetQueryStr()).CStr());}
194    if (GetAllHits()!=-1){
195      fprintf(fOut, "  <AllHits>%d</AllHits>\n", GetAllHits());}
196    fprintf(fOut, "  <Hits Size=\"%d\">\n", GetHits());
197    for (int HitN=0; HitN<GetHits(); HitN++){
198      PGgSchRef Ref=GetHit(HitN);
199      Ref->SaveXml(fOut, 1+HitN);
200    }
201    fprintf(fOut, "  </Hits>\n");
202    fprintf(fOut, "</RSet>");
203  }
204  void TGgSchRSet::LoadRSetsBin(const TStr& FNm, TGgSchRSetV& RSetV){
205    TFIn SIn(FNm); RSetV.Clr(); int RSets=0;
206    while (!SIn.Eof()){
207      RSets++; if (RSets%100==0){printf("%d\r", RSets);}
208      PGgSchRSet RSet(SIn);
209      RSetV.Add(RSet);
210    }
211  }
212  void TGgSchRSet::SaveRSetsBin(const TStr& FNm, TGgSchRSetV& RSetV){
213    TFOut SOut(FNm);
214    for (int RSetN=0; RSetN<RSetV.Len(); RSetN++){
215      RSetV[RSetN].Save(SOut);
216    }
217  }
218  void TGgSchBs::AddRef(const PGgSchRef& Ref){
219    TMd5Sig Sig=Ref->GetMd5Sig();
220    if (!RefMd5ToRefH.IsKey(Sig)){
221      RefMd5ToRefH.AddDat(Sig)=Ref;
222      RefMd5ToRefCiteCrawlPH.AddDat(Sig)=false;
223      for (int AuthN=0; AuthN<Ref->AuthNmV.Len(); AuthN++){
224        TStr LcAuthNm=Ref->AuthNmV[AuthN].GetLc();
225        if ((!LcAuthNm.Empty())&&(!AuthNmToCrawlPH.IsKey(LcAuthNm))){
226          AuthNmToCrawlPH.AddDat(LcAuthNm)=false;
227        }
228      }
229      TStr LcPubNm=Ref->PubNm.GetLc();
230      if ((!Ref->PubNm.Empty())&&(!AuthNmToCrawlPH.IsKey(LcPubNm))){
231        PubNmToCrawlPH.AddDat(LcPubNm)=false;
232      }
233    }
234  }
235  void TGgSchBs::AddRSet(const PGgSchRSet& RSet){
236    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
237      PGgSchRef Ref=RSet->GetHit(HitN);
238      AddRef(Ref);
239    }
240  }
241  TStr TGgSchBs::GetAuthNmToCrawl() const {
242    TStr AuthNm;
243    for (int AuthN=0; AuthN<AuthNmToCrawlPH.Len(); AuthN++){
244      if (!AuthNmToCrawlPH[AuthN]){
245        AuthNm=AuthNmToCrawlPH.GetKey(AuthN); break;
246      }
247    }
248    return AuthNm;
249  }
250  void TGgSchBs::SetAuthCrawled(const TStr& AuthNm){
251    AuthNmToCrawlPH.AddDat(AuthNm.GetLc())=true;
252  }
253  void TGgSchBs::SaveXml(const TStr& FNm){
254    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
255    fprintf(fOut, "<GgSchBs>\n");
256    for (int RefN=0; RefN<GetRefs(); RefN++){
257      PGgSchRef Ref=GetRef(RefN);
258      Ref->SaveXml(fOut, 1+RefN);
259    }
260    fprintf(fOut, "</GgSchBs>");
261  }
262  PRSet TRSet::NewWeb(const TStr& UrlStr, const TStr& HtmlStr){
263    PRSet RSet=TRSet::New();
264    PSIn HtmlSIn=TStrIn::New(HtmlStr);
265    THtmlLx HtmlLx(HtmlSIn);
266    HtmlLx.MoveToStrOrEof("Results");
267    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
268    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
269    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
270    AllHitsStr.DelChAll(',');
271    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
272    forever {
273      HtmlLx.MoveToBTagOrEof("<DIV>", "CLASS", "g", "<BR>", "CLEAR", "all");
274      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>"))){break;}
275      HtmlLx.MoveToBTagOrEof("<A>");
276      if (HtmlLx.Sym!=hsyBTag){break;}
277      TStr HitUrlStr=HtmlLx.GetArg("HREF");
278      TStr HitTitleStr=HtmlLx.GetStrToETag("<A>", true);
279      HtmlLx.MoveToBTagOrEof("<DIV>");
280      TStr HitCtxStr=HtmlLx.GetStrToBTag("<BR>", true);
281      RSet->AddHit(HitUrlStr, HitTitleStr, "", HitCtxStr);
282    }
283    TStr NextUrlStr;
284    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<BR>")){
285      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
286      if (!NextRelUrlStr.Empty()){
287        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
288        if (NextUrl->IsOk()){
289          NextUrlStr=NextUrl->GetUrlStr();
290        }
291      }
292    }
293    RSet->PutUrlStr(UrlStr);
294    RSet->PutNextUrlStr(NextUrlStr);
295    RSet->PutQueryStr(QueryStr);
296    RSet->PutAllHits(AllHitsStr.GetInt(-1));
297    return RSet;
298  }
299  PRSet TRSet::NewWeb(const PWebPg& WebPg){
300    TStr UrlStr=WebPg->GetUrlStr();
301    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
302    return TRSet::NewWeb(UrlStr, HtmlStr);
303  }
304  PRSet TRSet::NewNews(const TStr& UrlStr, const TStr& HtmlStr){
305    PRSet RSet=TRSet::New();
306    PSIn HtmlSIn=TStrIn::New(HtmlStr);
307    THtmlLx HtmlLx(HtmlSIn);
<span onclick='openModal()' class='match'>308    HtmlLx.MoveToStrOrEof("Results");
309    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
310    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
311    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
</span>312    AllHitsStr.DelChAll(',');
313    TStr QueryStr=HtmlLx.GetStrInTag("<B>", true);
314    forever {
315      HtmlLx.MoveToBTagOrEof("<TABLE>", "WIDTH", "75%", "<DIV>", "CLASS", "n");
316      if (!((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<TABLE>"))){break;}
317      HtmlLx.MoveToBTagOrEof("<A>");
318      if (HtmlLx.Sym!=hsyBTag){break;}
319      TStr HitUrlStr=HtmlLx.GetArg("HREF");
320      TStr IdStr=HtmlLx.GetArg("ID");
321      if ((!IdStr.Empty())&&(IdStr.LastCh()=='i')){
322        HtmlLx.MoveToBTagOrEof("<A>");
323        if (HtmlLx.Sym!=hsyBTag){break;}
324        HitUrlStr=HtmlLx.GetArg("HREF");
325      }
326      TStr HitTitleStr=HtmlLx.GetStrToETag("<A>", true);
327      TStr HitSrcNm=HtmlLx.GetStrToBTag("<NOBR>", true);
328      if (HitSrcNm.IsSuffix(" -")){
329        HitSrcNm=HitSrcNm.GetSubStr(0, HitSrcNm.Len()-3);}
330      HtmlLx.MoveToETagOrEof("<NOBR>");
331      TStr HitCtxStr=HtmlLx.GetStrToETag("<TABLE>", true);
332      RSet->AddHit(HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
333    }
334    TStr NextUrlStr;
335    if ((HtmlLx.Sym==hsyBTag)&&(HtmlLx.UcChA=="<DIV>")){
336      TStr NextRelUrlStr=HtmlLx.GetHRefBeforeStr("Next");
337      if (!NextRelUrlStr.Empty()){
338        PUrl NextUrl=TUrl::New(NextRelUrlStr, UrlStr);
339        if (NextUrl->IsOk()){
340          NextUrlStr=NextUrl->GetUrlStr();
341        }
342      }
343    }
344    RSet->PutUrlStr(UrlStr);
345    RSet->PutNextUrlStr(NextUrlStr);
346    RSet->PutQueryStr(QueryStr);
347    RSet->PutAllHits(AllHitsStr.GetInt(-1));
348    return RSet;
349  }
350  PRSet TRSet::NewNews(const PWebPg& WebPg){
351    TStr UrlStr=WebPg->GetUrlStr();
352    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
353    return TRSet::NewNews(UrlStr, HtmlStr);
354  }
355  int TRSet::GetHitN(const TStr& UrlStr, const bool& LcP) const {
356    int Hits=GetHits();
357    TStr LcUrlStr=UrlStr.GetLc();
358    for (int HitN=0; HitN<Hits; HitN++){
359      if (LcP){
360        if (GetHitUrlStr(HitN).GetLc()==LcUrlStr){return HitN;}
361      } else {
362        if (GetHitUrlStr(HitN)==UrlStr){return HitN;}
363      }
364    }
365    return -1;
366  }
367  void TRSet::Merge(const PRSet& RSet){
368    if (RSet.Empty()){return;}
369    TStrH UrlStrH(GetHits());
370    for (int HitN=0; HitN<GetHits(); HitN++){
371      UrlStrH.AddKey(GetHitUrlStr(HitN));
372    }
373    for (int HitN=0; HitN<RSet->GetHits(); HitN++){
374      TStr HitUrlStr; TStr HitTitleStr; TStr HitSrcNm; TStr HitCtxStr;
375      RSet->GetHit(HitN, HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
376      if (!UrlStrH.IsKey(HitUrlStr)){
377        AddHit(HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
378        UrlStrH.AddKey(HitUrlStr);
379      }
380    }
381    PutNextUrlStr("");
382    PutAllHits(-1);
383  }
384  PBowDocBs TRSet::GetBowDocBs(
385   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
386   const int& MxNGramLen, const int& MnNGramFq) const {
387    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
388    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
389    TStrV HtmlStrV(GetHits(), 0);
390    for (int HitN=0; HitN<GetHits(); HitN++){
391      TStr TitleStr=GetHitTitleStr(HitN);
392      TStr CtxStr=GetHitCtxStr(HitN);
393      TStr HtmlStr=TitleStr+". "+CtxStr;
394      HtmlStrV.Add(HtmlStr);
395    }
396    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
397     HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
398    printf("Create Bag-Of-Words Base ... ");
399    PBowDocBs BowDocBs=TBowDocBs::New();
400    BowDocBs->PutNGramBs(NGramBs);
401    for (int HitN=0; HitN<GetHits(); HitN++){
402      BowDocBs->AddHtmlDoc(GetHitTitleStr(HitN), TStrV(), HtmlStrV[HitN], true);
403    }
404    BowDocBs->AssertOk();
405    printf("Done.\n");
406    return BowDocBs;
407  }
408  PRSet TRSet::LoadBin(const TStr& FNm, const bool& MultiRSetsP){
409    if (!MultiRSetsP){
410      TFIn SIn(FNm); return Load(SIn);
411    } else {
412      PRSet RSet=TRSet::New();
413      TFIn SIn(FNm); int RSets=0;
414      while (!SIn.Eof()){
415        RSets++; 
416        PRSet SubRSet=TRSet::Load(SIn);
417        RSet->Merge(SubRSet);
418      }
419      return RSet;
420    }
421  }
422  void TRSet::SaveBin(const TStr& FNm, const PRSet& RSet, const bool& Append){
423    if (RSet.Empty()){
424      PRSet RSet=TRSet::New();
425      RSet->SaveBin(FNm, Append);
426    } else {
427      RSet->SaveBin(FNm, Append);
428    }
429  }
430  void TRSet::SaveXml(const TStr& FNm, const PRSet& RSet){
431    if (RSet.Empty()){
432      TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
433      fprintf(fOut, "<RSets>\n");
434      fprintf(fOut, "  <Error/>\n");
435      fprintf(fOut, "</RSets>");
436    } else {
437      RSet->SaveXml(FNm);
438    }
439  }
440  void TRSet::SaveXml(const TStr& FNm){
441    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
442    fprintf(fOut, "<RSet>\n");
443    if (!GetUrlStr().Empty()){
444      fprintf(fOut, "  <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(GetUrlStr()).CStr());}
445    if (!GetNextUrlStr().Empty()){
446      fprintf(fOut, "  <NextUrl>%s</NextUrl>\n", TXmlLx::GetXmlStrFromPlainStr(GetNextUrlStr()).CStr());}
447    if (!GetQueryStr().Empty()){
448      fprintf(fOut, "  <Query>%s</Query>\n", TXmlLx::GetXmlStrFromPlainStr(GetQueryStr()).CStr());}
449    if (GetAllHits()!=-1){
450      fprintf(fOut, "  <AllHits>%d</AllHits>\n", GetAllHits());}
451    fprintf(fOut, "  <Hits Size=\"%d\">\n", GetHits());
452    for (int HitN=0; HitN<GetHits(); HitN++){
453      TStr HitUrlStr; TStr HitTitleStr; TStr HitSrcNm; TStr HitCtxStr;
454      GetHit(HitN, HitUrlStr, HitTitleStr, HitSrcNm, HitCtxStr);
455      fprintf(fOut, "    <Hit Num=\"%d\">\n", 1+HitN);
456      fprintf(fOut, "      <Url>%s</Url>\n", TXmlLx::GetXmlStrFromPlainStr(HitUrlStr).CStr());
457      fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(HitTitleStr).CStr());
458      if (!HitSrcNm.Empty()){
459        fprintf(fOut, "      <Source>%s</Source>\n", TXmlLx::GetXmlStrFromPlainStr(HitSrcNm).CStr());}
460      fprintf(fOut, "      <Snippet>%s</Snippet>\n", TXmlLx::GetXmlStrFromPlainStr(HitCtxStr).CStr());
461      fprintf(fOut, "    </Hit>\n");
462    }
463    fprintf(fOut, "  </Hits>\n");
464    fprintf(fOut, "</RSet>");
465  }
466  void TRSet::LoadRSetsBin(const TStr& FNm, TRSetV& RSetV){
467    TFIn SIn(FNm); RSetV.Clr(); int RSets=0;
468    while (!SIn.Eof()){
469      RSets++; printf("%d\r", RSets);
470      PRSet RSet=TRSet::Load(SIn);
471      RSetV.Add(RSet);
472    }
473  }
474  void TRSet::SaveRSetsBin(const TStr& FNm, TRSetV& RSetV){
475    TFOut SOut(FNm);
476    for (int RSetN=0; RSetN<RSetV.Len(); RSetN++){
477      RSetV[RSetN]->Save(SOut);
478    }
479  }
480  void TGgWebFetchSaver::OnFetch(const int&, const PWebPg& WebPg){
481    printf("Fetched [Wait:%d Conn.:%d]: %s\n",
482     GetWaitUrls(), GetConnUrls(), WebPg->GetUrlStr().CStr());
483    WebPgV.Add(WebPg);
484    if (Empty()){
485      TSysMsg::Quit();}
486  }
487  void TGgWebFetchSaver::OnError(const int&, const TStr& MsgStr){
488    printf("Error [Wait:%d Conn.:%d]: %s\n",
489     GetWaitUrls(), GetConnUrls(), MsgStr.CStr());
490    if (Empty()){
491      TSysMsg::Quit();}
492  }
493  PWebPg TGgWebFetchSaver::GetWebPg(const TStr& UrlStr) const {
494    for (int WebPgN=0; WebPgN<GetWebPgs(); WebPgN++){
495      if (GetWebPg(WebPgN)->GetUrlStr(0)==UrlStr){
496        return GetWebPg(WebPgN);}
497    }
498    return NULL;
499  }
500  PGgFCrawl TGgFCrawl::GetFCrawl(
501   const TStr& SrcUrlStr, const int& MxCands, const TStr& ProxyStr){
502    printf("Expand source URL: %s\n", SrcUrlStr.CStr());
503    PRSet SrcUrlRSet=
504     TGg::WebSearch(TStr("related:")+SrcUrlStr, -1, TNotify::NullNotify, ProxyStr);
505    PGgFCrawl FCrawl=TGgFCrawl::New();
506    FCrawl->SrcUrlStr=SrcUrlStr;
507    FCrawl->DstRSet=TRSet::New(SrcUrlRSet);
508    for (int HitN=0; HitN<SrcUrlRSet->GetHits(); HitN++){
509      if ((MxCands!=-1)&&(FCrawl->DstRSet->GetHits()>MxCands)){break;}
510      TStr HitUrlStr=SrcUrlRSet->GetHitUrlStr(HitN);
511      printf("Expand URL: %s\n", HitUrlStr.CStr());
512      PRSet RelUrlRSet=
513       TGg::WebSearch(TStr("related:")+HitUrlStr, -1, TNotify::NullNotify, ProxyStr);
514      FCrawl->DstRSet->Merge(RelUrlRSet);
515    }
516    TGgWebFetchSaver WebFetchSaver(100);
517    WebFetchSaver.PutProxyStr(ProxyStr);
518    {bool Ok; TStr MsgStr;
519    TWebFetchBlocking::GetWebPg(
520     SrcUrlStr, Ok, MsgStr, FCrawl->SrcWebPg, NULL, ProxyStr);
521    if (!Ok){FCrawl->SrcWebPg=NULL;}}
522    int FetchHits=FCrawl->DstRSet->GetHits();
523    if ((MxCands!=-1)&&(MxCands<FetchHits)){FetchHits=MxCands;}
524    for (int HitN=0; HitN<FetchHits; HitN++){
525      TStr HitUrlStr=FCrawl->DstRSet->GetHitUrlStr(HitN);
526      WebFetchSaver.FetchUrl(HitUrlStr);
527    }
528    TSysMsg::Loop();
529    for (int WebPgN=0; WebPgN<WebFetchSaver.GetWebPgs(); WebPgN++){
530      PWebPg WebPg=WebFetchSaver.GetWebPg(WebPgN);
531      FCrawl->UrlStrToWebPgH.AddDat(WebPg->GetUrlStr(), WebPg);
532    }
533    FCrawl->BowDocBs=TBowDocBs::New();
534    FCrawl->SrcDId=FCrawl->BowDocBs->AddHtmlDoc(
535     SrcUrlStr, TStrV(), FCrawl->SrcWebPg->GetHttpBodyAsStr());
536    for (int WebPgN=0; WebPgN<WebFetchSaver.GetWebPgs(); WebPgN++){
537      PWebPg WebPg=WebFetchSaver.GetWebPg(WebPgN);
538      FCrawl->BowDocBs->AddHtmlDoc(
539       WebPg->GetUrlStr(0), TStrV(), WebPg->GetHttpBodyAsStr());
540    }
541    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(FCrawl->BowDocBs, bwwtNrmTFIDF);
542    PBowSim BowSim=TBowSim::New(bstCos);
543    FCrawl->SimDIdKdV; FCrawl->SumSim=0;
544    for (int DIdN=0; DIdN<BowDocWgtBs->GetDocs(); DIdN++){
545      int DId=BowDocWgtBs->GetDId(DIdN);
546      if (DId!=FCrawl->SrcDId){
547        double Sim=BowSim->GetSim(
548         BowDocWgtBs->GetSpV(FCrawl->SrcDId), BowDocWgtBs->GetSpV(DId));
549        FCrawl->SimDIdKdV.Add(TFltIntKd(Sim, DId));
550        FCrawl->SumSim+=Sim;
551      }
552    }
553    FCrawl->SimDIdKdV.Sort(false);
554    FCrawl->Ok=true;
555    return FCrawl;
556  }
557  void TGgFCrawl::SaveXml(const TStr& FNm, const bool& SaveDocP){
558    if (!Ok){return;}
559    PSOut SOut=TFOut::New(FNm);
560    FILE* fOut=SOut->GetFileId();
561    fprintf(fOut, "<FocusedCrawl>\n");
562    fprintf(fOut, "  <SourceWebPage>\n");
563    fprintf(fOut, "    <Url>%s</Url>\n", SrcUrlStr.CStr());
564    if (SaveDocP){
565      THtmlDoc::SaveHtmlToXml(SrcWebPg->GetHttpBodyAsStr(), SOut,
566       SrcUrlStr, false, false, true, false, false);
567    }
568    fprintf(fOut, "  </SourceWebPage>\n");
569    fprintf(fOut, "  <FocusedWebPages>\n", SimDIdKdV.Len());
570    double SumSimSF=0;
571    for (int DIdN=0; DIdN<SimDIdKdV.Len(); DIdN++){
572      double Sim=SimDIdKdV[DIdN].Key;
573      SumSimSF+=Sim; if ((SumSim==0)||(SumSimSF>SumSim*0.99)){break;}
574      int DId=SimDIdKdV[DIdN].Dat;
575      TStr UrlStr=BowDocBs->GetDocNm(DId);
576      printf("%d. %.3f %s\n", 1+DIdN, Sim, UrlStr.CStr());
577      int HitN=DstRSet->GetHitN(UrlStr); IAssert(HitN!=-1);
578      fprintf(fOut, "    <WebPage Rank=\"%d\" Sim=\"%.3f\">\n", 1+DIdN, Sim, UrlStr.CStr());
579      fprintf(fOut, "      <Url>%s</Url>\n", UrlStr.CStr());
580      fprintf(fOut, "      <Title>%s</Title>\n", TXmlLx::GetXmlStrFromPlainStr(DstRSet->GetHitTitleStr(HitN)).CStr());
581      fprintf(fOut, "      <Context>%s</Context>\n", TXmlLx::GetXmlStrFromPlainStr(DstRSet->GetHitCtxStr(HitN)).CStr());
582      if (SaveDocP){
583        PWebPg WebPg=UrlStrToWebPgH.GetDat(UrlStr);
584        THtmlDoc::SaveHtmlToXml(WebPg->GetHttpBodyAsStr(), SOut,
585         SrcUrlStr, false, false, true, false, false);
586      }
587      fprintf(fOut, "    </WebPage>\n");
588    }
589    printf("\n");
590    fprintf(fOut, "  </FocusedWebPages>\n");
591    fprintf(fOut, "</FocusedCrawl>\n");
592  }
593  void TGgFCrawl::SaveTxt(const TStr& FNm){
594    PSOut SOut=TFOut::New(FNm);
595    FILE* fOut=SOut->GetFileId();
596    if (Ok){
597      fprintf(fOut, "<SourceWebPage>\n");
598      fprintf(fOut, "%s\n", SrcUrlStr.CStr());
599      double SumSimSF=0;
600      for (int DIdN=0; DIdN<SimDIdKdV.Len(); DIdN++){
601        double Sim=SimDIdKdV[DIdN].Key;
602        SumSimSF+=Sim; if ((SumSim==0)||(SumSimSF>SumSim*0.99)){break;}
603        int DId=SimDIdKdV[DIdN].Dat;
604        TStr UrlStr=BowDocBs->GetDocNm(DId);
605        printf("%d. %.3f %s\n", 1+DIdN, Sim, UrlStr.CStr());
606        int HitN=DstRSet->GetHitN(UrlStr); IAssert(HitN!=-1);
607        TStr TitleStr=DstRSet->GetHitTitleStr(HitN);
608        TitleStr.ChangeChAll('\n', ' ');
609        TStr CtxStr=DstRSet->GetHitCtxStr(HitN);
610        CtxStr.ChangeChAll('\n', ' ');
611        fprintf(fOut, "<ResultWebPage>\n");
612        fprintf(fOut, "%s\n", UrlStr.CStr());
613        fprintf(fOut, "%s\n", TitleStr.CStr());
614        fprintf(fOut, "%s\n", CtxStr.CStr());
615      }
616    } else {
617      fprintf(fOut, "<Error>\n");
618    }
619    fprintf(fOut, "<End>\n");
620  }
621  PGgCtxGraph TGgCtxGraph::GetCtxGraph(const TStr& FocusUrlStr){
622    PGgCtxGraph CtxGraph=TGgCtxGraph::New();
623    CtxGraph->Ok=false;
624    CtxGraph->FocusUrlStr=FocusUrlStr;
625    {bool Ok; TStr MsgStr;
626    TWebFetchBlocking::GetWebPg(
627     CtxGraph->FocusUrlStr, Ok, MsgStr, CtxGraph->FocusWebPg, TNotify::StdNotify);
628    if (!Ok){return CtxGraph;}}
629    PRSet InRSet=
630     TGg::WebSearch(TStr("link:")+CtxGraph->FocusUrlStr, -1, TNotify::StdNotify);
631    for (int HitN=0; HitN<InRSet->GetHits(); HitN++){
632      TStr UrlStr; TStr TitleStr; TStr SrcNm; TStr CtxStr;
633      InRSet->GetHit(HitN, UrlStr, TitleStr, SrcNm, CtxStr);
634      TitleStr.ChangeChAll('\n', ' ');
635      CtxGraph->InUrlCtxStrPrV.Add(TStrPr(UrlStr, TitleStr));
636    }
637    TStrKdV OutDescUrlStrKdV;
638    CtxGraph->FocusWebPg->GetOutDescUrlStrKdV(OutDescUrlStrKdV);
639    for (int UrlN=0; UrlN<OutDescUrlStrKdV.Len(); UrlN++){
640      OutDescUrlStrKdV[UrlN].Key.ChangeChAll('\n', ' ');
641      CtxGraph->OutUrlCtxStrPrV.Add(
642       TStrPr(OutDescUrlStrKdV[UrlN].Dat, OutDescUrlStrKdV[UrlN].Key));
643    }
644    CtxGraph->Ok=true;
645    return CtxGraph;
646  }
647  void TGgCtxGraph::SaveTxt(const TStr& FNm){
648    PSOut SOut=TFOut::New(FNm);
649    FILE* fOut=SOut->GetFileId();
650    if (Ok){
651      fprintf(fOut, "<FocusWebPage>\n");
652      fprintf(fOut, "%s\n", FocusUrlStr.CStr());
653      for (int UrlN=0; UrlN<InUrlCtxStrPrV.Len(); UrlN++){
654        fprintf(fOut, "<InWebPage>\n");
655        fprintf(fOut, "%s\n", InUrlCtxStrPrV[UrlN].Val1.CStr());
656        fprintf(fOut, "%s\n", InUrlCtxStrPrV[UrlN].Val2.CStr());
657      }
658      for (int UrlN=0; UrlN<OutUrlCtxStrPrV.Len(); UrlN++){
659        fprintf(fOut, "<OutWebPage>\n");
660        fprintf(fOut, "%s\n", OutUrlCtxStrPrV[UrlN].Val1.CStr());
661        fprintf(fOut, "%s\n", OutUrlCtxStrPrV[UrlN].Val2.CStr());
662      }
663    } else {
664      fprintf(fOut, "<Error>\n");
665    }
666    fprintf(fOut, "<End>\n");
667  }
668  TStr TGg::GetWebSearchUrlStr(const TStr& QueryStr){
669    TStr SearchUrlStr=
670     "http:&bsol;&bsol;www.google.com/search?num=100&q="+
671     TUrl::GetUrlSearchStr(QueryStr);
672    return SearchUrlStr;
673  }
674  TStr TGg::GetNewsSearchUrlStr(const TStr& QueryStr){
675    TStr SearchUrlStr=
676     "http:&bsol;&bsol;news.google.com/news?num=100&q="+
677     TUrl::GetUrlSearchStr(QueryStr);
678    return SearchUrlStr;
679  }
680  TStr TGg::GetScholarSearchUrlStr(const TStr& QueryStr){
681    TStr SearchUrlStr=
682     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q="+
683     TUrl::GetUrlSearchStr(QueryStr);
684    return SearchUrlStr;
685  }
686  TStr TGg::GetScholarAuthorSearchUrlStr(const TStr& QueryStr){
687    TStr AuthorQueryStr=TStr("author:\"")+QueryStr+"\"";
688    TStr SearchUrlStr=
689     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q="+
690     TUrl::GetUrlSearchStr(AuthorQueryStr);
691    return SearchUrlStr;
692  }
693  TStr TGg::GetScholarPublicationSearchUrlStr(const TStr& QueryStr){
694    TStr PublicationQueryStr=TStr("\"")+QueryStr+"\"";
695    TStr SearchUrlStr=
696     "http:&bsol;&bsol;scholar.google.com/scholar?num=100&hl=en&lr=&q=&as_publication="+
697     TUrl::GetUrlSearchStr(PublicationQueryStr);
698    return SearchUrlStr;
699  }
700  PRSet TGg::WebSearch(const TStr& QueryStr, const int& MxHits,
701   const PNotify& Notify, const TStr& ProxyStr){
702    TStr SearchUrlStr=TGg::GetWebSearchUrlStr(QueryStr);
703    printf("."); bool Ok; TStr MsgStr; PWebPg WebPg;
704    TWebFetchBlocking::GetWebPg(
705     SearchUrlStr, Ok, MsgStr, WebPg, Notify, ProxyStr);
706    if (Ok){
707      PRSet RSet=TRSet::NewWeb(WebPg);
708      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
709      while (!NextSearchUrlStr.Empty()){
710        if ((MxHits!=-1)&&(RSet->GetHits()>=MxHits)){break;}
711        printf("."); bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
712        TWebFetchBlocking::GetWebPg(
713         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify, ProxyStr);
714        if (NextOk){
715          PRSet NextRSet=TRSet::NewWeb(NextWebPg);
716          RSet->Merge(NextRSet);
717          NextSearchUrlStr=NextRSet->GetNextUrlStr();
718        } else {
719          NextSearchUrlStr="";
720        }
721      }
722      RSet->Trunc(MxHits);
723      RSet->PutQueryStr(QueryStr);
724      return RSet;
725    } else {
726      return TRSet::New();
727    }
728  }
729  PRSet TGg::WebSearchExternal(
730   const TStr& QueryStr, const int& MxHits, const PNotify& Notify){
731    TStr ExeFPath=Env.GetExeFPath();
732    TStr ExeFNm=TStr::GetNrFPath(ExeFPath)+"Google2RSet.exe";
733    TStr RSetFNm=TStr::GetNrFPath(ExeFPath)+TTm::GetCurUniTm().GetIdStr()+".RSet";
734    TStr CmLn=
735     TStr::GetStr(QueryStr, " -iwq:%s")+
736     TInt::GetStr(MxHits, " -hits:%d")+
737     TStr::GetStr(RSetFNm, " -obin:\"%s\" -oxml: -obow: -ssilent");
738    if (TSysProc::ExeProc(ExeFNm, CmLn)){
739      PRSet RSet;
740      {TFIn RSetFIn(RSetFNm);
741      RSet=TRSet::Load(RSetFIn);}
742      TFile::Del(RSetFNm);
743      return RSet;
744    } else {
745      return TRSet::New();
746    }
747  }
748  PRSet TGg::NewsSearch(const TStr& QueryStr, const int& MxHits, const PNotify& Notify){
749    TStr SearchUrlStr=TGg::GetNewsSearchUrlStr(QueryStr);
750    bool Ok; TStr MsgStr; PWebPg WebPg;
751    TWebFetchBlocking::GetWebPg(
752     SearchUrlStr, Ok, MsgStr, WebPg, Notify);
753    if (Ok){
754      PRSet RSet=TRSet::NewNews(WebPg);
755      TStr NextSearchUrlStr=RSet->GetNextUrlStr();
756      while (!NextSearchUrlStr.Empty()){
757        if ((MxHits!=-1)&&(RSet->GetHits()>=MxHits)){break;}
758        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
759        TWebFetchBlocking::GetWebPg(
760         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify);
761        if (NextOk){
762          PRSet NextRSet=TRSet::NewNews(NextWebPg);
763          RSet->Merge(NextRSet);
764          NextSearchUrlStr=NextRSet->GetNextUrlStr();
765        } else {
766          NextSearchUrlStr="";
767        }
768      }
769      RSet->Trunc(MxHits);
770      return RSet;
771    } else {
772      return TRSet::New();
773    }
774  }
775  PGgSchRSet TGg::_ScholarSearch(
776   const TStr& SearchUrlStr, const PNotify& Notify){
777    bool Ok; TStr MsgStr; PWebPg WebPg;
778    TWebFetchBlocking::GetWebPg(
779     SearchUrlStr, Ok, MsgStr, WebPg, Notify);
780    if (Ok){
781      PGgSchRSet GgSchRSet=TGgSchRSet::NewScholar(WebPg);
782      TStr NextSearchUrlStr=GgSchRSet->GetNextUrlStr();
783      TRnd Rnd(0);
784      while (!NextSearchUrlStr.Empty()){
785        int WaitMSecs=int(1*1000*(Rnd.GetUniDev()+0.5));
786        TSysProc::Sleep(WaitMSecs);
787        bool NextOk; TStr NextMsgStr; PWebPg NextWebPg;
788        TWebFetchBlocking::GetWebPg(
789         NextSearchUrlStr, NextOk, NextMsgStr, NextWebPg, Notify);
790        if (NextOk){
791          PGgSchRSet NextRSet=TGgSchRSet::NewScholar(NextWebPg);
792          GgSchRSet->Merge(NextRSet);
793          NextSearchUrlStr=NextRSet->GetNextUrlStr();
794        } else {
795          NextSearchUrlStr="";
796        }
797      }
798      return GgSchRSet;
799    } else {
800      return TGgSchRSet::New();
801    }
802  }
803  PGgSchRSet TGg::ScholarSearch(const TStr& QueryStr, const PNotify& Notify){
804    TStr SearchUrlStr=GetScholarSearchUrlStr(QueryStr);
805    return _ScholarSearch(SearchUrlStr, Notify);
806  }
807  PGgSchRSet TGg::ScholarAuthorSearch(const TStr& AuthorNm, const PNotify& Notify){
808    TStr SearchUrlStr=GetScholarAuthorSearchUrlStr(AuthorNm);
809    return _ScholarSearch(SearchUrlStr, Notify);
810  }
811  PGgSchRSet TGg::ScholarPublicationSearch(const TStr& PublicationNm, const PNotify& Notify){
812    TStr SearchUrlStr=GetScholarPublicationSearchUrlStr(PublicationNm);
813    return _ScholarSearch(SearchUrlStr, Notify);
814  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wordnet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-google.cpp</div>
                </div>
                <div class="column column_space"><pre><code>130    int Sk_RelId=PlBs->GetRelId("sk", 3);
131    int G_RelId=PlBs->GetRelId("g", 2);
132    int Syntax_RelId=PlBs->GetRelId("syntax", 3);
133    int Hyp_RelId=PlBs->GetRelId("hyp", 2);
</pre></code></div>
                <div class="column column_space"><pre><code>308    HtmlLx.MoveToStrOrEof("Results");
309    TStr FromResultStr=HtmlLx.GetStrInTag("<B>", true);
310    TStr ToResultStr=HtmlLx.GetStrInTag("<B>", true);
311    TStr AllHitsStr=HtmlLx.GetStrInTag("<B>", true);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    