
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.354136429608127%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaView.h</h3>
            <pre><code>1  #import <Cocoa/Cocoa.h>
2  #import "Scintilla.h"
3  #import "InfoBarCommunicator.h"
4  #define WM_COMMAND 1001
5  #define WM_NOTIFY 1002
6  typedef void(*SciNotifyFunc)(intptr_t windowid, unsigned int iMessage, uintptr_t wParam, uintptr_t lParam);
7  extern NSString *const SCIUpdateUINotification;
8  @protocol ScintillaNotificationProtocol
<span onclick='openModal()' class='match'>9  - (void) notification: (SCNotification *) notification;
10  @end
11  @interface SCIScrollView : NSScrollView;
12  @end
13  @interface SCIMarginView : NSRulerView;
14  @end
15  @interface SCIContentView : NSView <
16  	NSTextInputClient,
17  	NSUserInterfaceValidations,
18  	NSDraggingSource,
19  	NSDraggingDestination,
20  	NSAccessibilityStaticText>;
21  - (void) setCursor: (int) cursor; 
22  @end
23  @interface ScintillaView : NSView <InfoBarCommunicator, ScintillaNotificationProtocol>;
24  @property(nonatomic, unsafe_unretained) id<ScintillaNotificationProtocol> delegate;
25  @property(nonatomic, readonly) NSScrollView *scrollView;
</span>26  + (Class) contentViewClass;
27  - (void) notify: (NotificationType) type message: (NSString *) message location: (NSPoint) location
28  	  value: (float) value;
29  - (void) setCallback: (id <InfoBarCommunicator>) callback;
30  - (void) suspendDrawing: (BOOL) suspend;
31  - (void) notification: (SCNotification *) notification;
32  - (void) updateIndicatorIME;
33  - (void) setMarginWidth: (int) width;
34  - (SCIContentView *) content;
35  - (void) updateMarginCursors;
36  - (NSString *) string;
37  - (void) setString: (NSString *) aString;
38  - (void) insertText: (id) aString;
39  - (void) setEditable: (BOOL) editable;
40  - (BOOL) isEditable;
41  - (NSRange) selectedRange;
42  - (NSRange) selectedRangePositions;
43  - (NSString *) selectedString;
44  - (void) deleteRange: (NSRange) range;
45  - (void) setFontName: (NSString *) font
46  		size: (int) size
47  		bold: (BOOL) bold
48  	      italic: (BOOL) italic;
49  + (sptr_t) directCall: (ScintillaView *) sender message: (unsigned int) message wParam: (uptr_t) wParam
50  	       lParam: (sptr_t) lParam;
51  - (sptr_t) message: (unsigned int) message wParam: (uptr_t) wParam lParam: (sptr_t) lParam;
52  - (sptr_t) message: (unsigned int) message wParam: (uptr_t) wParam;
53  - (sptr_t) message: (unsigned int) message;
54  - (void) setGeneralProperty: (int) property parameter: (long) parameter value: (long) value;
55  - (void) setGeneralProperty: (int) property value: (long) value;
56  - (long) getGeneralProperty: (int) property;
57  - (long) getGeneralProperty: (int) property parameter: (long) parameter;
58  - (long) getGeneralProperty: (int) property parameter: (long) parameter extra: (long) extra;
59  - (long) getGeneralProperty: (int) property ref: (const void *) ref;
60  - (void) setColorProperty: (int) property parameter: (long) parameter value: (NSColor *) value;
61  - (void) setColorProperty: (int) property parameter: (long) parameter fromHTML: (NSString *) fromHTML;
62  - (NSColor *) getColorProperty: (int) property parameter: (long) parameter;
63  - (void) setReferenceProperty: (int) property parameter: (long) parameter value: (const void *) value;
64  - (const void *) getReferenceProperty: (int) property parameter: (long) parameter;
65  - (void) setStringProperty: (int) property parameter: (long) parameter value: (NSString *) value;
66  - (NSString *) getStringProperty: (int) property parameter: (long) parameter;
67  - (void) setLexerProperty: (NSString *) name value: (NSString *) value;
68  - (NSString *) getLexerProperty: (NSString *) name;
69  - (void) registerNotifyCallback: (intptr_t) windowid value: (SciNotifyFunc) callback __attribute__ ( (deprecated)) ;
70  - (void) setInfoBar: (NSView <InfoBarCommunicator> *) aView top: (BOOL) top;
71  - (void) setStatusText: (NSString *) text;
72  - (BOOL) findAndHighlightText: (NSString *) searchText
73  		    matchCase: (BOOL) matchCase
74  		    wholeWord: (BOOL) wholeWord
75  		     scrollTo: (BOOL) scrollTo
76  			 wrap: (BOOL) wrap;
77  - (BOOL) findAndHighlightText: (NSString *) searchText
78  		    matchCase: (BOOL) matchCase
79  		    wholeWord: (BOOL) wholeWord
80  		     scrollTo: (BOOL) scrollTo
81  			 wrap: (BOOL) wrap
82  		    backwards: (BOOL) backwards;
83  - (int) findAndReplaceText: (NSString *) searchText
84  		    byText: (NSString *) newText
85  		 matchCase: (BOOL) matchCase
86  		 wholeWord: (BOOL) wholeWord
87  		     doAll: (BOOL) doAll;
88  @end
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-arg.cc</h3>
            <pre><code>1  #include "absl/strings/internal/str_format/arg.h"
2  #include <cassert>
3  #include <cerrno>
4  #include <cstdlib>
5  #include <string>
6  #include <type_traits>
7  #include "absl/base/port.h"
8  #include "absl/strings/internal/str_format/float_conversion.h"
9  #include "absl/strings/numbers.h"
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace str_format_internal {
13  namespace {
14  void ReducePadding(string_view s, size_t *capacity) {
15    *capacity = Excess(s.size(), *capacity);
16  }
17  void ReducePadding(size_t n, size_t *capacity) {
18    *capacity = Excess(n, *capacity);
19  }
20  template <typename T>
21  struct MakeUnsigned : std::make_unsigned<T> {};
22  template <>
23  struct MakeUnsigned<absl::int128> {
24    using type = absl::uint128;
25  };
26  template <>
27  struct MakeUnsigned<absl::uint128> {
28    using type = absl::uint128;
29  };
30  template <typename T>
31  struct IsSigned : std::is_signed<T> {};
32  template <>
33  struct IsSigned<absl::int128> : std::true_type {};
34  template <>
35  struct IsSigned<absl::uint128> : std::false_type {};
36  class IntDigits {
37   public:
38    template <typename T>
39    void PrintAsOct(T v) {
40      static_assert(!IsSigned<T>::value, "");
41      char *p = storage_ + sizeof(storage_);
42      do {
43        *--p = static_cast<char>('0' + (static_cast<size_t>(v) & 7));
44        v >>= 3;
45      } while (v);
46      start_ = p;
47      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
48    }
49    template <typename T>
50    void PrintAsDec(T v) {
51      static_assert(std::is_integral<T>::value, "");
52      start_ = storage_;
53      size_ = static_cast<size_t>(numbers_internal::FastIntToBuffer(v, storage_) -
54                                  storage_);
55    }
56    void PrintAsDec(int128 v) {
57      auto u = static_cast<uint128>(v);
58      bool add_neg = false;
59      if (v < 0) {
60        add_neg = true;
61        u = uint128{} - u;
62      }
63      PrintAsDec(u, add_neg);
64    }
65    void PrintAsDec(uint128 v, bool add_neg = false) {
66      char *p = storage_ + sizeof(storage_);
67      do {
68        p -= 2;
69        numbers_internal::PutTwoDigits(static_cast<uint32_t>(v % 100), p);
70        v /= 100;
71      } while (v);
72      if (p[0] == '0') {
73        ++p;
74      }
75      if (add_neg) {
76        *--p = '-';
77      }
78      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
79      start_ = p;
80    }
81    template <typename T>
82    void PrintAsHexLower(T v) {
83      static_assert(!IsSigned<T>::value, "");
84      char *p = storage_ + sizeof(storage_);
85      do {
86        p -= 2;
87        constexpr const char* table = numbers_internal::kHexTable;
88        std::memcpy(p, table + 2 * (static_cast<size_t>(v) & 0xFF), 2);
89        if (sizeof(T) == 1) break;
90        v >>= 8;
91      } while (v);
92      if (p[0] == '0') {
93        ++p;
94      }
95      start_ = p;
96      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
97    }
98    template <typename T>
99    void PrintAsHexUpper(T v) {
100      static_assert(!IsSigned<T>::value, "");
101      char *p = storage_ + sizeof(storage_);
102      do {
103        *--p = "0123456789ABCDEF"[static_cast<size_t>(v) & 15];
104        v >>= 4;
105      } while (v);
106      start_ = p;
107      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
108    }
109    string_view with_neg_and_zero() const { return {start_, size_}; }
110    string_view without_neg_or_zero() const {
111      static_assert('-' < '0', "The check below verifies both.");
112      size_t advance = start_[0] <= '0' ? 1 : 0;
113      return {start_ + advance, size_ - advance};
114    }
115    bool is_negative() const { return start_[0] == '-'; }
116   private:
117    const char *start_;
118    size_t size_;
119    char storage_[128 / 3 + 1 + 1];
120  };
121  string_view BaseIndicator(const IntDigits &as_digits,
122                            const FormatConversionSpecImpl conv) {
123    bool alt = conv.has_alt_flag() ||
124               conv.conversion_char() == FormatConversionCharInternal::p;
125    bool hex = (conv.conversion_char() == FormatConversionCharInternal::x ||
126                conv.conversion_char() == FormatConversionCharInternal::X ||
127                conv.conversion_char() == FormatConversionCharInternal::p);
128    if (alt && hex && !as_digits.without_neg_or_zero().empty()) {
129      return conv.conversion_char() == FormatConversionCharInternal::X ? "0X"
130                                                                       : "0x";
131    }
132    return {};
133  }
134  string_view SignColumn(bool neg, const FormatConversionSpecImpl conv) {
135    if (conv.conversion_char() == FormatConversionCharInternal::d ||
136        conv.conversion_char() == FormatConversionCharInternal::i) {
137      if (neg) return "-";
138      if (conv.has_show_pos_flag()) return "+";
139      if (conv.has_sign_col_flag()) return " ";
140    }
141    return {};
142  }
143  bool ConvertCharImpl(char v,
144                       const FormatConversionSpecImpl conv,
145                       FormatSinkImpl* sink) {
146    size_t fill = 0;
147    if (conv.width() >= 0)
148      fill = static_cast<size_t>(conv.width());
149    ReducePadding(1, &fill);
150    if (!conv.has_left_flag()) sink->Append(fill, ' ');
151    sink->Append(1, v);
152    if (conv.has_left_flag()) sink->Append(fill, ' ');
153    return true;
154  }
155  bool ConvertIntImplInnerSlow(const IntDigits &as_digits,
156                               const FormatConversionSpecImpl conv,
157                               FormatSinkImpl *sink) {
158    size_t fill = 0;
159    if (conv.width() >= 0)
160      fill = static_cast<size_t>(conv.width());
161    string_view formatted = as_digits.without_neg_or_zero();
162    ReducePadding(formatted, &fill);
163    string_view sign = SignColumn(as_digits.is_negative(), conv);
164    ReducePadding(sign, &fill);
165    string_view base_indicator = BaseIndicator(as_digits, conv);
166    ReducePadding(base_indicator, &fill);
167    bool precision_specified = conv.precision() >= 0;
168    size_t precision =
169        precision_specified ? static_cast<size_t>(conv.precision()) : size_t{1};
170    if (conv.has_alt_flag() &&
171        conv.conversion_char() == FormatConversionCharInternal::o) {
172      if (formatted.empty() || *formatted.begin() != '0') {
173        size_t needed = formatted.size() + 1;
174        precision = std::max(precision, needed);
175      }
176    }
177    size_t num_zeroes = Excess(formatted.size(), precision);
178    ReducePadding(num_zeroes, &fill);
179    size_t num_left_spaces = !conv.has_left_flag() ? fill : 0;
180    size_t num_right_spaces = conv.has_left_flag() ? fill : 0;
181    if (!precision_specified && conv.has_zero_flag()) {
182      num_zeroes += num_left_spaces;
183      num_left_spaces = 0;
184    }
185    sink->Append(num_left_spaces, ' ');
186    sink->Append(sign);
187    sink->Append(base_indicator);
188    sink->Append(num_zeroes, '0');
189    sink->Append(formatted);
190    sink->Append(num_right_spaces, ' ');
191    return true;
192  }
193  template <typename T>
194  bool ConvertFloatArg(T v, FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
195    if (conv.conversion_char() == FormatConversionCharInternal::v) {
196      conv.set_conversion_char(FormatConversionCharInternal::g);
197    }
198    return FormatConversionCharIsFloat(conv.conversion_char()) &&
199           ConvertFloatImpl(v, conv, sink);
200  }
201  inline bool ConvertStringArg(string_view v, const FormatConversionSpecImpl conv,
202                               FormatSinkImpl *sink) {
203    if (conv.is_basic()) {
204      sink->Append(v);
205      return true;
206    }
207    return sink->PutPaddedString(v, conv.width(), conv.precision(),
208                                 conv.has_left_flag());
209  }
210  }  
211  bool ConvertBoolArg(bool v, FormatSinkImpl *sink) {
212    if (v) {
213      sink->Append("true");
214    } else {
215      sink->Append("false");
216    }
217    return true;
218  }
219  template <typename T>
220  bool ConvertIntArg(T v, FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
221    using U = typename MakeUnsigned<T>::type;
222    IntDigits as_digits;
223    switch (static_cast<uint8_t>(conv.conversion_char())) {
224      case static_cast<uint8_t>(FormatConversionCharInternal::c):
225        return ConvertCharImpl(static_cast<char>(v), conv, sink);
226      case static_cast<uint8_t>(FormatConversionCharInternal::o):
227        as_digits.PrintAsOct(static_cast<U>(v));
228        break;
229      case static_cast<uint8_t>(FormatConversionCharInternal::x):
230        as_digits.PrintAsHexLower(static_cast<U>(v));
231        break;
232      case static_cast<uint8_t>(FormatConversionCharInternal::X):
233        as_digits.PrintAsHexUpper(static_cast<U>(v));
234        break;
235      case static_cast<uint8_t>(FormatConversionCharInternal::u):
236        as_digits.PrintAsDec(static_cast<U>(v));
237        break;
238      case static_cast<uint8_t>(FormatConversionCharInternal::d):
239      case static_cast<uint8_t>(FormatConversionCharInternal::i):
240      case static_cast<uint8_t>(FormatConversionCharInternal::v):
241        as_digits.PrintAsDec(v);
242        break;
243      case static_cast<uint8_t>(FormatConversionCharInternal::a):
244      case static_cast<uint8_t>(FormatConversionCharInternal::e):
245      case static_cast<uint8_t>(FormatConversionCharInternal::f):
246      case static_cast<uint8_t>(FormatConversionCharInternal::g):
247      case static_cast<uint8_t>(FormatConversionCharInternal::A):
248      case static_cast<uint8_t>(FormatConversionCharInternal::E):
249      case static_cast<uint8_t>(FormatConversionCharInternal::F):
250      case static_cast<uint8_t>(FormatConversionCharInternal::G):
251        return ConvertFloatImpl(static_cast<double>(v), conv, sink);
252      default:
253        ABSL_ASSUME(false);
254    }
255    if (conv.is_basic()) {
256      sink->Append(as_digits.with_neg_and_zero());
257      return true;
258    }
259    return ConvertIntImplInnerSlow(as_digits, conv, sink);
260  }
<span onclick='openModal()' class='match'>261  template bool ConvertIntArg<char>(char v, FormatConversionSpecImpl conv,
262                                    FormatSinkImpl *sink);
263  template bool ConvertIntArg<signed char>(signed char v,
264                                           FormatConversionSpecImpl conv,
265                                           FormatSinkImpl *sink);
266  template bool ConvertIntArg<unsigned char>(unsigned char v,
267                                             FormatConversionSpecImpl conv,
268                                             FormatSinkImpl *sink);
269  template bool ConvertIntArg<short>(short v,  
270                                     FormatConversionSpecImpl conv,
271                                     FormatSinkImpl *sink);
272  template bool ConvertIntArg<unsigned short>(unsigned short v,  
273                                              FormatConversionSpecImpl conv,
274                                              FormatSinkImpl *sink);
</span>275  template bool ConvertIntArg<int>(int v, FormatConversionSpecImpl conv,
276                                   FormatSinkImpl *sink);
277  template bool ConvertIntArg<unsigned int>(unsigned int v,
278                                            FormatConversionSpecImpl conv,
279                                            FormatSinkImpl *sink);
280  template bool ConvertIntArg<long>(long v,  
281                                    FormatConversionSpecImpl conv,
282                                    FormatSinkImpl *sink);
283  template bool ConvertIntArg<unsigned long>(unsigned long v,  
284                                             FormatConversionSpecImpl conv,
285                                             FormatSinkImpl *sink);
286  template bool ConvertIntArg<long long>(long long v,  
287                                         FormatConversionSpecImpl conv,
288                                         FormatSinkImpl *sink);
289  template bool ConvertIntArg<unsigned long long>(unsigned long long v,  
290                                                  FormatConversionSpecImpl conv,
291                                                  FormatSinkImpl *sink);
292  StringConvertResult FormatConvertImpl(const std::string &v,
293                                        const FormatConversionSpecImpl conv,
294                                        FormatSinkImpl *sink) {
295    return {ConvertStringArg(v, conv, sink)};
296  }
297  StringConvertResult FormatConvertImpl(string_view v,
298                                        const FormatConversionSpecImpl conv,
299                                        FormatSinkImpl *sink) {
300    return {ConvertStringArg(v, conv, sink)};
301  }
302  ArgConvertResult<FormatConversionCharSetUnion(
303      FormatConversionCharSetInternal::s, FormatConversionCharSetInternal::p)>
304  FormatConvertImpl(const char *v, const FormatConversionSpecImpl conv,
305                    FormatSinkImpl *sink) {
306    if (conv.conversion_char() == FormatConversionCharInternal::p)
307      return {FormatConvertImpl(VoidPtr(v), conv, sink).value};
308    size_t len;
309    if (v == nullptr) {
310      len = 0;
311    } else if (conv.precision() < 0) {
312      len = std::strlen(v);
313    } else {
314      len = static_cast<size_t>(std::find(v, v + conv.precision(), '\0') - v);
315    }
316    return {ConvertStringArg(string_view(v, len), conv, sink)};
317  }
318  ArgConvertResult<FormatConversionCharSetInternal::p> FormatConvertImpl(
319      VoidPtr v, const FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
320    if (!v.value) {
321      sink->Append("(nil)");
322      return {true};
323    }
324    IntDigits as_digits;
325    as_digits.PrintAsHexLower(v.value);
326    return {ConvertIntImplInnerSlow(as_digits, conv, sink)};
327  }
328  FloatingConvertResult FormatConvertImpl(float v,
329                                          const FormatConversionSpecImpl conv,
330                                          FormatSinkImpl *sink) {
331    return {ConvertFloatArg(v, conv, sink)};
332  }
333  FloatingConvertResult FormatConvertImpl(double v,
334                                          const FormatConversionSpecImpl conv,
335                                          FormatSinkImpl *sink) {
336    return {ConvertFloatArg(v, conv, sink)};
337  }
338  FloatingConvertResult FormatConvertImpl(long double v,
339                                          const FormatConversionSpecImpl conv,
340                                          FormatSinkImpl *sink) {
341    return {ConvertFloatArg(v, conv, sink)};
342  }
343  CharConvertResult FormatConvertImpl(char v, const FormatConversionSpecImpl conv,
344                                      FormatSinkImpl *sink) {
345    return {ConvertIntArg(v, conv, sink)};
346  }
347  IntegralConvertResult FormatConvertImpl(signed char v,
348                                          const FormatConversionSpecImpl conv,
349                                          FormatSinkImpl *sink) {
350    return {ConvertIntArg(v, conv, sink)};
351  }
352  IntegralConvertResult FormatConvertImpl(unsigned char v,
353                                          const FormatConversionSpecImpl conv,
354                                          FormatSinkImpl *sink) {
355    return {ConvertIntArg(v, conv, sink)};
356  }
357  IntegralConvertResult FormatConvertImpl(short v,  
358                                          const FormatConversionSpecImpl conv,
359                                          FormatSinkImpl *sink) {
360    return {ConvertIntArg(v, conv, sink)};
361  }
362  IntegralConvertResult FormatConvertImpl(unsigned short v,  
363                                          const FormatConversionSpecImpl conv,
364                                          FormatSinkImpl *sink) {
365    return {ConvertIntArg(v, conv, sink)};
366  }
367  IntegralConvertResult FormatConvertImpl(int v,
368                                          const FormatConversionSpecImpl conv,
369                                          FormatSinkImpl *sink) {
370    return {ConvertIntArg(v, conv, sink)};
371  }
372  IntegralConvertResult FormatConvertImpl(unsigned v,
373                                          const FormatConversionSpecImpl conv,
374                                          FormatSinkImpl *sink) {
375    return {ConvertIntArg(v, conv, sink)};
376  }
377  IntegralConvertResult FormatConvertImpl(long v,  
378                                          const FormatConversionSpecImpl conv,
379                                          FormatSinkImpl *sink) {
380    return {ConvertIntArg(v, conv, sink)};
381  }
382  IntegralConvertResult FormatConvertImpl(unsigned long v,  
383                                          const FormatConversionSpecImpl conv,
384                                          FormatSinkImpl *sink) {
385    return {ConvertIntArg(v, conv, sink)};
386  }
387  IntegralConvertResult FormatConvertImpl(long long v,  
388                                          const FormatConversionSpecImpl conv,
389                                          FormatSinkImpl *sink) {
390    return {ConvertIntArg(v, conv, sink)};
391  }
392  IntegralConvertResult FormatConvertImpl(unsigned long long v,  
393                                          const FormatConversionSpecImpl conv,
394                                          FormatSinkImpl *sink) {
395    return {ConvertIntArg(v, conv, sink)};
396  }
397  IntegralConvertResult FormatConvertImpl(absl::int128 v,
398                                          const FormatConversionSpecImpl conv,
399                                          FormatSinkImpl *sink) {
400    return {ConvertIntArg(v, conv, sink)};
401  }
402  IntegralConvertResult FormatConvertImpl(absl::uint128 v,
403                                          const FormatConversionSpecImpl conv,
404                                          FormatSinkImpl *sink) {
405    return {ConvertIntArg(v, conv, sink)};
406  }
407  ABSL_INTERNAL_FORMAT_DISPATCH_OVERLOADS_EXPAND_();
408  }  
409  ABSL_NAMESPACE_END
410  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaView.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-arg.cc</div>
                </div>
                <div class="column column_space"><pre><code>9  - (void) notification: (SCNotification *) notification;
10  @end
11  @interface SCIScrollView : NSScrollView;
12  @end
13  @interface SCIMarginView : NSRulerView;
14  @end
15  @interface SCIContentView : NSView <
16  	NSTextInputClient,
17  	NSUserInterfaceValidations,
18  	NSDraggingSource,
19  	NSDraggingDestination,
20  	NSAccessibilityStaticText>;
21  - (void) setCursor: (int) cursor; 
22  @end
23  @interface ScintillaView : NSView <InfoBarCommunicator, ScintillaNotificationProtocol>;
24  @property(nonatomic, unsafe_unretained) id<ScintillaNotificationProtocol> delegate;
25  @property(nonatomic, readonly) NSScrollView *scrollView;
</pre></code></div>
                <div class="column column_space"><pre><code>261  template bool ConvertIntArg<char>(char v, FormatConversionSpecImpl conv,
262                                    FormatSinkImpl *sink);
263  template bool ConvertIntArg<signed char>(signed char v,
264                                           FormatConversionSpecImpl conv,
265                                           FormatSinkImpl *sink);
266  template bool ConvertIntArg<unsigned char>(unsigned char v,
267                                             FormatConversionSpecImpl conv,
268                                             FormatSinkImpl *sink);
269  template bool ConvertIntArg<short>(short v,  
270                                     FormatConversionSpecImpl conv,
271                                     FormatSinkImpl *sink);
272  template bool ConvertIntArg<unsigned short>(unsigned short v,  
273                                              FormatConversionSpecImpl conv,
274                                              FormatSinkImpl *sink);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    