
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.490533842528642%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.cpp</h3>
            <pre><code>1  #include <memory>
2  #include <shlwapi.h>
3  #include <cinttypes>
4  #include <windowsx.h>
5  #include "ScintillaEditView.h"
6  #include "Parameters.h"
7  #include "Sorters.h"
8  #include "verifySignedfile.h"
9  #include "ILexer.h"
10  #include "Lexilla.h"
11  using namespace std;
12  bool ScintillaEditView::_SciInit = false;
13  int ScintillaEditView::_refCount = 0;
14  UserDefineDialog ScintillaEditView::_userDefineDlg;
15  const int ScintillaEditView::_SC_MARGE_LINENUMBER = 0;
16  const int ScintillaEditView::_SC_MARGE_SYMBOL = 1;
17  const int ScintillaEditView::_SC_MARGE_CHANGEHISTORY = 2;
18  const int ScintillaEditView::_SC_MARGE_FOLDER = 3;
19  WNDPROC ScintillaEditView::_scintillaDefaultProc = NULL;
20  string ScintillaEditView::_defaultCharList = "";
21  const int ScintillaEditView::_markersArray[][NB_FOLDER_STATE] = {
22    {SC_MARKNUM_FOLDEROPEN, SC_MARKNUM_FOLDER, SC_MARKNUM_FOLDERSUB, SC_MARKNUM_FOLDERTAIL, SC_MARKNUM_FOLDEREND,        SC_MARKNUM_FOLDEROPENMID,     SC_MARKNUM_FOLDERMIDTAIL},
23    {SC_MARK_MINUS,         SC_MARK_PLUS,      SC_MARK_EMPTY,        SC_MARK_EMPTY,         SC_MARK_EMPTY,               SC_MARK_EMPTY,                SC_MARK_EMPTY},
24    {SC_MARK_ARROWDOWN,     SC_MARK_ARROW,     SC_MARK_EMPTY,        SC_MARK_EMPTY,         SC_MARK_EMPTY,               SC_MARK_EMPTY,                SC_MARK_EMPTY},
25    {SC_MARK_CIRCLEMINUS,   SC_MARK_CIRCLEPLUS,SC_MARK_VLINE,        SC_MARK_LCORNERCURVE,  SC_MARK_CIRCLEPLUSCONNECTED, SC_MARK_CIRCLEMINUSCONNECTED, SC_MARK_TCORNERCURVE},
26    {SC_MARK_BOXMINUS,      SC_MARK_BOXPLUS,   SC_MARK_VLINE,        SC_MARK_LCORNER,       SC_MARK_BOXPLUSCONNECTED,    SC_MARK_BOXMINUSCONNECTED,    SC_MARK_TCORNER}
27  };
28  LanguageNameInfo ScintillaEditView::_langNameInfoArray[L_EXTERNAL + 1] = {
29  	{TEXT("normal"),		TEXT("Normal text"),		TEXT("Normal text file"),								L_TEXT,			"null"},
30  	{TEXT("php"),			TEXT("PHP"),				TEXT("PHP Hypertext Preprocessor file"),				L_PHP,			"phpscript"},
31  	{TEXT("c"),				TEXT("C"),					TEXT("C source file"),									L_C,			"cpp"},
32  	{TEXT("cpp"),			TEXT("C++"),				TEXT("C++ source file"),								L_CPP,			"cpp"},
33  	{TEXT("cs"),			TEXT("C#"),					TEXT("C# source file"),									L_CS,			"cpp"},
34  	{TEXT("objc"),			TEXT("Objective-C"),		TEXT("Objective-C source file"),						L_OBJC,			"objc"},
35  	{TEXT("java"),			TEXT("Java"),				TEXT("Java source file"),								L_JAVA,			"cpp"},
36  	{TEXT("rc"),			TEXT("RC"),					TEXT("Windows Resource file"),							L_RC,			"cpp"},
37  	{TEXT("html"),			TEXT("HTML"),				TEXT("Hyper Text Markup Language file"),				L_HTML,			"hypertext"},
38  	{TEXT("xml"),			TEXT("XML"),				TEXT("eXtensible Markup Language file"),				L_XML,			"xml"},
39  	{TEXT("makefile"),		TEXT("Makefile"),			TEXT("Makefile"),										L_MAKEFILE,		"makefile"},
40  	{TEXT("pascal"),		TEXT("Pascal"),				TEXT("Pascal source file"),								L_PASCAL,		"pascal"},
41  	{TEXT("batch"),			TEXT("Batch"),				TEXT("Batch file"),										L_BATCH,		"batch"},
42  	{TEXT("ini"),			TEXT("ini"),				TEXT("MS ini file"),									L_INI,			"props"},
43  	{TEXT("nfo"),			TEXT("NFO"),				TEXT("MSDOS Style/ASCII Art"),							L_ASCII,		"null"},
44  	{TEXT("udf"),			TEXT("udf"),				TEXT("User Defined language file"),						L_USER,			"user"},
45  	{TEXT("asp"),			TEXT("ASP"),				TEXT("Active Server Pages script file"),				L_ASP,			"hypertext"},
46  	{TEXT("sql"),			TEXT("SQL"),				TEXT("Structured Query Language file"),					L_SQL,			"sql"},
47  	{TEXT("vb"),			TEXT("Visual Basic"),		TEXT("Visual Basic file"),								L_VB,			"vb"},
48  	{TEXT("javascript"),	TEXT("JavaScript"),			TEXT("JavaScript file"),								L_JS,			"cpp"},
49  	{TEXT("css"),			TEXT("CSS"),				TEXT("Cascade Style Sheets File"),						L_CSS,			"css"},
50  	{TEXT("perl"),			TEXT("Perl"),				TEXT("Perl source file"),								L_PERL,			"perl"},
51  	{TEXT("python"),		TEXT("Python"),				TEXT("Python file"),									L_PYTHON,		"python"},
52  	{TEXT("lua"),			TEXT("Lua"),				TEXT("Lua source File"),								L_LUA,			"lua"},
53  	{TEXT("tex"),			TEXT("TeX"),				TEXT("TeX file"),										L_TEX,			"tex"},
54  	{TEXT("fortran"),		TEXT("Fortran free form"),	TEXT("Fortran free form source file"),					L_FORTRAN,		"fortran"},
55  	{TEXT("bash"),			TEXT("Shell"),				TEXT("Unix script file"),								L_BASH,			"bash"},
56  	{TEXT("actionscript"),	TEXT("ActionScript"),		TEXT("Flash ActionScript file"),						L_FLASH,		"cpp"},
57  	{TEXT("nsis"),			TEXT("NSIS"),				TEXT("Nullsoft Scriptable Install System script file"),	L_NSIS,			"nsis"},
58  	{TEXT("tcl"),			TEXT("TCL"),				TEXT("Tool Command Language file"),						L_TCL,			"tcl"},
59  	{TEXT("lisp"),			TEXT("Lisp"),				TEXT("List Processing language file"),					L_LISP,			"lisp"},
60  	{TEXT("scheme"),		TEXT("Scheme"),				TEXT("Scheme file"),									L_SCHEME,		"lisp"},
61  	{TEXT("asm"),			TEXT("Assembly"),			TEXT("Assembly language source file"),					L_ASM,			"asm"},
62  	{TEXT("diff"),			TEXT("Diff"),				TEXT("Diff file"),										L_DIFF,			"diff"},
63  	{TEXT("props"),			TEXT("Properties file"),	TEXT("Properties file"),								L_PROPS,		"props"},
64  	{TEXT("postscript"),	TEXT("PostScript"),			TEXT("PostScript file"),								L_PS,			"ps"},
65  	{TEXT("ruby"),			TEXT("Ruby"),				TEXT("Ruby file"),										L_RUBY,			"ruby"},
66  	{TEXT("smalltalk"),		TEXT("Smalltalk"),			TEXT("Smalltalk file"),									L_SMALLTALK,	"smalltalk"},
67  	{TEXT("vhdl"),			TEXT("VHDL"),				TEXT("VHSIC Hardware Description Language file"),		L_VHDL,			"vhdl"},
68  	{TEXT("kix"),			TEXT("KiXtart"),			TEXT("KiXtart file"),									L_KIX,			"kix"},
69  	{TEXT("autoit"),		TEXT("AutoIt"),				TEXT("AutoIt"),											L_AU3,			"au3"},
70  	{TEXT("caml"),			TEXT("CAML"),				TEXT("Categorical Abstract Machine Language"),			L_CAML,			"caml"},
71  	{TEXT("ada"),			TEXT("Ada"),				TEXT("Ada file"),										L_ADA,			"ada"},
72  	{TEXT("verilog"),		TEXT("Verilog"),			TEXT("Verilog file"),									L_VERILOG,		"verilog"},
73  	{TEXT("matlab"),		TEXT("MATLAB"),				TEXT("MATrix LABoratory"),								L_MATLAB,		"matlab"},
74  	{TEXT("haskell"),		TEXT("Haskell"),			TEXT("Haskell"),										L_HASKELL,		"haskell"},
75  	{TEXT("inno"),			TEXT("Inno Setup"),			TEXT("Inno Setup script"),								L_INNO,			"inno"},
76  	{TEXT("searchResult"),	TEXT("Internal Search"),	TEXT("Internal Search"),								L_SEARCHRESULT,	"searchResult"},
77  	{TEXT("cmake"),			TEXT("CMake"),				TEXT("CMake file"),										L_CMAKE,		"cmake"},
78  	{TEXT("yaml"),			TEXT("YAML"),				TEXT("YAML Ain't Markup Language"),						L_YAML,			"yaml"},
79  	{TEXT("cobol"),			TEXT("COBOL"),				TEXT("COmmon Business Oriented Language"),				L_COBOL,		"COBOL"},
80  	{TEXT("gui4cli"),		TEXT("Gui4Cli"),			TEXT("Gui4Cli file"),									L_GUI4CLI,		"gui4cli"},
81  	{TEXT("d"),				TEXT("D"),					TEXT("D programming language"),							L_D,			"d"},
82  	{TEXT("powershell"),	TEXT("PowerShell"),			TEXT("Windows PowerShell"),								L_POWERSHELL,	"powershell"},
83  	{TEXT("r"),				TEXT("R"),					TEXT("R programming language"),							L_R,			"r"},
84  	{TEXT("jsp"),			TEXT("JSP"),				TEXT("JavaServer Pages script file"),					L_JSP,			"hypertext"},
85  	{TEXT("coffeescript"),	TEXT("CoffeeScript"),		TEXT("CoffeeScript file"),								L_COFFEESCRIPT,	"coffeescript"},
86  	{TEXT("json"),			TEXT("json"),				TEXT("JSON file"),										L_JSON,			"json"},
87  	{TEXT("javascript.js"), TEXT("JavaScript"),			TEXT("JavaScript file"),								L_JAVASCRIPT,	"cpp"},
88  	{TEXT("fortran77"),		TEXT("Fortran fixed form"),	TEXT("Fortran fixed form source file"),					L_FORTRAN_77,	"f77"},
89  	{TEXT("baanc"),			TEXT("BaanC"),				TEXT("BaanC File"),										L_BAANC,		"baan"},
90  	{TEXT("srec"),			TEXT("S-Record"),			TEXT("Motorola S-Record binary data"),					L_SREC,			"srec"},
91  	{TEXT("ihex"),			TEXT("Intel HEX"),			TEXT("Intel HEX binary data"),							L_IHEX,			"ihex"},
92  	{TEXT("tehex"),			TEXT("Tektronix extended HEX"),	TEXT("Tektronix extended HEX binary data"),			L_TEHEX,		"tehex"},
93  	{TEXT("swift"),			TEXT("Swift"),              TEXT("Swift file"),										L_SWIFT,		"cpp"},
94  	{TEXT("asn1"),			TEXT("ASN.1"),				TEXT("Abstract Syntax Notation One file"),				L_ASN1,			"asn1"},
95  	{TEXT("avs"),			TEXT("AviSynth"),			TEXT("AviSynth scripts files"),							L_AVS,			"avs"},
96  	{TEXT("blitzbasic"),	TEXT("BlitzBasic"),			TEXT("BlitzBasic file"),								L_BLITZBASIC,	"blitzbasic"},
97  	{TEXT("purebasic"),		TEXT("PureBasic"),			TEXT("PureBasic file"),									L_PUREBASIC,	"purebasic"},
98  	{TEXT("freebasic"),		TEXT("FreeBasic"),			TEXT("FreeBasic file"),									L_FREEBASIC,	"freebasic"},
99  	{TEXT("csound"),		TEXT("Csound"),				TEXT("Csound file"),									L_CSOUND,		"csound"},
100  	{TEXT("erlang"),		TEXT("Erlang"),				TEXT("Erlang file"),									L_ERLANG,		"erlang"},
101  	{TEXT("escript"),		TEXT("ESCRIPT"),			TEXT("ESCRIPT file"),									L_ESCRIPT,		"escript"},
102  	{TEXT("forth"),			TEXT("Forth"),				TEXT("Forth file"),										L_FORTH,		"forth"},
103  	{TEXT("latex"),			TEXT("LaTeX"),				TEXT("LaTeX file"),										L_LATEX,		"latex"},
104  	{TEXT("mmixal"),		TEXT("MMIXAL"),				TEXT("MMIXAL file"),									L_MMIXAL,		"mmixal"},
105  	{TEXT("nim"),			TEXT("Nim"),				TEXT("Nim file"),										L_NIM,			"nimrod"},
106  	{TEXT("nncrontab"),		TEXT("Nncrontab"),			TEXT("extended crontab file"),							L_NNCRONTAB,	"nncrontab"},
107  	{TEXT("oscript"),		TEXT("OScript"),			TEXT("OScript source file"),							L_OSCRIPT,		"oscript"},
108  	{TEXT("rebol"),			TEXT("REBOL"),				TEXT("REBOL file"),										L_REBOL,		"rebol"},
109  	{TEXT("registry"),		TEXT("registry"),			TEXT("registry file"),									L_REGISTRY,		"registry"},
110  	{TEXT("rust"),			TEXT("Rust"),				TEXT("Rust file"),										L_RUST,			"rust"},
111  	{TEXT("spice"),			TEXT("Spice"),				TEXT("spice file"),										L_SPICE,		"spice"},
112  	{TEXT("txt2tags"),		TEXT("txt2tags"),			TEXT("txt2tags file"),									L_TXT2TAGS,		"txt2tags"},
113  	{TEXT("visualprolog"),	TEXT("Visual Prolog"),		TEXT("Visual Prolog file"),								L_VISUALPROLOG,	"visualprolog"},
114  	{TEXT("typescript"),	TEXT("TypeScript"),			TEXT("TypeScript file"),								L_TYPESCRIPT,	"cpp"},
115  	{TEXT("json5"),			TEXT("json5"),				TEXT("JSON5 file"),										L_JSON5,		"json"},
116  	{TEXT("mssql"),			TEXT("mssql"),				TEXT("Microsoft Transact-SQL (SQL Server) file"),		L_MSSQL,		"mssql"},
117  	{TEXT("gdscript"),		TEXT("GDScript"),			TEXT("GDScript file"),									L_GDSCRIPT,		"gdscript"},
118  	{TEXT("hollywood"),		TEXT("Hollywood"),			TEXT("Hollywood script"),								L_HOLLYWOOD,	"hollywood"},
119  	{TEXT("ext"),			TEXT("External"),			TEXT("External"),										L_EXTERNAL,		"null"}
120  };
121  int getNbDigits(int aNum, int base)
122  {
123  	int nbChiffre = 1;
124  	int diviseur = base;
125  	for (;;)
126  	{
127  		int result = aNum / diviseur;
128  		if (!result)
129  			break;
130  		else
131  		{
132  			diviseur *= base;
133  			++nbChiffre;
134  		}
135  	}
136  	if ((base == 16) && (nbChiffre % 2 != 0))
137  		nbChiffre += 1;
138  	return nbChiffre;
139  }
140  void ScintillaEditView::init(HINSTANCE hInst, HWND hPere)
141  {
142  	if (!_SciInit)
143  	{
144  		if (!Scintilla_RegisterClasses(hInst))
145  		{
146  			throw std::runtime_error("ScintillaEditView::init : SCINTILLA ERROR - Scintilla_RegisterClasses failed");
147  		}
148  		_SciInit = true;
149  	}
150  	Window::init(hInst, hPere);
151  	_hSelf = ::CreateWindowEx(
152  					0,\
153  					TEXT("Scintilla"),\
154  					TEXT("Notepad++"),\
155  					WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_CLIPCHILDREN | WS_EX_RTLREADING,\
156  					0, 0, 100, 100,\
157  					_hParent,\
158  					NULL,\
159  					_hInst,\
160  					NULL);
161  	if (!_hSelf)
162  	{
163  		throw std::runtime_error("ScintillaEditView::init : CreateWindowEx() function return null");
164  	}
165  	NppDarkMode::setDarkScrollBar(_hSelf);
166  	_pScintillaFunc = (SCINTILLA_FUNC)::SendMessage(_hSelf, SCI_GETDIRECTFUNCTION, 0, 0);
167  	_pScintillaPtr = (SCINTILLA_PTR)::SendMessage(_hSelf, SCI_GETDIRECTPOINTER, 0, 0);
168  	_userDefineDlg.init(_hInst, _hParent, this);
169  	if (!_pScintillaFunc)
170  	{
171  		throw std::runtime_error("ScintillaEditView::init : SCI_GETDIRECTFUNCTION message failed");
172  	}
173  	if (!_pScintillaPtr)
174  	{
175  		throw std::runtime_error("ScintillaEditView::init : SCI_GETDIRECTPOINTER message failed");
176  	}
177  	execute(SCI_SETMARGINMASKN, _SC_MARGE_FOLDER, SC_MASK_FOLDERS);
178  	showMargin(_SC_MARGE_FOLDER, true);
179  	execute(SCI_SETMARGINMASKN, _SC_MARGE_SYMBOL, (1 << MARK_BOOKMARK) | (1 << MARK_HIDELINESBEGIN) | (1 << MARK_HIDELINESEND));
180  	execute(SCI_SETMARGINMASKN, _SC_MARGE_CHANGEHISTORY, (1 << SC_MARKNUM_HISTORY_REVERTED_TO_ORIGIN) | (1 << SC_MARKNUM_HISTORY_SAVED) | (1 << SC_MARKNUM_HISTORY_MODIFIED) | (1 << SC_MARKNUM_HISTORY_REVERTED_TO_MODIFIED));
181  	COLORREF modifiedColor = RGB(255, 128, 0);
182  	execute(SCI_MARKERSETBACK, SC_MARKNUM_HISTORY_MODIFIED, modifiedColor);
183  	execute(SCI_MARKERSETALPHA, MARK_BOOKMARK, 70);
184  	const COLORREF hiddenLinesGreen = RGB(0x77, 0xCC, 0x77);
185  	long hiddenLinesGreenWithAlpha = hiddenLinesGreen | 0xFF000000;
186  	execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_HIDDEN_LINE, hiddenLinesGreenWithAlpha);
187  	if (NppParameters::getInstance()._dpiManager.scaleX(100) >= 150)
188  	{
189  		execute(SCI_RGBAIMAGESETWIDTH, 18);
190  		execute(SCI_RGBAIMAGESETHEIGHT, 18);
191  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_BOOKMARK, reinterpret_cast<LPARAM>(bookmark18));
192  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESBEGIN, reinterpret_cast<LPARAM>(hidelines_begin18));
193  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESEND, reinterpret_cast<LPARAM>(hidelines_end18));
194  	}
195  	else
196  	{
197  		execute(SCI_RGBAIMAGESETWIDTH, 14);
198  		execute(SCI_RGBAIMAGESETHEIGHT, 14);
199  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_BOOKMARK, reinterpret_cast<LPARAM>(bookmark14));
200  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESBEGIN, reinterpret_cast<LPARAM>(hidelines_begin14));
201  		execute(SCI_MARKERDEFINERGBAIMAGE, MARK_HIDELINESEND, reinterpret_cast<LPARAM>(hidelines_end14));
202  	}
203      execute(SCI_SETMARGINSENSITIVEN, _SC_MARGE_FOLDER, true); 
204      execute(SCI_SETMARGINSENSITIVEN, _SC_MARGE_SYMBOL, true); 
205      execute(SCI_SETFOLDFLAGS, SC_FOLDFLAG_LINEAFTER_CONTRACTED);
206  	execute(SCI_SETSCROLLWIDTHTRACKING, true);
207  	execute(SCI_SETSCROLLWIDTH, 1);	
208  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_SMART, INDIC_ROUNDBOX);
209  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE, INDIC_ROUNDBOX);
210  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_INC, INDIC_ROUNDBOX);
211  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_TAGMATCH, INDIC_ROUNDBOX);
212  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_TAGATTR, INDIC_ROUNDBOX);
213  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT1, INDIC_ROUNDBOX);
214  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT2, INDIC_ROUNDBOX);
215  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT3, INDIC_ROUNDBOX);
216  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT4, INDIC_ROUNDBOX);
217  	execute(SCI_INDICSETSTYLE, SCE_UNIVERSAL_FOUND_STYLE_EXT5, INDIC_ROUNDBOX);
218  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_SMART, 100);
219  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE, 100);
220  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_INC, 100);
221  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_TAGMATCH, 100);
222  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_TAGATTR, 100);
223  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT1, 100);
224  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT2, 100);
225  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT3, 100);
226  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT4, 100);
227  	execute(SCI_INDICSETALPHA, SCE_UNIVERSAL_FOUND_STYLE_EXT5, 100);
228  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_SMART, true);
229  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE, true);
230  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_INC, true);
231  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_TAGMATCH, true);
232  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_TAGATTR, true);
233  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT1, true);
234  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT2, true);
235  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT3, true);
236  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT4, true);
237  	execute(SCI_INDICSETUNDER, SCE_UNIVERSAL_FOUND_STYLE_EXT5, true);
238  	if ((NppParameters::getInstance()).getNppGUI()._writeTechnologyEngine == directWriteTechnology)
239  		execute(SCI_SETTECHNOLOGY, SC_TECHNOLOGY_DIRECTWRITE);
240  	_codepage = ::GetACP();
241  	::SetWindowLongPtr(_hSelf, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
242  	_callWindowProc = CallWindowProc;
243  	_scintillaDefaultProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSelf, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(scintillaStatic_Proc)));
244  	if (_defaultCharList.empty())
245  	{
246  		auto defaultCharListLen = execute(SCI_GETWORDCHARS);
247  		char *defaultCharList = new char[defaultCharListLen + 1];
248  		execute(SCI_GETWORDCHARS, 0, reinterpret_cast<LPARAM>(defaultCharList));
249  		defaultCharList[defaultCharListLen] = '\0';
250  		_defaultCharList = defaultCharList;
251  		delete[] defaultCharList;
252  	}
253  	attachDefaultDoc();
254  }
255  LRESULT CALLBACK ScintillaEditView::scintillaStatic_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
256  {
257  	ScintillaEditView *pScint = (ScintillaEditView *)(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
258  	if (Message == WM_MOUSEWHEEL || Message == WM_MOUSEHWHEEL)
259  	{
260  		POINT pt{};
261  		POINTS pts = MAKEPOINTS(lParam);
262  		POINTSTOPOINT(pt, pts);
263  		HWND hwndOnMouse = WindowFromPoint(pt);
264  		char synapticsHack[26]{};
265  		GetClassNameA(hwndOnMouse, (LPSTR)&synapticsHack, 26);
266  		bool isSynpnatic = std::string(synapticsHack) == "SynTrackCursorWindowClass";
267  		bool makeTouchPadCompetible = ((NppParameters::getInstance()).getSVP())._disableAdvancedScrolling;
268  		if (pScint && (isSynpnatic || makeTouchPadCompetible))
269  			return (pScint->scintillaNew_Proc(hwnd, Message, wParam, lParam));
270  		ScintillaEditView *pScintillaOnMouse = (ScintillaEditView *)(::GetWindowLongPtr(hwndOnMouse, GWLP_USERDATA));
271  		if (pScintillaOnMouse != pScint)
272  			return ::SendMessage(hwndOnMouse, Message, wParam, lParam);
273  	}
274  	if (pScint)
275  		return (pScint->scintillaNew_Proc(hwnd, Message, wParam, lParam));
276  	else
277  		return ::DefWindowProc(hwnd, Message, wParam, lParam);
278  }
279  LRESULT ScintillaEditView::scintillaNew_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
280  {
281  	switch (Message)
282  	{
283  		case NPPM_INTERNAL_REFRESHDARKMODE:
284  		{
285  			NppDarkMode::setDarkScrollBar(_hSelf);
286  			return TRUE;
287  		}
288  		case WM_MOUSEHWHEEL :
289  		{
290  			::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) > 0)?SB_LINERIGHT:SB_LINELEFT, 0);
291  			return TRUE;
292  		}
293  		case WM_MOUSEWHEEL :
294  		{
295  			if (LOWORD(wParam) & MK_RBUTTON)
296  			{
297  				::SendMessage(_hParent, Message, wParam, lParam);
298  				return TRUE;
299  			}
300  			if (LOWORD(wParam) & MK_SHIFT)
301  			{
302  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) < 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
303  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) < 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
304  				::CallWindowProc(_scintillaDefaultProc, hwnd, WM_HSCROLL, ((short)HIWORD(wParam) < 0) ? SB_LINERIGHT : SB_LINELEFT, 0);
305  				return TRUE;
306  			}
307  			LRESULT scrollResult = ::CallWindowProc(_scintillaDefaultProc, hwnd, Message, wParam, lParam);
308  			return scrollResult;
309  		}
310  		case WM_IME_REQUEST:
311  		{
312  			if (wParam == IMR_RECONVERTSTRING)
313  			{
314  				intptr_t					textLength = 0;
315  				intptr_t					selectSize = 0;
316  				char				smallTextBuffer[128] = { '\0' };
317  				char			  *	selectedStr = smallTextBuffer;
318  				RECONVERTSTRING   *	reconvert = (RECONVERTSTRING *)lParam;
319  				if (execute(SCI_SELECTIONISRECTANGLE, 0, 0))
320  					return 0;
321  				size_t cp = execute(SCI_GETCODEPAGE);
322  				UINT codepage = static_cast<UINT>(cp);
323  				Sci_CharacterRangeFull range = getSelection();
324  				if (range.cpMax == range.cpMin)
325  				{
326  					expandWordSelection();
327  					range = getSelection();
328  				}
329  				selectSize = range.cpMax - range.cpMin;
330  				if (selectSize == 0)
331  					return 0;
332  				if (static_cast<size_t>(selectSize + 1) > sizeof(smallTextBuffer))
333  					selectedStr = new char[selectSize + 1];
334  				getText(selectedStr, range.cpMin, range.cpMax);
335  				if (reconvert == NULL)
336  				{
337  					textLength = sizeof(WCHAR) * ::MultiByteToWideChar(codepage, 0, selectedStr, (int)selectSize, NULL, 0);
338  				}
339  				else
340  				{
341  					textLength = ::MultiByteToWideChar(	codepage, 0,
342  														selectedStr, (int)selectSize,
343  														(LPWSTR)((LPSTR)reconvert + sizeof(RECONVERTSTRING)),
344  														static_cast<int>(reconvert->dwSize - sizeof(RECONVERTSTRING)));
345  					reconvert->dwVersion		 = 0;
346  					reconvert->dwStrLen			 = static_cast<DWORD>(textLength);
347  					reconvert->dwStrOffset		 = sizeof(RECONVERTSTRING);
348  					reconvert->dwCompStrLen		 = static_cast<DWORD>(textLength);
349  					reconvert->dwCompStrOffset	 = 0;
350  					reconvert->dwTargetStrLen	 = reconvert->dwCompStrLen;
351  					reconvert->dwTargetStrOffset = reconvert->dwCompStrOffset;
352  					textLength *= sizeof(WCHAR);
353  				}
354  				if (selectedStr != smallTextBuffer)
355  					delete [] selectedStr;
356  				return sizeof(RECONVERTSTRING) + textLength;
357  			}
358  			break;
359  		}
360  		case WM_KEYUP :
361  		{
362  			if (wParam == VK_PRIOR || wParam == VK_NEXT)
363  			{
364  				SCNotification notification = {};
365  				notification.nmhdr.code = SCN_PAINTED;
366  				notification.nmhdr.hwndFrom = _hSelf;
367  				notification.nmhdr.idFrom = ::GetDlgCtrlID(_hSelf);
368  				::SendMessage(_hParent, WM_NOTIFY, LINKTRIGGERED, reinterpret_cast<LPARAM>(&notification));
369  			}
370  			break;
371  		}
372  		case WM_VSCROLL :
373  		{
374  			break;
375  		}
376  		case WM_RBUTTONDOWN:
377  		{
378  			bool rightClickKeepsSelection = ((NppParameters::getInstance()).getSVP())._rightClickKeepsSelection;
379  			if (rightClickKeepsSelection)
380  			{
381  				size_t clickX = GET_X_LPARAM(lParam);
382  				size_t marginX = execute(SCI_POINTXFROMPOSITION, 0, 0);
383  				if (clickX >= marginX)
384  				{
385  					return TRUE;
386  				}
387  			}
388  			break;
389  		}
390  	}
391  	return _callWindowProc(_scintillaDefaultProc, hwnd, Message, wParam, lParam);
392  }
393  #define DEFAULT_FONT_NAME "Courier New"
394  void ScintillaEditView::setSpecialStyle(const Style & styleToSet)
395  {
396  	int styleID = styleToSet._styleID;
397  	if ( styleToSet._colorStyle & COLORSTYLE_FOREGROUND )
398  	    execute(SCI_STYLESETFORE, styleID, styleToSet._fgColor);
399      if ( styleToSet._colorStyle & COLORSTYLE_BACKGROUND )
400  	    execute(SCI_STYLESETBACK, styleID, styleToSet._bgColor);
401      if (!styleToSet._fontName.empty())
402  	{
403  		if (!NppParameters::getInstance().isInFontList(styleToSet._fontName))
404  		{
405  			execute(SCI_STYLESETFONT, styleID, reinterpret_cast<LPARAM>(DEFAULT_FONT_NAME));
406  		}
407  		else
408  		{
409  			std::string fontNameA = wstring2string(styleToSet._fontName, CP_UTF8);
410  			execute(SCI_STYLESETFONT, styleID, reinterpret_cast<LPARAM>(fontNameA.c_str()));
411  		}
412  	}
413  	int fontStyle = styleToSet._fontStyle;
414      if (fontStyle != STYLE_NOT_USED)
415      {
416          execute(SCI_STYLESETBOLD,		styleID, fontStyle & FONTSTYLE_BOLD);
417          execute(SCI_STYLESETITALIC,		styleID, fontStyle & FONTSTYLE_ITALIC);
418          execute(SCI_STYLESETUNDERLINE,	styleID, fontStyle & FONTSTYLE_UNDERLINE);
419      }
420  	if (styleToSet._fontSize > 0)
421  		execute(SCI_STYLESETSIZE, styleID, styleToSet._fontSize);
422  }
423  void ScintillaEditView::setHotspotStyle(const Style& styleToSet)
424  {
425  	StyleMap* styleMap;
426  	if ( _hotspotStyles.find(_currentBuffer) == _hotspotStyles.end() )
427  	{
428  		_hotspotStyles[_currentBuffer] = new StyleMap;
429  	}
430  	styleMap = _hotspotStyles[_currentBuffer];
431  	(*styleMap)[styleToSet._styleID] = styleToSet;
432  	setStyle(styleToSet);
433  }
434  void ScintillaEditView::setStyle(Style styleToSet)
435  {
436  	GlobalOverride & go = NppParameters::getInstance().getGlobalOverrideStyle();
437  	if (go.isEnable())
438  	{
439  		const Style * pStyle = NppParameters::getInstance().getMiscStylerArray().findByName(TEXT("Global override"));
440  		if (pStyle)
441  		{
442  			if (go.enableFg)
443  			{
444  				if (pStyle->_colorStyle & COLORSTYLE_FOREGROUND)
445  				{
446  					styleToSet._colorStyle |= COLORSTYLE_FOREGROUND;
447  					styleToSet._fgColor = pStyle->_fgColor;
448  				}
449  				else
450  				{
451  					if (styleToSet._styleID == STYLE_DEFAULT) 
452  						styleToSet._colorStyle |= COLORSTYLE_FOREGROUND;
453  					else
454  						styleToSet._colorStyle &= ~COLORSTYLE_FOREGROUND;
455  				}
456  			}
457  			if (go.enableBg)
458  			{
459  				if (pStyle->_colorStyle & COLORSTYLE_BACKGROUND)
460  				{
461  					styleToSet._colorStyle |= COLORSTYLE_BACKGROUND;
462  					styleToSet._bgColor = pStyle->_bgColor;
463  				}
464  				else
465  				{
466  					if (styleToSet._styleID == STYLE_DEFAULT) 	
467  						styleToSet._colorStyle |= COLORSTYLE_BACKGROUND;
468  					else
469  						styleToSet._colorStyle &= ~COLORSTYLE_BACKGROUND;
470  				}
471  			}
472  			if (go.enableFont && !pStyle->_fontName.empty())
473  				styleToSet._fontName = pStyle->_fontName;
474  			if (go.enableFontSize && (pStyle->_fontSize > 0))
475  				styleToSet._fontSize = pStyle->_fontSize;
476  			if (pStyle->_fontStyle != STYLE_NOT_USED)
477  			{
478  				if (go.enableBold)
479  				{
480  					if (pStyle->_fontStyle & FONTSTYLE_BOLD)
481  						styleToSet._fontStyle |= FONTSTYLE_BOLD;
482  					else
483  						styleToSet._fontStyle &= ~FONTSTYLE_BOLD;
484  				}
485  				if (go.enableItalic)
486  				{
487  					if (pStyle->_fontStyle & FONTSTYLE_ITALIC)
488  						styleToSet._fontStyle |= FONTSTYLE_ITALIC;
489  					else
490  						styleToSet._fontStyle &= ~FONTSTYLE_ITALIC;
491  				}
492  				if (go.enableUnderLine)
493  				{
494  					if (pStyle->_fontStyle & FONTSTYLE_UNDERLINE)
495  						styleToSet._fontStyle |= FONTSTYLE_UNDERLINE;
496  					else
497  						styleToSet._fontStyle &= ~FONTSTYLE_UNDERLINE;
498  				}
499  			}
500  		}
501  	}
502  	setSpecialStyle(styleToSet);
503  }
504  void ScintillaEditView::setXmlLexer(LangType type)
505  {
506  	if (type == L_XML)
507  	{
508  		setLexerFromLangID(L_XML);
509  		for (int i = 0 ; i < 4 ; ++i)
510  			execute(SCI_SETKEYWORDS, i, reinterpret_cast<LPARAM>(TEXT("")));
511          makeStyle(type);
512  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.xml.allow.scripts"), reinterpret_cast<LPARAM>("0"));
513  	}
514  	else if ((type == L_HTML) || (type == L_PHP) || (type == L_ASP) || (type == L_JSP))
515  	{
516  		setLexerFromLangID(L_HTML);
517  		const TCHAR *htmlKeyWords_generic = NppParameters::getInstance().getWordList(L_HTML, LANG_INDEX_INSTR);
518  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
519  		const char *htmlKeyWords = wmc.wchar2char(htmlKeyWords_generic, CP_ACP);
520  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(htmlKeyWords?htmlKeyWords:""));
521  		makeStyle(L_HTML);
522          setEmbeddedJSLexer();
523          setEmbeddedPhpLexer();
524  		setEmbeddedAspLexer();
525  	}
526  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
527  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
528  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.html"), reinterpret_cast<LPARAM>("1"));
529  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.hypertext.comment"), reinterpret_cast<LPARAM>("1"));
530  }
531  void ScintillaEditView::setEmbeddedJSLexer()
532  {
533  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
534  	makeStyle(L_JS, pKwArray);
535  	basic_string<char> keywordList("");
536  	if (pKwArray[LANG_INDEX_INSTR])
537  	{
538  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
539  		keywordList = wstring2string(kwlW, CP_ACP);
540  	}
541  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, L_JS, LANG_INDEX_INSTR)));
542  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_DEFAULT, true);
543  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_COMMENT, true);
544  	execute(SCI_STYLESETEOLFILLED, SCE_HJ_COMMENTDOC, true);
545  }
546  void ScintillaEditView::setJsonLexer(bool isJson5)
547  {
548  	LangType j = isJson5 ? L_JSON5 : L_JSON;
549  	setLexerFromLangID(j);
550  	const TCHAR *pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
551  	makeStyle(L_JSON, pKwArray);
552  	string keywordList;
553  	string keywordList2;
554  	if (pKwArray[LANG_INDEX_INSTR])
555  	{
556  		wstring kwlW = pKwArray[LANG_INDEX_INSTR];
557  		keywordList = wstring2string(kwlW, CP_ACP);
558  	}
559  	if (pKwArray[LANG_INDEX_INSTR2])
560  	{
561  		wstring kwlW = pKwArray[LANG_INDEX_INSTR2];
562  		keywordList2 = wstring2string(kwlW, CP_ACP);
563  	}
564  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, j, LANG_INDEX_INSTR)));
565  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList2, j, LANG_INDEX_INSTR2)));
566  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
567  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
568  	if (j == L_JSON5)
569  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.json.allow.comments"), reinterpret_cast<LPARAM>("1"));
570  }
571  void ScintillaEditView::setEmbeddedPhpLexer()
572  {
573  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
574  	makeStyle(L_PHP, pKwArray);
575  	basic_string<char> keywordList("");
576  	if (pKwArray[LANG_INDEX_INSTR])
577  	{
578  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
579  		keywordList = wstring2string(kwlW, CP_ACP);
580  	}
581  	execute(SCI_SETKEYWORDS, 4, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, L_PHP, LANG_INDEX_INSTR)));
582  	execute(SCI_STYLESETEOLFILLED, SCE_HPHP_DEFAULT, true);
583  	execute(SCI_STYLESETEOLFILLED, SCE_HPHP_COMMENT, true);
584  }
585  void ScintillaEditView::setEmbeddedAspLexer()
586  {
587  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
588  	makeStyle(L_ASP, pKwArray);
589  	basic_string<char> keywordList("");
590  	if (pKwArray[LANG_INDEX_INSTR])
591  	{
592  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
593  		keywordList = wstring2string(kwlW, CP_ACP);
594  	}
595  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("asp.default.language"), reinterpret_cast<LPARAM>("2"));
596  	execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, L_VB, LANG_INDEX_INSTR)));
597      execute(SCI_STYLESETEOLFILLED, SCE_HBA_DEFAULT, true);
598  }
599  void ScintillaEditView::setUserLexer(const TCHAR *userLangName)
600  {
601  	int setKeywordsCounter = 0;
602  	setLexerFromLangID(L_USER);
603  	UserLangContainer * userLangContainer = userLangName? NppParameters::getInstance().getULCFromName(userLangName):_userDefineDlg._pCurrentUserLang;
604  	if (!userLangContainer)
<span onclick='openModal()' class='match'>605  		return;
606  	UINT codepage = CP_ACP;
607  	UniMode unicodeMode = _currentBuffer->getUnicodeMode();
608  	int encoding = _currentBuffer->getEncoding();
</span>609  	if (encoding == -1)
610  	{
611  		if (unicodeMode == uniUTF8 || unicodeMode == uniCookie)
612  			codepage = CP_UTF8;
613  	}
614  	else
615  	{
616  		codepage = CP_OEMCP;	
617  	}
618  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
619  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.isCaseIgnored"),		  reinterpret_cast<LPARAM>(userLangContainer->_isCaseIgnored ? "1":"0"));
620  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.allowFoldOfComments"),  reinterpret_cast<LPARAM>(userLangContainer->_allowFoldOfComments ? "1":"0"));
621  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.foldCompact"),		  reinterpret_cast<LPARAM>(userLangContainer->_foldCompact ? "1":"0"));
622      char name[] = "userDefine.prefixKeywords0";
623  	for (int i=0 ; i<SCE_USER_TOTAL_KEYWORD_GROUPS ; ++i)
624  	{
625  		itoa(i+1, (name+25), 10);
626  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>(name), reinterpret_cast<LPARAM>(userLangContainer->_isPrefix[i] ? "1" : "0"));
627  	}
628  	char* temp = new char[max_char];
629  	for (int i = 0 ; i < SCE_USER_KWLIST_TOTAL ; ++i)
630  	{
631  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
632  		const char * keyWords_char = wmc.wchar2char(userLangContainer->_keywordLists[i], codepage);
633  		if (globalMappper().setLexerMapper.find(i) != globalMappper().setLexerMapper.end())
634  		{
635  			execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>(globalMappper().setLexerMapper[i].c_str()), reinterpret_cast<LPARAM>(keyWords_char));
636  		}
637  		else 
638  		{
639  			bool inDoubleQuote = false;
640  			bool inSingleQuote = false;
641  			bool nonWSFound = false;
642  			int index = 0;
643  			for (size_t j=0, len = strlen(keyWords_char); j<len && index < (max_char-1); ++j)
644  			{
645  				if (!inSingleQuote && keyWords_char[j] == '"')
646  				{
647  					inDoubleQuote = !inDoubleQuote;
648  					continue;
649  				}
650  				if (!inDoubleQuote && keyWords_char[j] == '\'')
651  				{
652  					inSingleQuote = !inSingleQuote;
653  					continue;
654  				}
655  				if (keyWords_char[j] == '\\' && (keyWords_char[j+1] == '"' || keyWords_char[j+1] == '\'' || keyWords_char[j+1] == '\\'))
656  				{
657  					++j;
658  					temp[index++] = keyWords_char[j];
659  					continue;
660  				}
661  				if (inDoubleQuote || inSingleQuote)
662  				{
663  					if (keyWords_char[j] > ' ')		
664  					{
665  						temp[index++] = keyWords_char[j];
666  						if (nonWSFound == false)
667  							nonWSFound = true;
668  					}
669  					else if (nonWSFound == true && keyWords_char[j-1] != '"' && keyWords_char[j+1] != '"' && keyWords_char[j+1] > ' ')
670  					{
671  						temp[index++] = inDoubleQuote ? '\v' : '\b';
672  					}
673  					else
674  						continue;
675  				}
676  				else
677  				{
678  					temp[index++] = keyWords_char[j];
679  				}
680  			}
681  			temp[index++] = 0;
682  			execute(SCI_SETKEYWORDS, setKeywordsCounter++, reinterpret_cast<LPARAM>(temp));
683  		}
684  	}
685  	delete[] temp;
686   	char intBuffer[32];
687  	sprintf(intBuffer, "%d", userLangContainer->_forcePureLC);
688  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.forcePureLC"), reinterpret_cast<LPARAM>(intBuffer));
689  	sprintf(intBuffer, "%d", userLangContainer->_decimalSeparator);
690  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.decimalSeparator"), reinterpret_cast<LPARAM>(intBuffer));
691  	sprintf(intBuffer, "%" PRIuPTR, reinterpret_cast<uintptr_t>(userLangContainer->getName())); 
692  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.udlName"), reinterpret_cast<LPARAM>(intBuffer));
693  	sprintf(intBuffer, "%" PRIuPTR, reinterpret_cast<uintptr_t>(_currentBufferID)); 
694      execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("userDefine.currentBufferID"), reinterpret_cast<LPARAM>(intBuffer));
695  	for (const Style & style : userLangContainer->_styles)
696  	{
697  		if (style._styleID == STYLE_NOT_USED)
698  			continue;
699  		char nestingBuffer[32];
700  		sprintf(nestingBuffer, "userDefine.nesting.%02d", style._styleID);
701  		sprintf(intBuffer, "%d", style._nesting);
702  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>(nestingBuffer), reinterpret_cast<LPARAM>(intBuffer));
703  		setStyle(style);
704  	}
705  }
706  void ScintillaEditView::setExternalLexer(LangType typeDoc)
707  {
708  	int id = typeDoc - L_EXTERNAL;
709  	ExternalLangContainer& externalLexer = NppParameters::getInstance().getELCFromIndex(id);
710  	if (!externalLexer.fnCL)
711  		return;
712  	ILexer5* iLex5 = externalLexer.fnCL(externalLexer._name.c_str());
713  	if (!iLex5)
714  		return;
715  	execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(iLex5));
716  	::SendMessage(_hParent, NPPM_INTERNAL_EXTERNALLEXERBUFFER, 0, (LPARAM)getCurrentBufferID());
717  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
718  	const wchar_t* lexerNameW = wmc.char2wchar(externalLexer._name.c_str(), CP_ACP);
719  	LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerNameW);
720  	if (pStyler)
721  	{
722  		for (const Style & style : *pStyler)
723  		{
724  			setStyle(style);
725  			if (style._keywordClass >= 0 && style._keywordClass <= KEYWORDSET_MAX)
726  			{
727  				basic_string<char> keywordList("");
728  				if (!style._keywords.empty())
729  				{
730  					keywordList = wstring2string(style._keywords, CP_ACP);
731  				}
732  				execute(SCI_SETKEYWORDS, style._keywordClass, reinterpret_cast<LPARAM>(getCompleteKeywordList(keywordList, typeDoc, style._keywordClass)));
733  			}
734  		}
735  	}
736  }
737  void ScintillaEditView::setCppLexer(LangType langType)
738  {
739      const char *cppInstrs;
740      const char *cppTypes;
741      const TCHAR *doxygenKeyWords  = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
742      setLexerFromLangID(L_CPP);
743  	if (langType != L_RC)
744      {
745          if (doxygenKeyWords)
746  		{
747  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
748  			const char * doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
749  			execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords_char));
750  		}
751      }
752  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
753  	makeStyle(langType, pKwArray);
754  	basic_string<char> keywordListInstruction("");
755  	basic_string<char> keywordListType("");
756  	if (pKwArray[LANG_INDEX_INSTR])
757  	{
758  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
759  		keywordListInstruction = wstring2string(kwlW, CP_ACP);
760  	}
761  	cppInstrs = getCompleteKeywordList(keywordListInstruction, langType, LANG_INDEX_INSTR);
762  	if (pKwArray[LANG_INDEX_TYPE])
763  	{
764  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_TYPE];
765  		keywordListType = wstring2string(kwlW, CP_ACP);
766  	}
767  	cppTypes = getCompleteKeywordList(keywordListType, langType, LANG_INDEX_TYPE);
768  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(cppInstrs));
769  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(cppTypes));
770  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
771  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
772  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
773  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
774  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
775  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.track.preprocessor"), reinterpret_cast<LPARAM>("0"));
776  }
777  void ScintillaEditView::setJsLexer()
778  {
779  	const TCHAR *doxygenKeyWords = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
780  	setLexerFromLangID(L_JAVASCRIPT);
781  	const TCHAR *pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
782  	makeStyle(L_JAVASCRIPT, pKwArray);
783  	if (doxygenKeyWords)
784  	{
785  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
786  		const char * doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
787  		execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords_char));
788  	}
789  	const TCHAR *newLexerName = ScintillaEditView::_langNameInfoArray[L_JAVASCRIPT]._langName;
790  	LexerStyler *pNewStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(newLexerName);
791  	if (pNewStyler) 
792  	{
793  		for (const Style & style : *pNewStyler)
794  		{
795  			setStyle(style);
796  		}
797  		basic_string<char> keywordListInstruction("");
798  		basic_string<char> keywordListType("");
799  		basic_string<char> keywordListInstruction2("");
800  		if (pKwArray[LANG_INDEX_INSTR])
801  		{
802  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
803  			keywordListInstruction = wstring2string(kwlW, CP_ACP);
804  		}
805  		const char *jsInstrs = getCompleteKeywordList(keywordListInstruction, L_JAVASCRIPT, LANG_INDEX_INSTR);
806  		if (pKwArray[LANG_INDEX_TYPE])
807  		{
808  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_TYPE];
809  			keywordListType = wstring2string(kwlW, CP_ACP);
810  		}
811  		const char *jsTypes = getCompleteKeywordList(keywordListType, L_JAVASCRIPT, LANG_INDEX_TYPE);
812  		if (pKwArray[LANG_INDEX_INSTR2])
813  		{
814  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR2];
815  			keywordListInstruction2 = wstring2string(kwlW, CP_ACP);
816  		}
817  		const char *jsInstrs2 = getCompleteKeywordList(keywordListInstruction2, L_JAVASCRIPT, LANG_INDEX_INSTR2);
818  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(jsInstrs));
819  		execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(jsTypes));
820  		execute(SCI_SETKEYWORDS, 3, reinterpret_cast<LPARAM>(jsInstrs2));
821  	}
822  	else 
823  	{
824  		const TCHAR *lexerName = ScintillaEditView::_langNameInfoArray[L_JS]._langName;
825  		LexerStyler *pOldStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerName);
826  		if (pOldStyler)
827  		{
828  			for (Style style : *pOldStyler) 
829  			{
830  				int cppID = style._styleID;
831  				switch (style._styleID)
832  				{
833  					case SCE_HJ_DEFAULT: cppID = SCE_C_DEFAULT; break;
834  					case SCE_HJ_WORD: cppID = SCE_C_IDENTIFIER; break;
835  					case SCE_HJ_SYMBOLS: cppID = SCE_C_OPERATOR; break;
836  					case SCE_HJ_COMMENT: cppID = SCE_C_COMMENT; break;
837  					case SCE_HJ_COMMENTLINE: cppID = SCE_C_COMMENTLINE; break;
838  					case SCE_HJ_COMMENTDOC: cppID = SCE_C_COMMENTDOC; break;
839  					case SCE_HJ_NUMBER: cppID = SCE_C_NUMBER; break;
840  					case SCE_HJ_KEYWORD: cppID = SCE_C_WORD; break;
841  					case SCE_HJ_DOUBLESTRING: cppID = SCE_C_STRING; break;
842  					case SCE_HJ_SINGLESTRING: cppID = SCE_C_CHARACTER; break;
843  					case SCE_HJ_REGEX: cppID = SCE_C_REGEX; break;
844  				}
845  				style._styleID = cppID;
846  				setStyle(style);
847  			}
848  		}
849  		execute(SCI_STYLESETEOLFILLED, SCE_C_DEFAULT, true);
850  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENTLINE, true);
851  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENT, true);
852  		execute(SCI_STYLESETEOLFILLED, SCE_C_COMMENTDOC, true);
853  		makeStyle(L_JS, pKwArray);
854  		basic_string<char> keywordListInstruction("");
855  		if (pKwArray[LANG_INDEX_INSTR])
856  		{
857  			basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
858  			keywordListInstruction = wstring2string(kwlW, CP_ACP);
859  		}
860  		const char *jsEmbeddedInstrs = getCompleteKeywordList(keywordListInstruction, L_JS, LANG_INDEX_INSTR);
861  		execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(jsEmbeddedInstrs));
862  	}
863  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
864  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
865  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
866  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
867  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
868  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.track.preprocessor"), reinterpret_cast<LPARAM>("0"));
869  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.backquoted.strings"), reinterpret_cast<LPARAM>("1"));
870  }
871  void ScintillaEditView::setTclLexer()
872  {
873  	const char *tclInstrs;
874      const char *tclTypes;
875  	setLexerFromLangID(L_TCL);
876  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
877  	makeStyle(L_TCL, pKwArray);
878  	basic_string<char> keywordListInstruction("");
879  	basic_string<char> keywordListType("");
880  	if (pKwArray[LANG_INDEX_INSTR])
881  	{
882  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_INSTR];
883  		keywordListInstruction = wstring2string(kwlW, CP_ACP);
884  	}
885  	tclInstrs = getCompleteKeywordList(keywordListInstruction, L_TCL, LANG_INDEX_INSTR);
886  	if (pKwArray[LANG_INDEX_TYPE])
887  	{
888  		basic_string<wchar_t> kwlW = pKwArray[LANG_INDEX_TYPE];
889  		keywordListType = wstring2string(kwlW, CP_ACP);
890  	}
891  	tclTypes = getCompleteKeywordList(keywordListType, L_TCL, LANG_INDEX_TYPE);
892  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(tclInstrs));
893  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(tclTypes));
894  }
895  void ScintillaEditView::setObjCLexer(LangType langType)
896  {
897  	setLexerFromLangID(L_OBJC);
898  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
899  	makeStyle(langType, pKwArray);
900  	basic_string<char> objcInstr1Kwl("");
901  	if (pKwArray[LANG_INDEX_INSTR])
902  	{
903  		objcInstr1Kwl = wstring2string(pKwArray[LANG_INDEX_INSTR], CP_ACP);
904  	}
905  	const char *objcInstrs = getCompleteKeywordList(objcInstr1Kwl, langType, LANG_INDEX_INSTR);
906  	basic_string<char> objcInstr2Kwl("");
907  	if (pKwArray[LANG_INDEX_INSTR2])
908  	{
909  		objcInstr2Kwl = wstring2string(pKwArray[LANG_INDEX_INSTR2], CP_ACP);
910  	}
911  	const char *objCDirective = getCompleteKeywordList(objcInstr2Kwl, langType, LANG_INDEX_INSTR2);
912  	basic_string<char> objcTypeKwl("");
913  	if (pKwArray[LANG_INDEX_TYPE])
914  	{
915  		objcTypeKwl = wstring2string(pKwArray[LANG_INDEX_TYPE], CP_ACP);
916  	}
917  	const char *objcTypes = getCompleteKeywordList(objcTypeKwl, langType, LANG_INDEX_TYPE);
918  	basic_string<char> objcType2Kwl("");
919  	if (pKwArray[LANG_INDEX_TYPE2])
920  	{
921  		objcType2Kwl = wstring2string(pKwArray[LANG_INDEX_TYPE2], CP_ACP);
922  	}
923  	const char *objCQualifier = getCompleteKeywordList(objcType2Kwl, langType, LANG_INDEX_TYPE2);
924  	basic_string<char> doxygenKeyWordsString("");
925  	const TCHAR *doxygenKeyWordsW = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
926  	if (doxygenKeyWordsW)
927  	{
928  		doxygenKeyWordsString = wstring2string(doxygenKeyWordsW, CP_ACP);
929  	}
930  	const char *doxygenKeyWords = doxygenKeyWordsString.c_str();
931  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(objcInstrs));
932      execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(objcTypes));
933  	execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords));
934  	execute(SCI_SETKEYWORDS, 3, reinterpret_cast<LPARAM>(objCDirective));
935  	execute(SCI_SETKEYWORDS, 4, reinterpret_cast<LPARAM>(objCQualifier));
936  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
937  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
938  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
939  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
940  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
941  }
942  void ScintillaEditView::setTypeScriptLexer()
943  {
944  	const TCHAR* doxygenKeyWords = NppParameters::getInstance().getWordList(L_CPP, LANG_INDEX_TYPE2);
945  	setLexerFromLangID(L_TYPESCRIPT);
946  	if (doxygenKeyWords)
947  	{
948  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
949  		const char* doxygenKeyWords_char = wmc.wchar2char(doxygenKeyWords, CP_ACP);
950  		execute(SCI_SETKEYWORDS, 2, reinterpret_cast<LPARAM>(doxygenKeyWords_char));
951  	}
952  	const TCHAR* pKwArray[10] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
953  	makeStyle(L_TYPESCRIPT, pKwArray);
954  	auto getKeywordList = [&pKwArray](const int i) 
955  	{
956  		if (pKwArray[i])
957  		{
958  			basic_string<wchar_t> kwlW = pKwArray[i];
959  			return wstring2string(kwlW, CP_ACP);
960  		}
961  		return basic_string<char>("");
962  	};
963  	std::string keywordListInstruction = getKeywordList(LANG_INDEX_INSTR);
964  	const char* tsInstructions = getCompleteKeywordList(keywordListInstruction, L_TYPESCRIPT, LANG_INDEX_INSTR);
965  	string keywordListType = getKeywordList(LANG_INDEX_TYPE);
966  	const char* tsTypes = getCompleteKeywordList(keywordListType, L_TYPESCRIPT, LANG_INDEX_TYPE);
967  	execute(SCI_SETKEYWORDS, 0, reinterpret_cast<LPARAM>(tsInstructions));
968  	execute(SCI_SETKEYWORDS, 1, reinterpret_cast<LPARAM>(tsTypes));
969  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
970  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
971  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
972  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.cpp.comment.explicit"), reinterpret_cast<LPARAM>("0"));
973  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
974  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.track.preprocessor"), reinterpret_cast<LPARAM>("0"));
975  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.cpp.backquoted.strings"), reinterpret_cast<LPARAM>("1"));
976  }
977  void ScintillaEditView::setKeywords(LangType langType, const char *keywords, int index)
978  {
979  	std::basic_string<char> wordList;
980  	wordList = (keywords)?keywords:"";
981  	execute(SCI_SETKEYWORDS, index, reinterpret_cast<LPARAM>(getCompleteKeywordList(wordList, langType, index)));
982  }
983  void ScintillaEditView::setLexer(LangType langType, int whichList)
984  {
985  	setLexerFromLangID(langType);
986  	const TCHAR *pKwArray[10] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
987  	makeStyle(langType, pKwArray);
988  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
989  	if (whichList & LIST_0)
990  	{
991  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_INSTR], CP_ACP);
992  		setKeywords(langType, keyWords_char, LANG_INDEX_INSTR);
993  	}
994  	if (whichList & LIST_1)
995  	{
996  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_INSTR2], CP_ACP);
997  		setKeywords(langType, keyWords_char, LANG_INDEX_INSTR2);
998  	}
999  	if (whichList & LIST_2)
1000  	{
1001  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE], CP_ACP);
1002  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE);
1003  	}
1004  	if (whichList & LIST_3)
1005  	{
1006  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE2], CP_ACP);
1007  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE2);
1008  	}
1009  	if (whichList & LIST_4)
1010  	{
1011  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE3], CP_ACP);
1012  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE3);
1013  	}
1014  	if (whichList & LIST_5)
1015  	{
1016  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE4], CP_ACP);
1017  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE4);
1018  	}
1019  	if (whichList & LIST_6)
1020  	{
1021  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE5], CP_ACP);
1022  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE5);
1023  	}
1024  	if (whichList & LIST_7)
1025  	{
1026  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE6], CP_ACP);
1027  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE6);
1028  	}
1029  	if (whichList & LIST_8)
1030  	{
1031  		const char * keyWords_char = wmc.wchar2char(pKwArray[LANG_INDEX_TYPE7], CP_ACP);
1032  		setKeywords(langType, keyWords_char, LANG_INDEX_TYPE7);
1033  	}
1034  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold"), reinterpret_cast<LPARAM>("1"));
1035  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.compact"), reinterpret_cast<LPARAM>("0"));
1036  	execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.comment"), reinterpret_cast<LPARAM>("1"));
1037  }
1038  void ScintillaEditView::makeStyle(LangType language, const TCHAR **keywordArray)
1039  {
1040  	const TCHAR * lexerName = ScintillaEditView::_langNameInfoArray[language]._langName;
1041  	LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(lexerName);
1042  	if (pStyler)
1043  	{
1044  		for (const Style & style : *pStyler)
1045  		{
1046  			setStyle(style);
1047  			if (keywordArray)
1048  			{
1049  				if ((style._keywordClass != STYLE_NOT_USED) && (!style._keywords.empty()))
1050  					keywordArray[style._keywordClass] = style._keywords.c_str();
1051  			}
1052  		}
1053  	}
1054  }
1055  void ScintillaEditView::restoreDefaultWordChars()
1056  {
1057  	execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>(_defaultCharList.c_str()));
1058  }
1059  void ScintillaEditView::addCustomWordChars()
1060  {
1061  	NppParameters& nppParam = NppParameters::getInstance();
1062  	const NppGUI & nppGUI = nppParam.getNppGUI();
1063  	if (nppGUI._customWordChars.empty())
1064  		return;
1065  	string chars2addStr;
1066  	for (size_t i = 0; i < nppGUI._customWordChars.length(); ++i)
1067  	{
1068  		bool found = false;
1069  		char char2check = nppGUI._customWordChars[i];
1070  		for (size_t j = 0; j < _defaultCharList.length(); ++j)
1071  		{
1072  			char wordChar = _defaultCharList[j];
1073  			if (char2check == wordChar)
1074  			{
1075  				found = true;
1076  				break;
1077  			}
1078  		}
1079  		if (!found)
1080  		{
1081  			chars2addStr.push_back(char2check);
1082  		}
1083  	}
1084  	if (!chars2addStr.empty())
1085  	{
1086  		string newCharList = _defaultCharList;
1087  		newCharList += chars2addStr;
1088  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>(newCharList.c_str()));
1089  	}
1090  }
1091  void ScintillaEditView::setWordChars()
1092  {
1093  	NppParameters& nppParam = NppParameters::getInstance();
1094  	const NppGUI & nppGUI = nppParam.getNppGUI();
1095  	if (nppGUI._isWordCharDefault)
1096  		restoreDefaultWordChars();
1097  	else
1098  		addCustomWordChars();
1099  }
1100  void ScintillaEditView::setCRLF(long color)
1101  {
1102  	NppParameters& nppParams = NppParameters::getInstance();
1103  	const ScintillaViewParams& svp = nppParams.getSVP();
1104  	COLORREF eolCustomColor = liteGrey;
1105  	if (color == -1)
1106  	{
1107  		StyleArray& stylers = nppParams.getMiscStylerArray();
1108  		Style* pStyle = stylers.findByName(TEXT("EOL custom color"));
1109  		if (pStyle)
1110  		{
1111  			eolCustomColor = pStyle->_fgColor;
1112  		}
1113  	}
1114  	else
1115  	{
1116  		eolCustomColor = color;
1117  	}
1118  	ScintillaViewParams::crlfMode eolMode = svp._eolMode;
1119  	long appearance = SC_REPRESENTATION_BLOB;
1120  	if (eolMode == ScintillaViewParams::crlfMode::plainText)
1121  		appearance = SC_REPRESENTATION_PLAIN;
1122  	else if (eolMode == ScintillaViewParams::crlfMode::plainTextCustomColor)
1123  		appearance = SC_REPRESENTATION_PLAIN | SC_REPRESENTATION_COLOUR;
1124  	else if (eolMode == ScintillaViewParams::crlfMode::roundedRectangleText)
1125  		appearance = SC_REPRESENTATION_BLOB;
1126  	else if (eolMode == ScintillaViewParams::crlfMode::roundedRectangleTextCustomColor)
1127  		appearance = SC_REPRESENTATION_BLOB | SC_REPRESENTATION_COLOUR;
1128  	const wchar_t* cr = L"\x0d";
1129  	const wchar_t* lf = L"\x0a";
1130  	long alphaEolCustomColor = eolCustomColor;
1131  	alphaEolCustomColor |= 0xFF000000; 
1132  	execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(cr), alphaEolCustomColor);
1133  	execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(lf), alphaEolCustomColor);
1134  	execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(cr), appearance);
1135  	execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(lf), appearance);
1136  	redraw();
1137  }
1138  void ScintillaEditView::setNpcAndCcUniEOL(long color)
1139  {
1140  	NppParameters& nppParams = NppParameters::getInstance();
1141  	const ScintillaViewParams& svp = nppParams.getSVP();
1142  	COLORREF npcCustomColor = liteGrey;
1143  	if (color == -1)
1144  	{
1145  		StyleArray& stylers = nppParams.getMiscStylerArray();
1146  		Style* pStyle = stylers.findByName(g_npcStyleName);
1147  		if (pStyle)
1148  		{
1149  			npcCustomColor = pStyle->_fgColor;
1150  		}
1151  	}
1152  	else
1153  	{
1154  		npcCustomColor = color;
1155  	}
1156  	const long appearance = svp._npcCustomColor ? SC_REPRESENTATION_BLOB | SC_REPRESENTATION_COLOUR : SC_REPRESENTATION_BLOB;
1157  	const long alphaNpcCustomColor = npcCustomColor | 0xFF000000; 
1158  	if (svp._npcShow)
1159  	{
1160  		for (const auto& invChar : g_nonPrintingChars)
1161  		{
1162  			execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(invChar.at(0)), alphaNpcCustomColor);
1163  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(invChar.at(0)), appearance);
1164  		}
1165  	}
1166  	if (svp._ccUniEolShow && svp._npcIncludeCcUniEol)
1167  	{
1168  		for (const auto& invChar : g_ccUniEolChars)
1169  		{
1170  			execute(SCI_SETREPRESENTATIONCOLOUR, reinterpret_cast<WPARAM>(invChar.at(0)), alphaNpcCustomColor);
1171  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(invChar.at(0)), appearance);
1172  		}
1173  	}
1174  	redraw();
1175  }
1176  void ScintillaEditView::defineDocType(LangType typeDoc)
1177  {
1178  	StyleArray & stylers = NppParameters::getInstance().getMiscStylerArray();
1179  	Style * pStyleDefault = stylers.findByID(STYLE_DEFAULT);
1180  	if (pStyleDefault)
1181  	{
1182  		pStyleDefault->_colorStyle = COLORSTYLE_ALL;	
1183  		setStyle(*pStyleDefault);
1184  	}
1185  	execute(SCI_STYLECLEARALL);
1186  	Style defaultIndicatorStyle;
1187  	const Style * pStyle;
1188  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE;
1189  	defaultIndicatorStyle._bgColor = red;
1190  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1191  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1192  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_SMART;
1193  	defaultIndicatorStyle._bgColor = liteGreen;
1194  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1195  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1196  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_INC;
1197  	defaultIndicatorStyle._bgColor = blue;
1198  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1199  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1200  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_TAGMATCH;
1201  	defaultIndicatorStyle._bgColor = RGB(0x80, 0x00, 0xFF);
1202  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1203  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1204  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_TAGATTR;
1205  	defaultIndicatorStyle._bgColor = yellow;
1206  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1207  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1208  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1209  	defaultIndicatorStyle._bgColor = cyan;
1210  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1211  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1212  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1213  	defaultIndicatorStyle._bgColor = orange;
1214  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1215  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1216  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1217  	defaultIndicatorStyle._bgColor = yellow;
1218  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1219  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1220  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1221  	defaultIndicatorStyle._bgColor = purple;
1222  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1223  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1224  	defaultIndicatorStyle._styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1225  	defaultIndicatorStyle._bgColor = darkGreen;
1226  	pStyle = stylers.findByID(defaultIndicatorStyle._styleID);
1227  	setSpecialIndicator(pStyle ? *pStyle : defaultIndicatorStyle);
1228  	if (isCJK())
1229  	{
1230  		if (getCurrentBuffer()->getUnicodeMode() == uni8Bit)
1231  		{
1232  			if (typeDoc == L_CSS || typeDoc == L_CAML || typeDoc == L_ASM || typeDoc == L_MATLAB)
1233  				execute(SCI_SETCODEPAGE, CP_ACP);
1234  			else
1235  				execute(SCI_SETCODEPAGE, _codepage);
1236  		}
1237  	}
1238  	ScintillaViewParams & svp = (ScintillaViewParams &)NppParameters::getInstance().getSVP();
1239  	if (svp._folderStyle != FOLDER_STYLE_NONE)
1240  		showMargin(_SC_MARGE_FOLDER, isNeededFolderMarge(typeDoc));
1241  	switch (typeDoc)
1242  	{
1243  		case L_C :
1244  		case L_CPP :
1245  		case L_JAVA :
1246  		case L_RC :
1247  		case L_CS :
1248  		case L_FLASH :
1249  		case L_SWIFT:
1250  			setCppLexer(typeDoc); break;
1251  		case L_JS:
1252  		case L_JAVASCRIPT:
1253  			setJsLexer(); break;
1254  		case L_TCL :
1255              setTclLexer(); break;
1256          case L_OBJC :
1257              setObjCLexer(typeDoc); break;
1258  	    case L_PHP :
1259  		case L_ASP :
1260          case L_JSP :
1261  		case L_HTML :
1262  		case L_XML :
1263  			setXmlLexer(typeDoc); break;
1264  		case L_JSON:
1265  			setJsonLexer(); break;
1266  		case L_JSON5:
1267  			setJsonLexer(true); break;
1268  		case L_CSS :
1269  			setCssLexer(); break;
1270  		case L_LUA :
1271  			setLuaLexer(); break;
1272  		case L_MAKEFILE :
1273  			setMakefileLexer(); break;
1274  		case L_INI :
1275  			setPropsLexer(false); break;
1276  		case L_USER : {
1277  			const TCHAR * langExt = _currentBuffer->getUserDefineLangName();
1278  			if (langExt[0])
1279  				setUserLexer(langExt);
1280  			else
1281  				setUserLexer();
1282  			break; }
1283          case L_ASCII :
1284  		{
1285  			LexerStyler *pStyler = (NppParameters::getInstance().getLStylerArray()).getLexerStylerByName(TEXT("nfo"));
1286  			Style nfoStyle;
1287  			nfoStyle._styleID = STYLE_DEFAULT;
1288  			nfoStyle._fontName = TEXT("Lucida Console");
1289  			nfoStyle._fontSize = 10;
1290  			if (pStyler)
1291  			{
1292  				const Style * pStyle = pStyler->findByName(TEXT("DEFAULT"));
1293  				if (pStyle)
1294  				{
1295  					nfoStyle._bgColor = pStyle->_bgColor;
1296  					nfoStyle._fgColor = pStyle->_fgColor;
1297  					nfoStyle._colorStyle = pStyle->_colorStyle;
1298  				}
1299  			}
1300  			setSpecialStyle(nfoStyle);
1301  			execute(SCI_STYLECLEARALL);
1302  			Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1303  			if (buf->getEncoding() != NPP_CP_DOS_437)
1304  			{
1305  			   buf->setEncoding(NPP_CP_DOS_437);
1306  			   ::SendMessage(_hParent, WM_COMMAND, IDM_FILE_RELOAD, 0);
1307  			}
1308  		}
1309  		break;
1310  		case L_SQL :
1311  			setSqlLexer(); break;
1312  		case L_MSSQL :
1313  			setMSSqlLexer(); break;
1314  		case L_VB :
1315  			setVBLexer(); break;
1316  		case L_PASCAL :
1317  			setPascalLexer(); break;
1318  		case L_PERL :
1319  			setPerlLexer(); break;
1320  		case L_PYTHON :
1321  			setPythonLexer(); break;
1322  		case L_BATCH :
1323  			setBatchLexer(); break;
1324  		case L_TEX :
1325  			setTeXLexer(); break;
1326  		case L_NSIS :
1327  			setNsisLexer(); break;
1328  		case L_BASH :
1329  			setBashLexer(); break;
1330  		case L_FORTRAN :
1331  			setFortranLexer(); break;
1332  		case L_FORTRAN_77 :
1333  			setFortran77Lexer(); break;
1334  		case L_LISP :
1335              setLispLexer(); break;
1336  		case L_SCHEME :
1337              setSchemeLexer(); break;
1338  		case L_ASM :
1339              setAsmLexer(); break;
1340  		case L_DIFF :
1341              setDiffLexer(); break;
1342  		case L_PROPS :
1343              setPropsLexer(); break;
1344  		case L_PS :
1345              setPostscriptLexer(); break;
1346  		case L_RUBY :
1347              setRubyLexer(); break;
1348  		case L_SMALLTALK :
1349              setSmalltalkLexer(); break;
1350  		case L_VHDL :
1351              setVhdlLexer(); break;
1352  		case L_KIX :
1353              setKixLexer(); break;
1354  		case L_CAML :
1355              setCamlLexer(); break;
1356  		case L_ADA :
1357              setAdaLexer(); break;
1358  		case L_VERILOG :
1359              setVerilogLexer(); break;
1360  		case L_AU3 :
1361              setAutoItLexer(); break;
1362  		case L_MATLAB :
1363              setMatlabLexer(); break;
1364  		case L_HASKELL :
1365              setHaskellLexer(); break;
1366  		case L_INNO :
1367  			setInnoLexer(); break;
1368  		case L_CMAKE :
1369  			setCmakeLexer(); break;
1370  		case L_YAML :
1371  			setYamlLexer(); break;
1372          case L_COBOL :
1373  			setCobolLexer(); break;
1374          case L_GUI4CLI :
1375  			setGui4CliLexer(); break;
1376          case L_D :
1377  			setDLexer(); break;
1378          case L_POWERSHELL :
1379  			setPowerShellLexer(); break;
1380          case L_R :
1381  			setRLexer(); break;
1382  		case L_COFFEESCRIPT :
1383  			setCoffeeScriptLexer(); break;
1384  		case L_BAANC:
1385  			setBaanCLexer(); break;
1386  		case L_SREC :
1387  			setSrecLexer(); break;
1388  		case L_IHEX :
1389  			setIHexLexer(); break;
1390  		case L_TEHEX :
1391  			setTEHexLexer(); break;
1392  		case L_ASN1 :
1393  			setAsn1Lexer(); break;
1394  		case L_AVS :
1395  			setAVSLexer(); break;
1396  		case L_BLITZBASIC :
1397  			setBlitzBasicLexer(); break;
1398  		case L_PUREBASIC :
1399  			setPureBasicLexer(); break;
1400  		case L_FREEBASIC :
1401  			setFreeBasicLexer(); break;
1402  		case L_CSOUND :
1403  			setCsoundLexer(); break;
1404  		case L_ERLANG :
1405  			setErlangLexer(); break;
1406  		case L_ESCRIPT :
1407  			setESCRIPTLexer(); break;
1408  		case L_FORTH :
1409  			setForthLexer(); break;
1410  		case L_LATEX :
1411  			setLatexLexer(); break;
1412  		case L_MMIXAL :
1413  			setMMIXALLexer(); break;
1414  		case L_NIM :
1415  			setNimrodLexer(); break;
1416  		case L_NNCRONTAB :
1417  			setNncrontabLexer(); break;
1418  		case L_OSCRIPT :
1419  			setOScriptLexer(); break;
1420  		case L_REBOL :
1421  			setREBOLLexer(); break;
1422  		case L_REGISTRY :
1423  			setRegistryLexer(); break;
1424  		case L_RUST :
1425  			setRustLexer(); break;
1426  		case L_SPICE :
1427  			setSpiceLexer(); break;
1428  		case L_TXT2TAGS :
1429  			setTxt2tagsLexer(); break;
1430  		case L_VISUALPROLOG:
1431  			setVisualPrologLexer(); break;
1432  		case L_TYPESCRIPT:
1433  			setTypeScriptLexer(); break;
1434  		case L_GDSCRIPT:
1435  			setGDScriptLexer(); break;
1436  		case L_HOLLYWOOD:
1437  			setHollywoodLexer(); break;
1438  		case L_TEXT :
1439  		default :
1440  			if (typeDoc >= L_EXTERNAL && typeDoc < NppParameters::getInstance().L_END)
1441  				setExternalLexer(typeDoc);
1442  			else
1443  				setLexerFromLangID(L_TEXT);
1444  			break;
1445  	}
1446  	pStyle = stylers.findByID(STYLE_INDENTGUIDE);
1447  	if (pStyle)
1448  	{
1449  		setStyle(*pStyle);
1450  	}
1451  	pStyle = stylers.findByID(STYLE_BRACELIGHT);
1452  	if (pStyle)
1453  	{
1454  		setStyle(*pStyle);
1455  	}
1456  	pStyle = stylers.findByID(STYLE_BRACEBAD);
1457  	if (pStyle)
1458  	{
1459  		setStyle(*pStyle);
1460  	}
1461  	pStyle = stylers.findByID(STYLE_LINENUMBER);
1462  	if (pStyle)
1463  	{
1464  		setSpecialStyle(*pStyle);
1465  	}
1466  	setTabSettings(NppParameters::getInstance().getLangFromID(typeDoc));
1467  	if (svp._indentGuideLineShow)
1468  	{
1469  		const auto currentIndentMode = execute(SCI_GETINDENTATIONGUIDES);
1470  		const int docIndentMode = isPythonStyleIndentation(typeDoc) ? SC_IV_LOOKFORWARD : SC_IV_LOOKBOTH;
1471  		if (currentIndentMode != docIndentMode)
1472  			execute(SCI_SETINDENTATIONGUIDES, docIndentMode);
1473  	}
1474  }
1475  BufferID ScintillaEditView::attachDefaultDoc()
1476  {
1477  	Document doc = execute(SCI_GETDOCPOINTER, 0, 0);
1478  	execute(SCI_ADDREFDOCUMENT, 0, doc);
1479  	BufferID id = MainFileManager.bufferFromDocument(doc, false, true);
1480  	Buffer * buf = MainFileManager.getBufferByID(id);
1481  	MainFileManager.addBufferReference(id, this);	
1482  	_currentBufferID = id;
1483  	_currentBuffer = buf;
1484  	bufferUpdated(buf, BufferChangeMask);	
1485  	return id;
1486  }
1487  void ScintillaEditView::saveCurrentPos()
1488  {
1489  	size_t displayedLine = execute(SCI_GETFIRSTVISIBLELINE);
1490  	size_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1491  	size_t offset = displayedLine - execute(SCI_VISIBLEFROMDOCLINE, docLine);		
1492  	size_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
1493  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1494  	Position pos;
1495  	pos._firstVisibleLine = docLine;
1496  	pos._startPos = execute(SCI_GETANCHOR);
1497  	pos._endPos = execute(SCI_GETCURRENTPOS);
1498  	pos._xOffset = execute(SCI_GETXOFFSET);
1499  	pos._selMode = execute(SCI_GETSELECTIONMODE);
1500  	pos._scrollWidth = execute(SCI_GETSCROLLWIDTH);
1501  	pos._offset = offset;
1502  	pos._wrapCount = wrapCount;
1503  	buf->setPosition(pos, this);
1504  }
1505  void ScintillaEditView::restoreCurrentPosPreStep()
1506  {
1507  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1508  	Position & pos = buf->getPosition(this);
1509  	execute(SCI_SETSELECTIONMODE, pos._selMode);	
1510  	execute(SCI_SETANCHOR, pos._startPos);
1511  	execute(SCI_SETCURRENTPOS, pos._endPos);
1512  	execute(SCI_CANCEL);							
1513  	if (!isWrap()) 
1514  	{
1515  		execute(SCI_SETSCROLLWIDTH, pos._scrollWidth);
1516  		execute(SCI_SETXOFFSET, pos._xOffset);
1517  	}
1518  	execute(SCI_CHOOSECARETX); 
1519  	intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1520  	execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1521  	if (isWrap())
1522  	{
1523  		_positionRestoreNeeded = true;
1524  	}
1525  	_restorePositionRetryCount = 0;
1526  }
1527  void ScintillaEditView::restoreCurrentPosPostStep()
1528  {
1529  	if (!_positionRestoreNeeded)
1530  		return;
1531  	Buffer * buf = MainFileManager.getBufferByID(_currentBufferID);
1532  	Position & pos = buf->getPosition(this);
1533  	++_restorePositionRetryCount;
1534  	if (_restorePositionRetryCount > 8)
1535  	{
1536  		_positionRestoreNeeded = false;
1537  		return;
1538  	}
1539  	intptr_t displayedLine = execute(SCI_GETFIRSTVISIBLELINE);
1540  	intptr_t docLine = execute(SCI_DOCLINEFROMVISIBLE, displayedLine);		
1541  	if (docLine != pos._firstVisibleLine)
1542  	{
1543  		intptr_t lineToShow = execute(SCI_VISIBLEFROMDOCLINE, pos._firstVisibleLine);
1544  		execute(SCI_SETFIRSTVISIBLELINE, lineToShow);
1545  	}
1546  	else if (pos._offset > 0)
1547  	{
1548  		intptr_t wrapCount = execute(SCI_WRAPCOUNT, docLine);
1549  		if (wrapCount == pos._wrapCount)
1550  		{
1551  			scroll(0, pos._offset);
1552  			_positionRestoreNeeded = false;
1553  		}
1554  	}
1555  	else
1556  	{
1557  		_positionRestoreNeeded = false;
1558  	}
1559  }
1560  void ScintillaEditView::restyleBuffer()
1561  {
1562  	execute(SCI_CLEARDOCUMENTSTYLE);
1563  	execute(SCI_COLOURISE, 0, -1);
1564  	_currentBuffer->setNeedsLexing(false);
1565  }
1566  void ScintillaEditView::styleChange()
1567  {
1568  	defineDocType(_currentBuffer->getLangType());
1569  	restyleBuffer();
1570  }
1571  bool ScintillaEditView::setLexerFromLangID(int langID) 
1572  {
1573  	if (langID >= L_EXTERNAL)
1574  		return false;
1575  	const char* lexerNameID = _langNameInfoArray[langID]._lexerID;
1576  	execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(CreateLexer(lexerNameID)));
1577  	return true;
1578  }
1579  void ScintillaEditView::activateBuffer(BufferID buffer, bool force)
1580  {
1581  	if (buffer == BUFFER_INVALID)
1582  		return;
1583  	if (!force && buffer == _currentBuffer)
1584  		return;
1585  	Buffer * newBuf = MainFileManager.getBufferByID(buffer);
1586  	saveCurrentPos();
1587  	std::vector<size_t> lineStateVector;
1588  	getCurrentFoldStates(lineStateVector);
1589  	_currentBuffer->setHeaderLineState(lineStateVector, this);
1590  	_currentBufferID = buffer;	
1591  	_currentBuffer = newBuf;
1592  	execute(SCI_SETDOCPOINTER, 0, _currentBuffer->getDocument());
1593  	defineDocType(_currentBuffer->getLangType());
1594  	setWordChars();
1595  	if (_currentBuffer->getNeedsLexing())
1596  	{
1597  		restyleBuffer();
1598  	}
1599  	maintainStateForNpc();
1600  	bufferUpdated(_currentBuffer, (BufferChangeMask & ~BufferChangeLanguage));
1601  	const std::vector<size_t> & lineStateVectorNew = newBuf->getHeaderLineState(this);
1602  	syncFoldStateWith(lineStateVectorNew);
1603  	restoreCurrentPosPreStep();
1604  	runMarkers(true, 0, true, false);
1605  	setCRLF();
1606  	NppParameters& nppParam = NppParameters::getInstance();
1607  	const ScintillaViewParams& svp = nppParam.getSVP();
1608  	int enabledCH = svp._isChangeHistoryEnabled ? (SC_CHANGE_HISTORY_ENABLED | SC_CHANGE_HISTORY_MARKERS) : SC_CHANGE_HISTORY_DISABLED;
1609  	execute(SCI_SETCHANGEHISTORY, enabledCH);
1610      return;	
1611  }
1612  void ScintillaEditView::getCurrentFoldStates(std::vector<size_t> & lineStateVector)
1613  {
1614  	size_t contractedFoldHeaderLine = 0;
1615  	do {
1616  		contractedFoldHeaderLine = execute(SCI_CONTRACTEDFOLDNEXT, contractedFoldHeaderLine);
1617  		if (static_cast<intptr_t>(contractedFoldHeaderLine) != -1)
1618  		{
1619  			lineStateVector.push_back(contractedFoldHeaderLine);
1620  			++contractedFoldHeaderLine;
1621  		}
1622  	} while (static_cast<intptr_t>(contractedFoldHeaderLine) != -1);
1623  }
1624  void ScintillaEditView::syncFoldStateWith(const std::vector<size_t> & lineStateVectorNew)
1625  {
1626  	size_t nbLineState = lineStateVectorNew.size();
1627  	for (size_t i = 0 ; i < nbLineState ; ++i)
1628  	{
1629  		auto line = lineStateVectorNew.at(i);
1630  		fold(line, false);
1631  	}
1632  }
1633  void ScintillaEditView::bufferUpdated(Buffer * buffer, int mask)
1634  {
1635  	if (buffer == _currentBuffer)
1636  	{
1637  		if (mask & BufferChangeLanguage)
1638  		{
1639  			defineDocType(buffer->getLangType());
1640  			foldAll(fold_uncollapse);
1641  		}
1642  		if (mask & BufferChangeLexing)
1643  		{
1644  			if (buffer->getNeedsLexing())
1645  			{
1646  				restyleBuffer();	
1647  			}	
1648  		}
1649  		if (mask & BufferChangeFormat)
1650  		{
1651  			execute(SCI_SETEOLMODE, static_cast<int>(_currentBuffer->getEolFormat()));
1652  		}
1653  		if (mask & BufferChangeReadonly)
1654  		{
1655  			execute(SCI_SETREADONLY, _currentBuffer->isReadOnly());
1656  		}
1657  		if (mask & BufferChangeUnicode)
1658  		{
1659              int enc = CP_ACP;
1660  			if (buffer->getUnicodeMode() == uni8Bit)
1661  			{	
1662  				LangType typeDoc = buffer->getLangType();
1663  				if (isCJK())
1664  				{
1665  					if (typeDoc == L_CSS || typeDoc == L_CAML || typeDoc == L_ASM || typeDoc == L_MATLAB)
1666  						enc = CP_ACP;	
1667  					else
1668  						enc = _codepage;
1669  				}
1670                  else
1671                      enc = CP_ACP;
1672  			}
1673  			else	
1674  				enc = SC_CP_UTF8;
1675              execute(SCI_SETCODEPAGE, enc);
1676  		}
1677  	}
1678  }
1679  bool ScintillaEditView::isFoldIndentationBased() const
1680  {
1681  	const auto lexer = execute(SCI_GETLEXER);
1682  	return lexer == SCLEX_PYTHON
1683  		|| lexer == SCLEX_COFFEESCRIPT
1684  		|| lexer == SCLEX_HASKELL
1685  		|| lexer == SCLEX_NIMROD
1686  		|| lexer == SCLEX_VB
1687  		|| lexer == SCLEX_YAML
1688  	;
1689  }
1690  namespace {
1691  struct FoldLevelStack
1692  {
1693  	int levelCount = 0; 
1694  	intptr_t levelStack[MAX_FOLD_COLLAPSE_LEVEL]{};
1695  	void push(intptr_t level)
1696  	{
1697  		while (levelCount != 0 && level <= levelStack[levelCount - 1])
1698  		{
1699  			--levelCount;
1700  		}
1701  		levelStack[levelCount++] = level;
1702  	}
1703  };
1704  }
1705  void ScintillaEditView::collapseFoldIndentationBased(int level2Collapse, bool mode)
1706  {
1707  	execute(SCI_COLOURISE, 0, -1);
1708  	FoldLevelStack levelStack;
1709  	++level2Collapse; 
1710  	const intptr_t maxLine = execute(SCI_GETLINECOUNT);
1711  	intptr_t line = 0;
1712  	while (line < maxLine)
1713  	{
1714  		intptr_t level = execute(SCI_GETFOLDLEVEL, line);
1715  		if (level & SC_FOLDLEVELHEADERFLAG)
1716  		{
1717  			level &= SC_FOLDLEVELNUMBERMASK;
1718  			levelStack.push(level);
1719  			if (level2Collapse == levelStack.levelCount)
1720  			{
1721  				if (isFolded(line) != mode)
1722  				{
1723  					fold(line, mode);
1724  				}
1725  				line = execute(SCI_GETLASTCHILD, line, -1);
1726  			}
1727  		}
1728  		++line;
1729  	}
1730  	runMarkers(true, 0, true, false);
1731  }
1732  void ScintillaEditView::collapse(int level2Collapse, bool mode)
1733  {
1734  	if (isFoldIndentationBased())
1735  	{
1736  		collapseFoldIndentationBased(level2Collapse, mode);
1737  		return;
1738  	}
1739  	execute(SCI_COLOURISE, 0, -1);
1740  	intptr_t maxLine = execute(SCI_GETLINECOUNT);
1741  	for (int line = 0; line < maxLine; ++line)
1742  	{
1743  		intptr_t level = execute(SCI_GETFOLDLEVEL, line);
1744  		if (level & SC_FOLDLEVELHEADERFLAG)
1745  		{
1746  			level -= SC_FOLDLEVELBASE;
1747  			if (level2Collapse == (level & SC_FOLDLEVELNUMBERMASK))
1748  				if (isFolded(line) != mode)
1749  				{
1750  					fold(line, mode);
1751  				}
1752  		}
1753  	}
1754  	runMarkers(true, 0, true, false);
1755  }
1756  void ScintillaEditView::foldCurrentPos(bool mode)
1757  {
1758  	auto currentLine = getCurrentLineNumber();
1759  	fold(currentLine, mode);
1760  }
1761  bool ScintillaEditView::isCurrentLineFolded() const
1762  {
1763  	auto currentLine = getCurrentLineNumber();
1764  	intptr_t headerLine;
1765  	auto level = execute(SCI_GETFOLDLEVEL, currentLine);
1766  	if (level & SC_FOLDLEVELHEADERFLAG)
1767  		headerLine = currentLine;
1768  	else
1769  	{
1770  		headerLine = execute(SCI_GETFOLDPARENT, currentLine);
1771  		if (headerLine == -1)
1772  			return false;
1773  	}
1774  	bool isExpanded = execute(SCI_GETFOLDEXPANDED, headerLine);
1775  	return !isExpanded;
1776  }
1777  void ScintillaEditView::fold(size_t line, bool mode)
1778  {
1779  	auto endStyled = execute(SCI_GETENDSTYLED);
1780  	auto len = execute(SCI_GETTEXTLENGTH);
1781  	if (endStyled < len)
1782  		execute(SCI_COLOURISE, 0, -1);
1783  	intptr_t headerLine;
1784  	auto level = execute(SCI_GETFOLDLEVEL, line);
1785  	if (level & SC_FOLDLEVELHEADERFLAG)
1786  		headerLine = line;
1787  	else
1788  	{
1789  		headerLine = execute(SCI_GETFOLDPARENT, line);
1790  		if (headerLine == -1)
1791  			return;
1792  	}
1793  	if (isFolded(headerLine) != mode)
1794  	{
1795  		execute(SCI_TOGGLEFOLD, headerLine);
1796  		SCNotification scnN{};
1797  		scnN.nmhdr.code = SCN_FOLDINGSTATECHANGED;
1798  		scnN.nmhdr.hwndFrom = _hSelf;
1799  		scnN.nmhdr.idFrom = 0;
1800  		scnN.line = headerLine;
1801  		scnN.foldLevelNow = isFolded(headerLine)?1:0; 
1802  		::SendMessage(_hParent, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(&scnN));
1803  	}
1804  }
1805  void ScintillaEditView::foldAll(bool mode)
1806  {
1807  	auto maxLine = execute(SCI_GETLINECOUNT);
1808  	for (int line = 0; line < maxLine; ++line)
1809  	{
1810  		auto level = execute(SCI_GETFOLDLEVEL, line);
1811  		if (level & SC_FOLDLEVELHEADERFLAG)
1812  			if (isFolded(line) != mode)
1813  				fold(line, mode);
1814  	}
1815  }
1816  void ScintillaEditView::getText(char *dest, size_t start, size_t end) const
1817  {
1818  	Sci_TextRangeFull tr{};
1819  	tr.chrg.cpMin = static_cast<Sci_Position>(start);
1820  	tr.chrg.cpMax = static_cast<Sci_Position>(end);
1821  	tr.lpstrText = dest;
1822  	execute(SCI_GETTEXTRANGEFULL, 0, reinterpret_cast<LPARAM>(&tr));
1823  }
1824  generic_string ScintillaEditView::getGenericTextAsString(size_t start, size_t end) const
1825  {
1826  	assert(end > start);
1827  	const size_t bufSize = end - start + 1;
1828  	TCHAR *buf = new TCHAR[bufSize];
1829  	getGenericText(buf, bufSize, start, end);
1830  	generic_string text = buf;
1831  	delete[] buf;
1832  	return text;
1833  }
1834  void ScintillaEditView::getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end) const
1835  {
1836  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1837  	char *destA = new char[end - start + 1];
1838  	getText(destA, start, end);
1839  	size_t cp = execute(SCI_GETCODEPAGE);
1840  	const TCHAR *destW = wmc.char2wchar(destA, cp);
1841  	wcsncpy_s(dest, destlen, destW, _TRUNCATE);
1842  	delete [] destA;
1843  }
1844  void ScintillaEditView::getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end, intptr_t* mstart, intptr_t* mend) const
1845  {
1846  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1847  	char *destA = new char[end - start + 1];
1848  	getText(destA, start, end);
1849  	size_t cp = execute(SCI_GETCODEPAGE)    ;
1850  	const TCHAR *destW = wmc.char2wchar(destA, cp, mstart, mend);
1851  	wcsncpy_s(dest, destlen, destW, _TRUNCATE);
1852  	delete [] destA;
1853  }
1854  void ScintillaEditView::insertGenericTextFrom(size_t position, const TCHAR *text2insert) const
1855  {
1856  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1857  	size_t cp = execute(SCI_GETCODEPAGE);
1858  	const char *text2insertA = wmc.wchar2char(text2insert, cp);
1859  	execute(SCI_INSERTTEXT, position, reinterpret_cast<LPARAM>(text2insertA));
1860  }
1861  void ScintillaEditView::replaceSelWith(const char * replaceText)
1862  {
1863  	execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(replaceText));
1864  }
1865  void ScintillaEditView::getVisibleStartAndEndPosition(intptr_t* startPos, intptr_t* endPos)
1866  {
1867  	assert(startPos != NULL && endPos != NULL);
1868  	RECT rcEditView{};
1869  	getClientRect(rcEditView);
1870  	LRESULT pos = execute(SCI_POSITIONFROMPOINT, 0, 0);
1871  	LRESULT line = execute(SCI_LINEFROMPOSITION, pos);
1872  	*startPos = execute(SCI_POSITIONFROMLINE, line);
1873  	pos = execute(SCI_POSITIONFROMPOINT, static_cast<WPARAM>(rcEditView.right - rcEditView.left), static_cast<LPARAM>(rcEditView.bottom - rcEditView.top));
1874  	line = execute(SCI_LINEFROMPOSITION, pos);
1875  	*endPos = execute(SCI_GETLINEENDPOSITION, line);
1876  }
1877  char * ScintillaEditView::getWordFromRange(char * txt, size_t size, size_t pos1, size_t pos2)
1878  {
1879      if (!size)
1880  		return NULL;
1881      if (pos1 > pos2)
1882      {
1883          size_t tmp = pos1;
1884          pos1 = pos2;
1885          pos2 = tmp;
1886      }
1887      if (size < pos2 - pos1)
1888          return NULL;
1889      getText(txt, pos1, pos2);
1890  	return txt;
1891  }
1892  char * ScintillaEditView::getWordOnCaretPos(char * txt, size_t size)
1893  {
1894      if (!size)
1895  		return NULL;
1896      pair<size_t, size_t> range = getWordRange();
1897      return getWordFromRange(txt, size, range.first, range.second);
1898  }
1899  TCHAR * ScintillaEditView::getGenericWordOnCaretPos(TCHAR * txt, int size)
1900  {
1901  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1902  	size_t cp = execute(SCI_GETCODEPAGE);
1903  	char *txtA = new char[size + 1];
1904  	getWordOnCaretPos(txtA, size);
1905  	const TCHAR * txtW = wmc.char2wchar(txtA, cp);
1906  	wcscpy_s(txt, size, txtW);
1907  	delete [] txtA;
1908  	return txt;
1909  }
1910  char * ScintillaEditView::getSelectedText(char * txt, size_t size, bool expand)
1911  {
1912  	if (!size)
1913  		return NULL;
1914  	Sci_CharacterRangeFull range = getSelection();
1915  	if (range.cpMax == range.cpMin && expand)
1916  	{
1917  		expandWordSelection();
1918  		range = getSelection();
1919  	}
1920  	if (!(static_cast<Sci_Position>(size) > (range.cpMax - range.cpMin)))	
1921  	{
1922  		range.cpMax = range.cpMin + size -1;	
1923  	}
1924  	return getWordFromRange(txt, size, range.cpMin, range.cpMax);
1925  }
1926  TCHAR * ScintillaEditView::getGenericSelectedText(TCHAR * txt, int size, bool expand)
1927  {
1928  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1929  	size_t cp = execute(SCI_GETCODEPAGE);
1930  	char *txtA = new char[size + 1];
1931  	getSelectedText(txtA, size, expand);
1932  	const TCHAR * txtW = wmc.char2wchar(txtA, cp);
1933  	wcscpy_s(txt, size, txtW);
1934  	delete [] txtA;
1935  	return txt;
1936  }
1937  intptr_t ScintillaEditView::searchInTarget(const TCHAR * text2Find, size_t lenOfText2Find, size_t fromPos, size_t toPos) const
1938  {
1939  	execute(SCI_SETTARGETRANGE, fromPos, toPos);
1940  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1941  	size_t cp = execute(SCI_GETCODEPAGE);
1942  	const char *text2FindA = wmc.wchar2char(text2Find, cp);
1943  	size_t text2FindALen = strlen(text2FindA);
1944     	size_t len = (lenOfText2Find > text2FindALen) ? lenOfText2Find : text2FindALen;
1945  	return execute(SCI_SEARCHINTARGET, len, reinterpret_cast<LPARAM>(text2FindA));
1946  }
1947  void ScintillaEditView::appandGenericText(const TCHAR * text2Append) const
1948  {
1949  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1950  	size_t cp = execute(SCI_GETCODEPAGE);
1951  	const char *text2AppendA =wmc.wchar2char(text2Append, cp);
1952  	execute(SCI_APPENDTEXT, strlen(text2AppendA), reinterpret_cast<LPARAM>(text2AppendA));
1953  }
1954  void ScintillaEditView::addGenericText(const TCHAR * text2Append) const
1955  {
1956  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1957  	size_t cp = execute(SCI_GETCODEPAGE);
1958  	const char *text2AppendA =wmc.wchar2char(text2Append, cp);
1959  	execute(SCI_ADDTEXT, strlen(text2AppendA), reinterpret_cast<LPARAM>(text2AppendA));
1960  }
1961  void ScintillaEditView::addGenericText(const TCHAR * text2Append, intptr_t* mstart, intptr_t* mend) const
1962  {
1963  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1964  	size_t cp = execute(SCI_GETCODEPAGE);
1965  	const char *text2AppendA =wmc.wchar2char(text2Append, cp, mstart, mend);
1966  	execute(SCI_ADDTEXT, strlen(text2AppendA), reinterpret_cast<LPARAM>(text2AppendA));
1967  }
1968  intptr_t ScintillaEditView::replaceTarget(const TCHAR * str2replace, intptr_t fromTargetPos, intptr_t toTargetPos) const
1969  {
1970  	if (fromTargetPos != -1 || toTargetPos != -1)
1971  	{
1972  		execute(SCI_SETTARGETRANGE, fromTargetPos, toTargetPos);
1973  	}
1974  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1975  	size_t cp = execute(SCI_GETCODEPAGE);
1976  	const char *str2replaceA = wmc.wchar2char(str2replace, cp);
1977  	return execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(str2replaceA));
1978  }
1979  intptr_t ScintillaEditView::replaceTargetRegExMode(const TCHAR * re, intptr_t fromTargetPos, intptr_t toTargetPos) const
1980  {
1981  	if (fromTargetPos != -1 || toTargetPos != -1)
1982  	{
1983  		execute(SCI_SETTARGETRANGE, fromTargetPos, toTargetPos);
1984  	}
1985  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1986  	size_t cp = execute(SCI_GETCODEPAGE);
1987  	const char *reA = wmc.wchar2char(re, cp);
1988  	return execute(SCI_REPLACETARGETRE, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(reA));
1989  }
1990  void ScintillaEditView::showAutoComletion(size_t lenEntered, const TCHAR* list)
1991  {
1992  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1993  	size_t cp = execute(SCI_GETCODEPAGE);
1994  	const char *listA = wmc.wchar2char(list, cp);
1995  	execute(SCI_AUTOCSHOW, lenEntered, reinterpret_cast<LPARAM>(listA));
1996  	NppDarkMode::setDarkAutoCompletion();
1997  }
1998  void ScintillaEditView::showCallTip(size_t startPos, const TCHAR * def)
1999  {
2000  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2001  	size_t cp = execute(SCI_GETCODEPAGE);
2002  	const char *defA = wmc.wchar2char(def, cp);
2003  	execute(SCI_CALLTIPSHOW, startPos, reinterpret_cast<LPARAM>(defA));
2004  }
2005  generic_string ScintillaEditView::getLine(size_t lineNumber)
2006  {
2007  	size_t lineLen = execute(SCI_LINELENGTH, lineNumber);
2008  	const size_t bufSize = lineLen + 1;
2009  	std::unique_ptr<TCHAR[]> buf = std::make_unique<TCHAR[]>(bufSize);
2010  	getLine(lineNumber, buf.get(), bufSize);
2011  	return buf.get();
2012  }
2013  void ScintillaEditView::getLine(size_t lineNumber, TCHAR * line, size_t lineBufferLen)
2014  {
2015  	size_t lineLen = execute(SCI_LINELENGTH, lineNumber);
2016  	if (lineLen >= lineBufferLen)
2017  		return;
2018  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2019  	size_t cp = execute(SCI_GETCODEPAGE);
2020  	char *lineA = new char[lineBufferLen];
2021  	memset(lineA, 0x0, sizeof(char) * lineBufferLen);
2022  	execute(SCI_GETLINE, lineNumber, reinterpret_cast<LPARAM>(lineA));
2023  	const TCHAR *lineW = wmc.char2wchar(lineA, cp);
2024  	lstrcpyn(line, lineW, static_cast<int>(lineBufferLen));
2025  	delete [] lineA;
2026  }
2027  void ScintillaEditView::addText(size_t length, const char *buf)
2028  {
2029  	execute(SCI_ADDTEXT, length, reinterpret_cast<LPARAM>(buf));
2030  }
2031  void ScintillaEditView::beginOrEndSelect(bool isColumnMode)
2032  {
2033  	if (_beginSelectPosition == -1)
2034  	{
2035  		_beginSelectPosition = execute(SCI_GETCURRENTPOS);
2036  	}
2037  	else
2038  	{
2039  		execute(SCI_SETSELECTIONMODE, static_cast<WPARAM>(isColumnMode ? SC_SEL_RECTANGLE : SC_SEL_STREAM));
2040  		execute(SCI_SETANCHOR, static_cast<WPARAM>(_beginSelectPosition));
2041  		_beginSelectPosition = -1;
2042  	}
2043  }
2044  void ScintillaEditView::showMargin(int whichMarge, bool willBeShowed)
2045  {
2046  	if (whichMarge == _SC_MARGE_LINENUMBER)
2047  	{
2048  		bool forcedToHide = !willBeShowed;
2049  		updateLineNumbersMargin(forcedToHide);
2050  	}
2051  	else
2052  	{
2053  		DPIManager& dpiManager = NppParameters::getInstance()._dpiManager;
2054  		int width = dpiManager.scaleX(3);
2055  		if (whichMarge == _SC_MARGE_SYMBOL)
2056  			width = dpiManager.scaleX(16);
2057  		else if (whichMarge == _SC_MARGE_FOLDER)
2058  			width = dpiManager.scaleX(14);
2059  		execute(SCI_SETMARGINWIDTHN, whichMarge, willBeShowed ? width : 0);
2060  	}
2061  }
2062  void ScintillaEditView::showChangeHistoryMargin(bool willBeShowed)
2063  {
2064  	DPIManager& dpiManager = NppParameters::getInstance()._dpiManager;
2065  	int	width = dpiManager.scaleX(9);
2066  	execute(SCI_SETMARGINWIDTHN, _SC_MARGE_CHANGEHISTORY, willBeShowed ? width : 0);
2067  }
2068  void ScintillaEditView::updateBeginEndSelectPosition(bool is_insert, size_t position, size_t length)
2069  {
2070  	if (_beginSelectPosition != -1 && static_cast<intptr_t>(position) < _beginSelectPosition - 1)
2071  	{
2072  		if (is_insert)
2073  			_beginSelectPosition += length;
2074  		else
2075  			_beginSelectPosition -= length;
2076  		assert(_beginSelectPosition >= 0);
2077  	}
2078  }
2079  void ScintillaEditView::marginClick(Sci_Position position, int modifiers)
2080  {
2081  	size_t lineClick = execute(SCI_LINEFROMPOSITION, position, 0);
2082  	intptr_t levelClick = execute(SCI_GETFOLDLEVEL, lineClick, 0);
2083  	if (levelClick & SC_FOLDLEVELHEADERFLAG)
2084      {
2085  		if (modifiers & SCMOD_SHIFT)
2086          {
2087  			execute(SCI_SETFOLDEXPANDED, lineClick, 1);
2088  			expand(lineClick, true, true, 100, levelClick);
2089  		}
2090          else if (modifiers & SCMOD_CTRL)
2091          {
2092  			if (isFolded(lineClick))
2093              {
2094  				execute(SCI_SETFOLDEXPANDED, lineClick, 0);
2095  				expand(lineClick, false, true, 0, levelClick);
2096  			}
2097              else
2098              {
2099  				execute(SCI_SETFOLDEXPANDED, lineClick, 1);
2100  				expand(lineClick, true, true, 100, levelClick);
2101  			}
2102  		}
2103          else
2104          {
2105  			bool mode = isFolded(lineClick);
2106  			fold(lineClick, !mode);
2107  			runMarkers(true, lineClick, true, false);
2108  		}
2109  	}
2110  }
2111  void ScintillaEditView::expand(size_t& line, bool doExpand, bool force, intptr_t visLevels, intptr_t level)
2112  {
2113  	size_t lineMaxSubord = execute(SCI_GETLASTCHILD, line, level & SC_FOLDLEVELNUMBERMASK);
2114  	++line;
2115  	while (line <= lineMaxSubord)
2116      {
2117  		if (force)
2118          {
2119  			execute(((visLevels > 0) ? SCI_SHOWLINES : SCI_HIDELINES), line, line);
2120  		}
2121          else
2122          {
2123  			if (doExpand)
2124  				execute(SCI_SHOWLINES, line, line);
2125  		}
2126  		intptr_t levelLine = level;
2127  		if (levelLine == -1)
2128  			levelLine = execute(SCI_GETFOLDLEVEL, line, 0);
2129  		if (levelLine & SC_FOLDLEVELHEADERFLAG)
2130          {
2131  			if (force)
2132              {
2133  				if (visLevels > 1)
2134  					execute(SCI_SETFOLDEXPANDED, line, 1);
2135  				else
2136  					execute(SCI_SETFOLDEXPANDED, line, 0);
2137  				expand(line, doExpand, force, visLevels - 1);
2138  			}
2139              else
2140              {
2141  				if (doExpand)
2142                  {
2143  					if (!isFolded(line))
2144  						execute(SCI_SETFOLDEXPANDED, line, 1);
2145  					expand(line, true, force, visLevels - 1);
2146  				}
2147                  else
2148  					expand(line, false, force, visLevels - 1);
2149  			}
2150  		}
2151          else
2152  			++line;
2153  	}
2154  	runMarkers(true, 0, true, false);
2155  }
2156  void ScintillaEditView::performGlobalStyles()
2157  {
2158  	NppParameters& nppParams = NppParameters::getInstance();
2159  	const ScintillaViewParams& svp = nppParams.getSVP();
2160  	StyleArray& stylers = nppParams.getMiscStylerArray();
2161  	const Style* pStyle{};
2162  	if (svp._currentLineHiliteMode != LINEHILITE_NONE)
2163  	{
2164  		pStyle = stylers.findByName(TEXT("Current line background colour"));
2165  		if (pStyle)
2166  		{
2167  			execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, pStyle->_bgColor);
2168  		}
2169  	}
2170  	execute(SCI_SETCARETLINEFRAME, (svp._currentLineHiliteMode == LINEHILITE_FRAME) ? svp._currentLineFrameWidth : 0);
2171  	COLORREF selectColorBack = grey;
2172  	COLORREF selectColorFore = black;
2173  	pStyle = stylers.findByName(TEXT("Selected text colour"));
2174  	if (pStyle)
2175  	{
2176  		selectColorBack = pStyle->_bgColor;
2177  		selectColorFore = pStyle->_fgColor;
2178  	}
2179  	execute(SCI_SETSELBACK, 1, selectColorBack);
2180  	execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_SELECTION_INACTIVE_BACK, selectColorBack);
2181  	if (nppParams.isSelectFgColorEnabled())
2182  	{
2183  		execute(SCI_SETSELFORE, 1, selectColorFore);
2184  		long alphaSelectColorFore = selectColorFore;
2185  		alphaSelectColorFore |= 0xFF000000; 
2186  		execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_SELECTION_INACTIVE_TEXT, alphaSelectColorFore);
2187  	}
2188  	COLORREF caretColor = black;
2189  	pStyle = stylers.findByID(SCI_SETCARETFORE);
2190  	if (pStyle)
2191  	{
2192  		caretColor = pStyle->_fgColor;
2193  	}
2194  	execute(SCI_SETCARETFORE, caretColor);
2195  	COLORREF edgeColor = liteGrey;
2196  	pStyle = stylers.findByName(TEXT("Edge colour"));
2197  	if (pStyle)
2198  	{
2199  		edgeColor = pStyle->_fgColor;
2200  	}
2201  	execute(SCI_SETEDGECOLOUR, edgeColor);
2202  	::SendMessage(_hParent, NPPM_INTERNAL_EDGEMULTISETSIZE, 0, 0);
2203  	COLORREF foldMarginColor = grey;
2204  	COLORREF foldMarginHiColor = white;
2205  	pStyle = stylers.findByName(TEXT("Fold margin"));
2206  	if (pStyle)
2207  	{
2208  		foldMarginHiColor = pStyle->_fgColor;
2209  		foldMarginColor = pStyle->_bgColor;
2210  	}
2211  	execute(SCI_SETFOLDMARGINCOLOUR, true, foldMarginColor);
2212  	execute(SCI_SETFOLDMARGINHICOLOUR, true, foldMarginHiColor);
2213  	COLORREF bookmarkMarginColor = veryLiteGrey;
2214  	pStyle = stylers.findByName(TEXT("Bookmark margin"));
2215  	if (!pStyle)
2216  	{
2217  		pStyle = stylers.findByName(TEXT("Line number margin")); 
2218  		if (pStyle)                                              
2219  		{
2220  			bookmarkMarginColor = pStyle->_bgColor;
2221  		}
2222  	}
2223  	else
2224  	{
2225  		bookmarkMarginColor = pStyle->_bgColor;
2226  	}
2227  	execute(SCI_SETMARGINTYPEN, _SC_MARGE_SYMBOL, SC_MARGIN_COLOUR);
2228  	execute(SCI_SETMARGINBACKN, _SC_MARGE_SYMBOL, bookmarkMarginColor);
2229  	COLORREF changeHistoryMarginColor = veryLiteGrey;
2230  	pStyle = stylers.findByName(TEXT("Change History margin"));
2231  	if (!pStyle)
2232  	{
2233  		pStyle = stylers.findByName(TEXT("Line number margin"));
2234  		if (pStyle)
2235  		{
2236  			changeHistoryMarginColor = pStyle->_bgColor;
2237  		}
2238  	}
2239  	else
2240  	{
2241  		changeHistoryMarginColor = pStyle->_bgColor;
2242  	}
2243  	execute(SCI_SETMARGINTYPEN, _SC_MARGE_CHANGEHISTORY, SC_MARGIN_COLOUR);
2244  	execute(SCI_SETMARGINBACKN, _SC_MARGE_CHANGEHISTORY, changeHistoryMarginColor);
2245  	COLORREF urlHoveredFG = grey;
2246  	pStyle = stylers.findByName(TEXT("URL hovered"));
2247  	if (pStyle)
2248  	{
2249  		urlHoveredFG = pStyle->_fgColor;
2250  	}
2251  	execute(SCI_INDICSETHOVERFORE, URL_INDIC, urlHoveredFG);
2252  	COLORREF foldfgColor = white, foldbgColor = grey, activeFoldFgColor = red;
2253  	getFoldColor(foldfgColor, foldbgColor, activeFoldFgColor);
2254  	for (int j = 0 ; j < NB_FOLDER_STATE ; ++j)
2255  		defineMarker(_markersArray[FOLDER_TYPE][j], _markersArray[svp._folderStyle][j], foldfgColor, foldbgColor, activeFoldFgColor);
2256  	execute(SCI_MARKERENABLEHIGHLIGHT, true);
2257  	COLORREF wsSymbolFgColor = black;
2258  	pStyle = stylers.findByName(TEXT("White space symbol"));
2259  	if (pStyle)
2260  	{
2261  		wsSymbolFgColor = pStyle->_fgColor;
2262  	}
2263  	execute(SCI_SETWHITESPACEFORE, true, wsSymbolFgColor);
2264  	COLORREF eolCustomColor = liteGrey;
2265  	pStyle = stylers.findByName(TEXT("EOL custom color"));
2266  	if (pStyle)
2267  	{
2268  		eolCustomColor = pStyle->_fgColor;
2269  	}
2270  	setCRLF(eolCustomColor);
2271  	COLORREF npcCustomColor = liteGrey;
2272  	pStyle = stylers.findByName(g_npcStyleName);
2273  	if (pStyle)
2274  	{
2275  		npcCustomColor = pStyle->_fgColor;
2276  	}
2277  	setNpcAndCcUniEOL(npcCustomColor);
2278  }
2279  void ScintillaEditView::showNpc(bool willBeShowed, bool isSearchResult)
2280  {
2281  	auto& svp = NppParameters::getInstance().getSVP();
2282  	if (willBeShowed)
2283  	{
2284  		const auto& mode = static_cast<size_t>(svp._npcMode);
2285  		for (const auto& invChar : g_nonPrintingChars)
2286  		{
2287  			execute(SCI_SETREPRESENTATION, reinterpret_cast<WPARAM>(invChar.at(0)), reinterpret_cast<LPARAM>(invChar.at(mode)));
2288  		}
2289  		if (svp._npcCustomColor)
2290  		{
2291  			setNpcAndCcUniEOL();
2292  		}
2293  		showEOL(isShownEol());
2294  	}
2295  	else
2296  	{
2297  		execute(SCI_CLEARALLREPRESENTATIONS);
2298  		if (!isSearchResult && svp._eolMode != svp.roundedRectangleText)
2299  		{
2300  			setCRLF();
2301  		}
2302  		showCcUniEol(svp._ccUniEolShow);
2303  	}
2304  }
2305  void ScintillaEditView::showCcUniEol(bool willBeShowed, bool isSearchResult)
2306  {
2307  	auto& svp = NppParameters::getInstance().getSVP();
2308  	if (willBeShowed)
2309  	{
2310  		const auto& mode = static_cast<size_t>(svp._npcIncludeCcUniEol ? svp._npcMode : ScintillaViewParams::npcMode::abbreviation);
2311  		for (const auto& invChar : g_ccUniEolChars)
2312  		{
2313  			execute(SCI_SETREPRESENTATION, reinterpret_cast<WPARAM>(invChar.at(0)), reinterpret_cast<LPARAM>(invChar.at(mode)));
2314  		}
2315  		if (svp._npcIncludeCcUniEol && svp._npcCustomColor)
2316  		{
2317  			setNpcAndCcUniEOL();
2318  		}
2319  	}
2320  	else
2321  	{
2322  		execute(SCI_CLEARALLREPRESENTATIONS);
2323  		for (const auto& invChar : g_ccUniEolChars)
2324  		{
2325  			execute(SCI_SETREPRESENTATION, reinterpret_cast<WPARAM>(invChar.at(0)), reinterpret_cast<LPARAM>(g_ZWSP));
2326  			execute(SCI_SETREPRESENTATIONAPPEARANCE, reinterpret_cast<WPARAM>(invChar.at(0)), SC_REPRESENTATION_PLAIN);
2327  		}
2328  		if (!isSearchResult && svp._eolMode != svp.roundedRectangleText)
2329  		{
2330  			setCRLF();
2331  		}
2332  		if (svp._npcShow)
2333  		{
2334  			showNpc();
2335  			return; 
2336  		}
2337  	}
2338  	showEOL(isShownEol());
2339  }
2340  void ScintillaEditView::showIndentGuideLine(bool willBeShowed)
2341  {
2342  	auto typeDoc = _currentBuffer->getLangType();
2343  	const int docIndentMode = isPythonStyleIndentation(typeDoc) ? SC_IV_LOOKFORWARD : SC_IV_LOOKBOTH;
2344  	execute(SCI_SETINDENTATIONGUIDES, willBeShowed ? docIndentMode : SC_IV_NONE);
2345  }
2346  void ScintillaEditView::setLineIndent(size_t line, size_t indent) const
2347  {
2348  	Sci_CharacterRangeFull crange = getSelection();
2349  	int64_t posBefore = execute(SCI_GETLINEINDENTPOSITION, line);
2350  	execute(SCI_SETLINEINDENTATION, line, indent);
2351  	int64_t posAfter = execute(SCI_GETLINEINDENTPOSITION, line);
2352  	long long posDifference = posAfter - posBefore;
2353  	if (posAfter > posBefore)
2354  	{
2355  		if (crange.cpMin >= posBefore)
2356  		{
2357  			crange.cpMin += static_cast<Sci_Position>(posDifference);
2358  		}
2359  		if (crange.cpMax >= posBefore)
2360  		{
2361  			crange.cpMax += static_cast<Sci_Position>(posDifference);
2362  		}
2363  	}
2364  	else if (posAfter < posBefore)
2365  	{
2366  		if (crange.cpMin >= posAfter)
2367  		{
2368  			if (crange.cpMin >= posBefore)
2369  				crange.cpMin += static_cast<Sci_Position>(posDifference);
2370  			else
2371  				crange.cpMin = static_cast<Sci_Position>(posAfter);
2372  		}
2373  		if (crange.cpMax >= posAfter)
2374  		{
2375  			if (crange.cpMax >= posBefore)
2376  				crange.cpMax += static_cast<Sci_Position>(posDifference);
2377  			else
2378  				crange.cpMax = static_cast<Sci_Position>(posAfter);
2379  		}
2380  	}
2381  	execute(SCI_SETSEL, crange.cpMin, crange.cpMax);
2382  }
2383  void ScintillaEditView::updateLineNumberWidth()
2384  {
2385  	const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
2386  	if (svp._lineNumberMarginShow)
2387  	{
2388  		auto linesVisible = execute(SCI_LINESONSCREEN);
2389  		if (linesVisible)
2390  		{
2391  			int nbDigits = 0;
2392  			if (svp._lineNumberMarginDynamicWidth)
2393  			{
2394  				auto firstVisibleLineVis = execute(SCI_GETFIRSTVISIBLELINE);
2395  				auto lastVisibleLineVis = linesVisible + firstVisibleLineVis + 1;
2396  				auto lastVisibleLineDoc = execute(SCI_DOCLINEFROMVISIBLE, lastVisibleLineVis);
2397  				nbDigits = nbDigitsFromNbLines(lastVisibleLineDoc);
2398  				nbDigits = nbDigits < 3 ? 3 : nbDigits;
2399  			}
2400  			else
2401  			{
2402  				auto nbLines = execute(SCI_GETLINECOUNT);
2403  				nbDigits = nbDigitsFromNbLines(nbLines);
2404  				nbDigits = nbDigits < 4 ? 4 : nbDigits;
2405  			}
2406  			auto pixelWidth = 8 + nbDigits * execute(SCI_TEXTWIDTH, STYLE_LINENUMBER, reinterpret_cast<LPARAM>("8"));
2407  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, pixelWidth);
2408  		}
2409  	}
2410  }
2411  const char * ScintillaEditView::getCompleteKeywordList(std::basic_string<char> & kwl, LangType langType, int keywordIndex)
2412  {
2413  	kwl += " ";
2414  	const TCHAR *defKwl_generic = NppParameters::getInstance().getWordList(langType, keywordIndex);
2415  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2416  	const char * defKwl = wmc.wchar2char(defKwl_generic, CP_ACP);
2417  	kwl += defKwl?defKwl:"";
2418  	return kwl.c_str();
2419  }
2420  void ScintillaEditView::setMultiSelections(const ColumnModeInfos & cmi)
2421  {
2422  	for (size_t i = 0, len = cmi.size(); i < len ; ++i)
2423  	{
2424  		if (cmi[i].isValid())
2425  		{
2426  			intptr_t selStart = cmi[i]._direction == L2R?cmi[i]._selLpos:cmi[i]._selRpos;
2427  			intptr_t selEnd   = cmi[i]._direction == L2R?cmi[i]._selRpos:cmi[i]._selLpos;
2428  			execute(SCI_SETSELECTIONNSTART, i, selStart);
2429  			execute(SCI_SETSELECTIONNEND, i, selEnd);
2430  		}
2431  		if (cmi[i]._nbVirtualAnchorSpc)
2432  			execute(SCI_SETSELECTIONNANCHORVIRTUALSPACE, i, cmi[i]._nbVirtualAnchorSpc);
2433  		if (cmi[i]._nbVirtualCaretSpc)
2434  			execute(SCI_SETSELECTIONNCARETVIRTUALSPACE, i, cmi[i]._nbVirtualCaretSpc);
2435  	}
2436  }
2437  pair<size_t, size_t> ScintillaEditView::getSelectionLinesRange(intptr_t selectionNumber &bsol;* = -1 */) const
2438  {
2439  	size_t numSelections = execute(SCI_GETSELECTIONS);
2440  	size_t start_pos, end_pos;
2441  	if ((selectionNumber < 0) || (static_cast<size_t>(selectionNumber) >= numSelections))
2442  	{
2443  		start_pos = execute(SCI_GETSELECTIONSTART);
2444  		end_pos = execute(SCI_GETSELECTIONEND);
2445  	}
2446  	else
2447  	{
2448  		start_pos = execute(SCI_GETSELECTIONNSTART, selectionNumber);
2449  		end_pos = execute(SCI_GETSELECTIONNEND, selectionNumber);
2450  	}
2451  	size_t line1 = execute(SCI_LINEFROMPOSITION, start_pos);
2452  	size_t line2 = execute(SCI_LINEFROMPOSITION, end_pos);
2453  	if ((line1 != line2) && (static_cast<size_t>(execute(SCI_POSITIONFROMLINE, line2)) == end_pos))
2454  	{
2455  		--line2;
2456  	}
2457  	return pair<size_t, size_t>(line1, line2);
2458  }
2459  void ScintillaEditView::currentLinesUp() const
2460  {
2461  	execute(SCI_MOVESELECTEDLINESUP);
2462  }
2463  void ScintillaEditView::currentLinesDown() const
2464  {
2465  	execute(SCI_MOVESELECTEDLINESDOWN);
2466  	execute(SCI_SCROLLRANGE, execute(SCI_GETSELECTIONEND), execute(SCI_GETSELECTIONSTART));
2467  }
2468  intptr_t ScintillaEditView::caseConvertRange(intptr_t start, intptr_t end, TextCase caseToConvert)
2469  {
2470  	if (end <= start || uintptr_t(end) - uintptr_t(start) > INT_MAX/2)
2471  		return 0;
2472  	unsigned codepage = getCurrentBuffer()->getUnicodeMode() == uni8Bit ? _codepage : CP_UTF8;
2473  	int mbLen = int(end - start);
2474  	const int mbLenMax = 2 * mbLen + 1;  
2475  	char *mbStr = new char[mbLenMax];
2476  	getText(mbStr, start, end);
2477  	if (int wideLen = ::MultiByteToWideChar(codepage, 0, mbStr, mbLen, NULL, 0))
2478  	{
2479  		wchar_t *wideStr = new wchar_t[wideLen];  
2480  		::MultiByteToWideChar(codepage, 0, mbStr, mbLen, wideStr, wideLen);
2481  		changeCase(wideStr, wideLen, caseToConvert);
2482  		if (int mbLenOut = ::WideCharToMultiByte(codepage, 0, wideStr, wideLen, mbStr, mbLenMax, NULL, NULL))
2483  		{
2484  			mbLen = mbLenOut;
2485  			execute(SCI_SETTARGETRANGE, start, end);
2486  			execute(SCI_REPLACETARGET, mbLen, reinterpret_cast<LPARAM>(mbStr));
2487  		}
2488  		delete [] wideStr;
2489  	}
2490  	delete [] mbStr;
2491  	return (start + mbLen) - end;
2492  }
2493  void ScintillaEditView::changeCase(__inout wchar_t * const strWToConvert, const int & nbChars, const TextCase & caseToConvert) const
2494  {
2495  	if (strWToConvert == nullptr || nbChars == 0)
2496  		return;
2497  	switch (caseToConvert)
2498  	{
2499  		case UPPERCASE:
2500  		{
2501  			for (int i = 0; i < nbChars; ++i)
2502  			{
2503  				strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2504  			}
2505  			break; 
2506  		} 
2507  		case LOWERCASE:
2508  		{
2509  			for (int i = 0; i < nbChars; ++i)
2510  			{
2511  				strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2512  			}
2513  			break; 
2514  		} 
2515  		case TITLECASE_FORCE:
2516  		case TITLECASE_BLEND:
2517  		{
2518  			for (int i = 0; i < nbChars; ++i)
2519  			{
2520  				if (::IsCharAlphaW(strWToConvert[i]))
2521  				{
2522  					if ((i < 1) ? true : !::IsCharAlphaNumericW(strWToConvert[i - 1]))
2523  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2524  					else if (caseToConvert == TITLECASE_FORCE)
2525  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2526  					if ((i < 2) ? false : (strWToConvert[i - 1] == L'\'' && ::IsCharAlphaW(strWToConvert[i - 2])))
2527  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2528  				}
2529  			}
2530  			break; 
2531  		} 
2532  		case SENTENCECASE_FORCE:
2533  		case SENTENCECASE_BLEND:
2534  		{
2535  			bool isNewSentence = true;
2536  			bool wasEolR = false;
2537  			bool wasEolN = false;
2538  			for (int i = 0; i < nbChars; ++i)
2539  			{
2540  				if (::IsCharAlphaW(strWToConvert[i]))
2541  				{
2542  					if (isNewSentence)
2543  					{
2544  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2545  						isNewSentence = false;
2546  					}
2547  					else if (caseToConvert == SENTENCECASE_FORCE)
2548  					{
2549  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2550  					}
2551  					wasEolR = false;
2552  					wasEolN = false;
2553  					if (strWToConvert[i] == L'i' &&
2554  						((i < 1) ? false : (::iswspace(strWToConvert[i - 1]) || strWToConvert[i - 1] == L'(' || strWToConvert[i - 1] == L'"')) &&
2555  						((i + 1 == nbChars) ? false : (::iswspace(strWToConvert[i + 1]) || strWToConvert[i + 1] == L'\'')))
2556  					{
2557  						strWToConvert[i] = L'I';
2558  					}
2559  				}
2560  				else if (strWToConvert[i] == L'.' || strWToConvert[i] == L'!' || strWToConvert[i] == L'?')
2561  				{
2562  					if ((i + 1 == nbChars) ? true : ::IsCharAlphaNumericW(strWToConvert[i + 1]))
2563  						isNewSentence = false;
2564  					else
2565  						isNewSentence = true;
2566  				}
2567  				else if (strWToConvert[i] == L'\r')
2568  				{
2569  					if (wasEolR)
2570  						isNewSentence = true;
2571  					else
2572  						wasEolR = true;
2573  				}
2574  				else if (strWToConvert[i] == L'\n')
2575  				{
2576  					if (wasEolN)
2577  						isNewSentence = true;
2578  					else
2579  						wasEolN = true;
2580  				}
2581  			}
2582  			break;
2583  		} 
2584  		case INVERTCASE:
2585  		{
2586  			for (int i = 0; i < nbChars; ++i)
2587  			{
2588  				if (::IsCharLowerW(strWToConvert[i]))
2589  					strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2590  				else
2591  					strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2592  			}
2593  			break; 
2594  		} 
2595  		case RANDOMCASE:
2596  		{
2597  			for (int i = 0; i < nbChars; ++i)
2598  			{
2599  				if (::IsCharAlphaW(strWToConvert[i]))
2600  				{
2601  					if (std::rand() & true)
2602  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharUpperW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2603  					else
2604  						strWToConvert[i] = (WCHAR)(UINT_PTR)::CharLowerW(reinterpret_cast<LPWSTR>(strWToConvert[i]));
2605  				}
2606  			}
2607  			break; 
2608  		} 
2609  	} 
2610  }
2611  void ScintillaEditView::convertSelectedTextTo(const TextCase & caseToConvert)
2612  {
2613  	if (execute(SCI_GETSELECTIONS) > 1) 
2614  	{
2615          execute(SCI_BEGINUNDOACTION);
2616  		ColumnModeInfos cmi = getColumnModeSelectInfo();
2617  		bool reversed = !cmi.empty() && cmi.back()._selLpos < cmi.front()._selLpos;
2618  		std::sort(cmi.begin(), cmi.end(), SortInPositionOrder());
2619  		intptr_t sizedelta = 0;
2620  		for (ColumnModeInfo& info : cmi)
2621  		{
2622  			info._selLpos += sizedelta;
2623  			sizedelta += caseConvertRange(info._selLpos, info._selRpos + sizedelta, caseToConvert);
2624  			info._selRpos += sizedelta;
2625  		}
2626  		if (reversed)
2627  			std::reverse(cmi.begin(), cmi.end());
2628  		setMultiSelections(cmi);
2629  		execute(SCI_ENDUNDOACTION);
2630  		return;
2631  	}
2632  	size_t selectionStart = execute(SCI_GETSELECTIONSTART);
2633  	size_t selectionEnd = execute(SCI_GETSELECTIONEND);
2634  	if (selectionStart < selectionEnd)
2635  	{
2636  		selectionEnd += caseConvertRange(selectionStart, selectionEnd, caseToConvert);
2637  		execute(SCI_SETSEL, selectionStart, selectionEnd);
2638  	}
2639  }
2640  pair<size_t, size_t> ScintillaEditView::getWordRange()
2641  {
2642  	size_t caretPos = execute(SCI_GETCURRENTPOS, 0, 0);
2643  	size_t startPos = execute(SCI_WORDSTARTPOSITION, caretPos, true);
2644  	size_t endPos = execute(SCI_WORDENDPOSITION, caretPos, true);
2645      return pair<size_t, size_t>(startPos, endPos);
2646  }
2647  bool ScintillaEditView::expandWordSelection()
2648  {
2649      pair<size_t, size_t> wordRange = 	getWordRange();
2650      if (wordRange.first != wordRange.second)
2651  	{
2652          execute(SCI_SETSELECTIONSTART, wordRange.first);
2653          execute(SCI_SETSELECTIONEND, wordRange.second);
2654  		return true;
2655  	}
2656  	return false;
2657  }
2658  TCHAR* int2str(TCHAR* str, int strLen, int number, int base, int nbDigits, ColumnEditorParam::leadingChoice lead)
2659  {
2660  	if (nbDigits >= strLen) return NULL;
2661  	if (base == 2)
2662  	{
2663  		const unsigned int MASK_ULONG_BITFORT = 0x80000000;
2664  		int nbBits = sizeof(unsigned int) * 8;
2665  		int nbBit2Shift = (nbDigits >= nbBits) ? nbBits : (nbBits - nbDigits);
2666  		unsigned long mask = MASK_ULONG_BITFORT >> nbBit2Shift;
2667  		int i = 0;
2668  		for (; mask > 0; ++i)
2669  		{
2670  			str[i] = (mask & number) ? '1' : '0';
2671  			mask >>= 1;
2672  		}
2673  		str[i] = '\0';
2674  		if (lead == ColumnEditorParam::spaceLeading)
2675  		{
2676  			for (TCHAR* j = str; *j != '\0'; ++j)
2677  			{
2678  				if ((*j == '1') || (*(j + 1) == '\0'))
2679  				{
2680  					break;
2681  				}
2682  				else
2683  				{
2684  					*j = ' ';
2685  				}
2686  			}
2687  		}
2688  		else if (lead != ColumnEditorParam::zeroLeading)
2689  		{
2690  			for (TCHAR* j = str; *j != '\0'; ++j)
2691  			{
2692  				if (*j == '1' || *(j + 1) == '\0')
2693  				{
2694  					wcscpy_s(str, strLen, j);
2695  					break;
2696  				}
2697  			}
2698  			int i = lstrlen(str);
2699  			for (; i < nbDigits; ++i)
2700  			{
2701  				str[i] = ' ';
2702  			}
2703  			str[i] = '\0';
2704  		}
2705  	}
2706  	else
2707  	{
2708  		constexpr size_t bufSize = 64;
2709  		TCHAR f[bufSize] = { '\0' };
2710  		TCHAR fStr[2] = TEXT("d");
2711  		if (base == 16)
2712  			fStr[0] = 'X';
2713  		else if (base == 8)
2714  			fStr[0] = 'o';
2715  		if (lead == ColumnEditorParam::zeroLeading)
2716  		{
2717  			swprintf(f, bufSize, TEXT("%%.%d%s"), nbDigits, fStr);
2718  		}
2719  		else if (lead == ColumnEditorParam::spaceLeading)
2720  		{
2721  			swprintf(f, bufSize, TEXT("%%%d%s"), nbDigits, fStr);
2722  		}
2723  		else
2724  		{
2725  			swprintf(f, bufSize, TEXT("%%-%d%s"), nbDigits, fStr);
2726  		}
2727  		swprintf(str, strLen, f, number);
2728  	}
2729  	return str;
2730  }
2731  ColumnModeInfos ScintillaEditView::getColumnModeSelectInfo()
2732  {
2733  	ColumnModeInfos columnModeInfos;
2734  	if (execute(SCI_GETSELECTIONS) > 1) 
2735  	{
2736  		intptr_t nbSel = execute(SCI_GETSELECTIONS);
2737  		for (int i = 0 ; i < nbSel ; ++i)
2738  		{
2739  			intptr_t absPosSelStartPerLine = execute(SCI_GETSELECTIONNANCHOR, i);
2740  			intptr_t absPosSelEndPerLine = execute(SCI_GETSELECTIONNCARET, i);
2741  			intptr_t nbVirtualAnchorSpc = execute(SCI_GETSELECTIONNANCHORVIRTUALSPACE, i);
2742  			intptr_t nbVirtualCaretSpc = execute(SCI_GETSELECTIONNCARETVIRTUALSPACE, i);
2743  			if (absPosSelStartPerLine == absPosSelEndPerLine && execute(SCI_SELECTIONISRECTANGLE))
2744  			{
2745  				bool dir = nbVirtualAnchorSpc<nbVirtualCaretSpc?L2R:R2L;
2746  				columnModeInfos.push_back(ColumnModeInfo(absPosSelStartPerLine, absPosSelEndPerLine, i, dir, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2747  			}
2748  			else if (absPosSelStartPerLine > absPosSelEndPerLine)
2749  				columnModeInfos.push_back(ColumnModeInfo(absPosSelEndPerLine, absPosSelStartPerLine, i, R2L, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2750  			else
2751  				columnModeInfos.push_back(ColumnModeInfo(absPosSelStartPerLine, absPosSelEndPerLine, i, L2R, nbVirtualAnchorSpc, nbVirtualCaretSpc));
2752  		}
2753  	}
2754  	return columnModeInfos;
2755  }
2756  void ScintillaEditView::columnReplace(ColumnModeInfos & cmi, const TCHAR *str)
2757  {
2758  	intptr_t totalDiff = 0;
2759  	for (size_t i = 0, len = cmi.size(); i < len ; ++i)
2760  	{
2761  		if (cmi[i].isValid())
2762  		{
2763  			intptr_t len2beReplace = cmi[i]._selRpos - cmi[i]._selLpos;
2764  			intptr_t diff = lstrlen(str) - len2beReplace;
2765  			cmi[i]._selLpos += totalDiff;
2766  			cmi[i]._selRpos += totalDiff;
2767  			bool hasVirtualSpc = cmi[i]._nbVirtualAnchorSpc > 0;
2768  			if (hasVirtualSpc) 
2769  			{
2770  				for (intptr_t j = 0, k = cmi[i]._selLpos; j < cmi[i]._nbVirtualCaretSpc ; ++j, ++k)
2771  				{
2772  					execute(SCI_INSERTTEXT, k, reinterpret_cast<LPARAM>(" "));
2773  				}
2774  				cmi[i]._selLpos += cmi[i]._nbVirtualAnchorSpc;
2775  				cmi[i]._selRpos += cmi[i]._nbVirtualCaretSpc;
2776  			}
2777  			execute(SCI_SETTARGETRANGE, cmi[i]._selLpos, cmi[i]._selRpos);
2778  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2779  			size_t cp = execute(SCI_GETCODEPAGE);
2780  			const char *strA = wmc.wchar2char(str, cp);
2781  			execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(strA));
2782  			if (hasVirtualSpc)
2783  			{
2784  				totalDiff += cmi[i]._nbVirtualAnchorSpc + lstrlen(str);
2785  				cmi[i]._nbVirtualAnchorSpc = 0;
2786  				cmi[i]._nbVirtualCaretSpc = 0;
2787  			}
2788  			else
2789  			{
2790  				totalDiff += diff;
2791  			}
2792  			cmi[i]._selRpos += diff;
2793  		}
2794  	}
2795  }
2796  void ScintillaEditView::columnReplace(ColumnModeInfos & cmi, int initial, int incr, int repeat, UCHAR format, ColumnEditorParam::leadingChoice lead)
2797  {
2798  	assert(repeat > 0);
2799  	if (cmi.size() <= 0)
2800  		return;
2801  	UCHAR f = format & MASK_FORMAT;
2802  	int base = 10;
2803  	if (f == BASE_16)
2804  		base = 16;
2805  	else if (f == BASE_08)
2806  		base = 8;
2807  	else if (f == BASE_02)
2808  		base = 2;
2809  	const int stringSize = 512;
2810  	TCHAR str[stringSize];
2811  	std::vector<int> numbers;
2812  	{
2813  		int curNumber = initial;
2814  		const size_t kiMaxSize = cmi.size();
2815  		while (numbers.size() < kiMaxSize)
2816  		{
2817  			for (int i = 0; i < repeat; i++)
2818  			{
2819  				numbers.push_back(curNumber);
2820  				if (numbers.size() >= kiMaxSize)
2821  				{
2822  					break;
2823  				}
2824  			}
2825  			curNumber += incr;
2826  		}
2827  	}
2828  	assert(numbers.size()> 0);
2829  	const int kibEnd = getNbDigits(*numbers.rbegin(), base);
2830  	const int kibInit = getNbDigits(initial, base);
2831  	const int kib = std::max<int>(kibInit, kibEnd);
2832  	intptr_t totalDiff = 0;
2833  	const size_t len = cmi.size();
2834  	for (size_t i = 0 ; i < len ; i++)
2835  	{
2836  		if (cmi[i].isValid())
2837  		{
2838  			const intptr_t len2beReplaced = cmi[i]._selRpos - cmi[i]._selLpos;
2839  			const intptr_t diff = kib - len2beReplaced;
2840  			cmi[i]._selLpos += totalDiff;
2841  			cmi[i]._selRpos += totalDiff;
2842  			int2str(str, stringSize, numbers.at(i), base, kib, lead);
2843  			const bool hasVirtualSpc = cmi[i]._nbVirtualAnchorSpc > 0;
2844  			if (hasVirtualSpc) 
2845  			{
2846  				for (intptr_t j = 0, k = cmi[i]._selLpos; j < cmi[i]._nbVirtualCaretSpc ; ++j, ++k)
2847  				{
2848  					execute(SCI_INSERTTEXT, k, reinterpret_cast<LPARAM>(" "));
2849  				}
2850  				cmi[i]._selLpos += cmi[i]._nbVirtualAnchorSpc;
2851  				cmi[i]._selRpos += cmi[i]._nbVirtualCaretSpc;
2852  			}
2853  			execute(SCI_SETTARGETRANGE, cmi[i]._selLpos, cmi[i]._selRpos);
2854  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2855  			size_t cp = execute(SCI_GETCODEPAGE);
2856  			const char *strA = wmc.wchar2char(str, cp);
2857  			execute(SCI_REPLACETARGET, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(strA));
2858  			if (hasVirtualSpc)
2859  			{
2860  				totalDiff += cmi[i]._nbVirtualAnchorSpc + lstrlen(str);
2861  				cmi[i]._nbVirtualAnchorSpc = 0;
2862  				cmi[i]._nbVirtualCaretSpc = 0;
2863  			}
2864  			else
2865  			{
2866  				totalDiff += diff;
2867  			}
2868  			cmi[i]._selRpos += diff;
2869  		}
2870  	}
2871  }
2872  bool ScintillaEditView::getIndicatorRange(size_t indicatorNumber, size_t* from, size_t* to, size_t* cur)
2873  {
2874  	size_t curPos = execute(SCI_GETCURRENTPOS);
2875  	size_t indicMsk = execute(SCI_INDICATORALLONFOR, curPos);
2876  	if (!(static_cast<int>(indicMsk) & (1 << indicatorNumber)))
2877  		return false;
2878  	size_t startPos = execute(SCI_INDICATORSTART, indicatorNumber, curPos);
2879  	size_t endPos = execute(SCI_INDICATOREND, indicatorNumber, curPos);
2880  	if ((curPos < startPos) || (curPos > endPos))
2881  		return false;
2882  	if (from) *from = startPos;
2883  	if (to) *to = endPos;
2884  	if (cur) *cur = curPos;
2885  	return true;
2886  }
2887  void ScintillaEditView::scrollPosToCenter(size_t pos)
2888  {
2889  	_positionRestoreNeeded = false;
2890  	execute(SCI_GOTOPOS, pos);
2891  	size_t line = execute(SCI_LINEFROMPOSITION, pos);
2892  	size_t firstVisibleDisplayLine = execute(SCI_GETFIRSTVISIBLELINE);
2893  	size_t firstVisibleDocLine = execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLine);
2894  	size_t nbLine = execute(SCI_LINESONSCREEN, firstVisibleDisplayLine);
2895  	size_t lastVisibleDocLine = execute(SCI_DOCLINEFROMVISIBLE, firstVisibleDisplayLine + nbLine);
2896  	size_t middleLine;
2897  	if (line - firstVisibleDocLine < lastVisibleDocLine - line)
2898  		middleLine = firstVisibleDocLine + nbLine/2;
2899  	else
2900  		middleLine = lastVisibleDocLine -  nbLine/2;
2901  	size_t nbLines2scroll =  line - middleLine;
2902  	scroll(0, nbLines2scroll);
2903  	execute(SCI_ENSUREVISIBLEENFORCEPOLICY, line);
2904  }
2905  void ScintillaEditView::hideLines()
2906  {
2907  	size_t startLine = execute(SCI_LINEFROMPOSITION, execute(SCI_GETSELECTIONSTART));
2908  	size_t endLine = execute(SCI_LINEFROMPOSITION, execute(SCI_GETSELECTIONEND));
2909  	size_t nbLines = execute(SCI_GETLINECOUNT);
2910  	if (nbLines < 3)
2911  		return;	
2912  	if (!startLine)
2913  		++startLine;
2914  	if (endLine == (nbLines-1))
2915  		--endLine;
2916  	if (startLine > endLine)
2917  		return;	
2918  	int scope = 0;
2919  	bool recentMarkerWasOpen = false;
2920  	auto removeMarker = [this, &scope, &recentMarkerWasOpen](size_t line)
2921  	{
2922  		auto state = execute(SCI_MARKERGET, line);
2923  		bool closePresent = (state & (1 << MARK_HIDELINESEND)) != 0;
2924  		bool openPresent = (state & (1 << MARK_HIDELINESBEGIN)) != 0;
2925  		if (closePresent)
2926  		{
2927  			execute(SCI_MARKERDELETE, line, MARK_HIDELINESEND);
2928  			recentMarkerWasOpen = false;
2929  			--scope;
2930  		}
2931  		if (openPresent)
2932  		{
2933  			execute(SCI_MARKERDELETE, line, MARK_HIDELINESBEGIN);
2934  			recentMarkerWasOpen = true;
2935  			++scope;
2936  		}
2937  	};
2938  	size_t startMarker = startLine - 1;
2939  	size_t endMarker = endLine + 1;
2940  	for (size_t i = startMarker; i <= endMarker; ++i)
2941  		removeMarker(i);
2942  	if (scope == 0 && recentMarkerWasOpen)
2943  	{
2944  		while (scope == 0)
2945  			removeMarker(--startMarker);
2946  		while (scope != 0)
2947  			removeMarker(++endMarker);
2948  	}
2949  	else
2950  	{
2951  		while (scope < 0)
2952  			removeMarker(--startMarker);
2953  		while (scope > 0)
2954  			removeMarker(++endMarker);
2955  	}
2956  	execute(SCI_MARKERADD, startMarker, MARK_HIDELINESBEGIN);
2957  	execute(SCI_MARKERADD, endMarker, MARK_HIDELINESEND);
2958  	_currentBuffer->setHideLineChanged(true, startMarker);
2959  }
2960  bool ScintillaEditView::markerMarginClick(intptr_t lineNumber)
2961  {
2962  	auto state = execute(SCI_MARKERGET, lineNumber);
2963  	bool openPresent = (state & (1 << MARK_HIDELINESBEGIN)) != 0;
2964  	bool closePresent = (state & (1 << MARK_HIDELINESEND)) != 0;
2965  	if (!openPresent && !closePresent)
2966  		return false;
2967  	if (openPresent)
2968  	{
2969  		_currentBuffer->setHideLineChanged(false, lineNumber);
2970  	}
2971  	if (closePresent)
2972  	{
2973  		openPresent = false;
2974  		for (lineNumber--; lineNumber >= 0 && !openPresent; lineNumber--)
2975  		{
2976  			state = execute(SCI_MARKERGET, lineNumber);
2977  			openPresent = (state & (1 << MARK_HIDELINESBEGIN)) != 0;
2978  		}
2979  		if (openPresent)
2980  		{
2981  			_currentBuffer->setHideLineChanged(false, lineNumber + 1);
2982  		}
2983  	}
2984  	return true;
2985  }
2986  void ScintillaEditView::notifyMarkers(Buffer * buf, bool isHide, size_t location, bool del)
2987  {
2988  	if (buf != _currentBuffer)	
2989  		return;
2990  	runMarkers(isHide, location, false, del);
2991  }
2992  void ScintillaEditView::runMarkers(bool doHide, size_t searchStart, bool endOfDoc, bool doDelete)
2993  {
2994  	size_t maxLines = execute(SCI_GETLINECOUNT);
2995  	if (doHide)
2996  	{
2997  		auto startHiding = searchStart;
2998  		bool isInSection = false;
2999  		for (auto i = searchStart; i < maxLines; ++i)
3000  		{
3001  			auto state = execute(SCI_MARKERGET, i);
3002  			if ( ((state & (1 << MARK_HIDELINESEND)) != 0) )
3003  			{
3004  				if (isInSection)
3005  				{
3006  					execute(SCI_HIDELINES, startHiding, i-1);
3007  					if (!endOfDoc)
3008  					{
3009  						return;	
3010  					}	
3011  				}
3012  				isInSection = false;
3013  			}
3014  			if ((state & (1 << MARK_HIDELINESBEGIN)) != 0)
3015  			{
3016  				isInSection = true;
3017  				startHiding = i+1;
3018  			}
3019  		}
3020  	}
3021  	else
3022  	{
3023  		auto startShowing = searchStart;
3024  		bool isInSection = false;
3025  		for (auto i = searchStart; i < maxLines; ++i)
3026  		{
3027  			auto state = execute(SCI_MARKERGET, i);
3028  			if ( ((state & (1 << MARK_HIDELINESEND)) != 0) )
3029  			{
3030  				if (doDelete)
3031  				{
3032  					execute(SCI_MARKERDELETE, i, MARK_HIDELINESEND);
3033  					if (!endOfDoc)
3034  					{
3035  						return;	
3036  					}	
3037  				}
3038  				 else if (isInSection)
3039  				 {
3040  					if (startShowing >= i)
3041  					{	
3042  						if (!endOfDoc)
3043  						{
3044  							return;
3045  						}
3046  						else
3047  						{
3048  							continue;
3049  						}
3050  					}
3051  					execute(SCI_SHOWLINES, startShowing, i-1);
3052  					if (!endOfDoc)
3053  					{
3054  						return;	
3055  					}	
3056  					isInSection = false;
3057  				}
3058  			}
3059  			if ((state & (1 << MARK_HIDELINESBEGIN)) != 0)
3060  			{
3061  				if (doDelete)
3062  				{
3063  					execute(SCI_MARKERDELETE, i, MARK_HIDELINESBEGIN);
3064  				}
3065  				else
3066  				{
3067  					isInSection = true;
3068  					startShowing = i+1;
3069  				}
3070  			}
3071  			auto levelLine = execute(SCI_GETFOLDLEVEL, i, 0);
3072  			if (levelLine & SC_FOLDLEVELHEADERFLAG)
3073  			{	
3074  				if (isInSection && !isFolded(i))
3075  				{
3076  					execute(SCI_SHOWLINES, startShowing, i);
3077  				}
3078  			}
3079  		}
3080  	}
3081  }
3082  void ScintillaEditView::setTabSettings(Lang *lang)
3083  {
3084  	if (lang && lang->_tabSize != -1 && lang->_tabSize != 0)
3085  	{
3086  		if (lang->_langID == L_JAVASCRIPT)
3087  		{
3088  			Lang *ljs = NppParameters::getInstance().getLangFromID(L_JS);
3089  			execute(SCI_SETTABWIDTH, ljs->_tabSize > 0 ? ljs->_tabSize : lang->_tabSize);
3090  			execute(SCI_SETUSETABS, !ljs->_isTabReplacedBySpace);
3091  			return;
3092  		}
3093  		execute(SCI_SETTABWIDTH, lang->_tabSize);
3094  		execute(SCI_SETUSETABS, !lang->_isTabReplacedBySpace);
3095  	}
3096      else
3097  	{
3098  		const NppGUI & nppgui = NppParameters::getInstance().getNppGUI();
3099  		execute(SCI_SETTABWIDTH, nppgui._tabSize  > 0 ? nppgui._tabSize : 4);
3100  		execute(SCI_SETUSETABS, !nppgui._tabReplacedBySpace);
3101  	}
3102  }
3103  void ScintillaEditView::insertNewLineAboveCurrentLine()
3104  {
3105  	generic_string newline = getEOLString();
3106  	const auto current_line = getCurrentLineNumber();
3107  	if (current_line == 0)
3108  	{
3109  		insertGenericTextFrom(0, newline.c_str());
3110  	}
3111  	else
3112  	{
3113  		const auto eol_length = newline.length();
3114  		const auto position = execute(SCI_POSITIONFROMLINE, current_line) - eol_length;
3115  		insertGenericTextFrom(position, newline.c_str());
3116  	}
3117  	execute(SCI_SETEMPTYSELECTION, execute(SCI_POSITIONFROMLINE, current_line));
3118  }
3119  void ScintillaEditView::insertNewLineBelowCurrentLine()
3120  {
3121  	generic_string newline = getEOLString();
3122  	const auto line_count = execute(SCI_GETLINECOUNT);
3123  	const auto current_line = getCurrentLineNumber();
3124  	if (current_line == line_count - 1)
3125  	{
3126  		appandGenericText(newline.c_str());
3127  	}
3128  	else
3129  	{
3130  		const auto eol_length = newline.length();
3131  		const auto position = eol_length + execute(SCI_GETLINEENDPOSITION, current_line);
3132  		insertGenericTextFrom(position, newline.c_str());
3133  	}
3134  	execute(SCI_SETEMPTYSELECTION, execute(SCI_POSITIONFROMLINE, current_line + 1));
3135  }
3136  void ScintillaEditView::sortLines(size_t fromLine, size_t toLine, ISorter* pSort)
3137  {
3138  	if (fromLine >= toLine)
3139  	{
3140  		return;
3141  	}
3142  	const auto startPos = execute(SCI_POSITIONFROMLINE, fromLine);
3143  	const auto endPos = execute(SCI_POSITIONFROMLINE, toLine) + execute(SCI_LINELENGTH, toLine);
3144  	const generic_string text = getGenericTextAsString(startPos, endPos);
3145  	std::vector<generic_string> splitText = stringSplit(text, getEOLString());
3146  	const size_t lineCount = execute(SCI_GETLINECOUNT);
3147  	const bool sortEntireDocument = toLine == lineCount - 1;
3148  	if (!sortEntireDocument)
3149  	{
3150  		if (splitText.rbegin()->empty())
3151  		{
3152  			splitText.pop_back();
3153  		}
3154  	}
3155  	assert(toLine - fromLine + 1 == splitText.size());
3156  	const std::vector<generic_string> sortedText = pSort->sort(splitText);
3157  	generic_string joined = stringJoin(sortedText, getEOLString());
3158  	if (sortEntireDocument)
3159  	{
3160  		assert(joined.length() == text.length());
3161  	}
3162  	else
3163  	{
3164  		assert(joined.length() + getEOLString().length() == text.length());
3165  		joined += getEOLString();
3166  	}
3167  	if (text != joined)
3168  	{
3169  		replaceTarget(joined.c_str(), startPos, endPos);
3170  	}
3171  }
3172  bool ScintillaEditView::isTextDirectionRTL() const
3173  {
3174  	long exStyle = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3175  	return (exStyle & WS_EX_LAYOUTRTL) != 0;
3176  }
3177  void ScintillaEditView::changeTextDirection(bool isRTL)
3178  {
3179  	long exStyle = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3180  	exStyle = isRTL ? (exStyle | WS_EX_LAYOUTRTL) : (exStyle & (~WS_EX_LAYOUTRTL));
3181  	::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, exStyle);
3182  	if (isRTL)
3183  	{
3184  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT, SCI_CHARLEFT);
3185  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_SHIFT << 16), SCI_CHARLEFTEXTEND);
3186  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARLEFTRECTEXTEND);
3187  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_CTRL << 16), SCI_WORDLEFT);
3188  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDLEFTEXTEND);
3189  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT, SCI_CHARRIGHT);
3190  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_SHIFT << 16), SCI_CHARRIGHTEXTEND);
3191  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARRIGHTRECTEXTEND);
3192  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_CTRL << 16), SCI_WORDRIGHT);
3193  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDRIGHTEXTEND);
3194  	}
3195  	else
3196  	{
3197  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT, SCI_CHARRIGHT);
3198  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_SHIFT << 16), SCI_CHARRIGHTEXTEND);
3199  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARRIGHTRECTEXTEND);
3200  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + (SCMOD_CTRL << 16), SCI_WORDRIGHT);
3201  		execute(SCI_ASSIGNCMDKEY, SCK_RIGHT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDRIGHTEXTEND);
3202  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT, SCI_CHARLEFT);
3203  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_SHIFT << 16), SCI_CHARLEFTEXTEND);
3204  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_ALT) << 16), SCI_CHARLEFTRECTEXTEND);
3205  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + (SCMOD_CTRL << 16), SCI_WORDLEFT);
3206  		execute(SCI_ASSIGNCMDKEY, SCK_LEFT + ((SCMOD_SHIFT + SCMOD_CTRL) << 16), SCI_WORDLEFTEXTEND);
3207  	}
3208  }
3209  generic_string ScintillaEditView::getEOLString()
3210  {
3211  	intptr_t eol_mode = execute(SCI_GETEOLMODE);
3212  	if (eol_mode == SC_EOL_CRLF)
3213  	{
3214  		return TEXT("\r\n");
3215  	}
3216  	else if (eol_mode == SC_EOL_LF)
3217  	{
3218  		return TEXT("\n");
3219  	}
3220  	else
3221  	{
3222  		return TEXT("\r");
3223  	}
3224  }
3225  void ScintillaEditView::setBorderEdge(bool doWithBorderEdge)
3226  {
3227  	long style = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_STYLE));
3228  	long exStyle = static_cast<long>(::GetWindowLongPtr(_hSelf, GWL_EXSTYLE));
3229  	if (NppDarkMode::isEnabled())
3230  	{
3231  		exStyle &= ~WS_EX_CLIENTEDGE;
3232  		if (doWithBorderEdge)
3233  			style |= WS_BORDER;
3234  		else
3235  			style &= ~WS_BORDER;
3236  	}
3237  	else
3238  	{
3239  		style &= ~WS_BORDER;
3240  		if (doWithBorderEdge)
3241  			exStyle |= WS_EX_CLIENTEDGE;
3242  		else
3243  			exStyle &= ~WS_EX_CLIENTEDGE;
3244  	}
3245  	::SetWindowLongPtr(_hSelf, GWL_STYLE, style);
3246  	::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, exStyle);
3247  	::SetWindowPos(_hSelf, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
3248  }
3249  void ScintillaEditView::getFoldColor(COLORREF& fgColor, COLORREF& bgColor, COLORREF& activeFgColor)
3250  {
3251  	StyleArray & stylers = NppParameters::getInstance().getMiscStylerArray();
3252  	const Style * pStyle = stylers.findByName(TEXT("Fold"));
3253  	if (pStyle)
3254  	{
3255  		fgColor = pStyle->_bgColor;
3256  		bgColor = pStyle->_fgColor;
3257  	}
3258  	pStyle = stylers.findByName(TEXT("Fold active"));
3259  	if (pStyle)
3260  	{
3261  		activeFgColor = pStyle->_fgColor;
3262  	}
3263  }
3264  int ScintillaEditView::getTextZoneWidth() const
3265  {
3266  	RECT editorRect;
3267  	getClientRect(editorRect);
3268  	intptr_t marginWidths = 0;
3269  	for (int m = 0; m < 4; ++m)
3270  	{
3271  		marginWidths += execute(SCI_GETMARGINWIDTHN, m);
3272  	}
3273  	return editorRect.right - editorRect.left - static_cast<LONG>(marginWidths);
3274  }
3275  pair<size_t, size_t> ScintillaEditView::getSelectedCharsAndLinesCount(long long maxSelectionsForLineCount &bsol;* = -1 */) const
3276  {
3277  	pair<size_t, size_t> selectedCharsAndLines(0, 0);
3278  	selectedCharsAndLines.first = getUnicodeSelectedLength();
3279  	size_t numSelections = execute(SCI_GETSELECTIONS);
3280  	if (numSelections == 1)
3281  	{
3282  		pair<size_t, size_t> lineRange = getSelectionLinesRange();
3283  		selectedCharsAndLines.second = lineRange.second - lineRange.first + 1;
3284  	}
3285  	else if (execute(SCI_SELECTIONISRECTANGLE))
3286  	{
3287  		selectedCharsAndLines.second = numSelections;
3288  	}
3289  	else if ((maxSelectionsForLineCount == -1) ||  
3290  		(numSelections <= static_cast<size_t>(maxSelectionsForLineCount)))
3291  	{
3292  		vector< pair <size_t, size_t> > v;
3293  		for (size_t s = 0; s < numSelections; ++s)
3294  		{
3295  			v.push_back(getSelectionLinesRange(s));
3296  		}
3297  		sort(v.begin(), v.end());
3298  		intptr_t previousSecondLine = -1;
3299  		for (auto& lineRange : v)
3300  		{
3301  			selectedCharsAndLines.second += lineRange.second - lineRange.first;
3302  			if (lineRange.first != static_cast<size_t>(previousSecondLine))
3303  			{
3304  				++selectedCharsAndLines.second;
3305  			}
3306  			previousSecondLine = static_cast<intptr_t>(lineRange.second);
3307  		}
3308  	}
3309  	return selectedCharsAndLines;
3310  }
3311  size_t ScintillaEditView::getUnicodeSelectedLength() const
3312  {
3313  	size_t length = 0;
3314  	size_t numSelections = execute(SCI_GETSELECTIONS);
3315  	for (size_t s = 0; s < numSelections; ++s)
3316  	{
3317  		size_t start = execute(SCI_GETSELECTIONNSTART, s);
3318  		size_t end = execute(SCI_GETSELECTIONNEND, s);
3319  		length += execute(SCI_COUNTCHARACTERS, start, end);
3320  	}
3321  	return length;
3322  }
3323  void ScintillaEditView::markedTextToClipboard(int indiStyle, bool doAll &bsol;*= false*/)
3324  {
3325  	int styleIndicators[] =
3326  	{
3327  		SCE_UNIVERSAL_FOUND_STYLE_EXT1,
3328  		SCE_UNIVERSAL_FOUND_STYLE_EXT2,
3329  		SCE_UNIVERSAL_FOUND_STYLE_EXT3,
3330  		SCE_UNIVERSAL_FOUND_STYLE_EXT4,
3331  		SCE_UNIVERSAL_FOUND_STYLE_EXT5,
3332  		-1  
3333  	};
3334  	if (!doAll)
3335  	{
3336  		styleIndicators[0] = indiStyle;
3337  		styleIndicators[1] = -1;
3338  	}
3339  	std::vector<std::pair<size_t, generic_string>> styledVect;
3340  	const generic_string cr = TEXT("\r");
3341  	const generic_string lf = TEXT("\n");
3342  	bool textContainsLineEndingChar = false;
3343  	for (int si = 0; styleIndicators[si] != -1; ++si)
3344  	{
3345  		size_t pos = execute(SCI_INDICATOREND, styleIndicators[si], 0);
3346  		if (pos > 0)
3347  		{
3348  			bool atEndOfIndic = execute(SCI_INDICATORVALUEAT, styleIndicators[si], 0) != 0;
3349  			size_t prevPos = pos;
3350  			if (atEndOfIndic) prevPos = 0;
3351  			do
3352  			{
3353  				if (atEndOfIndic)
3354  				{
3355  					generic_string styledText = getGenericTextAsString(prevPos, pos);
3356  					if (!textContainsLineEndingChar)
3357  					{
3358  						if (styledText.find(cr) != std::string::npos ||
3359  							styledText.find(lf) != std::string::npos)
3360  						{
3361  							textContainsLineEndingChar = true;
3362  						}
3363  					}
3364  					styledVect.push_back(::make_pair(prevPos, styledText));
3365  				}
3366  				atEndOfIndic = !atEndOfIndic;
3367  				prevPos = pos;
3368  				pos = execute(SCI_INDICATOREND, styleIndicators[si], pos);
3369  			} while (pos != prevPos);
3370  		}
3371  	}
3372  	if (styledVect.size() > 0)
3373  	{
3374  		if (doAll)
3375  		{
3376  			std::sort(styledVect.begin(), styledVect.end());
3377  		}
3378  		const generic_string delim =
3379  			(textContainsLineEndingChar && styledVect.size() > 1) ?
3380  			TEXT("\r\n----\r\n") : TEXT("\r\n");
3381  		generic_string joined;
3382  		for (auto& item : styledVect)
3383  		{
3384  			joined += delim + item.second;
3385  		}
3386  		joined = joined.substr(delim.length());
3387  		if (styledVect.size() > 1)
3388  		{
3389  			joined += TEXT("\r\n");
3390  		}
3391  		str2Clipboard(joined, NULL);
3392  	}
3393  }
3394  void ScintillaEditView::removeAnyDuplicateLines()
3395  {
3396  	size_t fromLine = 0, toLine = 0;
3397  	bool hasLineSelection = false;
3398  	auto selStart = execute(SCI_GETSELECTIONSTART);
3399  	auto selEnd = execute(SCI_GETSELECTIONEND);
3400  	hasLineSelection = selStart != selEnd;
3401  	if (hasLineSelection)
3402  	{
3403  		const pair<size_t, size_t> lineRange = getSelectionLinesRange();
3404  		if (lineRange.first == lineRange.second)
3405  		{
3406  			return;
3407  		}
3408  		fromLine = lineRange.first;
3409  		toLine = lineRange.second;
3410  	}
3411  	else
3412  	{
3413  		fromLine = 0;
3414  		toLine = execute(SCI_GETLINECOUNT) - 1;
3415  	}
3416  	if (fromLine >= toLine)
3417  	{
3418  		return;
3419  	}
3420  	const auto startPos = execute(SCI_POSITIONFROMLINE, fromLine);
3421  	const auto endPos = execute(SCI_POSITIONFROMLINE, toLine) + execute(SCI_LINELENGTH, toLine);
3422  	const generic_string text = getGenericTextAsString(startPos, endPos);
3423  	std::vector<generic_string> linesVect = stringSplit(text, getEOLString());
3424  	const size_t lineCount = execute(SCI_GETLINECOUNT);
3425  	const bool doingEntireDocument = toLine == lineCount - 1;
3426  	if (!doingEntireDocument)
3427  	{
3428  		if (linesVect.rbegin()->empty())
3429  		{
3430  			linesVect.pop_back();
3431  		}
3432  	}
3433  	size_t origSize = linesVect.size();
3434  	size_t newSize = vecRemoveDuplicates(linesVect);
3435  	if (origSize != newSize)
3436  	{
3437  		generic_string joined = stringJoin(linesVect, getEOLString());
3438  		if (!doingEntireDocument)
3439  		{
3440  			joined += getEOLString();
3441  		}
3442  		if (text != joined)
3443  		{
3444  			replaceTarget(joined.c_str(), startPos, endPos);
3445  		}
3446  	}
3447  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</h3>
            <pre><code>1  void TPredicateNode::GetVariables(TStrV& Variables) {
2    if (Left != NULL) { Left->GetVariables(Variables); }
3    if (Right != NULL) { Right->GetVariables(Variables); }
4    if (Op == NOP) {
5      if (Atom.Lvar != "" ) { Variables.Add(Atom.Lvar); }
6      if (Atom.Rvar != "" ) { Variables.Add(Atom.Rvar); }
7    }
8  }
9  void TPredicate::GetVariables(TStrV& Variables) {
10    Root->GetVariables(Variables);
11  }
12  TBool TPredicate::Eval() {
13    TPredicateNode* Curr = Root;
14    TPredicateNode* Prev = NULL;
15    while (!(Curr == NULL && Prev == Root)) {
16      if (Prev == NULL || Prev == Curr->Parent) {
17        if (Curr->Left != NULL) {
18          Prev = Curr;
19          Curr = Curr->Left;
20        } else if (Curr->Right != NULL) {
21          Prev = Curr;
22          Curr = Curr->Right;
23        } else {
24          Curr->Result = EvalAtomicPredicate(Curr->Atom);
25          Prev = Curr;
26          Curr = Curr->Parent;
27        }
28      } else if (Prev == Curr->Left) {
29        switch (Curr->Op) {
30          case NOT: {
31            Assert(Curr->Right == NULL);
32            Curr->Result = !(Prev->Result);
33            Prev = Curr;
34            Curr = Curr->Parent;
35            break;
36          }
37          case AND: {
38            Assert(Curr->Right != NULL);
39            if (!Prev->Result) {
40              Curr->Result = false;
41              Prev = Curr;
42              Curr = Curr->Parent;
43            } else {
44              Prev = Curr;
45              Curr = Curr->Right;
46            }
47            break;
48          }
49          case OR: {
50            Assert(Curr->Right != NULL);
51            if (Prev->Result) {
52              Curr->Result = true;
53              Prev = Curr;
54              Curr = Curr->Parent;
55            } else {
56              Prev = Curr;
57              Curr = Curr->Right;
58            }
59            break;
60          }
61          case NOP: {
62            break;
63          }
64        }
65      } else {
66        Assert(Prev == Curr->Right);
67        switch (Curr->Op) {
68          case NOT: {
69            Assert(Curr->Left == NULL);
70            Curr->Result = !(Prev->Result);
71            break;
72          }
73          case AND: {
74            Assert(Curr->Left != NULL);
75            Assert(Curr->Left->Result);
76            Curr->Result = Prev->Result;
77            break;
78          }
79          case OR: {
80            Assert(Curr->Left != NULL);
81            Assert(!Curr->Left->Result);
82            Curr->Result = Prev->Result;
83            break;
84          }
85          case NOP: {
86            break;
87          }
88        }
89        Prev = Curr;
90        Curr = Curr->Parent;
91      }
92    }
93    return Root->Result;
94  }
95  TBool TPredicate::EvalAtomicPredicate(const TAtomicPredicate& Atom) {
96    switch (Atom.Type) {
97      case atInt: {
98        if (Atom.IsConst) { 
99          return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), Atom.IntConst, Atom.Compare); 
100        }
101        return EvalAtom<TInt>(IntVars.GetDat(Atom.Lvar), IntVars.GetDat(Atom.Rvar), Atom.Compare);
102      }
103      case atFlt: {
104        if (Atom.IsConst) { 
105          return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), Atom.FltConst, Atom.Compare); 
106        }
107        return EvalAtom<TFlt>(FltVars.GetDat(Atom.Lvar), FltVars.GetDat(Atom.Rvar), Atom.Compare);
108      }
109      case atStr: {
110        if (Atom.IsConst) { 
111          return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), Atom.StrConst, Atom.Compare); 
112        }
113        return EvalAtom<TStr>(StrVars.GetDat(Atom.Lvar), StrVars.GetDat(Atom.Rvar), Atom.Compare);
114      }
115    }
116    return false;
117  }
118  TInt const TTable::Last = -1;
119  TInt const TTable::Invalid = -2;
120  TInt TTable::UseMP = 1;
121  TRowIterator& TRowIterator::operator++(int) {
122    return this->Next();
123  }
124  TRowIterator& TRowIterator::Next() {
125    CurrRowIdx = Table->Next[CurrRowIdx];
126    return *this;
127  }
128  bool TRowIterator::operator < (const TRowIterator& RowI) const{
129    if (CurrRowIdx == TTable::Last) { return false; }
130    if (RowI.CurrRowIdx == TTable::Last) { return true; }
131    return CurrRowIdx < RowI.CurrRowIdx;
132  }
133  bool TRowIterator::operator == (const TRowIterator& RowI) const {
134    return CurrRowIdx == RowI.CurrRowIdx;
135  }
136  TInt TRowIterator::GetRowIdx() const {
137    return CurrRowIdx;
138  }
139  TInt TRowIterator::GetIntAttr(TInt ColIdx) const {
140    return Table->IntCols[ColIdx][CurrRowIdx];
141  }
142  TFlt TRowIterator::GetFltAttr(TInt ColIdx) const {
143    return Table->FltCols[ColIdx][CurrRowIdx];
144  }
145  TStr TRowIterator::GetStrAttr(TInt ColIdx) const {
146    return Table->GetStrValIdx(ColIdx, CurrRowIdx);
147  }
148  TInt TRowIterator::GetIntAttr(const TStr& Col) const {
149    TInt ColIdx = Table->GetColIdx(Col);
150    return Table->IntCols[ColIdx][CurrRowIdx];
151  }
152  TFlt TRowIterator::GetFltAttr(const TStr& Col) const {
153    TInt ColIdx = Table->GetColIdx(Col);
154    return Table->FltCols[ColIdx][CurrRowIdx];
155  }
156  TStr TRowIterator::GetStrAttr(const TStr& Col) const {
157    return Table->GetStrVal(Col, CurrRowIdx);
158  }
159  TInt TRowIterator::GetStrMapByName(const TStr& Col) const {
160    TInt ColIdx = Table->GetColIdx(Col);
161    return Table->StrColMaps[ColIdx][CurrRowIdx];
162  }
163  TInt TRowIterator::GetStrMapById(TInt ColIdx) const {
164    return Table->StrColMaps[ColIdx][CurrRowIdx];
165  }
166  TBool TRowIterator::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
167    TBool Result;
168    switch (Val.GetType()) {
169      case atInt:
170        Result = TPredicate::EvalAtom(GetIntAttr(ColIdx), Val.GetInt(), Cmp);
171        break;
172      case atFlt:
173        Result = TPredicate::EvalAtom(GetFltAttr(ColIdx), Val.GetFlt(), Cmp);
174        break;
175      case atStr:
176        Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val.GetStr(), Cmp);
177        break;
178      default:
179        Result = TBool(false);
180    }
181    return Result;
182  }
183  TBool TRowIterator::CompareAtomicConstTStr(TInt ColIdx, const TStr& Val, TPredComp Cmp) {
184    TBool Result;
185    Result = TPredicate::EvalStrAtom(GetStrAttr(ColIdx), Val, Cmp);
186    return Result;
187  }
188  TRowIteratorWithRemove::TRowIteratorWithRemove(TInt RowIdx, TTable* TablePtr) :
189    CurrRowIdx(RowIdx), Table(TablePtr), Start(RowIdx == TablePtr->FirstValidRow) {}
190  TRowIteratorWithRemove& TRowIteratorWithRemove::operator++(int) {
191    return this->Next();
192  }
193  TRowIteratorWithRemove& TRowIteratorWithRemove::Next() {
194    CurrRowIdx = GetNextRowIdx();
195    Start = false;
196    Assert(CurrRowIdx != TTable::Invalid);
197    return *this;
198  }
199  bool TRowIteratorWithRemove::operator < (const TRowIteratorWithRemove& RowI) const {
200    if (CurrRowIdx == TTable::Last) { return false; }
201    if (RowI.CurrRowIdx == TTable::Last) { return true; }
202    return CurrRowIdx < RowI.CurrRowIdx;
203  }
204  bool TRowIteratorWithRemove::operator == (const TRowIteratorWithRemove& RowI) const {
205    return CurrRowIdx == RowI.CurrRowIdx;
206  }
207  TInt TRowIteratorWithRemove::GetRowIdx() const {
208    return CurrRowIdx;
209  }
210  TInt TRowIteratorWithRemove::GetNextRowIdx() const {
211    return (Start ? Table->FirstValidRow : Table->Next[CurrRowIdx]);
212  }
213  TInt TRowIteratorWithRemove::GetNextIntAttr(TInt ColIdx) const {
214    return Table->IntCols[ColIdx][GetNextRowIdx()];
215  }
216  TFlt TRowIteratorWithRemove::GetNextFltAttr(TInt ColIdx) const {
217    return Table->FltCols[ColIdx][GetNextRowIdx()];
218  }
219  TStr TRowIteratorWithRemove::GetNextStrAttr(TInt ColIdx) const {
220    return Table->GetStrValIdx(ColIdx, GetNextRowIdx());
221  }
222  TInt TRowIteratorWithRemove::GetNextIntAttr(const TStr& Col) const {
223    TInt ColIdx = Table->GetColIdx(Col);
224    return Table->IntCols[ColIdx][GetNextRowIdx()];
225  }
226  TFlt TRowIteratorWithRemove::GetNextFltAttr(const TStr& Col) const {
227    TInt ColIdx = Table->GetColIdx(Col);
228    return Table->FltCols[ColIdx][GetNextRowIdx()];
229  }
230  TStr TRowIteratorWithRemove::GetNextStrAttr(const TStr& Col) const {
231    return Table->GetStrVal(Col, GetNextRowIdx());
232  }
233  TBool TRowIteratorWithRemove::IsFirst() const {
234    return CurrRowIdx == Table->FirstValidRow;
235  }
236  void TRowIteratorWithRemove::RemoveNext() {
237    Table->RemoveRow(GetNextRowIdx(), CurrRowIdx);
238  }
239  TBool TRowIteratorWithRemove::CompareAtomicConst(TInt ColIdx, const TPrimitive& Val, TPredComp Cmp) {
240    TBool Result;
241    switch (Val.GetType()) {
242      case atInt:
243        Result = TPredicate::EvalAtom(GetNextIntAttr(ColIdx), Val.GetInt(), Cmp);
244        break;
245      case atFlt:
246        Result = TPredicate::EvalAtom(GetNextFltAttr(ColIdx), Val.GetFlt(), Cmp);
247        break;
248      case atStr:
249        Result = TPredicate::EvalStrAtom(GetNextStrAttr(ColIdx), Val.GetStr(), Cmp);
250        break;
251      default:
252        Result = TBool(false);
253    }
254    return Result;
255  }
256  TTable::TTable(): Context(new TTableContext), NumRows(0), NumValidRows(0),
257    FirstValidRow(0), LastValidRow(-1) {}
258  TTable::TTable(TTableContext* Context): Context(Context), NumRows(0),
259    NumValidRows(0), FirstValidRow(0), LastValidRow(-1) {}
260  TTable::TTable(const Schema& TableSchema, TTableContext* Context): Context(Context), 
261    NumRows(0), NumValidRows(0), FirstValidRow(0), LastValidRow(-1), IsNextDirty(0) {
262    TInt IntColCnt = 0;
263    TInt FltColCnt = 0;
264    TInt StrColCnt = 0;
265    for (TInt i = 0; i < TableSchema.Len(); i++) {
266      TStr ColName = TableSchema[i].Val1;
267      TAttrType ColType = TableSchema[i].Val2;
268      AddSchemaCol(ColName, ColType);
269      switch (ColType) {
270        case atInt:
271          AddColType(ColName, atInt, IntColCnt);
272          IntColCnt++;
273          break;
274        case atFlt:
275          AddColType(ColName, atFlt, FltColCnt);
276          FltColCnt++;
277          break;
278        case atStr:
279          AddColType(ColName, atStr, StrColCnt);
280          StrColCnt++;
281          break;
282      }
283    }
284    IntCols = TVec<TIntV>(IntColCnt);
285    FltCols = TVec<TFltV>(FltColCnt);
286    StrColMaps = TVec<TIntV>(StrColCnt);
287  }
288  void TTable::GenerateColTypeMap(THash<TStr,TPair<TInt,TInt> > & ColTypeIntMap) {
289    ColTypeMap.Clr();
290    Sch.Clr();
291    for (THash<TStr,TPair<TInt,TInt> >::TIter it = ColTypeIntMap.BegI(); it < ColTypeIntMap.EndI(); it++) {
292      TPair<TInt,TInt> dat = it.GetDat();
293      switch (dat.GetVal1()) {
294        case 0:
295          AddColType(it.GetKey(), atInt, dat.GetVal2());
296          AddSchemaCol(it.GetKey(), atInt);
297          break;
298        case 1:
299          AddColType(it.GetKey(), atFlt, dat.GetVal2());
300          AddSchemaCol(it.GetKey(), atFlt);
301          break;
302        case 2:
303          AddColType(it.GetKey(), atStr, dat.GetVal2());
304          AddSchemaCol(it.GetKey(), atStr);
305          break;
306      }
307    }
308    IsNextDirty = 0;
309  }
310  void TTable::LoadTableShM(TShMIn& ShMIn, TTableContext* ContextTable) {
311    Context = ContextTable;
312    NumRows = TInt(ShMIn);
313    NumValidRows = TInt(ShMIn);
314    FirstValidRow = TInt(ShMIn);
315    LastValidRow = TInt(ShMIn);
316    Next.LoadShM(ShMIn);
317    TLoadVecInit Fn;
318    IntCols.LoadShM(ShMIn, Fn);
319    FltCols.Load(ShMIn);
320    StrColMaps.LoadShM(ShMIn, Fn);
321    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
322    ColTypeIntMap.LoadShM(ShMIn);
323    GenerateColTypeMap(ColTypeIntMap);
324  }
325  TTable::TTable(TSIn& SIn, TTableContext* Context): Context(Context), NumRows(SIn),
326    NumValidRows(SIn), FirstValidRow(SIn), LastValidRow(SIn), Next(SIn), IntCols(SIn),
327    FltCols(SIn), StrColMaps(SIn) {
328    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap(SIn);
329    GenerateColTypeMap(ColTypeIntMap);
330  }
331  TTable::TTable(const TIntIntH& H, const TStr& Col1, const TStr& Col2,
332   TTableContext* Context, const TBool IsStrKeys) : Context(Context), NumRows(H.Len()),
333    NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
334      TAttrType KeyType = IsStrKeys ? atStr : atInt;
335      AddSchemaCol(Col1, KeyType);
336      AddSchemaCol(Col2, atInt);
337      AddColType(Col1, KeyType, 0);
338      AddColType(Col2, atInt, 1);
339      if (IsStrKeys) {
340        StrColMaps = TVec<TIntV>(1);
341        IntCols = TVec<TIntV>(1);
342        H.GetKeyV(StrColMaps[0]);
343        H.GetDatV(IntCols[0]);
344      } else {
345        IntCols = TVec<TIntV>(2);
346        H.GetKeyV(IntCols[0]);
347        H.GetDatV(IntCols[1]);
348      }
349      Next = TIntV(NumRows);
350      for (TInt i = 0; i < NumRows; i++) {
351        Next[i] = i+1;
352      }
353      Next[NumRows-1] = Last;
354      IsNextDirty = 0;
355      InitIds();
356  }
357  TTable::TTable(const TIntFltH& H, const TStr& Col1, const TStr& Col2,
358   TTableContext* Context, const TBool IsStrKeys) : Context(Context),
359    NumRows(H.Len()), NumValidRows(H.Len()), FirstValidRow(0), LastValidRow(H.Len()-1) {
360    TAttrType KeyType = IsStrKeys ? atStr : atInt;
361    AddSchemaCol(Col1, KeyType);
362    AddSchemaCol(Col2, atFlt);
363    AddColType(Col1, KeyType, 0);
364    AddColType(Col2, atFlt, 0);
365    if (IsStrKeys) {
366      StrColMaps = TVec<TIntV>(1);
367      H.GetKeyV(StrColMaps[0]);
368    } else {
369      IntCols = TVec<TIntV>(1);
370      H.GetKeyV(IntCols[0]);
371    }
372    FltCols = TVec<TFltV>(1);
373    H.GetDatV(FltCols[0]);
374    Next = TIntV(NumRows);
375    for (TInt i = 0; i < NumRows; i++) {
376      Next[i] = i+1;
377    }
378    Next[NumRows-1] = Last;
379    IsNextDirty = 0;
380    InitIds();
381  }
382  TTable::TTable(const TTable& Table, const TIntV& RowIDs) : Context(Table.Context),
383    Sch(Table.Sch), SrcCol(Table.SrcCol), DstCol(Table.DstCol), EdgeAttrV(Table.EdgeAttrV),
384    SrcNodeAttrV(Table.SrcNodeAttrV), DstNodeAttrV(Table.DstNodeAttrV),
385    CommonNodeAttrs(Table.CommonNodeAttrs) {
386    ColTypeMap = Table.ColTypeMap;
387    IntCols = TVec<TIntV>(Table.IntCols.Len());
388    FltCols = TVec<TFltV>(Table.FltCols.Len());
389    StrColMaps = TVec<TIntV>(Table.StrColMaps.Len());
390    FirstValidRow = 0;
391    LastValidRow = -1;
392    NumRows = 0;
393    NumValidRows = 0;
394    AddSelectedRows(Table, RowIDs);
395    IsNextDirty = 0;
396    InitIds();
397  }
398  void TTable::GetSchema(const TStr& InFNm, Schema& S, const char& Separator) {
399    TSsParser Ss(InFNm, '\t', false, false, false);
400    TInt rowsToPeek = 1000;
401    TInt currRow = 0;
402    TInt lastComment = 0;
403    while (Ss.Next()) {
404      if (Ss.IsCmt()) {
405        lastComment += 1;
406      }
407      else break;
408    }
409    if (Ss.Eof()) {TExcept::Throw("No Data to determine attribute types!");}
410    TInt numCols = Ss.GetFlds();
411    TVec<TAttrType> colAttrV(numCols);
412    colAttrV.PutAll(atInt);
413    while (true) {
414      for (TInt i = 0; i < numCols; i++) {
415        if (Ss.IsInt(i)) {
416        }
417        else if (Ss.IsFlt(i)) {
418          colAttrV[i] = atFlt;
419        }
420        else {
421          colAttrV[i] = atStr;
422        }
423      }
424      currRow++;
425      if (currRow > rowsToPeek || Ss.Eof()) break;
426      Ss.Next();
427    }
428    TSsParser SsNames(InFNm, Separator, false, false, false);
429    for (int i = 0; i < lastComment; i++) { SsNames.Next();}
430    TVec<TStr> attrV;
431    TStr first(SsNames[0]);
432    int begin = 0;
433    TStr comment('#');
434    if (first != comment) {
435      for (int i = 1; i < first.Len(); i++){
436        if (first[i] != ' ') { begin = i; break;}
437      }
438      attrV.Add(first.GetSubStr(begin));
439    }
440    for (int i = 1; i < SsNames.GetFlds(); i++) {attrV.Add(SsNames[i]);}
441    for (TInt i = 0; i < numCols; i++) {
442      S.Add(TPair<TStr,TAttrType>(attrV[i],colAttrV[i]));
443    } 
444  }
445  #ifdef GCC_ATOMIC
446  void TTable::LoadSSPar(PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols, 
447                          const char& Separator, TBool HasTitleLine) {
448    TInt RowLen = T->Sch.Len();
449    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
450    for (TInt i = 0; i < RowLen; i++) {
451      ColTypes[i] = T->GetSchemaColType(i);
452    }
453    TSsParserMP Ss(InFNm, Separator);
454    Ss.SkipCommentLines();
455    if (HasTitleLine) {
456      Ss.Next();
457      if (S.Len() != Ss.GetFlds()) {
458        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
459      }
460      for (TInt i = 0; i < Ss.GetFlds(); i++) {
461        TInt L = strlen(Ss[i]);
462        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
463        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
464      }
<span onclick='openModal()' class='match'>465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
</span>469    uint64 Rem = Len - Pos;
470    int NumThreads = omp_get_max_threads();
471    uint64 Delta = Rem / NumThreads;
472    if (Delta < 1) Delta = 1;
473    TVec<uint64> StartIntV(NumThreads);
474    TVec<uint64> LineCountV(NumThreads);
475    TVec<uint64> PrefixSumV(NumThreads);
476    StartIntV[0] = Pos;
477    for (int i = 1; i < NumThreads; i++) {
478      StartIntV[i] = StartIntV[i-1] + Delta;
479    }
480    StartIntV.Add(Len);
481    omp_set_num_threads(NumThreads);
482    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
483    for (int i = 0; i < NumThreads; i++) {
484      LineCountV[i] = Ss.CountNewLinesInRange(StartIntV[i], StartIntV[i+1]);
485      Cnt += LineCountV[i];
486    }
487    PrefixSumV[0] = 0;
488    for (int i = 1; i < NumThreads; i++) {
489      PrefixSumV[i] = PrefixSumV[i-1] + LineCountV[i-1];
490    }
491    Ss.SetStreamPos(Pos);
492    TInt IntColIdx = 0;
493    TInt FltColIdx = 0;
494    for (TInt i = 0; i < RowLen; i++) {
495      switch (ColTypes[i]) {
496        case atInt:
497          T->IntCols[IntColIdx].Gen(Cnt);
498          IntColIdx++;
499          break;
500        case atFlt:
501          T->FltCols[FltColIdx].Gen(Cnt);
502          FltColIdx++;
503          break;
504        case atStr:
505          break;
506      }
507    }
508    Cnt = 0;
509    omp_set_num_threads(NumThreads);
510    #pragma omp parallel for schedule(dynamic) reduction(+:Cnt)
511    for (int i = 0; i < NumThreads; i++) {
512      TVec<uint64> LineStartPosV = Ss.GetStartPosV(StartIntV[i], StartIntV[i+1]);
513      for (uint64 k = 0; k < (uint64) LineStartPosV.Len(); k++) {
514        TVec<char*> FieldsV;
515        Ss.NextFromIndex(LineStartPosV[k], FieldsV);
516        if (FieldsV.Len() != S.Len()) {
517          TExcept::Throw("Error reading tsv file");
518        }
519        TInt IntColIdx = 0;
520        TInt FltColIdx = 0;
521        TInt RowIdx = PrefixSumV[i] + k;
522        for (TInt j = 0; j < RowLen; j++) {
523          switch (ColTypes[j]) {
524            case atInt:
525              if (RelevantCols.Len() == 0) {
526                T->IntCols[IntColIdx][RowIdx] = \
527                  (Ss.GetIntFromFldV(FieldsV, j));
528              } else {
529                T->IntCols[IntColIdx][RowIdx] = \
530                  (Ss.GetIntFromFldV(FieldsV, RelevantCols[j]));
531              }
532              IntColIdx++;
533              break;
534            case atFlt:
535              if (RelevantCols.Len() == 0) {
536                T->FltCols[FltColIdx][RowIdx] = \
537                  (Ss.GetFltFromFldV(FieldsV, j));
538              } else {
539                T->FltCols[FltColIdx][RowIdx] = \
540                  (Ss.GetFltFromFldV(FieldsV, RelevantCols[j]));
541              }
542              FltColIdx++;
543              break;
544            case atStr:
545              TExcept::Throw("TTable::LoadSS:: Str Col found\n");
546              break;
547          }
548        }
549        Cnt++;
550      }
551    }
552    T->NumRows = Cnt;
553    T->NumValidRows = T->NumRows;
554    T->Next.Clr();
555    T->Next.Gen(Cnt);
556    omp_set_num_threads(NumThreads);
557    #pragma omp parallel for schedule(dynamic, 10000)
558    for (int64 i = 0; i < Cnt-1; i++) {
559      T->Next[i] = i+1;
560    }
561    T->IsNextDirty = 0;
562    T->Next[Cnt-1] = Last;
563    T->LastValidRow = T->NumRows - 1;
564    T->IdColName = "_id";
565    TInt IdCol = T->IntCols.Add();
566    T->IntCols[IdCol].Gen(Cnt);
567    omp_set_num_threads(NumThreads);
568    #pragma omp parallel for schedule(dynamic, 10000)
569    for (int64 i = 0; i < Cnt; i++) {
570      T->IntCols[IdCol][i] = i;
571    }
572    T->AddSchemaCol(T->IdColName, atInt);
573    T->AddColType(T->IdColName, atInt, T->IntCols.Len()-1);
574  }
575  #endif 
576  void TTable::LoadSSSeq(
577   PTable& T, const Schema& S, const TStr& InFNm, const TIntV& RelevantCols,
578   const char& Separator, TBool HasTitleLine) {
579    int RowLen = T->Sch.Len();
580    TVec<TAttrType> ColTypes = TVec<TAttrType>(RowLen);
581    for (int i = 0; i < RowLen; i++) {
582      ColTypes[i] = T->GetSchemaColType(i);
583    }
584    TSsParser Ss(InFNm, Separator);
585    if (HasTitleLine) {
586      Ss.Next();
587      if (S.Len() != Ss.GetFlds()) {
588        printf("%s\n", Ss[0]); TExcept::Throw("Table Schema Mismatch!");
589      }
590      for (int i = 0; i < Ss.GetFlds(); i++) {
591        int L = strlen(Ss[i]);
592        if (Ss[i][L-1] < ' ') { Ss[i][L-1] = 0; }
593        if (NormalizeColName(S[i].Val1) != NormalizeColName(Ss[i])) { TExcept::Throw("Table Schema Mismatch!"); }
594      }
595    }
596    uint64 Cnt = 0;
597    while (Ss.Next()) {
598      int IntColIdx = 0;
599      int FltColIdx = 0;
600      int StrColIdx = 0;
601      Assert(Ss.GetFlds() == S.Len()); 
602      if (Ss.GetFlds() != S.Len()) {
603        printf("%s\n", Ss[S.Len()]); TExcept::Throw("Error reading tsv file");
604      }
605      for (int i = 0; i < RowLen; i++) {
606        switch (ColTypes[i]) {
607          case atInt:
608            if (RelevantCols.Len() == 0) {
609              T->IntCols[IntColIdx].Add(Ss.GetInt(i));
610            } else {
611              T->IntCols[IntColIdx].Add(Ss.GetInt(RelevantCols[i]));
612            }
613            IntColIdx++;
614            break;
615          case atFlt:
616            if (RelevantCols.Len() == 0) {
617              T->FltCols[FltColIdx].Add(Ss.GetFlt(i));
618            } else {
619              T->FltCols[FltColIdx].Add(Ss.GetFlt(RelevantCols[i]));
620            }
621            FltColIdx++;
622            break;
623          case atStr:
624            int ColIdx;
625            if (RelevantCols.Len() == 0) {
626              ColIdx = i;
627            } else {
628              ColIdx = RelevantCols[i];
629            }
630            TStr Sval = TStr(Ss[ColIdx]);
631            T->AddStrVal(StrColIdx, Sval);
632            StrColIdx++;
633            break;
634        }
635      }
636      Cnt += 1;
637    }
638    T->NumRows = static_cast<int>(Cnt);
639    T->NumValidRows = T->NumRows;
640    T->Next.Clr();
641    T->Next.Gen(static_cast<int>(Cnt));
642    for (uint64 i = 0; i < Cnt-1; i++) {
643      T->Next[static_cast<int>(i)] = static_cast<int>(i+1);
644    }
645    T->IsNextDirty = 0;
646    T->Next[static_cast<int>(Cnt-1)] = Last;
647    T->LastValidRow = T->NumRows - 1;
648    T->InitIds();
649  }
650  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
651   const TIntV& RelevantCols, const char& Separator, TBool HasTitleLine) {
652    TVec<uint64> IntGroupByCols;
653    bool NoStringCols = true;
654    Schema SR;
655    if (RelevantCols.Len() == 0) {
656      SR = S;
657    } else {
658      for (int i = 0; i < RelevantCols.Len(); i++) {
659        SR.Add(S[RelevantCols[i]]);
660      }
661    }
662    PTable T = New(SR, Context);
663    for (int i = 0; i < SR.Len(); i++) {
664      if (T->GetSchemaColType(i) == atStr) {
665        NoStringCols = false;
666        break;
667      }
668    }
669    if (GetMP() && NoStringCols) {
670  #ifdef GLib_LINUX
671      LoadSSPar(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
672  #else
673      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
674  #endif
675    } else {
676      LoadSSSeq(T, S, InFNm, RelevantCols, Separator, HasTitleLine);
677    }
678    return T;
679  }
680  PTable TTable::LoadSS(const Schema& S, const TStr& InFNm, TTableContext* Context,
681   const char& Separator, TBool HasTitleLine) {
682    return LoadSS(S, InFNm, Context, TIntV(), Separator, HasTitleLine);
683  }
684  void TTable::SaveSS(const TStr& OutFNm) {
685    if (NumValidRows == 0) {
686      printf("Table is empty");
687      return;
688    }
689    FILE* F = fopen(OutFNm.CStr(), "w");
690    if (F == NULL) {
691      printf("failed to open file %s\n", OutFNm.CStr());
692      perror("fail ");
693      return;
694    }
695    Dump(F);
696  #if 0
697    Schema DSch = DenormalizeSchema();
698    TInt L = Sch.Len();
699    fprintf(F, "# ");
700    for (TInt i = 0; i < L-1; i++) {
701      fprintf(F, "%s\t", DSch[i].Val1.CStr());
702    }  
703    fprintf(F, "%s\n", DSch[L-1].Val1.CStr());
704    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
705      for (TInt i = 0; i < L; i++) {
706        char C = (i == L-1) ? '\n' : '\t';
707        switch (GetSchemaColType(i)) {
708          case atInt: {
709            fprintf(F, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
710            break;
711          }
712          case atFlt: {
713            fprintf(F, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
714            break;
715          }
716          case atStr: {
717            fprintf(F, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
718            break;
719          }
720        }
721      }
722    }
723  #endif
724    fclose(F);
725  }
726  void TTable::SaveBin(const TStr& OutFNm) {
727    TFOut SOut(OutFNm);
728    Save(SOut);
729  }
730  void TTable::Save(TSOut& SOut) {
731    NumRows.Save(SOut);
732    NumValidRows.Save(SOut);
733    FirstValidRow.Save(SOut);
734    LastValidRow.Save(SOut);
735    Next.Save(SOut);
736    IntCols.Save(SOut);
737    FltCols.Save(SOut);
738    StrColMaps.Save(SOut);
739    THash<TStr,TPair<TInt,TInt> > ColTypeIntMap;
740    TInt atIntVal = TInt(0);
741    TInt atFltVal = TInt(1);
742    TInt atStrVal = TInt(2);
743    for (THash<TStr,TPair<TAttrType,TInt> >::TIter it = ColTypeMap.BegI(); it < ColTypeMap.EndI(); it++) {
744      TPair<TAttrType,TInt> dat = it.GetDat();
745      TStr DColName = DenormalizeColName(it.GetKey());
746      switch (dat.GetVal1()) {
747        case atInt:
748          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atIntVal, dat.GetVal2()));
749          break;
750        case atFlt:
751          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atFltVal, dat.GetVal2()));
752          break;
753        case atStr:
754          ColTypeIntMap.AddDat(DColName, TPair<TInt,TInt>(atStrVal, dat.GetVal2()));
755          break;
756      }
757    }
758    ColTypeIntMap.Save(SOut);
759    SOut.Flush();
760  }
761  void TTable::Dump(FILE *OutF) const {
762    TInt L = Sch.Len();
763    Schema DSch = DenormalizeSchema();
764    fprintf(OutF, "# ");
765    for (TInt i = 0; i < L-1; i++) {
766      fprintf(OutF, "%s\t", DSch[i].Val1.CStr());
767    }  
768    fprintf(OutF, "%s\n", DSch[L-1].Val1.CStr());
769    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
770      for (TInt i = 0; i < L; i++) {
771        char C = (i == L-1) ? '\n' : '\t';
772        switch (GetSchemaColType(i)) {
773          case atInt: {
774            fprintf(OutF, "%d%c", RowI.GetIntAttr(GetSchemaColName(i)).Val, C);
775            break;
776          }
777          case atFlt: {
778            fprintf(OutF, "%f%c", RowI.GetFltAttr(GetSchemaColName(i)).Val, C);
779            break;
780          }
781          case atStr: {
782            fprintf(OutF, "%s%c", RowI.GetStrAttr(GetSchemaColName(i)).CStr(), C);
783            break;
784          }
785        }
786      }
787    }
788  }
789  TTableContext* TTable::ChangeContext(TTableContext* NewContext) {
790    TInt L = Sch.Len();
791  #if 0
792    for (TInt i = 0; i < L; i++) {
793      if (GetSchemaColType(i) != atStr) {
794        continue;
795      }
796      TInt ColIdx = GetColIdx(GetSchemaColName(i));
797      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
798        TInt RowIdx = RowI.GetRowIdx();
799        TInt KeyId = StrColMaps[ColIdx][RowIdx];
800        printf("ChangeContext in  %d  %d  %d  .%s.\n",
801            ColIdx.Val, RowIdx.Val, KeyId.Val, GetStrVal(ColIdx, RowIdx).CStr());
802      }
803    }
804  #endif
805    for (TInt i = 0; i < L; i++) {
806      if (GetSchemaColType(i) != atStr) {
807        continue;
808      }
809      TInt ColIdx = GetColIdx(GetSchemaColName(i));
810      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
811        TInt RowIdx = RowI.GetRowIdx();
812        TStr Key = GetStrValIdx(ColIdx, RowIdx);
813        TInt KeyId = TInt(NewContext->StringVals.AddKey(Key));
814        StrColMaps[ColIdx][RowIdx] = KeyId;
815      }
816    }
817    Context = NewContext;
818    return Context;
819  }
820  void TTable::AddStrVal(const TInt& ColIdx, const TStr& Key) {
821    TInt KeyId = TInt(Context->StringVals.AddKey(Key));
822    StrColMaps[ColIdx].Add(KeyId);
823  }
824  void TTable::AddStrVal(const TStr& Col, const TStr& Key) {
825    if (GetColType(Col) != atStr) {
826      TExcept::Throw(Col + " is not a string valued column");
827    }
828    AddStrVal(GetColIdx(Col), Key);
829  }
830  void TTable::AddGraphAttribute(const TStr& Attr, TBool IsEdge, TBool IsSrc, TBool IsDst) {
831    if (!IsColName(Attr)) { TExcept::Throw(Attr + ": No such column"); }
832    if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attr)); }
833    if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attr)); }
834    if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attr)); }
835  }
836  void TTable::AddGraphAttributeV(TStrV& Attrs, TBool IsEdge, TBool IsSrc, TBool IsDst) {
837    for (TInt i = 0; i < Attrs.Len(); i++) {
838      if (!IsColName(Attrs[i])) {
839        TExcept::Throw(Attrs[i] + ": no such column");
840      }
841    }
842    for (TInt i = 0; i < Attrs.Len(); i++) {
843      if (IsEdge) { EdgeAttrV.Add(NormalizeColName(Attrs[i])); }
844      if (IsSrc) { SrcNodeAttrV.Add(NormalizeColName(Attrs[i])); }
845      if (IsDst) { DstNodeAttrV.Add(NormalizeColName(Attrs[i])); }
846    }
847  }
848  TStrV TTable::GetSrcNodeIntAttrV() const {
849    TStrV IntNA = TStrV(IntCols.Len(),0);
850    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
851      TStr Attr = SrcNodeAttrV[i];
852      if (GetColType(Attr) == atInt) {
853        IntNA.Add(Attr);
854      }
855    }
856    return IntNA;
857  }
858  TStrV TTable::GetDstNodeIntAttrV() const {
859    TStrV IntNA = TStrV(IntCols.Len(),0);
860    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
861      TStr Attr = DstNodeAttrV[i];
862      if (GetColType(Attr) == atInt) {
863        IntNA.Add(Attr);
864      }
865    }
866    return IntNA;
867  }
868  TStrV TTable::GetEdgeIntAttrV() const {
869    TStrV IntEA = TStrV(IntCols.Len(),0);
870    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
871      TStr Attr = EdgeAttrV[i];
872      if (GetColType(Attr) == atInt) {
873        IntEA.Add(Attr);
874      }
875    }
876    return IntEA;
877  }
878  TStrV TTable::GetSrcNodeFltAttrV() const {
879    TStrV FltNA = TStrV(FltCols.Len(),0);
880    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
881      TStr Attr = SrcNodeAttrV[i];
882      if (GetColType(Attr) == atFlt) {
883        FltNA.Add(Attr);
884      }
885    }
886    return FltNA;
887  }
888  TStrV TTable::GetDstNodeFltAttrV() const {
889    TStrV FltNA = TStrV(FltCols.Len(),0);
890    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
891      TStr Attr = DstNodeAttrV[i];
892      if (GetColType(Attr) == atFlt) {
893        FltNA.Add(Attr);
894      }
895    }
896    return FltNA;
897  }
898  TStrV TTable::GetEdgeFltAttrV() const {
899    TStrV FltEA = TStrV(FltCols.Len(),0);;
900    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
901      TStr Attr = EdgeAttrV[i];
902      if (GetColType(Attr) == atFlt) {
903        FltEA.Add(Attr);
904      }
905    }
906    return FltEA;
907  }
908  TStrV TTable::GetSrcNodeStrAttrV() const {
909    TStrV StrNA = TStrV(StrColMaps.Len(),0);
910    for (TInt i = 0; i < SrcNodeAttrV.Len(); i++) {
911      TStr Attr = SrcNodeAttrV[i];
912      if (GetColType(Attr) == atStr) {
913        StrNA.Add(Attr);
914      }
915    }
916    return StrNA;
917  }
918  TStrV TTable::GetDstNodeStrAttrV() const {
919    TStrV StrNA = TStrV(StrColMaps.Len(),0);
920    for (TInt i = 0; i < DstNodeAttrV.Len(); i++) {
921      TStr Attr = DstNodeAttrV[i];
922      if (GetColType(Attr) == atStr) {
923        StrNA.Add(Attr);
924      }
925    }
926    return StrNA;
927  }
928  TStrV TTable::GetEdgeStrAttrV() const {
929    TStrV StrEA = TStrV(StrColMaps.Len(),0);
930    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
931      TStr Attr = EdgeAttrV[i];
932      if (GetColType(Attr) == atStr) {
933        StrEA.Add(Attr);
934      }
935    }
936    return StrEA;
937  }
938  void TTable::Rename(const TStr& column, const TStr& NewLabel) {
939    if (!IsColName(column)) { TExcept::Throw("no such column " + column); }
940    TPair<TAttrType,TInt> ColVal = GetColTypeMap(column);
941    DelColType(column);
942    AddColType(NewLabel, ColVal);
943    TStr NColName = NormalizeColName(column);
944    TStr NLabel = NormalizeColName(NewLabel);
945    for (TInt c = 0; c < Sch.Len(); c++) {
946      if (Sch[c].Val1 == NColName) {
947        Sch.SetVal(c, TPair<TStr, TAttrType>(NLabel, Sch[c].Val2));
948        break;
949      }
950    }
951  }
952  void TTable::RemoveFirstRow() {
953    if (FirstValidRow == LastValidRow) {
954      LastValidRow = -1;
955    }
956    TInt Old = FirstValidRow;
957    FirstValidRow = Next[FirstValidRow];
958    Next[Old] = TTable::Invalid;
959    NumValidRows--;
960    TInt IdColIdx = GetColIdx(GetIdColName());
961    RowIdMap.AddDat(IntCols[IdColIdx][Old], Invalid);
962  }
963  void TTable::RemoveRow(TInt RowIdx, TInt PrevRowIdx) {
964    if (RowIdx == FirstValidRow) {
965      RemoveFirstRow();
966      return;
967    }
968    Assert(RowIdx != TTable::Invalid);
969    if (RowIdx == TTable::Last) { return; }
970    Next[PrevRowIdx] = Next[RowIdx];
971    if (LastValidRow == RowIdx) {
972      LastValidRow = RowIdx;
973    }
974    Next[RowIdx] = TTable::Invalid;
975    NumValidRows--;
976    TInt IdColIdx = GetColIdx(GetIdColName());
977    RowIdMap.AddDat(IntCols[IdColIdx][RowIdx], Invalid);
978  }
979  void TTable::KeepSortedRows(const TIntV& KeepV) {
980    TIntIntH KeepH(KeepV.Len());
981    for (TInt i = 0; i < KeepV.Len(); i++) {
982      KeepH.AddKey(KeepV[i]);
983    }
984    TRowIteratorWithRemove RowI = BegRIWR();
985    TInt KeepSize = 0;
986    while (RowI.GetNextRowIdx() != Last) {
987      if (KeepSize < KeepV.Len()) {
988        if (KeepH.IsKey(RowI.GetNextRowIdx())) {
989          KeepSize++;
990          RowI++;
991        } else {
992          RowI.RemoveNext();
993        }
994      } else {
995        RowI.RemoveNext();
996      }
997    }
998    LastValidRow = KeepV[KeepV.Len()-1];
999  }
1000  void TTable::GetPartitionRanges(TIntPrV& Partitions, TInt NumPartitions) const {
1001    TInt PartitionSize = NumValidRows / (NumPartitions);
1002    if (NumValidRows % NumPartitions != 0) PartitionSize++;
1003    if (PartitionSize < 10) { 
1004      PartitionSize = 10;
1005      NumPartitions = NumValidRows / PartitionSize; 
1006    }
1007    Partitions.Reserve(NumPartitions+1);
1008    TInt currRow = FirstValidRow;
1009    TInt currStart = currRow;
1010    if (IsNextDirty) {
1011      TInt currCount = PartitionSize;
1012      while (currRow != TTable::Last) {
1013        if (currCount == 0) {
1014          Partitions.Add(TIntPr(currStart, currRow));
1015          currStart = currRow;
1016          currCount = PartitionSize;
1017        }
1018        currRow = Next[currRow];
1019        currCount--;
1020      }
1021      Partitions.Add(TIntPr(currStart, currRow));
1022    } else {
1023      currRow += PartitionSize;
1024      while (currRow != TTable::Last && currRow < Next.Len()) {
1025        if (Next[currRow] == TTable::Invalid) { currRow++; continue; }
1026        Partitions.Add(TIntPr(currStart, currRow));
1027        currStart = currRow;
1028        currRow += PartitionSize;
1029      }
1030      Partitions.Add(TIntPr(currStart, TTable::Last));
1031    }
1032  }
1033  void TTable::GroupingSanityCheck(const TStr& GroupBy, const TAttrType& AttrType) const {
1034    if (!IsColName(GroupBy)) {
1035      TExcept::Throw("no such column " + GroupBy);
1036    }
1037    if (GetColType(GroupBy) != AttrType) {
1038      TExcept::Throw(GroupBy + " values are not of expected type");
1039    }
1040  }
1041  #ifdef GCC_ATOMIC
1042  void TTable::GroupByIntColMP(const TStr& GroupBy, THashMP<TInt, TIntV>& Grouping, TBool UsePhysicalIds) const {
1043    timeval timer0;
1044    gettimeofday(&timer0, NULL);
1045    TInt IdColIdx = GetColIdx(IdColName);
1046    TInt GroupByColIdx = GetColIdx(GroupBy);
1047    if(!UsePhysicalIds && IdColIdx < 0){
1048    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1049    }
1050    GroupingSanityCheck(GroupBy, atInt);
1051    TIntPrV Partitions;
1052    GetPartitionRanges(Partitions, 8*CHUNKS_PER_THREAD);
1053    TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1054    Grouping.Gen(NumValidRows);
1055    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1056    for (int i = 0; i < Partitions.Len(); i++){
1057      TRowIterator RowI(Partitions[i].GetVal1(), this);
1058      TRowIterator EndI(Partitions[i].GetVal2(), this);
1059      while (RowI < EndI) {
1060        TInt idx = UsePhysicalIds ? RowI.GetRowIdx() : RowI.GetIntAttr(IdColIdx);
1061        UpdateGrouping<TInt>(Grouping, RowI.GetIntAttr(GroupByColIdx), idx);
1062        RowI++;
1063      }
1064    }
1065    gettimeofday(&timer0, NULL);
1066  }
1067  #endif 
1068  void TTable::Unique(const TStr& Col) {
1069    TIntV RemainingRows;
1070    TStr NCol = NormalizeColName(Col);
1071    switch (GetColType(NCol)) {
1072      case atInt: {
1073        TIntIntVH Grouping;
1074        GroupByIntCol(NCol, Grouping, TIntV(), true, true);
1075        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1076          RemainingRows.Add(it->Dat[0]);
1077        }
1078        break;
1079      }
1080      case atFlt: {
1081        THash<TFlt,TIntV> Grouping;
1082        GroupByFltCol(NCol, Grouping, TIntV(), true, true);
1083        for (THash<TFlt,TIntV>::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1084          RemainingRows.Add(it->Dat[0]);
1085        }
1086        break;
1087      } 
1088      case atStr: {
1089        TIntIntVH Grouping;
1090        GroupByStrCol(NCol, Grouping, TIntV(), true, true);
1091        for (TIntIntVH::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1092          RemainingRows.Add(it->Dat[0]);
1093        }
1094        break;
1095      }
1096    }
1097    KeepSortedRows(RemainingRows);
1098  }
1099  void TTable::Unique(const TStrV& Cols, TBool Ordered) {
1100    if(Cols.Len() == 1){ 
1101    	Unique(Cols[0]);
1102    	return;
1103    }
1104    TStrV NCols = NormalizeColNameV(Cols);
1105    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1106    TIntV UniqueVec;
1107    GroupAux(NCols, Grouping, Ordered, "", true, UniqueVec, true);
1108    KeepSortedRows(UniqueVec);
1109  }
1110  void TTable::StoreGroupCol(const TStr& GroupColName, const TVec<TPair<TInt, TInt> >& GroupAndRowIds) {
1111    IntCols.Add(TIntV(NumRows));
1112    TInt L = IntCols.Len();
1113    AddColType(GroupColName, atInt, L-1);
1114    for (TInt i = 0; i < GroupAndRowIds.Len(); i++) {
1115      IntCols[L-1][GroupAndRowIds[i].Val2] = GroupAndRowIds[i].Val1;
1116    }
1117  }
1118  void TTable::GroupAux(const TStrV& GroupBy, THash<TGroupKey, TPair<TInt, TIntV> >& Grouping, 
1119   TBool Ordered, const TStr& GroupColName, TBool KeepUnique, TIntV& UniqueVec, TBool UsePhysicalIds) {
1120    TInt IdColIdx = GetColIdx(IdColName);
1121    if(!UsePhysicalIds && IdColIdx < 0){
1122    	TExcept::Throw("Grouping: Either use physical row ids, or have an id column");
1123    }
1124    TIntV IntGroupByCols;
1125    TIntV FltGroupByCols;
1126    TIntV StrGroupByCols;
1127    for (TInt c = 0; c < GroupBy.Len(); c++) {
1128      if (!IsColName(GroupBy[c])) { 
1129        TExcept::Throw("no such column " + GroupBy[c]); 
1130      }
1131      TPair<TAttrType, TInt> ColType = GetColTypeMap(GroupBy[c]);
1132      switch (ColType.Val1) {
1133        case atInt:
1134          IntGroupByCols.Add(ColType.Val2);
1135          break;
1136        case atFlt:
1137          FltGroupByCols.Add(ColType.Val2);
1138          break;
1139        case atStr:
1140          StrGroupByCols.Add(ColType.Val2);
1141          break;
1142      }
1143    }
1144    TInt IKLen = IntGroupByCols.Len();
1145    TInt FKLen = FltGroupByCols.Len();
1146    TInt SKLen = StrGroupByCols.Len();
1147    TInt GroupNum = 0;
1148    TVec<TPair<TInt, TInt> > GroupAndRowIds;
1149    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
1150      TIntV IKey(IKLen + SKLen, 0);
1151      TFltV FKey(FKLen, 0);
1152      TIntV SKey(SKLen, 0);
1153      for (TInt c = 0; c < IKLen; c++) {
1154        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
1155      }
1156      for (TInt c = 0; c < FKLen; c++) {
1157        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
1158      }
1159      for (TInt c = 0; c < SKLen; c++) {
1160        SKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
1161      }
1162      if (!Ordered) {
1163        if (IKLen > 0) { IKey.ISort(0, IKey.Len()-1, true); }
1164        if (FKLen > 0) { FKey.ISort(0, FKey.Len()-1, true); }
1165        if (SKLen > 0) { SKey.ISort(0, SKey.Len()-1, true); }
1166      }
1167      for (TInt c = 0; c < SKLen; c++) {
1168        IKey.Add(SKey[c]);
1169      }
1170      TGroupKey GroupKey = TGroupKey(IKey, FKey);
1171      TInt RowIdx = it.GetRowIdx();
1172      TInt idx = UsePhysicalIds ? it.GetRowIdx() : IntCols[IdColIdx][it.GetRowIdx()];
1173      if (!Grouping.IsKey(GroupKey)) {
1174        TPair<TInt, TIntV> NewGroup;
1175        NewGroup.Val1 = GroupNum;
1176        NewGroup.Val2.Add(idx);
1177        Grouping.AddDat(GroupKey, NewGroup);
1178        if (GroupColName != "") {
1179          GroupAndRowIds.Add(TPair<TInt, TInt>(GroupNum, RowIdx));
1180        }
1181        if (KeepUnique) { 
1182          UniqueVec.Add(idx);
1183        }
1184        GroupNum++;
1185      } else {
1186        if (!KeepUnique) {
1187          TPair<TInt, TIntV>& NewGroup = Grouping.GetDat(GroupKey);
1188          NewGroup.Val2.Add(idx);
1189          if (GroupColName != "") {
1190            GroupAndRowIds.Add(TPair<TInt, TInt>(NewGroup.Val1, RowIdx));
1191          }
1192        }
1193      }
1194    }
1195    if (!KeepUnique) {
1196      GroupStmt Stmt(NormalizeColNameV(GroupBy), Ordered, UsePhysicalIds);
1197      GroupStmtNames.AddDat(GroupColName, Stmt);
1198      GroupIDMapping.AddKey(Stmt);
1199      GroupMapping.AddKey(Stmt);
1200      for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it < Grouping.EndI(); it++) {
1201        TGroupKey key = it.GetKey();
1202        TPair<TInt, TIntV> group = it.GetDat();
1203        GroupIDMapping.GetDat(Stmt).AddDat(group.Val1, TGroupKey(key));
1204        GroupMapping.GetDat(Stmt).AddDat(TGroupKey(key), TIntV(group.Val2));
1205      }
1206    }
1207    if (GroupColName != "") {
1208      StoreGroupCol(GroupColName, GroupAndRowIds);
1209      AddSchemaCol(GroupColName, atInt);  
1210    }
1211  }
1212  void TTable::Group(const TStrV& GroupBy, const TStr& GroupColName, TBool Ordered, TBool UsePhysicalIds) {
1213    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1214    TStr NGroupColName = NormalizeColName(GroupColName);
1215    TIntV UniqueVec;
1216    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1217    GroupAux(NGroupBy, Grouping, Ordered, NGroupColName, false, UniqueVec, UsePhysicalIds);
1218  }
1219  void TTable::InvalidatePhysicalGroupings(){
1220  }
1221  void TTable::InvalidateAffectedGroupings(const TStr& Attr){
1222  }
1223  void TTable::Aggregate(const TStrV& GroupByAttrs, TAttrAggr AggOp,
1224   const TStr& ValAttr, const TStr& ResAttr, TBool Ordered) {
1225     for (TInt c = 0; c < GroupByAttrs.Len(); c++) {
1226      if (!IsColName(GroupByAttrs[c])) { 
1227        TExcept::Throw("no such column " + GroupByAttrs[c]); 
1228      }
1229     }
1230    TStrV NGroupByAttrs = NormalizeColNameV(GroupByAttrs);
1231    TBool UsePhysicalIds = (GetColIdx(IdColName) < 0);
1232    THash<TInt,TIntV> GroupByIntMapping;
1233    THash<TFlt,TIntV> GroupByFltMapping;
1234    THash<TInt,TIntV> GroupByStrMapping;
1235    THash<TGroupKey,TIntV> Mapping;
1236  #ifdef GCC_ATOMIC
1237    THashMP<TInt,TIntV> GroupByIntMapping_MP(NumValidRows);
1238    TIntV GroupByIntMPKeys(NumValidRows);
1239  #endif
1240    TInt NumOfGroups = 0;
1241    TInt GroupingCase = 0;
1242    GroupStmt Stmt(NGroupByAttrs, Ordered, UsePhysicalIds);
1243    if (GroupMapping.IsKey(Stmt)) {
1244      Mapping = GroupMapping.GetDat(Stmt);
1245    } else{
1246    	if(NGroupByAttrs.Len() == 1){
1247    		switch(GetColType(NGroupByAttrs[0])){
1248    			case atInt:
1249  #ifdef GCC_ATOMIC
1250    				if(GetMP()){
1251    					GroupByIntColMP(NGroupByAttrs[0], GroupByIntMapping_MP, UsePhysicalIds);
1252    					int x = 0;
1253  					for(THashMP<TInt,TIntV>::TIter it = GroupByIntMapping_MP.BegI(); it < GroupByIntMapping_MP.EndI(); it++){
1254  						GroupByIntMPKeys[x] = it.GetKey();
1255  						x++;
1256  					}
1257    					NumOfGroups = x;
1258    					GroupingCase = 4;
1259    					break;
1260    				}
1261  #endif 
1262    				GroupByIntCol(NGroupByAttrs[0], GroupByIntMapping, TIntV(), true, UsePhysicalIds);
1263    				NumOfGroups = GroupByIntMapping.Len();
1264    				GroupingCase = 1;
1265    				break;
1266    			case atFlt:
1267    				GroupByFltCol(NGroupByAttrs[0], GroupByFltMapping, TIntV(), true, UsePhysicalIds);
1268    				NumOfGroups = GroupByFltMapping.Len();
1269    				GroupingCase = 2;
1270    				break;
1271    			case atStr:
1272    				GroupByStrCol(NGroupByAttrs[0], GroupByStrMapping, TIntV(), true, UsePhysicalIds);
1273    				NumOfGroups = GroupByStrMapping.Len();
1274    				GroupingCase = 3;
1275    				break;
1276    		}
1277    	}
1278    	else{
1279    		TIntV UniqueVector;
1280    		THash<TGroupKey, TPair<TInt, TIntV> > Mapping_aux;
1281    		GroupAux(NGroupByAttrs, Mapping_aux, Ordered, "", false, UniqueVector, UsePhysicalIds);
1282    		for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Mapping_aux.BegI(); it < Mapping_aux.EndI(); it++){
1283    			Mapping.AddDat(it.GetKey(), it.GetDat().Val2);
1284    		}
1285    		NumOfGroups = Mapping.Len();
1286    	}
1287    }
1288    TAttrType T = GetColType(ValAttr);
1289    if (AggOp == aaCount) { AddIntCol(ResAttr); } 
1290    else {
1291      if (T == atInt) { AddIntCol(ResAttr); }
1292      else if (T == atFlt) { AddFltCol(ResAttr); }
1293      else {
1294        TExcept::Throw("Invalid aggregation for Str type!");
1295      }
1296    }
1297    TInt ColIdx = GetColIdx(ResAttr);
1298    TInt AggrColIdx = GetColIdx(ValAttr);
1299  #ifdef USE_OPENMP
1300    #pragma omp parallel for schedule(dynamic)
1301  #endif 
1302    for (int g = 0; g < NumOfGroups; g++) {
1303    	TIntV* GroupRows = NULL;
1304    	switch(GroupingCase){
1305    		case 0:
1306    			GroupRows = & Mapping.GetDat(Mapping.GetKey(g));
1307    			break;
1308    		case 1:
1309    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1310    			break;
1311    		case 2:
1312    			GroupRows = & GroupByIntMapping.GetDat(GroupByIntMapping.GetKey(g));
1313    			break;
1314    	    case 3:
1315    			GroupRows = & GroupByStrMapping.GetDat(GroupByStrMapping.GetKey(g));
1316    			break;
1317    		case 4:
1318  #ifdef GCC_ATOMIC
1319    			GroupRows = & GroupByIntMapping_MP.GetDat(GroupByIntMPKeys[g]);
1320  #endif
1321    			break;
1322    	}
1323  	TIntV& ValidRows = *GroupRows;
1324      TInt sz = ValidRows.Len();
1325      if (sz <= 0) continue;
1326      if (AggOp == aaCount) {
1327        for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = sz; }
1328      } else {
1329        if (T == atInt) {
1330          TIntV V;
1331          for (TInt i = 0; i < sz; i++) { V.Add(IntCols[AggrColIdx][ValidRows[i]]); }
1332          TInt Res = AggregateVector<TInt>(V, AggOp);
1333          if (AggOp == aaMean) { Res = Res / sz; }
1334          for (TInt i = 0; i < sz; i++) { IntCols[ColIdx][ValidRows[i]] = Res; }
1335        } else {
1336          TFltV V;
1337          for (TInt i = 0; i < sz; i++) { V.Add(FltCols[AggrColIdx][ValidRows[i]]); }
1338          TFlt Res = AggregateVector<TFlt>(V, AggOp);
1339          if (AggOp == aaMean) { Res /= sz; }
1340          for (TInt i = 0; i < sz; i++) { FltCols[ColIdx][ValidRows[i]] = Res; }
1341        }
1342      }
1343    }
1344  }
1345  void TTable::AggregateCols(const TStrV& AggrAttrs, TAttrAggr AggOp, const TStr& ResAttr) {
1346    TVec<TPair<TAttrType, TInt> >Info;
1347    for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1348      Info.Add(GetColTypeMap(AggrAttrs[i]));
1349      if (Info[i].Val1 != Info[0].Val1) {
1350        TExcept::Throw("AggregateCols: Aggregation attributes must have the same type");
1351      }
1352    }
1353    if (Info[0].Val1 == atInt) {
1354      AddIntCol(ResAttr);
1355      TInt ResIdx = GetColIdx(ResAttr);
1356      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1357        TInt RowIdx = RI.GetRowIdx();
1358        TIntV V;
1359        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1360          V.Add(IntCols[Info[i].Val2][RowIdx]);
1361        }
1362        IntCols[ResIdx][RowIdx] = AggregateVector<TInt>(V, AggOp);
1363      }
1364    } else if (Info[0].Val1 == atFlt) {
1365      AddFltCol(ResAttr);
1366      TInt ResIdx = GetColIdx(ResAttr);
1367      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1368        TInt RowIdx = RI.GetRowIdx();
1369        TFltV V;
1370        for (TInt i = 0; i < AggrAttrs.Len(); i++) {
1371          V.Add(FltCols[Info[i].Val2][RowIdx]);
1372        }
1373        FltCols[ResIdx][RowIdx] = AggregateVector<TFlt>(V, AggOp);
1374      }
1375    } else {
1376      TExcept::Throw("AggregateCols: Only Int and Flt aggregation supported right now");
1377    }
1378  }
1379  void TTable::PrintGrouping(const THash<TGroupKey, TIntV>& Mapping) const{
1380  	for(THash<TGroupKey, TIntV>::TIter it = Mapping.BegI(); it < Mapping.EndI(); it++){
1381    		TGroupKey gk = it.GetKey();
1382    		TIntV ik = gk.Val1;
1383    		TFltV fk = gk.Val2;
1384    		for(int i = 0; i < ik.Len(); i++){ printf("%d ",ik[i].Val);} 
1385    		for(int i = 0; i < fk.Len(); i++){ printf("%f ",fk[i].Val);} 
1386    		printf("-->");
1387    		TIntV v = it.GetDat();
1388    		for(int i = 0; i < v.Len(); i++){ printf("%d ",v[i].Val);} 
1389    		printf("\n");
1390    	}
1391  }
1392  void TTable::Count(const TStr& CountColName, const TStr& Col) {
1393    TStrV GroupByAttrs;
1394    GroupByAttrs.Add(CountColName);
1395    Aggregate(GroupByAttrs, aaCount, "", Col);
1396  }
1397  TVec<PTable> TTable::SpliceByGroup(const TStrV& GroupBy, TBool Ordered) {
1398    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1399    TIntV UniqueVec;
1400    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
1401    TVec<PTable> Result;
1402    Schema NewSchema;
1403    for (TInt c = 0; c < Sch.Len(); c++) {
1404      if (Sch[c].Val1 != GetIdColName()) {
1405        NewSchema.Add(Sch[c]);
1406      }
1407    }
1408    GroupAux(NGroupBy, Grouping, Ordered, "", false, UniqueVec);
1409    TInt cnt = 0;
1410    for (THash<TGroupKey, TPair<TInt, TIntV> >::TIter it = Grouping.BegI(); it != Grouping.EndI(); it++) {
1411      PTable GroupTable = TTable::New(NewSchema, Context);
1412      TVec<TPair<TAttrType, TInt> > ColInfo;
1413      TIntV V;
1414      for (TInt i = 0; i < Sch.Len(); i++) {
1415        ColInfo.Add(GroupTable->GetColTypeMap(Sch[i].Val1));
1416        if (Sch[i].Val1 == IdColName()) {
1417          ColInfo[i].Val2 = -1;
1418        }
1419        V.Add(GetColIdx(Sch[i].Val1));
1420      }
1421      TIntV& Rows = it.GetDat().Val2;
1422      for (TInt i = 0; i < Rows.Len(); i++) {
1423        TInt RowIdx = RowIdMap.GetDat(Rows[i]);
1424        for (TInt c = 0; c < Sch.Len(); c++) {
1425          TPair<TAttrType, TInt> Info = ColInfo[c];
1426          TInt ColIdx = Info.Val2;
1427          if (ColIdx == -1) { continue; }
1428          switch (Info.Val1) {
1429            case atInt:
1430              GroupTable->IntCols[ColIdx].Add(IntCols[V[c]][RowIdx]);
1431              break;
1432            case atFlt:
1433              GroupTable->FltCols[ColIdx].Add(FltCols[V[c]][RowIdx]);
1434              break;
1435            case atStr:
1436              GroupTable->StrColMaps[ColIdx].Add(StrColMaps[V[c]][RowIdx]);
1437              break;
1438          }
1439        }
1440        if (GroupTable->LastValidRow >= 0) {
1441          GroupTable->Next[GroupTable->LastValidRow] = GroupTable->NumRows;
1442        }
1443        GroupTable->Next.Add(GroupTable->Last);
1444        GroupTable->LastValidRow = GroupTable->NumRows;
1445        GroupTable->NumRows++;
1446        GroupTable->NumValidRows++;
1447      }
1448      GroupTable->InitIds();
1449      Result.Add(GroupTable);
1450      cnt += 1;
1451    }
1452    return Result;
1453  }
1454  void TTable::InitIds() {
1455    IdColName = "_id";
1456    AddIdColumn(IdColName);
1457  }
1458  void TTable::Reindex() {
1459    RowIdMap.Clr();
1460    TInt IdColIdx = GetColIdx(IdColName);
1461    TInt IdCnt = 0;
1462    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1463      IntCols[IdColIdx][RI.GetRowIdx()] = IdCnt;
1464      RowIdMap.AddDat(RI.GetRowIdx(), IdCnt);
1465      IdCnt++;
1466    }
1467  }
1468  void TTable::AddIdColumn(const TStr& ColName) {
1469    TInt IdCol = IntCols.Add();
1470    IntCols[IdCol].Reserve(NumRows, NumRows);
1471    TInt IdCnt = 0;
1472    RowIdMap.Clr();
1473    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
1474      IntCols[IdCol][RI.GetRowIdx()] = IdCnt;
1475      RowIdMap.AddDat(IdCnt, RI.GetRowIdx());
1476      IdCnt++;
1477    }
1478    AddSchemaCol(ColName, atInt);
1479    AddColType(ColName, atInt, IntCols.Len()-1);
1480  }
1481   PTable TTable::InitializeJointTable(const TTable& Table) {
1482    PTable JointTable = New(Context);
1483    JointTable->IntCols = TVec<TIntV>(IntCols.Len() + Table.IntCols.Len() + 1);
1484    JointTable->FltCols = TVec<TFltV>(FltCols.Len() + Table.FltCols.Len());
1485    JointTable->StrColMaps = TVec<TIntV>(StrColMaps.Len() + Table.StrColMaps.Len());
1486    for (TInt i = 0; i < Sch.Len(); i++) {
1487      TStr ColName = GetSchemaColName(i);
1488      TAttrType ColType = GetSchemaColType(i);
1489      TStr CName = JointTable->RenumberColName(ColName);
1490      TPair<TAttrType, TInt> TypeMap = GetColTypeMap(ColName);
1491      JointTable->AddColType(CName, TypeMap);
1492      JointTable->AddSchemaCol(CName, ColType);
1493    }
1494    for (TInt i = 0; i < Table.Sch.Len(); i++) {
1495      TStr ColName = Table.GetSchemaColName(i);
1496      TAttrType ColType = Table.GetSchemaColType(i);
1497      TStr CName = JointTable->RenumberColName(ColName);
1498      TPair<TAttrType, TInt> NewDat = Table.GetColTypeMap(ColName);
1499      Assert(ColType == NewDat.Val1);
1500      switch (NewDat.Val1) {
1501        case atInt:
1502          NewDat.Val2 += IntCols.Len();
1503          break;
1504        case atFlt:
1505          NewDat.Val2 += FltCols.Len();
1506          break;
1507        case atStr:
1508          NewDat.Val2 += StrColMaps.Len();
1509          break;
1510      }
1511      JointTable->AddColType(CName, NewDat);
1512      JointTable->AddSchemaCol(CName, ColType);
1513    }
1514    TStr IdColName = "_id";
1515    JointTable->AddColType(IdColName, atInt, IntCols.Len() + Table.IntCols.Len());
1516    JointTable->AddSchemaCol(IdColName, atInt);
1517    return JointTable;
1518  }
1519  void TTable::AddJointRow(const TTable& T1, const TTable& T2, TInt RowIdx1, TInt RowIdx2) {
1520    for (TInt i = 0; i < T1.IntCols.Len(); i++) {
1521      IntCols[i].Add(T1.IntCols[i][RowIdx1]);
1522    }
1523    for (TInt i = 0; i < T1.FltCols.Len(); i++) {
1524      FltCols[i].Add(T1.FltCols[i][RowIdx1]);
1525    }
1526    for (TInt i = 0; i < T1.StrColMaps.Len(); i++) {
1527      StrColMaps[i].Add(T1.StrColMaps[i][RowIdx1]);
1528    }
1529    TInt IntOffset = T1.IntCols.Len();
1530    TInt FltOffset = T1.FltCols.Len();
1531    TInt StrOffset = T1.StrColMaps.Len();
1532    for (TInt i = 0; i < T2.IntCols.Len(); i++) {
1533      IntCols[i+IntOffset].Add(T2.IntCols[i][RowIdx2]);
1534    }
1535    for (TInt i = 0; i < T2.FltCols.Len(); i++) {
1536      FltCols[i+FltOffset].Add(T2.FltCols[i][RowIdx2]);
1537    }
1538    for (TInt i = 0; i < T2.StrColMaps.Len(); i++) {
1539      StrColMaps[i+StrOffset].Add(T2.StrColMaps[i][RowIdx2]);
1540    }
1541    TInt IdOffset = IntOffset + T2.IntCols.Len(); 
1542    NumRows++;
1543    NumValidRows++;
1544    if (!Next.Empty()) {
1545      Next[Next.Len()-1] = NumValidRows-1;
1546      LastValidRow = NumValidRows-1;
1547    }
1548    Next.Add(Last);
1549    RowIdMap.AddDat(NumRows-1,NumRows-1);
1550    IntCols[IdOffset].Add(NumRows-1);
1551  }
1552  PTable TTable::SimJoin(const TStrV& Cols1, const TTable& Table, const TStrV& Cols2, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold)
1553  {
1554  	Assert(Cols1.Len() == Cols2.Len());
1555  	if(Cols1.Len()!=Cols2.Len()){
1556  		TExcept::Throw("Column vectors must match in type and length");
1557  	}
1558  	for (TInt i = 0; i < Cols1.Len(); i++) {
1559  		if(!IsColName(Cols1[i]) || !Table.IsColName(Cols2[i])){
1560  			TExcept::Throw("Column not found in Table");
1561  		}
1562  		TAttrType Type1 = GetColType(Cols1[i]);
1563  		TAttrType Type2 = GetColType(Cols2[i]);
1564  		if(Type1!=Type2){
1565  			TExcept::Throw("Column types on the two tables must match.");
1566  		}
1567  		if((Type1!=atInt && Type1!=atFlt) || (Type2!=atInt && Type2!=atFlt)){
1568  			TExcept::Throw("Column type not supported. Only Flt and Int column types are supported.");
1569  		}
1570    }
1571    PTable JointTable = InitializeJointTable(Table);
1572  	TFltV DistanceV;
1573  	for(TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1574  		for(TRowIterator RowI2 = Table.BegRI(); RowI2 < Table.EndRI(); RowI2++) {
1575  			float distance = 0;
1576  			switch(SimType)
1577  			{
1578  				case L2Norm:
1579  					for(TInt i = 0; i < Cols1.Len(); i++) {
1580  						float attrVal1, attrVal2;
1581  						attrVal1 = GetColType(Cols1[i])==atInt ? (float)RowI.GetIntAttr(Cols1[i]) : (float)RowI.GetFltAttr(Cols1[i]);
1582  						attrVal2 = Table.GetColType(Cols2[i])==atInt ? (float)RowI2.GetIntAttr(Cols2[i]) : (float)RowI2.GetFltAttr(Cols2[i]);
1583  						distance += pow(attrVal1 - attrVal2, 2);
1584  					}
1585  					distance = sqrt(distance);
1586  					if(distance<=Threshold){
1587  						JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1588  						DistanceV.Add(distance);
1589  					}
1590  					break;
1591  				case Haversine:
1592  					{
1593  						if(Cols1.Len()!=2){
1594  							TExcept::Throw("Haversine disance expects exactly two attributes - latitude and longitude - in that order.");
1595  						}
1596  						TFlt Radius = 6373; 
1597  						float Latitude1  = GetColType(Cols1[0])==atInt ? (float)RowI.GetIntAttr(Cols1[0]) : (float)RowI.GetFltAttr(Cols1[0]);
1598  						float Latitude2 = Table.GetColType(Cols2[0])==atInt ? (float)RowI2.GetIntAttr(Cols2[0]) : (float)RowI2.GetFltAttr(Cols2[0]);
1599  						float Longitude1  = GetColType(Cols1[1])==atInt ? (float)RowI.GetIntAttr(Cols1[1]) : (float)RowI.GetFltAttr(Cols1[1]);
1600  						float Longitude2  = Table.GetColType(Cols2[1])==atInt ? (float)RowI2.GetIntAttr(Cols2[1]) : (float)RowI2.GetFltAttr(Cols2[1]);
1601  						Latitude1 *= static_cast<float>(M_PI/180.0);
1602  						Latitude2 *= static_cast<float>(M_PI/180.0);
1603  						Longitude1 *= static_cast<float>(M_PI/180.0);
1604  						Longitude2 *= static_cast<float>(M_PI/180.0);
1605  						float dlon = Longitude2 - Longitude1;
1606  						float dlat = Latitude2 - Latitude1;
1607  						float a = pow(sin(dlat/2), 2) + cos(Latitude1)*cos(Latitude2)*pow(sin(dlon/2), 2);
1608  						float c = 2*atan2(sqrt(a), sqrt(1-a));
1609  						distance = (static_cast<float>(Radius.Val))*c;
1610  						if(distance<=Threshold){
1611  							JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), RowI2.GetRowIdx());
1612  							DistanceV.Add(distance);
1613  						}
1614  					}
1615  					break;
1616  				case L1Norm:
1617  				case Jaccard:
1618  					TExcept::Throw("This distance metric is not supported");
1619  			}
1620  		}	
1621  	}
1622  	JointTable->StoreFltCol(DistanceColName, DistanceV);
1623  	JointTable->InitIds();
1624  	return JointTable;
1625  }
1626  PTable TTable::SelfSimJoinPerGroup(const TStr& GroupAttr, const TStr& SimCol, const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) 
1627  {
1628  	if(!IsColName(SimCol) || !IsColName(GroupAttr)){
1629  		TExcept::Throw("No such column found in table");
1630  	}
1631    PTable JointTable = New(Context);
1632  	JointTable->IntCols = TVec<TIntV>(2);
1633  	JointTable->FltCols = TVec<TFltV>(1);
1634  	for(TInt i=0;i<2;i++){
1635      TInt Suffix = i+1;
1636      TStr CName = "GroupId_" + Suffix.GetStr();
1637      TPair<TAttrType, TInt> Group(atInt, (int)i);
1638      JointTable->AddColType(CName, Group);
1639      JointTable->AddSchemaCol(CName, atInt);
1640    }
1641  	TPair<TAttrType, TInt> Group(atFlt, 0);
1642  	JointTable->AddColType(DistanceColName, Group);
1643  	JointTable->AddSchemaCol(DistanceColName, atFlt);
1644  	THash<TInt, THash<TInt, TInt> > TIntHH;
1645  	TAttrType attrType = GetColType(SimCol);
1646  	TInt GroupColIdx = GetColIdx(GroupAttr);
1647  	TInt SimColIdx = GetColIdx(SimCol);
1648  	for (TRowIterator RowI = this->BegRI(); RowI < this->EndRI(); RowI++) {
1649  		TInt GroupId = IntCols[GroupColIdx][RowI.GetRowIdx()];
1650  		if(attrType==atInt || attrType==atStr)
1651  		{
1652  			if(!TIntHH.IsKey(GroupId)){
1653  				THash<TInt, TInt> TIntH;
1654  				TIntHH.AddDat(GroupId, TIntH);
1655  			}
1656  			THash<TInt, TInt>& TIntH = TIntHH.GetDat(GroupId);
1657  			TInt SimAttrVal = (attrType==atInt ? IntCols[SimColIdx][RowI.GetRowIdx()] : StrColMaps[SimColIdx][RowI.GetRowIdx()]);
1658  			TIntH.AddDat(SimAttrVal, 0);
1659  		}
1660  		else
1661  		{
1662  			TExcept::Throw("Attribute type not supported.");
1663  		}
1664  	}
1665  	for (THash<TInt, THash<TInt, TInt> >::TIter it1 = TIntHH.BegI(); it1 < TIntHH.EndI(); it1++) {
1666  		THash<TInt, TInt> Vals1H = it1.GetDat();
1667  		TInt GroupId1 = it1.GetKey();
1668  		for (THash<TInt, THash<TInt, TInt> >::TIter it2 = TIntHH.BegI(); it2 < TIntHH.EndI(); it2++) {
1669  				int intersectionCount = 0;
1670  				TInt GroupId2 = it2.GetKey();
1671  				THash<TInt, TInt> Vals2H = it2.GetDat();
1672  				for(THash<TInt, TInt>::TIter it = Vals1H.BegI(); it < Vals1H.EndI(); it++)
1673  				{
1674  					TInt Val = it.GetKey();
1675  					if(Vals2H.IsKey(Val)){
1676  						intersectionCount+=1;
1677  					}
1678  				}
1679  				int unionCount = Vals1H.Len() + Vals2H.Len() - intersectionCount;
1680  				float distance = 1.0f - (float)intersectionCount/unionCount;
1681  				if(distance<=Threshold){
1682  						JointTable->IntCols[0].Add(GroupId1);
1683  						JointTable->IntCols[1].Add(GroupId2);
1684  						JointTable->FltCols[0].Add(distance);
1685  						JointTable->IncrementNext();
1686  			}
1687  		}
1688  	}
1689    JointTable->InitIds();
1690  	return JointTable;
1691  }
1692  PTable TTable::SelfSimJoinPerGroup(const TStrV& GroupBy, const TStr& SimCol, 
1693   const TStr& DistanceColName, const TSimType& SimType, const TFlt& Threshold) {
1694    TStrV NGroupBy = NormalizeColNameV(GroupBy);
1695  	TStrV ProjectionV;
1696  	for(TInt i=0; i<GroupBy.Len(); i++)
1697  	{
1698  		ProjectionV.Add(GroupBy[i]);
1699  	}
1700  	ProjectionV.Add(SimCol);
1701  	ProjectInPlace(ProjectionV);
1702  	TStr CName = "Group";
1703    TIntV UniqueVec;
1704    THash<TGroupKey, TPair<TInt, TIntV> > Grouping;
1705    GroupAux(NGroupBy, Grouping, false, CName, false, UniqueVec);
1706  	PTable GroupJointTable = SelfSimJoinPerGroup(CName, SimCol, DistanceColName, SimType, Threshold);
1707  	PTable JointTable = InitializeJointTable(*this);
1708  	THash<TInt, TInt> GroupIdH;
1709  	for(THash<TGroupKey, TPair<TInt, TIntV> >::TIter it=Grouping.BegI(); it<Grouping.EndI(); it++)
1710  	{
1711  		TPair<TInt, TIntV> group = it.GetDat();
1712  		TInt GroupNum = group.Val1;
1713  		TIntV RowIds = group.Val2;
1714  		if(!GroupIdH.IsKey(GroupNum))
1715  		{
1716  			TInt RandomRowId = RowIds[0];  
1717  			GroupIdH.AddDat(GroupNum, RandomRowId);
1718  		}
1719  	}
1720  	for(TRowIterator RowI = GroupJointTable->BegRI(); RowI < GroupJointTable->EndRI(); RowI++)
1721  	{
1722  		TInt GroupId1 = GroupJointTable->IntCols[0][RowI.GetRowIdx()];
1723  		TInt GroupId2 = GroupJointTable->IntCols[1][RowI.GetRowIdx()];
1724  		TInt RowId1 = GroupIdH.GetDat(GroupId1);
1725  		TInt RowId2 = GroupIdH.GetDat(GroupId2);
1726  		JointTable->AddJointRow(*this, *this, RowId1, RowId2);
1727  	} 
1728  	JointTable->StoreFltCol(DistanceColName, GroupJointTable->FltCols[0]);
1729  	ProjectionV.Clr();
1730  	ProjectionV.Add(DistanceColName);
1731  	for(TInt i=0; i<GroupBy.Len(); i++){
1732  		for(TInt j=0; j<JointTable->Sch.Len(); j++)
1733  		{
1734  			TStr ColName = JointTable->Sch[j].Val1;
1735  			if(ColName.IsStrIn(GroupBy[i]))
1736  			{
1737  				ProjectionV.Add(ColName);
1738  			}
1739  		}
1740  	}
1741  	JointTable->ProjectInPlace(ProjectionV);
1742  	JointTable->InitIds();
1743  	return JointTable;
1744  }
1745  void TTable::IncrementNext()
1746  {
1747  	NumRows++;
1748  	NumValidRows++;
1749  	if (!Next.Empty()) {
1750  		Next[Next.Len()-1] = NumValidRows-1;
1751  		LastValidRow = NumValidRows-1;
1752  	}
1753  	Next.Add(Last);
1754  }
1755  PTable TTable::Join(const TStr& Col1, const TTable& Table, const TStr& Col2) {
1756    if (!IsColName(Col1)) {
1757      TExcept::Throw("no such column " + Col1);
1758      printf("no such column %s\n", Col1.CStr());
1759    }
1760    if (!Table.IsColName(Col2)) {
1761      TExcept::Throw("no such column " + Col2);
1762      printf("no such column %s\n", Col2.CStr());
1763    }
1764    if (GetColType(Col1) != Table.GetColType(Col2)) {
1765      TExcept::Throw("Trying to Join on columns of different type");
1766      printf("Trying to Join on columns of different type\n");
1767    }
1768    PTable JointTable = InitializeJointTable(Table);
1769    TAttrType ColType = GetColType(Col1);
1770    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
1771    const TTable& TS = ThisIsSmaller ? *this : Table;
1772    const TTable& TB = ThisIsSmaller ?  Table : *this;
1773    TStr ColS = ThisIsSmaller ? Col1 : Col2;
1774    TStr ColB = ThisIsSmaller ? Col2 : Col1;
1775    TInt ColBId = ThisIsSmaller ? Table.GetColIdx(ColB) : GetColIdx(ColB);
1776  #ifdef GCC_ATOMIC
1777    if (GetMP()) {
1778      switch(ColType){
1779        case atInt:{
1780          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1781          TS.GroupByIntColMP(ColS, T, true);
1782          TIntPrV Partitions;
1783          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1784          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1785          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1786          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
1787          for (int i = 0; i < Partitions.Len(); i++){
1788            JointRowIDSet[i].Reserve(PartitionSize);
1789            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1790            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1791            while (RowI < EndI) {
1792              TInt K = RowI.GetIntAttr(ColBId);
1793              if(T.IsKey(K)){
1794                TIntV& Group = T.GetDat(K);
1795                for(TInt j = 0; j < Group.Len(); j++){
1796                  if(ThisIsSmaller){
1797                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1798                  } else{
1799                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1800                  }
1801                }
1802              }
1803              RowI++;
1804            }
1805          }
1806          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);      
1807          break;
1808        }
1809        case atFlt:{
1810          THashMP<TFlt, TIntV> T(TS.GetNumValidRows());
1811          TS.GroupByFltCol(ColS, T, TIntV(), true);
1812          TIntPrV Partitions;
1813          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1814          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1815          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1816          #pragma omp parallel for schedule(dynamic) 
1817          for (int i = 0; i < Partitions.Len(); i++){
1818            JointRowIDSet[i].Reserve(PartitionSize);
1819            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1820            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1821            while (RowI < EndI) {
1822              TFlt K = RowI.GetFltAttr(ColBId);
1823              if(T.IsKey(K)){
1824                TIntV& Group = T.GetDat(K);
1825                for(TInt j = 0; j < Group.Len(); j++){
1826                  if(ThisIsSmaller){
1827                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1828                  } else{
1829                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1830                  }
1831                }
1832              }
1833              RowI++;
1834            }
1835          }
1836          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1837          break;
1838        }
1839        case atStr:{
1840          THashMP<TInt, TIntV> T(TS.GetNumValidRows());
1841          TS.GroupByStrCol(ColS, T, TIntV(), true);
1842          TIntPrV Partitions;
1843          TB.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
1844          TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
1845          TVec<TIntPrV> JointRowIDSet(Partitions.Len());
1846          #pragma omp parallel for schedule(dynamic) 
1847          for (int i = 0; i < Partitions.Len(); i++){
1848            JointRowIDSet[i].Reserve(PartitionSize);
1849            TRowIterator RowI(Partitions[i].GetVal1(), &TB);
1850            TRowIterator EndI(Partitions[i].GetVal2(), &TB);
1851            while (RowI < EndI) {
1852              TInt K = RowI.GetStrMapById(ColBId);
1853              if(T.IsKey(K)){
1854                TIntV& Group = T.GetDat(K);
1855                for(TInt j = 0; j < Group.Len(); j++){
1856                  if(ThisIsSmaller){
1857                    JointRowIDSet[i].Add(TIntPr(Group[j], RowI.GetRowIdx()));
1858                  } else{
1859                    JointRowIDSet[i].Add(TIntPr(RowI.GetRowIdx(), Group[j]));
1860                  }
1861                }
1862              }
1863              RowI++;
1864            }
1865          }
1866          JointTable->AddNJointRowsMP(*this, Table, JointRowIDSet);
1867        }
1868        break;
1869      }
1870    } else {
1871  #endif 
1872      switch (ColType) {
1873        case atInt:{
1874          TIntIntVH T;
1875          TS.GroupByIntCol(ColS, T, TIntV(), true);
1876          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1877            TInt K = RowI.GetIntAttr(ColBId);
1878            if (T.IsKey(K)) {
1879              TIntV& Group = T.GetDat(K);
1880              for (TInt i = 0; i < Group.Len(); i++) {
1881                if (ThisIsSmaller) {
1882                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1883                } else {
1884                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1885                }
1886              }
1887            }
1888          }
1889          break;
1890        }
1891        case atFlt:{
1892          THash<TFlt, TIntV> T;
1893          TS.GroupByFltCol(ColS, T, TIntV(), true);
1894          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1895            TFlt K = RowI.GetFltAttr(ColBId);
1896            if (T.IsKey(K)) {
1897              TIntV& Group = T.GetDat(K);
1898              for (TInt i = 0; i < Group.Len(); i++) {
1899                if (ThisIsSmaller) {
1900                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1901                } else {
1902                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1903                }
1904              }
1905            }
1906          }
1907          break;
1908        }
1909        case atStr:{
1910          TIntIntVH T;
1911          TS.GroupByStrCol(ColS, T, TIntV(), true);
1912          for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1913            TInt K = RowI.GetStrMapById(ColBId);
1914            if (T.IsKey(K)) {
1915              TIntV& Group = T.GetDat(K);
1916              for (TInt i = 0; i < Group.Len(); i++) {
1917                if (ThisIsSmaller) {
1918                  JointTable->AddJointRow(*this, Table, Group[i], RowI.GetRowIdx());
1919                } else {
1920                  JointTable->AddJointRow(*this, Table, RowI.GetRowIdx(), Group[i]);
1921                }
1922              }
1923            }
1924          }
1925        }
1926        break;
1927      }
1928  #ifdef GCC_ATOMIC
1929    }
1930  #endif
1931    return JointTable; 
1932  }
1933  void TTable::ThresholdJoinInputCorrectness(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
1934    const TStr& KeyCol2, const TStr& JoinCol2){
1935    if (!IsColName(KeyCol1)) {
1936      printf("no such column %s\n", KeyCol1.CStr());
1937      TExcept::Throw("no such column " + KeyCol1);
1938    }
1939    if (!Table.IsColName(KeyCol2)) {
1940      printf("no such column %s\n", KeyCol2.CStr());
1941      TExcept::Throw("no such column " + KeyCol2);
1942    }
1943    if (!IsColName(JoinCol1)) {
1944      printf("no such column %s\n", JoinCol1.CStr());
1945      TExcept::Throw("no such column " + JoinCol1);
1946    }
1947    if (!Table.IsColName(JoinCol2)) {
1948      printf("no such column %s\n", JoinCol2.CStr());
1949      TExcept::Throw("no such column " + JoinCol2);
1950    }
1951    if (GetColType(JoinCol1) != Table.GetColType(JoinCol2)) {
1952      printf("Trying to Join on columns of different type\n");
1953      TExcept::Throw("Trying to Join on columns of different type");
1954    }
1955    if (GetColType(KeyCol1) != Table.GetColType(KeyCol2)) {
1956      printf("Key type mismatch\n");
1957      TExcept::Throw("Key type mismatch");
1958    }
1959  }
1960  void TTable::ThresholdJoinCountCollisions(const TTable& TB, const TTable& TS, 
1961    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
1962    THash<TIntPr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
1963      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
1964        TInt JVal = 0;
1965        if(JoinColType == atStr){
1966          JVal = RowI.GetStrMapById(JoinColIdxB);
1967        } else{
1968          JVal = RowI.GetIntAttr(JoinColIdxB);
1969        }
1970        if(T.IsKey(JVal)){
1971          TInt KeyB = 0;
1972          if(KeyType == atStr){
1973            KeyB = RowI.GetStrMapById(KeyColIdxB);
1974          } else{
1975            KeyB = RowI.GetIntAttr(KeyColIdxB);
1976          } 
1977          const TIntV& RelevantRows = T.GetDat(JVal);
1978          for(int i = 0; i < RelevantRows.Len(); i++){
1979            TInt KeyS = 0;
1980            if(KeyType == atStr){
1981              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
1982            } else{
1983              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
1984            }
1985            TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
1986            if(Counters.IsKey(Keys)){
1987              TIntTr& V = Counters.GetDat(Keys);
1988              V.Val3 = V.Val3 + 1;
1989            } else{
1990              if(ThisIsSmaller){
1991                Counters.AddDat(Keys, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
1992              } else{
1993                Counters.AddDat(Keys, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
1994              }
1995            }
1996          }	
1997        }	
1998      } 
1999  }
2000  void TTable::ThresholdJoinCountPerJoinKeyCollisions(const TTable& TB, const TTable& TS, 
2001    const TIntIntVH& T, TInt JoinColIdxB, TInt KeyColIdxB, TInt KeyColIdxS, 
2002    THash<TIntTr,TIntTr>& Counters, TBool ThisIsSmaller, TAttrType JoinColType, TAttrType KeyType){
2003      for (TRowIterator RowI = TB.BegRI(); RowI < TB.EndRI(); RowI++) {
2004        TInt JVal = 0;
2005        if(JoinColType == atStr){
2006          JVal = RowI.GetStrMapById(JoinColIdxB);
2007         } else{
2008          JVal = RowI.GetIntAttr(JoinColIdxB);
2009         }
2010        if(T.IsKey(JVal)){
2011          TInt KeyB = 0;
2012          if(KeyType == atStr){
2013            KeyB = RowI.GetStrMapById(KeyColIdxB);
2014          } else{
2015            KeyB = RowI.GetIntAttr(KeyColIdxB);
2016          } 
2017          const TIntV& RelevantRows = T.GetDat(JVal);
2018          for(int i = 0; i < RelevantRows.Len(); i++){
2019            TInt KeyS = 0;
2020            if(KeyType == atStr){
2021              KeyS = TS.StrColMaps[KeyColIdxS][RelevantRows[i]];
2022            } else{
2023              KeyS = TS.IntCols[KeyColIdxS][RelevantRows[i]];
2024            }
2025          	TIntPr Keys = ThisIsSmaller ? TIntPr(KeyS, KeyB) : TIntPr(KeyB, KeyS);
2026          	TIntTr K(Keys.Val1,Keys.Val2,JVal);
2027            if(Counters.IsKey(K)){
2028              TIntTr& V = Counters.GetDat(K);
2029              V.Val3 = V.Val3 + 1;
2030            } else{
2031              if(ThisIsSmaller){
2032                Counters.AddDat(K, TIntTr(RelevantRows[i], RowI.GetRowIdx(),1));
2033              } else{
2034                Counters.AddDat(K, TIntTr(RowI.GetRowIdx(), RelevantRows[i],1));
2035              }
2036            }
2037          }	
2038        }	
2039      } 
2040    }
2041  PTable TTable::ThresholdJoinOutputTable(const THash<TIntPr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2042    PTable JointTable = InitializeJointTable(Table);
2043    for(THash<TIntPr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2044      TIntTr& Counter = iter.GetDat();
2045      if(Counter.Val3 >= Threshold){
2046        JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2047      }
2048    }
2049    return JointTable;
2050  }
2051  PTable TTable::ThresholdJoinPerJoinKeyOutputTable(const THash<TIntTr,TIntTr>& Counters, TInt Threshold, const TTable& Table){
2052    PTable JointTable = InitializeJointTable(Table);
2053    for(THash<TIntTr,TIntTr>::TIter iter = Counters.BegI(); iter < Counters.EndI(); iter++){
2054      const TIntTr& Counter = iter.GetDat();
2055      const TIntTr& Keys = iter.GetKey();
2056      THashSet<TIntPr> Pairs;
2057      if(Counter.Val3 >= Threshold){
2058        TIntPr K(Keys.Val1,Keys.Val2);
2059        if(!Pairs.IsKey(K)){
2060          Pairs.AddKey(K);
2061          JointTable->AddJointRow(*this, Table, Counter.Val1, Counter.Val2);
2062        }
2063      }
2064    }
2065    return JointTable;
2066  }
2067  PTable TTable::ThresholdJoin(const TStr& KeyCol1, const TStr& JoinCol1, const TTable& Table, 
2068    const TStr& KeyCol2, const TStr& JoinCol2, TInt Threshold, TBool PerJoinKey){
2069    ThresholdJoinInputCorrectness(KeyCol1, JoinCol1, Table, KeyCol2, JoinCol2);
2070    TAttrType JoinColType = GetColType(JoinCol1);
2071    TAttrType KeyType = GetColType(KeyCol1);
2072    TBool ThisIsSmaller = (NumValidRows <= Table.NumValidRows);
2073    const TTable& TS = ThisIsSmaller ? *this : Table;
2074    const TTable& TB = ThisIsSmaller ?  Table : *this;
2075    TStr JoinColS = JoinCol1;
2076    TInt JoinColIdxB = GetColIdx(JoinCol2);
2077    TInt KeyColIdxS = GetColIdx(KeyCol1);
2078    TInt KeyColIdxB = GetColIdx(KeyCol2);
2079    if(!ThisIsSmaller){
2080    	JoinColS = JoinCol2;
2081      JoinColIdxB = GetColIdx(JoinCol1);
2082    	KeyColIdxS = GetColIdx(KeyCol2);
2083      KeyColIdxB = GetColIdx(KeyCol1);
2084    }
2085    if(KeyType != atInt && KeyType != atStr){
2086      printf("ThresholdJoin only supports integer or string key attributes\n");
2087      TExcept::Throw("ThresholdJoin only supports integer or string key attributes");
2088    }
2089    if(JoinColType != atInt && JoinColType != atStr){
2090      printf("ThresholdJoin only supports integer or string join attributes\n");
2091      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2092    }
2093    TIntIntVH T;
2094    if(JoinColType == atInt){
2095      TS.GroupByIntCol(JoinColS, T, TIntV(), true);
2096    } else if(JoinColType == atStr){
2097      TS.GroupByStrCol(JoinColS, T, TIntV(), true);
2098    } else{
2099      TExcept::Throw("ThresholdJoin only supports integer or string join attributes");
2100    } 
2101    if(PerJoinKey){
2102      THash<TIntTr,TIntTr> Counters;
2103      ThresholdJoinCountPerJoinKeyCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2104      return ThresholdJoinPerJoinKeyOutputTable(Counters, Threshold, Table);
2105    } else{
2106      THash<TIntPr,TIntTr> Counters;
2107      ThresholdJoinCountCollisions(TB, TS, T, JoinColIdxB, KeyColIdxB, KeyColIdxS, Counters, ThisIsSmaller, JoinColType, KeyType);
2108      return ThresholdJoinOutputTable(Counters, Threshold, Table);
2109    }
2110  }
2111  void TTable::Select(TPredicate& Predicate, TIntV& SelectedRows, TBool Remove) {
2112    TIntV Selected;
2113    TStrV RelevantCols;
2114    Predicate.GetVariables(RelevantCols);
2115    TInt NumRelevantCols = RelevantCols.Len();
2116    TVec<TAttrType> ColTypes = TVec<TAttrType>(NumRelevantCols);
2117    TIntV ColIndices = TIntV(NumRelevantCols);
2118    for (TInt i = 0; i < NumRelevantCols; i++) {
2119      ColTypes[i] = GetColType(RelevantCols[i]);
2120      ColIndices[i] = GetColIdx(RelevantCols[i]);
2121    } 
2122    if (Remove) {
2123      TRowIteratorWithRemove RowI = BegRIWR();
2124      while (RowI.GetNextRowIdx() != Last) {
2125        for (TInt i = 0; i < NumRelevantCols; i++) {
2126          switch (ColTypes[i]) {
2127          case atInt:
2128            Predicate.SetIntVal(RelevantCols[i], RowI.GetNextIntAttr(ColIndices[i]));
2129            break;
2130          case atFlt:
2131            Predicate.SetFltVal(RelevantCols[i], RowI.GetNextFltAttr(ColIndices[i]));
2132            break;
2133          case atStr:
2134            Predicate.SetStrVal(RelevantCols[i], RowI.GetNextStrAttr(ColIndices[i]));
2135            break;
2136          }
2137        }
2138        if (!Predicate.Eval()) { 
2139          RowI.RemoveNext();
2140        } else {
2141          RowI++;
2142        }
2143      }
2144    } else {
2145      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2146        for (TInt i = 0; i < NumRelevantCols; i++) {
2147          switch (ColTypes[i]) {
2148          case atInt:
2149            Predicate.SetIntVal(RelevantCols[i], RowI.GetIntAttr(RelevantCols[i]));
2150            break;
2151          case atFlt:
2152            Predicate.SetFltVal(RelevantCols[i], RowI.GetFltAttr(RelevantCols[i]));
2153            break;
2154          case atStr:
2155            Predicate.SetStrVal(RelevantCols[i], RowI.GetStrAttr(RelevantCols[i]));
2156            break;
2157          }
2158        }
2159        if (Predicate.Eval()) { SelectedRows.Add(RowI.GetRowIdx()); }
2160      }
2161    }
2162  }
2163  void TTable::Classify(TPredicate& Predicate, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2164    TIntV SelectedRows;
2165    Select(Predicate, SelectedRows, false);
2166    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2167  }
2168  void TTable::SelectAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp, TIntV& SelectedRows, TBool Remove) {
2169    const TAttrType Ty1 = GetColType(Col1);
2170    const TAttrType Ty2 = GetColType(Col2);
2171    const TInt ColIdx1 = GetColIdx(Col1);
2172    const TInt ColIdx2 = GetColIdx(Col2);
2173    if (Ty1 != Ty2) {
2174      TExcept::Throw("SelectAtomic: diff types");
2175    }
2176    if (Cmp == SUBSTR || Cmp == SUPERSTR) { Assert(Ty1 == atStr); }
2177    if (Remove) {
2178      TRowIteratorWithRemove RowI = BegRIWR();
2179      while (RowI.GetNextRowIdx() != Last) {
2180        TBool Result;
2181        switch (Ty1) {
2182          case atInt:
2183            Result = TPredicate::EvalAtom(RowI.GetNextIntAttr(ColIdx1), RowI.GetNextIntAttr(ColIdx2), Cmp);
2184            break;
2185          case atFlt:
2186            Result = TPredicate::EvalAtom(RowI.GetNextFltAttr(ColIdx1), RowI.GetNextFltAttr(ColIdx2), Cmp);
2187            break;
2188          case atStr:
2189            Result = TPredicate::EvalStrAtom(RowI.GetNextStrAttr(ColIdx1), RowI.GetNextStrAttr(ColIdx2), Cmp);
2190            break;
2191        }
2192        if (!Result) { 
2193          RowI.RemoveNext();
2194        } else {
2195          RowI++;
2196        }
2197      }
2198    } else {
2199      for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
2200        TBool Result;
2201        switch (Ty1) {
2202          case atInt:
2203            Result = TPredicate::EvalAtom(RowI.GetIntAttr(Col1), RowI.GetIntAttr(Col2), Cmp);
2204            break;
2205          case atFlt:
2206            Result = TPredicate::EvalAtom(RowI.GetFltAttr(Col1), RowI.GetFltAttr(Col2), Cmp);
2207            break;
2208          case atStr:
2209            Result = TPredicate::EvalStrAtom(RowI.GetStrAttr(Col1), RowI.GetStrAttr(Col2), Cmp);
2210            break;
2211        }
2212        if (Result) { SelectedRows.Add(RowI.GetRowIdx()); }
2213      }
2214    }
2215  }
2216  void TTable::ClassifyAtomic(const TStr& Col1, const TStr& Col2, TPredComp Cmp,
2217    const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
2218    TIntV SelectedRows;
2219    SelectAtomic(Col1, Col2, Cmp, SelectedRows, false);
2220    ClassifyAux(SelectedRows, LabelName, PositiveLabel, NegativeLabel);
2221  }
2222  void TTable::SelectAtomicConst(const TStr& Col, const TPrimitive& Val, TPredComp Cmp, 
2223    TIntV& SelectedRows, PTable& SelectedTable, TBool Remove, TBool Table) {
2224    TStr ValTStr(Val.GetStr());
2225    TAttrType Type = GetColType(Col);
2226    TInt ColIdx = GetColIdx(Col);
2227    if (Type != Val.GetType()) { 
2228      TExcept::Throw("SelectAtomicConst: coltype does not match const type"); 
2229    }
2230    if(Remove){
2231  #ifdef USE_OPENMP
2232      if (GetMP()) {
2233        TIntPrV Partitions;
2234        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2235        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2236        int RemoveCount = 0;
2237        TIntPrV Bounds(Partitions.Len());
2238        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:RemoveCount)
2239        for (int i = 0; i < Partitions.Len(); i++){
2240          TRowIterator RowI(Partitions[i].GetVal1(), this);
2241          TRowIterator EndI(Partitions[i].GetVal2(), this);
2242          TInt FirstRowIdx = TTable::Invalid;
2243          TInt LastRowIdx = TTable::Invalid;
2244          TBool First = true;
2245          while (RowI < EndI) {
2246            TInt CurrRowIdx = RowI.GetRowIdx();
2247            TBool Result;
2248            if (Type != atStr) {
2249              Result = RowI.CompareAtomicConst(ColIdx, Val, Cmp);
2250            } else {
2251              Result = RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp);
2252            }
2253            RowI++;
2254            if(!Result) {
2255              Next[CurrRowIdx] = TTable::Invalid;
2256              RemoveCount++;
2257            } else { 
2258              if (First) { FirstRowIdx = CurrRowIdx; First = false; } 
2259              else { Next[LastRowIdx] = CurrRowIdx; }
2260              LastRowIdx = CurrRowIdx; 
2261            }
2262          }
2263          Bounds[i] = TIntPr(FirstRowIdx, LastRowIdx);
2264        }
2265        TInt CurrBound = 0;
2266        while (CurrBound < Bounds.Len() && Bounds[CurrBound].Val1 == TTable::Invalid) {
2267          CurrBound++;
2268        }
2269        if (CurrBound == Bounds.Len()) {
2270          Assert(NumValidRows == RemoveCount);
2271          NumValidRows = 0;
2272          FirstValidRow = TTable::Invalid;
2273          LastValidRow = TTable::Invalid;
2274        } else {
2275          NumValidRows -= RemoveCount;
2276          FirstValidRow = Bounds[CurrBound].Val1;
2277          LastValidRow = Bounds[CurrBound].Val2;
2278          TInt PrevBound = CurrBound;
2279          CurrBound++;
2280          while (CurrBound < Bounds.Len()) {
2281            if (Bounds[CurrBound].Val1 == TTable::Invalid) { CurrBound++; continue; }
2282            Next[Bounds[PrevBound].Val2] = Bounds[CurrBound].Val1;
2283            LastValidRow = Bounds[CurrBound].Val2;
2284            PrevBound = CurrBound;
2285            CurrBound++;
2286          }
2287          Next[Bounds[PrevBound].Val2] = TTable::Last;
2288        }
2289        IsNextDirty = 1;
2290      } else {
2291  #endif
2292        TRowIteratorWithRemove RowI = BegRIWR();
2293        while(RowI.GetNextRowIdx() != Last){
2294          if (!RowI.CompareAtomicConst(ColIdx, Val, Cmp)) {
2295            RowI.RemoveNext();
2296          } else {
2297            RowI++;
2298          }
2299        }
2300        IsNextDirty = 1;
2301  #ifdef USE_OPENMP
2302      }
2303  #endif
2304    } else if (Table) {
2305  #ifdef USE_OPENMP
2306      if (GetMP()) {
2307        TIntPrV Partitions;
2308        GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
2309        TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
2310        int TotalSelectedRows = 0;
2311        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) reduction(+:TotalSelectedRows)
2312        for (int i = 0; i < Partitions.Len(); i++){
2313          TRowIterator RowI(Partitions[i].GetVal1(), this);
2314          TRowIterator EndI(Partitions[i].GetVal2(), this);
2315          while (RowI < EndI) {
2316            if (Type != atStr) {
2317              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2318                TotalSelectedRows++;
2319              }
2320            } else {
2321              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2322                TotalSelectedRows++;
2323              }
2324            }
2325            RowI++;
2326          }
2327        }
2328        SelectedTable->ResizeTable(TotalSelectedRows);
2329        if (TotalSelectedRows == 0) {
2330          return;
2331        }
2332        #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
2333        for (int i = 0; i < Partitions.Len(); i++){
2334          TIntV LocalSelectedRows;
2335          LocalSelectedRows.Reserve(PartitionSize);
2336          TRowIterator RowI(Partitions[i].GetVal1(), this);
2337          TRowIterator EndI(Partitions[i].GetVal2(), this);
2338          while (RowI < EndI) {
2339            if (Type != atStr) {
2340              if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2341                LocalSelectedRows.Add(RowI.GetRowIdx());
2342              }
2343            } else {
2344              if (RowI.CompareAtomicConstTStr(ColIdx, ValTStr, Cmp)) { 
2345                LocalSelectedRows.Add(RowI.GetRowIdx());
2346              }
2347            }
2348            RowI++;
2349          }
2350          SelectedTable->AddSelectedRows(*this, LocalSelectedRows);
2351        }
2352        SelectedTable->SetFirstValidRow();
2353      } else {
2354  #endif
2355        for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2356          if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2357            SelectedTable->AddRowI(RowI);
2358          }
2359        }
2360  #ifdef USE_OPENMP
2361      }
2362  #endif
2363    } else {
2364      for(TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++){
2365        if (RowI.CompareAtomicConst(ColIdx, Val, Cmp)) { 
2366          SelectedRows.Add(RowI.GetRowIdx());
2367        }
2368      }
2369    }
2370  }
2371  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TAttrType& CompareByType, const TInt& CompareByIndex, TBool Asc) {
2372    switch (CompareByType) {
2373      case atInt:{
2374        if (IntCols[CompareByIndex][R1] > IntCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2375        if (IntCols[CompareByIndex][R1] < IntCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2376        return 0;
2377      }
2378      case atFlt:{
2379        if (FltCols[CompareByIndex][R1] > FltCols[CompareByIndex][R2]) { return (Asc ? 1 : -1); }
2380        if (FltCols[CompareByIndex][R1] < FltCols[CompareByIndex][R2]) { return (Asc ? -1 : 1); }
2381        return 0;
2382      }
2383      case atStr:{
2384        TStr S1 = GetStrValIdx(CompareByIndex, R1);
2385        TStr S2 = GetStrValIdx(CompareByIndex, R2);
2386        int CmpRes = strcmp(S1.CStr(), S2.CStr());
2387        return (Asc ? CmpRes : -CmpRes);
2388      }
2389    }
2390    return 0;
2391  }
2392  inline TInt TTable::CompareRows(TInt R1, TInt R2, const TVec<TAttrType>& CompareByTypes, const TIntV& CompareByIndices, TBool Asc) {
2393    for (TInt i = 0; i < CompareByTypes.Len(); i++) {
2394      TInt res = CompareRows(R1, R2, CompareByTypes[i], CompareByIndices[i], Asc);
2395      if (res != 0) { return res; }
2396    }
2397    return 0;
2398  }
2399  void TTable::ISort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2400    if (StartIdx < EndIdx) {
2401      for (TInt i = StartIdx+1; i <= EndIdx; i++) {
2402        TInt Val = V[i];
2403        TInt j = i;
2404        while ((StartIdx < j) && (CompareRows(V[j-1], Val, SortByTypes, SortByIndices, Asc) > 0)) {
2405          V[j] = V[j-1];
2406          j--;
2407        }
2408        V[j] = Val;
2409      }
2410    }
2411  }
2412  TInt TTable::GetPivot(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2413    TInt L = EndIdx - StartIdx + 1;
2414    const TInt Idx1 = StartIdx + TInt::GetRnd(L);
2415    const TInt Idx2 = StartIdx + TInt::GetRnd(L);
2416    const TInt Idx3 = StartIdx + TInt::GetRnd(L);
2417    if (CompareRows(V[Idx1], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) {
2418      if (CompareRows(V[Idx2], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2419      if (CompareRows(V[Idx1], V[Idx3], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2420      return Idx1;
2421    } else {
2422      if (CompareRows(V[Idx3], V[Idx2], SortByTypes, SortByIndices, Asc) < 0) { return Idx2; }
2423      if (CompareRows(V[Idx3], V[Idx1], SortByTypes, SortByIndices, Asc) < 0) { return Idx3; }
2424      return Idx1;
2425    }
2426  }
2427  TInt TTable::Partition(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2428    TInt j;
2429    for (j = StartIdx; j < EndIdx; j++) {
2430      if (CompareRows(V[j], V[j+1], SortByTypes, SortByIndices, Asc) > 0) {
2431        break;
2432      }
2433    }
2434    if (j >= EndIdx) {
2435      return EndIdx+1;
2436    }
2437    TInt PivotIdx = GetPivot(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2438    TInt Pivot = V[PivotIdx];
2439    V.Swap(PivotIdx, EndIdx);
2440    TInt StoreIdx = StartIdx;
2441    for (TInt i = StartIdx; i < EndIdx; i++) {
2442      if (CompareRows(V[i], Pivot, SortByTypes, SortByIndices, Asc) <= 0) {
2443        V.Swap(i, StoreIdx);
2444        StoreIdx++;
2445      }
2446    }
2447    V.Swap(StoreIdx, EndIdx);
2448    return StoreIdx;
2449  }
2450  void TTable::QSort(TIntV& V, TInt StartIdx, TInt EndIdx, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2451    if (StartIdx < EndIdx) {
2452      if (EndIdx - StartIdx < 20) {
2453        ISort(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2454      } else {
2455        TInt Pivot = Partition(V, StartIdx, EndIdx, SortByTypes, SortByIndices, Asc);
2456        if (Pivot > EndIdx) {
2457          return;
2458        }
2459        int Ub = Pivot - 1;
2460        while (Ub >= StartIdx && CompareRows(
2461          V[Ub], V[Pivot], SortByTypes, SortByIndices, Asc) == 0) {
2462          Ub -= 1;
2463        }
2464        QSort(V, StartIdx, Ub, SortByTypes, SortByIndices, Asc);
2465        QSort(V, Pivot+1, EndIdx, SortByTypes, SortByIndices, Asc);
2466      }
2467    }
2468  }
2469  void TTable::Merge(TIntV& V, TInt Idx1, TInt Idx2, TInt Idx3, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2470    TInt i = Idx1, j = Idx2;
2471    TIntV SortedV;
2472    while  (i < Idx2 && j < Idx3) {
2473      if (CompareRows(V[i], V[j], SortByTypes, SortByIndices, Asc) <= 0) {
2474        SortedV.Add(V[i]);
2475        i++;
2476      }
2477      else {
2478        SortedV.Add(V[j]);
2479        j++;
2480      }
2481    }
2482    while (i < Idx2) {
2483      SortedV.Add(V[i]);
2484      i++;
2485    }
2486    while (j < Idx3) {
2487      SortedV.Add(V[j]);
2488      j++;
2489    }
2490    for (TInt sz = 0; sz < Idx3 - Idx1; sz++) {
2491      V[Idx1 + sz] = SortedV[sz];
2492    }
2493  }
2494  #ifdef USE_OPENMP
2495  void TTable::QSortPar(TIntV& V, const TVec<TAttrType>& SortByTypes, const TIntV& SortByIndices, TBool Asc) {
2496    TInt NumThreads = 8; 
2497    TInt Sz = V.Len();
2498    TIntV IndV, NextV;
2499    for (TInt i = 0; i < NumThreads; i++) {
2500      IndV.Add(i * (Sz / NumThreads));
2501    }
2502    IndV.Add(Sz);
2503    omp_set_num_threads(NumThreads);
2504    #pragma omp parallel for
2505    for (int i = 0; i < NumThreads; i++) {
2506      QSort(V, IndV[i], IndV[i+1] - 1, SortByTypes, SortByIndices, Asc);
2507    }
2508    while (NumThreads > 1) {
2509      omp_set_num_threads(NumThreads / 2);
2510      #pragma omp parallel for
2511      for (int i = 0; i < NumThreads; i += 2) {
2512        Merge(V, IndV[i], IndV[i+1], IndV[i+2], SortByTypes, SortByIndices, Asc);
2513      }
2514      NextV.Clr();
2515      for (TInt i = 0; i < NumThreads; i+=2) {
2516        NextV.Add(IndV[i]);
2517      }
2518      NextV.Add(Sz);
2519      IndV = NextV;
2520      NumThreads = NumThreads / 2;
2521    }
2522  }
2523  #endif 
2524  void TTable::Order(const TStrV& OrderBy, TStr OrderColName, TBool ResetRankByMSC, TBool Asc) {
2525    TIntV ValidRows = TIntV(NumValidRows);
2526    if (NumRows == NumValidRows) {
2527      for (TInt i = 0; i < NumValidRows; i++) {
2528        ValidRows[i] = i;
2529      }
2530    } else {
2531      TInt i = 0;
2532      for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
2533        ValidRows[i] = RI.GetRowIdx();
2534        i++;
2535      }
2536    }
2537    TVec<TAttrType> OrderByTypes(OrderBy.Len());
2538    TIntV OrderByIndices(OrderBy.Len());
2539    for (TInt i = 0; i < OrderBy.Len(); i++) {
2540      OrderByTypes[i] = GetColType(OrderBy[i]);
2541      OrderByIndices[i] = GetColIdx(OrderBy[i]);
2542    }
2543  #ifdef USE_OPENMP
2544    if (GetMP()) {
2545      QSortPar(ValidRows, OrderByTypes, OrderByIndices, Asc);
2546    } else {
2547  #endif
2548      QSort(ValidRows, 0, NumValidRows-1, OrderByTypes, OrderByIndices, Asc);
2549  #ifdef USE_OPENMP
2550    }
2551  #endif
2552    IsNextDirty = 1;
2553    if (NumValidRows > 0) {
2554      FirstValidRow = ValidRows[0];
2555    } else {
2556      FirstValidRow = Last;
2557    }
2558    for (TInt i = 0; i < NumValidRows-1; i++) {
2559      Next[ValidRows[i]] = ValidRows[i+1];
2560    }
2561    if (NumValidRows > 0) {
2562      Next[ValidRows[NumValidRows-1]] = Last;
2563      LastValidRow = ValidRows[NumValidRows-1];
2564    } else {
2565      LastValidRow = Last;
2566    }
2567    if (!OrderColName.Empty()) {
2568      TIntV RankCol = TIntV(NumRows);
2569      for (TInt i = 0; i < NumValidRows; i++) {
2570        RankCol[ValidRows[i]] = i;
2571      }
2572      if (ResetRankByMSC) {
2573        for (TInt i = 1; i < NumValidRows; i++) {
2574          TStr GroupName = OrderBy[0];
2575          if (GetStrVal(GroupName, ValidRows[i]) != GetStrVal(GroupName, ValidRows[i-1])) { 
2576            RankCol[ValidRows[i]] = 0;
2577          } else {
2578            RankCol[ValidRows[i]] = RankCol[ValidRows[i-1]] + 1;
2579          }
2580        }
2581      }
2582      IntCols.Add(RankCol);
2583      AddSchemaCol(OrderColName, atInt);
2584      AddColType(OrderColName, atInt, IntCols.Len()-1);
2585    }
2586  }
2587  void TTable::Defrag() {
2588    TInt FreeIndex = 0;
2589    TIntV Mapping;  
2590    TInt IdColIdx = GetColIdx(IdColName);
2591    for (TInt i = 0; i < Next.Len(); i++) {
2592      if (Next[i] != TTable::Invalid) {  
2593        if (FreeIndex == 0) {
2594          Assert (i == FirstValidRow);
2595          FirstValidRow = 0;
2596        }
2597        if (Next[i] != Last) { 
2598          Next[FreeIndex] = FreeIndex + 1;
2599          Mapping.Add(FreeIndex);
2600        } else {
2601          Next[FreeIndex] = Last;
2602          LastValidRow = FreeIndex;
2603          Mapping.Add(Last);
2604        }
2605        RowIdMap.AddDat(IntCols[IdColIdx][i], FreeIndex);
2606        for (TInt j = 0; j < IntCols.Len(); j++) {
2607          IntCols[j][FreeIndex] = IntCols[j][i];
2608        }
2609        for (TInt j = 0; j < FltCols.Len(); j++) {
2610          FltCols[j][FreeIndex] = FltCols[j][i];
2611        }
2612        for (TInt j = 0; j < StrColMaps.Len(); j++) {
2613          StrColMaps[j][FreeIndex] = StrColMaps[j][i];
2614        }
2615        FreeIndex++;
2616      } else {
2617        NumRows--;
2618        Mapping.Add(TTable::Invalid);
2619      }
2620    }
2621    Assert (NumValidRows == NumRows);
2622  }
2623  void TTable::SelectFirstNRows(const TInt& N) {
2624    if (N == 0) {
2625      LastValidRow = -1;
2626      return;
2627    }
2628    TRowIterator RowI = BegRI();
2629    TInt count = 1;
2630    while (count < N) {
2631      if (!(RowI < EndRI())) {
2632        return; 
2633      }
2634      RowI++;
2635      count++;
2636    }
2637    NumValidRows = N;
2638    TInt LastId = RowI.GetRowIdx();
2639    if (Next[LastId] == Last) {
2640      return; 
2641    }
2642    TInt CurrId = LastId;
2643    while (Next[CurrId] != Last) {
2644      Assert(Next[CurrId] != Invalid);
2645      TInt NextId = Next[CurrId];
2646      Next[CurrId] = Invalid;
2647      CurrId = NextId;
2648    }
2649    Next[LastId] = Last;
2650    LastValidRow = LastId;
2651  }
2652  inline void TTable::CheckAndAddIntNode(PNEANet Graph, THashSet<TInt>& NodeVals, TInt NodeId) {
2653    if (!NodeVals.IsKey(NodeId)) {
2654      Graph->AddNode(NodeId);
2655      NodeVals.AddKey(NodeId);
2656    }
2657  }
2658  inline void TTable::AddEdgeAttributes(PNEANet& Graph, int RowId) {
2659    for (TInt i = 0; i < EdgeAttrV.Len(); i++) {
2660      TStr ColName = EdgeAttrV[i];
2661      TAttrType T = GetColType(ColName);
2662      TInt Index = GetColIdx(ColName);
2663      switch (T) {
2664        case atInt:
2665          Graph->AddIntAttrDatE(RowId, IntCols[Index][RowId], ColName);
2666          break;
2667        case atFlt:
2668          Graph->AddFltAttrDatE(RowId, FltCols[Index][RowId], ColName);
2669          break;
2670        case atStr:
2671          Graph->AddStrAttrDatE(RowId, GetStrValIdx(Index, RowId), ColName);
2672          break;
2673      }
2674    }
2675  }
2676  inline void TTable::AddNodeAttributes(TInt NId, TStrV NodeAttrV, TInt RowId, THash<TInt, TStrIntVH>& NodeIntAttrs,
2677    THash<TInt, TStrFltVH>& NodeFltAttrs, THash<TInt, TStrStrVH>& NodeStrAttrs) {
2678    for (TInt i = 0; i < NodeAttrV.Len(); i++) {
2679      TStr ColAttr = NodeAttrV[i];
2680      TAttrType CT = GetColType(ColAttr);
2681      int ColId = GetColIdx(ColAttr);
2682      for (TInt i = 0; i < CommonNodeAttrs.Len(); i++) {
2683        if (CommonNodeAttrs[i].Val1 == ColAttr || CommonNodeAttrs[i].Val2 == ColAttr) {
2684          ColAttr = CommonNodeAttrs[i].Val3;
2685          break;
2686        }
2687      }
2688      if (CT == atInt) {
2689        if (!NodeIntAttrs.IsKey(NId)) { NodeIntAttrs.AddKey(NId); }
2690        if (!NodeIntAttrs.GetDat(NId).IsKey(ColAttr)) { NodeIntAttrs.GetDat(NId).AddKey(ColAttr); }
2691        NodeIntAttrs.GetDat(NId).GetDat(ColAttr).Add(IntCols[ColId][RowId]);
2692      } else if (CT == atFlt) {
2693        if (!NodeFltAttrs.IsKey(NId)) { NodeFltAttrs.AddKey(NId); }
2694        if (!NodeFltAttrs.GetDat(NId).IsKey(ColAttr)) { NodeFltAttrs.GetDat(NId).AddKey(ColAttr); }
2695        NodeFltAttrs.GetDat(NId).GetDat(ColAttr).Add(FltCols[ColId][RowId]);
2696      } else {
2697        if (!NodeStrAttrs.IsKey(NId)) { NodeStrAttrs.AddKey(NId); }
2698        if (!NodeStrAttrs.GetDat(NId).IsKey(ColAttr)) { NodeStrAttrs.GetDat(NId).AddKey(ColAttr); }
2699        NodeStrAttrs.GetDat(NId).GetDat(ColAttr).Add(GetStrValIdx(ColId, RowId));
2700      }
2701    }
2702  }
2703  PNEANet TTable::BuildGraph(const TIntV& RowIds, TAttrAggr AggrPolicy) {
2704    PNEANet Graph = TNEANet::New();
2705    const TAttrType NodeType = GetColType(SrcCol);
2706    Assert(NodeType == GetColType(DstCol));
2707    const TInt SrcColIdx = GetColIdx(SrcCol);
2708    const TInt DstColIdx = GetColIdx(DstCol);
2709    THash<TFlt, TInt> FltNodeVals;
2710    THash<TInt, TStrIntVH> NodeIntAttrs;
2711    THash<TInt, TStrFltVH> NodeFltAttrs;
2712    THash<TInt, TStrStrVH> NodeStrAttrs;
2713    for (TVec<TInt>::TIter it = RowIds.BegI(); it < RowIds.EndI(); it++) {
2714      TInt CurrRowIdx = *it;
2715      TInt SVal, DVal;
2716      if (NodeType == atFlt) {
2717        TFlt FSVal = FltCols[SrcColIdx][CurrRowIdx];
2718        SVal = CheckAndAddFltNode(Graph, FltNodeVals, FSVal);
2719        TFlt FDVal = FltCols[SrcColIdx][CurrRowIdx];
2720        DVal = CheckAndAddFltNode(Graph, FltNodeVals, FDVal);
2721      } else if (NodeType == atInt || NodeType == atStr) {
2722        if (NodeType == atInt) {
2723          SVal = IntCols[SrcColIdx][CurrRowIdx];
2724          DVal = IntCols[DstColIdx][CurrRowIdx];
2725        } else {
2726          SVal = StrColMaps[SrcColIdx][CurrRowIdx];
2727          if (strlen(Context->StringVals.GetKey(SVal)) == 0) { continue; }  
2728          DVal = StrColMaps[DstColIdx][CurrRowIdx];
2729          if (strlen(Context->StringVals.GetKey(DVal)) == 0) { continue; }  
2730        }
2731        if (!Graph->IsNode(SVal)) { Graph->AddNode(SVal); }
2732        if (!Graph->IsNode(DVal)) { Graph->AddNode(DVal); }
2733      } 
2734      Graph->AddEdge(SVal, DVal, CurrRowIdx);
2735      if (EdgeAttrV.Len() > 0) { AddEdgeAttributes(Graph, CurrRowIdx); }
2736      if (SrcNodeAttrV.Len() > 0) { 
2737        AddNodeAttributes(SVal, SrcNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2738      }
2739      if (DstNodeAttrV.Len() > 0) {
2740        AddNodeAttributes(DVal, DstNodeAttrV, CurrRowIdx, NodeIntAttrs, NodeFltAttrs, NodeStrAttrs);
2741      }
2742    }
2743    if (SrcNodeAttrV.Len() > 0 || DstNodeAttrV.Len() > 0) {
2744      for (TNEANet::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
2745        TInt NId = NodeI.GetId();
2746        if (NodeIntAttrs.IsKey(NId)) {
2747          TStrIntVH IntAttrVals = NodeIntAttrs.GetDat(NId);
2748          for (TStrIntVH::TIter it = IntAttrVals.BegI(); it < IntAttrVals.EndI(); it++) {
2749            TInt AttrVal = AggregateVector<TInt>(it.GetDat(), AggrPolicy);
2750            Graph->AddIntAttrDatN(NId, AttrVal, it.GetKey());
2751          }
2752        }
2753        if (NodeFltAttrs.IsKey(NId)) {
2754          TStrFltVH FltAttrVals = NodeFltAttrs.GetDat(NId);
2755          for (TStrFltVH::TIter it = FltAttrVals.BegI(); it < FltAttrVals.EndI(); it++) {
2756            TFlt AttrVal = AggregateVector<TFlt>(it.GetDat(), AggrPolicy);
2757            Graph->AddFltAttrDatN(NId, AttrVal, it.GetKey());
2758          }
2759        }
2760        if (NodeStrAttrs.IsKey(NId)) {
2761          TStrStrVH StrAttrVals = NodeStrAttrs.GetDat(NId);
2762          for (TStrStrVH::TIter it = StrAttrVals.BegI(); it < StrAttrVals.EndI(); it++) {
2763            TStr AttrVal = AggregateVector<TStr>(it.GetDat(), AggrPolicy);
2764            Graph->AddStrAttrDatN(NId, AttrVal, it.GetKey());
2765          }
2766        }
2767      }
2768    }
2769    return Graph;
2770  }
2771  void TTable::InitRowIdBuckets(int NumBuckets) {
2772    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2773      RowIdBuckets[i].Clr();
2774    }
2775    RowIdBuckets.Clr();
2776    RowIdBuckets.Gen(NumBuckets);
2777    for (TInt i = 0; i < NumBuckets; i++) {
2778      RowIdBuckets[i].Gen(10, 0);
2779    }
2780  }
2781  void TTable::FillBucketsByWindow(TStr SplitAttr, TInt JumpSize, TInt WindowSize, TInt StartVal, TInt EndVal) {
2782    Assert (JumpSize <= WindowSize);
2783    int NumBuckets, MinBucket, MaxBucket;
2784    TInt SplitColId = GetColIdx(SplitAttr);
2785    if (StartVal == TInt::Mn || EndVal == TInt::Mx) {
2786      TInt MinValue = TInt::Mx;
2787      TInt MaxValue = TInt::Mn;
2788      for (TInt i = 0; i < Next.Len(); i++) {
2789        if (Next[i] != Invalid) { 
2790          if (MinValue > IntCols[SplitColId][i]) {
2791            MinValue = IntCols[SplitColId][i];
2792          }
2793          if (MaxValue < IntCols[SplitColId][i]) {
2794            MaxValue = IntCols[SplitColId][i];
2795          }
2796        }
2797      }
2798      if (StartVal == TInt::Mn) StartVal = MinValue;
2799      if (EndVal == TInt::Mx) EndVal = MaxValue;
2800    }
2801    NumBuckets = 1;
2802    if (JumpSize > 0) {
2803      NumBuckets = (EndVal - StartVal)/JumpSize + 1;
2804    }
2805    InitRowIdBuckets(NumBuckets);
2806    for (TInt i = 0; i < Next.Len(); i++) {
2807      if (Next[i] == Invalid) { continue; }
2808      int SplitVal = IntCols[SplitColId][i];
2809      if (SplitVal < StartVal || SplitVal > EndVal) { continue; }
2810      int RowVal = SplitVal - StartVal;
2811      if (JumpSize == 0) { 
2812        MinBucket = RowVal/WindowSize;
2813        MaxBucket = NumBuckets-1;
2814      } else if (JumpSize == WindowSize) { 
2815        MinBucket = MaxBucket = RowVal/JumpSize;  
2816      } else { 
2817        if (RowVal < WindowSize) { MinBucket = 0; }
2818        else { MinBucket = (RowVal-WindowSize)/JumpSize + 1; }
2819        MaxBucket = RowVal/JumpSize;  
2820      }
2821      for (TInt j = MinBucket; j <= MaxBucket; j++) { RowIdBuckets[j].Add(i); }
2822    }
2823  }
2824  void TTable::FillBucketsByInterval(TStr SplitAttr, TIntPrV SplitIntervals) {
2825    TInt SplitColId = GetColIdx(SplitAttr);
2826    int NumBuckets = SplitIntervals.Len();
2827    InitRowIdBuckets(NumBuckets);
2828    for (TInt i = 0; i < Next.Len(); i++) {
2829      if (Next[i] == Invalid) { continue; }
2830      int SplitVal = IntCols[SplitColId][i];
2831      for (TInt j = 0; j < SplitIntervals.Len(); j++) { 
2832        if (SplitVal >= SplitIntervals[j].Val1 && SplitVal < SplitIntervals[j].Val2) {
2833          RowIdBuckets[j].Add(i);
2834        }
2835      }
2836    }
2837  }
2838  TVec<PNEANet> TTable::GetGraphsFromSequence(TAttrAggr AggrPolicy) {
2839    TVec<PNEANet> GraphSequence;
2840    for (TInt i = 0; i < RowIdBuckets.Len(); i++) {
2841      if (RowIdBuckets[i].Len() == 0) { continue; }
2842      PNEANet PNet = BuildGraph(RowIdBuckets[i], AggrPolicy);
2843      GraphSequence.Add(PNet);
2844    }
2845    return GraphSequence;
2846  }
2847  PNEANet TTable::GetFirstGraphFromSequence(TAttrAggr AggrPolicy) {
2848    CurrBucket = -1;
2849    this->AggrPolicy = AggrPolicy;
2850    return GetNextGraphFromSequence();
2851  }
2852  PNEANet TTable::GetNextGraphFromSequence() {
2853    CurrBucket++;
2854    while (CurrBucket < RowIdBuckets.Len() && RowIdBuckets[CurrBucket].Len() == 0) {
2855      CurrBucket++;
2856    }
2857    if (CurrBucket >= RowIdBuckets.Len()) { return NULL; }
2858    return BuildGraph(RowIdBuckets[CurrBucket], AggrPolicy);
2859  }
2860  TVec<PNEANet> TTable::ToGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2861    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2862    printf("buckets filled\n");
2863    return GetGraphsFromSequence(AggrPolicy);  
2864  }
2865  TVec<PNEANet> TTable::ToVarGraphSequence(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2866    FillBucketsByInterval(SplitAttr, SplitIntervals);
2867    return GetGraphsFromSequence(AggrPolicy);
2868  }
2869  TVec<PNEANet> TTable::ToGraphPerGroup(TStr GroupAttr, TAttrAggr AggrPolicy) {
2870    return ToGraphSequence(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2871  }
2872  PNEANet TTable::ToGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TInt WindowSize, TInt JumpSize, TInt StartVal, TInt EndVal) {
2873    FillBucketsByWindow(SplitAttr, JumpSize, WindowSize, StartVal, EndVal);
2874    return GetFirstGraphFromSequence(AggrPolicy);  
2875  }
2876  PNEANet TTable::ToVarGraphSequenceIterator(TStr SplitAttr, TAttrAggr AggrPolicy, TIntPrV SplitIntervals) {
2877    FillBucketsByInterval(SplitAttr, SplitIntervals);
2878    return GetFirstGraphFromSequence(AggrPolicy);
2879  }
2880  PNEANet TTable::ToGraphPerGroupIterator(TStr GroupAttr, TAttrAggr AggrPolicy) {
2881    return ToGraphSequenceIterator(GroupAttr, AggrPolicy, TInt(1), TInt(1), TInt::Mn, TInt::Mx);
2882  }
2883  PNEANet TTable::NextGraphIterator() {
2884    return GetNextGraphFromSequence();
2885  }
2886  TBool TTable::IsLastGraphOfSequence() {
2887    return CurrBucket >= RowIdBuckets.Len() - 1;
2888  }
2889  PTable TTable::GetNodeTable(const PNEANet& Network, TTableContext* Context) {
2890    Schema SR;
2891    SR.Add(TPair<TStr,TAttrType>("node_id",atInt));
2892    TStrV IntAttrNames;
2893    TStrV FltAttrNames;
2894    TStrV StrAttrNames;
2895    TNEANet::TNodeI NodeI = Network->BegNI();
2896    NodeI.GetIntAttrNames(IntAttrNames);
2897    NodeI.GetFltAttrNames(FltAttrNames);
2898    NodeI.GetStrAttrNames(StrAttrNames);
2899    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2900      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2901    }
2902    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2903      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2904    }
2905    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2906      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2907    }
2908    PTable T = New(SR, Context);
2909    TInt Cnt = 0;
2910    while (NodeI < Network->EndNI()) {
2911      T->IntCols[0].Add(NodeI.GetId());
2912      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2913        T->IntCols[i+1].Add(Network->GetIntAttrDatN(NodeI,IntAttrNames[i]));
2914      }
2915      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2916        T->FltCols[i].Add(Network->GetFltAttrDatN(NodeI,FltAttrNames[i]));
2917      }
2918      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2919        T->AddStrVal(i, Network->GetStrAttrDatN(NodeI,StrAttrNames[i]));
2920      }
2921      Cnt++;
2922      NodeI++;
2923    }
2924    T->NumRows = Cnt;
2925    T->NumValidRows = T->NumRows;
2926    T->Next = TIntV(T->NumRows,0);
2927    for (TInt i = 0; i < T->NumRows-1; i++) {
2928      T->Next.Add(i+1);
2929    }
2930    T->LastValidRow = T->NumRows-1;
2931    T->Next.Add(Last);
2932    return T;
2933  }
2934  PTable TTable::GetEdgeTable(const PNEANet& Network, TTableContext* Context) {
2935    Schema SR;
2936    SR.Add(TPair<TStr,TAttrType>("edg_id",atInt));
2937    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2938    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2939    TStrV IntAttrNames;
2940    TStrV FltAttrNames;
2941    TStrV StrAttrNames;
2942    TNEANet::TEdgeI EdgeI = Network->BegEI();
2943    EdgeI.GetIntAttrNames(IntAttrNames);
2944    EdgeI.GetFltAttrNames(FltAttrNames);
2945    EdgeI.GetStrAttrNames(StrAttrNames);
2946    for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2947      SR.Add(TPair<TStr,TAttrType>(IntAttrNames[i],atInt));
2948    }
2949    for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2950      SR.Add(TPair<TStr,TAttrType>(FltAttrNames[i],atFlt));
2951    }
2952    for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2953      SR.Add(TPair<TStr,TAttrType>(StrAttrNames[i],atStr));
2954    }
2955    PTable T = New(SR, Context);
2956    TInt Cnt = 0;
2957    while (EdgeI < Network->EndEI()) {
2958      T->IntCols[0].Add(EdgeI.GetId());
2959      T->IntCols[1].Add(EdgeI.GetSrcNId());
2960      T->IntCols[2].Add(EdgeI.GetDstNId());
2961      for (TInt i = 0; i < IntAttrNames.Len(); i++) {
2962        T->IntCols[i+3].Add(Network->GetIntAttrDatE(EdgeI,IntAttrNames[i]));
2963      }
2964      for (TInt i = 0; i < FltAttrNames.Len(); i++) {
2965        T->FltCols[i].Add(Network->GetFltAttrDatE(EdgeI,FltAttrNames[i]));
2966      }
2967      for (TInt i = 0; i < StrAttrNames.Len(); i++) {
2968        T->AddStrVal(i, Network->GetStrAttrDatE(EdgeI,StrAttrNames[i]));
2969      }
2970      Cnt++;
2971      EdgeI++;
2972    }
2973    T->NumRows = Cnt;
2974    T->NumValidRows = T->NumRows;
2975    T->Next = TIntV(T->NumRows,0);
2976    for (TInt i = 0; i < T->NumRows-1; i++) {
2977      T->Next.Add(i+1);
2978    }
2979    T->LastValidRow = T->NumRows-1;
2980    T->Next.Add(Last);
2981    return T;
2982  }
2983  #ifdef GCC_ATOMIC
2984  PTable TTable::GetEdgeTablePN(const PNGraphMP& Network, TTableContext* Context){
2985    Schema SR;
2986    SR.Add(TPair<TStr,TAttrType>("src_id",atInt));
2987    SR.Add(TPair<TStr,TAttrType>("dst_id",atInt));
2988    TNGraphMP::TEdgeI FirstEI = Network->BegEI();
2989    PTable T = New(SR, Context);
2990    TInt NumEdges = Network->GetEdges();
2991    TInt NumPartitions = omp_get_max_threads()*CHUNKS_PER_THREAD;
2992    TInt PartitionSize = NumEdges/NumPartitions;
2993    if (PartitionSize*NumPartitions < NumEdges) { NumPartitions++;}
2994    typedef TPair<TNGraphMP::TEdgeI, TNGraphMP::TEdgeI> TEIPr;
2995    TVec<TEIPr> Partitions;
2996    TIntV PartitionSizes;
2997    TNGraphMP::TEdgeI currStart = FirstEI;
2998    TInt currCount = 0;
2999    while (FirstEI < Network->EndEI()){
3000      if (currCount == PartitionSize) {
3001        Partitions.Add(TEIPr(currStart, FirstEI));
3002        currStart = FirstEI;
3003        PartitionSizes.Add(currCount);
3004        currCount = 0;
3005      }
3006      FirstEI++;
3007      currCount++;
3008    }
3009    Partitions.Add(TEIPr(currStart, FirstEI));
3010    PartitionSizes.Add(currCount);
3011    T->ResizeTable(NumEdges);
3012    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3013    for (int p = 0; p < Partitions.Len(); p++) {
3014      TNGraphMP::TEdgeI EdgeI = Partitions[p].GetVal1();
3015      TNGraphMP::TEdgeI EndI = Partitions[p].GetVal2();
3016      int start = T->GetEmptyRowsStart(PartitionSizes[p]);
3017      while (EdgeI < EndI) {
3018        T->IntCols[0][start] = EdgeI.GetSrcNId();
3019        T->IntCols[1][start] = EdgeI.GetDstNId();
3020        EdgeI++;
3021        if (EdgeI < EndI) { T->Next[start] = start+1;}
3022        start++;
3023      }
3024    }
3025    Assert(T->NumRows == NumEdges);
3026    return T;
3027  }
3028  #endif 
3029  PTable TTable::GetFltNodePropertyTable(const PNEANet& Network, const TIntFltH& Property, 
3030   const TStr& NodeAttrName, const TAttrType& NodeAttrType, const TStr& PropertyAttrName, 
3031   TTableContext* Context) {
3032    Schema SR;
3033    SR.Add(TPair<TStr,TAttrType>(NodeAttrName,NodeAttrType));
3034    SR.Add(TPair<TStr,TAttrType>(PropertyAttrName,atFlt));
3035    PTable T = New(SR, Context);
3036    TInt NodeColIdx = T->GetColIdx(NodeAttrName);
3037    TInt Cnt = 0;
3038    for (TNEANet::TNodeI NodeI = Network->BegNI(); NodeI < Network->EndNI(); NodeI++) {
3039      switch (NodeAttrType) {
3040        case atInt:
3041          T->IntCols[NodeColIdx].Add(Network->GetIntAttrDatN(NodeI,NodeAttrName));
3042          break;
3043        case atFlt:
3044          T->FltCols[NodeColIdx].Add(Network->GetFltAttrDatN(NodeI,NodeAttrName));
3045          break;
3046        case atStr:
3047          T->AddStrVal(TInt(0), Network->GetStrAttrDatN(NodeI,NodeAttrName));
3048          break;
3049      }
3050      T->FltCols[0].Add(Property.GetDat(NodeI.GetId()));
3051      Cnt++;
3052    }
3053    T->NumRows = Cnt;
3054    T->NumValidRows = T->NumRows;
3055    T->Next = TIntV(T->NumRows,0);
3056    for (TInt i = 0; i < T->NumRows-1; i++) {
3057      T->Next.Add(i+1);
3058    }
3059    T->LastValidRow = T->NumRows-1;
3060    T->Next.Add(Last);
3061    return T;
3062  }
3063  PTable TTable::IsNextK(const TStr& OrderCol, TInt K, const TStr& GroupBy, const TStr& RankColName) {
3064    TStrV OrderBy;
3065    if (GroupBy.Empty()) {
3066      OrderBy.Add(OrderCol);
3067    } else {
3068      OrderBy.Add(GroupBy);
3069      OrderBy.Add(OrderCol);
3070    }
3071    if (RankColName.Empty()) {
3072      Order(OrderBy);
3073    } else {
3074      Order(OrderBy, RankColName, true);
3075    }
3076    TAttrType GroupByAttrType = GetColType(GroupBy);
3077    PTable T = InitializeJointTable(*this);
3078    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3079      TInt Succ = RI.GetRowIdx();
3080      TBool OutOfGroup = false;
3081      for (TInt i = 0; i < K; i++) {
3082        Succ = Next[Succ];
3083        if (Succ == Last) { break; }
3084        switch (GroupByAttrType) {
3085          case atInt:
3086            if (GetIntVal(GroupBy, Succ) != RI.GetIntAttr(GroupBy)) { OutOfGroup = true; }
3087            break;
3088          case atFlt:
3089            if (GetFltVal(GroupBy, Succ) != RI.GetFltAttr(GroupBy)) { OutOfGroup = true; }
3090            break;
3091          case atStr:
3092            if (GetStrVal(GroupBy, Succ) != RI.GetStrAttr(GroupBy)) { OutOfGroup = true; }
3093            break;
3094        }
3095        if (OutOfGroup) { break; }  
3096        T->AddJointRow(*this, *this, RI.GetRowIdx(), Succ);
3097      }
3098    }
3099    return T;
3100  }
3101  void TTable::PrintSize(){
3102  	printf("Total number of rows: %d\n", NumRows.Val);
3103  	printf("Number of valid rows: %d\n", NumValidRows.Val);
3104  	printf("Number of Int columns: %d\n", IntCols.Len());
3105  	printf("Number of Flt columns: %d\n", FltCols.Len());
3106  	printf("Number of Str columns: %d\n", StrColMaps.Len());
3107  	TSize MemUsed = GetMemUsedKB();
3108  	printf("Approximate table size is %s KB\n", TUInt64::GetStr(MemUsed).CStr());
3109  }
3110  TSize TTable::GetMemUsedKB() {
3111    TSize ApproxSize = 0;
3112    ApproxSize += Next.GetMemUsed()/1000;  
3113    for(int i = 0; i < IntCols.Len(); i++){
3114    	ApproxSize += IntCols[i].GetMemUsed()/1000;
3115    }
3116    for(int i = 0; i < FltCols.Len(); i++){
3117    	ApproxSize += FltCols[i].GetMemUsed()/1000;
3118    }
3119    for(int i = 0; i < StrColMaps.Len(); i++){
3120    	ApproxSize += StrColMaps[i].GetMemUsed()/1000;
3121    }
3122    ApproxSize += RowIdMap.GetMemUsed()/1000;
3123    ApproxSize += GroupIDMapping.GetMemUsed()/1000;
3124    ApproxSize += GroupMapping.GetMemUsed()/1000;
3125    ApproxSize += RowIdBuckets.GetMemUsed() / 1000;
3126    return ApproxSize;
3127  }
3128  void TTable::PrintContextSize(){
3129  	printf("Number of strings in pool: ");
3130  	printf("%d\n", Context->StringVals.Len());
3131  	printf("Number of entries in hash table: ");
3132  	printf("%d\n", Context->StringVals.Reserved());
3133  	TSize MemUsed = GetContextMemUsedKB();
3134  	printf("Approximate context size is %s KB\n",
3135            TUInt64::GetStr(MemUsed).CStr());
3136  }
3137  TSize TTable::GetContextMemUsedKB(){
3138  	TSize ApproxSize = 0;
3139  	ApproxSize += Context->StringVals.GetMemUsed();
3140  	return ApproxSize;
3141  }
3142  void TTable::AddTable(const TTable& T) {
3143    for (TInt c = 0; c < Sch.Len(); c++) {
3144      TStr ColName = GetSchemaColName(c);
3145      TInt ColIdx = GetColIdx(ColName);
3146      TInt TColIdx = ColName == IdColName ? T.GetColIdx(T.IdColName) : T.GetColIdx(ColName);
3147      if (TColIdx < 0) { TExcept::Throw("when adding a table, it must contain all columns of source table!"); }
3148      switch (GetColType(ColName)) { 
3149      case atInt:
3150         IntCols[ColIdx].AddV(T.IntCols[TColIdx]);
3151         break;
3152      case atFlt:
3153         FltCols[ColIdx].AddV(T.FltCols[TColIdx]);
3154         break;
3155      case atStr:
3156         StrColMaps[ColIdx].AddV(T.StrColMaps[TColIdx]);
3157         break;
3158      }
3159    }
3160    TIntV TNext(T.Next);
3161    for (TInt i = 0; i < TNext.Len(); i++) {
3162      if (TNext[i] != Last && TNext[i] != Invalid) { TNext[i] += NumRows; }
3163    }
3164    Next.AddV(TNext);
3165    if (LastValidRow >= 0) {
3166      Next[LastValidRow] = NumRows + T.FirstValidRow;
3167    }
3168    LastValidRow = NumRows + T.LastValidRow;
3169    NumRows += T.NumRows;
3170    NumValidRows += T.NumValidRows;
3171  }
3172  void TTable::GetCollidingRows(const TTable& Table, THashSet<TInt>& Collisions) {
3173    TIntV UniqueVec;
3174    THash<TGroupKey, TPair<TInt, TIntV> >Grouping;
3175    TStrV GroupBy;
3176    TIntV IntGroupByCols;
3177    TIntV FltGroupByCols;
3178    TIntV StrGroupByCols;
3179    TInt IKLen, FKLen, SKLen;
3180    for (TInt c = 0; c < Sch.Len(); c++) {
3181      if (Sch[c].Val1 == IdColName) {
3182        if (Table.Sch[c].Val1 != Table.GetIdColName()) {
3183          TExcept::Throw("GetCollidingRows: schemas do not match!");
3184        }
3185        continue;
3186      }
3187      if (Sch[c] != Table.Sch[c]) {
3188        printf("(%s,%d) != (%s,%d)\n", Sch[c].Val1.CStr(), Sch[c].Val2, Table.Sch[c].Val1.CStr(), Table.Sch[c].Val2); 
3189        TExcept::Throw("GetCollidingRows: schemas do not match!");
3190      }
3191      GroupBy.Add(NormalizeColName(Sch[c].Val1));
3192      TPair<TAttrType, TInt> ColType = Table.GetColTypeMap(Sch[c].Val1);
3193      switch (ColType.Val1) {
3194        case atInt:
3195          IntGroupByCols.Add(ColType.Val2);
3196          break;
3197        case atFlt:
3198          FltGroupByCols.Add(ColType.Val2);
3199          break;
3200        case atStr:
3201          StrGroupByCols.Add(ColType.Val2);
3202          break;
3203      }
3204    }
3205    IKLen = IntGroupByCols.Len();
3206    FKLen = FltGroupByCols.Len();
3207    SKLen = StrGroupByCols.Len();
3208    GroupAux(GroupBy, Grouping, true, "", false, UniqueVec, true);
3209    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3210      TIntV IKey(IKLen + SKLen, 0);
3211      TFltV FKey(FKLen, 0);
3212      for (TInt c = 0; c < IKLen; c++) {
3213        IKey.Add(it.GetIntAttr(IntGroupByCols[c])); 
3214      }
3215      for (TInt c = 0; c < FKLen; c++) {
3216        FKey.Add(it.GetFltAttr(FltGroupByCols[c])); 
3217      }
3218      for (TInt c = 0; c < SKLen; c++) {
3219        IKey.Add(it.GetStrMapById(StrGroupByCols[c])); 
3220      }
3221      TGroupKey GroupKey = TGroupKey(IKey, FKey);
3222      TInt RowIdx = it.GetRowIdx();
3223      if (Grouping.IsKey(GroupKey)) {
3224        Collisions.AddKey(RowIdx);
3225      }
3226    }
3227  }
3228  void TTable::StoreIntCol(const TStr& ColName, const TIntV& ColVals) {
3229    if (ColVals.Len() != NumRows) {
3230      printf("new column dimension must agree with number of rows\n");
3231      return;
3232    }
3233    AddSchemaCol(ColName, atInt);
3234    IntCols.Add(TIntV(NumRows));
3235    TInt ColIdx = IntCols.Len()-1;
3236    TInt i = 0;
3237    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3238      IntCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3239      i++;
3240    }
3241    TInt L = IntCols.Len();
3242    AddColType(ColName, atInt, L-1);
3243  }
3244  void TTable::StoreFltCol(const TStr& ColName, const TFltV& ColVals) {
3245    if (ColVals.Len() != NumRows) {
3246      printf("new column dimension must agree with number of rows\n");
3247      return;
3248    }
3249    AddSchemaCol(ColName, atFlt);
3250    FltCols.Add(TFltV(NumRows));
3251    TInt ColIdx = FltCols.Len()-1;
3252    TInt i = 0;
3253    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3254      FltCols[ColIdx][RI.GetRowIdx()] = ColVals[i];
3255      i++;
3256    }
3257    TInt L = FltCols.Len();
3258    AddColType(ColName, atFlt, L-1);
3259  }
3260  void TTable::StoreStrCol(const TStr& ColName, const TStrV& ColVals) {
3261    if (ColVals.Len() != NumRows) {
3262      printf("new column dimension must agree with number of rows\n");
3263      return;
3264    }
3265    AddSchemaCol(ColName, atStr);
3266    StrColMaps.Add(TIntV(NumRows,0));
3267    TInt ColIdx = FltCols.Len()-1;
3268    TInt i = 0;
3269    for (TRowIterator RI = BegRI(); RI < EndRI(); RI++) {
3270      TInt Key = Context->StringVals.GetKeyId(ColVals[i]);
3271      if (Key == -1) { Context->StringVals.AddKey(ColVals[i]); }
3272      StrColMaps[ColIdx][RI.GetRowIdx()] = Key;
3273      i++;
3274    }
3275    TInt L = StrColMaps.Len();
3276    AddColType(ColName, atStr, L-1);
3277  }
3278  void TTable::UpdateTableForNewRow() {
3279    if (LastValidRow >= 0) {
3280      Next[LastValidRow] = NumRows;
3281    }
3282    Next.Add(Last);
3283    LastValidRow = NumRows;
3284    NumRows++;
3285    NumValidRows++;
3286  }
3287  #ifdef GCC_ATOMIC
3288  void TTable::SetFltColToConstMP(TInt UpdateColIdx, TFlt DefaultFltVal){
3289      if(!GetMP()){ TExcept::Throw("Not Using MP!");}
3290  	TIntPrV Partitions;
3291  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3292  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3293  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3294  	for (int i = 0; i < Partitions.Len(); i++){
3295  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3296  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3297  		while(RowI < EndI){
3298  			FltCols[UpdateColIdx][RowI.GetRowIdx()] = DefaultFltVal;
3299  			RowI++;
3300  		}
3301  	}
3302  }
3303  int sync_bool_compare_and_swap(int *lock) {
3304    return(__sync_bool_compare_and_swap(lock, 0, 1));
3305  }
3306  void TTable::UpdateFltFromTableMP(const TStr& KeyAttr, const TStr& UpdateAttr,
3307      const TTable& Table, const TStr& FKeyAttr, const TStr& ReadAttr,
3308      TFlt DefaultFltVal) {
3309  	if (!GetMP()) {
3310      TExcept::Throw("Not Using MP!");
3311    }
3312    TAttrType KeyType = GetColType(KeyAttr);
3313    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3314    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3315    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3316      TExcept::Throw("Expecting Float values");
3317    }
3318    TStr NKeyAttr = NormalizeColName(KeyAttr);
3319    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3320    TInt FKeyColIdx = GetColIdx(FKeyAttr);
3321    TInt ReadColIdx = GetColIdx(ReadAttr);
3322    SetFltColToConstMP(UpdateColIdx, DefaultFltVal);
3323  	TIntPrV Partitions;
3324  	Table.GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3325  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3326  	TIntV Locks(NumRows);
3327  	Locks.PutAll(0);	
3328    switch (KeyType) {
3329      case atInt: {
3330          THashMP<TInt,TIntV> Grouping;
3331          GroupByIntColMP(NKeyAttr, Grouping, true);
3332          #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3333  			  for (int i = 0; i < Partitions.Len(); i++) {
3334  				  TRowIterator RowI(Partitions[i].GetVal1(), &Table);
3335  				  TRowIterator EndI(Partitions[i].GetVal2(), &Table);
3336  				  while (RowI < EndI) {
3337              TInt K = RowI.GetIntAttr(FKeyColIdx);
3338              if (Grouping.IsKey(K)) {
3339                TIntV& UpdateRows = Grouping.GetDat(K);
3340                for (int j = 0; j < UpdateRows.Len(); j++) {
3341                  int* lock = &Locks[UpdateRows[j]].Val;
3342                  if (!sync_bool_compare_and_swap(lock)) {
3343                    continue;
3344                  }
3345    							  FltCols[UpdateColIdx][UpdateRows[j]] = RowI.GetFltAttr(ReadColIdx);
3346                } 
3347              } 
3348              RowI++;
3349            } 
3350          }	
3351        } 
3352        break;
3353      default:
3354        break;
3355    } 
3356  }
3357  #endif	
3358  void TTable::UpdateFltFromTable(const TStr& KeyAttr, const TStr& UpdateAttr, const TTable& Table, 
3359    const TStr& FKeyAttr, const TStr& ReadAttr, TFlt DefaultFltVal){
3360    if(!IsColName(KeyAttr)){ TExcept::Throw("Bad KeyAttr parameter");}
3361    if(!IsColName(UpdateAttr)){ TExcept::Throw("Bad UpdateAttr parameter");}
3362    if(!Table.IsColName(FKeyAttr)){ TExcept::Throw("Bad FKeyAttr parameter");}
3363    if(!Table.IsColName(ReadAttr)){ TExcept::Throw("Bad ReadAttr parameter");}
3364  #ifdef GCC_ATOMIC
3365    if(GetMP()){
3366      UpdateFltFromTableMP(KeyAttr, UpdateAttr,Table, FKeyAttr, ReadAttr, DefaultFltVal);
3367      return;
3368    }
3369  #endif	
3370    TAttrType KeyType = GetColType(KeyAttr);
3371    TAttrType FKeyType = Table.GetColType(FKeyAttr);
3372    if(KeyType != FKeyType){TExcept::Throw("Key Type Mismatch");}
3373    if(GetColType(UpdateAttr) != atFlt || Table.GetColType(ReadAttr) != atFlt){
3374      TExcept::Throw("Expecting Float values");
3375    }
3376    TStr NKeyAttr = NormalizeColName(KeyAttr);
3377    TStr NUpdateAttr = NormalizeColName(UpdateAttr);
3378    TStr NFKeyAttr = Table.NormalizeColName(FKeyAttr);
3379    TStr NReadAttr = Table.NormalizeColName(ReadAttr);
3380    TInt UpdateColIdx = GetColIdx(UpdateAttr);
3381    for(TRowIterator iter = BegRI(); iter < EndRI(); iter++){
3382      FltCols[UpdateColIdx][iter.GetRowIdx()] = DefaultFltVal;
3383    }
3384    switch(KeyType) {
3385      case atInt: {
3386          TIntIntVH Grouping;
3387          GroupByIntCol(NKeyAttr, Grouping, TIntV(), true, true);
3388          for (TRowIterator RI = Table.BegRI(); RI < Table.EndRI(); RI++) {
3389            TInt K = RI.GetIntAttr(NFKeyAttr);
3390            if (Grouping.IsKey(K)) {
3391              TIntV& UpdateRows = Grouping.GetDat(K);
3392              for (int i = 0; i < UpdateRows.Len(); i++) {
3393                FltCols[UpdateColIdx][UpdateRows[i]] = RI.GetFltAttr(NReadAttr);
3394              } 
3395            } 
3396          } 
3397        } 
3398        break;
3399      default:
3400        break;
3401    } 
3402  }
3403  void TTable::AddRowI(const TRowIterator& RI) {
3404    for (TInt c = 0; c < Sch.Len(); c++) {
3405      TStr ColName = GetSchemaColName(c);
3406      if (ColName == IdColName) { continue; }
3407      TInt ColIdx = GetColIdx(ColName);
3408      switch (GetColType(ColName)) {
3409      case atInt:
3410         IntCols[ColIdx].Add(RI.GetIntAttr(ColName));
3411         break;
3412      case atFlt:
3413         FltCols[ColIdx].Add(RI.GetFltAttr(ColName));
3414         break;
3415      case atStr:
3416         StrColMaps[ColIdx].Add(RI.GetStrMapByName(ColName));
3417         break;
3418      }
3419    }
3420    UpdateTableForNewRow();
3421  }
3422  void TTable::AddRowV(const TIntV& IntVals, const TFltV& FltVals, const TStrV& StrVals) {
3423    for (TInt c = 0; c < IntVals.Len(); c++) {
3424      IntCols[c].Add(IntVals[c]);
3425    }
3426    for (TInt c = 0; c < FltVals.Len(); c++) {
3427      FltCols[c].Add(FltVals[c]);
3428    }
3429    for (TInt c = 0; c < StrVals.Len(); c++) {
3430      AddStrVal(c, StrVals[c]);
3431    }
3432    UpdateTableForNewRow();
3433  }
3434  void TTable::ResizeTable(int RowCount) {
3435    if (RowCount == 0) {
3436      NumValidRows = 0;
3437      FirstValidRow = TTable::Invalid;
3438      LastValidRow = TTable::Invalid;
3439    }
3440    if (Next.Len() < RowCount) {
3441      TInt FltOffset = IntCols.Len();
3442      TInt StrOffset = FltOffset + FltCols.Len();
3443      TInt TotalCols = StrOffset + StrColMaps.Len();
3444  #ifdef USE_OPENMP
3445      #pragma omp parallel for schedule(static)
3446  #endif
3447      for (int i = 0; i < TotalCols+1; i++) {
3448        if (i < FltOffset) {
3449          IntCols[i].Reserve(RowCount, RowCount); 
3450        } else if (i < StrOffset) {
3451          FltCols[i-FltOffset].Reserve(RowCount, RowCount);
3452        } else if (i < TotalCols) {
3453          StrColMaps[i-StrOffset].Reserve(RowCount, RowCount);  
3454        } else {
3455          Next.Reserve(RowCount, RowCount);    
3456        }
3457      }
3458    } else if (Next.Len() > RowCount) {
3459      TInt FltOffset = IntCols.Len();
3460      TInt StrOffset = FltOffset + FltCols.Len();
3461      TInt TotalCols = StrOffset + StrColMaps.Len();
3462  #ifdef USE_OPENMP
3463      #pragma omp parallel for schedule(static)
3464  #endif
3465      for (int i = 0; i < TotalCols+1; i++) {
3466        if (i < FltOffset) {
3467          IntCols[i].Trunc(RowCount); 
3468        } else if (i < StrOffset) {
3469          FltCols[i-FltOffset].Trunc(RowCount); 
3470        } else if (i < TotalCols) {
3471          StrColMaps[i-StrOffset].Trunc(RowCount); 
3472        } else {
3473          Next.Trunc(RowCount); 
3474        }
3475      }
3476    }
3477  }
3478  int TTable::GetEmptyRowsStart(int NewRows) {
3479    int start = -1;
3480  #ifdef USE_OPENMP
3481    #pragma omp critical
3482    {
3483  #endif
3484      start = NumRows;
3485      NumRows += NewRows;
3486      NumValidRows += NewRows;
3487      Assert(NumRows <= Next.Len());
3488      if (LastValidRow >= 0) {Next[LastValidRow] = start;}
3489      LastValidRow = start+NewRows-1;
3490      Next[LastValidRow] = Last;
3491  #ifdef USE_OPENMP
3492    }
3493  #endif
3494    Assert (start >= 0);
3495    return start;
3496  }
3497  void TTable::AddSelectedRows(const TTable& Table, const TIntV& RowIDs) {
3498    int NewRows = RowIDs.Len();
3499    if (NewRows == 0) { return; }
3500    int start = GetEmptyRowsStart(NewRows);
3501    for (TInt r = 0; r < NewRows; r++) {
3502      TInt CurrRowIdx = RowIDs[r];
3503      for (TInt i = 0; i < Table.IntCols.Len(); i++) {
3504        IntCols[i][start+r] = Table.IntCols[i][CurrRowIdx];
3505      }
3506      for (TInt i = 0; i < Table.FltCols.Len(); i++) {
3507        FltCols[i][start+r] = Table.FltCols[i][CurrRowIdx];
3508      }
3509      for (TInt i = 0; i < Table.StrColMaps.Len(); i++) {
3510        StrColMaps[i][start+r] = Table.StrColMaps[i][CurrRowIdx];
3511      }
3512    }
3513    for (TInt r = 0; r < NewRows-1; r++) {
3514      Next[start+r] = start+r+1;
3515    }
3516  }  
3517  void TTable::AddNRows(int NewRows, const TVec<TIntV>& IntColsP, const TVec<TFltV>& FltColsP, const TVec<TIntV>& StrColMapsP) {
3518    if (NewRows == 0) { return; }
3519    int start = GetEmptyRowsStart(NewRows);
3520    for (TInt r = 0; r < NewRows; r++) {
3521      for (TInt i = 0; i < IntColsP.Len(); i++) {
3522        IntCols[i][start+r] = IntColsP[i][r];
3523      }
3524      for (TInt i = 0; i < FltColsP.Len(); i++) {
3525        FltCols[i][start+r] = FltColsP[i][r];
3526      }
3527      for (TInt i = 0; i < StrColMapsP.Len(); i++) {
3528        StrColMaps[i][start+r] = StrColMapsP[i][r];
3529      }
3530    }
3531    for (TInt r = 0; r < NewRows-1; r++) {
3532      Next[start+r] = start+r+1;
3533    }
3534  }
3535  #ifdef USE_OPENMP
3536  void TTable::AddNJointRowsMP(const TTable& T1, const TTable& T2, const TVec<TIntPrV>& JointRowIDSet) {
3537    int JointTableSize = 0;
3538    TIntV StartOffsets(JointRowIDSet.Len());
3539    for (int i = 0; i < JointRowIDSet.Len(); i++) {
3540      StartOffsets[i] = JointTableSize;
3541      JointTableSize += JointRowIDSet[i].Len();
3542    }
3543    if (JointTableSize == 0) {
3544      TExcept::Throw("Joint table is empty");
3545    }
3546    ResizeTable(JointTableSize);
3547    NumRows = JointTableSize;
3548    NumValidRows = JointTableSize;
3549    Assert(NumRows <= Next.Len());
3550    TInt IntOffset = T1.IntCols.Len();
3551    TInt FltOffset = T1.FltCols.Len();
3552    TInt StrOffset = T1.StrColMaps.Len();
3553    TInt IdOffset = IntOffset + T2.IntCols.Len();
3554    RowIdMap.Clr();
3555    for (TInt IdCnt = 0; IdCnt < JointTableSize; IdCnt++) {
3556      RowIdMap.AddDat(IdCnt, IdCnt);
3557    }
3558    #pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD) 
3559    for (int j = 0; j < JointRowIDSet.Len(); j++) {
3560      const TIntPrV& RowIDs = JointRowIDSet[j];
3561      int start = StartOffsets[j];
3562      int NewRows = RowIDs.Len();
3563      if (NewRows == 0) {continue;}
3564      for (TInt r = 0; r < NewRows; r++){
3565        TIntPr CurrRowIdPr = RowIDs[r]; 
3566        for(TInt i = 0; i < T1.IntCols.Len(); i++){
3567          IntCols[i][start+r] = T1.IntCols[i][CurrRowIdPr.GetVal1()];
3568        }
3569        for(TInt i = 0; i < T1.FltCols.Len(); i++){
3570          FltCols[i][start+r] = T1.FltCols[i][CurrRowIdPr.GetVal1()];
3571        }
3572        for(TInt i = 0; i < T1.StrColMaps.Len(); i++){
3573          StrColMaps[i][start+r] = T1.StrColMaps[i][CurrRowIdPr.GetVal1()];
3574        }
3575        for(TInt i = 0; i < T2.IntCols.Len(); i++){
3576          IntCols[i+IntOffset][start+r] = T2.IntCols[i][CurrRowIdPr.GetVal2()];
3577        }
3578        for(TInt i = 0; i < T2.FltCols.Len(); i++){
3579          FltCols[i+FltOffset][start+r] = T2.FltCols[i][CurrRowIdPr.GetVal2()];
3580        }
3581        for(TInt i = 0; i < T2.StrColMaps.Len(); i++){
3582          StrColMaps[i+StrOffset][start+r] = T2.StrColMaps[i][CurrRowIdPr.GetVal2()];
3583        }
3584        IntCols[IdOffset][start+r] = start+r;
3585      }
3586      for(TInt r = 0; r < NewRows; r++){
3587        Next[start+r] = start+r+1;
3588      }
3589    }      
3590    LastValidRow = JointTableSize-1;
3591    Next[LastValidRow] = Last;
3592  }
3593  #endif 
3594  PTable TTable::UnionAll(const TTable& Table) {
3595    Schema NewSchema;
3596    for (TInt c = 0; c < Sch.Len(); c++) {
3597      if (Sch[c].Val1 != GetIdColName()) {
3598        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3599      }
3600    }
3601    PTable result = TTable::New(NewSchema, Context);
3602    result->AddTable(*this);
3603    result->UnionAllInPlace(Table);
3604    return result;
3605  }
3606  void TTable::UnionAllInPlace(const TTable& Table) {
3607    AddTable(Table);
3608  }
3609  PTable TTable::Union(const TTable& Table) {
3610    Schema NewSchema;
3611    THashSet<TInt> Collisions;
3612    TStrV ColNames;
3613    for (TInt c = 0; c < Sch.Len(); c++) {
3614      if (Sch[c].Val1 != GetIdColName()) {
3615        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3616        ColNames.Add(Sch[c].Val1);
3617      }
3618    }
3619    PTable result = TTable::New(NewSchema, Context);
3620    GetCollidingRows(Table, Collisions); 
3621    result->AddTable(*this);
3622    result->Unique(ColNames);
3623    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3624      if (!Collisions.IsKey(it.GetRowIdx())) {
3625        result->AddRowI(it);
3626      }
3627    }
3628    result->InitIds();
3629    return result;
3630  }
3631  PTable TTable::Intersection(const TTable& Table) {
3632    Schema NewSchema;
3633    THashSet<TInt> Collisions;
3634    for (TInt c = 0; c < Sch.Len(); c++) {
3635      if (Sch[c].Val1 != GetIdColName()) {
3636        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3637      }
3638    }
3639    PTable result = TTable::New(NewSchema, Context);
3640    GetCollidingRows(Table, Collisions);
3641    for (TRowIterator it = Table.BegRI(); it < Table.EndRI(); it++) {
3642      if (Collisions.IsKey(it.GetRowIdx())) {
3643        result->AddRowI(it);
3644      }
3645    }
3646    result->InitIds();
3647    return result;
3648  }
3649  PTable TTable::Minus(TTable& Table) {
3650    Schema NewSchema;
3651    THashSet<TInt> Collisions;
3652    for (TInt c = 0; c < Sch.Len(); c++) {
3653      if (Sch[c].Val1 != GetIdColName()) {
3654        NewSchema.Add(TPair<TStr,TAttrType>(Sch[c].Val1, Sch[c].Val2));
3655      }
3656    }
3657    PTable result = TTable::New(NewSchema, Context);
3658    Table.GetCollidingRows(*this, Collisions);
3659    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
3660      if (!Collisions.IsKey(it.GetRowIdx())) {
3661        result->AddRowI(it);
3662      }
3663    }
3664    result->InitIds();
3665    return result;
3666  }
3667  PTable TTable::Project(const TStrV& ProjectCols) {
3668    Schema NewSchema;
3669    for (TInt c = 0; c < ProjectCols.Len(); c++) {
3670      if (!IsColName(ProjectCols[c])) { TExcept::Throw("no such column " + ProjectCols[c]); }
3671      NewSchema.Add(TPair<TStr,TAttrType>(ProjectCols[c], GetColType(ProjectCols[c])));
3672    }
3673    PTable result = TTable::New(NewSchema, Context);
3674    result->AddTable(*this);
3675    result->InitIds();
3676    return result;
3677  }
3678  TBool TTable::IsAttr(const TStr& Attr) {
3679    return IsColName(Attr);
3680  }
3681  TStr TTable::RenumberColName(const TStr& ColName) const {
3682    TStr NColName = ColName;
3683    if (NColName.GetCh(NColName.Len()-2) == '-') { 
3684      NColName = NColName.GetSubStr(0,NColName.Len()-3); 
3685    }
3686    TInt Conflicts = 0;
3687    for (TInt i = 0; i < Sch.Len(); i++) {
3688      if (NColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3689        Conflicts++;
3690      }
3691    }
3692    Conflicts++;
3693    NColName = NColName + "-" + Conflicts.GetStr();
3694    return NColName;
3695  }
3696  TStr TTable::DenormalizeColName(const TStr& ColName) const {
3697    TStr DColName = ColName;
3698    if (DColName.Len() == 0) { return DColName; }
3699    if (DColName.GetCh(0) == '_') { return DColName; }
3700    if (DColName.GetCh(DColName.Len()-2) == '-') { 
3701      DColName = DColName.GetSubStr(0,DColName.Len()-3); 
3702    }
3703    TInt Conflicts = 0;
3704    for (TInt i = 0; i < Sch.Len(); i++) {
3705      if (DColName == Sch[i].Val1.GetSubStr(0, Sch[i].Val1.Len()-3)) {
3706        Conflicts++;
3707      }
3708    }
3709    if (Conflicts > 1) { return ColName; } 
3710    else { return DColName; }
3711  }
3712  Schema TTable::DenormalizeSchema() const {
3713    Schema DSch;
3714    for (TInt i = 0; i < Sch.Len(); i++) {
3715      DSch.Add(TPair<TStr, TAttrType>(DenormalizeColName(Sch[i].Val1), Sch[i].Val2));
3716    }
3717    return DSch;
3718  }
3719  void TTable::AddIntCol(const TStr& ColName) {
3720    AddSchemaCol(ColName, atInt);
3721    IntCols.Add(TIntV(NumRows));
3722    TInt L = IntCols.Len();
3723    AddColType(ColName, atInt, L-1);
3724  }
3725  void TTable::AddFltCol(const TStr& ColName) {
3726    AddSchemaCol(ColName, atFlt);
3727    FltCols.Add(TFltV(NumRows));
3728    TInt L = FltCols.Len();
3729    AddColType(ColName, atFlt, L-1);
3730  }
3731  void TTable::AddStrCol(const TStr& ColName) {
3732    AddSchemaCol(ColName, atStr);
3733    StrColMaps.Add(TIntV(NumRows));
3734    TInt L = StrColMaps.Len();
3735    AddColType(ColName, atStr, L-1);
3736  }
3737  void TTable::ClassifyAux(const TIntV& SelectedRows, const TStr& LabelName, const TInt& PositiveLabel, const TInt& NegativeLabel) {
3738    AddSchemaCol(LabelName, atInt);
3739    TInt LabelColIdx = IntCols.Len();
3740    AddColType(LabelName, atInt, LabelColIdx);
3741    IntCols.Add(TIntV(NumRows));
3742    for (TInt i = 0; i < NumRows; i++) {
3743      IntCols[LabelColIdx][i] = NegativeLabel;
3744    }
3745    for (TInt i = 0; i < SelectedRows.Len(); i++) {
3746      IntCols[LabelColIdx][SelectedRows[i]] = PositiveLabel;
3747    }
3748  }
3749  #ifdef USE_OPENMP
3750  void TTable::ColGenericOpMP(TInt ArgColIdx1, TInt ArgColIdx2, TAttrType ArgType1, TAttrType ArgType2, TInt ResColIdx, TArithOp op){
3751  	TAttrType ResType = atFlt;
3752  	if(ArgType1 == atInt && ArgType2 == atInt){ ResType = atInt;}
3753  	TIntPrV Partitions;
3754  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
3755  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
3756  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
3757  	for (int i = 0; i < Partitions.Len(); i++){
3758  		TRowIterator RowI(Partitions[i].GetVal1(), this);
3759  		TRowIterator EndI(Partitions[i].GetVal2(), this);
3760  		while(RowI < EndI){
3761  			if(ResType == atInt){
3762  				TInt V1 = RowI.GetIntAttr(ArgColIdx1);
3763  				TInt V2 = RowI.GetIntAttr(ArgColIdx2);
3764  				if (op == aoAdd) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3765        			if (op == aoSub) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3766        			if (op == aoMul) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3767        			if (op == aoDiv) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3768        			if (op == aoMod) { IntCols[ResColIdx][RowI.GetRowIdx()] = V1 % V2; }
3769        			if (op == aoMin) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3770        			if (op == aoMax) { IntCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3771  			} else{
3772  			    TFlt V1 = (ArgType1 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx1) : RowI.GetFltAttr(ArgColIdx1);
3773  			    TFlt V2 = (ArgType2 == atInt) ? (TFlt)RowI.GetIntAttr(ArgColIdx2) : RowI.GetFltAttr(ArgColIdx2);
3774  				if (op == aoAdd) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 + V2; }
3775        			if (op == aoSub) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 - V2; }
3776        			if (op == aoMul) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 * V2; }
3777        			if (op == aoDiv) { FltCols[ResColIdx][RowI.GetRowIdx()] = V1 / V2; }
3778        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3779        			if (op == aoMin) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3780        			if (op == aoMax) { FltCols[ResColIdx][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3781  			}
3782  			RowI++;
3783  		}
3784  	}
3785  }
3786  #endif	
3787  void TTable::ColGenericOp(const TStr& Attr1, const TStr& Attr2, const TStr& ResAttr, TArithOp op) {
3788    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
3789    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
3790    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3791    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
3792    TAttrType Arg1Type = Info1.Val1;
3793    TAttrType Arg2Type = Info2.Val1;
3794    if (Arg1Type == atStr || Arg2Type == atStr) {
3795      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3796    }
3797    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3798    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3799    }
3800    TInt ColIdx1 = Info1.Val2;
3801    TInt ColIdx2 = Info2.Val2;
3802    TInt ColIdx3 = ColIdx1;
3803    if (ResAttr != "") {
3804        if (Arg1Type == atInt && Arg2Type == atInt) {
3805            AddIntCol(ResAttr);
3806        }
3807        else {
3808            AddFltCol(ResAttr);
3809        }
3810        ColIdx3 = GetColIdx(ResAttr);
3811    }
3812  #ifdef USE_OPENMP
3813    if(GetMP()){
3814    	ColGenericOpMP(ColIdx1, ColIdx2, Arg1Type, Arg2Type, ColIdx3, op);
3815    	return;
3816    }
3817  #endif	
3818    TAttrType ResType = atFlt;
3819    if(Arg1Type == atInt && Arg2Type == atInt){ printf("hooray!\n"); ResType = atInt;}
3820    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3821  		if(ResType == atInt){
3822  			TInt V1 = RowI.GetIntAttr(ColIdx1);
3823  			TInt V2 = RowI.GetIntAttr(ColIdx2);
3824  			if (op == aoAdd) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3825        		if (op == aoSub) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3826        		if (op == aoMul) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3827        		if (op == aoDiv) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3828        		if (op == aoMod) { IntCols[ColIdx3][RowI.GetRowIdx()] = V1 % V2; }
3829        		if (op == aoMin) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3830        		if (op == aoMax) { IntCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3831  		} else{
3832  			TFlt V1 = (Arg1Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx1) : RowI.GetFltAttr(ColIdx1);
3833  			TFlt V2 = (Arg2Type == atInt) ? (TFlt)RowI.GetIntAttr(ColIdx2) : RowI.GetFltAttr(ColIdx2);
3834  			if (op == aoAdd) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 + V2; }
3835        		if (op == aoSub) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 - V2; }
3836        		if (op == aoMul) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 * V2; }
3837        		if (op == aoDiv) { FltCols[ColIdx3][RowI.GetRowIdx()] = V1 / V2; }
3838        		if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns");  }
3839        		if (op == aoMin) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 < V2) ? V1 : V2;}
3840        		if (op == aoMax) { FltCols[ColIdx3][RowI.GetRowIdx()] = (V1 > V2) ? V1 : V2;}
3841  		}
3842    }
3843  }
3844  void TTable::ColAdd(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3845    ColGenericOp(Attr1, Attr2, ResultAttrName, aoAdd);
3846  }
3847  void TTable::ColSub(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3848    ColGenericOp(Attr1, Attr2, ResultAttrName, aoSub);
3849  }
3850  void TTable::ColMul(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3851    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMul);
3852  }
3853  void TTable::ColDiv(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3854    ColGenericOp(Attr1, Attr2, ResultAttrName, aoDiv);
3855  }
3856  void TTable::ColMod(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3857    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMod);
3858  }
3859  void TTable::ColMin(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3860    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMin);
3861  }
3862  void TTable::ColMax(const TStr& Attr1, const TStr& Attr2, const TStr& ResultAttrName) {
3863    ColGenericOp(Attr1, Attr2, ResultAttrName, aoMax);
3864  }
3865  void TTable::ColGenericOp(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& ResAttr,
3866   TArithOp op, TBool AddToFirstTable) {
3867    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3868    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
3869    if (NumValidRows != Table.NumValidRows) {
3870      TExcept::Throw("Tables do not have equal number of rows");
3871    }
3872    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3873    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
3874    TAttrType Arg1Type = Info1.Val1;
3875    TAttrType Arg2Type = Info2.Val1;
3876    if (Info1.Val1 == atStr || Info2.Val1 == atStr) {
3877      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3878    }
3879    if(Arg1Type == atInt && Arg2Type == atFlt && ResAttr == ""){
3880    	TExcept::Throw("Trying to write float values to an existing int-typed column");
3881    }
3882    TInt ColIdx1 = Info1.Val2;
3883    TInt ColIdx2 = Info2.Val2;
3884    TInt ColIdx3 = AddToFirstTable ? ColIdx1 : ColIdx2;
3885    if (ResAttr != "") {
3886      if (AddToFirstTable) {
3887        if (Arg1Type == atInt && Arg2Type == atInt) {
3888            AddIntCol(ResAttr);
3889        } else {
3890            AddFltCol(ResAttr);
3891        }
3892        ColIdx3 = GetColIdx(ResAttr);
3893      }
3894      else {
3895        if (Arg1Type == atInt && Arg2Type == atInt) {
3896            Table.AddIntCol(ResAttr);
3897        } else {
3898            Table.AddFltCol(ResAttr);
3899        }
3900        ColIdx3 = Table.GetColIdx(ResAttr);
3901      }
3902    }
3903    TRowIterator RI1, RI2;
3904    RI1 = BegRI();
3905    RI2 = Table.BegRI();
3906    TAttrType ResType = atFlt;
3907    if(Arg1Type == atInt && Arg2Type == atInt){ ResType = atInt;}
3908    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
3909      if (ResType == atInt) {
3910  		TInt V1 = RI1.GetIntAttr(ColIdx1);
3911  		TInt V2 = RI2.GetIntAttr(ColIdx2);
3912          if (AddToFirstTable) {
3913          	if (op == aoAdd) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3914          	if (op == aoSub) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3915          	if (op == aoMul) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3916          	if (op == aoDiv) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3917         		if (op == aoMod) { IntCols[ColIdx3][RI1.GetRowIdx()] = V1 % V2; }
3918        	}
3919        	else {
3920          	if (op == aoAdd) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3921          	if (op == aoSub) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3922          	if (op == aoMul) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3923          	if (op == aoDiv) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3924          	if (op == aoMod) { Table.IntCols[ColIdx3][RI2.GetRowIdx()] = V1 % V2; }
3925        	}
3926      } else {
3927  	  	TFlt V1 = (Arg1Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx1) : RI2.GetFltAttr(ColIdx1);
3928  		TFlt V2 = (Arg2Type == atInt) ? (TFlt)RI1.GetIntAttr(ColIdx2) : RI2.GetFltAttr(ColIdx2);
3929        	if (AddToFirstTable) {
3930          	if (op == aoAdd) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 + V2; }
3931          	if (op == aoSub) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 - V2; }
3932          	if (op == aoMul) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 * V2; }
3933         	 	if (op == aoDiv) { FltCols[ColIdx3][RI1.GetRowIdx()] = V1 / V2; }
3934          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3935        	} else {
3936          	if (op == aoAdd) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 + V2; }
3937          	if (op == aoSub) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 - V2; }
3938          	if (op == aoMul) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 * V2; }
3939          	if (op == aoDiv) { Table.FltCols[ColIdx3][RI2.GetRowIdx()] = V1 / V2; }
3940          	if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
3941        	}
3942      }
3943      RI1++;
3944      RI2++;
3945    }
3946    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
3947      TExcept::Throw("ColGenericOp: Iteration error");
3948    }
3949  }
3950  void TTable::ColAdd(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3951   const TStr& ResultAttrName, TBool AddToFirstTable) {
3952    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoAdd, AddToFirstTable);
3953  }
3954  void TTable::ColSub(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3955   const TStr& ResultAttrName, TBool AddToFirstTable) {
3956    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoSub, AddToFirstTable);
3957  }
3958  void TTable::ColMul(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3959   const TStr& ResultAttrName, TBool AddToFirstTable) {
3960    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMul, AddToFirstTable);
3961  }
3962  void TTable::ColDiv(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3963   const TStr& ResultAttrName, TBool AddToFirstTable) {
3964    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoDiv, AddToFirstTable);
3965  }
3966  void TTable::ColMod(const TStr& Attr1, TTable& Table, const TStr& Attr2, 
3967   const TStr& ResultAttrName, TBool AddToFirstTable) {
3968    ColGenericOp(Attr1, Table, Attr2, ResultAttrName, aoMod, AddToFirstTable);
3969  }
3970  void TTable::ColGenericOp(const TStr& Attr1, const TFlt& Num, const TStr& ResAttr, TArithOp op, const TBool floatCast) {
3971    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
3972    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
3973    TAttrType ArgType = Info1.Val1;
3974    if (ArgType == atStr) {
3975      TExcept::Throw("Only numeric columns supported in arithmetic operations.");
3976    }
3977    TInt ColIdx1 = Info1.Val2;
3978    TInt ColIdx2 = ColIdx1;
3979    TBool shouldCast = floatCast;
3980    if (ResAttr != "") {
3981        if ((ArgType == atInt) & !shouldCast) {
3982            AddIntCol(ResAttr);
3983        } else {
3984            AddFltCol(ResAttr);
3985        }
3986        ColIdx2 = GetColIdx(ResAttr);
3987    } else {
3988      shouldCast = false;
3989    }
3990    #ifdef USE_OPENMP
3991    if(GetMP()){
3992    	ColGenericOpMP(ColIdx1, ColIdx2, ArgType, Num, op, shouldCast);
3993    	return;
3994    }
3995    #endif  
3996    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
3997      if ((ArgType == atInt) && !shouldCast) {
3998        TInt CurVal = RowI.GetIntAttr(ColIdx1);
3999        TInt Val = static_cast<int>(Num);
4000        if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4001        if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4002        if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4003        if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4004        if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4005      }
4006      else {
4007        TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4008        if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4009        if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4010        if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4011        if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4012        if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4013      }
4014    }
4015  }
4016  #ifdef USE_OPENMP
4017  void TTable::ColGenericOpMP(const TInt& ColIdx1, const TInt& ColIdx2, TAttrType ArgType, const TFlt& Num, TArithOp op, TBool ShouldCast){
4018  	TIntPrV Partitions;
4019  	GetPartitionRanges(Partitions, omp_get_max_threads()*CHUNKS_PER_THREAD);
4020  	TInt PartitionSize = Partitions[0].GetVal2()-Partitions[0].GetVal1()+1;
4021  	#pragma omp parallel for schedule(dynamic, CHUNKS_PER_THREAD)
4022  	for (int i = 0; i < Partitions.Len(); i++){
4023  		TRowIterator RowI(Partitions[i].GetVal1(), this);
4024  		TRowIterator EndI(Partitions[i].GetVal2(), this);
4025  		while(RowI < EndI){
4026  			if ((ArgType == atInt) && !ShouldCast) {
4027        			TInt CurVal = RowI.GetIntAttr(ColIdx1);
4028        			TInt Val = static_cast<int>(Num);
4029        			if (op == aoAdd) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Val; }
4030        			if (op == aoSub) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Val; }
4031        			if (op == aoMul) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Val; }
4032        			if (op == aoDiv) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Val; }
4033        			if (op == aoMod) { IntCols[ColIdx2][RowI.GetRowIdx()] = CurVal % Val; }
4034      		} else {
4035       			TFlt CurVal = (ArgType == atFlt) ? RowI.GetFltAttr(ColIdx1) : (TFlt) RowI.GetIntAttr(ColIdx1);
4036        			if (op == aoAdd) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal + Num; }
4037        			if (op == aoSub) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal - Num; }
4038        			if (op == aoMul) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal * Num; }
4039        			if (op == aoDiv) { FltCols[ColIdx2][RowI.GetRowIdx()] = CurVal / Num; }
4040        			if (op == aoMod) { TExcept::Throw("Cannot find modulo for float columns"); }
4041      		}
4042      		RowI++;
4043  		}
4044  	}
4045  }
4046  #endif
4047  void TTable::ColAdd(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4048    ColGenericOp(Attr1, Num, ResultAttrName, aoAdd, floatCast);
4049  }
4050  void TTable::ColSub(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4051    ColGenericOp(Attr1, Num, ResultAttrName, aoSub, floatCast);
4052  }
4053  void TTable::ColMul(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4054    ColGenericOp(Attr1, Num, ResultAttrName, aoMul, floatCast);
4055  }
4056  void TTable::ColDiv(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4057    ColGenericOp(Attr1, Num, ResultAttrName, aoDiv, floatCast);
4058  }
4059  void TTable::ColMod(const TStr& Attr1, const TFlt& Num, const TStr& ResultAttrName, const TBool floatCast) {
4060    ColGenericOp(Attr1, Num, ResultAttrName, aoMod, floatCast);
4061  }
4062  void TTable::ColConcat(const TStr& Attr1, const TStr& Attr2, const TStr& Sep, const TStr& ResAttr) {
4063    if (!IsAttr(Attr1)) TExcept::Throw("No attribute present: " + Attr1);
4064    if (!IsAttr(Attr2)) TExcept::Throw("No attribute present: " + Attr2);
4065    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4066    TPair<TAttrType, TInt> Info2 = GetColTypeMap(Attr2);
4067    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4068      TExcept::Throw("Only string columns supported in concat.");
4069    }
4070    TInt ColIdx1 = Info1.Val2;
4071    TInt ColIdx2 = Info2.Val2;
4072    TInt ColIdx3 = ColIdx1;
4073    if (ResAttr != "") {
4074        AddStrCol(ResAttr);
4075        ColIdx3 = GetColIdx(ResAttr);
4076    }
4077    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4078      TStr CurVal1 = RowI.GetStrAttr(ColIdx1);
4079      TStr CurVal2 = RowI.GetStrAttr(ColIdx2);
4080      TStr NewVal = CurVal1 + Sep + CurVal2;
4081      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4082      StrColMaps[ColIdx3][RowI.GetRowIdx()] = Key;
4083    }
4084  }
4085  void TTable::ColConcat(const TStr& Attr1, TTable& Table, const TStr& Attr2, const TStr& Sep, 
4086   const TStr& ResAttr, TBool AddToFirstTable) {
4087    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4088    if (!Table.IsAttr(Attr2)) { TExcept::Throw("No attribute present: " + Attr2); }
4089    if (NumValidRows != Table.NumValidRows) {
4090      TExcept::Throw("Tables do not have equal number of rows");
4091    }
4092    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4093    TPair<TAttrType, TInt> Info2 = Table.GetColTypeMap(Attr2);
4094    if (Info1.Val1 != atStr || Info2.Val1 != atStr) {
4095      TExcept::Throw("Only string columns supported in concat.");
4096    }
4097    TInt ColIdx1 = Info1.Val2;
4098    TInt ColIdx2 = Info2.Val2;
4099    TInt ColIdx3 = ColIdx1;
4100    if (!AddToFirstTable) {
4101      ColIdx3 = ColIdx2;
4102    }
4103    if (ResAttr != "") {
4104      if (AddToFirstTable) {
4105        AddStrCol(ResAttr);
4106        ColIdx3 = GetColIdx(ResAttr);
4107      }
4108      else {
4109        Table.AddStrCol(ResAttr);
4110        ColIdx3 = Table.GetColIdx(ResAttr);
4111      }
4112    }
4113    TRowIterator RI1, RI2;
4114    RI1 = BegRI();
4115    RI2 = Table.BegRI();
4116    while (RI1 < EndRI() && RI2 < Table.EndRI()) {
4117      TStr CurVal1 = RI1.GetStrAttr(ColIdx1);
4118      TStr CurVal2 = RI2.GetStrAttr(ColIdx2);
4119      TStr NewVal = CurVal1 + Sep + CurVal2;
4120      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4121      if (AddToFirstTable) {
4122        StrColMaps[ColIdx3][RI1.GetRowIdx()] = Key;
4123      }
4124      else {
4125        Table.StrColMaps[ColIdx3][RI2.GetRowIdx()] = Key;
4126      }
4127      RI1++;
4128      RI2++;
4129    }
4130    if (RI1 != EndRI() || RI2 != Table.EndRI()) {
4131      TExcept::Throw("ColGenericOp: Iteration error");
4132    }
4133  }
4134  void TTable::ColConcatConst(const TStr& Attr1, const TStr& Val, const TStr& Sep, const TStr& ResAttr) {
4135    if (!IsAttr(Attr1)) { TExcept::Throw("No attribute present: " + Attr1); }
4136    TPair<TAttrType, TInt> Info1 = GetColTypeMap(Attr1);
4137    if (Info1.Val1 != atStr) {
4138      TExcept::Throw("Only string columns supported in concat.");
4139    }
4140    TInt ColIdx1 = Info1.Val2;
4141    TInt ColIdx2 = ColIdx1;
4142    if (ResAttr != "") {
4143      AddStrCol(ResAttr);
4144      ColIdx2 = GetColIdx(ResAttr);
4145    }
4146    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4147      TStr CurVal = RowI.GetStrAttr(ColIdx1);
4148      TStr NewVal = CurVal + Sep + Val;
4149      TInt Key = TInt(Context->StringVals.AddKey(NewVal));
4150      StrColMaps[ColIdx2][RowI.GetRowIdx()] = Key;
4151    }  
4152  }
4153  void TTable::ReadIntCol(const TStr& ColName, TIntV& Result) const{
4154    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4155    if (GetColType(ColName) != atInt) { TExcept::Throw("not an integer column " + ColName); }
4156    TInt ColId = GetColIdx(ColName);
4157    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4158      Result.Add(it.GetIntAttr(ColId));
4159    }
4160  }
4161  void TTable::ReadFltCol(const TStr& ColName, TFltV& Result) const{
4162    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4163    if (GetColType(ColName) != atFlt) { TExcept::Throw("not a floating point column " + ColName); }
4164    TInt ColId = GetColIdx(ColName);
4165    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4166      Result.Add(it.GetFltAttr(ColId));
4167    }
4168  }
4169  void TTable::ReadStrCol(const TStr& ColName, TStrV& Result) const{
4170    if (!IsColName(ColName)) { TExcept::Throw("no such column " + ColName); }
4171    if (GetColType(ColName) != atStr) { TExcept::Throw("not a string column " + ColName); }
4172    TInt ColId = GetColIdx(ColName);
4173    for (TRowIterator it = BegRI(); it < EndRI(); it++) {
4174      Result.Add(it.GetStrAttr(ColId));
4175    }
4176  }
4177  void TTable::ProjectInPlace(const TStrV& ProjectCols) {
4178    TStrV NProjectCols = NormalizeColNameV(ProjectCols);
4179    for (TInt c = 0; c < NProjectCols.Len(); c++) {
4180      if (!IsColName(NProjectCols[c])) { TExcept::Throw("no such column " + NProjectCols[c]); }
4181    }
4182    THashSet<TStr> ProjectColsSet = THashSet<TStr>(NProjectCols);
4183    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4184      TStr ColName = GetSchemaColName(i);
4185      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4186      TAttrType ColType = GetSchemaColType(i);
4187      TInt ColId = GetColIdx(ColName);
4188      switch (ColType) {
4189        case atInt:
4190          IntCols.Del(ColId);
4191          break;
4192        case atFlt:
4193          FltCols.Del(ColId);
4194          break;
4195        case atStr:
4196          StrColMaps.Del(ColId);
4197          break;
4198      }
4199    }
4200    TInt IntColCnt = 0;
4201    TInt FltColCnt = 0;
4202    TInt StrColCnt = 0;
4203    ColTypeMap.Clr();
4204    for (TInt i = 0; i < Sch.Len(); i++) {
4205      TStr ColName = GetSchemaColName(i);
4206      if (!ProjectColsSet.IsKey(ColName) && ColName != IdColName) { continue; }
4207      TAttrType ColType = GetSchemaColType(i);
4208      switch (ColType) {
4209        case atInt:
4210          AddColType(ColName, atInt, IntColCnt);
4211          IntColCnt++;
4212          break;
4213        case atFlt:
4214          AddColType(ColName, atFlt, FltColCnt);
4215          FltColCnt++;
4216          break;
4217        case atStr:
4218          AddColType(ColName, atStr, StrColCnt);
4219          StrColCnt++;
4220          break;
4221      }
4222    }
4223    for (TInt i = Sch.Len() - 1; i >= 0; i--) {
4224      TStr ColName = GetSchemaColName(i);
4225      if (ProjectColsSet.IsKey(ColName) || ColName == IdColName) { continue; }
4226      Sch.Del(i);
4227    }
4228  }
4229  TInt TTable::CompareKeyVal(const TInt& K1, const TInt& V1, const TInt& K2, const TInt& V2) {
4230    if (K1 == K2) { return V1 - V2; }
4231    else { return K1 - K2; }
4232  }
4233  TInt TTable::CheckSortedKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4234    TInt j;
4235    for (j = Start; j < End; j++) {
4236      if (CompareKeyVal(Key[j], Val[j], Key[j+1], Val[j+1]) > 0) {
4237        break;
4238      }
4239    }
4240    if (j >= End) { return 0; }
4241    else { return 1; }
4242  }
4243  void TTable::ISortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4244    if (Start < End) {
4245      for (TInt i = Start+1; i <= End; i++) {
4246        TInt K = Key[i];
4247        TInt V = Val[i];
4248        TInt j = i;
4249        while ((Start < j) && (CompareKeyVal(Key[j-1], Val[j-1], K, V) > 0)) {
4250          Key[j] = Key[j-1];
4251          Val[j] = Val[j-1];
4252          j--;
4253        }
4254        Key[j] = K;
4255        Val[j] = V;
4256      }
4257    }
4258  }
4259  TInt TTable::GetPivotKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4260    TInt L = End - Start + 1;
4261    const TInt Idx1 = Start + TInt::GetRnd(L);
4262    const TInt Idx2 = Start + TInt::GetRnd(L);
4263    const TInt Idx3 = Start + TInt::GetRnd(L);
4264    if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx2], Val[Idx2]) < 0) {
4265      if (CompareKeyVal(Key[Idx2], Val[Idx2], Key[Idx3], Val[Idx3]) < 0) { return Idx2; }
4266      if (CompareKeyVal(Key[Idx1], Val[Idx1], Key[Idx3], Val[Idx3]) < 0) { return Idx3; }
4267      return Idx1;
4268    } else {
4269      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx2], Val[Idx2]) < 0) { return Idx2; }
4270      if (CompareKeyVal(Key[Idx3], Val[Idx3], Key[Idx1], Val[Idx1]) < 0) { return Idx3; }
4271      return Idx1;
4272    }
4273  }
4274  TInt TTable::PartitionKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4275    TInt Pivot = GetPivotKeyVal(Key, Val, Start, End);
4276    TInt PivotKey = Key[Pivot];
4277    TInt PivotVal = Val[Pivot];
4278    Key.Swap(Pivot, End);
4279    Val.Swap(Pivot, End);
4280    TInt StoreIdx = Start;
4281    for (TInt i = Start; i < End; i++) {
4282      if (CompareKeyVal(Key[i], Val[i], PivotKey, PivotVal) <= 0) {
4283        Key.Swap(i, StoreIdx);
4284        Val.Swap(i, StoreIdx);
4285        StoreIdx++;
4286      }
4287    }
4288    Key.Swap(StoreIdx, End);
4289    Val.Swap(StoreIdx, End);
4290    return StoreIdx;
4291  }
4292  void TTable::QSortKeyVal(TIntV& Key, TIntV& Val, TInt Start, TInt End) {
4293    TInt L = End-Start;
4294    if (L <= 0) { return; }
4295    if (CheckSortedKeyVal(Key, Val, Start, End) == 0) { return; }
4296    if (L <= 20) { ISortKeyVal(Key, Val, Start, End); }
4297    else {
4298      TInt Pivot = PartitionKeyVal(Key, Val, Start, End);
4299      if (Pivot > End) { return; }
4300      if (L <= 500000) {
4301        QSortKeyVal(Key, Val, Start, Pivot-1);
4302        QSortKeyVal(Key, Val, Pivot+1, End);
4303      } else {
4304  #ifdef USE_OPENMP
4305  #ifndef GLib_WIN32
4306        #pragma omp task untied shared(Key, Val)
4307  #endif
4308  #endif
4309        { QSortKeyVal(Key, Val, Start, Pivot-1); }
4310  #ifdef USE_OPENMP
4311  #ifndef GLib_WIN32
4312        #pragma omp task untied shared(Key, Val)
4313  #endif
4314  #endif
4315        { QSortKeyVal(Key, Val, Pivot+1, End); }
4316      }
4317    }
4318  }
4319  TIntV TTable::GetIntRowIdxByVal(const TStr& ColName, const TInt& Val) const {
4320    if (IntColIndexes.IsKey(ColName)) {
4321      THash<TInt, TIntV> ColIndex = IntColIndexes.GetDat(ColName);
4322      if (ColIndex.IsKey(Val)) {
4323        return ColIndex.GetDat(Val);
4324      }
4325      else {
4326        TIntV Empty;
4327        return Empty;
4328      }
4329    }
4330    TIntV ToReturn;
4331    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4332      TInt ValAtRow = RowI.GetIntAttr(ColName);
4333      if ( Val == ValAtRow) {
4334        ToReturn.Add(RowI.GetRowIdx());
4335      }
4336    }
4337    return ToReturn;
4338  }
4339  TIntV TTable::GetStrRowIdxByMap(const TStr& ColName, const TInt& Map) const {
4340    if (StrMapColIndexes.IsKey(ColName)) {
4341      THash<TInt, TIntV> ColIndex = StrMapColIndexes.GetDat(ColName);
4342      if (ColIndex.IsKey(Map)) {
4343        return ColIndex.GetDat(Map);
4344      }
4345      else {
4346        TIntV Empty;
4347        return Empty;
4348      }
4349    }
4350    TIntV ToReturn;
4351    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4352      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4353      if ( Map == MapAtRow) {
4354        ToReturn.Add(RowI.GetRowIdx());
4355      }
4356    }
4357    return ToReturn;
4358  }
4359  TIntV TTable::GetFltRowIdxByVal(const TStr& ColName, const TFlt& Val) const {
4360    if (FltColIndexes.IsKey(ColName)) {
4361      THash<TFlt, TIntV> ColIndex = FltColIndexes.GetDat(ColName);
4362      if (ColIndex.IsKey(Val)) {
4363        return ColIndex.GetDat(Val);
4364      }
4365      else {
4366        TIntV Empty;
4367        return Empty;
4368      }
4369    }
4370    TIntV ToReturn;
4371    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4372      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4373      if ( Val == ValAtRow) {
4374        ToReturn.Add(RowI.GetRowIdx());
4375      }
4376    }
4377    return ToReturn;
4378  }
4379  TInt TTable::RequestIndexInt(const TStr& ColName) {
4380    THash<TInt, TIntV> NewIndex;
4381    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4382      TInt ValAtRow = RowI.GetIntAttr(ColName);
4383      TInt RowIdx = RowI.GetRowIdx();
4384      if (NewIndex.IsKey(ValAtRow)) {
4385         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4386         Curr_V.Add(RowIdx);
4387      }
4388      else {
4389        TIntV New_V;
4390        New_V.Add(RowIdx);
4391        NewIndex.AddDat(ValAtRow, New_V);
4392      }
4393    }
4394    IntColIndexes.AddDat(ColName, NewIndex); 
4395    return 0;
4396  }
4397  TInt TTable::RequestIndexFlt(const TStr& ColName) {
4398    THash<TFlt, TIntV> NewIndex;
4399    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4400      TFlt ValAtRow = RowI.GetFltAttr(ColName);
4401      TInt RowIdx = RowI.GetRowIdx();
4402      if (NewIndex.IsKey(ValAtRow)) {
4403         TIntV Curr_V = NewIndex.GetDat(ValAtRow);
4404         Curr_V.Add(RowIdx);
4405      }
4406      else {
4407        TIntV New_V;
4408        New_V.Add(RowIdx);
4409        NewIndex.AddDat(ValAtRow, New_V);
4410      }
4411    }
4412    FltColIndexes.AddDat(ColName, NewIndex); 
4413    return 0;
4414  }
4415  TInt TTable::RequestIndexStrMap(const TStr& ColName) {
4416    THash<TInt, TIntV> NewIndex;
4417    for (TRowIterator RowI = BegRI(); RowI < EndRI(); RowI++) {
4418      TInt MapAtRow = RowI.GetStrMapByName(ColName);
4419      TInt RowIdx = RowI.GetRowIdx();
4420      if (NewIndex.IsKey(MapAtRow)) {
4421         TIntV Curr_V = NewIndex.GetDat(MapAtRow);
4422         Curr_V.Add(RowIdx);
4423      }
4424      else {
4425        TIntV New_V;
4426        New_V.Add(RowIdx);
4427        NewIndex.AddDat(MapAtRow, New_V);
4428      }
4429    }
4430    StrMapColIndexes.AddDat(ColName, NewIndex); 
4431    return 0;
4432  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-table.cpp</div>
                </div>
                <div class="column column_space"><pre><code>605  		return;
606  	UINT codepage = CP_ACP;
607  	UniMode unicodeMode = _currentBuffer->getUnicodeMode();
608  	int encoding = _currentBuffer->getEncoding();
</pre></code></div>
                <div class="column column_space"><pre><code>465    }
466    int64 Cnt = 0;
467    uint64 Pos = Ss.GetStreamPos();
468    uint64 Len = Ss.GetStreamLen();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    