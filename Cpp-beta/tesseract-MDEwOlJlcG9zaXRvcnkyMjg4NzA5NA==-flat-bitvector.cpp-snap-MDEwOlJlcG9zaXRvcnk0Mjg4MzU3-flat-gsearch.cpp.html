
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.00127024452207%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-bitvector.cpp</h3>
            <pre><code>1  #include "bitvector.h"
2  #include <algorithm>
3  #include <cstring>
4  #include "helpers.h"
5  #include "serialis.h" 
6  namespace tesseract {
7  const uint8_t BitVector::lsb_index_[256] = {
8      255, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
9      0,   1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0,
10      1,   0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1,
11      0,   3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
12      2,   0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4,
13      0,   1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
14      1,   0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1,
15      0,   2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
16      3,   0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
17  const uint8_t BitVector::lsb_eroded_[256] = {
18      0,    0,    0,    0x2,  0,    0x4,  0x4,  0x6,  0,    0x8,  0x8,  0x0a, 0x08, 0x0c, 0x0c, 0x0e,
19      0,    0x10, 0x10, 0x12, 0x10, 0x14, 0x14, 0x16, 0x10, 0x18, 0x18, 0x1a, 0x18, 0x1c, 0x1c, 0x1e,
20      0,    0x20, 0x20, 0x22, 0x20, 0x24, 0x24, 0x26, 0x20, 0x28, 0x28, 0x2a, 0x28, 0x2c, 0x2c, 0x2e,
21      0x20, 0x30, 0x30, 0x32, 0x30, 0x34, 0x34, 0x36, 0x30, 0x38, 0x38, 0x3a, 0x38, 0x3c, 0x3c, 0x3e,
22      0,    0x40, 0x40, 0x42, 0x40, 0x44, 0x44, 0x46, 0x40, 0x48, 0x48, 0x4a, 0x48, 0x4c, 0x4c, 0x4e,
23      0x40, 0x50, 0x50, 0x52, 0x50, 0x54, 0x54, 0x56, 0x50, 0x58, 0x58, 0x5a, 0x58, 0x5c, 0x5c, 0x5e,
24      0x40, 0x60, 0x60, 0x62, 0x60, 0x64, 0x64, 0x66, 0x60, 0x68, 0x68, 0x6a, 0x68, 0x6c, 0x6c, 0x6e,
25      0x60, 0x70, 0x70, 0x72, 0x70, 0x74, 0x74, 0x76, 0x70, 0x78, 0x78, 0x7a, 0x78, 0x7c, 0x7c, 0x7e,
26      0,    0x80, 0x80, 0x82, 0x80, 0x84, 0x84, 0x86, 0x80, 0x88, 0x88, 0x8a, 0x88, 0x8c, 0x8c, 0x8e,
27      0x80, 0x90, 0x90, 0x92, 0x90, 0x94, 0x94, 0x96, 0x90, 0x98, 0x98, 0x9a, 0x98, 0x9c, 0x9c, 0x9e,
28      0x80, 0xa0, 0xa0, 0xa2, 0xa0, 0xa4, 0xa4, 0xa6, 0xa0, 0xa8, 0xa8, 0xaa, 0xa8, 0xac, 0xac, 0xae,
29      0xa0, 0xb0, 0xb0, 0xb2, 0xb0, 0xb4, 0xb4, 0xb6, 0xb0, 0xb8, 0xb8, 0xba, 0xb8, 0xbc, 0xbc, 0xbe,
30      0x80, 0xc0, 0xc0, 0xc2, 0xc0, 0xc4, 0xc4, 0xc6, 0xc0, 0xc8, 0xc8, 0xca, 0xc8, 0xcc, 0xcc, 0xce,
31      0xc0, 0xd0, 0xd0, 0xd2, 0xd0, 0xd4, 0xd4, 0xd6, 0xd0, 0xd8, 0xd8, 0xda, 0xd8, 0xdc, 0xdc, 0xde,
32      0xc0, 0xe0, 0xe0, 0xe2, 0xe0, 0xe4, 0xe4, 0xe6, 0xe0, 0xe8, 0xe8, 0xea, 0xe8, 0xec, 0xec, 0xee,
33      0xe0, 0xf0, 0xf0, 0xf2, 0xf0, 0xf4, 0xf4, 0xf6, 0xf0, 0xf8, 0xf8, 0xfa, 0xf8, 0xfc, 0xfc, 0xfe};
34  const int BitVector::hamming_table_[256] = {
35      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
36      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
37      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
38      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
39      1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
40      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
41      2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
42      3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};
43  BitVector &BitVector::operator=(const BitVector &src) {
44    array_ = src.array_;
45    bit_size_ = src.bit_size_;
46    return *this;
47  }
48  void BitVector::Init(int length) {
49    Alloc(length);
50    SetAllFalse();
51  }
52  bool BitVector::Serialize(FILE *fp) const {
53    if (!tesseract::Serialize(fp, &bit_size_)) {
54      return false;
55    }
56    int wordlen = WordLength();
57    return tesseract::Serialize(fp, &array_[0], wordlen);
58  }
59  bool BitVector::DeSerialize(bool swap, FILE *fp) {
60    uint32_t new_bit_size;
61    if (!tesseract::DeSerialize(fp, &new_bit_size)) {
62      return false;
63    }
64    if (swap) {
65      ReverseN(&new_bit_size, sizeof(new_bit_size));
66    }
67    Alloc(new_bit_size);
68    int wordlen = WordLength();
69    if (!tesseract::DeSerialize(fp, &array_[0], wordlen)) {
70      return false;
71    }
72    if (swap) {
73      for (int i = 0; i < wordlen; ++i) {
74        ReverseN(&array_[i], sizeof(array_[i]));
75      }
76    }
77    return true;
78  }
79  void BitVector::SetAllFalse() {
80    memset(&array_[0], 0, ByteLength());
81  }
82  void BitVector::SetAllTrue() {
83    memset(&array_[0], ~0, ByteLength());
84  }
85  int BitVector::NextSetBit(int prev_bit) const {
86    int next_bit = prev_bit + 1;
87    if (next_bit >= bit_size_) {
88      return -1;
89    }
90    int next_word = WordIndex(next_bit);
91    int bit_index = next_word * kBitFactor;
92    int word_end = bit_index + kBitFactor;
93    uint32_t word = array_[next_word];
94    uint8_t byte = word & 0xff;
95    while (bit_index < word_end) {
96      if (bit_index + 8 > next_bit && byte != 0) {
97        while (bit_index + lsb_index_[byte] < next_bit && byte != 0) {
98          byte = lsb_eroded_[byte];
99        }
100        if (byte != 0) {
101          return bit_index + lsb_index_[byte];
102        }
103      }
104      word >>= 8;
105      bit_index += 8;
106      byte = word & 0xff;
107    }
108    ++next_word;
109    int wordlen = WordLength();
110    while (next_word < wordlen && (word = array_[next_word]) == 0) {
111      ++next_word;
112      bit_index += kBitFactor;
113    }
114    if (bit_index >= bit_size_) {
115      return -1;
116    }
117    while ((word & 0xff) == 0) {
118      word >>= 8;
119      bit_index += 8;
120    }
121    return bit_index + lsb_index_[word & 0xff];
122  }
123  int BitVector::NumSetBits() const {
124    int wordlen = WordLength();
125    int total_bits = 0;
126    for (int w = 0; w < wordlen; ++w) {
127      uint32_t word = array_[w];
128      for (int i = 0; i < 4; ++i) {
129        total_bits += hamming_table_[word & 0xff];
130        word >>= 8;
131      }
132    }
133    return total_bits;
<span onclick='openModal()' class='match'>134  }
135  void BitVector::operator|=(const BitVector &other) {
136    int length = std::min(WordLength(), other.WordLength());
137    for (int w = 0; w < length; ++w) {
</span>138      array_[w] |= other.array_[w];
139    }
140  }
141  void BitVector::operator&=(const BitVector &other) {
142    int length = std::min(WordLength(), other.WordLength());
143    for (int w = 0; w < length; ++w) {
144      array_[w] &= other.array_[w];
145    }
146    for (int w = WordLength() - 1; w >= length; --w) {
147      array_[w] = 0;
148    }
149  }
150  void BitVector::operator^=(const BitVector &other) {
151    int length = std::min(WordLength(), other.WordLength());
152    for (int w = 0; w < length; ++w) {
153      array_[w] ^= other.array_[w];
154    }
155  }
156  void BitVector::SetSubtract(const BitVector &v1, const BitVector &v2) {
157    Alloc(v1.size());
158    int length = std::min(v1.WordLength(), v2.WordLength());
159    for (int w = 0; w < length; ++w) {
160      array_[w] = v1.array_[w] ^ (v1.array_[w] & v2.array_[w]);
161    }
162    for (int w = WordLength() - 1; w >= length; --w) {
163      array_[w] = v1.array_[w];
164    }
165  }
166  void BitVector::Alloc(int length) {
167    int initial_wordlength = WordLength();
168    bit_size_ = length;
169    int new_wordlength = WordLength();
170    if (new_wordlength != initial_wordlength) {
171      array_.resize(new_wordlength);
172    }
173  }
174  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</h3>
            <pre><code>1  TStr TGixConst::WdGixFNm = "WdGix";
2  TStr TGixConst::WdGixDatFNm = "WdGix.Dat";
3  TStr TGixConst::WdGixBsFNm = "WdGixBs.MBlobBs";
4  TStr TGixConst::WdGixMDSFNm = "WdGixMDS.Dat";
5  TStr TGixConst::TrGixFNm = "TrGix";
6  TStr TGixConst::TrGixDatFNm = "TrGix.Dat";
7  TStr TGixConst::TrGixDocBsFNm = "TrGixDocBs.MBlobBs";
8  TStr TGixConst::TrGixSentBsFNm = "TrGixSentBs.MBlobBs";
9  TStr TGixConst::TrGixTrAttrBsFNm = "TrGixTrAttrBs.MBlobBs";
10  TStr TGixConst::MWdGixFNm = "MWdGix";
11  TStr TGixConst::MWdGixDatFNm = "MWdGix.Dat";
12  TStr TGixConst::MWdGixDocBsFNm = "MWdGixDocBs.MBlobBs";
13  TStr TGixConst::MWdGixBsFNm = "MWdGixBs.Dat";
14  int TWdGixItem::TitleBit = 0;
15  int TWdGixItem::NmObjBit = 1;
16  int TWdGixItem::AnchorBit = 2;
17  int TWdGixItem::EmphBit = 3;
18  TWdGixItem::TWdGixItem(const TBlobPt& BlobPt, const uchar& _Wgt, const uchar& _WdPos,
19          const bool& TitleP, const bool& NmObjP, const bool& AnchorP, const bool& EmphP):
20              Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()), WdPos(_WdPos) {
21      FSet.SetBit(TitleBit, TitleP);
22      FSet.SetBit(NmObjBit, NmObjP);
23      FSet.SetBit(AnchorBit, AnchorP);
24      FSet.SetBit(EmphBit, EmphP);
25  }
26  TWdGixItem::TWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _Wgt,
27          const uchar& _WdPos, const bool& TitleP, const bool& NmObjP, const bool& AnchorP,
28          const bool& EmphP): Seg(_Seg), Addr(_Addr), Wgt(_Wgt), WdPos(_WdPos) {
29      FSet.SetBit(TitleBit, TitleP);
30      FSet.SetBit(NmObjBit, NmObjP);
31      FSet.SetBit(AnchorBit, AnchorP);
32      FSet.SetBit(EmphBit, EmphP);
33  }
34  TWdGixItem::TWdGixItem(TSIn& SIn) {
35      SIn.Load(Seg); SIn.Load(Addr);
36      SIn.Load(Wgt); SIn.Load(WdPos); FSet=TB8Set(SIn);
37  }
38  void TWdGixItem::Save(TSOut& SOut) const {
39      SOut.Save(Seg); SOut.Save(Addr);
40      SOut.Save(Wgt); SOut.Save(WdPos); FSet.Save(SOut);
41  }
42  inline bool TWdGixItem::operator==(const TWdGixItem& Item) const {
43      return (Seg == Item.Seg) && (Addr == Item.Addr); 
44  }
45  inline bool TWdGixItem::operator<(const TWdGixItem& Item) const {
46      return (Seg < Item.Seg) ||
47          ((Seg == Item.Seg) && (Addr < Item.Addr)); 
48  }
49  void TWdGix::LoadTags() {
50      TitleTagH.AddKey("<TITLE>");
51      NmObjTagH.AddKey("<NMOBJ>");
52      EmphTagH.AddKey("<EM>"); EmphTagH.AddKey("<A>"); EmphTagH.AddKey("<B>");
53      EmphTagH.AddKey("<I>"); EmphTagH.AddKey("<H1>"); EmphTagH.AddKey("<H2>");
54      EmphTagH.AddKey("<H3>"); EmphTagH.AddKey("<H4>"); EmphTagH.AddKey("<H5>");
55  }
56  TWdGix::TWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
57      FPath = _FPath; FAccess = _FAccess;
58      WGix = TWGix::New(TGixConst::WdGixFNm, FPath, FAccess, CacheSize);
59      if (FAccess == faCreate) {
60          Stemmer = TStemmer::New(stmtPorter, false);
61          SwSet = TSwSet::New(swstEn523);
62      } else {
63          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
64          TFIn FIn(WdGixDatFNm);
65          WordH.Load(FIn);
66          Stemmer = TStemmer::Load(FIn);
67          SwSet = TSwSet::Load(FIn);
68      }
69      LoadTags();
70  }
71  TWdGix::~TWdGix() {
72      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
73          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
74          TFOut FOut(WdGixDatFNm);
75          WordH.Save(FOut);
76          Stemmer->Save(FOut);
77          SwSet->Save(FOut);
78      }
79  }
80  void TWdGix::AddHtml(const TStr& HtmlStr, const TBlobPt& BlobPt, const uchar& Wgt) {
81      PSIn HtmlSIn = TStrIn::New(HtmlStr);
82      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
83      THash<TInt, TWdGixItemV> WIdToItemVH; uchar WdPos = 0;
84      bool TitleP = false, NmObjP = false; int EmphLv = 0;
85      while (HtmlLx.Sym != hsyEof) {
86          if (HtmlLx.Sym == hsyStr) {
87              TStr WordStr = HtmlLx.UcChA;
88              if (!SwSet->IsIn(WordStr)) {
89                  WordStr=Stemmer->GetStem(WordStr);
90                  const int WId = WordH.AddKey(WordStr);
91                  WdPos++;
92                  WIdToItemVH.AddDat(WId).Add(
93                      TWdGixItem(BlobPt, Wgt, WdPos, TitleP, NmObjP, false, (EmphLv>0)));
94              }
95          } else if (HtmlLx.Sym == hsyBTag) {
96              TStr TagStr = HtmlLx.UcChA;
97              if (TitleTagH.IsKey(TagStr)) { TitleP = true; }
98              if (NmObjTagH.IsKey(TagStr)) { NmObjP = true; }
99              if (EmphTagH.IsKey(TagStr)) { EmphLv++; }
100          } else if (HtmlLx.Sym == hsyETag) {
101              TStr TagStr = HtmlLx.UcChA;
102              if (TitleTagH.IsKey(TagStr)) { TitleP = false; }
103              if (NmObjTagH.IsKey(TagStr)) { NmObjP = false; }
104              if (EmphTagH.IsKey(TagStr)) { EmphLv--; EmphLv = TInt::GetMx(0, EmphLv); }
105          }
106          HtmlLx.GetSym();
107      }
108      int WdKeyId = WIdToItemVH.FFirstKeyId();
109      while (WIdToItemVH.FNextKeyId(WdKeyId)) {
110          const int WId = WIdToItemVH.GetKey(WdKeyId); WordH[WId]++;
111          const TWdGixItemV& ItemV = WIdToItemVH[WdKeyId];
112          const uchar Seg = ItemV[0].GetSeg();
113          const uint Addr = ItemV[0].GetAddr();
114          const uchar Count = uchar(TInt::GetMn(int(TUCh::Mx), ItemV.Len()));
115          bool TitleP = false, NmObjP = false, EmphP = false, AnchorP = false;
116          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
117              const TWdGixItem& Item = ItemV[ItemN];
118              TitleP = TitleP || Item.IsTitle();
119              NmObjP = NmObjP || Item.IsNmObj();
120              EmphP = EmphP || Item.IsAnchor();
121              AnchorP = AnchorP || Item.IsEmph();
122          }
123          TWdGixItem Item(Seg, Addr, Wgt, Count, TitleP, NmObjP, AnchorP, EmphP);
124          WGix->AddItem(WId, Item);
125      }
126  }
127  bool TWdGix::Search(const TStr& QueryStr, TWdGixItemV& ResItemV) {
128      PWGixExpItem WGixExp = TWGixExpItem::NewEmpty();
129      PSIn HtmlSIn = TStrIn::New(QueryStr);
130      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
131      while (HtmlLx.Sym != hsyEof) {
132          if (HtmlLx.Sym == hsyStr) {
133              TStr WordStr = HtmlLx.UcChA;
134              WordStr=Stemmer->GetStem(WordStr);
135              const int WId = WordH.GetKeyId(WordStr);
136              if (WId != -1) {
137                  PWGixExpItem WGixExpItem = TWGixExpItem::NewItem(WId);
138                  if (WGixExp->IsEmpty()) { WGixExp = WGixExpItem; }
139                  else { WGixExp = TWGixExpItem::NewAnd(WGixExp, WGixExpItem); }
140              }
141          }
142          HtmlLx.GetSym();
143      }
144      return WGixExp->Eval(WGix, ResItemV);
145  }
146  void TWdGixMDS::AddDate(const TBlobPt& DocBlobPt, const TTm& DateTime) {
147      TAddrPr AddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr());
148      const uint64 DateMSecs = TTm::GetMSecsFromTm(DateTime);
149      AddrPrToDateH.AddDat(AddrPr, DateMSecs);
150  }
151  inline uint64 TWdGixMDS::GetDateMSecs(const TBlobPt& DocBlobPt) const {
152      return AddrPrToDateH.GetDat(TAddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr()));
153  }
154  inline TTm TWdGixMDS::GetDateTTm(const TBlobPt& DocBlobPt) const {
155      return TTm::GetTmFromMSecs(GetDateMSecs(DocBlobPt));
156  }
157  void TWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
158          const TStrV& CatNmV, const TTm& DateTime) {
159      DocTitleV.Add(DocTitle);
160      DocTitleV.Last().DelChAll('\n');
161      DocTitleV.Last().DelChAll('\r');
162      DocStrV.Add(DocStr);
163      CatNmVV.Add(CatNmV);
164      DateTimeV.Add(DateTime);
165  }
166  void TWdGixRSet::SortByDate(const bool& Asc) {
167      typedef TPair<TUInt64, TInt> TUInt64IntPr;
168      TVec<TUInt64IntPr> TmMSecsDocNV;
169      const int Docs = GetDocs();
170      for (int DocN = 0; DocN < Docs; DocN++) {
171          uint64 TmMSecs = TTm::GetMSecsFromTm(DateTimeV[DocN]);
172          TmMSecsDocNV.Add(TUInt64IntPr(TmMSecs, DocN));
173      }
174      TmMSecsDocNV.Sort(Asc);
175      TStrV NewDocTitleV(Docs, 0), NewDocStrV(Docs, 0);
176      TVec<TStrV> NewCatNmVV(Docs, 0); TTmV NewDateTimeV(Docs, 0);
177      for (int NewDocN = 0; NewDocN < Docs; NewDocN++) {
178          const int OldDocN = TmMSecsDocNV[NewDocN].Val2;
179          NewDocTitleV.Add(DocTitleV[OldDocN]);
180          NewDocStrV.Add(DocStrV[OldDocN]);
181          NewCatNmVV.Add(CatNmVV[OldDocN]);
182          NewDateTimeV.Add(DateTimeV[OldDocN]);
183      }
184      DocTitleV = NewDocTitleV; DocStrV = NewDocStrV;
185      CatNmVV = NewCatNmVV; DateTimeV = NewDateTimeV;
<span onclick='openModal()' class='match'>186  }
187  void TWdGixRSet::PrintRes(PNotify Notify) {
188      const int Docs = GetDocs();
189      Notify->OnStatus(TStr::Fmt(
190          "All results: %d, Showing results from %d to %d",
191          AllDocs.Val, Docs, Docs + Offset.Val));
192      for (int DocN = 0; DocN < Docs; DocN++) {
</span>193          TTm DateTime = DateTimeV[DocN];
194          if (DateTime.IsDef()) {
195              Notify->OnStatus(TStr::Fmt("[%d: %s] %s ...", DocN+1,
196                  DateTime.GetWebLogDateStr().CStr(),
197                  DocTitleV[DocN].Left(50).CStr()));
198          } else {
199              Notify->OnStatus(TStr::Fmt("[%d] %s ...", DocN+1,
200                  DocTitleV[DocN].Left(60).CStr()));
201          }
202      }
203      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
204          AllDocs.Val, Docs, Docs + Offset.Val));
205  }
206  PBowDocBs TWdGixRSet::GenBowDocBs() const {
207      PSwSet SwSet = TSwSet::New(swstEn523);
208      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
209      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
210      const int Docs = GetDocs();
211      for (int DocN = 0; DocN < Docs; DocN++) {
212          const TStr& DocNm = DocTitleV[DocN];
213          const TStr& DocStr = DocStrV[DocN];
214          BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, true);
215      }
216      return BowDocBs;
217  }
218  void TWdGixBs::Filter(const TWgtWdGixItemKdV& InItemV,
219          const TWdGixBsGrouping& Grouping, TWgtWdGixItemKdV& OutItemV) {
220      OutItemV.Clr();
221      if (Grouping == wgbgName) {
222          TStrFltH NameToRankH; TStrH NameToItemNH;
223          const int Items = InItemV.Len();
224          for (int ItemN = 0; ItemN < Items; ItemN++) {
225              TBlobPt BlobPt = InItemV[ItemN].Dat.GetBlobPt();
226              TStr Name = GetDocTitle(BlobPt);
227              const double Rank = InItemV[ItemN].Key;
228              if (NameToRankH.IsKey(Name)) {
229                  const double OldRank = NameToRankH.GetDat(Name);
230                  if (Rank > OldRank) {
231                      NameToRankH.GetDat(Name) = Rank;
232                      NameToItemNH.GetDat(Name) = ItemN;
233                  }
234              } else {
235                  NameToRankH.AddDat(Name) = Rank;
236                  NameToItemNH.AddDat(Name) = ItemN;
237              }
238          }
239          int KeyId = NameToItemNH.FFirstKeyId();
240          while (NameToItemNH.FNextKeyId(KeyId)) {
241              const int ItemN = NameToItemNH[KeyId];
242              OutItemV.Add(InItemV[ItemN]);
243          }
244      } else if (Grouping == wgbgDate) {
245          Fail;
246      } else if (Grouping == wgbgDateTime) {
247          Fail;
248      }
249  }
250  TWdGixBs::TWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
251      FPath = _FPath; FAccess = _FAccess;
252      TStr WdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixBsFNm;
253      DocBBs = TMBlobBs::New(WdGixBsFNm, FAccess);
254      if (FAccess == faCreate) { WdGixMDS = TWdGixMDS::New(); }
255      else {
256          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
257          WdGixMDS = TWdGixMDS::LoadBin(WdGixMDSFNm);
258      }
259      WdGix = TWdGix::New(FPath, FAccess, CacheSize);
260  }
261  TWdGixBs::~TWdGixBs() {
262      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
263          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
264          WdGixMDS->SaveBin(WdGixMDSFNm);
265      }
266  }
267  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
268          const TStrV& CatNmV, const TTm& DateTime, const uchar& Wgt) {
269      TMOut DocMOut;
270      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
271      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
272      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
273      WdGix->AddHtml(DocStr, DocBlobPt, Wgt);
274  }
275  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStoreStr,
276          const TStr& DocIndexStr, const TStrV& CatNmV,
277          const TTm& DateTime, const uchar& Wgt) {
278      TMOut DocMOut;
279      DocTitle.Save(DocMOut); DocStoreStr.Save(DocMOut); CatNmV.Save(DocMOut);
280      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
281      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
282      WdGix->AddHtml(DocIndexStr, DocBlobPt, Wgt);
283  }
284  void TWdGixBs::GetDoc(const TBlobPt& BlobPt,
285          TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
286      PSIn SIn = DocBBs->GetBlob(BlobPt);
287      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
288  }
289  TStr TWdGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
290      PSIn SIn = DocBBs->GetBlob(BlobPt);
291      TStr DocTitle; DocTitle.Load(*SIn);
292      return DocTitle;
293  }
294  TStr TWdGixBs::GetDocStr(const TBlobPt& BlobPt) const {
295      PSIn SIn = DocBBs->GetBlob(BlobPt);
296      {TStr DocTitle; DocTitle.Load(*SIn);}
297      TStr DocStr; DocStr.Load(*SIn);
298      return DocStr;
299  }
300  TStrV TWdGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
301      PSIn SIn = DocBBs->GetBlob(BlobPt);
302      {TStr DocTitle; DocTitle.Load(*SIn);}
303      {TStr DocStr; DocStr.Load(*SIn);}
304      TStrV CatNmV; CatNmV.Load(*SIn);
305      return CatNmV;
306  }
307  PWdGixRSet TWdGixBs::SearchDoc(const TStr& QueryStr,
308          const TWdGixBsGrouping& Grouping, TWdGixRankFun& RankFun,
309          const int& Docs, const int& Offset, const TTm& MnDate,
310          const TTm& MxDate) {
311      printf("  Loading from Gix ...\n");
312      TWdGixItemV ResItemV; WdGix->Search(QueryStr, ResItemV);
313      printf("  Weighting %d hits ...\n", ResItemV.Len());
314      TWgtWdGixItemKdV FullWgtItemV(ResItemV.Len(), 0);
315      const bool CheckMnDateP = MnDate.IsDef();
316      const bool CheckMxDateP = MxDate.IsDef();
317      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
318          const TWdGixItem& Item = ResItemV[ItemN];
319          TTm DateTime = WdGixMDS->GetDateTTm(Item.GetBlobPt());
320          if (CheckMnDateP && DateTime < MnDate) { continue; }
321          if (CheckMxDateP && DateTime > MxDate) { continue; }
322          const double Wgt = RankFun(DateTime, Item.GetWgt(), Item.GetWdPos(),
323              Item.IsTitle(), Item.IsNmObj(), Item.IsAnchor(), Item.IsEmph());
324          FullWgtItemV.Add(TWgtWdGixItemKd(Wgt, Item));
325      }
326      printf("  Filtering ...\n");
327      if (Grouping != wgbgNone) {
328          TWgtWdGixItemKdV TmpWgtItemV;
329          Filter(FullWgtItemV, Grouping, TmpWgtItemV);
330          FullWgtItemV = TmpWgtItemV;
331      }
332      printf("  Sorting %d hits ...\n", FullWgtItemV.Len());
333      TWgtWdGixItemKdV WgtItemV;
334      if (Docs == -1) {
335          WgtItemV = FullWgtItemV;
336      } else if (ResItemV.Len() >= (Docs + Offset)) {
337          WgtItemV = FullWgtItemV;
338          WgtItemV.Sort(false); WgtItemV.Trunc(Docs + Offset);
339          WgtItemV.Sort(true); WgtItemV.Trunc(Docs);
340      } else if (ResItemV.Len() > Offset) {
341          WgtItemV = FullWgtItemV; WgtItemV.Sort(true);
342          WgtItemV.Trunc(FullWgtItemV.Len() - Offset);
343      } else {
344      }
345      WgtItemV.Sort(false);
346      printf("  Loading content for %d hits ...\n", WgtItemV.Len());
347      PWdGixRSet RSet = TWdGixRSet::New(
348          QueryStr, FullWgtItemV.Len(), Offset);
349      for (int ItemN = 0; ItemN < WgtItemV.Len(); ItemN++) {
350          const TWdGixItem& Item = WgtItemV[ItemN].Dat;
351          TBlobPt DocBlobPt = Item.GetBlobPt();
352          TStr DocTitle, DocStr; TStrV CatNmV;
353          GetDoc(DocBlobPt, DocTitle, DocStr, CatNmV);
354          TTm DateTime = WdGixMDS->GetDateTTm(DocBlobPt);
355          RSet->AddDoc(DocTitle, DocStr, CatNmV, DateTime);
356      }
357      printf("  Done\n");
358      return RSet;
359  }
360  void TWdGixBs::AddReuters(const TStr& XmlFNm) {
361      PXmlDoc Doc=TXmlDoc::LoadTxt(XmlFNm);
362      TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
363      TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
364      TChA DocChA; DocChA += "<doc>";
365      TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
366      DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
367      DocChA += "<body>";
368      TStr DocHeadline = Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
369      DocChA += "<p><em>"; DocChA += TXmlDoc::GetXmlStr(DocHeadline); DocChA += "</em></p>\n";
370      TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
371      for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
372          TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
373          TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("enamex", NmObjTokV);
374          for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
375              TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
376              ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
377          }
378          DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
379      }
380      DocChA += "</body></doc>";
381      TStrV CatNmV;
382      TXmlTokV CdsTokV; Doc->GetTagTokV("newsitem|metadata|codes", CdsTokV);
383      for (int CdsTokN = 0; CdsTokN < CdsTokV.Len(); CdsTokN++){
384          PXmlTok CdsTok = CdsTokV[CdsTokN];
385          TXmlTokV CdTokV; CdsTok->GetTagTokV("code", CdTokV);
386          if (CdsTok->GetArgVal("class") == "bip:topics:1.0"){
387              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
388                  TStr CdNm = CdTokV[CdTokN]->GetArgVal("code");
389                  CatNmV.AddMerged(CdNm);
390              }
391          } else if (CdsTok->GetArgVal("class")=="bip:countries:1.0"){
392              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
393                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
394                  CatNmV.AddMerged(CdNm);
395              }
396          } else if (CdsTok->GetArgVal("class")=="bip:industries:1.0"){
397              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
398                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
399                  CatNmV.AddMerged(CdNm);
400              }
401          } else { Fail; }
402      }
403      AddDoc(DocTitle, DocChA, CatNmV, DateTm);
404  }
405  void TWdGixBs::IndexReuters(const TStr& FPath) {
406      PNotify Notify = TStdNotify::New();
407      Notify->OnStatus("Loading Reuters documents from " + FPath + " ...\n");
408      TFFile FFile(FPath, ".xml", true);
409      TStr XmlFNm; int Files = 0;
410      while (FFile.Next(XmlFNm)) {
411          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm); Files++; }
412          if (Files % 1000 == 0) { Notify->OnStatus(TStr::Fmt("F:%d\r", Files)); }
413      }
414      Notify->OnStatus(TStr::Fmt("F:%d\n", Files));
415  }
416  void TWdGixBs::IndexNmEnBs(const TStr& FNm) {
417      PNotify Notify = TStdNotify::New();
418      Notify->OnStatus("Loading name-entitites from " + FNm + " ...\n");
419      PNmEnBs NmEnBs = TNmEnBs::LoadBin(FNm, true);
420      int NmEnKeyId = NmEnBs->GetFFirstNmEn();
421      int NmEnN = 0; const int NmEns = NmEnBs->GetNmEns();
422      while (NmEnBs->GetFNextNmEn(NmEnKeyId)) {
423          if (NmEnN > 100000) { break; }
424          if (NmEnN % 1000 == 0) { Notify->OnStatus(TStr::Fmt("N:%d/%d\r", NmEnN, NmEns)); }
425          TStr NmEnStr = NmEnBs->GetNmEnStr(NmEnKeyId);
426          IAssertR(NmEnBs->IsNmEn(NmEnStr), NmEnStr);
427          THash<TUInt, TChA> DateIntToCtxH; THash<TUInt, TInt> DateIntToCountH;
428          const TIntV& NmEnCtxIdV = NmEnBs->GetCtxIdV(NmEnKeyId);
429          for (int CtxIdN = 0; CtxIdN < NmEnCtxIdV.Len(); CtxIdN++) {
430              const int CtxId = NmEnCtxIdV[CtxIdN];
431              TStr NmEnCtxStr = NmEnBs->GetCtxStr(CtxId);
432              TTm NmEnCtxTm = NmEnBs->GetCtxTm(CtxId);
433              const uint DateInt = TTm::GetDateIntFromTm(NmEnCtxTm);
434              DateIntToCtxH.AddDat(DateInt) += NmEnCtxStr;
435              DateIntToCountH.AddDat(DateInt)++;
436          }
437          int CtxKeyId = DateIntToCtxH.FFirstKeyId();
438          while (DateIntToCtxH.FNextKeyId(CtxKeyId)) {
439              const int DateInt = DateIntToCtxH.GetKey(CtxKeyId);
440              TTm CtxDate = TTm::GetTmFromDateTimeInt(DateInt);
441              TStr CtxStr = DateIntToCtxH[CtxKeyId];
442              const uchar Wgt = uchar(DateIntToCountH.GetDat(DateInt).Val);
443              AddDoc(NmEnStr, CtxStr, TStrV(), CtxDate, Wgt);
444          }
445          NmEnN++;
446      }
447      Notify->OnStatus(TStr::Fmt("N:%d/%d", NmEnN, NmEns));
448  }
449  void TWdGixBs::IndexNyt(const TStr& XmlFNm) {
450      PNotify Notify = TStdNotify::New();
451      Notify->OnStatus("Loading NYT documents from " + XmlFNm + " ...\n");
452      PSIn SIn = TFIn::New(XmlFNm); int Docs = 0;
453      TStr LastTitle = "";
454      forever {
455          if (Docs % 1000 == 0) { Notify->OnStatus(TStr::Fmt("Docs: %d\r", Docs)); }
456          PXmlDoc Doc = TXmlDoc::LoadTxt(SIn); Docs++;
457          if (!Doc->IsOk()) { printf("%s - %s\n", LastTitle.CStr(), Doc->GetMsgStr().CStr()); break; }
458          TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
459          TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
460          TChA DocChA; DocChA += "<doc>";
461          TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
462          DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
463          DocChA += "<body>";
464          TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
465          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
466              TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
467              TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("ent", NmObjTokV);
468              for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
469                  TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
470                  ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
471              }
472              DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
473          }
474          DocChA += "</body></doc>";
475          AddDoc(DocTitle, DocChA, TStrV(), DateTm);
476          LastTitle = DocTitle;
477      }
478      Notify->OnStatus(TStr::Fmt("Docs: %d", Docs));
479  }
480  TSearchTopics::TSearchTopics(PWdGixRSet RSet, const int& Topics) {
481      PBowDocBs BowDocBs = RSet->GenBowDocBs();
482      TRnd Rnd(1);
483      PBowDocPart BowDocPart = TBowClust::GetKMeansPart(
484          TNullNotify::New(), BowDocBs, TBowSim::New(bstCos), Rnd,
485          Topics, 1, 10, 1, bwwtLogDFNrmTFIDF, 0.0, 0);
486      TopicV.Gen(Topics, 0);
487      TIntH FrameH; THash<TInt, TIntH> FrameTopicHH;
488      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
489          PBowDocPartClust Clust = BowDocPart->GetClust(ClustN);
490          TStr TopicNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 3, 1, ", ", false, false);
491          TopicV.Add(TopicNm);
492          for (int DocN = 0; DocN < Clust->GetDocs(); DocN++) {
493              const int DocId = Clust->GetDId(DocN);
494              TTm DocDate = RSet->GetDocDateTime(DocId);
495              const uint FrameId = TTm::GetYearIntFromTm(DocDate);
496              FrameH.AddDat(FrameId)++;
497              FrameTopicHH.AddDat(FrameId).AddDat(ClustN)++;
498          }
499      }
500      const int Frames = FrameH.Len();
501      FrameV.Gen(Frames, 0);
502      TopicFrameFqVV.Gen(Topics, Frames); TopicFrameFqVV.PutAll(0.0);
503      FrameH.SortByKey(); int FrameKeyId = FrameH.FFirstKeyId();
504      while (FrameH.FNextKeyId(FrameKeyId)) {
505          int FrameId = FrameH.GetKey(FrameKeyId);
506          TTm FrameDate = TTm::GetTmFromDateTimeInt(FrameId);
507          TStr FrameNm = TStr::Fmt("%4d", FrameDate.GetYear());
508          const int FrameN = FrameV.Add(FrameNm);
509          const TIntH& TopicH = FrameTopicHH.GetDat(FrameId);
510          int TopicKeyId = TopicH.FFirstKeyId(); int CountSum = 0;
511          while (TopicH.FNextKeyId(TopicKeyId)) {
512              const int TopicN = TopicH.GetKey(TopicKeyId);
513              int TopicCount = TInt::Abs(TopicH.GetDat(TopicKeyId)) > 1000 ?
514                  0 : TopicH.GetDat(TopicKeyId)();
515              CountSum += TopicCount;
516              const double Fq = double(CountSum); 
517              TopicFrameFqVV(TopicN, FrameN) = Fq;
518          }
519      }
520  }
521  TTrGixItem::TTrGixItem(const TBlobPt& BlobPt, const int& _SubjectId,
522      const int& _PredicatId, const int& _ObjectId, const int& _WdId,
523      const uchar& Type, const uchar& Pos, const bool& Full, const bool& Stem,
524      const uchar& Hyper): Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()),
525          SubjectId(_SubjectId), PredicatId(_PredicatId), ObjectId(_ObjectId), WdId(_WdId) {
526      SetWordInfo(Type, Pos, Full, Stem, Hyper);
527      ClrMergeInfo();
528  }
529  TTrGixItem::TTrGixItem(TSIn& SIn) {
530      SIn.Load(Seg); SIn.Load(Addr);
531      SIn.Load(SubjectId);
532      SIn.Load(PredicatId);
533      SIn.Load(ObjectId);
534      SIn.Load(WdId);
535      SIn.Load(WdInfo);
536      ClrMergeInfo();
537  }
538  void TTrGixItem::Save(TSOut& SOut) const {
539      SOut.Save(Seg); SOut.Save(Addr);
540      SOut.Save(SubjectId);
541      SOut.Save(PredicatId);
542      SOut.Save(ObjectId);
543      SOut.Save(WdId);
544      SOut.Save(WdInfo);
545  }
546  bool TTrGixItem::operator==(const TTrGixItem& Item) const {
547      return ((Seg==Item.Seg)&&(Addr==Item.Addr)&&
548          (SubjectId==Item.SubjectId)&&
549          (PredicatId==Item.PredicatId)&&
550          (ObjectId==Item.ObjectId));
551  }
552  bool TTrGixItem::operator<(const TTrGixItem& Item) const {
553      return (Seg<Item.Seg) ||
554          ((Seg==Item.Seg)&&(Addr<Item.Addr)) ||
555          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId<Item.SubjectId)) ||
556          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId<Item.PredicatId)) ||
557          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId==Item.PredicatId)&&(ObjectId<Item.ObjectId));
558  }
559  void TTrGixItem::SetWordInfo(const uchar& Type, const uchar& Pos,
560          const bool& Full, const bool& Stem, const uchar& Hyper) {
561      TTrGixItemWdInfo Info;
562      Info.Short = 0;
563      Info.Bits.Type = Type;
564      Info.Bits.Pos = Type;
565      Info.Bits.Full = Full ? 1 : 0;
566      Info.Bits.Stem = Stem ? 1 : 0;
567      Info.Bits.Hyper = Hyper;
568      WdInfo = Info.Short;
569  }
570  char TTrGix::SubjectType = 0;
571  char TTrGix::SubjectWdType = 1;
572  char TTrGix::SubjectAttrWdType = 2;
573  char TTrGix::SubjectStemType = 3;
574  char TTrGix::SubjectAttrStemType = 4;
575  char TTrGix::PredicatType = 5;
576  char TTrGix::PredicatWdType = 6;
577  char TTrGix::PredicatAttrWdType = 7;
578  char TTrGix::PredicatStemType = 8;
579  char TTrGix::PredicatAttrStemType = 9;
580  char TTrGix::ObjectType = 10;
581  char TTrGix::ObjectWdType = 11;
582  char TTrGix::ObjectAttrWdType = 12;
583  char TTrGix::ObjectStemType = 13;
584  char TTrGix::ObjectAttrStemType = 14;
585  void TTrGix::AddTrPart(const int& FullId, const char& Type, const int& SubjectId,
586          const int& PredicatId, const int& ObjectId, const TBlobPt& BlobPt) {
587      Gix->AddItem(TTrGixKey(FullId, Type),
588          TTrGixItem(BlobPt, SubjectId, PredicatId,
589              ObjectId, FullId, Type, 0, true, false, 0));
590  }
591  void TTrGix::AddTrPart(const TIntPrV& IdPrV, const char& WdType, const char& StemType,
592          const int& SubjectId, const int& PredicatId, const int& ObjectId,
593          const TBlobPt& BlobPt) {
594      for (int IdPrN = 0; IdPrN < IdPrV.Len(); IdPrN++) {
595          const int WdId = IdPrV[IdPrN].Val1;
596          Gix->AddItem(TTrGixKey(WdId, WdType),
597              TTrGixItem(BlobPt, SubjectId, PredicatId,
598                  ObjectId, WdId, WdType, IdPrN, false, false, 0));
599          const int StemId = IdPrV[IdPrN].Val2;
600          Gix->AddItem(TTrGixKey(StemId, StemType),
601              TTrGixItem(BlobPt, SubjectId, PredicatId,
602                  ObjectId, StemId, StemType, IdPrN, false, true, 0));
603      }
604  }
605  TTrGix::PTGixExpItem TTrGix::GetExactExp(const TStr& Str, const char& Type) {
606      TTrGixKey FullTrKey = TTrGixKey(GetWordId(Str, false), Type);
607      return TTGixExpItem::NewItem(FullTrKey);
608  }
609  TTrGix::PTGixExpItem TTrGix::GetPartExp(const TStr& Str, const char& WdType, const char& StemType) {
610      TIntPrV WordStemIdV; GetWordIdV(Str, WordStemIdV, false);
611      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
612      for (int WordStemIdN = 0; WordStemIdN < WordStemIdV.Len(); WordStemIdN++) {
613          TTrGixKey WdKey(WordStemIdV[WordStemIdN].Val1, WdType);
614          TTrGixKey StemKey(WordStemIdV[WordStemIdN].Val2, StemType);
615          PTGixExpItem ExpItem = TTGixExpItem::NewOr(
616              TTGixExpItem::NewItem(WdKey), TTGixExpItem::NewItem(StemKey));
617          if (Exp->IsEmpty()) { Exp = ExpItem; }
618          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
619      }
620      return Exp;
621  }
622  TTrGix::TTrGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
623      FPath = _FPath; FAccess = _FAccess;
624      Gix = TTGix::New(TGixConst::TrGixFNm, FPath, FAccess, CacheSize);
625      if (FAccess == faCreate) {
626          Stemmer = TStemmer::New(stmtPorter, true);
627      } else {
628          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
629          TFIn FIn(TrGixDatFNm);
630          WordH.Load(FIn);
631          Stemmer = TStemmer::Load(FIn);
632      }
633  }
634  TTrGix::~TTrGix() {
635      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
636          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
637          TFOut FOut(TrGixDatFNm);
638          WordH.Save(FOut);
639          Stemmer->Save(FOut);
640      }
641  }
642  int TTrGix::GetWordId(const TStr& WordStr, const bool& AddIfNotExistP) {
643      if (WordStr.Empty()) { return -1; }
644      if (AddIfNotExistP) { return WordH.AddKey(WordStr.GetUc()); }
645      else { return WordH.GetKeyId(WordStr.GetUc()); }
646  }
647  inline TStr TTrGix::GetWordStr(const int& WId) const {
648      return WId != -1 ? WordH.GetKey(WId) : "";
649  }
650  void TTrGix::GetWordIdV(const TStr& Str,
651          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
652      PSIn HtmlSIn = TStrIn::New(Str);
653      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
654      while (HtmlLx.Sym != hsyEof) {
655          if (HtmlLx.Sym == hsyStr) {
656              const TStr WordStr = HtmlLx.UcChA;
657              const int WordId = GetWordId(WordStr, AddIfNotExistP);
658              const int StemId = GetWordId(Stemmer->GetStem(WordStr), AddIfNotExistP);
659              WordStemIdV.Add(TIntPr(WordId, StemId));
660          }
661          HtmlLx.GetSym();
662      }
663  }
664  void TTrGix::GetWordIdV(const TStrV& WordStrV,
665          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
666      for (int WordStrN = 0; WordStrN < WordStrV.Len(); WordStrN++) {
667          GetWordIdV(WordStrV[WordStrN], WordStemIdV, AddIfNotExistP);
668      }
669  }
670  void TTrGix::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
671          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
672          const TStrV& ObjectAttrV, const TBlobPt& BlobPt) {
673      const int SubjectId = GetWordId(SubjectStr, true);
674      const int PredicatId = GetWordId(PredicatStr, true);
675      const int ObjectId = GetWordId(ObjectStr, true);
676      AddTrPart(SubjectId, SubjectType, SubjectId, PredicatId, ObjectId, BlobPt);
677      AddTrPart(PredicatId, PredicatType, SubjectId, PredicatId, ObjectId, BlobPt);
678      AddTrPart(ObjectId, ObjectType, SubjectId, PredicatId, ObjectId, BlobPt);
679      TIntPrV SubjectWIdSIdV; GetWordIdV(SubjectStr, SubjectWIdSIdV, true);
680      TIntPrV SubjectAttrWIdSIdV; GetWordIdV(SubjectAttrV, SubjectAttrWIdSIdV, true);
681      TIntPrV PredicatWIdSIdV; GetWordIdV(PredicatStr, PredicatWIdSIdV, true);
682      TIntPrV PredicatAttrWIdSIdV; GetWordIdV(PredicatAttrV, PredicatAttrWIdSIdV, true);
683      TIntPrV ObjectWIdSIdV; GetWordIdV(ObjectStr, ObjectWIdSIdV, true);
684      TIntPrV ObjectAttrWIdSIdV; GetWordIdV(ObjectAttrV, ObjectAttrWIdSIdV, true);
685      AddTrPart(SubjectWIdSIdV, SubjectWdType, SubjectStemType,
686          SubjectId, PredicatId, ObjectId, BlobPt);
687      AddTrPart(SubjectAttrWIdSIdV, SubjectAttrWdType, SubjectAttrStemType,
688          SubjectId, PredicatId, ObjectId, BlobPt);
689      AddTrPart(PredicatWIdSIdV, PredicatWdType, PredicatStemType,
690          SubjectId, PredicatId, ObjectId, BlobPt);
691      AddTrPart(PredicatAttrWIdSIdV, PredicatAttrWdType, PredicatAttrStemType,
692          SubjectId, PredicatId, ObjectId, BlobPt);
693      AddTrPart(ObjectWIdSIdV, ObjectWdType, ObjectStemType,
694          SubjectId, PredicatId, ObjectId, BlobPt);
695      AddTrPart(ObjectAttrWIdSIdV, ObjectAttrWdType, ObjectAttrStemType,
696          SubjectId, PredicatId, ObjectId, BlobPt);
697  }
698  bool TTrGix::SearchExact(const TStr& SubjectStr, const TStr& PredicatStr,
699          const TStr& ObjectStr, TTrGixItemV& ResItemV) {
700      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
701      if (!SubjectStr.Empty()) {
702          PTGixExpItem ExpItem = GetExactExp(SubjectStr, SubjectType);
703          if (Exp->IsEmpty()) { Exp = ExpItem; }
704          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
705      }
706      if (!PredicatStr.Empty()) {
707          PTGixExpItem ExpItem = GetExactExp(PredicatStr, PredicatType);
708          if (Exp->IsEmpty()) { Exp = ExpItem; }
709          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
710      }
711      if (!ObjectStr.Empty()) {
712          PTGixExpItem ExpItem = GetExactExp(ObjectStr, ObjectType);
713          if (Exp->IsEmpty()) { Exp = ExpItem; }
714          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
715      }
716      return Exp->Eval(Gix, ResItemV);
717  }
718  bool TTrGix::SearchPart(const TStr& SubjectStr, const TStr& PredicatStr,
719          const TStr& ObjectStr, TTrGixItemV& ResItemV, const bool& IncExactP) {
720      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
721      if (!SubjectStr.Empty()) {
722          PTGixExpItem ExpItem = GetPartExp(SubjectStr, SubjectWdType, SubjectStemType);
723          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(SubjectStr, SubjectType), ExpItem); }
724          if (Exp->IsEmpty()) { Exp = ExpItem; }
725          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
726      }
727      if (!PredicatStr.Empty()) {
728          PTGixExpItem ExpItem = GetPartExp(PredicatStr, PredicatWdType, PredicatStemType);
729          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(PredicatStr, PredicatType), ExpItem); }
730          if (Exp->IsEmpty()) { Exp = ExpItem; }
731          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
732      }
733      if (!ObjectStr.Empty()) {
734          PTGixExpItem ExpItem = GetPartExp(ObjectStr, ObjectWdType, ObjectStemType);
735          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(ObjectStr, ObjectType), ExpItem); }
736          if (Exp->IsEmpty()) { Exp = ExpItem; }
737          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
738      }
739      return Exp->Eval(Gix, ResItemV);
740  }
741  void TTrGixRSet::AddTr(const TStrTr& TrStr, const TBlobPtV& TrAttrBlobPtV) {
742      TrStrV.Add(TrStr);
743      TrAttrBlobPtVV.Add(TrAttrBlobPtV);
744  }
745  void TTrGixRSet::GetSubjectV(TStrIntKdV& SubjectStrWgtV) {
746      TIntStrKdV SubjectWgtStrV;
747      for (int TrN = 0; TrN < GetTrs(); TrN++) {
748          const TStr& SubjectStr = TrStrV[TrN].Val1;
749          const int Wgt = GetTrCount(TrN);
750          SubjectWgtStrV.Add(TIntStrKd(Wgt, SubjectStr));
751      }
752      SubjectWgtStrV.Sort(false);
753      GetSwitchedKdV<TInt, TStr>(SubjectWgtStrV, SubjectStrWgtV);
754  }
755  void TTrGixRSet::GetPredicatV(TStrIntKdV& PredicatStrWgtV) {
756      TIntStrKdV PredicatWgtStrV;
757      for (int TrN = 0; TrN < GetTrs(); TrN++) {
758          const TStr& PredicatStr = TrStrV[TrN].Val2;
759          const int Wgt = GetTrCount(TrN);
760          PredicatWgtStrV.Add(TIntStrKd(Wgt, PredicatStr));
761      }
762      PredicatWgtStrV.Sort(false);
763      GetSwitchedKdV<TInt, TStr>(PredicatWgtStrV, PredicatStrWgtV);
764  }
765  void TTrGixRSet::GetObjectV(TStrIntKdV& ObjectStrWgtV) {
766      TIntStrKdV ObjectWgtStrV;
767      for (int TrN = 0; TrN < GetTrs(); TrN++) {
768          const TStr& ObjectStr = TrStrV[TrN].Val3;
769          const int Wgt = GetTrCount(TrN);
770          ObjectWgtStrV.Add(TIntStrKd(Wgt, ObjectStr));
771      }
772      ObjectWgtStrV.Sort(false);
773      GetSwitchedKdV<TInt, TStr>(ObjectWgtStrV, ObjectStrWgtV);
774  }
775  void TTrGixRSet::PrintRes(const bool& PrintSentsP, PNotify Notify) const {
776      printf("Query:\n");
777      printf("  Subject: '%s'\n", GetSubjectStr().CStr());
778      printf("  Predicat: '%s'\n", GetPredicatStr().CStr());
779      printf("  Object: '%s'\n", GetObjectStr().CStr());
780      printf("Displaying: %d - %d (All hits: %d)\n",
781          GetOffset()+1, Offset.Val+GetTrs()+1, GetAllTrs());
782      for (int TrN = 0; TrN < GetTrs(); TrN++) {
783          printf("%d. [%s <- %s -> %s], (Support:%d)\n", TrN+GetOffset()+1,
784              GetTrSubjectStr(TrN).CStr(), GetTrPredicatStr(TrN).CStr(),
785              GetTrObjectStr(TrN).CStr(), GetTrCount(TrN));
786      }
787  }
788  void TTrGixBs::GetAttrV(PXmlTok XmlTok, TStrV& AttrV) {
789      TXmlTokV AttrTokV; XmlTok->GetTagTokV("attrib", AttrTokV);
790      for (int AttrTokN = 0; AttrTokN < AttrTokV.Len(); AttrTokN++) {
791          PXmlTok AttrTok = AttrTokV[AttrTokN];
792          AttrV.Add(AttrTok->GetStrArgVal("word"));
793          GetAttrV(AttrTok, AttrV);
794      }
795  }
796  TTrGixBs::TTrGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
797      FPath = _FPath; FAccess = _FAccess;
798      TStr TrGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDocBsFNm;
799      DocBBs = TMBlobBs::New(TrGixDocBsFNm, FAccess);
800      TStr TrGixSentBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixSentBsFNm;
801      SentBBs = TMBlobBs::New(TrGixSentBsFNm, FAccess);
802      TStr TrGixTrAttrBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixTrAttrBsFNm;
803      TrAttrBBs = TMBlobBs::New(TrGixTrAttrBsFNm, FAccess);
804      TrGix = TTrGix::New(FPath, FAccess, CacheSize);
805  }
806  TTrGixBs::~TTrGixBs() {
807      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
808      }
809  }
810  TBlobPt TTrGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr, const TStrV& CatNmV) {
811      TMOut DocMOut;
812      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
813      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
814      return DocBlobPt;
815  }
816  TBlobPt TTrGixBs::AddSent(const TStr& SentStr) {
817      TMOut SentMOut; SentStr.Save(SentMOut);
818      TBlobPt SentBlobPt = SentBBs->PutBlob(SentMOut.GetSIn());
819      return SentBlobPt;
820  }
821  TBlobPt TTrGixBs::AddTrAttr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
822          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
823          const TStrV& ObjectAttrV, const TBlobPt& SentBlobPt, const TBlobPt& DocBlobPt) {
824      TMOut TrAttrMOut;
825      SubjectStr.Save(TrAttrMOut); SubjectAttrV.Save(TrAttrMOut);
826      PredicatStr.Save(TrAttrMOut); PredicatAttrV.Save(TrAttrMOut);
827      ObjectStr.Save(TrAttrMOut); ObjectAttrV.Save(TrAttrMOut);
828      SentBlobPt.Save(TrAttrMOut); DocBlobPt.Save(TrAttrMOut);
829      TBlobPt TrAttrBlobPt = TrAttrBBs->PutBlob(TrAttrMOut.GetSIn());
830      return TrAttrBlobPt;
831  }
832  void TTrGixBs::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
833          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
834          const TStrV& ObjectAttrV, const TBlobPt& TrAttrBlobPt) {
835      TrGix->AddTr(SubjectStr, SubjectAttrV, PredicatStr,
836          PredicatAttrV, ObjectStr, ObjectAttrV, TrAttrBlobPt);
837  }
838  void TTrGixBs::GetDoc(const TBlobPt& DocBlobPt, TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
839      PSIn SIn = DocBBs->GetBlob(DocBlobPt);
840      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
841  }
842  TStr TTrGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
843      PSIn SIn = DocBBs->GetBlob(BlobPt);
844      TStr DocTitle; DocTitle.Load(*SIn);
845      return DocTitle;
846  }
847  TStr TTrGixBs::GetDocStr(const TBlobPt& BlobPt) const {
848      PSIn SIn = DocBBs->GetBlob(BlobPt);
849      {TStr DocTitle; DocTitle.Load(*SIn);}
850      TStr DocStr; DocStr.Load(*SIn);
851      return DocStr;
852  }
853  TStrV TTrGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
854      PSIn SIn = DocBBs->GetBlob(BlobPt);
855      {TStr DocTitle; DocTitle.Load(*SIn);}
856      {TStr DocStr; DocStr.Load(*SIn);}
857      TStrV CatNmV; CatNmV.Load(*SIn);
858      return CatNmV;
859  }
860  TStr TTrGixBs::GetSentStr(const TBlobPt& SentBlobPt) {
861      PSIn SIn = SentBBs->GetBlob(SentBlobPt);
862      return TStr(*SIn);
863  }
864  void TTrGixBs::GetTrAttr(const TBlobPt& TrAttrBlobPt, TStr& SubjectStr,
865          TStrV& SubjectAttrV, TStr& PredicatStr, TStrV& PredicatAttrV,
866          TStr& ObjectStr, TStrV& ObjectAttrV, TBlobPt& SentBlobPt,
867          TBlobPt& DocBlobPt) {
868      PSIn SIn = TrAttrBBs->GetBlob(TrAttrBlobPt);
869      SubjectStr.Load(*SIn); SubjectAttrV.Load(*SIn);
870      PredicatStr.Load(*SIn); PredicatAttrV.Load(*SIn);
871      ObjectStr.Load(*SIn); ObjectAttrV.Load(*SIn);
872      SentBlobPt = TBlobPt(*SIn); DocBlobPt = TBlobPt(*SIn);
873  }
874  PTrGixRSet TTrGixBs::SearchTr(const TStr& SubjectStr, const TStr& PredicatStr,
875          const TStr& ObjectStr, TTrGixRankFun& RankFun, const int& Docs,
876          const int& Offset, const bool& ExactP) {
877      TTrGixItemV ResItemV;
878      if (ExactP) { TrGix->SearchExact(SubjectStr, PredicatStr, ObjectStr, ResItemV); }
879      else { TrGix->SearchPart(SubjectStr, PredicatStr, ObjectStr, ResItemV, true); }
880      THash<TIntTr, TIntV> TrToItemVH;
881      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
882          const TTrGixItem& Item = ResItemV[ItemN];
883          TrToItemVH.AddDat(Item.GetIdTr()).Add(ItemN);
884      }
885      TFltIntKdV FullWgtTrKeyIdV;
886      int TrKeyId = TrToItemVH.FFirstKeyId();
887      while (TrToItemVH.FNextKeyId(TrKeyId)) {
888          const double Wgt = RankFun(TrToItemVH[TrKeyId].Len());
889          FullWgtTrKeyIdV.Add(TFltIntKd(Wgt, TrKeyId));
890      }
891      TFltIntKdV WgtTrKeyIdV;
892      if (Docs == -1) {
893          WgtTrKeyIdV = FullWgtTrKeyIdV;
894      } else if (ResItemV.Len() >= (Docs + Offset)) {
895          WgtTrKeyIdV = FullWgtTrKeyIdV;
896          WgtTrKeyIdV.Sort(false); WgtTrKeyIdV.Trunc(Docs + Offset);
897          WgtTrKeyIdV.Sort(true); WgtTrKeyIdV.Trunc(Docs);
898      } else if (ResItemV.Len() > Offset) {
899          WgtTrKeyIdV = FullWgtTrKeyIdV; WgtTrKeyIdV.Sort(true);
900          WgtTrKeyIdV.Trunc(FullWgtTrKeyIdV.Len() - Offset);
901      } else {
902      }
903      WgtTrKeyIdV.Sort(false);
904      PTrGixRSet RSet = TTrGixRSet::New(SubjectStr, PredicatStr,
905          ObjectStr, FullWgtTrKeyIdV.Len(), Offset);
906      for (int TrN = 0; TrN < WgtTrKeyIdV.Len(); TrN++) {
907          const int TrKeyId = WgtTrKeyIdV[TrN].Dat;
908          const TIntTr& WIdTr = TrToItemVH.GetKey(TrKeyId);
909          const TIntV& ItemV = TrToItemVH[TrKeyId];
910          TStr SubjectStr = TrGix->GetWordStr(WIdTr.Val1);
911          TStr PredicatStr = TrGix->GetWordStr(WIdTr.Val2);
912          TStr ObjectStr = TrGix->GetWordStr(WIdTr.Val3);
913          TStrTr TrStr(SubjectStr, PredicatStr, ObjectStr);
914          TBlobPtV TrAttrBlobPtV;
915          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
916              const TTrGixItem& Item = ResItemV[ItemV[ItemN]];
917              TBlobPt TrAttrBlobPt = Item.GetBlobPt();
918              TrAttrBlobPtV.Add(TrAttrBlobPt);
919          }
920          RSet->AddTr(TrStr, TrAttrBlobPtV);
921      }
922      return RSet;
923  }
924  void TTrGixBs::AddReuters(const TStr& XmlFNm, int& Trs, const PSOut& CsvOut) {
925      PNotify Notify = TStdNotify::New();
926      TBlobPt EmptyDocBlobPt = AddDoc("No full document text!");
927      PSIn XmlSIn = TFIn::New(XmlFNm);
928      TXmlDoc::SkipTopTag(XmlSIn);
929      PXmlDoc XmlDoc; int XmlDocs = 0;
930      forever{
931          if (Trs % 100 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", Trs)); }
932          XmlDocs++; XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
933          if (!XmlDoc->IsOk()) { break; }
934          PXmlTok TopTok = XmlDoc->GetTok();
935          if (TopTok->IsTag("sentence")){
936              TStr DocStr = ""; TBlobPt DocBlobPt = EmptyDocBlobPt;
937              TStr SentStr = TopTok->GetTagTok("originalSentence")->GetTokStr(false);
938              TBlobPt SentBlobPt = AddSent(SentStr);
939              TXmlTokV TrTokV; TopTok->GetTagTokV("triplet", TrTokV);
940              for (int TrTokN = 0; TrTokN < TrTokV.Len(); TrTokN++) {
941                  PXmlTok TrTok = TrTokV[TrTokN];
942                  TStr SubjectStr = TrTok->GetTagTok("subject")->GetStrArgVal("word");
943                  TStr PredicatStr = TrTok->GetTagTok("verb")->GetStrArgVal("word");
944                  TStr ObjectStr = TrTok->GetTagTok("object")->GetStrArgVal("word");
945                  TStrV SubjectAttrV; GetAttrV(TrTok->GetTagTok("subject"), SubjectAttrV);
946                  TStrV PredicatAttrV; GetAttrV(TrTok->GetTagTok("verb"), PredicatAttrV);
947                  TStrV ObjectAttrV; GetAttrV(TrTok->GetTagTok("object"), ObjectAttrV);
948                  TBlobPt TrAttrBlobPt = AddTrAttr(SubjectStr, SubjectAttrV,
949                      PredicatStr, PredicatAttrV, ObjectStr, ObjectAttrV,
950                      SentBlobPt, DocBlobPt);
951                  AddTr(SubjectStr, SubjectAttrV, PredicatStr, PredicatAttrV,
952                      ObjectStr, ObjectAttrV, TrAttrBlobPt);
953                  Trs++;
954                  if (!CsvOut.Empty()) {
955                      SubjectStr.DelChAll(','); CsvOut->PutStr(SubjectStr + ",");
956                      PredicatStr.DelChAll(','); CsvOut->PutStr(PredicatStr + ",");
957                      ObjectStr.DelChAll(','); CsvOut->PutStr(ObjectStr + ",");
958                      CsvOut->PutStr(TStr::Fmt("%u,", uint(SentBlobPt.GetSeg())));
959                      CsvOut->PutStr(TStr::Fmt("%u,", SentBlobPt.GetAddr()));
960                      CsvOut->PutStr(TStr::Fmt("%d,", SubjectAttrV.Len()));
961                      for (int AttrN = 0; AttrN < SubjectAttrV.Len(); AttrN++) {
962                          SubjectAttrV[AttrN].DelChAll(',');
963                          CsvOut->PutStr(SubjectAttrV[AttrN]);
964                          CsvOut->PutStr(",");
965                      }
966                      CsvOut->PutStr(TStr::Fmt("%d,", PredicatAttrV.Len()));
967                      for (int AttrN = 0; AttrN < PredicatAttrV.Len(); AttrN++) {
968                          PredicatAttrV[AttrN].DelChAll(',');
969                          CsvOut->PutStr(PredicatAttrV[AttrN]);
970                          CsvOut->PutStr(",");
971                      }
972                      CsvOut->PutStr(TStr::Fmt("%d,", ObjectAttrV.Len()));
973                      for (int AttrN = 0; AttrN < ObjectAttrV.Len(); AttrN++) {
974                          ObjectAttrV[AttrN].DelChAll(',');
975                          CsvOut->PutStr(ObjectAttrV[AttrN]);
976                          CsvOut->PutStr(",");
977                      }
978                      CsvOut->PutStr("-1"); CsvOut->PutLn();
979                  }
980              }
981          }
982      }
983      CsvOut->Flush();
984  }
985  void TTrGixBs::IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm, const int& MxTrs) {
986      PNotify Notify = TStdNotify::New();
987      Notify->OnStatus("Loading Reuters documents from " + XmlFPath + " ...\n");
988      TFFile FFile(XmlFPath, ".xml", true); TStr XmlFNm; int Files = 0, Trs = 0;
989      PSOut CsvOut; if (!CsvFNm.Empty()) { CsvOut = TFOut::New(CsvFNm); }
990      while (FFile.Next(XmlFNm) && ((MxTrs == -11)||(MxTrs > Trs))) {
991          Notify->OnStatus(TStr::Fmt("Loading %3d : %s ...", Files+1, XmlFNm.CStr()));
992          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm, Trs, CsvOut); Files++; }
993      }
994      Notify->OnStatus(TStr::Fmt("Triplets loaded: %d", Trs));
995  }
996  TMWdGixItem::TMWdGixItem(TSIn& SIn) {
997      SIn.Load(Seg); SIn.Load(Addr);
998      SIn.Load(WdFq); SIn.Load(DocWds);
999  }
1000  void TMWdGixItem::Save(TSOut& SOut) const {
1001      SOut.Save(Seg); SOut.Save(Addr);
1002      SOut.Save(WdFq); SOut.Save(DocWds);
1003  }
1004  inline bool TMWdGixItem::operator==(const TMWdGixItem& Item) const {
1005      return (Seg == Item.Seg) && (Addr == Item.Addr);
1006  }
1007  inline bool TMWdGixItem::operator<(const TMWdGixItem& Item) const {
1008      return (Seg < Item.Seg) || ((Seg == Item.Seg) && (Addr < Item.Addr));
1009  }
1010  void TMWdGixDefMerger::Union(TMWdGixItemV& DstV, const TMWdGixItemV& SrcV) const {
1011      TMWdGixItemV DstValV(TInt::GetMx(DstV.Len(), SrcV.Len()), 0);
1012      int ValN1 = 0; int ValN2 = 0;
1013      while ((ValN1<DstV.Len()) && (ValN2<SrcV.Len())){
1014          const TMWdGixItem& Val1 = DstV.GetVal(ValN1);
1015          const TMWdGixItem& Val2 = SrcV.GetVal(ValN2);
1016          if (Val1 < Val2) { DstValV.Add(Val1); ValN1++; }
1017          else if (Val1>Val2) { DstValV.Add(Val2); ValN2++; }
1018          else { DstValV.Add(TMWdGixItem(Val1, Val2)); ValN1++; ValN2++; }
1019      }
1020      for (int RestValN1=ValN1; RestValN1<DstV.Len(); RestValN1++){
1021          DstValV.Add(DstV.GetVal(RestValN1));}
1022      for (int RestValN2=ValN2; RestValN2<SrcV.Len(); RestValN2++){
1023          DstValV.Add(SrcV.GetVal(RestValN2));}
1024      DstV = DstValV;
1025  }
1026  void TMWdGixDefMerger::Def(const TInt& Key, TMWdGixItemV& ItemV) const  {
1027      const int WdDocFq = MWdGix->GetWdFq(Key);
1028      const int Docs = MWdGix->GetAllDocs();
1029      const double AvgDocWds = MWdGix->GetAvgDocWds();
1030      const int Items = ItemV.Len();
1031      for (int ItemN = 0; ItemN < Items; ItemN++) {
1032          TMWdGixItem& Item = ItemV[ItemN];
1033          const int WdFq = Item.GetWdFq();
1034          const int DocWds = Item.GetDocWds();
1035          const double Wgt = RankFun->WdRank(WdFq, DocWds, WdDocFq, Docs, AvgDocWds);
1036          Item.PutWgt(Wgt);
1037      }
1038  }
1039  TMWdGix::TMWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
1040      FPath = _FPath; FAccess = _FAccess;
1041      printf("Loading '%s' .. ", FPath.CStr());
1042      if (FAccess == faCreate) { printf("create .. "); }
1043      if (FAccess == faRdOnly) { printf("read-only .. "); }
1044      printf("Cache[%s]\n", TUInt64::GetMegaStr(CacheSize).CStr());
1045      MWGix = TMWGix::New(TGixConst::MWdGixFNm, FPath, FAccess, CacheSize);
1046      if (FAccess != faCreate) {
1047          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1048          TFIn FIn(MWdGixDatFNm);
1049          WordH.Load(FIn);
1050          AllDocs.Load(FIn);
1051          AllWords.Load(FIn);
1052      }
1053  }
1054  TMWdGix::~TMWdGix() {
1055      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1056          printf("Closing %s: docs=%d, words=%d\n",
1057              FPath.CStr(), AllDocs.Val, AllWords.Val);
1058          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1059          TFOut FOut(MWdGixDatFNm);
1060          WordH.Save(FOut);
1061          AllDocs.Save(FOut);
1062          AllWords.Save(FOut);
1063      }
1064  }
1065  void TMWdGix::AddHtml(const TStr& DocStr, const TBlobPt& BlobPt) {
1066      PSIn HtmlSIn = TStrIn::New(DocStr);
1067      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1068      TIntH DocWIdH; int DocWds = 0;
1069      while (HtmlLx.Sym != hsyEof) {
1070          if (HtmlLx.Sym == hsyStr) {
1071              TStr WordStr = HtmlLx.UcChA;
1072              const int WId = WordH.AddKey(WordStr);
1073              DocWIdH.AddDat(WId)++;
1074              DocWds++;
1075          }
1076          HtmlLx.GetSym();
1077      }
1078      int WdKeyId = DocWIdH.FFirstKeyId();
1079      while (DocWIdH.FNextKeyId(WdKeyId)) {
1080          const int WId = DocWIdH.GetKey(WdKeyId);
1081          const int WdFq = DocWIdH[WdKeyId];
1082          WordH[WId]++; 
1083          TMWdGixKey Key(WId);
1084          TMWdGixItem Item(BlobPt, WdFq, DocWds);
1085          MWGix->AddItem(Key, Item);
1086      }
1087      AllDocs++; AllWords += DocWds;
1088  }
1089  bool TMWdGix::Search(const TStr& QueryStr,
1090          TMWdGixItemV& ResItemV, const TMWdGixDefMerger& Merger) {
1091      PMWGixExpItem MWGixExp = TMWGixExpItem::NewEmpty();
1092      PSIn HtmlSIn = TStrIn::New(QueryStr);
1093      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1094      while (HtmlLx.Sym != hsyEof) {
1095          if (HtmlLx.Sym == hsyStr) {
1096              TStr WordStr = HtmlLx.UcChA;
1097              const int WId = WordH.GetKeyId(WordStr);
1098              if (WId != -1) {
1099                  PMWGixExpItem MWGixExpItem = TMWGixExpItem::NewItem(TMWdGixKey(WId));
1100                  if (MWGixExp->IsEmpty()) { MWGixExp = MWGixExpItem; }
1101                  else { MWGixExp = TMWGixExpItem::NewOr(MWGixExp, MWGixExpItem); }
1102              }
1103          }
1104          HtmlLx.GetSym();
1105      }
1106      return MWGixExp->Eval(MWGix, ResItemV, Merger);
1107  }
1108  TStr TMWdGixRSet::GetMainPara(const TStr& QueryStr, const TStr& FullStr) {
1109      PBowDocBs BowDocBs = TBowDocBs::New();
1110      BowDocBs->AddHtmlDoc("Query", TStrV(), QueryStr, false);
1111      TStrV ParaV; FullStr.SplitOnAllCh('\n', ParaV);
1112      if (ParaV.Empty()) { return ""; }
1113      for (int ParaN = 0; ParaN < ParaV.Len(); ParaN++) {
1114          BowDocBs->AddHtmlDoc("Doc" + TInt::GetStr(ParaN), TStrV(), ParaV[ParaN], false);
1115      }
1116      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
1117      PBowSpV QuerySpV = BowDocWgtBs->GetSpV(0); int MxParaN = 0;
1118      double MxParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(1));
1119      for (int ParaN = 1; ParaN < ParaV.Len(); ParaN++) {
1120          const double ParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(ParaN+1));
1121          if (ParaSim > MxParaSim) {
1122              MxParaSim = ParaSim;
1123              MxParaN = ParaN;
1124          }
1125      }
1126      return ParaV[MxParaN];
1127  }
1128  void TMWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1129          const TStr& DocLang, const TStrV& KeyWdV) {
1130      DocTitleV.Add(DocTitle);
1131      DocTitleV.Last().DelChAll('\n');
1132      DocTitleV.Last().DelChAll('\r');
1133      DocStrV.Add(GetMainPara(LangQueryH.GetDat(DocLang), DocStr));
1134      DocLangV.Add(DocLang);
1135      KeyWdVV.Add(KeyWdV);
1136  }
1137  void TMWdGixRSet::PrintRes(PNotify Notify) {
1138      const int Docs = GetDocs();
1139      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1140          AllDocs.Val, Docs, Docs + Offset.Val));
1141      for (int DocN = 0; DocN < Docs; DocN++) {
1142          TStr DocStr = DocTitleV[DocN] + " - " + DocStrV[DocN];
1143          DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
1144          Notify->OnStatus(TStr::Fmt("[%d:%s] %s ...", DocN+1,
1145              DocLangV[DocN].CStr(), DocStr.Left(60).CStr()));
1146      }
1147      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1148          AllDocs.Val, Docs, Docs + Offset.Val));
1149  }
1150  TStr TMWdGixRSet::GetWsXml(const TStrPrStrH& EurovocH) const {
1151      PXmlTok TopTok = TXmlTok::New("cca");
1152      TopTok->AddArg("allhits", GetAllDocs());
1153      for (int DocN = 0; DocN < GetDocs(); DocN++) {
1154          PXmlTok HitTok = TXmlTok::New("hit");
1155          HitTok->AddArg("rank", DocN+1);
1156          HitTok->AddArg("lang", DocLangV[DocN]);
1157          TStr Title = DocTitleV[DocN];
1158          if (Title.Len() > 100) { Title = Title.Left(100) + "..."; }
1159          TStr Snipet = DocStrV[DocN].Left(800);
1160          if (Snipet.Len() > 800) { Snipet = Snipet.Left(800) + "..."; }
1161          HitTok->AddSubTok(TXmlTok::New("title", Title));
1162          HitTok->AddSubTok(TXmlTok::New("snipet", Snipet));
1163          PXmlTok KeyWdTok = TXmlTok::New("keywords");
1164          const TStrV& KeyWdV = KeyWdVV[DocN]; int GoodKeyWds = 0;
1165          for (int KeyWdN = 0; KeyWdN < KeyWdV.Len(); KeyWdN++) {
1166              TStrPr KeyWd(QueryLang, KeyWdV[KeyWdN]);
1167              if (EurovocH.IsKey(KeyWd)) {
1168                  KeyWdTok->AddSubTok(TXmlTok::New("keyword", EurovocH.GetDat(KeyWd)));
1169                  GoodKeyWds++;
1170              }
1171          }
1172          HitTok->AddSubTok(KeyWdTok);
1173          if (GoodKeyWds == 0) { continue; }
1174          TopTok->AddSubTok(HitTok);
1175      }
1176      return TopTok->GetTokStr();
1177  }
1178  TMWdGixBs::TMWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& _CacheSize) {
1179      FPath = _FPath; FAccess = _FAccess; CacheSize = _CacheSize;
1180      TStr MWdGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDocBsFNm;
1181      DocBBs = TMBlobBs::New(MWdGixDocBsFNm, FAccess);
1182      if (FAccess != faCreate) {
1183          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1184          AlignPairBs = TAlignPairBs::LoadBin(MWdGixBsFNm);
1185          InitGixs(FAccess);
1186      }
1187  }
1188  TMWdGixBs::~TMWdGixBs() {
1189      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1190          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1191          AlignPairBs->SaveBin(MWdGixBsFNm);
1192      }
1193  }
1194  void TMWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1195          const TStr& DocLang, const TStrV& KeyWdV) {
1196      TMOut DocMOut;
1197      DocTitle.Save(DocMOut); DocStr.Save(DocMOut);
1198      DocLang.Save(DocMOut); KeyWdV.Save(DocMOut);
1199      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
1200      LangMWdGixH.GetDat(DocLang)->AddHtml(DocStr, DocBlobPt);
1201  }
1202  void TMWdGixBs::GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
1203          TStr& DocStr, TStr& DocLang, TStrV& KeyWdV) const {
1204      PSIn SIn = DocBBs->GetBlob(BlobPt);
1205      DocTitle.Load(*SIn); DocStr.Load(*SIn);
1206      DocLang.Load(*SIn); KeyWdV.Load(*SIn);
1207  }
1208  PMWdGixRSet TMWdGixBs::SearchDoc(const TStr& QueryStr, const TStr& QueryLang,
1209          const TStrV& TargetLangV, const int& Docs, const int& Offset,
1210          PMWdGixRankFun& RankFun) {
1211      if (!AlignPairBs->IsLang(QueryLang)) {
1212          return TMWdGixRSet::New(QueryStr, "", TStrStrH(), 0, 0); }
1213      const int Queries = TargetLangV.Len();
1214      printf("  Translationg %d queries ...\n", Queries);
1215      const int QueryLangId = AlignPairBs->GetLangId(QueryLang);
1216      TStrStrH LangQueryH;
1217      TWgtMWdGixIntItemKdV FullWgtLangItemV;
1218      for (int TargetLangN = 0; TargetLangN < Queries; TargetLangN++) {
1219          if (!AlignPairBs->IsLang(TargetLangV[TargetLangN])) { continue; }
1220          const TStr& TargetLang = TargetLangV[TargetLangN];
1221          const int TargetLangId = AlignPairBs->GetLangId(TargetLang);
1222          if (TargetLangId == QueryLangId) { continue; }
1223          TStr TargetQueryStr = AlignPairBs->MapQuery(
1224              AlignPairMap, QueryStr, QueryLangId, TargetLangId);
1225          LangQueryH.AddDat(TargetLang, TargetQueryStr);
1226          printf("  Query: '%s' -> '%s'\n", QueryStr.CStr(), TargetQueryStr.CStr());
1227          printf("  Loading from Gix ...\n");
1228          TMWdGixItemV LangResItemV;
1229          PMWdGix LangMWdGix = LangMWdGixH.GetDat(TargetLang);
1230          TMWdGixDefMerger LangMerger(LangMWdGix, RankFun);
1231          LangMWdGix->Search(TargetQueryStr, LangResItemV, LangMerger);
1232          double MxWgt = 0.0;
1233          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1234              const TMWdGixItem& Item = LangResItemV[ItemN];
1235              MxWgt = TFlt::GetMx(Item.GetWgt(), MxWgt);
1236          }
1237          printf("  MxWgt: %g\n", MxWgt);
1238          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1239              const TMWdGixItem& Item = LangResItemV[ItemN];
1240              const double Wgt = MxWgt > 0.0 ? Item.GetWgt() / MxWgt : 0.0;
1241              TMWdGixIntItemPr LangItemPr(TargetLangId, Item);
1242              FullWgtLangItemV.Add(TWgtMWdGixIntItemKd(Wgt, LangItemPr));
1243          }
1244      }
1245      FullWgtLangItemV.Sort(false);
1246      printf("  Sorting %d hits ...\n", FullWgtLangItemV.Len());
1247      TWgtMWdGixIntItemKdV WgtLangItemV;
1248      if (Docs == -1) {
1249          WgtLangItemV = FullWgtLangItemV;
1250      } else if (FullWgtLangItemV.Len() >= (Docs + Offset)) {
1251          WgtLangItemV = FullWgtLangItemV;
1252          WgtLangItemV.Sort(false); WgtLangItemV.Trunc(Docs + Offset);
1253          WgtLangItemV.Sort(true); WgtLangItemV.Trunc(Docs);
1254      } else if (FullWgtLangItemV.Len() > Offset) {
1255          WgtLangItemV = FullWgtLangItemV; WgtLangItemV.Sort(true);
1256          WgtLangItemV.Trunc(FullWgtLangItemV.Len() - Offset);
1257      } else {
1258      }
1259      WgtLangItemV.Sort(false);
1260      printf("  Loading content for %d hits ...\n", WgtLangItemV.Len());
1261      PMWdGixRSet RSet = TMWdGixRSet::New(QueryStr,
1262          QueryLang, LangQueryH, FullWgtLangItemV.Len(), Offset);
1263      for (int ItemN = 0; ItemN < WgtLangItemV.Len(); ItemN++) {
1264          const TMWdGixIntItemPr& LangItem = WgtLangItemV[ItemN].Dat;
1265          const TMWdGixItem& Item = LangItem.Val2;
1266          TBlobPt DocBlobPt = Item.GetBlobPt();
1267          TStr DocTitle, DocStr, DocLang; TStrV KeyWdV;
1268          GetDoc(DocBlobPt, DocTitle, DocStr, DocLang, KeyWdV);
1269          RSet->AddDoc(DocTitle, DocStr, DocLang, KeyWdV);
1270      }
1271      printf("  Done\n");
1272      return RSet;
1273  }
1274  void TMWdGixBs::AddAcquis(const TStr& XmlFNm, const TStr& Lang) {
1275      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlFNm);
1276      if (!XmlDoc->IsOk()) { return; }
1277      PXmlTok TopTok = XmlDoc->GetTok();
1278      PXmlTok TextTok = TopTok->GetTagTok("text|body");
1279      if (TextTok.Empty()) { printf("  Bad file '%s'\n", XmlFNm.CStr()); return; }
1280      TStr DocTitle; TChA DocChA;
1281      for (int SubTokN = 0; SubTokN < TextTok->GetSubToks(); SubTokN++) {
1282          PXmlTok SubTok = TextTok->GetSubTok(SubTokN);
1283          if (!SubTok->IsTag()) { continue; }
1284          if (SubTok->GetTagNm() == "head") {
1285              DocTitle = SubTok->GetTokStr(false);
1286          } else if (SubTok->GetTagNm() == "div") {
1287              for (int ParaN = 0; ParaN < SubTok->GetSubToks(); ParaN++) {
1288                  if (SubTok->IsTag()) {
1289                      DocChA += SubTok->GetSubTok(ParaN)->GetTokStr(false);
1290                      DocChA += '\n';
1291                  }
1292              }
1293              DocChA += '\n';
1294          }
1295      }
1296      TStrV KeyWdV;
1297      PXmlTok KeyWdTok = TopTok->GetTagTok("teiHeader|profileDesc|textClass");
1298      if (!KeyWdTok.Empty()) {
1299          for (int SubTokN = 0; SubTokN < KeyWdTok->GetSubToks(); SubTokN++) {
1300              PXmlTok SubTok = KeyWdTok->GetSubTok(SubTokN);
1301              if (!SubTok->IsTag()) { continue; }
1302              if (SubTok->IsArg("scheme")) {
1303                  KeyWdV.Add(SubTok->GetStrArgVal("scheme") + "-" + SubTok->GetTokStr(false));
1304              }
1305          }
1306      }
1307      if (!KeyWdV.Empty()) { AddDoc(DocTitle, DocChA, Lang, KeyWdV); }
1308  }
1309  void TMWdGixBs::IndexAcquis(const TStr& InFPath, PAlignPairBs _AlignPairBs,
1310          const int& MxDocs, const int64& IndexCacheSize) {
1311      AlignPairBs = _AlignPairBs;
1312      int LangId = AlignPairBs->FFirstLangId();
1313      while (AlignPairBs->FNextLangId(LangId)) {
1314          const TStr& Lang = AlignPairBs->GetLang(LangId);
1315          TStr LangFPath = InFPath + "/" + Lang;
1316          printf("Indexing %s ...\n", LangFPath.CStr());
1317          LangMWdGixH.AddDat(Lang) =
1318                  TMWdGix::New(FPath + "/" + Lang, FAccess, IndexCacheSize);
1319          TFFile FFile(LangFPath, ".xml", true);
1320          TStr XmlFNm; int XmlFNms = 0;
1321          while (FFile.Next(XmlFNm)) {
1322              if (XmlFNms == MxDocs) { break; }
1323              if (XmlFNms % 100 == 0) { printf("  %d\r", XmlFNms); }
1324              try { AddAcquis(XmlFNm, Lang); } catch (...) { }
1325              XmlFNms++;
1326          } printf("\n");
1327          LangMWdGixH.Clr();
1328      }
1329      InitGixs(faRdOnly);
1330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-bitvector.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>134  }
135  void BitVector::operator|=(const BitVector &other) {
136    int length = std::min(WordLength(), other.WordLength());
137    for (int w = 0; w < length; ++w) {
</pre></code></div>
                <div class="column column_space"><pre><code>186  }
187  void TWdGixRSet::PrintRes(PNotify Notify) {
188      const int Docs = GetDocs();
189      Notify->OnStatus(TStr::Fmt(
190          "All results: %d, Showing results from %d to %d",
191          AllDocs.Val, Docs, Docs + Offset.Val));
192      for (int DocN = 0; DocN < Docs; DocN++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    