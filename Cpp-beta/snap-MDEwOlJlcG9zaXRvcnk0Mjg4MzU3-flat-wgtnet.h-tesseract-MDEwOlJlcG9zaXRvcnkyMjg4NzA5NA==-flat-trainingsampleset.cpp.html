
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5126050420168067%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wgtnet.h</h3>
            <pre><code>1  #ifndef snap_wgtnet_h
2  #define snap_wgtnet_h
3  #include "Snap.h"
4  class TWgtNet;
5  typedef TPt<TWgtNet> PWgtNet;
6  class TWgtNet : public TNodeEDatNet<TStr, TFlt> {
7  public:
8    TWgtNet() : TNet() { }
9    TWgtNet(TSIn& SIn) : TNet(SIn) { }
10    void Save(TSOut& SOut) const { TNet::Save(SOut); }
11    static PWgtNet New() { return new TWgtNet(); }
12    static PWgtNet Load(TSIn& SIn) { return new TWgtNet(SIn); }
13    double GetEdgeWgt() const;
14    void MulEdgeWgt(const double& MulBy);
15    void PermEdgeWgt();
16    void PermOutEdgeWgt();
17    void PutAllWgts();
18    void PutRnd01Wgts();
19    void AddBiDirEdges(const double& Wgt = -1);
20    void DelMinWgtNodes(const double MinWgt);
21    void ReinforceEdges(const int& NIters);
22    static PWgtNet GetRngWgtNet(const int& Nodes, const int& Edges, const double& Wgt);
23    static PWgtNet LoadCiteSeerCoAuth(const TStr& FNm);
24    static PWgtNet LoadDblpCoAuth(const TStr& FNm);
25    static PWgtNet LoadArxivCoAuth(const TStr& FNm);
26    static PWgtNet LoadEveCommNet(const TStr& FNm);
27    template <class PGraph>
28    static PWgtNet MakeFromBipart(const PGraph& Graph, const bool& TakeLeft);
29    friend class TPt<TWgtNet>;
30  };
31  namespace TSnap {
32  template <> struct IsDirected<TWgtNet> { enum { Val = 1 }; };
33  template <> struct IsNodeDat<TWgtNet> { enum { Val = 1 }; };
34  template <> struct IsEdgeDat<TWgtNet> { enum { Val = 1 }; };
35  }
36  template <class PGraph>
37  PWgtNet TWgtNet::MakeFromBipart(const PGraph& Graph, const bool& TakeLeft) {
38    PWgtNet Net = TWgtNet::New();
39    for (PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
40      IAssert((NI.GetOutDeg()==0 || NI.GetInDeg()==0) && (NI.GetOutDeg()>0 || NI.GetInDeg()>0)); 
41      if (TakeLeft) {
42        if (NI.GetInDeg()==0) { continue; }
43        for (int i = 0; i < NI.GetInDeg(); i++) {
44          const int n1 = NI.GetInNId(i);
<span onclick='openModal()' class='match'>45          for (int j = 0; j < NI.GetInDeg(); j++) {
46            if (i == j) { continue; }
47            const int n2 = NI.GetInNId(j);
48            if (! Net->IsNode(n1)) { Net->AddNode(n1); }
</span>49            if (! Net->IsNode(n2)) { Net->AddNode(n2); }
50            if (Net->IsEdge(n1, n2)) { Net->GetEDat(n1, n2) += 1; }
51            else { Net->AddEdge(n1, n2, 1); }
52          }
53        }
54      } else {
55        if (NI.GetOutDeg()==0) { continue; }
56        for (int i = 0; i < NI.GetOutDeg(); i++) {
57          const int n1 = NI.GetOutNId(i);
58          for (int j = 0; j < NI.GetOutDeg(); j++) {
59            if (i == j) { continue; }
60            const int n2 = NI.GetOutNId(j);
61            if (! Net->IsNode(n1)) { Net->AddNode(n1); }
62            if (! Net->IsNode(n2)) { Net->AddNode(n2); }
63            if (Net->IsEdge(n1, n2)) { Net->GetEDat(n1, n2) += 1; }
64            else { Net->AddEdge(n1, n2, 1); }
65          }
66        }
67      }
68    }
69    TGBase::PrintInfo(Net);
70    printf("  Edge weight: %f\n", Net->GetEdgeWgt());
71    return Net;
72  }
73  class TTop2FriendNet {
74  private:
75    PWgtNet Net;
76    THash<TInt, TIntPr> Top2NIdH;
77    TUnionFind Top1UF;
78    void SetTop2();
79  public:
80    TTop2FriendNet(const PWgtNet& NetPt) : Net(NetPt) { SetTop2(); }
81    PNGraph GetTop1Net();
82    int GetTop2Len() const { return Top2NIdH.Len(); }
83    int GetTop2WccSz(const double ProbPick2nd) const;
84    int GetRnd2WccSz(const double ProbPick2nd) const;
85    static void GetAvgSDevV(const THash<TFlt, TMom>& MomH, TFltTrV& ValAvgSDevV);
86    static void PlotPick2VsProb2nd(const PWgtNet& Net, const int& NRuns, const double& StepP, const TStr& OutFNm,
87      TStr Desc="", bool PlotTop2=true, bool PlotBtm2=true, bool PlotRnd2=true);
88  };
89  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trainingsampleset.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <algorithm>
5  #include <allheaders.h>
6  #include "boxread.h"
7  #include "fontinfo.h"
8  #include "indexmapbidi.h"
9  #include "intfeaturedist.h"
10  #include "intfeaturemap.h"
11  #include "intfeaturespace.h"
12  #include "shapetable.h"
13  #include "trainingsample.h"
14  #include "trainingsampleset.h"
15  #include "unicity_table.h"
16  namespace tesseract {
17  const int kTestChar = -1; 
18  const int kSquareLimit = 25;
19  const int kPrime1 = 17;
20  const int kPrime2 = 13;
21  TrainingSampleSet::FontClassInfo::FontClassInfo()
22      : num_raw_samples(0), canonical_sample(-1), canonical_dist(0.0f) {}
23  bool TrainingSampleSet::FontClassInfo::Serialize(FILE *fp) const {
24    if (fwrite(&num_raw_samples, sizeof(num_raw_samples), 1, fp) != 1) {
25      return false;
26    }
27    if (fwrite(&canonical_sample, sizeof(canonical_sample), 1, fp) != 1) {
28      return false;
29    }
30    if (fwrite(&canonical_dist, sizeof(canonical_dist), 1, fp) != 1) {
31      return false;
32    }
33    if (!::tesseract::Serialize(fp, samples)) {
34      return false;
35    }
36    return true;
37  }
38  bool TrainingSampleSet::FontClassInfo::DeSerialize(bool swap, FILE *fp) {
39    if (fread(&num_raw_samples, sizeof(num_raw_samples), 1, fp) != 1) {
40      return false;
41    }
42    if (fread(&canonical_sample, sizeof(canonical_sample), 1, fp) != 1) {
43      return false;
44    }
45    if (fread(&canonical_dist, sizeof(canonical_dist), 1, fp) != 1) {
46      return false;
47    }
48    if (!::tesseract::DeSerialize(swap, fp, samples)) {
49      return false;
50    }
51    if (swap) {
52      ReverseN(&num_raw_samples, sizeof(num_raw_samples));
53      ReverseN(&canonical_sample, sizeof(canonical_sample));
54      ReverseN(&canonical_dist, sizeof(canonical_dist));
55    }
56    return true;
57  }
58  TrainingSampleSet::TrainingSampleSet(const FontInfoTable &font_table)
59      : num_raw_samples_(0)
60      , unicharset_size_(0)
61      , font_class_array_(nullptr)
62      , fontinfo_table_(font_table) {}
63  TrainingSampleSet::~TrainingSampleSet() {
64    for (auto sample : samples_) {
65      delete sample;
66    }
67    delete font_class_array_;
68  }
69  bool TrainingSampleSet::Serialize(FILE *fp) const {
70    if (!tesseract::Serialize(fp, samples_)) {
71      return false;
72    }
73    if (!unicharset_.save_to_file(fp)) {
74      return false;
75    }
76    if (!font_id_map_.Serialize(fp)) {
77      return false;
78    }
79    int8_t not_null = font_class_array_ != nullptr;
80    if (fwrite(&not_null, sizeof(not_null), 1, fp) != 1) {
81      return false;
82    }
83    if (not_null) {
84      if (!font_class_array_->SerializeClasses(fp)) {
85        return false;
86      }
87    }
88    return true;
89  }
90  bool TrainingSampleSet::DeSerialize(bool swap, FILE *fp) {
91    if (!tesseract::DeSerialize(swap, fp, samples_)) {
92      return false;
93    }
94    num_raw_samples_ = samples_.size();
95    if (!unicharset_.load_from_file(fp)) {
96      return false;
97    }
98    if (!font_id_map_.DeSerialize(swap, fp)) {
99      return false;
100    }
101    delete font_class_array_;
102    font_class_array_ = nullptr;
103    int8_t not_null;
104    if (fread(&not_null, sizeof(not_null), 1, fp) != 1) {
105      return false;
106    }
107    if (not_null) {
108      FontClassInfo empty;
109      font_class_array_ = new GENERIC_2D_ARRAY<FontClassInfo>(1, 1, empty);
110      if (!font_class_array_->DeSerializeClasses(swap, fp)) {
111        return false;
112      }
113    }
114    unicharset_size_ = unicharset_.size();
115    return true;
116  }
117  void TrainingSampleSet::LoadUnicharset(const char *filename) {
118    if (!unicharset_.load_from_file(filename)) {
119      tprintf(
120          "Failed to load unicharset from file %s\n"
121          "Building unicharset from scratch...\n",
122          filename);
123      unicharset_.clear();
124      UNICHARSET empty;
125      unicharset_.AppendOtherUnicharset(empty);
126    }
127    unicharset_size_ = unicharset_.size();
128  }
129  int TrainingSampleSet::AddSample(const char *unichar, TrainingSample *sample) {
130    if (!unicharset_.contains_unichar(unichar)) {
131      unicharset_.unichar_insert(unichar);
132      if (unicharset_.size() > MAX_NUM_CLASSES) {
133        tprintf(
134            "Error: Size of unicharset in TrainingSampleSet::AddSample is "
135            "greater than MAX_NUM_CLASSES\n");
136        return -1;
137      }
138    }
139    UNICHAR_ID char_id = unicharset_.unichar_to_id(unichar);
140    AddSample(char_id, sample);
141    return char_id;
142  }
143  void TrainingSampleSet::AddSample(int unichar_id, TrainingSample *sample) {
144    sample->set_class_id(unichar_id);
145    samples_.push_back(sample);
146    num_raw_samples_ = samples_.size();
147    unicharset_size_ = unicharset_.size();
148  }
149  int TrainingSampleSet::NumClassSamples(int font_id, int class_id, bool randomize) const {
150    ASSERT_HOST(font_class_array_ != nullptr);
151    if (font_id < 0 || class_id < 0 || font_id >= font_id_map_.SparseSize() ||
152        class_id >= unicharset_size_) {
153      return 0;
154    }
155    int font_index = font_id_map_.SparseToCompact(font_id);
156    if (font_index < 0) {
157      return 0; 
158    }
159    if (randomize) {
160      return (*font_class_array_)(font_index, class_id).samples.size();
161    } else {
162      return (*font_class_array_)(font_index, class_id).num_raw_samples;
163    }
164  }
165  const TrainingSample *TrainingSampleSet::GetSample(int index) const {
166    return samples_[index];
167  }
168  const TrainingSample *TrainingSampleSet::GetSample(int font_id, int class_id, int index) const {
169    ASSERT_HOST(font_class_array_ != nullptr);
170    int font_index = font_id_map_.SparseToCompact(font_id);
171    if (font_index < 0) {
172      return nullptr;
173    }
174    int sample_index = (*font_class_array_)(font_index, class_id).samples[index];
175    return samples_[sample_index];
176  }
177  TrainingSample *TrainingSampleSet::MutableSample(int font_id, int class_id, int index) {
178    ASSERT_HOST(font_class_array_ != nullptr);
179    int font_index = font_id_map_.SparseToCompact(font_id);
180    if (font_index < 0) {
181      return nullptr;
182    }
183    int sample_index = (*font_class_array_)(font_index, class_id).samples[index];
184    return samples_[sample_index];
185  }
186  std::string TrainingSampleSet::SampleToString(const TrainingSample &sample) const {
187    std::string boxfile_str;
188    MakeBoxFileStr(unicharset_.id_to_unichar(sample.class_id()), sample.bounding_box(),
189                   sample.page_num(), boxfile_str);
190    return std::string(fontinfo_table_.at(sample.font_id()).name) + " " + boxfile_str;
191  }
192  const BitVector &TrainingSampleSet::GetCloudFeatures(int font_id, int class_id) const {
193    int font_index = font_id_map_.SparseToCompact(font_id);
194    ASSERT_HOST(font_index >= 0);
195    return (*font_class_array_)(font_index, class_id).cloud_features;
196  }
197  const std::vector<int> &TrainingSampleSet::GetCanonicalFeatures(int font_id, int class_id) const {
198    int font_index = font_id_map_.SparseToCompact(font_id);
199    ASSERT_HOST(font_index >= 0);
200    return (*font_class_array_)(font_index, class_id).canonical_features;
201  }
202  float TrainingSampleSet::UnicharDistance(const UnicharAndFonts &uf1, const UnicharAndFonts &uf2,
203                                           bool matched_fonts, const IntFeatureMap &feature_map) {
204    int num_fonts1 = uf1.font_ids.size();
205    int c1 = uf1.unichar_id;
206    int num_fonts2 = uf2.font_ids.size();
207    int c2 = uf2.unichar_id;
208    double dist_sum = 0.0;
209    int dist_count = 0;
210    const bool debug = false;
211    if (matched_fonts) {
212      for (int i = 0; i < num_fonts1; ++i) {
213        int f1 = uf1.font_ids[i];
214        for (int j = 0; j < num_fonts2; ++j) {
215          int f2 = uf2.font_ids[j];
216          if (f1 == f2) {
217            dist_sum += ClusterDistance(f1, c1, f2, c2, feature_map);
218            ++dist_count;
219          }
220        }
221      }
222    } else if (num_fonts1 * num_fonts2 <= kSquareLimit) {
223      for (int i = 0; i < num_fonts1; ++i) {
224        int f1 = uf1.font_ids[i];
225        for (int j = 0; j < num_fonts2; ++j) {
226          int f2 = uf2.font_ids[j];
227          dist_sum += ClusterDistance(f1, c1, f2, c2, feature_map);
228          if (debug) {
229            tprintf("Cluster dist %d %d %d %d = %g\n", f1, c1, f2, c2,
230                    ClusterDistance(f1, c1, f2, c2, feature_map));
231          }
232          ++dist_count;
233        }
234      }
235    } else {
236      int increment = kPrime1 != num_fonts2 ? kPrime1 : kPrime2;
237      int index = 0;
238      int num_samples = std::max(num_fonts1, num_fonts2);
239      for (int i = 0; i < num_samples; ++i, index += increment) {
240        int f1 = uf1.font_ids[i % num_fonts1];
241        int f2 = uf2.font_ids[index % num_fonts2];
242        if (debug) {
243          tprintf("Cluster dist %d %d %d %d = %g\n", f1, c1, f2, c2,
244                  ClusterDistance(f1, c1, f2, c2, feature_map));
245        }
246        dist_sum += ClusterDistance(f1, c1, f2, c2, feature_map);
247        ++dist_count;
248      }
249    }
250    if (dist_count == 0) {
251      if (matched_fonts) {
252        return UnicharDistance(uf1, uf2, false, feature_map);
253      }
254      return 0.0f;
255    }
256    return dist_sum / dist_count;
257  }
258  float TrainingSampleSet::ClusterDistance(int font_id1, int class_id1, int font_id2, int class_id2,
259                                           const IntFeatureMap &feature_map) {
260    ASSERT_HOST(font_class_array_ != nullptr);
261    int font_index1 = font_id_map_.SparseToCompact(font_id1);
262    int font_index2 = font_id_map_.SparseToCompact(font_id2);
263    if (font_index1 < 0 || font_index2 < 0) {
264      return 0.0f;
265    }
266    FontClassInfo &fc_info = (*font_class_array_)(font_index1, class_id1);
267    if (font_id1 == font_id2) {
268      if (fc_info.unichar_distance_cache.empty()) {
269        fc_info.unichar_distance_cache.resize(unicharset_size_, -1.0f);
270      }
271      if (fc_info.unichar_distance_cache[class_id2] < 0) {
272        float result = ComputeClusterDistance(font_id1, class_id1, font_id2, class_id2, feature_map);
273        fc_info.unichar_distance_cache[class_id2] = result;
274        FontClassInfo &fc_info2 = (*font_class_array_)(font_index2, class_id2);
275        if (fc_info2.unichar_distance_cache.empty()) {
276          fc_info2.unichar_distance_cache.resize(unicharset_size_, -1.0f);
277        }
278        fc_info2.unichar_distance_cache[class_id1] = result;
279      }
280      return fc_info.unichar_distance_cache[class_id2];
281    } else if (class_id1 == class_id2) {
282      if (fc_info.font_distance_cache.empty()) {
283        fc_info.font_distance_cache.resize(font_id_map_.CompactSize(), -1.0f);
284      }
285      if (fc_info.font_distance_cache[font_index2] < 0) {
286        float result = ComputeClusterDistance(font_id1, class_id1, font_id2, class_id2, feature_map);
287        fc_info.font_distance_cache[font_index2] = result;
288        FontClassInfo &fc_info2 = (*font_class_array_)(font_index2, class_id2);
289        if (fc_info2.font_distance_cache.empty()) {
290          fc_info2.font_distance_cache.resize(font_id_map_.CompactSize(), -1.0f);
291        }
292        fc_info2.font_distance_cache[font_index1] = result;
293      }
294      return fc_info.font_distance_cache[font_index2];
295    }
296    size_t cache_index = 0;
297    while (cache_index < fc_info.distance_cache.size() &&
298           (fc_info.distance_cache[cache_index].unichar_id != class_id2 ||
299            fc_info.distance_cache[cache_index].font_id != font_id2)) {
300      ++cache_index;
301    }
302    if (cache_index == fc_info.distance_cache.size()) {
303      float result = ComputeClusterDistance(font_id1, class_id1, font_id2, class_id2, feature_map);
304      FontClassDistance fc_dist = {class_id2, font_id2, result};
305      fc_info.distance_cache.push_back(fc_dist);
306      FontClassInfo &fc_info2 = (*font_class_array_)(font_index2, class_id2);
307      fc_dist.unichar_id = class_id1;
308      fc_dist.font_id = font_id1;
309      fc_info2.distance_cache.push_back(fc_dist);
310    }
311    return fc_info.distance_cache[cache_index].distance;
312  }
313  float TrainingSampleSet::ComputeClusterDistance(int font_id1, int class_id1, int font_id2,
314                                                  int class_id2,
315                                                  const IntFeatureMap &feature_map) const {
316    int dist = ReliablySeparable(font_id1, class_id1, font_id2, class_id2, feature_map, false);
317    dist += ReliablySeparable(font_id2, class_id2, font_id1, class_id1, feature_map, false);
318    int denominator = GetCanonicalFeatures(font_id1, class_id1).size();
319    denominator += GetCanonicalFeatures(font_id2, class_id2).size();
320    return static_cast<float>(dist) / denominator;
321  }
322  static void AddNearFeatures(const IntFeatureMap &feature_map, int f, int levels,
323                              std::vector<int> *good_features) {
324    int prev_num_features = 0;
325    good_features->push_back(f);
326    int num_features = 1;
327    for (int level = 0; level < levels; ++level) {
328      for (int i = prev_num_features; i < num_features; ++i) {
329        int feature = (*good_features)[i];
<span onclick='openModal()' class='match'>330        for (int dir = -kNumOffsetMaps; dir <= kNumOffsetMaps; ++dir) {
331          if (dir == 0) {
332            continue;
333          }
334          int f1 = feature_map.OffsetFeature(feature, dir);
335          if (f1 >= 0) {
336            good_features->push_back(f1);
</span>337          }
338        }
339      }
340      prev_num_features = num_features;
341      num_features = good_features->size();
342    }
343  }
344  int TrainingSampleSet::ReliablySeparable(int font_id1, int class_id1, int font_id2, int class_id2,
345                                           const IntFeatureMap &feature_map, bool thorough) const {
346    int result = 0;
347    const TrainingSample *sample2 = GetCanonicalSample(font_id2, class_id2);
348    if (sample2 == nullptr) {
349      return 0; 
350    }
351    const std::vector<int> &canonical2 = GetCanonicalFeatures(font_id2, class_id2);
352    const BitVector &cloud1 = GetCloudFeatures(font_id1, class_id1);
353    if (cloud1.empty()) {
354      return canonical2.size(); 
355    }
356    for (int feature : canonical2) {
357      if (cloud1[feature]) {
358        continue;
359      }
360      std::vector<int> good_features;
361      AddNearFeatures(feature_map, feature, 1, &good_features);
362      bool found = false;
363      for (auto good_f : good_features) {
364        if (cloud1[good_f]) {
365          found = true;
366          break;
367        }
368      }
369      if (found) {
370        continue; 
371      }
372      ++result;
373    }
374    return result;
375  }
376  int TrainingSampleSet::GlobalSampleIndex(int font_id, int class_id, int index) const {
377    ASSERT_HOST(font_class_array_ != nullptr);
378    int font_index = font_id_map_.SparseToCompact(font_id);
379    if (font_index < 0) {
380      return -1;
381    }
382    return (*font_class_array_)(font_index, class_id).samples[index];
383  }
384  const TrainingSample *TrainingSampleSet::GetCanonicalSample(int font_id, int class_id) const {
385    ASSERT_HOST(font_class_array_ != nullptr);
386    int font_index = font_id_map_.SparseToCompact(font_id);
387    if (font_index < 0) {
388      return nullptr;
389    }
390    const int sample_index = (*font_class_array_)(font_index, class_id).canonical_sample;
391    return sample_index >= 0 ? samples_[sample_index] : nullptr;
392  }
393  float TrainingSampleSet::GetCanonicalDist(int font_id, int class_id) const {
394    ASSERT_HOST(font_class_array_ != nullptr);
395    int font_index = font_id_map_.SparseToCompact(font_id);
396    if (font_index < 0) {
397      return 0.0f;
398    }
399    if ((*font_class_array_)(font_index, class_id).canonical_sample >= 0) {
400      return (*font_class_array_)(font_index, class_id).canonical_dist;
401    } else {
402      return 0.0f;
403    }
404  }
405  void TrainingSampleSet::IndexFeatures(const IntFeatureSpace &feature_space) {
406    for (auto &sample : samples_) {
407      sample->IndexFeatures(feature_space);
408    }
409  }
410  void TrainingSampleSet::KillSample(TrainingSample *sample) {
411    sample->set_sample_index(-1);
412  }
413  void TrainingSampleSet::DeleteDeadSamples() {
414    using namespace std::placeholders; 
415    for (auto &&it = samples_.begin(); it < samples_.end();) {
416      if (*it == nullptr || (*it)->class_id() < 0) {
417        samples_.erase(it);
418        delete *it;
419      } else {
420        ++it;
421      }
422    }
423    num_raw_samples_ = samples_.size();
424  }
425  void TrainingSampleSet::OrganizeByFontAndClass() {
426    SetupFontIdMap();
427    int compact_font_size = font_id_map_.CompactSize();
428    delete font_class_array_;
429    FontClassInfo empty;
430    font_class_array_ =
431        new GENERIC_2D_ARRAY<FontClassInfo>(compact_font_size, unicharset_size_, empty);
432    for (size_t s = 0; s < samples_.size(); ++s) {
433      int font_id = samples_[s]->font_id();
434      int class_id = samples_[s]->class_id();
435      if (font_id < 0 || font_id >= font_id_map_.SparseSize()) {
436        tprintf("Font id = %d/%d, class id = %d/%d on sample %zu\n", font_id,
437                font_id_map_.SparseSize(), class_id, unicharset_size_, s);
438      }
439      ASSERT_HOST(font_id >= 0 && font_id < font_id_map_.SparseSize());
440      ASSERT_HOST(class_id >= 0 && class_id < unicharset_size_);
441      int font_index = font_id_map_.SparseToCompact(font_id);
442      (*font_class_array_)(font_index, class_id).samples.push_back(s);
443    }
444    for (int f = 0; f < compact_font_size; ++f) {
445      for (int c = 0; c < unicharset_size_; ++c) {
446        (*font_class_array_)(f, c).num_raw_samples = (*font_class_array_)(f, c).samples.size();
447      }
448    }
449    num_raw_samples_ = samples_.size();
450  }
451  void TrainingSampleSet::SetupFontIdMap() {
452    std::vector<int> font_counts;
453    for (auto &sample : samples_) {
454      const int font_id = sample->font_id();
455      while (font_id >= font_counts.size()) {
456        font_counts.push_back(0);
457      }
458      ++font_counts[font_id];
459    }
460    font_id_map_.Init(font_counts.size(), false);
461    for (size_t f = 0; f < font_counts.size(); ++f) {
462      font_id_map_.SetMap(f, font_counts[f] > 0);
463    }
464    font_id_map_.Setup();
465  }
466  void TrainingSampleSet::ComputeCanonicalSamples(const IntFeatureMap &map, bool debug) {
467    ASSERT_HOST(font_class_array_ != nullptr);
468    IntFeatureDist f_table;
469    if (debug) {
470      tprintf("feature table size %d\n", map.sparse_size());
471    }
472    f_table.Init(&map);
473    int worst_s1 = 0;
474    int worst_s2 = 0;
475    double global_worst_dist = 0.0;
476    int font_size = font_id_map_.CompactSize();
477    for (int font_index = 0; font_index < font_size; ++font_index) {
478      int font_id = font_id_map_.CompactToSparse(font_index);
479      for (int c = 0; c < unicharset_size_; ++c) {
480        int samples_found = 0;
481        FontClassInfo &fcinfo = (*font_class_array_)(font_index, c);
482        if (fcinfo.samples.empty() || (kTestChar >= 0 && c != kTestChar)) {
483          fcinfo.canonical_sample = -1;
484          fcinfo.canonical_dist = 0.0f;
485          if (debug) {
486            tprintf("Skipping class %d\n", c);
487          }
488          continue;
489        }
490        double min_max_dist = 2.0;
491        double max_max_dist = 0.0;
492        int max_s1 = 0;
493        int max_s2 = 0;
494        fcinfo.canonical_sample = fcinfo.samples[0];
495        fcinfo.canonical_dist = 0.0f;
496        for (auto s1 : fcinfo.samples) {
497          const std::vector<int> &features1 = samples_[s1]->indexed_features();
498          f_table.Set(features1, features1.size(), true);
499          double max_dist = 0.0;
500          for (int s2 : fcinfo.samples) {
501            if (samples_[s2]->class_id() != c || samples_[s2]->font_id() != font_id || s2 == s1) {
502              continue;
503            }
504            std::vector<int> features2 = samples_[s2]->indexed_features();
505            double dist = f_table.FeatureDistance(features2);
506            if (dist > max_dist) {
507              max_dist = dist;
508              if (dist > max_max_dist) {
509                max_max_dist = dist;
510                max_s1 = s1;
511                max_s2 = s2;
512              }
513            }
514          }
515          f_table.Set(features1, features1.size(), false);
516          samples_[s1]->set_max_dist(max_dist);
517          ++samples_found;
518          if (max_dist < min_max_dist) {
519            fcinfo.canonical_sample = s1;
520            fcinfo.canonical_dist = max_dist;
521          }
522          UpdateRange(max_dist, &min_max_dist, &max_max_dist);
523        }
524        if (max_max_dist > global_worst_dist) {
525          global_worst_dist = max_max_dist;
526          worst_s1 = max_s1;
527          worst_s2 = max_s2;
528        }
529        if (debug) {
530          tprintf(
531              "Found %d samples of class %d=%s, font %d, "
532              "dist range [%g, %g], worst pair= %s, %s\n",
533              samples_found, c, unicharset_.debug_str(c).c_str(), font_index, min_max_dist,
534              max_max_dist, SampleToString(*samples_[max_s1]).c_str(),
535              SampleToString(*samples_[max_s2]).c_str());
536        }
537      }
538    }
539    if (debug) {
540      tprintf("Global worst dist = %g, between sample %d and %d\n", global_worst_dist, worst_s1,
541              worst_s2);
542    }
543  }
544  void TrainingSampleSet::ReplicateAndRandomizeSamples() {
545    ASSERT_HOST(font_class_array_ != nullptr);
546    int font_size = font_id_map_.CompactSize();
547    for (int font_index = 0; font_index < font_size; ++font_index) {
548      for (int c = 0; c < unicharset_size_; ++c) {
549        FontClassInfo &fcinfo = (*font_class_array_)(font_index, c);
550        int sample_count = fcinfo.samples.size();
551        int min_samples = 2 * std::max(kSampleRandomSize, sample_count);
552        if (sample_count > 0 && sample_count < min_samples) {
553          int base_count = sample_count;
554          for (int base_index = 0; sample_count < min_samples; ++sample_count) {
555            int src_index = fcinfo.samples[base_index++];
556            if (base_index >= base_count) {
557              base_index = 0;
558            }
559            TrainingSample *sample =
560                samples_[src_index]->RandomizedCopy(sample_count % kSampleRandomSize);
561            int sample_index = samples_.size();
562            sample->set_sample_index(sample_index);
563            samples_.push_back(sample);
564            fcinfo.samples.push_back(sample_index);
565          }
566        }
567      }
568    }
569  }
570  void TrainingSampleSet::ComputeCanonicalFeatures() {
571    ASSERT_HOST(font_class_array_ != nullptr);
572    const int font_size = font_id_map_.CompactSize();
573    for (int font_index = 0; font_index < font_size; ++font_index) {
574      const int font_id = font_id_map_.CompactToSparse(font_index);
575      for (int c = 0; c < unicharset_size_; ++c) {
576        int num_samples = NumClassSamples(font_id, c, false);
577        if (num_samples == 0) {
578          continue;
579        }
580        const TrainingSample *sample = GetCanonicalSample(font_id, c);
581        FontClassInfo &fcinfo = (*font_class_array_)(font_index, c);
582        fcinfo.canonical_features = sample->indexed_features();
583      }
584    }
585  }
586  void TrainingSampleSet::ComputeCloudFeatures(int feature_space_size) {
587    ASSERT_HOST(font_class_array_ != nullptr);
588    int font_size = font_id_map_.CompactSize();
589    for (int font_index = 0; font_index < font_size; ++font_index) {
590      int font_id = font_id_map_.CompactToSparse(font_index);
591      for (int c = 0; c < unicharset_size_; ++c) {
592        int num_samples = NumClassSamples(font_id, c, false);
593        if (num_samples == 0) {
594          continue;
595        }
596        FontClassInfo &fcinfo = (*font_class_array_)(font_index, c);
597        fcinfo.cloud_features.Init(feature_space_size);
598        for (int s = 0; s < num_samples; ++s) {
599          const TrainingSample *sample = GetSample(font_id, c, s);
600          const std::vector<int> &sample_features = sample->indexed_features();
601          for (int sample_feature : sample_features) {
602            fcinfo.cloud_features.SetBit(sample_feature);
603          }
604        }
605      }
606    }
607  }
608  void TrainingSampleSet::AddAllFontsForClass(int class_id, Shape *shape) const {
609    for (int f = 0; f < font_id_map_.CompactSize(); ++f) {
610      const int font_id = font_id_map_.CompactToSparse(f);
611      shape->AddToShape(class_id, font_id);
612    }
613  }
614  #ifndef GRAPHICS_DISABLED
615  void TrainingSampleSet::DisplaySamplesWithFeature(int f_index, const Shape &shape,
616                                                    const IntFeatureSpace &space,
617                                                    ScrollView::Color color,
618                                                    ScrollView *window) const {
619    for (int s = 0; s < num_raw_samples(); ++s) {
620      const TrainingSample *sample = GetSample(s);
621      if (shape.ContainsUnichar(sample->class_id())) {
622        std::vector<int> indexed_features;
623        space.IndexAndSortFeatures(sample->features(), sample->num_features(), &indexed_features);
624        for (int indexed_feature : indexed_features) {
625          if (indexed_feature == f_index) {
626            sample->DisplayFeatures(color, window);
627          }
628        }
629      }
630    }
631  }
632  #endif 
633  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wgtnet.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-trainingsampleset.cpp</div>
                </div>
                <div class="column column_space"><pre><code>45          for (int j = 0; j < NI.GetInDeg(); j++) {
46            if (i == j) { continue; }
47            const int n2 = NI.GetInNId(j);
48            if (! Net->IsNode(n1)) { Net->AddNode(n1); }
</pre></code></div>
                <div class="column column_space"><pre><code>330        for (int dir = -kNumOffsetMaps; dir <= kNumOffsetMaps; ++dir) {
331          if (dir == 0) {
332            continue;
333          }
334          int f1 = feature_map.OffsetFeature(feature, dir);
335          if (f1 >= 0) {
336            good_features->push_back(f1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    