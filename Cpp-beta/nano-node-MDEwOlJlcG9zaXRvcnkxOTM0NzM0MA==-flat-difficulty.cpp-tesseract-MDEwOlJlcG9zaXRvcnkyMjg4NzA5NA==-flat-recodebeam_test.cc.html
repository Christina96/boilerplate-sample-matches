
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6378896882494005%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-difficulty.cpp</h3>
            <pre><code>1  #include <nano/lib/blocks.hpp>
2  #include <nano/lib/config.hpp>
3  #include <nano/lib/epoch.hpp>
4  #include <nano/lib/numbers.hpp>
5  #include <nano/lib/work.hpp>
6  #include <nano/secure/common.hpp>
7  #include <nano/test_common/testutil.hpp>
8  #include <gtest/gtest.h>
9  TEST (difficultyDeathTest, multipliers)
10  {
11  	testing::FLAGS_gtest_death_test_style = "threadsafe";
12  	{
13  		uint64_t base = 0xff00000000000000;
14  		uint64_t difficulty = 0xfff27e7a57c285cd;
15  		double expected_multiplier = 18.95461493377003;
16  		ASSERT_NEAR (expected_multiplier, nano::difficulty::to_multiplier (difficulty, base), 1e-10);
17  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (expected_multiplier, base));
18  	}
19  	{
20  		uint64_t base = 0xffffffc000000000;
21  		uint64_t difficulty = 0xfffffe0000000000;
22  		double expected_multiplier = 0.125;
23  		ASSERT_NEAR (expected_multiplier, nano::difficulty::to_multiplier (difficulty, base), 1e-10);
24  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (expected_multiplier, base));
25  	}
26  	{
27  		uint64_t base = std::numeric_limits<std::uint64_t>::max ();
28  		uint64_t difficulty = 0xffffffffffffff00;
29  		double expected_multiplier = 0.00390625;
30  		ASSERT_NEAR (expected_multiplier, nano::difficulty::to_multiplier (difficulty, base), 1e-10);
31  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (expected_multiplier, base));
32  	}
33  	{
34  		uint64_t base = 0x8000000000000000;
35  		uint64_t difficulty = 0xf000000000000000;
36  		double expected_multiplier = 8.0;
37  		ASSERT_NEAR (expected_multiplier, nano::difficulty::to_multiplier (difficulty, base), 1e-10);
38  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (expected_multiplier, base));
39  	}
40  #ifndef NDEBUG
41  	if (!nano::running_within_valgrind ())
42  	{
43  		uint64_t base = 0xffffffc000000000;
44  		uint64_t difficulty_nil = 0;
45  		double multiplier_nil = 0.;
46  		ASSERT_DEATH_IF_SUPPORTED (nano::difficulty::to_multiplier (difficulty_nil, base), "");
47  		ASSERT_DEATH_IF_SUPPORTED (nano::difficulty::from_multiplier (multiplier_nil, base), "");
48  	}
49  #endif
<span onclick='openModal()' class='match'>50  }
51  TEST (difficulty, overflow)
52  {
53  	{
54  		uint64_t base = std::numeric_limits<std::uint64_t>::max (); 
55  		uint64_t difficulty = std::numeric_limits<std::uint64_t>::max ();
56  		double multiplier = 1.001; 
</span>57  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (multiplier, base));
58  	}
59  	{
60  		uint64_t base = 1; 
61  		uint64_t difficulty = 0;
62  		double multiplier = 0.999; 
63  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (multiplier, base));
64  	}
65  }
66  TEST (difficulty, zero)
67  {
68  	{
69  		uint64_t base = 0; 
70  		uint64_t difficulty = 0;
71  		double multiplier = 0.000000001; 
72  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (multiplier, base));
73  	}
74  	{
75  		uint64_t base = 0; 
76  		uint64_t difficulty = 0;
77  		double multiplier = 1000000000.0; 
78  		ASSERT_EQ (difficulty, nano::difficulty::from_multiplier (multiplier, base));
79  	}
80  }
81  TEST (difficulty, network_constants)
82  {
83  	auto & full_thresholds = nano::work_thresholds::publish_full;
84  	auto & beta_thresholds = nano::work_thresholds::publish_beta;
85  	auto & dev_thresholds = nano::work_thresholds::publish_dev;
86  	ASSERT_NEAR (8., nano::difficulty::to_multiplier (full_thresholds.epoch_2, full_thresholds.epoch_1), 1e-10);
87  	ASSERT_NEAR (1 / 8., nano::difficulty::to_multiplier (full_thresholds.epoch_2_receive, full_thresholds.epoch_1), 1e-10);
88  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (full_thresholds.epoch_2_receive, full_thresholds.entry), 1e-10);
89  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (full_thresholds.epoch_2, full_thresholds.base), 1e-10);
90  	ASSERT_NEAR (1 / 64., nano::difficulty::to_multiplier (beta_thresholds.epoch_1, full_thresholds.epoch_1), 1e-10);
91  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (beta_thresholds.epoch_2, beta_thresholds.epoch_1), 1e-10);
92  	ASSERT_NEAR (1 / 2., nano::difficulty::to_multiplier (beta_thresholds.epoch_2_receive, beta_thresholds.epoch_1), 1e-10);
93  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (beta_thresholds.epoch_2_receive, beta_thresholds.entry), 1e-10);
94  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (beta_thresholds.epoch_2, beta_thresholds.base), 1e-10);
95  	ASSERT_NEAR (8., nano::difficulty::to_multiplier (dev_thresholds.epoch_2, dev_thresholds.epoch_1), 1e-10);
96  	ASSERT_NEAR (1 / 8., nano::difficulty::to_multiplier (dev_thresholds.epoch_2_receive, dev_thresholds.epoch_1), 1e-10);
97  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (dev_thresholds.epoch_2_receive, dev_thresholds.entry), 1e-10);
98  	ASSERT_NEAR (1., nano::difficulty::to_multiplier (dev_thresholds.epoch_2, dev_thresholds.base), 1e-10);
99  	nano::work_version version{ nano::work_version::work_1 };
100  	ASSERT_EQ (nano::dev::network_params.work.base, nano::dev::network_params.work.epoch_2);
101  	ASSERT_EQ (nano::dev::network_params.work.base, nano::dev::network_params.work.threshold_base (version));
102  	ASSERT_EQ (nano::dev::network_params.work.entry, nano::dev::network_params.work.threshold_entry (version, nano::block_type::state));
103  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold_entry (version, nano::block_type::send));
104  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold_entry (version, nano::block_type::receive));
105  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold_entry (version, nano::block_type::open));
106  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold_entry (version, nano::block_type::change));
107  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_0, false, false, false)));
108  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_1, false, false, false)));
109  	ASSERT_EQ (nano::dev::network_params.work.epoch_1, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_1, false, false, false)));
110  	ASSERT_EQ (nano::dev::network_params.work.epoch_2, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_2, true, false, false)));
111  	ASSERT_EQ (nano::dev::network_params.work.epoch_2, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_2, false, false, false)));
112  	ASSERT_EQ (nano::dev::network_params.work.epoch_2_receive, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_2, false, true, false)));
113  	ASSERT_EQ (nano::dev::network_params.work.epoch_2_receive, nano::dev::network_params.work.threshold (version, nano::block_details (nano::epoch::epoch_2, false, false, true)));
114  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam_test.cc</h3>
            <pre><code>1  #include "include_gunit.h"
2  #include "log.h" 
3  #include "matrix.h"
4  #include "normstrngs.h"
5  #include "pageres.h"
6  #include "ratngs.h"
7  #include "recodebeam.h"
8  #include "unicharcompress.h"
9  #include "unicharset_training_utils.h"
10  #include "helpers.h"
11  namespace tesseract {
12  const int kNumChars = 100;
13  const int kPadding = 64;
14  const char *kGWRTops[] = {"G", "e", "f", " ", "s", " ", "w", "o", "r",    "d",
15                            "s", "",  "r", "i", "g", "h", "t", ".", nullptr};
16  const float kGWRTopScores[] = {0.99, 0.85, 0.87, 0.55, 0.99, 0.65, 0.89, 0.99, 0.99,
17                                 0.99, 0.99, 0.95, 0.99, 0.90, 0.90, 0.90, 0.95, 0.75};
18  const char *kGWR2nds[] = {"C", "c", "t", "",  "S", "",  "W", "O", "t",    "h",
19                            "S", " ", "t", "I", "9", "b", "f", ",", nullptr};
20  const float kGWR2ndScores[] = {0.01, 0.10, 0.12, 0.42, 0.01, 0.25, 0.10, 0.01, 0.01,
21                                 0.01, 0.01, 0.05, 0.01, 0.09, 0.09, 0.09, 0.05, 0.25};
22  const char *kZHTops[] = {"实", "学", "储", "啬", "投", "学", "生", nullptr};
23  const float kZHTopScores[] = {0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.98};
24  const char *kZH2nds[] = {"学", "储", "投", "生", "学", "生", "实", nullptr};
25  const float kZH2ndScores[] = {0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01};
26  const char *kViTops[] = {"v", "ậ", "y", " ", "t", "ộ", "i", nullptr};
27  const float kViTopScores[] = {0.98, 0.98, 0.98, 0.98, 0.98, 0.98, 0.97};
28  const char *kVi2nds[] = {"V", "a", "v", "", "l", "o", "", nullptr};
29  const float kVi2ndScores[] = {0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01};
30  class RecodeBeamTest : public ::testing::Test {
31  protected:
32    void SetUp() override {
33      std::locale::global(std::locale(""));
34      file::MakeTmpdir();
35    }
36    RecodeBeamTest() : lstm_dict_(&ccutil_) {}
37    ~RecodeBeamTest() override {
38      lstm_dict_.End();
39    }
40    void LoadUnicharset(const std::string &unicharset_name) {
41      std::string radical_stroke_file = file::JoinPath(LANGDATA_DIR, "radical-stroke.txt");
42      std::string unicharset_file = file::JoinPath(TESTDATA_DIR, unicharset_name);
43      std::string radical_data;
44      CHECK_OK(file::GetContents(radical_stroke_file, &radical_data, file::Defaults()));
45      CHECK(ccutil_.unicharset.load_from_file(unicharset_file.c_str()));
46      unichar_null_char_ =
47          ccutil_.unicharset.has_special_codes() ? UNICHAR_BROKEN : ccutil_.unicharset.size();
48      std::string radical_str(radical_data.c_str());
49      EXPECT_TRUE(recoder_.ComputeEncoding(ccutil_.unicharset, unichar_null_char_, &radical_str));
50      RecodedCharID code;
51      recoder_.EncodeUnichar(unichar_null_char_, &code);
52      encoded_null_char_ = code(0);
53      recoder_.EncodeUnichar(UNICHAR_SPACE, &code);
54      EXPECT_EQ(UNICHAR_SPACE, code(0));
55      std::string output_name = file::JoinPath(FLAGS_test_tmpdir, "testenc.txt");
56      std::string encoding = recoder_.GetEncodingAsString(ccutil_.unicharset);
57      std::string encoding_str(&encoding[0], encoding.size());
58      CHECK_OK(file::SetContents(output_name, encoding_str, file::Defaults()));
59      LOG(INFO) << "Wrote encoding to:" << output_name << "\n";
60    }
61    void LoadDict(const std::string &lang) {
62      std::string traineddata_name = lang + ".traineddata";
63      std::string traineddata_file = file::JoinPath(TESTDATA_DIR, traineddata_name);
64      lstm_dict_.SetupForLoad(nullptr);
65      tesseract::TessdataManager mgr;
66      mgr.Init(traineddata_file.c_str());
67      lstm_dict_.LoadLSTM(lang.c_str(), &mgr);
68      lstm_dict_.FinishLoad();
69    }
70    void ExpectCorrect(const GENERIC_2D_ARRAY<float> &output,
71                       const std::vector<int> &transcription) {
72      std::string truth_utf8;
73      for (int i : transcription) {
74        truth_utf8 += ccutil_.unicharset.id_to_unichar(i);
75      }
76      PointerVector<WERD_RES> words;
77      ExpectCorrect(output, truth_utf8, nullptr, &words);
78    }
79    void ExpectCorrect(const GENERIC_2D_ARRAY<float> &output, const std::string &truth_utf8,
80                       Dict *dict, PointerVector<WERD_RES> *words) {
81      RecodeBeamSearch beam_search(recoder_, encoded_null_char_, false, dict);
82      beam_search.Decode(output, 3.5, -0.125, -25.0, nullptr);
83      std::vector<int> labels, xcoords;
84      beam_search.ExtractBestPathAsLabels(&labels, &xcoords);
85      LOG(INFO) << "Labels size = " << labels.size() << " coords " << xcoords.size() << "\n";
86      std::string decoded;
87      int end = 1;
88      for (unsigned start = 0; start < labels.size(); start = end) {
89        RecodedCharID code;
90        unsigned index = start;
91        int uni_id = INVALID_UNICHAR_ID;
92        do {
93          code.Set(code.length(), labels[index++]);
94          uni_id = recoder_.DecodeUnichar(code);
95        } while (index < labels.size() && code.length() < RecodedCharID::kMaxCodeLen &&
96                 (uni_id == INVALID_UNICHAR_ID || !recoder_.IsValidFirstCode(labels[index])));
97        EXPECT_NE(INVALID_UNICHAR_ID, uni_id) << "index=" << index << "/" << labels.size();
98        if (uni_id != unichar_null_char_ && decoded.size() < truth_utf8.size()) {
99          decoded += ccutil_.unicharset.id_to_unichar(uni_id);
100        }
101        end = index;
102      }
103      EXPECT_EQ(truth_utf8, decoded);
104      std::vector<int> unichar_ids;
105      std::vector<float> certainties, ratings;
106      beam_search.ExtractBestPathAsUnicharIds(false, &ccutil_.unicharset, &unichar_ids, &certainties,
107                                              &ratings, &xcoords);
108      std::string u_decoded;
109      float total_rating = 0.0f;
110      for (unsigned u = 0; u < unichar_ids.size(); ++u) {
111        if (u_decoded.size() < truth_utf8.size()) {
112          const char *str = ccutil_.unicharset.id_to_unichar(unichar_ids[u]);
113          total_rating += ratings[u];
114          LOG(INFO) << u << ":u_id=" << unichar_ids[u] << "=" << str << ", c="
115            << certainties[u] << ", r=" << ratings[u] << "r_sum="
116            << total_rating << " @" << xcoords[u] << "\n";
117          if (str[0] == ' ') {
118            total_rating = 0.0f;
119          }
120          u_decoded += str;
121        }
122      }
123      EXPECT_EQ(truth_utf8, u_decoded);
124      TBOX line_box(0, 0, 100, 10);
125      for (int i = 0; i < 2; ++i) {
126        beam_search.ExtractBestPathAsWords(line_box, 1.0f, false, &ccutil_.unicharset, words);
127        std::string w_decoded;
128        for (int w = 0; w < words->size(); ++w) {
129          const WERD_RES *word = (*words)[w];
130          if (w_decoded.size() < truth_utf8.size()) {
131            if (!w_decoded.empty() && word->word->space()) {
132              w_decoded += " ";
133            }
134            w_decoded += word->best_choice->unichar_string().c_str();
135          }
136          LOG(INFO) << "Word:" << w << " = " << word->best_choice->unichar_string()
137            << ", c=" << word->best_choice->certainty() << ", r=" << word->best_choice->rating()
138            << ", perm=" << word->best_choice->permuter() << "\n";
139        }
140        std::string w_trunc(w_decoded.data(), truth_utf8.size());
141        if (truth_utf8 != w_trunc) {
142          tesseract::NormalizeUTF8String(
143              tesseract::UnicodeNormMode::kNFKD, tesseract::OCRNorm::kNormalize,
144              tesseract::GraphemeNorm::kNone, w_decoded.c_str(), &w_decoded);
145          w_trunc.assign(w_decoded.data(), truth_utf8.size());
146        }
147        EXPECT_EQ(truth_utf8, w_trunc);
148      }
<span onclick='openModal()' class='match'>149    }
150    GENERIC_2D_ARRAY<float> GenerateRandomPaddedOutputs(const std::vector<int> &unichar_ids,
151                                                        int padding) {
152      int width = unichar_ids.size() * 2 * RecodedCharID::kMaxCodeLen;
153      int num_codes = recoder_.code_range();
154      GENERIC_2D_ARRAY<float> outputs(width + padding, num_codes, 0.0f);
</span>155      TRand random;
156      for (int t = 0; t < width; ++t) {
157        for (int i = 0; i < num_codes; ++i) {
158          outputs(t, i) = random.UnsignedRand(0.25);
159        }
160      }
161      int t = 0;
162      for (int unichar_id : unichar_ids) {
163        RecodedCharID code;
164        int len = recoder_.EncodeUnichar(unichar_id, &code);
165        EXPECT_NE(0, len);
166        for (int j = 0; j < len; ++j) {
167          if (j > 0 && code(j) == code(j - 1)) {
168            outputs(t++, encoded_null_char_) = 1.0f;
169          }
170          outputs(t++, code(j)) = 1.0f;
171        }
172        outputs(t++, encoded_null_char_) = 1.0f;
173      }
174      for (int t = 0; t < width; ++t) {
175        double sum = 0.0;
176        for (int i = 0; i < num_codes; ++i) {
177          sum += outputs(t, i);
178        }
179        for (int i = 0; i < num_codes; ++i) {
180          outputs(t, i) /= sum;
181        }
182      }
183      return outputs;
184    }
185    int EncodeUTF8(const char *utf8_str, float score, int start_t, TRand *random,
186                   GENERIC_2D_ARRAY<float> *outputs) {
187      int t = start_t;
188      std::vector<int> unichar_ids;
189      EXPECT_TRUE(ccutil_.unicharset.encode_string(utf8_str, true, &unichar_ids, nullptr, nullptr));
190      if (unichar_ids.empty() || utf8_str[0] == '\0') {
191        unichar_ids.clear();
192        unichar_ids.push_back(unichar_null_char_);
193      }
194      int num_ids = unichar_ids.size();
195      for (int u = 0; u < num_ids; ++u) {
196        RecodedCharID code;
197        int len = recoder_.EncodeUnichar(unichar_ids[u], &code);
198        EXPECT_NE(0, len);
199        for (int i = 0; i < len; ++i) {
200          (*outputs)(t++, code(i)) = score;
201          if (random != nullptr && t + (num_ids - u) * RecodedCharID::kMaxCodeLen < outputs->dim1()) {
202            int dups = static_cast<int>(random->UnsignedRand(3.0));
203            for (int d = 0; d < dups; ++d) {
204              (*outputs)(t++, code(i)) = score;
205            }
206          }
207        }
208        if (random != nullptr && t + (num_ids - u) * RecodedCharID::kMaxCodeLen < outputs->dim1()) {
209          int dups = static_cast<int>(random->UnsignedRand(3.0));
210          for (int d = 0; d < dups; ++d) {
211            (*outputs)(t++, encoded_null_char_) = score;
212          }
213        }
214      }
215      return t;
216    }
217    GENERIC_2D_ARRAY<float> GenerateSyntheticOutputs(const char *chars1[], const float scores1[],
218                                                     const char *chars2[], const float scores2[],
219                                                     TRand *random) {
220      int width = 0;
221      while (chars1[width] != nullptr) {
222        ++width;
223      }
224      int padding = width * RecodedCharID::kMaxCodeLen;
225      int num_codes = recoder_.code_range();
226      GENERIC_2D_ARRAY<float> outputs(width + padding, num_codes, 0.0f);
227      int t = 0;
228      for (int i = 0; i < width; ++i) {
229        int end_t2 = EncodeUTF8(chars2[i], scores2[i], t, random, &outputs);
230        int end_t1 = EncodeUTF8(chars1[i], scores1[i], t, random, &outputs);
231        int max_t = std::max(end_t1, end_t2);
232        while (t < max_t) {
233          double total_score = 0.0;
234          for (int j = 0; j < num_codes; ++j) {
235            total_score += outputs(t, j);
236          }
237          double null_remainder = (1.0 - total_score) / 2.0;
238          double remainder = null_remainder / (num_codes - 2);
239          if (outputs(t, encoded_null_char_) < null_remainder) {
240            outputs(t, encoded_null_char_) += null_remainder;
241          } else {
242            remainder += remainder;
243          }
244          for (int j = 0; j < num_codes; ++j) {
245            if (outputs(t, j) == 0.0f) {
246              outputs(t, j) = remainder;
247            }
248          }
249          ++t;
250        }
251      }
252      while (t < width + padding) {
253        outputs(t++, encoded_null_char_) = 1.0f;
254      }
255      return outputs;
256    }
257    UnicharCompress recoder_;
258    int unichar_null_char_ = 0;
259    int encoded_null_char_ = 0;
260    CCUtil ccutil_;
261    Dict lstm_dict_;
262  };
263  TEST_F(RecodeBeamTest, DoesChinese) {
264    LOG(INFO) << "Testing chi_tra"
265              << "\n";
266    LoadUnicharset("chi_tra.unicharset");
267    std::vector<int> transcription;
268    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
269      transcription.push_back(i);
270    }
271    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
272    ExpectCorrect(outputs, transcription);
273    LOG(INFO) << "Testing chi_sim"
274              << "\n";
275    LoadUnicharset("chi_sim.unicharset");
276    transcription.clear();
277    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
278      transcription.push_back(i);
279    }
280    outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
281    ExpectCorrect(outputs, transcription);
282  }
283  TEST_F(RecodeBeamTest, DoesJapanese) {
284    LOG(INFO) << "Testing jpn"
285              << "\n";
286    LoadUnicharset("jpn.unicharset");
287    std::vector<int> transcription;
288    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
289      transcription.push_back(i);
290    }
291    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
292    ExpectCorrect(outputs, transcription);
293  }
294  TEST_F(RecodeBeamTest, DoesKorean) {
295    LOG(INFO) << "Testing kor"
296              << "\n";
297    LoadUnicharset("kor.unicharset");
298    std::vector<int> transcription;
299    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
300      transcription.push_back(i);
301    }
302    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
303    ExpectCorrect(outputs, transcription);
304  }
305  TEST_F(RecodeBeamTest, DoesKannada) {
306    LOG(INFO) << "Testing kan"
307              << "\n";
308    LoadUnicharset("kan.unicharset");
309    std::vector<int> transcription;
310    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
311      transcription.push_back(i);
312    }
313    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
314    ExpectCorrect(outputs, transcription);
315  }
316  TEST_F(RecodeBeamTest, DoesMarathi) {
317    LOG(INFO) << "Testing mar"
318              << "\n";
319    LoadUnicharset("mar.unicharset");
320    std::vector<int> transcription;
321    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
322      transcription.push_back(i);
323    }
324    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
325    ExpectCorrect(outputs, transcription);
326  }
327  TEST_F(RecodeBeamTest, DoesEnglish) {
328    LOG(INFO) << "Testing eng"
329              << "\n";
330    LoadUnicharset("eng.unicharset");
331    std::vector<int> transcription;
332    for (int i = SPECIAL_UNICHAR_CODES_COUNT; i < kNumChars; ++i) {
333      transcription.push_back(i);
334    }
335    GENERIC_2D_ARRAY<float> outputs = GenerateRandomPaddedOutputs(transcription, kPadding);
336    ExpectCorrect(outputs, transcription);
337  }
338  TEST_F(RecodeBeamTest, DISABLED_EngDictionary) {
339    LOG(INFO) << "Testing eng dictionary"
340              << "\n";
341    LoadUnicharset("eng_beam.unicharset");
342    GENERIC_2D_ARRAY<float> outputs =
343        GenerateSyntheticOutputs(kGWRTops, kGWRTopScores, kGWR2nds, kGWR2ndScores, nullptr);
344    std::string default_str;
345    for (int i = 0; kGWRTops[i] != nullptr; ++i) {
346      default_str += kGWRTops[i];
347    }
348    PointerVector<WERD_RES> words;
349    ExpectCorrect(outputs, default_str, nullptr, &words);
350    LoadDict("eng_beam");
351    ExpectCorrect(outputs, "Gets words right.", &lstm_dict_, &words);
352  }
353  TEST_F(RecodeBeamTest, DISABLED_ChiDictionary) {
354    LOG(INFO) << "Testing zh_hans dictionary"
355              << "\n";
356    LoadUnicharset("zh_hans.unicharset");
357    GENERIC_2D_ARRAY<float> outputs =
358        GenerateSyntheticOutputs(kZHTops, kZHTopScores, kZH2nds, kZH2ndScores, nullptr);
359    PointerVector<WERD_RES> words;
360    ExpectCorrect(outputs, "实学储啬投学生", nullptr, &words);
361    EXPECT_EQ(7, words.size());
362    for (int w = 0; w < words.size(); ++w) {
363      EXPECT_EQ(TOP_CHOICE_PERM, words[w]->best_choice->permuter());
364    }
365    LoadDict("zh_hans");
366    ExpectCorrect(outputs, "实学储啬投学生", &lstm_dict_, &words);
367    const int kNumWords = 5;
368    const char *kWords[kNumWords] = {"实学", "储", "啬", "投", "学生"};
369    const int kWordPerms[kNumWords] = {SYSTEM_DAWG_PERM, TOP_CHOICE_PERM, TOP_CHOICE_PERM,
370                                       TOP_CHOICE_PERM, SYSTEM_DAWG_PERM};
371    EXPECT_EQ(kNumWords, words.size());
372    for (int w = 0; w < kNumWords && w < words.size(); ++w) {
373      EXPECT_STREQ(kWords[w], words[w]->best_choice->unichar_string().c_str());
374      EXPECT_EQ(kWordPerms[w], words[w]->best_choice->permuter());
375    }
376  }
377  TEST_F(RecodeBeamTest, DISABLED_MultiCodeSequences) {
378    LOG(INFO) << "Testing duplicates in multi-code sequences"
379              << "\n";
380    LoadUnicharset("vie.d.unicharset");
381    tesseract::SetupBasicProperties(false, true, &ccutil_.unicharset);
382    TRand random;
383    GENERIC_2D_ARRAY<float> outputs =
384        GenerateSyntheticOutputs(kViTops, kViTopScores, kVi2nds, kVi2ndScores, &random);
385    PointerVector<WERD_RES> words;
386    std::string truth_str;
387    tesseract::NormalizeUTF8String(tesseract::UnicodeNormMode::kNFKC, tesseract::OCRNorm::kNormalize,
388                                   tesseract::GraphemeNorm::kNone, "vậy tội", &truth_str);
389    ExpectCorrect(outputs, truth_str, nullptr, &words);
390  }
391  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-difficulty.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-recodebeam_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>50  }
51  TEST (difficulty, overflow)
52  {
53  	{
54  		uint64_t base = std::numeric_limits<std::uint64_t>::max (); 
55  		uint64_t difficulty = std::numeric_limits<std::uint64_t>::max ();
56  		double multiplier = 1.001; 
</pre></code></div>
                <div class="column column_space"><pre><code>149    }
150    GENERIC_2D_ARRAY<float> GenerateRandomPaddedOutputs(const std::vector<int> &unichar_ids,
151                                                        int padding) {
152      int width = unichar_ids.size() * 2 * RecodedCharID::kMaxCodeLen;
153      int num_codes = recoder_.code_range();
154      GENERIC_2D_ARRAY<float> outputs(width + padding, num_codes, 0.0f);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    