
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.835190813914219%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_normalize_layer.cpp</h3>
            <pre><code>1  #include <cmath>
2  #include <cstring>
3  #include <vector>
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/normalize_layer.hpp"
8  #include "google/protobuf/text_format.h"
9  #include "gtest/gtest.h"
10  #include "caffe/test/test_caffe_main.hpp"
11  #include "caffe/test/test_gradient_check_util.hpp"
12  namespace caffe {
13  template <typename TypeParam>
14  class NormalizeLayerTest : public MultiDeviceTest<TypeParam> {
15    typedef typename TypeParam::Dtype Dtype;
16   protected:
17    NormalizeLayerTest()
18        : blob_bottom_(new Blob<Dtype>(2, 3, 2, 3)),
19          blob_top_(new Blob<Dtype>()) {
20      FillerParameter filler_param;
21      filler_param.set_value(1);
22      ConstantFiller<Dtype> filler(filler_param);
23      filler.Fill(this->blob_bottom_);
24      blob_bottom_vec_.push_back(blob_bottom_);
25      blob_top_vec_.push_back(blob_top_);
26    }
27    virtual ~NormalizeLayerTest() { delete blob_bottom_; delete blob_top_; }
28    Blob<Dtype>* const blob_bottom_;
29    Blob<Dtype>* const blob_top_;
30    vector<Blob<Dtype>*> blob_bottom_vec_;
31    vector<Blob<Dtype>*> blob_top_vec_;
32  };
33  TYPED_TEST_CASE(NormalizeLayerTest, TestDtypesAndDevices);
34  TYPED_TEST(NormalizeLayerTest, TestForward) {
35    typedef typename TypeParam::Dtype Dtype;
36    LayerParameter layer_param;
37    NormalizeLayer<Dtype> layer(layer_param);
38    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
39    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
40    int num = this->blob_bottom_->num();
41    int channels = this->blob_bottom_->channels();
42    int height = this->blob_bottom_->height();
43    int width = this->blob_bottom_->width();
44    for (int i = 0; i < num; ++i) {
45      Dtype norm = 0;
46      for (int j = 0; j < channels; ++j) {
47        for (int k = 0; k < height; ++k) {
48          for (int l = 0; l < width; ++l) {
49            Dtype data = this->blob_top_->data_at(i, j, k, l);
50            norm += data * data;
51          }
52        }
53      }
54      const Dtype kErrorBound = 1e-5;
55      EXPECT_NEAR(1, sqrt(norm), kErrorBound);
56    }
57  }
58  TYPED_TEST(NormalizeLayerTest, TestForwardScale) {
59    typedef typename TypeParam::Dtype Dtype;
60    LayerParameter layer_param;
61    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
62    norm_param->mutable_scale_filler()->set_type("constant");
63    norm_param->mutable_scale_filler()->set_value(10);
64    NormalizeLayer<Dtype> layer(layer_param);
<span onclick='openModal()' class='match'>65    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
66    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
67    int num = this->blob_bottom_->num();
68    int channels = this->blob_bottom_->channels();
69    int height = this->blob_bottom_->height();
70    int width = this->blob_bottom_->width();
</span>71    for (int i = 0; i < num; ++i) {
72      Dtype norm = 0;
73      for (int j = 0; j < channels; ++j) {
74        for (int k = 0; k < height; ++k) {
75          for (int l = 0; l < width; ++l) {
76            Dtype data = this->blob_top_->data_at(i, j, k, l);
77            norm += data * data;
78          }
79        }
80      }
81      const Dtype kErrorBound = 1e-5;
82      EXPECT_NEAR(10, sqrt(norm), kErrorBound);
83    }
84  }
85  TYPED_TEST(NormalizeLayerTest, TestForwardScaleChannels) {
86    typedef typename TypeParam::Dtype Dtype;
87    LayerParameter layer_param;
88    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
89    norm_param->set_channel_shared(false);
90    norm_param->mutable_scale_filler()->set_type("constant");
91    norm_param->mutable_scale_filler()->set_value(10);
92    NormalizeLayer<Dtype> layer(layer_param);
93    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
94    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
95    int num = this->blob_bottom_->num();
96    int channels = this->blob_bottom_->channels();
97    int height = this->blob_bottom_->height();
98    int width = this->blob_bottom_->width();
99    for (int i = 0; i < num; ++i) {
100      Dtype norm = 0;
101      for (int j = 0; j < channels; ++j) {
102        for (int k = 0; k < height; ++k) {
103          for (int l = 0; l < width; ++l) {
104            Dtype data = this->blob_top_->data_at(i, j, k, l);
105            norm += data * data;
106          }
107        }
108      }
109      const Dtype kErrorBound = 1e-5;
110      EXPECT_NEAR(10, sqrt(norm), kErrorBound);
111    }
112  }
113  TYPED_TEST(NormalizeLayerTest, TestForwardEltWise) {
114    typedef typename TypeParam::Dtype Dtype;
115    LayerParameter layer_param;
116    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
117    norm_param->set_across_spatial(false);
118    NormalizeLayer<Dtype> layer(layer_param);
119    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
120    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
121    int num = this->blob_bottom_->num();
122    int channels = this->blob_bottom_->channels();
123    int height = this->blob_bottom_->height();
124    int width = this->blob_bottom_->width();
125    for (int i = 0; i < num; ++i) {
126      for (int k = 0; k < height; ++k) {
127        for (int l = 0; l < width; ++l) {
128          Dtype norm = 0;
129          for (int j = 0; j < channels; ++j) {
130            Dtype data = this->blob_top_->data_at(i, j, k, l);
131            norm += data * data;
132          }
133          const Dtype kErrorBound = 1e-5;
134          EXPECT_NEAR(1, sqrt(norm), kErrorBound);
135        }
136      }
137    }
138  }
139  TYPED_TEST(NormalizeLayerTest, TestForwardEltWiseScale) {
140    typedef typename TypeParam::Dtype Dtype;
141    LayerParameter layer_param;
142    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
143    norm_param->set_across_spatial(false);
144    norm_param->mutable_scale_filler()->set_type("constant");
145    norm_param->mutable_scale_filler()->set_value(10);
146    NormalizeLayer<Dtype> layer(layer_param);
147    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
148    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
149    int num = this->blob_bottom_->num();
150    int channels = this->blob_bottom_->channels();
151    int height = this->blob_bottom_->height();
152    int width = this->blob_bottom_->width();
153    for (int i = 0; i < num; ++i) {
154      for (int k = 0; k < height; ++k) {
155        for (int l = 0; l < width; ++l) {
156          Dtype norm = 0;
157          for (int j = 0; j < channels; ++j) {
158            Dtype data = this->blob_top_->data_at(i, j, k, l);
159            norm += data * data;
160          }
161          const Dtype kErrorBound = 1e-5;
162          EXPECT_NEAR(10, sqrt(norm), kErrorBound);
163        }
164      }
165    }
166  }
167  TYPED_TEST(NormalizeLayerTest, TestForwardEltWiseScaleChannel) {
168    typedef typename TypeParam::Dtype Dtype;
169    LayerParameter layer_param;
170    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
171    norm_param->set_across_spatial(false);
172    norm_param->set_channel_shared(false);
173    norm_param->mutable_scale_filler()->set_type("constant");
174    norm_param->mutable_scale_filler()->set_value(10);
175    NormalizeLayer<Dtype> layer(layer_param);
176    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
177    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
178    int num = this->blob_bottom_->num();
179    int channels = this->blob_bottom_->channels();
180    int height = this->blob_bottom_->height();
181    int width = this->blob_bottom_->width();
182    for (int i = 0; i < num; ++i) {
183      for (int k = 0; k < height; ++k) {
184        for (int l = 0; l < width; ++l) {
185          Dtype norm = 0;
186          for (int j = 0; j < channels; ++j) {
187            Dtype data = this->blob_top_->data_at(i, j, k, l);
188            norm += data * data;
189          }
190          const Dtype kErrorBound = 1e-5;
191          EXPECT_NEAR(10, sqrt(norm), kErrorBound);
192        }
193      }
194    }
195  }
196  TYPED_TEST(NormalizeLayerTest, TestGradient) {
197    typedef typename TypeParam::Dtype Dtype;
198    LayerParameter layer_param;
199    NormalizeLayer<Dtype> layer(layer_param);
200    GradientChecker<Dtype> checker(1e-2, 1e-3);
201    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
202        this->blob_top_vec_, 0);
203  }
204  TYPED_TEST(NormalizeLayerTest, TestGradientScale) {
205    typedef typename TypeParam::Dtype Dtype;
206    LayerParameter layer_param;
207    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
208    norm_param->mutable_scale_filler()->set_type("constant");
209    norm_param->mutable_scale_filler()->set_value(3);
210    NormalizeLayer<Dtype> layer(layer_param);
211    GradientChecker<Dtype> checker(1e-2, 1e-3);
212    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
213        this->blob_top_vec_);
214  }
215  TYPED_TEST(NormalizeLayerTest, TestGradientScaleChannel) {
216    typedef typename TypeParam::Dtype Dtype;
217    LayerParameter layer_param;
218    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
219    norm_param->set_channel_shared(false);
220    norm_param->mutable_scale_filler()->set_type("constant");
221    norm_param->mutable_scale_filler()->set_value(3);
222    NormalizeLayer<Dtype> layer(layer_param);
223    GradientChecker<Dtype> checker(1e-2, 1e-3);
224    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
225        this->blob_top_vec_);
226  }
227  TYPED_TEST(NormalizeLayerTest, TestGradientEltWise) {
228    typedef typename TypeParam::Dtype Dtype;
229    LayerParameter layer_param;
230    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
231    norm_param->set_across_spatial(false);
232    NormalizeLayer<Dtype> layer(layer_param);
233    GradientChecker<Dtype> checker(1e-3, 1e-3);
234    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
235        this->blob_top_vec_);
236  }
237  TYPED_TEST(NormalizeLayerTest, TestGradientEltWiseScale) {
238    typedef typename TypeParam::Dtype Dtype;
239    LayerParameter layer_param;
240    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
241    norm_param->set_across_spatial(false);
242    norm_param->mutable_scale_filler()->set_type("constant");
243    norm_param->mutable_scale_filler()->set_value(3);
244    NormalizeLayer<Dtype> layer(layer_param);
245    GradientChecker<Dtype> checker(1e-3, 2e-3);
246    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
247        this->blob_top_vec_);
248  }
249  TYPED_TEST(NormalizeLayerTest, TestGradientEltWiseScaleChannel) {
250    typedef typename TypeParam::Dtype Dtype;
251    LayerParameter layer_param;
252    NormalizeParameter* norm_param = layer_param.mutable_norm_param();
253    norm_param->set_across_spatial(false);
254    norm_param->set_channel_shared(false);
255    norm_param->mutable_scale_filler()->set_type("constant");
256    norm_param->mutable_scale_filler()->set_value(3);
257    NormalizeLayer<Dtype> layer(layer_param);
258    GradientChecker<Dtype> checker(1e-3, 2e-3);
259    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
260        this->blob_top_vec_);
261  }
262  }  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "strokewidth.h"
5  #include <algorithm>
6  #include <cmath>
7  #include "blobbox.h"
8  #include "colpartition.h"
9  #include "colpartitiongrid.h"
10  #include "helpers.h" 
11  #include "imagefind.h"
12  #include "linlsq.h"
13  #include "statistc.h"
14  #include "tabfind.h"
15  #include "textlineprojection.h"
16  #include "tordmain.h" 
17  namespace tesseract {
18  #ifndef GRAPHICS_DISABLED
19  static INT_VAR(textord_tabfind_show_strokewidths, 0, "Show stroke widths (ScrollView)");
20  #else
21  static INT_VAR(textord_tabfind_show_strokewidths, 0, "Show stroke widths");
22  #endif
23  static BOOL_VAR(textord_tabfind_only_strokewidths, false, "Only run stroke widths");
24  const double kStrokeWidthFractionTolerance = 0.125;
25  const double kStrokeWidthTolerance = 1.5;
26  const double kStrokeWidthFractionCJK = 0.25;
27  const double kStrokeWidthCJK = 2.0;
28  const int kCJKRadius = 2;
29  const double kCJKBrokenDistanceFraction = 0.25;
30  const int kCJKMaxComponents = 8;
31  const double kCJKAspectRatio = 1.25;
32  const double kCJKAspectRatioIncrease = 1.0625;
33  const int kMaxCJKSizeRatio = 5;
34  const double kBrokenCJKIterationFraction = 0.125;
35  const double kDiacriticXPadRatio = 7.0;
36  const double kDiacriticYPadRatio = 1.75;
37  const double kMinDiacriticSizeRatio = 1.0625;
38  const double kMaxDiacriticDistanceRatio = 1.25;
39  const double kMaxDiacriticGapToBaseCharHeight = 1.0;
40  const int kLineTrapLongest = 4;
41  const int kLineTrapShortest = 2;
42  const int kMostlyOneDirRatio = 3;
43  const double kLineResidueAspectRatio = 8.0;
44  const int kLineResiduePadRatio = 3;
45  const double kLineResidueSizeRatio = 1.75;
46  const float kSizeRatioToReject = 2.0;
47  const double kNeighbourSearchFactor = 2.5;
48  const double kNoiseOverlapGrowthFactor = 4.0;
49  const double kNoiseOverlapAreaFactor = 1.0 / 512;
50  StrokeWidth::StrokeWidth(int gridsize, const ICOORD &bleft, const ICOORD &tright)
51      : BlobGrid(gridsize, bleft, tright)
52      , nontext_map_(nullptr)
53      , projection_(nullptr)
54      , denorm_(nullptr)
55      , grid_box_(bleft, tright)
56      , rerotation_(1.0f, 0.0f) {
57  }
58  StrokeWidth::~StrokeWidth() {
59  #ifndef GRAPHICS_DISABLED
60    if (widths_win_ != nullptr) {
61      widths_win_->AwaitEvent(SVET_DESTROY);
62      if (textord_tabfind_only_strokewidths) {
63        exit(0);
64      }
65      delete widths_win_;
66    }
67    delete leaders_win_;
68    delete initial_widths_win_;
69    delete chains_win_;
70    delete textlines_win_;
71    delete smoothed_win_;
72    delete diacritics_win_;
73  #endif
74  }
75  void StrokeWidth::SetNeighboursOnMediumBlobs(TO_BLOCK *block) {
76    InsertBlobList(&block->blobs);
77    BLOBNBOX_IT blob_it(&block->blobs);
78    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
79      SetNeighbours(false, false, blob_it.data());
80    }
81    Clear();
82  }
83  void StrokeWidth::FindTextlineDirectionAndFixBrokenCJK(PageSegMode pageseg_mode, bool cjk_merge,
84                                                         TO_BLOCK *input_block) {
85    InsertBlobs(input_block);
86    while (cjk_merge && FixBrokenCJK(input_block)) {
87    }
88    FindTextlineFlowDirection(pageseg_mode, false);
89    Clear();
90  }
91  static void CollectHorizVertBlobs(BLOBNBOX_LIST *input_blobs, int *num_vertical_blobs,
92                                    int *num_horizontal_blobs, BLOBNBOX_CLIST *vertical_blobs,
93                                    BLOBNBOX_CLIST *horizontal_blobs,
94                                    BLOBNBOX_CLIST *nondescript_blobs) {
95    BLOBNBOX_C_IT v_it(vertical_blobs);
96    BLOBNBOX_C_IT h_it(horizontal_blobs);
97    BLOBNBOX_C_IT n_it(nondescript_blobs);
98    BLOBNBOX_IT blob_it(input_blobs);
<span onclick='openModal()' class='match'>99    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
100      BLOBNBOX *blob = blob_it.data();
101      const TBOX &box = blob->bounding_box();
102      float y_x = static_cast<float>(box.height()) / box.width();
</span>103      float x_y = 1.0f / y_x;
104      float ratio = x_y > y_x ? x_y : y_x;
105      bool ok_blob = ratio <= kSizeRatioToReject;
106      if (blob->UniquelyVertical()) {
107        ++*num_vertical_blobs;
108        if (ok_blob) {
109          v_it.add_after_then_move(blob);
110        }
111      } else if (blob->UniquelyHorizontal()) {
112        ++*num_horizontal_blobs;
113        if (ok_blob) {
114          h_it.add_after_then_move(blob);
115        }
116      } else if (ok_blob) {
117        n_it.add_after_then_move(blob);
118      }
119    }
120  }
121  bool StrokeWidth::TestVerticalTextDirection(double find_vertical_text_ratio, TO_BLOCK *block,
122                                              BLOBNBOX_CLIST *osd_blobs) {
123    int vertical_boxes = 0;
124    int horizontal_boxes = 0;
125    BLOBNBOX_CLIST vertical_blobs;
126    BLOBNBOX_CLIST horizontal_blobs;
127    BLOBNBOX_CLIST nondescript_blobs;
128    CollectHorizVertBlobs(&block->blobs, &vertical_boxes, &horizontal_boxes, &vertical_blobs,
129                          &horizontal_blobs, &nondescript_blobs);
130    CollectHorizVertBlobs(&block->large_blobs, &vertical_boxes, &horizontal_boxes, &vertical_blobs,
131                          &horizontal_blobs, &nondescript_blobs);
132    if (textord_debug_tabfind) {
133      tprintf("TextDir hbox=%d vs vbox=%d, %dH, %dV, %dN osd blobs\n", horizontal_boxes,
134              vertical_boxes, horizontal_blobs.length(), vertical_blobs.length(),
135              nondescript_blobs.length());
136    }
137    if (osd_blobs != nullptr && vertical_boxes == 0 && horizontal_boxes == 0) {
138      BLOBNBOX_C_IT osd_it(osd_blobs);
139      osd_it.add_list_after(&nondescript_blobs);
140      return false;
141    }
142    int min_vert_boxes =
143        static_cast<int>((vertical_boxes + horizontal_boxes) * find_vertical_text_ratio);
144    if (vertical_boxes >= min_vert_boxes) {
145      if (osd_blobs != nullptr) {
146        BLOBNBOX_C_IT osd_it(osd_blobs);
147        osd_it.add_list_after(&vertical_blobs);
148      }
149      return true;
150    } else {
151      if (osd_blobs != nullptr) {
152        BLOBNBOX_C_IT osd_it(osd_blobs);
153        osd_it.add_list_after(&horizontal_blobs);
154      }
155      return false;
156    }
157  }
158  void StrokeWidth::CorrectForRotation(const FCOORD &rotation, ColPartitionGrid *part_grid) {
159    Init(part_grid->gridsize(), part_grid->bleft(), part_grid->tright());
160    grid_box_ = TBOX(bleft(), tright());
161    rerotation_.set_x(rotation.x());
162    rerotation_.set_y(-rotation.y());
163  }
164  void StrokeWidth::FindLeaderPartitions(TO_BLOCK *block, ColPartitionGrid *part_grid) {
165    Clear();
166    ColPartition_LIST leader_parts;
167    FindLeadersAndMarkNoise(block, &leader_parts);
168    InsertBlobList(&block->blobs);
169    for (ColPartition_IT it(&leader_parts); !it.empty(); it.forward()) {
170      ColPartition *part = it.extract();
171      part->ClaimBoxes();
172      MarkLeaderNeighbours(part, LR_LEFT);
173      MarkLeaderNeighbours(part, LR_RIGHT);
174      part_grid->InsertBBox(true, true, part);
175    }
176  }
177  void StrokeWidth::RemoveLineResidue(ColPartition_LIST *big_part_list) {
178    BlobGridSearch gsearch(this);
179    BLOBNBOX *bbox;
180    gsearch.StartFullSearch();
181    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
182      TBOX box = bbox->bounding_box();
183      if (box.height() < box.width() * kLineResidueAspectRatio) {
184        continue;
185      }
186      int padding = box.height() * kLineResiduePadRatio;
187      TBOX search_box = box;
188      search_box.pad(padding, padding);
189      bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
190      BlobGridSearch rsearch(this);
191      int max_height = 0;
192      BLOBNBOX *n;
193      rsearch.StartRectSearch(search_box);
194      while ((n = rsearch.NextRectSearch()) != nullptr) {
195        if (n == bbox) {
196          continue;
197        }
198        TBOX nbox = n->bounding_box();
199        if (nbox.height() > max_height) {
200          max_height = nbox.height();
201        }
202      }
203      if (debug) {
204        tprintf("Max neighbour size=%d for candidate line box at:", max_height);
205        box.print();
206      }
207      if (max_height * kLineResidueSizeRatio < box.height()) {
208  #ifndef GRAPHICS_DISABLED
209        if (leaders_win_ != nullptr) {
210          leaders_win_->Pen(ScrollView::PINK);
211          leaders_win_->Rectangle(box.left(), box.bottom(), box.right(), box.top());
212        }
213  #endif 
214        ColPartition::MakeBigPartition(bbox, big_part_list);
215      }
216    }
217  }
218  void StrokeWidth::GradeBlobsIntoPartitions(PageSegMode pageseg_mode, const FCOORD &rerotation,
219                                             TO_BLOCK *block, Image nontext_pix, const DENORM *denorm,
220                                             bool cjk_script, TextlineProjection *projection,
221                                             BLOBNBOX_LIST *diacritic_blobs,
222                                             ColPartitionGrid *part_grid,
223                                             ColPartition_LIST *big_parts) {
224    nontext_map_ = nontext_pix;
225    projection_ = projection;
226    denorm_ = denorm;
227    Clear();
228    InsertBlobs(block);
229    if (cjk_script) {
230      FixBrokenCJK(block);
231    }
232    FindTextlineFlowDirection(pageseg_mode, false);
233    projection_->ConstructProjection(block, rerotation, nontext_map_);
234  #ifndef GRAPHICS_DISABLED
235    if (textord_tabfind_show_strokewidths) {
236      ScrollView *line_blobs_win = MakeWindow(0, 0, "Initial textline Blobs");
237      projection_->PlotGradedBlobs(&block->blobs, line_blobs_win);
238      projection_->PlotGradedBlobs(&block->small_blobs, line_blobs_win);
239    }
240  #endif
241    projection_->MoveNonTextlineBlobs(&block->blobs, &block->noise_blobs);
242    projection_->MoveNonTextlineBlobs(&block->small_blobs, &block->noise_blobs);
243    Clear();
244    InsertBlobs(block);
245    FCOORD skew;
246    FindTextlineFlowDirection(pageseg_mode, true);
247    PartitionFindResult r = FindInitialPartitions(pageseg_mode, rerotation, true, block,
248                                                  diacritic_blobs, part_grid, big_parts, &skew);
249    if (r == PFR_NOISE) {
250      tprintf("Detected %d diacritics\n", diacritic_blobs->length());
251      Clear();
252      InsertBlobs(block);
253      FindTextlineFlowDirection(pageseg_mode, true);
254      r = FindInitialPartitions(pageseg_mode, rerotation, false, block, diacritic_blobs, part_grid,
255                                big_parts, &skew);
256    }
257    nontext_map_ = nullptr;
258    projection_ = nullptr;
259    denorm_ = nullptr;
260  }
261  static void PrintBoxWidths(BLOBNBOX *neighbour) {
262    const TBOX &nbox = neighbour->bounding_box();
263    tprintf("Box (%d,%d)->(%d,%d): h-width=%.1f, v-width=%.1f p-width=%1.f\n", nbox.left(),
264            nbox.bottom(), nbox.right(), nbox.top(), neighbour->horz_stroke_width(),
265            neighbour->vert_stroke_width(),
266            2.0 * neighbour->cblob()->area() / neighbour->cblob()->perimeter());
267  }
268  void StrokeWidth::HandleClick(int x, int y) {
269    BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>::HandleClick(x, y);
270    BlobGridSearch radsearch(this);
271    radsearch.StartRadSearch(x, y, 1);
272    BLOBNBOX *neighbour;
273    FCOORD click(static_cast<float>(x), static_cast<float>(y));
274    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
275      TBOX nbox = neighbour->bounding_box();
276      if (nbox.contains(click) && neighbour->cblob() != nullptr) {
277        PrintBoxWidths(neighbour);
278        if (neighbour->neighbour(BND_LEFT) != nullptr) {
279          PrintBoxWidths(neighbour->neighbour(BND_LEFT));
280        }
281        if (neighbour->neighbour(BND_RIGHT) != nullptr) {
282          PrintBoxWidths(neighbour->neighbour(BND_RIGHT));
283        }
284        if (neighbour->neighbour(BND_ABOVE) != nullptr) {
285          PrintBoxWidths(neighbour->neighbour(BND_ABOVE));
286        }
287        if (neighbour->neighbour(BND_BELOW) != nullptr) {
288          PrintBoxWidths(neighbour->neighbour(BND_BELOW));
289        }
290        int gaps[BND_COUNT];
291        neighbour->NeighbourGaps(gaps);
292        tprintf(
293            "Left gap=%d, right=%d, above=%d, below=%d, horz=%d, vert=%d\n"
294            "Good=    %d        %d        %d        %d\n",
295            gaps[BND_LEFT], gaps[BND_RIGHT], gaps[BND_ABOVE], gaps[BND_BELOW],
296            neighbour->horz_possible(), neighbour->vert_possible(),
297            neighbour->good_stroke_neighbour(BND_LEFT), neighbour->good_stroke_neighbour(BND_RIGHT),
298            neighbour->good_stroke_neighbour(BND_ABOVE), neighbour->good_stroke_neighbour(BND_BELOW));
299        break;
300      }
301    }
302  }
303  void StrokeWidth::FindLeadersAndMarkNoise(TO_BLOCK *block, ColPartition_LIST *leader_parts) {
304    InsertBlobList(&block->small_blobs);
305    InsertBlobList(&block->noise_blobs);
306    BlobGridSearch gsearch(this);
307    BLOBNBOX *bbox;
308    gsearch.StartFullSearch();
309    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
310      SetNeighbours(true, false, bbox);
311    }
312    ColPartition_IT part_it(leader_parts);
313    gsearch.StartFullSearch();
314    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
315      if (bbox->flow() == BTFT_NONE) {
316        if (bbox->neighbour(BND_RIGHT) == nullptr && bbox->neighbour(BND_LEFT) == nullptr) {
317          continue;
318        }
319        auto *part = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
320        BLOBNBOX *blob;
321        for (blob = bbox; blob != nullptr && blob->flow() == BTFT_NONE;
322             blob = blob->neighbour(BND_RIGHT)) {
323          part->AddBox(blob);
324        }
325        for (blob = bbox->neighbour(BND_LEFT); blob != nullptr && blob->flow() == BTFT_NONE;
326             blob = blob->neighbour(BND_LEFT)) {
327          part->AddBox(blob);
328        }
329        if (part->MarkAsLeaderIfMonospaced()) {
330          part_it.add_after_then_move(part);
331        } else {
332          delete part;
333        }
334      }
335    }
336  #ifndef GRAPHICS_DISABLED
337    if (textord_tabfind_show_strokewidths) {
338      leaders_win_ = DisplayGoodBlobs("LeaderNeighbours", 0, 0);
339    }
340  #endif
341    BLOBNBOX_IT blob_it(&block->blobs);
342    BLOBNBOX_IT small_it(&block->small_blobs);
343    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
344      BLOBNBOX *blob = small_it.data();
345      if (blob->flow() != BTFT_LEADER) {
346        if (blob->flow() == BTFT_NEIGHBOURS) {
347          blob->set_flow(BTFT_NONE);
348        }
349        blob->ClearNeighbours();
350        blob_it.add_to_end(small_it.extract());
351      }
352    }
353    BLOBNBOX_IT noise_it(&block->noise_blobs);
354    for (noise_it.mark_cycle_pt(); !noise_it.cycled_list(); noise_it.forward()) {
355      BLOBNBOX *blob = noise_it.data();
356      if (blob->flow() == BTFT_LEADER || blob->joined_to_prev()) {
357        small_it.add_to_end(noise_it.extract());
358      } else if (blob->flow() == BTFT_NEIGHBOURS) {
359        blob->set_flow(BTFT_NONE);
360        blob->ClearNeighbours();
361      }
362    }
363    Clear();
364  }
365  void StrokeWidth::InsertBlobs(TO_BLOCK *block) {
366    InsertBlobList(&block->blobs);
367    InsertBlobList(&block->large_blobs);
368  }
369  void StrokeWidth::MarkLeaderNeighbours(const ColPartition *part, LeftOrRight side) {
370    const TBOX &part_box = part->bounding_box();
371    BlobGridSearch blobsearch(this);
372    BLOBNBOX *best_blob = nullptr;
373    int best_gap = 0;
374    blobsearch.StartSideSearch(side == LR_LEFT ? part_box.left() : part_box.right(),
375                               part_box.bottom(), part_box.top());
376    BLOBNBOX *blob;
377    while ((blob = blobsearch.NextSideSearch(side == LR_LEFT)) != nullptr) {
378      const TBOX &blob_box = blob->bounding_box();
379      if (!blob_box.y_overlap(part_box)) {
380        continue;
381      }
382      int x_gap = blob_box.x_gap(part_box);
383      if (x_gap > 2 * gridsize()) {
384        break;
385      } else if (best_blob == nullptr || x_gap < best_gap) {
386        best_blob = blob;
387        best_gap = x_gap;
388      }
389    }
390    if (best_blob != nullptr) {
391      if (side == LR_LEFT) {
392        best_blob->set_leader_on_right(true);
393      } else {
394        best_blob->set_leader_on_left(true);
395      }
396  #ifndef GRAPHICS_DISABLED
397      if (leaders_win_ != nullptr) {
398        leaders_win_->Pen(side == LR_LEFT ? ScrollView::RED : ScrollView::GREEN);
399        const TBOX &blob_box = best_blob->bounding_box();
400        leaders_win_->Rectangle(blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
401      }
402  #endif 
403    }
404  }
405  static int UpperQuartileCJKSize(int gridsize, BLOBNBOX_LIST *blobs) {
406    STATS sizes(0, gridsize * kMaxCJKSizeRatio - 1);
407    BLOBNBOX_IT it(blobs);
408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
409      BLOBNBOX *blob = it.data();
410      int width = blob->bounding_box().width();
411      int height = blob->bounding_box().height();
412      if (width <= height * kCJKAspectRatio && height < width * kCJKAspectRatio) {
413        sizes.add(height, 1);
414      }
415    }
416    return static_cast<int>(sizes.ile(0.75f) + 0.5);
417  }
418  bool StrokeWidth::FixBrokenCJK(TO_BLOCK *block) {
419    BLOBNBOX_LIST *blobs = &block->blobs;
420    int median_height = UpperQuartileCJKSize(gridsize(), blobs);
421    int max_dist = static_cast<int>(median_height * kCJKBrokenDistanceFraction);
422    int max_height = static_cast<int>(median_height * kCJKAspectRatio);
423    int num_fixed = 0;
424    BLOBNBOX_IT blob_it(blobs);
425    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
426      BLOBNBOX *blob = blob_it.data();
427      if (blob->cblob() == nullptr || blob->cblob()->out_list()->empty()) {
428        continue;
429      }
430      TBOX bbox = blob->bounding_box();
431      bool debug = AlignedBlob::WithinTestRegion(3, bbox.left(), bbox.bottom());
432      if (debug) {
433        tprintf("Checking for Broken CJK (max size=%d):", max_height);
434        bbox.print();
435      }
436      BLOBNBOX_CLIST overlapped_blobs;
437      AccumulateOverlaps(blob, debug, max_height, max_dist, &bbox, &overlapped_blobs);
438      if (!overlapped_blobs.empty()) {
439        if (bbox.width() > bbox.height() * kCJKAspectRatio ||
440            bbox.height() > bbox.width() * kCJKAspectRatio) {
441          if (debug) {
442            tprintf("Bad final aspectratio:");
443            bbox.print();
444          }
445          continue;
446        }
447        if (overlapped_blobs.length() >= kCJKMaxComponents) {
448          if (debug) {
449            tprintf("Too many neighbours: %d\n", overlapped_blobs.length());
450          }
451          continue;
452        }
453        BLOBNBOX_C_IT n_it(&overlapped_blobs);
454        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
455          BLOBNBOX *neighbour = nullptr;
456          neighbour = n_it.data();
457          if (!blob->MatchingStrokeWidth(*neighbour, kStrokeWidthFractionCJK, kStrokeWidthCJK)) {
458            break;
459          }
460        }
461        if (!n_it.cycled_list()) {
462          if (debug) {
463            tprintf("Bad stroke widths:");
464            PrintBoxWidths(blob);
465          }
466          continue; 
467        }
468        RemoveBBox(blob);
469        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
470          BLOBNBOX *neighbour = n_it.data();
471          RemoveBBox(neighbour);
472          neighbour->set_region_type(BRT_NOISE);
473          blob->really_merge(neighbour);
474          if (rerotation_.x() != 1.0f || rerotation_.y() != 0.0f) {
475            blob->rotate_box(rerotation_);
476          }
477        }
478        InsertBBox(true, true, blob);
479        ++num_fixed;
480        if (debug) {
481          tprintf("Done! Final box:");
482          bbox.print();
483        }
484      }
485    }
486    int num_remaining = 0;
487    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
488      BLOBNBOX *blob = blob_it.data();
489      if (blob->cblob() != nullptr && !blob->cblob()->out_list()->empty()) {
490        ++num_remaining;
491      }
492    }
493    block->DeleteUnownedNoise();
494    return num_fixed > num_remaining * kBrokenCJKIterationFraction;
495  }
496  static bool AcceptableCJKMerge(const TBOX &bbox, const TBOX &nbox, bool debug, int max_size,
497                                 int max_dist, int *x_gap, int *y_gap) {
498    *x_gap = bbox.x_gap(nbox);
499    *y_gap = bbox.y_gap(nbox);
500    TBOX merged(nbox);
501    merged += bbox;
502    if (debug) {
503      tprintf("gaps = %d, %d, merged_box:", *x_gap, *y_gap);
504      merged.print();
505    }
506    if (*x_gap <= max_dist && *y_gap <= max_dist && merged.width() <= max_size &&
507        merged.height() <= max_size) {
508      double old_ratio = static_cast<double>(bbox.width()) / bbox.height();
509      if (old_ratio < 1.0) {
510        old_ratio = 1.0 / old_ratio;
511      }
512      double new_ratio = static_cast<double>(merged.width()) / merged.height();
513      if (new_ratio < 1.0) {
514        new_ratio = 1.0 / new_ratio;
515      }
516      if (new_ratio <= old_ratio * kCJKAspectRatioIncrease) {
517        return true;
518      }
519    }
520    return false;
521  }
522  void StrokeWidth::AccumulateOverlaps(const BLOBNBOX *not_this, bool debug, int max_size,
523                                       int max_dist, TBOX *bbox, BLOBNBOX_CLIST *blobs) {
524    BLOBNBOX *nearests[BND_COUNT];
525    for (auto &nearest : nearests) {
526      nearest = nullptr;
527    }
528    int x = (bbox->left() + bbox->right()) / 2;
529    int y = (bbox->bottom() + bbox->top()) / 2;
530    BlobGridSearch radsearch(this);
531    radsearch.StartRadSearch(x, y, kCJKRadius);
532    BLOBNBOX *neighbour;
533    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
534      if (neighbour == not_this) {
535        continue;
536      }
537      TBOX nbox = neighbour->bounding_box();
538      int x_gap, y_gap;
539      if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &x_gap, &y_gap)) {
540        *bbox += nbox;
541        blobs->add_sorted(SortByBoxLeft<BLOBNBOX>, true, neighbour);
542        if (debug) {
543          tprintf("Added:");
544          nbox.print();
545        }
546        for (int dir = 0; dir < BND_COUNT; ++dir) {
547          if (nearests[dir] == nullptr) {
548            continue;
549          }
550          nbox = nearests[dir]->bounding_box();
551          if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &x_gap, &y_gap)) {
552            *bbox += nbox;
553            blobs->add_sorted(SortByBoxLeft<BLOBNBOX>, true, nearests[dir]);
554            if (debug) {
555              tprintf("Added:");
556              nbox.print();
557            }
558            nearests[dir] = nullptr;
559            dir = -1; 
560          }
561        }
562      } else if (x_gap < 0 && x_gap <= y_gap) {
563        BlobNeighbourDir dir = nbox.top() > bbox->top() ? BND_ABOVE : BND_BELOW;
564        if (nearests[dir] == nullptr || y_gap < bbox->y_gap(nearests[dir]->bounding_box())) {
565          nearests[dir] = neighbour;
566        }
567      } else if (y_gap < 0 && y_gap <= x_gap) {
568        BlobNeighbourDir dir = nbox.left() > bbox->left() ? BND_RIGHT : BND_LEFT;
569        if (nearests[dir] == nullptr || x_gap < bbox->x_gap(nearests[dir]->bounding_box())) {
570          nearests[dir] = neighbour;
571        }
572      }
573      if (nearests[BND_LEFT] && nearests[BND_RIGHT] && nearests[BND_ABOVE] && nearests[BND_BELOW]) {
574        break;
575      }
576    }
577    for (auto &nearest : nearests) {
578      if (nearest == nullptr) {
579        continue;
580      }
581      const TBOX &nbox = nearest->bounding_box();
582      if (debug) {
583        tprintf("Testing for overlap with:");
584        nbox.print();
585      }
586      if (bbox->overlap(nbox)) {
587        blobs->shallow_clear();
588        if (debug) {
589          tprintf("Final box overlaps nearest\n");
590        }
591        return;
592      }
593    }
594  }
595  void StrokeWidth::FindTextlineFlowDirection(PageSegMode pageseg_mode, bool display_if_debugging) {
596    BlobGridSearch gsearch(this);
597    BLOBNBOX *bbox;
598    gsearch.StartFullSearch();
599    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
600      SetNeighbours(false, display_if_debugging, bbox);
601    }
602    gsearch.StartFullSearch();
603    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
604      SimplifyObviousNeighbours(bbox);
605    }
606    gsearch.StartFullSearch();
607    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
608      if (FindingVerticalOnly(pageseg_mode)) {
609        bbox->set_vert_possible(true);
610        bbox->set_horz_possible(false);
611      } else if (FindingHorizontalOnly(pageseg_mode)) {
612        bbox->set_vert_possible(false);
613        bbox->set_horz_possible(true);
614      } else {
615        SetNeighbourFlows(bbox);
616      }
617    }
618  #ifndef GRAPHICS_DISABLED
619    if ((textord_tabfind_show_strokewidths && display_if_debugging) ||
620        textord_tabfind_show_strokewidths > 1) {
621      initial_widths_win_ = DisplayGoodBlobs("InitialStrokewidths", 400, 0);
622    }
623  #endif
624    gsearch.StartFullSearch();
625    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
626      SmoothNeighbourTypes(pageseg_mode, false, bbox);
627    }
628    gsearch.StartFullSearch();
629    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
630      SmoothNeighbourTypes(pageseg_mode, true, bbox);
631    }
632    gsearch.StartFullSearch();
633    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
634      SmoothNeighbourTypes(pageseg_mode, true, bbox);
635    }
636  #ifndef GRAPHICS_DISABLED
637    if ((textord_tabfind_show_strokewidths && display_if_debugging) ||
638        textord_tabfind_show_strokewidths > 1) {
639      widths_win_ = DisplayGoodBlobs("ImprovedStrokewidths", 800, 0);
640    }
641  #endif
642  }
643  void StrokeWidth::SetNeighbours(bool leaders, bool activate_line_trap, BLOBNBOX *blob) {
644    int line_trap_count = 0;
645    for (int dir = 0; dir < BND_COUNT; ++dir) {
646      auto bnd = static_cast<BlobNeighbourDir>(dir);
647      line_trap_count += FindGoodNeighbour(bnd, leaders, blob);
648    }
649    if (line_trap_count > 0 && activate_line_trap) {
650      blob->ClearNeighbours();
651      const TBOX &box = blob->bounding_box();
652      blob->set_region_type(box.width() > box.height() ? BRT_HLINE : BRT_VLINE);
653    }
654  }
655  int StrokeWidth::FindGoodNeighbour(BlobNeighbourDir dir, bool leaders, BLOBNBOX *blob) {
656    TBOX blob_box = blob->bounding_box();
657    bool debug = AlignedBlob::WithinTestRegion(2, blob_box.left(), blob_box.bottom());
658    if (debug) {
659      tprintf("FGN in dir %d for blob:", dir);
660      blob_box.print();
661    }
662    int top = blob_box.top();
663    int bottom = blob_box.bottom();
664    int left = blob_box.left();
665    int right = blob_box.right();
666    int width = right - left;
667    int height = top - bottom;
668    int line_trap_max = std::max(width, height) / kLineTrapLongest;
669    int line_trap_min = std::min(width, height) * kLineTrapShortest;
670    int line_trap_count = 0;
671    int min_good_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 2 : width / 2;
672    int min_decent_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 3 : width / 3;
673    if (leaders) {
674      min_good_overlap = min_decent_overlap = 1;
675    }
676    int search_pad =
677        static_cast<int>(sqrt(static_cast<double>(width * height)) * kNeighbourSearchFactor);
678    if (gridsize() > search_pad) {
679      search_pad = gridsize();
680    }
681    TBOX search_box = blob_box;
682    switch (dir) {
683      case BND_LEFT:
684        search_box.set_left(search_box.left() - search_pad);
685        break;
686      case BND_RIGHT:
687        search_box.set_right(search_box.right() + search_pad);
688        break;
689      case BND_BELOW:
690        search_box.set_bottom(search_box.bottom() - search_pad);
691        break;
692      case BND_ABOVE:
693        search_box.set_top(search_box.top() + search_pad);
694        break;
695      case BND_COUNT:
696        return 0;
697    }
698    BlobGridSearch rectsearch(this);
699    rectsearch.StartRectSearch(search_box);
700    BLOBNBOX *best_neighbour = nullptr;
701    double best_goodness = 0.0;
702    bool best_is_good = false;
703    BLOBNBOX *neighbour;
704    while ((neighbour = rectsearch.NextRectSearch()) != nullptr) {
705      TBOX nbox = neighbour->bounding_box();
706      if (neighbour == blob) {
707        continue;
708      }
709      int mid_x = (nbox.left() + nbox.right()) / 2;
710      if (mid_x < blob->left_rule() || mid_x > blob->right_rule()) {
711        continue; 
712      }
713      if (debug) {
714        tprintf("Neighbour at:");
715        nbox.print();
716      }
717      int n_width = nbox.width();
718      int n_height = nbox.height();
719      if (std::min(n_width, n_height) > line_trap_min &&
720          std::max(n_width, n_height) < line_trap_max) {
721        ++line_trap_count;
722      }
723      if (TabFind::VeryDifferentSizes(std::max(n_width, n_height), std::max(width, height)) &&
724          (((dir == BND_LEFT || dir == BND_RIGHT) && TabFind::DifferentSizes(n_height, height)) ||
725           ((dir == BND_BELOW || dir == BND_ABOVE) && TabFind::DifferentSizes(n_width, width)))) {
726        if (debug) {
727          tprintf("Bad size\n");
728        }
729        continue; 
730      }
731      int overlap;
732      int perp_overlap;
733      int gap;
734      if (dir == BND_LEFT || dir == BND_RIGHT) {
735        overlap = std::min(static_cast<int>(nbox.top()), top) -
736                  std::max(static_cast<int>(nbox.bottom()), bottom);
737        if (overlap == nbox.height() && nbox.width() > nbox.height()) {
738          perp_overlap = nbox.width();
739        } else {
740          perp_overlap = overlap;
741        }
742        gap = dir == BND_LEFT ? left - nbox.left() : nbox.right() - right;
743        if (gap <= 0) {
744          if (debug) {
745            tprintf("On wrong side\n");
746          }
747          continue; 
748        }
749        gap -= n_width;
750      } else {
751        overlap = std::min(static_cast<int>(nbox.right()), right) -
752                  std::max(static_cast<int>(nbox.left()), left);
753        if (overlap == nbox.width() && nbox.height() > nbox.width()) {
754          perp_overlap = nbox.height();
755        } else {
756          perp_overlap = overlap;
757        }
758        gap = dir == BND_BELOW ? bottom - nbox.bottom() : nbox.top() - top;
759        if (gap <= 0) {
760          if (debug) {
761            tprintf("On wrong side\n");
762          }
763          continue; 
764        }
765        gap -= n_height;
766      }
767      if (-gap > overlap) {
768        if (debug) {
769          tprintf("Overlaps wrong way\n");
770        }
771        continue; 
772      }
773      if (perp_overlap < min_decent_overlap) {
774        if (debug) {
775          tprintf("Doesn't overlap enough\n");
776        }
777        continue; 
778      }
779      bool bad_sizes =
780          TabFind::DifferentSizes(height, n_height) && TabFind::DifferentSizes(width, n_width);
781      bool is_good =
782          overlap >= min_good_overlap && !bad_sizes &&
783          blob->MatchingStrokeWidth(*neighbour, kStrokeWidthFractionTolerance, kStrokeWidthTolerance);
784      if (gap < 1) {
785        gap = 1;
786      }
787      double goodness = (1.0 + is_good) * overlap / gap;
788      if (debug) {
789        tprintf("goodness = %g vs best of %g, good=%d, overlap=%d, gap=%d\n", goodness, best_goodness,
790                is_good, overlap, gap);
791      }
792      if (goodness > best_goodness) {
793        best_neighbour = neighbour;
794        best_goodness = goodness;
795        best_is_good = is_good;
796      }
797    }
798    blob->set_neighbour(dir, best_neighbour, best_is_good);
799    return line_trap_count;
800  }
801  static void ListNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
802    for (int dir = 0; dir < BND_COUNT; ++dir) {
803      auto bnd = static_cast<BlobNeighbourDir>(dir);
804      BLOBNBOX *neighbour = blob->neighbour(bnd);
805      if (neighbour != nullptr) {
806        neighbours->add_sorted(SortByBoxLeft<BLOBNBOX>, true, neighbour);
807      }
808    }
809  }
810  static void List2ndNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
811    ListNeighbours(blob, neighbours);
812    for (int dir = 0; dir < BND_COUNT; ++dir) {
813      auto bnd = static_cast<BlobNeighbourDir>(dir);
814      BLOBNBOX *neighbour = blob->neighbour(bnd);
815      if (neighbour != nullptr) {
816        ListNeighbours(neighbour, neighbours);
817      }
818    }
819  }
820  static void List3rdNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
821    List2ndNeighbours(blob, neighbours);
822    for (int dir = 0; dir < BND_COUNT; ++dir) {
823      auto bnd = static_cast<BlobNeighbourDir>(dir);
824      BLOBNBOX *neighbour = blob->neighbour(bnd);
825      if (neighbour != nullptr) {
826        List2ndNeighbours(neighbour, neighbours);
827      }
828    }
829  }
830  static void CountNeighbourGaps(bool debug, BLOBNBOX_CLIST *neighbours, int *pure_h_count,
831                                 int *pure_v_count) {
832    if (neighbours->length() <= kMostlyOneDirRatio) {
833      return;
834    }
835    BLOBNBOX_C_IT it(neighbours);
836    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
837      BLOBNBOX *blob = it.data();
838      int h_min, h_max, v_min, v_max;
839      blob->MinMaxGapsClipped(&h_min, &h_max, &v_min, &v_max);
840      if (debug) {
841        tprintf("Hgaps [%d,%d], vgaps [%d,%d]:", h_min, h_max, v_min, v_max);
842      }
843      if (h_max < v_min || blob->leader_on_left() || blob->leader_on_right()) {
844        ++*pure_h_count;
845        if (debug) {
846          tprintf("Horz at:");
847        }
848      } else if (v_max < h_min) {
849        ++*pure_v_count;
850        if (debug) {
851          tprintf("Vert at:");
852        }
853      } else {
854        if (debug) {
855          tprintf("Neither at:");
856        }
857      }
858      if (debug) {
859        blob->bounding_box().print();
860      }
861    }
862  }
863  void StrokeWidth::SetNeighbourFlows(BLOBNBOX *blob) {
864    if (blob->DefiniteIndividualFlow()) {
865      return;
866    }
867    bool debug =
868        AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(), blob->bounding_box().bottom());
869    if (debug) {
870      tprintf("SetNeighbourFlows (current flow=%d, type=%d) on:", blob->flow(), blob->region_type());
871      blob->bounding_box().print();
872    }
873    BLOBNBOX_CLIST neighbours;
874    List3rdNeighbours(blob, &neighbours);
875    int pure_h_count = 0;
876    int pure_v_count = 0;
877    CountNeighbourGaps(debug, &neighbours, &pure_h_count, &pure_v_count);
878    if (debug) {
879      HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
880      tprintf("SetFlows: h_count=%d, v_count=%d\n", pure_h_count, pure_v_count);
881    }
882    if (!neighbours.empty()) {
883      blob->set_vert_possible(true);
884      blob->set_horz_possible(true);
885      if (pure_h_count > 2 * pure_v_count) {
886        blob->set_vert_possible(false);
887      } else if (pure_v_count > 2 * pure_h_count) {
888        blob->set_horz_possible(false);
889      }
890    } else {
891      blob->set_vert_possible(false);
892      blob->set_horz_possible(false);
893    }
894  }
895  static void CountNeighbourTypes(BLOBNBOX_CLIST *neighbours, int *pure_h_count, int *pure_v_count) {
896    BLOBNBOX_C_IT it(neighbours);
897    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
898      BLOBNBOX *blob = it.data();
899      if (blob->UniquelyHorizontal()) {
900        ++*pure_h_count;
901      }
902      if (blob->UniquelyVertical()) {
903        ++*pure_v_count;
904      }
905    }
906  }
907  void StrokeWidth::SimplifyObviousNeighbours(BLOBNBOX *blob) {
908    if ((blob->bounding_box().width() > 3 * blob->area_stroke_width() &&
909         blob->bounding_box().height() > 3 * blob->area_stroke_width())) {
910      if (blob->bounding_box().width() > 4 * blob->bounding_box().height()) {
911        blob->set_neighbour(BND_ABOVE, nullptr, false);
912        blob->set_neighbour(BND_BELOW, nullptr, false);
913        return;
914      }
915      if (blob->bounding_box().height() > 4 * blob->bounding_box().width()) {
916        blob->set_neighbour(BND_LEFT, nullptr, false);
917        blob->set_neighbour(BND_RIGHT, nullptr, false);
918        return;
919      }
920    }
921    int margin = gridsize() / 2;
922    int h_min, h_max, v_min, v_max;
923    blob->MinMaxGapsClipped(&h_min, &h_max, &v_min, &v_max);
924    if ((h_max + margin < v_min && h_max < margin / 2) || blob->leader_on_left() ||
925        blob->leader_on_right()) {
926      blob->set_neighbour(BND_ABOVE, nullptr, false);
927      blob->set_neighbour(BND_BELOW, nullptr, false);
928    } else if (v_max + margin < h_min && v_max < margin / 2) {
929      blob->set_neighbour(BND_LEFT, nullptr, false);
930      blob->set_neighbour(BND_RIGHT, nullptr, false);
931    }
932  }
933  void StrokeWidth::SmoothNeighbourTypes(PageSegMode pageseg_mode, bool reset_all, BLOBNBOX *blob) {
934    if ((blob->vert_possible() && blob->horz_possible()) || reset_all) {
935      BLOBNBOX_CLIST neighbours;
936      List2ndNeighbours(blob, &neighbours);
937      int pure_h_count = 0;
938      int pure_v_count = 0;
939      CountNeighbourTypes(&neighbours, &pure_h_count, &pure_v_count);
940      if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
941                                        blob->bounding_box().bottom())) {
942        HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
943        tprintf("pure_h=%d, pure_v=%d\n", pure_h_count, pure_v_count);
944      }
945      if (pure_h_count > pure_v_count && !FindingVerticalOnly(pageseg_mode)) {
946        blob->set_vert_possible(false);
947        blob->set_horz_possible(true);
948      } else if (pure_v_count > pure_h_count && !FindingHorizontalOnly(pageseg_mode)) {
949        blob->set_horz_possible(false);
950        blob->set_vert_possible(true);
951      }
952    } else if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
953                                             blob->bounding_box().bottom())) {
954      HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
955      tprintf("Clean on pass 3!\n");
956    }
957  }
958  PartitionFindResult StrokeWidth::FindInitialPartitions(
959      PageSegMode pageseg_mode, const FCOORD &rerotation, bool find_problems, TO_BLOCK *block,
960      BLOBNBOX_LIST *diacritic_blobs, ColPartitionGrid *part_grid, ColPartition_LIST *big_parts,
961      FCOORD *skew_angle) {
962    if (!FindingHorizontalOnly(pageseg_mode)) {
963      FindVerticalTextChains(part_grid);
964    }
965    if (!FindingVerticalOnly(pageseg_mode)) {
966      FindHorizontalTextChains(part_grid);
967    }
968  #ifndef GRAPHICS_DISABLED
969    if (textord_tabfind_show_strokewidths) {
970      chains_win_ = MakeWindow(0, 400, "Initial text chains");
971      part_grid->DisplayBoxes(chains_win_);
972      projection_->DisplayProjection();
973    }
974  #endif
975    if (find_problems) {
976    }
977    part_grid->SplitOverlappingPartitions(big_parts);
978    EasyMerges(part_grid);
979    RemoveLargeUnusedBlobs(block, part_grid, big_parts);
980    TBOX grid_box(bleft(), tright());
981    while (part_grid->GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
982      ;
983    }
984    while (part_grid->GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
985      ;
986    }
987    int pre_overlap = part_grid->ComputeTotalOverlap(nullptr);
988    TestDiacritics(part_grid, block);
989    MergeDiacritics(block, part_grid);
990    if (find_problems && diacritic_blobs != nullptr &&
991        DetectAndRemoveNoise(pre_overlap, grid_box, block, part_grid, diacritic_blobs)) {
992      return PFR_NOISE;
993    }
994  #ifndef GRAPHICS_DISABLED
995    if (textord_tabfind_show_strokewidths) {
996      textlines_win_ = MakeWindow(400, 400, "GoodTextline blobs");
997      part_grid->DisplayBoxes(textlines_win_);
998      diacritics_win_ = DisplayDiacritics("Diacritics", 0, 0, block);
999    }
1000  #endif
1001    PartitionRemainingBlobs(pageseg_mode, part_grid);
1002    part_grid->SplitOverlappingPartitions(big_parts);
1003    EasyMerges(part_grid);
1004    while (part_grid->GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
1005      ;
1006    }
1007    while (part_grid->GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
1008      ;
1009    }
1010    while (part_grid->GridSmoothNeighbours(BTFT_STRONG_CHAIN, nontext_map_, grid_box, rerotation)) {
1011      ;
1012    }
1013  #ifndef GRAPHICS_DISABLED
1014    if (textord_tabfind_show_strokewidths) {
1015      smoothed_win_ = MakeWindow(800, 400, "Smoothed blobs");
1016      part_grid->DisplayBoxes(smoothed_win_);
1017    }
1018  #endif
1019    return PFR_OK;
1020  }
1021  bool StrokeWidth::DetectAndRemoveNoise(int pre_overlap, const TBOX &grid_box, TO_BLOCK *block,
1022                                         ColPartitionGrid *part_grid,
1023                                         BLOBNBOX_LIST *diacritic_blobs) {
1024    ColPartitionGrid *noise_grid = nullptr;
1025    int post_overlap = part_grid->ComputeTotalOverlap(&noise_grid);
1026    if (pre_overlap == 0) {
1027      pre_overlap = 1;
1028    }
1029    BLOBNBOX_IT diacritic_it(diacritic_blobs);
1030    if (noise_grid != nullptr) {
1031      if (post_overlap > pre_overlap * kNoiseOverlapGrowthFactor &&
1032          post_overlap > grid_box.area() * kNoiseOverlapAreaFactor) {
1033  #ifndef GRAPHICS_DISABLED
1034        if (textord_tabfind_show_strokewidths) {
1035          ScrollView *noise_win = MakeWindow(1000, 500, "Noise Areas");
1036          noise_grid->DisplayBoxes(noise_win);
1037        }
1038  #endif
1039        part_grid->DeleteNonLeaderParts();
1040        BLOBNBOX_IT blob_it(&block->noise_blobs);
1041        ColPartitionGridSearch rsearch(noise_grid);
1042        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1043          BLOBNBOX *blob = blob_it.data();
1044          blob->ClearNeighbours();
1045          if (!blob->IsDiacritic() || blob->owner() != nullptr) {
1046            continue; 
1047          }
1048          TBOX search_box(blob->bounding_box());
1049          search_box.pad(gridsize(), gridsize());
1050          rsearch.StartRectSearch(search_box);
1051          ColPartition *part = rsearch.NextRectSearch();
1052          if (part != nullptr) {
1053            blob->set_owns_cblob(true);
1054            blob->compute_bounding_box();
1055            diacritic_it.add_after_then_move(blob_it.extract());
1056          }
1057        }
1058        noise_grid->DeleteParts();
1059        delete noise_grid;
1060        return true;
1061      }
1062      noise_grid->DeleteParts();
1063      delete noise_grid;
1064    }
1065    return false;
1066  }
1067  static BLOBNBOX *MutualUnusedVNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1068    BLOBNBOX *next_blob = blob->neighbour(dir);
1069    if (next_blob == nullptr || next_blob->owner() != nullptr || next_blob->UniquelyHorizontal()) {
1070      return nullptr;
1071    }
1072    if (next_blob->neighbour(DirOtherWay(dir)) == blob) {
1073      return next_blob;
1074    }
1075    return nullptr;
1076  }
1077  void StrokeWidth::FindVerticalTextChains(ColPartitionGrid *part_grid) {
1078    PageSegMode pageseg_mode =
1079        rerotation_.y() == 0.0f ? PSM_SINGLE_BLOCK_VERT_TEXT : PSM_SINGLE_COLUMN;
1080    BlobGridSearch gsearch(this);
1081    BLOBNBOX *bbox;
1082    gsearch.StartFullSearch();
1083    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1084      BLOBNBOX *blob;
1085      if (bbox->owner() == nullptr && bbox->UniquelyVertical() &&
1086          (blob = MutualUnusedVNeighbour(bbox, BND_ABOVE)) != nullptr) {
1087        auto *part = new ColPartition(BRT_VERT_TEXT, ICOORD(0, 1));
1088        part->AddBox(bbox);
1089        while (blob != nullptr) {
1090          part->AddBox(blob);
1091          blob = MutualUnusedVNeighbour(blob, BND_ABOVE);
1092        }
1093        blob = MutualUnusedVNeighbour(bbox, BND_BELOW);
1094        while (blob != nullptr) {
1095          part->AddBox(blob);
1096          blob = MutualUnusedVNeighbour(blob, BND_BELOW);
1097        }
1098        CompletePartition(pageseg_mode, part, part_grid);
1099      }
1100    }
1101  }
1102  static BLOBNBOX *MutualUnusedHNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1103    BLOBNBOX *next_blob = blob->neighbour(dir);
1104    if (next_blob == nullptr || next_blob->owner() != nullptr || next_blob->UniquelyVertical()) {
1105      return nullptr;
1106    }
1107    if (next_blob->neighbour(DirOtherWay(dir)) == blob) {
1108      return next_blob;
1109    }
1110    return nullptr;
1111  }
1112  void StrokeWidth::FindHorizontalTextChains(ColPartitionGrid *part_grid) {
1113    PageSegMode pageseg_mode =
1114        rerotation_.y() == 0.0f ? PSM_SINGLE_COLUMN : PSM_SINGLE_BLOCK_VERT_TEXT;
1115    BlobGridSearch gsearch(this);
1116    BLOBNBOX *bbox;
1117    gsearch.StartFullSearch();
1118    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1119      BLOBNBOX *blob;
1120      if (bbox->owner() == nullptr && bbox->UniquelyHorizontal() &&
1121          (blob = MutualUnusedHNeighbour(bbox, BND_RIGHT)) != nullptr) {
1122        auto *part = new ColPartition(BRT_TEXT, ICOORD(0, 1));
1123        part->AddBox(bbox);
1124        while (blob != nullptr) {
1125          part->AddBox(blob);
1126          blob = MutualUnusedHNeighbour(blob, BND_RIGHT);
1127        }
1128        blob = MutualUnusedHNeighbour(bbox, BND_LEFT);
1129        while (blob != nullptr) {
1130          part->AddBox(blob);
1131          blob = MutualUnusedVNeighbour(blob, BND_LEFT);
1132        }
1133        CompletePartition(pageseg_mode, part, part_grid);
1134      }
1135    }
1136  }
1137  void StrokeWidth::TestDiacritics(ColPartitionGrid *part_grid, TO_BLOCK *block) {
1138    BlobGrid small_grid(gridsize(), bleft(), tright());
1139    small_grid.InsertBlobList(&block->noise_blobs);
1140    small_grid.InsertBlobList(&block->blobs);
1141    int medium_diacritics = 0;
1142    int small_diacritics = 0;
1143    BLOBNBOX_IT small_it(&block->noise_blobs);
1144    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1145      BLOBNBOX *blob = small_it.data();
1146      if (blob->owner() == nullptr && !blob->IsDiacritic() && DiacriticBlob(&small_grid, blob)) {
1147        ++small_diacritics;
1148      }
1149    }
1150    BLOBNBOX_IT blob_it(&block->blobs);
1151    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1152      BLOBNBOX *blob = blob_it.data();
1153      if (blob->IsDiacritic()) {
1154        small_it.add_to_end(blob_it.extract());
1155        continue; 
1156      }
1157      ColPartition *part = blob->owner();
1158      if (part == nullptr && DiacriticBlob(&small_grid, blob)) {
1159        ++medium_diacritics;
1160        RemoveBBox(blob);
1161        small_it.add_to_end(blob_it.extract());
1162      } else if (part != nullptr && !part->block_owned() && part->boxes_count() < 3) {
1163        BLOBNBOX_C_IT box_it(part->boxes());
1164        for (box_it.mark_cycle_pt();
1165             !box_it.cycled_list() && DiacriticBlob(&small_grid, box_it.data()); box_it.forward()) {
1166          ;
1167        }
1168        if (box_it.cycled_list()) {
1169          while (!box_it.empty()) {
1170            BLOBNBOX *box = box_it.extract();
1171            box->set_owner(nullptr);
1172            box_it.forward();
1173            ++medium_diacritics;
1174            RemoveBBox(box);
1175          }
1176          small_it.add_to_end(blob_it.extract());
1177          part_grid->RemoveBBox(part);
1178          delete part;
1179        }
1180      } else if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
1181                                               blob->bounding_box().bottom())) {
1182        tprintf("Blob not available to be a diacritic at:");
1183        blob->bounding_box().print();
1184      }
1185    }
1186    if (textord_tabfind_show_strokewidths) {
1187      tprintf("Found %d small diacritics, %d medium\n", small_diacritics, medium_diacritics);
1188    }
1189  }
1190  bool StrokeWidth::DiacriticBlob(BlobGrid *small_grid, BLOBNBOX *blob) {
1191    if (BLOBNBOX::UnMergeableType(blob->region_type()) || blob->region_type() == BRT_VERT_TEXT) {
1192      return false;
1193    }
1194    TBOX small_box(blob->bounding_box());
1195    bool debug = AlignedBlob::WithinTestRegion(2, small_box.left(), small_box.bottom());
1196    if (debug) {
1197      tprintf("Testing blob for diacriticness at:");
1198      small_box.print();
1199    }
1200    int x = (small_box.left() + small_box.right()) / 2;
1201    int y = (small_box.bottom() + small_box.top()) / 2;
1202    int grid_x, grid_y;
1203    GridCoords(x, y, &grid_x, &grid_y);
1204    int height = small_box.height();
1205    BLOBNBOX *best_x_overlap = nullptr;
1206    BLOBNBOX *best_y_overlap = nullptr;
1207    int best_total_dist = 0;
1208    int best_y_gap = 0;
1209    TBOX best_xbox;
1210    TBOX search_box(small_box);
1211    int x_pad = IntCastRounded(gridsize() * kDiacriticXPadRatio);
1212    int y_pad = IntCastRounded(gridsize() * kDiacriticYPadRatio);
1213    search_box.pad(x_pad, y_pad);
1214    BlobGridSearch rsearch(this);
1215    rsearch.SetUniqueMode(true);
1216    int min_height = height * kMinDiacriticSizeRatio;
1217    rsearch.StartRectSearch(search_box);
1218    BLOBNBOX *neighbour;
1219    while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1220      if (BLOBNBOX::UnMergeableType(neighbour->region_type()) || neighbour == blob ||
1221          neighbour->owner() == blob->owner()) {
1222        continue;
1223      }
1224      TBOX nbox = neighbour->bounding_box();
1225      if (neighbour->owner() == nullptr || neighbour->owner()->IsVerticalType() ||
1226          (neighbour->flow() != BTFT_CHAIN && neighbour->flow() != BTFT_STRONG_CHAIN)) {
1227        if (debug) {
1228          tprintf("Neighbour not strong enough:");
1229          nbox.print();
1230        }
1231        continue; 
1232      }
1233      if (nbox.height() < min_height) {
1234        if (debug) {
1235          tprintf("Neighbour not big enough:");
1236          nbox.print();
1237        }
1238        continue; 
1239      }
1240      int x_gap = small_box.x_gap(nbox);
1241      int y_gap = small_box.y_gap(nbox);
1242      int total_distance = projection_->DistanceOfBoxFromBox(small_box, nbox, true, denorm_, debug);
1243      if (debug) {
1244        tprintf("xgap=%d, y=%d, total dist=%d\n", x_gap, y_gap, total_distance);
1245      }
1246      if (total_distance > neighbour->owner()->median_height() * kMaxDiacriticDistanceRatio) {
1247        if (debug) {
1248          tprintf("Neighbour with median size %d too far away:", neighbour->owner()->median_height());
1249          neighbour->bounding_box().print();
1250        }
1251        continue; 
1252      }
1253      if (x_gap <= 0) {
1254        if (debug) {
1255          tprintf("Computing reduced box for :");
1256          nbox.print();
1257        }
1258        int left = small_box.left() - small_box.width();
1259        int right = small_box.right() + small_box.width();
1260        nbox = neighbour->BoundsWithinLimits(left, right);
1261        y_gap = small_box.y_gap(nbox);
1262        if (best_x_overlap == nullptr || y_gap < best_y_gap) {
1263          best_x_overlap = neighbour;
1264          best_xbox = nbox;
1265          best_y_gap = y_gap;
1266          if (debug) {
1267            tprintf("New best:");
1268            nbox.print();
1269          }
1270        } else if (debug) {
1271          tprintf("Shrunken box doesn't win:");
1272          nbox.print();
1273        }
1274      } else if (blob->ConfirmNoTabViolation(*neighbour)) {
1275        if (best_y_overlap == nullptr || total_distance < best_total_dist) {
1276          if (debug) {
1277            tprintf("New best y overlap:");
1278            nbox.print();
1279          }
1280          best_y_overlap = neighbour;
1281          best_total_dist = total_distance;
1282        } else if (debug) {
1283          tprintf("New y overlap box doesn't win:");
1284          nbox.print();
1285        }
1286      } else if (debug) {
1287        tprintf("Neighbour wrong side of a tab:");
1288        nbox.print();
1289      }
1290    }
1291    if (best_x_overlap != nullptr &&
1292        (best_y_overlap == nullptr || best_xbox.major_y_overlap(best_y_overlap->bounding_box()))) {
1293      blob->set_diacritic_box(best_xbox);
1294      blob->set_base_char_blob(best_x_overlap);
1295      if (debug) {
1296        tprintf("DiacriticBlob OK! (x-overlap:");
1297        small_box.print();
1298        best_xbox.print();
1299      }
1300      return true;
1301    }
1302    if (best_y_overlap != nullptr &&
1303        DiacriticXGapFilled(small_grid, small_box, best_y_overlap->bounding_box()) &&
1304        NoNoiseInBetween(small_box, best_y_overlap->bounding_box())) {
1305      blob->set_diacritic_box(best_y_overlap->bounding_box());
1306      blob->set_base_char_blob(best_y_overlap);
1307      if (debug) {
1308        tprintf("DiacriticBlob OK! (y-overlap:");
1309        small_box.print();
1310        best_y_overlap->bounding_box().print();
1311      }
1312      return true;
1313    }
1314    if (debug) {
1315      tprintf("DiacriticBlob fails:");
1316      small_box.print();
1317      tprintf("Best x+y gap = %d, y = %d\n", best_total_dist, best_y_gap);
1318      if (best_y_overlap != nullptr) {
1319        tprintf("XGapFilled=%d, NoiseBetween=%d\n",
1320                DiacriticXGapFilled(small_grid, small_box, best_y_overlap->bounding_box()),
1321                NoNoiseInBetween(small_box, best_y_overlap->bounding_box()));
1322      }
1323    }
1324    return false;
1325  }
1326  bool StrokeWidth::DiacriticXGapFilled(BlobGrid *grid, const TBOX &diacritic_box,
1327                                        const TBOX &base_box) {
1328    int max_gap = IntCastRounded(base_box.height() * kMaxDiacriticGapToBaseCharHeight);
1329    TBOX occupied_box(base_box);
1330    int diacritic_gap;
1331    while ((diacritic_gap = diacritic_box.x_gap(occupied_box)) > max_gap) {
1332      TBOX search_box(occupied_box);
1333      if (diacritic_box.left() > search_box.right()) {
1334        search_box.set_left(search_box.right());
1335        search_box.set_right(search_box.left() + max_gap);
1336      } else {
1337        search_box.set_right(search_box.left());
1338        search_box.set_left(search_box.left() - max_gap);
1339      }
1340      BlobGridSearch rsearch(grid);
1341      rsearch.StartRectSearch(search_box);
1342      BLOBNBOX *neighbour;
1343      while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1344        const TBOX &nbox = neighbour->bounding_box();
1345        if (nbox.x_gap(diacritic_box) < diacritic_gap) {
1346          if (nbox.left() < occupied_box.left()) {
1347            occupied_box.set_left(nbox.left());
1348          }
1349          if (nbox.right() > occupied_box.right()) {
1350            occupied_box.set_right(nbox.right());
1351          }
1352          break;
1353        }
1354      }
1355      if (neighbour == nullptr) {
1356        return false; 
1357      }
1358    }
1359    return true; 
1360  }
1361  void StrokeWidth::MergeDiacritics(TO_BLOCK *block, ColPartitionGrid *part_grid) {
1362    BLOBNBOX_IT small_it(&block->noise_blobs);
1363    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1364      BLOBNBOX *blob = small_it.data();
1365      if (blob->base_char_blob() != nullptr) {
1366        ColPartition *part = blob->base_char_blob()->owner();
1367        if (part != nullptr && !part->block_owned() && blob->owner() == nullptr &&
1368            blob->IsDiacritic()) {
1369          part_grid->RemoveBBox(part);
1370          part->AddBox(blob);
1371          blob->set_region_type(part->blob_type());
1372          blob->set_flow(part->flow());
1373          blob->set_owner(part);
1374          part_grid->InsertBBox(true, true, part);
1375        }
1376        blob->set_base_char_blob(nullptr);
1377      }
1378    }
1379  }
1380  void StrokeWidth::RemoveLargeUnusedBlobs(TO_BLOCK *block, ColPartitionGrid *part_grid,
1381                                           ColPartition_LIST *big_parts) {
1382    BLOBNBOX_IT large_it(&block->large_blobs);
1383    for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
1384      BLOBNBOX *blob = large_it.data();
1385      ColPartition *big_part = blob->owner();
1386      if (big_part == nullptr) {
1387        ColPartition::MakeBigPartition(blob, big_parts);
1388      }
1389    }
1390  }
1391  void StrokeWidth::PartitionRemainingBlobs(PageSegMode pageseg_mode, ColPartitionGrid *part_grid) {
1392    BlobGridSearch gsearch(this);
1393    BLOBNBOX *bbox;
1394    int prev_grid_x = -1;
1395    int prev_grid_y = -1;
1396    BLOBNBOX_CLIST cell_list;
1397    BLOBNBOX_C_IT cell_it(&cell_list);
1398    bool cell_all_noise = true;
1399    gsearch.StartFullSearch();
1400    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1401      int grid_x = gsearch.GridX();
1402      int grid_y = gsearch.GridY();
1403      if (grid_x != prev_grid_x || grid_y != prev_grid_y) {
1404        MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &cell_list);
1405        cell_it.set_to_list(&cell_list);
1406        prev_grid_x = grid_x;
1407        prev_grid_y = grid_y;
1408        cell_all_noise = true;
1409      }
1410      if (bbox->owner() == nullptr) {
1411        cell_it.add_to_end(bbox);
1412        if (bbox->flow() != BTFT_NONTEXT) {
1413          cell_all_noise = false;
1414        }
1415      } else {
1416        cell_all_noise = false;
1417      }
1418    }
1419    MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &cell_list);
1420  }
1421  void StrokeWidth::MakePartitionsFromCellList(PageSegMode pageseg_mode, bool combine,
1422                                               ColPartitionGrid *part_grid,
1423                                               BLOBNBOX_CLIST *cell_list) {
1424    if (cell_list->empty()) {
1425      return;
1426    }
1427    BLOBNBOX_C_IT cell_it(cell_list);
1428    if (combine) {
1429      BLOBNBOX *bbox = cell_it.extract();
1430      auto *part = new ColPartition(bbox->region_type(), ICOORD(0, 1));
1431      part->AddBox(bbox);
1432      part->set_flow(bbox->flow());
1433      for (cell_it.forward(); !cell_it.empty(); cell_it.forward()) {
1434        part->AddBox(cell_it.extract());
1435      }
1436      CompletePartition(pageseg_mode, part, part_grid);
1437    } else {
1438      for (; !cell_it.empty(); cell_it.forward()) {
1439        BLOBNBOX *bbox = cell_it.extract();
1440        auto *part = new ColPartition(bbox->region_type(), ICOORD(0, 1));
1441        part->set_flow(bbox->flow());
1442        part->AddBox(bbox);
1443        CompletePartition(pageseg_mode, part, part_grid);
1444      }
1445    }
1446  }
1447  void StrokeWidth::CompletePartition(PageSegMode pageseg_mode, ColPartition *part,
1448                                      ColPartitionGrid *part_grid) {
1449    part->ComputeLimits();
1450    TBOX box = part->bounding_box();
1451    bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
1452    int value = projection_->EvaluateColPartition(*part, denorm_, debug);
1453    if (value > 0 && FindingVerticalOnly(pageseg_mode)) {
1454      value = part->boxes_count() == 1 ? 0 : -2;
1455    } else if (value < 0 && FindingHorizontalOnly(pageseg_mode)) {
1456      value = part->boxes_count() == 1 ? 0 : 2;
1457    }
1458    part->SetRegionAndFlowTypesFromProjectionValue(value);
1459    part->ClaimBoxes();
1460    part_grid->InsertBBox(true, true, part);
1461  }
1462  void StrokeWidth::EasyMerges(ColPartitionGrid *part_grid) {
1463    using namespace std::placeholders; 
1464    part_grid->Merges(std::bind(&StrokeWidth::OrientationSearchBox, this, _1, _2),
1465                      std::bind(&StrokeWidth::ConfirmEasyMerge, this, _1, _2));
1466  }
1467  bool StrokeWidth::OrientationSearchBox(ColPartition *part, TBOX *box) {
1468    if (part->IsVerticalType()) {
1469      box->set_top(box->top() + box->width());
1470      box->set_bottom(box->bottom() - box->width());
1471    } else {
1472      box->set_left(box->left() - box->height());
1473      box->set_right(box->right() + box->height());
1474    }
1475    return true;
1476  }
1477  bool StrokeWidth::ConfirmEasyMerge(const ColPartition *p1, const ColPartition *p2) {
1478    ASSERT_HOST(p1 != nullptr && p2 != nullptr);
1479    ASSERT_HOST(!p1->IsEmpty() && !p2->IsEmpty());
1480    if ((p1->flow() == BTFT_NONTEXT && p2->flow() >= BTFT_CHAIN) ||
1481        (p1->flow() >= BTFT_CHAIN && p2->flow() == BTFT_NONTEXT)) {
1482      return false; 
1483    }
1484    if ((p1->IsVerticalType() || p2->IsVerticalType()) && p1->HCoreOverlap(*p2) <= 0 &&
1485        ((!p1->IsSingleton() && !p2->IsSingleton()) ||
1486         !p1->bounding_box().major_overlap(p2->bounding_box()))) {
1487      return false; 
1488    }
1489    if ((p1->IsHorizontalType() || p2->IsHorizontalType()) && p1->VCoreOverlap(*p2) <= 0 &&
1490        ((!p1->IsSingleton() && !p2->IsSingleton()) ||
1491         (!p1->bounding_box().major_overlap(p2->bounding_box()) &&
1492          !p1->OKDiacriticMerge(*p2, false) && !p2->OKDiacriticMerge(*p1, false)))) {
1493      return false; 
1494    }
1495    if (!p1->ConfirmNoTabViolation(*p2)) {
1496      return false;
1497    }
1498    if (p1->flow() <= BTFT_NONTEXT && p2->flow() <= BTFT_NONTEXT) {
1499      return true;
1500    }
1501    return NoNoiseInBetween(p1->bounding_box(), p2->bounding_box());
1502  }
1503  bool StrokeWidth::NoNoiseInBetween(const TBOX &box1, const TBOX &box2) const {
1504    return ImageFind::BlankImageInBetween(box1, box2, grid_box_, rerotation_, nontext_map_);
1505  }
1506  #ifndef GRAPHICS_DISABLED
1507  ScrollView *StrokeWidth::DisplayGoodBlobs(const char *window_name, int x, int y) {
1508    auto window = MakeWindow(x, y, window_name);
1509    window->Brush(ScrollView::NONE);
1510    BlobGridSearch gsearch(this);
1511    gsearch.StartFullSearch();
1512    BLOBNBOX *bbox;
1513    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1514      const TBOX &box = bbox->bounding_box();
1515      int left_x = box.left();
1516      int right_x = box.right();
1517      int top_y = box.top();
1518      int bottom_y = box.bottom();
1519      int goodness = bbox->GoodTextBlob();
1520      BlobRegionType blob_type = bbox->region_type();
1521      if (bbox->UniquelyVertical()) {
1522        blob_type = BRT_VERT_TEXT;
1523      }
1524      if (bbox->UniquelyHorizontal()) {
1525        blob_type = BRT_TEXT;
1526      }
1527      BlobTextFlowType flow = bbox->flow();
1528      if (flow == BTFT_NONE) {
1529        if (goodness == 0) {
1530          flow = BTFT_NEIGHBOURS;
1531        } else if (goodness == 1) {
1532          flow = BTFT_CHAIN;
1533        } else {
1534          flow = BTFT_STRONG_CHAIN;
1535        }
1536      }
1537      window->Pen(BLOBNBOX::TextlineColor(blob_type, flow));
1538      window->Rectangle(left_x, bottom_y, right_x, top_y);
1539    }
1540    window->Update();
1541    return window;
1542  }
1543  static void DrawDiacriticJoiner(const BLOBNBOX *blob, ScrollView *window) {
1544    const TBOX &blob_box(blob->bounding_box());
1545    int top = std::max(static_cast<int>(blob_box.top()), blob->base_char_top());
1546    int bottom = std::min(static_cast<int>(blob_box.bottom()), blob->base_char_bottom());
1547    int x = (blob_box.left() + blob_box.right()) / 2;
1548    window->Line(x, top, x, bottom);
1549  }
1550  ScrollView *StrokeWidth::DisplayDiacritics(const char *window_name, int x, int y, TO_BLOCK *block) {
1551    auto window = MakeWindow(x, y, window_name);
1552    window->Brush(ScrollView::NONE);
1553    BLOBNBOX_IT it(&block->blobs);
1554    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1555      BLOBNBOX *blob = it.data();
1556      if (blob->IsDiacritic()) {
1557        window->Pen(ScrollView::GREEN);
1558        DrawDiacriticJoiner(blob, window);
1559      } else {
1560        window->Pen(blob->BoxColor());
1561      }
1562      const TBOX &box = blob->bounding_box();
1563      window->Rectangle(box.left(), box.bottom(), box.right(), box.top());
1564    }
1565    it.set_to_list(&block->noise_blobs);
1566    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1567      BLOBNBOX *blob = it.data();
1568      if (blob->IsDiacritic()) {
1569        window->Pen(ScrollView::GREEN);
1570        DrawDiacriticJoiner(blob, window);
1571      } else {
1572        window->Pen(ScrollView::WHITE);
1573      }
1574      const TBOX &box = blob->bounding_box();
1575      window->Rectangle(box.left(), box.bottom(), box.right(), box.top());
1576    }
1577    window->Update();
1578    return window;
1579  }
1580  #endif 
1581  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_normalize_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</div>
                </div>
                <div class="column column_space"><pre><code>65    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
66    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
67    int num = this->blob_bottom_->num();
68    int channels = this->blob_bottom_->channels();
69    int height = this->blob_bottom_->height();
70    int width = this->blob_bottom_->width();
</pre></code></div>
                <div class="column column_space"><pre><code>99    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
100      BLOBNBOX *blob = blob_it.data();
101      const TBOX &box = blob->bounding_box();
102      float y_x = static_cast<float>(box.height()) / box.width();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    