
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1774051191526915%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tbhc.cpp</h3>
            <pre><code>1  #include "tbhc.h"
2  THTb::THTb(const PHcBase& _HcBase):
3    TTb(), HcBase(_HcBase),
4    VarNToWordIdV(HcBase->GetWords()), WordIdToVarNV(HcBase->GetMxWordIds()),
5    TupNToDocIdV(HcBase->GetDocs()), DocIdToTupNV(HcBase->GetMxDocIds()){
6    int WordId=HcBase->FFirstWordId(); int VarN=0-1;
7    while (HcBase->FNextWordId(WordId)){VarN++;
8      VarNToWordIdV[VarN]=WordId; WordIdToVarNV[WordId]=VarN;}
9  }
10  THBTb::THBTb(const PHcBase& _HcBase):
11    THTb(_HcBase), TupV(HcBase->GetDocs()){
12    int DocId=HcBase->FFirstDocId(); int TupN=0-1;
13    while (HcBase->FNextDocId(DocId)){TupN++;
14      TupNToDocIdV[TupN]=DocId; DocIdToTupNV[DocId]=TupN;
15      PHcDoc Doc=HcBase->GetDoc(DocId);
16      PBSet Tup=new TBSet(VarNToWordIdV.Len());
17      for (int WordN=0; WordN<Doc->Len(); WordN++){
18        Tup->Incl(WordIdToVarNV[Doc->Get(WordN).GetWordId()]);}
19      TupV[TupN]=Tup;
20    }
21  }
22  THSTb::THSTb(const PHcBase& _HcBase):
23    THTb(_HcBase), TupV(HcBase->GetDocs()){
24    THash<TInt, TInt> DocWordsH(1000);
25    int DocId=HcBase->FFirstDocId(); int TupN=0-1;
26    while (HcBase->FNextDocId(DocId)){TupN++;
27      TupNToDocIdV[TupN]=DocId; DocIdToTupNV[DocId]=TupN;
<span onclick='openModal()' class='match'>28      PHcDoc Doc=HcBase->GetDoc(DocId);
29      DocWordsH.Clr();
30      for (int WordN=0; WordN<Doc->Len(); WordN++){
</span>31        DocWordsH.AddDat(Doc->Get(WordN).GetWordId())++;}
32      TupV[TupN].Reserve(DocWordsH.Len());
33      int DocWordsP=DocWordsH.FFirstKeyId();
34      while (DocWordsH.FNextKeyId(DocWordsP)){
35        TupV[TupN].Add(DocWordsH.GetKey(DocWordsP));}
36      TupV[TupN].Sort();
37    }
38  }
39  THFTb::THFTb(const PHcBase& _HcBase):
40    THTb(_HcBase), TupV(HcBase->GetDocs()){
41    THash<TInt, TInt> DocWordsH(1000);
42    int DocId=HcBase->FFirstDocId(); int TupN=0-1;
43    while (HcBase->FNextDocId(DocId)){TupN++;
44      TupNToDocIdV[TupN]=DocId; DocIdToTupNV[DocId]=TupN;
45      PHcDoc Doc=HcBase->GetDoc(DocId);
46      DocWordsH.Clr();
47      for (int WordN=0; WordN<Doc->Len(); WordN++){
48        DocWordsH.AddDat(Doc->Get(WordN).GetWordId())++;}
49      TupV[TupN].Reserve(DocWordsH.Len());
50      int DocWordsP=DocWordsH.FFirstKeyId();
51      while (DocWordsH.FNextKeyId(DocWordsP)){
52        TupV[TupN].Add(DocWordsH.GetKeyDat(DocWordsP));}
53      TupV[TupN].Sort();
54    }
55  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bfsdfs.h</h3>
            <pre><code>1  namespace TSnap {
2  template <class PGraph> PNGraph GetBfsTree(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn);
3  template <class PGraph> int GetSubTreeSz(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn, int& TreeSzX, int& TreeDepthX);
4  template <class PGraph> int GetNodesAtHop(const PGraph& Graph, const int& StartNId, const int& Hop, TIntV& NIdV, const bool& IsDir=false);
5  template <class PGraph> int GetNodesAtHops(const PGraph& Graph, const int& StartNId, TIntPrV& HopCntV, const bool& IsDir=false);
6  template <class PGraph> int GetShortPath(const PGraph& Graph, const int& SrcNId, const int& DstNId, const bool& IsDir=false);
7  template <class PGraph> int GetShortPath(const PGraph& Graph, const int& SrcNId, TIntH& NIdToDistH, const bool& IsDir=false, const int& MaxDist=TInt::Mx);
8  template <class PGraph> int GetBfsFullDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir=false);
9  template <class PGraph> double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir=false);
10  template <class PGraph> double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiamX, int& FullDiamX);
11  template <class PGraph> double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiamX, int& FullDiamX, double& AvgSPLX);
12  template <class PGraph> double GetBfsEffDiamAll(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiamX, int& FullDiamX, double& AvgSPLX);
13  template <class PGraph> double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const TIntV& SubGraphNIdV, const bool& IsDir, double& EffDiamX, int& FullDiamX);
14  } 
15  template<class PGraph>
16  class TBreathFS {
17  public:
18    PGraph Graph;
19    TSnapQueue<int> Queue;
20    TInt StartNId;
21    TIntH NIdDistH;
22  public:
23    TBreathFS(const PGraph& GraphPt, const bool& InitBigQ=true) :
24      Graph(GraphPt), Queue(InitBigQ?Graph->GetNodes():1024), NIdDistH(InitBigQ?Graph->GetNodes():1024) { }
25    void SetGraph(const PGraph& GraphPt);
26    int DoBfs(const int& StartNode, const bool& FollowOut, const bool& FollowIn, const int& TargetNId=-1, const int& MxDist=TInt::Mx);
27    int DoBfsHybrid(const int& StartNode, const bool& FollowOut, const bool& FollowIn, const int& TargetNId=-1, const int& MxDist=TInt::Mx);
28    int GetNVisited() const { return NIdDistH.Len(); }
29    void GetVisitedNIdV(TIntV& NIdV) const { NIdDistH.GetKeyV(NIdV); }
30    int GetHops(const int& SrcNId, const int& DstNId) const;
31    int GetRndPath(const int& SrcNId, const int& DstNId, TIntV& PathNIdV) const;
32  private:
33    int Stage; 
34    static const unsigned int alpha = 100;
35    static const unsigned int beta = 20;
36    bool TopDownStep(TIntV &NIdDistV, TIntV *Frontier, TIntV *NextFrontier, int& MaxDist, const int& TargetNId, const bool& FollowOut, const bool& FollowIn);
37    bool BottomUpStep(TIntV &NIdDistV, TIntV *Frontier, TIntV *NextFrontier, int& MaxDist, const int& TargetNId, const bool& FollowOut, const bool& FollowIn);
38  };
39  template<class PGraph>
40  void TBreathFS<PGraph>::SetGraph(const PGraph& GraphPt) {
41    Graph=GraphPt;
42    const int N=GraphPt->GetNodes();
43    if (Queue.Reserved() < N) { Queue.Gen(N); }
44    if (NIdDistH.GetReservedKeyIds() < N) { NIdDistH.Gen(N); }
45  }
46  template<class PGraph>
47  int TBreathFS<PGraph>::DoBfs(const int& StartNode, const bool& FollowOut, const bool& FollowIn, const int& TargetNId, const int& MxDist) {
48    StartNId = StartNode;
49    IAssert(Graph->IsNode(StartNId));
50    NIdDistH.Clr(false);  NIdDistH.AddDat(StartNId, 0);
51    Queue.Clr(false);  Queue.Push(StartNId);
52    int v, MaxDist = 0;
53    while (! Queue.Empty()) {
54      const int NId = Queue.Top();  Queue.Pop();
55      const int Dist = NIdDistH.GetDat(NId);
56      if (Dist == MxDist) { break; } 
57      const typename PGraph::TObj::TNodeI NodeI = Graph->GetNI(NId);
58      if (FollowOut) { 
59        for (v = 0; v < NodeI.GetOutDeg(); v++) {  
60          const int DstNId = NodeI.GetOutNId(v);
61          if (! NIdDistH.IsKey(DstNId)) {
62            NIdDistH.AddDat(DstNId, Dist+1);
63            MaxDist = TMath::Mx(MaxDist, Dist+1);
64            if (DstNId == TargetNId) { return MaxDist; }
65            Queue.Push(DstNId);
66          }
67        }
68      }
69      if (FollowIn) { 
70        for (v = 0; v < NodeI.GetInDeg(); v++) {
71          const int DstNId = NodeI.GetInNId(v);
72          if (! NIdDistH.IsKey(DstNId)) {
73            NIdDistH.AddDat(DstNId, Dist+1);
74            MaxDist = TMath::Mx(MaxDist, Dist+1);
75            if (DstNId == TargetNId) { return MaxDist; }
76            Queue.Push(DstNId);
77          }
78        }
79      }
80    }
81    return MaxDist;
82  }
83  template<class PGraph>
84  int TBreathFS<PGraph>::DoBfsHybrid(const int& StartNode, const bool& FollowOut, const bool& FollowIn, const int& TargetNId, const int& MxDist) {
85    StartNId = StartNode;
86    IAssert(Graph->IsNode(StartNId));
87    if (TargetNId == StartNode) return 0;
88    const typename PGraph::TObj::TNodeI StartNodeI = Graph->GetNI(StartNode);
89    TIntV NIdDistV(Graph->GetMxNId() + 1);
90    for (int i = 0; i < NIdDistV.Len(); i++) {
91      NIdDistV.SetVal(i, -1);
92    }
93    TIntV *Frontier = new TIntV(Graph->GetNodes(), 0);
94    TIntV *NextFrontier = new TIntV(Graph->GetNodes(), 0);
95    NIdDistV.SetVal(StartNId, 0);
96    Frontier->Add(StartNId);
97    Stage = 0;
98    int MaxDist = -1;
99    const unsigned int TotalNodes = Graph->GetNodes();
100    unsigned int UnvisitedNodes = Graph->GetNodes();
101    while (! Frontier->Empty()) {
102      MaxDist += 1;
103      NextFrontier->Clr(false);
104      if (MaxDist == MxDist) { break; } 
105      UnvisitedNodes -= Frontier->Len();
106      if (Stage == 0 && UnvisitedNodes / Frontier->Len() < alpha) {
107        Stage = 1;
108      } else if (Stage == 1 && TotalNodes / Frontier->Len() > beta) {
109        Stage = 2;
110      }
111      bool targetFound = false;
112      if (Stage == 0 || Stage == 2) {
113        targetFound = TopDownStep(NIdDistV, Frontier, NextFrontier, MaxDist, TargetNId, FollowOut, FollowIn);
114      } else {
115        targetFound = BottomUpStep(NIdDistV, Frontier, NextFrontier, MaxDist, TargetNId, FollowOut, FollowIn);
116      }
117      if (targetFound) {
118        MaxDist = NIdDistV[TargetNId];
119        break;
120      }
121      TIntV *temp = Frontier;
122      Frontier = NextFrontier;
123      NextFrontier = temp;
124    }
125    delete Frontier;
126    delete NextFrontier;
127    NIdDistH.Clr(false);
128    for (int NId = 0; NId < NIdDistV.Len(); NId++) {
129      if (NIdDistV[NId] != -1) {
130        NIdDistH.AddDat(NId, NIdDistV[NId]);
131      }
132    }
133    return MaxDist;
134  }
135  template<class PGraph>
136  bool TBreathFS<PGraph>::TopDownStep(TIntV &NIdDistV, TIntV *Frontier, TIntV *NextFrontier, int& MaxDist, const int& TargetNId, const bool& FollowOut, const bool& FollowIn) {
137    for (TIntV::TIter it = Frontier->BegI(); it != Frontier->EndI(); ++it) { 
138      const int NId = *it;
139      const int Dist = NIdDistV[NId];
140      IAssert(Dist == MaxDist); 
141      const typename PGraph::TObj::TNodeI NodeI = Graph->GetNI(NId);
142      if (FollowOut) {
143        for (int v = 0; v < NodeI.GetOutDeg(); v++) {
144          const int NeighborNId = NodeI.GetOutNId(v);
145          if (NIdDistV[NeighborNId] == -1) {
146            NIdDistV.SetVal(NeighborNId, Dist+1);
147            if (NeighborNId == TargetNId) return true;
148            NextFrontier->Add(NeighborNId);
149          }
150        }
151      }
152      if (FollowIn) {
153        for (int v = 0; v < NodeI.GetInDeg(); v++) {
154          const int NeighborNId = NodeI.GetInNId(v);
155          if (NIdDistV[NeighborNId] == -1) {
156            NIdDistV.SetVal(NeighborNId, Dist+1);
157            if (NeighborNId == TargetNId) return true;
158            NextFrontier->Add(NeighborNId);
159          }
160        }
161      }
162    }
163    return false;
164  }
165  template<class PGraph>
166  bool TBreathFS<PGraph>::BottomUpStep(TIntV &NIdDistV, TIntV *Frontier, TIntV *NextFrontier, int& MaxDist, const int& TargetNId, const bool& FollowOut, const bool& FollowIn) {
167    for (typename PGraph::TObj::TNodeI NodeI = Graph->BegNI(); NodeI < Graph->EndNI(); NodeI++) {
168      const int NId = NodeI.GetId();
169      if (NIdDistV[NId] == -1) {
170        if (FollowOut) {
171          for (int v = 0; v < NodeI.GetInDeg(); v++) {
172            const int ParentNId = NodeI.GetInNId(v);
173            if (NIdDistV[ParentNId] == MaxDist) {
174              NIdDistV[NId] = MaxDist + 1;
175              if (NId == TargetNId) return true;
176              NextFrontier->Add(NId);
177              break;
178            }
179          }
180        }
181        if (FollowIn && NIdDistV[NId] == -1) {
182          for (int v = 0; v < NodeI.GetOutDeg(); v++) {
183            const int ParentNId = NodeI.GetOutNId(v);
184            if (NIdDistV[ParentNId] == MaxDist) {
185              NIdDistV[NId] = MaxDist + 1;
186              if (NId == TargetNId) return true;
187              NextFrontier->Add(NId);
188              break;
189            }
190          }
191        }
192      }
193    }
194    return false;
195  }
196  template<class PGraph>
197  int TBreathFS<PGraph>::GetHops(const int& SrcNId, const int& DstNId) const {
198    TInt Dist;
199    if (SrcNId!=StartNId) { return -1; }
200    if (! NIdDistH.IsKeyGetDat(DstNId, Dist)) { return -1; }
201    return Dist.Val;
202  }
203  template<class PGraph>
204  int TBreathFS<PGraph>::GetRndPath(const int& SrcNId, const int& DstNId, TIntV& PathNIdV) const {
205    PathNIdV.Clr(false);
206    if (SrcNId!=StartNId || ! NIdDistH.IsKey(DstNId)) { return -1; }
207    PathNIdV.Add(DstNId);
208    TIntV CloserNIdV;
209    int CurNId = DstNId;
210    TInt CurDist, NextDist;
211    while (CurNId != SrcNId) {
212      typename PGraph::TObj::TNodeI NI = Graph->GetNI(CurNId);
213      IAssert(NIdDistH.IsKeyGetDat(CurNId, CurDist));
214      CloserNIdV.Clr(false);
215      for (int e = 0; e < NI.GetDeg(); e++) {
216        const int Next = NI.GetNbrNId(e);
217        if (NIdDistH.IsKeyGetDat(Next, NextDist)) {
218          if (NextDist == CurDist-1) { CloserNIdV.Add(Next); }
219        }
220      }
221      IAssert(! CloserNIdV.Empty());
222      CurNId = CloserNIdV[TInt::Rnd.GetUniDevInt(CloserNIdV.Len())];
223      PathNIdV.Add(CurNId);
224    }
225    PathNIdV.Reverse();
226    return PathNIdV.Len()-1;
227  }
228  namespace TSnap {
229  template <class PGraph>
230  PNGraph GetBfsTree(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn) {
231    TBreathFS<PGraph> BFS(Graph);
232    BFS.DoBfs(StartNId, FollowOut, FollowIn, -1, TInt::Mx);
<span onclick='openModal()' class='match'>233    PNGraph Tree = TNGraph::New();
234    BFS.NIdDistH.SortByDat();
235    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
</span>236      const int NId = BFS.NIdDistH.GetKey(i);
237      const int Dist = BFS.NIdDistH[i];
238      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
239      if (!Tree->IsNode(NId)) {
240        Tree->AddNode(NId);
241      }
242      if (FollowOut) {
243        for (int e = 0; e < NI.GetInDeg(); e++) {
244          const int Prev = NI.GetInNId(e);
245          if (Tree->IsNode(Prev) && BFS.NIdDistH.GetDat(Prev)==Dist-1) {
246            Tree->AddEdge(Prev, NId); }
247        }
248      }
249      if (FollowIn) {
250        for (int e = 0; e < NI.GetOutDeg(); e++) {
251          const int Prev = NI.GetOutNId(e);
252          if (Tree->IsNode(Prev) && BFS.NIdDistH.GetDat(Prev)==Dist-1) {
253            Tree->AddEdge(Prev, NId); }
254        }
255      }
256    }
257    return Tree;
258  }
259  template <class PGraph>
260  int GetSubTreeSz(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn, int& TreeSz, int& TreeDepth) {
261    TBreathFS<PGraph> BFS(Graph);
262    BFS.DoBfs(StartNId, FollowOut, FollowIn, -1, TInt::Mx);
263    TreeSz = BFS.NIdDistH.Len();
264    TreeDepth = 0;
265    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
266      TreeDepth = TMath::Mx(TreeDepth, BFS.NIdDistH[i].Val);
267    }
268    return TreeSz;
269  }
270  template <class PGraph>
271  int GetNodesAtHop(const PGraph& Graph, const int& StartNId, const int& Hop, TIntV& NIdV, const bool& IsDir) {
272    TBreathFS<PGraph> BFS(Graph);
273    BFS.DoBfs(StartNId, true, !IsDir, -1, Hop);
274    NIdV.Clr(false);
275    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
276      if (BFS.NIdDistH[i] == Hop) {
277        NIdV.Add(BFS.NIdDistH.GetKey(i)); }
278    }
279    return NIdV.Len();
280  }
281  template <class PGraph>
282  int GetNodesAtHops(const PGraph& Graph, const int& StartNId, TIntPrV& HopCntV, const bool& IsDir) {
283    TBreathFS<PGraph> BFS(Graph);
284    BFS.DoBfs(StartNId, true, !IsDir, -1, TInt::Mx);
285    TIntH HopCntH;
286    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
287      HopCntH.AddDat(BFS.NIdDistH[i]) += 1;
288    }
289    HopCntH.GetKeyDatPrV(HopCntV);
290    HopCntV.Sort();
291    return HopCntV.Len();
292  }
293  template <class PGraph>
294  int GetShortPath(const PGraph& Graph, const int& SrcNId, TIntH& NIdToDistH, const bool& IsDir, const int& MaxDist) {
295    TBreathFS<PGraph> BFS(Graph);
296    BFS.DoBfs(SrcNId, true, ! IsDir, -1, MaxDist);
297    NIdToDistH.Clr();
298    NIdToDistH.Swap(BFS.NIdDistH);
299    return NIdToDistH[NIdToDistH.Len()-1];
300  }
301  template <class PGraph>
302  int GetShortPath(const PGraph& Graph, const int& SrcNId, const int& DstNId, const bool& IsDir) {
303    TBreathFS<PGraph> BFS(Graph);
304    BFS.DoBfs(SrcNId, true, ! IsDir, DstNId, TInt::Mx);
305    return BFS.GetHops(SrcNId, DstNId);
306  }
307  template <class PGraph>
308  int GetBfsFullDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir) {
309    int FullDiam;
310    double EffDiam;
311    GetBfsEffDiam(Graph, NTestNodes, IsDir, EffDiam, FullDiam);
312    return FullDiam;
313  }
314  template <class PGraph>
315  double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir) {
316    int FullDiam;
317    double EffDiam;
318    GetBfsEffDiam(Graph, NTestNodes, IsDir, EffDiam, FullDiam);
319    return EffDiam;
320  }
321  template <class PGraph>
322  double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiam, int& FullDiam) {
323    double AvgDiam;
324    EffDiam = -1;  FullDiam = -1;
325    return GetBfsEffDiam(Graph, NTestNodes, IsDir, EffDiam, FullDiam, AvgDiam);
326  }
327  template <class PGraph>
328  double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiam, int& FullDiam, double& AvgSPL) {
329    EffDiam = -1;  FullDiam = -1;  AvgSPL = -1;
330    TIntFltH DistToCntH;
331    TBreathFS<PGraph> BFS(Graph);
332    TIntV NodeIdV;
333    Graph->GetNIdV(NodeIdV);  NodeIdV.Shuffle(TInt::Rnd);
334    for (int tries = 0; tries < TMath::Mn(NTestNodes, Graph->GetNodes()); tries++) {
335      const int NId = NodeIdV[tries];
336      BFS.DoBfs(NId, true, ! IsDir, -1, TInt::Mx);
337      for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
338        DistToCntH.AddDat(BFS.NIdDistH[i]) += 1; }
339    }
340    TIntFltKdV DistNbrsPdfV;
341    double SumPathL=0, PathCnt=0;
342    for (int i = 0; i < DistToCntH.Len(); i++) {
343      DistNbrsPdfV.Add(TIntFltKd(DistToCntH.GetKey(i), DistToCntH[i]));
344      SumPathL += DistToCntH.GetKey(i) * DistToCntH[i];
345      PathCnt += DistToCntH[i];
346    }
347    DistNbrsPdfV.Sort();
348    EffDiam = TSnap::TSnapDetail::CalcEffDiamPdf(DistNbrsPdfV, 0.9); 
349    FullDiam = DistNbrsPdfV.Last().Key;                
350    AvgSPL = SumPathL/PathCnt;                        
351    return EffDiam;
352  }
353  template <class PGraph>
354  double GetBfsEffDiamAll(const PGraph& Graph, const int& NTestNodes, const bool& IsDir, double& EffDiam, int& FullDiam, double& AvgSPL) {
355    return GetBfsEffDiam(Graph, NTestNodes, IsDir, EffDiam, FullDiam, AvgSPL);
356  }
357  template <class PGraph>
358  double GetBfsEffDiam(const PGraph& Graph, const int& NTestNodes, const TIntV& SubGraphNIdV, const bool& IsDir, double& EffDiam, int& FullDiam) {
359    EffDiam = -1;
360    FullDiam = -1;
361    TIntFltH DistToCntH;
362    TBreathFS<PGraph> BFS(Graph);
363    TIntV NodeIdV(SubGraphNIdV);  NodeIdV.Shuffle(TInt::Rnd);
364    TInt Dist;
365    for (int tries = 0; tries < TMath::Mn(NTestNodes, SubGraphNIdV.Len()); tries++) {
366      const int NId = NodeIdV[tries];
367      BFS.DoBfs(NId, true, ! IsDir, -1, TInt::Mx);
368      for (int i = 0; i < SubGraphNIdV.Len(); i++) {
369        if (BFS.NIdDistH.IsKeyGetDat(SubGraphNIdV[i], Dist)) {
370          DistToCntH.AddDat(Dist) += 1;
371        }
372      }
373    }
374    TIntFltKdV DistNbrsPdfV;
375    for (int i = 0; i < DistToCntH.Len(); i++) {
376      DistNbrsPdfV.Add(TIntFltKd(DistToCntH.GetKey(i), DistToCntH[i]));
377    }
378    DistNbrsPdfV.Sort();
379    EffDiam = TSnap::TSnapDetail::CalcEffDiamPdf(DistNbrsPdfV, 0.9);  
380    FullDiam = DistNbrsPdfV.Last().Key;                 
381    return EffDiam;                                     
382  }
383  template <class PGraph>
384  int GetShortestDistances(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn, TIntV& ShortestDists) {
385    PSOut StdOut = TStdOut::New();
386    int MxNId = Graph->GetMxNId();
387    int NonNodeDepth = 2147483647; 
388    int InfDepth = 2147483646; 
389    ShortestDists.Gen(MxNId);
390    for (int NId = 0; NId < MxNId; NId++) {
391      if (Graph->IsNode(NId)) { ShortestDists[NId] = InfDepth; }
392      else { ShortestDists[NId] = NonNodeDepth; }
393    }
394    TIntV Vec1(MxNId, 0); 
395    TIntV Vec2(MxNId, 0); 
396    ShortestDists[StartNId] = 0;
397    TIntV* PCurV = &Vec1;
398    PCurV->Add(StartNId);
399    TIntV* PNextV = &Vec2;
400    int Depth = 0; 
401    while (!PCurV->Empty()) {
402      Depth++; 
403      for (int i = 0; i < PCurV->Len(); i++) {
404        int NId = PCurV->GetVal(i);
405        typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
406        for (int e = 0; e < NI.GetOutDeg(); e++) {
407          const int OutNId = NI.GetOutNId(e);
408          if (ShortestDists[OutNId].Val == InfDepth) {
409            ShortestDists[OutNId] = Depth;
410            PNextV->Add(OutNId);
411          }
412        }
413      }
414      TIntV* Tmp = PCurV;
415      PCurV = PNextV;
416      PNextV = Tmp;
417      PNextV->Reduce(0); 
418    }
419    return Depth-1;
420  }
421  #ifdef USE_OPENMP
422  template <class PGraph>
423  int GetShortestDistancesMP2(const PGraph& Graph, const int& StartNId, const bool& FollowOut, const bool& FollowIn, TIntV& ShortestDists) {
424    int MxNId = Graph->GetMxNId();
425    int NonNodeDepth = 2147483647; 
426    int InfDepth = 2147483646; 
427    ShortestDists.Gen(MxNId);
428    #pragma omp parallel for schedule(dynamic,10000)
429    for (int NId = 0; NId < MxNId; NId++) {
430      if (Graph->IsNode(NId)) { ShortestDists[NId] = InfDepth; }
431      else { ShortestDists[NId] = NonNodeDepth; }
432    }
433    TIntV Vec1(MxNId, 0); 
434    TIntV Vec2(MxNId, 0); 
435    ShortestDists[StartNId] = 0;
436    TIntV* PCurV = &Vec1;
437    PCurV->Add(StartNId);
438    TIntV* PNextV = &Vec2;
439    int Depth = 0; 
440    while (!PCurV->Empty()) {
441      Depth++; 
442      #pragma omp parallel for schedule(dynamic,10000)
443      for (int i = 0; i < PCurV->Len(); i++) {
444        int NId = PCurV->GetVal(i);
445        typename PGraph::TObj::TNodeI NI = Graph->GetNI(NId);
446        for (int e = 0; e < NI.GetOutDeg(); e++) {
447          const int OutNId = NI.GetOutNId(e);
448          if (__sync_bool_compare_and_swap(&(ShortestDists[OutNId].Val), InfDepth, Depth)) {
449            PNextV->AddMP(OutNId);
450          }
451        }
452      }
453      TIntV* Tmp = PCurV;
454      PCurV = PNextV;
455      PNextV = Tmp;
456      PNextV->Reduce(0); 
457    }
458    return Depth-1;
459  }
460  #endif 
461  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tbhc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bfsdfs.h</div>
                </div>
                <div class="column column_space"><pre><code>28      PHcDoc Doc=HcBase->GetDoc(DocId);
29      DocWordsH.Clr();
30      for (int WordN=0; WordN<Doc->Len(); WordN++){
</pre></code></div>
                <div class="column column_space"><pre><code>233    PNGraph Tree = TNGraph::New();
234    BFS.NIdDistH.SortByDat();
235    for (int i = 0; i < BFS.NIdDistH.Len(); i++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    