
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.587479935794542%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "alignedblob.h"
5  #include "blobbox.h"
6  #include "crakedge.h" 
7  #include "edgblob.h"
8  #include "linefind.h"
9  #include "tabvector.h"
10  #if defined(USE_OPENCL)
11  #  include "openclwrapper.h" 
12  #endif
13  #include <algorithm>
14  namespace tesseract {
15  const int kThinLineFraction = 20;
16  const int kMinLineLengthFraction = 4;
17  const int kCrackSpacing = 100;
18  const int kLineFindGridSize = 50;
19  const int kMinThickLineWidth = 12;
20  const int kMaxLineResidue = 6;
21  const double kThickLengthMultiple = 0.75;
22  const double kMaxNonLineDensity = 0.25;
23  const double kMaxStaveHeight = 1.0;
24  const double kMinMusicPixelFraction = 0.75;
25  static void RemoveUnusedLineSegments(bool horizontal_lines, BLOBNBOX_LIST *line_bblobs,
26                                       Image line_pix) {
27    int height = pixGetHeight(line_pix);
28    BLOBNBOX_IT bbox_it(line_bblobs);
29    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
30      BLOBNBOX *blob = bbox_it.data();
31      if (blob->left_tab_type() != TT_VLINE) {
32        const TBOX &box = blob->bounding_box();
33        Box *pixbox = nullptr;
34        if (horizontal_lines) {
35          pixbox = boxCreate(box.bottom(), height - box.right(), box.height(), box.width());
36        } else {
37          pixbox = boxCreate(box.left(), height - box.top(), box.width(), box.height());
38        }
39        pixClearInRect(line_pix, pixbox);
40        boxDestroy(&pixbox);
41      }
42    }
43  }
44  static void SubtractLinesAndResidue(Image line_pix, Image non_line_pix,
45                                      Image src_pix) {
46    pixSubtract(src_pix, src_pix, line_pix);
47    Image residue_pix = pixSubtract(nullptr, src_pix, non_line_pix);
48    Image fat_line_pix = pixDilateBrick(nullptr, line_pix, 3, 3);
49    pixSeedfillBinary(fat_line_pix, fat_line_pix, residue_pix, 8);
50    pixSubtract(src_pix, src_pix, fat_line_pix);
51    fat_line_pix.destroy();
52    residue_pix.destroy();
53  }
54  static int MaxStrokeWidth(Image pix) {
55    Image dist_pix = pixDistanceFunction(pix, 4, 8, L_BOUNDARY_BG);
56    int width = pixGetWidth(dist_pix);
57    int height = pixGetHeight(dist_pix);
58    int wpl = pixGetWpl(dist_pix);
59    l_uint32 *data = pixGetData(dist_pix);
60    int max_dist = 0;
61    for (int y = 0; y < height; ++y) {
62      for (int x = 0; x < width; ++x) {
63        int pixel = GET_DATA_BYTE(data, x);
64        if (pixel > max_dist) {
65          max_dist = pixel;
66        }
67      }
68      data += wpl;
69    }
70    dist_pix.destroy();
71    return max_dist * 2;
72  }
73  static int NumTouchingIntersections(Box *line_box, Image intersection_pix) {
74    if (intersection_pix == nullptr) {
75      return 0;
76    }
77    Image rect_pix = pixClipRectangle(intersection_pix, line_box, nullptr);
78    Boxa *boxa = pixConnComp(rect_pix, nullptr, 8);
79    rect_pix.destroy();
80    if (boxa == nullptr) {
81      return false;
82    }
83    int result = boxaGetCount(boxa);
84    boxaDestroy(&boxa);
85    return result;
86  }
87  static int CountPixelsAdjacentToLine(int line_width, Box *line_box, Image nonline_pix) {
88    l_int32 x, y, box_width, box_height;
89    boxGetGeometry(line_box, &x, &y, &box_width, &box_height);
90    if (box_width > box_height) {
91      int bottom = std::min(pixGetHeight(nonline_pix), y + box_height + line_width);
92      y = std::max(0, y - line_width);
93      box_height = bottom - y;
94    } else {
95      int right = std::min(pixGetWidth(nonline_pix), x + box_width + line_width);
96      x = std::max(0, x - line_width);
97      box_width = right - x;
98    }
99    Box *box = boxCreate(x, y, box_width, box_height);
100    Image rect_pix = pixClipRectangle(nonline_pix, box, nullptr);
101    boxDestroy(&box);
102    l_int32 result;
103    pixCountPixels(rect_pix, &result, nullptr);
104    rect_pix.destroy();
105    return result;
106  }
107  static int FilterFalsePositives(int resolution, Image nonline_pix, Image intersection_pix,
108                                  Image line_pix) {
109    int min_thick_length = static_cast<int>(resolution * kThickLengthMultiple);
110    Pixa *pixa = nullptr;
111    Boxa *boxa = pixConnComp(line_pix, &pixa, 8);
112    int nboxes = boxaGetCount(boxa);
113    int remaining_boxes = nboxes;
114    for (int i = 0; i < nboxes; ++i) {
115      Box *box = boxaGetBox(boxa, i, L_CLONE);
116      l_int32 x, y, box_width, box_height;
117      boxGetGeometry(box, &x, &y, &box_width, &box_height);
118      Image comp_pix = pixaGetPix(pixa, i, L_CLONE);
119      int max_width = MaxStrokeWidth(comp_pix);
120      comp_pix.destroy();
121      bool bad_line = false;
122      if (box_width >= kMinThickLineWidth && box_height >= kMinThickLineWidth &&
123          box_width < min_thick_length && box_height < min_thick_length &&
124          max_width > kMinThickLineWidth) {
125        bad_line = true;
126      }
127      if (!bad_line && (NumTouchingIntersections(box, intersection_pix) < 2)) {
128        int nonline_count = CountPixelsAdjacentToLine(max_width, box, nonline_pix);
129        if (nonline_count > box_height * box_width * kMaxNonLineDensity) {
130          bad_line = true;
131        }
132      }
133      if (bad_line) {
134        pixClearInRect(line_pix, box);
135        --remaining_boxes;
136      }
137      boxDestroy(&box);
138    }
139    pixaDestroy(&pixa);
140    boxaDestroy(&boxa);
141    return remaining_boxes;
142  }
143  static void ConvertBoxaToBlobs(int image_width, int image_height, Boxa **boxes,
144                                 C_BLOB_LIST *blobs) {
145    C_OUTLINE_LIST outlines;
146    C_OUTLINE_IT ol_it = &outlines;
147    int nboxes = boxaGetCount(*boxes);
148    for (int i = 0; i < nboxes; ++i) {
149      l_int32 x, y, width, height;
150      boxaGetBoxGeometry(*boxes, i, &x, &y, &width, &height);
151      ICOORD top_left(x, y);
152      ICOORD bot_right(x + width, y + height);
153      CRACKEDGE startpt;
154      startpt.pos = top_left;
155      auto *outline = new C_OUTLINE(&startpt, top_left, bot_right, 0);
156      ol_it.add_after_then_move(outline);
157    }
158    BLOCK block;
159    ICOORD page_tl(0, 0);
160    ICOORD page_br(image_width, image_height);
161    outlines_to_blobs(&block, page_tl, page_br, &outlines);
162    C_BLOB_IT blob_it(blobs);
163    blob_it.add_list_after(block.blob_list());
164    boxaDestroy(boxes);
165  }
166  static void GetLineBoxes(bool horizontal_lines, Image pix_lines, Image pix_intersections,
167                           C_BLOB_LIST *line_cblobs, BLOBNBOX_LIST *line_bblobs) {
168    int wpl = pixGetWpl(pix_lines);
169    int width = pixGetWidth(pix_lines);
170    int height = pixGetHeight(pix_lines);
171    l_uint32 *data = pixGetData(pix_lines);
172    if (horizontal_lines) {
173      for (int y = 0; y < height; ++y, data += wpl) {
174        for (int x = kCrackSpacing; x < width; x += kCrackSpacing) {
175          CLEAR_DATA_BIT(data, x);
176        }
177      }
178    } else {
179      for (int y = kCrackSpacing; y < height; y += kCrackSpacing) {
180        memset(data + wpl * y, 0, wpl * sizeof(*data));
181      }
182    }
183    Boxa *boxa = pixConnComp(pix_lines, nullptr, 8);
184    ConvertBoxaToBlobs(width, height, &boxa, line_cblobs);
185    C_BLOB_IT blob_it(line_cblobs);
186    BLOBNBOX_IT bbox_it(line_bblobs);
187    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
188      C_BLOB *cblob = blob_it.data();
189      auto *bblob = new BLOBNBOX(cblob);
190      bbox_it.add_to_end(bblob);
191      const TBOX &bbox = bblob->bounding_box();
192      Box *box = boxCreate(bbox.left(), bbox.bottom(), bbox.width(), bbox.height());
193      bblob->set_line_crossings(NumTouchingIntersections(box, pix_intersections));
194      boxDestroy(&box);
195      if (horizontal_lines) {
196        TBOX new_box(height - bbox.top(), bbox.left(), height - bbox.bottom(), bbox.right());
197        bblob->set_bounding_box(new_box);
198      } else {
199        TBOX new_box(bbox.left(), height - bbox.top(), bbox.right(), height - bbox.bottom());
200        bblob->set_bounding_box(new_box);
201      }
202    }
203  }
204  static void FindLineVectors(const ICOORD &bleft, const ICOORD &tright,
205                              BLOBNBOX_LIST *line_bblobs, int *vertical_x, int *vertical_y,
206                              TabVector_LIST *vectors) {
207    BLOBNBOX_IT bbox_it(line_bblobs);
208    int b_count = 0;
209    AlignedBlob blob_grid(kLineFindGridSize, bleft, tright);
210    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
211      BLOBNBOX *bblob = bbox_it.data();
212      bblob->set_left_tab_type(TT_MAYBE_ALIGNED);
213      bblob->set_left_rule(bleft.x());
214      bblob->set_right_rule(tright.x());
215      bblob->set_left_crossing_rule(bleft.x());
216      bblob->set_right_crossing_rule(tright.x());
217      blob_grid.InsertBBox(false, true, bblob);
218      ++b_count;
219    }
220    if (b_count == 0) {
221      return;
222    }
223    BlobGridSearch lsearch(&blob_grid);
224    BLOBNBOX *bbox;
225    TabVector_IT vector_it(vectors);
226    *vertical_x = 0;
227    *vertical_y = 1;
228    lsearch.StartFullSearch();
229    while ((bbox = lsearch.NextFullSearch()) != nullptr) {
230      if (bbox->left_tab_type() == TT_MAYBE_ALIGNED) {
231        const TBOX &box = bbox->bounding_box();
232        if (AlignedBlob::WithinTestRegion(2, box.left(), box.bottom())) {
233          tprintf("Finding line vector starting at bbox (%d,%d)\n", box.left(), box.bottom());
234        }
235        AlignedBlobParams align_params(*vertical_x, *vertical_y, box.width());
236        TabVector *vector =
237            blob_grid.FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
238        if (vector != nullptr) {
239          vector->Freeze();
240          vector_it.add_to_end(vector);
241        }
242      }
243    }
244  }
245  static Image FilterMusic(int resolution, Image pix_closed, Image pix_vline, Image pix_hline,
246                          bool &v_empty, bool &h_empty) {
247    int max_stave_height = static_cast<int>(resolution * kMaxStaveHeight);
248    Image intersection_pix = pix_vline & pix_hline;
249    Boxa *boxa = pixConnComp(pix_vline, nullptr, 8);
250    int nboxes = boxaGetCount(boxa);
251    Image music_mask = nullptr;
252    for (int i = 0; i < nboxes; ++i) {
253      Box *box = boxaGetBox(boxa, i, L_CLONE);
254      l_int32 x, y, box_width, box_height;
255      boxGetGeometry(box, &x, &y, &box_width, &box_height);
256      int joins = NumTouchingIntersections(box, intersection_pix);
257      if (joins >= 5 && (joins - 1) * max_stave_height >= 4 * box_height) {
258        if (music_mask == nullptr) {
259          music_mask = pixCreate(pixGetWidth(pix_vline), pixGetHeight(pix_vline), 1);
260        }
261        pixSetInRect(music_mask, box);
262      }
263      boxDestroy(&box);
264    }
265    boxaDestroy(&boxa);
266    intersection_pix.destroy();
267    if (music_mask != nullptr) {
268      pixSeedfillBinary(music_mask, music_mask, pix_closed, 8);
269      Boxa *boxa = pixConnComp(music_mask, nullptr, 8);
270      int nboxes = boxaGetCount(boxa);
271      for (int i = 0; i < nboxes; ++i) {
272        Box *box = boxaGetBox(boxa, i, L_CLONE);
273        Image rect_pix = pixClipRectangle(music_mask, box, nullptr);
274        l_int32 music_pixels;
275        pixCountPixels(rect_pix, &music_pixels, nullptr);
276        rect_pix.destroy();
277        rect_pix = pixClipRectangle(pix_closed, box, nullptr);
278        l_int32 all_pixels;
279        pixCountPixels(rect_pix, &all_pixels, nullptr);
280        rect_pix.destroy();
281        if (music_pixels < kMinMusicPixelFraction * all_pixels) {
282          pixClearInRect(music_mask, box);
283        }
284        boxDestroy(&box);
285      }
286      boxaDestroy(&boxa);
287      if (music_mask.isZero()) {
288        music_mask.destroy();
289      } else {
290        pixSubtract(pix_vline, pix_vline, music_mask);
291        pixSubtract(pix_hline, pix_hline, music_mask);
292        v_empty = pix_vline.isZero();
293        h_empty = pix_hline.isZero();
294      }
295    }
296    return music_mask;
297  }
298  static void GetLineMasks(int resolution, Image src_pix, Image *pix_vline, Image *pix_non_vline,
299                           Image *pix_hline, Image *pix_non_hline, Image *pix_intersections,
300                           Image *pix_music_mask, Pixa *pixa_display) {
301    Image pix_closed = nullptr;
302    Image pix_hollow = nullptr;
303    int max_line_width = resolution / kThinLineFraction;
304    int min_line_length = resolution / kMinLineLengthFraction;
305    if (pixa_display != nullptr) {
306      tprintf("Image resolution = %d, max line width = %d, min length=%d\n", resolution,
307              max_line_width, min_line_length);
308    }
309    int closing_brick = max_line_width / 3;
310  #ifdef USE_OPENCL
311    if (OpenclDevice::selectedDeviceIsOpenCL()) {
312      int clStatus =
313          OpenclDevice::initMorphCLAllocations(pixGetWpl(src_pix), pixGetHeight(src_pix), src_pix);
314      bool getpixclosed = pix_music_mask != nullptr;
315      OpenclDevice::pixGetLinesCL(nullptr, src_pix, pix_vline, pix_hline, &pix_closed, getpixclosed,
316                                  closing_brick, closing_brick, max_line_width, max_line_width,
317                                  min_line_length, min_line_length);
318    } else {
319  #endif
320      pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
321      if (pixa_display != nullptr) {
322        pixaAddPix(pixa_display, pix_closed, L_CLONE);
323      }
324      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
325      if (pixa_display != nullptr) {
326        pixaAddPix(pixa_display, pix_solid, L_CLONE);
327      }
328      pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
329      pix_solid.destroy();
330      if (pixa_display != nullptr) {
331        pixaAddPix(pixa_display, pix_hollow, L_CLONE);
332      }
333      *pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
334      *pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
335      pix_hollow.destroy();
336  #ifdef USE_OPENCL
337    }
338  #endif
339    bool v_empty = pix_vline->isZero();
340    bool h_empty = pix_hline->isZero();
341    if (pix_music_mask != nullptr) {
342      if (!v_empty && !h_empty) {
343        *pix_music_mask =
344            FilterMusic(resolution, pix_closed, *pix_vline, *pix_hline, v_empty, h_empty);
345      } else {
346        *pix_music_mask = nullptr;
347      }
348    }
349    pix_closed.destroy();
350    Image pix_nonlines = nullptr;
351    *pix_intersections = nullptr;
352    Image extra_non_hlines = nullptr;
353    if (!v_empty) {
354      pix_nonlines = pixSubtract(nullptr, src_pix, *pix_vline);
355      if (!h_empty) {
356        pixSubtract(pix_nonlines, pix_nonlines, *pix_hline);
357        *pix_intersections = *pix_vline & *pix_hline;
358        extra_non_hlines = pixSubtract(nullptr, *pix_vline, *pix_intersections);
359      }
360      *pix_non_vline = pixErodeBrick(nullptr, pix_nonlines, kMaxLineResidue, 1);
361      pixSeedfillBinary(*pix_non_vline, *pix_non_vline, pix_nonlines, 8);
362      if (!h_empty) {
363        *pix_non_vline |= *pix_hline;
364        pixSubtract(*pix_non_vline, *pix_non_vline, *pix_intersections);
365      }
366      if (!FilterFalsePositives(resolution, *pix_non_vline, *pix_intersections, *pix_vline)) {
367        pix_vline->destroy(); 
368      }
369    } else {
370      pix_vline->destroy();
371      *pix_non_vline = nullptr;
372      if (!h_empty) {
373        pix_nonlines = pixSubtract(nullptr, src_pix, *pix_hline);
374      }
375    }
376    if (h_empty) {
377      pix_hline->destroy();
378      *pix_non_hline = nullptr;
379      if (v_empty) {
380        return;
381      }
382    } else {
383      *pix_non_hline = pixErodeBrick(nullptr, pix_nonlines, 1, kMaxLineResidue);
384      pixSeedfillBinary(*pix_non_hline, *pix_non_hline, pix_nonlines, 8);
385      if (extra_non_hlines != nullptr) {
386        *pix_non_hline |= extra_non_hlines;
387        extra_non_hlines.destroy();
388      }
389      if (!FilterFalsePositives(resolution, *pix_non_hline, *pix_intersections, *pix_hline)) {
390        pix_hline->destroy(); 
391      }
392    }
393    if (pixa_display != nullptr) {
394      if (*pix_vline != nullptr) {
395        pixaAddPix(pixa_display, *pix_vline, L_CLONE);
396      }
397      if (*pix_hline != nullptr) {
398        pixaAddPix(pixa_display, *pix_hline, L_CLONE);
399      }
400      if (pix_nonlines != nullptr) {
401        pixaAddPix(pixa_display, pix_nonlines, L_CLONE);
402      }
403      if (*pix_non_vline != nullptr) {
404        pixaAddPix(pixa_display, *pix_non_vline, L_CLONE);
405      }
406      if (*pix_non_hline != nullptr) {
407        pixaAddPix(pixa_display, *pix_non_hline, L_CLONE);
408      }
409      if (*pix_intersections != nullptr) {
410        pixaAddPix(pixa_display, *pix_intersections, L_CLONE);
411      }
412      if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
413        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
414      }
415    }
416    pix_nonlines.destroy();
417  }
418  static void FindAndRemoveVLines(Image pix_intersections, int *vertical_x,
419                                  int *vertical_y, Image *pix_vline, Image pix_non_vline,
420                                  Image src_pix, TabVector_LIST *vectors) {
421    if (pix_vline == nullptr || *pix_vline == nullptr) {
422      return;
423    }
<span onclick='openModal()' class='match'>424    C_BLOB_LIST line_cblobs;
425    BLOBNBOX_LIST line_bblobs;
426    GetLineBoxes(false, *pix_vline, pix_intersections, &line_cblobs, &line_bblobs);
427    int width = pixGetWidth(src_pix);
428    int height = pixGetHeight(src_pix);
429    ICOORD bleft(0, 0);
</span>430    ICOORD tright(width, height);
431    FindLineVectors(bleft, tright, &line_bblobs, vertical_x, vertical_y, vectors);
432    if (!vectors->empty()) {
433      RemoveUnusedLineSegments(false, &line_bblobs, *pix_vline);
434      SubtractLinesAndResidue(*pix_vline, pix_non_vline, src_pix);
435      ICOORD vertical;
436      vertical.set_with_shrink(*vertical_x, *vertical_y);
437      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
438    } else {
439      pix_vline->destroy();
440    }
441  }
442  static void FindAndRemoveHLines(Image pix_intersections, int vertical_x,
443                                  int vertical_y, Image *pix_hline, Image pix_non_hline,
444                                  Image src_pix, TabVector_LIST *vectors) {
445    if (pix_hline == nullptr || *pix_hline == nullptr) {
446      return;
447    }
448    C_BLOB_LIST line_cblobs;
449    BLOBNBOX_LIST line_bblobs;
450    GetLineBoxes(true, *pix_hline, pix_intersections, &line_cblobs, &line_bblobs);
451    int width = pixGetWidth(src_pix);
452    int height = pixGetHeight(src_pix);
453    ICOORD bleft(0, 0);
454    ICOORD tright(height, width);
455    FindLineVectors(bleft, tright, &line_bblobs, &vertical_x, &vertical_y, vectors);
456    if (!vectors->empty()) {
457      RemoveUnusedLineSegments(true, &line_bblobs, *pix_hline);
458      SubtractLinesAndResidue(*pix_hline, pix_non_hline, src_pix);
459      ICOORD vertical;
460      vertical.set_with_shrink(vertical_x, vertical_y);
461      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
462      TabVector_IT h_it(vectors);
463      for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
464        h_it.data()->XYFlip();
465      }
466    } else {
467      pix_hline->destroy();
468    }
469  }
470  void LineFinder::FindAndRemoveLines(int resolution, bool debug, Image pix, int *vertical_x,
471                                      int *vertical_y, Image *pix_music_mask, TabVector_LIST *v_lines,
472                                      TabVector_LIST *h_lines) {
473    if (pix == nullptr || vertical_x == nullptr || vertical_y == nullptr) {
474      tprintf("Error in parameters for LineFinder::FindAndRemoveLines\n");
475      return;
476    }
477    Image pix_vline = nullptr;
478    Image pix_non_vline = nullptr;
479    Image pix_hline = nullptr;
480    Image pix_non_hline = nullptr;
481    Image pix_intersections = nullptr;
482    Pixa *pixa_display = debug ? pixaCreate(0) : nullptr;
483    GetLineMasks(resolution, pix, &pix_vline, &pix_non_vline, &pix_hline, &pix_non_hline,
484                 &pix_intersections, pix_music_mask, pixa_display);
485    FindAndRemoveVLines(pix_intersections, vertical_x, vertical_y, &pix_vline,
486                        pix_non_vline, pix, v_lines);
487    pix_intersections.destroy();
488    if (pix_hline != nullptr) {
489      if (pix_vline != nullptr) {
490        pix_intersections = pix_vline & pix_hline;
491      }
492      if (!FilterFalsePositives(resolution, pix_non_hline, pix_intersections, pix_hline)) {
493        pix_hline.destroy();
494      }
495    }
496    FindAndRemoveHLines(pix_intersections, *vertical_x, *vertical_y, &pix_hline,
497                        pix_non_hline, pix, h_lines);
498    if (pixa_display != nullptr && pix_vline != nullptr) {
499      pixaAddPix(pixa_display, pix_vline, L_CLONE);
500    }
501    if (pixa_display != nullptr && pix_hline != nullptr) {
502      pixaAddPix(pixa_display, pix_hline, L_CLONE);
503    }
504    pix_intersections.destroy();
505    if (pix_vline != nullptr && pix_hline != nullptr) {
506      pix_intersections = pix_vline & pix_hline;
507      Image pix_join_residue = pixDilateBrick(nullptr, pix_intersections, 5, 5);
508      pixSeedfillBinary(pix_join_residue, pix_join_residue, pix, 8);
509      pixSubtract(pix, pix, pix_join_residue);
510      pix_join_residue.destroy();
511    }
512    if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
513      if (pixa_display != nullptr) {
514        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
515      }
516      pixSubtract(pix, pix, *pix_music_mask);
517    }
518    if (pixa_display != nullptr) {
519      pixaAddPix(pixa_display, pix, L_CLONE);
520    }
521    pix_vline.destroy();
522    pix_non_vline.destroy();
523    pix_hline.destroy();
524    pix_non_hline.destroy();
525    pix_intersections.destroy();
526    if (pixa_display != nullptr) {
527      pixaConvertToPdf(pixa_display, resolution, 1.0f, 0, 0, "LineFinding", "vhlinefinding.pdf");
528      pixaDestroy(&pixa_display);
529    }
530  }
531  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format_test.cc</h3>
            <pre><code>1  #include <chrono>
2  #include <cstdint>
3  #include <iomanip>
4  #include <sstream>
5  #include <string>
6  #include "absl/base/config.h"
7  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
8  #if defined(__linux__)
9  #include <features.h>
10  #endif
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
14  namespace chrono = std::chrono;
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace time_internal {
18  namespace cctz {
19  namespace {
20  #define ExpectTime(tp, tz, y, m, d, hh, mm, ss, off, isdst, zone) \
21    do {                                                            \
22      time_zone::absolute_lookup al = tz.lookup(tp);                \
23      EXPECT_EQ(y, al.cs.year());                                   \
24      EXPECT_EQ(m, al.cs.month());                                  \
25      EXPECT_EQ(d, al.cs.day());                                    \
26      EXPECT_EQ(hh, al.cs.hour());                                  \
27      EXPECT_EQ(mm, al.cs.minute());                                \
28      EXPECT_EQ(ss, al.cs.second());                                \
29      EXPECT_EQ(off, al.offset);                                    \
30      EXPECT_TRUE(isdst == al.is_dst);                              \
31      EXPECT_STREQ(zone, al.abbr);                                  \
32    } while (0)
33  const char RFC3339_full[] = "%Y-%m-%d%ET%H:%M:%E*S%Ez";
34  const char RFC3339_sec[] = "%Y-%m-%d%ET%H:%M:%S%Ez";
35  const char RFC1123_full[] = "%a, %d %b %Y %H:%M:%S %z";
36  const char RFC1123_no_wday[] = "%d %b %Y %H:%M:%S %z";
37  template <typename D>
38  void TestFormatSpecifier(time_point<D> tp, time_zone tz, const std::string& fmt,
39                           const std::string& ans) {
40    EXPECT_EQ(ans, absl::time_internal::cctz::format(fmt, tp, tz)) << fmt;
41    EXPECT_EQ("xxx " + ans,
42              absl::time_internal::cctz::format("xxx " + fmt, tp, tz));
43    EXPECT_EQ(ans + " yyy",
44              absl::time_internal::cctz::format(fmt + " yyy", tp, tz));
45    EXPECT_EQ("xxx " + ans + " yyy",
46              absl::time_internal::cctz::format("xxx " + fmt + " yyy", tp, tz));
47  }
48  }  
49  TEST(Format, TimePointResolution) {
50    const char kFmt[] = "%H:%M:%E*S";
51    const time_zone utc = utc_time_zone();
52    const time_point<chrono::nanoseconds> t0 =
53        chrono::system_clock::from_time_t(1420167845) +
54        chrono::milliseconds(123) + chrono::microseconds(456) +
55        chrono::nanoseconds(789);
56    EXPECT_EQ("03:04:05.123456789",
57              absl::time_internal::cctz::format(
58                  kFmt, chrono::time_point_cast<chrono::nanoseconds>(t0), utc));
59    EXPECT_EQ("03:04:05.123456",
60              absl::time_internal::cctz::format(
61                  kFmt, chrono::time_point_cast<chrono::microseconds>(t0), utc));
62    EXPECT_EQ("03:04:05.123",
63              absl::time_internal::cctz::format(
64                  kFmt, chrono::time_point_cast<chrono::milliseconds>(t0), utc));
65    EXPECT_EQ("03:04:05",
66              absl::time_internal::cctz::format(
67                  kFmt, chrono::time_point_cast<chrono::seconds>(t0), utc));
68    EXPECT_EQ(
69        "03:04:05",
70        absl::time_internal::cctz::format(
71            kFmt, chrono::time_point_cast<absl::time_internal::cctz::seconds>(t0),
72            utc));
73    EXPECT_EQ("03:04:00",
74              absl::time_internal::cctz::format(
75                  kFmt, chrono::time_point_cast<chrono::minutes>(t0), utc));
76    EXPECT_EQ("03:00:00",
77              absl::time_internal::cctz::format(
78                  kFmt, chrono::time_point_cast<chrono::hours>(t0), utc));
79  }
80  TEST(Format, TimePointExtendedResolution) {
81    const char kFmt[] = "%H:%M:%E*S";
82    const time_zone utc = utc_time_zone();
83    const time_point<absl::time_internal::cctz::seconds> tp =
84        chrono::time_point_cast<absl::time_internal::cctz::seconds>(
85            chrono::system_clock::from_time_t(0)) +
86        chrono::hours(12) + chrono::minutes(34) + chrono::seconds(56);
87    EXPECT_EQ(
88        "12:34:56.123456789012345",
89        detail::format(kFmt, tp, detail::femtoseconds(123456789012345), utc));
90    EXPECT_EQ(
91        "12:34:56.012345678901234",
92        detail::format(kFmt, tp, detail::femtoseconds(12345678901234), utc));
93    EXPECT_EQ("12:34:56.001234567890123",
94              detail::format(kFmt, tp, detail::femtoseconds(1234567890123), utc));
95    EXPECT_EQ("12:34:56.000123456789012",
96              detail::format(kFmt, tp, detail::femtoseconds(123456789012), utc));
97    EXPECT_EQ("12:34:56.000000000000123",
98              detail::format(kFmt, tp, detail::femtoseconds(123), utc));
99    EXPECT_EQ("12:34:56.000000000000012",
100              detail::format(kFmt, tp, detail::femtoseconds(12), utc));
101    EXPECT_EQ("12:34:56.000000000000001",
102              detail::format(kFmt, tp, detail::femtoseconds(1), utc));
103  }
104  TEST(Format, Basics) {
105    time_zone tz = utc_time_zone();
106    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
107    EXPECT_EQ("", absl::time_internal::cctz::format("", tp, tz));
108    EXPECT_EQ(" ", absl::time_internal::cctz::format(" ", tp, tz));
109    EXPECT_EQ("  ", absl::time_internal::cctz::format("  ", tp, tz));
110    EXPECT_EQ("xxx", absl::time_internal::cctz::format("xxx", tp, tz));
111    std::string big(128, 'x');
112    EXPECT_EQ(big, absl::time_internal::cctz::format(big, tp, tz));
113    std::string bigger(100000, 'x');
114    EXPECT_EQ(bigger, absl::time_internal::cctz::format(bigger, tp, tz));
115    tp += chrono::hours(13) + chrono::minutes(4) + chrono::seconds(5);
116    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
117          chrono::nanoseconds(8);
118    EXPECT_EQ("1970-01-01",
119              absl::time_internal::cctz::format("%Y-%m-%d", tp, tz));
120    EXPECT_EQ("13:04:05", absl::time_internal::cctz::format("%H:%M:%S", tp, tz));
121    EXPECT_EQ("13:04:05.006",
122              absl::time_internal::cctz::format("%H:%M:%E3S", tp, tz));
123    EXPECT_EQ("13:04:05.006007",
124              absl::time_internal::cctz::format("%H:%M:%E6S", tp, tz));
125    EXPECT_EQ("13:04:05.006007008",
126              absl::time_internal::cctz::format("%H:%M:%E9S", tp, tz));
127  }
128  TEST(Format, PosixConversions) {
129    const time_zone tz = utc_time_zone();
130    auto tp = chrono::system_clock::from_time_t(0);
131    TestFormatSpecifier(tp, tz, "%d", "01");
132    TestFormatSpecifier(tp, tz, "%e", " 1");  
133    TestFormatSpecifier(tp, tz, "%H", "00");
134    TestFormatSpecifier(tp, tz, "%I", "12");
135    TestFormatSpecifier(tp, tz, "%j", "001");
136    TestFormatSpecifier(tp, tz, "%m", "01");
137    TestFormatSpecifier(tp, tz, "%M", "00");
138    TestFormatSpecifier(tp, tz, "%S", "00");
139    TestFormatSpecifier(tp, tz, "%U", "00");
140  #if !defined(__EMSCRIPTEN__)
141    TestFormatSpecifier(tp, tz, "%w", "4");  
142  #endif
143    TestFormatSpecifier(tp, tz, "%W", "00");
144    TestFormatSpecifier(tp, tz, "%y", "70");
145    TestFormatSpecifier(tp, tz, "%Y", "1970");
146    TestFormatSpecifier(tp, tz, "%z", "+0000");
147    TestFormatSpecifier(tp, tz, "%Z", "UTC");
148    TestFormatSpecifier(tp, tz, "%%", "%");
149  #if defined(__linux__)
150    TestFormatSpecifier(tp, tz, "%C", "19");
151    TestFormatSpecifier(tp, tz, "%D", "01/01/70");
152    TestFormatSpecifier(tp, tz, "%F", "1970-01-01");
153    TestFormatSpecifier(tp, tz, "%g", "70");
154    TestFormatSpecifier(tp, tz, "%G", "1970");
155  #if defined(__GLIBC__)
156    TestFormatSpecifier(tp, tz, "%k", " 0");
157    TestFormatSpecifier(tp, tz, "%l", "12");
158  #endif
159    TestFormatSpecifier(tp, tz, "%n", "\n");
160    TestFormatSpecifier(tp, tz, "%R", "00:00");
161    TestFormatSpecifier(tp, tz, "%t", "\t");
162    TestFormatSpecifier(tp, tz, "%T", "00:00:00");
163    TestFormatSpecifier(tp, tz, "%u", "4");  
164    TestFormatSpecifier(tp, tz, "%V", "01");
165    TestFormatSpecifier(tp, tz, "%s", "0");
166  #endif
167  }
<span onclick='openModal()' class='match'>168  TEST(Format, LocaleSpecific) {
169    const time_zone tz = utc_time_zone();
170    auto tp = chrono::system_clock::from_time_t(0);
171    TestFormatSpecifier(tp, tz, "%a", "Thu");
172    TestFormatSpecifier(tp, tz, "%A", "Thursday");
173    TestFormatSpecifier(tp, tz, "%b", "Jan");
174    TestFormatSpecifier(tp, tz, "%B", "January");
175    const std::string s =
</span>176        absl::time_internal::cctz::format("%c", tp, utc_time_zone());
177    EXPECT_THAT(s, testing::HasSubstr("1970"));
178    EXPECT_THAT(s, testing::HasSubstr("00:00:00"));
179    TestFormatSpecifier(tp, tz, "%p", "AM");
180    TestFormatSpecifier(tp, tz, "%x", "01/01/70");
181    TestFormatSpecifier(tp, tz, "%X", "00:00:00");
182  #if defined(__linux__)
183    TestFormatSpecifier(tp, tz, "%h", "Jan");  
184  #if defined(__GLIBC__)
185    TestFormatSpecifier(tp, tz, "%P", "am");
186  #endif
187    TestFormatSpecifier(tp, tz, "%r", "12:00:00 AM");
188    TestFormatSpecifier(tp, tz, "%Ec", "Thu Jan  1 00:00:00 1970");
189    TestFormatSpecifier(tp, tz, "%EC", "19");
190    TestFormatSpecifier(tp, tz, "%Ex", "01/01/70");
191    TestFormatSpecifier(tp, tz, "%EX", "00:00:00");
192    TestFormatSpecifier(tp, tz, "%Ey", "70");
193    TestFormatSpecifier(tp, tz, "%EY", "1970");
194    TestFormatSpecifier(tp, tz, "%Od", "01");
195    TestFormatSpecifier(tp, tz, "%Oe", " 1");
196    TestFormatSpecifier(tp, tz, "%OH", "00");
197    TestFormatSpecifier(tp, tz, "%OI", "12");
198    TestFormatSpecifier(tp, tz, "%Om", "01");
199    TestFormatSpecifier(tp, tz, "%OM", "00");
200    TestFormatSpecifier(tp, tz, "%OS", "00");
201    TestFormatSpecifier(tp, tz, "%Ou", "4");  
202    TestFormatSpecifier(tp, tz, "%OU", "00");
203    TestFormatSpecifier(tp, tz, "%OV", "01");
204    TestFormatSpecifier(tp, tz, "%Ow", "4");  
205    TestFormatSpecifier(tp, tz, "%OW", "00");
206    TestFormatSpecifier(tp, tz, "%Oy", "70");
207  #endif
208  }
209  TEST(Format, Escaping) {
210    const time_zone tz = utc_time_zone();
211    auto tp = chrono::system_clock::from_time_t(0);
212    TestFormatSpecifier(tp, tz, "%%", "%");
213    TestFormatSpecifier(tp, tz, "%%a", "%a");
214    TestFormatSpecifier(tp, tz, "%%b", "%b");
215    TestFormatSpecifier(tp, tz, "%%Ea", "%Ea");
216    TestFormatSpecifier(tp, tz, "%%Es", "%Es");
217    TestFormatSpecifier(tp, tz, "%%E3S", "%E3S");
218    TestFormatSpecifier(tp, tz, "%%OS", "%OS");
219    TestFormatSpecifier(tp, tz, "%%O3S", "%O3S");
220    TestFormatSpecifier(tp, tz, "%%%Y", "%1970");
221    TestFormatSpecifier(tp, tz, "%%%E3S", "%00.000");
222    TestFormatSpecifier(tp, tz, "%%%%E3S", "%%E3S");
223  }
224  TEST(Format, ExtendedSeconds) {
225    const time_zone tz = utc_time_zone();
226    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
227    tp += chrono::seconds(5);
228    EXPECT_EQ("05", absl::time_internal::cctz::format("%E*S", tp, tz));
229    EXPECT_EQ("05", absl::time_internal::cctz::format("%E0S", tp, tz));
230    EXPECT_EQ("05.0", absl::time_internal::cctz::format("%E1S", tp, tz));
231    EXPECT_EQ("05.00", absl::time_internal::cctz::format("%E2S", tp, tz));
232    EXPECT_EQ("05.000", absl::time_internal::cctz::format("%E3S", tp, tz));
233    EXPECT_EQ("05.0000", absl::time_internal::cctz::format("%E4S", tp, tz));
234    EXPECT_EQ("05.00000", absl::time_internal::cctz::format("%E5S", tp, tz));
235    EXPECT_EQ("05.000000", absl::time_internal::cctz::format("%E6S", tp, tz));
236    EXPECT_EQ("05.0000000", absl::time_internal::cctz::format("%E7S", tp, tz));
237    EXPECT_EQ("05.00000000", absl::time_internal::cctz::format("%E8S", tp, tz));
238    EXPECT_EQ("05.000000000", absl::time_internal::cctz::format("%E9S", tp, tz));
239    EXPECT_EQ("05.0000000000",
240              absl::time_internal::cctz::format("%E10S", tp, tz));
241    EXPECT_EQ("05.00000000000",
242              absl::time_internal::cctz::format("%E11S", tp, tz));
243    EXPECT_EQ("05.000000000000",
244              absl::time_internal::cctz::format("%E12S", tp, tz));
245    EXPECT_EQ("05.0000000000000",
246              absl::time_internal::cctz::format("%E13S", tp, tz));
247    EXPECT_EQ("05.00000000000000",
248              absl::time_internal::cctz::format("%E14S", tp, tz));
249    EXPECT_EQ("05.000000000000000",
250              absl::time_internal::cctz::format("%E15S", tp, tz));
251    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
252          chrono::nanoseconds(8);
253    EXPECT_EQ("05.006007008", absl::time_internal::cctz::format("%E*S", tp, tz));
254    EXPECT_EQ("05", absl::time_internal::cctz::format("%E0S", tp, tz));
255    EXPECT_EQ("05.0", absl::time_internal::cctz::format("%E1S", tp, tz));
256    EXPECT_EQ("05.00", absl::time_internal::cctz::format("%E2S", tp, tz));
257    EXPECT_EQ("05.006", absl::time_internal::cctz::format("%E3S", tp, tz));
258    EXPECT_EQ("05.0060", absl::time_internal::cctz::format("%E4S", tp, tz));
259    EXPECT_EQ("05.00600", absl::time_internal::cctz::format("%E5S", tp, tz));
260    EXPECT_EQ("05.006007", absl::time_internal::cctz::format("%E6S", tp, tz));
261    EXPECT_EQ("05.0060070", absl::time_internal::cctz::format("%E7S", tp, tz));
262    EXPECT_EQ("05.00600700", absl::time_internal::cctz::format("%E8S", tp, tz));
263    EXPECT_EQ("05.006007008", absl::time_internal::cctz::format("%E9S", tp, tz));
264    EXPECT_EQ("05.0060070080",
265              absl::time_internal::cctz::format("%E10S", tp, tz));
266    EXPECT_EQ("05.00600700800",
267              absl::time_internal::cctz::format("%E11S", tp, tz));
268    EXPECT_EQ("05.006007008000",
269              absl::time_internal::cctz::format("%E12S", tp, tz));
270    EXPECT_EQ("05.0060070080000",
271              absl::time_internal::cctz::format("%E13S", tp, tz));
272    EXPECT_EQ("05.00600700800000",
273              absl::time_internal::cctz::format("%E14S", tp, tz));
274    EXPECT_EQ("05.006007008000000",
275              absl::time_internal::cctz::format("%E15S", tp, tz));
276    tp = chrono::system_clock::from_time_t(0) + chrono::microseconds(-1);
277    EXPECT_EQ("1969-12-31 23:59:59.999999",
278              absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
279    tp = chrono::system_clock::from_time_t(0) +
280         chrono::microseconds(1395024427333304);
281    EXPECT_EQ("2014-03-17 02:47:07.333304",
282              absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
283    tp += chrono::microseconds(1);
284    EXPECT_EQ("2014-03-17 02:47:07.333305",
285              absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
286  }
287  TEST(Format, ExtendedSubeconds) {
288    const time_zone tz = utc_time_zone();
289    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
290    tp += chrono::seconds(5);
291    EXPECT_EQ("0", absl::time_internal::cctz::format("%E*f", tp, tz));
292    EXPECT_EQ("", absl::time_internal::cctz::format("%E0f", tp, tz));
293    EXPECT_EQ("0", absl::time_internal::cctz::format("%E1f", tp, tz));
294    EXPECT_EQ("00", absl::time_internal::cctz::format("%E2f", tp, tz));
295    EXPECT_EQ("000", absl::time_internal::cctz::format("%E3f", tp, tz));
296    EXPECT_EQ("0000", absl::time_internal::cctz::format("%E4f", tp, tz));
297    EXPECT_EQ("00000", absl::time_internal::cctz::format("%E5f", tp, tz));
298    EXPECT_EQ("000000", absl::time_internal::cctz::format("%E6f", tp, tz));
299    EXPECT_EQ("0000000", absl::time_internal::cctz::format("%E7f", tp, tz));
300    EXPECT_EQ("00000000", absl::time_internal::cctz::format("%E8f", tp, tz));
301    EXPECT_EQ("000000000", absl::time_internal::cctz::format("%E9f", tp, tz));
302    EXPECT_EQ("0000000000", absl::time_internal::cctz::format("%E10f", tp, tz));
303    EXPECT_EQ("00000000000", absl::time_internal::cctz::format("%E11f", tp, tz));
304    EXPECT_EQ("000000000000", absl::time_internal::cctz::format("%E12f", tp, tz));
305    EXPECT_EQ("0000000000000",
306              absl::time_internal::cctz::format("%E13f", tp, tz));
307    EXPECT_EQ("00000000000000",
308              absl::time_internal::cctz::format("%E14f", tp, tz));
309    EXPECT_EQ("000000000000000",
310              absl::time_internal::cctz::format("%E15f", tp, tz));
311    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
312          chrono::nanoseconds(8);
313    EXPECT_EQ("006007008", absl::time_internal::cctz::format("%E*f", tp, tz));
314    EXPECT_EQ("", absl::time_internal::cctz::format("%E0f", tp, tz));
315    EXPECT_EQ("0", absl::time_internal::cctz::format("%E1f", tp, tz));
316    EXPECT_EQ("00", absl::time_internal::cctz::format("%E2f", tp, tz));
317    EXPECT_EQ("006", absl::time_internal::cctz::format("%E3f", tp, tz));
318    EXPECT_EQ("0060", absl::time_internal::cctz::format("%E4f", tp, tz));
319    EXPECT_EQ("00600", absl::time_internal::cctz::format("%E5f", tp, tz));
320    EXPECT_EQ("006007", absl::time_internal::cctz::format("%E6f", tp, tz));
321    EXPECT_EQ("0060070", absl::time_internal::cctz::format("%E7f", tp, tz));
322    EXPECT_EQ("00600700", absl::time_internal::cctz::format("%E8f", tp, tz));
323    EXPECT_EQ("006007008", absl::time_internal::cctz::format("%E9f", tp, tz));
324    EXPECT_EQ("0060070080", absl::time_internal::cctz::format("%E10f", tp, tz));
325    EXPECT_EQ("00600700800", absl::time_internal::cctz::format("%E11f", tp, tz));
326    EXPECT_EQ("006007008000", absl::time_internal::cctz::format("%E12f", tp, tz));
327    EXPECT_EQ("0060070080000",
328              absl::time_internal::cctz::format("%E13f", tp, tz));
329    EXPECT_EQ("00600700800000",
330              absl::time_internal::cctz::format("%E14f", tp, tz));
331    EXPECT_EQ("006007008000000",
332              absl::time_internal::cctz::format("%E15f", tp, tz));
333    tp = chrono::system_clock::from_time_t(0) + chrono::microseconds(-1);
334    EXPECT_EQ(
335        "1969-12-31 23:59:59.999999",
336        absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
337    tp = chrono::system_clock::from_time_t(0) +
338         chrono::microseconds(1395024427333304);
339    EXPECT_EQ(
340        "2014-03-17 02:47:07.333304",
341        absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
342    tp += chrono::microseconds(1);
343    EXPECT_EQ(
344        "2014-03-17 02:47:07.333305",
345        absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
346  }
347  TEST(Format, CompareExtendSecondsVsSubseconds) {
348    const time_zone tz = utc_time_zone();
349    auto fmt_A = [](const std::string& prec) { return "%E" + prec + "S"; };
350    auto fmt_B = [](const std::string& prec) { return "%S.%E" + prec + "f"; };
351    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
352    tp += chrono::seconds(5);
353    EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("*"), tp, tz));
354    EXPECT_EQ("05.0", absl::time_internal::cctz::format(fmt_B("*"), tp, tz));
355    EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("0"), tp, tz));
356    EXPECT_EQ("05.", absl::time_internal::cctz::format(fmt_B("0"), tp, tz));
357    for (int prec = 1; prec <= 15; ++prec) {
358      const std::string a =
359          absl::time_internal::cctz::format(fmt_A(std::to_string(prec)), tp, tz);
360      const std::string b =
361          absl::time_internal::cctz::format(fmt_B(std::to_string(prec)), tp, tz);
362      EXPECT_EQ(a, b) << "prec=" << prec;
363    }
364    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
365          chrono::nanoseconds(8);
366    EXPECT_EQ("05.006007008",
367              absl::time_internal::cctz::format(fmt_A("*"), tp, tz));
368    EXPECT_EQ("05.006007008",
369              absl::time_internal::cctz::format(fmt_B("*"), tp, tz));
370    EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("0"), tp, tz));
371    EXPECT_EQ("05.", absl::time_internal::cctz::format(fmt_B("0"), tp, tz));
372    for (int prec = 1; prec <= 15; ++prec) {
373      const std::string a =
374          absl::time_internal::cctz::format(fmt_A(std::to_string(prec)), tp, tz);
375      const std::string b =
376          absl::time_internal::cctz::format(fmt_B(std::to_string(prec)), tp, tz);
377      EXPECT_EQ(a, b) << "prec=" << prec;
378    }
379  }
380  TEST(Format, ExtendedOffset) {
381    const auto tp = chrono::system_clock::from_time_t(0);
382    auto tz = fixed_time_zone(absl::time_internal::cctz::seconds::zero());
383    TestFormatSpecifier(tp, tz, "%z", "+0000");
384    TestFormatSpecifier(tp, tz, "%:z", "+00:00");
385    TestFormatSpecifier(tp, tz, "%Ez", "+00:00");
386    tz = fixed_time_zone(chrono::seconds(56));
387    TestFormatSpecifier(tp, tz, "%z", "+0000");
388    TestFormatSpecifier(tp, tz, "%:z", "+00:00");
389    TestFormatSpecifier(tp, tz, "%Ez", "+00:00");
390    tz = fixed_time_zone(-chrono::seconds(56));  
391    TestFormatSpecifier(tp, tz, "%z", "+0000");
392    TestFormatSpecifier(tp, tz, "%:z", "+00:00");
393    TestFormatSpecifier(tp, tz, "%Ez", "+00:00");
394    tz = fixed_time_zone(chrono::minutes(34));
395    TestFormatSpecifier(tp, tz, "%z", "+0034");
396    TestFormatSpecifier(tp, tz, "%:z", "+00:34");
397    TestFormatSpecifier(tp, tz, "%Ez", "+00:34");
398    tz = fixed_time_zone(-chrono::minutes(34));
399    TestFormatSpecifier(tp, tz, "%z", "-0034");
400    TestFormatSpecifier(tp, tz, "%:z", "-00:34");
401    TestFormatSpecifier(tp, tz, "%Ez", "-00:34");
402    tz = fixed_time_zone(chrono::minutes(34) + chrono::seconds(56));
403    TestFormatSpecifier(tp, tz, "%z", "+0034");
404    TestFormatSpecifier(tp, tz, "%:z", "+00:34");
405    TestFormatSpecifier(tp, tz, "%Ez", "+00:34");
406    tz = fixed_time_zone(-chrono::minutes(34) - chrono::seconds(56));
407    TestFormatSpecifier(tp, tz, "%z", "-0034");
408    TestFormatSpecifier(tp, tz, "%:z", "-00:34");
409    TestFormatSpecifier(tp, tz, "%Ez", "-00:34");
410    tz = fixed_time_zone(chrono::hours(12));
411    TestFormatSpecifier(tp, tz, "%z", "+1200");
412    TestFormatSpecifier(tp, tz, "%:z", "+12:00");
413    TestFormatSpecifier(tp, tz, "%Ez", "+12:00");
414    tz = fixed_time_zone(-chrono::hours(12));
415    TestFormatSpecifier(tp, tz, "%z", "-1200");
416    TestFormatSpecifier(tp, tz, "%:z", "-12:00");
417    TestFormatSpecifier(tp, tz, "%Ez", "-12:00");
418    tz = fixed_time_zone(chrono::hours(12) + chrono::seconds(56));
419    TestFormatSpecifier(tp, tz, "%z", "+1200");
420    TestFormatSpecifier(tp, tz, "%:z", "+12:00");
421    TestFormatSpecifier(tp, tz, "%Ez", "+12:00");
422    tz = fixed_time_zone(-chrono::hours(12) - chrono::seconds(56));
423    TestFormatSpecifier(tp, tz, "%z", "-1200");
424    TestFormatSpecifier(tp, tz, "%:z", "-12:00");
425    TestFormatSpecifier(tp, tz, "%Ez", "-12:00");
426    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34));
427    TestFormatSpecifier(tp, tz, "%z", "+1234");
428    TestFormatSpecifier(tp, tz, "%:z", "+12:34");
429    TestFormatSpecifier(tp, tz, "%Ez", "+12:34");
430    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34));
431    TestFormatSpecifier(tp, tz, "%z", "-1234");
432    TestFormatSpecifier(tp, tz, "%:z", "-12:34");
433    TestFormatSpecifier(tp, tz, "%Ez", "-12:34");
434    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34) +
435                         chrono::seconds(56));
436    TestFormatSpecifier(tp, tz, "%z", "+1234");
437    TestFormatSpecifier(tp, tz, "%:z", "+12:34");
438    TestFormatSpecifier(tp, tz, "%Ez", "+12:34");
439    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34) -
440                         chrono::seconds(56));
441    TestFormatSpecifier(tp, tz, "%z", "-1234");
442    TestFormatSpecifier(tp, tz, "%:z", "-12:34");
443    TestFormatSpecifier(tp, tz, "%Ez", "-12:34");
444  }
445  TEST(Format, ExtendedSecondOffset) {
446    const auto tp = chrono::system_clock::from_time_t(0);
447    auto tz = fixed_time_zone(absl::time_internal::cctz::seconds::zero());
448    TestFormatSpecifier(tp, tz, "%E*z", "+00:00:00");
449    TestFormatSpecifier(tp, tz, "%::z", "+00:00:00");
450    TestFormatSpecifier(tp, tz, "%:::z", "+00");
451    tz = fixed_time_zone(chrono::seconds(56));
452    TestFormatSpecifier(tp, tz, "%E*z", "+00:00:56");
453    TestFormatSpecifier(tp, tz, "%::z", "+00:00:56");
454    TestFormatSpecifier(tp, tz, "%:::z", "+00:00:56");
455    tz = fixed_time_zone(-chrono::seconds(56));
456    TestFormatSpecifier(tp, tz, "%E*z", "-00:00:56");
457    TestFormatSpecifier(tp, tz, "%::z", "-00:00:56");
458    TestFormatSpecifier(tp, tz, "%:::z", "-00:00:56");
459    tz = fixed_time_zone(chrono::minutes(34));
460    TestFormatSpecifier(tp, tz, "%E*z", "+00:34:00");
461    TestFormatSpecifier(tp, tz, "%::z", "+00:34:00");
462    TestFormatSpecifier(tp, tz, "%:::z", "+00:34");
463    tz = fixed_time_zone(-chrono::minutes(34));
464    TestFormatSpecifier(tp, tz, "%E*z", "-00:34:00");
465    TestFormatSpecifier(tp, tz, "%::z", "-00:34:00");
466    TestFormatSpecifier(tp, tz, "%:::z", "-00:34");
467    tz = fixed_time_zone(chrono::minutes(34) + chrono::seconds(56));
468    TestFormatSpecifier(tp, tz, "%E*z", "+00:34:56");
469    TestFormatSpecifier(tp, tz, "%::z", "+00:34:56");
470    TestFormatSpecifier(tp, tz, "%:::z", "+00:34:56");
471    tz = fixed_time_zone(-chrono::minutes(34) - chrono::seconds(56));
472    TestFormatSpecifier(tp, tz, "%E*z", "-00:34:56");
473    TestFormatSpecifier(tp, tz, "%::z", "-00:34:56");
474    TestFormatSpecifier(tp, tz, "%:::z", "-00:34:56");
475    tz = fixed_time_zone(chrono::hours(12));
476    TestFormatSpecifier(tp, tz, "%E*z", "+12:00:00");
477    TestFormatSpecifier(tp, tz, "%::z", "+12:00:00");
478    TestFormatSpecifier(tp, tz, "%:::z", "+12");
479    tz = fixed_time_zone(-chrono::hours(12));
480    TestFormatSpecifier(tp, tz, "%E*z", "-12:00:00");
481    TestFormatSpecifier(tp, tz, "%::z", "-12:00:00");
482    TestFormatSpecifier(tp, tz, "%:::z", "-12");
483    tz = fixed_time_zone(chrono::hours(12) + chrono::seconds(56));
484    TestFormatSpecifier(tp, tz, "%E*z", "+12:00:56");
485    TestFormatSpecifier(tp, tz, "%::z", "+12:00:56");
486    TestFormatSpecifier(tp, tz, "%:::z", "+12:00:56");
487    tz = fixed_time_zone(-chrono::hours(12) - chrono::seconds(56));
488    TestFormatSpecifier(tp, tz, "%E*z", "-12:00:56");
489    TestFormatSpecifier(tp, tz, "%::z", "-12:00:56");
490    TestFormatSpecifier(tp, tz, "%:::z", "-12:00:56");
491    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34));
492    TestFormatSpecifier(tp, tz, "%E*z", "+12:34:00");
493    TestFormatSpecifier(tp, tz, "%::z", "+12:34:00");
494    TestFormatSpecifier(tp, tz, "%:::z", "+12:34");
495    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34));
496    TestFormatSpecifier(tp, tz, "%E*z", "-12:34:00");
497    TestFormatSpecifier(tp, tz, "%::z", "-12:34:00");
498    TestFormatSpecifier(tp, tz, "%:::z", "-12:34");
499    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34) +
500                         chrono::seconds(56));
501    TestFormatSpecifier(tp, tz, "%E*z", "+12:34:56");
502    TestFormatSpecifier(tp, tz, "%::z", "+12:34:56");
503    TestFormatSpecifier(tp, tz, "%:::z", "+12:34:56");
504    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34) -
505                         chrono::seconds(56));
506    TestFormatSpecifier(tp, tz, "%E*z", "-12:34:56");
507    TestFormatSpecifier(tp, tz, "%::z", "-12:34:56");
508    TestFormatSpecifier(tp, tz, "%:::z", "-12:34:56");
509  }
510  TEST(Format, ExtendedYears) {
511    const time_zone utc = utc_time_zone();
512    const char e4y_fmt[] = "%E4Y%m%d";  
513    auto tp = convert(civil_second(-999, 11, 27, 0, 0, 0), utc);
514    EXPECT_EQ("-9991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
515    tp = convert(civil_second(-99, 11, 27, 0, 0, 0), utc);
516    EXPECT_EQ("-0991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
517    tp = convert(civil_second(-9, 11, 27, 0, 0, 0), utc);
518    EXPECT_EQ("-0091127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
519    tp = convert(civil_second(-1, 11, 27, 0, 0, 0), utc);
520    EXPECT_EQ("-0011127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
521    tp = convert(civil_second(0, 11, 27, 0, 0, 0), utc);
522    EXPECT_EQ("00001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
523    tp = convert(civil_second(1, 11, 27, 0, 0, 0), utc);
524    EXPECT_EQ("00011127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
525    tp = convert(civil_second(9, 11, 27, 0, 0, 0), utc);
526    EXPECT_EQ("00091127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
527    tp = convert(civil_second(99, 11, 27, 0, 0, 0), utc);
528    EXPECT_EQ("00991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
529    tp = convert(civil_second(999, 11, 27, 0, 0, 0), utc);
530    EXPECT_EQ("09991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
531    tp = convert(civil_second(9999, 11, 27, 0, 0, 0), utc);
532    EXPECT_EQ("99991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
533    tp = convert(civil_second(-1000, 11, 27, 0, 0, 0), utc);
534    EXPECT_EQ("-10001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
535    tp = convert(civil_second(10000, 11, 27, 0, 0, 0), utc);
536    EXPECT_EQ("100001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
537  }
538  TEST(Format, RFC3339Format) {
539    time_zone tz;
540    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
541    time_point<chrono::nanoseconds> tp =
542        convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
543    EXPECT_EQ("1977-06-28T09:08:07-07:00",
544              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
545    EXPECT_EQ("1977-06-28T09:08:07-07:00",
546              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
547    tp += chrono::milliseconds(100);
548    EXPECT_EQ("1977-06-28T09:08:07.1-07:00",
549              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
550    EXPECT_EQ("1977-06-28T09:08:07-07:00",
551              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
552    tp += chrono::milliseconds(20);
553    EXPECT_EQ("1977-06-28T09:08:07.12-07:00",
554              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
555    EXPECT_EQ("1977-06-28T09:08:07-07:00",
556              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
557    tp += chrono::milliseconds(3);
558    EXPECT_EQ("1977-06-28T09:08:07.123-07:00",
559              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
560    EXPECT_EQ("1977-06-28T09:08:07-07:00",
561              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
562    tp += chrono::microseconds(400);
563    EXPECT_EQ("1977-06-28T09:08:07.1234-07:00",
564              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
565    EXPECT_EQ("1977-06-28T09:08:07-07:00",
566              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
567    tp += chrono::microseconds(50);
568    EXPECT_EQ("1977-06-28T09:08:07.12345-07:00",
569              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
570    EXPECT_EQ("1977-06-28T09:08:07-07:00",
571              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
572    tp += chrono::microseconds(6);
573    EXPECT_EQ("1977-06-28T09:08:07.123456-07:00",
574              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
575    EXPECT_EQ("1977-06-28T09:08:07-07:00",
576              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
577    tp += chrono::nanoseconds(700);
578    EXPECT_EQ("1977-06-28T09:08:07.1234567-07:00",
579              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
580    EXPECT_EQ("1977-06-28T09:08:07-07:00",
581              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
582    tp += chrono::nanoseconds(80);
583    EXPECT_EQ("1977-06-28T09:08:07.12345678-07:00",
584              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
585    EXPECT_EQ("1977-06-28T09:08:07-07:00",
586              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
587    tp += chrono::nanoseconds(9);
588    EXPECT_EQ("1977-06-28T09:08:07.123456789-07:00",
589              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
590    EXPECT_EQ("1977-06-28T09:08:07-07:00",
591              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
592  }
593  TEST(Format, RFC1123Format) {  
594    time_zone tz;
595    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
596    auto tp = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
597    EXPECT_EQ("Tue, 28 Jun 1977 09:08:07 -0700",
598              absl::time_internal::cctz::format(RFC1123_full, tp, tz));
599    EXPECT_EQ("28 Jun 1977 09:08:07 -0700",
600              absl::time_internal::cctz::format(RFC1123_no_wday, tp, tz));
601  }
602  TEST(Format, Week) {
603    const time_zone utc = utc_time_zone();
604    auto tp = convert(civil_second(2017, 1, 1, 0, 0, 0), utc);
605    EXPECT_EQ("2017-01-7",
606              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
607    EXPECT_EQ("2017-00-0",
608              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
609    tp = convert(civil_second(2017, 12, 31, 0, 0, 0), utc);
610    EXPECT_EQ("2017-53-7",
611              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
612    EXPECT_EQ("2017-52-0",
613              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
614    tp = convert(civil_second(2018, 1, 1, 0, 0, 0), utc);
615    EXPECT_EQ("2018-00-1",
616              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
617    EXPECT_EQ("2018-01-1",
618              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
619    tp = convert(civil_second(2018, 12, 31, 0, 0, 0), utc);
620    EXPECT_EQ("2018-52-1",
621              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
622    EXPECT_EQ("2018-53-1",
623              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
624    tp = convert(civil_second(2019, 1, 1, 0, 0, 0), utc);
625    EXPECT_EQ("2019-00-2",
626              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
627    EXPECT_EQ("2019-00-2",
628              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
629    tp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
630    EXPECT_EQ("2019-52-2",
631              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
632    EXPECT_EQ("2019-52-2",
633              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
634  }
635  TEST(Parse, TimePointResolution) {
636    const char kFmt[] = "%H:%M:%E*S";
637    const time_zone utc = utc_time_zone();
638    time_point<chrono::nanoseconds> tp_ns;
639    EXPECT_TRUE(parse(kFmt, "03:04:05.123456789", utc, &tp_ns));
640    EXPECT_EQ("03:04:05.123456789",
641              absl::time_internal::cctz::format(kFmt, tp_ns, utc));
642    EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_ns));
643    EXPECT_EQ("03:04:05.123456",
644              absl::time_internal::cctz::format(kFmt, tp_ns, utc));
645    time_point<chrono::microseconds> tp_us;
646    EXPECT_TRUE(parse(kFmt, "03:04:05.123456789", utc, &tp_us));
647    EXPECT_EQ("03:04:05.123456",
648              absl::time_internal::cctz::format(kFmt, tp_us, utc));
649    EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_us));
650    EXPECT_EQ("03:04:05.123456",
651              absl::time_internal::cctz::format(kFmt, tp_us, utc));
652    EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_us));
653    EXPECT_EQ("03:04:05.123",
654              absl::time_internal::cctz::format(kFmt, tp_us, utc));
655    time_point<chrono::milliseconds> tp_ms;
656    EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_ms));
657    EXPECT_EQ("03:04:05.123",
658              absl::time_internal::cctz::format(kFmt, tp_ms, utc));
659    EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_ms));
660    EXPECT_EQ("03:04:05.123",
661              absl::time_internal::cctz::format(kFmt, tp_ms, utc));
662    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_ms));
663    EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_ms, utc));
664    time_point<chrono::seconds> tp_s;
665    EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_s));
666    EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_s, utc));
667    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_s));
668    EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_s, utc));
669    time_point<chrono::minutes> tp_m;
670    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_m));
671    EXPECT_EQ("03:04:00", absl::time_internal::cctz::format(kFmt, tp_m, utc));
672    time_point<chrono::hours> tp_h;
673    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_h));
674    EXPECT_EQ("03:00:00", absl::time_internal::cctz::format(kFmt, tp_h, utc));
675  }
676  TEST(Parse, TimePointExtendedResolution) {
677    const char kFmt[] = "%H:%M:%E*S";
678    const time_zone utc = utc_time_zone();
679    time_point<absl::time_internal::cctz::seconds> tp;
680    detail::femtoseconds fs;
681    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.123456789012345", utc, &tp, &fs));
682    EXPECT_EQ("12:34:56.123456789012345", detail::format(kFmt, tp, fs, utc));
683    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.012345678901234", utc, &tp, &fs));
684    EXPECT_EQ("12:34:56.012345678901234", detail::format(kFmt, tp, fs, utc));
685    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.001234567890123", utc, &tp, &fs));
686    EXPECT_EQ("12:34:56.001234567890123", detail::format(kFmt, tp, fs, utc));
687    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000123", utc, &tp, &fs));
688    EXPECT_EQ("12:34:56.000000000000123", detail::format(kFmt, tp, fs, utc));
689    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000012", utc, &tp, &fs));
690    EXPECT_EQ("12:34:56.000000000000012", detail::format(kFmt, tp, fs, utc));
691    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000001", utc, &tp, &fs));
692    EXPECT_EQ("12:34:56.000000000000001", detail::format(kFmt, tp, fs, utc));
693  }
694  TEST(Parse, Basics) {
695    time_zone tz = utc_time_zone();
696    time_point<chrono::nanoseconds> tp =
697        chrono::system_clock::from_time_t(1234567890);
698    EXPECT_TRUE(parse("", "", tz, &tp));
699    EXPECT_EQ(chrono::system_clock::from_time_t(0), tp);  
700    EXPECT_TRUE(parse(" ", " ", tz, &tp));
701    EXPECT_TRUE(parse("  ", "  ", tz, &tp));
702    EXPECT_TRUE(parse("x", "x", tz, &tp));
703    EXPECT_TRUE(parse("xxx", "xxx", tz, &tp));
704    EXPECT_TRUE(
705        parse("%Y-%m-%d %H:%M:%S %z", "2013-06-28 19:08:09 -0800", tz, &tp));
706    ExpectTime(tp, tz, 2013, 6, 29, 3, 8, 9, 0, false, "UTC");
707  }
708  TEST(Parse, WithTimeZone) {
709    time_zone tz;
710    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
711    time_point<chrono::nanoseconds> tp;
712    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2013-06-28 19:08:09", tz, &tp));
713    ExpectTime(tp, tz, 2013, 6, 28, 19, 8, 9, -7 * 60 * 60, true, "PDT");
714    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S %z", "2013-06-28 19:08:09 +0800",
715                      utc_time_zone(), &tp));
716    ExpectTime(tp, tz, 2013, 6, 28, 19 - 8 - 7, 8, 9, -7 * 60 * 60, true, "PDT");
717    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2011-03-13 02:15:00", tz, &tp));
718    ExpectTime(tp, tz, 2011, 3, 13, 3, 15, 0, -7 * 60 * 60, true, "PDT");
719    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2011-11-06 01:15:00", tz, &tp));
720    ExpectTime(tp, tz, 2011, 11, 6, 1, 15, 0, -7 * 60 * 60, true, "PDT");
721  }
722  TEST(Parse, LeapSecond) {
723    time_zone tz;
724    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
725    time_point<chrono::nanoseconds> tp;
726    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:59-08:00", tz, &tp));
727    ExpectTime(tp, tz, 2013, 6, 28, 8, 8, 59, -7 * 60 * 60, true, "PDT");
728    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:59.5-08:00", tz, &tp));
729    ExpectTime(tp, tz, 2013, 6, 28, 8, 8, 59, -7 * 60 * 60, true, "PDT");
730    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:60-08:00", tz, &tp));
731    ExpectTime(tp, tz, 2013, 6, 28, 8, 9, 0, -7 * 60 * 60, true, "PDT");
732    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:60.5-08:00", tz, &tp));
733    ExpectTime(tp, tz, 2013, 6, 28, 8, 9, 0, -7 * 60 * 60, true, "PDT");
734    EXPECT_FALSE(parse(RFC3339_full, "2013-06-28T07:08:61-08:00", tz, &tp));
735  }
736  TEST(Parse, ErrorCases) {
737    const time_zone tz = utc_time_zone();
738    auto tp = chrono::system_clock::from_time_t(0);
739    EXPECT_FALSE(parse("%S", "123", tz, &tp));
740    EXPECT_FALSE(parse("%Q", "x", tz, &tp));
741    EXPECT_FALSE(parse("%m-%d", "2-3 blah", tz, &tp));
742    EXPECT_TRUE(parse("%m-%d", "2-3  ", tz, &tp));
743    EXPECT_EQ(2, convert(tp, utc_time_zone()).month());
744    EXPECT_EQ(3, convert(tp, utc_time_zone()).day());
745    EXPECT_FALSE(parse("%m-%d", "2-31", tz, &tp));
746    EXPECT_TRUE(parse("%z", "-0203", tz, &tp));
747    EXPECT_FALSE(parse("%z", "- 2 3", tz, &tp));
748    EXPECT_TRUE(parse("%Ez", "-02:03", tz, &tp));
749    EXPECT_FALSE(parse("%Ez", "- 2: 3", tz, &tp));
750    EXPECT_FALSE(parse("%Ez", "+-08:00", tz, &tp));
751    EXPECT_FALSE(parse("%Ez", "-+08:00", tz, &tp));
752    EXPECT_FALSE(parse("%Y", "-0", tz, &tp));
753    EXPECT_FALSE(parse("%E4Y", "-0", tz, &tp));
754    EXPECT_FALSE(parse("%H", "-0", tz, &tp));
755    EXPECT_FALSE(parse("%M", "-0", tz, &tp));
756    EXPECT_FALSE(parse("%S", "-0", tz, &tp));
757    EXPECT_FALSE(parse("%z", "+-000", tz, &tp));
758    EXPECT_FALSE(parse("%Ez", "+-0:00", tz, &tp));
759    EXPECT_FALSE(parse("%z", "-00-0", tz, &tp));
760    EXPECT_FALSE(parse("%Ez", "-00:-0", tz, &tp));
761  }
762  TEST(Parse, PosixConversions) {
763    time_zone tz = utc_time_zone();
764    auto tp = chrono::system_clock::from_time_t(0);
765    const auto reset = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
766    tp = reset;
767    EXPECT_TRUE(parse("%d", "15", tz, &tp));
768    EXPECT_EQ(15, convert(tp, tz).day());
769    tp = reset;
770    EXPECT_TRUE(parse("%e", "15", tz, &tp));
771    EXPECT_EQ(15, convert(tp, tz).day());  
772    tp = reset;
773    EXPECT_TRUE(parse("%H", "17", tz, &tp));
774    EXPECT_EQ(17, convert(tp, tz).hour());
775    tp = reset;
776    EXPECT_TRUE(parse("%I", "5", tz, &tp));
777    EXPECT_EQ(5, convert(tp, tz).hour());
778    EXPECT_TRUE(parse("%j", "32", tz, &tp));
779    tp = reset;
780    EXPECT_TRUE(parse("%m", "11", tz, &tp));
781    EXPECT_EQ(11, convert(tp, tz).month());
782    tp = reset;
783    EXPECT_TRUE(parse("%M", "33", tz, &tp));
784    EXPECT_EQ(33, convert(tp, tz).minute());
785    tp = reset;
786    EXPECT_TRUE(parse("%S", "55", tz, &tp));
787    EXPECT_EQ(55, convert(tp, tz).second());
788    EXPECT_TRUE(parse("%U", "15", tz, &tp));
789    EXPECT_TRUE(parse("%w", "2", tz, &tp));
790    EXPECT_TRUE(parse("%W", "22", tz, &tp));
791    tp = reset;
792    EXPECT_TRUE(parse("%y", "04", tz, &tp));
793    EXPECT_EQ(2004, convert(tp, tz).year());
794    tp = reset;
795    EXPECT_TRUE(parse("%Y", "2004", tz, &tp));
796    EXPECT_EQ(2004, convert(tp, tz).year());
797    EXPECT_TRUE(parse("%%", "%", tz, &tp));
798  #if defined(__linux__)
799  #if 0
800    tp = reset;
801    EXPECT_TRUE(parse("%C %y", "20 04", tz, &tp));
802    EXPECT_EQ(2004, convert(tp, tz).year());
803  #endif
804    tp = reset;
805    EXPECT_TRUE(parse("%D", "02/03/04", tz, &tp));
806    EXPECT_EQ(2, convert(tp, tz).month());
807    EXPECT_EQ(3, convert(tp, tz).day());
808    EXPECT_EQ(2004, convert(tp, tz).year());
809    EXPECT_TRUE(parse("%n", "\n", tz, &tp));
810    tp = reset;
811    EXPECT_TRUE(parse("%R", "03:44", tz, &tp));
812    EXPECT_EQ(3, convert(tp, tz).hour());
813    EXPECT_EQ(44, convert(tp, tz).minute());
814    EXPECT_TRUE(parse("%t", "\t\v\f\n\r ", tz, &tp));
815    tp = reset;
816    EXPECT_TRUE(parse("%T", "03:44:55", tz, &tp));
817    EXPECT_EQ(3, convert(tp, tz).hour());
818    EXPECT_EQ(44, convert(tp, tz).minute());
819    EXPECT_EQ(55, convert(tp, tz).second());
820    tp = reset;
821    EXPECT_TRUE(parse("%s", "1234567890", tz, &tp));
822    EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);
823    time_zone lax;
824    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &lax));
825    tp = reset;
826    EXPECT_TRUE(parse("%s", "1234567890", lax, &tp));
827    EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);
828    tp = reset;
829    EXPECT_TRUE(parse("%s", "1414917000", lax, &tp));
830    EXPECT_EQ(chrono::system_clock::from_time_t(1414917000), tp);
831    tp = reset;
832    EXPECT_TRUE(parse("%s", "1414920600", lax, &tp));
833    EXPECT_EQ(chrono::system_clock::from_time_t(1414920600), tp);
834  #endif
835  }
836  TEST(Parse, LocaleSpecific) {
837    time_zone tz = utc_time_zone();
838    auto tp = chrono::system_clock::from_time_t(0);
839    const auto reset = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
840    EXPECT_TRUE(parse("%a", "Mon", tz, &tp));
841    EXPECT_TRUE(parse("%A", "Monday", tz, &tp));
842    tp = reset;
843    EXPECT_TRUE(parse("%b", "Feb", tz, &tp));
844    EXPECT_EQ(2, convert(tp, tz).month());
845    tp = reset;
846    EXPECT_TRUE(parse("%B", "February", tz, &tp));
847    EXPECT_EQ(2, convert(tp, tz).month());
848    EXPECT_TRUE(parse("%p", "AM", tz, &tp));
849    tp = reset;
850    EXPECT_TRUE(parse("%I %p", "5 PM", tz, &tp));
851    EXPECT_EQ(17, convert(tp, tz).hour());
852    tp = reset;
853    EXPECT_TRUE(parse("%x", "02/03/04", tz, &tp));
854    if (convert(tp, tz).month() == 2) {
855      EXPECT_EQ(3, convert(tp, tz).day());
856    } else {
857      EXPECT_EQ(2, convert(tp, tz).day());
858      EXPECT_EQ(3, convert(tp, tz).month());
859    }
860    EXPECT_EQ(2004, convert(tp, tz).year());
861    tp = reset;
862    EXPECT_TRUE(parse("%X", "15:44:55", tz, &tp));
863    EXPECT_EQ(15, convert(tp, tz).hour());
864    EXPECT_EQ(44, convert(tp, tz).minute());
865    EXPECT_EQ(55, convert(tp, tz).second());
866  #if defined(__linux__)
867    tp = reset;
868    EXPECT_TRUE(parse("%h", "Feb", tz, &tp));
869    EXPECT_EQ(2, convert(tp, tz).month());  
870  #if defined(__GLIBC__)
871    tp = reset;
872    EXPECT_TRUE(parse("%l %p", "5 PM", tz, &tp));
873    EXPECT_EQ(17, convert(tp, tz).hour());
874  #endif
875    tp = reset;
876    EXPECT_TRUE(parse("%r", "03:44:55 PM", tz, &tp));
877    EXPECT_EQ(15, convert(tp, tz).hour());
878    EXPECT_EQ(44, convert(tp, tz).minute());
879    EXPECT_EQ(55, convert(tp, tz).second());
880  #if defined(__GLIBC__)
881    tp = reset;
882    EXPECT_TRUE(parse("%Ec", "Tue Nov 19 05:06:07 2013", tz, &tp));
883    EXPECT_EQ(convert(civil_second(2013, 11, 19, 5, 6, 7), tz), tp);
884    tp = reset;
885    EXPECT_TRUE(parse("%Ex", "02/03/04", tz, &tp));
886    EXPECT_EQ(2, convert(tp, tz).month());
887    EXPECT_EQ(3, convert(tp, tz).day());
888    EXPECT_EQ(2004, convert(tp, tz).year());
889    tp = reset;
890    EXPECT_TRUE(parse("%EX", "15:44:55", tz, &tp));
891    EXPECT_EQ(15, convert(tp, tz).hour());
892    EXPECT_EQ(44, convert(tp, tz).minute());
893    EXPECT_EQ(55, convert(tp, tz).second());
894    tp = reset;
895    EXPECT_TRUE(parse("%EY", "2004", tz, &tp));
896    EXPECT_EQ(2004, convert(tp, tz).year());
897    tp = reset;
898    EXPECT_TRUE(parse("%Od", "15", tz, &tp));
899    EXPECT_EQ(15, convert(tp, tz).day());
900    tp = reset;
901    EXPECT_TRUE(parse("%Oe", "15", tz, &tp));
902    EXPECT_EQ(15, convert(tp, tz).day());  
903    tp = reset;
904    EXPECT_TRUE(parse("%OH", "17", tz, &tp));
905    EXPECT_EQ(17, convert(tp, tz).hour());
906    tp = reset;
907    EXPECT_TRUE(parse("%OI", "5", tz, &tp));
908    EXPECT_EQ(5, convert(tp, tz).hour());
909    tp = reset;
910    EXPECT_TRUE(parse("%Om", "11", tz, &tp));
911    EXPECT_EQ(11, convert(tp, tz).month());
912    tp = reset;
913    EXPECT_TRUE(parse("%OM", "33", tz, &tp));
914    EXPECT_EQ(33, convert(tp, tz).minute());
915    tp = reset;
916    EXPECT_TRUE(parse("%OS", "55", tz, &tp));
917    EXPECT_EQ(55, convert(tp, tz).second());
918    EXPECT_TRUE(parse("%OU", "15", tz, &tp));
919    EXPECT_TRUE(parse("%Ow", "2", tz, &tp));
920    EXPECT_TRUE(parse("%OW", "22", tz, &tp));
921    tp = reset;
922    EXPECT_TRUE(parse("%Oy", "04", tz, &tp));
923    EXPECT_EQ(2004, convert(tp, tz).year());
924  #endif
925  #endif
926  }
927  TEST(Parse, ExtendedSeconds) {
928    const time_zone tz = utc_time_zone();
929    const time_point<chrono::nanoseconds> unix_epoch =
930        chrono::system_clock::from_time_t(0);
931    auto precisions = {"*", "0", "1",  "2",  "3",  "4",  "5",  "6", "7",
932                       "8", "9", "10", "11", "12", "13", "14", "15"};
933    for (const std::string prec : precisions) {
934      const std::string fmt = "%E" + prec + "S";
935      SCOPED_TRACE(fmt);
936      time_point<chrono::nanoseconds> tp = unix_epoch;
937      EXPECT_TRUE(parse(fmt, "5", tz, &tp));
938      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
939      tp = unix_epoch;
940      EXPECT_TRUE(parse(fmt, "05", tz, &tp));
941      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
942      tp = unix_epoch;
943      EXPECT_TRUE(parse(fmt, "05.0", tz, &tp));
944      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
945      tp = unix_epoch;
946      EXPECT_TRUE(parse(fmt, "05.00", tz, &tp));
947      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
948      tp = unix_epoch;
949      EXPECT_TRUE(parse(fmt, "05.6", tz, &tp));
950      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
951      tp = unix_epoch;
952      EXPECT_TRUE(parse(fmt, "05.60", tz, &tp));
953      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
954      tp = unix_epoch;
955      EXPECT_TRUE(parse(fmt, "05.600", tz, &tp));
956      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
957      tp = unix_epoch;
958      EXPECT_TRUE(parse(fmt, "05.67", tz, &tp));
959      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(670), tp);
960      tp = unix_epoch;
961      EXPECT_TRUE(parse(fmt, "05.670", tz, &tp));
962      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(670), tp);
963      tp = unix_epoch;
964      EXPECT_TRUE(parse(fmt, "05.678", tz, &tp));
965      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(678), tp);
966    }
967    time_point<chrono::nanoseconds> tp = unix_epoch;
968    EXPECT_TRUE(parse("%E*S", "0.2147483647", tz, &tp));
969    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
970    tp = unix_epoch;
971    EXPECT_TRUE(parse("%E*S", "0.2147483648", tz, &tp));
972    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
973    tp = unix_epoch;
974    EXPECT_TRUE(parse(
975        "%E*S", "0.214748364801234567890123456789012345678901234567890123456789",
976        tz, &tp));
977    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
978  }
979  TEST(Parse, ExtendedSecondsScan) {
980    const time_zone tz = utc_time_zone();
981    time_point<chrono::nanoseconds> tp;
982    for (int ms = 0; ms < 1000; ms += 111) {
983      for (int us = 0; us < 1000; us += 27) {
984        const int micros = ms * 1000 + us;
985        for (int ns = 0; ns < 1000; ns += 9) {
986          const auto expected = chrono::system_clock::from_time_t(0) +
987                                chrono::nanoseconds(micros * 1000 + ns);
988          std::ostringstream oss;
989          oss << "0." << std::setfill('0') << std::setw(3);
990          oss << ms << std::setw(3) << us << std::setw(3) << ns;
991          const std::string input = oss.str();
992          EXPECT_TRUE(parse("%E*S", input, tz, &tp));
993          EXPECT_EQ(expected, tp) << input;
994        }
995      }
996    }
997  }
998  TEST(Parse, ExtendedSubeconds) {
999    const time_zone tz = utc_time_zone();
1000    const time_point<chrono::nanoseconds> unix_epoch =
1001        chrono::system_clock::from_time_t(0);
1002    auto precisions = {"*", "0", "1",  "2",  "3",  "4",  "5",  "6", "7",
1003                       "8", "9", "10", "11", "12", "13", "14", "15"};
1004    for (const std::string prec : precisions) {
1005      const std::string fmt = "%E" + prec + "f";
1006      SCOPED_TRACE(fmt);
1007      time_point<chrono::nanoseconds> tp = unix_epoch - chrono::seconds(1);
1008      EXPECT_TRUE(parse(fmt, "", tz, &tp));
1009      EXPECT_EQ(unix_epoch, tp);
1010      tp = unix_epoch;
1011      EXPECT_TRUE(parse(fmt, "6", tz, &tp));
1012      EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
1013      tp = unix_epoch;
1014      EXPECT_TRUE(parse(fmt, "60", tz, &tp));
1015      EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
1016      tp = unix_epoch;
1017      EXPECT_TRUE(parse(fmt, "600", tz, &tp));
1018      EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
1019      tp = unix_epoch;
1020      EXPECT_TRUE(parse(fmt, "67", tz, &tp));
1021      EXPECT_EQ(unix_epoch + chrono::milliseconds(670), tp);
1022      tp = unix_epoch;
1023      EXPECT_TRUE(parse(fmt, "670", tz, &tp));
1024      EXPECT_EQ(unix_epoch + chrono::milliseconds(670), tp);
1025      tp = unix_epoch;
1026      EXPECT_TRUE(parse(fmt, "678", tz, &tp));
1027      EXPECT_EQ(unix_epoch + chrono::milliseconds(678), tp);
1028      tp = unix_epoch;
1029      EXPECT_TRUE(parse(fmt, "6789", tz, &tp));
1030      EXPECT_EQ(
1031          unix_epoch + chrono::milliseconds(678) + chrono::microseconds(900), tp);
1032    }
1033    time_point<chrono::nanoseconds> tp = unix_epoch;
1034    EXPECT_TRUE(parse("%E*f", "2147483647", tz, &tp));
1035    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
1036    tp = unix_epoch;
1037    EXPECT_TRUE(parse("%E*f", "2147483648", tz, &tp));
1038    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
1039    tp = unix_epoch;
1040    EXPECT_TRUE(parse(
1041        "%E*f", "214748364801234567890123456789012345678901234567890123456789",
1042        tz, &tp));
1043    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
1044  }
1045  TEST(Parse, ExtendedSubecondsScan) {
1046    time_point<chrono::nanoseconds> tp;
1047    const time_zone tz = utc_time_zone();
1048    for (int ms = 0; ms < 1000; ms += 111) {
1049      for (int us = 0; us < 1000; us += 27) {
1050        const int micros = ms * 1000 + us;
1051        for (int ns = 0; ns < 1000; ns += 9) {
1052          std::ostringstream oss;
1053          oss << std::setfill('0') << std::setw(3) << ms;
1054          oss << std::setw(3) << us << std::setw(3) << ns;
1055          const std::string nanos = oss.str();
1056          const auto expected = chrono::system_clock::from_time_t(0) +
1057                                chrono::nanoseconds(micros * 1000 + ns);
1058          for (int ps = 0; ps < 1000; ps += 250) {
1059            std::ostringstream ps_oss;
1060            oss << std::setfill('0') << std::setw(3) << ps;
1061            const std::string input = nanos + ps_oss.str() + "999";
1062            EXPECT_TRUE(parse("%E*f", input, tz, &tp));
1063            EXPECT_EQ(expected + chrono::nanoseconds(ps) / 1000, tp) << input;
1064          }
1065        }
1066      }
1067    }
1068  }
1069  TEST(Parse, ExtendedOffset) {
1070    const time_zone utc = utc_time_zone();
1071    time_point<absl::time_internal::cctz::seconds> tp;
1072    EXPECT_TRUE(parse("%Ez", "+00:00", utc, &tp));
1073    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1074    EXPECT_TRUE(parse("%Ez", "-12:34", utc, &tp));
1075    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1076    EXPECT_TRUE(parse("%Ez", "+12:34", utc, &tp));
1077    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1078    EXPECT_FALSE(parse("%Ez", "-12:3", utc, &tp));
1079    for (auto fmt : {"%Ez", "%z"}) {
1080      EXPECT_TRUE(parse(fmt, "+0000", utc, &tp));
1081      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1082      EXPECT_TRUE(parse(fmt, "-1234", utc, &tp));
1083      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1084      EXPECT_TRUE(parse(fmt, "+1234", utc, &tp));
1085      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1086      EXPECT_FALSE(parse(fmt, "-123", utc, &tp));
1087      EXPECT_TRUE(parse(fmt, "+00", utc, &tp));
1088      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1089      EXPECT_TRUE(parse(fmt, "-12", utc, &tp));
1090      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 0, 0), utc), tp);
1091      EXPECT_TRUE(parse(fmt, "+12", utc, &tp));
1092      EXPECT_EQ(convert(civil_second(1969, 12, 31, 12, 0, 0), utc), tp);
1093      EXPECT_FALSE(parse(fmt, "-1", utc, &tp));
1094    }
1095  }
1096  TEST(Parse, ExtendedSecondOffset) {
1097    const time_zone utc = utc_time_zone();
1098    time_point<absl::time_internal::cctz::seconds> tp;
1099    for (auto fmt : {"%Ez", "%E*z", "%:z", "%::z", "%:::z"}) {
1100      EXPECT_TRUE(parse(fmt, "+00:00:00", utc, &tp));
1101      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1102      EXPECT_TRUE(parse(fmt, "-12:34:56", utc, &tp));
1103      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 56), utc), tp);
1104      EXPECT_TRUE(parse(fmt, "+12:34:56", utc, &tp));
1105      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 25, 4), utc), tp);
1106      EXPECT_FALSE(parse(fmt, "-12:34:5", utc, &tp));
1107      EXPECT_TRUE(parse(fmt, "+000000", utc, &tp));
1108      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1109      EXPECT_TRUE(parse(fmt, "-123456", utc, &tp));
1110      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 56), utc), tp);
1111      EXPECT_TRUE(parse(fmt, "+123456", utc, &tp));
1112      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 25, 4), utc), tp);
1113      EXPECT_FALSE(parse(fmt, "-12345", utc, &tp));
1114      EXPECT_TRUE(parse(fmt, "+00:00", utc, &tp));
1115      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1116      EXPECT_TRUE(parse(fmt, "-12:34", utc, &tp));
1117      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1118      EXPECT_TRUE(parse(fmt, "+12:34", utc, &tp));
1119      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1120      EXPECT_FALSE(parse(fmt, "-12:3", utc, &tp));
1121      EXPECT_TRUE(parse(fmt, "+0000", utc, &tp));
1122      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1123      EXPECT_TRUE(parse(fmt, "-1234", utc, &tp));
1124      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1125      EXPECT_TRUE(parse(fmt, "+1234", utc, &tp));
1126      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1127      EXPECT_FALSE(parse(fmt, "-123", utc, &tp));
1128      EXPECT_TRUE(parse(fmt, "+00", utc, &tp));
1129      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1130      EXPECT_TRUE(parse(fmt, "-12", utc, &tp));
1131      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 0, 0), utc), tp);
1132      EXPECT_TRUE(parse(fmt, "+12", utc, &tp));
1133      EXPECT_EQ(convert(civil_second(1969, 12, 31, 12, 0, 0), utc), tp);
1134      EXPECT_FALSE(parse(fmt, "-1", utc, &tp));
1135    }
1136  }
1137  TEST(Parse, ExtendedYears) {
1138    const time_zone utc = utc_time_zone();
1139    const char e4y_fmt[] = "%E4Y%m%d";  
1140    time_point<absl::time_internal::cctz::seconds> tp;
1141    EXPECT_TRUE(parse(e4y_fmt, "-9991127", utc, &tp));
1142    EXPECT_EQ(convert(civil_second(-999, 11, 27, 0, 0, 0), utc), tp);
1143    EXPECT_TRUE(parse(e4y_fmt, "-0991127", utc, &tp));
1144    EXPECT_EQ(convert(civil_second(-99, 11, 27, 0, 0, 0), utc), tp);
1145    EXPECT_TRUE(parse(e4y_fmt, "-0091127", utc, &tp));
1146    EXPECT_EQ(convert(civil_second(-9, 11, 27, 0, 0, 0), utc), tp);
1147    EXPECT_TRUE(parse(e4y_fmt, "-0011127", utc, &tp));
1148    EXPECT_EQ(convert(civil_second(-1, 11, 27, 0, 0, 0), utc), tp);
1149    EXPECT_TRUE(parse(e4y_fmt, "00001127", utc, &tp));
1150    EXPECT_EQ(convert(civil_second(0, 11, 27, 0, 0, 0), utc), tp);
1151    EXPECT_TRUE(parse(e4y_fmt, "00011127", utc, &tp));
1152    EXPECT_EQ(convert(civil_second(1, 11, 27, 0, 0, 0), utc), tp);
1153    EXPECT_TRUE(parse(e4y_fmt, "00091127", utc, &tp));
1154    EXPECT_EQ(convert(civil_second(9, 11, 27, 0, 0, 0), utc), tp);
1155    EXPECT_TRUE(parse(e4y_fmt, "00991127", utc, &tp));
1156    EXPECT_EQ(convert(civil_second(99, 11, 27, 0, 0, 0), utc), tp);
1157    EXPECT_TRUE(parse(e4y_fmt, "09991127", utc, &tp));
1158    EXPECT_EQ(convert(civil_second(999, 11, 27, 0, 0, 0), utc), tp);
1159    EXPECT_TRUE(parse(e4y_fmt, "99991127", utc, &tp));
1160    EXPECT_EQ(convert(civil_second(9999, 11, 27, 0, 0, 0), utc), tp);
1161    EXPECT_FALSE(parse(e4y_fmt, "-10001127", utc, &tp));
1162    EXPECT_FALSE(parse(e4y_fmt, "100001127", utc, &tp));
1163  }
1164  TEST(Parse, RFC3339Format) {
1165    const time_zone tz = utc_time_zone();
1166    time_point<chrono::nanoseconds> tp;
1167    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00+00:00", tz, &tp));
1168    ExpectTime(tp, tz, 2014, 2, 12, 20, 21, 0, 0, false, "UTC");
1169    time_point<chrono::nanoseconds> tp2;
1170    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12t20:21:00+00:00", tz, &tp2));
1171    EXPECT_EQ(tp, tp2);
1172    time_point<chrono::nanoseconds> tp3;
1173    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00Z", tz, &tp3));
1174    EXPECT_EQ(tp, tp3);
1175    time_point<chrono::nanoseconds> tp4;
1176    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00z", tz, &tp4));
1177    EXPECT_EQ(tp, tp4);
1178  }
1179  TEST(Parse, Week) {
1180    const time_zone utc = utc_time_zone();
1181    time_point<absl::time_internal::cctz::seconds> tp;
1182    auto exp = convert(civil_second(2017, 1, 1, 0, 0, 0), utc);
1183    EXPECT_TRUE(parse("%Y-%U-%u", "2017-01-7", utc, &tp));
1184    EXPECT_EQ(exp, tp);
1185    EXPECT_TRUE(parse("%Y-%W-%w", "2017-00-0", utc, &tp));
1186    EXPECT_EQ(exp, tp);
1187    exp = convert(civil_second(2017, 12, 31, 0, 0, 0), utc);
1188    EXPECT_TRUE(parse("%Y-%U-%u", "2017-53-7", utc, &tp));
1189    EXPECT_EQ(exp, tp);
1190    EXPECT_TRUE(parse("%Y-%W-%w", "2017-52-0", utc, &tp));
1191    EXPECT_EQ(exp, tp);
1192    exp = convert(civil_second(2018, 1, 1, 0, 0, 0), utc);
1193    EXPECT_TRUE(parse("%Y-%U-%u", "2018-00-1", utc, &tp));
1194    EXPECT_EQ(exp, tp);
1195    EXPECT_TRUE(parse("%Y-%W-%w", "2018-01-1", utc, &tp));
1196    EXPECT_EQ(exp, tp);
1197    exp = convert(civil_second(2018, 12, 31, 0, 0, 0), utc);
1198    EXPECT_TRUE(parse("%Y-%U-%u", "2018-52-1", utc, &tp));
1199    EXPECT_EQ(exp, tp);
1200    EXPECT_TRUE(parse("%Y-%W-%w", "2018-53-1", utc, &tp));
1201    EXPECT_EQ(exp, tp);
1202    exp = convert(civil_second(2019, 1, 1, 0, 0, 0), utc);
1203    EXPECT_TRUE(parse("%Y-%U-%u", "2019-00-2", utc, &tp));
1204    EXPECT_EQ(exp, tp);
1205    EXPECT_TRUE(parse("%Y-%W-%w", "2019-00-2", utc, &tp));
1206    EXPECT_EQ(exp, tp);
1207    exp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
1208    EXPECT_TRUE(parse("%Y-%U-%u", "2019-52-2", utc, &tp));
1209    EXPECT_EQ(exp, tp);
1210    EXPECT_TRUE(parse("%Y-%W-%w", "2019-52-2", utc, &tp));
1211    EXPECT_EQ(exp, tp);
1212  }
1213  TEST(Parse, WeekYearShift) {
1214    const time_zone utc = utc_time_zone();
1215    time_point<absl::time_internal::cctz::seconds> tp;
1216    auto exp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
1217    EXPECT_TRUE(parse("%Y-%U-%u", "2020-00-2", utc, &tp));
1218    EXPECT_EQ(exp, tp);
1219    EXPECT_TRUE(parse("%Y-%W-%w", "2020-00-2", utc, &tp));
1220    EXPECT_EQ(exp, tp);
1221    exp = convert(civil_second(2021, 1, 1, 0, 0, 0), utc);
1222    EXPECT_TRUE(parse("%Y-%U-%u", "2020-52-5", utc, &tp));
1223    EXPECT_EQ(exp, tp);
1224    EXPECT_TRUE(parse("%Y-%W-%w", "2020-52-5", utc, &tp));
1225    EXPECT_EQ(exp, tp);
1226    EXPECT_FALSE(parse("%Y-%U-%u", "-9223372036854775808-0-7", utc, &tp));
1227    EXPECT_FALSE(parse("%Y-%U-%u", "9223372036854775807-53-7", utc, &tp));
1228  }
1229  TEST(Parse, MaxRange) {
1230    const time_zone utc = utc_time_zone();
1231    time_point<absl::time_internal::cctz::seconds> tp;
1232    EXPECT_TRUE(
1233        parse(RFC3339_sec, "292277026596-12-04T15:30:07+00:00", utc, &tp));
1234    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::max());
1235    EXPECT_FALSE(
1236        parse(RFC3339_sec, "292277026596-12-04T15:30:08+00:00", utc, &tp));
1237    EXPECT_TRUE(
1238        parse(RFC3339_sec, "292277026596-12-04T14:30:07-01:00", utc, &tp));
1239    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::max());
1240    EXPECT_FALSE(
1241        parse(RFC3339_sec, "292277026596-12-04T14:30:08-01:00", utc, &tp));
1242    EXPECT_TRUE(
1243        parse(RFC3339_sec, "-292277022657-01-27T08:29:52+00:00", utc, &tp));
1244    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::min());
1245    EXPECT_FALSE(
1246        parse(RFC3339_sec, "-292277022657-01-27T08:29:51+00:00", utc, &tp));
1247    EXPECT_TRUE(
1248        parse(RFC3339_sec, "-292277022657-01-27T09:29:52+01:00", utc, &tp));
1249    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::min());
1250    EXPECT_FALSE(
1251        parse(RFC3339_sec, "-292277022657-01-27T08:29:51+01:00", utc, &tp));
1252    EXPECT_FALSE(
1253        parse(RFC3339_sec, "9223372036854775807-12-31T23:59:59-00:01", utc, &tp));
1254    EXPECT_FALSE(parse(RFC3339_sec, "-9223372036854775808-01-01T00:00:00+00:01",
1255                       utc, &tp));
1256  }
1257  TEST(Parse, TimePointOverflow) {
1258    const time_zone utc = utc_time_zone();
1259    using D = chrono::duration<std::int64_t, std::nano>;
1260    time_point<D> tp;
1261    EXPECT_TRUE(
1262        parse(RFC3339_full, "2262-04-11T23:47:16.8547758079+00:00", utc, &tp));
1263    EXPECT_EQ(tp, time_point<D>::max());
1264    EXPECT_EQ("2262-04-11T23:47:16.854775807+00:00",
1265              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1266  #if 0
1267    EXPECT_FALSE(
1268        parse(RFC3339_full, "2262-04-11T23:47:16.8547758080+00:00", utc, &tp));
1269    EXPECT_TRUE(
1270        parse(RFC3339_full, "1677-09-21T00:12:43.1452241920+00:00", utc, &tp));
1271    EXPECT_EQ(tp, time_point<D>::min());
1272    EXPECT_EQ("1677-09-21T00:12:43.145224192+00:00",
1273              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1274    EXPECT_FALSE(
1275        parse(RFC3339_full, "1677-09-21T00:12:43.1452241919+00:00", utc, &tp));
1276  #endif
1277    using DS = chrono::duration<std::int8_t, chrono::seconds::period>;
1278    time_point<DS> stp;
1279    EXPECT_TRUE(parse(RFC3339_full, "1970-01-01T00:02:07.9+00:00", utc, &stp));
1280    EXPECT_EQ(stp, time_point<DS>::max());
1281    EXPECT_EQ("1970-01-01T00:02:07+00:00",
1282              absl::time_internal::cctz::format(RFC3339_full, stp, utc));
1283    EXPECT_FALSE(parse(RFC3339_full, "1970-01-01T00:02:08+00:00", utc, &stp));
1284    EXPECT_TRUE(parse(RFC3339_full, "1969-12-31T23:57:52+00:00", utc, &stp));
1285    EXPECT_EQ(stp, time_point<DS>::min());
1286    EXPECT_EQ("1969-12-31T23:57:52+00:00",
1287              absl::time_internal::cctz::format(RFC3339_full, stp, utc));
1288    EXPECT_FALSE(parse(RFC3339_full, "1969-12-31T23:57:51.9+00:00", utc, &stp));
1289    using DM = chrono::duration<std::int8_t, chrono::minutes::period>;
1290    time_point<DM> mtp;
1291    EXPECT_TRUE(parse(RFC3339_full, "1970-01-01T02:07:59+00:00", utc, &mtp));
1292    EXPECT_EQ(mtp, time_point<DM>::max());
1293    EXPECT_EQ("1970-01-01T02:07:00+00:00",
1294              absl::time_internal::cctz::format(RFC3339_full, mtp, utc));
1295    EXPECT_FALSE(parse(RFC3339_full, "1970-01-01T02:08:00+00:00", utc, &mtp));
1296    EXPECT_TRUE(parse(RFC3339_full, "1969-12-31T21:52:00+00:00", utc, &mtp));
1297    EXPECT_EQ(mtp, time_point<DM>::min());
1298    EXPECT_EQ("1969-12-31T21:52:00+00:00",
1299              absl::time_internal::cctz::format(RFC3339_full, mtp, utc));
1300    EXPECT_FALSE(parse(RFC3339_full, "1969-12-31T21:51:59+00:00", utc, &mtp));
1301  }
1302  TEST(Parse, TimePointOverflowFloor) {
1303    const time_zone utc = utc_time_zone();
1304    using D = chrono::duration<std::int64_t, std::micro>;
1305    time_point<D> tp;
1306    EXPECT_TRUE(
1307        parse(RFC3339_full, "294247-01-10T04:00:54.7758079+00:00", utc, &tp));
1308    EXPECT_EQ(tp, time_point<D>::max());
1309    EXPECT_EQ("294247-01-10T04:00:54.775807+00:00",
1310              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1311  #if 0
1312    EXPECT_FALSE(
1313        parse(RFC3339_full, "294247-01-10T04:00:54.7758080+00:00", utc, &tp));
1314    EXPECT_TRUE(
1315        parse(RFC3339_full, "-290308-12-21T19:59:05.2241920+00:00", utc, &tp));
1316    EXPECT_EQ(tp, time_point<D>::min());
1317    EXPECT_EQ("-290308-12-21T19:59:05.224192+00:00",
1318              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1319    EXPECT_FALSE(
1320        parse(RFC3339_full, "-290308-12-21T19:59:05.2241919+00:00", utc, &tp));
1321  #endif
1322  }
1323  TEST(FormatParse, RoundTrip) {
1324    time_zone lax;
1325    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &lax));
1326    const auto in = convert(civil_second(1977, 6, 28, 9, 8, 7), lax);
1327    const auto subseconds = chrono::nanoseconds(654321);
1328    {
1329      time_point<chrono::nanoseconds> out;
1330      const std::string s =
1331          absl::time_internal::cctz::format(RFC3339_full, in + subseconds, lax);
1332      EXPECT_TRUE(parse(RFC3339_full, s, lax, &out)) << s;
1333      EXPECT_EQ(in + subseconds, out);  
1334    }
1335    {
1336      time_point<chrono::nanoseconds> out;
1337      const std::string s =
1338          absl::time_internal::cctz::format(RFC1123_full, in, lax);
1339      EXPECT_TRUE(parse(RFC1123_full, s, lax, &out)) << s;
1340      EXPECT_EQ(in, out);  
1341    }
1342  #if defined(_WIN32) || defined(_WIN64)
1343  #elif defined(__EMSCRIPTEN__)
1344  #else
1345    {
1346      time_point<chrono::nanoseconds> out;
1347      time_zone utc = utc_time_zone();
1348      const std::string s = absl::time_internal::cctz::format("%c", in, utc);
1349      EXPECT_TRUE(parse("%c", s, utc, &out)) << s;
1350      EXPECT_EQ(in, out);
1351    }
1352  #endif
1353  }
1354  TEST(FormatParse, RoundTripDistantFuture) {
1355    const time_zone utc = utc_time_zone();
1356    const time_point<absl::time_internal::cctz::seconds> in =
1357        time_point<absl::time_internal::cctz::seconds>::max();
1358    const std::string s =
1359        absl::time_internal::cctz::format(RFC3339_full, in, utc);
1360    time_point<absl::time_internal::cctz::seconds> out;
1361    EXPECT_TRUE(parse(RFC3339_full, s, utc, &out)) << s;
1362    EXPECT_EQ(in, out);
1363  }
1364  TEST(FormatParse, RoundTripDistantPast) {
1365    const time_zone utc = utc_time_zone();
1366    const time_point<absl::time_internal::cctz::seconds> in =
1367        time_point<absl::time_internal::cctz::seconds>::min();
1368    const std::string s =
1369        absl::time_internal::cctz::format(RFC3339_full, in, utc);
1370    time_point<absl::time_internal::cctz::seconds> out;
1371    EXPECT_TRUE(parse(RFC3339_full, s, utc, &out)) << s;
1372    EXPECT_EQ(in, out);
1373  }
1374  }  
1375  }  
1376  ABSL_NAMESPACE_END
1377  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>424    C_BLOB_LIST line_cblobs;
425    BLOBNBOX_LIST line_bblobs;
426    GetLineBoxes(false, *pix_vline, pix_intersections, &line_cblobs, &line_bblobs);
427    int width = pixGetWidth(src_pix);
428    int height = pixGetHeight(src_pix);
429    ICOORD bleft(0, 0);
</pre></code></div>
                <div class="column column_space"><pre><code>168  TEST(Format, LocaleSpecific) {
169    const time_zone tz = utc_time_zone();
170    auto tp = chrono::system_clock::from_time_t(0);
171    TestFormatSpecifier(tp, tz, "%a", "Thu");
172    TestFormatSpecifier(tp, tz, "%A", "Thursday");
173    TestFormatSpecifier(tp, tz, "%b", "Jan");
174    TestFormatSpecifier(tp, tz, "%B", "January");
175    const std::string s =
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    