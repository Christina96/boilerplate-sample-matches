
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.360655737704917%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-compressed_tuple_test.cc</h3>
            <pre><code>1  #include "absl/container/internal/compressed_tuple.h"
2  #include <memory>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/container/internal/test_instance_tracker.h"
7  #include "absl/memory/memory.h"
8  #include "absl/types/any.h"
9  #include "absl/types/optional.h"
10  #include "absl/utility/utility.h"
11  enum class CallType { kConstRef, kConstMove };
12  template <int>
13  struct Empty {
14    constexpr CallType value() const& { return CallType::kConstRef; }
15    constexpr CallType value() const&& { return CallType::kConstMove; }
16  };
17  template <typename T>
18  struct NotEmpty {
19    T value;
20  };
21  template <typename T, typename U>
22  struct TwoValues {
23    T value1;
24    U value2;
25  };
26  namespace absl {
27  ABSL_NAMESPACE_BEGIN
28  namespace container_internal {
29  namespace {
30  using absl::test_internal::CopyableMovableInstance;
31  using absl::test_internal::InstanceTracker;
32  TEST(CompressedTupleTest, Sizeof) {
33    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int>));
34    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int, Empty<0>>));
35    EXPECT_EQ(sizeof(int), sizeof(CompressedTuple<int, Empty<0>, Empty<1>>));
36    EXPECT_EQ(sizeof(int),
37              sizeof(CompressedTuple<int, Empty<0>, Empty<1>, Empty<2>>));
38    EXPECT_EQ(sizeof(TwoValues<int, double>),
39              sizeof(CompressedTuple<int, NotEmpty<double>>));
40    EXPECT_EQ(sizeof(TwoValues<int, double>),
41              sizeof(CompressedTuple<int, Empty<0>, NotEmpty<double>>));
42    EXPECT_EQ(sizeof(TwoValues<int, double>),
43              sizeof(CompressedTuple<int, Empty<0>, NotEmpty<double>, Empty<1>>));
44  }
45  TEST(CompressedTupleTest, OneMoveOnRValueConstructionTemp) {
46    InstanceTracker tracker;
47    CompressedTuple<CopyableMovableInstance> x1(CopyableMovableInstance(1));
48    EXPECT_EQ(tracker.instances(), 1);
49    EXPECT_EQ(tracker.copies(), 0);
50    EXPECT_LE(tracker.moves(), 1);
51    EXPECT_EQ(x1.get<0>().value(), 1);
52  }
53  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMove) {
54    InstanceTracker tracker;
55    CopyableMovableInstance i1(1);
<span onclick='openModal()' class='match'>56    CompressedTuple<CopyableMovableInstance> x1(std::move(i1));
57    EXPECT_EQ(tracker.instances(), 2);
58    EXPECT_EQ(tracker.copies(), 0);
59    EXPECT_LE(tracker.moves(), 1);
60    EXPECT_EQ(x1.get<0>().value(), 1);
61  }
62  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMixedTypes) {
63    InstanceTracker tracker;
64    CopyableMovableInstance i1(1);
</span>65    CopyableMovableInstance i2(2);
66    Empty<0> empty;
67    CompressedTuple<CopyableMovableInstance, CopyableMovableInstance&, Empty<0>>
68        x1(std::move(i1), i2, empty);
69    EXPECT_EQ(x1.get<0>().value(), 1);
70    EXPECT_EQ(x1.get<1>().value(), 2);
71    EXPECT_EQ(tracker.copies(), 0);
72    EXPECT_EQ(tracker.moves(), 1);
73  }
74  struct IncompleteType;
75  CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>>
76  MakeWithIncomplete(CopyableMovableInstance i1,
77                     IncompleteType& t,  
78                     Empty<0> empty) {
79    return CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>>{
80        std::move(i1), t, empty};
81  }
82  struct IncompleteType {};
83  TEST(CompressedTupleTest, OneMoveOnRValueConstructionWithIncompleteType) {
84    InstanceTracker tracker;
85    CopyableMovableInstance i1(1);
86    Empty<0> empty;
87    struct DerivedType : IncompleteType {int value = 0;};
88    DerivedType fd;
89    fd.value = 7;
90    CompressedTuple<CopyableMovableInstance, IncompleteType&, Empty<0>> x1 =
91        MakeWithIncomplete(std::move(i1), fd, empty);
92    EXPECT_EQ(x1.get<0>().value(), 1);
93    EXPECT_EQ(static_cast<DerivedType&>(x1.get<1>()).value, 7);
94    EXPECT_EQ(tracker.copies(), 0);
95    EXPECT_EQ(tracker.moves(), 2);
96  }
97  TEST(CompressedTupleTest,
98       OneMoveOnRValueConstructionMixedTypes_BraceInitPoisonPillExpected) {
99    InstanceTracker tracker;
100    CopyableMovableInstance i1(1);
101    CopyableMovableInstance i2(2);
102    CompressedTuple<CopyableMovableInstance, CopyableMovableInstance&, Empty<0>>
103        x1(std::move(i1), i2, {});  
104    EXPECT_EQ(x1.get<0>().value(), 1);
105    EXPECT_EQ(x1.get<1>().value(), 2);
106    EXPECT_EQ(tracker.instances(), 3);
107    EXPECT_EQ(tracker.copies(), 1);
108    EXPECT_EQ(tracker.moves(), 0);
109  }
110  TEST(CompressedTupleTest, OneCopyOnLValueConstruction) {
111    InstanceTracker tracker;
112    CopyableMovableInstance i1(1);
113    CompressedTuple<CopyableMovableInstance> x1(i1);
114    EXPECT_EQ(tracker.copies(), 1);
115    EXPECT_EQ(tracker.moves(), 0);
116    tracker.ResetCopiesMovesSwaps();
117    CopyableMovableInstance i2(2);
118    const CopyableMovableInstance& i2_ref = i2;
119    CompressedTuple<CopyableMovableInstance> x2(i2_ref);
120    EXPECT_EQ(tracker.copies(), 1);
121    EXPECT_EQ(tracker.moves(), 0);
122  }
123  TEST(CompressedTupleTest, OneMoveOnRValueAccess) {
124    InstanceTracker tracker;
125    CopyableMovableInstance i1(1);
126    CompressedTuple<CopyableMovableInstance> x(std::move(i1));
127    tracker.ResetCopiesMovesSwaps();
128    CopyableMovableInstance i2 = std::move(x).get<0>();
129    EXPECT_EQ(tracker.copies(), 0);
130    EXPECT_EQ(tracker.moves(), 1);
131  }
132  TEST(CompressedTupleTest, OneCopyOnLValueAccess) {
133    InstanceTracker tracker;
134    CompressedTuple<CopyableMovableInstance> x(CopyableMovableInstance(0));
135    EXPECT_EQ(tracker.copies(), 0);
136    EXPECT_EQ(tracker.moves(), 1);
137    CopyableMovableInstance t = x.get<0>();
138    EXPECT_EQ(tracker.copies(), 1);
139    EXPECT_EQ(tracker.moves(), 1);
140  }
141  TEST(CompressedTupleTest, ZeroCopyOnRefAccess) {
142    InstanceTracker tracker;
143    CompressedTuple<CopyableMovableInstance> x(CopyableMovableInstance(0));
144    EXPECT_EQ(tracker.copies(), 0);
145    EXPECT_EQ(tracker.moves(), 1);
146    CopyableMovableInstance& t1 = x.get<0>();
147    const CopyableMovableInstance& t2 = x.get<0>();
148    EXPECT_EQ(tracker.copies(), 0);
149    EXPECT_EQ(tracker.moves(), 1);
150    EXPECT_EQ(t1.value(), 0);
151    EXPECT_EQ(t2.value(), 0);
152  }
153  TEST(CompressedTupleTest, Access) {
154    struct S {
155      std::string x;
156    };
157    CompressedTuple<int, Empty<0>, S> x(7, {}, S{"ABC"});
158    EXPECT_EQ(sizeof(x), sizeof(TwoValues<int, S>));
159    EXPECT_EQ(7, x.get<0>());
160    EXPECT_EQ("ABC", x.get<2>().x);
161  }
162  TEST(CompressedTupleTest, NonClasses) {
163    CompressedTuple<int, const char*> x(7, "ABC");
164    EXPECT_EQ(7, x.get<0>());
165    EXPECT_STREQ("ABC", x.get<1>());
166  }
167  TEST(CompressedTupleTest, MixClassAndNonClass) {
168    CompressedTuple<int, const char*, Empty<0>, NotEmpty<double>> x(7, "ABC", {},
169                                                                    {1.25});
170    struct Mock {
171      int v;
172      const char* p;
173      double d;
174    };
175    EXPECT_EQ(sizeof(x), sizeof(Mock));
176    EXPECT_EQ(7, x.get<0>());
177    EXPECT_STREQ("ABC", x.get<1>());
178    EXPECT_EQ(1.25, x.get<3>().value);
179  }
180  TEST(CompressedTupleTest, Nested) {
181    CompressedTuple<int, CompressedTuple<int>,
182                    CompressedTuple<int, CompressedTuple<int>>>
183        x(1, CompressedTuple<int>(2),
184          CompressedTuple<int, CompressedTuple<int>>(3, CompressedTuple<int>(4)));
185    EXPECT_EQ(1, x.get<0>());
186    EXPECT_EQ(2, x.get<1>().get<0>());
187    EXPECT_EQ(3, x.get<2>().get<0>());
188    EXPECT_EQ(4, x.get<2>().get<1>().get<0>());
189    CompressedTuple<Empty<0>, Empty<0>,
190                    CompressedTuple<Empty<0>, CompressedTuple<Empty<0>>>>
191        y;
192    std::set<Empty<0>*> empties{&y.get<0>(), &y.get<1>(), &y.get<2>().get<0>(),
193                                &y.get<2>().get<1>().get<0>()};
194  #ifdef _MSC_VER
195    int expected = 1;
196  #else
197    int expected = 4;
198  #endif
199    EXPECT_EQ(expected, sizeof(y));
200    EXPECT_EQ(expected, empties.size());
201    EXPECT_EQ(sizeof(y), sizeof(Empty<0>) * empties.size());
202    EXPECT_EQ(4 * sizeof(char),
203              sizeof(CompressedTuple<CompressedTuple<char, char>,
204                                     CompressedTuple<char, char>>));
205    EXPECT_TRUE((std::is_empty<CompressedTuple<Empty<0>, Empty<1>>>::value));
206    struct CT_Empty : CompressedTuple<Empty<0>> {};
207    CompressedTuple<Empty<0>, CT_Empty> nested_empty;
208    auto contained = nested_empty.get<0>();
209    auto nested = nested_empty.get<1>().get<0>();
210    EXPECT_TRUE((std::is_same<decltype(contained), decltype(nested)>::value));
211  }
212  TEST(CompressedTupleTest, Reference) {
213    int i = 7;
214    std::string s = "Very long string that goes in the heap";
215    CompressedTuple<int, int&, std::string, std::string&> x(i, i, s, s);
216    EXPECT_EQ(s, "Very long string that goes in the heap");
217    EXPECT_EQ(x.get<0>(), x.get<1>());
218    EXPECT_NE(&x.get<0>(), &x.get<1>());
219    EXPECT_EQ(&x.get<1>(), &i);
220    EXPECT_EQ(x.get<2>(), x.get<3>());
221    EXPECT_NE(&x.get<2>(), &x.get<3>());
222    EXPECT_EQ(&x.get<3>(), &s);
223  }
224  TEST(CompressedTupleTest, NoElements) {
225    CompressedTuple<> x;
226    static_cast<void>(x);  
227    EXPECT_TRUE(std::is_empty<CompressedTuple<>>::value);
228  }
229  TEST(CompressedTupleTest, MoveOnlyElements) {
230    CompressedTuple<std::unique_ptr<std::string>> str_tup(
231        absl::make_unique<std::string>("str"));
232    CompressedTuple<CompressedTuple<std::unique_ptr<std::string>>,
233                    std::unique_ptr<int>>
234    x(std::move(str_tup), absl::make_unique<int>(5));
235    EXPECT_EQ(*x.get<0>().get<0>(), "str");
236    EXPECT_EQ(*x.get<1>(), 5);
237    std::unique_ptr<std::string> x0 = std::move(x.get<0>()).get<0>();
238    std::unique_ptr<int> x1 = std::move(x).get<1>();
239    EXPECT_EQ(*x0, "str");
240    EXPECT_EQ(*x1, 5);
241  }
242  TEST(CompressedTupleTest, MoveConstructionMoveOnlyElements) {
243    CompressedTuple<std::unique_ptr<std::string>> base(
244        absl::make_unique<std::string>("str"));
245    EXPECT_EQ(*base.get<0>(), "str");
246    CompressedTuple<std::unique_ptr<std::string>> copy(std::move(base));
247    EXPECT_EQ(*copy.get<0>(), "str");
248  }
249  TEST(CompressedTupleTest, AnyElements) {
250    any a(std::string("str"));
251    CompressedTuple<any, any&> x(any(5), a);
252    EXPECT_EQ(absl::any_cast<int>(x.get<0>()), 5);
253    EXPECT_EQ(absl::any_cast<std::string>(x.get<1>()), "str");
254    a = 0.5f;
255    EXPECT_EQ(absl::any_cast<float>(x.get<1>()), 0.5);
256  }
257  TEST(CompressedTupleTest, Constexpr) {
258    struct NonTrivialStruct {
259      constexpr NonTrivialStruct() = default;
260      constexpr int value() const { return v; }
261      int v = 5;
262    };
263    struct TrivialStruct {
264      TrivialStruct() = default;
265      constexpr int value() const { return v; }
266      int v;
267    };
268    constexpr CompressedTuple<int, double, CompressedTuple<int>, Empty<0>> x(
269        7, 1.25, CompressedTuple<int>(5), {});
270    constexpr int x0 = x.get<0>();
271    constexpr double x1 = x.get<1>();
272    constexpr int x2 = x.get<2>().get<0>();
273    constexpr CallType x3 = x.get<3>().value();
274    EXPECT_EQ(x0, 7);
275    EXPECT_EQ(x1, 1.25);
276    EXPECT_EQ(x2, 5);
277    EXPECT_EQ(x3, CallType::kConstRef);
278  #if !defined(__GNUC__) || defined(__clang__) || __GNUC__ > 4
279    constexpr CompressedTuple<Empty<0>, TrivialStruct, int> trivial = {};
280    constexpr CallType trivial0 = trivial.get<0>().value();
281    constexpr int trivial1 = trivial.get<1>().value();
282    constexpr int trivial2 = trivial.get<2>();
283    EXPECT_EQ(trivial0, CallType::kConstRef);
284    EXPECT_EQ(trivial1, 0);
285    EXPECT_EQ(trivial2, 0);
286  #endif
287    constexpr CompressedTuple<Empty<0>, NonTrivialStruct, absl::optional<int>>
288        non_trivial = {};
289    constexpr CallType non_trivial0 = non_trivial.get<0>().value();
290    constexpr int non_trivial1 = non_trivial.get<1>().value();
291    constexpr absl::optional<int> non_trivial2 = non_trivial.get<2>();
292    EXPECT_EQ(non_trivial0, CallType::kConstRef);
293    EXPECT_EQ(non_trivial1, 5);
294    EXPECT_EQ(non_trivial2, absl::nullopt);
295    static constexpr char data[] = "DEF";
296    constexpr CompressedTuple<const char*> z(data);
297    constexpr const char* z1 = z.get<0>();
298    EXPECT_EQ(std::string(z1), std::string(data));
299  #if defined(__clang__)
300    constexpr int x2m = absl::move(x.get<2>()).get<0>();
301    constexpr CallType x3m = absl::move(x).get<3>().value();
302    EXPECT_EQ(x2m, 5);
303    EXPECT_EQ(x3m, CallType::kConstMove);
304  #endif
305  }
306  #if defined(__clang__) || defined(__GNUC__)
307  TEST(CompressedTupleTest, EmptyFinalClass) {
308    struct S final {
309      int f() const { return 5; }
310    };
311    CompressedTuple<S> x;
312    EXPECT_EQ(x.get<0>().f(), 5);
313  }
314  #endif
315  TEST(CompressedTupleTest, DISABLED_NestedEbo) {
316    struct Empty1 {};
317    struct Empty2 {};
318    CompressedTuple<Empty1, CompressedTuple<Empty2>, int> x;
319    CompressedTuple<Empty1, Empty2, int> y;
320    EXPECT_EQ(sizeof(x), sizeof(y));
321  }
322  }  
323  }  
324  ABSL_NAMESPACE_END
325  }  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.cpp</h3>
            <pre><code>1  #include <nano/lib/jsonconfig.hpp>
2  #include <nano/node/election.hpp>
3  #include <nano/node/scheduler/buckets.hpp>
4  #include <nano/node/scheduler/component.hpp>
5  #include <nano/node/transport/inproc.hpp>
6  #include <nano/test_common/chains.hpp>
7  #include <nano/test_common/system.hpp>
8  #include <nano/test_common/testutil.hpp>
9  #include <gtest/gtest.h>
10  #include <numeric>
11  using namespace std::chrono_literals;
12  namespace nano
13  {
14  TEST (active_transactions, confirm_election_by_request)
15  {
16  	nano::test::system system{};
17  	auto & node1 = *system.add_node ();
18  	nano::state_block_builder builder{};
19  	auto send1 = builder
20  				 .account (nano::dev::genesis_key.pub)
21  				 .representative (nano::dev::genesis_key.pub)
22  				 .previous (nano::dev::genesis->hash ())
23  				 .link (nano::public_key ())
24  				 .balance (nano::dev::constants.genesis_amount - 100)
25  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
26  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
27  				 .build_shared ();
28  	ASSERT_TRUE (nano::test::process (node1, { send1 }));
29  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
30  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { send1 }));
31  	ASSERT_TIMELY (5s, node1.active.empty ());
32  	WAIT (1s);
33  	nano::node_flags node_flags2{};
34  	node_flags2.disable_rep_crawler = true;
35  	auto & node2 = *system.add_node (node_flags2);
36  	node2.process_active (send1);
37  	std::shared_ptr<nano::election> election{};
38  	ASSERT_TIMELY (5s, (election = node2.active.election (send1->qualified_root ())) != nullptr);
39  	WAIT (1s);
40  	ASSERT_FALSE (election->confirmed ());
41  	ASSERT_EQ (0, election->confirmation_request_count);
42  	auto const peers = node2.network.random_set (1);
43  	ASSERT_FALSE (peers.empty ());
44  	{
45  		nano::lock_guard<nano::mutex> guard (node2.rep_crawler.probable_reps_mutex);
46  		node2.rep_crawler.probable_reps.emplace (nano::dev::genesis_key.pub, *peers.cbegin ());
47  	}
48  	ASSERT_TIMELY (5s, election->votes ().size () >= 1);
49  	ASSERT_TIMELY (5s, election->confirmation_request_count >= 1);
50  	ASSERT_TIMELY (5s, election->confirmed ());
51  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { send1 }));
52  	ASSERT_TIMELY (5s, nano::test::confirmed (node2, { send1 }));
53  }
54  }
55  namespace nano
56  {
57  TEST (active_transactions, confirm_frontier)
58  {
59  	nano::test::system system;
60  	nano::node_flags node_flags;
61  	node_flags.disable_request_loop = true;
62  	auto & node1 = *system.add_node (node_flags);
63  	nano::node_flags node_flags2;
64  	node_flags2.disable_rep_crawler = true;
65  	auto & node2 = *system.add_node (node_flags2);
66  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
67  	auto peers (node2.network.random_set (1));
68  	ASSERT_FALSE (peers.empty ());
69  	{
70  		nano::lock_guard<nano::mutex> guard (node2.rep_crawler.probable_reps_mutex);
71  		node2.rep_crawler.probable_reps.emplace (nano::dev::genesis_key.pub, *peers.begin ());
72  	}
73  	nano::state_block_builder builder;
74  	auto send = builder
75  				.account (nano::dev::genesis_key.pub)
76  				.previous (nano::dev::genesis->hash ())
77  				.representative (nano::dev::genesis_key.pub)
78  				.balance (nano::dev::constants.genesis_amount - 100)
79  				.link (nano::public_key ())
80  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
81  				.work (*system.work.generate (nano::dev::genesis->hash ()))
82  				.build_shared ();
83  	auto send_copy = builder.make_block ().from (*send).build_shared ();
84  	ASSERT_EQ (nano::process_result::progress, node1.process (*send).code);
85  	node1.confirmation_height_processor.add (send);
86  	ASSERT_TIMELY (5s, node1.ledger.block_confirmed (node1.store.tx_begin_read (), send->hash ()));
87  	ASSERT_EQ (nano::process_result::progress, node2.process (*send_copy).code);
88  	ASSERT_TIMELY (5s, !node2.active.empty ());
89  	auto election2 = node2.active.election (send->qualified_root ());
90  	ASSERT_NE (nullptr, election2);
91  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 2 && node2.active.empty ());
92  	ASSERT_GT (election2->confirmation_request_count, 0u);
93  }
94  }
95  TEST (active_transactions, keep_local)
96  {
97  	nano::test::system system{};
98  	nano::node_config node_config = system.default_config ();
99  	node_config.enable_voting = false;
100  	node_config.active_elections_size = 2;
101  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
102  	auto & node = *system.add_node (node_config);
103  	auto & wallet (*system.wallet (0));
104  	nano::keypair key1{};
105  	nano::keypair key2{};
106  	nano::keypair key3{};
107  	nano::keypair key4{};
108  	nano::keypair key5{};
109  	nano::keypair key6{};
110  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
111  	auto const send1 = wallet.send_action (nano::dev::genesis_key.pub, key1.pub, node.config.receive_minimum.number ());
112  	auto const send2 = wallet.send_action (nano::dev::genesis_key.pub, key2.pub, node.config.receive_minimum.number ());
113  	auto const send3 = wallet.send_action (nano::dev::genesis_key.pub, key3.pub, node.config.receive_minimum.number ());
114  	auto const send4 = wallet.send_action (nano::dev::genesis_key.pub, key4.pub, node.config.receive_minimum.number ());
115  	auto const send5 = wallet.send_action (nano::dev::genesis_key.pub, key5.pub, node.config.receive_minimum.number ());
116  	auto const send6 = wallet.send_action (nano::dev::genesis_key.pub, key6.pub, node.config.receive_minimum.number ());
117  	for (auto const & block : { send1, send2, send3, send4, send5, send6 })
118  	{
119  		std::shared_ptr<nano::election> election{};
120  		ASSERT_TIMELY (5s, (election = node.active.election (block->qualified_root ())) != nullptr);
121  		node.process_confirmed (nano::election_status{ block });
122  		election->force_confirm ();
123  		ASSERT_TIMELY (5s, node.block_confirmed (block->hash ()));
124  	}
125  	nano::state_block_builder builder{};
126  	const auto receive1 = builder.make_block ()
127  						  .account (key1.pub)
128  						  .previous (0)
129  						  .representative (key1.pub)
130  						  .balance (node.config.receive_minimum.number ())
131  						  .link (send1->hash ())
132  						  .sign (key1.prv, key1.pub)
133  						  .work (*system.work.generate (key1.pub))
134  						  .build_shared ();
135  	const auto receive2 = builder.make_block ()
136  						  .account (key2.pub)
137  						  .previous (0)
138  						  .representative (key2.pub)
139  						  .balance (node.config.receive_minimum.number ())
140  						  .link (send2->hash ())
141  						  .sign (key2.prv, key2.pub)
142  						  .work (*system.work.generate (key2.pub))
143  						  .build_shared ();
144  	const auto receive3 = builder.make_block ()
145  						  .account (key3.pub)
146  						  .previous (0)
147  						  .representative (key3.pub)
148  						  .balance (node.config.receive_minimum.number ())
149  						  .link (send3->hash ())
150  						  .sign (key3.prv, key3.pub)
151  						  .work (*system.work.generate (key3.pub))
152  						  .build_shared ();
153  	node.process_active (receive1);
154  	node.process_active (receive2);
155  	node.process_active (receive3);
156  	ASSERT_TIMELY (5s, node.active.size () == node_config.active_elections_size);
157  }
158  TEST (active_transactions, inactive_votes_cache)
159  {
160  	nano::test::system system (1);
161  	auto & node = *system.nodes[0];
162  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
163  	nano::keypair key;
164  	auto send = nano::send_block_builder ()
165  				.previous (latest)
166  				.destination (key.pub)
167  				.balance (nano::dev::constants.genesis_amount - 100)
168  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
169  				.work (*system.work.generate (latest))
170  				.build_shared ();
171  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash> (1, send->hash ())));
172  	node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
173  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
174  	node.process_active (send);
175  	node.block_processor.flush ();
176  	ASSERT_TIMELY (5s, node.ledger.block_confirmed (node.store.tx_begin_read (), send->hash ()));
177  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
178  }
179  TEST (active_transactions, inactive_votes_cache_non_final)
180  {
181  	nano::test::system system (1);
182  	auto & node = *system.nodes[0];
183  	auto send = nano::send_block_builder ()
184  				.previous (nano::dev::genesis->hash ())
185  				.destination (nano::keypair{}.pub)
186  				.balance (nano::dev::constants.genesis_amount - 100)
187  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
188  				.work (*system.work.generate (nano::dev::genesis->hash ()))
189  				.build_shared ();
190  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send->hash ()));
191  	node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
192  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
193  	node.process_active (send);
194  	std::shared_ptr<nano::election> election;
195  	ASSERT_TIMELY (5s, election = node.active.election (send->qualified_root ()));
196  	ASSERT_TIMELY_EQ (5s, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached), 1);
197  	ASSERT_TIMELY_EQ (5s, nano::dev::constants.genesis_amount - 100, election->tally ().begin ()->first);
198  	ASSERT_FALSE (election->confirmed ());
199  }
200  TEST (active_transactions, inactive_votes_cache_fork)
201  {
202  	nano::test::system system{ 1 };
203  	auto & node = *system.nodes[0];
204  	auto const latest = node.latest (nano::dev::genesis_key.pub);
205  	nano::keypair key{};
206  	nano::send_block_builder builder{};
207  	auto send1 = builder.make_block ()
208  				 .previous (latest)
209  				 .destination (key.pub)
210  				 .balance (nano::dev::constants.genesis_amount - 100)
211  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
212  				 .work (*system.work.generate (latest))
213  				 .build_shared ();
214  	auto send2 = builder.make_block ()
215  				 .previous (latest)
216  				 .destination (key.pub)
217  				 .balance (nano::dev::constants.genesis_amount - 200)
218  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
219  				 .work (*system.work.generate (latest))
220  				 .build_shared ();
221  	auto const vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash> (1, send1->hash ()));
222  	node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
223  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 1);
224  	node.process_active (send2);
225  	std::shared_ptr<nano::election> election{};
226  	ASSERT_TIMELY (5s, (election = node.active.election (send1->qualified_root ())) != nullptr);
227  	node.process_active (send1);
228  	ASSERT_TIMELY (5s, election->blocks ().size () == 2);
229  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
230  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
231  }
232  TEST (active_transactions, inactive_votes_cache_existing_vote)
233  {
234  	nano::test::system system;
235  	nano::node_config node_config = system.default_config ();
236  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
237  	auto & node = *system.add_node (node_config);
238  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
239  	nano::keypair key;
240  	nano::block_builder builder;
241  	auto send = builder.send ()
242  				.previous (latest)
243  				.destination (key.pub)
244  				.balance (nano::dev::constants.genesis_amount - 100 * nano::Gxrb_ratio)
245  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
246  				.work (*system.work.generate (latest))
247  				.build_shared ();
248  	auto open = builder.state ()
249  				.account (key.pub)
250  				.previous (0)
251  				.representative (key.pub)
252  				.balance (100 * nano::Gxrb_ratio)
253  				.link (send->hash ())
254  				.sign (key.prv, key.pub)
255  				.work (*system.work.generate (key.pub))
256  				.build_shared ();
257  	node.process_active (send);
258  	node.block_processor.add (open);
259  	node.block_processor.flush ();
260  	ASSERT_TIMELY (5s, node.active.size () == 1);
261  	auto election (node.active.election (send->qualified_root ()));
262  	ASSERT_NE (nullptr, election);
263  	ASSERT_GT (node.weight (key.pub), node.minimum_principal_weight ());
264  	auto vote1 (std::make_shared<nano::vote> (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash> (1, send->hash ())));
265  	node.vote_processor.vote (vote1, std::make_shared<nano::transport::inproc::channel> (node, node));
266  	ASSERT_TIMELY (5s, election->votes ().size () == 2);
267  	ASSERT_EQ (1, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_new));
268  	auto last_vote1 (election->votes ()[key.pub]);
269  	ASSERT_EQ (send->hash (), last_vote1.hash);
270  	ASSERT_EQ (nano::vote::timestamp_min * 1, last_vote1.timestamp);
271  	nano::unique_lock<nano::mutex> active_lock (node.active.mutex);
272  	node.inactive_vote_cache.vote (send->hash (), vote1);
273  	auto cache = node.inactive_vote_cache.find (send->hash ());
274  	ASSERT_TRUE (cache);
275  	ASSERT_EQ (1, cache->voters.size ());
276  	cache->fill (election);
277  	ASSERT_EQ (2, election->votes ().size ());
278  	auto last_vote2 (election->votes ()[key.pub]);
279  	ASSERT_EQ (last_vote1.hash, last_vote2.hash);
280  	ASSERT_EQ (last_vote1.timestamp, last_vote2.timestamp);
281  	ASSERT_EQ (last_vote1.time, last_vote2.time);
282  	ASSERT_EQ (0, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
283  }
284  TEST (active_transactions, inactive_votes_cache_multiple_votes)
285  {
286  	nano::test::system system;
287  	nano::node_config node_config = system.default_config ();
288  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
289  	auto & node = *system.add_node (node_config);
290  	nano::keypair key1;
291  	nano::block_builder builder;
292  	auto send1 = builder.send ()
293  				 .previous (nano::dev::genesis->hash ())
294  				 .destination (key1.pub)
295  				 .balance (nano::dev::constants.genesis_amount - 100 * nano::Gxrb_ratio)
296  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
297  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
298  				 .build_shared ();
299  	auto send2 = builder.send ()
300  				 .previous (send1->hash ())
301  				 .destination (key1.pub)
302  				 .balance (100 * nano::Gxrb_ratio)
303  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
304  				 .work (*system.work.generate (send1->hash ()))
305  				 .build_shared ();
306  	auto open = builder.state ()
307  				.account (key1.pub)
308  				.previous (0)
309  				.representative (key1.pub)
310  				.balance (100 * nano::Gxrb_ratio)
311  				.link (send1->hash ())
312  				.sign (key1.prv, key1.pub)
313  				.work (*system.work.generate (key1.pub))
314  				.build_shared ();
315  	ASSERT_TRUE (nano::test::process (node, { send1, send2, open }));
316  	ASSERT_TIMELY (5s, nano::test::exists (node, { send1, send2, open }));
317  	auto vote1 (std::make_shared<nano::vote> (key1.pub, key1.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
318  	node.vote_processor.vote (vote1, std::make_shared<nano::transport::inproc::channel> (node, node));
319  	auto vote2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
320  	node.vote_processor.vote (vote2, std::make_shared<nano::transport::inproc::channel> (node, node));
321  	ASSERT_TIMELY (5s, node.inactive_vote_cache.find (send1->hash ()));
322  	ASSERT_TIMELY (5s, node.inactive_vote_cache.find (send1->hash ())->voters.size () == 2);
323  	ASSERT_EQ (1, node.inactive_vote_cache.cache_size ());
324  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
325  	std::shared_ptr<nano::election> election;
326  	ASSERT_TIMELY (5s, election = node.active.election (send1->qualified_root ()));
327  	ASSERT_EQ (3, election->votes ().size ()); 
328  	ASSERT_EQ (2, node.stats.count (nano::stat::type::election, nano::stat::detail::vote_cached));
329  }
330  TEST (active_transactions, inactive_votes_cache_election_start)
331  {
332  	nano::test::system system;
333  	nano::node_config node_config = system.default_config ();
334  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
335  	node_config.optimistic_scheduler.enabled = false;
336  	auto & node = *system.add_node (node_config);
337  	nano::block_hash latest (node.latest (nano::dev::genesis_key.pub));
338  	nano::keypair key1, key2;
339  	nano::send_block_builder send_block_builder;
340  	nano::state_block_builder state_block_builder;
341  	auto amount = ((node.online_reps.trended () / 100) * node.config.election_hint_weight_percent) / 2 + 1000 * nano::Gxrb_ratio;
342  	auto send1 = send_block_builder.make_block ()
343  				 .previous (latest)
344  				 .destination (key1.pub)
345  				 .balance (nano::dev::constants.genesis_amount - amount)
346  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
347  				 .work (*system.work.generate (latest))
348  				 .build_shared ();
349  	auto send2 = send_block_builder.make_block ()
350  				 .previous (send1->hash ())
351  				 .destination (key2.pub)
352  				 .balance (nano::dev::constants.genesis_amount - 2 * amount)
353  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
354  				 .work (*system.work.generate (send1->hash ()))
355  				 .build_shared ();
356  	auto open1 = state_block_builder.make_block ()
357  				 .account (key1.pub)
358  				 .previous (0)
359  				 .representative (key1.pub)
360  				 .balance (amount)
361  				 .link (send1->hash ())
362  				 .sign (key1.prv, key1.pub)
363  				 .work (*system.work.generate (key1.pub))
364  				 .build_shared ();
365  	auto open2 = state_block_builder.make_block ()
366  				 .account (key2.pub)
367  				 .previous (0)
368  				 .representative (key2.pub)
369  				 .balance (amount)
370  				 .link (send2->hash ())
371  				 .sign (key2.prv, key2.pub)
372  				 .work (*system.work.generate (key2.pub))
373  				 .build_shared ();
374  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
375  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
376  	ASSERT_EQ (nano::process_result::progress, node.process (*open1).code);
377  	ASSERT_EQ (nano::process_result::progress, node.process (*open2).code);
378  	ASSERT_TIMELY (5s, 5 == node.ledger.cache.block_count);
379  	ASSERT_TRUE (node.active.empty ());
380  	ASSERT_EQ (1, node.ledger.cache.cemented_count);
381  	auto send3 = send_block_builder.make_block ()
382  				 .previous (send2->hash ())
383  				 .destination (nano::keypair ().pub)
384  				 .balance (send2->balance ().number () - 1)
385  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
386  				 .work (*system.work.generate (send2->hash ()))
387  				 .build_shared ();
388  	auto send4 = send_block_builder.make_block ()
389  				 .previous (send3->hash ())
390  				 .destination (nano::keypair ().pub)
391  				 .balance (send3->balance ().number () - 1)
392  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
393  				 .work (*system.work.generate (send3->hash ()))
394  				 .build_shared ();
395  	std::vector<nano::block_hash> hashes{ open1->hash (), open2->hash (), send4->hash () };
396  	auto vote1 (std::make_shared<nano::vote> (key1.pub, key1.prv, 0, 0, hashes));
397  	node.vote_processor.vote (vote1, std::make_shared<nano::transport::inproc::channel> (node, node));
398  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 3);
399  	ASSERT_TRUE (node.active.empty ());
400  	ASSERT_EQ (1, node.ledger.cache.cemented_count);
401  	auto vote2 (std::make_shared<nano::vote> (key2.pub, key2.prv, 0, 0, hashes));
402  	node.vote_processor.vote (vote2, std::make_shared<nano::transport::inproc::channel> (node, node));
403  	ASSERT_TIMELY (5s, 2 == node.active.size ());
404  	auto vote0 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, hashes)); 
405  	node.vote_processor.vote (vote0, std::make_shared<nano::transport::inproc::channel> (node, node));
406  	ASSERT_TIMELY (5s, node.active.empty ());
407  	ASSERT_TIMELY (5s, 5 == node.ledger.cache.cemented_count);
408  	ASSERT_TRUE (node.active.empty ());
409  	auto send4_cache (node.inactive_vote_cache.find (send4->hash ()));
410  	ASSERT_TRUE (send4_cache);
411  	ASSERT_EQ (3, send4_cache->voters.size ());
412  	node.process_active (send3);
413  	ASSERT_FALSE (node.block_confirmed_or_being_confirmed (send3->hash ()));
414  	ASSERT_FALSE (node.ledger.dependents_confirmed (node.store.tx_begin_read (), *send4));
415  	node.process_active (send4);
416  	ASSERT_TIMELY (5s, 7 == node.ledger.cache.cemented_count);
417  }
418  namespace nano
419  {
420  TEST (active_transactions, vote_replays)
421  {
422  	nano::test::system system;
423  	nano::node_config node_config = system.default_config ();
424  	node_config.enable_voting = false;
425  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
426  	auto & node = *system.add_node (node_config);
427  	nano::keypair key;
428  	nano::state_block_builder builder;
429  	auto send1 = builder.make_block ()
430  				 .account (nano::dev::genesis_key.pub)
431  				 .previous (nano::dev::genesis->hash ())
432  				 .representative (nano::dev::genesis_key.pub)
433  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
434  				 .link (key.pub)
435  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
436  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
437  				 .build_shared ();
438  	ASSERT_NE (nullptr, send1);
439  	auto open1 = builder.make_block ()
440  				 .account (key.pub)
441  				 .previous (0)
442  				 .representative (key.pub)
443  				 .balance (nano::Gxrb_ratio)
444  				 .link (send1->hash ())
445  				 .sign (key.prv, key.pub)
446  				 .work (*system.work.generate (key.pub))
447  				 .build_shared ();
448  	ASSERT_NE (nullptr, open1);
449  	node.process_active (send1);
450  	node.process_active (open1);
451  	nano::test::start_elections (system, node, { send1, open1 });
452  	ASSERT_EQ (2, node.active.size ());
453  	auto vote_send1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send1->hash () }));
454  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote_send1));
455  	ASSERT_EQ (2, node.active.size ());
456  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_send1));
457  	ASSERT_TIMELY (3s, node.active.size () == 1);
458  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_send1));
459  	auto vote_open1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ open1->hash () }));
460  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote_open1));
461  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_open1));
462  	ASSERT_TIMELY (3s, node.active.empty ());
463  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote_open1));
464  	ASSERT_EQ (nano::Gxrb_ratio, node.ledger.weight (key.pub));
465  	auto send2 = builder.make_block ()
466  				 .account (key.pub)
467  				 .previous (open1->hash ())
468  				 .representative (key.pub)
469  				 .balance (nano::Gxrb_ratio - 1)
470  				 .link (key.pub)
471  				 .sign (key.prv, key.pub)
472  				 .work (*system.work.generate (open1->hash ()))
473  				 .build_shared ();
474  	ASSERT_NE (nullptr, send2);
475  	node.process_active (send2);
476  	nano::test::start_elections (system, node, { send2 });
477  	ASSERT_EQ (1, node.active.size ());
478  	auto vote1_send2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send2->hash () }));
479  	auto vote2_send2 (std::make_shared<nano::vote> (key.pub, key.prv, 0, 0, std::vector<nano::block_hash>{ send2->hash () }));
480  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote2_send2));
481  	ASSERT_EQ (1, node.active.size ());
482  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
483  	ASSERT_EQ (1, node.active.size ());
484  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote1_send2));
485  	ASSERT_EQ (1, node.active.size ());
486  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote1_send2));
487  	ASSERT_TIMELY (3s, node.active.empty ());
488  	ASSERT_EQ (0, node.active.size ());
489  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote1_send2));
<span onclick='openModal()' class='match'>490  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
491  	{
492  		nano::lock_guard<nano::mutex> guard (node.active.mutex);
493  		node.active.recently_confirmed.clear ();
494  	}
495  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_send1));
496  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_open1));
497  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote1_send2));
498  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote2_send2));
499  }
500  }
501  TEST (active_transactions, dropped_cleanup)
502  {
503  	nano::test::system system;
504  	nano::node_flags flags;
</span>505  	flags.disable_request_loop = true;
506  	auto & node (*system.add_node (flags));
507  	auto chain = nano::test::setup_chain (system, node, 1, nano::dev::genesis_key, false);
508  	auto hash = chain[0]->hash ();
509  	std::vector<uint8_t> block_bytes;
510  	{
511  		nano::vectorstream stream (block_bytes);
512  		chain[0]->serialize (stream);
513  	}
514  	ASSERT_FALSE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
515  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
516  	auto election = nano::test::start_election (system, node, hash);
517  	ASSERT_NE (nullptr, election);
518  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
519  	ASSERT_TRUE (node.active.active (hash));
520  	ASSERT_FALSE (election->confirmed ());
521  	node.active.erase (*chain[0]);
522  	ASSERT_FALSE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
523  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
524  	ASSERT_FALSE (node.active.active (hash));
525  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
526  	election = nano::test::start_election (system, node, hash);
527  	ASSERT_NE (nullptr, election);
528  	election->force_confirm ();
529  	ASSERT_TIMELY (5s, election->confirmed ());
530  	node.active.erase (*chain[0]);
531  	ASSERT_TRUE (node.network.publish_filter.apply (block_bytes.data (), block_bytes.size ()));
532  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
533  	ASSERT_FALSE (node.active.active (hash));
534  }
535  TEST (active_transactions, republish_winner)
536  {
537  	nano::test::system system;
538  	nano::node_config node_config = system.default_config ();
539  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
540  	auto & node1 = *system.add_node (node_config);
541  	node_config.peering_port = system.get_available_port ();
542  	auto & node2 = *system.add_node (node_config);
543  	nano::keypair key;
544  	nano::state_block_builder builder;
545  	auto send1 = builder.make_block ()
546  				 .account (nano::dev::genesis_key.pub)
547  				 .previous (nano::dev::genesis->hash ())
548  				 .representative (nano::dev::genesis_key.pub)
549  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
550  				 .link (key.pub)
551  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
553  				 .build_shared ();
554  	node1.process_active (send1);
555  	node1.block_processor.flush ();
556  	ASSERT_TIMELY (3s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) == 1);
557  	for (auto i (0); i < 5; i++)
558  	{
559  		auto fork = builder.make_block ()
560  					.account (nano::dev::genesis_key.pub)
561  					.previous (nano::dev::genesis->hash ())
562  					.representative (nano::dev::genesis_key.pub)
563  					.balance (nano::dev::constants.genesis_amount - 1 - i)
564  					.link (key.pub)
565  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
566  					.work (*system.work.generate (nano::dev::genesis->hash ()))
567  					.build_shared ();
568  		node1.process_active (fork);
569  	}
570  	node1.block_processor.flush ();
571  	ASSERT_TIMELY (3s, !node1.active.empty ());
572  	ASSERT_EQ (1, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in));
573  	auto fork = builder.make_block ()
574  				.account (nano::dev::genesis_key.pub)
575  				.previous (nano::dev::genesis->hash ())
576  				.representative (nano::dev::genesis_key.pub)
577  				.balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
578  				.link (key.pub)
579  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
580  				.work (*system.work.generate (nano::dev::genesis->hash ()))
581  				.build_shared ();
582  	node1.process_active (fork);
583  	node1.block_processor.flush ();
584  	auto election = node1.active.election (fork->qualified_root ());
585  	ASSERT_NE (nullptr, election);
586  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ fork->hash () });
587  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
588  	node1.vote_processor.flush ();
589  	node1.block_processor.flush ();
590  	ASSERT_TIMELY (5s, election->confirmed ());
591  	ASSERT_EQ (fork->hash (), election->status.winner->hash ());
592  	ASSERT_TIMELY (5s, node2.block_confirmed (fork->hash ()));
593  }
594  TEST (active_transactions, fork_filter_cleanup)
595  {
596  	nano::test::system system{};
597  	nano::node_config node_config = system.default_config ();
598  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
599  	auto & node1 = *system.add_node (node_config);
600  	nano::keypair key{};
601  	nano::state_block_builder builder{};
602  	auto const latest_hash = nano::dev::genesis->hash ();
603  	auto send1 = builder.make_block ()
604  				 .previous (latest_hash)
605  				 .account (nano::dev::genesis_key.pub)
606  				 .representative (nano::dev::genesis_key.pub)
607  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
608  				 .link (key.pub)
609  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
610  				 .work (*system.work.generate (latest_hash))
611  				 .build_shared ();
612  	std::vector<uint8_t> send_block_bytes{};
613  	{
614  		nano::vectorstream stream{ send_block_bytes };
615  		send1->serialize (stream);
616  	}
617  	for (auto i = 0; i < 10; ++i)
618  	{
619  		auto fork = builder.make_block ()
620  					.previous (latest_hash)
621  					.account (nano::dev::genesis_key.pub)
622  					.representative (nano::dev::genesis_key.pub)
623  					.balance (nano::dev::constants.genesis_amount - 1 - i)
624  					.link (key.pub)
625  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
626  					.work (*system.work.generate (latest_hash))
627  					.build_shared ();
628  		node1.process_active (fork);
629  		ASSERT_TIMELY (5s, node1.active.election (fork->qualified_root ()) != nullptr);
630  	}
631  	std::shared_ptr<nano::election> election{};
632  	ASSERT_TIMELY (5s, (election = node1.active.election (send1->qualified_root ())) != nullptr);
633  	ASSERT_TIMELY (5s, election->blocks ().size () == 10);
634  	ASSERT_EQ (1, node1.active.size ());
635  	node_config.peering_port = system.get_available_port ();
636  	auto & node2 = *system.add_node (node_config);
637  	node2.process_active (send1);
638  	ASSERT_TIMELY (5s, node2.active.election (send1->qualified_root ()) != nullptr);
639  	ASSERT_TIMELY (5s, node2.ledger.cache.block_count == 2);
640  	ASSERT_TIMELY (5s, node1.ledger.cache.block_count == 2);
641  	ASSERT_TIMELY (5s, node1.network.publish_filter.apply (send_block_bytes.data (), send_block_bytes.size ()));
642  }
643  TEST (active_transactions, fork_replacement_tally)
644  {
645  	nano::test::system system;
646  	nano::node_config node_config = system.default_config ();
647  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
648  	auto & node1 (*system.add_node (node_config));
649  	size_t const reps_count = 20;
650  	size_t const max_blocks = 10;
651  	std::vector<nano::keypair> keys (reps_count);
652  	auto latest (nano::dev::genesis->hash ());
653  	auto balance (nano::dev::constants.genesis_amount);
654  	auto amount (node1.minimum_principal_weight ());
655  	nano::state_block_builder builder;
656  	for (auto i (0); i < reps_count; i++)
657  	{
658  		balance -= amount + i;
659  		auto send = builder.make_block ()
660  					.account (nano::dev::genesis_key.pub)
661  					.previous (latest)
662  					.representative (nano::dev::genesis_key.pub)
663  					.balance (balance)
664  					.link (keys[i].pub)
665  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
666  					.work (*system.work.generate (latest))
667  					.build_shared ();
668  		node1.process_active (send);
669  		latest = send->hash ();
670  		auto open = builder.make_block ()
671  					.account (keys[i].pub)
672  					.previous (0)
673  					.representative (keys[i].pub)
674  					.balance (amount + i)
675  					.link (send->hash ())
676  					.sign (keys[i].prv, keys[i].pub)
677  					.work (*system.work.generate (keys[i].pub))
678  					.build_shared ();
679  		node1.process_active (open);
680  		auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send->hash (), open->hash () }));
681  		node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
682  	}
683  	ASSERT_TIMELY (5s, node1.ledger.cache.cemented_count == 1 + 2 * reps_count);
684  	nano::keypair key;
685  	auto send_last = builder.make_block ()
686  					 .account (nano::dev::genesis_key.pub)
687  					 .previous (latest)
688  					 .representative (nano::dev::genesis_key.pub)
689  					 .balance (balance - 2 * nano::Gxrb_ratio)
690  					 .link (key.pub)
691  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
692  					 .work (*system.work.generate (latest))
693  					 .build_shared ();
694  	for (auto i (0); i < reps_count; i++)
695  	{
696  		auto fork = builder.make_block ()
697  					.account (nano::dev::genesis_key.pub)
698  					.previous (latest)
699  					.representative (nano::dev::genesis_key.pub)
700  					.balance (balance - nano::Gxrb_ratio - i)
701  					.link (key.pub)
702  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
703  					.work (*system.work.generate (latest))
704  					.build_shared ();
705  		node1.process_active (fork);
706  	}
707  	ASSERT_TIMELY (5s, !node1.active.empty ());
708  	auto election = node1.active.election (send_last->qualified_root ());
709  	ASSERT_NE (nullptr, election);
710  	ASSERT_TIMELY (5s, max_blocks == election->blocks ().size ());
711  	for (auto i (0); i < reps_count; i++)
712  	{
713  		auto fork = builder.make_block ()
714  					.account (nano::dev::genesis_key.pub)
715  					.previous (latest)
716  					.representative (nano::dev::genesis_key.pub)
717  					.balance (balance - 1 - i)
718  					.link (key.pub)
719  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
720  					.work (*system.work.generate (latest))
721  					.build_shared ();
722  		auto vote (std::make_shared<nano::vote> (keys[i].pub, keys[i].prv, 0, 0, std::vector<nano::block_hash>{ fork->hash () }));
723  		node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
724  		node1.vote_processor.flush ();
725  		node1.process_active (fork);
726  	}
727  	auto count_rep_votes_in_election = [&max_blocks, &reps_count, &election, &keys] () {
728  		auto votes_l = election->votes ();
729  		if (max_blocks != votes_l.size ())
730  		{
731  			return -1;
732  		}
733  		int vote_count = 0;
734  		for (auto i = 0; i < reps_count; i++)
735  		{
736  			if (votes_l.find (keys[i].pub) != votes_l.end ())
737  			{
738  				vote_count++;
739  			}
740  		}
741  		return vote_count;
742  	};
743  	ASSERT_TIMELY (10s, count_rep_votes_in_election () == 9);
744  	ASSERT_EQ (max_blocks, election->blocks ().size ());
745  	node_config.peering_port = system.get_available_port ();
746  	auto & node2 (*system.add_node (node_config));
747  	node1.network.publish_filter.clear ();
748  	node2.network.flood_block (send_last);
749  	ASSERT_TIMELY (3s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) > 0);
750  	node1.block_processor.flush ();
751  	system.delay_ms (50ms);
752  	auto blocks1 (election->blocks ());
753  	ASSERT_EQ (max_blocks, blocks1.size ());
754  	ASSERT_FALSE (blocks1.find (send_last->hash ()) != blocks1.end ());
755  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send_last->hash () }));
756  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node1, node1));
757  	node1.vote_processor.flush ();
758  	ASSERT_TIMELY (5s, node1.inactive_vote_cache.find (send_last->hash ()));
759  	ASSERT_TIMELY (5s, 1 == node1.inactive_vote_cache.find (send_last->hash ())->size ());
760  	node1.network.publish_filter.clear ();
761  	node2.network.flood_block (send_last);
762  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) > 1);
763  	auto find_send_last_block = [&election, &send_last] () {
764  		auto blocks2 = election->blocks ();
765  		return blocks2.find (send_last->hash ()) != blocks2.end ();
766  	};
767  	ASSERT_TIMELY (5s, find_send_last_block ())
768  	ASSERT_EQ (max_blocks, election->blocks ().size ());
769  	ASSERT_TIMELY (5s, count_rep_votes_in_election () == 8);
770  	auto votes2 (election->votes ());
771  	ASSERT_TRUE (votes2.find (nano::dev::genesis_key.pub) != votes2.end ());
772  }
773  namespace nano
774  {
775  TEST (active_transactions, confirmation_consistency)
776  {
777  	nano::test::system system;
778  	nano::node_config node_config = system.default_config ();
779  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
780  	auto & node = *system.add_node (node_config);
781  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
782  	for (unsigned i = 0; i < 10; ++i)
783  	{
784  		auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::public_key (), node.config.receive_minimum.number ()));
785  		ASSERT_NE (nullptr, block);
786  		system.deadline_set (5s);
787  		while (!node.ledger.block_confirmed (node.store.tx_begin_read (), block->hash ()))
788  		{
789  			node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
790  			ASSERT_NO_ERROR (system.poll (5ms));
791  		}
792  		ASSERT_NO_ERROR (system.poll_until_true (1s, [&node, &block, i] {
793  			nano::lock_guard<nano::mutex> guard (node.active.mutex);
794  			EXPECT_EQ (i + 1, node.active.recently_confirmed.size ());
795  			EXPECT_EQ (block->qualified_root (), node.active.recently_confirmed.back ().first);
796  			return i + 1 == node.active.recently_cemented.size (); 
797  		}));
798  	}
799  }
800  }
801  TEST (active_transactions, DISABLED_confirm_new)
802  {
803  	nano::test::system system (1);
804  	auto & node1 = *system.nodes[0];
805  	auto send = nano::send_block_builder ()
806  				.previous (nano::dev::genesis->hash ())
807  				.destination (nano::public_key ())
808  				.balance (nano::dev::constants.genesis_amount - 100)
809  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
810  				.work (*system.work.generate (nano::dev::genesis->hash ()))
811  				.build_shared ();
812  	node1.process_active (send);
813  	node1.block_processor.flush ();
814  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
815  	auto & node2 = *system.add_node ();
816  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
817  	ASSERT_TIMELY (5s, node2.block (send->hash ()));
818  	ASSERT_TIMELY (5s, node1.ledger.cache.cemented_count == 2 && node2.ledger.cache.cemented_count == 2);
819  }
820  TEST (active_transactions, conflicting_block_vote_existing_election)
821  {
822  	nano::test::system system;
823  	nano::node_flags node_flags;
824  	node_flags.disable_request_loop = true;
825  	auto & node = *system.add_node (node_flags);
826  	nano::keypair key;
827  	nano::state_block_builder builder;
828  	auto send = builder.make_block ()
829  				.account (nano::dev::genesis_key.pub)
830  				.previous (nano::dev::genesis->hash ())
831  				.representative (nano::dev::genesis_key.pub)
832  				.balance (nano::dev::constants.genesis_amount - 100)
833  				.link (key.pub)
834  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
835  				.work (*system.work.generate (nano::dev::genesis->hash ()))
836  				.build_shared ();
837  	auto fork = builder.make_block ()
838  				.account (nano::dev::genesis_key.pub)
839  				.previous (nano::dev::genesis->hash ())
840  				.representative (nano::dev::genesis_key.pub)
841  				.balance (nano::dev::constants.genesis_amount - 200)
842  				.link (key.pub)
843  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
844  				.work (*system.work.generate (nano::dev::genesis->hash ()))
845  				.build_shared ();
846  	auto vote_fork (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ fork->hash () }));
847  	ASSERT_EQ (nano::process_result::progress, node.process_local (send).value ().code);
848  	ASSERT_TIMELY_EQ (5s, 1, node.active.size ());
849  	node.active.vote (vote_fork);
850  	ASSERT_EQ (nano::process_result::fork, node.process_local (fork).value ().code);
851  	auto election (node.active.election (fork->qualified_root ()));
852  	ASSERT_NE (nullptr, election);
853  	ASSERT_TIMELY (3s, election->confirmed ());
854  }
855  TEST (active_transactions, activate_account_chain)
856  {
857  	nano::test::system system;
858  	nano::node_flags flags;
859  	nano::node_config config = system.default_config ();
860  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
861  	auto & node = *system.add_node (config, flags);
862  	nano::keypair key;
863  	nano::state_block_builder builder;
864  	auto send = builder.make_block ()
865  				.account (nano::dev::genesis_key.pub)
866  				.previous (nano::dev::genesis->hash ())
867  				.representative (nano::dev::genesis_key.pub)
868  				.link (nano::dev::genesis_key.pub)
869  				.balance (nano::dev::constants.genesis_amount - 1)
870  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
871  				.work (*system.work.generate (nano::dev::genesis->hash ()))
872  				.build ();
873  	auto send2 = builder.make_block ()
874  				 .account (nano::dev::genesis_key.pub)
875  				 .previous (send->hash ())
876  				 .representative (nano::dev::genesis_key.pub)
877  				 .link (key.pub)
878  				 .balance (nano::dev::constants.genesis_amount - 2)
879  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
880  				 .work (*system.work.generate (send->hash ()))
881  				 .build ();
882  	auto send3 = builder.make_block ()
883  				 .account (nano::dev::genesis_key.pub)
884  				 .previous (send2->hash ())
885  				 .representative (nano::dev::genesis_key.pub)
886  				 .link (key.pub)
887  				 .balance (nano::dev::constants.genesis_amount - 3)
888  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
889  				 .work (*system.work.generate (send2->hash ()))
890  				 .build ();
891  	auto open = builder.make_block ()
892  				.account (key.pub)
893  				.previous (0)
894  				.representative (key.pub)
895  				.link (send2->hash ())
896  				.balance (1)
897  				.sign (key.prv, key.pub)
898  				.work (*system.work.generate (key.pub))
899  				.build ();
900  	auto receive = builder.make_block ()
901  				   .account (key.pub)
902  				   .previous (open->hash ())
903  				   .representative (key.pub)
904  				   .link (send3->hash ())
905  				   .balance (2)
906  				   .sign (key.prv, key.pub)
907  				   .work (*system.work.generate (open->hash ()))
908  				   .build ();
909  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
910  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
911  	ASSERT_EQ (nano::process_result::progress, node.process (*send3).code);
912  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
913  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
914  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
915  	ASSERT_TIMELY (5s, node.active.election (send->qualified_root ()));
916  	auto election1 = node.active.election (send->qualified_root ());
917  	ASSERT_EQ (1, node.active.size ());
918  	ASSERT_EQ (1, election1->blocks ().count (send->hash ()));
919  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
920  	auto election2 = node.active.election (send->qualified_root ());
921  	ASSERT_EQ (election2, election1);
922  	election1->force_confirm ();
923  	ASSERT_TIMELY (3s, node.block_confirmed (send->hash ()));
924  	ASSERT_TIMELY (3s, node.active.active (send2->qualified_root ()));
925  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
926  	auto election3 = node.active.election (send2->qualified_root ());
927  	ASSERT_NE (nullptr, election3);
928  	ASSERT_EQ (1, election3->blocks ().count (send2->hash ()));
929  	election3->force_confirm ();
930  	ASSERT_TIMELY (3s, node.block_confirmed (send2->hash ()));
931  	ASSERT_TIMELY (3s, node.active.active (open->qualified_root ()));
932  	ASSERT_TIMELY (3s, node.active.active (send3->qualified_root ()));
933  	node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
934  	auto election4 = node.active.election (send3->qualified_root ());
935  	ASSERT_NE (nullptr, election4);
936  	ASSERT_EQ (1, election4->blocks ().count (send3->hash ()));
937  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
938  	auto election5 = node.active.election (open->qualified_root ());
939  	ASSERT_NE (nullptr, election5);
940  	ASSERT_EQ (1, election5->blocks ().count (open->hash ()));
941  	election5->force_confirm ();
942  	ASSERT_TIMELY (3s, node.block_confirmed (open->hash ()));
943  	std::this_thread::sleep_for (200ms);
944  	node.scheduler.buckets.activate (key.pub, node.store.tx_begin_read ());
945  	election4->force_confirm ();
946  	ASSERT_TIMELY (3s, node.block_confirmed (send3->hash ()));
947  	ASSERT_TIMELY (3s, node.active.active (receive->qualified_root ()));
948  }
949  TEST (active_transactions, activate_inactive)
950  {
951  	nano::test::system system;
952  	nano::node_flags flags;
953  	nano::node_config config = system.default_config ();
954  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
955  	auto & node = *system.add_node (config, flags);
956  	nano::keypair key;
957  	nano::state_block_builder builder;
958  	auto send = builder.make_block ()
959  				.account (nano::dev::genesis_key.pub)
960  				.previous (nano::dev::genesis->hash ())
961  				.representative (nano::dev::genesis_key.pub)
962  				.link (key.pub)
963  				.balance (nano::dev::constants.genesis_amount - 1)
964  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
965  				.work (*system.work.generate (nano::dev::genesis->hash ()))
966  				.build_shared ();
967  	auto send2 = builder.make_block ()
968  				 .account (nano::dev::genesis_key.pub)
969  				 .previous (send->hash ())
970  				 .representative (nano::dev::genesis_key.pub)
971  				 .link (nano::keypair ().pub)
972  				 .balance (nano::dev::constants.genesis_amount - 2)
973  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
974  				 .work (*system.work.generate (send->hash ()))
975  				 .build_shared ();
976  	auto open = builder.make_block ()
977  				.account (key.pub)
978  				.previous (0)
979  				.representative (key.pub)
980  				.link (send->hash ())
981  				.balance (1)
982  				.sign (key.prv, key.pub)
983  				.work (*system.work.generate (key.pub))
984  				.build_shared ();
985  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
986  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
987  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
988  	auto election = nano::test::start_election (system, node, send2->hash ());
989  	ASSERT_NE (nullptr, election);
990  	election->force_confirm ();
991  	ASSERT_TIMELY (5s, !node.confirmation_height_processor.is_processing_added_block (send2->hash ()));
992  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
993  	ASSERT_TIMELY (5s, node.block_confirmed (send->hash ()));
994  	ASSERT_EQ (1, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out));
995  	ASSERT_EQ (1, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::active_quorum, nano::stat::dir::out));
996  	ASSERT_EQ (0, node.stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::active_conf_height, nano::stat::dir::out));
997  	ASSERT_FALSE (node.active.active (open->qualified_root ()) || node.block_confirmed_or_being_confirmed (open->hash ()));
998  }
999  TEST (active_transactions, list_active)
1000  {
1001  	nano::test::system system (1);
1002  	auto & node = *system.nodes[0];
1003  	nano::keypair key;
1004  	nano::state_block_builder builder;
1005  	auto send = builder.make_block ()
1006  				.account (nano::dev::genesis_key.pub)
1007  				.previous (nano::dev::genesis->hash ())
1008  				.representative (nano::dev::genesis_key.pub)
1009  				.link (nano::dev::genesis_key.pub)
1010  				.balance (nano::dev::constants.genesis_amount - 1)
1011  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1012  				.work (*system.work.generate (nano::dev::genesis->hash ()))
1013  				.build_shared ();
1014  	ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1015  	auto send2 = builder.make_block ()
1016  				 .account (nano::dev::genesis_key.pub)
1017  				 .previous (send->hash ())
1018  				 .representative (nano::dev::genesis_key.pub)
1019  				 .link (key.pub)
1020  				 .balance (nano::dev::constants.genesis_amount - 2)
1021  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1022  				 .work (*system.work.generate (send->hash ()))
1023  				 .build_shared ();
1024  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
1025  	auto open = builder.make_block ()
1026  				.account (key.pub)
1027  				.previous (0)
1028  				.representative (key.pub)
1029  				.link (send2->hash ())
1030  				.balance (1)
1031  				.sign (key.prv, key.pub)
1032  				.work (*system.work.generate (key.pub))
1033  				.build_shared ();
1034  	ASSERT_EQ (nano::process_result::progress, node.process (*open).code);
1035  	nano::test::start_elections (system, node, { send, send2, open });
1036  	ASSERT_EQ (3, node.active.size ());
1037  	ASSERT_EQ (1, node.active.list_active (1).size ());
1038  	ASSERT_EQ (2, node.active.list_active (2).size ());
1039  	ASSERT_EQ (3, node.active.list_active (3).size ());
1040  	ASSERT_EQ (3, node.active.list_active (4).size ());
1041  	ASSERT_EQ (3, node.active.list_active (99999).size ());
1042  	ASSERT_EQ (3, node.active.list_active ().size ());
1043  	auto active = node.active.list_active ();
1044  }
1045  TEST (active_transactions, vacancy)
1046  {
1047  	std::atomic<bool> updated = false;
1048  	{
1049  		nano::test::system system;
1050  		nano::node_config config = system.default_config ();
1051  		config.active_elections_size = 1;
1052  		auto & node = *system.add_node (config);
1053  		nano::state_block_builder builder;
1054  		auto send = builder.make_block ()
1055  					.account (nano::dev::genesis_key.pub)
1056  					.previous (nano::dev::genesis->hash ())
1057  					.representative (nano::dev::genesis_key.pub)
1058  					.link (nano::dev::genesis_key.pub)
1059  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1060  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1061  					.work (*system.work.generate (nano::dev::genesis->hash ()))
1062  					.build_shared ();
1063  		node.active.vacancy_update = [&updated] () { updated = true; };
1064  		ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
1065  		ASSERT_EQ (1, node.active.vacancy ());
1066  		ASSERT_EQ (0, node.active.size ());
1067  		node.scheduler.buckets.activate (nano::dev::genesis_key.pub, node.store.tx_begin_read ());
1068  		ASSERT_TIMELY (1s, updated);
1069  		updated = false;
1070  		ASSERT_EQ (0, node.active.vacancy ());
1071  		ASSERT_EQ (1, node.active.size ());
1072  		auto election1 = node.active.election (send->qualified_root ());
1073  		ASSERT_NE (nullptr, election1);
1074  		election1->force_confirm ();
1075  		ASSERT_TIMELY (1s, updated);
1076  		ASSERT_EQ (1, node.active.vacancy ());
1077  		ASSERT_EQ (0, node.active.size ());
1078  	}
1079  }
1080  TEST (active_transactions, fifo)
1081  {
1082  	nano::test::system system{};
1083  	nano::node_config config = system.default_config ();
1084  	config.active_elections_size = 1;
1085  	auto & node = *system.add_node (config);
1086  	auto latest_hash = nano::dev::genesis->hash ();
1087  	nano::keypair key0{};
1088  	nano::state_block_builder builder{};
1089  	auto send1 = builder.make_block ()
1090  				 .previous (latest_hash)
1091  				 .account (nano::dev::genesis_key.pub)
1092  				 .representative (nano::dev::genesis_key.pub)
1093  				 .link (key0.pub)
1094  				 .balance (nano::dev::constants.genesis_amount - 1)
1095  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1096  				 .work (*system.work.generate (latest_hash))
1097  				 .build_shared ();
1098  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
1099  	node.process_confirmed (nano::election_status{ send1 });
1100  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
1101  	nano::keypair key1{};
1102  	latest_hash = send1->hash ();
1103  	auto send2 = builder.make_block ()
1104  				 .previous (latest_hash)
1105  				 .account (nano::dev::genesis_key.pub)
1106  				 .representative (nano::dev::genesis_key.pub)
1107  				 .link (key1.pub)
1108  				 .balance (nano::dev::constants.genesis_amount - 2)
1109  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1110  				 .work (*system.work.generate (latest_hash))
1111  				 .build_shared ();
1112  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
1113  	node.process_confirmed (nano::election_status{ send2 });
1114  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
1115  	auto receive1 = builder.make_block ()
1116  					.previous (0)
1117  					.account (key0.pub)
1118  					.representative (nano::dev::genesis_key.pub)
1119  					.link (send1->hash ())
1120  					.balance (1)
1121  					.sign (key0.prv, key0.pub)
1122  					.work (*system.work.generate (key0.pub))
1123  					.build_shared ();
1124  	ASSERT_EQ (nano::process_result::progress, node.process (*receive1).code);
1125  	auto receive2 = builder.make_block ()
1126  					.previous (0)
1127  					.account (key1.pub)
1128  					.representative (nano::dev::genesis_key.pub)
1129  					.link (send2->hash ())
1130  					.balance (1)
1131  					.sign (key1.prv, key1.pub)
1132  					.work (*system.work.generate (key1.pub))
1133  					.build_shared ();
1134  	ASSERT_EQ (nano::process_result::progress, node.process (*receive2).code);
1135  	node.scheduler.buckets.manual (receive1);
1136  	ASSERT_TIMELY (5s, node.active.election (receive1->qualified_root ()) != nullptr);
1137  	node.scheduler.buckets.manual (receive2);
1138  	ASSERT_TIMELY (5s, node.active.election (receive2->qualified_root ()) != nullptr);
1139  	ASSERT_TIMELY (5s, node.active.size () == 1);
1140  	ASSERT_EQ (1, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
1141  	ASSERT_TIMELY (1s, node.active.election (receive2->qualified_root ()) != nullptr);
1142  }
1143  TEST (active_transactions, limit_vote_hinted_elections)
1144  {
1145  	nano::test::system system;
1146  	nano::node_config config = system.default_config ();
1147  	const int aec_limit = 10;
1148  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1149  	config.optimistic_scheduler.enabled = false;
1150  	config.active_elections_size = aec_limit;
1151  	config.active_elections_hinted_limit_percentage = 10; 
1152  	auto & node = *system.add_node (config);
1153  	const auto amount = ((node.online_reps.trended () / 100) * node.config.election_hint_weight_percent) + 1000 * nano::Gxrb_ratio;
1154  	nano::keypair rep1 = nano::test::setup_rep (system, node, amount / 2);
1155  	nano::keypair rep2 = nano::test::setup_rep (system, node, amount / 2);
1156  	auto blocks = nano::test::setup_independent_blocks (system, node, 2);
1157  	auto open0 = blocks[0];
1158  	auto open1 = blocks[1];
1159  	WAIT (1s);
1160  	node.active.clear ();
1161  	ASSERT_TRUE (node.active.empty ());
1162  	auto vote1 = nano::test::make_vote (rep1, { open0, open1 });
1163  	node.vote_processor.vote (vote1, nano::test::fake_channel (node));
1164  	ASSERT_TIMELY (5s, node.inactive_vote_cache.cache_size () == 2);
1165  	ASSERT_ALWAYS (1s, node.active.empty ());
1166  	ASSERT_FALSE (nano::test::confirmed (node, { open0, open1 }));
1167  	auto vote2 = nano::test::make_vote (rep2, { open0 });
1168  	node.vote_processor.vote (vote2, nano::test::fake_channel (node));
1169  	ASSERT_TIMELY (5s, node.active.size () == 1);
1170  	ASSERT_TIMELY (5s, nano::test::active (node, { open0 }));
1171  	auto vote3 = nano::test::make_vote (rep2, { open1 });
1172  	node.vote_processor.vote (vote3, nano::test::fake_channel (node));
1173  	ASSERT_NEVER (1s, nano::test::active (node, { open1 }));
1174  	ASSERT_EQ (node.active.size (), 1);
1175  	auto vote4 = nano::test::make_final_vote (nano::dev::genesis_key, { open0 });
1176  	node.vote_processor.vote (vote4, nano::test::fake_channel (node));
1177  	ASSERT_TIMELY (5s, nano::test::confirmed (node, { open0 }));
1178  	ASSERT_TIMELY (5s, nano::test::active (node, { open1 }));
1179  	ASSERT_EQ (0, node.stats.count (nano::stat::type::active_dropped, nano::stat::detail::normal));
1180  }
1181  TEST (active_transactions, allow_limited_overflow)
1182  {
1183  	nano::test::system system;
1184  	nano::node_config config = system.default_config ();
1185  	const int aec_limit = 20;
1186  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1187  	config.active_elections_size = aec_limit;
1188  	config.active_elections_hinted_limit_percentage = 20; 
1189  	auto & node = *system.add_node (config);
1190  	auto blocks = nano::test::setup_independent_blocks (system, node, aec_limit * 4);
1191  	std::vector<std::shared_ptr<nano::block>> blocks1 (blocks.begin (), blocks.begin () + blocks.size () / 2);
1192  	std::vector<std::shared_ptr<nano::block>> blocks2 (blocks.begin () + blocks.size () / 2, blocks.end ());
1193  	WAIT (1s);
1194  	node.active.clear ();
1195  	ASSERT_TRUE (node.active.empty ());
1196  	for (auto const & block : blocks1)
1197  	{
1198  		node.scheduler.buckets.activate (block->account (), node.store.tx_begin_read ());
1199  	}
1200  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit ());
1201  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit ());
1202  	for (auto const & block : blocks2)
1203  	{
1204  		auto vote = nano::test::make_vote (nano::dev::genesis_key, { block });
1205  		node.inactive_vote_cache.vote (block->hash (), vote);
1206  	}
1207  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit () + node.active.limit (nano::election_behavior::hinted));
1208  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit () + node.active.limit (nano::election_behavior::hinted));
1209  }
1210  TEST (active_transactions, allow_limited_overflow_adapt)
1211  {
1212  	nano::test::system system;
1213  	nano::node_config config = system.default_config ();
1214  	const int aec_limit = 20;
1215  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1216  	config.active_elections_size = aec_limit;
1217  	config.active_elections_hinted_limit_percentage = 20; 
1218  	auto & node = *system.add_node (config);
1219  	auto blocks = nano::test::setup_independent_blocks (system, node, aec_limit * 4);
1220  	std::vector<std::shared_ptr<nano::block>> blocks1 (blocks.begin (), blocks.begin () + blocks.size () / 2);
1221  	std::vector<std::shared_ptr<nano::block>> blocks2 (blocks.begin () + blocks.size () / 2, blocks.end ());
1222  	WAIT (1s);
1223  	node.active.clear ();
1224  	ASSERT_TRUE (node.active.empty ());
1225  	for (auto const & block : blocks2)
1226  	{
1227  		auto vote = nano::test::make_vote (nano::dev::genesis_key, { block });
1228  		node.inactive_vote_cache.vote (block->hash (), vote);
1229  	}
1230  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit (nano::election_behavior::hinted));
1231  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit (nano::election_behavior::hinted));
1232  	for (auto const & block : blocks1)
1233  	{
1234  		node.scheduler.buckets.activate (block->account (), node.store.tx_begin_read ());
1235  	}
1236  	ASSERT_TIMELY_EQ (5s, node.active.size (), node.active.limit ());
1237  	ASSERT_ALWAYS (1s, node.active.size () == node.active.limit ());
1238  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-compressed_tuple_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.cpp</div>
                </div>
                <div class="column column_space"><pre><code>56    CompressedTuple<CopyableMovableInstance> x1(std::move(i1));
57    EXPECT_EQ(tracker.instances(), 2);
58    EXPECT_EQ(tracker.copies(), 0);
59    EXPECT_LE(tracker.moves(), 1);
60    EXPECT_EQ(x1.get<0>().value(), 1);
61  }
62  TEST(CompressedTupleTest, OneMoveOnRValueConstructionMixedTypes) {
63    InstanceTracker tracker;
64    CopyableMovableInstance i1(1);
</pre></code></div>
                <div class="column column_space"><pre><code>490  	ASSERT_EQ (nano::vote_code::replay, node.active.vote (vote2_send2));
491  	{
492  		nano::lock_guard<nano::mutex> guard (node.active.mutex);
493  		node.active.recently_confirmed.clear ();
494  	}
495  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_send1));
496  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote_open1));
497  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote1_send2));
498  	ASSERT_EQ (nano::vote_code::indeterminate, node.active.vote (vote2_send2));
499  }
500  }
501  TEST (active_transactions, dropped_cleanup)
502  {
503  	nano::test::system system;
504  	nano::node_flags flags;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    