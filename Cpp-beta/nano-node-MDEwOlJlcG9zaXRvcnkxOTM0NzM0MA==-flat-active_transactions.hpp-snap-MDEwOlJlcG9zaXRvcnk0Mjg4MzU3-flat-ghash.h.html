
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 32.57766582703611%, Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/numbers.hpp>
3  #include <nano/node/election.hpp>
4  #include <nano/node/election_insertion_result.hpp>
5  #include <nano/node/voting.hpp>
6  #include <nano/secure/common.hpp>
7  #include <boost/multi_index/hashed_index.hpp>
8  #include <boost/multi_index/member.hpp>
9  #include <boost/multi_index/random_access_index.hpp>
10  #include <boost/multi_index/sequenced_index.hpp>
11  #include <boost/multi_index_container.hpp>
12  #include <atomic>
13  #include <condition_variable>
14  #include <deque>
15  #include <memory>
16  #include <unordered_map>
17  namespace mi = boost::multi_index;
18  namespace nano
19  {
20  class node;
21  class active_transactions;
22  class block;
23  class block_sideband;
24  class election;
25  class vote;
26  class transaction;
27  class confirmation_height_processor;
28  class stats;
29  namespace scheduler
30  {
31  	class buckets;
32  }
33  class recently_confirmed_cache final
34  {
35  public:
<span onclick='openModal()' class='match'>36  	using entry_t = std::pair<nano::qualified_root, nano::block_hash>;
37  	explicit recently_confirmed_cache (std::size_t max_size);
38  	void put (nano::qualified_root const &, nano::block_hash const &);
39  	void erase (nano::block_hash const &);
40  	void clear ();
41  	std::size_t size () const;
42  	bool exists (nano::qualified_root const &) const;
43  	bool exists (nano::block_hash const &) const;
44  public: 
45  	entry_t back () const;
</span>46  private:
47  	class tag_root {};
48  	class tag_hash {};
49  	using ordered_recent_confirmations = boost::multi_index_container<entry_t,
50  	mi::indexed_by<
51  		mi::sequenced<mi::tag<tag_sequence>>,
52  		mi::hashed_unique<mi::tag<tag_root>,
53  			mi::member<entry_t, nano::qualified_root, &entry_t::first>>,
54  		mi::hashed_unique<mi::tag<tag_hash>,
55  			mi::member<entry_t, nano::block_hash, &entry_t::second>>>>;
56  	ordered_recent_confirmations confirmed;
57  	std::size_t const max_size;
58  	mutable nano::mutex mutex;
59  public: 
60  	std::unique_ptr<container_info_component> collect_container_info (std::string const &);
61  };
62  class recently_cemented_cache final
63  {
64  public:
65  	using queue_t = std::deque<nano::election_status>;
66  	explicit recently_cemented_cache (std::size_t max_size);
67  	void put (nano::election_status const &);
68  	queue_t list () const;
69  	std::size_t size () const;
70  private:
71  	queue_t cemented;
72  	std::size_t const max_size;
73  	mutable nano::mutex mutex;
74  public: 
75  	std::unique_ptr<container_info_component> collect_container_info (std::string const &);
76  };
77  class active_transactions final
78  {
79  private: 
80  	class conflict_info final
81  	{
82  	public:
83  		nano::qualified_root root;
84  		std::shared_ptr<nano::election> election;
85  	};
86  	friend class nano::election;
87  	class tag_account {};
88  	class tag_root {};
89  	class tag_sequenced {};
90  	class tag_uncemented {};
91  	class tag_arrival {};
92  	class tag_hash {};
93  	using ordered_roots = boost::multi_index_container<conflict_info,
94  	mi::indexed_by<
95  		mi::sequenced<mi::tag<tag_sequenced>>,
96  		mi::hashed_unique<mi::tag<tag_root>,
97  			mi::member<conflict_info, nano::qualified_root, &conflict_info::root>>
98  	>>;
99  	ordered_roots roots;
100  	std::unordered_map<nano::block_hash, std::shared_ptr<nano::election>> blocks;
101  public:
102  	active_transactions (nano::node &, nano::confirmation_height_processor &);
103  	~active_transactions ();
104  	void start ();
105  	void stop ();
106  	nano::election_insertion_result insert (std::shared_ptr<nano::block> const & block, nano::election_behavior behavior = nano::election_behavior::normal);
107  	nano::vote_code vote (std::shared_ptr<nano::vote> const &);
108  	bool active (nano::block const &) const;
109  	bool active (nano::qualified_root const &) const;
110  	bool active (nano::block_hash const &) const;
111  	std::shared_ptr<nano::election> election (nano::qualified_root const &) const;
112  	std::shared_ptr<nano::block> winner (nano::block_hash const &) const;
113  	std::vector<std::shared_ptr<nano::election>> list_active (std::size_t = std::numeric_limits<std::size_t>::max ());
114  	void erase (nano::block const &);
115  	void erase_hash (nano::block_hash const &);
116  	void erase_oldest ();
117  	bool empty () const;
118  	std::size_t size () const;
119  	bool publish (std::shared_ptr<nano::block> const &);
120  	boost::optional<nano::election_status_type> confirm_block (nano::transaction const &, std::shared_ptr<nano::block> const &);
121  	void block_cemented_callback (std::shared_ptr<nano::block> const &);
122  	void block_already_cemented_callback (nano::block_hash const &);
123  	int64_t limit (nano::election_behavior behavior = nano::election_behavior::normal) const;
124  	int64_t vacancy (nano::election_behavior behavior = nano::election_behavior::normal) const;
125  	std::function<void ()> vacancy_update{ [] () {} };
126  	std::size_t election_winner_details_size ();
127  	void add_election_winner_details (nano::block_hash const &, std::shared_ptr<nano::election> const &);
128  	void remove_election_winner_details (nano::block_hash const &);
129  private:
130  	void trim ();
131  	nano::election_insertion_result insert_impl (nano::unique_lock<nano::mutex> &, std::shared_ptr<nano::block> const &, nano::election_behavior = nano::election_behavior::normal, std::function<void (std::shared_ptr<nano::block> const &)> const & = nullptr);
132  	void request_loop ();
133  	void request_confirm (nano::unique_lock<nano::mutex> &);
134  	void erase (nano::qualified_root const &);
135  	void cleanup_election (nano::unique_lock<nano::mutex> & lock_a, std::shared_ptr<nano::election>);
136  	nano::stat::type completion_type (nano::election const & election) const;
137  	std::vector<std::shared_ptr<nano::election>> list_active_impl (std::size_t) const;
138  	void add_inactive_vote_cache (nano::block_hash const & hash, std::shared_ptr<nano::vote> vote);
139  private: 
140  	nano::confirmation_height_processor & confirmation_height_processor;
141  	nano::node & node;
142  public:
143  	recently_confirmed_cache recently_confirmed;
144  	recently_cemented_cache recently_cemented;
145  	mutable nano::mutex mutex{ mutex_identifier (mutexes::active) };
146  private:
147  	nano::mutex election_winner_details_mutex{ mutex_identifier (mutexes::election_winner_details) };
148  	std::unordered_map<nano::block_hash, std::shared_ptr<nano::election>> election_winner_details;
149  	std::chrono::seconds const election_time_to_live;
150  	nano::enum_array<nano::election_behavior, int64_t> count_by_behavior;
151  	nano::condition_variable condition;
152  	bool stopped{ false };
153  	std::thread thread;
154  	friend class election;
155  	friend std::unique_ptr<container_info_component> collect_container_info (active_transactions &, std::string const &);
156  public: 
157  	void clear ();
158  	friend class node_fork_storm_Test;
159  	friend class system_block_sequence_Test;
160  	friend class node_mass_block_new_Test;
161  	friend class active_transactions_vote_replays_Test;
162  	friend class frontiers_confirmation_prioritize_frontiers_Test;
163  	friend class frontiers_confirmation_prioritize_frontiers_max_optimistic_elections_Test;
164  	friend class confirmation_height_prioritize_frontiers_overwrite_Test;
165  	friend class active_transactions_confirmation_consistency_Test;
166  	friend class node_deferred_dependent_elections_Test;
167  	friend class active_transactions_pessimistic_elections_Test;
168  	friend class frontiers_confirmation_expired_optimistic_elections_removal_Test;
169  };
170  std::unique_ptr<container_info_component> collect_container_info (active_transactions & active_transactions, std::string const & name);
171  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ghash.h</h3>
            <pre><code>1  class TGraphKey {
2  public:
3    static const int RoundTo;
4  private:
5  public:
6    TInt Nodes;
7    TIntPrV EdgeV;  
8    TFltV SigV;     
9    TInt VariantId; 
10  public:
11    TGraphKey() : Nodes(-1), EdgeV(), SigV(), VariantId(0) { }
12    TGraphKey(const TSFltV& GraphSigV);
13    TGraphKey(const TIntV& GraphSigV);
14    TGraphKey(const TFltV& GraphSigV);
15    TGraphKey(const TGraphKey& GraphKey);
16    TGraphKey(TSIn& SIn);
17    void Save(TSOut& SOut) const;
18    TGraphKey& operator = (const TGraphKey& GraphKey);
19    bool operator == (const TGraphKey& GraphKey) const { return SigV==GraphKey.SigV && VariantId==GraphKey.VariantId; }
20    int GetPrimHashCd() const { return abs(SigV.GetPrimHashCd() ^ VariantId); }
21    int GetSecHashCd() const { return abs(SigV.GetSecHashCd() ^ VariantId<<8); }
22    int GetNodes() const { return Nodes; }
23    int GetEdges() const { return EdgeV.Len(); }
24    int GetSigLen() const { return SigV.Len(); }
25    int GetVariant() const { return VariantId; }
26    void SetVariant(const int& Variant) { VariantId = Variant; }
27    void SetEdgeV(const TIntPrV& EdgeIdV) { EdgeV = EdgeIdV; }
28    PNGraph GetNGraph() const;
29    void TakeGraph(const PNGraph& Graph);
30    void TakeGraph(const PNGraph& Graph, TIntPrV& NodeMap);
31    void TakeSig(const PNGraph& Graph, const int& MnSvdGraph, const int& MxSvdGraph);
32    void SaveTxt(FILE *F) const;
33    void SaveGViz(const TStr& OutFNm, const TStr& Desc = TStr(), const TStr& NodeAttrs="", const int& Size=-1) const;
34    void DrawGViz(const TStr& OutFNm, const TStr& Desc = TStr(), const TStr& NodeAttrs="", const int& Size=-1) const;
35    static bool IsIsomorph(const TGraphKey& Key1, const TGraphKey& Key2, const TIntV& NodeIdMap);
36    static bool IsIsomorph(const TGraphKey& Key1, const TGraphKey& Key2, const TVec<TIntV>& NodeIdMapV);
37    static bool IsIsomorph(const TGraphKey& Key1, const TGraphKey& Key2, const TVec<TIntV>& NodeIdMapV, int& IsoPermId);
38  };
39  template <class TDat>
40  class TGHash {
41  public:
42    typedef typename THash<TGraphKey, TDat>::TIter TIter;
43  private:
44    TInt MxIsoCheck;     
45    TInt MxSvdGraph;     
46    THash<TInt, TVec<TIntV> > GSzToPermH; 
47    TBool HashOnlyTrees; 
48    THash<TGraphKey, TDat> GraphH;
49  private:
50    void InitPermutations();
51    int IsGetKeyId(const PNGraph& Graph) const;
52    int IsGetKeyId(const PNGraph& Graph, TGraphKey& GKey) const;
53    int IsGetKeyId(const PNGraph& Graph, TGraphKey& GKey, TIntPrV& NodeMap) const;
54  public:
55    TGHash(const bool& HashTrees, const int& MaxIsoCheck=8, const int& MaxSvdGraph=500);
56    TGHash(TSIn& SIn);
57    void Save(TSOut& SOut) const;
58    const TDat& operator [] (const int& KeyId) const { return GraphH[KeyId]; }
59    TDat& operator [] (const int& KeyId) { return GraphH[KeyId]; }
60    const TDat& operator () (const TGraphKey& Key) const { return GraphH.GetDat(Key); }
61    TDat& operator () (const TGraphKey& Key) { return GraphH.GetDat(Key); }
62    TIter BegI() const { return GraphH.BegI(); }
63    TIter EndI() const { return GraphH.EndI(); }
64    TIter GetI(const int& KeyId) const  { return GraphH.GetI(KeyId); }
65    bool HashTrees() const { return HashOnlyTrees; }
66    void Gen(const int& ExpectVals) { GraphH.Gen(ExpectVals); }
67    void Clr(const bool& DoDel=true, const int& NoDelLim=-1) { GraphH.Clr(DoDel, NoDelLim); }
68    bool Empty() const { return GraphH.Empty(); }
69    int Len() const {  return GraphH.Len(); }
70    int GetPorts() const { return GraphH.GetPorts(); }
71    bool IsAutoSize() const { return GraphH.IsAutoSize(); }
72    int GetMxKeyIds() const { return GraphH.GetMxKeyIds(); }
73    bool IsKeyIdEqKeyN() const { return GraphH.IsKeyIdEqKeyN(); }
74    int AddKey(const PNGraph& Graph);
75    TDat& AddDat(const PNGraph& Graph) { return GraphH[AddKey(Graph)]; }
76    TDat& AddDat(const PNGraph& Graph, const TDat& Dat) { return GraphH[AddKey(Graph)] = Dat; }
77    bool IsKey(const PNGraph& Graph) const { int k=IsGetKeyId(Graph); return k!=-1; }
78    int GetKeyId(const PNGraph& Graph) const { return IsGetKeyId(Graph); }
79    const TDat& GetDat(const PNGraph& Graph) const { return GraphH[GetKeyId(Graph)]; }
80    TDat& GetDat(const PNGraph& Graph) { return GraphH[GetKeyId(Graph)]; }
81    const TGraphKey& GetKey(const int& KeyId) const { return GraphH.GetKey(KeyId); }
82    int GetKeyId(const TGraphKey& Key) const { return GraphH.GetKeyId(Key); }
83    bool IsKey(const TGraphKey& Key) const { return GraphH.IsKey(Key); }
84    bool IsKey(const TGraphKey& Key, int& KeyId) const { return GraphH.IsKey(Key, KeyId); }
85    bool IsKeyId(const int& KeyId) const { return GraphH.IsKeyId(KeyId); }
86    const TDat& GetDat(const TGraphKey& Key) const { return GraphH.GetDat(Key); }
87    TDat& GetDat(const TGraphKey& Key) { return GraphH.GetDat(Key); }
88    const TDat& GetDatId(const int& KeyId) const { return GraphH[KeyId]; }
89    TDat& GetDatId(const int& KeyId) { return GraphH[KeyId]; }
90    void GetKeyDat(const int& KeyId, TGraphKey& Key, TDat& Dat) const { GraphH.GetKeyDat(KeyId, Key, Dat); }
91    bool IsKeyGetDat(const TGraphKey& Key, TDat& Dat) const { return GraphH.IsKeyGetDat(Key, Dat); }
92    bool GetNodeMap(const PNGraph& Graph, TIntPrV& NodeMapV) const;
93    bool GetNodeMap(const PNGraph& Graph, TIntPrV& NodeMapV, int& KeyId) const;
94    int FFirstKeyId() const { return 0-1; }
95    bool FNextKeyId(int& KeyId) const { return GraphH.FNextKeyId(KeyId); }
96    void GetKeyV(TVec<TGraphKey>& KeyV) const { GraphH.GetKeyV(KeyV); }
97    void GetDatV(TVec<TDat>& DatV) const { GraphH.GetDatV(DatV); }
98    void GetKeyIdByDat(TIntV& KeyIdV, const bool& Asc = true) const;
99    void GetKeyIdByGSz(TIntV& KeyIdV, const bool& Asc = true) const;
100    void GetKeyDatPrV(TVec<TPair<TGraphKey, TDat> >& KeyDatPrV) const { GraphH.GetKeyDatPrV(KeyDatPrV); }
101    void GetDatKeyPrV(TVec<TPair<TDat, TGraphKey> >& DatKeyPrV) const { GraphH.GetDatKeyPrV(DatKeyPrV); }
102    void Defrag() { GraphH.Defrag(); }
103    void Pack() { GraphH.Pack(); }
104    void DrawGViz(const int& KeyId, const TStr& OutFNmPref, const TStr& OutputType = "gif", TStr Desc="") const;
105    void DrawGViz(const TIntV& KeyIdV, const TStr& OutFNmPref, const TStr& OutputType = "gif") const;
106    void SaveTxt(const TStr& OutFNm, const TStr& Desc, const TStr& DatColNm, const bool& SortByKeyVal=true) const;
107    void SaveDetailTxt(const TStr& OutFNm, const TStr& Desc, const TStr& DatColNm) const;
108  };
109  template <class TDat>
110  void TGHash<TDat>::InitPermutations() {
111    GSzToPermH.Clr();
112    for (int nodes = 2; nodes <= MxIsoCheck; nodes++) {
113      TVec<TIntV> NodePermutationV;
114      TIntV NodeIdV(nodes, 0);
115      for (int i = 0; i < nodes; i++)  NodeIdV.Add(i);
116      NodeIdV.Pack();
117      NodePermutationV.Add(NodeIdV);
118      while (NodeIdV.NextPerm()) {
119        NodePermutationV.Add(NodeIdV);
120      }
121      NodePermutationV.Pack();
122      GSzToPermH.AddDat(nodes, NodePermutationV);
123    }
124  }
125  template <class TDat>
126  TGHash<TDat>::TGHash(const bool& HashTrees, const int& MaxIsoCheck, const int& MaxSvdGraph) :
127   MxIsoCheck(MaxIsoCheck), MxSvdGraph(MaxSvdGraph), GSzToPermH(), HashOnlyTrees(HashTrees), GraphH() {
128    if (! HashTrees) {
129      InitPermutations();
130    }
131  }
132  template <class TDat>
133  TGHash<TDat>::TGHash(TSIn& SIn) : MxIsoCheck(SIn), MxSvdGraph(SIn), GSzToPermH(), HashOnlyTrees(SIn), GraphH(SIn) {
134    if (! HashOnlyTrees) {
135      InitPermutations();
136    }
137  }
138  template <class TDat>
139  void TGHash<TDat>::Save(TSOut& SOut) const {
140    MxIsoCheck.Save(SOut);
141    MxSvdGraph.Save(SOut);
142    HashOnlyTrees.Save(SOut);
143    GraphH.Save(SOut);
144  }
145  template <class TDat>
146  int TGHash<TDat>::AddKey(const PNGraph& Graph) {
147    if (HashOnlyTrees) {
148      int RootNId;  IAssert(TSnap::IsTree(Graph, RootNId));
149      TIntV TreeSig;  TSnap::GetTreeSig(Graph, RootNId, TreeSig);
150      TGraphKey GKey(TreeSig);
151      const int KeyId = GraphH.GetKeyId(GKey);
152      if (KeyId == -1) {
153        GKey.TakeGraph(Graph);
154        return GraphH.AddKey(GKey);
155      }
156      return KeyId;
157    } else {
158      TGraphKey GKey;
159      GKey.TakeSig(Graph, MxIsoCheck+1, MxSvdGraph); 
160      const int Nodes = GKey.GetNodes();
161      if (Nodes > 2 && Nodes <= MxIsoCheck) {
162        GKey.TakeGraph(Graph);
163        for (int variant = 1; ; variant++) {
164          GKey.SetVariant(variant);
165          int KeyId = GraphH.GetKeyId(GKey);
166          if (KeyId == -1) { 
167            KeyId = GraphH.AddKey(GKey);
168            return KeyId;
169          }
170          if (TGraphKey::IsIsomorph(GKey, GraphH.GetKey(KeyId), GSzToPermH.GetDat(Nodes))) { 
171            return KeyId;  
172          }
173        }
174      } else {
175        const int KeyId = GraphH.GetKeyId(GKey);
176        if (KeyId == -1) {
177          GKey.TakeGraph(Graph);
178          return GraphH.AddKey(GKey);
179        }
180        return KeyId;
181      }
182    }
183    Fail;
184    return -1;
185  }
186  template <class TDat>
187  int TGHash<TDat>::IsGetKeyId(const PNGraph& Graph) const {
188    TGraphKey GKey;
189    return IsGetKeyId(Graph, GKey);
190  }
191  template <class TDat>
192  int TGHash<TDat>::IsGetKeyId(const PNGraph& Graph, TGraphKey& GKey) const {
193    if (HashOnlyTrees) {
194      int RootNId;  IAssert(TSnap::IsTree(Graph, RootNId));
195      TIntV TreeSig;  TSnap::GetTreeSig(Graph, RootNId, TreeSig);
196      GKey = TGraphKey(TreeSig);
197      const int KeyId = GraphH.GetKeyId(GKey);
198      return KeyId;
199    } else {
200      GKey.TakeSig(Graph, MxIsoCheck+1, MxSvdGraph);
201      const int Nodes = GKey.GetNodes();
202      if (Nodes > 2 && Nodes <= MxIsoCheck) {
203        GKey.TakeGraph(Graph);
204        for (int variant = 1; ; variant++) {
205          GKey.SetVariant(variant);
206          int KeyId = GraphH.GetKeyId(GKey); 
207          if (KeyId == -1) { return -1; }
208          if (TGraphKey::IsIsomorph(GKey, GraphH.GetKey(KeyId), GSzToPermH.GetDat(Nodes))) { return KeyId; } 
209        }
210      } else {
211        const int KeyId = GraphH.GetKeyId(GKey);
212        return KeyId;
213      }
214    }
215    Fail;
216    return -1;
217  }
218  template <class TDat>
219  bool TGHash<TDat>::GetNodeMap(const PNGraph& Graph, TIntPrV& NodeMapV) const {
220    int KeyId;
221    return GetNodeMap(Graph, NodeMapV, KeyId);
222  }
223  template <class TDat>
224  bool TGHash<TDat>::GetNodeMap(const PNGraph& Graph, TIntPrV& NodeMapV, int& KeyId) const {
225    NodeMapV.Clr(false);
226    if (HashOnlyTrees) {
227      int RootNId;  IAssert(TSnap::IsTree(Graph, RootNId));
228      TIntV TreeSig;  TSnap::GetTreeSig(Graph, RootNId, TreeSig, NodeMapV);
229      TGraphKey GKey(TreeSig);
230      KeyId = GraphH.GetKeyId(GKey);
231      return KeyId != -1;
232    } else {
233      const int Nodes = Graph->GetNodes();
234      int IsoPermId = -1;
235      NodeMapV.Clr(false);
236      if (Nodes == 0) { return true; }
237      else if (Nodes == 1) {
238        NodeMapV.Add(TIntPr(Graph->BegNI().GetId(), 0));  return true; }
239      else if (Nodes <= MxIsoCheck) {
240        TGraphKey GKey;
241        GKey.TakeSig(Graph, MxIsoCheck+1, MxSvdGraph);
242        GKey.TakeGraph(Graph, NodeMapV);
243        for (int variant = 1; ; variant++) {
244          GKey.SetVariant(variant);
245          KeyId = GraphH.GetKeyId(GKey);
246          if (KeyId == -1) { return false; }
247          if (TGraphKey::IsIsomorph(GKey, GraphH.GetKey(KeyId), GSzToPermH.GetDat(Nodes), IsoPermId)) {
248            const TIntV& K1K2Perm = GSzToPermH.GetDat(Nodes)[IsoPermId];
249            for  (int i = 0; i < NodeMapV.Len(); i++) {
250              NodeMapV[i].Val2 = K1K2Perm[NodeMapV[i].Val2]; }
251            return true;
252          }
253        }
254        return false;
255      } else {
256        return false; 
257      }
258    }
259    Fail;
260    return false;
261  }
262  template <class TDat>
263  void TGHash<TDat>::GetKeyIdByDat(TIntV& KeyIdV, const bool& Asc) const {
264    TVec<TQuad<TDat, TInt,TInt, TInt> > DatKeyIdV(Len(), 0); 
265    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
266      DatKeyIdV.Add(TQuad<TDat, TInt,TInt, TInt>(GetDatId(i), GetKey(i).GetNodes(), GetKey(i).GetEdges(), i));
267    }
268    DatKeyIdV.Sort(Asc);
269    KeyIdV.Gen(Len(), 0);
270    for (int i = 0; i < Len(); i++) {
271      KeyIdV.Add(DatKeyIdV[i].Val4);
272    }
273  }
274  template <class TDat>
275  void TGHash<TDat>::GetKeyIdByGSz(TIntV& KeyIdV, const bool& Asc) const {
276    TVec<TQuad<TInt,TInt, TDat, TInt> > DatKeyIdV(Len(), 0); 
277    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
278      DatKeyIdV.Add(TQuad< TInt,TInt, TDat, TInt>(GetKey(i).GetNodes(), GetKey(i).GetEdges(), GetDatId(i), i));
279    }
280    DatKeyIdV.Sort(Asc);
281    KeyIdV.Gen(Len(), 0);
282    for (int i = 0; i < Len(); i++) {
283      KeyIdV.Add(DatKeyIdV[i].Val4);
284    }
285  }
286  template <class TDat>
287  void TGHash<TDat>::DrawGViz(const int& KeyId, const TStr& OutFNmPref, const TStr& OutputType, TStr Desc) const {
288    IAssert(OutputType == "ps" || OutputType == "gif" || OutputType == "png");
289    const TGraphKey& GKey = GetKey(KeyId);
290    const TStr Desc1 = TStr::Fmt("%s (%d, %d)", Desc.CStr(), GKey.GetNodes(), GKey.GetEdges());
291    GKey.SaveGViz(OutFNmPref+".dot", Desc1);
292    TSnap::TSnapDetail::GVizDoLayout(OutFNmPref+".dot", OutFNmPref+"."+OutputType, gvlDot);
293  }
294  template <class TDat>
295  void TGHash<TDat>::DrawGViz(const TIntV& KeyIdV, const TStr& OutFNmPref, const TStr& OutputType) const {
296    IAssert(OutputType == "ps" || OutputType == "gif" || OutputType == "png");
297    TExeTm ExeTm;
298    printf("Plotting %d graphs\n", KeyIdV.Len());
299    for (int i = 0; i < KeyIdV.Len(); i++) {
300      const TStr FNm = TStr::Fmt("%s.%03d.key%d.", OutFNmPref.CStr(), i+1, KeyIdV[i]());
301      const TStr Desc = TStr::Fmt("KeyId:%d", KeyIdV[i]());
302      const TGraphKey& GKey = GetKey(KeyIdV[i]);
303      printf("\r  %d  g(%d, %d)    ", i, GKey.GetNodes(), GKey.GetEdges());
304      GKey.SaveGViz(FNm+"dot", Desc);
305      TSnap::TSnapDetail::GVizDoLayout(FNm+"dot", FNm+OutputType, gvlDot);
306    }
307    printf("done [%s].\n", ExeTm.GetTmStr());
308  }
309  template <class TDat>
310  void TGHash<TDat>::SaveTxt(const TStr& OutFNm, const TStr& Desc, const TStr& DatColNm, const bool& SortByKeyVal) const {
311    TIntV KeyIdV;
312    if (SortByKeyVal) GetKeyIdByDat(KeyIdV, false);
313    else GetKeyIdByGSz(KeyIdV, true);
314    FILE *F = fopen(OutFNm.CStr(), "wt");
315    fprintf(F, "Graph-Hash-Table");
316    fprintf(F, "%s\n", Desc.CStr());
317    fprintf(F, "%d graphs\n", KeyIdV.Len());
318    fprintf(F, "Rank\tKeyId\tNodes\tEdges\t%s\n", DatColNm.CStr());
319    for (int i = 0; i < KeyIdV.Len(); i++) {
320      const TGraphKey& Key = GetKey(KeyIdV[i]);
321      fprintf(F, "%d\t%d\t%d\t%d\t%s\n", i+1, KeyIdV[i](), Key.GetNodes(), Key.GetEdges(),
322        GetDatId(KeyIdV[i]).GetStr().CStr());
323    }
324    fclose(F);
325  }
326  template <class TDat>
327  void TGHash<TDat>::SaveDetailTxt(const TStr& OutFNm, const TStr& Desc, const TStr& DatColNm) const {
328    TIntV KeyIdV;  GetKeyIdByDat(KeyIdV, false);
329    FILE *F = fopen(OutFNm.CStr(), "wt");
330    fprintf(F, "Graph-Hash-Table\n");
331    fprintf(F, "%s\n", Desc.CStr());
332    fprintf(F, "%d graphs", KeyIdV.Len());
333    for (int i = 0; i < KeyIdV.Len(); i++) {
334      fprintf(F, "\n\n[%5d]\tRank: %d\n", KeyIdV[i](), i+1);
335      fprintf(F, "Dat:  %s\n", GetDat(KeyIdV[i]).GetStr().CStr());
336      GetDatId(KeyIdV[i]).SaveTxt(F);
337    }
338    fclose(F);
339  }
340  class TSimpleGraph {
341  private:
342    TIntPrV EdgeV;
343  public:
344    TSimpleGraph() { }
345    TSimpleGraph(const TIntPrV& GEdgeV) : EdgeV(GEdgeV) { }
346    bool operator == (const TSimpleGraph& Graph) const { return EdgeV == Graph.EdgeV; }
347    bool operator < (const TSimpleGraph& Graph) const { return EdgeV < Graph.EdgeV; }
348    int GetEdges() const { return EdgeV.Len(); }
349    void AddEdge(const int& SrcNId, const int& DstNId) { EdgeV.Add(TIntPr(SrcNId, DstNId)); }
350    bool Join(const TSimpleGraph& G1, const TSimpleGraph& G2);
351    TIntPrV& GetEdgeV() { return EdgeV; }
352    TIntPrV& operator () () { return EdgeV; }
353    void Dump(const TStr& Desc = TStr()) const;
354  };
355  typedef TVec<TSimpleGraph> TSimpleGraphV;
356  class TSubGraphsEnum {
357  private:
358    TSimpleGraphV SgV, NextSgV;
359    THash<TIntPr, TIntH> EdgeH;
360    PNGraph NGraph;
361  public:
362    TSubGraphsEnum(PNGraph Graph) : NGraph(Graph) { }
<span onclick='openModal()' class='match'>363    void Gen2Graphs();
364    void EnumSubGraphs(const int& MaxEdges);
365    void RecurBfs(const int& MxDepth);
366    void RecurBfs(const int& NId, const int& Depth, TSimpleGraph& PrevG);
367    void RecurBfs1(const int& MxDepth);
368    void RecurBfs1(const int& NId, const int& Depth);
</span>369  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-active_transactions.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ghash.h</div>
                </div>
                <div class="column column_space"><pre><code>36  	using entry_t = std::pair<nano::qualified_root, nano::block_hash>;
37  	explicit recently_confirmed_cache (std::size_t max_size);
38  	void put (nano::qualified_root const &, nano::block_hash const &);
39  	void erase (nano::block_hash const &);
40  	void clear ();
41  	std::size_t size () const;
42  	bool exists (nano::qualified_root const &) const;
43  	bool exists (nano::block_hash const &) const;
44  public: 
45  	entry_t back () const;
</pre></code></div>
                <div class="column column_space"><pre><code>363    void Gen2Graphs();
364    void EnumSubGraphs(const int& MaxEdges);
365    void RecurBfs(const int& MxDepth);
366    void RecurBfs(const int& NId, const int& Depth, TSimpleGraph& PrevG);
367    void RecurBfs1(const int& MxDepth);
368    void RecurBfs1(const int& NId, const int& Depth);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    