
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.3401499659168374%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_cat_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_cat.h"
2  #include <cstdint>
3  #include <string>
4  #include <vector>
5  #include "gtest/gtest.h"
6  #include "absl/strings/str_format.h"
7  #include "absl/strings/substitute.h"
8  #ifdef __ANDROID__
9  #define ABSL_EXPECT_DEBUG_DEATH(statement, regex) \
10    EXPECT_DEBUG_DEATH(statement, ".*")
11  #else
12  #define ABSL_EXPECT_DEBUG_DEATH(statement, regex) \
13    EXPECT_DEBUG_DEATH(statement, regex)
14  #endif
15  namespace {
16  TEST(StrCat, Ints) {
17    const short s = -1;  
18    const uint16_t us = 2;
19    const int i = -3;
20    const unsigned int ui = 4;
21    const long l = -5;                 
22    const unsigned long ul = 6;        
23    const long long ll = -7;           
24    const unsigned long long ull = 8;  
25    const ptrdiff_t ptrdiff = -9;
26    const size_t size = 10;
27    const intptr_t intptr = -12;
28    const uintptr_t uintptr = 13;
29    std::string answer;
30    answer = absl::StrCat(s, us);
31    EXPECT_EQ(answer, "-12");
32    answer = absl::StrCat(i, ui);
33    EXPECT_EQ(answer, "-34");
34    answer = absl::StrCat(l, ul);
35    EXPECT_EQ(answer, "-56");
36    answer = absl::StrCat(ll, ull);
37    EXPECT_EQ(answer, "-78");
38    answer = absl::StrCat(ptrdiff, size);
39    EXPECT_EQ(answer, "-910");
40    answer = absl::StrCat(ptrdiff, intptr);
41    EXPECT_EQ(answer, "-9-12");
42    answer = absl::StrCat(uintptr, 0);
43    EXPECT_EQ(answer, "130");
44  }
45  TEST(StrCat, Enums) {
46    enum SmallNumbers { One = 1, Ten = 10 } e = Ten;
47    EXPECT_EQ("10", absl::StrCat(e));
48    EXPECT_EQ("-5", absl::StrCat(SmallNumbers(-5)));
49    enum class Option { Boxers = 1, Briefs = -1 };
50    EXPECT_EQ("-1", absl::StrCat(Option::Briefs));
51    enum class Airplane : uint64_t {
52      Airbus = 1,
53      Boeing = 1000,
54      Canary = 10000000000  
55    };
56    EXPECT_EQ("10000000000", absl::StrCat(Airplane::Canary));
57    enum class TwoGig : int32_t {
58      TwoToTheZero = 1,
59      TwoToTheSixteenth = 1 << 16,
60      TwoToTheThirtyFirst = INT32_MIN
61    };
62    EXPECT_EQ("65536", absl::StrCat(TwoGig::TwoToTheSixteenth));
63    EXPECT_EQ("-2147483648", absl::StrCat(TwoGig::TwoToTheThirtyFirst));
64    EXPECT_EQ("-1", absl::StrCat(static_cast<TwoGig>(-1)));
65    enum class FourGig : uint32_t {
66      TwoToTheZero = 1,
67      TwoToTheSixteenth = 1 << 16,
68      TwoToTheThirtyFirst = 1U << 31  
69    };
70    EXPECT_EQ("65536", absl::StrCat(FourGig::TwoToTheSixteenth));
71    EXPECT_EQ("2147483648", absl::StrCat(FourGig::TwoToTheThirtyFirst));
72    EXPECT_EQ("4294967295", absl::StrCat(static_cast<FourGig>(-1)));
73    EXPECT_EQ("10000000000", absl::StrCat(Airplane::Canary));
74  }
75  TEST(StrCat, Basics) {
76    std::string result;
77    std::string strs[] = {"Hello", "Cruel", "World"};
78    std::string stdstrs[] = {
79      "std::Hello",
80      "std::Cruel",
81      "std::World"
82    };
83    absl::string_view pieces[] = {"Hello", "Cruel", "World"};
84    const char* c_strs[] = {
85      "Hello",
86      "Cruel",
87      "World"
88    };
89    int32_t i32s[] = {'H', 'C', 'W'};
90    uint64_t ui64s[] = {12345678910LL, 10987654321LL};
91    EXPECT_EQ(absl::StrCat(), "");
92    result = absl::StrCat(false, true, 2, 3);
93    EXPECT_EQ(result, "0123");
94    result = absl::StrCat(-1);
95    EXPECT_EQ(result, "-1");
96    result = absl::StrCat(absl::SixDigits(0.5));
97    EXPECT_EQ(result, "0.5");
98    result = absl::StrCat(strs[1], pieces[2]);
99    EXPECT_EQ(result, "CruelWorld");
100    result = absl::StrCat(stdstrs[1], " ", stdstrs[2]);
101    EXPECT_EQ(result, "std::Cruel std::World");
102    result = absl::StrCat(strs[0], ", ", pieces[2]);
103    EXPECT_EQ(result, "Hello, World");
104    result = absl::StrCat(strs[0], ", ", strs[1], " ", strs[2], "!");
105    EXPECT_EQ(result, "Hello, Cruel World!");
106    result = absl::StrCat(pieces[0], ", ", pieces[1], " ", pieces[2]);
107    EXPECT_EQ(result, "Hello, Cruel World");
108    result = absl::StrCat(c_strs[0], ", ", c_strs[1], " ", c_strs[2]);
109    EXPECT_EQ(result, "Hello, Cruel World");
110    result = absl::StrCat("ASCII ", i32s[0], ", ", i32s[1], " ", i32s[2], "!");
111    EXPECT_EQ(result, "ASCII 72, 67 87!");
112    result = absl::StrCat(ui64s[0], ", ", ui64s[1], "!");
113    EXPECT_EQ(result, "12345678910, 10987654321!");
114    std::string one =
115        "1";  
116    result = absl::StrCat("And a ", one.size(), " and a ",
117                          &result[2] - &result[0], " and a ", one, " 2 3 4", "!");
118    EXPECT_EQ(result, "And a 1 and a 2 and a 1 2 3 4!");
119    result =
120        absl::StrCat("To output a char by ASCII/numeric value, use +: ", '!' + 0);
121    EXPECT_EQ(result, "To output a char by ASCII/numeric value, use +: 33");
122    float f = 100000.5;
123    result = absl::StrCat("A hundred K and a half is ", absl::SixDigits(f));
124    EXPECT_EQ(result, "A hundred K and a half is 100000");
125    f = 100001.5;
126    result =
127        absl::StrCat("A hundred K and one and a half is ", absl::SixDigits(f));
128    EXPECT_EQ(result, "A hundred K and one and a half is 100002");
129    double d = 100000.5;
130    d *= d;
131    result =
132        absl::StrCat("A hundred K and a half squared is ", absl::SixDigits(d));
133    EXPECT_EQ(result, "A hundred K and a half squared is 1.00001e+10");
134    result = absl::StrCat(1, 2, 333, 4444, 55555, 666666, 7777777, 88888888,
135                          999999999);
136    EXPECT_EQ(result, "12333444455555666666777777788888888999999999");
137  }
138  TEST(StrCat, CornerCases) {
139    std::string result;
140    result = absl::StrCat("");  
141    EXPECT_EQ(result, "");
142    result = absl::StrCat("", "");
143    EXPECT_EQ(result, "");
144    result = absl::StrCat("", "", "");
145    EXPECT_EQ(result, "");
146    result = absl::StrCat("", "", "", "");
147    EXPECT_EQ(result, "");
148    result = absl::StrCat("", "", "", "", "");
149    EXPECT_EQ(result, "");
150  }
151  TEST(StrCat, NullConstCharPtr) {
152    const char* null = nullptr;
153    EXPECT_EQ(absl::StrCat("mon", null, "key"), "monkey");
154  }
155  template <typename T>
156  struct Mallocator {
157    typedef T value_type;
158    typedef size_t size_type;
159    typedef ptrdiff_t difference_type;
160    typedef T* pointer;
161    typedef const T* const_pointer;
162    typedef T& reference;
163    typedef const T& const_reference;
164    size_type max_size() const {
165      return size_t(std::numeric_limits<size_type>::max()) / sizeof(value_type);
166    }
167    template <typename U>
168    struct rebind {
169      typedef Mallocator<U> other;
170    };
171    Mallocator() = default;
172    template <class U>
173    Mallocator(const Mallocator<U>&) {}  
174    T* allocate(size_t n) { return static_cast<T*>(std::malloc(n * sizeof(T))); }
175    void deallocate(T* p, size_t) { std::free(p); }
176  };
177  template <typename T, typename U>
178  bool operator==(const Mallocator<T>&, const Mallocator<U>&) {
179    return true;
180  }
181  template <typename T, typename U>
182  bool operator!=(const Mallocator<T>&, const Mallocator<U>&) {
183    return false;
184  }
185  TEST(StrCat, CustomAllocator) {
186    using mstring =
187        std::basic_string<char, std::char_traits<char>, Mallocator<char>>;
188    const mstring str1("PARACHUTE OFF A BLIMP INTO MOSCONE!!");
189    const mstring str2("Read this book about coffee tables");
190    std::string result = absl::StrCat(str1, str2);
191    EXPECT_EQ(result,
192              "PARACHUTE OFF A BLIMP INTO MOSCONE!!"
193              "Read this book about coffee tables");
194  }
195  TEST(StrCat, MaxArgs) {
196    std::string result;
197    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a");
198    EXPECT_EQ(result, "123456789a");
199    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b");
200    EXPECT_EQ(result, "123456789ab");
201    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c");
202    EXPECT_EQ(result, "123456789abc");
203    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d");
204    EXPECT_EQ(result, "123456789abcd");
205    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e");
206    EXPECT_EQ(result, "123456789abcde");
207    result =
208        absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f");
209    EXPECT_EQ(result, "123456789abcdef");
210    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
211                          "g");
212    EXPECT_EQ(result, "123456789abcdefg");
213    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
214                          "g", "h");
215    EXPECT_EQ(result, "123456789abcdefgh");
216    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
217                          "g", "h", "i");
218    EXPECT_EQ(result, "123456789abcdefghi");
219    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
220                          "g", "h", "i", "j");
221    EXPECT_EQ(result, "123456789abcdefghij");
222    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
223                          "g", "h", "i", "j", "k");
224    EXPECT_EQ(result, "123456789abcdefghijk");
225    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
226                          "g", "h", "i", "j", "k", "l");
227    EXPECT_EQ(result, "123456789abcdefghijkl");
228    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
229                          "g", "h", "i", "j", "k", "l", "m");
230    EXPECT_EQ(result, "123456789abcdefghijklm");
231    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
232                          "g", "h", "i", "j", "k", "l", "m", "n");
233    EXPECT_EQ(result, "123456789abcdefghijklmn");
234    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
235                          "g", "h", "i", "j", "k", "l", "m", "n", "o");
236    EXPECT_EQ(result, "123456789abcdefghijklmno");
237    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
238                          "g", "h", "i", "j", "k", "l", "m", "n", "o", "p");
239    EXPECT_EQ(result, "123456789abcdefghijklmnop");
240    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f",
241                          "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q");
242    EXPECT_EQ(result, "123456789abcdefghijklmnopq");
243    result = absl::StrCat(
244        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "a", "b", "c", "d", "e", "f", "g", "h",
245        "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w",
246        "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L",
247        "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z");
248    EXPECT_EQ(result,
249              "12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
250  }
251  TEST(StrAppend, Basics) {
252    std::string result = "existing text";
253    std::string strs[] = {"Hello", "Cruel", "World"};
254    std::string stdstrs[] = {
255      "std::Hello",
256      "std::Cruel",
257      "std::World"
258    };
259    absl::string_view pieces[] = {"Hello", "Cruel", "World"};
260    const char* c_strs[] = {
261      "Hello",
262      "Cruel",
263      "World"
264    };
265    int32_t i32s[] = {'H', 'C', 'W'};
266    uint64_t ui64s[] = {12345678910LL, 10987654321LL};
267    std::string::size_type old_size = result.size();
268    absl::StrAppend(&result);
269    EXPECT_EQ(result.size(), old_size);
270    old_size = result.size();
271    absl::StrAppend(&result, strs[0]);
272    EXPECT_EQ(result.substr(old_size), "Hello");
273    old_size = result.size();
274    absl::StrAppend(&result, strs[1], pieces[2]);
275    EXPECT_EQ(result.substr(old_size), "CruelWorld");
276    old_size = result.size();
277    absl::StrAppend(&result, stdstrs[0], ", ", pieces[2]);
278    EXPECT_EQ(result.substr(old_size), "std::Hello, World");
279    old_size = result.size();
280    absl::StrAppend(&result, strs[0], ", ", stdstrs[1], " ", strs[2], "!");
281    EXPECT_EQ(result.substr(old_size), "Hello, std::Cruel World!");
282    old_size = result.size();
283    absl::StrAppend(&result, pieces[0], ", ", pieces[1], " ", pieces[2]);
284    EXPECT_EQ(result.substr(old_size), "Hello, Cruel World");
285    old_size = result.size();
286    absl::StrAppend(&result, c_strs[0], ", ", c_strs[1], " ", c_strs[2]);
287    EXPECT_EQ(result.substr(old_size), "Hello, Cruel World");
288    old_size = result.size();
289    absl::StrAppend(&result, "ASCII ", i32s[0], ", ", i32s[1], " ", i32s[2], "!");
290    EXPECT_EQ(result.substr(old_size), "ASCII 72, 67 87!");
291    old_size = result.size();
292    absl::StrAppend(&result, ui64s[0], ", ", ui64s[1], "!");
293    EXPECT_EQ(result.substr(old_size), "12345678910, 10987654321!");
294    std::string one =
295        "1";  
296    old_size = result.size();
297    absl::StrAppend(&result, "And a ", one.size(), " and a ",
298                    &result[2] - &result[0], " and a ", one, " 2 3 4", "!");
299    EXPECT_EQ(result.substr(old_size), "And a 1 and a 2 and a 1 2 3 4!");
300    old_size = result.size();
301    absl::StrAppend(&result,
302                    "To output a char by ASCII/numeric value, use +: ", '!' + 0);
303    EXPECT_EQ(result.substr(old_size),
304              "To output a char by ASCII/numeric value, use +: 33");
305    old_size = result.size();
306    absl::StrAppend(&result, 1, 22, 333, 4444, 55555, 666666, 7777777, 88888888,
307                    9);
308    EXPECT_EQ(result.substr(old_size), "1223334444555556666667777777888888889");
309    old_size = result.size();
310    absl::StrAppend(
311        &result, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,                           
312        "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",  
313        "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",  
314        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",  
315        "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",  
316        "No limit thanks to C++11's variadic templates");
317    EXPECT_EQ(result.substr(old_size),
318              "12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
319              "No limit thanks to C++11's variadic templates");
320  }
321  TEST(StrCat, VectorBoolReferenceTypes) {
322    std::vector<bool> v;
323    v.push_back(true);
324    v.push_back(false);
325    std::vector<bool> const& cv = v;
326    std::string result = absl::StrCat(v[0], v[1], cv[0], cv[1]); 
327    EXPECT_EQ(result, "1010");
328  }
329  TEST(StrCat, AvoidsMemcpyWithNullptr) {
330    EXPECT_EQ(absl::StrCat(42, absl::string_view{}), "42");
331    EXPECT_EQ(absl::StrCat(1, 2, 3, 4, 5, absl::string_view{}), "12345");
332    std::string result;
333    absl::StrAppend(&result, 1, 2, 3, 4, 5, absl::string_view{});
334    EXPECT_EQ(result, "12345");
335  }
336  #if GTEST_HAS_DEATH_TEST
337  TEST(StrAppend, Death) {
338    std::string s = "self";
339    ABSL_EXPECT_DEBUG_DEATH(absl::StrAppend(&s, s.c_str() + 1),
340                            "ssertion.*failed");
341    ABSL_EXPECT_DEBUG_DEATH(absl::StrAppend(&s, s), "ssertion.*failed");
<span onclick='openModal()' class='match'>342  }
343  #endif  
344  TEST(StrAppend, CornerCases) {
345    std::string result;
346    absl::StrAppend(&result, "");
347    EXPECT_EQ(result, "");
348    absl::StrAppend(&result, "", "");
349    EXPECT_EQ(result, "");
350    absl::StrAppend(&result, "", "", "");
351    EXPECT_EQ(result, "");
352    absl::StrAppend(&result, "", "", "", "");
353    EXPECT_EQ(result, "");
354    absl::StrAppend(&result, "", "", "", "", "");
</span>355    EXPECT_EQ(result, "");
356  }
357  TEST(StrAppend, CornerCasesNonEmptyAppend) {
358    for (std::string result : {"hello", "a string too long to fit in the SSO"}) {
359      const std::string expected = result;
360      absl::StrAppend(&result, "");
361      EXPECT_EQ(result, expected);
362      absl::StrAppend(&result, "", "");
363      EXPECT_EQ(result, expected);
364      absl::StrAppend(&result, "", "", "");
365      EXPECT_EQ(result, expected);
366      absl::StrAppend(&result, "", "", "", "");
367      EXPECT_EQ(result, expected);
368      absl::StrAppend(&result, "", "", "", "", "");
369      EXPECT_EQ(result, expected);
370    }
371  }
372  template <typename IntType>
373  void CheckHex(IntType v, const char* nopad_format, const char* zeropad_format,
374                const char* spacepad_format) {
375    char expected[256];
376    std::string actual = absl::StrCat(absl::Hex(v, absl::kNoPad));
377    snprintf(expected, sizeof(expected), nopad_format, v);
378    EXPECT_EQ(expected, actual) << " decimal value " << v;
379    for (int spec = absl::kZeroPad2; spec <= absl::kZeroPad20; ++spec) {
380      std::string actual =
381          absl::StrCat(absl::Hex(v, static_cast<absl::PadSpec>(spec)));
382      snprintf(expected, sizeof(expected), zeropad_format,
383               spec - absl::kZeroPad2 + 2, v);
384      EXPECT_EQ(expected, actual) << " decimal value " << v;
385    }
386    for (int spec = absl::kSpacePad2; spec <= absl::kSpacePad20; ++spec) {
387      std::string actual =
388          absl::StrCat(absl::Hex(v, static_cast<absl::PadSpec>(spec)));
389      snprintf(expected, sizeof(expected), spacepad_format,
390               spec - absl::kSpacePad2 + 2, v);
391      EXPECT_EQ(expected, actual) << " decimal value " << v;
392    }
393  }
394  template <typename IntType>
395  void CheckDec(IntType v, const char* nopad_format, const char* zeropad_format,
396                const char* spacepad_format) {
397    char expected[256];
398    std::string actual = absl::StrCat(absl::Dec(v, absl::kNoPad));
399    snprintf(expected, sizeof(expected), nopad_format, v);
400    EXPECT_EQ(expected, actual) << " decimal value " << v;
401    for (int spec = absl::kZeroPad2; spec <= absl::kZeroPad20; ++spec) {
402      std::string actual =
403          absl::StrCat(absl::Dec(v, static_cast<absl::PadSpec>(spec)));
404      snprintf(expected, sizeof(expected), zeropad_format,
405               spec - absl::kZeroPad2 + 2, v);
406      EXPECT_EQ(expected, actual)
407          << " decimal value " << v << " format '" << zeropad_format
408          << "' digits " << (spec - absl::kZeroPad2 + 2);
409    }
410    for (int spec = absl::kSpacePad2; spec <= absl::kSpacePad20; ++spec) {
411      std::string actual =
412          absl::StrCat(absl::Dec(v, static_cast<absl::PadSpec>(spec)));
413      snprintf(expected, sizeof(expected), spacepad_format,
414               spec - absl::kSpacePad2 + 2, v);
415      EXPECT_EQ(expected, actual)
416          << " decimal value " << v << " format '" << spacepad_format
417          << "' digits " << (spec - absl::kSpacePad2 + 2);
418    }
419  }
420  void CheckHexDec64(uint64_t v) {
421    unsigned long long ullv = v;  
422    CheckHex(ullv, "%llx", "%0*llx", "%*llx");
423    CheckDec(ullv, "%llu", "%0*llu", "%*llu");
424    long long llv = static_cast<long long>(ullv);  
425    CheckDec(llv, "%lld", "%0*lld", "%*lld");
426    if (sizeof(v) == sizeof(&v)) {
427      auto uintptr = static_cast<uintptr_t>(v);
428      void* ptr = reinterpret_cast<void*>(uintptr);
429      CheckHex(ptr, "%llx", "%0*llx", "%*llx");
430    }
431  }
432  void CheckHexDec32(uint32_t uv) {
433    CheckHex(uv, "%x", "%0*x", "%*x");
434    CheckDec(uv, "%u", "%0*u", "%*u");
435    int32_t v = static_cast<int32_t>(uv);
436    CheckDec(v, "%d", "%0*d", "%*d");
437    if (sizeof(v) == sizeof(&v)) {
438      auto uintptr = static_cast<uintptr_t>(v);
439      void* ptr = reinterpret_cast<void*>(uintptr);
440      CheckHex(ptr, "%x", "%0*x", "%*x");
441    }
442  }
443  void CheckAll(uint64_t v) {
444    CheckHexDec64(v);
445    CheckHexDec32(static_cast<uint32_t>(v));
446  }
447  void TestFastPrints() {
448    for (int i = 0; i < 10000; i++) {
449      CheckAll(i);
450    }
451    CheckAll(std::numeric_limits<uint64_t>::max());
452    CheckAll(std::numeric_limits<uint64_t>::max() - 1);
453    CheckAll(std::numeric_limits<int64_t>::min());
454    CheckAll(std::numeric_limits<int64_t>::min() + 1);
455    CheckAll(std::numeric_limits<uint32_t>::max());
456    CheckAll(std::numeric_limits<uint32_t>::max() - 1);
457    CheckAll(std::numeric_limits<int32_t>::min());
458    CheckAll(std::numeric_limits<int32_t>::min() + 1);
459    CheckAll(999999999);              
460    CheckAll(1000000000);             
461    CheckAll(9999999999);             
462    CheckAll(10000000000);            
463    CheckAll(999999999999999999);     
464    CheckAll(9999999999999999999u);   
465    CheckAll(1000000000000000000);    
466    CheckAll(10000000000000000000u);  
467    CheckAll(999999999876543210);    
468    CheckAll(9999999999876543210u);  
469    CheckAll(0x123456789abcdef0);    
470    CheckAll(0x12345678);
471    int8_t minus_one_8bit = -1;
472    EXPECT_EQ("ff", absl::StrCat(absl::Hex(minus_one_8bit)));
473    int16_t minus_one_16bit = -1;
474    EXPECT_EQ("ffff", absl::StrCat(absl::Hex(minus_one_16bit)));
475  }
476  TEST(Numbers, TestFunctionsMovedOverFromNumbersMain) {
477    TestFastPrints();
478  }
479  struct PointStringify {
480    template <typename FormatSink>
481    friend void AbslStringify(FormatSink& sink, const PointStringify& p) {
482      sink.Append("(");
483      sink.Append(absl::StrCat(p.x));
484      sink.Append(", ");
485      sink.Append(absl::StrCat(p.y));
486      sink.Append(")");
487    }
488    double x = 10.0;
489    double y = 20.0;
490  };
491  TEST(StrCat, AbslStringifyExample) {
492    PointStringify p;
493    EXPECT_EQ(absl::StrCat(p), "(10, 20)");
494    EXPECT_EQ(absl::StrCat("a ", p, " z"), "a (10, 20) z");
495  }
496  struct PointStringifyUsingFormat {
497    template <typename FormatSink>
498    friend void AbslStringify(FormatSink& sink,
499                              const PointStringifyUsingFormat& p) {
500      absl::Format(&sink, "(%g, %g)", p.x, p.y);
501    }
502    double x = 10.0;
503    double y = 20.0;
504  };
505  TEST(StrCat, AbslStringifyExampleUsingFormat) {
506    PointStringifyUsingFormat p;
507    EXPECT_EQ(absl::StrCat(p), "(10, 20)");
508    EXPECT_EQ(absl::StrCat("a ", p, " z"), "a (10, 20) z");
509  }
510  enum class EnumWithStringify { Many = 0, Choices = 1 };
511  template <typename Sink>
512  void AbslStringify(Sink& sink, EnumWithStringify e) {
513    absl::Format(&sink, "%s", e == EnumWithStringify::Many ? "Many" : "Choices");
514  }
515  TEST(StrCat, AbslStringifyWithEnum) {
516    const auto e = EnumWithStringify::Choices;
517    EXPECT_EQ(absl::StrCat(e), "Choices");
518  }
519  }  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-control.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <cctype>
5  #include <cmath>
6  #include <cstdint> 
7  #include <cstdio>  
8  #include <ctime>   
9  #include "control.h"
10  #ifndef DISABLED_LEGACY_ENGINE
11  #  include "docqual.h"
12  #  include "drawfx.h"
13  #  include "fixspace.h"
14  #endif
15  #include <tesseract/ocrclass.h>
16  #include "lstmrecognizer.h"
17  #include "output.h"
18  #include "pageres.h" 
19  #ifndef DISABLED_LEGACY_ENGINE
20  #  include "reject.h"
21  #endif
22  #include "sorthelper.h"
23  #include "tesseractclass.h"
24  #include "tessvars.h"
25  #include "werdit.h"
26  const char *const kBackUpConfigFile = "tempconfigdata.config";
27  #ifndef DISABLED_LEGACY_ENGINE
28  const double kMinRefitXHeightFraction = 0.5;
29  #endif 
30  namespace tesseract {
31  void Tesseract::recog_pseudo_word(PAGE_RES *page_res, TBOX &selection_box) {
32    PAGE_RES_IT *it = make_pseudo_word(page_res, selection_box);
33    if (it != nullptr) {
34      recog_interactive(it);
35      it->DeleteCurrentWord();
36      delete it;
37    }
38  }
39  bool Tesseract::recog_interactive(PAGE_RES_IT *pr_it) {
40    WordData word_data(*pr_it);
41    SetupWordPassN(2, &word_data);
42    if (lstm_recognizer_ == nullptr) {
43  #ifndef DISABLED_LEGACY_ENGINE
44      classify_word_and_language(2, pr_it, &word_data);
45  #endif 
46    } else {
47      classify_word_and_language(1, pr_it, &word_data);
48    }
49  #ifndef DISABLED_LEGACY_ENGINE
50    if (tessedit_debug_quality_metrics) {
51      int16_t char_qual;
52      int16_t good_char_qual;
53      WERD_RES *word_res = pr_it->word();
54      word_char_quality(word_res, &char_qual, &good_char_qual);
55      tprintf(
56          "\n%d chars;  word_blob_quality: %d;  outline_errs: %d; "
57          "char_quality: %d; good_char_quality: %d\n",
58          word_res->reject_map.length(), word_blob_quality(word_res), word_outline_errs(word_res),
59          char_qual, good_char_qual);
60    }
61  #endif 
62    return true;
63  }
64  bool Tesseract::ProcessTargetWord(const TBOX &word_box, const TBOX &target_word_box,
65                                    const char *word_config, int pass) {
66    if (word_config != nullptr) {
67      if (word_box.major_overlap(target_word_box)) {
68        if (backup_config_file_ == nullptr) {
69          backup_config_file_ = kBackUpConfigFile;
70          FILE *config_fp = fopen(backup_config_file_, "wb");
71          if (config_fp == nullptr) {
72            tprintf("Error, failed to open file \"%s\"\n", backup_config_file_);
73          } else {
74            ParamUtils::PrintParams(config_fp, params());
75            fclose(config_fp);
76          }
77          ParamUtils::ReadParamsFile(word_config, SET_PARAM_CONSTRAINT_DEBUG_ONLY, params());
78        }
79      } else {
80        if (backup_config_file_ != nullptr) {
81          ParamUtils::ReadParamsFile(backup_config_file_, SET_PARAM_CONSTRAINT_DEBUG_ONLY, params());
82          backup_config_file_ = nullptr;
83        }
84      }
85    } else if (pass > 1 && !word_box.major_overlap(target_word_box)) {
86      return false;
87    }
88    return true;
89  }
90  void Tesseract::SetupAllWordsPassN(int pass_n, const TBOX *target_word_box, const char *word_config,
91                                     PAGE_RES *page_res, std::vector<WordData> *words) {
92    PAGE_RES_IT page_res_it(page_res);
93    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
94      if (target_word_box == nullptr || ProcessTargetWord(page_res_it.word()->word->bounding_box(),
95                                                          *target_word_box, word_config, 1)) {
96        words->push_back(WordData(page_res_it));
97      }
98    }
99    for (unsigned w = 0; w < words->size(); ++w) {
100      SetupWordPassN(pass_n, &(*words)[w]);
101      if (w > 0) {
102        (*words)[w].prev_word = &(*words)[w - 1];
103      }
104    }
105  }
106  void Tesseract::SetupWordPassN(int pass_n, WordData *word) {
107    if (pass_n == 1 || !word->word->done) {
108      if (pass_n == 1) {
109        word->word->SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode,
110                                        nullptr, classify_bln_numeric_mode, textord_use_cjk_fp_model,
111                                        poly_allow_detailed_fx, word->row, word->block);
112      } else if (pass_n == 2) {
113        word->word->caps_height = 0.0;
114        if (word->word->x_height == 0.0f) {
115          word->word->x_height = word->row->x_height();
116        }
117      }
118      word->lang_words.truncate(0);
119      for (unsigned s = 0; s <= sub_langs_.size(); ++s) {
120        Tesseract *lang_t = s < sub_langs_.size() ? sub_langs_[s] : this;
121        auto *word_res = new WERD_RES;
122        word_res->InitForRetryRecognition(*word->word);
123        word->lang_words.push_back(word_res);
124        if (pass_n == 1 || lang_t->tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
125          word_res->SetupForRecognition(
126              lang_t->unicharset, lang_t, BestPix(), lang_t->tessedit_ocr_engine_mode, nullptr,
127              lang_t->classify_bln_numeric_mode, lang_t->textord_use_cjk_fp_model,
128              lang_t->poly_allow_detailed_fx, word->row, word->block);
129        }
130      }
131    }
132  }
133  bool Tesseract::RecogAllWordsPassN(int pass_n, ETEXT_DESC *monitor, PAGE_RES_IT *pr_it,
134                                     std::vector<WordData> *words) {
135    pr_it->restart_page();
136    for (unsigned w = 0; w < words->size(); ++w) {
137      WordData *word = &(*words)[w];
138      if (w > 0) {
139        word->prev_word = &(*words)[w - 1];
140      }
141      if (monitor != nullptr) {
142        monitor->ocr_alive = true;
143        if (pass_n == 1) {
144          monitor->progress = 70 * w / words->size();
145        } else {
146          monitor->progress = 70 + 30 * w / words->size();
147        }
148        if (monitor->progress_callback2 != nullptr) {
149          TBOX box = pr_it->word()->word->bounding_box();
150          (*monitor->progress_callback2)(monitor, box.left(), box.right(), box.top(), box.bottom());
151        }
152        if (monitor->deadline_exceeded() ||
153            (monitor->cancel != nullptr && (*monitor->cancel)(monitor->cancel_this, words->size()))) {
154          for (; w < words->size(); ++w) {
155            (*words)[w].word->SetupFake(unicharset);
156          }
157          return false;
158        }
159      }
160      if (word->word->tess_failed) {
161        unsigned s;
162        for (s = 0; s < word->lang_words.size() && word->lang_words[s]->tess_failed; ++s) {
163        }
164        if (s > word->lang_words.size()) {
165          continue;
166        }
167      }
168      while (pr_it->word() != nullptr && pr_it->word() != word->word) {
169        pr_it->forward();
170      }
171      ASSERT_HOST(pr_it->word() != nullptr);
172      bool make_next_word_fuzzy = false;
173  #ifndef DISABLED_LEGACY_ENGINE
174      if (!AnyLSTMLang() && ReassignDiacritics(pass_n, pr_it, &make_next_word_fuzzy)) {
175        SetupWordPassN(pass_n, word);
176      }
177  #endif 
178      classify_word_and_language(pass_n, pr_it, word);
179      if (tessedit_dump_choices || debug_noise_removal) {
180        tprintf("Pass%d: %s [%s]\n", pass_n, word->word->best_choice->unichar_string().c_str(),
181                word->word->best_choice->debug_string().c_str());
182      }
183      pr_it->forward();
184      if (make_next_word_fuzzy && pr_it->word() != nullptr) {
185        pr_it->MakeCurrentWordFuzzy();
186      }
187    }
188    return true;
189  }
190  bool Tesseract::recog_all_words(PAGE_RES *page_res, ETEXT_DESC *monitor,
191                                  const TBOX *target_word_box, const char *word_config,
192                                  int dopasses) {
193    PAGE_RES_IT page_res_it(page_res);
194    if (tessedit_minimal_rej_pass1) {
195      tessedit_test_adaption.set_value(true);
196      tessedit_minimal_rejection.set_value(true);
197    }
198    if (dopasses == 0 || dopasses == 1) {
199      page_res_it.restart_page();
200  #ifndef DISABLED_LEGACY_ENGINE
201      if (AdaptiveClassifierIsFull()) {
202        SwitchAdaptiveClassifier();
203      } else if (!AdaptiveClassifierIsEmpty()) {
204        StartBackupAdaptiveClassifier();
205      }
206      for (auto &lang : sub_langs_) {
207        if (lang->AdaptiveClassifierIsFull()) {
208          lang->SwitchAdaptiveClassifier();
209        } else if (!lang->AdaptiveClassifierIsEmpty()) {
210          lang->StartBackupAdaptiveClassifier();
211        }
212      }
213  #endif 
214      std::vector<WordData> words;
215      SetupAllWordsPassN(1, target_word_box, word_config, page_res, &words);
216  #ifndef DISABLED_LEGACY_ENGINE
217      if (tessedit_parallelize) {
218        PrerecAllWordsPar(words);
219      }
220  #endif 
221      stats_.word_count = words.size();
222      stats_.dict_words = 0;
223      stats_.doc_blob_quality = 0;
224      stats_.doc_outline_errs = 0;
225      stats_.doc_char_quality = 0;
226      stats_.good_char_count = 0;
227      stats_.doc_good_char_quality = 0;
228      most_recently_used_ = this;
229      if (!RecogAllWordsPassN(1, monitor, &page_res_it, &words)) {
230        return false;
231      }
232      for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
233        if (page_res_it.word()->word->flag(W_REP_CHAR)) {
234          fix_rep_char(&page_res_it);
235          continue;
236        }
237        if (page_res_it.word()->best_choice->permuter() == USER_DAWG_PERM) {
238          ++(stats_.dict_words);
239        }
240        if (page_res_it.word()->blamer_bundle != nullptr &&
241            page_res_it.word()->blamer_bundle->misadaption_debug().length() > 0) {
242          page_res->misadaption_log.push_back(page_res_it.word()->blamer_bundle->misadaption_debug());
243        }
244      }
245    }
246    if (dopasses == 1) {
247      return true;
248    }
249  #ifndef DISABLED_LEGACY_ENGINE
250    if (tessedit_tess_adaption_mode != 0x0 && !tessedit_test_adaption && AnyTessLang()) {
251      page_res_it.restart_page();
252      std::vector<WordData> words;
253      SetupAllWordsPassN(2, target_word_box, word_config, page_res, &words);
254      if (tessedit_parallelize) {
255        PrerecAllWordsPar(words);
256      }
257      most_recently_used_ = this;
258      if (!RecogAllWordsPassN(2, monitor, &page_res_it, &words)) {
259        return false;
260      }
261    }
262    if (AnyTessLang() && !AnyLSTMLang()) {
263      if (!tessedit_test_adaption && tessedit_fix_fuzzy_spaces && !tessedit_word_for_word &&
264          !right_to_left()) {
265        fix_fuzzy_spaces(monitor, stats_.word_count, page_res);
266      }
267      if (tessedit_enable_dict_correction) {
268        dictionary_correction_pass(page_res);
269      }
270      if (tessedit_enable_bigram_correction) {
271        bigram_correction_pass(page_res);
272      }
273      rejection_passes(page_res, monitor, target_word_box, word_config);
274      font_recognition_pass(page_res);
275      blamer_pass(page_res);
276      script_pos_pass(page_res);
277    }
278  #endif 
279  #ifndef DISABLED_LEGACY_ENGINE
280    if ((dopasses == 0 || dopasses == 2) && (monitor || tessedit_write_unlv)) {
281      output_pass(page_res_it, target_word_box);
282    }
283  #endif 
284    const auto pageseg_mode = static_cast<PageSegMode>(static_cast<int>(tessedit_pageseg_mode));
285    textord_.CleanupSingleRowResult(pageseg_mode, page_res);
286    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
287      const WERD_RES *word = page_res_it.word();
288      const POLY_BLOCK *pb = page_res_it.block()->block != nullptr
289                                 ? page_res_it.block()->block->pdblk.poly_block()
290                                 : nullptr;
291      if (word->best_choice == nullptr || word->best_choice->empty() ||
292          (word->best_choice->IsAllSpaces() && (pb == nullptr || pb->IsText()))) {
293        page_res_it.DeleteCurrentWord();
294      }
295    }
296    if (monitor != nullptr) {
297      monitor->progress = 100;
298    }
299    return true;
300  }
301  #ifndef DISABLED_LEGACY_ENGINE
302  void Tesseract::bigram_correction_pass(PAGE_RES *page_res) {
303    PAGE_RES_IT word_it(page_res);
304    WERD_RES *w_prev = nullptr;
305    WERD_RES *w = word_it.word();
306    while (true) {
307      w_prev = w;
308      while (word_it.forward() != nullptr && (!word_it.word() || word_it.word()->part_of_combo)) {
309      }
310      if (!word_it.word()) {
311        break;
312      }
313      w = word_it.word();
314      if (!w || !w_prev || w->uch_set != w_prev->uch_set) {
315        continue;
316      }
317      if (w_prev->word->flag(W_REP_CHAR) || w->word->flag(W_REP_CHAR)) {
318        if (tessedit_bigram_debug) {
319          tprintf("Skipping because one of the words is W_REP_CHAR\n");
320        }
321        continue;
322      }
323      std::vector<WERD_CHOICE *> overrides_word1;
324      std::vector<WERD_CHOICE *> overrides_word2;
325      const auto orig_w1_str = w_prev->best_choice->unichar_string();
326      const auto orig_w2_str = w->best_choice->unichar_string();
327      WERD_CHOICE prev_best(w->uch_set);
328      {
329        int w1start, w1end;
330        w_prev->best_choice->GetNonSuperscriptSpan(&w1start, &w1end);
331        prev_best = w_prev->best_choice->shallow_copy(w1start, w1end);
332      }
333      WERD_CHOICE this_best(w->uch_set);
334      {
335        int w2start, w2end;
336        w->best_choice->GetNonSuperscriptSpan(&w2start, &w2end);
337        this_best = w->best_choice->shallow_copy(w2start, w2end);
338      }
339      if (w->tesseract->getDict().valid_bigram(prev_best, this_best)) {
340        if (tessedit_bigram_debug) {
341          tprintf("Top choice \"%s %s\" verified by bigram model.\n", orig_w1_str.c_str(),
342                  orig_w2_str.c_str());
343        }
344        continue;
345      }
346      if (tessedit_bigram_debug > 2) {
347        tprintf("Examining alt choices for \"%s %s\".\n", orig_w1_str.c_str(), orig_w2_str.c_str());
348      }
349      if (tessedit_bigram_debug > 1) {
350        if (!w_prev->best_choices.singleton()) {
351          w_prev->PrintBestChoices();
352        }
353        if (!w->best_choices.singleton()) {
354          w->PrintBestChoices();
355        }
356      }
357      float best_rating = 0.0;
358      int best_idx = 0;
359      WERD_CHOICE_IT prev_it(&w_prev->best_choices);
360      for (prev_it.mark_cycle_pt(); !prev_it.cycled_list(); prev_it.forward()) {
361        WERD_CHOICE *p1 = prev_it.data();
362        WERD_CHOICE strip1(w->uch_set);
363        {
364          int p1start, p1end;
365          p1->GetNonSuperscriptSpan(&p1start, &p1end);
366          strip1 = p1->shallow_copy(p1start, p1end);
367        }
368        WERD_CHOICE_IT w_it(&w->best_choices);
369        for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
370          WERD_CHOICE *p2 = w_it.data();
371          WERD_CHOICE strip2(w->uch_set);
372          {
373            int p2start, p2end;
374            p2->GetNonSuperscriptSpan(&p2start, &p2end);
375            strip2 = p2->shallow_copy(p2start, p2end);
376          }
377          if (w->tesseract->getDict().valid_bigram(strip1, strip2)) {
378            overrides_word1.push_back(p1);
379            overrides_word2.push_back(p2);
380            if (overrides_word1.size() == 1 || p1->rating() + p2->rating() < best_rating) {
381              best_rating = p1->rating() + p2->rating();
382              best_idx = overrides_word1.size() - 1;
383            }
384          }
385        }
386      }
387      if (!overrides_word1.empty()) {
388        if (EqualIgnoringCaseAndTerminalPunct(*w_prev->best_choice, *overrides_word1[best_idx]) &&
389            EqualIgnoringCaseAndTerminalPunct(*w->best_choice, *overrides_word2[best_idx])) {
390          if (tessedit_bigram_debug > 1) {
391            tprintf(
392                "Top choice \"%s %s\" verified (sans case) by bigram "
393                "model.\n",
394                orig_w1_str.c_str(), orig_w2_str.c_str());
395          }
396          continue;
397        }
398        const auto new_w1_str = overrides_word1[best_idx]->unichar_string();
399        const auto new_w2_str = overrides_word2[best_idx]->unichar_string();
400        if (new_w1_str != orig_w1_str) {
401          w_prev->ReplaceBestChoice(overrides_word1[best_idx]);
402        }
403        if (new_w2_str != orig_w2_str) {
404          w->ReplaceBestChoice(overrides_word2[best_idx]);
405        }
406        if (tessedit_bigram_debug > 0) {
407          std::string choices_description;
408          int num_bigram_choices = overrides_word1.size() * overrides_word2.size();
409          if (num_bigram_choices == 1) {
410            choices_description = "This was the unique bigram choice.";
411          } else {
412            if (tessedit_bigram_debug > 1) {
413              std::string bigrams_list;
414              const int kMaxChoicesToPrint = 20;
415              for (unsigned i = 0; i < overrides_word1.size() && i < kMaxChoicesToPrint; i++) {
416                if (i > 0) {
417                  bigrams_list += ", ";
418                }
419                WERD_CHOICE *p1 = overrides_word1[i];
420                WERD_CHOICE *p2 = overrides_word2[i];
421                bigrams_list += p1->unichar_string() + " " + p2->unichar_string();
422              }
423              choices_description = "There were many choices: {";
424              choices_description += bigrams_list;
425              choices_description += "}";
426            } else {
427              choices_description += "There were " + std::to_string(num_bigram_choices);
428              choices_description += " compatible bigrams.";
429            }
430          }
431          tprintf("Replaced \"%s %s\" with \"%s %s\" with bigram model. %s\n", orig_w1_str.c_str(),
432                  orig_w2_str.c_str(), new_w1_str.c_str(), new_w2_str.c_str(),
433                  choices_description.c_str());
434        }
435      }
436    }
437  }
438  void Tesseract::rejection_passes(PAGE_RES *page_res, ETEXT_DESC *monitor,
439                                   const TBOX *target_word_box, const char *word_config) {
440    PAGE_RES_IT page_res_it(page_res);
441    int word_index = 0;
442    while (!tessedit_test_adaption && page_res_it.word() != nullptr) {
443      WERD_RES *word = page_res_it.word();
444      word_index++;
445      if (monitor != nullptr) {
446        monitor->ocr_alive = true;
447        monitor->progress = 95 + 5 * word_index / stats_.word_count;
448      }
449      if (word->rebuild_word == nullptr) {
450        page_res_it.forward();
451        continue;
452      }
453      check_debug_pt(word, 70);
454      if (target_word_box &&
455          !ProcessTargetWord(word->word->bounding_box(), *target_word_box, word_config, 4)) {
456        page_res_it.forward();
457        continue;
458      }
459      page_res_it.rej_stat_word();
460      const int chars_in_word = word->reject_map.length();
461      const int rejects_in_word = word->reject_map.reject_count();
462      const int blob_quality = word_blob_quality(word);
463      stats_.doc_blob_quality += blob_quality;
464      const int outline_errs = word_outline_errs(word);
465      stats_.doc_outline_errs += outline_errs;
466      int16_t all_char_quality;
467      int16_t accepted_all_char_quality;
468      word_char_quality(word, &all_char_quality, &accepted_all_char_quality);
469      stats_.doc_char_quality += all_char_quality;
470      const uint8_t permuter_type = word->best_choice->permuter();
471      if ((permuter_type == SYSTEM_DAWG_PERM) || (permuter_type == FREQ_DAWG_PERM) ||
472          (permuter_type == USER_DAWG_PERM)) {
473        stats_.good_char_count += chars_in_word - rejects_in_word;
474        stats_.doc_good_char_quality += accepted_all_char_quality;
475      }
476      check_debug_pt(word, 80);
477      if (tessedit_reject_bad_qual_wds && (blob_quality == 0) && (outline_errs >= chars_in_word)) {
478        word->reject_map.rej_word_bad_quality();
479      }
480      check_debug_pt(word, 90);
481      page_res_it.forward();
482    }
483    if (tessedit_debug_quality_metrics) {
484      tprintf(
485          "QUALITY: num_chs= %d  num_rejs= %d %5.3f blob_qual= %d %5.3f"
486          " outline_errs= %d %5.3f char_qual= %d %5.3f good_ch_qual= %d %5.3f\n",
487          page_res->char_count, page_res->rej_count,
488          page_res->rej_count / static_cast<float>(page_res->char_count), stats_.doc_blob_quality,
489          stats_.doc_blob_quality / static_cast<float>(page_res->char_count), stats_.doc_outline_errs,
490          stats_.doc_outline_errs / static_cast<float>(page_res->char_count), stats_.doc_char_quality,
491          stats_.doc_char_quality / static_cast<float>(page_res->char_count),
492          stats_.doc_good_char_quality,
493          (stats_.good_char_count > 0)
494              ? (stats_.doc_good_char_quality / static_cast<float>(stats_.good_char_count))
495              : 0.0);
496    }
497    bool good_quality_doc =
498        ((page_res->rej_count / static_cast<float>(page_res->char_count)) <= quality_rej_pc) &&
499        (stats_.doc_blob_quality / static_cast<float>(page_res->char_count) >= quality_blob_pc) &&
500        (stats_.doc_outline_errs / static_cast<float>(page_res->char_count) <= quality_outline_pc) &&
501        (stats_.doc_char_quality / static_cast<float>(page_res->char_count) >= quality_char_pc);
502    if (!tessedit_test_adaption) {
503      quality_based_rejection(page_res_it, good_quality_doc);
504    }
505  }
506  #endif 
507  void Tesseract::blamer_pass(PAGE_RES *page_res) {
508    if (!wordrec_run_blamer) {
509      return;
510    }
511    PAGE_RES_IT page_res_it(page_res);
512    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
513      WERD_RES *word = page_res_it.word();
514      BlamerBundle::LastChanceBlame(wordrec_debug_blamer, word);
515      page_res->blame_reasons[word->blamer_bundle->incorrect_result_reason()]++;
516    }
517    tprintf("Blame reasons:\n");
518    for (int bl = 0; bl < IRR_NUM_REASONS; ++bl) {
519      tprintf("%s %d\n", BlamerBundle::IncorrectReasonName(static_cast<IncorrectResultReason>(bl)),
520              page_res->blame_reasons[bl]);
521    }
522    if (page_res->misadaption_log.size() > 0) {
523      tprintf("Misadaption log:\n");
524      for (auto &log : page_res->misadaption_log) {
525        tprintf("%s\n", log.c_str());
526      }
527    }
528  }
529  void Tesseract::script_pos_pass(PAGE_RES *page_res) {
530    PAGE_RES_IT page_res_it(page_res);
531    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
532      WERD_RES *word = page_res_it.word();
533      if (word->word->flag(W_REP_CHAR)) {
534        page_res_it.forward();
535        continue;
536      }
537      const float x_height = page_res_it.block()->block->x_height();
538      float word_x_height = word->x_height;
539      if (word_x_height < word->best_choice->min_x_height() ||
540          word_x_height > word->best_choice->max_x_height()) {
541        word_x_height =
542            (word->best_choice->min_x_height() + word->best_choice->max_x_height()) / 2.0f;
543      }
544      const double small_cap_xheight = x_height * kXHeightCapRatio;
545      const double small_cap_delta = (x_height - small_cap_xheight) / 2.0;
546      if (word->uch_set->script_has_xheight() &&
547          small_cap_xheight - small_cap_delta <= word_x_height &&
548          word_x_height <= small_cap_xheight + small_cap_delta) {
549        int num_upper = 0;
550        int num_lower = 0;
551        for (unsigned i = 0; i < word->best_choice->length(); ++i) {
552          if (word->uch_set->get_isupper(word->best_choice->unichar_id(i))) {
553            ++num_upper;
554          } else if (word->uch_set->get_islower(word->best_choice->unichar_id(i))) {
555            ++num_lower;
556          }
557        }
558        if (num_upper > 0 && num_lower == 0) {
559          word->small_caps = true;
560        }
561      }
562      word->SetScriptPositions();
563    }
564  }
565  static void WordGap(const PointerVector<WERD_RES> &words, unsigned index, int *right, int *next_left) {
566    *right = -INT32_MAX;
567    *next_left = INT32_MAX;
568    if (index < words.size()) {
569      *right = words[index]->word->bounding_box().right();
570      if (index + 1 < words.size()) {
571        *next_left = words[index + 1]->word->bounding_box().left();
572      }
573    }
574  }
575  static void EvaluateWordSpan(const PointerVector<WERD_RES> &words, unsigned first_index, unsigned end_index,
576                               float *rating, float *certainty, bool *bad, bool *valid_permuter) {
577    if (end_index <= first_index) {
578      *bad = true;
579      *valid_permuter = false;
580    }
581    for (unsigned index = first_index; index < end_index && index < words.size(); ++index) {
582      WERD_CHOICE *choice = words[index]->best_choice;
583      if (choice == nullptr) {
584        *bad = true;
585      } else {
586        *rating += choice->rating();
587        *certainty = std::min(*certainty, choice->certainty());
588        if (!Dict::valid_word_permuter(choice->permuter(), false)) {
589          *valid_permuter = false;
590        }
591      }
592    }
593  }
594  static int SelectBestWords(double rating_ratio, double certainty_margin, bool debug,
595                             PointerVector<WERD_RES> *new_words,
596                             PointerVector<WERD_RES> *best_words) {
597    std::vector<WERD_RES *> out_words;
598    unsigned b = 0, n = 0;
599    int num_best = 0, num_new = 0;
600    while (b < best_words->size() || n < new_words->size()) {
601      auto start_b = b, start_n = n;
602      while (b < best_words->size() || n < new_words->size()) {
603        int b_right = -INT32_MAX;
604        int next_b_left = INT32_MAX;
605        WordGap(*best_words, b, &b_right, &next_b_left);
606        int n_right = -INT32_MAX;
607        int next_n_left = INT32_MAX;
608        WordGap(*new_words, n, &n_right, &next_n_left);
609        if (std::max(b_right, n_right) < std::min(next_b_left, next_n_left)) {
610          break;
611        }
612        if ((b_right < n_right && b < best_words->size()) || n == new_words->size()) {
613          ++b;
614        } else {
615          ++n;
616        }
617      }
618      float b_rating = 0.0f, n_rating = 0.0f;
619      float b_certainty = 0.0f, n_certainty = 0.0f;
620      bool b_bad = false, n_bad = false;
621      bool b_valid_permuter = true, n_valid_permuter = true;
622      const int end_b = b < best_words->size() ? b + 1 : b;
623      const int end_n = n < new_words->size() ? n + 1 : n;
624      EvaluateWordSpan(*best_words, start_b, end_b, &b_rating, &b_certainty, &b_bad,
625                       &b_valid_permuter);
626      EvaluateWordSpan(*new_words, start_n, end_n, &n_rating, &n_certainty, &n_bad,
627                       &n_valid_permuter);
628      bool new_better = false;
629      if (!n_bad && (b_bad || (n_certainty > b_certainty && n_rating < b_rating) ||
630                     (!b_valid_permuter && n_valid_permuter && n_rating < b_rating * rating_ratio &&
631                      n_certainty > b_certainty - certainty_margin))) {
632        for (int i = start_n; i < end_n; ++i) {
633          out_words.push_back((*new_words)[i]);
634          (*new_words)[i] = nullptr;
635          ++num_new;
636        }
637        new_better = true;
638      } else if (!b_bad) {
639        for (int i = start_b; i < end_b; ++i) {
640          out_words.push_back((*best_words)[i]);
641          (*best_words)[i] = nullptr;
642          ++num_best;
643        }
644      }
645      if (debug) {
646        tprintf(
647            "%d new words %s than %d old words: r: %g v %g c: %g v %g"
648            " valid dict: %d v %d\n",
649            end_n - start_n, new_better ? "better" : "worse", end_b - start_b, n_rating, b_rating,
650            n_certainty, b_certainty, n_valid_permuter, b_valid_permuter);
651      }
652      b = end_b;
653      n = end_n;
654    }
655    best_words->clear();
656    for (auto &out_word : out_words) {
657      best_words->push_back(out_word);
658    }
659    return num_new - num_best;
660  }
661  int Tesseract::RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
662                                   WERD_RES **in_word, PointerVector<WERD_RES> *best_words) {
663    if (debug) {
664      tprintf("Trying word using lang %s, oem %d\n", lang.c_str(),
665              static_cast<int>(tessedit_ocr_engine_mode));
666    }
667    PointerVector<WERD_RES> new_words;
668    (this->*recognizer)(word_data, in_word, &new_words);
669    if (new_words.empty()) {
670      new_words.push_back(*in_word);
671      *in_word = nullptr;
672    }
673    if (debug) {
674      for (unsigned i = 0; i < new_words.size(); ++i) {
675        new_words[i]->DebugTopChoice("Lang result");
676      }
677    }
678    return SelectBestWords(classify_max_rating_ratio, classify_max_certainty_margin, debug,
679                           &new_words, best_words);
680  }
681  static bool WordsAcceptable(const PointerVector<WERD_RES> &words) {
682    for (unsigned w = 0; w < words.size(); ++w) {
683      if (words[w]->tess_failed || !words[w]->tess_accepted) {
684        return false;
685      }
686    }
687    return true;
688  }
689  #ifndef DISABLED_LEGACY_ENGINE
690  bool Tesseract::ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy) {
691    *make_next_word_fuzzy = false;
692    WERD *real_word = pr_it->word()->word;
693    if (real_word->rej_cblob_list()->empty() || real_word->cblob_list()->empty() ||
694        real_word->rej_cblob_list()->length() > noise_maxperword) {
695      return false;
696    }
697    real_word->rej_cblob_list()->sort(&C_BLOB::SortByXMiddle);
698    std::vector<C_OUTLINE *> outlines;
699    real_word->GetNoiseOutlines(&outlines);
700    std::vector<bool> word_wanted;
701    std::vector<bool> overlapped_any_blob;
702    std::vector<C_BLOB *> target_blobs;
703    AssignDiacriticsToOverlappingBlobs(outlines, pass, real_word, pr_it, &word_wanted,
704                                       &overlapped_any_blob, &target_blobs);
705    std::vector<bool> wanted;
706    std::vector<C_BLOB *> wanted_blobs;
707    std::vector<C_OUTLINE *> wanted_outlines;
708    int num_overlapped = 0;
709    int num_overlapped_used = 0;
710    for (unsigned i = 0; i < overlapped_any_blob.size(); ++i) {
711      if (overlapped_any_blob[i]) {
712        ++num_overlapped;
713        if (word_wanted[i]) {
714          ++num_overlapped_used;
715        }
716        wanted.push_back(word_wanted[i]);
717        wanted_blobs.push_back(target_blobs[i]);
718        wanted_outlines.push_back(outlines[i]);
719        outlines[i] = nullptr;
720      }
721    }
722    real_word->AddSelectedOutlines(wanted, wanted_blobs, wanted_outlines, nullptr);
723    AssignDiacriticsToNewBlobs(outlines, pass, real_word, pr_it, &word_wanted, &target_blobs);
724    int non_overlapped = 0;
725    int non_overlapped_used = 0;
726    for (unsigned i = 0; i < word_wanted.size(); ++i) {
727      if (word_wanted[i]) {
728        ++non_overlapped_used;
729      }
730      if (outlines[i] != nullptr) {
731        ++non_overlapped_used;
732      }
733    }
734    if (debug_noise_removal) {
735      tprintf("Used %d/%d overlapped %d/%d non-overlaped diacritics on word:", num_overlapped_used,
736              num_overlapped, non_overlapped_used, non_overlapped);
737      real_word->bounding_box().print();
738    }
739    if (real_word->AddSelectedOutlines(word_wanted, target_blobs, outlines, make_next_word_fuzzy)) {
740      pr_it->MakeCurrentWordFuzzy();
741    }
742    return num_overlapped_used != 0 || non_overlapped_used != 0;
<span onclick='openModal()' class='match'>743  }
744  void Tesseract::AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines,
745                                                     int pass, WERD *real_word, PAGE_RES_IT *pr_it,
746                                                     std::vector<bool> *word_wanted,
747                                                     std::vector<bool> *overlapped_any_blob,
748                                                     std::vector<C_BLOB *> *target_blobs) {
749    std::vector<bool> blob_wanted;
</span>750    word_wanted->clear();
751    word_wanted->resize(outlines.size());
752    overlapped_any_blob->clear();
753    overlapped_any_blob->resize(outlines.size());
754    target_blobs->clear();
755    target_blobs->resize(outlines.size());
756    C_BLOB_IT blob_it(real_word->cblob_list());
757    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
758      C_BLOB *blob = blob_it.data();
759      const TBOX blob_box = blob->bounding_box();
760      blob_wanted.clear();
761      blob_wanted.resize(outlines.size());
762      int num_blob_outlines = 0;
763      for (unsigned i = 0; i < outlines.size(); ++i) {
764        if (blob_box.major_x_overlap(outlines[i]->bounding_box()) && !(*word_wanted)[i]) {
765          blob_wanted[i] = true;
766          (*overlapped_any_blob)[i] = true;
767          ++num_blob_outlines;
768        }
769      }
770      if (debug_noise_removal) {
771        tprintf("%d noise outlines overlap blob at:", num_blob_outlines);
772        blob_box.print();
773      }
774      if (0 < num_blob_outlines && num_blob_outlines < noise_maxperblob) {
775        if (SelectGoodDiacriticOutlines(pass, noise_cert_basechar, pr_it, blob, outlines,
776                                        num_blob_outlines, &blob_wanted)) {
777          for (unsigned i = 0; i < blob_wanted.size(); ++i) {
778            if (blob_wanted[i]) {
779              (*word_wanted)[i] = true;
780              (*target_blobs)[i] = blob;
781            }
782          }
783        }
784      }
785    }
786  }
787  void Tesseract::AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
788                                             WERD *real_word, PAGE_RES_IT *pr_it,
789                                             std::vector<bool> *word_wanted,
790                                             std::vector<C_BLOB *> *target_blobs) {
791    std::vector<bool> blob_wanted;
792    word_wanted->clear();
793    word_wanted->resize(outlines.size());
794    target_blobs->clear();
795    target_blobs->resize(outlines.size());
796    for (unsigned i = 0; i < outlines.size(); ++i) {
797      if (outlines[i] == nullptr) {
798        continue;
799      }
800      blob_wanted.clear();
801      blob_wanted.resize(outlines.size());
802      int num_blob_outlines = 0;
803      TBOX total_ol_box(outlines[i]->bounding_box());
804      while (i < outlines.size() && outlines[i] != nullptr) {
805        blob_wanted[i] = true;
806        total_ol_box += outlines[i]->bounding_box();
807        ++i;
808        ++num_blob_outlines;
809      }
810      C_BLOB_IT blob_it(real_word->cblob_list());
811      while (!blob_it.at_last() &&
812             blob_it.data_relative(1)->bounding_box().left() <= total_ol_box.left()) {
813        blob_it.forward();
814      }
815      if (debug_noise_removal) {
816        tprintf("Num blobless outlines = %d\n", num_blob_outlines);
817      }
818      C_BLOB *left_blob = blob_it.data();
819      TBOX left_box = left_blob->bounding_box();
820      C_BLOB *right_blob = blob_it.at_last() ? nullptr : blob_it.data_relative(1);
821      if ((left_box.x_overlap(total_ol_box) || right_blob == nullptr ||
822           !right_blob->bounding_box().x_overlap(total_ol_box)) &&
823          SelectGoodDiacriticOutlines(pass, noise_cert_disjoint, pr_it, left_blob, outlines,
824                                      num_blob_outlines, &blob_wanted)) {
825        if (debug_noise_removal) {
826          tprintf("Added to left blob\n");
827        }
828        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
829          if (blob_wanted[j]) {
830            (*word_wanted)[j] = true;
831            (*target_blobs)[j] = left_blob;
832          }
833        }
834      } else if (right_blob != nullptr &&
835                 (!left_box.x_overlap(total_ol_box) ||
836                  right_blob->bounding_box().x_overlap(total_ol_box)) &&
837                 SelectGoodDiacriticOutlines(pass, noise_cert_disjoint, pr_it, right_blob, outlines,
838                                             num_blob_outlines, &blob_wanted)) {
839        if (debug_noise_removal) {
840          tprintf("Added to right blob\n");
841        }
842        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
843          if (blob_wanted[j]) {
844            (*word_wanted)[j] = true;
845            (*target_blobs)[j] = right_blob;
846          }
847        }
848      } else if (SelectGoodDiacriticOutlines(pass, noise_cert_punc, pr_it, nullptr, outlines,
849                                             num_blob_outlines, &blob_wanted)) {
850        if (debug_noise_removal) {
851          tprintf("Fitted between blobs\n");
852        }
853        for (unsigned j = 0; j < blob_wanted.size(); ++j) {
854          if (blob_wanted[j]) {
855            (*word_wanted)[j] = true;
856            (*target_blobs)[j] = nullptr;
857          }
858        }
859      }
860    }
861  }
862  bool Tesseract::SelectGoodDiacriticOutlines(int pass, float certainty_threshold, PAGE_RES_IT *pr_it,
863                                              C_BLOB *blob,
864                                              const std::vector<C_OUTLINE *> &outlines,
865                                              int num_outlines, std::vector<bool> *ok_outlines) {
866    std::string best_str;
867    float target_cert = certainty_threshold;
868    if (blob != nullptr) {
869      float target_c2;
870      target_cert = ClassifyBlobAsWord(pass, pr_it, blob, best_str, &target_c2);
871      if (debug_noise_removal) {
872        tprintf("No Noise blob classified as %s=%g(%g) at:", best_str.c_str(), target_cert,
873                target_c2);
874        blob->bounding_box().print();
875      }
876      target_cert -= (target_cert - certainty_threshold) * noise_cert_factor;
877    }
878    std::vector<bool> test_outlines = *ok_outlines;
879    std::string all_str;
880    std::vector<bool> best_outlines = *ok_outlines;
881    float best_cert = ClassifyBlobPlusOutlines(test_outlines, outlines, pass, pr_it, blob, all_str);
882    if (debug_noise_removal) {
883      TBOX ol_box;
884      for (unsigned i = 0; i < test_outlines.size(); ++i) {
885        if (test_outlines[i]) {
886          ol_box += outlines[i]->bounding_box();
887        }
888      }
889      tprintf("All Noise blob classified as %s=%g, delta=%g at:", all_str.c_str(), best_cert,
890              best_cert - target_cert);
891      ol_box.print();
892    }
893    int best_index = 0; 
894    while (num_outlines > 1 && best_index >= 0 &&
895           (blob == nullptr || best_cert < target_cert || blob != nullptr)) {
896      best_index = -1;
897      for (unsigned i = 0; i < outlines.size(); ++i) {
898        if (test_outlines[i]) {
899          test_outlines[i] = false;
900          std::string str;
901          float cert = ClassifyBlobPlusOutlines(test_outlines, outlines, pass, pr_it, blob, str);
902          if (debug_noise_removal) {
903            TBOX ol_box;
904            for (unsigned j = 0; j < outlines.size(); ++j) {
905              if (test_outlines[j]) {
906                ol_box += outlines[j]->bounding_box();
907              }
908              tprintf("%c", test_outlines[j] ? 'T' : 'F');
909            }
910            tprintf(" blob classified as %s=%g, delta=%g) at:", str.c_str(), cert,
911                    cert - target_cert);
912            ol_box.print();
913          }
914          if (cert > best_cert) {
915            best_cert = cert;
916            best_index = i;
917            best_outlines = test_outlines;
918          }
919          test_outlines[i] = true;
920        }
921      }
922      if (best_index >= 0) {
923        test_outlines[best_index] = false;
924        --num_outlines;
925      }
926    }
927    if (best_cert >= target_cert) {
928      *ok_outlines = best_outlines;
929      if (debug_noise_removal) {
930        tprintf("%s noise combination ", blob ? "Adding" : "New");
931        for (auto &&best_outline : best_outlines) {
932          tprintf("%c", best_outline ? 'T' : 'F');
933        }
934        tprintf(" yields certainty %g, beating target of %g\n", best_cert, target_cert);
935      }
936      return true;
937    }
938    return false;
939  }
940  float Tesseract::ClassifyBlobPlusOutlines(const std::vector<bool> &ok_outlines,
941                                            const std::vector<C_OUTLINE *> &outlines, int pass_n,
942                                            PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str) {
943    C_OUTLINE_IT ol_it;
944    C_OUTLINE *first_to_keep = nullptr;
945    C_BLOB *local_blob = nullptr;
946    if (blob != nullptr) {
947      ol_it.set_to_list(blob->out_list());
948      first_to_keep = ol_it.data();
949    }
950    for (unsigned i = 0; i < ok_outlines.size(); ++i) {
951      if (ok_outlines[i]) {
952        if (blob == nullptr) {
953          local_blob = new C_BLOB(outlines[i]);
954          blob = local_blob;
955          ol_it.set_to_list(blob->out_list());
956        } else {
957          ol_it.add_before_stay_put(outlines[i]);
958        }
959      }
960    }
961    float c2;
962    float cert = ClassifyBlobAsWord(pass_n, pr_it, blob, best_str, &c2);
963    ol_it.move_to_first();
964    if (first_to_keep == nullptr) {
965      for (; !ol_it.empty(); ol_it.forward()) {
966        ol_it.extract();
967      }
968      delete local_blob;
969      cert = -c2;
970    } else {
971      for (; ol_it.data() != first_to_keep; ol_it.forward()) {
972        ol_it.extract();
973      }
974    }
975    return cert;
976  }
977  float Tesseract::ClassifyBlobAsWord(int pass_n, PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str,
978                                      float *c2) {
979    WERD *real_word = pr_it->word()->word;
980    WERD *word = real_word->ConstructFromSingleBlob(real_word->flag(W_BOL), real_word->flag(W_EOL),
981                                                    C_BLOB::deep_copy(blob));
982    WERD_RES *word_res = pr_it->InsertSimpleCloneWord(*pr_it->word(), word);
983    PAGE_RES_IT it(pr_it->page_res);
984    while (it.word() != word_res && it.word() != nullptr) {
985      it.forward();
986    }
987    ASSERT_HOST(it.word() == word_res);
988    WordData wd(it);
989    SetupWordPassN(1, &wd);
990    classify_word_and_language(pass_n, &it, &wd);
991    if (debug_noise_removal) {
992      if (wd.word->raw_choice != nullptr) {
993        tprintf("word xheight=%g, row=%g, range=[%g,%g]\n", word_res->x_height, wd.row->x_height(),
994                wd.word->raw_choice->min_x_height(), wd.word->raw_choice->max_x_height());
995      } else {
996        tprintf("Got word with null raw choice xheight=%g, row=%g\n", word_res->x_height,
997                wd.row->x_height());
998      }
999    }
1000    float cert = 0.0f;
1001    if (wd.word->raw_choice != nullptr) { 
1002      cert = wd.word->raw_choice->certainty();
1003      float rat = wd.word->raw_choice->rating();
1004      *c2 = rat > 0.0f ? cert * cert / rat : 0.0f;
1005      best_str = wd.word->raw_choice->unichar_string();
1006    } else {
1007      *c2 = 0.0f;
1008      best_str.clear();
1009    }
1010    it.DeleteCurrentWord();
1011    pr_it->ResetWordIterator();
1012    return cert;
1013  }
1014  #endif 
1015  void Tesseract::classify_word_and_language(int pass_n, PAGE_RES_IT *pr_it, WordData *word_data) {
1016  #ifdef DISABLED_LEGACY_ENGINE
1017    WordRecognizer recognizer = &Tesseract::classify_word_pass1;
1018  #else
1019    WordRecognizer recognizer =
1020        pass_n == 1 ? &Tesseract::classify_word_pass1 : &Tesseract::classify_word_pass2;
1021  #endif 
1022    PointerVector<WERD_RES> best_words;
1023    const WERD_RES *word = word_data->word;
1024    clock_t start_t = clock();
1025    const bool debug = classify_debug_level > 0 || multilang_debug_level > 0;
1026    if (debug) {
1027      tprintf("%s word with lang %s at:", word->done ? "Already done" : "Processing",
1028              most_recently_used_->lang.c_str());
1029      word->word->bounding_box().print();
1030    }
1031    if (word->done) {
1032      if (!word->tess_failed) {
1033        most_recently_used_ = word->tesseract;
1034      }
1035      return;
1036    }
1037    auto sub = sub_langs_.size();
1038    if (most_recently_used_ != this) {
1039      for (sub = 0; sub < sub_langs_.size() && most_recently_used_ != sub_langs_[sub]; ++sub) {
1040      }
1041    }
1042    most_recently_used_->RetryWithLanguage(*word_data, recognizer, debug, &word_data->lang_words[sub],
1043                                           &best_words);
1044    Tesseract *best_lang_tess = most_recently_used_;
1045    if (!WordsAcceptable(best_words)) {
1046      if (most_recently_used_ != this &&
1047          this->RetryWithLanguage(*word_data, recognizer, debug,
1048                                  &word_data->lang_words[sub_langs_.size()], &best_words) > 0) {
1049        best_lang_tess = this;
1050      }
1051      for (unsigned i = 0; !WordsAcceptable(best_words) && i < sub_langs_.size(); ++i) {
1052        if (most_recently_used_ != sub_langs_[i] &&
1053            sub_langs_[i]->RetryWithLanguage(*word_data, recognizer, debug, &word_data->lang_words[i],
1054                                             &best_words) > 0) {
1055          best_lang_tess = sub_langs_[i];
1056        }
1057      }
1058    }
1059    most_recently_used_ = best_lang_tess;
1060    if (!best_words.empty()) {
1061      if (best_words.size() == 1 && !best_words[0]->combination) {
1062        word_data->word->ConsumeWordResults(best_words[0]);
1063      } else {
1064        word_data->word = best_words.back();
1065        pr_it->ReplaceCurrentWord(&best_words);
1066      }
1067      ASSERT_HOST(word_data->word->box_word != nullptr);
1068    } else {
1069      tprintf("no best words!!\n");
1070    }
1071    clock_t ocr_t = clock();
1072    if (tessedit_timing_debug) {
1073      tprintf("%s (ocr took %.2f sec)\n", word_data->word->best_choice->unichar_string().c_str(),
1074              static_cast<double>(ocr_t - start_t) / CLOCKS_PER_SEC);
1075    }
1076  }
1077  void Tesseract::classify_word_pass1(const WordData &word_data, WERD_RES **in_word,
1078                                      PointerVector<WERD_RES> *out_words) {
1079    ROW *row = word_data.row;
1080    BLOCK *block = word_data.block;
1081    prev_word_best_choice_ =
1082        word_data.prev_word != nullptr ? word_data.prev_word->word->best_choice : nullptr;
1083  #ifdef DISABLED_LEGACY_ENGINE
1084    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1085  #else
1086    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY ||
1087        tessedit_ocr_engine_mode == OEM_TESSERACT_LSTM_COMBINED) {
1088  #endif 
1089      if (!(*in_word)->odd_size || tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1090        LSTMRecognizeWord(*block, row, *in_word, out_words);
1091        if (!out_words->empty()) {
1092          return; 
1093        }
1094      }
1095      if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1096        (*in_word)->SetupFake(lstm_recognizer_->GetUnicharset());
1097        return;
1098      }
1099  #ifndef DISABLED_LEGACY_ENGINE
1100      (*in_word)->SetupForRecognition(unicharset, this, BestPix(), OEM_TESSERACT_ONLY, nullptr,
1101                                      classify_bln_numeric_mode, textord_use_cjk_fp_model,
1102                                      poly_allow_detailed_fx, row, block);
1103  #endif 
1104    }
1105  #ifndef DISABLED_LEGACY_ENGINE
1106    WERD_RES *word = *in_word;
1107    match_word_pass_n(1, word, row, block);
1108    if (!word->tess_failed && !word->word->flag(W_REP_CHAR)) {
1109      word->tess_would_adapt = AdaptableWord(word);
1110      bool adapt_ok = word_adaptable(word, tessedit_tess_adaption_mode);
1111      if (adapt_ok) {
1112        word->BestChoiceToCorrectText();
1113        LearnWord(nullptr, word);
1114        if (word->blamer_bundle != nullptr) {
1115          word->blamer_bundle->SetMisAdaptionDebug(word->best_choice, wordrec_debug_blamer);
1116        }
1117      }
1118      if (tessedit_enable_doc_dict && !word->IsAmbiguous()) {
1119        tess_add_doc_word(word->best_choice);
1120      }
1121    }
1122  #endif 
1123  }
1124  void Tesseract::ReportXhtFixResult(bool accept_new_word, float new_x_ht, WERD_RES *word,
1125                                     WERD_RES *new_word) {
1126    tprintf("New XHT Match:%s = %s ", word->best_choice->unichar_string().c_str(),
1127            word->best_choice->debug_string().c_str());
1128    word->reject_map.print(debug_fp);
1129    tprintf(" -> %s = %s ", new_word->best_choice->unichar_string().c_str(),
1130            new_word->best_choice->debug_string().c_str());
1131    new_word->reject_map.print(debug_fp);
1132    tprintf(" %s->%s %s %s\n", word->guessed_x_ht ? "GUESS" : "CERT",
1133            new_word->guessed_x_ht ? "GUESS" : "CERT", new_x_ht > 0.1 ? "STILL DOUBT" : "OK",
1134            accept_new_word ? "ACCEPTED" : "");
1135  }
1136  #ifndef DISABLED_LEGACY_ENGINE
1137  bool Tesseract::TrainedXheightFix(WERD_RES *word, BLOCK *block, ROW *row) {
1138    int original_misfits = CountMisfitTops(word);
1139    if (original_misfits == 0) {
1140      return false;
1141    }
1142    float baseline_shift = 0.0f;
1143    float new_x_ht = ComputeCompatibleXheight(word, &baseline_shift);
1144    if (baseline_shift != 0.0f) {
1145      if (!TestNewNormalization(original_misfits, baseline_shift, word->x_height, word, block, row)) {
1146        return false;
1147      }
1148      original_misfits = CountMisfitTops(word);
1149      if (original_misfits > 0) {
1150        float new_baseline_shift;
1151        new_x_ht = ComputeCompatibleXheight(word, &new_baseline_shift);
1152        if (new_x_ht >= kMinRefitXHeightFraction * word->x_height) {
1153          TestNewNormalization(original_misfits, baseline_shift, new_x_ht, word, block, row);
1154        }
1155      }
1156      return true;
1157    } else if (new_x_ht >= kMinRefitXHeightFraction * word->x_height) {
1158      return TestNewNormalization(original_misfits, 0.0f, new_x_ht, word, block, row);
1159    } else {
1160      return false;
1161    }
1162  }
1163  bool Tesseract::TestNewNormalization(int original_misfits, float baseline_shift, float new_x_ht,
1164                                       WERD_RES *word, BLOCK *block, ROW *row) {
1165    bool accept_new_x_ht = false;
1166    WERD_RES new_x_ht_word(word->word);
1167    if (word->blamer_bundle != nullptr) {
1168      new_x_ht_word.blamer_bundle = new BlamerBundle();
1169      new_x_ht_word.blamer_bundle->CopyTruth(*(word->blamer_bundle));
1170    }
1171    new_x_ht_word.x_height = new_x_ht;
1172    new_x_ht_word.baseline_shift = baseline_shift;
1173    new_x_ht_word.caps_height = 0.0;
1174    new_x_ht_word.SetupForRecognition(unicharset, this, BestPix(), tessedit_ocr_engine_mode, nullptr,
1175                                      classify_bln_numeric_mode, textord_use_cjk_fp_model,
1176                                      poly_allow_detailed_fx, row, block);
1177    match_word_pass_n(2, &new_x_ht_word, row, block);
1178    if (!new_x_ht_word.tess_failed) {
1179      int new_misfits = CountMisfitTops(&new_x_ht_word);
1180      if (debug_x_ht_level >= 1) {
1181        tprintf("Old misfits=%d with x-height %f, new=%d with x-height %f\n", original_misfits,
1182                word->x_height, new_misfits, new_x_ht);
1183        tprintf("Old rating= %f, certainty=%f, new=%f, %f\n", word->best_choice->rating(),
1184                word->best_choice->certainty(), new_x_ht_word.best_choice->rating(),
1185                new_x_ht_word.best_choice->certainty());
1186      }
1187      accept_new_x_ht = new_misfits < original_misfits &&
1188                        (new_x_ht_word.best_choice->certainty() > word->best_choice->certainty() ||
1189                         new_x_ht_word.best_choice->rating() < word->best_choice->rating());
1190      if (debug_x_ht_level >= 1) {
1191        ReportXhtFixResult(accept_new_x_ht, new_x_ht, word, &new_x_ht_word);
1192      }
1193    }
1194    if (accept_new_x_ht) {
1195      word->ConsumeWordResults(&new_x_ht_word);
1196      return true;
1197    }
1198    return false;
1199  }
1200  #endif 
1201  void Tesseract::classify_word_pass2(const WordData &word_data, WERD_RES **in_word,
1202                                      PointerVector<WERD_RES> *out_words) {
1203    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
1204      return;
1205    }
1206  #ifndef DISABLED_LEGACY_ENGINE
1207    ROW *row = word_data.row;
1208    BLOCK *block = word_data.block;
1209    WERD_RES *word = *in_word;
1210    prev_word_best_choice_ =
1211        word_data.prev_word != nullptr ? word_data.prev_word->word->best_choice : nullptr;
1212    check_debug_pt(word, 30);
1213    if (!word->done) {
1214      word->caps_height = 0.0;
1215      if (word->x_height == 0.0f) {
1216        word->x_height = row->x_height();
1217      }
1218      match_word_pass_n(2, word, row, block);
1219      check_debug_pt(word, 40);
1220    }
1221    SubAndSuperscriptFix(word);
1222    if (!word->tess_failed && !word->word->flag(W_REP_CHAR)) {
1223      if (unicharset.top_bottom_useful() && unicharset.script_has_xheight() &&
1224          block->classify_rotation().y() == 0.0f) {
1225        TrainedXheightFix(word, block, row);
1226      }
1227    }
1228  #  ifndef GRAPHICS_DISABLED
1229    if (tessedit_display_outwords) {
1230      if (fx_win == nullptr) {
1231        create_fx_win();
1232      }
1233      clear_fx_win();
1234      word->rebuild_word->plot(fx_win);
1235      TBOX wbox = word->rebuild_word->bounding_box();
1236      fx_win->ZoomToRectangle(wbox.left(), wbox.top(), wbox.right(), wbox.bottom());
1237      ScrollView::Update();
1238    }
1239  #  endif
1240    check_debug_pt(word, 50);
1241  #endif 
1242  }
1243  #ifndef DISABLED_LEGACY_ENGINE
1244  void Tesseract::match_word_pass_n(int pass_n, WERD_RES *word, ROW *row, BLOCK *block) {
1245    if (word->tess_failed) {
1246      return;
1247    }
1248    tess_segment_pass_n(pass_n, word);
1249    if (!word->tess_failed) {
1250      if (!word->word->flag(W_REP_CHAR)) {
1251        word->fix_quotes();
1252        if (tessedit_fix_hyphens) {
1253          word->fix_hyphens();
1254        }
1255        if (static_cast<unsigned>(word->best_choice->length()) != word->box_word->length()) {
1256          tprintf(
1257              "POST FIX_QUOTES FAIL String:\"%s\"; Strlen=%d;"
1258              " #Blobs=%u\n",
1259              word->best_choice->debug_string().c_str(), word->best_choice->length(),
1260              word->box_word->length());
1261        }
1262        word->tess_accepted = tess_acceptable_word(word);
1263        make_reject_map(word, row, pass_n);
1264      }
1265    }
1266    set_word_fonts(word);
1267    ASSERT_HOST(word->raw_choice != nullptr);
1268  }
1269  #endif 
1270  static BLOB_CHOICE *FindBestMatchingChoice(UNICHAR_ID char_id, WERD_RES *word_res) {
1271    BLOB_CHOICE *best_choice = nullptr;
1272    for (unsigned i = 0; i < word_res->best_choice->length(); ++i) {
1273      BLOB_CHOICE *choice = FindMatchingChoice(char_id, word_res->GetBlobChoices(i));
1274      if (choice != nullptr) {
1275        if (best_choice == nullptr || choice->rating() < best_choice->rating()) {
1276          best_choice = choice;
1277        }
1278      }
1279    }
1280    return best_choice;
1281  }
1282  static void CorrectRepcharChoices(BLOB_CHOICE *blob_choice, WERD_RES *word_res) {
1283    WERD_CHOICE *word = word_res->best_choice;
1284    for (unsigned i = 0; i < word_res->best_choice->length(); ++i) {
1285      BLOB_CHOICE *choice =
1286          FindMatchingChoice(blob_choice->unichar_id(), word_res->GetBlobChoices(i));
1287      if (choice == nullptr) {
1288        BLOB_CHOICE_IT choice_it(word_res->GetBlobChoices(i));
1289        choice_it.add_before_stay_put(new BLOB_CHOICE(*blob_choice));
1290      }
1291    }
1292    for (unsigned i = 0; i < word->length(); ++i) {
1293      if (word->unichar_id(i) != blob_choice->unichar_id()) {
1294        word->set_unichar_id(blob_choice->unichar_id(), i);
1295      }
1296    }
1297  }
1298  void Tesseract::fix_rep_char(PAGE_RES_IT *page_res_it) {
1299    WERD_RES *word_res = page_res_it->word();
1300    const WERD_CHOICE &word = *(word_res->best_choice);
1301    SortHelper<UNICHAR_ID> rep_ch(word.length());
1302    for (unsigned i = 0; i < word.length(); ++i) {
1303      rep_ch.Add(word.unichar_id(i), 1);
1304    }
1305    UNICHAR_ID maxch_id = INVALID_UNICHAR_ID; 
1306    int max_count = rep_ch.MaxCount(&maxch_id);
1307    BLOB_CHOICE *best_choice = FindBestMatchingChoice(maxch_id, word_res);
1308    if (best_choice == nullptr) {
1309      tprintf("Failed to find a choice for %s, occurring %d times\n",
1310              word_res->uch_set->debug_str(maxch_id).c_str(), max_count);
1311      return;
1312    }
1313    word_res->done = true;
1314    CorrectRepcharChoices(best_choice, word_res);
1315    word_res->reject_map.initialise(word.length());
1316  }
1317  ACCEPTABLE_WERD_TYPE Tesseract::acceptable_word_string(const UNICHARSET &char_set, const char *s,
1318                                                         const char *lengths) {
1319    int i = 0;
1320    int offset = 0;
1321    int leading_punct_count;
1322    int upper_count = 0;
1323    int hyphen_pos = -1;
1324    ACCEPTABLE_WERD_TYPE word_type = AC_UNACCEPTABLE;
1325    if (strlen(lengths) > 20) {
1326      return word_type;
1327    }
1328    if (s[offset] != '\0' && chs_leading_punct.contains(s[offset])) {
1329      offset += lengths[i++];
1330    }
1331    leading_punct_count = i;
1332    while (s[offset] != '\0' && char_set.get_isupper(s + offset, lengths[i])) {
1333      offset += lengths[i++];
1334      upper_count++;
1335    }
1336    if (upper_count > 1) {
1337      word_type = AC_UPPER_CASE;
1338    } else {
1339      while (s[offset] != '\0' && char_set.get_islower(s + offset, lengths[i])) {
1340        offset += lengths[i++];
1341      }
1342      if (i - leading_punct_count < quality_min_initial_alphas_reqd) {
1343        goto not_a_word;
1344      }
1345      if (lengths[i] == 1 && s[offset] == '-') {
1346        hyphen_pos = i;
1347        offset += lengths[i++];
1348        if (s[offset] != '\0') {
1349          while ((s[offset] != '\0') && char_set.get_islower(s + offset, lengths[i])) {
1350            offset += lengths[i++];
1351          }
1352          if (i < hyphen_pos + 3) {
1353            goto not_a_word;
1354          }
1355        }
1356      } else {
1357        if (lengths[i] == 1 && (s[offset] == '\'') && lengths[i + 1] == 1 &&
1358            (s[offset + lengths[i]] == 's')) {
1359          offset += lengths[i++];
1360          offset += lengths[i++];
1361        }
1362      }
1363      if (upper_count > 0) {
1364        word_type = AC_INITIAL_CAP;
1365      } else {
1366        word_type = AC_LOWER_CASE;
1367      }
1368    }
1369    if (lengths[i] == 1 && s[offset] != '\0' && chs_trailing_punct1.contains(s[offset])) {
1370      offset += lengths[i++];
1371    }
1372    if (lengths[i] == 1 && s[offset] != '\0' && i > 0 && s[offset - lengths[i - 1]] != s[offset] &&
1373        chs_trailing_punct2.contains(s[offset])) {
1374      offset += lengths[i++];
1375    }
1376    if (s[offset] != '\0') {
1377      word_type = AC_UNACCEPTABLE;
1378    }
1379  not_a_word:
1380    if (word_type == AC_UNACCEPTABLE) {
1381      i = 0;
1382      offset = 0;
1383      if (s[0] != '\0' && char_set.get_isupper(s, lengths[0])) {
1384        word_type = AC_UC_ABBREV;
1385        while (s[offset] != '\0' && char_set.get_isupper(s + offset, lengths[i]) &&
1386               lengths[i + 1] == 1 && s[offset + lengths[i]] == '.') {
1387          offset += lengths[i++];
1388          offset += lengths[i++];
1389        }
1390      } else if (s[0] != '\0' && char_set.get_islower(s, lengths[0])) {
1391        word_type = AC_LC_ABBREV;
1392        while (s[offset] != '\0' && char_set.get_islower(s + offset, lengths[i]) &&
1393               lengths[i + 1] == 1 && s[offset + lengths[i]] == '.') {
1394          offset += lengths[i++];
1395          offset += lengths[i++];
1396        }
1397      }
1398      if (s[offset] != '\0') {
1399        word_type = AC_UNACCEPTABLE;
1400      }
1401    }
1402    return word_type;
1403  }
1404  bool Tesseract::check_debug_pt(WERD_RES *word, int location) {
1405    bool show_map_detail = false;
1406    int16_t i;
1407    if (!test_pt) {
1408      return false;
1409    }
1410    tessedit_rejection_debug.set_value(false);
1411    debug_x_ht_level.set_value(0);
1412    if (word->word->bounding_box().contains(FCOORD(test_pt_x, test_pt_y))) {
1413      if (location < 0) {
1414        return true; 
1415      }
1416      tessedit_rejection_debug.set_value(true);
1417      debug_x_ht_level.set_value(2);
1418      tprintf("\n\nTESTWD::");
1419      switch (location) {
1420        case 0:
1421          tprintf("classify_word_pass1 start\n");
1422          word->word->print();
1423          break;
1424        case 10:
1425          tprintf("make_reject_map: initial map");
1426          break;
1427        case 20:
1428          tprintf("make_reject_map: after NN");
1429          break;
1430        case 30:
1431          tprintf("classify_word_pass2 - START");
1432          break;
1433        case 40:
1434          tprintf("classify_word_pass2 - Pre Xht");
1435          break;
1436        case 50:
1437          tprintf("classify_word_pass2 - END");
1438          show_map_detail = true;
1439          break;
1440        case 60:
1441          tprintf("fixspace");
1442          break;
1443        case 70:
1444          tprintf("MM pass START");
1445          break;
1446        case 80:
1447          tprintf("MM pass END");
1448          break;
1449        case 90:
1450          tprintf("After Poor quality rejection");
1451          break;
1452        case 100:
1453          tprintf("unrej_good_quality_words - START");
1454          break;
1455        case 110:
1456          tprintf("unrej_good_quality_words - END");
1457          break;
1458        case 120:
1459          tprintf("Write results pass");
1460          show_map_detail = true;
1461          break;
1462      }
1463      if (word->best_choice != nullptr) {
1464        tprintf(" \"%s\" ", word->best_choice->unichar_string().c_str());
1465        word->reject_map.print(debug_fp);
1466        tprintf("\n");
1467        if (show_map_detail) {
1468          tprintf("\"%s\"\n", word->best_choice->unichar_string().c_str());
1469          for (i = 0; word->best_choice->unichar_string()[i] != '\0'; i++) {
1470            tprintf("**** \"%c\" ****\n", word->best_choice->unichar_string()[i]);
1471            word->reject_map[i].full_print(debug_fp);
1472          }
1473        }
1474      } else {
1475        tprintf("null best choice\n");
1476      }
1477      tprintf("Tess Accepted: %s\n", word->tess_accepted ? "TRUE" : "FALSE");
1478      tprintf("Done flag: %s\n\n", word->done ? "TRUE" : "FALSE");
1479      return true;
1480    } else {
1481      return false;
1482    }
1483  }
1484  #ifndef DISABLED_LEGACY_ENGINE
1485  static void find_modal_font( 
1486      STATS *fonts,            
1487      int16_t *font_out,       
1488      int8_t *font_count       
1489  ) {
1490    int16_t font;  
1491    int32_t count; 
1492    if (fonts->get_total() > 0) {
1493      font = static_cast<int16_t>(fonts->mode());
1494      *font_out = font;
1495      count = fonts->pile_count(font);
1496      *font_count = count < INT8_MAX ? count : INT8_MAX;
1497      fonts->add(font, -*font_count);
1498    } else {
1499      *font_out = -1;
1500      *font_count = 0;
1501    }
1502  }
1503  #endif 
1504  void Tesseract::set_word_fonts(WERD_RES *word) {
1505    if (word->chopped_word == nullptr) {
1506      return;
1507    }
1508    ASSERT_HOST(word->best_choice != nullptr);
1509  #ifndef DISABLED_LEGACY_ENGINE
1510    const int fontinfo_size = fontinfo_table_.size();
1511    if (fontinfo_size == 0) {
1512      return;
1513    }
1514    if (tessedit_font_id > 0) {
1515      if (tessedit_font_id >= fontinfo_size) {
1516        tprintf("Error, invalid font ID provided: must be below %d.\n"
1517                "Falling back to font auto-detection.\n", fontinfo_size);
1518      } else {
1519        word->fontinfo = &fontinfo_table_.at(tessedit_font_id);
1520        word->fontinfo2 = nullptr;
1521        word->fontinfo_id_count = INT8_MAX;
1522        word->fontinfo_id2_count = 0;
1523        return;
1524      }
1525    }
1526    std::vector<int> font_total_score(fontinfo_size);
1527    if (tessedit_debug_fonts) {
1528      tprintf("Examining fonts in %s\n", word->best_choice->debug_string().c_str());
1529    }
1530    for (unsigned b = 0; b < word->best_choice->length(); ++b) {
1531      const BLOB_CHOICE *choice = word->GetBlobChoice(b);
1532      if (choice == nullptr) {
1533        continue;
1534      }
1535      auto &fonts = choice->fonts();
1536      for (auto &f : fonts) {
1537        const int fontinfo_id = f.fontinfo_id;
1538        if (0 <= fontinfo_id && fontinfo_id < fontinfo_size) {
1539          font_total_score[fontinfo_id] += f.score;
1540        }
1541      }
1542    }
1543    int score1 = 0, score2 = 0;
1544    int16_t font_id1 = -1, font_id2 = -1;
1545    for (int f = 0; f < fontinfo_size; ++f) {
1546      if (tessedit_debug_fonts && font_total_score[f] > 0) {
1547        tprintf("Font %s, total score = %d\n", fontinfo_table_.at(f).name, font_total_score[f]);
1548      }
1549      if (font_total_score[f] > score1) {
1550        score2 = score1;
1551        font_id2 = font_id1;
1552        score1 = font_total_score[f];
1553        font_id1 = f;
1554      } else if (font_total_score[f] > score2) {
1555        score2 = font_total_score[f];
1556        font_id2 = f;
1557      }
1558    }
1559    word->fontinfo = font_id1 >= 0 ? &fontinfo_table_.at(font_id1) : nullptr;
1560    word->fontinfo2 = font_id2 >= 0 ? &fontinfo_table_.at(font_id2) : nullptr;
1561    word->fontinfo_id_count = ClipToRange<int>(score1 / UINT16_MAX, 1, INT8_MAX);
1562    word->fontinfo_id2_count = ClipToRange<int>(score2 / UINT16_MAX, 0, INT8_MAX);
1563    if (score1 > 0) {
1564      const FontInfo fi = fontinfo_table_.at(font_id1);
1565      if (tessedit_debug_fonts) {
1566        if (word->fontinfo_id2_count > 0 && font_id2 >= 0) {
1567          tprintf("Word modal font=%s, score=%d, 2nd choice %s/%d\n", fi.name,
1568                  word->fontinfo_id_count, fontinfo_table_.at(font_id2).name,
1569                  word->fontinfo_id2_count);
1570        } else {
1571          tprintf("Word modal font=%s, score=%d. No 2nd choice\n", fi.name, word->fontinfo_id_count);
1572        }
1573      }
1574    }
1575  #endif 
1576  }
1577  #ifndef DISABLED_LEGACY_ENGINE
1578  void Tesseract::font_recognition_pass(PAGE_RES *page_res) {
1579    PAGE_RES_IT page_res_it(page_res);
1580    WERD_RES *word;                       
1581    STATS doc_fonts(0, font_table_size_ - 1); 
1582    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1583      word = page_res_it.word();
1584      if (word->fontinfo != nullptr) {
1585        doc_fonts.add(word->fontinfo->universal_id, word->fontinfo_id_count);
1586      }
1587      if (word->fontinfo2 != nullptr) {
1588        doc_fonts.add(word->fontinfo2->universal_id, word->fontinfo_id2_count);
1589      }
1590    }
1591    int16_t doc_font;      
1592    int8_t doc_font_count; 
1593    find_modal_font(&doc_fonts, &doc_font, &doc_font_count);
1594    if (doc_font_count == 0) {
1595      return;
1596    }
1597    const FontInfo *modal_font = nullptr;
1598    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1599      word = page_res_it.word();
1600      if (word->fontinfo != nullptr && word->fontinfo->universal_id == doc_font) {
1601        modal_font = word->fontinfo;
1602        break;
1603      }
1604      if (word->fontinfo2 != nullptr && word->fontinfo2->universal_id == doc_font) {
1605        modal_font = word->fontinfo2;
1606        break;
1607      }
1608    }
1609    ASSERT_HOST(modal_font != nullptr);
1610    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
1611      word = page_res_it.word();
1612      const int length = word->best_choice->length();
1613      const int count = word->fontinfo_id_count;
1614      if (!(count == length || (length > 3 && count >= length * 3 / 4))) {
1615        word->fontinfo = modal_font;
1616        word->fontinfo_id_count = 1;
1617      }
1618    }
1619  }
1620  #endif 
1621  void Tesseract::dictionary_correction_pass(PAGE_RES *page_res) {
1622    PAGE_RES_IT word_it(page_res);
1623    for (WERD_RES *word = word_it.word(); word != nullptr; word = word_it.forward()) {
1624      if (word->best_choices.singleton()) {
1625        continue; 
1626      }
1627      const WERD_CHOICE *best = word->best_choice;
1628      if (word->tesseract->getDict().valid_word(*best) != 0) {
1629        continue; 
1630      }
1631      WERD_CHOICE_IT choice_it(&word->best_choices);
1632      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
1633        WERD_CHOICE *alternate = choice_it.data();
1634        if (word->tesseract->getDict().valid_word(*alternate)) {
1635          if (tessedit_bigram_debug) {
1636            tprintf("Dictionary correction replaces best choice '%s' with '%s'\n",
1637                    best->unichar_string().c_str(), alternate->unichar_string().c_str());
1638          }
1639          word->ReplaceBestChoice(alternate);
1640          break;
1641        }
1642      }
1643    }
1644  }
1645  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_cat_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-control.cpp</div>
                </div>
                <div class="column column_space"><pre><code>342  }
343  #endif  
344  TEST(StrAppend, CornerCases) {
345    std::string result;
346    absl::StrAppend(&result, "");
347    EXPECT_EQ(result, "");
348    absl::StrAppend(&result, "", "");
349    EXPECT_EQ(result, "");
350    absl::StrAppend(&result, "", "", "");
351    EXPECT_EQ(result, "");
352    absl::StrAppend(&result, "", "", "", "");
353    EXPECT_EQ(result, "");
354    absl::StrAppend(&result, "", "", "", "", "");
</pre></code></div>
                <div class="column column_space"><pre><code>743  }
744  void Tesseract::AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines,
745                                                     int pass, WERD *real_word, PAGE_RES_IT *pr_it,
746                                                     std::vector<bool> *word_wanted,
747                                                     std::vector<bool> *overlapped_any_blob,
748                                                     std::vector<C_BLOB *> *target_blobs) {
749    std::vector<bool> blob_wanted;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    