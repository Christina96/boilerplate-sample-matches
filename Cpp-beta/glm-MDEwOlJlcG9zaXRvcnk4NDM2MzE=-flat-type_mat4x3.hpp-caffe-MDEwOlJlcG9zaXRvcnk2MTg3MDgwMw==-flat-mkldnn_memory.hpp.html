
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.686274509803921%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type_mat4x3.hpp</h3>
            <pre><code>1  #ifndef glm_core_type_mat4x3
2  #define glm_core_type_mat4x3
3  #include "type_mat.hpp"
4  namespace glm{
5  namespace detail
6  {
7  	template <typename T> struct tvec1;
8  	template <typename T> struct tvec2;
9  	template <typename T> struct tvec3;
10  	template <typename T> struct tvec4;
11  	template <typename T> struct tmat2x2;
12  	template <typename T> struct tmat2x3;
13  	template <typename T> struct tmat2x4;
14  	template <typename T> struct tmat3x2;
15  	template <typename T> struct tmat3x3;
16  	template <typename T> struct tmat3x4;
17  	template <typename T> struct tmat4x2;
18  	template <typename T> struct tmat4x3;
19  	template <typename T> struct tmat4x4;
20  	template <typename T> 
21  	struct tmat4x3
22  	{
23  		enum ctor{null};
24  		typedef T value_type;
25  		typedef std::size_t size_type;
26  		typedef tvec3<T> col_type;
27  		typedef tvec4<T> row_type;
28          GLM_FUNC_DECL size_type length() const;
29  		static GLM_FUNC_DECL size_type col_size();
30  		static GLM_FUNC_DECL size_type row_size();
31  		typedef tmat4x3<T> type;
32  		typedef tmat3x4<T> transpose_type;
33  	private:
34  		col_type value[4];
35  	public:
36  		GLM_FUNC_DECL tmat4x3();
37  		GLM_FUNC_DECL tmat4x3(tmat4x3 const & m);
38  		GLM_FUNC_DECL explicit tmat4x3(
39  			ctor Null);
40  		GLM_FUNC_DECL explicit tmat4x3(
41  			value_type const & x);
42  		GLM_FUNC_DECL explicit tmat4x3(
43  			value_type const & x0, value_type const & y0, value_type const & z0,
44  			value_type const & x1, value_type const & y1, value_type const & z1,
45  			value_type const & x2, value_type const & y2, value_type const & z2,
46  			value_type const & x3, value_type const & y3, value_type const & z3);
47  		GLM_FUNC_DECL explicit tmat4x3(
48  			col_type const & v0, 
49  			col_type const & v1,
50  			col_type const & v2,
51              col_type const & v3);
52  		template <typename U> 
53  		GLM_FUNC_DECL explicit tmat4x3(
54              U const & x);
55  		template <
56              typename X1, typename Y1, typename Z1, 
57              typename X2, typename Y2, typename Z2, 
58              typename X3, typename Y3, typename Z3, 
59              typename X4, typename Y4, typename Z4> 
60  		GLM_FUNC_DECL explicit tmat4x3(
<span onclick='openModal()' class='match'>61              X1 const & x1, Y1 const & y1, Z1 const & z1, 
62              X2 const & x2, Y2 const & y2, Z2 const & z2, 
63              X3 const & x3, Y3 const & y3, Z3 const & z3, 
64              X4 const & x4, Y4 const & y4, Z4 const & z4);
</span>65  		template <typename V1, typename V2, typename V3, typename V4> 
66  		GLM_FUNC_DECL explicit tmat4x3(
67              tvec3<V1> const & v1, 
68              tvec3<V2> const & v2,
69              tvec3<V3> const & v3,
70              tvec3<V4> const & v4);
71  		template <typename U> 
72  		GLM_FUNC_DECL explicit tmat4x3(tmat4x3<U> const & m);
73  		GLM_FUNC_DECL explicit tmat4x3(tmat2x2<T> const & x);
74  		GLM_FUNC_DECL explicit tmat4x3(tmat3x3<T> const & x);
75  		GLM_FUNC_DECL explicit tmat4x3(tmat4x4<T> const & x);
76  		GLM_FUNC_DECL explicit tmat4x3(tmat2x3<T> const & x);
77  		GLM_FUNC_DECL explicit tmat4x3(tmat3x2<T> const & x);
78  		GLM_FUNC_DECL explicit tmat4x3(tmat2x4<T> const & x);
79  		GLM_FUNC_DECL explicit tmat4x3(tmat4x2<T> const & x);
80  		GLM_FUNC_DECL explicit tmat4x3(tmat3x4<T> const & x);
81  		col_type & operator[](size_type i);
82  		col_type const & operator[](size_type i) const;
83  		GLM_FUNC_DECL tmat4x3<T> & operator=  (tmat4x3<T> const & m);
84  		template <typename U> 
85  		GLM_FUNC_DECL tmat4x3<T> & operator=  (tmat4x3<U> const & m);
86  		template <typename U> 
87  		GLM_FUNC_DECL tmat4x3<T> & operator+= (U const & s);
88  		template <typename U> 
89  		GLM_FUNC_DECL tmat4x3<T> & operator+= (tmat4x3<U> const & m);
90  		template <typename U> 
91  		GLM_FUNC_DECL tmat4x3<T> & operator-= (U const & s);
92  		template <typename U> 
93  		GLM_FUNC_DECL tmat4x3<T> & operator-= (tmat4x3<U> const & m);
94  		template <typename U> 
95  		GLM_FUNC_DECL tmat4x3<T> & operator*= (U const & s);
96  		template <typename U> 
97  		GLM_FUNC_DECL tmat4x3<T> & operator*= (tmat4x3<U> const & m);
98  		template <typename U> 
99  		GLM_FUNC_DECL tmat4x3<T> & operator/= (U const & s);
100  		GLM_FUNC_DECL tmat4x3<T> & operator++ ();
101  		GLM_FUNC_DECL tmat4x3<T> & operator-- ();
102  	};
103  	template <typename T> 
104  	tmat4x3<T> operator+ (
105  		tmat4x3<T> const & m, 
106  		typename tmat4x3<T>::value_type const & s);
107  	template <typename T> 
108  	tmat4x3<T> operator+ (
109  		tmat4x3<T> const & m1, 
110  		tmat4x3<T> const & m2);
111  	template <typename T> 
112  	tmat4x3<T> operator- (
113  		tmat4x3<T> const & m, 
114  		typename tmat4x3<T>::value_type const & s);
115  	template <typename T> 
116  	tmat4x3<T> operator- (
117  		tmat4x3<T> const & m1, 
118  		tmat4x3<T> const & m2);
119  	template <typename T> 
120  	tmat4x3<T> operator* (
121  		tmat4x3<T> const & m, 
122  		typename tmat4x3<T>::value_type const & s);
123  	template <typename T> 
124  	tmat4x3<T> operator* (
125  		typename tmat4x3<T>::value_type const & s, 
126  		tmat4x3<T> const & m);
127  	template <typename T>
128  	typename tmat4x3<T>::col_type operator* (
129  		tmat4x3<T> const & m, 
130  		typename tmat4x3<T>::row_type const & v);
131  	template <typename T> 
132  	typename tmat4x3<T>::row_type operator* (
133  		typename tmat4x3<T>::col_type const & v, 
134  		tmat4x3<T> const & m);
135  	template <typename T> 
136  	tmat2x3<T> operator* (
137  		tmat4x3<T> const & m1, 
138  		tmat2x4<T> const & m2);
139  	template <typename T> 
140  	tmat3x3<T> operator* (
141  		tmat4x3<T> const & m1, 
142  		tmat3x4<T> const & m2);
143  	template <typename T>
144  	tmat4x3<T> operator* (
145  		tmat4x3<T> const & m1, 
146  		tmat4x4<T> const & m2);
147  	template <typename T> 
148  	tmat4x3<T> operator/ (
149  		tmat4x3<T> const & m, 
150  		typename tmat4x3<T>::value_type const & s);
151  	template <typename T> 
152  	tmat4x3<T> operator/ (
153  		typename tmat4x3<T>::value_type const & s, 
154  		tmat4x3<T> const & m);
155  	template <typename T> 
156  	tmat4x3<T> const operator- (
157  		tmat4x3<T> const & m);
158  	template <typename T> 
159  	tmat4x3<T> const operator-- (
160  		tmat4x3<T> const & m, 
161  		int);
162  	template <typename T> 
163  	tmat4x3<T> const operator++ (
164  		tmat4x3<T> const & m, 
165  		int);
166  }
167  	typedef detail::tmat4x3<lowp_float>		lowp_mat4x3;
168  	typedef detail::tmat4x3<mediump_float>	mediump_mat4x3;
169  	typedef detail::tmat4x3<highp_float>	highp_mat4x3;
170  }
171  #ifndef GLM_EXTERNAL_TEMPLATE
172  #include "type_mat4x3.inl"
173  #endif 
174  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_memory.hpp</h3>
            <pre><code>1  #ifndef CAFFE_MKLDNN_MEMORY_HPP_
2  #define CAFFE_MKLDNN_MEMORY_HPP_
3  #include <string>
4  #include <vector>
5  #include <boost/interprocess/shared_memory_object.hpp>
6  #include <boost/interprocess/mapped_region.hpp>
7  #include "boost/enable_shared_from_this.hpp"
8  #include "caffe/blob.hpp"
9  #include "caffe/common.hpp"
10  #include "caffe/util/math_functions.hpp"
11  #include "mkldnn.hpp"
12  #include "mkldnn_base.hpp"
13  #include "caffe/syncedmem.hpp"
14  #include "caffe/net.hpp"
15  using namespace mkldnn;
16  using namespace boost::interprocess;
17  namespace caffe {
18  template <typename Dtype>
19  class MKLDNNMemoryDescriptorBase : public PrvMemDescr
20          , public boost::enable_shared_from_this<MKLDNNMemoryDescriptorBase<Dtype> >
21  {
22  public:
<span onclick='openModal()' class='match'>23      MKLDNNMemoryDescriptorBase(shared_ptr<memory::primitive_desc> usr_memory_pd
24                                  , shared_ptr<memory::primitive_desc> prv_memory_pd
25                                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
</span>26                                  , std::vector<float>scale=std::vector<float>(1,1.)
27                                  , int mask=0
28                                  , bool is_sum=false
29                                  , bool is_wino=false
30                                  , bool is_weight=false
31                                  , std::string _name="");
32      ~MKLDNNMemoryDescriptorBase() {}
33      virtual void convert_from_other(shared_ptr<PrvMemDescr> other);
34      virtual bool layout_compare(shared_ptr<PrvMemDescr> other);
35      virtual PrvDescrType get_descr_type() {return PRV_DESCR_MKLDNN;}
36      virtual size_t prv_count() { return prv_size()/sizeof(Dtype); }
37      virtual size_t prv_size() { return _prv_memory_pd->get_size(); }
38      shared_ptr<MKLDNNMemoryDescriptorBase<Dtype> > get_shared_ptr() {
39          return this->shared_from_this();
40      }
41      shared_ptr<memory::primitive_desc>  prv_memory_pd() const {
42          return _prv_memory_pd;
43      }
44      shared_ptr<memory::primitive_desc>  usr_memory_pd() const {
45          return _usr_memory_pd;
46      }
47      inline bool conversion_needed() const { return (_reorder_usr2prv_pd != NULL || _reorder_extprv2prv_pd != NULL); }
48      virtual void* prv_ptr() { return _internal_ptr;  }
49      shared_ptr<memory>  get_prv_memory()
50      {
51          if (_prv_memory == NULL) allocate();
52          return _prv_memory;
53      }
54      Dtype* get_prv_ptr() {
55          if (_prv_memory == NULL) allocate();
56          return _internal_ptr;
57      }
58      shared_ptr<primitive>  reorder_usr2prv() { return _reorder_usr2prv.aprimitive; }
59      shared_ptr<primitive>  reorder_prv2usr() { return _reorder_prv2usr.aprimitive; }
60      shared_ptr<primitive>  reorder_extprv2prv() { return _reorder_extprv2prv.aprimitive; }
61      float get_scale(int i) { return _scale[i]; }
62      std::vector<float> get_scale() { return _scale; }
63      void set_scale(std::vector<float> scale) { _scale.assign(scale.begin(),scale.end());}
64      void set_sum(bool is_sum) { _is_sum = is_sum; }
65      bool get_sum() { return _is_sum; }
66      void set_mkldnn_layer(MKLDNNLayer<Dtype>* layer) { _mkldnn_layer = layer;  }
67      MKLDNNLayer<Dtype>*  mkldnn_layer() const { return _mkldnn_layer;  }
68      std::string name;  
69      shared_memory_object *shm;
70      mapped_region *region;
71  protected:
72      void check_usr_with_prv_descriptors();
73      void set_prv_memory(shared_ptr<memory> memory)
74      {
75          _prv_memory = memory;
76          _internal_ptr = (Dtype *)(_prv_memory->get_data_handle());
77      }
78      void allocate() {
79          if (_prv_memory == NULL) {
80  #ifdef USE_MLSL
81            if (mn::is_multinode()) {
82              auto mlsl_free = [](char* p) { mn::free((void*)p); };
83              _mlsl_memory.reset(
84                (char*)mn::alloc(_prv_memory_pd->get_size(), 64), mlsl_free);
85              _prv_memory = shared_ptr<memory>(
86                new memory(*_prv_memory_pd, (void*)_mlsl_memory.get()));
87            } else {
88  #endif
89              if (CircleBuf::Instance()->GetBufSize()) {
90                if (!_is_weight) {
91                  _m_memory = CircleBuf::Instance()->GetFreeBuf();
92                } else {
93                  if (getenv("CAFFE_INFERENCE_WEIGHT_SHARING")) {
94                    shm = new shared_memory_object(open_or_create, name.c_str(), read_write);
95                    shm->truncate(_prv_memory_pd->get_size());
96                    region = new mapped_region(*shm, read_write);
97                    _m_memory = region->get_address();
98                  } else {
99                    bool cuda;
100                    CaffeMallocHost(&_m_memory, _prv_memory_pd->get_size(), &cuda);
101                  }
102                }
103                _prv_memory = shared_ptr<memory>(new memory(*_prv_memory_pd, _m_memory));
104              } else
105                _prv_memory = shared_ptr<memory>(new memory(*_prv_memory_pd));
106  #ifdef USE_MLSL
107            }
108  #endif
109            _internal_ptr = (Dtype *)(_prv_memory->get_data_handle());
110          }
111      }
112      void set_prv_memory_pd(shared_ptr<memory::primitive_desc> memory_pd, std::vector<float> scale, int mask, bool is_wino, bool is_weight)  {
113          _prv_memory_pd = memory_pd;
114          if (_prv_memory_pd && _usr_memory_pd) {
115              check_usr_with_prv_descriptors();
116              std::vector<float>scale_ext = std::vector<float>(1,1.);            
117              this->create_reorder_descriptors(scale, mask, scale_ext, false, is_wino, is_weight);
118          }
119      }
120      void set_extprv_memory_pd(shared_ptr<memory::primitive_desc> memory_pd, std::vector<float> scale, std::vector<float> scale_ext, bool is_sum)  {
121          _extprv_memory_pd = memory_pd;
122          if (_prv_memory_pd && _usr_memory_pd) {
123              check_usr_with_prv_descriptors();
124              this->create_reorder_descriptors(scale, 0, scale_ext, is_sum);
125          }
126      }
127      void set_usr_memory_pd(shared_ptr<memory::primitive_desc> memory_pd, std::vector<float> scale) {
128          _usr_memory_pd = memory_pd;
129      }
130      void create_reorder_descriptors(std::vector<float> scale, int mask=0, std::vector<float>scale_ext=std::vector<float>(1,1.), bool is_sum=false, bool is_wino=false, bool is_weight=false);
131      shared_ptr<memory::primitive_desc> _usr_memory_pd;
132      shared_ptr<memory::primitive_desc> _prv_memory_pd;
133      shared_ptr<memory::primitive_desc> _extprv_memory_pd;
134      shared_ptr<reorder::primitive_desc> _reorder_usr2prv_pd;
135      shared_ptr<reorder::primitive_desc> _reorder_prv2usr_pd;
136      shared_ptr<reorder::primitive_desc> _reorder_extprv2prv_pd;
137      MKLDNNPrimitive<Dtype> _reorder_usr2prv;
138      MKLDNNPrimitive<Dtype> _reorder_prv2usr;
139      MKLDNNPrimitive<Dtype> _reorder_extprv2prv;
140      shared_ptr<memory> _prv_memory;
141      Dtype* _internal_ptr;
142      shared_ptr<memory> _usr_memory;
143      void* _cpu_ptr;
144  #ifdef CO_SIM
145      shared_ptr<memory> _usr_memory_cosim;
146      MKLDNNPrimitive<Dtype> _reorder_prv2usr_cosim;
147      shared_ptr<memory> _prv_memory_cosim;
148      shared_ptr<primitive::at>  at_prv_cosim;
149  #endif
150      MKLDNNLayer<Dtype>* _mkldnn_layer;
151      Blob<Dtype>* _blob;
152      std::vector<float> _scale = std::vector<float>(1,1.);
153      bool _is_sum = false;
154  #ifdef USE_MLSL
155      shared_ptr<char> _mlsl_memory;
156  #endif
157      void* _m_memory;
158      bool _is_weight;
159  };
160  template <typename Dtype, bool is_diff>
161  class MKLDNNMemoryDescriptor : public MKLDNNMemoryDescriptorBase<Dtype> {
162  public:
163      MKLDNNMemoryDescriptor(shared_ptr<memory::primitive_desc> usr_memory_pd
164                          , shared_ptr<memory::primitive_desc> prv_memory_pd
165                          , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
166                          , std::vector<float> scale=std::vector<float>(1,1.)
167                          , int mask=0
168                          , bool is_sum=false
169                          , bool is_wino=false
170                          , bool is_weight=false
171                          , std::string name="");
172      virtual void convert_from_prv(void* cpu_ptr);
173      virtual void convert_to_prv(void* cpu_ptr);
174      virtual void convert_from_extprv(shared_ptr<primitive> aprimitive);
175      virtual bool on_to_cpu();
176  #ifdef CO_SIM
177      virtual void create_reorder_from_prv_cosim(void* cpu_ptr);
178      virtual void convert_from_prv_cosim(void* cpu_ptr);
179  #endif
180      virtual void create_reorder_from_prv(void* cpu_ptr);
181      virtual void create_reorder_to_prv(void* cpu_ptr);
182      virtual void create_reorder_from_extprv(shared_ptr<primitive> aprimitive);
183      shared_ptr<primitive> get_blob_prv_primitive(Blob<Dtype> * blob, bool set_prv_ptr, bool convert = true,
184              MKLDNNMemoryDescriptor<Dtype, is_diff>* converted_in_fwd = NULL);
185      void sync_before_read();
186      void sync_before_write(bool inplace = false);
187      shared_ptr<primitive> create_input(Blob<Dtype> * blob, bool set_prv_ptr);
188      shared_ptr<memory> create_output_memory(Blob<Dtype> * blob, bool inplace = false);
189      shared_ptr<primitive> create_input(bool set_prv_ptr);
190      shared_ptr<memory> create_output_memory(bool inplace = false);
191      Dtype* get_memory_ptr(long offset = 0);
192      shared_ptr<memory::desc> get_memory_desc();
193      size_t get_memory_count();
194      void set_mkldnn_primitive(MKLDNNPrimitive<Dtype>& mprimitive) { CHECK(mprimitive.aprimitive); _mkldnn_primitive = mprimitive;  }
195      MKLDNNPrimitive<Dtype>&  mkldnn_primitive() { return _mkldnn_primitive; }
196      shared_ptr<primitive> aprimitive() const { return _mkldnn_primitive.aprimitive; }
197  private:
198      MKLDNNPrimitive<Dtype> _mkldnn_primitive;
199  };
200  template <typename Dtype>
201  class MKLDNNData : public MKLDNNMemoryDescriptor<Dtype, false>
202  {
203  public:
204      MKLDNNData(shared_ptr<memory::primitive_desc> usr_memory_pd
205                  , shared_ptr<memory::primitive_desc> prv_memory_pd
206                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
207                  , std::vector<float> scale=std::vector<float>(1,1.)
208                  , int mask=0
209                  , bool is_sum=false
210                  , bool is_wino=false
211                  , bool is_weight=false
212                  , std::string name="")
213          : MKLDNNMemoryDescriptor<Dtype, false>(usr_memory_pd, prv_memory_pd, blob, mkldnn_layer, scale, mask, is_sum, is_wino, is_weight, name) {}
214  };
215  template <typename Dtype>
216  class MKLDNNDiff : public MKLDNNMemoryDescriptor<Dtype, true>
217  {
218  public:
219      MKLDNNDiff(shared_ptr<memory::primitive_desc> usr_memory_pd
220                  , shared_ptr<memory::primitive_desc> prv_memory_pd
221                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer)
222          : MKLDNNMemoryDescriptor<Dtype, true>(usr_memory_pd, prv_memory_pd, blob, mkldnn_layer ) {}
223  };
224  template <typename Dtype, bool is_diff>
225  shared_ptr<MKLDNNMemoryDescriptor<Dtype, is_diff> > get_mkldnn_prv_descriptor(Blob<Dtype>* blob);
226  }  
227  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type_mat4x3.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_memory.hpp</div>
                </div>
                <div class="column column_space"><pre><code>61              X1 const & x1, Y1 const & y1, Z1 const & z1, 
62              X2 const & x2, Y2 const & y2, Z2 const & z2, 
63              X3 const & x3, Y3 const & y3, Z3 const & z3, 
64              X4 const & x4, Y4 const & y4, Z4 const & z4);
</pre></code></div>
                <div class="column column_space"><pre><code>23      MKLDNNMemoryDescriptorBase(shared_ptr<memory::primitive_desc> usr_memory_pd
24                                  , shared_ptr<memory::primitive_desc> prv_memory_pd
25                                  , Blob<Dtype>* blob, MKLDNNLayer<Dtype>* mkldnn_layer
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    