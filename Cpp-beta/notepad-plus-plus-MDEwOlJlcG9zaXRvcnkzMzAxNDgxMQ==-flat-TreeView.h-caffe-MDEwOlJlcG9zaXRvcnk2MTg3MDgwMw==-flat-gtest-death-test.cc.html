
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.738562091503268%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TreeView.h</h3>
            <pre><code>1  #pragma once
2  #include <windows.h>
3  #include <commctrl.h>
4  #include "Window.h"
5  #include "Common.h"
6  #define CX_BITMAP         16
7  #define CY_BITMAP         16
8  struct TreeStateNode {
9  	generic_string _label;
10  	generic_string _extraData;
11  	bool _isExpanded = false;
12  	bool _isSelected = false;
13  	std::vector<TreeStateNode> _children;
14  };
15  class TreeView : public Window {
16  public:
17  	TreeView() = default;
18  	virtual ~TreeView() = default;
19  	virtual void init(HINSTANCE hInst, HWND parent, int treeViewID);
20  	virtual void destroy();
21  	HTREEITEM addItem(const TCHAR *itemName, HTREEITEM hParentItem, int iImage, LPARAM lParam = 0);
22  	bool setItemParam(HTREEITEM Item2Set, LPARAM param);
23  	LPARAM getItemParam(HTREEITEM Item2Get) const;
24  	generic_string getItemDisplayName(HTREEITEM Item2Set) const;
25  	HTREEITEM searchSubItemByName(const TCHAR *itemName, HTREEITEM hParentItem);
26  	void removeItem(HTREEITEM hTreeItem);
27  	void removeAllItems();
28  	bool renameItem(HTREEITEM Item2Set, const TCHAR *newName);
29  	void makeLabelEditable(bool toBeEnabled);
30  	HTREEITEM getChildFrom(HTREEITEM hTreeItem) const {
31  		return TreeView_GetChild(_hSelf, hTreeItem);
32  	};
33  	HTREEITEM getSelection() const {
34  		return TreeView_GetSelection(_hSelf);
35  	};
36  	bool selectItem(HTREEITEM hTreeItem2Select) const {
37  		return TreeView_SelectItem(_hSelf, hTreeItem2Select) == TRUE;
38  	};
39  	HTREEITEM getRoot() const {
40  		return TreeView_GetRoot(_hSelf);
41  	};
42  	HTREEITEM getParent(HTREEITEM hItem) const {
43  		return TreeView_GetParent(_hSelf, hItem);
44  	};
45  	HTREEITEM getNextSibling(HTREEITEM hItem) const {
46  		return TreeView_GetNextSibling(_hSelf, hItem);
47  	};
48  	HTREEITEM getPrevSibling(HTREEITEM hItem) const {
49  		return TreeView_GetPrevSibling(_hSelf, hItem);
50  	};
51  	void expand(HTREEITEM hItem) const {
52  		TreeView_Expand(_hSelf, hItem, TVE_EXPAND);
53  	};
54  	void fold(HTREEITEM hItem) const {
55  		TreeView_Expand(_hSelf, hItem, TVE_COLLAPSE);
56  	};
57  	void foldExpandRecursively(HTREEITEM hItem, bool isFold) const;
58  	void foldExpandAll(bool isFold) const;
59  	void foldAll() const {
60  		foldExpandAll(true);
61  	};
62  	void expandAll() const {
63  		foldExpandAll(false);
64  	};
65  	void toggleExpandCollapse(HTREEITEM hItem) const {
66  		TreeView_Expand(_hSelf, hItem, TVE_TOGGLE);
<span onclick='openModal()' class='match'>67  	};
68  	void setItemImage(HTREEITEM hTreeItem, int iImage, int iSelectedImage);
69  	void beginDrag(NMTREEVIEW* tv);
</span>70  	void dragItem(HWND parentHandle, int x, int y);
71  	bool isDragging() const {
72  		return _isItemDragged;
73  	};
74  	bool dropItem();
75  	void addCanNotDropInList(int val2set) {
76  		_canNotDropInList.push_back(val2set);
77  	};
78  	void addCanNotDragOutList(int val2set) {
79  		_canNotDragOutList.push_back(val2set);
80  	};
81  	bool moveDown(HTREEITEM itemToMove);
82  	bool moveUp(HTREEITEM itemToMove);
83  	bool swapTreeViewItem(HTREEITEM itemGoDown, HTREEITEM itemGoUp);
84  	bool restoreFoldingStateFrom(const TreeStateNode & treeState2Compare, HTREEITEM treeviewNode);
85  	bool retrieveFoldingStateTo(TreeStateNode & treeState2Construct, HTREEITEM treeviewNode);
86  	bool searchLeafAndBuildTree(const TreeView & tree2Build, const generic_string & text2Search, int index2Search);
87  	void sort(HTREEITEM hTreeItem, bool isRecusive);
88  	void customSorting(HTREEITEM hTreeItem, PFNTVCOMPARE sortingCallbackFunc, LPARAM lParam, bool isRecursive);
89  	BOOL setImageList(int w, int h, int nbImage, int image_id, ...);
90  protected:
91  	HIMAGELIST _hImaLst = nullptr;
92  	WNDPROC _defaultProc = nullptr;
93  	LRESULT runProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
94  	static LRESULT CALLBACK staticProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam) {
95  		return (((TreeView *)(::GetWindowLongPtr(hwnd, GWLP_USERDATA)))->runProc(hwnd, Message, wParam, lParam));
96  	};
97  	void cleanSubEntries(HTREEITEM hTreeItem);
98  	void dupTree(HTREEITEM hTree2Dup, HTREEITEM hParentItem);
99  	bool searchLeafRecusivelyAndBuildTree(HTREEITEM tree2Build, const generic_string & text2Search, int index2Search, HTREEITEM tree2Search);
100  	HTREEITEM _draggedItem = nullptr;
101  	HIMAGELIST _draggedImageList = nullptr;
102  	bool _isItemDragged = false;
103  	std::vector<int> _canNotDragOutList;
104  	std::vector<int> _canNotDropInList;
105  	bool canBeDropped(HTREEITEM draggedItem, HTREEITEM targetItem);
106  	void moveTreeViewItem(HTREEITEM draggedItem, HTREEITEM targetItem);
107  	bool isParent(HTREEITEM targetItem, HTREEITEM draggedItem);
108  	bool isDescendant(HTREEITEM targetItem, HTREEITEM draggedItem);
109  	bool canDragOut(HTREEITEM targetItem);
110  	bool canDropIn(HTREEITEM targetItem);
111  };
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-death-test.cc</h3>
            <pre><code>1  #include "gtest/gtest-death-test.h"
2  #include "gtest/internal/gtest-port.h"
3  #if GTEST_HAS_DEATH_TEST
4  # if GTEST_OS_MAC
5  #  include <crt_externs.h>
6  # endif  
7  # include <errno.h>
8  # include <fcntl.h>
9  # include <limits.h>
10  # if GTEST_OS_LINUX
11  #  include <signal.h>
12  # endif  
13  # include <stdarg.h>
14  # if GTEST_OS_WINDOWS
15  #  include <windows.h>
16  # else
17  #  include <sys/mman.h>
18  #  include <sys/wait.h>
19  # endif  
20  # if GTEST_OS_QNX
21  #  include <spawn.h>
22  # endif  
23  #endif  
24  #include "gtest/gtest-message.h"
25  #include "gtest/internal/gtest-string.h"
26  #define GTEST_IMPLEMENTATION_ 1
27  #include "src/gtest-internal-inl.h"
28  #undef GTEST_IMPLEMENTATION_
29  namespace testing {
30  static const char kDefaultDeathTestStyle[] = "fast";
31  GTEST_DEFINE_string_(
32      death_test_style,
33      internal::StringFromGTestEnv("death_test_style", kDefaultDeathTestStyle),
34      "Indicates how to run a death test in a forked child process: "
35      "\"threadsafe\" (child process re-executes the test binary "
36      "from the beginning, running only the specific death test) or "
37      "\"fast\" (child process runs the death test immediately "
38      "after forking).");
39  GTEST_DEFINE_bool_(
40      death_test_use_fork,
41      internal::BoolFromGTestEnv("death_test_use_fork", false),
42      "Instructs to use fork()/_exit() instead of clone() in death tests. "
43      "Ignored and always uses fork() on POSIX systems where clone() is not "
44      "implemented. Useful when running under valgrind or similar tools if "
45      "those do not support clone(). Valgrind 3.3.1 will just fail if "
46      "it sees an unsupported combination of clone() flags. "
47      "It is not recommended to use this flag w/o valgrind though it will "
48      "work in 99% of the cases. Once valgrind is fixed, this flag will "
49      "most likely be removed.");
50  namespace internal {
51  GTEST_DEFINE_string_(
52      internal_run_death_test, "",
53      "Indicates the file, line number, temporal index of "
54      "the single death test to run, and a file descriptor to "
55      "which a success code may be sent, all separated by "
56      "the '|' characters.  This flag is specified if and only if the current "
57      "process is a sub-process launched for running a thread-safe "
58      "death test.  FOR INTERNAL USE ONLY.");
59  }  
60  #if GTEST_HAS_DEATH_TEST
61  namespace internal {
62  static bool g_in_fast_death_test_child = false;
63  bool InDeathTestChild() {
64  # if GTEST_OS_WINDOWS
65    return !GTEST_FLAG(internal_run_death_test).empty();
66  # else
67    if (GTEST_FLAG(death_test_style) == "threadsafe")
68      return !GTEST_FLAG(internal_run_death_test).empty();
69    else
70      return g_in_fast_death_test_child;
71  #endif
72  }
73  }  
74  ExitedWithCode::ExitedWithCode(int exit_code) : exit_code_(exit_code) {
75  }
76  bool ExitedWithCode::operator()(int exit_status) const {
77  # if GTEST_OS_WINDOWS
78    return exit_status == exit_code_;
79  # else
80    return WIFEXITED(exit_status) && WEXITSTATUS(exit_status) == exit_code_;
81  # endif  
82  }
83  # if !GTEST_OS_WINDOWS
84  KilledBySignal::KilledBySignal(int signum) : signum_(signum) {
85  }
86  bool KilledBySignal::operator()(int exit_status) const {
87    return WIFSIGNALED(exit_status) && WTERMSIG(exit_status) == signum_;
88  }
89  # endif  
90  namespace internal {
91  static std::string ExitSummary(int exit_code) {
92    Message m;
93  # if GTEST_OS_WINDOWS
94    m << "Exited with exit status " << exit_code;
95  # else
96    if (WIFEXITED(exit_code)) {
97      m << "Exited with exit status " << WEXITSTATUS(exit_code);
98    } else if (WIFSIGNALED(exit_code)) {
99      m << "Terminated by signal " << WTERMSIG(exit_code);
100    }
101  #  ifdef WCOREDUMP
102    if (WCOREDUMP(exit_code)) {
103      m << " (core dumped)";
104    }
105  #  endif
106  # endif  
107    return m.GetString();
108  }
109  bool ExitedUnsuccessfully(int exit_status) {
110    return !ExitedWithCode(0)(exit_status);
111  }
112  # if !GTEST_OS_WINDOWS
113  static std::string DeathTestThreadWarning(size_t thread_count) {
114    Message msg;
115    msg << "Death tests use fork(), which is unsafe particularly"
116        << " in a threaded context. For this test, " << GTEST_NAME_ << " ";
117    if (thread_count == 0)
118      msg << "couldn't detect the number of threads.";
119    else
120      msg << "detected " << thread_count << " threads.";
121    return msg.GetString();
122  }
123  # endif  
124  static const char kDeathTestLived = 'L';
125  static const char kDeathTestReturned = 'R';
126  static const char kDeathTestThrew = 'T';
127  static const char kDeathTestInternalError = 'I';
128  enum DeathTestOutcome { IN_PROGRESS, DIED, LIVED, RETURNED, THREW };
129  void DeathTestAbort(const std::string& message) {
130    const InternalRunDeathTestFlag* const flag =
131        GetUnitTestImpl()->internal_run_death_test_flag();
132    if (flag != NULL) {
133      FILE* parent = posix::FDOpen(flag->write_fd(), "w");
134      fputc(kDeathTestInternalError, parent);
135      fprintf(parent, "%s", message.c_str());
136      fflush(parent);
137      _exit(1);
138    } else {
139      fprintf(stderr, "%s", message.c_str());
140      fflush(stderr);
141      posix::Abort();
142    }
143  }
144  # define GTEST_DEATH_TEST_CHECK_(expression) \
145    do { \
146      if (!::testing::internal::IsTrue(expression)) { \
147        DeathTestAbort( \
148            ::std::string("CHECK failed: File ") + __FILE__ +  ", line " \
149            + ::testing::internal::StreamableToString(__LINE__) + ": " \
150            + #expression); \
151      } \
152    } while (::testing::internal::AlwaysFalse())
153  # define GTEST_DEATH_TEST_CHECK_SYSCALL_(expression) \
154    do { \
155      int gtest_retval; \
156      do { \
157        gtest_retval = (expression); \
158      } while (gtest_retval == -1 && errno == EINTR); \
159      if (gtest_retval == -1) { \
160        DeathTestAbort( \
161            ::std::string("CHECK failed: File ") + __FILE__ + ", line " \
162            + ::testing::internal::StreamableToString(__LINE__) + ": " \
163            + #expression + " != -1"); \
164      } \
165    } while (::testing::internal::AlwaysFalse())
166  std::string GetLastErrnoDescription() {
167      return errno == 0 ? "" : posix::StrError(errno);
168  }
169  static void FailFromInternalError(int fd) {
170    Message error;
171    char buffer[256];
172    int num_read;
173    do {
174      while ((num_read = posix::Read(fd, buffer, 255)) > 0) {
175        buffer[num_read] = '\0';
176        error << buffer;
177      }
178    } while (num_read == -1 && errno == EINTR);
179    if (num_read == 0) {
180      GTEST_LOG_(FATAL) << error.GetString();
181    } else {
182      const int last_error = errno;
183      GTEST_LOG_(FATAL) << "Error while reading death test internal: "
184                        << GetLastErrnoDescription() << " [" << last_error << "]";
185    }
186  }
187  DeathTest::DeathTest() {
188    TestInfo* const info = GetUnitTestImpl()->current_test_info();
189    if (info == NULL) {
190      DeathTestAbort("Cannot run a death test outside of a TEST or "
191                     "TEST_F construct");
192    }
193  }
194  bool DeathTest::Create(const char* statement, const RE* regex,
195                         const char* file, int line, DeathTest** test) {
196    return GetUnitTestImpl()->death_test_factory()->Create(
197        statement, regex, file, line, test);
198  }
199  const char* DeathTest::LastMessage() {
200    return last_death_test_message_.c_str();
201  }
202  void DeathTest::set_last_death_test_message(const std::string& message) {
203    last_death_test_message_ = message;
204  }
205  std::string DeathTest::last_death_test_message_;
206  class DeathTestImpl : public DeathTest {
207   protected:
208    DeathTestImpl(const char* a_statement, const RE* a_regex)
209        : statement_(a_statement),
210          regex_(a_regex),
211          spawned_(false),
212          status_(-1),
213          outcome_(IN_PROGRESS),
214          read_fd_(-1),
215          write_fd_(-1) {}
216    ~DeathTestImpl() { GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); }
217    void Abort(AbortReason reason);
218    virtual bool Passed(bool status_ok);
219    const char* statement() const { return statement_; }
220    const RE* regex() const { return regex_; }
221    bool spawned() const { return spawned_; }
222    void set_spawned(bool is_spawned) { spawned_ = is_spawned; }
223    int status() const { return status_; }
224    void set_status(int a_status) { status_ = a_status; }
225    DeathTestOutcome outcome() const { return outcome_; }
226    void set_outcome(DeathTestOutcome an_outcome) { outcome_ = an_outcome; }
227    int read_fd() const { return read_fd_; }
228    void set_read_fd(int fd) { read_fd_ = fd; }
229    int write_fd() const { return write_fd_; }
<span onclick='openModal()' class='match'>230    void set_write_fd(int fd) { write_fd_ = fd; }
231    void ReadAndInterpretStatusByte();
232   private:
233    const char* const statement_;
234    const RE* const regex_;
235    bool spawned_;
236    int status_;
237    DeathTestOutcome outcome_;
238    int read_fd_;
239    int write_fd_;
</span>240  };
241  void DeathTestImpl::ReadAndInterpretStatusByte() {
242    char flag;
243    int bytes_read;
244    do {
245      bytes_read = posix::Read(read_fd(), &flag, 1);
246    } while (bytes_read == -1 && errno == EINTR);
247    if (bytes_read == 0) {
248      set_outcome(DIED);
249    } else if (bytes_read == 1) {
250      switch (flag) {
251        case kDeathTestReturned:
252          set_outcome(RETURNED);
253          break;
254        case kDeathTestThrew:
255          set_outcome(THREW);
256          break;
257        case kDeathTestLived:
258          set_outcome(LIVED);
259          break;
260        case kDeathTestInternalError:
261          FailFromInternalError(read_fd());  
262          break;
263        default:
264          GTEST_LOG_(FATAL) << "Death test child process reported "
265                            << "unexpected status byte ("
266                            << static_cast<unsigned int>(flag) << ")";
267      }
268    } else {
269      GTEST_LOG_(FATAL) << "Read from death test child process failed: "
270                        << GetLastErrnoDescription();
271    }
272    GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));
273    set_read_fd(-1);
274  }
275  void DeathTestImpl::Abort(AbortReason reason) {
276    const char status_ch =
277        reason == TEST_DID_NOT_DIE ? kDeathTestLived :
278        reason == TEST_THREW_EXCEPTION ? kDeathTestThrew : kDeathTestReturned;
279    GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &status_ch, 1));
280    _exit(1);  
281  }
282  static ::std::string FormatDeathTestOutput(const ::std::string& output) {
283    ::std::string ret;
284    for (size_t at = 0; ; ) {
285      const size_t line_end = output.find('\n', at);
286      ret += "[  DEATH   ] ";
287      if (line_end == ::std::string::npos) {
288        ret += output.substr(at);
289        break;
290      }
291      ret += output.substr(at, line_end + 1 - at);
292      at = line_end + 1;
293    }
294    return ret;
295  }
296  bool DeathTestImpl::Passed(bool status_ok) {
297    if (!spawned())
298      return false;
299    const std::string error_message = GetCapturedStderr();
300    bool success = false;
301    Message buffer;
302    buffer << "Death test: " << statement() << "\n";
303    switch (outcome()) {
304      case LIVED:
305        buffer << "    Result: failed to die.\n"
306               << " Error msg:\n" << FormatDeathTestOutput(error_message);
307        break;
308      case THREW:
309        buffer << "    Result: threw an exception.\n"
310               << " Error msg:\n" << FormatDeathTestOutput(error_message);
311        break;
312      case RETURNED:
313        buffer << "    Result: illegal return in test statement.\n"
314               << " Error msg:\n" << FormatDeathTestOutput(error_message);
315        break;
316      case DIED:
317        if (status_ok) {
318          const bool matched = RE::PartialMatch(error_message.c_str(), *regex());
319          if (matched) {
320            success = true;
321          } else {
322            buffer << "    Result: died but not with expected error.\n"
323                   << "  Expected: " << regex()->pattern() << "\n"
324                   << "Actual msg:\n" << FormatDeathTestOutput(error_message);
325          }
326        } else {
327          buffer << "    Result: died but not with expected exit code:\n"
328                 << "            " << ExitSummary(status()) << "\n"
329                 << "Actual msg:\n" << FormatDeathTestOutput(error_message);
330        }
331        break;
332      case IN_PROGRESS:
333      default:
334        GTEST_LOG_(FATAL)
335            << "DeathTest::Passed somehow called before conclusion of test";
336    }
337    DeathTest::set_last_death_test_message(buffer.GetString());
338    return success;
339  }
340  # if GTEST_OS_WINDOWS
341  class WindowsDeathTest : public DeathTestImpl {
342   public:
343    WindowsDeathTest(const char* a_statement,
344                     const RE* a_regex,
345                     const char* file,
346                     int line)
347        : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}
348    virtual int Wait();
349    virtual TestRole AssumeRole();
350   private:
351    const char* const file_;
352    const int line_;
353    AutoHandle write_handle_;
354    AutoHandle child_handle_;
355    AutoHandle event_handle_;
356  };
357  int WindowsDeathTest::Wait() {
358    if (!spawned())
359      return 0;
360    const HANDLE wait_handles[2] = { child_handle_.Get(), event_handle_.Get() };
361    switch (::WaitForMultipleObjects(2,
362                                     wait_handles,
363                                     FALSE,  
364                                     INFINITE)) {
365      case WAIT_OBJECT_0:
366      case WAIT_OBJECT_0 + 1:
367        break;
368      default:
369        GTEST_DEATH_TEST_CHECK_(false);  
370    }
371    write_handle_.Reset();
372    event_handle_.Reset();
373    ReadAndInterpretStatusByte();
374    GTEST_DEATH_TEST_CHECK_(
375        WAIT_OBJECT_0 == ::WaitForSingleObject(child_handle_.Get(),
376                                               INFINITE));
377    DWORD status_code;
378    GTEST_DEATH_TEST_CHECK_(
379        ::GetExitCodeProcess(child_handle_.Get(), &status_code) != FALSE);
380    child_handle_.Reset();
381    set_status(static_cast<int>(status_code));
382    return status();
383  }
384  DeathTest::TestRole WindowsDeathTest::AssumeRole() {
385    const UnitTestImpl* const impl = GetUnitTestImpl();
386    const InternalRunDeathTestFlag* const flag =
387        impl->internal_run_death_test_flag();
388    const TestInfo* const info = impl->current_test_info();
389    const int death_test_index = info->result()->death_test_count();
390    if (flag != NULL) {
391      set_write_fd(flag->write_fd());
392      return EXECUTE_TEST;
393    }
394    SECURITY_ATTRIBUTES handles_are_inheritable = {
395      sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
396    HANDLE read_handle, write_handle;
397    GTEST_DEATH_TEST_CHECK_(
398        ::CreatePipe(&read_handle, &write_handle, &handles_are_inheritable,
399                     0)  
400        != FALSE);
401    set_read_fd(::_open_osfhandle(reinterpret_cast<intptr_t>(read_handle),
402                                  O_RDONLY));
403    write_handle_.Reset(write_handle);
404    event_handle_.Reset(::CreateEvent(
405        &handles_are_inheritable,
406        TRUE,    
407        FALSE,   
408        NULL));  
409    GTEST_DEATH_TEST_CHECK_(event_handle_.Get() != NULL);
410    const std::string filter_flag =
411        std::string("--") + GTEST_FLAG_PREFIX_ + kFilterFlag + "=" +
412        info->test_case_name() + "." + info->name();
413    const std::string internal_flag =
414        std::string("--") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag +
415        "=" + file_ + "|" + StreamableToString(line_) + "|" +
416        StreamableToString(death_test_index) + "|" +
417        StreamableToString(static_cast<unsigned int>(::GetCurrentProcessId())) +
418        "|" + StreamableToString(reinterpret_cast<size_t>(write_handle)) +
419        "|" + StreamableToString(reinterpret_cast<size_t>(event_handle_.Get()));
420    char executable_path[_MAX_PATH + 1];  
421    GTEST_DEATH_TEST_CHECK_(
422        _MAX_PATH + 1 != ::GetModuleFileNameA(NULL,
423                                              executable_path,
424                                              _MAX_PATH));
425    std::string command_line =
426        std::string(::GetCommandLineA()) + " " + filter_flag + " \"" +
427        internal_flag + "\"";
428    DeathTest::set_last_death_test_message("");
429    CaptureStderr();
430    FlushInfoLog();
431    STARTUPINFOA startup_info;
432    memset(&startup_info, 0, sizeof(STARTUPINFO));
433    startup_info.dwFlags = STARTF_USESTDHANDLES;
434    startup_info.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);
435    startup_info.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);
436    startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);
437    PROCESS_INFORMATION process_info;
438    GTEST_DEATH_TEST_CHECK_(::CreateProcessA(
439        executable_path,
440        const_cast<char*>(command_line.c_str()),
441        NULL,   
442        NULL,   
443        TRUE,   
444        0x0,    
445        NULL,   
446        UnitTest::GetInstance()->original_working_dir(),
447        &startup_info,
448        &process_info) != FALSE);
449    child_handle_.Reset(process_info.hProcess);
450    ::CloseHandle(process_info.hThread);
451    set_spawned(true);
452    return OVERSEE_TEST;
453  }
454  # else  
455  class ForkingDeathTest : public DeathTestImpl {
456   public:
457    ForkingDeathTest(const char* statement, const RE* regex);
458    virtual int Wait();
459   protected:
460    void set_child_pid(pid_t child_pid) { child_pid_ = child_pid; }
461   private:
462    pid_t child_pid_;
463  };
464  ForkingDeathTest::ForkingDeathTest(const char* a_statement, const RE* a_regex)
465      : DeathTestImpl(a_statement, a_regex),
466        child_pid_(-1) {}
467  int ForkingDeathTest::Wait() {
468    if (!spawned())
469      return 0;
470    ReadAndInterpretStatusByte();
471    int status_value;
472    GTEST_DEATH_TEST_CHECK_SYSCALL_(waitpid(child_pid_, &status_value, 0));
473    set_status(status_value);
474    return status_value;
475  }
476  class NoExecDeathTest : public ForkingDeathTest {
477   public:
478    NoExecDeathTest(const char* a_statement, const RE* a_regex) :
479        ForkingDeathTest(a_statement, a_regex) { }
480    virtual TestRole AssumeRole();
481  };
482  DeathTest::TestRole NoExecDeathTest::AssumeRole() {
483    const size_t thread_count = GetThreadCount();
484    if (thread_count != 1) {
485      GTEST_LOG_(WARNING) << DeathTestThreadWarning(thread_count);
486    }
487    int pipe_fd[2];
488    GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);
489    DeathTest::set_last_death_test_message("");
490    CaptureStderr();
491    FlushInfoLog();
492    const pid_t child_pid = fork();
493    GTEST_DEATH_TEST_CHECK_(child_pid != -1);
494    set_child_pid(child_pid);
495    if (child_pid == 0) {
496      GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[0]));
497      set_write_fd(pipe_fd[1]);
498      LogToStderr();
499      GetUnitTestImpl()->listeners()->SuppressEventForwarding();
500      g_in_fast_death_test_child = true;
501      return EXECUTE_TEST;
502    } else {
503      GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));
504      set_read_fd(pipe_fd[0]);
505      set_spawned(true);
506      return OVERSEE_TEST;
507    }
508  }
509  class ExecDeathTest : public ForkingDeathTest {
510   public:
511    ExecDeathTest(const char* a_statement, const RE* a_regex,
512                  const char* file, int line) :
513        ForkingDeathTest(a_statement, a_regex), file_(file), line_(line) { }
514    virtual TestRole AssumeRole();
515   private:
516    static ::std::vector<testing::internal::string>
517    GetArgvsForDeathTestChildProcess() {
518      ::std::vector<testing::internal::string> args = GetInjectableArgvs();
519      return args;
520    }
521    const char* const file_;
522    const int line_;
523  };
524  class Arguments {
525   public:
526    Arguments() {
527      args_.push_back(NULL);
528    }
529    ~Arguments() {
530      for (std::vector<char*>::iterator i = args_.begin(); i != args_.end();
531           ++i) {
532        free(*i);
533      }
534    }
535    void AddArgument(const char* argument) {
536      args_.insert(args_.end() - 1, posix::StrDup(argument));
537    }
538    template <typename Str>
539    void AddArguments(const ::std::vector<Str>& arguments) {
540      for (typename ::std::vector<Str>::const_iterator i = arguments.begin();
541           i != arguments.end();
542           ++i) {
543        args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));
544      }
545    }
546    char* const* Argv() {
547      return &args_[0];
548    }
549   private:
550    std::vector<char*> args_;
551  };
552  struct ExecDeathTestArgs {
553    char* const* argv;  
554    int close_fd;       
555  };
556  #  if GTEST_OS_MAC
557  inline char** GetEnviron() {
558    return *_NSGetEnviron();
559  }
560  #  else
561  extern "C" char** environ;
562  inline char** GetEnviron() { return environ; }
563  #  endif  
564  #  if !GTEST_OS_QNX
565  static int ExecDeathTestChildMain(void* child_arg) {
566    ExecDeathTestArgs* const args = static_cast<ExecDeathTestArgs*>(child_arg);
567    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(args->close_fd));
568    const char* const original_dir =
569        UnitTest::GetInstance()->original_working_dir();
570    if (chdir(original_dir) != 0) {
571      DeathTestAbort(std::string("chdir(\"") + original_dir + "\") failed: " +
572                     GetLastErrnoDescription());
573      return EXIT_FAILURE;
574    }
575    execve(args->argv[0], args->argv, GetEnviron());
576    DeathTestAbort(std::string("execve(") + args->argv[0] + ", ...) in " +
577                   original_dir + " failed: " +
578                   GetLastErrnoDescription());
579    return EXIT_FAILURE;
580  }
581  #  endif  
582  void StackLowerThanAddress(const void* ptr, bool* result) GTEST_NO_INLINE_;
583  void StackLowerThanAddress(const void* ptr, bool* result) {
584    int dummy;
585    *result = (&dummy < ptr);
586  }
587  bool StackGrowsDown() {
588    int dummy;
589    bool result;
590    StackLowerThanAddress(&dummy, &result);
591    return result;
592  }
593  static pid_t ExecDeathTestSpawnChild(char* const* argv, int close_fd) {
594    ExecDeathTestArgs args = { argv, close_fd };
595    pid_t child_pid = -1;
596  #  if GTEST_OS_QNX
597    const int cwd_fd = open(".", O_RDONLY);
598    GTEST_DEATH_TEST_CHECK_(cwd_fd != -1);
599    GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(cwd_fd, F_SETFD, FD_CLOEXEC));
600    const char* const original_dir =
601        UnitTest::GetInstance()->original_working_dir();
602    if (chdir(original_dir) != 0) {
603      DeathTestAbort(std::string("chdir(\"") + original_dir + "\") failed: " +
604                     GetLastErrnoDescription());
605      return EXIT_FAILURE;
606    }
607    int fd_flags;
608    GTEST_DEATH_TEST_CHECK_SYSCALL_(fd_flags = fcntl(close_fd, F_GETFD));
609    GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(close_fd, F_SETFD,
610                                          fd_flags | FD_CLOEXEC));
611    struct inheritance inherit = {0};
612    child_pid = spawn(args.argv[0], 0, NULL, &inherit, args.argv, GetEnviron());
613    GTEST_DEATH_TEST_CHECK_(fchdir(cwd_fd) != -1);
614    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(cwd_fd));
615  #  else   
616  #   if GTEST_OS_LINUX
617    struct sigaction saved_sigprof_action;
618    struct sigaction ignore_sigprof_action;
619    memset(&ignore_sigprof_action, 0, sizeof(ignore_sigprof_action));
620    sigemptyset(&ignore_sigprof_action.sa_mask);
621    ignore_sigprof_action.sa_handler = SIG_IGN;
622    GTEST_DEATH_TEST_CHECK_SYSCALL_(sigaction(
623        SIGPROF, &ignore_sigprof_action, &saved_sigprof_action));
624  #   endif  
625  #   if GTEST_HAS_CLONE
626    const bool use_fork = GTEST_FLAG(death_test_use_fork);
627    if (!use_fork) {
628      static const bool stack_grows_down = StackGrowsDown();
629      const size_t stack_size = getpagesize();
630      void* const stack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,
631                               MAP_ANON | MAP_PRIVATE, -1, 0);
632      GTEST_DEATH_TEST_CHECK_(stack != MAP_FAILED);
633      const size_t kMaxStackAlignment = 64;
634      void* const stack_top =
635          static_cast<char*>(stack) +
636              (stack_grows_down ? stack_size - kMaxStackAlignment : 0);
637      GTEST_DEATH_TEST_CHECK_(stack_size > kMaxStackAlignment &&
638          reinterpret_cast<intptr_t>(stack_top) % kMaxStackAlignment == 0);
639      child_pid = clone(&ExecDeathTestChildMain, stack_top, SIGCHLD, &args);
640      GTEST_DEATH_TEST_CHECK_(munmap(stack, stack_size) != -1);
641    }
642  #   else
643    const bool use_fork = true;
644  #   endif  
645    if (use_fork && (child_pid = fork()) == 0) {
646        ExecDeathTestChildMain(&args);
647        _exit(0);
648    }
649  #  endif  
650  #  if GTEST_OS_LINUX
651    GTEST_DEATH_TEST_CHECK_SYSCALL_(
652        sigaction(SIGPROF, &saved_sigprof_action, NULL));
653  #  endif  
654    GTEST_DEATH_TEST_CHECK_(child_pid != -1);
655    return child_pid;
656  }
657  DeathTest::TestRole ExecDeathTest::AssumeRole() {
658    const UnitTestImpl* const impl = GetUnitTestImpl();
659    const InternalRunDeathTestFlag* const flag =
660        impl->internal_run_death_test_flag();
661    const TestInfo* const info = impl->current_test_info();
662    const int death_test_index = info->result()->death_test_count();
663    if (flag != NULL) {
664      set_write_fd(flag->write_fd());
665      return EXECUTE_TEST;
666    }
667    int pipe_fd[2];
668    GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);
669    GTEST_DEATH_TEST_CHECK_(fcntl(pipe_fd[1], F_SETFD, 0) != -1);
670    const std::string filter_flag =
671        std::string("--") + GTEST_FLAG_PREFIX_ + kFilterFlag + "="
672        + info->test_case_name() + "." + info->name();
673    const std::string internal_flag =
674        std::string("--") + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag + "="
675        + file_ + "|" + StreamableToString(line_) + "|"
676        + StreamableToString(death_test_index) + "|"
677        + StreamableToString(pipe_fd[1]);
678    Arguments args;
679    args.AddArguments(GetArgvsForDeathTestChildProcess());
680    args.AddArgument(filter_flag.c_str());
681    args.AddArgument(internal_flag.c_str());
682    DeathTest::set_last_death_test_message("");
683    CaptureStderr();
684    FlushInfoLog();
685    const pid_t child_pid = ExecDeathTestSpawnChild(args.Argv(), pipe_fd[0]);
686    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));
687    set_child_pid(child_pid);
688    set_read_fd(pipe_fd[0]);
689    set_spawned(true);
690    return OVERSEE_TEST;
691  }
692  # endif  
693  bool DefaultDeathTestFactory::Create(const char* statement, const RE* regex,
694                                       const char* file, int line,
695                                       DeathTest** test) {
696    UnitTestImpl* const impl = GetUnitTestImpl();
697    const InternalRunDeathTestFlag* const flag =
698        impl->internal_run_death_test_flag();
699    const int death_test_index = impl->current_test_info()
700        ->increment_death_test_count();
701    if (flag != NULL) {
702      if (death_test_index > flag->index()) {
703        DeathTest::set_last_death_test_message(
704            "Death test count (" + StreamableToString(death_test_index)
705            + ") somehow exceeded expected maximum ("
706            + StreamableToString(flag->index()) + ")");
707        return false;
708      }
709      if (!(flag->file() == file && flag->line() == line &&
710            flag->index() == death_test_index)) {
711        *test = NULL;
712        return true;
713      }
714    }
715  # if GTEST_OS_WINDOWS
716    if (GTEST_FLAG(death_test_style) == "threadsafe" ||
717        GTEST_FLAG(death_test_style) == "fast") {
718      *test = new WindowsDeathTest(statement, regex, file, line);
719    }
720  # else
721    if (GTEST_FLAG(death_test_style) == "threadsafe") {
722      *test = new ExecDeathTest(statement, regex, file, line);
723    } else if (GTEST_FLAG(death_test_style) == "fast") {
724      *test = new NoExecDeathTest(statement, regex);
725    }
726  # endif  
727    else {  
728      DeathTest::set_last_death_test_message(
729          "Unknown death test style \"" + GTEST_FLAG(death_test_style)
730          + "\" encountered");
731      return false;
732    }
733    return true;
734  }
735  static void SplitString(const ::std::string& str, char delimiter,
736                          ::std::vector< ::std::string>* dest) {
737    ::std::vector< ::std::string> parsed;
738    ::std::string::size_type pos = 0;
739    while (::testing::internal::AlwaysTrue()) {
740      const ::std::string::size_type colon = str.find(delimiter, pos);
741      if (colon == ::std::string::npos) {
742        parsed.push_back(str.substr(pos));
743        break;
744      } else {
745        parsed.push_back(str.substr(pos, colon - pos));
746        pos = colon + 1;
747      }
748    }
749    dest->swap(parsed);
750  }
751  # if GTEST_OS_WINDOWS
752  int GetStatusFileDescriptor(unsigned int parent_process_id,
753                              size_t write_handle_as_size_t,
754                              size_t event_handle_as_size_t) {
755    AutoHandle parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,
756                                                     FALSE,  
757                                                     parent_process_id));
758    if (parent_process_handle.Get() == INVALID_HANDLE_VALUE) {
759      DeathTestAbort("Unable to open parent process " +
760                     StreamableToString(parent_process_id));
761    }
762    GTEST_CHECK_(sizeof(HANDLE) <= sizeof(size_t));
763    const HANDLE write_handle =
764        reinterpret_cast<HANDLE>(write_handle_as_size_t);
765    HANDLE dup_write_handle;
766    if (!::DuplicateHandle(parent_process_handle.Get(), write_handle,
767                           ::GetCurrentProcess(), &dup_write_handle,
768                           0x0,    
769                           FALSE,  
770                           DUPLICATE_SAME_ACCESS)) {
771      DeathTestAbort("Unable to duplicate the pipe handle " +
772                     StreamableToString(write_handle_as_size_t) +
773                     " from the parent process " +
774                     StreamableToString(parent_process_id));
775    }
776    const HANDLE event_handle = reinterpret_cast<HANDLE>(event_handle_as_size_t);
777    HANDLE dup_event_handle;
778    if (!::DuplicateHandle(parent_process_handle.Get(), event_handle,
779                           ::GetCurrentProcess(), &dup_event_handle,
780                           0x0,
781                           FALSE,
782                           DUPLICATE_SAME_ACCESS)) {
783      DeathTestAbort("Unable to duplicate the event handle " +
784                     StreamableToString(event_handle_as_size_t) +
785                     " from the parent process " +
786                     StreamableToString(parent_process_id));
787    }
788    const int write_fd =
789        ::_open_osfhandle(reinterpret_cast<intptr_t>(dup_write_handle), O_APPEND);
790    if (write_fd == -1) {
791      DeathTestAbort("Unable to convert pipe handle " +
792                     StreamableToString(write_handle_as_size_t) +
793                     " to a file descriptor");
794    }
795    ::SetEvent(dup_event_handle);
796    return write_fd;
797  }
798  # endif  
799  InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag() {
800    if (GTEST_FLAG(internal_run_death_test) == "") return NULL;
801    int line = -1;
802    int index = -1;
803    ::std::vector< ::std::string> fields;
804    SplitString(GTEST_FLAG(internal_run_death_test).c_str(), '|', &fields);
805    int write_fd = -1;
806  # if GTEST_OS_WINDOWS
807    unsigned int parent_process_id = 0;
808    size_t write_handle_as_size_t = 0;
809    size_t event_handle_as_size_t = 0;
810    if (fields.size() != 6
811        || !ParseNaturalNumber(fields[1], &line)
812        || !ParseNaturalNumber(fields[2], &index)
813        || !ParseNaturalNumber(fields[3], &parent_process_id)
814        || !ParseNaturalNumber(fields[4], &write_handle_as_size_t)
815        || !ParseNaturalNumber(fields[5], &event_handle_as_size_t)) {
816      DeathTestAbort("Bad --gtest_internal_run_death_test flag: " +
817                     GTEST_FLAG(internal_run_death_test));
818    }
819    write_fd = GetStatusFileDescriptor(parent_process_id,
820                                       write_handle_as_size_t,
821                                       event_handle_as_size_t);
822  # else
823    if (fields.size() != 4
824        || !ParseNaturalNumber(fields[1], &line)
825        || !ParseNaturalNumber(fields[2], &index)
826        || !ParseNaturalNumber(fields[3], &write_fd)) {
827      DeathTestAbort("Bad --gtest_internal_run_death_test flag: "
828          + GTEST_FLAG(internal_run_death_test));
829    }
830  # endif  
831    return new InternalRunDeathTestFlag(fields[0], line, index, write_fd);
832  }
833  }  
834  #endif  
835  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TreeView.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-death-test.cc</div>
                </div>
                <div class="column column_space"><pre><code>67  	};
68  	void setItemImage(HTREEITEM hTreeItem, int iImage, int iSelectedImage);
69  	void beginDrag(NMTREEVIEW* tv);
</pre></code></div>
                <div class="column column_space"><pre><code>230    void set_write_fd(int fd) { write_fd_ = fd; }
231    void ReadAndInterpretStatusByte();
232   private:
233    const char* const statement_;
234    const RE* const regex_;
235    bool spawned_;
236    int status_;
237    DeathTestOutcome outcome_;
238    int read_fd_;
239    int write_fd_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    