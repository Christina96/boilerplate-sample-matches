
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.576328439651812%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "memes.h"
3  int TQuote::GetFq() const {
4    int fq=0;
5    for(int i=0; i<TmUrlCntV.Len(); i++) {
6      fq+=TmUrlCntV[i].Cnt(); }
7    return fq;
8  }
9  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm) const {
10    int fq=0;
11    for(int i=0; i<TmUrlCntV.Len(); i++) {
12      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm) {
13        fq += TmUrlCntV[i].Cnt(); } 
14    }
15    return fq;
16  }
17  int TQuote::GetDoms(const TQuoteBs& QtBs) const {
18    THashSet<TChA> DomSet;
19    for (int u = 0; u < TmUrlCntV.Len(); u++) {
20      DomSet.AddKey(TStrUtil::GetDomNm(QtBs.GetStr(TmUrlCntV[u].UrlId())));
21    }
22    return DomSet.Len();
23  }
24  int TQuote::GetFq(const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
25    int fq=0;
26    for(int i=0; i<TmUrlCntV.Len(); i++) {
27      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
28        fq += TmUrlCntV[i].Cnt(); } 
29    }
30    return fq;
31  }
32  int TQuote::GetFq(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
33    int fq=0;
34    for(int i=0; i<TmUrlCntV.Len(); i++) {
35      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() <= EndTm &&
36       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
37        fq+=1; }
38    }
39    return fq;
40  }
41  int TQuote::GetUrls(const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
42    int urls=0;
43    for(int i=0; i<TmUrlCntV.Len(); i++) {
44      if (TmUrlCntV[i].Tm() >= BegTm && TmUrlCntV[i].Tm() < EndTm &&
45       (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
46        urls+=1; }
47    }
48    return urls;
49  }
50  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm) const {
51    TInt FreqAtPeak;
52    return GetPeakTm(TmUnit, AfterTm, FreqAtPeak);
53  }
54  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, TInt& FreqAtPeak) const {
55    const TSecTm After = AfterTm.Round(TmUnit);
56    THash<TSecTm, TInt> TmFqH;
57    for(int i=0; i<TmUrlCntV.Len(); i++) {
58      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After) {
59        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); }
60    }
61    if (TmFqH.Empty()) {
62      FreqAtPeak = 0;
63      return GetPeakTm(TmUnit, TSecTm(1));
64    }
65    TmFqH.SortByDat(false);
66    FreqAtPeak = TmFqH[0];
67    return TmFqH.GetKey(0);
68  }
69  TSecTm TQuote::GetPeakTm(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
70    const TSecTm After = AfterTm.Round(TmUnit);
71    THash<TSecTm, TInt> TmFqH;
72    for(int i=0; i<TmUrlCntV.Len(); i++) {
73      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
74        TmFqH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt(); } 
75    }
76    if (TmFqH.Empty()) {
77      return GetPeakTm(TmUnit, TSecTm(1)); }
78    TmFqH.SortByDat(false);
79    return TmFqH.GetKey(0);
80  }
81  TSecTm TQuote::GetMeanTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
82    const TSecTm After = AfterTm.Round(TmUnit);
83    double MeanTm = 0;
84    int Cnt = 0;
85    for(int i=0; i<TmUrlCntV.Len(); i++) {
86      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
87        MeanTm += TmUrlCntV[i].Tm().Round(TmUnit) * TmUrlCntV[i].Cnt();
88        Cnt += TmUrlCntV[i].Cnt();
89      }
90    }
91    return TSecTm(uint(MeanTm/double(Cnt))).Round(TmUnit);
92  }
93  TSecTm TQuote::GetMedianTm(const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs, const TSecTm& AfterTm) const {
94    const TSecTm After = AfterTm.Round(TmUnit);
95    TMom Mom;
96    for(int i=0; i<TmUrlCntV.Len(); i++) {
97      if (TmUrlCntV[i].Tm().Round(TmUnit) >= After && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
98        Mom.Add(TmUrlCntV[i].Tm().Round(TmUnit).GetAbsSecs(), TmUrlCntV[i].Cnt());
99      }
100    }
101    Mom.Def();
102    return TSecTm(uint(Mom.GetMedian())).Round(TmUnit);
103  }
104  bool TQuote::IsSinglePeak(const TTmUnit& TmUnit, const TSecTm& AfterTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
105    const double PeakThresh = 0.4;
106    TTmFltPrV FqOtV, SmoothV;
107    GetFqOt(FqOtV, TmUnit, UrlTy, QtBs);
108    TQuote::GetSmoothFqOt(SmoothV, FqOtV, TmUnit, 48, 1.2, AfterTm); 
109    SmoothV.Swap(FqOtV);
110    double MaxVal=0;
111    int maxI=0, maxL=0, maxR=0;
112    for (int i = 0; i < FqOtV.Len(); i++) {
113      if (MaxVal < FqOtV[i].Val2) {
114        MaxVal = FqOtV[i].Val2;  maxI=i; }
115    }
116    MaxVal *= PeakThresh;
117    for (maxL = maxI; maxL>0 && FqOtV[maxL].Val2 > MaxVal; maxL--) { }
118    for (maxR = maxI; maxR<FqOtV.Len() && FqOtV[maxR].Val2 > MaxVal; maxR++) { }
119    if (maxR-maxL > 100) { return false; }
120    for (int i = maxR; i < FqOtV.Len(); i++) {
121      if (FqOtV[i].Val2 > MaxVal) { return false; }
122    }
123    for (int i = maxL; i >= 0; i--) {
124      if (FqOtV[i].Val2 > MaxVal) { return false; }
125    }
126    return true;
127  }
128  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit) const {
129    THash<TSecTm, TFlt> TmCntH;
130    for (int i = 0; i < TmUrlCntV.Len(); i++) {
131      TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
132    }
133    TmCntH.SortByKey();
134    TmCntH.GetKeyDatPrV(RawFqOtV);
135  }
136  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
137    THash<TSecTm, TFlt> TmCntH;
138    for (int i = 0; i < TmUrlCntV.Len(); i++) {
139      if (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy) {
140        TmCntH.AddDat(TmUrlCntV[i].Tm().Round(TmUnit)) += TmUrlCntV[i].Cnt();
141      }
142    }
143    TmCntH.SortByKey();
144    TmCntH.GetKeyDatPrV(RawFqOtV);
145  }
146  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm) const {
147    const TSecTm RBegTm = BegTm.Round(TmUnit);
148    const TSecTm REndTm = EndTm.Round(TmUnit);
149    THash<TSecTm, TFlt> TmCntH;
150    for (int i = 0; i < TmUrlCntV.Len(); i++) {
151      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
152      if (Tm >= RBegTm && Tm <= REndTm) {
153        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
154      }
155    }
156    TmCntH.SortByKey();
157    TmCntH.GetKeyDatPrV(RawFqOtV);
158  }
159  void TQuote::GetFqOt(TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& UrlTy, const TQuoteBs& QtBs) const {
160    const TSecTm RBegTm = BegTm.Round(TmUnit);
161    const TSecTm REndTm = EndTm.Round(TmUnit);
162    THash<TSecTm, TFlt> TmCntH;
163    for (int i = 0; i < TmUrlCntV.Len(); i++) {
164      const TSecTm Tm = TmUrlCntV[i].Tm().Round(TmUnit);
165      if (Tm >= RBegTm && Tm <= REndTm && (UrlTy==utUndef || QtBs.GetUrlTy(TmUrlCntV[i].UrlId())==UrlTy)) {
166        TmCntH.AddDat(Tm) += TmUrlCntV[i].Cnt();
167      }
168    }
169    TmCntH.SortByKey();
170    TmCntH.GetKeyDatPrV(RawFqOtV);
171  }
172  void TQuote::GetSmoothFqOt(TTmFltPrV& FqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) const {
173    TTmFltPrV RawFqOtV;
174    GetFqOt(RawFqOtV, TmUnit, BegTm, EndTm);
175    GetSmoothFqOt(FqOtV, RawFqOtV, TmUnit, WndSz, Smooth, BegTm, EndTm);
176  }
177  void TQuote::GetSmoothFqOt(TTmFltPrV& SmoothFqOtV, const TTmFltPrV& RawFqOtV, const TTmUnit& TmUnit, const int& WndSz, const double& Smooth, const TSecTm& BegTm, const TSecTm& EndTm) {
178    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
179    const int HalfWndSecs = (WndSz/2)*TmUnitSecs;
180    double FullNormConst = 1;
181    for (int j = 1; j <= WndSz/2; j++) {
182      FullNormConst += 2*pow(Smooth, -j); }
183    THash<TSecTm, TFlt> TmCntH;
184    for (int i = 0; i < RawFqOtV.Len(); i++) {
185      const TSecTm Tm = RawFqOtV[i].Val1;
186      double NormConst = FullNormConst;
187      if (Tm < BegTm+HalfWndSecs || Tm+HalfWndSecs > EndTm) {
188        NormConst = 1;
189        for (int j = 1; j <= WndSz/2; j++) {
190          if (Tm >= BegTm+j*TmUnitSecs) { NormConst += pow(Smooth, -j);  }
191          if (Tm+j*TmUnitSecs <= EndTm) { NormConst += pow(Smooth, -j);  }
192      } }
193      const double NormFq = RawFqOtV[i].Val2 / NormConst;
194      for (int j = 1; j <= WndSz/2; j++) {
195        const int Off = j*TmUnitSecs;
196        if (Tm+Off <= EndTm) {
197          TmCntH.AddDat(TSecTm(Tm+Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
198        if (Tm >= BegTm + Off) {
199          TmCntH.AddDat(TSecTm(Tm-Off).Round(TmUnit)) += NormFq * pow(Smooth, -j); }
200      }
201      TmCntH.AddDat(Tm.Round(TmUnit)) += NormFq;
202    }
203    TmCntH.SortByKey();
204    TmCntH.GetKeyDatPrV(SmoothFqOtV);
205  }
206  TStr TQuote::GetDesc() const {
207    return TStr::Fmt("#:%d U:%d  %s", GetFq(), GetUrls(), QtStr.CStr());
208  }
209  void TQuote::PlotOverTm(const TStr& OutFNm) {
210    TFltFltH HrCntH;
211    TmUrlCntV.Sort();
212    if (TmUrlCntV.Empty()) { return; }
213    for (int i = 0; i < TmUrlCntV.Len(); i++) {
214      double Hr = TSecTm(TmUrlCntV[i].Tm()-TmUrlCntV[0].Tm()).Round(tmu6Hour)/(24*3600.0);
215      HrCntH.AddDat(Hr) += TmUrlCntV[i].Cnt();
216    }
217    HrCntH.SortByKey();
218    TGnuPlot::PlotValCntH(HrCntH, OutFNm, TStr::Fmt("%d occurences, %d urls: %s", GetFq(), GetUrls(), QtStr.CStr()),
219      TStr::Fmt("Time [days] from %s", TmUrlCntV[0].Tm().GetYmdTmStr().CStr()), "Frequency");
220  }
221  void TQuote::LoadQtV(const TStr& InFNm, TVec<TQuote>& QtV) {
222    PSIn SIn = TZipIn::IsZipFNm(InFNm) ? TZipIn::New(InFNm) : TFIn::New(InFNm);
223    QtV.Clr(false);
224    while (! SIn->Eof()) {
225      QtV.Add();
226      QtV.Last().Load(*SIn);
227    }
228  }
229  TQuoteBs::TQuoteBs(TSIn& SIn) : StrQtIdH(SIn), QuoteH(SIn), UrlInDegH(SIn), UrlTyH(SIn) {
230    if (! SIn.Eof()) { ClustQtIdVH.Load(SIn); }
231    TIntSet CIdSet;
232    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
233      CIdSet.AddKey(ClustQtIdVH.GetKey(q));
234      for (int c = 0; c < ClustQtIdVH[q].Len(); c++) {
235        CIdSet.AddKey(ClustQtIdVH[q][c]); } 
236      CIdSet.GetKeyV(ClustQtIdVH[q]);
237      ClustQtIdVH[q].Sort();
238      CIdSet.Clr(false);
239    }
240    Dump();
241  }
242  void TQuoteBs::Save(TSOut& SOut) const {
243    StrQtIdH.Save(SOut);
244    QuoteH.Save(SOut);
245    UrlInDegH.Save(SOut);
246    UrlTyH.Save(SOut);
247    ClustQtIdVH.Save(SOut);
248  }
249  PQuoteBs TQuoteBs::New() {
250    return PQuoteBs(new TQuoteBs());
251  }
252  PQuoteBs TQuoteBs::Load(TSIn& SIn) {
253    printf("loading %s...", SIn.GetSNm().CStr());
254    return PQuoteBs(new TQuoteBs(SIn));
255  }
256  void TQuoteBs::GetQtIdV(TIntV& QtIdV) const {
257    QtIdV.Clr();
258    for (int q = 0; q < QuoteH.Len(); q++) {
259      QtIdV.Add(QuoteH.GetKey(q)); }
260  }
261  TUrlTy TQuoteBs::GetUrlTy(const int& UrlId) const {
262    if (UrlTyH.IsKey(UrlId)) {
263      return (TUrlTy) UrlTyH.GetDat(UrlId).Val; } 
264    return utBlog; 
265  }
266  void TQuoteBs::SetUrlTy(const TStr& InFNm, const TUrlTy& SetTy) {
267    printf("Set url type\n");
268    TStrHash<TIntV> DomUrlV; 
269    for (int q = 0; q < Len(); q++) {
270      const TQuote::TTmUrlCntV& V = GetQtN(q).TmUrlCntV;
271      for (int u = 0; u < V.Len(); u++) {
272        const TChA Url = GetStr(V[u].UrlId());
273        DomUrlV.AddDat(TStrUtil::GetDomNm(Url).CStr()).Add(V[u].UrlId());
274      }
275    }
276    printf("  %d domains\n", DomUrlV.Len());
277    TStrV TyUrlV; TStr Ln;
278    if (! TFile::Exists(InFNm)) {
279      printf("!!! %s does not exist\n", InFNm.CStr());
280      return;
281    }
282    for (TFIn FIn(InFNm); FIn.GetNextLn(Ln); ) { TyUrlV.Add(Ln.GetTrunc()); }
283    printf("  %d domains with type label loaded\n", TyUrlV.Len());
284    int NDomSet=0, NUrlSet=0;
285    TExeTm ExeTm;
286    for (int d = 0; d < DomUrlV.Len(); d++) {
287      for (int u = 0; u < TyUrlV.Len(); u++) {
288        if (strstr(DomUrlV.GetKey(d), TyUrlV[u].CStr()) != NULL) {
289          const TIntV& urlV = DomUrlV[d];
290          for (int i = 0; i < urlV.Len(); i++) {
291            UrlTyH.AddDat(urlV[i], SetTy); }
292          NDomSet++;  NUrlSet+=urlV.Len();
293          break;
294        }
295      }
296      if (d % 1000 == 0) { printf("  %d/%d: labeled %d doms, %d urls [%s]\n", d, DomUrlV.Len(), NDomSet, NUrlSet, ExeTm.GetStr()); }
297    }
298    printf("  labeled %d doms, %d urls [%s]\n", NDomSet, NUrlSet, ExeTm.GetStr());
299    printf("  %d total labeled urls\n", UrlTyH.Len());
300  }
301  bool AppearsAt(const TIntSet& UrlSet, const TQuote& Q) {
302    for (int u = 0; u < Q.GetUrls(); u++) {
303      if (UrlSet.IsKey(Q.GetUrlId(u))) { return true; }
304    }
305    return false;
306  }
307  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const bool& OnlyClustRoots, const TStr& HasWord, const TStr& AppearsAtUrl, const TUrlTy& OnlyCountTy, const TSecTm& BegTm, const TSecTm& EndTm) const {
308    printf("Get top quotes from %d quotes\n", QuoteH.Len());
309    printf("  %s -- %s\n", BegTm.GetYmdTmStr().CStr(), EndTm.GetYmdTmStr().CStr());
310    TIntPrV FqQtIdV;
311    int words=0, minFq=0, hasWord=0;
312    TIntSet CSet, QSet;
313    TIntSet UrlSet;
314    if (! AppearsAtUrl.Empty()) {
315      for (int q = 0; q < QuoteH.Len(); q++) {
316        const TQuote& Q = GetQtN(q);
317        TQuote::TTmUrlCntV TmUrlCntV(Q.GetUrls(), 0);
318        for (int u = 0; u < Q.GetUrls(); u++) {
319          if (UrlSet.IsKey(Q.GetUrlId(u))) {
320            TmUrlCntV.Add(Q.TmUrlCntV[u]);
321            continue; }
322          if (strstr(GetStr(Q.GetUrlId(u)), AppearsAtUrl.CStr())!=NULL) {
323            TmUrlCntV.Add(Q.TmUrlCntV[u]);
324            UrlSet.AddKey(Q.GetUrlId(u)); } 
325        }
326        TQuote* QPt = (TQuote*) &(QuoteH[q]);
327        QPt->TmUrlCntV = TmUrlCntV; 
328      }
329    }
330    printf("done.");
331    for (int q = 0; q < QuoteH.Len(); q++) {
332      const TQuote& Qt = GetQtN(q);
333      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { words++;  continue; }
334      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { hasWord++;  continue; }
335      int Fq = 0;
336      if (OnlyClustRoots && Qt.GetTy() == qtRoot) {
337        IAssert(Qt.GetCId() == GetQtId(q));
338        IAssert(! CSet.IsKey(Qt.GetCId()));  CSet.AddKey(Qt.GetCId());
339        if ((! HasWord.Empty()) && GetQt(GetCentrQtId(Qt.GetCId())).GetStr().SearchStr(HasWord)==-1) { hasWord++; continue; } 
340        TQuote CentrQt;  GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
341        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, CentrQt)) { continue; }
342        Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
343        if (Fq < MinQtFq) { minFq++; continue; }
344        const int Doms = CentrQt.GetDoms(*this);
345        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
346      }
347      else {
348        if (! UrlSet.Empty() && ! AppearsAt(UrlSet, Qt)) { continue; }
349        Fq = Qt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
350        if (Fq < MinQtFq) { minFq++; continue; }
351        const int Doms = Qt.GetDoms(*this);
352        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
353      }
354      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
355      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
356    }
357    printf("  skip %d : word len < %d\n", words, MinWrdLen);
358    printf("  skip %d : qt fq < %d\n", minFq, MinQtFq);
359    if (! HasWord.Empty()) { printf("  skip %d : not containing '%s'\n", hasWord, HasWord.CStr()); }
360    printf("  remaining %d quotes\n", FqQtIdV.Len());
361    FqQtIdV.Sort(false);
362    QtIdV.Clr(false);
363    TIntSet SeenSet;
364    for (int i = 0; i < FqQtIdV.Len(); i++) {
365      if (i < 100) { printf(" fq:%d", FqQtIdV[i].Val1()); }
366      const int qid = FqQtIdV[i].Val2;
367      if (! SeenSet.IsKey(qid)) {
368        QtIdV.Add(qid);
369        SeenSet.AddKey(qid);
370        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
371          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
372          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
373        }
374      }
375    }
376    printf("  return %d quotes\n", QtIdV.Len());
377  }
378  int AppearsAtDom(const TQuote& CentrQt, const TIntSet& GoodDom, const TIntH& UrlDomH) {
379    int DomCnt = 0;
380    for (int u = 0; u < CentrQt.GetUrls(); u++) {
381      const int U = CentrQt.GetUrlId(u);
382      IAssert(UrlDomH.IsKey(U));
383      if (GoodDom.IsKey(UrlDomH.GetDat(U))) { 
384        DomCnt++; }
385    }
386    return DomCnt;
387  }
388  void TQuoteBs::GetQtIdVByFq(TIntV& QtIdV, const int& MinWrdLen, const int& MinQtFq, const TStrV& FromDomains,
389                              const bool& OnlyClustRoots, const TStr& HasWord, int MinDoms) const {
390    printf("Get top quotes from %d quotes appearing at %d domains\n", QuoteH.Len(), FromDomains.Len());
391    TIntPrV FqQtIdV;
392    TIntH UrlDomH;
393    TStrSet DomainSet;
394    TIntSet QSet;
395    for (int q = 0; q < QuoteH.Len(); q++) {
396      const TQuote& Q = GetQtN(q);
397      for (int u = 0; u < Q.GetUrls(); u++) {
398        const int U = Q.GetUrlId(u);
399        const int D = DomainSet.AddKey(TStrUtil::GetDomNm2(GetStr(U)));
400        UrlDomH.AddDat(U, D);
401      }
402    }
403    TIntSet GoodDom;
404    for (int d = 0; d < DomainSet.Len(); d++) {
405      for (int f = 0; f < FromDomains.Len(); f++) {
406        if (DomainSet[d].SearchStr(FromDomains[f]) != -1) {
407          GoodDom.AddKey(d); break; }
408      }
409    }
410    printf("%d total domains\n", DomainSet.Len());
411    printf("%d from domains\n", FromDomains.Len());
412    printf("%d good domains\n", GoodDom.Len());
413    printf("done.\n\n");
414    const TSecTm BegTm(1), EndTm(TSecTm::GetCurTm());
415    for (int q = 0; q < QuoteH.Len(); q++) {
416      const TQuote& Qt = GetQtN(q);
417      if (TStrUtil::CountWords(Qt.QtStr.CStr()) < MinWrdLen) { continue; }
418      if ((! HasWord.Empty()) && Qt.QtStr.SearchStr(HasWord)==-1) { continue; }
419      int Fq = 0;
420      if (Qt.GetTy() == qtRoot) {
421        TQuote CentrQt;
422        GetMergedClustQt(Qt.GetCId(), CentrQt, true); 
423        if (AppearsAtDom(CentrQt, GoodDom, UrlDomH) < MinDoms) { continue; }
424        Fq = CentrQt.GetFq(BegTm, EndTm, utUndef, *this);
425        if (Fq < MinQtFq) { continue; }
426        const int Doms = CentrQt.GetDoms(*this);
427        if (Doms < 3 || 5*Doms < CentrQt.GetUrls()) { continue; }
428      }
429      else if (! OnlyClustRoots) {
430        if (AppearsAtDom(Qt, GoodDom, UrlDomH) < MinDoms) { continue; }
431        Fq = Qt.GetFq(BegTm, EndTm, utUndef, *this);
432        if (Fq < MinQtFq) { continue; }
433        const int Doms = Qt.GetDoms(*this);
434        if (Doms < 3 || 4*Doms < Qt.GetUrls()) { continue; }
435      }
436      IAssert(! QSet.IsKey(GetQtId(q))); QSet.AddKey(GetQtId(q));
437      FqQtIdV.Add(TIntPr(Fq, GetQtId(q)));
438    }
439    printf("  remaining %d quotes\n", FqQtIdV.Len());
440    FqQtIdV.Sort(false);
441    QtIdV.Clr(false);
442    TIntSet SeenSet;
443    for (int i = 0; i < FqQtIdV.Len(); i++) {
444      const int qid = FqQtIdV[i].Val2;
445      if (! SeenSet.IsKey(qid)) {
446        QtIdV.Add(qid);
447        SeenSet.AddKey(qid);
448        if (GetQt(qid).GetTy()==qtRoot || GetQt(qid).GetTy()==qtCentr) {
449          const TIntV& ClustV = GetClust(GetQt(qid).GetCId());
450          for (int c = 0; c < ClustV.Len(); c++) { SeenSet.AddKey(ClustV[c]); }
451        }
452      }
453    }
454    printf("  return %d quotes\n", QtIdV.Len());
455  }
456  void TQuoteBs::GetQtIdVByTm(const int& WndSzHr, const int& StepHr, const int& MinWrdLen, const int& MinQtFq, const int& TakePerStep) const {
457    const TTmUnit TmUnit = tmu4Hour;
458    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
459    MinTm=MinTm.Round(TmUnit); MaxTm=MaxTm.Round(TmUnit);
460    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
461    printf("  time window %dh, step size %dh, min wrd len %d, take top %d per step\n", WndSzHr, StepHr, MinWrdLen, TakePerStep);
462    TIntSet TopQtIdSet;
463    TIntV TopQtIdV;
<span onclick='openModal()' class='match'>464    int cnt=0;
465    FILE *F = fopen("top_qts_per_time_unit.txt", "wt");
466    for (TSecTm Tm=MinTm; Tm <= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, "", "", utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
</span>468      fprintf(F,"week of: %s\n", Tm.GetYmdTmStr().CStr());
469      for (int q = 0, j=0; q < TopQtIdV.Len() && j<3; q++) {
470        if (! TopQtIdSet.IsKey(TopQtIdV[q])) {
471          fprintf(F, "%s\t%d\n", GetQt(GetCentrQtId(TopQtIdV[q])).GetStr().CStr(), GetClustFq(TopQtIdV[q]));
472          j++; }
473        TopQtIdSet.AddKey(TopQtIdV[q]);
474      }
475      fprintf(F, "\n");
476    }
477    fclose(F);
478    printf("  done %d quotes\n", TopQtIdSet.Len());
479  }
480  void TQuoteBs::GetCIdVByFq(TIntV& CIdV, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy, const bool& OnlyAfterRoot, const TSecTm& BegTm, const TSecTm& EndTm) const {
481    printf("Get top clusters from %d clusters\n", GetClusts());
482    TIntPrV FqCIdV;
483    for (int c = 0; c < GetClusts(); c++) {
484      const int CId = GetCId(c);
485      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
486      IAssert(GetQt(CId).GetTy()==qtRoot);
487      const int CentrQId = GetCentrQtId(CId);
488      if (CentrQId == -1) { continue; }
489      if ((! RootHasWord.Empty()) && GetQt(CentrQId).GetStr().SearchStr(RootHasWord)==-1) { continue; } 
490      TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, OnlyAfterRoot); 
491      const int Fq = CentrQt.GetFq(BegTm, EndTm, OnlyCountTy, *this);
492      if (Fq < MinClFq) { continue; }
493      FqCIdV.Add(TIntPr(Fq, CId));
494    }
495    printf("  remaining %d clusters\n", FqCIdV.Len());
496    FqCIdV.Sort(false);
497    CIdV.Clr(false);
498    for (int i = 0; i < FqCIdV.Len(); i++) {
499      CIdV.Add(FqCIdV[i].Val2); }
500  }
501  void TQuoteBs::GetMinMaxTm(TSecTm& MinTm, TSecTm& MaxTm) const {
502    MinTm = MaxTm = TSecTm();
503    for (int q = 0; q < QuoteH.Len(); q++) {
504      const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
505      if (V.Empty()) { continue; }
506      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
507        MinTm = V[0].Tm(); }
508      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
509        MaxTm = V[0].Tm(); }
510    }
511  }
512  void TQuoteBs::GetMinMaxTm(const TIntV& QtIdV, TSecTm& MinTm, TSecTm&MaxTm) const {
513    MinTm = MaxTm = TSecTm();
514    for (int q = 0; q < QtIdV.Len(); q++) {
515      const TQuote::TTmUrlCntV& V = GetQt(QtIdV[q]).TmUrlCntV;
516      if (V.Empty()) { continue; }
517      if (! MinTm.IsDef() || MinTm > V[0].Tm()) {
518        MinTm = V[0].Tm(); }
519      if (! MaxTm.IsDef() || MaxTm < V[0].Tm()) {
520        MaxTm = V[0].Tm(); }
521    }
522  }
523  void TQuoteBs::GetQtPageUrl(const TIntV& QtIdV, TIntH& QtUrlIdH) const {
524    THash<TChA, TInt> DomQtCntH;
525    for (int q = 0; q < Len(); q++) {
526      const TQuote& Q = GetQtN(q);
527      for (int u = 0; u < Q.GetUrls(); u++) {
528        DomQtCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += Q.TmUrlCntV[u].Cnt(); }
529    }
530    const TStr StopList = "blog.myspace.com|www.newsmeat.com|us.rd.yahoo.com|www.startribune.com|"
531      "news.originalsignal.com|uk.news.yahoo.com|ap.google.com|www.cnn.com|www.opednews.com";
532    TStrV StopListV; StopList.SplitOnAllCh('|', StopListV);
533    for (int s = 0; s < StopListV.Len(); s++) {
534      DomQtCntH.AddDat(StopListV[s]) = 1; }
535    DomQtCntH.SortByDat(false);
536    QtUrlIdH.Clr(false);
537    for (int q = 0; q < QtIdV.Len(); q++) {
538      const TQuote& Q = GetQt(QtIdV[q]);
539      int DomFq=0, BestUrlId=0;
540      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
541        const TChA Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
542        if (DomFq < DomQtCntH.GetDat(Dom)) {
543          DomFq = DomQtCntH.GetDat(Dom);
544          BestUrlId = Q.TmUrlCntV[u].UrlId();
545        }
546      }
547      QtUrlIdH.AddDat(QtIdV[q], BestUrlId);
548    }
549  }
550  void TQuoteBs::AddQuote(const TQuote& Quote, const TQuoteBs& CurQtBs) {
551    const int QtId = CurQtBs.GetQtId(Quote.GetStr().CStr());
552    TQuote& Qt = QuoteH.AddDat(QtId);
553    StrQtIdH.AddDat(Quote.GetStr().CStr(), QtId);
554    Qt.QtCIdTy = TQuote::TQtIdTy(Quote.GetCId(), Quote.GetTy());
555    Qt.QtStr = Quote.QtStr;
556    Qt.TmUrlCntV = Quote.TmUrlCntV;
557    for (int u = 0; u < Qt.TmUrlCntV.Len(); u++) {
558      Qt.TmUrlCntV[u].SetUrlId(AddStr(CurQtBs.GetStr(Quote.TmUrlCntV[u].UrlId())));
559    }
560  }
561  void TQuoteBs::AddQuote(const TVec<TChA>& QuoteV, const TVec<TChA>& LinkV, const TChA& PostUrlStr, const TSecTm& PubTm, const int& MinQtWrdLen) {
562    TIntH QtCntH; 
563    for (int q = 0; q < QuoteV.Len(); q++) {
564      if (TStrUtil::CountWords(QuoteV[q].CStr()) < MinQtWrdLen) { continue; } 
565      int QtId = GetQtId(QuoteV[q].CStr());
566      if (QtId == -1) { 
567        IAssert(! IsStr(QuoteV[q].CStr()));
568        QtId = QuoteH.Len();
569        TQuote& Qt = QuoteH.AddDat(QtId);
570        Qt.QtCIdTy = TQuote::TQtIdTy(QtId, qtQuote);
571        Qt.QtStr = QuoteV[q];
572        StrQtIdH.AddDat(QuoteV[q].CStr(), QtId);
573      } else { IAssert(IsStr(QuoteV[q].CStr())); }
574      IAssert(IsQtId(QtId));
575      QtCntH.AddDat(QtId) += 1; 
576    }
577    if (QtCntH.Len() > 0) {
578      const int PostUrlId = AddStr(PostUrlStr);
579      for (int i = 0; i < QtCntH.Len(); i++) {
580        QuoteH.GetDat(QtCntH.GetKey(i)).TmUrlCntV.Add(TQuote::TTmUrlCnt(PubTm, PostUrlId, QtCntH[i]));
581      }
582    }
583    const TChA PostDomain = TStrUtil::GetDomNm(PostUrlStr);
584    for (int l = 0; l < LinkV.Len(); l++) {
585      const TChA& Url = LinkV[l];
586      if (TStrUtil::GetDomNm(Url) == PostDomain) { continue; } 
587      if (IsStr(Url.CStr())) { UrlInDegH.AddDat(GetStrId(Url.CStr())) += 1; }
588    }
589  }
590  PQuoteBs TQuoteBs::GetQuoteBs(const TIntV& QtIdV) const {
591    PQuoteBs _NewQtBs = TQuoteBs::New();
592    TQuoteBs& NewQtBs = *_NewQtBs;
593    for (int q = 0; q < QtIdV.Len(); q++) {
594      const TQuote& Qt = GetQt(QtIdV[q]);
595      NewQtBs.AddQuote(Qt, *this);
596    }
597    for (int u = 0; u < UrlInDegH.Len(); u++) {
598      const char* UrlStr = GetStr(UrlInDegH.GetKey(u));
599      if (NewQtBs.IsStr(UrlStr)) {
600        NewQtBs.UrlInDegH.AddDat(NewQtBs.GetStrId(UrlStr), UrlInDegH[u]); }
601    }
602    for (int t = 0; t < UrlTyH.Len(); t++) {
603      const char* UrlStr = GetStr(UrlTyH.GetKey(t));
604      if (NewQtBs.IsStr(UrlStr)) {
605        NewQtBs.UrlTyH.AddDat(NewQtBs.GetStrId(UrlStr), UrlTyH[t]); }
606    }
607    for (int c = 0; c < GetClusts(); c++) {
608      const int CId = GetCId(c);
609      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
610      const TIntV& CQtIdV = GetClust(CId);
611      if (NewQtBs.IsQtId(CId)) {
612        IAssert(! NewQtBs.ClustQtIdVH.IsKey(CId));
613        TIntV& CIdV = NewQtBs.ClustQtIdVH.AddDat(CId);
614        for (int i = 0; i < CQtIdV.Len(); i++) {
615          if (NewQtBs.IsQtId(CQtIdV[i])) { CIdV.Add(CQtIdV[i]); }
616        }
617        IAssert(CIdV.Len() > 0);
618      }
619    }
620    return _NewQtBs;
621  }
622  int TQuoteBs::GetQtsInClust() const {
623    int qts = 0;
624    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
625      qts += ClustQtIdVH[q].Len();
626    }
627    return qts;
628  }
629  int TQuoteBs::GetClustFq(const int& CId) const {
630    int fq = 0;
631    TIntSet S;
632    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
633    for (int c = 0; c < ClustV.Len(); c++) {
634      fq += GetQt(ClustV[c]).GetFq();
635      IAssert(! S.IsKey(ClustV[c]));
636      S.AddKey((ClustV[c]));
637    }
638    return fq;
639  }
640  int TQuoteBs::GetClustFq(const int& CId, const TUrlTy& UrlTy) const {
641    int fq = 0;
642    const TIntV& ClustV = ClustQtIdVH.GetDat(CId);
643    for (int c = 0; c < ClustV.Len(); c++) {
644      fq += GetQt(ClustV[c]).GetFq(UrlTy, *this);
645    }
646    return fq;
647  }
648  int TQuoteBs::GetCentrQtId(const int& CId) const {
649    return GetCentrQtId(GetClust(CId));
650  }
651  int TQuoteBs::GetCentrQtId(const TIntV& ClustV) const {
652    TIntPrV QtFqIdV;
653    for (int c = 0; c < ClustV.Len(); c++) {
654      if (! IsQtId(ClustV[c])) { continue; }
655      const TQuote& Q = GetQt(ClustV[c]);
656      QtFqIdV.Add(TIntPr(Q.GetUrls(), ClustV[c]));
657    }
658    if (QtFqIdV.Empty()) { return -1; }
659    QtFqIdV.Sort(false);
660    const TStr FqStr = GetQt(QtFqIdV[0].Val2).GetStr(); 
661    for (int c = 0; c < QtFqIdV.Len(); c++) {
662      IAssert(IsQtId(QtFqIdV[c].Val2));
663      const TQuote& Q = GetQt(QtFqIdV[c].Val2);
664      const int Words = TStrUtil::CountWords(Q.GetStr().CStr());
665      if (Words >= 6 && Words < 50 && strstr(Q.GetStr().CStr(), FqStr.CStr())!=NULL) {
666        return QtFqIdV[c].Val2; }
667    }
668    return QtFqIdV[0].Val2;
669  }
670  void TQuoteBs::GetMergedClustQt(const int& CId, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
671    const TIntV& ClustV = GetClust(CId);
672    GetMergedClustQt(ClustV, NewQt, OnlyAfterBegTm);
673  }
674  void TQuoteBs::GetMergedClustQt(const TIntV& ClustV, TQuote& NewQt, const bool& OnlyAfterBegTm) const {
675    const int CentrQtId = GetCentrQtId(ClustV);
676    const TSecTm BegTm = OnlyAfterBegTm ? GetClustBegTm(ClustV, CentrQtId) : TSecTm(1);
677    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
678    for (int c = 0; c < ClustV.Len(); c++) {
679      const TQuote& Q = GetQt(ClustV[c]);
680      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
681        if (Q.TmUrlCntV[u].Tm() >= BegTm) {
682          TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.TmUrlCntV[u].Tm(), Q.TmUrlCntV[u].UrlId())) += Q.TmUrlCntV[u].Cnt(); }
683      }
684    }
685    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
686    NewQt.QtStr = GetQt(CentrQtId).GetStr(); 
687    if (! TmUrlCntH.Empty()) {
688      NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
689      for (int u = 0; u < TmUrlCntH.Len(); u++) {
690        NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
691      }
692      NewQt.TmUrlCntV.Sort();
693    }
694  }
695  TSecTm TQuoteBs::GetClustBegTm(const int& CId, const int& CentrQtId) const {
696    const TIntV& ClustV = GetClust(CId);
697    return GetClustBegTm(ClustV, CentrQtId);
698  }
699  TSecTm TQuoteBs::GetClustBegTm(const TIntV& ClustV, const int& CentrQtId) const {
700    TStrHash<TInt> StrH;
701    TIntV CntrWIdV, WIdV;
702    int WIdV1Start, WIdV2Start, SkipId;
703    TStrUtil::GetAddWIdV(StrH, GetQt(CentrQtId).GetStr().CStr(), CntrWIdV);
704    TSecTm BegTm = TSecTm::GetCurTm();
705    for (int c = 0; c < ClustV.Len(); c++) {
706      TStrUtil::GetAddWIdV(StrH, GetQt(ClustV[c]).GetStr().CStr(), WIdV);
707      if (WIdV.Len() < CntrWIdV.Len()) { continue; }
708      const int Overlap = LongestCmnSubSq(CntrWIdV, WIdV, WIdV1Start, WIdV2Start, SkipId);
709      if (Overlap >= CntrWIdV.Len() && SkipId==0) { 
710        if (GetQt(ClustV[c]).TmUrlCntV.Empty()) { continue; }
711        BegTm = TMath::Mn(BegTm, GetQt(ClustV[c]).TmUrlCntV[0].Tm()); 
712      }
713    }
714    return BegTm;
715  }
716  int TQuoteBs::LongestCmnSubSq(const TIntV& WIdV1, const TIntV& WIdV2, int& WIdV1Start, int& WIdV2Start, int& SkipId) {
717    const TIntV& V1 = WIdV1.Len()>WIdV2.Len() ? WIdV1:WIdV2; 
718    const TIntV& V2 = WIdV1.Len()>WIdV2.Len() ? WIdV2:WIdV1; 
719    const int V1Len = V1.Len();
720    const int V2Len = V2.Len();
721    static THash<TInt, TIntV> WIdPosH;
722    static THashSet<TInt> V2WIdSet;
723    V2WIdSet.Clr(false);
724    for (int i=0; i < WIdPosH.Len(); i++) { WIdPosH[i].Clr(false); }
725    WIdPosH.Clr(false, -1, false);
726    WIdV1Start = WIdV2Start = SkipId = 0;
727    for (int i = 0; i < V2Len; i++) { 
728      V2WIdSet.AddKey(V2[i]); }
729    for (int i = 0; i < V1Len; i++) { 
730      if (V2WIdSet.IsKey(V1[i])) { WIdPosH.AddDat(V1[i]).Add(i); } }
731    {const int cmnWords = WIdPosH.Len();
732    if (cmnWords < V2WIdSet.Len()) {
733      if (cmnWords < 4) { return 0; }
734      else if (V2Len >= 5 && cmnWords < 5) { return 0; }
735      else if (V2Len > 6 && (2*cmnWords < V2Len && cmnWords < 10)) { return 0; } }
736    }
737    int MaxLen = 0;
738    for (int w = 0; w < V2Len; w++) { 
739      const int wid = V2[w];
740      if (! WIdPosH.IsKey(wid)) { continue; }
741      const TIntV& OccV = WIdPosH.GetDat(wid);
742      for (int o = 0; o < OccV.Len(); o++) {
743        const int beg = OccV[o];
744        int cnt = 0, tmp = 0;
745        while (w+cnt < V2Len && beg+cnt < V1Len && V2[w+cnt]==V1[beg+cnt]) { cnt++; tmp=0; }           
746        while (beg+1+cnt < V1Len && w+cnt < V2Len && V2[w+cnt]==V1[beg+cnt+1]) { cnt++; tmp=-1; }      
747        while (beg+cnt+1 < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt+1]) {  cnt++; tmp=-2;}  
748        while (beg+cnt < V1Len && w+cnt+1 < V2Len && V2[w+cnt+1]==V1[beg+cnt]) { cnt++; tmp=-3;}       
749        if (MaxLen < cnt) { MaxLen = cnt; SkipId=tmp; WIdV1Start = beg;  WIdV2Start = w; }
750        IAssert(cnt >= 1);
751      }
752    }
753    if (! (WIdV1.Len()>WIdV2.Len())) {
754      int tmp=WIdV1Start; WIdV1Start=WIdV2Start; WIdV2Start=tmp;
755    }
756    return MaxLen;
757  }
758  void TQuoteBs::CreateClusters(const TVec<TIntV>& ClustV) {
759    TIntV CIdV;
760    ClustQtIdVH.Clr();
761    printf("len %d\n", Len());
762    for (int q = 0; q < Len(); q++) {
763      TQuote& Q = GetQt(q);
764      Q.QtCIdTy = TQuote::TQtIdTy(q, qtQuote);
765    }
766    TIntH SeenNId;
767    for (int c = 0; c < ClustV.Len(); c++) {
768      if (ClustV[c].Len() < 3) { continue; } 
769      const int CentrQtId = GetCentrQtId(ClustV[c]);
770      if (CentrQtId == -1) {
771        printf("Cluster %d of size %d has no root!!!\n", c, ClustV[c].Len());
772        for (int i = 0; i < ClustV[c].Len(); i++) {
773          printf("  %d%c", ClustV[c][i].Val, IsQtId(ClustV[c][i])?'t':'f'); } printf("\n");
774        continue;
775      }
776      IAssert(! SeenNId.IsKey(CentrQtId));
777      SeenNId.AddKey(CentrQtId);
778      TQuote& Q = GetQt(CentrQtId);
779      if (Q.GetTy() != qtQuote) { printf("  %d", Q.GetTy()); }
780      IAssert(! ClustQtIdVH.IsKey(CentrQtId));
781      Q.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtRoot);
782      ClustQtIdVH.AddDat(CentrQtId, ClustV[c]);
783      for (int q = 0; q < ClustV[c].Len(); q++) {
784        if (ClustV[c][q] == CentrQtId) { continue; }
785        IAssert(! SeenNId.IsKey(ClustV[c][q]));
786        SeenNId.AddKey(ClustV[c][q]);
787        TQuote& Q2 = GetQt(ClustV[c][q]);
788        Q2.QtCIdTy = TQuote::TQtIdTy(CentrQtId, qtInClust);
789      }
790    }
791  }
792  void TQuoteBs::ClusterQts(const int& MinRootWrdLen, const int& MinQtFq, const TStr& OutFNmPref, const TStrV& BlackListV) {
793    printf("Cluster quotes with min Fq >= %d: %d total quotes\n", MinQtFq, Len());
794    TExeTm ExeTm;
795    TStrHash<TInt> StrH;
796    TVec<TPair<TInt, TIntV> > QWIdVV;  
797    { TIntPrV LenQIdV;  TIntV QWIdV;
798    printf("sort qid by len\n");
799    TStrHash<TInt> BlackListH;
800    for (int i = 0; i < BlackListV.Len(); i++) { BlackListH.AddDatId(BlackListV[i].GetTrunc()); }
801    printf("blacklist len: %d\n", BlackListH.Len());
802    for (int q1 = 0; q1 < Len(); q1++) {
803      const TQuote& Q = GetQtN(q1);
804      const int Doms = Q.GetDoms(*this);
805      if ((Q.GetTy()==qtQuote || Q.GetTy()==qtRoot) && Doms>1 && Doms*4>Q.GetUrls()
806        && Q.GetFq() >= MinQtFq && (! BlackListH.IsKey(Q.GetStr().CStr()))) { 
807          LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1))); }
808    }
809    printf("sort %d candidates\n", LenQIdV.Len());
810    LenQIdV.Sort(false);
811    printf("get word id vectors\n");
812    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
813      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
814      QWIdVV.Add(TPair<TInt, TIntV>(LenQIdV[q1].Val2, QWIdV));
815    } }
816    printf("  %d root quotes\n", ClustQtIdVH.Len());
817    printf("  %d quotes to merge\n", QWIdVV.Len());
818    int NMergers=0;
819    FILE *F = fopen(TStr(OutFNmPref+"-merged.txt").CStr(), "wt");
820    const int ClusterQ=QWIdVV.Len();
821    for (int q1 = 0; q1 < ClusterQ; q1++) {
822      if (QWIdVV[q1].Val2.Len() < MinRootWrdLen) { continue; } 
823      const int Qt1Id = QWIdVV[q1].Val1;
824      for (int q2 = q1+1; q2 < ClusterQ; q2++) {
825        int idx1=0, idx2=0, SkipTy=0;
826        bool DoMerge = false;
827        const int ShortLen = TMath::Mn(QWIdVV[q1].Val2.Len(), QWIdVV[q2].Val2.Len());
828        if (ShortLen == 0) { continue; }
829        const int Overlap = LongestCmnSubSq(QWIdVV[q1].Val2, QWIdVV[q2].Val2, idx1, idx2, SkipTy);
830        if (ShortLen == 4 && Overlap == 4 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
831        else if (ShortLen == 5 && Overlap == 5 &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
832        else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
833        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
834        if (DoMerge == true) {
835          NMergers++;
836          const int Qt2Id = QWIdVV[q2].Val1;
837          TQuote& Q1 = GetQt(Qt1Id);
838          TQuote& Q2 = GetQt(Qt2Id);
839          if (Q1.GetTy() != qtRoot) { 
840            IAssert(Q1.GetTy() == qtQuote);
841            IAssert(! ClustQtIdVH.IsKey(Qt1Id));
842            ClustQtIdVH.AddDat(Qt1Id).Add(Qt1Id);
843            Q1.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtRoot);
844          } else { IAssert(Q1.GetTy() == qtRoot); }
845          if (Q2.GetTy() == qtRoot) { 
846            for (int c = 0; c < ClustQtIdVH.GetDat(Qt2Id).Len(); c++) {
847              ClustQtIdVH.AddDat(Qt1Id).Add(ClustQtIdVH.GetDat(Qt2Id)[c]); }
848            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
849            ClustQtIdVH.DelKey(Qt2Id);
850            IAssert(ClustQtIdVH.AddDat(Qt1Id).IsIn(Qt2Id));
851          } else {
852            IAssert(Q2.GetTy() == qtQuote);
853            Q2.QtCIdTy = TQuote::TQtIdTy(Qt1Id, qtInClust);
854            ClustQtIdVH.AddDat(Qt1Id).Add(Qt2Id);
855          }
856          QWIdVV[q2].Val2.Clr(true); 
857          { TStr Str= "    :"; if(SkipTy==-1){Str="long=";} else if(SkipTy==-2){Str="both=";} else if(SkipTy==-3){Str="shrt=";}
858          if (Str.Len()>0) { printf("%c", Str[0]); }
859          if (ClustQtIdVH.GetDat(Qt1Id).Len() == 2) { fprintf(F, "\n[%d] %s \t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()), Q1.QtStr.CStr(), Q1.GetFq()); }
860          fprintf(F, "%s%d [%d] %s \t%d\n", Str.CStr(), Overlap, TStrUtil::CountWords(Q2.QtStr.CStr()), Q2.QtStr.CStr(), Q2.GetFq()); }
861        }
862      }
863      if (ClustQtIdVH.IsKey(Qt1Id)) {
864        ClustQtIdVH.GetDat(Qt1Id).Pack();
865        ClustQtIdVH.GetDat(Qt1Id).Sort();
866        QWIdVV[q1].Val2.Clr(true);
867      }
868      if (q1>0 && q1 % 100 == 0) {
869        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMergers, ExeTm.GetStr());
870        if (q1 % 1000 == 0) { printf("save.\n");  fflush(F);
871          TFOut FOut(OutFNmPref+"-QtBs.ClustQtIdVH"); ClustQtIdVH.Save(FOut); }
872      }
873    }
874    fclose(F);
875    printf("\n%d quotes, %d clusters [%s]\n\n.", NMergers, ClustQtIdVH.Len(), ExeTm.GetStr());
876  }
877  void TQuoteBs::ResetClusters() {
878    ClustQtIdVH.Clr();
879    for (int q = 0; q < Len(); q++) {
880      GetQtN(q).QtCIdTy = TQuote::TQtIdTy(GetQtId(q), qtQuote);
881    }
882  }
883  void TQuoteBs::ReassignToClust(const int& QtId, const int& NewCId) {
884    const int QtCl = GetQt(QtId).GetCId();
885    printf("assign %d from clust %d to %d\n", QtId, QtCl, NewCId);
886    if (QtCl != QtId) {
887      ClustQtIdVH.GetDat(QtCl).DelIfIn(QtId); }
888    GetQt(QtId).QtCIdTy = TQuote::TQtIdTy(NewCId, qtInClust);
889    ClustQtIdVH.AddDat(NewCId).Add(QtId);
890  }
891  void TQuoteBs::Mergec2Clusters(const int& ParentCId, const int& ChildCId) {
892    IAssert(IsClust(ParentCId) && IsClust(ChildCId));
893    printf("merging %d (fq: %d) to %d (%d fq)\n", ChildCId, GetClustFq(ChildCId), ParentCId, GetClustFq(ParentCId));
894    TIntSet ClustSet;
895    { const TIntV& ClustV = GetClust(ParentCId);
896    for (int c = 0; c < ClustV.Len(); c++) {
897      ClustSet.AddKey(ClustV[c]); } }
898    { const TIntV& ClustV = GetClust(ChildCId);
899    for (int c = 0; c < ClustV.Len(); c++) {
900      ClustSet.AddKey(ClustV[c]); } }
901    ClustSet.GetKeyV(ClustQtIdVH.GetDat(ParentCId));
902    GetQt(ChildCId).QtCIdTy = TQuote::TQtIdTy(ChildCId, qtInClust);
903    ClustQtIdVH.DelKey(ChildCId);
904    ClustQtIdVH.Defrag();
905  }
906  PClustNet TQuoteBs::GetClustNet(const int& MinQtFq, const TStr& OutFNmPref) const {
907    printf("Cluster quotes with Fq >= %d: %d total quotes\n", MinQtFq, Len());
908    TExeTm ExeTm;
909    TStrHash<TInt> StrH;
910    FILE *F = fopen(TStr(OutFNmPref+"-candidates.txt").CStr(), "wt");
911    THash<TInt, TIntV> QWIdVH;  
912    { TIntPrV LenQIdV;  TIntV QWIdV;
913    printf("sort qid by len\n");
914    for (int q1 = 0; q1 < Len(); q1++) {
915      const TQuote& Q = GetQtN(q1);
916      const int Doms = Q.GetDoms(*this);
917      if ((Q.GetTy()!=qtCentr) && Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
918        LenQIdV.Add(TIntPr(TStrUtil::CountWords(Q.QtStr.CStr()), GetQtId(q1)));
919      }
920    }
921    printf("sort %d candidates by word length\n", LenQIdV.Len());
922    LenQIdV.Sort(false);
923    for (int q1 = 0; q1 < LenQIdV.Len(); q1++) {
924      TStrUtil::GetAddWIdV(StrH, GetQt(LenQIdV[q1].Val2).QtStr.CStr(), QWIdV);
925      QWIdVH.AddDat(LenQIdV[q1].Val2, QWIdV);
926      fprintf(F, "%s\n", GetQt(LenQIdV[q1].Val2).QtStr.CStr());
927    } }
928    printf("  %d root quotes\n", ClustQtIdVH.Len());
929    printf("  %d quotes to merge\n", QWIdVH.Len());
930    const int ClusterQ=QWIdVH.Len();
931    PClustNet ClustNet = TClustNet::New();
932    TIntH NIdDepthH;
933    TIntSet SeenQtIdSet;
934    int NMerges=0, idx1=0, idx2=0, SkipTy=0; 
935    for (int q1 = 0; q1 < ClusterQ; q1++) { 
936      SeenQtIdSet.Clr(false);
937      const int Qt1Id = QWIdVH.GetKey(q1);
938      for (int q2 = q1-1; q2 >= 0; q2--) { 
939        const int Qt2Id = QWIdVH.GetKey(q2);
940        if (SeenQtIdSet.IsKey(Qt2Id)) { continue; }
941        bool DoMerge = false;
942        const int Overlap = LongestCmnSubSq(QWIdVH[q1], QWIdVH[q2], idx1, idx2, SkipTy);
943        const int ShortLen = QWIdVH[q1].Len(); IAssert(QWIdVH[q1].Len()<= QWIdVH[q2].Len());
944        if (ShortLen == 4 && Overlap == 4) { DoMerge=true; } 
945        else if (ShortLen == 5 && Overlap == 5) { DoMerge=true; } 
946        else if (ShortLen == 6 && Overlap >= 5) { DoMerge=true; }
947        else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
948        if (DoMerge==true) { NMerges++;
949          if (! ClustNet->IsNode(Qt1Id)) { ClustNet->AddNode(Qt1Id, GetQt(Qt1Id)); }
950          if (! ClustNet->IsNode(Qt2Id)) { ClustNet->AddNode(Qt2Id, GetQt(Qt2Id)); }
951          ClustNet->AddEdge(Qt1Id, Qt2Id);
952          SeenQtIdSet.AddKey(Qt1Id);  SeenQtIdSet.AddKey(Qt2Id);
953          fprintf(F, "%d Merge\t%d\t%d\ttree\t%d\n\t%s\n\t%s\n", q1, QWIdVH[q1].Len(), QWIdVH[q2].Len(), NIdDepthH.Len(), GetQt(Qt2Id).GetStr().CStr(), GetQt(Qt1Id).GetStr().CStr());
954          fflush(F);
955        }
956      }
957      if (q1>0 && q1 % 100 == 0) {
958        printf("\r  %d/%d: %d merged [%s]  ", q1, ClusterQ, NMerges, ExeTm.GetStr());
959        if (q1 % 1000 == 0) {
960          printf("save: %d merges, %d nodes, %d edges in ClustNet [%s]\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
961          TFOut FOut(OutFNmPref+".ClustNet"); ClustNet->Save(FOut); }
962      }
963    }
964    fclose(F);
965    printf("\n%d merges, %d nodes, %d edges in ClustNet [%s]\n\n.", NMerges, ClustNet->GetNodes(), ClustNet->GetEdges(), ExeTm.GetStr());
966    return ClustNet;
967  }
968  void TQuoteBs::AddMergedQtsToQtBs() {
969    printf("merge quote clusters and add them to the quote base\n");
970    TQuote MergedQt;
971    int toDel = ClustQtIdVH.Len();
972    for (int q = 0; q < QuoteH.Len(); q++) {
973      if (QuoteH[q].GetFq() == 1) { QuoteH.DelKeyId(q); toDel--; }
974      if (toDel == 0) { break; }
975    }
976    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
977      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
978      IAssert(MergedQt.TmUrlCntV.Len() > 0); 
979      QuoteH.AddDat(QuoteH.Len(), MergedQt); 
980    }
981    printf("IsKeyIdEqKeyN: %s\n", QuoteH.IsKeyIdEqKeyN()?"T":"F");
982  }
983  PQuoteBs TQuoteBs::GetMergeClusters(const bool& OnlyClusters) const {
984    printf("Merging clusters into single quotes:\n");
985    PQuoteBs NewQtBs = TQuoteBs::New();
986    TQuote MergedQt;
987    printf("  %d quotes total\n", Len());
988    printf("  %d clusters\n", ClustQtIdVH.Len());
989    TIntSet SeenQtIdSet;
990    for (int q = 0; q < ClustQtIdVH.Len(); q++) {
991      GetMergedClustQt(ClustQtIdVH.GetKey(q), MergedQt);
992      IAssert(MergedQt.TmUrlCntV.Len() >0);
993      NewQtBs->AddQuote(MergedQt, *this);
994      const TIntV& ClustQtIdV = ClustQtIdVH[q];
995      for (int c = 0; c < ClustQtIdV.Len(); c++) {
996        const int qid = ClustQtIdV[c];
997        IAssert(! SeenQtIdSet.IsKey(qid)); 
998        SeenQtIdSet.AddKey(qid);
999      }
1000    }
1001    if (! OnlyClusters) {
1002      for (int q = 0; q < Len(); q++) {
1003        const TQuote& Q = GetQtN(q);
1004        if (! SeenQtIdSet.IsKey(GetQtId(q))) {
1005          NewQtBs->AddQuote(Q, *this); }
1006      }
1007    }
1008    printf("  %d quotes in new Quotes base\n", NewQtBs->Len());
1009    return NewQtBs;
1010  }
1011  void TQuoteBs::GetTopQtDoms(TStrIntPrV& DomCntV, const int& TakeNClust, const int& MinClFq, const TStr& RootHasWord, const TUrlTy& OnlyCountTy) const {
1012    TIntV CIdV;
1013    GetCIdVByFq(CIdV, MinClFq, RootHasWord, OnlyCountTy);
1014    THash<TStr, TInt> DomCntH;
1015    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClust); c++) {
1016      const TIntV& ClustV = GetClust(CIdV[c]);
1017      for (int q = 0; q < ClustV.Len(); q++) {
1018        const TQuote& Q = GetQt(ClustV[q]);
1019        for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1020          DomCntH.AddDat(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))) += 1;
1021        }
1022      }
1023    }
1024    DomCntH.SortByDat(false);
1025    DomCntH.GetKeyDatPrV(DomCntV);
1026  }
1027  void TQuoteBs::TopDomsByLag(const TTmUnit& TmUnit, const int& TakeNDoms, const int& TakeNClusts, const int& Thresh) const {
1028    THash<TStr, TMom> DomLagH;
1029    TIntV CIdV;  GetCIdVByFq(CIdV, 10, "", utUndef);
1030    TStrIntPrV DomCntV;  GetTopQtDoms(DomCntV, TakeNClusts, 10, "", utUndef);
1031    printf("Take %d clusters, %d domains", TakeNClusts, TakeNDoms);
1032    for (int d = 0; d < TMath::Mn(TakeNDoms, DomCntV.Len()); d++) {
1033      DomLagH.AddDat(DomCntV[d].Val1);
1034      printf("%d\t%s\n", DomCntV[d].Val2(), DomCntV[d].Val1.CStr());
1035    }
1036    int NQuotes=0;
1037    for (int c = 0; c < TMath::Mn(CIdV.Len(), TakeNClusts); c++) {
1038      TQuote Q;  GetMergedClustQt(CIdV[c], Q, false);
1039      const TSecTm MedTm = Q.GetMedianTm(TmUnit, utUndef, *this).Round(TmUnit);
1040      TStrSet DomSet;
1041      for (int u = 0; u < Q.TmUrlCntV.Len(); u++) {
1042        IAssert(IsStrId(Q.TmUrlCntV[u].UrlId()));
1043        const TStr Dom = TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()));
1044        if (DomSet.IsKey(Dom)) { continue; } 
1045        if (! DomLagH.IsKey(Dom)) { continue; }
1046        DomLagH.AddDat(Dom).Add((int(Q.TmUrlCntV[u].Tm().Round(TmUnit))-int(MedTm))/3600.0);
1047        DomSet.AddKey(Dom);
1048      }
1049      NQuotes += GetClust(CIdV[c]).Len();
1050    }
1051    FILE *F = fopen(TStr::Fmt("domsByLag-clust%d.tab", TakeNClusts).CStr(), "wt");
1052    fprintf(F, "Top clusters: %d, total quotes in top clusters: %d\n", TakeNClusts, NQuotes);
1053    TFltFltStrTrV MedLagDomV;
1054    for (int i = 0; i < DomLagH.Len(); i++) {
1055      DomLagH[i].Def();
1056      MedLagDomV.Add(TFltFltStrTr(DomLagH[i].GetMedian(), DomLagH[i].GetVals(), DomLagH.GetKey(i)));
1057    }
1058    MedLagDomV.Sort();
1059    fprintf(F, "AGGREGATE PEAK\nTop domains with least lag (out of top %d considered) that mention at least 10 pct of top %d quotes (clusters) :\n", TakeNDoms, TakeNClusts);
1060    for (int i = 0; i < MedLagDomV.Len(); i++) {
1061      if (MedLagDomV[i].Val2() < Thresh*TakeNClusts/100.0) { continue; }
1062      fprintf(F, "%g\t%g\t%s\n", MedLagDomV[i].Val1(), MedLagDomV[i].Val2(), MedLagDomV[i].Val3.CStr());
1063    }
1064    fclose(F);
1065  }
1066  void TQuoteBs::PlotQtFqCnt(const TStr& OutFNmPref) const {
1067    TIntH UrlCntH, DomCntH, CntFqH;
1068    THashSet<TChA> DomSet;
1069    for (int q = 0; q < QuoteH.Len(); q++) {
1070      const TQuote& Q = GetQtN(q);
1071      UrlCntH.AddDat(Q.GetUrls()) += 1;
1072      CntFqH.AddDat(Q.GetFq()) += 1;
1073      DomSet.Clr(false);
1074      for (int u = 0; u < Q.GetUrls(); u++) {
1075        DomSet.AddKey(TStrUtil::GetDomNm(GetStr(Q.TmUrlCntV[u].UrlId()))); }
1076      DomCntH.AddDat(DomSet.Len()) += 1;
1077    }
1078    TGnuPlot::PlotValCntH(UrlCntH, OutFNmPref+"-url", "", "number of urls quote appears at", "count", gpsLog10XY);
1079    TGnuPlot::PlotValCntH(DomCntH, OutFNmPref+"-dom", "", "number of domains quote appears at", "count", gpsLog10XY);
1080    TGnuPlot::PlotValCntH(CntFqH, OutFNmPref+"-fq", "", "number of times quote appears", "count", gpsLog10XY);
1081  }
1082  void TQuoteBs::PlotQtMediaVsBlogFq(const int& QtId, const TStr& OutFNmPref) const {
1083    TQuote::TTmFltPrV BlogFqV, MediaFqV, SmoothV;
1084    TFltPrV FqV;
1085    const TQuote& ClQt = GetQt(QtId);
1086    ClQt.GetFqOt(BlogFqV, tmu4Hour, utBlog, *this);
1087    ClQt.GetFqOt(MediaFqV, tmu4Hour, utMedia, *this);
1088    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1089    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", ClQt.GetStr().CStr(),
1090      ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1091    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, tmu4Hour, 24, 1.2, MinTm);
1092    for (int i = 0; i < SmoothV.Len(); i++) {
1093      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0), SmoothV[i].Val2())); }
1094    GP.AddPlot(FqV, gpwLines, "Blog frequency");
1095    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, tmu4Hour, 24, 1.2, MinTm);
1096    FqV.Clr();
1097    for (int i = 0; i < SmoothV.Len(); i++) {
1098      IAssert(SmoothV[i].Val1>=MinTm);
1099      FqV.Add(TFltPr(double(SmoothV[i].Val1-MinTm)/(24.0*3600.0)*(54.0/46.0), SmoothV[i].Val2()));
1100    }
1101    GP.AddPlot(FqV, gpwLines, "Media frequency");
1102    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Quote frequency (normalized for the baseline 46 vs 54)");
1103    GP.SavePng();
1104  }
1105  int NormMaxTo1(const TQuote::TTmFltPrV& TmFqV, TFltPrV& OutV, const TSecTm& BegTm) {
1106    int Idx=0;
1107    double MaxVal=0;
1108    for (int i = 0; i < TmFqV.Len(); i++) {
1109      if (MaxVal < TmFqV[i].Val2) {
1110        MaxVal=TmFqV[i].Val2; Idx = i; }
1111    }
1112    OutV.Gen(TmFqV.Len(), 0);
1113    for (int i = 0; i < TmFqV.Len(); i++) {
1114      OutV.Add(TFltPr(double(TmFqV[i].Val1-BegTm)/(24.0*3600.0), TmFqV[i].Val2())); 
1115    }
1116    return Idx;
1117  }
1118  void TQuoteBs::PlotClustMediaVsBlogFq(const int& CId, const TStr& OutFNmPref) const {
1119    const TTmUnit TmUnit = tmu4Hour;
1120    TQuote::TTmFltPrV BlogFqV, MediaFqV, AllFqV, SmoothV;
1121    TFltPrV FqV, RawFqV;
1122    TQuote ClQt;
1123    GetMergedClustQt(CId, ClQt, false);
1124    ClQt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1125    ClQt.GetFqOt(MediaFqV, TmUnit, utMedia, *this);
1126    const TSecTm MinTm = ClQt.TmUrlCntV[0].Tm().Round(tmuDay);
1127    const TSecTm  MediaPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this);
1128    const TSecTm BlogPeak = ClQt.GetPeakTm(TmUnit, TSecTm(1), utBlog, *this);
1129    const int Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600;
1130    const bool Is1Peak = ClQt.IsSinglePeak(TmUnit, TSecTm(1), utUndef, *this);
1131    TGnuPlot GP("mediaVsBlogs-"+OutFNmPref, TStr::Fmt("%s. b:%d m:%d u:%d d:%d", Is1Peak?"SINGLE PEAK": "MORE PEAKS", 
1132      Lag, ClQt.GetFq(utBlog, *this), ClQt.GetFq(utMedia, *this), ClQt.GetUrls(), ClQt.GetDoms(*this)));
1133    int mx = NormMaxTo1(BlogFqV, RawFqV, MinTm);
1134    TQuote::GetSmoothFqOt(SmoothV, BlogFqV, TmUnit, 2*24, 1.2, MinTm);
1135    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1136    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Blog : max %s", SmoothV[mx].Val1.GetYmdTmStr().CStr()), "pt 7 ps 1");
1137    const TSecTm SmBlog = SmoothV[mx].Val1;
1138    mx = NormMaxTo1(MediaFqV, RawFqV, MinTm);
1139    TQuote::GetSmoothFqOt(SmoothV, MediaFqV, TmUnit, 2*24, 1.2, MinTm);
1140    mx = NormMaxTo1(SmoothV, FqV, MinTm);
1141    const TSecTm SmMed = SmoothV[mx].Val1;
1142    const int SmLag = (int(SmBlog.Round(TmUnit))-int(SmMed.Round(TmUnit)))/3600;
1143    GP.AddPlot(FqV, gpwLines, TStr::Fmt("SMOOTH Media is behind: %dh, smooth: %dh.", -Lag, -SmLag), "pt 5 ps 1");
1144    GP.SetXYLabel(TStr::Fmt("time [days] since %s", MinTm.GetYmdTmStr().CStr()), "Cluster frequency (normalized for the baseline 46 vs 54)");
1145    GP.AddCmd("set xtics 10");
1146    GP.AddCmd("set mxtics 10");
1147    GP.SavePng();
1148  }
1149  void TQuoteBs::PlotMediaVsBlogLag(const TTmUnit& TmUnit, const bool& TakeClusters, const int& TakeN, const TStr& OutFNmPref) const {
1150    TQuote Qt;  TIntV IdV;
1151    TMom LagMom1d, LagMom2d, LagMom3d, LagMom4d, LagMom7d;
1152    TFltFltH LagCntH, LagBCntH, LagMCntH;
1153    int Cnt=0;
1154    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1155    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1156    for (int c = 0; c < TakeN; c++) {
1157      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1158      else { Qt = GetQt(IdV[c]); }
1159      const TSecTm  AllPeak = Qt.GetMedianTm(TmUnit, utUndef, *this);
1160      const TSecTm BlogPeak = Qt.GetMedianTm(TmUnit, utBlog, *this);
1161      const TSecTm  MediaPeak = Qt.GetMedianTm(TmUnit, utMedia, *this);
1162      const double Lag = (int(BlogPeak.Round(TmUnit))-int(MediaPeak.Round(TmUnit)))/3600.0;
1163      const double Lag1 = (int(BlogPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1164      const double Lag2 = (int(MediaPeak.Round(TmUnit))-int(AllPeak.Round(TmUnit)))/3600.0;
1165      if (fabs(Lag) < 1*24) { LagMom1d.Add(Lag); }
1166      if (fabs(Lag) < 2*24) { LagMom2d.Add(Lag); }
1167      if (fabs(Lag) < 3*24) { LagMom3d.Add(Lag); }
1168      if (fabs(Lag) < 4*24) { LagMom4d.Add(Lag); }
1169      if (fabs(Lag) < 7*24) { LagMom7d.Add(Lag); }
1170      LagCntH.AddDat(Lag) += 1;
1171      LagBCntH.AddDat(Lag1) += 1;
1172      LagMCntH.AddDat(Lag2) += 1;
1173      Cnt++;
1174    }
1175    TFltPrV PrV;
1176    LagMom1d.Def();  LagMom2d.Def();  LagMom3d.Def();  LagMom4d.Def();  LagMom7d.Def();
1177    { TGnuPlot GP("lagBlogsVsMedia-"+OutFNmPref, TStr::Fmt("Lag: 1D: %.2f %g;   2D: %.2f  %g;   3D: %.2f  %g;   4D: %.2f  %g;   7D: %.2f  %g",
1178      LagMom1d.GetMean(), LagMom1d.GetMedian(), LagMom2d.GetMean(), LagMom2d.GetMedian(), LagMom3d.GetMean(), LagMom3d.GetMedian(),
1179      LagMom4d.GetMean(), LagMom4d.GetMedian(), LagMom7d.GetMean(), LagMom7d.GetMedian()), true);
1180    LagBCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d BLOG", Qt.GetStr().CStr(),
1181      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1182    LagMCntH.GetKeyDatPrV(PrV); PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints, TStr::Fmt("%s. b:%d m:%d u:%d d:%d MEDIA", Qt.GetStr().CStr(),
1183      Qt.GetFq(utBlog, *this), Qt.GetFq(utMedia, *this), Qt.GetUrls(), Qt.GetDoms(*this)));
1184    GP.AddCmd("set xrange[-24:24]\nset mxtics 5\nset xtics 5");
1185    GP.SetXYLabel("media lag in hours (+: news lag, -: news lead)", "count");
1186    GP.SavePng(); }
1187    printf("\nTake top %d clusters. TmUnit: %s\n", TakeN, TTmInfo::GetTmUnitStr(TmUnit).CStr());
1188    printf("  1d:\tavg:\t%f\tmed:\t%f\n", LagMom1d.GetMean(), LagMom1d.GetMedian());
1189    printf("  2d:\tavg:\t%f\tmed:\t%f\n", LagMom2d.GetMean(), LagMom2d.GetMedian());
1190    printf("  3d:\tavg:\t%f\tmed:\t%f\n", LagMom3d.GetMean(), LagMom3d.GetMedian());
1191    printf("  4d:\tavg:\t%f\tmed:\t%f\n", LagMom4d.GetMean(), LagMom4d.GetMedian());
1192    printf("  7d:\tavg:\t%f\tmed:\t%f\n", LagMom7d.GetMean(), LagMom7d.GetMedian());
1193  }
1194  void TQuoteBs::PlotFqDecay(const TTmUnit& TmUnit, const bool& TakeClusters, const TUrlTy& CntUrlTy, const int& PlotN, const int& MinValsPerTm, const TStr& OutFNmPref) const {
1195    THash<TFlt, TMom> MomH;
1196    TQuote Qt;
1197    TIntV IdV;
1198    TGnuPlot GP("decay-"+OutFNmPref);
1199    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", CntUrlTy, false); }
1200    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", CntUrlTy); }
1201    for (int c = 0; c < PlotN; c++) {
1202      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1203      else { Qt = GetQt(IdV[c]); }
1204      TQuote::TTmFltPrV QtV;  TFltPrV TmV;
1205      Qt.GetFqOt(QtV, TmUnit);
1206      int pos=0;  double val=0.0;
1207      for (int i = 0; i < QtV.Len(); i++) {
1208        if (val < QtV[i].Val2) { pos = i;  val = QtV[i].Val2; }
1209      }
1210      const double PeakVal = val;
1211      const TSecTm PeakTm = QtV[pos].Val1;
1212      for (int i = 0; i < QtV.Len(); i++) {
1213        TmV.Add(TFltPr((double(QtV[i].Val1)-double(PeakTm))/(24.0*3600), QtV[i].Val2/PeakVal));
1214        MomH.AddDat(TmV.Last().Val1).Add(TmV.Last().Val2);
1215      }
1216      const TStr Label = "";
1217    }
1218    TFltPrV AvgV, MedV;
1219    MomH.SortByKey();
1220    for (int i = 0; i < MomH.Len(); i++) {
1221      MomH[i].Def();
1222      if (MomH[i].GetVals()< MinValsPerTm) { printf("."); continue; }
1223      AvgV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMean()));
1224      MedV.Add(TFltPr(MomH.GetKey(i), MomH[i].GetMedian()));
1225    }
1226    GP.AddPlot(AvgV, gpwLines, "Average", "lt 2 lw 2");
1227    GP.AddPlot(MedV, gpwLines, TStr::Fmt("Median (last qt: %d %d %d)", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(*this)), "lt 1 lw 2");
1228    GP.SetXYLabel("time [days]", "count");
1229    GP.AddCmd("set mxtics 6");
1230    GP.AddCmd("set xtics 1");
1231    GP.AddCmd("set yrange [0:1]");
1232    GP.AddCmd("set xrange [-5:5]");
1233    GP.AddCmd("set yzeroaxis lt -1");
1234    GP.SavePng();
1235  }
1236  void NormPeakAt1(THash<TInt, TFlt>& H) {
1237    double PeakFq=1;
1238    for (int i = 0; i < H.Len(); i++) {
1239      PeakFq=TMath::Mx((double)H[i], PeakFq); }
1240    for (int i = 0; i < H.Len(); i++) {
1241      H[i]/=PeakFq; }
1242  }
1243  void TQuoteBs::PlotBlogVsMediaFqOt(const TTmUnit& TmUnit, const bool& TakeClusters, int PlotN, const TStr& OutFNmPref) const {
1244    THash<TInt, TFlt> Peak1AllH, Peak2AllH, Peak3AllH;
1245    THash<TInt, TFlt> Peak1MedH, Peak2MedH, Peak3MedH;
1246    THash<TInt, TFlt> Peak1BlogH, Peak2BlogH, Peak3BlogH;
1247    TQuote Qt;
1248    TIntV IdV;
1249    TInt FqAtPeak;
1250    if (TakeClusters) { GetCIdVByFq(IdV, 100, "", utUndef, false); }
1251    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1252    for (int c = 0; c < TMath::Mn(PlotN, IdV.Len()); c++) {
1253      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1254      else { Qt = GetQt(IdV[c]); }
1255      if (! Qt.IsSinglePeak(TmUnit, TSecTm(0), utUndef, *this)) { PlotN++; printf("."); continue; }
1256      TQuote::TTmFltPrV AllFqV, BlogFqV, MedFqV;  TFltPrV TmV;
1257      const double Peak1 = Qt.GetPeakTm(TmUnit, TSecTm(1), FqAtPeak).GetAbsSecs(); 
1258      const double Peak2 = Qt.GetMeanTm(TmUnit, utUndef, *this).GetAbsSecs();    
1259      const double Peak3 = Qt.GetMedianTm(TmUnit, utUndef, *this).GetAbsSecs();  
1260      double PeakFq = FqAtPeak;
1261      Qt.GetFqOt(AllFqV, TmUnit, utUndef, *this);
1262      Qt.GetFqOt(MedFqV, TmUnit, utMedia, *this);
1263      Qt.GetFqOt(BlogFqV, TmUnit, utBlog, *this);
1264      PeakFq=1;
1265      for (int i = 0; i < MedFqV.Len(); i++) { PeakFq=TMath::Mx((double)MedFqV[i].Val2(), PeakFq); }
1266      for (int i = 0; i < MedFqV.Len(); i++) {
1267        const int T1 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1268        const int T2 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1269        const int T3 = (int) TMath::Round((double(MedFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1270        Peak1MedH.AddDat(T1) += MedFqV[i].Val2/PeakFq;
1271        Peak2MedH.AddDat(T2) += MedFqV[i].Val2/PeakFq;
1272        Peak3MedH.AddDat(T3) += MedFqV[i].Val2/PeakFq;
1273      }
1274      PeakFq=1;
1275      for (int i = 0; i < BlogFqV.Len(); i++) { PeakFq=TMath::Mx((double)BlogFqV[i].Val2(), PeakFq); }
1276      for (int i = 0; i < BlogFqV.Len(); i++) {
1277        const int T1 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak1)/(3600.0));
1278        const int T2 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak2)/(3600.0));
1279        const int T3 = (int) TMath::Round((double(BlogFqV[i].Val1.GetAbsSecs())-Peak3)/(3600.0));
1280        Peak1BlogH.AddDat(T1) += BlogFqV[i].Val2/PeakFq;
1281        Peak2BlogH.AddDat(T2) += BlogFqV[i].Val2/PeakFq;
1282        Peak3BlogH.AddDat(T3) += BlogFqV[i].Val2/PeakFq;
1283      }
1284    }
1285    NormPeakAt1(Peak1AllH); NormPeakAt1(Peak2AllH); NormPeakAt1(Peak3AllH);
1286    NormPeakAt1(Peak1MedH); NormPeakAt1(Peak2MedH); NormPeakAt1(Peak3MedH);
1287    NormPeakAt1(Peak1BlogH); NormPeakAt1(Peak2BlogH); NormPeakAt1(Peak3BlogH);
1288    TGnuPlot::PlotValCntH(Peak1AllH, "ALL", Peak1MedH, "MEDIA", Peak1BlogH, "BLOG", "peakMax-"+OutFNmPref, "Max is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1289    TGnuPlot::PlotValCntH(Peak3AllH, "ALL", Peak3MedH, "MEDIA", Peak3BlogH, "BLOG", "peakMed-"+OutFNmPref, "Median is the peak", "Time [h]", "Count (sum of frequencies of all quotes)");
1290  }
1291  void TQuoteBs::PlotBlogFracOt(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1292    TQuote Qt;
1293    TIntV IdV;
1294    THash<TFlt, TMom> TmMomH;
1295    THash<TFlt, TFltPr> TmBmH;
1296    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1297    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1298    for (int c = 0; c < PlotN; c++) {
1299      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1300      else { Qt = GetQt(IdV[c]); }
1301      TQuote::TTmFltPrV MedQtV, BlgQtV;
1302      Qt.GetFqOt(MedQtV, TmUnit, utMedia, *this);
1303      Qt.GetFqOt(BlgQtV, TmUnit, utBlog, *this);
1304      TFltPrV FracV;
1305      const int PeakTm = Qt.GetPeakTm(TmUnit, TSecTm(1), utUndef, *this);
1306      for (int m=0, b=0; m < MedQtV.Len(); m++) {
1307        while (b<BlgQtV.Len() && BlgQtV[b].Val1 < MedQtV[m].Val1) { b++; }
1308        if (b<BlgQtV.Len() && BlgQtV[b].Val1 == MedQtV[m].Val1) {
1309          const double Tm = (int(MedQtV[m].Val1.Round(TmUnit))-PeakTm)/(24*3600.0);
1310            const double Frac = BlgQtV[b].Val2/double(BlgQtV[b].Val2+MedQtV[m].Val2);
1311            FracV.Add(TFltPr(Tm, Frac));
1312            TmMomH.AddDat(Tm).Add(Frac);
1313          TFltPr& BM = TmBmH.AddDat(Tm);
1314          BM.Val1+= BlgQtV[b].Val2;
1315          BM.Val2+= MedQtV[m].Val2;
1316        }
1317      }
1318    }
1319    { TFltPrV PrV;
1320    for (int b = 0; b < TmMomH.Len(); b++) {
1321      TmMomH[b].Def();
1322      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMean())); }
1323    TGnuPlot GP(TStr::Fmt("fqFracA-%s", OutFNmPref.CStr()));
1324    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1325    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1326    { TFltPrV PrV;
1327    for (int b = 0; b < TmMomH.Len(); b++) {
1328      PrV.Add(TFltPr(TmMomH.GetKey(b), TmMomH[b].GetMedian())); }
1329    TGnuPlot GP(TStr::Fmt("fqFracM-%s", OutFNmPref.CStr()));
1330    PrV.Sort();  GP.AddPlot(PrV, gpwLinesPoints);
1331    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1332    { TFltPrV PrV;
1333    for (int b = 0; b < TmBmH.Len(); b++) {
1334      PrV.Add(TFltPr(TmBmH.GetKey(b), TmBmH[b].Val1/(TmBmH[b].Val1+TmBmH[b].Val2))); }
1335    TGnuPlot GP(TStr::Fmt("fqFracS-%s", OutFNmPref.CStr()));
1336    PrV.Sort(); GP.AddPlot(PrV, gpwLinesPoints);
1337    GP.AddCmd("set xrange [-7:7]\nset yzeroaxis lt -1"); GP.SavePng(); }
1338  }
1339  void TQuoteBs::PlotPopularityCnt(const bool& TakeClusters, const TUrlTy& UrlTy, const int& PlotN, const TStr& OutFNmPref) const {
1340    TIntV IdV;
1341    TIntH FqCntH;
1342    TQuote Qt;
1343    for (int c = 0; c < Len(); c++) {
1344      const TQuote& Qt = GetQtN(c);
1345      if (Qt.GetStr().IsStrIn("lipstick") && Qt.GetStr().IsStrIn("pig")) {
1346        FqCntH.AddDat(Qt.GetFq(UrlTy, *this)) += 1; }
1347    }
1348    TIntPrV FqCntV, CdfV;
1349    FqCntH.GetKeyDatPrV(FqCntV);  FqCntV.Sort();
1350    TGUtil::GetCCdf(FqCntV, CdfV);
1351    TGnuPlot::PlotValV(FqCntV, "pop-"+OutFNmPref, "", "total frequency", "count", gpsLog10XY);
1352    TGnuPlot::PlotValV(CdfV, "popCDF-"+OutFNmPref+"", "", "total frequency", "NCDF", gpsLog10XY);
1353  }
1354  void TQuoteBs::PlotEmptyY(const TTmUnit& TmUnit, const bool& TakeClusters, const int& PlotN, const TStr& OutFNmPref) const {
1355    TQuote Qt;
1356    TIntV IdV;
1357    THash<TInt, TInt> TmCumCntH;
1358    int MaxY=0;
1359    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1360    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1361    for (int c = 0; c < PlotN; c++) {
1362      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1363      else { Qt = GetQt(IdV[c]); }
1364      TQuote::TTmFltPrV QtV;
1365      Qt.GetFqOt(QtV, TmUnit);
1366      for (int i = 0; i < QtV.Len(); i++) {
1367        const int Tm = QtV[i].Val1.Round(tmu1Hour)/3600;
1368        TInt& CumCnt = TmCumCntH.AddDat(Tm);
1369        CumCnt += (int) QtV[i].Val2;
1370        MaxY = TMath::Mx(CumCnt(), MaxY);
1371      }
1372    }
1373    TmCumCntH.SortByKey(true);
1374    const int BegHr = TmCumCntH.GetKey(0);
1375    THash<TFlt, TFlt> EmptyH;
1376    TFltPrV TmV;
1377    for (int t = 0; t < TmCumCntH.Len(); t++) {
1378      printf("%d  ", TmCumCntH[t]());
1379      for (int y = TmCumCntH[t]; y < MaxY; y+=1) {
1380        EmptyH.AddDat(y) += 1; }
1381      TmV.Add(TFltPr((TmCumCntH.GetKey(t)-BegHr)/24.0, TmCumCntH[t].Val));
1382    }
1383    EmptyH.SortByKey(false);
1384    TFltPrV EmptyV;
1385    EmptyV.Add(TFltPr(EmptyH.GetKey(0), EmptyH[0]));
1386    for (int i = 1; i < EmptyH.Len(); i++) {
1387      EmptyV.Add(TFltPr(EmptyH.GetKey(i), EmptyH[i]+EmptyV.Last().Val2));
1388    }
1389    TGnuPlot::PlotValCntH(EmptyH, "emptyF-"+OutFNmPref+"-d", "Amount of empty area above the cummulative query-frequency curve", "y value", "area at y");
1390    TGnuPlot::PlotValV(EmptyV, "emptyF-"+OutFNmPref+"-c", "Amount of empty area above the cummulative query-frequency curve", "y value", "area above y");
1391    TGnuPlot::PlotValV(TmV, "emptyF1"+OutFNmPref, "Cummulative query frequency over time", "time (days)", "frequency");
1392  }
1393  PNGraph TQuoteBs::GetQuotePostNet(const TStr& DatasetFNm) const {
1394    PNGraph Graph = TNGraph::New();
1395    for (TMemesDataLoader Memes(DatasetFNm); Memes.LoadNext(); ) {
1396      if (Memes.MemeV.Empty()) { continue; }
1397      if (! IsStr(Memes.PostUrlStr.CStr())) { continue; }
1398      const int SrcNId = GetStrId(Memes.PostUrlStr.CStr());
1399      for (int u = 0; u < Memes.LinkV.Len(); u++) {
1400        if (! IsStr(Memes.LinkV[u].CStr())) { continue; }
1401        const int DstNId = GetStrId(Memes.LinkV[u].CStr());
1402        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
1403        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
1404        Graph->AddEdge(SrcNId, DstNId);
1405      }
1406    }
1407    TSnap::PrintInfo(Graph);
1408    return Graph;
1409  }
1410  PQtDomNet TQuoteBs::GetQuoteDomNet(const PNGraph& PostGraph, const int& CId) const {
1411    TQuote Qt;  GetMergedClustQt(CId, Qt, false);
1412    PQtDomNet DomG = TQtDomNet::New();
1413    TIntSet UrlSet;
1414    for (int i = 0; i < Qt.GetTimes(); i++) { UrlSet.AddKey(Qt.GetUrlId(i)); }
1415    TStrSet DomH;
1416    for (int i = 0; i < Qt.GetTimes(); i++) {
1417      const int url = Qt.GetUrlId(i);
1418      if (! PostGraph->IsNode(url)) { continue; }
1419      const int dom = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url)));
1420      TNGraph::TNodeI NI = PostGraph->GetNI(url);
1421      for (int o = 0; o < NI.GetOutDeg(); o++) {
1422        if (! UrlSet.IsKey(NI.GetOutNId(o))) { continue; }
1423        const int url2 = NI.GetOutNId(o);
1424        const int dom2 = DomH.AddKey(TStrUtil::GetDomNm2(GetStr(url2)));
1425        if (dom==dom2) { continue; }
1426        if (! DomG->IsNode(dom)) {
1427          DomG->AddNode(dom, TPair<TStr, TInt>(DomH[dom], GetUrlTy(url))); }
1428        if (! DomG->IsNode(dom2)) {
1429          DomG->AddNode(dom2, TPair<TStr, TInt>(DomH[dom2], GetUrlTy(url2))); }
1430        if (DomG->IsEdge(dom, dom2)) {
1431          DomG->GetEDat(dom, dom2) += 1; }
1432        else {
1433          DomG->AddEdge(dom, dom2, 1); }
1434      }
1435    }
1436    return DomG;
1437  }
1438  void TQuoteBs::SaveQuotes(const int& MinQtFq, const TStr& OutFNm) const {
1439    TIntV QtIdV;
1440    GetQtIdVByFq(QtIdV, 0, MinQtFq);
1441    SaveQuotes(QtIdV, OutFNm);
1442  }
1443  void TQuoteBs::SaveQuotes(const TIntV& QtIdV, const TStr& OutFNm) const {
1444    TIntSet QtIdSet;
1445    FILE *F = fopen(OutFNm.CStr(), "wt");
1446    printf("saving %d quotes\n", QtIdV.Len());
1447    fprintf(F, "#Freq\tUrls\tDomains\tQuote\n");
1448    for (int q = 0; q < QtIdV.Len(); q++) {
1449      const int QtId = QtIdV[q];
1450      if (QtIdSet.IsKey(QtId)) { continue; } 
1451      QtIdSet.AddKey(QtId);
1452      const TQuote& Q = GetQt(QtId);
1453    fprintf(F, "%d\t%d\t%d\t%s\n", Q.GetFq(), Q.GetUrls(), Q.GetDoms(*this), Q.QtStr.CStr());
1454      if (Q.GetTy() == qtRoot || Q.GetTy() == qtCentr) { 
1455        IAssert(ClustQtIdVH.IsKey(Q.GetCId()));
1456        const TIntV& ClustV = ClustQtIdVH.GetDat(Q.GetCId());
1457        for (int i = 0; i < ClustV.Len(); i++) {
1458          const TQuote& Q1 = GetQt(ClustV[i]);
1459          fprintf(F, "\t[%d] %d=%d %s\t%d\t%d\t%d\n", TStrUtil::CountWords(Q1.QtStr.CStr()),
1460            ClustV[i](), Q1.GetCId(), Q1.QtStr.CStr(), Q1.GetFq(), Q1.GetUrls(), Q1.GetDoms(*this));
1461          QtIdSet.AddKey(ClustV[i]);
1462        }
1463      }
1464    }
1465    fclose(F);
1466  }
1467  void TQuoteBs::SaveClusters(const TStr& OutFNm, const bool& SkipUrls) const {
1468    TIntPrV FqCIdV;
1469    TIntH ClSzCntH, ClFqCntH;
1470    for (int c = 0; c < GetClusts(); c++) {
1471      const int CId = GetCId(c);
1472      if ( ! IsQtId(CId)) { printf("!!! %d:%d\n", c, CId); continue; }
1473      FqCIdV.Add(TIntPr(GetClustFq(CId), CId));
1474      ClSzCntH.AddDat(GetClust(CId).Len()) += 1;
1475      ClFqCntH.AddDat(GetClustFq(CId)) += 1;
1476    }
1477    TGnuPlot::PlotValCntH(ClSzCntH, OutFNm+"-clSz", TStr::Fmt("%d clusters", GetClusts()), "Number of quotes in the cluster", "Number of clusters", gpsLog);
1478    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFq", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, false);
1479    TGnuPlot::PlotValCntH(ClFqCntH, OutFNm+"-clFqB", TStr::Fmt("%d clusters", GetClusts()), "Volume of quotes in the cluster", "Number of clusters", gpsLog, false, gpwLinesPoints, false, true);
1480    FqCIdV.Sort(false);
1481    TIntPrV QtFqV;
1482    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1483    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1484    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1485    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1486    for (int c = 0; c < FqCIdV.Len(); c++) {
1487      const int CId = FqCIdV[c].Val2;
1488      const TIntV& ClustV = GetClust(CId);
1489      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), FqCIdV[c].Val1(), GetQt(CId).GetStr().CStr(), CId);
1490      QtFqV.Clr(false);
1491      for (int q = 0; q < ClustV.Len(); q++) {
1492        IAssert(IsQtId(ClustV[q]));
1493        QtFqV.Add(TIntPr(GetQt(ClustV[q]).GetUrls(), ClustV[q])); }
1494      QtFqV.Sort(false);
1495      for (int q = 0; q < QtFqV.Len(); q++) {
1496        IAssert(IsQtId(QtFqV[q].Val2));
1497        const TQuote& Qt = GetQt(QtFqV[q].Val2);
1498        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1499        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), QtFqV[q].Val2());
1500        if (! SkipUrls) {
1501          for (int u = 0; u < Qt.GetUrls(); u++) {
1502            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1503              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1504        }
1505      }
1506    }
1507    fclose(F);
1508  }
1509  void TQuoteBs::SaveClusters(const TIntV& QtIdV, const TStr& OutFNm, const bool& SkipUrls) const {
1510    FILE *F = fopen(TStr::Fmt("%s-clust.txt", OutFNm.CStr()).CStr(), "wt");
1511    fprintf(F, "format:\n<ClSz>\t<TotFq>\t<Root>\t<ClusterId>\n");
1512    fprintf(F, "\t<QtFq>\t<Urls>\t<QtStr>\t<QuteId>\n");
1513    fprintf(F, "\t\t<Tm>\t<Fq>\t<UrlTy>\t<Url>\n\n");
1514    for (int c = 0; c < QtIdV.Len(); c++) {
1515      int CId = QtIdV[c];
1516      if (! IsClust(CId)) { CId = GetQt(CId).GetCId(); }
1517      const TIntV& ClustV = GetClust(CId);
1518      fprintf(F, "\n%d\t%d\t%s\t%d\n", ClustV.Len(), GetClustFq(CId), GetQt(CId).GetStr().CStr(), CId);
1519      for (int q = 0; q < ClustV.Len(); q++) {
1520        const TQuote& Qt = GetQt(ClustV[q]);
1521        if ((! SkipUrls) && q > 0) { fprintf(F, "\n"); }
1522        fprintf(F, "\t%d\t%d\t%s\t%d\n", Qt.GetFq(), Qt.GetUrls(), Qt.GetStr().CStr(), ClustV[q]());
1523        if (! SkipUrls) {
1524          for (int u = 0; u < Qt.GetUrls(); u++) {
1525            fprintf(F, "\t\t%s\t%d\t%s\t%s\n", Qt.TmUrlCntV[u].Tm().GetYmdTmStr().CStr(), Qt.TmUrlCntV[u].Cnt(),
1526              GetUrlTy(Qt.TmUrlCntV[u].UrlId())==utMedia?"M":"B", GetStr(Qt.TmUrlCntV[u].UrlId())); }
1527        }
1528      }
1529    }
1530    fclose(F);
1531  }
1532  void TQuoteBs::SaveBigBlogMassQt(const TStr& OutFNm) const {
1533    const TTmUnit TmUnit = tmuDay;
1534    const bool TakeClusters = true;
1535    TIntV IdV;
1536    TQuote Qt;
1537    int Candidates=0;
1538    if (TakeClusters) { GetCIdVByFq(IdV, 10, "", utUndef, false); }
1539    else { GetQtIdVByFq(IdV, 8, 10, false, "", "", utUndef); }
1540    TVec<TPair<TFlt, TStr> > ScoreV;
1541    for (int c = 0; c < IdV.Len(); c++) {
1542      if (TakeClusters) { GetMergedClustQt(IdV[c], Qt, false); }
1543      else { Qt = GetQt(IdV[c]); }
1544      const int MediaPeak = Qt.GetPeakTm(TmUnit, TSecTm(1), utMedia, *this); 
1545      const double BlogFq = Qt.GetUrls(TSecTm(MediaPeak-21*24*3600), TSecTm(MediaPeak-7*24*3600), utBlog, *this);  
1546      const double TotFq = Qt.GetUrls();
1547      if (BlogFq < 10) { continue; }
1548      Candidates++;
1549      if (BlogFq < TotFq*0.15 || BlogFq > TotFq*0.75) { continue; }
1550      ScoreV.Add(TFltStrPr(TotFq, TStr::Fmt("%g\t%g\t%s", BlogFq, TotFq, Qt.GetStr().CStr())));
1551    }
1552    printf("Considered: %d quotes\n", IdV.Len());
1553    printf("            %d candidates\n", Candidates);
1554    printf("            %d selected\n", ScoreV.Len());
1555    ScoreV.Sort(false);
1556    FILE *F = fopen(TStr::Fmt("%s.txt", OutFNm.CStr()).CStr(), "wt");
1557    fprintf(F, "total %d items\n", IdV.Len());
1558    fprintf(F, "items above blog threshdolg %d\n", ScoreV.Len());
1559    fprintf(F, "counts are numbers of urls (not actually number of occurences)\n");
1560    fprintf(F, "\nblog\ttotal\tQuote\n");
1561    for (int i = 0; i < ScoreV.Len(); i++) {
1562      fprintf(F, "%s\n", ScoreV[i].Val2.CStr());
1563    }
1564    fclose(F);
1565  }
1566  void TQuoteBs::SaveForFlash(const TIntV& QtIdV, const TStr& OutFNm, const TTmUnit& TmUnit, int SaveN, const TSecTm& BegTm, const TSecTm& EndTm, const TUrlTy& OnlyCountTy) const {
1567    const int TmUnitSecs = TTmInfo::GetTmUnitSecs(TmUnit);
1568    TVec<TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV> > QtInfoV, QtInfoV2; 
1569    TQuote::TTmFltPrV FqV, SmoothFqV;
1570    TIntV VizQtIdV;
1571    if (SaveN == -1) { SaveN = TInt::Mx; }
1572    TSecTm MinTm=TSecTm(TInt::Mx-1), MaxTm=TSecTm(1);
1573    printf("Saving top %d out of %d quotes\n", SaveN, QtIdV.Len());
1574    THash<TInt, TIntPr> WeekPeakQtIdH; 
1575    for (int q = 0; q < QtIdV.Len() && QtInfoV2.Len() < (SaveN+100); q++) { 
1576      const TQuote& Qt = GetQt(QtIdV[q]);
1577      if (Qt.GetTy() == qtQuote) {
1578        Qt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1579        if (FqV.Empty()) { continue; }
1580        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)Qt.GetPeakTm(TmUnit, BegTm)+1e-6*Qt.GetUrls(), QtIdV[q], Qt.GetFq(), FqV));
1581        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1582        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1583        VizQtIdV.Add(QtIdV[q]);
1584        TInt PeakFq;
1585        const int PeakTm = Qt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1586        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1587          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1588        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1589          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1590      } else { 
1591        const int CId = Qt.GetCId();
1592        if (! ClustQtIdVH.IsKey(CId)) { continue; }
1593        const int CentrQtId = GetCentrQtId(CId);
1594        TQuote CentrQt;  GetMergedClustQt(CId, CentrQt, true);
1595        CentrQt.GetFqOt(FqV, TmUnit, BegTm, EndTm, OnlyCountTy, *this);
1596        if (FqV.Empty()) { continue; }
1597        QtInfoV2.Add(TQuad<TFlt, TInt, TInt, TQuote::TTmFltPrV>((double)CentrQt.GetPeakTm(TmUnit, BegTm)+1e-6*CentrQt.GetUrls(), CentrQtId, GetClustFq(CId), FqV));
1598        TInt PeakFq;
1599        const int PeakTm = CentrQt.GetPeakTm(tmuWeek, BegTm, PeakFq).GetAbsSecs();
1600        if (! WeekPeakQtIdH.IsKey(PeakTm)) {
1601          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1602        else if (WeekPeakQtIdH.GetDat(PeakTm).Val1<PeakFq) {
1603          WeekPeakQtIdH.AddDat(PeakTm, TIntPr(PeakFq, QtInfoV2.Len()-1)); }
1604        MinTm = TMath::Mn(MinTm, FqV[0].Val1);
1605        MaxTm = TMath::Mx(MaxTm, FqV.Last().Val1);
1606        VizQtIdV.Add(CentrQtId);
1607      } /&bsol;*/
1608    }
1609    { TIntSet QtIdSet;
1610    for (int i = 0; i < WeekPeakQtIdH.Len(); i++) {
1611    }
1612    QtInfoV.Clr(true);
1613    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV2.Len()); i++) {
1614      if (QtIdSet.IsKey(i)) { continue; }
1615      QtInfoV.Add(QtInfoV2[i]);
1616    printf("%d  ", (int) QtInfoV2[i].Val3()); 
1617      if (QtInfoV.Len() > SaveN) { break; }
1618    } } 
1619    THash<TSecTm, TIntFltH> TmCntH; 
1620    for (int i = 0; i < QtInfoV.Len(); i++) {
1621      const TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1622      for (int t = 0; t < FqV.Len(); t++) {
1623        TmCntH.AddDat(FqV[t].Val1).AddDat(i, FqV[t].Val2); }
1624    }
1625    for (int i = 0; i < TmCntH.Len(); i++) {
1626      TmCntH[i].SortByDat(false); }
1627    const int K = 10;
1628    const int Slack = 3*24*3600; 
1629    THash<TInt, TSecTm> QtLastTopH; 
1630    for (int i = 0; i < TmCntH.Len(); i++) {
1631      TIntFltH& TmH = TmCntH[i];
1632      for (int j = 0; j < TMath::Mn(K, TmH.Len()); j++) {
1633        QtLastTopH.AddDat(TmH.GetKey(j), TmCntH.GetKey(i));
1634      }
1635    }
1636    for (int i = 0; i < QtInfoV.Len(); i++) {
1637      TQuote::TTmFltPrV& FqV = QtInfoV[i].Val4;
1638      const TSecTm LastTime = QtLastTopH.GetDat(i);
1639      int x = 0; for (x = 0; x < FqV.Len() && FqV[x].Val1 <= LastTime+Slack; x++) { }
1640      if (x < FqV.Len()) { FqV.Del(x, FqV.Len()-1); }
1641    } 
1642    printf("save from %d quotes\n", QtInfoV.Len());
1643    QtInfoV.Sort();
1644    TIntH QtIdUrlH;  GetQtPageUrl(VizQtIdV, QtIdUrlH);
1645    FILE *F = fopen(TStr::Fmt("qtOt-%sQ.tab", OutFNm.CStr()).CStr(), "wt");
1646    fprintf(F, "QuoteId\tQuote\tUrl\tTotalVol\n");
1647    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1648      fprintf(F, "%d\t%s\t%s\t%d\n", SaveN-i, GetQt(QtInfoV[i].Val2).QtStr.CStr(), GetStr(QtIdUrlH.GetDat(QtInfoV[i].Val2)), (int) QtInfoV[i].Val3);
1649    }
1650    fclose(F);
1651    printf("saveT\n");
1652    F = fopen(TStr::Fmt("qtOt-%sT.tab", OutFNm.CStr()).CStr(), "wt");
1653    fprintf(F, "Time\tQuoteId\tSmoothFreq\tRawFreq\n");
1654    for (int i = 0; i < TMath::Mn(SaveN, QtInfoV.Len()); i++) {
1655      const TQuote::TTmFltPrV RawFqV = QtInfoV[i].Val4;
1656      TQuote::GetSmoothFqOt(SmoothFqV, RawFqV, TmUnit, 6*24*3600/TmUnitSecs, 1.05, MinTm, MaxTm);  
1657      IAssert(SmoothFqV.Len() >= RawFqV.Len());
1658      for (int d=0, ds = 0; ds < SmoothFqV.Len(); ds++) {
1659        if (TmUnit == tmuDay) { fprintf(F, "%s", SmoothFqV[ds].Val1.GetDtYmdStr().CStr()); }
1660        else { fprintf(F, "%s_%02d", SmoothFqV[ds].Val1.GetDtYmdStr().CStr(), SmoothFqV[ds].Val1.GetHourN()); }
1661        fprintf(F, "\t%d\t%.2f", SaveN-i, SmoothFqV[ds].Val2());
1662        if (d < RawFqV.Len() && SmoothFqV[ds].Val1 == RawFqV[d].Val1) { fprintf(F, "\t%.0f", RawFqV[d].Val2()); d++; } else { fprintf(F, "\t0"); }
1663        fprintf(F, "\n");
1664      }
1665    }
1666    fclose(F);
1667    printf("done.\n");
1668  }
1669  void TQuoteBs::SaveDomainStat(const TStr& OutFNm, const int& MinCnt) const {
1670    THash<TInt, TInt> MedOt, BlogOt, AllOt;
1671    int MedCnt=0, BlogCnt=0, AllCnt=0;
1672    TSecTm BegTm(2008,7,31,0,0,0);
1673    THash<TStr, TIntPr> DomCntH;
1674    for (int q = 0; q < QuoteH.Len(); q++) {
1675      const TQuote& Q = QuoteH[q];
1676      for (int u = 0; u < Q.GetUrls(); u++) {
1677        const int Day = TSecTm(Q.GetTm(u)-BegTm).GetInUnits(tmuDay);
1678        AllOt.AddDat(Day) += 1;  AllCnt++;
1679        if (GetUrlTy(Q.GetUrlId(u)) ==  utMedia) { MedOt.AddDat(Day) += 1;  MedCnt++;}
1680        else { BlogOt.AddDat(Day) += 1;  BlogCnt++; }
1681        TStr Dom = TStrUtil::GetDomNm2(GetStr(Q.GetUrlId(u)));
1682        DomCntH.AddDat(Dom).Val1 += 1;
1683        DomCntH.AddDat(Dom).Val2 += Q.GetCnt(u);
1684      }
1685    }
1686    TGnuPlot::PlotValCntH(AllOt, "ALL", MedOt, "MEDIA", BlogOt, "BLOGS", "overTm-"+OutFNm, TStr::Fmt("Quote freq over time: A:%d M:%d B:%d", AllCnt, MedCnt, BlogCnt),
1687      "Time [days]", "Number of quote mentions");
1688    DomCntH.SortByDat(false);
1689    FILE *F = fopen(TStr::Fmt("domains-%s.tab", OutFNm.CStr()).CStr(), "wt");
1690    fprintf(F, "# %d domains, total mentions:\tAll:%d\tMedia:%d\tBlogs:%d", DomCntH.Len(), AllCnt, MedCnt, BlogCnt);
1691    fprintf(F, "#Domain\tNumber of quotes mentioned\tNumber of mentions\n");
1692    for (int d = 0; d < DomCntH.Len(); d++) {
1693      fprintf(F, "%s\t%d\t%d\n", DomCntH.GetKey(d).CStr(), DomCntH[d].Val1(), DomCntH[d].Val2());
1694    }
1695    fclose(F);
1696  }
1697  void TQuoteBs::Dump(const bool& Fast) const {
1698    printf("Quote base:\n");
1699    if (! Fast) {
1700      TSecTm MinTm, MaxTm; GetMinMaxTm(MinTm, MaxTm);
1701      printf("  %s -- %s\n", MinTm.GetYmdTmStr().CStr(), MaxTm.GetYmdTmStr().CStr());
1702      int totCnt=0, totVol=0;
1703      for (int q = 0; q < QuoteH.Len(); q++) {
1704        const TQuote::TTmUrlCntV& V = QuoteH[q].TmUrlCntV;
1705        totCnt += V.Len();
1706        for (int u = 0; u < V.Len(); u++) {
1707          totVol += V[u].Cnt();
1708        }
1709      }
1710      printf("  %d number of posts mentioning quotes\n", totCnt);
1711      printf("  %d number of mentions\n", totVol);
1712    }
1713    printf("  %d quotes\n", Len());
1714    printf("  %d strings (quotes+urls, no domains)\n", StrQtIdH.Len());
1715    printf("  %d clusters\n", ClustQtIdVH.Len());
1716    printf("  %d quotes in clusters\n", GetQtsInClust());
1717    printf("  %d urls with type\n\n", UrlTyH.Len());
1718  }
1719  PQuoteBs TQuoteBs::FindQtInTxtQBs(const TStr& InBinFNmWc, const TStrV& QuoteStrV) {
1720    THashSet<TMd5Sig> SeenUrlH; 
1721    PQuoteBs QtBsPt = TQuoteBs::New();
1722    TQuoteBs& QtBs = *QtBsPt;
1723    TStrHash<TInt> StrH;
1724    TVec<TIntV> QtWIdVV;
1725    TVec<TIntV> QtSkipLenVV; 
1726    for (int q = 0; q < QuoteStrV.Len(); q++) {
1727      const int QId = QtBs.QuoteH.Len(); 
1728      TQuote& Qt = QtBs.QuoteH.AddDat(QId);
1729      Qt.QtCIdTy = TQuote::TQtIdTy(QId, qtQuote);
1730      Qt.QtStr = QuoteStrV[q];
1731      QtWIdVV.Add();  QtSkipLenVV.Add();
1732      TStrUtil::GetAddWIdV(StrH, QuoteStrV[q].CStr(), QtWIdVV.Last());
1733      TIntV& WIdV = QtWIdVV.Last();
1734      TIntV& SkipV = QtSkipLenVV.Last();
1735      SkipV.Add(1);
1736      for (int w = 1; w < WIdV.Len(); w++) {
1737        int skipLen = 1;
1738        while (w-skipLen >= 0 && WIdV[w-skipLen] != WIdV[w]) { skipLen++; }
1739        SkipV.Add(skipLen);
1740      }
1741    }
1742    TInt WId;
1743    TIntV TxtWIdV;
1744    TVec<char *> WrdV;
1745    TQuoteLoader QL(InBinFNmWc);
1746    while (QL.Next()) {
1747      if (SeenUrlH.IsKey(TMd5Sig(QL.PostUrlStr))) { continue; }
1748      SeenUrlH.AddKey(TMd5Sig(QL.PostUrlStr));
1749      TxtWIdV.Clr();  WrdV.Clr(false);
1750      { TStrUtil::SplitWords(QL.ContentStr, WrdV);
1751      for (int w = 0; w < WrdV.Len(); w++) {
1752        if (StrH.IsKeyGetDat(WrdV[w], WId)) { TxtWIdV.Add(WId); }
1753        else if (TxtWIdV.Len()>0 && TxtWIdV.Last()!=-1) { TxtWIdV.Add(-1); }
1754      } }
1755      for (int q = 0; q < QtWIdVV.Len(); q++) {
1756        const TIntV& QWIdV = QtWIdVV[q];
1757        const TIntV& SkipV = QtSkipLenVV[q];
1758        int cnt = 0;
1759        for (int w = 0; w < TxtWIdV.Len()-QWIdV.Len(); ) {
1760          int len = 0;
1761          while (len < QWIdV.Len() && TxtWIdV[w+len] == QWIdV[len]) { len++; }
1762          if (len == QWIdV.Len()) { cnt+=1;  w+=len; }
1763          else { w += SkipV[len]; }
1764        }
1765        if (cnt > 0) {
1766          QtBs.GetQtN(q).TmUrlCntV.Add(TQuote::TTmUrlCnt(QL.PubTm, QtBs.AddStr(QL.PostUrlStr), cnt));
1767          if (cnt > 255) { printf("*"); }
1768        }
1769      }
1770    }
1771    for (int i = 0; i < QtBs.Len(); i++) { QtBs.QuoteH[i].TmUrlCntV.Sort(); }
1772    return QtBsPt;
1773  }
1774  #ifdef false
1775  void TQuoteBs::BuildQtSubSeqCounts(TIntV& QtIdV, const TStr& OutFNm) {
1776  }
1777  void TQuoteBs::PlotQtFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1778    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1779    TGnuPlot GP("fqOT."+OutFNm);
1780    TFltPrV HrFqV;
1781    if (PlotN == -1) { PlotN = TInt::Mx; }
1782    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1783      const TQuote& Qt = GetQt(QtIdV[i]);
1784      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1785      for (int h = 0; h < HrFqV.Len(); h++) {
1786        HrFqV[h].Val1 = TMath::Round(HrFqV[h].Val1/24.0, 2);
1787      }
1788      GP.AddPlot(HrFqV, gpwLines, TStrUtil::GetShorStr(Qt.QtStr), "lt 1");
1789    }
1790    GP.SetXYLabel("Time [days]", "Frequency");
1791    GP.AddCmd("set nokey");
1792    GP.SavePng("fqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1793    GP.AddCmd("set size 2,0.5");
1794    GP.SaveEps(10);
1795  }
1796  void TQuoteBs::PlotQtCumFqOverTm(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1797    const int TmuSecs = TTmInfo::GetTmUnitSecs(tmu1Hour);
1798    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1799    const TSecTm StartTm = MinTm.Round(tmu1Hour);
1800    const TSecTm EndTm = MaxTm.Round(tmu1Hour);
1801    TQuote::TTmFltPrV HrFqV;
1802    TFltFltH SumCntH;
1803    for (TSecTm Tm = StartTm; Tm <= MaxTm.Round(tmu1Hour); Tm += TmuSecs) {
1804      SumCntH.AddDat(double(Tm-StartTm)/(24.0*3600.0)) = 0;
1805    }
1806    TGnuPlot GP("cfqOT."+OutFNm);
1807    if (PlotN == -1) { PlotN = TInt::Mx; }
1808    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1809      const TQuote& Qt = GetQt(QtIdV[i]);
1810      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, 48, 1.2);
1811      for (int h = 0; h < HrFqV.Len(); h++) {
1812        const TSecTm roundTm = HrFqV[h].Val1.Round(tmu1Hour);
1813        if (roundTm >= StartTm && roundTm<=EndTm) {
1814          SumCntH.AddDat(double(roundTm-StartTm)/(24.0*3600.0)) += HrFqV[h].Val2;
1815        }
1816      }
1817      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr, 100).CStr());
1818    }
1819    GP.SetXYLabel(TStr::Fmt("Time [days] since %s", StartTm.GetYmdTmStr().CStr()), "Stacked frequency");
1820    GP.AddCmd("set notitle");
1821    GP.AddCmd("set nogrid");
1822    GP.AddCmd("set mxtics 4");
1823    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 1000,600");
1824  }
1825  void TQuoteBs::PlotQtCumFqOverTm1(const TIntV& QtIdV, const TStr& OutFNm, int PlotN) const {
1826    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1827    TGnuPlot GP("cfqOT."+OutFNm);
1828    TFltPrV HrFqV, HrCFqV;
1829    TFltFltH SumCntH;
1830    if (PlotN == -1) { PlotN = TInt::Mx; }
1831    for (int i = 0; i < TMath::Mn(PlotN, QtIdV.Len()); i++) {
1832      const TQuote& Qt = GetQt(QtIdV[i]);
1833      Qt.GetSmoothFqOverTm(HrFqV, tmu1Hour, MinTm, 12, 1.2);
1834      HrCFqV.Clr(false);
1835      for (int h = 0; h < HrFqV.Len(); h++) {
1836        const double hr = TMath::Round(HrFqV[h].Val1/24.0+0.001, 2);
1837        SumCntH.AddDat(hr) += HrFqV[h].Val2;
1838      }
1839      GP.AddPlot(SumCntH, gpwLines, TStrUtil::GetShorStr(Qt.QtStr).CStr(), "lt 1");
1840    }
1841    GP.SetXYLabel("Time [days]", "Stacked frequency");
1842    GP.AddCmd("set nokey");
1843    GP.AddCmd("set notitle");
1844    GP.AddCmd("set nogrid");
1845    GP.AddCmd("set mxtics 5");
1846    GP.AddCmd("set xtics 5");
1847    GP.SavePng("cfqOT."+OutFNm+".png", -1, -1, "", "set terminal png small size 3000,600");
1848    GP.AddCmd("set size 2,0.5");
1849    GP.SaveEps(8);
1850  }
1851  void TQuoteBs::SaveForMatlab(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1852    const TTmUnit TmUnit = tmu1Hour;
1853    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1854    THash<TInt, TFlt> TmCntH;
1855    TVec<TFltV> TmQtFqV;
1856    const int MinTmUnit = MinTm.GetInUnits(TmUnit);
1857    for (uint i = MinTmUnit; i <= MaxTm.GetInUnits(TmUnit); i++) {
1858      TmCntH.AddDat(i, 0);  TmQtFqV.Add();
1859      TmQtFqV.Last().Add(i-MinTmUnit+1); 
1860    }
1861    TQuote::TTmFltPrV DayFqV;
1862    if (SaveN == -1) { SaveN = TInt::Mx; }
1863    for (int i = 0; i < TMath::Mn(SaveN, QtIdV.Len()); i++) {
1864      const TQuote& Qt = GetQt(QtIdV[i]);
1865      Qt.GetSmoothFqOverTm(DayFqV, TmUnit, 48, 1.2);
1866      for (int d = 0; d < TmCntH.Len(); d++) { TmCntH[d] = 0; }
1867      for (int d = 0; d < DayFqV.Len(); d++) {
1868        const int T = DayFqV[d].Val1.GetInUnits(TmUnit);
1869        if (TmCntH.IsKey(T)) {
1870          TmCntH.AddDat(T) += DayFqV[d].Val2; }
1871      }
1872      for (int d = 0; d < TmCntH.Len(); d++) {
1873        TmQtFqV[d].Add(TmCntH[d]); }
1874    }
1875    FILE *F = fopen(TStr::Fmt("qtFqOtMATLAB-%s.tab", OutFNm.CStr()).CStr(), "wt");
1876    for (int d = 0; d < TmQtFqV.Len(); d++) {
1877      fprintf(F, "%g", TmQtFqV[d][0]());
1878      for (int q = 1; q < TmQtFqV[d].Len(); q++) {
1879        fprintf(F, "\t%g", TmQtFqV[d][q]()); }
1880      fprintf(F, "\n");
1881    }
1882    fclose(F);
1883  }
1884  void TQuoteBs::SaveQtTmUrlTxt(const TIntV& QtIdV, const TStr& OutFNm, int SaveN) const {
1885    if (SaveN == -1) { SaveN = TInt::Mx; }
1886    SaveN = TMath::Mn(SaveN, QtIdV.Len());
1887    FILE *F = fopen(OutFNm.CStr(), "wt");
1888    for (int q = 0; q < QtIdV.Len(); q++) {
1889      const TQuote& Qt = GetQt(QtIdV[q]);
1890      fprintf(F, "%s\t%d\n", Qt.QtStr.CStr(), Qt.GetFq());
1891      for (int u = 0; u < Qt.GetUrls(); u++) {
1892        fprintf(F, "\t%s\t%s\n", Qt.TmUrlCntV[u].Val1.GetYmdTmStr().CStr(), GetStr(Qt.TmUrlCntV[u].Val2));
1893      }
1894      fprintf(F, "\n");
1895    }
1896    fclose(F);
1897  }
1898  void TQuoteBs::PlotSubQtOverTm(const int& QtId, const TStr& OutFNm) const {
1899    TIntV PlotQtV;
1900    const TQuote Qt = GetQt(QtId);
1901    PlotQtV.Add(QtId);
1902    TIntV WrdBegV; WrdBegV.Add(0);
1903    for (int i = 1; i < Qt.QtStr.Len()-1; i++) {
1904      if (TCh::IsAlNum(Qt.QtStr.GetCh(i)) && TCh::IsWs(Qt.QtStr.GetCh(i-1))) { WrdBegV.Add(i); }
1905    }
1906    TInt subQtId;
1907    WrdBegV.Add(Qt.QtStr.Len()+1); 
1908    const int QtWords = TStrUtil::CountWords(Qt.QtStr.CStr());
1909    for (int WndSz = 5; WndSz < QtWords; WndSz++) {
1910      for (int word = 0; word < QtWords-WndSz; word++) {
1911        const TStr SubQtStr = Qt.QtStr.GetSubStr(WrdBegV[word], WrdBegV[word+WndSz]-2);
1912        if (StrH.IsKeyGetDat(SubQtStr, subQtId) && QuoteH.IsKey(subQtId) && subQtId!=QtId) { PlotQtV.Add(subQtId); printf("."); }
1913      }
1914    }
1915    TGnuPlot GP(OutFNm, TStr::Fmt("%d occurences, %d urls, %d domains: %s", Qt.GetFq(), Qt.GetUrls(), Qt.GetDoms(), Qt.QtStr.CStr()));
1916    TFltPrV HrFqV;
1917    for (int i = 0; i < PlotQtV.Len(); i++) {
1918      const TQuote& subQt = QuoteH.GetDat(PlotQtV[i]);
1919      subQt.GetSmoothFqOverTm(HrFqV, tmu1Hour);
1920      GP.AddPlot(HrFqV, gpwLines, subQt.QtStr.CStr());
1921    }
1922    GP.SetXYLabel("Time [hours]", "Frequency");
1923    GP.SavePng(OutFNm+".png", -1, -1, "", "set terminal png small size 1000,800");
1924  }
1925  void TQuoteBs::PlotTopQuotesOverTm(const int& StepSecs, const int& IntervalSecs, const int& TakeNPerStep, const TStr& OutFNm) const {
1926    TSecTm MinTm, MaxTm;  GetMinMaxTm(MinTm, MaxTm);
1927    printf("Dataset span %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1928    TIntSet TopQtIdSet;
1929    int cnt=0;
1930    TIntV TopQtIdV;
1931    for (TSecTm Tm(MinTm); Tm < MaxTm; Tm += StepSecs, cnt++) {
1932      FailR("TopQuotesOverTm: take top quotes from each day");
1933      for (int q = 0; q < TopQtIdV.Len(); q++) { TopQtIdSet.AddKey(TopQtIdV[q]); }
1934    }
1935    printf("\n%d time steps total, %d quotes per step: %d total quotes\n", cnt, TakeNPerStep, TopQtIdSet.Len());
1936    printf("%s   %d\n", MinTm.Round(tmuDay).GetStr().CStr(), MinTm.Round(tmuDay).GetInUnits(tmu1Hour));
1937    TFltPrV FqOverTm;
1938    TGnuPlot GP(TStr("topQtOverTm.")+OutFNm, "");
1939    TFOut FOut(OutFNm+TStr(".Quote"));
1940    for (int q = 0; q < TopQtIdSet.Len(); q++) {
1941      const TQuote& Q = QuoteH.GetDat(TopQtIdSet[q]);
1942      Q.Save(FOut);
1943      Q.GetSmoothFqOverTm(FqOverTm, tmu1Hour, MinTm.Round(tmuDay));
1944      GP.AddPlot(FqOverTm, gpwLines, Q.QtStr);
1945    }
1946    GP.AddCmd("set xtics 24"); GP.AddCmd("set mxtics 4");
1947    GP.SetXYLabel(TStr("time [hours] from "+MinTm.Round(tmuDay).GetStr()), "frequency");
1948    GP.SavePng(TStr("topQtOverTm.")+OutFNm+TStr(".png"), -1, -1, "", "set terminal png small size 2000,800");
1949  }
1950  PQuoteBs TQuoteBs::BuildQuoteBs(const TStr& InBinFNmWc, const int& MinQtWrdLen) {
1951    PQuoteBs QBsPt = TQuoteBs::New(InBinFNmWc);
1952    QBsPt->AddToQuoteBs(InBinFNmWc, MinQtWrdLen);
1953    return QBsPt;
1954  }
1955  #endif
1956  PClustNet TClustNet::GetSubGraph(const TIntV& NIdV) const {
1957    PClustNet NewNetPt = TClustNet::New();
1958    TClustNet& NewNet = *NewNetPt;
1959    NewNet.Reserve(NIdV.Len(), -1);
1960    int node, edge;
1961    TClustNet::TNodeI NI;
1962    for (node = 0; node < NIdV.Len(); node++) {
1963      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
1964    }
1965    for (node = 0; node < NIdV.Len(); node++) {
1966      NI = GetNI(NIdV[node]);
1967      const int SrcNId = NI.GetId();
1968      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
1969        const int OutNId = NI.GetOutNId(edge);
1970        if (NewNet.IsNode(OutNId)) {
1971          NewNet.AddEdge(SrcNId, OutNId); }
1972      }
1973    }
1974    NewNet.Defrag();
1975    return NewNetPt;
1976  }
1977  void TClustNet::AddLink(const TQuote& SrcQt, const TQuote& DstQt) {
1978    const int Qt1Id = SrcQt.GetCId();
1979    const int Qt2Id = DstQt.GetCId();
1980    if (! IsNode(Qt1Id)) {
1981      AddNode(Qt1Id, SrcQt); }
1982    if (! IsNode(Qt2Id)) {
1983      AddNode(Qt2Id, DstQt); }
1984    if (! IsEdge(Qt2Id, Qt1Id)) {
1985      AddEdge(Qt1Id, Qt2Id);
1986    }
1987  }
1988  PClustNet TClustNet::GetSubGraph(const int& MinQtWords, const int& MaxQtWords, const int& MinFq) const {
1989    TIntV NIdV;
1990    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
1991      const int Wrds = TStrUtil::CountWords(NI().GetStr().CStr());
1992      if (NI().GetFq() >= MinFq &&  Wrds >= MinQtWords && Wrds <= MaxQtWords) {
1993        NIdV.Add(NI.GetId()); }
1994    }
1995    return GetSubGraph(NIdV);
1996  }
1997  void TClustNet::RecalcEdges(const double& MinOverlapFrac) {
1998    printf("Recalculating edges...\n");
1999    TIntPrV DelEdgeV;
2000    TStrHash<TInt> StrH(Mega(1), true);
2001    int WIdV1Start, WIdV2Start, SkipTy;
2002    TIntV WIdV1, WIdV2;
2003    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2004      const TStr Q1 = NI().GetStr();
2005      TStrUtil::GetAddWIdV(StrH, Q1.CStr(), WIdV1);
2006      for (int e = 0; e < NI.GetOutDeg(); e++) {
2007        const TStr Q2 = NI.GetOutNDat(e).GetStr();
2008        TStrUtil::GetAddWIdV(StrH, Q2.CStr(), WIdV2);
2009        const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, WIdV1Start, WIdV2Start, SkipTy);
2010        const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2011        const int LongLen = TMath::Mx(WIdV1.Len(), WIdV2.Len());
2012        IAssert(Overlap<=ShortLen);
2013        if (2*ShortLen>LongLen && Overlap/double(ShortLen) > MinOverlapFrac) { continue; }
2014        DelEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(e)));
2015      }
2016    }
2017    printf("Deleting %d/%d (%.4f) edges\n", DelEdgeV.Len(), GetEdges(), DelEdgeV.Len()/double(GetEdges()));
2018    for (int i = 0; i < DelEdgeV.Len(); i++) {
2019      DelEdge(DelEdgeV[i].Val1, DelEdgeV[i].Val2);
2020    }
2021  }
2022  void TClustNet::MakeClusters(const TIntPrV& KeepEdgeV) {
2023    PUNGraph G = TUNGraph::New();
2024    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2025      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2026        G->AddNode(KeepEdgeV[e].Val1); }
2027      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2028        G->AddNode(KeepEdgeV[e].Val2); }
2029      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2030    }
2031    TCnComV CnComV;
2032    TSnap::GetWccs(G, CnComV);
2033    TIntH NIdCcIdH(GetNodes());
2034    for (int c = 0; c < CnComV.Len(); c++) {
2035      const TIntV& NIdV = CnComV[c].NIdV;
2036      for (int n = 0; n < NIdV.Len(); n++) {
2037        NIdCcIdH.AddDat(NIdV[n], c);
2038      }
2039    }
2040    TIntPrV DelEdgeV;
2041    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2042      const int ccid1 = NIdCcIdH.IsKey(EI.GetSrcNId()) ? NIdCcIdH.GetDat(EI.GetSrcNId()).Val : -1;
2043      const int ccid2 = NIdCcIdH.IsKey(EI.GetDstNId()) ? NIdCcIdH.GetDat(EI.GetDstNId()).Val : -1;
2044      if (ccid1 != ccid2 && ccid1!=-1 && ccid2!=-1) {
2045        DelEdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId())); }
2046    }
2047    const int Edges = GetEdges();
2048    printf("Deleting %d out of %d  (%f) edges\n", DelEdgeV.Len(), Edges, DelEdgeV.Len()/double(Edges));
2049    for (int d = 0; d < DelEdgeV.Len(); d++) {
2050      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2051    }
2052  }
2053  void TClustNet::KeepOnlyTree(const TIntPrV& KeepEdgeV) {
2054    TIntPrSet EdgeSet(KeepEdgeV.Len());
2055    for (int i = 0; i < KeepEdgeV.Len(); i++) {
2056      EdgeSet.AddKey(TIntPr(TMath::Mn(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2),
2057        TMath::Mx(KeepEdgeV[i].Val1, KeepEdgeV[i].Val2)));
2058    }
2059    TIntPrSet DelEdgeV;
2060    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
2061      const int N1 = TMath::Mn(EI.GetSrcNId(), EI.GetDstNId());
2062      const int N2 = TMath::Mx(EI.GetSrcNId(), EI.GetDstNId());
2063      if (! EdgeSet.IsKey(TIntPr(N1, N2))) {
2064        DelEdgeV.AddKey(TIntPr(N1, N2)); }
2065    }
2066    printf("deleting %d edges\n", DelEdgeV.Len());
2067    for (int d = 0; d < DelEdgeV.Len(); d++) {
2068      DelEdge(DelEdgeV[d].Val1, DelEdgeV[d].Val2);
2069    }
2070  }
2071  void TClustNet::GetClusters(TVec<TIntV>& QtNIdV) const {
2072    TCnComV CnComV;
2073    TSnap::GetWccs(GetThis(), CnComV);
2074    CnComV.Sort(false);
2075    QtNIdV.Clr(false);
2076    TIntSet SeenSet;
2077    for (int i = 0; i < CnComV.Len(); i++) {
2078      for (int n = 0; n < CnComV[i].NIdV.Len(); n++) {
2079        IAssert(! SeenSet.IsKey(CnComV[i].NIdV[n]));
2080        SeenSet.AddKey(CnComV[i].NIdV[n]);
2081      }
2082      QtNIdV.Add(CnComV[i].NIdV);
2083    }
2084  }
2085  void TClustNet::GetMergedClustQt(const TIntV& QtIdV, TQuote& NewQt) const {
2086    int CentrQtId=-1, MxFq=0;
2087    THash<TPair<TSecTm, TInt>, TInt> TmUrlCntH;
2088    for (int c = 0; c < QtIdV.Len(); c++) {
2089      const TQuote& Q = GetNDat(QtIdV[c]);
2090      IAssert(Q.GetId() == QtIdV[c]);
2091      for (int t = 0; t < Q.GetTimes(); t++) {
2092        TmUrlCntH.AddDat(TPair<TSecTm, TInt>(Q.GetTm(t), Q.GetUrlId(t))) += Q.GetCnt(t);
2093      }
2094      if (MxFq < Q.GetFq()) {
2095        MxFq = Q.GetFq();
2096        CentrQtId = Q.GetId();
2097      }
2098    }
2099    NewQt.QtCIdTy = TQuote::TQtIdTy(-1, qtCentr);
2100    NewQt.QtStr = GetNDat(CentrQtId).GetStr(); 
2101    NewQt.TmUrlCntV.Gen(TmUrlCntH.Len(), 0);
2102    for (int u = 0; u < TmUrlCntH.Len(); u++) {
2103      NewQt.TmUrlCntV.Add(TQuote::TTmUrlCnt(TmUrlCntH.GetKey(u).Val1, TmUrlCntH.GetKey(u).Val2(), TmUrlCntH[u]()));
2104    }
2105    NewQt.TmUrlCntV.Sort();
2106  }
2107  int TClustNet::EvalPhraseClusters(const TIntPrV& KeepEdgeV, const bool& dump) const {
2108    PNGraph G = TNGraph::New();
2109    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2110      if (! G->IsNode(KeepEdgeV[e].Val1)) {
2111        G->AddNode(KeepEdgeV[e].Val1); }
2112      if (! G->IsNode(KeepEdgeV[e].Val2)) {
2113        G->AddNode(KeepEdgeV[e].Val2); }
2114      G->AddEdge(KeepEdgeV[e].Val1, KeepEdgeV[e].Val2);
2115    }
2116    TCnComV CnComV;
2117    TSnap::GetWccs(G, CnComV);
2118    G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2119    int TotEdges=0, EdgesInBigClust=0;
2120    int TotNodes=0, NodesInBigClust=0;
2121    int BigClust=0;
2122    for (int cc = 0; cc < CnComV.Len(); cc++) {
2123      if (CnComV[cc].NIdV.Len() < 3) { continue; }
2124      PNGraph CC = TSnap::GetSubGraph(G, CnComV[cc].NIdV);
2125      TotEdges += CC->GetEdges();
2126      TotNodes += CC->GetNodes()-1;
2127      if (CC->GetNodes() > 10) {
2128        EdgesInBigClust += CC->GetEdges();
2129        NodesInBigClust += CC->GetNodes()-1;
2130        BigClust++;
2131      }
2132    }
2133    if (dump) {
2134      printf("                                all\tbig(>10)\n");
2135      printf("  Number of clusters:           %d\t%d\n", CnComV.Len(), BigClust);
2136      printf("  Total edges inside clusters:  %d\t%d\n", TotEdges, TotEdges-TotNodes);
2137      printf("  Total edges deleted:          %d\t%d\n", GetEdges()-TotEdges, GetEdges()-TotEdges-TotNodes);
2138      printf("  Total edges in big clusters:  %d\t%d\n", EdgesInBigClust, EdgesInBigClust-NodesInBigClust);
2139    }
2140    return TotEdges-TotNodes;
2141  }
2142  void TClustNet::ClustKeepSingleEdge(const int& MethodId) const {
2143    TIntPrV KeepEdgeV;
2144    ClustKeepSingleEdge(MethodId, KeepEdgeV);
2145  }
2146  void TClustNet::ClustKeepSingleEdge(const int& MethodId, TIntPrV& KeepEdgeV) const {
2147    PNGraph G = TSnap::ConvertGraph<PNGraph>(TPt<TClustNet>((TClustNet*) this));
2148    KeepEdgeV.Clr(false);
2149    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2150      IAssert(NI.GetId() == NI().GetId());
2151      int EdgeToKeep = -1, BestVal=0;
2152      for (int e = 0; e < NI.GetOutDeg(); e++) {
2153        if (MethodId==1 && NI.GetOutNDat(e).GetFq() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetFq(); }
2154        if (MethodId==2 && NI.GetOutNDat(e).GetStr().Len() > BestVal) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2155        if (MethodId==3 && NI.GetOutNDat(e).GetStr().Len() < BestVal ||BestVal==0) { EdgeToKeep=e; BestVal=NI.GetOutNDat(e).GetStr().Len(); }
2156      }
2157      if (MethodId==4 && NI.GetOutDeg()>0) {
2158        EdgeToKeep = TInt::Rnd.GetUniDevInt(NI.GetOutDeg()); }
2159      if (EdgeToKeep!=-1) {
2160        KeepEdgeV.Add(TIntPr(NI.GetId(), NI.GetOutNId(EdgeToKeep))); }
2161    }
2162    if (MethodId==1) { printf("Keep edge to most frequent quote:\n"); }
2163    if (MethodId==2) { printf("Keep edge to longest quote:\n"); }
2164    if (MethodId==3) { printf("Keep edge to shortest quote:\n"); }
2165    if (MethodId==4) { printf("Keep random edge:\n"); }
2166    EvalPhraseClusters(KeepEdgeV);
2167  }
2168  void TClustNet::ClustGreedyTopDown() const {
2169    TIntPrV KeepEdgeV;
2170    ClustGreedyTopDown(KeepEdgeV);
2171  }
2172  void TClustNet::ClustGreedyTopDown(TIntPrV& KeepEdgeV) const {
2173    TIntH NIdOutDegH;
2174    TIntH NIdClustH;
2175    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2176      NIdOutDegH.AddDat(NI.GetId(), NI.GetOutDeg());
2177      if (NI.GetOutDeg() == 0) {
2178        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2179    }
2180    printf("%d root nodes\n", NIdClustH.Len());
2181    printf("%d nodes\n", NIdOutDegH.Len());
2182    NIdOutDegH.SortByDat(true);
2183    THash<TInt, TIntPr> ClustCntH;
2184    KeepEdgeV.Clr(false);
2185    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2186      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2187        IAssert(IsNode(NIdOutDegH.GetKey(i)));
2188        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2189        for (int e = 0; e < NI.GetInDeg(); e++) {
2190          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2191        ClustCntH.Clr(false);
2192        for (int e = 0; e < NI.GetOutDeg(); e++) {
2193          IAssert(NIdClustH.IsKey(NI.GetOutNId(e)));
2194          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1; 
2195          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2196        }
2197        ClustCntH.SortByDat(false);
2198        if (ClustCntH.Len() > 0) {
2199          const int NId = NI.GetId();
2200          const int NId2 = ClustCntH[0].Val2;
2201          const int CId = NIdClustH.GetDat(NId2);
2202          KeepEdgeV.Add(TIntPr(NId, NId2)); 
2203          NIdClustH.AddDat(NId, CId); 
2204        }
2205        NIdOutDegH[i] = TInt::Mx;
2206      }
2207      NIdOutDegH.SortByDat(true);
2208    }
2209    printf("Greedy top down approach:\n");
2210    EvalPhraseClusters(KeepEdgeV);
2211  }
2212  void TClustNet::ClustGreedyRandom() const {
2213    printf("Greedy random:\n");
2214    THash<TInt, TIntV> OutNIdV;
2215    THash<TInt, TInt> EdgeH;
2216    TIntPrV KeepEdgeV;
2217    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2218      if (NI.GetOutDeg() > 0) {
2219        EdgeH.AddDat(NI.GetId()) = NI.GetOutNId(TInt::Rnd.GetUniDevInt(NI.GetOutDeg()));
2220        if (NI.GetOutDeg() > 1) {
2221          for (int e = 0; e < NI.GetOutDeg(); e++) {
2222            OutNIdV.AddDat(NI.GetId()).Add(NI.GetOutNId(e)); }
2223        }
2224      }
2225    }
2226    { TIntH NIdOutDegH;
2227    TIntH NIdClustH;
2228    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
2229      NIdOutDegH.AddDat(NI.GetId()) = NI.GetOutDeg();
2230      if (NI.GetOutDeg() == 0) {
2231        NIdClustH.AddDat(NI.GetId(), NI.GetId()); }
2232    }
2233    NIdOutDegH.SortByDat(true);
2234    THash<TInt, TIntPr> ClustCntH;
2235    while (NIdOutDegH.Len() > 0 && NIdOutDegH[0] == 0) {
2236      for (int i = 0; i < NIdOutDegH.Len() && NIdOutDegH[i] == 0; i++) {
2237        const TNodeI NI = GetNI(NIdOutDegH.GetKey(i));
2238        for (int e = 0; e < NI.GetInDeg(); e++) {
2239          NIdOutDegH.GetDat(NI.GetInNId(e)) -= 1; }
2240        ClustCntH.Clr(false);
2241        for (int e = 0; e < NI.GetOutDeg(); e++) {
2242          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val1 += 1;
2243          ClustCntH.AddDat(NIdClustH.GetDat(NI.GetOutNId(e))).Val2 = NI.GetOutNId(e);
2244        }
2245        ClustCntH.SortByDat(false);
2246        if (ClustCntH.Len() > 0) {
2247          KeepEdgeV.Add(TIntPr(NI.GetId(), ClustCntH[0].Val2));
2248        }
2249        NIdOutDegH[i] = TInt::Mx;
2250      }
2251      NIdOutDegH.SortByDat(true);
2252    } }
2253    printf("%d\n", EdgeH.Len());
2254    for (int e = 0; e < KeepEdgeV.Len(); e++) {
2255      EdgeH.AddDat(KeepEdgeV[e].Val1) = KeepEdgeV[e].Val2;
2256    }
2257    printf("%d\n", EdgeH.Len());
2258    EdgeH.GetKeyDatPrV(KeepEdgeV);
2259    int CurScore = EvalPhraseClusters(KeepEdgeV);
2260    while (true) {
2261        const int RndNId = OutNIdV.GetKey(TInt::Rnd.GetUniDevInt(OutNIdV.Len()));
2262        const int RndEdge = OutNIdV.GetDat(RndNId)[TInt::Rnd.GetUniDevInt(OutNIdV.GetDat(RndNId).Len())];
2263        const int id = EdgeH.GetKeyId(RndNId);  IAssert(KeepEdgeV[id].Val1 == RndNId);
2264        if (KeepEdgeV[id].Val2 == RndEdge) { continue; } 
2265        const int OldE = KeepEdgeV[id].Val2;
2266        KeepEdgeV[id].Val2 = RndEdge;
2267      const int NewScore = EvalPhraseClusters(KeepEdgeV, false);
2268      if (NewScore > CurScore &bsol;*|| TInt::Rnd.GetUniDev() < 0.1*/) {
2269        printf("%6d --> %6d\n", CurScore, NewScore);
2270        CurScore = NewScore;
2271      }
2272      else {  KeepEdgeV[id].Val2 = OldE; } 
2273    }
2274  }
2275  TChA InsertLineBreaks(const TChA& ChA, const int& BreakAtPost) {
2276    TChA Tmp = ChA, Out;
2277    int Lines = 1;
2278    TVec<char*> WrdV;
2279    TStrUtil::SplitWords(Tmp, WrdV);
2280    for (int w = 0; w < WrdV.Len(); w++) {
2281      if (Out.Len() + (int)strlen(WrdV[w]) > Lines*BreakAtPost) {
2282        Lines++; Out+="\\n"; }
2283      Out += WrdV[w];
2284      Out += " ";
2285    }
2286    return Out;
2287  }
2288  void TClustNet::DrawNet(const TStr& OutFNm, const int& SaveTopN) const {
2289    TCnComV CnComV;
2290    TSnap::GetWccs(GetThis(), CnComV);
2291    CnComV.Sort(false);
2292    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2293      if (CnComV[Comp].Len() < 5) { continue; }
2294      TPt<TNet> SubNet = TSnap::GetSubGraph(TPt<TNet>((TClustNet*) this), CnComV[Comp].NIdV);
2295      printf("draw: %d nodes, %d edges\n", SubNet->GetNodes(), SubNet->GetEdges());
2296      FILE *F = fopen(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp).CStr(), "wt");
2297      fprintf(F, "digraph G { &bsol;*%d nodes, %d edges*/\n", SubNet->GetNodes(), SubNet->GetEdges());
2298      fprintf(F, "  graph [splines=true overlap=false rankdir=LR]\n");
2299      fprintf(F, "  node  [shape=box, fontsize=14]\n");
2300      for (TNet::TNodeI NI = SubNet->BegNI(); NI < SubNet->EndNI(); NI++) {
2301        fprintf(F, "  %d [label=\"%s (%d, %d)\"];\n", NI.GetId(), InsertLineBreaks(NI().GetStr(), 80).CStr(), NI().GetFq(), NI().GetUrls());
2302      }
2303      for (TNet::TEdgeI EI = SubNet->BegEI(); EI < SubNet->EndEI(); EI++) {
2304        fprintf(F, "  %d -> %d;\n", EI.GetSrcNId(), EI.GetDstNId());
2305      }
2306      fprintf(F, "}\n");
2307      fclose(F);
2308      TGraphViz::DoLayout(TStr::Fmt("%s-c%02d.dot", OutFNm.CStr(), Comp), TStr::Fmt("%s-c%02d.ps", OutFNm.CStr(), Comp), gvlDot);
2309      TSnap::SavePajek(SubNet, TStr::Fmt("%s-c%02d.net", OutFNm.CStr(), Comp));
2310    }
2311  }
2312  void TClustNet::DumpNodes(const TStr& OutFNm, const int& SaveTopN) const {
2313    TIntV NIdV;  GetNIdV(NIdV);
2314    TIntH NIdCompSzH;
2315    { TCnComV CnComV;
2316    TSnap::GetWccs(GetThis(), CnComV);
2317    for (int c = 0; c < CnComV.Len(); c++) {
2318      for (int n = 0; n < CnComV[c].NIdV.Len(); n++) {
2319        NIdCompSzH.AddDat(CnComV[c].NIdV[n], CnComV[c].Len());
2320      }
2321    } }
2322    TIntPrV FqNIdV;
2323    for (int n = 0; n < NIdV.Len(); n++) {
2324      FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2325    }
2326    FqNIdV.Sort(false);
2327    FILE *F = fopen(TStr::Fmt("nodes-%s.txt", OutFNm.CStr()).CStr(), "wt");
2328    fprintf(F, "#Freq\tClustSz\tQuote\n");
2329    for (int i = 0; i < FqNIdV.Len(); i++) {
2330      const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2331      fprintf(F, "%d\t%d\t%s\n", Q.GetFq(), NIdCompSzH.GetDat(FqNIdV[i].Val2).Val, Q.GetStr().CStr());
2332    }
2333  }
2334  void TClustNet::DumpClusters(const TStr& OutFNm, int SaveTopN) const {
2335    TCnComV CnComV;
2336    TSnap::GetWccs(GetThis(), CnComV); 
2337    CnComV.Sort(false);
2338    FILE *F = fopen(TStr::Fmt("clust-%s.txt", OutFNm.CStr()).CStr(), "wt");
2339    if (SaveTopN==-1) { SaveTopN=TInt::Mx; }
2340    for (int Comp = 0; Comp<TMath::Mn(SaveTopN, CnComV.Len()); Comp++) {
2341      const TIntV& NIdV = CnComV[Comp].NIdV;
2342      TIntPrV FqNIdV;
2343      int SumFq=0;
2344      for (int n = 0; n < NIdV.Len(); n++) {
2345        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2346        SumFq += GetNDat(NIdV[n]).GetFq();
2347      }
2348      FqNIdV.Sort(false);
2349      fprintf(F, "%d quotes, total freq %d\n", FqNIdV.Len(), SumFq);
2350      for (int i = 0; i < FqNIdV.Len(); i++) {
2351        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2352        fprintf(F, "%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2353      }
2354      fprintf(F, "\n");
2355    }
2356  }
2357  void TClustNet::DumpClustersByVol(const TStr& OutFNm, const int& MinClustSz, const int& MinVolume) const {
2358    TCnComV CnComV;
2359    TSnap::GetWccs(GetThis(), CnComV);
2360    CnComV.Sort(false);
2361    TIntPrV FqClustV;
2362    TIntH ClSzH, ClFqH;
2363    int FqMore1k=0;
2364    for (int Comp = 0; Comp < CnComV.Len(); Comp++) {
2365      const TIntV& NIdV = CnComV[Comp].NIdV;
2366      if (NIdV.Len() < MinClustSz) { continue; } 
2367      int SumFq=0;
2368      for (int n = 0; n < NIdV.Len(); n++) {
2369        SumFq += GetNDat(NIdV[n]).GetFq(); }
2370      FqClustV.Add(TIntPr(SumFq, Comp));
2371      ClFqH.AddDat(SumFq) += 1;
2372      ClSzH.AddDat(NIdV.Len()) += 1;
2373      if (SumFq>500) { FqMore1k++; }
2374    }
2375    FqClustV.Sort(false);
2376    FILE *F = fopen(TStr::Fmt("clustFq-%s.txt", OutFNm.CStr()).CStr(), "wt");
2377    fprintf(F, "Cluster network:\n%d nodes\n%d edges\n%d clusters\n%d big clusters (>=%d)\n",
2378      GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz);
2379    for (int c = 0; c < FqClustV.Len(); c++) {
2380      const TIntV& NIdV = CnComV[FqClustV[c].Val2].NIdV;
2381      TIntPrV FqNIdV;
2382      int SumFq=0;
2383      for (int n = 0; n < NIdV.Len(); n++) {
2384        FqNIdV.Add(TIntPr(GetNDat(NIdV[n]).GetFq(), NIdV[n]));
2385        SumFq += GetNDat(NIdV[n]).GetFq();
2386      }
2387      if (SumFq < MinVolume) { continue; }
2388      FqNIdV.Sort(false);
2389      fprintf(F, "%d\t%d items\t%d totFq\n", c, FqNIdV.Len(), SumFq);
2390      for (int i = 0; i < FqNIdV.Len(); i++) {
2391        const TQuote& Q = GetNDat(FqNIdV[i].Val2);
2392        fprintf(F, "\t%d\t%s\n", Q.GetFq(), Q.GetStr().CStr());
2393      }
2394      fprintf(F, "\n");
2395    }
2396    TGnuPlot::PlotValCntH(ClFqH, "clVol."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2397      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster volume", "Count", gpsLog);
2398    TGnuPlot::PlotValCntH(ClSzH, "clSz."+OutFNm, TStr::Fmt("%s. %d nodes, %d edges, %d clusters, %d big clusters (>=%d), %d with vol>500",
2399      OutFNm.CStr(), GetNodes(), GetEdges(), CnComV.Len(), FqClustV.Len(), MinClustSz, FqMore1k), "Cluster size", "Count", gpsLog);
2400  }
2401  void BuildPhraseInvertIdx(const PQuoteBs& QtBs, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& WIdQtIdVH) {
2402    printf("build quote word inverted index\n");
2403    TIntV WIdV;
2404    TIntSet WIdSet;
2405    for (int q = 0; q < QtBs->Len(); q++) {
2406      const TQuote& Q = QtBs->GetQtN(q);
2407      TStrUtil::GetAddWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2408      const int Doms = Q.GetDoms(*QtBs);
2409      if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= 5)) { 
2410        continue;
2411      }
2412      WIdSet.Clr(false); 
2413      for (int w = 0; w < WIdV.Len(); w++) {
2414        WIdSet.AddKey(WIdV[w]);
2415      }
2416      for (int w = 0; w < WIdSet.Len(); w++) {
2417        WIdQtIdVH.AddDat(WIdSet[w]).Add(q);
2418      }
2419    }
2420    for (int i = 0; i < WIdQtIdVH.Len(); i++) {
2421      WIdQtIdVH[i].Pack();
2422    }
2423    printf("done.\n");
2424  }
2425  bool IsLinkPhrases(const PQuoteBs& QtBs, const int& QtN1, const int& QtN2, TStrHash<TInt>& WordIdH, THash<TInt, TIntV>& QtToWordIdVH) {
2426    if (! QtToWordIdVH.IsKey(QtN1)) {
2427      TIntV WIdV;
2428      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN1).GetStr().CStr(), WIdV);
2429      WIdV.Pack();
2430      QtToWordIdVH.AddDat(QtN1, WIdV);
2431    }
2432    if (! QtToWordIdVH.IsKey(QtN2)) {
2433      TIntV WIdV;
2434      TStrUtil::GetWIdV(WordIdH, QtBs->GetQtN(QtN2).GetStr().CStr(), WIdV);
2435      WIdV.Pack();
2436      QtToWordIdVH.AddDat(QtN2, WIdV);
2437    }
2438    int idx1=0, idx2=0, SkipTy=0;
2439    const TIntV& WIdV1 = QtToWordIdVH.GetDat(QtN1);
2440    const TIntV& WIdV2 = QtToWordIdVH.GetDat(QtN2);
2441    const int ShortLen = TMath::Mn(WIdV1.Len(), WIdV2.Len());
2442    const int Overlap = TQuoteBs::LongestCmnSubSq(WIdV1, WIdV2, idx1, idx2, SkipTy);
2443    bool DoMerge = false;
2444    if (ShortLen <= 5 && Overlap == ShortLen &bsol;*&& SkipTy==0*/) { DoMerge=true; } 
2445    else if ((ShortLen == 6 && Overlap >= 5 &bsol;*&& SkipTy==0) || (ShortLen == 6 && Overlap == 5*/)) { DoMerge=true; }
2446    else if (Overlap/double(ShortLen+3) > 0.5 || Overlap > 10) { DoMerge=true; }
2447    return DoMerge;
2448  }
2449  PClustNet TClustNet::GetFromQtBs(const PQuoteBs& QtBs, int MinQtFq, int MnWrdLen) {
2450    TStrHash<TInt> WordIdH;
2451    THash<TInt, TIntV> WIdQtIdVH; 
2452    BuildPhraseInvertIdx(QtBs, WordIdH, WIdQtIdVH);
2453    PClustNet Net = TClustNet::New();
2454    TVec<int> QtSharCnt(QtBs->Len()), QtWrdLen(QtBs->Len());
2455    THash<TInt, TIntV> QtToWordIdVH;   
2456    TIntV WIdV;
2457    TIntH CandLenH, LinkLenH;
2458    THash<TInt, TIntH> QtLenCandH, QtLenLinkH;
2459    int AllCand=0, AllLinks=0;
2460    TExeTm ExeTm;
2461    for (int qt = 0; qt < QtBs->Len(); qt++) {
2462      QtWrdLen[qt] = TStrUtil::CountWords(QtBs->GetQtN(qt).GetStr().CStr());
2463    }
2464    const int QtBsLen = QtBs->Len();
2465    for (int qt = 0; qt < QtBs->Len(); qt++) {
2466      const TQuote& Q = QtBs->GetQtN(qt);
2467      const int Doms = Q.GetDoms(*QtBs);
2468    if (! (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq &&
2469      TStrUtil::CountWords(Q.GetStr())>=MnWrdLen)) {
2470        continue; }
2471      memset(QtSharCnt.BegI(), 0, sizeof(int)*QtSharCnt.Len());
2472      TStrUtil::GetWIdV(WordIdH, Q.GetStr().CStr(), WIdV);
2473      if (! QtToWordIdVH.IsKey(qt)) {
2474        WIdV.Pack();
2475        QtToWordIdVH.AddDat(qt, WIdV);
2476      }
2477      for (int w = 0; w < WIdV.Len(); w++) {
2478        IAssert(WIdQtIdVH.IsKey(WIdV[w]));
2479        const TIntV& QtIdV = WIdQtIdVH.GetDat(WIdV[w]);
2480        for (int q = 0; q < QtIdV.Len(); q++) {
2481          QtSharCnt[QtIdV[q]] += 1;
2482        }
2483      }
2484      const int W = WIdV.Len();
2485      int Candidates = 0, Links = 0, MinSharedWords = W-3;
2486      if (W <= 5) { MinSharedWords = W-1; }
2487      else if (W <= 10) { MinSharedWords = W-2; }
2488      for (int q = 0; q < QtSharCnt.Len(); q++) {
2489        if (QtSharCnt[q] >= MinSharedWords && (QtWrdLen[q] >= W || QtWrdLen[q] > 20)) {
2490          const TQuote& Qt2 = QtBs->GetQtN(q);
2491          if (Doms>1 && Doms*4 > Q.GetUrls() && Q.GetFq() >= MinQtFq) { 
2492            if (IsLinkPhrases(QtBs, qt, q, WordIdH, QtToWordIdVH)) {    
2493              Net->AddLink(Q, Qt2);
2494              Links++;
2495            }
2496          }
2497          Candidates++;
2498        }
2499      }
2500      AllCand += Candidates;
2501      AllLinks += Links;
2502      CandLenH.AddDat(Candidates) += 1;
2503      LinkLenH.AddDat(Links) += 1;
2504      if (W < 21) {
2505        QtLenCandH.AddDat(W).AddDat(Candidates) += 1;
2506        QtLenLinkH.AddDat(W).AddDat(Links) += 1;
2507      }
2508      if (qt % 1000 == 0 || qt==QtBsLen-1) {
2509        printf("\r%d  %s    allCands: %d    allLinks: %d    nodes:%d", qt, ExeTm.GetStr(), AllCand, AllLinks, Net->GetNodes());
2510        if (qt % 100000 == 0 || qt==QtBsLen-1) {
2511          TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2512            "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2513          TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2514            "ClustNet: number of out-links of a quote", "Count", gpsLog);
2515        }
2516      }
2517    }
2518    printf("done.\n");
2519    TGnuPlot::PlotValCntH(CandLenH, "qtNet-NCand", "Number of candidate links for each quote (candidate has at most 2*words)",
2520      "ClustNet: number of candidate quotes to create link to", "Count", gpsLog);
2521    TGnuPlot::PlotValCntH(LinkLenH, "qtNet-NLink", "Number of links for each quote (candidate has at most 2*words)",
2522      "ClustNet: number of out-links of a quote", "Count", gpsLog);
2523    return Net;
2524  }
2525  void TQuoteLoader::Clr() {
2526    PostTitleStr.Clr();
2527    PostUrlStr.Clr();
2528    PubTm = TSecTm();
2529    BlogUrlStr.Clr();
2530    BlogTitleStr.Clr();
2531    ContentStr.Clr();
2532    QuoteV.Clr(false);
2533    LinkV.Clr(false);
2534  }
2535  bool TQuoteLoader::LoadItem(TXmlLx& XmlLx) {
2536    static const TSecTm BegOfTm(2008,8,30, 0, 0, 0);
2537    Clr();
2538    try {
2539      EAssert(XmlLx.TagNm == "post");
2540      const TChA T = TStrUtil::GetXmlTagVal(XmlLx, "pubDate");
2541      PubTm = TSecTm(atoi(T.GetSubStr(0,3).CStr()), atoi(T.GetSubStr(5,6).CStr()), atoi(T.GetSubStr(8,9).CStr()),
2542        atoi(T.GetSubStr(11,12).CStr()), atoi(T.GetSubStr(14,15).CStr()), atoi(T.GetSubStr(17,18).CStr()));
2543      EAssert(PubTm > BegOfTm);
2544      PostUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "postUrl");
2545      PostTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "postTitle");
2546      BlogUrlStr = TStrUtil::GetXmlTagVal(XmlLx, "blogUrl");
2547      BlogTitleStr = TStrUtil::GetXmlTagVal(XmlLx, "blogTitle");
2548      ContentStr = TStrUtil::GetXmlTagVal(XmlLx, "content");
2549      while (XmlLx.GetSym()==xsySTag && XmlLx.TagNm=="q") {
2550        EAssert(XmlLx.GetSym() == xsyStr);
2551        QuoteV.Add(XmlLx.TxtChA);
2552        EAssert(XmlLx.GetSym() == xsyETag && XmlLx.TagNm=="q");
2553      }
2554    }
2555    catch (PExcept Except){
2556      ErrNotify(Except->GetStr());
2557      Fail;  return false;
2558    }
2559    return true;
2560  }
2561  void TQuoteLoader::Save(TSOut& SOut) const {
2562    PubTm.Save(SOut);
2563    PostUrlStr.Save(SOut);
2564    PostTitleStr.Save(SOut);
2565    BlogUrlStr.Save(SOut);
2566    BlogTitleStr.Save(SOut);
2567    ContentStr.Save(SOut);
2568    QuoteV.Save(SOut);
2569    LinkV.Save(SOut);
2570  }
2571  void TQuoteLoader::Load(TSIn& SIn) {
2572    PubTm.Load(SIn);
2573    PostUrlStr.Load(SIn);
2574    PostTitleStr.Load(SIn);
2575    BlogUrlStr.Load(SIn);
2576    BlogTitleStr.Load(SIn);
2577    ContentStr.Load(SIn);
2578    QuoteV.Load(SIn);
2579    LinkV.Load(SIn);
2580  }
2581  bool TQuoteLoader::Next() {
2582    if (SIn.Empty() || SIn->Eof()) {
2583      printf("  new file");
2584      if (! FFile.Next(CurFNm)) { return false; }
2585      printf(" %s\n", CurFNm.GetFMid().CStr());
2586      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2587      StartProcFile(CurFNm);
2588    }
2589    Load(*SIn);
2590    if (++PostCnt % Kilo(10) == 0) { printf("\r  %dk [%s]  ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2591    return true;
2592  }
2593  void TQuoteLoader::ProcessPosts(const bool& IsXml, int LoadN) {
2594    TExeTm ExeTm, TotalTm;
2595    StartProcess();
2596    if (LoadN < 0) { LoadN = TInt::Mx; }
2597    int FilePostCnt=0;
2598    for (int f = 1; FFile.Next(CurFNm); f++) {
2599      printf("*** FILE:  %s\n", CurFNm.GetFMid().CStr());
2600      SIn = TZipIn::IsZipExt(CurFNm.GetFExt()) ? PSIn(new TZipIn(CurFNm)) : PSIn(new TFIn(CurFNm));
2601      if (IsXml) {
2602        TXmlLx XmlLx(SIn, xspTruncate);
2603        StartProcFile(CurFNm);
2604        for (FilePostCnt=0; XmlLx.GetSym() != xsyEof; FilePostCnt++, PostCnt++) {
2605          if (! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) {
2606            while (XmlLx.GetSym()!=xsyEof && ! (XmlLx.Sym==xsySTag && XmlLx.TagNm=="post")) { }
2607            if (XmlLx.Sym == xsyEof) { break; }
2608          }
2609          const bool IsGoodPost = LoadItem(XmlLx);
2610          ProcessPost(IsGoodPost);
2611          if (PostCnt % Kilo(1) == 0) {
2612            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2613          if (PostCnt >= LoadN) { break; }
2614        }
2615      } else {
2616        FilePostCnt = 0;
2617        while (! SIn->Eof()) {
2618          Load(*SIn);  FilePostCnt++;  PostCnt++;
2619          ProcessPost(true);
2620          if (PostCnt % Kilo(10) == 0) {
2621            printf("\r%dk [%s] ", PostCnt/Kilo(1), ExeTm.GetStr()); }
2622          if (PostCnt >= LoadN) { break; }
2623        }
2624      }
2625      printf("\n================================================================\n");
2626      printf("  file:  %s\n", CurFNm.GetFMid().CStr());
2627      printf("  time:  %s   ", ExeTm.GetStr());
2628      printf("total: %s [%s]\n", TotalTm.GetStr(), TExeTm::GetCurTm());
2629      printf("  posts: %d   total: %d\n", FilePostCnt, PostCnt);
2630      EndProcFile(CurFNm);
2631      fflush(stdout);  ExeTm.Tick();
2632      if (PostCnt >= LoadN) { break; }
2633    }
2634    EndProcess(PostCnt);
2635  }
2636  bool TMemesDataLoader::GetNextFile() {
2637    TStr FNm;
2638    if (! FFile.Empty()) {
2639      if (! FFile->Next(FNm)) { return false; }
2640      printf("NEXT-FL:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2641    } else {
2642      IAssert(! InFNmF.Empty());
2643      if (InFNmF->Eof()) { return false; }
2644    while (! InFNmF->Eof() && InFNmF->GetNextLn(FNm) && FNm.Empty()) { }
2645      printf("NEXT-LN:  %s :\t%s\n", FNm.GetFBase().CStr(), TExeTm::GetCurTm());
2646    }
2647    if (FNm.Empty()) { return false; }
2648    if (TZipIn::IsZipExt(FNm.GetFExt())) {
2649      SInPt = TZipIn::New(FNm); }
2650    else {
2651      SInPt = TFIn::New(FNm); }  LineCnt = 0;
2652    return true;
2653  }
2654  void TMemesDataLoader::Clr() {
2655    PostUrlStr.Clr();
2656    ContentStr.Clr();
2657    PubTm = TSecTm();
2658    MemeV.Clr(false);
2659    MemePosV.Clr(false);
2660    LinkV.Clr(false);
2661    LinkPosV.Clr(false);
2662  }
2663  bool TMemesDataLoader::LoadNext() {
2664    Clr();
2665    if (SInPt.Empty() || SInPt->Eof()) {
2666      if (! GetNextFile()) { return false; }
2667    }
2668    TSIn& SIn = *SInPt;
2669    CurLn.Clr();
2670    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='U' || CurLn[1]!='\t'))) { 
2671      printf("L: %s\n", CurLn.CStr()); LineCnt++; }
2672    LineCnt++;
2673    if (CurLn.Empty()) { return LoadNext(); }
2674    IAssertR((! CurLn.Empty()) && CurLn[0]=='U' && CurLn[1]=='\t', 
2675      TStr::Fmt("ERROR1: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());
2676    PostUrlStr = CurLn.CStr()+2;
2677    while (SIn.GetNextLn(CurLn) && (CurLn.Empty() || (CurLn[0]!='D' || CurLn[1]!='\t'))) { LineCnt++; }
2678    IAssertR((! CurLn.Empty()) && CurLn[0]=='D', 
2679      TStr::Fmt("ERROR2: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2680    try {
2681      PubTm = TSecTm::GetDtTmFromStr(CurLn);
2682    } catch (PExcept Except){ PubTm = 1; ErrNotify(Except->GetStr());
2683      printf("ERROR3: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()); 
2684    }
2685    IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && (CurLn[0]=='C' || CurLn[0]=='T'), 
2686      TStr::Fmt("ERROR4: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++;
2687    if (CurLn[0] == 'T') { 
2688      IAssertR(SIn.GetNextLn(CurLn) && (! CurLn.Empty()) && CurLn[0]=='C', 
2689        TStr::Fmt("ERROR5: %s [line %llu]: '%s'\n", SIn.GetSNm().CStr(), LineCnt, CurLn.CStr()).CStr());  LineCnt++; }
2690    ContentStr = CurLn.CStr()+2;
2691    while (SIn.GetNextLn(CurLn)) {  LineCnt++;
2692      if (CurLn.Empty() || CurLn[0]!='L') { break; }
2693      int linkb=2;
2694      while (CurLn[linkb]!='\t') { linkb++; }
2695      CurLn[linkb]=0;
2696      LinkV.Add(CurLn.CStr()+linkb+1);
2697      LinkPosV.Add(atoi(CurLn.CStr()+2));
2698    }
2699    do {
2700      if (CurLn.Empty() || CurLn[0]!='Q') { break; }
2701      int qb1=2;      while (CurLn[qb1]!='\t') { qb1++; }
2702      int qb2=qb1+1;  while (CurLn[qb2]!='\t') { qb2++; }
2703      CurLn[qb1]=0;  CurLn[qb2]=0;
2704      MemeV.Add(CurLn.CStr()+qb2+1);
2705      MemePosV.Add(TIntPr(atoi(CurLn.CStr()+2), atoi(CurLn.CStr()+qb1+1)));
2706      LineCnt++;
2707    } while (SIn.GetNextLn(CurLn));
2708    return true;
2709  }
2710  void TMemesDataLoader::SaveTxt(TSOut& SOut) const {
2711  }
2712  void TMemesDataLoader::Dump(const bool& DumpAll) const {
2713  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</h3>
            <pre><code>1  void TNEANet::LoadNetworkShM(TShMIn& ShMIn) {
2    MxNId = TInt(ShMIn);
3    MxEId = TInt(ShMIn);
4    LoadTNodeFunctor NodeFn;
5    NodeH.LoadShM(ShMIn, NodeFn);
6    EdgeH.LoadShM(ShMIn);
7    KeyToIndexTypeN.LoadShM(ShMIn);
8    KeyToIndexTypeE.LoadShM(ShMIn);
9    KeyToDenseN.LoadShM(ShMIn);
10    KeyToDenseE.LoadShM(ShMIn);
11    IntDefaultsN.LoadShM(ShMIn);
12    IntDefaultsE.LoadShM(ShMIn);
13    StrDefaultsN.LoadShM(ShMIn);
14    StrDefaultsE.LoadShM(ShMIn);
15    FltDefaultsE.LoadShM(ShMIn);
16    FltDefaultsE.LoadShM(ShMIn);
17    LoadVecFunctor vec_fn;
18    VecOfIntVecsN.LoadShM(ShMIn, vec_fn);
19    VecOfIntVecsE.LoadShM(ShMIn, vec_fn);
20    VecOfStrVecsN.Load(ShMIn);
21    VecOfStrVecsE.Load(ShMIn);
22    VecOfFltVecsN.Load(ShMIn);
23    VecOfFltVecsE.Load(ShMIn);
24    LoadVecOfVecFunctor vec_of_vec_fn;
25    VecOfIntVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
26    VecOfIntVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
27    VecOfFltVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
28    VecOfFltVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
29    LoadHashOfVecFunctor hash_of_vec_fn;
30    VecOfIntHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
31    VecOfIntHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
32    VecOfFltHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
33    VecOfFltHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
34    SAttrN.Load(ShMIn);
35    SAttrE.Load(ShMIn);
36  }
37  bool TNEANet::HasFlag(const TGraphFlag& Flag) const {
38    return HasGraphFlag(TNEANet::TNet, Flag);
39  }
40  bool TNEANet::TNodeI::IsInNId(const int& NId) const {
41    const TNode& Node = NodeHI.GetDat();
42    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
43      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
44        return true;
45    }
46    return false;
47  }
48  bool TNEANet::TNodeI::IsOutNId(const int& NId) const {
49    const TNode& Node = NodeHI.GetDat();
50    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
51      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
52        return true;
53    }
54    return false;
55  }
56  void TNEANet::AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
57    Names = TVec<TStr>();
58    while (!NodeHI.IsEnd()) {
59      if (!NodeAttrIsDeleted(NId, NodeHI)) {
60        Names.Add(NodeHI.GetKey());
61      }
62      NodeHI++;
63    }  
64  }
65  void TNEANet::AttrValueNI(const TInt& NId , TStrIntPrH::TIter NodeHI, TStrV& Values) const {
66    Values = TVec<TStr>();
67    while (!NodeHI.IsEnd()) {
68      if (!NodeAttrIsDeleted(NId, NodeHI)) {
69        Values.Add(GetNodeAttrValue(NId, NodeHI));
70      }
71      NodeHI++;
72    }
73  }
74  void TNEANet::IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
75    Names = TVec<TStr>();
76    while (!NodeHI.IsEnd()) {
77      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
78        Names.Add(NodeHI.GetKey());
79      }
80      NodeHI++;
81    }  
82  }
83  void TNEANet::IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const {
84    Values = TVec<TInt>();
85    while (!NodeHI.IsEnd()) {
86      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
87        TInt val = this->VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
88        Values.Add(val);
89      }
90      NodeHI++;
91    }  
92  }
93  void TNEANet::IntVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
94    Names = TVec<TStr>();
95    while (!NodeHI.IsEnd()) {
96      if (NodeHI.GetDat().Val1 == IntVType) {
97        Names.Add(NodeHI.GetKey());
98      }
99      NodeHI++;
100    }  
101  }
102  void TNEANet::IntVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TIntV>& Values) const {
103    Values = TVec<TIntV>();
104    while (!NodeHI.IsEnd()) {
105      if (NodeHI.GetDat().Val1 == IntVType) {
106        TInt index = NodeHI.GetDat().Val2;
107        TStr attr =  NodeHI.GetKey();
108        TInt loc = CheckDenseOrSparseN(attr);
109        if (loc == 1) {
110          TIntV val = this->VecOfIntVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
111          if (val.Len() != 0) Values.Add(val);
112        } else {
113          const THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[index];
114          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
115            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
116          }
117        }
118      }
119      NodeHI++;
120    }
121  }
122  void TNEANet::FltVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
123    Names = TVec<TStr>();
124    while (!NodeHI.IsEnd()) {
125      if (NodeHI.GetDat().Val1 == FltVType) {
126        Names.Add(NodeHI.GetKey());
127      }
128      NodeHI++;
129    }  
130  }
131  void TNEANet::FltVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TFltV>& Values) const {
132    Values = TVec<TFltV>();
133    while (!NodeHI.IsEnd()) {
134      if (NodeHI.GetDat().Val1 == FltVType) {
135        TInt index = NodeHI.GetDat().Val2;
136        TStr attr =  NodeHI.GetKey();
137        TInt loc = CheckDenseOrSparseN(attr);
138        if (loc == 1) {
139          TFltV val = this->VecOfFltVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
140          if (val.Len() != 0) Values.Add(val);
141        } else {
142          const THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[index];
143          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
144            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
145          }
146        }
147      }
148      NodeHI++;
149    }
150  }
151  void TNEANet::StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
152    Names = TVec<TStr>();
153    while (!NodeHI.IsEnd()) {
154      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
155        Names.Add(NodeHI.GetKey());
156      }
157      NodeHI++;
158    }  
159  }
160  void TNEANet::StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const {
161    Values = TVec<TStr>();
162    while (!NodeHI.IsEnd()) {
163      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
164        TStr val = this->VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
165        Values.Add(val);
166      }
167      NodeHI++;
168    }  
169  }
170  void TNEANet::FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
171    Names = TVec<TStr>();
172    while (!NodeHI.IsEnd()) {
173      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
174        Names.Add(NodeHI.GetKey());
175      }
176      NodeHI++;
177    }  
178  }
179  void TNEANet::FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const {
180    Values = TVec<TFlt>();
181    while (!NodeHI.IsEnd()) {
182      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
183        TFlt val = (this->VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
184        Values.Add(val);
185      }
186      NodeHI++;
187    }  
188  }
189  bool TNEANet::IsAttrDeletedN(const int& NId, const TStr& attr) const {
190    bool IntDel = IsIntAttrDeletedN(NId, attr);
191    bool StrDel = IsStrAttrDeletedN(NId, attr);
192    bool FltDel = IsFltAttrDeletedN(NId, attr);
193    bool IntVDel = IsIntVAttrDeletedN(NId, attr);
194    bool FltVDel = IsFltVAttrDeletedN(NId, attr);
195    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
196  }
197  bool TNEANet::IsIntAttrDeletedN(const int& NId, const TStr& attr) const {
198    return NodeAttrIsIntDeleted(NId, KeyToIndexTypeN.GetI(attr));
199  }
200  bool TNEANet::IsIntVAttrDeletedN(const int& NId, const TStr& attr) const {
201    return NodeAttrIsIntVDeleted(NId, KeyToIndexTypeN.GetI(attr));
202  }
203  bool TNEANet::IsFltVAttrDeletedN(const int& NId, const TStr& attr) const {
204    return NodeAttrIsFltVDeleted(NId, KeyToIndexTypeN.GetI(attr));
205  }
206  bool TNEANet::IsStrAttrDeletedN(const int& NId, const TStr& attr) const {
207    return NodeAttrIsStrDeleted(NId, KeyToIndexTypeN.GetI(attr));
208  }
209  bool TNEANet::IsFltAttrDeletedN(const int& NId, const TStr& attr) const {
210    return NodeAttrIsFltDeleted(NId, KeyToIndexTypeN.GetI(attr));
211  }
212  bool TNEANet::NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
213    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
214    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
215    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
216    bool IntVDel = NodeAttrIsIntVDeleted(NId, NodeHI);
217    return IntDel || StrDel || FltDel || IntVDel;
218  }
219  bool TNEANet::NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
220    if (NodeHI.GetDat().Val1 != IntType) {
221      return false;
222    }
223    return (GetIntAttrDefaultN(NodeHI.GetKey()) == this->VecOfIntVecsN.GetVal(
224      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
225  }
226  bool TNEANet::NodeAttrIsIntVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
227    if (NodeHI.GetDat().Val1 != IntVType) {
228      return false;
229    }
230    return (TIntV() == this->VecOfIntVecVecsN.GetVal(
231      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
232  }
233  bool TNEANet::NodeAttrIsFltVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
234    if (NodeHI.GetDat().Val1 != FltVType) {
235      return false;
236    }
237    return (TFltV() == this->VecOfFltVecVecsN.GetVal(
238      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
239  }
240  bool TNEANet::NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
241    if (NodeHI.GetDat().Val1 != StrType) {
242      return false;
243    }
244    return (GetStrAttrDefaultN(NodeHI.GetKey()) == this->VecOfStrVecsN.GetVal(
245      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
246  }
247  bool TNEANet::NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
248    if (NodeHI.GetDat().Val1 != FltType) {
249      return false;
250    }
251    return (GetFltAttrDefaultN(NodeHI.GetKey()) == this->VecOfFltVecsN.GetVal(
252      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
253  }
254  TStr TNEANet::GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
255    if (NodeHI.GetDat().Val1 == IntType) {
256      return (this->VecOfIntVecsN.GetVal(
257        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
258    } else if(NodeHI.GetDat().Val1 == StrType) {
259      return this->VecOfStrVecsN.GetVal(
260      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
261    } else if (NodeHI.GetDat().Val1 == FltType) {
262      return (this->VecOfFltVecsN.GetVal(
263        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
264    }
265    return TStr::GetNullStr();
266  }
267  void TNEANet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
268    Names = TVec<TStr>();
269    while (!EdgeHI.IsEnd()) {
270      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
271        Names.Add(EdgeHI.GetKey());
272      }
273      EdgeHI++;
274    }  
275  }
276  void TNEANet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
277    Values = TVec<TStr>();
278    while (!EdgeHI.IsEnd()) {
279      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
280        Values.Add(GetEdgeAttrValue(EId, EdgeHI));
281      }
282      EdgeHI++;
283    }  
284  }
285  void TNEANet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
286    Names = TVec<TStr>();
287    while (!EdgeHI.IsEnd()) {
288      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
289        Names.Add(EdgeHI.GetKey());
290      }
291      EdgeHI++;
292    }  
293  }
294  void TNEANet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const {
295    Values = TVec<TInt>();
296    while (!EdgeHI.IsEnd()) {
297      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
298        TInt val = (this->VecOfIntVecsE[EdgeHI.GetDat().Val2].GetVal(EdgeH.GetKeyId(EId)));
299        Values.Add(val);
300      }
301      EdgeHI++;
302    }  
303  }
304  void TNEANet::IntVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
305    Names = TVec<TStr>();
306    while (!EdgeHI.IsEnd()) {
307      if (EdgeHI.GetDat().Val1 == IntVType) {
308        Names.Add(EdgeHI.GetKey());
309      }
310      EdgeHI++;
311    }  
312  }
313  void TNEANet::IntVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TIntV>& Values) const {
314    Values = TVec<TIntV>();
315    while (!EdgeHI.IsEnd()) {
316      if (EdgeHI.GetDat().Val1 == IntVType) {
317        TInt index = EdgeHI.GetDat().Val2;
318        TStr attr =  EdgeHI.GetKey();
319        TInt loc = CheckDenseOrSparseE(attr);
320        if (loc == 1) {
321          TIntV val = this->VecOfIntVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
322          if (val.Len() != 0) Values.Add(val);
323        } else {
324          const THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[index];
325          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
326            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
327          }
328        }
329      }
330      EdgeHI++;
331    }
332  }
333  void TNEANet::FltVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
334    Names = TVec<TStr>();
335    while (!EdgeHI.IsEnd()) {
336      if (EdgeHI.GetDat().Val1 == FltVType) {
337        Names.Add(EdgeHI.GetKey());
338      }
339      EdgeHI++;
340    }  
341  }
342  void TNEANet::FltVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TFltV>& Values) const {
343    Values = TVec<TFltV>();
344    while (!EdgeHI.IsEnd()) {
345      if (EdgeHI.GetDat().Val1 == FltVType) {
346        TInt index = EdgeHI.GetDat().Val2;
347        TStr attr =  EdgeHI.GetKey();
348        TInt loc = CheckDenseOrSparseE(attr);
349        if (loc == 1) {
350          TFltV val = this->VecOfFltVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
351          if (val.Len() != 0) Values.Add(val);
352        } else {
353          const THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[index];
354          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
355            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
356          }
357        }
358      }
359      EdgeHI++;
360    }
361  }
362  void TNEANet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
363    Names = TVec<TStr>();
364    while (!EdgeHI.IsEnd()) {
365      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
366        Names.Add(EdgeHI.GetKey());
367      }
368      EdgeHI++;
369    }  
370  }
371  void TNEANet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
372    Values = TVec<TStr>();
373    while (!EdgeHI.IsEnd()) {
374      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
375        TStr val = this->VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
376        Values.Add(val);
377      }
378      EdgeHI++;
379    }  
380  }
381  void TNEANet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
382    Names = TVec<TStr>();
383    while (!EdgeHI.IsEnd()) {
384      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
385        Names.Add(EdgeHI.GetKey());
386      }
387      EdgeHI++;
388    }  
389  }
390  void TNEANet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const {
391    Values = TVec<TFlt>();
392    while (!EdgeHI.IsEnd()) {
393      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
394        TFlt val = (this->VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
395        Values.Add(val);
396      }
397      EdgeHI++;
398    }  
399  }
400  bool TNEANet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
401    bool IntDel = IsIntAttrDeletedE(EId, attr);
402    bool IntVDel = IsIntVAttrDeletedE(EId, attr);
403    bool StrDel = IsStrAttrDeletedE(EId, attr);
404    bool FltDel = IsFltAttrDeletedE(EId, attr);
405    bool FltVDel = IsFltVAttrDeletedE(EId, attr);
406    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
407  }
408  bool TNEANet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
409    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
410  }
411  bool TNEANet::IsIntVAttrDeletedE(const int& EId, const TStr& attr) const {
412    return EdgeAttrIsIntVDeleted(EId, KeyToIndexTypeE.GetI(attr));
413  }
414  bool TNEANet::IsFltVAttrDeletedE(const int& EId, const TStr& attr) const {
415    return EdgeAttrIsFltVDeleted(EId, KeyToIndexTypeE.GetI(attr));
416  }
417  bool TNEANet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
418    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
419  }
420  bool TNEANet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
421    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
422  }
423  bool TNEANet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
424    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
425    bool IntVDel = EdgeAttrIsIntVDeleted(EId, EdgeHI);
426    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
427    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
428    bool FltVDel = EdgeAttrIsFltVDeleted(EId, EdgeHI);
429    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
430  }
431  bool TNEANet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
432    return (EdgeHI.GetDat().Val1 == IntType &&
433      GetIntAttrDefaultE(EdgeHI.GetKey()) == this->VecOfIntVecsE.GetVal(
434      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
435  }
436  bool TNEANet::EdgeAttrIsIntVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
437    return (EdgeHI.GetDat().Val1 == IntVType &&
438      TIntV() == this->VecOfIntVecVecsE.GetVal(
439      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
440  }
441  bool TNEANet::EdgeAttrIsFltVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
442    return (EdgeHI.GetDat().Val1 == FltVType &&
443      TFltV() == this->VecOfFltVecVecsE.GetVal(
444      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
445  }
446  bool TNEANet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
447    return (EdgeHI.GetDat().Val1 == StrType &&
448      GetStrAttrDefaultE(EdgeHI.GetKey()) == this->VecOfStrVecsE.GetVal(
449      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
450  }
451  bool TNEANet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
452    return (EdgeHI.GetDat().Val1 == FltType &&
453      GetFltAttrDefaultE(EdgeHI.GetKey()) == this->VecOfFltVecsE.GetVal(
454      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
455  }
456  TStr TNEANet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
457    if (EdgeHI.GetDat().Val1 == IntType) {
458      return (this->VecOfIntVecsE.GetVal(
459        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
460    } else if(EdgeHI.GetDat().Val1 == StrType) {
461      return this->VecOfStrVecsE.GetVal(
462      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
463    } else if (EdgeHI.GetDat().Val1 == FltType) {
464      return (this->VecOfFltVecsE.GetVal(
465        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
466    }
467    return TStr::GetNullStr();
468  }
469  int TNEANet::AddNode(int NId) {
470    if (NId == -1) {
471      NId = MxNId;  MxNId++;
472    } else {
473      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
474      MxNId = TMath::Mx(NId+1, MxNId());
475    }
476    NodeH.AddDat(NId, TNode(NId));
477    AddAttributes(NId);
478    return NId;
479  }
480  int TNEANet::AddNodeUnchecked(int NId) {
481    if (NId == -1) {
482      NId = MxNId;  MxNId++;
483    } else {
484      if (IsNode(NId)) { return -1;}
485      MxNId = TMath::Mx(NId+1, MxNId());
486    }
487    NodeH.AddDat(NId, TNode(NId));
488    AddAttributes(NId);
489    return NId;
490  }
491  int TNEANet::AddAttributes(const int NId) {
492    int i;
493    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
494      TVec<TInt>& IntVec = VecOfIntVecsN[i];
495      int KeyId = NodeH.GetKeyId(NId);
496      if (IntVec.Len() > KeyId) {
497        IntVec[KeyId] = TInt::Mn;
498      } else {
499        IntVec.Ins(KeyId, TInt::Mn);
500      }
501    }
502    TVec<TStr> DefIntVec = TVec<TStr>();
503    IntDefaultsN.GetKeyV(DefIntVec);
504    for (i = 0; i < DefIntVec.Len(); i++) {
505      TStr attr = DefIntVec[i];
506      TVec<TInt>& IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
507      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
508    } 
509    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
510      TVec<TStr>& StrVec = VecOfStrVecsN[i];
511      int KeyId = NodeH.GetKeyId(NId);
512      if (StrVec.Len() > KeyId) {
513        StrVec[KeyId] = TStr::GetNullStr();
514      } else {
515        StrVec.Ins(KeyId, TStr::GetNullStr());
516      }
517    }
518    TVec<TStr> DefStrVec = TVec<TStr>();
519    StrDefaultsN.GetKeyV(DefStrVec);
520    for (i = 0; i < DefStrVec.Len(); i++) {
521      TStr attr = DefStrVec[i];
522      TVec<TStr>& StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
523      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
524    }
525    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
526      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
527      int KeyId = NodeH.GetKeyId(NId);
528      if (FltVec.Len() > KeyId) {
529        FltVec[KeyId] = TFlt::Mn;
530      } else {
531        FltVec.Ins(KeyId, TFlt::Mn);
532      }
533    }
534    TVec<TStr> DefFltVec = TVec<TStr>();
535    FltDefaultsN.GetKeyV(DefFltVec);
536    for (i = 0; i < DefFltVec.Len(); i++) {
537      TStr attr = DefFltVec[i];
538      TVec<TFlt>& FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
539      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
540    }
541    for (i = 0; i < VecOfIntVecVecsN.Len(); i++) {
542      TVec<TIntV>& IntVecV = VecOfIntVecVecsN[i];
543      int KeyId = NodeH.GetKeyId(NId);
544      if (IntVecV.Len() > KeyId) {
545        IntVecV[KeyId] = TIntV();
546      } else {
547        IntVecV.Ins(KeyId, TIntV());
548      }
549    }
550    for (i = 0; i < VecOfFltVecVecsN.Len(); i++) {
551      TVec<TFltV>& FltVecV = VecOfFltVecVecsN[i];
552      int KeyId = NodeH.GetKeyId(NId);
553      if (FltVecV.Len() > KeyId) {
554        FltVecV[KeyId] = TFltV();
555      } else {
556        FltVecV.Ins(KeyId, TFltV());
557      }
558    }
559    return NId;
560  }
561  void TNEANet::DelNode(const int& NId) {
562    int i;
563    TInt Id(NId);
564    SAttrN.DelSAttrId(Id);
565    const TNode& Node = GetNode(NId);
566    for (int out = 0; out < Node.GetOutDeg(); out++) {
567      const int EId = Node.GetOutEId(out);
568      const TEdge& Edge = GetEdge(EId);
569      IAssert(Edge.GetSrcNId() == NId);
570      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
571      for (i = 0; i < VecOfIntVecsE.Len(); i++) {
572        TVec<TInt>& IntVec = VecOfIntVecsE[i];
573        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
574      }
575      for (i = 0; i < VecOfStrVecsE.Len(); i++) {
576        TVec<TStr>& StrVec = VecOfStrVecsE[i];
577        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
578      }
579      for (i = 0; i < VecOfFltVecsE.Len(); i++) {
580        TVec<TFlt>& FltVec = VecOfFltVecsE[i];
581        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
582      }
583      for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
584        TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
585        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
586      }
587      for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
588        TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
589        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
590      }
591      for (i = 0; i < VecOfIntHashVecsE.Len(); i++) {
592        THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsE[i];
593        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
594          IntHashV.DelKey(EdgeH.GetKeyId(EId));
595        }
596      }
597      for (i = 0; i < VecOfFltHashVecsE.Len(); i++) {
598        THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsE[i];
599        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
600          FltHashV.DelKey(EdgeH.GetKeyId(EId));
601        }
602      }
603      EdgeH.DelKey(EId);
604    }
605    for (int in = 0; in < Node.GetInDeg(); in++) {
606      const int EId = Node.GetInEId(in);
607      const TEdge& Edge = GetEdge(EId);
608      IAssert(Edge.GetDstNId() == NId);
609      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
610      for (i = 0; i < VecOfIntVecsE.Len(); i++) {
611        TVec<TInt>& IntVec = VecOfIntVecsE[i];
612        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
613      }
614      for (i = 0; i < VecOfStrVecsE.Len(); i++) {
615        TVec<TStr>& StrVec = VecOfStrVecsE[i];
616        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
617      }
618      for (i = 0; i < VecOfFltVecsE.Len(); i++) {
619        TVec<TFlt>& FltVec = VecOfFltVecsE[i];
620        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
621      }
622      for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
623        TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
624        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
625      }
626      for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
627        TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
628        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
629      }
630      for (i = 0; i < VecOfIntHashVecsE.Len(); i++) {
631        THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsE[i];
632        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
633          IntHashV.DelKey(EdgeH.GetKeyId(EId));
634        }
635      }
636      for (i = 0; i < VecOfFltHashVecsE.Len(); i++) {
637        THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsE[i];
638        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
639          FltHashV.DelKey(EdgeH.GetKeyId(EId));
640        }
641      }
642      EdgeH.DelKey(EId);
643    }
644    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
645      TVec<TInt>& IntVec = VecOfIntVecsN[i];
646      IntVec[NodeH.GetKeyId(NId)] = TInt::Mn;
647    }
648    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
649      TVec<TStr>& StrVec = VecOfStrVecsN[i];
650      StrVec[NodeH.GetKeyId(NId)] = TStr::GetNullStr();
651    }
652    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
653      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
654      FltVec[NodeH.GetKeyId(NId)] = TFlt::Mn;
655    }
656    for (i = 0; i < VecOfIntVecVecsN.Len(); i++) {
657      TVec<TIntV>& IntVecV = VecOfIntVecVecsN[i];
658      IntVecV[NodeH.GetKeyId(NId)] = TIntV();
659    }
660    for (i = 0; i < VecOfFltVecVecsN.Len(); i++) {
661      TVec<TFltV>& FltVecV = VecOfFltVecVecsN[i];
662      FltVecV[NodeH.GetKeyId(NId)] = TFltV();
663    }
664    for (i = 0; i < VecOfIntHashVecsN.Len(); i++) {
665      THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsN[i];
666      if (IntHashV.IsKey(NodeH.GetKeyId(NId))) {
667        IntHashV.DelKey(NodeH.GetKeyId(NId));
668      }
669    }
670    for (i = 0; i < VecOfFltHashVecsN.Len(); i++) {
671      THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsN[i];
672      if (FltHashV.IsKey(NodeH.GetKeyId(NId))) {
673        FltHashV.DelKey(NodeH.GetKeyId(NId));
674      }
675    }
676    NodeH.DelKey(NId);
677  }
678  int TNEANet::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
679    int i;
680    if (EId == -1) { EId = MxEId;  MxEId++; }
681    else { MxEId = TMath::Mx(EId+1, MxEId()); }
682    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
683    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
684    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
685    GetNode(SrcNId).OutEIdV.AddSorted(EId);
686    GetNode(DstNId).InEIdV.AddSorted(EId);
687    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
688      TVec<TInt>& IntVec = VecOfIntVecsE[i];
689      int KeyId = EdgeH.GetKeyId(EId);
690      if (IntVec.Len() > KeyId) {
691        IntVec[KeyId] = TInt::Mn;
692      } else {
693        IntVec.Ins(KeyId, TInt::Mn);
694      }
695    }
696    TVec<TStr> DefIntVec = TVec<TStr>();
697    IntDefaultsE.GetKeyV(DefIntVec);
698    for (i = 0; i < DefIntVec.Len(); i++) {
699      TStr attr = DefIntVec[i];
700      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
701      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
702    }
703    for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
704      TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
705      IntVecV.Ins(EdgeH.GetKeyId(EId), TIntV());
706    }
707    for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
708      TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
709      FltVecV.Ins(EdgeH.GetKeyId(EId), TFltV());
710    }
711    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
712      TVec<TStr>& StrVec = VecOfStrVecsE[i];
713      int KeyId = EdgeH.GetKeyId(EId);
714      if (StrVec.Len() > KeyId) {
715        StrVec[KeyId] = TStr::GetNullStr();
716      } else {
717        StrVec.Ins(KeyId, TStr::GetNullStr());
718      }
719    }
720    TVec<TStr> DefStrVec = TVec<TStr>();
721    StrDefaultsE.GetKeyV(DefStrVec);
722    for (i = 0; i < DefStrVec.Len(); i++) {
723      TStr attr = DefStrVec[i];
724      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
725      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
726    }
727    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
728      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
729      int KeyId = EdgeH.GetKeyId(EId);
730      if (FltVec.Len() > KeyId) {
731        FltVec[KeyId] = TFlt::Mn;
732      } else {
733        FltVec.Ins(KeyId, TFlt::Mn);
734      }
735    }
736    TVec<TStr> DefFltVec = TVec<TStr>();
737    FltDefaultsE.GetKeyV(DefFltVec);
738    for (i = 0; i < DefFltVec.Len(); i++) {
739      TStr attr = DefFltVec[i];
740      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
741      FltVec[EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
742    }
743    return EId;
744  }
745  void TNEANet::DelEdge(const int& EId) {
746    int i;
747    IAssert(IsEdge(EId));
748    const int SrcNId = GetEdge(EId).GetSrcNId();
749    const int DstNId = GetEdge(EId).GetDstNId();
750    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
751    GetNode(DstNId).InEIdV.DelIfIn(EId);
752    TInt Id(EId);
753    SAttrE.DelSAttrId(Id);
754    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
755      TVec<TInt>& IntVec = VecOfIntVecsE[i];
756      IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
757    }
758    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
759      TVec<TStr>& StrVec = VecOfStrVecsE[i];
760      StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
761    }
762    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
763      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
764      FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
765    }
766    EdgeH.DelKey(EId);
767  }
768  void TNEANet::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
769    int EId = 0;
770    bool Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
771    IAssert(Edge); 
772    while (Edge) {
773      DelEdge(EId);
774      Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
775    }
776  }
777  bool TNEANet::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
778    if (! IsNode(SrcNId) || ! IsNode(DstNId)) {
779      return false;
780    }
781    const TNode& SrcNode = GetNode(SrcNId);
782    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
783      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
784      if (DstNId == Edge.GetDstNId()) {
785        EId = Edge.GetId();
786        return true;
787      }
788    }
789    if (! IsDir) {
790      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
791        const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
792        if (DstNId == Edge.GetSrcNId()) {
793          EId = Edge.GetId();
794          return true;
795        }
796      }
797    }
798    return false;
799  }
800  void TNEANet::GetNIdV(TIntV& NIdV) const {
801    NIdV.Gen(GetNodes(), 0);
802    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
803      NIdV.Add(NodeH.GetKey(N));
804    }
805  }
806  void TNEANet::GetEIdV(TIntV& EIdV) const {
807    EIdV.Gen(GetEdges(), 0);
808    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
809      EIdV.Add(EdgeH.GetKey(E));
810    }
811  }
812  void TNEANet::Defrag(const bool& OnlyNodeLinks) {
813    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
814      TNode& Node = NodeH[kid];
815      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
816    }
817    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
818    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
819  }
820  bool TNEANet::IsOk(const bool& ThrowExcept) const {
821    bool RetVal = true;
822    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
823      const TNode& Node = NodeH[N];
824      if (! Node.OutEIdV.IsSorted()) {
825        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
826        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
827      }
828      if (! Node.InEIdV.IsSorted()) {
829        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
830        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
831      }
832      int prevEId = -1;
833      for (int e = 0; e < Node.GetOutDeg(); e++) {
834        if (! IsEdge(Node.GetOutEId(e))) {
835          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
836          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
837        }
838        if (e > 0 && prevEId == Node.GetOutEId(e)) {
839          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
840          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
841        }
842        prevEId = Node.GetOutEId(e);
843      }
844      prevEId = -1;
845      for (int e = 0; e < Node.GetInDeg(); e++) {
846        if (! IsEdge(Node.GetInEId(e))) {
847        const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
848        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
849        }
850        if (e > 0 && prevEId == Node.GetInEId(e)) {
851          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
852          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
853        }
854        prevEId = Node.GetInEId(e);
855      }
856    }
857    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
858      const TEdge& Edge = EdgeH[E];
859      if (! IsNode(Edge.GetSrcNId())) {
860        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
861        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
862      }
863      if (! IsNode(Edge.GetDstNId())) {
864        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
865        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
866      }
867    }
868    return RetVal;
869  }
870  void TNEANet::Dump(FILE *OutF) const {
871    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
872    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
873    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Network with Attributes: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
874    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
875      fprintf(OutF, "  %*d:", NodePlaces, NodeI.GetId());
876      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
877      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
878        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
879      fprintf(OutF, "    out[%d]", NodeI.GetOutDeg());
880      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
881        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
882      TIntV IntAttrN;
883      IntAttrValueNI(NodeI.GetId(), IntAttrN);
884      fprintf(OutF, "    nai[%d]", IntAttrN.Len());
885      for (int i = 0; i < IntAttrN.Len(); i++) {
886        fprintf(OutF, " %*i", NodePlaces, IntAttrN[i]()); }
887      TStrV StrAttrN;
888      StrAttrValueNI(NodeI.GetId(), StrAttrN);
889      fprintf(OutF, "    nas[%d]", StrAttrN.Len());
890      for (int i = 0; i < StrAttrN.Len(); i++) {
891        fprintf(OutF, " %*s", NodePlaces, StrAttrN[i]()); }
892      TFltV FltAttrN;
893      FltAttrValueNI(NodeI.GetId(), FltAttrN);
894      fprintf(OutF, "    naf[%d]", FltAttrN.Len());
895      for (int i = 0; i < FltAttrN.Len(); i++) {
896        fprintf(OutF, " %*f", NodePlaces, FltAttrN[i]()); }
897      fprintf(OutF, "\n");
898    }
899    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
900      fprintf(OutF, "  %*d:  %*d  ->  %*d", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
901      TIntV IntAttrE;
902      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
903      fprintf(OutF, "    eai[%d]", IntAttrE.Len());
904      for (int i = 0; i < IntAttrE.Len(); i++) {
905        fprintf(OutF, " %*i", EdgePlaces, IntAttrE[i]()); 
906      }
907      TStrV StrAttrE;
908      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
909      fprintf(OutF, "    eas[%d]", StrAttrE.Len());
910      for (int i = 0; i < StrAttrE.Len(); i++) {
911        fprintf(OutF, " %*s", EdgePlaces, StrAttrE[i]()); 
912      }
913      TFltV FltAttrE;
914      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
915      fprintf(OutF, "    eaf[%d]", FltAttrE.Len());
916      for (int i = 0; i < FltAttrE.Len(); i++) {
917        fprintf(OutF, " %*f", EdgePlaces, FltAttrE[i]()); 
918      }
919      fprintf(OutF, "\n");
920    }
921  }
922  int TNEANet::AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
923    int i;
924    TInt CurrLen;
925    if (!IsNode(NId)) {
926      return -1;
927    }
928    if (KeyToIndexTypeN.IsKey(attr)) {
929      TVec<TInt>& NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
930      NewVec[NodeH.GetKeyId(NId)] = value;
931    } else {
932      CurrLen = VecOfIntVecsN.Len();
933      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
934      TVec<TInt> NewVec = TVec<TInt>();
935      for (i = 0; i < MxNId; i++) {
936        NewVec.Ins(i, GetIntAttrDefaultN(attr));
937      }
938      NewVec[NodeH.GetKeyId(NId)] = value;
939      VecOfIntVecsN.Add(NewVec);
940    }
941    return 0;
942  }
943  int TNEANet::AddIntVAttrDatN(const int& NId, const TIntV& value, const TStr& attr, TBool UseDense) {
944    if (!IsNode(NId)) {
945      return -1;
946    }
947    TInt location = CheckDenseOrSparseN(attr);
948    if (location==-1) {
949      AddIntVAttrN(attr, UseDense);
950      location = CheckDenseOrSparseN(attr);
951    }
952    if (UseDense) {
953      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
954      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
955      NewVec[NodeH.GetKeyId(NId)] = value;
956    } else {
957      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
958      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
959      NewHash.AddDat(NodeH.GetKeyId(NId), value);
960    }
961    return 0;
962  } 
963  int TNEANet::AddFltVAttrDatN(const int& NId, const TFltV& value, const TStr& attr, TBool UseDense) {
964    if (!IsNode(NId)) {
965      return -1;
966    }
967    TInt location = CheckDenseOrSparseN(attr);
968    if (location==-1) {
969      AddFltVAttrN(attr, UseDense);
970      location = CheckDenseOrSparseN(attr);
971    }
972    if (UseDense) {
973      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
974      TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
975      NewVec[NodeH.GetKeyId(NId)] = value;
976    } else {
977      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
978      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
979      NewHash.AddDat(NodeH.GetKeyId(NId), value);
980    }
981    return 0;
982  } 
983  int TNEANet::AppendIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr, TBool UseDense) {
984    if (!IsNode(NId)) {
985      return -1;
986    }
987    TInt location = CheckDenseOrSparseN(attr);
988    if (location==-1) {
989      AddIntVAttrN(attr, UseDense);
990      location = CheckDenseOrSparseN(attr);
991    }
992    if (UseDense) {
993      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
994      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
995      NewVec[NodeH.GetKeyId(NId)].Add(value);
996    } else {
997      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
998      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
999      NewHash[NodeH.GetKeyId(NId)].Add(value);
1000    }
1001    return 0;
1002  } 
1003  int TNEANet::AppendFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr, TBool UseDense) {
1004    if (!IsNode(NId)) {
1005      return -1;
1006    }
1007    TInt location = CheckDenseOrSparseN(attr);
1008    if (location==-1) {
1009      AddFltVAttrN(attr, UseDense);
1010      location = CheckDenseOrSparseN(attr);
1011    }
1012    if (UseDense) {
1013      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
1014      TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1015      NewVec[NodeH.GetKeyId(NId)].Add(value);
1016    } else {
1017      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
1018      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1019      NewHash[NodeH.GetKeyId(NId)].Add(value);
1020    }
1021    return 0;
1022  } 
1023  int TNEANet::DelFromIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
1024    TInt CurrLen;
1025    if (!IsNode(NId)) {
1026      return -1;
1027    }
1028    TInt location = CheckDenseOrSparseN(attr);
1029    if (location != -1) {
1030      if (location == 1) {
1031        TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1032        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1033          return -1;
1034        }
1035      } else {
1036        THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1037        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1038          return -1;
1039        }
1040      }
1041    } else {
1042      return -1;
1043    }
1044    return 0;
1045  } 
1046  int TNEANet::DelFromFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
1047    TInt CurrLen;
1048    if (!IsNode(NId)) {
1049      return -1;
1050    }
1051    TInt location = CheckDenseOrSparseN(attr);
1052    if (location != -1) {
1053      if (location == 1) {
1054        TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1055        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1056          return -1;
1057        }
1058      } else {
1059        THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1060        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1061          return -1;
1062        }
1063      }
1064    } else {
1065      return -1;
1066    }
1067    return 0;
1068  }
1069  int TNEANet::AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr) {
1070    int i;
1071    TInt CurrLen;
1072    if (!IsNode(NId)) {
1073      return -1;
1074    }
1075    if (KeyToIndexTypeN.IsKey(attr)) {
1076      TVec<TStr>& NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1077      NewVec[NodeH.GetKeyId(NId)] = value;
1078    } else {
1079      CurrLen = VecOfStrVecsN.Len();
1080      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1081      TVec<TStr> NewVec = TVec<TStr>();
1082      for (i = 0; i < MxNId; i++) {
1083          NewVec.Ins(i, GetStrAttrDefaultN(attr));
1084      }
1085      NewVec[NodeH.GetKeyId(NId)] = value;
1086      VecOfStrVecsN.Add(NewVec);
1087    }
1088    return 0;
1089  } 
1090  int TNEANet::AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
1091    int i;
1092    TInt CurrLen;
1093    if (!IsNode(NId)) {
1094      return -1;
1095    }
1096    if (KeyToIndexTypeN.IsKey(attr)) {
1097      TVec<TFlt>& NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1098      NewVec[NodeH.GetKeyId(NId)] = value;
1099    } else {
1100      CurrLen = VecOfFltVecsN.Len();
1101      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1102      TVec<TFlt> NewVec = TVec<TFlt>();
1103      for (i = 0; i < MxNId; i++) {
1104        NewVec.Ins(i, GetFltAttrDefaultN(attr));
1105      }
1106      NewVec[NodeH.GetKeyId(NId)] = value;
1107      VecOfFltVecsN.Add(NewVec);
1108    }
1109    return 0;
1110  } 
1111  int TNEANet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
1112    int i;
1113    TInt CurrLen;
1114    if (!IsEdge(EId)) {
1115       return -1;
1116    }
1117    if (KeyToIndexTypeE.IsKey(attr)) {
1118      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1119      NewVec[EdgeH.GetKeyId(EId)] = value;
1120    } else {
1121      CurrLen = VecOfIntVecsE.Len();
1122      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1123      TVec<TInt> NewVec = TVec<TInt>();
1124      for (i = 0; i < MxEId; i++) {
1125        NewVec.Ins(i, GetIntAttrDefaultE(attr));
1126      }
1127      NewVec[EdgeH.GetKeyId(EId)] = value;
1128      VecOfIntVecsE.Add(NewVec);
1129    }
1130    return 0;
1131  }
1132  int TNEANet::AddIntVAttrDatE(const int& EId, const TIntV& value, const TStr& attr, TBool UseDense) {
1133    if (!IsEdge(EId)) {
1134      return -1;
1135    }
1136    TInt location = CheckDenseOrSparseE(attr);
1137    if (location==-1) {
1138      AddIntVAttrE(attr, UseDense);
1139      location = CheckDenseOrSparseE(attr);
1140    }
1141    if (UseDense) {
1142      IAssertR(location != 0, TStr::Fmt("EdgeID %d exists for %s in sparse representation", EId, attr.CStr()));
1143      TVec<TIntV>& NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1144      NewVec[EdgeH.GetKeyId(EId)] = value;
1145    } else {
1146      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", EId, attr.CStr()));
1147      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1148      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1149    }
1150    return 0;
1151  } 
1152  int TNEANet::AddFltVAttrDatE(const int& EId, const TFltV& value, const TStr& attr, TBool UseDense) {
1153    if (!IsEdge(EId)) {
1154      return -1;
1155    }
1156    TInt location = CheckDenseOrSparseE(attr);
1157    if (location==-1) {
1158      AddFltVAttrE(attr, UseDense);
1159      location = CheckDenseOrSparseE(attr);
1160    }
1161    if (UseDense) {
1162      IAssertR(location != 0, TStr::Fmt("EdgeID %d exists for %s in sparse representation", EId, attr.CStr()));
1163      TVec<TFltV>& NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1164      NewVec[EdgeH.GetKeyId(EId)] = value;
1165    } else {
1166      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", EId, attr.CStr()));
1167      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1168      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1169    }
1170    return 0;
1171  } 
1172  int TNEANet::AppendIntVAttrDatE(const int& EId, const TInt& value, const TStr& attr, TBool UseDense) {
1173    if (!IsEdge(EId)) {
1174      return -1;
1175    }
1176    TInt location = CheckDenseOrSparseE(attr);
1177    if (location==-1) return -1;
1178    if (UseDense) {
1179      IAssertR(location != 0, TStr::Fmt("Edge %d exists for %s in sparse representation", EId, attr.CStr()));
1180      TVec<TIntV>& NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1181      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1182    } else {
1183      IAssertR(location != 1, TStr::Fmt("Edge %d exists for %s in dense representation", EId, attr.CStr()));
1184      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1185      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1186    }
1187    return 0;
1188  }
1189  int TNEANet::AppendFltVAttrDatE(const int& EId, const TFlt& value, const TStr& attr, TBool UseDense) {
1190    if (!IsEdge(EId)) {
1191      return -1;
1192    }
1193    TInt location = CheckDenseOrSparseE(attr);
1194    if (location==-1) return -1;
1195    if (UseDense) {
1196      IAssertR(location != 0, TStr::Fmt("Edge %d exists for %s in sparse representation", EId, attr.CStr()));
1197      TVec<TFltV>& NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1198      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1199    } else {
1200      IAssertR(location != 1, TStr::Fmt("Edge %d exists for %s in dense representation", EId, attr.CStr()));
1201      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1202      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1203    }
1204    return 0;
1205  }
1206  int TNEANet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
1207    int i;
1208    TInt CurrLen;
1209    if (!IsEdge(EId)) {
1210       return -1;
1211    }
1212    if (KeyToIndexTypeE.IsKey(attr)) {
1213      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1214      NewVec[EdgeH.GetKeyId(EId)] = value;
1215    } else {
1216      CurrLen = VecOfStrVecsE.Len();
1217      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1218      TVec<TStr> NewVec = TVec<TStr>();
1219      for (i = 0; i < MxEId; i++) {
1220        NewVec.Ins(i, GetStrAttrDefaultE(attr));
1221      }
1222      NewVec[EdgeH.GetKeyId(EId)] = value;
1223      VecOfStrVecsE.Add(NewVec);
1224    }
1225    return 0;
1226  } 
1227  int TNEANet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
1228    int i;
1229    TInt CurrLen;
1230    if (!IsEdge(EId)) {
1231       return -1;
1232    }
1233    if (KeyToIndexTypeE.IsKey(attr)) {
1234      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1235      NewVec[EdgeH.GetKeyId(EId)] = value;
1236    } else {
1237      CurrLen = VecOfFltVecsE.Len();
1238      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1239      TVec<TFlt> NewVec = TVec<TFlt>();
1240      for (i = 0; i < MxEId; i++) {
1241        NewVec.Ins(i, GetFltAttrDefaultE(attr));
1242      }
1243      NewVec[EdgeH.GetKeyId(EId)] = value;
1244      VecOfFltVecsE.Add(NewVec);
1245    }
1246    return 0;
1247  }
1248  TVec<TFlt>& TNEANet::GetFltAttrVecE(const TStr& attr) {
1249    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1250  }
1251  int TNEANet::GetFltKeyIdE(const int& EId) {
1252    return EdgeH.GetKeyId(EId);
1253  }
1254  TInt TNEANet::GetIntAttrDatN(const int& NId, const TStr& attr) {
1255    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1256  }
1257  TIntV TNEANet::GetIntVAttrDatN(const int& NId, const TStr& attr) const {
1258    TInt location = CheckDenseOrSparseN(attr);
1259    if (location != 0) return VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1260    else return VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1261  }
1262  TFltV TNEANet::GetFltVAttrDatN(const int& NId, const TStr& attr) const {
1263    TInt location = CheckDenseOrSparseN(attr);
1264    if (location != 0) return VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1265    else return VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1266  }
1267  TStr TNEANet::GetStrAttrDatN(const int& NId, const TStr& attr) {
1268    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1269  }
1270  TFlt TNEANet::GetFltAttrDatN(const int& NId, const TStr& attr) {
1271    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1272  }
1273  TInt TNEANet::GetIntAttrIndDatN(const int& NId, const int& index) {
1274    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
1275  }
1276  TStr TNEANet::GetStrAttrIndDatN(const int& NId, const int& index) {
1277    return VecOfStrVecsN[index][NodeH.GetKeyId(NId)];
1278  }
1279  TFlt TNEANet::GetFltAttrIndDatN(const int& NId, const int& index) {
1280    return VecOfFltVecsN[index][NodeH.GetKeyId(NId)];
1281  }
1282  int TNEANet::GetIntAttrIndN(const TStr& attr) {
1283    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1284  }
1285  int TNEANet::GetAttrIndN(const TStr& attr) {
1286    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1287  }
1288  TInt TNEANet::GetIntAttrDatE(const int& EId, const TStr& attr) {
1289    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1290  }
1291  TIntV TNEANet::GetIntVAttrDatE(const int& EId, const TStr& attr) {
1292    TInt location = CheckDenseOrSparseE(attr);
1293    if (location != 0) return VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1294    else return VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1295  }
1296  TFltV TNEANet::GetFltVAttrDatE(const int& EId, const TStr& attr) {
1297    TInt location = CheckDenseOrSparseE(attr);
1298    if (location != 0) return VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1299    else return VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1300  }
1301  TStr TNEANet::GetStrAttrDatE(const int& EId, const TStr& attr) {
1302    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1303  }
1304  TFlt TNEANet::GetFltAttrDatE(const int& EId, const TStr& attr) {
1305    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1306  }
1307  TInt TNEANet::GetIntAttrIndDatE(const int& EId, const int& index) {
1308    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
1309  }
1310  TStr TNEANet::GetStrAttrIndDatE(const int& EId, const int& index) {
1311    return VecOfStrVecsE[index][EdgeH.GetKeyId(EId)];
1312  }
1313  TFlt TNEANet::GetFltAttrIndDatE(const int& EId, const int& index) {
1314    return VecOfFltVecsE[index][EdgeH.GetKeyId(EId)];
1315  }
1316  int TNEANet::GetIntAttrIndE(const TStr& attr) {
1317    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1318  }
1319  int TNEANet::GetAttrIndE(const TStr& attr) {
1320    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1321  }
1322  int TNEANet::DelAttrDatN(const int& NId, const TStr& attr) {
1323    TInt vecType = KeyToIndexTypeN(attr).Val1;
1324    if (vecType == IntType) {
1325      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
1326    } else if (vecType == StrType) {
1327      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
1328    } else if (vecType == FltType) {
1329      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
1330    } else if (vecType ==IntVType) {
1331      TInt location = CheckDenseOrSparseN(attr);
1332      if (location == 0) VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1333      else VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1334    } else if (vecType == FltVType) { 
1335      TInt location = CheckDenseOrSparseN(attr);
1336      if (location == 0) VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1337      else VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1338    } else {
1339      return -1;
1340    }
1341    return 0;
1342  }
1343  int TNEANet::DelAttrDatE(const int& EId, const TStr& attr) {
1344    TInt vecType = KeyToIndexTypeE(attr).Val1;
1345    if (vecType == IntType) {
1346      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
1347    } else if (vecType == StrType) {
1348      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
1349    } else if (vecType == FltType) {
1350      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
1351    } else if (vecType == IntVType) {
1352      TInt location = CheckDenseOrSparseE(attr);
1353      if (location == 0) VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1354      else VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1355    } else if (vecType == FltVType) {
1356      TInt location = CheckDenseOrSparseE(attr);
1357      if (location == 0) VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1358      else VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1359    } else {
1360      return -1;
1361    }
1362    return 0;
1363  }
1364  int TNEANet::AddIntAttrN(const TStr& attr, TInt defaultValue){
1365    int i;
1366    TInt CurrLen;
1367    TVec<TInt> NewVec;
1368    CurrLen = VecOfIntVecsN.Len();
1369    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
1370    NewVec = TVec<TInt>();
1371    for (i = 0; i < MxNId; i++) {
1372      NewVec.Ins(i, defaultValue);
1373    }
1374    VecOfIntVecsN.Add(NewVec);
1375    if (!IntDefaultsN.IsKey(attr)) {
1376      IntDefaultsN.AddDat(attr, defaultValue);
1377    } else {
1378      return -1;
1379    }
1380    return 0;
1381  }
1382  int TNEANet::AddIntVAttrN(const TStr& attr, TBool UseDense){
1383    TInt CurrLen;
1384    if (UseDense) {
1385      CurrLen = VecOfIntVecVecsN.Len();
1386      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1387      KeyToDenseN.AddDat(attr, true);
1388      TVec<TIntV> NewVec = TVec<TIntV>(MxNId);
1389      VecOfIntVecVecsN.Add(NewVec);
1390    } else {
1391      CurrLen = VecOfIntHashVecsN.Len();
1392      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1393      KeyToDenseN.AddDat(attr, false);
1394      THash<TInt, TIntV> NewHash;
1395      VecOfIntHashVecsN.Add(NewHash);
1396    }
1397    return 0;
1398  }
1399  int TNEANet::AddFltVAttrN(const TStr& attr, TBool UseDense){
1400    TInt CurrLen;
1401    if (UseDense) {
1402      CurrLen = VecOfFltVecVecsN.Len();
1403      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1404      KeyToDenseN.AddDat(attr, true);
1405      TVec<TFltV> NewVec = TVec<TFltV>(MxNId);
1406      VecOfFltVecVecsN.Add(NewVec);
1407    } else {
1408      CurrLen = VecOfFltHashVecsN.Len();
1409      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1410      KeyToDenseN.AddDat(attr, false);
1411      THash<TInt, TFltV> NewHash;
1412      VecOfFltHashVecsN.Add(NewHash);
1413    }
1414    return 0;
1415  }
1416  int TNEANet::AddStrAttrN(const TStr& attr, TStr defaultValue) {
1417    int i;
1418    TInt CurrLen;
1419    TVec<TStr> NewVec;
1420    CurrLen = VecOfStrVecsN.Len();
1421    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1422    NewVec = TVec<TStr>();
1423    for (i = 0; i < MxNId; i++) {
1424      NewVec.Ins(i, defaultValue);
1425    }
1426    VecOfStrVecsN.Add(NewVec);
1427    if (!StrDefaultsN.IsKey(attr)) {
1428      StrDefaultsN.AddDat(attr, defaultValue);
1429    } else {
1430      return -1;
1431    }
1432    return 0;
1433  }
1434  int TNEANet::AddFltAttrN(const TStr& attr, TFlt defaultValue) {
1435    int i;
1436    TInt CurrLen;
1437    TVec<TFlt> NewVec;
1438    CurrLen = VecOfFltVecsN.Len();
1439    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1440    NewVec = TVec<TFlt>();
1441    for (i = 0; i < MxNId; i++) {
1442      NewVec.Ins(i, defaultValue);
1443    }
1444    VecOfFltVecsN.Add(NewVec);
1445    if (!FltDefaultsN.IsKey(attr)) {
1446      FltDefaultsN.AddDat(attr, defaultValue);
1447    } else {
1448      return -1;
1449    }
1450    return 0;
1451  }
1452  int TNEANet::AddIntAttrE(const TStr& attr, TInt defaultValue){
1453    int i;
1454    TInt CurrLen;
1455    TVec<TInt> NewVec;
1456    CurrLen = VecOfIntVecsE.Len();
1457    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1458    NewVec = TVec<TInt>();
1459    for (i = 0; i < MxEId; i++) {
1460      NewVec.Ins(i, defaultValue);
1461    }
1462    VecOfIntVecsE.Add(NewVec);
1463    if (!IntDefaultsE.IsKey(attr)) {
1464      IntDefaultsE.AddDat(attr, defaultValue);
1465    } else {
1466      return -1;
1467    }
1468    return 0;
1469  }
1470  int TNEANet::AddIntVAttrE(const TStr& attr, TBool UseDense){
1471    TInt CurrLen;
1472    if (UseDense) {
1473      CurrLen = VecOfIntVecVecsE.Len();
1474      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1475      KeyToDenseE.AddDat(attr, true);
1476      TVec<TIntV> NewVec = TVec<TIntV>(MxEId);
1477      VecOfIntVecVecsE.Add(NewVec);
1478    } else {
1479      CurrLen = VecOfIntHashVecsE.Len();
1480      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1481      KeyToDenseE.AddDat(attr, false);
1482      THash<TInt, TIntV> NewHash;
1483      VecOfIntHashVecsE.Add(NewHash);
1484    }
1485    return 0;
1486  }
1487  int TNEANet::AddFltVAttrE(const TStr& attr, TBool UseDense){
1488    TInt CurrLen;
1489    if (UseDense) {
1490      CurrLen = VecOfFltVecVecsE.Len();
1491      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1492      KeyToDenseE.AddDat(attr, true);
1493      TVec<TFltV> NewVec = TVec<TFltV>(MxEId);
1494      VecOfFltVecVecsE.Add(NewVec);
1495    } else {
1496      CurrLen = VecOfFltHashVecsE.Len();
1497      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1498      KeyToDenseE.AddDat(attr, false);
1499      THash<TInt, TFltV> NewHash;
1500      VecOfFltHashVecsE.Add(NewHash);
1501    }
1502    return 0;
1503  }
1504  int TNEANet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
1505    int i;
1506    TInt CurrLen;
1507    TVec<TStr> NewVec;
1508    CurrLen = VecOfStrVecsE.Len();
1509    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1510    NewVec = TVec<TStr>();
1511    for (i = 0; i < MxEId; i++) {
1512      NewVec.Ins(i, defaultValue);
1513    }
1514    VecOfStrVecsE.Add(NewVec);
1515    if (!StrDefaultsE.IsKey(attr)) {
1516      StrDefaultsE.AddDat(attr, defaultValue);
1517    } else {
1518      return -1;
1519    }
1520    return 0;
1521  }
1522  int TNEANet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
1523    int i;
1524    TInt CurrLen;
1525    TVec<TFlt> NewVec;
1526    CurrLen = VecOfFltVecsE.Len();
1527    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1528    NewVec = TVec<TFlt>();
1529    for (i = 0; i < MxEId; i++) {
1530      NewVec.Ins(i, defaultValue);
1531    }
1532    VecOfFltVecsE.Add(NewVec);
1533    if (!FltDefaultsE.IsKey(attr)) {
1534      FltDefaultsE.AddDat(attr, defaultValue);
1535    } else {
1536      return -1;
1537    }
1538    return 0;
1539  }
1540  int TNEANet::DelAttrN(const TStr& attr) {
1541    TInt vecType = KeyToIndexTypeN(attr).Val1;
1542    if (vecType == IntType) {
1543      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TInt>();
1544      if (IntDefaultsN.IsKey(attr)) {
1545        IntDefaultsN.DelKey(attr);
1546      }
1547    } else if (vecType == StrType) {
1548      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TStr>();  
1549      if (StrDefaultsN.IsKey(attr)) {
1550        StrDefaultsN.DelKey(attr);
1551      }
1552    } else if (vecType == FltType) {
1553      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TFlt>();
1554      if (FltDefaultsN.IsKey(attr)) {
1555        FltDefaultsN.DelKey(attr);
1556      }
1557    } else if (vecType == IntVType) {
1558      TInt location = CheckDenseOrSparseN(attr);
1559      if (location == 1) VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TIntV>();
1560      else VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash<TInt, TIntV>();
1561      KeyToDenseN.DelKey(attr);
1562    } else if (vecType == FltVType) {
1563      TInt location = CheckDenseOrSparseN(attr);
1564      if (location == 1) VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TFltV>();
1565      else VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash<TInt, TFltV>();
1566      KeyToDenseN.DelKey(attr);
1567    } else {
1568      return -1;
1569    }
1570    KeyToIndexTypeN.DelKey(attr);
1571    return 0;
1572  }
1573  int TNEANet::DelAttrE(const TStr& attr) {
1574    TInt vecType = KeyToIndexTypeE(attr).Val1;
1575    if (vecType == IntType) {
1576      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
1577      if (IntDefaultsE.IsKey(attr)) {
1578        IntDefaultsE.DelKey(attr);
1579      }
1580    } else if (vecType == StrType) {
1581      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
1582      if (StrDefaultsE.IsKey(attr)) {
1583        StrDefaultsE.DelKey(attr);
1584      }  
1585    } else if (vecType == FltType) {
1586      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
1587      if (FltDefaultsE.IsKey(attr)) {
1588        FltDefaultsE.DelKey(attr);
1589      }
1590    } else {
1591      return -1;
1592    }
1593    KeyToIndexTypeE.DelKey(attr);
1594    return 0;
1595  }
1596  PNEANet TNEANet::GetSmallGraph() {
1597    PNEANet Net = TNEANet::New();
1598    for (int i = 0; i < 5; i++) { Net->AddNode(i); }
1599    Net->AddEdge(0,1);  Net->AddEdge(0,2);
1600    Net->AddEdge(0,3);  Net->AddEdge(0,4);
1601    Net->AddEdge(1,2);  Net->AddEdge(1,2);
1602    return Net;
1603  }
1604  void TNEANet::GetAttrNNames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const {
1605    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
1606      if (it.GetDat().GetVal1() == IntType) {
1607        IntAttrNames.Add(it.GetKey());
1608      }
1609      if (it.GetDat().GetVal1() == FltType) {
1610        FltAttrNames.Add(it.GetKey());
1611      }
1612      if (it.GetDat().GetVal1() == StrType) {
1613        StrAttrNames.Add(it.GetKey());
1614      }
1615    }
1616  }
1617  void TNEANet::GetAttrENames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const {
1618    for (TStrIntPrH::TIter it = KeyToIndexTypeE.BegI(); it < KeyToIndexTypeE.EndI(); it++) {
1619      if (it.GetDat().GetVal1() == IntType) {
1620        IntAttrNames.Add(it.GetKey());
1621      }
1622      if (it.GetDat().GetVal1() == FltType) {
1623        FltAttrNames.Add(it.GetKey());
1624      }
1625      if (it.GetDat().GetVal1() == StrType) {
1626        StrAttrNames.Add(it.GetKey());
1627      }
1628    }
1629  }
1630  TFlt TNEANet::GetWeightOutEdges(const TNodeI& NI, const TStr& attr) {
1631    TNode Node = GetNode(NI.GetId());
1632    TIntV OutEIdV = Node.OutEIdV;
<span onclick='openModal()' class='match'>1633    TFlt total = 0;
1634    int len = Node.OutEIdV.Len();
1635    for (int i = 0; i < len; i++) {
1636      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
</span>1637    }
1638    return total;
1639  }
1640  void TNEANet::GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) {
1641    for (TEdgeI it = BegEI(); it < EndEI(); it++) {
1642      int EId = it.GetId();
1643      int SrcId = it.GetSrcNId();
1644      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
1645    }
1646  }
1647  bool TNEANet::IsFltAttrE(const TStr& attr) {
1648    return (KeyToIndexTypeE.IsKey(attr) &&
1649      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
1650  }
1651  bool TNEANet::IsIntAttrE(const TStr& attr) {
1652    return (KeyToIndexTypeE.IsKey(attr) &&
1653      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
1654  }
1655  bool TNEANet::IsStrAttrE(const TStr& attr) {
1656    return (KeyToIndexTypeE.IsKey(attr) &&
1657      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
1658  }
1659  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
1660    if (!IsNode(NId)) {
1661      return -1;
1662    }
1663    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1664  }
1665  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
1666    if (!IsNode(NId)) {
1667      return -1;
1668    }
1669    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1670  }
1671  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
1672    if (!IsNode(NId)) {
1673      return -1;
1674    }
1675    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1676  }
1677  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
1678    if (!IsNode(NId)) {
1679      return -1;
1680    }
1681    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1682  }
1683  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
1684    if (!IsNode(NId)) {
1685      return -1;
1686    }
1687    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1688  }
1689  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
1690    if (!IsNode(NId)) {
1691      return -1;
1692    }
1693    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1694  }
1695  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
1696    if (!IsNode(NId)) {
1697      return -1;
1698    }
1699    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1700  }
1701  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
1702    if (!IsNode(NId)) {
1703      return -1;
1704    }
1705    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1706  }
1707  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
1708    if (!IsNode(NId)) {
1709      return -1;
1710    }
1711    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1712  }
1713  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
1714    if (!IsNode(NId)) {
1715      return -1;
1716    }
1717    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1718  }
1719  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
1720    if (!IsNode(NId)) {
1721      return -1;
1722    }
1723    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1724  }
1725  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
1726    if (!IsNode(NId)) {
1727      return -1;
1728    }
1729    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1730  }
1731  int TNEANet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
1732    if (!IsNode(NId)) {
1733      return -1;
1734    }
1735    return SAttrN.DelSAttrDat(NId, AttrName);
1736  }
1737  int TNEANet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
1738    if (!IsNode(NId)) {
1739      return -1;
1740    }
1741    return SAttrN.DelSAttrDat(NId, AttrId);
1742  }
1743  int TNEANet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
1744    if (!IsNode(NId)) {
1745      return -1;
1746    }
1747    SAttrN.GetSAttrV(NId, AttrType, AttrV);
1748    return 0;
1749  }
1750  int TNEANet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
1751    return SAttrN.GetIdVSAttr(AttrName, IdV);
1752  }
1753  int TNEANet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
1754    return SAttrN.GetIdVSAttr(AttrId, IdV);
1755  }
1756  int TNEANet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
1757    return SAttrN.AddSAttr(Name, AttrType, AttrId);
1758  }
1759  int TNEANet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
1760    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
1761  }
1762  int TNEANet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
1763    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
1764  }
1765  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TInt& Val) {
1766    if (!IsEdge(EId)) {
1767      return -1;
1768    }
1769    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1770  }
1771  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TInt& Val) {
1772    if (!IsEdge(EId)) {
1773      return -1;
1774    }
1775    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1776  }
1777  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TFlt& Val) {
1778    if (!IsEdge(EId)) {
1779      return -1;
1780    }
1781    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1782  }
1783  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TFlt& Val) {
1784    if (!IsEdge(EId)) {
1785      return -1;
1786    }
1787    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1788  }
1789  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TStr& Val) {
1790    if (!IsEdge(EId)) {
1791      return -1;
1792    }
1793    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1794  }
1795  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TStr& Val) {
1796    if (!IsEdge(EId)) {
1797      return -1;
1798    }
1799    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1800  }
1801  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TInt& Val) const {
1802    if (!IsEdge(EId)) {
1803      return -1;
1804    }
1805    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1806  }
1807  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TInt& Val) const {
1808    if (!IsEdge(EId)) {
1809      return -1;
1810    }
1811    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1812  }
1813  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TFlt& Val) const {
1814    if (!IsEdge(EId)) {
1815      return -1;
1816    }
1817    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1818  }
1819  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TFlt& Val) const {
1820    if (!IsEdge(EId)) {
1821      return -1;
1822    }
1823    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1824  }
1825  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TStr& Val) const {
1826    if (!IsEdge(EId)) {
1827      return -1;
1828    }
1829    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1830  }
1831  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TStr& Val) const {
1832    if (!IsEdge(EId)) {
1833      return -1;
1834    }
1835    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1836  }
1837  int TNEANet::DelSAttrDatE(const TInt& EId, const TStr& AttrName) {
1838    if (!IsEdge(EId)) {
1839      return -1;
1840    }
1841    return SAttrE.DelSAttrDat(EId, AttrName);
1842  }
1843  int TNEANet::DelSAttrDatE(const TInt& EId, const TInt& AttrId) {
1844    if (!IsEdge(EId)) {
1845      return -1;
1846    }
1847    return SAttrE.DelSAttrDat(EId, AttrId);
1848  }
1849  int TNEANet::GetSAttrVE(const TInt& EId, const TAttrType AttrType, TAttrPrV& AttrV) const {
1850    if (!IsEdge(EId)) {
1851      return -1;
1852    }
1853    SAttrE.GetSAttrV(EId, AttrType, AttrV);
1854    return 0;
1855  }
1856  int TNEANet::GetIdVSAttrE(const TStr& AttrName, TIntV& IdV) const {
1857    return SAttrE.GetIdVSAttr(AttrName, IdV);
1858  }
1859  int TNEANet::GetIdVSAttrE(const TInt& AttrId, TIntV& IdV) const {
1860    return SAttrE.GetIdVSAttr(AttrId, IdV);
1861  }
1862  int TNEANet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
1863    return SAttrE.AddSAttr(Name, AttrType, AttrId);
1864  }
1865  int TNEANet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
1866    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
1867  }
1868  int TNEANet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
1869    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
1870  }
1871  bool TUndirNet::HasFlag(const TGraphFlag& Flag) const {
1872    return HasGraphFlag(TUndirNet::TNet, Flag);
1873  }
1874  int TUndirNet::AddNode(int NId) {
1875    if (NId == -1) {
1876      NId = MxNId;  MxNId++;
1877    } else {
1878      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1879      MxNId = TMath::Mx(NId+1, MxNId());
1880    }
1881    NodeH.AddDat(NId, TNode(NId));
1882    return NId;
1883  }
1884  int TUndirNet::AddNodeUnchecked(int NId) {
1885    if (NId == -1) {
1886      NId = MxNId;  MxNId++;
1887    } else {
1888      if (IsNode(NId)) { return -1;}
1889      MxNId = TMath::Mx(NId+1, MxNId());
1890    }
1891    NodeH.AddDat(NId, TNode(NId));
1892    return NId;
1893  }
1894  int TUndirNet::AddNode(const int& NId, const TIntV& NbrNIdV) {
1895    int NewNId;
1896    if (NId == -1) {
1897      NewNId = MxNId;  MxNId++;
1898    } else {
1899      IAssertR(! IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1900      NewNId = NId;
1901      MxNId = TMath::Mx(NewNId+1, MxNId());
1902    }
1903    TNode& Node = NodeH.AddDat(NewNId);
1904    Node.Id = NewNId;
1905    Node.NIdV = NbrNIdV;
1906    Node.NIdV.Sort();
1907    NEdges += Node.GetDeg();
1908    for (int i = 0; i < NbrNIdV.Len(); i++) {
1909      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
1910    }
1911    return NewNId;
1912  }
1913  int TUndirNet::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId) {
1914    int NewNId;
1915    if (NId == -1) {
1916      NewNId = MxNId;  MxNId++;
1917    } else {
1918      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1919      NewNId = NId;
1920      MxNId = TMath::Mx(NewNId+1, MxNId()); 
1921    }
1922    TNode& Node = NodeH.AddDat(NewNId);
1923    Node.Id = NewNId;
1924    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
1925    Node.NIdV.Sort();
1926    NEdges += Node.GetDeg();
1927    return NewNId;
1928  }
1929  void TUndirNet::DelNode(const int& NId) {
1930    { AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
1931    TInt Id(NId);
1932    SAttrN.DelSAttrId(Id);
1933    TNode& Node = GetNode(NId);
1934    NEdges -= Node.GetDeg();
1935    for (int e = 0; e < Node.GetDeg(); e++) {
1936      const int nbr = Node.GetNbrNId(e);
1937      if (nbr == NId) { continue; }
1938      TNode& N = GetNode(nbr);
1939      const int n = N.NIdV.SearchBin(NId);
1940      IAssert(n != -1); 
1941      if (n!= -1) { N.NIdV.Del(n); }
1942    } }
1943    NodeH.DelKey(NId);
1944  }
1945  int TUndirNet::GetEdges() const {
1946    return NEdges;
1947  }
1948  int TUndirNet::AddEdge(const int& SrcNId, const int& DstNId) {
1949    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1950    if (IsEdge(SrcNId, DstNId)) { return -2; } 
1951    GetNode(SrcNId).NIdV.AddSorted(DstNId);
1952    if (SrcNId!=DstNId) { 
1953      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
1954    NEdges++;
1955    return -1; 
1956  }
1957  int TUndirNet::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
1958    GetNode(SrcNId).NIdV.Add(DstNId);
1959    if (SrcNId!=DstNId) { 
1960      GetNode(DstNId).NIdV.Add(SrcNId); }
1961    NEdges++;
1962    return -1; 
1963  }
1964  void TUndirNet::DelEdge(const int& SrcNId, const int& DstNId) {
1965    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1966    { TNode& N = GetNode(SrcNId);
1967    const int n = N.NIdV.SearchBin(DstNId);
1968    TIntPr Id(SrcNId, DstNId);
1969    SAttrE.DelSAttrId(Id);
1970    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
1971    if (SrcNId != DstNId) { 
1972      TNode& N = GetNode(DstNId);
1973      const int n = N.NIdV.SearchBin(SrcNId);
1974      if (n!= -1) { N.NIdV.Del(n); }
1975    }
1976  }
1977  bool TUndirNet::IsEdge(const int& SrcNId, const int& DstNId) const {
1978    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
1979    return GetNode(SrcNId).IsNbrNId(DstNId);
1980  }
1981  TUndirNet::TEdgeI TUndirNet::GetEI(const int& SrcNId, const int& DstNId) const {
1982    const int MnNId = TMath::Mn(SrcNId, DstNId);
1983    const int MxNId = TMath::Mx(SrcNId, DstNId);
1984    const TNodeI SrcNI = GetNI(MnNId);
1985    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
1986    IAssert(NodeN != -1);
1987    return TEdgeI(SrcNI, EndNI(), NodeN);
1988  }
1989  void TUndirNet::GetNIdV(TIntV& NIdV) const {
1990    NIdV.Gen(GetNodes(), 0);
1991    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1992      NIdV.Add(NodeH.GetKey(N)); }
1993  }
1994  void TUndirNet::Defrag(const bool& OnlyNodeLinks) {
1995    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
1996      NodeH[n].NIdV.Pack();
1997    }
1998    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
1999      NodeH.Defrag();
2000    }
2001  }
2002  bool TUndirNet::IsOk(const bool& ThrowExcept) const {
2003    bool RetVal = true;
2004    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2005      const TNode& Node = NodeH[N];
2006      if (! Node.NIdV.IsSorted()) {
2007        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", Node.GetId());
2008        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2009        RetVal=false;
2010      }
2011      int prevNId = -1;
2012      for (int e = 0; e < Node.GetDeg(); e++) {
2013        if (! IsNode(Node.GetNbrNId(e))) {
2014          const TStr Msg = TStr::Fmt("Edge %d --> %d: node %d does not exist.",
2015            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
2016          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2017          RetVal=false;
2018        }
2019        if (e > 0 && prevNId == Node.GetNbrNId(e)) {
2020          const TStr Msg = TStr::Fmt("Node %d has duplicate edge %d --> %d.",
2021            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
2022          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2023          RetVal=false;
2024        }
2025        prevNId = Node.GetNbrNId(e);
2026      }
2027    }
2028    int EdgeCnt = 0;
2029    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) { EdgeCnt++; }
2030    if (EdgeCnt != GetEdges()) {
2031      const TStr Msg = TStr::Fmt("Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.", GetEdges(), EdgeCnt);
2032      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2033      RetVal=false;
2034    }
2035    return RetVal;
2036  }
2037  void TUndirNet::Dump(FILE *OutF) const {
2038    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2039    fprintf(OutF, "-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
2040    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2041      const TNode& Node = NodeH[N];
2042      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
2043      for (int edge = 0; edge < Node.GetDeg(); edge++) {
2044        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
2045      fprintf(OutF, "\n");
2046    }
2047    fprintf(OutF, "\n");
2048  }
2049  PUndirNet TUndirNet::GetSmallGraph() {
2050    PUndirNet Graph = TUndirNet::New();
2051    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
2052    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
2053    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
2054    Graph->AddEdge(1,2);
2055    return Graph;
2056  }
2057  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
2058    if (!IsNode(NId)) {
2059      return -1;
2060    }
2061    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2062  }
2063  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
2064    if (!IsNode(NId)) {
2065      return -1;
2066    }
2067    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2068  }
2069  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
2070    if (!IsNode(NId)) {
2071      return -1;
2072    }
2073    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2074  }
2075  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
2076    if (!IsNode(NId)) {
2077      return -1;
2078    }
2079    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2080  }
2081  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
2082    if (!IsNode(NId)) {
2083      return -1;
2084    }
2085    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2086  }
2087  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
2088    if (!IsNode(NId)) {
2089      return -1;
2090    }
2091    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2092  }
2093  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
2094    if (!IsNode(NId)) {
2095      return -1;
2096    }
2097    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2098  }
2099  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
2100    if (!IsNode(NId)) {
2101      return -1;
2102    }
2103    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2104  }
2105  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
2106    if (!IsNode(NId)) {
2107      return -1;
2108    }
2109    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2110  }
2111  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
2112    if (!IsNode(NId)) {
2113      return -1;
2114    }
2115    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2116  }
2117  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
2118    if (!IsNode(NId)) {
2119      return -1;
2120    }
2121    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2122  }
2123  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
2124    if (!IsNode(NId)) {
2125      return -1;
2126    }
2127    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2128  }
2129  int TUndirNet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
2130    if (!IsNode(NId)) {
2131      return -1;
2132    }
2133    return SAttrN.DelSAttrDat(NId, AttrName);
2134  }
2135  int TUndirNet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
2136    if (!IsNode(NId)) {
2137      return -1;
2138    }
2139    return SAttrN.DelSAttrDat(NId, AttrId);
2140  }
2141  int TUndirNet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2142    if (!IsNode(NId)) {
2143      return -1;
2144    }
2145    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2146    return 0;
2147  }
2148  int TUndirNet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
2149    return SAttrN.GetIdVSAttr(AttrName, IdV);
2150  }
2151  int TUndirNet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
2152    return SAttrN.GetIdVSAttr(AttrId, IdV);
2153  }
2154  int TUndirNet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2155    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2156  }
2157  int TUndirNet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2158    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2159  }
2160  int TUndirNet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2161    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2162  }
2163  TIntPr TUndirNet::OrderEdgeNodes(const int& SrcNId, const int& DstNId) const{
2164    if (SrcNId < DstNId) {
2165      return TIntPr(SrcNId, DstNId);
2166    }
2167    return TIntPr(DstNId, SrcNId);
2168  }
2169  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val) {
2170    if (!IsEdge(SrcNId, DstNId)) {
2171      return -1;
2172    }
2173    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2174    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2175  }
2176  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val) {
2177    if (!IsEdge(SrcNId, DstNId)) {
2178      return -1;
2179    }
2180    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2181    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2182  }
2183  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val) {
2184    if (!IsEdge(SrcNId, DstNId)) {
2185      return -1;
2186    }
2187    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2188    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2189  }
2190  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val) {
2191    if (!IsEdge(SrcNId, DstNId)) {
2192      return -1;
2193    }
2194    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2195    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2196  }
2197  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val) {
2198    if (!IsEdge(SrcNId, DstNId)) {
2199      return -1;
2200    }
2201    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2202    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2203  }
2204  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val) {
2205    if (!IsEdge(SrcNId, DstNId)) {
2206      return -1;
2207    }
2208    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2209    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2210  }
2211  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& Val) const {
2212    if (!IsEdge(SrcNId, DstNId)) {
2213      return -1;
2214    }
2215    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2216    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2217  }
2218  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& Val) const {
2219    if (!IsEdge(SrcNId, DstNId)) {
2220      return -1;
2221    }
2222    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2223    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2224  }
2225  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& Val) const {
2226    if (!IsEdge(SrcNId, DstNId)) {
2227      return -1;
2228    }
2229    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2230    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2231  }
2232  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& Val) const {
2233    if (!IsEdge(SrcNId, DstNId)) {
2234      return -1;
2235    }
2236    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2237    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2238  }
2239  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& Val) const {
2240    if (!IsEdge(SrcNId, DstNId)) {
2241      return -1;
2242    }
2243    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2244    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2245  }
2246  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& Val) const {
2247    if (!IsEdge(SrcNId, DstNId)) {
2248      return -1;
2249    }
2250    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2251    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2252  }
2253  int TUndirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName) {
2254    if (!IsEdge(SrcNId, DstNId)) {
2255      return -1;
2256    }
2257    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2258    return SAttrE.DelSAttrDat(EId, AttrName);
2259  }
2260  int TUndirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId) {
2261    if (!IsEdge(SrcNId, DstNId)) {
2262      return -1;
2263    }
2264    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2265    return SAttrE.DelSAttrDat(EId, AttrId);
2266  }
2267  int TUndirNet::GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2268    if (!IsEdge(SrcNId, DstNId)) {
2269      return -1;
2270    }
2271    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2272    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2273    return 0;
2274  }
2275  int TUndirNet::GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const {
2276    return SAttrE.GetIdVSAttr(AttrName, IdV);
2277  }
2278  int TUndirNet::GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const {
2279    return SAttrE.GetIdVSAttr(AttrId, IdV);
2280  }
2281  int TUndirNet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2282    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2283  }
2284  int TUndirNet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2285    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2286  }
2287  int TUndirNet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2288    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2289  }
2290  bool TDirNet::HasFlag(const TGraphFlag& Flag) const {
2291    return HasGraphFlag(TDirNet::TNet, Flag);
2292  }
2293  int TDirNet::AddNode(int NId) {
2294    if (NId == -1) {
2295      NId = MxNId;  MxNId++;
2296    } else {
2297      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2298      MxNId = TMath::Mx(NId+1, MxNId());
2299    }
2300    NodeH.AddDat(NId, TNode(NId));
2301    return NId;
2302  }
2303  int TDirNet::AddNodeUnchecked(int NId) {
2304    if (NId == -1) {
2305      NId = MxNId;  MxNId++;
2306    } else {
2307      if (IsNode(NId)) { return -1;}
2308      MxNId = TMath::Mx(NId+1, MxNId());
2309    }
2310    NodeH.AddDat(NId, TNode(NId));
2311    return NId;
2312  }
2313  int TDirNet::AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
2314    int NewNId;
2315    if (NId == -1) {
2316      NewNId = MxNId;  MxNId++;
2317    } else {
2318      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2319      NewNId = NId;
2320      MxNId = TMath::Mx(NewNId+1, MxNId());
2321    }
2322    TNode& Node = NodeH.AddDat(NewNId);
2323    Node.Id = NewNId;
2324    Node.InNIdV = InNIdV;
2325    Node.OutNIdV = OutNIdV;
2326    Node.InNIdV.Sort();
2327    Node.OutNIdV.Sort();
2328    return NewNId;
2329  }
2330  int TDirNet::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
2331    int NewNId;
2332    if (NId == -1) {
2333      NewNId = MxNId;  MxNId++;
2334    } else {
2335      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2336      NewNId = NId;
2337      MxNId = TMath::Mx(NewNId+1, MxNId());
2338    }
2339    TNode& Node = NodeH.AddDat(NewNId);
2340    Node.Id = NewNId;
2341    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
2342    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
2343    Node.InNIdV.Sort();
2344    Node.OutNIdV.Sort();
2345    return NewNId;
2346  }
2347  void TDirNet::DelNode(const int& NId) {
2348    { TNode& Node = GetNode(NId);
2349    TInt Id(NId);
2350    SAttrN.DelSAttrId(Id);
2351    for (int e = 0; e < Node.GetOutDeg(); e++) {
2352    const int nbr = Node.GetOutNId(e);
2353    if (nbr == NId) { continue; }
2354      TNode& N = GetNode(nbr);
2355      const int n = N.InNIdV.SearchBin(NId);
2356      if (n!= -1) { N.InNIdV.Del(n); }
2357    }
2358    for (int e = 0; e < Node.GetInDeg(); e++) {
2359    const int nbr = Node.GetInNId(e);
2360    if (nbr == NId) { continue; }
2361      TNode& N = GetNode(nbr);
2362      const int n = N.OutNIdV.SearchBin(NId);
2363      if (n!= -1) { N.OutNIdV.Del(n); }
2364    } }
2365    NodeH.DelKey(NId);
2366  }
2367  int TDirNet::GetEdges() const {
2368    int edges=0;
2369    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2370      edges+=NodeH[N].GetOutDeg();
2371    }
2372    return edges;
2373  }
2374  int TDirNet::AddEdge(const int& SrcNId, const int& DstNId) {
2375    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
2376    if (IsEdge(SrcNId, DstNId)) { return -2; }
2377    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
2378    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
2379    return -1; 
2380  }
2381  int TDirNet::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
2382    GetNode(SrcNId).OutNIdV.Add(DstNId);
2383    GetNode(DstNId).InNIdV.Add(SrcNId);
2384    return -1; 
2385  }
2386  void TDirNet::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
2387    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
2388    { TNode& N = GetNode(SrcNId);
2389    TIntPr Id(SrcNId, DstNId);
2390    SAttrE.DelSAttrId(Id);
2391    const int n = N.OutNIdV.SearchBin(DstNId);
2392    if (n!= -1) { N.OutNIdV.Del(n); } }
2393    { TNode& N = GetNode(DstNId);
2394    const int n = N.InNIdV.SearchBin(SrcNId);
2395    if (n!= -1) { N.InNIdV.Del(n); } }
2396    if (! IsDir) {
2397      { TNode& N = GetNode(SrcNId);
2398      const int n = N.InNIdV.SearchBin(DstNId);
2399      if (n!= -1) { N.InNIdV.Del(n); } }
2400      { TNode& N = GetNode(DstNId);
2401      const int n = N.OutNIdV.SearchBin(SrcNId);
2402      if (n!= -1) { N.OutNIdV.Del(n); } }
2403    }
2404  }
2405  bool TDirNet::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
2406    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
2407    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
2408    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
2409  }
2410  TDirNet::TEdgeI TDirNet::GetEI(const int& SrcNId, const int& DstNId) const {
2411    const TNodeI SrcNI = GetNI(SrcNId);
2412    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
2413    IAssert(NodeN != -1);
2414    return TEdgeI(SrcNI, EndNI(), NodeN);
2415  }
2416  void TDirNet::GetNIdV(TIntV& NIdV) const {
2417    NIdV.Gen(GetNodes(), 0);
2418    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2419      NIdV.Add(NodeH.GetKey(N)); }
2420  }
2421  void TDirNet::Defrag(const bool& OnlyNodeLinks) {
2422    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
2423      TNode& Node = NodeH[n];
2424      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
2425    }
2426    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
2427  }
2428  bool TDirNet::IsOk(const bool& ThrowExcept) const {
2429    bool RetVal = true;
2430    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2431      const TNode& Node = NodeH[N];
2432      if (! Node.OutNIdV.IsSorted()) {
2433        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
2434        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2435      }
2436      if (! Node.InNIdV.IsSorted()) {
2437        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
2438        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2439      }
2440      int prevNId = -1;
2441      for (int e = 0; e < Node.GetOutDeg(); e++) {
2442        if (! IsNode(Node.GetOutNId(e))) {
2443          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
2444            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
2445          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2446        }
2447        if (e > 0 && prevNId == Node.GetOutNId(e)) {
2448          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
2449            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
2450          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2451        }
2452        prevNId = Node.GetOutNId(e);
2453      }
2454      prevNId = -1;
2455      for (int e = 0; e < Node.GetInDeg(); e++) {
2456        if (! IsNode(Node.GetInNId(e))) {
2457          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
2458            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
2459          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2460        }
2461        if (e > 0 && prevNId == Node.GetInNId(e)) {
2462          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
2463            Node.GetId(), Node.GetId(), Node.GetInNId(e));
2464          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2465        }
2466        prevNId = Node.GetInNId(e);
2467      }
2468    }
2469    return RetVal;
2470  }
2471  void TDirNet::Dump(FILE *OutF) const {
2472    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2473    fprintf(OutF, "-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
2474    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2475      const TNode& Node = NodeH[N];
2476      fprintf(OutF, "  %*d]\n", NodePlaces, Node.GetId());
2477      fprintf(OutF, "    in [%d]", Node.GetInDeg());
2478      for (int edge = 0; edge < Node.GetInDeg(); edge++) {
2479        fprintf(OutF, " %*d", NodePlaces, Node.GetInNId(edge)); }
2480      fprintf(OutF, "\n    out[%d]", Node.GetOutDeg());
2481      for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
2482        fprintf(OutF, " %*d", NodePlaces, Node.GetOutNId(edge)); }
2483      fprintf(OutF, "\n");
2484    }
2485    fprintf(OutF, "\n");
2486  }
2487  PDirNet TDirNet::GetSmallGraph() {
2488    PDirNet G = TDirNet::New();
2489    for (int i = 0; i < 5; i++) { G->AddNode(i); }
2490    G->AddEdge(0,1); G->AddEdge(1,2); G->AddEdge(0,2);
2491    G->AddEdge(1,3); G->AddEdge(3,4); G->AddEdge(2,3);
2492    return G;
2493  }
2494  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
2495    if (!IsNode(NId)) {
2496      return -1;
2497    }
2498    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2499  }
2500  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
2501    if (!IsNode(NId)) {
2502      return -1;
2503    }
2504    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2505  }
2506  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
2507    if (!IsNode(NId)) {
2508      return -1;
2509    }
2510    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2511  }
2512  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
2513    if (!IsNode(NId)) {
2514      return -1;
2515    }
2516    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2517  }
2518  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
2519    if (!IsNode(NId)) {
2520      return -1;
2521    }
2522    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2523  }
2524  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
2525    if (!IsNode(NId)) {
2526      return -1;
2527    }
2528    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2529  }
2530  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
2531    if (!IsNode(NId)) {
2532      return -1;
2533    }
2534    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2535  }
2536  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
2537    if (!IsNode(NId)) {
2538      return -1;
2539    }
2540    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2541  }
2542  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
2543    if (!IsNode(NId)) {
2544      return -1;
2545    }
2546    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2547  }
2548  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
2549    if (!IsNode(NId)) {
2550      return -1;
2551    }
2552    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2553  }
2554  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
2555    if (!IsNode(NId)) {
2556      return -1;
2557    }
2558    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2559  }
2560  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
2561    if (!IsNode(NId)) {
2562      return -1;
2563    }
2564    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2565  }
2566  int TDirNet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
2567    if (!IsNode(NId)) {
2568      return -1;
2569    }
2570    return SAttrN.DelSAttrDat(NId, AttrName);
2571  }
2572  int TDirNet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
2573    if (!IsNode(NId)) {
2574      return -1;
2575    }
2576    return SAttrN.DelSAttrDat(NId, AttrId);
2577  }
2578  int TDirNet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2579    if (!IsNode(NId)) {
2580      return -1;
2581    }
2582    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2583    return 0;
2584  }
2585  int TDirNet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
2586    return SAttrN.GetIdVSAttr(AttrName, IdV);
2587  }
2588  int TDirNet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
2589    return SAttrN.GetIdVSAttr(AttrId, IdV);
2590  }
2591  int TDirNet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2592    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2593  }
2594  int TDirNet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2595    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2596  }
2597  int TDirNet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2598    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2599  }
2600  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val) {
2601    if (!IsEdge(SrcNId, DstNId)) {
2602      return -1;
2603    }
2604    TIntPr EId(SrcNId, DstNId);
2605    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2606  }
2607  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val) {
2608    if (!IsEdge(SrcNId, DstNId)) {
2609      return -1;
2610    }
2611    TIntPr EId(SrcNId, DstNId);
2612    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2613  }
2614  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val) {
2615    if (!IsEdge(SrcNId, DstNId)) {
2616      return -1;
2617    }
2618    TIntPr EId(SrcNId, DstNId);
2619    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2620  }
2621  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val) {
2622    if (!IsEdge(SrcNId, DstNId)) {
2623      return -1;
2624    }
2625    TIntPr EId(SrcNId, DstNId);
2626    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2627  }
2628  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val) {
2629    if (!IsEdge(SrcNId, DstNId)) {
2630      return -1;
2631    }
2632    TIntPr EId(SrcNId, DstNId);
2633    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2634  }
2635  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val) {
2636    if (!IsEdge(SrcNId, DstNId)) {
2637      return -1;
2638    }
2639    TIntPr EId(SrcNId, DstNId);
2640    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2641  }
2642  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& Val) const {
2643    if (!IsEdge(SrcNId, DstNId)) {
2644      return -1;
2645    }
2646    TIntPr EId(SrcNId, DstNId);
2647    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2648  }
2649  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& Val) const {
2650    if (!IsEdge(SrcNId, DstNId)) {
2651      return -1;
2652    }
2653    TIntPr EId(SrcNId, DstNId);
2654    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2655  }
2656  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& Val) const {
2657    if (!IsEdge(SrcNId, DstNId)) {
2658      return -1;
2659    }
2660    TIntPr EId(SrcNId, DstNId);
2661    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2662  }
2663  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& Val) const {
2664    if (!IsEdge(SrcNId, DstNId)) {
2665      return -1;
2666    }
2667    TIntPr EId(SrcNId, DstNId);
2668    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2669  }
2670  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& Val) const {
2671    if (!IsEdge(SrcNId, DstNId)) {
2672      return -1;
2673    }
2674    TIntPr EId(SrcNId, DstNId);
2675    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2676  }
2677  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& Val) const {
2678    if (!IsEdge(SrcNId, DstNId)) {
2679      return -1;
2680    }
2681    TIntPr EId(SrcNId, DstNId);
2682    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2683  }
2684  int TDirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName) {
2685    if (!IsEdge(SrcNId, DstNId)) {
2686      return -1;
2687    }
2688    TIntPr EId(SrcNId, DstNId);
2689    return SAttrE.DelSAttrDat(EId, AttrName);
2690  }
2691  int TDirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId) {
2692    if (!IsEdge(SrcNId, DstNId)) {
2693      return -1;
2694    }
2695    TIntPr EId(SrcNId, DstNId);
2696    return SAttrE.DelSAttrDat(EId, AttrId);
2697  }
2698  int TDirNet::GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2699    if (!IsEdge(SrcNId, DstNId)) {
2700      return -1;
2701    }
2702    TIntPr EId(SrcNId, DstNId);
2703    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2704    return 0;
2705  }
2706  int TDirNet::GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const {
2707    return SAttrE.GetIdVSAttr(AttrName, IdV);
2708  }
2709  int TDirNet::GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const {
2710    return SAttrE.GetIdVSAttr(AttrId, IdV);
2711  }
2712  int TDirNet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2713    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2714  }
2715  int TDirNet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2716    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2717  }
2718  int TDirNet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2719    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2720  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memes.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</div>
                </div>
                <div class="column column_space"><pre><code>464    int cnt=0;
465    FILE *F = fopen("top_qts_per_time_unit.txt", "wt");
466    for (TSecTm Tm=MinTm; Tm <= MaxTm; Tm += StepHr*3600, cnt++) {
467      GetQtIdVByFq(TopQtIdV, MinWrdLen, MinQtFq, true, "", "", utUndef, TSecTm(Tm), TSecTm(Tm+StepHr*3600));
</pre></code></div>
                <div class="column column_space"><pre><code>1633    TFlt total = 0;
1634    int len = Node.OutEIdV.Len();
1635    for (int i = 0; i < len; i++) {
1636      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    