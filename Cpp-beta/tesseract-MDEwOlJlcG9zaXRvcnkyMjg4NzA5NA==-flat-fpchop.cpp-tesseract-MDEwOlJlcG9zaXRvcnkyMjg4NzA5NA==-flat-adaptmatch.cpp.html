
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.574018126888216%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-fpchop.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "fpchop.h"
5  #include "blobbox.h"
6  #include "drawtord.h"
7  #include "statistc.h"
8  #include "topitch.h"
9  #include "tovars.h"
10  namespace tesseract {
11  INT_VAR(textord_fp_chop_error, 2, "Max allowed bending of chop cells");
12  static WERD *add_repeated_word(WERD_IT *rep_it, int16_t &rep_left, int16_t &prev_chop_coord,
13                                 uint8_t &blanks, float pitch, WERD_IT *word_it);
14  static void fixed_chop_cblob(C_BLOB *blob, int16_t chop_coord, float pitch_error,
15                               C_OUTLINE_LIST *left_outlines, C_OUTLINE_LIST *right_outlines);
16  static void fixed_split_coutline(C_OUTLINE *srcline, int16_t chop_coord, float pitch_error,
17                                   C_OUTLINE_IT *left_it, C_OUTLINE_IT *right_it);
18  static bool fixed_chop_coutline(C_OUTLINE *srcline, int16_t chop_coord, float pitch_error,
19                                  C_OUTLINE_FRAG_LIST *left_frags, C_OUTLINE_FRAG_LIST *right_frags);
20  static void save_chop_cfragment(int16_t head_index, ICOORD head_pos, int16_t tail_index,
21                                  ICOORD tail_pos, C_OUTLINE *srcline, C_OUTLINE_FRAG_LIST *frags);
22  static void add_frag_to_list(C_OUTLINE_FRAG *frag, C_OUTLINE_FRAG_LIST *frags);
23  static void close_chopped_cfragments(C_OUTLINE_FRAG_LIST *frags, C_OUTLINE_LIST *children,
24                                       float pitch_error, C_OUTLINE_IT *dest_it);
25  static C_OUTLINE *join_chopped_fragments(C_OUTLINE_FRAG *bottom, C_OUTLINE_FRAG *top);
26  static void join_segments(C_OUTLINE_FRAG *bottom, C_OUTLINE_FRAG *top);
27  ROW *fixed_pitch_words( 
28      TO_ROW *row,        
29      FCOORD rotation     
30  ) {
31    bool bol;                
32    uint8_t blanks;          
33    uint8_t new_blanks;      
34    int16_t chop_coord;      
35    int16_t prev_chop_coord; 
36    int16_t rep_left;        
37    ROW *real_row;           
38    C_OUTLINE_LIST left_coutlines;
39    C_OUTLINE_LIST right_coutlines;
40    C_BLOB_LIST cblobs;
41    C_BLOB_IT cblob_it = &cblobs;
42    WERD_LIST words;
43    WERD_IT word_it = &words; 
44    WERD_IT rep_it = &row->rep_words;
45    WERD *word;         
46    int32_t xstarts[2]; 
47    int32_t prev_x;     
48    BLOBNBOX_IT box_it = row->blob_list();
49    ICOORDELT_IT cell_it = &row->char_cells;
50  #ifndef GRAPHICS_DISABLED
51    if (textord_show_page_cuts && to_win != nullptr) {
52      plot_row_cells(to_win, ScrollView::RED, row, 0, &row->char_cells);
53    }
54  #endif
55    prev_x = -INT16_MAX;
56    bol = true;
57    blanks = 0;
58    if (rep_it.empty()) {
59      rep_left = INT16_MAX;
60    } else {
61      rep_left = rep_it.data()->bounding_box().left();
62    }
63    if (box_it.empty()) {
64      return nullptr; 
65    }
<span onclick='openModal()' class='match'>66    xstarts[0] = box_it.data()->bounding_box().left();
67    if (rep_left < xstarts[0]) {
68      xstarts[0] = rep_left;
69    }
70    if (cell_it.empty() || row->char_cells.singleton()) {
71      tprintf("Row without enough char cells!\n");
72      tprintf("Leftmost blob is at (%d,%d)\n", box_it.data()->bounding_box().left(),
73              box_it.data()->bounding_box().bottom());
</span>74      return nullptr;
75    }
76    ASSERT_HOST(!cell_it.empty() && !row->char_cells.singleton());
77    prev_chop_coord = cell_it.data()->x();
78    word = nullptr;
79    while (rep_left < cell_it.data()->x()) {
80      word =
81          add_repeated_word(&rep_it, rep_left, prev_chop_coord, blanks, row->fixed_pitch, &word_it);
82    }
83    cell_it.mark_cycle_pt();
84    if (prev_chop_coord >= cell_it.data()->x()) {
85      cell_it.forward();
86    }
87    for (; !cell_it.cycled_list(); cell_it.forward()) {
88      chop_coord = cell_it.data()->x();
89      while (!box_it.empty() && box_it.data()->bounding_box().left() <= chop_coord) {
90        if (box_it.data()->bounding_box().right() > prev_x) {
91          prev_x = box_it.data()->bounding_box().right();
92        }
93        split_to_blob(box_it.extract(), chop_coord, textord_fp_chop_error + 0.5f, &left_coutlines,
94                      &right_coutlines);
95        box_it.forward();
96        while (!box_it.empty() && box_it.data()->cblob() == nullptr) {
97          delete box_it.extract();
98          box_it.forward();
99        }
100      }
101      if (!right_coutlines.empty() && left_coutlines.empty()) {
102        split_to_blob(nullptr, chop_coord, textord_fp_chop_error + 0.5f, &left_coutlines,
103                      &right_coutlines);
104      }
105      if (!left_coutlines.empty()) {
106        cblob_it.add_after_then_move(new C_BLOB(&left_coutlines));
107      } else {
108        if (rep_left < chop_coord) {
109          if (rep_left > prev_chop_coord) {
110            new_blanks =
111                static_cast<uint8_t>(floor((rep_left - prev_chop_coord) / row->fixed_pitch + 0.5));
112          } else {
113            new_blanks = 0;
114          }
115        } else {
116          if (chop_coord > prev_chop_coord) {
117            new_blanks =
118                static_cast<uint8_t>(floor((chop_coord - prev_chop_coord) / row->fixed_pitch + 0.5));
119          } else {
120            new_blanks = 0;
121          }
122        }
123        if (!cblob_it.empty()) {
124          if (blanks < 1 && word != nullptr && !word->flag(W_REP_CHAR)) {
125            blanks = 1;
126          }
127          word = new WERD(&cblobs, blanks, nullptr);
128          cblob_it.set_to_list(&cblobs);
129          word->set_flag(W_DONT_CHOP, true);
130          word_it.add_after_then_move(word);
131          if (bol) {
132            word->set_flag(W_BOL, true);
133            bol = false;
134          }
135          blanks = new_blanks;
136        } else {
137          blanks += new_blanks;
138        }
139        while (rep_left < chop_coord) {
140          word = add_repeated_word(&rep_it, rep_left, prev_chop_coord, blanks, row->fixed_pitch,
141                                   &word_it);
142        }
143      }
144      if (prev_chop_coord < chop_coord) {
145        prev_chop_coord = chop_coord;
146      }
147    }
148    if (!cblob_it.empty()) {
149      word = new WERD(&cblobs, blanks, nullptr);
150      word->set_flag(W_DONT_CHOP, true);
151      word_it.add_after_then_move(word);
152      if (bol) {
153        word->set_flag(W_BOL, true);
154      }
155    }
156    ASSERT_HOST(word != nullptr);
157    while (!rep_it.empty()) {
158      add_repeated_word(&rep_it, rep_left, prev_chop_coord, blanks, row->fixed_pitch, &word_it);
159    }
160    word_it.data()->set_flag(W_EOL, true);
161    if (prev_chop_coord > prev_x) {
162      prev_x = prev_chop_coord;
163    }
164    xstarts[1] = prev_x + 1;
165    real_row =
166        new ROW(row, static_cast<int16_t>(row->kern_size), static_cast<int16_t>(row->space_size));
167    word_it.set_to_list(real_row->word_list());
168    word_it.add_list_after(&words);
169    real_row->recalc_bounding_box();
170    return real_row;
171  }
172  static WERD *add_repeated_word( 
173      WERD_IT *rep_it,            
174      int16_t &rep_left,          
175      int16_t &prev_chop_coord,   
176      uint8_t &blanks,            
177      float pitch,                
178      WERD_IT *word_it            
179  ) {
180    WERD *word;         
181    int16_t new_blanks; 
182    if (rep_left > prev_chop_coord) {
183      new_blanks = static_cast<uint8_t>(floor((rep_left - prev_chop_coord) / pitch + 0.5));
184      blanks += new_blanks;
185    }
186    word = rep_it->extract();
187    prev_chop_coord = word->bounding_box().right();
188    word_it->add_after_then_move(word);
189    word->set_blanks(blanks);
190    rep_it->forward();
191    if (rep_it->empty()) {
192      rep_left = INT16_MAX;
193    } else {
194      rep_left = rep_it->data()->bounding_box().left();
195    }
196    blanks = 0;
197    return word;
198  }
199  void split_to_blob(                 
200      BLOBNBOX *blob,                 
201      int16_t chop_coord,             
202      float pitch_error,              
203      C_OUTLINE_LIST *left_coutlines, 
204      C_OUTLINE_LIST *right_coutlines) {
205    C_BLOB *real_cblob; 
206    if (blob != nullptr) {
207      real_cblob = blob->remove_cblob();
208    } else {
209      real_cblob = nullptr;
210    }
211    if (!right_coutlines->empty() || real_cblob != nullptr) {
212      fixed_chop_cblob(real_cblob, chop_coord, pitch_error, left_coutlines, right_coutlines);
213    }
214    delete blob;
215  }
216  static void fixed_chop_cblob(      
217      C_BLOB *blob,                  
218      int16_t chop_coord,            
219      float pitch_error,             
220      C_OUTLINE_LIST *left_outlines, 
221      C_OUTLINE_LIST *right_outlines 
222  ) {
223    C_OUTLINE *old_right;        
224    C_OUTLINE_LIST new_outlines; 
225    C_OUTLINE_IT left_it = left_outlines;
226    C_OUTLINE_IT right_it = right_outlines;
227    C_OUTLINE_IT new_it = &new_outlines;
228    C_OUTLINE_IT blob_it; 
229    if (!right_it.empty()) {
230      while (!right_it.empty()) {
231        old_right = right_it.extract();
232        right_it.forward();
233        fixed_split_coutline(old_right, chop_coord, pitch_error, &left_it, &new_it);
234      }
235      right_it.add_list_before(&new_outlines);
236    }
237    if (blob != nullptr) {
238      blob_it.set_to_list(blob->out_list());
239      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
240        fixed_split_coutline(blob_it.extract(), chop_coord, pitch_error, &left_it, &right_it);
241      }
242      delete blob;
243    }
244  }
245  static void fixed_split_coutline( 
246      C_OUTLINE *srcline,           
247      int16_t chop_coord,           
248      float pitch_error,            
249      C_OUTLINE_IT *left_it,        
250      C_OUTLINE_IT *right_it        
251  ) {
252    C_OUTLINE *child;               
253    TBOX srcbox;                    
254    C_OUTLINE_LIST left_ch;         
255    C_OUTLINE_LIST right_ch;        
256    C_OUTLINE_FRAG_LIST left_frags; 
257    C_OUTLINE_FRAG_LIST right_frags;
258    ;
259    C_OUTLINE_IT left_ch_it = &left_ch;
260    C_OUTLINE_IT right_ch_it = &right_ch;
261    C_OUTLINE_IT child_it = srcline->child();
262    srcbox = srcline->bounding_box();
263    if (srcbox.left() + srcbox.right() <= chop_coord * 2 &&
264        srcbox.right() < chop_coord + pitch_error) {
265      left_it->add_after_then_move(srcline);
266    } else if (srcbox.left() + srcbox.right() > chop_coord * 2 &&
267               srcbox.left() > chop_coord - pitch_error) {
268      right_it->add_before_stay_put(srcline);
269    } else {
270      if (fixed_chop_coutline(srcline, chop_coord, pitch_error, &left_frags, &right_frags)) {
271        for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
272          child = child_it.extract();
273          srcbox = child->bounding_box();
274          if (srcbox.right() < chop_coord) {
275            left_ch_it.add_after_then_move(child);
276          } else if (srcbox.left() > chop_coord) {
277            right_ch_it.add_after_then_move(child);
278          } else {
279            if (fixed_chop_coutline(child, chop_coord, 0.0f, &left_frags, &right_frags)) {
280              delete child;
281            } else {
282              if (srcbox.left() + srcbox.right() <= chop_coord * 2) {
283                left_ch_it.add_after_then_move(child);
284              } else {
285                right_ch_it.add_after_then_move(child);
286              }
287            }
288          }
289        }
290        close_chopped_cfragments(&left_frags, &left_ch, pitch_error, left_it);
291        close_chopped_cfragments(&right_frags, &right_ch, pitch_error, right_it);
292        ASSERT_HOST(left_ch.empty() && right_ch.empty());
293        delete srcline; 
294      } else {
295        if (srcbox.left() + srcbox.right() <= chop_coord * 2) {
296          left_it->add_after_then_move(srcline); 
297        } else {
298          right_it->add_before_stay_put(srcline);
299        }
300      }
301    }
302  }
303  static bool fixed_chop_coutline(     
304      C_OUTLINE *srcline,              
305      int16_t chop_coord,              
306      float pitch_error,               
307      C_OUTLINE_FRAG_LIST *left_frags, 
308      C_OUTLINE_FRAG_LIST *right_frags 
309  ) {
310    bool first_frag;         
311    int16_t left_edge;       
312    int16_t startindex;      
313    int32_t length;          
314    int16_t stepindex;       
315    int16_t head_index;      
316    ICOORD head_pos;         
317    int16_t tail_index;      
318    ICOORD tail_pos;         
319    ICOORD pos;              
320    int16_t first_index = 0; 
321    ICOORD first_pos;        
322    length = srcline->pathlength();
323    pos = srcline->start_pos();
324    left_edge = pos.x();
325    tail_index = 0;
326    tail_pos = pos;
327    for (stepindex = 0; stepindex < length; stepindex++) {
328      if (pos.x() < left_edge) {
329        left_edge = pos.x();
330        tail_index = stepindex;
331        tail_pos = pos;
332      }
333      pos += srcline->step(stepindex);
334    }
335    if (left_edge >= chop_coord - pitch_error) {
336      return false; 
337    }
338    startindex = tail_index;
339    first_frag = true;
340    head_index = tail_index;
341    head_pos = tail_pos;
342    do {
343      do {
344        tail_pos += srcline->step(tail_index);
345        tail_index++;
346        if (tail_index == length) {
347          tail_index = 0;
348        }
349      } while (tail_pos.x() != chop_coord && tail_index != startindex);
350      if (tail_index == startindex) {
351        if (first_frag) {
352          return false; 
353        } else {
354          break;
355        }
356      }
357      ASSERT_HOST(head_index != tail_index);
358      if (!first_frag) {
359        save_chop_cfragment(head_index, head_pos, tail_index, tail_pos, srcline, left_frags);
360      } else {
361        first_index = tail_index;
362        first_pos = tail_pos;
363        first_frag = false;
364      }
365      while (srcline->step(tail_index).x() == 0) {
366        tail_pos += srcline->step(tail_index);
367        tail_index++;
368        if (tail_index == length) {
369          tail_index = 0;
370        }
371      }
372      head_index = tail_index;
373      head_pos = tail_pos;
374      while (srcline->step(tail_index).x() > 0) {
375        do {
376          tail_pos += srcline->step(tail_index);
377          tail_index++;
378          if (tail_index == length) {
379            tail_index = 0;
380          }
381        } while (tail_pos.x() != chop_coord);
382        ASSERT_HOST(head_index != tail_index);
383        save_chop_cfragment(head_index, head_pos, tail_index, tail_pos, srcline, right_frags);
384        while (srcline->step(tail_index).x() == 0) {
385          tail_pos += srcline->step(tail_index);
386          tail_index++;
387          if (tail_index == length) {
388            tail_index = 0;
389          }
390        }
391        head_index = tail_index;
392        head_pos = tail_pos;
393      }
394    } while (tail_index != startindex);
395    save_chop_cfragment(head_index, head_pos, first_index, first_pos, srcline, left_frags);
396    return true; 
397  }
398  static void save_chop_cfragment( 
399      int16_t head_index,          
400      ICOORD head_pos,             
401      int16_t tail_index,          
402      ICOORD tail_pos,             
403      C_OUTLINE *srcline,          
404      C_OUTLINE_FRAG_LIST *frags   
405  ) {
406    int16_t jump;         
407    int16_t stepcount;    
408    C_OUTLINE_FRAG *head; 
409    C_OUTLINE_FRAG *tail; 
410    int16_t tail_y;       
411    ASSERT_HOST(tail_pos.x() == head_pos.x());
412    ASSERT_HOST(tail_index != head_index);
413    stepcount = tail_index - head_index;
414    if (stepcount < 0) {
415      stepcount += srcline->pathlength();
416    }
417    jump = tail_pos.y() - head_pos.y();
418    if (jump < 0) {
419      jump = -jump;
420    }
421    if (jump == stepcount) {
422      return; 
423    }
424    tail_y = tail_pos.y();
425    head = new C_OUTLINE_FRAG(head_pos, tail_pos, srcline, head_index, tail_index);
426    tail = new C_OUTLINE_FRAG(head, tail_y);
427    head->other_end = tail;
428    add_frag_to_list(head, frags);
429    add_frag_to_list(tail, frags);
430  }
431  C_OUTLINE_FRAG::C_OUTLINE_FRAG( 
432      ICOORD start_pt,            
433      ICOORD end_pt,              
434      C_OUTLINE *outline,         
435      int16_t start_index, int16_t end_index) {
436    start = start_pt;
437    end = end_pt;
438    ycoord = start_pt.y();
439    stepcount = end_index - start_index;
440    if (stepcount < 0) {
441      stepcount += outline->pathlength();
442    }
443    ASSERT_HOST(stepcount > 0);
444    steps = new DIR128[stepcount];
445    if (end_index > start_index) {
446      for (int i = start_index; i < end_index; ++i) {
447        steps[i - start_index] = outline->step_dir(i);
448      }
449    } else {
450      int len = outline->pathlength();
451      int i = start_index;
452      for (; i < len; ++i) {
453        steps[i - start_index] = outline->step_dir(i);
454      }
455      if (end_index > 0) {
456        for (; i < end_index + len; ++i) {
457          steps[i - start_index] = outline->step_dir(i - len);
458        }
459      }
460    }
461    other_end = nullptr;
462    delete close();
463  }
464  C_OUTLINE_FRAG::C_OUTLINE_FRAG( 
465      C_OUTLINE_FRAG *head,       
466      int16_t tail_y) {
467    ycoord = tail_y;
468    other_end = head;
469    start = head->start;
470    end = head->end;
471    steps = nullptr;
472    stepcount = 0;
473  }
474  static void add_frag_to_list(  
475      C_OUTLINE_FRAG *frag,      
476      C_OUTLINE_FRAG_LIST *frags 
477  ) {
478    C_OUTLINE_FRAG_IT frag_it = frags;
479    if (!frags->empty()) {
480      for (frag_it.mark_cycle_pt(); !frag_it.cycled_list(); frag_it.forward()) {
481        if (frag_it.data()->ycoord > frag->ycoord ||
482            (frag_it.data()->ycoord == frag->ycoord && frag->other_end->ycoord < frag->ycoord)) {
483          frag_it.add_before_then_move(frag);
484          return;
485        }
486      }
487    }
488    frag_it.add_to_end(frag);
489  }
490  static void close_chopped_cfragments( 
491      C_OUTLINE_FRAG_LIST *frags,       
492      C_OUTLINE_LIST *children,         
493      float pitch_error,                
494      C_OUTLINE_IT *dest_it             
495  ) {
496    C_OUTLINE_FRAG_IT frag_it = frags;
497    C_OUTLINE_FRAG *bottom_frag; 
498    C_OUTLINE_FRAG *top_frag;    
499    C_OUTLINE *outline;          
500    C_OUTLINE *child;            
501    C_OUTLINE_IT child_it = children;
502    C_OUTLINE_IT olchild_it; 
503    while (!frag_it.empty()) {
504      frag_it.move_to_first();
505      bottom_frag = frag_it.extract();
506      frag_it.forward();
507      top_frag = frag_it.data(); 
508      if ((bottom_frag->steps == nullptr && top_frag->steps == nullptr) ||
509          (bottom_frag->steps != nullptr && top_frag->steps != nullptr)) {
510        if (frag_it.data_relative(1)->ycoord == top_frag->ycoord) {
511          frag_it.forward();
512        }
513      }
514      top_frag = frag_it.extract();
515      if (top_frag->other_end != bottom_frag) {
516        outline = join_chopped_fragments(bottom_frag, top_frag);
517        ASSERT_HOST(outline == nullptr);
518      } else {
519        outline = join_chopped_fragments(bottom_frag, top_frag);
520        if (outline != nullptr) {
521          olchild_it.set_to_list(outline->child());
522          for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
523            child = child_it.data();
524            if (*child < *outline) {
525              olchild_it.add_to_end(child_it.extract());
526            }
527          }
528          if (outline->bounding_box().width() > pitch_error) {
529            dest_it->add_after_then_move(outline);
530          } else {
531            delete outline; 
532          }
533        }
534      }
535    }
536    while (!child_it.empty()) {
537      dest_it->add_after_then_move(child_it.extract());
538      child_it.forward();
539    }
540  }
541  static C_OUTLINE *join_chopped_fragments( 
542      C_OUTLINE_FRAG *bottom,               
543      C_OUTLINE_FRAG *top                   
544  ) {
545    C_OUTLINE *outline; 
546    if (bottom->other_end == top) {
547      if (bottom->steps == nullptr) {
548        outline = top->close(); 
549      } else {
550        outline = bottom->close();
551      }
552      delete top;
553      delete bottom;
554      return outline;
555    }
556    if (bottom->steps == nullptr) {
557      ASSERT_HOST(top->steps != nullptr);
558      join_segments(bottom->other_end, top);
559    } else {
560      ASSERT_HOST(top->steps == nullptr);
561      join_segments(top->other_end, bottom);
562    }
563    top->other_end->other_end = bottom->other_end;
564    bottom->other_end->other_end = top->other_end;
565    delete bottom;
566    delete top;
567    return nullptr;
568  }
569  static void join_segments(  
570      C_OUTLINE_FRAG *bottom, 
571      C_OUTLINE_FRAG *top     
572  ) {
573    DIR128 *steps;      
574    int32_t stepcount;  
575    int16_t fake_count; 
576    DIR128 fake_step;   
577    ASSERT_HOST(bottom->end.x() == top->start.x());
578    fake_count = top->start.y() - bottom->end.y();
579    if (fake_count < 0) {
580      fake_count = -fake_count;
581      fake_step = 32;
582    } else {
583      fake_step = 96;
584    }
585    stepcount = bottom->stepcount + fake_count + top->stepcount;
586    steps = new DIR128[stepcount];
587    memmove(steps, bottom->steps, bottom->stepcount);
588    memset(steps + bottom->stepcount, fake_step.get_dir(), fake_count);
589    memmove(steps + bottom->stepcount + fake_count, top->steps, top->stepcount);
590    delete[] bottom->steps;
591    bottom->steps = steps;
592    bottom->stepcount = stepcount;
593    bottom->end = top->end;
594    bottom->other_end->end = top->end;
595  }
596  C_OUTLINE *C_OUTLINE_FRAG::close() { 
597    DIR128 *new_steps;                 
598    int32_t new_stepcount;             
599    int16_t fake_count;                
600    DIR128 fake_step;                  
601    ASSERT_HOST(start.x() == end.x());
602    fake_count = start.y() - end.y();
603    if (fake_count < 0) {
604      fake_count = -fake_count;
605      fake_step = 32;
606    } else {
607      fake_step = 96;
608    }
609    new_stepcount = stepcount + fake_count;
610    if (new_stepcount > C_OUTLINE::kMaxOutlineLength) {
611      return nullptr; 
612    }
613    new_steps = new DIR128[new_stepcount];
614    memmove(new_steps, steps, stepcount);
615    memset(new_steps + stepcount, fake_step.get_dir(), fake_count);
616    auto *result = new C_OUTLINE(start, new_steps, new_stepcount);
617    delete[] new_steps;
618    return result;
619  }
620  C_OUTLINE_FRAG &C_OUTLINE_FRAG::operator=(const C_OUTLINE_FRAG &src 
621  ) {
622    delete[] steps;
623    stepcount = src.stepcount;
624    steps = new DIR128[stepcount];
625    memmove(steps, src.steps, stepcount);
626    start = src.start;
627    end = src.end;
628    ycoord = src.ycoord;
629    return *this;
630  }
631  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-adaptmatch.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "adaptive.h"        
5  #include "ambigs.h"          
6  #include "bitvec.h"          
7  #include "blobs.h"           
8  #include "classify.h"        
9  #include "dict.h"            
10  #include "errcode.h"         
11  #include "featdefs.h"        
12  #include "float2int.h"       
13  #include "fontinfo.h"        
14  #include "intfx.h"           
15  #include "intmatcher.h"      
16  #include "intproto.h"        
17  #include "matchdefs.h"       
18  #include "mfoutline.h"       
19  #include "normalis.h"        
20  #include "normfeat.h"        
21  #include "ocrfeatures.h"     
22  #include "oldlist.h"         
23  #include "outfeat.h"         
24  #include "pageres.h"         
25  #include "params.h"          
26  #include "picofeat.h"        
27  #include "protos.h"          
28  #include "ratngs.h"          
29  #include "rect.h"            
30  #include "scrollview.h"      
31  #include "seam.h"            
32  #include "shapeclassifier.h" 
33  #include "shapetable.h"      
34  #include "tessclassifier.h"  
35  #include "tessdatamanager.h" 
36  #include "tprintf.h"         
37  #include "trainingsample.h"  
38  #include "unicharset.h"      
39  #include "unicity_table.h"   
40  #include <tesseract/unichar.h> 
41  #include "helpers.h"           
42  #include "serialis.h"          
43  #include <algorithm> 
44  #include <cassert>   
45  #include <cmath>     
46  #include <cstdint>   
47  #include <cstdio>    
48  #include <cstring>   
49  namespace tesseract {
50  #define classify_enable_adaptive_matcher true
51  #define ADAPT_TEMPLATE_SUFFIX ".a"
52  #define MAX_MATCHES 10
53  #define UNLIKELY_NUM_FEAT 200
54  #define NO_DEBUG 0
55  #define MAX_ADAPTABLE_WERD_SIZE 40
56  #define ADAPTABLE_WERD_ADJUSTMENT (0.05)
57  #define Y_DIM_OFFSET (Y_SHIFT - BASELINE_Y_SHIFT)
58  #define WORST_POSSIBLE_RATING (0.0f)
59  struct ADAPT_RESULTS {
60    int32_t BlobLength;
61    bool HasNonfragment;
62    UNICHAR_ID best_unichar_id;
63    int best_match_index;
64    float best_rating;
65    std::vector<UnicharRating> match;
66    std::vector<CP_RESULT_STRUCT> CPResults;
67    inline void Initialize() {
68      BlobLength = INT32_MAX;
69      HasNonfragment = false;
70      ComputeBest();
71    }
72    void ComputeBest() {
73      best_unichar_id = INVALID_UNICHAR_ID;
74      best_match_index = -1;
75      best_rating = WORST_POSSIBLE_RATING;
76      for (unsigned i = 0; i < match.size(); ++i) {
77        if (match[i].rating > best_rating) {
78          best_rating = match[i].rating;
79          best_unichar_id = match[i].unichar_id;
80          best_match_index = i;
81        }
82      }
83    }
84  };
85  struct PROTO_KEY {
86    ADAPT_TEMPLATES_STRUCT *Templates;
87    CLASS_ID ClassId;
88    int ConfigId;
89  };
90  static bool SortDescendingRating(const UnicharRating &a, const UnicharRating &b) {
91    if (a.rating != b.rating) {
92      return a.rating > b.rating;
93    } else {
94      return a.unichar_id < b.unichar_id;
95    }
96  }
97  inline bool MarginalMatch(float confidence, float matcher_great_threshold) {
98    return (1.0f - confidence) > matcher_great_threshold;
99  }
100  static unsigned FindScoredUnichar(UNICHAR_ID id, const ADAPT_RESULTS &results) {
101    for (unsigned i = 0; i < results.match.size(); i++) {
102      if (results.match[i].unichar_id == id) {
103        return i;
104      }
105    }
106    return results.match.size();
107  }
108  static float ScoredUnichar(UNICHAR_ID id, const ADAPT_RESULTS &results) {
109    unsigned index = FindScoredUnichar(id, results);
110    if (index >= results.match.size()) {
111      return WORST_POSSIBLE_RATING;
112    }
113    return results.match[index].rating;
114  }
115  void InitMatcherRatings(float *Rating);
116  int MakeTempProtoPerm(void *item1, void *item2);
117  void SetAdaptiveThreshold(float Threshold);
118  void Classify::AdaptiveClassifier(TBLOB *Blob, BLOB_CHOICE_LIST *Choices) {
119    assert(Choices != nullptr);
120    auto *Results = new ADAPT_RESULTS;
121    Results->Initialize();
122    ASSERT_HOST(AdaptedTemplates != nullptr);
123    DoAdaptiveMatch(Blob, Results);
124    RemoveBadMatches(Results);
125    std::sort(Results->match.begin(), Results->match.end(), SortDescendingRating);
126    RemoveExtraPuncs(Results);
127    Results->ComputeBest();
128    ConvertMatchesToChoices(Blob->denorm(), Blob->bounding_box(), Results, Choices);
129    if (LargeSpeckle(*Blob) || Choices->empty()) {
130      AddLargeSpeckleTo(Results->BlobLength, Choices);
131    }
132    if (matcher_debug_level >= 1) {
133      tprintf("AD Matches =  ");
134      PrintAdaptiveMatchResults(*Results);
135    }
136  #ifndef GRAPHICS_DISABLED
137    if (classify_enable_adaptive_debugger) {
138      DebugAdaptiveClassifier(Blob, Results);
139    }
140  #endif
141    delete Results;
142  } &bsol;* AdaptiveClassifier */
143  #ifndef GRAPHICS_DISABLED
144  void Classify::RefreshDebugWindow(ScrollView **win, const char *msg, int y_offset,
145                                    const TBOX &wbox) {
146    const int kSampleSpaceWidth = 500;
147    if (*win == nullptr) {
148      *win = new ScrollView(msg, 100, y_offset, kSampleSpaceWidth * 2, 200, kSampleSpaceWidth * 2,
149                            200, true);
150    }
151    (*win)->Clear();
152    (*win)->Pen(64, 64, 64);
153    (*win)->Line(-kSampleSpaceWidth, kBlnBaselineOffset, kSampleSpaceWidth, kBlnBaselineOffset);
154    (*win)->Line(-kSampleSpaceWidth, kBlnXHeight + kBlnBaselineOffset, kSampleSpaceWidth,
155                 kBlnXHeight + kBlnBaselineOffset);
156    (*win)->ZoomToRectangle(wbox.left(), wbox.top(), wbox.right(), wbox.bottom());
157  }
158  #endif 
159  void Classify::LearnWord(const char *fontname, WERD_RES *word) {
160    int word_len = word->correct_text.size();
161    if (word_len == 0) {
162      return;
163    }
164    float *thresholds = nullptr;
165    if (fontname == nullptr) {
166      if (!EnableLearning || word->best_choice == nullptr) {
167        return; 
168      }
169      if (classify_learning_debug_level >= 1) {
170        tprintf("\n\nAdapting to word = %s\n", word->best_choice->debug_string().c_str());
171      }
172      thresholds = new float[word_len];
173      word->ComputeAdaptionThresholds(getDict().certainty_scale, matcher_perfect_threshold,
174                                      matcher_good_threshold, matcher_rating_margin, thresholds);
175    }
176    int start_blob = 0;
177  #ifndef GRAPHICS_DISABLED
178    if (classify_debug_character_fragments) {
179      if (learn_fragmented_word_debug_win_ != nullptr) {
180        learn_fragmented_word_debug_win_->Wait();
181      }
182      RefreshDebugWindow(&learn_fragments_debug_win_, "LearnPieces", 400,
183                         word->chopped_word->bounding_box());
184      RefreshDebugWindow(&learn_fragmented_word_debug_win_, "LearnWord", 200,
185                         word->chopped_word->bounding_box());
186      word->chopped_word->plot(learn_fragmented_word_debug_win_);
187      ScrollView::Update();
188    }
189  #endif 
190    for (int ch = 0; ch < word_len; ++ch) {
191      if (classify_debug_character_fragments) {
192        tprintf("\nLearning %s\n", word->correct_text[ch].c_str());
193      }
194      if (word->correct_text[ch].length() > 0) {
195        float threshold = thresholds != nullptr ? thresholds[ch] : 0.0f;
196        LearnPieces(fontname, start_blob, word->best_state[ch], threshold, CST_WHOLE,
197                    word->correct_text[ch].c_str(), word);
198        if (word->best_state[ch] > 1 && !disable_character_fragments) {
199          bool garbage = false;
200          int frag;
201          for (frag = 0; frag < word->best_state[ch]; ++frag) {
202            TBLOB *frag_blob = word->chopped_word->blobs[start_blob + frag];
203            if (classify_character_fragments_garbage_certainty_threshold < 0) {
204              garbage |= LooksLikeGarbage(frag_blob);
205            }
206          }
207          if (!garbage) {
208            bool pieces_all_natural = word->PiecesAllNatural(start_blob, word->best_state[ch]);
209            if (pieces_all_natural || !prioritize_division) {
210              for (frag = 0; frag < word->best_state[ch]; ++frag) {
211                std::vector<std::string> tokens = split(word->correct_text[ch], ' ');
212                tokens[0] = CHAR_FRAGMENT::to_string(tokens[0].c_str(), frag, word->best_state[ch],
213                                                     pieces_all_natural);
214                std::string full_string;
215                for (unsigned i = 0; i < tokens.size(); i++) {
216                  full_string += tokens[i];
217                  if (i != tokens.size() - 1) {
218                    full_string += ' ';
219                  }
220                }
221                LearnPieces(fontname, start_blob + frag, 1, threshold, CST_FRAGMENT,
222                            full_string.c_str(), word);
223              }
224            }
225          }
226        }
227      }
228      start_blob += word->best_state[ch];
229    }
230    delete[] thresholds;
231  } 
232  void Classify::LearnPieces(const char *fontname, int start, int length, float threshold,
233                             CharSegmentationType segmentation, const char *correct_text,
234                             WERD_RES *word) {
235    if (segmentation != CST_WHOLE && (segmentation != CST_FRAGMENT || disable_character_fragments)) {
236      return;
237    }
238    if (length > 1) {
239      SEAM::JoinPieces(word->seam_array, word->chopped_word->blobs, start, start + length - 1);
240    }
241    TBLOB *blob = word->chopped_word->blobs[start];
<span onclick='openModal()' class='match'>242    TBLOB *rotated_blob = blob->ClassifyNormalizeIfNeeded();
243    if (rotated_blob == nullptr) {
244      rotated_blob = blob;
245    }
246  #ifndef GRAPHICS_DISABLED
247    if (strcmp(classify_learn_debug_str.c_str(), correct_text) == 0) {
248      RefreshDebugWindow(&learn_debug_win_, "LearnPieces", 600, word->chopped_word->bounding_box());
249      rotated_blob->plot(learn_debug_win_, ScrollView::GREEN, ScrollView::BROWN);
250      learn_debug_win_->Update();
251      learn_debug_win_->Wait();
</span>252    }
253    if (classify_debug_character_fragments && segmentation == CST_FRAGMENT) {
254      ASSERT_HOST(learn_fragments_debug_win_ != nullptr); 
255      blob->plot(learn_fragments_debug_win_, ScrollView::BLUE, ScrollView::BROWN);
256      learn_fragments_debug_win_->Update();
257    }
258  #endif 
259    if (fontname != nullptr) {
260      classify_norm_method.set_value(character); 
261      tess_bn_matching.set_value(false);         
262      tess_cn_matching.set_value(false);
263      DENORM bl_denorm, cn_denorm;
264      INT_FX_RESULT_STRUCT fx_info;
265      SetupBLCNDenorms(*rotated_blob, classify_nonlinear_norm, &bl_denorm, &cn_denorm, &fx_info);
266      LearnBlob(fontname, rotated_blob, cn_denorm, fx_info, correct_text);
267    } else if (unicharset.contains_unichar(correct_text)) {
268      UNICHAR_ID class_id = unicharset.unichar_to_id(correct_text);
269      int font_id = word->fontinfo != nullptr ? fontinfo_table_.get_index(*word->fontinfo) : 0;
270      if (classify_learning_debug_level >= 1) {
271        tprintf("Adapting to char = %s, thr= %g font_id= %d\n", unicharset.id_to_unichar(class_id),
272                threshold, font_id);
273      }
274      AdaptToChar(rotated_blob, class_id, font_id, threshold, AdaptedTemplates);
275      if (BackupAdaptedTemplates != nullptr) {
276        AdaptToChar(rotated_blob, class_id, font_id, threshold, BackupAdaptedTemplates);
277      }
278    } else if (classify_debug_level >= 1) {
279      tprintf("Can't adapt to %s not in unicharset\n", correct_text);
280    }
281    if (rotated_blob != blob) {
282      delete rotated_blob;
283    }
284    SEAM::BreakPieces(word->seam_array, word->chopped_word->blobs, start, start + length - 1);
285  } 
286  void Classify::EndAdaptiveClassifier() {
287    std::string Filename;
288    FILE *File;
289    if (AdaptedTemplates != nullptr && classify_enable_adaptive_matcher &&
290        classify_save_adapted_templates) {
291      Filename = imagefile + ADAPT_TEMPLATE_SUFFIX;
292      File = fopen(Filename.c_str(), "wb");
293      if (File == nullptr) {
294        tprintf("Unable to save adapted templates to %s!\n", Filename.c_str());
295      } else {
296        tprintf("\nSaving adapted templates to %s ...", Filename.c_str());
297        fflush(stdout);
298        WriteAdaptedTemplates(File, AdaptedTemplates);
299        tprintf("\n");
300        fclose(File);
301      }
302    }
303    delete AdaptedTemplates;
304    AdaptedTemplates = nullptr;
305    delete BackupAdaptedTemplates;
306    BackupAdaptedTemplates = nullptr;
307    if (PreTrainedTemplates != nullptr) {
308      delete PreTrainedTemplates;
309      PreTrainedTemplates = nullptr;
310    }
311    getDict().EndDangerousAmbigs();
312    FreeNormProtos();
313    if (AllProtosOn != nullptr) {
314      FreeBitVector(AllProtosOn);
315      FreeBitVector(AllConfigsOn);
316      FreeBitVector(AllConfigsOff);
317      FreeBitVector(TempProtoMask);
318      AllProtosOn = nullptr;
319      AllConfigsOn = nullptr;
320      AllConfigsOff = nullptr;
321      TempProtoMask = nullptr;
322    }
323    delete shape_table_;
324    shape_table_ = nullptr;
325    delete static_classifier_;
326    static_classifier_ = nullptr;
327  } &bsol;* EndAdaptiveClassifier */
328  void Classify::InitAdaptiveClassifier(TessdataManager *mgr) {
329    if (!classify_enable_adaptive_matcher) {
330      return;
331    }
332    if (AllProtosOn != nullptr) {
333      EndAdaptiveClassifier(); 
334    }
335    if (language_data_path_prefix.length() > 0 && mgr != nullptr) {
336      TFile fp;
337      ASSERT_HOST(mgr->GetComponent(TESSDATA_INTTEMP, &fp));
338      PreTrainedTemplates = ReadIntTemplates(&fp);
339      if (mgr->GetComponent(TESSDATA_SHAPE_TABLE, &fp)) {
340        shape_table_ = new ShapeTable(unicharset);
341        if (!shape_table_->DeSerialize(&fp)) {
342          tprintf("Error loading shape table!\n");
343          delete shape_table_;
344          shape_table_ = nullptr;
345        }
346      }
347      ASSERT_HOST(mgr->GetComponent(TESSDATA_PFFMTABLE, &fp));
348      ReadNewCutoffs(&fp, CharNormCutoffs);
349      ASSERT_HOST(mgr->GetComponent(TESSDATA_NORMPROTO, &fp));
350      NormProtos = ReadNormProtos(&fp);
351      static_classifier_ = new TessClassifier(false, this);
352    }
353    InitIntegerFX();
354    AllProtosOn = NewBitVector(MAX_NUM_PROTOS);
355    AllConfigsOn = NewBitVector(MAX_NUM_CONFIGS);
356    AllConfigsOff = NewBitVector(MAX_NUM_CONFIGS);
357    TempProtoMask = NewBitVector(MAX_NUM_PROTOS);
358    set_all_bits(AllProtosOn, WordsInVectorOfSize(MAX_NUM_PROTOS));
359    set_all_bits(AllConfigsOn, WordsInVectorOfSize(MAX_NUM_CONFIGS));
360    zero_all_bits(AllConfigsOff, WordsInVectorOfSize(MAX_NUM_CONFIGS));
361    for (uint16_t &BaselineCutoff : BaselineCutoffs) {
362      BaselineCutoff = 0;
363    }
364    if (classify_use_pre_adapted_templates) {
365      TFile fp;
366      std::string Filename = imagefile;
367      Filename += ADAPT_TEMPLATE_SUFFIX;
368      if (!fp.Open(Filename.c_str(), nullptr)) {
369        AdaptedTemplates = new ADAPT_TEMPLATES_STRUCT(unicharset);
370      } else {
371        tprintf("\nReading pre-adapted templates from %s ...\n", Filename.c_str());
372        fflush(stdout);
373        AdaptedTemplates = ReadAdaptedTemplates(&fp);
374        tprintf("\n");
375        PrintAdaptedTemplates(stdout, AdaptedTemplates);
376        for (unsigned i = 0; i < AdaptedTemplates->Templates->NumClasses; i++) {
377          BaselineCutoffs[i] = CharNormCutoffs[i];
378        }
379      }
380    } else {
381      delete AdaptedTemplates;
382      AdaptedTemplates = new ADAPT_TEMPLATES_STRUCT(unicharset);
383    }
384  } &bsol;* InitAdaptiveClassifier */
385  void Classify::ResetAdaptiveClassifierInternal() {
386    if (classify_learning_debug_level > 0) {
387      tprintf("Resetting adaptive classifier (NumAdaptationsFailed=%d)\n", NumAdaptationsFailed);
388    }
389    delete AdaptedTemplates;
390    AdaptedTemplates = new ADAPT_TEMPLATES_STRUCT(unicharset);
391    delete BackupAdaptedTemplates;
392    BackupAdaptedTemplates = nullptr;
393    NumAdaptationsFailed = 0;
394  }
395  void Classify::SwitchAdaptiveClassifier() {
396    if (BackupAdaptedTemplates == nullptr) {
397      ResetAdaptiveClassifierInternal();
398      return;
399    }
400    if (classify_learning_debug_level > 0) {
401      tprintf("Switch to backup adaptive classifier (NumAdaptationsFailed=%d)\n",
402              NumAdaptationsFailed);
403    }
404    delete AdaptedTemplates;
405    AdaptedTemplates = BackupAdaptedTemplates;
406    BackupAdaptedTemplates = nullptr;
407    NumAdaptationsFailed = 0;
408  }
409  void Classify::StartBackupAdaptiveClassifier() {
410    delete BackupAdaptedTemplates;
411    BackupAdaptedTemplates = new ADAPT_TEMPLATES_STRUCT(unicharset);
412  }
413  void Classify::SettupPass1() {
414    EnableLearning = classify_enable_learning;
415    getDict().SettupStopperPass1();
416  } &bsol;* SettupPass1 */
417  void Classify::SettupPass2() {
418    EnableLearning = false;
419    getDict().SettupStopperPass2();
420  } &bsol;* SettupPass2 */
421  void Classify::InitAdaptedClass(TBLOB *Blob, CLASS_ID ClassId, int FontinfoId, ADAPT_CLASS_STRUCT *Class,
422                                  ADAPT_TEMPLATES_STRUCT *Templates) {
423    FEATURE_SET Features;
424    int Fid, Pid;
425    FEATURE Feature;
426    int NumFeatures;
427    PROTO_STRUCT *Proto;
428    INT_CLASS_STRUCT *IClass;
429    TEMP_CONFIG_STRUCT *Config;
430    classify_norm_method.set_value(baseline);
431    Features = ExtractOutlineFeatures(Blob);
432    NumFeatures = Features->NumFeatures;
433    if (NumFeatures > UNLIKELY_NUM_FEAT || NumFeatures <= 0) {
434      delete Features;
435      return;
436    }
437    Config = new TEMP_CONFIG_STRUCT(NumFeatures - 1, FontinfoId);
438    TempConfigFor(Class, 0) = Config;
439    if (Templates == AdaptedTemplates) {
440      BaselineCutoffs[ClassId] = CharNormCutoffs[ClassId];
441    }
442    IClass = ClassForClassId(Templates->Templates, ClassId);
443    for (Fid = 0; Fid < Features->NumFeatures; Fid++) {
444      Pid = AddIntProto(IClass);
445      assert(Pid != NO_PROTO);
446      Feature = Features->Features[Fid];
447      auto TempProto = new TEMP_PROTO_STRUCT;
448      Proto = &(TempProto->Proto);
449      Proto->Angle = Feature->Params[OutlineFeatDir];
450      Proto->X = Feature->Params[OutlineFeatX];
451      Proto->Y = Feature->Params[OutlineFeatY] - Y_DIM_OFFSET;
452      Proto->Length = Feature->Params[OutlineFeatLength];
453      FillABC(Proto);
454      TempProto->ProtoId = Pid;
455      SET_BIT(Config->Protos, Pid);
456      ConvertProto(Proto, Pid, IClass);
457      AddProtoToProtoPruner(Proto, Pid, IClass, classify_learning_debug_level >= 2);
458      Class->TempProtos = push(Class->TempProtos, TempProto);
459    }
460    delete Features;
461    AddIntConfig(IClass);
462    ConvertConfig(AllProtosOn, 0, IClass);
463    if (classify_learning_debug_level >= 1) {
464      tprintf("Added new class '%s' with class id %d and %d protos.\n",
465              unicharset.id_to_unichar(ClassId), ClassId, NumFeatures);
466  #ifndef GRAPHICS_DISABLED
467      if (classify_learning_debug_level > 1) {
468        DisplayAdaptedChar(Blob, IClass);
469      }
470  #endif
471    }
472    if (IsEmptyAdaptedClass(Class)) {
473      (Templates->NumNonEmptyClasses)++;
474    }
475  } &bsol;* InitAdaptedClass */
476  int Classify::GetAdaptiveFeatures(TBLOB *Blob, INT_FEATURE_ARRAY IntFeatures,
477                                    FEATURE_SET *FloatFeatures) {
478    FEATURE_SET Features;
479    int NumFeatures;
480    classify_norm_method.set_value(baseline);
481    Features = ExtractPicoFeatures(Blob);
482    NumFeatures = Features->NumFeatures;
483    if (NumFeatures == 0 || NumFeatures > UNLIKELY_NUM_FEAT) {
484      delete Features;
485      return 0;
486    }
487    ComputeIntFeatures(Features, IntFeatures);
488    *FloatFeatures = Features;
489    return NumFeatures;
490  } &bsol;* GetAdaptiveFeatures */
491  bool Classify::AdaptableWord(WERD_RES *word) {
492    if (word->best_choice == nullptr) {
493      return false;
494    }
495    auto BestChoiceLength = word->best_choice->length();
496    float adaptable_score = getDict().segment_penalty_dict_case_ok + ADAPTABLE_WERD_ADJUSTMENT;
497    return 
498        BestChoiceLength > 0 && BestChoiceLength == word->rebuild_word->NumBlobs() &&
499        BestChoiceLength <= MAX_ADAPTABLE_WERD_SIZE &&
500        word->best_choice->adjust_factor() <= adaptable_score &&
501        word->AlternativeChoiceAdjustmentsWorseThan(adaptable_score);
502  }
503  void Classify::AdaptToChar(TBLOB *Blob, CLASS_ID ClassId, int FontinfoId, float Threshold,
504                             ADAPT_TEMPLATES_STRUCT *adaptive_templates) {
505    int NumFeatures;
506    INT_FEATURE_ARRAY IntFeatures;
507    UnicharRating int_result;
508    INT_CLASS_STRUCT *IClass;
509    ADAPT_CLASS_STRUCT *Class;
510    TEMP_CONFIG_STRUCT *TempConfig;
511    FEATURE_SET FloatFeatures;
512    int NewTempConfigId;
513    if (!LegalClassId(ClassId)) {
514      return;
515    }
516    int_result.unichar_id = ClassId;
517    Class = adaptive_templates->Class[ClassId];
518    assert(Class != nullptr);
519    if (IsEmptyAdaptedClass(Class)) {
520      InitAdaptedClass(Blob, ClassId, FontinfoId, Class, adaptive_templates);
521    } else {
522      IClass = ClassForClassId(adaptive_templates->Templates, ClassId);
523      NumFeatures = GetAdaptiveFeatures(Blob, IntFeatures, &FloatFeatures);
524      if (NumFeatures <= 0) {
525        return; 
526      }
527      BIT_VECTOR MatchingFontConfigs = NewBitVector(MAX_NUM_PROTOS);
528      for (int cfg = 0; cfg < IClass->NumConfigs; ++cfg) {
529        if (GetFontinfoId(Class, cfg) == FontinfoId) {
530          SET_BIT(MatchingFontConfigs, cfg);
531        } else {
532          reset_bit(MatchingFontConfigs, cfg);
533        }
534      }
535      im_.Match(IClass, AllProtosOn, MatchingFontConfigs, NumFeatures, IntFeatures, &int_result,
536                classify_adapt_feature_threshold, NO_DEBUG, matcher_debug_separate_windows);
537      FreeBitVector(MatchingFontConfigs);
538      SetAdaptiveThreshold(Threshold);
539      if (1.0f - int_result.rating <= Threshold) {
540        if (ConfigIsPermanent(Class, int_result.config)) {
541          if (classify_learning_debug_level >= 1) {
542            tprintf("Found good match to perm config %d = %4.1f%%.\n", int_result.config,
543                    int_result.rating * 100.0);
544          }
545          delete FloatFeatures;
546          return;
547        }
548        TempConfig = TempConfigFor(Class, int_result.config);
549        IncreaseConfidence(TempConfig);
550        if (TempConfig->NumTimesSeen > Class->MaxNumTimesSeen) {
551          Class->MaxNumTimesSeen = TempConfig->NumTimesSeen;
552        }
553        if (classify_learning_debug_level >= 1) {
554          tprintf("Increasing reliability of temp config %d to %d.\n", int_result.config,
555                  TempConfig->NumTimesSeen);
556        }
557        if (TempConfigReliable(ClassId, TempConfig)) {
558          MakePermanent(adaptive_templates, ClassId, int_result.config, Blob);
559          UpdateAmbigsGroup(ClassId, Blob);
560        }
561      } else {
562        if (classify_learning_debug_level >= 1) {
563          tprintf("Found poor match to temp config %d = %4.1f%%.\n", int_result.config,
564                  int_result.rating * 100.0);
565  #ifndef GRAPHICS_DISABLED
566          if (classify_learning_debug_level > 2) {
567            DisplayAdaptedChar(Blob, IClass);
568          }
569  #endif
570        }
571        NewTempConfigId = MakeNewTemporaryConfig(adaptive_templates, ClassId, FontinfoId, NumFeatures,
572                                                 IntFeatures, FloatFeatures);
573        if (NewTempConfigId >= 0 &&
574            TempConfigReliable(ClassId, TempConfigFor(Class, NewTempConfigId))) {
575          MakePermanent(adaptive_templates, ClassId, NewTempConfigId, Blob);
576          UpdateAmbigsGroup(ClassId, Blob);
577        }
578  #ifndef GRAPHICS_DISABLED
579        if (classify_learning_debug_level > 1) {
580          DisplayAdaptedChar(Blob, IClass);
581        }
582  #endif
583      }
584      delete FloatFeatures;
585    }
586  } &bsol;* AdaptToChar */
587  #ifndef GRAPHICS_DISABLED
588  void Classify::DisplayAdaptedChar(TBLOB *blob, INT_CLASS_STRUCT *int_class) {
589    INT_FX_RESULT_STRUCT fx_info;
590    std::vector<INT_FEATURE_STRUCT> bl_features;
591    TrainingSample *sample =
592        BlobToTrainingSample(*blob, classify_nonlinear_norm, &fx_info, &bl_features);
593    if (sample == nullptr) {
594      return;
595    }
596    UnicharRating int_result;
597    im_.Match(int_class, AllProtosOn, AllConfigsOn, bl_features.size(), &bl_features[0], &int_result,
598              classify_adapt_feature_threshold, NO_DEBUG, matcher_debug_separate_windows);
599    tprintf("Best match to temp config %d = %4.1f%%.\n", int_result.config,
600            int_result.rating * 100.0);
601    if (classify_learning_debug_level >= 2) {
602      uint32_t ConfigMask;
603      ConfigMask = 1 << int_result.config;
604      ShowMatchDisplay();
605      im_.Match(int_class, AllProtosOn, static_cast<BIT_VECTOR>(&ConfigMask), bl_features.size(),
606                &bl_features[0], &int_result, classify_adapt_feature_threshold, 6 | 0x19,
607                matcher_debug_separate_windows);
608      UpdateMatchDisplay();
609    }
610    delete sample;
611  }
612  #endif
613  void Classify::AddNewResult(const UnicharRating &new_result, ADAPT_RESULTS *results) {
614    auto old_match = FindScoredUnichar(new_result.unichar_id, *results);
615    if (new_result.rating + matcher_bad_match_pad < results->best_rating ||
616        (old_match < results->match.size() &&
617         new_result.rating <= results->match[old_match].rating)) {
618      return; 
619    }
620    if (!unicharset.get_fragment(new_result.unichar_id)) {
621      results->HasNonfragment = true;
622    }
623    if (old_match < results->match.size()) {
624      results->match[old_match].rating = new_result.rating;
625    } else {
626      results->match.push_back(new_result);
627    }
628    if (new_result.rating > results->best_rating &&
629        !unicharset.get_fragment(new_result.unichar_id)) {
630      results->best_match_index = old_match;
631      results->best_rating = new_result.rating;
632      results->best_unichar_id = new_result.unichar_id;
633    }
634  } &bsol;* AddNewResult */
635  void Classify::AmbigClassifier(const std::vector<INT_FEATURE_STRUCT> &int_features,
636                                 const INT_FX_RESULT_STRUCT &fx_info, const TBLOB *blob,
637                                 INT_TEMPLATES_STRUCT *templates, ADAPT_CLASS_STRUCT **classes,
638                                 UNICHAR_ID *ambiguities, ADAPT_RESULTS *results) {
639    if (int_features.empty()) {
640      return;
641    }
642    auto *CharNormArray = new uint8_t[unicharset.size()];
643    UnicharRating int_result;
644    results->BlobLength = GetCharNormFeature(fx_info, templates, nullptr, CharNormArray);
645    bool debug = matcher_debug_level >= 2 || classify_debug_level > 1;
646    if (debug) {
647      tprintf("AM Matches =  ");
648    }
649    int top = blob->bounding_box().top();
650    int bottom = blob->bounding_box().bottom();
651    while (*ambiguities >= 0) {
652      CLASS_ID class_id = *ambiguities;
653      int_result.unichar_id = class_id;
654      im_.Match(ClassForClassId(templates, class_id), AllProtosOn, AllConfigsOn, int_features.size(),
655                &int_features[0], &int_result, classify_adapt_feature_threshold, NO_DEBUG,
656                matcher_debug_separate_windows);
657      ExpandShapesAndApplyCorrections(nullptr, debug, class_id, bottom, top, 0, results->BlobLength,
658                                      classify_integer_matcher_multiplier, CharNormArray, &int_result,
659                                      results);
660      ambiguities++;
661    }
662    delete[] CharNormArray;
663  } &bsol;* AmbigClassifier */
664  void Classify::MasterMatcher(INT_TEMPLATES_STRUCT *templates, int16_t num_features,
665                               const INT_FEATURE_STRUCT *features, const uint8_t *norm_factors,
666                               ADAPT_CLASS_STRUCT **classes, int debug, int matcher_multiplier,
667                               const TBOX &blob_box, const std::vector<CP_RESULT_STRUCT> &results,
668                               ADAPT_RESULTS *final_results) {
669    int top = blob_box.top();
670    int bottom = blob_box.bottom();
671    UnicharRating int_result;
672    for (auto &&result : results) {
673      CLASS_ID class_id = result.Class;
674      BIT_VECTOR protos = classes != nullptr ? classes[class_id]->PermProtos : AllProtosOn;
675      BIT_VECTOR configs = classes != nullptr ? classes[class_id]->PermConfigs : AllConfigsOn;
676      int_result.unichar_id = class_id;
677      im_.Match(ClassForClassId(templates, class_id), protos, configs, num_features, features,
678                &int_result, classify_adapt_feature_threshold, debug, matcher_debug_separate_windows);
679      bool is_debug = matcher_debug_level >= 2 || classify_debug_level > 1;
680      ExpandShapesAndApplyCorrections(classes, is_debug, class_id, bottom, top, result.Rating,
681                                      final_results->BlobLength, matcher_multiplier, norm_factors,
682                                      &int_result, final_results);
683    }
684  }
685  void Classify::ExpandShapesAndApplyCorrections(ADAPT_CLASS_STRUCT **classes, bool debug, int class_id,
686                                                 int bottom, int top, float cp_rating,
687                                                 int blob_length, int matcher_multiplier,
688                                                 const uint8_t *cn_factors, UnicharRating *int_result,
689                                                 ADAPT_RESULTS *final_results) {
690    if (classes != nullptr) {
691      int_result->adapted = true;
692      for (auto &font : int_result->fonts) {
693        font.fontinfo_id = GetFontinfoId(classes[class_id], font.fontinfo_id);
694      }
695    } else {
696      int_result->adapted = false;
697      for (auto &font : int_result->fonts) {
698        font.fontinfo_id = ClassAndConfigIDToFontOrShapeID(class_id, font.fontinfo_id);
699      }
700      if (shape_table_ != nullptr) {
701        std::vector<UnicharRating> mapped_results;
702        for (auto &f : int_result->fonts) {
703          int shape_id = f.fontinfo_id;
704          const Shape &shape = shape_table_->GetShape(shape_id);
705          for (int c = 0; c < shape.size(); ++c) {
706            int unichar_id = shape[c].unichar_id;
707            if (!unicharset.get_enabled(unichar_id)) {
708              continue;
709            }
710            unsigned r = 0;
711            for (r = 0; r < mapped_results.size() && mapped_results[r].unichar_id != unichar_id;
712                 ++r) {
713            }
714            if (r == mapped_results.size()) {
715              mapped_results.push_back(*int_result);
716              mapped_results[r].unichar_id = unichar_id;
717              mapped_results[r].fonts.clear();
718            }
719            for (int font_id : shape[c].font_ids) {
720              mapped_results[r].fonts.emplace_back(font_id, f.score);
721            }
722          }
723        }
724        for (auto &m : mapped_results) {
725          m.rating = ComputeCorrectedRating(debug, m.unichar_id, cp_rating, int_result->rating,
726                                            int_result->feature_misses, bottom, top, blob_length,
727                                            matcher_multiplier, cn_factors);
728          AddNewResult(m, final_results);
729        }
730        return;
731      }
732    }
733    if (unicharset.get_enabled(class_id)) {
734      int_result->rating = ComputeCorrectedRating(debug, class_id, cp_rating, int_result->rating,
735                                                  int_result->feature_misses, bottom, top,
736                                                  blob_length, matcher_multiplier, cn_factors);
737      AddNewResult(*int_result, final_results);
738    }
739  }
740  double Classify::ComputeCorrectedRating(bool debug, int unichar_id, double cp_rating,
741                                          double im_rating, int feature_misses, int bottom, int top,
742                                          int blob_length, int matcher_multiplier,
743                                          const uint8_t *cn_factors) {
744    double cn_corrected = im_.ApplyCNCorrection(1.0 - im_rating, blob_length, cn_factors[unichar_id],
745                                                matcher_multiplier);
746    double miss_penalty = tessedit_class_miss_scale * feature_misses;
747    double vertical_penalty = 0.0;
748    if (!unicharset.get_isalpha(unichar_id) && !unicharset.get_isdigit(unichar_id) &&
749        cn_factors[unichar_id] != 0 && classify_misfit_junk_penalty > 0.0) {
750      int min_bottom, max_bottom, min_top, max_top;
751      unicharset.get_top_bottom(unichar_id, &min_bottom, &max_bottom, &min_top, &max_top);
752      if (debug) {
753        tprintf("top=%d, vs [%d, %d], bottom=%d, vs [%d, %d]\n", top, min_top, max_top, bottom,
754                min_bottom, max_bottom);
755      }
756      if (top < min_top || top > max_top || bottom < min_bottom || bottom > max_bottom) {
757        vertical_penalty = classify_misfit_junk_penalty;
758      }
759    }
760    double result = 1.0 - (cn_corrected + miss_penalty + vertical_penalty);
761    if (result < WORST_POSSIBLE_RATING) {
762      result = WORST_POSSIBLE_RATING;
763    }
764    if (debug) {
765      tprintf("%s: %2.1f%%(CP%2.1f, IM%2.1f + CN%.2f(%d) + MP%2.1f + VP%2.1f)\n",
766              unicharset.id_to_unichar(unichar_id), result * 100.0, cp_rating * 100.0,
767              (1.0 - im_rating) * 100.0, (cn_corrected - (1.0 - im_rating)) * 100.0,
768              cn_factors[unichar_id], miss_penalty * 100.0, vertical_penalty * 100.0);
769    }
770    return result;
771  }
772  UNICHAR_ID *Classify::BaselineClassifier(TBLOB *Blob,
773                                           const std::vector<INT_FEATURE_STRUCT> &int_features,
774                                           const INT_FX_RESULT_STRUCT &fx_info,
775                                           ADAPT_TEMPLATES_STRUCT *Templates, ADAPT_RESULTS *Results) {
776    if (int_features.empty()) {
777      return nullptr;
778    }
779    auto *CharNormArray = new uint8_t[unicharset.size()];
780    ClearCharNormArray(CharNormArray);
781    Results->BlobLength = IntCastRounded(fx_info.Length / kStandardFeatureLength);
782    PruneClasses(Templates->Templates, int_features.size(), -1, &int_features[0], CharNormArray,
783                 BaselineCutoffs, &Results->CPResults);
784    if (matcher_debug_level >= 2 || classify_debug_level > 1) {
785      tprintf("BL Matches =  ");
786    }
787    MasterMatcher(Templates->Templates, int_features.size(), &int_features[0], CharNormArray,
788                  Templates->Class, matcher_debug_flags, 0, Blob->bounding_box(), Results->CPResults,
789                  Results);
790    delete[] CharNormArray;
791    CLASS_ID ClassId = Results->best_unichar_id;
792    if (ClassId == INVALID_UNICHAR_ID || Results->best_match_index < 0) {
793      return nullptr;
794    }
795    return Templates->Class[ClassId]
796        ->Config[Results->match[Results->best_match_index].config]
797        .Perm->Ambigs;
798  } &bsol;* BaselineClassifier */
799  int Classify::CharNormClassifier(TBLOB *blob, const TrainingSample &sample,
800                                   ADAPT_RESULTS *adapt_results) {
801    adapt_results->BlobLength = IntCastRounded(sample.outline_length() / kStandardFeatureLength);
802    std::vector<UnicharRating> unichar_results;
803    static_classifier_->UnicharClassifySample(sample, blob->denorm().pix(), 0, -1, &unichar_results);
804    for (auto &r : unichar_results) {
805      AddNewResult(r, adapt_results);
806    }
807    return sample.num_features();
808  } &bsol;* CharNormClassifier */
809  int Classify::CharNormTrainingSample(bool pruner_only, int keep_this, const TrainingSample &sample,
810                                       std::vector<UnicharRating> *results) {
811    results->clear();
812    std::unique_ptr<ADAPT_RESULTS> adapt_results(new ADAPT_RESULTS());
813    adapt_results->Initialize();
814    uint32_t num_features = sample.num_features();
815    TBOX blob_box(sample.geo_feature(GeoBottom), sample.geo_feature(GeoBottom),
816                  sample.geo_feature(GeoTop), sample.geo_feature(GeoTop));
817    FEATURE norm_feature = sample.GetCNFeature();
818    std::vector<uint8_t> char_norm_array(unicharset.size());
819    auto num_pruner_classes = std::max(static_cast<unsigned>(unicharset.size()), PreTrainedTemplates->NumClasses);
820    std::vector<uint8_t> pruner_norm_array(num_pruner_classes);
821    adapt_results->BlobLength = static_cast<int>(ActualOutlineLength(norm_feature) * 20 + 0.5f);
822    ComputeCharNormArrays(norm_feature, PreTrainedTemplates, &char_norm_array[0], &pruner_norm_array[0]);
823    PruneClasses(PreTrainedTemplates, num_features, keep_this, sample.features(), &pruner_norm_array[0],
824                 shape_table_ != nullptr ? &shapetable_cutoffs_[0] : CharNormCutoffs,
825                 &adapt_results->CPResults);
826    if (keep_this >= 0) {
827      adapt_results->CPResults[0].Class = keep_this;
828      adapt_results->CPResults.resize(1);
829    }
830    if (pruner_only) {
831      for (auto &it : adapt_results->CPResults) {
832        int class_id = it.Class;
833        results->push_back(UnicharRating(class_id, 1.0f - it.Rating));
834      }
835    } else {
836      MasterMatcher(PreTrainedTemplates, num_features, sample.features(), &char_norm_array[0], nullptr,
837                    matcher_debug_flags, classify_integer_matcher_multiplier, blob_box,
838                    adapt_results->CPResults, adapt_results.get());
839      for (auto &i : adapt_results->match) {
840        results->push_back(i);
841      }
842      if (results->size() > 1) {
843        std::sort(results->begin(), results->end(), SortDescendingRating);
844      }
845    }
846    return num_features;
847  } &bsol;* CharNormTrainingSample */
848  void Classify::ClassifyAsNoise(ADAPT_RESULTS *results) {
849    float rating = results->BlobLength / matcher_avg_noise_size;
850    rating *= rating;
851    rating /= 1 + rating;
852    AddNewResult(UnicharRating(UNICHAR_SPACE, 1.0f - rating), results);
853  } &bsol;* ClassifyAsNoise */
854  void Classify::ConvertMatchesToChoices(const DENORM &denorm, const TBOX &box,
855                                         ADAPT_RESULTS *Results, BLOB_CHOICE_LIST *Choices) {
856    assert(Choices != nullptr);
857    float Rating;
858    float Certainty;
859    BLOB_CHOICE_IT temp_it;
860    bool contains_nonfrag = false;
861    temp_it.set_to_list(Choices);
862    int choices_length = 0;
863    int max_matches = MAX_MATCHES;
864    if (shape_table_ != nullptr) {
865      max_matches = shape_table_->MaxNumUnichars() * 2;
866      if (max_matches < MAX_MATCHES) {
867        max_matches = MAX_MATCHES;
868      }
869    }
870    float best_certainty = -FLT_MAX;
871    for (auto &it : Results->match) {
872      const UnicharRating &result = it;
873      bool adapted = result.adapted;
874      bool current_is_frag = (unicharset.get_fragment(result.unichar_id) != nullptr);
875      if (temp_it.length() + 1 == max_matches && !contains_nonfrag && current_is_frag) {
876        continue; 
877      }
878      if (Results->BlobLength == 0) {
879        Certainty = -20;
880        Rating = 100; 
881      } else {
882        Rating = Certainty = (1.0f - result.rating);
883        Rating *= rating_scale * Results->BlobLength;
884        Certainty *= -(getDict().certainty_scale);
885      }
886      if (Certainty > best_certainty) {
887        best_certainty = std::min(Certainty, static_cast<float>(classify_adapted_pruning_threshold));
888      } else if (adapted && Certainty / classify_adapted_pruning_factor < best_certainty) {
889        continue; 
890      }
891      float min_xheight, max_xheight, yshift;
892      denorm.XHeightRange(result.unichar_id, unicharset, box, &min_xheight, &max_xheight, &yshift);
893      auto *choice = new BLOB_CHOICE(
894          result.unichar_id, Rating, Certainty, unicharset.get_script(result.unichar_id), min_xheight,
895          max_xheight, yshift, adapted ? BCC_ADAPTED_CLASSIFIER : BCC_STATIC_CLASSIFIER);
896      choice->set_fonts(result.fonts);
897      temp_it.add_to_end(choice);
898      contains_nonfrag |= !current_is_frag; 
899      choices_length++;
900      if (choices_length >= max_matches) {
901        break;
902      }
903    }
904    Results->match.resize(choices_length);
905  } 
906  #ifndef GRAPHICS_DISABLED
907  void Classify::DebugAdaptiveClassifier(TBLOB *blob, ADAPT_RESULTS *Results) {
908    if (static_classifier_ == nullptr) {
909      return;
910    }
911    INT_FX_RESULT_STRUCT fx_info;
912    std::vector<INT_FEATURE_STRUCT> bl_features;
913    TrainingSample *sample = BlobToTrainingSample(*blob, false, &fx_info, &bl_features);
914    if (sample == nullptr) {
915      return;
916    }
917    static_classifier_->DebugDisplay(*sample, blob->denorm().pix(), Results->best_unichar_id);
918  } &bsol;* DebugAdaptiveClassifier */
919  #endif
920  void Classify::DoAdaptiveMatch(TBLOB *Blob, ADAPT_RESULTS *Results) {
921    UNICHAR_ID *Ambiguities;
922    INT_FX_RESULT_STRUCT fx_info;
923    std::vector<INT_FEATURE_STRUCT> bl_features;
924    TrainingSample *sample =
925        BlobToTrainingSample(*Blob, classify_nonlinear_norm, &fx_info, &bl_features);
926    if (sample == nullptr) {
927      return;
928    }
929    if (static_classifier_ == nullptr) {
930      delete sample;
931      return;
932    }
933    if (AdaptedTemplates->NumPermClasses < matcher_permanent_classes_min || tess_cn_matching) {
934      CharNormClassifier(Blob, *sample, Results);
935    } else {
936      Ambiguities = BaselineClassifier(Blob, bl_features, fx_info, AdaptedTemplates, Results);
937      if ((!Results->match.empty() &&
938           MarginalMatch(Results->best_rating, matcher_reliable_adaptive_result) &&
939           !tess_bn_matching) ||
940          Results->match.empty()) {
941        CharNormClassifier(Blob, *sample, Results);
942      } else if (Ambiguities && *Ambiguities >= 0 && !tess_bn_matching) {
943        AmbigClassifier(bl_features, fx_info, Blob, PreTrainedTemplates, AdaptedTemplates->Class,
944                        Ambiguities, Results);
945      }
946    }
947    if (!Results->HasNonfragment || Results->match.empty()) {
948      ClassifyAsNoise(Results);
949    }
950    delete sample;
951  } &bsol;* DoAdaptiveMatch */
952  UNICHAR_ID *Classify::GetAmbiguities(TBLOB *Blob, CLASS_ID CorrectClass) {
953    auto *Results = new ADAPT_RESULTS();
954    UNICHAR_ID *Ambiguities;
955    Results->Initialize();
956    INT_FX_RESULT_STRUCT fx_info;
957    std::vector<INT_FEATURE_STRUCT> bl_features;
958    TrainingSample *sample =
959        BlobToTrainingSample(*Blob, classify_nonlinear_norm, &fx_info, &bl_features);
960    if (sample == nullptr) {
961      delete Results;
962      return nullptr;
963    }
964    CharNormClassifier(Blob, *sample, Results);
965    delete sample;
966    RemoveBadMatches(Results);
967    std::sort(Results->match.begin(), Results->match.end(), SortDescendingRating);
968    Ambiguities = new UNICHAR_ID[Results->match.size() + 1];
969    if (Results->match.size() > 1 ||
970        (Results->match.size() == 1 && Results->match[0].unichar_id != CorrectClass)) {
971      unsigned i;
972      for (i = 0; i < Results->match.size(); i++) {
973        Ambiguities[i] = Results->match[i].unichar_id;
974      }
975      Ambiguities[i] = -1;
976    } else {
977      Ambiguities[0] = -1;
978    }
979    delete Results;
980    return Ambiguities;
981  } &bsol;* GetAmbiguities */
982  bool Classify::LooksLikeGarbage(TBLOB *blob) {
983    auto *ratings = new BLOB_CHOICE_LIST();
984    AdaptiveClassifier(blob, ratings);
985    BLOB_CHOICE_IT ratings_it(ratings);
986    const UNICHARSET &unicharset = getDict().getUnicharset();
987    if (classify_debug_character_fragments) {
988      print_ratings_list("======================\nLooksLikeGarbage() got ", ratings, unicharset);
989    }
990    for (ratings_it.mark_cycle_pt(); !ratings_it.cycled_list(); ratings_it.forward()) {
991      if (unicharset.get_fragment(ratings_it.data()->unichar_id()) != nullptr) {
992        continue;
993      }
994      float certainty = ratings_it.data()->certainty();
995      delete ratings;
996      return certainty < classify_character_fragments_garbage_certainty_threshold;
997    }
998    delete ratings;
999    return true; 
1000  }
1001  int Classify::GetCharNormFeature(const INT_FX_RESULT_STRUCT &fx_info, INT_TEMPLATES_STRUCT *templates,
1002                                   uint8_t *pruner_norm_array, uint8_t *char_norm_array) {
1003    auto norm_feature = new FEATURE_STRUCT(&CharNormDesc);
1004    float baseline = kBlnBaselineOffset;
1005    float scale = MF_SCALE_FACTOR;
1006    norm_feature->Params[CharNormY] = (fx_info.Ymean - baseline) * scale;
1007    norm_feature->Params[CharNormLength] = fx_info.Length * scale / LENGTH_COMPRESSION;
1008    norm_feature->Params[CharNormRx] = fx_info.Rx * scale;
1009    norm_feature->Params[CharNormRy] = fx_info.Ry * scale;
1010    ComputeCharNormArrays(norm_feature, templates, char_norm_array, pruner_norm_array);
1011    return IntCastRounded(fx_info.Length / kStandardFeatureLength);
1012  } &bsol;* GetCharNormFeature */
1013  void Classify::ComputeCharNormArrays(FEATURE_STRUCT *norm_feature, INT_TEMPLATES_STRUCT *templates,
1014                                       uint8_t *char_norm_array, uint8_t *pruner_array) {
1015    ComputeIntCharNormArray(*norm_feature, char_norm_array);
1016      if (shape_table_ == nullptr) {
1017        ComputeIntCharNormArray(*norm_feature, pruner_array);
1018      } else {
1019        memset(&pruner_array[0], UINT8_MAX, templates->NumClasses * sizeof(pruner_array[0]));
1020        for (unsigned id = 0; id < templates->NumClasses; ++id) {
1021          int font_set_id = templates->Class[id]->font_set_id;
1022          const FontSet &fs = fontset_table_.at(font_set_id);
1023          for (auto f : fs) {
1024            const Shape &shape = shape_table_->GetShape(f);
1025            for (int c = 0; c < shape.size(); ++c) {
1026              if (char_norm_array[shape[c].unichar_id] < pruner_array[id]) {
1027                pruner_array[id] = char_norm_array[shape[c].unichar_id];
1028              }
1029            }
1030          }
1031        }
1032      }
1033    delete norm_feature;
1034  }
1035  int Classify::MakeNewTemporaryConfig(ADAPT_TEMPLATES_STRUCT *Templates, CLASS_ID ClassId, int FontinfoId,
1036                                       int NumFeatures, INT_FEATURE_ARRAY Features,
1037                                       FEATURE_SET FloatFeatures) {
1038    INT_CLASS_STRUCT *IClass;
1039    ADAPT_CLASS_STRUCT *Class;
1040    PROTO_ID OldProtos[MAX_NUM_PROTOS];
1041    FEATURE_ID BadFeatures[MAX_NUM_INT_FEATURES];
1042    int NumOldProtos;
1043    int NumBadFeatures;
1044    int MaxProtoId, OldMaxProtoId;
1045    int MaskSize;
1046    int ConfigId;
1047    int i;
1048    int debug_level = NO_DEBUG;
1049    if (classify_learning_debug_level >= 3) {
1050      debug_level = PRINT_MATCH_SUMMARY | PRINT_FEATURE_MATCHES | PRINT_PROTO_MATCHES;
1051    }
1052    IClass = ClassForClassId(Templates->Templates, ClassId);
1053    Class = Templates->Class[ClassId];
1054    if (IClass->NumConfigs >= MAX_NUM_CONFIGS) {
1055      ++NumAdaptationsFailed;
1056      if (classify_learning_debug_level >= 1) {
1057        tprintf("Cannot make new temporary config: maximum number exceeded.\n");
1058      }
1059      return -1;
1060    }
1061    OldMaxProtoId = IClass->NumProtos - 1;
1062    NumOldProtos = im_.FindGoodProtos(IClass, AllProtosOn, AllConfigsOff, NumFeatures, Features,
1063                                      OldProtos, classify_adapt_proto_threshold, debug_level);
1064    MaskSize = WordsInVectorOfSize(MAX_NUM_PROTOS);
1065    zero_all_bits(TempProtoMask, MaskSize);
1066    for (i = 0; i < NumOldProtos; i++) {
1067      SET_BIT(TempProtoMask, OldProtos[i]);
1068    }
1069    NumBadFeatures = im_.FindBadFeatures(IClass, TempProtoMask, AllConfigsOn, NumFeatures, Features,
1070                                         BadFeatures, classify_adapt_feature_threshold, debug_level);
1071    MaxProtoId =
1072        MakeNewTempProtos(FloatFeatures, NumBadFeatures, BadFeatures, IClass, Class, TempProtoMask);
1073    if (MaxProtoId == NO_PROTO) {
1074      ++NumAdaptationsFailed;
1075      if (classify_learning_debug_level >= 1) {
1076        tprintf("Cannot make new temp protos: maximum number exceeded.\n");
1077      }
1078      return -1;
1079    }
1080    ConfigId = AddIntConfig(IClass);
1081    ConvertConfig(TempProtoMask, ConfigId, IClass);
1082    auto Config = new TEMP_CONFIG_STRUCT(MaxProtoId, FontinfoId);
1083    TempConfigFor(Class, ConfigId) = Config;
1084    copy_all_bits(TempProtoMask, Config->Protos, Config->ProtoVectorSize);
1085    if (classify_learning_debug_level >= 1) {
1086      tprintf(
1087          "Making new temp config %d fontinfo id %d"
1088          " using %d old and %d new protos.\n",
1089          ConfigId, Config->FontinfoId, NumOldProtos, MaxProtoId - OldMaxProtoId);
1090    }
1091    return ConfigId;
1092  } &bsol;* MakeNewTemporaryConfig */
1093  PROTO_ID Classify::MakeNewTempProtos(FEATURE_SET Features, int NumBadFeat, FEATURE_ID BadFeat[],
1094                                       INT_CLASS_STRUCT *IClass, ADAPT_CLASS_STRUCT *Class,
1095                                       BIT_VECTOR TempProtoMask) {
1096    FEATURE_ID *ProtoStart;
1097    FEATURE_ID *ProtoEnd;
1098    FEATURE_ID *LastBad;
1099    PROTO_STRUCT *Proto;
1100    FEATURE F1, F2;
1101    float X1, X2, Y1, Y2;
1102    float A1, A2, AngleDelta;
1103    float SegmentLength;
1104    PROTO_ID Pid;
1105    for (ProtoStart = BadFeat, LastBad = ProtoStart + NumBadFeat; ProtoStart < LastBad;
1106         ProtoStart = ProtoEnd) {
1107      F1 = Features->Features[*ProtoStart];
1108      X1 = F1->Params[PicoFeatX];
1109      Y1 = F1->Params[PicoFeatY];
1110      A1 = F1->Params[PicoFeatDir];
1111      for (ProtoEnd = ProtoStart + 1, SegmentLength = GetPicoFeatureLength(); ProtoEnd < LastBad;
1112           ProtoEnd++, SegmentLength += GetPicoFeatureLength()) {
1113        F2 = Features->Features[*ProtoEnd];
1114        X2 = F2->Params[PicoFeatX];
1115        Y2 = F2->Params[PicoFeatY];
1116        A2 = F2->Params[PicoFeatDir];
1117        AngleDelta = std::fabs(A1 - A2);
1118        if (AngleDelta > 0.5f) {
1119          AngleDelta = 1 - AngleDelta;
1120        }
1121        if (AngleDelta > matcher_clustering_max_angle_delta || std::fabs(X1 - X2) > SegmentLength ||
1122            std::fabs(Y1 - Y2) > SegmentLength) {
1123          break;
1124        }
1125      }
1126      F2 = Features->Features[*(ProtoEnd - 1)];
1127      X2 = F2->Params[PicoFeatX];
1128      Y2 = F2->Params[PicoFeatY];
1129      A2 = F2->Params[PicoFeatDir];
1130      Pid = AddIntProto(IClass);
1131      if (Pid == NO_PROTO) {
1132        return (NO_PROTO);
1133      }
1134      auto TempProto = new TEMP_PROTO_STRUCT;
1135      Proto = &(TempProto->Proto);
1136      Proto->Length = SegmentLength;
1137      Proto->Angle = A1;
1138      Proto->X = (X1 + X2) / 2;
1139      Proto->Y = (Y1 + Y2) / 2 - Y_DIM_OFFSET;
1140      FillABC(Proto);
1141      TempProto->ProtoId = Pid;
1142      SET_BIT(TempProtoMask, Pid);
1143      ConvertProto(Proto, Pid, IClass);
1144      AddProtoToProtoPruner(Proto, Pid, IClass, classify_learning_debug_level >= 2);
1145      Class->TempProtos = push(Class->TempProtos, TempProto);
1146    }
1147    return IClass->NumProtos - 1;
1148  } &bsol;* MakeNewTempProtos */
1149  void Classify::MakePermanent(ADAPT_TEMPLATES_STRUCT *Templates, CLASS_ID ClassId, int ConfigId,
1150                               TBLOB *Blob) {
1151    UNICHAR_ID *Ambigs;
1152    PROTO_KEY ProtoKey;
1153    auto Class = Templates->Class[ClassId];
1154    auto Config = TempConfigFor(Class, ConfigId);
1155    MakeConfigPermanent(Class, ConfigId);
1156    if (Class->NumPermConfigs == 0) {
1157      Templates->NumPermClasses++;
1158    }
1159    Class->NumPermConfigs++;
1160    Ambigs = GetAmbiguities(Blob, ClassId);
1161    auto Perm = new PERM_CONFIG_STRUCT;
1162    Perm->Ambigs = Ambigs;
1163    Perm->FontinfoId = Config->FontinfoId;
1164    ProtoKey.Templates = Templates;
1165    ProtoKey.ClassId = ClassId;
1166    ProtoKey.ConfigId = ConfigId;
1167    Class->TempProtos = delete_d(Class->TempProtos, &ProtoKey, MakeTempProtoPerm);
1168    delete Config;
1169    PermConfigFor(Class, ConfigId) = Perm;
1170    if (classify_learning_debug_level >= 1) {
1171      tprintf(
1172          "Making config %d for %s (ClassId %d) permanent:"
1173          " fontinfo id %d, ambiguities '",
1174          ConfigId, getDict().getUnicharset().debug_str(ClassId).c_str(), ClassId,
1175          PermConfigFor(Class, ConfigId)->FontinfoId);
1176      for (UNICHAR_ID *AmbigsPointer = Ambigs; *AmbigsPointer >= 0; ++AmbigsPointer) {
1177        tprintf("%s", unicharset.id_to_unichar(*AmbigsPointer));
1178      }
1179      tprintf("'.\n");
1180    }
1181  } &bsol;* MakePermanent */
1182  int MakeTempProtoPerm(void *item1, void *item2) {
1183    auto TempProto = static_cast<TEMP_PROTO_STRUCT *>(item1);
1184    auto ProtoKey = static_cast<PROTO_KEY *>(item2);
1185    auto Class = ProtoKey->Templates->Class[ProtoKey->ClassId];
1186    auto Config = TempConfigFor(Class, ProtoKey->ConfigId);
1187    if (TempProto->ProtoId > Config->MaxProtoId || !test_bit(Config->Protos, TempProto->ProtoId)) {
1188      return false;
1189    }
1190    MakeProtoPermanent(Class, TempProto->ProtoId);
1191    AddProtoToClassPruner(&(TempProto->Proto), ProtoKey->ClassId, ProtoKey->Templates->Templates);
1192    delete TempProto;
1193    return true;
1194  } &bsol;* MakeTempProtoPerm */
1195  void Classify::PrintAdaptiveMatchResults(const ADAPT_RESULTS &results) {
1196    for (auto &it : results.match) {
1197      tprintf("%s  ", unicharset.debug_str(it.unichar_id).c_str());
1198      it.Print();
1199    }
1200  } &bsol;* PrintAdaptiveMatchResults */
1201  void Classify::RemoveBadMatches(ADAPT_RESULTS *Results) {
1202    unsigned Next, NextGood;
1203    float BadMatchThreshold;
1204    static const char *romans = "i v x I V X";
1205    BadMatchThreshold = Results->best_rating - matcher_bad_match_pad;
1206    if (classify_bln_numeric_mode) {
1207      UNICHAR_ID unichar_id_one =
1208          unicharset.contains_unichar("1") ? unicharset.unichar_to_id("1") : -1;
1209      UNICHAR_ID unichar_id_zero =
1210          unicharset.contains_unichar("0") ? unicharset.unichar_to_id("0") : -1;
1211      float scored_one = ScoredUnichar(unichar_id_one, *Results);
1212      float scored_zero = ScoredUnichar(unichar_id_zero, *Results);
1213      for (Next = NextGood = 0; Next < Results->match.size(); Next++) {
1214        const UnicharRating &match = Results->match[Next];
1215        if (match.rating >= BadMatchThreshold) {
1216          if (!unicharset.get_isalpha(match.unichar_id) ||
1217              strstr(romans, unicharset.id_to_unichar(match.unichar_id)) != nullptr) {
1218          } else if (unicharset.eq(match.unichar_id, "l") && scored_one < BadMatchThreshold) {
1219            Results->match[Next].unichar_id = unichar_id_one;
1220          } else if (unicharset.eq(match.unichar_id, "O") && scored_zero < BadMatchThreshold) {
1221            Results->match[Next].unichar_id = unichar_id_zero;
1222          } else {
1223            Results->match[Next].unichar_id = INVALID_UNICHAR_ID; 
1224          }
1225          if (Results->match[Next].unichar_id != INVALID_UNICHAR_ID) {
1226            if (NextGood == Next) {
1227              ++NextGood;
1228            } else {
1229              Results->match[NextGood++] = Results->match[Next];
1230            }
1231          }
1232        }
1233      }
1234    } else {
1235      for (Next = NextGood = 0; Next < Results->match.size(); Next++) {
1236        if (Results->match[Next].rating >= BadMatchThreshold) {
1237          if (NextGood == Next) {
1238            ++NextGood;
1239          } else {
1240            Results->match[NextGood++] = Results->match[Next];
1241          }
1242        }
1243      }
1244    }
1245    Results->match.resize(NextGood);
1246  } &bsol;* RemoveBadMatches */
1247  void Classify::RemoveExtraPuncs(ADAPT_RESULTS *Results) {
1248    unsigned Next, NextGood;
1249    int punc_count; &bsol;*no of garbage characters */
1250    int digit_count;
1251    static char punc_chars[] = ". , ; : / ` ~ ' - = \\ | \" ! _ ^";
1252    static char digit_chars[] = "0 1 2 3 4 5 6 7 8 9";
1253    punc_count = 0;
1254    digit_count = 0;
1255    for (Next = NextGood = 0; Next < Results->match.size(); Next++) {
1256      const UnicharRating &match = Results->match[Next];
1257      bool keep = true;
1258      if (strstr(punc_chars, unicharset.id_to_unichar(match.unichar_id)) != nullptr) {
1259        if (punc_count >= 2) {
1260          keep = false;
1261        }
1262        punc_count++;
1263      } else {
1264        if (strstr(digit_chars, unicharset.id_to_unichar(match.unichar_id)) != nullptr) {
1265          if (digit_count >= 1) {
1266            keep = false;
1267          }
1268          digit_count++;
1269        }
1270      }
1271      if (keep) {
1272        if (NextGood == Next) {
1273          ++NextGood;
1274        } else {
1275          Results->match[NextGood++] = match;
1276        }
1277      }
1278    }
1279    Results->match.resize(NextGood);
1280  } &bsol;* RemoveExtraPuncs */
1281  void Classify::SetAdaptiveThreshold(float Threshold) {
1282    Threshold = (Threshold == matcher_good_threshold) ? 0.9f : (1 - Threshold);
1283    classify_adapt_proto_threshold.set_value(ClipToRange<int>(255 * Threshold, 0, 255));
1284    classify_adapt_feature_threshold.set_value(ClipToRange<int>(255 * Threshold, 0, 255));
1285  } &bsol;* SetAdaptiveThreshold */
1286  #ifndef GRAPHICS_DISABLED
1287  void Classify::ShowBestMatchFor(int shape_id, const INT_FEATURE_STRUCT *features,
1288                                  int num_features) {
1289    uint32_t config_mask;
1290    if (UnusedClassIdIn(PreTrainedTemplates, shape_id)) {
1291      tprintf("No built-in templates for class/shape %d\n", shape_id);
1292      return;
1293    }
1294    if (num_features <= 0) {
1295      tprintf("Illegal blob (char norm features)!\n");
1296      return;
1297    }
1298    UnicharRating cn_result;
1299    classify_norm_method.set_value(character);
1300    im_.Match(ClassForClassId(PreTrainedTemplates, shape_id), AllProtosOn, AllConfigsOn, num_features,
1301              features, &cn_result, classify_adapt_feature_threshold, NO_DEBUG,
1302              matcher_debug_separate_windows);
1303    tprintf("\n");
1304    config_mask = 1 << cn_result.config;
1305    tprintf("Static Shape ID: %d\n", shape_id);
1306    ShowMatchDisplay();
1307    im_.Match(ClassForClassId(PreTrainedTemplates, shape_id), AllProtosOn, &config_mask, num_features,
1308              features, &cn_result, classify_adapt_feature_threshold, matcher_debug_flags,
1309              matcher_debug_separate_windows);
1310    UpdateMatchDisplay();
1311  } &bsol;* ShowBestMatchFor */
1312  #endif 
1313  std::string Classify::ClassIDToDebugStr(const INT_TEMPLATES_STRUCT *templates, int class_id,
1314                                          int config_id) const {
1315    std::string class_string;
1316    if (templates == PreTrainedTemplates && shape_table_ != nullptr) {
1317      int shape_id = ClassAndConfigIDToFontOrShapeID(class_id, config_id);
1318      class_string = shape_table_->DebugStr(shape_id);
1319    } else {
1320      class_string = unicharset.debug_str(class_id);
1321    }
1322    return class_string;
1323  }
1324  int Classify::ClassAndConfigIDToFontOrShapeID(int class_id, int int_result_config) const {
1325    int font_set_id = PreTrainedTemplates->Class[class_id]->font_set_id;
1326    if (font_set_id < 0) {
1327      return kBlankFontinfoId;
1328    }
1329    const FontSet &fs = fontset_table_.at(font_set_id);
1330    return fs.at(int_result_config);
1331  }
1332  int Classify::ShapeIDToClassID(int shape_id) const {
1333    for (unsigned id = 0; id < PreTrainedTemplates->NumClasses; ++id) {
1334      int font_set_id = PreTrainedTemplates->Class[id]->font_set_id;
1335      ASSERT_HOST(font_set_id >= 0);
1336      const FontSet &fs = fontset_table_.at(font_set_id);
1337      for (auto f : fs) {
1338        if (f == shape_id) {
1339          return id;
1340        }
1341      }
1342    }
1343    tprintf("Shape %d not found\n", shape_id);
1344    return -1;
1345  }
1346  bool Classify::TempConfigReliable(CLASS_ID class_id, const TEMP_CONFIG_STRUCT *config) {
1347    if (classify_learning_debug_level >= 1) {
1348      tprintf("NumTimesSeen for config of %s is %d\n",
1349              getDict().getUnicharset().debug_str(class_id).c_str(), config->NumTimesSeen);
1350    }
1351    if (config->NumTimesSeen >= matcher_sufficient_examples_for_prototyping) {
1352      return true;
1353    } else if (config->NumTimesSeen < matcher_min_examples_for_prototyping) {
1354      return false;
1355    } else if (use_ambigs_for_adaption) {
1356      const UnicharIdVector *ambigs = getDict().getUnicharAmbigs().AmbigsForAdaption(class_id);
1357      int ambigs_size = (ambigs == nullptr) ? 0 : ambigs->size();
1358      for (int ambig = 0; ambig < ambigs_size; ++ambig) {
1359        ADAPT_CLASS_STRUCT *ambig_class = AdaptedTemplates->Class[(*ambigs)[ambig]];
1360        assert(ambig_class != nullptr);
1361        if (ambig_class->NumPermConfigs == 0 &&
1362            ambig_class->MaxNumTimesSeen < matcher_min_examples_for_prototyping) {
1363          if (classify_learning_debug_level >= 1) {
1364            tprintf(
1365                "Ambig %s has not been seen enough times,"
1366                " not making config for %s permanent\n",
1367                getDict().getUnicharset().debug_str((*ambigs)[ambig]).c_str(),
1368                getDict().getUnicharset().debug_str(class_id).c_str());
1369          }
1370          return false;
1371        }
1372      }
1373    }
1374    return true;
1375  }
1376  void Classify::UpdateAmbigsGroup(CLASS_ID class_id, TBLOB *Blob) {
1377    const UnicharIdVector *ambigs = getDict().getUnicharAmbigs().ReverseAmbigsForAdaption(class_id);
1378    int ambigs_size = (ambigs == nullptr) ? 0 : ambigs->size();
1379    if (classify_learning_debug_level >= 1) {
1380      tprintf("Running UpdateAmbigsGroup for %s class_id=%d\n",
1381              getDict().getUnicharset().debug_str(class_id).c_str(), class_id);
1382    }
1383    for (int ambig = 0; ambig < ambigs_size; ++ambig) {
1384      CLASS_ID ambig_class_id = (*ambigs)[ambig];
1385      const ADAPT_CLASS_STRUCT *ambigs_class = AdaptedTemplates->Class[ambig_class_id];
1386      for (int cfg = 0; cfg < MAX_NUM_CONFIGS; ++cfg) {
1387        if (ConfigIsPermanent(ambigs_class, cfg)) {
1388          continue;
1389        }
1390        const TEMP_CONFIG_STRUCT *config = TempConfigFor(AdaptedTemplates->Class[ambig_class_id], cfg);
1391        if (config != nullptr && TempConfigReliable(ambig_class_id, config)) {
1392          if (classify_learning_debug_level >= 1) {
1393            tprintf("Making config %d of %s permanent\n", cfg,
1394                    getDict().getUnicharset().debug_str(ambig_class_id).c_str());
1395          }
1396          MakePermanent(AdaptedTemplates, ambig_class_id, cfg, Blob);
1397        }
1398      }
1399    }
1400  }
1401  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-fpchop.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-adaptmatch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>66    xstarts[0] = box_it.data()->bounding_box().left();
67    if (rep_left < xstarts[0]) {
68      xstarts[0] = rep_left;
69    }
70    if (cell_it.empty() || row->char_cells.singleton()) {
71      tprintf("Row without enough char cells!\n");
72      tprintf("Leftmost blob is at (%d,%d)\n", box_it.data()->bounding_box().left(),
73              box_it.data()->bounding_box().bottom());
</pre></code></div>
                <div class="column column_space"><pre><code>242    TBLOB *rotated_blob = blob->ClassifyNormalizeIfNeeded();
243    if (rotated_blob == nullptr) {
244      rotated_blob = blob;
245    }
246  #ifndef GRAPHICS_DISABLED
247    if (strcmp(classify_learn_debug_str.c_str(), correct_text) == 0) {
248      RefreshDebugWindow(&learn_debug_win_, "LearnPieces", 600, word->chopped_word->bounding_box());
249      rotated_blob->plot(learn_debug_win_, ScrollView::GREEN, ScrollView::BROWN);
250      learn_debug_win_->Update();
251      learn_debug_win_->Wait();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    