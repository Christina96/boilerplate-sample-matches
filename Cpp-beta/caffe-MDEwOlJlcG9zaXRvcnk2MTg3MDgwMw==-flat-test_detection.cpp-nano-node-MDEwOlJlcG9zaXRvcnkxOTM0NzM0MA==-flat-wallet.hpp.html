
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.721030042918455%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_detection.cpp</h3>
            <pre><code>1  #include <gflags/gflags.h>
2  #include <glog/logging.h>
3  #include <cstring>
4  #include <map>
5  #include <string>
6  #include <vector>
7  #include "boost/algorithm/string.hpp"
8  #include "caffe/caffe.hpp"
9  #include "caffe/util/signal_handler.h"
10  #include "caffe/util/benchmark.hpp"
11  using caffe::Blob;
12  using caffe::Caffe;
13  using caffe::Net;
14  using caffe::Layer;
15  using caffe::string;
16  using caffe::vector;
17  using std::map;
18  using std::pair;
19  DEFINE_string(gpu, "",
20      "Optional; run in GPU mode on given device IDs separated by ','."
21      "Use '-gpu all' to run on all available GPUs. The effective training "
22      "batch size is multiplied by the number of devices.");
23  DEFINE_string(model, "",
24      "The model definition protocol buffer text file.");
25  DEFINE_string(weights, "",
26      "Optional; the pretrained weights to initialize finetuning, "
27      "separated by ','. Cannot be set simultaneously with snapshot.");
28  DEFINE_int32(iterations, 50,
29      "The number of iterations to run.");
30  DEFINE_int32(side, 17, "side of image");
31  DEFINE_int32(objects, 5, "num of box for every point");
32  DEFINE_int32(classes, 20, "num of classes");
33  static void get_gpus(vector<int>* gpus) {
34    if (FLAGS_gpu == "all") {
35      int count = 0;
36  #ifndef CPU_ONLY
37      CUDA_CHECK(cudaGetDeviceCount(&count));
38  #else
39      NO_GPU;
40  #endif
41      for (int i = 0; i < count; ++i) {
42        gpus->push_back(i);
43      }
44    } else if (FLAGS_gpu.size()) {
45      vector<string> strings;
46      boost::split(strings, FLAGS_gpu, boost::is_any_of(","));
47      for (int i = 0; i < strings.size(); ++i) {
48        gpus->push_back(boost::lexical_cast<int>(strings[i]));
49      }
50    } else {
51      CHECK_EQ(gpus->size(), 0);
52    }
53  }
54  template <typename T>
55  bool SortScorePairDescend(const pair<float, T>& pair1,
56                            const pair<float, T>& pair2) {
57    return pair1.first > pair2.first;
58  }
59  template bool SortScorePairDescend(const pair<float, int>& pair1,
60                                     const pair<float, int>& pair2);
61  template bool SortScorePairDescend(const pair<float, pair<int, int> >& pair1,
62                                     const pair<float, pair<int, int> >& pair2);
63  void CumSum(const vector<pair<float, int> >& pairs, vector<int>* cumsum) {
64    vector<pair<float, int> > sort_pairs = pairs;
65    std::stable_sort(sort_pairs.begin(), sort_pairs.end(),
66                     SortScorePairDescend<int>);
67    cumsum->clear();
68    for (int i = 0; i < sort_pairs.size(); ++i) {
69      if (i == 0) {
70        cumsum->push_back(sort_pairs[i].second);
71      } else {
72        cumsum->push_back(cumsum->back() + sort_pairs[i].second);
73      }
74    }
75  }
76  void ComputeAP(const vector<pair<float, int> >& tp, const int num_pos,
77                 const vector<pair<float, int> >& fp, const string ap_version,
78                 vector<float>* prec, vector<float>* rec, float* ap) {
79    const float eps = 1e-6;
80    CHECK_EQ(tp.size(), fp.size()) << "tp must have same size as fp.";
81    const int num = tp.size();
82    for (int i = 0; i < num; ++i) {
83      CHECK_LE(fabs(tp[i].first - fp[i].first), eps);
84      CHECK_GE(tp[i].second, 0);
85      CHECK_GE(fp[i].second, 0);
86    }
87    prec->clear();
88    rec->clear();
89    *ap = 0;
90    if (tp.size() == 0 || num_pos == 0) {
91      return;
92    }
93    vector<int> tp_cumsum;
94    CumSum(tp, &tp_cumsum);
95    CHECK_EQ(tp_cumsum.size(), num);
96    vector<int> fp_cumsum;
97    CumSum(fp, &fp_cumsum);
98    CHECK_EQ(fp_cumsum.size(), num);
99    for (int i = 0; i < num; ++i) {
100      prec->push_back(static_cast<float>(tp_cumsum[i]) /
101                      (tp_cumsum[i] + fp_cumsum[i]));
102    }
103    for (int i = 0; i < num; ++i) {
104      CHECK_LE(tp_cumsum[i], num_pos);
105      rec->push_back(static_cast<float>(tp_cumsum[i]) / num_pos);
106    }
107    if (ap_version == "11point") {
108      vector<float> max_precs(11, 0.);
109      int start_idx = num - 1;
110      for (int j = 10; j >= 0; --j) {
111        for (int i = start_idx; i >= 0 ; --i) {
112          if ((*rec)[i] < j / 10.) {
113            start_idx = i;
114            if (j > 0) {
115              max_precs[j-1] = max_precs[j];
116            }
117            break;
118          } else {
119            if (max_precs[j] < (*prec)[i]) {
120              max_precs[j] = (*prec)[i];
121            }
122          }
123        }
124      }
125      for (int j = 10; j >= 0; --j) {
126        *ap += max_precs[j] / 11;
127      }
128    } else if (ap_version == "MaxIntegral") {
129      float cur_rec = rec->back();
130      float cur_prec = prec->back();
131      for (int i = num - 2; i >= 0; --i) {
132        cur_prec = std::max<float>((*prec)[i], cur_prec);
133        if (fabs(cur_rec - (*rec)[i]) > eps) {
134          *ap += cur_prec * fabs(cur_rec - (*rec)[i]);
135        }
136        cur_rec = (*rec)[i];
137      }
138      *ap += cur_rec * cur_prec;
139    } else if (ap_version == "Integral") {
140      float prev_rec = 0.;
141      for (int i = 0; i < num; ++i) {
142        if (fabs((*rec)[i] - prev_rec) > eps) {
143          *ap += (*prec)[i] * fabs((*rec)[i] - prev_rec);
144        }
145        prev_rec = (*rec)[i];
146      }
147    } else {
148      LOG(FATAL) << "Unknown ap_version: " << ap_version;
149    }
150  }
151  int test_detection() {
152    CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to score.";
153    CHECK_GT(FLAGS_weights.size(), 0) << "Need model weights to score.";
154    vector<int> gpus;
155    get_gpus(&gpus);
156    if (gpus.size() != 0) {
157      LOG(INFO) << "Use GPU with device ID " << gpus[0];
158  #ifndef CPU_ONLY
159      cudaDeviceProp device_prop;
160      cudaGetDeviceProperties(&device_prop, gpus[0]);
161      LOG(INFO) << "GPU device name: " << device_prop.name;
162  #endif
163      Caffe::SetDevice(gpus[0]);
164      Caffe::set_mode(Caffe::GPU);
165    } else {
166      LOG(INFO) << "Use CPU.";
167      Caffe::set_mode(Caffe::CPU);
168    }
169    /&bsol;***************************************************
<span onclick='openModal()' class='match'>170    int side = FLAGS_side;			
171    int num_object = FLAGS_objects;	
172    int num_class = FLAGS_classes;	
173    caffe::CPUTimer timer;
174    Net<float> caffe_net(FLAGS_model, caffe::TEST);
175    caffe_net.CopyTrainedLayersFrom(FLAGS_weights);
176    LOG(INFO) << "Running for " << FLAGS_iterations << " iterations.";
177    map<int, map<int, vector<pair<float, int> > > > true_poss, false_poss;
178    map<int, map<int, int> > num_gts;
179    vector<int> test_score_output_id;
180    float loss = 0;
</span>181    int out_size(0);
182    map<int, int> skip_idx;
183    double total_time(0.0);
184    timer.Start();
185    for (int i = 0; i < FLAGS_iterations; ++i) {
186      float iter_loss;
187      const vector<Blob<float>*>& result = caffe_net.Forward(&iter_loss);
188      out_size = result.size();
189      LOG(INFO) << "iter_loss: " << iter_loss;
190      loss += iter_loss;
191      for (int j = 0; j < result.size(); ++j) {
192        if (result[j]->count() == 1) {
193          skip_idx[j] = 0;
194          continue;
195        }
196        const float* result_data = result[j]->cpu_data();
197        for (int k = 0; k < result[j]->num(); ++k) {
198          int res_index = k * result[j]->count(1);
199          for (int c = 0; c < num_class; ++c) {
200            if (num_gts[j].find(c) == num_gts[j].end()) {
201              num_gts[j][c] = static_cast<int>(result_data[res_index + c]);
202            } else {
203              num_gts[j][c] += static_cast<int>(result_data[res_index + c]);
204            }
205          }
206          int all_obj_num = side * side * num_object;
207          int obj_index = res_index + num_class;
208          for (int b = 0; b < all_obj_num; ++b) {
209            int label = static_cast<int>(result_data[obj_index + b * 4 + 0]);
210            float score = result_data[obj_index + b * 4 + 1];
211            int tp = static_cast<int>(result_data[obj_index + b * 4 + 2]);
212            int fp = static_cast<int>(result_data[obj_index + b * 4 + 3]);
213            true_poss[j][label].push_back(std::make_pair(score, tp));
214            false_poss[j][label].push_back(std::make_pair(score, fp));
215          }
216        }
217      }
218      LOG(INFO) << "Running Iteration " << i;
219    }
220    total_time += timer.MicroSeconds();
221    LOG(INFO) << "Total time: " << total_time / 1000 << " ms.";
222    for (int i = 0; i < out_size; ++i) {
223      if (skip_idx.find(i) != skip_idx.end()) {
224        continue;
225      }
226      map<int, vector<pair<float, int> > > true_pos = true_poss[i];
227      map<int, vector<pair<float, int> > > false_pos = false_poss[i];
228      map<int, int> num_gt = num_gts[i];
229      map<int, float> APs;
230      float mAP = 0.;
231      for (int j = 0; j < num_class; ++j) {
232        if (!num_gt[j]) {
233          LOG(WARNING) << "Ground trurh label number is 0: " << j;
234          continue;
235        } 
236        if (true_pos.find(j) == true_pos.end()) {
237          LOG(WARNING) << "Missing true_pos for label: " << j;
238          continue;
239        }
240        if (false_pos.find(j) == false_pos.end()) {
241          LOG(WARNING) << "Missing false_pos for label: " << j;
242          continue;
243        }
244        string ap_version = "11point";
245        vector<float> prec, rec;
246        ComputeAP(true_pos[j], num_gt[j], false_pos[j], ap_version, &prec, &rec, &(APs[j]));
247        mAP += APs[j];
248      }
249      mAP /= num_class;
250      const string& output_name = caffe_net.blob_names()[caffe_net.output_blob_indices()[i]];
251      LOG(INFO) << "    Test net output #" << i << ": " << output_name << " = " << mAP;
252    }
253    loss /= FLAGS_iterations;
254    LOG(INFO) << "Loss: " << loss;
255    LOG(INFO) << "Model: " << FLAGS_weights;
256    return 0;
257  }
258  int main(int argc, char** argv) {
259  #ifdef USE_MLSL
260    caffe::mn::init(&argc, &argv);
261  #endif
262    ::google::InitGoogleLogging(argv[0]);
263    FLAGS_alsologtostderr = 1;
264  #ifndef GFLAGS_GFLAGS_H_
265    namespace gflags = google;
266  #endif
267    gflags::SetUsageMessage("Test a object detection model\n"
268          "Usage:\n"
269          "    test_detection [FLAGS] \n");
270    gflags::ParseCommandLineFlags(&argc, &argv, true);
271    return test_detection();
272  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallet.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/lmdbconfig.hpp>
3  #include <nano/lib/locks.hpp>
4  #include <nano/lib/work.hpp>
5  #include <nano/node/lmdb/lmdb.hpp>
6  #include <nano/node/lmdb/wallet_value.hpp>
7  #include <nano/node/openclwork.hpp>
8  #include <nano/secure/common.hpp>
9  #include <nano/secure/store.hpp>
10  #include <atomic>
11  #include <mutex>
12  #include <thread>
13  #include <unordered_set>
14  namespace nano
15  {
16  class node;
17  class node_config;
18  class wallets;
19  class fan final
20  {
21  public:
22  	fan (nano::raw_key const &, std::size_t);
23  	void value (nano::raw_key &);
24  	void value_set (nano::raw_key const &);
25  	std::vector<std::unique_ptr<nano::raw_key>> values;
26  private:
27  	nano::mutex mutex;
28  	void value_get (nano::raw_key &);
29  };
30  class kdf final
31  {
32  public:
33  	kdf (unsigned & kdf_work) :
34  		kdf_work{ kdf_work }
35  	{
36  	}
37  	void phs (nano::raw_key &, std::string const &, nano::uint256_union const &);
38  	nano::mutex mutex;
39  	unsigned & kdf_work;
40  };
41  enum class key_type
42  {
43  	not_a_type,
44  	unknown,
45  	adhoc,
46  	deterministic
47  };
48  class wallet_store final
49  {
50  public:
51  	wallet_store (bool &, nano::kdf &, nano::transaction &, nano::account, unsigned, std::string const &);
52  	wallet_store (bool &, nano::kdf &, nano::transaction &, nano::account, unsigned, std::string const &, std::string const &);
53  	std::vector<nano::account> accounts (nano::transaction const &);
54  	void initialize (nano::transaction const &, bool &, std::string const &);
55  	nano::uint256_union check (nano::transaction const &);
56  	bool rekey (nano::transaction const &, std::string const &);
57  	bool valid_password (nano::transaction const &);
58  	bool valid_public_key (nano::public_key const &);
59  	bool attempt_password (nano::transaction const &, std::string const &);
60  	void wallet_key (nano::raw_key &, nano::transaction const &);
61  	void seed (nano::raw_key &, nano::transaction const &);
62  	void seed_set (nano::transaction const &, nano::raw_key const &);
63  	nano::key_type key_type (nano::wallet_value const &);
64  	nano::public_key deterministic_insert (nano::transaction const &);
65  	nano::public_key deterministic_insert (nano::transaction const &, uint32_t const);
66  	nano::raw_key deterministic_key (nano::transaction const &, uint32_t);
67  	uint32_t deterministic_index_get (nano::transaction const &);
68  	void deterministic_index_set (nano::transaction const &, uint32_t);
69  	void deterministic_clear (nano::transaction const &);
70  	nano::uint256_union salt (nano::transaction const &);
71  	bool is_representative (nano::transaction const &);
72  	nano::account representative (nano::transaction const &);
73  	void representative_set (nano::transaction const &, nano::account const &);
74  	nano::public_key insert_adhoc (nano::transaction const &, nano::raw_key const &);
75  	bool insert_watch (nano::transaction const &, nano::account const &);
76  	void erase (nano::transaction const &, nano::account const &);
77  	nano::wallet_value entry_get_raw (nano::transaction const &, nano::account const &);
78  	void entry_put_raw (nano::transaction const &, nano::account const &, nano::wallet_value const &);
79  	bool fetch (nano::transaction const &, nano::account const &, nano::raw_key &);
80  	bool exists (nano::transaction const &, nano::account const &);
81  	void destroy (nano::transaction const &);
82  	nano::store_iterator<nano::account, nano::wallet_value> find (nano::transaction const &, nano::account const &);
83  	nano::store_iterator<nano::account, nano::wallet_value> begin (nano::transaction const &, nano::account const &);
84  	nano::store_iterator<nano::account, nano::wallet_value> begin (nano::transaction const &);
85  	nano::store_iterator<nano::account, nano::wallet_value> end ();
86  	void derive_key (nano::raw_key &, nano::transaction const &, std::string const &);
87  	void serialize_json (nano::transaction const &, std::string &);
88  	void write_backup (nano::transaction const &, boost::filesystem::path const &);
89  	bool move (nano::transaction const &, nano::wallet_store &, std::vector<nano::public_key> const &);
90  	bool import (nano::transaction const &, nano::wallet_store &);
91  	bool work_get (nano::transaction const &, nano::public_key const &, uint64_t &);
92  	void work_put (nano::transaction const &, nano::public_key const &, uint64_t);
93  	unsigned version (nano::transaction const &);
94  	void version_put (nano::transaction const &, unsigned);
95  	nano::fan password;
96  	nano::fan wallet_key_mem;
97  	static unsigned const version_1 = 1;
98  	static unsigned const version_2 = 2;
<span onclick='openModal()' class='match'>99  	static unsigned const version_3 = 3;
100  	static unsigned const version_4 = 4;
101  	static unsigned constexpr version_current = version_4;
102  	static nano::account const version_special;
103  	static nano::account const wallet_key_special;
104  	static nano::account const salt_special;
105  	static nano::account const check_special;
106  	static nano::account const representative_special;
107  	static nano::account const seed_special;
108  	static nano::account const deterministic_index_special;
</span>109  	static std::size_t const check_iv_index;
110  	static std::size_t const seed_iv_index;
111  	static int const special_count;
112  	nano::kdf & kdf;
113  	std::atomic<MDB_dbi> handle{ 0 };
114  	std::recursive_mutex mutex;
115  private:
116  	MDB_txn * tx (nano::transaction const &) const;
117  };
118  class wallet final : public std::enable_shared_from_this<nano::wallet>
119  {
120  public:
121  	std::shared_ptr<nano::block> change_action (nano::account const &, nano::account const &, uint64_t = 0, bool = true);
122  	std::shared_ptr<nano::block> receive_action (nano::block_hash const &, nano::account const &, nano::uint128_union const &, nano::account const &, uint64_t = 0, bool = true);
123  	std::shared_ptr<nano::block> send_action (nano::account const &, nano::account const &, nano::uint128_t const &, uint64_t = 0, bool = true, boost::optional<std::string> = {});
124  	bool action_complete (std::shared_ptr<nano::block> const &, nano::account const &, bool const, nano::block_details const &);
125  	wallet (bool &, nano::transaction &, nano::wallets &, std::string const &);
126  	wallet (bool &, nano::transaction &, nano::wallets &, std::string const &, std::string const &);
127  	void enter_initial_password ();
128  	bool enter_password (nano::transaction const &, std::string const &);
129  	nano::public_key insert_adhoc (nano::raw_key const &, bool = true);
130  	bool insert_watch (nano::transaction const &, nano::public_key const &);
131  	nano::public_key deterministic_insert (nano::transaction const &, bool = true);
132  	nano::public_key deterministic_insert (uint32_t, bool = true);
133  	nano::public_key deterministic_insert (bool = true);
134  	bool exists (nano::public_key const &);
135  	bool import (std::string const &, std::string const &);
136  	void serialize (std::string &);
137  	bool change_sync (nano::account const &, nano::account const &);
138  	void change_async (nano::account const &, nano::account const &, std::function<void (std::shared_ptr<nano::block> const &)> const &, uint64_t = 0, bool = true);
139  	bool receive_sync (std::shared_ptr<nano::block> const &, nano::account const &, nano::uint128_t const &);
140  	void receive_async (nano::block_hash const &, nano::account const &, nano::uint128_t const &, nano::account const &, std::function<void (std::shared_ptr<nano::block> const &)> const &, uint64_t = 0, bool = true);
141  	nano::block_hash send_sync (nano::account const &, nano::account const &, nano::uint128_t const &);
142  	void send_async (nano::account const &, nano::account const &, nano::uint128_t const &, std::function<void (std::shared_ptr<nano::block> const &)> const &, uint64_t = 0, bool = true, boost::optional<std::string> = {});
143  	void work_cache_blocking (nano::account const &, nano::root const &);
144  	void work_update (nano::transaction const &, nano::account const &, nano::root const &, uint64_t);
145  	void work_ensure (nano::account const &, nano::root const &);
146  	bool search_receivable (nano::transaction const &);
147  	void init_free_accounts (nano::transaction const &);
148  	uint32_t deterministic_check (nano::transaction const & transaction_a, uint32_t index);
149  	nano::public_key change_seed (nano::transaction const & transaction_a, nano::raw_key const & prv_a, uint32_t count = 0);
150  	void deterministic_restore (nano::transaction const & transaction_a);
151  	bool live ();
152  	std::unordered_set<nano::account> free_accounts;
153  	std::function<void (bool, bool)> lock_observer;
154  	nano::wallet_store store;
155  	nano::wallets & wallets;
156  	nano::mutex representatives_mutex;
157  	std::unordered_set<nano::account> representatives;
158  };
159  class wallet_representatives
160  {
161  public:
162  	uint64_t voting{ 0 }; 
163  	bool half_principal{ false }; 
164  	std::unordered_set<nano::account> accounts; 
165  	bool have_half_rep () const
166  	{
167  		return half_principal;
168  	}
169  	bool exists (nano::account const & rep_a) const
170  	{
171  		return accounts.count (rep_a) > 0;
172  	}
173  	void clear ()
174  	{
175  		voting = 0;
176  		half_principal = false;
177  		accounts.clear ();
178  	}
179  };
180  class wallets final
181  {
182  public:
183  	wallets (bool, nano::node &);
184  	~wallets ();
185  	std::shared_ptr<nano::wallet> open (nano::wallet_id const &);
186  	std::shared_ptr<nano::wallet> create (nano::wallet_id const &);
187  	bool search_receivable (nano::wallet_id const &);
188  	void search_receivable_all ();
189  	void destroy (nano::wallet_id const &);
190  	void reload ();
191  	void do_wallet_actions ();
192  	void queue_wallet_action (nano::uint128_t const &, std::shared_ptr<nano::wallet> const &, std::function<void (nano::wallet &)>);
193  	void foreach_representative (std::function<void (nano::public_key const &, nano::raw_key const &)> const &);
194  	bool exists (nano::transaction const &, nano::account const &);
195  	void start ();
196  	void stop ();
197  	void clear_send_ids (nano::transaction const &);
198  	nano::wallet_representatives reps () const;
199  	bool check_rep (nano::account const &, nano::uint128_t const &, bool const = true);
200  	void compute_reps ();
201  	void ongoing_compute_reps ();
202  	void split_if_needed (nano::transaction &, nano::store &);
203  	void move_table (std::string const &, MDB_txn *, MDB_txn *);
204  	std::unordered_map<nano::wallet_id, std::shared_ptr<nano::wallet>> get_wallets ();
205  	nano::network_params & network_params;
206  	std::function<void (bool)> observer;
207  	std::unordered_map<nano::wallet_id, std::shared_ptr<nano::wallet>> items;
208  	std::multimap<nano::uint128_t, std::pair<std::shared_ptr<nano::wallet>, std::function<void (nano::wallet &)>>, std::greater<nano::uint128_t>> actions;
209  	nano::locked<std::unordered_map<nano::account, nano::root>> delayed_work;
210  	nano::mutex mutex;
211  	nano::mutex action_mutex;
212  	nano::condition_variable condition;
213  	nano::kdf kdf;
214  	MDB_dbi handle;
215  	MDB_dbi send_action_ids;
216  	nano::node & node;
217  	nano::mdb_env & env;
218  	std::atomic<bool> stopped;
219  	std::thread thread;
220  	static nano::uint128_t const generate_priority;
221  	static nano::uint128_t const high_priority;
222  	nano::write_transaction tx_begin_write ();
223  	nano::read_transaction tx_begin_read ();
224  private:
225  	mutable nano::mutex reps_cache_mutex;
226  	nano::wallet_representatives representatives;
227  };
228  std::unique_ptr<container_info_component> collect_container_info (wallets & wallets, std::string const & name);
229  class wallets_store
230  {
231  public:
232  	virtual ~wallets_store () = default;
233  	virtual bool init_error () const = 0;
234  };
235  class mdb_wallets_store final : public wallets_store
236  {
237  public:
238  	mdb_wallets_store (boost::filesystem::path const &, nano::lmdb_config const & lmdb_config_a = nano::lmdb_config{});
239  	nano::mdb_env environment;
240  	bool init_error () const override;
241  	bool error{ false };
242  };
243  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_detection.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallet.hpp</div>
                </div>
                <div class="column column_space"><pre><code>170    int side = FLAGS_side;			
171    int num_object = FLAGS_objects;	
172    int num_class = FLAGS_classes;	
173    caffe::CPUTimer timer;
174    Net<float> caffe_net(FLAGS_model, caffe::TEST);
175    caffe_net.CopyTrainedLayersFrom(FLAGS_weights);
176    LOG(INFO) << "Running for " << FLAGS_iterations << " iterations.";
177    map<int, map<int, vector<pair<float, int> > > > true_poss, false_poss;
178    map<int, map<int, int> > num_gts;
179    vector<int> test_score_output_id;
180    float loss = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>99  	static unsigned const version_3 = 3;
100  	static unsigned const version_4 = 4;
101  	static unsigned constexpr version_current = version_4;
102  	static nano::account const version_special;
103  	static nano::account const wallet_key_special;
104  	static nano::account const salt_special;
105  	static nano::account const check_special;
106  	static nano::account const representative_special;
107  	static nano::account const seed_special;
108  	static nano::account const deterministic_index_special;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    