
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.63302752293578%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.h</h3>
            <pre><code>1  class TGUtil {
2  public:
3    static void GetCdf(const TIntPrV& PdfV, TIntPrV& CdfV);
4    static void GetCdf(const TFltPrV& PdfV, TFltPrV& CdfV);
5    static void GetCdf(const TIntFltKdV& PdfV, TIntFltKdV& CdfV);
6    static TIntPrV GetCdf(const TIntPrV& PdfV);
7    static TFltPrV GetCdf(const TFltPrV& PdfV);
8    static void GetCCdf(const TIntPrV& PdfV, TIntPrV& CCdfV);
9    static void GetCCdf(const TFltPrV& PdfV, TFltPrV& CCdfV);
10    static void GetCCdf(const TIntFltKdV& PdfV, TIntFltKdV& CCdfV);
11    static TIntPrV GetCCdf(const TIntPrV& PdfV);
12    static TFltPrV GetCCdf(const TFltPrV& PdfV);
13    static void GetPdf(const TIntPrV& CdfV, TIntPrV& PdfV);
14    static void GetPdf(const TFltPrV& CdfV, TFltPrV& PdfV);
15    static void GetPdf(const TIntFltKdV& CdfV, TIntFltKdV& PdfV);
16    static void Normalize(TFltPrV& PdfV);
17    static void Normalize(TIntFltKdV& PdfV);
18    static void MakeExpBins(const TFltPrV& XYValV, TFltPrV& ExpXYValV,
19      const double& BinFactor = 2, const double& MinYVal = 1);
20    static void MakeExpBins(const TFltKdV& XYValV, TFltKdV& ExpXYValV,
21      const double& BinFactor = 2, const double& MinYVal = 1);
22    static void MakeExpBins(const TFltV& YValV, TFltV& ExpYValV, const double& BinFactor = 1.01);
23    static void MakeExpBins(const TIntV& YValV, TIntV& ExpYValV, const double& BinFactor = 1.01);
24  };
25  class TStrUtil {
26  public:
<span onclick='openModal()' class='match'>27    static TChA& GetXmlTagVal(TXmlLx& XmlLx, const TChA& TagNm);
28    static void GetXmlTagNmVal(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal);
</span>29    static bool GetXmlTagNmVal2(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal, const bool& TakeTagNms);
30    static TChA GetDomNm(const TChA& UrlChA);  
31    static TChA GetDomNm2(const TChA& UrlChA); 
32    static TChA GetWebsiteNm(const TChA& UrlChA); 
33    static bool GetNormalizedUrl(const TChA& UrlIn, const TChA& BaseUrl, TChA& UrlOut);
34    static bool StripEnd(const TChA& Str, const TChA& SearchStr, TChA& NewStr);
35    static TChA GetShorStr(const TChA& LongStr, const int MaxLen=50);
36    static TChA GetCleanStr(const TChA& ChA);
37    static TChA GetCleanWrdStr(const TChA& ChA);
38    static int CountWords(const char* CStr);
39    static int CountWords(const TChA& ChA);
40    static int CountWords(const TChA& ChA, const TStrHash<TInt>& StopWordH);
41    static int SplitWords(TChA& ChA, TVec<char *>& WrdV, const bool& SplitOnWs=true);
42    static int SplitOnCh(TChA& ChA, TVec<char *>& WrdV, const char& Ch, const bool& SkipEmpty=false);
43    static int SplitLines(TChA& ChA, TVec<char *>& LineV, const bool& SkipEmpty=false);
44    static int SplitSentences(TChA& ChA, TVec<char *>& SentenceV);
45    static void RemoveHtmlTags(const TChA& HtmlStr, TChA& TextStr);
46    static bool IsLatinStr(const TChA& Str, const double& MinAlFrac);
47    static void GetWIdV(const TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV);
48    static void GetAddWIdV(TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV);
49    static bool GetTmFromStr(const char* TmStr, TSecTm& Tm);
50    static TStr GetStdName(TStr AuthorName);
51    static void GetStdNameV(TStr AuthorNames, TStrV& StdNameV);
52  };
53  class TStopwatch {
54  public:
55    typedef enum {LoadTables, Preprocess, ConstructGraph, Compute, Postprocess, StoreOutputs,
56        AllocateColumnCopies, CopyColumns, Sort, Group, MergeNeighborhoods, AddNeighborhoods, AddEdges, Sort2, ComputeOffset,
57        ComputeETypes, EstimateSizes, InitGraph, ExtractNbrETypes, CopyNodes, PopulateGraph, ExtractEdges, BuildSubgraph} TExperiment;
58    static const int NEXPS = 25;
59    static TStopwatch* GetInstance() {
60      static TStopwatch instance; 
61      return &instance;
62    }
63  private:
64    TStopwatch() {
65      for (int i = 0; i < NEXPS; i++) { Mins[i] = 100000000000.0; }
66    }; 
67    TStopwatch(TStopwatch const&);              
68    void operator=(TStopwatch const&); 
69    double Starts[NEXPS];
70    int Cnts[NEXPS];
71    double Sums[NEXPS];
72    double Maxs[NEXPS];
73    double Mins[NEXPS];
74  private:
75    double Tick();
76  public:
77    void Start(const TExperiment Exp);
78    void Stop(const TExperiment Exp);
79    int Cnt(const TExperiment Exp) const;
80    double Sum(const TExperiment Exp) const;
81    double Avg(const TExperiment Exp) const;
82    double Max(const TExperiment Exp) const;
83    double Min(const TExperiment Exp) const;
84  };
85  #if defined(SW_WRITEN)
86  extern int WriteN(int fd, char *ptr, int nbytes);
87  template <class TVal, class TSizeTy>
88  int64 SendVec(const TVec<TVal, TSizeTy>& V, int FileDesc) {
89    int64 l = 0;
90    int n;
91    int r;
92    TSizeTy Vals = V.Len();
93    int ChunkSize = 25600;
94    r = WriteN(FileDesc, (char *) &Vals, (int) sizeof(TSizeTy));
95    if (r < 0) {
96      return r;
97    }
98    l += r;
99    r = WriteN(FileDesc, (char *) &Vals, (int) sizeof(TSizeTy));
100    if (r < 0) {
101      return r;
102    }
103    l += r;
104    for (TSizeTy ValN = 0; ValN < Vals; ValN += ChunkSize) {
105      n = ChunkSize;
106      if ((Vals - ValN) < ChunkSize) {
107        n = Vals - ValN;
108      }
109      r = WriteN(FileDesc, (char *) &V[ValN], (int) (n*sizeof(TVal)));
110      if (r < 0) {
111        return r;
112      }
113      l += r;
114    }
115    return l;
116  }
117  template <class TVal, class TSizeTy>
118  int64 SendVec64(const TVec< TVec< TVal, TSizeTy > , TSizeTy >&Vec64, int FileDesc) {
119    TSizeTy N =Vec64.Len();
120    int64 l=0;
121    int r;
122    r = WriteN(FileDesc, (char *) &N, (int) sizeof(TSizeTy));
123    if (r < 0) {
124      return r;
125    }
126    l += r;
127    r = WriteN(FileDesc, (char *) &N, (int) sizeof(TSizeTy));
128    if (r < 0) {
129      return r;
130    }
131    l += r;
132    for (typename TVec< TVec< TVal, TSizeTy >, TSizeTy >::TIter it=Vec64.BegI(); it!=Vec64.EndI(); ++it) {
133      r = SendVec(*it, FileDesc);
134      if (r < 0) {
135        return r;
136      }
137      l += r;
138    }
139    return l;
140  }
141  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pithsync.cpp</h3>
            <pre><code>1  #include "pithsync.h"
2  #include "makerow.h"
3  #include "pitsync1.h"
4  #include "topitch.h"
5  #include "tprintf.h"
6  #include <cfloat> 
7  #include <cmath>
8  #include <vector> 
9  namespace tesseract {
10  void FPCUTPT::setup(      
11      FPCUTPT *cutpts,      
12      int16_t array_origin, 
13      STATS *projection,    
14      int16_t zero_count,   
15      int16_t pitch,        
16      int16_t x,            
17      int16_t offset        
18  ) {
19    int16_t half_pitch = pitch / 2 - 1;
20    uint32_t lead_flag; 
21    int32_t ind;        
22    if (half_pitch > 31) {
23      half_pitch = 31;
24    } else if (half_pitch < 0) {
25      half_pitch = 0;
26    }
27    lead_flag = 1 << half_pitch;
28    pred = nullptr;
29    mean_sum = 0;
30    sq_sum = offset * offset;
31    cost = sq_sum;
32    faked = false;
33    terminal = false;
34    fake_count = 0;
35    xpos = x;
36    region_index = 0;
37    mid_cuts = 0;
38    if (x == array_origin) {
39      back_balance = 0;
40      fwd_balance = 0;
41      for (ind = 0; ind <= half_pitch; ind++) {
42        fwd_balance >>= 1;
43        if (projection->pile_count(ind) > zero_count) {
44          fwd_balance |= lead_flag;
45        }
46      }
47    } else {
48      back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
49      back_balance &= lead_flag + (lead_flag - 1);
50      if (projection->pile_count(x) > zero_count) {
51        back_balance |= 1;
52      }
53      fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
54      if (projection->pile_count(x + half_pitch) > zero_count) {
55        fwd_balance |= lead_flag;
56      }
57    }
58  }
59  void FPCUTPT::assign(       
60      FPCUTPT *cutpts,        
61      int16_t array_origin,   
62      int16_t x,              
63      bool faking,            
64      bool mid_cut,           
65      int16_t offset,         
66      STATS *projection,      
67      float projection_scale, 
68      int16_t zero_count,     
69      int16_t pitch,          
70      int16_t pitch_error     
71  ) {
72    int index;             
73    int balance_index;     
74    int16_t balance_count; 
75    int16_t r_index;       
76    FPCUTPT *segpt;        
77    int32_t dist;          
78    double sq_dist;        
79    double mean;           
80    double total;          
81    double factor;         
82    int16_t half_pitch = pitch / 2 - 1;
83    uint32_t lead_flag; 
84    if (half_pitch > 31) {
85      half_pitch = 31;
86    } else if (half_pitch < 0) {
87      half_pitch = 0;
88    }
89    lead_flag = 1 << half_pitch;
90    back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
91    back_balance &= lead_flag + (lead_flag - 1);
92    if (projection->pile_count(x) > zero_count) {
93      back_balance |= 1;
94    }
95    fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
96    if (projection->pile_count(x + half_pitch) > zero_count) {
97      fwd_balance |= lead_flag;
98    }
99    xpos = x;
100    cost = FLT_MAX;
101    pred = nullptr;
102    faked = faking;
103    terminal = false;
104    region_index = 0;
105    fake_count = INT16_MAX;
106    for (index = x - pitch - pitch_error; index <= x - pitch + pitch_error; index++) {
107      if (index >= array_origin) {
108        segpt = &cutpts[index - array_origin];
109        dist = x - segpt->xpos;
110        if (!segpt->terminal && segpt->fake_count < INT16_MAX) {
111          balance_count = 0;
112          if (textord_balance_factor > 0) {
113            if (textord_fast_pitch_test) {
114              lead_flag = back_balance ^ segpt->fwd_balance;
115              balance_count = 0;
116              while (lead_flag != 0) {
117                balance_count++;
118                lead_flag &= lead_flag - 1;
119              }
120            } else {
121              for (balance_index = 0; index + balance_index < x - balance_index; balance_index++) {
122                balance_count += (projection->pile_count(index + balance_index) <= zero_count) ^
123                                 (projection->pile_count(x - balance_index) <= zero_count);
124              }
125            }
126            balance_count =
127                static_cast<int16_t>(balance_count * textord_balance_factor / projection_scale);
128          }
129          r_index = segpt->region_index + 1;
130          total = segpt->mean_sum + dist;
131          balance_count += offset;
132          sq_dist = dist * dist + segpt->sq_sum + balance_count * balance_count;
133          mean = total / r_index;
134          factor = mean - pitch;
135          factor *= factor;
136          factor += sq_dist / (r_index)-mean * mean;
137          if (factor < cost && segpt->fake_count + faked <= fake_count) {
138            cost = factor; 
139            pred = segpt;  
140            mean_sum = total;
141            sq_sum = sq_dist;
142            fake_count = segpt->fake_count + faked;
143            mid_cuts = segpt->mid_cuts + mid_cut;
144            region_index = r_index;
145          }
146        }
147      }
148    }
149  }
150  void FPCUTPT::assign_cheap( 
151      FPCUTPT *cutpts,        
152      int16_t array_origin,   
153      int16_t x,              
154      bool faking,            
155      bool mid_cut,           
156      int16_t offset,         
157      STATS *projection,      
158      float projection_scale, 
159      int16_t zero_count,     
160      int16_t pitch,          
161      int16_t pitch_error     
162  ) {
163    int index;             
164    int16_t balance_count; 
165    int16_t r_index;       
166    FPCUTPT *segpt;        
167    int32_t dist;          
168    double sq_dist;        
169    double mean;           
170    double total;          
171    double factor;         
172    int16_t half_pitch = pitch / 2 - 1;
173    uint32_t lead_flag; 
174    if (half_pitch > 31) {
175      half_pitch = 31;
176    } else if (half_pitch < 0) {
177      half_pitch = 0;
178    }
179    lead_flag = 1 << half_pitch;
180    back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
181    back_balance &= lead_flag + (lead_flag - 1);
182    if (projection->pile_count(x) > zero_count) {
183      back_balance |= 1;
184    }
185    fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
186    if (projection->pile_count(x + half_pitch) > zero_count) {
187      fwd_balance |= lead_flag;
188    }
189    xpos = x;
190    cost = FLT_MAX;
191    pred = nullptr;
192    faked = faking;
193    terminal = false;
194    region_index = 0;
195    fake_count = INT16_MAX;
196    index = x - pitch;
197    if (index >= array_origin) {
198      segpt = &cutpts[index - array_origin];
199      dist = x - segpt->xpos;
200      if (!segpt->terminal && segpt->fake_count < INT16_MAX) {
201        balance_count = 0;
202        if (textord_balance_factor > 0) {
203          lead_flag = back_balance ^ segpt->fwd_balance;
204          balance_count = 0;
205          while (lead_flag != 0) {
206            balance_count++;
207            lead_flag &= lead_flag - 1;
208          }
209          balance_count =
210              static_cast<int16_t>(balance_count * textord_balance_factor / projection_scale);
211        }
212        r_index = segpt->region_index + 1;
213        total = segpt->mean_sum + dist;
214        balance_count += offset;
215        sq_dist = dist * dist + segpt->sq_sum + balance_count * balance_count;
216        mean = total / r_index;
217        factor = mean - pitch;
218        factor *= factor;
219        factor += sq_dist / (r_index)-mean * mean;
220        cost = factor; 
221        pred = segpt;  
222        mean_sum = total;
223        sq_sum = sq_dist;
224        fake_count = segpt->fake_count + faked;
225        mid_cuts = segpt->mid_cuts + mid_cut;
226        region_index = r_index;
227      }
228    }
229  }
230  double check_pitch_sync2(    
231      BLOBNBOX_IT *blob_it,    
232      int16_t blob_count,      
233      int16_t pitch,           
234      int16_t pitch_error,     
235      STATS *projection,       
236      int16_t projection_left, 
237      int16_t projection_right, float projection_scale,
238      int16_t &occupation_count, 
239      FPSEGPT_LIST *seg_list,    
240      int16_t start,             
241      int16_t end                
242  ) {
243    bool faking;                  
244    bool mid_cut;                 
245    int16_t x;                    
246    int16_t blob_index;           
247    int16_t left_edge;            
248    int16_t right_edge;           
249    int16_t array_origin;         
250    int16_t offset;               
251    int16_t zero_count;           
252    int16_t best_left_x = 0;      
253    int16_t best_right_x = 0;     
<span onclick='openModal()' class='match'>254    TBOX this_box;                
255    TBOX next_box;                
256    FPSEGPT *segpt;               
257    double best_cost;             
258    double mean_sum;              
259    FPCUTPT *best_end;            
260    int16_t best_fake;            
261    int16_t best_count;           
262    BLOBNBOX_IT this_it;          
263    FPSEGPT_IT seg_it = seg_list; 
</span>264    zero_count = 0;
265    if (pitch < 3) {
266      pitch = 3; 
267    }
268    if ((pitch - 3) / 2 < pitch_error) {
269      pitch_error = (pitch - 3) / 2;
270    }
271    this_it = *blob_it;
272    this_box = box_next(&this_it); 
273    for (left_edge = projection_left;
274         projection->pile_count(left_edge) == 0 && left_edge < projection_right; left_edge++) {
275      ;
276    }
277    for (right_edge = projection_right;
278         projection->pile_count(right_edge) == 0 && right_edge > left_edge; right_edge--) {
279      ;
280    }
281    ASSERT_HOST(right_edge >= left_edge);
282    if (pitsync_linear_version >= 4) {
283      return check_pitch_sync3(projection_left, projection_right, zero_count, pitch, pitch_error,
284                               projection, projection_scale, occupation_count, seg_list, start, end);
285    }
286    array_origin = left_edge - pitch;
287    std::vector<FPCUTPT> cutpts(right_edge - left_edge + pitch * 2 + 1);
288    for (x = array_origin; x < left_edge; x++) {
289      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x, 0);
290    }
291    for (offset = 0; offset <= pitch_error; offset++, x++) {
292      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x,
293                                     offset);
294    }
295    this_it = *blob_it;
296    best_cost = FLT_MAX;
297    best_end = nullptr;
298    this_box = box_next(&this_it); 
299    next_box = box_next(&this_it); 
300    blob_index = 1;
301    while (x < right_edge - pitch_error) {
302      if (x > this_box.right() + pitch_error && blob_index < blob_count) {
303        this_box = next_box;
304        next_box = box_next(&this_it);
305        blob_index++;
306      }
307      faking = false;
308      mid_cut = false;
309      if (x <= this_box.left()) {
310        offset = 0;
311      } else if (x <= this_box.left() + pitch_error) {
312        offset = x - this_box.left();
313      } else if (x >= this_box.right()) {
314        offset = 0;
315      } else if (x >= next_box.left() && blob_index < blob_count) {
316        offset = x - next_box.left();
317        if (this_box.right() - x < offset) {
318          offset = this_box.right() - x;
319        }
320      } else if (x >= this_box.right() - pitch_error) {
321        offset = this_box.right() - x;
322      } else if (x - this_box.left() > pitch * pitsync_joined_edge &&
323                 this_box.right() - x > pitch * pitsync_joined_edge) {
324        mid_cut = true;
325        offset = 0;
326      } else {
327        faking = true;
328        offset = projection->pile_count(x);
329      }
330      cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, faking, mid_cut, offset,
331                                      projection, projection_scale, zero_count, pitch, pitch_error);
332      x++;
333    }
334    best_fake = INT16_MAX;
335    best_cost = INT32_MAX;
336    best_count = INT16_MAX;
337    while (x < right_edge + pitch) {
338      offset = x < right_edge ? right_edge - x : 0;
339      cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, false, false, offset, projection,
340                                      projection_scale, zero_count, pitch, pitch_error);
341      cutpts[x - array_origin].terminal = true;
342      if (cutpts[x - array_origin].index() + cutpts[x - array_origin].fake_count <=
343          best_count + best_fake) {
344        if (cutpts[x - array_origin].fake_count < best_fake ||
345            (cutpts[x - array_origin].fake_count == best_fake &&
346             cutpts[x - array_origin].cost_function() < best_cost)) {
347          best_fake = cutpts[x - array_origin].fake_count;
348          best_cost = cutpts[x - array_origin].cost_function();
349          best_left_x = x;
350          best_right_x = x;
351          best_count = cutpts[x - array_origin].index();
352        } else if (cutpts[x - array_origin].fake_count == best_fake && x == best_right_x + 1 &&
353                   cutpts[x - array_origin].cost_function() == best_cost) {
354          best_right_x = x;
355        }
356      }
357      x++;
358    }
359    ASSERT_HOST(best_fake < INT16_MAX);
360    best_end = &cutpts[(best_left_x + best_right_x) / 2 - array_origin];
361    if (this_box.right() == textord_test_x && this_box.top() == textord_test_y) {
362      for (x = left_edge - pitch; x < right_edge + pitch; x++) {
363        tprintf("x=%d, C=%g, s=%g, sq=%g, prev=%d\n", x, cutpts[x - array_origin].cost_function(),
364                cutpts[x - array_origin].sum(), cutpts[x - array_origin].squares(),
365                cutpts[x - array_origin].previous()->position());
366      }
367    }
368    occupation_count = -1;
369    do {
370      for (x = best_end->position() - pitch + pitch_error;
371           x < best_end->position() - pitch_error && projection->pile_count(x) == 0; x++) {
372        ;
373      }
374      if (x < best_end->position() - pitch_error) {
375        occupation_count++;
376      }
377      segpt = new FPSEGPT(best_end);
378      seg_it.add_before_then_move(segpt);
379      best_end = best_end->previous();
380    } while (best_end != nullptr);
381    seg_it.move_to_last();
382    mean_sum = seg_it.data()->sum();
383    mean_sum = mean_sum * mean_sum / best_count;
384    if (seg_it.data()->squares() - mean_sum < 0) {
385      tprintf("Impossible sqsum=%g, mean=%g, total=%d\n", seg_it.data()->squares(),
386              seg_it.data()->sum(), best_count);
387    }
388    return seg_it.data()->squares() - mean_sum;
389  }
390  double check_pitch_sync3(    
391      int16_t projection_left, 
392      int16_t projection_right, int16_t zero_count,
393      int16_t pitch,             
394      int16_t pitch_error,       
395      STATS *projection,         
396      float projection_scale,    
397      int16_t &occupation_count, 
398      FPSEGPT_LIST *seg_list,    
399      int16_t start,             
400      int16_t end                
401  ) {
402    bool faking;                  
403    bool mid_cut;                 
404    int16_t left_edge;            
405    int16_t right_edge;           
406    int16_t x;                    
407    int16_t array_origin;         
408    int16_t offset;               
409    int16_t projection_offset;    
410    int16_t prev_zero;            
411    int16_t next_zero;            
412    int16_t zero_offset;          
413    int16_t best_left_x = 0;      
414    int16_t best_right_x = 0;     
415    FPSEGPT *segpt;               
416    int minindex;                 
417    int test_index;               
418    double best_cost;             
419    double mean_sum;              
420    FPCUTPT *best_end;            
421    int16_t best_fake;            
422    int16_t best_count;           
423    FPSEGPT_IT seg_it = seg_list; 
424    end = (end - start) % pitch;
425    if (pitch < 3) {
426      pitch = 3; 
427    }
428    if ((pitch - 3) / 2 < pitch_error) {
429      pitch_error = (pitch - 3) / 2;
430    }
431    zero_offset = static_cast<int16_t>(pitch * pitsync_joined_edge);
432    for (left_edge = projection_left;
433         projection->pile_count(left_edge) == 0 && left_edge < projection_right; left_edge++) {
434      ;
435    }
436    for (right_edge = projection_right;
437         projection->pile_count(right_edge) == 0 && right_edge > left_edge; right_edge--) {
438      ;
439    }
440    array_origin = left_edge - pitch;
441    std::vector<FPCUTPT> cutpts(right_edge - left_edge + pitch * 2 + 1);
442    std::vector<bool> mins(pitch_error * 2 + 1);
443    for (x = array_origin; x < left_edge; x++) {
444      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x, 0);
445    }
446    prev_zero = left_edge - 1;
447    for (offset = 0; offset <= pitch_error; offset++, x++) {
448      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x,
449                                     offset);
450    }
451    best_cost = FLT_MAX;
452    best_end = nullptr;
453    for (offset = -pitch_error, minindex = 0; offset < pitch_error; offset++, minindex++) {
454      mins[minindex] = projection->local_min(x + offset);
455    }
456    next_zero = x + zero_offset + 1;
457    for (offset = next_zero - 1; offset >= x; offset--) {
458      if (projection->pile_count(offset) <= zero_count) {
459        next_zero = offset;
460        break;
461      }
462    }
463    while (x < right_edge - pitch_error) {
464      mins[minindex] = projection->local_min(x + pitch_error);
465      minindex++;
466      if (minindex > pitch_error * 2) {
467        minindex = 0;
468      }
469      faking = false;
470      mid_cut = false;
471      offset = 0;
472      if (projection->pile_count(x) <= zero_count) {
473        prev_zero = x;
474      } else {
475        for (offset = 1; offset <= pitch_error; offset++) {
476          if (projection->pile_count(x + offset) <= zero_count ||
477              projection->pile_count(x - offset) <= zero_count) {
478            break;
479          }
480        }
481      }
482      if (offset > pitch_error) {
483        if (x - prev_zero > zero_offset && next_zero - x > zero_offset) {
484          for (offset = 0; offset <= pitch_error; offset++) {
485            test_index = minindex + pitch_error + offset;
486            if (test_index > pitch_error * 2) {
487              test_index -= pitch_error * 2 + 1;
488            }
489            if (mins[test_index]) {
490              break;
491            }
492            test_index = minindex + pitch_error - offset;
493            if (test_index > pitch_error * 2) {
494              test_index -= pitch_error * 2 + 1;
495            }
496            if (mins[test_index]) {
497              break;
498            }
499          }
500        }
501        if (offset > pitch_error) {
502          offset = projection->pile_count(x);
503          faking = true;
504        } else {
505          projection_offset = static_cast<int16_t>(projection->pile_count(x) / projection_scale);
506          if (projection_offset > offset) {
507            offset = projection_offset;
508          }
509          mid_cut = true;
510        }
511      }
512      if ((start == 0 && end == 0) || !textord_fast_pitch_test ||
513          (x - projection_left - start) % pitch <= end) {
514        cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, faking, mid_cut, offset,
515                                        projection, projection_scale, zero_count, pitch, pitch_error);
516      } else {
517        cutpts[x - array_origin].assign_cheap(&cutpts[0], array_origin, x, faking, mid_cut, offset,
518                                              projection, projection_scale, zero_count, pitch,
519                                              pitch_error);
520      }
521      x++;
522      if (next_zero < x || next_zero == x + zero_offset) {
523        next_zero = x + zero_offset + 1;
524      }
525      if (projection->pile_count(x + zero_offset) <= zero_count) {
526        next_zero = x + zero_offset;
527      }
528    }
529    best_fake = INT16_MAX;
530    best_cost = INT32_MAX;
531    best_count = INT16_MAX;
532    while (x < right_edge + pitch) {
533      offset = x < right_edge ? right_edge - x : 0;
534      cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, false, false, offset, projection,
535                                      projection_scale, zero_count, pitch, pitch_error);
536      cutpts[x - array_origin].terminal = true;
537      if (cutpts[x - array_origin].index() + cutpts[x - array_origin].fake_count <=
538          best_count + best_fake) {
539        if (cutpts[x - array_origin].fake_count < best_fake ||
540            (cutpts[x - array_origin].fake_count == best_fake &&
541             cutpts[x - array_origin].cost_function() < best_cost)) {
542          best_fake = cutpts[x - array_origin].fake_count;
543          best_cost = cutpts[x - array_origin].cost_function();
544          best_left_x = x;
545          best_right_x = x;
546          best_count = cutpts[x - array_origin].index();
547        } else if (cutpts[x - array_origin].fake_count == best_fake && x == best_right_x + 1 &&
548                   cutpts[x - array_origin].cost_function() == best_cost) {
549          best_right_x = x;
550        }
551      }
552      x++;
553    }
554    ASSERT_HOST(best_fake < INT16_MAX);
555    best_end = &cutpts[(best_left_x + best_right_x) / 2 - array_origin];
556    occupation_count = -1;
557    do {
558      for (x = best_end->position() - pitch + pitch_error;
559           x < best_end->position() - pitch_error && projection->pile_count(x) == 0; x++) {
560      }
561      if (x < best_end->position() - pitch_error) {
562        occupation_count++;
563      }
564      segpt = new FPSEGPT(best_end);
565      seg_it.add_before_then_move(segpt);
566      best_end = best_end->previous();
567    } while (best_end != nullptr);
568    seg_it.move_to_last();
569    mean_sum = seg_it.data()->sum();
570    mean_sum = mean_sum * mean_sum / best_count;
571    if (seg_it.data()->squares() - mean_sum < 0) {
572      tprintf("Impossible sqsum=%g, mean=%g, total=%d\n", seg_it.data()->squares(),
573              seg_it.data()->sum(), best_count);
574    }
575    return seg_it.data()->squares() - mean_sum;
576  }
577  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pithsync.cpp</div>
                </div>
                <div class="column column_space"><pre><code>27    static TChA& GetXmlTagVal(TXmlLx& XmlLx, const TChA& TagNm);
28    static void GetXmlTagNmVal(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal);
</pre></code></div>
                <div class="column column_space"><pre><code>254    TBOX this_box;                
255    TBOX next_box;                
256    FPSEGPT *segpt;               
257    double best_cost;             
258    double mean_sum;              
259    FPCUTPT *best_end;            
260    int16_t best_fake;            
261    int16_t best_count;           
262    BLOBNBOX_IT this_it;          
263    FPSEGPT_IT seg_it = seg_list; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    