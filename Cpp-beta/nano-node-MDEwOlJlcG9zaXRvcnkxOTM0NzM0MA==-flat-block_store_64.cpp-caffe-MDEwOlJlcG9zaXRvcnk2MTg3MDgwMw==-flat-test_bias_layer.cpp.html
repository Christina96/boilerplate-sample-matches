
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.76958525345622%, Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store_64.cpp</h3>
            <pre><code>1  #include <nano/node/rocksdb/block_store.hpp>
2  #include <nano/node/rocksdb/rocksdb.hpp>
3  #include <nano/secure/parallel_traversal.hpp>
4  namespace nano
5  {
6  class block_predecessor_rocksdb_set : public nano::block_visitor
7  {
8  public:
9  	block_predecessor_rocksdb_set (nano::write_transaction const & transaction_a, nano::rocksdb::block_store & block_store_a);
<span onclick='openModal()' class='match'>10  	virtual ~block_predecessor_rocksdb_set () = default;
11  	void fill_value (nano::block const & block_a);
12  	void send_block (nano::send_block const & block_a) override;
13  	void receive_block (nano::receive_block const & block_a) override;
14  	void open_block (nano::open_block const & block_a) override;
15  	void change_block (nano::change_block const & block_a) override;
16  	void state_block (nano::state_block const & block_a) override;
17  	nano::write_transaction const & transaction;
18  	nano::rocksdb::block_store & block_store;
19  };
</span>20  }
21  nano::rocksdb::block_store::block_store (nano::rocksdb::store & store_a) :
22  	store{ store_a } {};
23  void nano::rocksdb::block_store::put (nano::write_transaction const & transaction, nano::block_hash const & hash, nano::block const & block)
24  {
25  	debug_assert (block.sideband ().successor.is_zero () || exists (transaction, block.sideband ().successor));
26  	std::vector<uint8_t> vector;
27  	{
28  		nano::vectorstream stream (vector);
29  		nano::serialize_block (stream, block);
30  		block.sideband ().serialize (stream, block.type ());
31  	}
32  	raw_put (transaction, vector, hash);
33  	block_predecessor_rocksdb_set predecessor (transaction, *this);
34  	block.visit (predecessor);
35  	debug_assert (block.previous ().is_zero () || successor (transaction, block.previous ()) == hash);
36  }
37  void nano::rocksdb::block_store::raw_put (nano::write_transaction const & transaction_a, std::vector<uint8_t> const & data, nano::block_hash const & hash_a)
38  {
39  	nano::rocksdb_val value{ data.size (), (void *)data.data () };
40  	auto status = store.put (transaction_a, tables::blocks, hash_a, value);
41  	store.release_assert_success (status);
42  }
43  nano::block_hash nano::rocksdb::block_store::successor (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
44  {
45  	nano::rocksdb_val value;
46  	block_raw_get (transaction_a, hash_a, value);
47  	nano::block_hash result;
48  	if (value.size () != 0)
49  	{
50  		debug_assert (value.size () >= result.bytes.size ());
51  		auto type = block_type_from_raw (value.data ());
52  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()) + block_successor_offset (transaction_a, value.size (), type), result.bytes.size ());
53  		auto error (nano::try_read (stream, result.bytes));
54  		(void)error;
55  		debug_assert (!error);
56  	}
57  	else
58  	{
59  		result.clear ();
60  	}
61  	return result;
62  }
63  void nano::rocksdb::block_store::successor_clear (nano::write_transaction const & transaction, nano::block_hash const & hash)
64  {
65  	nano::rocksdb_val value;
66  	block_raw_get (transaction, hash, value);
67  	debug_assert (value.size () != 0);
68  	auto type = block_type_from_raw (value.data ());
69  	std::vector<uint8_t> data (static_cast<uint8_t *> (value.data ()), static_cast<uint8_t *> (value.data ()) + value.size ());
70  	std::fill_n (data.begin () + block_successor_offset (transaction, value.size (), type), sizeof (nano::block_hash), uint8_t{ 0 });
71  	raw_put (transaction, data, hash);
72  }
73  std::shared_ptr<nano::block> nano::rocksdb::block_store::get (nano::transaction const & transaction, nano::block_hash const & hash) const
74  {
75  	nano::rocksdb_val value;
76  	block_raw_get (transaction, hash, value);
77  	std::shared_ptr<nano::block> result;
78  	if (value.size () != 0)
79  	{
80  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
81  		nano::block_type type;
82  		auto error (try_read (stream, type));
83  		release_assert (!error);
84  		result = nano::deserialize_block (stream, type);
85  		release_assert (result != nullptr);
86  		nano::block_sideband sideband;
87  		error = (sideband.deserialize (stream, type));
88  		release_assert (!error);
89  		result->sideband_set (sideband);
90  	}
91  	return result;
92  }
93  std::shared_ptr<nano::block> nano::rocksdb::block_store::get_no_sideband (nano::transaction const & transaction, nano::block_hash const & hash) const
94  {
95  	nano::rocksdb_val value;
96  	block_raw_get (transaction, hash, value);
97  	std::shared_ptr<nano::block> result;
98  	if (value.size () != 0)
99  	{
100  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
101  		result = nano::deserialize_block (stream);
102  		debug_assert (result != nullptr);
103  	}
104  	return result;
105  }
106  std::shared_ptr<nano::block> nano::rocksdb::block_store::random (nano::transaction const & transaction)
107  {
108  	nano::block_hash hash;
109  	nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
110  	auto existing = begin (transaction, hash);
111  	if (existing == end ())
112  	{
113  		existing = begin (transaction);
114  	}
115  	debug_assert (existing != end ());
116  	return existing->second.block;
117  }
118  void nano::rocksdb::block_store::del (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a)
119  {
120  	auto status = store.del (transaction_a, tables::blocks, hash_a);
121  	store.release_assert_success (status);
122  }
123  bool nano::rocksdb::block_store::exists (nano::transaction const & transaction, nano::block_hash const & hash)
124  {
125  	nano::rocksdb_val junk;
126  	block_raw_get (transaction, hash, junk);
127  	return junk.size () != 0;
128  }
129  uint64_t nano::rocksdb::block_store::count (nano::transaction const & transaction_a)
130  {
131  	return store.count (transaction_a, tables::blocks);
132  }
133  nano::account nano::rocksdb::block_store::account (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
134  {
135  	auto block (get (transaction_a, hash_a));
136  	debug_assert (block != nullptr);
137  	return account_calculated (*block);
138  }
139  nano::account nano::rocksdb::block_store::account_calculated (nano::block const & block_a) const
140  {
141  	debug_assert (block_a.has_sideband ());
142  	nano::account result (block_a.account ());
143  	if (result.is_zero ())
144  	{
145  		result = block_a.sideband ().account;
146  	}
147  	debug_assert (!result.is_zero ());
148  	return result;
149  }
150  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction) const
151  {
152  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks);
153  }
154  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction, nano::block_hash const & hash) const
155  {
156  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks, hash);
157  }
158  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::end () const
159  {
160  	return nano::store_iterator<nano::block_hash, nano::block_w_sideband> (nullptr);
161  }
162  nano::uint128_t nano::rocksdb::block_store::balance (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
163  {
164  	auto block (get (transaction_a, hash_a));
165  	release_assert (block);
166  	nano::uint128_t result (balance_calculated (block));
167  	return result;
168  }
169  nano::uint128_t nano::rocksdb::block_store::balance_calculated (std::shared_ptr<nano::block> const & block_a) const
170  {
171  	nano::uint128_t result;
172  	switch (block_a->type ())
173  	{
174  		case nano::block_type::open:
175  		case nano::block_type::receive:
176  		case nano::block_type::change:
177  			result = block_a->sideband ().balance.number ();
178  			break;
179  		case nano::block_type::send:
180  			result = boost::polymorphic_downcast<nano::send_block *> (block_a.get ())->hashables.balance.number ();
181  			break;
182  		case nano::block_type::state:
183  			result = boost::polymorphic_downcast<nano::state_block *> (block_a.get ())->hashables.balance.number ();
184  			break;
185  		case nano::block_type::invalid:
186  		case nano::block_type::not_a_block:
187  			release_assert (false);
188  			break;
189  	}
190  	return result;
191  }
192  nano::epoch nano::rocksdb::block_store::version (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
193  {
194  	auto block = get (transaction_a, hash_a);
195  	if (block && block->type () == nano::block_type::state)
196  	{
197  		return block->sideband ().details.epoch;
198  	}
199  	return nano::epoch::epoch_0;
200  }
201  void nano::rocksdb::block_store::for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::block_hash, block_w_sideband>, nano::store_iterator<nano::block_hash, block_w_sideband>)> const & action_a) const
202  {
203  	parallel_traversal<nano::uint256_t> (
204  	[&action_a, this] (nano::uint256_t const & start, nano::uint256_t const & end, bool const is_last) {
205  		auto transaction (this->store.tx_begin_read ());
206  		action_a (transaction, this->begin (transaction, start), !is_last ? this->begin (transaction, end) : this->end ());
207  	});
208  }
209  uint64_t nano::rocksdb::block_store::account_height (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
210  {
211  	auto block = get (transaction_a, hash_a);
212  	return block->sideband ().height;
213  }
214  void nano::rocksdb::block_store::block_raw_get (nano::transaction const & transaction, nano::block_hash const & hash, nano::rocksdb_val & value) const
215  {
216  	auto status = store.get (transaction, tables::blocks, hash, value);
217  	release_assert (store.success (status) || store.not_found (status));
218  }
219  size_t nano::rocksdb::block_store::block_successor_offset (nano::transaction const & transaction_a, size_t entry_size_a, nano::block_type type_a) const
220  {
221  	return entry_size_a - nano::block_sideband::size (type_a);
222  }
223  nano::block_type nano::rocksdb::block_store::block_type_from_raw (void * data_a)
224  {
225  	return static_cast<nano::block_type> ((reinterpret_cast<uint8_t const *> (data_a))[0]);
226  }
227  nano::block_predecessor_rocksdb_set::block_predecessor_rocksdb_set (nano::write_transaction const & transaction_a, nano::rocksdb::block_store & block_store_a) :
228  	transaction{ transaction_a },
229  	block_store{ block_store_a }
230  {
231  }
232  void nano::block_predecessor_rocksdb_set::fill_value (nano::block const & block_a)
233  {
234  	auto hash = block_a.hash ();
235  	nano::rocksdb_val value;
236  	block_store.block_raw_get (transaction, block_a.previous (), value);
237  	debug_assert (value.size () != 0);
238  	auto type = block_store.block_type_from_raw (value.data ());
239  	std::vector<uint8_t> data (static_cast<uint8_t *> (value.data ()), static_cast<uint8_t *> (value.data ()) + value.size ());
240  	std::copy (hash.bytes.begin (), hash.bytes.end (), data.begin () + block_store.block_successor_offset (transaction, value.size (), type));
241  	block_store.raw_put (transaction, data, block_a.previous ());
242  }
243  void nano::block_predecessor_rocksdb_set::send_block (nano::send_block const & block_a)
244  {
245  	fill_value (block_a);
246  }
247  void nano::block_predecessor_rocksdb_set::receive_block (nano::receive_block const & block_a)
248  {
249  	fill_value (block_a);
250  }
251  void nano::block_predecessor_rocksdb_set::open_block (nano::open_block const & block_a)
252  {
253  }
254  void nano::block_predecessor_rocksdb_set::change_block (nano::change_block const & block_a)
255  {
256  	fill_value (block_a);
257  }
258  void nano::block_predecessor_rocksdb_set::state_block (nano::state_block const & block_a)
259  {
260  	if (!block_a.previous ().is_zero ())
261  	{
262  		fill_value (block_a);
263  	}
264  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_bias_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/bias_layer.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class BiasLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    BiasLayerTest()
16        : blob_bottom_(new Blob<Dtype>(2, 3, 4, 5)),
17          blob_bottom_eltwise_(new Blob<Dtype>(2, 3, 4, 5)),
18          blob_bottom_broadcast_0_(new Blob<Dtype>()),
19          blob_bottom_broadcast_1_(new Blob<Dtype>()),
20          blob_bottom_broadcast_2_(new Blob<Dtype>()),
21          blob_bottom_bias_(new Blob<Dtype>(vector<int>())),
22          blob_top_(new Blob<Dtype>()) {
23      Caffe::set_random_seed(1701);
24      vector<int> broadcast_shape(2);
25      broadcast_shape[0] = 2; broadcast_shape[1] = 3;
26      this->blob_bottom_broadcast_0_->Reshape(broadcast_shape);
27      broadcast_shape[0] = 3; broadcast_shape[1] = 4;
28      this->blob_bottom_broadcast_1_->Reshape(broadcast_shape);
29      broadcast_shape[0] = 4; broadcast_shape[1] = 5;
30      this->blob_bottom_broadcast_2_->Reshape(broadcast_shape);
31      FillerParameter filler_param;
32      filler_param.set_min(1);
33      filler_param.set_max(10);
34      UniformFiller<Dtype> filler(filler_param);
35      filler.Fill(this->blob_bottom_);
36      filler.Fill(this->blob_bottom_eltwise_);
37      filler.Fill(this->blob_bottom_broadcast_0_);
38      filler.Fill(this->blob_bottom_broadcast_1_);
39      filler.Fill(this->blob_bottom_broadcast_2_);
40      filler.Fill(this->blob_bottom_bias_);
41      blob_bottom_vec_.push_back(blob_bottom_);
42      blob_top_vec_.push_back(blob_top_);
43    }
<span onclick='openModal()' class='match'>44    virtual ~BiasLayerTest() {
45      delete blob_bottom_;
46      delete blob_bottom_eltwise_;
47      delete blob_bottom_broadcast_0_;
48      delete blob_bottom_broadcast_1_;
49      delete blob_bottom_broadcast_2_;
50      delete blob_bottom_bias_;
51      delete blob_top_;
52    }
53    Blob<Dtype>* const blob_bottom_;
54    Blob<Dtype>* const blob_bottom_eltwise_;
55    Blob<Dtype>* const blob_bottom_broadcast_0_;
56    Blob<Dtype>* const blob_bottom_broadcast_1_;
57    Blob<Dtype>* const blob_bottom_broadcast_2_;
58    Blob<Dtype>* const blob_bottom_bias_;
59    Blob<Dtype>* const blob_top_;
60    vector<Blob<Dtype>*> blob_bottom_vec_;
61    vector<Blob<Dtype>*> blob_top_vec_;
62  };
</span>63  TYPED_TEST_CASE(BiasLayerTest, TestDtypesAndDevices);
64  TYPED_TEST(BiasLayerTest, TestForwardEltwise) {
65    typedef typename TypeParam::Dtype Dtype;
66    this->blob_bottom_vec_.push_back(this->blob_bottom_eltwise_);
67    LayerParameter layer_param;
68    layer_param.mutable_bias_param()->set_axis(0);
69    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
70    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
71    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
72    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
73    const Dtype* data = this->blob_top_->cpu_data();
74    const int count = this->blob_top_->count();
75    const Dtype* in_data_a = this->blob_bottom_->cpu_data();
76    const Dtype* in_data_b = this->blob_bottom_eltwise_->cpu_data();
77    for (int i = 0; i < count; ++i) {
78      EXPECT_NEAR(data[i], in_data_a[i] + in_data_b[i], 1e-5);
79    }
80  }
81  TYPED_TEST(BiasLayerTest, TestForwardEltwiseInPlace) {
82    typedef typename TypeParam::Dtype Dtype;
83    this->blob_top_vec_[0] = this->blob_bottom_;  
84    Blob<Dtype> orig_bottom(this->blob_bottom_->shape());
85    orig_bottom.CopyFrom(*this->blob_bottom_);
86    this->blob_bottom_vec_.push_back(this->blob_bottom_eltwise_);
87    LayerParameter layer_param;
88    layer_param.mutable_bias_param()->set_axis(0);
89    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
90    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
91    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
92    const Dtype* data = this->blob_bottom_->cpu_data();
93    const int count = this->blob_bottom_->count();
94    const Dtype* in_data_a = orig_bottom.cpu_data();
95    const Dtype* in_data_b = this->blob_bottom_eltwise_->cpu_data();
96    for (int i = 0; i < count; ++i) {
97      EXPECT_NEAR(data[i], in_data_a[i] + in_data_b[i], 1e-5);
98    }
99  }
100  TYPED_TEST(BiasLayerTest, TestBackwardEltwiseInPlace) {
101    typedef typename TypeParam::Dtype Dtype;
102    Blob<Dtype> orig_bottom(this->blob_bottom_->shape());
103    orig_bottom.CopyFrom(*this->blob_bottom_);
104    this->blob_bottom_vec_.push_back(this->blob_bottom_eltwise_);
105    LayerParameter layer_param;
106    layer_param.mutable_bias_param()->set_axis(0);
107    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
108    Blob<Dtype> top_diff(this->blob_bottom_->shape());
109    FillerParameter filler_param;
110    filler_param.set_type("gaussian");
111    filler_param.set_std(1);
112    GaussianFiller<Dtype> filler(filler_param);
113    filler.Fill(&top_diff);
114    vector<bool> propagate_down(2, true);
115    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
116    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
117    caffe_copy(top_diff.count(), top_diff.cpu_data(),
118               this->blob_top_->mutable_cpu_diff());
119    layer->Backward(this->blob_top_vec_, propagate_down, this->blob_bottom_vec_);
120    const bool kReshape = true;
121    const bool kCopyDiff = true;
122    Blob<Dtype> orig_bottom_diff;
123    orig_bottom_diff.CopyFrom(*this->blob_bottom_, kCopyDiff, kReshape);
124    Blob<Dtype> orig_bias_diff;
125    orig_bias_diff.CopyFrom(*this->blob_bottom_eltwise_,
126                              kCopyDiff, kReshape);
127    this->blob_top_vec_[0] = this->blob_bottom_;  
128    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
129    caffe_copy(top_diff.count(), top_diff.cpu_data(),
130               this->blob_bottom_->mutable_cpu_diff());
131    layer->Backward(this->blob_top_vec_, propagate_down, this->blob_bottom_vec_);
132    for (int i = 0; i < this->blob_bottom_->count(); ++i) {
133      EXPECT_NEAR(orig_bottom_diff.cpu_diff()[i],
134                  this->blob_bottom_->cpu_diff()[i], 1e-5);
135    }
136    for (int i = 0; i < this->blob_bottom_eltwise_->count(); ++i) {
137      EXPECT_NEAR(orig_bias_diff.cpu_diff()[i],
138                  this->blob_bottom_eltwise_->cpu_diff()[i], 1e-5);
139    }
140  }
141  TYPED_TEST(BiasLayerTest, TestForwardEltwiseWithParam) {
142    typedef typename TypeParam::Dtype Dtype;
143    LayerParameter layer_param;
144    BiasParameter* bias_param = layer_param.mutable_bias_param();
145    bias_param->set_axis(0);
146    bias_param->set_num_axes(-1);
147    bias_param->mutable_filler()->set_type("gaussian");
148    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
149    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
150    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
151    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
152    const Dtype* data = this->blob_top_->cpu_data();
153    const int count = this->blob_top_->count();
154    const Dtype* in_data_a = this->blob_bottom_->cpu_data();
155    const Dtype* in_data_b = layer->blobs()[0]->cpu_data();
156    for (int i = 0; i < count; ++i) {
157      EXPECT_NEAR(data[i], in_data_a[i] + in_data_b[i], 1e-5);
158    }
159  }
160  TYPED_TEST(BiasLayerTest, TestForwardBroadcastBegin) {
161    typedef typename TypeParam::Dtype Dtype;
162    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_0_);
163    LayerParameter layer_param;
164    layer_param.mutable_bias_param()->set_axis(0);
165    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
166    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
167    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
168    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
169    for (int n = 0; n < this->blob_bottom_->num(); ++n) {
170      for (int c = 0; c < this->blob_bottom_->channels(); ++c) {
171        for (int h = 0; h < this->blob_bottom_->height(); ++h) {
172          for (int w = 0; w < this->blob_bottom_->width(); ++w) {
173            EXPECT_NEAR(this->blob_top_->data_at(n, c, h, w),
174                        this->blob_bottom_->data_at(n, c, h, w) +
175                        this->blob_bottom_broadcast_0_->data_at(n, c, 0, 0),
176                        1e-5);
177          }
178        }
179      }
180    }
181  }
182  TYPED_TEST(BiasLayerTest, TestForwardBroadcastMiddle) {
183    typedef typename TypeParam::Dtype Dtype;
184    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_1_);
185    LayerParameter layer_param;
186    layer_param.mutable_bias_param()->set_axis(1);
187    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
188    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
189    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
190    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
191    for (int n = 0; n < this->blob_bottom_->num(); ++n) {
192      for (int c = 0; c < this->blob_bottom_->channels(); ++c) {
193        for (int h = 0; h < this->blob_bottom_->height(); ++h) {
194          for (int w = 0; w < this->blob_bottom_->width(); ++w) {
195            EXPECT_NEAR(this->blob_top_->data_at(n, c, h, w),
196                        this->blob_bottom_->data_at(n, c, h, w) +
197                        this->blob_bottom_broadcast_1_->data_at(c, h, 0, 0),
198                        1e-5);
199          }
200        }
201      }
202    }
203  }
204  TYPED_TEST(BiasLayerTest, TestForwardBroadcastMiddleInPlace) {
205    typedef typename TypeParam::Dtype Dtype;
206    this->blob_top_vec_[0] = this->blob_bottom_;  
207    Blob<Dtype> orig_bottom(this->blob_bottom_->shape());
208    orig_bottom.CopyFrom(*this->blob_bottom_);
209    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_1_);
210    LayerParameter layer_param;
211    layer_param.mutable_bias_param()->set_axis(1);
212    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
213    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
214    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
215    for (int n = 0; n < this->blob_bottom_->num(); ++n) {
216      for (int c = 0; c < this->blob_bottom_->channels(); ++c) {
217        for (int h = 0; h < this->blob_bottom_->height(); ++h) {
218          for (int w = 0; w < this->blob_bottom_->width(); ++w) {
219            EXPECT_NEAR(this->blob_bottom_->data_at(n, c, h, w),
220                        orig_bottom.data_at(n, c, h, w) +
221                        this->blob_bottom_broadcast_1_->data_at(c, h, 0, 0),
222                        1e-5);
223          }
224        }
225      }
226    }
227  }
228  TYPED_TEST(BiasLayerTest, TestBackwardBroadcastMiddleInPlace) {
229    typedef typename TypeParam::Dtype Dtype;
230    Blob<Dtype> orig_bottom(this->blob_bottom_->shape());
231    orig_bottom.CopyFrom(*this->blob_bottom_);
232    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_1_);
233    LayerParameter layer_param;
234    layer_param.mutable_bias_param()->set_axis(1);
235    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
236    Blob<Dtype> top_diff(this->blob_bottom_->shape());
237    FillerParameter filler_param;
238    filler_param.set_type("gaussian");
239    filler_param.set_std(1);
240    GaussianFiller<Dtype> filler(filler_param);
241    filler.Fill(&top_diff);
242    vector<bool> propagate_down(2, true);
243    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
244    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
245    caffe_copy(top_diff.count(), top_diff.cpu_data(),
246               this->blob_top_->mutable_cpu_diff());
247    layer->Backward(this->blob_top_vec_, propagate_down, this->blob_bottom_vec_);
248    const bool kReshape = true;
249    const bool kCopyDiff = true;
250    Blob<Dtype> orig_bottom_diff;
251    orig_bottom_diff.CopyFrom(*this->blob_bottom_, kCopyDiff, kReshape);
252    Blob<Dtype> orig_bias_diff;
253    orig_bias_diff.CopyFrom(*this->blob_bottom_broadcast_1_,
254                              kCopyDiff, kReshape);
255    this->blob_top_vec_[0] = this->blob_bottom_;  
256    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
257    caffe_copy(top_diff.count(), top_diff.cpu_data(),
258               this->blob_bottom_->mutable_cpu_diff());
259    layer->Backward(this->blob_top_vec_, propagate_down, this->blob_bottom_vec_);
260    for (int i = 0; i < this->blob_bottom_->count(); ++i) {
261      EXPECT_NEAR(orig_bottom_diff.cpu_diff()[i],
262                  this->blob_bottom_->cpu_diff()[i], 1e-5);
263    }
264    for (int i = 0; i < this->blob_bottom_broadcast_1_->count(); ++i) {
265      EXPECT_NEAR(orig_bias_diff.cpu_diff()[i],
266                  this->blob_bottom_broadcast_1_->cpu_diff()[i], 1e-5);
267    }
268  }
269  TYPED_TEST(BiasLayerTest, TestForwardBroadcastMiddleWithParam) {
270    typedef typename TypeParam::Dtype Dtype;
271    LayerParameter layer_param;
272    BiasParameter* bias_param = layer_param.mutable_bias_param();
273    bias_param->set_axis(1);
274    bias_param->set_num_axes(2);
275    bias_param->mutable_filler()->set_type("gaussian");
276    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
277    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
278    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
279    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
280    for (int n = 0; n < this->blob_bottom_->num(); ++n) {
281      for (int c = 0; c < this->blob_bottom_->channels(); ++c) {
282        for (int h = 0; h < this->blob_bottom_->height(); ++h) {
283          for (int w = 0; w < this->blob_bottom_->width(); ++w) {
284            EXPECT_NEAR(this->blob_top_->data_at(n, c, h, w),
285                        this->blob_bottom_->data_at(n, c, h, w) +
286                        layer->blobs()[0]->data_at(c, h, 0, 0), 1e-5);
287          }
288        }
289      }
290    }
291  }
292  TYPED_TEST(BiasLayerTest, TestForwardBroadcastEnd) {
293    typedef typename TypeParam::Dtype Dtype;
294    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_2_);
295    LayerParameter layer_param;
296    layer_param.mutable_bias_param()->set_axis(2);
297    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
298    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
299    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
300    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
301    for (int n = 0; n < this->blob_bottom_->num(); ++n) {
302      for (int c = 0; c < this->blob_bottom_->channels(); ++c) {
303        for (int h = 0; h < this->blob_bottom_->height(); ++h) {
304          for (int w = 0; w < this->blob_bottom_->width(); ++w) {
305            EXPECT_NEAR(this->blob_top_->data_at(n, c, h, w),
306                        this->blob_bottom_->data_at(n, c, h, w) +
307                        this->blob_bottom_broadcast_2_->data_at(h, w, 0, 0),
308                        1e-5);
309          }
310        }
311      }
312    }
313  }
314  TYPED_TEST(BiasLayerTest, TestForwardBias) {
315    typedef typename TypeParam::Dtype Dtype;
316    this->blob_bottom_vec_.push_back(this->blob_bottom_bias_);
317    LayerParameter layer_param;
318    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
319    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
320    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
321    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
322    const Dtype* data = this->blob_top_->cpu_data();
323    const int count = this->blob_top_->count();
324    const Dtype* in_data = this->blob_bottom_->cpu_data();
325    const Dtype bias = *this->blob_bottom_bias_->cpu_data();
326    for (int i = 0; i < count; ++i) {
327      EXPECT_NEAR(data[i], in_data[i] + bias, 1e-5);
328    }
329  }
330  TYPED_TEST(BiasLayerTest, TestForwardBiasAxis2) {
331    typedef typename TypeParam::Dtype Dtype;
332    this->blob_bottom_vec_.push_back(this->blob_bottom_bias_);
333    LayerParameter layer_param;
334    layer_param.mutable_bias_param()->set_axis(2);
335    shared_ptr<BiasLayer<Dtype> > layer(new BiasLayer<Dtype>(layer_param));
336    layer->SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
337    ASSERT_EQ(this->blob_bottom_->shape(), this->blob_top_->shape());
338    layer->Forward(this->blob_bottom_vec_, this->blob_top_vec_);
339    const Dtype* data = this->blob_top_->cpu_data();
340    const int count = this->blob_top_->count();
341    const Dtype* in_data = this->blob_bottom_->cpu_data();
342    const Dtype bias = *this->blob_bottom_bias_->cpu_data();
343    for (int i = 0; i < count; ++i) {
344      EXPECT_NEAR(data[i], in_data[i] + bias, 1e-5);
345    }
346  }
347  TYPED_TEST(BiasLayerTest, TestGradientEltwise) {
348    typedef typename TypeParam::Dtype Dtype;
349    this->blob_bottom_vec_.push_back(this->blob_bottom_eltwise_);
350    LayerParameter layer_param;
351    layer_param.mutable_bias_param()->set_axis(0);
352    BiasLayer<Dtype> layer(layer_param);
353    GradientChecker<Dtype> checker(1e-2, 1e-3);
354    checker.CheckGradientEltwise(&layer, this->blob_bottom_vec_,
355        this->blob_top_vec_);
356  }
357  TYPED_TEST(BiasLayerTest, TestGradientEltwiseWithParam) {
358    typedef typename TypeParam::Dtype Dtype;
359    LayerParameter layer_param;
360    BiasParameter* bias_param = layer_param.mutable_bias_param();
361    bias_param->set_axis(0);
362    bias_param->set_num_axes(-1);
363    bias_param->mutable_filler()->set_type("gaussian");
364    BiasLayer<Dtype> layer(layer_param);
365    GradientChecker<Dtype> checker(1e-2, 1e-3);
366    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
367        this->blob_top_vec_);
368  }
369  TYPED_TEST(BiasLayerTest, TestGradientBroadcastBegin) {
370    typedef typename TypeParam::Dtype Dtype;
371    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_0_);
372    LayerParameter layer_param;
373    layer_param.mutable_bias_param()->set_axis(0);
374    BiasLayer<Dtype> layer(layer_param);
375    GradientChecker<Dtype> checker(1e-2, 1e-3);
376    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
377        this->blob_top_vec_);
378  }
379  TYPED_TEST(BiasLayerTest, TestGradientBroadcastMiddle) {
380    typedef typename TypeParam::Dtype Dtype;
381    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_1_);
382    LayerParameter layer_param;
383    layer_param.mutable_bias_param()->set_axis(1);
384    BiasLayer<Dtype> layer(layer_param);
385    GradientChecker<Dtype> checker(1e-2, 1e-3);
386    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
387        this->blob_top_vec_);
388  }
389  TYPED_TEST(BiasLayerTest, TestGradientBroadcastMiddleWithParam) {
390    typedef typename TypeParam::Dtype Dtype;
391    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_1_);
392    LayerParameter layer_param;
393    BiasParameter* bias_param = layer_param.mutable_bias_param();
394    bias_param->set_axis(1);
395    bias_param->set_num_axes(2);
396    bias_param->mutable_filler()->set_type("gaussian");
397    BiasLayer<Dtype> layer(layer_param);
398    GradientChecker<Dtype> checker(1e-2, 1e-3);
399    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
400        this->blob_top_vec_);
401  }
402  TYPED_TEST(BiasLayerTest, TestGradientBroadcastEnd) {
403    typedef typename TypeParam::Dtype Dtype;
404    this->blob_bottom_vec_.push_back(this->blob_bottom_broadcast_2_);
405    LayerParameter layer_param;
406    layer_param.mutable_bias_param()->set_axis(2);
407    BiasLayer<Dtype> layer(layer_param);
408    GradientChecker<Dtype> checker(1e-2, 1e-3);
409    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
410        this->blob_top_vec_);
411  }
412  TYPED_TEST(BiasLayerTest, TestGradientBias) {
413    typedef typename TypeParam::Dtype Dtype;
414    this->blob_bottom_vec_.push_back(this->blob_bottom_bias_);
415    LayerParameter layer_param;
416    BiasLayer<Dtype> layer(layer_param);
417    GradientChecker<Dtype> checker(1e-2, 1e-3);
418    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
419        this->blob_top_vec_);
420  }
421  TYPED_TEST(BiasLayerTest, TestGradientBiasAxis2) {
422    typedef typename TypeParam::Dtype Dtype;
423    this->blob_bottom_vec_.push_back(this->blob_bottom_bias_);
424    LayerParameter layer_param;
425    layer_param.mutable_bias_param()->set_axis(2);
426    BiasLayer<Dtype> layer(layer_param);
427    GradientChecker<Dtype> checker(1e-2, 1e-3);
428    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
429        this->blob_top_vec_);
430  }
431  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store_64.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_bias_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>10  	virtual ~block_predecessor_rocksdb_set () = default;
11  	void fill_value (nano::block const & block_a);
12  	void send_block (nano::send_block const & block_a) override;
13  	void receive_block (nano::receive_block const & block_a) override;
14  	void open_block (nano::open_block const & block_a) override;
15  	void change_block (nano::change_block const & block_a) override;
16  	void state_block (nano::state_block const & block_a) override;
17  	nano::write_transaction const & transaction;
18  	nano::rocksdb::block_store & block_store;
19  };
</pre></code></div>
                <div class="column column_space"><pre><code>44    virtual ~BiasLayerTest() {
45      delete blob_bottom_;
46      delete blob_bottom_eltwise_;
47      delete blob_bottom_broadcast_0_;
48      delete blob_bottom_broadcast_1_;
49      delete blob_bottom_broadcast_2_;
50      delete blob_bottom_bias_;
51      delete blob_top_;
52    }
53    Blob<Dtype>* const blob_bottom_;
54    Blob<Dtype>* const blob_bottom_eltwise_;
55    Blob<Dtype>* const blob_bottom_broadcast_0_;
56    Blob<Dtype>* const blob_bottom_broadcast_1_;
57    Blob<Dtype>* const blob_bottom_broadcast_2_;
58    Blob<Dtype>* const blob_bottom_bias_;
59    Blob<Dtype>* const blob_top_;
60    vector<Blob<Dtype>*> blob_bottom_vec_;
61    vector<Blob<Dtype>*> blob_top_vec_;
62  };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    