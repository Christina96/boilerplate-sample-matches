
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.689863842662632%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pitsync1.cpp</h3>
            <pre><code>1  #include "pitsync1.h"
2  #include <cfloat> 
3  #include <cmath>
4  namespace tesseract {
5  INT_VAR(pitsync_linear_version, 6, "Use new fast algorithm");
6  double_VAR(pitsync_joined_edge, 0.75, "Dist inside big blob for chopping");
7  double_VAR(pitsync_offset_freecut_fraction, 0.25, "Fraction of cut for free cuts");
8  FPSEGPT::FPSEGPT(  
9      FPCUTPT *cutpt 
10  ) {
11    pred = nullptr;
12    mean_sum = cutpt->sum();
13    sq_sum = cutpt->squares();
14    cost = cutpt->cost_function();
15    faked = cutpt->faked;
16    terminal = cutpt->terminal;
17    fake_count = cutpt->fake_count;
18    xpos = cutpt->position();
19    mid_cuts = cutpt->cheap_cuts();
20  }
21  FPSEGPT::FPSEGPT( 
22      int16_t x     
23      )
24      : xpos(x) {
25    pred = nullptr;
26    mean_sum = 0;
27    sq_sum = 0;
28    cost = 0;
29    faked = false;
30    terminal = false;
31    fake_count = 0;
32    mid_cuts = 0;
33  }
34  FPSEGPT::FPSEGPT(           
35      int16_t x,              
36      bool faking,            
37      int16_t offset,         
38      int16_t region_index,   
39      int16_t pitch,          
40      int16_t pitch_error,    
41      FPSEGPT_LIST *prev_list 
42      )
43      : fake_count(0), xpos(x), mean_sum(0.0), sq_sum(0.0) {
44    int16_t best_fake;              
45    FPSEGPT *segpt;                 
46    int32_t dist;                   
47    double sq_dist;                 
48    double mean;                    
49    double total;                   
50    double factor;                  
51    FPSEGPT_IT pred_it = prev_list; 
52    cost = FLT_MAX;
53    pred = nullptr;
54    faked = faking;
55    terminal = false;
56    best_fake = INT16_MAX;
57    mid_cuts = 0;
58    for (pred_it.mark_cycle_pt(); !pred_it.cycled_list(); pred_it.forward()) {
59      segpt = pred_it.data();
60      if (segpt->fake_count < best_fake) {
61        best_fake = segpt->fake_count;
62      }
63      dist = x - segpt->xpos;
64      if (dist >= pitch - pitch_error && dist <= pitch + pitch_error && !segpt->terminal) {
65        total = segpt->mean_sum + dist;
66        sq_dist = dist * dist + segpt->sq_sum + offset * offset;
67        mean = total / region_index;
68        factor = mean - pitch;
69        factor *= factor;
70        factor += sq_dist / (region_index)-mean * mean;
71        if (factor < cost) {
72          cost = factor; 
73          pred = segpt;  
74          mean_sum = total;
75          sq_sum = sq_dist;
76          fake_count = segpt->fake_count + faked;
77        }
78      }
79    }
80    if (fake_count > best_fake + 1) {
81      pred = nullptr; 
<span onclick='openModal()' class='match'>82    }
83  }
84  double check_pitch_sync(   
85      BLOBNBOX_IT *blob_it,  
86      int16_t blob_count,    
87      int16_t pitch,         
88      int16_t pitch_error,   
89      STATS *projection,     
90      FPSEGPT_LIST *seg_list 
91  ) {
92    int16_t x;          
</span>93    int16_t min_index;  
94    int16_t max_index;  
95    int16_t left_edge;  
96    int16_t right_edge; 
97    int16_t right_max;  
98    int16_t min_x;      
99    int16_t max_x;
100    int16_t region_index;
101    int16_t best_region_index = 0; 
102    int16_t offset;                
103    int16_t left_best_x;           
104    int16_t right_best_x;          
105    TBOX min_box;                  
106    TBOX max_box;                  
107    TBOX next_box;                 
108    FPSEGPT *segpt;                
109    FPSEGPT_LIST *segpts;          
110    double best_cost;              
111    double mean_sum;               
112    FPSEGPT *best_end;             
113    BLOBNBOX_IT min_it;            
114    BLOBNBOX_IT max_it;            
115    FPSEGPT_IT segpt_it;           
116    FPSEGPT_IT outseg_it = seg_list;
117    FPSEGPT_LIST_CLIST lattice; 
118    FPSEGPT_LIST_C_IT lattice_it = &lattice;
119    if (pitch < 3) {
120      pitch = 3; 
121    }
122    if ((pitch - 3) / 2 < pitch_error) {
123      pitch_error = (pitch - 3) / 2;
124    }
125    min_it = *blob_it;
126    min_box = box_next(&min_it); 
127    left_edge = min_box.left() + pitch_error;
128    for (min_index = 1; min_index < blob_count; min_index++) {
129      min_box = box_next(&min_it);
130    }
131    right_edge = min_box.right(); 
132    max_x = left_edge;
133    min_x = max_x - pitch + pitch_error * 2 + 1;
134    right_max = right_edge + pitch - pitch_error - 1;
135    segpts = new FPSEGPT_LIST; 
136    segpt_it.set_to_list(segpts);
137    for (x = min_x; x <= max_x; x++) {
138      segpt = new FPSEGPT(x); 
139      segpt_it.add_after_then_move(segpt);
140    }
141    lattice_it.add_before_then_move(segpts);
142    min_index = 0;
143    region_index = 1;
144    best_cost = FLT_MAX;
145    best_end = nullptr;
146    min_it = *blob_it;
147    min_box = box_next(&min_it); 
148    do {
149      left_best_x = -1;
150      right_best_x = -1;
151      segpts = new FPSEGPT_LIST; 
152      segpt_it.set_to_list(segpts);
153      min_x += pitch - pitch_error; 
154      max_x += pitch + pitch_error;
155      while (min_box.right() < min_x && min_index < blob_count) {
156        min_index++;
157        min_box = box_next(&min_it);
158      }
159      max_it = min_it;
160      max_index = min_index;
161      max_box = min_box;
162      next_box = box_next(&max_it);
163      for (x = min_x; x <= max_x && x <= right_max; x++) {
164        while (x < right_edge && max_index < blob_count && x > max_box.right()) {
165          max_index++;
166          max_box = next_box;
167          next_box = box_next(&max_it);
168        }
169        if (x <= max_box.left() + pitch_error || x >= max_box.right() - pitch_error ||
170            x >= right_edge || (max_index < blob_count - 1 && x >= next_box.left()) ||
171            (x - max_box.left() > pitch * pitsync_joined_edge &&
172             max_box.right() - x > pitch * pitsync_joined_edge)) {
173          if (x - max_box.left() > 0 && x - max_box.left() <= pitch_error) {
174            offset = x - max_box.left();
175          } else if (max_box.right() - x > 0 && max_box.right() - x <= pitch_error &&
176                     (max_index >= blob_count - 1 || x < next_box.left())) {
177            offset = max_box.right() - x;
178          } else {
179            offset = 0;
180          }
181          segpt = new FPSEGPT(x, false, offset, region_index, pitch, pitch_error, lattice_it.data());
182        } else {
183          offset = projection->pile_count(x);
184          segpt = new FPSEGPT(x, true, offset, region_index, pitch, pitch_error, lattice_it.data());
185        }
186        if (segpt->previous() != nullptr) {
187          segpt_it.add_after_then_move(segpt);
188          if (x >= right_edge - pitch_error) {
189            segpt->terminal = true; 
190            if (segpt->cost_function() < best_cost) {
191              best_cost = segpt->cost_function();
192              best_end = segpt;
193              best_region_index = region_index;
194              left_best_x = x;
195              right_best_x = x;
196            } else if (segpt->cost_function() == best_cost && right_best_x == x - 1) {
197              right_best_x = x;
198            }
199          }
200        } else {
201          delete segpt; 
202        }
203      }
204      if (segpts->empty()) {
205        if (best_end != nullptr) {
206          break; 
207        }
208        make_illegal_segment(lattice_it.data(), min_box, min_it, region_index, pitch, pitch_error,
209                             segpts);
210      } else {
211        if (right_best_x > left_best_x + 1) {
212          left_best_x = (left_best_x + right_best_x + 1) / 2;
213          for (segpt_it.mark_cycle_pt();
214               !segpt_it.cycled_list() && segpt_it.data()->position() != left_best_x;
215               segpt_it.forward()) {
216            ;
217          }
218          if (segpt_it.data()->position() == left_best_x) {
219            best_end = segpt_it.data();
220          }
221        }
222      }
223      lattice_it.add_before_then_move(segpts);
224      region_index++;
225    } while (min_x < right_edge);
226    ASSERT_HOST(best_end != nullptr); 
227    for (lattice_it.mark_cycle_pt(); !lattice_it.cycled_list(); lattice_it.forward()) {
228      segpts = lattice_it.data();
229      segpt_it.set_to_list(segpts);
230      for (segpt_it.mark_cycle_pt(); !segpt_it.cycled_list() && segpt_it.data() != best_end;
231           segpt_it.forward()) {
232        ;
233      }
234      if (segpt_it.data() == best_end) {
235        segpt = segpt_it.extract();
236        outseg_it.add_before_then_move(segpt);
237        best_end = segpt->previous();
238      }
239    }
240    ASSERT_HOST(best_end == nullptr);
241    ASSERT_HOST(!outseg_it.empty());
242    outseg_it.move_to_last();
243    mean_sum = outseg_it.data()->sum();
244    mean_sum = mean_sum * mean_sum / best_region_index;
245    if (outseg_it.data()->squares() - mean_sum < 0) {
246      tprintf("Impossible sqsum=%g, mean=%g, total=%d\n", outseg_it.data()->squares(),
247              outseg_it.data()->sum(), best_region_index);
248    }
249    lattice.deep_clear(); 
250    return outseg_it.data()->squares() - mean_sum;
251  }
252  void make_illegal_segment(   
253      FPSEGPT_LIST *prev_list, 
254      TBOX blob_box,           
255      BLOBNBOX_IT blob_it,     
256      int16_t region_index,    
257      int16_t pitch,           
258      int16_t pitch_error,     
259      FPSEGPT_LIST *seg_list   
260  ) {
261    int16_t x;         
262    int16_t min_x = 0; 
263    int16_t max_x = 0;
264    int16_t offset;                 
265    FPSEGPT *segpt;                 
266    FPSEGPT *prevpt;                
267    float best_cost;                
268    FPSEGPT_IT segpt_it = seg_list; 
269    FPSEGPT_IT prevpt_it = prev_list;
270    best_cost = FLT_MAX;
271    for (prevpt_it.mark_cycle_pt(); !prevpt_it.cycled_list(); prevpt_it.forward()) {
272      prevpt = prevpt_it.data();
273      if (prevpt->cost_function() < best_cost) {
274        best_cost = prevpt->cost_function();
275        min_x = prevpt->position();
276        max_x = min_x; 
277      } else if (prevpt->cost_function() == best_cost) {
278        max_x = prevpt->position();
279      }
280    }
281    min_x += pitch - pitch_error;
282    max_x += pitch + pitch_error;
283    for (x = min_x; x <= max_x; x++) {
284      while (x > blob_box.right()) {
285        blob_box = box_next(&blob_it);
286      }
287      offset = x - blob_box.left();
288      if (blob_box.right() - x < offset) {
289        offset = blob_box.right() - x;
290      }
291      segpt = new FPSEGPT(x, false, offset, region_index, pitch, pitch_error, prev_list);
292      if (segpt->previous() != nullptr) {
293        ASSERT_HOST(offset >= 0);
294        fprintf(stderr, "made fake at %d\n", x);
295        segpt_it.add_after_then_move(segpt);
296        segpt->faked = true;
297        segpt->fake_count++;
298      } else {
299        delete segpt;
300      }
301    }
302  }
303  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.cpp</h3>
            <pre><code>1  #include "yahoodm.h"
2  TYTb::TYTb(const PYBs& _YBs, const PYDsBs& _YDsBs):
3    YBs(_YBs), YDsBs(_YDsBs),
4    VarNToWordIdV(YBs->GetWords()), WordIdToVarNV(YBs->GetMxWordIds()),
5    TupNToDocIdV(YBs->GetDocs()), DocIdToTupNV(YBs->GetMxDocIds()){
6    int WordId=YBs->FFirstWordId(); int VarN=0-1;
7    while (YBs->FNextWordId(WordId)){VarN++;
8      VarNToWordIdV[VarN]=WordId; WordIdToVarNV[WordId]=VarN;}
9    int DocId=YBs->FFirstDocId(); int TupN=0-1;
10    while (YBs->FNextDocId(DocId)){TupN++;
11      TupNToDocIdV[TupN]=DocId; DocIdToTupNV[DocId]=TupN;}
12  }
13  TTbVal TYTb::GetVal(const int& TupN, const int& VarN){
14    int DocId=TupNToDocIdV[TupN];
15    int WordId=VarNToWordIdV[VarN];
16    double WordFq;
17    if (YDsBs->GetWordDs(DocId)->IsWordId(WordId, WordFq)){return WordFq;}
<span onclick='openModal()' class='match'>18    else {return double(0);}
19  }
20  TYDmDs::TYDmDs(
21   const bool& _DoPriorDmDs, const int& ClassN,
22   const int& _YNegDsType, const int& _YPriorType,
23   const PYBs& _YBs, const PYDsBs& _YDsBs, const PDmHd& _DmHd):
</span>24    DoPriorDmDs(_DoPriorDmDs),
25    YNegDsType(_YNegDsType), YPriorType(_YPriorType),
26    YBs(_YBs), YDsBs(_YDsBs), DmHd(_DmHd),
27    NegWordDs(), PosWordDs(),
28    CValDs(), NegCValPrb(), PosCValPrb(){
29    NegWordDs=GetNegWordDs(YNegDsType, YBs, YDsBs);
30    PosWordDs=YDsBs->GetWordDs(ClassN);
31    CValDs=GetPriorValDs(YPriorType, NegWordDs, PosWordDs);
32    NegCValPrb=CValDs->GetPrb_RelFq(TTbVal::NegVal);
33    PosCValPrb=CValDs->GetPrb_RelFq(TTbVal::PosVal);
34  }
35  double TYDmDs::GetSumW(){
36    return CValDs->GetSumW();
37  }
38  PTbValDs TYDmDs::GetCDs(){
39    return CValDs;
40  }
41  PTbValDs TYDmDs::GetAVDs(const int& AttrN){
42    if (DoPriorDmDs){
43      return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
44    } else {
45      return TTbValDs::GetBoolValDs(-1,
46       NegCValPrb*NegWordDs->GetWordPrb(AttrN)+
47       PosCValPrb*PosWordDs->GetWordPrb(AttrN));
48    }
49  }
50  PTbValDs TYDmDs::GetCAVDs(const TTbVal& CVal, const int& AttrN){
51    if (DoPriorDmDs){
52      return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
53    } else {
54      if (CVal==TTbVal::NegVal){
55        return TTbValDs::GetBoolValDs(-1, NegWordDs->GetWordPrb(AttrN));
56      } else
57      if (CVal==TTbVal::PosVal){
58        return TTbValDs::GetBoolValDs(-1, PosWordDs->GetWordPrb(AttrN));
59      } else {
60        Fail; return NULL;
61      }
62    }
63  }
64  PYWordDs TYDmDs::GetNegWordDs(
65   const int& YNegDsType, const PYBs& YBs, const PYDsBs& YDsBs){
66    PYWordDs NegWordDs;
67    switch (TYNegDsType(YNegDsType)){
68      case yndtEmpty: NegWordDs=PYWordDs(new TYWordDs(0, 0, 0)); break;
69      case yndtRoot: NegWordDs=YDsBs->GetWordDs(YBs->GetRootDocId()); break;
70      case yndtAll: NegWordDs=YDsBs->GetAllWordDs(); break;
71      default: Fail;
72    }
73    return NegWordDs;
74  }
75  PTbValDs TYDmDs::GetPriorValDs(const int& YPriorType,
76   const PYWordDs& NegWordDs, const PYWordDs& PosWordDs){
77    double PosW; double AllW;
78    switch (TYPriorType(YPriorType)){
79      case yptWords:
80        PosW=PosWordDs->GetSumWordFq(); AllW=NegWordDs->GetSumWordFq(); break;
81      case yptSects:
82        PosW=PosWordDs->GetSects(); AllW=NegWordDs->GetSects(); break;
83      case yptDocs:
84        PosW=PosWordDs->GetDocs(); AllW=NegWordDs->GetDocs(); break;
85      default: Fail;
86    }
87    return TTbValDs::GetBoolValDs(AllW, PosW);
88  }
89  TStr TYDmDs::GetYNegDsTypeStr(const TYNegDsType& YNegDsType){
90    switch (YNegDsType){
91      case yndtEmpty: return "Empty";
92      case yndtRoot: return "Root";
93      case yndtAll: return "All";
94      default: Fail; return TStr();
95    }
96  }
97  TStr TYDmDs::GetYPriorTypeStr(const TYPriorType& YPriorType){
98    switch (YPriorType){
99      case yptWords: return "Words";
100      case yptSects: return "Sects";
101      case yptDocs: return "Docs";
102      default: Fail; return TStr();
103    }
104  }
105  TYFSelBs::TYFSelBs(
106   const TYFSelType& FSelType, const double& FSels,
107   const bool& FSelPosWords, const PAttrEst& AttrEst,
108   const TYNegDsType& _YNegDsType, const TYPriorType& YPriorType,
109   const PYBs& YBs, const PYDsBs& YDsBs, const PNotify& Notify):
110    YNegDsType(_YNegDsType), DocIdToWordIdEstVV(YBs->GetDocs()){
111    TNotify::OnNotify(Notify, ntInfo, "Start Feature Selection");
112    PDmHd DmHd=new TYDmHd(YBs, YDsBs);
113    PYWordDs NegWordDs=TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs);
114    PTbValSplit BoolValSplit=TTbValSplit::GetBoolValSplit();
115    int DocId=YBs->FFirstDocId(); int DocIds=0;
116    while (YBs->FNextDocId(DocId)){
117      PYWordDs PosWordDs=YDsBs->GetWordDs(DocId); DocIds++;
118      int SelWordIds;
119      switch (FSelType){
120        case yfstFix: SelWordIds=int(FSels); break;
121        case yfstPosPrc:
122          SelWordIds=int(FSels*double(PosWordDs->GetWordIds())); break;
123        case yfstUnionPrc:{
124          PYWordDs UnionWordDs=TYWordDs::GetMerged(PosWordDs, NegWordDs, 1, 1);
125          SelWordIds=int(FSels*double(UnionWordDs->GetWordIds())); break;}
126        default: Fail; SelWordIds=0;
127      }
128      if (SelWordIds<=0){SelWordIds=1;}
129      PDmDs DmDs=PDmDs(new TYDmDs(
130       false, DocId, YNegDsType, YPriorType, YBs, YDsBs, DmHd));
131      PDmDs PriorDmDs=PDmDs(new TYDmDs(
132       true, DocId, yndtAll, yptDocs, YBs, YDsBs, DmHd));
133      PYWordDs WordDs; PYWordDs TrvWordDs;
134      TIntH SelWordIdH(SelWordIds);
135      TFltIntKdV WordEstIdKdV(SelWordIds, 0);
136      for (int CDsc=0; CDsc<TTbVal::BoolVals; CDsc++){
137        switch (CDsc){
138          case 0: WordDs=NegWordDs; break;
139          case 1: WordDs=PosWordDs; break;
140          default: Fail;
141        }
142        if (FSelPosWords){TrvWordDs=PosWordDs;} else {TrvWordDs=WordDs;}
143        int WordIdN=TrvWordDs->FFirstWordId(); int WordId;
144        while (TrvWordDs->FNextWordId(WordIdN, WordId)){
145          if (SelWordIdH.IsKey(WordId)){continue;}
146          double WordEst;
147          if (AttrEst.Empty()){
148            double PriorSumW=YBs->GetDocs();
149            IAssert(PriorSumW>0);
150            double S1C0Prb=NegWordDs->GetWordPrb(WordId);
151            double S1C1Prb=PosWordDs->GetWordPrb(WordId);
152            if (S1C0Prb==0){S1C0Prb=1/sqr(PriorSumW);}
153            if (S1C0Prb==1){S1C0Prb=1-(1/sqr(PriorSumW));}
154            double OddsS1C0=S1C0Prb/(1-S1C0Prb);
155            if (S1C1Prb==0){S1C1Prb=1/sqr(PriorSumW);}
156            if (S1C1Prb==1){S1C1Prb=1-(1/sqr(PriorSumW));}
157            double OddsS1C1=S1C1Prb/(1-S1C1Prb);
158            WordEst=log(OddsS1C1/OddsS1C0);
159          } else {
160            WordEst=AttrEst->GetAttrQ(WordId, BoolValSplit, DmDs, PriorDmDs);
161          }
162          WordEstIdKdV.AddSorted(TFltIntKd(WordEst, WordId), false, SelWordIds);
163          SelWordIdH.AddKey(WordId);
164        }
165      }
166      TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
167      WordIdEstKdV.Gen(WordEstIdKdV.Len(), 0);
168      for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
169        double WordEst=WordEstIdKdV[WordIdN].Key;
170        int WordId=WordEstIdKdV[WordIdN].Dat;
171        WordIdEstKdV.Add(TIntFltKd(WordId, WordEst));
172      }
173      WordIdEstKdV.Sort();
174      if (DocIds%100==0){
175        TNotify::OnNotify(Notify, ntInfo,
176         TStr("...")+TInt::GetStr(DocIds)+" Selections.");}
177    }
178    TNotify::OnNotify(Notify, ntInfo,
179     TStr("Feature Selection Finished (")+ TInt::GetStr(DocIds)+").");
180  }
181  void TYFSelBs::GetBestWordIdV(
182   const int& DocId, const double& EstExp, const double& SumEstPrb,
183   const PYWordDs& IntrsWordDs, TIntV& BestWordIdV){
184    TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
185    TFltIntKdV WordEstIdKdV(WordIdEstKdV.Len(), 0);
186    double MnWordEst=TFlt::Mx;
187    for (int WordIdN=0; WordIdN<WordIdEstKdV.Len(); WordIdN++){
188      int WordId=WordIdEstKdV[WordIdN].Key;
189      double WordEst=pow(WordIdEstKdV[WordIdN].Dat, EstExp);
190      if (IntrsWordDs->IsWordId(WordId)){
191        WordEstIdKdV.Add(TFltIntKd(WordEst, WordId));
192        MnWordEst=TFlt::GetMn(WordEst, MnWordEst);
193      }
194    }
195    double SumWordEst=0;
196    {for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
197      SumWordEst+=(WordEstIdKdV[WordIdN].Key-=MnWordEst);}}
198    WordEstIdKdV.Sort(false);
199    {BestWordIdV.Gen(WordEstIdKdV.Len(), 0);
200    SumWordEst*=SumEstPrb; int WordIdN=0;
201    while ((SumWordEst>=0)&&(WordIdN<WordEstIdKdV.Len())){
202      double WordEst=WordEstIdKdV[WordIdN].Key;
203      int WordId=WordEstIdKdV[WordIdN].Dat;
204      SumWordEst-=WordEst;
205      BestWordIdV.Add(WordId);
206      WordIdN++;
207    }}
208  }
209  void TYFSelBs::SaveTxt(
210   const PSOut& SOut, const PYBs& YBs, const PYDsBs& YDsBs){
211    PYWordDs NegWordDs=TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs);
212    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
213    for (int DocId=0; DocId<DocIdToWordIdEstVV.Len(); DocId++){
214      TIntFltKdV& WordIdEstKdV=DocIdToWordIdEstVV[DocId];
215      TFltIntKdV WordEstIdKdV(WordIdEstKdV.Len(), 0);
216      for (int WordIdN=0; WordIdN<WordIdEstKdV.Len(); WordIdN++){
217        int WordId=WordIdEstKdV[WordIdN].Key;
218        double WordEst=WordIdEstKdV[WordIdN].Dat;
219        WordEstIdKdV.Add(TFltIntKd(WordEst, WordId));
220      }
221      WordEstIdKdV.Sort(false);
222      Lx.PutVarStr("UrlStr", YBs->GetDocUrlStr(DocId));
223      Lx.PutVarInt("DocId", DocId);
224      PYWordDs WordDs=YDsBs->GetWordDs(DocId);
225      Lx.PutVar("WordIdEstKdV", true, true); 
226      {for (int WordIdN=0; WordIdN<WordEstIdKdV.Len(); WordIdN++){
227        double WordEst=WordEstIdKdV[WordIdN].Key;
228        int WordId=WordEstIdKdV[WordIdN].Dat;
229        TStr WordStr=YBs->GetWordStr(WordId);
230        double PosWordPrb=WordDs->GetWordPrb(WordId);
231        double NegWordPrb=NegWordDs->GetWordPrb(WordId);
232        Lx.PutQStr(WordStr);
233        Lx.PutTab(); Lx.PutFlt(WordEst);
234        Lx.PutIndent(1); Lx.PutSym(syLBracket);
235        Lx.PutFlt(PosWordPrb); Lx.PutFlt(NegWordPrb);
236        Lx.PutSym(syRBracket);
237        Lx.PutLn();
238      }}
239      Lx.PutSym(syRBracket); Lx.PutLn();
240    }
241  }
242  TStr TYFSelBs::GetYFSelTypeStr(const TYFSelType& YFSelType){
243    switch (YFSelType){
244      case yfstFix: return "Fix";
245      case yfstPosPrc: return "PosPrc";
246      case yfstUnionPrc: return "NegPrc";
247      default: Fail; return TStr();
248    }
249  }
250  TYInvIx::TYInvIx(
251   const double& EstExp, const double& SumEstPrb,
252   const PYBs& YBs, const PYDsBs& YDsBs,
253   const PYFSelBs& YFSelBs, const PNotify& Notify):
254    WordIdToFirstDocIdNH(YBs->GetWords()/2),
255    DocIdVHeap(), AllDocIdV(YBs->GetDocs(), 0){
256    TNotify::OnNotify(Notify, ntInfo, "Start Creating Inverted Index");
257    TIntPrV WordIdDocIdPrV(YBs->GetDocs(), 0);
258    TIntV BestWordIdV;
259    int DocId=YBs->FFirstDocId();
260    while (YBs->FNextDocId(DocId)){
261      AllDocIdV.Add(DocId);
262      PYWordDs PosWordDs=YDsBs->GetWordDs(DocId);
263      YFSelBs->GetBestWordIdV(DocId, EstExp, SumEstPrb, PosWordDs, BestWordIdV);
264      for (int WordIdN=0; WordIdN<BestWordIdV.Len(); WordIdN++){
265        int WordId=BestWordIdV[WordIdN];
266        WordIdDocIdPrV.Add(TIntPr(WordId, DocId));
267      }
268    }
269    WordIdDocIdPrV.Sort();
270    DocIdVHeap.Gen(WordIdDocIdPrV.Len()+YBs->GetDocs(), 0);
271    int PrevWordId=-1;
272    for (int WordIdN=0; WordIdN<WordIdDocIdPrV.Len(); WordIdN++){
273      int WordId=WordIdDocIdPrV[WordIdN].Val1;
274      int DocId=WordIdDocIdPrV[WordIdN].Val2;
275      if (PrevWordId!=WordId){
276        if (PrevWordId!=-1){DocIdVHeap.Add(TInt(-1));}
277        PrevWordId=WordId;
278        WordIdToFirstDocIdNH.AddDat(TInt(WordId), TInt(DocIdVHeap.Len()));
279      }
280      DocIdVHeap.Add(DocId);
281    }
282    DocIdVHeap.Add(TInt(-1));
283    TNotify::OnNotify(Notify, ntInfo, "End Creating Inverted Index");
284  }
285  void TYInvIx::GetDocIdV(
286   const PYWordDs& WordDs, const int& MnDocFq, TIntV& DocIdV){
287    IAssert(MnDocFq>=0);
288    if (MnDocFq==0){
289      DocIdV=AllDocIdV;
290    } else {
291      TIntIntH DocIdFqH(100); int MxDocFq=0;
292      int WordIdN=WordDs->FFirstWordId(); int WordId; double WordFq;
293      while (WordDs->FNextWordId(WordIdN, WordId, WordFq)){
294        if (WordIdToFirstDocIdNH.IsKey(WordId)){
295          int DocIdN=FFirstDocId(WordId); int DocId;
296          while (FNextWordId(DocIdN, DocId)){
297            DocIdFqH.AddDat(DocId)+=int(WordFq);
298            MxDocFq=TInt::GetMx(MxDocFq, DocIdFqH.GetDat(DocId));
299          }
300        }
301      }
302      int NewMnDocFq=(MnDocFq<=MxDocFq) ? MnDocFq : MxDocFq-3;
303      DocIdV.Gen(DocIdFqH.Len(), 0);
304      int DocIdP=DocIdFqH.FFirstKeyId();
305      while (DocIdFqH.FNextKeyId(DocIdP)){
306        int DocId=DocIdFqH.GetKey(DocIdP);
307        int DocFq=DocIdFqH[DocIdP];
308        if (DocFq>=NewMnDocFq){DocIdV.Add(DocId);}
309      }
310    }
311  }
312  void TYInvIx::SaveTxt(const PSOut& SOut, const PYBs& YBs){
313    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
314    int WordIdToFirstDocIdNP=WordIdToFirstDocIdNH.FFirstKeyId();
315    while (WordIdToFirstDocIdNH.FNextKeyId(WordIdToFirstDocIdNP)){
316      int WordId=WordIdToFirstDocIdNH.GetKey(WordIdToFirstDocIdNP);
317      TStr WordStr;
318      if (YBs.Empty()){WordStr=TInt::GetStr(WordId);}
319      else {WordStr=YBs->GetWordStr(WordId);}
320      Lx.PutStr(WordStr); Lx.PutSym(syColon); Lx.PutSym(syLBracket);
321      int DocIdN=FFirstDocId(WordId); int DocId;
322      while (FNextWordId(DocIdN, DocId)){
323        Lx.PutInt(DocId);}
324      Lx.PutSym(syRBracket); Lx.PutLn();
325    }
326  }
327  bool TYValRet::FNextAttrN(int& AttrP, int& AttrN, TTbVal& AttrVal) const {
328    bool IsFNext; double WordFq; double WordPrb;
329    do {
330      IsFNext=WordDs->FNextWordId(AttrP, AttrN, WordFq, WordPrb);
331      if ((IsFNext)&&(WordPrb>MnWordPrb)){AttrVal=TTbVal(WordFq); return true;}
332    } while (IsFNext);
333    return false;
334  }
335  TMdYBayes::TMdYBayes(
336   const TYNegDsType& _YNegDsType, const TYPriorType& _YPriorType,
337   const PYBs& _YBs, const PYDsBs& _YDsBs,
338   const PYFSelBs& _YFSelBs, const PYInvIx& _YInvIx):
339    TMd(PDmHd(new TYDmHd(_YBs, _YDsBs))),
340    YNegDsType(_YNegDsType), YPriorType(_YPriorType),
341    YBs(_YBs), YDsBs(_YDsBs),
342    YFSelBs(_YFSelBs), YInvIx(_YInvIx),
343    NegWordDs(TYDmDs::GetNegWordDs(YNegDsType, YBs, YDsBs)){
344    Def();
345  }
346  PMd TMdYBayes::Load(TSIn& SIn){
347    TStr TypeNm(SIn); 
348    IAssert(TypeNm==TTypeNm<TMdYBayes>());
349    TYNegDsType YNegDsType=TYNegDsType(int(TInt(SIn)));
350    TYPriorType YPriorType=TYPriorType(int(TInt(SIn)));
351    PYBs YBs(SIn);
352    PYDsBs YDsBs(SIn);
353    PYFSelBs YFSelBs(SIn);
354    PYInvIx YInvIx(SIn);
355    PYWordDs NegWordDs(SIn); SIn.LoadCs();
356    PMd Md=PMd(new TMdYBayes(
357     YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx));
358    return Md;
359  }
360  void TMdYBayes::Save(TSOut& SOut){
361    GetTypeNm(*this).Save(SOut);
362    YNegDsType.Save(SOut); YPriorType.Save(SOut);
363    YBs.Save(SOut);
364    YDsBs.Save(SOut);
365    YFSelBs.Save(SOut);
366    YInvIx.Save(SOut);
367    NegWordDs.Save(SOut);
368    SOut.SaveCs();
369  }
370  PTbValDs TMdYBayes::GetPostrValDs(
371   const PValRet& ValRet, const int& ClassN) const {
372    PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
373    PTbValDs PriorValDs=GetPriorValDs(ClassN);
374    TIntFltKdV& WordIdEstKdV=YFSelBs->GetWordIdEstV(ClassN);
375    double LnSumW=log(PriorValDs->GetSumW());
376    PTbValDs ValDs=new TTbValDs(TTbVal::BoolVals);
377    double NegPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::NegVal);
378    double PosPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::PosVal);
379    double NegLnPriorCPrb=0; double NegLnPostrCPrb=0;
380    double PosLnPriorCPrb=0; double PosLnPostrCPrb=0;
381    if (NegPriorCPrb!=0){NegLnPostrCPrb=NegLnPriorCPrb=log(NegPriorCPrb);}
382    if (PosPriorCPrb!=0){PosLnPostrCPrb=PosLnPriorCPrb=log(PosPriorCPrb);}
383    int AttrP=ValRet->FFirstAttrN(); int AttrN; TTbVal AVal;
384    while (ValRet->FNextAttrN(AttrP, AttrN, AVal)){
385      int WordId=AttrN; double WordFq=AVal.GetFlt();
386      if (YFSelBs->IsWordId(WordIdEstKdV, WordId)){
387        if (NegPriorCPrb!=0){
388          double NegAValPrb=NegWordDs->GetWordPrb(WordId);
389          if (NegAValPrb==0){NegLnPostrCPrb+=NegLnPriorCPrb-LnSumW;}
390          else {NegLnPostrCPrb+=log(WordFq*NegAValPrb);}
391        }
392        if (PosPriorCPrb!=0){
393          double PosAValPrb=PosWordDs->GetWordPrb(WordId);
394          if (PosAValPrb==0){PosLnPostrCPrb+=PosLnPriorCPrb-LnSumW;}
395          else {PosLnPostrCPrb+=log(WordFq*PosAValPrb);}
396        }
397      }
398    }
399    if (NegPriorCPrb!=0){ValDs->AddVal(TTbVal::NegVal, NegLnPostrCPrb);}
400    if (PosPriorCPrb!=0){ValDs->AddVal(TTbVal::PosVal, PosLnPostrCPrb);}
401    ValDs->ExpW(); ValDs->Def();
402    return ValDs;
403  }
404  PTbValDs TMdYBayes::GetPostrValDs(
405   const PValRet& ValRet, const int& ClassN, TFltIntKdV& WordPrbIdV) const {
406    WordPrbIdV.Clr();
407    PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
408    PTbValDs PriorValDs=GetPriorValDs(ClassN);
409    TIntFltKdV& WordIdEstKdV=YFSelBs->GetWordIdEstV(ClassN);
410    double LnSumW=log(PriorValDs->GetSumW());
411    PTbValDs ValDs=new TTbValDs(TTbVal::BoolVals);
412    double NegPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::NegVal);
413    double PosPriorCPrb=PriorValDs->GetPrb_RelFq(TTbVal::PosVal);
414    double NegLnPriorCPrb=0; double NegLnPostrCPrb=0;
415    double PosLnPriorCPrb=0; double PosLnPostrCPrb=0;
416    if (NegPriorCPrb!=0){NegLnPostrCPrb=NegLnPriorCPrb=log(NegPriorCPrb);}
417    if (PosPriorCPrb!=0){PosLnPostrCPrb=PosLnPriorCPrb=log(PosPriorCPrb);}
418    int AttrP=ValRet->FFirstAttrN(); int AttrN; TTbVal AVal;
419    while (ValRet->FNextAttrN(AttrP, AttrN, AVal)){
420      int WordId=AttrN; double WordFq=AVal.GetFlt();
421      if (YFSelBs->IsWordId(WordIdEstKdV, WordId)){
422        if (NegPriorCPrb!=0){
423          double NegAValPrb=NegWordDs->GetWordPrb(WordId);
424          if (NegAValPrb==0){NegLnPostrCPrb+=NegLnPriorCPrb-LnSumW;}
425          else {NegLnPostrCPrb+=log(WordFq*NegAValPrb);}
426          if (NegAValPrb!=0){
427            WordPrbIdV.Add(TFltIntKd(-&bsol;*WordFq**/NegAValPrb, WordId));}
428        }
429        if (PosPriorCPrb!=0){
430          double PosAValPrb=PosWordDs->GetWordPrb(WordId);
431          if (PosAValPrb==0){PosLnPostrCPrb+=PosLnPriorCPrb-LnSumW;}
432          else {PosLnPostrCPrb+=log(WordFq*PosAValPrb);}
433          if (PosAValPrb!=0){
434            WordPrbIdV.Add(TFltIntKd(&bsol;*WordFq**/PosAValPrb, WordId));}
435        }
436      }
437    }
438    if (NegPriorCPrb!=0){ValDs->AddVal(TTbVal::NegVal, NegLnPostrCPrb);}
439    if (PosPriorCPrb!=0){ValDs->AddVal(TTbVal::PosVal, PosLnPostrCPrb);}
440    ValDs->ExpW(); ValDs->Def();
441    WordPrbIdV.Sort(false);
442    return ValDs;
443  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pitsync1.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.cpp</div>
                </div>
                <div class="column column_space"><pre><code>82    }
83  }
84  double check_pitch_sync(   
85      BLOBNBOX_IT *blob_it,  
86      int16_t blob_count,    
87      int16_t pitch,         
88      int16_t pitch_error,   
89      STATS *projection,     
90      FPSEGPT_LIST *seg_list 
91  ) {
92    int16_t x;          
</pre></code></div>
                <div class="column column_space"><pre><code>18    else {return double(0);}
19  }
20  TYDmDs::TYDmDs(
21   const bool& _DoPriorDmDs, const int& ClassN,
22   const int& _YNegDsType, const int& _YPriorType,
23   const PYBs& _YBs, const PYDsBs& _YDsBs, const PDmHd& _DmHd):
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    