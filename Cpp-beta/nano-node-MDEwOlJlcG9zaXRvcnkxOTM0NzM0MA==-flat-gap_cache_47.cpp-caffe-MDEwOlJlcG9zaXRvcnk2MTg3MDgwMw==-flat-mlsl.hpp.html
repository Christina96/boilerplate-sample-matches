
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.3783783783783785%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-gap_cache_47.cpp</h3>
            <pre><code>1  #include <nano/node/gap_cache.hpp>
2  #include <nano/node/node.hpp>
3  #include <nano/secure/store.hpp>
4  #include <boost/format.hpp>
5  nano::gap_cache::gap_cache (nano::node & node_a) :
6  	node (node_a)
7  {
8  }
9  void nano::gap_cache::add (nano::block_hash const & hash_a, std::chrono::steady_clock::time_point time_point_a)
10  {
11  	nano::lock_guard<nano::mutex> lock{ mutex };
12  	auto existing (blocks.get<tag_hash> ().find (hash_a));
13  	if (existing != blocks.get<tag_hash> ().end ())
14  	{
15  		blocks.get<tag_hash> ().modify (existing, [time_point_a] (nano::gap_information & info) {
16  			info.arrival = time_point_a;
17  		});
18  	}
19  	else
20  	{
21  		blocks.get<tag_arrival> ().emplace (nano::gap_information{ time_point_a, hash_a, std::vector<nano::account> () });
22  		if (blocks.get<tag_arrival> ().size () > max)
23  		{
24  			blocks.get<tag_arrival> ().erase (blocks.get<tag_arrival> ().begin ());
25  		}
26  	}
27  }
28  void nano::gap_cache::erase (nano::block_hash const & hash_a)
29  {
30  	nano::lock_guard<nano::mutex> lock{ mutex };
31  	blocks.get<tag_hash> ().erase (hash_a);
32  }
33  void nano::gap_cache::vote (std::shared_ptr<nano::vote> const & vote_a)
34  {
35  	nano::lock_guard<nano::mutex> lock{ mutex };
36  	for (auto const & hash : vote_a->hashes)
37  	{
38  		auto & gap_blocks_by_hash (blocks.get<tag_hash> ());
39  		auto existing (gap_blocks_by_hash.find (hash));
40  		if (existing != gap_blocks_by_hash.end () && !existing->bootstrap_started)
41  		{
42  			auto is_new (false);
43  			gap_blocks_by_hash.modify (existing, [&is_new, &vote_a] (nano::gap_information & info) {
44  				auto it = std::find (info.voters.begin (), info.voters.end (), vote_a->account);
45  				is_new = (it == info.voters.end ());
46  				if (is_new)
47  				{
48  					info.voters.push_back (vote_a->account);
49  				}
50  			});
51  			if (is_new)
52  			{
53  				if (bootstrap_check (existing->voters, hash))
54  				{
55  					gap_blocks_by_hash.modify (existing, [] (nano::gap_information & info) {
56  						info.bootstrap_started = true;
57  					});
58  				}
59  			}
60  		}
61  	}
62  }
63  bool nano::gap_cache::bootstrap_check (std::vector<nano::account> const & voters_a, nano::block_hash const & hash_a)
64  {
65  	nano::uint128_t tally;
66  	for (auto const & voter : voters_a)
67  	{
68  		tally += node.ledger.weight (voter);
69  	}
70  	bool start_bootstrap (false);
71  	if (!node.flags.disable_lazy_bootstrap)
72  	{
73  		if (tally >= node.online_reps.delta ())
74  		{
75  			start_bootstrap = true;
76  		}
77  	}
78  	else if (!node.flags.disable_legacy_bootstrap && tally > bootstrap_threshold ())
79  	{
80  		start_bootstrap = true;
81  	}
82  	if (start_bootstrap && !node.ledger.block_or_pruned_exists (hash_a))
83  	{
84  		bootstrap_start (hash_a);
85  	}
86  	return start_bootstrap;
87  }
88  void nano::gap_cache::bootstrap_start (nano::block_hash const & hash_a)
89  {
90  	auto node_l (node.shared ());
91  	node.workers.add_timed_task (std::chrono::steady_clock::now () + node.network_params.bootstrap.gap_cache_bootstrap_start_interval, [node_l, hash_a] () {
92  		if (!node_l->ledger.block_or_pruned_exists (hash_a))
93  		{
94  			if (!node_l->bootstrap_initiator.in_progress ())
95  			{
96  				node_l->logger.try_log (boost::str (boost::format ("Missing block %1% which has enough votes to warrant lazy bootstrapping it") % hash_a.to_string ()));
97  			}
98  			if (!node_l->flags.disable_lazy_bootstrap)
99  			{
100  				node_l->bootstrap_initiator.bootstrap_lazy (hash_a);
101  			}
102  			else if (!node_l->flags.disable_legacy_bootstrap)
103  			{
104  				node_l->bootstrap_initiator.bootstrap ();
105  			}
106  		}
107  	});
108  }
109  nano::uint128_t nano::gap_cache::bootstrap_threshold ()
110  {
111  	auto result ((node.online_reps.trended () / 256) * node.config.bootstrap_fraction_numerator);
112  	return result;
113  }
114  std::size_t nano::gap_cache::size ()
115  {
116  	nano::lock_guard<nano::mutex> lock{ mutex };
<span onclick='openModal()' class='match'>117  	return blocks.size ();
118  }
119  std::unique_ptr<nano::container_info_component> nano::collect_container_info (gap_cache & gap_cache, std::string const & name)
120  {
121  	auto count = gap_cache.size ();
122  	auto sizeof_element = sizeof (decltype (gap_cache.blocks)::value_type);
</span>123  	auto composite = std::make_unique<container_info_composite> (name);
124  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "blocks", count, sizeof_element }));
125  	return composite;
126  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mlsl.hpp</h3>
            <pre><code>1  #ifndef CAFFE_MLSL_HPP_
2  #define CAFFE_MLSL_HPP_
3  #ifdef USE_MLSL
4  #include <mlsl.hpp>
5  #include <mpi.h>
6  #include "caffe/common.hpp"
7  namespace caffe {
8    namespace mn {
9  #define MLSL_DEFAULT_COLOR -1
10      extern MLSL::Distribution *global_distrib;
11      void init(int* argc, char** argv[]);
12      inline void barrier() {
13        global_distrib->Barrier(MLSL::GT_DATA);
14      }
15      inline void free(void *addr) {
16        return MLSL::Environment::GetEnv().Free(addr);
17      }
18      inline void* alloc(size_t size, int alignment) {
19        return MLSL::Environment::GetEnv().Alloc(size, alignment);
20      }
21      inline int get_node_id() {
22        return MLSL::Environment::GetEnv().GetProcessIdx();
23      }
24      inline int get_nodes_count() {
25        return MLSL::Environment::GetEnv().GetProcessCount();
26      }
27      inline bool is_root() {
28        return mn::get_node_id() == 0;
29      }
30      template <typename Dtype>
31      MPI_Datatype DtypeToMPIDtype();
32      template <typename Dtype>
33      MLSL::DataType DtypeToMLSLDtype();
34      extern int nGroup;
35      extern int nServer;
36      inline bool use_param_server() {
37        return nServer > 0;
38      }
39      inline int get_world_size() {
40        return global_distrib->GetProcessCount(MLSL::GT_DATA);
41      }
42      inline int get_node_rank() {
43        return global_distrib->GetProcessIdx(MLSL::GT_DATA);
44      }
45      inline int get_ppn() {
46        int is_mpi_inited = 0;
47        MPI_Initialized(&is_mpi_inited);
48        assert(is_mpi_inited);
49        int ppn = 1;
50        int rank;
51        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
52        MPI_Comm node_comm;
53        MPI_Comm_split_type(MPI_COMM_WORLD, MPI_COMM_TYPE_SHARED, rank, MPI_INFO_NULL, &node_comm);
54        MPI_Comm_size(node_comm, &ppn);
55        MPI_Comm_free(&node_comm);
56        DLOG(INFO) << "ppn " << ppn;
57        return ppn;
58      }
59      inline bool is_multinode() {
60        static bool multinode{ get_world_size() > 1 };
61        return multinode;
62      }
63      inline int get_num_groups() {
64        return nGroup;
65      }
66      inline int get_group_size() {
<span onclick='openModal()' class='match'>67        return (get_world_size() - nServer) / nGroup;
68      }
69      inline int get_global_part_id(int data_parts, int model_parts) {
70        int node_id = get_node_id();
71        int num_nodes = get_group_size();
</span>72        return (node_id % (num_nodes / data_parts)) / model_parts;
73      }
74      inline int get_group_id() {
75        return get_node_rank() / get_group_size();
76      }
77      inline int world_rank_to_root_rank(int world_rank) {
78        int group_size = get_group_size();
79        return world_rank / group_size * group_size;
80      }
81      inline int get_group_root_rank(int group_id, int part_id = 0, int num_parts = 1) {
82        return group_id * get_group_size() + part_id;
83      }
84      inline int param_to_server_rank(int layer_id, int param_id) {
85        return (param_id % nServer) + nGroup * get_group_size();
86      }
87      inline bool is_param_server() {
88        return get_node_rank() >= nGroup * get_group_size();
89      }
90      namespace detail {
91        template <typename Dtype>
92        inline MLSL::DataType dtype();
93        template <>
94        inline MLSL::DataType dtype<long double>() {
95          return MLSL::DataType::DT_DOUBLE;
96        }
97        template <>
98        inline MLSL::DataType dtype<float>() {
99          return MLSL::DataType::DT_FLOAT;
100        }
101        template <>
102        inline MLSL::DataType dtype<double>() {
103          return MLSL::DataType::DT_DOUBLE;
104        }
105      }
106      class Distribution {
107      public:
108        Distribution() = delete;
109        Distribution & operator = (const Distribution &) = delete;
110        Distribution(const Distribution &) = delete;
111        Distribution(int dataParts, int modelParts, int dataColor = MLSL_DEFAULT_COLOR, int modelColor = MLSL_DEFAULT_COLOR,
112                     int dataColorMax = MLSL_DEFAULT_COLOR, int modelColorMax = MLSL_DEFAULT_COLOR) :
113          data_parts_(dataParts), model_parts_(modelParts),
114          data_color_(dataColor), model_color_(modelColor),
115          data_color_max_(dataColorMax), model_color_max_(modelColorMax) {
116          if (dataColor == MLSL_DEFAULT_COLOR || modelColor == MLSL_DEFAULT_COLOR) {
117            distrib_ = MLSL::Environment::GetEnv().CreateDistribution(dataParts, modelParts);
118          } else {
119            distrib_ = MLSL::Environment::GetEnv().CreateDistributionWithColors(dataColor, modelColor);
120          }
121        }
122        ~Distribution() {
123          MLSL::Environment::GetEnv().DeleteDistribution(distrib_);
124        }
125        operator MLSL::Distribution * () {
126          return distrib_;
127        }
128        template <typename Dtype, MLSL::ReductionType Rtype, MLSL::GroupType Gtype>
129        void reduce(Dtype *sendBuffer, Dtype *recvBuffer, size_t count, size_t rootIdx = 0) {
130          if (skip_comm(Gtype)) return;
131          MLSL::CommReq *rqts = distrib_->Reduce((void *)sendBuffer, (void*)recvBuffer, count, detail::dtype<Dtype>(), Rtype, rootIdx, Gtype);
132          MLSL::Environment::GetEnv().Wait(rqts);
133        }
134        template <typename Dtype, MLSL::ReductionType Rtype, MLSL::GroupType Gtype>
135        MLSL::CommReq* reduce_async(Dtype *sendBuffer, Dtype *recvBuffer, size_t count, size_t rootIdx = 0) {
136          if (skip_comm(Gtype)) return NULL;
137          return distrib_->Reduce((void *)sendBuffer, (void*)recvBuffer, count, detail::dtype<Dtype>(), Rtype, rootIdx, Gtype);
138        }
139        template <typename Dtype, MLSL::GroupType Gtype>
140        void bcast(Dtype *buffer, size_t count, int rootId = 0) {
141          if (skip_comm(Gtype)) return;
142          MLSL::CommReq *rqts = distrib_->Bcast((void *)buffer, count, detail::dtype<Dtype>(), rootId, Gtype);
143          MLSL::Environment::GetEnv().Wait(rqts);
144        }
145        template <typename Dtype, MLSL::GroupType Gtype>
146        MLSL::CommReq* bcast_async(Dtype *buffer, size_t count, int rootId = 0) {
147          if (skip_comm(Gtype)) return NULL;
148          return distrib_->Bcast((void *)buffer, count, detail::dtype<Dtype>(), rootId, Gtype);
149        }
150        template <typename Dtype, MLSL::ReductionType Rtype, MLSL::GroupType Gtype>
151        void allreduce(Dtype *sendBuffer, Dtype *recvBuffer, size_t count) {
152          if (skip_comm(Gtype)) return;
153          MLSL::CommReq *rqts = distrib_->AllReduce((void *)sendBuffer, (void *)recvBuffer, count, detail::dtype<Dtype>(), Rtype, Gtype);
154          MLSL::Environment::GetEnv().Wait(rqts);
155        }
156        template <typename Dtype, MLSL::ReductionType Rtype, MLSL::GroupType Gtype>
157        void allreduce(Dtype *buffer, size_t count) {
158          if (skip_comm(Gtype)) return;
159          MLSL::CommReq *rqts = distrib_->AllReduce((void *)buffer, (void *)buffer, count, detail::dtype<Dtype>(), Rtype, Gtype);
160          MLSL::Environment::GetEnv().Wait(rqts);
161        }
162        template <typename Dtype, MLSL::GroupType Gtype>
163        void gather(const Dtype *sendBuffer, size_t count, Dtype *recvBuffer, size_t rootIdx = 0) {
164          if (skip_comm(Gtype)) return;
165          MLSL::CommReq *rqts = distrib_->Gather((void *)sendBuffer, count, (void *)recvBuffer, detail::dtype<Dtype>(), rootIdx, Gtype);
166          MLSL::Environment::GetEnv().Wait(rqts);
167        }
168        template <typename Dtype, MLSL::GroupType Gtype>
169        void scatter(Dtype *sendBuffer, Dtype *recvBuffer, size_t count, size_t rootIdx = 0) {
170          if (skip_comm(Gtype)) return;
171          MLSL::CommReq *rqts = distrib_->Scatter((void *)sendBuffer, (void *)recvBuffer, count, detail::dtype<Dtype>(), rootIdx, Gtype);
172          MLSL::Environment::GetEnv().Wait(rqts);
173        }
174        template <typename Dtype, MLSL::ReductionType Rtype, MLSL::GroupType Gtype>
175        void reducescatter(Dtype *sendBuffer, Dtype *recvBuffer, size_t count) {
176          if (skip_comm(Gtype)) return;
177          MLSL::CommReq *rqts = distrib_->ReduceScatter(sendBuffer, recvBuffer, count, detail::dtype<Dtype>(), Rtype, Gtype);
178          MLSL::Environment::GetEnv().Wait(rqts);
179        }
180        template <typename Dtype, MLSL::GroupType Gtype>
181        void allgather(Dtype *sendBuffer, size_t count, Dtype *recvBuffer) {
182          if (skip_comm(Gtype)) return;
183          gather<Dtype,Gtype>(sendBuffer, count, recvBuffer);
184          size_t bcast_count = count;
185          switch (Gtype) {
186          case MLSL::GT_MODEL:
187            bcast_count *= model_parts_;
188            break;
189          case MLSL::GT_DATA:
190            bcast_count *= data_parts_;
191            break;
192          case MLSL::GT_GLOBAL:
193            bcast_count *= model_parts_ * data_parts_;
194            break;
195          default:
196            NOT_IMPLEMENTED;
197          }
198          bcast<Dtype,Gtype>(recvBuffer, bcast_count);
199        }
200        template <MLSL::GroupType Gtype>
201        void barrier() {
202          if (skip_comm(Gtype)) return;
203          distrib_->Barrier(Gtype);
204        }
205        inline int get_node_id(MLSL::GroupType Gtype = MLSL::GroupType::GT_GLOBAL) {
206          return distrib_->GetProcessIdx(Gtype);
207        }
208        inline int get_nodes_count(MLSL::GroupType Gtype = MLSL::GroupType::GT_GLOBAL) {
209          return distrib_->GetProcessCount(Gtype);
210        }
211        inline int is_root(MLSL::GroupType Gtype = MLSL::GroupType::GT_GLOBAL) {
212          return get_node_id(Gtype) == 0;
213        }
214        inline int get_data_parts() {
215          return data_parts_;
216        }
217        inline int get_model_parts() {
218          return model_parts_;
219        }
220        inline int get_global_part_id() {
221          return mn::get_global_part_id(data_parts_, model_parts_);
222        }
223      private:
224        inline bool skip_comm(MLSL::GroupType Gtype) {
225          if (Gtype == MLSL::GT_DATA && data_color_max_ != MLSL_DEFAULT_COLOR) {
226            return data_color_ > data_color_max_;
227          } else if (Gtype == MLSL::GT_MODEL && model_color_max_ != MLSL_DEFAULT_COLOR) {
228            return model_color_ > model_color_max_;
229          } else return get_global_part_id() > 0;
230        }
231        MLSL::Distribution *distrib_{ nullptr };
232        int data_parts_;
233        int model_parts_;
234        int data_color_;
235        int model_color_;
236        int data_color_max_;
237        int model_color_max_;
238      };
239      inline void GetCanonicalMnParam(int &num_nodes, int &model_parts) {
240        if (num_nodes == 0) num_nodes = mn::get_group_size();
241        if (model_parts == 0 || model_parts > num_nodes) model_parts = num_nodes;
242      }
243      shared_ptr<Distribution> create_distrib(
244        int dataParts, int modelParts, int dataColor, int modelColor,
245        int dataColorMax = MLSL_DEFAULT_COLOR,
246        int modelColorMax = MLSL_DEFAULT_COLOR);
247      boost::shared_ptr<Distribution> create_distrib(int dataParts, int modelParts);
248      boost::shared_ptr<Distribution> create_distrib();
249      Distribution * get_distrib(int dataParts, int modelParts);
250      Distribution * get_distrib();
251      template <typename Dtype, MLSL::ReductionType Rtype = MLSL::RT_SUM>
252      inline void allreduce(Dtype *sendBuffer, Dtype *recvBuffer, size_t count) {
253        get_distrib()->allreduce<Dtype, Rtype, MLSL::GT_GLOBAL>(sendBuffer, recvBuffer, count);
254      }
255      template <typename Dtype, MLSL::ReductionType Rtype = MLSL::RT_SUM>
256      inline void allreduce(Dtype *buffer, size_t count) {
257        get_distrib()->allreduce<Dtype, Rtype, MLSL::GT_GLOBAL>(buffer, count);
258      }
259      template <typename Dtype, MLSL::ReductionType Rtype = MLSL::RT_SUM>
260      inline void reduce(Dtype *buffer, size_t count, int rootId = 0) {
261        get_distrib()->reduce<Dtype, Rtype, MLSL::GT_GLOBAL>(buffer, count, rootId);
262      }
263      template <typename Dtype>
264      void bcast(Dtype *buffer, size_t count, int rootId = 0) {
265        get_distrib()->bcast<Dtype, MLSL::GT_GLOBAL>(buffer, count, rootId);
266      }
267      template <typename Dtype>
268      inline void gather(const Dtype *sendBuffer, size_t count, Dtype *recvBuffer, int rootId = 0) {
269        get_distrib()->gather<Dtype, MLSL::GT_GLOBAL>(sendBuffer, count, recvBuffer, rootId);
270      }
271      template <typename Dtype>
272      inline void scatter(Dtype *sendBuffer, Dtype *recvBuffer, size_t count, int rootId = 0) {
273        get_distrib()->scatter<Dtype, MLSL::GT_GLOBAL>(sendBuffer, recvBuffer, count, rootId);
274      }
275      class Session {
276      public:
277        Session(MLSL::PhaseType phaseType)
278          : session_{ MLSL::Environment::GetEnv().CreateSession(phaseType) } {
279        }
280        ~Session() {
281          session_->RemoveOperations();
282          MLSL::Environment::GetEnv().DeleteSession(session_);
283        }
284        operator MLSL::Session * () {
285          return session_;
286        }
287        void commit() {
288          session_->Commit();
289        }
290        void set_global_minibatch_size(int global_minibatch_size) {
291          session_->SetGlobalMinibatchSize(global_minibatch_size);
292        }
293        int get_global_minibatch_size() {
294          return session_->GetGlobalMinibatchSize();
295        }
296        MLSL::Operation * add_operation(MLSL::OperationRegInfo *opRegInfo, MLSL::Distribution *distrib = nullptr) {
297          return session_->GetOperation(session_->AddOperation(opRegInfo, distrib));
298        }
299        void delete_operation_reg_info(MLSL::OperationRegInfo *opRegInfo) {
300          session_->DeleteOperationRegInfo(opRegInfo);
301        }
302        MLSL::OperationRegInfo * create_operation_reg_info(MLSL::OpType opType) {
303          return session_->CreateOperationRegInfo(opType);
304        }
305        size_t get_operation_count() {
306            return session_->GetOperationCount();
307        }
308        const char* get_operation_name(size_t idx) {
309            return session_->GetOperation(idx)->GetName();
310        }
311        MLSL::Statistics * get_stats() {
312            return session_->GetStats();
313        }
314      private:
315        MLSL::Session *session_{ nullptr };
316      };
317      namespace train {
318        inline Session & get_session() {
319          static Session session{ MLSL::PT_TRAIN };
320          return session;
321        }
322        inline MLSL::Operation * add_operation(MLSL::OperationRegInfo* opRegInfo, MLSL::Distribution* distrib = *get_distrib()) {
323          return get_session().add_operation(opRegInfo, distrib);
324        }
325        inline int get_global_minibatch_size() {
326          return get_session().get_global_minibatch_size();
327        }
328        inline void set_global_minibatch_size(int global_minibatch_size) {
329          get_session().set_global_minibatch_size(global_minibatch_size);
330        }
331        inline void commit() {
332          get_session().commit();
333        }
334  #ifdef ENABLE_WEIGHT_GRAD_COMPRESSION
335        inline void set_quantization_param(MLSL::QuantParams *qparams) {
336          MLSL::Environment::GetEnv().SetQuantizationParams(qparams);
337        }
338  #endif
339        namespace stats {
340          inline void stop() {
341            get_session().get_stats()->Stop();
342          }
343          inline void print() {
344            get_session().get_stats()->Print();
345          }
346          inline void reset() {
347            get_session().get_stats()->Reset();
348          }
349          inline void start() {
350            get_session().get_stats()->Start();
351          }
352          inline bool is_started() {
353            return get_session().get_stats()->IsStarted();
354          }
355          inline unsigned long long get_isolation_comm_time(size_t idx) {
356            return get_session().get_stats()->GetIsolationCommCycles(idx);
357          }
358          inline size_t get_comm_size(size_t idx) {
359            return get_session().get_stats()->GetCommSize(idx);
360          }
361          inline unsigned long long get_comm_time(size_t idx) {
362            return get_session().get_stats()->GetCommCycles(idx);
363          }
364          inline unsigned long long get_compute_time(size_t idx) {
365            return get_session().get_stats()->GetComputeCycles(idx);
366          }
367          inline unsigned long long get_total_isolation_comm_time() {
368            return get_session().get_stats()->GetTotalIsolationCommCycles();
369          }
370          inline size_t get_total_comm_size() {
371            return get_session().get_stats()->GetTotalCommSize();
372          }
373          inline unsigned long long get_total_comm_time() {
374            return get_session().get_stats()->GetTotalCommCycles();
375          }
376          inline unsigned long long get_total_compute_time() {
377            return get_session().get_stats()->GetTotalComputeCycles();
378          }
379        }
380      }
381      class OpRegInfo {
382      public:
383        OpRegInfo() = delete;
384        OpRegInfo & operator = (const OpRegInfo &) = delete;
385        OpRegInfo(const OpRegInfo &) = delete;
386        OpRegInfo(OpRegInfo &&) = default;
387        OpRegInfo & operator = (OpRegInfo &&) = default;
388        explicit OpRegInfo(Session& session, MLSL::OpType opType)
389          : opRegInfo_{ session.create_operation_reg_info(opType) },
390            session_(session) {
391        }
392        ~OpRegInfo() {
393          session_.delete_operation_reg_info(opRegInfo_);
394        }
395        operator MLSL::OperationRegInfo * () {
396          return opRegInfo_;
397        }
398        void set_name(std::string name) {
399          opRegInfo_->SetName(name.c_str());
400        }
401        template <typename Dtype>
402        void add_input(int featureMapCount, int featureMapSize) {
403          opRegInfo_->AddInput(featureMapCount, featureMapSize, detail::dtype<Dtype>());
404        }
405        template <typename Dtype>
406        void add_output(int featureMapCount, int featureMapSize) {
407          opRegInfo_->AddOutput(featureMapCount, featureMapSize, detail::dtype<Dtype>());
408        }
409        template <typename Dtype>
410        void add_parameter_set(int kernelCount, int kernelSize,
411          bool distributedUpdate = false
412  #ifdef ENABLE_WEIGHT_GRAD_COMPRESSION
413          , MLSL::CompressionType compressType = MLSL::CompressionType::CT_NONE
414  #endif
415          )
416        {
417          opRegInfo_->AddParameterSet(kernelCount, kernelSize, detail::dtype<Dtype>(),
418             distributedUpdate
419  #ifdef ENABLE_WEIGHT_GRAD_COMPRESSION
420             , compressType
421  #endif
422             );
423        }
424      private:
425        MLSL::OperationRegInfo *opRegInfo_{ nullptr };
426        Session &session_;
427      };
428    }  
429  }  
430  #endif 
431  #endif   
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-gap_cache_47.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mlsl.hpp</div>
                </div>
                <div class="column column_space"><pre><code>117  	return blocks.size ();
118  }
119  std::unique_ptr<nano::container_info_component> nano::collect_container_info (gap_cache & gap_cache, std::string const & name)
120  {
121  	auto count = gap_cache.size ();
122  	auto sizeof_element = sizeof (decltype (gap_cache.blocks)::value_type);
</pre></code></div>
                <div class="column column_space"><pre><code>67        return (get_world_size() - nServer) / nGroup;
68      }
69      inline int get_global_part_id(int data_parts, int model_parts) {
70        int node_id = get_node_id();
71        int num_nodes = get_group_size();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    