
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.072289156626507%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type_mat3x3.hpp</h3>
            <pre><code>1  #ifndef glm_core_type_mat3x3
2  #define glm_core_type_mat3x3
3  #include "type_mat.hpp"
4  namespace glm{
5  namespace detail
6  {
7  	template <typename T> struct tvec1;
8  	template <typename T> struct tvec2;
9  	template <typename T> struct tvec3;
10  	template <typename T> struct tvec4;
11  	template <typename T> struct tmat2x2;
12  	template <typename T> struct tmat2x3;
13  	template <typename T> struct tmat2x4;
14  	template <typename T> struct tmat3x2;
15  	template <typename T> struct tmat3x3;
16  	template <typename T> struct tmat3x4;
17  	template <typename T> struct tmat4x2;
18  	template <typename T> struct tmat4x3;
19  	template <typename T> struct tmat4x4;
20  	template <typename T> 
21  	struct tmat3x3
22  	{
23  		enum ctor{null};
24  		typedef T value_type;
25  		typedef std::size_t size_type;
26  		typedef tvec3<T> col_type;
27  		typedef tvec3<T> row_type;
28          GLM_FUNC_DECL size_type length() const;
29  		static GLM_FUNC_DECL size_type col_size();
30  		static GLM_FUNC_DECL size_type row_size();
31  		typedef tmat3x3<T> type;
32  		typedef tmat3x3<T> transpose_type;
33  	public:
34  		GLM_FUNC_DECL tmat3x3<T> _inverse() const;
35  	private:
36  		col_type value[3];
37  	public:
38  		GLM_FUNC_DECL tmat3x3();
39  		GLM_FUNC_DECL tmat3x3(tmat3x3 const & m);
40  		GLM_FUNC_DECL explicit tmat3x3(
41  			ctor Null);
42  		GLM_FUNC_DECL explicit tmat3x3(
43  			value_type const & s);
44  		GLM_FUNC_DECL explicit tmat3x3(
45  			value_type const & x0, value_type const & y0, value_type const & z0,
46  			value_type const & x1, value_type const & y1, value_type const & z1,
47  			value_type const & x2, value_type const & y2, value_type const & z2);
48  		GLM_FUNC_DECL explicit tmat3x3(
49  			col_type const & v0, 
50  			col_type const & v1,
51  			col_type const & v2);
52  		template <typename U> 
53  		GLM_FUNC_DECL explicit tmat3x3(
54              U const & x);
55  		template 
56          <
57              typename X1, typename Y1, typename Z1, 
58              typename X2, typename Y2, typename Z2, 
59              typename X3, typename Y3, typename Z3
60          > 
61  		GLM_FUNC_DECL explicit tmat3x3(
62              X1 const & x1, Y1 const & y1, Z1 const & z1, 
63              X2 const & x2, Y2 const & y2, Z2 const & z2, 
64              X3 const & x3, Y3 const & y3, Z3 const & z3);
65  		template <typename V1, typename V2, typename V3> 
66  		GLM_FUNC_DECL explicit tmat3x3(
67              tvec3<V1> const & v1, 
68              tvec3<V2> const & v2,
69              tvec3<V3> const & v3);
70  		template <typename U> 
<span onclick='openModal()' class='match'>71  		GLM_FUNC_DECL explicit tmat3x3(tmat3x3<U> const & m);
72  		GLM_FUNC_DECL explicit tmat3x3(tmat2x2<T> const & x);
73  		GLM_FUNC_DECL explicit tmat3x3(tmat4x4<T> const & x);
74  		GLM_FUNC_DECL explicit tmat3x3(tmat2x3<T> const & x);
75  		GLM_FUNC_DECL explicit tmat3x3(tmat3x2<T> const & x);
76  		GLM_FUNC_DECL explicit tmat3x3(tmat2x4<T> const & x);
77  		GLM_FUNC_DECL explicit tmat3x3(tmat4x2<T> const & x);
78  		GLM_FUNC_DECL explicit tmat3x3(tmat3x4<T> const & x);
79  		GLM_FUNC_DECL explicit tmat3x3(tmat4x3<T> const & x);
80  		GLM_FUNC_DECL col_type & operator[](size_type i);
81  		GLM_FUNC_DECL col_type const & operator[](size_type i) const;
82  		GLM_FUNC_DECL tmat3x3<T>& operator=  (tmat3x3<T> const & m);
</span>83  		template <typename U> 
84  		GLM_FUNC_DECL tmat3x3<T>& operator=  (tmat3x3<U> const & m);
85  		template <typename U> 
86  		GLM_FUNC_DECL tmat3x3<T>& operator+= (U const & s);
87  		template <typename U> 
88  		GLM_FUNC_DECL tmat3x3<T>& operator+= (tmat3x3<U> const & m);
89  		template <typename U> 
90  		GLM_FUNC_DECL tmat3x3<T>& operator-= (U const & s);
91  		template <typename U> 
92  		GLM_FUNC_DECL tmat3x3<T>& operator-= (tmat3x3<U> const & m);
93  		template <typename U> 
94  		GLM_FUNC_DECL tmat3x3<T>& operator*= (U const & s);
95  		template <typename U> 
96  		GLM_FUNC_DECL tmat3x3<T>& operator*= (tmat3x3<U> const & m);
97  		template <typename U> 
98  		GLM_FUNC_DECL tmat3x3<T>& operator/= (U const & s);
99  		template <typename U> 
100  		GLM_FUNC_DECL tmat3x3<T>& operator/= (tmat3x3<U> const & m);
101  		GLM_FUNC_DECL tmat3x3<T>& operator++ ();
102  		GLM_FUNC_DECL tmat3x3<T>& operator-- ();
103  	};
104  	template <typename T> 
105  	tmat3x3<T> operator+ (
106  		tmat3x3<T> const & m, 
107  		typename tmat3x3<T>::value_type const & s);
108  	template <typename T> 
109  	tmat3x3<T> operator+ (
110  		typename tmat3x3<T>::value_type const & s, 
111  		tmat3x3<T> const & m);
112  	template <typename T> 
113  	tmat3x3<T> operator+ (
114  		tmat3x3<T> const & m1, 
115  		tmat3x3<T> const & m2);
116  	template <typename T> 
117  	tmat3x3<T> operator- (
118  		tmat3x3<T> const & m, 
119  		typename tmat3x3<T>::value_type const & s);
120  	template <typename T> 
121  	tmat3x3<T> operator- (
122  		typename tmat3x3<T>::value_type const & s, 
123  		tmat3x3<T> const & m);
124  	template <typename T> 
125  	tmat3x3<T> operator- (
126  		tmat3x3<T> const & m1, 
127  		tmat3x3<T> const & m2);
128  	template <typename T> 
129  	tmat3x3<T> operator* (
130  		tmat3x3<T> const & m, 
131  		typename tmat3x3<T>::value_type const & s);
132  	template <typename T> 
133  	tmat3x3<T> operator* (
134  		typename tmat3x3<T>::value_type const & s, 
135  		tmat3x3<T> const & m);
136  	template <typename T> 
137  	typename tmat3x3<T>::col_type operator* (
138  		tmat3x3<T> const & m, 
139  		typename tmat3x3<T>::row_type const & v);
140  	template <typename T> 
141  	typename tmat3x3<T>::row_type operator* (
142  		typename tmat3x3<T>::col_type const & v, 
143  		tmat3x3<T> const & m);
144  	template <typename T> 
145  	tmat3x3<T> operator* (
146  		tmat3x3<T> const & m1, 
147  		tmat3x3<T> const & m2);
148  	template <typename T>
149  	tmat2x3<T> operator* (
150  		tmat3x3<T> const & m1, 
151  		tmat2x3<T> const & m2);
152  	template <typename T>
153  	tmat4x3<T> operator* (
154  		tmat3x3<T> const & m1, 
155  		tmat4x3<T> const & m2);
156  	template <typename T> 
157  	tmat3x3<T> operator/ (
158  		tmat3x3<T> const & m, 
159  		typename tmat3x3<T>::value_type const & s);
160  	template <typename T> 
161  	tmat3x3<T> operator/ (
162  		typename tmat3x3<T>::value_type const & s, 
163  		tmat3x3<T> const & m);
164  	template <typename T> 
165  	typename tmat3x3<T>::col_type operator/ (
166  		tmat3x3<T> const & m, 
167  		typename tmat3x3<T>::row_type const & v);
168  	template <typename T> 
169  	typename tmat3x3<T>::row_type operator/ (
170  		typename tmat3x3<T>::col_type const & v, 
171  		tmat3x3<T> const & m);
172  	template <typename T> 
173  	tmat3x3<T> operator/ (
174  		tmat3x3<T> const & m1, 
175  		tmat3x3<T> const & m2);
176  	template <typename T> 
177  	tmat3x3<T> const operator-  (
178  		tmat3x3<T> const & m);
179  	template <typename T> 
180  	tmat3x3<T> const operator-- (
181  		tmat3x3<T> const & m, 
182  		int);
183  	template <typename T> 
184  	tmat3x3<T> const operator++ (
185  		tmat3x3<T> const & m, 
186  		int);
187  } 
188  	typedef detail::tmat3x3<lowp_float>		lowp_mat3;
189  	typedef detail::tmat3x3<mediump_float>	mediump_mat3;
190  	typedef detail::tmat3x3<highp_float>	highp_mat3;
191  	typedef detail::tmat3x3<lowp_float>		lowp_mat3x3;
192  	typedef detail::tmat3x3<mediump_float>	mediump_mat3x3;
193  	typedef detail::tmat3x3<highp_float>	highp_mat3x3;
194  }
195  #ifndef GLM_EXTERNAL_TEMPLATE
196  #include "type_mat3x3.inl"
197  #endif
198  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_navigator.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_NAVIGATOR_H_
2  #define ABSL_STRINGS_INTERNAL_CORD_REP_BTREE_NAVIGATOR_H_
3  #include <cassert>
4  #include <iostream>
5  #include "absl/strings/internal/cord_internal.h"
6  #include "absl/strings/internal/cord_rep_btree.h"
7  namespace absl {
8  ABSL_NAMESPACE_BEGIN
9  namespace cord_internal {
10  class CordRepBtreeNavigator {
11   public:
12    struct Position {
13      CordRep* edge;
14      size_t offset;
15    };
16    struct ReadResult {
17      CordRep* tree;
18      size_t n;
19    };
<span onclick='openModal()' class='match'>20    explicit operator bool() const;
21    CordRepBtree* btree() const;
22    CordRep* Current() const;
23    CordRep* InitFirst(CordRepBtree* tree);
24    CordRep* InitLast(CordRepBtree* tree);
25    Position InitOffset(CordRepBtree* tree, size_t offset);
</span>26    CordRep* Next();
27    CordRep* Previous();
28    Position Seek(size_t offset);
29    ReadResult Read(size_t edge_offset, size_t n);
30    Position Skip(size_t n);
31    void Reset();
32   private:
33    CordRep* NextUp();
34    CordRep* PreviousUp();
35    template <CordRepBtree::EdgeType edge_type>
36    CordRep* Init(CordRepBtree* tree);
37    int height_ = -1;
38    uint8_t index_[CordRepBtree::kMaxDepth];
39    CordRepBtree* node_[CordRepBtree::kMaxDepth];
40  };
41  inline CordRepBtreeNavigator::operator bool() const { return height_ >= 0; }
42  inline CordRepBtree* CordRepBtreeNavigator::btree() const {
43    return height_ >= 0 ? node_[height_] : nullptr;
44  }
45  inline CordRep* CordRepBtreeNavigator::Current() const {
46    assert(height_ >= 0);
47    return node_[0]->Edge(index_[0]);
48  }
49  inline void CordRepBtreeNavigator::Reset() { height_ = -1; }
50  inline CordRep* CordRepBtreeNavigator::InitFirst(CordRepBtree* tree) {
51    return Init<CordRepBtree::kFront>(tree);
52  }
53  inline CordRep* CordRepBtreeNavigator::InitLast(CordRepBtree* tree) {
54    return Init<CordRepBtree::kBack>(tree);
55  }
56  template <CordRepBtree::EdgeType edge_type>
57  inline CordRep* CordRepBtreeNavigator::Init(CordRepBtree* tree) {
58    assert(tree != nullptr);
59    assert(tree->size() > 0);
60    assert(tree->height() <= CordRepBtree::kMaxHeight);
61    int height = height_ = tree->height();
62    size_t index = tree->index(edge_type);
63    node_[height] = tree;
64    index_[height] = static_cast<uint8_t>(index);
65    while (--height >= 0) {
66      tree = tree->Edge(index)->btree();
67      node_[height] = tree;
68      index = tree->index(edge_type);
69      index_[height] = static_cast<uint8_t>(index);
70    }
71    return node_[0]->Edge(index);
72  }
73  inline CordRepBtreeNavigator::Position CordRepBtreeNavigator::Seek(
74      size_t offset) {
75    assert(btree() != nullptr);
76    int height = height_;
77    CordRepBtree* edge = node_[height];
78    if (ABSL_PREDICT_FALSE(offset >= edge->length)) return {nullptr, 0};
79    CordRepBtree::Position index = edge->IndexOf(offset);
80    index_[height] = static_cast<uint8_t>(index.index);
81    while (--height >= 0) {
82      edge = edge->Edge(index.index)->btree();
83      node_[height] = edge;
84      index = edge->IndexOf(index.n);
85      index_[height] = static_cast<uint8_t>(index.index);
86    }
87    return {edge->Edge(index.index), index.n};
88  }
89  inline CordRepBtreeNavigator::Position CordRepBtreeNavigator::InitOffset(
90      CordRepBtree* tree, size_t offset) {
91    assert(tree != nullptr);
92    assert(tree->height() <= CordRepBtree::kMaxHeight);
93    if (ABSL_PREDICT_FALSE(offset >= tree->length)) return {nullptr, 0};
94    height_ = tree->height();
95    node_[height_] = tree;
96    return Seek(offset);
97  }
98  inline CordRep* CordRepBtreeNavigator::Next() {
99    CordRepBtree* edge = node_[0];
100    return index_[0] == edge->back() ? NextUp() : edge->Edge(++index_[0]);
101  }
102  inline CordRep* CordRepBtreeNavigator::Previous() {
103    CordRepBtree* edge = node_[0];
104    return index_[0] == edge->begin() ? PreviousUp() : edge->Edge(--index_[0]);
105  }
106  inline CordRep* CordRepBtreeNavigator::NextUp() {
107    assert(index_[0] == node_[0]->back());
108    CordRepBtree* edge;
109    size_t index;
110    int height = 0;
111    do {
112      if (++height > height_) return nullptr;
113      edge = node_[height];
114      index = index_[height] + 1;
115    } while (index == edge->end());
116    index_[height] = static_cast<uint8_t>(index);
117    do {
118      node_[--height] = edge = edge->Edge(index)->btree();
119      index_[height] = static_cast<uint8_t>(index = edge->begin());
120    } while (height > 0);
121    return edge->Edge(index);
122  }
123  inline CordRep* CordRepBtreeNavigator::PreviousUp() {
124    assert(index_[0] == node_[0]->begin());
125    CordRepBtree* edge;
126    size_t index;
127    int height = 0;
128    do {
129      if (++height > height_) return nullptr;
130      edge = node_[height];
131      index = index_[height];
132    } while (index == edge->begin());
133    index_[height] = static_cast<uint8_t>(--index);
134    do {
135      node_[--height] = edge = edge->Edge(index)->btree();
136      index_[height] = static_cast<uint8_t>(index = edge->back());
137    } while (height > 0);
138    return edge->Edge(index);
139  }
140  }  
141  ABSL_NAMESPACE_END
142  }  
143  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type_mat3x3.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_navigator.h</div>
                </div>
                <div class="column column_space"><pre><code>71  		GLM_FUNC_DECL explicit tmat3x3(tmat3x3<U> const & m);
72  		GLM_FUNC_DECL explicit tmat3x3(tmat2x2<T> const & x);
73  		GLM_FUNC_DECL explicit tmat3x3(tmat4x4<T> const & x);
74  		GLM_FUNC_DECL explicit tmat3x3(tmat2x3<T> const & x);
75  		GLM_FUNC_DECL explicit tmat3x3(tmat3x2<T> const & x);
76  		GLM_FUNC_DECL explicit tmat3x3(tmat2x4<T> const & x);
77  		GLM_FUNC_DECL explicit tmat3x3(tmat4x2<T> const & x);
78  		GLM_FUNC_DECL explicit tmat3x3(tmat3x4<T> const & x);
79  		GLM_FUNC_DECL explicit tmat3x3(tmat4x3<T> const & x);
80  		GLM_FUNC_DECL col_type & operator[](size_type i);
81  		GLM_FUNC_DECL col_type const & operator[](size_type i) const;
82  		GLM_FUNC_DECL tmat3x3<T>& operator=  (tmat3x3<T> const & m);
</pre></code></div>
                <div class="column column_space"><pre><code>20    explicit operator bool() const;
21    CordRepBtree* btree() const;
22    CordRep* Current() const;
23    CordRep* InitFirst(CordRepBtree* tree);
24    CordRep* InitLast(CordRepBtree* tree);
25    Position InitOffset(CordRepBtree* tree, size_t offset);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    