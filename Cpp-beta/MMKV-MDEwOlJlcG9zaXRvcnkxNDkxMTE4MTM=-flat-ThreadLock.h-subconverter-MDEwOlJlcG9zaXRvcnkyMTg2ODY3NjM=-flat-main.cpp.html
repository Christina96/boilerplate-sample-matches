
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.940298507462686%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-ThreadLock.h</h3>
            <pre><code>1  #ifndef MMKV_THREADLOCK_H
2  #define MMKV_THREADLOCK_H
3  #ifdef  __cplusplus
4  #include "MMKVPredef.h"
5  #ifndef MMKV_WIN32
6  #    include <pthread.h>
7  #    define MMKV_USING_PTHREAD 1
8  #endif
9  #if MMKV_USING_PTHREAD
10  #else
11  #    include <atomic>
12  #endif
13  namespace mmkv {
14  #if MMKV_USING_PTHREAD
15  #    define ThreadOnceToken_t pthread_once_t
16  #    define ThreadOnceUninitialized PTHREAD_ONCE_INIT
17  #else
18  enum ThreadOnceTokenEnum : int32_t { ThreadOnceUninitialized = 0, ThreadOnceInitializing, ThreadOnceInitialized };
19  using ThreadOnceToken_t = std::atomic<ThreadOnceTokenEnum>;
20  #endif
21  class ThreadLock {
22  private:
23  #if MMKV_USING_PTHREAD
<span onclick='openModal()' class='match'>24      pthread_mutex_t m_lock;
25  #else
26      CRITICAL_SECTION m_lock;
27  #endif
28  public:
29      ThreadLock();
30      ~ThreadLock();
31      void initialize();
32      void lock();
33      void unlock();
34      static void ThreadOnce(ThreadOnceToken_t *onceToken, void (*callback)(void));
</span>35  #ifdef MMKV_WIN32
36      static void Sleep(int ms);
37  #endif
38      explicit ThreadLock(const ThreadLock &other) = delete;
39      ThreadLock &operator=(const ThreadLock &other) = delete;
40  };
41  } 
42  #endif
43  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-main.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <string>
3  #include <unistd.h>
4  #include <signal.h>
5  #include <sys/types.h>
6  #include <dirent.h>
7  #include "config/ruleset.h"
8  #include "handler/interfaces.h"
9  #include "handler/webget.h"
10  #include "handler/settings.h"
11  #include "script/cron.h"
12  #include "server/socket.h"
13  #include "server/webserver.h"
14  #include "utils/defer.h"
15  #include "utils/file_extra.h"
16  #include "utils/logger.h"
17  #include "utils/network.h"
18  #include "utils/rapidjson_extra.h"
19  #include "utils/system.h"
20  #include "utils/urlencode.h"
21  #include "version.h"
22  WebServer webServer;
23  #ifndef _WIN32
24  void SetConsoleTitle(const std::string &title)
25  {
26      system(std::string("echo \"\\033]0;" + title + "\\007\\c\"").data());
27  }
28  #endif 
29  void setcd(std::string &file)
30  {
31      char szTemp[1024] = {}, filename[256] = {};
32      std::string path;
33  #ifdef _WIN32
34      char *pname = NULL;
35      DWORD retVal = GetFullPathName(file.data(), 1023, szTemp, &pname);
36      if(!retVal)
37          return;
38      strcpy(filename, pname);
39      strrchr(szTemp, '\\')[1] = '\0';
40  #else
41      char *ret = realpath(file.data(), szTemp);
42      if(ret == NULL)
43          return;
44      ret = strcpy(filename, strrchr(szTemp, '/') + 1);
45      if(ret == NULL)
46          return;
47      strrchr(szTemp, '/')[1] = '\0';
48  #endif 
49      file.assign(filename);
50      path.assign(szTemp);
51      chdir(path.data());
52  }
53  void chkArg(int argc, char *argv[])
54  {
55      for(int i = 1; i < argc; i++)
56      {
57          if(strcmp(argv[i], "-cfw") == 0)
58          {
59              global.CFWChildProcess = true;
60              global.updateRulesetOnRequest = true;
61          }
62          else if(strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--file") == 0)
63          {
64              if(i < argc - 1)
65                  global.prefPath.assign(argv[++i]);
66          }
67          else if(strcmp(argv[i], "-g") == 0 || strcmp(argv[i], "--gen") == 0)
68          {
69              global.generatorMode = true;
70          }
71          else if(strcmp(argv[i], "--artifact") == 0)
72          {
73              if(i < argc - 1)
74                  global.generateProfiles.assign(argv[++i]);
75          }
76          else if(strcmp(argv[i], "-l") == 0 || strcmp(argv[i], "--log") == 0)
77          {
78              if(i < argc - 1)
79                  if(freopen(argv[++i], "a", stderr) == NULL)
80                      std::cerr<<"Error redirecting output to file.\n";
81          }
82      }
83  }
84  void signal_handler(int sig)
85  {
86      writeLog(0, "Interrupt signal " + std::to_string(sig) + " received. Exiting gracefully...", LOG_LEVEL_FATAL);
87      switch(sig)
88      {
89  #ifndef _WIN32
90      case SIGHUP:
91      case SIGQUIT:
92  #endif 
93      case SIGTERM:
94      case SIGINT:
95          webServer.stop_web_server();
96          break;
97      }
98  }
99  void cron_tick_caller()
100  {
101      if(global.enableCron)
102          cron_tick();
103  }
104  int main(int argc, char *argv[])
105  {
106  #ifndef _DEBUG
107      std::string prgpath = argv[0];
108      setcd(prgpath); 
109  #endif 
110      if(fileExist("pref.toml"))
111          global.prefPath = "pref.toml";
112      else if(fileExist("pref.yml"))
113          global.prefPath = "pref.yml";
114      else if(!fileExist("pref.ini"))
115      {
116          if(fileExist("pref.example.toml"))
117          {
118              fileCopy("pref.example.toml", "pref.toml");
119              global.prefPath = "pref.toml";
120          }
121          else if(fileExist("pref.example.yml"))
122          {
123              fileCopy("pref.example.yml", "pref.yml");
124              global.prefPath = "pref.yml";
125          }
126          else if(fileExist("pref.example.ini"))
127              fileCopy("pref.example.ini", "pref.ini");
128      }
129      chkArg(argc, argv);
130      setcd(global.prefPath); 
131      writeLog(0, "SubConverter " VERSION " starting up..", LOG_LEVEL_INFO);
132  #ifdef _WIN32
133      WSADATA wsaData;
134      if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
135      {
136          writeLog(0, "WSAStartup failed.", LOG_LEVEL_FATAL);
137          return 1;
138      }
139      UINT origcp = GetConsoleOutputCP();
140      defer(SetConsoleOutputCP(origcp);)
141      SetConsoleOutputCP(65001);
142  #else
<span onclick='openModal()' class='match'>143      signal(SIGPIPE, SIG_IGN);
144      signal(SIGABRT, SIG_IGN);
145      signal(SIGHUP, signal_handler);
146      signal(SIGQUIT, signal_handler);
147  #endif 
148      signal(SIGTERM, signal_handler);
149      signal(SIGINT, signal_handler);
</span>150      SetConsoleTitle("SubConverter " VERSION);
151      readConf();
152      if(!global.updateRulesetOnRequest)
153          refreshRulesets(global.customRulesets, global.rulesetsContent);
154      std::string env_api_mode = getEnv("API_MODE"), env_managed_prefix = getEnv("MANAGED_PREFIX"), env_token = getEnv("API_TOKEN");
155      global.APIMode = tribool().parse(toLower(env_api_mode)).get(global.APIMode);
156      if(env_managed_prefix.size())
157          global.managedConfigPrefix = env_managed_prefix;
158      if(env_token.size())
159          global.accessToken = env_token;
160      if(global.generatorMode)
161          return simpleGenerator();
162      webServer.append_response("GET", "/version", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
163      {
164          return "subconverter " VERSION " backend\n";
165      });
166      webServer.append_response("GET", "/refreshrules", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
167      {
168          if(global.accessToken.size())
169          {
170              std::string token = getUrlArg(request.argument, "token");
171              if(token != global.accessToken)
172              {
173                  response.status_code = 403;
174                  return "Forbidden\n";
175              }
176          }
177          refreshRulesets(global.customRulesets, global.rulesetsContent);
178          return "done\n";
179      });
180      webServer.append_response("GET", "/readconf", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
181      {
182          if(global.accessToken.size())
183          {
184              std::string token = getUrlArg(request.argument, "token");
185              if(token != global.accessToken)
186              {
187                  response.status_code = 403;
188                  return "Forbidden\n";
189              }
190          }
191          readConf();
192          if(!global.updateRulesetOnRequest)
193              refreshRulesets(global.customRulesets, global.rulesetsContent);
194          return "done\n";
195      });
196      webServer.append_response("POST", "/updateconf", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
197      {
198          if(global.accessToken.size())
199          {
200              std::string token = getUrlArg(request.argument, "token");
201              if(token != global.accessToken)
202              {
203                  response.status_code = 403;
204                  return "Forbidden\n";
205              }
206          }
207          std::string type = getUrlArg(request.argument, "type");
208          if(type == "form")
209              fileWrite(global.prefPath, getFormData(request.postdata), true);
210          else if(type == "direct")
211              fileWrite(global.prefPath, request.postdata, true);
212          else
213          {
214              response.status_code = 501;
215              return "Not Implemented\n";
216          }
217          readConf();
218          if(!global.updateRulesetOnRequest)
219              refreshRulesets(global.customRulesets, global.rulesetsContent);
220          return "done\n";
221      });
222      webServer.append_response("GET", "/flushcache", "text/plain", [](RESPONSE_CALLBACK_ARGS) -> std::string
223      {
224          if(getUrlArg(request.argument, "token") != global.accessToken)
225          {
226              response.status_code = 403;
227              return "Forbidden";
228          }
229          flushCache();
230          return "done";
231      });
232      webServer.append_response("GET", "/sub", "text/plain;charset=utf-8", subconverter);
233      webServer.append_response("HEAD", "/sub", "text/plain", subconverter);
234      webServer.append_response("GET", "/sub2clashr", "text/plain;charset=utf-8", simpleToClashR);
235      webServer.append_response("GET", "/surge2clash", "text/plain;charset=utf-8", surgeConfToClash);
236      webServer.append_response("GET", "/getruleset", "text/plain;charset=utf-8", getRuleset);
237      webServer.append_response("GET", "/getprofile", "text/plain;charset=utf-8", getProfile);
238      webServer.append_response("GET", "/render", "text/plain;charset=utf-8", renderTemplate);
239      webServer.append_response("GET", "/convert", "text/plain;charset=utf-8", getConvertedRuleset);
240      if(!global.APIMode)
241      {
242          webServer.append_response("GET", "/get", "text/plain;charset=utf-8", [](RESPONSE_CALLBACK_ARGS) -> std::string
243          {
244              std::string url = urlDecode(getUrlArg(request.argument, "url"));
245              return webGet(url, "");
246          });
247          webServer.append_response("GET", "/getlocal", "text/plain;charset=utf-8", [](RESPONSE_CALLBACK_ARGS) -> std::string
248          {
249              return fileGet(urlDecode(getUrlArg(request.argument, "path")));
250          });
251      }
252      std::string env_port = getEnv("PORT");
253      if(env_port.size())
254          global.listenPort = to_int(env_port, global.listenPort);
255      listener_args args = {global.listenAddress, global.listenPort, global.maxPendingConns, global.maxConcurThreads, cron_tick_caller, 200};
256      writeLog(0, "Startup completed. Serving HTTP @ http:&bsol;&bsol;" + global.listenAddress + ":" + std::to_string(global.listenPort), LOG_LEVEL_INFO);
257      webServer.start_web_server_multi(&args);
258  #ifdef _WIN32
259      WSACleanup();
260  #endif 
261      return 0;
262  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-ThreadLock.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-main.cpp</div>
                </div>
                <div class="column column_space"><pre><code>24      pthread_mutex_t m_lock;
25  #else
26      CRITICAL_SECTION m_lock;
27  #endif
28  public:
29      ThreadLock();
30      ~ThreadLock();
31      void initialize();
32      void lock();
33      void unlock();
34      static void ThreadOnce(ThreadOnceToken_t *onceToken, void (*callback)(void));
</pre></code></div>
                <div class="column column_space"><pre><code>143      signal(SIGPIPE, SIG_IGN);
144      signal(SIGABRT, SIG_IGN);
145      signal(SIGHUP, signal_handler);
146      signal(SIGQUIT, signal_handler);
147  #endif 
148      signal(SIGTERM, signal_handler);
149      signal(SIGINT, signal_handler);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    