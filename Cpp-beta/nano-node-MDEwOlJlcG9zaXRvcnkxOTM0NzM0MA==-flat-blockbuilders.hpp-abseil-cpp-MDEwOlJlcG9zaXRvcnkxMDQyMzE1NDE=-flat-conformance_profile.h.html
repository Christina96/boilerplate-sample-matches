
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.422535211267608%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockbuilders.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/blocks.hpp>
3  #include <memory>
4  namespace nano
5  {
6  enum class build_flags : uint8_t
7  {
8  	signature_present = 1,
9  	work_present = 2,
10  	account_present = 4,
11  	balance_present = 8,
12  	link_present = 16,
13  	previous_present = 32,
14  	representative_present = 64
15  };
16  inline nano::build_flags operator| (nano::build_flags a, nano::build_flags b)
17  {
18  	return static_cast<nano::build_flags> (static_cast<uint8_t> (a) | static_cast<uint8_t> (b));
19  }
20  inline uint8_t operator| (uint8_t a, nano::build_flags b)
21  {
22  	return static_cast<uint8_t> (a | static_cast<uint8_t> (b));
23  }
24  inline uint8_t operator& (uint8_t a, nano::build_flags b)
25  {
26  	return static_cast<uint8_t> (a & static_cast<uint8_t> (b));
27  }
28  inline uint8_t operator|= (uint8_t & a, nano::build_flags b)
29  {
30  	return a = static_cast<uint8_t> (a | static_cast<uint8_t> (b));
31  }
32  template <typename BLOCKTYPE, typename BUILDER>
33  class abstract_builder
34  {
35  public:
<span onclick='openModal()' class='match'>36  	std::unique_ptr<BLOCKTYPE> build ();
37  	std::unique_ptr<BLOCKTYPE> build (std::error_code & ec);
38  	std::shared_ptr<BLOCKTYPE> build_shared ();
39  	std::shared_ptr<BLOCKTYPE> build_shared (std::error_code & ec);
40  	abstract_builder & work (uint64_t work);
</span>41  	abstract_builder & sign (nano::raw_key const & private_key, nano::public_key const & public_key);
42  	abstract_builder & sign_zero ();
43  protected:
44  	abstract_builder () = default;
45  	void construct_block ();
46  	std::unique_ptr<BLOCKTYPE> block;
47  	std::error_code ec;
48  	uint8_t build_state{ 0 };
49  	uint8_t base_fields = static_cast<uint8_t> (nano::build_flags::work_present | nano::build_flags::signature_present);
50  };
51  class state_block_builder : public abstract_builder<nano::state_block, state_block_builder>
52  {
53  public:
54  	state_block_builder ();
55  	state_block_builder & from (nano::state_block const & block);
56  	state_block_builder & make_block ();
57  	state_block_builder & zero ();
58  	state_block_builder & account (nano::account const & account);
59  	state_block_builder & account_hex (std::string const & account_hex);
60  	state_block_builder & account_address (std::string const & account_address);
61  	state_block_builder & representative (nano::account const & account);
62  	state_block_builder & representative_hex (std::string const & account_hex);
63  	state_block_builder & representative_address (std::string const & account_address);
64  	state_block_builder & previous (nano::block_hash const & previous);
65  	state_block_builder & previous_hex (std::string const & previous_hex);
66  	state_block_builder & balance (nano::amount const & balance);
67  	state_block_builder & balance_dec (std::string const & balance_decimal);
68  	state_block_builder & balance_hex (std::string const & balance_hex);
69  	state_block_builder & link (nano::link const & link);
70  	state_block_builder & link_hex (std::string const & link_hex);
71  	state_block_builder & link_address (std::string const & link_address);
72  	void validate ();
73  private:
74  	uint8_t required_fields = base_fields | static_cast<uint8_t> (nano::build_flags::account_present | nano::build_flags::balance_present | nano::build_flags::link_present | nano::build_flags::previous_present | nano::build_flags::representative_present);
75  };
76  class open_block_builder : public abstract_builder<nano::open_block, open_block_builder>
77  {
78  public:
79  	open_block_builder ();
80  	open_block_builder & make_block ();
81  	open_block_builder & zero ();
82  	open_block_builder & account (nano::account account);
83  	open_block_builder & account_hex (std::string account_hex);
84  	open_block_builder & account_address (std::string account_address);
85  	open_block_builder & representative (nano::account account);
86  	open_block_builder & representative_hex (std::string account_hex);
87  	open_block_builder & representative_address (std::string account_address);
88  	open_block_builder & source (nano::block_hash source);
89  	open_block_builder & source_hex (std::string source_hex);
90  	void validate ();
91  private:
92  	uint8_t required_fields = base_fields | static_cast<uint8_t> (nano::build_flags::account_present | nano::build_flags::representative_present | nano::build_flags::link_present);
93  };
94  class change_block_builder : public abstract_builder<nano::change_block, change_block_builder>
95  {
96  public:
97  	change_block_builder ();
98  	change_block_builder & make_block ();
99  	change_block_builder & zero ();
100  	change_block_builder & representative (nano::account account);
101  	change_block_builder & representative_hex (std::string account_hex);
102  	change_block_builder & representative_address (std::string account_address);
103  	change_block_builder & previous (nano::block_hash previous);
104  	change_block_builder & previous_hex (std::string previous_hex);
105  	void validate ();
106  private:
107  	uint8_t required_fields = base_fields | static_cast<uint8_t> (nano::build_flags::previous_present | nano::build_flags::representative_present);
108  };
109  class send_block_builder : public abstract_builder<nano::send_block, send_block_builder>
110  {
111  public:
112  	send_block_builder ();
113  	send_block_builder & make_block ();
114  	send_block_builder & zero ();
115  	send_block_builder & destination (nano::account account);
116  	send_block_builder & destination_hex (std::string account_hex);
117  	send_block_builder & destination_address (std::string account_address);
118  	send_block_builder & previous (nano::block_hash previous);
119  	send_block_builder & previous_hex (std::string previous_hex);
120  	send_block_builder & balance (nano::amount balance);
121  	send_block_builder & balance_dec (std::string balance_decimal);
122  	send_block_builder & balance_hex (std::string balance_hex);
123  	void validate ();
124  private:
125  	uint8_t required_fields = base_fields | static_cast<uint8_t> (build_flags::previous_present | build_flags::link_present | build_flags::balance_present);
126  };
127  class receive_block_builder : public abstract_builder<nano::receive_block, receive_block_builder>
128  {
129  public:
130  	receive_block_builder ();
131  	receive_block_builder & make_block ();
132  	receive_block_builder & zero ();
133  	receive_block_builder & previous (nano::block_hash previous);
134  	receive_block_builder & previous_hex (std::string previous_hex);
135  	receive_block_builder & source (nano::block_hash source);
136  	receive_block_builder & source_hex (std::string source_hex);
137  	void validate ();
138  private:
139  	uint8_t required_fields = base_fields | static_cast<uint8_t> (build_flags::previous_present | build_flags::link_present);
140  };
141  class block_builder
142  {
143  public:
144  	nano::state_block_builder & state ()
145  	{
146  		state_builder.make_block ();
147  		return state_builder;
148  	}
149  	nano::open_block_builder & open ()
150  	{
151  		open_builder.make_block ();
152  		return open_builder;
153  	}
154  	nano::change_block_builder & change ()
155  	{
156  		change_builder.make_block ();
157  		return change_builder;
158  	}
159  	nano::send_block_builder & send ()
160  	{
161  		send_builder.make_block ();
162  		return send_builder;
163  	}
164  	nano::receive_block_builder & receive ()
165  	{
166  		receive_builder.make_block ();
167  		return receive_builder;
168  	}
169  private:
170  	nano::state_block_builder state_builder;
171  	nano::open_block_builder open_builder;
172  	nano::change_block_builder change_builder;
173  	nano::send_block_builder send_builder;
174  	nano::receive_block_builder receive_builder;
175  };
176  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_profile.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_PROFILE_H_
2  #define ABSL_TYPES_INTERNAL_CONFORMANCE_PROFILE_H_
3  #include <set>
4  #include <type_traits>
5  #include <utility>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/algorithm/container.h"
9  #include "absl/meta/type_traits.h"
10  #include "absl/strings/ascii.h"
11  #include "absl/strings/str_cat.h"
12  #include "absl/strings/string_view.h"
13  #include "absl/types/internal/conformance_testing_helpers.h"
14  #include "absl/utility/utility.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace types_internal {
18  template <typename Enum>
19  constexpr absl::underlying_type_t<Enum> UnderlyingValue(Enum value) {
20    return static_cast<absl::underlying_type_t<Enum>>(value);
21  }
22  struct NoError {};
23  class ConformanceErrors {
24   public:
25    explicit ConformanceErrors(std::string type_name)
26        : assertion_result_(false), type_name_(std::move(type_name)) {
27      assertion_result_ << "\n\n"
28                           "Assuming the following type alias:\n"
29                           "\n"
30                           "  using _T = "
31                        << type_name_ << ";\n\n";
32      outputDivider();
33    }
34    void addTestSuccess(absl::string_view test_name) {
35      auto normalized_test_name = absl::AsciiStrToLower(test_name);
36      if (test_failures_.find(normalized_test_name) == test_failures_.end()) {
37        test_successes_.insert(std::move(normalized_test_name));
38      }
39    }
40    template <class... P>
41    void addTestFailure(absl::string_view test_name, const P&... args) {
42      assertion_result_ << "\n\n"
43                           "Failed test: "
44                        << test_name << "\n\n";
45      addTestFailureImpl(args...);
46      assertion_result_ << "\n\n";
47      outputDivider();
48      auto normalized_test_name = absl::AsciiStrToLower(test_name);
49      test_successes_.erase(normalized_test_name);
50      test_failures_.insert(std::move(normalized_test_name));
51      has_error_ = true;
52    }
53    ::testing::AssertionResult assertionResult() const {
54      return has_error_ ? assertion_result_ : ::testing::AssertionSuccess();
55    }
56    ::testing::AssertionResult expectFailedTests(
57        const std::set<std::string>& test_names) const {
58      if (!has_error_) {
59        return ::testing::AssertionFailure()
60               << "Unexpected conformance of type:\n"
61                  "    "
62               << type_name_ << "\n\n";
63      }
64      std::vector<std::string> nonfailing_tests;
65      absl::c_set_difference(test_names, test_failures_,
66                             std::back_inserter(nonfailing_tests));
67      std::vector<std::string> unrun_tests;
68      absl::c_set_difference(nonfailing_tests, test_successes_,
69                             std::back_inserter(unrun_tests));
70      if (!unrun_tests.empty()) {
71        const bool tests_were_run =
72            !(test_failures_.empty() && test_successes_.empty());
73        ::testing::AssertionResult result = ::testing::AssertionFailure();
74        result << "When testing type:\n    " << type_name_
75               << "\n\nThe following tests were expected to fail but were not "
76                  "run";
77        if (tests_were_run) result << " (was the test name spelled correctly?)";
78        result << ":\n\n";
79        for (const auto& test_name : unrun_tests) {
80          result << "    " << test_name << "\n";
81        }
82        if (!tests_were_run) result << "\nNo tests were run.";
83        if (!test_failures_.empty()) {
84          result << "\nThe tests that were run and failed are:\n\n";
85          for (const auto& test_name : test_failures_) {
86            result << "    " << test_name << "\n";
87          }
88        }
89        if (!test_successes_.empty()) {
90          result << "\nThe tests that were run and succeeded are:\n\n";
91          for (const auto& test_name : test_successes_) {
92            result << "    " << test_name << "\n";
93          }
94        }
95        return result;
96      }
97      if (nonfailing_tests.empty()) return ::testing::AssertionSuccess();
98      ::testing::AssertionResult unexpected_successes =
99          ::testing::AssertionFailure();
100      unexpected_successes << "When testing type:\n    " << type_name_
101                           << "\n\nThe following tests passed when they were "
102                              "expected to fail:\n\n";
103      for (const auto& test_name : nonfailing_tests) {
104        unexpected_successes << "    " << test_name << "\n";
105      }
106      return unexpected_successes;
107    }
108   private:
109    void outputDivider() {
110      assertion_result_ << "========================================";
111    }
112    void addTestFailureImpl() {}
113    template <class H, class... T>
114    void addTestFailureImpl(const H& head, const T&... tail) {
115      assertion_result_ << head;
116      addTestFailureImpl(tail...);
117    }
118    ::testing::AssertionResult assertion_result_;
119    std::set<std::string> test_failures_;
120    std::set<std::string> test_successes_;
121    std::string type_name_;
122    bool has_error_ = false;
123  };
124  template <class T, class &bsol;*Enabler*/ = void>
125  struct PropertiesOfImpl {};
126  template <class T>
127  struct PropertiesOfImpl<T, absl::void_t<typename T::properties>> {
128    using type = typename T::properties;
129  };
130  template <class T>
131  struct PropertiesOfImpl<T, absl::void_t<typename T::profile_alias_of>> {
132    using type = typename PropertiesOfImpl<typename T::profile_alias_of>::type;
133  };
134  template <class T>
135  struct PropertiesOf : PropertiesOfImpl<T> {};
136  template <class T>
137  using PropertiesOfT = typename PropertiesOf<T>::type;
138  enum class function_support { maybe, yes, nothrow, trivial };
139  constexpr const char* PessimisticPropertyDescription(function_support v) {
140    return v == function_support::maybe
141               ? "no"
142               : v == function_support::yes
143                     ? "yes, potentially throwing"
144                     : v == function_support::nothrow ? "yes, nothrow"
145                                                      : "yes, trivial";
146  }
147  inline std::string ExpectedFunctionKindList(function_support min,
148                                              function_support max) {
149    if (min == max) {
150      std::string result =
151          absl::StrCat("Expected:\n  ",
152                       PessimisticPropertyDescription(
153                           static_cast<function_support>(UnderlyingValue(min))),
154                       "\n");
155      return result;
156    }
157    std::string result = "Expected one of:\n";
158    for (auto curr_support = UnderlyingValue(min);
159         curr_support <= UnderlyingValue(max); ++curr_support) {
160      absl::StrAppend(&result, "  ",
161                      PessimisticPropertyDescription(
162                          static_cast<function_support>(curr_support)),
163                      "\n");
164    }
165    return result;
166  }
167  template <class Enum>
168  void ExpectModelOfImpl(ConformanceErrors* errors, Enum min_support,
169                         Enum max_support, Enum kind) {
170    const auto kind_value = UnderlyingValue(kind);
171    const auto min_support_value = UnderlyingValue(min_support);
172    const auto max_support_value = UnderlyingValue(max_support);
173    if (!(kind_value >= min_support_value && kind_value <= max_support_value)) {
174      errors->addTestFailure(
175          PropertyName(kind), "**Failed property expectation**\n\n",
176          ExpectedFunctionKindList(
177              static_cast<function_support>(min_support_value),
178              static_cast<function_support>(max_support_value)),
179          '\n', "Actual:\n  ",
180          PessimisticPropertyDescription(
181              static_cast<function_support>(kind_value)));
182    } else {
183      errors->addTestSuccess(PropertyName(kind));
184    }
185  }
186  #define ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM(description, name) \
187    enum class name { maybe, yes, nothrow, trivial };                   \
188                                                                        \
189    constexpr const char* PropertyName(name v) { return description; }  \
190    static_assert(true, "")  
191  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for default construction",
192                                             default_constructible);
193  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for move construction",
194                                             move_constructible);
195  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for copy construction",
196                                             copy_constructible);
197  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for move assignment",
198                                             move_assignable);
199  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for copy assignment",
200                                             copy_assignable);
201  ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM("support for destruction",
202                                             destructible);
203  #undef ABSL_INTERNAL_SPECIAL_MEMBER_FUNCTION_ENUM
204  #define ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM(description, name)     \
205    enum class name { maybe, yes, nothrow };                           \
206                                                                       \
207    constexpr const char* PropertyName(name v) { return description; } \
208    static_assert(true, "")  
209  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for ==", equality_comparable);
210  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for !=", inequality_comparable);
211  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for <", less_than_comparable);
212  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for <=", less_equal_comparable);
213  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for >=",
214                                        greater_equal_comparable);
215  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for >", greater_than_comparable);
216  ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM("support for swap", swappable);
217  #undef ABSL_INTERNAL_INTRINSIC_FUNCTION_ENUM
218  enum class hashable { maybe, yes };
219  constexpr const char* PropertyName(hashable v) {
220    return "support for std::hash";
221  }
222  template <class T>
223  using AlwaysFalse = std::false_type;
224  #define ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(name, property)   \
225    template <class T>                                                        \
226    constexpr property property##_support_of() {                              \
227      return std::is_##property<T>::value                                     \
228                 ? std::is_nothrow_##property<T>::value                       \
229                       ? absl::is_trivially_##property<T>::value              \
230                             ? property::trivial                              \
231                             : property::nothrow                              \
232                       : property::yes                                        \
233                 : property::maybe;                                           \
234    }                                                                         \
235                                                                              \
236    template <class T, class MinProf, class MaxProf>                          \
237    void ExpectModelOf##name(ConformanceErrors* errors) {                     \
238      (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::property##_support, \
239                          PropertiesOfT<MaxProf>::property##_support,         \
240                          property##_support_of<T>());                        \
241    }
242  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(DefaultConstructible,
243                                                    default_constructible);
244  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(MoveConstructible,
245                                                    move_constructible);
246  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(CopyConstructible,
247                                                    copy_constructible);
248  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(MoveAssignable,
249                                                    move_assignable);
250  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(CopyAssignable,
251                                                    copy_assignable);
252  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER(Destructible, destructible);
253  #undef ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_SPECIAL_MEMBER
254  void BoolFunction(bool) noexcept;
255  template <class T, template <class...> class Op, class = void>
256  struct IsOpableImpl : std::false_type {};
257  template <class T, template <class...> class Op>
258  struct IsOpableImpl<T, Op, absl::void_t<Op<T>>> : std::true_type {};
259  template <template <class...> class Op>
260  struct IsOpable {
261    template <class T>
262    using apply = typename IsOpableImpl<T, Op>::type;
263  };
264  template <class T, template <class...> class Op, class = void>
265  struct IsNothrowOpableImpl : std::false_type {};
266  template <class T, template <class...> class Op>
267  struct IsNothrowOpableImpl<T, Op, absl::enable_if_t<Op<T>::value>>
268      : std::true_type {};
269  template <template <class...> class Op>
270  struct IsNothrowOpable {
271    template <class T>
272    using apply = typename IsNothrowOpableImpl<T, Op>::type;
273  };
274  #define ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(name, property, op)      \
275    template <class T,                                                           \
276              class Result = std::integral_constant<                             \
277                  bool, noexcept((BoolFunction)(std::declval<const T&>() op      \
278                                                    std::declval<const T&>()))>> \
279    using name = Result;                                                         \
280                                                                                 \
281    template <class T>                                                           \
282    constexpr property property##_support_of() {                                 \
283      return IsOpable<name>::apply<T>::value                                     \
284                 ? IsNothrowOpable<name>::apply<T>::value ? property::nothrow    \
285                                                          : property::yes        \
286                 : property::maybe;                                              \
287    }                                                                            \
288                                                                                 \
289    template <class T, class MinProf, class MaxProf>                             \
290    void ExpectModelOf##name(ConformanceErrors* errors) {                        \
291      (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::property##_support,    \
292                          PropertiesOfT<MaxProf>::property##_support,            \
293                          property##_support_of<T>());                           \
294    }
295  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(EqualityComparable,
296                                                equality_comparable, ==);
297  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(InequalityComparable,
298                                                inequality_comparable, !=);
299  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(LessThanComparable,
300                                                less_than_comparable, <);
301  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(LessEqualComparable,
302                                                less_equal_comparable, <=);
303  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(GreaterEqualComparable,
304                                                greater_equal_comparable, >=);
305  ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON(GreaterThanComparable,
306                                                greater_than_comparable, >);
307  #undef ABSL_INTERNAL_PESSIMISTIC_MODEL_OF_COMPARISON
308  template <class T>
309  constexpr swappable swappable_support_of() {
310    return type_traits_internal::IsSwappable<T>::value
311               ? type_traits_internal::IsNothrowSwappable<T>::value
312                     ? swappable::nothrow
313                     : swappable::yes
314               : swappable::maybe;
315  }
316  template <class T, class MinProf, class MaxProf>
317  void ExpectModelOfSwappable(ConformanceErrors* errors) {
318    (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::swappable_support,
319                        PropertiesOfT<MaxProf>::swappable_support,
320                        swappable_support_of<T>());
321  }
322  template <class T>
323  constexpr hashable hashable_support_of() {
324    return type_traits_internal::IsHashable<T>::value ? hashable::yes
325                                                      : hashable::maybe;
326  }
327  template <class T, class MinProf, class MaxProf>
328  void ExpectModelOfHashable(ConformanceErrors* errors) {
329    (ExpectModelOfImpl)(errors, PropertiesOfT<MinProf>::hashable_support,
330                        PropertiesOfT<MaxProf>::hashable_support,
331                        hashable_support_of<T>());
332  }
333  template <
334      default_constructible DefaultConstructibleValue =
335          default_constructible::maybe,
336      move_constructible MoveConstructibleValue = move_constructible::maybe,
337      copy_constructible CopyConstructibleValue = copy_constructible::maybe,
338      move_assignable MoveAssignableValue = move_assignable::maybe,
339      copy_assignable CopyAssignableValue = copy_assignable::maybe,
340      destructible DestructibleValue = destructible::maybe,
341      equality_comparable EqualityComparableValue = equality_comparable::maybe,
342      inequality_comparable InequalityComparableValue =
343          inequality_comparable::maybe,
344      less_than_comparable LessThanComparableValue = less_than_comparable::maybe,
345      less_equal_comparable LessEqualComparableValue =
346          less_equal_comparable::maybe,
347      greater_equal_comparable GreaterEqualComparableValue =
348          greater_equal_comparable::maybe,
349      greater_than_comparable GreaterThanComparableValue =
350          greater_than_comparable::maybe,
351      swappable SwappableValue = swappable::maybe,
352      hashable HashableValue = hashable::maybe>
353  struct ConformanceProfile {
354    using properties = ConformanceProfile;
355    static constexpr default_constructible
356        default_constructible_support =  
357        DefaultConstructibleValue;
358    static constexpr move_constructible move_constructible_support =  
359        MoveConstructibleValue;
360    static constexpr copy_constructible copy_constructible_support =  
361        CopyConstructibleValue;
362    static constexpr move_assignable move_assignable_support =  
363        MoveAssignableValue;
364    static constexpr copy_assignable copy_assignable_support =  
365        CopyAssignableValue;
366    static constexpr destructible destructible_support =  
367        DestructibleValue;
368    static constexpr equality_comparable equality_comparable_support =  
369        EqualityComparableValue;
370    static constexpr inequality_comparable
371        inequality_comparable_support =  
372        InequalityComparableValue;
373    static constexpr less_than_comparable
374        less_than_comparable_support =  
375        LessThanComparableValue;
376    static constexpr less_equal_comparable
377        less_equal_comparable_support =  
378        LessEqualComparableValue;
379    static constexpr greater_equal_comparable
380        greater_equal_comparable_support =  
381        GreaterEqualComparableValue;
382    static constexpr greater_than_comparable
383        greater_than_comparable_support =  
384        GreaterThanComparableValue;
385    static constexpr swappable swappable_support = SwappableValue;  
386    static constexpr hashable hashable_support = HashableValue;  
387    static constexpr bool is_default_constructible =  
388        DefaultConstructibleValue != default_constructible::maybe;
389    static constexpr bool is_move_constructible =  
390        MoveConstructibleValue != move_constructible::maybe;
391    static constexpr bool is_copy_constructible =  
392        CopyConstructibleValue != copy_constructible::maybe;
393    static constexpr bool is_move_assignable =  
394        MoveAssignableValue != move_assignable::maybe;
395    static constexpr bool is_copy_assignable =  
396        CopyAssignableValue != copy_assignable::maybe;
397    static constexpr bool is_destructible =  
398        DestructibleValue != destructible::maybe;
399    static constexpr bool is_equality_comparable =  
400        EqualityComparableValue != equality_comparable::maybe;
401    static constexpr bool is_inequality_comparable =  
402        InequalityComparableValue != inequality_comparable::maybe;
403    static constexpr bool is_less_than_comparable =  
404        LessThanComparableValue != less_than_comparable::maybe;
405    static constexpr bool is_less_equal_comparable =  
406        LessEqualComparableValue != less_equal_comparable::maybe;
407    static constexpr bool is_greater_equal_comparable =  
408        GreaterEqualComparableValue != greater_equal_comparable::maybe;
409    static constexpr bool is_greater_than_comparable =  
410        GreaterThanComparableValue != greater_than_comparable::maybe;
411    static constexpr bool is_swappable =  
412        SwappableValue != swappable::maybe;
413    static constexpr bool is_hashable =  
414        HashableValue != hashable::maybe;
415  };
416  enum class CheckHashability { no, yes };
417  template <class T, CheckHashability ShouldCheckHashability>
418  struct conservative_hashable_support_of;
419  template <class T>
420  struct conservative_hashable_support_of<T, CheckHashability::no> {
421    static constexpr hashable Invoke() { return hashable::maybe; }
422  };
423  template <class T>
424  struct conservative_hashable_support_of<T, CheckHashability::yes> {
425    static constexpr hashable Invoke() { return hashable_support_of<T>(); }
426  };
427  template <class T, CheckHashability ShouldCheckHashability>
428  struct SyntacticConformanceProfileOf {
429    using properties = ConformanceProfile<
430        default_constructible_support_of<T>(), move_constructible_support_of<T>(),
431        copy_constructible_support_of<T>(), move_assignable_support_of<T>(),
432        copy_assignable_support_of<T>(), destructible_support_of<T>(),
433        equality_comparable_support_of<T>(),
434        inequality_comparable_support_of<T>(),
435        less_than_comparable_support_of<T>(),
436        less_equal_comparable_support_of<T>(),
437        greater_equal_comparable_support_of<T>(),
438        greater_than_comparable_support_of<T>(), swappable_support_of<T>(),
439        conservative_hashable_support_of<T, ShouldCheckHashability>::Invoke()>;
440  };
441  #define ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(type, name)     \
442    template <default_constructible DefaultConstructibleValue,                   \
443              move_constructible MoveConstructibleValue,                         \
444              copy_constructible CopyConstructibleValue,                         \
445              move_assignable MoveAssignableValue,                               \
446              copy_assignable CopyAssignableValue,                               \
447              destructible DestructibleValue,                                    \
448              equality_comparable EqualityComparableValue,                       \
449              inequality_comparable InequalityComparableValue,                   \
450              less_than_comparable LessThanComparableValue,                      \
451              less_equal_comparable LessEqualComparableValue,                    \
452              greater_equal_comparable GreaterEqualComparableValue,              \
453              greater_than_comparable GreaterThanComparableValue,                \
454              swappable SwappableValue, hashable HashableValue>                  \
455    constexpr type ConformanceProfile<                                           \
456        DefaultConstructibleValue, MoveConstructibleValue,                       \
457        CopyConstructibleValue, MoveAssignableValue, CopyAssignableValue,        \
458        DestructibleValue, EqualityComparableValue, InequalityComparableValue,   \
459        LessThanComparableValue, LessEqualComparableValue,                       \
460        GreaterEqualComparableValue, GreaterThanComparableValue, SwappableValue, \
461        HashableValue>::name
462  #define ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(type)           \
463    ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(type,            \
464                                                           type##_support); \
465    ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL(bool, is_##type)
466  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
467  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(default_constructible);
468  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(move_constructible);
469  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(copy_constructible);
470  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(move_assignable);
471  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(copy_assignable);
472  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(destructible);
473  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(equality_comparable);
474  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(inequality_comparable);
475  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(less_than_comparable);
476  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(less_equal_comparable);
477  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(greater_equal_comparable);
478  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(greater_than_comparable);
479  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(swappable);
480  ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF(hashable);
481  #endif
482  #undef ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF
483  #undef ABSL_INTERNAL_CONFORMANCE_TESTING_DATA_MEMBER_DEF_IMPL
484  template <class H>
485  constexpr H MinEnum(H head) {
486    return head;
487  }
488  template <class H, class N, class... T>
489  constexpr H MinEnum(H head, N next, T... tail) {
490    return (UnderlyingValue)(head) < (UnderlyingValue)(next)
491               ? (MinEnum)(head, tail...)
492               : (MinEnum)(next, tail...);
493  }
494  template <class... Profs>
495  struct MinimalProfiles {
496    static constexpr default_constructible
497        default_constructible_support =  
498        (MinEnum)(PropertiesOfT<Profs>::default_constructible_support...);
499    static constexpr move_constructible move_constructible_support =  
500        (MinEnum)(PropertiesOfT<Profs>::move_constructible_support...);
501    static constexpr copy_constructible copy_constructible_support =  
502        (MinEnum)(PropertiesOfT<Profs>::copy_constructible_support...);
503    static constexpr move_assignable move_assignable_support =  
504        (MinEnum)(PropertiesOfT<Profs>::move_assignable_support...);
505    static constexpr copy_assignable copy_assignable_support =  
506        (MinEnum)(PropertiesOfT<Profs>::copy_assignable_support...);
507    static constexpr destructible destructible_support =  
508        (MinEnum)(PropertiesOfT<Profs>::destructible_support...);
509    static constexpr equality_comparable equality_comparable_support =  
510        (MinEnum)(PropertiesOfT<Profs>::equality_comparable_support...);
511    static constexpr inequality_comparable
512        inequality_comparable_support =  
513        (MinEnum)(PropertiesOfT<Profs>::inequality_comparable_support...);
514    static constexpr less_than_comparable
515        less_than_comparable_support =  
516        (MinEnum)(PropertiesOfT<Profs>::less_than_comparable_support...);
517    static constexpr less_equal_comparable
518        less_equal_comparable_support =  
519        (MinEnum)(PropertiesOfT<Profs>::less_equal_comparable_support...);
520    static constexpr greater_equal_comparable
521        greater_equal_comparable_support =  
522        (MinEnum)(PropertiesOfT<Profs>::greater_equal_comparable_support...);
523    static constexpr greater_than_comparable
524        greater_than_comparable_support =  
525        (MinEnum)(PropertiesOfT<Profs>::greater_than_comparable_support...);
526    static constexpr swappable swappable_support =  
527        (MinEnum)(PropertiesOfT<Profs>::swappable_support...);
528    static constexpr hashable hashable_support =  
529        (MinEnum)(PropertiesOfT<Profs>::hashable_support...);
<span onclick='openModal()' class='match'>530    using properties = ConformanceProfile<
531        default_constructible_support, move_constructible_support,
532        copy_constructible_support, move_assignable_support,
533        copy_assignable_support, destructible_support,
534        equality_comparable_support, inequality_comparable_support,
535        less_than_comparable_support, less_equal_comparable_support,
536        greater_equal_comparable_support, greater_than_comparable_support,
537        swappable_support, hashable_support>;
</span>538  };
539  template <class H>
540  constexpr H MaxEnum(H head) {
541    return head;
542  }
543  template <class H, class N, class... T>
544  constexpr H MaxEnum(H head, N next, T... tail) {
545    return (UnderlyingValue)(next) < (UnderlyingValue)(head)
546               ? (MaxEnum)(head, tail...)
547               : (MaxEnum)(next, tail...);
548  }
549  template <class... Profs>
550  struct CombineProfilesImpl {
551    static constexpr default_constructible
552        default_constructible_support =  
553        (MaxEnum)(PropertiesOfT<Profs>::default_constructible_support...);
554    static constexpr move_constructible move_constructible_support =  
555        (MaxEnum)(PropertiesOfT<Profs>::move_constructible_support...);
556    static constexpr copy_constructible copy_constructible_support =  
557        (MaxEnum)(PropertiesOfT<Profs>::copy_constructible_support...);
558    static constexpr move_assignable move_assignable_support =  
559        (MaxEnum)(PropertiesOfT<Profs>::move_assignable_support...);
560    static constexpr copy_assignable copy_assignable_support =  
561        (MaxEnum)(PropertiesOfT<Profs>::copy_assignable_support...);
562    static constexpr destructible destructible_support =  
563        (MaxEnum)(PropertiesOfT<Profs>::destructible_support...);
564    static constexpr equality_comparable equality_comparable_support =  
565        (MaxEnum)(PropertiesOfT<Profs>::equality_comparable_support...);
566    static constexpr inequality_comparable
567        inequality_comparable_support =  
568        (MaxEnum)(PropertiesOfT<Profs>::inequality_comparable_support...);
569    static constexpr less_than_comparable
570        less_than_comparable_support =  
571        (MaxEnum)(PropertiesOfT<Profs>::less_than_comparable_support...);
572    static constexpr less_equal_comparable
573        less_equal_comparable_support =  
574        (MaxEnum)(PropertiesOfT<Profs>::less_equal_comparable_support...);
575    static constexpr greater_equal_comparable
576        greater_equal_comparable_support =  
577        (MaxEnum)(PropertiesOfT<Profs>::greater_equal_comparable_support...);
578    static constexpr greater_than_comparable
579        greater_than_comparable_support =  
580        (MaxEnum)(PropertiesOfT<Profs>::greater_than_comparable_support...);
581    static constexpr swappable swappable_support =  
582        (MaxEnum)(PropertiesOfT<Profs>::swappable_support...);
583    static constexpr hashable hashable_support =  
584        (MaxEnum)(PropertiesOfT<Profs>::hashable_support...);
585    using properties = ConformanceProfile<
586        default_constructible_support, move_constructible_support,
587        copy_constructible_support, move_assignable_support,
588        copy_assignable_support, destructible_support,
589        equality_comparable_support, inequality_comparable_support,
590        less_than_comparable_support, less_equal_comparable_support,
591        greater_equal_comparable_support, greater_than_comparable_support,
592        swappable_support, hashable_support>;
593  };
594  template <class... Profs>
595  struct CombineProfiles {
596    using profile_alias_of = CombineProfilesImpl<Profs...>;
597  };
598  template <>
599  struct CombineProfiles<> {
600    using properties = ConformanceProfile<>;
601  };
602  template <class Profile, class Tag>
603  struct StrongProfileTypedef {
604    using properties = PropertiesOfT<Profile>;
605  };
606  template <class T, class &bsol;*Enabler*/ = void>
607  struct IsProfileImpl : std::false_type {};
608  template <class T>
609  struct IsProfileImpl<T, absl::void_t<PropertiesOfT<T>>> : std::true_type {};
610  template <class T>
611  struct IsProfile : IsProfileImpl<T>::type {};
612  struct RegularityDomain {};
613  }  
614  ABSL_NAMESPACE_END
615  }  
616  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockbuilders.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_profile.h</div>
                </div>
                <div class="column column_space"><pre><code>36  	std::unique_ptr<BLOCKTYPE> build ();
37  	std::unique_ptr<BLOCKTYPE> build (std::error_code & ec);
38  	std::shared_ptr<BLOCKTYPE> build_shared ();
39  	std::shared_ptr<BLOCKTYPE> build_shared (std::error_code & ec);
40  	abstract_builder & work (uint64_t work);
</pre></code></div>
                <div class="column column_space"><pre><code>530    using properties = ConformanceProfile<
531        default_constructible_support, move_constructible_support,
532        copy_constructible_support, move_assignable_support,
533        copy_assignable_support, destructible_support,
534        equality_comparable_support, inequality_comparable_support,
535        less_than_comparable_support, less_equal_comparable_support,
536        greater_equal_comparable_support, greater_than_comparable_support,
537        swappable_support, hashable_support>;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    