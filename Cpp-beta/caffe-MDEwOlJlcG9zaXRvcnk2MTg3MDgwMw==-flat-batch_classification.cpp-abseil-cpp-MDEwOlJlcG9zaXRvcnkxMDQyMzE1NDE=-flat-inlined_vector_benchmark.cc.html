
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.0%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</h3>
            <pre><code>1  #include <caffe/caffe.hpp>
2  #ifdef USE_OPENCV
3  #include <opencv2/core/core.hpp>
4  #include <opencv2/highgui/highgui.hpp>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #endif  
7  #include <algorithm>
8  #include <iosfwd>
9  #include <memory>
10  #include <string>
11  #include <utility>
12  #include <vector>
13  #include <gflags/gflags.h>
14  #ifdef USE_OPENCV
15  using namespace caffe;  
16  using std::string;
17  using std::cout;
18  using std::cerr;
19  using std::endl;
20  using std::vector;
21  DEFINE_string(model, "",
22      "Required; The model definition protocol buffer text file.");
23  DEFINE_string(weights, "",
24      "Required; The pretrained weights.");
25  DEFINE_string(input, "",
26      "Required; File that contain the path of input images line by line");
27  DEFINE_string(label_file, "",
28      "Required; The label file.");
29  DEFINE_string(engine, "",
30      "Optional; Engine can only be CAFFE | MKL2017 | MKLDNN");
31  DEFINE_string(mean_file, "",
32      "Optional; The mean file used to subtract from the input image.");
33  DEFINE_string(mean_value, "104,117,123",
34      "Optional; If specified, can be one value or can be same as image channels"
35      " - would subtract from the corresponding channel). Separated by ','.");
36  DEFINE_int32(batch_size, 1,
37      "Optional; batch size, default 1");
38  typedef std::pair<string, float> Prediction;
39  class Classifier {
40      public:
41          Classifier(const string& model_file,
42                  const string& trained_file,
43                  const string& mean_file,
44                  const string& mean_value,
45                  const string& label_file,
46                  const string& engine,
47                  const size_t batch_size,
48                  const size_t topN = 5
49                  );
50          vector<vector<Prediction> > ClassifyBatch(vector<cv::Mat>& imgs);
51      private:
52          void SetMean(const string& mean_file, const string& mean_value);
53          vector<float> PredictBatch(vector<cv::Mat>& imgs);
54          void WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch);
55          void WriteImgToInput(const vector<cv::Mat>& imgs, vector<vector<cv::Mat> >* input_channels_batch);
56          void Preprocess(cv::Mat& img);
57          void PreprocessBatch(vector<cv::Mat>& imgs);
58      private:
59          shared_ptr<Net<float> > net_;
60          cv::Size input_geometry_;
61          int num_channels_;
62          cv::Mat mean_;
63          size_t batch_size_;
64          size_t topN_;
65          std::vector<string> labels_;
66  };
67  Classifier::Classifier(const string& model_file,
68          const string& trained_file,
69          const string& mean_file,
70          const string& mean_value,
71          const string& label_file,
72          const string& engine,
73          const size_t batch_size,
74          const size_t topN
75          ) {
76  #ifdef CPU_ONLY
77      Caffe::set_mode(Caffe::CPU);
78  #else
79      Caffe::set_mode(Caffe::GPU);
80  #endif
81      net_.reset(new Net<float>(model_file, TEST, 0, NULL, NULL, engine));
82      net_->CopyTrainedLayersFrom(trained_file);
83      CHECK_EQ(net_->num_inputs(), 1) << "Network should have exactly one input.";
84      CHECK_EQ(net_->num_outputs(), 1) << "Network should have exactly one output.";
85      Blob<float>* input_layer = net_->input_blobs()[0];
86      num_channels_ = input_layer->channels();
87      CHECK(num_channels_ == 3 || num_channels_ == 1)
88          << "Input layer should have 1 or 3 channels.";
89      input_geometry_ = cv::Size(input_layer->width(), input_layer->height());
90      SetMean(mean_file, mean_value);
91      batch_size_ = batch_size;
92      topN_ = topN;
93      if(!label_file.empty()) {
94      std::ifstream labels(label_file.c_str());
95      CHECK(labels) << "Unable to open labels file " << label_file;
96      string line;
97      while (std::getline(labels, line))
98          labels_.push_back(string(line));
99      Blob<float>* output_layer = net_->output_blobs()[0];
100      CHECK_EQ(labels_.size(), output_layer->channels())
101          << "Number of labels is different from the output layer dimension.";
102      }
103  }
104  static bool PairCompare(const std::pair<float, int>& lhs,
105          const std::pair<float, int>& rhs) {
106      return lhs.first > rhs.first;
107  }
108  static vector<int> Argmax(const vector<float>& v, int N) {
109      vector<std::pair<float, int> > pairs;
110      for (size_t i = 0; i < v.size(); ++i)
111          pairs.push_back(std::make_pair(v[i], i));
112      std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);
113      vector<int> result;
114      for (int i = 0; i < N; ++i)
115          result.push_back(pairs[i].second);
116      return result;
117  }
118  vector<vector<Prediction> > Classifier::ClassifyBatch(vector<cv::Mat>& imgs) {
119      vector<float> output_batch = PredictBatch(imgs);
120      vector<vector<Prediction> > predictionsBatch;
121      int output_channels = net_->output_blobs()[0]->channels();
122      for (size_t i = 0; i < batch_size_; ++i) {
123          vector<float> output(output_batch.begin() + i*output_channels, output_batch.begin()+(i+1)*output_channels);
124          vector<int> maxN = Argmax(output, topN_);
125          vector<Prediction>  predictions;
126          for (int i = 0; i < topN_; ++i) {
127              int idx = maxN[i];
128              if(labels_.empty()) {
129                  predictions.push_back(std::make_pair(std::to_string(idx), output[idx]));
130              } else{
131                  predictions.push_back(std::make_pair(labels_[idx], output[idx]));
132              }
133          }
134          predictionsBatch.push_back(predictions);
135      }
136      return predictionsBatch;
137  }
138  void Classifier::SetMean(const string& mean_file, const string& mean_value) {
139      cv::Scalar channel_mean;
140      if(!mean_file.empty()) {
141          BlobProto blob_proto;
142          ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);
143          Blob<float> mean_blob;
144          mean_blob.FromProto(blob_proto);
145          CHECK_EQ(mean_blob.channels(), num_channels_)
146              << "Number of channels of mean file doesn't match input layer.";
147          vector<cv::Mat> channels;
148          float* data = mean_blob.mutable_cpu_data();
149          for (int i = 0; i < num_channels_; ++i) {
150              cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
151              channels.push_back(channel);
152              data += mean_blob.height() * mean_blob.width();
153          }
154          cv::Mat mean;
155          cv::merge(channels, mean);
156          channel_mean = cv::mean(mean);
157          mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
158      }
159      if (!mean_value.empty()) {
160          stringstream ss(mean_value);
161          vector<float> values;
162          string item;
163          while (getline(ss, item, ',')) {
164              float value = std::atof(item.c_str());
165              values.push_back(value);
166          }
167          CHECK(values.size() == 1 || values.size() == num_channels_) <<
168              "Specify either 1 mean_value or as many as channels: " << num_channels_;
169          std::vector<cv::Mat> channels;
170          for (int i = 0; i < num_channels_; ++i) {
171              cv::Mat channel(input_geometry_.height, input_geometry_.width, CV_32FC1,
172                      cv::Scalar(values[i]));
173              channels.push_back(channel);
174          }
175          cv::merge(channels, mean_);
176      }
177  }
178  vector<float> Classifier::PredictBatch(vector<cv::Mat>& imgs) {
179      Blob<float>* input_layer = net_->input_blobs()[0];
180      input_layer->Reshape(batch_size_, num_channels_,
181              input_geometry_.height, input_geometry_.width);
182      net_->Reshape();
183      vector<vector<cv::Mat> > input_channels_batch;
184      WrapInputLayerBatch(&input_channels_batch);
185      PreprocessBatch(imgs);
186      WriteImgToInput(imgs, &input_channels_batch);
187      net_->Forward();
188      Blob<float>* output_layer = net_->output_blobs()[0];
189      const float* begin = output_layer->cpu_data();
190      const float* end = begin + output_layer->channels() * batch_size_;
191      printf("output_layer->channels: %d\n", output_layer->channels());
192      return vector<float>(begin, end);
<span onclick='openModal()' class='match'>193  }
194  void Classifier::WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch) {
195      Blob<float>* input_layer = net_->input_blobs()[0];
196      int width = input_layer->width();
197      int height = input_layer->height();
</span>198      float* input_data = input_layer->mutable_cpu_data();
199      int num = input_layer->num();
200      for( int j = 0; j < num; ++j) {
201          vector<cv::Mat> input_channels;
202          for (int i = 0; i < input_layer->channels(); ++i) {
203              cv::Mat channel(height, width, CV_32FC1, input_data);
204              input_channels.push_back(channel);
205              input_data += width * height;
206          }
207          input_channels_batch->push_back(input_channels);
208      }
209  }
210  void Classifier::WriteImgToInput(const vector<cv::Mat>& imgs,
211          vector<vector<cv::Mat> >* input_channels_batch)
212  {
213      for(size_t i=0; i<batch_size_; ++i) {
214          cv::split(imgs[i], input_channels_batch->at(i));
215      }
216  }
217  void Classifier::PreprocessBatch(vector<cv::Mat>& imgs) {
218      for(size_t i=0; i<imgs.size(); ++i) {
219          Preprocess(imgs[i]);
220      }
221  }
222  void Classifier::Preprocess(cv::Mat& img) {
223      cv::Mat sample;
224      if (img.channels() == 3 && num_channels_ == 1)
225          cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
226      else if (img.channels() == 4 && num_channels_ == 1)
227          cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
228      else if (img.channels() == 4 && num_channels_ == 3)
229          cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
230      else if (img.channels() == 1 && num_channels_ == 3)
231          cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
232      else
233          sample = img;
234      cv::Mat sample_resized;
235      if (sample.size() != input_geometry_)
236          cv::resize(sample, sample_resized, input_geometry_);
237      else
238          sample_resized = sample;
239      cv::Mat sample_float;
240      if (num_channels_ == 3)
241          sample_resized.convertTo(sample_float, CV_32FC3);
242      else
243          sample_resized.convertTo(sample_float, CV_32FC1);
244      cv::subtract(sample_float, mean_, img);
245  }
246  vector<cv::Mat> loadImgBatch(vector<string> imgNames) {
247      vector<cv::Mat> imgs;
248      for(size_t i=0; i<imgNames.size(); ++i) {
249          cv::Mat img = cv::imread(imgNames[i], -1);
250          CHECK(!img.empty()) << "Unable to decode image " << imgNames[i];
251          imgs.push_back(img);
252      }
253      return imgs;
254  }
255  void printPrediction(vector<Prediction> predictions) {
256      for (size_t i = 0; i < predictions.size(); ++i) {
257          Prediction p = predictions[i];
258          cout << std::fixed << std::setprecision(4) << p.second << " - \""
259              << p.first << "\"" << endl;
260      }
261  }
262  void printPredictionsBatch(vector<string> imgNames,
263          vector<vector<Prediction> > predictionsBatch) {
264      for( size_t i = 0; i < predictionsBatch.size(); ++i) {
265          cout << "---------- "<< i + 1 <<": Prediction for "
266              << imgNames[i] << " ----------" << endl;
267          printPrediction(predictionsBatch[i]);
268      }
269  }
270  vector<string> readImgListFromPath(string file) {
271      vector<string> rawImgNames;
272      std::ifstream input_lines(file.c_str());
273      CHECK(input_lines) << "Unable to open file " << file;
274      string line;
275      while (std::getline(input_lines, line))
276          rawImgNames.push_back(string(line));
277      return rawImgNames;
278  }
279  int main(int argc, char** argv) {
280      ::google::InitGoogleLogging(argv[0]);
281  #ifndef GFLAGS_GFLAGS_H_
282      namespace gflags = google;
283  #endif
284      gflags::SetUsageMessage("Image classification.\n"
285          "Usage:\n"
286          "batch_classification <args>\n"
287          "Example: ./batch_classification --model <model path> --weights <weights path> --input <input.txt> --batch_size <num>"
288          );
289      gflags::ParseCommandLineFlags(&argc, &argv, true);
290      CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to score.";
291      CHECK_GT(FLAGS_weights.size(), 0) << "Need model weights to score.";
292      CHECK_GT(FLAGS_input.size(), 0) << "Need model weights to score.";
293      cout<<"Use batch size: "<< FLAGS_batch_size << endl;
294      if (FLAGS_mean_file.empty()) {
295          cout<<"Use mean value: "<< FLAGS_mean_value<<endl;
296      }else{
297          cout<<"Use mean file: "<<FLAGS_mean_file<<endl;
298      }
299  #ifdef USE_MLSL
300      caffe::mn::init(&argc,&argv);
301  #endif
302      Classifier classifier(FLAGS_model, FLAGS_weights, FLAGS_mean_file,
303              FLAGS_mean_value, FLAGS_label_file, FLAGS_engine, FLAGS_batch_size);
304      vector<string> rawImgNames = readImgListFromPath(FLAGS_input);
305      if(rawImgNames.size() > 0 && rawImgNames.size() < FLAGS_batch_size) {
306          while(rawImgNames.size() < FLAGS_batch_size) {
307              rawImgNames.insert(rawImgNames.end(), rawImgNames.begin(), rawImgNames.end());
308          }
309      }
310      vector<string> imgNames(rawImgNames.begin(), rawImgNames.begin() + FLAGS_batch_size);
311      vector<cv::Mat> imgs = loadImgBatch(rawImgNames);
312      vector<vector<Prediction> > predictionsBatch = classifier.ClassifyBatch(imgs);
313      printPredictionsBatch(imgNames, predictionsBatch);
314      return 0;
315  }
316  #else
317  int main(int argc, char** argv) {
318      LOG(FATAL) << "This example requires OpenCV; compile with USE_OPENCV.";
319  }
320  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</h3>
            <pre><code>1  #include <array>
2  #include <string>
3  #include <vector>
4  #include "absl/base/internal/raw_logging.h"
5  #include "absl/base/macros.h"
6  #include "absl/container/inlined_vector.h"
7  #include "absl/strings/str_cat.h"
8  #include "benchmark/benchmark.h"
9  namespace {
10  void BM_InlinedVectorFill(benchmark::State& state) {
11    const int len = state.range(0);
12    absl::InlinedVector<int, 8> v;
13    v.reserve(len);
14    for (auto _ : state) {
15      v.resize(0);  
16      for (int i = 0; i < len; ++i) {
17        v.push_back(i);
18      }
19      benchmark::DoNotOptimize(v);
20    }
21  }
22  BENCHMARK(BM_InlinedVectorFill)->Range(1, 256);
23  void BM_InlinedVectorFillRange(benchmark::State& state) {
24    const int len = state.range(0);
25    const std::vector<int> src(len, len);
26    absl::InlinedVector<int, 8> v;
27    v.reserve(len);
28    for (auto _ : state) {
29      benchmark::DoNotOptimize(src);
30      v.assign(src.begin(), src.end());
31      benchmark::DoNotOptimize(v);
32    }
33  }
34  BENCHMARK(BM_InlinedVectorFillRange)->Range(1, 256);
35  void BM_StdVectorFill(benchmark::State& state) {
36    const int len = state.range(0);
37    std::vector<int> v;
38    v.reserve(len);
39    for (auto _ : state) {
40      v.clear();
41      for (int i = 0; i < len; ++i) {
42        v.push_back(i);
43      }
44      benchmark::DoNotOptimize(v);
45    }
46  }
47  BENCHMARK(BM_StdVectorFill)->Range(1, 256);
48  bool StringRepresentedInline(std::string s) {
49    const char* chars = s.data();
50    std::string s1 = std::move(s);
51    return s1.data() != chars;
52  }
53  int GetNonShortStringOptimizationSize() {
54    for (int i = 24; i <= 192; i *= 2) {
55      if (!StringRepresentedInline(std::string(i, 'A'))) {
56        return i;
57      }
58    }
59    ABSL_RAW_LOG(
60        FATAL,
61        "Failed to find a string larger than the short string optimization");
62    return -1;
<span onclick='openModal()' class='match'>63  }
64  void BM_InlinedVectorFillString(benchmark::State& state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
</span>68                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
69    for (auto _ : state) {
70      absl::InlinedVector<std::string, 8> v;
71      for (int i = 0; i < len; i++) {
72        v.push_back(strings[i & 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)->Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State& state) {
79    const int len = state.range(0);
80    const int no_sso = GetNonShortStringOptimizationSize();
81    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
82                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
83    for (auto _ : state) {
84      std::vector<std::string> v;
85      for (int i = 0; i < len; i++) {
86        v.push_back(strings[i & 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)->Range(0, 1024);
92  struct Buffer {  
93    char* base;
94    int length;
95    int capacity;
96    void* user_data;
97  };
98  void BM_InlinedVectorAssignments(benchmark::State& state) {
99    const int len = state.range(0);
100    using BufferVec = absl::InlinedVector<Buffer, 2>;
101    BufferVec src;
102    src.resize(len);
103    BufferVec dst;
104    for (auto _ : state) {
105      benchmark::DoNotOptimize(dst);
106      benchmark::DoNotOptimize(src);
107      dst = src;
108    }
109  }
110  BENCHMARK(BM_InlinedVectorAssignments)
111      ->Arg(0)
112      ->Arg(1)
113      ->Arg(2)
114      ->Arg(3)
115      ->Arg(4)
116      ->Arg(20);
117  void BM_CreateFromContainer(benchmark::State& state) {
118    for (auto _ : state) {
119      absl::InlinedVector<int, 4> src{1, 2, 3};
120      benchmark::DoNotOptimize(src);
121      absl::InlinedVector<int, 4> dst(std::move(src));
122      benchmark::DoNotOptimize(dst);
123    }
124  }
125  BENCHMARK(BM_CreateFromContainer);
126  struct LargeCopyableOnly {
127    LargeCopyableOnly() : d(1024, 17) {}
128    LargeCopyableOnly(const LargeCopyableOnly& o) = default;
129    LargeCopyableOnly& operator=(const LargeCopyableOnly& o) = default;
130    std::vector<int> d;
131  };
132  struct LargeCopyableSwappable {
133    LargeCopyableSwappable() : d(1024, 17) {}
134    LargeCopyableSwappable(const LargeCopyableSwappable& o) = default;
135    LargeCopyableSwappable& operator=(LargeCopyableSwappable o) {
136      using std::swap;
137      swap(*this, o);
138      return *this;
139    }
140    friend void swap(LargeCopyableSwappable& a, LargeCopyableSwappable& b) {
141      using std::swap;
142      swap(a.d, b.d);
143    }
144    std::vector<int> d;
145  };
146  struct LargeCopyableMovable {
147    LargeCopyableMovable() : d(1024, 17) {}
148    std::vector<int> d;
149  };
150  struct LargeCopyableMovableSwappable {
151    LargeCopyableMovableSwappable() : d(1024, 17) {}
152    LargeCopyableMovableSwappable(const LargeCopyableMovableSwappable& o) =
153        default;
154    LargeCopyableMovableSwappable(LargeCopyableMovableSwappable&& o) = default;
155    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable o) {
156      using std::swap;
157      swap(*this, o);
158      return *this;
159    }
160    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable&& o) =
161        default;
162    friend void swap(LargeCopyableMovableSwappable& a,
163                     LargeCopyableMovableSwappable& b) {
164      using std::swap;
165      swap(a.d, b.d);
166    }
167    std::vector<int> d;
168  };
169  template <typename ElementType>
170  void BM_SwapElements(benchmark::State& state) {
171    const int len = state.range(0);
172    using Vec = absl::InlinedVector<ElementType, 32>;
173    Vec a(len);
174    Vec b;
175    for (auto _ : state) {
176      using std::swap;
177      benchmark::DoNotOptimize(a);
178      benchmark::DoNotOptimize(b);
179      swap(a, b);
180    }
181  }
182  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableOnly)->Range(0, 1024);
183  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableSwappable)->Range(0, 1024);
184  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovable)->Range(0, 1024);
185  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovableSwappable)
186      ->Range(0, 1024);
187  template <typename VecType>
188  void BM_Sizeof(benchmark::State& state) {
189    int size = 0;
190    for (auto _ : state) {
191      VecType vec;
192      size = sizeof(vec);
193    }
194    state.SetLabel(absl::StrCat("sz=", size));
195  }
196  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 1>);
197  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 4>);
198  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 7>);
199  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 8>);
200  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 1>);
201  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 4>);
202  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 7>);
203  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 8>);
204  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 1>);
205  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 4>);
206  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 7>);
207  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 8>);
208  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 1>);
209  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 4>);
210  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 7>);
211  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 8>);
212  void BM_InlinedVectorIndexInlined(benchmark::State& state) {
213    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
214    for (auto _ : state) {
215      benchmark::DoNotOptimize(v);
216      benchmark::DoNotOptimize(v[4]);
217    }
218  }
219  BENCHMARK(BM_InlinedVectorIndexInlined);
220  void BM_InlinedVectorIndexExternal(benchmark::State& state) {
221    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
222    for (auto _ : state) {
223      benchmark::DoNotOptimize(v);
224      benchmark::DoNotOptimize(v[4]);
225    }
226  }
227  BENCHMARK(BM_InlinedVectorIndexExternal);
228  void BM_StdVectorIndex(benchmark::State& state) {
229    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
230    for (auto _ : state) {
231      benchmark::DoNotOptimize(v);
232      benchmark::DoNotOptimize(v[4]);
233    }
234  }
235  BENCHMARK(BM_StdVectorIndex);
236  void BM_InlinedVectorDataInlined(benchmark::State& state) {
237    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
238    for (auto _ : state) {
239      benchmark::DoNotOptimize(v);
240      benchmark::DoNotOptimize(v.data());
241    }
242  }
243  BENCHMARK(BM_InlinedVectorDataInlined);
244  void BM_InlinedVectorDataExternal(benchmark::State& state) {
245    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
246    for (auto _ : state) {
247      benchmark::DoNotOptimize(v);
248      benchmark::DoNotOptimize(v.data());
249    }
250    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
251  }
252  BENCHMARK(BM_InlinedVectorDataExternal);
253  void BM_StdVectorData(benchmark::State& state) {
254    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
255    for (auto _ : state) {
256      benchmark::DoNotOptimize(v);
257      benchmark::DoNotOptimize(v.data());
258    }
259    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
260  }
261  BENCHMARK(BM_StdVectorData);
262  void BM_InlinedVectorSizeInlined(benchmark::State& state) {
263    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
264    for (auto _ : state) {
265      benchmark::DoNotOptimize(v);
266      benchmark::DoNotOptimize(v.size());
267    }
268  }
269  BENCHMARK(BM_InlinedVectorSizeInlined);
270  void BM_InlinedVectorSizeExternal(benchmark::State& state) {
271    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
272    for (auto _ : state) {
273      benchmark::DoNotOptimize(v);
274      benchmark::DoNotOptimize(v.size());
275    }
276  }
277  BENCHMARK(BM_InlinedVectorSizeExternal);
278  void BM_StdVectorSize(benchmark::State& state) {
279    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
280    for (auto _ : state) {
281      benchmark::DoNotOptimize(v);
282      benchmark::DoNotOptimize(v.size());
283    }
284  }
285  BENCHMARK(BM_StdVectorSize);
286  void BM_InlinedVectorEmptyInlined(benchmark::State& state) {
287    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
288    for (auto _ : state) {
289      benchmark::DoNotOptimize(v);
290      benchmark::DoNotOptimize(v.empty());
291    }
292  }
293  BENCHMARK(BM_InlinedVectorEmptyInlined);
294  void BM_InlinedVectorEmptyExternal(benchmark::State& state) {
295    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
296    for (auto _ : state) {
297      benchmark::DoNotOptimize(v);
298      benchmark::DoNotOptimize(v.empty());
299    }
300  }
301  BENCHMARK(BM_InlinedVectorEmptyExternal);
302  void BM_StdVectorEmpty(benchmark::State& state) {
303    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
304    for (auto _ : state) {
305      benchmark::DoNotOptimize(v);
306      benchmark::DoNotOptimize(v.empty());
307    }
308  }
309  BENCHMARK(BM_StdVectorEmpty);
310  constexpr size_t kInlinedCapacity = 4;
311  constexpr size_t kLargeSize = kInlinedCapacity * 2;
312  constexpr size_t kSmallSize = kInlinedCapacity / 2;
313  constexpr size_t kBatchSize = 100;
314  #define ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_FunctionTemplate, T) \
315    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize);        \
316    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize)
317  #define ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_FunctionTemplate, T)      \
318    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kLargeSize); \
319    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kSmallSize); \
320    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kLargeSize); \
321    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kSmallSize)
322  template <typename T>
323  using InlVec = absl::InlinedVector<T, kInlinedCapacity>;
324  struct TrivialType {
325    size_t val;
326  };
327  class NontrivialType {
328   public:
329    ABSL_ATTRIBUTE_NOINLINE NontrivialType() : val_() {
330      benchmark::DoNotOptimize(*this);
331    }
332    ABSL_ATTRIBUTE_NOINLINE NontrivialType(const NontrivialType& other)
333        : val_(other.val_) {
334      benchmark::DoNotOptimize(*this);
335    }
336    ABSL_ATTRIBUTE_NOINLINE NontrivialType& operator=(
337        const NontrivialType& other) {
338      val_ = other.val_;
339      benchmark::DoNotOptimize(*this);
340      return *this;
341    }
342    ABSL_ATTRIBUTE_NOINLINE ~NontrivialType() noexcept {
343      benchmark::DoNotOptimize(*this);
344    }
345   private:
346    size_t val_;
347  };
348  template <typename T, typename PrepareVecFn, typename TestVecFn>
349  void BatchedBenchmark(benchmark::State& state, PrepareVecFn prepare_vec,
350                        TestVecFn test_vec) {
351    std::array<InlVec<T>, kBatchSize> vector_batch{};
352    while (state.KeepRunningBatch(kBatchSize)) {
353      state.PauseTiming();
354      for (size_t i = 0; i < kBatchSize; ++i) {
355        prepare_vec(vector_batch.data() + i, i);
356      }
357      benchmark::DoNotOptimize(vector_batch);
358      state.ResumeTiming();
359      for (size_t i = 0; i < kBatchSize; ++i) {
360        test_vec(vector_batch.data() + i, i);
361      }
362    }
363  }
364  template <typename T, size_t ToSize>
365  void BM_ConstructFromSize(benchmark::State& state) {
366    using VecT = InlVec<T>;
367    auto size = ToSize;
368    BatchedBenchmark<T>(
369        state,
370         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
371        [&](void* ptr, size_t) {
372          benchmark::DoNotOptimize(size);
373          ::new (ptr) VecT(size);
374        });
375  }
376  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, TrivialType);
377  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, NontrivialType);
378  template <typename T, size_t ToSize>
379  void BM_ConstructFromSizeRef(benchmark::State& state) {
380    using VecT = InlVec<T>;
381    auto size = ToSize;
382    auto ref = T();
383    BatchedBenchmark<T>(
384        state,
385         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
386        [&](void* ptr, size_t) {
387          benchmark::DoNotOptimize(size);
388          benchmark::DoNotOptimize(ref);
389          ::new (ptr) VecT(size, ref);
390        });
391  }
392  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, TrivialType);
393  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, NontrivialType);
394  template <typename T, size_t ToSize>
395  void BM_ConstructFromRange(benchmark::State& state) {
396    using VecT = InlVec<T>;
397    std::array<T, ToSize> arr{};
398    BatchedBenchmark<T>(
399        state,
400         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
401        [&](void* ptr, size_t) {
402          benchmark::DoNotOptimize(arr);
403          ::new (ptr) VecT(arr.begin(), arr.end());
404        });
405  }
406  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, TrivialType);
407  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, NontrivialType);
408  template <typename T, size_t ToSize>
409  void BM_ConstructFromCopy(benchmark::State& state) {
410    using VecT = InlVec<T>;
411    VecT other_vec(ToSize);
412    BatchedBenchmark<T>(
413        state,
414        [](InlVec<T>* vec, size_t) { vec->~VecT(); },
415        [&](void* ptr, size_t) {
416          benchmark::DoNotOptimize(other_vec);
417          ::new (ptr) VecT(other_vec);
418        });
419  }
420  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, TrivialType);
421  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, NontrivialType);
422  template <typename T, size_t ToSize>
423  void BM_ConstructFromMove(benchmark::State& state) {
424    using VecT = InlVec<T>;
425    std::array<VecT, kBatchSize> vector_batch{};
426    BatchedBenchmark<T>(
427        state,
428        [&](InlVec<T>* vec, size_t i) {
429          vector_batch[i].clear();
430          vector_batch[i].resize(ToSize);
431          vec->~VecT();
432        },
433        [&](void* ptr, size_t i) {
434          benchmark::DoNotOptimize(vector_batch[i]);
435          ::new (ptr) VecT(std::move(vector_batch[i]));
436        });
437  }
438  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, TrivialType);
439  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, NontrivialType);
440  void BM_CopyTrivial(benchmark::State& state) {
441    const int n = state.range(0);
442    InlVec<int64_t> src(n);
443    for (auto s : state) {
444      InlVec<int64_t> copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State& state) {
450    const int n = state.range(0);
451    InlVec<InlVec<int64_t>> src(n);
452    for (auto s : state) {
453      InlVec<InlVec<int64_t>> copy(src);
454      benchmark::DoNotOptimize(copy);
455    }
456  }
457  BENCHMARK(BM_CopyNonTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
458  template <typename T, size_t FromSize, size_t ToSize>
459  void BM_AssignSizeRef(benchmark::State& state) {
460    auto size = ToSize;
461    auto ref = T();
462    BatchedBenchmark<T>(
463        state,
464         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
465        [&](InlVec<T>* vec, size_t) {
466          benchmark::DoNotOptimize(size);
467          benchmark::DoNotOptimize(ref);
468          vec->assign(size, ref);
469        });
470  }
471  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, TrivialType);
472  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, NontrivialType);
473  template <typename T, size_t FromSize, size_t ToSize>
474  void BM_AssignRange(benchmark::State& state) {
475    std::array<T, ToSize> arr{};
476    BatchedBenchmark<T>(
477        state,
478         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
479        [&](InlVec<T>* vec, size_t) {
480          benchmark::DoNotOptimize(arr);
481          vec->assign(arr.begin(), arr.end());
482        });
483  }
484  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, TrivialType);
485  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, NontrivialType);
486  template <typename T, size_t FromSize, size_t ToSize>
487  void BM_AssignFromCopy(benchmark::State& state) {
488    InlVec<T> other_vec(ToSize);
489    BatchedBenchmark<T>(
490        state,
491         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
492        [&](InlVec<T>* vec, size_t) {
493          benchmark::DoNotOptimize(other_vec);
494          *vec = other_vec;
495        });
496  }
497  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, TrivialType);
498  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, NontrivialType);
499  template <typename T, size_t FromSize, size_t ToSize>
500  void BM_AssignFromMove(benchmark::State& state) {
501    using VecT = InlVec<T>;
502    std::array<VecT, kBatchSize> vector_batch{};
503    BatchedBenchmark<T>(
504        state,
505        [&](InlVec<T>* vec, size_t i) {
506          vector_batch[i].clear();
507          vector_batch[i].resize(ToSize);
508          vec->resize(FromSize);
509        },
510        [&](InlVec<T>* vec, size_t i) {
511          benchmark::DoNotOptimize(vector_batch[i]);
512          *vec = std::move(vector_batch[i]);
513        });
514  }
515  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, TrivialType);
516  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, NontrivialType);
517  template <typename T, size_t FromSize, size_t ToSize>
518  void BM_ResizeSize(benchmark::State& state) {
519    BatchedBenchmark<T>(
520        state,
521        [](InlVec<T>* vec, size_t) {
522          vec->clear();
523          vec->resize(FromSize);
524        },
525        [](InlVec<T>* vec, size_t) { vec->resize(ToSize); });
526  }
527  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, TrivialType);
528  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, NontrivialType);
529  template <typename T, size_t FromSize, size_t ToSize>
530  void BM_ResizeSizeRef(benchmark::State& state) {
531    auto t = T();
532    BatchedBenchmark<T>(
533        state,
534        [](InlVec<T>* vec, size_t) {
535          vec->clear();
536          vec->resize(FromSize);
537        },
538        [&](InlVec<T>* vec, size_t) {
539          benchmark::DoNotOptimize(t);
540          vec->resize(ToSize, t);
541        });
542  }
543  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, TrivialType);
544  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, NontrivialType);
545  template <typename T, size_t FromSize, size_t ToSize>
546  void BM_InsertSizeRef(benchmark::State& state) {
547    auto t = T();
548    BatchedBenchmark<T>(
549        state,
550        [](InlVec<T>* vec, size_t) {
551          vec->clear();
552          vec->resize(FromSize);
553        },
554        [&](InlVec<T>* vec, size_t) {
555          benchmark::DoNotOptimize(t);
556          auto* pos = vec->data() + (vec->size() / 2);
557          vec->insert(pos, t);
558        });
559  }
560  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, TrivialType);
561  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, NontrivialType);
562  template <typename T, size_t FromSize, size_t ToSize>
563  void BM_InsertRange(benchmark::State& state) {
564    InlVec<T> other_vec(ToSize);
565    BatchedBenchmark<T>(
566        state,
567        [](InlVec<T>* vec, size_t) {
568          vec->clear();
569          vec->resize(FromSize);
570        },
571        [&](InlVec<T>* vec, size_t) {
572          benchmark::DoNotOptimize(other_vec);
573          auto* pos = vec->data() + (vec->size() / 2);
574          vec->insert(pos, other_vec.begin(), other_vec.end());
575        });
576  }
577  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, TrivialType);
578  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, NontrivialType);
579  template <typename T, size_t FromSize>
580  void BM_EmplaceBack(benchmark::State& state) {
581    BatchedBenchmark<T>(
582        state,
583        [](InlVec<T>* vec, size_t) {
584          vec->clear();
585          vec->resize(FromSize);
586        },
587        [](InlVec<T>* vec, size_t) { vec->emplace_back(); });
588  }
589  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, TrivialType);
590  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, NontrivialType);
591  template <typename T, size_t FromSize>
592  void BM_PopBack(benchmark::State& state) {
593    BatchedBenchmark<T>(
594        state,
595        [](InlVec<T>* vec, size_t) {
596          vec->clear();
597          vec->resize(FromSize);
598        },
599        [](InlVec<T>* vec, size_t) { vec->pop_back(); });
600  }
601  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, TrivialType);
602  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, NontrivialType);
603  template <typename T, size_t FromSize>
604  void BM_EraseOne(benchmark::State& state) {
605    BatchedBenchmark<T>(
606        state,
607        [](InlVec<T>* vec, size_t) {
608          vec->clear();
609          vec->resize(FromSize);
610        },
611        [](InlVec<T>* vec, size_t) {
612          auto* pos = vec->data() + (vec->size() / 2);
613          vec->erase(pos);
614        });
615  }
616  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, TrivialType);
617  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, NontrivialType);
618  template <typename T, size_t FromSize>
619  void BM_EraseRange(benchmark::State& state) {
620    BatchedBenchmark<T>(
621        state,
622        [](InlVec<T>* vec, size_t) {
623          vec->clear();
624          vec->resize(FromSize);
625        },
626        [](InlVec<T>* vec, size_t) {
627          auto* pos = vec->data() + (vec->size() / 2);
628          vec->erase(pos, pos + 1);
629        });
630  }
631  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, TrivialType);
632  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, NontrivialType);
633  template <typename T, size_t FromSize>
634  void BM_Clear(benchmark::State& state) {
635    BatchedBenchmark<T>(
636        state,
637         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
638         [](InlVec<T>* vec, size_t) { vec->clear(); });
639  }
640  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, TrivialType);
641  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, NontrivialType);
642  template <typename T, size_t FromSize, size_t ToCapacity>
643  void BM_Reserve(benchmark::State& state) {
644    BatchedBenchmark<T>(
645        state,
646        [](InlVec<T>* vec, size_t) {
647          vec->clear();
648          vec->resize(FromSize);
649        },
650        [](InlVec<T>* vec, size_t) { vec->reserve(ToCapacity); });
651  }
652  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, TrivialType);
653  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, NontrivialType);
654  template <typename T, size_t FromCapacity, size_t ToCapacity>
655  void BM_ShrinkToFit(benchmark::State& state) {
656    BatchedBenchmark<T>(
657        state,
658        [](InlVec<T>* vec, size_t) {
659          vec->clear();
660          vec->resize(ToCapacity);
661          vec->reserve(FromCapacity);
662        },
663         [](InlVec<T>* vec, size_t) { vec->shrink_to_fit(); });
664  }
665  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, TrivialType);
666  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, NontrivialType);
667  template <typename T, size_t FromSize, size_t ToSize>
668  void BM_Swap(benchmark::State& state) {
669    using VecT = InlVec<T>;
670    std::array<VecT, kBatchSize> vector_batch{};
671    BatchedBenchmark<T>(
672        state,
673        [&](InlVec<T>* vec, size_t i) {
674          vector_batch[i].clear();
675          vector_batch[i].resize(ToSize);
676          vec->resize(FromSize);
677        },
678        [&](InlVec<T>* vec, size_t i) {
679          using std::swap;
680          benchmark::DoNotOptimize(vector_batch[i]);
681          swap(*vec, vector_batch[i]);
682        });
683  }
684  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, TrivialType);
685  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, NontrivialType);
686  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>193  }
194  void Classifier::WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch) {
195      Blob<float>* input_layer = net_->input_blobs()[0];
196      int width = input_layer->width();
197      int height = input_layer->height();
</pre></code></div>
                <div class="column column_space"><pre><code>63  }
64  void BM_InlinedVectorFillString(benchmark::State& state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    