
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 22.427035330261134%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/boost/asio/ip/tcp.hpp>
3  #include <nano/boost/asio/strand.hpp>
4  #include <nano/lib/asio.hpp>
5  #include <nano/lib/locks.hpp>
6  #include <nano/lib/timer.hpp>
7  #include <nano/node/transport/traffic_type.hpp>
8  #include <chrono>
9  #include <map>
10  #include <memory>
11  #include <optional>
12  #include <queue>
13  #include <unordered_map>
14  #include <vector>
15  namespace boost::asio::ip
16  {
17  class network_v6;
18  }
19  namespace nano
20  {
21  class node;
22  }
23  namespace nano::transport
24  {
25  enum class buffer_drop_policy
26  {
27  	limiter,
28  	no_limiter_drop,
29  	no_socket_drop
30  };
31  class server_socket;
32  class socket : public std::enable_shared_from_this<nano::transport::socket>
33  {
34  	friend class server_socket;
35  	friend class tcp_server;
36  	friend class tcp_channels;
37  public:
38  	static std::size_t constexpr default_max_queue_size = 128;
39  	enum class type_t
40  	{
41  		undefined,
42  		bootstrap,
43  		realtime,
44  		realtime_response_server 
45  	};
46  	enum class endpoint_type_t
47  	{
48  		server,
49  		client
50  	};
51  	explicit socket (nano::node & node, endpoint_type_t endpoint_type_a, std::size_t max_queue_size = default_max_queue_size);
52  	virtual ~socket ();
53  	void start ();
54  	void async_connect (boost::asio::ip::tcp::endpoint const &, std::function<void (boost::system::error_code const &)>);
55  	void async_read (std::shared_ptr<std::vector<uint8_t>> const &, std::size_t, std::function<void (boost::system::error_code const &, std::size_t)>);
<span onclick='openModal()' class='match'>56  	void async_write (nano::shared_const_buffer const &, std::function<void (boost::system::error_code const &, std::size_t)> callback = {}, nano::transport::traffic_type = nano::transport::traffic_type::generic);
57  	virtual void close ();
58  	boost::asio::ip::tcp::endpoint remote_endpoint () const;
59  	boost::asio::ip::tcp::endpoint local_endpoint () const;
60  	bool has_timed_out () const;
61  	void set_default_timeout_value (std::chrono::seconds);
62  	std::chrono::seconds get_default_timeout_value () const;
63  	void set_timeout (std::chrono::seconds);
</span>64  	void set_silent_connection_tolerance_time (std::chrono::seconds tolerance_time_a);
65  	bool max (nano::transport::traffic_type = nano::transport::traffic_type::generic) const;
66  	bool full (nano::transport::traffic_type = nano::transport::traffic_type::generic) const;
67  	type_t type () const
68  	{
69  		return type_m;
70  	};
71  	void type_set (type_t type_a)
72  	{
73  		type_m = type_a;
74  	}
75  	endpoint_type_t endpoint_type () const
76  	{
77  		return endpoint_type_m;
78  	}
79  	bool is_realtime_connection () const
80  	{
81  		return type () == nano::transport::socket::type_t::realtime || type () == nano::transport::socket::type_t::realtime_response_server;
82  	}
83  	bool is_bootstrap_connection () const
84  	{
85  		return type () == nano::transport::socket::type_t::bootstrap;
86  	}
87  	bool is_closed () const
88  	{
89  		return closed;
90  	}
91  	bool alive () const
92  	{
93  		return !closed && tcp_socket.is_open ();
94  	}
95  private:
96  	class write_queue
97  	{
98  	public:
99  		using buffer_t = nano::shared_const_buffer;
100  		using callback_t = std::function<void (boost::system::error_code const &, std::size_t)>;
101  		struct entry
102  		{
103  			buffer_t buffer;
104  			callback_t callback;
105  		};
106  	public:
107  		explicit write_queue (std::size_t max_size);
108  		bool insert (buffer_t const &, callback_t, nano::transport::traffic_type);
109  		std::optional<entry> pop ();
110  		void clear ();
111  		std::size_t size (nano::transport::traffic_type) const;
112  		bool empty () const;
113  		std::size_t const max_size;
114  	private:
115  		mutable nano::mutex mutex;
116  		std::unordered_map<nano::transport::traffic_type, std::queue<entry>> queues;
117  	};
118  	write_queue send_queue;
119  protected:
120  	boost::asio::strand<boost::asio::io_context::executor_type> strand;
121  	boost::asio::ip::tcp::socket tcp_socket;
122  	nano::node & node;
123  	boost::asio::ip::tcp::endpoint remote;
124  	std::atomic<uint64_t> timeout;
125  	std::atomic<uint64_t> last_completion_time_or_init;
126  	std::atomic<nano::seconds_t> last_receive_time_or_init;
127  	std::atomic<bool> timed_out{ false };
128  	std::atomic<std::chrono::seconds> default_timeout;
129  	std::chrono::seconds silent_connection_tolerance_time;
130  	std::atomic<bool> closed{ false };
131  	std::atomic<bool> write_in_progress{ false };
132  	void close_internal ();
133  	void write_queued_messages ();
134  	void set_default_timeout ();
135  	void set_last_completion ();
136  	void set_last_receive_time ();
137  	void ongoing_checkup ();
138  	void read_impl (std::shared_ptr<std::vector<uint8_t>> const & data_a, std::size_t size_a, std::function<void (boost::system::error_code const &, std::size_t)> callback_a);
139  private:
140  	type_t type_m{ type_t::undefined };
141  	endpoint_type_t endpoint_type_m;
142  public:
143  	std::size_t const max_queue_size;
144  };
145  std::string socket_type_to_string (socket::type_t type);
146  using address_socket_mmap = std::multimap<boost::asio::ip::address, std::weak_ptr<socket>>;
147  namespace socket_functions
148  {
149  	boost::asio::ip::network_v6 get_ipv6_subnet_address (boost::asio::ip::address_v6 const &, std::size_t);
150  	boost::asio::ip::address first_ipv6_subnet_address (boost::asio::ip::address_v6 const &, std::size_t);
151  	boost::asio::ip::address last_ipv6_subnet_address (boost::asio::ip::address_v6 const &, std::size_t);
152  	std::size_t count_subnetwork_connections (nano::transport::address_socket_mmap const &, boost::asio::ip::address_v6 const &, std::size_t);
153  }
154  class server_socket final : public socket
155  {
156  public:
157  	explicit server_socket (nano::node & node_a, boost::asio::ip::tcp::endpoint local_a, std::size_t max_connections_a);
158  	void start (boost::system::error_code &);
159  	void close () override;
160  	void on_connection (std::function<bool (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const &)>);
161  	uint16_t listening_port ()
162  	{
163  		return acceptor.local_endpoint ().port ();
164  	}
165  private:
166  	nano::transport::address_socket_mmap connections_per_address;
167  	boost::asio::ip::tcp::acceptor acceptor;
168  	boost::asio::ip::tcp::endpoint local;
169  	std::size_t max_inbound_connections;
170  	void evict_dead_connections ();
171  	void on_connection_requeue_delayed (std::function<bool (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const &)>);
172  	bool limit_reached_for_incoming_ip_connections (std::shared_ptr<nano::transport::socket> const & new_connection);
173  	bool limit_reached_for_incoming_subnetwork_connections (std::shared_ptr<nano::transport::socket> const & new_connection);
174  };
175  class client_socket final : public socket
176  {
177  public:
178  	explicit client_socket (nano::node & node_a, std::size_t max_queue_size = default_max_queue_size) :
179  		socket{ node_a, endpoint_type_t::client, max_queue_size }
180  	{
181  	}
182  };
183  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_gradient_check_util.hpp</h3>
            <pre><code>1  #ifndef CAFFE_TEST_GRADIENT_CHECK_UTIL_H_
2  #define CAFFE_TEST_GRADIENT_CHECK_UTIL_H_
3  #include <glog/logging.h>
4  #include <gtest/gtest.h>
5  #include <algorithm>
6  #include <cmath>
7  #include <vector>
8  #include "caffe/layer.hpp"
9  #include "caffe/net.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  class GradientChecker {
13   public:
14    GradientChecker(const Dtype stepsize, const Dtype threshold,
15        const unsigned int seed = 1701, const Dtype kink = 0.,
16        const Dtype kink_range = -1)
17        : stepsize_(stepsize), threshold_(threshold), seed_(seed),
18          kink_(kink), kink_range_(kink_range) {}
19    void CheckGradient(Layer<Dtype>* layer, const vector<Blob<Dtype>*>& bottom,
20        const vector<Blob<Dtype>*>& top, int check_bottom = -1) {
21        layer->SetUp(bottom, top);
22        CheckGradientSingle(layer, bottom, top, check_bottom, -1, -1);
23    }
24    void CheckGradientExhaustive(Layer<Dtype>* layer,
25        const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
26        int check_bottom = -1);
27    void CheckGradientEltwise(Layer<Dtype>* layer,
28        const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top);
29    void CheckGradientSingle(Layer<Dtype>* layer,
30        const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
<span onclick='openModal()' class='match'>31        int check_bottom, int top_id, int top_data_id, bool element_wise = false);
32    void CheckGradientNet(const Net<Dtype>& net,
</span>33        const vector<Blob<Dtype>*>& input);
34   protected:
35    Dtype GetObjAndGradient(const Layer<Dtype>& layer,
36        const vector<Blob<Dtype>*>& top, int top_id = -1, int top_data_id = -1);
37    Dtype stepsize_;
38    Dtype threshold_;
39    unsigned int seed_;
40    Dtype kink_;
41    Dtype kink_range_;
42  };
43  template <typename Dtype>
44  void GradientChecker<Dtype>::CheckGradientSingle(Layer<Dtype>* layer,
45      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
46      int check_bottom, int top_id, int top_data_id, bool element_wise) {
47    if (element_wise) {
48      CHECK_EQ(0, layer->blobs().size());
49      CHECK_LE(0, top_id);
50      CHECK_LE(0, top_data_id);
51      const int top_count = top[top_id]->count();
52      for (int blob_id = 0; blob_id < bottom.size(); ++blob_id) {
53        CHECK_EQ(top_count, bottom[blob_id]->count());
54      }
55    }
56    vector<Blob<Dtype>*> blobs_to_check;
57    vector<bool> propagate_down(bottom.size(), check_bottom == -1);
58    for (int i = 0; i < layer->blobs().size(); ++i) {
59      Blob<Dtype>* blob = layer->blobs()[i].get();
60      caffe_set(blob->count(), static_cast<Dtype>(0), blob->mutable_cpu_diff());
61      blobs_to_check.push_back(blob);
62    }
63    if (check_bottom == -1) {
64      for (int i = 0; i < bottom.size(); ++i) {
65        blobs_to_check.push_back(bottom[i]);
66      }
67    } else if (check_bottom >= 0) {
68      CHECK_LT(check_bottom, bottom.size());
69      blobs_to_check.push_back(bottom[check_bottom]);
70      propagate_down[check_bottom] = true;
71    }
72    CHECK_GT(blobs_to_check.size(), 0) << "No blobs to check.";
73    Caffe::set_random_seed(seed_);
74    layer->Forward(bottom, top);
75    GetObjAndGradient(*layer, top, top_id, top_data_id);
76    layer->Backward(top, propagate_down, bottom);
77    vector<shared_ptr<Blob<Dtype> > >
78        computed_gradient_blobs(blobs_to_check.size());
79    for (int blob_id = 0; blob_id < blobs_to_check.size(); ++blob_id) {
80      Blob<Dtype>* current_blob = blobs_to_check[blob_id];
81      computed_gradient_blobs[blob_id].reset(new Blob<Dtype>());
82      computed_gradient_blobs[blob_id]->ReshapeLike(*current_blob);
83      const int count = blobs_to_check[blob_id]->count();
84      const Dtype* diff = blobs_to_check[blob_id]->cpu_diff();
85      Dtype* computed_gradients =
86          computed_gradient_blobs[blob_id]->mutable_cpu_data();
87      caffe_copy(count, diff, computed_gradients);
88    }
89    for (int blob_id = 0; blob_id < blobs_to_check.size(); ++blob_id) {
90      Blob<Dtype>* current_blob = blobs_to_check[blob_id];
91      const Dtype* computed_gradients =
92          computed_gradient_blobs[blob_id]->cpu_data();
93      for (int feat_id = 0; feat_id < current_blob->count(); ++feat_id) {
94        Dtype estimated_gradient = 0;
95        Dtype positive_objective = 0;
96        Dtype negative_objective = 0;
97        if (!element_wise || (feat_id == top_data_id)) {
98          current_blob->mutable_cpu_data()[feat_id] += stepsize_;
99          Caffe::set_random_seed(seed_);
100          layer->Forward(bottom, top);
101          positive_objective =
102              GetObjAndGradient(*layer, top, top_id, top_data_id);
103          current_blob->mutable_cpu_data()[feat_id] -= stepsize_ * 2;
104          Caffe::set_random_seed(seed_);
105          layer->Forward(bottom, top);
106          negative_objective =
107              GetObjAndGradient(*layer, top, top_id, top_data_id);
108          current_blob->mutable_cpu_data()[feat_id] += stepsize_;
109          estimated_gradient = (positive_objective - negative_objective) /
110              stepsize_ / 2.;
111        }
112        Dtype computed_gradient = computed_gradients[feat_id];
113        Dtype feature = current_blob->cpu_data()[feat_id];
114        if (kink_ - kink_range_ > fabs(feature)
115            || fabs(feature) > kink_ + kink_range_) {
116          Dtype scale = std::max<Dtype>(
117              std::max(fabs(computed_gradient), fabs(estimated_gradient)),
118              Dtype(1.));
119          EXPECT_NEAR(computed_gradient, estimated_gradient, threshold_ * scale)
120            << "debug: (top_id, top_data_id, blob_id, feat_id)="
121            << top_id << "," << top_data_id << "," << blob_id << "," << feat_id
122            << "; feat = " << feature
123            << "; objective+ = " << positive_objective
124            << "; objective- = " << negative_objective;
125        }
126      }
127    }
128  }
129  template <typename Dtype>
130  void GradientChecker<Dtype>::CheckGradientExhaustive(Layer<Dtype>* layer,
131      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top,
132      int check_bottom) {
133    layer->SetUp(bottom, top);
134    CHECK_GT(top.size(), 0) << "Exhaustive mode requires at least one top blob.";
135    for (int i = 0; i < top.size(); ++i) {
136      for (int j = 0; j < top[i]->count(); ++j) {
137        CheckGradientSingle(layer, bottom, top, check_bottom, i, j);
138      }
139    }
140  }
141  template <typename Dtype>
142  void GradientChecker<Dtype>::CheckGradientEltwise(Layer<Dtype>* layer,
143      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
144    layer->SetUp(bottom, top);
145    CHECK_GT(top.size(), 0) << "Eltwise mode requires at least one top blob.";
146    const int check_bottom = -1;
147    const bool element_wise = true;
148    for (int i = 0; i < top.size(); ++i) {
149      for (int j = 0; j < top[i]->count(); ++j) {
150        CheckGradientSingle(layer, bottom, top, check_bottom, i, j, element_wise);
151      }
152    }
153  }
154  template <typename Dtype>
155  void GradientChecker<Dtype>::CheckGradientNet(
156      const Net<Dtype>& net, const vector<Blob<Dtype>*>& input) {
157    const vector<shared_ptr<Layer<Dtype> > >& layers = net.layers();
158    vector<vector<Blob<Dtype>*> >& bottom_vecs = net.bottom_vecs();
159    vector<vector<Blob<Dtype>*> >& top_vecs = net.top_vecs();
160    for (int i = 0; i < layers.size(); ++i) {
161      net.Forward(input);
162      LOG(ERROR) << "Checking gradient for " << layers[i]->layer_param().name();
163      CheckGradientExhaustive(*(layers[i].get()), bottom_vecs[i], top_vecs[i]);
164    }
165  }
166  template <typename Dtype>
167  Dtype GradientChecker<Dtype>::GetObjAndGradient(const Layer<Dtype>& layer,
168      const vector<Blob<Dtype>*>& top, int top_id, int top_data_id) {
169    Dtype loss = 0;
170    if (top_id < 0) {
171      for (int i = 0; i < top.size(); ++i) {
172        Blob<Dtype>* top_blob = top[i];
173        const Dtype* top_blob_data = top_blob->cpu_data();
174        Dtype* top_blob_diff = top_blob->mutable_cpu_diff();
175        int count = top_blob->count();
176        for (int j = 0; j < count; ++j) {
177          loss += top_blob_data[j] * top_blob_data[j];
178        }
179        caffe_copy(top_blob->count(), top_blob_data, top_blob_diff);
180      }
181      loss /= 2.;
182    } else {
183      for (int i = 0; i < top.size(); ++i) {
184        Blob<Dtype>* top_blob = top[i];
185        Dtype* top_blob_diff = top_blob->mutable_cpu_diff();
186        caffe_set(top_blob->count(), Dtype(0), top_blob_diff);
187      }
188      const Dtype loss_weight = 2;
189      loss = top[top_id]->cpu_data()[top_data_id] * loss_weight;
190      top[top_id]->mutable_cpu_diff()[top_data_id] = loss_weight;
191    }
192    return loss;
193  }
194  }  
195  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_gradient_check_util.hpp</div>
                </div>
                <div class="column column_space"><pre><code>56  	void async_write (nano::shared_const_buffer const &, std::function<void (boost::system::error_code const &, std::size_t)> callback = {}, nano::transport::traffic_type = nano::transport::traffic_type::generic);
57  	virtual void close ();
58  	boost::asio::ip::tcp::endpoint remote_endpoint () const;
59  	boost::asio::ip::tcp::endpoint local_endpoint () const;
60  	bool has_timed_out () const;
61  	void set_default_timeout_value (std::chrono::seconds);
62  	std::chrono::seconds get_default_timeout_value () const;
63  	void set_timeout (std::chrono::seconds);
</pre></code></div>
                <div class="column column_space"><pre><code>31        int check_bottom, int top_id, int top_data_id, bool element_wise = false);
32    void CheckGradientNet(const Net<Dtype>& net,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    