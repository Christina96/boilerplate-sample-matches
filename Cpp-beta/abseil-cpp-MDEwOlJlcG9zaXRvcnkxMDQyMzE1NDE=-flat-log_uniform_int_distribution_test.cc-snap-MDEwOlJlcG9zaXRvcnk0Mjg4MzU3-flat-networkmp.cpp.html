
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.826546003016592%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_uniform_int_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/log_uniform_int_distribution.h"
2  #include <cstddef>
3  #include <cstdint>
4  #include <iterator>
5  #include <random>
6  #include <sstream>
7  #include <string>
8  #include <vector>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/log/log.h"
12  #include "absl/random/internal/chi_square.h"
13  #include "absl/random/internal/distribution_test_util.h"
14  #include "absl/random/internal/pcg_engine.h"
15  #include "absl/random/internal/sequence_urbg.h"
16  #include "absl/random/random.h"
17  #include "absl/strings/str_cat.h"
18  #include "absl/strings/str_format.h"
19  #include "absl/strings/str_replace.h"
20  #include "absl/strings/strip.h"
21  namespace {
22  template <typename IntType>
23  class LogUniformIntDistributionTypeTest : public ::testing::Test {};
24  using IntTypes = ::testing::Types<int8_t, int16_t, int32_t, int64_t,  
25                                    uint8_t, uint16_t, uint32_t, uint64_t>;
26  TYPED_TEST_SUITE(LogUniformIntDistributionTypeTest, IntTypes);
27  TYPED_TEST(LogUniformIntDistributionTypeTest, SerializeTest) {
28    using param_type =
29        typename absl::log_uniform_int_distribution<TypeParam>::param_type;
30    using Limits = std::numeric_limits<TypeParam>;
31    constexpr int kCount = 1000;
32    absl::InsecureBitGen gen;
33    for (const auto& param : {
<span onclick='openModal()' class='match'>34             param_type(0, 1),                             
35             param_type(0, 2),                             
36             param_type(0, 2, 10),                         
37             param_type(9, 32, 4),                         
38             param_type(1, 101, 10),                       
39             param_type(1, Limits::max() / 2),             
40             param_type(0, Limits::max() - 1),             
41             param_type(0, Limits::max(), 2),              
42             param_type(0, Limits::max(), 10),             
</span>43             param_type(Limits::min(), 0),                 
44             param_type(Limits::lowest(), Limits::max()),  
45             param_type(Limits::min(), Limits::max()),     
46         }) {
47      const auto min = param.min();
48      const auto max = param.max();
49      const auto base = param.base();
50      absl::log_uniform_int_distribution<TypeParam> before(min, max, base);
51      EXPECT_EQ(before.min(), param.min());
52      EXPECT_EQ(before.max(), param.max());
53      EXPECT_EQ(before.base(), param.base());
54      {
55        absl::log_uniform_int_distribution<TypeParam> via_param(param);
56        EXPECT_EQ(via_param, before);
57      }
58      std::stringstream ss;
59      ss << before;
60      absl::log_uniform_int_distribution<TypeParam> after(3, 6, 17);
61      EXPECT_NE(before.max(), after.max());
62      EXPECT_NE(before.base(), after.base());
63      EXPECT_NE(before.param(), after.param());
64      EXPECT_NE(before, after);
65      ss >> after;
66      EXPECT_EQ(before.min(), after.min());
67      EXPECT_EQ(before.max(), after.max());
68      EXPECT_EQ(before.base(), after.base());
69      EXPECT_EQ(before.param(), after.param());
70      EXPECT_EQ(before, after);
71      auto sample_min = after.max();
72      auto sample_max = after.min();
73      for (int i = 0; i < kCount; i++) {
74        auto sample = after(gen);
75        EXPECT_GE(sample, after.min());
76        EXPECT_LE(sample, after.max());
77        if (sample > sample_max) sample_max = sample;
78        if (sample < sample_min) sample_min = sample;
79      }
80      LOG(INFO) << "Range: " << sample_min << ", " << sample_max;
81    }
82  }
83  using log_uniform_i32 = absl::log_uniform_int_distribution<int32_t>;
84  class LogUniformIntChiSquaredTest
85      : public testing::TestWithParam<log_uniform_i32::param_type> {
86   public:
87    double ChiSquaredTestImpl();
88    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
89  };
90  double LogUniformIntChiSquaredTest::ChiSquaredTestImpl() {
91    using absl::random_internal::kChiSquared;
92    const auto& param = GetParam();
93    const bool is_2 = (param.base() == 2);
94    const double base_log = 1.0 / std::log(param.base());
95    const auto bucket_index = [base_log, is_2, &param](int32_t x) {
96      uint64_t y = static_cast<uint64_t>(x) - param.min();
97      return (y == 0) ? 0
98                      : is_2 ? static_cast<int>(1 + std::log2(y))
99                             : static_cast<int>(1 + std::log(y) * base_log);
100    };
101    const int max_bucket = bucket_index(param.max());  
102    const size_t trials = 15 + (max_bucket + 1) * 10;
103    log_uniform_i32 dist(param);
104    std::vector<int64_t> buckets(max_bucket + 1);
105    for (size_t i = 0; i < trials; ++i) {
106      const auto sample = dist(rng_);
107      ABSL_ASSERT(sample <= dist.max());
108      ABSL_ASSERT(sample >= dist.min());
109      int bucket = bucket_index(sample);
110      ABSL_ASSERT(bucket <= max_bucket);
111      ++buckets[bucket];
112    }
113    const int dof = buckets.size() - 1;
114    const double expected = trials / static_cast<double>(buckets.size());
115    const double threshold = absl::random_internal::ChiSquareValue(dof, 0.98);
116    double chi_square = absl::random_internal::ChiSquareWithExpected(
117        std::begin(buckets), std::end(buckets), expected);
118    const double p = absl::random_internal::ChiSquarePValue(chi_square, dof);
119    if (chi_square > threshold) {
120      LOG(INFO) << "values";
121      for (size_t i = 0; i < buckets.size(); i++) {
122        LOG(INFO) << i << ": " << buckets[i];
123      }
124      LOG(INFO) << "trials=" << trials << "\n"
125                << kChiSquared << "(data, " << dof << ") = " << chi_square << " ("
126                << p << ")\n"
127                << kChiSquared << " @ 0.98 = " << threshold;
128    }
129    return p;
130  }
131  TEST_P(LogUniformIntChiSquaredTest, MultiTest) {
132    const int kTrials = 5;
133    int failures = 0;
134    for (int i = 0; i < kTrials; i++) {
135      double p_value = ChiSquaredTestImpl();
136      if (p_value < 0.005) {
137        failures++;
138      }
139    }
140    EXPECT_LE(failures, 4);
141  }
142  std::vector<log_uniform_i32::param_type> GenParams() {
143    using Param = log_uniform_i32::param_type;
144    using Limits = std::numeric_limits<int32_t>;
145    return std::vector<Param>{
146        Param{0, 1, 2},
147        Param{1, 1, 2},
148        Param{0, 2, 2},
149        Param{0, 3, 2},
150        Param{0, 4, 2},
151        Param{0, 9, 10},
152        Param{0, 10, 10},
153        Param{0, 11, 10},
154        Param{1, 10, 10},
155        Param{0, (1 << 8) - 1, 2},
156        Param{0, (1 << 8), 2},
157        Param{0, (1 << 30) - 1, 2},
158        Param{-1000, 1000, 10},
159        Param{0, Limits::max(), 2},
160        Param{0, Limits::max(), 3},
161        Param{0, Limits::max(), 10},
162        Param{Limits::min(), 0},
163        Param{Limits::min(), Limits::max(), 2},
164    };
165  }
166  std::string ParamName(
167      const ::testing::TestParamInfo<log_uniform_i32::param_type>& info) {
168    const auto& p = info.param;
169    std::string name =
170        absl::StrCat("min_", p.min(), "__max_", p.max(), "__base_", p.base());
171    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
172  }
173  INSTANTIATE_TEST_SUITE_P(All, LogUniformIntChiSquaredTest,
174                           ::testing::ValuesIn(GenParams()), ParamName);
175  TEST(LogUniformIntDistributionTest, StabilityTest) {
176    using testing::ElementsAre;
177    absl::random_internal::sequence_urbg urbg(
178        {0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull, 0xC332DDEFBE6C5AA5ull,
179         0x6558218568AB9702ull, 0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull,
180         0xECDD4775619F1510ull, 0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull,
181         0xB5735C904C70A239ull, 0xD59E9E0BCBAADE14ull, 0xEECC86BC60622CA7ull});
182    std::vector<int> output(6);
183    {
184      absl::log_uniform_int_distribution<int32_t> dist(0, 256);
185      std::generate(std::begin(output), std::end(output),
186                    [&] { return dist(urbg); });
187      EXPECT_THAT(output, ElementsAre(256, 66, 4, 6, 57, 103));
188    }
189    urbg.reset();
190    {
191      absl::log_uniform_int_distribution<int32_t> dist(0, 256, 10);
192      std::generate(std::begin(output), std::end(output),
193                    [&] { return dist(urbg); });
194      EXPECT_THAT(output, ElementsAre(8, 4, 0, 0, 0, 69));
195    }
196  }
197  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.cpp</h3>
            <pre><code>1  #ifdef GCC_ATOMIC
2  bool TNEANetMP::HasFlag(const TGraphFlag& Flag) const {
3    return HasGraphFlag(TNEANetMP::TNet, Flag);
4  }
5  bool TNEANetMP::TNodeI::IsInNId(const int& NId) const {
6    const TNode& Node = NodeHI.GetDat();
7    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
8      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
9        return true;
10    }
11    return false;
12  }
13  bool TNEANetMP::TNodeI::IsOutNId(const int& NId) const {
14    const TNode& Node = NodeHI.GetDat();
15    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
16      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
17        return true;
18    }
19    return false;
20  }
21  void TNEANetMP::AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
22    Names = TVec<TStr>();
23    while (!NodeHI.IsEnd()) {
24      if (!NodeAttrIsDeleted(NId, NodeHI)) {
25        Names.Add(NodeHI.GetKey());
26      }
27      NodeHI++;
28    }
29  }
30  void TNEANetMP::AttrValueNI(const TInt& NId , TStrIntPrH::TIter NodeHI, TStrV& Values) const {
31    Values = TVec<TStr>();
32    while (!NodeHI.IsEnd()) {
33      if (!NodeAttrIsDeleted(NId, NodeHI)) {
34        Values.Add(GetNodeAttrValue(NId, NodeHI));
35      }
36      NodeHI++;
37    }
38  }
39  void TNEANetMP::IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
40    Names = TVec<TStr>();
41    while (!NodeHI.IsEnd()) {
42      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
43        Names.Add(NodeHI.GetKey());
44      }
45      NodeHI++;
46    }
47  }
48  void TNEANetMP::IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const {
49    Values = TVec<TInt>();
50    while (!NodeHI.IsEnd()) {
51      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
52        TInt val = this->VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
53        Values.Add(val);
54      }
55      NodeHI++;
56    }
57  }
58  void TNEANetMP::StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
59    Names = TVec<TStr>();
60    while (!NodeHI.IsEnd()) {
61      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
62        Names.Add(NodeHI.GetKey());
63      }
64      NodeHI++;
65    }
66  }
67  void TNEANetMP::StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const {
68    Values = TVec<TStr>();
69    while (!NodeHI.IsEnd()) {
70      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
71        TStr val = this->VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
72        Values.Add(val);
73      }
74      NodeHI++;
75    }
76  }
77  void TNEANetMP::FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
78    Names = TVec<TStr>();
79    while (!NodeHI.IsEnd()) {
80      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
81        Names.Add(NodeHI.GetKey());
82      }
83      NodeHI++;
84    }
85  }
86  void TNEANetMP::FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const {
87    Values = TVec<TFlt>();
88    while (!NodeHI.IsEnd()) {
89      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
90        TFlt val = (this->VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
91        Values.Add(val);
92      }
93      NodeHI++;
94    }
95  }
96  bool TNEANetMP::NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
97    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
98    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
99    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
100    return IntDel || StrDel || FltDel;
101  }
102  bool TNEANetMP::NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
103    return (NodeHI.GetDat().Val1 == IntType &&
104      GetIntAttrDefaultN(NodeHI.GetKey()) == this->VecOfIntVecsN.GetVal(
105      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
106  }
107  bool TNEANetMP::NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
108    return (NodeHI.GetDat().Val1 == StrType &&
109      GetStrAttrDefaultN(NodeHI.GetKey()) == this->VecOfStrVecsN.GetVal(
110      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
111  }
112  bool TNEANetMP::NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
113    return (NodeHI.GetDat().Val1 == FltType &&
114      GetFltAttrDefaultN(NodeHI.GetKey()) == this->VecOfFltVecsN.GetVal(
115      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
116  }
117  TStr TNEANetMP::GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
118    if (NodeHI.GetDat().Val1 == IntType) {
119      return (this->VecOfIntVecsN.GetVal(
120        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
121    } else if(NodeHI.GetDat().Val1 == StrType) {
122      return this->VecOfStrVecsN.GetVal(
123      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
124    } else if (NodeHI.GetDat().Val1 == FltType) {
125      return (this->VecOfFltVecsN.GetVal(
126        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
127    }
128    return TStr::GetNullStr();
129  }
130  void TNEANetMP::AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
131    Names = TVec<TStr>();
132    while (!EdgeHI.IsEnd()) {
133      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
134        Names.Add(EdgeHI.GetKey());
135      }
136      EdgeHI++;
137    }
138  }
139  void TNEANetMP::AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
140    Values = TVec<TStr>();
141    while (!EdgeHI.IsEnd()) {
142      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
143        Values.Add(GetNodeAttrValue(EId, EdgeHI));
144      }
145      EdgeHI++;
146    }
147  }
148  void TNEANetMP::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
149    Names = TVec<TStr>();
150    while (!EdgeHI.IsEnd()) {
151      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
152        Names.Add(EdgeHI.GetKey());
153      }
154      EdgeHI++;
155    }
156  }
157  void TNEANetMP::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const {
158    Values = TVec<TInt>();
159    while (!EdgeHI.IsEnd()) {
160      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
161        TInt val = (this->VecOfIntVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
162        Values.Add(val);
163      }
164      EdgeHI++;
165    }
166  }
167  void TNEANetMP::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
168    Names = TVec<TStr>();
169    while (!EdgeHI.IsEnd()) {
170      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
171        Names.Add(EdgeHI.GetKey());
172      }
173      EdgeHI++;
174    }
175  }
176  void TNEANetMP::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
177    Values = TVec<TStr>();
178    while (!EdgeHI.IsEnd()) {
179      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
180        TStr val = this->VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
181        Values.Add(val);
182      }
183      EdgeHI++;
184    }
185  }
186  void TNEANetMP::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
187    Names = TVec<TStr>();
188    while (!EdgeHI.IsEnd()) {
189      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
190        Names.Add(EdgeHI.GetKey());
191      }
192      EdgeHI++;
193    }
194  }
195  void TNEANetMP::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const {
196    Values = TVec<TFlt>();
197    while (!EdgeHI.IsEnd()) {
198      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
199        TFlt val = (this->VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
200        Values.Add(val);
201      }
202      EdgeHI++;
203    }
204  }
205  bool TNEANetMP::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
206    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
207    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
208    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
209    return IntDel || StrDel || FltDel;
210  }
211  bool TNEANetMP::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
212    return (EdgeHI.GetDat().Val1 == IntType &&
213      GetIntAttrDefaultE(EdgeHI.GetKey()) == this->VecOfIntVecsE.GetVal(
214      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
215  }
216  bool TNEANetMP::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
217    return (EdgeHI.GetDat().Val1 == StrType &&
218      GetStrAttrDefaultE(EdgeHI.GetKey()) == this->VecOfStrVecsE.GetVal(
219      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
220  }
221  bool TNEANetMP::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
222    return (EdgeHI.GetDat().Val1 == FltType &&
223      GetFltAttrDefaultE(EdgeHI.GetKey()) == this->VecOfFltVecsE.GetVal(
224      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
225  }
226  TStr TNEANetMP::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
227    if (EdgeHI.GetDat().Val1 == IntType) {
228      return (this->VecOfIntVecsE.GetVal(
229        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
230    } else if(EdgeHI.GetDat().Val1 == StrType) {
231      return this->VecOfStrVecsE.GetVal(
232      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
233    } else if (EdgeHI.GetDat().Val1 == FltType) {
234      return (this->VecOfFltVecsE.GetVal(
235        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
236    }
237    return TStr::GetNullStr();
238  }
239  int TNEANetMP::AddNode(int NId) {
240    int i;
241    if (NId == -1) {
242      NId = MxNId;  MxNId++;
243    } else {
244      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
245      MxNId = TMath::Mx(NId+1, MxNId());
246    }
247    NodeH.AddDat(NId, TNode(NId));
248    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
249      TVec<TInt>& IntVec = VecOfIntVecsN[i];
250      IntVec.Ins(NodeH.GetKeyId(NId), TInt::Mn);
251    }
252    TVec<TStr> DefIntVec = TVec<TStr>();
253    IntDefaultsN.GetKeyV(DefIntVec);
254    for (i = 0; i < DefIntVec.Len(); i++) {
255      TStr attr = DefIntVec[i];
256      TVec<TInt>& IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
257      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
258    }
259    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
260      TVec<TStr>& StrVec = VecOfStrVecsN[i];
261      StrVec.Ins(NodeH.GetKeyId(NId), TStr::GetNullStr());
262    }
263    TVec<TStr> DefStrVec = TVec<TStr>();
264    IntDefaultsN.GetKeyV(DefStrVec);
265    for (i = 0; i < DefStrVec.Len(); i++) {
266      TStr attr = DefStrVec[i];
267      TVec<TStr>& StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
268      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
269    }
270    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
271      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
272      FltVec.Ins(NodeH.GetKeyId(NId), TFlt::Mn);
273    }
274    TVec<TStr> DefFltVec = TVec<TStr>();
275    FltDefaultsN.GetKeyV(DefFltVec);
276    for (i = 0; i < DefFltVec.Len(); i++) {
277      TStr attr = DefFltVec[i];
278      TVec<TFlt>& FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
279      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
280    }
281    return NId;
282  }
283  void TNEANetMP::AddNodeWithEdges(const TInt& NId, TIntV& InEIdV, TIntV& OutEIdV) {
284    int NodeIdx = abs((NId.GetPrimHashCd()) % Reserved());
285    int NodeKeyId = NodeH.AddKey13(NodeIdx, NId);
286    MxNId = TMath::Mx(NId+1, MxNId());
287    NodeH[NodeKeyId] = TNode(NId);
288    NodeH[NodeKeyId].InEIdV.MoveFrom(InEIdV);
289    NodeH[NodeKeyId].OutEIdV.MoveFrom(OutEIdV);
290  }
291  int TNEANetMP::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
292    int i;
293    if (EId == -1) { EId = MxEId;  MxEId++; }
294    else { MxEId = TMath::Mx(EId+1, MxEId()); }
<span onclick='openModal()' class='match'>295    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
296    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
297    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
298    GetNode(SrcNId).OutEIdV.AddSorted(EId);
299    GetNode(DstNId).InEIdV.AddSorted(EId);
</span>300    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
301      TVec<TInt>& IntVec = VecOfIntVecsE[i];
302      IntVec.Ins(EdgeH.GetKeyId(EId), TInt::Mn);
303    }
304    TVec<TStr> DefIntVec = TVec<TStr>();
305    IntDefaultsE.GetKeyV(DefIntVec);
306    for (i = 0; i < DefIntVec.Len(); i++) {
307      TStr attr = DefIntVec[i];
308      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
309      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
310    }
311    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
312      TVec<TStr>& StrVec = VecOfStrVecsE[i];
313      StrVec.Ins(EdgeH.GetKeyId(EId), TStr::GetNullStr());
314    }
315    TVec<TStr> DefStrVec = TVec<TStr>();
316    IntDefaultsE.GetKeyV(DefStrVec);
317    for (i = 0; i < DefStrVec.Len(); i++) {
318      TStr attr = DefStrVec[i];
319      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
320      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
321    }
322    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
323      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
324      FltVec.Ins(EdgeH.GetKeyId(EId), TFlt::Mn);
325    }
326    TVec<TStr> DefFltVec = TVec<TStr>();
327    FltDefaultsE.GetKeyV(DefFltVec);
328    for (i = 0; i < DefFltVec.Len(); i++) {
329      TStr attr = DefFltVec[i];
330      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
331      FltVec[NodeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
332    }
333    return EId;
334  }
335  void TNEANetMP::AddEdgeUnchecked(const TInt& EId, const int SrcNId, const int DstNId) {
336    int Idx = abs((EId.GetPrimHashCd()) % ReservedE());
337    int KeyId = EdgeH.AddKey13(Idx, EId);
338    MxEId = TMath::Mx(EId+1, MxEId());
339    EdgeH[KeyId] = TEdge(EId, SrcNId, DstNId);
340  }
341  bool TNEANetMP::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
342    const TNode& SrcNode = GetNode(SrcNId);
343    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
344      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
345      if (DstNId == Edge.GetDstNId()) {
346        EId = Edge.GetId();
347        return true;
348      }
349    }
350    if (! IsDir) {
351      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
352        const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
353        if (DstNId == Edge.GetSrcNId()) {
354          EId = Edge.GetId();
355          return true;
356        }
357      }
358    }
359    return false;
360  }
361  void TNEANetMP::GetNIdV(TIntV& NIdV) const {
362    NIdV.Gen(GetNodes(), 0);
363    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
364      NIdV.Add(NodeH.GetKey(N));
365    }
366  }
367  void TNEANetMP::GetEIdV(TIntV& EIdV) const {
368    EIdV.Gen(GetEdges(), 0);
369    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
370      EIdV.Add(EdgeH.GetKey(E));
371    }
372  }
373  void TNEANetMP::Defrag(const bool& OnlyNodeLinks) {
374    #if 0
375    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
376      TNode& Node = NodeH[kid];
377      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
378    }
379    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
380    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
381    #endif
382  }
383  bool TNEANetMP::IsOk(const bool& ThrowExcept) const {
384    bool RetVal = true;
385    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
386      const TNode& Node = NodeH[N];
387      if (! Node.OutEIdV.IsSorted()) {
388        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
389        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
390      }
391      if (! Node.InEIdV.IsSorted()) {
392        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
393        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
394      }
395      int prevEId = -1;
396      for (int e = 0; e < Node.GetOutDeg(); e++) {
397        if (! IsEdge(Node.GetOutEId(e))) {
398          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
399          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
400        }
401        if (e > 0 && prevEId == Node.GetOutEId(e)) {
402          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
403          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
404        }
405        prevEId = Node.GetOutEId(e);
406      }
407      prevEId = -1;
408      for (int e = 0; e < Node.GetInDeg(); e++) {
409        if (! IsEdge(Node.GetInEId(e))) {
410        const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
411        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
412        }
413        if (e > 0 && prevEId == Node.GetInEId(e)) {
414          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
415          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
416        }
417        prevEId = Node.GetInEId(e);
418      }
419    }
420    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
421      const TEdge& Edge = EdgeH[E];
422      if (! IsNode(Edge.GetSrcNId())) {
423        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
424        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
425      }
426      if (! IsNode(Edge.GetDstNId())) {
427        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
428        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
429      }
430    }
431    return RetVal;
432  }
433  void TNEANetMP::Dump(FILE *OutF) const {
434    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
435    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
436    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Network: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
437    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
438      fprintf(OutF, "  %*d]\n", NodePlaces, NodeI.GetId());
439      TIntV IntAttrN;
440      IntAttrValueNI(NodeI.GetId(), IntAttrN);
441      fprintf(OutF, "    nai[%d]", IntAttrN.Len());
442      for (int i = 0; i < IntAttrN.Len(); i++) {
443        fprintf(OutF, " %*i", NodePlaces, IntAttrN[i]()); }
444      TStrV StrAttrN;
445      StrAttrValueNI(NodeI.GetId(), StrAttrN);
446      fprintf(OutF, "    nas[%d]", StrAttrN.Len());
447      for (int i = 0; i < StrAttrN.Len(); i++) {
448        fprintf(OutF, " %*s", NodePlaces, StrAttrN[i]()); }
449      TFltV FltAttrN;
450      FltAttrValueNI(NodeI.GetId(), FltAttrN);
451      fprintf(OutF, "    naf[%d]", FltAttrN.Len());
452      for (int i = 0; i < FltAttrN.Len(); i++) {
453        fprintf(OutF, " %*f", NodePlaces, FltAttrN[i]()); }
454      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
455      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
456        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
457      fprintf(OutF, "\n");
458      fprintf(OutF, "    out[%d]", NodeI.GetOutDeg());
459      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
460        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
461      fprintf(OutF, "\n");
462    }
463    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
464      fprintf(OutF, "  %*d]  %*d  ->  %*d", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
465      TIntV IntAttrE;
466      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
467      fprintf(OutF, "    eai[%d]", IntAttrE.Len());
468      for (int i = 0; i < IntAttrE.Len(); i++) {
469        fprintf(OutF, " %*i", EdgePlaces, IntAttrE[i]());
470      }
471      TStrV StrAttrE;
472      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
473      fprintf(OutF, "    eas[%d]", StrAttrE.Len());
474      for (int i = 0; i < StrAttrE.Len(); i++) {
475        fprintf(OutF, " %*s", EdgePlaces, StrAttrE[i]());
476      }
477      TFltV FltAttrE;
478      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
479      fprintf(OutF, "    eaf[%d]", FltAttrE.Len());
480      for (int i = 0; i < FltAttrE.Len(); i++) {
481        fprintf(OutF, " %*f", EdgePlaces, FltAttrE[i]());
482      }
483      fprintf(OutF, "\n");
484    }
485    fprintf(OutF, "\n");
486  }
487  int TNEANetMP::AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
488    int i;
489    TInt CurrLen;
490    if (!IsNode(NId)) {
491      return -1;
492    }
493    if (KeyToIndexTypeN.IsKey(attr)) {
494      TVec<TInt>& NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
495      NewVec[NodeH.GetKeyId(NId)] = value;
496    } else {
497      CurrLen = VecOfIntVecsN.Len();
498      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
499      TVec<TInt> NewVec = TVec<TInt>();
500      for (i = 0; i < MxNId; i++) {
501        NewVec.Ins(i, (TInt) TInt::Mn);
502      }
503      NewVec[NodeH.GetKeyId(NId)] = value;
504      VecOfIntVecsN.Add(NewVec);
505    }
506    return 0;
507  }
508  int TNEANetMP::AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr) {
509    int i;
510    TInt CurrLen;
511    if (!IsNode(NId)) {
512      return -1;
513    }
514    if (KeyToIndexTypeN.IsKey(attr)) {
515      TVec<TStr>& NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
516      NewVec[NodeH.GetKeyId(NId)] = value;
517    } else {
518      CurrLen = VecOfStrVecsN.Len();
519      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
520      TVec<TStr> NewVec = TVec<TStr>();
521      for (i = 0; i < MxNId; i++) {
522          NewVec.Ins(i, (TStr) TStr::GetNullStr() );
523      }
524      NewVec[NodeH.GetKeyId(NId)] = value;
525      VecOfStrVecsN.Add(NewVec);
526    }
527    return 0;
528  }
529  int TNEANetMP::AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
530    int i;
531    TInt CurrLen;
532    if (!IsNode(NId)) {
533      return -1;
534    }
535    if (KeyToIndexTypeN.IsKey(attr)) {
536      TVec<TFlt>& NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
537      NewVec[NodeH.GetKeyId(NId)] = value;
538    } else {
539      CurrLen = VecOfFltVecsN.Len();
540      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
541      TVec<TFlt> NewVec = TVec<TFlt>();
542      for (i = 0; i < MxNId; i++) {
543        NewVec.Ins(i, GetFltAttrDefaultN(attr));
544      }
545      NewVec[NodeH.GetKeyId(NId)] = value;
546      VecOfFltVecsN.Add(NewVec);
547    }
548    return 0;
549  }
550  int TNEANetMP::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
551    int i;
552    TInt CurrLen;
553    if (!IsEdge(EId)) {
554       return -1;
555    }
556    if (KeyToIndexTypeE.IsKey(attr)) {
557      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
558      NewVec[EdgeH.GetKeyId(EId)] = value;
559    } else {
560      CurrLen = VecOfIntVecsE.Len();
561      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
562      TVec<TInt> NewVec = TVec<TInt>();
563      for (i = 0; i < MxEId; i++) {
564        NewVec.Ins(i, (TInt) TInt::Mn);
565      }
566      NewVec[EdgeH.GetKeyId(EId)] = value;
567      VecOfIntVecsE.Add(NewVec);
568    }
569    return 0;
570  }
571  int TNEANetMP::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
572    int i;
573    TInt CurrLen;
574    if (!IsEdge(EId)) {
575       return -1;
576    }
577    if (KeyToIndexTypeE.IsKey(attr)) {
578      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
579      NewVec[EdgeH.GetKeyId(EId)] = value;
580    } else {
581      CurrLen = VecOfStrVecsE.Len();
582      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
583      TVec<TStr> NewVec = TVec<TStr>();
584      for (i = 0; i < MxEId; i++) {
585        NewVec.Ins(i, (TStr) TStr::GetNullStr());
586      }
587      NewVec[EdgeH.GetKeyId(EId)] = value;
588      VecOfStrVecsE.Add(NewVec);
589    }
590    return 0;
591  }
592  int TNEANetMP::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
593    int i;
594    TInt CurrLen;
595    if (!IsEdge(EId)) {
596       return -1;
597    }
598    if (KeyToIndexTypeE.IsKey(attr)) {
599      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
600      NewVec[EdgeH.GetKeyId(EId)] = value;
601    } else {
602      CurrLen = VecOfFltVecsE.Len();
603      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
604      TVec<TFlt> NewVec = TVec<TFlt>();
605      for (i = 0; i < MxEId; i++) {
606        NewVec.Ins(i, GetFltAttrDefaultE(attr));
607      }
608      NewVec[EdgeH.GetKeyId(EId)] = value;
609      VecOfFltVecsE.Add(NewVec);
610    }
611    return 0;
612  }
613  TVec<TFlt>& TNEANetMP::GetFltAttrVecE(const TStr& attr) {
614    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
615  }
616  int TNEANetMP::GetFltKeyIdE(const int& EId) {
617    return EdgeH.GetKeyId(EId);
618  }
619  TInt TNEANetMP::GetIntAttrDatN(const int& NId, const TStr& attr) {
620    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
621  }
622  TInt TNEANetMP::GetIntAttrIndDatN(const int& NId, const int& index) {
623    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
624  }
625  int TNEANetMP::GetIntAttrIndN(const TStr& attr) {
626    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
627  }
628  TStr TNEANetMP::GetStrAttrDatN(const int& NId, const TStr& attr) {
629    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
630  }
631  TFlt TNEANetMP::GetFltAttrDatN(const int& NId, const TStr& attr) {
632    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
633  }
634  TInt TNEANetMP::GetIntAttrDatE(const int& EId, const TStr& attr) {
635    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
636  }
637  TInt TNEANetMP::GetIntAttrIndDatE(const int& EId, const int& index) {
638    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
639  }
640  int TNEANetMP::GetIntAttrIndE(const TStr& attr) {
641    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
642  }
643  TStr TNEANetMP::GetStrAttrDatE(const int& EId, const TStr& attr) {
644    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
645  }
646  TFlt TNEANetMP::GetFltAttrDatE(const int& EId, const TStr& attr) {
647    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
648  }
649  int TNEANetMP::DelAttrDatN(const int& NId, const TStr& attr) {
650    TInt vecType = KeyToIndexTypeN(attr).Val1;
651    if (vecType == IntType) {
652      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
653    } else if (vecType == StrType) {
654      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
655    } else if (vecType == FltType) {
656      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
657    } else {
658      return -1;
659    }
660    return 0;
661  }
662  int TNEANetMP::DelAttrDatE(const int& EId, const TStr& attr) {
663    TInt vecType = KeyToIndexTypeE(attr).Val1;
664    if (vecType == IntType) {
665      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
666    } else if (vecType == StrType) {
667      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
668    } else if (vecType == FltType) {
669      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
670    } else {
671      return -1;
672    }
673    return 0;
674  }
675  int TNEANetMP::AddIntAttrN(const TStr& attr, TInt defaultValue){
676    int i;
677    TInt CurrLen;
678    TVec<TInt> NewVec;
679    CurrLen = VecOfIntVecsN.Len();
680    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
681    NewVec = TVec<TInt>();
682    for (i = 0; i < MxNId; i++) {
683      NewVec.Ins(i, defaultValue);
684    }
685    VecOfIntVecsN.Add(NewVec);
686    if (!IntDefaultsN.IsKey(attr)) {
687      IntDefaultsN.AddDat(attr, defaultValue);
688    } else {
689      return -1;
690    }
691    return 0;
692  }
693  int TNEANetMP::AddStrAttrN(const TStr& attr, TStr defaultValue) {
694    int i;
695    TInt CurrLen;
696    TVec<TStr> NewVec;
697    CurrLen = VecOfStrVecsN.Len();
698    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
699    NewVec = TVec<TStr>();
700    for (i = 0; i < MxNId; i++) {
701      NewVec.Ins(i, defaultValue);
702    }
703    VecOfStrVecsN.Add(NewVec);
704    if (!StrDefaultsN.IsKey(attr)) {
705      StrDefaultsN.AddDat(attr, defaultValue);
706    } else {
707      return -1;
708    }
709    return 0;
710  }
711  int TNEANetMP::AddFltAttrN(const TStr& attr, TFlt defaultValue) {
712    int i;
713    TInt CurrLen;
714    TVec<TFlt> NewVec;
715    CurrLen = VecOfStrVecsN.Len();
716    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
717    NewVec = TVec<TFlt>();
718    for (i = 0; i < MxNId; i++) {
719      NewVec.Ins(i, defaultValue);
720    }
721    VecOfFltVecsN.Add(NewVec);
722    if (!FltDefaultsN.IsKey(attr)) {
723      FltDefaultsN.AddDat(attr, defaultValue);
724    } else {
725      return -1;
726    }
727    return 0;
728  }
729  int TNEANetMP::AddIntAttrE(const TStr& attr, TInt defaultValue){
730    int i;
731    TInt CurrLen;
732    TVec<TInt> NewVec;
733    CurrLen = VecOfIntVecsE.Len();
734    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
735    NewVec = TVec<TInt>();
736    for (i = 0; i < MxEId; i++) {
737      NewVec.Ins(i, defaultValue);
738    }
739    VecOfIntVecsE.Add(NewVec);
740    if (!IntDefaultsE.IsKey(attr)) {
741      IntDefaultsE.AddDat(attr, defaultValue);
742    } else {
743      return -1;
744    }
745    return 0;
746  }
747  int TNEANetMP::AddStrAttrE(const TStr& attr, TStr defaultValue) {
748    int i;
749    TInt CurrLen;
750    TVec<TStr> NewVec;
751    CurrLen = VecOfStrVecsE.Len();
752    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
753    NewVec = TVec<TStr>();
754    for (i = 0; i < MxEId; i++) {
755      NewVec.Ins(i, defaultValue);
756    }
757    VecOfStrVecsE.Add(NewVec);
758    if (!StrDefaultsE.IsKey(attr)) {
759      StrDefaultsE.AddDat(attr, defaultValue);
760    } else {
761      return -1;
762    }
763    return 0;
764  }
765  int TNEANetMP::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
766    int i;
767    TInt CurrLen;
768    TVec<TFlt> NewVec;
769    CurrLen = VecOfStrVecsE.Len();
770    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
771    NewVec = TVec<TFlt>();
772    for (i = 0; i < MxEId; i++) {
773      NewVec.Ins(i, defaultValue);
774    }
775    VecOfFltVecsE.Add(NewVec);
776    if (!FltDefaultsE.IsKey(attr)) {
777      FltDefaultsE.AddDat(attr, defaultValue);
778    } else {
779      return -1;
780    }
781    return 0;
782  }
783  TFlt TNEANetMP::GetWeightOutEdges(const TNodeI& NI, const TStr& attr) {
784    TNode Node = GetNode(NI.GetId());
785    TIntV OutEIdV = Node.OutEIdV;
786    TFlt total = 0;
787    int len = Node.OutEIdV.Len();
788    for (int i = 0; i < len; i++) {
789      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
790    }
791    return total;
792  }
793  void TNEANetMP::GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) {
794    for (TEdgeI it = BegEI(); it < EndEI(); it++) {
795      int EId = it.GetId();
796      int SrcId = it.GetSrcNId();
797      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
798    }
799  }
800  bool TNEANetMP::IsFltAttrE(const TStr& attr) {
801    return (KeyToIndexTypeE.IsKey(attr) &&
802      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
803  }
804  bool TNEANetMP::IsIntAttrE(const TStr& attr) {
805    return (KeyToIndexTypeE.IsKey(attr) &&
806      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
807  }
808  bool TNEANetMP::IsStrAttrE(const TStr& attr) {
809    return (KeyToIndexTypeE.IsKey(attr) &&
810      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
811  }
812  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-log_uniform_int_distribution_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.cpp</div>
                </div>
                <div class="column column_space"><pre><code>34             param_type(0, 1),                             
35             param_type(0, 2),                             
36             param_type(0, 2, 10),                         
37             param_type(9, 32, 4),                         
38             param_type(1, 101, 10),                       
39             param_type(1, Limits::max() / 2),             
40             param_type(0, Limits::max() - 1),             
41             param_type(0, Limits::max(), 2),              
42             param_type(0, Limits::max(), 10),             
</pre></code></div>
                <div class="column column_space"><pre><code>295    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
296    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
297    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
298    GetNode(SrcNId).OutEIdV.AddSorted(EId);
299    GetNode(DstNId).InEIdV.AddSorted(EId);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    