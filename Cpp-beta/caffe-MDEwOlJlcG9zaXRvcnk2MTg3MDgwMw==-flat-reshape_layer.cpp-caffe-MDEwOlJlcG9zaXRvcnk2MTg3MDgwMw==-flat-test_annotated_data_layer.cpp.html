
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.566615620214396%, Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-reshape_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/layers/reshape_layer.hpp"
3  namespace caffe {
4  template <typename Dtype>
5  void ReshapeLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
6      const vector<Blob<Dtype>*>& top) {
7    CHECK_NE(top[0], bottom[0]) << this->type() << " Layer does not "
8        "allow in-place computation.";
9    const int ps = this->layer_param_.reshape_param().pixelshuffler();
10    if(ps == 1){
11      inferred_axis_ = -1;
12      copy_axes_.clear();
13      const BlobShape& top_blob_shape = this->layer_param_.reshape_param().shape();
14      const int top_num_axes = top_blob_shape.dim_size();
15      constant_count_ = 1;
16      for (int i = 0; i < top_num_axes; ++i) {
17        const int top_dim = top_blob_shape.dim(i);
18        if (top_dim == 0) {
19          copy_axes_.push_back(i);
20        } else if (top_dim == -1) {
21          CHECK_EQ(inferred_axis_, -1) << "new shape contains multiple "
22              << "-1 dims; at most a single (1) value of -1 may be specified";
23          inferred_axis_ = i;
24        } else {
25          constant_count_ *= top_dim;
26        }
27     }
28    }
29  }
30  template <typename Dtype>
31  void ReshapeLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
32      const vector<Blob<Dtype>*>& top) {
33    const int ps = this->layer_param_.reshape_param().pixelshuffler();   
34    if (ps ==1 ){
35          const int input_start_axis = this->layer_param_.reshape_param().axis();
36          const int start_axis = (input_start_axis >= 0) ? input_start_axis :
37              bottom[0]->num_axes() + input_start_axis + 1;
38          CHECK_GE(start_axis, 0) << "axis " << input_start_axis << " out of range";
39          CHECK_LE(start_axis, bottom[0]->num_axes()) << "axis " << input_start_axis
40              << " out of range for " << bottom[0]->num_axes() << "-D input blob";
41          const int num_axes = this->layer_param_.reshape_param().num_axes();
42          CHECK_GE(num_axes, -1) << "num_axes must be >= 0, or -1 for all";
43          const int end_axis =
44              (num_axes == -1) ? bottom[0]->num_axes() : (start_axis + num_axes);
45          CHECK_LE(end_axis, bottom[0]->num_axes())
46              << "end_axis = axis + num_axes is out of range";
47          const int num_axes_replaced = end_axis - start_axis;
48          const int num_axes_retained = bottom[0]->num_axes() - num_axes_replaced;
49          const BlobShape& top_blob_shape = this->layer_param_.reshape_param().shape();
50          const int num_new_axes = top_blob_shape.dim_size();
51          vector<int> top_shape(num_axes_retained + num_new_axes);
52          int top_shape_index = 0;
53          for (int i = 0; i < start_axis; ++i) {
54            top_shape[top_shape_index++] = bottom[0]->shape(i);
55          }
56          for (int i = 0; i < num_new_axes; ++i) {
57            top_shape[top_shape_index++] = top_blob_shape.dim(i);
58          }
59          for (int i = end_axis; i < bottom[0]->num_axes(); ++i) {
60            top_shape[top_shape_index++] = bottom[0]->shape(i);
61          }
62          CHECK_EQ(top_shape_index, top_shape.size());
63          for (int i = 0; i < copy_axes_.size(); ++i) {
64            const int copy_axis_index = copy_axes_[i];
65            CHECK_GT(bottom[0]->num_axes(), start_axis + copy_axis_index)
66                << "new shape contains a 0, but there was no corresponding bottom axis "
67                << "to copy";
68            top_shape[start_axis + copy_axis_index] =
69                bottom[0]->shape(start_axis + copy_axis_index);
70          }
71          if (inferred_axis_ >= 0) {
72            int explicit_count = constant_count_;
73            explicit_count *= bottom[0]->count(0, start_axis);
74            explicit_count *= bottom[0]->count(end_axis);
75            for (int i = 0; i < copy_axes_.size(); ++i) {
76              const int copy_axis_index = copy_axes_[i];
77              explicit_count *= top_shape[start_axis + copy_axis_index];
78            }
79            CHECK_EQ(0, bottom[0]->count() % explicit_count) << "bottom count ("
80                << bottom[0]->count() << ") must be divisible by the product of "
81                << "the specified dimensions (" << explicit_count << ")";
82            const int inferred_dim = bottom[0]->count() / explicit_count;
83            top_shape[start_axis + inferred_axis_] = inferred_dim;
84          }
85          top[0]->Reshape(top_shape);
86          CHECK_EQ(top[0]->count(), bottom[0]->count())
87              << "output count must match input count";
88          top[0]->ShareData(*bottom[0]);
89          top[0]->ShareDiff(*bottom[0]);
90    }
91    else {
92      vector<int> bottom_shape = bottom[0]->shape();
93      const int bn = bottom_shape[0];
94      const int bc = bottom_shape[1];
95      const int bh = bottom_shape[2];
96      const int bw = bottom_shape[3];
97      vector<int> top_shape(4);
98      top_shape[0] = bn;
99      top_shape[1] = bc/(ps * ps);
100      top_shape[2] = bh * ps;
101      top_shape[3] = bw * ps;
102      top[0]->Reshape(top_shape);
103      CHECK_EQ(top[0]->count(), bottom[0]->count())
104              << "output count must match input count";
105    }
106  }
107  template <typename Dtype>
108  void ReshapeLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
109        const vector<Blob<Dtype>*>& top){
110    const int ps = this->layer_param_.reshape_param().pixelshuffler();
111    if( ps == 1){}
112    else{
113      vector<int> bottom_shape = bottom[0]->shape();
114      const int bn = bottom_shape[0];
115      const int bc = bottom_shape[1];
116      const int bh = bottom_shape[2];
117      const int bw = bottom_shape[3];
118      vector<int> top_shape = top[0]->shape();
119      const int tc = top_shape[1];
120      const int th = top_shape[2];
121      const int tw = top_shape[3];
122      int test_r1 = bc/tc;
123      const int r = th / bh;
<span onclick='openModal()' class='match'>124      int test_r2 = r * r;
125      CHECK_EQ( test_r1, test_r2) << "Pixelshuffler output is illegal";
126      const Dtype* bottom_data = bottom[0]->cpu_data();
127      Dtype* top_data = top[0]->mutable_cpu_data();
128      #ifdef _OPENMP
129          #if defined(_MSC_EXTENSIONS)
130              #pragma omp parallel for
131          #else
132              #pragma omp parallel for collapse(2)
133          #endif
134      #endif
135      for(int n = 0; n < bn; n++) {
136        for(int c = 0; c < bc; c++) {
137          for(int h = 0; h < bh; h++) {
</span>138            for(int w = 0; w < bw; w++) {
139                int new_c = static_cast<int>(floor(c/(r*r)));
140                int new_h = h*r + (static_cast<int>(floor(c/r)))%r;
141                int new_w = w*r+ (c%(r*r))%r;
142                int top_index = n*(tc*th*tw)+ new_c*(th*tw)+ new_h*tw+ new_w;
143                int bottom_index = n*bc*bh*bw + c*(bh*bw) + h*bw + w;
144                top_data[top_index] = bottom_data[bottom_index];
145            }
146          }
147        }
148      }
149    }
150  }
151  template <typename Dtype>
152  void ReshapeLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
153        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom){
154    const int ps = this->layer_param_.reshape_param().pixelshuffler();
155    if( ps == 1){}
156    else{
157      vector<int> top_shape = top[0]->shape();
158      const int tn = top_shape[0];    
159      const int tc = top_shape[1];
160      const int th = top_shape[2];
161      const int tw = top_shape[3];
162      vector<int> bottom_shape = bottom[0]->shape();
163      const int bc = bottom_shape[1];
164      const int bh = bottom_shape[2];
165      const int bw = bottom_shape[3];
166      const int r = th / bh;
167      Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
168      const Dtype* top_diff = top[0]->cpu_diff();
169      #ifdef _OPENMP
170          #if defined(_MSC_EXTENSIONS)
171              #pragma omp parallel for
172          #else
173              #pragma omp parallel for collapse(2)
174          #endif
175      #endif
176      for(int n = 0; n < tn; n++) {
177        for(int c = 0; c < tc; c++) {
178          for(int h = 0; h < th; h++) {
179            for(int w = 0; w < tw; w++) {
180                int old_c = c*r*r + (h%r)*r + w%r;
181                int old_h = static_cast<int>(floor(h/r));
182                int old_w = static_cast<int>(floor(w/r));
183                int bottom_index = n*(bc*bh*bw)+ old_c*(bh*bw)+ old_h*bw+ old_w;
184                int top_index = n*(tc*th*tw)+ c*(th*tw)+ h*tw+ w;
185                bottom_diff[bottom_index] = top_diff[top_index];
186            }
187          }
188        }
189      }
190    }
191  }
192  INSTANTIATE_CLASS(ReshapeLayer);
193  REGISTER_LAYER_CLASS(Reshape);
194  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_annotated_data_layer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <algorithm>
3  #include <string>
4  #include <vector>
5  #include "boost/scoped_ptr.hpp"
6  #include "gtest/gtest.h"
7  #include "caffe/blob.hpp"
8  #include "caffe/common.hpp"
9  #include "caffe/filler.hpp"
10  #include "caffe/layers/annotated_data_layer.hpp"
11  #include "caffe/proto/caffe.pb.h"
12  #include "caffe/util/db.hpp"
13  #include "caffe/util/io.hpp"
14  #include "caffe/test/test_caffe_main.hpp"
15  namespace caffe {
16  using boost::scoped_ptr;
17  static bool kBoolChoices[] = {false, true};
18  static int kNumChoices = 2;
19  int OneBBoxNum(int n) {
20    int sum = 0;
21    for (int g = 0; g < n; ++g) {
22      sum += g;
23    }
24    return sum;
25  }
26  int BBoxNum(int n) {
27    int sum = 0;
28    for (int i = 0; i < n; ++i) {
29      for (int g = 0; g < i; ++g) {
30        sum += g;
31      }
32    }
33    return sum;
34  }
35  template <typename TypeParam>
36  class AnnotatedDataLayerTest : public MultiDeviceTest<TypeParam> {
37    typedef typename TypeParam::Dtype Dtype;
38   protected:
39    AnnotatedDataLayerTest()
40        : backend_(DataParameter_DB_LEVELDB),
41          blob_top_data_(new Blob<Dtype>()),
42          blob_top_label_(new Blob<Dtype>()),
43          seed_(1701),
44          num_(6),
45          channels_(2),
46          height_(10),
47          width_(10),
48          eps_(1e-6) {}
49    virtual void SetUp() {
50      spatial_dim_ = height_ * width_;
51      size_ = channels_ * spatial_dim_;
52      filename_.reset(new string());
53      GetTempDirname(filename_.get());
54      *filename_ += "/db";
55      blob_top_vec_.push_back(blob_top_data_);
56      blob_top_vec_.push_back(blob_top_label_);
57    }
58    void Fill(DataParameter_DB backend, bool unique_pixel, bool unique_annotation,
59              bool use_rich_annotation, AnnotatedDatum_AnnotationType type) {
60      backend_ = backend;
61      unique_pixel_ = unique_pixel;
62      unique_annotation_ = unique_annotation;
63      use_rich_annotation_ = use_rich_annotation;
64      type_ = type;
65      GetTempDirname(filename_.get());
66      LOG(INFO) << "Using temporary dataset " << *filename_;
67      scoped_ptr<db::DB> db(db::GetDB(backend));
68      db->Open(*filename_, db::NEW);
69      scoped_ptr<db::Transaction> txn(db->NewTransaction());
70      for (int i = 0; i < num_; ++i) {
71        AnnotatedDatum anno_datum;
72        Datum* datum = anno_datum.mutable_datum();
73        datum->set_channels(channels_);
74        datum->set_height(height_);
75        datum->set_width(width_);
76        std::string* data = datum->mutable_data();
77        for (int j = 0; j < size_; ++j) {
78          int elem = unique_pixel ? j : i;
79          data->push_back(static_cast<uint8_t>(elem));
80        }
81        if (use_rich_annotation) {
82          anno_datum.set_type(type);
83          for (int g = 0; g < i; ++g) {
84            AnnotationGroup* anno_group = anno_datum.add_annotation_group();
85            anno_group->set_group_label(g);
86            for (int a = 0; a < g; ++a) {
87              Annotation* anno = anno_group->add_annotation();
88              anno->set_instance_id(a);
89              if (type == AnnotatedDatum_AnnotationType_BBOX) {
90                NormalizedBBox* bbox = anno->mutable_bbox();
91                int b = unique_annotation ? a : g;
92                bbox->set_xmin(b*0.1);
93                bbox->set_ymin(b*0.1);
94                bbox->set_xmax(std::min(b*0.1 + 0.2, 1.0));
95                bbox->set_ymax(std::min(b*0.1 + 0.2, 1.0));
96                bbox->set_difficult(a % 2);
97              }
98            }
99          }
100        } else {
101          datum->set_label(i);
102        }
103        stringstream ss;
104        ss << i;
105        string out;
106        CHECK(anno_datum.SerializeToString(&out));
107        txn->Put(ss.str(), out);
108      }
109      txn->Commit();
110      db->Close();
111    }
112    void TestRead() {
113      LayerParameter param;
114      param.set_phase(TRAIN);
115      DataParameter* data_param = param.mutable_data_param();
116      data_param->set_batch_size(num_);
117      data_param->set_source(filename_->c_str());
118      data_param->set_backend(backend_);
119      const Dtype scale = 3;
120      TransformationParameter* transform_param =
121          param.mutable_transform_param();
122      transform_param->set_scale(scale);
123      AnnotatedDataLayer<Dtype> layer(param);
124      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
125      EXPECT_EQ(blob_top_data_->num(), num_);
126      EXPECT_EQ(blob_top_data_->channels(), channels_);
127      EXPECT_EQ(blob_top_data_->height(), height_);
128      EXPECT_EQ(blob_top_data_->width(), width_);
129      if (use_rich_annotation_) {
130        switch (type_) {
131          case AnnotatedDatum_AnnotationType_BBOX:
132            EXPECT_EQ(blob_top_label_->num(), 1);
133            EXPECT_EQ(blob_top_label_->channels(), 1);
134            EXPECT_EQ(blob_top_label_->height(), 1);
135            EXPECT_EQ(blob_top_label_->width(), 8);
136            break;
137          default:
138            LOG(FATAL) << "Unknown annotation type.";
139            break;
140        }
141      } else {
142        EXPECT_EQ(blob_top_label_->num(), num_);
143        EXPECT_EQ(blob_top_label_->channels(), 1);
144        EXPECT_EQ(blob_top_label_->height(), 1);
145        EXPECT_EQ(blob_top_label_->width(), 1);
146      }
147      for (int iter = 0; iter < 5; ++iter) {
148        layer.Forward(blob_bottom_vec_, blob_top_vec_);
149        const Dtype* label_data = blob_top_label_->cpu_data();
150        int cur_bbox = 0;
151        for (int i = 0; i < num_; ++i) {
152          if (use_rich_annotation_) {
153            if (type_ == AnnotatedDatum_AnnotationType_BBOX) {
154              EXPECT_EQ(blob_top_label_->num(), 1);
155              EXPECT_EQ(blob_top_label_->channels(), 1);
156              EXPECT_EQ(blob_top_label_->height(), BBoxNum(num_));
157              EXPECT_EQ(blob_top_label_->width(), 8);
158              for (int g = 0; g < i; ++g) {
159                for (int a = 0; a < g; ++a) {
160                  EXPECT_EQ(i, label_data[cur_bbox*8]);
161                  EXPECT_EQ(g, label_data[cur_bbox*8+1]);
162                  EXPECT_EQ(a, label_data[cur_bbox*8+2]);
163                  int b = unique_annotation_ ? a : g;
164                  for (int p = 3; p < 5; ++p) {
165                    EXPECT_NEAR(b*0.1, label_data[cur_bbox*8+p], this->eps_);
166                  }
167                  for (int p = 5; p < 7; ++p) {
168                    EXPECT_NEAR(std::min(b*0.1 + 0.2, 1.0),
169                              label_data[cur_bbox*8+p], this->eps_);
170                  }
171                  EXPECT_EQ(a % 2, label_data[cur_bbox*8+7]);
172                  cur_bbox++;
173                }
174              }
175            } else {
176              LOG(FATAL) << "Unknown annotation type.";
177            }
178          } else {
179            EXPECT_EQ(i, label_data[i]);
180          }
181        }
182        for (int i = 1; i < num_; ++i) {
183          for (int j = 0; j < size_; ++j) {
184            EXPECT_EQ(scale * (unique_pixel_ ? j : i),
185                      blob_top_data_->cpu_data()[i * size_ + j])
186                << "debug: iter " << iter << " i " << i << " j " << j;
187          }
188        }
189      }
190    }
191    void TestReshape(DataParameter_DB backend, bool unique_pixel,
192                     bool unique_annotation, bool use_rich_annotation,
193                     AnnotatedDatum_AnnotationType type) {
194      GetTempDirname(filename_.get());
195      LOG(INFO) << "Using temporary dataset " << *filename_;
196      scoped_ptr<db::DB> db(db::GetDB(backend));
197      db->Open(*filename_, db::NEW);
198      scoped_ptr<db::Transaction> txn(db->NewTransaction());
199      for (int i = 0; i < num_; ++i) {
200        AnnotatedDatum anno_datum;
201        Datum* datum = anno_datum.mutable_datum();
202        datum->set_channels(channels_);
203        datum->set_height(i % 2 + 1);
204        datum->set_width(i % 4 + 1);
205        std::string* data = datum->mutable_data();
206        const int data_size =
207            datum->channels() * datum->height() * datum->width();
208        for (int j = 0; j < data_size; ++j) {
209          data->push_back(static_cast<uint8_t>(j));
210        }
211        if (use_rich_annotation) {
212          anno_datum.set_type(type);
213          for (int g = 0; g < i; ++g) {
214            AnnotationGroup* anno_group = anno_datum.add_annotation_group();
215            anno_group->set_group_label(g);
216            for (int a = 0; a < g; ++a) {
217              Annotation* anno = anno_group->add_annotation();
218              anno->set_instance_id(a);
219              if (type == AnnotatedDatum_AnnotationType_BBOX) {
220                NormalizedBBox* bbox = anno->mutable_bbox();
221                int b = unique_annotation ? a : g;
222                bbox->set_xmin(b*0.1);
223                bbox->set_ymin(b*0.1);
224                bbox->set_xmax(std::min(b*0.1 + 0.2, 1.0));
225                bbox->set_ymax(std::min(b*0.1 + 0.2, 1.0));
226                bbox->set_difficult(a % 2);
227              }
228            }
229          }
230        } else {
231          datum->set_label(i);
232        }
233        stringstream ss;
234        ss << i;
235        string out;
236        CHECK(anno_datum.SerializeToString(&out));
237        txn->Put(ss.str(), out);
238      }
239      txn->Commit();
240      db->Close();
241      LayerParameter param;
242      param.set_phase(TEST);
243      DataParameter* data_param = param.mutable_data_param();
244      data_param->set_batch_size(1);
245      data_param->set_source(filename_->c_str());
246      data_param->set_backend(backend);
247      AnnotatedDataLayer<Dtype> layer(param);
248      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
249      EXPECT_EQ(blob_top_data_->num(), 1);
250      EXPECT_EQ(blob_top_data_->channels(), channels_);
251      if (use_rich_annotation) {
252        switch (type) {
253          case AnnotatedDatum_AnnotationType_BBOX:
254            EXPECT_EQ(blob_top_label_->num(), 1);
255            EXPECT_EQ(blob_top_label_->channels(), 1);
256            EXPECT_EQ(blob_top_label_->height(), 1);
257            EXPECT_EQ(blob_top_label_->width(), 8);
258            break;
259          default:
260            LOG(FATAL) << "Unknown annotation type.";
261            break;
262        }
263      } else {
264        EXPECT_EQ(blob_top_label_->num(), 1);
265        EXPECT_EQ(blob_top_label_->channels(), 1);
266        EXPECT_EQ(blob_top_label_->height(), 1);
267        EXPECT_EQ(blob_top_label_->width(), 1);
268      }
269      for (int iter = 0; iter < 3; ++iter) {
270        layer.Forward(blob_bottom_vec_, blob_top_vec_);
271        EXPECT_EQ(blob_top_data_->height(), iter % 2 + 1);
272        EXPECT_EQ(blob_top_data_->width(), iter % 4 + 1);
273        const Dtype* label_data = blob_top_label_->cpu_data();
274        if (use_rich_annotation) {
275          if (type == AnnotatedDatum_AnnotationType_BBOX) {
276            if (iter <= 1) {
277              EXPECT_EQ(blob_top_label_->num(), 1);
278              EXPECT_EQ(blob_top_label_->channels(), 1);
279              EXPECT_EQ(blob_top_label_->height(), 1);
280              EXPECT_EQ(blob_top_label_->width(), 8);
281              for (int i = 0; i < 8; ++i) {
282                EXPECT_NEAR(label_data[i], -1, this->eps_);
283              }
284            } else {
285              int cur_bbox = 0;
286              EXPECT_EQ(blob_top_label_->num(), 1);
287              EXPECT_EQ(blob_top_label_->channels(), 1);
288              EXPECT_EQ(blob_top_label_->height(), OneBBoxNum(iter));
289              EXPECT_EQ(blob_top_label_->width(), 8);
290              for (int g = 0; g < iter; ++g) {
291                for (int a = 0; a < g; ++a) {
292                  EXPECT_EQ(0, label_data[cur_bbox*8]);
293                  EXPECT_EQ(g, label_data[cur_bbox*8+1]);
294                  EXPECT_EQ(a, label_data[cur_bbox*8+2]);
295                  int b = unique_annotation ? a : g;
296                  for (int p = 3; p < 5; ++p) {
297                    EXPECT_NEAR(b*0.1, label_data[cur_bbox*8+p], this->eps_);
298                  }
299                  for (int p = 5; p < 7; ++p) {
300                    EXPECT_NEAR(std::min(b*0.1 + 0.2, 1.0),
301                              label_data[cur_bbox*8+p], this->eps_);
302                  }
303                  EXPECT_EQ(a % 2, label_data[cur_bbox*8+7]);
304                  cur_bbox++;
305                }
306              }
307            }
308          } else {
309            LOG(FATAL) << "Unknown annotation type.";
310          }
311        } else {
312          EXPECT_EQ(iter, label_data[0]);
313        }
<span onclick='openModal()' class='match'>314        const int channels = blob_top_data_->channels();
315        const int height = blob_top_data_->height();
316        const int width = blob_top_data_->width();
317        for (int c = 0; c < channels; ++c) {
318          for (int h = 0; h < height; ++h) {
319            for (int w = 0; w < width; ++w) {
</span>320              const int idx = (c * height + h) * width + w;
321              EXPECT_EQ(idx, static_cast<int>(blob_top_data_->cpu_data()[idx]))
322                  << "debug: iter " << iter << " c " << c
323                  << " h " << h << " w " << w;
324            }
325          }
326        }
327      }
328    }
329    void TestReadCrop(Phase phase) {
330      const Dtype scale = 3;
331      LayerParameter param;
332      param.set_phase(phase);
333      Caffe::set_random_seed(1701);
334      DataParameter* data_param = param.mutable_data_param();
335      data_param->set_batch_size(num_);
336      data_param->set_source(filename_->c_str());
337      data_param->set_backend(backend_);
338      TransformationParameter* transform_param =
339          param.mutable_transform_param();
340      transform_param->set_scale(scale);
341      transform_param->set_crop_size(1);
342      AnnotatedDataLayer<Dtype> layer(param);
343      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
344      EXPECT_EQ(blob_top_data_->num(), num_);
345      EXPECT_EQ(blob_top_data_->channels(), channels_);
346      EXPECT_EQ(blob_top_data_->height(), 1);
347      EXPECT_EQ(blob_top_data_->width(), 1);
348      EXPECT_EQ(blob_top_label_->num(), num_);
349      EXPECT_EQ(blob_top_label_->channels(), 1);
350      EXPECT_EQ(blob_top_label_->height(), 1);
351      EXPECT_EQ(blob_top_label_->width(), 1);
352      for (int iter = 0; iter < 5; ++iter) {
353        layer.Forward(blob_bottom_vec_, blob_top_vec_);
354        for (int i = 0; i < num_; ++i) {
355          EXPECT_EQ(i, blob_top_label_->cpu_data()[i]);
356        }
357        int num_with_center_value = 0;
358        for (int i = 0; i < num_; ++i) {
359          for (int j = 0; j < channels_; ++j) {
360            const Dtype center_value =
361                scale * ((ceil(height_ / 2.0) - 1) * width_ +
362                         ceil(width_ / 2.0) - 1 + j * spatial_dim_);
363            num_with_center_value +=
364                (center_value == blob_top_data_->cpu_data()[i * 2 + j]);
365            if (phase == caffe::TEST) {
366              EXPECT_EQ(center_value,
367                        this->blob_top_data_->cpu_data()[i * channels_ + j])
368                  << "debug: iter " << iter << " i " << i << " j " << j;
369            }
370          }
371        }
372        if (phase == caffe::TRAIN) {
373          EXPECT_LT(num_with_center_value, 10);
374        }
375      }
376    }
377    void TestReadCropTrainSequenceSeeded() {
378      LayerParameter param;
379      param.set_phase(TRAIN);
380      DataParameter* data_param = param.mutable_data_param();
381      data_param->set_batch_size(num_);
382      data_param->set_source(filename_->c_str());
383      data_param->set_backend(backend_);
384      TransformationParameter* transform_param =
385          param.mutable_transform_param();
386      transform_param->set_crop_size(1);
387      transform_param->set_mirror(true);
388      Caffe::set_random_seed(seed_);
389      vector<vector<Dtype> > crop_sequence;
390      {
391        AnnotatedDataLayer<Dtype> layer1(param);
392        layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
393        for (int iter = 0; iter < 2; ++iter) {
394          layer1.Forward(blob_bottom_vec_, blob_top_vec_);
395          for (int i = 0; i < num_; ++i) {
396            EXPECT_EQ(i, blob_top_label_->cpu_data()[i]);
397          }
398          vector<Dtype> iter_crop_sequence;
399          for (int i = 0; i < num_; ++i) {
400            for (int j = 0; j < channels_; ++j) {
401              iter_crop_sequence.push_back(
402                  blob_top_data_->cpu_data()[i * channels_ + j]);
403            }
404          }
405          crop_sequence.push_back(iter_crop_sequence);
406        }
407      }  
408      Caffe::set_random_seed(seed_);
409      AnnotatedDataLayer<Dtype> layer2(param);
410      layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
411      for (int iter = 0; iter < 2; ++iter) {
412        layer2.Forward(blob_bottom_vec_, blob_top_vec_);
413        for (int i = 0; i < num_; ++i) {
414          EXPECT_EQ(i, blob_top_label_->cpu_data()[i]);
415        }
416        for (int i = 0; i < num_; ++i) {
417          for (int j = 0; j < channels_; ++j) {
418            EXPECT_EQ(crop_sequence[iter][i * channels_ + j],
419                      blob_top_data_->cpu_data()[i * channels_ + j])
420                << "debug: iter " << iter << " i " << i << " j " << j;
421          }
422        }
423      }
424    }
425    void TestReadCropTrainSequenceUnseeded() {
426      LayerParameter param;
427      param.set_phase(TRAIN);
428      DataParameter* data_param = param.mutable_data_param();
429      data_param->set_batch_size(num_);
430      data_param->set_source(filename_->c_str());
431      data_param->set_backend(backend_);
432      TransformationParameter* transform_param =
433          param.mutable_transform_param();
434      transform_param->set_crop_size(1);
435      transform_param->set_mirror(true);
436      Caffe::set_random_seed(seed_);
437      srand(seed_);
438      vector<vector<Dtype> > crop_sequence;
439      {
440        AnnotatedDataLayer<Dtype> layer1(param);
441        layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
442        for (int iter = 0; iter < 2; ++iter) {
443          layer1.Forward(blob_bottom_vec_, blob_top_vec_);
444          for (int i = 0; i < num_; ++i) {
445            EXPECT_EQ(i, blob_top_label_->cpu_data()[i]);
446          }
447          vector<Dtype> iter_crop_sequence;
448          for (int i = 0; i < num_; ++i) {
449            for (int j = 0; j < channels_; ++j) {
450              iter_crop_sequence.push_back(
451                  blob_top_data_->cpu_data()[i * channels_ + j]);
452            }
453          }
454          crop_sequence.push_back(iter_crop_sequence);
455        }
456      }  
457      srand(seed_);
458      AnnotatedDataLayer<Dtype> layer2(param);
459      layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
460      for (int iter = 0; iter < 2; ++iter) {
461        layer2.Forward(blob_bottom_vec_, blob_top_vec_);
462        for (int i = 0; i < num_; ++i) {
463          EXPECT_EQ(i, blob_top_label_->cpu_data()[i]);
464        }
465        int num_sequence_matches = 0;
466        for (int i = 0; i < num_; ++i) {
467          for (int j = 0; j < channels_; ++j) {
468            num_sequence_matches +=
469                (crop_sequence[iter][i * channels_ + j] ==
470                 blob_top_data_->cpu_data()[i * channels_ + j]);
471          }
472        }
473        EXPECT_LT(num_sequence_matches, num_ * channels_);
474      }
475    }
476    virtual ~AnnotatedDataLayerTest() {
477      delete blob_top_data_;
478      delete blob_top_label_;
479    }
480    DataParameter_DB backend_;
481    shared_ptr<string> filename_;
482    Blob<Dtype>* const blob_top_data_;
483    Blob<Dtype>* const blob_top_label_;
484    vector<Blob<Dtype>*> blob_bottom_vec_;
485    vector<Blob<Dtype>*> blob_top_vec_;
486    int seed_;
487    int num_;
488    int channels_;
489    int height_;
490    int width_;
491    Dtype eps_;
492    int spatial_dim_;
493    int size_;
494    bool unique_pixel_;
495    bool unique_annotation_;
496    bool use_rich_annotation_;
497    AnnotatedDatum_AnnotationType type_;
498  };
499  TYPED_TEST_CASE(AnnotatedDataLayerTest, TestDtypesAndDevices);
500  #ifdef USE_LEVELDB
501  TYPED_TEST(AnnotatedDataLayerTest, TestReadLevelDB) {
502    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
503    for (int p = 0; p < kNumChoices; ++p) {
504      bool unique_pixel = kBoolChoices[p];
505      for (int r = 0; r < kNumChoices; ++r) {
506        bool use_rich_annotation = kBoolChoices[r];
507        for (int a = 0; a < kNumChoices; ++a) {
508          if (!use_rich_annotation) {
509            continue;
510          }
511          bool unique_annotation = kBoolChoices[a];
512          this->Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
513                     use_rich_annotation, type);
514          this->TestRead();
515        }
516      }
517    }
518  }
519  TYPED_TEST(AnnotatedDataLayerTest, TestReshapeLevelDB) {
520    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
521    for (int p = 0; p < kNumChoices; ++p) {
522      bool unique_pixel = kBoolChoices[p];
523      for (int r = 0; r < kNumChoices; ++r) {
524        bool use_rich_annotation = kBoolChoices[r];
525        for (int a = 0; a < kNumChoices; ++a) {
526          if (!use_rich_annotation) {
527            continue;
528          }
529          bool unique_annotation = kBoolChoices[a];
530          this->TestReshape(DataParameter_DB_LEVELDB, unique_pixel,
531                            unique_annotation, use_rich_annotation, type);
532        }
533      }
534    }
535  }
536  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainLevelDB) {
537    const bool unique_pixel = true;  
538    const bool unique_annotation = false;  
539    const bool use_rich_annotation = false;
540    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
541    this->Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
542               use_rich_annotation, type);
543    this->TestReadCrop(TRAIN);
544  }
545  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceSeededLevelDB) {
546    const bool unique_pixel = true;  
547    const bool unique_annotation = false;  
548    const bool use_rich_annotation = false;
549    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
550    this->Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
551               use_rich_annotation, type);
552    this->TestReadCropTrainSequenceSeeded();
553  }
554  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceUnseededLevelDB) {
555    const bool unique_pixel = true;  
556    const bool unique_annotation = false;  
557    const bool use_rich_annotation = false;
558    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
559    this->Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
560               use_rich_annotation, type);
561    this->TestReadCropTrainSequenceUnseeded();
562  }
563  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTestLevelDB) {
564    const bool unique_pixel = true;  
565    const bool unique_annotation = false;  
566    const bool use_rich_annotation = false;
567    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
568    this->Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
569               use_rich_annotation, type);
570    this->TestReadCrop(TEST);
571  }
572  #endif  
573  #ifdef USE_LMDB
574  TYPED_TEST(AnnotatedDataLayerTest, TestReadLMDB) {
575    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
576    for (int p = 0; p < kNumChoices; ++p) {
577      bool unique_pixel = kBoolChoices[p];
578      for (int r = 0; r < kNumChoices; ++r) {
579        bool use_rich_annotation = kBoolChoices[r];
580        for (int a = 0; a < kNumChoices; ++a) {
581          if (!use_rich_annotation) {
582            continue;
583          }
584          bool unique_annotation = kBoolChoices[a];
585          this->Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
586                     use_rich_annotation, type);
587          this->TestRead();
588        }
589      }
590    }
591  }
592  TYPED_TEST(AnnotatedDataLayerTest, TestReshapeLMDB) {
593    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
594    for (int p = 0; p < kNumChoices; ++p) {
595      bool unique_pixel = kBoolChoices[p];
596      for (int r = 0; r < kNumChoices; ++r) {
597        bool use_rich_annotation = kBoolChoices[r];
598        for (int a = 0; a < kNumChoices; ++a) {
599          if (!use_rich_annotation) {
600            continue;
601          }
602          bool unique_annotation = kBoolChoices[a];
603          this->TestReshape(DataParameter_DB_LMDB, unique_pixel,
604                            unique_annotation, use_rich_annotation, type);
605        }
606      }
607    }
608  }
609  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainLMDB) {
610    const bool unique_pixel = true;  
611    const bool unique_annotation = false;  
612    const bool use_rich_annotation = false;
613    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
614    this->Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
615               use_rich_annotation, type);
616    this->TestReadCrop(TRAIN);
617  }
618  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceSeededLMDB) {
619    const bool unique_pixel = true;  
620    const bool unique_annotation = false;  
621    const bool use_rich_annotation = false;
622    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
623    this->Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
624               use_rich_annotation, type);
625    this->TestReadCropTrainSequenceSeeded();
626  }
627  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceUnseededLMDB) {
628    const bool unique_pixel = true;  
629    const bool unique_annotation = false;  
630    const bool use_rich_annotation = false;
631    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
632    this->Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
633               use_rich_annotation, type);
634    this->TestReadCropTrainSequenceUnseeded();
635  }
636  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTestLMDB) {
637    const bool unique_pixel = true;  
638    const bool unique_annotation = false;  
639    const bool use_rich_annotation = false;
640    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
641    this->Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
642               use_rich_annotation, type);
643    this->TestReadCrop(TEST);
644  }
645  #endif  
646  }  
647  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-reshape_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_annotated_data_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>124      int test_r2 = r * r;
125      CHECK_EQ( test_r1, test_r2) << "Pixelshuffler output is illegal";
126      const Dtype* bottom_data = bottom[0]->cpu_data();
127      Dtype* top_data = top[0]->mutable_cpu_data();
128      #ifdef _OPENMP
129          #if defined(_MSC_EXTENSIONS)
130              #pragma omp parallel for
131          #else
132              #pragma omp parallel for collapse(2)
133          #endif
134      #endif
135      for(int n = 0; n < bn; n++) {
136        for(int c = 0; c < bc; c++) {
137          for(int h = 0; h < bh; h++) {
</pre></code></div>
                <div class="column column_space"><pre><code>314        const int channels = blob_top_data_->channels();
315        const int height = blob_top_data_->height();
316        const int width = blob_top_data_->width();
317        for (int c = 0; c < channels; ++c) {
318          for (int h = 0; h < height; ++h) {
319            for (int w = 0; w < width; ++w) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    