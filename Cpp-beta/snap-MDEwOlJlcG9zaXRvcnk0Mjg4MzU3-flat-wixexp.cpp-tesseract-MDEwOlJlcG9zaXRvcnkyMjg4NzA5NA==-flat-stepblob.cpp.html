
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4581005586592175%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wixexp.cpp</h3>
            <pre><code>1  class EWixExp{
2  private:
3    TStr ErrMsg;
4  public:
5    EWixExp(const TWixExp);
6    EWixExp(const TStr& _ErrMsg):
7      ErrMsg(_ErrMsg){}
8    EWixExp& operator=(const EWixExp& E){
9      ErrMsg=E.ErrMsg; return *this;}
10    TStr GetErrMsg() const {return ErrMsg;}
11  };
12  void TWixExpLxChDef::SetChTy(const TWixExpLxChTy& ChTy, const TStr& Str){
13    for (int ChN=0; ChN<Str.Len(); ChN++){ChTyV[Str[ChN]-TCh::Mn]=TInt(ChTy);}}
14  TWixExpLxChDef::TWixExpLxChDef():
15    ChTyV(TCh::Vals){
16    ChTyV.PutAll(TInt(welctAlpha));
17    for (char Ch=TCh::NullCh; Ch<=' '; Ch++){SetChTy(welctSpace, TStr(Ch));}
18    SetChTy(welctNum, "0123456789");
19    SetChTy(welctSym, "&|!()\"+-*:");
20    SetChTy(welctEof, TStr(TCh::EofCh));
21  }
22  TWixExpKwMap::TWixExpKwMap():
23    StrToKwH(20){
24    StrToKwH.AddDat("domain", wekDomain);
25    StrToKwH.AddDat("depth", wekDepth);
26    StrToKwH.AddDat("feature", wekFeature);
27    StrToKwH.AddDat("outgoingurl", wekOutgoingUrl);
28    StrToKwH.AddDat("title", wekTitle);
29    StrToKwH.AddDat("after", wekAfter);
30    StrToKwH.AddDat("before", wekBefore);
31    StrToKwH.AddDat("within", wekWithin);
32  }
33  bool TWixExpKwMap::IsExpKw(const TStr& ExpKwStr, TWixExpKw& ExpKw){
34    int KeyId=StrToKwH.GetKeyId(ExpKwStr);
35    if (KeyId==-1){return false;}
36    else {ExpKw=TWixExpKw(int(StrToKwH[KeyId])); return true;}
37  }
38  TWixExpLxChDef TWixExpLx::ChDef;
39  TWixExpLx::TWixExpLx(const TStr& ExpStr):
40    SIn(TStrIn::New(ExpStr)), Ch(' '),  Sym(wesyUndef), Str(){
41  }
42  TWixExpLxSym TWixExpLx::GetSym(const TFSet& Expect){
43    Str.Clr();
44    while (ChDef.IsSpace(Ch)){GetCh();}
45    if (Expect.In(wesyNum)){
46      if (!ChDef.IsNum(Ch)){throw EWixExp("Number expected.");}
47      Sym=wesyNum;
48      do {Str.AddCh(Ch); GetCh();} while (ChDef.IsNum(Ch));
49    } else {
50      switch (ChDef.GetChTy(Ch)){
51        case welctAlpha:
52        case welctNum:
53          do {Str.AddCh(Ch); GetCh();} while (ChDef.IsAlNum(Ch));
54          if (Str=="OR"){Sym=wesyOr;}
55          else if (Str=="AND"){Sym=wesyAnd;}
56          else if (Str=="NOT"){Sym=wesyNot;}
57          else {Sym=wesyWord;}
58          break;
59        case welctSym:
60          Str.AddCh(Ch);
61          switch (Ch){
62            case ':': Sym=wesyColon; break;
63            case '(': Sym=wesyLParen; break;
64            case ')': Sym=wesyRParen; break;
65            case '|': Sym=wesyOr; break;
66            case '&': Sym=wesyAnd; break;
67            case '!': Sym=wesyNot; break;
68            case '+': Sym=wesyIncl; break;
69            case '-': Sym=wesyExcl; break;
70            case '*': Sym=wesyWCard; break;
71            default: Sym=wesySSym;
72          }
73          GetCh();
74          break;
75        case welctEof: Sym=wesyEof; break;
76        default: Sym=wesyUndef; GetCh();
77      }
78    }
79    if ((!Expect.In(Sym))&&(!Expect.Empty())){
80      if (Sym==wesyEof){
81        throw EWixExp("Unexpected end of expression.");
82      } else {
83        throw EWixExp("Unexpected symbol.");
84      }
85    }
86    return Sym;
87  }
88  PWixExpDocIdSet TWixExpDocIdSet::AndDocSet(const PWixExpDocIdSet& DocSet){
89    PWixExpDocIdSet DstDocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet());
90    TBlobPtV& V1=DocIdV;
91    TBlobPtV& V2=DocSet->DocIdV;
92    TBlobPtV& DstV=DstDocIdSet->DocIdV;
93    int N1=0; int N2=0;
94    while ((N1<V1.Len())&&(N2<V2.Len())){
95      TBlobPt& Val1=V1[N1];
96      while ((N2<V2.Len())&&(Val1>V2[N2])){
97        N2++;}
98      if ((N2<V2.Len())&&(Val1==V2[N2])){
99        TBlobPt Val(Val1); Val.MergeFlags(V2[N2]);
100        DstV.Add(Val); N2++;
101      }
102      N1++;
103    }
104    return DstDocIdSet;
105  }
106  PWixExpDocIdSet TWixExpDocIdSet::OrDocSet(const PWixExpDocIdSet& DocSet){
107    PWixExpDocIdSet DstDocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet());
108    TBlobPtV& V1=DocIdV;
109    TBlobPtV& V2=DocSet->DocIdV;
110    TBlobPtV& DstV=DstDocIdSet->DocIdV;
111    int N1=0; int N2=0;
112    while ((N1<V1.Len())&&(N2<V2.Len())){
113      TBlobPt& Val1=V1[N1];
114      TBlobPt& Val2=V2[N2];
115      if (Val1<Val2){DstV.Add(Val1); N1++;}
116      else if (Val1>Val2){DstV.Add(Val2); N2++;}
117      else {TBlobPt Val(Val1); Val.MergeFlags(Val2); DstV.Add(Val); N1++; N2++;}
118    }
119    for (int RestN1=N1; RestN1<V1.Len(); RestN1++){DstV.Add(V1[RestN1]);}
<span onclick='openModal()' class='match'>120    for (int RestN2=N2; RestN2<V2.Len(); RestN2++){DstV.Add(V2[RestN2]);}
121    return DstDocIdSet;
122  }
123  TWixExpItem::TWixExpItem(const TWixExpItemType& _Type,
124   const PWixExpItem& ExpItem1, const PWixExpItem& ExpItem2):
</span>125    Type(_Type), ExpItemV(), WordStrV(){
126    IAssert(
127     (Type==weitOr)||(Type==weitAnd)||(Type==weitNot)||
128     (Type==weitIncl)||(Type==weitExcl)||(Type==weitWCard));
129    if (Type==weitWCard){
130      IAssert(ExpItem1->GetType()==weitWord);
131      IAssert(ExpItem2.Empty());
132    }
133    ExpItemV.Add(ExpItem1);
134    if (!ExpItem2.Empty()){ExpItemV.Add(ExpItem2);}
135  }
136  TWixExpItem::TWixExpItem(const TStr& WordStr):
137    Type(weitWord), ExpItemV(), WordStrV(){
138    WordStrV.Add(WordStr);
139  }
140  TWixExpItem::TWixExpItem(const TStrV& _WordStrV):
141    Type(weitPhrase), ExpItemV(), WordStrV(_WordStrV){}
142  TWixExpItem::TWixExpItem(const TStr& MetaTag, const TStrV& ArgStrV):
143    Type(weitMeta), ExpItemV(), WordStrV(){
144    WordStrV.Add(MetaTag);
145    WordStrV.AddV(ArgStrV);
146  }
147  PWixExpItem TWixExpItem::GetExpItem(const int& ExpItemN){
148    IAssert(
149     (Type==weitOr)||(Type==weitAnd)||(Type==weitNot)||
150     (Type==weitIncl)||(Type==weitExcl)||(Type==weitWCard));
151    return ExpItemV[ExpItemN];
152  }
153  TStr TWixExpItem::GetWordStr(){
154    IAssert(Type==weitWord);
155    return WordStrV[0];
156  }
157  int TWixExpItem::GetPhraseLen(){
158    IAssert(Type==weitPhrase);
159    return WordStrV.Len();
160  }
161  TStr TWixExpItem::GetPhraseWordStr(const int& WordStrN){
162    IAssert(Type==weitPhrase);
163    return WordStrV[WordStrN];
164  }
165  PWixExpDocIdSet TWixExpItem::Eval(const PWix& Wix){
166    PWixExpDocIdSet DocIdSet;
167    switch (Type){
168      case weitOr:{
169        DocIdSet=GetExpItem(0)->Eval(Wix);
170        PWixExpDocIdSet RDocIdSet=GetExpItem(1)->Eval(Wix);
171        DocIdSet=DocIdSet->OrDocSet(RDocIdSet);
172        break;}
173      case weitAnd:{
174        DocIdSet=GetExpItem(0)->Eval(Wix);
175        PWixExpDocIdSet RDocIdSet=GetExpItem(1)->Eval(Wix);
176        DocIdSet=DocIdSet->AndDocSet(RDocIdSet);
177        break;}
178      case weitNot:{
179        DocIdSet=GetExpItem()->Eval(Wix);
180        DocIdSet->PutNegated(!DocIdSet->IsNegated());
181        break;}
182      case weitIncl: break; /&bsol;**
183      case weitExcl: break; /&bsol;**
184      case weitWCard:{
185        PWixExpItem SubExpItem=GetExpItem();
186        TBlobPtV DocIdV;
187        Wix->GetDocIdV(SubExpItem->GetWordStr(), false, 100, DocIdV);
188        DocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet(DocIdV));
189        break;}
190      case weitWord:{
191        TBlobPtV DocIdV;
192        Wix->GetDocIdV(GetWordStr(), true, -1, DocIdV);
193        DocIdSet=PWixExpDocIdSet(new TWixExpDocIdSet(DocIdV));
194        break;}
195      case weitPhrase: break; /&bsol;**
196      case weitMeta: break; /&bsol;**
197      default: Fail;
198    }
199    return DocIdSet;
200  }
201  PWixExpItem TWixExp::ParseFact(TWixExpLx& Lx, const TFSet& Expect){
202    if (Lx.Sym==wesyNot){
203      Lx.GetSym(FactExpect);
204      PWixExpItem ExpItem=ParseFact(Lx, Expect);
205      return PWixExpItem(new TWixExpItem(weitNot, ExpItem));
206    } else
207    if (Lx.Sym==wesyIncl){
208      Lx.GetSym(FactExpect);
209      PWixExpItem ExpItem=ParseFact(Lx, Expect);
210      return PWixExpItem(new TWixExpItem(weitIncl, ExpItem));
211    } else
212    if (Lx.Sym==wesyExcl){
213      Lx.GetSym(FactExpect);
214      PWixExpItem ExpItem=ParseFact(Lx, Expect);
215      return PWixExpItem(new TWixExpItem(weitExcl, ExpItem));
216    } else
217    if (Lx.Sym==wesyLParen){
218      Lx.GetSym(ExpExpect);
219      PWixExpItem ExpItem=ParseExp(Lx, TFSet()|wesyRParen);
220      Lx.GetSym(Expect);
221      return ExpItem;
222    } else
223    if (Lx.Sym==wesyDQuote){
224      TStrV WordStrV;
225      Lx.GetSym(TFSet()|wesyWord|wesyDQuote);
226      while (Lx.Sym==wesyWord){
227        WordStrV.Add(Lx.Str);
228        Lx.GetSym(TFSet()|wesyWord|wesyDQuote);
229      }
230      Lx.GetSym(Expect);
231      return PWixExpItem(new TWixExpItem(WordStrV));
232    } else
233    if (Lx.Sym==wesyWord){
234      PWixExpItem ExpItem=PWixExpItem(new TWixExpItem(Lx.Str));
235      Lx.GetSym(TFSet(Expect)|wesyWCard);
236      if (Lx.Sym==wesyWCard){
237        PWixExpItem WCardExpItem=
238         PWixExpItem(new TWixExpItem(weitWCard, ExpItem));
239        ExpItem=WCardExpItem;
240        Lx.GetSym(Expect);
241      }
242      return ExpItem;
243    } else {
244      Fail; return NULL;
245    }
246  }
247  PWixExpItem TWixExp::ParseTerm(TWixExpLx& Lx, const TFSet& Expect){
248    TFSet LoopExpect=TFSet(Expect)|FactExpect|wesyAnd;
249    PWixExpItem ExpItem=ParseFact(Lx, LoopExpect);
250    while ((Lx.Sym==wesyAnd)||(FactExpect.In(Lx.Sym))){
251      if (Lx.Sym==wesyAnd){
252        Lx.GetSym(FactExpect);}
253      PWixExpItem RExpItem=ParseFact(Lx, LoopExpect);
254      ExpItem=PWixExpItem(new TWixExpItem(weitAnd, ExpItem, RExpItem));
255    }
256    return ExpItem;
257  }
258  PWixExpItem TWixExp::ParseExp(TWixExpLx& Lx, const TFSet& Expect){
259    PWixExpItem ExpItem=ParseTerm(Lx, TFSet(Expect)|wesyOr);
260    while (Lx.Sym==wesyOr){
261      Lx.GetSym(TermExpect);
262      PWixExpItem RExpItem=ParseTerm(Lx, TFSet(Expect)|wesyOr);
263      ExpItem=PWixExpItem(new TWixExpItem(weitOr, ExpItem, RExpItem));
264    }
265    return ExpItem;
266  }
267  TWixExp::TWixExp(const TStr& _ExpStr):
268    ExpStr(_ExpStr), Ok(true), ErrMsg(), ExpItem(),
269    FactExpect(), TermExpect(), ExpExpect(){
270    FactExpect=TFSet()|wesyNot|wesyIncl|wesyExcl|wesyLParen|wesyDQuote|wesyWord;
271    TermExpect=FactExpect;
272    ExpExpect=TermExpect;
273    TWixExpLx Lx(ExpStr);
274    try {
275      Lx.GetSym(ExpExpect);
276      ExpItem=ParseExp(Lx, TFSet()|wesyEof);
277    }
278    catch (EWixExp E){
279      Ok=false; ErrMsg=E.GetErrMsg();
280    }
281  }
282  PWixExpDocIdSet TWixExp::Eval(const PWix& Wix){
283    PWixExpDocIdSet DocIdSet=ExpItem->Eval(Wix);
284    return DocIdSet;
285  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stepblob.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "stepblob.h"
5  #include "points.h" 
6  #include <allheaders.h> 
7  #include <vector>       
8  namespace tesseract {
9  class DENORM;
10  const double kMaxPerimeterWidthRatio = 8.0;
11  static void position_outline( 
12      C_OUTLINE *outline,       
13      C_OUTLINE_LIST *destlist  
14  ) {
15    C_OUTLINE_IT it = destlist; 
16    C_OUTLINE_IT child_it = outline->child();
17    if (!it.empty()) {
18      do {
19        C_OUTLINE *dest_outline = it.data(); 
20        if (*dest_outline < *outline) {
21          dest_outline = it.extract();
22          it.add_after_then_move(outline);
23          child_it.add_to_end(dest_outline);
24          while (!it.at_last()) {
25            it.forward(); 
26            dest_outline = it.data();
27            if (*dest_outline < *outline) {
28              dest_outline = it.extract();
29              child_it.add_to_end(dest_outline);
30              if (it.empty()) {
31                break;
32              }
33            }
34          }
35          return; 
36        }
37        else if (*outline < *dest_outline) {
38          position_outline(outline, dest_outline->child());
39          return; 
40        }
41        it.forward();
42      } while (!it.at_first());
43    }
44    it.add_to_end(outline); 
45  }
46  #ifndef GRAPHICS_DISABLED
47  static void plot_outline_list(     
48      C_OUTLINE_LIST *list,          
49      ScrollView *window,            
50      ScrollView::Color colour,      
51      ScrollView::Color child_colour 
52  ) {
53    C_OUTLINE *outline;     
54    C_OUTLINE_IT it = list; 
55    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
56      outline = it.data();
57      outline->plot(window, colour);
58      if (!outline->child()->empty()) {
59        plot_outline_list(outline->child(), window, child_colour, child_colour);
60      }
61    }
62  }
63  static void plot_normed_outline_list(const DENORM &denorm, C_OUTLINE_LIST *list,
64                                       ScrollView::Color colour, ScrollView::Color child_colour,
65                                       ScrollView *window) {
66    C_OUTLINE_IT it(list);
67    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
68      C_OUTLINE *outline = it.data();
69      outline->plot_normed(denorm, colour, window);
70      if (!outline->child()->empty()) {
71        plot_normed_outline_list(denorm, outline->child(), child_colour, child_colour, window);
72      }
73    }
74  }
75  #endif
76  static void reverse_outline_list(C_OUTLINE_LIST *list) {
77    C_OUTLINE_IT it = list; 
78    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
79      C_OUTLINE *outline = it.data();
80      outline->reverse(); 
81      outline->set_flag(COUT_INVERSE, true);
82      if (!outline->child()->empty()) {
83        reverse_outline_list(outline->child());
84      }
85    }
86  }
87  C_BLOB::C_BLOB(C_OUTLINE_LIST *outline_list) {
88    for (C_OUTLINE_IT ol_it(outline_list); !ol_it.empty(); ol_it.forward()) {
89      C_OUTLINE *outline = ol_it.extract();
90      position_outline(outline, &outlines);
91    }
92    CheckInverseFlagAndDirection();
93  }
94  C_BLOB::C_BLOB(C_OUTLINE *outline) {
95    C_OUTLINE_IT it(&outlines);
96    it.add_to_end(outline);
97  }
98  void C_BLOB::ConstructBlobsFromOutlines(bool good_blob, C_OUTLINE_LIST *outline_list,
99                                          C_BLOB_IT *good_blobs_it, C_BLOB_IT *bad_blobs_it) {
100    C_OUTLINE_LIST nested_outlines;
101    for (C_OUTLINE_IT ol_it(outline_list); !ol_it.empty(); ol_it.forward()) {
102      C_OUTLINE *outline = ol_it.extract();
103      position_outline(outline, &nested_outlines);
104    }
105    for (C_OUTLINE_IT ol_it(&nested_outlines); !ol_it.empty(); ol_it.forward()) {
106      C_OUTLINE *outline = ol_it.extract();
107      bool blob_is_good = good_blob;
108      if (!outline->IsLegallyNested()) {
109        blob_is_good = false;
110        ol_it.add_list_after(outline->child());
111      }
112      auto *blob = new C_BLOB(outline);
113      blob->CheckInverseFlagAndDirection();
114      if (!blob_is_good && bad_blobs_it != nullptr) {
115        bad_blobs_it->add_after_then_move(blob);
116      } else {
117        good_blobs_it->add_after_then_move(blob);
118      }
119    }
120  }
121  void C_BLOB::CheckInverseFlagAndDirection() {
122    C_OUTLINE_IT ol_it(&outlines);
123    for (ol_it.mark_cycle_pt(); !ol_it.cycled_list(); ol_it.forward()) {
124      C_OUTLINE *outline = ol_it.data();
125      if (outline->turn_direction() < 0) {
126        outline->reverse();
127        reverse_outline_list(outline->child());
128        outline->set_flag(COUT_INVERSE, true);
129      } else {
130        outline->set_flag(COUT_INVERSE, false);
131      }
132    }
133  }
134  C_BLOB *C_BLOB::FakeBlob(const TBOX &box) {
135    C_OUTLINE_LIST outlines;
136    C_OUTLINE::FakeOutline(box, &outlines);
137    return new C_BLOB(&outlines);
138  }
139  TBOX C_BLOB::bounding_box() const { 
140    C_OUTLINE_IT it = const_cast<C_OUTLINE_LIST *>(&outlines);
141    TBOX box; 
142    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
143      C_OUTLINE *outline = it.data();
144      box += outline->bounding_box();
145    }
146    return box;
147  }
148  int32_t C_BLOB::area() {       
149    C_OUTLINE_IT it = &outlines; 
150    int32_t total = 0;           
151    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
152      C_OUTLINE *outline = it.data();
153      total += outline->area();
154    }
155    return total;
156  }
157  int32_t C_BLOB::perimeter() {
158    C_OUTLINE_IT it = &outlines; 
159    int32_t total = 0;           
160    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
161      C_OUTLINE *outline = it.data();
162      total += outline->perimeter();
163    }
164    return total;
165  }
166  int32_t C_BLOB::outer_area() { 
167    C_OUTLINE_IT it = &outlines; 
168    int32_t total = 0;           
169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
<span onclick='openModal()' class='match'>170      C_OUTLINE *outline = it.data();
171      total += outline->outer_area();
172    }
173    return total;
174  }
175  int32_t C_BLOB::count_transitions( 
176      int32_t threshold              
177  ) {
178    C_OUTLINE_IT it = &outlines; 
</span>179    int32_t total = 0;           
180    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
181      C_OUTLINE *outline = it.data();
182      total += outline->count_transitions(threshold);
183    }
184    return total;
185  }
186  void C_BLOB::move(   
187      const ICOORD vec 
188  ) {
189    C_OUTLINE_IT it(&outlines); 
190    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
191      it.data()->move(vec); 
192    }
193  }
194  static void RotateOutlineList(const FCOORD &rotation, C_OUTLINE_LIST *outlines) {
195    C_OUTLINE_LIST new_outlines;
196    C_OUTLINE_IT src_it(outlines);
197    C_OUTLINE_IT dest_it(&new_outlines);
198    while (!src_it.empty()) {
199      C_OUTLINE *old_outline = src_it.extract();
200      src_it.forward();
201      auto *new_outline = new C_OUTLINE(old_outline, rotation);
202      if (!old_outline->child()->empty()) {
203        RotateOutlineList(rotation, old_outline->child());
204        C_OUTLINE_IT child_it(new_outline->child());
205        child_it.add_list_after(old_outline->child());
206      }
207      delete old_outline;
208      dest_it.add_to_end(new_outline);
209    }
210    src_it.add_list_after(&new_outlines);
211  }
212  void C_BLOB::rotate(const FCOORD &rotation) {
213    RotateOutlineList(rotation, &outlines);
214  }
215  static void ComputeEdgeOffsetsOutlineList(int threshold, Image pix, C_OUTLINE_LIST *list) {
216    C_OUTLINE_IT it(list);
217    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
218      C_OUTLINE *outline = it.data();
219      if (pix != nullptr && pixGetDepth(pix) == 8) {
220        outline->ComputeEdgeOffsets(threshold, pix);
221      } else {
222        outline->ComputeBinaryOffsets();
223      }
224      if (!outline->child()->empty()) {
225        ComputeEdgeOffsetsOutlineList(threshold, pix, outline->child());
226      }
227    }
228  }
229  void C_BLOB::ComputeEdgeOffsets(int threshold, Image pix) {
230    ComputeEdgeOffsetsOutlineList(threshold, pix, &outlines);
231  }
232  int16_t C_BLOB::EstimateBaselinePosition() {
233    TBOX box = bounding_box();
234    int left = box.left();
235    int width = box.width();
236    int bottom = box.bottom();
237    if (outlines.empty() || perimeter() > width * kMaxPerimeterWidthRatio) {
238      return bottom; 
239    }
240    std::vector<int> y_mins(width + 1, box.top());
241    C_OUTLINE_IT it(&outlines);
242    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
243      C_OUTLINE *outline = it.data();
244      ICOORD pos = outline->start_pos();
245      for (int s = 0; s < outline->pathlength(); ++s) {
246        if (pos.y() < y_mins[pos.x() - left]) {
247          y_mins[pos.x() - left] = pos.y();
248        }
249        pos += outline->step(s);
250      }
251    }
252    int bottom_extent = 0;
253    for (int x = 0; x <= width; ++x) {
254      if (y_mins[x] == bottom || y_mins[x] == bottom + 1) {
255        ++bottom_extent;
256      }
257    }
258    int best_min = box.top();
259    int prev_run = 0;
260    int prev_y = box.top();
261    int prev_prev_y = box.top();
262    for (int x = 0; x < width; x += prev_run) {
263      int y_at_x = y_mins[x];
264      int run = 1;
265      while (x + run <= width && y_mins[x + run] == y_at_x) {
266        ++run;
267      }
268      if (y_at_x > bottom + 1) {
269        int total_run = run;
270        while (x + total_run <= width &&
271               (y_mins[x + total_run] == y_at_x || y_mins[x + total_run] == y_at_x + 1)) {
272          ++total_run;
273        }
274        if (prev_prev_y > y_at_x + 1 || x + total_run > width || y_mins[x + total_run] > y_at_x + 1) {
275          if (prev_run > 0 && prev_y == y_at_x + 1) {
276            total_run += prev_run;
277          }
278          if (total_run > bottom_extent && y_at_x < best_min) {
279            best_min = y_at_x;
280          }
281        }
282      }
283      prev_run = run;
284      prev_prev_y = prev_y;
285      prev_y = y_at_x;
286    }
287    return best_min == box.top() ? bottom : best_min;
288  }
289  static void render_outline_list(C_OUTLINE_LIST *list, int left, int top, Image pix) {
290    C_OUTLINE_IT it(list);
291    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
292      C_OUTLINE *outline = it.data();
293      outline->render(left, top, pix);
294      if (!outline->child()->empty()) {
295        render_outline_list(outline->child(), left, top, pix);
296      }
297    }
298  }
299  static void render_outline_list_outline(C_OUTLINE_LIST *list, int left, int top, Image pix) {
300    C_OUTLINE_IT it(list);
301    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
302      C_OUTLINE *outline = it.data();
303      outline->render_outline(left, top, pix);
304    }
305  }
306  Image C_BLOB::render() {
307    TBOX box = bounding_box();
308    Image pix = pixCreate(box.width(), box.height(), 1);
309    render_outline_list(&outlines, box.left(), box.top(), pix);
310    return pix;
311  }
312  Image C_BLOB::render_outline() {
313    TBOX box = bounding_box();
314    Image pix = pixCreate(box.width(), box.height(), 1);
315    render_outline_list_outline(&outlines, box.left(), box.top(), pix);
316    return pix;
317  }
318  #ifndef GRAPHICS_DISABLED
319  void C_BLOB::plot(ScrollView *window,               
320                    ScrollView::Color blob_colour,    
321                    ScrollView::Color child_colour) { 
322    plot_outline_list(&outlines, window, blob_colour, child_colour);
323  }
324  void C_BLOB::plot_normed(const DENORM &denorm, ScrollView::Color blob_colour,
325                           ScrollView::Color child_colour, ScrollView *window) {
326    plot_normed_outline_list(denorm, &outlines, blob_colour, child_colour, window);
327  }
328  #endif
329  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wixexp.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-stepblob.cpp</div>
                </div>
                <div class="column column_space"><pre><code>120    for (int RestN2=N2; RestN2<V2.Len(); RestN2++){DstV.Add(V2[RestN2]);}
121    return DstDocIdSet;
122  }
123  TWixExpItem::TWixExpItem(const TWixExpItemType& _Type,
124   const PWixExpItem& ExpItem1, const PWixExpItem& ExpItem2):
</pre></code></div>
                <div class="column column_space"><pre><code>170      C_OUTLINE *outline = it.data();
171      total += outline->outer_area();
172    }
173    return total;
174  }
175  int32_t C_BLOB::count_transitions( 
176      int32_t threshold              
177  ) {
178    C_OUTLINE_IT it = &outlines; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    