
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.428248076052512%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baseapi_test.cc</h3>
            <pre><code>1  #include "include_gunit.h"
2  #include "cycletimer.h" 
3  #include "log.h"        
4  #include "ocrblock.h"   
5  #include "pageres.h"
6  #include <tesseract/baseapi.h>
7  #include <allheaders.h>
8  #include "gmock/gmock-matchers.h"
9  #include <memory>
10  #include <regex>
11  #include <string>
12  #include <vector>
13  namespace tesseract {
14  using ::testing::ContainsRegex;
15  using ::testing::HasSubstr;
16  static const char *langs[] = {"eng", "vie", "hin", "ara", nullptr};
17  static const char *image_files[] = {"HelloGoogle.tif", "viet.tif", "raaj.tif", "arabic.tif",
18                                      nullptr};
19  static const char *gt_text[] = {"Hello Google", "\x74\x69\xe1\xba\xbf\x6e\x67",
20                                  "\xe0\xa4\xb0\xe0\xa4\xbe\xe0\xa4\x9c",
21                                  "\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a", nullptr};
22  class FriendlyTessBaseAPI : public tesseract::TessBaseAPI {
23    FRIEND_TEST(TesseractTest, LSTMGeometryTest);
24  };
25  std::string GetCleanedTextResult(tesseract::TessBaseAPI *tess, Image pix) {
26    tess->SetImage(pix);
27    char *result = tess->GetUTF8Text();
28    std::string ocr_result = result;
29    delete[] result;
30    trim(ocr_result);
31    return ocr_result;
32  }
33  class TesseractTest : public testing::Test {
34  protected:
35    static std::string TestDataNameToPath(const std::string &name) {
36      return file::JoinPath(TESTING_DIR, name);
37    }
38    static std::string TessdataPath() {
39      return TESSDATA_DIR;
40    }
41  };
42  TEST_F(TesseractTest, StaticTessBaseAPI) {
43    static tesseract::TessBaseAPI api;
44    api.End();
45  }
46  TEST_F(TesseractTest, BasicTesseractTest) {
47    tesseract::TessBaseAPI api;
48    std::string truth_text;
49    std::string ocr_text;
50    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) != -1) {
51      Image src_pix = pixRead(TestDataNameToPath("phototest.tif").c_str());
52      CHECK(src_pix);
53      ocr_text = GetCleanedTextResult(&api, src_pix);
54      CHECK_OK(
55          file::GetContents(TestDataNameToPath("phototest.gold.txt"), &truth_text, file::Defaults()));
56      trim(truth_text);
57      EXPECT_STREQ(truth_text.c_str(), ocr_text.c_str());
58      src_pix.destroy();
59    } else {
60      GTEST_SKIP();
61    }
62  }
63  TEST_F(TesseractTest, IteratesParagraphsEvenIfNotDetected) {
64    tesseract::TessBaseAPI api;
65    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) != -1) {
<span onclick='openModal()' class='match'>66      api.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);
67      api.SetVariable("paragraph_debug_level", "3");
68  #if 0 
69      Pix* src_pix = pixRead(TestDataNameToPath("b622.png").c_str());
70      CHECK(src_pix);
71      api.SetImage(src_pix);
</span>72      Boxa* para_boxes =
73          api.GetComponentImages(tesseract::RIL_PARA, true, nullptr, nullptr);
74      EXPECT_TRUE(para_boxes != nullptr);
75      Boxa* block_boxes =
76          api.GetComponentImages(tesseract::RIL_BLOCK, true, nullptr, nullptr);
77      EXPECT_TRUE(block_boxes != nullptr);
78      EXPECT_GE(boxaGetCount(para_boxes), boxaGetCount(block_boxes));
79      boxaDestroy(&block_boxes);
80      boxaDestroy(&para_boxes);
81      src_pix.destroy();
82  #endif
83    } else {
84      GTEST_SKIP();
85    }
86  }
87  TEST_F(TesseractTest, HOCRWorksWithoutSetInputName) {
88    tesseract::TessBaseAPI api;
89    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) == -1) {
90      GTEST_SKIP();
91      return;
92    }
93    Image src_pix = pixRead(TestDataNameToPath("HelloGoogle.tif").c_str());
94    CHECK(src_pix);
95    api.SetImage(src_pix);
96    char *result = api.GetHOCRText(0);
97    EXPECT_TRUE(result != nullptr);
98    EXPECT_THAT(result, HasSubstr("Hello"));
99    EXPECT_THAT(result, HasSubstr("<div class='ocr_page'"));
100    delete[] result;
101    src_pix.destroy();
102  }
103  TEST_F(TesseractTest, HOCRContainsBaseline) {
104    tesseract::TessBaseAPI api;
105    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) == -1) {
106      GTEST_SKIP();
107      return;
108    }
109    Image src_pix = pixRead(TestDataNameToPath("HelloGoogle.tif").c_str());
110    CHECK(src_pix);
111    api.SetInputName("HelloGoogle.tif");
112    api.SetImage(src_pix);
113    char *result = api.GetHOCRText(0);
114    EXPECT_TRUE(result != nullptr);
115    EXPECT_THAT(result, HasSubstr("Hello"));
116    EXPECT_TRUE(std::regex_search(
117        result, std::regex{"<span class='ocr_line'[^>]* baseline [-.0-9]+ [-.0-9]+"}));
118    delete[] result;
119    src_pix.destroy();
120  }
121  TEST_F(TesseractTest, AdaptToWordStrTest) {
122  #ifdef DISABLED_LEGACY_ENGINE
123    GTEST_SKIP();
124  #else
125    static const char *kTrainingPages[] = {"136.tif", "256.tif", "410.tif", "432.tif", "540.tif",
126                                           "692.tif", "779.tif", "793.tif", "808.tif", "815.tif",
127                                           "12.tif",  "12.tif",  nullptr};
128    static const char *kTrainingText[] = {"1 3 6", "2 5 6", "4 1 0", "4 3 2", "5 4 0",
129                                          "6 9 2", "7 7 9", "7 9 3", "8 0 8", "8 1 5",
130                                          "1 2",   "1 2",   nullptr};
131    static const char *kTestPages[] = {"324.tif", "433.tif", "12.tif", nullptr};
132    static const char *kTestText[] = {"324", "433", "12", nullptr};
133    tesseract::TessBaseAPI api;
134    std::string truth_text;
135    std::string ocr_text;
136    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) == -1) {
137      GTEST_SKIP();
138      return;
139    }
140    api.SetVariable("matcher_sufficient_examples_for_prototyping", "1");
141    api.SetVariable("classify_class_pruner_threshold", "220");
142    for (int i = 0; kTrainingPages[i] != nullptr; ++i) {
143      std::string image_file = TestDataNameToPath(kTrainingPages[i]);
144      Image src_pix = pixRead(image_file.c_str());
145      CHECK(src_pix);
146      api.SetImage(src_pix);
147      EXPECT_TRUE(api.AdaptToWordStr(tesseract::PSM_SINGLE_WORD, kTrainingText[i]))
148          << "Failed to adapt to text \"" << kTrainingText[i] << "\" on image " << image_file;
149      src_pix.destroy();
150    }
151    api.SetVariable("tess_bn_matching", "1");
152    api.SetPageSegMode(tesseract::PSM_SINGLE_WORD);
153    for (int i = 0; kTestPages[i] != nullptr; ++i) {
154      Image src_pix = pixRead(TestDataNameToPath(kTestPages[i]).c_str());
155      CHECK(src_pix);
156      ocr_text = GetCleanedTextResult(&api, src_pix);
157      trim(truth_text);
158      EXPECT_STREQ(kTestText[i], ocr_text.c_str());
159      src_pix.destroy();
160    }
161  #endif
162  }
163  TEST_F(TesseractTest, BasicLSTMTest) {
164    tesseract::TessBaseAPI api;
165    std::string truth_text;
166    std::string ocr_text;
167    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_LSTM_ONLY) == -1) {
168      GTEST_SKIP();
169      return;
170    }
171    Image src_pix = pixRead(TestDataNameToPath("phototest_2.tif").c_str());
172    CHECK(src_pix);
173    ocr_text = GetCleanedTextResult(&api, src_pix);
174    CHECK_OK(
175        file::GetContents(TestDataNameToPath("phototest.gold.txt"), &truth_text, file::Defaults()));
176    trim(truth_text);
177    EXPECT_STREQ(truth_text.c_str(), ocr_text.c_str());
178    src_pix.destroy();
179  }
180  TEST_F(TesseractTest, LSTMGeometryTest) {
181    Image src_pix = pixRead(TestDataNameToPath("deslant.tif").c_str());
182    FriendlyTessBaseAPI api;
183    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_LSTM_ONLY) == -1) {
184      GTEST_SKIP();
185      return;
186    }
187    api.SetImage(src_pix);
188    ASSERT_EQ(api.Recognize(nullptr), 0);
189    const PAGE_RES *page_res = api.GetPageRes();
190    PAGE_RES_IT page_res_it(const_cast<PAGE_RES *>(page_res));
191    page_res_it.restart_page();
192    BLOCK *block = page_res_it.block()->block;
193    CHECK(block);
194    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
195      WERD_RES *word = page_res_it.word();
196      CHECK(word);
197      CHECK(word->best_choice);
198      CHECK_GT(word->best_choice->length(), 0);
199      CHECK(word->word);
200      CHECK(word->box_word);
201      TBOX tess_blob_box;
202      tess_blob_box = word->word->bounding_box();
203      tess_blob_box.rotate(block->re_rotation());
204      for (int i = 0; i < word->box_word->length(); ++i) {
205        TBOX lstm_blob_box = word->box_word->BlobBox(i);
206        EXPECT_LT(tess_blob_box.left() - lstm_blob_box.left(), 5);
207        EXPECT_LT(lstm_blob_box.right() - tess_blob_box.right(), 5);
208        EXPECT_LT(tess_blob_box.bottom() - lstm_blob_box.bottom(), 5);
209        EXPECT_LT(lstm_blob_box.top() - tess_blob_box.top(), 5);
210      }
211    }
212    src_pix.destroy();
213  }
214  TEST_F(TesseractTest, InitConfigOnlyTest) {
215    const char *langs[] = {"eng", "chi_tra", "jpn", "vie"};
216    std::unique_ptr<tesseract::TessBaseAPI> api;
217    CycleTimer timer;
218    for (auto &lang : langs) {
219      api = std::make_unique<tesseract::TessBaseAPI>();
220      timer.Restart();
221      EXPECT_EQ(0, api->Init(TessdataPath().c_str(), lang, tesseract::OEM_TESSERACT_ONLY));
222      timer.Stop();
223      LOG(INFO) << "Lang " << lang << " took " << timer.GetInMs() << "ms in regular init";
224    }
225    std::vector<std::string> vars_vec, vars_values;
226    vars_vec.emplace_back("tessedit_init_config_only");
227    vars_values.emplace_back("1");
228    LOG(INFO) << "Switching to config only initialization:";
229    for (auto &lang : langs) {
230      api = std::make_unique<tesseract::TessBaseAPI>();
231      timer.Restart();
232      EXPECT_EQ(0, api->Init(TessdataPath().c_str(), lang, tesseract::OEM_TESSERACT_ONLY, nullptr, 0,
233                             &vars_vec, &vars_values, false));
234      timer.Stop();
235      LOG(INFO) << "Lang " << lang << " took " << timer.GetInMs() << "ms in config-only init";
236    }
237  }
238  TEST(TesseractInstanceTest, TestMultipleTessInstances) {
239    int num_langs = 0;
240    while (langs[num_langs] != nullptr) {
241      ++num_langs;
242    }
243    const std::string kTessdataPath = TESSDATA_DIR;
244    std::vector<Image > pix(num_langs);
245    for (int i = 0; i < num_langs; ++i) {
246      std::string tracestring = "Single instance test with lang = ";
247      tracestring += langs[i];
248      SCOPED_TRACE(tracestring);
249      std::string path = file::JoinPath(TESTING_DIR, image_files[i]);
250      pix[i] = pixRead(path.c_str());
251      QCHECK(pix[i] != nullptr) << "Could not read " << path;
252      tesseract::TessBaseAPI tess;
253      EXPECT_EQ(0, tess.Init(kTessdataPath.c_str(), langs[i]));
254      std::string ocr_result = GetCleanedTextResult(&tess, pix[i]);
255      EXPECT_STREQ(gt_text[i], ocr_result.c_str());
256    }
257    std::string ocr_result[2];
258    for (int i = 0; i < num_langs; ++i) {
259      for (int j = i + 1; j < num_langs; ++j) {
260        tesseract::TessBaseAPI tess1, tess2;
261        tess1.Init(kTessdataPath.c_str(), langs[i]);
262        tess2.Init(kTessdataPath.c_str(), langs[j]);
263        ocr_result[0] = GetCleanedTextResult(&tess1, pix[i]);
264        ocr_result[1] = GetCleanedTextResult(&tess2, pix[j]);
265        EXPECT_FALSE(strcmp(gt_text[i], ocr_result[0].c_str()) ||
266                     strcmp(gt_text[j], ocr_result[1].c_str()))
267            << "OCR failed on language pair " << langs[i] << "-" << langs[j];
268      }
269    }
270    for (int i = 0; i < num_langs; ++i) {
271      pix[i].destroy();
272    }
273  }
274  TEST(TesseractInstanceTest, TestMultipleTessInstanceVariables) {
275    std::string illegal_name = "an_illegal_name";
276    std::string langs[2] = {"eng", "hin"};
277    std::string int_param_name = "tessedit_pageseg_mode";
278    int int_param[2] = {1, 2};
279    std::string int_param_str[2] = {"1", "2"};
280    std::string bool_param_name = "tessedit_ambigs_training";
281    bool bool_param[2] = {false, true};
282    std::string bool_param_str[2] = {"F", "T"};
283    std::string str_param_name = "tessedit_char_blacklist";
284    std::string str_param[2] = {"abc", "def"};
285    std::string double_param_name = "segment_penalty_dict_frequent_word";
286    std::string double_param_str[2] = {"0.01", "2"};
287    double double_param[2] = {0.01, 2};
288    const std::string kTessdataPath = TESSDATA_DIR;
289    tesseract::TessBaseAPI tess1, tess2;
290    for (int i = 0; i < 2; ++i) {
291      tesseract::TessBaseAPI *api = (i == 0) ? &tess1 : &tess2;
292      api->Init(kTessdataPath.c_str(), langs[i].c_str());
293      api->SetVariable(illegal_name.c_str(), "none");
294      api->SetVariable(int_param_name.c_str(), int_param_str[i].c_str());
295      api->SetVariable(bool_param_name.c_str(), bool_param_str[i].c_str());
296      api->SetVariable(str_param_name.c_str(), str_param[i].c_str());
297      api->SetVariable(double_param_name.c_str(), double_param_str[i].c_str());
298    }
299    for (int i = 0; i < 2; ++i) {
300      tesseract::TessBaseAPI *api = (i == 0) ? &tess1 : &tess2;
301      EXPECT_FALSE(api->GetStringVariable(illegal_name.c_str()));
302      int intvar;
303      EXPECT_TRUE(api->GetIntVariable(int_param_name.c_str(), &intvar));
304      EXPECT_EQ(int_param[i], intvar);
305      bool boolvar;
306      EXPECT_TRUE(api->GetBoolVariable(bool_param_name.c_str(), &boolvar));
307      EXPECT_EQ(bool_param[i], boolvar);
308      EXPECT_STREQ(str_param[i].c_str(), api->GetStringVariable(str_param_name.c_str()));
309      double doublevar;
310      EXPECT_TRUE(api->GetDoubleVariable(double_param_name.c_str(), &doublevar));
311      EXPECT_EQ(double_param[i], doublevar);
312    }
313  }
314  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.cpp</h3>
            <pre><code>1  #ifdef GCC_ATOMIC
2  bool TNEANetMP::HasFlag(const TGraphFlag& Flag) const {
3    return HasGraphFlag(TNEANetMP::TNet, Flag);
4  }
5  bool TNEANetMP::TNodeI::IsInNId(const int& NId) const {
6    const TNode& Node = NodeHI.GetDat();
7    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
8      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
9        return true;
10    }
11    return false;
12  }
13  bool TNEANetMP::TNodeI::IsOutNId(const int& NId) const {
14    const TNode& Node = NodeHI.GetDat();
15    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
16      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
17        return true;
18    }
19    return false;
20  }
21  void TNEANetMP::AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
22    Names = TVec<TStr>();
23    while (!NodeHI.IsEnd()) {
24      if (!NodeAttrIsDeleted(NId, NodeHI)) {
25        Names.Add(NodeHI.GetKey());
26      }
27      NodeHI++;
28    }
29  }
30  void TNEANetMP::AttrValueNI(const TInt& NId , TStrIntPrH::TIter NodeHI, TStrV& Values) const {
31    Values = TVec<TStr>();
32    while (!NodeHI.IsEnd()) {
33      if (!NodeAttrIsDeleted(NId, NodeHI)) {
34        Values.Add(GetNodeAttrValue(NId, NodeHI));
35      }
36      NodeHI++;
37    }
38  }
39  void TNEANetMP::IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
40    Names = TVec<TStr>();
41    while (!NodeHI.IsEnd()) {
42      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
43        Names.Add(NodeHI.GetKey());
44      }
45      NodeHI++;
46    }
47  }
48  void TNEANetMP::IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const {
49    Values = TVec<TInt>();
50    while (!NodeHI.IsEnd()) {
<span onclick='openModal()' class='match'>51      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
52        TInt val = this->VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
53        Values.Add(val);
</span>54      }
55      NodeHI++;
56    }
57  }
58  void TNEANetMP::StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
59    Names = TVec<TStr>();
60    while (!NodeHI.IsEnd()) {
61      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
62        Names.Add(NodeHI.GetKey());
63      }
64      NodeHI++;
65    }
66  }
67  void TNEANetMP::StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const {
68    Values = TVec<TStr>();
69    while (!NodeHI.IsEnd()) {
70      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
71        TStr val = this->VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
72        Values.Add(val);
73      }
74      NodeHI++;
75    }
76  }
77  void TNEANetMP::FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
78    Names = TVec<TStr>();
79    while (!NodeHI.IsEnd()) {
80      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
81        Names.Add(NodeHI.GetKey());
82      }
83      NodeHI++;
84    }
85  }
86  void TNEANetMP::FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const {
87    Values = TVec<TFlt>();
88    while (!NodeHI.IsEnd()) {
89      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
90        TFlt val = (this->VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
91        Values.Add(val);
92      }
93      NodeHI++;
94    }
95  }
96  bool TNEANetMP::NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
97    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
98    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
99    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
100    return IntDel || StrDel || FltDel;
101  }
102  bool TNEANetMP::NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
103    return (NodeHI.GetDat().Val1 == IntType &&
104      GetIntAttrDefaultN(NodeHI.GetKey()) == this->VecOfIntVecsN.GetVal(
105      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
106  }
107  bool TNEANetMP::NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
108    return (NodeHI.GetDat().Val1 == StrType &&
109      GetStrAttrDefaultN(NodeHI.GetKey()) == this->VecOfStrVecsN.GetVal(
110      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
111  }
112  bool TNEANetMP::NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
113    return (NodeHI.GetDat().Val1 == FltType &&
114      GetFltAttrDefaultN(NodeHI.GetKey()) == this->VecOfFltVecsN.GetVal(
115      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
116  }
117  TStr TNEANetMP::GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
118    if (NodeHI.GetDat().Val1 == IntType) {
119      return (this->VecOfIntVecsN.GetVal(
120        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
121    } else if(NodeHI.GetDat().Val1 == StrType) {
122      return this->VecOfStrVecsN.GetVal(
123      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
124    } else if (NodeHI.GetDat().Val1 == FltType) {
125      return (this->VecOfFltVecsN.GetVal(
126        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
127    }
128    return TStr::GetNullStr();
129  }
130  void TNEANetMP::AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
131    Names = TVec<TStr>();
132    while (!EdgeHI.IsEnd()) {
133      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
134        Names.Add(EdgeHI.GetKey());
135      }
136      EdgeHI++;
137    }
138  }
139  void TNEANetMP::AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
140    Values = TVec<TStr>();
141    while (!EdgeHI.IsEnd()) {
142      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
143        Values.Add(GetNodeAttrValue(EId, EdgeHI));
144      }
145      EdgeHI++;
146    }
147  }
148  void TNEANetMP::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
149    Names = TVec<TStr>();
150    while (!EdgeHI.IsEnd()) {
151      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
152        Names.Add(EdgeHI.GetKey());
153      }
154      EdgeHI++;
155    }
156  }
157  void TNEANetMP::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const {
158    Values = TVec<TInt>();
159    while (!EdgeHI.IsEnd()) {
160      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
161        TInt val = (this->VecOfIntVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
162        Values.Add(val);
163      }
164      EdgeHI++;
165    }
166  }
167  void TNEANetMP::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
168    Names = TVec<TStr>();
169    while (!EdgeHI.IsEnd()) {
170      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
171        Names.Add(EdgeHI.GetKey());
172      }
173      EdgeHI++;
174    }
175  }
176  void TNEANetMP::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
177    Values = TVec<TStr>();
178    while (!EdgeHI.IsEnd()) {
179      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
180        TStr val = this->VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
181        Values.Add(val);
182      }
183      EdgeHI++;
184    }
185  }
186  void TNEANetMP::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
187    Names = TVec<TStr>();
188    while (!EdgeHI.IsEnd()) {
189      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
190        Names.Add(EdgeHI.GetKey());
191      }
192      EdgeHI++;
193    }
194  }
195  void TNEANetMP::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const {
196    Values = TVec<TFlt>();
197    while (!EdgeHI.IsEnd()) {
198      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
199        TFlt val = (this->VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
200        Values.Add(val);
201      }
202      EdgeHI++;
203    }
204  }
205  bool TNEANetMP::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
206    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
207    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
208    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
209    return IntDel || StrDel || FltDel;
210  }
211  bool TNEANetMP::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
212    return (EdgeHI.GetDat().Val1 == IntType &&
213      GetIntAttrDefaultE(EdgeHI.GetKey()) == this->VecOfIntVecsE.GetVal(
214      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
215  }
216  bool TNEANetMP::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
217    return (EdgeHI.GetDat().Val1 == StrType &&
218      GetStrAttrDefaultE(EdgeHI.GetKey()) == this->VecOfStrVecsE.GetVal(
219      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
220  }
221  bool TNEANetMP::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
222    return (EdgeHI.GetDat().Val1 == FltType &&
223      GetFltAttrDefaultE(EdgeHI.GetKey()) == this->VecOfFltVecsE.GetVal(
224      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
225  }
226  TStr TNEANetMP::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
227    if (EdgeHI.GetDat().Val1 == IntType) {
228      return (this->VecOfIntVecsE.GetVal(
229        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
230    } else if(EdgeHI.GetDat().Val1 == StrType) {
231      return this->VecOfStrVecsE.GetVal(
232      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
233    } else if (EdgeHI.GetDat().Val1 == FltType) {
234      return (this->VecOfFltVecsE.GetVal(
235        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
236    }
237    return TStr::GetNullStr();
238  }
239  int TNEANetMP::AddNode(int NId) {
240    int i;
241    if (NId == -1) {
242      NId = MxNId;  MxNId++;
243    } else {
244      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
245      MxNId = TMath::Mx(NId+1, MxNId());
246    }
247    NodeH.AddDat(NId, TNode(NId));
248    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
249      TVec<TInt>& IntVec = VecOfIntVecsN[i];
250      IntVec.Ins(NodeH.GetKeyId(NId), TInt::Mn);
251    }
252    TVec<TStr> DefIntVec = TVec<TStr>();
253    IntDefaultsN.GetKeyV(DefIntVec);
254    for (i = 0; i < DefIntVec.Len(); i++) {
255      TStr attr = DefIntVec[i];
256      TVec<TInt>& IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
257      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
258    }
259    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
260      TVec<TStr>& StrVec = VecOfStrVecsN[i];
261      StrVec.Ins(NodeH.GetKeyId(NId), TStr::GetNullStr());
262    }
263    TVec<TStr> DefStrVec = TVec<TStr>();
264    IntDefaultsN.GetKeyV(DefStrVec);
265    for (i = 0; i < DefStrVec.Len(); i++) {
266      TStr attr = DefStrVec[i];
267      TVec<TStr>& StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
268      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
269    }
270    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
271      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
272      FltVec.Ins(NodeH.GetKeyId(NId), TFlt::Mn);
273    }
274    TVec<TStr> DefFltVec = TVec<TStr>();
275    FltDefaultsN.GetKeyV(DefFltVec);
276    for (i = 0; i < DefFltVec.Len(); i++) {
277      TStr attr = DefFltVec[i];
278      TVec<TFlt>& FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
279      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
280    }
281    return NId;
282  }
283  void TNEANetMP::AddNodeWithEdges(const TInt& NId, TIntV& InEIdV, TIntV& OutEIdV) {
284    int NodeIdx = abs((NId.GetPrimHashCd()) % Reserved());
285    int NodeKeyId = NodeH.AddKey13(NodeIdx, NId);
286    MxNId = TMath::Mx(NId+1, MxNId());
287    NodeH[NodeKeyId] = TNode(NId);
288    NodeH[NodeKeyId].InEIdV.MoveFrom(InEIdV);
289    NodeH[NodeKeyId].OutEIdV.MoveFrom(OutEIdV);
290  }
291  int TNEANetMP::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
292    int i;
293    if (EId == -1) { EId = MxEId;  MxEId++; }
294    else { MxEId = TMath::Mx(EId+1, MxEId()); }
295    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
296    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
297    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
298    GetNode(SrcNId).OutEIdV.AddSorted(EId);
299    GetNode(DstNId).InEIdV.AddSorted(EId);
300    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
301      TVec<TInt>& IntVec = VecOfIntVecsE[i];
302      IntVec.Ins(EdgeH.GetKeyId(EId), TInt::Mn);
303    }
304    TVec<TStr> DefIntVec = TVec<TStr>();
305    IntDefaultsE.GetKeyV(DefIntVec);
306    for (i = 0; i < DefIntVec.Len(); i++) {
307      TStr attr = DefIntVec[i];
308      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
309      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
310    }
311    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
312      TVec<TStr>& StrVec = VecOfStrVecsE[i];
313      StrVec.Ins(EdgeH.GetKeyId(EId), TStr::GetNullStr());
314    }
315    TVec<TStr> DefStrVec = TVec<TStr>();
316    IntDefaultsE.GetKeyV(DefStrVec);
317    for (i = 0; i < DefStrVec.Len(); i++) {
318      TStr attr = DefStrVec[i];
319      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
320      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
321    }
322    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
323      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
324      FltVec.Ins(EdgeH.GetKeyId(EId), TFlt::Mn);
325    }
326    TVec<TStr> DefFltVec = TVec<TStr>();
327    FltDefaultsE.GetKeyV(DefFltVec);
328    for (i = 0; i < DefFltVec.Len(); i++) {
329      TStr attr = DefFltVec[i];
330      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
331      FltVec[NodeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
332    }
333    return EId;
334  }
335  void TNEANetMP::AddEdgeUnchecked(const TInt& EId, const int SrcNId, const int DstNId) {
336    int Idx = abs((EId.GetPrimHashCd()) % ReservedE());
337    int KeyId = EdgeH.AddKey13(Idx, EId);
338    MxEId = TMath::Mx(EId+1, MxEId());
339    EdgeH[KeyId] = TEdge(EId, SrcNId, DstNId);
340  }
341  bool TNEANetMP::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
342    const TNode& SrcNode = GetNode(SrcNId);
343    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
344      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
345      if (DstNId == Edge.GetDstNId()) {
346        EId = Edge.GetId();
347        return true;
348      }
349    }
350    if (! IsDir) {
351      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
352        const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
353        if (DstNId == Edge.GetSrcNId()) {
354          EId = Edge.GetId();
355          return true;
356        }
357      }
358    }
359    return false;
360  }
361  void TNEANetMP::GetNIdV(TIntV& NIdV) const {
362    NIdV.Gen(GetNodes(), 0);
363    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
364      NIdV.Add(NodeH.GetKey(N));
365    }
366  }
367  void TNEANetMP::GetEIdV(TIntV& EIdV) const {
368    EIdV.Gen(GetEdges(), 0);
369    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
370      EIdV.Add(EdgeH.GetKey(E));
371    }
372  }
373  void TNEANetMP::Defrag(const bool& OnlyNodeLinks) {
374    #if 0
375    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
376      TNode& Node = NodeH[kid];
377      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
378    }
379    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
380    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
381    #endif
382  }
383  bool TNEANetMP::IsOk(const bool& ThrowExcept) const {
384    bool RetVal = true;
385    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
386      const TNode& Node = NodeH[N];
387      if (! Node.OutEIdV.IsSorted()) {
388        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
389        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
390      }
391      if (! Node.InEIdV.IsSorted()) {
392        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
393        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
394      }
395      int prevEId = -1;
396      for (int e = 0; e < Node.GetOutDeg(); e++) {
397        if (! IsEdge(Node.GetOutEId(e))) {
398          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
399          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
400        }
401        if (e > 0 && prevEId == Node.GetOutEId(e)) {
402          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
403          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
404        }
405        prevEId = Node.GetOutEId(e);
406      }
407      prevEId = -1;
408      for (int e = 0; e < Node.GetInDeg(); e++) {
409        if (! IsEdge(Node.GetInEId(e))) {
410        const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
411        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
412        }
413        if (e > 0 && prevEId == Node.GetInEId(e)) {
414          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
415          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
416        }
417        prevEId = Node.GetInEId(e);
418      }
419    }
420    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
421      const TEdge& Edge = EdgeH[E];
422      if (! IsNode(Edge.GetSrcNId())) {
423        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
424        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
425      }
426      if (! IsNode(Edge.GetDstNId())) {
427        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
428        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
429      }
430    }
431    return RetVal;
432  }
433  void TNEANetMP::Dump(FILE *OutF) const {
434    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
435    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
436    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Network: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
437    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
438      fprintf(OutF, "  %*d]\n", NodePlaces, NodeI.GetId());
439      TIntV IntAttrN;
440      IntAttrValueNI(NodeI.GetId(), IntAttrN);
441      fprintf(OutF, "    nai[%d]", IntAttrN.Len());
442      for (int i = 0; i < IntAttrN.Len(); i++) {
443        fprintf(OutF, " %*i", NodePlaces, IntAttrN[i]()); }
444      TStrV StrAttrN;
445      StrAttrValueNI(NodeI.GetId(), StrAttrN);
446      fprintf(OutF, "    nas[%d]", StrAttrN.Len());
447      for (int i = 0; i < StrAttrN.Len(); i++) {
448        fprintf(OutF, " %*s", NodePlaces, StrAttrN[i]()); }
449      TFltV FltAttrN;
450      FltAttrValueNI(NodeI.GetId(), FltAttrN);
451      fprintf(OutF, "    naf[%d]", FltAttrN.Len());
452      for (int i = 0; i < FltAttrN.Len(); i++) {
453        fprintf(OutF, " %*f", NodePlaces, FltAttrN[i]()); }
454      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
455      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
456        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
457      fprintf(OutF, "\n");
458      fprintf(OutF, "    out[%d]", NodeI.GetOutDeg());
459      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
460        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
461      fprintf(OutF, "\n");
462    }
463    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
464      fprintf(OutF, "  %*d]  %*d  ->  %*d", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
465      TIntV IntAttrE;
466      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
467      fprintf(OutF, "    eai[%d]", IntAttrE.Len());
468      for (int i = 0; i < IntAttrE.Len(); i++) {
469        fprintf(OutF, " %*i", EdgePlaces, IntAttrE[i]());
470      }
471      TStrV StrAttrE;
472      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
473      fprintf(OutF, "    eas[%d]", StrAttrE.Len());
474      for (int i = 0; i < StrAttrE.Len(); i++) {
475        fprintf(OutF, " %*s", EdgePlaces, StrAttrE[i]());
476      }
477      TFltV FltAttrE;
478      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
479      fprintf(OutF, "    eaf[%d]", FltAttrE.Len());
480      for (int i = 0; i < FltAttrE.Len(); i++) {
481        fprintf(OutF, " %*f", EdgePlaces, FltAttrE[i]());
482      }
483      fprintf(OutF, "\n");
484    }
485    fprintf(OutF, "\n");
486  }
487  int TNEANetMP::AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
488    int i;
489    TInt CurrLen;
490    if (!IsNode(NId)) {
491      return -1;
492    }
493    if (KeyToIndexTypeN.IsKey(attr)) {
494      TVec<TInt>& NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
495      NewVec[NodeH.GetKeyId(NId)] = value;
496    } else {
497      CurrLen = VecOfIntVecsN.Len();
498      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
499      TVec<TInt> NewVec = TVec<TInt>();
500      for (i = 0; i < MxNId; i++) {
501        NewVec.Ins(i, (TInt) TInt::Mn);
502      }
503      NewVec[NodeH.GetKeyId(NId)] = value;
504      VecOfIntVecsN.Add(NewVec);
505    }
506    return 0;
507  }
508  int TNEANetMP::AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr) {
509    int i;
510    TInt CurrLen;
511    if (!IsNode(NId)) {
512      return -1;
513    }
514    if (KeyToIndexTypeN.IsKey(attr)) {
515      TVec<TStr>& NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
516      NewVec[NodeH.GetKeyId(NId)] = value;
517    } else {
518      CurrLen = VecOfStrVecsN.Len();
519      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
520      TVec<TStr> NewVec = TVec<TStr>();
521      for (i = 0; i < MxNId; i++) {
522          NewVec.Ins(i, (TStr) TStr::GetNullStr() );
523      }
524      NewVec[NodeH.GetKeyId(NId)] = value;
525      VecOfStrVecsN.Add(NewVec);
526    }
527    return 0;
528  }
529  int TNEANetMP::AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
530    int i;
531    TInt CurrLen;
532    if (!IsNode(NId)) {
533      return -1;
534    }
535    if (KeyToIndexTypeN.IsKey(attr)) {
536      TVec<TFlt>& NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
537      NewVec[NodeH.GetKeyId(NId)] = value;
538    } else {
539      CurrLen = VecOfFltVecsN.Len();
540      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
541      TVec<TFlt> NewVec = TVec<TFlt>();
542      for (i = 0; i < MxNId; i++) {
543        NewVec.Ins(i, GetFltAttrDefaultN(attr));
544      }
545      NewVec[NodeH.GetKeyId(NId)] = value;
546      VecOfFltVecsN.Add(NewVec);
547    }
548    return 0;
549  }
550  int TNEANetMP::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
551    int i;
552    TInt CurrLen;
553    if (!IsEdge(EId)) {
554       return -1;
555    }
556    if (KeyToIndexTypeE.IsKey(attr)) {
557      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
558      NewVec[EdgeH.GetKeyId(EId)] = value;
559    } else {
560      CurrLen = VecOfIntVecsE.Len();
561      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
562      TVec<TInt> NewVec = TVec<TInt>();
563      for (i = 0; i < MxEId; i++) {
564        NewVec.Ins(i, (TInt) TInt::Mn);
565      }
566      NewVec[EdgeH.GetKeyId(EId)] = value;
567      VecOfIntVecsE.Add(NewVec);
568    }
569    return 0;
570  }
571  int TNEANetMP::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
572    int i;
573    TInt CurrLen;
574    if (!IsEdge(EId)) {
575       return -1;
576    }
577    if (KeyToIndexTypeE.IsKey(attr)) {
578      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
579      NewVec[EdgeH.GetKeyId(EId)] = value;
580    } else {
581      CurrLen = VecOfStrVecsE.Len();
582      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
583      TVec<TStr> NewVec = TVec<TStr>();
584      for (i = 0; i < MxEId; i++) {
585        NewVec.Ins(i, (TStr) TStr::GetNullStr());
586      }
587      NewVec[EdgeH.GetKeyId(EId)] = value;
588      VecOfStrVecsE.Add(NewVec);
589    }
590    return 0;
591  }
592  int TNEANetMP::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
593    int i;
594    TInt CurrLen;
595    if (!IsEdge(EId)) {
596       return -1;
597    }
598    if (KeyToIndexTypeE.IsKey(attr)) {
599      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
600      NewVec[EdgeH.GetKeyId(EId)] = value;
601    } else {
602      CurrLen = VecOfFltVecsE.Len();
603      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
604      TVec<TFlt> NewVec = TVec<TFlt>();
605      for (i = 0; i < MxEId; i++) {
606        NewVec.Ins(i, GetFltAttrDefaultE(attr));
607      }
608      NewVec[EdgeH.GetKeyId(EId)] = value;
609      VecOfFltVecsE.Add(NewVec);
610    }
611    return 0;
612  }
613  TVec<TFlt>& TNEANetMP::GetFltAttrVecE(const TStr& attr) {
614    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
615  }
616  int TNEANetMP::GetFltKeyIdE(const int& EId) {
617    return EdgeH.GetKeyId(EId);
618  }
619  TInt TNEANetMP::GetIntAttrDatN(const int& NId, const TStr& attr) {
620    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
621  }
622  TInt TNEANetMP::GetIntAttrIndDatN(const int& NId, const int& index) {
623    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
624  }
625  int TNEANetMP::GetIntAttrIndN(const TStr& attr) {
626    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
627  }
628  TStr TNEANetMP::GetStrAttrDatN(const int& NId, const TStr& attr) {
629    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
630  }
631  TFlt TNEANetMP::GetFltAttrDatN(const int& NId, const TStr& attr) {
632    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
633  }
634  TInt TNEANetMP::GetIntAttrDatE(const int& EId, const TStr& attr) {
635    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
636  }
637  TInt TNEANetMP::GetIntAttrIndDatE(const int& EId, const int& index) {
638    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
639  }
640  int TNEANetMP::GetIntAttrIndE(const TStr& attr) {
641    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
642  }
643  TStr TNEANetMP::GetStrAttrDatE(const int& EId, const TStr& attr) {
644    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
645  }
646  TFlt TNEANetMP::GetFltAttrDatE(const int& EId, const TStr& attr) {
647    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
648  }
649  int TNEANetMP::DelAttrDatN(const int& NId, const TStr& attr) {
650    TInt vecType = KeyToIndexTypeN(attr).Val1;
651    if (vecType == IntType) {
652      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
653    } else if (vecType == StrType) {
654      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
655    } else if (vecType == FltType) {
656      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
657    } else {
658      return -1;
659    }
660    return 0;
661  }
662  int TNEANetMP::DelAttrDatE(const int& EId, const TStr& attr) {
663    TInt vecType = KeyToIndexTypeE(attr).Val1;
664    if (vecType == IntType) {
665      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
666    } else if (vecType == StrType) {
667      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
668    } else if (vecType == FltType) {
669      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
670    } else {
671      return -1;
672    }
673    return 0;
674  }
675  int TNEANetMP::AddIntAttrN(const TStr& attr, TInt defaultValue){
676    int i;
677    TInt CurrLen;
678    TVec<TInt> NewVec;
679    CurrLen = VecOfIntVecsN.Len();
680    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
681    NewVec = TVec<TInt>();
682    for (i = 0; i < MxNId; i++) {
683      NewVec.Ins(i, defaultValue);
684    }
685    VecOfIntVecsN.Add(NewVec);
686    if (!IntDefaultsN.IsKey(attr)) {
687      IntDefaultsN.AddDat(attr, defaultValue);
688    } else {
689      return -1;
690    }
691    return 0;
692  }
693  int TNEANetMP::AddStrAttrN(const TStr& attr, TStr defaultValue) {
694    int i;
695    TInt CurrLen;
696    TVec<TStr> NewVec;
697    CurrLen = VecOfStrVecsN.Len();
698    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
699    NewVec = TVec<TStr>();
700    for (i = 0; i < MxNId; i++) {
701      NewVec.Ins(i, defaultValue);
702    }
703    VecOfStrVecsN.Add(NewVec);
704    if (!StrDefaultsN.IsKey(attr)) {
705      StrDefaultsN.AddDat(attr, defaultValue);
706    } else {
707      return -1;
708    }
709    return 0;
710  }
711  int TNEANetMP::AddFltAttrN(const TStr& attr, TFlt defaultValue) {
712    int i;
713    TInt CurrLen;
714    TVec<TFlt> NewVec;
715    CurrLen = VecOfStrVecsN.Len();
716    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
717    NewVec = TVec<TFlt>();
718    for (i = 0; i < MxNId; i++) {
719      NewVec.Ins(i, defaultValue);
720    }
721    VecOfFltVecsN.Add(NewVec);
722    if (!FltDefaultsN.IsKey(attr)) {
723      FltDefaultsN.AddDat(attr, defaultValue);
724    } else {
725      return -1;
726    }
727    return 0;
728  }
729  int TNEANetMP::AddIntAttrE(const TStr& attr, TInt defaultValue){
730    int i;
731    TInt CurrLen;
732    TVec<TInt> NewVec;
733    CurrLen = VecOfIntVecsE.Len();
734    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
735    NewVec = TVec<TInt>();
736    for (i = 0; i < MxEId; i++) {
737      NewVec.Ins(i, defaultValue);
738    }
739    VecOfIntVecsE.Add(NewVec);
740    if (!IntDefaultsE.IsKey(attr)) {
741      IntDefaultsE.AddDat(attr, defaultValue);
742    } else {
743      return -1;
744    }
745    return 0;
746  }
747  int TNEANetMP::AddStrAttrE(const TStr& attr, TStr defaultValue) {
748    int i;
749    TInt CurrLen;
750    TVec<TStr> NewVec;
751    CurrLen = VecOfStrVecsE.Len();
752    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
753    NewVec = TVec<TStr>();
754    for (i = 0; i < MxEId; i++) {
755      NewVec.Ins(i, defaultValue);
756    }
757    VecOfStrVecsE.Add(NewVec);
758    if (!StrDefaultsE.IsKey(attr)) {
759      StrDefaultsE.AddDat(attr, defaultValue);
760    } else {
761      return -1;
762    }
763    return 0;
764  }
765  int TNEANetMP::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
766    int i;
767    TInt CurrLen;
768    TVec<TFlt> NewVec;
769    CurrLen = VecOfStrVecsE.Len();
770    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
771    NewVec = TVec<TFlt>();
772    for (i = 0; i < MxEId; i++) {
773      NewVec.Ins(i, defaultValue);
774    }
775    VecOfFltVecsE.Add(NewVec);
776    if (!FltDefaultsE.IsKey(attr)) {
777      FltDefaultsE.AddDat(attr, defaultValue);
778    } else {
779      return -1;
780    }
781    return 0;
782  }
783  TFlt TNEANetMP::GetWeightOutEdges(const TNodeI& NI, const TStr& attr) {
784    TNode Node = GetNode(NI.GetId());
785    TIntV OutEIdV = Node.OutEIdV;
786    TFlt total = 0;
787    int len = Node.OutEIdV.Len();
788    for (int i = 0; i < len; i++) {
789      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
790    }
791    return total;
792  }
793  void TNEANetMP::GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) {
794    for (TEdgeI it = BegEI(); it < EndEI(); it++) {
795      int EId = it.GetId();
796      int SrcId = it.GetSrcNId();
797      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
798    }
799  }
800  bool TNEANetMP::IsFltAttrE(const TStr& attr) {
801    return (KeyToIndexTypeE.IsKey(attr) &&
802      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
803  }
804  bool TNEANetMP::IsIntAttrE(const TStr& attr) {
805    return (KeyToIndexTypeE.IsKey(attr) &&
806      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
807  }
808  bool TNEANetMP::IsStrAttrE(const TStr& attr) {
809    return (KeyToIndexTypeE.IsKey(attr) &&
810      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
811  }
812  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baseapi_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-networkmp.cpp</div>
                </div>
                <div class="column column_space"><pre><code>66      api.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);
67      api.SetVariable("paragraph_debug_level", "3");
68  #if 0 
69      Pix* src_pix = pixRead(TestDataNameToPath("b622.png").c_str());
70      CHECK(src_pix);
71      api.SetImage(src_pix);
</pre></code></div>
                <div class="column column_space"><pre><code>51      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
52        TInt val = this->VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
53        Values.Add(val);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    