
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.411078717201166%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type_mat2x2.hpp</h3>
            <pre><code>1  #ifndef glm_core_type_mat2x2
2  #define glm_core_type_mat2x2
3  #include "type_mat.hpp"
4  namespace glm{
5  namespace detail
6  {
7  	template <typename T> struct tvec1;
8  	template <typename T> struct tvec2;
9  	template <typename T> struct tvec3;
10  	template <typename T> struct tvec4;
11  	template <typename T> struct tmat2x2;
12  	template <typename T> struct tmat2x3;
13  	template <typename T> struct tmat2x4;
14  	template <typename T> struct tmat3x2;
15  	template <typename T> struct tmat3x3;
16  	template <typename T> struct tmat3x4;
17  	template <typename T> struct tmat4x2;
18  	template <typename T> struct tmat4x3;
19  	template <typename T> struct tmat4x4;
20  	template <typename T> 
21  	struct tmat2x2
22  	{
23  		enum ctor{null};
24  		typedef T value_type;
25  		typedef std::size_t size_type;
26  		typedef tvec2<T> col_type;
27  		typedef tvec2<T> row_type;
28  		static GLM_FUNC_DECL size_type col_size();
29  		static GLM_FUNC_DECL size_type row_size();
30  		typedef tmat2x2<T> type;
31  		typedef tmat2x2<T> transpose_type;
32  		GLM_FUNC_DECL size_type length() const;
33  	public:
34  		GLM_FUNC_DECL tmat2x2<T> _inverse() const;
35  	private:
36  		col_type value[2];
37  	public:
38  		GLM_FUNC_DECL tmat2x2();
39  		GLM_FUNC_DECL tmat2x2(
40  			tmat2x2 const & m);
41  		GLM_FUNC_DECL explicit tmat2x2(
42  			ctor Null);
43  		GLM_FUNC_DECL explicit tmat2x2(
44  			value_type const & x);
45  		GLM_FUNC_DECL explicit tmat2x2(
46  			value_type const & x1, value_type const & y1, 
47  			value_type const & x2, value_type const & y2);
48  		GLM_FUNC_DECL explicit tmat2x2(
49  			col_type const & v1, 
50  			col_type const & v2);
51  		template <typename U> 
52  		GLM_FUNC_DECL explicit tmat2x2(
53  			U const & x);
54  		template <typename U, typename V, typename M, typename N> 
55  		GLM_FUNC_DECL explicit tmat2x2(
56  			U const & x1, V const & y1, 
57  			M const & x2, N const & y2);
58  		template <typename U, typename V> 
59  		GLM_FUNC_DECL explicit tmat2x2(
60  			tvec2<U> const & v1, 
61  			tvec2<V> const & v2);
62  		template <typename U> 
<span onclick='openModal()' class='match'>63  		GLM_FUNC_DECL explicit tmat2x2(tmat2x2<U> const & m);
64  		GLM_FUNC_DECL explicit tmat2x2(tmat3x3<T> const & x);
65  		GLM_FUNC_DECL explicit tmat2x2(tmat4x4<T> const & x);
66  		GLM_FUNC_DECL explicit tmat2x2(tmat2x3<T> const & x);
67  		GLM_FUNC_DECL explicit tmat2x2(tmat3x2<T> const & x);
68  		GLM_FUNC_DECL explicit tmat2x2(tmat2x4<T> const & x);
69  		GLM_FUNC_DECL explicit tmat2x2(tmat4x2<T> const & x);
70  		GLM_FUNC_DECL explicit tmat2x2(tmat3x4<T> const & x);
71  		GLM_FUNC_DECL explicit tmat2x2(tmat4x3<T> const & x);
72  		GLM_FUNC_DECL col_type & operator[](size_type i);
73  		GLM_FUNC_DECL col_type const & operator[](size_type i) const;
74  		GLM_FUNC_DECL tmat2x2<T> & operator=(tmat2x2<T> const & m);
</span>75  		template <typename U> 
76  		GLM_FUNC_DECL tmat2x2<T> & operator=(tmat2x2<U> const & m);
77  		template <typename U> 
78  		GLM_FUNC_DECL tmat2x2<T> & operator+=(U const & s);
79  		template <typename U> 
80  		GLM_FUNC_DECL tmat2x2<T> & operator+=(tmat2x2<U> const & m);
81  		template <typename U> 
82  		GLM_FUNC_DECL tmat2x2<T> & operator-=(U const & s);
83  		template <typename U> 
84  		GLM_FUNC_DECL tmat2x2<T> & operator-=(tmat2x2<U> const & m);
85  		template <typename U> 
86  		GLM_FUNC_DECL tmat2x2<T> & operator*=(U const & s);
87  		template <typename U> 
88  		GLM_FUNC_DECL tmat2x2<T> & operator*=(tmat2x2<U> const & m);
89  		template <typename U> 
90  		GLM_FUNC_DECL tmat2x2<T> & operator/=(U const & s);
91  		template <typename U> 
92  		GLM_FUNC_DECL tmat2x2<T> & operator/=(tmat2x2<U> const & m);
93  		GLM_FUNC_DECL tmat2x2<T> & operator++();
94  		GLM_FUNC_DECL tmat2x2<T> & operator--();
95  	};
96  	template <typename T> 
97  	tmat2x2<T> operator+ (
98  		tmat2x2<T> const & m, 
99  		typename tmat2x2<T>::value_type const & s);
100  	template <typename T> 
101  	tmat2x2<T> operator+ (
102  		typename tmat2x2<T>::value_type const & s, 
103  		tmat2x2<T> const & m);
104  	template <typename T> 
105  	tmat2x2<T> operator+ (
106  		tmat2x2<T> const & m1, 
107  		tmat2x2<T> const & m2);
108  	template <typename T> 
109  	tmat2x2<T> operator- (
110  		tmat2x2<T> const & m, 
111  		typename tmat2x2<T>::value_type const & s);
112  	template <typename T> 
113  	tmat2x2<T> operator- (
114  		typename tmat2x2<T>::value_type const & s, 
115  		tmat2x2<T> const & m);
116  	template <typename T> 
117  	tmat2x2<T> operator- (
118  		tmat2x2<T> const & m1, 
119  		tmat2x2<T> const & m2);
120  	template <typename T> 
121  	tmat2x2<T> operator* (
122  		tmat2x2<T> const & m, 
123  		typename tmat2x2<T>::value_type const & s);
124  	template <typename T> 
125  	tmat2x2<T> operator* (
126  		typename tmat2x2<T>::value_type const & s, 
127  		tmat2x2<T> const & m);
128  	template <typename T> 
129  	typename tmat2x2<T>::col_type operator* (
130  		tmat2x2<T> const & m, 
131  		typename tmat2x2<T>::row_type const & v);
132  	template <typename T> 
133  	typename tmat2x2<T>::row_type operator* (
134  		typename tmat2x2<T>::col_type const & v, 
135  		tmat2x2<T> const & m);
136  	template <typename T> 
137  	tmat2x2<T> operator* (
138  		tmat2x2<T> const & m1, 
139  		tmat2x2<T> const & m2);
140  	template <typename T>
141  	tmat3x2<T> operator* (
142  		tmat2x2<T> const & m1, 
143  		tmat3x2<T> const & m2);
144  	template <typename T>
145  	tmat4x2<T> operator* (
146  		tmat2x2<T> const & m1, 
147  		tmat4x2<T> const & m2);
148  	template <typename T> 
149  	tmat2x2<T> operator/ (
150  		tmat2x2<T> const & m, 
151  		typename tmat2x2<T>::value_type const & s);
152  	template <typename T> 
153  	tmat2x2<T> operator/ (
154  		typename tmat2x2<T>::value_type const & s,
155  		tmat2x2<T> const & m);
156  	template <typename T> 
157  	typename tmat2x2<T>::col_type operator/ (
158  		tmat2x2<T> const & m, 
159  		typename tmat2x2<T>::row_type const & v);
160  	template <typename T> 
161  	typename tmat2x2<T>::row_type operator/ (
162  		typename tmat2x2<T>::col_type const & v, 
163  		tmat2x2<T> const & m);
164  	template <typename T> 
165  	tmat2x2<T> operator/ (
166  		tmat2x2<T> const & m1, 
167  		tmat2x2<T> const & m2);
168  	template <typename T> 
169  	tmat2x2<T> const operator-  (
170  		tmat2x2<T> const & m);
171  	template <typename T> 
172  	tmat2x2<T> const operator-- (
173  		tmat2x2<T> const & m, 
174  		int);
175  	template <typename T> 
176  	tmat2x2<T> const operator++ (
177  		tmat2x2<T> const & m, 
178  		int);
179  } 
180  	typedef detail::tmat2x2<lowp_float>		lowp_mat2;
181  	typedef detail::tmat2x2<mediump_float>	mediump_mat2;
182  	typedef detail::tmat2x2<highp_float>	highp_mat2;
183  	typedef detail::tmat2x2<lowp_float>		lowp_mat2x2;
184  	typedef detail::tmat2x2<mediump_float>	mediump_mat2x2;
185  	typedef detail::tmat2x2<highp_float>	highp_mat2x2;
186  }
187  #ifndef GLM_EXTERNAL_TEMPLATE
188  #include "type_mat2x2.inl"
189  #endif
190  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memenet.h</h3>
            <pre><code>1  #ifndef snap_memenet_h
2  #define snap_memenet_h
3  #include "Snap.h"
4  #include "memes.h"
5  class TMemeNet;
6  typedef TPt<TMemeNet> PMemeNet;
7  class TMemeNetBs;
8  typedef TPt<TMemeNetBs> PMemeNetBs;
9  class TMemeNetDat {
10  public:
11    TInt UrlId;
12    TSecTm Tm;
13    TIntV QtIdV;
14    TUrlTy UrlTy;
15  public:
16    TMemeNetDat() : UrlId(-1), Tm(), QtIdV(), UrlTy(utUndef) { }
17    TMemeNetDat(TSIn& SIn) : UrlId(SIn), Tm(SIn), QtIdV(SIn), UrlTy(utUndef) { UrlTy=TUrlTy(TInt(SIn).Val);}
18    void Save(TSOut& SOut) const { UrlId.Save(SOut); Tm.Save(SOut); QtIdV.Save(SOut); TInt(UrlTy).Save(SOut); }
19    int GetUrlId() const { return UrlId; }
20    TUrlTy GetUrlTy() const { return UrlTy; }
21    TSecTm GetTm() const { return Tm; }
22  };
23  class TMemeNet : public TNodeNet<TMemeNetDat> { 
24  private:
25    TStr QtStr;
26  public:
27    TMemeNet(const TStr& QuoteStr=TStr()) : QtStr(QuoteStr) { } 
28    TMemeNet(TSIn& SIn) : TNet(SIn), QtStr(SIn) { }
29    void Save(TSOut& SOut) { TNet::Save(SOut); QtStr.Save(SOut); }
30    static PMemeNet New(const TStr& QtStr=TStr()) { return new TMemeNet(QtStr); }
31    static PMemeNet Load(TSIn& SIn) { return new TMemeNet(SIn); }
32    TStr GetStr() const { return QtStr; }
<span onclick='openModal()' class='match'>33    int GetSameDomLinks(const PMemeNetBs& NetBs) const;
34    void DelSameDomLinks(const PMemeNetBs& NetBs);
35    void DrawNet(const TStr& OutFNm) const;
36    void DrawNet(const TStr& OutFNm, const PMemeNetBs& MemeNetBs, const int& MinCcSize) const;
</span>37    friend class TPt<TMemeNet>;
38  };
39  class TMemeNetBs { 
40  private:
41    TCRef CRef;
42    TStrHash<TInt> UrlH; 
43    THash<TInt, PMemeNet> QtIdNetH;
44  public:
45    TMemeNetBs() { }
46    TMemeNetBs(TSIn& SIn) : UrlH(SIn), QtIdNetH(SIn) { }
47    void Save(TSOut& SOut) const { UrlH.Save(SOut); QtIdNetH.Save(SOut); }
48    static PMemeNetBs New() { return new TMemeNetBs(); }
49    static PMemeNetBs Load(TSIn& SIn) { return new TMemeNetBs(SIn); }
50    int GetUrls() const { return UrlH.Len(); }
51    const char *GetUrl(const int& UrlId) const { return UrlH.GetKey(UrlId); }
52    TChA GetDomNm(const int& UrlId) const { return TStrUtil::GetDomNm2(UrlH.GetKey(UrlId)); }
53    TChA GetWebsite(const int& UrlId) const { return TStrUtil::GetWebsite(UrlH.GetKey(UrlId)); }
54    bool IsUrlId(const int& UrlId) const { return UrlId < UrlH.Len(); }
55    bool IsUrl(const char* UrlStr) const { return UrlH.IsKey(UrlStr); }
56    TUrlTy GetUrlTy(const int& UrlId) const { return (TUrlTy) UrlH[UrlId].Val; }
57    TUrlTy GetUrlTy(const char* UrlStr) const { return (TUrlTy) UrlH.GetDat(UrlStr).Val; }
58    int GetUrlId(const char* UrlStr) const { return UrlH.GetKeyId(UrlStr); }
59    int AddUrl(const char* UrlStr, const TUrlTy& UrlTy) { return UrlH.AddDat(UrlStr, UrlTy); }
60    int GetNets() const { return QtIdNetH.Len(); }
61    TIntV GetNetByNzNodes() const;
62    PMemeNet GetNet(const int& NetN) const { return QtIdNetH[NetN]; }
63    void QuoteToDomainSvd() const;
64    void LinkDomainSvd() const;
65    void SaveNetStat(const TStr& OutFNm) const;
66    static PMemeNetBs Build(const PQuoteBs& QtBs, const TStr& MemesFNmWc, const int& TakeTopN);
67    friend class TPt<TMemeNetBs>;
68  };
69  class TBlogPostNet;
70  typedef TPt<TBlogPostNet> PBlogPostNet;
71  class TBlogPostNet : public TNGraph {
72  private:
73    TCRef CRef;
74    THash<TMd5Sig, TSecTm> UrlH; 
75  public:
76    TBlogPostNet() { }
77    TBlogPostNet(TSIn& SIn) : UrlH(SIn) { }
78    void Save(TSOut& SOut) const { UrlH.Save(SOut); }
79    static PBlogPostNet New() { return new TBlogPostNet(); }
80    static PBlogPostNet Load(TSIn& SIn) { return new TBlogPostNet(SIn); }
81    int GetUrls() const { return UrlH.Len(); }
82    int GetUrlId(const char* UrlStr) const { return UrlH.GetKeyId(TMd5Sig(UrlStr)); }
83    int AddUrl(const char* UrlStr, const TSecTm& PostTm) { 
84      const int id=UrlH.AddKey(TMd5Sig(UrlStr)); UrlH[id]=PostTm; return id; }
85    static PBlogPostNet BuildFromQt(const TStr& InFNmWc) {
86      PBlogPostNet Net = TBlogPostNet::New();
87  	{ TMemesDataLoader MDL(InFNmWc);
88  	while (MDL.LoadNext()) { 
89  	  const int UId = Net->AddUrl(MDL.PostUrlStr.CStr(), MDL.PubTm);
90  	  Net->AddNode(UId);
91  	} }
92      TMemesDataLoader MDL(InFNmWc);
93      while (MDL.LoadNext()) {
94        const int UId = Net->GetUrlId(MDL.PostUrlStr.CStr());
95  	  for (int l = 0; l < MDL.LinkV.Len(); l++) {
96  		int UId2 = Net->GetUrlId(MDL.LinkV[l].CStr());
97          if (UId2 == -1) { continue; }
98          Net->AddEdge(UId, UId2);
99        }
100      }
101      TSnap::PrintInfo(Net);
102      return Net;
103    }
104    friend class TPt<TBlogPostNet>;
105  };
106  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type_mat2x2.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-memenet.h</div>
                </div>
                <div class="column column_space"><pre><code>63  		GLM_FUNC_DECL explicit tmat2x2(tmat2x2<U> const & m);
64  		GLM_FUNC_DECL explicit tmat2x2(tmat3x3<T> const & x);
65  		GLM_FUNC_DECL explicit tmat2x2(tmat4x4<T> const & x);
66  		GLM_FUNC_DECL explicit tmat2x2(tmat2x3<T> const & x);
67  		GLM_FUNC_DECL explicit tmat2x2(tmat3x2<T> const & x);
68  		GLM_FUNC_DECL explicit tmat2x2(tmat2x4<T> const & x);
69  		GLM_FUNC_DECL explicit tmat2x2(tmat4x2<T> const & x);
70  		GLM_FUNC_DECL explicit tmat2x2(tmat3x4<T> const & x);
71  		GLM_FUNC_DECL explicit tmat2x2(tmat4x3<T> const & x);
72  		GLM_FUNC_DECL col_type & operator[](size_type i);
73  		GLM_FUNC_DECL col_type const & operator[](size_type i) const;
74  		GLM_FUNC_DECL tmat2x2<T> & operator=(tmat2x2<T> const & m);
</pre></code></div>
                <div class="column column_space"><pre><code>33    int GetSameDomLinks(const PMemeNetBs& NetBs) const;
34    void DelSameDomLinks(const PMemeNetBs& NetBs);
35    void DrawNet(const TStr& OutFNm) const;
36    void DrawNet(const TStr& OutFNm, const PMemeNetBs& MemeNetBs, const int& MinCcSize) const;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    