
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6734693877551026%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_arrival.cpp</h3>
            <pre><code>1  #include <nano/node/block_arrival.hpp>
2  bool nano::block_arrival::add (nano::block_hash const & hash_a)
3  {
4  	nano::lock_guard<nano::mutex> lock{ mutex };
5  	auto now (std::chrono::steady_clock::now ());
6  	auto inserted (arrival.get<tag_sequence> ().emplace_back (nano::block_arrival_info{ now, hash_a }));
7  	auto result (!inserted.second);
8  	return result;
9  }
10  bool nano::block_arrival::recent (nano::block_hash const & hash_a)
11  {
12  	nano::lock_guard<nano::mutex> lock{ mutex };
13  	auto now (std::chrono::steady_clock::now ());
14  	while (arrival.size () > arrival_size_min && arrival.get<tag_sequence> ().front ().arrival + arrival_time_min < now)
15  	{
16  		arrival.get<tag_sequence> ().pop_front ();
17  	}
<span onclick='openModal()' class='match'>18  	return arrival.get<tag_hash> ().find (hash_a) != arrival.get<tag_hash> ().end ();
19  }
20  std::unique_ptr<nano::container_info_component> nano::collect_container_info (block_arrival & block_arrival, std::string const & name)
21  {
22  	std::size_t count = 0;
</span>23  	{
24  		nano::lock_guard<nano::mutex> guard{ block_arrival.mutex };
25  		count = block_arrival.arrival.size ();
26  	}
27  	auto sizeof_element = sizeof (decltype (block_arrival.arrival)::value_type);
28  	auto composite = std::make_unique<container_info_composite> (name);
29  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "arrival", count, sizeof_element }));
30  	return composite;
31  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-vote_processor.cpp</h3>
            <pre><code>1  #include <nano/lib/jsonconfig.hpp>
2  #include <nano/node/transport/inproc.hpp>
3  #include <nano/node/vote_processor.hpp>
4  #include <nano/test_common/chains.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  using namespace std::chrono_literals;
9  TEST (vote_processor, codes)
10  {
11  	nano::test::system system (1);
12  	auto & node (*system.nodes[0]);
13  	nano::keypair key;
14  	auto vote (std::make_shared<nano::vote> (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () }));
15  	auto vote_invalid = std::make_shared<nano::vote> (*vote);
16  	vote_invalid->signature.bytes[0] ^= 1;
17  	auto channel (std::make_shared<nano::transport::inproc::channel> (node, node));
18  	ASSERT_EQ (nano::vote_code::invalid, node.vote_processor.vote_blocking (vote_invalid, channel, false));
19  	ASSERT_NE (nano::vote_code::invalid, node.vote_processor.vote_blocking (vote_invalid, channel, true));
20  	ASSERT_EQ (nano::vote_code::indeterminate, node.vote_processor.vote_blocking (vote, channel));
21  	node.block_confirm (nano::dev::genesis);
22  	ASSERT_NE (nullptr, node.active.election (nano::dev::genesis->qualified_root ()));
23  	ASSERT_EQ (nano::vote_code::vote, node.vote_processor.vote_blocking (vote, channel));
<span onclick='openModal()' class='match'>24  	ASSERT_EQ (nano::vote_code::replay, node.vote_processor.vote_blocking (vote, channel));
25  	ASSERT_EQ (nano::vote_code::invalid, node.vote_processor.vote_blocking (vote_invalid, channel));
26  	node.active.erase (*nano::dev::genesis);
27  	ASSERT_EQ (nano::vote_code::indeterminate, node.vote_processor.vote_blocking (vote, channel));
28  }
29  TEST (vote_processor, flush)
30  {
31  	nano::test::system system (1);
</span>32  	auto & node (*system.nodes[0]);
33  	auto channel (std::make_shared<nano::transport::inproc::channel> (node, node));
34  	for (unsigned i = 0; i < 2000; ++i)
35  	{
36  		auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * (1 + i), 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
37  		node.vote_processor.vote (vote, channel);
38  	}
39  	node.vote_processor.flush ();
40  	ASSERT_TRUE (node.vote_processor.empty ());
41  }
42  TEST (vote_processor, invalid_signature)
43  {
44  	nano::test::system system{ 1 };
45  	auto & node = *system.nodes[0];
46  	auto chain = nano::test::setup_chain (system, node, 1, nano::dev::genesis_key, false);
47  	nano::keypair key;
48  	auto vote = std::make_shared<nano::vote> (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ chain[0]->hash () });
49  	auto vote_invalid = std::make_shared<nano::vote> (*vote);
50  	vote_invalid->signature.bytes[0] ^= 1;
51  	auto channel = std::make_shared<nano::transport::inproc::channel> (node, node);
52  	auto election = nano::test::start_election (system, node, chain[0]->hash ());
53  	ASSERT_NE (election, nullptr);
54  	ASSERT_EQ (1, election->votes ().size ());
55  	node.vote_processor.vote (vote_invalid, channel);
56  	ASSERT_TIMELY (5s, 1 == election->votes ().size ());
57  	node.vote_processor.vote (vote, channel);
58  	ASSERT_TIMELY (5s, 2 == election->votes ().size ());
59  }
60  TEST (vote_processor, no_capacity)
61  {
62  	nano::test::system system;
63  	nano::node_flags node_flags;
64  	node_flags.vote_processor_capacity = 0;
65  	auto & node (*system.add_node (node_flags));
66  	nano::keypair key;
67  	auto vote (std::make_shared<nano::vote> (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () }));
68  	auto channel (std::make_shared<nano::transport::inproc::channel> (node, node));
69  	ASSERT_TRUE (node.vote_processor.vote (vote, channel));
70  }
71  TEST (vote_processor, overflow)
72  {
73  	nano::test::system system;
74  	nano::node_flags node_flags;
75  	node_flags.vote_processor_capacity = 1;
76  	auto & node (*system.add_node (node_flags));
77  	nano::keypair key;
78  	auto vote (std::make_shared<nano::vote> (key.pub, key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () }));
79  	auto channel (std::make_shared<nano::transport::inproc::channel> (node, node));
80  	auto start_time = std::chrono::system_clock::now ();
81  	size_t not_processed{ 0 };
82  	size_t const total{ 1000 };
83  	for (unsigned i = 0; i < total; ++i)
84  	{
85  		if (node.vote_processor.vote (vote, channel))
86  		{
87  			++not_processed;
88  		}
89  	}
90  	ASSERT_GT (not_processed, 0);
91  	ASSERT_LT (not_processed, total);
92  	ASSERT_EQ (not_processed, node.stats.count (nano::stat::type::vote, nano::stat::detail::vote_overflow));
93  	ASSERT_LT (std::chrono::system_clock::now () - start_time, 10s);
94  }
95  namespace nano
96  {
97  TEST (vote_processor, weights)
98  {
99  	nano::test::system system (4);
100  	auto & node (*system.nodes[0]);
101  	auto const online = node.config.online_weight_minimum.number ();
102  	auto const level0 = online / 5000; 
103  	auto const level1 = online / 500; 
104  	auto const level2 = online / 50; 
105  	nano::keypair key0;
106  	nano::keypair key1;
107  	nano::keypair key2;
108  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
109  	system.wallet (1)->insert_adhoc (key0.prv);
110  	system.wallet (2)->insert_adhoc (key1.prv);
111  	system.wallet (3)->insert_adhoc (key2.prv);
112  	system.wallet (1)->store.representative_set (system.nodes[1]->wallets.tx_begin_write (), key0.pub);
113  	system.wallet (2)->store.representative_set (system.nodes[2]->wallets.tx_begin_write (), key1.pub);
114  	system.wallet (3)->store.representative_set (system.nodes[3]->wallets.tx_begin_write (), key2.pub);
115  	system.wallet (0)->send_sync (nano::dev::genesis_key.pub, key0.pub, level0);
116  	system.wallet (0)->send_sync (nano::dev::genesis_key.pub, key1.pub, level1);
117  	system.wallet (0)->send_sync (nano::dev::genesis_key.pub, key2.pub, level2);
118  	ASSERT_TIMELY (10s, node.ledger.cache.rep_weights.get_rep_amounts ().size () == 4);
119  	node.vote_processor.calculate_weights ();
120  	ASSERT_EQ (node.vote_processor.representatives_1.end (), node.vote_processor.representatives_1.find (key0.pub));
121  	ASSERT_EQ (node.vote_processor.representatives_2.end (), node.vote_processor.representatives_2.find (key0.pub));
122  	ASSERT_EQ (node.vote_processor.representatives_3.end (), node.vote_processor.representatives_3.find (key0.pub));
123  	ASSERT_NE (node.vote_processor.representatives_1.end (), node.vote_processor.representatives_1.find (key1.pub));
124  	ASSERT_EQ (node.vote_processor.representatives_2.end (), node.vote_processor.representatives_2.find (key1.pub));
125  	ASSERT_EQ (node.vote_processor.representatives_3.end (), node.vote_processor.representatives_3.find (key1.pub));
126  	ASSERT_NE (node.vote_processor.representatives_1.end (), node.vote_processor.representatives_1.find (key2.pub));
127  	ASSERT_NE (node.vote_processor.representatives_2.end (), node.vote_processor.representatives_2.find (key2.pub));
128  	ASSERT_EQ (node.vote_processor.representatives_3.end (), node.vote_processor.representatives_3.find (key2.pub));
129  	ASSERT_NE (node.vote_processor.representatives_1.end (), node.vote_processor.representatives_1.find (nano::dev::genesis_key.pub));
130  	ASSERT_NE (node.vote_processor.representatives_2.end (), node.vote_processor.representatives_2.find (nano::dev::genesis_key.pub));
131  	ASSERT_NE (node.vote_processor.representatives_3.end (), node.vote_processor.representatives_3.find (nano::dev::genesis_key.pub));
132  }
133  }
134  TEST (vote_processor, no_broadcast_local)
135  {
136  	nano::test::system system;
137  	nano::node_flags flags;
138  	flags.disable_request_loop = true;
139  	nano::node_config config1, config2;
140  	config1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
141  	auto & node (*system.add_node (config1, flags));
142  	config2.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
143  	config2.peering_port = system.get_available_port ();
144  	system.add_node (config2, flags);
145  	nano::block_builder builder;
146  	std::error_code ec;
147  	nano::keypair key;
148  	std::shared_ptr<nano::block> send = builder.state ()
149  										.account (nano::dev::genesis_key.pub)
150  										.representative (nano::dev::genesis_key.pub)
151  										.previous (nano::dev::genesis->hash ())
152  										.balance (2 * node.config.vote_minimum.number ())
153  										.link (key.pub)
154  										.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
155  										.work (*system.work.generate (nano::dev::genesis->hash ()))
156  										.build (ec);
157  	ASSERT_FALSE (ec);
158  	ASSERT_EQ (nano::process_result::progress, node.process_local (send).value ().code);
159  	ASSERT_TIMELY (10s, !node.active.empty ());
160  	ASSERT_EQ (2 * node.config.vote_minimum.number (), node.weight (nano::dev::genesis_key.pub));
161  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
162  	node.wallets.compute_reps ();
163  	ASSERT_TRUE (node.wallets.reps ().exists (nano::dev::genesis_key.pub));
164  	ASSERT_FALSE (node.wallets.reps ().have_half_rep ()); 
165  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), nano::vote::duration_max, std::vector<nano::block_hash>{ send->hash () });
166  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote));
167  	auto election (node.active.election (send->qualified_root ()));
168  	ASSERT_NE (nullptr, election);
169  	auto votes (election->votes ());
170  	auto existing (votes.find (nano::dev::genesis_key.pub));
171  	ASSERT_NE (votes.end (), existing);
172  	ASSERT_EQ (vote->timestamp (), existing->second.timestamp);
173  	ASSERT_EQ (0, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
174  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::out));
175  }
176  TEST (vote_processor, local_broadcast_without_a_representative)
177  {
178  	nano::test::system system;
179  	nano::node_flags flags;
180  	flags.disable_request_loop = true;
181  	nano::node_config config1, config2;
182  	config1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
183  	auto & node (*system.add_node (config1, flags));
184  	config2.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
185  	config2.peering_port = system.get_available_port ();
186  	system.add_node (config2, flags);
187  	nano::block_builder builder;
188  	std::error_code ec;
189  	nano::keypair key;
190  	std::shared_ptr<nano::block> send = builder.state ()
191  										.account (nano::dev::genesis_key.pub)
192  										.representative (nano::dev::genesis_key.pub)
193  										.previous (nano::dev::genesis->hash ())
194  										.balance (node.config.vote_minimum.number ())
195  										.link (key.pub)
196  										.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
197  										.work (*system.work.generate (nano::dev::genesis->hash ()))
198  										.build (ec);
199  	ASSERT_FALSE (ec);
200  	ASSERT_EQ (nano::process_result::progress, node.process_local (send).value ().code);
201  	ASSERT_TIMELY (10s, !node.active.empty ());
202  	ASSERT_EQ (node.config.vote_minimum, node.weight (nano::dev::genesis_key.pub));
203  	node.block_confirm (send);
204  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), nano::vote::duration_max, std::vector<nano::block_hash>{ send->hash () });
205  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote));
206  	auto election (node.active.election (send->qualified_root ()));
207  	ASSERT_NE (nullptr, election);
208  	auto votes (election->votes ());
209  	auto existing (votes.find (nano::dev::genesis_key.pub));
210  	ASSERT_NE (votes.end (), existing);
211  	ASSERT_EQ (vote->timestamp (), existing->second.timestamp);
212  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
213  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::out));
214  }
215  TEST (vote_processor, no_broadcast_local_with_a_principal_representative)
216  {
217  	nano::test::system system;
218  	nano::node_flags flags;
219  	flags.disable_request_loop = true;
220  	nano::node_config config1, config2;
221  	config1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
222  	auto & node (*system.add_node (config1, flags));
223  	config2.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
224  	config2.peering_port = system.get_available_port ();
225  	system.add_node (config2, flags);
226  	nano::block_builder builder;
227  	std::error_code ec;
228  	nano::keypair key;
229  	std::shared_ptr<nano::block> send = builder.state ()
230  										.account (nano::dev::genesis_key.pub)
231  										.representative (nano::dev::genesis_key.pub)
232  										.previous (nano::dev::genesis->hash ())
233  										.balance (nano::dev::constants.genesis_amount - 2 * node.config.vote_minimum.number ())
234  										.link (key.pub)
235  										.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
236  										.work (*system.work.generate (nano::dev::genesis->hash ()))
237  										.build (ec);
238  	ASSERT_FALSE (ec);
239  	ASSERT_EQ (nano::process_result::progress, node.process_local (send).value ().code);
240  	ASSERT_TIMELY (10s, !node.active.empty ());
241  	ASSERT_EQ (nano::dev::constants.genesis_amount - 2 * node.config.vote_minimum.number (), node.weight (nano::dev::genesis_key.pub));
242  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
243  	node.wallets.compute_reps ();
244  	ASSERT_TRUE (node.wallets.reps ().exists (nano::dev::genesis_key.pub));
245  	ASSERT_TRUE (node.wallets.reps ().have_half_rep ()); 
246  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), nano::vote::duration_max, std::vector<nano::block_hash>{ send->hash () });
247  	ASSERT_EQ (nano::vote_code::vote, node.active.vote (vote));
248  	auto election (node.active.election (send->qualified_root ()));
249  	ASSERT_NE (nullptr, election);
250  	auto votes (election->votes ());
251  	auto existing (votes.find (nano::dev::genesis_key.pub));
252  	ASSERT_NE (votes.end (), existing);
253  	ASSERT_EQ (vote->timestamp (), existing->second.timestamp);
254  	ASSERT_EQ (0, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
255  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::out));
256  }
257  TEST (vote, timestamp_and_duration_masking)
258  {
259  	nano::test::system system;
260  	nano::keypair key;
261  	auto hash = std::vector<nano::block_hash>{ nano::dev::genesis->hash () };
262  	auto vote = std::make_shared<nano::vote> (key.pub, key.prv, 0x123f, 0xf, hash);
263  	ASSERT_EQ (vote->timestamp (), 0x1230);
264  	ASSERT_EQ (vote->duration ().count (), 524288);
265  	ASSERT_EQ (vote->duration_bits (), 0xf);
266  }
267  TEST (vote, empty_hashes)
268  {
269  	nano::keypair key;
270  	auto vote = std::make_shared<nano::vote> (key.pub, key.prv, 0, 0, std::vector<nano::block_hash>{} &bsol;* empty */);
271  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_arrival.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-vote_processor.cpp</div>
                </div>
                <div class="column column_space"><pre><code>18  	return arrival.get<tag_hash> ().find (hash_a) != arrival.get<tag_hash> ().end ();
19  }
20  std::unique_ptr<nano::container_info_component> nano::collect_container_info (block_arrival & block_arrival, std::string const & name)
21  {
22  	std::size_t count = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>24  	ASSERT_EQ (nano::vote_code::replay, node.vote_processor.vote_blocking (vote, channel));
25  	ASSERT_EQ (nano::vote_code::invalid, node.vote_processor.vote_blocking (vote_invalid, channel));
26  	node.active.erase (*nano::dev::genesis);
27  	ASSERT_EQ (nano::vote_code::indeterminate, node.vote_processor.vote_blocking (vote, channel));
28  }
29  TEST (vote_processor, flush)
30  {
31  	nano::test::system system (1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    