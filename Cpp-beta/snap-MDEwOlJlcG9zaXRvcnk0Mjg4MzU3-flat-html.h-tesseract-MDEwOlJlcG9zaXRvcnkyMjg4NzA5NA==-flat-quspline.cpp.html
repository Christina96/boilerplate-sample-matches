
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.321839080459771%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-html.h</h3>
            <pre><code>1  #include "bd.h"
2  ClassHdTP(THtmlTok, PHtmlTok)
3  ClassHdTP(THtmlDoc, PHtmlDoc)
4  typedef enum {
5    hlctSpace, hlctAlpha, hlctNum, hlctSym,
6    hlctLTag, hlctRTag, hlctEof} THtmlLxChTy;
7  ClassTP(THtmlLxChDef, PHtmlLxChDef)
8  private:
<span onclick='openModal()' class='match'>9    TIntV ChTyV;
10    TChV UcChV;
11    TChV LcChV;
12    TStrStrH EscStrH;
13    void SetUcCh(const char& UcCh, const char& LcCh);
14    void SetUcCh(const TStr& Str);
15    void SetChTy(const THtmlLxChTy& ChTy, const TStr& Str);
16    void SetEscStr(const TStr& SrcStr, const TStr& DstStr);
</span>17  public:
18    THtmlLxChDef();
19    THtmlLxChDef(TSIn& SIn): ChTyV(SIn), UcChV(SIn), LcChV(SIn), EscStrH(SIn){}
20    static PHtmlLxChDef Load(TSIn& SIn){return new THtmlLxChDef(SIn);}
21    void Save(TSOut& SOut){
22      ChTyV.Save(SOut); UcChV.Save(SOut); LcChV.Save(SOut); EscStrH.Save(SOut);}
23    THtmlLxChDef& operator=(const THtmlLxChDef&){Fail; return *this;}
24    int GetChTy(const char& Ch) const {return ChTyV[Ch-TCh::Mn];}
25    bool IsEoln(const char& Ch) const {return (Ch==TCh::CrCh)||(Ch==TCh::LfCh);}
26    bool IsWs(const char& Ch) const {
27      return (Ch==' ')||(Ch==TCh::TabCh)||(Ch==TCh::CrCh)||(Ch==TCh::LfCh);}
28    bool IsSpace(const char& Ch) const {return int(ChTyV[Ch-TCh::Mn])==hlctSpace;}
29    bool IsAlpha(const char& Ch) const {return int(ChTyV[Ch-TCh::Mn])==hlctAlpha;}
30    bool IsNum(const char& Ch) const {return int(ChTyV[Ch-TCh::Mn])==hlctNum;}
31    bool IsAlNum(const char& Ch) const {
32      return (int(ChTyV[Ch-TCh::Mn])==hlctAlpha)||(int(ChTyV[Ch-TCh::Mn])==hlctNum);}
33    bool IsSym(const char& Ch) const {return int(ChTyV[Ch-TCh::Mn])==hlctSym;}
34    bool IsUrl(const char& Ch) const {
35      int ChTy=ChTyV[Ch-TCh::Mn];
36      return (ChTy==hlctAlpha)||(ChTy==hlctNum)||
37       (Ch=='.')||(Ch=='-')||(Ch==':')||(Ch=='/')||(Ch=='~');}
38    bool IsUc(const char& Ch) const {return Ch==UcChV[Ch-TCh::Mn];}
39    bool IsLc(const char& Ch) const {return Ch==LcChV[Ch-TCh::Mn];}
40    char GetUc(const char& Ch) const {return UcChV[Ch-TCh::Mn];}
41    char GetLc(const char& Ch) const {return LcChV[Ch-TCh::Mn];}
42    void GetUcChA(TChA& ChA) const {
43      for (int ChN=0; ChN<ChA.Len(); ChN++){ChA.PutCh(ChN, GetUc(ChA[ChN]));}}
44    void GetLcChA(TChA& ChA) const {
45      for (int ChN=0; ChN<ChA.Len(); ChN++){ChA.PutCh(ChN, GetLc(ChA[ChN]));}}
46    TStr GetUcStr(const TStr& Str) const {
47      TChA ChA(Str); GetUcChA(ChA); return ChA;}
48    TStr GetLcStr(const TStr& Str) const {
49      TChA ChA(Str); GetLcChA(ChA); return ChA;}
50    TStr GetEscStr(const TStr& Str) const;
51    static PHtmlLxChDef ChDef;
52    static PHtmlLxChDef GetChDef(){IAssert(!ChDef.Empty()); return ChDef;}
53    static THtmlLxChDef& GetChDefRef(){IAssert(!ChDef.Empty()); return *ChDef;}
54    static TStr GetCSZFromYuascii(const TChA& ChA);
55    static TStr GetCSZFromWin1250(const TChA& ChA);
56    static TStr GetWin1250FromYuascii(const TChA& ChA);
57    static TStr GetIsoCeFromYuascii(const TChA& ChA);
58  };
59  typedef enum {
60    hsyUndef, hsyStr, hsyNum, hsySSym, hsyUrl,
61    hsyBTag, hsyETag, hsyMTag, hsyEof} THtmlLxSym;
62  class THtmlLx{
63  private:
64    static THtmlLxChDef ChDef;
65    PSIn SIn;
66    TSIn& RSIn;
67    bool DoParseArg;
68    TChA ChStack;
69    char Ch;
70    int ChX;
71    bool EscCh;
72    TChA EscChA;
73    TChA ArgNm;
74    TChA ArgVal;
75    void GetCh(){
76      if (ChStack.Empty()){
77        if (RSIn.Eof()){Ch=TCh::EofCh;} else {Ch=RSIn.GetCh(); ChX++;}
78      } else {
79        Ch=ChStack.Pop(); ChX++;
80      }
81      SymChA+=Ch;
82    }
83    void GetEscCh();
84    void GetMetaTag();
85    void GetTag();
86  public:
87    THtmlLxSym Sym;
88    int SymBChX, SymEChX;
89    TChA ChA;
90    TChA UcChA;
91    TChA SymChA;
92    int PreSpaces;
93    TChA PreSpaceChA;
94    typedef TStrKdV TArgNmValV;
95    TArgNmValV ArgNmValV;
96  public:
97    THtmlLx(const PSIn& _SIn, const bool& _DoParseArg=true):
98      SIn(_SIn), RSIn(*SIn), DoParseArg(_DoParseArg),
99      ChStack(), Ch(' '), ChX(0), EscCh(false),
100      EscChA(), ArgNm(), ArgVal(),
101      Sym(hsyUndef), SymBChX(0), SymEChX(0), ChA(), UcChA(),
102      PreSpaces(0), PreSpaceChA(), ArgNmValV(){}
103    THtmlLx& operator=(const THtmlLx&){Fail; return *this;}
104    void PutCh(const char& _Ch){
105      ChStack.Push(Ch); if (!SymChA.Empty()){SymChA.Pop();} Ch=_Ch; ChX--;}
106    void PutStr(const TStr& Str){
107      for (int ChN=Str.Len()-1; ChN>=0; ChN--){PutCh(Str[ChN]);}}
108    THtmlLxSym GetSym();
109    PHtmlTok GetTok(const bool& DoUc=true);
110    TStr GetPreSpaceStr() const {
111      return TStr::GetSpaceStr(PreSpaces);}
112    int GetArgs() const {return ArgNmValV.Len();}
113    TStr GetArgNm(const int& ArgN) const {return ArgNmValV[ArgN].Key;}
114    TStr GetArgVal(const int& ArgN) const {return ArgNmValV[ArgN].Dat;}
115    bool IsArg(const TStr& ArgNm) const {return ArgNmValV.IsIn(TStrKd(ArgNm));}
116    TStr GetArg(const TStr& ArgNm, const TStr& DfArgVal=TStr()) const {
117      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
118      if (ArgN==-1){return DfArgVal;} else {return ArgNmValV[ArgN].Dat;}}
119    void PutArg(const TStr& ArgNm, const TStr& ArgVal){
120      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
121      if (ArgN==-1){ArgNmValV.Add(TStrKd(ArgNm, ArgVal));}
122      else {ArgNmValV[ArgN]=TStrKd(ArgNm, ArgVal);}}
123    TStr GetFullBTagStr() const;
124    void MoveToStrOrEof(const TStr& Str);
125    void MoveToBTagOrEof(const TStr& TagNm);
126    void MoveToBTag2OrEof(const TStr& TagNm1, const TStr& TagNm2);
127    void MoveToBTag3OrEof(const TStr& TagNm1, const TStr& TagNm2, const TStr& TagNm3);
128    void MoveToBTagOrETagOrEof(const TStr& BTagNm, const TStr& ETagNm);
129    void MoveToBTagArgOrEof(
130     const TStr& TagNm, const TStr& ArgNm, const TStr& ArgVal);
131    void MoveToBTagArg2OrEof(const TStr& TagNm,
132     const TStr& ArgNm1, const TStr& ArgVal1,
133     const TStr& ArgNm2, const TStr& ArgVal2, const bool& AndOpP=true);
134    void MoveToBTagOrEof(
135     const TStr& TagNm1, const TStr& ArgNm1, const TStr& ArgVal1,
136     const TStr& TagNm2, const TStr& ArgNm2, const TStr& ArgVal2);
137    void MoveToETagOrEof(const TStr& TagNm);
138    TStr GetTextOnlyStrToEof();
139    TStr GetStrToBTag(const TStr& TagNm, const bool& TxtOnlyP=false);
140    TStr GetStrToBTag(const TStr& TagNm, const TStr& ArgNm,
141     const TStr& ArgVal, const bool& TxtOnlyP=false);
142    TStr GetStrToETag(const TStr& TagNm, const bool& TxtOnlyP=false);
143    TStr GetStrToETag2(const TStr& TagNm1, const TStr& TagNm2, const bool& TxtOnlyP=false);
144    TStr GetStrInTag(const TStr& TagNm, const bool& TxtOnlyP=false);
145    TStr GetHRefBeforeStr(const TStr& Str);
146    bool IsGetBTag(const TStr& TagNm);
147    bool IsGetETag(const TStr& TagNm);
148    static TStr GetSymStr(const THtmlLxSym& Sym);
149    static TStr GetEscapedStr(const TChA& ChA);
150    static TStr GetAsciiStr(const TChA& ChA, const char& GenericCh='_');
151    static void GetTokStrV(const TStr& Str, TStrV& TokStrV);
152    static TStr GetNoTag(const TStr& Str);
153  };
154  ClassTPV(THtmlTok, PHtmlTok, THtmlTokV)
155  private:
156    THtmlLxSym Sym;
157    TStr Str;
158    THtmlLx::TArgNmValV ArgNmValV;
159  public:
160    THtmlTok(): Sym(hsyUndef), Str(), ArgNmValV(){}
161    THtmlTok(const THtmlLxSym& _Sym):
162      Sym(_Sym), Str(), ArgNmValV(){}
163    THtmlTok(const THtmlLxSym& _Sym, const TStr& _Str):
164      Sym(_Sym), Str(_Str), ArgNmValV(){}
165    THtmlTok(const THtmlLxSym& _Sym, const TStr& _Str,
166     const THtmlLx::TArgNmValV& _ArgNmValV):
167      Sym(_Sym), Str(_Str), ArgNmValV(_ArgNmValV){}
168    THtmlTok(TSIn&){Fail;}
169    static PHtmlTok Load(TSIn&){Fail; return NULL;}
170    void Save(TSOut&){Fail;}
171    THtmlTok& operator=(const THtmlTok&){Fail; return *this;}
172    THtmlLxSym GetSym() const {return Sym;}
173    TStr GetStr() const {return Str;}
174    TStr GetFullStr() const;
175    bool IsArg(const TStr& ArgNm) const {
176      return ArgNmValV.SearchForw(TStrKd(ArgNm))!=-1;}
177    TStr GetArg(const TStr& ArgNm) const {
178      return ArgNmValV[ArgNmValV.SearchForw(TStrKd(ArgNm))].Dat;}
179    TStr GetArg(const TStr& ArgNm, const TStr& DfArgVal) const {
180      int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
181      if (ArgN==-1){return DfArgVal;} else {return ArgNmValV[ArgN].Dat;}}
182    bool IsUrlTok(TStr& RelUrlStr) const;
183    bool IsRedirUrlTok() const;
184    void SaveTxt(const PSOut& SOut, const bool& TxtMode=true);
185    static const TStr ATagNm;
186    static const TStr AreaTagNm;
187    static const TStr BrTagNm;
188    static const TStr CardTagNm;
189    static const TStr CenterTagNm;
190    static const TStr FrameTagNm;
191    static const TStr H1TagNm;
192    static const TStr H2TagNm;
193    static const TStr H3TagNm;
194    static const TStr H4TagNm;
195    static const TStr H5TagNm;
196    static const TStr H6TagNm;
197    static const TStr ImgTagNm;
198    static const TStr LiTagNm;
199    static const TStr MetaTagNm;
200    static const TStr PTagNm;
201    static const TStr UlTagNm;
202    static const TStr TitleTagNm;
203    static const TStr TitleETagNm;
204    static const TStr AltArgNm;
205    static const TStr HRefArgNm;
206    static const TStr SrcArgNm;
207    static const TStr TitleArgNm;
208    static const TStr HttpEquivArgNm;
209    static bool IsBreakTag(const TStr& TagNm);
210    static bool IsBreakTok(const PHtmlTok& Tok);
211    static bool IsHTag(const TStr& TagNm, int& HTagN);
212    static PHtmlTok GetHTok(const bool& IsBTag, const int& HTagN);
213  };
214  typedef enum {
215    hdtAll, hdtStr, hdtStrNum, hdtTag, hdtA, hdtHRef, hdtUL} THtmlDocType;
216  ClassTPV(THtmlDoc, PHtmlDoc, THtmlDocV)
217  private:
218    THtmlTokV TokV;
219  public:
220    THtmlDoc(): TokV(){}
221    THtmlDoc(
222     const PSIn& SIn, const THtmlDocType& Type=hdtAll, const bool& DoUc=true);
223    static PHtmlDoc New(
224     const PSIn& SIn, const THtmlDocType& Type=hdtAll, const bool& DoUc=true){
225      return PHtmlDoc(new THtmlDoc(SIn, Type, DoUc));}
226    THtmlDoc(TSIn&){Fail;}
227    static PHtmlDoc Load(TSIn&){Fail; return NULL;}
228    void Save(TSOut&){Fail;}
229    THtmlDoc& operator=(const THtmlDoc&){Fail; return *this;}
230    int GetToks() const {return TokV.Len();}
231    PHtmlTok GetTok(const int& TokN) const {return TokV[TokN];}
232    PHtmlTok GetTok(const int& TokN, THtmlLxSym& Sym, TStr& Str) const {
233      Sym=TokV[TokN]->GetSym(); Str=TokV[TokN]->GetStr(); return TokV[TokN];}
234    void AddTokV(const THtmlTokV& _TokV){TokV.AddV(_TokV);}
235    static TStr GetTxtLnDoc(const TStr& HtmlStr);
236    static TStr GetTxtLnDoc(const TStr& HtmlStr, const TStr& BaseUrlStr,
237     const bool& OutUrlP, const bool& OutTagsP);
238    static PHtmlDoc LoadTxt(
239     const TStr& FNm, const THtmlDocType& Type=hdtAll, const bool& DoUc=true){
240      PSIn SIn=TFIn::New(FNm); return PHtmlDoc(new THtmlDoc(SIn, Type, DoUc));}
241    void SaveTxt(const PSOut& SOut, const bool& TxtMode=true) const;
242    static void SaveHtmlToTxt(
243     const TStr& HtmlStr, const PSOut& TxtSOut, const TStr& BaseUrlStr,
244     const bool& OutUrlP, const bool& OutToksP);
245    static void SaveHtmlToTxt(
246     const TStr& HtmlStr, const TStr& TxtFNm, const TStr& BaseUrlStr,
247     const bool& OutUrlP, const bool& OutToksP);
248    static void SaveHtmlToXml(
249     const TStr& HtmlStr, const PSOut& XmlSOut, const TStr& BaseUrlStr,
250     const bool& OutTextP, const bool& OutUrlP, const bool& OutToksP,
251     const bool& OutTagsP, const bool& OutArgsP);
252    static void SaveHtmlToXml(
253     const TStr& HtmlStr, const TStr& XmlFNm, const TStr& BaseUrlStr,
254     const bool& OutTextP, const bool& OutUrlP, const bool& OutToksP,
255     const bool& OutTagsP, const bool& OutArgsP);
256    static TLxSym GetLxSym(const THtmlLxSym& HtmlLxSym, const TChA& ChA);
257    static bool _IsTagRedir(
258     const TStr& TagStr, const TStr& ArgNm, THtmlLx& Lx,
259     const TStr& BaseUrlStr, const TStr& RedirUrlStr);
260    static TStr GetRedirHtmlDocStr(const TStr& HtmlStr,
261     const TStr& BaseUrlStr, const TStr& RedirUrlStr);
262  };
263  ClassTP(THtmlHldV, PHtmlHldV)
264  private:
265    PHtmlDoc RefHtmlDoc;
266    THtmlDocV HldV;
267  public:
268    THtmlHldV(const PHtmlDoc& _RefHtmlDoc, const int& HldWnLen=10);
269    THtmlHldV(TSIn&){Fail;}
270    static PHtmlHldV Load(TSIn&){Fail; return NULL;}
271    void Save(TSOut&){Fail;}
272    THtmlHldV& operator=(const THtmlHldV&){Fail; return *this;}
273    PHtmlDoc GetRefHtmlDoc(){return RefHtmlDoc;}
274    int GetHlds(){return HldV.Len();}
275    PHtmlDoc GetHld(const int& HldN){return HldV[HldN];}
276  };
277  ClassTPV(TWebPg, PWebPg, TWebPgV)
278  private:
279    TStrV UrlStrV;
280    TStrV IpNumV;
281    PHttpResp HttpResp;
282    uint64 FetchMSecs;
283  public:
284    TWebPg(): UrlStrV(), IpNumV(), HttpResp(){}
285    TWebPg(const TStrV& _UrlStrV, const TStrV& _IpNumV, const PHttpResp& _HttpResp):
286      UrlStrV(_UrlStrV), IpNumV(_IpNumV), HttpResp(_HttpResp){}
287    static PWebPg New(const TStrV& UrlStrV, const TStrV& IpNumV, const PHttpResp& HttpResp){
288      return new TWebPg(UrlStrV, IpNumV, HttpResp);}
289    static PWebPg New(const TStrV& UrlStrV, const PHttpResp& HttpResp){
290      return new TWebPg(UrlStrV, TStrV(), HttpResp);}
291    static PWebPg New(const TStr& UrlStr, const PHttpResp& HttpResp){
292      TStrV UrlStrV; UrlStrV.Add(UrlStr);
293      return new TWebPg(UrlStrV, TStrV(), HttpResp);}
294    ~TWebPg(){}
295    TWebPg(TSIn&){Fail;}
296    static PWebPg Load(TSIn&){Fail; return NULL;}
297    void Save(TSOut&){Fail;}
298    TWebPg& operator=(const TWebPg&){Fail; return *this;}
299    int GetUrls() const {return UrlStrV.Len();}
300    TStr GetUrlStr(const int& UrlN=-1) const {
301      if (UrlN==-1){return UrlStrV.Last();} else {return UrlStrV[UrlN];}}
302    PUrl GetUrl(const int& UrlN=-1) const {
303      TStr UrlStr;
304      if (UrlN==-1){UrlStr=UrlStrV.Last();} else {UrlStr=UrlStrV[UrlN];}
305      return TUrl::New(UrlStr);}
306    int GetIps() const {return IpNumV.Len();}
307    TStr GetIpNum(const int& IpN=-1) const {
308      if (IpN==-1){return IpNumV.Last();} else {return IpNumV[IpN];}}
309    PHttpResp GetHttpResp() const {return HttpResp;}
310    TStr GetHttpHdStr() const {return GetHttpResp()->GetHdStr();}
311    TStr GetHttpBodyAsStr() const {return GetHttpResp()->GetBodyAsStr();}
312    void GetOutUrlV(TUrlV& OutUrlV, TUrlV& OutRedirUrlV) const;
313    void GetOutUrlV(TUrlV& OutUrlV) const {
314      TUrlV OutRedirUrlV; GetOutUrlV(OutUrlV, OutRedirUrlV);}
315    void GetOutDescUrlStrKdV(TStrKdV& OutDescUrlStrKdV) const;
316    void PutFetchMSecs(const uint64& _FetchMSecs){FetchMSecs=_FetchMSecs;}
317    uint64 GetFetchMSecs() const {return FetchMSecs;}
318    void SaveAsHttpBody(const TStr& FNm) const;
319    void SaveAsHttp(const TStr& FNm) const;
320    bool IsTxt() const;
321  };
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-quspline.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "quspline.h"
5  #include "points.h"   
6  #include "quadlsq.h"  
7  #include "quadratc.h" 
8  #include <allheaders.h> 
9  #include "pix.h"        
10  namespace tesseract {
11  #define QSPLINE_PRECISION 16 
12  QSPLINE::QSPLINE(     
13      int32_t count,    
14      int32_t *xstarts, 
15      double *coeffs    
16  ) {
17    int32_t index; 
18    xcoords = new int32_t[count + 1];
19    quadratics = new QUAD_COEFFS[count];
20    segments = count;
21    for (index = 0; index < segments; index++) {
22      xcoords[index] = xstarts[index];
23      quadratics[index] =
24          QUAD_COEFFS(coeffs[index * 3], coeffs[index * 3 + 1], coeffs[index * 3 + 2]);
25    }
26    xcoords[index] = xstarts[index];
27  }
28  QSPLINE::QSPLINE(               
<span onclick='openModal()' class='match'>29      int xstarts[],              
30      int segcount,               
31      int xpts[],                 
32      int ypts[], int pointcount, 
33      int degree                  
34  ) {
35    int pointindex;    &bsol;*no along text line */
</span>36    int segment;       &bsol;*segment no */
37    int32_t *ptcounts; 
38    QLSQ qlsq;         &bsol;*accumulator */
39    segments = segcount;
40    xcoords = new int32_t[segcount + 1];
41    ptcounts = new int32_t[segcount + 1];
42    quadratics = new QUAD_COEFFS[segcount];
43    memmove(xcoords, xstarts, (segcount + 1) * sizeof(int32_t));
44    ptcounts[0] = 0; &bsol;*none in any yet */
45    for (segment = 0, pointindex = 0; pointindex < pointcount; pointindex++) {
46      while (segment < segcount && xpts[pointindex] >= xstarts[segment]) {
47        segment++; &bsol;*try next segment */
48        ptcounts[segment] = ptcounts[segment - 1];
49      }
50      ptcounts[segment]++; &bsol;*no in previous partition */
51    }
52    while (segment < segcount) {
53      segment++;
54      ptcounts[segment] = ptcounts[segment - 1];
55    }
56    for (segment = 0; segment < segcount; segment++) {
57      qlsq.clear();
58      pointindex = ptcounts[segment];
59      if (pointindex > 0 && xpts[pointindex] != xpts[pointindex - 1] &&
60          xpts[pointindex] != xstarts[segment]) {
61        qlsq.add(xstarts[segment],
62                 ypts[pointindex - 1] + (ypts[pointindex] - ypts[pointindex - 1]) *
63                                            (xstarts[segment] - xpts[pointindex - 1]) /
64                                            (xpts[pointindex] - xpts[pointindex - 1]));
65      }
66      for (; pointindex < ptcounts[segment + 1]; pointindex++) {
67        qlsq.add(xpts[pointindex], ypts[pointindex]);
68      }
69      if (pointindex > 0 && pointindex < pointcount && xpts[pointindex] != xstarts[segment + 1]) {
70        qlsq.add(xstarts[segment + 1],
71                 ypts[pointindex - 1] + (ypts[pointindex] - ypts[pointindex - 1]) *
72                                            (xstarts[segment + 1] - xpts[pointindex - 1]) /
73                                            (xpts[pointindex] - xpts[pointindex - 1]));
74      }
75      qlsq.fit(degree);
76      quadratics[segment].a = qlsq.get_a();
77      quadratics[segment].b = qlsq.get_b();
78      quadratics[segment].c = qlsq.get_c();
79    }
80    delete[] ptcounts;
81  }
82  QSPLINE::QSPLINE( 
83      const QSPLINE &src) {
84    segments = 0;
85    xcoords = nullptr;
86    quadratics = nullptr;
87    *this = src;
88  }
89  QSPLINE::~QSPLINE() {
90    delete[] xcoords;
91    delete[] quadratics;
92  }
93  QSPLINE &QSPLINE::operator=( 
94      const QSPLINE &source) {
95    delete[] xcoords;
96    delete[] quadratics;
97    segments = source.segments;
98    xcoords = new int32_t[segments + 1];
99    quadratics = new QUAD_COEFFS[segments];
100    memmove(xcoords, source.xcoords, (segments + 1) * sizeof(int32_t));
101    memmove(quadratics, source.quadratics, segments * sizeof(QUAD_COEFFS));
102    return *this;
103  }
104  double QSPLINE::step( 
105      double x1,        
106      double x2) {
107    int index1, index2; 
108    double total;       &bsol;*total steps */
109    index1 = spline_index(x1);
110    index2 = spline_index(x2);
111    total = 0;
112    while (index1 < index2) {
113      total += static_cast<double>(quadratics[index1 + 1].y(static_cast<float>(xcoords[index1 + 1])));
114      total -= static_cast<double>(quadratics[index1].y(static_cast<float>(xcoords[index1 + 1])));
115      index1++; &bsol;*next segment */
116    }
117    return total; &bsol;*total steps */
118  }
119  double QSPLINE::y( 
120      double x       
121      ) const {
122    int32_t index; 
123    index = spline_index(x);
124    return quadratics[index].y(x); 
125  }
126  int32_t QSPLINE::spline_index( 
127      double x                   
128      ) const {
129    int32_t index;  
130    int32_t bottom; 
131    int32_t top;    
132    bottom = 0;
133    top = segments;
134    while (top - bottom > 1) {
135      index = (top + bottom) / 2; 
136      if (x >= xcoords[index]) {
137        bottom = index; 
138      } else {
139        top = index; 
140      }
141    }
142    return bottom;
143  }
144  void QSPLINE::move( 
145      ICOORD vec      
146  ) {
147    int32_t segment; 
148    int16_t x_shift = vec.x();
149    for (segment = 0; segment < segments; segment++) {
150      xcoords[segment] += x_shift;
151      quadratics[segment].move(vec);
152    }
153    xcoords[segment] += x_shift;
154  }
155  bool QSPLINE::overlap( 
156      QSPLINE *spline2,  
157      double fraction    
158  ) {
159    int leftlimit = xcoords[1];             &bsol;*common left limit */
160    int rightlimit = xcoords[segments - 1]; &bsol;*common right limit */
161    return !(spline2->segments < 3 ||
162             spline2->xcoords[1] > leftlimit + fraction * (rightlimit - leftlimit) ||
163             spline2->xcoords[spline2->segments - 1] <
164                 rightlimit - fraction * (rightlimit - leftlimit));
165  }
166  void QSPLINE::extrapolate( 
167      double gradient,       
168      int xmin,              
169      int xmax               
170  ) {
171    int segment;        &bsol;*current segment of spline */
172    int dest_segment;   
173    int32_t *xstarts;   
174    QUAD_COEFFS *quads; 
175    int increment;      
176    increment = xmin < xcoords[0] ? 1 : 0;
177    if (xmax > xcoords[segments]) {
178      increment++;
179    }
180    if (increment == 0) {
181      return;
182    }
183    xstarts = new int32_t[segments + 1 + increment];
184    quads = new QUAD_COEFFS[segments + increment];
185    if (xmin < xcoords[0]) {
186      xstarts[0] = xmin;
187      quads[0].a = 0;
188      quads[0].b = gradient;
189      quads[0].c = y(xcoords[0]) - quads[0].b * xcoords[0];
190      dest_segment = 1;
191    } else {
192      dest_segment = 0;
193    }
194    for (segment = 0; segment < segments; segment++) {
195      xstarts[dest_segment] = xcoords[segment];
196      quads[dest_segment] = quadratics[segment];
197      dest_segment++;
198    }
199    xstarts[dest_segment] = xcoords[segment];
200    if (xmax > xcoords[segments]) {
201      quads[dest_segment].a = 0;
202      quads[dest_segment].b = gradient;
203      quads[dest_segment].c = y(xcoords[segments]) - quads[dest_segment].b * xcoords[segments];
204      dest_segment++;
205      xstarts[dest_segment] = xmax + 1;
206    }
207    segments = dest_segment;
208    delete[] xcoords;
209    delete[] quadratics;
210    xcoords = xstarts;
211    quadratics = quads;
212  }
213  #ifndef GRAPHICS_DISABLED
214  void QSPLINE::plot(          
215      ScrollView *window,      
216      ScrollView::Color colour 
217      ) const {
218    int32_t segment;  
219    int16_t step;     
220    double increment; 
221    double x;         
222    window->Pen(colour);
223    for (segment = 0; segment < segments; segment++) {
224      increment = static_cast<double>(xcoords[segment + 1] - xcoords[segment]) / QSPLINE_PRECISION;
225      x = xcoords[segment];
226      for (step = 0; step <= QSPLINE_PRECISION; step++) {
227        if (segment == 0 && step == 0) {
228          window->SetCursor(x, quadratics[segment].y(x));
229        } else {
230          window->DrawTo(x, quadratics[segment].y(x));
231        }
232        x += increment;
233      }
234    }
235  }
236  #endif
237  void QSPLINE::plot(Image pix) const {
238    if (pix == nullptr) {
239      return;
240    }
241    int32_t segment;  
242    int16_t step;     
243    double increment; 
244    double x;         
245    auto height = static_cast<double>(pixGetHeight(pix));
246    Pta *points = ptaCreate(QSPLINE_PRECISION * segments);
247    const int kLineWidth = 5;
248    for (segment = 0; segment < segments; segment++) {
249      increment = static_cast<double>((xcoords[segment + 1] - xcoords[segment])) / QSPLINE_PRECISION;
250      x = xcoords[segment];
251      for (step = 0; step <= QSPLINE_PRECISION; step++) {
252        double y = height - quadratics[segment].y(x);
253        ptaAddPt(points, x, y);
254        x += increment;
255      }
256    }
257    switch (pixGetDepth(pix)) {
258      case 1:
259        pixRenderPolyline(pix, points, kLineWidth, L_SET_PIXELS, 1);
260        break;
261      case 32:
262        pixRenderPolylineArb(pix, points, kLineWidth, 255, 0, 0, 1);
263        break;
264      default:
265        pixRenderPolyline(pix, points, kLineWidth, L_CLEAR_PIXELS, 1);
266        break;
267    }
268    ptaDestroy(&points);
269  }
270  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-html.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-quspline.cpp</div>
                </div>
                <div class="column column_space"><pre><code>9    TIntV ChTyV;
10    TChV UcChV;
11    TChV LcChV;
12    TStrStrH EscStrH;
13    void SetUcCh(const char& UcCh, const char& LcCh);
14    void SetUcCh(const TStr& Str);
15    void SetChTy(const THtmlLxChTy& ChTy, const TStr& Str);
16    void SetEscStr(const TStr& SrcStr, const TStr& DstStr);
</pre></code></div>
                <div class="column column_space"><pre><code>29      int xstarts[],              
30      int segcount,               
31      int xpts[],                 
32      int ypts[], int pointcount, 
33      int degree                  
34  ) {
35    int pointindex;    &bsol;*no along text line */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    