
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.743465634075508%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "Snap.h"
3  #include "rolx.h"
4  void PrintFeatures(const TIntFtrH& Features) {
5    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
6      printf("%d: [", HI.GetKey()());
7      const TFtr& Feature = HI.GetDat();
8      for (int i = 0; i < Feature.Len(); ++i) {
9        if (i > 0) {
10          printf(",");
11        }
12        printf("%f", Feature[i]());
13      }
14      printf("]\n");
15    }
16  }
17  TIntFtrH CreateEmptyFeatures(const PUNGraph Graph) {
18    TIntFtrH EmptyFeatures;
19    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
20      EmptyFeatures.AddDat(TInt(NI.GetId()), TFtr());
21    }
22    return EmptyFeatures;
23  }
24  TIntFtrH CreateEmptyFeatures(const TIntFtrH& Features) {
25    TIntFtrH EmptyFeatures;
26    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
27      EmptyFeatures.AddDat(HI.GetKey(), TFtr());
28    }
29    return EmptyFeatures;
30  }
31  int GetNumFeatures(const TIntFtrH& Features) {
32    return Features.BegI().GetDat().Len();
33  }
34  TFtr GetNthFeature(const TIntFtrH& Features, const int N) {
35    TFtr NthFeature;
36    IAssert(0 <= N && N < GetNumFeatures(Features));
37    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
38      NthFeature.Add(HI.GetDat()[N]);
39    }
40    return NthFeature;
41  }
42  TIntFtrH ExtractFeatures(const PUNGraph Graph) {
43    TIntFtrH Features = CreateEmptyFeatures(Graph);
44    AddNeighborhoodFeatures(Graph, Features);
45    printf("finish neighborhood features\n");
46    AddRecursiveFeatures(Graph, Features);
47    printf("finish recursive features\n");
48    return Features;
49  }
50  void AddNeighborhoodFeatures(const PUNGraph Graph, TIntFtrH& Features) {
51    AddLocalFeatures(Graph, Features);
52    printf("finish local features\n");
53    AddEgonetFeatures(Graph, Features);
54    printf("finish egonet features\n");
55  }
56  void AddRecursiveFeatures(const PUNGraph Graph, TIntFtrH& Features) {
57    int SimilarityThreshold = 0;
58    TIntFtrH RetainedFeatures = Features;
59    while (true) {
60      TIntFtrH NewFeatures = GenerateRecursiveFeatures(Graph, RetainedFeatures);
61      RetainedFeatures = PruneRecursiveFeatures(Graph, Features, NewFeatures,
62          SimilarityThreshold);
63      if (0 == GetNumFeatures(RetainedFeatures)) {
64        break;
65      }
66      AppendFeatures(Features, RetainedFeatures);
67      ++SimilarityThreshold;
68      printf("recursion %d: ", SimilarityThreshold);
69      printf("current feature number %d\n", GetNumFeatures(Features));
70    }
71  }
72  void AddLocalFeatures(const PUNGraph Graph, TIntFtrH& Features) {
73    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
74      Features.GetDat(TInt(NI.GetId())).Add(NI.GetInDeg());
75    }
76  }
77  void AddEgonetFeatures(const PUNGraph Graph, TIntFtrH& Features) {
78    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
79      int NId = NI.GetId();
80      int ArndEdges;
81      PUNGraph Egonet = TSnap::GetEgonet(Graph, NId, ArndEdges);
82      Features.GetDat(NId).Add(Egonet->GetEdges());
83      Features.GetDat(NId).Add(ArndEdges);
84    }
85  }
86  TIntFtrH GenerateRecursiveFeatures(const PUNGraph Graph,
87      const TIntFtrH& CurrFeatures) {
88    const int NumCurrFeatures = GetNumFeatures(CurrFeatures);
89    if (0 == NumCurrFeatures) {
90      return CurrFeatures;
91    }
92    TIntFtrH NewFeatures = CreateEmptyFeatures(CurrFeatures);
93    for (int i = 0; i < NumCurrFeatures; ++i) {
94      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
95        float Sum = 0;
96        for (int j = 0; j < NI.GetInDeg(); ++j) {
97          int NbrNId = NI.GetInNId(j);
98          Sum += CurrFeatures.GetDat(NbrNId)[i]();
99        }
100        NewFeatures.GetDat(NI.GetId()).Add(Sum);
101        NewFeatures.GetDat(NI.GetId()).Add(0 == NI.GetInDeg()?
102            0 : (float(Sum) / NI.GetInDeg()));
103      }
104    }
105    return NewFeatures;
106  }
107  TIntFtrH PruneRecursiveFeatures(const PUNGraph Graph, const TIntFtrH& Features,
108      const TIntFtrH& NewFeatures, const int SimilarityThreshold) {
109    TIntFtrH AllFeatures = CreateEmptyFeatures(Features);
110    AppendFeatures(AllFeatures, Features);
111    AppendFeatures(AllFeatures, NewFeatures);
112    const float BinFraction = 0.5;
113    TIntFtrH LogBinFeatures = CalcVerticalLogBinning(AllFeatures, BinFraction);
114    PUNGraph FeatureGraph = BuildFeatureGraph(LogBinFeatures,
115        SimilarityThreshold);
116    return SummarizeConnectedComponents(FeatureGraph, Features, NewFeatures);
117  }
118  void AppendFeatures(TIntFtrH& DstFeatures, const TIntFtrH& SrcFeatures,
119      const int ColIdx) {
120    for (TIntFtrH::TIter HI = SrcFeatures.BegI();
121        HI < SrcFeatures.EndI();
122        HI++) {
123      const TFtr& Feature = HI.GetDat();
124      if (ColIdx >= 0) {
125        DstFeatures.GetDat(HI.GetKey()).Add(Feature[ColIdx]);
126      } else {
127        for (int i = 0; i < Feature.Len(); ++i) {
128          DstFeatures.GetDat(HI.GetKey()).Add(Feature[i]);
129        }
130      }
131    }
132  }
133  TIntFtrH CalcVerticalLogBinning(const TIntFtrH& Features,
134      const float BinFraction) {
135    const int NumFeatures = GetNumFeatures(Features);
136    TIntFtrH LogBinFeatures = CreateEmptyFeatures(Features);
137    for (int i = 0; i < NumFeatures; ++i) {
138      TVec<TInt> SortedNId = GetNIdSorted(Features, i);
139      AssignBinValue(SortedNId, BinFraction, LogBinFeatures);
140    }
141    return LogBinFeatures;
142  }
143  PUNGraph BuildFeatureGraph(const TIntFtrH& LogBinFeatures,
144      const int SimilarityThreshold) {
145    PUNGraph FeatureGraph = PUNGraph::New();
146    const int NumFeatures = GetNumFeatures(LogBinFeatures);
147    for (int i = 0; i < NumFeatures; ++i) {
148      FeatureGraph->AddNode(i);
149    }
150    for (int i = 0; i < NumFeatures; ++i) {
151      TFtr IthFeature = GetNthFeature(LogBinFeatures, i);
152      for (int j = i + 1; j < NumFeatures; ++j) {
153        TFtr JthFeature = GetNthFeature(LogBinFeatures, j);
154        if (IsSimilarFeature(IthFeature, JthFeature, SimilarityThreshold) &&
155            !FeatureGraph->IsEdge(i, j)) {
156          FeatureGraph->AddEdge(i, j);
157        }
158      }
159    }
160    return FeatureGraph;
161  }
162  TIntFtrH SummarizeConnectedComponents(const PUNGraph FeatureGraph,
163      const TIntFtrH& Features, const TIntFtrH& NewFeatures) {
164    TCnComV Wcc;
165    TSnap::GetWccs(FeatureGraph, Wcc);
166    TVec<TInt> RetainedIdx;
167    for (int i = 0; i < Wcc.Len(); ++i) {
168      RetainedIdx.Add(Wcc[i][0]);
169    }
170    RetainedIdx.Sort();
171    TIntFtrH RetainedFeatures = CreateEmptyFeatures(Features);
172    const int StartIdxNewFeatures = GetNumFeatures(Features);
173    for (int i = 0; i < RetainedIdx.Len(); ++i) {
174      const int IdxNewFeatures = RetainedIdx[i] - StartIdxNewFeatures;
175      if (IdxNewFeatures >= 0) {
176        AppendFeatures(RetainedFeatures, NewFeatures, IdxNewFeatures);
177      }
178    }
179    return RetainedFeatures;
180  }
181  TVec<TInt> GetNIdSorted(const TIntFtrH& Features, const int Idx) {
182    THash<TInt, TFlt> F;
183    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
184      F.AddDat(HI.GetKey(), HI.GetDat()[Idx]);
185    }
186    F.SortByDat();
187    TVec<TInt> SortedNId;
188    for (THash<TInt, TFlt>::TIter HI = F.BegI(); HI < F.EndI(); HI++) {
189      SortedNId.Add(HI.GetKey());
190    }
191    return SortedNId;
192  }
193  void AssignBinValue(const TVec<TInt>& SortedNId, const float BinFraction,
194      TIntFtrH& LogBinFeatures) {
195    int NumNodes = LogBinFeatures.Len();
196    int NumAssigned = 0;
197    int BinValue = 0;
198    while (NumAssigned < NumNodes) {
199      int NumToAssign = ceil(BinFraction * (NumNodes - NumAssigned));
200      for (int i = NumAssigned; i < NumAssigned + NumToAssign; ++i) {
201        int NId = SortedNId[i];
202        LogBinFeatures.GetDat(NId).Add(BinValue);
203      }
204      NumAssigned += NumToAssign;
205      ++BinValue;
206    }
207  }
208  bool IsSimilarFeature(const TFtr& F1, const TFtr& F2,
209      const int SimilarityThreshold) {
210    IAssert(F1.Len() == F2.Len());
211    for (int i = 0; i < F1.Len(); ++i) {
212      if (TFlt::Abs(F1[i] - F2[i]) > SimilarityThreshold) {
213        return false;
214      }
215    }
216    return true;
217  }
218  TFltVV ConvertFeatureToMatrix(const TIntFtrH& Features,
219      const TIntIntH& NodeIdMtxIdxH) {
220    const int NumNodes = Features.Len();
221    const int NumFeatures = GetNumFeatures(Features);
222    TFltVV FeaturesMtx(NumNodes, NumFeatures);
223    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
224      int i = GetMtxIdx(HI.GetKey(), NodeIdMtxIdxH);
225      for (int j = 0; j < NumFeatures; ++j) {
226        FeaturesMtx(i, j) = HI.GetDat()[j];
227      }
228    }
229    return FeaturesMtx;
230  }
231  void PrintMatrix(const TFltVV& Matrix) {
232    int XDim = Matrix.GetXDim();
233    int YDim = Matrix.GetYDim();
234    printf("[");
235    for (int i = 0; i < XDim; ++i) {
236      printf("[");
237      for (int j = 0; j < YDim; ++j) {
238        if (j != 0) {
239          printf(" ");
240        }
241        printf("%f", Matrix(i, j)());
242      }
243      printf("]\n");
244    }
245    printf("]\n");
246  }
247  TFltVV CreateRandMatrix(const int XDim, const int YDim) {
248    int Seed = 13;
249    TFltVV Matrix(XDim, YDim);
250    for (int i = 0; i < XDim; ++i) {
251      for (int j = 0; j < YDim; ++j) {
252        Matrix(i, j) = (double)Seed / 10007;
253        Seed = (Seed * 1871) % 10007;
254      }
255    }
256    return Matrix;
257  }
258  bool FltIsZero(const TFlt Number) {
259    return TFlt::Abs(Number) < TFlt::Eps;
260  }
261  void CalcNonNegativeFactorization(const TFltVV& V, const int NumRoles,
262      TFltVV& W, TFltVV& H, const double Threshold) {
263    double Cost = 100, NewCost = 0;
264    int NumNodes = V.GetXDim();
265    int NumFeatures = V.GetYDim();
266    W = CreateRandMatrix(NumNodes, NumRoles);
267    H = CreateRandMatrix(NumRoles, NumFeatures);
<span onclick='openModal()' class='match'>268    TFltVV NewW(NumNodes, NumRoles);
269    TFltVV NewH(NumRoles, NumFeatures);
270    TFltVV Product(NumNodes, NumFeatures);
271    TFltV Sum(NumRoles);
272    TFltVV *PW = &W, *PH = &H, *PNewW = &NewW, *PNewH = &NewH, *Tmp;
</span>273    while (TFlt::Abs((NewCost - Cost)/Cost) > Threshold) {
274      TLinAlg::Multiply(*PW, *PH, Product);
275      Cost = NewCost;
276      NewCost = 0;
277      for (int i = 0; i < NumNodes; i++) {
278        for (int j = 0; j < NumFeatures; j++) {
279          NewCost += V(i, j) * TMath::Log(Product(i, j)) - Product(i, j);
280        }
281      }
282      for (int i = 0; i < NumNodes; i++) {
283        for (int a = 0; a < NumRoles; a++) {
284          double SumU = 0;
285          for (int u = 0; u < NumFeatures; ++u) {
286            if (!FltIsZero(Product(i, u))) {
287              SumU += V(i, u) / Product(i, u) * PH->At(a, u);
288            }
289          }
290          PNewW->At(i, a) = PW->At(i, a) * SumU;
291        }
292      }
293      for (int i = 0; i < NumRoles; i++) {
294        Sum[i] = 0;
295      }
296      for (int i = 0; i < NumNodes; i++) {
297        for (int j = 0; j < NumRoles; j++) {
298          Sum[j] += PNewW->At(i, j);
299        }
300      }
301      for (int i = 0; i < NumNodes; i++) {
302        for (int j = 0; j < NumRoles; j++) {
303          PNewW->At(i, j) /= Sum[j];
304        }
305      }
306      for (int a = 0; a < NumRoles; a++) {
307        for (int u = 0; u < NumFeatures; u++) {
308          double SumI = 0;
309          for (int i = 0; i < NumNodes; ++i) {
310            if (!FltIsZero(Product(i, u))) {
311              SumI += PW->At(i, a) * V(i, u) / Product(i, u);
312            }
313          }
314          PNewH->At(a, u) = PH->At(a, u) * SumI;
315        }
316      }
317      Tmp = PW; PW = PNewW; PNewW = Tmp;
318      Tmp = PH; PH = PNewH; PNewH = Tmp;
319    }
320  }
321  TFlt CalcDescriptionLength(const TFltVV& V, const TFltVV& G,
322      const TFltVV& F) {
323    int B = 64;
324    int M = B * V.GetYDim() * (V.GetXDim() + F.GetYDim());
325    TFlt E = 0;
326    TFltVV GF(G.GetXDim(), F.GetYDim());
327    TLinAlg::Multiply(G, F, GF);
328    for (int i = 0; i < V.GetXDim(); ++i) {
329      for (int j = 0; j < V.GetYDim(); ++j) {
330        TFlt ValueV = V(i, j);
331        TFlt ValueGF = GF(i, j);
332        if (FltIsZero(ValueV)) {
333          E += ValueGF;
334        } else if (!FltIsZero(ValueGF)) {
335          E += ValueV * TMath::Log(ValueV / ValueGF) - ValueV + ValueGF;
336        }
337      }
338    }
339    return M + E;
340  }
341  TIntIntH CreateNodeIdMtxIdxHash(const TIntFtrH& Features) {
342    TIntIntH H;
343    TInt Idx = 0;
344    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
345      H.AddDat(HI.GetKey(), Idx);
346      Idx++;
347    }
348    return H;
349  }
350  int GetMtxIdx(const TInt NodeId, const TIntIntH& NodeIdMtxIdxH) {
351    return NodeIdMtxIdxH.GetDat(NodeId)();
352  }
353  int GetNodeId(const TInt MtxId, const TIntIntH& NodeIdMtxIdxH) {
354    for (TIntIntH::TIter HI = NodeIdMtxIdxH.BegI();
355        HI < NodeIdMtxIdxH.EndI();
356        HI++) {
357      if (HI.GetDat() == MtxId) {
358        return HI.GetKey()();
359      }
360    }
361    return -1;
362  }
363  TIntIntH FindRoles(const TFltVV& G, const TIntIntH& NodeIdMtxIdxH) {
364    TIntIntH Roles;
365    for (int i = 0; i < G.GetXDim(); i++) {
366      int Role = -1;
367      TFlt Max = TFlt::Mn;
368      for (int j = 0; j < G.GetYDim(); j ++) {
369        if (G(i, j) > Max) {
370          Max = G(i, j);
371          Role = j;
372        }
373      }
374      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
375      Roles.AddDat(NodeId, Role);
376    }
377    return Roles;
378  }
379  void PlotRoles(const PUNGraph Graph, const TIntIntH& Roles) {
380    TStr RoleToColor[10] = { "white", "black", "red", "green", "blue",
381        "yellow", "gold", "cyan", "magenta", "brown" };
382    TIntStrH Color;
383    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
384      Color.AddDat(HI.GetKey(), RoleToColor[HI.GetDat()].CStr());
385    }
386    TSnap::DrawGViz(Graph, gvlDot, "gviz_plot.png", "Dot", 1, Color);
387  }
388  void PrintRoles(const TIntIntH& Roles) {
389    printf("--roles (node ID: role ID)--\n");
390    printf("{\n");
391    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
392      printf("(%d: %d)\n", HI.GetKey()(), HI.GetDat()());
393    }
394    printf("}\n");
395  }
396  void FPrintMatrix(const TFltVV& Matrix, const TStr& Path) {
397    FILE *Fp;
398    Fp = fopen(Path.CStr(), "w");
399    int XDim = Matrix.GetXDim();
400    int YDim = Matrix.GetYDim();
401    for (int i = 0; i < XDim; ++i) {
402      for (int j = 0; j < YDim; ++j) {
403        if (j != 0) {
404          fprintf(Fp, " ");
405        }
406        fprintf(Fp, "%f", Matrix(i, j)());
407      }
408      fprintf(Fp, "\n");
409    }
410    fclose(Fp);
411  }
412  void FPrintNodeMappings(const TIntIntH& NodeIdMtxIdxH, const TStr& Path) {
413    FILE *Fp;
414    Fp = fopen(Path.CStr(), "w");
415    fprintf(Fp, "# mappings from the feature line numbers to node IDs\n");
416    for (int i = 0; i < NodeIdMtxIdxH.Len(); i++) {
417      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
418      fprintf(Fp, "%d %d\n", i, NodeId);
419    }
420    fclose(Fp);
421  }
422  void FPrintRoles(const TIntIntH& Roles, const TStr& Path) {
423    FILE *Fp;
424    Fp = fopen(Path.CStr(), "w");
425    fprintf(Fp, "--roles (node ID role ID)--\n\n");
426    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
427      fprintf(Fp, "%d\t%d\n", HI.GetKey()(), HI.GetDat()());
428    }
429    fclose(Fp);
430  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_test.cc</h3>
            <pre><code>1  #include "absl/flags/flag.h"
2  #include <stddef.h>
3  #include <stdint.h>
4  #include <atomic>
5  #include <cmath>
6  #include <new>
7  #include <string>
8  #include <thread>  
9  #include <vector>
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/macros.h"
13  #include "absl/flags/config.h"
14  #include "absl/flags/declare.h"
15  #include "absl/flags/internal/flag.h"
16  #include "absl/flags/marshalling.h"
17  #include "absl/flags/reflection.h"
18  #include "absl/flags/usage_config.h"
19  #include "absl/numeric/int128.h"
20  #include "absl/strings/match.h"
21  #include "absl/strings/numbers.h"
22  #include "absl/strings/str_cat.h"
23  #include "absl/strings/str_split.h"
24  #include "absl/strings/string_view.h"
25  #include "absl/time/time.h"
26  ABSL_DECLARE_FLAG(int64_t, mistyped_int_flag);
27  ABSL_DECLARE_FLAG(std::vector<std::string>, mistyped_string_flag);
28  namespace {
29  namespace flags = absl::flags_internal;
30  std::string TestHelpMsg() { return "dynamic help"; }
31  #if defined(_MSC_VER) && !defined(__clang__)
32  std::string TestLiteralHelpMsg() { return "literal help"; }
33  #endif
34  template <typename T>
35  void TestMakeDflt(void* dst) {
36    new (dst) T{};
37  }
38  void TestCallback() {}
39  struct UDT {
40    UDT() = default;
41    UDT(const UDT&) = default;
42    UDT& operator=(const UDT&) = default;
43  };
44  bool AbslParseFlag(absl::string_view, UDT*, std::string*) { return true; }
45  std::string AbslUnparseFlag(const UDT&) { return ""; }
46  class FlagTest : public testing::Test {
47   protected:
48    static void SetUpTestSuite() {
49      absl::FlagsUsageConfig default_config;
50      default_config.normalize_filename = &FlagTest::NormalizeFileName;
51      absl::SetFlagsUsageConfig(default_config);
52    }
53   private:
54    static std::string NormalizeFileName(absl::string_view fname) {
55  #ifdef _WIN32
56      std::string normalized(fname);
57      std::replace(normalized.begin(), normalized.end(), '\\', '/');
58      fname = normalized;
59  #endif
60      return std::string(fname);
61    }
62    absl::FlagSaver flag_saver_;
63  };
64  struct S1 {
65    S1() = default;
66    S1(const S1&) = default;
67    int32_t f1;
68    int64_t f2;
69  };
70  struct S2 {
71    S2() = default;
72    S2(const S2&) = default;
73    int64_t f1;
74    double f2;
75  };
76  TEST_F(FlagTest, Traits) {
<span onclick='openModal()' class='match'>77    EXPECT_EQ(flags::StorageKind<int>(),
78              flags::FlagValueStorageKind::kValueAndInitBit);
79    EXPECT_EQ(flags::StorageKind<bool>(),
80              flags::FlagValueStorageKind::kValueAndInitBit);
81    EXPECT_EQ(flags::StorageKind<double>(),
82              flags::FlagValueStorageKind::kOneWordAtomic);
83    EXPECT_EQ(flags::StorageKind<int64_t>(),
84              flags::FlagValueStorageKind::kOneWordAtomic);
</span>85    EXPECT_EQ(flags::StorageKind<S1>(),
86              flags::FlagValueStorageKind::kSequenceLocked);
87    EXPECT_EQ(flags::StorageKind<S2>(),
88              flags::FlagValueStorageKind::kSequenceLocked);
89  #ifdef __clang__
90    EXPECT_EQ(flags::StorageKind<absl::Duration>(),
91              flags::FlagValueStorageKind::kSequenceLocked);
92  #endif
93    EXPECT_EQ(flags::StorageKind<std::string>(),
94              flags::FlagValueStorageKind::kAlignedBuffer);
95    EXPECT_EQ(flags::StorageKind<std::vector<std::string>>(),
96              flags::FlagValueStorageKind::kAlignedBuffer);
97    EXPECT_EQ(flags::StorageKind<absl::int128>(),
98              flags::FlagValueStorageKind::kSequenceLocked);
99    EXPECT_EQ(flags::StorageKind<absl::uint128>(),
100              flags::FlagValueStorageKind::kSequenceLocked);
101  }
102  constexpr flags::FlagHelpArg help_arg{flags::FlagHelpMsg("literal help"),
103                                        flags::FlagHelpKind::kLiteral};
104  using String = std::string;
105  using int128 = absl::int128;
106  using uint128 = absl::uint128;
107  #if !defined(_MSC_VER) || defined(__clang__)
108  #define DEFINE_CONSTRUCTED_FLAG(T, dflt, dflt_kind)                        \
109    constexpr flags::FlagDefaultArg f1default##T{                            \
110        flags::FlagDefaultSrc{dflt}, flags::FlagDefaultKind::dflt_kind};     \
111    constexpr absl::Flag<T> f1##T{"f1", "file", help_arg, f1default##T};     \
112    ABSL_CONST_INIT absl::Flag<T> f2##T {                                    \
113      "f2", "file",                                                          \
114          {flags::FlagHelpMsg(&TestHelpMsg), flags::FlagHelpKind::kGenFunc}, \
115          flags::FlagDefaultArg {                                            \
116        flags::FlagDefaultSrc(&TestMakeDflt<T>),                             \
117            flags::FlagDefaultKind::kGenFunc                                 \
118      }                                                                      \
119    }
120  #else
121  #define DEFINE_CONSTRUCTED_FLAG(T, dflt, dflt_kind)                    \
122    constexpr flags::FlagDefaultArg f1default##T{                        \
123        flags::FlagDefaultSrc{dflt}, flags::FlagDefaultKind::dflt_kind}; \
124    constexpr absl::Flag<T> f1##T{"f1", "file", &TestLiteralHelpMsg,     \
125                                  &TestMakeDflt<T>};                     \
126    ABSL_CONST_INIT absl::Flag<T> f2##T {                                \
127      "f2", "file", &TestHelpMsg, &TestMakeDflt<T>                       \
128    }
129  #endif
130  DEFINE_CONSTRUCTED_FLAG(bool, true, kOneWord);
131  DEFINE_CONSTRUCTED_FLAG(int16_t, 1, kOneWord);
132  DEFINE_CONSTRUCTED_FLAG(uint16_t, 2, kOneWord);
133  DEFINE_CONSTRUCTED_FLAG(int32_t, 3, kOneWord);
134  DEFINE_CONSTRUCTED_FLAG(uint32_t, 4, kOneWord);
135  DEFINE_CONSTRUCTED_FLAG(int64_t, 5, kOneWord);
136  DEFINE_CONSTRUCTED_FLAG(uint64_t, 6, kOneWord);
137  DEFINE_CONSTRUCTED_FLAG(float, 7.8, kOneWord);
138  DEFINE_CONSTRUCTED_FLAG(double, 9.10, kOneWord);
139  DEFINE_CONSTRUCTED_FLAG(String, &TestMakeDflt<String>, kGenFunc);
140  DEFINE_CONSTRUCTED_FLAG(UDT, &TestMakeDflt<UDT>, kGenFunc);
141  DEFINE_CONSTRUCTED_FLAG(int128, 13, kGenFunc);
142  DEFINE_CONSTRUCTED_FLAG(uint128, 14, kGenFunc);
143  template <typename T>
144  bool TestConstructionFor(const absl::Flag<T>& f1, absl::Flag<T>& f2) {
145    EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Name(), "f1");
146    EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Help(), "literal help");
147    EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Filename(), "file");
148    flags::FlagRegistrar<T, false>(ABSL_FLAG_IMPL_FLAG_PTR(f2), nullptr)
149        .OnUpdate(TestCallback);
150    EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Name(), "f2");
151    EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Help(), "dynamic help");
152    EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Filename(), "file");
153    return true;
154  }
155  #define TEST_CONSTRUCTED_FLAG(T) TestConstructionFor(f1##T, f2##T);
156  TEST_F(FlagTest, TestConstruction) {
157    TEST_CONSTRUCTED_FLAG(bool);
158    TEST_CONSTRUCTED_FLAG(int16_t);
159    TEST_CONSTRUCTED_FLAG(uint16_t);
160    TEST_CONSTRUCTED_FLAG(int32_t);
161    TEST_CONSTRUCTED_FLAG(uint32_t);
162    TEST_CONSTRUCTED_FLAG(int64_t);
163    TEST_CONSTRUCTED_FLAG(uint64_t);
164    TEST_CONSTRUCTED_FLAG(float);
165    TEST_CONSTRUCTED_FLAG(double);
166    TEST_CONSTRUCTED_FLAG(String);
167    TEST_CONSTRUCTED_FLAG(UDT);
168    TEST_CONSTRUCTED_FLAG(int128);
169    TEST_CONSTRUCTED_FLAG(uint128);
170  }
171  }  
172  ABSL_DECLARE_FLAG(bool, test_flag_01);
173  ABSL_DECLARE_FLAG(int, test_flag_02);
174  ABSL_DECLARE_FLAG(int16_t, test_flag_03);
175  ABSL_DECLARE_FLAG(uint16_t, test_flag_04);
176  ABSL_DECLARE_FLAG(int32_t, test_flag_05);
177  ABSL_DECLARE_FLAG(uint32_t, test_flag_06);
178  ABSL_DECLARE_FLAG(int64_t, test_flag_07);
179  ABSL_DECLARE_FLAG(uint64_t, test_flag_08);
180  ABSL_DECLARE_FLAG(double, test_flag_09);
181  ABSL_DECLARE_FLAG(float, test_flag_10);
182  ABSL_DECLARE_FLAG(std::string, test_flag_11);
183  ABSL_DECLARE_FLAG(absl::Duration, test_flag_12);
184  ABSL_DECLARE_FLAG(absl::int128, test_flag_13);
185  ABSL_DECLARE_FLAG(absl::uint128, test_flag_14);
186  namespace {
187  #if !ABSL_FLAGS_STRIP_NAMES
188  TEST_F(FlagTest, TestFlagDeclaration) {
189    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Name(),
190              "test_flag_01");
191    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Name(),
192              "test_flag_02");
193    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Name(),
194              "test_flag_03");
195    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Name(),
196              "test_flag_04");
197    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Name(),
198              "test_flag_05");
199    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Name(),
200              "test_flag_06");
201    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Name(),
202              "test_flag_07");
203    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Name(),
204              "test_flag_08");
205    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Name(),
206              "test_flag_09");
207    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Name(),
208              "test_flag_10");
209    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Name(),
210              "test_flag_11");
211    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Name(),
212              "test_flag_12");
213    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Name(),
214              "test_flag_13");
215    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Name(),
216              "test_flag_14");
217  }
218  #endif  
219  }  
220  ABSL_FLAG(bool, test_flag_01, true, "test flag 01");
221  ABSL_FLAG(int, test_flag_02, 1234, "test flag 02");
222  ABSL_FLAG(int16_t, test_flag_03, -34, "test flag 03");
223  ABSL_FLAG(uint16_t, test_flag_04, 189, "test flag 04");
224  ABSL_FLAG(int32_t, test_flag_05, 10765, "test flag 05");
225  ABSL_FLAG(uint32_t, test_flag_06, 40000, "test flag 06");
226  ABSL_FLAG(int64_t, test_flag_07, -1234567, "test flag 07");
227  ABSL_FLAG(uint64_t, test_flag_08, 9876543, "test flag 08");
228  ABSL_FLAG(double, test_flag_09, -9.876e-50, "test flag 09");
229  ABSL_FLAG(float, test_flag_10, 1.234e12f, "test flag 10");
230  ABSL_FLAG(std::string, test_flag_11, "", "test flag 11");
231  ABSL_FLAG(absl::Duration, test_flag_12, absl::Minutes(10), "test flag 12");
232  ABSL_FLAG(absl::int128, test_flag_13, absl::MakeInt128(-1, 0), "test flag 13");
233  ABSL_FLAG(absl::uint128, test_flag_14, absl::MakeUint128(0, 0xFFFAAABBBCCCDDD),
234            "test flag 14");
235  namespace {
236  #if !ABSL_FLAGS_STRIP_NAMES
237  TEST_F(FlagTest, TestFlagDefinition) {
238    absl::string_view expected_file_name = "absl/flags/flag_test.cc";
239    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Name(),
240              "test_flag_01");
241    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Help(),
242              "test flag 01");
243    EXPECT_TRUE(absl::EndsWith(
244        absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Filename(),
245        expected_file_name))
246        << absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Filename();
247    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Name(),
248              "test_flag_02");
249    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Help(),
250              "test flag 02");
251    EXPECT_TRUE(absl::EndsWith(
252        absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Filename(),
253        expected_file_name))
254        << absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Filename();
255    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Name(),
256              "test_flag_03");
257    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Help(),
258              "test flag 03");
259    EXPECT_TRUE(absl::EndsWith(
260        absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Filename(),
261        expected_file_name))
262        << absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Filename();
263    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Name(),
264              "test_flag_04");
265    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Help(),
266              "test flag 04");
267    EXPECT_TRUE(absl::EndsWith(
268        absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Filename(),
269        expected_file_name))
270        << absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Filename();
271    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Name(),
272              "test_flag_05");
273    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Help(),
274              "test flag 05");
275    EXPECT_TRUE(absl::EndsWith(
276        absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Filename(),
277        expected_file_name))
278        << absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Filename();
279    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Name(),
280              "test_flag_06");
281    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Help(),
282              "test flag 06");
283    EXPECT_TRUE(absl::EndsWith(
284        absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Filename(),
285        expected_file_name))
286        << absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Filename();
287    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Name(),
288              "test_flag_07");
289    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Help(),
290              "test flag 07");
291    EXPECT_TRUE(absl::EndsWith(
292        absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Filename(),
293        expected_file_name))
294        << absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Filename();
295    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Name(),
296              "test_flag_08");
297    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Help(),
298              "test flag 08");
299    EXPECT_TRUE(absl::EndsWith(
300        absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Filename(),
301        expected_file_name))
302        << absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Filename();
303    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Name(),
304              "test_flag_09");
305    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Help(),
306              "test flag 09");
307    EXPECT_TRUE(absl::EndsWith(
308        absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Filename(),
309        expected_file_name))
310        << absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Filename();
311    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Name(),
312              "test_flag_10");
313    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Help(),
314              "test flag 10");
315    EXPECT_TRUE(absl::EndsWith(
316        absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Filename(),
317        expected_file_name))
318        << absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Filename();
319    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Name(),
320              "test_flag_11");
321    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Help(),
322              "test flag 11");
323    EXPECT_TRUE(absl::EndsWith(
324        absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Filename(),
325        expected_file_name))
326        << absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Filename();
327    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Name(),
328              "test_flag_12");
329    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Help(),
330              "test flag 12");
331    EXPECT_TRUE(absl::EndsWith(
332        absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Filename(),
333        expected_file_name))
334        << absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Filename();
335    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Name(),
336              "test_flag_13");
337    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Help(),
338              "test flag 13");
339    EXPECT_TRUE(absl::EndsWith(
340        absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Filename(),
341        expected_file_name))
342        << absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Filename();
343    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Name(),
344              "test_flag_14");
345    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Help(),
346              "test flag 14");
347    EXPECT_TRUE(absl::EndsWith(
348        absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Filename(),
349        expected_file_name))
350        << absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Filename();
351  }
352  #endif  
353  TEST_F(FlagTest, TestDefault) {
354    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).DefaultValue(),
355              "true");
356    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).DefaultValue(),
357              "1234");
358    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).DefaultValue(),
359              "-34");
360    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).DefaultValue(),
361              "189");
362    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).DefaultValue(),
363              "10765");
364    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).DefaultValue(),
365              "40000");
366    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).DefaultValue(),
367              "-1234567");
368    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).DefaultValue(),
369              "9876543");
370    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).DefaultValue(),
371              "-9.876e-50");
372    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).DefaultValue(),
373              "1.234e+12");
374    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).DefaultValue(),
375              "");
376    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).DefaultValue(),
377              "10m");
378    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).DefaultValue(),
379              "-18446744073709551616");
380    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).DefaultValue(),
381              "1152827684197027293");
382    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).CurrentValue(),
383              "true");
384    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).CurrentValue(),
385              "1234");
386    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).CurrentValue(),
387              "-34");
388    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).CurrentValue(),
389              "189");
390    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).CurrentValue(),
391              "10765");
392    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).CurrentValue(),
393              "40000");
394    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).CurrentValue(),
395              "-1234567");
396    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).CurrentValue(),
397              "9876543");
398    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).CurrentValue(),
399              "-9.876e-50");
400    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).CurrentValue(),
401              "1.234e+12");
402    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).CurrentValue(),
403              "");
404    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).CurrentValue(),
405              "10m");
406    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).CurrentValue(),
407              "-18446744073709551616");
408    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).CurrentValue(),
409              "1152827684197027293");
410    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
411    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
412    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
413    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
414    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
415    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
416    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
417    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
418    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
419    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
420    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
421    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
422    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), absl::MakeInt128(-1, 0));
423    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14),
424              absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
425  }
426  struct NonTriviallyCopyableAggregate {
427    NonTriviallyCopyableAggregate() = default;
428    NonTriviallyCopyableAggregate(const NonTriviallyCopyableAggregate& rhs)
429        : value(rhs.value) {}
430    NonTriviallyCopyableAggregate& operator=(
431        const NonTriviallyCopyableAggregate& rhs) {
432      value = rhs.value;
433      return *this;
434    }
435    int value;
436  };
437  bool AbslParseFlag(absl::string_view src, NonTriviallyCopyableAggregate* f,
438                     std::string* e) {
439    return absl::ParseFlag(src, &f->value, e);
440  }
441  std::string AbslUnparseFlag(const NonTriviallyCopyableAggregate& ntc) {
442    return absl::StrCat(ntc.value);
443  }
444  bool operator==(const NonTriviallyCopyableAggregate& ntc1,
445                  const NonTriviallyCopyableAggregate& ntc2) {
446    return ntc1.value == ntc2.value;
447  }
448  }  
449  ABSL_FLAG(bool, test_flag_eb_01, {}, "");
450  ABSL_FLAG(int32_t, test_flag_eb_02, {}, "");
451  ABSL_FLAG(int64_t, test_flag_eb_03, {}, "");
452  ABSL_FLAG(double, test_flag_eb_04, {}, "");
453  ABSL_FLAG(std::string, test_flag_eb_05, {}, "");
454  ABSL_FLAG(NonTriviallyCopyableAggregate, test_flag_eb_06, {}, "");
455  namespace {
456  TEST_F(FlagTest, TestEmptyBracesDefault) {
457    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_01).DefaultValue(),
458              "false");
459    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_02).DefaultValue(),
460              "0");
461    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_03).DefaultValue(),
462              "0");
463    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_04).DefaultValue(),
464              "0");
465    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_05).DefaultValue(),
466              "");
467    EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_06).DefaultValue(),
468              "0");
469    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_01), false);
470    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_02), 0);
471    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_03), 0);
472    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_04), 0.0);
473    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_05), "");
474    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_06),
475              NonTriviallyCopyableAggregate{});
476  }
477  TEST_F(FlagTest, TestGetSet) {
478    absl::SetFlag(&FLAGS_test_flag_01, false);
479    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), false);
480    absl::SetFlag(&FLAGS_test_flag_02, 321);
481    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 321);
482    absl::SetFlag(&FLAGS_test_flag_03, 67);
483    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), 67);
484    absl::SetFlag(&FLAGS_test_flag_04, 1);
485    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 1);
486    absl::SetFlag(&FLAGS_test_flag_05, -908);
487    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), -908);
488    absl::SetFlag(&FLAGS_test_flag_06, 4001);
489    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 4001);
490    absl::SetFlag(&FLAGS_test_flag_07, -23456);
491    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -23456);
492    absl::SetFlag(&FLAGS_test_flag_08, 975310);
493    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 975310);
494    absl::SetFlag(&FLAGS_test_flag_09, 1.00001);
495    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), 1.00001, 1e-10);
496    absl::SetFlag(&FLAGS_test_flag_10, -3.54f);
497    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), -3.54f, 1e-6f);
498    absl::SetFlag(&FLAGS_test_flag_11, "asdf");
499    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "asdf");
500    absl::SetFlag(&FLAGS_test_flag_12, absl::Seconds(110));
501    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Seconds(110));
502    absl::SetFlag(&FLAGS_test_flag_13, absl::MakeInt128(-1, 0));
503    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), absl::MakeInt128(-1, 0));
504    absl::SetFlag(&FLAGS_test_flag_14, absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
505    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14),
506              absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
507  }
508  TEST_F(FlagTest, TestGetViaReflection) {
509    auto* handle = absl::FindCommandLineFlag("test_flag_01");
510    EXPECT_EQ(*handle->TryGet<bool>(), true);
511    handle = absl::FindCommandLineFlag("test_flag_02");
512    EXPECT_EQ(*handle->TryGet<int>(), 1234);
513    handle = absl::FindCommandLineFlag("test_flag_03");
514    EXPECT_EQ(*handle->TryGet<int16_t>(), -34);
515    handle = absl::FindCommandLineFlag("test_flag_04");
516    EXPECT_EQ(*handle->TryGet<uint16_t>(), 189);
517    handle = absl::FindCommandLineFlag("test_flag_05");
518    EXPECT_EQ(*handle->TryGet<int32_t>(), 10765);
519    handle = absl::FindCommandLineFlag("test_flag_06");
520    EXPECT_EQ(*handle->TryGet<uint32_t>(), 40000);
521    handle = absl::FindCommandLineFlag("test_flag_07");
522    EXPECT_EQ(*handle->TryGet<int64_t>(), -1234567);
523    handle = absl::FindCommandLineFlag("test_flag_08");
524    EXPECT_EQ(*handle->TryGet<uint64_t>(), 9876543);
525    handle = absl::FindCommandLineFlag("test_flag_09");
526    EXPECT_NEAR(*handle->TryGet<double>(), -9.876e-50, 1e-55);
527    handle = absl::FindCommandLineFlag("test_flag_10");
528    EXPECT_NEAR(*handle->TryGet<float>(), 1.234e12f, 1e5f);
529    handle = absl::FindCommandLineFlag("test_flag_11");
530    EXPECT_EQ(*handle->TryGet<std::string>(), "");
531    handle = absl::FindCommandLineFlag("test_flag_12");
532    EXPECT_EQ(*handle->TryGet<absl::Duration>(), absl::Minutes(10));
533    handle = absl::FindCommandLineFlag("test_flag_13");
534    EXPECT_EQ(*handle->TryGet<absl::int128>(), absl::MakeInt128(-1, 0));
535    handle = absl::FindCommandLineFlag("test_flag_14");
536    EXPECT_EQ(*handle->TryGet<absl::uint128>(),
537              absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
538  }
539  TEST_F(FlagTest, ConcurrentSetAndGet) {
540    static constexpr int kNumThreads = 8;
541    static const absl::Duration kValidDurations[] = {
542        absl::Seconds(int64_t{0x6cebf47a9b68c802}) + absl::Nanoseconds(229702057),
543        absl::Seconds(int64_t{0x23fec0307e4e9d3}) + absl::Nanoseconds(44555374)};
544    absl::SetFlag(&FLAGS_test_flag_12, kValidDurations[0]);
545    std::atomic<bool> stop{false};
546    std::vector<std::thread> threads;
547    auto* handle = absl::FindCommandLineFlag("test_flag_12");
548    for (int i = 0; i < kNumThreads; i++) {
549      threads.emplace_back([&]() {
550        while (!stop.load(std::memory_order_relaxed)) {
551          absl::Duration v = absl::GetFlag(FLAGS_test_flag_12);
552          EXPECT_TRUE(v == kValidDurations[0] || v == kValidDurations[1]);
553          v = *handle->TryGet<absl::Duration>();
554          EXPECT_TRUE(v == kValidDurations[0] || v == kValidDurations[1]);
555        }
556      });
557    }
558    absl::Time end_time = absl::Now() + absl::Seconds(1);
559    int i = 0;
560    while (absl::Now() < end_time) {
561      absl::SetFlag(&FLAGS_test_flag_12,
562                    kValidDurations[i++ % ABSL_ARRAYSIZE(kValidDurations)]);
563    }
564    stop.store(true, std::memory_order_relaxed);
565    for (auto& t : threads) t.join();
566  }
567  int GetDflt1() { return 1; }
568  }  
569  ABSL_FLAG(int, test_int_flag_with_non_const_default, GetDflt1(),
570            "test int flag non const default");
571  ABSL_FLAG(std::string, test_string_flag_with_non_const_default,
572            absl::StrCat("AAA", "BBB"), "test string flag non const default");
573  namespace {
574  TEST_F(FlagTest, TestNonConstexprDefault) {
575    EXPECT_EQ(absl::GetFlag(FLAGS_test_int_flag_with_non_const_default), 1);
576    EXPECT_EQ(absl::GetFlag(FLAGS_test_string_flag_with_non_const_default),
577              "AAABBB");
578  }
579  }  
580  ABSL_FLAG(bool, test_flag_with_non_const_help, true,
581            absl::StrCat("test ", "flag ", "non const help"));
582  namespace {
583  #if !ABSL_FLAGS_STRIP_HELP
584  TEST_F(FlagTest, TestNonConstexprHelp) {
585    EXPECT_EQ(
586        absl::GetFlagReflectionHandle(FLAGS_test_flag_with_non_const_help).Help(),
587        "test flag non const help");
588  }
589  #endif  
590  int cb_test_value = -1;
591  void TestFlagCB();
592  }  
593  ABSL_FLAG(int, test_flag_with_cb, 100, "").OnUpdate(TestFlagCB);
594  ABSL_FLAG(int, test_flag_with_lambda_cb, 200, "").OnUpdate([]() {
595    cb_test_value = absl::GetFlag(FLAGS_test_flag_with_lambda_cb) +
596                    absl::GetFlag(FLAGS_test_flag_with_cb);
597  });
598  namespace {
599  void TestFlagCB() { cb_test_value = absl::GetFlag(FLAGS_test_flag_with_cb); }
600  TEST_F(FlagTest, CallbackInvocation) {
601    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_with_cb), 100);
602    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_with_lambda_cb), 200);
603    EXPECT_EQ(cb_test_value, 300);
604    absl::SetFlag(&FLAGS_test_flag_with_cb, 1);
605    EXPECT_EQ(cb_test_value, 1);
606    absl::SetFlag(&FLAGS_test_flag_with_lambda_cb, 3);
607    EXPECT_EQ(cb_test_value, 4);
608  }
609  struct CustomUDT {
610    CustomUDT() : a(1), b(1) {}
611    CustomUDT(int a_, int b_) : a(a_), b(b_) {}
612    friend bool operator==(const CustomUDT& f1, const CustomUDT& f2) {
613      return f1.a == f2.a && f1.b == f2.b;
614    }
615    int a;
616    int b;
617  };
618  bool AbslParseFlag(absl::string_view in, CustomUDT* f, std::string*) {
619    std::vector<absl::string_view> parts =
620        absl::StrSplit(in, ':', absl::SkipWhitespace());
621    if (parts.size() != 2) return false;
622    if (!absl::SimpleAtoi(parts[0], &f->a)) return false;
623    if (!absl::SimpleAtoi(parts[1], &f->b)) return false;
624    return true;
625  }
626  std::string AbslUnparseFlag(const CustomUDT& f) {
627    return absl::StrCat(f.a, ":", f.b);
628  }
629  }  
630  ABSL_FLAG(CustomUDT, test_flag_custom_udt, CustomUDT(), "test flag custom UDT");
631  namespace {
632  TEST_F(FlagTest, TestCustomUDT) {
633    EXPECT_EQ(flags::StorageKind<CustomUDT>(),
634              flags::FlagValueStorageKind::kOneWordAtomic);
635    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_custom_udt), CustomUDT(1, 1));
636    absl::SetFlag(&FLAGS_test_flag_custom_udt, CustomUDT(2, 3));
637    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_custom_udt), CustomUDT(2, 3));
638  }
639  #if !defined(_WIN32) && GTEST_HAS_DEATH_TEST
640  using FlagDeathTest = FlagTest;
641  TEST_F(FlagDeathTest, TestTypeMismatchValidations) {
642  #if !defined(NDEBUG)
643    EXPECT_DEATH_IF_SUPPORTED(
644        static_cast<void>(absl::GetFlag(FLAGS_mistyped_int_flag)),
645        "Flag 'mistyped_int_flag' is defined as one type and declared "
646        "as another");
647    EXPECT_DEATH_IF_SUPPORTED(
648        static_cast<void>(absl::GetFlag(FLAGS_mistyped_string_flag)),
649        "Flag 'mistyped_string_flag' is defined as one type and "
650        "declared as another");
651  #endif
652    EXPECT_DEATH_IF_SUPPORTED(
653        absl::SetFlag(&FLAGS_mistyped_int_flag, 1),
654        "Flag 'mistyped_int_flag' is defined as one type and declared "
655        "as another");
656    EXPECT_DEATH_IF_SUPPORTED(
657        absl::SetFlag(&FLAGS_mistyped_string_flag, std::vector<std::string>{}),
658        "Flag 'mistyped_string_flag' is defined as one type and declared as "
659        "another");
660  }
661  #endif
662  struct ConversionTestVal {
663    ConversionTestVal() = default;
664    explicit ConversionTestVal(int a_in) : a(a_in) {}
665    enum class ViaImplicitConv { kTen = 10, kEleven };
666    ConversionTestVal(ViaImplicitConv from) : a(static_cast<int>(from)) {}
667    int a;
668  };
669  bool AbslParseFlag(absl::string_view in, ConversionTestVal* val_out,
670                     std::string*) {
671    if (!absl::SimpleAtoi(in, &val_out->a)) {
672      return false;
673    }
674    return true;
675  }
676  std::string AbslUnparseFlag(const ConversionTestVal& val) {
677    return absl::StrCat(val.a);
678  }
679  }  
680  ABSL_FLAG(ConversionTestVal, test_flag_implicit_conv,
681            ConversionTestVal::ViaImplicitConv::kTen,
682            "test flag init via implicit conversion");
683  namespace {
684  TEST_F(FlagTest, CanSetViaImplicitConversion) {
685    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_implicit_conv).a, 10);
686    absl::SetFlag(&FLAGS_test_flag_implicit_conv,
687                  ConversionTestVal::ViaImplicitConv::kEleven);
688    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_implicit_conv).a, 11);
689  }
690  struct NonDfltConstructible {
691   public:
692    NonDfltConstructible(int i) : value(i) {}  
693    explicit NonDfltConstructible(char c) : value(100 + static_cast<int>(c)) {}
694    int value;
695  };
696  bool AbslParseFlag(absl::string_view in, NonDfltConstructible* ndc_out,
697                     std::string*) {
698    return absl::SimpleAtoi(in, &ndc_out->value);
699  }
700  std::string AbslUnparseFlag(const NonDfltConstructible& ndc) {
701    return absl::StrCat(ndc.value);
702  }
703  }  
704  ABSL_FLAG(NonDfltConstructible, ndc_flag1, NonDfltConstructible('1'),
705            "Flag with non default constructible type");
706  ABSL_FLAG(NonDfltConstructible, ndc_flag2, 0,
707            "Flag with non default constructible type");
708  namespace {
709  TEST_F(FlagTest, TestNonDefaultConstructibleType) {
710    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag1).value, '1' + 100);
711    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag2).value, 0);
712    absl::SetFlag(&FLAGS_ndc_flag1, NonDfltConstructible('A'));
713    absl::SetFlag(&FLAGS_ndc_flag2, 25);
714    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag1).value, 'A' + 100);
715    EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag2).value, 25);
716  }
717  }  
718  ABSL_RETIRED_FLAG(bool, old_bool_flag, true, "old descr");
719  ABSL_RETIRED_FLAG(int, old_int_flag, (int)std::sqrt(10), "old descr");
720  ABSL_RETIRED_FLAG(std::string, old_str_flag, "", absl::StrCat("old ", "descr"));
721  namespace {
722  bool initialization_order_fiasco_test ABSL_ATTRIBUTE_UNUSED = [] {
723    auto* handle1 = absl::FindCommandLineFlag("flag_on_separate_file");
724    auto* handle2 = absl::FindCommandLineFlag("retired_flag_on_separate_file");
725    if (handle1 != nullptr && handle2 != nullptr) {
726      return handle1->Name() == handle2->Name();
727    }
728    return true;
729  }();
730  TEST_F(FlagTest, TestRetiredFlagRegistration) {
731    auto* handle = absl::FindCommandLineFlag("old_bool_flag");
732    EXPECT_TRUE(handle->IsOfType<bool>());
733    EXPECT_TRUE(handle->IsRetired());
734    handle = absl::FindCommandLineFlag("old_int_flag");
735    EXPECT_TRUE(handle->IsOfType<int>());
736    EXPECT_TRUE(handle->IsRetired());
737    handle = absl::FindCommandLineFlag("old_str_flag");
738    EXPECT_TRUE(handle->IsOfType<std::string>());
739    EXPECT_TRUE(handle->IsRetired());
740  }
741  }  
742  namespace {
743  struct SmallAlignUDT {
744    SmallAlignUDT() : c('A'), s(12) {}
745    char c;
746    int16_t s;
747    char bytes[14];
748  };
749  bool AbslParseFlag(absl::string_view, SmallAlignUDT*, std::string*) {
750    return true;
751  }
752  std::string AbslUnparseFlag(const SmallAlignUDT&) { return ""; }
753  struct NonTriviallyCopyableUDT {
754    NonTriviallyCopyableUDT() : c('A') {}
755    NonTriviallyCopyableUDT(const NonTriviallyCopyableUDT& rhs) : c(rhs.c) {}
756    NonTriviallyCopyableUDT& operator=(const NonTriviallyCopyableUDT& rhs) {
757      c = rhs.c;
758      return *this;
759    }
760    char c;
761  };
762  bool AbslParseFlag(absl::string_view, NonTriviallyCopyableUDT*, std::string*) {
763    return true;
764  }
765  std::string AbslUnparseFlag(const NonTriviallyCopyableUDT&) { return ""; }
766  }  
767  ABSL_FLAG(SmallAlignUDT, test_flag_sa_udt, {}, "help");
768  ABSL_FLAG(NonTriviallyCopyableUDT, test_flag_ntc_udt, {}, "help");
769  namespace {
770  TEST_F(FlagTest, TestSmallAlignUDT) {
771    SmallAlignUDT value = absl::GetFlag(FLAGS_test_flag_sa_udt);
772    EXPECT_EQ(value.c, 'A');
773    EXPECT_EQ(value.s, 12);
774    value.c = 'B';
775    value.s = 45;
776    absl::SetFlag(&FLAGS_test_flag_sa_udt, value);
777    value = absl::GetFlag(FLAGS_test_flag_sa_udt);
778    EXPECT_EQ(value.c, 'B');
779    EXPECT_EQ(value.s, 45);
780  }
781  TEST_F(FlagTest, TestNonTriviallyCopyableUDT) {
782    NonTriviallyCopyableUDT value = absl::GetFlag(FLAGS_test_flag_ntc_udt);
783    EXPECT_EQ(value.c, 'A');
784    value.c = 'B';
785    absl::SetFlag(&FLAGS_test_flag_ntc_udt, value);
786    value = absl::GetFlag(FLAGS_test_flag_ntc_udt);
787    EXPECT_EQ(value.c, 'B');
788  }
789  }  
790  namespace {
791  enum TestE { A = 1, B = 2, C = 3 };
792  struct EnumWrapper {
793    EnumWrapper() : e(A) {}
794    TestE e;
795  };
796  bool AbslParseFlag(absl::string_view, EnumWrapper*, std::string*) {
797    return true;
798  }
799  std::string AbslUnparseFlag(const EnumWrapper&) { return ""; }
800  }  
801  ABSL_FLAG(EnumWrapper, test_enum_wrapper_flag, {}, "help");
802  TEST_F(FlagTest, TesTypeWrappingEnum) {
803    EnumWrapper value = absl::GetFlag(FLAGS_test_enum_wrapper_flag);
804    EXPECT_EQ(value.e, A);
805    value.e = B;
806    absl::SetFlag(&FLAGS_test_enum_wrapper_flag, value);
807    value = absl::GetFlag(FLAGS_test_enum_wrapper_flag);
808    EXPECT_EQ(value.e, B);
809  }
810  #define FLAG_NAME_MACRO(name) prefix_##name
811  ABSL_DECLARE_FLAG(int, FLAG_NAME_MACRO(test_macro_named_flag));
812  ABSL_FLAG(int, FLAG_NAME_MACRO(test_macro_named_flag), 0,
813            "Testing macro expansion within ABSL_FLAG");
814  TEST_F(FlagTest, MacroWithinAbslFlag) {
815    EXPECT_EQ(absl::GetFlag(FLAGS_prefix_test_macro_named_flag), 0);
816    absl::SetFlag(&FLAGS_prefix_test_macro_named_flag, 1);
817    EXPECT_EQ(absl::GetFlag(FLAGS_prefix_test_macro_named_flag), 1);
818  }
819  #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
820  #define ABSL_SKIP_OPTIONAL_BOOL_TEST_DUE_TO_GCC_BUG
821  #endif
822  #ifndef ABSL_SKIP_OPTIONAL_BOOL_TEST_DUE_TO_GCC_BUG
823  ABSL_FLAG(absl::optional<bool>, optional_bool, absl::nullopt, "help");
824  #endif
825  ABSL_FLAG(absl::optional<int>, optional_int, {}, "help");
826  ABSL_FLAG(absl::optional<double>, optional_double, 9.3, "help");
827  ABSL_FLAG(absl::optional<std::string>, optional_string, absl::nullopt, "help");
828  ABSL_FLAG(absl::optional<absl::Duration>, optional_duration, absl::nullopt,
829            "help");
830  ABSL_FLAG(absl::optional<absl::optional<int>>, optional_optional_int,
831            absl::nullopt, "help");
832  #if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
833  ABSL_FLAG(std::optional<int64_t>, std_optional_int64, std::nullopt, "help");
834  #endif
835  namespace {
836  #ifndef ABSL_SKIP_OPTIONAL_BOOL_TEST_DUE_TO_GCC_BUG
837  TEST_F(FlagTest, TestOptionalBool) {
838    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_bool).has_value());
839    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), absl::nullopt);
840    absl::SetFlag(&FLAGS_optional_bool, false);
841    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_bool).has_value());
842    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), false);
843    absl::SetFlag(&FLAGS_optional_bool, true);
844    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_bool).has_value());
845    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), true);
846    absl::SetFlag(&FLAGS_optional_bool, absl::nullopt);
847    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_bool).has_value());
848    EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), absl::nullopt);
849  }
850  #endif
851  TEST_F(FlagTest, TestOptionalInt) {
852    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_int).has_value());
853    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), absl::nullopt);
854    absl::SetFlag(&FLAGS_optional_int, 0);
855    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_int).has_value());
856    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), 0);
857    absl::SetFlag(&FLAGS_optional_int, 10);
858    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_int).has_value());
859    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), 10);
860    absl::SetFlag(&FLAGS_optional_int, absl::nullopt);
861    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_int).has_value());
862    EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), absl::nullopt);
863  }
864  TEST_F(FlagTest, TestOptionalDouble) {
865    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
866    EXPECT_DOUBLE_EQ(*absl::GetFlag(FLAGS_optional_double), 9.3);
867    absl::SetFlag(&FLAGS_optional_double, 0.0);
868    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
869    EXPECT_EQ(absl::GetFlag(FLAGS_optional_double), 0.0);
870    absl::SetFlag(&FLAGS_optional_double, 1.234);
871    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
872    EXPECT_DOUBLE_EQ(*absl::GetFlag(FLAGS_optional_double), 1.234);
873    absl::SetFlag(&FLAGS_optional_double, absl::nullopt);
874    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_double).has_value());
875    EXPECT_EQ(absl::GetFlag(FLAGS_optional_double), absl::nullopt);
876  }
877  TEST_F(FlagTest, TestOptionalString) {
878    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_string).has_value());
879    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), absl::nullopt);
880    absl::SetFlag(&FLAGS_optional_string, " ");
881    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_string).has_value());
882    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), " ");
883    absl::SetFlag(&FLAGS_optional_string, "QWERTY");
884    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_string).has_value());
885    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), "QWERTY");
886    absl::SetFlag(&FLAGS_optional_string, absl::nullopt);
887    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_string).has_value());
888    EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), absl::nullopt);
889  }
890  TEST_F(FlagTest, TestOptionalDuration) {
891    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_duration).has_value());
892    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::nullopt);
893    absl::SetFlag(&FLAGS_optional_duration, absl::ZeroDuration());
894    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_duration).has_value());
895    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::Seconds(0));
896    absl::SetFlag(&FLAGS_optional_duration, absl::Hours(3));
897    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_duration).has_value());
898    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::Hours(3));
899    absl::SetFlag(&FLAGS_optional_duration, absl::nullopt);
900    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_duration).has_value());
901    EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::nullopt);
902  }
903  TEST_F(FlagTest, TestOptionalOptional) {
904    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
905    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::nullopt);
906    absl::optional<int> nullint{absl::nullopt};
907    absl::SetFlag(&FLAGS_optional_optional_int, nullint);
908    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
909    EXPECT_NE(absl::GetFlag(FLAGS_optional_optional_int), nullint);
910    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int),
911              absl::optional<absl::optional<int>>{nullint});
912    absl::SetFlag(&FLAGS_optional_optional_int, 0);
913    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
914    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), 0);
915    absl::SetFlag(&FLAGS_optional_optional_int, absl::optional<int>{0});
916    EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
917    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), 0);
918    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::optional<int>{0});
919    absl::SetFlag(&FLAGS_optional_optional_int, absl::nullopt);
920    EXPECT_FALSE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
921    EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::nullopt);
922  }
923  #if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
924  TEST_F(FlagTest, TestStdOptional) {
925    EXPECT_FALSE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
926    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), std::nullopt);
927    absl::SetFlag(&FLAGS_std_optional_int64, 0);
928    EXPECT_TRUE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
929    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), 0);
930    absl::SetFlag(&FLAGS_std_optional_int64, 0xFFFFFFFFFF16);
931    EXPECT_TRUE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
932    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), 0xFFFFFFFFFF16);
933    absl::SetFlag(&FLAGS_std_optional_int64, std::nullopt);
934    EXPECT_FALSE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
935    EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), std::nullopt);
936  }
937  #endif
938  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-flag_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>268    TFltVV NewW(NumNodes, NumRoles);
269    TFltVV NewH(NumRoles, NumFeatures);
270    TFltVV Product(NumNodes, NumFeatures);
271    TFltV Sum(NumRoles);
272    TFltVV *PW = &W, *PH = &H, *PNewW = &NewW, *PNewH = &NewH, *Tmp;
</pre></code></div>
                <div class="column column_space"><pre><code>77    EXPECT_EQ(flags::StorageKind<int>(),
78              flags::FlagValueStorageKind::kValueAndInitBit);
79    EXPECT_EQ(flags::StorageKind<bool>(),
80              flags::FlagValueStorageKind::kValueAndInitBit);
81    EXPECT_EQ(flags::StorageKind<double>(),
82              flags::FlagValueStorageKind::kOneWordAtomic);
83    EXPECT_EQ(flags::StorageKind<int64_t>(),
84              flags::FlagValueStorageKind::kOneWordAtomic);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    