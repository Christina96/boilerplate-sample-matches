
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.27777777777778%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_im2col_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "gtest/gtest.h"
3  #include "caffe/blob.hpp"
4  #include "caffe/common.hpp"
5  #include "caffe/filler.hpp"
6  #include "caffe/layers/im2col_layer.hpp"
7  #include "caffe/test/test_caffe_main.hpp"
8  #include "caffe/test/test_gradient_check_util.hpp"
9  namespace caffe {
10  template <typename TypeParam>
11  class Im2colLayerTest : public MultiDeviceTest<TypeParam> {
12    typedef typename TypeParam::Dtype Dtype;
13   protected:
14    Im2colLayerTest()
15        : blob_bottom_(new Blob<Dtype>(2, 3, 6, 5)),
16          blob_top_(new Blob<Dtype>()) {
17      Caffe::set_random_seed(1701);
18      FillerParameter filler_param;
19      GaussianFiller<Dtype> filler(filler_param);
20      filler.Fill(this->blob_bottom_);
21      blob_bottom_vec_.push_back(blob_bottom_);
22      blob_top_vec_.push_back(blob_top_);
23    }
24    virtual ~Im2colLayerTest() { delete blob_bottom_; delete blob_top_; }
25    Blob<Dtype>* const blob_bottom_;
26    Blob<Dtype>* const blob_top_;
27    vector<Blob<Dtype>*> blob_bottom_vec_;
28    vector<Blob<Dtype>*> blob_top_vec_;
29  };
30  TYPED_TEST_CASE(Im2colLayerTest, TestDtypesAndDevices);
31  TYPED_TEST(Im2colLayerTest, TestSetup) {
32    typedef typename TypeParam::Dtype Dtype;
33    LayerParameter layer_param;
34    ConvolutionParameter* convolution_param =
35        layer_param.mutable_convolution_param();
36    vector<int> bottom_shape;
37    bottom_shape.push_back(2);
38    bottom_shape.push_back(3);
39    bottom_shape.push_back(10);
40    bottom_shape.push_back(11);
41    this->blob_bottom_->Reshape(bottom_shape);
42    convolution_param->add_kernel_size(3);
43    convolution_param->add_stride(2);
44    convolution_param->add_dilation(3);
45    Im2colLayer<Dtype> layer(layer_param);
46    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
47    EXPECT_EQ(this->blob_top_->num(), 2);
48    EXPECT_EQ(this->blob_top_->channels(), 27);
49    EXPECT_EQ(this->blob_top_->height(), 2);
50    EXPECT_EQ(this->blob_top_->width(), 3);
51  }
52  TYPED_TEST(Im2colLayerTest, TestForward) {
53    typedef typename TypeParam::Dtype Dtype;
54    LayerParameter layer_param;
55    ConvolutionParameter* convolution_param =
56        layer_param.mutable_convolution_param();
57    convolution_param->add_kernel_size(3);
58    convolution_param->add_stride(2);
59    Im2colLayer<Dtype> layer(layer_param);
60    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
61    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
62    for (int c = 0; c < 27; ++c) {
63      EXPECT_EQ(this->blob_bottom_->data_at(0, (c / 9), (c / 3) % 3, c % 3),
64          this->blob_top_->data_at(0, c, 0, 0));
65    }
66  }
67  TYPED_TEST(Im2colLayerTest, TestGradient) {
68    typedef typename TypeParam::Dtype Dtype;
69    LayerParameter layer_param;
70    ConvolutionParameter* convolution_param =
71        layer_param.mutable_convolution_param();
72    convolution_param->add_kernel_size(3);
73    convolution_param->add_stride(2);
74    Im2colLayer<Dtype> layer(layer_param);
75    GradientChecker<Dtype> checker(1e-2, 1e-2);
76    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
77        this->blob_top_vec_);
78  }
79  TYPED_TEST(Im2colLayerTest, TestDilatedGradient) {
80    typedef typename TypeParam::Dtype Dtype;
81    LayerParameter layer_param;
82    ConvolutionParameter* convolution_param =
83        layer_param.mutable_convolution_param();
84    vector<int> bottom_shape;
85    bottom_shape.push_back(2);
86    bottom_shape.push_back(3);
87    bottom_shape.push_back(10);
88    bottom_shape.push_back(9);
89    this->blob_bottom_->Reshape(bottom_shape);
90    convolution_param->add_kernel_size(3);
91    convolution_param->add_stride(2);
92    convolution_param->add_dilation(3);
93    Im2colLayer<Dtype> layer(layer_param);
94    GradientChecker<Dtype> checker(1e-2, 1e-2);
95    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
96                                    this->blob_top_vec_);
97  }
98  TYPED_TEST(Im2colLayerTest, TestGradientForceND) {
99    typedef typename TypeParam::Dtype Dtype;
100    LayerParameter layer_param;
101    ConvolutionParameter* convolution_param =
102        layer_param.mutable_convolution_param();
103    convolution_param->add_kernel_size(3);
104    convolution_param->add_stride(2);
105    convolution_param->set_force_nd_im2col(true);
106    Im2colLayer<Dtype> layer(layer_param);
107    GradientChecker<Dtype> checker(1e-2, 1e-2);
108    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
109        this->blob_top_vec_);
110  }
111  TYPED_TEST(Im2colLayerTest, TestDilatedGradientForceND) {
112    typedef typename TypeParam::Dtype Dtype;
113    LayerParameter layer_param;
114    ConvolutionParameter* convolution_param =
115        layer_param.mutable_convolution_param();
116    vector<int> bottom_shape;
117    bottom_shape.push_back(2);
118    bottom_shape.push_back(3);
119    bottom_shape.push_back(10);
<span onclick='openModal()' class='match'>120    bottom_shape.push_back(9);
121    this->blob_bottom_->Reshape(bottom_shape);
122    convolution_param->add_kernel_size(3);
123    convolution_param->add_stride(2);
124    convolution_param->add_dilation(3);
125    convolution_param->set_force_nd_im2col(true);
126    Im2colLayer<Dtype> layer(layer_param);
127    GradientChecker<Dtype> checker(1e-2, 1e-2);
128    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
</span>129                                    this->blob_top_vec_);
130  }
131  TYPED_TEST(Im2colLayerTest, TestRect) {
132    typedef typename TypeParam::Dtype Dtype;
133    LayerParameter layer_param;
134    ConvolutionParameter* convolution_param =
135        layer_param.mutable_convolution_param();
136    convolution_param->set_kernel_h(5);
137    convolution_param->set_kernel_w(3);
138    convolution_param->add_stride(2);
139    Im2colLayer<Dtype> layer(layer_param);
140    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
141    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
142    for (int c = 0; c < 45; ++c) {
143      EXPECT_EQ(this->blob_top_->data_at(0, c, 0, 0),
144          this->blob_bottom_->data_at(0, (c / 15), (c / 3) % 5, c % 3));
145    }
146  }
147  TYPED_TEST(Im2colLayerTest, TestRectGradient) {
148    typedef typename TypeParam::Dtype Dtype;
149    LayerParameter layer_param;
150    ConvolutionParameter* convolution_param =
151        layer_param.mutable_convolution_param();
152    convolution_param->set_kernel_h(5);
153    convolution_param->set_kernel_w(3);
154    convolution_param->add_stride(2);
155    Im2colLayer<Dtype> layer(layer_param);
156    GradientChecker<Dtype> checker(1e-2, 1e-2);
157    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
158        this->blob_top_vec_);
159  }
160  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_multibox_loss_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cmath>
3  #include <string>
4  #include <vector>
5  #include "boost/scoped_ptr.hpp"
6  #include "gtest/gtest.h"
7  #include "caffe/blob.hpp"
8  #include "caffe/common.hpp"
9  #include "caffe/filler.hpp"
10  #include "caffe/layers/annotated_data_layer.hpp"
11  #include "caffe/layers/conv_layer.hpp"
12  #include "caffe/layers/flatten_layer.hpp"
13  #include "caffe/layers/multibox_loss_layer.hpp"
14  #include "caffe/layers/permute_layer.hpp"
15  #include "caffe/layers/pooling_layer.hpp"
16  #include "caffe/layers/prior_box_layer.hpp"
17  #include "caffe/proto/caffe.pb.h"
18  #include "caffe/util/db.hpp"
19  #include "caffe/util/io.hpp"
20  #ifdef USE_CUDNN
21  #include "caffe/layers/cudnn_conv_layer.hpp"
22  #endif
23  #include "caffe/test/test_caffe_main.hpp"
24  #include "caffe/test/test_gradient_check_util.hpp"
25  using boost::scoped_ptr;
26  namespace caffe {
27  static bool kBoolChoices[] = {true, false};
28  static MultiBoxLossParameter_LocLossType kLocLossTypes[] = {
29    MultiBoxLossParameter_LocLossType_L2,
30    MultiBoxLossParameter_LocLossType_SMOOTH_L1};
31  static MultiBoxLossParameter_ConfLossType kConfLossTypes[] = {
32    MultiBoxLossParameter_ConfLossType_SOFTMAX,
33    MultiBoxLossParameter_ConfLossType_LOGISTIC};
34  static MultiBoxLossParameter_MatchType kMatchTypes[] = {
35    MultiBoxLossParameter_MatchType_BIPARTITE,
36    MultiBoxLossParameter_MatchType_PER_PREDICTION};
37  static LossParameter_NormalizationMode kNormalizationModes[] = {
38    LossParameter_NormalizationMode_BATCH_SIZE,
39    LossParameter_NormalizationMode_FULL,
40    LossParameter_NormalizationMode_VALID,
41    LossParameter_NormalizationMode_NONE};
42  static MultiBoxLossParameter_MiningType kMiningType[] = {
43    MultiBoxLossParameter_MiningType_NONE,
44    MultiBoxLossParameter_MiningType_MAX_NEGATIVE,
45    MultiBoxLossParameter_MiningType_HARD_EXAMPLE};
46  template <typename TypeParam>
47  class MultiBoxLossLayerTest : public MultiDeviceTest<TypeParam> {
48    typedef typename TypeParam::Dtype Dtype;
49   protected:
50    MultiBoxLossLayerTest()
51        : num_(3),
52          num_classes_(3),
53          width_(2),
54          height_(2),
55          num_priors_per_location_(4),
56          num_priors_(width_ * height_ * num_priors_per_location_),
57          blob_bottom_loc_(new Blob<Dtype>(num_, num_priors_ * 4, 1, 1)),
58          blob_bottom_conf_(new Blob<Dtype>(
59                  num_, num_priors_ * num_classes_, 1, 1)),
60          blob_bottom_prior_(new Blob<Dtype>(num_, 2, num_priors_ * 4, 1)),
61          blob_bottom_gt_(new Blob<Dtype>(1, 1, 4, 7)),
62          blob_top_loss_(new Blob<Dtype>()) {
63      blob_bottom_vec_.push_back(blob_bottom_loc_);
64      blob_bottom_vec_.push_back(blob_bottom_conf_);
65      blob_bottom_vec_.push_back(blob_bottom_prior_);
66      blob_bottom_vec_.push_back(blob_bottom_gt_);
67      blob_top_vec_.push_back(blob_top_loss_);
68    }
69    virtual ~MultiBoxLossLayerTest() {
70      delete blob_bottom_prior_;
71      delete blob_bottom_loc_;
72      delete blob_bottom_conf_;
73      delete blob_bottom_gt_;
74      delete blob_top_loss_;
75    }
76    void FillItem(Dtype* blob_data, const string values) {
77      vector<string> items;
78      std::istringstream iss(values);
79      std::copy(std::istream_iterator<string>(iss),
80                std::istream_iterator<string>(), back_inserter(items));
81      int num_items = items.size();
82      CHECK_EQ(num_items, 8);
83      for (int i = 0; i < 8; ++i) {
84        if (i >= 3 && i <= 6) {
85          blob_data[i] = atof(items[i].c_str());
86        } else {
87          blob_data[i] = atoi(items[i].c_str());
88        }
89      }
90    }
91    void Fill(bool share_location) {
92      int loc_classes = share_location ? 1 : num_classes_;
93      vector<Blob<Dtype>*> fake_bottom_vec;
94      vector<Blob<Dtype>*> fake_top_vec;
95      LayerParameter layer_param;
96      Blob<Dtype>* fake_input = new Blob<Dtype>(num_, 3, 20, 20);
97  #ifdef USE_LMDB
98      string filename;
99      GetTempDirname(&filename);
100      DataParameter_DB backend = DataParameter_DB_LMDB;
101      scoped_ptr<db::DB> db(db::GetDB(backend));
102      db->Open(filename, db::NEW);
103      scoped_ptr<db::Transaction> txn(db->NewTransaction());
104      for (int i = 0; i < num_; ++i) {
105        AnnotatedDatum anno_datum;
106        Datum* datum = anno_datum.mutable_datum();
107        datum->set_channels(3);
108        datum->set_height(20);
109        datum->set_width(20);
110        std::string* data = datum->mutable_data();
111        for (int j = 0; j < 3*20*20; ++j) {
112          data->push_back(static_cast<uint8_t>(j/100.));
113        }
114        anno_datum.set_type(AnnotatedDatum_AnnotationType_BBOX);
115        if (i == 0 || i == 2) {
116          AnnotationGroup* anno_group = anno_datum.add_annotation_group();
117          anno_group->set_group_label(1);
118          Annotation* anno = anno_group->add_annotation();
119          anno->set_instance_id(0);
120          NormalizedBBox* bbox = anno->mutable_bbox();
121          bbox->set_xmin(0.1);
122          bbox->set_ymin(0.1);
123          bbox->set_xmax(0.3);
124          bbox->set_ymax(0.3);
125          bbox->set_difficult(i % 2);
126        }
127        if (i == 2) {
128          AnnotationGroup* anno_group = anno_datum.add_annotation_group();
129          anno_group->set_group_label(2);
130          Annotation* anno = anno_group->add_annotation();
131          anno->set_instance_id(0);
132          NormalizedBBox* bbox = anno->mutable_bbox();
133          bbox->set_xmin(0.2);
134          bbox->set_ymin(0.2);
135          bbox->set_xmax(0.4);
136          bbox->set_ymax(0.4);
137          bbox->set_difficult(i % 2);
138          anno = anno_group->add_annotation();
139          anno->set_instance_id(1);
140          bbox = anno->mutable_bbox();
141          bbox->set_xmin(0.6);
142          bbox->set_ymin(0.6);
143          bbox->set_xmax(0.8);
144          bbox->set_ymax(0.9);
145          bbox->set_difficult((i + 1) % 2);
146        }
147        string key_str = caffe::format_int(i, 3);
148        string out;
149        CHECK(anno_datum.SerializeToString(&out));
150        txn->Put(key_str, out);
151      }
152      txn->Commit();
153      db->Close();
154      DataParameter* data_param = layer_param.mutable_data_param();
155      data_param->set_batch_size(num_);
156      data_param->set_source(filename.c_str());
157      data_param->set_backend(backend);
158      AnnotatedDataLayer<Dtype> anno_data_layer(layer_param);
159      fake_top_vec.clear();
160      fake_top_vec.push_back(fake_input);
161      fake_top_vec.push_back(blob_bottom_gt_);
162      anno_data_layer.SetUp(fake_bottom_vec, fake_top_vec);
163      anno_data_layer.Forward(fake_bottom_vec, fake_top_vec);
164  #else
165      FillerParameter filler_param;
166      GaussianFiller<Dtype> filler(filler_param);
167      filler.Fill(fake_input);
168      vector<int> gt_shape(4, 1);
169      gt_shape[2] = 4;
170      gt_shape[3] = 8;
171      blob_bottom_gt_->Reshape(gt_shape);
172      Dtype* gt_data = blob_bottom_gt_->mutable_cpu_data();
173      FillItem(gt_data, "0 1 0 0.1 0.1 0.3 0.3 0");
174      FillItem(gt_data + 8, "2 1 0 0.1 0.1 0.3 0.3 0");
175      FillItem(gt_data + 8 * 2, "2 2 0 0.2 0.2 0.4 0.4 0");
176      FillItem(gt_data + 8 * 3, "2 2 1 0.6 0.6 0.8 0.9 1");
177  #endif  
178      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
179      pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
180      pooling_param->set_kernel_size(10);
181      pooling_param->set_stride(10);
182      PoolingLayer<Dtype> pooling_layer(layer_param);
183      Blob<Dtype>* fake_blob = new Blob<Dtype>(num_, 5, height_, width_);
184      fake_bottom_vec.clear();
185      fake_bottom_vec.push_back(fake_input);
186      fake_top_vec.clear();
187      fake_top_vec.push_back(fake_blob);
188      pooling_layer.SetUp(fake_bottom_vec, fake_top_vec);
189      pooling_layer.Forward(fake_bottom_vec, fake_top_vec);
190      ConvolutionParameter* convolution_param =
191          layer_param.mutable_convolution_param();
192      convolution_param->add_pad(0);
193      convolution_param->add_kernel_size(1);
194      convolution_param->add_stride(1);
195      int num_output = num_priors_per_location_ * loc_classes * 4;
196      convolution_param->set_num_output(num_output);
197      convolution_param->mutable_weight_filler()->set_type("xavier");
198      convolution_param->mutable_bias_filler()->set_type("constant");
199      convolution_param->mutable_bias_filler()->set_value(0.1);
200      ConvolutionLayer<Dtype> conv_layer_loc(layer_param);
201      fake_bottom_vec.clear();
202      fake_bottom_vec.push_back(fake_blob);
203      Blob<Dtype> fake_output_loc;
204      fake_top_vec.clear();
205      fake_top_vec.push_back(&fake_output_loc);
206      conv_layer_loc.SetUp(fake_bottom_vec, fake_top_vec);
207      conv_layer_loc.Forward(fake_bottom_vec, fake_top_vec);
208      PermuteParameter* permute_param = layer_param.mutable_permute_param();
209      permute_param->add_order(0);
210      permute_param->add_order(2);
211      permute_param->add_order(3);
212      permute_param->add_order(1);
213      PermuteLayer<Dtype> permute_layer(layer_param);
214      fake_bottom_vec.clear();
215      fake_bottom_vec.push_back(&fake_output_loc);
216      fake_top_vec.clear();
217      Blob<Dtype> fake_permute_loc;
218      fake_top_vec.push_back(&fake_permute_loc);
219      permute_layer.SetUp(fake_bottom_vec, fake_top_vec);
220      permute_layer.Forward(fake_bottom_vec, fake_top_vec);
221      FlattenParameter* flatten_param = layer_param.mutable_flatten_param();
222      flatten_param->set_axis(1);
223      FlattenLayer<Dtype> flatten_layer(layer_param);
224      vector<int> loc_shape(4, 1);
225      loc_shape[0] = num_;
226      loc_shape[1] = num_output * height_ * width_;
227      blob_bottom_loc_->Reshape(loc_shape);
228      fake_bottom_vec.clear();
229      fake_bottom_vec.push_back(&fake_permute_loc);
230      fake_top_vec.clear();
231      fake_top_vec.push_back(blob_bottom_loc_);
232      flatten_layer.SetUp(fake_bottom_vec, fake_top_vec);
233      flatten_layer.Forward(fake_bottom_vec, fake_top_vec);
234      convolution_param->set_num_output(num_priors_per_location_ * num_classes_);
235      ConvolutionLayer<Dtype> conv_layer_conf(layer_param);
236      fake_bottom_vec.clear();
237      fake_bottom_vec.push_back(fake_blob);
238      num_output = num_priors_per_location_ * num_classes_;
239      Blob<Dtype> fake_output_conf;
240      fake_top_vec.clear();
241      fake_top_vec.push_back(&fake_output_conf);
242      conv_layer_conf.SetUp(fake_bottom_vec, fake_top_vec);
243      conv_layer_conf.Forward(fake_bottom_vec, fake_top_vec);
244      fake_bottom_vec.clear();
245      fake_bottom_vec.push_back(&fake_output_conf);
246      fake_top_vec.clear();
247      Blob<Dtype> fake_permute_conf;
248      fake_top_vec.push_back(&fake_permute_conf);
249      permute_layer.SetUp(fake_bottom_vec, fake_top_vec);
250      permute_layer.Forward(fake_bottom_vec, fake_top_vec);
251      vector<int> conf_shape(4, 1);
252      conf_shape[0] = num_;
253      conf_shape[1] = num_output * height_ * width_;
254      blob_bottom_conf_->Reshape(conf_shape);
255      fake_bottom_vec.clear();
256      fake_bottom_vec.push_back(&fake_permute_conf);
257      fake_top_vec.clear();
258      fake_top_vec.push_back(blob_bottom_conf_);
259      flatten_layer.SetUp(fake_bottom_vec, fake_top_vec);
260      flatten_layer.Forward(fake_bottom_vec, fake_top_vec);
261      PriorBoxParameter* prior_box_param = layer_param.mutable_prior_box_param();
262      prior_box_param->add_min_size(5);
263      prior_box_param->add_max_size(10);
264      prior_box_param->add_aspect_ratio(3.);
265      prior_box_param->set_flip(true);
266      PriorBoxLayer<Dtype> prior_layer(layer_param);
267      fake_bottom_vec.clear();
268      fake_bottom_vec.push_back(fake_blob);
269      fake_bottom_vec.push_back(fake_input);
270      fake_top_vec.clear();
271      fake_top_vec.push_back(blob_bottom_prior_);
272      prior_layer.SetUp(fake_bottom_vec, fake_top_vec);
273      prior_layer.Forward(fake_bottom_vec, fake_top_vec);
274      delete fake_blob;
275      delete fake_input;
276    }
277    int num_;
278    int num_classes_;
279    int width_;
280    int height_;
281    int num_priors_per_location_;
282    int num_priors_;
283    Blob<Dtype>* const blob_bottom_loc_;
284    Blob<Dtype>* const blob_bottom_conf_;
285    Blob<Dtype>* const blob_bottom_prior_;
286    Blob<Dtype>* const blob_bottom_gt_;
287    Blob<Dtype>* const blob_top_loss_;
288    vector<Blob<Dtype>*> blob_bottom_vec_;
289    vector<Blob<Dtype>*> blob_top_vec_;
290  };
291  TYPED_TEST_CASE(MultiBoxLossLayerTest, TestDtypesAndDevices);
292  TYPED_TEST(MultiBoxLossLayerTest, TestSetUp) {
293    typedef typename TypeParam::Dtype Dtype;
294    LayerParameter layer_param;
295    MultiBoxLossParameter* multibox_loss_param =
296        layer_param.mutable_multibox_loss_param();
297    multibox_loss_param->set_num_classes(3);
298    for (int i = 0; i < 2; ++i) {
299      bool share_location = kBoolChoices[i];
300      this->Fill(share_location);
301      for (int j = 0; j < 2; ++j) {
302        MultiBoxLossParameter_MatchType match_type = kMatchTypes[j];
303        for (int k = 0; k < 2; ++k) {
304          bool use_prior = kBoolChoices[k];
305          for (int m = 0; m < 3; ++m) {
306            MiningType mining_type = kMiningType[m];
307            if (!share_location &&
308                mining_type != MultiBoxLossParameter_MiningType_NONE) {
309              continue;
310            }
311            multibox_loss_param->set_share_location(share_location);
312            multibox_loss_param->set_match_type(match_type);
313            multibox_loss_param->set_use_prior_for_matching(use_prior);
314            multibox_loss_param->set_mining_type(mining_type);
315            MultiBoxLossLayer<Dtype> layer(layer_param);
316            layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
317          }
318        }
319      }
320    }
321  }
322  TYPED_TEST(MultiBoxLossLayerTest, TestLocGradient) {
323    typedef typename TypeParam::Dtype Dtype;
324    LayerParameter layer_param;
325    layer_param.add_propagate_down(true);
326    layer_param.add_propagate_down(false);
327    LossParameter* loss_param = layer_param.mutable_loss_param();
328    MultiBoxLossParameter* multibox_loss_param =
329        layer_param.mutable_multibox_loss_param();
330    multibox_loss_param->set_num_classes(this->num_classes_);
331    for (int l = 0; l < 2; ++l) {
332      MultiBoxLossParameter_LocLossType loc_loss_type = kLocLossTypes[l];
333      for (int i = 0; i < 2; ++i) {
334        bool share_location = kBoolChoices[i];
335        this->Fill(share_location);
336        for (int j = 0; j < 2; ++j) {
337          MultiBoxLossParameter_MatchType match_type = kMatchTypes[j];
338          for (int k = 0; k < 1; ++k) {
339            bool use_prior = kBoolChoices[k];
340            for (int n = 0; n < 4; ++n) {
341              LossParameter_NormalizationMode normalize = kNormalizationModes[n];
342              loss_param->set_normalization(normalize);
343              for (int u = 0; u < 2; ++u) {
344                bool use_difficult_gt = kBoolChoices[u];
345                for (int m = 0; m < 3; ++m) {
346                  MiningType mining_type = kMiningType[m];
347                  if (!share_location &&
348                      mining_type != MultiBoxLossParameter_MiningType_NONE) {
349                    continue;
350                  }
<span onclick='openModal()' class='match'>351                  multibox_loss_param->set_loc_loss_type(loc_loss_type);
352                  multibox_loss_param->set_share_location(share_location);
353                  multibox_loss_param->set_match_type(match_type);
354                  multibox_loss_param->set_use_prior_for_matching(use_prior);
355                  multibox_loss_param->set_use_difficult_gt(use_difficult_gt);
356                  multibox_loss_param->set_mining_type(mining_type);
357                  MultiBoxLossLayer<Dtype> layer(layer_param);
358                  GradientChecker<Dtype> checker(1e-2, 1e-2, 1701);
359                  checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
</span>360                                                  this->blob_top_vec_, 0);
361                }
362              }
363            }
364          }
365        }
366      }
367    }
368  }
369  TYPED_TEST(MultiBoxLossLayerTest, TestConfGradient) {
370    typedef typename TypeParam::Dtype Dtype;
371    LayerParameter layer_param;
372    LossParameter* loss_param = layer_param.mutable_loss_param();
373    layer_param.add_propagate_down(false);
374    layer_param.add_propagate_down(true);
375    MultiBoxLossParameter* multibox_loss_param =
376        layer_param.mutable_multibox_loss_param();
377    multibox_loss_param->set_num_classes(this->num_classes_);
378    for (int c = 0; c < 2; ++c) {
379      MultiBoxLossParameter_ConfLossType conf_loss_type = kConfLossTypes[c];
380      for (int i = 0; i < 2; ++i) {
381        bool share_location = kBoolChoices[i];
382        this->Fill(share_location);
383        for (int j = 0; j < 2; ++j) {
384          MultiBoxLossParameter_MatchType match_type = kMatchTypes[j];
385          for (int k = 0; k < 1; ++k) {
386            bool use_prior = kBoolChoices[k];
387            for (int n = 0; n < 4; ++n) {
388              LossParameter_NormalizationMode normalize = kNormalizationModes[n];
389              loss_param->set_normalization(normalize);
390              for (int u = 0; u < 2; ++u) {
391                bool use_difficult_gt = kBoolChoices[u];
392                for (int m = 0; m < 3; ++m) {
393                  MiningType mining_type = kMiningType[m];
394                  if (!share_location &&
395                      mining_type != MultiBoxLossParameter_MiningType_NONE) {
396                    continue;
397                  }
398                  multibox_loss_param->set_conf_loss_type(conf_loss_type);
399                  multibox_loss_param->set_share_location(share_location);
400                  multibox_loss_param->set_match_type(match_type);
401                  multibox_loss_param->set_use_prior_for_matching(use_prior);
402                  multibox_loss_param->set_use_difficult_gt(use_difficult_gt);
403                  multibox_loss_param->set_background_label_id(0);
404                  multibox_loss_param->set_mining_type(mining_type);
405                  MultiBoxLossLayer<Dtype> layer(layer_param);
406                  GradientChecker<Dtype> checker(1e-2, 1e-2, 1701);
407                  checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
408                                                  this->blob_top_vec_, 1);
409                }
410              }
411            }
412          }
413        }
414      }
415    }
416  }
417  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_im2col_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_multibox_loss_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>120    bottom_shape.push_back(9);
121    this->blob_bottom_->Reshape(bottom_shape);
122    convolution_param->add_kernel_size(3);
123    convolution_param->add_stride(2);
124    convolution_param->add_dilation(3);
125    convolution_param->set_force_nd_im2col(true);
126    Im2colLayer<Dtype> layer(layer_param);
127    GradientChecker<Dtype> checker(1e-2, 1e-2);
128    checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
</pre></code></div>
                <div class="column column_space"><pre><code>351                  multibox_loss_param->set_loc_loss_type(loc_loss_type);
352                  multibox_loss_param->set_share_location(share_location);
353                  multibox_loss_param->set_match_type(match_type);
354                  multibox_loss_param->set_use_prior_for_matching(use_prior);
355                  multibox_loss_param->set_use_difficult_gt(use_difficult_gt);
356                  multibox_loss_param->set_mining_type(mining_type);
357                  MultiBoxLossLayer<Dtype> layer(layer_param);
358                  GradientChecker<Dtype> checker(1e-2, 1e-2, 1701);
359                  checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    