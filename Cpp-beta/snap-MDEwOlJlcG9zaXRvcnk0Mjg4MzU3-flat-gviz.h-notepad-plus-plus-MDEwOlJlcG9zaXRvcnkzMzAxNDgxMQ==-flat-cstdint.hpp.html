
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.171314741035857%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gviz.h</h3>
            <pre><code>1  typedef enum TGVizLayout_ { gvlDot, gvlNeato, gvlTwopi, gvlCirco, gvlSfdp } TGVizLayout;
2  namespace TSnap {
3  template<class PGraph> void DrawGViz(const PGraph& Graph, const TGVizLayout& Layout, const TStr& PltFNm, const TStr& Desc=TStr(), const bool& NodeLabels=false, const TIntStrH& NIdColorH=TIntStrH());
<span onclick='openModal()' class='match'>4  template<class PGraph> void DrawGViz(const PGraph& Graph, const TGVizLayout& Layout, const TStr& PltFNm, const TStr& Desc, const TIntStrH& NodeLabelH);
5  namespace TSnapDetail {
6  void GVizDoLayout(const TStr& GraphInFNm, TStr OutFNm, const TGVizLayout& Layout);
7  TStr GVizGetLayoutStr(const TGVizLayout& Layout);
</span>8  } 
9  template<class PGraph>
10  void DrawGViz(const PGraph& Graph, const TGVizLayout& Layout, const TStr& PltFNm, const TStr& Desc, const bool& NodeLabels, const TIntStrH& NIdColorH) {
11    const TStr Ext = PltFNm.GetFExt();
12    const TStr GraphFNm = PltFNm.GetSubStr(0, PltFNm.Len()-Ext.Len()) + "dot";
13    SaveGViz(Graph, GraphFNm, Desc, NodeLabels, NIdColorH);
14    TSnap::TSnapDetail::GVizDoLayout(GraphFNm, PltFNm, Layout);
15  }
16  template<class PGraph>
17  void DrawGViz(const PGraph& Graph, const TGVizLayout& Layout, const TStr& PltFNm, const TStr& Desc, const TIntStrH& NodeLabelH) {
18    const TStr Ext = PltFNm.GetFExt();
19    const TStr GraphFNm = PltFNm.GetSubStr(0, PltFNm.Len()-Ext.Len()) + "dot";
20    SaveGViz(Graph, GraphFNm, Desc, NodeLabelH);
21    TSnap::TSnapDetail::GVizDoLayout(GraphFNm, PltFNm, Layout);
22  }
23  } 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cstdint.hpp</h3>
            <pre><code>1  #ifndef BOOST_CSTDINT_HPP
2  #define BOOST_CSTDINT_HPP
3  #ifndef __STDC_CONSTANT_MACROS
4  #  define __STDC_CONSTANT_MACROS
5  #endif
6  #include <boost/config.hpp>
7  #if defined(__GNUC__) && (__GNUC__ >= 4)
8  #pragma GCC system_header
9  #endif
10  #if defined(BOOST_HAS_STDINT_H)            \
11    && (!defined(__GLIBC__)                  \
12        || defined(__GLIBC_HAVE_LONG_LONG)   \
13        || (defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 17)))))
14  # ifdef __hpux
15  #   include <inttypes.h>
16  #   ifdef __STDC_32_MODE__
17  #     define BOOST_NO_INT64_T
18  #   endif
19  # elif defined(__FreeBSD__) || defined(__IBMCPP__) || defined(_AIX)
20  #   include <inttypes.h>
21  # else
22  #   include <stdint.h>
23  #   if defined(INTMAX_C) && defined(__CYGWIN__)
24  #     undef INTMAX_C
25  #     undef UINTMAX_C
26  #     define INTMAX_C(c) c##LL
27  #     define UINTMAX_C(c) c##ULL
28  #   endif
29  # endif
30  #if defined(__QNX__) && defined(__EXT_QNX) 
<span onclick='openModal()' class='match'>31  typedef ::intleast8_t int_least8_t;
32  typedef ::intfast8_t int_fast8_t;
33  typedef ::uintleast8_t uint_least8_t;
34  typedef ::uintfast8_t uint_fast8_t;
35  typedef ::intleast16_t int_least16_t;
36  typedef ::intfast16_t int_fast16_t;
37  typedef ::uintleast16_t uint_least16_t;
38  typedef ::uintfast16_t uint_fast16_t;
39  typedef ::intleast32_t int_least32_t;
</span>40  typedef ::intfast32_t int_fast32_t;
41  typedef ::uintleast32_t uint_least32_t;
42  typedef ::uintfast32_t uint_fast32_t;
43  # ifndef BOOST_NO_INT64_T
44  typedef ::intleast64_t int_least64_t;
45  typedef ::intfast64_t int_fast64_t;
46  typedef ::uintleast64_t uint_least64_t;
47  typedef ::uintfast64_t uint_fast64_t;
48  # endif
49  #endif
50  namespace boost
51  {
52    using ::int8_t;
53    using ::int_least8_t;
54    using ::int_fast8_t;
55    using ::uint8_t;
56    using ::uint_least8_t;
57    using ::uint_fast8_t;
58    using ::int16_t;
59    using ::int_least16_t;
60    using ::int_fast16_t;
61    using ::uint16_t;
62    using ::uint_least16_t;
63    using ::uint_fast16_t;
64    using ::int32_t;
65    using ::int_least32_t;
66    using ::int_fast32_t;
67    using ::uint32_t;
68    using ::uint_least32_t;
69    using ::uint_fast32_t;
70  # ifndef BOOST_NO_INT64_T
71    using ::int64_t;
72    using ::int_least64_t;
73    using ::int_fast64_t;
74    using ::uint64_t;
75    using ::uint_least64_t;
76    using ::uint_fast64_t;
77  # endif
78    using ::intmax_t;
79    using ::uintmax_t;
80  } 
81  #elif defined(__FreeBSD__) && (__FreeBSD__ <= 4) || defined(__osf__) || defined(__VMS) || defined(__SOLARIS9__) || defined(__NetBSD__)
82  # include <inttypes.h>
83  namespace boost {
84    using ::int8_t;
85    typedef int8_t int_least8_t;
86    typedef int8_t int_fast8_t;
87    using ::uint8_t;
88    typedef uint8_t uint_least8_t;
89    typedef uint8_t uint_fast8_t;
90    using ::int16_t;
91    typedef int16_t int_least16_t;
92    typedef int16_t int_fast16_t;
93    using ::uint16_t;
94    typedef uint16_t uint_least16_t;
95    typedef uint16_t uint_fast16_t;
96    using ::int32_t;
97    typedef int32_t int_least32_t;
98    typedef int32_t int_fast32_t;
99    using ::uint32_t;
100    typedef uint32_t uint_least32_t;
101    typedef uint32_t uint_fast32_t;
102  # ifndef BOOST_NO_INT64_T
103    using ::int64_t;
104    typedef int64_t int_least64_t;
105    typedef int64_t int_fast64_t;
106    using ::uint64_t;
107    typedef uint64_t uint_least64_t;
108    typedef uint64_t uint_fast64_t;
109    typedef int64_t intmax_t;
110    typedef uint64_t uintmax_t;
111  # else
112    typedef int32_t intmax_t;
113    typedef uint32_t uintmax_t;
114  # endif
115  } 
116  #else  
117  # include <boost/limits.hpp> 
118  # include <limits.h>         
119  namespace boost
120  {
121  # if UCHAR_MAX == 0xff
122       typedef signed char     int8_t;
123       typedef signed char     int_least8_t;
124       typedef signed char     int_fast8_t;
125       typedef unsigned char   uint8_t;
126       typedef unsigned char   uint_least8_t;
127       typedef unsigned char   uint_fast8_t;
128  # else
129  #    error defaults not correct; you must hand modify boost/cstdint.hpp
130  # endif
131  # if USHRT_MAX == 0xffff
132  #  if defined(__crayx1)
133       typedef short           int16_t;
134       typedef short           int_least16_t;
135       typedef int             int_fast16_t;
136       typedef unsigned short  uint16_t;
137       typedef unsigned short  uint_least16_t;
138       typedef unsigned int    uint_fast16_t;
139  #  else
140       typedef short           int16_t;
141       typedef short           int_least16_t;
142       typedef short           int_fast16_t;
143       typedef unsigned short  uint16_t;
144       typedef unsigned short  uint_least16_t;
145       typedef unsigned short  uint_fast16_t;
146  #  endif
147  # elif (USHRT_MAX == 0xffffffff) && defined(__MTA__)
148        typedef __short16           int16_t;
149        typedef __short16           int_least16_t;
150        typedef __short16           int_fast16_t;
151        typedef unsigned __short16  uint16_t;
152        typedef unsigned __short16  uint_least16_t;
153        typedef unsigned __short16  uint_fast16_t;
154  # elif (USHRT_MAX == 0xffffffff) && defined(CRAY)
155       typedef short           int_least16_t;
156       typedef short           int_fast16_t;
157       typedef unsigned short  uint_least16_t;
158       typedef unsigned short  uint_fast16_t;
159  # else
160  #    error defaults not correct; you must hand modify boost/cstdint.hpp
161  # endif
162  # if UINT_MAX == 0xffffffff
163       typedef int             int32_t;
164       typedef int             int_least32_t;
165       typedef int             int_fast32_t;
166       typedef unsigned int    uint32_t;
167       typedef unsigned int    uint_least32_t;
168       typedef unsigned int    uint_fast32_t;
169  # elif (USHRT_MAX == 0xffffffff)
170       typedef short             int32_t;
171       typedef short             int_least32_t;
172       typedef short             int_fast32_t;
173       typedef unsigned short    uint32_t;
174       typedef unsigned short    uint_least32_t;
175       typedef unsigned short    uint_fast32_t;
176  # elif ULONG_MAX == 0xffffffff
177       typedef long            int32_t;
178       typedef long            int_least32_t;
179       typedef long            int_fast32_t;
180       typedef unsigned long   uint32_t;
181       typedef unsigned long   uint_least32_t;
182       typedef unsigned long   uint_fast32_t;
183  # elif (UINT_MAX == 0xffffffffffffffff) && defined(__MTA__)
184        typedef __int32           int32_t;
185        typedef __int32           int_least32_t;
186        typedef __int32           int_fast32_t;
187        typedef unsigned __int32  uint32_t;
188        typedef unsigned __int32  uint_least32_t;
189        typedef unsigned __int32  uint_fast32_t;
190  # else
191  #    error defaults not correct; you must hand modify boost/cstdint.hpp
192  # endif
193  # if defined(BOOST_HAS_LONG_LONG) && \
194     !defined(BOOST_MSVC) && !defined(BOOST_BORLANDC) && \
195     (!defined(__GLIBCPP__) || defined(_GLIBCPP_USE_LONG_LONG)) && \
196     (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))
197  #    if defined(__hpux)
198  #    elif (defined(ULLONG_MAX) && ULLONG_MAX == 18446744073709551615ULL) || (defined(ULONG_LONG_MAX) && ULONG_LONG_MAX == 18446744073709551615ULL) || (defined(ULONGLONG_MAX) && ULONGLONG_MAX == 18446744073709551615ULL)
199  #    else
200  #       error defaults not correct; you must hand modify boost/cstdint.hpp
201  #    endif
202       typedef  ::boost::long_long_type            intmax_t;
203       typedef  ::boost::ulong_long_type   uintmax_t;
204       typedef  ::boost::long_long_type            int64_t;
205       typedef  ::boost::long_long_type            int_least64_t;
206       typedef  ::boost::long_long_type            int_fast64_t;
207       typedef  ::boost::ulong_long_type   uint64_t;
208       typedef  ::boost::ulong_long_type   uint_least64_t;
209       typedef  ::boost::ulong_long_type   uint_fast64_t;
210  # elif ULONG_MAX != 0xffffffff
211  #    if ULONG_MAX == 18446744073709551615 
212       typedef long                 intmax_t;
213       typedef unsigned long        uintmax_t;
214       typedef long                 int64_t;
215       typedef long                 int_least64_t;
216       typedef long                 int_fast64_t;
217       typedef unsigned long        uint64_t;
218       typedef unsigned long        uint_least64_t;
219       typedef unsigned long        uint_fast64_t;
220  #    else
221  #       error defaults not correct; you must hand modify boost/cstdint.hpp
222  #    endif
223  # elif defined(__GNUC__) && defined(BOOST_HAS_LONG_LONG)
224       __extension__ typedef long long            intmax_t;
225       __extension__ typedef unsigned long long   uintmax_t;
226       __extension__ typedef long long            int64_t;
227       __extension__ typedef long long            int_least64_t;
228       __extension__ typedef long long            int_fast64_t;
229       __extension__ typedef unsigned long long   uint64_t;
230       __extension__ typedef unsigned long long   uint_least64_t;
231       __extension__ typedef unsigned long long   uint_fast64_t;
232  # elif defined(BOOST_HAS_MS_INT64)
233       typedef __int64             intmax_t;
234       typedef unsigned __int64    uintmax_t;
235       typedef __int64             int64_t;
236       typedef __int64             int_least64_t;
237       typedef __int64             int_fast64_t;
238       typedef unsigned __int64    uint64_t;
239       typedef unsigned __int64    uint_least64_t;
240       typedef unsigned __int64    uint_fast64_t;
241  # else 
242  #  define BOOST_NO_INT64_T
243       typedef int32_t              intmax_t;
244       typedef uint32_t             uintmax_t;
245  # endif
246  } 
247  #endif 
248  #if defined(BOOST_WINDOWS) && !defined(_WIN32_WCE) && !defined(BOOST_HAS_STDINT_H)
249  #include <stddef.h>
250  #endif
251  #if (defined(BOOST_WINDOWS) && !defined(_WIN32_WCE)) \
252      || (defined(_XOPEN_UNIX) && (_XOPEN_UNIX+0 > 0) && !defined(__UCLIBC__)) \
253      || defined(__CYGWIN__) || defined(__VXWORKS__) \
254      || defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__) \
255      || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || (defined(sun) && !defined(BOOST_HAS_STDINT_H)) || defined(INTPTR_MAX)
256  namespace boost {
257      using ::intptr_t;
258      using ::uintptr_t;
259  }
260  #define BOOST_HAS_INTPTR_T
261  #elif defined(__GNUC__) && defined(__INTPTR_TYPE__) && defined(__UINTPTR_TYPE__)
262  namespace boost {
263      typedef __INTPTR_TYPE__ intptr_t;
264      typedef __UINTPTR_TYPE__ uintptr_t;
265  }
266  #define BOOST_HAS_INTPTR_T
267  #endif
268  #endif 
269  #if !defined(BOOST__STDC_CONSTANT_MACROS_DEFINED) && \
270     (!defined(INT8_C) || !defined(INT16_C) || !defined(INT32_C) || !defined(INT64_C))
271  #undef INT8_C
272  #undef INT16_C
273  #undef INT32_C
274  #undef INT64_C
275  #undef INTMAX_C
276  #undef UINT8_C
277  #undef UINT16_C
278  #undef UINT32_C
279  #undef UINT64_C
280  #undef UINTMAX_C
281  #include <limits.h>
282  # define BOOST__STDC_CONSTANT_MACROS_DEFINED
283  # if defined(BOOST_HAS_MS_INT64)
284  #ifndef INT8_C
285  #  define INT8_C(value)     value##i8
286  #endif
287  #ifndef INT16_C
288  #  define INT16_C(value)    value##i16
289  #endif
290  #ifndef INT32_C
291  #  define INT32_C(value)    value##i32
292  #endif
293  #ifndef INT64_C
294  #  define INT64_C(value)    value##i64
295  #endif
296  #  ifdef BOOST_BORLANDC
297  #   define UINT8_C(value)    static_cast<unsigned char>(value##u)
298  #  else
299  #   define UINT8_C(value)    value##ui8
300  #  endif
301  #ifndef UINT16_C
302  #  define UINT16_C(value)   value##ui16
303  #endif
304  #ifndef UINT32_C
305  #  define UINT32_C(value)   value##ui32
306  #endif
307  #ifndef UINT64_C
308  #  define UINT64_C(value)   value##ui64
309  #endif
310  #ifndef INTMAX_C
311  #  define INTMAX_C(value)   value##i64
312  #  define UINTMAX_C(value)  value##ui64
313  #endif
314  # else
315  #  if (UCHAR_MAX == 0xff) && !defined(INT8_C)
316  #   define INT8_C(value) static_cast<boost::int8_t>(value)
317  #   define UINT8_C(value) static_cast<boost::uint8_t>(value##u)
318  #  endif
319  #  if (USHRT_MAX == 0xffff) && !defined(INT16_C)
320  #   define INT16_C(value) static_cast<boost::int16_t>(value)
321  #   define UINT16_C(value) static_cast<boost::uint16_t>(value##u)
322  #  endif
323  #ifndef INT32_C
324  #  if (UINT_MAX == 0xffffffff)
325  #   define INT32_C(value) value
326  #   define UINT32_C(value) value##u
327  #  elif ULONG_MAX == 0xffffffff
328  #   define INT32_C(value) value##L
329  #   define UINT32_C(value) value##uL
330  #  endif
331  #endif
332  #ifndef INT64_C
333  #  if defined(BOOST_HAS_LONG_LONG) && \
334      (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX) || defined(_ULLONG_MAX) || defined(_LLONG_MAX))
335  #    if defined(__hpux)
336  #       define INT64_C(value) value##LL
337  #       define UINT64_C(value) value##uLL
338  #    elif (defined(ULLONG_MAX) && ULLONG_MAX == 18446744073709551615ULL) ||  \
339          (defined(ULONG_LONG_MAX) && ULONG_LONG_MAX == 18446744073709551615ULL) ||  \
340          (defined(ULONGLONG_MAX) && ULONGLONG_MAX == 18446744073709551615ULL) || \
341          (defined(_ULLONG_MAX) && _ULLONG_MAX == 18446744073709551615ULL) || \
342          (defined(_LLONG_MAX) && _LLONG_MAX == 9223372036854775807LL)
343  #       define INT64_C(value) value##LL
344  #       define UINT64_C(value) value##uLL
345  #    else
346  #       error defaults not correct; you must hand modify boost/cstdint.hpp
347  #    endif
348  #  elif ULONG_MAX != 0xffffffff
349  #    if ULONG_MAX == 18446744073709551615U 
350  #       define INT64_C(value) value##L
351  #       define UINT64_C(value) value##uL
352  #    else
353  #       error defaults not correct; you must hand modify boost/cstdint.hpp
354  #    endif
355  #  elif defined(BOOST_HAS_LONG_LONG)
356  #    if(~0uLL == 18446744073709551615ULL)
357  #       define INT64_C(value) value##LL
358  #       define UINT64_C(value) value##uLL
359  #    else
360  #       error defaults not correct; you must hand modify boost/cstdint.hpp
361  #    endif
362  #  else
363  #    error defaults not correct; you must hand modify boost/cstdint.hpp
364  #  endif
365  #  ifdef BOOST_NO_INT64_T
366  #   define INTMAX_C(value) INT32_C(value)
367  #   define UINTMAX_C(value) UINT32_C(value)
368  #  else
369  #   define INTMAX_C(value) INT64_C(value)
370  #   define UINTMAX_C(value) UINT64_C(value)
371  #  endif
372  #endif
373  # endif 
374  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gviz.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cstdint.hpp</div>
                </div>
                <div class="column column_space"><pre><code>4  template<class PGraph> void DrawGViz(const PGraph& Graph, const TGVizLayout& Layout, const TStr& PltFNm, const TStr& Desc, const TIntStrH& NodeLabelH);
5  namespace TSnapDetail {
6  void GVizDoLayout(const TStr& GraphInFNm, TStr OutFNm, const TGVizLayout& Layout);
7  TStr GVizGetLayoutStr(const TGVizLayout& Layout);
</pre></code></div>
                <div class="column column_space"><pre><code>31  typedef ::intleast8_t int_least8_t;
32  typedef ::intfast8_t int_fast8_t;
33  typedef ::uintleast8_t uint_least8_t;
34  typedef ::uintfast8_t uint_fast8_t;
35  typedef ::intleast16_t int_least16_t;
36  typedef ::intfast16_t int_fast16_t;
37  typedef ::uintleast16_t uint_least16_t;
38  typedef ::uintfast16_t uint_fast16_t;
39  typedef ::intleast32_t int_least32_t;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    