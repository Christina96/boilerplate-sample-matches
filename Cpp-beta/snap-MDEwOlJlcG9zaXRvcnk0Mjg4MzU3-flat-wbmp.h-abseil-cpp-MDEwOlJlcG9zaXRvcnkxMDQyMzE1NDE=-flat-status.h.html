
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.984031936127744%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wbmp.h</h3>
            <pre><code>1  #ifndef wbmp_h
2  #define wbmp_h
3  #include "base.h"
4  #include "gks.h"
5  class TWbmp;
6  typedef TPt<TWbmp> PWbmp;
<span onclick='openModal()' class='match'>7  class TWbmp{
8  private:
9    TCRef CRef;
10  private:
11    TBoolVV PxValVV;
12    static void PutMultiByteInt(const PSOut& SOut, const uint& Val);
13    static uint GetMultiByteInt(const PSIn& SIn);
</span>14  public:
15    TWbmp(): PxValVV(){}
16    TWbmp(const int& Width, const int& Height): PxValVV(){
17      Gen(Width, Height);}
18    static PWbmp New(){
19      return PWbmp(new TWbmp());}
20    static PWbmp New(const int& Width, const int& Height){
21      return PWbmp(new TWbmp(Width, Height));}
22    ~TWbmp(){}
23    TWbmp(TSIn& SIn){Fail;}
24    static PWbmp Load(TSIn& SIn);
25    void Save(TSOut& SOut){Fail;}
26    TWbmp& operator=(const TWbmp&){Fail; return *this;}
27    void Clr(){PxValVV.Gen(GetWidth(), GetHeight());}
28    void Gen(const int& Width, const int& Height){PxValVV.Gen(Width, Height);}
29    int GetWidth() const {return PxValVV.GetXDim();}
30    int GetHeight() const {return PxValVV.GetYDim();}
31    bool PutPxVal(const int& X, const int& Y, const bool& PxVal) const {
32      return PxValVV.At(X, Y)=PxVal;}
33    bool GetPxVal(const int& X, const int& Y) const {
34      return PxValVV.At(X, Y);}
35    void Draw(const PGks& Gks);
36    static PWbmp LoadWbmp(const TStr& FNm){
37      return LoadWbmp(TFIn::New(FNm));}
38    void SaveWbmp(const TStr& FNm) const {
39      SaveWbmp(TFOut::New(FNm));}
40    static PWbmp LoadWbmp(const PSIn& SIn);
41    void SaveWbmp(const PSOut& SOut) const;
42    friend PWbmp;
43  };
44  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-status.h</h3>
            <pre><code>1  #ifndef ABSL_STATUS_STATUS_H_
2  #define ABSL_STATUS_STATUS_H_
3  #include <ostream>
4  #include <string>
5  #include <utility>
6  #include "absl/functional/function_ref.h"
7  #include "absl/status/internal/status_internal.h"
8  #include "absl/strings/cord.h"
9  #include "absl/strings/string_view.h"
10  #include "absl/types/optional.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  enum class StatusCode : int {
14    kOk = 0,
15    kCancelled = 1,
16    kUnknown = 2,
17    kInvalidArgument = 3,
18    kDeadlineExceeded = 4,
19    kNotFound = 5,
20    kAlreadyExists = 6,
21    kPermissionDenied = 7,
22    kResourceExhausted = 8,
23    kFailedPrecondition = 9,
24    kAborted = 10,
25    kOutOfRange = 11,
26    kUnimplemented = 12,
27    kInternal = 13,
28    kUnavailable = 14,
29    kDataLoss = 15,
30    kUnauthenticated = 16,
31    kDoNotUseReservedForFutureExpansionUseDefaultInSwitchInstead_ = 20
32  };
33  std::string StatusCodeToString(StatusCode code);
34  std::ostream& operator<<(std::ostream& os, StatusCode code);
35  enum class StatusToStringMode : int {
36    kWithNoExtraData = 0,
37    kWithPayload = 1 << 0,
38    kWithEverything = ~kWithNoExtraData,
39    kDefault = kWithPayload,
40  };
41  inline constexpr StatusToStringMode operator&(StatusToStringMode lhs,
42                                                StatusToStringMode rhs) {
43    return static_cast<StatusToStringMode>(static_cast<int>(lhs) &
44                                           static_cast<int>(rhs));
45  }
46  inline constexpr StatusToStringMode operator|(StatusToStringMode lhs,
47                                                StatusToStringMode rhs) {
48    return static_cast<StatusToStringMode>(static_cast<int>(lhs) |
49                                           static_cast<int>(rhs));
50  }
51  inline constexpr StatusToStringMode operator^(StatusToStringMode lhs,
52                                                StatusToStringMode rhs) {
53    return static_cast<StatusToStringMode>(static_cast<int>(lhs) ^
54                                           static_cast<int>(rhs));
55  }
56  inline constexpr StatusToStringMode operator~(StatusToStringMode arg) {
57    return static_cast<StatusToStringMode>(~static_cast<int>(arg));
58  }
59  inline StatusToStringMode& operator&=(StatusToStringMode& lhs,
60                                        StatusToStringMode rhs) {
61    lhs = lhs & rhs;
62    return lhs;
63  }
64  inline StatusToStringMode& operator|=(StatusToStringMode& lhs,
65                                        StatusToStringMode rhs) {
66    lhs = lhs | rhs;
67    return lhs;
68  }
69  inline StatusToStringMode& operator^=(StatusToStringMode& lhs,
70                                        StatusToStringMode rhs) {
71    lhs = lhs ^ rhs;
72    return lhs;
73  }
<span onclick='openModal()' class='match'>74  class Status final {
75   public:
76    Status();
77    Status(absl::StatusCode code, absl::string_view msg);
78    Status(const Status&);
79    Status& operator=(const Status& x);
80    Status(Status&&) noexcept;
</span>81    Status& operator=(Status&&);
82    ~Status();
83    void Update(const Status& new_status);
84    void Update(Status&& new_status);
85    ABSL_MUST_USE_RESULT bool ok() const;
86    absl::StatusCode code() const;
87    int raw_code() const;
88    absl::string_view message() const;
89    friend bool operator==(const Status&, const Status&);
90    friend bool operator!=(const Status&, const Status&);
91    std::string ToString(
92        StatusToStringMode mode = StatusToStringMode::kDefault) const;
93    void IgnoreError() const;
94    friend void swap(Status& a, Status& b);
95    absl::optional<absl::Cord> GetPayload(absl::string_view type_url) const;
96    void SetPayload(absl::string_view type_url, absl::Cord payload);
97    bool ErasePayload(absl::string_view type_url);
98    void ForEachPayload(
99        absl::FunctionRef<void(absl::string_view, const absl::Cord&)> visitor)
100        const;
101   private:
102    friend Status CancelledError();
103    explicit Status(absl::StatusCode code);
104    static void UnrefNonInlined(uintptr_t rep);
105    static void Ref(uintptr_t rep);
106    static void Unref(uintptr_t rep);
107    void PrepareToModify();
108    const status_internal::Payloads* GetPayloads() const;
109    status_internal::Payloads* GetPayloads();
110    static bool EqualsSlow(const absl::Status& a, const absl::Status& b);
111    static constexpr const char kMovedFromString[] =
112        "Status accessed after move.";
113    static const std::string* EmptyString();
114    static const std::string* MovedFromString();
115    static bool IsInlined(uintptr_t rep);
116    static bool IsMovedFrom(uintptr_t rep);
117    static uintptr_t MovedFromRep();
118    static uintptr_t CodeToInlinedRep(absl::StatusCode code);
119    static absl::StatusCode InlinedRepToCode(uintptr_t rep);
120    static uintptr_t PointerToRep(status_internal::StatusRep* r);
121    static status_internal::StatusRep* RepToPointer(uintptr_t r);
122    std::string ToStringSlow(StatusToStringMode mode) const;
123    uintptr_t rep_;
124  };
125  Status OkStatus();
126  std::ostream& operator<<(std::ostream& os, const Status& x);
127  ABSL_MUST_USE_RESULT bool IsAborted(const Status& status);
128  ABSL_MUST_USE_RESULT bool IsAlreadyExists(const Status& status);
129  ABSL_MUST_USE_RESULT bool IsCancelled(const Status& status);
130  ABSL_MUST_USE_RESULT bool IsDataLoss(const Status& status);
131  ABSL_MUST_USE_RESULT bool IsDeadlineExceeded(const Status& status);
132  ABSL_MUST_USE_RESULT bool IsFailedPrecondition(const Status& status);
133  ABSL_MUST_USE_RESULT bool IsInternal(const Status& status);
134  ABSL_MUST_USE_RESULT bool IsInvalidArgument(const Status& status);
135  ABSL_MUST_USE_RESULT bool IsNotFound(const Status& status);
136  ABSL_MUST_USE_RESULT bool IsOutOfRange(const Status& status);
137  ABSL_MUST_USE_RESULT bool IsPermissionDenied(const Status& status);
138  ABSL_MUST_USE_RESULT bool IsResourceExhausted(const Status& status);
139  ABSL_MUST_USE_RESULT bool IsUnauthenticated(const Status& status);
140  ABSL_MUST_USE_RESULT bool IsUnavailable(const Status& status);
141  ABSL_MUST_USE_RESULT bool IsUnimplemented(const Status& status);
142  ABSL_MUST_USE_RESULT bool IsUnknown(const Status& status);
143  Status AbortedError(absl::string_view message);
144  Status AlreadyExistsError(absl::string_view message);
145  Status CancelledError(absl::string_view message);
146  Status DataLossError(absl::string_view message);
147  Status DeadlineExceededError(absl::string_view message);
148  Status FailedPreconditionError(absl::string_view message);
149  Status InternalError(absl::string_view message);
150  Status InvalidArgumentError(absl::string_view message);
151  Status NotFoundError(absl::string_view message);
152  Status OutOfRangeError(absl::string_view message);
153  Status PermissionDeniedError(absl::string_view message);
154  Status ResourceExhaustedError(absl::string_view message);
155  Status UnauthenticatedError(absl::string_view message);
156  Status UnavailableError(absl::string_view message);
157  Status UnimplementedError(absl::string_view message);
158  Status UnknownError(absl::string_view message);
159  absl::StatusCode ErrnoToStatusCode(int error_number);
160  Status ErrnoToStatus(int error_number, absl::string_view message);
161  inline Status::Status() : rep_(CodeToInlinedRep(absl::StatusCode::kOk)) {}
162  inline Status::Status(absl::StatusCode code) : rep_(CodeToInlinedRep(code)) {}
163  inline Status::Status(const Status& x) : rep_(x.rep_) { Ref(rep_); }
164  inline Status& Status::operator=(const Status& x) {
165    uintptr_t old_rep = rep_;
166    if (x.rep_ != old_rep) {
167      Ref(x.rep_);
168      rep_ = x.rep_;
169      Unref(old_rep);
170    }
171    return *this;
172  }
173  inline Status::Status(Status&& x) noexcept : rep_(x.rep_) {
174    x.rep_ = MovedFromRep();
175  }
176  inline Status& Status::operator=(Status&& x) {
177    uintptr_t old_rep = rep_;
178    if (x.rep_ != old_rep) {
179      rep_ = x.rep_;
180      x.rep_ = MovedFromRep();
181      Unref(old_rep);
182    }
183    return *this;
184  }
185  inline void Status::Update(const Status& new_status) {
186    if (ok()) {
187      *this = new_status;
188    }
189  }
190  inline void Status::Update(Status&& new_status) {
191    if (ok()) {
192      *this = std::move(new_status);
193    }
194  }
195  inline Status::~Status() { Unref(rep_); }
196  inline bool Status::ok() const {
197    return rep_ == CodeToInlinedRep(absl::StatusCode::kOk);
198  }
199  inline absl::string_view Status::message() const {
200    return !IsInlined(rep_)
201               ? RepToPointer(rep_)->message
202               : (IsMovedFrom(rep_) ? absl::string_view(kMovedFromString)
203                                    : absl::string_view());
204  }
205  inline bool operator==(const Status& lhs, const Status& rhs) {
206    return lhs.rep_ == rhs.rep_ || Status::EqualsSlow(lhs, rhs);
207  }
208  inline bool operator!=(const Status& lhs, const Status& rhs) {
209    return !(lhs == rhs);
210  }
211  inline std::string Status::ToString(StatusToStringMode mode) const {
212    return ok() ? "OK" : ToStringSlow(mode);
213  }
214  inline void Status::IgnoreError() const {
215  }
216  inline void swap(absl::Status& a, absl::Status& b) {
217    using std::swap;
218    swap(a.rep_, b.rep_);
219  }
220  inline const status_internal::Payloads* Status::GetPayloads() const {
221    return IsInlined(rep_) ? nullptr : RepToPointer(rep_)->payloads.get();
222  }
223  inline status_internal::Payloads* Status::GetPayloads() {
224    return IsInlined(rep_) ? nullptr : RepToPointer(rep_)->payloads.get();
225  }
226  inline bool Status::IsInlined(uintptr_t rep) { return (rep & 1) == 0; }
227  inline bool Status::IsMovedFrom(uintptr_t rep) {
228    return IsInlined(rep) && (rep & 2) != 0;
229  }
230  inline uintptr_t Status::MovedFromRep() {
231    return CodeToInlinedRep(absl::StatusCode::kInternal) | 2;
232  }
233  inline uintptr_t Status::CodeToInlinedRep(absl::StatusCode code) {
234    return static_cast<uintptr_t>(code) << 2;
235  }
236  inline absl::StatusCode Status::InlinedRepToCode(uintptr_t rep) {
237    assert(IsInlined(rep));
238    return static_cast<absl::StatusCode>(rep >> 2);
239  }
240  inline status_internal::StatusRep* Status::RepToPointer(uintptr_t rep) {
241    assert(!IsInlined(rep));
242    return reinterpret_cast<status_internal::StatusRep*>(rep - 1);
243  }
244  inline uintptr_t Status::PointerToRep(status_internal::StatusRep* rep) {
245    return reinterpret_cast<uintptr_t>(rep) + 1;
246  }
247  inline void Status::Ref(uintptr_t rep) {
248    if (!IsInlined(rep)) {
249      RepToPointer(rep)->ref.fetch_add(1, std::memory_order_relaxed);
250    }
251  }
252  inline void Status::Unref(uintptr_t rep) {
253    if (!IsInlined(rep)) {
254      UnrefNonInlined(rep);
255    }
256  }
257  inline Status OkStatus() { return Status(); }
258  inline Status CancelledError() { return Status(absl::StatusCode::kCancelled); }
259  const char* StatusMessageAsCStr(
260      const Status& status ABSL_ATTRIBUTE_LIFETIME_BOUND);
261  ABSL_NAMESPACE_END
262  }  
263  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wbmp.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-status.h</div>
                </div>
                <div class="column column_space"><pre><code>7  class TWbmp{
8  private:
9    TCRef CRef;
10  private:
11    TBoolVV PxValVV;
12    static void PutMultiByteInt(const PSOut& SOut, const uint& Val);
13    static uint GetMultiByteInt(const PSIn& SIn);
</pre></code></div>
                <div class="column column_space"><pre><code>74  class Status final {
75   public:
76    Status();
77    Status(absl::StatusCode code, absl::string_view msg);
78    Status(const Status&);
79    Status& operator=(const Status& x);
80    Status(Status&&) noexcept;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    