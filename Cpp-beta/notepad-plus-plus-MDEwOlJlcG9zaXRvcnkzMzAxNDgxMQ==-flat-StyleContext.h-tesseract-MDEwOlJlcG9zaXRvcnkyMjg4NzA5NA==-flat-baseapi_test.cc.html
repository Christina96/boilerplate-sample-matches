
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5412960609911055%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-StyleContext.h</h3>
            <pre><code>1  #ifndef STYLECONTEXT_H
2  #define STYLECONTEXT_H
3  namespace Lexilla {
4  class StyleContext {
5  	LexAccessor &styler;
6  	Scintilla::IDocument * const multiByteAccess;
7  	const Sci_PositionU lengthDocument;
8  	const Sci_PositionU endPos;
9  	const Sci_Position lineDocEnd;
10  	Sci_PositionU posRelative = 0;
11  	Sci_PositionU currentPosLastRelative;
12  	Sci_Position offsetRelative = 0;
13  	void GetNextChar() {
14  		if (multiByteAccess) {
15  			chNext = multiByteAccess->GetCharacterAndWidth(currentPos+width, &widthNext);
16  		} else {
17  			const unsigned char charNext = styler.SafeGetCharAt(currentPos + width, 0);
18  			chNext = charNext;
19  		}
20  		const Sci_Position currentPosSigned = currentPos;
21  		if (currentLine < lineDocEnd)
22  			atLineEnd = currentPosSigned >= (lineStartNext-1);
23  		else 
24  			atLineEnd = currentPosSigned >= lineStartNext;
25  	}
26  public:
27  	Sci_PositionU currentPos;
28  	Sci_Position currentLine;
29  	Sci_Position lineEnd;
30  	Sci_Position lineStartNext;
31  	bool atLineStart;
32  	bool atLineEnd = false;
33  	int state;
34  	int chPrev = 0;
35  	int ch = 0;
36  	Sci_Position width = 0;
37  	int chNext = 0;
38  	Sci_Position widthNext = 1;
39  	StyleContext(Sci_PositionU startPos, Sci_PositionU length,
40                          int initStyle, LexAccessor &styler_, char chMask = '\377');
41  	StyleContext(const StyleContext &) = delete;
42  	StyleContext &operator=(const StyleContext &) = delete;
43  	void Complete() {
44  		styler.ColourTo(currentPos - ((currentPos > lengthDocument) ? 2 : 1), state);
45  		styler.Flush();
46  	}
47  	bool More() const noexcept {
48  		return currentPos < endPos;
49  	}
50  	void Forward() {
51  		if (currentPos < endPos) {
52  			atLineStart = atLineEnd;
53  			if (atLineStart) {
54  				currentLine++;
55  				lineEnd = styler.LineEnd(currentLine);
56  				lineStartNext = styler.LineStart(currentLine+1);
57  			}
58  			chPrev = ch;
59  			currentPos += width;
60  			ch = chNext;
61  			width = widthNext;
62  			GetNextChar();
63  		} else {
64  			atLineStart = false;
65  			chPrev = ' ';
66  			ch = ' ';
67  			chNext = ' ';
68  			atLineEnd = true;
69  		}
70  	}
71  	void Forward(Sci_Position nb) {
<span onclick='openModal()' class='match'>72  		for (Sci_Position i = 0; i < nb; i++) {
73  			Forward();
74  		}
75  	}
76  	void ForwardBytes(Sci_Position nb) {
77  		const Sci_PositionU forwardPos = currentPos + nb;
</span>78  		while (forwardPos > currentPos) {
79  			const Sci_PositionU currentPosStart = currentPos;
80  			Forward();
81  			if (currentPos == currentPosStart) {
82  				return;
83  			}
84  		}
85  	}
86  	void ChangeState(int state_) noexcept {
87  		state = state_;
88  	}
89  	void SetState(int state_) {
90  		styler.ColourTo(currentPos - ((currentPos > lengthDocument) ? 2 : 1), state);
91  		state = state_;
92  	}
93  	void ForwardSetState(int state_) {
94  		Forward();
95  		styler.ColourTo(currentPos - ((currentPos > lengthDocument) ? 2 : 1), state);
96  		state = state_;
97  	}
98  	Sci_Position LengthCurrent() const noexcept {
99  		return currentPos - styler.GetStartSegment();
100  	}
101  	int GetRelative(Sci_Position n, char chDefault='\0') {
102  		const unsigned char chRelative = styler.SafeGetCharAt(currentPos + n, chDefault);
103  		return chRelative;
104  	}
105  	int GetRelativeCharacter(Sci_Position n) {
106  		if (n == 0)
107  			return ch;
108  		if (multiByteAccess) {
109  			if ((currentPosLastRelative != currentPos) ||
110  				((n > 0) && ((offsetRelative < 0) || (n < offsetRelative))) ||
111  				((n < 0) && ((offsetRelative > 0) || (n > offsetRelative)))) {
112  				posRelative = currentPos;
113  				offsetRelative = 0;
114  			}
115  			const Sci_Position diffRelative = n - offsetRelative;
116  			const Sci_Position posNew = multiByteAccess->GetRelativePosition(posRelative, diffRelative);
117  			const int chReturn = multiByteAccess->GetCharacterAndWidth(posNew, nullptr);
118  			posRelative = posNew;
119  			currentPosLastRelative = currentPos;
120  			offsetRelative = n;
121  			return chReturn;
122  		} else {
123  			const unsigned char chRelative = styler.SafeGetCharAt(currentPos + n, 0);
124  			return chRelative;
125  		}
126  	}
127  	bool MatchLineEnd() const noexcept {
128  		const Sci_Position currentPosSigned = currentPos;
129  		return currentPosSigned == lineEnd;
130  	}
131  	bool Match(char ch0) const noexcept {
132  		const unsigned char uch0 = ch0;
133  		return ch == uch0;
134  	}
135  	bool Match(char ch0, char ch1) const noexcept {
136  		const unsigned char uch0 = ch0;
137  		const unsigned char uch1 = ch1;
138  		return (ch == uch0) && (chNext == uch1);
139  	}
140  	bool Match(const char *s) {
141  		const unsigned char su = *s;
142  		if (ch != su)
143  			return false;
144  		s++;
145  		if (!*s)
146  			return true;
147  		const unsigned char sNext = *s;
148  		if (chNext != sNext)
149  			return false;
150  		s++;
151  		for (int n=2; *s; n++) {
152  			if (*s != styler.SafeGetCharAt(currentPos+n, 0))
153  				return false;
154  			s++;
155  		}
156  		return true;
157  	}
158  	bool MatchIgnoreCase(const char *s);
159  	bool MatchIgnoreCase2(const char *s);
160  	void GetCurrent(char *s, Sci_PositionU len);
161  	void GetCurrentLowered(char *s, Sci_PositionU len);
162  	enum class Transform { none, lower };
163  	void GetCurrentString(std::string &string, Transform transform);
164  };
165  }
166  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baseapi_test.cc</h3>
            <pre><code>1  #include "include_gunit.h"
2  #include "cycletimer.h" 
3  #include "log.h"        
4  #include "ocrblock.h"   
5  #include "pageres.h"
6  #include <tesseract/baseapi.h>
7  #include <allheaders.h>
8  #include "gmock/gmock-matchers.h"
9  #include <memory>
10  #include <regex>
11  #include <string>
12  #include <vector>
13  namespace tesseract {
14  using ::testing::ContainsRegex;
15  using ::testing::HasSubstr;
16  static const char *langs[] = {"eng", "vie", "hin", "ara", nullptr};
17  static const char *image_files[] = {"HelloGoogle.tif", "viet.tif", "raaj.tif", "arabic.tif",
18                                      nullptr};
19  static const char *gt_text[] = {"Hello Google", "\x74\x69\xe1\xba\xbf\x6e\x67",
20                                  "\xe0\xa4\xb0\xe0\xa4\xbe\xe0\xa4\x9c",
21                                  "\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a", nullptr};
22  class FriendlyTessBaseAPI : public tesseract::TessBaseAPI {
23    FRIEND_TEST(TesseractTest, LSTMGeometryTest);
24  };
25  std::string GetCleanedTextResult(tesseract::TessBaseAPI *tess, Image pix) {
26    tess->SetImage(pix);
27    char *result = tess->GetUTF8Text();
28    std::string ocr_result = result;
29    delete[] result;
30    trim(ocr_result);
31    return ocr_result;
32  }
33  class TesseractTest : public testing::Test {
34  protected:
35    static std::string TestDataNameToPath(const std::string &name) {
36      return file::JoinPath(TESTING_DIR, name);
37    }
38    static std::string TessdataPath() {
39      return TESSDATA_DIR;
40    }
41  };
42  TEST_F(TesseractTest, StaticTessBaseAPI) {
43    static tesseract::TessBaseAPI api;
44    api.End();
45  }
46  TEST_F(TesseractTest, BasicTesseractTest) {
47    tesseract::TessBaseAPI api;
48    std::string truth_text;
49    std::string ocr_text;
50    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) != -1) {
51      Image src_pix = pixRead(TestDataNameToPath("phototest.tif").c_str());
52      CHECK(src_pix);
53      ocr_text = GetCleanedTextResult(&api, src_pix);
54      CHECK_OK(
55          file::GetContents(TestDataNameToPath("phototest.gold.txt"), &truth_text, file::Defaults()));
56      trim(truth_text);
57      EXPECT_STREQ(truth_text.c_str(), ocr_text.c_str());
58      src_pix.destroy();
59    } else {
60      GTEST_SKIP();
61    }
62  }
63  TEST_F(TesseractTest, IteratesParagraphsEvenIfNotDetected) {
64    tesseract::TessBaseAPI api;
65    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) != -1) {
66      api.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);
67      api.SetVariable("paragraph_debug_level", "3");
68  #if 0 
69      Pix* src_pix = pixRead(TestDataNameToPath("b622.png").c_str());
70      CHECK(src_pix);
71      api.SetImage(src_pix);
72      Boxa* para_boxes =
73          api.GetComponentImages(tesseract::RIL_PARA, true, nullptr, nullptr);
74      EXPECT_TRUE(para_boxes != nullptr);
75      Boxa* block_boxes =
76          api.GetComponentImages(tesseract::RIL_BLOCK, true, nullptr, nullptr);
77      EXPECT_TRUE(block_boxes != nullptr);
78      EXPECT_GE(boxaGetCount(para_boxes), boxaGetCount(block_boxes));
79      boxaDestroy(&block_boxes);
80      boxaDestroy(&para_boxes);
81      src_pix.destroy();
82  #endif
83    } else {
84      GTEST_SKIP();
85    }
86  }
87  TEST_F(TesseractTest, HOCRWorksWithoutSetInputName) {
88    tesseract::TessBaseAPI api;
89    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) == -1) {
90      GTEST_SKIP();
91      return;
92    }
93    Image src_pix = pixRead(TestDataNameToPath("HelloGoogle.tif").c_str());
94    CHECK(src_pix);
95    api.SetImage(src_pix);
96    char *result = api.GetHOCRText(0);
97    EXPECT_TRUE(result != nullptr);
98    EXPECT_THAT(result, HasSubstr("Hello"));
99    EXPECT_THAT(result, HasSubstr("<div class='ocr_page'"));
100    delete[] result;
101    src_pix.destroy();
102  }
103  TEST_F(TesseractTest, HOCRContainsBaseline) {
104    tesseract::TessBaseAPI api;
105    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) == -1) {
106      GTEST_SKIP();
107      return;
108    }
109    Image src_pix = pixRead(TestDataNameToPath("HelloGoogle.tif").c_str());
110    CHECK(src_pix);
111    api.SetInputName("HelloGoogle.tif");
112    api.SetImage(src_pix);
113    char *result = api.GetHOCRText(0);
114    EXPECT_TRUE(result != nullptr);
115    EXPECT_THAT(result, HasSubstr("Hello"));
116    EXPECT_TRUE(std::regex_search(
117        result, std::regex{"<span class='ocr_line'[^>]* baseline [-.0-9]+ [-.0-9]+"}));
118    delete[] result;
119    src_pix.destroy();
120  }
121  TEST_F(TesseractTest, AdaptToWordStrTest) {
122  #ifdef DISABLED_LEGACY_ENGINE
123    GTEST_SKIP();
124  #else
125    static const char *kTrainingPages[] = {"136.tif", "256.tif", "410.tif", "432.tif", "540.tif",
126                                           "692.tif", "779.tif", "793.tif", "808.tif", "815.tif",
127                                           "12.tif",  "12.tif",  nullptr};
128    static const char *kTrainingText[] = {"1 3 6", "2 5 6", "4 1 0", "4 3 2", "5 4 0",
129                                          "6 9 2", "7 7 9", "7 9 3", "8 0 8", "8 1 5",
130                                          "1 2",   "1 2",   nullptr};
131    static const char *kTestPages[] = {"324.tif", "433.tif", "12.tif", nullptr};
132    static const char *kTestText[] = {"324", "433", "12", nullptr};
133    tesseract::TessBaseAPI api;
134    std::string truth_text;
135    std::string ocr_text;
136    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY) == -1) {
137      GTEST_SKIP();
138      return;
139    }
140    api.SetVariable("matcher_sufficient_examples_for_prototyping", "1");
141    api.SetVariable("classify_class_pruner_threshold", "220");
142    for (int i = 0; kTrainingPages[i] != nullptr; ++i) {
143      std::string image_file = TestDataNameToPath(kTrainingPages[i]);
144      Image src_pix = pixRead(image_file.c_str());
145      CHECK(src_pix);
146      api.SetImage(src_pix);
147      EXPECT_TRUE(api.AdaptToWordStr(tesseract::PSM_SINGLE_WORD, kTrainingText[i]))
148          << "Failed to adapt to text \"" << kTrainingText[i] << "\" on image " << image_file;
149      src_pix.destroy();
150    }
151    api.SetVariable("tess_bn_matching", "1");
152    api.SetPageSegMode(tesseract::PSM_SINGLE_WORD);
153    for (int i = 0; kTestPages[i] != nullptr; ++i) {
154      Image src_pix = pixRead(TestDataNameToPath(kTestPages[i]).c_str());
155      CHECK(src_pix);
156      ocr_text = GetCleanedTextResult(&api, src_pix);
157      trim(truth_text);
158      EXPECT_STREQ(kTestText[i], ocr_text.c_str());
159      src_pix.destroy();
160    }
161  #endif
162  }
163  TEST_F(TesseractTest, BasicLSTMTest) {
164    tesseract::TessBaseAPI api;
165    std::string truth_text;
166    std::string ocr_text;
167    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_LSTM_ONLY) == -1) {
168      GTEST_SKIP();
169      return;
170    }
171    Image src_pix = pixRead(TestDataNameToPath("phototest_2.tif").c_str());
172    CHECK(src_pix);
173    ocr_text = GetCleanedTextResult(&api, src_pix);
174    CHECK_OK(
175        file::GetContents(TestDataNameToPath("phototest.gold.txt"), &truth_text, file::Defaults()));
176    trim(truth_text);
177    EXPECT_STREQ(truth_text.c_str(), ocr_text.c_str());
178    src_pix.destroy();
179  }
180  TEST_F(TesseractTest, LSTMGeometryTest) {
181    Image src_pix = pixRead(TestDataNameToPath("deslant.tif").c_str());
182    FriendlyTessBaseAPI api;
183    if (api.Init(TessdataPath().c_str(), "eng", tesseract::OEM_LSTM_ONLY) == -1) {
184      GTEST_SKIP();
185      return;
186    }
187    api.SetImage(src_pix);
188    ASSERT_EQ(api.Recognize(nullptr), 0);
189    const PAGE_RES *page_res = api.GetPageRes();
190    PAGE_RES_IT page_res_it(const_cast<PAGE_RES *>(page_res));
191    page_res_it.restart_page();
192    BLOCK *block = page_res_it.block()->block;
193    CHECK(block);
194    for (page_res_it.restart_page(); page_res_it.word() != nullptr; page_res_it.forward()) {
195      WERD_RES *word = page_res_it.word();
196      CHECK(word);
197      CHECK(word->best_choice);
198      CHECK_GT(word->best_choice->length(), 0);
199      CHECK(word->word);
200      CHECK(word->box_word);
201      TBOX tess_blob_box;
202      tess_blob_box = word->word->bounding_box();
203      tess_blob_box.rotate(block->re_rotation());
204      for (int i = 0; i < word->box_word->length(); ++i) {
205        TBOX lstm_blob_box = word->box_word->BlobBox(i);
206        EXPECT_LT(tess_blob_box.left() - lstm_blob_box.left(), 5);
207        EXPECT_LT(lstm_blob_box.right() - tess_blob_box.right(), 5);
208        EXPECT_LT(tess_blob_box.bottom() - lstm_blob_box.bottom(), 5);
209        EXPECT_LT(lstm_blob_box.top() - tess_blob_box.top(), 5);
210      }
211    }
212    src_pix.destroy();
213  }
214  TEST_F(TesseractTest, InitConfigOnlyTest) {
215    const char *langs[] = {"eng", "chi_tra", "jpn", "vie"};
216    std::unique_ptr<tesseract::TessBaseAPI> api;
217    CycleTimer timer;
218    for (auto &lang : langs) {
219      api = std::make_unique<tesseract::TessBaseAPI>();
220      timer.Restart();
221      EXPECT_EQ(0, api->Init(TessdataPath().c_str(), lang, tesseract::OEM_TESSERACT_ONLY));
222      timer.Stop();
223      LOG(INFO) << "Lang " << lang << " took " << timer.GetInMs() << "ms in regular init";
224    }
225    std::vector<std::string> vars_vec, vars_values;
226    vars_vec.emplace_back("tessedit_init_config_only");
227    vars_values.emplace_back("1");
228    LOG(INFO) << "Switching to config only initialization:";
229    for (auto &lang : langs) {
230      api = std::make_unique<tesseract::TessBaseAPI>();
231      timer.Restart();
232      EXPECT_EQ(0, api->Init(TessdataPath().c_str(), lang, tesseract::OEM_TESSERACT_ONLY, nullptr, 0,
233                             &vars_vec, &vars_values, false));
234      timer.Stop();
235      LOG(INFO) << "Lang " << lang << " took " << timer.GetInMs() << "ms in config-only init";
236    }
237  }
238  TEST(TesseractInstanceTest, TestMultipleTessInstances) {
239    int num_langs = 0;
240    while (langs[num_langs] != nullptr) {
241      ++num_langs;
242    }
243    const std::string kTessdataPath = TESSDATA_DIR;
244    std::vector<Image > pix(num_langs);
245    for (int i = 0; i < num_langs; ++i) {
246      std::string tracestring = "Single instance test with lang = ";
247      tracestring += langs[i];
248      SCOPED_TRACE(tracestring);
249      std::string path = file::JoinPath(TESTING_DIR, image_files[i]);
250      pix[i] = pixRead(path.c_str());
251      QCHECK(pix[i] != nullptr) << "Could not read " << path;
252      tesseract::TessBaseAPI tess;
253      EXPECT_EQ(0, tess.Init(kTessdataPath.c_str(), langs[i]));
254      std::string ocr_result = GetCleanedTextResult(&tess, pix[i]);
255      EXPECT_STREQ(gt_text[i], ocr_result.c_str());
256    }
257    std::string ocr_result[2];
258    for (int i = 0; i < num_langs; ++i) {
259      for (int j = i + 1; j < num_langs; ++j) {
260        tesseract::TessBaseAPI tess1, tess2;
261        tess1.Init(kTessdataPath.c_str(), langs[i]);
262        tess2.Init(kTessdataPath.c_str(), langs[j]);
263        ocr_result[0] = GetCleanedTextResult(&tess1, pix[i]);
264        ocr_result[1] = GetCleanedTextResult(&tess2, pix[j]);
265        EXPECT_FALSE(strcmp(gt_text[i], ocr_result[0].c_str()) ||
266                     strcmp(gt_text[j], ocr_result[1].c_str()))
267            << "OCR failed on language pair " << langs[i] << "-" << langs[j];
268      }
269    }
<span onclick='openModal()' class='match'>270    for (int i = 0; i < num_langs; ++i) {
271      pix[i].destroy();
272    }
273  }
274  TEST(TesseractInstanceTest, TestMultipleTessInstanceVariables) {
</span>275    std::string illegal_name = "an_illegal_name";
276    std::string langs[2] = {"eng", "hin"};
277    std::string int_param_name = "tessedit_pageseg_mode";
278    int int_param[2] = {1, 2};
279    std::string int_param_str[2] = {"1", "2"};
280    std::string bool_param_name = "tessedit_ambigs_training";
281    bool bool_param[2] = {false, true};
282    std::string bool_param_str[2] = {"F", "T"};
283    std::string str_param_name = "tessedit_char_blacklist";
284    std::string str_param[2] = {"abc", "def"};
285    std::string double_param_name = "segment_penalty_dict_frequent_word";
286    std::string double_param_str[2] = {"0.01", "2"};
287    double double_param[2] = {0.01, 2};
288    const std::string kTessdataPath = TESSDATA_DIR;
289    tesseract::TessBaseAPI tess1, tess2;
290    for (int i = 0; i < 2; ++i) {
291      tesseract::TessBaseAPI *api = (i == 0) ? &tess1 : &tess2;
292      api->Init(kTessdataPath.c_str(), langs[i].c_str());
293      api->SetVariable(illegal_name.c_str(), "none");
294      api->SetVariable(int_param_name.c_str(), int_param_str[i].c_str());
295      api->SetVariable(bool_param_name.c_str(), bool_param_str[i].c_str());
296      api->SetVariable(str_param_name.c_str(), str_param[i].c_str());
297      api->SetVariable(double_param_name.c_str(), double_param_str[i].c_str());
298    }
299    for (int i = 0; i < 2; ++i) {
300      tesseract::TessBaseAPI *api = (i == 0) ? &tess1 : &tess2;
301      EXPECT_FALSE(api->GetStringVariable(illegal_name.c_str()));
302      int intvar;
303      EXPECT_TRUE(api->GetIntVariable(int_param_name.c_str(), &intvar));
304      EXPECT_EQ(int_param[i], intvar);
305      bool boolvar;
306      EXPECT_TRUE(api->GetBoolVariable(bool_param_name.c_str(), &boolvar));
307      EXPECT_EQ(bool_param[i], boolvar);
308      EXPECT_STREQ(str_param[i].c_str(), api->GetStringVariable(str_param_name.c_str()));
309      double doublevar;
310      EXPECT_TRUE(api->GetDoubleVariable(double_param_name.c_str(), &doublevar));
311      EXPECT_EQ(double_param[i], doublevar);
312    }
313  }
314  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-StyleContext.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-baseapi_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>72  		for (Sci_Position i = 0; i < nb; i++) {
73  			Forward();
74  		}
75  	}
76  	void ForwardBytes(Sci_Position nb) {
77  		const Sci_PositionU forwardPos = currentPos + nb;
</pre></code></div>
                <div class="column column_space"><pre><code>270    for (int i = 0; i < num_langs; ++i) {
271      pix[i].destroy();
272    }
273  }
274  TEST(TesseractInstanceTest, TestMultipleTessInstanceVariables) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    