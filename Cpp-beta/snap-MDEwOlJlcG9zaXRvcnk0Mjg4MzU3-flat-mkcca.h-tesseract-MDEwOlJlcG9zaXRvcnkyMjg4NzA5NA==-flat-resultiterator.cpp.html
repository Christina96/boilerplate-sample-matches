
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.7905102954341987%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mkcca.h</h3>
            <pre><code>1  #ifndef MKCCA_H
2  #define MKCCA_H
3  #include "mine.h"
4  class TMKCCASemSpace: TSemSpace {
5  private:
6      static bool IsReg;
7      static bool MkReg(){return TSemSpace::Reg(TTypeNm<TMKCCASemSpace>(), &Load);}
8  private:
9      static void ConjugGrad(const TMatrix& Matrix, const TFltV& b, TFltV& x, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TFltV& CGpom1, TFltV& CGr, TFltV& CGp, TFltV& CGa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z,
10          const int& CGMxIter = 20, const double& RelErr = TFlt::EpsHalf,
11          const TFltV& x0 = TFltV());
12  	static void ConjugGrad2(const TMatrix& Matrix, const TFltV& b, TFltV& x, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TFltV& CGpom1, TFltV& CGr, TFltV& CGp, TFltV& CGa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z,
13          const int& CGMxIter = 20, const double& RelErr = TFlt::EpsHalf,
14          const TFltV& x0 = TFltV());
15      static void CalcKCCA(const TVec<TBowMatrix>& BowMatrixV, const int& Dims, 
16          const double& Kapa, const int& CGMxIter, const int& HorstMxIter, 
17          TVec<TVec<TFltV> >& AlphaVV);
18  	static void CalcKCCA2(const TVec<TBowMatrix>& BowMatrixV, const int& Dims, 
19          const double& Kapa, const int& CGMxIter, const int& HorstMxIter, 
20          TVec<TVec<TFltV> >& AlphaVV);
21  	static void CenterMultiply3(const TMatrix& Matrix, const TFltV& x,TFltV& y, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z);
22  	static void CenterMultiply2(const TMatrix& Matrix, const TFltV& x,TFltV& y, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z);
23  	static void CenterMultiply(const TMatrix& Matrix, const TFltV& x,TFltV& y, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones, const int& LangN, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1);
24  private:
25  public:
26  	TMKCCASemSpace();
27      static PSemSpace New() {
28          return new TMKCCASemSpace(); }
29      TMKCCASemSpace(TSIn &SIn): TSemSpace(SIn) { }
30      static PSemSpace Load(TSIn &SIn) { return new TMKCCASemSpace(SIn); }
31      void Save(TSOut &SOut) const { }
32      PBowDocBs Project(PBowDocBs BowDocBs, 
33          PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV, 
34          const int& Dim, const bool& Normalize) { return TBowDocBs::New(); }
35      PBowSpV ProjectSpV(PBowSpV SpV, const int& Dim, 
<span onclick='openModal()' class='match'>36          const bool& Normalize) { return TBowSpV::New(); }
37      void ProjectSpV(PBowSpV SpV, const int& Dim, 
38          const bool& Normalize, TIntFltPrV& ProjSpV) { }
39      void GetBasisV(const int& VecN, TFltV& VecV) { }
</span>40      int GetDim() { return 0; }
41      static void Calc(const TVec<PBowDocBs>& BowDocBsV, TVec<PSemSpace>& SemSpaceV, const TStrV& InBowFNmV, const int& trainsize,
42          const int& Dims = 100, const double& Kapa = 0.5, const int& CGMxIter = 20,  const int& HorstMxIter = 20);
43  };
44  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator.cpp</h3>
            <pre><code>1  #include <tesseract/resultiterator.h>
2  #include "pageres.h"
3  #include "tesseractclass.h"
4  #include "unicharset.h"
5  #include <allheaders.h>
6  #include <set>
7  #include <vector>
8  static const char *const kLRM = "\u200E"; 
9  static const char *const kRLM = "\u200F"; 
10  namespace tesseract {
11  ResultIterator::ResultIterator(const LTRResultIterator &resit) : LTRResultIterator(resit) {
12    in_minor_direction_ = false;
13    at_beginning_of_minor_run_ = false;
14    preserve_interword_spaces_ = false;
15    auto *p = ParamUtils::FindParam<BoolParam>(
16        "preserve_interword_spaces", GlobalParams()->bool_params, tesseract_->params()->bool_params);
17    if (p != nullptr) {
18      preserve_interword_spaces_ = (bool)(*p);
19    }
20    current_paragraph_is_ltr_ = CurrentParagraphIsLtr();
21    MoveToLogicalStartOfTextline();
22  }
23  ResultIterator *ResultIterator::StartOfParagraph(const LTRResultIterator &resit) {
24    return new ResultIterator(resit);
25  }
26  bool ResultIterator::ParagraphIsLtr() const {
27    return current_paragraph_is_ltr_;
28  }
29  bool ResultIterator::CurrentParagraphIsLtr() const {
30    if (!it_->word()) {
31      return true; 
32    }
33    LTRResultIterator it(*this);
34    it.RestartParagraph();
35    bool leftmost_rtl = it.WordDirection() == DIR_RIGHT_TO_LEFT;
36    bool rightmost_ltr = it.WordDirection() == DIR_LEFT_TO_RIGHT;
37    int num_ltr, num_rtl;
38    num_rtl = leftmost_rtl ? 1 : 0;
39    num_ltr = (it.WordDirection() == DIR_LEFT_TO_RIGHT) ? 1 : 0;
40    for (it.Next(RIL_WORD); !it.Empty(RIL_WORD) && !it.IsAtBeginningOf(RIL_TEXTLINE);
41         it.Next(RIL_WORD)) {
42      StrongScriptDirection dir = it.WordDirection();
43      rightmost_ltr = (dir == DIR_LEFT_TO_RIGHT);
44      num_rtl += (dir == DIR_RIGHT_TO_LEFT) ? 1 : 0;
45      num_ltr += rightmost_ltr ? 1 : 0;
46    }
47    if (leftmost_rtl) {
48      return false;
49    }
50    if (rightmost_ltr) {
51      return true;
52    }
53    if (!it.Empty(RIL_WORD) && !it.IsAtBeginningOf(RIL_PARA)) {
54      do {
55        StrongScriptDirection dir = it.WordDirection();
56        num_rtl += (dir == DIR_RIGHT_TO_LEFT) ? 1 : 0;
57        num_ltr += (dir == DIR_LEFT_TO_RIGHT) ? 1 : 0;
58      } while (it.Next(RIL_WORD) && !it.IsAtBeginningOf(RIL_PARA));
59    }
60    return num_ltr >= num_rtl;
61  }
62  const int ResultIterator::kMinorRunStart = -1;
63  const int ResultIterator::kMinorRunEnd = -2;
64  const int ResultIterator::kComplexWord = -3;
65  void ResultIterator::CalculateBlobOrder(std::vector<int> *blob_indices) const {
66    bool context_is_ltr = current_paragraph_is_ltr_ ^ in_minor_direction_;
67    blob_indices->clear();
68    if (Empty(RIL_WORD)) {
69      return;
70    }
71    if (context_is_ltr || it_->word()->UnicharsInReadingOrder()) {
72      for (int i = 0; i < word_length_; i++) {
73        blob_indices->push_back(i);
74      }
75      return;
76    }
77    const int U_LTR = UNICHARSET::U_LEFT_TO_RIGHT;
78    const int U_RTL = UNICHARSET::U_RIGHT_TO_LEFT;
79    const int U_EURO_NUM = UNICHARSET::U_EUROPEAN_NUMBER;
80    const int U_EURO_NUM_SEP = UNICHARSET::U_EUROPEAN_NUMBER_SEPARATOR;
81    const int U_EURO_NUM_TERM = UNICHARSET::U_EUROPEAN_NUMBER_TERMINATOR;
82    const int U_COMMON_NUM_SEP = UNICHARSET::U_COMMON_NUMBER_SEPARATOR;
83    const int U_OTHER_NEUTRAL = UNICHARSET::U_OTHER_NEUTRAL;
84    std::vector<int> letter_types;
85    letter_types.reserve(word_length_);
86    for (int i = 0; i < word_length_; i++) {
87      letter_types.push_back(it_->word()->SymbolDirection(i));
88    }
89    for (int i = 0; i + 2 < word_length_; i++) {
90      if (letter_types[i] == U_EURO_NUM && letter_types[i + 2] == U_EURO_NUM &&
91          (letter_types[i + 1] == U_EURO_NUM_SEP || letter_types[i + 1] == U_COMMON_NUM_SEP)) {
92        letter_types[i + 1] = U_EURO_NUM;
93      }
94    }
95    for (int i = 0; i < word_length_; i++) {
96      if (letter_types[i] == U_EURO_NUM_TERM) {
97        int j = i + 1;
98        while (j < word_length_ && letter_types[j] == U_EURO_NUM_TERM) {
99          j++;
100        }
101        if (j < word_length_ && letter_types[j] == U_EURO_NUM) {
102          for (int k = i; k < j; k++) {
103            letter_types[k] = U_EURO_NUM;
104          }
105        }
106        j = i - 1;
107        while (j > -1 && letter_types[j] == U_EURO_NUM_TERM) {
108          j--;
109        }
110        if (j > -1 && letter_types[j] == U_EURO_NUM) {
111          for (int k = j; k <= i; k++) {
112            letter_types[k] = U_EURO_NUM;
113          }
114        }
115      }
116    }
117    for (int i = 0; i < word_length_;) {
118      int ti = letter_types[i];
119      if (ti == U_LTR || ti == U_EURO_NUM) {
120        int last_good = i;
121        for (int j = i + 1; j < word_length_; j++) {
122          int tj = letter_types[j];
123          if (tj == U_LTR || tj == U_EURO_NUM) {
124            last_good = j;
125          } else if (tj == U_COMMON_NUM_SEP || tj == U_OTHER_NEUTRAL) {
126          } else {
127            break;
128          }
129        }
130        for (int k = i; k <= last_good; k++) {
131          letter_types[k] = U_LTR;
132        }
133        i = last_good + 1;
134      } else {
135        letter_types[i] = U_RTL;
136        i++;
137      }
138    }
139    for (int i = word_length_ - 1; i >= 0;) {
140      if (letter_types[i] == U_RTL) {
141        blob_indices->push_back(i);
142        i--;
143      } else {
144        int j = i - 1;
145        for (; j >= 0 && letter_types[j] != U_RTL; j--) {
146        } 
147        for (int k = j + 1; k <= i; k++) {
148          blob_indices->push_back(k);
149        }
150        i = j;
151      }
152    }
153    ASSERT_HOST(blob_indices->size() == static_cast<size_t>(word_length_));
154  }
155  static void PrintScriptDirs(const std::vector<StrongScriptDirection> &dirs) {
156    for (auto dir : dirs) {
157      switch (dir) {
158        case DIR_NEUTRAL:
159          tprintf("N ");
160          break;
161        case DIR_LEFT_TO_RIGHT:
162          tprintf("L ");
163          break;
164        case DIR_RIGHT_TO_LEFT:
165          tprintf("R ");
166          break;
167        case DIR_MIX:
168          tprintf("Z ");
169          break;
170        default:
171          tprintf("? ");
172          break;
173      }
174    }
175    tprintf("\n");
<span onclick='openModal()' class='match'>176  }
177  void ResultIterator::CalculateTextlineOrder(bool paragraph_is_ltr, const LTRResultIterator &resit,
178                                              std::vector<int> *word_indices) const {
179    std::vector<StrongScriptDirection> directions;
180    CalculateTextlineOrder(paragraph_is_ltr, resit, &directions, word_indices);
181  }
182  void ResultIterator::CalculateTextlineOrder(bool paragraph_is_ltr, const LTRResultIterator &resit,
</span>183                                              std::vector<StrongScriptDirection> *dirs_arg,
184                                              std::vector<int> *word_indices) const {
185    std::vector<StrongScriptDirection> dirs;
186    std::vector<StrongScriptDirection> *directions;
187    directions = (dirs_arg != nullptr) ? dirs_arg : &dirs;
188    directions->clear();
189    LTRResultIterator ltr_it(resit);
190    ltr_it.RestartRow();
191    if (ltr_it.Empty(RIL_WORD)) {
192      return;
193    }
194    do {
195      directions->push_back(ltr_it.WordDirection());
196    } while (ltr_it.Next(RIL_WORD) && !ltr_it.IsAtBeginningOf(RIL_TEXTLINE));
197    word_indices->clear();
198    CalculateTextlineOrder(paragraph_is_ltr, *directions, word_indices);
199  }
200  void ResultIterator::CalculateTextlineOrder(bool paragraph_is_ltr,
201                                              const std::vector<StrongScriptDirection> &word_dirs,
202                                              std::vector<int> *reading_order) {
203    reading_order->clear();
204    if (word_dirs.empty()) {
205      return;
206    }
207    int minor_direction, major_direction, major_step, start, end;
208    if (paragraph_is_ltr) {
209      start = 0;
210      end = word_dirs.size();
211      major_step = 1;
212      major_direction = DIR_LEFT_TO_RIGHT;
213      minor_direction = DIR_RIGHT_TO_LEFT;
214    } else {
215      start = word_dirs.size() - 1;
216      end = -1;
217      major_step = -1;
218      major_direction = DIR_RIGHT_TO_LEFT;
219      minor_direction = DIR_LEFT_TO_RIGHT;
220      if (word_dirs[start] == DIR_NEUTRAL) {
221        int neutral_end = start;
222        while (neutral_end > 0 && word_dirs[neutral_end] == DIR_NEUTRAL) {
223          neutral_end--;
224        }
225        if (neutral_end >= 0 && word_dirs[neutral_end] == DIR_LEFT_TO_RIGHT) {
226          int left = neutral_end;
227          for (int i = left; i >= 0 && word_dirs[i] != DIR_RIGHT_TO_LEFT; i--) {
228            if (word_dirs[i] == DIR_LEFT_TO_RIGHT) {
229              left = i;
230            }
231          }
232          reading_order->push_back(kMinorRunStart);
233          for (unsigned i = left; i < word_dirs.size(); i++) {
234            reading_order->push_back(i);
235            if (word_dirs[i] == DIR_MIX) {
236              reading_order->push_back(kComplexWord);
237            }
238          }
239          reading_order->push_back(kMinorRunEnd);
240          start = left - 1;
241        }
242      }
243    }
244    for (int i = start; i != end;) {
245      if (word_dirs[i] == minor_direction) {
246        int j = i;
247        while (j != end && word_dirs[j] != major_direction) {
248          j += major_step;
249        }
250        if (j == end) {
251          j -= major_step;
252        }
253        while (j != i && word_dirs[j] != minor_direction) {
254          j -= major_step;
255        }
256        reading_order->push_back(kMinorRunStart);
257        for (int k = j; k != i; k -= major_step) {
258          reading_order->push_back(k);
259        }
260        reading_order->push_back(i);
261        reading_order->push_back(kMinorRunEnd);
262        i = j + major_step;
263      } else {
264        reading_order->push_back(i);
265        if (word_dirs[i] == DIR_MIX) {
266          reading_order->push_back(kComplexWord);
267        }
268        i += major_step;
269      }
270    }
271  }
272  int ResultIterator::LTRWordIndex() const {
273    int this_word_index = 0;
274    LTRResultIterator textline(*this);
275    textline.RestartRow();
276    while (!textline.PositionedAtSameWord(it_)) {
277      this_word_index++;
278      textline.Next(RIL_WORD);
279    }
280    return this_word_index;
281  }
282  void ResultIterator::MoveToLogicalStartOfWord() {
283    if (word_length_ == 0) {
284      BeginWord(0);
285      return;
286    }
287    std::vector<int> blob_order;
288    CalculateBlobOrder(&blob_order);
289    if (blob_order.empty() || blob_order[0] == 0) {
290      return;
291    }
292    BeginWord(blob_order[0]);
293  }
294  bool ResultIterator::IsAtFinalSymbolOfWord() const {
295    if (!it_->word()) {
296      return true;
297    }
298    std::vector<int> blob_order;
299    CalculateBlobOrder(&blob_order);
300    return blob_order.empty() || blob_order.back() == blob_index_;
301  }
302  bool ResultIterator::IsAtFirstSymbolOfWord() const {
303    if (!it_->word()) {
304      return true;
305    }
306    std::vector<int> blob_order;
307    CalculateBlobOrder(&blob_order);
308    return blob_order.empty() || blob_order[0] == blob_index_;
309  }
310  void ResultIterator::AppendSuffixMarks(std::string *text) const {
311    if (!it_->word()) {
312      return;
313    }
314    bool reading_direction_is_ltr = current_paragraph_is_ltr_ ^ in_minor_direction_;
315    std::vector<int> textline_order;
316    CalculateTextlineOrder(current_paragraph_is_ltr_, *this, &textline_order);
317    int this_word_index = LTRWordIndex();
318    size_t i = 0;
319    for (const auto word_index : textline_order) {
320      if (word_index == this_word_index) {
321        break;
322      }
323      i++;
324    }
325    if (i == textline_order.size()) {
326      return;
327    }
328    int last_non_word_mark = 0;
329    for (i++; i < textline_order.size() && textline_order[i] < 0; i++) {
330      last_non_word_mark = textline_order[i];
331    }
332    if (last_non_word_mark == kComplexWord) {
333      *text += reading_direction_is_ltr ? kLRM : kRLM;
334    } else if (last_non_word_mark == kMinorRunEnd) {
335      if (current_paragraph_is_ltr_) {
336        *text += kLRM;
337      } else {
338        *text += kRLM;
339      }
340    }
341  }
342  void ResultIterator::MoveToLogicalStartOfTextline() {
343    std::vector<int> word_indices;
344    RestartRow();
345    CalculateTextlineOrder(current_paragraph_is_ltr_, dynamic_cast<const LTRResultIterator &>(*this),
346                           &word_indices);
347    unsigned i = 0;
348    for (; i < word_indices.size() && word_indices[i] < 0; i++) {
349      if (word_indices[i] == kMinorRunStart) {
350        in_minor_direction_ = true;
351      } else if (word_indices[i] == kMinorRunEnd) {
352        in_minor_direction_ = false;
353      }
354    }
355    if (in_minor_direction_) {
356      at_beginning_of_minor_run_ = true;
357    }
358    if (i >= word_indices.size()) {
359      return;
360    }
361    int first_word_index = word_indices[i];
362    for (int j = 0; j < first_word_index; j++) {
363      PageIterator::Next(RIL_WORD);
364    }
365    MoveToLogicalStartOfWord();
366  }
367  void ResultIterator::Begin() {
368    LTRResultIterator::Begin();
369    current_paragraph_is_ltr_ = CurrentParagraphIsLtr();
370    in_minor_direction_ = false;
371    at_beginning_of_minor_run_ = false;
372    MoveToLogicalStartOfTextline();
373  }
374  bool ResultIterator::Next(PageIteratorLevel level) {
375    if (it_->block() == nullptr) {
376      return false; 
377    }
378    switch (level) {
379      case RIL_BLOCK: 
380      case RIL_PARA:  
381      case RIL_TEXTLINE:
382        if (!PageIterator::Next(level)) {
383          return false;
384        }
385        if (IsWithinFirstTextlineOfParagraph()) {
386          current_paragraph_is_ltr_ = CurrentParagraphIsLtr();
387        }
388        in_minor_direction_ = false;
389        MoveToLogicalStartOfTextline();
390        return it_->block() != nullptr;
391      case RIL_SYMBOL: {
392        std::vector<int> blob_order;
393        CalculateBlobOrder(&blob_order);
394        unsigned next_blob = 0;
395        while (next_blob < blob_order.size() && blob_index_ != blob_order[next_blob]) {
396          next_blob++;
397        }
398        next_blob++;
399        if (next_blob < blob_order.size()) {
400          BeginWord(blob_order[next_blob]);
401          at_beginning_of_minor_run_ = false;
402          return true;
403        }
404        level = RIL_WORD; 
405      }
406      case RIL_WORD: 
407      {
408        if (it_->word() == nullptr) {
409          return Next(RIL_BLOCK);
410        }
411        std::vector<int> word_indices;
412        int this_word_index = LTRWordIndex();
413        CalculateTextlineOrder(current_paragraph_is_ltr_, *this, &word_indices);
414        int final_real_index = word_indices.size() - 1;
415        while (final_real_index > 0 && word_indices[final_real_index] < 0) {
416          final_real_index--;
417        }
418        for (int i = 0; i < final_real_index; i++) {
419          if (word_indices[i] == this_word_index) {
420            int j = i + 1;
421            for (; j < final_real_index && word_indices[j] < 0; j++) {
422              if (word_indices[j] == kMinorRunStart) {
423                in_minor_direction_ = true;
424              }
425              if (word_indices[j] == kMinorRunEnd) {
426                in_minor_direction_ = false;
427              }
428            }
429            at_beginning_of_minor_run_ = (word_indices[j - 1] == kMinorRunStart);
430            if (BidiDebug(3)) {
431              tprintf("Next(RIL_WORD): %d -> %d\n", this_word_index, word_indices[j]);
432            }
433            PageIterator::RestartRow();
434            for (int k = 0; k < word_indices[j]; k++) {
435              PageIterator::Next(RIL_WORD);
436            }
437            MoveToLogicalStartOfWord();
438            return true;
439          }
440        }
441        if (BidiDebug(3)) {
442          tprintf("Next(RIL_WORD): %d -> EOL\n", this_word_index);
443        }
444        return Next(RIL_TEXTLINE);
445      }
446    }
447    ASSERT_HOST(false); 
448    return false;
449  }
450  bool ResultIterator::IsAtBeginningOf(PageIteratorLevel level) const {
451    if (it_->block() == nullptr) {
452      return false; 
453    }
454    if (it_->word() == nullptr) {
455      return true; 
456    }
457    if (level == RIL_SYMBOL) {
458      return true; 
459    }
460    bool at_word_start = IsAtFirstSymbolOfWord();
461    if (level == RIL_WORD) {
462      return at_word_start;
463    }
464    ResultIterator line_start(*this);
465    line_start.MoveToLogicalStartOfTextline();
466    bool at_textline_start = at_word_start && *line_start.it_ == *it_;
467    if (level == RIL_TEXTLINE) {
468      return at_textline_start;
469    }
470    line_start.RestartRow();
471    bool at_block_start =
472        at_textline_start && line_start.it_->block() != line_start.it_->prev_block();
473    if (level == RIL_BLOCK) {
474      return at_block_start;
475    }
476    bool at_para_start =
477        at_block_start || (at_textline_start && line_start.it_->row()->row->para() !=
478                                                    line_start.it_->prev_row()->row->para());
479    if (level == RIL_PARA) {
480      return at_para_start;
481    }
482    ASSERT_HOST(false); 
483    return false;
484  }
485  bool ResultIterator::IsAtFinalElement(PageIteratorLevel level, PageIteratorLevel element) const {
486    if (Empty(element)) {
487      return true; 
488    }
489    ResultIterator next(*this);
490    next.Next(element);
491    if (next.Empty(element)) {
492      return true; 
493    }
494    while (element > level) {
495      element = static_cast<PageIteratorLevel>(element - 1);
496      if (!next.IsAtBeginningOf(element)) {
497        return false;
498      }
499    }
500    return true;
501  }
502  int ResultIterator::BlanksBeforeWord() const {
503    if (CurrentParagraphIsLtr()) {
504      return LTRResultIterator::BlanksBeforeWord();
505    }
506    return IsAtBeginningOf(RIL_TEXTLINE) ? 0 : 1;
507  }
508  char *ResultIterator::GetUTF8Text(PageIteratorLevel level) const {
509    if (it_->word() == nullptr) {
510      return nullptr; 
511    }
512    std::string text;
513    switch (level) {
514      case RIL_BLOCK: {
515        ResultIterator pp(*this);
516        do {
517          pp.AppendUTF8ParagraphText(&text);
518        } while (pp.Next(RIL_PARA) && pp.it_->block() == it_->block());
519      } break;
520      case RIL_PARA:
521        AppendUTF8ParagraphText(&text);
522        break;
523      case RIL_TEXTLINE: {
524        ResultIterator it(*this);
525        it.MoveToLogicalStartOfTextline();
526        it.IterateAndAppendUTF8TextlineText(&text);
527      } break;
528      case RIL_WORD:
529        AppendUTF8WordText(&text);
530        break;
531      case RIL_SYMBOL: {
532        bool reading_direction_is_ltr = current_paragraph_is_ltr_ ^ in_minor_direction_;
533        if (at_beginning_of_minor_run_) {
534          text += reading_direction_is_ltr ? kLRM : kRLM;
535        }
536        text = it_->word()->BestUTF8(blob_index_, false);
537        if (IsAtFinalSymbolOfWord()) {
538          AppendSuffixMarks(&text);
539        }
540      } break;
541    }
542    int length = text.length() + 1;
543    char *result = new char[length];
544    strncpy(result, text.c_str(), length);
545    return result;
546  }
547  std::vector<std::vector<std::vector<std::pair<const char *, float>>>>
548      *ResultIterator::GetRawLSTMTimesteps() const {
549    if (it_->word() != nullptr) {
550      return &it_->word()->segmented_timesteps;
551    } else {
552      return nullptr;
553    }
554  }
555  std::vector<std::vector<std::pair<const char *, float>>> *ResultIterator::GetBestLSTMSymbolChoices()
556      const {
557    if (it_->word() != nullptr) {
558      return &it_->word()->CTC_symbol_choices;
559    } else {
560      return nullptr;
561    }
562  }
563  void ResultIterator::AppendUTF8WordText(std::string *text) const {
564    if (!it_->word()) {
565      return;
566    }
567    ASSERT_HOST(it_->word()->best_choice != nullptr);
568    bool reading_direction_is_ltr = current_paragraph_is_ltr_ ^ in_minor_direction_;
569    if (at_beginning_of_minor_run_) {
570      *text += reading_direction_is_ltr ? kLRM : kRLM;
571    }
572    std::vector<int> blob_order;
573    CalculateBlobOrder(&blob_order);
574    for (int i : blob_order) {
575      *text += it_->word()->BestUTF8(i, false);
576    }
577    AppendSuffixMarks(text);
578  }
579  void ResultIterator::IterateAndAppendUTF8TextlineText(std::string *text) {
580    if (Empty(RIL_WORD)) {
581      Next(RIL_WORD);
582      return;
583    }
584    if (BidiDebug(1)) {
585      std::vector<int> textline_order;
586      std::vector<StrongScriptDirection> dirs;
587      CalculateTextlineOrder(current_paragraph_is_ltr_, *this, &dirs, &textline_order);
588      tprintf("Strong Script dirs     [%p/P=%s]: ",
589              static_cast<void *>(it_->row()),
590              current_paragraph_is_ltr_ ? "ltr" : "rtl");
591      PrintScriptDirs(dirs);
592      tprintf("Logical textline order [%p/P=%s]: ",
593              static_cast<void *>(it_->row()),
594              current_paragraph_is_ltr_ ? "ltr" : "rtl");
595      for (int i : textline_order) {
596        tprintf("%d ", i);
597      }
598      tprintf("\n");
599    }
600    int words_appended = 0;
601    do {
602      int numSpaces = preserve_interword_spaces_ ? it_->word()->word->space() : (words_appended > 0);
603      for (int i = 0; i < numSpaces; ++i) {
604        *text += " ";
605      }
606      AppendUTF8WordText(text);
607      words_appended++;
608      if (BidiDebug(2)) {
609        tprintf("Num spaces=%d, text=%s\n", numSpaces, text->c_str());
610      }
611    } while (Next(RIL_WORD) && !IsAtBeginningOf(RIL_TEXTLINE));
612    if (BidiDebug(1)) {
613      tprintf("%d words printed\n", words_appended);
614    }
615    *text += line_separator_;
616    if (IsAtBeginningOf(RIL_PARA)) {
617      *text += paragraph_separator_;
618    }
619  }
620  void ResultIterator::AppendUTF8ParagraphText(std::string *text) const {
621    ResultIterator it(*this);
622    it.RestartParagraph();
623    it.MoveToLogicalStartOfTextline();
624    if (it.Empty(RIL_WORD)) {
625      return;
626    }
627    do {
628      it.IterateAndAppendUTF8TextlineText(text);
629    } while (it.it_->block() != nullptr && !it.IsAtBeginningOf(RIL_PARA));
630  }
631  bool ResultIterator::BidiDebug(int min_level) const {
632    int debug_level = 1;
633    auto *p = ParamUtils::FindParam<IntParam>("bidi_debug", GlobalParams()->int_params,
634                                              tesseract_->params()->int_params);
635    if (p != nullptr) {
636      debug_level = (int32_t)(*p);
637    }
638    return debug_level >= min_level;
639  }
640  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mkcca.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator.cpp</div>
                </div>
                <div class="column column_space"><pre><code>36          const bool& Normalize) { return TBowSpV::New(); }
37      void ProjectSpV(PBowSpV SpV, const int& Dim, 
38          const bool& Normalize, TIntFltPrV& ProjSpV) { }
39      void GetBasisV(const int& VecN, TFltV& VecV) { }
</pre></code></div>
                <div class="column column_space"><pre><code>176  }
177  void ResultIterator::CalculateTextlineOrder(bool paragraph_is_ltr, const LTRResultIterator &resit,
178                                              std::vector<int> *word_indices) const {
179    std::vector<StrongScriptDirection> directions;
180    CalculateTextlineOrder(paragraph_is_ltr, resit, &directions, word_indices);
181  }
182  void ResultIterator::CalculateTextlineOrder(bool paragraph_is_ltr, const LTRResultIterator &resit,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    