
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.728337236533958%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-inja.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_INJA_INJA_HPP_
2  #define INCLUDE_INJA_INJA_HPP_
3  #include <nlohmann/json.hpp>
4  namespace inja {
5  #ifndef INJA_DATA_TYPE
6    using json = nlohmann::json;
7  #else
8    using json = INJA_DATA_TYPE;
9  #endif
10  }
11  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(INJA_NOEXCEPTION)
12    #ifndef INJA_THROW
13      #define INJA_THROW(exception) throw exception
14    #endif
15  #else
16    #include <cstdlib>
17    #ifndef INJA_THROW
18      #define INJA_THROW(exception) std::abort(); std::ignore = exception
19    #endif
20    #ifndef INJA_NOEXCEPTION
21      #define INJA_NOEXCEPTION
22    #endif
23  #endif
24  #ifndef INCLUDE_INJA_ENVIRONMENT_HPP_
25  #define INCLUDE_INJA_ENVIRONMENT_HPP_
26  #include <fstream>
27  #include <iostream>
28  #include <memory>
29  #include <sstream>
30  #include <string>
31  #ifndef INCLUDE_INJA_CONFIG_HPP_
32  #define INCLUDE_INJA_CONFIG_HPP_
33  #include <functional>
34  #include <string>
35  #ifndef NONSTD_SV_LITE_H_INCLUDED
36  #define NONSTD_SV_LITE_H_INCLUDED
37  #define string_view_lite_MAJOR 1
38  #define string_view_lite_MINOR 4
39  #define string_view_lite_PATCH 0
40  #define string_view_lite_VERSION                                                                                       \
41    nssv_STRINGIFY(string_view_lite_MAJOR) "." nssv_STRINGIFY(string_view_lite_MINOR) "." nssv_STRINGIFY(                \
42        string_view_lite_PATCH)
43  #define nssv_STRINGIFY(x) nssv_STRINGIFY_(x)
44  #define nssv_STRINGIFY_(x) #x
45  #define nssv_STRING_VIEW_DEFAULT 0
46  #define nssv_STRING_VIEW_NONSTD 1
47  #define nssv_STRING_VIEW_STD 2
48  #if !defined(nssv_CONFIG_SELECT_STRING_VIEW)
49  #define nssv_CONFIG_SELECT_STRING_VIEW (nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD)
50  #endif
51  #if defined(nssv_CONFIG_SELECT_STD_STRING_VIEW) || defined(nssv_CONFIG_SELECT_NONSTD_STRING_VIEW)
52  #error nssv_CONFIG_SELECT_STD_STRING_VIEW and nssv_CONFIG_SELECT_NONSTD_STRING_VIEW are deprecated and removed, please use nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_...
53  #endif
54  #ifndef nssv_CONFIG_STD_SV_OPERATOR
55  #define nssv_CONFIG_STD_SV_OPERATOR 0
56  #endif
57  #ifndef nssv_CONFIG_USR_SV_OPERATOR
58  #define nssv_CONFIG_USR_SV_OPERATOR 1
59  #endif
60  #ifdef nssv_CONFIG_CONVERSION_STD_STRING
61  #define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS nssv_CONFIG_CONVERSION_STD_STRING
62  #define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS nssv_CONFIG_CONVERSION_STD_STRING
63  #endif
64  #ifndef nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
65  #define nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS 1
66  #endif
67  #ifndef nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
68  #define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS 1
69  #endif
70  #ifndef nssv_CONFIG_NO_EXCEPTIONS
71  #if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)
72  #define nssv_CONFIG_NO_EXCEPTIONS 0
73  #else
74  #define nssv_CONFIG_NO_EXCEPTIONS 1
75  #endif
76  #endif
77  #ifndef nssv_CPLUSPLUS
78  #if defined(_MSVC_LANG) && !defined(__clang__)
79  #define nssv_CPLUSPLUS (_MSC_VER == 1900 ? 201103L : _MSVC_LANG)
80  #else
81  #define nssv_CPLUSPLUS __cplusplus
82  #endif
83  #endif
84  #define nssv_CPP98_OR_GREATER (nssv_CPLUSPLUS >= 199711L)
85  #define nssv_CPP11_OR_GREATER (nssv_CPLUSPLUS >= 201103L)
86  #define nssv_CPP11_OR_GREATER_ (nssv_CPLUSPLUS >= 201103L)
87  #define nssv_CPP14_OR_GREATER (nssv_CPLUSPLUS >= 201402L)
88  #define nssv_CPP17_OR_GREATER (nssv_CPLUSPLUS >= 201703L)
89  #define nssv_CPP20_OR_GREATER (nssv_CPLUSPLUS >= 202000L)
90  #if nssv_CPP17_OR_GREATER && defined(__has_include)
91  #if __has_include(<string_view> )
92  #define nssv_HAVE_STD_STRING_VIEW 1
93  #else
94  #define nssv_HAVE_STD_STRING_VIEW 0
95  #endif
96  #else
97  #define nssv_HAVE_STD_STRING_VIEW 0
98  #endif
99  #define nssv_USES_STD_STRING_VIEW                                                                                      \
100    ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_STD) ||                                                         \
101     ((nssv_CONFIG_SELECT_STRING_VIEW == nssv_STRING_VIEW_DEFAULT) && nssv_HAVE_STD_STRING_VIEW))
102  #define nssv_HAVE_STARTS_WITH (nssv_CPP20_OR_GREATER || !nssv_USES_STD_STRING_VIEW)
103  #define nssv_HAVE_ENDS_WITH nssv_HAVE_STARTS_WITH
104  #if nssv_USES_STD_STRING_VIEW
105  #include <string_view>
106  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
107  namespace nonstd {
108  template <class CharT, class Traits, class Allocator = std::allocator<CharT>>
109  std::basic_string<CharT, Traits, Allocator> to_string(std::basic_string_view<CharT, Traits> v,
110                                                        Allocator const &a = Allocator()) {
111    return std::basic_string<CharT, Traits, Allocator>(v.begin(), v.end(), a);
112  }
113  template <class CharT, class Traits, class Allocator>
114  std::basic_string_view<CharT, Traits> to_string_view(std::basic_string<CharT, Traits, Allocator> const &s) {
115    return std::basic_string_view<CharT, Traits>(s.data(), s.size());
116  }
117  #if nssv_CONFIG_STD_SV_OPERATOR
118  using namespace std::literals::string_view_literals;
119  #endif
120  #if nssv_CONFIG_USR_SV_OPERATOR
121  inline namespace literals {
122  inline namespace string_view_literals {
123  constexpr std::string_view operator"" _sv(const char *str, size_t len) noexcept 
124  {
125    return std::string_view {str, len};
126  }
127  constexpr std::u16string_view operator"" _sv(const char16_t *str, size_t len) noexcept 
128  {
129    return std::u16string_view {str, len};
130  }
131  constexpr std::u32string_view operator"" _sv(const char32_t *str, size_t len) noexcept 
132  {
133    return std::u32string_view {str, len};
134  }
135  constexpr std::wstring_view operator"" _sv(const wchar_t *str, size_t len) noexcept 
136  {
137    return std::wstring_view {str, len};
138  }
139  } 
140  } 
141  #endif 
142  } 
143  #endif 
144  namespace nonstd {
145  using std::basic_string_view;
146  using std::string_view;
147  using std::u16string_view;
148  using std::u32string_view;
149  using std::wstring_view;
150  using std::operator==;
151  using std::operator!=;
152  using std::operator<;
153  using std::operator<=;
154  using std::operator>;
155  using std::operator>=;
156  using std::operator<<;
157  } 
158  #else 
159  #if defined(_MSC_VER) && !defined(__clang__)
160  #define nssv_COMPILER_MSVC_VER (_MSC_VER)
161  #define nssv_COMPILER_MSVC_VERSION (_MSC_VER / 10 - 10 * (5 + (_MSC_VER < 1900)))
162  #else
163  #define nssv_COMPILER_MSVC_VER 0
164  #define nssv_COMPILER_MSVC_VERSION 0
165  #endif
166  #define nssv_COMPILER_VERSION(major, minor, patch) (10 * (10 * (major) + (minor)) + (patch))
167  #if defined(__clang__)
168  #define nssv_COMPILER_CLANG_VERSION nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)
169  #else
170  #define nssv_COMPILER_CLANG_VERSION 0
171  #endif
172  #if defined(__GNUC__) && !defined(__clang__)
173  #define nssv_COMPILER_GNUC_VERSION nssv_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
174  #else
175  #define nssv_COMPILER_GNUC_VERSION 0
176  #endif
177  #define nssv_BETWEEN(v, lo, hi) ((lo) <= (v) && (v) < (hi))
178  #ifdef _HAS_CPP0X
179  #define nssv_HAS_CPP0X _HAS_CPP0X
180  #else
181  #define nssv_HAS_CPP0X 0
182  #endif
183  #if nssv_COMPILER_MSVC_VER >= 1900
184  #undef nssv_CPP11_OR_GREATER
185  #define nssv_CPP11_OR_GREATER 1
186  #endif
187  #define nssv_CPP11_90 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1500)
188  #define nssv_CPP11_100 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1600)
189  #define nssv_CPP11_110 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1700)
190  #define nssv_CPP11_120 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1800)
191  #define nssv_CPP11_140 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1900)
192  #define nssv_CPP11_141 (nssv_CPP11_OR_GREATER_ || nssv_COMPILER_MSVC_VER >= 1910)
193  #define nssv_CPP14_000 (nssv_CPP14_OR_GREATER)
194  #define nssv_CPP17_000 (nssv_CPP17_OR_GREATER)
195  #define nssv_HAVE_CONSTEXPR_11 nssv_CPP11_140
196  #define nssv_HAVE_EXPLICIT_CONVERSION nssv_CPP11_140
197  #define nssv_HAVE_INLINE_NAMESPACE nssv_CPP11_140
198  #define nssv_HAVE_NOEXCEPT nssv_CPP11_140
199  #define nssv_HAVE_NULLPTR nssv_CPP11_100
200  #define nssv_HAVE_REF_QUALIFIER nssv_CPP11_140
201  #define nssv_HAVE_UNICODE_LITERALS nssv_CPP11_140
202  #define nssv_HAVE_USER_DEFINED_LITERALS nssv_CPP11_140
203  #define nssv_HAVE_WCHAR16_T nssv_CPP11_100
204  #define nssv_HAVE_WCHAR32_T nssv_CPP11_100
205  #if !((nssv_CPP11_OR_GREATER && nssv_COMPILER_CLANG_VERSION) || nssv_BETWEEN(nssv_COMPILER_CLANG_VERSION, 300, 400))
206  #define nssv_HAVE_STD_DEFINED_LITERALS nssv_CPP11_140
207  #else
208  #define nssv_HAVE_STD_DEFINED_LITERALS 0
209  #endif
210  #define nssv_HAVE_CONSTEXPR_14 nssv_CPP14_000
211  #define nssv_HAVE_NODISCARD nssv_CPP17_000
212  #define nssv_HAVE_STD_HASH nssv_CPP11_120
213  #if nssv_HAVE_CONSTEXPR_11
214  #define nssv_constexpr constexpr
215  #else
216  #define nssv_constexpr &bsol;*constexpr*/
217  #endif
218  #if nssv_HAVE_CONSTEXPR_14
219  #define nssv_constexpr14 constexpr
220  #else
221  #define nssv_constexpr14 &bsol;*constexpr*/
222  #endif
223  #if nssv_HAVE_EXPLICIT_CONVERSION
224  #define nssv_explicit explicit
225  #else
226  #define nssv_explicit &bsol;*explicit*/
227  #endif
228  #if nssv_HAVE_INLINE_NAMESPACE
229  #define nssv_inline_ns inline
230  #else
231  #define nssv_inline_ns &bsol;*inline*/
232  #endif
233  #if nssv_HAVE_NOEXCEPT
234  #define nssv_noexcept noexcept
235  #else
236  #define nssv_noexcept &bsol;*noexcept*/
237  #endif
238  #if nssv_HAVE_NULLPTR
239  #define nssv_nullptr nullptr
240  #else
241  #define nssv_nullptr NULL
242  #endif
243  #if nssv_HAVE_NODISCARD
244  #define nssv_nodiscard [[nodiscard]]
245  #else
246  #define nssv_nodiscard &bsol;*[[nodiscard]]*/
247  #endif
248  #include <algorithm>
249  #include <cassert>
250  #include <iterator>
251  #include <limits>
252  #include <ostream>
253  #include <string> 
254  #if !nssv_CONFIG_NO_EXCEPTIONS
255  #include <stdexcept>
256  #endif
257  #if nssv_CPP11_OR_GREATER
258  #include <type_traits>
259  #endif
260  #if defined(__clang__)
261  #pragma clang diagnostic ignored "-Wreserved-user-defined-literal"
262  #pragma clang diagnostic push
263  #pragma clang diagnostic ignored "-Wuser-defined-literals"
264  #elif defined(__GNUC__)
265  #pragma GCC diagnostic push
266  #pragma GCC diagnostic ignored "-Wliteral-suffix"
267  #endif 
268  #if nssv_COMPILER_MSVC_VERSION >= 140
269  #define nssv_SUPPRESS_MSGSL_WARNING(expr) [[gsl::suppress(expr)]]
270  #define nssv_SUPPRESS_MSVC_WARNING(code, descr) __pragma(warning(suppress : code))
271  #define nssv_DISABLE_MSVC_WARNINGS(codes) __pragma(warning(push)) __pragma(warning(disable : codes))
272  #else
273  #define nssv_SUPPRESS_MSGSL_WARNING(expr)
274  #define nssv_SUPPRESS_MSVC_WARNING(code, descr)
275  #define nssv_DISABLE_MSVC_WARNINGS(codes)
276  #endif
277  #if defined(__clang__)
278  #define nssv_RESTORE_WARNINGS() _Pragma("clang diagnostic pop")
279  #elif defined(__GNUC__)
280  #define nssv_RESTORE_WARNINGS() _Pragma("GCC diagnostic pop")
281  #elif nssv_COMPILER_MSVC_VERSION >= 140
282  #define nssv_RESTORE_WARNINGS() __pragma(warning(pop))
283  #else
284  #define nssv_RESTORE_WARNINGS()
285  #endif
286  nssv_DISABLE_MSVC_WARNINGS(4455 26481 26472)
287      namespace nonstd {
288    namespace sv_lite {
289  #if nssv_CPP11_OR_GREATER
290    namespace detail {
291    template <typename CharT> inline constexpr std::size_t length(CharT *s, std::size_t result = 0) {
292      return *s == '\0' ? result : length(s + 1, result + 1);
293    }
294    } 
295  #endif 
296    template <class CharT, class Traits = std::char_traits<CharT>> class basic_string_view;
297    template <class CharT, class Traits &bsol;* = std::char_traits<CharT> */
298              >
299    class basic_string_view {
300    public:
301      typedef Traits traits_type;
302      typedef CharT value_type;
303      typedef CharT *pointer;
304      typedef CharT const *const_pointer;
305      typedef CharT &reference;
306      typedef CharT const &const_reference;
307      typedef const_pointer iterator;
308      typedef const_pointer const_iterator;
309      typedef std::reverse_iterator<const_iterator> reverse_iterator;
310      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
311      typedef std::size_t size_type;
312      typedef std::ptrdiff_t difference_type;
313      nssv_constexpr basic_string_view() nssv_noexcept : data_(nssv_nullptr), size_(0) {}
314  #if nssv_CPP11_OR_GREATER
315      nssv_constexpr basic_string_view(basic_string_view const &other) nssv_noexcept = default;
316  #else
317      nssv_constexpr basic_string_view(basic_string_view const &other) nssv_noexcept : data_(other.data_),
318                                                                                       size_(other.size_) {}
319  #endif
320      nssv_constexpr basic_string_view(CharT const *s, size_type count) nssv_noexcept 
321          : data_(s),
322            size_(count) {}
323      nssv_constexpr basic_string_view(CharT const *s) nssv_noexcept 
324          : data_(s)
325  #if nssv_CPP17_OR_GREATER
326          ,
327            size_(Traits::length(s))
328  #elif nssv_CPP11_OR_GREATER
329          ,
330            size_(detail::length(s))
331  #else
332          ,
333            size_(Traits::length(s))
334  #endif
335      {
336      }
337  #if nssv_CPP11_OR_GREATER
338      nssv_constexpr14 basic_string_view &operator=(basic_string_view const &other) nssv_noexcept = default;
339  #else
340      nssv_constexpr14 basic_string_view &operator=(basic_string_view const &other) nssv_noexcept {
341        data_ = other.data_;
342        size_ = other.size_;
343        return *this;
344      }
345  #endif
346      nssv_constexpr const_iterator begin() const nssv_noexcept { return data_; }
347      nssv_constexpr const_iterator end() const nssv_noexcept { return data_ + size_; }
348      nssv_constexpr const_iterator cbegin() const nssv_noexcept { return begin(); }
349      nssv_constexpr const_iterator cend() const nssv_noexcept { return end(); }
350      nssv_constexpr const_reverse_iterator rbegin() const nssv_noexcept { return const_reverse_iterator(end()); }
351      nssv_constexpr const_reverse_iterator rend() const nssv_noexcept { return const_reverse_iterator(begin()); }
352      nssv_constexpr const_reverse_iterator crbegin() const nssv_noexcept { return rbegin(); }
353      nssv_constexpr const_reverse_iterator crend() const nssv_noexcept { return rend(); }
354      nssv_constexpr size_type size() const nssv_noexcept { return size_; }
355      nssv_constexpr size_type length() const nssv_noexcept { return size_; }
356      nssv_constexpr size_type max_size() const nssv_noexcept { return (std::numeric_limits<size_type>::max)(); }
357      nssv_nodiscard nssv_constexpr bool empty() const nssv_noexcept { return 0 == size_; }
358      nssv_constexpr const_reference operator[](size_type pos) const { return data_at(pos); }
359      nssv_constexpr14 const_reference at(size_type pos) const {
360  #if nssv_CONFIG_NO_EXCEPTIONS
361        assert(pos < size());
362  #else
363        if (pos >= size()) {
364          throw std::out_of_range("nonstd::string_view::at()");
365        }
366  #endif
367        return data_at(pos);
368      }
369      nssv_constexpr const_reference front() const { return data_at(0); }
370      nssv_constexpr const_reference back() const { return data_at(size() - 1); }
371      nssv_constexpr const_pointer data() const nssv_noexcept { return data_; }
372      nssv_constexpr14 void remove_prefix(size_type n) {
373        assert(n <= size());
374        data_ += n;
375        size_ -= n;
376      }
377      nssv_constexpr14 void remove_suffix(size_type n) {
378        assert(n <= size());
379        size_ -= n;
380      }
381      nssv_constexpr14 void swap(basic_string_view &other) nssv_noexcept {
382        using std::swap;
383        swap(data_, other.data_);
384        swap(size_, other.size_);
385      }
386      size_type copy(CharT *dest, size_type n, size_type pos = 0) const {
387  #if nssv_CONFIG_NO_EXCEPTIONS
388        assert(pos <= size());
389  #else
390        if (pos > size()) {
391          throw std::out_of_range("nonstd::string_view::copy()");
392        }
393  #endif
394        const size_type rlen = (std::min)(n, size() - pos);
395        (void)Traits::copy(dest, data() + pos, rlen);
396        return rlen;
397      }
398      nssv_constexpr14 basic_string_view substr(size_type pos = 0, size_type n = npos) const {
399  #if nssv_CONFIG_NO_EXCEPTIONS
400        assert(pos <= size());
401  #else
402        if (pos > size()) {
403          throw std::out_of_range("nonstd::string_view::substr()");
404        }
405  #endif
406        return basic_string_view(data() + pos, (std::min)(n, size() - pos));
407      }
408      nssv_constexpr14 int compare(basic_string_view other) const nssv_noexcept 
409      {
410        if (const int result = Traits::compare(data(), other.data(), (std::min)(size(), other.size()))) {
411          return result;
412        }
413        return size() == other.size() ? 0 : size() < other.size() ? -1 : 1;
414      }
415      nssv_constexpr int compare(size_type pos1, size_type n1, basic_string_view other) const 
416      {
417        return substr(pos1, n1).compare(other);
418      }
419      nssv_constexpr int compare(size_type pos1, size_type n1, basic_string_view other, size_type pos2,
420                                 size_type n2) const 
421      {
422        return substr(pos1, n1).compare(other.substr(pos2, n2));
423      }
424      nssv_constexpr int compare(CharT const *s) const 
425      {
426        return compare(basic_string_view(s));
427      }
428      nssv_constexpr int compare(size_type pos1, size_type n1, CharT const *s) const 
429      {
430        return substr(pos1, n1).compare(basic_string_view(s));
431      }
432      nssv_constexpr int compare(size_type pos1, size_type n1, CharT const *s, size_type n2) const 
433      {
434        return substr(pos1, n1).compare(basic_string_view(s, n2));
435      }
436      nssv_constexpr bool starts_with(basic_string_view v) const nssv_noexcept 
437      {
438        return size() >= v.size() && compare(0, v.size(), v) == 0;
439      }
440      nssv_constexpr bool starts_with(CharT c) const nssv_noexcept 
441      {
442        return starts_with(basic_string_view(&c, 1));
443      }
444      nssv_constexpr bool starts_with(CharT const *s) const 
445      {
446        return starts_with(basic_string_view(s));
447      }
448      nssv_constexpr bool ends_with(basic_string_view v) const nssv_noexcept 
449      {
450        return size() >= v.size() && compare(size() - v.size(), npos, v) == 0;
451      }
452      nssv_constexpr bool ends_with(CharT c) const nssv_noexcept 
453      {
454        return ends_with(basic_string_view(&c, 1));
455      }
456      nssv_constexpr bool ends_with(CharT const *s) const 
457      {
458        return ends_with(basic_string_view(s));
459      }
460      nssv_constexpr14 size_type find(basic_string_view v, size_type pos = 0) const nssv_noexcept 
461      {
462        return assert(v.size() == 0 || v.data() != nssv_nullptr),
463               pos >= size() ? npos : to_pos(std::search(cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq));
464      }
465      nssv_constexpr14 size_type find(CharT c, size_type pos = 0) const nssv_noexcept 
466      {
467        return find(basic_string_view(&c, 1), pos);
468      }
469      nssv_constexpr14 size_type find(CharT const *s, size_type pos, size_type n) const 
470      {
471        return find(basic_string_view(s, n), pos);
472      }
473      nssv_constexpr14 size_type find(CharT const *s, size_type pos = 0) const 
474      {
475        return find(basic_string_view(s), pos);
476      }
477      nssv_constexpr14 size_type rfind(basic_string_view v, size_type pos = npos) const nssv_noexcept 
478      {
479        if (size() < v.size()) {
480          return npos;
481        }
482        if (v.empty()) {
483          return (std::min)(size(), pos);
484        }
485        const_iterator last = cbegin() + (std::min)(size() - v.size(), pos) + v.size();
486        const_iterator result = std::find_end(cbegin(), last, v.cbegin(), v.cend(), Traits::eq);
487        return result != last ? size_type(result - cbegin()) : npos;
488      }
489      nssv_constexpr14 size_type rfind(CharT c, size_type pos = npos) const nssv_noexcept 
490      {
491        return rfind(basic_string_view(&c, 1), pos);
492      }
493      nssv_constexpr14 size_type rfind(CharT const *s, size_type pos, size_type n) const 
494      {
495        return rfind(basic_string_view(s, n), pos);
496      }
497      nssv_constexpr14 size_type rfind(CharT const *s, size_type pos = npos) const 
498      {
499        return rfind(basic_string_view(s), pos);
500      }
501      nssv_constexpr size_type find_first_of(basic_string_view v, size_type pos = 0) const nssv_noexcept 
502      {
503        return pos >= size() ? npos
504                             : to_pos(std::find_first_of(cbegin() + pos, cend(), v.cbegin(), v.cend(), Traits::eq));
505      }
506      nssv_constexpr size_type find_first_of(CharT c, size_type pos = 0) const nssv_noexcept 
507      {
508        return find_first_of(basic_string_view(&c, 1), pos);
509      }
510      nssv_constexpr size_type find_first_of(CharT const *s, size_type pos, size_type n) const 
511      {
512        return find_first_of(basic_string_view(s, n), pos);
513      }
514      nssv_constexpr size_type find_first_of(CharT const *s, size_type pos = 0) const 
515      {
516        return find_first_of(basic_string_view(s), pos);
517      }
518      nssv_constexpr size_type find_last_of(basic_string_view v, size_type pos = npos) const nssv_noexcept 
519      {
520        return empty() ? npos
521                       : pos >= size() ? find_last_of(v, size() - 1)
522                                       : to_pos(std::find_first_of(const_reverse_iterator(cbegin() + pos + 1), crend(),
523                                                                   v.cbegin(), v.cend(), Traits::eq));
524      }
525      nssv_constexpr size_type find_last_of(CharT c, size_type pos = npos) const nssv_noexcept 
526      {
527        return find_last_of(basic_string_view(&c, 1), pos);
528      }
529      nssv_constexpr size_type find_last_of(CharT const *s, size_type pos, size_type count) const 
530      {
531        return find_last_of(basic_string_view(s, count), pos);
532      }
533      nssv_constexpr size_type find_last_of(CharT const *s, size_type pos = npos) const 
534      {
535        return find_last_of(basic_string_view(s), pos);
536      }
537      nssv_constexpr size_type find_first_not_of(basic_string_view v, size_type pos = 0) const nssv_noexcept 
538      {
539        return pos >= size() ? npos : to_pos(std::find_if(cbegin() + pos, cend(), not_in_view(v)));
540      }
541      nssv_constexpr size_type find_first_not_of(CharT c, size_type pos = 0) const nssv_noexcept 
542      {
543        return find_first_not_of(basic_string_view(&c, 1), pos);
544      }
545      nssv_constexpr size_type find_first_not_of(CharT const *s, size_type pos, size_type count) const 
546      {
547        return find_first_not_of(basic_string_view(s, count), pos);
548      }
549      nssv_constexpr size_type find_first_not_of(CharT const *s, size_type pos = 0) const 
550      {
551        return find_first_not_of(basic_string_view(s), pos);
552      }
553      nssv_constexpr size_type find_last_not_of(basic_string_view v, size_type pos = npos) const nssv_noexcept 
554      {
555        return empty() ? npos
<span onclick='openModal()' class='match'>556                       : pos >= size()
557                             ? find_last_not_of(v, size() - 1)
558                             : to_pos(std::find_if(const_reverse_iterator(cbegin() + pos + 1), crend(), not_in_view(v)));
</span>559      }
560      nssv_constexpr size_type find_last_not_of(CharT c, size_type pos = npos) const nssv_noexcept 
561      {
562        return find_last_not_of(basic_string_view(&c, 1), pos);
563      }
564      nssv_constexpr size_type find_last_not_of(CharT const *s, size_type pos, size_type count) const 
565      {
566        return find_last_not_of(basic_string_view(s, count), pos);
567      }
568      nssv_constexpr size_type find_last_not_of(CharT const *s, size_type pos = npos) const 
569      {
570        return find_last_not_of(basic_string_view(s), pos);
571      }
572  #if nssv_CPP17_OR_GREATER
573      static nssv_constexpr size_type npos = size_type(-1);
574  #elif nssv_CPP11_OR_GREATER
575      enum : size_type { npos = size_type(-1) };
576  #else
577      enum { npos = size_type(-1) };
578  #endif
579    private:
580      struct not_in_view {
581        const basic_string_view v;
582        nssv_constexpr explicit not_in_view(basic_string_view v) : v(v) {}
583        nssv_constexpr bool operator()(CharT c) const { return npos == v.find_first_of(c); }
584      };
585      nssv_constexpr size_type to_pos(const_iterator it) const { return it == cend() ? npos : size_type(it - cbegin()); }
586      nssv_constexpr size_type to_pos(const_reverse_iterator it) const {
587        return it == crend() ? npos : size_type(crend() - it - 1);
588      }
589      nssv_constexpr const_reference data_at(size_type pos) const {
590  #if nssv_BETWEEN(nssv_COMPILER_GNUC_VERSION, 1, 500)
591        return data_[pos];
592  #else
593        return assert(pos < size()), data_[pos];
594  #endif
595      }
596    private:
597      const_pointer data_;
598      size_type size_;
599    public:
600  #if nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS
601      template <class Allocator>
602      basic_string_view(std::basic_string<CharT, Traits, Allocator> const &s) nssv_noexcept : data_(s.data()),
603                                                                                              size_(s.size()) {}
604  #if nssv_HAVE_EXPLICIT_CONVERSION
605      template <class Allocator> explicit operator std::basic_string<CharT, Traits, Allocator>() const {
606        return to_string(Allocator());
607      }
608  #endif 
609  #if nssv_CPP11_OR_GREATER
610      template <class Allocator = std::allocator<CharT>>
611      std::basic_string<CharT, Traits, Allocator> to_string(Allocator const &a = Allocator()) const {
612        return std::basic_string<CharT, Traits, Allocator>(begin(), end(), a);
613      }
614  #else
615      std::basic_string<CharT, Traits> to_string() const { return std::basic_string<CharT, Traits>(begin(), end()); }
616      template <class Allocator> std::basic_string<CharT, Traits, Allocator> to_string(Allocator const &a) const {
617        return std::basic_string<CharT, Traits, Allocator>(begin(), end(), a);
618      }
619  #endif 
620  #endif 
621    };
622    template <class CharT, class Traits>
623    nssv_constexpr bool operator==(basic_string_view<CharT, Traits> lhs,
624                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
625      return lhs.compare(rhs) == 0;
626    }
627    template <class CharT, class Traits>
628    nssv_constexpr bool operator!=(basic_string_view<CharT, Traits> lhs,
629                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
630      return lhs.compare(rhs) != 0;
631    }
632    template <class CharT, class Traits>
633    nssv_constexpr bool operator<(basic_string_view<CharT, Traits> lhs,
634                                  basic_string_view<CharT, Traits> rhs) nssv_noexcept {
635      return lhs.compare(rhs) < 0;
636    }
637    template <class CharT, class Traits>
638    nssv_constexpr bool operator<=(basic_string_view<CharT, Traits> lhs,
639                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
640      return lhs.compare(rhs) <= 0;
641    }
642    template <class CharT, class Traits>
643    nssv_constexpr bool operator>(basic_string_view<CharT, Traits> lhs,
644                                  basic_string_view<CharT, Traits> rhs) nssv_noexcept {
645      return lhs.compare(rhs) > 0;
646    }
647    template <class CharT, class Traits>
648    nssv_constexpr bool operator>=(basic_string_view<CharT, Traits> lhs,
649                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
650      return lhs.compare(rhs) >= 0;
651    }
652  #if !nssv_CPP11_OR_GREATER || nssv_BETWEEN(nssv_COMPILER_MSVC_VERSION, 100, 141)
653    template <class CharT, class Traits>
654    nssv_constexpr bool operator==(basic_string_view<CharT, Traits> lhs, char const *rhs) nssv_noexcept {
655      return lhs.compare(rhs) == 0;
656    }
657    template <class CharT, class Traits>
658    nssv_constexpr bool operator==(char const *lhs, basic_string_view<CharT, Traits> rhs) nssv_noexcept {
659      return rhs.compare(lhs) == 0;
660    }
661    template <class CharT, class Traits>
662    nssv_constexpr bool operator==(basic_string_view<CharT, Traits> lhs,
663                                   std::basic_string<CharT, Traits> rhs) nssv_noexcept {
664      return lhs.size() == rhs.size() && lhs.compare(rhs) == 0;
665    }
666    template <class CharT, class Traits>
667    nssv_constexpr bool operator==(std::basic_string<CharT, Traits> rhs,
668                                   basic_string_view<CharT, Traits> lhs) nssv_noexcept {
669      return lhs.size() == rhs.size() && lhs.compare(rhs) == 0;
670    }
671    template <class CharT, class Traits>
672    nssv_constexpr bool operator!=(basic_string_view<CharT, Traits> lhs, char const *rhs) nssv_noexcept {
673      return lhs.compare(rhs) != 0;
674    }
675    template <class CharT, class Traits>
676    nssv_constexpr bool operator!=(char const *lhs, basic_string_view<CharT, Traits> rhs) nssv_noexcept {
677      return rhs.compare(lhs) != 0;
678    }
679    template <class CharT, class Traits>
680    nssv_constexpr bool operator!=(basic_string_view<CharT, Traits> lhs,
681                                   std::basic_string<CharT, Traits> rhs) nssv_noexcept {
682      return lhs.size() != rhs.size() && lhs.compare(rhs) != 0;
683    }
684    template <class CharT, class Traits>
685    nssv_constexpr bool operator!=(std::basic_string<CharT, Traits> rhs,
686                                   basic_string_view<CharT, Traits> lhs) nssv_noexcept {
687      return lhs.size() != rhs.size() || rhs.compare(lhs) != 0;
688    }
689    template <class CharT, class Traits>
690    nssv_constexpr bool operator<(basic_string_view<CharT, Traits> lhs, char const *rhs) nssv_noexcept {
691      return lhs.compare(rhs) < 0;
692    }
693    template <class CharT, class Traits>
694    nssv_constexpr bool operator<(char const *lhs, basic_string_view<CharT, Traits> rhs) nssv_noexcept {
695      return rhs.compare(lhs) > 0;
696    }
697    template <class CharT, class Traits>
698    nssv_constexpr bool operator<(basic_string_view<CharT, Traits> lhs,
699                                  std::basic_string<CharT, Traits> rhs) nssv_noexcept {
700      return lhs.compare(rhs) < 0;
701    }
702    template <class CharT, class Traits>
703    nssv_constexpr bool operator<(std::basic_string<CharT, Traits> rhs,
704                                  basic_string_view<CharT, Traits> lhs) nssv_noexcept {
705      return rhs.compare(lhs) > 0;
706    }
707    template <class CharT, class Traits>
708    nssv_constexpr bool operator<=(basic_string_view<CharT, Traits> lhs, char const *rhs) nssv_noexcept {
709      return lhs.compare(rhs) <= 0;
710    }
711    template <class CharT, class Traits>
712    nssv_constexpr bool operator<=(char const *lhs, basic_string_view<CharT, Traits> rhs) nssv_noexcept {
713      return rhs.compare(lhs) >= 0;
714    }
715    template <class CharT, class Traits>
716    nssv_constexpr bool operator<=(basic_string_view<CharT, Traits> lhs,
717                                   std::basic_string<CharT, Traits> rhs) nssv_noexcept {
718      return lhs.compare(rhs) <= 0;
719    }
720    template <class CharT, class Traits>
721    nssv_constexpr bool operator<=(std::basic_string<CharT, Traits> rhs,
722                                   basic_string_view<CharT, Traits> lhs) nssv_noexcept {
723      return rhs.compare(lhs) >= 0;
724    }
725    template <class CharT, class Traits>
726    nssv_constexpr bool operator>(basic_string_view<CharT, Traits> lhs, char const *rhs) nssv_noexcept {
727      return lhs.compare(rhs) > 0;
728    }
729    template <class CharT, class Traits>
730    nssv_constexpr bool operator>(char const *lhs, basic_string_view<CharT, Traits> rhs) nssv_noexcept {
731      return rhs.compare(lhs) < 0;
732    }
733    template <class CharT, class Traits>
734    nssv_constexpr bool operator>(basic_string_view<CharT, Traits> lhs,
735                                  std::basic_string<CharT, Traits> rhs) nssv_noexcept {
736      return lhs.compare(rhs) > 0;
737    }
738    template <class CharT, class Traits>
739    nssv_constexpr bool operator>(std::basic_string<CharT, Traits> rhs,
740                                  basic_string_view<CharT, Traits> lhs) nssv_noexcept {
741      return rhs.compare(lhs) < 0;
742    }
743    template <class CharT, class Traits>
744    nssv_constexpr bool operator>=(basic_string_view<CharT, Traits> lhs, char const *rhs) nssv_noexcept {
745      return lhs.compare(rhs) >= 0;
746    }
747    template <class CharT, class Traits>
748    nssv_constexpr bool operator>=(char const *lhs, basic_string_view<CharT, Traits> rhs) nssv_noexcept {
749      return rhs.compare(lhs) <= 0;
750    }
751    template <class CharT, class Traits>
752    nssv_constexpr bool operator>=(basic_string_view<CharT, Traits> lhs,
753                                   std::basic_string<CharT, Traits> rhs) nssv_noexcept {
754      return lhs.compare(rhs) >= 0;
755    }
756    template <class CharT, class Traits>
757    nssv_constexpr bool operator>=(std::basic_string<CharT, Traits> rhs,
758                                   basic_string_view<CharT, Traits> lhs) nssv_noexcept {
759      return rhs.compare(lhs) <= 0;
760    }
761  #else 
762  #define nssv_BASIC_STRING_VIEW_I(T, U) typename std::decay<basic_string_view<T, U>>::type
763  #if nssv_BETWEEN(nssv_COMPILER_MSVC_VERSION, 140, 150)
764  #define nssv_MSVC_ORDER(x) , int = x
765  #else
766  #define nssv_MSVC_ORDER(x) &bsol;*, int=x*/
767  #endif
768    template <class CharT, class Traits nssv_MSVC_ORDER(1)>
769    nssv_constexpr bool operator==(basic_string_view<CharT, Traits> lhs,
770                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
771      return lhs.compare(rhs) == 0;
772    }
773    template <class CharT, class Traits nssv_MSVC_ORDER(2)>
774    nssv_constexpr bool operator==(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
775                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
776      return lhs.size() == rhs.size() && lhs.compare(rhs) == 0;
777    }
778    template <class CharT, class Traits nssv_MSVC_ORDER(1)>
779    nssv_constexpr bool operator!=(basic_string_view<CharT, Traits> lhs,
780                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
781      return lhs.size() != rhs.size() || lhs.compare(rhs) != 0;
782    }
783    template <class CharT, class Traits nssv_MSVC_ORDER(2)>
784    nssv_constexpr bool operator!=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
785                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
786      return lhs.compare(rhs) != 0;
787    }
788    template <class CharT, class Traits nssv_MSVC_ORDER(1)>
789    nssv_constexpr bool operator<(basic_string_view<CharT, Traits> lhs,
790                                  nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
791      return lhs.compare(rhs) < 0;
792    }
793    template <class CharT, class Traits nssv_MSVC_ORDER(2)>
794    nssv_constexpr bool operator<(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
795                                  basic_string_view<CharT, Traits> rhs) nssv_noexcept {
796      return lhs.compare(rhs) < 0;
797    }
798    template <class CharT, class Traits nssv_MSVC_ORDER(1)>
799    nssv_constexpr bool operator<=(basic_string_view<CharT, Traits> lhs,
800                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
801      return lhs.compare(rhs) <= 0;
802    }
803    template <class CharT, class Traits nssv_MSVC_ORDER(2)>
804    nssv_constexpr bool operator<=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
805                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
806      return lhs.compare(rhs) <= 0;
807    }
808    template <class CharT, class Traits nssv_MSVC_ORDER(1)>
809    nssv_constexpr bool operator>(basic_string_view<CharT, Traits> lhs,
810                                  nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
811      return lhs.compare(rhs) > 0;
812    }
813    template <class CharT, class Traits nssv_MSVC_ORDER(2)>
814    nssv_constexpr bool operator>(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
815                                  basic_string_view<CharT, Traits> rhs) nssv_noexcept {
816      return lhs.compare(rhs) > 0;
817    }
818    template <class CharT, class Traits nssv_MSVC_ORDER(1)>
819    nssv_constexpr bool operator>=(basic_string_view<CharT, Traits> lhs,
820                                   nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs) nssv_noexcept {
821      return lhs.compare(rhs) >= 0;
822    }
823    template <class CharT, class Traits nssv_MSVC_ORDER(2)>
824    nssv_constexpr bool operator>=(nssv_BASIC_STRING_VIEW_I(CharT, Traits) lhs,
825                                   basic_string_view<CharT, Traits> rhs) nssv_noexcept {
826      return lhs.compare(rhs) >= 0;
827    }
828  #undef nssv_MSVC_ORDER
829  #undef nssv_BASIC_STRING_VIEW_I
830  #endif 
831    namespace detail {
832    template <class Stream> void write_padding(Stream &os, std::streamsize n) {
833      for (std::streamsize i = 0; i < n; ++i)
834        os.rdbuf()->sputc(os.fill());
835    }
836    template <class Stream, class View> Stream &write_to_stream(Stream &os, View const &sv) {
837      typename Stream::sentry sentry(os);
838      if (!os)
839        return os;
840      const std::streamsize length = static_cast<std::streamsize>(sv.length());
841      const bool pad = (length < os.width());
842      const bool left_pad = pad && (os.flags() & std::ios_base::adjustfield) == std::ios_base::right;
843      if (left_pad)
844        write_padding(os, os.width() - length);
845      os.rdbuf()->sputn(sv.begin(), length);
846      if (pad && !left_pad)
847        write_padding(os, os.width() - length);
848      os.width(0);
849      return os;
850    }
851    } 
852    template <class CharT, class Traits>
853    std::basic_ostream<CharT, Traits> &operator<<(std::basic_ostream<CharT, Traits> &os,
854                                                  basic_string_view<CharT, Traits> sv) {
855      return detail::write_to_stream(os, sv);
856    }
857    typedef basic_string_view<char> string_view;
858    typedef basic_string_view<wchar_t> wstring_view;
859  #if nssv_HAVE_WCHAR16_T
860    typedef basic_string_view<char16_t> u16string_view;
861    typedef basic_string_view<char32_t> u32string_view;
862  #endif
863    } 
864  } 
865  #if nssv_HAVE_USER_DEFINED_LITERALS
866  namespace nonstd {
867  nssv_inline_ns namespace literals {
868    nssv_inline_ns namespace string_view_literals {
869  #if nssv_CONFIG_STD_SV_OPERATOR && nssv_HAVE_STD_DEFINED_LITERALS
870      nssv_constexpr nonstd::sv_lite::string_view operator"" sv(const char *str, size_t len) nssv_noexcept 
871      {
872        return nonstd::sv_lite::string_view {str, len};
873      }
874      nssv_constexpr nonstd::sv_lite::u16string_view operator"" sv(const char16_t *str, size_t len) nssv_noexcept 
875      {
876        return nonstd::sv_lite::u16string_view {str, len};
877      }
878      nssv_constexpr nonstd::sv_lite::u32string_view operator"" sv(const char32_t *str, size_t len) nssv_noexcept 
879      {
880        return nonstd::sv_lite::u32string_view {str, len};
881      }
882      nssv_constexpr nonstd::sv_lite::wstring_view operator"" sv(const wchar_t *str, size_t len) nssv_noexcept 
883      {
884        return nonstd::sv_lite::wstring_view {str, len};
885      }
886  #endif 
887  #if nssv_CONFIG_USR_SV_OPERATOR
888      nssv_constexpr nonstd::sv_lite::string_view operator"" _sv(const char *str, size_t len) nssv_noexcept 
889      {
890        return nonstd::sv_lite::string_view {str, len};
891      }
892      nssv_constexpr nonstd::sv_lite::u16string_view operator"" _sv(const char16_t *str, size_t len) nssv_noexcept 
893      {
894        return nonstd::sv_lite::u16string_view {str, len};
895      }
896      nssv_constexpr nonstd::sv_lite::u32string_view operator"" _sv(const char32_t *str, size_t len) nssv_noexcept 
897      {
898        return nonstd::sv_lite::u32string_view {str, len};
899      }
900      nssv_constexpr nonstd::sv_lite::wstring_view operator"" _sv(const wchar_t *str, size_t len) nssv_noexcept 
901      {
902        return nonstd::sv_lite::wstring_view {str, len};
903      }
904  #endif 
905    }
906  }
907  } 
908  #endif
909  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
910  namespace nonstd {
911  namespace sv_lite {
912  #if nssv_CPP11_OR_GREATER && nssv_COMPILER_MSVC_VERSION != 140
913  template <class CharT, class Traits, class Allocator = std::allocator<CharT>>
914  std::basic_string<CharT, Traits, Allocator> to_string(basic_string_view<CharT, Traits> v,
915                                                        Allocator const &a = Allocator()) {
916    return std::basic_string<CharT, Traits, Allocator>(v.begin(), v.end(), a);
917  }
918  #else
919  template <class CharT, class Traits> std::basic_string<CharT, Traits> to_string(basic_string_view<CharT, Traits> v) {
920    return std::basic_string<CharT, Traits>(v.begin(), v.end());
921  }
922  template <class CharT, class Traits, class Allocator>
923  std::basic_string<CharT, Traits, Allocator> to_string(basic_string_view<CharT, Traits> v, Allocator const &a) {
924    return std::basic_string<CharT, Traits, Allocator>(v.begin(), v.end(), a);
925  }
926  #endif 
927  template <class CharT, class Traits, class Allocator>
928  basic_string_view<CharT, Traits> to_string_view(std::basic_string<CharT, Traits, Allocator> const &s) {
929    return basic_string_view<CharT, Traits>(s.data(), s.size());
930  }
931  } 
932  } 
933  #endif 
934  namespace nonstd {
935  using sv_lite::basic_string_view;
936  using sv_lite::string_view;
937  using sv_lite::wstring_view;
938  #if nssv_HAVE_WCHAR16_T
939  using sv_lite::u16string_view;
940  #endif
941  #if nssv_HAVE_WCHAR32_T
942  using sv_lite::u32string_view;
943  #endif
944  using sv_lite::operator==;
945  using sv_lite::operator!=;
946  using sv_lite::operator<;
947  using sv_lite::operator<=;
948  using sv_lite::operator>;
949  using sv_lite::operator>=;
950  using sv_lite::operator<<;
951  #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS
952  using sv_lite::to_string;
953  using sv_lite::to_string_view;
954  #endif
955  } 
956  #if nssv_HAVE_STD_HASH
957  #include <functional>
958  namespace std {
959  template <> struct hash<nonstd::string_view> {
960  public:
961    std::size_t operator()(nonstd::string_view v) const nssv_noexcept {
962      return std::hash<std::string>()(std::string(v.data(), v.size()));
963    }
964  };
965  template <> struct hash<nonstd::wstring_view> {
966  public:
967    std::size_t operator()(nonstd::wstring_view v) const nssv_noexcept {
968      return std::hash<std::wstring>()(std::wstring(v.data(), v.size()));
969    }
970  };
971  template <> struct hash<nonstd::u16string_view> {
972  public:
973    std::size_t operator()(nonstd::u16string_view v) const nssv_noexcept {
974      return std::hash<std::u16string>()(std::u16string(v.data(), v.size()));
975    }
976  };
977  template <> struct hash<nonstd::u32string_view> {
978  public:
979    std::size_t operator()(nonstd::u32string_view v) const nssv_noexcept {
980      return std::hash<std::u32string>()(std::u32string(v.data(), v.size()));
981    }
982  };
983  } 
984  #endif 
985  nssv_RESTORE_WARNINGS()
986  #endif 
987  #endif 
988  #ifndef INCLUDE_INJA_TEMPLATE_HPP_
989  #define INCLUDE_INJA_TEMPLATE_HPP_
990  #include <map>
991  #include <memory>
992  #include <string>
993  #include <vector>
994  #ifndef INCLUDE_INJA_NODE_HPP_
995  #define INCLUDE_INJA_NODE_HPP_
996  #include <string>
997  #include <utility>
998  #ifndef INCLUDE_INJA_FUNCTION_STORAGE_HPP_
999  #define INCLUDE_INJA_FUNCTION_STORAGE_HPP_
1000  #include <vector>
1001  namespace inja {
1002  using Arguments = std::vector<const json *>;
1003  using CallbackFunction = std::function<json(Arguments &args)>;
1004  using VoidCallbackFunction = std::function<void(Arguments &args)>;
1005  class FunctionStorage {
1006  public:
1007    enum class Operation {
1008      Not,
1009      And,
1010      Or,
1011      In,
1012      Equal,
1013      NotEqual,
1014      Greater,
1015      GreaterEqual,
1016      Less,
1017      LessEqual,
1018      Add,
1019      Subtract,
1020      Multiplication,
1021      Division,
1022      Power,
1023      Modulo,
1024      AtId,
1025      At,
1026      Default,
1027      DivisibleBy,
1028      Even,
1029      Exists,
1030      ExistsInObject,
1031      First,
1032      Float,
1033      Int,
1034      IsArray,
1035      IsBoolean,
1036      IsFloat,
1037      IsInteger,
1038      IsNumber,
1039      IsObject,
1040      IsString,
1041      Last,
1042      Length,
1043      Lower,
1044      Max,
1045      Min,
1046      Odd,
1047      Range,
1048      Round,
1049      Sort,
1050      Upper,
1051      Super,
1052      Join,
1053      Callback,
1054      ParenLeft,
1055      ParenRight,
1056      None,
1057    };
1058    struct FunctionData {
1059      explicit FunctionData(const Operation &op, const CallbackFunction &cb = CallbackFunction{}) : operation(op), callback(cb) {}
1060      const Operation operation;
1061      const CallbackFunction callback;
1062    };
1063  private:
1064    const int VARIADIC {-1};
1065    std::map<std::pair<std::string, int>, FunctionData> function_storage = {
1066      {std::make_pair("at", 2), FunctionData { Operation::At }},
1067      {std::make_pair("default", 2), FunctionData { Operation::Default }},
1068      {std::make_pair("divisibleBy", 2), FunctionData { Operation::DivisibleBy }},
1069      {std::make_pair("even", 1), FunctionData { Operation::Even }},
1070      {std::make_pair("exists", 1), FunctionData { Operation::Exists }},
1071      {std::make_pair("existsIn", 2), FunctionData { Operation::ExistsInObject }},
1072      {std::make_pair("first", 1), FunctionData { Operation::First }},
1073      {std::make_pair("float", 1), FunctionData { Operation::Float }},
1074      {std::make_pair("int", 1), FunctionData { Operation::Int }},
1075      {std::make_pair("isArray", 1), FunctionData { Operation::IsArray }},
1076      {std::make_pair("isBoolean", 1), FunctionData { Operation::IsBoolean }},
1077      {std::make_pair("isFloat", 1), FunctionData { Operation::IsFloat }},
1078      {std::make_pair("isInteger", 1), FunctionData { Operation::IsInteger }},
1079      {std::make_pair("isNumber", 1), FunctionData { Operation::IsNumber }},
1080      {std::make_pair("isObject", 1), FunctionData { Operation::IsObject }},
1081      {std::make_pair("isString", 1), FunctionData { Operation::IsString }},
1082      {std::make_pair("last", 1), FunctionData { Operation::Last }},
1083      {std::make_pair("length", 1), FunctionData { Operation::Length }},
1084      {std::make_pair("lower", 1), FunctionData { Operation::Lower }},
1085      {std::make_pair("max", 1), FunctionData { Operation::Max }},
1086      {std::make_pair("min", 1), FunctionData { Operation::Min }},
1087      {std::make_pair("odd", 1), FunctionData { Operation::Odd }},
1088      {std::make_pair("range", 1), FunctionData { Operation::Range }},
1089      {std::make_pair("round", 2), FunctionData { Operation::Round }},
1090      {std::make_pair("sort", 1), FunctionData { Operation::Sort }},
1091      {std::make_pair("upper", 1), FunctionData { Operation::Upper }},
1092      {std::make_pair("super", 0), FunctionData { Operation::Super }},
1093      {std::make_pair("super", 1), FunctionData { Operation::Super }},
1094      {std::make_pair("join", 2), FunctionData { Operation::Join }},
1095    };
1096  public:
1097    void add_builtin(nonstd::string_view name, int num_args, Operation op) {
1098      function_storage.emplace(std::make_pair(static_cast<std::string>(name), num_args), FunctionData { op });
1099    }
1100    void add_callback(nonstd::string_view name, int num_args, const CallbackFunction &callback) {
1101      function_storage.emplace(std::make_pair(static_cast<std::string>(name), num_args), FunctionData { Operation::Callback, callback });
1102    }
1103    FunctionData find_function(nonstd::string_view name, int num_args) const {
1104      auto it = function_storage.find(std::make_pair(static_cast<std::string>(name), num_args));
1105      if (it != function_storage.end()) {
1106        return it->second;
1107      } else if (num_args > 0) {
1108        it = function_storage.find(std::make_pair(static_cast<std::string>(name), VARIADIC));
1109        if (it != function_storage.end()) {
1110          return it->second;
1111        }
1112      }
1113      return FunctionData { Operation::None };
1114    }
1115  };
1116  } 
1117  #endif 
1118  #ifndef INCLUDE_INJA_UTILS_HPP_
1119  #define INCLUDE_INJA_UTILS_HPP_
1120  #include <algorithm>
1121  #include <fstream>
1122  #include <string>
1123  #include <utility>
1124  #ifndef INCLUDE_INJA_EXCEPTIONS_HPP_
1125  #define INCLUDE_INJA_EXCEPTIONS_HPP_
1126  #include <stdexcept>
1127  #include <string>
1128  namespace inja {
1129  struct SourceLocation {
1130    size_t line;
1131    size_t column;
1132  };
1133  struct InjaError : public std::runtime_error {
1134    const std::string type;
1135    const std::string message;
1136    const SourceLocation location;
1137    explicit InjaError(const std::string &type, const std::string &message)
1138        : std::runtime_error("[inja.exception." + type + "] " + message), type(type), message(message), location({0, 0}) {}
1139    explicit InjaError(const std::string &type, const std::string &message, SourceLocation location)
1140        : std::runtime_error("[inja.exception." + type + "] (at " + std::to_string(location.line) + ":" +
1141                             std::to_string(location.column) + ") " + message),
1142          type(type), message(message), location(location) {}
1143  };
1144  struct ParserError : public InjaError {
1145    explicit ParserError(const std::string &message, SourceLocation location) : InjaError("parser_error", message, location) {}
1146  };
1147  struct RenderError : public InjaError {
1148    explicit RenderError(const std::string &message, SourceLocation location) : InjaError("render_error", message, location) {}
1149  };
1150  struct FileError : public InjaError {
1151    explicit FileError(const std::string &message) : InjaError("file_error", message) {}
1152    explicit FileError(const std::string &message, SourceLocation location) : InjaError("file_error", message, location) {}
1153  };
1154  struct JsonError : public InjaError {
1155    explicit JsonError(const std::string &message, SourceLocation location) : InjaError("json_error", message, location) {}
1156  };
1157  } 
1158  #endif 
1159  namespace inja {
1160  namespace string_view {
1161  inline nonstd::string_view slice(nonstd::string_view view, size_t start, size_t end) {
1162    start = std::min(start, view.size());
1163    end = std::min(std::max(start, end), view.size());
1164    return view.substr(start, end - start);
1165  }
1166  inline std::pair<nonstd::string_view, nonstd::string_view> split(nonstd::string_view view, char Separator) {
1167    size_t idx = view.find(Separator);
1168    if (idx == nonstd::string_view::npos) {
1169      return std::make_pair(view, nonstd::string_view());
1170    }
1171    return std::make_pair(slice(view, 0, idx), slice(view, idx + 1, nonstd::string_view::npos));
1172  }
1173  inline bool starts_with(nonstd::string_view view, nonstd::string_view prefix) {
1174    return (view.size() >= prefix.size() && view.compare(0, prefix.size(), prefix) == 0);
1175  }
1176  } 
1177  inline SourceLocation get_source_location(nonstd::string_view content, size_t pos) {
1178    auto sliced = string_view::slice(content, 0, pos);
1179    std::size_t last_newline = sliced.rfind("\n");
1180    if (last_newline == nonstd::string_view::npos) {
1181      return {1, sliced.length() + 1};
1182    }
1183    size_t count_lines = 0;
1184    size_t search_start = 0;
1185    while (search_start <= sliced.size()) {
1186      search_start = sliced.find("\n", search_start) + 1;
1187      if (search_start == 0) {
1188        break;
1189      }
1190      count_lines += 1;
1191    }
1192    return {count_lines + 1, sliced.length() - last_newline};
1193  }
1194  inline void replace_substring(std::string& s, const std::string& f,
1195                                const std::string& t)
1196  {
1197    if (f.empty()) return;
1198    for (auto pos = s.find(f);                  
1199              pos != std::string::npos;         
1200              s.replace(pos, f.size(), t),      
1201              pos = s.find(f, pos + t.size()))  
1202    {}
1203  }
1204  } 
1205  #endif 
1206  namespace inja {
1207  class NodeVisitor;
1208  class BlockNode;
1209  class TextNode;
1210  class ExpressionNode;
1211  class LiteralNode;
1212  class JsonNode;
1213  class FunctionNode;
1214  class ExpressionListNode;
1215  class StatementNode;
1216  class ForStatementNode;
1217  class ForArrayStatementNode;
1218  class ForObjectStatementNode;
1219  class IfStatementNode;
1220  class IncludeStatementNode;
1221  class ExtendsStatementNode;
1222  class BlockStatementNode;
1223  class SetStatementNode;
1224  class NodeVisitor {
1225  public:
1226    virtual ~NodeVisitor() = default;
1227    virtual void visit(const BlockNode& node) = 0;
1228    virtual void visit(const TextNode& node) = 0;
1229    virtual void visit(const ExpressionNode& node) = 0;
1230    virtual void visit(const LiteralNode& node) = 0;
1231    virtual void visit(const JsonNode& node) = 0;
1232    virtual void visit(const FunctionNode& node) = 0;
1233    virtual void visit(const ExpressionListNode& node) = 0;
1234    virtual void visit(const StatementNode& node) = 0;
1235    virtual void visit(const ForStatementNode& node) = 0;
1236    virtual void visit(const ForArrayStatementNode& node) = 0;
1237    virtual void visit(const ForObjectStatementNode& node) = 0;
1238    virtual void visit(const IfStatementNode& node) = 0;
1239    virtual void visit(const IncludeStatementNode& node) = 0;
1240    virtual void visit(const ExtendsStatementNode& node) = 0;
1241    virtual void visit(const BlockStatementNode& node) = 0;
1242    virtual void visit(const SetStatementNode& node) = 0;
1243  };
1244  class AstNode {
1245  public:
1246    virtual void accept(NodeVisitor& v) const = 0;
1247    size_t pos;
1248    AstNode(size_t pos) : pos(pos) { }
1249    virtual ~AstNode() { }
1250  };
1251  class BlockNode : public AstNode {
1252  public:
1253    std::vector<std::shared_ptr<AstNode>> nodes;
1254    explicit BlockNode() : AstNode(0) {}
1255    void accept(NodeVisitor& v) const {
1256      v.visit(*this);
1257    }
1258  };
1259  class TextNode : public AstNode {
1260  public:
1261    const size_t length;
1262    explicit TextNode(size_t pos, size_t length): AstNode(pos), length(length) { }
1263    void accept(NodeVisitor& v) const {
1264      v.visit(*this);
1265    }
1266  };
1267  class ExpressionNode : public AstNode {
1268  public:
1269    explicit ExpressionNode(size_t pos) : AstNode(pos) {}
1270    void accept(NodeVisitor& v) const {
1271      v.visit(*this);
1272    }
1273  };
1274  class LiteralNode : public ExpressionNode {
1275  public:
1276    const json value;
1277    explicit LiteralNode(const json& value, size_t pos) : ExpressionNode(pos), value(value) { }
1278    void accept(NodeVisitor& v) const {
1279      v.visit(*this);
1280    }
1281  };
1282  class JsonNode : public ExpressionNode {
1283  public:
1284    const std::string name;
1285    const json::json_pointer ptr;
1286    static std::string convert_dot_to_json_ptr(nonstd::string_view ptr_name) {
1287      std::string result;
1288      do {
1289        nonstd::string_view part;
1290        std::tie(part, ptr_name) = string_view::split(ptr_name, '.');
1291        result.push_back('/');
1292        result.append(part.begin(), part.end());
1293      } while (!ptr_name.empty());
1294      return result;
1295    }
1296    explicit JsonNode(nonstd::string_view ptr_name, size_t pos) : ExpressionNode(pos), name(ptr_name), ptr(json::json_pointer(convert_dot_to_json_ptr(ptr_name))) { }
1297    void accept(NodeVisitor& v) const {
1298      v.visit(*this);
1299    }
1300  };
1301  class FunctionNode : public ExpressionNode {
1302    using Op = FunctionStorage::Operation;
1303  public:
1304    enum class Associativity {
1305      Left,
1306      Right,
1307    };
1308    unsigned int precedence;
1309    Associativity associativity;
1310    Op operation;
1311    std::string name;
1312    int number_args; 
1313    std::vector<std::shared_ptr<ExpressionNode>> arguments;
1314    CallbackFunction callback;
1315    explicit FunctionNode(nonstd::string_view name, size_t pos) : ExpressionNode(pos), precedence(8), associativity(Associativity::Left), operation(Op::Callback), name(name), number_args(1) { }
1316    explicit FunctionNode(Op operation, size_t pos) : ExpressionNode(pos), operation(operation), number_args(1) {
1317      switch (operation) {
1318        case Op::Not: {
1319          number_args = 1;
1320          precedence = 4;
1321          associativity = Associativity::Left;
1322        } break;
1323        case Op::And: {
1324          number_args = 2;
1325          precedence = 1;
1326          associativity = Associativity::Left;
1327        } break;
1328        case Op::Or: {
1329          number_args = 2;
1330          precedence = 1;
1331          associativity = Associativity::Left;
1332        } break;
1333        case Op::In: {
1334          number_args = 2;
1335          precedence = 2;
1336          associativity = Associativity::Left;
1337        } break;
1338        case Op::Equal: {
1339          number_args = 2;
1340          precedence = 2;
1341          associativity = Associativity::Left;
1342        } break;
1343        case Op::NotEqual: {
1344          number_args = 2;
1345          precedence = 2;
1346          associativity = Associativity::Left;
1347        } break;
1348        case Op::Greater: {
1349          number_args = 2;
1350          precedence = 2;
1351          associativity = Associativity::Left;
1352        } break;
1353        case Op::GreaterEqual: {
1354          number_args = 2;
1355          precedence = 2;
1356          associativity = Associativity::Left;
1357        } break;
1358        case Op::Less: {
1359          number_args = 2;
1360          precedence = 2;
1361          associativity = Associativity::Left;
1362        } break;
1363        case Op::LessEqual: {
1364          number_args = 2;
1365          precedence = 2;
1366          associativity = Associativity::Left;
1367        } break;
1368        case Op::Add: {
1369          number_args = 2;
1370          precedence = 3;
1371          associativity = Associativity::Left;
1372        } break;
1373        case Op::Subtract: {
1374          number_args = 2;
1375          precedence = 3;
1376          associativity = Associativity::Left;
1377        } break;
1378        case Op::Multiplication: {
1379          number_args = 2;
1380          precedence = 4;
1381          associativity = Associativity::Left;
1382        } break;
1383        case Op::Division: {
1384          number_args = 2;
1385          precedence = 4;
1386          associativity = Associativity::Left;
1387        } break;
1388        case Op::Power: {
1389          number_args = 2;
1390          precedence = 5;
1391          associativity = Associativity::Right;
1392        } break;
1393        case Op::Modulo: {
1394          number_args = 2;
1395          precedence = 4;
1396          associativity = Associativity::Left;
1397        } break;
1398        case Op::AtId: {
1399          number_args = 2;
1400          precedence = 8;
1401          associativity = Associativity::Left;
1402        } break;
1403        default: {
1404          precedence = 1;
1405          associativity = Associativity::Left;
1406        }
1407      }
1408    }
1409    void accept(NodeVisitor& v) const {
1410      v.visit(*this);
1411    }
1412  };
1413  class ExpressionListNode : public AstNode {
1414  public:
1415    std::shared_ptr<ExpressionNode> root;
1416    explicit ExpressionListNode() : AstNode(0) { }
1417    explicit ExpressionListNode(size_t pos) : AstNode(pos) { }
1418    void accept(NodeVisitor& v) const {
1419      v.visit(*this);
1420    }
1421  };
1422  class StatementNode : public AstNode {
1423  public:
1424    StatementNode(size_t pos) : AstNode(pos) { }
1425    virtual void accept(NodeVisitor& v) const = 0;
1426  };
1427  class ForStatementNode : public StatementNode {
1428  public:
1429    ExpressionListNode condition;
1430    BlockNode body;
1431    BlockNode *const parent;
1432    ForStatementNode(BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent) { }
1433    virtual void accept(NodeVisitor& v) const = 0;
1434  };
1435  class ForArrayStatementNode : public ForStatementNode {
1436  public:
1437    const std::string value;
1438    explicit ForArrayStatementNode(const std::string& value, BlockNode *const parent, size_t pos) : ForStatementNode(parent, pos), value(value) { }
1439    void accept(NodeVisitor& v) const {
1440      v.visit(*this);
1441    }
1442  };
1443  class ForObjectStatementNode : public ForStatementNode {
1444  public:
1445    const std::string key;
1446    const std::string value;
1447    explicit ForObjectStatementNode(const std::string& key, const std::string& value, BlockNode *const parent, size_t pos) : ForStatementNode(parent, pos), key(key), value(value) { }
1448    void accept(NodeVisitor& v) const {
1449      v.visit(*this);
1450    }
1451  };
1452  class IfStatementNode : public StatementNode {
1453  public:
1454    ExpressionListNode condition;
1455    BlockNode true_statement;
1456    BlockNode false_statement;
1457    BlockNode *const parent;
1458    const bool is_nested;
1459    bool has_false_statement {false};
1460    explicit IfStatementNode(BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent), is_nested(false) { }
1461    explicit IfStatementNode(bool is_nested, BlockNode *const parent, size_t pos) : StatementNode(pos), parent(parent), is_nested(is_nested) { }
1462    void accept(NodeVisitor& v) const {
1463      v.visit(*this);
1464    }
1465  };
1466  class IncludeStatementNode : public StatementNode {
1467  public:
1468    const std::string file;
1469    explicit IncludeStatementNode(const std::string& file, size_t pos) : StatementNode(pos), file(file) { }
1470    void accept(NodeVisitor& v) const {
1471      v.visit(*this);
1472    }
1473  };
1474  class ExtendsStatementNode : public StatementNode {
1475  public:
1476    const std::string file;
1477    explicit ExtendsStatementNode(const std::string& file, size_t pos) : StatementNode(pos), file(file) { }
1478    void accept(NodeVisitor& v) const {
1479      v.visit(*this);
1480    };
1481  };
1482  class BlockStatementNode : public StatementNode {
1483  public:
1484    const std::string name;
1485    BlockNode block;
1486    BlockNode *const parent;
1487    explicit BlockStatementNode(BlockNode *const parent, const std::string& name, size_t pos) : StatementNode(pos), name(name), parent(parent) { }
1488    void accept(NodeVisitor& v) const {
1489      v.visit(*this);
1490    };
1491  };
1492  class SetStatementNode : public StatementNode {
1493  public:
1494    const std::string key;
1495    ExpressionListNode expression;
1496    explicit SetStatementNode(const std::string& key, size_t pos) : StatementNode(pos), key(key) { }
1497    void accept(NodeVisitor& v) const {
1498      v.visit(*this);
1499    }
1500  };
1501  } 
1502  #endif 
1503  #ifndef INCLUDE_INJA_STATISTICS_HPP_
1504  #define INCLUDE_INJA_STATISTICS_HPP_
1505  namespace inja {
1506  class StatisticsVisitor : public NodeVisitor {
1507    void visit(const BlockNode& node) {
1508      for (auto& n : node.nodes) {
1509        n->accept(*this);
1510      }
1511    }
1512    void visit(const TextNode&) { }
1513    void visit(const ExpressionNode&) { }
1514    void visit(const LiteralNode&) { }
1515    void visit(const JsonNode&) {
1516      variable_counter += 1;
1517    }
1518    void visit(const FunctionNode& node) {
1519      for (auto& n : node.arguments) {
1520        n->accept(*this);
1521      }
1522    }
1523    void visit(const ExpressionListNode& node) {
1524      node.root->accept(*this);
1525    }
1526    void visit(const StatementNode&) { }
1527    void visit(const ForStatementNode&) { }
1528    void visit(const ForArrayStatementNode& node) {
1529      node.condition.accept(*this);
1530      node.body.accept(*this);
1531    }
1532    void visit(const ForObjectStatementNode& node) {
1533      node.condition.accept(*this);
1534      node.body.accept(*this);
1535    }
1536    void visit(const IfStatementNode& node) {
1537      node.condition.accept(*this);
1538      node.true_statement.accept(*this);
1539      node.false_statement.accept(*this);
1540    }
1541    void visit(const IncludeStatementNode&) { }
1542    void visit(const ExtendsStatementNode&) { }
1543    void visit(const BlockStatementNode& node) {
1544      node.block.accept(*this);
1545    }
1546    void visit(const SetStatementNode&) { }
1547  public:
1548    unsigned int variable_counter;
1549    explicit StatisticsVisitor() : variable_counter(0) { }
1550  };
1551  } 
1552  #endif 
1553  namespace inja {
1554  struct Template {
1555    BlockNode root;
1556    std::string content;
1557    std::map<std::string, std::shared_ptr<BlockStatementNode>> block_storage;
1558    explicit Template() { }
1559    explicit Template(const std::string& content): content(content) { }
1560    int count_variables() {
1561      auto statistic_visitor = StatisticsVisitor();
1562      root.accept(statistic_visitor);
1563      return statistic_visitor.variable_counter;
1564    }
1565  };
1566  using TemplateStorage = std::map<std::string, Template>;
1567  } 
1568  #endif 
1569  namespace inja {
1570  struct LexerConfig {
1571    std::string statement_open {"{%"};
1572    std::string statement_open_no_lstrip {"{%+"};
1573    std::string statement_open_force_lstrip {"{%-"};
1574    std::string statement_close {"%}"};
1575    std::string statement_close_force_rstrip {"-%}"};
1576    std::string line_statement {"##"};
1577    std::string expression_open {"{{"};
1578    std::string expression_open_force_lstrip {"{{-"};
1579    std::string expression_close {"}}"};
1580    std::string expression_close_force_rstrip {"-}}"};
1581    std::string comment_open {"{#"};
1582    std::string comment_open_force_lstrip {"{#-"};
1583    std::string comment_close {"#}"};
1584    std::string comment_close_force_rstrip {"-#}"};
1585    std::string open_chars {"#{"};
1586    bool trim_blocks {false};
1587    bool lstrip_blocks {false};
1588    void update_open_chars() {
1589      open_chars = "";
1590      if (open_chars.find(line_statement[0]) == std::string::npos) {
1591        open_chars += line_statement[0];
1592      }
1593      if (open_chars.find(statement_open[0]) == std::string::npos) {
1594        open_chars += statement_open[0];
1595      }
1596      if (open_chars.find(statement_open_no_lstrip[0]) == std::string::npos) {
1597        open_chars += statement_open_no_lstrip[0];
1598      }
1599      if (open_chars.find(statement_open_force_lstrip[0]) == std::string::npos) {
1600        open_chars += statement_open_force_lstrip[0];
1601      }
1602      if (open_chars.find(expression_open[0]) == std::string::npos) {
1603        open_chars += expression_open[0];
1604      }
1605      if (open_chars.find(expression_open_force_lstrip[0]) == std::string::npos) {
1606        open_chars += expression_open_force_lstrip[0];
1607      }
1608      if (open_chars.find(comment_open[0]) == std::string::npos) {
1609        open_chars += comment_open[0];
1610      }
1611      if (open_chars.find(comment_open_force_lstrip[0]) == std::string::npos) {
1612        open_chars += comment_open_force_lstrip[0];
1613      }
1614    }
1615  };
1616  struct ParserConfig {
1617    bool search_included_templates_in_files {true};
1618    std::function<Template(const std::string&, const std::string&)> include_callback;
1619  };
1620  struct RenderConfig {
1621    bool throw_at_missing_includes {true};
1622  };
1623  } 
1624  #endif 
1625  #ifndef INCLUDE_INJA_PARSER_HPP_
1626  #define INCLUDE_INJA_PARSER_HPP_
1627  #include <limits>
1628  #include <stack>
1629  #include <string>
1630  #include <utility>
1631  #include <queue>
1632  #include <vector>
1633  #ifndef INCLUDE_INJA_LEXER_HPP_
1634  #define INCLUDE_INJA_LEXER_HPP_
1635  #include <cctype>
1636  #include <locale>
1637  #ifndef INCLUDE_INJA_TOKEN_HPP_
1638  #define INCLUDE_INJA_TOKEN_HPP_
1639  #include <string>
1640  namespace inja {
1641  struct Token {
1642    enum class Kind {
1643      Text,
1644      ExpressionOpen,     
1645      ExpressionClose,    
1646      LineStatementOpen,  
1647      LineStatementClose, 
1648      StatementOpen,      
1649      StatementClose,     
1650      CommentOpen,        
1651      CommentClose,       
1652      Id,                 
1653      Number,             
1654      String,             
1655      Plus,               
1656      Minus,              
1657      Times,              
1658      Slash,              
1659      Percent,            
1660      Power,              
1661      Comma,              
1662      Dot,                
1663      Colon,              
1664      LeftParen,          
1665      RightParen,         
1666      LeftBracket,        
1667      RightBracket,       
1668      LeftBrace,          
1669      RightBrace,         
1670      Equal,              
1671      NotEqual,           
1672      GreaterThan,        
1673      GreaterEqual,       
1674      LessThan,           
1675      LessEqual,          
1676      Unknown,
1677      Eof,
1678    };
1679    Kind kind {Kind::Unknown};
1680    nonstd::string_view text;
1681    explicit constexpr Token() = default;
1682    explicit constexpr Token(Kind kind, nonstd::string_view text) : kind(kind), text(text) {}
1683    std::string describe() const {
1684      switch (kind) {
1685      case Kind::Text:
1686        return "<text>";
1687      case Kind::LineStatementClose:
1688        return "<eol>";
1689      case Kind::Eof:
1690        return "<eof>";
1691      default:
1692        return static_cast<std::string>(text);
1693      }
1694    }
1695  };
1696  } 
1697  #endif 
1698  namespace inja {
1699  class Lexer {
1700    enum class State {
1701      Text,
1702      ExpressionStart,
1703      ExpressionStartForceLstrip,
1704      ExpressionBody,
1705      LineStart,
1706      LineBody,
1707      StatementStart,
1708      StatementStartNoLstrip,
1709      StatementStartForceLstrip,
1710      StatementBody,
1711      CommentStart,
1712      CommentStartForceLstrip,
1713      CommentBody,
1714    };
1715    enum class MinusState {
1716      Operator,
1717      Number,
1718    };
1719    const LexerConfig &config;
1720    State state;
1721    MinusState minus_state;
1722    nonstd::string_view m_in;
1723    size_t tok_start;
1724    size_t pos;
1725    Token scan_body(nonstd::string_view close, Token::Kind closeKind, nonstd::string_view close_trim = nonstd::string_view(), bool trim = false) {
1726    again:
1727      if (tok_start >= m_in.size()) {
1728        return make_token(Token::Kind::Eof);
1729      }
1730      const char ch = m_in[tok_start];
1731      if (ch == ' ' || ch == '\t' || ch == '\r') {
1732        tok_start += 1;
1733        goto again;
1734      }
1735      if (!close_trim.empty() && inja::string_view::starts_with(m_in.substr(tok_start), close_trim)) {
1736        state = State::Text;
1737        pos = tok_start + close_trim.size();
1738        const Token tok = make_token(closeKind);
1739        skip_whitespaces_and_newlines();
1740        return tok;
1741      }
1742      if (inja::string_view::starts_with(m_in.substr(tok_start), close)) {
1743        state = State::Text;
1744        pos = tok_start + close.size();
1745        const Token tok = make_token(closeKind);
1746        if (trim) {
1747          skip_whitespaces_and_first_newline();
1748        }
1749        return tok;
1750      }
1751      if (ch == '\n') {
1752        tok_start += 1;
1753        goto again;
1754      }
1755      pos = tok_start + 1;
1756      if (std::isalpha(ch)) {
1757        minus_state = MinusState::Operator;
1758        return scan_id();
1759      }
1760      const MinusState current_minus_state = minus_state;
1761      if (minus_state == MinusState::Operator) {
1762        minus_state = MinusState::Number;
1763      }
1764      switch (ch) {
1765      case '+':
1766        return make_token(Token::Kind::Plus);
1767      case '-':
1768        if (current_minus_state == MinusState::Operator) {
1769          return make_token(Token::Kind::Minus);
1770        }
1771        return scan_number();
1772      case '*':
1773        return make_token(Token::Kind::Times);
1774      case '/':
1775        return make_token(Token::Kind::Slash);
1776      case '^':
1777        return make_token(Token::Kind::Power);
1778      case '%':
1779        return make_token(Token::Kind::Percent);
1780      case '.':
1781        return make_token(Token::Kind::Dot);
1782      case ',':
1783        return make_token(Token::Kind::Comma);
1784      case ':':
1785        return make_token(Token::Kind::Colon);
1786      case '(':
1787        return make_token(Token::Kind::LeftParen);
1788      case ')':
1789        minus_state = MinusState::Operator;
1790        return make_token(Token::Kind::RightParen);
1791      case '[':
1792        return make_token(Token::Kind::LeftBracket);
1793      case ']':
1794        minus_state = MinusState::Operator;
1795        return make_token(Token::Kind::RightBracket);
1796      case '{':
1797        return make_token(Token::Kind::LeftBrace);
1798      case '}':
1799        minus_state = MinusState::Operator;
1800        return make_token(Token::Kind::RightBrace);
1801      case '>':
1802        if (pos < m_in.size() && m_in[pos] == '=') {
1803          pos += 1;
1804          return make_token(Token::Kind::GreaterEqual);
1805        }
1806        return make_token(Token::Kind::GreaterThan);
1807      case '<':
1808        if (pos < m_in.size() && m_in[pos] == '=') {
1809          pos += 1;
1810          return make_token(Token::Kind::LessEqual);
1811        }
1812        return make_token(Token::Kind::LessThan);
1813      case '=':
1814        if (pos < m_in.size() && m_in[pos] == '=') {
1815          pos += 1;
1816          return make_token(Token::Kind::Equal);
1817        }
1818        return make_token(Token::Kind::Unknown);
1819      case '!':
1820        if (pos < m_in.size() && m_in[pos] == '=') {
1821          pos += 1;
1822          return make_token(Token::Kind::NotEqual);
1823        }
1824        return make_token(Token::Kind::Unknown);
1825      case '\"':
1826        return scan_string();
1827      case '0':
1828      case '1':
1829      case '2':
1830      case '3':
1831      case '4':
1832      case '5':
1833      case '6':
1834      case '7':
1835      case '8':
1836      case '9':
1837        minus_state = MinusState::Operator;
1838        return scan_number();
1839      case '_':
1840      case '@':
1841      case '$':
1842        minus_state = MinusState::Operator;
1843        return scan_id();
1844      default:
1845        return make_token(Token::Kind::Unknown);
1846      }
1847    }
1848    Token scan_id() {
1849      for (;;) {
1850        if (pos >= m_in.size()) {
1851          break;
1852        }
1853        const char ch = m_in[pos];
1854        if (!std::isalnum(ch) && ch != '.' && ch != '/' && ch != '_' && ch != '-') {
1855          break;
1856        }
1857        pos += 1;
1858      }
1859      return make_token(Token::Kind::Id);
1860    }
1861    Token scan_number() {
1862      for (;;) {
1863        if (pos >= m_in.size()) {
1864          break;
1865        }
1866        const char ch = m_in[pos];
1867        if (!std::isdigit(ch) && ch != '.' && ch != 'e' && ch != 'E' && ch != '+' && ch != '-') {
1868          break;
1869        }
1870        pos += 1;
1871      }
1872      return make_token(Token::Kind::Number);
1873    }
1874    Token scan_string() {
1875      bool escape {false};
1876      for (;;) {
1877        if (pos >= m_in.size()) {
1878          break;
1879        }
1880        const char ch = m_in[pos++];
1881        if (ch == '\\') {
1882          escape = true;
1883        } else if (!escape && ch == m_in[tok_start]) {
1884          break;
1885        } else {
1886          escape = false;
1887        }
1888      }
1889      return make_token(Token::Kind::String);
1890    }
1891    Token make_token(Token::Kind kind) const { return Token(kind, string_view::slice(m_in, tok_start, pos)); }
1892    void skip_whitespaces_and_newlines() {
1893      if (pos < m_in.size()) {
1894        while (pos < m_in.size() && (m_in[pos] == ' ' || m_in[pos] == '\t' || m_in[pos] == '\n' || m_in[pos] == '\r')) {
1895          pos += 1;
1896        }
1897      }
1898    }
1899    void skip_whitespaces_and_first_newline() {
1900      if (pos < m_in.size()) {
1901        while (pos < m_in.size() && (m_in[pos] == ' ' || m_in[pos] == '\t')) {
1902          pos += 1;
1903        }
1904      }
1905      if (pos < m_in.size()) {
1906        const char ch = m_in[pos];
1907        if (ch == '\n') {
1908          pos += 1;
1909        } else if (ch == '\r') {
1910          pos += 1;
1911          if (pos < m_in.size() && m_in[pos] == '\n') {
1912            pos += 1;
1913          }
1914        }
1915      }
1916    }
1917    static nonstd::string_view clear_final_line_if_whitespace(nonstd::string_view text) {
1918      nonstd::string_view result = text;
1919      while (!result.empty()) {
1920        const char ch = result.back();
1921        if (ch == ' ' || ch == '\t') {
1922          result.remove_suffix(1);
1923        } else if (ch == '\n' || ch == '\r') {
1924          break;
1925        } else {
1926          return text;
1927        }
1928      }
1929      return result;
1930    }
1931  public:
1932    explicit Lexer(const LexerConfig &config) : config(config), state(State::Text), minus_state(MinusState::Number) {}
1933    SourceLocation current_position() const {
1934      return get_source_location(m_in, tok_start);
1935    }
1936    void start(nonstd::string_view input) {
1937      m_in = input;
1938      tok_start = 0;
1939      pos = 0;
1940      state = State::Text;
1941      minus_state = MinusState::Number;
1942      if (inja::string_view::starts_with(m_in, "\xEF\xBB\xBF")) {
1943        m_in = m_in.substr(3);
1944      }
1945    }
1946    Token scan() {
1947      tok_start = pos;
1948    again:
1949      if (tok_start >= m_in.size()) {
1950        return make_token(Token::Kind::Eof);
1951      }
1952      switch (state) {
1953      default:
1954      case State::Text: {
1955        const size_t open_start = m_in.substr(pos).find_first_of(config.open_chars);
1956        if (open_start == nonstd::string_view::npos) {
1957          pos = m_in.size();
1958          return make_token(Token::Kind::Text);
1959        }
1960        pos += open_start;
1961        nonstd::string_view open_str = m_in.substr(pos);
1962        bool must_lstrip = false;
1963        if (inja::string_view::starts_with(open_str, config.expression_open)) {
1964          if (inja::string_view::starts_with(open_str, config.expression_open_force_lstrip)) {
1965            state = State::ExpressionStartForceLstrip;
1966            must_lstrip = true;
1967          } else {
1968            state = State::ExpressionStart;
1969          }
1970        } else if (inja::string_view::starts_with(open_str, config.statement_open)) {
1971          if (inja::string_view::starts_with(open_str, config.statement_open_no_lstrip)) {
1972            state = State::StatementStartNoLstrip;
1973          } else if (inja::string_view::starts_with(open_str, config.statement_open_force_lstrip )) {
1974            state = State::StatementStartForceLstrip;
1975            must_lstrip = true;
1976          } else {
1977            state = State::StatementStart;
1978            must_lstrip = config.lstrip_blocks;
1979          }
1980        } else if (inja::string_view::starts_with(open_str, config.comment_open)) {
1981          if (inja::string_view::starts_with(open_str, config.comment_open_force_lstrip)) {
1982            state = State::CommentStartForceLstrip;
1983            must_lstrip = true;
1984          } else {
1985            state = State::CommentStart;
1986            must_lstrip = config.lstrip_blocks;
1987          }
1988        } else if ((pos == 0 || m_in[pos - 1] == '\n') && inja::string_view::starts_with(open_str, config.line_statement)) {
1989          state = State::LineStart;
1990        } else {
1991          pos += 1; 
1992          goto again;
1993        }
1994        nonstd::string_view text = string_view::slice(m_in, tok_start, pos);
1995        if (must_lstrip) {
1996          text = clear_final_line_if_whitespace(text);
1997        }
1998        if (text.empty()) {
1999          goto again; 
2000        }
2001        return Token(Token::Kind::Text, text);
2002      }
2003      case State::ExpressionStart: {
2004        state = State::ExpressionBody;
2005        pos += config.expression_open.size();
2006        return make_token(Token::Kind::ExpressionOpen);
2007      }
2008      case State::ExpressionStartForceLstrip: {
2009        state = State::ExpressionBody;
2010        pos += config.expression_open_force_lstrip.size();
2011        return make_token(Token::Kind::ExpressionOpen);
2012      }
2013      case State::LineStart: {
2014        state = State::LineBody;
2015        pos += config.line_statement.size();
2016        return make_token(Token::Kind::LineStatementOpen);
2017      }
2018      case State::StatementStart: {
2019        state = State::StatementBody;
2020        pos += config.statement_open.size();
2021        return make_token(Token::Kind::StatementOpen);
2022      }
2023      case State::StatementStartNoLstrip: {
2024        state = State::StatementBody;
2025        pos += config.statement_open_no_lstrip.size();
2026        return make_token(Token::Kind::StatementOpen);
2027      }
2028      case State::StatementStartForceLstrip: {
2029        state = State::StatementBody;
2030        pos += config.statement_open_force_lstrip.size();
2031        return make_token(Token::Kind::StatementOpen);
2032      }
2033      case State::CommentStart: {
2034        state = State::CommentBody;
2035        pos += config.comment_open.size();
2036        return make_token(Token::Kind::CommentOpen);
2037      }
2038      case State::CommentStartForceLstrip: {
2039        state = State::CommentBody;
2040        pos += config.comment_open_force_lstrip.size();
2041        return make_token(Token::Kind::CommentOpen);
2042      }
2043      case State::ExpressionBody:
2044        return scan_body(config.expression_close, Token::Kind::ExpressionClose, config.expression_close_force_rstrip);
2045      case State::LineBody:
2046        return scan_body("\n", Token::Kind::LineStatementClose);
2047      case State::StatementBody:
2048        return scan_body(config.statement_close, Token::Kind::StatementClose, config.statement_close_force_rstrip, config.trim_blocks);
2049      case State::CommentBody: {
2050        const size_t end = m_in.substr(pos).find(config.comment_close);
2051        if (end == nonstd::string_view::npos) {
2052          pos = m_in.size();
2053          return make_token(Token::Kind::Eof);
2054        }
2055        const bool must_rstrip = inja::string_view::starts_with(m_in.substr(pos + end - 1), config.comment_close_force_rstrip);
2056        state = State::Text;
2057        pos += end + config.comment_close.size();
2058        Token tok = make_token(Token::Kind::CommentClose);
2059        if (must_rstrip || config.trim_blocks) {
2060          skip_whitespaces_and_first_newline();
2061        }
2062        return tok;
2063      }
2064      }
2065    }
2066    const LexerConfig &get_config() const {
2067      return config;
2068    }
2069  };
2070  } 
2071  #endif 
2072  namespace inja {
2073  class Parser {
2074    const ParserConfig &config;
2075    Lexer lexer;
2076    TemplateStorage &template_storage;
2077    const FunctionStorage &function_storage;
2078    Token tok, peek_tok;
2079    bool have_peek_tok {false};
2080    size_t current_paren_level {0};
2081    size_t current_bracket_level {0};
2082    size_t current_brace_level {0};
2083    nonstd::string_view json_literal_start;
2084    BlockNode *current_block {nullptr};
2085    ExpressionListNode *current_expression_list {nullptr};
2086    std::stack<std::pair<FunctionNode*, size_t>> function_stack;
2087    std::vector<std::shared_ptr<ExpressionNode>> arguments;
2088    std::stack<std::shared_ptr<FunctionNode>> operator_stack;
2089    std::stack<IfStatementNode*> if_statement_stack;
2090    std::stack<ForStatementNode*> for_statement_stack;
2091    std::stack<BlockStatementNode*> block_statement_stack;
2092    inline void throw_parser_error(const std::string &message) {
2093      INJA_THROW(ParserError(message, lexer.current_position()));
2094    }
2095    inline void get_next_token() {
2096      if (have_peek_tok) {
2097        tok = peek_tok;
2098        have_peek_tok = false;
2099      } else {
2100        tok = lexer.scan();
2101      }
2102    }
2103    inline void get_peek_token() {
2104      if (!have_peek_tok) {
2105        peek_tok = lexer.scan();
2106        have_peek_tok = true;
2107      }
2108    }
2109    inline void add_json_literal(const char* content_ptr) {
2110      nonstd::string_view json_text(json_literal_start.data(), tok.text.data() - json_literal_start.data() + tok.text.size());
2111      arguments.emplace_back(std::make_shared<LiteralNode>(json::parse(json_text), json_text.data() - content_ptr));
2112    }
2113    inline void add_operator() {
2114      auto function = operator_stack.top();
2115      operator_stack.pop();
2116      for (int i = 0; i < function->number_args; ++i) {
2117        function->arguments.insert(function->arguments.begin(), arguments.back());
2118        arguments.pop_back();
2119      }
2120      arguments.emplace_back(function);
2121    }
2122    void add_to_template_storage(nonstd::string_view path, std::string& template_name) {
2123      if (template_storage.find(template_name) != template_storage.end()) {
2124        return;
2125      }
2126      std::string original_path = static_cast<std::string>(path);
2127      std::string original_name = template_name;
2128      if (config.search_included_templates_in_files) {
2129        template_name = original_path + original_name;
2130        if (template_name.compare(0, 2, "./") == 0) {
2131          template_name.erase(0, 2);
2132        }
2133        if (template_storage.find(template_name) == template_storage.end()) {
2134          std::ifstream file;
2135          file.open(template_name);
2136          if (!file.fail()) {
2137            std::string text((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
2138            auto include_template = Template(text);
2139            template_storage.emplace(template_name, include_template);
2140            parse_into_template(template_storage[template_name], template_name);
2141            return;
2142          } else if (!config.include_callback) {
2143            INJA_THROW(FileError("failed accessing file at '" + template_name + "'"));
2144          }
2145        }
2146      }
2147      if (config.include_callback) {
2148        auto include_template = config.include_callback(original_path, original_name);
2149        template_storage.emplace(template_name, include_template);
2150      }
2151    }
2152    bool parse_expression(Template &tmpl, Token::Kind closing) {
2153      while (tok.kind != closing && tok.kind != Token::Kind::Eof) {
2154        switch (tok.kind) {
2155        case Token::Kind::String: {
2156          if (current_brace_level == 0 && current_bracket_level == 0) {
2157            json_literal_start = tok.text;
2158            add_json_literal(tmpl.content.c_str());
2159          }
2160        } break;
2161        case Token::Kind::Number: {
2162          if (current_brace_level == 0 && current_bracket_level == 0) {
2163            json_literal_start = tok.text;
2164            add_json_literal(tmpl.content.c_str());
2165          }
2166        } break;
2167        case Token::Kind::LeftBracket: {
2168          if (current_brace_level == 0 && current_bracket_level == 0) {
2169            json_literal_start = tok.text;
2170          }
2171          current_bracket_level += 1;
2172        } break;
2173        case Token::Kind::LeftBrace: {
2174          if (current_brace_level == 0 && current_bracket_level == 0) {
2175            json_literal_start = tok.text;
2176          }
2177          current_brace_level += 1;
2178        } break;
2179        case Token::Kind::RightBracket: {
2180          if (current_bracket_level == 0) {
2181            throw_parser_error("unexpected ']'");
2182          }
2183          current_bracket_level -= 1;
2184          if (current_brace_level == 0 && current_bracket_level == 0) {
2185            add_json_literal(tmpl.content.c_str());
2186          }
2187        } break;
2188        case Token::Kind::RightBrace: {
2189          if (current_brace_level == 0) {
2190            throw_parser_error("unexpected '}'");
2191          }
2192          current_brace_level -= 1;
2193          if (current_brace_level == 0 && current_bracket_level == 0) {
2194            add_json_literal(tmpl.content.c_str());
2195          }
2196        } break;
2197        case Token::Kind::Id: {
2198          get_peek_token();
2199          if (tok.text == static_cast<decltype(tok.text)>("true") || tok.text == static_cast<decltype(tok.text)>("false") || tok.text == static_cast<decltype(tok.text)>("null")) {
2200            if (current_brace_level == 0 && current_bracket_level == 0) {
2201              json_literal_start = tok.text;
2202              add_json_literal(tmpl.content.c_str());
2203            }
2204          } else if (tok.text == "and" || tok.text == "or" || tok.text == "in" || tok.text == "not") {
2205            goto parse_operator;
2206          } else if (peek_tok.kind == Token::Kind::LeftParen) {
2207            operator_stack.emplace(std::make_shared<FunctionNode>(static_cast<std::string>(tok.text), tok.text.data() - tmpl.content.c_str()));
2208            function_stack.emplace(operator_stack.top().get(), current_paren_level);       
2209          } else {
2210            arguments.emplace_back(std::make_shared<JsonNode>(static_cast<std::string>(tok.text), tok.text.data() - tmpl.content.c_str()));
2211          }
2212        } break;
2213        case Token::Kind::Equal:
2214        case Token::Kind::NotEqual:
2215        case Token::Kind::GreaterThan:
2216        case Token::Kind::GreaterEqual:
2217        case Token::Kind::LessThan:
2218        case Token::Kind::LessEqual:
2219        case Token::Kind::Plus:
2220        case Token::Kind::Minus:
2221        case Token::Kind::Times:
2222        case Token::Kind::Slash:
2223        case Token::Kind::Power:
2224        case Token::Kind::Percent:
2225        case Token::Kind::Dot: {
2226    parse_operator:
2227          FunctionStorage::Operation operation;
2228          switch (tok.kind) {
2229          case Token::Kind::Id: {
2230            if (tok.text == "and") {
2231              operation = FunctionStorage::Operation::And;
2232            } else if (tok.text == "or") {
2233              operation = FunctionStorage::Operation::Or;
2234            } else if (tok.text == "in") {
2235              operation = FunctionStorage::Operation::In;
2236            } else if (tok.text == "not") {
2237              operation = FunctionStorage::Operation::Not;
2238            } else {
2239              throw_parser_error("unknown operator in parser.");
2240            }
2241          } break;
2242          case Token::Kind::Equal: {
2243            operation = FunctionStorage::Operation::Equal;
2244          } break;
2245          case Token::Kind::NotEqual: {
2246            operation = FunctionStorage::Operation::NotEqual;
2247          } break;
2248          case Token::Kind::GreaterThan: {
2249            operation = FunctionStorage::Operation::Greater;
2250          } break;
2251          case Token::Kind::GreaterEqual: {
2252            operation = FunctionStorage::Operation::GreaterEqual;
2253          } break;
2254          case Token::Kind::LessThan: {
2255            operation = FunctionStorage::Operation::Less;
2256          } break;
2257          case Token::Kind::LessEqual: {
2258            operation = FunctionStorage::Operation::LessEqual;
2259          } break;
2260          case Token::Kind::Plus: {
2261            operation = FunctionStorage::Operation::Add;
2262          } break;
2263          case Token::Kind::Minus: {
2264            operation = FunctionStorage::Operation::Subtract;
2265          } break;
2266          case Token::Kind::Times: {
2267            operation = FunctionStorage::Operation::Multiplication;
2268          } break;
2269          case Token::Kind::Slash: {
2270            operation = FunctionStorage::Operation::Division;
2271          } break;
2272          case Token::Kind::Power: {
2273            operation = FunctionStorage::Operation::Power;
2274          } break;
2275          case Token::Kind::Percent: {
2276            operation = FunctionStorage::Operation::Modulo;
2277          } break;
2278          case Token::Kind::Dot: {
2279            operation = FunctionStorage::Operation::AtId;
2280          } break;
2281          default: {
2282            throw_parser_error("unknown operator in parser.");
2283          }
2284          }
2285          auto function_node = std::make_shared<FunctionNode>(operation, tok.text.data() - tmpl.content.c_str());
2286          while (!operator_stack.empty() && ((operator_stack.top()->precedence > function_node->precedence) || (operator_stack.top()->precedence == function_node->precedence && function_node->associativity == FunctionNode::Associativity::Left)) && (operator_stack.top()->operation != FunctionStorage::Operation::ParenLeft)) {
2287            add_operator();
2288          }
2289          operator_stack.emplace(function_node);
2290        } break;
2291        case Token::Kind::Comma: {
2292          if (current_brace_level == 0 && current_bracket_level == 0) {
2293            if (function_stack.empty()) {
2294              throw_parser_error("unexpected ','");
2295            }
2296            function_stack.top().first->number_args += 1;
2297          }
2298        } break;
2299        case Token::Kind::Colon: {
2300          if (current_brace_level == 0 && current_bracket_level == 0) {
2301            throw_parser_error("unexpected ':'");
2302          }
2303        } break;
2304        case Token::Kind::LeftParen: {
2305          current_paren_level += 1;
2306          operator_stack.emplace(std::make_shared<FunctionNode>(FunctionStorage::Operation::ParenLeft, tok.text.data() - tmpl.content.c_str()));
2307          get_peek_token();
2308          if (peek_tok.kind == Token::Kind::RightParen) {
2309            if (!function_stack.empty() && function_stack.top().second == current_paren_level - 1) {
2310              function_stack.top().first->number_args = 0;
2311            }
2312          }
2313        } break;
2314        case Token::Kind::RightParen: {
2315          current_paren_level -= 1;
2316          while (!operator_stack.empty() && operator_stack.top()->operation != FunctionStorage::Operation::ParenLeft) {
2317            add_operator();
2318          }
2319          if (!operator_stack.empty() && operator_stack.top()->operation == FunctionStorage::Operation::ParenLeft) {
2320            operator_stack.pop();
2321          }
2322          if (!function_stack.empty() && function_stack.top().second == current_paren_level) {
2323            auto func = function_stack.top().first;
2324            auto function_data = function_storage.find_function(func->name, func->number_args);
2325            if (function_data.operation == FunctionStorage::Operation::None) {
2326              throw_parser_error("unknown function " + func->name);
2327            }
2328            func->operation = function_data.operation;
2329            if (function_data.operation == FunctionStorage::Operation::Callback) {
2330              func->callback = function_data.callback;
2331            }
2332            if (operator_stack.empty()) {
2333              throw_parser_error("internal error at function " + func->name);
2334            }
2335            add_operator();
2336            function_stack.pop();
2337          }
2338        }
2339        default:
2340          break;
2341        }
2342        get_next_token();
2343      }
2344      while (!operator_stack.empty()) {
2345        add_operator();
2346      }
2347      if (arguments.size() == 1) {
2348        current_expression_list->root = arguments[0];
2349        arguments = {};
2350      } else if (arguments.size() > 1) {
2351        throw_parser_error("malformed expression");
2352      }
2353      return true;
2354    }
2355    bool parse_statement(Template &tmpl, Token::Kind closing, nonstd::string_view path) {
2356      if (tok.kind != Token::Kind::Id) {
2357        return false;
2358      }
2359      if (tok.text == static_cast<decltype(tok.text)>("if")) {
2360        get_next_token();
2361        auto if_statement_node = std::make_shared<IfStatementNode>(current_block, tok.text.data() - tmpl.content.c_str());
2362        current_block->nodes.emplace_back(if_statement_node);
2363        if_statement_stack.emplace(if_statement_node.get());
2364        current_block = &if_statement_node->true_statement;
2365        current_expression_list = &if_statement_node->condition;
2366        if (!parse_expression(tmpl, closing)) {
2367          return false;
2368        }
2369      } else if (tok.text == static_cast<decltype(tok.text)>("else")) {
2370        if (if_statement_stack.empty()) {
2371          throw_parser_error("else without matching if");
2372        }
2373        auto &if_statement_data = if_statement_stack.top();
2374        get_next_token();
2375        if_statement_data->has_false_statement = true;
2376        current_block = &if_statement_data->false_statement;
2377        if (tok.kind == Token::Kind::Id && tok.text == static_cast<decltype(tok.text)>("if")) {
2378          get_next_token();
2379          auto if_statement_node = std::make_shared<IfStatementNode>(true, current_block, tok.text.data() - tmpl.content.c_str());
2380          current_block->nodes.emplace_back(if_statement_node);
2381          if_statement_stack.emplace(if_statement_node.get());
2382          current_block = &if_statement_node->true_statement;
2383          current_expression_list = &if_statement_node->condition;
2384          if (!parse_expression(tmpl, closing)) {
2385            return false;
2386          }
2387        }
2388      } else if (tok.text == static_cast<decltype(tok.text)>("endif")) {
2389        if (if_statement_stack.empty()) {
2390          throw_parser_error("endif without matching if");
2391        }
2392        while (if_statement_stack.top()->is_nested) {
2393          if_statement_stack.pop();
2394        }
2395        auto &if_statement_data = if_statement_stack.top();
2396        get_next_token();
2397        current_block = if_statement_data->parent;
2398        if_statement_stack.pop();
2399      } else if (tok.text == static_cast<decltype(tok.text)>("block")) {
2400        get_next_token();
2401        if (tok.kind != Token::Kind::Id) {
2402          throw_parser_error("expected block name, got '" + tok.describe() + "'");
2403        }
2404        const std::string block_name = static_cast<std::string>(tok.text);
2405        auto block_statement_node = std::make_shared<BlockStatementNode>(current_block, block_name, tok.text.data() - tmpl.content.c_str());
2406        current_block->nodes.emplace_back(block_statement_node);
2407        block_statement_stack.emplace(block_statement_node.get());
2408        current_block = &block_statement_node->block;
2409        auto success = tmpl.block_storage.emplace(block_name, block_statement_node);
2410        if (!success.second) {
2411          throw_parser_error("block with the name '" + block_name + "' does already exist");
2412        }
2413        get_next_token();
2414      } else if (tok.text == static_cast<decltype(tok.text)>("endblock")) {
2415        if (block_statement_stack.empty()) {
2416          throw_parser_error("endblock without matching block");
2417        }
2418        auto &block_statement_data = block_statement_stack.top();
2419        get_next_token();
2420        current_block = block_statement_data->parent;
2421        block_statement_stack.pop();
2422      } else if (tok.text == static_cast<decltype(tok.text)>("for")) {
2423        get_next_token();
2424        if (tok.kind != Token::Kind::Id) {
2425          throw_parser_error("expected id, got '" + tok.describe() + "'");
2426        }
2427        Token value_token = tok;
2428        get_next_token();
2429        std::shared_ptr<ForStatementNode> for_statement_node;
2430        if (tok.kind == Token::Kind::Comma) {
2431          get_next_token();
2432          if (tok.kind != Token::Kind::Id) {
2433            throw_parser_error("expected id, got '" + tok.describe() + "'");
2434          }
2435          Token key_token = std::move(value_token);
2436          value_token = tok;
2437          get_next_token();
2438          for_statement_node = std::make_shared<ForObjectStatementNode>(static_cast<std::string>(key_token.text), static_cast<std::string>(value_token.text), current_block, tok.text.data() - tmpl.content.c_str());
2439        } else {
2440          for_statement_node = std::make_shared<ForArrayStatementNode>(static_cast<std::string>(value_token.text), current_block, tok.text.data() - tmpl.content.c_str());
2441        }
2442        current_block->nodes.emplace_back(for_statement_node);
2443        for_statement_stack.emplace(for_statement_node.get());
2444        current_block = &for_statement_node->body;
2445        current_expression_list = &for_statement_node->condition;
2446        if (tok.kind != Token::Kind::Id || tok.text != static_cast<decltype(tok.text)>("in")) {
2447          throw_parser_error("expected 'in', got '" + tok.describe() + "'");
2448        }
2449        get_next_token();
2450        if (!parse_expression(tmpl, closing)) {
2451          return false;
2452        }
2453      } else if (tok.text == static_cast<decltype(tok.text)>("endfor")) {
2454        if (for_statement_stack.empty()) {
2455          throw_parser_error("endfor without matching for");
2456        }
2457        auto &for_statement_data = for_statement_stack.top();
2458        get_next_token();
2459        current_block = for_statement_data->parent;
2460        for_statement_stack.pop();
2461      } else if (tok.text == static_cast<decltype(tok.text)>("include")) {
2462        get_next_token();
2463        if (tok.kind != Token::Kind::String) {
2464          throw_parser_error("expected string, got '" + tok.describe() + "'");
2465        }
2466        std::string template_name = json::parse(tok.text).get_ref<const std::string &>();
2467        add_to_template_storage(path, template_name);
2468        current_block->nodes.emplace_back(std::make_shared<IncludeStatementNode>(template_name, tok.text.data() - tmpl.content.c_str()));
2469        get_next_token();
2470      } else if (tok.text == static_cast<decltype(tok.text)>("extends")) {
2471        get_next_token();
2472        if (tok.kind != Token::Kind::String) {
2473          throw_parser_error("expected string, got '" + tok.describe() + "'");
2474        }
2475        std::string template_name = json::parse(tok.text).get_ref<const std::string &>();
2476        add_to_template_storage(path, template_name);
2477        current_block->nodes.emplace_back(std::make_shared<ExtendsStatementNode>(template_name, tok.text.data() - tmpl.content.c_str()));
2478        get_next_token();
2479      } else if (tok.text == static_cast<decltype(tok.text)>("set")) {
2480        get_next_token();
2481        if (tok.kind != Token::Kind::Id) {
2482          throw_parser_error("expected variable name, got '" + tok.describe() + "'");
2483        }
2484        std::string key = static_cast<std::string>(tok.text);
2485        get_next_token();
2486        auto set_statement_node = std::make_shared<SetStatementNode>(key, tok.text.data() - tmpl.content.c_str());
2487        current_block->nodes.emplace_back(set_statement_node);
2488        current_expression_list = &set_statement_node->expression;
2489        if (tok.text != static_cast<decltype(tok.text)>("=")) {
2490          throw_parser_error("expected '=', got '" + tok.describe() + "'");
2491        }
2492        get_next_token();
2493        if (!parse_expression(tmpl, closing)) {
2494          return false;
2495        }
2496      } else {
2497        return false;
2498      }
2499      return true;
2500    }
2501    void parse_into(Template &tmpl, nonstd::string_view path) {
2502      lexer.start(tmpl.content);
2503      current_block = &tmpl.root;
2504      for (;;) {
2505        get_next_token();
2506        switch (tok.kind) {
2507        case Token::Kind::Eof: {
2508          if (!if_statement_stack.empty()) {
2509            throw_parser_error("unmatched if");
2510          }
2511          if (!for_statement_stack.empty()) {
2512            throw_parser_error("unmatched for");
2513          }
2514        } return;
2515        case Token::Kind::Text: {
2516          current_block->nodes.emplace_back(std::make_shared<TextNode>(tok.text.data() - tmpl.content.c_str(), tok.text.size()));
2517        } break;
2518        case Token::Kind::StatementOpen: {
2519          get_next_token();
2520          if (!parse_statement(tmpl, Token::Kind::StatementClose, path)) {
2521            throw_parser_error("expected statement, got '" + tok.describe() + "'");
2522          }
2523          if (tok.kind != Token::Kind::StatementClose) {
2524            throw_parser_error("expected statement close, got '" + tok.describe() + "'");
2525          }
2526        } break;
2527        case Token::Kind::LineStatementOpen: {
2528          get_next_token();
2529          if (!parse_statement(tmpl, Token::Kind::LineStatementClose, path)) {
2530            throw_parser_error("expected statement, got '" + tok.describe() + "'");
2531          }
2532          if (tok.kind != Token::Kind::LineStatementClose && tok.kind != Token::Kind::Eof) {
2533            throw_parser_error("expected line statement close, got '" + tok.describe() + "'");
2534          }
2535        } break;
2536        case Token::Kind::ExpressionOpen: {
2537          get_next_token();
2538          auto expression_list_node = std::make_shared<ExpressionListNode>(tok.text.data() - tmpl.content.c_str());
2539          current_block->nodes.emplace_back(expression_list_node);
2540          current_expression_list = expression_list_node.get();
2541          if (!parse_expression(tmpl, Token::Kind::ExpressionClose)) {
2542            throw_parser_error("expected expression, got '" + tok.describe() + "'");
2543          }
2544          if (tok.kind != Token::Kind::ExpressionClose) {
2545            throw_parser_error("expected expression close, got '" + tok.describe() + "'");
2546          }
2547        } break;
2548        case Token::Kind::CommentOpen: {
2549          get_next_token();
2550          if (tok.kind != Token::Kind::CommentClose) {
2551            throw_parser_error("expected comment close, got '" + tok.describe() + "'");
2552          }
2553        } break;
2554        default: {
2555          throw_parser_error("unexpected token '" + tok.describe() + "'");
2556        } break;
2557        }
2558      }
2559    }
2560  public:
2561    explicit Parser(const ParserConfig &parser_config, const LexerConfig &lexer_config,
2562                    TemplateStorage &template_storage, const FunctionStorage &function_storage)
2563        : config(parser_config), lexer(lexer_config), template_storage(template_storage), function_storage(function_storage) { }
2564    Template parse(nonstd::string_view input, nonstd::string_view path) {
2565      auto result = Template(static_cast<std::string>(input));
2566      parse_into(result, path);
2567      return result;
2568    }
2569    Template parse(nonstd::string_view input) {
2570      return parse(input, "./");
2571    }
2572    void parse_into_template(Template& tmpl, nonstd::string_view filename) {
2573      nonstd::string_view path = filename.substr(0, filename.find_last_of("/\\") + 1);
2574      auto sub_parser = Parser(config, lexer.get_config(), template_storage, function_storage);
2575      sub_parser.parse_into(tmpl, path);
2576    }
2577    std::string load_file(const std::string& filename) {
2578      std::ifstream file;
2579      file.open(filename);
2580      if (file.fail()) {
2581        INJA_THROW(FileError("failed accessing file at '" + filename + "'"));
2582      }
2583      std::string text((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
2584      return text;
2585    }
2586  };
2587  } 
2588  #endif 
2589  #ifndef INCLUDE_INJA_RENDERER_HPP_
2590  #define INCLUDE_INJA_RENDERER_HPP_
2591  #include <algorithm>
2592  #include <numeric>
2593  #include <string>
2594  #include <utility>
2595  #include <vector>
2596  namespace inja {
2597  class Renderer : public NodeVisitor  {
2598    using Op = FunctionStorage::Operation;
2599    const RenderConfig config;
2600    const TemplateStorage &template_storage;
2601    const FunctionStorage &function_storage;
2602    const Template *current_template;
2603    size_t current_level {0};
2604    std::vector<const Template*> template_stack;
2605    std::vector<const BlockStatementNode*> block_statement_stack;
2606    const json *json_input;
2607    std::ostream *output_stream;
2608    json json_additional_data;
2609    json* current_loop_data = &json_additional_data["loop"];
2610    std::vector<std::shared_ptr<json>> json_tmp_stack;
2611    std::stack<const json*> json_eval_stack;
2612    std::stack<const JsonNode*> not_found_stack;
2613    bool break_rendering {false};
2614    bool truthy(const json* data) const {
2615      if (data->is_boolean()) {
2616        return data->get<bool>();
2617      } else if (data->is_number()) {
2618        return (*data != 0);
2619      } else if (data->is_null()) {
2620        return false;
2621      }
2622      return !data->empty();
2623    }
2624    void print_json(const std::shared_ptr<json> value) {
2625      if (value->is_string()) {
2626        *output_stream << value->get_ref<const json::string_t&>();
2627      } else if (value->is_number_integer()) {
2628        *output_stream << value->get<const json::number_integer_t>();
2629      } else if (value->is_null()) {
2630      } else {
2631        *output_stream << value->dump();
2632      }
2633    }
2634    const std::shared_ptr<json> eval_expression_list(const ExpressionListNode& expression_list) {
2635      if (!expression_list.root) {
2636        throw_renderer_error("empty expression", expression_list);
2637      }
2638      expression_list.root->accept(*this);
2639      if (json_eval_stack.empty()) {
2640        throw_renderer_error("empty expression", expression_list);
2641      } else if (json_eval_stack.size() != 1) {
2642        throw_renderer_error("malformed expression", expression_list);
2643      }
2644      const auto result = json_eval_stack.top();
2645      json_eval_stack.pop();
2646      if (!result) {
2647        if (not_found_stack.empty()) {
2648          throw_renderer_error("expression could not be evaluated", expression_list);
2649        }
2650        auto node = not_found_stack.top();
2651        not_found_stack.pop();
2652        throw_renderer_error("variable '" + static_cast<std::string>(node->name) + "' not found", *node);
2653      }
2654      return std::make_shared<json>(*result);
2655    }
2656    void throw_renderer_error(const std::string &message, const AstNode& node) {
2657      SourceLocation loc = get_source_location(current_template->content, node.pos);
2658      INJA_THROW(RenderError(message, loc));
2659    }
2660    template<size_t N, size_t N_start = 0, bool throw_not_found=true>
2661    std::array<const json*, N> get_arguments(const FunctionNode& node) {
2662      if (node.arguments.size() < N_start + N) {
2663        throw_renderer_error("function needs " + std::to_string(N_start + N) + " variables, but has only found " + std::to_string(node.arguments.size()), node);
2664      }
2665      for (size_t i = N_start; i < N_start + N; i += 1) {
2666        node.arguments[i]->accept(*this);
2667      }
2668      if (json_eval_stack.size() < N) {
2669        throw_renderer_error("function needs " + std::to_string(N) + " variables, but has only found " + std::to_string(json_eval_stack.size()), node);
2670      }
2671      std::array<const json*, N> result;
2672      for (size_t i = 0; i < N; i += 1) {
2673        result[N - i - 1] = json_eval_stack.top();
2674        json_eval_stack.pop();
2675        if (!result[N - i - 1]) {
2676          const auto json_node = not_found_stack.top();
2677          not_found_stack.pop();
2678          if (throw_not_found) {
2679            throw_renderer_error("variable '" + static_cast<std::string>(json_node->name) + "' not found", *json_node);
2680          }
2681        }
2682      }
2683      return result;
2684    }
2685    template<bool throw_not_found=true>
2686    Arguments get_argument_vector(const FunctionNode& node) {
2687      const size_t N = node.arguments.size();
2688      for (auto a: node.arguments) {
2689        a->accept(*this);
2690      }
2691      if (json_eval_stack.size() < N) {
2692        throw_renderer_error("function needs " + std::to_string(N) + " variables, but has only found " + std::to_string(json_eval_stack.size()), node);
2693      }
2694      Arguments result {N};
2695      for (size_t i = 0; i < N; i += 1) {
2696        result[N - i - 1] = json_eval_stack.top();
2697        json_eval_stack.pop();
2698        if (!result[N - i - 1]) {
2699          const auto json_node = not_found_stack.top();
2700          not_found_stack.pop();
2701          if (throw_not_found) {
2702            throw_renderer_error("variable '" + static_cast<std::string>(json_node->name) + "' not found", *json_node);
2703          }
2704        }
2705      }
2706      return result;
2707    }
2708    void visit(const BlockNode& node) {
2709      for (auto& n : node.nodes) {
2710        n->accept(*this);
2711        if (break_rendering) {
2712          break;
2713        }
2714      }
2715    }
2716    void visit(const TextNode& node) {
2717      output_stream->write(current_template->content.c_str() + node.pos, node.length);
2718    }
2719    void visit(const ExpressionNode&) { }
2720    void visit(const LiteralNode& node) {
2721      json_eval_stack.push(&node.value);
2722    }
2723    void visit(const JsonNode& node) {
2724      if (json_additional_data.contains(node.ptr)) {
2725        json_eval_stack.push(&(json_additional_data[node.ptr]));
2726      } else if (json_input->contains(node.ptr)) {
2727        json_eval_stack.push(&(*json_input)[node.ptr]);
2728      } else {
2729        const auto function_data = function_storage.find_function(node.name, 0);
2730        if (function_data.operation == FunctionStorage::Operation::Callback) {
2731          Arguments empty_args {};
2732          const auto value = std::make_shared<json>(function_data.callback(empty_args));
2733          json_tmp_stack.push_back(value);
2734          json_eval_stack.push(value.get());
2735        } else {
2736          json_eval_stack.push(nullptr);
2737          not_found_stack.emplace(&node);
2738        }
2739      }
2740    }
2741    void visit(const FunctionNode& node) {
2742      std::shared_ptr<json> result_ptr;
2743      switch (node.operation) {
2744      case Op::Not: {
2745        const auto args = get_arguments<1>(node);
2746        result_ptr = std::make_shared<json>(!truthy(args[0]));
2747        json_tmp_stack.push_back(result_ptr);
2748        json_eval_stack.push(result_ptr.get());
2749      } break;
2750      case Op::And: {
2751        result_ptr = std::make_shared<json>(truthy(get_arguments<1, 0>(node)[0]) && truthy(get_arguments<1, 1>(node)[0]));
2752        json_tmp_stack.push_back(result_ptr);
2753        json_eval_stack.push(result_ptr.get());
2754      } break;
2755      case Op::Or: {
2756        result_ptr = std::make_shared<json>(truthy(get_arguments<1, 0>(node)[0]) || truthy(get_arguments<1, 1>(node)[0]));
2757        json_tmp_stack.push_back(result_ptr);
2758        json_eval_stack.push(result_ptr.get());
2759      } break;
2760      case Op::In: {
2761        const auto args = get_arguments<2>(node);
2762        result_ptr = std::make_shared<json>(std::find(args[1]->begin(), args[1]->end(), *args[0]) != args[1]->end());
2763        json_tmp_stack.push_back(result_ptr);
2764        json_eval_stack.push(result_ptr.get());
2765      } break;
2766      case Op::Equal: {
2767        const auto args = get_arguments<2>(node);
2768        result_ptr = std::make_shared<json>(*args[0] == *args[1]);
2769        json_tmp_stack.push_back(result_ptr);
2770        json_eval_stack.push(result_ptr.get());
2771      } break;
2772      case Op::NotEqual: {
2773        const auto args = get_arguments<2>(node);
2774        result_ptr = std::make_shared<json>(*args[0] != *args[1]);
2775        json_tmp_stack.push_back(result_ptr);
2776        json_eval_stack.push(result_ptr.get());
2777      } break;
2778      case Op::Greater: {
2779        const auto args = get_arguments<2>(node);
2780        result_ptr = std::make_shared<json>(*args[0] > *args[1]);
2781        json_tmp_stack.push_back(result_ptr);
2782        json_eval_stack.push(result_ptr.get());
2783      } break;
2784      case Op::GreaterEqual: {
2785        const auto args = get_arguments<2>(node);
2786        result_ptr = std::make_shared<json>(*args[0] >= *args[1]);
2787        json_tmp_stack.push_back(result_ptr);
2788        json_eval_stack.push(result_ptr.get());
2789      } break;
2790      case Op::Less: {
2791        const auto args = get_arguments<2>(node);
2792        result_ptr = std::make_shared<json>(*args[0] < *args[1]);
2793        json_tmp_stack.push_back(result_ptr);
2794        json_eval_stack.push(result_ptr.get());
2795      } break;
2796      case Op::LessEqual: {
2797        const auto args = get_arguments<2>(node);
2798        result_ptr = std::make_shared<json>(*args[0] <= *args[1]);
2799        json_tmp_stack.push_back(result_ptr);
2800        json_eval_stack.push(result_ptr.get());
2801      } break;
2802      case Op::Add: {
2803        const auto args = get_arguments<2>(node);
2804        if (args[0]->is_string() && args[1]->is_string()) {
2805          result_ptr = std::make_shared<json>(args[0]->get_ref<const std::string&>() + args[1]->get_ref<const std::string&>());
2806          json_tmp_stack.push_back(result_ptr);
2807        } else if (args[0]->is_number_integer() && args[1]->is_number_integer()) {
2808          result_ptr = std::make_shared<json>(args[0]->get<int>() + args[1]->get<int>());
2809          json_tmp_stack.push_back(result_ptr);
2810        } else {
2811          result_ptr = std::make_shared<json>(args[0]->get<double>() + args[1]->get<double>());
2812          json_tmp_stack.push_back(result_ptr);
2813        }
2814        json_eval_stack.push(result_ptr.get());
2815      } break;
2816      case Op::Subtract: {
2817        const auto args = get_arguments<2>(node);
2818        if (args[0]->is_number_integer() && args[1]->is_number_integer()) {
2819          result_ptr = std::make_shared<json>(args[0]->get<int>() - args[1]->get<int>());
2820          json_tmp_stack.push_back(result_ptr);
2821        } else {
2822          result_ptr = std::make_shared<json>(args[0]->get<double>() - args[1]->get<double>());
2823          json_tmp_stack.push_back(result_ptr);
2824        }
2825        json_eval_stack.push(result_ptr.get());
2826      } break;
2827      case Op::Multiplication: {
2828        const auto args = get_arguments<2>(node);
2829        if (args[0]->is_number_integer() && args[1]->is_number_integer()) {
2830          result_ptr = std::make_shared<json>(args[0]->get<int>() * args[1]->get<int>());
2831          json_tmp_stack.push_back(result_ptr);
2832        } else {
2833          result_ptr = std::make_shared<json>(args[0]->get<double>() * args[1]->get<double>());
2834          json_tmp_stack.push_back(result_ptr);
2835        }
2836        json_eval_stack.push(result_ptr.get());
2837      } break;
2838      case Op::Division: {
2839        const auto args = get_arguments<2>(node);
2840        if (args[1]->get<double>() == 0) {
2841          throw_renderer_error("division by zero", node);
2842        }
2843        result_ptr = std::make_shared<json>(args[0]->get<double>() / args[1]->get<double>());
2844        json_tmp_stack.push_back(result_ptr);
2845        json_eval_stack.push(result_ptr.get());
2846      } break;
2847      case Op::Power: {
2848        const auto args = get_arguments<2>(node);
2849        if (args[0]->is_number_integer() && args[1]->get<int>() >= 0) {
2850          int result = static_cast<int>(std::pow(args[0]->get<int>(), args[1]->get<int>()));
2851          result_ptr = std::make_shared<json>(std::move(result));
2852          json_tmp_stack.push_back(result_ptr);
2853        } else {
2854          double result = std::pow(args[0]->get<double>(), args[1]->get<int>());
2855          result_ptr = std::make_shared<json>(std::move(result));
2856          json_tmp_stack.push_back(result_ptr);
2857        }
2858        json_eval_stack.push(result_ptr.get());
2859      } break;
2860      case Op::Modulo: {
2861        const auto args = get_arguments<2>(node);
2862        result_ptr = std::make_shared<json>(args[0]->get<int>() % args[1]->get<int>());
2863        json_tmp_stack.push_back(result_ptr);
2864        json_eval_stack.push(result_ptr.get());
2865      } break;
2866      case Op::AtId: {
2867        const auto container = get_arguments<1, 0, false>(node)[0];
2868        node.arguments[1]->accept(*this);
2869        if (not_found_stack.empty()) {
2870          throw_renderer_error("could not find element with given name", node);
2871        }
2872        const auto id_node = not_found_stack.top();
2873        not_found_stack.pop();
2874        json_eval_stack.pop();
2875        json_eval_stack.push(&container->at(id_node->name));
2876      } break;
2877      case Op::At: {
2878        const auto args = get_arguments<2>(node);
2879        if (args[0]->is_object()) {
2880          json_eval_stack.push(&args[0]->at(args[1]->get<std::string>()));
2881        } else {
2882          json_eval_stack.push(&args[0]->at(args[1]->get<int>()));
2883        }
2884      } break;
2885      case Op::Default: {
2886        const auto test_arg = get_arguments<1, 0, false>(node)[0];
2887        json_eval_stack.push(test_arg ? test_arg : get_arguments<1, 1>(node)[0]);
2888      } break;
2889      case Op::DivisibleBy: {
2890        const auto args = get_arguments<2>(node);
2891        const int divisor = args[1]->get<int>();
2892        result_ptr = std::make_shared<json>((divisor != 0) && (args[0]->get<int>() % divisor == 0));
2893        json_tmp_stack.push_back(result_ptr);
2894        json_eval_stack.push(result_ptr.get());
2895      } break;
2896      case Op::Even: {
2897        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->get<int>() % 2 == 0);
2898        json_tmp_stack.push_back(result_ptr);
2899        json_eval_stack.push(result_ptr.get());
2900      } break;
2901      case Op::Exists: {
2902        auto &&name = get_arguments<1>(node)[0]->get_ref<const std::string &>();
2903        result_ptr = std::make_shared<json>(json_input->contains(json::json_pointer(JsonNode::convert_dot_to_json_ptr(name))));
2904        json_tmp_stack.push_back(result_ptr);
2905        json_eval_stack.push(result_ptr.get());
2906      } break;
2907      case Op::ExistsInObject: {
2908        const auto args = get_arguments<2>(node);
2909        auto &&name = args[1]->get_ref<const std::string &>();
2910        result_ptr = std::make_shared<json>(args[0]->find(name) != args[0]->end());
2911        json_tmp_stack.push_back(result_ptr);
2912        json_eval_stack.push(result_ptr.get());
2913      } break;
2914      case Op::First: {
2915        const auto result = &get_arguments<1>(node)[0]->front();
2916        json_eval_stack.push(result);
2917      } break;
2918      case Op::Float: {
2919        result_ptr = std::make_shared<json>(std::stod(get_arguments<1>(node)[0]->get_ref<const std::string &>()));
2920        json_tmp_stack.push_back(result_ptr);
2921        json_eval_stack.push(result_ptr.get());
2922      } break;
2923      case Op::Int: {
2924        result_ptr = std::make_shared<json>(std::stoi(get_arguments<1>(node)[0]->get_ref<const std::string &>()));
2925        json_tmp_stack.push_back(result_ptr);
2926        json_eval_stack.push(result_ptr.get());
2927      } break;
2928      case Op::Last: {
2929        const auto result = &get_arguments<1>(node)[0]->back();
2930        json_eval_stack.push(result);
2931      } break;
2932      case Op::Length: {
2933        const auto val = get_arguments<1>(node)[0];
2934        if (val->is_string()) {
2935          result_ptr = std::make_shared<json>(val->get_ref<const std::string &>().length());
2936        } else {
2937          result_ptr = std::make_shared<json>(val->size());
2938        }
2939        json_tmp_stack.push_back(result_ptr);
2940        json_eval_stack.push(result_ptr.get());
2941      } break;
2942      case Op::Lower: {
2943        std::string result = get_arguments<1>(node)[0]->get<std::string>();
2944        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
2945        result_ptr = std::make_shared<json>(std::move(result));
2946        json_tmp_stack.push_back(result_ptr);
2947        json_eval_stack.push(result_ptr.get());
2948      } break;
2949      case Op::Max: {
2950        const auto args = get_arguments<1>(node);
2951        const auto result = std::max_element(args[0]->begin(), args[0]->end());
2952        json_eval_stack.push(&(*result));
2953      } break;
2954      case Op::Min: {
2955        const auto args = get_arguments<1>(node);
2956        const auto result = std::min_element(args[0]->begin(), args[0]->end());
2957        json_eval_stack.push(&(*result));
2958      } break;
2959      case Op::Odd: {
2960        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->get<int>() % 2 != 0);
2961        json_tmp_stack.push_back(result_ptr);
2962        json_eval_stack.push(result_ptr.get());
2963      } break;
2964      case Op::Range: {
2965        std::vector<int> result(get_arguments<1>(node)[0]->get<int>());
2966        std::iota(result.begin(), result.end(), 0);
2967        result_ptr = std::make_shared<json>(std::move(result));
2968        json_tmp_stack.push_back(result_ptr);
2969        json_eval_stack.push(result_ptr.get());
2970      } break;
2971      case Op::Round: {
2972        const auto args = get_arguments<2>(node);
2973        const int precision = args[1]->get<int>();
2974        const double result = std::round(args[0]->get<double>() * std::pow(10.0, precision)) / std::pow(10.0, precision);
2975        if(0==precision){
2976          result_ptr = std::make_shared<json>(int(result));
2977        }else{
2978          result_ptr = std::make_shared<json>(std::move(result));
2979        }
2980        json_tmp_stack.push_back(result_ptr);
2981        json_eval_stack.push(result_ptr.get());
2982      } break;
2983      case Op::Sort: {
2984        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->get<std::vector<json>>());
2985        std::sort(result_ptr->begin(), result_ptr->end());
2986        json_tmp_stack.push_back(result_ptr);
2987        json_eval_stack.push(result_ptr.get());
2988      } break;
2989      case Op::Upper: {
2990        std::string result = get_arguments<1>(node)[0]->get<std::string>();
2991        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
2992        result_ptr = std::make_shared<json>(std::move(result));
2993        json_tmp_stack.push_back(result_ptr);
2994        json_eval_stack.push(result_ptr.get());
2995      } break;
2996      case Op::IsBoolean: {
2997        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_boolean());
2998        json_tmp_stack.push_back(result_ptr);
2999        json_eval_stack.push(result_ptr.get());
3000      } break;
3001      case Op::IsNumber: {
3002        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_number());
3003        json_tmp_stack.push_back(result_ptr);
3004        json_eval_stack.push(result_ptr.get());
3005      } break;
3006      case Op::IsInteger: {
3007        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_number_integer());
3008        json_tmp_stack.push_back(result_ptr);
3009        json_eval_stack.push(result_ptr.get());
3010      } break;
3011      case Op::IsFloat: {
3012        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_number_float());
3013        json_tmp_stack.push_back(result_ptr);
3014        json_eval_stack.push(result_ptr.get());
3015      } break;
3016      case Op::IsObject: {
3017        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_object());
3018        json_tmp_stack.push_back(result_ptr);
3019        json_eval_stack.push(result_ptr.get());
3020      } break;
3021      case Op::IsArray: {
3022        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_array());
3023        json_tmp_stack.push_back(result_ptr);
3024        json_eval_stack.push(result_ptr.get());
3025      } break;
3026      case Op::IsString: {
3027        result_ptr = std::make_shared<json>(get_arguments<1>(node)[0]->is_string());
3028        json_tmp_stack.push_back(result_ptr);
3029        json_eval_stack.push(result_ptr.get());
3030      } break;
3031      case Op::Callback: {
3032        auto args = get_argument_vector(node);
3033        result_ptr = std::make_shared<json>(node.callback(args));
3034        json_tmp_stack.push_back(result_ptr);
3035        json_eval_stack.push(result_ptr.get());
3036      } break;
3037      case Op::Super: {
3038        const auto args = get_argument_vector(node);
3039        const size_t old_level = current_level;
3040        const size_t level_diff = (args.size() == 1) ? args[0]->get<int>() : 1;
3041        const size_t level = current_level + level_diff;
3042        if (block_statement_stack.empty()) {
3043          throw_renderer_error("super() call is not within a block", node);
3044        }
3045        if (level < 1 || level > template_stack.size() - 1) {
3046          throw_renderer_error("level of super() call does not match parent templates (between 1 and " + std::to_string(template_stack.size() - 1) + ")", node);
3047        }
3048        const auto current_block_statement = block_statement_stack.back();
3049        const Template *new_template = template_stack.at(level);
3050        const Template *old_template = current_template;
3051        const auto block_it = new_template->block_storage.find(current_block_statement->name);
3052        if (block_it != new_template->block_storage.end()) {
3053          current_template = new_template;
3054          current_level = level;
3055          block_it->second->block.accept(*this);
3056          current_level = old_level;
3057          current_template = old_template;
3058        } else {
3059          throw_renderer_error("could not find block with name '" + current_block_statement->name + "'", node);
3060        }
3061        result_ptr = std::make_shared<json>(nullptr);
3062        json_tmp_stack.push_back(result_ptr);
3063        json_eval_stack.push(result_ptr.get());
3064      } break;
3065      case Op::Join: {
3066        const auto args = get_arguments<2>(node);
3067        const auto separator = args[1]->get<std::string>();
3068        std::ostringstream os;
3069        std::string sep;
3070        for (const auto& value : *args[0]) {
3071          os << sep;
3072          if (value.is_string()) {
3073            os << value.get<std::string>(); 
3074          } else {
3075            os << value;
3076          }
3077          sep = separator;
3078        }
3079        result_ptr = std::make_shared<json>(os.str());
3080        json_tmp_stack.push_back(result_ptr);
3081        json_eval_stack.push(result_ptr.get());
3082      } break;
3083      case Op::ParenLeft:
3084      case Op::ParenRight:
3085      case Op::None:
3086        break;
3087      }
3088    }
3089    void visit(const ExpressionListNode& node) {
3090      print_json(eval_expression_list(node));
3091    }
3092    void visit(const StatementNode&) { }
3093    void visit(const ForStatementNode&) { }
3094    void visit(const ForArrayStatementNode& node) {
3095      const auto result = eval_expression_list(node.condition);
3096      if (!result->is_array()) {
3097        throw_renderer_error("object must be an array", node);
3098      }
3099      if (!current_loop_data->empty()) {
3100        auto tmp = *current_loop_data; 
3101        (*current_loop_data)["parent"] = std::move(tmp);
3102      }
3103      size_t index = 0;
3104      (*current_loop_data)["is_first"] = true;
3105      (*current_loop_data)["is_last"] = (result->size() <= 1);
3106      for (auto it = result->begin(); it != result->end(); ++it) {
3107        json_additional_data[static_cast<std::string>(node.value)] = *it;
3108        (*current_loop_data)["index"] = index;
3109        (*current_loop_data)["index1"] = index + 1;
3110        if (index == 1) {
3111          (*current_loop_data)["is_first"] = false;
3112        }
3113        if (index == result->size() - 1) {
3114          (*current_loop_data)["is_last"] = true;
3115        }
3116        node.body.accept(*this);
3117        ++index;
3118      }
3119      json_additional_data[static_cast<std::string>(node.value)].clear();
3120      if (!(*current_loop_data)["parent"].empty()) {
3121        const auto tmp = (*current_loop_data)["parent"];
3122        *current_loop_data = std::move(tmp);
3123      } else {
3124        current_loop_data = &json_additional_data["loop"];
3125      }
3126    }
3127    void visit(const ForObjectStatementNode& node) {
3128      const auto result = eval_expression_list(node.condition);
3129      if (!result->is_object()) {
3130        throw_renderer_error("object must be an object", node);
3131      }
3132      if (!current_loop_data->empty()) {
3133        (*current_loop_data)["parent"] = std::move(*current_loop_data);
3134      }
3135      size_t index = 0;
3136      (*current_loop_data)["is_first"] = true;
3137      (*current_loop_data)["is_last"] = (result->size() <= 1);
3138      for (auto it = result->begin(); it != result->end(); ++it) {
3139        json_additional_data[static_cast<std::string>(node.key)] = it.key();
3140        json_additional_data[static_cast<std::string>(node.value)] = it.value();
3141        (*current_loop_data)["index"] = index;
3142        (*current_loop_data)["index1"] = index + 1;
3143        if (index == 1) {
3144          (*current_loop_data)["is_first"] = false;
3145        }
3146        if (index == result->size() - 1) {
3147          (*current_loop_data)["is_last"] = true;
3148        }
3149        node.body.accept(*this);
3150        ++index;
3151      }
3152      json_additional_data[static_cast<std::string>(node.key)].clear();
3153      json_additional_data[static_cast<std::string>(node.value)].clear();
3154      if (!(*current_loop_data)["parent"].empty()) {
3155        *current_loop_data = std::move((*current_loop_data)["parent"]);
3156      } else {
3157        current_loop_data = &json_additional_data["loop"];
3158      }
3159    }
3160    void visit(const IfStatementNode& node) {
3161      const auto result = eval_expression_list(node.condition);
3162      if (truthy(result.get())) {
3163        node.true_statement.accept(*this);
3164      } else if (node.has_false_statement) {
3165        node.false_statement.accept(*this);
3166      }
3167    }
3168    void visit(const IncludeStatementNode& node) {
3169      auto sub_renderer = Renderer(config, template_storage, function_storage);
3170      const auto included_template_it = template_storage.find(node.file);
3171      if (included_template_it != template_storage.end()) {
3172        sub_renderer.render_to(*output_stream, included_template_it->second, *json_input, &json_additional_data);
3173      } else if (config.throw_at_missing_includes) {
3174        throw_renderer_error("include '" + node.file + "' not found", node);
3175      }
3176    }
3177    void visit(const ExtendsStatementNode& node) {
3178      const auto included_template_it = template_storage.find(node.file);
3179      if (included_template_it != template_storage.end()) {
3180        const Template *parent_template = &included_template_it->second;
3181        render_to(*output_stream, *parent_template, *json_input, &json_additional_data);
3182        break_rendering = true;
3183      } else if (config.throw_at_missing_includes) {
3184        throw_renderer_error("extends '" + node.file + "' not found", node);
3185      }
3186    }
3187    void visit(const BlockStatementNode& node) {
3188      const size_t old_level = current_level;
3189      current_level = 0;
3190      current_template = template_stack.front();
3191      const auto block_it = current_template->block_storage.find(node.name);
3192      if (block_it != current_template->block_storage.end()) {
3193        block_statement_stack.emplace_back(&node);
3194        block_it->second->block.accept(*this);
3195        block_statement_stack.pop_back(); 
3196      }
3197      current_level = old_level;
3198      current_template = template_stack.back();
3199    }
3200    void visit(const SetStatementNode& node) {
3201      std::string ptr = node.key;
3202      replace_substring(ptr, ".", "/");
3203      ptr = "/" + ptr;
3204      json_additional_data[json::json_pointer(ptr)] = *eval_expression_list(node.expression);
3205    }
3206  public:
3207    Renderer(const RenderConfig& config, const TemplateStorage &template_storage, const FunctionStorage &function_storage)
3208        : config(config), template_storage(template_storage), function_storage(function_storage) { }
3209    void render_to(std::ostream &os, const Template &tmpl, const json &data, json *loop_data = nullptr) {
3210      output_stream = &os;
3211      current_template = &tmpl;
3212      json_input = &data;
3213      if (loop_data) {
3214        json_additional_data = *loop_data;
3215        current_loop_data = &json_additional_data["loop"];
3216      }
3217      template_stack.emplace_back(current_template);
3218      current_template->root.accept(*this);
3219      json_tmp_stack.clear();
3220    }
3221  };
3222  } 
3223  #endif 
3224  namespace inja {
3225  class Environment {
3226    std::string input_path;
3227    std::string output_path;
3228    LexerConfig lexer_config;
3229    ParserConfig parser_config;
3230    RenderConfig render_config;
3231    FunctionStorage function_storage;
3232    TemplateStorage template_storage;
3233  public:
3234    Environment() : Environment("") {}
3235    explicit Environment(const std::string &global_path) : input_path(global_path), output_path(global_path) {}
3236    Environment(const std::string &input_path, const std::string &output_path)
3237        : input_path(input_path), output_path(output_path) {}
3238    void set_statement(const std::string &open, const std::string &close) {
3239      lexer_config.statement_open = open;
3240      lexer_config.statement_open_no_lstrip = open + "+";
3241      lexer_config.statement_open_force_lstrip = open + "-";
3242      lexer_config.statement_close = close;
3243      lexer_config.statement_close_force_rstrip = "-" + close;
3244      lexer_config.update_open_chars();
3245    }
3246    void set_line_statement(const std::string &open) {
3247      lexer_config.line_statement = open;
3248      lexer_config.update_open_chars();
3249    }
3250    void set_expression(const std::string &open, const std::string &close) {
3251      lexer_config.expression_open = open;
3252      lexer_config.expression_open_force_lstrip = open + "-";
3253      lexer_config.expression_close = close;
3254      lexer_config.expression_close_force_rstrip = "-" + close;
3255      lexer_config.update_open_chars();
3256    }
3257    void set_comment(const std::string &open, const std::string &close) {
3258      lexer_config.comment_open = open;
3259      lexer_config.comment_open_force_lstrip = open + "-";
3260      lexer_config.comment_close = close;
3261      lexer_config.comment_close_force_rstrip = "-" + close;
3262      lexer_config.update_open_chars();
3263    }
3264    void set_trim_blocks(bool trim_blocks) {
3265      lexer_config.trim_blocks = trim_blocks;
3266    }
3267    void set_lstrip_blocks(bool lstrip_blocks) {
3268      lexer_config.lstrip_blocks = lstrip_blocks;
3269    }
3270    void set_search_included_templates_in_files(bool search_in_files) {
3271      parser_config.search_included_templates_in_files = search_in_files;
3272    }
3273    void set_throw_at_missing_includes(bool will_throw) {
3274      render_config.throw_at_missing_includes = will_throw;
3275    }
3276    Template parse(nonstd::string_view input) {
3277      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3278      return parser.parse(input);
3279    }
3280    Template parse_template(const std::string &filename) {
3281      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3282      auto result = Template(parser.load_file(input_path + static_cast<std::string>(filename)));
3283      parser.parse_into_template(result, input_path + static_cast<std::string>(filename));
3284      return result;
3285    }
3286    Template parse_file(const std::string &filename) {
3287      return parse_template(filename);
3288    }
3289    std::string render(nonstd::string_view input, const json &data) { return render(parse(input), data); }
3290    std::string render(const Template &tmpl, const json &data) {
3291      std::stringstream os;
3292      render_to(os, tmpl, data);
3293      return os.str();
3294    }
3295    std::string render_file(const std::string &filename, const json &data) {
3296      return render(parse_template(filename), data);
3297    }
3298    std::string render_file_with_json_file(const std::string &filename, const std::string &filename_data) {
3299      const json data = load_json(filename_data);
3300      return render_file(filename, data);
3301    }
3302    void write(const std::string &filename, const json &data, const std::string &filename_out) {
3303      std::ofstream file(output_path + filename_out);
3304      file << render_file(filename, data);
3305      file.close();
3306    }
3307    void write(const Template &temp, const json &data, const std::string &filename_out) {
3308      std::ofstream file(output_path + filename_out);
3309      file << render(temp, data);
3310      file.close();
3311    }
3312    void write_with_json_file(const std::string &filename, const std::string &filename_data,
3313                              const std::string &filename_out) {
3314      const json data = load_json(filename_data);
3315      write(filename, data, filename_out);
3316    }
3317    void write_with_json_file(const Template &temp, const std::string &filename_data, const std::string &filename_out) {
3318      const json data = load_json(filename_data);
3319      write(temp, data, filename_out);
3320    }
3321    std::ostream &render_to(std::ostream &os, const Template &tmpl, const json &data) {
3322      Renderer(render_config, template_storage, function_storage).render_to(os, tmpl, data);
3323      return os;
3324    }
3325    std::string load_file(const std::string &filename) {
3326      Parser parser(parser_config, lexer_config, template_storage, function_storage);
3327      return parser.load_file(input_path + filename);
3328    }
3329    json load_json(const std::string &filename) {
3330      std::ifstream file;
3331      file.open(input_path + filename);
3332      if (file.fail()) {
3333        INJA_THROW(FileError("failed accessing file at '" + input_path + filename + "'"));
3334      }
3335      json j;
3336      file >> j;
3337      return j;
3338    }
3339    void add_callback(const std::string &name, const CallbackFunction &callback) {
3340      add_callback(name, -1, callback);
3341    }
3342    void add_void_callback(const std::string &name, const VoidCallbackFunction &callback) {
3343      add_void_callback(name, -1, callback);
3344    }
3345    void add_callback(const std::string &name, int num_args, const CallbackFunction &callback) {
3346      function_storage.add_callback(name, num_args, callback);
3347    }
3348    void add_void_callback(const std::string &name, int num_args, const VoidCallbackFunction &callback) {
3349      function_storage.add_callback(name, num_args, [callback](Arguments& args) { callback(args); return json(); });
3350    }
3351    void include_template(const std::string &name, const Template &tmpl) {
3352      template_storage[name] = tmpl;
3353    }
3354    void set_include_callback(const std::function<Template(const std::string&, const std::string&)>& callback) {
3355      parser_config.include_callback = callback;
3356    }
3357  };
3358  inline std::string render(nonstd::string_view input, const json &data) {
3359    return Environment().render(input, data);
3360  }
3361  inline void render_to(std::ostream &os, nonstd::string_view input, const json &data) {
3362    Environment env;
3363    env.render_to(os, env.parse(input), data);
3364  }
3365  } 
3366  #endif 
3367  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-jpcre2.hpp</h3>
            <pre><code>1  #ifndef JPCRE2_HPP
2  #define JPCRE2_HPP
3  #ifndef PCRE2_CODE_UNIT_WIDTH
4  #define PCRE2_CODE_UNIT_WIDTH 0
5  #endif
6  #ifndef PCRE2_MAJOR
7      #include <pcre2.h>  
8  #endif
9  #include <string>       
10  #include <vector>       
11  #include <map>          
12  #include <cstdio>       
13  #include <climits>      
14  #include <cstdlib>      
15  #if __cplusplus >= 201103L || _MSVC_LANG >= 201103L
16      #define JPCRE2_USE_MINIMUM_CXX_11 1
17      #include <utility>
18      #ifndef JPCRE2_USE_FUNCTION_POINTER_CALLBACK
19          #include <functional>   
20      #endif
21  #else
22      #define JPCRE2_USE_MINIMUM_CXX_11 0
23  #endif
24  #define JPCRE2_UNUSED(x) ((void)(x))
25  #if defined(NDEBUG) || defined(JPCRE2_NDEBUG)
26      #define JPCRE2_ASSERT(cond, msg) ((void)0)
27      #define JPCRE2_VECTOR_DATA_ASSERT(cond, name) ((void)0)
28  #else
29      #define JPCRE2_ASSERT(cond, msg) jpcre2::jassert(cond, msg, __FILE__, __LINE__)
30      #define JPCRE2_VECTOR_DATA_ASSERT(cond, name) jpcre2::_jvassert(cond, name, __FILE__, __LINE__)
31  #endif
32  #ifdef ERROR
33  #undef ERROR
34  #endif
35  namespace jpcre2 {
36  #define JPCRE2_VERSION 103201L
37  namespace INFO {
38      static const char NAME[] = "JPCRE2";               
39      static const char FULL_VERSION[] = "10.32.01";     
40      static const char VERSION_GENRE[] = "10";          
41      static const char VERSION_MAJOR[] = "32";          
42      static const char VERSION_MINOR[] = "01";          
43      static const char VERSION_PRE_RELEASE[] = "";      
44  }
45  typedef PCRE2_SIZE SIZE_T;                          
46  typedef uint32_t Uint;                              
47  typedef uint8_t Ush;                                
48  typedef std::vector<SIZE_T> VecOff;                 
49  typedef std::vector<Uint> VecOpt;                   
50  namespace ERROR {
51      enum {
52          INVALID_MODIFIER        = 2,  
53          INSUFFICIENT_OVECTOR    = 3   
54      };
55  }
56  enum {
57      NONE                    = 0x0000000u,           
58      FIND_ALL                = 0x0000002u,           
59      JIT_COMPILE             = 0x0000004u            
60  };
61  template<bool B, typename T = void>
62  struct EnableIf{};
63  template<typename T>
64  struct EnableIf<true, T>{typedef T Type;};
65  template<typename T1, typename T2>
66  struct IsSame{ static const bool value = false; };
67  template<typename T>
68  struct IsSame<T,T>{ static const bool value = true; };
69  static inline void jassert(bool cond, const char* msg, const char* f, size_t line){
70      if(!cond) {
71          std::fprintf(stderr,"\n\tE: AssertionFailure\n%s\nAssertion failed in file: %s\t at line: %u\n", msg, f, (unsigned)line);
72          std::abort();
73      }
74  }
75  static inline void _jvassert(bool cond, char const * name, const char* f, size_t line){
76      jassert(cond, (std::string("ValueError: \n\
77      Required data vector of type ")+std::string(name)+" is empty.\n\
78      Your MatchEvaluator callback function is not\n\
79      compatible with existing data!!\n\
80      You are trying to use a vector that does not\n\
81      have any match data. Either call nreplace() or replace()\n\
82      with true or perform a match with appropriate\n\
83      callback function. For more details, refer to\n\
84      the doc in MatchEvaluator section.").c_str(), f, line);
85  }
86  static inline std::string _tostdstring(unsigned x){
87      char buf[128];
88      int written = std::sprintf(buf, "%u", x);
89      return (written > 0) ? std::string(buf, buf + written) : std::string();
90  }
91  template<Ush BS> struct Pcre2Type;
92  template<Ush BS> struct Pcre2Func;
93  template<Ush BS> struct Pcre2Type {};
94  template<> struct Pcre2Type<8>{
95      typedef PCRE2_UCHAR8 Pcre2Uchar;
96      typedef PCRE2_SPTR8 Pcre2Sptr;
97      typedef pcre2_code_8 Pcre2Code;
98      typedef pcre2_compile_context_8 CompileContext;
99      typedef pcre2_match_data_8 MatchData;
100      typedef pcre2_general_context_8 GeneralContext;
101      typedef pcre2_match_context_8 MatchContext;
102      typedef pcre2_jit_callback_8 JitCallback;
103      typedef pcre2_jit_stack_8 JitStack;
104  };
105  template<> struct Pcre2Type<16>{
106      typedef PCRE2_UCHAR16 Pcre2Uchar;
107      typedef PCRE2_SPTR16 Pcre2Sptr;
108      typedef pcre2_code_16 Pcre2Code;
109      typedef pcre2_compile_context_16 CompileContext;
110      typedef pcre2_match_data_16 MatchData;
111      typedef pcre2_general_context_16 GeneralContext;
112      typedef pcre2_match_context_16 MatchContext;
113      typedef pcre2_jit_callback_16 JitCallback;
114      typedef pcre2_jit_stack_16 JitStack;
115  };
116  template<> struct Pcre2Type<32>{
117      typedef PCRE2_UCHAR32 Pcre2Uchar;
118      typedef PCRE2_SPTR32 Pcre2Sptr;
119      typedef pcre2_code_32 Pcre2Code;
120      typedef pcre2_compile_context_32 CompileContext;
121      typedef pcre2_match_data_32 MatchData;
122      typedef pcre2_general_context_32 GeneralContext;
123      typedef pcre2_match_context_32 MatchContext;
124      typedef pcre2_jit_callback_32 JitCallback;
125      typedef pcre2_jit_stack_32 JitStack;
126  };
127  template<Ush BS> struct Pcre2Func{};
128  template<> struct Pcre2Func<8> {
129      static Pcre2Type<8>::CompileContext* compile_context_create(Pcre2Type<8>::GeneralContext *gcontext){
130          return pcre2_compile_context_create_8(gcontext);
131      }
132      static void compile_context_free(Pcre2Type<8>::CompileContext *ccontext){
133          pcre2_compile_context_free_8(ccontext);
134      }
135      static Pcre2Type<8>::CompileContext* compile_context_copy(Pcre2Type<8>::CompileContext* ccontext){
136      return pcre2_compile_context_copy_8(ccontext);
137      }
138      static const unsigned char * maketables(Pcre2Type<8>::GeneralContext* gcontext){
139          return pcre2_maketables_8(gcontext);
140      }
141      static int set_character_tables(Pcre2Type<8>::CompileContext * ccontext, const unsigned char * table){
142          return pcre2_set_character_tables_8(ccontext, table);
143      }
144      static Pcre2Type<8>::Pcre2Code * compile(Pcre2Type<8>::Pcre2Sptr pattern,
145                                       PCRE2_SIZE length,
146                                       uint32_t options,
147                                       int *errorcode,
148                                       PCRE2_SIZE *erroroffset,
149                                       Pcre2Type<8>::CompileContext *ccontext){
150          return pcre2_compile_8(pattern, length, options, errorcode, erroroffset, ccontext);
151      }
152      static int jit_compile(Pcre2Type<8>::Pcre2Code *code, uint32_t options){
153          return pcre2_jit_compile_8(code, options);
154      }
155      static int substitute( const Pcre2Type<8>::Pcre2Code *code,
156                      Pcre2Type<8>::Pcre2Sptr subject,
157                      PCRE2_SIZE length,
158                      PCRE2_SIZE startoffset,
159                      uint32_t options,
160                      Pcre2Type<8>::MatchData *match_data,
161                      Pcre2Type<8>::MatchContext *mcontext,
162                      Pcre2Type<8>::Pcre2Sptr replacement,
163                      PCRE2_SIZE rlength,
164                      Pcre2Type<8>::Pcre2Uchar *outputbuffer,
165                      PCRE2_SIZE *outlengthptr){
166          return pcre2_substitute_8( code, subject, length, startoffset, options, match_data,
167                                     mcontext, replacement, rlength, outputbuffer, outlengthptr);
168      }
169      static void code_free(Pcre2Type<8>::Pcre2Code *code){
170          pcre2_code_free_8(code);
171      }
172      static int get_error_message(  int errorcode,
173                              Pcre2Type<8>::Pcre2Uchar *buffer,
174                              PCRE2_SIZE bufflen){
175          return pcre2_get_error_message_8(errorcode, buffer, bufflen);
176      }
177      static Pcre2Type<8>::MatchData * match_data_create_from_pattern(
178                                const Pcre2Type<8>::Pcre2Code *code,
179                                Pcre2Type<8>::GeneralContext *gcontext){
180          return pcre2_match_data_create_from_pattern_8(code, gcontext);
181      }
182      static int match(  const Pcre2Type<8>::Pcre2Code *code,
183                              Pcre2Type<8>::Pcre2Sptr subject,
184                              PCRE2_SIZE length,
185                              PCRE2_SIZE startoffset,
186                              uint32_t options,
187                              Pcre2Type<8>::MatchData *match_data,
188                              Pcre2Type<8>::MatchContext *mcontext){
189          return pcre2_match_8(code, subject, length, startoffset, options, match_data, mcontext);
190      }
191      static void match_data_free(Pcre2Type<8>::MatchData *match_data){
192          pcre2_match_data_free_8(match_data);
193      }
194      static PCRE2_SIZE * get_ovector_pointer(Pcre2Type<8>::MatchData *match_data){
195          return pcre2_get_ovector_pointer_8(match_data);
196      }
197      static int pattern_info(const Pcre2Type<8>::Pcre2Code *code, uint32_t what, void *where){
198          return pcre2_pattern_info_8(code, what, where);
199      }
200      static int set_newline(Pcre2Type<8>::CompileContext *ccontext, uint32_t value){
201          return pcre2_set_newline_8(ccontext, value);
202      }
203      static uint32_t get_ovector_count(Pcre2Type<8>::MatchData *match_data){
204          return pcre2_get_ovector_count_8(match_data);
205      }
206  };
207  template<> struct Pcre2Func<16> {
208      static Pcre2Type<16>::CompileContext* compile_context_create(Pcre2Type<16>::GeneralContext *gcontext){
209          return pcre2_compile_context_create_16(gcontext);
210      }
211      static void compile_context_free(Pcre2Type<16>::CompileContext *ccontext){
212          pcre2_compile_context_free_16(ccontext);
213      }
214      static Pcre2Type<16>::CompileContext* compile_context_copy(Pcre2Type<16>::CompileContext* ccontext){
215      return pcre2_compile_context_copy_16(ccontext);
216      }
217      static const unsigned char * maketables(Pcre2Type<16>::GeneralContext* gcontext){
218          return pcre2_maketables_16(gcontext);
219      }
220      static int set_character_tables(Pcre2Type<16>::CompileContext * ccontext, const unsigned char * table){
221          return pcre2_set_character_tables_16(ccontext, table);
222      }
223      static Pcre2Type<16>::Pcre2Code * compile(Pcre2Type<16>::Pcre2Sptr pattern,
224                                       PCRE2_SIZE length,
225                                       uint32_t options,
226                                       int *errorcode,
227                                       PCRE2_SIZE *erroroffset,
228                                       Pcre2Type<16>::CompileContext *ccontext){
229          return pcre2_compile_16(pattern, length, options, errorcode, erroroffset, ccontext);
230      }
231      static int jit_compile(Pcre2Type<16>::Pcre2Code *code, uint32_t options){
232          return pcre2_jit_compile_16(code, options);
233      }
234      static int substitute( const Pcre2Type<16>::Pcre2Code *code,
235                      Pcre2Type<16>::Pcre2Sptr subject,
236                      PCRE2_SIZE length,
237                      PCRE2_SIZE startoffset,
238                      uint32_t options,
239                      Pcre2Type<16>::MatchData *match_data,
240                      Pcre2Type<16>::MatchContext *mcontext,
241                      Pcre2Type<16>::Pcre2Sptr replacement,
242                      PCRE2_SIZE rlength,
243                      Pcre2Type<16>::Pcre2Uchar *outputbuffer,
244                      PCRE2_SIZE *outlengthptr){
245          return pcre2_substitute_16( code, subject, length, startoffset, options, match_data,
246                                     mcontext, replacement, rlength, outputbuffer, outlengthptr);
247      }
248      static void code_free(Pcre2Type<16>::Pcre2Code *code){
249          pcre2_code_free_16(code);
250      }
251      static int get_error_message(  int errorcode,
252                              Pcre2Type<16>::Pcre2Uchar *buffer,
253                              PCRE2_SIZE bufflen){
254          return pcre2_get_error_message_16(errorcode, buffer, bufflen);
255      }
256      static Pcre2Type<16>::MatchData * match_data_create_from_pattern(
257                                const Pcre2Type<16>::Pcre2Code *code,
258                                Pcre2Type<16>::GeneralContext *gcontext){
259          return pcre2_match_data_create_from_pattern_16(code, gcontext);
260      }
261      static int match(  const Pcre2Type<16>::Pcre2Code *code,
262                              Pcre2Type<16>::Pcre2Sptr subject,
263                              PCRE2_SIZE length,
264                              PCRE2_SIZE startoffset,
265                              uint32_t options,
266                              Pcre2Type<16>::MatchData *match_data,
267                              Pcre2Type<16>::MatchContext *mcontext){
268          return pcre2_match_16(code, subject, length, startoffset, options, match_data, mcontext);
269      }
270      static void match_data_free(Pcre2Type<16>::MatchData *match_data){
271          pcre2_match_data_free_16(match_data);
272      }
273      static PCRE2_SIZE * get_ovector_pointer(Pcre2Type<16>::MatchData *match_data){
274          return pcre2_get_ovector_pointer_16(match_data);
275      }
276      static int pattern_info(const Pcre2Type<16>::Pcre2Code *code, uint32_t what, void *where){
277          return pcre2_pattern_info_16(code, what, where);
278      }
279      static int set_newline(Pcre2Type<16>::CompileContext *ccontext, uint32_t value){
280          return pcre2_set_newline_16(ccontext, value);
281      }
282      static uint32_t get_ovector_count(Pcre2Type<16>::MatchData *match_data){
283          return pcre2_get_ovector_count_16(match_data);
284      }
285  };
286  template<> struct Pcre2Func<32> {
287      static Pcre2Type<32>::CompileContext* compile_context_create(Pcre2Type<32>::GeneralContext *gcontext){
288          return pcre2_compile_context_create_32(gcontext);
289      }
290      static void compile_context_free(Pcre2Type<32>::CompileContext *ccontext){
291          pcre2_compile_context_free_32(ccontext);
292      }
293      static Pcre2Type<32>::CompileContext* compile_context_copy(Pcre2Type<32>::CompileContext* ccontext){
294      return pcre2_compile_context_copy_32(ccontext);
295      }
296      static const unsigned char * maketables(Pcre2Type<32>::GeneralContext* gcontext){
297          return pcre2_maketables_32(gcontext);
298      }
299      static int set_character_tables(Pcre2Type<32>::CompileContext * ccontext, const unsigned char * table){
300          return pcre2_set_character_tables_32(ccontext, table);
301      }
302      static Pcre2Type<32>::Pcre2Code * compile(Pcre2Type<32>::Pcre2Sptr pattern,
303                                       PCRE2_SIZE length,
304                                       uint32_t options,
305                                       int *errorcode,
306                                       PCRE2_SIZE *erroroffset,
307                                       Pcre2Type<32>::CompileContext *ccontext){
308          return pcre2_compile_32(pattern, length, options, errorcode, erroroffset, ccontext);
309      }
310      static int jit_compile(Pcre2Type<32>::Pcre2Code *code, uint32_t options){
311          return pcre2_jit_compile_32(code, options);
312      }
313      static int substitute( const Pcre2Type<32>::Pcre2Code *code,
314                      Pcre2Type<32>::Pcre2Sptr subject,
315                      PCRE2_SIZE length,
316                      PCRE2_SIZE startoffset,
317                      uint32_t options,
318                      Pcre2Type<32>::MatchData *match_data,
319                      Pcre2Type<32>::MatchContext *mcontext,
320                      Pcre2Type<32>::Pcre2Sptr replacement,
321                      PCRE2_SIZE rlength,
322                      Pcre2Type<32>::Pcre2Uchar *outputbuffer,
323                      PCRE2_SIZE *outlengthptr){
324          return pcre2_substitute_32( code, subject, length, startoffset, options, match_data,
325                                     mcontext, replacement, rlength, outputbuffer, outlengthptr);
326      }
327      static void code_free(Pcre2Type<32>::Pcre2Code *code){
328          pcre2_code_free_32(code);
329      }
330      static int get_error_message(  int errorcode,
331                              Pcre2Type<32>::Pcre2Uchar *buffer,
332                              PCRE2_SIZE bufflen){
333          return pcre2_get_error_message_32(errorcode, buffer, bufflen);
334      }
335      static Pcre2Type<32>::MatchData * match_data_create_from_pattern(
336                                const Pcre2Type<32>::Pcre2Code *code,
337                                Pcre2Type<32>::GeneralContext *gcontext){
338          return pcre2_match_data_create_from_pattern_32(code, gcontext);
339      }
340      static int match(  const Pcre2Type<32>::Pcre2Code *code,
341                              Pcre2Type<32>::Pcre2Sptr subject,
342                              PCRE2_SIZE length,
343                              PCRE2_SIZE startoffset,
344                              uint32_t options,
345                              Pcre2Type<32>::MatchData *match_data,
346                              Pcre2Type<32>::MatchContext *mcontext){
347          return pcre2_match_32(code, subject, length, startoffset, options, match_data, mcontext);
348      }
349      static void match_data_free(Pcre2Type<32>::MatchData *match_data){
350          pcre2_match_data_free_32(match_data);
351      }
352      static PCRE2_SIZE * get_ovector_pointer(Pcre2Type<32>::MatchData *match_data){
353          return pcre2_get_ovector_pointer_32(match_data);
354      }
355      static int pattern_info(const Pcre2Type<32>::Pcre2Code *code, uint32_t what, void *where){
356          return pcre2_pattern_info_32(code, what, where);
357      }
358      static int set_newline(Pcre2Type<32>::CompileContext *ccontext, uint32_t value){
359          return pcre2_set_newline_32(ccontext, value);
360      }
361      static uint32_t get_ovector_count(Pcre2Type<32>::MatchData *match_data){
362          return pcre2_get_ovector_count_32(match_data);
363      }
364  };
365  class Modifier{
366      std::string mod;
367      public:
368      Modifier(){}
369      Modifier(std::string const& x):mod(x){}
370      Modifier(char const *x):mod(x?x:""){}
371      std::string str() const { return mod; }
372      char const * c_str() const { return mod.c_str(); }
373      SIZE_T length() const{ return mod.length(); }
374      char operator[](SIZE_T i) const { return mod[i]; }
375  };
376  namespace MOD {
377      static const char C_N[] = "eijmnsuxADJU";
378      static const jpcre2::Uint C_V[12] = { PCRE2_MATCH_UNSET_BACKREF,                  
379                                            PCRE2_CASELESS,                             
380                                            PCRE2_ALT_BSUX | PCRE2_MATCH_UNSET_BACKREF, 
381                                            PCRE2_MULTILINE,                            
382                                            PCRE2_UTF | PCRE2_UCP,                      
383                                            PCRE2_DOTALL,                               
384                                            PCRE2_UTF,                                  
385                                            PCRE2_EXTENDED,                             
386                                            PCRE2_ANCHORED,                             
387                                            PCRE2_DOLLAR_ENDONLY,                       
388                                            PCRE2_DUPNAMES,                             
389                                            PCRE2_UNGREEDY                              
390                                          };
391      static const char CJ_N[] = "S";
392      static const jpcre2::Uint CJ_V[1] = { JIT_COMPILE,                                
393                                          };
394      static const char R_N[] = "eEgx";
395      static const jpcre2::Uint R_V[4]  = {  PCRE2_SUBSTITUTE_UNSET_EMPTY,                
396                                             PCRE2_SUBSTITUTE_UNKNOWN_UNSET | PCRE2_SUBSTITUTE_UNSET_EMPTY,   
397                                             PCRE2_SUBSTITUTE_GLOBAL,                     
398                                             PCRE2_SUBSTITUTE_EXTENDED                    
399                                          };
400      static const char RJ_N[] = "";
401      static const jpcre2::Uint RJ_V[1] = { NONE  
402                                          };
403      static const char M_N[] = "A";
404      static const jpcre2::Uint M_V[1]  = { PCRE2_ANCHORED                               
405                                          };
406      static const char MJ_N[] = "g";
407      static const jpcre2::Uint MJ_V[1] = { FIND_ALL,                                   
408                                          };
409      static inline void toOption(Modifier const& mod, bool x,
410                                  Uint const * J_V, char const * J_N, SIZE_T SJ,
411                                  Uint const * V, char const * N, SIZE_T S,
412                                  Uint* po, Uint* jo,
413                                  int* en, SIZE_T* eo
414                                  ){
415          SIZE_T n = mod.length();
416          for (SIZE_T i = 0; i < n; ++i) {
417              for(SIZE_T j = 0; j < SJ; ++j){
418                  if(J_N[j] == mod[i]) {
419                      if(x) *jo |= J_V[j];
420                      else  *jo &= ~J_V[j];
421                      goto endfor;
422                  }
423              }
424              for(SIZE_T j = 0; j< S; ++j){
425                  if(N[j] == mod[i]){
426                      if(x) *po |= V[j];
427                      else  *po &= ~V[j];
428                      goto endfor;
429                  }
430              }
431              *en = (int)ERROR::INVALID_MODIFIER;
432              *eo = (int)mod[i];
433              endfor:;
434          }
435      }
436      static inline void toMatchOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo){
437          toOption(mod, x,
438                   MJ_V, MJ_N, sizeof(MJ_V)/sizeof(Uint),
439                   M_V, M_N, sizeof(M_V)/sizeof(Uint),
440                   po, jo, en, eo);
441      }
442      static inline void toReplaceOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo){
443          toOption(mod, x,
444                   RJ_V, RJ_N, sizeof(RJ_V)/sizeof(Uint),
445                   R_V, R_N, sizeof(R_V)/sizeof(Uint),
446                   po, jo, en, eo);
447      }
448      static inline void toCompileOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo){
449          toOption(mod, x,
450                   CJ_V, CJ_N, sizeof(CJ_V)/sizeof(Uint),
451                   C_V, C_N, sizeof(C_V)/sizeof(Uint),
452                   po, jo, en, eo);
453      }
454      static inline std::string fromOption(Uint const * J_V, char const * J_N, SIZE_T SJ,
455                                           Uint const * V, char const * N, SIZE_T S,
456                                           Uint po, Uint jo
457                                           ){
458          std::string mod;
459          for(SIZE_T i = 0; i < S; ++i){
460              if( (V[i] & po) != 0 &&
461                  (V[i] & po) == V[i]) 
462                  mod += N[i];
463          }
464          for(SIZE_T i = 0; i < SJ; ++i){
465              if( (J_V[i] & jo) != 0 &&
466                  (J_V[i] & jo) == J_V[i]) 
467                  mod += J_N[i];
468          }
469          return mod;
470      }
471      static inline std::string fromMatchOption(Uint po, Uint jo){
472          return fromOption(MJ_V, MJ_N, sizeof(MJ_V)/sizeof(Uint),
473                            M_V, M_N, sizeof(M_V)/sizeof(Uint),
474                            po, jo);
475      }
476      static inline std::string fromReplaceOption(Uint po, Uint jo){
477          return fromOption(RJ_V, RJ_N, sizeof(RJ_V)/sizeof(Uint),
478                            R_V, R_N, sizeof(R_V)/sizeof(Uint),
479                            po, jo);
480      }
481      static inline std::string fromCompileOption(Uint po, Uint jo){
482          return fromOption(CJ_V, CJ_N, sizeof(CJ_V)/sizeof(Uint),
483                            C_V, C_N, sizeof(C_V)/sizeof(Uint),
484                            po, jo);
485      }
486  } 
487  class ModifierTable{
488      std::string tabjms;
489      std::string tabms;
490      std::string tabjrs;
491      std::string tabrs;
492      std::string tabjcs;
493      std::string tabcs;
494      VecOpt tabjmv;
495      VecOpt tabmv;
496      VecOpt tabjrv;
497      VecOpt tabrv;
498      VecOpt tabjcv;
499      VecOpt tabcv;
500      void toOption(Modifier const& mod, bool x,
501                    VecOpt const& J_V, std::string const& J_N,
502                    VecOpt const& V, std::string const& N,
503                    Uint* po, Uint* jo, int* en, SIZE_T* eo
504                    ) const{
505          SIZE_T SJ = J_V.size();
506          SIZE_T S = V.size();
507          JPCRE2_ASSERT(SJ == J_N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(SJ) + " == " + _tostdstring(J_N.length()) + ").").c_str());
508          JPCRE2_ASSERT(S == N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(S) + " == " + _tostdstring(N.length()) + ").").c_str());
509          MOD::toOption(mod, x,
510                       J_V.empty()?0:&J_V[0], J_N.c_str(), SJ,
511                       V.empty()?0:&V[0], N.c_str(), S,
512                       po, jo, en, eo
513                       );
514      }
515      std::string fromOption(VecOpt const& J_V, std::string const& J_N,
516                             VecOpt const& V, std::string const& N,
517                             Uint po, Uint jo) const{
518          SIZE_T SJ = J_V.size();
<span onclick='openModal()' class='match'>519          SIZE_T S = V.size();
520          JPCRE2_ASSERT(SJ == J_N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(SJ) + " == " + _tostdstring(J_N.length()) + ").").c_str());
521          JPCRE2_ASSERT(S == N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(S) + " == " + _tostdstring(N.length()) + ").").c_str());
</span>522          return MOD::fromOption(J_V.empty()?0:&J_V[0], J_N.c_str(), SJ,
523                       V.empty()?0:&V[0], N.c_str(), S,
524                       po, jo);
525      }
526      void parseModifierTable(std::string& tabjs, VecOpt& tabjv,
527                              std::string& tab_s, VecOpt& tab_v,
528                              std::string const& tabs, VecOpt const& tabv);
529      public:
530      ModifierTable(){}
531      ModifierTable(bool deflt){
532          if(deflt) setAllToDefault();
533      }
534      ModifierTable& resetMatchModifierTable(){
535          std::string().swap(tabjms);
536          std::string().swap(tabms);
537          VecOpt().swap(tabjmv);
538          VecOpt().swap(tabmv);
539          return *this;
540      }
541      ModifierTable& resetReplaceModifierTable(){
542          std::string().swap(tabjrs);
543          std::string().swap(tabrs);
544          VecOpt().swap(tabjrv);
545          VecOpt().swap(tabrv);
546          return *this;
547      }
548      ModifierTable& resetCompileModifierTable(){
549          std::string().swap(tabjcs);
550          std::string().swap(tabcs);
551          VecOpt().swap(tabjcv);
552          VecOpt().swap(tabcv);
553          return *this;
554      }
555      ModifierTable& reset(){
556          resetMatchModifierTable();
557          resetReplaceModifierTable();
558          resetCompileModifierTable();
559          return *this;
560      }
561      ModifierTable& clearMatchModifierTable(){
562          tabjms.clear();
563          tabms.clear();
564          tabjmv.clear();
565          tabmv.clear();
566          return *this;
567      }
568      ModifierTable& clearReplaceModifierTable(){
569          tabjrs.clear();
570          tabrs.clear();
571          tabjrv.clear();
572          tabrv.clear();
573          return *this;
574      }
575      ModifierTable& clearCompileModifierTable(){
576          tabjcs.clear();
577          tabcs.clear();
578          tabjcv.clear();
579          tabcv.clear();
580          return *this;
581      }
582      ModifierTable& clear(){
583          clearMatchModifierTable();
584          clearReplaceModifierTable();
585          clearCompileModifierTable();
586          return *this;
587      }
588      void toMatchOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo) const {
589          toOption(mod, x,tabjmv,tabjms,tabmv, tabms,po,jo,en,eo);
590      }
591      void toReplaceOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo) const {
592          return toOption(mod, x,tabjrv,tabjrs,tabrv,tabrs,po,jo,en,eo);
593      }
594      void toCompileOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo) const {
595          return toOption(mod, x,tabjcv,tabjcs,tabcv,tabcs,po,jo,en,eo);
596      }
597      std::string fromMatchOption(Uint po, Uint jo) const {
598          return fromOption(tabjmv,tabjms,tabmv,tabms,po,jo);
599      }
600      std::string fromReplaceOption(Uint po, Uint jo) const {
601          return fromOption(tabjrv,tabjrs,tabrv,tabrs,po,jo);
602      }
603      std::string fromCompileOption(Uint po, Uint jo) const {
604          return fromOption(tabjcv,tabjcs,tabcv,tabcs,po,jo);
605      }
606      ModifierTable& setMatchModifierTable(std::string const& tabs, VecOpt const& tabv){
607          parseModifierTable(tabjms, tabjmv, tabms, tabmv, tabs, tabv);
608          return *this;
609      }
610      ModifierTable& setMatchModifierTable(std::string const& tabs, const Uint* tabvp){
611          if(tabvp) {
612              VecOpt tabv(tabvp, tabvp + tabs.length());
613              setMatchModifierTable(tabs, tabv);
614          } else clearMatchModifierTable();
615          return *this;
616      }
617      ModifierTable& setMatchModifierTable(const char* tabsp, const Uint* tabvp){
618          if(tabsp && tabvp) {
619              std::string tabs(tabsp);
620              VecOpt tabv(tabvp, tabvp + tabs.length());
621              setMatchModifierTable(tabs, tabv);
622          } else clearMatchModifierTable();
623          return *this;
624      }
625      ModifierTable& setReplaceModifierTable(std::string const& tabs, VecOpt const& tabv){
626          parseModifierTable(tabjrs, tabjrv, tabrs, tabrv, tabs, tabv);
627          return *this;
628      }
629      ModifierTable& setReplaceModifierTable(std::string const& tabs, const Uint* tabvp){
630          if(tabvp) {
631              VecOpt tabv(tabvp, tabvp + tabs.length());
632              setReplaceModifierTable(tabs, tabv);
633          } else clearReplaceModifierTable();
634          return *this;
635      }
636      ModifierTable& setReplaceModifierTable(const char* tabsp, const Uint* tabvp){
637          if(tabsp && tabvp) {
638              std::string tabs(tabsp);
639              VecOpt tabv(tabvp, tabvp + tabs.length());
640              setReplaceModifierTable(tabs, tabv);
641          } else clearReplaceModifierTable();
642          return *this;
643      }
644      ModifierTable& setCompileModifierTable(std::string const& tabs, VecOpt const& tabv){
645          parseModifierTable(tabjcs, tabjcv, tabcs, tabcv, tabs, tabv);
646          return *this;
647      }
648      ModifierTable& setCompileModifierTable(std::string const& tabs, const Uint* tabvp){
649          if(tabvp) {
650              VecOpt tabv(tabvp, tabvp + tabs.length());
651              setCompileModifierTable(tabs, tabv);
652          } else clearCompileModifierTable();
653          return *this;
654      }
655      ModifierTable& setCompileModifierTable(const char* tabsp, const Uint* tabvp){
656          if(tabsp && tabvp) {
657              std::string tabs(tabsp);
658              VecOpt tabv(tabvp, tabvp + tabs.length());
659              setCompileModifierTable(tabs, tabv);
660          } else clearCompileModifierTable();
661          return *this;
662      }
663      ModifierTable& setMatchModifierTableToDefault(){
664          tabjms = std::string(MOD::MJ_N, MOD::MJ_N + sizeof(MOD::MJ_V)/sizeof(Uint));
665          tabms = std::string(MOD::M_N, MOD::M_N  + sizeof(MOD::M_V)/sizeof(Uint));
666          tabjmv = VecOpt(MOD::MJ_V, MOD::MJ_V + sizeof(MOD::MJ_V)/sizeof(Uint));
667          tabmv = VecOpt(MOD::M_V, MOD::M_V + sizeof(MOD::M_V)/sizeof(Uint));
668          return *this;
669      }
670      ModifierTable& setReplaceModifierTableToDefault(){
671          tabjrs = std::string(MOD::RJ_N, MOD::RJ_N  + sizeof(MOD::RJ_V)/sizeof(Uint));
672          tabrs = std::string(MOD::R_N, MOD::R_N  + sizeof(MOD::R_V)/sizeof(Uint));
673          tabjrv = VecOpt(MOD::RJ_V, MOD::RJ_V + sizeof(MOD::RJ_V)/sizeof(Uint));
674          tabrv = VecOpt(MOD::R_V, MOD::R_V + sizeof(MOD::R_V)/sizeof(Uint));
675          return *this;
676      }
677      ModifierTable& setCompileModifierTableToDefault(){
678          tabjcs = std::string(MOD::CJ_N, MOD::CJ_N  + sizeof(MOD::CJ_V)/sizeof(Uint));
679          tabcs = std::string(MOD::C_N, MOD::C_N  + sizeof(MOD::C_V)/sizeof(Uint));
680          tabjcv = VecOpt(MOD::CJ_V, MOD::CJ_V + sizeof(MOD::CJ_V)/sizeof(Uint));
681          tabcv = VecOpt(MOD::C_V, MOD::C_V + sizeof(MOD::C_V)/sizeof(Uint));
682          return *this;
683      }
684      ModifierTable& setAllToDefault(){
685          setMatchModifierTableToDefault();
686          setReplaceModifierTableToDefault();
687          setCompileModifierTableToDefault();
688          return *this;
689      }
690  };
691  template<typename Char_T> struct MSG{
692      static std::basic_string<Char_T> INVALID_MODIFIER(void);
693      static std::basic_string<Char_T> INSUFFICIENT_OVECTOR(void);
694  };
695  template<> inline std::basic_string<char> MSG<char>::INVALID_MODIFIER(){ return "Invalid modifier: "; }
696  template<> inline std::basic_string<wchar_t> MSG<wchar_t>::INVALID_MODIFIER(){ return L"Invalid modifier: "; }
697  template<> inline std::basic_string<char> MSG<char>::INSUFFICIENT_OVECTOR(){ return "ovector wasn't big enough"; }
698  template<> inline std::basic_string<wchar_t> MSG<wchar_t>::INSUFFICIENT_OVECTOR(){ return L"ovector wasn't big enough"; }
699  #if JPCRE2_USE_MINIMUM_CXX_11
700  template<> inline std::basic_string<char16_t> MSG<char16_t>::INVALID_MODIFIER(){ return u"Invalid modifier: "; }
701  template<> inline std::basic_string<char32_t> MSG<char32_t>::INVALID_MODIFIER(){ return U"Invalid modifier: "; }
702  template<> inline std::basic_string<char16_t> MSG<char16_t>::INSUFFICIENT_OVECTOR(){ return u"ovector wasn't big enough"; }
703  template<> inline std::basic_string<char32_t> MSG<char32_t>::INSUFFICIENT_OVECTOR(){ return U"ovector wasn't big enough"; }
704  #endif
705  #if JPCRE2_USE_MINIMUM_CXX_11
706  template<typename Char_T, template<typename...> class Map=std::map>
707  #else
708  template<typename Char_T>
709  #endif
710  struct select{
711      typedef Char_T Char;
712      typedef typename std::basic_string<Char_T> String;
713      #if JPCRE2_USE_MINIMUM_CXX_11
714      typedef class Map<String, String> MapNas;
715      typedef class Map<String, SIZE_T> MapNtN;
716      #else
717      typedef typename std::map<String, String> MapNas;
718      typedef typename std::map<String, SIZE_T> MapNtN;
719      #endif
720      typedef MapNtN MapNtn;
721      typedef typename std::vector<String> NumSub;
722      typedef typename std::vector<MapNas> VecNas;
723      typedef typename std::vector<MapNtN> VecNtN;
724      typedef VecNtN VecNtn;
725      typedef typename std::vector<NumSub> VecNum;
726      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::Pcre2Uchar Pcre2Uchar;
727      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::Pcre2Sptr Pcre2Sptr;
728      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::Pcre2Code Pcre2Code;
729      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::CompileContext CompileContext;
730      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::MatchData MatchData;
731      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::GeneralContext GeneralContext;
732      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::MatchContext MatchContext;
733      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::JitCallback JitCallback;
734      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::JitStack JitStack;
735      template<typename T>
736      static String toString(T); 
737      static String toString(Char a){
738          return a?String(1, a):String();
739      }
740      static String toString(Char const *a){
741          return a?String(a):String();
742      }
743      static String toString(Char* a){
744          return a?String(a):String();
745      }
746      static String toString(Pcre2Uchar* a) {
747          return a?String((Char*) a):String();
748      }
749      static String getPcre2ErrorMessage(int err_num) {
750          Pcre2Uchar buffer[sizeof(Char)*CHAR_BIT*1024];
751          Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::get_error_message(err_num, buffer, sizeof(buffer));
752          return toString((Pcre2Uchar*) buffer);
753      }
754      static String getErrorMessage(int err_num, int err_off)  {
755          if(err_num == (int)ERROR::INVALID_MODIFIER){
756              return MSG<Char>::INVALID_MODIFIER() + toString((Char)err_off);
757          } else if(err_num == (int)ERROR::INSUFFICIENT_OVECTOR){
758              return MSG<Char>::INSUFFICIENT_OVECTOR();
759          } else if(err_num != 0) {
760              return getPcre2ErrorMessage((int) err_num);
761          } else return String();
762      }
763      class Regex;
764      class RegexMatch;
765      class RegexReplace;
766      class MatchEvaluator;
767      class RegexMatch {
768      private:
769          friend class MatchEvaluator;
770          Regex const *re;
771          String m_subject;
772          String const *m_subject_ptr;
773          Uint match_opts;
774          Uint jpcre2_match_opts;
775          MatchContext *mcontext;
776          ModifierTable const * modtab;
777          MatchData * mdata;
778          PCRE2_SIZE _start_offset; 
779          VecNum* vec_num;
780          VecNas* vec_nas;
781          VecNtN* vec_ntn;
782          VecOff* vec_soff;
783          VecOff* vec_eoff;
784          bool getNumberedSubstrings(int, Pcre2Sptr, PCRE2_SIZE*, uint32_t);
785          bool getNamedSubstrings(int, int, Pcre2Sptr, Pcre2Sptr, PCRE2_SIZE*);
786          void init_vars() {
787              re = 0;
788              vec_num = 0;
789              vec_nas = 0;
790              vec_ntn = 0;
791              vec_soff = 0;
792              vec_eoff = 0;
793              match_opts = 0;
794              jpcre2_match_opts = 0;
795              error_number = 0;
796              error_offset = 0;
797              _start_offset = 0;
798              m_subject_ptr = &m_subject;
799              mcontext = 0;
800              modtab = 0;
801              mdata = 0;
802          }
803          void onlyCopy(RegexMatch const &rm){
804              re = rm.re; 
805              m_subject_ptr = (rm.m_subject_ptr == &rm.m_subject) ? &m_subject  
806                                                                  : rm.m_subject_ptr;
807              vec_num = rm.vec_num;
808              vec_nas = rm.vec_nas;
809              vec_ntn = rm.vec_ntn;
810              vec_soff = rm.vec_soff;
811              vec_eoff = rm.vec_eoff;
812              match_opts = rm.match_opts;
813              jpcre2_match_opts = rm.jpcre2_match_opts;
814              error_number = rm.error_number;
815              error_offset = rm.error_offset;
816              _start_offset = rm._start_offset;
817              mcontext = rm.mcontext;
818              modtab = rm.modtab;
819              mdata = rm.mdata;
820          }
821          void deepCopy(RegexMatch const &rm){
822              m_subject = rm.m_subject;
823              onlyCopy(rm);
824          }
825          #if JPCRE2_USE_MINIMUM_CXX_11
826          void deepMove(RegexMatch& rm){
827              m_subject = std::move_if_noexcept(rm.m_subject);
828              onlyCopy(rm);
829          }
830          #endif
831          friend class Regex;
832          protected:
833          int error_number;
834          PCRE2_SIZE error_offset;
835      public:
836          RegexMatch(){
837              init_vars();
838          }
839          RegexMatch(Regex const *r) {
840              init_vars();
841              re = r;
842          }
843          RegexMatch(RegexMatch const &rm){
844              init_vars();
845              deepCopy(rm);
846          }
847          virtual RegexMatch& operator=(RegexMatch const &rm){
848              if(this == &rm) return *this;
849              deepCopy(rm);
850              return *this;
851          }
852          #if JPCRE2_USE_MINIMUM_CXX_11
853          RegexMatch(RegexMatch&& rm){
854              init_vars();
855              deepMove(rm);
856          }
857          virtual RegexMatch& operator=(RegexMatch&& rm){
858              if(this == &rm) return *this;
859              deepMove(rm);
860              return *this;
861          }
862          #endif
863          virtual ~RegexMatch() {}
864          virtual RegexMatch& reset() {
865              String().swap(m_subject); 
866              init_vars();
867              return *this;
868          }
869          virtual RegexMatch& clear(){
870              m_subject.clear(); 
871              init_vars();
872              return *this;
873          }
874          virtual RegexMatch& resetErrors(){
875              error_number = 0;
876              error_offset = 0;
877              return *this;
878          }
879          virtual int getErrorNumber() const {
880              return error_number;
881          }
882          virtual int getErrorOffset() const  {
883              return (int)error_offset;
884          }
885          virtual String getErrorMessage() const  {
886              #if JPCRE2_USE_MINIMUM_CXX_11
887              return select<Char, Map>::getErrorMessage(error_number, error_offset);
888              #else
889              return select<Char>::getErrorMessage(error_number, error_offset);
890              #endif
891          }
892          virtual String getSubject() const  {
893              return *m_subject_ptr;
894          }
895          virtual String const * getSubjectPointer() const  {
896              return m_subject_ptr;
897          }
898          virtual std::string getModifier() const {
899              return modtab ? modtab->fromMatchOption(match_opts, jpcre2_match_opts)
900                            : MOD::fromMatchOption(match_opts, jpcre2_match_opts);
901          }
902          virtual ModifierTable const* getModifierTable(){
903              return modtab;
904          }
905          virtual Uint getPcre2Option() const  {
906              return match_opts;
907          }
908          virtual Uint getJpcre2Option() const  {
909              return jpcre2_match_opts;
910          }
911          virtual PCRE2_SIZE getStartOffset() const  {
912              return _start_offset;
913          }
914          virtual VecOff const* getMatchStartOffsetVector() const {
915              return vec_soff;
916          }
917          virtual VecOff const* getMatchEndOffsetVector() const {
918              return vec_eoff;
919          }
920          virtual Regex const * getRegexObject() const {
921              return re;
922          }
923          virtual VecNum const* getNumberedSubstringVector() const {
924              return vec_num;
925          }
926          virtual VecNas const* getNamedSubstringVector() const {
927              return vec_nas;
928          }
929          virtual VecNtN const* getNameToNumberMapVector() const {
930              return vec_ntn;
931          }
932          virtual RegexMatch& setRegexObject(Regex const *r){
933              re = r;
934              return *this;
935          }
936          virtual RegexMatch& setNumberedSubstringVector(VecNum* v) {
937              vec_num = v;
938              return *this;
939          }
940          virtual RegexMatch& setNamedSubstringVector(VecNas* v) {
941              vec_nas = v;
942              return *this;
943          }
944          virtual RegexMatch& setNameToNumberMapVector(VecNtN* v) {
945              vec_ntn = v;
946              return *this;
947          }
948          virtual RegexMatch& setMatchStartOffsetVector(VecOff* v){
949              vec_soff = v;
950              return *this;
951          }
952          virtual RegexMatch& setMatchEndOffsetVector(VecOff* v){
953              vec_eoff = v;
954              return *this;
955          }
956          virtual RegexMatch& setSubject(String const &s) {
957              m_subject = s;
958              m_subject_ptr = &m_subject; 
959              return *this;
960          }
961          virtual RegexMatch& setSubject(String const *s) {
962              if(s) m_subject_ptr = s;
963              else {
964                  m_subject.clear();
965                  m_subject_ptr = &m_subject;
966              }
967              return *this;
968          }
969          virtual RegexMatch& setModifier(Modifier const& s) {
970              match_opts = 0;
971              jpcre2_match_opts = 0;
972              changeModifier(s, true);
973              return *this;
974          }
975          virtual RegexMatch& setModifierTable(ModifierTable const * mdt){
976              modtab = mdt;
977              return *this;
978          }
979          virtual RegexMatch& setJpcre2Option(Uint x) {
980              jpcre2_match_opts = x;
981              return *this;
982          }
983          virtual RegexMatch& setPcre2Option(Uint x) {
984              match_opts = x;
985              return *this;
986          }
987          virtual RegexMatch& setFindAll(bool x) {
988              jpcre2_match_opts = x?jpcre2_match_opts | FIND_ALL:jpcre2_match_opts & ~FIND_ALL;
989              return *this;
990          }
991          virtual RegexMatch& setFindAll() {
992              return setFindAll(true);
993          }
994          virtual RegexMatch& setStartOffset(PCRE2_SIZE offset) {
995              _start_offset = offset;
996              return *this;
997          }
998          virtual RegexMatch& setMatchContext(MatchContext *match_context){
999              mcontext = match_context;
1000              return *this;
1001          }
1002          virtual MatchContext* getMatchContext(){
1003              return mcontext;
1004          }
1005          virtual RegexMatch& setMatchDataBlock(MatchData* madt){
1006              mdata = madt;
1007              return *this;
1008          }
1009          virtual MatchData* getMatchDataBlock(){
1010              return mdata;
1011          }
1012          virtual RegexMatch& changeModifier(Modifier const& mod, bool x){
1013              modtab ? modtab->toMatchOption(mod, x, &match_opts, &jpcre2_match_opts, &error_number, &error_offset)
1014                     : MOD::toMatchOption(mod, x, &match_opts, &jpcre2_match_opts, &error_number, &error_offset);
1015              return *this;
1016          }
1017          virtual RegexMatch& changeJpcre2Option(Uint opt, bool x) {
1018              jpcre2_match_opts = x ? jpcre2_match_opts | opt : jpcre2_match_opts & ~opt;
1019              return *this;
1020          }
1021          virtual RegexMatch& changePcre2Option(Uint opt, bool x) {
1022              match_opts = x ? match_opts | opt : match_opts & ~opt;
1023              return *this;
1024          }
1025          virtual RegexMatch& addModifier(Modifier const& mod){
1026              return changeModifier(mod, true);
1027          }
1028          virtual RegexMatch& addJpcre2Option(Uint x) {
1029              jpcre2_match_opts |= x;
1030              return *this;
1031          }
1032          virtual RegexMatch& addPcre2Option(Uint x) {
1033              match_opts |= x;
1034              return *this;
1035          }
1036          virtual SIZE_T match(void);
1037      };
1038      template<typename T1, typename T2, typename T3>
1039      struct MatchEvaluatorCallback{
1040          #if !defined JPCRE2_USE_FUNCTION_POINTER_CALLBACK && JPCRE2_USE_MINIMUM_CXX_11
1041          typedef std::function<String (T1,T2,T3)> Callback;
1042          #else
1043          typedef String (*Callback)(T1,T2,T3);
1044          #endif
1045      };
1046      struct callback{
1047          static String eraseFill(NumSub const &num, MapNas const &nas, MapNtN const &ntn){
1048              return String();
1049          }
1050          static String erase(void*, void*, void*){
1051              return String();
1052          }
1053          static String fill(NumSub const &num, MapNas const &nas, MapNtn const &ntn){
1054              return num[0];
1055          }
1056          private:
1057          callback();
1058          callback(callback const &);
1059          #if JPCRE2_USE_MINIMUM_CXX_11
1060          callback(callback&&);
1061          #endif
1062          ~callback();
1063      };
1064      class MatchEvaluator: virtual public RegexMatch{
1065          private:
1066          friend class RegexReplace;
1067          VecNum vec_num;
1068          VecNas vec_nas;
1069          VecNtN vec_ntn;
1070          VecOff vec_soff;
1071          VecOff vec_eoff;
1072          int callbackn;
1073          typename MatchEvaluatorCallback<void*, void*, void*>::Callback callback0;
1074          typename MatchEvaluatorCallback<NumSub const &, void*, void*>::Callback callback1;
1075          typename MatchEvaluatorCallback<void*, MapNas const &, void*>::Callback callback2;
1076          typename MatchEvaluatorCallback<NumSub const &, MapNas const &, void*>::Callback callback3;
1077          typename MatchEvaluatorCallback<void*, void*, MapNtN const &>::Callback callback4;
1078          typename MatchEvaluatorCallback<NumSub const &, void*, MapNtN const &>::Callback callback5;
1079          typename MatchEvaluatorCallback<void*, MapNas const &, MapNtN const &>::Callback callback6;
1080          typename MatchEvaluatorCallback<NumSub const &, MapNas const &, MapNtN const &>::Callback callback7;
1081          PCRE2_SIZE buffer_size;
1082          void init(){
1083              callbackn = 0;
1084              callback0 = callback::erase;
1085              callback1 = 0;
1086              callback2 = 0;
1087              callback3 = 0;
1088              callback4 = 0;
1089              callback5 = 0;
1090              callback6 = 0;
1091              callback7 = 0;
1092              setMatchStartOffsetVector(&vec_soff);
1093              setMatchEndOffsetVector(&vec_eoff);
1094              buffer_size = 0;
1095          }
1096          void setVectorPointersAccordingToCallback(){
1097              switch(callbackn){
1098                  case 0: break;
1099                  case 1: setNumberedSubstringVector(&vec_num);break;
1100                  case 2: setNamedSubstringVector(&vec_nas);break;
1101                  case 3: setNumberedSubstringVector(&vec_num).setNamedSubstringVector(&vec_nas);break;
1102                  case 4: setNameToNumberMapVector(&vec_ntn);break;
1103                  case 5: setNumberedSubstringVector(&vec_num).setNameToNumberMapVector(&vec_ntn);break;
1104                  case 6: setNamedSubstringVector(&vec_nas).setNameToNumberMapVector(&vec_ntn);break;
1105                  case 7: setNumberedSubstringVector(&vec_num).setNamedSubstringVector(&vec_nas).setNameToNumberMapVector(&vec_ntn);break;
1106              }
1107          }
1108          void onlyCopy(MatchEvaluator const &me){
1109              callbackn = me.callbackn;
1110              callback0 = me.callback0;
1111              callback1 = me.callback1;
1112              callback2 = me.callback2;
1113              callback3 = me.callback3;
1114              callback4 = me.callback4;
1115              callback5 = me.callback5;
1116              callback6 = me.callback6;
1117              callback7 = me.callback7;
1118              setVectorPointersAccordingToCallback();
1119              buffer_size = me.buffer_size;
1120          }
1121          void deepCopy(MatchEvaluator const &me) {
1122              vec_num = me.vec_num;
1123              vec_nas = me.vec_nas;
1124              vec_ntn = me.vec_ntn;
1125              vec_soff = me.vec_soff;
1126              vec_eoff = me.vec_eoff;
1127              onlyCopy(me);
1128          }
1129          #if JPCRE2_USE_MINIMUM_CXX_11
1130          void deepMove(MatchEvaluator& me){
1131              vec_num = std::move_if_noexcept(me.vec_num);
1132              vec_nas = std::move_if_noexcept(me.vec_nas);
1133              vec_ntn = std::move_if_noexcept(me.vec_ntn);
1134              vec_soff = std::move_if_noexcept(me.vec_soff);
1135              vec_eoff = std::move_if_noexcept(me.vec_eoff);
1136              onlyCopy(me);
1137          }
1138          #endif
1139          MatchEvaluator& setNumberedSubstringVector(VecNum* v){
1140              RegexMatch::setNumberedSubstringVector(v);
1141              return *this;
1142          }
1143          MatchEvaluator& setNamedSubstringVector(VecNas* v){
1144              RegexMatch::setNamedSubstringVector(v);
1145              return *this;
1146          }
1147          MatchEvaluator& setNameToNumberMapVector(VecNtN* v){
1148              RegexMatch::setNameToNumberMapVector(v);
1149              return *this;
1150          }
1151          MatchEvaluator& setMatchStartOffsetVector(VecOff* v){
1152              RegexMatch::setMatchStartOffsetVector(v);
1153              return *this;
1154          }
1155          MatchEvaluator& setMatchEndOffsetVector(VecOff* v){
1156              RegexMatch::setMatchEndOffsetVector(v);
1157              return *this;
1158          }
1159          public:
1160          explicit
1161          MatchEvaluator():RegexMatch(){
1162              init();
1163          }
1164          explicit
1165          MatchEvaluator(Regex const *r):RegexMatch(r){
1166              init();
1167          }
1168          explicit
1169          MatchEvaluator(typename MatchEvaluatorCallback<void*, void*, void*>::Callback mef): RegexMatch(){
1170              init();
1171              setCallback(mef);
1172          }
1173          explicit
1174          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, void*, void*>::Callback mef): RegexMatch(){
1175              init();
1176              setCallback(mef);
1177          }
1178          explicit
1179          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, void*>::Callback mef): RegexMatch(){
1180              init();
1181              setCallback(mef);
1182          }
1183          explicit
1184          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, void*,  MapNtN const &>::Callback mef): RegexMatch(){
1185              init();
1186              setCallback(mef);
1187          }
1188          explicit
1189          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, MapNtN const &>::Callback mef): RegexMatch(){
1190              init();
1191              setCallback(mef);
1192          }
1193          explicit
1194          MatchEvaluator(typename MatchEvaluatorCallback<void*, MapNas const &, void*>::Callback mef): RegexMatch(){
1195              init();
1196              setCallback(mef);
1197          }
1198          explicit
1199          MatchEvaluator(typename MatchEvaluatorCallback<void*, MapNas const &,  MapNtN const &>::Callback mef): RegexMatch(){
1200              init();
1201              setCallback(mef);
1202          }
1203          explicit
1204          MatchEvaluator(typename MatchEvaluatorCallback<void*, void*,  MapNtN const &>::Callback mef): RegexMatch(){
1205              init();
1206              setCallback(mef);
1207          }
1208          MatchEvaluator(MatchEvaluator const &me): RegexMatch(me){
1209              init();
1210              deepCopy(me);
1211          }
1212          MatchEvaluator& operator=(MatchEvaluator const &me){
1213              if(this == &me) return *this;
1214              RegexMatch::operator=(me);
1215              deepCopy(me);
1216              return *this;
1217          }
1218          #if JPCRE2_USE_MINIMUM_CXX_11
1219          MatchEvaluator(MatchEvaluator&& me): RegexMatch(me){
1220              init();
1221              deepMove(me);
1222          }
1223          MatchEvaluator& operator=(MatchEvaluator&& me){
1224              if(this == &me) return *this;
1225              RegexMatch::operator=(me);
1226              deepMove(me);
1227              return *this;
1228          }
1229          #endif
1230          virtual ~MatchEvaluator(){}
1231          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, void*, void*>::Callback mef){
1232              callback0 = mef;
1233              callbackn = 0;
1234              return *this;
1235          }
1236          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, void*, void*>::Callback mef){
1237              callback1 = mef;
1238              callbackn = 1;
1239              setNumberedSubstringVector(&vec_num);
1240              return *this;
1241          }
1242          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, void*>::Callback mef){
1243              callback3 = mef;
1244              callbackn = 3;
1245              setNumberedSubstringVector(&vec_num);
1246              setNamedSubstringVector(&vec_nas);
1247              return *this;
1248          }
1249          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, void*,  MapNtN const &>::Callback mef){
1250              callback5 = mef;
1251              callbackn = 5;
1252              setNumberedSubstringVector(&vec_num);
1253              setNameToNumberMapVector(&vec_ntn);
1254              return *this;
1255          }
1256          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, MapNtN const &>::Callback mef){
1257              callback7 = mef;
1258              callbackn = 7;
1259              setNumberedSubstringVector(&vec_num);
1260              setNamedSubstringVector(&vec_nas);
1261              setNameToNumberMapVector(&vec_ntn);
1262              return *this;
1263          }
1264          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, MapNas const &, void*>::Callback mef){
1265              callback2 = mef;
1266              callbackn = 2;
1267              setNamedSubstringVector(&vec_nas);
1268              return *this;
1269          }
1270          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, MapNas const &,  MapNtN const &>::Callback mef){
1271              callback6 = mef;
1272              callbackn = 6;
1273              setNamedSubstringVector(&vec_nas);
1274              setNameToNumberMapVector(&vec_ntn);
1275              return *this;
1276          }
1277          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, void*,  MapNtN const &>::Callback mef){
1278              callback4 = mef;
1279              callbackn = 4;
1280              setNameToNumberMapVector(&vec_ntn);
1281              return *this;
1282          }
1283          MatchEvaluator& clearMatchData(){
1284              vec_num.clear();
1285              vec_nas.clear();
1286              vec_ntn.clear();
1287              vec_soff.clear();
1288              vec_eoff.clear();
1289              return *this;
1290          }
1291          MatchEvaluator& resetMatchData(){
1292              VecNum().swap(vec_num);
1293              VecNas().swap(vec_nas);
1294              VecNtN().swap(vec_ntn);
1295              VecOff().swap(vec_soff);
1296              VecOff().swap(vec_eoff);
1297              return *this;
1298          }
1299          MatchEvaluator& reset(){
1300              RegexMatch::reset();
1301              resetMatchData();
1302              init();
1303              return *this;
1304          }
1305          MatchEvaluator& clear(){
1306              RegexMatch::clear();
1307              clearMatchData();
1308              init();
1309              return *this;
1310          }
1311          MatchEvaluator& resetErrors(){
1312              RegexMatch::resetErrors();
1313              return *this;
1314          }
1315          MatchEvaluator& setRegexObject (Regex const *r){
1316              RegexMatch::setRegexObject(r);
1317              return *this;
1318          }
1319          MatchEvaluator& setSubject (String const &s){
1320              RegexMatch::setSubject(s);
1321              return *this;
1322          }
1323          MatchEvaluator& setSubject (String const *s){
1324              RegexMatch::setSubject(s);
1325              return *this;
1326          }
1327          MatchEvaluator& setModifier (Modifier const& s){
1328              RegexMatch::setModifier(s);
1329              return *this;
1330          }
1331          MatchEvaluator& setModifierTable (ModifierTable const * mdt){
1332              RegexMatch::setModifierTable(mdt);
1333              return *this;
1334          }
1335          MatchEvaluator& setJpcre2Option (Uint x){
1336              RegexMatch::setJpcre2Option(x);
1337              return *this;
1338          }
1339          MatchEvaluator& setPcre2Option (Uint x){
1340              RegexMatch::setPcre2Option(x);
1341              return *this;
1342          }
1343          MatchEvaluator& setFindAll (bool x){
1344              RegexMatch::setFindAll(x);
1345              return *this;
1346          }
1347          MatchEvaluator& setFindAll(){
1348              RegexMatch::setFindAll();
1349              return *this;
1350          }
1351          MatchEvaluator& setStartOffset (PCRE2_SIZE offset){
1352              RegexMatch::setStartOffset(offset);
1353              return *this;
1354          }
1355          MatchEvaluator& setMatchContext (MatchContext *match_context){
1356              RegexMatch::setMatchContext(match_context);
1357              return *this;
1358          }
1359          MatchEvaluator& setMatchDataBlock(MatchData* mdt){
1360              RegexMatch::setMatchDataBlock(mdt);
1361              return *this;
1362          }
1363          MatchEvaluator& setBufferSize(PCRE2_SIZE x){
1364              buffer_size = x;
1365              return *this;
1366          }
1367          PCRE2_SIZE getBufferSize(){
1368              return buffer_size;
1369          }
1370          MatchEvaluator& changeModifier (Modifier const& mod, bool x){
1371              RegexMatch::changeModifier(mod, x);
1372              return *this;
1373          }
1374          MatchEvaluator& changeJpcre2Option (Uint opt, bool x){
1375              RegexMatch::changeJpcre2Option(opt, x);
1376              return *this;
1377          }
1378          MatchEvaluator& changePcre2Option (Uint opt, bool x){
1379              RegexMatch::changePcre2Option(opt, x);
1380              return *this;
1381          }
1382          MatchEvaluator& addModifier (Modifier const& mod){
1383              RegexMatch::addModifier(mod);
1384              return *this;
1385          }
1386          MatchEvaluator& addJpcre2Option (Uint x){
1387              RegexMatch::addJpcre2Option(x);
1388              return *this;
1389          }
1390          MatchEvaluator& addPcre2Option (Uint x){
1391              RegexMatch::addPcre2Option(x);
1392              return *this;
1393          }
1394          SIZE_T match(void){
1395              RegexMatch::changePcre2Option(PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT, false);
1396              return RegexMatch::match();
1397          }
1398          String nreplace(bool do_match=true, Uint jro=0, SIZE_T* counter=0);
1399          String replace(bool do_match=true, Uint ro=0, SIZE_T* counter=0);
1400      };
1401      class RegexReplace {
1402      private:
1403          friend class Regex;
1404          Regex const *re;
1405          String r_subject;
1406          String *r_subject_ptr; 
1407          String r_replw;
1408          String const *r_replw_ptr;
1409          Uint replace_opts;
1410          Uint jpcre2_replace_opts;
1411          PCRE2_SIZE buffer_size;
1412          PCRE2_SIZE _start_offset;
1413          MatchData *mdata;
1414          MatchContext *mcontext;
1415          ModifierTable const * modtab;
1416          SIZE_T last_replace_count;
1417          SIZE_T* last_replace_counter;
1418          void init_vars() {
1419              re = 0;
1420              r_subject_ptr = &r_subject;
1421              r_replw_ptr = &r_replw;
1422              replace_opts = PCRE2_SUBSTITUTE_OVERFLOW_LENGTH;
1423              jpcre2_replace_opts = 0;
1424              buffer_size = 0;
1425              error_number = 0;
1426              error_offset = 0;
1427              _start_offset = 0;
1428              mdata = 0;
1429              mcontext = 0;
1430              modtab = 0;
1431              last_replace_count = 0;
1432              last_replace_counter = &last_replace_count;
1433          }
1434          void onlyCopy(RegexReplace const &rr){
1435              re = rr.re; 
1436              r_subject_ptr = (rr.r_subject_ptr == &rr.r_subject) ? &r_subject 
1437                                                                  : rr.r_subject_ptr; 
1438              r_replw = rr.r_replw;
1439              r_replw_ptr = (rr.r_replw_ptr == &rr.r_replw) ? &r_replw 
1440                                                            : rr.r_replw_ptr; 
1441              replace_opts = rr.replace_opts;
1442              jpcre2_replace_opts = rr.jpcre2_replace_opts;
1443              buffer_size = rr.buffer_size;
1444              error_number = rr.error_number;
1445              error_offset = rr.error_offset;
1446              _start_offset = rr._start_offset;
1447              mdata = rr.mdata;
1448              mcontext = rr.mcontext;
1449              modtab = rr.modtab;
1450              last_replace_count = rr.last_replace_count;
1451              last_replace_counter = (rr.last_replace_counter == &rr.last_replace_count) ? &last_replace_count
1452                                                                                         : rr.last_replace_counter;
1453          }
1454          void deepCopy(RegexReplace const &rr){
1455              r_subject = rr.r_subject;
1456              onlyCopy(rr);
1457          }
1458          #if JPCRE2_USE_MINIMUM_CXX_11
1459          void deepMove(RegexReplace& rr){
1460              r_subject = std::move_if_noexcept(rr.r_subject);
1461              onlyCopy(rr);
1462          }
1463          #endif
1464          protected:
1465          int error_number;
1466          PCRE2_SIZE error_offset;
1467      public:
1468          RegexReplace(){
1469              init_vars();
1470          }
1471          RegexReplace(Regex const *r) {
1472              init_vars();
1473              re = r;
1474          }
1475          RegexReplace(RegexReplace const &rr){
1476              init_vars();
1477              deepCopy(rr);
1478          }
1479          RegexReplace& operator=(RegexReplace const &rr){
1480              if(this == &rr) return *this;
1481              deepCopy(rr);
1482              return *this;
1483          }
1484          #if JPCRE2_USE_MINIMUM_CXX_11
1485          RegexReplace(RegexReplace&& rr){
1486              init_vars();
1487              deepMove(rr);
1488          }
1489          RegexReplace& operator=(RegexReplace&& rr){
1490              if(this == &rr) return *this;
1491              deepMove(rr);
1492              return *this;
1493          }
1494          #endif
1495          virtual ~RegexReplace() {}
1496          RegexReplace& reset() {
1497              String().swap(r_subject);
1498              String().swap(r_replw);
1499              init_vars();
1500              return *this;
1501          }
1502          RegexReplace& clear() {
1503              r_subject.clear();
1504              r_replw.clear();
1505              init_vars();
1506              return *this;
1507          }
1508          RegexReplace& resetErrors(){
1509              error_number = 0;
1510              error_offset = 0;
1511              return *this;
1512          }
1513          int getErrorNumber() const {
1514              return error_number;
1515          }
1516          int getErrorOffset() const  {
1517              return (int)error_offset;
1518          }
1519          String getErrorMessage() const  {
1520              #if JPCRE2_USE_MINIMUM_CXX_11
1521              return select<Char, Map>::getErrorMessage(error_number, error_offset);
1522              #else
1523              return select<Char>::getErrorMessage(error_number, error_offset);
1524              #endif
1525          }
1526          String getReplaceWith() const  {
1527              return *r_replw_ptr;
1528          }
1529          String const * getReplaceWithPointer() const  {
1530              return r_replw_ptr;
1531          }
1532          String getSubject() const  {
1533              return *r_subject_ptr;
1534          }
1535          String const *  getSubjectPointer() const  {
1536              return r_subject_ptr;
1537          }
1538          std::string getModifier() const {
1539              return modtab ? modtab->fromReplaceOption(replace_opts, jpcre2_replace_opts)
1540                            : MOD::fromReplaceOption(replace_opts, jpcre2_replace_opts);
1541          }
1542          ModifierTable const* getModifierTable(){
1543              return modtab;
1544          }
1545          PCRE2_SIZE getStartOffset() const {
1546              return _start_offset;
1547          }
1548          Uint getPcre2Option() const  {
1549              return replace_opts;
1550          }
1551          Uint getJpcre2Option() const  {
1552              return jpcre2_replace_opts;
1553          }
1554          Regex const * getRegexObject() const {
1555              return re;
1556          }
1557          MatchContext* getMatchContext(){
1558              return mcontext;
1559          }
1560          virtual MatchData* getMatchDataBlock(){
1561              return mdata;
1562          }
1563          PCRE2_SIZE getBufferSize(){
1564              return buffer_size;
1565          }
1566          SIZE_T getLastReplaceCount(){
1567              return *last_replace_counter;
1568          }
1569          RegexReplace& setReplaceCounter(SIZE_T* counter){
1570              last_replace_count = 0;
1571              last_replace_counter = counter ? counter : &last_replace_count;
1572              return *this;
1573          }
1574          RegexReplace& setRegexObject(Regex const *r){
1575              re = r;
1576              return *this;
1577          }
1578          RegexReplace& setSubject(String const &s) {
1579              r_subject = s;
1580              r_subject_ptr = &r_subject; 
1581              return *this;
1582          }
1583          RegexReplace& setSubject(String *s) {
1584              if(s) r_subject_ptr = s;
1585              else {
1586                  r_subject.clear();
1587                  r_subject_ptr = &r_subject;
1588              }
1589              return *this;
1590          }
1591          RegexReplace& setReplaceWith(String const &s) {
1592              r_replw = s;
1593              r_replw_ptr = &r_replw; 
1594              return *this;
1595          }
1596          RegexReplace& setReplaceWith(String const *s) {
1597              if(s) r_replw_ptr = s;
1598              else {
1599                  r_replw.clear();
1600                  r_replw_ptr = &r_replw;
1601              }
1602              return *this;
1603          }
1604          RegexReplace& setModifier(Modifier const& s) {
1605              replace_opts = PCRE2_SUBSTITUTE_OVERFLOW_LENGTH; &bsol;* must not be initialized to 0 */
1606              jpcre2_replace_opts = 0;
1607              return changeModifier(s, true);
1608          }
1609          RegexReplace& setModifierTable(ModifierTable const * mdt){
1610              modtab = mdt;
1611              return *this;
1612          }
1613          RegexReplace& setBufferSize(PCRE2_SIZE x) {
1614              buffer_size = x;
1615              return *this;
1616          }
1617          RegexReplace& setStartOffset(PCRE2_SIZE start_offset){
1618              _start_offset = start_offset;
1619              return *this;
1620          }
1621          RegexReplace& setJpcre2Option(Uint x) {
1622              jpcre2_replace_opts = x;
1623              return *this;
1624          }
1625          RegexReplace& setPcre2Option(Uint x) {
1626              replace_opts = PCRE2_SUBSTITUTE_OVERFLOW_LENGTH | x;
1627              return *this;
1628          }
1629          RegexReplace& setMatchContext(MatchContext * match_context){
1630              mcontext = match_context;
1631              return *this;
1632          }
1633          RegexReplace& setMatchDataBlock(MatchData *match_data){
1634              mdata = match_data;
1635              return *this;
1636          }
1637          RegexReplace& changeModifier(Modifier const& mod, bool x){
1638              modtab ? modtab->toReplaceOption(mod, x, &replace_opts, &jpcre2_replace_opts, &error_number, &error_offset)
1639                     : MOD::toReplaceOption(mod, x, &replace_opts, &jpcre2_replace_opts, &error_number, &error_offset);
1640              return *this;
1641          }
1642          RegexReplace& changeJpcre2Option(Uint opt, bool x) {
1643              jpcre2_replace_opts = x ? jpcre2_replace_opts | opt : jpcre2_replace_opts & ~opt;
1644              return *this;
1645          }
1646          RegexReplace& changePcre2Option(Uint opt, bool x) {
1647              replace_opts = x ? replace_opts | opt : replace_opts & ~opt;
1648              return *this;
1649          }
1650          RegexReplace& addModifier(Modifier const& mod){
1651              return changeModifier(mod, true);
1652          }
1653          RegexReplace& addJpcre2Option(Uint x) {
1654              jpcre2_replace_opts |= x;
1655              return *this;
1656          }
1657          RegexReplace& addPcre2Option(Uint x) {
1658              replace_opts |= x;
1659              return *this;
1660          }
1661          String replace(void);
1662          SIZE_T preplace(void){
1663              *r_subject_ptr = replace();
1664              return *last_replace_counter;
1665          }
1666          SIZE_T preplace(MatchEvaluator me){
1667              *r_subject_ptr = me.setRegexObject(getRegexObject())
1668                                 .setSubject(r_subject_ptr) 
1669                                 .setFindAll((getPcre2Option() & PCRE2_SUBSTITUTE_GLOBAL)!=0)
1670                                 .setMatchContext(getMatchContext())
1671                                 .setMatchDataBlock(getMatchDataBlock())
1672                                 .setBufferSize(getBufferSize())
1673                                 .setStartOffset(getStartOffset())
1674                                 .replace(true, getPcre2Option(), last_replace_counter);
1675              return *last_replace_counter;
1676          }
1677          String nreplace(MatchEvaluator me){
1678              return me.setRegexObject(getRegexObject())
1679                       .setSubject(getSubjectPointer())
1680                       .setFindAll((getPcre2Option() & PCRE2_SUBSTITUTE_GLOBAL)!=0)
1681                       .setMatchContext(getMatchContext())
1682                       .setMatchDataBlock(getMatchDataBlock())
1683                       .setStartOffset(getStartOffset())
1684                       .nreplace(true, getJpcre2Option(), last_replace_counter);
1685          }
1686          String replace(MatchEvaluator me){
1687              return me.setRegexObject(getRegexObject())
1688                       .setSubject(getSubjectPointer())
1689                       .setFindAll((getPcre2Option() & PCRE2_SUBSTITUTE_GLOBAL)!=0)
1690                       .setMatchContext(getMatchContext())
1691                       .setMatchDataBlock(getMatchDataBlock())
1692                       .setBufferSize(getBufferSize())
1693                       .setStartOffset(getStartOffset())
1694                       .replace(true, getPcre2Option(), last_replace_counter);
1695          }
1696      };
1697      class Regex {
1698      private:
1699          friend class RegexMatch;
1700          friend class RegexReplace;
1701          friend class MatchEvaluator;
1702          String pat_str;
1703          String const *pat_str_ptr;
1704          Pcre2Code *code;
1705          Uint compile_opts;
1706          Uint jpcre2_compile_opts;
1707          ModifierTable const * modtab;
1708          CompileContext *ccontext;
1709          std::vector<unsigned char> tabv;
1710          void init_vars() {
1711              jpcre2_compile_opts = 0;
1712              compile_opts = 0;
1713              error_number = 0;
1714              error_offset = 0;
1715              code = 0;
1716              pat_str_ptr = &pat_str;
1717              ccontext = 0;
1718              modtab = 0;
1719          }
1720          void freeRegexMemory(void) {
1721              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::code_free(code);
1722              code = 0; 
1723          }
1724          void freeCompileContext(){
1725              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_free(ccontext);
1726              ccontext = 0;
1727          }
1728          void onlyCopy(Regex const &r){
1729              pat_str_ptr = (r.pat_str_ptr == &r.pat_str) ? &pat_str 
1730                                                          : r.pat_str_ptr; 
1731              compile_opts = r.compile_opts;
1732              jpcre2_compile_opts = r.jpcre2_compile_opts;
1733              error_number = r.error_number;
1734              error_offset = r.error_offset;
1735              modtab = r.modtab;
1736          }
1737          void deepCopy(Regex const &r) {
1738              pat_str = r.pat_str; 
1739              onlyCopy(r);
1740              tabv = r.tabv;
1741              freeCompileContext();
1742              ccontext = (r.ccontext) ? Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_copy(r.ccontext) : 0;
1743              if(ccontext  && !tabv.empty()) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_character_tables(ccontext, &tabv[0]);
1744              r.code ? compile() 
1745                     : freeRegexMemory();
1746          }
1747          #if JPCRE2_USE_MINIMUM_CXX_11
1748          void deepMove(Regex& r) {
1749              pat_str = std::move_if_noexcept(r.pat_str);
1750              onlyCopy(r);
1751              tabv = std::move_if_noexcept(r.tabv);
1752              freeCompileContext();
1753              ccontext = r.ccontext; r.ccontext = 0; 
1754              if(ccontext && !tabv.empty()) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_character_tables(ccontext, &tabv[0]);
1755              freeRegexMemory();
1756              code = r.code; r.code = 0; 
1757          }
1758          #endif
1759          protected:
1760          int error_number;
1761          PCRE2_SIZE error_offset;
1762      public:
1763          Regex() {
1764              init_vars();
1765          }
1766          Regex(String const &re) {
1767              init_vars();
1768              compile(re);
1769          }
1770          Regex(String const *re) {
1771              init_vars();
1772              compile(re);
1773          }
1774          Regex(String const &re, Modifier const& mod) {
1775              init_vars();
1776              compile(re, mod);
1777          }
1778          Regex(String const *re, Modifier const& mod) {
1779              init_vars();
1780              compile(re, mod);
1781          }
1782          Regex(String const &re, Uint po) {
1783              init_vars();
1784              compile(re, po);
1785          }
1786          Regex(String const *re, Uint po) {
1787              init_vars();
1788              compile(re, po);
1789          }
1790          Regex(String const &re, Uint po, Uint jo) {
1791              init_vars();
1792              compile(re, po, jo);
1793          }
1794          Regex(String const *re, Uint po, Uint jo) {
1795              init_vars();
1796              compile(re, po, jo);
1797          }
1798          Regex(Regex const &r) {
1799              init_vars();
1800              deepCopy(r);
1801          }
1802          Regex& operator=(Regex const &r) {
1803              if (this == &r) return *this;
1804              deepCopy(r);
1805              return *this;
1806          }
1807          #if JPCRE2_USE_MINIMUM_CXX_11
1808          Regex(Regex&& r) {
1809              init_vars();
1810              deepMove(r);
1811          }
1812          Regex& operator=(Regex&& r) {
1813              if (this == &r) return *this;
1814              deepMove(r);
1815              return *this;
1816          }
1817          explicit operator bool() const {
1818              return (code != 0);
1819          }
1820          #endif
1821          bool operator!() const {
1822              return (code == 0);
1823          }
1824          virtual ~Regex() {
1825              freeRegexMemory();
1826              freeCompileContext();
1827          }
1828          Regex& reset() {
1829              freeRegexMemory();
1830              freeCompileContext();
1831              String().swap(pat_str);
1832              init_vars();
1833              return *this;
1834          }
1835          Regex& clear() {
1836              freeRegexMemory();
1837              freeCompileContext();
1838              pat_str.clear();
1839              init_vars();
1840              return *this;
1841          }
1842          Regex& resetErrors() {
1843              error_number = 0;
1844              error_offset = 0;
1845              return *this;
1846          }
1847          Regex& resetCharacterTables() {
1848              const unsigned char* tables = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::maketables(0); 
1849              tabv = std::vector<unsigned char>(tables, tables+1088);
1850              ::free((void*)tables); 
1851              if(!ccontext)
1852                  ccontext = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_create(0);
1853              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_character_tables(ccontext, &tabv[0]);
1854              return *this;
1855          }
1856          Pcre2Code const* getPcre2Code() const{
1857              return code;
1858          }
1859          String getPattern() const  {
1860              return *pat_str_ptr;
1861          }
1862          String const * getPatternPointer() const  {
1863              return pat_str_ptr;
1864          }
1865          std::string getModifier() const {
1866              return modtab ? modtab->fromCompileOption(compile_opts, jpcre2_compile_opts)
1867                            : MOD::fromCompileOption(compile_opts, jpcre2_compile_opts);
1868          }
1869          Uint getPcre2Option() const  {
1870              return compile_opts;
1871          }
1872          Uint getJpcre2Option() const  {
1873              return jpcre2_compile_opts;
1874          }
1875          int getErrorNumber() const {
1876              return error_number;
1877          }
1878          int getErrorOffset() const  {
1879              return (int)error_offset;
1880          }
1881          String getErrorMessage() const  {
1882              #if JPCRE2_USE_MINIMUM_CXX_11
1883              return select<Char, Map>::getErrorMessage(error_number, error_offset);
1884              #else
1885              return select<Char>::getErrorMessage(error_number, error_offset);
1886              #endif
1887          }
1888          Uint getNewLine() {
1889              if(!code) return 0;
1890              Uint newline = 0;
1891              int ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info(code, PCRE2_INFO_NEWLINE, &newline);
1892              if(ret < 0) error_number = ret;
1893              return newline;
1894          }
1895          ModifierTable const* getModifierTable(){
1896              return modtab;
1897          }
1898          Regex& setNewLine(Uint value){
1899              if(!ccontext)
1900                  ccontext = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_create(0);
1901              int ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_newline(ccontext, value);
1902              if(ret < 0) error_number = ret;
1903              return *this;
1904          }
1905          Regex& setPattern(String const &re) {
1906              pat_str = re;
1907              pat_str_ptr = &pat_str; 
1908              return *this;
1909          }
1910          Regex& setPattern(String const *re) {
1911              if(re) pat_str_ptr = re;
1912              else {
1913                  pat_str.clear();
1914                  pat_str_ptr = &pat_str;
1915              }
1916              return *this;
1917          }
1918          Regex& setModifier(Modifier const& x) {
1919              compile_opts = 0;
1920              jpcre2_compile_opts = 0;
1921              return changeModifier(x, true);
1922          }
1923          Regex& setModifierTable(ModifierTable const * mdt){
1924              modtab = mdt;
1925              return *this;
1926          }
1927          Regex& setJpcre2Option(Uint x) {
1928              jpcre2_compile_opts = x;
1929              return *this;
1930          }
1931          Regex& setPcre2Option(Uint x) {
1932              compile_opts = x;
1933              return *this;
1934          }
1935          Regex& changeModifier(Modifier const& mod, bool x){
1936              modtab ? modtab->toCompileOption(mod, x, &compile_opts, &jpcre2_compile_opts, &error_number, &error_offset)
1937                     : MOD::toCompileOption(mod, x, &compile_opts, &jpcre2_compile_opts, &error_number, &error_offset);
1938              return *this;
1939          }
1940          Regex& changeJpcre2Option(Uint opt, bool x) {
1941              jpcre2_compile_opts = x ? jpcre2_compile_opts | opt : jpcre2_compile_opts & ~opt;
1942              return *this;
1943          }
1944          Regex& changePcre2Option(Uint opt, bool x) {
1945              compile_opts = x ? compile_opts | opt : compile_opts & ~opt;
1946              return *this;
1947          }
1948          Regex& addModifier(Modifier const& mod){
1949              return changeModifier(mod, true);
1950          }
1951          Regex& addJpcre2Option(Uint x) {
1952              jpcre2_compile_opts |= x;
1953              return *this;
1954          }
1955          Regex& addPcre2Option(Uint x) {
1956              compile_opts |= x;
1957              return *this;
1958          }
1959          void compile(void);
1960          void compile(String const &re, Uint po, Uint jo) {
1961              setPattern(re).setPcre2Option(po).setJpcre2Option(jo);
1962              compile();
1963          }
1964          void compile(String const *re, Uint po, Uint jo) {
1965              setPattern(re).setPcre2Option(po).setJpcre2Option(jo);
1966              compile();
1967          }
1968          void compile(String const &re, Uint po) {
1969              setPattern(re).setPcre2Option(po);
1970              compile();
1971          }
1972          void compile(String const *re, Uint po) {
1973              setPattern(re).setPcre2Option(po);
1974              compile();
1975          }
1976          void compile(String const &re, Modifier const& mod) {
1977              setPattern(re).setModifier(mod);
1978              compile();
1979          }
1980          void compile(String const *re, Modifier const& mod) {
1981              setPattern(re).setModifier(mod);
1982              compile();
1983          }
1984          void compile(String const &re) {
1985              setPattern(re);
1986              compile();
1987          }
1988          void compile(String const *re) {
1989              setPattern(re);
1990              compile();
1991          }
1992          RegexMatch initMatch(){
1993              RegexMatch rm(this);
1994              rm.setModifierTable(modtab);
1995              return rm;
1996          }
1997          RegexMatch getMatchObject(){
1998              return initMatch();
1999          }
2000          SIZE_T match(String const &s, Modifier const& mod, PCRE2_SIZE start_offset=0) {
2001              return initMatch().setStartOffset(start_offset).setSubject(s).setModifier(mod).match();
2002          }
2003          SIZE_T match(String const *s, Modifier const& mod, PCRE2_SIZE start_offset=0) {
2004              return initMatch().setStartOffset(start_offset).setSubject(s).setModifier(mod).match();
2005          }
2006          SIZE_T match(String const &s,  PCRE2_SIZE start_offset=0) {
2007              return initMatch().setStartOffset(start_offset).setSubject(s).match();
2008          }
2009          SIZE_T match(String const *s,  PCRE2_SIZE start_offset=0) {
2010              return initMatch().setStartOffset(start_offset).setSubject(s).match();
2011          }
2012          RegexReplace initReplace(){
2013              RegexReplace rr(this);
2014              rr.setModifierTable(modtab);
2015              return rr;
2016          }
2017          RegexReplace getReplaceObject(){
2018              return initReplace();
2019          }
2020          String replace(String const &mains, String const &repl, Modifier const& mod="", SIZE_T* counter=0) {
2021              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2022          }
2023          String replace(String *mains, String const &repl, Modifier const& mod="", SIZE_T* counter=0) {
2024              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2025          }
2026          String replace(String const &mains, String const *repl, Modifier const& mod="", SIZE_T* counter=0) {
2027              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2028          }
2029          String replace(String *mains, String const *repl, Modifier const& mod="", SIZE_T* counter=0) {
2030              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2031          }
2032          SIZE_T preplace(String * mains, String const& repl, Modifier const& mod=""){
2033              SIZE_T counter = 0;
2034              if(mains) *mains = initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2035              return counter;
2036          }
2037          SIZE_T preplace(String * mains, String const* repl, Modifier const& mod=""){
2038              SIZE_T counter = 0;
2039              if(mains) *mains = initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2040              return counter;
2041          }
2042          SIZE_T preplace(String const& mains, String const& repl, Modifier const& mod=""){
2043              SIZE_T counter = 0;
2044              initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2045              return counter;
2046          }
2047          SIZE_T preplace(String const& mains, String const* repl, Modifier const& mod=""){
2048              SIZE_T counter = 0;
2049              initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2050              return counter;
2051          }
2052      };
2053      private:
2054      select();
2055      select(select const &);
2056      #if JPCRE2_USE_MINIMUM_CXX_11
2057      select(select&&);
2058      #endif
2059      ~select();
2060  };
2061  }
2062  inline void jpcre2::ModifierTable::parseModifierTable(std::string& tabjs, VecOpt& tabjv,
2063                                                       std::string& tab_s, VecOpt& tab_v,
2064                                                       std::string const& tabs, VecOpt const& tabv){
2065      SIZE_T n = tabs.length();
2066      JPCRE2_ASSERT(n == tabv.size(), ("ValueError: Could not set Modifier table.\
2067      Modifier character and value tables are not of the same size (" + _tostdstring(n) + " == " + _tostdstring(tabv.size()) + ").").c_str());
2068      tabjs.clear();
2069      tab_s.clear(); tab_s.reserve(n);
2070      tabjv.clear();
2071      tab_v.clear(); tab_v.reserve(n);
2072      for(SIZE_T i=0;i<n;++i){
2073          switch(tabv[i]){
2074              case JIT_COMPILE:
2075              case FIND_ALL: 
2076                  tabjs.push_back(tabs[i]); tabjv.push_back(tabv[i]);break;
2077              default: tab_s.push_back(tabs[i]); tab_v.push_back(tabv[i]); break;
2078          }
2079      }
2080  }
2081  #if JPCRE2_USE_MINIMUM_CXX_11
2082  template<typename Char_T, template<typename...> class Map>
2083  void jpcre2::select<Char_T, Map>::Regex::compile() {
2084  #else
2085  template<typename Char_T>
2086  void jpcre2::select<Char_T>::Regex::compile() {
2087  #endif
2088      Pcre2Sptr c_pattern = (Pcre2Sptr) pat_str_ptr->c_str();
2089      int err_number = 0;
2090      PCRE2_SIZE err_offset = 0;
2091      freeRegexMemory();
2092      code = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile(  c_pattern,              &bsol;* the pattern */
2093                                      PCRE2_ZERO_TERMINATED,  &bsol;* indicates pattern is zero-terminated */
2094                                      compile_opts,           &bsol;* default options */
2095                                      &err_number,            &bsol;* for error number */
2096                                      &err_offset,            &bsol;* for error offset */
2097                                      ccontext);              &bsol;* use compile context */
2098      if (code == 0) {
2099          error_number = err_number;
2100          error_offset = err_offset;
2101          return;
2102      } else if ((jpcre2_compile_opts & JIT_COMPILE) != 0) {
2103          int jit_ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::jit_compile(code, PCRE2_JIT_COMPLETE);
2104          if(jit_ret < 0) error_number = jit_ret;
2105      }
2106  }
2107  #if JPCRE2_USE_MINIMUM_CXX_11
2108  template<typename Char_T, template<typename...> class Map>
2109  typename jpcre2::select<Char_T, Map>::String jpcre2::select<Char_T, Map>::MatchEvaluator::replace(bool do_match, Uint replace_opts, SIZE_T * counter) {
2110  #else
2111  template<typename Char_T>
2112  typename jpcre2::select<Char_T>::String jpcre2::select<Char_T>::MatchEvaluator::replace(bool do_match, Uint replace_opts, SIZE_T * counter) {
2113  #endif
2114      if(counter) *counter = 0;
2115      replace_opts |= PCRE2_SUBSTITUTE_OVERFLOW_LENGTH;
2116      replace_opts &= ~PCRE2_SUBSTITUTE_GLOBAL;
2117      Regex const * re = RegexMatch::getRegexObject();
2118      if (!re || re->code == 0)
2119          return RegexMatch::getSubject();
2120      Pcre2Sptr r_subject_ptr = (Pcre2Sptr) RegexMatch::getSubjectPointer()->c_str();
2121      if(do_match) match();
2122      SIZE_T mcount = vec_soff.size();
2123      if(!mcount) return RegexMatch::getSubject();
2124      SIZE_T current_offset = 0; 
2125      String res, tmp;
2126      SIZE_T last = vec_eoff.size();
2127      last = (last>0)?last-1:0;
2128      JPCRE2_ASSERT(vec_eoff[last] <= RegexMatch::getSubject().size(), "ValueError: subject string is not of the required size, may be it's changed!!!\
2129      If you are using esisting match data, try a new match.");
2130      for(SIZE_T i=0;i<mcount;++i){
2131          if(vec_soff[i] < current_offset || vec_eoff[i] < vec_soff[i]){
2132              RegexMatch::error_number = PCRE2_ERROR_BADSUBSPATTERN;
2133              return RegexMatch::getSubject();
2134          } else {
2135              res += String(r_subject_ptr+current_offset, r_subject_ptr+vec_soff[i]);
2136          }
2137          switch(callbackn){
2138              case 0: tmp = callback0((void*)0, (void*)0, (void*)0); break;
2139              case 1: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount, "VecNum");
2140                      tmp = callback1(vec_num[i], (void*)0, (void*)0); break;
2141              case 2: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount, "VecNas");
2142                      tmp = callback2((void*)0, vec_nas[i], (void*)0); break;
2143              case 3: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount, "VecNum or VecNas");
2144                      tmp = callback3(vec_num[i], vec_nas[i], (void*)0); break;
2145              case 4: JPCRE2_VECTOR_DATA_ASSERT(vec_ntn.size() == mcount, "VecNtn");
2146                      tmp = callback4((void*)0, (void*)0, vec_ntn[i]); break;
2147              case 5: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_ntn.size() == mcount, "VecNum or VecNtn");
2148                      tmp = callback5(vec_num[i], (void*)0, vec_ntn[i]); break;
2149              case 6: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNas or VecNtn");
2150                      tmp = callback6((void*)0, vec_nas[i], vec_ntn[i]); break;
2151              case 7: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNum\n or VecNas or VecNtn");
2152                      tmp = callback7(vec_num[i], vec_nas[i], vec_ntn[i]); break;
2153              default: JPCRE2_ASSERT(2 == 1, "Invalid callbackn. Please file a bug report (must include the line number from below)."); break;
2154          }
2155          current_offset = vec_eoff[i];
2156          Pcre2Sptr subject = r_subject_ptr + vec_soff[i];
2157          PCRE2_SIZE subject_length = vec_eoff[i] - vec_soff[i];
2158          Pcre2Sptr replace = (Pcre2Sptr) tmp.c_str();
2159          PCRE2_SIZE replace_length = tmp.length();
2160          bool retry = true;
2161          int ret = 0;
2162          PCRE2_SIZE outlengthptr = 0;
2163          Pcre2Uchar* output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2164          while (true) {
2165              ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::substitute(
2166                          re->code,               &bsol;*Points to the compiled pattern*/
2167                          subject,                &bsol;*Points to the subject string*/
2168                          subject_length,         &bsol;*Length of the subject string*/
2169                          0,                      &bsol;*Offset in the subject at which to start matching*/ 
2170                          replace_opts,           &bsol;*Option bits*/
2171                          RegexMatch::mdata,      &bsol;*Points to a match data block, or is NULL*/
2172                          RegexMatch::mcontext,   &bsol;*Points to a match context, or is NULL*/
2173                          replace,                &bsol;*Points to the replacement string*/
2174                          replace_length,         &bsol;*Length of the replacement string*/
2175                          output_buffer,          &bsol;*Points to the output buffer*/
2176                          &outlengthptr           &bsol;*Points to the length of the output buffer*/
2177                          );
2178              if (ret < 0) {
2179                  if ((replace_opts & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0
2180                          && ret == (int) PCRE2_ERROR_NOMEMORY && retry) {
2181                      retry = false;
2182                      delete[] output_buffer;
2183                      output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2184                      continue;
2185                  } else {
2186                      RegexMatch::error_number = ret;
2187                      delete[] output_buffer;
2188                      return RegexMatch::getSubject();
2189                  }
2190              }
2191              break;
2192          }
2193          res += String((Char*) output_buffer,(Char*) (output_buffer + outlengthptr) );
2194          delete[] output_buffer;
2195          if(counter) *counter += ret;
2196          if((RegexMatch::getJpcre2Option() & FIND_ALL) == 0) break;
2197      }
2198      res += RegexMatch::getSubject().substr(current_offset, String::npos);
2199      return res;
2200  }
2201  #if JPCRE2_USE_MINIMUM_CXX_11
2202  template<typename Char_T, template<typename...> class Map>
2203  typename jpcre2::select<Char_T, Map>::String jpcre2::select<Char_T, Map>::MatchEvaluator::nreplace(bool do_match, Uint jo, SIZE_T* counter){
2204  #else
2205  template<typename Char_T>
2206  typename jpcre2::select<Char_T>::String jpcre2::select<Char_T>::MatchEvaluator::nreplace(bool do_match, Uint jo, SIZE_T* counter){
2207  #endif
2208      if(counter) *counter = 0;
2209      if(do_match) match();
2210      SIZE_T mcount = vec_soff.size();
2211      if(!mcount) return RegexMatch::getSubject();
2212      SIZE_T current_offset = 0; 
2213      String res;
2214      SIZE_T last = vec_eoff.size();
2215      last = (last>0)?last-1:0;
2216      JPCRE2_ASSERT(vec_eoff[last] <= RegexMatch::getSubject().size(), "ValueError: subject string is not of the required size, may be it's changed!!!\
2217      If you are using esisting match data, try a new match.");
2218      for(SIZE_T i=0;i<mcount;++i){
2219          if(vec_soff[i] < current_offset){
2220              RegexMatch::error_number = PCRE2_ERROR_BADSUBSPATTERN;
2221              return RegexMatch::getSubject();
2222          } else {
2223              res += RegexMatch::getSubject().substr(current_offset, vec_soff[i]-current_offset);
2224          }
2225          switch(callbackn){
2226              case 0: res += callback0((void*)0, (void*)0, (void*)0); break;
2227              case 1: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount, "VecNum");
2228                      res += callback1(vec_num[i], (void*)0, (void*)0); break;
2229              case 2: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount, "VecNas");
2230                      res += callback2((void*)0, vec_nas[i], (void*)0); break;
2231              case 3: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount, "VecNum or VecNas");
2232                      res += callback3(vec_num[i], vec_nas[i], (void*)0); break;
2233              case 4: JPCRE2_VECTOR_DATA_ASSERT(vec_ntn.size() == mcount, "VecNtn");
2234                      res += callback4((void*)0, (void*)0, vec_ntn[i]); break;
2235              case 5: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_ntn.size() == mcount, "VecNum or VecNtn");
2236                      res += callback5(vec_num[i], (void*)0, vec_ntn[i]); break;
2237              case 6: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNas or VecNtn");
2238                      res += callback6((void*)0, vec_nas[i], vec_ntn[i]); break;
2239              case 7: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNum\n or VecNas or VecNtn");
2240                      res += callback7(vec_num[i], vec_nas[i], vec_ntn[i]); break;
2241              default: JPCRE2_ASSERT(2 == 1, "Invalid callbackn. Please file a bug report (must include the line number from below)."); break;
2242          }
2243          current_offset = vec_eoff[i];
2244          if(counter) *counter += 1;
2245          if((RegexMatch::getJpcre2Option() & FIND_ALL) == 0) break;
2246      }
2247      res += RegexMatch::getSubject().substr(current_offset, String::npos);
2248      return res;
2249  }
2250  #if JPCRE2_USE_MINIMUM_CXX_11
2251  template<typename Char_T, template<typename...> class Map>
2252  typename jpcre2::select<Char_T, Map>::String jpcre2::select<Char_T, Map>::RegexReplace::replace() {
2253  #else
2254  template<typename Char_T>
2255  typename jpcre2::select<Char_T>::String jpcre2::select<Char_T>::RegexReplace::replace() {
2256  #endif
2257      *last_replace_counter = 0;
2258      if (!re || re->code == 0)
2259          return *r_subject_ptr;
2260      Pcre2Sptr subject = (Pcre2Sptr) r_subject_ptr->c_str();
2261      PCRE2_SIZE subject_length = r_subject_ptr->length();
2262      Pcre2Sptr replace = (Pcre2Sptr) r_replw_ptr->c_str();
2263      PCRE2_SIZE replace_length = r_replw_ptr->length();
2264      PCRE2_SIZE outlengthptr = (PCRE2_SIZE) buffer_size;
2265      bool retry = true;
2266      int ret = 0;
2267      Pcre2Uchar* output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2268      while (true) {
2269          ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::substitute(
2270                      re->code,               &bsol;*Points to the compiled pattern*/
2271                      subject,                &bsol;*Points to the subject string*/
2272                      subject_length,         &bsol;*Length of the subject string*/
2273                      _start_offset,          &bsol;*Offset in the subject at which to start matching*/
2274                      replace_opts,           &bsol;*Option bits*/
2275                      mdata,                  &bsol;*Points to a match data block, or is NULL*/
2276                      mcontext,               &bsol;*Points to a match context, or is NULL*/
2277                      replace,                &bsol;*Points to the replacement string*/
2278                      replace_length,         &bsol;*Length of the replacement string*/
2279                      output_buffer,          &bsol;*Points to the output buffer*/
2280                      &outlengthptr           &bsol;*Points to the length of the output buffer*/
2281                      );
2282          if (ret < 0) {
2283              if ((replace_opts & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0
2284                      && ret == (int) PCRE2_ERROR_NOMEMORY && retry) {
2285                  retry = false;
2286                  delete[] output_buffer;
2287                  output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2288                  continue;
2289              } else {
2290                  error_number = ret;
2291                  delete[] output_buffer;
2292                  return *r_subject_ptr;
2293              }
2294          }
2295          break;
2296      }
2297      *last_replace_counter += ret;
2298      String result = String((Char*) output_buffer,(Char*) (output_buffer + outlengthptr) );
2299      delete[] output_buffer;
2300      return result;
2301  }
2302  #if JPCRE2_USE_MINIMUM_CXX_11
2303  template<typename Char_T, template<typename...> class Map>
2304  bool jpcre2::select<Char_T, Map>::RegexMatch::getNumberedSubstrings(int rc, Pcre2Sptr subject, PCRE2_SIZE* ovector, uint32_t ovector_count) {
2305  #else
2306  template<typename Char_T>
2307  bool jpcre2::select<Char_T>::RegexMatch::getNumberedSubstrings(int rc, Pcre2Sptr subject, PCRE2_SIZE* ovector, uint32_t ovector_count) {
2308  #endif
2309      NumSub num_sub;
2310      uint32_t rcu = rc;
2311      num_sub.reserve(rcu); 
2312      uint32_t i;
2313      for (i = 0u; i < rcu; i++)
2314          num_sub.push_back(String((Char*)(subject + ovector[2*i]), ovector[2*i+1] - ovector[2*i]));
2315      for (uint32_t j = i; j < ovector_count; j++)
2316          num_sub.push_back(String());
2317      vec_num->push_back(num_sub); 
2318      return true;
2319  }
2320  #if JPCRE2_USE_MINIMUM_CXX_11
2321  template<typename Char_T, template<typename...> class Map>
2322  bool jpcre2::select<Char_T, Map>::RegexMatch::getNamedSubstrings(int namecount, int name_entry_size,
2323                                                              Pcre2Sptr name_table,
2324                                                              Pcre2Sptr subject, PCRE2_SIZE* ovector ) {
2325  #else
2326  template<typename Char_T>
2327  bool jpcre2::select<Char_T>::RegexMatch::getNamedSubstrings(int namecount, int name_entry_size,
2328                                                              Pcre2Sptr name_table,
2329                                                              Pcre2Sptr subject, PCRE2_SIZE* ovector ) {
2330  #endif
2331      Pcre2Sptr tabptr = name_table;
2332      String key;
2333      MapNas map_nas;
2334      MapNtN map_ntn;
2335      for (int i = 0; i < namecount; i++) {
2336          int n;
2337          if(sizeof( Char_T ) * CHAR_BIT == 8){
2338              n = (int)((tabptr[0] << 8) | tabptr[1]);
2339              key = toString((Char*) (tabptr + 2));
2340          }
2341          else{
2342              n = (int)tabptr[0];
2343              key = toString((Char*) (tabptr + 1));
2344          }
2345          tabptr += name_entry_size;
2346          String value((Char*)(subject + ovector[2*n]), ovector[2*n+1] - ovector[2*n]); 
2347          if(vec_nas) map_nas[key] = value;
2348          if(vec_ntn) map_ntn[key] = n;
2349      }
2350      if(vec_nas) vec_nas->push_back(map_nas);
2351      if(vec_ntn) vec_ntn->push_back(map_ntn);
2352      return true;
2353  }
2354  #if JPCRE2_USE_MINIMUM_CXX_11
2355  template<typename Char_T, template<typename...> class Map>
2356  jpcre2::SIZE_T jpcre2::select<Char_T, Map>::RegexMatch::match() {
2357  #else
2358  template<typename Char_T>
2359  jpcre2::SIZE_T jpcre2::select<Char_T>::RegexMatch::match() {
2360  #endif
2361      if (!re || re->code == 0)
2362          return 0;
2363      Pcre2Sptr subject = (Pcre2Sptr) m_subject_ptr->c_str();
2364      Pcre2Sptr name_table = 0;
2365      int crlf_is_newline = 0;
2366      int namecount = 0;
2367      int name_entry_size = 0;
2368      int rc = 0;
2369      uint32_t ovector_count = 0;
2370      int utf = 0;
2371      SIZE_T count = 0;
2372      Uint option_bits;
2373      Uint newline = 0;
2374      PCRE2_SIZE *ovector = 0;
2375      SIZE_T subject_length = 0;
2376      MatchData *match_data = 0;
2377      subject_length = m_subject_ptr->length();
2378      bool mdc = false; 
2379      if (vec_num) vec_num->clear();
2380      if (vec_nas) vec_nas->clear();
2381      if (vec_ntn) vec_ntn->clear();
2382      if(vec_soff) vec_soff->clear();
2383      if(vec_eoff) vec_eoff->clear();
2384      if(mdata) match_data = mdata;
2385      else {
2386          match_data = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_create_from_pattern(re->code, 0);
2387          mdc = true;
2388      }
2389      rc = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match(  re->code,       &bsol;* the compiled pattern */
2390                                  subject,        &bsol;* the subject string */
2391                                  subject_length, &bsol;* the length of the subject */
2392                                  _start_offset,  &bsol;* start at offset 'start_offset' in the subject */
2393                                  match_opts,     &bsol;* default options */
2394                                  match_data,     &bsol;* block for storing the result */
2395                                  mcontext);      &bsol;* use default match context */
2396      if (rc < 0) {
2397          if(mdc)
2398              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data); &bsol;* Release memory used for the match */
2399          switch (rc) {
2400              case PCRE2_ERROR_NOMATCH:
2401                  return count;
2402              default:;
2403          }
2404          error_number = rc;
2405          return count;
2406      }
2407      ++count; 
2408      ovector = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::get_ovector_pointer(match_data);
2409      ovector_count = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::get_ovector_count(match_data);
2410      if (rc == 0) {
2411          error_number = (int)ERROR::INSUFFICIENT_OVECTOR;
2412          rc = ovector_count;
2413      }
2414      if(vec_soff) vec_soff->push_back(ovector[0]);
2415      if(vec_eoff) vec_eoff->push_back(ovector[1]);
2416      if (vec_num) { 
2417          if(!getNumberedSubstrings(rc, subject, ovector, ovector_count))
2418              return count;
2419      }
2420      if (vec_nas || vec_ntn) {
2421          (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info( re->code,               &bsol;* the compiled pattern */
2422                                              PCRE2_INFO_NAMECOUNT,   &bsol;* get the number of named substrings */
2423                                              &namecount);            &bsol;* where to put the answer */
2424          if (namecount <= 0); &bsol;*No named substrings*/
2425          else {
2426              (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info( re->code,               &bsol;* the compiled pattern */
2427                                                  PCRE2_INFO_NAMETABLE,   &bsol;* address of the table */
2428                                                  &name_table);           &bsol;* where to put the answer */
2429              (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info( re->code,                   &bsol;* the compiled pattern */
2430                                                  PCRE2_INFO_NAMEENTRYSIZE,   &bsol;* size of each entry in the table */
2431                                                  &name_entry_size);          &bsol;* where to put the answer */
2432          }
2433          if(!getNamedSubstrings(namecount, name_entry_size, name_table, subject, ovector))
2434              return count;
2435      }
2436      if ((jpcre2_match_opts & FIND_ALL) == 0) {
2437          if(mdc)
2438              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data); &bsol;* Release the memory that was used */
2439          return count; &bsol;* Exit the program. */
2440      }
2441      (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info(re->code, PCRE2_INFO_ALLOPTIONS, &option_bits);
2442      utf = ((option_bits & PCRE2_UTF) != 0);
2443      (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info(re->code, PCRE2_INFO_NEWLINE, &newline);
2444      crlf_is_newline = newline == PCRE2_NEWLINE_ANY
2445              || newline == PCRE2_NEWLINE_CRLF
2446              || newline == PCRE2_NEWLINE_ANYCRLF;
2447      for (;;) {
2448          Uint options = match_opts; &bsol;* Normally no options */
2449          PCRE2_SIZE start_offset = ovector[1]; &bsol;* Start at end of previous match */
2450          if (ovector[0] == ovector[1]) {
2451              if (ovector[0] == subject_length)
2452                  break;
2453              options |= PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;
2454          }
2455          rc = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match(  re->code,       &bsol;* the compiled pattern */
2456                                      subject,        &bsol;* the subject string */
2457                                      subject_length, &bsol;* the length of the subject */
2458                                      start_offset,   &bsol;* starting offset in the subject */
2459                                      options,        &bsol;* options */
2460                                      match_data,     &bsol;* block for storing the result */
2461                                      mcontext);      &bsol;* use match context */
2462          if (rc == PCRE2_ERROR_NOMATCH) {
2463              if (options == 0)
2464                  break;                          &bsol;* All matches found */
2465              ovector[1] = start_offset + 1; &bsol;* Advance one code unit */
2466              if (crlf_is_newline &&                      &bsol;* If CRLF is newline & */
2467                  start_offset < subject_length - 1 &&    &bsol;* we are at CRLF, */
2468                  subject[start_offset] == '\r' && subject[start_offset + 1] == '\n')
2469                  ovector[1] += 1;                        &bsol;* Advance by one more. */
2470              else if (utf) { &bsol;* advance a whole UTF (8 or 16), for UTF-32, it's not needed */
2471                  while (ovector[1] < subject_length) {
2472                      if(sizeof( Char_T ) * CHAR_BIT == 8 && (subject[ovector[1]] & 0xc0) != 0x80) break;
2473                      else if(sizeof( Char_T ) * CHAR_BIT == 16 && (subject[ovector[1]] & 0xfc00) != 0xdc00) break;
2474                      else if(sizeof( Char_T ) * CHAR_BIT == 32) break; 
2475                      ovector[1] += 1;
2476                  }
2477              }
2478              continue; &bsol;* Go round the loop again */
2479          }
2480          if (rc < 0) {
2481              if(mdc)
2482                  Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data);
2483              error_number = rc;
2484              return count;
2485          }
2486          ++count; 
2487          if (rc == 0) {
2488              error_number = (int)ERROR::INSUFFICIENT_OVECTOR;
2489              rc = ovector_count;
2490          }
2491          if(vec_soff) vec_soff->push_back(ovector[0]);
2492          if(vec_eoff) vec_eoff->push_back(ovector[1]);
2493          if (vec_num) { 
2494              if(!getNumberedSubstrings(rc, subject, ovector, ovector_count))
2495                  return count;
2496          }
2497          if (vec_nas || vec_ntn) {
2498              if(!getNamedSubstrings(namecount, name_entry_size, name_table, subject, ovector))
2499                  return count;
2500          }
2501      } &bsol;* End of loop to find second and subsequent matches */
2502      if(mdc)
2503          Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data);
2504      return count;
2505  }
2506  #undef JPCRE2_VECTOR_DATA_ASSERT
2507  #undef JPCRE2_UNUSED
2508  #undef JPCRE2_USE_MINIMUM_CXX_11
2509  #ifdef __DOXYGEN__
2510  #ifndef JPCRE2_USE_FUNCTION_POINTER_CALLBACK
2511  #define JPCRE2_USE_FUNCTION_POINTER_CALLBACK
2512  #endif
2513  #ifndef JPCRE2_NDEBUG
2514  #define JPCRE2_NDEBUG
2515  #endif
2516  #endif
2517  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-inja.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-jpcre2.hpp</div>
                </div>
                <div class="column column_space"><pre><code>556                       : pos >= size()
557                             ? find_last_not_of(v, size() - 1)
558                             : to_pos(std::find_if(const_reverse_iterator(cbegin() + pos + 1), crend(), not_in_view(v)));
</pre></code></div>
                <div class="column column_space"><pre><code>519          SIZE_T S = V.size();
520          JPCRE2_ASSERT(SJ == J_N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(SJ) + " == " + _tostdstring(J_N.length()) + ").").c_str());
521          JPCRE2_ASSERT(S == N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(S) + " == " + _tostdstring(N.length()) + ").").c_str());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    