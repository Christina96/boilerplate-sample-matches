
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.49609984399376%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CellBuffer.h</h3>
            <pre><code>1  #ifndef CELLBUFFER_H
2  #define CELLBUFFER_H
3  namespace Scintilla::Internal {
4  class PerLine {
5  public:
6  	virtual ~PerLine() {}
7  	virtual void Init()=0;
8  	virtual void InsertLine(Sci::Line line)=0;
9  	virtual void InsertLines(Sci::Line line, Sci::Line lines) = 0;
10  	virtual void RemoveLine(Sci::Line line)=0;
11  };
12  class ChangeHistory;
13  class ILineVector;
14  enum class ActionType { insert, remove, start, container };
15  class Action {
16  public:
17  	ActionType at;
18  	Sci::Position position;
19  	std::unique_ptr<char[]> data;
20  	Sci::Position lenData;
21  	bool mayCoalesce;
22  	Action() noexcept;
23  	void Create(ActionType at_, Sci::Position position_=0, const char *data_=nullptr, Sci::Position lenData_=0, bool mayCoalesce_=true);
24  	void Clear() noexcept;
25  };
26  class UndoHistory {
27  	std::vector<Action> actions;
28  	int maxAction;
29  	int currentAction;
30  	int undoSequenceDepth;
31  	int savePoint;
32  	int tentativePoint;
33  	std::optional<int> detach;
34  	void EnsureUndoRoom();
35  public:
36  	UndoHistory();
37  	const char *AppendAction(ActionType at, Sci::Position position, const char *data, Sci::Position lengthData, bool &startSequence, bool mayCoalesce=true);
38  	void BeginUndoAction();
39  	void EndUndoAction();
40  	void DropUndoSequence();
41  	void DeleteUndoHistory();
42  	void SetSavePoint() noexcept;
43  	bool IsSavePoint() const noexcept;
44  	bool BeforeSavePoint() const noexcept;
45  	bool BeforeReachableSavePoint() const noexcept;
46  	bool AfterSavePoint() const noexcept;
47  	bool AfterDetachPoint() const noexcept;
48  	void TentativeStart();
49  	void TentativeCommit();
50  	bool TentativeActive() const noexcept;
51  	int TentativeSteps() noexcept;
52  	bool CanUndo() const noexcept;
53  	int StartUndo();
54  	const Action &GetUndoStep() const;
55  	void CompletedUndoStep();
56  	bool CanRedo() const noexcept;
57  	int StartRedo();
58  	const Action &GetRedoStep() const;
59  	void CompletedRedoStep();
60  };
61  struct SplitView {
62  	const char *segment1 = nullptr;
63  	size_t length1 = 0;
64  	const char *segment2 = nullptr;
65  	size_t length = 0;
66  	bool operator==(const SplitView &other) const noexcept {
67  		return segment1 == other.segment1 && length1 == other.length1 &&
68  			segment2 == other.segment2 && length == other.length;
69  	}
70  	bool operator!=(const SplitView &other) const noexcept {
71  		return !(*this == other);
72  	}
73  	char CharAt(size_t position) const noexcept {
74  		if (position < length1) {
75  			return segment1[position];
76  		}
77  		if (position < length) {
78  			return segment2[position];
79  		}
80  		return 0;
81  	}
82  };
83  class CellBuffer {
84  private:
85  	bool hasStyles;
86  	bool largeDocument;
87  	SplitVector<char> substance;
88  	SplitVector<char> style;
89  	bool readOnly;
90  	bool utf8Substance;
91  	Scintilla::LineEndType utf8LineEnds;
92  	bool collectingUndo;
93  	UndoHistory uh;
94  	std::unique_ptr<ChangeHistory> changeHistory;
95  	std::unique_ptr<ILineVector> plv;
96  	bool UTF8LineEndOverlaps(Sci::Position position) const noexcept;
97  	bool UTF8IsCharacterBoundary(Sci::Position position) const;
98  	void ResetLineEnds();
99  	void RecalculateIndexLineStarts(Sci::Line lineFirst, Sci::Line lineLast);
100  	bool MaintainingLineCharacterIndex() const noexcept;
101  	void BasicInsertString(Sci::Position position, const char *s, Sci::Position insertLength);
102  	void BasicDeleteChars(Sci::Position position, Sci::Position deleteLength);
103  public:
104  	CellBuffer(bool hasStyles_, bool largeDocument_);
105  	CellBuffer(const CellBuffer &) = delete;
106  	CellBuffer(CellBuffer &&) = delete;
107  	CellBuffer &operator=(const CellBuffer &) = delete;
<span onclick='openModal()' class='match'>108  	CellBuffer &operator=(CellBuffer &&) = delete;
109  	~CellBuffer() noexcept;
110  	char CharAt(Sci::Position position) const noexcept;
111  	unsigned char UCharAt(Sci::Position position) const noexcept;
112  	void GetCharRange(char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const;
</span>113  	char StyleAt(Sci::Position position) const noexcept;
114  	void GetStyleRange(unsigned char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const;
115  	const char *BufferPointer();
116  	const char *RangePointer(Sci::Position position, Sci::Position rangeLength) noexcept;
117  	Sci::Position GapPosition() const noexcept;
118  	SplitView AllView() const noexcept;
119  	Sci::Position Length() const noexcept;
120  	void Allocate(Sci::Position newSize);
121  	void SetUTF8Substance(bool utf8Substance_) noexcept;
122  	Scintilla::LineEndType GetLineEndTypes() const noexcept { return utf8LineEnds; }
123  	void SetLineEndTypes(Scintilla::LineEndType utf8LineEnds_);
124  	bool ContainsLineEnd(const char *s, Sci::Position length) const noexcept;
125  	void SetPerLine(PerLine *pl) noexcept;
126  	Scintilla::LineCharacterIndexType LineCharacterIndex() const noexcept;
127  	void AllocateLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
128  	void ReleaseLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
129  	Sci::Line Lines() const noexcept;
130  	void AllocateLines(Sci::Line lines);
131  	Sci::Position LineStart(Sci::Line line) const noexcept;
132  	Sci::Position IndexLineStart(Sci::Line line, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept;
133  	Sci::Line LineFromPosition(Sci::Position pos) const noexcept;
134  	Sci::Line LineFromPositionIndex(Sci::Position pos, Scintilla::LineCharacterIndexType lineCharacterIndex) const noexcept;
135  	void InsertLine(Sci::Line line, Sci::Position position, bool lineStart);
136  	void RemoveLine(Sci::Line line);
137  	const char *InsertString(Sci::Position position, const char *s, Sci::Position insertLength, bool &startSequence);
138  	bool SetStyleAt(Sci::Position position, char styleValue) noexcept;
139  	bool SetStyleFor(Sci::Position position, Sci::Position lengthStyle, char styleValue) noexcept;
140  	const char *DeleteChars(Sci::Position position, Sci::Position deleteLength, bool &startSequence);
141  	bool IsReadOnly() const noexcept;
142  	void SetReadOnly(bool set) noexcept;
143  	bool IsLarge() const noexcept;
144  	bool HasStyles() const noexcept;
145  	void SetSavePoint();
146  	bool IsSavePoint() const noexcept;
147  	void TentativeStart();
148  	void TentativeCommit();
149  	bool TentativeActive() const noexcept;
150  	int TentativeSteps() noexcept;
151  	bool SetUndoCollection(bool collectUndo);
152  	bool IsCollectingUndo() const noexcept;
153  	void BeginUndoAction();
154  	void EndUndoAction();
155  	void AddUndoAction(Sci::Position token, bool mayCoalesce);
156  	void DeleteUndoHistory();
157  	bool CanUndo() const noexcept;
158  	int StartUndo();
159  	const Action &GetUndoStep() const;
160  	void PerformUndoStep();
161  	bool CanRedo() const noexcept;
162  	int StartRedo();
163  	const Action &GetRedoStep() const;
164  	void PerformRedoStep();
165  	void ChangeHistorySet(bool set);
166  	[[nodiscard]] int EditionAt(Sci::Position pos) const noexcept;
167  	[[nodiscard]] Sci::Position EditionEndRun(Sci::Position pos) const noexcept;
168  	[[nodiscard]] unsigned int EditionDeletesAt(Sci::Position pos) const noexcept;
169  	[[nodiscard]] Sci::Position EditionNextDelete(Sci::Position pos) const noexcept;
170  };
171  }
172  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-native-bridge.cpp</h3>
            <pre><code>1  #include "MMKVPredef.h"
2  #ifdef MMKV_ANDROID
3  #    include "MMBuffer.h"
4  #    include "MMKV.h"
5  #    include "MMKVLog.h"
6  #    include "MemoryFile.h"
7  #    include <cstdint>
8  #    include <jni.h>
9  #    include <string>
10  using namespace std;
11  using namespace mmkv;
12  static jclass g_cls = nullptr;
13  static jfieldID g_fileID = nullptr;
14  static jmethodID g_callbackOnCRCFailID = nullptr;
15  static jmethodID g_callbackOnFileLengthErrorID = nullptr;
16  static jmethodID g_mmkvLogID = nullptr;
17  static jmethodID g_callbackOnContentChange = nullptr;
18  static JavaVM *g_currentJVM = nullptr;
19  static int registerNativeMethods(JNIEnv *env, jclass cls);
20  extern "C" void internalLogWithLevel(MMKVLogLevel level, const char *filename, const char *func, int line, const char *format, ...);
21  extern MMKVLogLevel g_currentLogLevel;
22  namespace mmkv {
23      static void mmkvLog(MMKVLogLevel level, const char *file, int line, const char *function, const std::string &message);
24  }
25  #define InternalLogError(format, ...) \
26      internalLogWithLevel(MMKV_NAMESPACE_PREFIX::MMKVLogError, __MMKV_FILE_NAME__, __func__, __LINE__, format, ##__VA_ARGS__)
27  #define InternalLogInfo(format, ...) \
28      internalLogWithLevel(MMKV_NAMESPACE_PREFIX::MMKVLogInfo, __MMKV_FILE_NAME__, __func__, __LINE__, format, ##__VA_ARGS__)
29  extern "C" JNIEXPORT JNICALL jint JNI_OnLoad(JavaVM *vm, void *reserved) {
30      g_currentJVM = vm;
31      JNIEnv *env;
32      if (vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) != JNI_OK) {
33          return -1;
34      }
35      if (g_cls) {
36          env->DeleteGlobalRef(g_cls);
37      }
38      static const char *clsName = "com/tencent/mmkv/MMKV";
39      jclass instance = env->FindClass(clsName);
40      if (!instance) {
41          MMKVError("fail to locate class: %s", clsName);
42          return -2;
43      }
44      g_cls = reinterpret_cast<jclass>(env->NewGlobalRef(instance));
45      if (!g_cls) {
46          MMKVError("fail to create global reference for %s", clsName);
47          return -3;
48      }
49      g_mmkvLogID =
50          env->GetStaticMethodID(g_cls, "mmkvLogImp", "(ILjava/lang/String;ILjava/lang/String;Ljava/lang/String;)V");
51      if (!g_mmkvLogID) {
52          MMKVError("fail to get method id for mmkvLogImp");
53      }
54      int ret = registerNativeMethods(env, g_cls);
55      if (ret != 0) {
56          InternalLogError("fail to register native methods for class %s, ret = %d", clsName, ret);
57          return -4;
58      }
59      g_fileID = env->GetFieldID(g_cls, "nativeHandle", "J");
60      if (!g_fileID) {
61          InternalLogError("fail to locate fileID");
62          return -5;
63      }
64      g_callbackOnCRCFailID = env->GetStaticMethodID(g_cls, "onMMKVCRCCheckFail", "(Ljava/lang/String;)I");
65      if (!g_callbackOnCRCFailID) {
66          InternalLogError("fail to get method id for onMMKVCRCCheckFail");
67      }
68      g_callbackOnFileLengthErrorID = env->GetStaticMethodID(g_cls, "onMMKVFileLengthError", "(Ljava/lang/String;)I");
69      if (!g_callbackOnFileLengthErrorID) {
70          InternalLogError("fail to get method id for onMMKVFileLengthError");
71      }
72      g_callbackOnContentChange =
73          env->GetStaticMethodID(g_cls, "onContentChangedByOuterProcess", "(Ljava/lang/String;)V");
74      if (!g_callbackOnContentChange) {
75          InternalLogError("fail to get method id for onContentChangedByOuterProcess()");
76      }
77      jclass versionClass = env->FindClass("android/os/Build$VERSION");
78      if (versionClass) {
79          jfieldID sdkIntFieldID = env->GetStaticFieldID(versionClass, "SDK_INT", "I");
80          if (sdkIntFieldID) {
81              g_android_api = env->GetStaticIntField(versionClass, sdkIntFieldID);
82  #ifdef MMKV_STL_SHARED
83              InternalLogInfo("current API level = %d, libc++_shared=%d", g_android_api, MMKV_STL_SHARED);
84  #else
85              InternalLogInfo("current API level = %d, libc++_shared=?", g_android_api);
86  #endif
87          } else {
88              InternalLogError("fail to get field id android.os.Build.VERSION.SDK_INT");
89          }
90      } else {
91          InternalLogError("fail to get class android.os.Build.VERSION");
92      }
93      return JNI_VERSION_1_6;
94  }
95  #    define MMKV_JNI static
96  namespace mmkv {
97  static string jstring2string(JNIEnv *env, jstring str);
98  MMKV_JNI void jniInitialize(JNIEnv *env, jobject obj, jstring rootDir, jstring cacheDir, jint logLevel) {
99      if (!rootDir) {
100          return;
101      }
102      const char *kstr = env->GetStringUTFChars(rootDir, nullptr);
103      if (kstr) {
104          MMKV::initializeMMKV(kstr, (MMKVLogLevel) logLevel);
105          env->ReleaseStringUTFChars(rootDir, kstr);
106          g_android_tmpDir = jstring2string(env, cacheDir);
107      }
108  }
109  MMKV_JNI void jniInitialize_2(JNIEnv *env, jobject obj, jstring rootDir, jstring cacheDir, jint logLevel, jboolean logReDirecting) {
110      if (!rootDir) {
111          return;
112      }
113      const char *kstr = env->GetStringUTFChars(rootDir, nullptr);
114      if (kstr) {
115          auto logHandler = logReDirecting ? mmkvLog : nullptr;
116          MMKV::initializeMMKV(kstr, (MMKVLogLevel) logLevel, logHandler);
117          env->ReleaseStringUTFChars(rootDir, kstr);
118          g_android_tmpDir = jstring2string(env, cacheDir);
119      }
120  }
121  MMKV_JNI void onExit(JNIEnv *env, jobject obj) {
122      MMKV::onExit();
123  }
124  static MMKV *getMMKV(JNIEnv *env, jobject obj) {
125      jlong handle = env->GetLongField(obj, g_fileID);
126      return reinterpret_cast<MMKV *>(handle);
127  }
128  static string jstring2string(JNIEnv *env, jstring str) {
129      if (str) {
130          const char *kstr = env->GetStringUTFChars(str, nullptr);
131          if (kstr) {
132              string result(kstr);
133              env->ReleaseStringUTFChars(str, kstr);
134              return result;
135          }
136      }
137      return "";
138  }
139  static jstring string2jstring(JNIEnv *env, const string &str) {
140      return env->NewStringUTF(str.c_str());
141  }
142  static vector<string> jarray2vector(JNIEnv *env, jobjectArray array) {
143      vector<string> keys;
144      if (array) {
145          jsize size = env->GetArrayLength(array);
146          keys.reserve(size);
147          for (jsize i = 0; i < size; i++) {
148              jstring str = (jstring) env->GetObjectArrayElement(array, i);
149              if (str) {
150                  keys.push_back(jstring2string(env, str));
151                  env->DeleteLocalRef(str);
152              }
153          }
154      }
155      return keys;
156  }
157  static jobjectArray vector2jarray(JNIEnv *env, const vector<string> &arr) {
158      jobjectArray result = env->NewObjectArray(arr.size(), env->FindClass("java/lang/String"), nullptr);
159      if (result) {
160          for (size_t index = 0; index < arr.size(); index++) {
161              jstring value = string2jstring(env, arr[index]);
162              env->SetObjectArrayElement(result, index, value);
163              env->DeleteLocalRef(value);
164          }
165      }
166      return result;
167  }
168  static JNIEnv *getCurrentEnv() {
169      if (g_currentJVM) {
170          JNIEnv *currentEnv = nullptr;
171          auto ret = g_currentJVM->GetEnv(reinterpret_cast<void **>(&currentEnv), JNI_VERSION_1_6);
172          if (ret == JNI_OK) {
173              return currentEnv;
174          } else {
175              MMKVError("fail to get current JNIEnv: %d", ret);
176          }
177      }
178      return nullptr;
179  }
180  MMKVRecoverStrategic onMMKVError(const std::string &mmapID, MMKVErrorType errorType) {
181      jmethodID methodID = nullptr;
182      if (errorType == MMKVCRCCheckFail) {
183          methodID = g_callbackOnCRCFailID;
184      } else if (errorType == MMKVFileLength) {
185          methodID = g_callbackOnFileLengthErrorID;
186      }
187      auto currentEnv = getCurrentEnv();
188      if (currentEnv && methodID) {
189          jstring str = string2jstring(currentEnv, mmapID);
190          auto strategic = currentEnv->CallStaticIntMethod(g_cls, methodID, str);
191          return static_cast<MMKVRecoverStrategic>(strategic);
192      }
193      return OnErrorDiscard;
194  }
195  extern "C" void internalLogWithLevel(MMKVLogLevel level, const char *filename, const char *func, int line, const char *format, ...) {
196      if (level >= g_currentLogLevel) {
197          std::string message;
198          char buffer[16];
199          va_list args;
200          va_start(args, format);
201          auto length = std::vsnprintf(buffer, sizeof(buffer), format, args);
202          va_end(args);
203          if (length < 0) { 
204              message = {};
205          } else if (length < sizeof(buffer)) {
206              message = std::string(buffer, static_cast<unsigned long>(length));
207          } else {
208              message.resize(static_cast<unsigned long>(length), '\0');
209              va_start(args, format);
210              std::vsnprintf(const_cast<char *>(message.data()), static_cast<size_t>(length) + 1, format, args);
211              va_end(args);
212          }
213          if (g_cls && g_mmkvLogID) {
214              mmkvLog(level, filename, line, func, message);
215          } else {
216              _MMKVLogWithLevel(level, filename, func, line, message.c_str());
217          }
218      }
219  }
220  static void mmkvLog(MMKVLogLevel level, const char *file, int line, const char *function, const std::string &message) {
221      auto currentEnv = getCurrentEnv();
222      if (currentEnv && g_mmkvLogID) {
223          jstring oFile = string2jstring(currentEnv, string(file));
224          jstring oFunction = string2jstring(currentEnv, string(function));
225          jstring oMessage = string2jstring(currentEnv, message);
226          int readLevel = level;
227          currentEnv->CallStaticVoidMethod(g_cls, g_mmkvLogID, readLevel, oFile, line, oFunction, oMessage);
228      }
229  }
230  static void onContentChangedByOuterProcess(const std::string &mmapID) {
231      auto currentEnv = getCurrentEnv();
232      if (currentEnv && g_callbackOnContentChange) {
233          jstring str = string2jstring(currentEnv, mmapID);
234          currentEnv->CallStaticVoidMethod(g_cls, g_callbackOnContentChange, str);
235      }
236  }
237  MMKV_JNI jlong getMMKVWithID(JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring rootPath) {
238      MMKV *kv = nullptr;
239      if (!mmapID) {
240          return (jlong) kv;
241      }
242      string str = jstring2string(env, mmapID);
243      bool done = false;
244      if (cryptKey) {
245          string crypt = jstring2string(env, cryptKey);
246          if (crypt.length() > 0) {
247              if (rootPath) {
248                  string path = jstring2string(env, rootPath);
249                  kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &crypt, &path);
250              } else {
251                  kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &crypt, nullptr);
252              }
253              done = true;
254          }
255      }
256      if (!done) {
257          if (rootPath) {
258              string path = jstring2string(env, rootPath);
259              kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, nullptr, &path);
260          } else {
261              kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, nullptr, nullptr);
262          }
263      }
264      return (jlong) kv;
265  }
266  MMKV_JNI jlong getMMKVWithIDAndSize(JNIEnv *env, jobject obj, jstring mmapID, jint size, jint mode, jstring cryptKey) {
267      MMKV *kv = nullptr;
268      if (!mmapID || size < 0) {
269          return (jlong) kv;
270      }
271      string str = jstring2string(env, mmapID);
272      if (cryptKey) {
273          string crypt = jstring2string(env, cryptKey);
274          if (crypt.length() > 0) {
275              kv = MMKV::mmkvWithID(str, size, (MMKVMode) mode, &crypt);
276          }
277      }
278      if (!kv) {
279          kv = MMKV::mmkvWithID(str, size, (MMKVMode) mode, nullptr);
280      }
281      return (jlong) kv;
282  }
283  MMKV_JNI jlong getDefaultMMKV(JNIEnv *env, jobject obj, jint mode, jstring cryptKey) {
284      MMKV *kv = nullptr;
285      if (cryptKey) {
286          string crypt = jstring2string(env, cryptKey);
287          if (crypt.length() > 0) {
288              kv = MMKV::defaultMMKV((MMKVMode) mode, &crypt);
289          }
290      }
291      if (!kv) {
292          kv = MMKV::defaultMMKV((MMKVMode) mode, nullptr);
293      }
294      return (jlong) kv;
295  }
296  MMKV_JNI jlong getMMKVWithAshmemFD(JNIEnv *env, jobject obj, jstring mmapID, jint fd, jint metaFD, jstring cryptKey) {
297      MMKV *kv = nullptr;
298      if (!mmapID || fd < 0 || metaFD < 0) {
299          return (jlong) kv;
300      }
301      string id = jstring2string(env, mmapID);
302      if (cryptKey) {
303          string crypt = jstring2string(env, cryptKey);
304          if (crypt.length() > 0) {
305              kv = MMKV::mmkvWithAshmemFD(id, fd, metaFD, &crypt);
306          }
307      }
308      if (!kv) {
309          kv = MMKV::mmkvWithAshmemFD(id, fd, metaFD, nullptr);
310      }
311      return (jlong) kv;
312  }
313  MMKV_JNI jstring mmapID(JNIEnv *env, jobject instance) {
314      MMKV *kv = getMMKV(env, instance);
315      if (kv) {
316          return string2jstring(env, kv->mmapID());
317      }
318      return nullptr;
319  }
320  MMKV_JNI jint ashmemFD(JNIEnv *env, jobject instance) {
321      MMKV *kv = getMMKV(env, instance);
322      if (kv) {
323          return kv->ashmemFD();
324      }
325      return -1;
326  }
327  MMKV_JNI jint ashmemMetaFD(JNIEnv *env, jobject instance) {
328      MMKV *kv = getMMKV(env, instance);
329      if (kv) {
330          return kv->ashmemMetaFD();
331      }
332      return -1;
333  }
334  MMKV_JNI jboolean checkProcessMode(JNIEnv *env, jobject, jlong handle) {
335      MMKV *kv = reinterpret_cast<MMKV *>(handle);
336      if (kv) {
337          return kv->checkProcessMode();
338      }
339      return false;
340  }
341  MMKV_JNI jboolean encodeBool(JNIEnv *env, jobject, jlong handle, jstring oKey, jboolean value) {
342      MMKV *kv = reinterpret_cast<MMKV *>(handle);
343      if (kv && oKey) {
344          string key = jstring2string(env, oKey);
345          return (jboolean) kv->set((bool) value, key);
346      }
347      return (jboolean) false;
348  }
349  MMKV_JNI jboolean encodeBool_2(JNIEnv *env, jobject, jlong handle, jstring oKey, jboolean value, jint expiration) {
350      MMKV *kv = reinterpret_cast<MMKV *>(handle);
351      if (kv && oKey) {
352          string key = jstring2string(env, oKey);
353          return (jboolean) kv->set((bool) value, key, (uint32_t) expiration);
354      }
355      return (jboolean) false;
356  }
357  MMKV_JNI jboolean decodeBool(JNIEnv *env, jobject, jlong handle, jstring oKey, jboolean defaultValue) {
358      MMKV *kv = reinterpret_cast<MMKV *>(handle);
359      if (kv && oKey) {
360          string key = jstring2string(env, oKey);
361          return (jboolean) kv->getBool(key, defaultValue);
362      }
363      return defaultValue;
364  }
365  MMKV_JNI jboolean encodeInt(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value) {
366      MMKV *kv = reinterpret_cast<MMKV *>(handle);
367      if (kv && oKey) {
368          string key = jstring2string(env, oKey);
369          return (jboolean) kv->set((int32_t) value, key);
370      }
371      return (jboolean) false;
372  }
373  MMKV_JNI jboolean encodeInt_2(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint value, jint expiration) {
374      MMKV *kv = reinterpret_cast<MMKV *>(handle);
375      if (kv && oKey) {
376          string key = jstring2string(env, oKey);
377          return (jboolean) kv->set((int32_t) value, key, (uint32_t) expiration);
378      }
379      return (jboolean) false;
380  }
381  MMKV_JNI jint decodeInt(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jint defaultValue) {
382      MMKV *kv = reinterpret_cast<MMKV *>(handle);
383      if (kv && oKey) {
384          string key = jstring2string(env, oKey);
385          return (jint) kv->getInt32(key, defaultValue);
386      }
387      return defaultValue;
388  }
389  MMKV_JNI jboolean encodeLong(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jlong value) {
390      MMKV *kv = reinterpret_cast<MMKV *>(handle);
391      if (kv && oKey) {
392          string key = jstring2string(env, oKey);
393          return (jboolean) kv->set((int64_t) value, key);
394      }
395      return (jboolean) false;
396  }
397  MMKV_JNI jboolean encodeLong_2(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jlong value, jint expiration) {
398      MMKV *kv = reinterpret_cast<MMKV *>(handle);
399      if (kv && oKey) {
400          string key = jstring2string(env, oKey);
401          return (jboolean) kv->set((int64_t) value, key, (uint32_t) expiration);
402      }
403      return (jboolean) false;
404  }
405  MMKV_JNI jlong decodeLong(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jlong defaultValue) {
406      MMKV *kv = reinterpret_cast<MMKV *>(handle);
407      if (kv && oKey) {
408          string key = jstring2string(env, oKey);
409          return (jlong) kv->getInt64(key, defaultValue);
410      }
411      return defaultValue;
412  }
413  MMKV_JNI jboolean encodeFloat(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jfloat value) {
414      MMKV *kv = reinterpret_cast<MMKV *>(handle);
415      if (kv && oKey) {
416          string key = jstring2string(env, oKey);
417          return (jboolean) kv->set((float) value, key);
418      }
419      return (jboolean) false;
420  }
421  MMKV_JNI jboolean encodeFloat_2(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jfloat value, jint expiration) {
422      MMKV *kv = reinterpret_cast<MMKV *>(handle);
423      if (kv && oKey) {
424          string key = jstring2string(env, oKey);
425          return (jboolean) kv->set((float) value, key, (uint32_t) expiration);
426      }
427      return (jboolean) false;
428  }
429  MMKV_JNI jfloat decodeFloat(JNIEnv *env, jobject, jlong handle, jstring oKey, jfloat defaultValue) {
430      MMKV *kv = reinterpret_cast<MMKV *>(handle);
431      if (kv && oKey) {
432          string key = jstring2string(env, oKey);
433          return (jfloat) kv->getFloat(key, defaultValue);
434      }
435      return defaultValue;
436  }
437  MMKV_JNI jboolean encodeDouble(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jdouble value) {
438      MMKV *kv = reinterpret_cast<MMKV *>(handle);
439      if (kv && oKey) {
440          string key = jstring2string(env, oKey);
441          return (jboolean) kv->set((double) value, key);
442      }
443      return (jboolean) false;
444  }
445  MMKV_JNI jboolean encodeDouble_2(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jdouble value, jint expiration) {
446      MMKV *kv = reinterpret_cast<MMKV *>(handle);
447      if (kv && oKey) {
448          string key = jstring2string(env, oKey);
449          return (jboolean) kv->set((double) value, key, (uint32_t) expiration);
450      }
451      return (jboolean) false;
452  }
453  MMKV_JNI jdouble decodeDouble(JNIEnv *env, jobject, jlong handle, jstring oKey, jdouble defaultValue) {
454      MMKV *kv = reinterpret_cast<MMKV *>(handle);
455      if (kv && oKey) {
456          string key = jstring2string(env, oKey);
457          return (jdouble) kv->getDouble(key, defaultValue);
458      }
459      return defaultValue;
460  }
461  MMKV_JNI jboolean encodeString(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue) {
462      MMKV *kv = reinterpret_cast<MMKV *>(handle);
463      if (kv && oKey) {
464          string key = jstring2string(env, oKey);
465          if (oValue) {
466              string value = jstring2string(env, oValue);
467              return (jboolean) kv->set(value, key);
468          } else {
469              kv->removeValueForKey(key);
470              return (jboolean) true;
471          }
472      }
473      return (jboolean) false;
474  }
475  MMKV_JNI jboolean encodeString_2(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue, jint expiration) {
476      MMKV *kv = reinterpret_cast<MMKV *>(handle);
477      if (kv && oKey) {
478          string key = jstring2string(env, oKey);
479          if (oValue) {
480              string value = jstring2string(env, oValue);
481              return (jboolean) kv->set(value, key, (uint32_t) expiration);
482          } else {
483              kv->removeValueForKey(key);
484              return (jboolean) true;
485          }
486      }
487      return (jboolean) false;
488  }
489  MMKV_JNI jstring decodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) {
490      MMKV *kv = reinterpret_cast<MMKV *>(handle);
491      if (kv && oKey) {
492          string key = jstring2string(env, oKey);
493          string value;
494          bool hasValue = kv->getString(key, value);
495          if (hasValue) {
496              return string2jstring(env, value);
497          }
498      }
499      return oDefaultValue;
500  }
501  MMKV_JNI jboolean encodeBytes(JNIEnv *env, jobject, jlong handle, jstring oKey, jbyteArray oValue) {
502      MMKV *kv = reinterpret_cast<MMKV *>(handle);
503      if (kv && oKey) {
504          string key = jstring2string(env, oKey);
505          if (oValue) {
506              MMBuffer value(0);
507              {
508                  jsize len = env->GetArrayLength(oValue);
509                  void *bufferPtr = env->GetPrimitiveArrayCritical(oValue, nullptr);
510                  if (bufferPtr) {
511                      value = MMBuffer(bufferPtr, len);
512                      env->ReleasePrimitiveArrayCritical(oValue, bufferPtr, JNI_ABORT);
513                  } else {
514                      MMKVError("fail to get array: %s=%p", key.c_str(), oValue);
515                  }
516              }
517              return (jboolean) kv->set(value, key);
518          } else {
519              kv->removeValueForKey(key);
520              return (jboolean) true;
521          }
522      }
523      return (jboolean) false;
524  }
525  MMKV_JNI jboolean encodeBytes_2(JNIEnv *env, jobject, jlong handle, jstring oKey, jbyteArray oValue, jint expiration) {
526      MMKV *kv = reinterpret_cast<MMKV *>(handle);
527      if (kv && oKey) {
528          string key = jstring2string(env, oKey);
529          if (oValue) {
530              MMBuffer value(0);
531              {
532                  jsize len = env->GetArrayLength(oValue);
533                  void *bufferPtr = env->GetPrimitiveArrayCritical(oValue, nullptr);
534                  if (bufferPtr) {
535                      value = MMBuffer(bufferPtr, len);
536                      env->ReleasePrimitiveArrayCritical(oValue, bufferPtr, JNI_ABORT);
537                  } else {
538                      MMKVError("fail to get array: %s=%p", key.c_str(), oValue);
539                  }
540              }
541              return (jboolean) kv->set(value, key, (uint32_t) expiration);
542          } else {
543              kv->removeValueForKey(key);
544              return (jboolean) true;
545          }
546      }
547      return (jboolean) false;
548  }
549  MMKV_JNI jbyteArray decodeBytes(JNIEnv *env, jobject obj, jlong handle, jstring oKey) {
550      MMKV *kv = reinterpret_cast<MMKV *>(handle);
551      if (kv && oKey) {
552          string key = jstring2string(env, oKey);
553          MMBuffer value = kv->getBytes(key);
554          if (value.length() > 0) {
555              jbyteArray result = env->NewByteArray(value.length());
556              env->SetByteArrayRegion(result, 0, value.length(), (const jbyte *) value.getPtr());
557              return result;
558          }
559      }
560      return nullptr;
561  }
562  MMKV_JNI jobjectArray allKeys(JNIEnv *env, jobject instance) {
563      MMKV *kv = getMMKV(env, instance);
564      if (kv) {
565          vector<string> keys = kv->allKeys();
566          return vector2jarray(env, keys);
567      }
568      return nullptr;
569  }
570  MMKV_JNI jboolean containsKey(JNIEnv *env, jobject instance, jlong handle, jstring oKey) {
571      MMKV *kv = reinterpret_cast<MMKV *>(handle);
572      if (kv && oKey) {
573          string key = jstring2string(env, oKey);
574          return (jboolean) kv->containsKey(key);
575      }
576      return (jboolean) false;
577  }
578  MMKV_JNI jlong count(JNIEnv *env, jobject instance, jlong handle) {
579      MMKV *kv = reinterpret_cast<MMKV *>(handle);
580      if (kv) {
581          jlong size = kv->count();
582          return size;
583      }
584      return 0;
585  }
586  MMKV_JNI jlong totalSize(JNIEnv *env, jobject instance, jlong handle) {
587      MMKV *kv = reinterpret_cast<MMKV *>(handle);
588      if (kv) {
589          jlong size = kv->totalSize();
590          return size;
591      }
592      return 0;
593  }
594  MMKV_JNI jlong actualSize(JNIEnv *env, jobject instance, jlong handle) {
595      MMKV *kv = reinterpret_cast<MMKV *>(handle);
596      if (kv) {
597          jlong size = kv->actualSize();
598          return size;
599      }
600      return 0;
601  }
602  MMKV_JNI void removeValueForKey(JNIEnv *env, jobject instance, jlong handle, jstring oKey) {
603      MMKV *kv = reinterpret_cast<MMKV *>(handle);
604      if (kv && oKey) {
605          string key = jstring2string(env, oKey);
606          kv->removeValueForKey(key);
607      }
608  }
609  MMKV_JNI void removeValuesForKeys(JNIEnv *env, jobject instance, jobjectArray arrKeys) {
610      MMKV *kv = getMMKV(env, instance);
611      if (kv && arrKeys) {
612          vector<string> keys = jarray2vector(env, arrKeys);
613          if (!keys.empty()) {
614              kv->removeValuesForKeys(keys);
615          }
616      }
617  }
618  MMKV_JNI void clearAll(JNIEnv *env, jobject instance) {
619      MMKV *kv = getMMKV(env, instance);
620      if (kv) {
621          kv->clearAll();
622      }
623  }
624  MMKV_JNI void sync(JNIEnv *env, jobject instance, jboolean sync) {
625      MMKV *kv = getMMKV(env, instance);
626      if (kv) {
627          kv->sync((SyncFlag) sync);
628      }
629  }
630  MMKV_JNI jboolean isFileValid(JNIEnv *env, jclass type, jstring oMmapID, jstring rootPath) {
631      if (oMmapID) {
632          string mmapID = jstring2string(env, oMmapID);
633          if (!rootPath) {
634              return (jboolean) MMKV::isFileValid(mmapID, nullptr);
635          } else {
636              auto root = jstring2string(env, rootPath);
637              return (jboolean) MMKV::isFileValid(mmapID, &root);
638          }
639      }
640      return (jboolean) false;
641  }
642  MMKV_JNI jboolean encodeSet(JNIEnv *env, jobject, jlong handle, jstring oKey, jobjectArray arrStr) {
643      MMKV *kv = reinterpret_cast<MMKV *>(handle);
644      if (kv && oKey) {
645          string key = jstring2string(env, oKey);
646          if (arrStr) {
647              vector<string> value = jarray2vector(env, arrStr);
648              return (jboolean) kv->set(value, key);
649          } else {
650              kv->removeValueForKey(key);
651              return (jboolean) true;
652          }
653      }
654      return (jboolean) false;
655  }
656  MMKV_JNI jboolean encodeSet_2(JNIEnv *env, jobject, jlong handle, jstring oKey, jobjectArray arrStr, jint expiration) {
657      MMKV *kv = reinterpret_cast<MMKV *>(handle);
658      if (kv && oKey) {
659          string key = jstring2string(env, oKey);
660          if (arrStr) {
661              vector<string> value = jarray2vector(env, arrStr);
662              return (jboolean) kv->set(value, key, (uint32_t) expiration);
663          } else {
664              kv->removeValueForKey(key);
665              return (jboolean) true;
666          }
667      }
668      return (jboolean) false;
669  }
670  MMKV_JNI jobjectArray decodeStringSet(JNIEnv *env, jobject, jlong handle, jstring oKey) {
671      MMKV *kv = reinterpret_cast<MMKV *>(handle);
672      if (kv && oKey) {
673          string key = jstring2string(env, oKey);
674          vector<string> value;
675          bool hasValue = kv->getVector(key, value);
676          if (hasValue) {
677              return vector2jarray(env, value);
678          }
679      }
680      return nullptr;
681  }
682  MMKV_JNI void clearMemoryCache(JNIEnv *env, jobject instance) {
683      MMKV *kv = getMMKV(env, instance);
684      if (kv) {
685          kv->clearMemoryCache();
686      }
687  }
688  MMKV_JNI void lock(JNIEnv *env, jobject instance) {
689      MMKV *kv = getMMKV(env, instance);
690      if (kv) {
691          kv->lock();
692      }
693  }
694  MMKV_JNI void unlock(JNIEnv *env, jobject instance) {
695      MMKV *kv = getMMKV(env, instance);
696      if (kv) {
697          kv->unlock();
698      }
699  }
700  MMKV_JNI jboolean tryLock(JNIEnv *env, jobject instance) {
701      MMKV *kv = getMMKV(env, instance);
702      if (kv) {
703          return (jboolean) kv->try_lock();
704      }
705      return jboolean(false);
706  }
707  MMKV_JNI jint pageSize(JNIEnv *env, jclass type) {
708      return DEFAULT_MMAP_SIZE;
709  }
710  MMKV_JNI jstring version(JNIEnv *env, jclass type) {
711      return string2jstring(env, MMKV_VERSION);
712  }
713  #    ifndef MMKV_DISABLE_CRYPT
714  MMKV_JNI jstring cryptKey(JNIEnv *env, jobject instance) {
715      MMKV *kv = getMMKV(env, instance);
716      if (kv) {
717          string cryptKey = kv->cryptKey();
718          if (cryptKey.length() > 0) {
719              return string2jstring(env, cryptKey);
720          }
721      }
722      return nullptr;
723  }
724  MMKV_JNI jboolean reKey(JNIEnv *env, jobject instance, jstring cryptKey) {
725      MMKV *kv = getMMKV(env, instance);
726      if (kv) {
727          string newKey;
728          if (cryptKey) {
729              newKey = jstring2string(env, cryptKey);
730          }
731          return (jboolean) kv->reKey(newKey);
732      }
733      return (jboolean) false;
734  }
735  MMKV_JNI void checkReSetCryptKey(JNIEnv *env, jobject instance, jstring cryptKey) {
736      MMKV *kv = getMMKV(env, instance);
737      if (kv) {
738          string newKey;
739          if (cryptKey) {
740              newKey = jstring2string(env, cryptKey);
741          }
742          if (!cryptKey || newKey.empty()) {
743              kv->checkReSetCryptKey(nullptr);
744          } else {
745              kv->checkReSetCryptKey(&newKey);
746          }
747      }
748  }
749  #    else
750  MMKV_JNI jstring cryptKey(JNIEnv *env, jobject instance) {
751      return nullptr;
752  }
753  #    endif 
754  MMKV_JNI void trim(JNIEnv *env, jobject instance) {
755      MMKV *kv = getMMKV(env, instance);
756      if (kv) {
757          kv->trim();
758      }
759  }
760  MMKV_JNI void close(JNIEnv *env, jobject instance) {
761      MMKV *kv = getMMKV(env, instance);
762      if (kv) {
763          kv->close();
764          env->SetLongField(instance, g_fileID, 0);
765      }
766  }
767  MMKV_JNI jint valueSize(JNIEnv *env, jobject, jlong handle, jstring oKey, jboolean actualSize) {
768      MMKV *kv = reinterpret_cast<MMKV *>(handle);
769      if (kv && oKey) {
770          string key = jstring2string(env, oKey);
771          return static_cast<jint>(kv->getValueSize(key, (bool) actualSize));
772      }
773      return 0;
774  }
775  MMKV_JNI void setLogLevel(JNIEnv *env, jclass type, jint level) {
776      MMKV::setLogLevel((MMKVLogLevel) level);
777  }
778  MMKV_JNI void setCallbackHandler(JNIEnv *env, jclass type, jboolean logReDirecting, jboolean hasCallback) {
779      if (logReDirecting == JNI_TRUE) {
780          MMKV::registerLogHandler(mmkvLog);
781      } else {
782          MMKV::unRegisterLogHandler();
783      }
784      if (hasCallback == JNI_TRUE) {
785          MMKV::registerErrorHandler(onMMKVError);
786      } else {
787          MMKV::unRegisterErrorHandler();
788      }
789  }
790  MMKV_JNI jlong createNB(JNIEnv *env, jobject instance, jint size) {
791      auto ptr = malloc(static_cast<size_t>(size));
792      if (!ptr) {
793          MMKVError("fail to create NativeBuffer:%s", strerror(errno));
794          return 0;
795      }
796      return reinterpret_cast<jlong>(ptr);
797  }
798  MMKV_JNI void destroyNB(JNIEnv *env, jobject instance, jlong pointer, jint size) {
799      free(reinterpret_cast<void *>(pointer));
800  }
801  MMKV_JNI jint writeValueToNB(JNIEnv *env, jobject instance, jlong handle, jstring oKey, jlong pointer, jint size) {
802      MMKV *kv = reinterpret_cast<MMKV *>(handle);
803      if (kv && oKey) {
804          string key = jstring2string(env, oKey);
805          return kv->writeValueToBuffer(key, reinterpret_cast<void *>(pointer), size);
806      }
807      return -1;
808  }
809  MMKV_JNI void setWantsContentChangeNotify(JNIEnv *env, jclass type, jboolean notify) {
810      if (notify == JNI_TRUE) {
811          MMKV::registerContentChangeHandler(onContentChangedByOuterProcess);
812      } else {
813          MMKV::unRegisterContentChangeHandler();
814      }
815  }
816  MMKV_JNI void checkContentChanged(JNIEnv *env, jobject instance) {
817      MMKV *kv = getMMKV(env, instance);
818      if (kv) {
819          kv->checkContentChanged();
820      }
821  }
822  MMKV_JNI jboolean backupOne(JNIEnv *env, jobject obj, jstring mmapID, jstring dstDir, jstring rootPath) {
823      if (rootPath) {
824          string root = jstring2string(env, rootPath);
825          if (root.length() > 0) {
826              return (jboolean) MMKV::backupOneToDirectory(jstring2string(env, mmapID), jstring2string(env, dstDir), &root);
827          }
828      }
829      return (jboolean) MMKV::backupOneToDirectory(jstring2string(env, mmapID), jstring2string(env, dstDir));
830  }
831  MMKV_JNI jboolean restoreOne(JNIEnv *env, jobject obj, jstring mmapID, jstring srcDir, jstring rootPath) {
832      if (rootPath) {
833          string root = jstring2string(env, rootPath);
834          if (root.length() > 0) {
835              return (jboolean) MMKV::restoreOneFromDirectory(jstring2string(env, mmapID), jstring2string(env, srcDir), &root);
836          }
837      }
838      return (jboolean) MMKV::restoreOneFromDirectory(jstring2string(env, mmapID), jstring2string(env, srcDir));
<span onclick='openModal()' class='match'>839  }
840  MMKV_JNI jlong backupAll(JNIEnv *env, jobject obj, jstring dstDir&bsol;*, jstring rootPath*/) {
841      return (jlong) MMKV::backupAllToDirectory(jstring2string(env, dstDir));
842  }
843  MMKV_JNI jlong restoreAll(JNIEnv *env, jobject obj, jstring srcDir&bsol;*, jstring rootPath*/) {
844      return (jlong) MMKV::restoreAllFromDirectory(jstring2string(env, srcDir));
</span>845  }
846  MMKV_JNI jboolean enableAutoExpire(JNIEnv *env, jobject instance, jint expireDuration) {
847      MMKV *kv = getMMKV(env, instance);
848      if (kv) {
849          return (jboolean) kv->enableAutoKeyExpire(expireDuration);
850      }
851      return (jboolean) false;
852  }
853  MMKV_JNI jboolean disableAutoExpire(JNIEnv *env, jobject instance) {
854      MMKV *kv = getMMKV(env, instance);
855      if (kv) {
856          return (jboolean) kv->disableAutoKeyExpire();
857      }
858      return (jboolean) false;
859  }
860  } 
861  static JNINativeMethod g_methods[] = {
862      {"onExit", "()V", (void *) mmkv::onExit},
863      {"cryptKey", "()Ljava/lang/String;", (void *) mmkv::cryptKey},
864  #    ifndef MMKV_DISABLE_CRYPT
865      {"reKey", "(Ljava/lang/String;)Z", (void *) mmkv::reKey},
866      {"checkReSetCryptKey", "(Ljava/lang/String;)V", (void *) mmkv::checkReSetCryptKey},
867  #    endif
868      {"pageSize", "()I", (void *) mmkv::pageSize},
869      {"mmapID", "()Ljava/lang/String;", (void *) mmkv::mmapID},
870      {"version", "()Ljava/lang/String;", (void *) mmkv::version},
871      {"lock", "()V", (void *) mmkv::lock},
872      {"unlock", "()V", (void *) mmkv::unlock},
873      {"tryLock", "()Z", (void *) mmkv::tryLock},
874      {"allKeys", "()[Ljava/lang/String;", (void *) mmkv::allKeys},
875      {"removeValuesForKeys", "([Ljava/lang/String;)V", (void *) mmkv::removeValuesForKeys},
876      {"clearAll", "()V", (void *) mmkv::clearAll},
877      {"trim", "()V", (void *) mmkv::trim},
878      {"close", "()V", (void *) mmkv::close},
879      {"clearMemoryCache", "()V", (void *) mmkv::clearMemoryCache},
880      {"sync", "(Z)V", (void *) mmkv::sync},
881      {"isFileValid", "(Ljava/lang/String;Ljava/lang/String;)Z", (void *) mmkv::isFileValid},
882      {"ashmemFD", "()I", (void *) mmkv::ashmemFD},
883      {"ashmemMetaFD", "()I", (void *) mmkv::ashmemMetaFD},
884      {"jniInitialize", "(Ljava/lang/String;Ljava/lang/String;IZ)V", (void *) mmkv::jniInitialize_2},
885      {"getMMKVWithID", "(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)J", (void *) mmkv::getMMKVWithID},
886      {"getMMKVWithIDAndSize", "(Ljava/lang/String;IILjava/lang/String;)J", (void *) mmkv::getMMKVWithIDAndSize},
887      {"getDefaultMMKV", "(ILjava/lang/String;)J", (void *) mmkv::getDefaultMMKV},
888      {"getMMKVWithAshmemFD", "(Ljava/lang/String;IILjava/lang/String;)J", (void *) mmkv::getMMKVWithAshmemFD},
889      {"encodeBool", "(JLjava/lang/String;Z)Z", (void *) mmkv::encodeBool},
890      {"encodeBool_2", "(JLjava/lang/String;ZI)Z", (void *) mmkv::encodeBool_2},
891      {"decodeBool", "(JLjava/lang/String;Z)Z", (void *) mmkv::decodeBool},
892      {"encodeInt", "(JLjava/lang/String;I)Z", (void *) mmkv::encodeInt},
893      {"encodeInt_2", "(JLjava/lang/String;II)Z", (void *) mmkv::encodeInt_2},
894      {"decodeInt", "(JLjava/lang/String;I)I", (void *) mmkv::decodeInt},
895      {"encodeLong", "(JLjava/lang/String;J)Z", (void *) mmkv::encodeLong},
896      {"encodeLong_2", "(JLjava/lang/String;JI)Z", (void *) mmkv::encodeLong_2},
897      {"decodeLong", "(JLjava/lang/String;J)J", (void *) mmkv::decodeLong},
898      {"encodeFloat", "(JLjava/lang/String;F)Z", (void *) mmkv::encodeFloat},
899      {"encodeFloat_2", "(JLjava/lang/String;FI)Z", (void *) mmkv::encodeFloat_2},
900      {"decodeFloat", "(JLjava/lang/String;F)F", (void *) mmkv::decodeFloat},
901      {"encodeDouble", "(JLjava/lang/String;D)Z", (void *) mmkv::encodeDouble},
902      {"encodeDouble_2", "(JLjava/lang/String;DI)Z", (void *) mmkv::encodeDouble_2},
903      {"decodeDouble", "(JLjava/lang/String;D)D", (void *) mmkv::decodeDouble},
904      {"encodeString", "(JLjava/lang/String;Ljava/lang/String;)Z", (void *) mmkv::encodeString},
905      {"encodeString_2", "(JLjava/lang/String;Ljava/lang/String;I)Z", (void *) mmkv::encodeString_2},
906      {"decodeString", "(JLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;", (void *) mmkv::decodeString},
907      {"encodeSet", "(JLjava/lang/String;[Ljava/lang/String;)Z", (void *) mmkv::encodeSet},
908      {"encodeSet_2", "(JLjava/lang/String;[Ljava/lang/String;I)Z", (void *) mmkv::encodeSet_2},
909      {"decodeStringSet", "(JLjava/lang/String;)[Ljava/lang/String;", (void *) mmkv::decodeStringSet},
910      {"encodeBytes", "(JLjava/lang/String;[B)Z", (void *) mmkv::encodeBytes},
911      {"encodeBytes_2", "(JLjava/lang/String;[BI)Z", (void *) mmkv::encodeBytes_2},
912      {"decodeBytes", "(JLjava/lang/String;)[B", (void *) mmkv::decodeBytes},
913      {"containsKey", "(JLjava/lang/String;)Z", (void *) mmkv::containsKey},
914      {"count", "(J)J", (void *) mmkv::count},
915      {"totalSize", "(J)J", (void *) mmkv::totalSize},
916      {"actualSize", "(J)J", (void *) mmkv::actualSize},
917      {"removeValueForKey", "(JLjava/lang/String;)V", (void *) mmkv::removeValueForKey},
918      {"valueSize", "(JLjava/lang/String;Z)I", (void *) mmkv::valueSize},
919      {"setLogLevel", "(I)V", (void *) mmkv::setLogLevel},
920      {"setCallbackHandler", "(ZZ)V", (void *) mmkv::setCallbackHandler},
921      {"createNB", "(I)J", (void *) mmkv::createNB},
922      {"destroyNB", "(JI)V", (void *) mmkv::destroyNB},
923      {"writeValueToNB", "(JLjava/lang/String;JI)I", (void *) mmkv::writeValueToNB},
924      {"setWantsContentChangeNotify", "(Z)V", (void *) mmkv::setWantsContentChangeNotify},
925      {"checkContentChangedByOuterProcess", "()V", (void *) mmkv::checkContentChanged},
926      {"checkProcessMode", "(J)Z", (void *) mmkv::checkProcessMode},
927      {"backupOneToDirectory", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z", (void *) mmkv::backupOne},
928      {"restoreOneMMKVFromDirectory", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Z", (void *) mmkv::restoreOne},
929      {"backupAllToDirectory", "(Ljava/lang/String;)J", (void *) mmkv::backupAll},
930      {"restoreAllFromDirectory", "(Ljava/lang/String;)J", (void *) mmkv::restoreAll},
931      {"enableAutoKeyExpire", "(I)Z", (void *) mmkv::enableAutoExpire},
932      {"disableAutoKeyExpire", "()Z", (void *) mmkv::disableAutoExpire},
933  };
934  static int registerNativeMethods(JNIEnv *env, jclass cls) {
935      return env->RegisterNatives(cls, g_methods, sizeof(g_methods) / sizeof(g_methods[0]));
936  }
937  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CellBuffer.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-native-bridge.cpp</div>
                </div>
                <div class="column column_space"><pre><code>108  	CellBuffer &operator=(CellBuffer &&) = delete;
109  	~CellBuffer() noexcept;
110  	char CharAt(Sci::Position position) const noexcept;
111  	unsigned char UCharAt(Sci::Position position) const noexcept;
112  	void GetCharRange(char *buffer, Sci::Position position, Sci::Position lengthRetrieve) const;
</pre></code></div>
                <div class="column column_space"><pre><code>839  }
840  MMKV_JNI jlong backupAll(JNIEnv *env, jobject obj, jstring dstDir&bsol;*, jstring rootPath*/) {
841      return (jlong) MMKV::backupAllToDirectory(jstring2string(env, dstDir));
842  }
843  MMKV_JNI jlong restoreAll(JNIEnv *env, jobject obj, jstring srcDir&bsol;*, jstring rootPath*/) {
844      return (jlong) MMKV::restoreAllFromDirectory(jstring2string(env, srcDir));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    