
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.563409563409564%, Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-peer_container.cpp</h3>
            <pre><code>1  #include <nano/node/transport/socket.hpp>
2  #include <nano/node/transport/tcp.hpp>
3  #include <nano/node/transport/tcp_server.hpp>
4  #include <nano/test_common/network.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  #include <memory>
9  using namespace std::chrono_literals;
10  TEST (peer_container, empty_peers)
11  {
12  	nano::test::system system (1);
13  	nano::network & network (system.nodes[0]->network);
14  	system.nodes[0]->network.cleanup (std::chrono::steady_clock::now ());
15  	ASSERT_EQ (0, network.size ());
16  }
17  TEST (peer_container, no_self_incoming)
18  {
19  	nano::test::system system{ 1 };
20  	auto & node = *system.nodes[0];
21  	node.network.tcp_channels.start_tcp (node.network.endpoint ());
22  	auto error = system.poll_until_true (2s, [&node] {
23  		auto result = node.network.tcp_channels.find_channel (nano::transport::map_endpoint_to_tcp (node.network.endpoint ()));
24  		return result != nullptr;
25  	});
26  	ASSERT_TRUE (error);
27  	ASSERT_TRUE (system.nodes[0]->network.empty ());
28  }
29  TEST (peer_container, reserved_ip_is_not_a_peer)
30  {
31  	nano::test::system system{ 1 };
32  	auto not_a_peer = [&node = system.nodes[0]] (nano::endpoint endpoint_a) -> bool {
33  		return node->network.not_a_peer (endpoint_a, true);
34  	};
35  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0x00000001)), 10000))));
36  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xc0000201)), 10000))));
37  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xc6336401)), 10000))));
38  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xcb007101)), 10000))));
39  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xe9fc0001)), 10000))));
40  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xf0000001)), 10000))));
41  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xffffffff)), 10000))));
42  	ASSERT_FALSE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0x08080808)), 10000))));
43  }
44  TEST (peer_container, tcp_channel_cleanup_works)
45  {
46  	nano::test::system system;
47  	nano::node_config node_config = system.default_config ();
48  	node_config.network_params.network.keepalive_period = std::chrono::minutes (10);
49  	nano::node_flags node_flags;
50  	node_flags.disable_connection_cleanup = true;
51  	node_flags.disable_rep_crawler = true;
52  	auto & node1 = *system.add_node (node_config, node_flags);
53  	auto outer_node1 = nano::test::add_outer_node (system, node_flags);
54  	outer_node1->config.network_params.network.keepalive_period = std::chrono::minutes (10);
55  	auto outer_node2 = nano::test::add_outer_node (system, node_flags);
56  	outer_node2->config.network_params.network.keepalive_period = std::chrono::minutes (10);
57  	auto now = std::chrono::steady_clock::now ();
58  	auto channel1 = nano::test::establish_tcp (system, node1, outer_node1->network.endpoint ());
59  	ASSERT_NE (nullptr, channel1);
60  	node1.network.tcp_channels.modify (channel1, [&now] (auto channel) {
61  		channel->set_last_packet_sent (now - std::chrono::seconds (5));
62  	});
63  	auto channel2 = nano::test::establish_tcp (system, node1, outer_node2->network.endpoint ());
64  	ASSERT_NE (nullptr, channel2);
65  	node1.network.tcp_channels.modify (channel2, [&now] (auto channel) {
66  		channel->set_last_packet_sent (now + std::chrono::seconds (1));
67  	});
68  	ASSERT_EQ (2, node1.network.size ());
69  	ASSERT_EQ (2, node1.network.tcp_channels.size ());
70  	for (auto it = 0; node1.network.tcp_channels.size () > 1 && it < 10; ++it)
71  	{
72  		auto const channel1_last_packet_sent = channel1->get_last_packet_sent ();
73  		auto const channel2_last_packet_sent = channel2->get_last_packet_sent ();
74  		auto const max_last_packet_sent = std::max (channel1_last_packet_sent, channel2_last_packet_sent);
75  		auto const min_last_packet_sent = std::min (channel1_last_packet_sent, channel2_last_packet_sent);
76  		auto const cleanup_point = ((max_last_packet_sent - min_last_packet_sent) / 2) + min_last_packet_sent;
77  		node1.network.cleanup (cleanup_point);
78  		if (node1.network.tcp_channels.size () == 2)
79  		{
80  			WAIT (500ms);
81  		}
82  	}
83  	ASSERT_EQ (1, node1.network.size ());
84  	ASSERT_EQ (1, node1.network.tcp_channels.size ());
85  }
86  TEST (channels, fill_random_clear)
87  {
88  	nano::test::system system (1);
89  	std::array<nano::endpoint, 8> target;
90  	std::fill (target.begin (), target.end (), nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000));
91  	system.nodes[0]->network.random_fill (target);
92  	ASSERT_TRUE (std::all_of (target.begin (), target.end (), [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::any (), 0); }));
93  }
94  TEST (channels, fill_random_full)
95  {
96  	nano::test::system system{ 1 };
97  	for (int i = 0; i < 8; ++i)
98  	{
99  		auto outer_node = nano::test::add_outer_node (system);
100  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
101  	}
102  	ASSERT_TIMELY_EQ (5s, 8, system.nodes[0]->network.tcp_channels.size ());
103  	auto filler_endpoint = nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000);
104  	std::array<nano::endpoint, 8> target;
105  	std::fill (target.begin (), target.end (), filler_endpoint);
106  	system.nodes[0]->network.random_fill (target);
107  	auto is_filler = [&filler_endpoint] (nano::endpoint const & endpoint_a) {
108  		return endpoint_a == filler_endpoint;
109  	};
110  	ASSERT_TRUE (std::none_of (target.begin (), target.end (), is_filler));
111  }
112  TEST (channels, fill_random_part)
113  {
114  	nano::test::system system{ 1 };
115  	std::array<nano::endpoint, 8> target;
116  	std::size_t half = target.size () / 2;
117  	for (std::size_t i = 0; i < half; ++i)
118  	{
119  		auto outer_node = nano::test::add_outer_node (system);
120  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
121  	}
122  	ASSERT_EQ (half, system.nodes[0]->network.tcp_channels.size ());
123  	std::fill (target.begin (), target.end (), nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000));
124  	system.nodes[0]->network.random_fill (target);
125  	ASSERT_TRUE (std::none_of (target.begin (), target.begin () + half, [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000); }));
126  	ASSERT_TRUE (std::none_of (target.begin (), target.begin () + half, [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::loopback (), 0); }));
127  	ASSERT_TRUE (std::all_of (target.begin () + half, target.end (), [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::any (), 0); }));
128  }
129  TEST (peer_container, list_fanout)
130  {
131  	nano::test::system system{ 1 };
132  	auto node = system.nodes[0];
133  	ASSERT_EQ (0, node->network.size ());
134  	ASSERT_EQ (0.0, node->network.size_sqrt ());
135  	ASSERT_EQ (0, node->network.fanout ());
136  	ASSERT_TRUE (node->network.list (node->network.fanout ()).empty ());
137  	auto add_peer = [&node, &system] () {
138  		auto outer_node = nano::test::add_outer_node (system);
139  		auto channel = nano::test::establish_tcp (system, *node, outer_node->network.endpoint ());
140  	};
141  	add_peer ();
142  	ASSERT_TIMELY_EQ (5s, 1, node->network.size ());
143  	ASSERT_EQ (1.f, node->network.size_sqrt ());
144  	ASSERT_EQ (1, node->network.fanout ());
145  	ASSERT_EQ (1, node->network.list (node->network.fanout ()).size ());
146  	add_peer ();
147  	ASSERT_TIMELY_EQ (5s, 2, node->network.size ());
148  	ASSERT_EQ (std::sqrt (2.f), node->network.size_sqrt ());
149  	ASSERT_EQ (2, node->network.fanout ());
150  	ASSERT_EQ (2, node->network.list (node->network.fanout ()).size ());
151  	unsigned number_of_peers = 10;
152  	for (unsigned i = 2; i < number_of_peers; ++i)
153  	{
154  		add_peer ();
155  	}
156  	ASSERT_TIMELY_EQ (5s, number_of_peers, node->network.size ());
157  	ASSERT_EQ (std::sqrt (float (number_of_peers)), node->network.size_sqrt ());
<span onclick='openModal()' class='match'>158  	ASSERT_EQ (4, node->network.fanout ());
159  	ASSERT_EQ (4, node->network.list (node->network.fanout ()).size ());
160  }
161  TEST (peer_container, reachout)
162  {
163  	nano::test::system system;
164  	nano::node_flags node_flags;
165  	auto & node1 = *system.add_node (node_flags);
166  	auto outer_node1 = nano::test::add_outer_node (system);
</span>167  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, node1, outer_node1->network.endpoint ()));
168  	ASSERT_TRUE (node1.network.reachout (outer_node1->network.endpoint ()));
169  	auto outer_node2 = nano::test::add_outer_node (system);
170  	ASSERT_FALSE (node1.network.reachout (outer_node2->network.endpoint ()));
171  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, node1, outer_node2->network.endpoint ()));
172  	ASSERT_TRUE (node1.network.reachout (outer_node2->network.endpoint ()));
173  	node1.network.cleanup (std::chrono::steady_clock::now () - std::chrono::seconds (10));
174  	ASSERT_TRUE (node1.network.reachout (outer_node2->network.endpoint ()));
175  	node1.network.cleanup (std::chrono::steady_clock::now () + std::chrono::seconds (10));
176  	ASSERT_FALSE (node1.network.reachout (outer_node2->network.endpoint ()));
177  }
178  TEST (peer_container, depeer_on_outdated_version)
179  {
180  	nano::test::system system{ 2 };
181  	auto & node1 = *system.nodes[0];
182  	auto & node2 = *system.nodes[1];
183  	auto channel = node2.network.find_node_id (node1.get_node_id ());
184  	ASSERT_NE (nullptr, channel);
185  	nano::keepalive keepalive{ nano::dev::network_params.network };
186  	const_cast<uint8_t &> (keepalive.header.version_using) = nano::dev::network_params.network.protocol_version_min - 1;
187  	ASSERT_TIMELY (5s, channel->alive ());
188  	channel->send (keepalive);
189  	ASSERT_TIMELY (5s, !channel->alive ());
190  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wmine.cpp</h3>
            <pre><code>1  #include "wmine.h"
2  void TWebLog::GetUsrUrlRankStep(
3   const double& TaxFact, const TIntPrV& LRIdPrV,
4   TFltIntKdV& WgtLIdKdV, TFltIntKdV& WgtRIdKdV, double& WgtDiff){
5    int WgtRIdKds=WgtRIdKdV.Len();
6    TFltIntKdV NewWgtRIdKdV(WgtRIdKds, 0);
7    for (int NewRIdN=0; NewRIdN<WgtRIdKds; NewRIdN++){
8      NewWgtRIdKdV.Add(TFltIntKd(0, WgtRIdKdV[NewRIdN].Dat));}
9    double TaxWealth=0;
10    int LRIdKdN=0; int LRIdKds=LRIdPrV.Len(); double WgtSum=0;
11    while (LRIdKdN<LRIdKds){
12      int LId=LRIdPrV[LRIdKdN].Val1;
13      double LWgt=(1-TaxFact)*WgtLIdKdV[LId].Key;
14      TaxWealth+=TaxFact*WgtLIdKdV[LId].Key;
15      int RIds=0;
16      while ((LRIdKdN+RIds<LRIdKds)&&
17       (LRIdPrV[LRIdKdN+RIds].Val1==LId)){RIds++;}
18      for (int RIdN=0; RIdN<RIds; RIdN++){
19        int RId=LRIdPrV[LRIdKdN+RIdN].Val2;
20        NewWgtRIdKdV[RId].Key+=LWgt/RIds;
21        WgtSum+=LWgt/RIds;
22      }
23      LRIdKdN+=RIds;
24    }
25    for (int RIdWgtKdN=0; RIdWgtKdN<WgtRIdKds; RIdWgtKdN++){
26      WgtDiff+=fabs(NewWgtRIdKdV[RIdWgtKdN].Key-WgtRIdKdV[RIdWgtKdN].Key);
27      WgtRIdKdV[RIdWgtKdN].Key=0;
28      WgtRIdKdV[RIdWgtKdN].Key+=NewWgtRIdKdV[RIdWgtKdN].Key;
29    }
30  }
31  void TWebLog::GetUsrUrlRank(
32   TFltIntKdV& WgtUsrIdKdV, TFltIntKdV& WgtUrlIdKdV) const {
33    int Usrs=GetUsrs(); int Urls=GetUrls();
34    WgtUsrIdKdV.Gen(Usrs, 0); WgtUrlIdKdV.Gen(Urls, 0);
35    for (int UsrId=0; UsrId<Usrs; UsrId++){WgtUsrIdKdV.Add(TFltIntKd(1, UsrId));}
36    for (int UrlId=0; UrlId<Urls; UrlId++){WgtUrlIdKdV.Add(TFltIntKd(0, UrlId));}
37    double TaxFact=0.15; int IterN=0; double KdevWgtDiff=0; double WgtDiff=0;
38    forever {
39      GetUsrUrlRankStep(TaxFact, UsrIdUrlIdPrV, WgtUsrIdKdV, WgtUrlIdKdV, WgtDiff);
40      GetUsrUrlRankStep(TaxFact, UrlIdUsrIdPrV, WgtUrlIdKdV, WgtUsrIdKdV, WgtDiff);
41      IterN++;
42      printf("%d: %g\n", IterN, fabs(WgtDiff-KdevWgtDiff));
43      if (fabs(WgtDiff-KdevWgtDiff)<0.001){break;}
44      KdevWgtDiff=WgtDiff;
45    }
46    WgtUrlIdKdV.Sort(false); WgtUsrIdKdV.Sort(false);
47  }
48  void TWebLog::SaveTxtUURank(const PSOut& SOut,
49   const TFltIntKdV& WgtUsrIdKdV, const TFltIntKdV& WgtUrlIdKdV,
50   const int& TopRecs) const {
51    int TopUrls=TopRecs;
52    if ((TopUrls==-1)||(TopUrls>GetUrls())){TopUrls=GetUrls();}
53    SOut->PutStr("================================="); SOut->PutLn();
54    SOut->PutStr("Best Urls"); SOut->PutLn();
55    for (int UrlN=0; UrlN<TopUrls; UrlN++){
56      double Wgt=WgtUrlIdKdV[UrlN].Key;
57      int UrlId=WgtUrlIdKdV[UrlN].Dat;
58      TStr UrlStr=GetUrlNm(UrlId);
59      TChA OutLn;
60      OutLn+=TInt::GetStr(UrlN+1, "%d.");
61      OutLn+=TFlt::GetStr(Wgt, " (%g)");
62      OutLn+=TStr::GetStr(UrlStr, " '%s'");
63      SOut->PutStr(OutLn); SOut->PutLn();
64    }
65    int TopUsrs=TopRecs;
66    if ((TopUsrs==-1)||(TopUsrs>GetUsrs())){TopUsrs=GetUsrs();}
67    SOut->PutStr("================================="); SOut->PutLn();
68    SOut->PutStr("Best Users"); SOut->PutLn();
69    for (int UsrN=0; UsrN<TopUsrs; UsrN++){
70      double Wgt=WgtUsrIdKdV[UsrN].Key;
71      int UsrId=WgtUsrIdKdV[UsrN].Dat;
72      TStr UsrStr=GetUsrNm(UsrId);
73      TChA OutLn;
74      OutLn+=TInt::GetStr(UsrN+1, "%d.");
75      OutLn+=TFlt::GetStr(Wgt, " (%g)");
76      OutLn+=TStr::GetStr(UsrStr, " '%s'");
77      SOut->PutStr(OutLn); SOut->PutLn();
78    }
79  }
80  void TWebLog::SaveXmlUURank(const PSOut& SOut,
81   const TFltIntKdV& WgtUsrIdKdV, const TFltIntKdV& WgtUrlIdKdV,
82   const int& TopRecs) const {
83    SOut->PutStr("<UrlUserRank>"); SOut->PutLn();
84    int TopUrls=TopRecs;
85    if ((TopUrls==-1)||(TopUrls>GetUrls())){TopUrls=GetUrls();}
86    SOut->PutStr("<UrlRank>"); SOut->PutLn();
87    for (int UrlN=0; UrlN<TopUrls; UrlN++){
88      double Wgt=WgtUrlIdKdV[UrlN].Key;
89      int UrlId=WgtUrlIdKdV[UrlN].Dat;
90      TStr UrlStr=GetUrlNm(UrlId);
91      TChA BTagChA;
92      BTagChA+="<Rank";
93      BTagChA+=TInt::GetStr(UrlN+1, " Place=\"%d\"");
94      BTagChA+=TFlt::GetStr(Wgt, " Weigth=\"%g\"");
95      BTagChA+=">";
96      SOut->PutStr(BTagChA);
97      TStr UrlXmlStr=TXmlLx::GetXmlStrFromPlainStr(UrlStr);
98      SOut->PutStr(UrlXmlStr);
99      SOut->PutStr("</Rank>");
100      SOut->PutLn();
101    }
102    SOut->PutStr("</UrlRank>"); SOut->PutLn();
103    int TopUsrs=TopRecs;
104    if ((TopUsrs==-1)||(TopUsrs>GetUsrs())){TopUsrs=GetUsrs();}
105    SOut->PutStr("<UserRank>"); SOut->PutLn();
106    for (int UsrN=0; UsrN<TopUsrs; UsrN++){
107      double Wgt=WgtUsrIdKdV[UsrN].Key;
108      int UsrId=WgtUsrIdKdV[UsrN].Dat;
109      TStr UsrStr=GetUsrNm(UsrId);
110      TChA BTagChA;
111      BTagChA+="<Rank";
112      BTagChA+=TInt::GetStr(UsrN+1, " Place=\"%d\"");
113      BTagChA+=TFlt::GetStr(Wgt, " Weigth=\"%g\"");
114      BTagChA+=">";
115      SOut->PutStr(BTagChA);
116      TStr UsrXmlStr=TXmlLx::GetXmlStrFromPlainStr(UsrStr);
117      SOut->PutStr(UsrXmlStr);
118      SOut->PutStr("</Rank>");
119      SOut->PutLn();
120    }
<span onclick='openModal()' class='match'>121    SOut->PutStr("</UserRank>"); SOut->PutLn();
122    SOut->PutStr("</UrlUserRank>"); SOut->PutLn();
123  }
124  PBowDocBs TWebLog::GetBowDocBs(
125   const TStrIntH& DocNmToFqH, const TIntPrV& DIdWIdPrV,
126   const TStrIntH& WordStrToFqH, const int& MnFq) const {
127    printf("Generating Bag-Of-Words...\n");
128    PBowDocBs BowDocBs=TBowDocBs::New();
129    int DIdWIdPrs=DIdWIdPrV.Len();
</span>130    int PrevDId=-1; TStr DocNm; TStrV WordStrV;
131    for (int DIdWIdPrN=0; DIdWIdPrN<DIdWIdPrs; DIdWIdPrN++){
132      if (DIdWIdPrN%100==0){printf("%d/%d\r", DIdWIdPrN, DIdWIdPrs);}
133      int DId=DIdWIdPrV[DIdWIdPrN].Val1;
134      int WId=DIdWIdPrV[DIdWIdPrN].Val2;
135      if ((PrevDId!=-1)&&(PrevDId!=DId)){
136        if (WordStrV.Len()>=MnFq){
137          BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
138        DocNm=DocNmToFqH.GetKey(DId);
139        WordStrV.Clr(false);
140      }
141      WordStrV.Add(WordStrToFqH.GetKey(WId));
142      PrevDId=DId;
143    }
144    if (!WordStrV.Empty()){
145      if (WordStrV.Len()>=MnFq){
146        BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
147    }
148    BowDocBs->AssertOk();
149    printf("\nDone.\n");
150    return BowDocBs;
151  }
152  PBowDocBs TWebLog::GetUsrBowDocBsFromUrl(const int& MnFq) const {
153    return GetBowDocBs(UsrNmToClicksH, UsrIdUrlIdPrV, UrlNmToClicksH, MnFq);
154  }
155  PBowDocBs TWebLog::GetUrlBowDocBsFromUsr(const int& MnFq) const {
156    return GetBowDocBs(UrlNmToClicksH, UrlIdUsrIdPrV, UsrNmToClicksH, MnFq);
157  }
158  PBowDocBs TWebLog::GetUsrBowDocBsFromHtml(
159   const int& MnFq, const TStr& WebRootFPath){
160    printf("Generating Bag-Of-Words...\n");
161    PBowDocBs BowDocBs=TBowDocBs::New();
162    TStrIntH& DocNmToFqH=UsrNmToClicksH;
163    TIntPrV& DIdWIdPrV=UsrIdUrlIdPrV;
164    TStrIntH& WordStrToFqH=UrlNmToClicksH;
165    TStr WebRootNrFPath=TStr::GetNrFPath(WebRootFPath);
166    if ((WebRootNrFPath.Len()>0)&&(WebRootNrFPath.LastCh()=='/')){
167      WebRootNrFPath.DelSubStr(WebRootNrFPath.Len()-1, WebRootNrFPath.Len()-1);}
168    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
169    int DIdWIdPrs=DIdWIdPrV.Len();
170    int PrevDId=-1; TStr DocNm; TStrV WordStrV; int NotFoundDocs=0;
171    for (int DIdWIdPrN=0; DIdWIdPrN<DIdWIdPrs; DIdWIdPrN++){
172      if (DIdWIdPrN%10==0){
173        printf("%d/%d (%d missed)\r", DIdWIdPrN, DIdWIdPrs, NotFoundDocs);}
174      int DId=DIdWIdPrV[DIdWIdPrN].Val1;
175      int WId=DIdWIdPrV[DIdWIdPrN].Val2;
176      if ((PrevDId!=-1)&&(PrevDId!=DId)){
177        if (WordStrV.Len()>=MnFq){
178          BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
179        DocNm=DocNmToFqH.GetKey(DId);
180        WordStrV.Clr(false);
181      }
182      TStr HtmlFNm=WebRootNrFPath+WordStrToFqH.GetKey(WId);
183      if (TFile::Exists(HtmlFNm)){
184        PSIn HtmlSIn=TFIn::New(HtmlFNm);
185        THtmlLx HtmlLx(HtmlSIn);
186        while (HtmlLx.Sym!=hsyEof){
187          if (HtmlLx.Sym==hsyStr){
188            TStr WordStr=HtmlLx.UcChA;
189            if (!SwSet->IsIn(WordStr)){
190              WordStrV.Add(WordStr);
191            }
192          }
193          HtmlLx.GetSym();
194        }
195      } else {
196        NotFoundDocs++;
197      }
198      PrevDId=DId;
199    }
200    if (!WordStrV.Empty()){
201      if (WordStrV.Len()>=MnFq){
202        BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
203    }
204    BowDocBs->AssertOk();
205    printf("\nDone.\n");
206    return BowDocBs;
207  }
208  PWebLog TWebLog::LoadTxt(const TStr& FNm, const int& MxRecs,
209   const TSsFmt& SsFmt, const bool& HdLnP){
210    printf("Loading web-log '%s' ...\n", FNm.CStr());
211    PWebLog WebLog=TWebLog::New();
212    PSIn SIn=TFIn::New(FNm);
213    int UsrIdFldN=0; int UrlIdFldN=1;
214    if (HdLnP){
215      char Ch=' '; TStrV FldNmV; TSs::LoadTxtFldV(SsFmt, SIn, Ch, FldNmV);
216      UsrIdFldN=FldNmV.SearchForw("UserID");
217      UrlIdFldN=FldNmV.SearchForw("URLID");
218    }
219    TStrV FldValV; int Recs=0;
220    while (!SIn->Eof()){
221      if ((MxRecs!=-1)&&(Recs>MxRecs)){break;}
222      Recs++; if (Recs%100==0){printf("%d\r", Recs);}
223      char Ch=' '; TSs::LoadTxtFldV(SsFmt, SIn, Ch, FldValV);
224      TStr UsrNm=FldValV[UsrIdFldN].GetLc();
225      TStr UrlNm=FldValV[UrlIdFldN].GetLc();
226      int UsrId=WebLog->UsrNmToClicksH.AddKey(UsrNm);
227      int UrlId=WebLog->UrlNmToClicksH.AddKey(UrlNm);
228      WebLog->UsrNmToClicksH[UsrId]++;
229      WebLog->UrlNmToClicksH[UrlId]++;
230      WebLog->UsrIdUrlIdPrV.Add(TIntPr(UsrId, UrlId));
231      WebLog->UrlIdUsrIdPrV.Add(TIntPr(UrlId, UsrId));
232    }
233    WebLog->UsrIdUrlIdPrV.Sort();
234    WebLog->UrlIdUsrIdPrV.Sort();
235    printf("   Users:%d   Urls:%d   Clicks:%d\n",
236     WebLog->GetUsrs(), WebLog->GetUrls(), WebLog->GetClicks());
237    printf("Done.\n");
238    return WebLog;
239  }
240  PWebLog TWebLog::LoadBinOrTxt(
241   const TStr& BinFNm, const TStr& TxtFNm, const int& MxRecs){
242    PWebLog WebLog;
243    if (TFile::Exists(BinFNm)){
244      printf("Loading binary file '%s' ... ", BinFNm.CStr());
245      WebLog=TWebLog::LoadBin(BinFNm);
246      printf("Done.\n");
247    } else {
248      printf("Loading text file '%s' ... ", TxtFNm.CStr());
249      WebLog=LoadTxt(TxtFNm, MxRecs);
250      printf("Done.\n");
251      if (!BinFNm.Empty()){
252        printf("Saving binary file '%s'... ", BinFNm.CStr());
253        WebLog->SaveBin(BinFNm);
254        printf("Done.\n");
255      }
256    }
257    return WebLog;
258  }
259  PWebLog TWebLog::LoadYbTxt(const TStr& FNm, const int& MxRecs){
260    printf("Loading Yield-Broker Web-Log '%s' ...\n", FNm.CStr());
261    PWebLog WebLog=TWebLog::New();
262    PSIn SIn=TFIn::New(FNm);
263    char Ch=' '; TStrV FldNmV; TSs::LoadTxtFldV(ssfCommaSep, SIn, Ch, FldNmV);
264    int UsrIdFldN=FldNmV.SearchForw("UserID");
265    int UrlIdFldN=FldNmV.SearchForw("URLID");
266    TStrV FldValV; int Recs=0;
267    while (!SIn->Eof()){
268      if ((MxRecs!=-1)&&(Recs>MxRecs)){break;}
269      Recs++; if (Recs%100==0){printf("%d\r", Recs);}
270      char Ch=' '; TSs::LoadTxtFldV(ssfCommaSep, SIn, Ch, FldValV);
271      TStr UsrNm=FldValV[UsrIdFldN].GetLc();
272      TStr UrlNm=FldValV[UrlIdFldN].GetLc();
273      int UsrId=WebLog->UsrNmToClicksH.AddKey(UsrNm);
274      int UrlId=WebLog->UrlNmToClicksH.AddKey(UrlNm);
275      WebLog->UsrNmToClicksH[UsrId]++;
276      WebLog->UrlNmToClicksH[UrlId]++;
277      WebLog->UsrIdUrlIdPrV.Add(TIntPr(UsrId, UrlId));
278      WebLog->UrlIdUsrIdPrV.Add(TIntPr(UrlId, UsrId));
279    }
280    WebLog->UsrIdUrlIdPrV.Sort();
281    WebLog->UrlIdUsrIdPrV.Sort();
282    printf("   Users:%d   Urls:%d   Clicks:%d\n",
283     WebLog->GetUsrs(), WebLog->GetUrls(), WebLog->GetClicks());
284    printf("Done.\n");
285    return WebLog;
286  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-peer_container.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wmine.cpp</div>
                </div>
                <div class="column column_space"><pre><code>158  	ASSERT_EQ (4, node->network.fanout ());
159  	ASSERT_EQ (4, node->network.list (node->network.fanout ()).size ());
160  }
161  TEST (peer_container, reachout)
162  {
163  	nano::test::system system;
164  	nano::node_flags node_flags;
165  	auto & node1 = *system.add_node (node_flags);
166  	auto outer_node1 = nano::test::add_outer_node (system);
</pre></code></div>
                <div class="column column_space"><pre><code>121    SOut->PutStr("</UserRank>"); SOut->PutLn();
122    SOut->PutStr("</UrlUserRank>"); SOut->PutLn();
123  }
124  PBowDocBs TWebLog::GetBowDocBs(
125   const TStrIntH& DocNmToFqH, const TIntPrV& DIdWIdPrV,
126   const TStrIntH& WordStrToFqH, const int& MnFq) const {
127    printf("Generating Bag-Of-Words...\n");
128    PBowDocBs BowDocBs=TBowDocBs::New();
129    int DIdWIdPrs=DIdWIdPrV.Len();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    