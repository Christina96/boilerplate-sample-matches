
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 24.00793650793651%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-peer_container.cpp</h3>
            <pre><code>1  #include <nano/node/transport/socket.hpp>
2  #include <nano/node/transport/tcp.hpp>
3  #include <nano/node/transport/tcp_server.hpp>
4  #include <nano/test_common/network.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/testutil.hpp>
7  #include <gtest/gtest.h>
8  #include <memory>
9  using namespace std::chrono_literals;
10  TEST (peer_container, empty_peers)
11  {
12  	nano::test::system system (1);
13  	nano::network & network (system.nodes[0]->network);
14  	system.nodes[0]->network.cleanup (std::chrono::steady_clock::now ());
15  	ASSERT_EQ (0, network.size ());
16  }
17  TEST (peer_container, no_self_incoming)
18  {
19  	nano::test::system system{ 1 };
20  	auto & node = *system.nodes[0];
21  	node.network.tcp_channels.start_tcp (node.network.endpoint ());
22  	auto error = system.poll_until_true (2s, [&node] {
23  		auto result = node.network.tcp_channels.find_channel (nano::transport::map_endpoint_to_tcp (node.network.endpoint ()));
24  		return result != nullptr;
25  	});
26  	ASSERT_TRUE (error);
27  	ASSERT_TRUE (system.nodes[0]->network.empty ());
28  }
29  TEST (peer_container, reserved_ip_is_not_a_peer)
30  {
31  	nano::test::system system{ 1 };
32  	auto not_a_peer = [&node = system.nodes[0]] (nano::endpoint endpoint_a) -> bool {
33  		return node->network.not_a_peer (endpoint_a, true);
34  	};
35  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0x00000001)), 10000))));
36  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xc0000201)), 10000))));
37  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xc6336401)), 10000))));
<span onclick='openModal()' class='match'>38  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xcb007101)), 10000))));
39  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xe9fc0001)), 10000))));
40  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xf0000001)), 10000))));
</span>41  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xffffffff)), 10000))));
42  	ASSERT_FALSE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0x08080808)), 10000))));
43  }
44  TEST (peer_container, tcp_channel_cleanup_works)
45  {
46  	nano::test::system system;
47  	nano::node_config node_config = system.default_config ();
48  	node_config.network_params.network.keepalive_period = std::chrono::minutes (10);
49  	nano::node_flags node_flags;
50  	node_flags.disable_connection_cleanup = true;
51  	node_flags.disable_rep_crawler = true;
52  	auto & node1 = *system.add_node (node_config, node_flags);
53  	auto outer_node1 = nano::test::add_outer_node (system, node_flags);
54  	outer_node1->config.network_params.network.keepalive_period = std::chrono::minutes (10);
55  	auto outer_node2 = nano::test::add_outer_node (system, node_flags);
56  	outer_node2->config.network_params.network.keepalive_period = std::chrono::minutes (10);
57  	auto now = std::chrono::steady_clock::now ();
58  	auto channel1 = nano::test::establish_tcp (system, node1, outer_node1->network.endpoint ());
59  	ASSERT_NE (nullptr, channel1);
60  	node1.network.tcp_channels.modify (channel1, [&now] (auto channel) {
61  		channel->set_last_packet_sent (now - std::chrono::seconds (5));
62  	});
63  	auto channel2 = nano::test::establish_tcp (system, node1, outer_node2->network.endpoint ());
64  	ASSERT_NE (nullptr, channel2);
65  	node1.network.tcp_channels.modify (channel2, [&now] (auto channel) {
66  		channel->set_last_packet_sent (now + std::chrono::seconds (1));
67  	});
68  	ASSERT_EQ (2, node1.network.size ());
69  	ASSERT_EQ (2, node1.network.tcp_channels.size ());
70  	for (auto it = 0; node1.network.tcp_channels.size () > 1 && it < 10; ++it)
71  	{
72  		auto const channel1_last_packet_sent = channel1->get_last_packet_sent ();
73  		auto const channel2_last_packet_sent = channel2->get_last_packet_sent ();
74  		auto const max_last_packet_sent = std::max (channel1_last_packet_sent, channel2_last_packet_sent);
75  		auto const min_last_packet_sent = std::min (channel1_last_packet_sent, channel2_last_packet_sent);
76  		auto const cleanup_point = ((max_last_packet_sent - min_last_packet_sent) / 2) + min_last_packet_sent;
77  		node1.network.cleanup (cleanup_point);
78  		if (node1.network.tcp_channels.size () == 2)
79  		{
80  			WAIT (500ms);
81  		}
82  	}
83  	ASSERT_EQ (1, node1.network.size ());
84  	ASSERT_EQ (1, node1.network.tcp_channels.size ());
85  }
86  TEST (channels, fill_random_clear)
87  {
88  	nano::test::system system (1);
89  	std::array<nano::endpoint, 8> target;
90  	std::fill (target.begin (), target.end (), nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000));
91  	system.nodes[0]->network.random_fill (target);
92  	ASSERT_TRUE (std::all_of (target.begin (), target.end (), [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::any (), 0); }));
93  }
94  TEST (channels, fill_random_full)
95  {
96  	nano::test::system system{ 1 };
97  	for (int i = 0; i < 8; ++i)
98  	{
99  		auto outer_node = nano::test::add_outer_node (system);
100  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
101  	}
102  	ASSERT_TIMELY_EQ (5s, 8, system.nodes[0]->network.tcp_channels.size ());
103  	auto filler_endpoint = nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000);
104  	std::array<nano::endpoint, 8> target;
105  	std::fill (target.begin (), target.end (), filler_endpoint);
106  	system.nodes[0]->network.random_fill (target);
107  	auto is_filler = [&filler_endpoint] (nano::endpoint const & endpoint_a) {
108  		return endpoint_a == filler_endpoint;
109  	};
110  	ASSERT_TRUE (std::none_of (target.begin (), target.end (), is_filler));
111  }
112  TEST (channels, fill_random_part)
113  {
114  	nano::test::system system{ 1 };
115  	std::array<nano::endpoint, 8> target;
116  	std::size_t half = target.size () / 2;
117  	for (std::size_t i = 0; i < half; ++i)
118  	{
119  		auto outer_node = nano::test::add_outer_node (system);
120  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ()));
121  	}
122  	ASSERT_EQ (half, system.nodes[0]->network.tcp_channels.size ());
123  	std::fill (target.begin (), target.end (), nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000));
124  	system.nodes[0]->network.random_fill (target);
125  	ASSERT_TRUE (std::none_of (target.begin (), target.begin () + half, [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000); }));
126  	ASSERT_TRUE (std::none_of (target.begin (), target.begin () + half, [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::loopback (), 0); }));
127  	ASSERT_TRUE (std::all_of (target.begin () + half, target.end (), [] (nano::endpoint const & endpoint_a) { return endpoint_a == nano::endpoint (boost::asio::ip::address_v6::any (), 0); }));
128  }
129  TEST (peer_container, list_fanout)
130  {
131  	nano::test::system system{ 1 };
132  	auto node = system.nodes[0];
133  	ASSERT_EQ (0, node->network.size ());
134  	ASSERT_EQ (0.0, node->network.size_sqrt ());
135  	ASSERT_EQ (0, node->network.fanout ());
136  	ASSERT_TRUE (node->network.list (node->network.fanout ()).empty ());
137  	auto add_peer = [&node, &system] () {
138  		auto outer_node = nano::test::add_outer_node (system);
139  		auto channel = nano::test::establish_tcp (system, *node, outer_node->network.endpoint ());
140  	};
141  	add_peer ();
142  	ASSERT_TIMELY_EQ (5s, 1, node->network.size ());
143  	ASSERT_EQ (1.f, node->network.size_sqrt ());
144  	ASSERT_EQ (1, node->network.fanout ());
145  	ASSERT_EQ (1, node->network.list (node->network.fanout ()).size ());
146  	add_peer ();
147  	ASSERT_TIMELY_EQ (5s, 2, node->network.size ());
148  	ASSERT_EQ (std::sqrt (2.f), node->network.size_sqrt ());
149  	ASSERT_EQ (2, node->network.fanout ());
150  	ASSERT_EQ (2, node->network.list (node->network.fanout ()).size ());
151  	unsigned number_of_peers = 10;
152  	for (unsigned i = 2; i < number_of_peers; ++i)
153  	{
154  		add_peer ();
155  	}
156  	ASSERT_TIMELY_EQ (5s, number_of_peers, node->network.size ());
157  	ASSERT_EQ (std::sqrt (float (number_of_peers)), node->network.size_sqrt ());
158  	ASSERT_EQ (4, node->network.fanout ());
159  	ASSERT_EQ (4, node->network.list (node->network.fanout ()).size ());
160  }
161  TEST (peer_container, reachout)
162  {
163  	nano::test::system system;
164  	nano::node_flags node_flags;
165  	auto & node1 = *system.add_node (node_flags);
166  	auto outer_node1 = nano::test::add_outer_node (system);
167  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, node1, outer_node1->network.endpoint ()));
168  	ASSERT_TRUE (node1.network.reachout (outer_node1->network.endpoint ()));
169  	auto outer_node2 = nano::test::add_outer_node (system);
170  	ASSERT_FALSE (node1.network.reachout (outer_node2->network.endpoint ()));
171  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, node1, outer_node2->network.endpoint ()));
172  	ASSERT_TRUE (node1.network.reachout (outer_node2->network.endpoint ()));
173  	node1.network.cleanup (std::chrono::steady_clock::now () - std::chrono::seconds (10));
174  	ASSERT_TRUE (node1.network.reachout (outer_node2->network.endpoint ()));
175  	node1.network.cleanup (std::chrono::steady_clock::now () + std::chrono::seconds (10));
176  	ASSERT_FALSE (node1.network.reachout (outer_node2->network.endpoint ()));
177  }
178  TEST (peer_container, depeer_on_outdated_version)
179  {
180  	nano::test::system system{ 2 };
181  	auto & node1 = *system.nodes[0];
182  	auto & node2 = *system.nodes[1];
183  	auto channel = node2.network.find_node_id (node1.get_node_id ());
184  	ASSERT_NE (nullptr, channel);
185  	nano::keepalive keepalive{ nano::dev::network_params.network };
186  	const_cast<uint8_t &> (keepalive.header.version_using) = nano::dev::network_params.network.protocol_version_min - 1;
187  	ASSERT_TIMELY (5s, channel->alive ());
188  	channel->send (keepalive);
189  	ASSERT_TIMELY (5s, !channel->alive ());
190  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_io.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/core/core.hpp>
3  #include <opencv2/highgui/highgui.hpp>
4  #include <opencv2/highgui/highgui_c.h>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #include <string>
7  #include "gtest/gtest.h"
8  #include "caffe/common.hpp"
9  #include "caffe/util/io.hpp"
10  #include "caffe/test/test_caffe_main.hpp"
11  namespace caffe {
12  class IOTest : public ::testing::Test {};
13  bool ReadImageToDatumReference(const string& filename, const int label,
14      const int height, const int width, const bool is_color, Datum* datum) {
15    cv::Mat cv_img;
16    int cv_read_flag = (is_color ? CV_LOAD_IMAGE_COLOR :
17      CV_LOAD_IMAGE_GRAYSCALE);
18    cv::Mat cv_img_origin = cv::imread(filename, cv_read_flag);
19    if (!cv_img_origin.data) {
20      LOG(ERROR) << "Could not open or find file " << filename;
21      return false;
22    }
23    if (height > 0 && width > 0) {
24      cv::resize(cv_img_origin, cv_img, cv::Size(width, height));
25    } else {
26      cv_img = cv_img_origin;
27    }
28    int num_channels = (is_color ? 3 : 1);
29    datum->set_channels(num_channels);
30    datum->set_height(cv_img.rows);
31    datum->set_width(cv_img.cols);
32    datum->set_label(label);
33    datum->clear_data();
34    datum->clear_float_data();
35    string* datum_string = datum->mutable_data();
36    if (is_color) {
37      for (int c = 0; c < num_channels; ++c) {
38        for (int h = 0; h < cv_img.rows; ++h) {
39          for (int w = 0; w < cv_img.cols; ++w) {
40            datum_string->push_back(
41              static_cast<char>(cv_img.at<cv::Vec3b>(h, w)[c]));
42          }
43        }
44      }
45    } else {  
46      for (int h = 0; h < cv_img.rows; ++h) {
47        for (int w = 0; w < cv_img.cols; ++w) {
48          datum_string->push_back(
49            static_cast<char>(cv_img.at<uchar>(h, w)));
50          }
51        }
52    }
53    return true;
54  }
55  TEST_F(IOTest, TestReadImageToDatum) {
56    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
57    Datum datum;
58    ReadImageToDatum(filename, 0, &datum);
59    EXPECT_EQ(datum.channels(), 3);
60    EXPECT_EQ(datum.height(), 360);
61    EXPECT_EQ(datum.width(), 480);
62  }
63  TEST_F(IOTest, TestReadImageToDatumReference) {
64    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
65    Datum datum, datum_ref;
66    ReadImageToDatum(filename, 0, 0, 0, true, &datum);
67    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
68    EXPECT_EQ(datum.channels(), datum_ref.channels());
69    EXPECT_EQ(datum.height(), datum_ref.height());
70    EXPECT_EQ(datum.width(), datum_ref.width());
71    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
72    const string& data = datum.data();
73    const string& data_ref = datum.data();
74    for (int i = 0; i < datum.data().size(); ++i) {
75      EXPECT_TRUE(data[i] == data_ref[i]);
76    }
77  }
78  TEST_F(IOTest, TestReadImageToDatumReferenceResized) {
79    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
80    Datum datum, datum_ref;
81    ReadImageToDatum(filename, 0, 100, 200, true, &datum);
82    ReadImageToDatumReference(filename, 0, 100, 200, true, &datum_ref);
83    EXPECT_EQ(datum.channels(), datum_ref.channels());
84    EXPECT_EQ(datum.height(), datum_ref.height());
85    EXPECT_EQ(datum.width(), datum_ref.width());
86    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
87    const string& data = datum.data();
88    const string& data_ref = datum.data();
89    for (int i = 0; i < datum.data().size(); ++i) {
90      EXPECT_TRUE(data[i] == data_ref[i]);
91    }
92  }
93  TEST_F(IOTest, TestReadImageToDatumContent) {
94    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
95    Datum datum;
96    ReadImageToDatum(filename, 0, &datum);
97    cv::Mat cv_img = ReadImageToCVMat(filename);
98    EXPECT_EQ(datum.channels(), cv_img.channels());
99    EXPECT_EQ(datum.height(), cv_img.rows);
100    EXPECT_EQ(datum.width(), cv_img.cols);
101    const string& data = datum.data();
102    int index = 0;
103    for (int c = 0; c < datum.channels(); ++c) {
104      for (int h = 0; h < datum.height(); ++h) {
105        for (int w = 0; w < datum.width(); ++w) {
106          EXPECT_TRUE(data[index++] ==
107            static_cast<char>(cv_img.at<cv::Vec3b>(h, w)[c]));
108        }
109      }
110    }
111  }
112  TEST_F(IOTest, TestReadImageToDatumContentGray) {
113    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
114    Datum datum;
115    const bool is_color = false;
116    ReadImageToDatum(filename, 0, is_color, &datum);
117    cv::Mat cv_img = ReadImageToCVMat(filename, is_color);
118    EXPECT_EQ(datum.channels(), cv_img.channels());
119    EXPECT_EQ(datum.height(), cv_img.rows);
120    EXPECT_EQ(datum.width(), cv_img.cols);
121    const string& data = datum.data();
122    int index = 0;
123    for (int h = 0; h < datum.height(); ++h) {
124      for (int w = 0; w < datum.width(); ++w) {
125        EXPECT_TRUE(data[index++] == static_cast<char>(cv_img.at<uchar>(h, w)));
126      }
127    }
128  }
129  TEST_F(IOTest, TestReadImageToDatumResized) {
130    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
131    Datum datum;
132    ReadImageToDatum(filename, 0, 100, 200, &datum);
133    EXPECT_EQ(datum.channels(), 3);
134    EXPECT_EQ(datum.height(), 100);
135    EXPECT_EQ(datum.width(), 200);
136  }
137  TEST_F(IOTest, TestReadImageToDatumResizedSquare) {
138    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
139    Datum datum;
140    ReadImageToDatum(filename, 0, 256, 256, &datum);
141    EXPECT_EQ(datum.channels(), 3);
142    EXPECT_EQ(datum.height(), 256);
143    EXPECT_EQ(datum.width(), 256);
144  }
145  TEST_F(IOTest, TestReadImageToDatumGray) {
146    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
147    Datum datum;
148    const bool is_color = false;
149    ReadImageToDatum(filename, 0, is_color, &datum);
150    EXPECT_EQ(datum.channels(), 1);
151    EXPECT_EQ(datum.height(), 360);
152    EXPECT_EQ(datum.width(), 480);
153  }
154  TEST_F(IOTest, TestReadImageToDatumResizedGray) {
155    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
156    Datum datum;
157    const bool is_color = false;
158    ReadImageToDatum(filename, 0, 256, 256, is_color, &datum);
159    EXPECT_EQ(datum.channels(), 1);
160    EXPECT_EQ(datum.height(), 256);
161    EXPECT_EQ(datum.width(), 256);
162  }
163  TEST_F(IOTest, TestReadImageToCVMat) {
164    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
165    cv::Mat cv_img = ReadImageToCVMat(filename);
166    EXPECT_EQ(cv_img.channels(), 3);
167    EXPECT_EQ(cv_img.rows, 360);
168    EXPECT_EQ(cv_img.cols, 480);
169  }
170  TEST_F(IOTest, TestReadImageToCVMatResized) {
171    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
172    cv::Mat cv_img = ReadImageToCVMat(filename, 100, 200);
173    EXPECT_EQ(cv_img.channels(), 3);
174    EXPECT_EQ(cv_img.rows, 100);
175    EXPECT_EQ(cv_img.cols, 200);
176  }
177  TEST_F(IOTest, TestReadImageToCVMatResizedSquare) {
178    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
179    cv::Mat cv_img = ReadImageToCVMat(filename, 256, 256);
180    EXPECT_EQ(cv_img.channels(), 3);
181    EXPECT_EQ(cv_img.rows, 256);
182    EXPECT_EQ(cv_img.cols, 256);
183  }
184  TEST_F(IOTest, TestReadImageToCVMatGray) {
185    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
186    const bool is_color = false;
187    cv::Mat cv_img = ReadImageToCVMat(filename, is_color);
188    EXPECT_EQ(cv_img.channels(), 1);
189    EXPECT_EQ(cv_img.rows, 360);
190    EXPECT_EQ(cv_img.cols, 480);
191  }
192  TEST_F(IOTest, TestReadImageToCVMatResizedGray) {
193    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
194    const bool is_color = false;
195    cv::Mat cv_img = ReadImageToCVMat(filename, 256, 256, is_color);
196    EXPECT_EQ(cv_img.channels(), 1);
197    EXPECT_EQ(cv_img.rows, 256);
198    EXPECT_EQ(cv_img.cols, 256);
199  }
200  TEST_F(IOTest, TestCVMatToDatum) {
201    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
202    cv::Mat cv_img = ReadImageToCVMat(filename);
203    Datum datum;
204    CVMatToDatum(cv_img, &datum);
205    EXPECT_EQ(datum.channels(), 3);
206    EXPECT_EQ(datum.height(), 360);
207    EXPECT_EQ(datum.width(), 480);
208  }
209  TEST_F(IOTest, TestCVMatToDatumContent) {
210    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
211    cv::Mat cv_img = ReadImageToCVMat(filename);
212    Datum datum;
213    CVMatToDatum(cv_img, &datum);
214    Datum datum_ref;
215    ReadImageToDatum(filename, 0, &datum_ref);
216    EXPECT_EQ(datum.channels(), datum_ref.channels());
217    EXPECT_EQ(datum.height(), datum_ref.height());
218    EXPECT_EQ(datum.width(), datum_ref.width());
219    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
220    const string& data = datum.data();
221    const string& data_ref = datum_ref.data();
222    for (int i = 0; i < datum.data().size(); ++i) {
223      EXPECT_TRUE(data[i] == data_ref[i]);
224    }
225  }
226  TEST_F(IOTest, TestCVMatToDatumReference) {
227    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
228    cv::Mat cv_img = ReadImageToCVMat(filename);
229    Datum datum;
230    CVMatToDatum(cv_img, &datum);
231    Datum datum_ref;
232    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
<span onclick='openModal()' class='match'>233    EXPECT_EQ(datum.channels(), datum_ref.channels());
234    EXPECT_EQ(datum.height(), datum_ref.height());
235    EXPECT_EQ(datum.width(), datum_ref.width());
236    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
</span>237    const string& data = datum.data();
238    const string& data_ref = datum_ref.data();
239    for (int i = 0; i < datum.data().size(); ++i) {
240      EXPECT_TRUE(data[i] == data_ref[i]);
241    }
242  }
243  TEST_F(IOTest, TestReadFileToDatum) {
244    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
245    Datum datum;
246    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
247    EXPECT_TRUE(datum.encoded());
248    EXPECT_EQ(datum.label(), -1);
249    EXPECT_EQ(datum.data().size(), 140391);
250  }
251  TEST_F(IOTest, TestDecodeDatum) {
252    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
253    Datum datum;
254    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
255    EXPECT_TRUE(DecodeDatum(&datum, true));
256    EXPECT_FALSE(DecodeDatum(&datum, true));
257    Datum datum_ref;
258    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
259    EXPECT_EQ(datum.channels(), datum_ref.channels());
260    EXPECT_EQ(datum.height(), datum_ref.height());
261    EXPECT_EQ(datum.width(), datum_ref.width());
262    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
263    const string& data = datum.data();
264    const string& data_ref = datum_ref.data();
265    for (int i = 0; i < datum.data().size(); ++i) {
266      EXPECT_TRUE(data[i] == data_ref[i]);
267    }
268  }
269  TEST_F(IOTest, TestDecodeDatumToCVMat) {
270    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
271    Datum datum;
272    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
273    cv::Mat cv_img = DecodeDatumToCVMat(datum, true);
274    EXPECT_EQ(cv_img.channels(), 3);
275    EXPECT_EQ(cv_img.rows, 360);
276    EXPECT_EQ(cv_img.cols, 480);
277    cv_img = DecodeDatumToCVMat(datum, false);
278    EXPECT_EQ(cv_img.channels(), 1);
279    EXPECT_EQ(cv_img.rows, 360);
280    EXPECT_EQ(cv_img.cols, 480);
281  }
282  TEST_F(IOTest, TestDecodeDatumToCVMatContent) {
283    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
284    Datum datum;
285    EXPECT_TRUE(ReadImageToDatum(filename, 0, std::string("jpg"), &datum));
286    cv::Mat cv_img = DecodeDatumToCVMat(datum, true);
287    cv::Mat cv_img_ref = ReadImageToCVMat(filename);
288    EXPECT_EQ(cv_img_ref.channels(), cv_img.channels());
289    EXPECT_EQ(cv_img_ref.rows, cv_img.rows);
290    EXPECT_EQ(cv_img_ref.cols, cv_img.cols);
291    for (int c = 0; c < datum.channels(); ++c) {
292      for (int h = 0; h < datum.height(); ++h) {
293        for (int w = 0; w < datum.width(); ++w) {
294          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
295            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
296        }
297      }
298    }
299  }
300  TEST_F(IOTest, TestDecodeDatumNative) {
301    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
302    Datum datum;
303    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
304    EXPECT_TRUE(DecodeDatumNative(&datum));
305    EXPECT_FALSE(DecodeDatumNative(&datum));
306    Datum datum_ref;
307    ReadImageToDatumReference(filename, 0, 0, 0, true, &datum_ref);
308    EXPECT_EQ(datum.channels(), datum_ref.channels());
309    EXPECT_EQ(datum.height(), datum_ref.height());
310    EXPECT_EQ(datum.width(), datum_ref.width());
311    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
312    const string& data = datum.data();
313    const string& data_ref = datum_ref.data();
314    for (int i = 0; i < datum.data().size(); ++i) {
315      EXPECT_TRUE(data[i] == data_ref[i]);
316    }
317  }
318  TEST_F(IOTest, TestDecodeDatumToCVMatNative) {
319    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
320    Datum datum;
321    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
322    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
323    EXPECT_EQ(cv_img.channels(), 3);
324    EXPECT_EQ(cv_img.rows, 360);
325    EXPECT_EQ(cv_img.cols, 480);
326  }
327  TEST_F(IOTest, TestDecodeDatumNativeGray) {
328    string filename = EXAMPLES_SOURCE_DIR "images/cat_gray.jpg";
329    Datum datum;
330    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
331    EXPECT_TRUE(DecodeDatumNative(&datum));
332    EXPECT_FALSE(DecodeDatumNative(&datum));
333    Datum datum_ref;
334    ReadImageToDatumReference(filename, 0, 0, 0, false, &datum_ref);
335    EXPECT_EQ(datum.channels(), datum_ref.channels());
336    EXPECT_EQ(datum.height(), datum_ref.height());
337    EXPECT_EQ(datum.width(), datum_ref.width());
338    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
339    const string& data = datum.data();
340    const string& data_ref = datum_ref.data();
341    for (int i = 0; i < datum.data().size(); ++i) {
342      EXPECT_TRUE(data[i] == data_ref[i]);
343    }
344  }
345  TEST_F(IOTest, TestDecodeDatumToCVMatNativeGray) {
346    string filename = EXAMPLES_SOURCE_DIR "images/cat_gray.jpg";
347    Datum datum;
348    EXPECT_TRUE(ReadFileToDatum(filename, &datum));
349    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
350    EXPECT_EQ(cv_img.channels(), 1);
351    EXPECT_EQ(cv_img.rows, 360);
352    EXPECT_EQ(cv_img.cols, 480);
353  }
354  TEST_F(IOTest, TestDecodeDatumToCVMatContentNative) {
355    string filename = EXAMPLES_SOURCE_DIR "images/cat.jpg";
356    Datum datum;
357    EXPECT_TRUE(ReadImageToDatum(filename, 0, std::string("jpg"), &datum));
358    cv::Mat cv_img = DecodeDatumToCVMatNative(datum);
359    cv::Mat cv_img_ref = ReadImageToCVMat(filename);
360    EXPECT_EQ(cv_img_ref.channels(), cv_img.channels());
361    EXPECT_EQ(cv_img_ref.rows, cv_img.rows);
362    EXPECT_EQ(cv_img_ref.cols, cv_img.cols);
363    for (int c = 0; c < datum.channels(); ++c) {
364      for (int h = 0; h < datum.height(); ++h) {
365        for (int w = 0; w < datum.width(); ++w) {
366          EXPECT_TRUE(cv_img.at<cv::Vec3b>(h, w)[c]==
367            cv_img_ref.at<cv::Vec3b>(h, w)[c]);
368        }
369      }
370    }
371  }
372  }  
373  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-peer_container.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_io.cpp</div>
                </div>
                <div class="column column_space"><pre><code>38  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xcb007101)), 10000))));
39  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xe9fc0001)), 10000))));
40  	ASSERT_TRUE (not_a_peer (nano::transport::map_endpoint_to_v6 (nano::endpoint (boost::asio::ip::address (boost::asio::ip::address_v4 (0xf0000001)), 10000))));
</pre></code></div>
                <div class="column column_space"><pre><code>233    EXPECT_EQ(datum.channels(), datum_ref.channels());
234    EXPECT_EQ(datum.height(), datum_ref.height());
235    EXPECT_EQ(datum.width(), datum_ref.width());
236    EXPECT_EQ(datum.data().size(), datum_ref.data().size());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    