
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.486017357762778%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_engine_selection.cpp</h3>
            <pre><code>1  #include <string>
2  #include <vector>
3  #include "google/protobuf/text_format.h"
4  #include "gtest/gtest.h"
5  #include "caffe/blob.hpp"
6  #include "caffe/common.hpp"
7  #include "caffe/engine_parser.hpp"
8  #include "caffe/filler.hpp"
9  #include "caffe/layer.hpp"
10  #include "caffe/layer_factory.hpp"
11  #include "caffe/layers/batch_norm_layer.hpp"
12  #include "caffe/layers/concat_layer.hpp"
13  #include "caffe/layers/conv_layer.hpp"
14  #include "caffe/layers/inner_product_layer.hpp"
15  #include "caffe/layers/lrn_layer.hpp"
16  #include "caffe/layers/pooling_layer.hpp"
17  #include "caffe/layers/relu_layer.hpp"
18  #include "caffe/layers/sigmoid_layer.hpp"
19  #include "caffe/layers/softmax_layer.hpp"
20  #include "caffe/layers/tanh_layer.hpp"
21  #ifdef MKL2017_SUPPORTED
22  #include "caffe/layers/mkl_layers.hpp"
23  #endif
24  #ifdef MKLDNN_SUPPORTED
25  #include "caffe/layers/mkldnn_layers.hpp"
26  #endif
27  #include "caffe/test/test_caffe_main.hpp"
28  #include "caffe/test/test_gradient_check_util.hpp"
29  namespace caffe {
30  template <typename TypeParam>
31  class TestEngineSelection : public MultiDeviceTest<TypeParam> {
32    typedef typename TypeParam::Dtype Dtype;
33   protected:
34    TestEngineSelection() {}
35    virtual ~TestEngineSelection() {}
36    virtual void InitNetFromProtoString(const string& proto) {
37      NetParameter param;
38      CHECK(google::protobuf::TextFormat::ParseFromString(proto, &param));
39      net_.reset(new Net<Dtype>(param));
40    }
41    virtual void InitNet(const string& net_engine) {
42      string proto =
43          "engine: '" + net_engine + "' "
44          "layer { "
45          "  name: 'data' "
46          "  type: 'Input' "
47          "  top: 'data' "
48          "  input_param { "
49          "  shape: { dim: 1 dim: 3 dim: 100 dim: 100 } "
50          "  } "
51          "} "
52          "layer { "
53          "  name: 'conv1' "
54          "  type: 'Convolution' "
55          "  bottom: 'data' "
56          "  top: 'conv1' "
57          "  convolution_param { "
58          "    num_output: 5 "
59          "    kernel_size: 3 "
60          "    stride: 2 "
61          "  } "
62          "} "
63          "layer { "
64          "  name: 'relu1' "
65          "  type: 'ReLU' "
66          "  bottom: 'conv1' "
67          "  top: 'conv1' "
68          "} "
69          "layer { "
70          "  name: 'pool1' "
71          "  type: 'Pooling' "
72          "  bottom: 'conv1' "
73          "  top: 'pool1' "
74          "  pooling_param { "
75          "    pool: MAX "
76          "    kernel_size: 2 "
77          "    stride: 2 "
78          "  } "
79          "} "
80          "layer { "
81          "  name: 'norm1' "
82          "  type: 'LRN' "
83          "  bottom: 'pool1' "
84          "  top: 'norm1' "
85          "  lrn_param { "
86          "    local_size: 3 "
87          "  } "
88          "} "
89          "layer { "
90          "  name: 'ip1' "
91          "  type: 'InnerProduct' "
92          "  inner_product_param { "
93          "    num_output: 1 "
94          "  } "
95          "  bottom: 'norm1' "
96          "  top: 'ip1' "
97          "} "
98          "layer { "
99          "  name: 'relu2' "
100          "  type: 'ReLU' "
101          "  bottom: 'ip1' "
102          "  top: 'ip1' "
103          "} "
104          " layer {"
105          "   bottom: 'ip1'"
106          "   top: 'bn1'"
107          "   name: 'bn1'"
108          "   type: 'BatchNorm'"
109          " }"
110          " layer {"
111          "   bottom: 'pool1'"
112          "   bottom: 'norm1'"
113          "   top: 'concat1'"
114          "   name: 'concat1'"
115          "   type: 'Concat'"
116          " } "
117          " layer { "
118          "   bottom: 'concat1' "
119          "   bottom: 'concat1' "
120          "   top: 'eltw1' "
121          "   name: 'eltw1' "
122          "   type: 'Eltwise' "
123          "}"
124          " layer { "
125          "   bottom: 'eltw1' "
126          "   top: 'split1' "
127          "   name: 'split1' "
128          "   type: 'Split' "
129          "}";
130      InitNetFromProtoString(proto);
131    }
132      shared_ptr<Net<Dtype> > net_;
133  };
134  TYPED_TEST_CASE(TestEngineSelection, TestDtypesAndDevices);
135  TYPED_TEST(TestEngineSelection, TestEngineParser) {
136    EngineParser ep1("CAFFE");
137    EXPECT_TRUE(ep1.isEngine("CAFFE"));
138    EXPECT_FALSE(ep1.isEngine("MKLDNN"));
139    EXPECT_FALSE(ep1.isEngine("MKL2017"));
140    EXPECT_FALSE(ep1.isEngine("CUDNN"));
141  #ifdef MKL2017_SUPPORTED
142    EngineParser ep2("MKL2017");
143    EXPECT_FALSE(ep2.isEngine("CAFFE"));
144    EXPECT_FALSE(ep2.isEngine("MKLDNN"));
145    EXPECT_TRUE(ep2.isEngine("MKL2017"));
146    EXPECT_FALSE(ep2.isEngine("CUDNN"));
147  #endif
148  #ifdef MKLDNN_SUPPORTED
149    EngineParser ep3("MKLDNN:CPU,FPGA,DLA");
<span onclick='openModal()' class='match'>150    EXPECT_FALSE(ep3.isEngine("CAFFE"));
151    EXPECT_TRUE(ep3.isEngine("MKLDNN"));
152    EXPECT_FALSE(ep3.isEngine("MKL2017"));
153    EXPECT_FALSE(ep3.isEngine("CUDNN"));
154    EXPECT_EQ(3, ep3.getNumberOfSubEngines());
155    EXPECT_EQ(&ep3.getMKLDNNSubEngine(0), &CpuEngine::Instance().get_engine());
156  #ifdef FPGA_ENABLED
157    EXPECT_EQ(&ep3.getMKLDNNSubEngine(1), &FPGAEngine::Instance().get_engine());
</span>158  #endif
159  #ifdef DLA_ENABLED
160    EXPECT_EQ(&ep3.getMKLDNNSubEngine(2), &DLAEngine::Instance().get_engine());
161  #endif
162    EngineParser ep4("MKLDNN:FPGA,CPU,FPGA");
163    EXPECT_FALSE(ep4.isEngine("CAFFE"));
164    EXPECT_TRUE(ep4.isEngine("MKLDNN"));
165    EXPECT_FALSE(ep4.isEngine("MKL2017"));
166    EXPECT_FALSE(ep4.isEngine("CUDNN"));
167    EXPECT_EQ(3, ep4.getNumberOfSubEngines());
168    EXPECT_EQ(&ep4.getMKLDNNSubEngine(1), &CpuEngine::Instance().get_engine());
169  #ifdef FPGA_ENABLED
170    EXPECT_EQ(&ep4.getMKLDNNSubEngine(0), &FPGAEngine::Instance().get_engine());
171    EXPECT_EQ(&ep4.getMKLDNNSubEngine(2), &FPGAEngine::Instance().get_engine());
172  #endif
173  #endif  
174  #ifdef USE_CUDNN
175    EngineParser ep5("CUDNN");
176    EXPECT_FALSE(ep5.isEngine("CAFFE"));
177    EXPECT_FALSE(ep5.isEngine("MKLDNN"));
178    EXPECT_FALSE(ep5.isEngine("MKL2017"));
179    EXPECT_TRUE(ep5.isEngine("CUDNN"));
180  #endif
181  }
182  TYPED_TEST(TestEngineSelection, TestEngineParserNetCAFFE) {
183    typedef typename TypeParam::Dtype Dtype;
184    void* null_ptr = NULL;
185    this->InitNet("CAFFE");
186    Net<Dtype>* net = this->net_.get();
187    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
188    ConvolutionLayer<Dtype>* conv1_caffe =
189            dynamic_cast<ConvolutionLayer<Dtype>* >(conv1_layer);
190    EXPECT_NE(null_ptr, conv1_caffe);
191  #ifdef MKL2017_SUPPORTED
192    MKLConvolutionLayer<Dtype>* conv1_mkl =
193            dynamic_cast<MKLConvolutionLayer<Dtype>* >(conv1_layer);
194    EXPECT_EQ(null_ptr, conv1_mkl);
195  #endif
196  #ifdef MKLDNN_SUPPORTED
197    MKLDNNConvolutionLayer<Dtype>* conv1_mkldnn =
198            dynamic_cast<MKLDNNConvolutionLayer<Dtype>* >(conv1_layer);
199    EXPECT_EQ(null_ptr, conv1_mkldnn);
200  #endif
201    Layer<Dtype>* relu1_layer = net->layer_by_name("relu1").get();
202    ReLULayer<Dtype>* relu1_caffe =
203            dynamic_cast<ReLULayer<Dtype>* >(relu1_layer);
204    EXPECT_NE(null_ptr, relu1_caffe);
205    Layer<Dtype>* relu2_layer = net->layer_by_name("relu2").get();
206    ReLULayer<Dtype>* relu2_caffe =
207            dynamic_cast<ReLULayer<Dtype>* >(relu2_layer);
208    EXPECT_NE(null_ptr, relu2_caffe);
209    Layer<Dtype>* pool1_layer = net->layer_by_name("pool1").get();
210    PoolingLayer<Dtype>* pool1_caffe =
211            dynamic_cast<PoolingLayer<Dtype>* >(pool1_layer);
212    EXPECT_NE(null_ptr, pool1_caffe);
213    Layer<Dtype>* norm1_layer = net->layer_by_name("norm1").get();
214    LRNLayer<Dtype>* norm1_caffe =
215            dynamic_cast<LRNLayer<Dtype>* >(norm1_layer);
216    EXPECT_NE(null_ptr, norm1_caffe);
217    Layer<Dtype>* ip1_layer = net->layer_by_name("ip1").get();
218    InnerProductLayer<Dtype>* ip1_caffe =
219            dynamic_cast<InnerProductLayer<Dtype>* >(ip1_layer);
220    EXPECT_NE(null_ptr, ip1_caffe);
221    Layer<Dtype>* bn1_layer = net->layer_by_name("bn1").get();
222    BatchNormLayer<Dtype>* bn1_caffe =
223            dynamic_cast<BatchNormLayer<Dtype>* >(bn1_layer);
224    EXPECT_NE(null_ptr, bn1_caffe);
225    Layer<Dtype>* concat1_layer = net->layer_by_name("concat1").get();
226    ConcatLayer<Dtype>* concat1_caffe =
227            dynamic_cast<ConcatLayer<Dtype>* >(concat1_layer);
228    EXPECT_NE(null_ptr, concat1_caffe);
229    Layer<Dtype>* eltw1_layer = net->layer_by_name("eltw1").get();
230    EltwiseLayer<Dtype>* eltw1_caffe =
231            dynamic_cast<EltwiseLayer<Dtype>* >(eltw1_layer);
232    EXPECT_NE(null_ptr, eltw1_caffe);
233    const vector<shared_ptr<Layer<Dtype> > >& layers = net->layers();
234    for (int i = 0; i < layers.size(); i++) {
235      if (layers[i]->layer_param().type() == "Split") {
236        string name = layers[i]->layer_param().name();
237        Layer<Dtype>* split_layer = net->layer_by_name(name).get();
238        SplitLayer<Dtype>* split_caffe =
239            dynamic_cast<SplitLayer<Dtype>* >(split_layer);
240        EXPECT_NE(null_ptr, split_caffe);
241      }
242    }
243  }
244  #ifdef MKL2017_SUPPORTED
245  TYPED_TEST(TestEngineSelection, TestEngineParserNetMKL2017) {
246    typedef typename TypeParam::Dtype Dtype;
247    void* null_ptr = NULL;
248    this->InitNet("MKL2017");
249    Net<Dtype>* net = this->net_.get();
250    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
251    MKLConvolutionLayer<Dtype>* conv1_mkl =
252            dynamic_cast<MKLConvolutionLayer<Dtype>* >(conv1_layer);
253    EXPECT_NE(null_ptr, conv1_mkl);
254    ConvolutionLayer<Dtype>* conv1_caffe =
255            dynamic_cast<ConvolutionLayer<Dtype>* >(conv1_layer);
256    EXPECT_NE(null_ptr, conv1_caffe);
257    Layer<Dtype>* relu1_layer = net->layer_by_name("relu1").get();
258    MKLReLULayer<Dtype>* relu1_mkl =
259            dynamic_cast<MKLReLULayer<Dtype>* >(relu1_layer);
260    EXPECT_NE(null_ptr, relu1_mkl);
261    Layer<Dtype>* relu2_layer = net->layer_by_name("relu2").get();
262    MKLReLULayer<Dtype>* relu2_mkl =
263            dynamic_cast<MKLReLULayer<Dtype>* >(relu2_layer);
264    EXPECT_NE(null_ptr, relu2_mkl);
265    Layer<Dtype>* pool1_layer = net->layer_by_name("pool1").get();
266    MKLPoolingLayer<Dtype>* pool1_mkl =
267            dynamic_cast<MKLPoolingLayer<Dtype>* >(pool1_layer);
268    EXPECT_NE(null_ptr, pool1_mkl);
269    Layer<Dtype>* norm1_layer = net->layer_by_name("norm1").get();
270    MKLLRNLayer<Dtype>* norm1_mkl =
271            dynamic_cast<MKLLRNLayer<Dtype>* >(norm1_layer);
272    EXPECT_NE(null_ptr, norm1_mkl);
273    Layer<Dtype>* ip1_layer = net->layer_by_name("ip1").get();
274    InnerProductLayer<Dtype>* ip1_caffe =
275            dynamic_cast<InnerProductLayer<Dtype>* >(ip1_layer);
276    EXPECT_NE(null_ptr, ip1_caffe);
277    Layer<Dtype>* bn1_layer = net->layer_by_name("bn1").get();
278    MKLBatchNormLayer<Dtype>* bn1_mkl =
279            dynamic_cast<MKLBatchNormLayer<Dtype>* >(bn1_layer);
280    EXPECT_NE(null_ptr, bn1_mkl);
281    Layer<Dtype>* concat1_layer = net->layer_by_name("concat1").get();
282    MKLConcatLayer<Dtype>* concat1_mkl =
283            dynamic_cast<MKLConcatLayer<Dtype>* >(concat1_layer);
284    EXPECT_NE(null_ptr, concat1_mkl);
285    Layer<Dtype>* eltw1_layer = net->layer_by_name("eltw1").get();
286    MKLEltwiseLayer<Dtype>* eltw1_mkl =
287            dynamic_cast<MKLEltwiseLayer<Dtype>* >(eltw1_layer);
288    EXPECT_NE(null_ptr, eltw1_mkl);
289    const vector<shared_ptr<Layer<Dtype> > >& layers = net->layers();
290    for (int i = 0; i < layers.size(); i++) {
291      if (layers[i]->layer_param().type() == "Split") {
292        string name = layers[i]->layer_param().name();
293        Layer<Dtype>* split_layer = net->layer_by_name(name).get();
294        MKLSplitLayer<Dtype>* split_mkl =
295            dynamic_cast<MKLSplitLayer<Dtype>* >(split_layer);
296        EXPECT_NE(null_ptr, split_mkl);
297      }
298    }
299  }
300  #endif
301  #ifdef MKLDNN_SUPPORTED
302  TYPED_TEST(TestEngineSelection, TestEngineParserNetMKLDNN) {
303    typedef typename TypeParam::Dtype Dtype;
304    void* null_ptr = NULL;
305    this->InitNet("MKLDNN:CPU");
306    Net<Dtype>* net = this->net_.get();
307    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
308    MKLDNNConvolutionLayer<Dtype>* conv1_mkldnn =
309            dynamic_cast<MKLDNNConvolutionLayer<Dtype>* >(conv1_layer);
310    EXPECT_NE(null_ptr, conv1_mkldnn);
311    ConvolutionLayer<Dtype>* conv1_caffe =
312            dynamic_cast<ConvolutionLayer<Dtype>* >(conv1_layer);
313    EXPECT_NE(null_ptr, conv1_caffe);
314    Layer<Dtype>* relu1_layer = net->layer_by_name("relu1").get();
315    MKLDNNReLULayer<Dtype>* relu1_mkldnn =
316            dynamic_cast<MKLDNNReLULayer<Dtype>* >(relu1_layer);
317    EXPECT_EQ(null_ptr, relu1_mkldnn);
318    Layer<Dtype>* pool1_layer = net->layer_by_name("pool1").get();
319    MKLDNNPoolingLayer<Dtype>* pool1_mkldnn =
320            dynamic_cast<MKLDNNPoolingLayer<Dtype>* >(pool1_layer);
321    EXPECT_NE(null_ptr, pool1_mkldnn);
322    Layer<Dtype>* norm1_layer = net->layer_by_name("norm1").get();
323    MKLDNNLRNLayer<Dtype>* norm1_mkldnn =
324            dynamic_cast<MKLDNNLRNLayer<Dtype>* >(norm1_layer);
325    EXPECT_NE(null_ptr, norm1_mkldnn);
326    Layer<Dtype>* ip1_layer = net->layer_by_name("ip1").get();
327    MKLDNNInnerProductLayer<Dtype>* ip1_mkldnn =
328            dynamic_cast<MKLDNNInnerProductLayer<Dtype>* >(ip1_layer);
329    EXPECT_NE(null_ptr, ip1_mkldnn);
330    Layer<Dtype>* bn1_layer = net->layer_by_name("bn1").get();
331    MKLDNNBatchNormLayer<Dtype>* bn1_mkldnn =
332            dynamic_cast<MKLDNNBatchNormLayer<Dtype>* >(bn1_layer);
333    EXPECT_NE(null_ptr, bn1_mkldnn);
334    Layer<Dtype>* concat1_layer = net->layer_by_name("concat1").get();
335    MKLDNNConcatLayer<Dtype>* concat1_mkldnn =
336            dynamic_cast<MKLDNNConcatLayer<Dtype>* >(concat1_layer);
337    EXPECT_NE(null_ptr, concat1_mkldnn);
338    Layer<Dtype>* eltw1_layer = net->layer_by_name("eltw1").get();
339    MKLDNNEltwiseLayer<Dtype>* eltw1_mkldnn =
340            dynamic_cast<MKLDNNEltwiseLayer<Dtype>* >(eltw1_layer);
341    EXPECT_NE(null_ptr, eltw1_mkldnn);
342    const vector<shared_ptr<Layer<Dtype> > >& layers = net->layers();
343    for (int i = 0; i < layers.size(); i++) {
344      if (layers[i]->layer_param().type() == "Split") {
345        string name = layers[i]->layer_param().name();
346        Layer<Dtype>* split_layer = net->layer_by_name(name).get();
347        MKLDNNSplitLayer<Dtype>* split_caffe =
348            dynamic_cast<MKLDNNSplitLayer<Dtype>* >(split_layer);
349        EXPECT_NE(null_ptr, split_caffe);
350      }
351    }
352  }
353  #endif
354  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-poisson_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/poisson_distribution.h"
2  #include <algorithm>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iterator>
6  #include <random>
7  #include <sstream>
8  #include <string>
9  #include <vector>
10  #include "gmock/gmock.h"
11  #include "gtest/gtest.h"
12  #include "absl/base/macros.h"
13  #include "absl/container/flat_hash_map.h"
14  #include "absl/log/log.h"
15  #include "absl/random/internal/chi_square.h"
16  #include "absl/random/internal/distribution_test_util.h"
17  #include "absl/random/internal/pcg_engine.h"
18  #include "absl/random/internal/sequence_urbg.h"
19  #include "absl/random/random.h"
20  #include "absl/strings/str_cat.h"
21  #include "absl/strings/str_format.h"
22  #include "absl/strings/str_replace.h"
23  #include "absl/strings/strip.h"
24  namespace {
25  using absl::random_internal::kChiSquared;
26  template <typename IntType>
27  class PoissonDistributionInterfaceTest : public ::testing::Test {};
28  using IntTypes = ::testing::Types<int, int8_t, int16_t, int32_t, int64_t,
29                                    uint8_t, uint16_t, uint32_t, uint64_t>;
30  TYPED_TEST_SUITE(PoissonDistributionInterfaceTest, IntTypes);
31  TYPED_TEST(PoissonDistributionInterfaceTest, SerializeTest) {
32    using param_type = typename absl::poisson_distribution<TypeParam>::param_type;
33    const double kMax =
34        std::min(1e10 &bsol;* assertion limit */,
35                 static_cast<double>(std::numeric_limits<TypeParam>::max()));
36    const double kParams[] = {
37        1,                         
<span onclick='openModal()' class='match'>38        std::nextafter(1.0, 0.0),  
39        std::nextafter(1.0, 2.0),  
40        1e-8, 1e-4,
41        0.0000005,  
42        0.2,        
43        0.5,        
44        2,          
45        20,         
46        100, 1e4, 1e8, 1.5e9, 1e20,
47        std::numeric_limits<double>::max(),
48        std::numeric_limits<double>::epsilon(),
49        std::nextafter(std::numeric_limits<double>::min(),
50                       1.0),                        
51        std::numeric_limits<double>::min(),         
52        std::numeric_limits<double>::denorm_min(),  
53        std::numeric_limits<double>::min() / 2,     
54        std::nextafter(std::numeric_limits<double>::min(),
</span>55                       0.0),  
56    };
57    constexpr int kCount = 1000;
58    absl::InsecureBitGen gen;
59    for (const double m : kParams) {
60      const double mean = std::min(kMax, m);
61      const param_type param(mean);
62      absl::poisson_distribution<TypeParam> before(mean);
63      EXPECT_EQ(before.mean(), param.mean());
64      {
65        absl::poisson_distribution<TypeParam> via_param(param);
66        EXPECT_EQ(via_param, before);
67        EXPECT_EQ(via_param.param(), before.param());
68      }
69      auto sample_min = before.max();
70      auto sample_max = before.min();
71      for (int i = 0; i < kCount; i++) {
72        auto sample = before(gen);
73        EXPECT_GE(sample, before.min());
74        EXPECT_LE(sample, before.max());
75        if (sample > sample_max) sample_max = sample;
76        if (sample < sample_min) sample_min = sample;
77      }
78      LOG(INFO) << "Range {" << param.mean() << "}: " << sample_min << ", "
79                << sample_max;
80      std::stringstream ss;
81      ss << before;
82      absl::poisson_distribution<TypeParam> after(3.8);
83      EXPECT_NE(before.mean(), after.mean());
84      EXPECT_NE(before.param(), after.param());
85      EXPECT_NE(before, after);
86      ss >> after;
87      EXPECT_EQ(before.mean(), after.mean())  
88          << ss.str() << " "                  
89          << (ss.good() ? "good " : "")       
90          << (ss.bad() ? "bad " : "")         
91          << (ss.eof() ? "eof " : "")         
92          << (ss.fail() ? "fail " : "");
93    }
94  }
95  class PoissonModel {
96   public:
97    explicit PoissonModel(double mean) : mean_(mean) {}
98    double mean() const { return mean_; }
99    double variance() const { return mean_; }
100    double stddev() const { return std::sqrt(variance()); }
101    double skew() const { return 1.0 / mean_; }
102    double kurtosis() const { return 3.0 + 1.0 / mean_; }
103    void InitCDF();
104    struct CDF {
105      size_t index;
106      double pmf;
107      double cdf;
108    };
109    CDF InverseCDF(double p) {
110      CDF target{0, 0, p};
111      auto it = std::upper_bound(
112          std::begin(cdf_), std::end(cdf_), target,
113          [](const CDF& a, const CDF& b) { return a.cdf < b.cdf; });
114      return *it;
115    }
116    void LogCDF() {
117      LOG(INFO) << "CDF (mean = " << mean_ << ")";
118      for (const auto c : cdf_) {
119        LOG(INFO) << c.index << ": pmf=" << c.pmf << " cdf=" << c.cdf;
120      }
121    }
122   private:
123    const double mean_;
124    std::vector<CDF> cdf_;
125  };
126  void PoissonModel::InitCDF() {
127    if (!cdf_.empty()) {
128      return;
129    }
130    ABSL_ASSERT(mean_ < 201.0);
131    const size_t max_i = 50 * stddev() + mean();
132    const double e_neg_mean = std::exp(-mean());
133    ABSL_ASSERT(e_neg_mean > 0);
134    double d = 1;
135    double last_result = e_neg_mean;
136    double cumulative = e_neg_mean;
137    if (e_neg_mean > 1e-10) {
138      cdf_.push_back({0, e_neg_mean, cumulative});
139    }
140    for (size_t i = 1; i < max_i; i++) {
141      d *= (mean() / i);
142      double result = e_neg_mean * d;
143      cumulative += result;
144      if (result < 1e-10 && result < last_result && cumulative > 0.999999) {
145        break;
146      }
147      if (result > 1e-7) {
148        cdf_.push_back({i, result, cumulative});
149      }
150      last_result = result;
151    }
152    ABSL_ASSERT(!cdf_.empty());
153  }
154  struct ZParam {
155    double mean;
156    double p_fail;   
157    int trials;      
158    size_t samples;  
159  };
160  class PoissonDistributionZTest : public testing::TestWithParam<ZParam>,
161                                   public PoissonModel {
162   public:
163    PoissonDistributionZTest() : PoissonModel(GetParam().mean) {}
164    template <typename D>
165    bool SingleZTest(const double p, const size_t samples);
166    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
167  };
168  template <typename D>
169  bool PoissonDistributionZTest::SingleZTest(const double p,
170                                             const size_t samples) {
171    D dis(mean());
172    absl::flat_hash_map<int32_t, int> buckets;
173    std::vector<double> data;
174    data.reserve(samples);
175    for (int j = 0; j < samples; j++) {
176      const auto x = dis(rng_);
177      buckets[x]++;
178      data.push_back(x);
179    }
180    const auto m = absl::random_internal::ComputeDistributionMoments(data);
181    const double max_err = absl::random_internal::MaxErrorTolerance(p);
182    const double z = absl::random_internal::ZScore(mean(), m);
183    const bool pass = absl::random_internal::Near("z", z, 0.0, max_err);
184    if (!pass) {
185      LOG(INFO)
186          << "p=" << p << " max_err=" << max_err << "\n"
187             " mean=" << m.mean << " vs. " << mean() << "\n"
188             " stddev=" << std::sqrt(m.variance) << " vs. " << stddev() << "\n"
189             " skewness=" << m.skewness << " vs. " << skew() << "\n"
190             " kurtosis=" << m.kurtosis << " vs. " << kurtosis() << "\n"
191             " z=" << z;
192    }
193    return pass;
194  }
195  TEST_P(PoissonDistributionZTest, AbslPoissonDistribution) {
196    const auto& param = GetParam();
197    const int expected_failures =
198        std::max(1, static_cast<int>(std::ceil(param.trials * param.p_fail)));
199    const double p = absl::random_internal::RequiredSuccessProbability(
200        param.p_fail, param.trials);
201    int failures = 0;
202    for (int i = 0; i < param.trials; i++) {
203      failures +=
204          SingleZTest<absl::poisson_distribution<int32_t>>(p, param.samples) ? 0
205                                                                             : 1;
206    }
207    EXPECT_LE(failures, expected_failures);
208  }
209  std::vector<ZParam> GetZParams() {
210    return std::vector<ZParam>({
211        ZParam{0.5, 0.01, 100, 1000},
212        ZParam{1.0, 0.01, 100, 1000},
213        ZParam{10.0, 0.01, 100, 5000},
214        ZParam{20.0, 0.01, 100, 10000},
215        ZParam{50.0, 0.01, 100, 10000},
216        ZParam{51.0, 0.01, 100, 10000},
217        ZParam{200.0, 0.05, 10, 100000},
218        ZParam{100000.0, 0.05, 10, 1000000},
219    });
220  }
221  std::string ZParamName(const ::testing::TestParamInfo<ZParam>& info) {
222    const auto& p = info.param;
223    std::string name = absl::StrCat("mean_", absl::SixDigits(p.mean));
224    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
225  }
226  INSTANTIATE_TEST_SUITE_P(All, PoissonDistributionZTest,
227                           ::testing::ValuesIn(GetZParams()), ZParamName);
228  class PoissonDistributionChiSquaredTest : public testing::TestWithParam<double>,
229                                            public PoissonModel {
230   public:
231    PoissonDistributionChiSquaredTest() : PoissonModel(GetParam()) {}
232    template <typename D>
233    double ChiSquaredTestImpl();
234   private:
235    void InitChiSquaredTest(const double buckets);
236    std::vector<size_t> cutoffs_;
237    std::vector<double> expected_;
238    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
239  };
240  void PoissonDistributionChiSquaredTest::InitChiSquaredTest(
241      const double buckets) {
242    if (!cutoffs_.empty() && !expected_.empty()) {
243      return;
244    }
245    InitCDF();
246    double last_cdf = 0;
247    const double inc = 1.0 / buckets;
248    for (double p = inc; p <= 1.0; p += inc) {
249      auto result = InverseCDF(p);
250      if (!cutoffs_.empty() && cutoffs_.back() == result.index) {
251        continue;
252      }
253      double d = result.cdf - last_cdf;
254      cutoffs_.push_back(result.index);
255      expected_.push_back(d);
256      last_cdf = result.cdf;
257    }
258    cutoffs_.push_back(std::numeric_limits<size_t>::max());
259    expected_.push_back(std::max(0.0, 1.0 - last_cdf));
260  }
261  template <typename D>
262  double PoissonDistributionChiSquaredTest::ChiSquaredTestImpl() {
263    const int kSamples = 2000;
264    const int kBuckets = 50;
265    ABSL_ASSERT(mean() <= 200);
266    InitChiSquaredTest(kBuckets);
267    D dis(mean());
268    std::vector<int32_t> counts(cutoffs_.size(), 0);
269    for (int j = 0; j < kSamples; j++) {
270      const size_t x = dis(rng_);
271      auto it = std::lower_bound(std::begin(cutoffs_), std::end(cutoffs_), x);
272      counts[std::distance(cutoffs_.begin(), it)]++;
273    }
274    std::vector<int32_t> e(expected_.size(), 0);
275    for (int i = 0; i < e.size(); i++) {
276      e[i] = kSamples * expected_[i];
277    }
278    const int dof = static_cast<int>(counts.size()) - 1;
279    const double threshold = absl::random_internal::ChiSquareValue(dof, 0.98);
280    const double chi_square = absl::random_internal::ChiSquare(
281        std::begin(counts), std::end(counts), std::begin(e), std::end(e));
282    const double p = absl::random_internal::ChiSquarePValue(chi_square, dof);
283    if (chi_square > threshold) {
284      LogCDF();
285      LOG(INFO) << "VALUES  buckets=" << counts.size()
286                << "  samples=" << kSamples;
287      for (size_t i = 0; i < counts.size(); i++) {
288        LOG(INFO) << cutoffs_[i] << ": " << counts[i] << " vs. E=" << e[i];
289      }
290      LOG(INFO) << kChiSquared << "(data, dof=" << dof << ") = " << chi_square
291                << " (" << p << ")\n"
292                << " vs.\n"
293                << kChiSquared << " @ 0.98 = " << threshold;
294    }
295    return p;
296  }
297  TEST_P(PoissonDistributionChiSquaredTest, AbslPoissonDistribution) {
298    const int kTrials = 20;
299    ASSERT_LE(mean(), 200.0);
300    if (mean() > 200.0) {
301      return;
302    }
303    int failures = 0;
304    for (int i = 0; i < kTrials; i++) {
305      double p_value = ChiSquaredTestImpl<absl::poisson_distribution<int32_t>>();
306      if (p_value < 0.005) {
307        failures++;
308      }
309    }
310    EXPECT_LE(failures, 4);
311  }
312  INSTANTIATE_TEST_SUITE_P(All, PoissonDistributionChiSquaredTest,
313                           ::testing::Values(0.5, 1.0, 2.0, 10.0, 50.0, 51.0,
314                                             200.0));
315  TEST(PoissonDistributionTest, StabilityTest) {
316    using testing::ElementsAre;
317    absl::random_internal::sequence_urbg urbg({
318        0x035b0dc7e0a18acfull, 0x06cebe0d2653682eull, 0x0061e9b23861596bull,
319        0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull, 0xC332DDEFBE6C5AA5ull,
320        0x6558218568AB9702ull, 0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull,
321        0xECDD4775619F1510ull, 0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull,
322        0xB5735C904C70A239ull, 0xD59E9E0BCBAADE14ull, 0xEECC86BC60622CA7ull,
323        0x4864f22c059bf29eull, 0x247856d8b862665cull, 0xe46e86e9a1337e10ull,
324        0xd8c8541f3519b133ull, 0xe75b5162c567b9e4ull, 0xf732e5ded7009c5bull,
325        0xb170b98353121eacull, 0x1ec2e8986d2362caull, 0x814c8e35fe9a961aull,
326        0x0c3cd59c9b638a02ull, 0xcb3bb6478a07715cull, 0x1224e62c978bbc7full,
327        0x671ef2cb04e81f6eull, 0x3c1cbd811eaf1808ull, 0x1bbc23cfa8fac721ull,
328        0xa4c2cda65e596a51ull, 0xb77216fad37adf91ull, 0x836d794457c08849ull,
329        0xe083df03475f49d7ull, 0xbc9feb512e6b0d6cull, 0xb12d74fdd718c8c5ull,
330        0x12ff09653bfbe4caull, 0x8dd03a105bc4ee7eull, 0x5738341045ba0d85ull,
331        0xf3fd722dc65ad09eull, 0xfa14fd21ea2a5705ull, 0xffe6ea4d6edb0c73ull,
332        0xD07E9EFE2BF11FB4ull, 0x95DBDA4DAE909198ull, 0xEAAD8E716B93D5A0ull,
333        0xD08ED1D0AFC725E0ull, 0x8E3C5B2F8E7594B7ull, 0x8FF6E2FBF2122B64ull,
334        0x8888B812900DF01Cull, 0x4FAD5EA0688FC31Cull, 0xD1CFF191B3A8C1ADull,
335        0x2F2F2218BE0E1777ull, 0xEA752DFE8B021FA1ull, 0xE5A0CC0FB56F74E8ull,
336        0x18ACF3D6CE89E299ull, 0xB4A84FE0FD13E0B7ull, 0x7CC43B81D2ADA8D9ull,
337        0x165FA26680957705ull, 0x93CC7314211A1477ull, 0xE6AD206577B5FA86ull,
338        0xC75442F5FB9D35CFull, 0xEBCDAF0C7B3E89A0ull, 0xD6411BD3AE1E7E49ull,
339        0x00250E2D2071B35Eull, 0x226800BB57B8E0AFull, 0x2464369BF009B91Eull,
340        0x5563911D59DFA6AAull, 0x78C14389D95A537Full, 0x207D5BA202E5B9C5ull,
341        0x832603766295CFA9ull, 0x11C819684E734A41ull, 0xB3472DCA7B14A94Aull,
342    });
343    std::vector<int> output(10);
344    {
345      absl::poisson_distribution<int> dist(5);
346      std::generate(std::begin(output), std::end(output),
347                    [&] { return dist(urbg); });
348    }
349    EXPECT_THAT(output,  
350                ElementsAre(1, 0, 0, 4, 2, 10, 3, 3, 7, 12));
351    {
352      urbg.reset();
353      absl::poisson_distribution<int> dist(25);
354      std::generate(std::begin(output), std::end(output),
355                    [&] { return dist(urbg); });
356    }
357    EXPECT_THAT(output,  
358                ElementsAre(9, 35, 18, 10, 35, 18, 10, 35, 18, 10));
359    {
360      urbg.reset();
361      absl::poisson_distribution<int> dist(121);
362      std::generate(std::begin(output), std::end(output),
363                    [&] { return dist(urbg); });
364    }
365    EXPECT_THAT(output,  
366                ElementsAre(161, 122, 129, 124, 112, 112, 117, 120, 130, 114));
367  }
368  TEST(PoissonDistributionTest, AlgorithmExpectedValue_1) {
369    absl::random_internal::sequence_urbg urbg({0x8000000000000001ull});
370    absl::poisson_distribution<int> dist(5);
371    EXPECT_EQ(7, dist(urbg));
372  }
373  TEST(PoissonDistributionTest, AlgorithmExpectedValue_2) {
374    absl::random_internal::sequence_urbg urbg({0x8000000000000001ull});
375    absl::poisson_distribution<int> dist(25);
376    EXPECT_EQ(36, dist(urbg));
377  }
378  TEST(PoissonDistributionTest, AlgorithmExpectedValue_3) {
379    absl::random_internal::sequence_urbg urbg(
380        {0x7fffffffffffffffull, 0x8000000000000000ull});
381    absl::poisson_distribution<int> dist(121);
382    EXPECT_EQ(121, dist(urbg));
383  }
384  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_engine_selection.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-poisson_distribution_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>150    EXPECT_FALSE(ep3.isEngine("CAFFE"));
151    EXPECT_TRUE(ep3.isEngine("MKLDNN"));
152    EXPECT_FALSE(ep3.isEngine("MKL2017"));
153    EXPECT_FALSE(ep3.isEngine("CUDNN"));
154    EXPECT_EQ(3, ep3.getNumberOfSubEngines());
155    EXPECT_EQ(&ep3.getMKLDNNSubEngine(0), &CpuEngine::Instance().get_engine());
156  #ifdef FPGA_ENABLED
157    EXPECT_EQ(&ep3.getMKLDNNSubEngine(1), &FPGAEngine::Instance().get_engine());
</pre></code></div>
                <div class="column column_space"><pre><code>38        std::nextafter(1.0, 0.0),  
39        std::nextafter(1.0, 2.0),  
40        1e-8, 1e-4,
41        0.0000005,  
42        0.2,        
43        0.5,        
44        2,          
45        20,         
46        100, 1e4, 1e8, 1.5e9, 1e20,
47        std::numeric_limits<double>::max(),
48        std::numeric_limits<double>::epsilon(),
49        std::nextafter(std::numeric_limits<double>::min(),
50                       1.0),                        
51        std::numeric_limits<double>::min(),         
52        std::numeric_limits<double>::denorm_min(),  
53        std::numeric_limits<double>::min() / 2,     
54        std::nextafter(std::numeric_limits<double>::min(),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    