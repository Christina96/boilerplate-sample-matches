
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.979253112033195%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Cpp_Primer_Answers-MDEwOlJlcG9zaXRvcnk0NzE3MDI2MQ==-flat-exercise14_23.cpp</h3>
            <pre><code>1  #include "exercise14_23.h"
2  #include <algorithm>
3  void StrVec::push_back(const std::string &s)
4  {
5  	chk_n_alloc();
6  	alloc.construct(first_free++, s);
7  }
8  std::pair<std::string*, std::string*>
9  StrVec::alloc_n_copy(const std::string *b, const std::string *e)
10  {
11  	auto data = alloc.allocate(e - b);
12  	return{ data, std::uninitialized_copy(b, e, data) };
13  }
14  void StrVec::free()
15  {
16  	if (elements)
17  	{
18  		for_each(elements, first_free, [this](std::string &rhs) { alloc.destroy(&rhs); });
19  		alloc.deallocate(elements, cap - elements);
20  	}
21  }
22  void StrVec::range_initialize(const std::string *first, const std::string *last)
23  {
24  	auto newdata = alloc_n_copy(first, last);
25  	elements = newdata.first;
26  	first_free = cap = newdata.second;
27  }
28  StrVec::StrVec(const StrVec &rhs)
29  {
30  	range_initialize(rhs.begin(), rhs.end());
31  }
32  StrVec::StrVec(std::initializer_list<std::string> il)
33  {
34  	range_initialize(il.begin(), il.end());
35  }
36  StrVec::~StrVec()
37  {
38  	free();
39  }
40  StrVec& StrVec::operator = (const StrVec &rhs)
41  {
42  	auto data = alloc_n_copy(rhs.begin(), rhs.end());
43  	free();
44  	elements = data.first;
45  	first_free = cap = data.second;
46  	return *this;
47  }
48  void StrVec::alloc_n_move(size_t new_cap)
49  {
50  	auto newdata = alloc.allocate(new_cap);
51  	auto dest = newdata;
52  	auto elem = elements;
53  	for (size_t i = 0; i != size(); ++i)
54  		alloc.construct(dest++, std::move(*elem++));
55  	free();
56  	elements = newdata;
57  	first_free = dest;
58  	cap = elements + new_cap;
59  }
60  void StrVec::reallocate()
61  {
62  	auto newcapacity = size() ? 2 * size() : 1;
63  	alloc_n_move(newcapacity);
64  }
65  void StrVec::reserve(size_t new_cap)
66  {
67  	if (new_cap <= capacity()) return;
68  	alloc_n_move(new_cap);
69  }
70  void StrVec::resize(size_t count)
71  {
72  	resize(count, std::string());
73  }
74  void StrVec::resize(size_t count, const std::string &s)
75  {
76  	if (count > size())
77  	{
78  		if (count > capacity()) reserve(count * 2);
79  		for (size_t i = size(); i != count; ++i)
80  			alloc.construct(first_free++, s);
81  	}
82  	else if (count < size())
83  	{
84  		while (first_free != elements + count)
85  			alloc.destroy(--first_free);
86  	}
87  }
88  StrVec::StrVec(StrVec &&s) NOEXCEPT : elements(s.elements), first_free(s.first_free), cap(s.cap)
89  {
90  	s.elements = s.first_free = s.cap = nullptr;
91  }
92  StrVec& StrVec::operator = (StrVec &&rhs) NOEXCEPT
93  {
94  	if (this != &rhs)
95  	{
96  		free();
97  		elements = rhs.elements;
98  		first_free = rhs.first_free;
99  		cap = rhs.cap;
100  		rhs.elements = rhs.first_free = rhs.cap = nullptr;
101  	}
102  	return *this;
103  }
104  bool operator==(const StrVec &lhs, const StrVec &rhs)
105  {
106  	return (lhs.size() == rhs.size() && std::equal(lhs.begin(), lhs.end(), rhs.begin()));
<span onclick='openModal()' class='match'>107  }
108  bool operator!=(const StrVec &lhs, const StrVec &rhs)
109  {
110  	return !(lhs == rhs);
111  }
112  bool operator<(const StrVec &lhs, const StrVec &rhs)
</span>113  {
114  	return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
115  }
116  bool operator>(const StrVec &lhs, const StrVec &rhs)
117  {
118  	return rhs < lhs;
119  }
120  bool operator<=(const StrVec &lhs, const StrVec &rhs)
121  {
122  	return !(rhs < lhs);
123  }
124  bool operator>=(const StrVec &lhs, const StrVec &rhs)
125  {
126  	return !(lhs < rhs);
127  }
128  StrVec& StrVec::operator=(std::initializer_list<std::string> il)
129  {
130  	*this = StrVec(il);
131  	return *this;
132  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-message_deserializer_65.cpp</h3>
            <pre><code>1  #include <nano/node/node.hpp>
2  #include <nano/node/transport/message_deserializer.hpp>
3  nano::transport::message_deserializer::message_deserializer (nano::network_constants const & network_constants_a, nano::network_filter & publish_filter_a, nano::block_uniquer & block_uniquer_a, nano::vote_uniquer & vote_uniquer_a,
4  read_query read_op) :
5  	read_buffer{ std::make_shared<std::vector<uint8_t>> () },
6  	network_constants_m{ network_constants_a },
7  	publish_filter_m{ publish_filter_a },
8  	block_uniquer_m{ block_uniquer_a },
9  	vote_uniquer_m{ vote_uniquer_a },
10  	read_op{ std::move (read_op) }
11  {
12  	debug_assert (this->read_op);
13  	read_buffer->resize (MAX_MESSAGE_SIZE);
14  }
15  void nano::transport::message_deserializer::read (const nano::transport::message_deserializer::callback_type && callback)
16  {
17  	debug_assert (callback);
18  	debug_assert (read_op);
19  	status = parse_status::none;
20  	read_op (read_buffer, HEADER_SIZE, [this_l = shared_from_this (), callback = std::move (callback)] (boost::system::error_code const & ec, std::size_t size_a) {
21  		if (ec)
22  		{
23  			callback (ec, nullptr);
24  			return;
25  		}
26  		if (size_a != HEADER_SIZE)
27  		{
28  			callback (boost::asio::error::fault, nullptr);
29  			return;
30  		}
31  		this_l->received_header (std::move (callback));
32  	});
33  }
34  void nano::transport::message_deserializer::received_header (const nano::transport::message_deserializer::callback_type && callback)
35  {
36  	nano::bufferstream stream{ read_buffer->data (), HEADER_SIZE };
37  	auto error = false;
38  	nano::message_header header{ error, stream };
39  	if (error)
40  	{
41  		status = parse_status::invalid_header;
42  		callback (boost::asio::error::fault, nullptr);
43  		return;
44  	}
45  	if (header.network != network_constants_m.current_network)
46  	{
47  		status = parse_status::invalid_network;
48  		callback (boost::asio::error::fault, nullptr);
49  		return;
50  	}
51  	if (header.version_using < network_constants_m.protocol_version_min)
52  	{
53  		status = parse_status::outdated_version;
54  		callback (boost::asio::error::fault, nullptr);
55  		return;
56  	}
57  	if (!header.is_valid_message_type ())
58  	{
59  		status = parse_status::invalid_header;
60  		callback (boost::asio::error::fault, nullptr);
61  		return;
62  	}
63  	std::size_t payload_size = header.payload_length_bytes ();
64  	if (payload_size > MAX_MESSAGE_SIZE)
65  	{
66  		status = parse_status::message_size_too_big;
67  		callback (boost::asio::error::fault, nullptr);
68  		return;
69  	}
70  	debug_assert (payload_size <= read_buffer->capacity ());
71  	if (payload_size == 0)
72  	{
73  		received_message (header, 0, std::move (callback));
74  	}
75  	else
76  	{
77  		debug_assert (read_op);
78  		read_op (read_buffer, payload_size, [this_l = shared_from_this (), payload_size, header, callback = std::move (callback)] (boost::system::error_code const & ec, std::size_t size_a) {
79  			if (ec)
80  			{
81  				callback (ec, nullptr);
82  				return;
83  			}
84  			if (size_a != payload_size)
85  			{
86  				callback (boost::asio::error::fault, nullptr);
87  				return;
88  			}
89  			this_l->received_message (header, size_a, std::move (callback));
90  		});
91  	}
92  }
93  void nano::transport::message_deserializer::received_message (nano::message_header header, std::size_t payload_size, const nano::transport::message_deserializer::callback_type && callback)
94  {
95  	auto message = deserialize (header, payload_size);
96  	if (message)
97  	{
98  		debug_assert (status == parse_status::none);
99  		status = parse_status::success;
100  		callback (boost::system::error_code{}, std::move (message));
101  	}
102  	else
103  	{
104  		debug_assert (status != parse_status::none);
105  		callback (boost::system::error_code{}, nullptr);
106  	}
107  }
108  std::unique_ptr<nano::message> nano::transport::message_deserializer::deserialize (nano::message_header header, std::size_t payload_size)
109  {
110  	release_assert (payload_size <= MAX_MESSAGE_SIZE);
111  	nano::bufferstream stream{ read_buffer->data (), payload_size };
112  	switch (header.type)
113  	{
114  		case nano::message_type::keepalive:
115  		{
116  			return deserialize_keepalive (stream, header);
117  		}
118  		case nano::message_type::publish:
119  		{
120  			nano::uint128_t digest;
121  			if (!publish_filter_m.apply (read_buffer->data (), payload_size, &digest))
122  			{
123  				return deserialize_publish (stream, header, digest);
124  			}
125  			else
126  			{
127  				status = parse_status::duplicate_publish_message;
128  			}
129  			break;
130  		}
131  		case nano::message_type::confirm_req:
132  		{
133  			return deserialize_confirm_req (stream, header);
134  		}
135  		case nano::message_type::confirm_ack:
136  		{
137  			return deserialize_confirm_ack (stream, header);
138  		}
139  		case nano::message_type::node_id_handshake:
140  		{
141  			return deserialize_node_id_handshake (stream, header);
142  		}
143  		case nano::message_type::telemetry_req:
144  		{
145  			return deserialize_telemetry_req (stream, header);
146  		}
147  		case nano::message_type::telemetry_ack:
148  		{
149  			return deserialize_telemetry_ack (stream, header);
150  		}
151  		case nano::message_type::bulk_pull:
152  		{
153  			return deserialize_bulk_pull (stream, header);
154  		}
155  		case nano::message_type::bulk_pull_account:
156  		{
157  			return deserialize_bulk_pull_account (stream, header);
158  		}
159  		case nano::message_type::bulk_push:
160  		{
161  			return deserialize_bulk_push (stream, header);
162  		}
163  		case nano::message_type::frontier_req:
164  		{
165  			return deserialize_frontier_req (stream, header);
166  		}
167  		case nano::message_type::asc_pull_req:
168  		{
169  			return deserialize_asc_pull_req (stream, header);
170  		}
171  		case nano::message_type::asc_pull_ack:
172  		{
173  			return deserialize_asc_pull_ack (stream, header);
174  		}
175  		default:
176  		{
177  			status = parse_status::invalid_message_type;
178  			break;
179  		}
180  	}
181  	return {};
182  }
183  std::unique_ptr<nano::keepalive> nano::transport::message_deserializer::deserialize_keepalive (nano::stream & stream, nano::message_header const & header)
184  {
185  	auto error = false;
186  	auto incoming = std::make_unique<nano::keepalive> (error, stream, header);
187  	if (!error && nano::at_end (stream))
188  	{
189  		return incoming;
190  	}
191  	else
192  	{
193  		status = parse_status::invalid_keepalive_message;
194  	}
195  	return {};
196  }
197  std::unique_ptr<nano::publish> nano::transport::message_deserializer::deserialize_publish (nano::stream & stream, nano::message_header const & header, nano::uint128_t const & digest_a)
198  {
199  	auto error = false;
200  	auto incoming = std::make_unique<nano::publish> (error, stream, header, digest_a, &block_uniquer_m);
201  	if (!error && nano::at_end (stream))
202  	{
203  		release_assert (incoming->block);
204  		if (!network_constants_m.work.validate_entry (*incoming->block))
205  		{
206  			return incoming;
207  		}
208  		else
209  		{
210  			status = parse_status::insufficient_work;
211  		}
212  	}
213  	else
214  	{
215  		status = parse_status::invalid_publish_message;
216  	}
217  	return {};
218  }
219  std::unique_ptr<nano::confirm_req> nano::transport::message_deserializer::deserialize_confirm_req (nano::stream & stream, nano::message_header const & header)
220  {
221  	auto error = false;
222  	auto incoming = std::make_unique<nano::confirm_req> (error, stream, header, &block_uniquer_m);
223  	if (!error && nano::at_end (stream))
224  	{
225  		if (incoming->block == nullptr || !network_constants_m.work.validate_entry (*incoming->block))
226  		{
227  			return incoming;
228  		}
229  		else
230  		{
231  			status = parse_status::insufficient_work;
232  		}
233  	}
234  	else
235  	{
236  		status = parse_status::invalid_confirm_req_message;
237  	}
238  	return {};
239  }
240  std::unique_ptr<nano::confirm_ack> nano::transport::message_deserializer::deserialize_confirm_ack (nano::stream & stream, nano::message_header const & header)
241  {
242  	auto error = false;
243  	auto incoming = std::make_unique<nano::confirm_ack> (error, stream, header, &vote_uniquer_m);
244  	if (!error && nano::at_end (stream))
245  	{
246  		return incoming;
247  	}
248  	else
249  	{
250  		status = parse_status::invalid_confirm_ack_message;
251  	}
252  	return {};
253  }
254  std::unique_ptr<nano::node_id_handshake> nano::transport::message_deserializer::deserialize_node_id_handshake (nano::stream & stream, nano::message_header const & header)
255  {
256  	bool error = false;
257  	auto incoming = std::make_unique<nano::node_id_handshake> (error, stream, header);
258  	if (!error && nano::at_end (stream))
259  	{
260  		return incoming;
261  	}
262  	else
263  	{
264  		status = parse_status::invalid_node_id_handshake_message;
265  	}
266  	return {};
<span onclick='openModal()' class='match'>267  }
268  std::unique_ptr<nano::telemetry_req> nano::transport::message_deserializer::deserialize_telemetry_req (nano::stream & stream, nano::message_header const & header)
269  {
270  	return std::make_unique<nano::telemetry_req> (header);
271  }
272  std::unique_ptr<nano::telemetry_ack> nano::transport::message_deserializer::deserialize_telemetry_ack (nano::stream & stream, nano::message_header const & header)
</span>273  {
274  	bool error = false;
275  	auto incoming = std::make_unique<nano::telemetry_ack> (error, stream, header);
276  	if (!error)
277  	{
278  		return incoming;
279  	}
280  	else
281  	{
282  		status = parse_status::invalid_telemetry_ack_message;
283  	}
284  	return {};
285  }
286  std::unique_ptr<nano::bulk_pull> nano::transport::message_deserializer::deserialize_bulk_pull (nano::stream & stream, const nano::message_header & header)
287  {
288  	bool error = false;
289  	auto incoming = std::make_unique<nano::bulk_pull> (error, stream, header);
290  	if (!error && nano::at_end (stream))
291  	{
292  		return incoming;
293  	}
294  	else
295  	{
296  		status = parse_status::invalid_bulk_pull_message;
297  	}
298  	return {};
299  }
300  std::unique_ptr<nano::bulk_pull_account> nano::transport::message_deserializer::deserialize_bulk_pull_account (nano::stream & stream, const nano::message_header & header)
301  {
302  	bool error = false;
303  	auto incoming = std::make_unique<nano::bulk_pull_account> (error, stream, header);
304  	if (!error && nano::at_end (stream))
305  	{
306  		return incoming;
307  	}
308  	else
309  	{
310  		status = parse_status::invalid_bulk_pull_account_message;
311  	}
312  	return {};
313  }
314  std::unique_ptr<nano::frontier_req> nano::transport::message_deserializer::deserialize_frontier_req (nano::stream & stream, const nano::message_header & header)
315  {
316  	bool error = false;
317  	auto incoming = std::make_unique<nano::frontier_req> (error, stream, header);
318  	if (!error && nano::at_end (stream))
319  	{
320  		return incoming;
321  	}
322  	else
323  	{
324  		status = parse_status::invalid_frontier_req_message;
325  	}
326  	return {};
327  }
328  std::unique_ptr<nano::bulk_push> nano::transport::message_deserializer::deserialize_bulk_push (nano::stream & stream, const nano::message_header & header)
329  {
330  	return std::make_unique<nano::bulk_push> (header);
331  }
332  std::unique_ptr<nano::asc_pull_req> nano::transport::message_deserializer::deserialize_asc_pull_req (nano::stream & stream, const nano::message_header & header)
333  {
334  	bool error = false;
335  	auto incoming = std::make_unique<nano::asc_pull_req> (error, stream, header);
336  	if (!error)
337  	{
338  		return incoming;
339  	}
340  	else
341  	{
342  		status = parse_status::invalid_asc_pull_req_message;
343  	}
344  	return {};
345  }
346  std::unique_ptr<nano::asc_pull_ack> nano::transport::message_deserializer::deserialize_asc_pull_ack (nano::stream & stream, const nano::message_header & header)
347  {
348  	bool error = false;
349  	auto incoming = std::make_unique<nano::asc_pull_ack> (error, stream, header);
350  	if (!error)
351  	{
352  		return incoming;
353  	}
354  	else
355  	{
356  		status = parse_status::invalid_asc_pull_ack_message;
357  	}
358  	return {};
359  }
360  nano::stat::detail nano::transport::message_deserializer::to_stat_detail (parse_status status)
361  {
362  	switch (status)
363  	{
364  		case parse_status::none:
365  		case parse_status::success:
366  			break;
367  		case parse_status::insufficient_work:
368  			return stat::detail::insufficient_work;
369  			break;
370  		case parse_status::invalid_header:
371  			return stat::detail::invalid_header;
372  			break;
373  		case parse_status::invalid_message_type:
374  			return stat::detail::invalid_message_type;
375  			break;
376  		case parse_status::invalid_keepalive_message:
377  			return stat::detail::invalid_keepalive_message;
378  			break;
379  		case parse_status::invalid_publish_message:
380  			return stat::detail::invalid_publish_message;
381  			break;
382  		case parse_status::invalid_confirm_req_message:
383  			return stat::detail::invalid_confirm_req_message;
384  			break;
385  		case parse_status::invalid_confirm_ack_message:
386  			return stat::detail::invalid_confirm_ack_message;
387  			break;
388  		case parse_status::invalid_node_id_handshake_message:
389  			return stat::detail::invalid_node_id_handshake_message;
390  			break;
391  		case parse_status::invalid_telemetry_req_message:
392  			return stat::detail::invalid_telemetry_req_message;
393  			break;
394  		case parse_status::invalid_telemetry_ack_message:
395  			return stat::detail::invalid_telemetry_ack_message;
396  			break;
397  		case parse_status::invalid_bulk_pull_message:
398  			return stat::detail::invalid_bulk_pull_message;
399  			break;
400  		case parse_status::invalid_bulk_pull_account_message:
401  			return stat::detail::invalid_bulk_pull_account_message;
402  			break;
403  		case parse_status::invalid_frontier_req_message:
404  			return stat::detail::invalid_frontier_req_message;
405  			break;
406  		case parse_status::invalid_asc_pull_req_message:
407  			return stat::detail::invalid_asc_pull_req_message;
408  			break;
409  		case parse_status::invalid_asc_pull_ack_message:
410  			return stat::detail::invalid_asc_pull_ack_message;
411  			break;
412  		case parse_status::invalid_network:
413  			return stat::detail::invalid_network;
414  			break;
415  		case parse_status::outdated_version:
416  			return stat::detail::outdated_version;
417  			break;
418  		case parse_status::duplicate_publish_message:
419  			return stat::detail::duplicate_publish;
420  			break;
421  		case parse_status::message_size_too_big:
422  			return stat::detail::message_too_big;
423  			break;
424  	}
425  	return {};
426  }
427  std::string nano::transport::message_deserializer::to_string (parse_status status)
428  {
429  	switch (status)
430  	{
431  		case parse_status::none:
432  			return "none";
433  			break;
434  		case parse_status::success:
435  			return "success";
436  			break;
437  		case parse_status::insufficient_work:
438  			return "insufficient_work";
439  			break;
440  		case parse_status::invalid_header:
441  			return "invalid_header";
442  			break;
443  		case parse_status::invalid_message_type:
444  			return "invalid_message_type";
445  			break;
446  		case parse_status::invalid_keepalive_message:
447  			return "invalid_keepalive_message";
448  			break;
449  		case parse_status::invalid_publish_message:
450  			return "invalid_publish_message";
451  			break;
452  		case parse_status::invalid_confirm_req_message:
453  			return "invalid_confirm_req_message";
454  			break;
455  		case parse_status::invalid_confirm_ack_message:
456  			return "invalid_confirm_ack_message";
457  			break;
458  		case parse_status::invalid_node_id_handshake_message:
459  			return "invalid_node_id_handshake_message";
460  			break;
461  		case parse_status::invalid_telemetry_req_message:
462  			return "invalid_telemetry_req_message";
463  			break;
464  		case parse_status::invalid_telemetry_ack_message:
465  			return "invalid_telemetry_ack_message";
466  			break;
467  		case parse_status::invalid_bulk_pull_message:
468  			return "invalid_bulk_pull_message";
469  			break;
470  		case parse_status::invalid_bulk_pull_account_message:
471  			return "invalid_bulk_pull_account_message";
472  			break;
473  		case parse_status::invalid_frontier_req_message:
474  			return "invalid_frontier_req_message";
475  			break;
476  		case parse_status::invalid_asc_pull_req_message:
477  			return "invalid_asc_pull_req_message";
478  			break;
479  		case parse_status::invalid_asc_pull_ack_message:
480  			return "invalid_asc_pull_ack_message";
481  			break;
482  		case parse_status::invalid_network:
483  			return "invalid_network";
484  			break;
485  		case parse_status::outdated_version:
486  			return "outdated_version";
487  			break;
488  		case parse_status::duplicate_publish_message:
489  			return "duplicate_publish_message";
490  			break;
491  		case parse_status::message_size_too_big:
492  			return "message_size_too_big";
493  			break;
494  	}
495  	return "n/a";
496  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Cpp_Primer_Answers-MDEwOlJlcG9zaXRvcnk0NzE3MDI2MQ==-flat-exercise14_23.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-message_deserializer_65.cpp</div>
                </div>
                <div class="column column_space"><pre><code>107  }
108  bool operator!=(const StrVec &lhs, const StrVec &rhs)
109  {
110  	return !(lhs == rhs);
111  }
112  bool operator<(const StrVec &lhs, const StrVec &rhs)
</pre></code></div>
                <div class="column column_space"><pre><code>267  }
268  std::unique_ptr<nano::telemetry_req> nano::transport::message_deserializer::deserialize_telemetry_req (nano::stream & stream, nano::message_header const & header)
269  {
270  	return std::make_unique<nano::telemetry_req> (header);
271  }
272  std::unique_ptr<nano::telemetry_ack> nano::transport::message_deserializer::deserialize_telemetry_ack (nano::stream & stream, nano::message_header const & header)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    