
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.280442804428045%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagedata.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "imagedata.h"
5  #include "boxread.h"    
6  #include "rect.h"       
7  #include "scrollview.h" 
8  #include "tprintf.h"    
9  #include "helpers.h"  
10  #include "serialis.h" 
11  #include <allheaders.h> 
12  #include <cinttypes> 
13  namespace tesseract {
14  const int kMaxReadAhead = 8;
15  ImageData::ImageData() : page_number_(-1), vertical_text_(false) {}
16  ImageData::ImageData(bool vertical, Image pix)
17      : page_number_(0), vertical_text_(vertical) {
18    SetPix(pix);
19  }
20  ImageData::~ImageData() {
21  #ifdef TESSERACT_IMAGEDATA_AS_PIX
22    internal_pix_.destroy();
23  #endif
24  }
25  ImageData *ImageData::Build(const char *name, int page_number, const char *lang,
26                              const char *imagedata, int imagedatasize,
27                              const char *truth_text, const char *box_text) {
28    auto *image_data = new ImageData();
29    image_data->imagefilename_ = name;
30    image_data->page_number_ = page_number;
31    image_data->language_ = lang;
32    image_data->image_data_.resize(imagedatasize);
33    memcpy(&image_data->image_data_[0], imagedata, imagedatasize);
34    if (!image_data->AddBoxes(box_text)) {
35      if (truth_text == nullptr || truth_text[0] == '\0') {
36        tprintf("Error: No text corresponding to page %d from image %s!\n",
37                page_number, name);
38        delete image_data;
39        return nullptr;
40      }
41      image_data->transcription_ = truth_text;
42      image_data->box_texts_.emplace_back(truth_text);
43    } else if (truth_text != nullptr && truth_text[0] != '\0' &&
44               image_data->transcription_ != truth_text) {
45      image_data->transcription_ = truth_text;
46    }
47    return image_data;
48  }
49  bool ImageData::Serialize(TFile *fp) const {
50    if (!fp->Serialize(imagefilename_)) {
51      return false;
52    }
53    if (!fp->Serialize(&page_number_)) {
54      return false;
55    }
56    if (!fp->Serialize(image_data_)) {
57      return false;
58    }
59    if (!fp->Serialize(language_)) {
60      return false;
61    }
62    if (!fp->Serialize(transcription_)) {
63      return false;
64    }
65    if (!fp->Serialize(boxes_)) {
66      return false;
67    }
68    if (!fp->Serialize(box_texts_)) {
69      return false;
70    }
71    int8_t vertical = vertical_text_;
<span onclick='openModal()' class='match'>72    return fp->Serialize(&vertical);
73  }
74  bool ImageData::DeSerialize(TFile *fp) {
75    if (!fp->DeSerialize(imagefilename_)) {
76      return false;
77    }
</span>78    if (!fp->DeSerialize(&page_number_)) {
79      return false;
80    }
81    if (!fp->DeSerialize(image_data_)) {
82      return false;
83    }
84    if (!fp->DeSerialize(language_)) {
85      return false;
86    }
87    if (!fp->DeSerialize(transcription_)) {
88      return false;
89    }
90    if (!fp->DeSerialize(boxes_)) {
91      return false;
92    }
93    if (!fp->DeSerialize(box_texts_)) {
94      return false;
95    }
96    int8_t vertical = 0;
97    if (!fp->DeSerialize(&vertical)) {
98      return false;
99    }
100    vertical_text_ = vertical != 0;
101    return true;
102  }
103  bool ImageData::SkipDeSerialize(TFile *fp) {
104    if (!fp->DeSerializeSkip()) {
105      return false;
106    }
107    int32_t page_number;
108    if (!fp->DeSerialize(&page_number)) {
109      return false;
110    }
111    if (!fp->DeSerializeSkip()) {
112      return false;
113    }
114    if (!fp->DeSerializeSkip()) {
115      return false;
116    }
117    if (!fp->DeSerializeSkip()) {
118      return false;
119    }
120    if (!fp->DeSerializeSkip(sizeof(TBOX))) {
121      return false;
122    }
123    int32_t number;
124    if (!fp->DeSerialize(&number)) {
125      return false;
126    }
127    for (int i = 0; i < number; i++) {
128      if (!fp->DeSerializeSkip()) {
129        return false;
130      }
131    }
132    int8_t vertical = 0;
133    return fp->DeSerialize(&vertical);
134  }
135  void ImageData::SetPix(Image pix) {
136  #ifdef TESSERACT_IMAGEDATA_AS_PIX
137    internal_pix_ = pix;
138  #else
139    SetPixInternal(pix, &image_data_);
140  #endif
141  }
142  Image ImageData::GetPix() const {
143  #ifdef TESSERACT_IMAGEDATA_AS_PIX
144  #  ifdef GRAPHICS_DISABLED
145    return internal_pix_.clone();
146  #  else
147    return internal_pix_.copy();
148  #  endif
149  #else
150    return GetPixInternal(image_data_);
151  #endif
152  }
153  Image ImageData::PreScale(int target_height, int max_height,
154                            float *scale_factor, int *scaled_width,
155                            int *scaled_height, std::vector<TBOX> *boxes) const {
156    int input_width = 0;
157    int input_height = 0;
158    Image src_pix = GetPix();
159    ASSERT_HOST(src_pix != nullptr);
160    input_width = pixGetWidth(src_pix);
161    input_height = pixGetHeight(src_pix);
162    if (target_height == 0) {
163      target_height = std::min(input_height, max_height);
164    }
165    float im_factor = static_cast<float>(target_height) / input_height;
166    if (scaled_width != nullptr) {
167      *scaled_width = IntCastRounded(im_factor * input_width);
168    }
169    if (scaled_height != nullptr) {
170      *scaled_height = target_height;
171    }
172    Image pix = pixScale(src_pix, im_factor, im_factor);
173    if (pix == nullptr) {
174      tprintf("Scaling pix of size %d, %d by factor %g made null pix!!\n",
175              input_width, input_height, im_factor);
176      src_pix.destroy();
177      return nullptr;
178    }
179    if (scaled_width != nullptr) {
180      *scaled_width = pixGetWidth(pix);
181    }
182    if (scaled_height != nullptr) {
183      *scaled_height = pixGetHeight(pix);
184    }
185    src_pix.destroy();
186    if (boxes != nullptr) {
187      boxes->clear();
188      for (auto box : boxes_) {
189        box.scale(im_factor);
190        boxes->push_back(box);
191      }
192      if (boxes->empty()) {
193        TBOX box(0, 0, im_factor * input_width, target_height);
194        boxes->push_back(box);
195      }
196    }
197    if (scale_factor != nullptr) {
198      *scale_factor = im_factor;
199    }
200    return pix;
201  }
202  int ImageData::MemoryUsed() const {
203    return image_data_.size();
204  }
205  #ifndef GRAPHICS_DISABLED
206  void ImageData::Display() const {
207    const int kTextSize = 64;
208    Image pix = GetPix();
209    if (pix == nullptr) {
210      return;
211    }
212    int width = pixGetWidth(pix);
213    int height = pixGetHeight(pix);
214    auto *win = new ScrollView("Imagedata", 100, 100, 2 * (width + 2 * kTextSize),
215                               2 * (height + 4 * kTextSize), width + 10,
216                               height + 3 * kTextSize, true);
217    win->Draw(pix, 0, height - 1);
218    pix.destroy();
219    win->Pen(ScrollView::RED);
220    win->Brush(ScrollView::NONE);
221    int text_size = kTextSize;
222    if (!boxes_.empty() && boxes_[0].height() * 2 < text_size) {
223      text_size = boxes_[0].height() * 2;
224    }
225    win->TextAttributes("Arial", text_size, false, false, false);
226    if (!boxes_.empty()) {
227      for (unsigned b = 0; b < boxes_.size(); ++b) {
228        boxes_[b].plot(win);
229        win->Text(boxes_[b].left(), height + kTextSize, box_texts_[b].c_str());
230      }
231    } else {
232      win->Pen(ScrollView::CYAN);
233      win->Text(0, height + kTextSize * 2, transcription_.c_str());
234    }
235    win->Update();
236    win->Wait();
237  }
238  #endif
239  void ImageData::AddBoxes(const std::vector<TBOX> &boxes,
240                           const std::vector<std::string> &texts,
241                           const std::vector<int> &box_pages) {
242    for (unsigned i = 0; i < box_pages.size(); ++i) {
243      if (page_number_ >= 0 && box_pages[i] != page_number_) {
244        continue;
245      }
246      transcription_ += texts[i];
247      boxes_.push_back(boxes[i]);
248      box_texts_.push_back(texts[i]);
249    }
250  }
251  #ifndef TESSERACT_IMAGEDATA_AS_PIX
252  void ImageData::SetPixInternal(Image pix, std::vector<char> *image_data) {
253    l_uint8 *data;
254    size_t size;
255    l_int32 ret;
256    ret = pixWriteMem(&data, &size, pix, IFF_PNG);
257    if (ret) {
258      ret = pixWriteMem(&data, &size, pix, IFF_PNM);
259    }
260    pix.destroy();
261    image_data->resize(size);
262    memcpy(&(*image_data)[0], data, size);
263    lept_free(data);
264  }
265  Image ImageData::GetPixInternal(const std::vector<char> &image_data) {
266    Image pix = nullptr;
267    if (!image_data.empty()) {
268      const auto *u_data =
269          reinterpret_cast<const unsigned char *>(&image_data[0]);
270      pix = pixReadMem(u_data, image_data.size());
271    }
272    return pix;
273  }
274  #endif
275  bool ImageData::AddBoxes(const char *box_text) {
276    if (box_text != nullptr && box_text[0] != '\0') {
277      std::vector<TBOX> boxes;
278      std::vector<std::string> texts;
279      std::vector<int> box_pages;
280      if (ReadMemBoxes(page_number_, &bsol;*skip_blanks*/ false, box_text,
281                        true, &boxes, &texts, nullptr,
282                       &box_pages)) {
283        AddBoxes(boxes, texts, box_pages);
284        return true;
285      } else {
286        tprintf("Error: No boxes for page %d from image %s!\n", page_number_,
287                imagefilename_.c_str());
288      }
289    }
290    return false;
291  }
292  DocumentData::DocumentData(const std::string &name)
293      : document_name_(name),
294        pages_offset_(-1),
295        total_pages_(-1),
296        memory_used_(0),
297        max_memory_(0),
298        reader_(nullptr) {}
299  DocumentData::~DocumentData() {
300    if (thread.joinable()) {
301      thread.join();
302    }
303    std::lock_guard<std::mutex> lock_p(pages_mutex_);
304    std::lock_guard<std::mutex> lock_g(general_mutex_);
305    for (auto data : pages_) {
306      delete data;
307    }
308  }
309  bool DocumentData::LoadDocument(const char *filename, int start_page,
310                                  int64_t max_memory, FileReader reader) {
311    SetDocument(filename, max_memory, reader);
312    pages_offset_ = start_page;
313    return ReCachePages();
314  }
315  void DocumentData::SetDocument(const char *filename, int64_t max_memory,
316                                 FileReader reader) {
317    std::lock_guard<std::mutex> lock_p(pages_mutex_);
318    std::lock_guard<std::mutex> lock(general_mutex_);
319    document_name_ = filename;
320    pages_offset_ = -1;
321    max_memory_ = max_memory;
322    reader_ = reader;
323  }
324  bool DocumentData::SaveDocument(const char *filename, FileWriter writer) {
325    std::lock_guard<std::mutex> lock(pages_mutex_);
326    TFile fp;
327    fp.OpenWrite(nullptr);
328    if (!fp.Serialize(pages_) || !fp.CloseWrite(filename, writer)) {
329      tprintf("Serialize failed: %s\n", filename);
330      return false;
331    }
332    return true;
333  }
334  void DocumentData::AddPageToDocument(ImageData *page) {
335    std::lock_guard<std::mutex> lock(pages_mutex_);
336    pages_.push_back(page);
337    set_memory_used(memory_used() + page->MemoryUsed());
338  }
339  void DocumentData::LoadPageInBackground(int index) {
340    ImageData *page = nullptr;
341    if (IsPageAvailable(index, &page)) {
342      return;
343    }
344    {
345      std::lock_guard<std::mutex> lock(pages_mutex_);
346      if (pages_offset_ == index) {
347        return;
348      }
349      pages_offset_ = index;
350      for (auto page : pages_) {
351        delete page;
352      }
353      pages_.clear();
354    }
355    if (thread.joinable()) {
356      thread.join();
357    }
358    ReCachePages();
359  }
360  const ImageData *DocumentData::GetPage(int index) {
361    ImageData *page = nullptr;
362    while (!IsPageAvailable(index, &page)) {
363      pages_mutex_.lock();
364      bool needs_loading = pages_offset_ != index;
365      pages_mutex_.unlock();
366      if (needs_loading) {
367        LoadPageInBackground(index);
368      }
369      std::this_thread::yield();
370    }
371    return page;
372  }
373  bool DocumentData::IsPageAvailable(int index, ImageData **page) {
374    std::lock_guard<std::mutex> lock(pages_mutex_);
375    int num_pages = NumPages();
376    if (num_pages == 0 || index < 0) {
377      *page = nullptr; 
378      return true;
379    }
380    if (num_pages > 0) {
381      index = Modulo(index, num_pages);
382      if (pages_offset_ <= index &&
383          static_cast<unsigned>(index) < pages_offset_ + pages_.size()) {
384        *page = pages_[index - pages_offset_]; 
385        return true;
386      }
387    }
388    return false;
389  }
390  int64_t DocumentData::UnCache() {
391    std::lock_guard<std::mutex> lock(pages_mutex_);
392    int64_t memory_saved = memory_used();
393    for (auto page : pages_) {
394      delete page;
395    }
396    pages_.clear();
397    pages_offset_ = -1;
398    set_total_pages(-1);
399    set_memory_used(0);
400    tprintf("Unloaded document %s, saving %" PRId64 " memory\n",
401            document_name_.c_str(), memory_saved);
402    return memory_saved;
403  }
404  void DocumentData::Shuffle() {
405    TRand random;
406    random.set_seed(document_name_.c_str());
407    int num_pages = pages_.size();
408    for (int i = 0; i < num_pages; ++i) {
409      int src = random.IntRand() % num_pages;
410      int dest = random.IntRand() % num_pages;
411      std::swap(pages_[src], pages_[dest]);
412    }
413  }
414  bool DocumentData::ReCachePages() {
415    std::lock_guard<std::mutex> lock(pages_mutex_);
416    set_total_pages(0);
417    set_memory_used(0);
418    int loaded_pages = 0;
419    for (auto page : pages_) {
420      delete page;
421    }
422    pages_.clear();
423    TFile fp;
424    if (!fp.Open(document_name_.c_str(), reader_) ||
425        !fp.DeSerializeSize(&loaded_pages) || loaded_pages <= 0) {
426      tprintf("Deserialize header failed: %s\n", document_name_.c_str());
427      return false;
428    }
429    pages_offset_ %= loaded_pages;
430    int page;
431    for (page = 0; page < loaded_pages; ++page) {
432      uint8_t non_null;
433      if (!fp.DeSerialize(&non_null)) {
434        break;
435      }
436      if (page < pages_offset_ ||
437          (max_memory_ > 0 && memory_used() > max_memory_)) {
438        if (non_null && !ImageData::SkipDeSerialize(&fp)) {
439          break;
440        }
441      } else {
442        ImageData *image_data = nullptr;
443        if (non_null) {
444          image_data = new ImageData;
445          if (!image_data->DeSerialize(&fp)) {
446            delete image_data;
447            break;
448          }
449        }
450        pages_.push_back(image_data);
451        if (image_data->imagefilename().empty()) {
452          image_data->set_imagefilename(document_name_);
453          image_data->set_page_number(page);
454        }
455        set_memory_used(memory_used() + image_data->MemoryUsed());
456      }
457    }
458    if (page < loaded_pages) {
459      tprintf("Deserialize failed: %s read %d/%d lines\n", document_name_.c_str(),
460              page, loaded_pages);
461      for (auto page : pages_) {
462        delete page;
463      }
464      pages_.clear();
465    } else if (loaded_pages > 1) {
466      tprintf("Loaded %zu/%d lines (%d-%zu) of document %s\n", pages_.size(),
467              loaded_pages, pages_offset_ + 1, pages_offset_ + pages_.size(),
468              document_name_.c_str());
469    }
470    set_total_pages(loaded_pages);
471    return !pages_.empty();
472  }
473  DocumentCache::DocumentCache(int64_t max_memory) : max_memory_(max_memory) {}
474  DocumentCache::~DocumentCache() {
475    for (auto *document : documents_) {
476      delete document;
477    }
478  }
479  bool DocumentCache::LoadDocuments(const std::vector<std::string> &filenames,
480                                    CachingStrategy cache_strategy,
481                                    FileReader reader) {
482    cache_strategy_ = cache_strategy;
483    int64_t fair_share_memory = 0;
484    if (cache_strategy_ == CS_ROUND_ROBIN) {
485      fair_share_memory = max_memory_ / filenames.size();
486    }
487    for (const auto &filename : filenames) {
488      auto *document = new DocumentData(filename);
489      document->SetDocument(filename.c_str(), fair_share_memory, reader);
490      AddToCache(document);
491    }
492    if (!documents_.empty()) {
493      if (GetPageBySerial(0) != nullptr) {
494        return true;
495      }
496      tprintf("Load of page 0 failed!\n");
497    }
498    return false;
499  }
500  bool DocumentCache::AddToCache(DocumentData *data) {
501    documents_.push_back(data);
502    return true;
503  }
504  DocumentData *DocumentCache::FindDocument(
505      const std::string &document_name) const {
506    for (auto *document : documents_) {
507      if (document->document_name() == document_name) {
508        return document;
509      }
510    }
511    return nullptr;
512  }
513  int DocumentCache::TotalPages() {
514    if (cache_strategy_ == CS_SEQUENTIAL) {
515      if (num_pages_per_doc_ == 0) {
516        GetPageSequential(0);
517      }
518      return num_pages_per_doc_ * documents_.size();
519    }
520    int total_pages = 0;
521    for (auto *document : documents_) {
522      document->GetPage(0);
523      total_pages += document->NumPages();
524    }
525    return total_pages;
526  }
527  const ImageData *DocumentCache::GetPageRoundRobin(int serial) {
528    int num_docs = documents_.size();
529    int doc_index = serial % num_docs;
530    const ImageData *doc = documents_[doc_index]->GetPage(serial / num_docs);
531    for (int offset = 1; offset <= kMaxReadAhead && offset < num_docs; ++offset) {
532      doc_index = (serial + offset) % num_docs;
533      int page = (serial + offset) / num_docs;
534      documents_[doc_index]->LoadPageInBackground(page);
535    }
536    return doc;
537  }
538  const ImageData *DocumentCache::GetPageSequential(int serial) {
539    int num_docs = documents_.size();
540    ASSERT_HOST(num_docs > 0);
541    if (num_pages_per_doc_ == 0) {
542      documents_[0]->GetPage(0);
543      num_pages_per_doc_ = documents_[0]->NumPages();
544      if (num_pages_per_doc_ == 0) {
545        tprintf("First document cannot be empty!!\n");
546        ASSERT_HOST(num_pages_per_doc_ > 0);
547      }
548      if (serial / num_pages_per_doc_ % num_docs > 0) {
549        documents_[0]->UnCache();
550      }
551    }
552    int doc_index = serial / num_pages_per_doc_ % num_docs;
553    const ImageData *doc =
554        documents_[doc_index]->GetPage(serial % num_pages_per_doc_);
555    int64_t total_memory = 0;
556    for (auto *document : documents_) {
557      total_memory += document->memory_used();
558    }
559    if (total_memory >= max_memory_) {
560      int num_in_front = CountNeighbourDocs(doc_index, 1);
561      for (int offset = num_in_front - 2;
562           offset > 1 && total_memory >= max_memory_; --offset) {
563        int next_index = (doc_index + offset) % num_docs;
564        total_memory -= documents_[next_index]->UnCache();
565      }
566      int num_behind = CountNeighbourDocs(doc_index, -1);
567      for (int offset = num_behind; offset < 0 && total_memory >= max_memory_;
568           ++offset) {
569        int next_index = (doc_index + offset + num_docs) % num_docs;
570        total_memory -= documents_[next_index]->UnCache();
571      }
572    }
573    int next_index = (doc_index + 1) % num_docs;
574    if (!documents_[next_index]->IsCached() && total_memory < max_memory_) {
575      documents_[next_index]->LoadPageInBackground(0);
576    }
577    return doc;
578  }
579  int DocumentCache::CountNeighbourDocs(int index, int dir) {
580    int num_docs = documents_.size();
581    for (int offset = dir; abs(offset) < num_docs; offset += dir) {
582      int offset_index = (index + offset + num_docs) % num_docs;
583      if (!documents_[offset_index]->IsCached()) {
584        return offset - dir;
585      }
586    }
587    return num_docs;
588  }
589  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.cpp</h3>
            <pre><code>1  #include "shapetable.h"
2  #include "bitvector.h"
3  #include "fontinfo.h"
4  #include "intfeaturespace.h"
5  #include "unicharset.h"
6  #include "unicity_table.h"
7  #include <algorithm>
8  namespace tesseract {
9  int ShapeRating::FirstResultWithUnichar(const std::vector<ShapeRating> &results,
10                                          const ShapeTable &shape_table, UNICHAR_ID unichar_id) {
11    for (unsigned r = 0; r < results.size(); ++r) {
12      const auto shape_id = results[r].shape_id;
13      const Shape &shape = shape_table.GetShape(shape_id);
14      if (shape.ContainsUnichar(unichar_id)) {
15        return r;
16      }
17    }
18    return -1;
19  }
20  int UnicharRating::FirstResultWithUnichar(const std::vector<UnicharRating> &results,
21                                            UNICHAR_ID unichar_id) {
22    for (unsigned r = 0; r < results.size(); ++r) {
23      if (results[r].unichar_id == unichar_id) {
24        return r;
25      }
26    }
27    return -1;
28  }
29  bool UnicharAndFonts::Serialize(FILE *fp) const {
30    return tesseract::Serialize(fp, &unichar_id) && tesseract::Serialize(fp, font_ids);
31  }
32  bool UnicharAndFonts::DeSerialize(TFile *fp) {
33    return fp->DeSerialize(&unichar_id) && fp->DeSerialize(font_ids);
34  }
35  int UnicharAndFonts::SortByUnicharId(const void *v1, const void *v2) {
36    const auto *p1 = static_cast<const UnicharAndFonts *>(v1);
37    const auto *p2 = static_cast<const UnicharAndFonts *>(v2);
38    return p1->unichar_id - p2->unichar_id;
39  }
40  bool UnicharAndFonts::StdSortByUnicharId(const UnicharAndFonts &v1, const UnicharAndFonts &v2) {
41    return v1.unichar_id < v2.unichar_id;
42  }
43  bool Shape::Serialize(FILE *fp) const {
44    uint8_t sorted = unichars_sorted_;
45    return tesseract::Serialize(fp, &sorted) && tesseract::Serialize(fp, unichars_);
46  }
47  bool Shape::DeSerialize(TFile *fp) {
48    uint8_t sorted;
49    if (!fp->DeSerialize(&sorted)) {
50      return false;
51    }
52    unichars_sorted_ = sorted != 0;
53    return fp->DeSerialize(unichars_);
54  }
55  void Shape::AddToShape(int unichar_id, int font_id) {
56    for (auto &unichar : unichars_) {
57      if (unichar.unichar_id == unichar_id) {
58        std::vector<int> &font_list = unichar.font_ids;
59        for (int f : font_list) {
60          if (f == font_id) {
61            return; 
62          }
63        }
64        font_list.push_back(font_id);
65        return;
66      }
67    }
68    unichars_.emplace_back(unichar_id, font_id);
69    unichars_sorted_ = unichars_.size() <= 1;
70  }
71  void Shape::AddShape(const Shape &other) {
72    for (const auto &unichar : other.unichars_) {
73      for (unsigned f = 0; f < unichar.font_ids.size(); ++f) {
74        AddToShape(unichar.unichar_id, unichar.font_ids[f]);
75      }
76    }
77    unichars_sorted_ = unichars_.size() <= 1;
78  }
79  bool Shape::ContainsUnicharAndFont(int unichar_id, int font_id) const {
80    for (const auto &unichar : unichars_) {
81      if (unichar.unichar_id == unichar_id) {
82        auto &font_list = unichar.font_ids;
83        for (int f : font_list) {
84          if (f == font_id) {
85            return true;
86          }
87        }
88        return false;
89      }
90    }
91    return false;
92  }
93  bool Shape::ContainsUnichar(int unichar_id) const {
94    for (const auto &unichar : unichars_) {
95      if (unichar.unichar_id == unichar_id) {
96        return true;
97      }
98    }
99    return false;
100  }
101  bool Shape::ContainsFont(int font_id) const {
102    for (const auto &unichar : unichars_) {
103      auto &font_list = unichar.font_ids;
104      for (int f : font_list) {
105        if (f == font_id) {
106          return true;
107        }
108      }
109    }
110    return false;
111  }
112  bool Shape::ContainsFontProperties(const FontInfoTable &font_table, uint32_t properties) const {
113    for (const auto &unichar : unichars_) {
114      auto &font_list = unichar.font_ids;
115      for (int f : font_list) {
116        if (font_table.at(f).properties == properties) {
117          return true;
118        }
119      }
120    }
121    return false;
122  }
123  bool Shape::ContainsMultipleFontProperties(const FontInfoTable &font_table) const {
124    uint32_t properties = font_table.at(unichars_[0].font_ids[0]).properties;
125    for (const auto &unichar : unichars_) {
126      auto &font_list = unichar.font_ids;
127      for (int f : font_list) {
128        if (font_table.at(f).properties != properties) {
129          return true;
130        }
131      }
132    }
133    return false;
134  }
135  bool Shape::operator==(const Shape &other) const {
136    return IsSubsetOf(other) && other.IsSubsetOf(*this);
137  }
138  bool Shape::IsSubsetOf(const Shape &other) const {
139    for (const auto &unichar : unichars_) {
140      int unichar_id = unichar.unichar_id;
141      const std::vector<int> &font_list = unichar.font_ids;
142      for (int f : font_list) {
143        if (!other.ContainsUnicharAndFont(unichar_id, f)) {
144          return false;
145        }
146      }
147    }
148    return true;
149  }
150  bool Shape::IsEqualUnichars(Shape *other) {
151    if (unichars_.size() != other->unichars_.size()) {
152      return false;
153    }
154    if (!unichars_sorted_) {
155      SortUnichars();
156    }
157    if (!other->unichars_sorted_) {
158      other->SortUnichars();
159    }
160    for (unsigned c = 0; c < unichars_.size(); ++c) {
161      if (unichars_[c].unichar_id != other->unichars_[c].unichar_id) {
162        return false;
163      }
164    }
165    return true;
166  }
167  void Shape::SortUnichars() {
168    std::sort(unichars_.begin(), unichars_.end(), UnicharAndFonts::StdSortByUnicharId);
169    unichars_sorted_ = true;
170  }
171  ShapeTable::ShapeTable() : unicharset_(nullptr), num_fonts_(0) {}
172  ShapeTable::ShapeTable(const UNICHARSET &unicharset) : unicharset_(&unicharset), num_fonts_(0) {}
173  bool ShapeTable::Serialize(FILE *fp) const {
<span onclick='openModal()' class='match'>174    return tesseract::Serialize(fp, shape_table_);
175  }
176  bool ShapeTable::DeSerialize(TFile *fp) {
177    if (!fp->DeSerialize(shape_table_)) {
178      return false;
179    }
</span>180    num_fonts_ = 0;
181    return true;
182  }
183  int ShapeTable::NumFonts() const {
184    if (num_fonts_ <= 0) {
185      for (auto shape_id : shape_table_) {
186        const Shape &shape = *shape_id;
187        for (int c = 0; c < shape.size(); ++c) {
188          for (int font_id : shape[c].font_ids) {
189            if (font_id >= num_fonts_) {
190              num_fonts_ = font_id + 1;
191            }
192          }
193        }
194      }
195    }
196    return num_fonts_;
197  }
198  void ShapeTable::ReMapClassIds(const std::vector<int> &unicharset_map) {
199    for (auto shape : shape_table_) {
200      for (int c = 0; c < shape->size(); ++c) {
201        shape->SetUnicharId(c, unicharset_map[(*shape)[c].unichar_id]);
202      }
203    }
204  }
205  std::string ShapeTable::DebugStr(unsigned shape_id) const {
206    if (shape_id >= shape_table_.size()) {
207      return "INVALID_UNICHAR_ID";
208    }
209    const Shape &shape = GetShape(shape_id);
210    std::string result;
211    result += "Shape" + std::to_string(shape_id);
212    if (shape.size() > 100) {
213      result += " Num unichars=" + std::to_string(shape.size());
214      return result;
215    }
216    for (int c = 0; c < shape.size(); ++c) {
217      result += " c_id=" + std::to_string(shape[c].unichar_id);
218      result += "=";
219      result += unicharset_->id_to_unichar(shape[c].unichar_id);
220      if (shape.size() < 10) {
221        result += ", " + std::to_string(shape[c].font_ids.size());
222        result += " fonts =";
223        int num_fonts = shape[c].font_ids.size();
224        if (num_fonts > 10) {
225          result += " " + std::to_string(shape[c].font_ids[0]);
226          result += " ... " + std::to_string(shape[c].font_ids[num_fonts - 1]);
227        } else {
228          for (int f = 0; f < num_fonts; ++f) {
229            result += " " + std::to_string(shape[c].font_ids[f]);
230          }
231        }
232      }
233    }
234    return result;
235  }
236  std::string ShapeTable::SummaryStr() const {
237    int max_unichars = 0;
238    int num_multi_shapes = 0;
239    int num_master_shapes = 0;
240    for (unsigned s = 0; s < shape_table_.size(); ++s) {
241      if (MasterDestinationIndex(s) != s) {
242        continue;
243      }
244      ++num_master_shapes;
245      int shape_size = GetShape(s).size();
246      if (shape_size > 1) {
247        ++num_multi_shapes;
248      }
249      if (shape_size > max_unichars) {
250        max_unichars = shape_size;
251      }
252    }
253    std::string result;
254    result += "Number of shapes = " + std::to_string(num_master_shapes);
255    result += " max unichars = " + std::to_string(max_unichars);
256    result += " number with multiple unichars = " + std::to_string(num_multi_shapes);
257    return result;
258  }
259  unsigned ShapeTable::AddShape(int unichar_id, int font_id) {
260    auto index = shape_table_.size();
261    auto *shape = new Shape;
262    shape->AddToShape(unichar_id, font_id);
263    shape_table_.push_back(shape);
264    num_fonts_ = std::max(num_fonts_, font_id + 1);
265    return index;
266  }
267  unsigned ShapeTable::AddShape(const Shape &other) {
268    unsigned index;
269    for (index = 0; index < shape_table_.size() && !(other == *shape_table_[index]); ++index) {
270      continue;
271    }
272    if (index == shape_table_.size()) {
273      auto *shape = new Shape(other);
274      shape_table_.push_back(shape);
275    }
276    num_fonts_ = 0;
277    return index;
278  }
279  void ShapeTable::DeleteShape(unsigned shape_id) {
280    delete shape_table_[shape_id];
281    shape_table_.erase(shape_table_.begin() + shape_id);
282  }
283  void ShapeTable::AddToShape(unsigned shape_id, int unichar_id, int font_id) {
284    Shape &shape = *shape_table_[shape_id];
285    shape.AddToShape(unichar_id, font_id);
286    num_fonts_ = std::max(num_fonts_, font_id + 1);
287  }
288  void ShapeTable::AddShapeToShape(unsigned shape_id, const Shape &other) {
289    Shape &shape = *shape_table_[shape_id];
290    shape.AddShape(other);
291    num_fonts_ = 0;
292  }
293  int ShapeTable::FindShape(int unichar_id, int font_id) const {
294    for (unsigned s = 0; s < shape_table_.size(); ++s) {
295      const Shape &shape = GetShape(s);
296      for (int c = 0; c < shape.size(); ++c) {
297        if (shape[c].unichar_id == unichar_id) {
298          if (font_id < 0) {
299            return s; 
300          }
301          for (int f : shape[c].font_ids) {
302            if (f == font_id) {
303              return s;
304            }
305          }
306        }
307      }
308    }
309    return -1;
310  }
311  void ShapeTable::GetFirstUnicharAndFont(unsigned shape_id, int *unichar_id, int *font_id) const {
312    const UnicharAndFonts &unichar_and_fonts = (*shape_table_[shape_id])[0];
313    *unichar_id = unichar_and_fonts.unichar_id;
314    *font_id = unichar_and_fonts.font_ids[0];
315  }
316  int ShapeTable::BuildFromShape(const Shape &shape, const ShapeTable &master_shapes) {
317    BitVector shape_map(master_shapes.NumShapes());
318    for (int u_ind = 0; u_ind < shape.size(); ++u_ind) {
319      for (unsigned f_ind = 0; f_ind < shape[u_ind].font_ids.size(); ++f_ind) {
320        int c = shape[u_ind].unichar_id;
321        int f = shape[u_ind].font_ids[f_ind];
322        int master_id = master_shapes.FindShape(c, f);
323        if (master_id >= 0) {
324          shape_map.SetBit(master_id);
325        } else if (FindShape(c, f) < 0) {
326          AddShape(c, f);
327        }
328      }
329    }
330    int num_masters = 0;
331    for (unsigned s = 0; s < master_shapes.NumShapes(); ++s) {
332      if (shape_map[s]) {
333        AddShape(master_shapes.GetShape(s));
334        ++num_masters;
335      }
336    }
337    return num_masters;
338  }
339  bool ShapeTable::AlreadyMerged(unsigned shape_id1, unsigned shape_id2) const {
340    return MasterDestinationIndex(shape_id1) == MasterDestinationIndex(shape_id2);
341  }
342  bool ShapeTable::AnyMultipleUnichars() const {
343    auto num_shapes = NumShapes();
344    for (unsigned s1 = 0; s1 < num_shapes; ++s1) {
345      if (MasterDestinationIndex(s1) != s1) {
346        continue;
347      }
348      if (GetShape(s1).size() > 1) {
349        return true;
350      }
351    }
352    return false;
353  }
354  int ShapeTable::MaxNumUnichars() const {
355    int max_num_unichars = 0;
356    int num_shapes = NumShapes();
357    for (int s = 0; s < num_shapes; ++s) {
358      if (GetShape(s).size() > max_num_unichars) {
359        max_num_unichars = GetShape(s).size();
360      }
361    }
362    return max_num_unichars;
363  }
364  void ShapeTable::ForceFontMerges(unsigned start, unsigned end) {
365    for (unsigned s1 = start; s1 < end; ++s1) {
366      if (MasterDestinationIndex(s1) == s1 && GetShape(s1).size() == 1) {
367        int unichar_id = GetShape(s1)[0].unichar_id;
368        for (auto s2 = s1 + 1; s2 < end; ++s2) {
369          if (MasterDestinationIndex(s2) == s2 && GetShape(s2).size() == 1 &&
370              unichar_id == GetShape(s2)[0].unichar_id) {
371            MergeShapes(s1, s2);
372          }
373        }
374      }
375    }
376    ShapeTable compacted(*unicharset_);
377    compacted.AppendMasterShapes(*this, nullptr);
378    *this = compacted;
379  }
380  unsigned ShapeTable::MasterUnicharCount(unsigned shape_id) const {
381    int master_id = MasterDestinationIndex(shape_id);
382    return GetShape(master_id).size();
383  }
384  int ShapeTable::MasterFontCount(unsigned shape_id) const {
385    int master_id = MasterDestinationIndex(shape_id);
386    const Shape &shape = GetShape(master_id);
387    int font_count = 0;
388    for (int c = 0; c < shape.size(); ++c) {
389      font_count += shape[c].font_ids.size();
390    }
391    return font_count;
392  }
393  int ShapeTable::MergedUnicharCount(unsigned shape_id1, unsigned shape_id2) const {
394    int master_id1 = MasterDestinationIndex(shape_id1);
395    int master_id2 = MasterDestinationIndex(shape_id2);
396    Shape combined_shape(*shape_table_[master_id1]);
397    combined_shape.AddShape(*shape_table_[master_id2]);
398    return combined_shape.size();
399  }
400  void ShapeTable::MergeShapes(unsigned shape_id1, unsigned shape_id2) {
401    auto master_id1 = MasterDestinationIndex(shape_id1);
402    auto master_id2 = MasterDestinationIndex(shape_id2);
403    shape_table_[master_id2]->set_destination_index(master_id1);
404    shape_table_[master_id1]->AddShape(*shape_table_[master_id2]);
405  }
406  void ShapeTable::SwapShapes(unsigned shape_id1, unsigned shape_id2) {
407    Shape *tmp = shape_table_[shape_id1];
408    shape_table_[shape_id1] = shape_table_[shape_id2];
409    shape_table_[shape_id2] = tmp;
410  }
411  unsigned ShapeTable::MasterDestinationIndex(unsigned shape_id) const {
412    auto dest_id = shape_table_[shape_id]->destination_index();
413    if (static_cast<unsigned>(dest_id) == shape_id || dest_id < 0) {
414      return shape_id; 
415    }
416    auto master_id = shape_table_[dest_id]->destination_index();
417    if (master_id == dest_id || master_id < 0) {
418      return dest_id; 
419    }
420    master_id = MasterDestinationIndex(master_id);
421    return master_id;
422  }
423  bool ShapeTable::SubsetUnichar(unsigned shape_id1, unsigned shape_id2) const {
424    const Shape &shape1 = GetShape(shape_id1);
425    const Shape &shape2 = GetShape(shape_id2);
426    int c1, c2;
427    for (c1 = 0; c1 < shape1.size(); ++c1) {
428      int unichar_id1 = shape1[c1].unichar_id;
429      if (!shape2.ContainsUnichar(unichar_id1)) {
430        break;
431      }
432    }
433    for (c2 = 0; c2 < shape2.size(); ++c2) {
434      int unichar_id2 = shape2[c2].unichar_id;
435      if (!shape1.ContainsUnichar(unichar_id2)) {
436        break;
437      }
438    }
439    return c1 == shape1.size() || c2 == shape2.size();
440  }
441  bool ShapeTable::MergeSubsetUnichar(int merge_id1, int merge_id2, unsigned shape_id) const {
442    const Shape &merge1 = GetShape(merge_id1);
443    const Shape &merge2 = GetShape(merge_id2);
444    const Shape &shape = GetShape(shape_id);
445    int cm1, cm2, cs;
446    for (cs = 0; cs < shape.size(); ++cs) {
447      int unichar_id = shape[cs].unichar_id;
448      if (!merge1.ContainsUnichar(unichar_id) && !merge2.ContainsUnichar(unichar_id)) {
449        break; 
450      }
451    }
452    for (cm1 = 0; cm1 < merge1.size(); ++cm1) {
453      int unichar_id1 = merge1[cm1].unichar_id;
454      if (!shape.ContainsUnichar(unichar_id1)) {
455        break; 
456      }
457    }
458    for (cm2 = 0; cm2 < merge2.size(); ++cm2) {
459      int unichar_id2 = merge2[cm2].unichar_id;
460      if (!shape.ContainsUnichar(unichar_id2)) {
461        break; 
462      }
463    }
464    return cs == shape.size() || (cm1 == merge1.size() && cm2 == merge2.size());
465  }
466  bool ShapeTable::EqualUnichars(unsigned shape_id1, unsigned shape_id2) const {
467    const Shape &shape1 = GetShape(shape_id1);
468    const Shape &shape2 = GetShape(shape_id2);
469    for (int c1 = 0; c1 < shape1.size(); ++c1) {
470      int unichar_id1 = shape1[c1].unichar_id;
471      if (!shape2.ContainsUnichar(unichar_id1)) {
472        return false;
473      }
474    }
475    for (int c2 = 0; c2 < shape2.size(); ++c2) {
476      int unichar_id2 = shape2[c2].unichar_id;
477      if (!shape1.ContainsUnichar(unichar_id2)) {
478        return false;
479      }
480    }
481    return true;
482  }
483  bool ShapeTable::MergeEqualUnichars(int merge_id1, int merge_id2, unsigned shape_id) const {
484    const Shape &merge1 = GetShape(merge_id1);
485    const Shape &merge2 = GetShape(merge_id2);
486    const Shape &shape = GetShape(shape_id);
487    for (int cs = 0; cs < shape.size(); ++cs) {
488      int unichar_id = shape[cs].unichar_id;
489      if (!merge1.ContainsUnichar(unichar_id) && !merge2.ContainsUnichar(unichar_id)) {
490        return false; 
491      }
492    }
493    for (int cm1 = 0; cm1 < merge1.size(); ++cm1) {
494      int unichar_id1 = merge1[cm1].unichar_id;
495      if (!shape.ContainsUnichar(unichar_id1)) {
496        return false; 
497      }
498    }
499    for (int cm2 = 0; cm2 < merge2.size(); ++cm2) {
500      int unichar_id2 = merge2[cm2].unichar_id;
501      if (!shape.ContainsUnichar(unichar_id2)) {
502        return false; 
503      }
504    }
505    return true;
506  }
507  bool ShapeTable::CommonUnichars(unsigned shape_id1, unsigned shape_id2) const {
508    const Shape &shape1 = GetShape(shape_id1);
509    const Shape &shape2 = GetShape(shape_id2);
510    for (int c1 = 0; c1 < shape1.size(); ++c1) {
511      int unichar_id1 = shape1[c1].unichar_id;
512      if (shape2.ContainsUnichar(unichar_id1)) {
513        return true;
514      }
515    }
516    return false;
517  }
518  bool ShapeTable::CommonFont(unsigned shape_id1, unsigned shape_id2) const {
519    const Shape &shape1 = GetShape(shape_id1);
520    const Shape &shape2 = GetShape(shape_id2);
521    for (int c1 = 0; c1 < shape1.size(); ++c1) {
522      const std::vector<int> &font_list1 = shape1[c1].font_ids;
523      for (int f : font_list1) {
524        if (shape2.ContainsFont(f)) {
525          return true;
526        }
527      }
528    }
529    return false;
530  }
531  void ShapeTable::AppendMasterShapes(const ShapeTable &other, std::vector<int> *shape_map) {
532    if (shape_map != nullptr) {
533      shape_map->clear();
534      shape_map->resize(other.NumShapes(), -1);
535    }
536    for (unsigned s = 0; s < other.shape_table_.size(); ++s) {
537      if (other.shape_table_[s]->destination_index() < 0) {
538        int index = AddShape(*other.shape_table_[s]);
539        if (shape_map != nullptr) {
540          (*shape_map)[s] = index;
541        }
542      }
543    }
544  }
545  int ShapeTable::NumMasterShapes() const {
546    int num_shapes = 0;
547    for (auto s : shape_table_) {
548      if (s->destination_index() < 0) {
549        ++num_shapes;
550      }
551    }
552    return num_shapes;
553  }
554  void ShapeTable::AddShapeToResults(const ShapeRating &shape_rating, std::vector<int> *unichar_map,
555                                     std::vector<UnicharRating> *results) const {
556    if (shape_rating.joined) {
557      AddUnicharToResults(UNICHAR_JOINED, shape_rating.rating, unichar_map, results);
558    }
559    if (shape_rating.broken) {
560      AddUnicharToResults(UNICHAR_BROKEN, shape_rating.rating, unichar_map, results);
561    }
562    const Shape &shape = GetShape(shape_rating.shape_id);
563    for (int u = 0; u < shape.size(); ++u) {
564      int result_index =
565          AddUnicharToResults(shape[u].unichar_id, shape_rating.rating, unichar_map, results);
566      for (int font_id : shape[u].font_ids) {
567        (*results)[result_index].fonts.emplace_back(font_id,
568                                                    IntCastRounded(shape_rating.rating * INT16_MAX));
569      }
570    }
571  }
572  int ShapeTable::AddUnicharToResults(int unichar_id, float rating, std::vector<int> *unichar_map,
573                                      std::vector<UnicharRating> *results) const {
574    int result_index = unichar_map->at(unichar_id);
575    if (result_index < 0) {
576      UnicharRating result(unichar_id, rating);
577      result_index = results->size();
578      results->push_back(result);
579      (*unichar_map)[unichar_id] = result_index;
580    }
581    return result_index;
582  }
583  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-imagedata.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-shapetable.cpp</div>
                </div>
                <div class="column column_space"><pre><code>72    return fp->Serialize(&vertical);
73  }
74  bool ImageData::DeSerialize(TFile *fp) {
75    if (!fp->DeSerialize(imagefilename_)) {
76      return false;
77    }
</pre></code></div>
                <div class="column column_space"><pre><code>174    return tesseract::Serialize(fp, shape_table_);
175  }
176  bool ShapeTable::DeSerialize(TFile *fp) {
177    if (!fp->DeSerialize(shape_table_)) {
178      return false;
179    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    