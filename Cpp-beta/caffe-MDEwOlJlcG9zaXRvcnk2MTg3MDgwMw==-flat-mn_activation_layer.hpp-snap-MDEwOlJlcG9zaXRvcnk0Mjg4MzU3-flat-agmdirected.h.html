
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.254355400696863%, Tokens: 67, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mn_activation_layer.hpp</h3>
            <pre><code>1  #ifndef CAFFE_MN_ACTIVATION_LAYER_HPP_
2  #define CAFFE_MN_ACTIVATION_LAYER_HPP_
3  #ifdef USE_MLSL
4  #include <vector>
5  #include "caffe/blob.hpp"
6  #include "caffe/layer.hpp"
7  #include "caffe/proto/caffe.pb.h"
8  namespace caffe {
9  template <typename Dtype>
10  class MnActivationLayer : public Layer<Dtype> {
11   public:
12    explicit MnActivationLayer(const LayerParameter& param)
13      : Layer<Dtype>(param) {}
14    virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,
15        const vector<Blob<Dtype>*>& top);
16    virtual void Reshape(const vector<Blob<Dtype>*>& bottom,
17        const vector<Blob<Dtype>*>& top);
18    virtual inline const char* type() const { return "MnActivation"; }
19    virtual inline int MinBottomBlobs() const { return 1; }
20    virtual inline int ExactNumTopBlobs() const { return 1; }
21   protected:
<span onclick='openModal()' class='match'>22    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
23        const vector<Blob<Dtype>*>& top);
24    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
25        const vector<Blob<Dtype>*>& top);
26    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
27        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
28    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
29        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
30    virtual bool Bypass(const vector<Blob<Dtype>*>& bottom,
31        const vector<Blob<Dtype>*>& top);
32   private:
33    void Pack(const Dtype *src, Dtype *dst, int N, int C, int HW, int numC);
34    void Unpack(const Dtype *src, int N, int C, int HW, int numC, Dtype *dst);
</span>35    bool Backward_cpu_fast(const vector<Blob<Dtype>*>& top,
36        const vector<Blob<Dtype>*>& bottom);
37    int num_nodes_in_;
38    int num_nodes_out_;
39    int model_parts_in_;
40    int model_parts_out_;
41    int data_parts_in_;
42    int data_parts_out_;
43    mn::Distribution *distrib_in_;
44    mn::Distribution *distrib_out_;
45    shared_ptr<mn::Distribution> distrib_data_in_out_;
46    Blob<Dtype> top_reduce_buf_;
47    Blob<Dtype> bottom_gather_buf_;
48    Blob<Dtype> bottom_gather_work_buf_;
49  };
50  }  
51  #endif
52  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmdirected.h</h3>
            <pre><code>1  #ifndef yanglib_agmdirected_h
2  #define yanglib_agmdirected_h
3  #include "Snap.h"
4  #include "agm.h"
5  #include "agmfast.h"
6  class TCoda { 
7  private:
8    PNGraph G; 
9    TVec<TIntFltH> F; 
10    TVec<TIntFltH> H; 
11    TRnd Rnd; 
12    TIntV NIDV; 
13    TFlt RegCoef; 
14    TFltV SumFV; 
15    TFltV SumHV; 
16    TBool NodesOk; 
17    TInt NumComs; 
18    TVec<TIntSet> HOVIDSV; 
19  public:
20    TFlt MinVal; 
21    TFlt MaxVal; 
22    TFlt NegWgt; 
23    TFlt PNoCom; 
24    TBool DoParallel; 
25    TCoda(const PNGraph& GraphPt, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
26      NodesOk(true), MinVal(0.0), MaxVal(1000.0), NegWgt(1.0) { SetGraph(GraphPt); RandomInit(InitComs); }
27    TCoda() { G = TNGraph::New(); }
28    void SetGraph(const PNGraph& GraphPt);
29    PNGraph GetGraph() { return G; }
30    PNGraph GetGraphRawNID();
31    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
32    double GetRegCoef() { return RegCoef; }
33    void RandomInit(const int InitComs);
34    int GetNumComs() { return NumComs.Val; }
35    void NeighborComInit(const int InitComs);
36    void NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs);
37    void SetCmtyVV(const TVec<TIntV>& CmtyVVOut, const TVec<TIntV>& CmtyVVIn);
38    double Likelihood(const bool DoParallel = false);
39    double LikelihoodForNode(const bool IsRow, const int UID);
40    double LikelihoodForNode(const bool IsRow, const int UID, const TIntFltH& FU);
41    void GetNonEdgePairScores(TFltIntIntTrV& ScoreV);
42    void GetNIDValH(TIntFltH& NIdValInOutH, TIntFltH& NIdValOutH, TIntFltH& NIdValInH, const int CID, const double Thres);
43    void DumpMemberships(const TStr& OutFNm, const TStrHash<TInt>& NodeNameH) { DumpMemberships(OutFNm, NodeNameH, sqrt(PNoCom)); }
44    void DumpMemberships(const TStr& OutFNm, const TStrHash<TInt>& NodeNameH, const double Thres);
45    void GetCmtyS(TIntSet& CmtySOut, TIntSet& CmtySIn, const int CID, const double Thres);
46    void DumpMemberships(const TStr& OutFNm, const double Thres);
47    void DumpMemberships(const TStr& OutFNm) { DumpMemberships(OutFNm, sqrt(PNoCom)); }
48    void GetCommunity(TIntV& CmtyVIn, TIntV& CmtyVOut, const int CID) { GetCommunity(CmtyVIn, CmtyVOut, CID, sqrt(PNoCom)); }
49    void GetCommunity(TIntV& CmtyVIn, TIntV& CmtyVOut, const int CID, const double Thres);
50    void GetTopCIDs(TIntV& CIdV, const int TopK, const int IsAverage = 1, const int MinSz = 1);
51    void GradientForNode(const bool IsRow, const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
52    void SetHoldOut(const double HOFrac) { TVec<TIntSet> HoldOut; TAGMFastUtil::GenHoldOutPairs(G, HoldOut, HOFrac, Rnd); HOVIDSV = HoldOut; }
53    void GetCmtyVV(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn, const int MinSz = 3);
54    void GetCmtyVV(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn, const double ThresOut, const double ThresIn, const int MinSz = 3);
55    void GetCmtyVV(const bool IsOut, TVec<TIntV>& CmtyVV);
56    void GetCmtyVV(const bool IsOut, TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
57    void GetCmtyVVUnSorted(const bool IsOut, TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
58    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVVOut, TVec<TIntV>& CmtyVVIn);
<span onclick='openModal()' class='match'>59    int FindComsByCV(TIntV& ComsV, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const int EdgesForCV = 100, const double StepAlpha = 0.3, const double StepBeta = 0.1);
60    int FindComsByCV(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const int EdgesForCV = 100, const double StepAlpha = 0.3, const double StepBeta = 0.3);
61    double LikelihoodHoldOut(const bool DoParallel = false);
62    double GetStepSizeByLineSearch(const bool IsRow, const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
63    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
64    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
</span>65    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
66      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
67      if (ChunkSize == 0) { ChunkSize = 1; }
68      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
69    }
70    void Save(TSOut& SOut);
71    void Load(TSIn& SIn, const int& RndSeed = 0);
72    TFlt& GetSumVal(const bool IsOut, const int CID) { 
73      if (IsOut) {
74        return SumFV[CID];
75      } else {
76        return SumHV[CID];
77      }
78    }
79    double inline GetCom(const bool IsOut, const int& NID, const int& CID) {
80      if (IsOut) {
81        return GetComOut(NID, CID);
82      } else {
83        return GetComIn(NID, CID);
84      }
85    }
86    double inline GetComOut(const int& NID, const int& CID) {
87      if (F[NID].IsKey(CID)) {
88        return F[NID].GetDat(CID);
89      } else {
90        return 0.0;
91      }
92    }
93    double inline GetComIn(const int& NID, const int& CID) {
94      if (H[NID].IsKey(CID)) {
95        return H[NID].GetDat(CID);
96      } else {
97        return 0.0;
98      }
99    }
100    void inline AddCom(const bool IsOut, const int& NID, const int& CID, const double& Val) {
101      if (IsOut) {
102        AddComOut(NID, CID, Val);
103      } else {
104        AddComIn(NID, CID, Val);
105      }
106    }
107    void inline AddComOut(const int& NID, const int& CID, const double& Val) {
108      if (F[NID].IsKey(CID)) {
109        SumFV[CID] -= F[NID].GetDat(CID);
110      }
111      F[NID].AddDat(CID) = Val;
112      SumFV[CID] += Val;
113    }
114    void inline AddComIn(const int& NID, const int& CID, const double& Val) {
115      if (H[NID].IsKey(CID)) {
116        SumHV[CID] -= H[NID].GetDat(CID);
117      }
118      H[NID].AddDat(CID) = Val;
119      SumHV[CID] += Val;
120    }
121    void inline DelCom(const bool IsOut, const int& NID, const int& CID) {
122      if (IsOut) {
123        return DelComOut(NID, CID);
124      } else {
125        return DelComIn(NID, CID);
126      }
127    }
128    void inline DelComOut(const int& NID, const int& CID) {
129      if (F[NID].IsKey(CID)) {
130        SumFV[CID] -= F[NID].GetDat(CID);
131        F[NID].DelKey(CID);
132      }
133    }
134    void inline DelComIn(const int& NID, const int& CID) {
135      if (H[NID].IsKey(CID)) {
136        SumHV[CID] -= H[NID].GetDat(CID);
137        H[NID].DelKey(CID);
138      }
139    }
140    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
141      double DP = 0;
142      if (UV.Len() > VV.Len()) {
143        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
144          if (VV.IsKey(HI.GetKey())) { 
145            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
146          }
147        }
148      } else {
149        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
150          if (UV.IsKey(HI.GetKey())) { 
151            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
152          }
153        }
154      }
155      return DP;
156    }
157    double inline DotProductUtoV(const int& UID, const int& VID) {
158      return DotProduct(F[UID], H[VID]);
159    }
160    double inline Prediction(const TIntFltH& FU, const TIntFltH& HV) {
161      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, HV);
162      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
163      return exp(- DP);
164    }
165    double inline Prediction(const int& UID, const int& VID) {
166      return Prediction(F[UID], H[VID]);
167    }
168    double inline Sum(const TIntFltH& UV) {
169      double N = 0.0;
170      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
171        N += HI.GetDat();
172      }
173      return N;
174    }
175    double inline Norm2(const TIntFltH& UV) {
176      double N = 0.0;
177      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
178        N += HI.GetDat() * HI.GetDat();
179      }
180      return N;
181    }
182  };
183  class TCodaAnalyzer {
184  public:
185    PNGraph G;
186    TVec<TIntFltH> InCmtyValHV;
187    TVec<TIntFltH> OutCmtyValHV;
188    TVec<TIntFltH> InOutCmtyValHV;
189    TCodaAnalyzer() { G = TNGraph::New(); }
190    TCodaAnalyzer(TCoda& Coda, const double MemThres = -1.0) {
191      G = Coda.GetGraphRawNID();
192      printf("graph copied (%d nodes %d edges)\n", G->GetNodes(), G->GetEdges());
193      TIntV CIdV;
194      Coda.GetTopCIDs(CIdV, Coda.GetNumComs());
195      double Delta = MemThres == -1.0 ? sqrt(Coda.PNoCom): MemThres;
196      for (int c = 0; c < CIdV.Len(); c++) {
197        int CID = CIdV[c];
198        TIntFltH InMemH, OutMemH, InOutMemH;
199        Coda.GetNIDValH(InOutMemH, OutMemH, InMemH, CID, Delta);
200        InCmtyValHV.Add(InMemH);
201        OutCmtyValHV.Add(OutMemH);
202        InOutCmtyValHV.Add(InOutMemH);
203      }
204      printf("Communities copied (%d communities)\n", InCmtyValHV.Len());
205    }
206    void GetAllCmtyVV(TVec<TIntV>& CmtyVV, const int MinSz) {
207      for (int c = 0; c < InCmtyValHV.Len(); c++) {
208        TIntV CmtyVIn, CmtyVOut, CmtyVInOut;
209        if (InCmtyValHV[c].Len() < MinSz || OutCmtyValHV[c].Len() < MinSz) { continue; }
210        InOutCmtyValHV[c].GetKeyV(CmtyVInOut);
211        InCmtyValHV[c].GetKeyV(CmtyVIn);
212        OutCmtyValHV[c].GetKeyV(CmtyVOut);
213        CmtyVV.Add(CmtyVInOut);
214        CmtyVV.Add(CmtyVOut);
215        CmtyVV.Add(CmtyVIn);
216      }
217    }
218    double GetFrac2Mode(const double Thres2Mode = 0.2, const int MinSzEach = 2) {
219      int Cnt2Mode = 0;
220      int CntAll = 0;
221      for (int c = 0; c < InCmtyValHV.Len(); c++) {
222        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
223        if (InCmtyValHV[c].Len() < MinSzEach || OutCmtyValHV[c].Len() < MinSzEach) { continue; }
224        if (Jacc <= Thres2Mode) { Cnt2Mode++; }
225        CntAll++;
226      }
227      return (double) Cnt2Mode / (double) CntAll;
228    }
229    void Summary(const int TopK = 10, const double Thres2Mode = 0.2) {
230      int Cnt2Mode = 0;
231      double SumJacc = 0.0;
232      for (int c = 0; c < InCmtyValHV.Len(); c++) {
233        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
234        if (Jacc <= Thres2Mode) { Cnt2Mode++; }
235        SumJacc += Jacc;
236        if (c < TopK) {
237          printf("Cmty %d: InOut: %d, In:%d, Out:%d, Jacc;%.3f\n", c, InCmtyValHV[c].Len(), InCmtyValHV[c].Len(), OutCmtyValHV[c].Len(), Jacc);
238        }
239      }
240      double AvgJacc = SumJacc / (double) InCmtyValHV.Len();
241      printf("Average jaccard similarity = %.3f. (%d / %d communities are 2-mode)\n", AvgJacc, Cnt2Mode, InCmtyValHV.Len());
242    }
243    int GetNumComs() { return InCmtyValHV.Len(); }
244    void GetCmtyVAll(TIntV& CmtyVAll, const int CID) {
245      TIntV CmtyVIn, CmtyVOut;
246      InCmtyValHV[CID].GetKeyV(CmtyVIn);
247      OutCmtyValHV[CID].GetKeyV(CmtyVOut);
248      CmtyVIn.Sort();
249      CmtyVOut.Sort();
250      CmtyVAll.Gen(CmtyVIn.Len() + CmtyVOut.Len(), 0);
251      CmtyVIn.Union(CmtyVOut, CmtyVAll);
252    }
253    PNGraph Net2ModeCommunities(const double MaxJac, const double JacEdge, const bool GetWcc = true) {
254      int Coms = InCmtyValHV.Len();
255      PNGraph ComG = TNGraph::New(Coms, -1);
256      for (int c = 0; c < InCmtyValHV.Len(); c++) {
257        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
258        if (Jacc > MaxJac) { continue; }
259        ComG->AddNode(c);
260      }
261      TVec<TIntSet> CmtySVIn, CmtySVOut;
262      for (int c = 0; c < Coms; c++) {
263        TIntV CmtyVIn, CmtyVOut;
264        InCmtyValHV[c].GetKeyV(CmtyVIn);
265        OutCmtyValHV[c].GetKeyV(CmtyVOut);
266        TIntSet CmtySIn(CmtyVIn), CmtySOut(CmtyVOut);
267        CmtySVIn.Add(CmtySIn);
268        CmtySVOut.Add(CmtySOut);
269      }
270      for (int c1 = 0; c1 < Coms; c1++) {
271        if (! ComG->IsNode(c1)) { continue; }
272        for (int c2 = 0; c2 < Coms; c2++) {
273          if (! ComG->IsNode(c2)) { continue; }
274          int IntC1C2 = TAGMUtil::Intersection(CmtySVIn[c1], CmtySVOut[c2]);
275          double Jac = (double) IntC1C2 / (CmtySVIn[c1].Len() + CmtySVOut[c2].Len() - IntC1C2);
276          if (Jac >= JacEdge) {
277            ComG->AddEdge(c1, c2);
278          }
279        }
280      }
281      TIntV NIDV;
282      ComG->GetNIdV(NIDV);
283      for (int u = 0; u < NIDV.Len(); u++) {
284        int NID = NIDV[u];
285        TNGraph::TNodeI NI = ComG->GetNI(NID);
286        if (NI.GetDeg() == 0) { ComG->DelNode(NID); }
287        if (NI.GetInDeg() == 1 && NI.GetOutDeg() == 1 && NI.GetOutNId(0) == NID) { ComG->DelNode(NID); }
288      }
289      printf("Community graph made (Jaccard similarity for edges: %f, %d nodes, %d edges)\n", JacEdge, ComG->GetNodes(), ComG->GetEdges());
290      return ComG;
291    }
292    void Dump2ModeCommunities(const TStr& OutFNm, const double MaxJac, const TIntStrH& NIDNameH) {
293      FILE* F = fopen(OutFNm.CStr(), "wt");
294      for (int c = 0; c < InCmtyValHV.Len(); c++) {
295        double Jacc = (double) InOutCmtyValHV[c].Len() / (double) (InCmtyValHV[c].Len() + OutCmtyValHV[c].Len() - InOutCmtyValHV[c].Len());
296        if (Jacc > MaxJac) { continue; }
297        TIntV CmtyVIn, CmtyVOut, CmtyVAll;
298        InCmtyValHV[c].GetKeyV(CmtyVIn);
299        OutCmtyValHV[c].GetKeyV(CmtyVOut);
300        GetCmtyVAll(CmtyVAll, c);
301        for (int u = 0; u < InOutCmtyValHV[c].Len(); u++) {
302          int UID = InOutCmtyValHV[c].GetKey(u);
303          if (CmtyVIn.Len() >= CmtyVOut.Len()) {
304            CmtyVIn.DelIfIn(UID); 
305          } else {
306            CmtyVOut.DelIfIn(UID); 
307          }
308        }
309        if (CmtyVAll.Len() == 0) { continue; }
310        fprintf(F, "Com %d\n", c);
311        for (int u = 0; u < CmtyVOut.Len(); u++) {
312          int NID = CmtyVOut[u];
313          TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): TStr::Fmt("Concept %d", NID);
314          fprintf(F, "%s:%f\n", Label.CStr(), OutCmtyValHV[c].GetDat(NID).Val);
315        }
316        fprintf(F, "||==>||\n");
317        for (int u = 0; u < CmtyVIn.Len(); u++) {
318          int NID = CmtyVIn[u];
319          TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): TStr::Fmt("Concept %d", NID);
320          fprintf(F, "%s:%f\n", Label.CStr(), InCmtyValHV[c].GetDat(NID).Val);
321        }
322        fprintf(F, "\n");
323      }
324      fclose(F);
325    }
326    void Draw2ModeCommunity(const int CID, const TStr& OutFNm, const TIntStrH& NIDNameH, const THash<TInt, TIntTr>& NIDColorH) {
327      TIntV CmtyVIn, CmtyVOut, CmtyVAll;
328      InCmtyValHV[CID].GetKeyV(CmtyVIn);
329      OutCmtyValHV[CID].GetKeyV(CmtyVOut);
330      GetCmtyVAll(CmtyVAll, CID);
331      for (int u = 0; u < InOutCmtyValHV[CID].Len(); u++) {
332        int UID = InOutCmtyValHV[CID].GetKey(u);
333        if (CmtyVIn.Len() >= CmtyVOut.Len()) {
334          CmtyVIn.DelIfIn(UID); 
335        } else {
336          CmtyVOut.DelIfIn(UID); 
337        }
338      }
339      PNGraph SG = TSnap::GetSubGraph(G, CmtyVAll);
340      if (CmtyVAll.Len() == 0) { return; }
341      double OXMin = 0.1, YMin = 0.1, OXMax = 2500.00, YMax = 1000.0, IXMin = 0.1, IXMax = 2500.00;
342      double OStep = (OXMax - OXMin) / (double) CmtyVOut.Len(), IStep = (IXMax - IXMin) / (double) CmtyVIn.Len();
343      FILE* F = fopen(OutFNm.CStr(), "wt");
344      fprintf(F, "<?xml version='1.0' encoding='UTF-8'?>\n");
345      fprintf(F, "<gexf xmlns='http:&bsol;&bsol;www.gexf.net/1.2draft' xmlns:viz='http:&bsol;&bsol;www.gexf.net/1.1draft/viz' xmlns:xsi='http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance' xsi:schemaLocation='http:&bsol;&bsol;www.gexf.net/1.2draft http:&bsol;&bsol;www.gexf.net/1.2draft/gexf.xsd' version='1.2'>\n");
346      fprintf(F, "\t<graph mode='static' defaultedgetype='directed'>\n");
347      fprintf(F, "\t\t<nodes>\n");
348      for (int c = 0; c < CmtyVOut.Len(); c++) {
349        int NID = CmtyVOut[c];
350        double XPos = c * OStep + OXMin;
351        TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): "";
352        Label.ChangeChAll('<', ' ');
353        Label.ChangeChAll('>', ' ');
354        Label.ChangeChAll('&', ' ');
355        Label.ChangeChAll('\'', ' ');
356        TIntTr Color = NIDColorH.IsKey(NID)? NIDColorH.GetDat(NID) : TIntTr(120, 120, 120);
357        fprintf(F, "\t\t\t<node id='%d' label='%s'>\n", NID, Label.CStr());
358        fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val);
359        fprintf(F, "\t\t\t\t<viz:size value='4.0'/>\n");
360        fprintf(F, "\t\t\t\t<viz:shape value='square'/>\n");
361        fprintf(F, "\t\t\t\t<viz:position x='%f' y='%f' z='0.0'/>\n", XPos, YMax); 
362        fprintf(F, "\t\t\t</node>\n");
363      }
364      for (int u = 0; u < CmtyVIn.Len(); u++) {
365        int NID = CmtyVIn[u];
366        TStr Label = NIDNameH.IsKey(NID)? NIDNameH.GetDat(NID): "";
367        Label.ChangeChAll('<', ' ');
368        Label.ChangeChAll('>', ' ');
369        Label.ChangeChAll('&', ' ');
370        Label.ChangeChAll('\'', ' ');
371        double XPos = IXMin + u * IStep;
372        TIntTr Color = NIDColorH.IsKey(NID)? NIDColorH.GetDat(NID) : TIntTr(120, 120, 120);
373        double Alpha = 1.0;
374        fprintf(F, "\t\t\t<node id='%d' label='%s'>\n", NID, Label.CStr());
375        fprintf(F, "\t\t\t\t<viz:color r='%d' g='%d' b='%d' a='%.1f'/>\n", Color.Val1.Val, Color.Val2.Val, Color.Val3.Val, Alpha);
376        fprintf(F, "\t\t\t\t<viz:size value='4.0'/>\n");
377        fprintf(F, "\t\t\t\t<viz:shape value='square'/>\n");
378        fprintf(F, "\t\t\t\t<viz:position x='%f' y='%f' z='0.0'/>\n", XPos, YMin); 
379        fprintf(F, "\t\t\t</node>\n");
380      }
381      fprintf(F, "\t\t</nodes>\n");
382      int EID = 0;
383      fprintf(F, "\t\t<edges>\n");
384      for (TNGraph::TNodeI NI = SG->BegNI(); NI < SG->EndNI(); NI++) {
385        if (NI.GetOutDeg() == 0 && NI.GetInDeg() == 0  ) { continue; }
386        for (int e = 0; e < NI.GetOutDeg(); e++) {
387          fprintf(F, "\t\t\t<edge id='%d' source='%d' target='%d'/>\n", EID++, NI.GetId(), NI.GetOutNId(e));
388        }
389      }
390      fprintf(F, "\t\t</edges>\n");
391      fprintf(F, "\t</graph>\n");
392      fprintf(F, "</gexf>\n");
393      fclose(F);
394    }
395  };
396  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mn_activation_layer.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmdirected.h</div>
                </div>
                <div class="column column_space"><pre><code>22    virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,
23        const vector<Blob<Dtype>*>& top);
24    virtual void Forward_gpu(const vector<Blob<Dtype>*>& bottom,
25        const vector<Blob<Dtype>*>& top);
26    virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,
27        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
28    virtual void Backward_gpu(const vector<Blob<Dtype>*>& top,
29        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom);
30    virtual bool Bypass(const vector<Blob<Dtype>*>& bottom,
31        const vector<Blob<Dtype>*>& top);
32   private:
33    void Pack(const Dtype *src, Dtype *dst, int N, int C, int HW, int numC);
34    void Unpack(const Dtype *src, int N, int C, int HW, int numC, Dtype *dst);
</pre></code></div>
                <div class="column column_space"><pre><code>59    int FindComsByCV(TIntV& ComsV, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const int EdgesForCV = 100, const double StepAlpha = 0.3, const double StepBeta = 0.1);
60    int FindComsByCV(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const int EdgesForCV = 100, const double StepAlpha = 0.3, const double StepBeta = 0.3);
61    double LikelihoodHoldOut(const bool DoParallel = false);
62    double GetStepSizeByLineSearch(const bool IsRow, const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
63    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
64    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    