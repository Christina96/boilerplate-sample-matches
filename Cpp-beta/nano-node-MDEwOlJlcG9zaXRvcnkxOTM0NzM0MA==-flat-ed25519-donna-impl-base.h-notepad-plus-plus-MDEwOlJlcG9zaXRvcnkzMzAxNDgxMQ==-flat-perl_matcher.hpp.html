
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.467005076142132%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ed25519-donna-impl-base.h</h3>
            <pre><code>1  DONNA_INLINE static void
2  ge25519_p1p1_to_partial(ge25519 *r, const ge25519_p1p1 *p) {
3  	curve25519_mul(r->x, p->x, p->t);
4  	curve25519_mul(r->y, p->y, p->z);
5  	curve25519_mul(r->z, p->z, p->t); 
6  }
7  DONNA_INLINE static void
8  ge25519_p1p1_to_full(ge25519 *r, const ge25519_p1p1 *p) {
9  	curve25519_mul(r->x, p->x, p->t);
10  	curve25519_mul(r->y, p->y, p->z);
11  	curve25519_mul(r->z, p->z, p->t); 
12  	curve25519_mul(r->t, p->x, p->y); 
13  }
14  static void
15  ge25519_full_to_pniels(ge25519_pniels *p, const ge25519 *r) {
16  	curve25519_sub(p->ysubx, r->y, r->x);
17  	curve25519_add(p->xaddy, r->y, r->x);
18  	curve25519_copy(p->z, r->z);
19  	curve25519_mul(p->t2d, r->t, ge25519_ec2d);
20  }
21  static void
22  ge25519_add_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519 *q) {
23  	bignum25519 a,b,c,d,t,u;
24  	curve25519_sub(a, p->y, p->x);
25  	curve25519_add(b, p->y, p->x);
26  	curve25519_sub(t, q->y, q->x);
27  	curve25519_add(u, q->y, q->x);
28  	curve25519_mul(a, a, t);
29  	curve25519_mul(b, b, u);
30  	curve25519_mul(c, p->t, q->t);
31  	curve25519_mul(c, c, ge25519_ec2d);
32  	curve25519_mul(d, p->z, q->z);
33  	curve25519_add(d, d, d);
34  	curve25519_sub(r->x, b, a);
35  	curve25519_add(r->y, b, a);
36  	curve25519_add_after_basic(r->z, d, c);
37  	curve25519_sub_after_basic(r->t, d, c);
38  }
39  static void
40  ge25519_double_p1p1(ge25519_p1p1 *r, const ge25519 *p) {
41  	bignum25519 a,b,c;
42  	curve25519_square(a, p->x);
43  	curve25519_square(b, p->y);
44  	curve25519_square(c, p->z);
45  	curve25519_add_reduce(c, c, c);
46  	curve25519_add(r->x, p->x, p->y);
47  	curve25519_square(r->x, r->x);
48  	curve25519_add(r->y, b, a);
49  	curve25519_sub(r->z, b, a);
50  	curve25519_sub_after_basic(r->x, r->x, r->y);
51  	curve25519_sub_after_basic(r->t, c, r->z);
52  }
53  static void
54  ge25519_nielsadd2_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519_niels *q, unsigned char signbit) {
55  	const bignum25519 *qb = (const bignum25519 *)q;
56  	bignum25519 *rb = (bignum25519 *)r;
57  	bignum25519 a,b,c;
58  	curve25519_sub(a, p->y, p->x);
59  	curve25519_add(b, p->y, p->x);
60  	curve25519_mul(a, a, qb[signbit]); &bsol;* x for +, y for - */
61  	curve25519_mul(r->x, b, qb[signbit^1]); &bsol;* y for +, x for - */
62  	curve25519_add(r->y, r->x, a);
63  	curve25519_sub(r->x, r->x, a);
64  	curve25519_mul(c, p->t, q->t2d);
65  	curve25519_add_reduce(r->t, p->z, p->z);
66  	curve25519_copy(r->z, r->t);
67  	curve25519_add(rb[2+signbit], rb[2+signbit], c); &bsol;* z for +, t for - */
68  	curve25519_sub(rb[2+(signbit^1)], rb[2+(signbit^1)], c); &bsol;* t for +, z for - */
69  }
70  static void
71  ge25519_pnielsadd_p1p1(ge25519_p1p1 *r, const ge25519 *p, const ge25519_pniels *q, unsigned char signbit) {
72  	const bignum25519 *qb = (const bignum25519 *)q;
73  	bignum25519 *rb = (bignum25519 *)r;
74  	bignum25519 a,b,c;
75  	curve25519_sub(a, p->y, p->x);
76  	curve25519_add(b, p->y, p->x);
77  	curve25519_mul(a, a, qb[signbit]); &bsol;* ysubx for +, xaddy for - */
78  	curve25519_mul(r->x, b, qb[signbit^1]); &bsol;* xaddy for +, ysubx for - */
79  	curve25519_add(r->y, r->x, a);
80  	curve25519_sub(r->x, r->x, a);
81  	curve25519_mul(c, p->t, q->t2d);
82  	curve25519_mul(r->t, p->z, q->z);
83  	curve25519_add_reduce(r->t, r->t, r->t);
84  	curve25519_copy(r->z, r->t);
85  	curve25519_add(rb[2+signbit], rb[2+signbit], c); &bsol;* z for +, t for - */
86  	curve25519_sub(rb[2+(signbit^1)], rb[2+(signbit^1)], c); &bsol;* t for +, z for - */
87  }
88  static void
89  ge25519_double_partial(ge25519 *r, const ge25519 *p) {
90  	ge25519_p1p1 t;
91  	ge25519_double_p1p1(&t, p);
92  	ge25519_p1p1_to_partial(r, &t);
93  }
94  static void
95  ge25519_double(ge25519 *r, const ge25519 *p) {
96  	ge25519_p1p1 t;
97  	ge25519_double_p1p1(&t, p);
98  	ge25519_p1p1_to_full(r, &t);
99  }
100  static void
101  ge25519_add(ge25519 *r, const ge25519 *p,  const ge25519 *q) {
102  	ge25519_p1p1 t;
103  	ge25519_add_p1p1(&t, p, q);
104  	ge25519_p1p1_to_full(r, &t);
105  }
106  static void
107  ge25519_nielsadd2(ge25519 *r, const ge25519_niels *q) {
108  	bignum25519 a,b,c,e,f,g,h;
109  	curve25519_sub(a, r->y, r->x);
110  	curve25519_add(b, r->y, r->x);
111  	curve25519_mul(a, a, q->ysubx);
112  	curve25519_mul(e, b, q->xaddy);
113  	curve25519_add(h, e, a);
114  	curve25519_sub(e, e, a);
115  	curve25519_mul(c, r->t, q->t2d);
116  	curve25519_add(f, r->z, r->z);
117  	curve25519_add_after_basic(g, f, c);
118  	curve25519_sub_after_basic(f, f, c);
119  	curve25519_mul(r->x, e, f);
120  	curve25519_mul(r->y, h, g);
121  	curve25519_mul(r->z, g, f);
122  	curve25519_mul(r->t, e, h);
123  }
124  static void
125  ge25519_pnielsadd(ge25519_pniels *r, const ge25519 *p, const ge25519_pniels *q) {
126  	bignum25519 a,b,c,x,y,z,t;
127  	curve25519_sub(a, p->y, p->x);
128  	curve25519_add(b, p->y, p->x);
129  	curve25519_mul(a, a, q->ysubx);
130  	curve25519_mul(x, b, q->xaddy);
131  	curve25519_add(y, x, a);
132  	curve25519_sub(x, x, a);
133  	curve25519_mul(c, p->t, q->t2d);
134  	curve25519_mul(t, p->z, q->z);
135  	curve25519_add(t, t, t);
136  	curve25519_add_after_basic(z, t, c);
137  	curve25519_sub_after_basic(t, t, c);
138  	curve25519_mul(r->xaddy, x, t);
139  	curve25519_mul(r->ysubx, y, z);
140  	curve25519_mul(r->z, z, t);
141  	curve25519_mul(r->t2d, x, y);
142  	curve25519_copy(y, r->ysubx);
143  	curve25519_sub(r->ysubx, r->ysubx, r->xaddy);
144  	curve25519_add(r->xaddy, r->xaddy, y);
145  	curve25519_mul(r->t2d, r->t2d, ge25519_ec2d);
146  }
147  static void
148  ge25519_pack(unsigned char r[32], const ge25519 *p) {
149  	bignum25519 tx, ty, zi;
150  	unsigned char parity[32];
151  	curve25519_recip(zi, p->z);
152  	curve25519_mul(tx, p->x, zi);
153  	curve25519_mul(ty, p->y, zi);
154  	curve25519_contract(r, ty);
155  	curve25519_contract(parity, tx);
156  	r[31] ^= ((parity[0] & 1) << 7);
157  }
158  static int
159  ge25519_unpack_negative_vartime(ge25519 *r, const unsigned char p[32]) {
160  	static const unsigned char zero[32] = {0};
161  	static const bignum25519 one = {1};
162  	unsigned char parity = p[31] >> 7;
163  	unsigned char check[32];
164  	bignum25519 t, root, num, den, d3;
165  	curve25519_expand(r->y, p);
166  	curve25519_copy(r->z, one);
167  	curve25519_square(num, r->y); &bsol;* x = y^2 */
168  	curve25519_mul(den, num, ge25519_ecd); &bsol;* den = dy^2 */
169  	curve25519_sub_reduce(num, num, r->z); &bsol;* x = y^1 - 1 */
170  	curve25519_add(den, den, r->z); &bsol;* den = dy^2 + 1 */
171  	curve25519_square(t, den);
172  	curve25519_mul(d3, t, den);
173  	curve25519_square(r->x, d3);
174  	curve25519_mul(r->x, r->x, den);
175  	curve25519_mul(r->x, r->x, num);
176  	curve25519_pow_two252m3(r->x, r->x);
177  	curve25519_mul(r->x, r->x, d3);
178  	curve25519_mul(r->x, r->x, num);
179  	curve25519_square(t, r->x);
180  	curve25519_mul(t, t, den);
181  	curve25519_sub_reduce(root, t, num);
182  	curve25519_contract(check, root);
183  	if (!ed25519_verify(check, zero, 32)) {
184  		curve25519_add_reduce(t, t, num);
185  		curve25519_contract(check, t);
186  		if (!ed25519_verify(check, zero, 32))
187  			return 0;
188  		curve25519_mul(r->x, r->x, ge25519_sqrtneg1);
189  	}
190  	curve25519_contract(check, r->x);
191  	if ((check[0] & 1) == parity) {
192  		curve25519_copy(t, r->x);
193  		curve25519_neg(r->x, t);
194  	}
195  	curve25519_mul(r->t, r->x, r->y);
196  	return 1;
197  }
198  #define S1_SWINDOWSIZE 5
199  #define S1_TABLE_SIZE (1<<(S1_SWINDOWSIZE-2))
200  #define S2_SWINDOWSIZE 7
201  #define S2_TABLE_SIZE (1<<(S2_SWINDOWSIZE-2))
202  static void 
<span onclick='openModal()' class='match'>203  ge25519_double_scalarmult_vartime(ge25519 *r, const ge25519 *p1, const bignum256modm s1, const bignum256modm s2) {
204  	signed char slide1[256], slide2[256];
205  	ge25519_pniels pre1[S1_TABLE_SIZE];
206  	ge25519 d1;
207  	ge25519_p1p1 t;
208  	int32_t i;
</span>209  	contract256_slidingwindow_modm(slide1, s1, S1_SWINDOWSIZE);
210  	contract256_slidingwindow_modm(slide2, s2, S2_SWINDOWSIZE);
211  	ge25519_double(&d1, p1);
212  	ge25519_full_to_pniels(pre1, p1);
213  	for (i = 0; i < S1_TABLE_SIZE - 1; i++)
214  		ge25519_pnielsadd(&pre1[i+1], &d1, &pre1[i]);
215  	memset(r, 0, sizeof(ge25519));
216  	r->y[0] = 1;
217  	r->z[0] = 1;
218  	i = 255;
219  	while ((i >= 0) && !(slide1[i] | slide2[i]))
220  		i--;
221  	for (; i >= 0; i--) {
222  		ge25519_double_p1p1(&t, r);
223  		if (slide1[i]) {
224  			ge25519_p1p1_to_full(r, &t);
225  			ge25519_pnielsadd_p1p1(&t, r, &pre1[abs(slide1[i]) / 2], (unsigned char)slide1[i] >> 7);
226  		}
227  		if (slide2[i]) {
228  			ge25519_p1p1_to_full(r, &t);
229  			ge25519_nielsadd2_p1p1(&t, r, &ge25519_niels_sliding_multiples[abs(slide2[i]) / 2], (unsigned char)slide2[i] >> 7);
230  		}
231  		ge25519_p1p1_to_partial(r, &t);
232  	}
233  }
234  #if !defined(HAVE_GE25519_SCALARMULT_BASE_CHOOSE_NIELS)
235  static uint32_t
236  ge25519_windowb_equal(uint32_t b, uint32_t c) {
237  	return ((b ^ c) - 1) >> 31;
238  }
239  static void
240  ge25519_scalarmult_base_choose_niels(ge25519_niels *t, const uint8_t table[256][96], uint32_t pos, signed char b) {
241  	bignum25519 neg;
242  	uint32_t sign = (uint32_t)((unsigned char)b >> 7);
243  	uint32_t mask = ~(sign - 1);
244  	uint32_t u = (b + mask) ^ mask;
245  	uint32_t i;
246  	uint8_t packed[96] = {0};
247  	packed[0] = 1;
248  	packed[32] = 1;
249  	for (i = 0; i < 8; i++)
250  		curve25519_move_conditional_bytes(packed, table[(pos * 8) + i], ge25519_windowb_equal(u, i + 1));
251  	curve25519_expand(t->ysubx, packed +  0);
252  	curve25519_expand(t->xaddy, packed + 32);
253  	curve25519_expand(t->t2d  , packed + 64);
254  	curve25519_swap_conditional(t->ysubx, t->xaddy, sign);
255  	curve25519_neg(neg, t->t2d);
256  	curve25519_swap_conditional(t->t2d, neg, sign);
257  }
258  #endif &bsol;* HAVE_GE25519_SCALARMULT_BASE_CHOOSE_NIELS */
259  static void
260  ge25519_scalarmult_base_niels(ge25519 *r, const uint8_t basepoint_table[256][96], const bignum256modm s) {
261  	signed char b[64];
262  	uint32_t i;
263  	ge25519_niels t;
264  	contract256_window4_modm(b, s);
265  	ge25519_scalarmult_base_choose_niels(&t, basepoint_table, 0, b[1]);
266  	curve25519_sub_reduce(r->x, t.xaddy, t.ysubx);
267  	curve25519_add_reduce(r->y, t.xaddy, t.ysubx);
268  	memset(r->z, 0, sizeof(bignum25519));
269  	curve25519_copy(r->t, t.t2d);
270  	r->z[0] = 2;	
271  	for (i = 3; i < 64; i += 2) {
272  		ge25519_scalarmult_base_choose_niels(&t, basepoint_table, i / 2, b[i]);
273  		ge25519_nielsadd2(r, &t);
274  	}
275  	ge25519_double_partial(r, r);
276  	ge25519_double_partial(r, r);
277  	ge25519_double_partial(r, r);
278  	ge25519_double(r, r);
279  	ge25519_scalarmult_base_choose_niels(&t, basepoint_table, 0, b[0]);
280  	curve25519_mul(t.t2d, t.t2d, ge25519_ecd);
281  	ge25519_nielsadd2(r, &t);
282  	for(i = 2; i < 64; i += 2) {
283  		ge25519_scalarmult_base_choose_niels(&t, basepoint_table, i / 2, b[i]);
284  		ge25519_nielsadd2(r, &t);
285  	}
286  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_MATCHER_HPP
2  #define BOOST_REGEX_MATCHER_HPP
3  #include <boost/regex/v5/iterator_category.hpp>
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #pragma warning(disable : 4251 4459)
7  #if BOOST_REGEX_MSVC < 1700
8  #     pragma warning(disable : 4231)
9  #endif
10  #  if BOOST_REGEX_MSVC < 1600
11  #     pragma warning(disable : 4660)
12  #  endif
13  #if BOOST_REGEX_MSVC < 1910
14  #pragma warning(disable:4800)
15  #endif
16  #endif
17  namespace boost{
18  namespace BOOST_REGEX_DETAIL_NS{
19  inline void  verify_options(boost::regex_constants::syntax_option_type, match_flag_type mf)
20  {
21     if ((mf & match_extra) && (mf & match_posix))
22     {
23        std::logic_error msg("Usage Error: Can't mix regular expression captures with POSIX matching rules");
24  #ifndef BOOST_REGEX_STANDALONE
25        throw_exception(msg);
26  #else
27        throw msg;
28  #endif
29     }
30  }
31  template <class charT>
32  inline bool can_start(charT c, const unsigned char* map, unsigned char mask)
33  {
34     return ((c < static_cast<charT>(0)) ? true : ((c >= static_cast<charT>(1 << CHAR_BIT)) ? true : map[c] & mask));
35  }
36  inline bool can_start(char c, const unsigned char* map, unsigned char mask)
37  {
38     return map[(unsigned char)c] & mask;
39  }
40  inline bool can_start(signed char c, const unsigned char* map, unsigned char mask)
41  {
42     return map[(unsigned char)c] & mask;
43  }
44  inline bool can_start(unsigned char c, const unsigned char* map, unsigned char mask)
45  {
46     return map[c] & mask;
47  }
48  inline bool can_start(unsigned short c, const unsigned char* map, unsigned char mask)
49  {
50     return ((c >= (1 << CHAR_BIT)) ? true : map[c] & mask);
51  }
52  #if defined(WCHAR_MIN) && (WCHAR_MIN == 0) && !defined(BOOST_NO_INTRINSIC_WCHAR_T)
53  inline bool can_start(wchar_t c, const unsigned char* map, unsigned char mask)
54  {
55     return ((c >= static_cast<wchar_t>(1u << CHAR_BIT)) ? true : map[c] & mask);
56  }
57  #endif
58  #if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
59  inline bool can_start(unsigned int c, const unsigned char* map, unsigned char mask)
60  {
61     return (((c >= static_cast<unsigned int>(1u << CHAR_BIT)) ? true : map[c] & mask));
62  }
63  #endif
64  template <class C, class T, class A>
65  inline int string_compare(const std::basic_string<C,T,A>& s, const C* p)
66  { 
67     if(0 == *p)
68     {
69        if(s.empty() || ((s.size() == 1) && (s[0] == 0)))
70           return 0;
71     }
72     return s.compare(p); 
73  }
74  template <class Seq, class C>
75  inline int string_compare(const Seq& s, const C* p)
76  {
77     std::size_t i = 0;
78     while((i < s.size()) && (p[i] == s[i]))
79     {
80        ++i;
81     }
82     return (i == s.size()) ? -(int)p[i] : (int)s[i] - (int)p[i];
83  }
84  # define STR_COMP(s,p) string_compare(s,p)
85  template<class charT>
86  inline const charT* re_skip_past_null(const charT* p)
87  {
88    while (*p != static_cast<charT>(0)) ++p;
89    return ++p;
90  }
91  template <class iterator, class charT, class traits_type, class char_classT>
92  iterator  re_is_set_member(iterator next, 
93                            iterator last, 
94                            const re_set_long<char_classT>* set_, 
95                            const regex_data<charT, traits_type>& e, bool icase)
96  {   
97     const charT* p = reinterpret_cast<const charT*>(set_+1);
98     iterator ptr;
99     unsigned int i;
100     if(next == last) return next;
101     typedef typename traits_type::string_type traits_string_type;
102     const ::boost::regex_traits_wrapper<traits_type>& traits_inst = *(e.m_ptraits);
103     (void)traits_inst;
104     for(i = 0; i < set_->csingles; ++i)
105     {
106        ptr = next;
107        if(*p == static_cast<charT>(0))
108        {
109           if(traits_inst.translate(*ptr, icase))
110           {
111              ++p;
112              continue;
113           }
114           return set_->isnot ? next : (ptr == next) ? ++next : ptr;
115        }
116        else
117        {
118           while(*p && (ptr != last))
119           {
120              if(traits_inst.translate(*ptr, icase) != *p)
121                 break;
122              ++p;
123              ++ptr;
124           }
125           if(*p == static_cast<charT>(0)) 
126              return set_->isnot ? next : (ptr == next) ? ++next : ptr;
127           p = re_skip_past_null(p);     
128        }
129     }
130     charT col = traits_inst.translate(*next, icase);
131     if(set_->cranges || set_->cequivalents)
132     {
133        traits_string_type s1;
134        if(set_->cranges)
135        {
136           if((e.m_flags & regex_constants::collate) == 0)
137              s1.assign(1, col);
138           else
139           {
140              charT a[2] = { col, charT(0), };
141              s1 = traits_inst.transform(a, a + 1);
142           }
143           for(i = 0; i < set_->cranges; ++i)
144           {
145              if(STR_COMP(s1, p) >= 0)
146              {
147                 do{ ++p; }while(*p);
148                 ++p;
149                 if(STR_COMP(s1, p) <= 0)
150                    return set_->isnot ? next : ++next;
151              }
152              else
153              {
154                 do{ ++p; }while(*p);
155                 ++p;
156              }
157              do{ ++p; }while(*p);
158              ++p;
159           }
160        }
161        if(set_->cequivalents)
162        {
163           charT a[2] = { col, charT(0), };
164           s1 = traits_inst.transform_primary(a, a +1);
165           for(i = 0; i < set_->cequivalents; ++i)
166           {
167              if(STR_COMP(s1, p) == 0)
168                 return set_->isnot ? next : ++next;
169              do{ ++p; }while(*p);
170              ++p;
171           }
172        }
173     }
174     if(traits_inst.isctype(col, set_->cclasses) == true)
175        return set_->isnot ? next : ++next;
176     if((set_->cnclasses != 0) && (traits_inst.isctype(col, set_->cnclasses) == false))
177        return set_->isnot ? next : ++next;
178     return set_->isnot ? ++next : next;
179  }
180  template <class BidiIterator>
181  class repeater_count
182  {
183     repeater_count** stack;
184     repeater_count* next;
185     int state_id;
186     std::size_t count;        
187     BidiIterator start_pos;   
188     repeater_count* unwind_until(int n, repeater_count* p, int current_recursion_id)
189     { 
190        while(p && (p->state_id != n))
191        {
192           if(-2 - current_recursion_id == p->state_id)
193              return 0;
194           p = p->next;
195           if(p && (p->state_id < 0))
196           {
197              p = unwind_until(p->state_id, p, current_recursion_id);
198              if(!p)
199                 return p;
200              p = p->next;
201           }
202        }
203        return p;
204     }
205  public:
206     repeater_count(repeater_count** s) : stack(s), next(0), state_id(-1), count(0), start_pos() {}
207     repeater_count(int i, repeater_count** s, BidiIterator start, int current_recursion_id)
208        : start_pos(start)
209     {
210        state_id = i;
211        stack = s;
212        next = *stack;
213        *stack = this;
214        if((state_id > next->state_id) && (next->state_id >= 0))
215           count = 0;
216        else
217        {
218           repeater_count* p = next;
219           p = unwind_until(state_id, p, current_recursion_id);
220           if(p)
221           {
222              count = p->count;
223              start_pos = p->start_pos;
224           }
225           else
226              count = 0;
227        }
228     }
229     ~repeater_count()
230     {
231        if(next)
232           *stack = next;
233     }
234     std::size_t get_count() { return count; }
235     int get_id() { return state_id; }
236     std::size_t operator++() { return ++count; }
237     bool check_null_repeat(const BidiIterator& pos, std::size_t max)
238     {
239        bool result = (count == 0) ? false : (pos == start_pos);
240        if(result)
241           count = max;
242        else
243           start_pos = pos;
244        return result;
245     }
246  };
247  struct saved_state;
248  enum saved_state_type
249  {
<span onclick='openModal()' class='match'>250     saved_type_end = 0,
251     saved_type_paren = 1,
252     saved_type_recurse = 2,
253     saved_type_assertion = 3,
254     saved_state_alt = 4,
255     saved_state_repeater_count = 5,
256     saved_state_extra_block = 6,
257     saved_state_greedy_single_repeat = 7,
258     saved_state_rep_slow_dot = 8,
259     saved_state_rep_fast_dot = 9,
</span>260     saved_state_rep_char = 10,
261     saved_state_rep_short_set = 11,
262     saved_state_rep_long_set = 12,
263     saved_state_non_greedy_long_repeat = 13, 
264     saved_state_count = 14
265  };
266  #ifdef BOOST_REGEX_MSVC
267  #  pragma warning(push)
268  #if BOOST_REGEX_MSVC >= 1800
269  #pragma warning(disable:26495)
270  #endif
271  #endif
272  template <class Results>
273  struct recursion_info
274  {
275     typedef typename Results::value_type value_type;
276     typedef typename value_type::iterator iterator;
277     int idx;
278     const re_syntax_base* preturn_address;
279     Results results;
280     repeater_count<iterator>* repeater_stack;
281     iterator location_of_start;
282  };
283  #ifdef BOOST_REGEX_MSVC
284  #  pragma warning(pop)
285  #endif
286  template <class BidiIterator, class Allocator, class traits>
287  class perl_matcher
288  {
289  public:
290     typedef typename traits::char_type char_type;
291     typedef perl_matcher<BidiIterator, Allocator, traits> self_type;
292     typedef bool (self_type::*matcher_proc_type)();
293     typedef std::size_t traits_size_type;
294     typedef typename is_byte<char_type>::width_type width_type;
295     typedef typename std::iterator_traits<BidiIterator>::difference_type difference_type;
296     typedef match_results<BidiIterator, Allocator> results_type;
297     perl_matcher(BidiIterator first, BidiIterator end, 
298        match_results<BidiIterator, Allocator>& what, 
299        const basic_regex<char_type, traits>& e,
300        match_flag_type f,
301        BidiIterator l_base)
302        :  m_result(what), base(first), last(end), 
303           position(first), backstop(l_base), re(e), traits_inst(e.get_traits()), 
304           m_independent(false), next_count(&rep_obj), rep_obj(&next_count)
305        , m_recursions(0)
306     {
307        construct_init(e, f);
308     }
309     bool match();
310     bool find();
311     void setf(match_flag_type f)
312     { m_match_flags |= f; }
313     void unsetf(match_flag_type f)
314     { m_match_flags &= ~f; }
315  private:
316     void construct_init(const basic_regex<char_type, traits>& e, match_flag_type f);
317     bool find_imp();
318     bool match_imp();
319     void estimate_max_state_count(std::random_access_iterator_tag*);
320     void estimate_max_state_count(void*);
321     bool match_prefix();
322     bool match_all_states();
323     bool match_startmark();
324     bool match_endmark();
325     bool match_literal();
326     bool match_start_line();
327     bool match_end_line();
328     bool match_wild();
329     bool match_match();
330     bool match_word_boundary();
331     bool match_within_word();
332     bool match_word_start();
333     bool match_word_end();
334     bool match_buffer_start();
335     bool match_buffer_end();
336     bool match_backref();
337     bool match_long_set();
338     bool match_set();
339     bool match_jump();
340     bool match_alt();
341     bool match_rep();
342     bool match_combining();
343     bool match_soft_buffer_end();
344     bool match_restart_continue();
345     bool match_long_set_repeat();
346     bool match_set_repeat();
347     bool match_char_repeat();
348     bool match_dot_repeat_fast();
349     bool match_dot_repeat_slow();
350     bool match_dot_repeat_dispatch()
351     {
352        return ::boost::is_random_access_iterator<BidiIterator>::value ? match_dot_repeat_fast() : match_dot_repeat_slow();
353     }
354     bool match_backstep();
355     bool match_assert_backref();
356     bool match_toggle_case();
357     bool match_recursion();
358     bool match_fail();
359     bool match_accept();
360     bool match_commit();
361     bool match_then();
362     bool skip_until_paren(int index, bool match = true);
363     bool find_restart_any();
364     bool find_restart_word();
365     bool find_restart_line();
366     bool find_restart_buf();
367     bool find_restart_lit();
368  private:
369     match_results<BidiIterator, Allocator>& m_result;
370     std::unique_ptr<match_results<BidiIterator, Allocator> > m_temp_match;
371     match_results<BidiIterator, Allocator>* m_presult;
372     BidiIterator base;
373     BidiIterator last; 
374     BidiIterator position;
375     BidiIterator restart;
376     BidiIterator search_base;
377     BidiIterator backstop;
378     const basic_regex<char_type, traits>& re;
379     const ::boost::regex_traits_wrapper<traits>& traits_inst;
380     const re_syntax_base* pstate;
381     match_flag_type m_match_flags;
382     std::ptrdiff_t state_count;
383     std::ptrdiff_t max_state_count;
384     bool icase;
385     bool m_has_partial_match;
386     bool m_has_found_match;
387     bool m_independent;
388     repeater_count<BidiIterator>* next_count;
389     repeater_count<BidiIterator> rep_obj;
390     typename traits::char_class_type m_word_mask;
391     unsigned char match_any_mask;
392     std::vector<recursion_info<results_type> > recursion_stack;
393     typedef bool (self_type::*unwind_proc_type)(bool);
394     void extend_stack();
395     bool unwind(bool);
396     bool unwind_end(bool);
397     bool unwind_paren(bool);
398     bool unwind_recursion_stopper(bool);
399     bool unwind_assertion(bool);
400     bool unwind_alt(bool);
401     bool unwind_repeater_counter(bool);
402     bool unwind_extra_block(bool);
403     bool unwind_greedy_single_repeat(bool);
404     bool unwind_slow_dot_repeat(bool);
405     bool unwind_fast_dot_repeat(bool);
406     bool unwind_char_repeat(bool);
407     bool unwind_short_set_repeat(bool);
408     bool unwind_long_set_repeat(bool);
409     bool unwind_non_greedy_repeat(bool);
410     bool unwind_recursion(bool);
411     bool unwind_recursion_pop(bool);
412     bool unwind_commit(bool);
413     bool unwind_then(bool);
414     bool unwind_case(bool);
415     void destroy_single_repeat();
416     void push_matched_paren(int index, const sub_match<BidiIterator>& sub);
417     void push_recursion_stopper();
418     void push_assertion(const re_syntax_base* ps, bool positive);
419     void push_alt(const re_syntax_base* ps);
420     void push_repeater_count(int i, repeater_count<BidiIterator>** s);
421     void push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id);
422     void push_non_greedy_repeat(const re_syntax_base* ps);
423     void push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2);
424     void push_recursion_pop();
425     void push_case_change(bool);
426     saved_state* m_stack_base;
427     saved_state* m_backup_state;
428     unsigned used_block_count;
429     bool m_recursive_result;
430     bool m_unwound_lookahead;
431     bool m_unwound_alt;
432     unsigned m_recursions;
433  #ifdef BOOST_REGEX_MSVC
434  #  pragma warning(push)
435  #if BOOST_REGEX_MSVC >= 1800
436  #pragma warning(disable:26495)
437  #endif
438  #endif
439     perl_matcher& operator=(const perl_matcher&)
440     {
441        return *this;
442     }
443     perl_matcher(const perl_matcher& that)
444        : m_result(that.m_result), re(that.re), traits_inst(that.traits_inst), rep_obj(0) {}
445  #ifdef BOOST_REGEX_MSVC
446  #  pragma warning(pop)
447  #endif
448  };
449  } 
450  #ifdef BOOST_REGEX_MSVC
451  #  pragma warning(pop)
452  #endif
453  } 
454  #include <boost/regex/v5/perl_matcher_non_recursive.hpp>
455  #include <boost/regex/v5/perl_matcher_common.hpp>
456  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ed25519-donna-impl-base.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher.hpp</div>
                </div>
                <div class="column column_space"><pre><code>203  ge25519_double_scalarmult_vartime(ge25519 *r, const ge25519 *p1, const bignum256modm s1, const bignum256modm s2) {
204  	signed char slide1[256], slide2[256];
205  	ge25519_pniels pre1[S1_TABLE_SIZE];
206  	ge25519 d1;
207  	ge25519_p1p1 t;
208  	int32_t i;
</pre></code></div>
                <div class="column column_space"><pre><code>250     saved_type_end = 0,
251     saved_type_paren = 1,
252     saved_type_recurse = 2,
253     saved_type_assertion = 3,
254     saved_state_alt = 4,
255     saved_state_repeater_count = 5,
256     saved_state_extra_block = 6,
257     saved_state_greedy_single_repeat = 7,
258     saved_state_rep_slow_dot = 8,
259     saved_state_rep_fast_dot = 9,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    