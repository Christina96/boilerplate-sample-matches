
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.396694214876034%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-skygrid.cpp</h3>
            <pre><code>1  #include "skygrid.h"
2  void TSkyGridBinDoc::SaveBinDocV(
3   const TStr& InXmlFPath, const TStr& OutBinFNm, const int& MxDocs){
4    printf("Processing SkyGrid-News-Xml files from '%s'...\n", InXmlFPath.CStr());
5    TFOut SOut(OutBinFNm);
6    TFFile FFile(InXmlFPath, true); TStr FNm;
7    int Docs=0; int DateDocs=0; uint64 PrevTm=0;
8    while (FFile.Next(FNm)){
9      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
10      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
11      PXmlTok ContentTok=XmlDoc->GetTagTok("item|content");
12      TStr SwIdStr=ContentTok->GetTagTok("swid")->GetArgVal("value");
13      TStr UrlStr=ContentTok->GetTagTok("url")->GetTokStr(false);
14      TStr TitleStr=ContentTok->GetTagTok("title")->GetTokStr(false);
15      TStr FetchedValStr=ContentTok->GetTagTok("fetched")->GetArgVal("value");
16      TXmlTokV EntityTokV; ContentTok->GetTagTokV("annotations|entity", EntityTokV);
17      TStr BodyStr=ContentTok->GetTagTok("body")->GetTokStr(false);
18      TStr DateStr=SwIdStr.GetSubStr(0, 7);
19      TStr YearStr=DateStr.GetSubStr(0, 3);
20      TStr MonthStr=DateStr.GetSubStr(4, 5);
21      TStr DayStr=DateStr.GetSubStr(6, 7);
22      TTm DateTm(YearStr.GetInt(), MonthStr.GetInt(), DayStr.GetInt());
23      uint64 Tm=TTm::GetMSecsFromTm(DateTm);
24      TStrIntH EntNmToFqH;
25      for (int EntityTokN=0; EntityTokN<EntityTokV.Len(); EntityTokN++){
26        PXmlTok EntityTok=EntityTokV[EntityTokN];
27        if (!EntityTok->IsTag("entity")){continue;}
28        TStr CanonicalNm=EntityTok->GetArgVal("canonical", "");
29        TStr TextStr=EntityTok->GetArgVal("text", "");
30        TStr TypeNm=EntityTok->GetArgVal("type", "");
31        TStr EntNm=CanonicalNm.Empty() ? TextStr : CanonicalNm;
32        EntNmToFqH.AddDat(EntNm)++;
33      }
34      TIntStrPrV FqEntNmPrV; EntNmToFqH.GetDatKeyPrV(FqEntNmPrV); FqEntNmPrV.Sort(false);
35      TChA HeadlineChA=BodyStr.GetSubStr(0, 250);
36      while ((HeadlineChA.Len()>0)&&(HeadlineChA.LastCh()!=' ')){
37        HeadlineChA.Trunc(HeadlineChA.Len()-1);}
38      HeadlineChA+="...";
39      TSkyGridBinDoc Doc(SwIdStr, Tm, TitleStr, HeadlineChA, FqEntNmPrV);
40      Doc.Save(SOut);
41      if (PrevTm!=Tm){
42        if (PrevTm!=0){printf("\n");}
43        PrevTm=Tm; DateDocs=0;
44      }
45      Docs++; DateDocs++;
46      printf("  %s [Day:%d / All:%d]\r", DateStr.CStr(), DateDocs, Docs);
47    }
48    printf("\nDone.\n");
49  }
50  void TSkyGridBinDoc::LoadBinDocV(const TStr& InBinFNm){
51    printf("Processing SkyGrid News-Binary file '%s'...\n", InBinFNm.CStr());
52    TFIn SIn(InBinFNm); int Docs=0;
53    while (!SIn.Eof()){
54      TSkyGridBinDoc Doc(SIn);
55      Docs++; printf("%d\r", Docs);
56    }
57    printf("\nDone.\n");
58  }
59  void TSkyGridEnt::GetDocIdV(const TSkyGridBs* SkyGridBs,
60   const uint64& MnTm, const uint64& MxTm, TIntV& DocIdV) const {
61    DocIdV.Gen(GetDocIds(), 0);
62    for (int DocN=0; DocN<GetDocIds(); DocN++){
63      int DocId=GetDocId(DocN);
64      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
65      uint64 DocTm=Doc->GetTm();
66      if (((MnTm==0)||(MnTm<=DocTm))&&((MxTm==0)||(DocTm<MxTm))){
67        DocIdV.Add(DocId);
68      }
69    }
70  }
71  void TSkyGridEnt::GetDocsPerDateV(
72   const TSkyGridBs* SkyGridBs, TStrIntPrV& DateStrDocsPrV, int& Docs) const {
73    TStrIntH DateStrToDocsH; Docs=0;
<span onclick='openModal()' class='match'>74    for (int DocN=0; DocN<GetDocIds(); DocN++){
75      int DocId=GetDocId(DocN);
76      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
77      uint64 DocTm=Doc->GetTm();
</span>78      TStr DocDateStr=TTm::GetTmFromMSecs(DocTm).GetWebLogDateStr();
79      DateStrToDocsH.AddDat(DocDateStr)++; Docs++;
80    }
81    DateStrToDocsH.GetKeyDatPrV(DateStrDocsPrV);
82    DateStrDocsPrV.Sort();
83  }
84  void TSkyGridEnt::GetDocCentroid(const TSkyGridBs* SkyGridBs,
85   const int& TopWords, const double& TopWordsWgtSumPrc,
86   TStrFltPrV& WordStrWgtPrV) const {
87    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
88    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
89    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NULL);
90    for (int DocN=0; DocN<GetDocIds(); DocN++){
91      int DocId=GetDocId(DocN);
92      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
93      TStr DocStr=Doc->GetHeadlineStr();
94      BowDocBs->AddHtmlDoc(TInt::GetStr(DocId), TStrV(), DocStr);
95    }
96    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
97    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
98    PBowSim BowSim=TBowSim::New(bstCos); 
99    TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
100    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, AllDIdV);
101    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, WordStrWgtPrV);
102  }
103  void TSkyGridEnt::GetDocCentroid(const TSkyGridBs* SkyGridBs,
104   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
105   const uint64& MnTm, const int& TopWords, const double& TopWordsWgtSumPrc,
106   int& Docs, TStrFltPrV& WordStrWgtPrV) const {
107    TIntV DocIdV; GetDocIdV(SkyGridBs, MnTm, 0, DocIdV);
108    TIntV BowDIdV(DocIdV.Len(), 0);
109    for (int DocN=0; DocN<DocIdV.Len(); DocN++){
110      int DocId=DocIdV[DocN];
111      TStr BowDocNm=TInt::GetStr(DocId);
112      int BowDId=BowDocBs->GetDId(BowDocNm);
113      BowDIdV.Add(BowDId);
114    }
115    PBowSim BowSim=TBowSim::New(bstCos); 
116    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, BowDIdV);
117    Docs=DocIdV.Len();
118    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, WordStrWgtPrV);
119  }
120  void TSkyGridEnt::GetEntClustV(const TSkyGridBs* SkyGridBs,
121   const uint64& MnTm, const int& MnDocs, const int& MxDocs, const int& Clusts,
122   TVec<TStrFltPrV>& EntNmWgtPrVV) const {
123    EntNmWgtPrVV.Clr();
124    PBowDocBs BowDocBs=TBowDocBs::New();
125    TIntV DocIdV; GetDocIdV(SkyGridBs, MnTm, 0, DocIdV);
126    DocIdV.Reverse(); DocIdV.Shuffle(TRnd(1)); DocIdV.Trunc(MxDocs);
127    if (DocIdV.Len()<MnDocs){return;}
128    for (int DocN=0; DocN<DocIdV.Len(); DocN++){
129      int DocId=DocIdV[DocN];
130      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
131      TIntFltPrV WIdWgtPrV;
132      for (int EntN=0; EntN<Doc->GetEnts(); EntN++){
133        int EntId; int EntFq; Doc->GetEntNmFq(EntN, EntId, EntFq);
134        TStr EntNm=SkyGridBs->GetEntNm(EntId);
135        int EntWId=BowDocBs->AddWordStr(EntNm);
136        WIdWgtPrV.Add(TIntFltPr(EntWId, EntFq));
137      }
138      int DId=BowDocBs->AddDoc(TInt::GetStr(DocId), TStrV(), WIdWgtPrV);
139      TStr DocDescStr=Doc->GetTitleStr();
140      BowDocBs->PutDocDescStr(DId, DocDescStr);
141    }
142    PBowSim BowSim=TBowSim::New(bstCos); 
143    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
144    PBowDocPart BowDocPart=TBowClust::GetKMeansPart(
145     TNotify::StdNotify, 
146     BowDocBs, 
147     BowSim, 
148     TRnd(1), 
149     Clusts, 
150     1, 
151     1, 
152     1, 
153     WordWgtType, 
154     0, 
155     0); 
156    EntNmWgtPrVV.Clr();
157    for (int ClustN=0; ClustN<BowDocPart->GetClusts(); ClustN++){
158      PBowDocPartClust Clust=BowDocPart->GetClust(ClustN);
159      TStrFltPrV WordStrWgtPrV;
160      Clust->GetTopWordStrWgtPrV(BowDocBs, 25, 0.5, WordStrWgtPrV);
161      EntNmWgtPrVV.Add(WordStrWgtPrV);
162    }
163  }
164  void TSkyGridEnt::GetSorted_LinkWgtDstEntIdPrV(
165   const uint64& MnTm, const double& TopWgtSumPrc, TIntPrV& LinkWgtDstEntIdPrV) const {
166    double AllLinkWgtSum=0;
167    TIntIntH DstEntIdLinkWgtH;
168    int LinkEnts=GetLinkEnts();
169    for (int LinkEntN=0; LinkEntN<LinkEnts; LinkEntN++){
170      int DstEntId=GetLinkEntId(LinkEntN);
171      int EntLinks=GetEntLinks(LinkEntN);
172      int EntLinkWgtSum=0;
173      for (int EntLinkN=0; EntLinkN<EntLinks; EntLinkN++){
174        const TSkyGridEntLinkCtx& EntLinkCtx=GetEntLinkCtx(LinkEntN, EntLinkN);
175        if (EntLinkCtx.Tm>=MnTm){
176          EntLinkWgtSum+=EntLinkCtx.LinkWgt;}
177      }
178      DstEntIdLinkWgtH.AddDat(DstEntId, EntLinkWgtSum);
179      AllLinkWgtSum+=EntLinkWgtSum;
180    }
181    LinkWgtDstEntIdPrV.Clr(); DstEntIdLinkWgtH.GetDatKeyPrV(LinkWgtDstEntIdPrV);
182    LinkWgtDstEntIdPrV.Sort(false);
183    if ((TopWgtSumPrc>0.0)&&(LinkWgtDstEntIdPrV.Len()>0)){
184      int TopLinkWgt=LinkWgtDstEntIdPrV[0].Val1;
185      if (TopLinkWgt>(3*AllLinkWgtSum)/LinkWgtDstEntIdPrV.Len()){
186        double CutWgtSum=AllLinkWgtSum*(1-TopWgtSumPrc);
187        int LastValN=LinkWgtDstEntIdPrV.Len()-1;
188        while ((LastValN>0)&&(CutWgtSum>0)){
189          CutWgtSum-=LinkWgtDstEntIdPrV[LastValN].Val1;
190          LastValN--;
191        }
192        LinkWgtDstEntIdPrV.Trunc(LastValN+1);
193      }
194    }
195  }
196  void TSkyGridBs::GetSorted_DocsEntIdPrV(TIntPrV& DocsEntIdPrV){
197    TIntIntH EntIdToDocsH;
198    for (int EntId=0; EntId<GetEnts(); EntId++){
199      int Docs=GetEnt(EntId).GetDocIds();
200      EntIdToDocsH.AddDat(EntId, Docs);
201    }
202    DocsEntIdPrV.Clr(); EntIdToDocsH.GetDatKeyPrV(DocsEntIdPrV);
203    DocsEntIdPrV.Sort(false);
204  }
205  int TSkyGridBs::AddDoc(
206   const TStr& SwIdStr, const uint64& Tm,
207   const TStr& TitleStr, const TStr& HeadlineStr,
208   const TIntStrPrV FqEntNmPrV){
209    TIntPrV EntIdFqPrV(FqEntNmPrV.Len(), 0);
210    for (int EntN=0; EntN<FqEntNmPrV.Len(); EntN++){
211      TStr EntNm=FqEntNmPrV[EntN].Val2;
212      int EntFq=FqEntNmPrV[EntN].Val1;
213      if (EntFq>=GetMnEntFqPerDoc()){
214        int EntId=AddEntNm(EntNm);
215        EntIdFqPrV.Add(TIntPr(EntId, EntFq));
216      }
217    }
218    if (EntIdFqPrV.Len()<GetMnEntsPerDoc()){
219      return -1;}
220    PSkyGridDoc Doc=
221     TSkyGridDoc::New(SwIdStr, Tm, TitleStr, HeadlineStr, EntIdFqPrV);
222    int DocId=GetNewDocId();
223    IdToDocH.AddDat(DocId, Doc);
224    for (int EntN=0; EntN<EntIdFqPrV.Len(); EntN++){
225      int EntId=EntIdFqPrV[EntN].Val1;
226      TSkyGridEnt& Ent=GetEnt(EntId);
227      Ent.PushDocId(DocId);
228    }
229    int EntLinkWgtSum=0;
230    for (int EntN1=0; EntN1<EntIdFqPrV.Len(); EntN1++){
231      int EntId1=EntIdFqPrV[EntN1].Val1;
232      TSkyGridEnt& Ent1=GetEnt(EntId1);
233      int EntWgt1=EntIdFqPrV[EntN1].Val2;
234      for (int EntN2=0; EntN2<EntIdFqPrV.Len(); EntN2++){
235        if (EntN1==EntN2){continue;}
236        int EntId2=EntIdFqPrV[EntN2].Val1;
237        int EntWgt2=EntIdFqPrV[EntN2].Val2;
238        int EntLinkWgt=EntWgt1*EntWgt2;
239        EntLinkWgtSum+=EntLinkWgt;
240        TSkyGridEntLinkCtx LinkCtx(EntLinkWgt, DocId, Tm);
241        Ent1.AddLink(EntId2, LinkCtx);
242      }
243    }
244    return DocId;
245  }
246  PBowDocBs TSkyGridBs::GetBowDocBs(
247   const int& MxNGramLen, const int& MnNGramFq) const {
248    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
249    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
250    PNGramBs NGramBs;
251    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
252      TStrV HtmlStrV;
253      TSkyGridIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV);
254      for (int DocN=0; DocN<IdDocPrV.Len(); DocN++){
255        PSkyGridDoc Doc=IdDocPrV[DocN].Val2;
256        TStr DocStr=Doc->GetHeadlineStr();
257        HtmlStrV.Add(DocStr);
258      }
259      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
260       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
261    }
262    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
263    TSkyGridIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV);
264    for (int DocN=0; DocN<IdDocPrV.Len(); DocN++){
265      int DocId=IdDocPrV[DocN].Val1;
266      PSkyGridDoc Doc=IdDocPrV[DocN].Val2;
267      TStr DocStr=Doc->GetHeadlineStr();
268      BowDocBs->AddHtmlDoc(TInt::GetStr(DocId), TStrV(), DocStr);
269    }
270    return BowDocBs;
271  }
272  PBowDocWgtBs TSkyGridBs::GetBowDocWgtBs(const PBowDocBs& BowDocBs) const {
273    TBowWordWgtType WordWgtType=bwwtNrmTFIDF;
274    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
275    return BowDocWgtBs;
276  }
277  void TSkyGridBs::GetWordStrWgtPrVDiff(
278   const TStrFltPrV& OldWordStrWgtPrV, const TStrFltPrV& NewWordStrWgtPrV,
279   TStrFltPrV& NegDiffWordStrWgtPrV, TStrFltPrV& PosDiffWordStrWgtPrV){
280    TStrFltH WordStrToWgtH;
281    for (int WordN=0; WordN<NewWordStrWgtPrV.Len(); WordN++){
282      TStr WStr=NewWordStrWgtPrV[WordN].Val1;
283      double WWgt=NewWordStrWgtPrV[WordN].Val2;
284      WordStrToWgtH.AddDat(WStr, WWgt);
285    }
286    for (int WordN=0; WordN<OldWordStrWgtPrV.Len(); WordN++){
287      TStr WStr=OldWordStrWgtPrV[WordN].Val1;
288      double WWgt=OldWordStrWgtPrV[WordN].Val2;
289      double CurWWgt=WordStrToWgtH.AddDat(WStr);
290      WordStrToWgtH.AddDat(WStr, CurWWgt-WWgt);
291    }
292    TFltStrPrV DiffWordWgtStrPrV; WordStrToWgtH.GetDatKeyPrV(DiffWordWgtStrPrV);
293    DiffWordWgtStrPrV.Sort(true);
294    NegDiffWordStrWgtPrV.Gen(DiffWordWgtStrPrV.Len(), 0);
295    for (int WordN=0; WordN<DiffWordWgtStrPrV.Len(); WordN++){
296      TStr WStr=DiffWordWgtStrPrV[WordN].Val2;
297      double WWgt=DiffWordWgtStrPrV[WordN].Val1;
298      if (WWgt!=0){NegDiffWordStrWgtPrV.Add(TStrFltPr(WStr, WWgt));}
299    }
300    DiffWordWgtStrPrV.Sort(false);
301    PosDiffWordStrWgtPrV.Gen(DiffWordWgtStrPrV.Len(), 0);
302    for (int WordN=0; WordN<DiffWordWgtStrPrV.Len(); WordN++){
303      TStr WStr=DiffWordWgtStrPrV[WordN].Val2;
304      double WWgt=DiffWordWgtStrPrV[WordN].Val1;
305      if (WWgt!=0){PosDiffWordStrWgtPrV.Add(TStrFltPr(WStr, WWgt));}
306    }
307  }
308  void TSkyGridBs::GetWordStrWgtPrVChA(
309   const TStrFltPrV& WordStrWgtPrV, TChA& WordStrWgtPrVChA){
310    WordStrWgtPrVChA.Clr();
311    for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
312      TStr WStr=WordStrWgtPrV[WordN].Val1;
313      double WWgt=WordStrWgtPrV[WordN].Val2;
314      if (WordN>0){WordStrWgtPrVChA+=' ';}
315      WordStrWgtPrVChA+=TStr::Fmt("['%s':%.3f]", WStr.CStr(), WWgt);
316    }
317  }
318  void TSkyGridBs::GetLinkWgtDstEntIdPrVDiff(
319   const TIntPrV& OldLinkWgtDstEntIdPrV, const TIntPrV& NewLinkWgtDstEntIdPrV,
320   TIntPrV& NegDiffLinkWgtDstEntIdPrV, TIntPrV& PosDiffLinkWgtDstEntIdPrV){
321    TIntIntH DstEntIdToLinkWgtH;
322    for (int WordN=0; WordN<NewLinkWgtDstEntIdPrV.Len(); WordN++){
323      int LinkWgt=NewLinkWgtDstEntIdPrV[WordN].Val1;
324      int DstEntId=NewLinkWgtDstEntIdPrV[WordN].Val2;
325      DstEntIdToLinkWgtH.AddDat(DstEntId, LinkWgt);
326    }
327    for (int WordN=0; WordN<OldLinkWgtDstEntIdPrV.Len(); WordN++){
328      int LinkWgt=OldLinkWgtDstEntIdPrV[WordN].Val1;
329      int DstEntId=OldLinkWgtDstEntIdPrV[WordN].Val2;
330      int CurLinkWgt=DstEntIdToLinkWgtH.AddDat(DstEntId);
331      DstEntIdToLinkWgtH.AddDat(DstEntId, CurLinkWgt-LinkWgt);
332    }
333    TIntPrV _DiffLinkWgtDstEntIdPrV;
334    DstEntIdToLinkWgtH.GetDatKeyPrV(_DiffLinkWgtDstEntIdPrV);
335    TIntPrV DiffLinkWgtDstEntIdPrV(_DiffLinkWgtDstEntIdPrV.Len(), 0);
336    for (int EntN=0; EntN<_DiffLinkWgtDstEntIdPrV.Len(); EntN++){
337      int LinkWgt=_DiffLinkWgtDstEntIdPrV[EntN].Val1;
338      if (LinkWgt!=0){
339        DiffLinkWgtDstEntIdPrV.Add(_DiffLinkWgtDstEntIdPrV[EntN]);}
340    }
341    DiffLinkWgtDstEntIdPrV.Sort(true);
342    NegDiffLinkWgtDstEntIdPrV=DiffLinkWgtDstEntIdPrV;
343    DiffLinkWgtDstEntIdPrV.Sort(false);
344    PosDiffLinkWgtDstEntIdPrV=DiffLinkWgtDstEntIdPrV;
345  }
346  void TSkyGridBs::GetLinkWgtDstEntIdPrVChA(
347   const TIntPrV& LinkWgtDstEntIdPrV, TChA& LinkWgtDstEntIdPrVChA){
348    LinkWgtDstEntIdPrVChA.Clr();
349    for (int DstEntN=0; DstEntN<LinkWgtDstEntIdPrV.Len(); DstEntN++){
350      int DstEntId=LinkWgtDstEntIdPrV[DstEntN].Val2;
351      TStr DstEntNm=GetEntNm(DstEntId);
352      int LinkWgt=LinkWgtDstEntIdPrV[DstEntN].Val1;
353      if (DstEntN>0){LinkWgtDstEntIdPrVChA+=' ';}
354      LinkWgtDstEntIdPrVChA+=TStr::Fmt("['%s':%d]", DstEntNm.CStr(), LinkWgt);
355    }
356  }
357  void TSkyGridBs::SaveTxt(const TStr& FNm, const uint64& CurTm){
358    TStr CurTmStr=TTm::GetTmFromMSecs(CurTm).GetWebLogDateTimeStr();
359    uint64 CurDateTm=TTm::GetMSecsFromTm(TTm::GetTmFromWebLogDateTimeStr(TTm::GetTmFromMSecs(CurTm).GetWebLogDateStr()));
360    TStr CurDateTmStr=TTm::GetTmFromMSecs(CurDateTm).GetWebLogDateTimeStr();
361    TUInt64V MnTmV;
362    MnTmV.Add(CurDateTm-0*TTmInfo::GetDayMSecs());
363    MnTmV.Add(CurDateTm-1*TTmInfo::GetDayMSecs());
364    MnTmV.Add(CurDateTm-2*TTmInfo::GetDayMSecs());
365    MnTmV.Add(CurDateTm-4*TTmInfo::GetDayMSecs());
366    MnTmV.Add(CurDateTm-8*TTmInfo::GetDayMSecs());
367    MnTmV.Add(CurDateTm-16*TTmInfo::GetDayMSecs());
368    MnTmV.Add(CurDateTm-32*TTmInfo::GetDayMSecs());
369    PBowDocBs BowDocBs=GetBowDocBs();
370    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs(BowDocBs);
371    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
372    TIntPrV DocsEntIdPrV; GetSorted_DocsEntIdPrV(DocsEntIdPrV);
373    for (int EntN=0; EntN<DocsEntIdPrV.Len(); EntN++){
374      int EntId=DocsEntIdPrV[EntN].Val2;
375      TStr EntNm=GetEntNm(EntId);
376      int EntDocs=DocsEntIdPrV[EntN].Val1;
377      TSkyGridEnt& Ent=GetEnt(EntId);
378      int LinkEnts=Ent.GetLinkEnts();
379      fprintf(fOut, "'%s' [%d docs] [%d ents]\n", EntNm.CStr(), EntDocs, LinkEnts);
380      {TStrIntPrV DateStrDocsPrV; int _EntDocs;
381      Ent.GetDocsPerDateV(this, DateStrDocsPrV, _EntDocs);
382      fprintf(fOut, "   Docs per Date (%d docs):", _EntDocs);
383      for (int DateN=0; DateN<DateStrDocsPrV.Len(); DateN++){
384        TStr DateStr=DateStrDocsPrV[DateN].Val1;
385        int Docs=DateStrDocsPrV[DateN].Val2;
386        fprintf(fOut, " [%s:%d]", DateStr.CStr(), Docs);
387      }
388      fprintf(fOut, "\n");}
389      fprintf(fOut, "   [Now: %s]\n", CurTmStr.CStr());
390      TIntPrV PrevLinkWgtDstEntIdPrV;
391      TStrFltPrV PrevWordStrWgtPrV;
392      for (int MnTmN=0; MnTmN<MnTmV.Len(); MnTmN++){
393        uint64 MnTm=MnTmV[MnTmN];
394        double PastDays=(CurDateTm-MnTm)/double(TTmInfo::GetDayMSecs());
395        TStr MnTmStr=TTm::GetTmFromMSecs(MnTm).GetWebLogDateTimeStr();
396        TIntPrV LinkWgtDstEntIdPrV;
397        Ent.GetSorted_LinkWgtDstEntIdPrV(MnTm, 0.9, LinkWgtDstEntIdPrV);
398        if (MnTmN>0){
399          TIntPrV NegDiffLinkWgtDstEntIdPrV; TIntPrV PosDiffLinkWgtDstEntIdPrV;
400          GetLinkWgtDstEntIdPrVDiff(LinkWgtDstEntIdPrV, PrevLinkWgtDstEntIdPrV,
401           NegDiffLinkWgtDstEntIdPrV, PosDiffLinkWgtDstEntIdPrV);
402          TChA PosDiffLinkWgtDstEntIdPrVChA;
403          GetLinkWgtDstEntIdPrVChA(PosDiffLinkWgtDstEntIdPrV, PosDiffLinkWgtDstEntIdPrVChA);
404          fprintf(fOut, "         Pos-Diff: %s\n", PosDiffLinkWgtDstEntIdPrVChA.CStr());
405          TChA NegDiffLinkWgtDstEntIdPrVChA;
406          GetLinkWgtDstEntIdPrVChA(NegDiffLinkWgtDstEntIdPrV, NegDiffLinkWgtDstEntIdPrVChA);
407          fprintf(fOut, "         Neg-Diff: %s\n", NegDiffLinkWgtDstEntIdPrVChA.CStr());
408        }
409        PrevLinkWgtDstEntIdPrV=LinkWgtDstEntIdPrV;
410        int TopLinkEnts=LinkWgtDstEntIdPrV.Len();
411        TChA LinkWgtDstEntIdPrVChA;
412        GetLinkWgtDstEntIdPrVChA(LinkWgtDstEntIdPrV, LinkWgtDstEntIdPrVChA);
413        fprintf(fOut, "      Entities (%d ents): %s\n",
414         TopLinkEnts, LinkWgtDstEntIdPrVChA.CStr());
415        int CtrDocs; TStrFltPrV WordStrWgtPrV;
416        Ent.GetDocCentroid(this, BowDocBs, BowDocWgtBs, MnTm, 150, 0.9, CtrDocs, WordStrWgtPrV);
417        if (MnTmN>0){
418          TStrFltPrV NegDiffWordStrWgtPrV; TStrFltPrV PosDiffWordStrWgtPrV;
419          GetWordStrWgtPrVDiff(WordStrWgtPrV, PrevWordStrWgtPrV,
420           NegDiffWordStrWgtPrV, PosDiffWordStrWgtPrV);
421          TChA PosDiffWordStrWgtPrVChA; GetWordStrWgtPrVChA(PosDiffWordStrWgtPrV, PosDiffWordStrWgtPrVChA);
422          fprintf(fOut, "         Pos-Diff: %s\n", PosDiffWordStrWgtPrVChA.CStr());
423          TChA NegDiffWordStrWgtPrVChA; GetWordStrWgtPrVChA(NegDiffWordStrWgtPrV, NegDiffWordStrWgtPrVChA);
424          fprintf(fOut, "         Neg-Diff: %s\n", NegDiffWordStrWgtPrVChA.CStr());
425        }
426        PrevWordStrWgtPrV=WordStrWgtPrV;
427        TChA WordStrWgtPrVChA; GetWordStrWgtPrVChA(WordStrWgtPrV, WordStrWgtPrVChA);
428        fprintf(fOut, "      Centroid (%d docs, %d words): %s\n",
429         CtrDocs, WordStrWgtPrV.Len(), WordStrWgtPrVChA.CStr());
430        fprintf(fOut, "   [-%.1f days: %s]\n", PastDays, MnTmStr.CStr());
431      }
432      fprintf(fOut, "\n");
433    }
434  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_ring.h"
2  #include <cassert>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iostream>
6  #include <limits>
7  #include <memory>
8  #include <string>
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/throw_delegate.h"
11  #include "absl/base/macros.h"
12  #include "absl/container/inlined_vector.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_consume.h"
15  #include "absl/strings/internal/cord_rep_flat.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace cord_internal {
19  namespace {
20  using index_type = CordRepRing::index_type;
21  enum class Direction { kForward, kReversed };
22  inline bool IsFlatOrExternal(CordRep* rep) {
23    return rep->IsFlat() || rep->IsExternal();
24  }
25  inline void CheckCapacity(size_t n, size_t extra) {
26    if (ABSL_PREDICT_FALSE(extra > CordRepRing::kMaxCapacity - n)) {
27      base_internal::ThrowStdLengthError("Maximum capacity exceeded");
28    }
29  }
30  CordRepFlat* CreateFlat(const char* s, size_t n, size_t extra = 0) {  
31    assert(n <= kMaxFlatLength);
32    auto* rep = CordRepFlat::New(n + extra);
33    rep->length = n;
34    memcpy(rep->Data(), s, n);
35    return rep;
36  }
37  void UnrefEntries(const CordRepRing* rep, index_type head, index_type tail) {
38    rep->ForEach(head, tail, [rep](index_type ix) {
39      CordRep* child = rep->entry_child(ix);
40      if (!child->refcount.Decrement()) {
41        if (child->tag >= FLAT) {
42          CordRepFlat::Delete(child->flat());
43        } else {
44          CordRepExternal::Delete(child->external());
45        }
46      }
47    });
48  }
49  }  
50  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep) {
51    s << "  CordRepRing(" << &rep << ", length = " << rep.length
52      << ", head = " << rep.head_ << ", tail = " << rep.tail_
53      << ", cap = " << rep.capacity_ << ", rc = " << rep.refcount.Get()
54      << ", begin_pos_ = " << static_cast<ptrdiff_t>(rep.begin_pos_) << ") {\n";
55    CordRepRing::index_type head = rep.head();
56    do {
57      CordRep* child = rep.entry_child(head);
58      s << " entry[" << head << "] length = " << rep.entry_length(head)
59        << ", child " << child << ", clen = " << child->length
60        << ", tag = " << static_cast<int>(child->tag)
61        << ", rc = " << child->refcount.Get()
62        << ", offset = " << rep.entry_data_offset(head)
63        << ", end_pos = " << static_cast<ptrdiff_t>(rep.entry_end_pos(head))
64        << "\n";
65      head = rep.advance(head);
66    } while (head != rep.tail());
67    return s << "}\n";
68  }
69  void CordRepRing::AddDataOffset(index_type index, size_t n) {
70    entry_data_offset()[index] += static_cast<offset_type>(n);
71  }
72  void CordRepRing::SubLength(index_type index, size_t n) {
73    entry_end_pos()[index] -= n;
74  }
75  class CordRepRing::Filler {
76   public:
77    Filler(CordRepRing* rep, index_type pos) : rep_(rep), head_(pos), pos_(pos) {}
78    index_type head() const { return head_; }
79    index_type pos() const { return pos_; }
80    void Add(CordRep* child, size_t offset, pos_type end_pos) {
81      rep_->entry_end_pos()[pos_] = end_pos;
82      rep_->entry_child()[pos_] = child;
83      rep_->entry_data_offset()[pos_] = static_cast<offset_type>(offset);
84      pos_ = rep_->advance(pos_);
85    }
86   private:
87    CordRepRing* rep_;
88    index_type head_;
89    index_type pos_;
90  };
91  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
92  constexpr size_t CordRepRing::kMaxCapacity;
93  #endif
94  bool CordRepRing::IsValid(std::ostream& output) const {
95    if (capacity_ == 0) {
96      output << "capacity == 0";
97      return false;
98    }
99    if (head_ >= capacity_ || tail_ >= capacity_) {
100      output << "head " << head_ << " and/or tail " << tail_ << "exceed capacity "
101             << capacity_;
102      return false;
103    }
104    const index_type back = retreat(tail_);
105    size_t pos_length = Distance(begin_pos_, entry_end_pos(back));
106    if (pos_length != length) {
107      output << "length " << length << " does not match positional length "
108             << pos_length << " from begin_pos " << begin_pos_ << " and entry["
109             << back << "].end_pos " << entry_end_pos(back);
110      return false;
111    }
112    index_type head = head_;
113    pos_type begin_pos = begin_pos_;
114    do {
115      pos_type end_pos = entry_end_pos(head);
116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
127      if (child->tag < FLAT && child->tag != EXTERNAL) {
128        output << "entry[" << head << "].child has an invalid tag "
129               << static_cast<int>(child->tag);
130        return false;
131      }
132      size_t offset = entry_data_offset(head);
133      if (offset >= child->length || entry_length > child->length - offset) {
134        output << "entry[" << head << "] has offset " << offset
135               << " and entry length " << entry_length
136               << " which are outside of the child's length of " << child->length;
137        return false;
138      }
139      begin_pos = end_pos;
140      head = advance(head);
141    } while (head != tail_);
142    return true;
143  }
144  #ifdef EXTRA_CORD_RING_VALIDATION
145  CordRepRing* CordRepRing::Validate(CordRepRing* rep, const char* file,
146                                     int line) {
147    if (!rep->IsValid(std::cerr)) {
148      std::cerr << "\nERROR: CordRepRing corrupted";
149      if (line) std::cerr << " at line " << line;
150      if (file) std::cerr << " in file " << file;
151      std::cerr << "\nContent = " << *rep;
152      abort();
153    }
154    return rep;
155  }
156  #endif  
157  CordRepRing* CordRepRing::New(size_t capacity, size_t extra) {
158    CheckCapacity(capacity, extra);
159    size_t size = AllocSize(capacity += extra);
160    void* mem = ::operator new(size);
161    auto* rep = new (mem) CordRepRing(static_cast<index_type>(capacity));
162    rep->tag = RING;
163    rep->capacity_ = static_cast<index_type>(capacity);
164    rep->begin_pos_ = 0;
165    return rep;
166  }
167  void CordRepRing::SetCapacityForTesting(size_t capacity) {
168    assert(capacity <= capacity_);
169    assert(head() == 0 || head() < tail());
170    memmove(Layout::Partial(capacity).Pointer<1>(data_) + head(),
171            Layout::Partial(capacity_).Pointer<1>(data_) + head(),
172            entries() * sizeof(Layout::ElementType<1>));
173    memmove(Layout::Partial(capacity, capacity).Pointer<2>(data_) + head(),
174            Layout::Partial(capacity_, capacity_).Pointer<2>(data_) + head(),
175            entries() * sizeof(Layout::ElementType<2>));
176    capacity_ = static_cast<index_type>(capacity);
177  }
178  void CordRepRing::Delete(CordRepRing* rep) {
179    assert(rep != nullptr && rep->IsRing());
180  #if defined(__cpp_sized_deallocation)
181    size_t size = AllocSize(rep->capacity_);
182    rep->~CordRepRing();
183    ::operator delete(rep, size);
184  #else
185    rep->~CordRepRing();
186    ::operator delete(rep);
187  #endif
188  }
189  void CordRepRing::Destroy(CordRepRing* rep) {
190    UnrefEntries(rep, rep->head(), rep->tail());
191    Delete(rep);
192  }
193  template <bool ref>
194  void CordRepRing::Fill(const CordRepRing* src, index_type head,
195                         index_type tail) {
196    this->length = src->length;
197    head_ = 0;
198    tail_ = advance(0, src->entries(head, tail));
199    begin_pos_ = src->begin_pos_;
200    auto* dst_pos = entry_end_pos();
201    auto* dst_child = entry_child();
202    auto* dst_offset = entry_data_offset();
203    src->ForEach(head, tail, [&](index_type index) {
204      *dst_pos++ = src->entry_end_pos(index);
205      CordRep* child = src->entry_child(index);
206      *dst_child++ = ref ? CordRep::Ref(child) : child;
207      *dst_offset++ = src->entry_data_offset(index);
208    });
209  }
210  CordRepRing* CordRepRing::Copy(CordRepRing* rep, index_type head,
211                                 index_type tail, size_t extra) {
212    CordRepRing* newrep = CordRepRing::New(rep->entries(head, tail), extra);
213    newrep->Fill<true>(rep, head, tail);
214    CordRep::Unref(rep);
215    return newrep;
216  }
217  CordRepRing* CordRepRing::Mutable(CordRepRing* rep, size_t extra) {
218    size_t entries = rep->entries();
219    if (!rep->refcount.IsOne()) {
220      return Copy(rep, rep->head(), rep->tail(), extra);
221    } else if (entries + extra > rep->capacity()) {
222      const size_t min_grow = rep->capacity() + rep->capacity() / 2;
223      const size_t min_extra = (std::max)(extra, min_grow - entries);
224      CordRepRing* newrep = CordRepRing::New(entries, min_extra);
225      newrep->Fill<false>(rep, rep->head(), rep->tail());
226      CordRepRing::Delete(rep);
227      return newrep;
228    } else {
229      return rep;
230    }
231  }
232  Span<char> CordRepRing::GetAppendBuffer(size_t size) {
233    assert(refcount.IsOne());
234    index_type back = retreat(tail_);
235    CordRep* child = entry_child(back);
236    if (child->tag >= FLAT && child->refcount.IsOne()) {
237      size_t capacity = child->flat()->Capacity();
238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
242      if (size_t n = (std::min)(capacity - used, size)) {
243        child->length = data_offset + entry_length + n;
244        entry_end_pos()[back] = end_pos + n;
245        this->length += n;
246        return {child->flat()->Data() + used, n};
247      }
248    }
249    return {nullptr, 0};
250  }
251  Span<char> CordRepRing::GetPrependBuffer(size_t size) {
252    assert(refcount.IsOne());
253    CordRep* child = entry_child(head_);
254    size_t data_offset = entry_data_offset(head_);
255    if (data_offset && child->refcount.IsOne() && child->tag >= FLAT) {
256      size_t n = (std::min)(data_offset, size);
257      this->length += n;
258      begin_pos_ -= n;
259      data_offset -= n;
260      entry_data_offset()[head_] = static_cast<offset_type>(data_offset);
261      return {child->flat()->Data() + data_offset, n};
262    }
263    return {nullptr, 0};
264  }
265  CordRepRing* CordRepRing::CreateFromLeaf(CordRep* child, size_t offset,
266                                           size_t len, size_t extra) {
267    CordRepRing* rep = CordRepRing::New(1, extra);
268    rep->head_ = 0;
269    rep->tail_ = rep->advance(0);
270    rep->length = len;
271    rep->entry_end_pos()[0] = len;
272    rep->entry_child()[0] = child;
273    rep->entry_data_offset()[0] = static_cast<offset_type>(offset);
274    return Validate(rep);
275  }
276  CordRepRing* CordRepRing::CreateSlow(CordRep* child, size_t extra) {
277    CordRepRing* rep = nullptr;
278    Consume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
279      if (IsFlatOrExternal(child_arg)) {
280        rep = rep ? AppendLeaf(rep, child_arg, offset, len)
281                  : CreateFromLeaf(child_arg, offset, len, extra);
282      } else if (rep) {
283        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
284      } else if (offset == 0 && child_arg->length == len) {
285        rep = Mutable(child_arg->ring(), extra);
286      } else {
287        rep = SubRing(child_arg->ring(), offset, len, extra);
288      }
289    });
290    return Validate(rep, nullptr, __LINE__);
291  }
292  CordRepRing* CordRepRing::Create(CordRep* child, size_t extra) {
293    size_t length = child->length;
294    if (IsFlatOrExternal(child)) {
295      return CreateFromLeaf(child, 0, length, extra);
296    }
297    if (child->IsRing()) {
298      return Mutable(child->ring(), extra);
299    }
300    return CreateSlow(child, extra);
301  }
302  template <CordRepRing::AddMode mode>
303  CordRepRing* CordRepRing::AddRing(CordRepRing* rep, CordRepRing* ring,
304                                    size_t offset, size_t len) {
305    assert(offset < ring->length);
<span onclick='openModal()' class='match'>306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
</span>310    rep = Mutable(rep, entries);
311    const pos_type delta_length =
312        (append ? rep->begin_pos_ + rep->length : rep->begin_pos_ - len) -
313        ring->entry_begin_pos(head.index) - head.offset;
314    Filler filler(rep, append ? rep->tail_ : rep->retreat(rep->head_, entries));
315    if (ring->refcount.IsOne()) {
316      ring->ForEach(head.index, tail.index, [&](index_type ix) {
317        filler.Add(ring->entry_child(ix), ring->entry_data_offset(ix),
318                   ring->entry_end_pos(ix) + delta_length);
319      });
320      if (head.index != ring->head_) UnrefEntries(ring, ring->head_, head.index);
321      if (tail.index != ring->tail_) UnrefEntries(ring, tail.index, ring->tail_);
322      CordRepRing::Delete(ring);
323    } else {
324      ring->ForEach(head.index, tail.index, [&](index_type ix) {
325        CordRep* child = ring->entry_child(ix);
326        filler.Add(child, ring->entry_data_offset(ix),
327                   ring->entry_end_pos(ix) + delta_length);
328        CordRep::Ref(child);
329      });
330      CordRepRing::Unref(ring);
331    }
332    if (head.offset) {
333      rep->AddDataOffset(filler.head(), head.offset);
334    }
335    if (tail.offset) {
336      rep->SubLength(rep->retreat(filler.pos()), tail.offset);
337    }
338    rep->length += len;
339    if (append) {
340      rep->tail_ = filler.pos();
341    } else {
342      rep->head_ = filler.head();
343      rep->begin_pos_ -= len;
344    }
345    return Validate(rep);
346  }
347  CordRepRing* CordRepRing::AppendSlow(CordRepRing* rep, CordRep* child) {
348    Consume(child, [&rep](CordRep* child_arg, size_t offset, size_t len) {
349      if (child_arg->IsRing()) {
350        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
351      } else {
352        rep = AppendLeaf(rep, child_arg, offset, len);
353      }
354    });
355    return rep;
356  }
357  CordRepRing* CordRepRing::AppendLeaf(CordRepRing* rep, CordRep* child,
358                                       size_t offset, size_t len) {
359    rep = Mutable(rep, 1);
360    index_type back = rep->tail_;
361    const pos_type begin_pos = rep->begin_pos_ + rep->length;
362    rep->tail_ = rep->advance(rep->tail_);
363    rep->length += len;
364    rep->entry_end_pos()[back] = begin_pos + len;
365    rep->entry_child()[back] = child;
366    rep->entry_data_offset()[back] = static_cast<offset_type>(offset);
367    return Validate(rep, nullptr, __LINE__);
368  }
369  CordRepRing* CordRepRing::Append(CordRepRing* rep, CordRep* child) {
370    size_t length = child->length;
371    if (IsFlatOrExternal(child)) {
372      return AppendLeaf(rep, child, 0, length);
373    }
374    if (child->IsRing()) {
375      return AddRing<AddMode::kAppend>(rep, child->ring(), 0, length);
376    }
377    return AppendSlow(rep, child);
378  }
379  CordRepRing* CordRepRing::PrependSlow(CordRepRing* rep, CordRep* child) {
380    ReverseConsume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
381      if (IsFlatOrExternal(child_arg)) {
382        rep = PrependLeaf(rep, child_arg, offset, len);
383      } else {
384        rep = AddRing<AddMode::kPrepend>(rep, child_arg->ring(), offset, len);
385      }
386    });
387    return Validate(rep);
388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
400    return Validate(rep);
401  }
402  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, CordRep* child) {
403    size_t length = child->length;
404    if (IsFlatOrExternal(child)) {
405      return PrependLeaf(rep, child, 0, length);
406    }
407    if (child->IsRing()) {
408      return AddRing<AddMode::kPrepend>(rep, child->ring(), 0, length);
409    }
410    return PrependSlow(rep, child);
411  }
412  CordRepRing* CordRepRing::Append(CordRepRing* rep, absl::string_view data,
413                                   size_t extra) {
414    if (rep->refcount.IsOne()) {
415      Span<char> avail = rep->GetAppendBuffer(data.length());
416      if (!avail.empty()) {
417        memcpy(avail.data(), data.data(), avail.length());
418        data.remove_prefix(avail.length());
419      }
420    }
421    if (data.empty()) return Validate(rep);
422    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
423    rep = Mutable(rep, flats);
424    Filler filler(rep, rep->tail_);
425    pos_type pos = rep->begin_pos_ + rep->length;
426    while (data.length() >= kMaxFlatLength) {
427      auto* flat = CreateFlat(data.data(), kMaxFlatLength);
428      filler.Add(flat, 0, pos += kMaxFlatLength);
429      data.remove_prefix(kMaxFlatLength);
430    }
431    if (data.length()) {
432      auto* flat = CreateFlat(data.data(), data.length(), extra);
433      filler.Add(flat, 0, pos += data.length());
434    }
435    rep->length = pos - rep->begin_pos_;
436    rep->tail_ = filler.pos();
437    return Validate(rep);
438  }
439  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, absl::string_view data,
440                                    size_t extra) {
441    if (rep->refcount.IsOne()) {
442      Span<char> avail = rep->GetPrependBuffer(data.length());
443      if (!avail.empty()) {
444        const char* tail = data.data() + data.length() - avail.length();
445        memcpy(avail.data(), tail, avail.length());
446        data.remove_suffix(avail.length());
447      }
448    }
449    if (data.empty()) return rep;
450    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
451    rep = Mutable(rep, flats);
452    pos_type pos = rep->begin_pos_;
453    Filler filler(rep, rep->retreat(rep->head_, static_cast<index_type>(flats)));
454    size_t first_size = data.size() - (flats - 1) * kMaxFlatLength;
455    CordRepFlat* flat = CordRepFlat::New(first_size + extra);
456    flat->length = first_size + extra;
457    memcpy(flat->Data() + extra, data.data(), first_size);
458    data.remove_prefix(first_size);
459    filler.Add(flat, extra, pos);
460    pos -= first_size;
461    while (!data.empty()) {
462      assert(data.size() >= kMaxFlatLength);
463      flat = CreateFlat(data.data(), kMaxFlatLength);
464      filler.Add(flat, 0, pos);
465      pos -= kMaxFlatLength;
466      data.remove_prefix(kMaxFlatLength);
467    }
468    rep->head_ = filler.head();
469    rep->length += rep->begin_pos_ - pos;
470    rep->begin_pos_ = pos;
471    return Validate(rep);
472  }
473  static constexpr index_type kBinarySearchThreshold = 32;
474  static constexpr index_type kBinarySearchEndCount = 8;
475  template <bool wrap>
476  CordRepRing::index_type CordRepRing::FindBinary(index_type head,
477                                                  index_type tail,
478                                                  size_t offset) const {
479    index_type count = tail + (wrap ? capacity_ : 0) - head;
480    do {
481      count = (count - 1) / 2;
482      assert(count < entries(head, tail_));
483      index_type mid = wrap ? advance(head, count) : head + count;
484      index_type after_mid = wrap ? advance(mid) : mid + 1;
485      bool larger = (offset >= entry_end_offset(mid));
486      head = larger ? after_mid : head;
487      tail = larger ? tail : mid;
488      assert(head != tail);
489    } while (ABSL_PREDICT_TRUE(count > kBinarySearchEndCount));
490    return head;
491  }
492  CordRepRing::Position CordRepRing::FindSlow(index_type head,
493                                              size_t offset) const {
494    index_type tail = tail_;
495    if (tail > head) {
496      index_type count = tail - head;
497      if (count > kBinarySearchThreshold) {
498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
508    while (offset >= Distance(begin_pos_, end_pos)) {
509      head = advance(head);
510      pos = end_pos;
511      end_pos = entry_end_pos(head);
512    }
513    return {head, offset - Distance(begin_pos_, pos)};
514  }
515  CordRepRing::Position CordRepRing::FindTailSlow(index_type head,
516                                                  size_t offset) const {
517    index_type tail = tail_;
518    const size_t tail_offset = offset - 1;
519    if (tail > head) {
520      index_type count = tail - head;
521      if (count > kBinarySearchThreshold) {
522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
532      head = advance(head);
533      end_offset = entry_end_offset(head);
534    }
535    return {advance(head), end_offset - offset};
536  }
537  char CordRepRing::GetCharacter(size_t offset) const {
538    assert(offset < length);
539    Position pos = Find(offset);
540    size_t data_offset = entry_data_offset(pos.index) + pos.offset;
541    return GetRepData(entry_child(pos.index))[data_offset];
542  }
543  CordRepRing* CordRepRing::SubRing(CordRepRing* rep, size_t offset,
544                                    size_t len, size_t extra) {
545    assert(offset <= rep->length);
546    assert(offset <= rep->length - len);
547    if (len == 0) {
548      CordRep::Unref(rep);
549      return nullptr;
550    }
551    Position head = rep->Find(offset);
552    Position tail = rep->FindTail(head.index, offset + len);
553    const size_t new_entries = rep->entries(head.index, tail.index);
554    if (rep->refcount.IsOne() && extra <= (rep->capacity() - new_entries)) {
555      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
556      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
557      rep->head_ = head.index;
558      rep->tail_ = tail.index;
559    } else {
560      rep = Copy(rep, head.index, tail.index, extra);
561      head.index = rep->head_;
562      tail.index = rep->tail_;
563    }
564    rep->length = len;
565    rep->begin_pos_ += offset;
566    if (head.offset) {
567      rep->AddDataOffset(head.index, head.offset);
568    }
569    if (tail.offset) {
570      rep->SubLength(rep->retreat(tail.index), tail.offset);
571    }
572    return Validate(rep);
573  }
574  CordRepRing* CordRepRing::RemovePrefix(CordRepRing* rep, size_t len,
575                                         size_t extra) {
576    assert(len <= rep->length);
577    if (len == rep->length) {
578      CordRep::Unref(rep);
579      return nullptr;
580    }
581    Position head = rep->Find(len);
582    if (rep->refcount.IsOne()) {
583      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
584      rep->head_ = head.index;
585    } else {
586      rep = Copy(rep, head.index, rep->tail_, extra);
587      head.index = rep->head_;
588    }
589    rep->length -= len;
590    rep->begin_pos_ += len;
591    if (head.offset) {
592      rep->AddDataOffset(head.index, head.offset);
593    }
594    return Validate(rep);
595  }
596  CordRepRing* CordRepRing::RemoveSuffix(CordRepRing* rep, size_t len,
597                                         size_t extra) {
598    assert(len <= rep->length);
599    if (len == rep->length) {
600      CordRep::Unref(rep);
601      return nullptr;
602    }
603    Position tail = rep->FindTail(rep->length - len);
604    if (rep->refcount.IsOne()) {
605      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
606      rep->tail_ = tail.index;
607    } else {
608      rep = Copy(rep, rep->head_, tail.index, extra);
609      tail.index = rep->tail_;
610    }
611    rep->length -= len;
612    if (tail.offset) {
613      rep->SubLength(rep->retreat(tail.index), tail.offset);
614    }
615    return Validate(rep);
616  }
617  }  
618  ABSL_NAMESPACE_END
619  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-skygrid.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</div>
                </div>
                <div class="column column_space"><pre><code>74    for (int DocN=0; DocN<GetDocIds(); DocN++){
75      int DocId=GetDocId(DocN);
76      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
77      uint64 DocTm=Doc->GetTm();
</pre></code></div>
                <div class="column column_space"><pre><code>306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    