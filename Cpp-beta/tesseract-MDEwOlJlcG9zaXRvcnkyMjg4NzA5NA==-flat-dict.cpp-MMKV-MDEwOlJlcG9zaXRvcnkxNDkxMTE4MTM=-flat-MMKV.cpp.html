
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.3209081667231444%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dict.cpp</h3>
            <pre><code>1  #include "dict.h"
2  #include "tprintf.h"
3  #include <cstdio>
4  namespace tesseract {
5  class Image;
6  Dict::Dict(CCUtil *ccutil)
7      : letter_is_okay_(&tesseract::Dict::def_letter_is_okay)
8      , probability_in_context_(&tesseract::Dict::def_probability_in_context)
9      , ccutil_(ccutil)
10      , wildcard_unichar_id_(INVALID_UNICHAR_ID)
11      , apostrophe_unichar_id_(INVALID_UNICHAR_ID)
12      , question_unichar_id_(INVALID_UNICHAR_ID)
13      , slash_unichar_id_(INVALID_UNICHAR_ID)
14      , hyphen_unichar_id_(INVALID_UNICHAR_ID)
15      , STRING_MEMBER(user_words_file, "", "A filename of user-provided words.",
16                      getCCUtil()->params())
17      , STRING_INIT_MEMBER(user_words_suffix, "",
18                           "A suffix of user-provided words located in tessdata.",
19                           getCCUtil()->params())
20      , STRING_MEMBER(user_patterns_file, "", "A filename of user-provided patterns.",
21                      getCCUtil()->params())
22      , STRING_INIT_MEMBER(user_patterns_suffix, "",
23                           "A suffix of user-provided patterns located in "
24                           "tessdata.",
25                           getCCUtil()->params())
26      , BOOL_INIT_MEMBER(load_system_dawg, true, "Load system word dawg.", getCCUtil()->params())
27      , BOOL_INIT_MEMBER(load_freq_dawg, true, "Load frequent word dawg.", getCCUtil()->params())
28      , BOOL_INIT_MEMBER(load_unambig_dawg, true, "Load unambiguous word dawg.",
29                         getCCUtil()->params())
30      , BOOL_INIT_MEMBER(load_punc_dawg, true,
31                         "Load dawg with punctuation"
32                         " patterns.",
33                         getCCUtil()->params())
34      , BOOL_INIT_MEMBER(load_number_dawg, true,
35                         "Load dawg with number"
36                         " patterns.",
37                         getCCUtil()->params())
38      , BOOL_INIT_MEMBER(load_bigram_dawg, true,
39                         "Load dawg with special word "
40                         "bigrams.",
41                         getCCUtil()->params())
42      , double_MEMBER(xheight_penalty_subscripts, 0.125,
43                      "Score penalty (0.1 = 10%) added if there are subscripts "
44                      "or superscripts in a word, but it is otherwise OK.",
45                      getCCUtil()->params())
46      , double_MEMBER(xheight_penalty_inconsistent, 0.25,
47                      "Score penalty (0.1 = 10%) added if an xheight is "
48                      "inconsistent.",
49                      getCCUtil()->params())
50      , double_MEMBER(segment_penalty_dict_frequent_word, 1.0,
51                      "Score multiplier for word matches which have good case and"
52                      " are frequent in the given language (lower is better).",
53                      getCCUtil()->params())
54      , double_MEMBER(segment_penalty_dict_case_ok, 1.1,
55                      "Score multiplier for word matches that have good case "
56                      "(lower is better).",
57                      getCCUtil()->params())
58      , double_MEMBER(segment_penalty_dict_case_bad, 1.3125,
59                      "Default score multiplier for word matches, which may have "
60                      "case issues (lower is better).",
61                      getCCUtil()->params())
62      , double_MEMBER(segment_penalty_dict_nonword, 1.25,
63                      "Score multiplier for glyph fragment segmentations which "
64                      "do not match a dictionary word (lower is better).",
65                      getCCUtil()->params())
66      , double_MEMBER(segment_penalty_garbage, 1.50,
67                      "Score multiplier for poorly cased strings that are not in"
68                      " the dictionary and generally look like garbage (lower is"
69                      " better).",
70                      getCCUtil()->params())
71      , STRING_MEMBER(output_ambig_words_file, "",
72                      "Output file for ambiguities found in the dictionary", getCCUtil()->params())
73      , INT_MEMBER(dawg_debug_level, 0,
74                   "Set to 1 for general debug info"
75                   ", to 2 for more details, to 3 to see all the debug messages",
76                   getCCUtil()->params())
77      , INT_MEMBER(hyphen_debug_level, 0, "Debug level for hyphenated words.", getCCUtil()->params())
78      , BOOL_MEMBER(use_only_first_uft8_step, false,
79                    "Use only the first UTF8 step of the given string"
80                    " when computing log probabilities.",
81                    getCCUtil()->params())
82      , double_MEMBER(certainty_scale, 20.0, "Certainty scaling factor", getCCUtil()->params())
83      , double_MEMBER(stopper_nondict_certainty_base, -2.50, "Certainty threshold for non-dict words",
84                      getCCUtil()->params())
85      , double_MEMBER(stopper_phase2_certainty_rejection_offset, 1.0, "Reject certainty offset",
86                      getCCUtil()->params())
87      , INT_MEMBER(stopper_smallword_size, 2, "Size of dict word to be treated as non-dict word",
88                   getCCUtil()->params())
89      , double_MEMBER(stopper_certainty_per_char, -0.50,
90                      "Certainty to add"
91                      " for each dict char above small word size.",
92                      getCCUtil()->params())
93      , double_MEMBER(stopper_allowable_character_badness, 3.0,
94                      "Max certainty variation allowed in a word (in sigma)", getCCUtil()->params())
95      , INT_MEMBER(stopper_debug_level, 0, "Stopper debug level", getCCUtil()->params())
96      , BOOL_MEMBER(stopper_no_acceptable_choices, false,
97                    "Make AcceptableChoice() always return false. Useful"
98                    " when there is a need to explore all segmentations",
99                    getCCUtil()->params())
100      , INT_MEMBER(tessedit_truncate_wordchoice_log, 10, "Max words to keep in list",
101                   getCCUtil()->params())
102      , STRING_MEMBER(word_to_debug, "",
103                      "Word for which stopper debug"
104                      " information should be printed to stdout",
105                      getCCUtil()->params())
106      , BOOL_MEMBER(segment_nonalphabetic_script, false,
107                    "Don't use any alphabetic-specific tricks."
108                    " Set to true in the traineddata config file for"
109                    " scripts that are cursive or inherently fixed-pitch",
110                    getCCUtil()->params())
111      , BOOL_MEMBER(save_doc_words, 0, "Save Document Words", getCCUtil()->params())
112      , double_MEMBER(doc_dict_pending_threshold, 0.0, "Worst certainty for using pending dictionary",
113                      getCCUtil()->params())
114      , double_MEMBER(doc_dict_certainty_threshold, -2.25,
115                      "Worst certainty for words that can be inserted into the"
116                      " document dictionary",
117                      getCCUtil()->params())
118      , INT_MEMBER(max_permuter_attempts, 10000,
119                   "Maximum number of different"
120                   " character choices to consider during permutation."
121                   " This limit is especially useful when user patterns"
122                   " are specified, since overly generic patterns can result in"
123                   " dawg search exploring an overly large number of options.",
124                   getCCUtil()->params()) {
125    reject_offset_ = 0.0;
126    go_deeper_fxn_ = nullptr;
127    hyphen_word_ = nullptr;
128    last_word_on_line_ = false;
129    document_words_ = nullptr;
130    dawg_cache_ = nullptr;
131    dawg_cache_is_ours_ = false;
132    pending_words_ = nullptr;
133    bigram_dawg_ = nullptr;
134    freq_dawg_ = nullptr;
135    punc_dawg_ = nullptr;
136    unambig_dawg_ = nullptr;
137    wordseg_rating_adjust_factor_ = -1.0f;
138    output_ambig_words_file_ = nullptr;
139  }
140  Dict::~Dict() {
141    End();
142    delete hyphen_word_;
143    if (output_ambig_words_file_ != nullptr) {
144      fclose(output_ambig_words_file_);
145    }
146  }
147  DawgCache *Dict::GlobalDawgCache() {
148    static DawgCache cache;
149    return &cache;
150  }
151  void Dict::SetupForLoad(DawgCache *dawg_cache) {
152    if (dawgs_.size() != 0) {
153      this->End();
154    }
155    apostrophe_unichar_id_ = getUnicharset().unichar_to_id(kApostropheSymbol);
156    question_unichar_id_ = getUnicharset().unichar_to_id(kQuestionSymbol);
157    slash_unichar_id_ = getUnicharset().unichar_to_id(kSlashSymbol);
158    hyphen_unichar_id_ = getUnicharset().unichar_to_id(kHyphenSymbol);
159    if (dawg_cache != nullptr) {
160      dawg_cache_ = dawg_cache;
161      dawg_cache_is_ours_ = false;
162    } else {
163      dawg_cache_ = new DawgCache();
164      dawg_cache_is_ours_ = true;
165    }
166  }
167  void Dict::Load(const std::string &lang, TessdataManager *data_file) {
168    if (load_punc_dawg) {
169      punc_dawg_ =
170          dawg_cache_->GetSquishedDawg(lang, TESSDATA_PUNC_DAWG, dawg_debug_level, data_file);
171      if (punc_dawg_) {
172        dawgs_.push_back(punc_dawg_);
173      }
174    }
175    if (load_system_dawg) {
176      Dawg *system_dawg =
177          dawg_cache_->GetSquishedDawg(lang, TESSDATA_SYSTEM_DAWG, dawg_debug_level, data_file);
178      if (system_dawg) {
179        dawgs_.push_back(system_dawg);
180      }
181    }
182    if (load_number_dawg) {
183      Dawg *number_dawg =
184          dawg_cache_->GetSquishedDawg(lang, TESSDATA_NUMBER_DAWG, dawg_debug_level, data_file);
185      if (number_dawg) {
186        dawgs_.push_back(number_dawg);
187      }
188    }
189    if (load_bigram_dawg) {
190      bigram_dawg_ =
191          dawg_cache_->GetSquishedDawg(lang, TESSDATA_BIGRAM_DAWG, dawg_debug_level, data_file);
192    }
193    if (load_freq_dawg) {
194      freq_dawg_ =
195          dawg_cache_->GetSquishedDawg(lang, TESSDATA_FREQ_DAWG, dawg_debug_level, data_file);
196      if (freq_dawg_) {
197        dawgs_.push_back(freq_dawg_);
198      }
199    }
200    if (load_unambig_dawg) {
201      unambig_dawg_ =
202          dawg_cache_->GetSquishedDawg(lang, TESSDATA_UNAMBIG_DAWG, dawg_debug_level, data_file);
203      if (unambig_dawg_) {
204        dawgs_.push_back(unambig_dawg_);
205      }
206    }
207    std::string name;
208    if (!user_words_suffix.empty() || !user_words_file.empty()) {
209      Trie *trie_ptr =
210          new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM, getUnicharset().size(), dawg_debug_level);
211      if (!user_words_file.empty()) {
212        name = user_words_file;
213      } else {
214        name = getCCUtil()->language_data_path_prefix;
215        name += user_words_suffix;
216      }
217      if (!trie_ptr->read_and_add_word_list(name.c_str(), getUnicharset(),
218                                            Trie::RRP_REVERSE_IF_HAS_RTL)) {
219        tprintf("Error: failed to load %s\n", name.c_str());
220        delete trie_ptr;
221      } else {
222        dawgs_.push_back(trie_ptr);
223      }
224    }
225    if (!user_patterns_suffix.empty() || !user_patterns_file.empty()) {
226      Trie *trie_ptr = new Trie(DAWG_TYPE_PATTERN, lang, USER_PATTERN_PERM, getUnicharset().size(),
227                                dawg_debug_level);
228      trie_ptr->initialize_patterns(&(getUnicharset()));
229      if (!user_patterns_file.empty()) {
230        name = user_patterns_file;
231      } else {
232        name = getCCUtil()->language_data_path_prefix;
233        name += user_patterns_suffix;
234      }
235      if (!trie_ptr->read_pattern_list(name.c_str(), getUnicharset())) {
236        tprintf("Error: failed to load %s\n", name.c_str());
237        delete trie_ptr;
238      } else {
239        dawgs_.push_back(trie_ptr);
240      }
241    }
242    document_words_ =
243        new Trie(DAWG_TYPE_WORD, lang, DOC_DAWG_PERM, getUnicharset().size(), dawg_debug_level);
244    dawgs_.push_back(document_words_);
245    pending_words_ =
246        new Trie(DAWG_TYPE_WORD, lang, NO_PERM, getUnicharset().size(), dawg_debug_level);
247  }
248  void Dict::LoadLSTM(const std::string &lang, TessdataManager *data_file) {
249    if (load_punc_dawg) {
250      punc_dawg_ =
251          dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_PUNC_DAWG, dawg_debug_level, data_file);
252      if (punc_dawg_) {
253        dawgs_.push_back(punc_dawg_);
254      }
255    }
256    if (load_system_dawg) {
257      Dawg *system_dawg =
258          dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_SYSTEM_DAWG, dawg_debug_level, data_file);
259      if (system_dawg) {
260        dawgs_.push_back(system_dawg);
261      }
262    }
263    if (load_number_dawg) {
264      Dawg *number_dawg =
265          dawg_cache_->GetSquishedDawg(lang, TESSDATA_LSTM_NUMBER_DAWG, dawg_debug_level, data_file);
266      if (number_dawg) {
267        dawgs_.push_back(number_dawg);
268      }
269    }
270    std::string name;
271    if (!user_words_suffix.empty() || !user_words_file.empty()) {
272      Trie *trie_ptr =
273          new Trie(DAWG_TYPE_WORD, lang, USER_DAWG_PERM, getUnicharset().size(), dawg_debug_level);
274      if (!user_words_file.empty()) {
275        name = user_words_file;
276      } else {
277        name = getCCUtil()->language_data_path_prefix;
278        name += user_words_suffix;
279      }
280      if (!trie_ptr->read_and_add_word_list(name.c_str(), getUnicharset(),
281                                            Trie::RRP_REVERSE_IF_HAS_RTL)) {
282        tprintf("Error: failed to load %s\n", name.c_str());
283        delete trie_ptr;
284      } else {
285        dawgs_.push_back(trie_ptr);
286      }
287    }
288    if (!user_patterns_suffix.empty() || !user_patterns_file.empty()) {
289      Trie *trie_ptr = new Trie(DAWG_TYPE_PATTERN, lang, USER_PATTERN_PERM, getUnicharset().size(),
290                                dawg_debug_level);
291      trie_ptr->initialize_patterns(&(getUnicharset()));
292      if (!user_patterns_file.empty()) {
293        name = user_patterns_file;
294      } else {
295        name = getCCUtil()->language_data_path_prefix;
296        name += user_patterns_suffix;
297      }
298      if (!trie_ptr->read_pattern_list(name.c_str(), getUnicharset())) {
299        tprintf("Error: failed to load %s\n", name.c_str());
300        delete trie_ptr;
301      } else {
302        dawgs_.push_back(trie_ptr);
303      }
304    }
305  }
306  bool Dict::FinishLoad() {
307    if (dawgs_.empty()) {
308      return false;
309    }
310    successors_.reserve(dawgs_.size());
311    for (auto dawg : dawgs_) {
312      auto *lst = new SuccessorList();
313      for (unsigned j = 0; j < dawgs_.size(); ++j) {
314        const Dawg *other = dawgs_[j];
315        if (dawg != nullptr && other != nullptr && (dawg->lang() == other->lang()) &&
316            kDawgSuccessors[dawg->type()][other->type()]) {
317          lst->push_back(j);
318        }
319      }
320      successors_.push_back(lst);
321    }
322    return true;
323  }
324  void Dict::End() {
325    if (dawgs_.empty()) {
326      return; 
327    }
328    for (auto &dawg : dawgs_) {
329      if (!dawg_cache_->FreeDawg(dawg)) {
330        delete dawg;
331      }
332    }
333    dawg_cache_->FreeDawg(bigram_dawg_);
334    if (dawg_cache_is_ours_) {
335      delete dawg_cache_;
336      dawg_cache_ = nullptr;
337    }
338    for (auto successor : successors_) {
339      delete successor;
340    }
341    dawgs_.clear();
342    successors_.clear();
343    document_words_ = nullptr;
344    delete pending_words_;
345    pending_words_ = nullptr;
346  }
347  int Dict::def_letter_is_okay(void *void_dawg_args, const UNICHARSET &unicharset,
348                               UNICHAR_ID unichar_id, bool word_end) const {
349    auto *dawg_args = static_cast<DawgArgs *>(void_dawg_args);
350    ASSERT_HOST(unicharset.contains_unichar_id(unichar_id));
351    if (dawg_debug_level >= 3) {
352      tprintf(
353          "def_letter_is_okay: current unichar=%s word_end=%d"
354          " num active dawgs=%zu\n",
355          getUnicharset().debug_str(unichar_id).c_str(), word_end, dawg_args->active_dawgs->size());
356    }
357    if (unichar_id == Dawg::kPatternUnicharID || unichar_id == INVALID_UNICHAR_ID) {
358      dawg_args->permuter = NO_PERM;
359      return NO_PERM;
360    }
361    PermuterType curr_perm = NO_PERM;
362    dawg_args->updated_dawgs->clear();
363    dawg_args->valid_end = false;
364    for (unsigned a = 0; a < dawg_args->active_dawgs->size(); ++a) {
365      const DawgPosition &pos = (*dawg_args->active_dawgs)[a];
366      const Dawg *punc_dawg = pos.punc_index >= 0 ? dawgs_[pos.punc_index] : nullptr;
367      const Dawg *dawg = pos.dawg_index >= 0 ? dawgs_[pos.dawg_index] : nullptr;
368      if (!dawg && !punc_dawg) {
369        tprintf("Received DawgPosition with no dawg or punc_dawg.  wth?\n");
370        continue;
371      }
372      if (!dawg) {
373        NODE_REF punc_node = GetStartingNode(punc_dawg, pos.punc_ref);
374        EDGE_REF punc_transition_edge =
375            punc_dawg->edge_char_of(punc_node, Dawg::kPatternUnicharID, word_end);
376        if (punc_transition_edge != NO_EDGE) {
377          const SuccessorList &slist = *(successors_[pos.punc_index]);
378          for (int sdawg_index : slist) {
379            const Dawg *sdawg = dawgs_[sdawg_index];
380            UNICHAR_ID ch = char_for_dawg(unicharset, unichar_id, sdawg);
381            EDGE_REF dawg_edge = sdawg->edge_char_of(0, ch, word_end);
382            if (dawg_edge != NO_EDGE) {
383              if (dawg_debug_level >= 3) {
384                tprintf("Letter found in dawg %d\n", sdawg_index);
385              }
386              dawg_args->updated_dawgs->add_unique(
387                  DawgPosition(sdawg_index, dawg_edge, pos.punc_index, punc_transition_edge, false),
388                  dawg_debug_level > 0, "Append transition from punc dawg to current dawgs: ");
389              if (sdawg->permuter() > curr_perm) {
390                curr_perm = sdawg->permuter();
391              }
392              if (sdawg->end_of_word(dawg_edge) && punc_dawg->end_of_word(punc_transition_edge)) {
393                dawg_args->valid_end = true;
394              }
395            }
396          }
397        }
398        EDGE_REF punc_edge = punc_dawg->edge_char_of(punc_node, unichar_id, word_end);
399        if (punc_edge != NO_EDGE) {
400          if (dawg_debug_level >= 3) {
401            tprintf("Letter found in punctuation dawg\n");
402          }
403          dawg_args->updated_dawgs->add_unique(
404              DawgPosition(-1, NO_EDGE, pos.punc_index, punc_edge, false), dawg_debug_level > 0,
405              "Extend punctuation dawg: ");
406          if (PUNC_PERM > curr_perm) {
407            curr_perm = PUNC_PERM;
408          }
409          if (punc_dawg->end_of_word(punc_edge)) {
410            dawg_args->valid_end = true;
411          }
412        }
413        continue;
414      }
415      if (punc_dawg && dawg->end_of_word(pos.dawg_ref)) {
416        NODE_REF punc_node = GetStartingNode(punc_dawg, pos.punc_ref);
417        EDGE_REF punc_edge =
418            punc_node == NO_EDGE ? NO_EDGE : punc_dawg->edge_char_of(punc_node, unichar_id, word_end);
419        if (punc_edge != NO_EDGE) {
420          dawg_args->updated_dawgs->add_unique(
421              DawgPosition(pos.dawg_index, pos.dawg_ref, pos.punc_index, punc_edge, true),
422              dawg_debug_level > 0, "Return to punctuation dawg: ");
423          if (dawg->permuter() > curr_perm) {
424            curr_perm = dawg->permuter();
425          }
426          if (punc_dawg->end_of_word(punc_edge)) {
427            dawg_args->valid_end = true;
428          }
429        }
430      }
431      if (pos.back_to_punc) {
432        continue;
433      }
434      if (dawg->type() == DAWG_TYPE_PATTERN) {
435        ProcessPatternEdges(dawg, pos, unichar_id, word_end, dawg_args, &curr_perm);
436        continue;
437      }
438      NODE_REF node = GetStartingNode(dawg, pos.dawg_ref);
439      EDGE_REF edge =
440          (node == NO_EDGE)
441              ? NO_EDGE
442              : dawg->edge_char_of(node, char_for_dawg(unicharset, unichar_id, dawg), word_end);
443      if (dawg_debug_level >= 3) {
444        tprintf("Active dawg: [%d, " REFFORMAT "] edge=" REFFORMAT "\n", pos.dawg_index, node, edge);
445      }
446      if (edge != NO_EDGE) { 
447        if (dawg_debug_level >= 3) {
448          tprintf("Letter found in dawg %d\n", pos.dawg_index);
449        }
450        if (word_end && punc_dawg && !punc_dawg->end_of_word(pos.punc_ref)) {
451          if (dawg_debug_level >= 3) {
452            tprintf("Punctuation constraint not satisfied at end of word.\n");
453          }
454          continue;
455        }
456        if (dawg->permuter() > curr_perm) {
457          curr_perm = dawg->permuter();
458        }
459        if (dawg->end_of_word(edge) &&
460            (punc_dawg == nullptr || punc_dawg->end_of_word(pos.punc_ref))) {
461          dawg_args->valid_end = true;
462        }
463        dawg_args->updated_dawgs->add_unique(
464            DawgPosition(pos.dawg_index, edge, pos.punc_index, pos.punc_ref, false),
465            dawg_debug_level > 0, "Append current dawg to updated active dawgs: ");
466      }
467    } 
468    if (dawg_args->permuter == NO_PERM || curr_perm == NO_PERM ||
469        (curr_perm != PUNC_PERM && dawg_args->permuter != COMPOUND_PERM)) {
470      dawg_args->permuter = curr_perm;
471    }
472    if (dawg_debug_level >= 2) {
473      tprintf("Returning %d for permuter code for this character.\n", dawg_args->permuter);
474    }
475    return dawg_args->permuter;
476  }
477  void Dict::ProcessPatternEdges(const Dawg *dawg, const DawgPosition &pos, UNICHAR_ID unichar_id,
478                                 bool word_end, DawgArgs *dawg_args, PermuterType *curr_perm) const {
479    NODE_REF node = GetStartingNode(dawg, pos.dawg_ref);
480    std::vector<UNICHAR_ID> unichar_id_patterns;
481    unichar_id_patterns.push_back(unichar_id);
482    dawg->unichar_id_to_patterns(unichar_id, getUnicharset(), &unichar_id_patterns);
483    for (int unichar_id_pattern : unichar_id_patterns) {
484      for (int k = 0; k < 2; ++k) {
485        EDGE_REF edge = (k == 0)
486                            ? dawg->edge_char_of(node, unichar_id_pattern, word_end)
487                            : dawg->pattern_loop_edge(pos.dawg_ref, unichar_id_pattern, word_end);
488        if (edge == NO_EDGE) {
489          continue;
490        }
491        if (dawg_debug_level >= 3) {
492          tprintf("Pattern dawg: [%d, " REFFORMAT "] edge=" REFFORMAT "\n", pos.dawg_index, node,
493                  edge);
494          tprintf("Letter found in pattern dawg %d\n", pos.dawg_index);
495        }
496        if (dawg->permuter() > *curr_perm) {
497          *curr_perm = dawg->permuter();
498        }
499        if (dawg->end_of_word(edge)) {
500          dawg_args->valid_end = true;
501        }
502        dawg_args->updated_dawgs->add_unique(
503            DawgPosition(pos.dawg_index, edge, pos.punc_index, pos.punc_ref, pos.back_to_punc),
504            dawg_debug_level > 0, "Append current dawg to updated active dawgs: ");
505      }
506    }
507  }
508  void Dict::init_active_dawgs(DawgPositionVector *active_dawgs, bool ambigs_mode) const {
509    if (hyphenated()) {
510      *active_dawgs = hyphen_active_dawgs_;
511      if (dawg_debug_level >= 3) {
512        for (unsigned i = 0; i < hyphen_active_dawgs_.size(); ++i) {
513          tprintf("Adding hyphen beginning dawg [%d, " REFFORMAT "]\n",
514                  hyphen_active_dawgs_[i].dawg_index, hyphen_active_dawgs_[i].dawg_ref);
515        }
516      }
517    } else {
518      default_dawgs(active_dawgs, ambigs_mode);
519    }
520  }
521  void Dict::default_dawgs(DawgPositionVector *dawg_pos_vec, bool suppress_patterns) const {
522    bool punc_dawg_available = (punc_dawg_ != nullptr) &&
523                               punc_dawg_->edge_char_of(0, Dawg::kPatternUnicharID, true) != NO_EDGE;
524    for (unsigned i = 0; i < dawgs_.size(); i++) {
525      if (dawgs_[i] != nullptr && !(suppress_patterns && (dawgs_[i])->type() == DAWG_TYPE_PATTERN)) {
526        int dawg_ty = dawgs_[i]->type();
527        bool subsumed_by_punc = kDawgSuccessors[DAWG_TYPE_PUNCTUATION][dawg_ty];
528        if (dawg_ty == DAWG_TYPE_PUNCTUATION) {
529          dawg_pos_vec->push_back(DawgPosition(-1, NO_EDGE, i, NO_EDGE, false));
530          if (dawg_debug_level >= 3) {
531            tprintf("Adding beginning punc dawg [%d, " REFFORMAT "]\n", i, NO_EDGE);
532          }
533        } else if (!punc_dawg_available || !subsumed_by_punc) {
534          dawg_pos_vec->push_back(DawgPosition(i, NO_EDGE, -1, NO_EDGE, false));
535          if (dawg_debug_level >= 3) {
536            tprintf("Adding beginning dawg [%d, " REFFORMAT "]\n", i, NO_EDGE);
537          }
538        }
539      }
540    }
541  }
542  void Dict::add_document_word(const WERD_CHOICE &best_choice) {
543    if (hyphen_word_) {
544      return;
545    }
546    int stringlen = best_choice.length();
547    if (valid_word(best_choice) || stringlen < 2) {
548      return;
549    }
550    if (best_choice.length() >= kDocDictMaxRepChars) {
551      int num_rep_chars = 1;
552      UNICHAR_ID uch_id = best_choice.unichar_id(0);
553      for (unsigned i = 1; i < best_choice.length(); ++i) {
554        if (best_choice.unichar_id(i) != uch_id) {
555          num_rep_chars = 1;
556          uch_id = best_choice.unichar_id(i);
557        } else {
558          ++num_rep_chars;
559          if (num_rep_chars == kDocDictMaxRepChars) {
560            return;
561          }
562        }
563      }
564    }
565    if (best_choice.certainty() < doc_dict_certainty_threshold || stringlen == 2) {
566      if (best_choice.certainty() < doc_dict_pending_threshold) {
567        return;
568      }
569      if (!pending_words_->word_in_dawg(best_choice)) {
570        if (stringlen > 2 ||
571            (stringlen == 2 && getUnicharset().get_isupper(best_choice.unichar_id(0)) &&
572             getUnicharset().get_isupper(best_choice.unichar_id(1)))) {
573          pending_words_->add_word_to_dawg(best_choice);
574        }
575        return;
576      }
577    }
578    if (save_doc_words) {
579      std::string filename(getCCUtil()->imagefile);
580      filename += ".doc";
581      FILE *doc_word_file = fopen(filename.c_str(), "a");
582      if (doc_word_file == nullptr) {
583        tprintf("Error: Could not open file %s\n", filename.c_str());
584        ASSERT_HOST(doc_word_file);
585      }
586      fprintf(doc_word_file, "%s\n", best_choice.debug_string().c_str());
587      fclose(doc_word_file);
588    }
<span onclick='openModal()' class='match'>589    document_words_->add_word_to_dawg(best_choice);
590  }
591  void Dict::adjust_word(WERD_CHOICE *word, bool nonword, XHeightConsistencyEnum xheight_consistency,
592                         float additional_adjust, bool modify_rating, bool debug) {
593    bool is_han = (getUnicharset().han_sid() != getUnicharset().null_sid() &&
</span>594                   word->GetTopScriptID() == getUnicharset().han_sid());
595    bool case_is_ok = (is_han || case_ok(*word));
596    bool punc_is_ok = (is_han || !nonword || valid_punctuation(*word));
597    float adjust_factor = additional_adjust;
598    float new_rating = word->rating();
599    new_rating += kRatingPad;
600    const char *xheight_triggered = "";
601    if (word->length() > 1) {
602      switch (xheight_consistency) {
603        case XH_INCONSISTENT:
604          adjust_factor += xheight_penalty_inconsistent;
605          xheight_triggered = ", xhtBAD";
606          break;
607        case XH_SUBNORMAL:
608          adjust_factor += xheight_penalty_subscripts;
609          xheight_triggered = ", xhtSUB";
610          break;
611        case XH_GOOD:
612          break;
613      }
614    } else {
615      if (debug) {
616        tprintf("Consistency could not be calculated.\n");
617      }
618    }
619    if (debug) {
620      tprintf("%sWord: %s %4.2f%s", nonword ? "Non-" : "", word->unichar_string().c_str(),
621              word->rating(), xheight_triggered);
622    }
623    if (nonword) { 
624      if (case_is_ok && punc_is_ok) {
625        adjust_factor += segment_penalty_dict_nonword;
626        new_rating *= adjust_factor;
627        if (debug) {
628          tprintf(", W");
629        }
630      } else {
631        adjust_factor += segment_penalty_garbage;
632        new_rating *= adjust_factor;
633        if (debug) {
634          if (!case_is_ok) {
635            tprintf(", C");
636          }
637          if (!punc_is_ok) {
638            tprintf(", P");
639          }
640        }
641      }
642    } else { 
643      if (case_is_ok) {
644        if (!is_han && freq_dawg_ != nullptr && freq_dawg_->word_in_dawg(*word)) {
645          word->set_permuter(FREQ_DAWG_PERM);
646          adjust_factor += segment_penalty_dict_frequent_word;
647          new_rating *= adjust_factor;
648          if (debug) {
649            tprintf(", F");
650          }
651        } else {
652          adjust_factor += segment_penalty_dict_case_ok;
653          new_rating *= adjust_factor;
654          if (debug) {
655            tprintf(", ");
656          }
657        }
658      } else {
659        adjust_factor += segment_penalty_dict_case_bad;
660        new_rating *= adjust_factor;
661        if (debug) {
662          tprintf(", C");
663        }
664      }
665    }
666    new_rating -= kRatingPad;
667    if (modify_rating) {
668      word->set_rating(new_rating);
669    }
670    if (debug) {
671      tprintf(" %4.2f --> %4.2f\n", adjust_factor, new_rating);
672    }
673    word->set_adjust_factor(adjust_factor);
674  }
675  int Dict::valid_word(const WERD_CHOICE &word, bool numbers_ok) const {
676    const WERD_CHOICE *word_ptr = &word;
677    WERD_CHOICE temp_word(word.unicharset());
678    if (hyphenated() && hyphen_word_->unicharset() == word.unicharset()) {
679      copy_hyphen_info(&temp_word);
680      temp_word += word;
681      word_ptr = &temp_word;
682    }
683    if (word_ptr->empty()) {
684      return NO_PERM;
685    }
686    DawgPositionVector active_dawgs[2];
687    init_active_dawgs(&(active_dawgs[0]), false);
688    DawgArgs dawg_args(&(active_dawgs[0]), &(active_dawgs[1]), NO_PERM);
689    int last_index = word_ptr->length() - 1;
690    for (int i = hyphen_base_size(); i <= last_index; ++i) {
691      if (!((this->*letter_is_okay_)(&dawg_args, *word_ptr->unicharset(), word_ptr->unichar_id(i),
692                                     i == last_index))) {
693        break;
694      }
695      if (dawg_args.updated_dawgs == &(active_dawgs[1])) {
696        dawg_args.updated_dawgs = &(active_dawgs[0]);
697        ++(dawg_args.active_dawgs);
698      } else {
699        ++(dawg_args.updated_dawgs);
700        dawg_args.active_dawgs = &(active_dawgs[0]);
701      }
702    }
703    return valid_word_permuter(dawg_args.permuter, numbers_ok) ? dawg_args.permuter : NO_PERM;
704  }
705  bool Dict::valid_bigram(const WERD_CHOICE &word1, const WERD_CHOICE &word2) const {
706    if (bigram_dawg_ == nullptr) {
707      return false;
708    }
709    unsigned w1start, w1end, w2start, w2end;
710    word1.punct_stripped(&w1start, &w1end);
711    word2.punct_stripped(&w2start, &w2end);
712    if (w1start >= w1end) {
713      return word1.length() < 3;
714    }
715    if (w2start >= w2end) {
716      return word2.length() < 3;
717    }
718    const UNICHARSET &uchset = getUnicharset();
719    std::vector<UNICHAR_ID> bigram_string;
720    bigram_string.reserve(w1end + w2end + 1);
721    for (auto i = w1start; i < w1end; i++) {
722      const auto &normed_ids = getUnicharset().normed_ids(word1.unichar_id(i));
723      if (normed_ids.size() == 1 && uchset.get_isdigit(normed_ids[0])) {
724        bigram_string.push_back(question_unichar_id_);
725      } else {
726        bigram_string.insert(bigram_string.end(), normed_ids.begin(), normed_ids.end());
727      }
728    }
729    bigram_string.push_back(UNICHAR_SPACE);
730    for (auto i = w2start; i < w2end; i++) {
731      const auto &normed_ids = getUnicharset().normed_ids(word2.unichar_id(i));
732      if (normed_ids.size() == 1 && uchset.get_isdigit(normed_ids[0])) {
733        bigram_string.push_back(question_unichar_id_);
734      } else {
735        bigram_string.insert(bigram_string.end(), normed_ids.begin(), normed_ids.end());
736      }
737    }
738    WERD_CHOICE normalized_word(&uchset, bigram_string.size());
739    for (int i : bigram_string) {
740      normalized_word.append_unichar_id_space_allocated(i, 1, 0.0f, 0.0f);
741    }
742    return bigram_dawg_->word_in_dawg(normalized_word);
743  }
744  bool Dict::valid_punctuation(const WERD_CHOICE &word) {
745    if (word.empty()) {
746      return NO_PERM;
747    }
748    WERD_CHOICE new_word(word.unicharset());
749    auto last_index = word.length() - 1;
750    int new_len = 0;
751    for (unsigned i = 0; i <= last_index; ++i) {
752      UNICHAR_ID unichar_id = (word.unichar_id(i));
753      if (getUnicharset().get_ispunctuation(unichar_id)) {
754        new_word.append_unichar_id(unichar_id, 1, 0.0, 0.0);
755      } else if (!getUnicharset().get_isalpha(unichar_id) &&
756                 !getUnicharset().get_isdigit(unichar_id)) {
757        return false; 
758      } else if ((new_len = new_word.length()) == 0 ||
759                 new_word.unichar_id(new_len - 1) != Dawg::kPatternUnicharID) {
760        new_word.append_unichar_id(Dawg::kPatternUnicharID, 1, 0.0, 0.0);
761      }
762    }
763    for (unsigned i = 0; i < dawgs_.size(); ++i) {
764      if (dawgs_[i] != nullptr && dawgs_[i]->type() == DAWG_TYPE_PUNCTUATION &&
765          dawgs_[i]->word_in_dawg(new_word)) {
766        return true;
767      }
768    }
769    return false;
770  }
771  bool Dict::IsSpaceDelimitedLang() const {
772    const UNICHARSET &u_set = getUnicharset();
773    if (u_set.han_sid() > 0) {
774      return false;
775    }
776    if (u_set.katakana_sid() > 0) {
777      return false;
778    }
779    if (u_set.thai_sid() > 0) {
780      return false;
781    }
782    return true;
783  }
784  } 
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV.cpp</h3>
            <pre><code>1  #include "CodedInputData.h"
2  #include "CodedOutputData.h"
3  #include "InterProcessLock.h"
4  #include "KeyValueHolder.h"
5  #include "MMBuffer.h"
6  #include "MMKVLog.h"
7  #include "MMKVMetaInfo.hpp"
8  #include "MMKV_IO.h"
9  #include "MemoryFile.h"
10  #include "MiniPBCoder.h"
11  #include "PBUtility.h"
12  #include "ScopedLock.hpp"
13  #include "ThreadLock.h"
14  #include "aes/AESCrypt.h"
15  #include "aes/openssl/openssl_aes.h"
16  #include "aes/openssl/openssl_md5.h"
17  #include "crc32/Checksum.h"
18  #include <algorithm>
19  #include <cstdio>
20  #include <cstring>
21  #include <unordered_set>
22  #include <cassert>
23  #if defined(__aarch64__) && defined(__linux)
24  #    include <asm/hwcap.h>
25  #    include <sys/auxv.h>
26  #endif
27  #ifdef MMKV_APPLE
28  #    if __has_feature(objc_arc)
29  #        error This file must be compiled with MRC. Use -fno-objc-arc flag.
30  #    endif
31  #endif 
32  using namespace std;
33  using namespace mmkv;
34  unordered_map<string, MMKV *> *g_instanceDic;
35  ThreadLock *g_instanceLock;
36  MMKVPath_t g_rootDir;
37  static mmkv::ErrorHandler g_errorHandler;
38  size_t mmkv::DEFAULT_MMAP_SIZE;
39  #ifndef MMKV_WIN32
40  constexpr auto SPECIAL_CHARACTER_DIRECTORY_NAME = "specialCharacter";
41  constexpr auto CRC_SUFFIX = ".crc";
42  #else
43  constexpr auto SPECIAL_CHARACTER_DIRECTORY_NAME = L"specialCharacter";
44  constexpr auto CRC_SUFFIX = L".crc";
45  #endif
46  MMKV_NAMESPACE_BEGIN
47  static MMKVPath_t encodeFilePath(const string &mmapID, const MMKVPath_t &rootDir);
48  bool endsWith(const MMKVPath_t &str, const MMKVPath_t &suffix);
49  MMKVPath_t filename(const MMKVPath_t &path);
50  #ifndef MMKV_ANDROID
51  MMKV::MMKV(const string &mmapID, MMKVMode mode, string *cryptKey, MMKVPath_t *rootPath)
52      : m_mmapID(mmapID)
53      , m_path(mappedKVPathWithID(m_mmapID, mode, rootPath))
54      , m_crcPath(crcPathWithID(m_mmapID, mode, rootPath))
55      , m_dic(nullptr)
56      , m_dicCrypt(nullptr)
57      , m_file(new MemoryFile(m_path))
58      , m_metaFile(new MemoryFile(m_crcPath))
59      , m_metaInfo(new MMKVMetaInfo())
60      , m_crypter(nullptr)
61      , m_lock(new ThreadLock())
62      , m_fileLock(new FileLock(m_metaFile->getFd()))
63      , m_sharedProcessLock(new InterProcessLock(m_fileLock, SharedLockType))
64      , m_exclusiveProcessLock(new InterProcessLock(m_fileLock, ExclusiveLockType))
65      , m_isInterProcess((mode & MMKV_MULTI_PROCESS) != 0) {
66      m_actualSize = 0;
67      m_output = nullptr;
68  #    ifndef MMKV_DISABLE_CRYPT
69      if (cryptKey && cryptKey->length() > 0) {
70          m_dicCrypt = new MMKVMapCrypt();
71          m_crypter = new AESCrypt(cryptKey->data(), cryptKey->length());
72      } else {
73          m_dic = new MMKVMap();
74      }
75  #    else
76      m_dic = new MMKVMap();
77  #    endif
78      m_needLoadFromFile = true;
79      m_hasFullWriteback = false;
80      m_crcDigest = 0;
81      m_lock->initialize();
82      m_sharedProcessLock->m_enable = m_isInterProcess;
83      m_exclusiveProcessLock->m_enable = m_isInterProcess;
84      {
85          SCOPED_LOCK(m_sharedProcessLock);
86          loadFromFile();
87      }
88  }
89  #endif
90  MMKV::~MMKV() {
91      clearMemoryCache();
92      delete m_dic;
93  #ifndef MMKV_DISABLE_CRYPT
94      delete m_dicCrypt;
95      delete m_crypter;
96  #endif
97      delete m_file;
98      delete m_metaFile;
99      delete m_metaInfo;
100      delete m_lock;
101      delete m_fileLock;
102      delete m_sharedProcessLock;
103      delete m_exclusiveProcessLock;
104  #ifdef MMKV_ANDROID
105      delete m_fileModeLock;
106      delete m_sharedProcessModeLock;
107      delete m_exclusiveProcessModeLock;
108  #endif
109      MMKVInfo("destruct [%s]", m_mmapID.c_str());
110  }
111  MMKV *MMKV::defaultMMKV(MMKVMode mode, string *cryptKey) {
112  #ifndef MMKV_ANDROID
113      return mmkvWithID(DEFAULT_MMAP_ID, mode, cryptKey);
114  #else
115      return mmkvWithID(DEFAULT_MMAP_ID, DEFAULT_MMAP_SIZE, mode, cryptKey);
116  #endif
117  }
118  void initialize() {
119      g_instanceDic = new unordered_map<string, MMKV *>;
120      g_instanceLock = new ThreadLock();
121      g_instanceLock->initialize();
122      mmkv::DEFAULT_MMAP_SIZE = mmkv::getPageSize();
123      MMKVInfo("version %s, page size %d, arch %s", MMKV_VERSION, DEFAULT_MMAP_SIZE, MMKV_ABI);
124  #if defined(__aarch64__) && defined(__linux__)
125      auto hwcaps = getauxval(AT_HWCAP);
126  #    ifndef MMKV_DISABLE_CRYPT
127      if (hwcaps & HWCAP_AES) {
128          openssl::AES_set_encrypt_key = openssl_aes_armv8_set_encrypt_key;
129          openssl::AES_set_decrypt_key = openssl_aes_armv8_set_decrypt_key;
130          openssl::AES_encrypt = openssl_aes_armv8_encrypt;
131          openssl::AES_decrypt = openssl_aes_armv8_decrypt;
132          MMKVInfo("armv8 AES instructions is supported");
133      } else {
134          MMKVInfo("armv8 AES instructions is not supported");
135      }
136  #    endif 
137  #    ifdef MMKV_USE_ARMV8_CRC32
138      if (hwcaps & HWCAP_CRC32) {
139          CRC32 = mmkv::armv8_crc32;
140          MMKVInfo("armv8 CRC32 instructions is supported");
141      } else {
142          MMKVInfo("armv8 CRC32 instructions is not supported");
143      }
144  #    endif 
145  #endif     
146  #if defined(MMKV_DEBUG) && !defined(MMKV_DISABLE_CRYPT)
147  #endif
148  }
149  ThreadOnceToken_t once_control = ThreadOnceUninitialized;
150  void MMKV::initializeMMKV(const MMKVPath_t &rootDir, MMKVLogLevel logLevel, mmkv::LogHandler handler) {
151      g_currentLogLevel = logLevel;
152      g_logHandler = handler;
153      ThreadLock::ThreadOnce(&once_control, initialize);
154      g_rootDir = rootDir;
155      mkPath(g_rootDir);
156      MMKVInfo("root dir: " MMKV_PATH_FORMAT, g_rootDir.c_str());
157  }
158  const MMKVPath_t &MMKV::getRootDir() {
159      return g_rootDir;
160  }
161  #ifndef MMKV_ANDROID
162  MMKV *MMKV::mmkvWithID(const string &mmapID, MMKVMode mode, string *cryptKey, MMKVPath_t *rootPath) {
163      if (mmapID.empty()) {
164          return nullptr;
165      }
166      SCOPED_LOCK(g_instanceLock);
167      auto mmapKey = mmapedKVKey(mmapID, rootPath);
168      auto itr = g_instanceDic->find(mmapKey);
169      if (itr != g_instanceDic->end()) {
170          MMKV *kv = itr->second;
171          return kv;
172      }
173      if (rootPath) {
174          MMKVPath_t specialPath = (*rootPath) + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
175          if (!isFileExist(specialPath)) {
176              mkPath(specialPath);
177          }
178          MMKVInfo("prepare to load %s (id %s) from rootPath %s", mmapID.c_str(), mmapKey.c_str(), rootPath->c_str());
179      }
180      auto kv = new MMKV(mmapID, mode, cryptKey, rootPath);
181      kv->m_mmapKey = mmapKey;
182      (*g_instanceDic)[mmapKey] = kv;
183      return kv;
184  }
185  #endif
186  void MMKV::onExit() {
187      SCOPED_LOCK(g_instanceLock);
188      for (auto &pair : *g_instanceDic) {
189          MMKV *kv = pair.second;
190          kv->sync();
191          kv->clearMemoryCache();
192          delete kv;
193          pair.second = nullptr;
194      }
195      delete g_instanceDic;
196      g_instanceDic = nullptr;
197  }
198  const string &MMKV::mmapID() const {
199      return m_mmapID;
200  }
201  mmkv::ContentChangeHandler g_contentChangeHandler = nullptr;
202  void MMKV::notifyContentChanged() {
203      if (g_contentChangeHandler) {
204          g_contentChangeHandler(m_mmapID);
205      }
206  }
207  void MMKV::checkContentChanged() {
208      SCOPED_LOCK(m_lock);
209      checkLoadData();
210  }
211  void MMKV::registerContentChangeHandler(mmkv::ContentChangeHandler handler) {
212      g_contentChangeHandler = handler;
213  }
214  void MMKV::unRegisterContentChangeHandler() {
215      g_contentChangeHandler = nullptr;
216  }
217  void MMKV::clearMemoryCache() {
218      SCOPED_LOCK(m_lock);
219      if (m_needLoadFromFile) {
220          return;
221      }
222      MMKVInfo("clearMemoryCache [%s]", m_mmapID.c_str());
223      m_needLoadFromFile = true;
224      m_hasFullWriteback = false;
225      clearDictionary(m_dic);
226  #ifndef MMKV_DISABLE_CRYPT
227      clearDictionary(m_dicCrypt);
228      if (m_crypter) {
229          if (m_metaInfo->m_version >= MMKVVersionRandomIV) {
230              m_crypter->resetIV(m_metaInfo->m_vector, sizeof(m_metaInfo->m_vector));
231          } else {
232              m_crypter->resetIV();
233          }
234      }
235  #endif
236      delete m_output;
237      m_output = nullptr;
238      m_file->clearMemoryCache();
239      m_metaFile->clearMemoryCache();
240      m_actualSize = 0;
241      m_metaInfo->m_crcDigest = 0;
242  }
243  void MMKV::close() {
244      MMKVInfo("close [%s]", m_mmapID.c_str());
245      SCOPED_LOCK(g_instanceLock);
246      m_lock->lock();
247  #ifndef MMKV_ANDROID
248      auto itr = g_instanceDic->find(m_mmapKey);
249  #else
250      auto itr = g_instanceDic->find(m_mmapID);
251  #endif
252      if (itr != g_instanceDic->end()) {
253          g_instanceDic->erase(itr);
254      }
255      delete this;
256  }
257  #ifndef MMKV_DISABLE_CRYPT
258  string MMKV::cryptKey() const {
259      SCOPED_LOCK(m_lock);
260      if (m_crypter) {
261          char key[AES_KEY_LEN];
262          m_crypter->getKey(key);
263          return {key, strnlen(key, AES_KEY_LEN)};
264      }
265      return "";
266  }
267  void MMKV::checkReSetCryptKey(const string *cryptKey) {
268      SCOPED_LOCK(m_lock);
269      if (m_crypter) {
270          if (cryptKey && cryptKey->length() > 0) {
271              string oldKey = this->cryptKey();
272              if (oldKey != *cryptKey) {
273                  MMKVInfo("setting new aes key");
274                  delete m_crypter;
275                  auto ptr = cryptKey->data();
276                  m_crypter = new AESCrypt(ptr, cryptKey->length());
277                  checkLoadData();
278              } else {
279              }
280          } else {
281              MMKVInfo("reset aes key");
282              delete m_crypter;
283              m_crypter = nullptr;
284              checkLoadData();
285          }
286      } else {
287          if (cryptKey && cryptKey->length() > 0) {
288              MMKVInfo("setting new aes key");
289              auto ptr = cryptKey->data();
290              m_crypter = new AESCrypt(ptr, cryptKey->length());
291              checkLoadData();
292          } else {
293          }
294      }
295  }
296  #endif 
297  bool MMKV::isFileValid() {
298      return m_file->isFileValid();
299  }
300  bool MMKV::checkFileCRCValid(size_t actualSize, uint32_t crcDigest) {
301      auto ptr = (uint8_t *) m_file->getMemory();
302      if (ptr) {
303          m_crcDigest = (uint32_t) CRC32(0, (const uint8_t *) ptr + Fixed32Size, (uint32_t) actualSize);
304          if (m_crcDigest == crcDigest) {
305              return true;
306          }
307          MMKVError("check crc [%s] fail, crc32:%u, m_crcDigest:%u", m_mmapID.c_str(), crcDigest, m_crcDigest);
308      }
309      return false;
310  }
311  void MMKV::recaculateCRCDigestWithIV(const void *iv) {
312      auto ptr = (const uint8_t *) m_file->getMemory();
313      if (ptr) {
314          m_crcDigest = 0;
315          m_crcDigest = (uint32_t) CRC32(0, ptr + Fixed32Size, (uint32_t) m_actualSize);
316          writeActualSize(m_actualSize, m_crcDigest, iv, IncreaseSequence);
317      }
318  }
319  void MMKV::updateCRCDigest(const uint8_t *ptr, size_t length) {
320      if (ptr == nullptr) {
321          return;
322      }
323      m_crcDigest = (uint32_t) CRC32(m_crcDigest, ptr, (uint32_t) length);
324      writeActualSize(m_actualSize, m_crcDigest, nullptr, KeepSequence);
325  }
326  bool MMKV::set(bool value, MMKVKey_t key) {
327      return set(value, key, m_expiredInSeconds);
328  }
329  bool MMKV::set(bool value, MMKVKey_t key, uint32_t expireDuration) {
330      if (isKeyEmpty(key)) {
331          return false;
332      }
333      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbBoolSize() : pbBoolSize();
334      MMBuffer data(size);
335      CodedOutputData output(data.getPtr(), size);
336      output.writeBool(value);
337      if (unlikely(m_enableKeyExpire)) {
338          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
339          output.writeRawLittleEndian32(UInt32ToInt32(time));
340      } else {
341          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
342      }
343      return setDataForKey(std::move(data), key);
344  }
345  bool MMKV::set(int32_t value, MMKVKey_t key) {
346      return set(value, key, m_expiredInSeconds);
347  }
348  bool MMKV::set(int32_t value, MMKVKey_t key, uint32_t expireDuration) {
349      if (isKeyEmpty(key)) {
350          return false;
351      }
352      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbInt32Size(value) : pbInt32Size(value);
353      MMBuffer data(size);
354      CodedOutputData output(data.getPtr(), size);
355      output.writeInt32(value);
356      if (unlikely(m_enableKeyExpire)) {
357          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
358          output.writeRawLittleEndian32(UInt32ToInt32(time));
359      } else {
360          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
361      }
362      return setDataForKey(std::move(data), key);
363  }
364  bool MMKV::set(uint32_t value, MMKVKey_t key) {
365      return set(value, key, m_expiredInSeconds);
366  }
367  bool MMKV::set(uint32_t value, MMKVKey_t key, uint32_t expireDuration) {
368      if (isKeyEmpty(key)) {
369          return false;
370      }
371      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbUInt32Size(value) : pbUInt32Size(value);
372      MMBuffer data(size);
373      CodedOutputData output(data.getPtr(), size);
374      output.writeUInt32(value);
375      if (unlikely(m_enableKeyExpire)) {
376          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
377          output.writeRawLittleEndian32(UInt32ToInt32(time));
378      } else {
379          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
380      }
381      return setDataForKey(std::move(data), key);
382  }
383  bool MMKV::set(int64_t value, MMKVKey_t key) {
384      return set(value, key, m_expiredInSeconds);
385  }
386  bool MMKV::set(int64_t value, MMKVKey_t key, uint32_t expireDuration) {
387      if (isKeyEmpty(key)) {
388          return false;
389      }
390      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbInt64Size(value) : pbInt64Size(value);
391      MMBuffer data(size);
392      CodedOutputData output(data.getPtr(), size);
393      output.writeInt64(value);
394      if (unlikely(m_enableKeyExpire)) {
395          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
396          output.writeRawLittleEndian32(UInt32ToInt32(time));
397      } else {
398          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
399      }
400      return setDataForKey(std::move(data), key);
401  }
402  bool MMKV::set(uint64_t value, MMKVKey_t key) {
403      return set(value, key, m_expiredInSeconds);
404  }
405  bool MMKV::set(uint64_t value, MMKVKey_t key, uint32_t expireDuration) {
406      if (isKeyEmpty(key)) {
407          return false;
408      }
409      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbUInt64Size(value) : pbUInt64Size(value);
410      MMBuffer data(size);
411      CodedOutputData output(data.getPtr(), size);
412      output.writeUInt64(value);
413      if (unlikely(m_enableKeyExpire)) {
414          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
415          output.writeRawLittleEndian32(UInt32ToInt32(time));
416      } else {
417          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
418      }
419      return setDataForKey(std::move(data), key);
420  }
421  bool MMKV::set(float value, MMKVKey_t key) {
422      return set(value, key, m_expiredInSeconds);
423  }
424  bool MMKV::set(float value, MMKVKey_t key, uint32_t expireDuration) {
425      if (isKeyEmpty(key)) {
426          return false;
427      }
428      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbFloatSize() : pbFloatSize();
429      MMBuffer data(size);
430      CodedOutputData output(data.getPtr(), size);
431      output.writeFloat(value);
432      if (unlikely(m_enableKeyExpire)) {
433          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
434          output.writeRawLittleEndian32(UInt32ToInt32(time));
435      } else {
436          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
437      }
438      return setDataForKey(std::move(data), key);
439  }
440  bool MMKV::set(double value, MMKVKey_t key) {
441      return set(value, key, m_expiredInSeconds);
442  }
443  bool MMKV::set(double value, MMKVKey_t key, uint32_t expireDuration) {
444      if (isKeyEmpty(key)) {
445          return false;
446      }
447      size_t size = unlikely(m_enableKeyExpire) ? Fixed32Size + pbDoubleSize() : pbDoubleSize();
448      MMBuffer data(size);
449      CodedOutputData output(data.getPtr(), size);
450      output.writeDouble(value);
451      if (unlikely(m_enableKeyExpire)) {
452          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
453          output.writeRawLittleEndian32(UInt32ToInt32(time));
454      } else {
455          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
456      }
457      return setDataForKey(std::move(data), key);
458  }
459  #ifndef MMKV_APPLE
460  bool MMKV::set(const char *value, MMKVKey_t key) {
461      return set(value, key, m_expiredInSeconds);
462  }
463  bool MMKV::set(const char *value, MMKVKey_t key, uint32_t expireDuration) {
464      if (!value) {
465          removeValueForKey(key);
466          return true;
467      }
468      if (likely(!m_enableKeyExpire)) {
469          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
470          return setDataForKey(MMBuffer((void *) value, strlen(value), MMBufferNoCopy), key, true);
471      } else {
472          MMBuffer data((void *) value, strlen(value), MMBufferNoCopy);
473          if (data.length() > 0) {
474              auto tmp = MMBuffer(pbMMBufferSize(data) + Fixed32Size);
475              CodedOutputData output(tmp.getPtr(), tmp.length());
476              output.writeData(data);
477              auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
478              output.writeRawLittleEndian32(UInt32ToInt32(time));
479              data = std::move(tmp);
480          }
481          return setDataForKey(std::move(data), key);
482      }
483  }
484  bool MMKV::set(const string &value, MMKVKey_t key) {
485      return set(value, key, m_expiredInSeconds);
486  }
487  bool MMKV::set(const string &value, MMKVKey_t key, uint32_t expireDuration) {
488      if (isKeyEmpty(key)) {
489          return false;
490      }
491      if (likely(!m_enableKeyExpire)) {
492          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
493          return setDataForKey(MMBuffer((void *) value.data(), value.length(), MMBufferNoCopy), key, true);
494      } else {
495          MMBuffer data((void *) value.data(), value.length(), MMBufferNoCopy);
496          if (data.length() > 0) {
497              auto tmp = MMBuffer(pbMMBufferSize(data) + Fixed32Size);
498              CodedOutputData output(tmp.getPtr(), tmp.length());
499              output.writeData(data);
500              auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
501              output.writeRawLittleEndian32(UInt32ToInt32(time));
502              data = std::move(tmp);
503          }
504          return setDataForKey(std::move(data), key);
505      }
506  }
507  bool MMKV::set(const MMBuffer &value, MMKVKey_t key) {
508      return set(value, key, m_expiredInSeconds);
509  }
510  bool MMKV::set(const MMBuffer &value, MMKVKey_t key, uint32_t expireDuration) {
511      if (isKeyEmpty(key)) {
512          return false;
513      }
514      if (likely(!m_enableKeyExpire)) {
515          assert(expireDuration == ExpireNever && "setting expire duration without calling enableAutoKeyExpire() first");
516          return setDataForKey(MMBuffer(value.getPtr(), value.length(), MMBufferNoCopy), key, true);
517      } else {
518          MMBuffer data(value.getPtr(), value.length(), MMBufferNoCopy);
519          if (data.length() > 0) {
520              auto tmp = MMBuffer(pbMMBufferSize(data) + Fixed32Size);
521              CodedOutputData output(tmp.getPtr(), tmp.length());
522              output.writeData(data);
523              auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
524              output.writeRawLittleEndian32(UInt32ToInt32(time));
525              data = std::move(tmp);
526          }
527          return setDataForKey(std::move(data), key);
528      }
529  }
530  bool MMKV::set(const vector<string> &value, MMKVKey_t key) {
531      return set(value, key, m_expiredInSeconds);
532  }
533  bool MMKV::set(const vector<string> &v, MMKVKey_t key, uint32_t expireDuration) {
534      if (isKeyEmpty(key)) {
535          return false;
536      }
537      auto data = MiniPBCoder::encodeDataWithObject(v);
538      if (unlikely(m_enableKeyExpire) && data.length() > 0) {
539          auto tmp = MMBuffer(data.length() + Fixed32Size);
540          auto ptr = (uint8_t *)tmp.getPtr();
541          memcpy(ptr, data.getPtr(), data.length());
542          auto time = (expireDuration != ExpireNever) ? getCurrentTimeInSecond() + expireDuration : ExpireNever;
543          memcpy(ptr + data.length(), &time, Fixed32Size);
544          data = std::move(tmp);
545      }
546      return setDataForKey(std::move(data), key);
547  }
548  bool MMKV::getString(MMKVKey_t key, string &result) {
549      if (isKeyEmpty(key)) {
550          return false;
551      }
552      SCOPED_LOCK(m_lock);
553      SCOPED_LOCK(m_sharedProcessLock);
554      auto data = getDataForKey(key);
555      if (data.length() > 0) {
556          try {
557              CodedInputData input(data.getPtr(), data.length());
558              result = input.readString();
559              return true;
560          } catch (std::exception &exception) {
561              MMKVError("%s", exception.what());
562          }
563      }
564      return false;
565  }
566  bool MMKV::getBytes(MMKVKey_t key, mmkv::MMBuffer &result) {
567      if (isKeyEmpty(key)) {
568          return false;
569      }
570      SCOPED_LOCK(m_lock);
571      SCOPED_LOCK(m_sharedProcessLock);
572      auto data = getDataForKey(key);
573      if (data.length() > 0) {
574          try {
575              CodedInputData input(data.getPtr(), data.length());
576              result = std::move(input.readData());
577              return true;
578          } catch (std::exception &exception) {
579              MMKVError("%s", exception.what());
580          }
581      }
582      return false;
583  }
584  MMBuffer MMKV::getBytes(MMKVKey_t key) {
585      if (isKeyEmpty(key)) {
586          return MMBuffer();
587      }
588      SCOPED_LOCK(m_lock);
589      SCOPED_LOCK(m_sharedProcessLock);
590      auto data = getDataForKey(key);
591      if (data.length() > 0) {
592          try {
593              CodedInputData input(data.getPtr(), data.length());
594              return input.readData();
595          } catch (std::exception &exception) {
596              MMKVError("%s", exception.what());
597          }
598      }
599      return MMBuffer();
600  }
601  bool MMKV::getVector(MMKVKey_t key, vector<string> &result) {
602      if (isKeyEmpty(key)) {
603          return false;
604      }
605      SCOPED_LOCK(m_lock);
606      SCOPED_LOCK(m_sharedProcessLock);
607      auto data = getDataForKey(key);
608      if (data.length() > 0) {
609          try {
610              result = MiniPBCoder::decodeVector(data);
611              return true;
612          } catch (std::exception &exception) {
613              MMKVError("%s", exception.what());
614          }
615      }
616      return false;
617  }
618  #endif 
619  bool MMKV::getBool(MMKVKey_t key, bool defaultValue, bool *hasValue) {
620      if (isKeyEmpty(key)) {
621          if (hasValue != nullptr) {
622              *hasValue = false;
623          }
624          return defaultValue;
625      }
626      SCOPED_LOCK(m_lock);
627      SCOPED_LOCK(m_sharedProcessLock);
628      auto data = getDataForKey(key);
629      if (data.length() > 0) {
630          try {
631              CodedInputData input(data.getPtr(), data.length());
632              if (hasValue != nullptr) {
633                  *hasValue = true;
634              }
635              return input.readBool();
636          } catch (std::exception &exception) {
637              MMKVError("%s", exception.what());
638          }
639      }
640      if (hasValue != nullptr) {
641          *hasValue = false;
642      }
643      return defaultValue;
644  }
645  int32_t MMKV::getInt32(MMKVKey_t key, int32_t defaultValue, bool *hasValue) {
646      if (isKeyEmpty(key)) {
647          if (hasValue != nullptr) {
648              *hasValue = false;
649          }
650          return defaultValue;
651      }
652      SCOPED_LOCK(m_lock);
653      SCOPED_LOCK(m_sharedProcessLock);
654      auto data = getDataForKey(key);
655      if (data.length() > 0) {
656          try {
657              CodedInputData input(data.getPtr(), data.length());
658              if (hasValue != nullptr) {
659                  *hasValue = true;
660              }
661              return input.readInt32();
662          } catch (std::exception &exception) {
663              MMKVError("%s", exception.what());
664          }
665      }
666      if (hasValue != nullptr) {
667          *hasValue = false;
668      }
669      return defaultValue;
670  }
671  uint32_t MMKV::getUInt32(MMKVKey_t key, uint32_t defaultValue, bool *hasValue) {
672      if (isKeyEmpty(key)) {
673          if (hasValue != nullptr) {
674              *hasValue = false;
675          }
676          return defaultValue;
677      }
678      SCOPED_LOCK(m_lock);
679      SCOPED_LOCK(m_sharedProcessLock);
680      auto data = getDataForKey(key);
681      if (data.length() > 0) {
682          try {
683              CodedInputData input(data.getPtr(), data.length());
684              if (hasValue != nullptr) {
685                  *hasValue = true;
686              }
687              return input.readUInt32();
688          } catch (std::exception &exception) {
689              MMKVError("%s", exception.what());
690          }
691      }
692      if (hasValue != nullptr) {
693          *hasValue = false;
694      }
695      return defaultValue;
696  }
697  int64_t MMKV::getInt64(MMKVKey_t key, int64_t defaultValue, bool *hasValue) {
698      if (isKeyEmpty(key)) {
699          if (hasValue != nullptr) {
700              *hasValue = false;
701          }
702          return defaultValue;
703      }
704      SCOPED_LOCK(m_lock);
705      SCOPED_LOCK(m_sharedProcessLock);
706      auto data = getDataForKey(key);
707      if (data.length() > 0) {
708          try {
709              CodedInputData input(data.getPtr(), data.length());
710              if (hasValue != nullptr) {
711                  *hasValue = true;
712              }
713              return input.readInt64();
714          } catch (std::exception &exception) {
715              MMKVError("%s", exception.what());
716          }
717      }
718      if (hasValue != nullptr) {
719          *hasValue = false;
720      }
721      return defaultValue;
722  }
723  uint64_t MMKV::getUInt64(MMKVKey_t key, uint64_t defaultValue, bool *hasValue) {
724      if (isKeyEmpty(key)) {
725          if (hasValue != nullptr) {
726              *hasValue = false;
727          }
728          return defaultValue;
729      }
730      SCOPED_LOCK(m_lock);
731      SCOPED_LOCK(m_sharedProcessLock);
732      auto data = getDataForKey(key);
733      if (data.length() > 0) {
734          try {
735              CodedInputData input(data.getPtr(), data.length());
736              if (hasValue != nullptr) {
737                  *hasValue = true;
738              }
739              return input.readUInt64();
740          } catch (std::exception &exception) {
741              MMKVError("%s", exception.what());
742          }
743      }
744      if (hasValue != nullptr) {
745          *hasValue = false;
746      }
747      return defaultValue;
748  }
749  float MMKV::getFloat(MMKVKey_t key, float defaultValue, bool *hasValue) {
750      if (isKeyEmpty(key)) {
751          if (hasValue != nullptr) {
752              *hasValue = false;
753          }
754          return defaultValue;
755      }
756      SCOPED_LOCK(m_lock);
757      SCOPED_LOCK(m_sharedProcessLock);
758      auto data = getDataForKey(key);
759      if (data.length() > 0) {
760          try {
761              CodedInputData input(data.getPtr(), data.length());
762              if (hasValue != nullptr) {
763                  *hasValue = true;
764              }
765              return input.readFloat();
766          } catch (std::exception &exception) {
767              MMKVError("%s", exception.what());
768          }
769      }
770      if (hasValue != nullptr) {
771          *hasValue = false;
772      }
773      return defaultValue;
774  }
775  double MMKV::getDouble(MMKVKey_t key, double defaultValue, bool *hasValue) {
776      if (isKeyEmpty(key)) {
777          if (hasValue != nullptr) {
778              *hasValue = false;
779          }
780          return defaultValue;
781      }
782      SCOPED_LOCK(m_lock);
783      SCOPED_LOCK(m_sharedProcessLock);
784      auto data = getDataForKey(key);
785      if (data.length() > 0) {
786          try {
787              CodedInputData input(data.getPtr(), data.length());
788              if (hasValue != nullptr) {
789                  *hasValue = true;
790              }
791              return input.readDouble();
792          } catch (std::exception &exception) {
793              MMKVError("%s", exception.what());
794          }
795      }
796      if (hasValue != nullptr) {
797          *hasValue = false;
798      }
799      return defaultValue;
800  }
801  size_t MMKV::getValueSize(MMKVKey_t key, bool actualSize) {
802      if (isKeyEmpty(key)) {
803          return 0;
804      }
805      SCOPED_LOCK(m_lock);
806      SCOPED_LOCK(m_sharedProcessLock);
807      auto data = getDataForKey(key);
808      if (actualSize) {
809          try {
810              CodedInputData input(data.getPtr(), data.length());
811              auto length = input.readInt32();
812              if (length >= 0) {
813                  auto s_length = static_cast<size_t>(length);
814                  if (pbRawVarint32Size(length) + s_length == data.length()) {
815                      return s_length;
816                  }
817              }
818          } catch (std::exception &exception) {
819              MMKVError("%s", exception.what());
820          }
821      }
822      return data.length();
823  }
824  int32_t MMKV::writeValueToBuffer(MMKVKey_t key, void *ptr, int32_t size) {
825      if (isKeyEmpty(key) || size < 0) {
826          return -1;
827      }
828      auto s_size = static_cast<size_t>(size);
829      SCOPED_LOCK(m_lock);
830      SCOPED_LOCK(m_sharedProcessLock);
831      auto data = getDataForKey(key);
832      try {
833          CodedInputData input(data.getPtr(), data.length());
834          auto length = input.readInt32();
835          auto offset = pbRawVarint32Size(length);
836          if (length >= 0) {
837              auto s_length = static_cast<size_t>(length);
838              if (offset + s_length == data.length()) {
839                  if (s_length <= s_size) {
840                      memcpy(ptr, (uint8_t *) data.getPtr() + offset, s_length);
841                      return length;
842                  }
843              } else {
844                  if (data.length() <= s_size) {
845                      memcpy(ptr, data.getPtr(), data.length());
846                      return static_cast<int32_t>(data.length());
847                  }
848              }
849          }
850      } catch (std::exception &exception) {
851          MMKVError("%s", exception.what());
852      }
853      return -1;
854  }
855  bool MMKV::containsKey(MMKVKey_t key) {
856      SCOPED_LOCK(m_lock);
857      checkLoadData();
858      if (likely(!m_enableKeyExpire)) {
859          if (m_crypter) {
860              return m_dicCrypt->find(key) != m_dicCrypt->end();
861          } else {
862              return m_dic->find(key) != m_dic->end();
863          }
864      }
865      auto raw = getDataWithoutMTimeForKey(key);
866      return raw.length() != 0;
867  }
868  size_t MMKV::count() {
869      SCOPED_LOCK(m_lock);
870      checkLoadData();
871      if (m_crypter) {
872          return m_dicCrypt->size();
873      } else {
874          return m_dic->size();
875      }
876  }
877  size_t MMKV::totalSize() {
878      SCOPED_LOCK(m_lock);
879      checkLoadData();
880      return m_file->getFileSize();
881  }
882  size_t MMKV::actualSize() {
883      SCOPED_LOCK(m_lock);
884      checkLoadData();
885      return m_actualSize;
886  }
887  void MMKV::removeValueForKey(MMKVKey_t key) {
888      if (isKeyEmpty(key)) {
889          return;
890      }
891      SCOPED_LOCK(m_lock);
892      SCOPED_LOCK(m_exclusiveProcessLock);
893      checkLoadData();
894      removeDataForKey(key);
895  }
896  #ifndef MMKV_APPLE
897  vector<string> MMKV::allKeys() {
898      SCOPED_LOCK(m_lock);
899      checkLoadData();
900      vector<string> keys;
901      if (m_crypter) {
902          for (const auto &itr : *m_dicCrypt) {
903              keys.push_back(itr.first);
904          }
905      } else {
906          for (const auto &itr : *m_dic) {
907              keys.push_back(itr.first);
908          }
909      }
910      return keys;
911  }
912  void MMKV::removeValuesForKeys(const vector<string> &arrKeys) {
913      if (arrKeys.empty()) {
914          return;
915      }
916      if (arrKeys.size() == 1) {
917          return removeValueForKey(arrKeys[0]);
918      }
919      SCOPED_LOCK(m_lock);
920      SCOPED_LOCK(m_exclusiveProcessLock);
921      checkLoadData();
922      size_t deleteCount = 0;
923      if (m_crypter) {
924          for (const auto &key : arrKeys) {
925              auto itr = m_dicCrypt->find(key);
926              if (itr != m_dicCrypt->end()) {
927                  m_dicCrypt->erase(itr);
928                  deleteCount++;
929              }
930          }
931      } else {
932          for (const auto &key : arrKeys) {
933              auto itr = m_dic->find(key);
934              if (itr != m_dic->end()) {
935                  m_dic->erase(itr);
936                  deleteCount++;
937              }
938          }
939      }
940      if (deleteCount > 0) {
941          m_hasFullWriteback = false;
942          fullWriteback();
943      }
944  }
945  #endif 
946  void MMKV::sync(SyncFlag flag) {
947      SCOPED_LOCK(m_lock);
948      if (m_needLoadFromFile || !isFileValid()) {
949          return;
950      }
951      SCOPED_LOCK(m_exclusiveProcessLock);
952      m_file->msync(flag);
953      m_metaFile->msync(flag);
954  }
955  void MMKV::lock() {
956      SCOPED_LOCK(m_lock);
957      m_exclusiveProcessLock->lock();
958  }
959  void MMKV::unlock() {
960      SCOPED_LOCK(m_lock);
961      m_exclusiveProcessLock->unlock();
962  }
963  bool MMKV::try_lock() {
964      SCOPED_LOCK(m_lock);
965      return m_exclusiveProcessLock->try_lock();
966  }
967  static bool backupOneToDirectoryByFilePath(const string &mmapKey, const MMKVPath_t &srcPath, const MMKVPath_t &dstPath) {
968      File crcFile(srcPath, OpenFlag::ReadOnly);
969      if (!crcFile.isFileValid()) {
970          return false;
971      }
972      bool ret = false;
973      {
974  #ifdef MMKV_WIN32
975          MMKVInfo("backup one mmkv[%s] from [%ls] to [%ls]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
976  #else
977          MMKVInfo("backup one mmkv[%s] from [%s] to [%s]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
978  #endif
979          FileLock fileLock(crcFile.getFd());
980          InterProcessLock lock(&fileLock, SharedLockType);
981          SCOPED_LOCK(&lock);
982          ret = copyFile(srcPath, dstPath);
983          if (ret) {
984              auto srcCRCPath = srcPath + CRC_SUFFIX;
985              auto dstCRCPath = dstPath + CRC_SUFFIX;
986              ret = copyFile(srcCRCPath, dstCRCPath);
987          }
988          MMKVInfo("finish backup one mmkv[%s]", mmapKey.c_str());
989      }
990      return ret;
991  }
992  bool MMKV::backupOneToDirectory(const string &mmapKey, const MMKVPath_t &dstPath, const MMKVPath_t &srcPath, bool compareFullPath) {
993      SCOPED_LOCK(g_instanceLock);
994      MMKV *kv = nullptr;
995      if (!compareFullPath) {
996          auto itr = g_instanceDic->find(mmapKey);
997          if (itr != g_instanceDic->end()) {
998              kv = itr->second;
999          }
1000      } else {
1001          for (auto &pair : *g_instanceDic) {
1002              if (pair.second->m_path == srcPath) {
1003                  kv = pair.second;
1004                  break;
1005              }
1006          }
1007      }
1008      if (kv) {
1009  #ifdef MMKV_WIN32
1010          MMKVInfo("backup one cached mmkv[%s] from [%ls] to [%ls]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
1011  #else
1012          MMKVInfo("backup one cached mmkv[%s] from [%s] to [%s]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
1013  #endif
1014          SCOPED_LOCK(kv->m_lock);
1015          SCOPED_LOCK(kv->m_sharedProcessLock);
1016          kv->sync();
1017          auto ret = copyFile(kv->m_path, dstPath);
1018          if (ret) {
1019              auto dstCRCPath = dstPath + CRC_SUFFIX;
1020              ret = copyFile(kv->m_crcPath, dstCRCPath);
1021          }
1022          MMKVInfo("finish backup one mmkv[%s], ret: %d", mmapKey.c_str(), ret);
1023          return ret;
1024      }
1025      bool ret = backupOneToDirectoryByFilePath(mmapKey, srcPath, dstPath);
1026      return ret;
1027  }
1028  bool MMKV::backupOneToDirectory(const string &mmapID, const MMKVPath_t &dstDir, const MMKVPath_t *srcDir) {
1029      auto rootPath = srcDir ? srcDir : &g_rootDir;
1030      if (*rootPath == dstDir) {
1031          return true;
1032      }
1033      mkPath(dstDir);
1034      auto encodePath = encodeFilePath(mmapID, dstDir);
1035      auto dstPath = dstDir + MMKV_PATH_SLASH + encodePath;
1036      auto mmapKey = mmapedKVKey(mmapID, rootPath);
1037  #ifdef MMKV_ANDROID
1038      auto srcPath = *rootPath + MMKV_PATH_SLASH + encodeFilePath(mmapKey, *rootPath);
1039  #else
1040      auto srcPath = *rootPath + MMKV_PATH_SLASH + encodePath;
1041  #endif
1042      return backupOneToDirectory(mmapKey, dstPath, srcPath, false);
1043  }
1044  bool endsWith(const MMKVPath_t &str, const MMKVPath_t &suffix) {
1045      if (str.length() >= suffix.length()) {
1046          return str.compare(str.length() - suffix.length(), suffix.length(), suffix) == 0;
1047      } else {
1048          return false;
1049      }
1050  }
1051  MMKVPath_t filename(const MMKVPath_t &path) {
1052      auto startPos = path.rfind(MMKV_PATH_SLASH);
1053      startPos++; 
1054      auto filename = path.substr(startPos);
1055      return filename;
1056  }
1057  size_t MMKV::backupAllToDirectory(const MMKVPath_t &dstDir, const MMKVPath_t &srcDir, bool isInSpecialDir) {
1058      unordered_set<MMKVPath_t> mmapIDSet;
1059      unordered_set<MMKVPath_t> mmapIDCRCSet;
1060      walkInDir(srcDir, WalkFile, [&](const MMKVPath_t &filePath, WalkType) {
1061          if (endsWith(filePath, CRC_SUFFIX)) {
1062              mmapIDCRCSet.insert(filePath);
1063          } else {
1064              mmapIDSet.insert(filePath);
1065          }
1066      });
1067      size_t count = 0;
1068      if (!mmapIDSet.empty()) {
1069          mkPath(dstDir);
1070          auto compareFullPath = isInSpecialDir;
1071          for (auto &srcPath : mmapIDSet) {
1072              auto srcCRCPath = srcPath + CRC_SUFFIX;
1073              if (mmapIDCRCSet.find(srcCRCPath) == mmapIDCRCSet.end()) {
1074  #ifdef MMKV_WIN32
1075                  MMKVWarning("crc not exist [%ls]", srcCRCPath.c_str());
1076  #else
1077                  MMKVWarning("crc not exist [%s]", srcCRCPath.c_str());
1078  #endif
1079                  continue;
1080              }
1081              auto basename = filename(srcPath);
1082              const auto &strBasename = MMKVPath_t2String(basename);
1083              auto mmapKey = isInSpecialDir ? strBasename : mmapedKVKey(strBasename, &srcDir);
1084              auto dstPath = dstDir + MMKV_PATH_SLASH + basename;
1085              if (backupOneToDirectory(mmapKey, dstPath, srcPath, compareFullPath)) {
1086                  count++;
1087              }
1088          }
1089      }
1090      return count;
1091  }
1092  size_t MMKV::backupAllToDirectory(const MMKVPath_t &dstDir, const MMKVPath_t *srcDir) {
1093      auto rootPath = srcDir ? srcDir : &g_rootDir;
1094      if (*rootPath == dstDir) {
1095          return true;
1096      }
1097      auto count = backupAllToDirectory(dstDir, *rootPath, false);
1098      auto specialSrcDir = *rootPath + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
1099      if (isFileExist(specialSrcDir)) {
1100          auto specialDstDir = dstDir + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
1101          count += backupAllToDirectory(specialDstDir, specialSrcDir, true);
1102      }
1103      return count;
1104  }
1105  static bool restoreOneFromDirectoryByFilePath(const string &mmapKey, const MMKVPath_t &srcPath, const MMKVPath_t &dstPath) {
1106      auto dstCRCPath = dstPath + CRC_SUFFIX;
1107      File dstCRCFile(std::move(dstCRCPath), OpenFlag::ReadWrite | OpenFlag::Create);
1108      if (!dstCRCFile.isFileValid()) {
1109          return false;
1110      }
1111      bool ret = false;
1112      {
1113  #ifdef MMKV_WIN32
1114          MMKVInfo("restore one mmkv[%s] from [%ls] to [%ls]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
1115  #else
1116          MMKVInfo("restore one mmkv[%s] from [%s] to [%s]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
1117  #endif
1118          FileLock fileLock(dstCRCFile.getFd());
1119          InterProcessLock lock(&fileLock, ExclusiveLockType);
1120          SCOPED_LOCK(&lock);
1121          ret = copyFileContent(srcPath, dstPath);
1122          if (ret) {
1123              auto srcCRCPath = srcPath + CRC_SUFFIX;
1124              ret = copyFileContent(srcCRCPath, dstCRCFile.getFd());
1125          }
1126          MMKVInfo("finish restore one mmkv[%s]", mmapKey.c_str());
1127      }
1128      return ret;
1129  }
1130  bool MMKV::restoreOneFromDirectory(const string &mmapKey, const MMKVPath_t &srcPath, const MMKVPath_t &dstPath, bool compareFullPath) {
1131      SCOPED_LOCK(g_instanceLock);
1132      MMKV *kv = nullptr;
1133      if (!compareFullPath) {
1134          auto itr = g_instanceDic->find(mmapKey);
1135          if (itr != g_instanceDic->end()) {
1136              kv = itr->second;
1137          }
1138      } else {
1139          for (auto &pair : *g_instanceDic) {
1140              if (pair.second->m_path == dstPath) {
1141                  kv = pair.second;
1142                  break;
1143              }
1144          }
1145      }
1146      if (kv) {
1147  #ifdef MMKV_WIN32
1148          MMKVInfo("restore one cached mmkv[%s] from [%ls] to [%ls]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
1149  #else
1150          MMKVInfo("restore one cached mmkv[%s] from [%s] to [%s]", mmapKey.c_str(), srcPath.c_str(), dstPath.c_str());
1151  #endif
1152          SCOPED_LOCK(kv->m_lock);
1153          SCOPED_LOCK(kv->m_exclusiveProcessLock);
1154          kv->sync();
1155          auto ret = copyFileContent(srcPath, kv->m_file->getFd());
1156          if (ret) {
1157              auto srcCRCPath = srcPath + CRC_SUFFIX;
1158              ret = copyFileContent(srcCRCPath, kv->m_metaFile->getFd());
1159          }
1160          kv->clearMemoryCache();
1161          kv->loadFromFile();
1162          if (kv->m_isInterProcess) {
1163              kv->notifyContentChanged();
1164          }
1165          MMKVInfo("finish restore one mmkv[%s], ret: %d", mmapKey.c_str(), ret);
1166          return ret;
1167      }
1168      bool ret = restoreOneFromDirectoryByFilePath(mmapKey, srcPath, dstPath);
1169      return ret;
1170  }
1171  bool MMKV::restoreOneFromDirectory(const string &mmapID, const MMKVPath_t &srcDir, const MMKVPath_t *dstDir) {
1172      auto rootPath = dstDir ? dstDir : &g_rootDir;
1173      if (*rootPath == srcDir) {
1174          return true;
1175      }
1176      mkPath(*rootPath);
1177      auto encodePath = encodeFilePath(mmapID, *rootPath);
1178      auto srcPath = srcDir + MMKV_PATH_SLASH + encodePath;
1179      auto mmapKey = mmapedKVKey(mmapID, rootPath);
1180  #ifdef MMKV_ANDROID
1181      auto dstPath = *rootPath + MMKV_PATH_SLASH + encodeFilePath(mmapKey, *rootPath);
1182  #else
1183      auto dstPath = *rootPath + MMKV_PATH_SLASH + encodePath;
1184  #endif
<span onclick='openModal()' class='match'>1185      return restoreOneFromDirectory(mmapKey, srcPath, dstPath, false);
1186  }
1187  size_t MMKV::restoreAllFromDirectory(const MMKVPath_t &srcDir, const MMKVPath_t &dstDir, bool isInSpecialDir) {
1188      unordered_set<MMKVPath_t> mmapIDSet;
1189      unordered_set<MMKVPath_t> mmapIDCRCSet;
1190      walkInDir(srcDir, WalkFile, [&](const MMKVPath_t &filePath, WalkType) {
</span>1191          if (endsWith(filePath, CRC_SUFFIX)) {
1192              mmapIDCRCSet.insert(filePath);
1193          } else {
1194              mmapIDSet.insert(filePath);
1195          }
1196      });
1197      size_t count = 0;
1198      if (!mmapIDSet.empty()) {
1199          mkPath(dstDir);
1200          auto compareFullPath = isInSpecialDir;
1201          for (auto &srcPath : mmapIDSet) {
1202              auto srcCRCPath = srcPath + CRC_SUFFIX;
1203              if (mmapIDCRCSet.find(srcCRCPath) == mmapIDCRCSet.end()) {
1204  #ifdef MMKV_WIN32
1205                  MMKVWarning("crc not exist [%ls]", srcCRCPath.c_str());
1206  #else
1207                  MMKVWarning("crc not exist [%s]", srcCRCPath.c_str());
1208  #endif
1209                  continue;
1210              }
1211              auto basename = filename(srcPath);
1212              const auto &strBasename = MMKVPath_t2String(basename);
1213              auto mmapKey = isInSpecialDir ? strBasename : mmapedKVKey(strBasename, &dstDir);
1214              auto dstPath = dstDir + MMKV_PATH_SLASH + basename;
1215              if (restoreOneFromDirectory(mmapKey, srcPath, dstPath, compareFullPath)) {
1216                  count++;
1217              }
1218          }
1219      }
1220      return count;
1221  }
1222  size_t MMKV::restoreAllFromDirectory(const MMKVPath_t &srcDir, const MMKVPath_t *dstDir) {
1223      auto rootPath = dstDir ? dstDir : &g_rootDir;
1224      if (*rootPath == srcDir) {
1225          return true;
1226      }
1227      auto count = restoreAllFromDirectory(srcDir, *rootPath, true);
1228      auto specialSrcDir = srcDir + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
1229      if (isFileExist(specialSrcDir)) {
1230          auto specialDstDir = *rootPath + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
1231          count += restoreAllFromDirectory(specialSrcDir, specialDstDir, false);
1232      }
1233      return count;
1234  }
1235  void MMKV::registerErrorHandler(ErrorHandler handler) {
1236      SCOPED_LOCK(g_instanceLock);
1237      g_errorHandler = handler;
1238  }
1239  void MMKV::unRegisterErrorHandler() {
1240      SCOPED_LOCK(g_instanceLock);
1241      g_errorHandler = nullptr;
1242  }
1243  void MMKV::registerLogHandler(LogHandler handler) {
1244      SCOPED_LOCK(g_instanceLock);
1245      g_logHandler = handler;
1246  }
1247  void MMKV::unRegisterLogHandler() {
1248      SCOPED_LOCK(g_instanceLock);
1249      g_logHandler = nullptr;
1250  }
1251  void MMKV::setLogLevel(MMKVLogLevel level) {
1252      SCOPED_LOCK(g_instanceLock);
1253      g_currentLogLevel = level;
1254  }
1255  static void mkSpecialCharacterFileDirectory() {
1256      MMKVPath_t path = g_rootDir + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
1257      mkPath(path);
1258  }
1259  template <typename T>
1260  static string md5(const basic_string<T> &value) {
1261      uint8_t md[MD5_DIGEST_LENGTH] = {};
1262      char tmp[3] = {}, buf[33] = {};
1263      openssl::MD5((const uint8_t *) value.c_str(), value.size() * (sizeof(T) / sizeof(uint8_t)), md);
1264      for (auto ch : md) {
1265          snprintf(tmp, sizeof(tmp), "%2.2x", ch);
1266          strcat(buf, tmp);
1267      }
1268      return {buf};
1269  }
1270  static MMKVPath_t encodeFilePath(const string &mmapID) {
1271      const char *specialCharacters = "\\/:*?\"<>|";
1272      string encodedID;
1273      bool hasSpecialCharacter = false;
1274      for (auto ch : mmapID) {
1275          if (strchr(specialCharacters, ch) != nullptr) {
1276              encodedID = md5(mmapID);
1277              hasSpecialCharacter = true;
1278              break;
1279          }
1280      }
1281      if (hasSpecialCharacter) {
1282          static ThreadOnceToken_t once_control = ThreadOnceUninitialized;
1283          ThreadLock::ThreadOnce(&once_control, mkSpecialCharacterFileDirectory);
1284          return MMKVPath_t(SPECIAL_CHARACTER_DIRECTORY_NAME) + MMKV_PATH_SLASH + string2MMKVPath_t(encodedID);
1285      } else {
1286          return string2MMKVPath_t(mmapID);
1287      }
1288  }
1289  static MMKVPath_t encodeFilePath(const string &mmapID, const MMKVPath_t &rootDir) {
1290      const char *specialCharacters = "\\/:*?\"<>|";
1291      string encodedID;
1292      bool hasSpecialCharacter = false;
1293      for (auto ch : mmapID) {
1294          if (strchr(specialCharacters, ch) != nullptr) {
1295              encodedID = md5(mmapID);
1296              hasSpecialCharacter = true;
1297              break;
1298          }
1299      }
1300      if (hasSpecialCharacter) {
1301          MMKVPath_t path = rootDir + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;
1302          mkPath(path);
1303          return MMKVPath_t(SPECIAL_CHARACTER_DIRECTORY_NAME) + MMKV_PATH_SLASH + string2MMKVPath_t(encodedID);
1304      } else {
1305          return string2MMKVPath_t(mmapID);
1306      }
1307  }
1308  string mmapedKVKey(const string &mmapID, const MMKVPath_t *rootPath) {
1309      if (rootPath && g_rootDir != (*rootPath)) {
1310          return md5(*rootPath + MMKV_PATH_SLASH + string2MMKVPath_t(mmapID));
1311      }
1312      return mmapID;
1313  }
1314  MMKVPath_t mappedKVPathWithID(const string &mmapID, MMKVMode mode, const MMKVPath_t *rootPath) {
1315  #ifndef MMKV_ANDROID
1316      if (rootPath) {
1317  #else
1318      if (mode & MMKV_ASHMEM) {
1319          return ashmemMMKVPathWithID(encodeFilePath(mmapID));
1320      } else if (rootPath) {
1321  #endif
1322          return *rootPath + MMKV_PATH_SLASH + encodeFilePath(mmapID);
1323      }
1324      return g_rootDir + MMKV_PATH_SLASH + encodeFilePath(mmapID);
1325  }
1326  MMKVPath_t crcPathWithID(const string &mmapID, MMKVMode mode, const MMKVPath_t *rootPath) {
1327  #ifndef MMKV_ANDROID
1328      if (rootPath) {
1329  #else
1330      if (mode & MMKV_ASHMEM) {
1331          return ashmemMMKVPathWithID(encodeFilePath(mmapID)) + CRC_SUFFIX;
1332      } else if (rootPath) {
1333  #endif
1334          return *rootPath + MMKV_PATH_SLASH + encodeFilePath(mmapID) + CRC_SUFFIX;
1335      }
1336      return g_rootDir + MMKV_PATH_SLASH + encodeFilePath(mmapID) + CRC_SUFFIX;
1337  }
1338  MMKVRecoverStrategic onMMKVCRCCheckFail(const string &mmapID) {
1339      if (g_errorHandler) {
1340          return g_errorHandler(mmapID, MMKVErrorType::MMKVCRCCheckFail);
1341      }
1342      return OnErrorDiscard;
1343  }
1344  MMKVRecoverStrategic onMMKVFileLengthError(const string &mmapID) {
1345      if (g_errorHandler) {
1346          return g_errorHandler(mmapID, MMKVErrorType::MMKVFileLength);
1347      }
1348      return OnErrorDiscard;
1349  }
1350  MMKV_NAMESPACE_END
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dict.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV.cpp</div>
                </div>
                <div class="column column_space"><pre><code>589    document_words_->add_word_to_dawg(best_choice);
590  }
591  void Dict::adjust_word(WERD_CHOICE *word, bool nonword, XHeightConsistencyEnum xheight_consistency,
592                         float additional_adjust, bool modify_rating, bool debug) {
593    bool is_han = (getUnicharset().han_sid() != getUnicharset().null_sid() &&
</pre></code></div>
                <div class="column column_space"><pre><code>1185      return restoreOneFromDirectory(mmapKey, srcPath, dstPath, false);
1186  }
1187  size_t MMKV::restoreAllFromDirectory(const MMKVPath_t &srcDir, const MMKVPath_t &dstDir, bool isInSpecialDir) {
1188      unordered_set<MMKVPath_t> mmapIDSet;
1189      unordered_set<MMKVPath_t> mmapIDCRCSet;
1190      walkInDir(srcDir, WalkFile, [&](const MMKVPath_t &filePath, WalkType) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    