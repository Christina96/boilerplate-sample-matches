
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.774538386783285%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-proto.cc</h3>
            <pre><code>1  #include "absl/log/internal/proto.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <cstddef>
5  #include <cstdint>
6  #include <cstring>
7  #include "absl/base/attributes.h"
8  #include "absl/base/config.h"
9  #include "absl/types/span.h"
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace log_internal {
13  namespace {
14  void EncodeRawVarint(uint64_t value, size_t size, absl::Span<char> *buf) {
15    for (size_t s = 0; s < size; s++) {
16      (*buf)[s] = static_cast<char>((value & 0x7f) | (s + 1 == size ? 0 : 0x80));
17      value >>= 7;
18    }
19    buf->remove_prefix(size);
20  }
21  constexpr uint64_t MakeTagType(uint64_t tag, WireType type) {
<span onclick='openModal()' class='match'>22    return tag << 3 | static_cast<uint64_t>(type);
23  }
24  }  
25  bool EncodeVarint(uint64_t tag, uint64_t value, absl::Span<char> *buf) {
26    const uint64_t tag_type = MakeTagType(tag, WireType::kVarint);
27    const size_t tag_type_size = VarintSize(tag_type);
</span>28    const size_t value_size = VarintSize(value);
29    if (tag_type_size + value_size > buf->size()) {
30      buf->remove_suffix(buf->size());
31      return false;
32    }
33    EncodeRawVarint(tag_type, tag_type_size, buf);
34    EncodeRawVarint(value, value_size, buf);
35    return true;
36  }
37  bool Encode64Bit(uint64_t tag, uint64_t value, absl::Span<char> *buf) {
38    const uint64_t tag_type = MakeTagType(tag, WireType::k64Bit);
39    const size_t tag_type_size = VarintSize(tag_type);
40    if (tag_type_size + sizeof(value) > buf->size()) {
41      buf->remove_suffix(buf->size());
42      return false;
43    }
44    EncodeRawVarint(tag_type, tag_type_size, buf);
45    for (size_t s = 0; s < sizeof(value); s++) {
46      (*buf)[s] = static_cast<char>(value & 0xff);
47      value >>= 8;
48    }
49    buf->remove_prefix(sizeof(value));
50    return true;
51  }
52  bool Encode32Bit(uint64_t tag, uint32_t value, absl::Span<char> *buf) {
53    const uint64_t tag_type = MakeTagType(tag, WireType::k32Bit);
54    const size_t tag_type_size = VarintSize(tag_type);
55    if (tag_type_size + sizeof(value) > buf->size()) {
56      buf->remove_suffix(buf->size());
57      return false;
58    }
59    EncodeRawVarint(tag_type, tag_type_size, buf);
60    for (size_t s = 0; s < sizeof(value); s++) {
61      (*buf)[s] = static_cast<char>(value & 0xff);
62      value >>= 8;
63    }
64    buf->remove_prefix(sizeof(value));
65    return true;
66  }
67  bool EncodeBytes(uint64_t tag, absl::Span<const char> value,
68                   absl::Span<char> *buf) {
69    const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);
70    const size_t tag_type_size = VarintSize(tag_type);
71    uint64_t length = value.size();
72    const size_t length_size = VarintSize(length);
73    if (tag_type_size + length_size + value.size() > buf->size()) {
74      buf->remove_suffix(buf->size());
75      return false;
76    }
77    EncodeRawVarint(tag_type, tag_type_size, buf);
78    EncodeRawVarint(length, length_size, buf);
79    memcpy(buf->data(), value.data(), value.size());
80    buf->remove_prefix(value.size());
81    return true;
82  }
83  bool EncodeBytesTruncate(uint64_t tag, absl::Span<const char> value,
84                           absl::Span<char> *buf) {
85    const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);
86    const size_t tag_type_size = VarintSize(tag_type);
87    uint64_t length = value.size();
88    const size_t length_size =
89        VarintSize(std::min<uint64_t>(length, buf->size()));
90    if (tag_type_size + length_size <= buf->size() &&
91        tag_type_size + length_size + value.size() > buf->size()) {
92      value.remove_suffix(tag_type_size + length_size + value.size() -
93                          buf->size());
94      length = value.size();
95    }
96    if (tag_type_size + length_size + value.size() > buf->size()) {
97      buf->remove_suffix(buf->size());
98      return false;
99    }
100    EncodeRawVarint(tag_type, tag_type_size, buf);
101    EncodeRawVarint(length, length_size, buf);
102    memcpy(buf->data(), value.data(), value.size());
103    buf->remove_prefix(value.size());
104    return true;
105  }
106  ABSL_MUST_USE_RESULT absl::Span<char> EncodeMessageStart(
107      uint64_t tag, uint64_t max_size, absl::Span<char> *buf) {
108    const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);
109    const size_t tag_type_size = VarintSize(tag_type);
110    max_size = std::min<uint64_t>(max_size, buf->size());
111    const size_t length_size = VarintSize(max_size);
112    if (tag_type_size + length_size > buf->size()) {
113      buf->remove_suffix(buf->size());
114      return absl::Span<char>();
115    }
116    EncodeRawVarint(tag_type, tag_type_size, buf);
117    const absl::Span<char> ret = buf->subspan(0, length_size);
118    EncodeRawVarint(0, length_size, buf);
119    return ret;
120  }
121  void EncodeMessageLength(absl::Span<char> msg, const absl::Span<char> *buf) {
122    if (!msg.data()) return;
123    assert(buf->data() >= msg.data());
124    if (buf->data() < msg.data()) return;
125    EncodeRawVarint(
126        static_cast<uint64_t>(buf->data() - (msg.data() + msg.size())),
127        msg.size(), &msg);
128  }
129  namespace {
130  uint64_t DecodeVarint(absl::Span<const char> *buf) {
131    uint64_t value = 0;
132    size_t s = 0;
133    while (s < buf->size()) {
134      value |= static_cast<uint64_t>(static_cast<unsigned char>((*buf)[s]) & 0x7f)
135               << 7 * s;
136      if (!((*buf)[s++] & 0x80)) break;
137    }
138    buf->remove_prefix(s);
139    return value;
140  }
141  uint64_t Decode64Bit(absl::Span<const char> *buf) {
142    uint64_t value = 0;
143    size_t s = 0;
144    while (s < buf->size()) {
145      value |= static_cast<uint64_t>(static_cast<unsigned char>((*buf)[s]))
146               << 8 * s;
147      if (++s == sizeof(value)) break;
148    }
149    buf->remove_prefix(s);
150    return value;
151  }
152  uint32_t Decode32Bit(absl::Span<const char> *buf) {
153    uint32_t value = 0;
154    size_t s = 0;
155    while (s < buf->size()) {
156      value |= static_cast<uint32_t>(static_cast<unsigned char>((*buf)[s]))
157               << 8 * s;
158      if (++s == sizeof(value)) break;
159    }
160    buf->remove_prefix(s);
161    return value;
162  }
163  }  
164  bool ProtoField::DecodeFrom(absl::Span<const char> *data) {
165    if (data->empty()) return false;
166    const uint64_t tag_type = DecodeVarint(data);
167    tag_ = tag_type >> 3;
168    type_ = static_cast<WireType>(tag_type & 0x07);
169    switch (type_) {
170      case WireType::kVarint:
171        value_ = DecodeVarint(data);
172        break;
173      case WireType::k64Bit:
174        value_ = Decode64Bit(data);
175        break;
176      case WireType::kLengthDelimited: {
177        value_ = DecodeVarint(data);
178        data_ = data->subspan(
179            0, static_cast<size_t>(std::min<uint64_t>(value_, data->size())));
180        data->remove_prefix(data_.size());
181        break;
182      }
183      case WireType::k32Bit:
184        value_ = Decode32Bit(data);
185        break;
186    }
187    return true;
188  }
189  }  
190  ABSL_NAMESPACE_END
191  }  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-osdetect.cpp</h3>
            <pre><code>1  #include <tesseract/osdetect.h>
2  #include "blobbox.h"
3  #include "blread.h"
4  #include "colfind.h"
5  #include "fontinfo.h"
6  #include "imagefind.h"
7  #include "linefind.h"
8  #include "oldlist.h"
9  #include "qrsequence.h"
10  #include "ratngs.h"
11  #include "tabvector.h"
12  #include "tesseractclass.h"
13  #include "textord.h"
14  #include <algorithm>
15  #include <cmath> 
16  #include <memory>
17  namespace tesseract {
18  const float kSizeRatioToReject = 2.0;
19  const int kMinAcceptableBlobHeight = 10;
20  const float kScriptAcceptRatio = 1.3;
21  const float kHanRatioInKorean = 0.7;
22  const float kHanRatioInJapanese = 0.3;
23  const float kNonAmbiguousMargin = 1.0;
24  static const char *han_script = "Han";
25  static const char *latin_script = "Latin";
26  static const char *katakana_script = "Katakana";
27  static const char *hiragana_script = "Hiragana";
28  static const char *hangul_script = "Hangul";
29  const char *ScriptDetector::korean_script_ = "Korean";
30  const char *ScriptDetector::japanese_script_ = "Japanese";
31  const char *ScriptDetector::fraktur_script_ = "Fraktur";
32  void OSResults::update_best_orientation() {
33    float first = orientations[0];
34    float second = orientations[1];
35    best_result.orientation_id = 0;
36    if (orientations[0] < orientations[1]) {
37      first = orientations[1];
38      second = orientations[0];
39      best_result.orientation_id = 1;
40    }
41    for (int i = 2; i < 4; ++i) {
42      if (orientations[i] > first) {
43        second = first;
44        first = orientations[i];
45        best_result.orientation_id = i;
46      } else if (orientations[i] > second) {
47        second = orientations[i];
48      }
49    }
50    best_result.oconfidence = first - second;
51  }
52  void OSResults::set_best_orientation(int orientation_id) {
53    best_result.orientation_id = orientation_id;
54    best_result.oconfidence = 0;
55  }
56  void OSResults::update_best_script(int orientation) {
57    float first = scripts_na[orientation][1];
58    float second = scripts_na[orientation][2];
59    best_result.script_id = 1;
60    if (scripts_na[orientation][1] < scripts_na[orientation][2]) {
61      first = scripts_na[orientation][2];
62      second = scripts_na[orientation][1];
63      best_result.script_id = 2;
64    }
65    for (int i = 3; i < kMaxNumberOfScripts; ++i) {
66      if (scripts_na[orientation][i] > first) {
67        best_result.script_id = i;
68        second = first;
69        first = scripts_na[orientation][i];
70      } else if (scripts_na[orientation][i] > second) {
71        second = scripts_na[orientation][i];
72      }
73    }
74    best_result.sconfidence =
75        (second == 0.0f) ? 2.0f : (first / second - 1.0) / (kScriptAcceptRatio - 1.0);
76  }
77  int OSResults::get_best_script(int orientation_id) const {
78    int max_id = -1;
79    for (int j = 0; j < kMaxNumberOfScripts; ++j) {
80      const char *script = unicharset->get_script_from_script_id(j);
81      if (strcmp(script, "Common") && strcmp(script, "NULL")) {
82        if (max_id == -1 || scripts_na[orientation_id][j] > scripts_na[orientation_id][max_id]) {
83          max_id = j;
84        }
85      }
86    }
87    return max_id;
88  }
89  void OSResults::print_scores(void) const {
90    for (int i = 0; i < 4; ++i) {
91      tprintf("Orientation id #%d", i);
92      print_scores(i);
93    }
94  }
95  void OSResults::print_scores(int orientation_id) const {
96    for (int j = 0; j < kMaxNumberOfScripts; ++j) {
97      if (scripts_na[orientation_id][j]) {
98        tprintf("%12s\t: %f\n", unicharset->get_script_from_script_id(j),
99                scripts_na[orientation_id][j]);
100      }
101    }
102  }
103  void OSResults::accumulate(const OSResults &osr) {
104    for (int i = 0; i < 4; ++i) {
105      orientations[i] += osr.orientations[i];
106      for (int j = 0; j < kMaxNumberOfScripts; ++j) {
107        scripts_na[i][j] += osr.scripts_na[i][j];
108      }
109    }
110    unicharset = osr.unicharset;
<span onclick='openModal()' class='match'>111    update_best_orientation();
112    update_best_script(best_result.orientation_id);
113  }
114  static void remove_nontext_regions(tesseract::Tesseract *tess, BLOCK_LIST *blocks,
115                                     TO_BLOCK_LIST *to_blocks) {
116    Image pix = tess->pix_binary();
117    ASSERT_HOST(pix != nullptr);
118    int vertical_x = 0;
</span>119    int vertical_y = 1;
120    tesseract::TabVector_LIST v_lines;
121    tesseract::TabVector_LIST h_lines;
122    int resolution;
123    if (kMinCredibleResolution > pixGetXRes(pix)) {
124      resolution = kMinCredibleResolution;
125      tprintf("Warning. Invalid resolution %d dpi. Using %d instead.\n", pixGetXRes(pix), resolution);
126    } else {
127      resolution = pixGetXRes(pix);
128    }
129    tesseract::LineFinder::FindAndRemoveLines(resolution, false, pix, &vertical_x, &vertical_y,
130                                              nullptr, &v_lines, &h_lines);
131    Image im_pix = tesseract::ImageFind::FindImages(pix, nullptr);
132    if (im_pix != nullptr) {
133      pixSubtract(pix, pix, im_pix);
134      im_pix.destroy();
135    }
136    tess->mutable_textord()->find_components(tess->pix_binary(), blocks, to_blocks);
137  }
138  int orientation_and_script_detection(const char *filename, OSResults *osr,
139                                       tesseract::Tesseract *tess) {
140    std::string name = filename; 
141    const char *lastdot = strrchr(name.c_str(), '.');
142    if (lastdot != nullptr) {
143      name[lastdot - name.c_str()] = '\0';
144    }
145    ASSERT_HOST(tess->pix_binary() != nullptr);
146    int width = pixGetWidth(tess->pix_binary());
147    int height = pixGetHeight(tess->pix_binary());
148    BLOCK_LIST blocks;
149    if (!read_unlv_file(name, width, height, &blocks)) {
150      FullPageBlock(width, height, &blocks);
151    }
152    TO_BLOCK_LIST land_blocks, port_blocks;
153    remove_nontext_regions(tess, &blocks, &port_blocks);
154    if (port_blocks.empty()) {
155      tess->mutable_textord()->find_components(tess->pix_binary(), &blocks, &port_blocks);
156    } else {
157      TBOX page_box(0, 0, width, height);
158      tess->mutable_textord()->filter_blobs(page_box.topright(), &port_blocks, true);
159    }
160    return os_detect(&port_blocks, osr, tess);
161  }
162  int os_detect(TO_BLOCK_LIST *port_blocks, OSResults *osr, tesseract::Tesseract *tess) {
163    int blobs_total = 0;
164    TO_BLOCK_IT block_it;
165    block_it.set_to_list(port_blocks);
166    BLOBNBOX_CLIST filtered_list;
167    BLOBNBOX_C_IT filtered_it(&filtered_list);
168    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
169      TO_BLOCK *to_block = block_it.data();
170      if (to_block->block->pdblk.poly_block() && !to_block->block->pdblk.poly_block()->IsText()) {
171        continue;
172      }
173      BLOBNBOX_IT bbox_it;
174      bbox_it.set_to_list(&to_block->blobs);
175      for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
176        BLOBNBOX *bbox = bbox_it.data();
177        C_BLOB *blob = bbox->cblob();
178        TBOX box = blob->bounding_box();
179        ++blobs_total;
180        if (box.width() == 0) {
181          continue;
182        }
183        float y_x = std::fabs((box.height() * 1.0f) / box.width());
184        float x_y = 1.0f / y_x;
185        float ratio = x_y > y_x ? x_y : y_x;
186        if (ratio > kSizeRatioToReject) {
187          continue;
188        }
189        if (box.height() < kMinAcceptableBlobHeight) {
190          continue;
191        }
192        filtered_it.add_to_end(bbox);
193      }
194    }
195    return os_detect_blobs(nullptr, &filtered_list, osr, tess);
196  }
197  int os_detect_blobs(const std::vector<int> *allowed_scripts, BLOBNBOX_CLIST *blob_list,
198                      OSResults *osr, tesseract::Tesseract *tess) {
199    OSResults osr_;
200    int minCharactersToTry = tess->min_characters_to_try;
201    int maxCharactersToTry = 5 * minCharactersToTry;
202    if (osr == nullptr) {
203      osr = &osr_;
204    }
205    osr->unicharset = &tess->unicharset;
206    OrientationDetector o(allowed_scripts, osr);
207    ScriptDetector s(allowed_scripts, osr, tess);
208    BLOBNBOX_C_IT filtered_it(blob_list);
209    int real_max = std::min(filtered_it.length(), maxCharactersToTry);
210    if (real_max < minCharactersToTry / 2) {
211      tprintf("Too few characters. Skipping this page\n");
212      return 0;
213    }
214    auto **blobs = new BLOBNBOX *[filtered_it.length()];
215    int number_of_blobs = 0;
216    for (filtered_it.mark_cycle_pt(); !filtered_it.cycled_list(); filtered_it.forward()) {
217      blobs[number_of_blobs++] = filtered_it.data();
218    }
219    QRSequenceGenerator sequence(number_of_blobs);
220    int num_blobs_evaluated = 0;
221    for (int i = 0; i < real_max; ++i) {
222      if (os_detect_blob(blobs[sequence.GetVal()], &o, &s, osr, tess) && i > minCharactersToTry) {
223        break;
224      }
225      ++num_blobs_evaluated;
226    }
227    delete[] blobs;
228    int orientation = o.get_orientation();
229    osr->update_best_script(orientation);
230    return num_blobs_evaluated;
231  }
232  bool os_detect_blob(BLOBNBOX *bbox, OrientationDetector *o, ScriptDetector *s, OSResults *osr,
233                      tesseract::Tesseract *tess) {
234    tess->tess_cn_matching.set_value(true); 
235    tess->tess_bn_matching.set_value(false);
236    C_BLOB *blob = bbox->cblob();
237    TBLOB *tblob = TBLOB::PolygonalCopy(tess->poly_allow_detailed_fx, blob);
238    TBOX box = tblob->bounding_box();
239    FCOORD current_rotation(1.0f, 0.0f);
240    FCOORD rotation90(0.0f, 1.0f);
241    BLOB_CHOICE_LIST ratings[4];
242    for (int i = 0; i < 4; ++i) {
243      float scaling = static_cast<float>(kBlnXHeight) / box.height();
244      float x_origin = (box.left() + box.right()) / 2.0f;
245      float y_origin = (box.bottom() + box.top()) / 2.0f;
246      if (i == 0 || i == 2) {
247        y_origin = i == 0 ? box.bottom() : box.top();
248      } else {
249        scaling = static_cast<float>(kBlnXHeight) / box.width();
250        x_origin = i == 1 ? box.left() : box.right();
251      }
252      std::unique_ptr<TBLOB> rotated_blob(new TBLOB(*tblob));
253      rotated_blob->Normalize(nullptr, &current_rotation, nullptr, x_origin, y_origin, scaling,
254                              scaling, 0.0f, static_cast<float>(kBlnBaselineOffset), false, nullptr);
255      tess->AdaptiveClassifier(rotated_blob.get(), ratings + i);
256      current_rotation.rotate(rotation90);
257    }
258    delete tblob;
259    bool stop = o->detect_blob(ratings);
260    s->detect_blob(ratings);
261    int orientation = o->get_orientation();
262    stop = s->must_stop(orientation) && stop;
263    return stop;
264  }
265  OrientationDetector::OrientationDetector(const std::vector<int> *allowed_scripts, OSResults *osr) {
266    osr_ = osr;
267    allowed_scripts_ = allowed_scripts;
268  }
269  bool OrientationDetector::detect_blob(BLOB_CHOICE_LIST *scores) {
270    float blob_o_score[4] = {0.0f, 0.0f, 0.0f, 0.0f};
271    float total_blob_o_score = 0.0f;
272    for (int i = 0; i < 4; ++i) {
273      BLOB_CHOICE_IT choice_it(scores + i);
274      if (!choice_it.empty()) {
275        BLOB_CHOICE *choice = nullptr;
276        if (allowed_scripts_ != nullptr && !allowed_scripts_->empty()) {
277          for (choice_it.mark_cycle_pt(); !choice_it.cycled_list() && choice == nullptr;
278               choice_it.forward()) {
279            int choice_script = choice_it.data()->script_id();
280            unsigned s = 0;
281            for (s = 0; s < allowed_scripts_->size(); ++s) {
282              if ((*allowed_scripts_)[s] == choice_script) {
283                choice = choice_it.data();
284                break;
285              }
286            }
287          }
288        } else {
289          choice = choice_it.data();
290        }
291        if (choice != nullptr) {
292          blob_o_score[i] = 1 + 0.05 * choice->certainty();
293          total_blob_o_score += blob_o_score[i];
294        }
295      }
296    }
297    if (total_blob_o_score == 0.0) {
298      return false;
299    }
300    float worst_score = 0.0f;
301    int num_good_scores = 0;
302    for (float f : blob_o_score) {
303      if (f > 0.0f) {
304        ++num_good_scores;
305        if (worst_score == 0.0f || f < worst_score) {
306          worst_score = f;
307        }
308      }
309    }
310    if (num_good_scores == 1) {
311      worst_score /= 2.0f;
312    }
313    for (float &f : blob_o_score) {
314      if (f == 0.0f) {
315        f = worst_score;
316        total_blob_o_score += worst_score;
317      }
318    }
319    for (int i = 0; total_blob_o_score != 0 && i < 4; ++i) {
320      osr_->orientations[i] += std::log(blob_o_score[i] / total_blob_o_score);
321    }
322    return false;
323  }
324  int OrientationDetector::get_orientation() {
325    osr_->update_best_orientation();
326    return osr_->best_result.orientation_id;
327  }
328  ScriptDetector::ScriptDetector(const std::vector<int> *allowed_scripts, OSResults *osr,
329                                 tesseract::Tesseract *tess) {
330    osr_ = osr;
331    tess_ = tess;
332    allowed_scripts_ = allowed_scripts;
333    katakana_id_ = tess_->unicharset.add_script(katakana_script);
334    hiragana_id_ = tess_->unicharset.add_script(hiragana_script);
335    han_id_ = tess_->unicharset.add_script(han_script);
336    hangul_id_ = tess_->unicharset.add_script(hangul_script);
337    japanese_id_ = tess_->unicharset.add_script(japanese_script_);
338    korean_id_ = tess_->unicharset.add_script(korean_script_);
339    latin_id_ = tess_->unicharset.add_script(latin_script);
340    fraktur_id_ = tess_->unicharset.add_script(fraktur_script_);
341  }
342  void ScriptDetector::detect_blob(BLOB_CHOICE_LIST *scores) {
343    for (int i = 0; i < 4; ++i) {
344      std::vector<bool> done(kMaxNumberOfScripts);
345      BLOB_CHOICE_IT choice_it;
346      choice_it.set_to_list(scores + i);
347      float prev_score = -1;
348      int script_count = 0;
349      int prev_id = -1;
350      int prev_fontinfo_id = -1;
351      const char *prev_unichar = "";
352      const char *unichar = "";
353      for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
354        BLOB_CHOICE *choice = choice_it.data();
355        int id = choice->script_id();
356        if (allowed_scripts_ != nullptr && !allowed_scripts_->empty()) {
357          size_t s = 0;
358          for (s = 0; s < allowed_scripts_->size(); ++s) {
359            if ((*allowed_scripts_)[s] == id) {
360              break;
361            }
362          }
363          if (s == allowed_scripts_->size()) {
364            continue; 
365          }
366        }
367        if (done.at(id)) {
368          continue;
369        }
370        done[id] = true;
371        unichar = tess_->unicharset.id_to_unichar(choice->unichar_id());
372        if (prev_score < 0) {
373          prev_score = -choice->certainty();
374          script_count = 1;
375          prev_id = id;
376          prev_unichar = unichar;
377          prev_fontinfo_id = choice->fontinfo_id();
378        } else if (-choice->certainty() < prev_score + kNonAmbiguousMargin) {
379          ++script_count;
380        }
381        if (strlen(prev_unichar) == 1) {
382          if (unichar[0] >= '0' && unichar[0] <= '9') {
383            break;
384          }
385        }
386        if (script_count >= 2) {
387          break;
388        }
389      }
390      if (script_count == 1) {
391        osr_->scripts_na[i][prev_id] += 1.0;
392        if (prev_id == latin_id_) {
393          if (prev_fontinfo_id >= 0) {
394            const tesseract::FontInfo &fi = tess_->get_fontinfo_table().at(prev_fontinfo_id);
395            if (fi.is_fraktur()) {
396              osr_->scripts_na[i][prev_id] -= 1.0;
397              osr_->scripts_na[i][fraktur_id_] += 1.0;
398            }
399          }
400        }
401        if (prev_id == katakana_id_) {
402          osr_->scripts_na[i][japanese_id_] += 1.0;
403        }
404        if (prev_id == hiragana_id_) {
405          osr_->scripts_na[i][japanese_id_] += 1.0;
406        }
407        if (prev_id == hangul_id_) {
408          osr_->scripts_na[i][korean_id_] += 1.0;
409        }
410        if (prev_id == han_id_) {
411          osr_->scripts_na[i][korean_id_] += kHanRatioInKorean;
412          osr_->scripts_na[i][japanese_id_] += kHanRatioInJapanese;
413        }
414      }
415    } 
416  }
417  bool ScriptDetector::must_stop(int orientation) const {
418    osr_->update_best_script(orientation);
419    return osr_->best_result.sconfidence > 1;
420  }
421  int OrientationIdToValue(const int &id) {
422    switch (id) {
423      case 0:
424        return 0;
425      case 1:
426        return 270;
427      case 2:
428        return 180;
429      case 3:
430        return 90;
431      default:
432        return -1;
433    }
434  }
435  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-proto.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-osdetect.cpp</div>
                </div>
                <div class="column column_space"><pre><code>22    return tag << 3 | static_cast<uint64_t>(type);
23  }
24  }  
25  bool EncodeVarint(uint64_t tag, uint64_t value, absl::Span<char> *buf) {
26    const uint64_t tag_type = MakeTagType(tag, WireType::kVarint);
27    const size_t tag_type_size = VarintSize(tag_type);
</pre></code></div>
                <div class="column column_space"><pre><code>111    update_best_orientation();
112    update_best_script(best_result.orientation_id);
113  }
114  static void remove_nontext_regions(tesseract::Tesseract *tess, BLOCK_LIST *blocks,
115                                     TO_BLOCK_LIST *to_blocks) {
116    Image pix = tess->pix_binary();
117    ASSERT_HOST(pix != nullptr);
118    int vertical_x = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    