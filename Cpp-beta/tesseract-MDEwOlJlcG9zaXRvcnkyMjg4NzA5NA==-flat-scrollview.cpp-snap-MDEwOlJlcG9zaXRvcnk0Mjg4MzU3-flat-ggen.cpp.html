
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.037097654118931%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scrollview.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "scrollview.h"
5  #include "svutil.h" 
6  #include <allheaders.h>
7  #include <algorithm>
8  #include <climits>
9  #include <cstdarg>
10  #include <cstring>
11  #include <map>
12  #include <memory> 
13  #include <mutex> 
14  #include <string>
15  #include <thread> 
16  #include <utility>
17  #include <vector>
18  namespace tesseract {
19  const int kSvPort = 8461;
20  const int kMaxMsgSize = 4096;
21  const int kMaxIntPairSize = 45; 
22  struct SVPolyLineBuffer {
23    bool empty; 
24    std::vector<int> xcoords;
25    std::vector<int> ycoords;
26  };
27  static std::map<int, ScrollView *> svmap;
28  static std::mutex *svmap_mu;
29  static std::map<std::pair<ScrollView *, SVEventType>,
30                  std::pair<SVSemaphore *, std::unique_ptr<SVEvent>>> waiting_for_events;
31  static std::mutex *waiting_for_events_mu;
32  std::unique_ptr<SVEvent> SVEvent::copy() const {
33    auto any = std::unique_ptr<SVEvent>(new SVEvent);
34    any->command_id = command_id;
35    any->counter = counter;
36    any->parameter = new char[strlen(parameter) + 1];
37    strcpy(any->parameter, parameter);
38    any->type = type;
39    any->x = x;
40    any->y = y;
41    any->x_size = x_size;
42    any->y_size = y_size;
43    any->window = window;
44    return any;
45  }
46  SVEventHandler::~SVEventHandler() = default;
47  #ifndef GRAPHICS_DISABLED
48  void ScrollView::MessageReceiver() {
49    int counter_event_id = 0; 
50    char *message = nullptr;
51    do {
52      message = ScrollView::GetStream()->Receive();
53    } while (message == nullptr);
54    while (true) {
55      std::unique_ptr<SVEvent> cur(new SVEvent);
56      int window_id;
57      int ev_type;
58      int n;
59      sscanf(message, "%d,%d,%d,%d,%d,%d,%d,%n", &window_id, &ev_type, &cur->x, &cur->y, &cur->x_size,
60             &cur->y_size, &cur->command_id, &n);
61      char *p = (message + n);
62      svmap_mu->lock();
63      cur->window = svmap[window_id];
64      if (cur->window != nullptr) {
65        auto length = strlen(p);
66        cur->parameter = new char[length + 1];
67        strcpy(cur->parameter, p);
68        if (length > 0) { 
69          cur->parameter[length - 1] = '\0';
70        }
71        cur->type = static_cast<SVEventType>(ev_type);
72        if (cur->x_size > 0) {
73          cur->x -= cur->x_size;
74        } else {
75          cur->x_size = -cur->x_size;
76        }
77        if (cur->y_size > 0) {
78          cur->y -= cur->y_size;
79        } else {
80          cur->y_size = -cur->y_size;
81        }
82        if (cur->window->y_axis_is_reversed_) {
83          cur->y = cur->window->TranslateYCoordinate(cur->y + cur->y_size);
84        }
85        cur->counter = counter_event_id;
86        counter_event_id += 2;
87        if (ev_type == SVET_EXIT) {
88          SendRawMessage("svmain:exit()");
89          break;
90        }
91        cur->window->SetEvent(cur.get());
92        std::pair<ScrollView *, SVEventType> awaiting_list(cur->window, cur->type);
93        std::pair<ScrollView *, SVEventType> awaiting_list_any(cur->window, SVET_ANY);
94        std::pair<ScrollView *, SVEventType> awaiting_list_any_window((ScrollView *)nullptr,
95                                                                      SVET_ANY);
96        waiting_for_events_mu->lock();
97        if (waiting_for_events.count(awaiting_list) > 0) {
98          waiting_for_events[awaiting_list].second = std::move(cur);
99          waiting_for_events[awaiting_list].first->Signal();
100        } else if (waiting_for_events.count(awaiting_list_any) > 0) {
101          waiting_for_events[awaiting_list_any].second = std::move(cur);
102          waiting_for_events[awaiting_list_any].first->Signal();
103        } else if (waiting_for_events.count(awaiting_list_any_window) > 0) {
104          waiting_for_events[awaiting_list_any_window].second = std::move(cur);
105          waiting_for_events[awaiting_list_any_window].first->Signal();
106        }
107        waiting_for_events_mu->unlock();
108        ScrollView *sv = svmap[window_id];
109        if (sv != nullptr) {
110          sv->Signal();
111          sv->Signal();
112        }
113      }
114      svmap_mu->unlock();
115      do {
116        message = ScrollView::GetStream()->Receive();
117      } while (message == nullptr);
118    }
119  }
120  static const uint8_t table_colors[ScrollView::GREEN_YELLOW + 1][4] = {
121      {0, 0, 0, 0},         
122      {0, 0, 0, 255},       
123      {255, 255, 255, 255}, 
124      {255, 0, 0, 255},     
125      {255, 255, 0, 255},   
126      {0, 255, 0, 255},     
127      {0, 255, 255, 255},   
128      {0, 0, 255, 255},     
129      {255, 0, 255, 255},   
130      {0, 128, 255, 255},   
131      {0, 0, 64, 255},      
132      {128, 128, 255, 255}, 
133      {64, 64, 255, 255},   
134      {0, 0, 32, 255},      
135      {0, 0, 128, 255},     
136      {192, 192, 255, 255}, 
137      {64, 64, 128, 255},   
138      {32, 32, 64, 255},    
139      {255, 128, 128, 255}, 
140      {128, 64, 0, 255},    
141      {128, 128, 0, 255},   
142      {192, 192, 0, 255},   
143      {192, 192, 128, 255}, 
144      {0, 64, 0, 255},      
145      {32, 64, 0, 255},     
146      {64, 128, 0, 255},    
147      {128, 255, 0, 255},   
148      {192, 255, 192, 255}, 
149      {192, 255, 0, 255},   
150      {192, 192, 192, 255}, 
151      {64, 64, 128, 255},   
152      {64, 64, 64, 255},    
153      {128, 128, 128, 255}, 
154      {64, 192, 0, 255},    
155      {255, 0, 192, 255},   
156      {255, 128, 0, 255},   
157      {255, 128, 64, 255},  
158      {255, 192, 192, 255}, 
159      {128, 0, 128, 255},   
160      {255, 0, 64, 255},    
161      {255, 64, 0, 255},    
162      {255, 0, 192, 255},   
163      {255, 192, 128, 255}, 
164      {128, 128, 0, 255},   
165      {0, 255, 255, 255},   
166      {0, 128, 128, 255},   
167      {192, 0, 255, 255},   
168      {128, 128, 0, 255},   
169      {128, 255, 0, 255}    
170  };
171  SVNetwork *ScrollView::stream_ = nullptr;
172  int ScrollView::nr_created_windows_ = 0;
173  int ScrollView::image_index_ = 0;
174  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
175                         int x_canvas_size, int y_canvas_size, bool y_axis_reversed,
176                         const char *server_name) {
177    Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size, y_axis_reversed,
178               server_name);
<span onclick='openModal()' class='match'>179  }
180  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
181                         int x_canvas_size, int y_canvas_size, bool y_axis_reversed) {
</span>182    Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size, y_axis_reversed,
183               "localhost");
184  }
185  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
186                         int x_canvas_size, int y_canvas_size) {
187    Initialize(name, x_pos, y_pos, x_size, y_size, x_canvas_size, y_canvas_size, false, "localhost");
188  }
189  void ScrollView::Initialize(const char *name, int x_pos, int y_pos, int x_size, int y_size,
190                              int x_canvas_size, int y_canvas_size, bool y_axis_reversed,
191                              const char *server_name) {
192    if (stream_ == nullptr) {
193      nr_created_windows_ = 0;
194      stream_ = new SVNetwork(server_name, kSvPort);
195      waiting_for_events_mu = new std::mutex();
196      svmap_mu = new std::mutex();
197      SendRawMessage("svmain = luajava.bindClass('com.google.scrollview.ScrollView')\n");
198      std::thread t(&ScrollView::MessageReceiver);
199      t.detach();
200    }
201    nr_created_windows_++;
202    event_handler_ = nullptr;
203    event_handler_ended_ = false;
204    y_axis_is_reversed_ = y_axis_reversed;
205    y_size_ = y_canvas_size;
206    window_name_ = name;
207    window_id_ = nr_created_windows_;
208    points_ = new SVPolyLineBuffer;
209    points_->empty = true;
210    svmap_mu->lock();
211    svmap[window_id_] = this;
212    svmap_mu->unlock();
213    for (auto &i : event_table_) {
214      i = nullptr;
215    }
216    semaphore_ = new SVSemaphore();
217    char message[kMaxMsgSize];
218    snprintf(message, sizeof(message),
219             "w%u = luajava.newInstance('com.google.scrollview.ui"
220             ".SVWindow','%s',%u,%u,%u,%u,%u,%u,%u)\n",
221             window_id_, window_name_, window_id_, x_pos, y_pos, x_size, y_size, x_canvas_size,
222             y_canvas_size);
223    SendRawMessage(message);
224    std::thread t(&ScrollView::StartEventHandler, this);
225    t.detach();
226  }
227  void ScrollView::StartEventHandler() {
228    for (;;) {
229      stream_->Flush();
230      semaphore_->Wait();
231      int serial = -1;
232      int k = -1;
233      mutex_.lock();
234      for (int i = 0; i < SVET_COUNT; i++) {
235        if (event_table_[i] != nullptr && (serial < 0 || event_table_[i]->counter < serial)) {
236          serial = event_table_[i]->counter;
237          k = i;
238        }
239      }
240      if (k != -1) {
241        auto new_event = std::move(event_table_[k]);
242        mutex_.unlock();
243        if (event_handler_ != nullptr) {
244          event_handler_->Notify(new_event.get());
245        }
246        if (new_event->type == SVET_DESTROY) {
247          event_handler_ended_ = true;
248          return;
249        }
250      } else {
251        mutex_.unlock();
252      }
253    }
254  }
255  #endif 
256  ScrollView::~ScrollView() {
257  #ifndef GRAPHICS_DISABLED
258    svmap_mu->lock();
259    if (svmap[window_id_] != nullptr) {
260      svmap_mu->unlock();
261      SendMsg("destroy()");
262      AwaitEvent(SVET_DESTROY);
263      svmap_mu->lock();
264      svmap[window_id_] = nullptr;
265      svmap_mu->unlock();
266      while (!event_handler_ended_) {
267        Update();
268      }
269    } else {
270      svmap_mu->unlock();
271    }
272    delete semaphore_;
273    delete points_;
274  #endif 
275  }
276  #ifndef GRAPHICS_DISABLED
277  void ScrollView::SendMsg(const char *format, ...) {
278    if (!points_->empty) {
279      SendPolygon();
280    }
281    va_list args;
282    char message[kMaxMsgSize - 4];
283    va_start(args, format); 
284    vsnprintf(message, sizeof(message), format, args);
285    va_end(args);
286    char form[kMaxMsgSize];
287    snprintf(form, sizeof(form), "w%u:%s\n", window_id_, message);
288    stream_->Send(form);
289  }
290  void ScrollView::SendRawMessage(const char *msg) {
291    stream_->Send(msg);
292  }
293  void ScrollView::AddEventHandler(SVEventHandler *listener) {
294    event_handler_ = listener;
295  }
296  void ScrollView::Signal() {
297    semaphore_->Signal();
298  }
299  void ScrollView::SetEvent(const SVEvent *svevent) {
300    auto any = svevent->copy();
301    auto specific = svevent->copy();
302    any->counter = specific->counter + 1;
303    std::lock_guard<std::mutex> guard(mutex_);
304    event_table_[specific->type] = std::move(specific);
305    event_table_[SVET_ANY] = std::move(any);
306  }
307  std::unique_ptr<SVEvent> ScrollView::AwaitEvent(SVEventType type) {
308    auto *sem = new SVSemaphore();
309    std::pair<ScrollView *, SVEventType> ea(this, type);
310    waiting_for_events_mu->lock();
311    waiting_for_events[ea] = {sem, nullptr};
312    waiting_for_events_mu->unlock();
313    stream_->Flush();
314    sem->Wait();
315    waiting_for_events_mu->lock();
316    auto ret = std::move(waiting_for_events[ea].second);
317    waiting_for_events.erase(ea);
318    delete sem;
319    waiting_for_events_mu->unlock();
320    return ret;
321  }
322  void ScrollView::SendPolygon() {
323    if (!points_->empty) {
324      points_->empty = true; 
325      int length = points_->xcoords.size();
326      if (length == 2) {
327        SendMsg("drawLine(%d,%d,%d,%d)", points_->xcoords[0], points_->ycoords[0],
328                points_->xcoords[1], points_->ycoords[1]);
329      } else if (length > 2) {
330        SendMsg("createPolyline(%d)", length);
331        char coordpair[kMaxIntPairSize];
332        std::string decimal_coords;
333        for (int i = 0; i < length; ++i) {
334          snprintf(coordpair, kMaxIntPairSize, "%d,%d,", points_->xcoords[i], points_->ycoords[i]);
335          decimal_coords += coordpair;
336        }
337        decimal_coords += '\n';
338        SendRawMessage(decimal_coords.c_str());
339        SendMsg("drawPolyline()");
340      }
341      points_->xcoords.clear();
342      points_->ycoords.clear();
343    }
344  }
345  void ScrollView::SetCursor(int x, int y) {
346    SendPolygon();
347    DrawTo(x, y);
348  }
349  void ScrollView::DrawTo(int x, int y) {
350    points_->xcoords.push_back(x);
351    points_->ycoords.push_back(TranslateYCoordinate(y));
352    points_->empty = false;
353  }
354  void ScrollView::Line(int x1, int y1, int x2, int y2) {
355    if (!points_->xcoords.empty() && x1 == points_->xcoords.back() &&
356        TranslateYCoordinate(y1) == points_->ycoords.back()) {
357      DrawTo(x2, y2);
358    } else if (!points_->xcoords.empty() && x2 == points_->xcoords.back() &&
359               TranslateYCoordinate(y2) == points_->ycoords.back()) {
360      DrawTo(x1, y1);
361    } else {
362      SetCursor(x1, y1);
363      DrawTo(x2, y2);
364    }
365  }
366  void ScrollView::SetVisible(bool visible) {
367    if (visible) {
368      SendMsg("setVisible(true)");
369    } else {
370      SendMsg("setVisible(false)");
371    }
372  }
373  void ScrollView::AlwaysOnTop(bool b) {
374    if (b) {
375      SendMsg("setAlwaysOnTop(true)");
376    } else {
377      SendMsg("setAlwaysOnTop(false)");
378    }
379  }
380  void ScrollView::AddMessage(const char *message) {
381    char form[kMaxMsgSize];
382    snprintf(form, sizeof(form), "w%u:%s", window_id_, message);
383    char *esc = AddEscapeChars(form);
384    SendMsg("addMessage(\"%s\")", esc);
385    delete[] esc;
386  }
387  void ScrollView::AddMessageF(const char *format, ...) {
388    va_list args;
389    char message[kMaxMsgSize - 4];
390    va_start(args, format); 
391    vsnprintf(message, sizeof(message), format, args);
392    va_end(args);
393    AddMessage(message);
394  }
395  void ScrollView::AddMessageBox() {
396    SendMsg("addMessageBox()");
397  }
398  void ScrollView::Exit() {
399    SendRawMessage("svmain:exit()");
400    exit(0);
401  }
402  void ScrollView::Clear() {
403    SendMsg("clear()");
404  }
405  void ScrollView::Stroke(float width) {
406    SendMsg("setStrokeWidth(%f)", width);
407  }
408  void ScrollView::Rectangle(int x1, int y1, int x2, int y2) {
409    if (x1 == x2 && y1 == y2) {
410      return; 
411    }
412    SendMsg("drawRectangle(%d,%d,%d,%d)", x1, TranslateYCoordinate(y1), x2, TranslateYCoordinate(y2));
413  }
414  void ScrollView::Ellipse(int x1, int y1, int width, int height) {
415    SendMsg("drawEllipse(%d,%d,%u,%u)", x1, TranslateYCoordinate(y1), width, height);
416  }
417  void ScrollView::Pen(int red, int green, int blue) {
418    SendMsg("pen(%d,%d,%d)", red, green, blue);
419  }
420  void ScrollView::Pen(int red, int green, int blue, int alpha) {
421    SendMsg("pen(%d,%d,%d,%d)", red, green, blue, alpha);
422  }
423  void ScrollView::Brush(int red, int green, int blue) {
424    SendMsg("brush(%d,%d,%d)", red, green, blue);
425  }
426  void ScrollView::Brush(int red, int green, int blue, int alpha) {
427    SendMsg("brush(%d,%d,%d,%d)", red, green, blue, alpha);
428  }
429  void ScrollView::TextAttributes(const char *font, int pixel_size, bool bold, bool italic,
430                                  bool underlined) {
431    const char *b;
432    const char *i;
433    const char *u;
434    if (bold) {
435      b = "true";
436    } else {
437      b = "false";
438    }
439    if (italic) {
440      i = "true";
441    } else {
442      i = "false";
443    }
444    if (underlined) {
445      u = "true";
446    } else {
447      u = "false";
448    }
449    SendMsg("textAttributes('%s',%u,%s,%s,%s)", font, pixel_size, b, i, u);
450  }
451  void ScrollView::Text(int x, int y, const char *mystring) {
452    SendMsg("drawText(%d,%d,'%s')", x, TranslateYCoordinate(y), mystring);
453  }
454  void ScrollView::Draw(const char *image, int x_pos, int y_pos) {
455    SendMsg("openImage('%s')", image);
456    SendMsg("drawImage('%s',%d,%d)", image, x_pos, TranslateYCoordinate(y_pos));
457  }
458  void ScrollView::MenuItem(const char *parent, const char *name, int cmdEvent, bool flag) {
459    if (parent == nullptr) {
460      parent = "";
461    }
462    if (flag) {
463      SendMsg("addMenuBarItem('%s','%s',%d,true)", parent, name, cmdEvent);
464    } else {
465      SendMsg("addMenuBarItem('%s','%s',%d,false)", parent, name, cmdEvent);
466    }
467  }
468  void ScrollView::MenuItem(const char *parent, const char *name, int cmdEvent) {
469    if (parent == nullptr) {
470      parent = "";
471    }
472    SendMsg("addMenuBarItem('%s','%s',%d)", parent, name, cmdEvent);
473  }
474  void ScrollView::MenuItem(const char *parent, const char *name) {
475    if (parent == nullptr) {
476      parent = "";
477    }
478    SendMsg("addMenuBarItem('%s','%s')", parent, name);
479  }
480  void ScrollView::PopupItem(const char *parent, const char *name) {
481    if (parent == nullptr) {
482      parent = "";
483    }
484    SendMsg("addPopupMenuItem('%s','%s')", parent, name);
485  }
486  void ScrollView::PopupItem(const char *parent, const char *name, int cmdEvent, const char *value,
487                             const char *desc) {
488    if (parent == nullptr) {
489      parent = "";
490    }
491    char *esc = AddEscapeChars(value);
492    char *esc2 = AddEscapeChars(desc);
493    SendMsg("addPopupMenuItem('%s','%s',%d,'%s','%s')", parent, name, cmdEvent, esc, esc2);
494    delete[] esc;
495    delete[] esc2;
496  }
497  void ScrollView::UpdateWindow() {
498    SendMsg("update()");
499  }
500  void ScrollView::Update() {
501    std::lock_guard<std::mutex> guard(*svmap_mu);
502    for (auto &iter : svmap) {
503      if (iter.second != nullptr) {
504        iter.second->UpdateWindow();
505      }
506    }
507  }
508  void ScrollView::Pen(Color color) {
509    Pen(table_colors[color][0], table_colors[color][1], table_colors[color][2],
510        table_colors[color][3]);
511  }
512  void ScrollView::Brush(Color color) {
513    Brush(table_colors[color][0], table_colors[color][1], table_colors[color][2],
514          table_colors[color][3]);
515  }
516  char *ScrollView::ShowInputDialog(const char *msg) {
517    SendMsg("showInputDialog(\"%s\")", msg);
518    auto ev = AwaitEvent(SVET_INPUT);
519    char *p = new char[strlen(ev->parameter) + 1];
520    strcpy(p, ev->parameter);
521    return p;
522  }
523  int ScrollView::ShowYesNoDialog(const char *msg) {
524    SendMsg("showYesNoDialog(\"%s\")", msg);
525    auto ev = AwaitEvent(SVET_INPUT);
526    int a = ev->parameter[0];
527    return a;
528  }
529  void ScrollView::ZoomToRectangle(int x1, int y1, int x2, int y2) {
530    y1 = TranslateYCoordinate(y1);
531    y2 = TranslateYCoordinate(y2);
532    SendMsg("zoomRectangle(%d,%d,%d,%d)", std::min(x1, x2), std::min(y1, y2), std::max(x1, x2),
533            std::max(y1, y2));
534  }
535  void ScrollView::Draw(Image image, int x_pos, int y_pos) {
536    l_uint8 *data;
537    size_t size;
538    pixWriteMem(&data, &size, image, IFF_PNG);
539    int base64_len = (size + 2) / 3 * 4;
540    y_pos = TranslateYCoordinate(y_pos);
541    SendMsg("readImage(%d,%d,%d)", x_pos, y_pos, base64_len);
542    const char kBase64Table[64] = {
543        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
544        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
545        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
546        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
547    };
548    char *base64 = new char[base64_len + 1];
549    memset(base64, '=', base64_len);
550    base64[base64_len] = '\0';
551    int remainder = 0;
552    int bits_left = 0;
553    int code_len = 0;
554    for (size_t i = 0; i < size; ++i) {
555      int code = (data[i] >> (bits_left + 2)) | remainder;
556      base64[code_len++] = kBase64Table[code & 63];
557      bits_left += 2;
558      remainder = data[i] << (6 - bits_left);
559      if (bits_left == 6) {
560        base64[code_len++] = kBase64Table[remainder & 63];
561        bits_left = 0;
562        remainder = 0;
563      }
564    }
565    if (bits_left > 0) {
566      base64[code_len++] = kBase64Table[remainder & 63];
567    }
568    SendRawMessage(base64);
569    delete[] base64;
570    lept_free(data);
571  }
572  char *ScrollView::AddEscapeChars(const char *input) {
573    const char *nextptr = strchr(input, '\'');
574    const char *lastptr = input;
575    char *message = new char[kMaxMsgSize];
576    int pos = 0;
577    while (nextptr != nullptr) {
578      strncpy(message + pos, lastptr, nextptr - lastptr);
579      pos += nextptr - lastptr;
580      message[pos] = '\\';
581      pos += 1;
582      lastptr = nextptr;
583      nextptr = strchr(nextptr + 1, '\'');
584    }
585    strcpy(message + pos, lastptr);
586    return message;
587  }
588  int ScrollView::TranslateYCoordinate(int y) {
589    if (!y_axis_is_reversed_) {
590      return y;
591    } else {
592      return y_size_ - y;
593    }
594  }
595  char ScrollView::Wait() {
596    char ret = '\0';
597    SVEventType ev_type = SVET_ANY;
598    do {
599      std::unique_ptr<SVEvent> ev(AwaitEvent(SVET_ANY));
600      ev_type = ev->type;
601      if (ev_type == SVET_INPUT) {
602        ret = ev->parameter[0];
603      }
604    } while (ev_type != SVET_INPUT && ev_type != SVET_CLICK);
605    return ret;
606  }
607  #endif 
608  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ggen.cpp</h3>
            <pre><code>1  namespace TSnap {
2  PBPGraph GenRndBipart(const int& LeftNodes, const int& RightNodes, const int& Edges, TRnd& Rnd) {
3    PBPGraph G = TBPGraph::New();
4    for (int i = 0; i < LeftNodes; i++) { G->AddNode(i, true); }
5    for (int i = 0; i < RightNodes; i++) { G->AddNode(LeftNodes+i, false); }
6    IAssertR(Edges <= LeftNodes*RightNodes, "Too many edges in the bipartite graph!");
7    for (int edges = 0; edges < Edges; ) {
8      const int LNId = Rnd.GetUniDevInt(LeftNodes);
9      const int RNId = LeftNodes + Rnd.GetUniDevInt(RightNodes);
10      if (G->AddEdge(LNId, RNId) != -2) { edges++; } 
11    }
12    return G;
13  }
14  PUNGraph GenRndDegK(const int& Nodes, const int& NodeDeg, const int& NSwitch, TRnd& Rnd) {
15    TIntV DegV(Nodes, 0);
16    int DegSum=0;
17    for (int i = 0; i < Nodes; i++) {
18      DegV.Add(NodeDeg);
19      DegSum += NodeDeg;
20    }
21    IAssert(DegSum % 2 == 0);
22    PUNGraph G = GenDegSeq(DegV, Rnd); 
23    return GenRewire(G, NSwitch, Rnd);  
24  }
25  PUNGraph GenRndPowerLaw(const int& Nodes, const double& PowerExp, const bool& ConfModel, TRnd& Rnd) {
26    TIntV DegSeqV;
27    uint DegSum=0;
28    for (int n = 0; n < Nodes; n++) {
29      const int Val = (int) TMath::Round(Rnd.GetPowerDev(PowerExp));
30      if (! (Val >= 1 && Val < Nodes/2)) { n--; continue; } 
31      DegSeqV.Add(Val);
32      DegSum += Val;
33    }
34    printf("%d nodes, %u edges\n", Nodes, DegSum);
35    if (DegSum % 2 == 1) { DegSeqV[0] += 1; }
36    if (ConfModel) {
37      return GenConfModel(DegSeqV, Rnd);
38    } else {
39      DegSeqV.Sort();
40      DegSeqV.Reverse();
41      PUNGraph G = TSnap::GenDegSeq(DegSeqV, Rnd);
42      return TSnap::GenRewire(G, 10, Rnd);
43    }
44  }
45  PUNGraph GenDegSeq(const TIntV& DegSeqV, TRnd& Rnd) {
46    const int Nodes = DegSeqV.Len();
47    PUNGraph GraphPt = TUNGraph::New();
48    TUNGraph& Graph = *GraphPt;
49    Graph.Reserve(Nodes, -1);
50    TIntH DegH(DegSeqV.Len(), true);
51    IAssertR(DegSeqV.IsSorted(false), "DegSeqV must be sorted in descending order.");
52    int DegSum=0, edge=0;
53    for (int node = 0; node < Nodes; node++) {
54      IAssert(Graph.AddNode(node) == node);
55      DegH.AddDat(node, DegSeqV[node]);
56      DegSum += DegSeqV[node];
57    }
58    IAssert(DegSum % 2 == 0);
59    while (! DegH.Empty()) {
60      const int NId1 = DegH.GetKey(DegH.GetRndKeyId(Rnd, 0.5));
61      const int NId2 = DegH.GetKey(DegH.GetRndKeyId(Rnd, 0.5));
62      IAssert(DegH.IsKey(NId1) && DegH.IsKey(NId2));
63      if (NId1 == NId2) {
64        if (DegH.GetDat(NId1) == 1) { continue; }
65        const TIntPr Edge = TSnapDetail::GetRndEdgeNonAdjNode(GraphPt, NId1, -1);
66        if (Edge.Val1==-1) { continue; }
67        Graph.DelEdge(Edge.Val1, Edge.Val2);
68        Graph.AddEdge(Edge.Val1, NId1);
69        Graph.AddEdge(NId1, Edge.Val2);
70        if (DegH.GetDat(NId1) == 2) { DegH.DelKey(NId1); }
71        else { DegH.GetDat(NId1) -= 2; }
72      } else {
73        if (! Graph.IsEdge(NId1, NId2)) {
74          Graph.AddEdge(NId1, NId2); }  
75        else {
76          const TIntPr Edge = TSnapDetail::GetRndEdgeNonAdjNode(GraphPt, NId1, NId2);
77          if (Edge.Val1==-1) { continue; }
78          Graph.DelEdge(Edge.Val1, Edge.Val2);
79          Graph.AddEdge(NId1, Edge.Val1);
80          Graph.AddEdge(NId2, Edge.Val2);
81        }
82        if (DegH.GetDat(NId1)==1) { DegH.DelKey(NId1); }
83        else { DegH.GetDat(NId1) -= 1; }
84        if (DegH.GetDat(NId2)==1) { DegH.DelKey(NId2); }
85        else { DegH.GetDat(NId2) -= 1; }
86      }
87      if (++edge % 1000 == 0) {
88        printf("\r %dk / %dk", edge/1000, DegSum/2000); }
89    }
90    return GraphPt;
91  }
92  PUNGraph GenConfModel(const TIntV& DegSeqV, TRnd& Rnd) {
93    const int Nodes = DegSeqV.Len();
94    PUNGraph GraphPt = TUNGraph::New();
95    TUNGraph& Graph = *GraphPt;
96    Graph.Reserve(Nodes, -1);
97    TIntV NIdDegV(DegSeqV.Len(), 0);
98    int DegSum=0, edges=0;
99    for (int node = 0; node < Nodes; node++) {
100      Graph.AddNode(node);
101      for (int d = 0; d < DegSeqV[node]; d++) { NIdDegV.Add(node); }
102      DegSum += DegSeqV[node];
103    }
104    NIdDegV.Shuffle(Rnd);
105    TIntPrSet EdgeH(DegSum/2); 
106    if (DegSum % 2 != 0) {
107      printf("Seg seq is odd [%d]: ", DegSeqV.Len());
108      for (int d = 0; d < TMath::Mn(100, DegSeqV.Len()); d++) { printf("  %d", (int)DegSeqV[d]); }
109      printf("\n");
110    }
111    int u=0, v=0;
112    for (int c = 0; NIdDegV.Len() > 1; c++) {
113      u = Rnd.GetUniDevInt(NIdDegV.Len());
114      while ((v = Rnd.GetUniDevInt(NIdDegV.Len())) == u) { }
115      if (u > v) { Swap(u, v); }
116      const int E1 = NIdDegV[u];
117      const int E2 = NIdDegV[v];
118      if (v == NIdDegV.Len()-1) { NIdDegV.DelLast(); } 
119      else { NIdDegV[v] = NIdDegV.Last();  NIdDegV.DelLast(); }
120      if (u == NIdDegV.Len()-1) { NIdDegV.DelLast(); } 
121      else { NIdDegV[u] = NIdDegV.Last();  NIdDegV.DelLast(); }
122      if (E1 == E2 || EdgeH.IsKey(TIntPr(E1, E2))) { continue; }
123      EdgeH.AddKey(TIntPr(E1, E2));
124      Graph.AddEdge(E1, E2);
125      edges++;
126      if (c % (DegSum/100+1) == 0) { printf("\r configuration model: iter %d: edges: %d, left: %d", c, edges, NIdDegV.Len()/2); }
127    }
128    printf("\n");
129    return GraphPt;
130  }
131  PUNGraph GenRewire(const PUNGraph& OrigGraph, const int& NSwitch, TRnd& Rnd) {
132    const int Nodes = OrigGraph->GetNodes();
133    const int Edges = OrigGraph->GetEdges();
134    PUNGraph GraphPt = TUNGraph::New();
135    TUNGraph& Graph = *GraphPt;
136    Graph.Reserve(Nodes, -1);
137    TExeTm ExeTm;
138    printf("Randomizing edges (%d, %d)...\n", Nodes, Edges);
139    TIntPrSet EdgeSet(Edges);
140    for (TUNGraph::TNodeI NI = OrigGraph->BegNI(); NI < OrigGraph->EndNI(); NI++) {
141      const int NId = NI.GetId();
142      for (int e = 0; e < NI.GetOutDeg(); e++) {
143        if (NId <= NI.GetOutNId(e)) { continue; }
144        EdgeSet.AddKey(TIntPr(NId, NI.GetOutNId(e)));
145      }
146      Graph.AddNode(NI.GetId());
147    }
148    uint skip=0;
149    for (uint swps = 0; swps < 2*uint(Edges)*uint(NSwitch); swps++) {
150      const int keyId1 = EdgeSet.GetRndKeyId(Rnd);
151      const int keyId2 = EdgeSet.GetRndKeyId(Rnd);
152      if (keyId1 == keyId2) { skip++; continue; }
153      const TIntPr& E1 = EdgeSet[keyId1];
154      const TIntPr& E2 = EdgeSet[keyId2];
155      TIntPr NewE1(E1.Val1, E2.Val1), NewE2(E1.Val2, E2.Val2);
156      if (NewE1.Val1 > NewE1.Val2) { Swap(NewE1.Val1, NewE1.Val2); }
157      if (NewE2.Val1 > NewE2.Val2) { Swap(NewE2.Val1, NewE2.Val2); }
158      if (NewE1!=NewE2 && NewE1.Val1!=NewE1.Val2 && NewE2.Val1!=NewE2.Val2 && ! EdgeSet.IsKey(NewE1) && ! EdgeSet.IsKey(NewE2)) {
159        EdgeSet.DelKeyId(keyId1);  EdgeSet.DelKeyId(keyId2);
160        EdgeSet.AddKey(TIntPr(NewE1));
161        EdgeSet.AddKey(TIntPr(NewE2));
162      } else { skip++; }
163      if (swps % Edges == 0) {
164        printf("\r  %uk/%uk: %uk skip [%s]", swps/1000u, 2*uint(Edges)*uint(NSwitch)/1000u, skip/1000u, ExeTm.GetStr());
165        if (ExeTm.GetSecs() > 2*3600) { printf(" *** Time limit!\n"); break; } 
166      }
167    }
168    printf("\r  total %uk switchings attempted, %uk skiped  [%s]\n", 2*uint(Edges)*uint(NSwitch)/1000u, skip/1000u, ExeTm.GetStr());
169    for (int e = 0; e < EdgeSet.Len(); e++) {
170      Graph.AddEdge(EdgeSet[e].Val1, EdgeSet[e].Val2); }
171    return GraphPt;
172  }
173  PNGraph GenRewire(const PNGraph& OrigGraph, const int& NSwitch, TRnd& Rnd) {
174    const int Nodes = OrigGraph->GetNodes();
175    const int Edges = OrigGraph->GetEdges();
176    PNGraph GraphPt = TNGraph::New();
177    TNGraph& Graph = *GraphPt;
178    Graph.Reserve(Nodes, -1);
179    TExeTm ExeTm;
180    printf("Randomizing edges (%d, %d)...\n", Nodes, Edges);
181    TIntPrSet EdgeSet(Edges);
182    for (TNGraph::TNodeI NI = OrigGraph->BegNI(); NI < OrigGraph->EndNI(); NI++) {
183      const int NId = NI.GetId();
184      for (int e = 0; e < NI.GetOutDeg(); e++) {
185        EdgeSet.AddKey(TIntPr(NId, NI.GetOutNId(e))); }
186      Graph.AddNode(NI);
187    }
188    uint skip=0;
189    for (uint swps = 0; swps < 2*uint(Edges)*uint(NSwitch); swps++) {
190      const int keyId1 = EdgeSet.GetRndKeyId(Rnd);
191      const int keyId2 = EdgeSet.GetRndKeyId(Rnd);
192      if (keyId1 == keyId2) { skip++; continue; }
193      const TIntPr& E1 = EdgeSet[keyId1];
194      const TIntPr& E2 = EdgeSet[keyId2];
195      TIntPr NewE1(E1.Val1, E2.Val2), NewE2(E2.Val1, E1.Val2);
196      if (NewE1.Val1!=NewE1.Val2 && NewE2.Val1!=NewE2.Val2 && NewE1.Val1!=NewE2.Val1 && NewE1.Val2!=NewE2.Val2 && ! EdgeSet.IsKey(NewE1) && ! EdgeSet.IsKey(NewE2)) {
197        EdgeSet.DelKeyId(keyId1);  EdgeSet.DelKeyId(keyId2);
198        EdgeSet.AddKey(TIntPr(NewE1));
199        EdgeSet.AddKey(TIntPr(NewE2));
200      } else { skip++; }
201      if (swps % Edges == 0) {
202        printf("\r  %uk/%uk: %uk skip [%s]", swps/1000u, 2*uint(Edges)*uint(NSwitch)/1000u, skip/1000u, ExeTm.GetStr());
203        if (ExeTm.GetSecs() > 2*3600) { printf(" *** Time limit!\n"); break; } 
204      }
205    }
206    printf("\r  total %uk switchings attempted, %uk skiped  [%s]\n", 2*uint(Edges)*uint(NSwitch)/1000u, skip/1000u, ExeTm.GetStr());
207    for (int e = 0; e < EdgeSet.Len(); e++) {
208      Graph.AddEdge(EdgeSet[e].Val1, EdgeSet[e].Val2); }
209    return GraphPt;
210  }
211  PBPGraph GenRewire(const PBPGraph& OrigGraph, const int& NSwitch, TRnd& Rnd) {
212    const int Nodes = OrigGraph->GetNodes();
213    const int Edges = OrigGraph->GetEdges();
214    PBPGraph GraphPt = TBPGraph::New();
215    TBPGraph& Graph = *GraphPt;
216    Graph.Reserve(Nodes, -1);
217    TExeTm ExeTm;
218    printf("Randomizing edges (%d, %d)...\n", Nodes, Edges);
219    TIntPrSet EdgeSet(Edges);
220    for (TBPGraph::TNodeI NI = OrigGraph->BegLNI(); NI < OrigGraph->EndLNI(); NI++) {
221      const int NId = NI.GetId();
222      for (int e = 0; e < NI.GetOutDeg(); e++) {
223        EdgeSet.AddKey(TIntPr(NId, NI.GetOutNId(e))); } 
224      Graph.AddNode(NI.GetId(), true); } 
225    for (TBPGraph::TNodeI NI = OrigGraph->BegRNI(); NI < OrigGraph->EndRNI(); NI++) {
226      Graph.AddNode(NI.GetId(), false); } 
227    IAssert(EdgeSet.Len() == Edges);
228    uint skip=0;
229    for (uint swps = 0; swps < 2*uint(Edges)*uint(NSwitch); swps++) {
230      const int keyId1 = EdgeSet.GetRndKeyId(Rnd);
231      const int keyId2 = EdgeSet.GetRndKeyId(Rnd);
232      if (keyId1 == keyId2) { skip++; continue; }
233      const TIntPr& E1 = EdgeSet[keyId1];
234      const TIntPr& E2 = EdgeSet[keyId2];
235      TIntPr NewE1(E1.Val1, E2.Val2), NewE2(E2.Val1, E1.Val2);
236      if (NewE1!=NewE2 && NewE1.Val1!=NewE1.Val2 && NewE2.Val1!=NewE2.Val2 && ! EdgeSet.IsKey(NewE1) && ! EdgeSet.IsKey(NewE2)) {
237        EdgeSet.DelKeyId(keyId1);  EdgeSet.DelKeyId(keyId2);
238        EdgeSet.AddKey(TIntPr(NewE1));
239        EdgeSet.AddKey(TIntPr(NewE2));
240      } else { skip++; }
241      if (swps % Edges == 0) {
242        printf("\r  %uk/%uk: %uk skip [%s]", swps/1000u, 2*uint(Edges)*uint(NSwitch)/1000u, skip/1000u, ExeTm.GetStr());
243        if (ExeTm.GetSecs() > 2*3600) { printf(" *** Time limit!\n"); break; } 
244      }
245    }
246    printf("\r  total %uk switchings attempted, %uk skiped  [%s]\n", 2*uint(Edges)*uint(NSwitch)/1000u, skip/1000u, ExeTm.GetStr());
247    for (int e = 0; e < EdgeSet.Len(); e++) {
248      Graph.AddEdge(EdgeSet[e].Val1, EdgeSet[e].Val2); }
249    return GraphPt;
250  }
251  PUNGraph GenPrefAttach(const int& Nodes, const int& NodeOutDeg, TRnd& Rnd) {
252    PUNGraph GraphPt = PUNGraph::New();
253    TUNGraph& Graph = *GraphPt;
254    Graph.Reserve(Nodes, NodeOutDeg*Nodes);
255    TIntV NIdV(NodeOutDeg*Nodes, 0);
256    Graph.AddNode(0);  Graph.AddNode(1);
257    NIdV.Add(0);  NIdV.Add(1);
258    Graph.AddEdge(0, 1);
259    TIntSet NodeSet;
260    for (int node = 2; node < Nodes; node++) {
261      NodeSet.Clr(false);
262      while (NodeSet.Len() < NodeOutDeg && NodeSet.Len() < node) {
263        NodeSet.AddKey(NIdV[Rnd.GetUniDevInt(NIdV.Len())]);
264      }
265      const int N = Graph.AddNode();
266      for (int i = 0; i < NodeSet.Len(); i++) {
267        Graph.AddEdge(N, NodeSet[i]);
268        NIdV.Add(N);
269        NIdV.Add(NodeSet[i]);
270      }
271    }
272    return GraphPt;
273  }
274  PUNGraph GenConfModel(const PUNGraph& G) {
275    TIntV DegSeqV(G->GetNodes(), 0);
276    TSnap::GetDegSeqV(G, DegSeqV);
277    return TSnap::GenConfModel(DegSeqV);
278  }
279  namespace TSnapDetail {
280  void GetSphereDev(const int& Dim, TRnd& Rnd, TFltV& ValV) {
281    if (ValV.Len() != Dim) { ValV.Gen(Dim); }
282    double Length = 0.0;
283    for (int i = 0; i < Dim; i++) {
284      ValV[i] = Rnd.GetNrmDev();
285      Length += TMath::Sqr(ValV[i]); }
286    Length = 1.0 / sqrt(Length);
287    for (int i = 0; i < Dim; i++) {
288      ValV[i] *= Length;
289    }
290  }
291  } 
292  PUNGraph GenGeoPrefAttach(const int& Nodes, const int& OutDeg, const double& Beta, TRnd& Rnd) {
293    PUNGraph G = TUNGraph::New(Nodes, Nodes*OutDeg);
294    TFltTrV PointV(Nodes, 0);
295    TFltV ValV;
296    const double Rad = 0.5 * TMath::Pi;
297    for (int i = 0; i < Nodes; i++) {
298      TSnapDetail::GetSphereDev(3, Rnd, ValV);
299      PointV.Add(TFltTr(Rad*ValV[0], Rad*ValV[1], Rad*ValV[2]));
300    }
301    const double R2 = TMath::Sqr(log((double) Nodes) / (pow((double) Nodes, 0.5-Beta)));
302    TIntV DegV, NIdV;
303    int SumDeg;
304    for (int t = 0; t < Nodes; t++) {
305      const int pid = t;
306      const TFltTr& P1 = PointV[pid];
307      if (! G->IsNode(pid)) { G->AddNode(pid); }
308      DegV.Clr(false);  NIdV.Clr(false);  SumDeg=0;
309      for (int p = 0; p < t; p++) {
310        const TFltTr& P2 = PointV[p];
311        if (TMath::Sqr(P1.Val1-P2.Val1)+TMath::Sqr(P1.Val2-P2.Val2)+TMath::Sqr(P1.Val3-P2.Val3) < R2) {
312          NIdV.Add(p);
313          DegV.Add(G->GetNI(p).GetDeg()+1);
314          SumDeg += DegV.Last();
315        }
316      }
317      for (int m = 0; m < OutDeg; m++) {
318        const int rnd = Rnd.GetUniDevInt(SumDeg);
319        int sum = 0, dst = -1;
320        for (int s = 0; s < DegV.Len(); s++) {
321          sum += DegV[s];
322          if (rnd < sum) { dst=s;  break; }
323        }
324        if (dst != -1) {
325          G->AddEdge(pid, NIdV[dst]);
326          SumDeg -= DegV[dst];
327          NIdV.Del(dst);  DegV.Del(dst);
328        }
329      }
330    }
331    return G;
332  }
333  PUNGraph GenSmallWorld(const int& Nodes, const int& NodeOutDeg, const double& RewireProb, TRnd& Rnd) {
334    THashSet<TIntPr> EdgeSet(Nodes*NodeOutDeg);
335    IAssertR(Nodes > NodeOutDeg, TStr::Fmt("Insufficient nodes for out degree, %d!", NodeOutDeg));
336    for (int node = 0; node < Nodes; node++) {
337      const int src = node;
338      for (int edge = 1; edge <= NodeOutDeg; edge++) {
339        int dst = (node+edge) % Nodes;      
340        if (Rnd.GetUniDev() < RewireProb) { 
341          dst = Rnd.GetUniDevInt(Nodes);
342          while (dst == src || EdgeSet.IsKey(TIntPr(src, dst))) {
343            dst = Rnd.GetUniDevInt(Nodes); }
344        }
345        EdgeSet.AddKey(TIntPr(src, dst));
346      }
347    }
348    PUNGraph GraphPt = TUNGraph::New();
349    TUNGraph& Graph = *GraphPt;
350    Graph.Reserve(Nodes, EdgeSet.Len());
351    int node;
352    for (node = 0; node < Nodes; node++) {
353      IAssert(Graph.AddNode(node) == node);
354    }
355    for (int edge = 0; edge < EdgeSet.Len(); edge++) {
356      Graph.AddEdge(EdgeSet[edge].Val1, EdgeSet[edge].Val2);
357    }
358    Graph.Defrag();
359    return GraphPt;
360  }
361  PNGraph GenForestFire(const int& Nodes, const double& FwdProb, const double& BckProb) {
362    return TForestFire::GenGraph(Nodes, FwdProb, BckProb);
363  }
364  PNGraph GenCopyModel(const int& Nodes, const double& Beta, TRnd& Rnd) {
365    PNGraph GraphPt = TNGraph::New();
366    TNGraph& Graph = *GraphPt;
367    Graph.Reserve(Nodes, Nodes);
368    const int startNId = Graph.AddNode();
369    Graph.AddEdge(startNId, startNId);
370    for (int n = 1; n < Nodes; n++) {
371      const int rnd = Graph.GetRndNId();
372      const int NId = Graph.AddNode();
373      if (Rnd.GetUniDev() < Beta) {
374        Graph.AddEdge(NId, rnd); }
375      else {
376        const TNGraph::TNodeI NI = Graph.GetNI(rnd);
377        const int rnd2 = Rnd.GetUniDevInt(NI.GetOutDeg());
378        Graph.AddEdge(NId, NI.GetOutNId(rnd2));
379      }
380    }
381    return GraphPt;
<span onclick='openModal()' class='match'>382  }
383  PNGraph GenRMat(const int& Nodes, const int& Edges, const double& A, const double& B, const double& C, TRnd& Rnd) {
384    PNGraph GraphPt = TNGraph::New();
</span>385    TNGraph& Graph = *GraphPt;
386    Graph.Reserve(Nodes, Edges);
387    IAssert(A+B+C < 1.0);
388    int rngX, rngY, offX, offY;
389    int Depth=0, Collisions=0, Cnt=0, PctDone=0;
390    const int EdgeGap = Edges / 100 + 1;
391    TVec<double> sumA(128, 0), sumAB(128, 0), sumAC(128, 0), sumABC(128, 0);  
392    for (int i = 0; i < 128; i++) {
393      const double a = A * (Rnd.GetUniDev() + 0.5);
394      const double b = B * (Rnd.GetUniDev() + 0.5);
395      const double c = C * (Rnd.GetUniDev() + 0.5);
396      const double d = (1.0 - (A+B+C)) * (Rnd.GetUniDev() + 0.5);
397      const double abcd = a+b+c+d;
398      sumA.Add(a / abcd);
399      sumAB.Add((a+b) / abcd);
400      sumAC.Add((a+c) / abcd);
401      sumABC.Add((a+b+c) / abcd);
402    }
403    for (int node = 0; node < Nodes; node++) {
404      IAssert(Graph.AddNode(-1) == node);
405    }
406    for (int edge = 0; edge < Edges; ) {
407      rngX = Nodes;  rngY = Nodes;  offX = 0;  offY = 0;
408      Depth = 0;
409      while (rngX > 1 || rngY > 1) {
410        const double RndProb = Rnd.GetUniDev();
411        if (rngX>1 && rngY>1) {
412          if (RndProb < sumA[Depth]) { rngX/=2; rngY/=2; }
413          else if (RndProb < sumAB[Depth]) { offX+=rngX/2;  rngX-=rngX/2;  rngY/=2; }
414          else if (RndProb < sumABC[Depth]) { offY+=rngY/2;  rngX/=2;  rngY-=rngY/2; }
415          else { offX+=rngX/2;  offY+=rngY/2;  rngX-=rngX/2;  rngY-=rngY/2; }
416        } else
417        if (rngX>1) { 
418          if (RndProb < sumAC[Depth]) { rngX/=2; rngY/=2; }
419          else { offX+=rngX/2;  rngX-=rngX/2;  rngY/=2; }
420        } else
421        if (rngY>1) { 
422          if (RndProb < sumAB[Depth]) { rngX/=2; rngY/=2; }
423          else { offY+=rngY/2;  rngX/=2;  rngY-=rngY/2; }
424        } else { Fail; }
425        Depth++;
426      }
427      const int NId1 = offX;
428      const int NId2 = offY;
429      if (NId1 != NId2 && ! Graph.IsEdge(NId1, NId2)) {
430        Graph.AddEdge(NId1, NId2);
431        if (++Cnt > EdgeGap) {
432          Cnt=0;  printf("\r  %d%% edges", ++PctDone); }
433        edge++;
434      } else {
435        Collisions++; }
436    }
437    printf("\r  RMat: nodes:%d, edges:%d, Iterations:%d, Collisions:%d (%.1f%%).\n", Nodes, Edges,
438      Edges+Collisions, Collisions, 100*Collisions/double(Edges+Collisions));
439    Graph.Defrag();
440    return GraphPt;
441  }
442  PNGraph GenRMatEpinions() {
443    return GenRMat(75888, 508837, 0.550, 0.228, 0.212);
444  }
445  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scrollview.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ggen.cpp</div>
                </div>
                <div class="column column_space"><pre><code>179  }
180  ScrollView::ScrollView(const char *name, int x_pos, int y_pos, int x_size, int y_size,
181                         int x_canvas_size, int y_canvas_size, bool y_axis_reversed) {
</pre></code></div>
                <div class="column column_space"><pre><code>382  }
383  PNGraph GenRMat(const int& Nodes, const int& Edges, const double& A, const double& B, const double& C, TRnd& Rnd) {
384    PNGraph GraphPt = TNGraph::New();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    