
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.8763931104356635%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-BabyGrid.cpp</h3>
            <pre><code>1  #include "BabyGrid.h"
2  #include "Parameters.h"
3  #define MAX_GRIDS 20
4  #define MAX_ROWS 32000
5  #define MAX_COLS 256
6  HFONT hfontbody,hfontheader,hfonttitle;
7  HFONT holdfont;
8  struct _gridhandlestruct
9  	{
10          HMENU gridmenu;
11  		HWND hlist1;
12  		TCHAR protect[2];
13          TCHAR title[305];
14          TCHAR editstring[305];
15          TCHAR editstringdisplay[305];
16  		int rows;
17  		int cols;
18  		int gridwidth;
19  		int gridheight;
20  		int homerow;
21  		int homecol;
22  		int rowheight;
23  		int leftvisiblecol;
24  		int rightvisiblecol;
25  		int topvisiblerow;
26  		int bottomvisiblerow;
27  		int headerrowheight;
28  		int cursorrow;
29  		int cursorcol;
30          int ownerdrawitem;
31          int visiblecolumns;
32          int titleheight;
33          int fontascentheight;
34  		COLORREF cursorcolor;
35  		COLORREF protectcolor;
36  		COLORREF unprotectcolor;
37  		COLORREF textcolor;
38  		COLORREF highlightcolor;
39  		COLORREF highlightcolorNoFocus;
40  		COLORREF highlightcolorProtect;
41  		COLORREF highlightcolorProtectNoFocus;
42  		COLORREF gridlinecolor;
43          COLORREF highlighttextcolor;
44          COLORREF backgroundcolor;
45          COLORREF titletextcolor;
46          COLORREF titlecolor;
47          COLORREF titlegridlinecolor;
48  		BOOL DRAWHIGHLIGHT;
49          BOOL ADVANCEROW;
50          BOOL CURRENTCELLPROTECTED;
51  		BOOL GRIDHASFOCUS;
52          BOOL AUTOROW;
53          RECT activecellrect;
54          HFONT hfont;
55          HFONT hcolumnheadingfont;
56          HFONT htitlefont;
57  		BOOL ROWSNUMBERED;
58  		BOOL COLUMNSNUMBERED;
59          BOOL EDITABLE;
60          BOOL EDITING;
61          BOOL EXTENDLASTCOLUMN;
62          BOOL HSCROLL;
63          BOOL VSCROLL;
64          BOOL SHOWINTEGRALROWS;
65          BOOL ELLIPSIS;
66          BOOL COLAUTOWIDTH;
67          BOOL COLUMNSIZING;
68          BOOL ALLOWCOLUMNRESIZING;
69          int columntoresize;
70          int columntoresizeinitsize;
71          int columntoresizeinitx;
72          int cursortype;
73  		int columnwidths[MAX_COLS+1];
74          BOOL REMEMBERINTEGRALROWS;
75  		BOOL INITIALCONTENT;
76      } BGHS[MAX_GRIDS];
77  _BGCELL BGcell,*LPBGcell;
78  int BG_GridIndex;
79  int FindResult;
80  TCHAR data[1000];
81  CREATESTRUCT cs,*lpcs;
82  int         AddGrid(HMENU);
83  int         FindGrid(HMENU);
84  void		ShowVscroll(HWND,int);
85  void		ShowHscroll(HWND,int);
86  int         BinarySearchListBox(HWND,TCHAR*);
87  void        DisplayEditString(HWND ,int , const TCHAR*);
88  int         CountGrids();
89  int HomeColumnNthVisible(int SI)
90      {
91       int j,hc,count;
92       count=0;
93       hc=BGHS[SI].homecol;
94       for(j=1;j<=hc;++j)
95           {
96            if(BGHS[SI].columnwidths[j]>0)
97                {
98                 ++count;
99                }
100           }
101       return count;
102      }
103  void RefreshGrid(HWND hWnd)
104  	{
105  	 RECT rect;
106       int SI;
107  	 GetClientRect(hWnd,&rect);
108  	 InvalidateRect(hWnd,&rect,FALSE);
109  	 SI=FindGrid(GetMenu(hWnd));
110       if(BGHS[SI].EDITING)
111           {
112            DisplayEditString(hWnd, SI, TEXT(""));
113           }
114  	}
115  int GetNextColWithWidth(int SI, int startcol, int direction)
116      {
117       int j;
118       int ReturnValue;
119       j=startcol;
120       if(direction == 1){j++;}
121       if(direction != 1){j--;}
122       while((j>0)&&(j<=BGHS[SI].cols)&&(BGHS[SI].columnwidths[j] == 0))
123           {
124           if(direction == 1){j++;}
125           if(direction != 1){j--;}
126           }
127       if((j<=BGHS[SI].cols)&&(BGHS[SI].columnwidths[j] > 0))
128           {
129            ReturnValue = j;
130           }
131       else
132           {
133            ReturnValue = 0;
134           }
135       return ReturnValue;
136      }
137  int GetRowOfMouse(int SI,int y)
138  	{
139  	 int ReturnValue;
140  	 if(y<=(BGHS[SI].titleheight))
141  		 {
142  		  return -1;
143  		 }
144  	 if((y>=BGHS[SI].titleheight)&&(y<=BGHS[SI].headerrowheight + BGHS[SI].titleheight))
145  		 {
146  		  return 0;
147  		 }
148  	 y=y-(BGHS[SI].headerrowheight + BGHS[SI].titleheight);
149  	 y=y/BGHS[SI].rowheight;
150  	 ReturnValue = BGHS[SI].homerow + y;
151  	 if(ReturnValue > BGHS[SI].rows){ReturnValue = -1;}
152  	 return ReturnValue;
153  	}
154  int GetColOfMouse(int SI,int x)
155  	{
156  	 int ReturnValue;
157  	 int j;
158  	 if(x<=BGHS[SI].columnwidths[0])
159  		 {
160  		  return 0;
161  		 }
162  	 x-=BGHS[SI].columnwidths[0];
163  	 j=BGHS[SI].homecol;
164  	 while(x>0)
165  		 {
166  		  x-=BGHS[SI].columnwidths[j];
167  		  j++;
168  		 }
169  	 j--;
170  	 ReturnValue = j;
171       if(BGHS[SI].EXTENDLASTCOLUMN)
172           {
173  	      if(j>BGHS[SI].cols){ReturnValue = BGHS[SI].cols;}
174           }
175       else
176           {
177            if(j>BGHS[SI].cols){ReturnValue = -1;}
178           }
179  	 return ReturnValue;
180  	}
181  BOOL OutOfRange(_BGCELL *cell)
182      {
183        if((cell->row > MAX_ROWS)||(cell->col > MAX_COLS))
184            {return TRUE;}
185        else
186            {return FALSE;}
187      }
188  void SetCell(_BGCELL *cell,int row, int col)
189  	{
190  	 cell->row = row;
191  	 cell->col = col;
192  	}
193  void CalcVisibleCellBoundaries(int SelfIndex)
194  {
195   int gridx,gridy;
196   int j;
197   gridx=BGHS[SelfIndex].gridwidth;
198   gridy=BGHS[SelfIndex].gridheight;
199   j=	BGHS[SelfIndex].homecol;
200   BGHS[SelfIndex].leftvisiblecol = BGHS[SelfIndex].homecol;
201   BGHS[SelfIndex].topvisiblerow = BGHS[SelfIndex].homerow;
202   gridx = gridx - BGHS[SelfIndex].columnwidths[0];
203   do
204   {
205    gridx = gridx - BGHS[SelfIndex].columnwidths[j];
206    j++;
207   }while ((gridx >= 0)&&(j<BGHS[SelfIndex].cols));
208   if(j>BGHS[SelfIndex].cols){j=BGHS[SelfIndex].cols;}
209   BGHS[SelfIndex].rightvisiblecol = j;
210   gridy = gridy - BGHS[SelfIndex].headerrowheight;
211   j=	BGHS[SelfIndex].homerow;
212   do
213   {
214    gridy = gridy - BGHS[SelfIndex].rowheight;
215    j++;
216   }while ((gridy > 0)&&(j<BGHS[SelfIndex].rows));
217   if(j>BGHS[SelfIndex].rows){j=BGHS[SelfIndex].rows;}
218   BGHS[SelfIndex].bottomvisiblerow = j;
219  }
220  RECT GetCellRect(HWND hWnd,int SI, int r, int c)
221  	{
222  	 RECT rect;
223  	 int offset;
224  	 int j;
225  	   offset=BGHS[SI].columnwidths[0];
226  	   for(j=BGHS[SI].homecol;j<c;j++)
227  		   {
228  			offset += BGHS[SI].columnwidths[j];
229  		   }
230  	   rect.left = offset;
231  	   rect.right = offset + BGHS[SI].columnwidths[c];
232      if(BGHS[SI].EXTENDLASTCOLUMN)
233          {
234  	        if(!GetNextColWithWidth(SI,c,1))
235  		        {
236  		         RECT trect;
237  		         int temp;
238  		         GetClientRect(hWnd,&trect);
239  		         temp = (offset +(trect.right - rect.left))-rect.left;
240  		         if(temp > BGHS[SI].columnwidths[c])
241  			         {
242  		              rect.right = offset + (trect.right - rect.left);
243  			         }
244  		        }
245          }
246  	   offset = BGHS[SI].headerrowheight+BGHS[SI].titleheight;
247  	   for(j=BGHS[SI].homerow;j<r;j++)
248  		   {
249  			offset += BGHS[SI].rowheight;
250  		   }
251  	   rect.top = offset;
252  	   rect.bottom = offset + BGHS[SI].rowheight;
253  	   return rect;
254  	}
<span onclick='openModal()' class='match'>255  void DisplayTitle(HWND hWnd,int SI,HFONT hfont)
256      {
257       RECT rect;
258       HDC gdc;
259       HFONT holdfont;
260       GetClientRect(hWnd,&rect);
261       gdc=GetDC(hWnd);
262       SetBkMode(gdc,TRANSPARENT);
</span>263       holdfont=(HFONT)SelectObject(gdc,hfont);
264       rect.bottom = BGHS[SI].titleheight;
265  	 DrawEdge(gdc,&rect,EDGE_ETCHED,BF_MIDDLE|BF_RECT|BF_ADJUST);
266  	 DrawTextEx(gdc,BGHS[SI].title,-1,&rect,DT_END_ELLIPSIS|DT_CENTER|DT_WORDBREAK|DT_NOPREFIX,NULL);
267       SelectObject(gdc,holdfont);
268       ReleaseDC(hWnd,gdc);
269      }
270  const size_t bufferLen = 1000;
271  void DisplayColumn(HWND hWnd,int SI,int c,int offset,HFONT hfont,HFONT hcolumnheadingfont)
272  {
273  	HDC gdc;
274  	RECT rect,rectsave;
275      HFONT holdfont;
276  	int r;
277  	TCHAR buffer[bufferLen];
278  	int iDataType,iProtection,iProperty;
279  	if(BGHS[SI].columnwidths[c]==0){return;}
280  	 gdc=GetDC(hWnd);
281  	 SetBkMode(gdc,TRANSPARENT);
282       ShowHscroll(hWnd,SI);
283  	 ShowVscroll(hWnd,SI);
284      holdfont = (HFONT)SelectObject(gdc,hcolumnheadingfont);
285  	SetTextColor(gdc,BGHS[SI].titletextcolor);
286  	r=0;
287  	rect.left = offset + 0;
288  	rect.top = BGHS[SI].titleheight;
289  	rect.right = BGHS[SI].columnwidths[c] + offset;
290  	rect.bottom = BGHS[SI].headerrowheight + BGHS[SI].titleheight;
291      if(BGHS[SI].EXTENDLASTCOLUMN)
292          {
293  	        if(!GetNextColWithWidth(SI,c,1))
294  		        {
295  		         RECT trect;
296  		         GetClientRect(hWnd,&trect);
297  		         rect.right = offset + (trect.right - rect.left);
298  		        }
299          }
300      else
301          {
302           if(!GetNextColWithWidth(SI,c,1))
303               {
304  		         RECT trect;
305                   HBRUSH holdbrush;
306                   HPEN holdpen;
307  		         GetClientRect(hWnd,&trect);
308                   trect.left=offset+(rect.right-rect.left);
309                   holdbrush=(HBRUSH)SelectObject(gdc,GetStockObject(GRAY_BRUSH));
310                   holdpen=(HPEN)SelectObject(gdc,GetStockObject(NULL_PEN));
311                   Rectangle(gdc,trect.left,trect.top+BGHS[SI].titleheight,trect.right+1,trect.bottom+1);
312  		         SelectObject(gdc,holdbrush);
313                   SelectObject(gdc,holdpen);
314               }
315          }
316  	 SetCell(&BGcell,r,c);
317  	 wcscpy_s(buffer, TEXT(""));
318  	 if(BGHS[SI].COLUMNSNUMBERED)
319  	 {
320  	  if(c>0)
321  	  {
322  	   int high,low;
323  	   high = ((c-1)/26);
324  	   low = c % 26;
325  	   if(high == 0){high = 32;}else{high+=64;}
326  	   if(low == 0){low=26;}
327  	   low += 64;
328  	   wsprintf(buffer, TEXT("%c%c"), high,low);
329  	  }
330  	 }
331  	 else
332  		 SendMessage(hWnd, BGM_GETCELLDATA, reinterpret_cast<WPARAM>(&BGcell), reinterpret_cast<LPARAM>(buffer));
333  	 rectsave=rect;
334       HBRUSH hbrushtitle, holdbrushtitle;
335       HPEN hpentitle, holdpentitle;
336       hbrushtitle = CreateSolidBrush(BGHS[SI].titlecolor);
337       hpentitle = CreatePen(PS_SOLID, 1, BGHS[SI].titlegridlinecolor);
338       holdbrushtitle = (HBRUSH)SelectObject(gdc, hbrushtitle);
339       holdpentitle = (HPEN)SelectObject(gdc, hpentitle);
340       Rectangle(gdc, rect.left, rect.top, rect.right, rect.bottom);
341       SelectObject(gdc, holdbrushtitle);
342       SelectObject(gdc, holdpentitle);
343       DeleteObject(hbrushtitle);
344       DeleteObject(hpentitle);
345  	 DrawTextEx(gdc,buffer,-1,&rect,DT_END_ELLIPSIS|DT_CENTER|DT_WORDBREAK|DT_NOPREFIX,NULL);
346  	 rect=rectsave;
347  	 r=BGHS[SI].topvisiblerow;
348       SelectObject(gdc,hfont);
349  	 while(r<=BGHS[SI].bottomvisiblerow)
350  	 {
351               if((r==BGHS[SI].cursorrow)&&(c>0)&&(BGHS[SI].DRAWHIGHLIGHT))
352                   {
353                    if(BGHS[SI].GRIDHASFOCUS)
354                        {
355                         SetTextColor(gdc,BGHS[SI].highlighttextcolor);
356                        }
357                    else
358                        {
359                         SetTextColor(gdc,BGHS[SI].textcolor);
360                        }
361                   }
362               else
363                   {
364                    SetTextColor(gdc,BGHS[SI].textcolor);
365                   }
366  		 rect.top = rect.bottom;
367  		 rect.bottom = rect.top + BGHS[SI].rowheight;
368  		 rectsave=rect;
369  		 SetCell(&BGcell,r,c);
370  		 wcscpy_s(buffer, TEXT(""));
371  		 if((c==0)&&(BGHS[SI].ROWSNUMBERED))
372  		 {
373  		  wsprintf(buffer, TEXT("%d"), r);
374  		  iProperty = 2 << 4; 
375  		 }
376  		 else
377  		  iProperty = static_cast<int32_t>(SendMessage(hWnd, BGM_GETCELLDATA, reinterpret_cast<WPARAM>(&BGcell), reinterpret_cast<LPARAM>(buffer)));
378  		 if(c==0)
379  		 {
380  			 SetTextColor(gdc, BGHS[SI].titletextcolor);
381  			 HBRUSH hbrush, holdbrush;
382  			 HPEN hpen, holdpen;
383  			 hbrush = CreateSolidBrush(BGHS[SI].titlecolor);
384  			 hpen = CreatePen(PS_SOLID, 1, BGHS[SI].titlegridlinecolor);
385  			 holdbrush = (HBRUSH)SelectObject(gdc, hbrush);
386  			 holdpen = (HPEN)SelectObject(gdc, hpen);
387  			 Rectangle(gdc, rect.left, rect.top, rect.right, rect.bottom);
388  			 SelectObject(gdc, holdbrush);
389  			 SelectObject(gdc, holdpen);
390  			 DeleteObject(hbrush);
391  			 DeleteObject(hpen);
392  		 }
393  		 else
394  		 {
395  		  HBRUSH hbrush,holdbrush;
396  		  HPEN hpen,holdpen;
397  		  iProtection = iProperty & 0xf;
398  		  if(BGHS[SI].DRAWHIGHLIGHT)
399  			  {
400  			   if(r==BGHS[SI].cursorrow)
401  				   {
402  				    if(BGHS[SI].GRIDHASFOCUS)
403  						{
404  							if(iProtection == 1)
405  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolorProtect);
406  							else
407  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolor);
408  						}
409  					else
410  						{
411  							if(iProtection == 1)
412  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolorProtectNoFocus);
413  							else
414  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolorNoFocus);
415  						}
416  				   }
417  			   else
418  				  {
419  					  if(iProtection == 1)
420  					  {
421  						hbrush=CreateSolidBrush(BGHS[SI].protectcolor);
422  					  }
423  					  else
424  					  {
425  						hbrush=CreateSolidBrush(BGHS[SI].unprotectcolor);
426  					  }
427  				  }
428  			  }
429  		  else
430  			  {
431  					  if(iProtection == 1)
432  					  {
433  						hbrush=CreateSolidBrush(BGHS[SI].protectcolor);
434  					  }
435  					  else
436  					  {
437  						hbrush=CreateSolidBrush(BGHS[SI].unprotectcolor);
438  					  }
439  			  }
440  		  hpen=CreatePen(PS_SOLID,1,BGHS[SI].gridlinecolor);
441  		  holdbrush=(HBRUSH)SelectObject(gdc,hbrush);
442  		  holdpen=(HPEN)SelectObject(gdc,hpen);
443  		  Rectangle(gdc,rect.left,rect.top,rect.right,rect.bottom);
444  		  SelectObject(gdc,holdbrush);
445  		  SelectObject(gdc,holdpen);
446  		  DeleteObject(hbrush);
447  		  DeleteObject(hpen);
448  		 }
449  		 rect.right -= 2;
450  		 rect.left += 2;
451  		 iDataType = iProperty >> 4 & 0xf;
452           if((iDataType < 1)||(iDataType > 5))
453               {
454                iDataType = 1;
455               }
456  		 if(iDataType == 1)
457  		 {
458            if(BGHS[SI].ELLIPSIS)
459                {
460                DrawTextEx(gdc,buffer,-1,&rect,DT_END_ELLIPSIS|DT_LEFT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX,NULL);
461                }
462            else
463                {
464  			   DrawTextEx(gdc,buffer,-1,&rect,DT_LEFT|DT_WORDBREAK|DT_EDITCONTROL|DT_NOPREFIX,NULL);
465                }
466  		 }
467  		 if(iDataType == 2)
468  		 {
469  		  DrawTextEx(gdc,buffer,-1,&rect,DT_END_ELLIPSIS|DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX,NULL);
470  		 }
471  		 if(iDataType == 3)
472  		 {
473  		  int k,excess;
474  		  k=2;
475  		  rect.top +=k;
476  		  rect.bottom -=k;
477  		  rect.left +=0;
478  		  rect.right -=0;
479            if((rect.bottom - rect.top)>24)
480            {
481                 excess=(rect.bottom - rect.top)-16;
482                 rect.top += excess / 2;
483                 rect.bottom -= excess / 2;
484            }
485  	      DrawFrameControl(gdc,&rect,DFC_BUTTON,DFCS_BUTTONCHECK|DFCS_CHECKED);
486  		 }
487  		 if(iDataType == 4)
488  		 {
489  		  int k,excess;
490  		  k=2;
491  		  rect.top +=k;
492  		  rect.bottom -=k;
493  		  rect.left +=0;
494  		  rect.right -=0;
495            if((rect.bottom - rect.top)>24)
496            {
497                 excess=(rect.bottom - rect.top)-16;
498                 rect.top += excess / 2;
499                 rect.bottom -= excess / 2;
500            }
501  	      DrawFrameControl(gdc,&rect,DFC_BUTTON,DFCS_BUTTONCHECK);
502  		 }
503  		 if(iDataType == 5) 
504  			 {
505  			   WPARAM wParam;
506                 buffer[0]=0x20;
507                 BGHS[SI].ownerdrawitem = _wtoi(buffer);
508  			   wParam=MAKEWPARAM(::GetMenu(hWnd),BGN_OWNERDRAW);
509  			   SendMessage(GetParent(hWnd), WM_COMMAND, wParam, reinterpret_cast<LPARAM>(&rect));
510  			 }
511           if(BGHS[SI].EDITING)
512               {
513                DisplayEditString(hWnd, SI, TEXT(""));
514               }
515           rect=rectsave;
516  	     r++;
517  	 }
518               {
519  		         RECT trect;
520                   HBRUSH holdbrush, hbrush;
521                   HPEN holdpen;
522  		         GetClientRect(hWnd,&trect);
523                   trect.top = rect.bottom;
524                   trect.left = rect.left;
525                   trect.right = rect.right;
526                   hbrush = CreateSolidBrush(BGHS[SI].backgroundcolor);
527                   holdbrush=(HBRUSH)SelectObject(gdc, hbrush);
528                   holdpen=(HPEN)SelectObject(gdc,GetStockObject(NULL_PEN));
529                   Rectangle(gdc,trect.left,trect.top,trect.right+1,trect.bottom+1);
530  		         SelectObject(gdc,holdbrush);
531                   SelectObject(gdc,holdpen);
532                   DeleteObject(hbrush);
533               }
534       SelectObject(gdc,holdfont);
535       DeleteObject(holdfont);
536  	 ReleaseDC(hWnd,gdc);
537  }
538  void DrawCursor(HWND hWnd,int SI)
539  	{
540  	   RECT rect,rectwhole;
541  	   HDC gdc;
542  	   HPEN hpen,holdpen;
543  	   int rop;
544         if(BGHS[SI].rows == 0){return;}
545  	   GetClientRect(hWnd,&rect);
546  	   if(BGHS[SI].cursorrow < BGHS[SI].homerow){return;}
547         if(BGHS[SI].cursorcol < BGHS[SI].homecol){return;}
548  	   rect = GetCellRect(hWnd,SI,BGHS[SI].cursorrow,BGHS[SI].cursorcol);
549  	   rectwhole=rect;
550  	   gdc=GetDC(hWnd);
551         BGHS[SI].activecellrect = rect;
552  	   rop=GetROP2(gdc);
553  	   SetROP2(gdc,R2_XORPEN);
554  	   SelectObject(gdc,(HBRUSH)GetStockObject(NULL_BRUSH));
555  	   hpen=CreatePen(PS_SOLID,3,BGHS[SI].cursorcolor);  
556  	   holdpen=(HPEN)SelectObject(gdc,hpen);
557  	   Rectangle(gdc,rect.left,rect.top,rect.right,rect.bottom);
558  	   SelectObject(gdc,holdpen);
559  	   DeleteObject(hpen);
560  	   SetROP2(gdc,rop);
561  	   ReleaseDC(hWnd,gdc);
562  	}
563  void SetCurrentCellStatus(HWND hWnd,int SelfIndex)
564      {
565         SetCell(&BGcell,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
566  	   if (SendMessage(hWnd, BGM_GETPROTECTION, reinterpret_cast<WPARAM>(&BGcell), 0))
567             {
568              BGHS[SelfIndex].CURRENTCELLPROTECTED = TRUE;
569             }
570         else
571             {
572              BGHS[SelfIndex].CURRENTCELLPROTECTED = FALSE;
573             }
574      }
575  TCHAR GetASCII(WPARAM wParam, LPARAM lParam)
576      {
577       int returnvalue;
578       TCHAR mbuffer[100];
579       int result;
580       BYTE keys[256];
581       WORD dwReturnedValue;
582       GetKeyboardState(keys);
583  	 result = ToAscii(static_cast<UINT>(wParam), (lParam >> 16) & 0xff, keys, &dwReturnedValue, 0);
584       returnvalue = (TCHAR) dwReturnedValue;
585       if(returnvalue < 0){returnvalue = 0;}
586       wsprintf(mbuffer, TEXT("return value = %d"), returnvalue);
587       if(result!=1){returnvalue = 0;}
588       return (TCHAR)returnvalue;
589      }
590  void SetHomeRow(HWND hWnd,int SI,int row,int col)
591  	{
592  	 RECT gridrect,cellrect;
593  	 GetClientRect(hWnd,&gridrect);
594  	 cellrect=GetCellRect(hWnd,SI,row,col);
595  	 if((cellrect.bottom > gridrect.bottom)&&((cellrect.bottom - cellrect.top)<(gridrect.bottom-(BGHS[SI].headerrowheight+BGHS[SI].titleheight))))
596  		 {
597  			 while(cellrect.bottom > gridrect.bottom)
598  				 {
599  				  BGHS[SI].homerow ++;
600  				  if(row==BGHS[SI].rows)
601  					  {
602  					   gridrect.top = gridrect.bottom - (BGHS[SI].rowheight);
603  				       InvalidateRect(hWnd,&gridrect,TRUE);
604  					  }
605  				  else
606  					  {
607  					   InvalidateRect(hWnd,&gridrect,FALSE);
608  					  }
609  				  cellrect=GetCellRect(hWnd,SI,row,col);
610  				 }
611  		 }
612       else
613           {
614            if((cellrect.bottom - cellrect.top)>=(gridrect.bottom - (BGHS[SI].headerrowheight+BGHS[SI].titleheight)))
615                {
616                 BGHS[SI].homerow++;
617                }
618           }
619  	 cellrect=GetCellRect(hWnd,SI,row,col);
620  		 {
621  			 while((row < BGHS[SI].homerow))
622  				 {
623  				  BGHS[SI].homerow --;
624  				  InvalidateRect(hWnd,&gridrect,FALSE);
625  				  cellrect=GetCellRect(hWnd,SI,row,col);
626  				 }
627  		 }
628  		 SetScrollPos(hWnd,SB_VERT,BGHS[SI].homerow,TRUE);
629  	}
630  void SetHomeCol(HWND hWnd,int SI,int row,int col)
631  	{
632        RECT gridrect{}, cellrect{};
633        GetClientRect(hWnd,&gridrect);
634        cellrect = GetCellRect(hWnd,SI,row,col);
635        while((cellrect.right > gridrect.right)&&(cellrect.left != BGHS[SI].columnwidths[0]))
636            {
637             BGHS[SI].homecol++;
638             cellrect = GetCellRect(hWnd,SI,row,col);
639             InvalidateRect(hWnd,&gridrect,FALSE);
640            }
641        cellrect = GetCellRect(hWnd,SI,row,col);
642        while((BGHS[SI].cursorcol < BGHS[SI].homecol)&&(BGHS[SI].homecol > 1))
643            {
644             BGHS[SI].homecol--;
645             cellrect = GetCellRect(hWnd,SI,row,col);
646             InvalidateRect(hWnd,&gridrect,FALSE);
647            }
648            {
649            int k;
650             k=HomeColumnNthVisible(SI);
651             SetScrollPos(hWnd,SB_HORZ,k,TRUE);
652            }
653  	}
654  void ShowVscroll(HWND hWnd,int SI)
655  	{
656  	 RECT gridrect;
657  	 int totalpixels;
658  	 int rowsvisibleonscreen;
659  	 GetClientRect(hWnd,&gridrect);
660  	 totalpixels = gridrect.bottom;
661       totalpixels -= BGHS[SI].titleheight;
662  	 totalpixels -= BGHS[SI].headerrowheight;
663  	 totalpixels -= (BGHS[SI].rowheight * BGHS[SI].rows);
664  	 rowsvisibleonscreen = (gridrect.bottom - (BGHS[SI].headerrowheight+BGHS[SI].titleheight)) / BGHS[SI].rowheight;
665  	 if(totalpixels < 0)
666  		 {
667  		 ShowScrollBar(hWnd,SB_VERT,TRUE);
668  		 SetScrollRange(hWnd,SB_VERT,1,(BGHS[SI].rows-rowsvisibleonscreen)+1,TRUE);
669           BGHS[SI].VSCROLL = TRUE;
670  		 }
671  	 else
672  		 {
673  		  ShowScrollBar(hWnd,SB_VERT,FALSE);
674            BGHS[SI].VSCROLL = FALSE;
675  		 }
676  	}
677  void ShowHscroll(HWND hWnd,int SI)
678  	{
679  	 RECT gridrect;
680  	 int totalpixels;
681  	 int colswithwidth;
682       int j;
683  	 GetClientRect(hWnd,&gridrect);
684  	 totalpixels = gridrect.right;
685  	 totalpixels -= BGHS[SI].columnwidths[0];
686       colswithwidth = 0;
687       for(j=1;j<=BGHS[SI].cols;j++)
688           {
689            totalpixels -= BGHS[SI].columnwidths[j];
690            if(BGHS[SI].columnwidths[j]>0)
691                {
692                 colswithwidth++;
693                }
694           }
695  	 if(totalpixels < 0)
696  		 {
697  		 ShowScrollBar(hWnd,SB_HORZ,TRUE);
698  		 SetScrollRange(hWnd,SB_HORZ,1,colswithwidth,TRUE);
699           BGHS[SI].HSCROLL = TRUE;
700  		 }
701  	 else
702  		 {
703  		  ShowScrollBar(hWnd,SB_HORZ,FALSE);
704            BGHS[SI].HSCROLL = FALSE;
705  		 }
706  	}
707  void NotifyRowChanged(HWND hWnd,int SI)
708  	{
709  	 WPARAM wParam;
710  	 LPARAM lParam;
711  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
712         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_ROWCHANGED);
713         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
714  	   wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_SELCHANGE);
715  	   SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
716  	}
717  void NotifyColChanged(HWND hWnd,int SI)
718  	{
719  	 WPARAM wParam;
720  	 LPARAM lParam;
721  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
722         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_COLCHANGED);
723         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
724         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_SELCHANGE);
725         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
726  	}
727  void NotifyEndEdit(HWND hWnd,int SI)
728  	{
729  	 WPARAM wParam;
730  	 LPARAM lParam;
731  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
732         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_EDITEND);
733         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
734  	}
735  void NotifyDelete(HWND hWnd,int SI)
736  	{
737  	 WPARAM wParam;
738  	 LPARAM lParam;
739  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
740         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_DELETECELL);
741         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
742  	}
743  void NotifyEditBegin(HWND hWnd,int SI)
744  	{
745  	 WPARAM wParam;
746  	 LPARAM lParam;
747  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
748         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_EDITBEGIN);
749         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
750  	}
751  void NotifyEditEnd(HWND hWnd,int SI)
752  	{
753  	 WPARAM wParam;
754  	 LPARAM lParam;
755  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
756         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_EDITEND);
757         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
758  	}
759  void NotifyCellClicked(HWND hWnd,int SI)
760  	{
761  	 WPARAM wParam;
762  	 LPARAM lParam;
763  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
764         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_CELLCLICKED);
765         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
766  	}
767  void NotifyCellDbClicked(HWND hWnd,int SI)
768  	{
769  	 WPARAM wParam;
770  	 LPARAM lParam;
771  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
772         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_CELLDBCLICKED);
773         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
774  	}
775  void NotifyCellRClicked(HWND hWnd,int SI)
776  	{
777  	 WPARAM wParam;
778  	 LPARAM lParam;
779  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
780         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_CELLRCLICKED);
781         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
782  	}
783  void GetVisibleColumns(HWND hWnd,int SI)
784      {
785       int j;
786       int value;
787       value=0;
788       for(j=1;j<=BGHS[SI].cols;j++)
789           {
790            if(BGHS[SI].columnwidths[j] > 0)
791                {
792                 value++;
793                }
794           }
795       BGHS[SI].visiblecolumns = value;
796       SetScrollRange(hWnd,SB_HORZ,1,value,TRUE);
797      }
798  int GetNthVisibleColumn(HWND, int SI, int n)
799      {
800       int j,count;
801       int value;
802       j=1;
803       count=0;
804       value = n-1;
805       while(j<=BGHS[SI].cols)
806           {
807            if(BGHS[SI].columnwidths[j]>0)
808                {
809                 count++;
810                 if(count==n)
811                     {
812                      value = j;
813                     }
814                }
815            j++;
816           }
817       return value;
818      }
819  void CloseEdit(HWND hWnd,int SI)
820      {
821       int r,c;
822       _BGCELL cell;
823       r=BGHS[SI].cursorrow;
824       c=BGHS[SI].cursorcol;
825       cell.row = r;
826       cell.col = c;
827  	 SendMessage(hWnd, BGM_SETCELLDATA, reinterpret_cast<WPARAM>(&cell), reinterpret_cast<LPARAM>(BGHS[SI].editstring));
828  	 wcscpy_s(BGHS[SI].editstring, TEXT(""));
829       RefreshGrid(hWnd);
830       BGHS[SI].EDITING = FALSE;
831       HideCaret(hWnd);
832       NotifyEditEnd(hWnd,SI);
833      }
834  void DisplayEditString(HWND hWnd,int SI, const TCHAR* tstring)
835      {
836         int r,c;
837         HFONT holdfont;
838         RECT rt;
839         HDC cdc;
840         r=BGHS[SI].cursorrow;
841         c=BGHS[SI].cursorcol;
842         ShowCaret(hWnd);
843         if((r<BGHS[SI].homerow)||(c<BGHS[SI].homecol))
844             {
845              HideCaret(hWnd);
846              return;
847             }
848         rt=GetCellRect(hWnd,SI,r,c);
849         rt.top += 2;
850         rt.bottom -= 2;
851         rt.right -=2;
852         rt.left += 2;
853         cdc=GetDC(hWnd);
854         Rectangle(cdc,rt.left,rt.top,rt.right,rt.bottom);
855         rt.top += 2;
856         rt.bottom -= 2;
857         rt.right -=2;
858         rt.left += 2;
859         if(lstrlen(BGHS[SI].editstring)<=300)
860             {
861  		   wcscat_s(BGHS[SI].editstring,tstring);
862  		   wcscat_s(BGHS[SI].editstringdisplay,BGHS[SI].editstring);
863             }
864         else
865  		{
866  			if (!NppParameters::getInstance().getNppGUI()._muteSounds)
867  				MessageBeep(0);
868  		}
869         holdfont=(HFONT)SelectObject(cdc,BGHS[SI].hfont);
870         rt.right -= 5;
871         DrawText(cdc,BGHS[SI].editstringdisplay,-1,&rt,DT_RIGHT|DT_VCENTER|DT_SINGLELINE);
872         rt.right +=5;
873         ShowCaret(hWnd);
874         int rh = BGHS[SI].rowheight;
875         int ah = BGHS[SI].fontascentheight;
876         SetCaretPos(rt.right - 4, rt.top + (rh / 2)-ah + 2);
877         SelectObject(cdc,holdfont);
878         ReleaseDC(hWnd,cdc);
879      }
880  ATOM RegisterGridClass(HINSTANCE hInstance)
881  {
882     for(int j = 0 ; j < MAX_GRIDS ; j++)
883     {
884          BGHS[j].gridmenu = 0;
885          BGHS[j].hlist1 = NULL;
886  		wcscpy_s(BGHS[j].protect, TEXT("U"));
887  		BGHS[j].rows = 100;
888  		BGHS[j].cols = 255;
889  		BGHS[j].homerow = 1;
890  		BGHS[j].homecol = 1;
891  		BGHS[j].rowheight = 21;
892  		BGHS[j].headerrowheight = 21;
893  		BGHS[j].ROWSNUMBERED = TRUE;
894  		BGHS[j].COLUMNSNUMBERED = TRUE;
895          BGHS[j].EDITABLE = FALSE;
896          BGHS[j].EDITING = FALSE;
897          BGHS[j].AUTOROW = TRUE;
898  		BGHS[j].cursorcol = 1;
899  		BGHS[j].cursorrow = 1;
900  		BGHS[j].columnwidths[0]=50;
901          BGHS[j].ADVANCEROW = TRUE;
902  		BGHS[j].DRAWHIGHLIGHT = TRUE;
903  		BGHS[j].cursorcolor = RGB(255,255,255);
904  		BGHS[j].protectcolor = RGB(255,255,255);
905  		BGHS[j].unprotectcolor = RGB(255,255,255);
906  		BGHS[j].highlightcolor = RGB(0,0,128);
907  		BGHS[j].highlightcolorNoFocus = RGB(200,200,200);
908  		BGHS[j].highlightcolorProtect = RGB(0,0,128);
909  		BGHS[j].highlightcolorProtectNoFocus = RGB(200,200,200);
910  		BGHS[j].gridlinecolor = RGB(220,220,220);
911          BGHS[j].highlighttextcolor = RGB(255,255,255);
912  		BGHS[j].textcolor = RGB(0,0,0);
913          BGHS[j].backgroundcolor = GetSysColor(COLOR_BTNFACE);
914          BGHS[j].titletextcolor = RGB(0,0,0);
915          BGHS[j].titlecolor = GetSysColor(COLOR_BTNFACE);
916          BGHS[j].titlegridlinecolor = RGB(120,120,120);
917          BGHS[j].titleheight = 0;
918          BGHS[j].EXTENDLASTCOLUMN = TRUE;
919          BGHS[j].SHOWINTEGRALROWS = TRUE;
920          BGHS[j].ELLIPSIS = TRUE;
921          BGHS[j].COLAUTOWIDTH = FALSE;
922          BGHS[j].COLUMNSIZING = FALSE;
923          BGHS[j].ALLOWCOLUMNRESIZING = FALSE;
924          BGHS[j].cursortype = 0;
925          BGHS[j].hcolumnheadingfont = NULL;
926          BGHS[j].htitlefont = NULL;
927  		BGHS[j].INITIALCONTENT = FALSE;
928  		wcscpy_s(BGHS[j].editstring, TEXT(""));
929  		for(int k = 0 ; k < MAX_COLS ; k++)
930  		{
931  			BGHS[j].columnwidths[k]=50;
932  		}
933      }
934  	WNDCLASS wclass;
935      wclass.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
936  	wclass.lpfnWndProc = (WNDPROC)GridProc;
937  	wclass.cbClsExtra = 0;
938  	wclass.cbWndExtra = 0;
939  	wclass.hInstance = hInstance;
940  	wclass.hIcon = NULL;
941  	wclass.hCursor = ::LoadCursor(NULL, IDC_ARROW);
942  	wclass.hbrBackground = (HBRUSH)(GetStockObject(GRAY_BRUSH));
943  	wclass.lpszClassName = TEXT("BABYGRID");
944  	wclass.lpszMenuName = NULL;
945  	return RegisterClass(&wclass);
946  }
947  void SizeGrid(HWND hWnd,int &bsol;*SI*/)
948  {
949       SendMessage(hWnd,WM_SIZE,SIZE_MAXIMIZED,0);
950  }
951  int FindLongestLine(HDC hdc, wchar_t* text, SIZE* size)
952  {
953      int longest = 0;
954      wchar_t* buffer = nullptr;
955      wchar_t* token = WCSTOK(text, TEXT("\n"), &buffer);;
956      while (token)
957      {
958          ::GetTextExtentPoint32(hdc, token, lstrlen(token), size);
959          if (size->cx > longest)
960          {
961               longest=size->cx;
962          }
963          token = WCSTOK(nullptr, TEXT("\n"), &buffer);
964      }
965      return longest;
966  }
967  LRESULT CALLBACK GridProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
968  {
969  	int wmId;
970  	PAINTSTRUCT ps;
971  	TCHAR buffer[bufferLen];
972  	int SelfIndex;
973  	int ReturnValue;
974  	HINSTANCE hInst;
975      int iDataType;
976  	SelfIndex=FindGrid(GetMenu(hWnd));
977  	{
978  	 RECT rect;
979  	 GetClientRect(hWnd,&rect);
980  	 BGHS[SelfIndex].gridwidth = rect.right - rect.left;
981  	 BGHS[SelfIndex].gridheight = rect.bottom - rect.top;
982  	}
983  	ReturnValue = 0;
984  	switch (message)
985  	{
986  		case WM_COMMAND:
987  			wmId    = LOWORD(wParam);
988  			switch (wmId)
989  			{
990                  case 1:
991  				default:
992  				   return DefWindowProc(hWnd, message, wParam, lParam);
993  			}
994  			break;
995  		case WM_PAINT:
996  			BeginPaint(hWnd, &ps);
997  			RECT rt;
998  			GetClientRect(hWnd, &rt);
999  			CalcVisibleCellBoundaries(SelfIndex);
1000  			if (BGHS[SelfIndex].titleheight > 0)
1001  				DisplayTitle(hWnd,SelfIndex,BGHS[SelfIndex].htitlefont);
1002  			DisplayColumn(hWnd,SelfIndex,0,0,BGHS[SelfIndex].hfont,BGHS[SelfIndex].hcolumnheadingfont);
1003  			{
1004  			     int c,j,k,offset;
1005  			     offset = BGHS[SelfIndex].columnwidths[0];
1006  			     j=BGHS[SelfIndex].leftvisiblecol;
1007  			     k=BGHS[SelfIndex].rightvisiblecol;
1008  			     for(c=j;c<=k;c++)
1009  			     {
1010  			          DisplayColumn(hWnd,SelfIndex,c,offset,BGHS[SelfIndex].hfont,BGHS[SelfIndex].hcolumnheadingfont);
1011  			          offset+=BGHS[SelfIndex].columnwidths[c];
1012  			     }
1013  			}
1014  			EndPaint(hWnd, &ps);
1015  			if(GetFocus()==hWnd)
1016  				{
1017  			      PostMessage(hWnd,BGM_DRAWCURSOR,(UINT)SelfIndex,0);
1018  				}
1019  			break;
1020          case BGM_PAINTGRID:
1021          {
1022               RECT rect;
1023               GetClientRect(hWnd, &rect);
1024               InvalidateRect(hWnd,&rect,TRUE);
1025               UpdateWindow(hWnd);
1026  			if (!NppParameters::getInstance().getNppGUI()._muteSounds)
1027  				MessageBeep(0);
1028          }
1029          break;
1030          case WM_SETTEXT:
1031          {
1032                int j,linecount;
1033                SIZE size;
1034                HDC gdc;
1035                HFONT holdfont;
1036                if(lstrlen((TCHAR*)lParam)>300)
1037                {
1038  				  wcscpy_s(BGHS[SelfIndex].title, TEXT("Title too long (300 chars max)"));
1039                }
1040                else
1041                {
1042  				  wcscpy_s(BGHS[SelfIndex].title,(TCHAR*)lParam);
1043                }
1044               gdc=GetDC(hWnd);
1045               if(lstrlen(BGHS[SelfIndex].title) > 0)
1046               {
1047                    linecount=1;
1048  				  for (j = 0; j<static_cast<int>(lstrlen(BGHS[SelfIndex].title)); j++)
1049                    {
1050                         if (BGHS[SelfIndex].title[j] == '\n')
1051                         {
1052                              linecount++;
1053                         }
1054                    }
1055                    holdfont=(HFONT)SelectObject(gdc,BGHS[SelfIndex].htitlefont);
1056                    GetTextExtentPoint32(gdc,BGHS[SelfIndex].title,lstrlen(BGHS[SelfIndex].title),&size);
1057                    SelectObject(gdc,holdfont);
1058  				  BGHS[SelfIndex].titleheight = static_cast<int>((size.cy*1.2) * linecount);
1059               }
1060               else
1061               {
1062                    BGHS[SelfIndex].titleheight = 0;
1063               }
1064               ReleaseDC(hWnd,gdc);
1065  			 RefreshGrid(hWnd);
1066               SizeGrid(hWnd,SelfIndex);
1067          }
1068          break;
1069          case BGM_GETROWS:
1070                ReturnValue = BGHS[SelfIndex].rows;
1071              break;
1072          case BGM_GETCOLS:
1073                ReturnValue = BGHS[SelfIndex].cols;
1074              break;
1075          case BGM_GETCOLWIDTH:
1076                ReturnValue = BGHS[SelfIndex].columnwidths[wParam];
1077              break;
1078          case BGM_GETROWHEIGHT:
1079                 ReturnValue = BGHS[SelfIndex].rowheight;
1080              break;
1081          case BGM_GETHEADERROWHEIGHT:
1082                 ReturnValue = BGHS[SelfIndex].headerrowheight;
1083              break;
1084          case BGM_GETOWNERDRAWITEM:
1085                ReturnValue = BGHS[SelfIndex].ownerdrawitem;
1086              break;
1087  		case BGM_DRAWCURSOR:
1088  			DrawCursor(hWnd, static_cast<int32_t>(wParam));
1089  			break;
1090          case BGM_SETCURSORPOS:
1091                 DrawCursor(hWnd,SelfIndex);
1092                 if((((int)wParam <= BGHS[SelfIndex].rows)&&((int)wParam > 0))&&
1093                     (((int)lParam <= BGHS[SelfIndex].cols)&&((int)lParam > 0)))
1094                 {
1095  					   BGHS[SelfIndex].cursorrow = static_cast<int32_t>(wParam);
1096  					   BGHS[SelfIndex].cursorcol = static_cast<int32_t>(lParam);
1097                 }
1098                 else
1099                 {
1100                      DrawCursor(hWnd,SelfIndex);
1101                      break;
1102                 }
1103                 SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1104                 SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1105                 DrawCursor(hWnd,SelfIndex);
1106                 RefreshGrid(hWnd);
1107              break;
1108  		case BGM_SETLASTVIEW:
1109  			if ((((int)wParam <= BGHS[SelfIndex].rows) && ((int)wParam > 0)) &&
1110  				(((int)lParam <= BGHS[SelfIndex].rows) && ((int)lParam > 0)))
1111  			{
1112  				BGHS[SelfIndex].homerow = static_cast<int32_t>(wParam);
1113  				BGHS[SelfIndex].homecol = 1;
1114  				BGHS[SelfIndex].cursorrow = static_cast<int32_t>(lParam);
1115  				BGHS[SelfIndex].cursorcol = 1;
1116  				SetHomeRow(hWnd, SelfIndex, BGHS[SelfIndex].cursorrow, BGHS[SelfIndex].cursorcol);
1117  				RefreshGrid(hWnd);
1118  				NotifyRowChanged(hWnd, SelfIndex);
1119  			}
1120  			break;
1121          case BGM_SETINITIALCONTENT:
1122                 BGHS[SelfIndex].INITIALCONTENT = (BOOL)wParam;
1123              break;
1124  		case BGM_SHOWHILIGHT:
1125  			   BGHS[SelfIndex].DRAWHIGHLIGHT = (BOOL)wParam;
1126                 RefreshGrid(hWnd);
1127  			break;
1128          case BGM_EXTENDLASTCOLUMN:
1129                 BGHS[SelfIndex].EXTENDLASTCOLUMN = (BOOL)wParam;
1130                 RefreshGrid(hWnd);
1131              break;
1132          case BGM_SHOWINTEGRALROWS:
1133                 BGHS[SelfIndex].SHOWINTEGRALROWS = (BOOL)wParam;
1134                 SizeGrid(hWnd,SelfIndex);
1135                 RefreshGrid(hWnd);
1136              break;
1137          case BGM_SETCOLAUTOWIDTH:
1138                 BGHS[SelfIndex].COLAUTOWIDTH = (BOOL)wParam;
1139              break;
1140          case BGM_SETALLOWCOLRESIZE:
1141                 BGHS[SelfIndex].ALLOWCOLUMNRESIZING = (BOOL)wParam;
1142              break;
1143  		case BGM_PROTECTCELL:
1144                LPBGcell=(_BGCELL*)wParam;
1145                if(OutOfRange(LPBGcell))
1146                {
1147                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1148                     lParam = 0;
1149                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1150  				   ReturnValue = -1;
1151                     break;
1152                }
1153                wsprintf(buffer, TEXT("%05d-%03d"), LPBGcell->row,LPBGcell->col);
1154                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1155                if(FindResult != LB_ERR)
1156                {
1157  				  auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1158  				  if (static_cast<size_t>(lbTextLen) > bufferLen)
1159  					  return TRUE;
1160  					SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1161  				   if((BOOL)lParam)
1162  				   {
1163  					   buffer[10] = 'P';
1164  				   }
1165  				   else
1166  				   {
1167  					   buffer[10] = 'U';
1168  				   }
1169                     SendMessage(BGHS[SelfIndex].hlist1, LB_DELETESTRING, FindResult, 0);
1170  				   SendMessage(BGHS[SelfIndex].hlist1, LB_ADDSTRING, FindResult, reinterpret_cast<LPARAM>(buffer));
1171                }
1172  			  else
1173  			  {
1174  				  wcscat_s(buffer, TEXT("|"));
1175  				  if((BOOL)lParam)
1176  				  {
1177  					  wcscat_s(buffer, TEXT("PA"));
1178  				  }
1179  				  else
1180  				  {
1181  					  wcscat_s(buffer, TEXT("UA"));
1182  				  }
1183  				  wcscat_s(buffer, TEXT("|"));
1184  				  SendMessage(BGHS[SelfIndex].hlist1, LB_ADDSTRING, FindResult, reinterpret_cast<LPARAM>(buffer));
1185  			  }
1186  			break;
1187  		case BGM_NOTIFYROWCHANGED:
1188  			   NotifyRowChanged(hWnd,SelfIndex);
1189  			break;
1190  		case BGM_NOTIFYCOLCHANGED:
1191  			   NotifyColChanged(hWnd,SelfIndex);
1192  			break;
1193  		case BGM_SETPROTECT:
1194  			if((BOOL)wParam)
1195              {
1196  				wcscpy_s(BGHS[SelfIndex].protect, TEXT("P"));
1197  			}
1198  			else
1199              {
1200  				wcscpy_s(BGHS[SelfIndex].protect, TEXT("U"));
1201  			}
1202  			break;
1203  		case BGM_AUTOROW:
1204  			  if((BOOL)wParam)
1205  			  {
1206  			      BGHS[SelfIndex].AUTOROW = TRUE;
1207  			  }
1208  			  else
1209  			  {
1210  			      BGHS[SelfIndex].AUTOROW = FALSE;
1211  			  }
1212  			break;
1213          case BGM_SETEDITABLE:
1214                 if((BOOL)wParam)
1215                 {
1216                      BGHS[SelfIndex].EDITABLE = TRUE;
1217                 }
1218  			   else
1219  			   {
1220  				   BGHS[SelfIndex].EDITABLE = FALSE;
1221  			   }
1222              break;
1223          case BGM_SETCELLDATA:
1224                LPBGcell=(_BGCELL*)wParam;
1225                if(OutOfRange(LPBGcell))
1226                    {
1227                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1228                     lParam = 0;
1229                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1230  				   ReturnValue = -1;
1231                     break;
1232                    }
1233                wsprintf(buffer, TEXT("%05d-%03d"), LPBGcell->row,LPBGcell->col);
1234  			  if (!BGHS[SelfIndex].INITIALCONTENT) 
1235  			  {
1236  				  FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1237  				  if(FindResult != LB_ERR)
1238  				  {
1239  					  SendMessage(BGHS[SelfIndex].hlist1,LB_DELETESTRING,FindResult,0);
1240  				  }
1241  			  }
1242  			  wcscat_s(buffer, TEXT("|"));
1243  			  wcscat_s(buffer,BGHS[SelfIndex].protect);
1244  			  iDataType = 1;
1245                if(iDataType==1){ wcscat_s(buffer, TEXT("A"));}
1246                if(iDataType==2){ wcscat_s(buffer, TEXT("N"));}
1247                if(iDataType==3){ wcscat_s(buffer, TEXT("T"));}
1248                if(iDataType==4){ wcscat_s(buffer, TEXT("F"));}
1249  			  if(iDataType==5){ wcscat_s(buffer, TEXT("G"));}
1250  			  wcscat_s(buffer, TEXT("|"));
1251  			  wcscat_s(buffer, (TCHAR*)lParam);
1252  			  FindResult = static_cast<int32_t>(SendMessage(BGHS[SelfIndex].hlist1, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(buffer)));
1253                if(FindResult==LB_ERR)
1254  			  {
1255  				if (!NppParameters::getInstance().getNppGUI()._muteSounds)
1256  					MessageBeep(0);
1257  			  }
1258                    {
1259                     RECT rect;
1260                     rect=GetCellRect(hWnd,SelfIndex,LPBGcell->row,LPBGcell->col);
1261                     InvalidateRect(hWnd,&rect,FALSE);
1262                    }
1263                    if(BGHS[SelfIndex].AUTOROW)
1264                    {
1265                     int j = static_cast<int32_t>(SendMessage(BGHS[SelfIndex].hlist1, LB_GETCOUNT, 0, 0));
1266                      if(j>0)
1267                          {
1268                          auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, j-1, 0);
1269                          if (static_cast<size_t>(lbTextLen) > bufferLen)
1270                              return TRUE;
1271                           SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, j - 1, reinterpret_cast<LPARAM>(buffer));
1272                           buffer[5]=0x00;
1273                           j=_wtoi(buffer);
1274                           if(j>SendMessage(hWnd,BGM_GETROWS,0,0))
1275                               {
1276                                SendMessage(hWnd,BGM_SETGRIDDIM,j,BGHS[SelfIndex].cols);
1277                               }
1278                          }
1279                      else
1280                          {
1281                          SendMessage(hWnd,BGM_SETGRIDDIM,j,BGHS[SelfIndex].cols);
1282                          }
1283                    }
1284                    if((BGHS[SelfIndex].COLAUTOWIDTH)||(LPBGcell->row == 0))
1285                        {
1286                         HDC hdc;
1287                         SIZE size { 0, 0 };
1288                         int required_width;
1289                         int current_width;
1290                         int required_height = 30;
1291                         int current_height;
1292                         int longestline;
1293                         HFONT holdfont;
1294                         hdc=GetDC(hWnd);
1295                         if(LPBGcell->row == 0)
1296                             {
1297                               holdfont=(HFONT)SelectObject(hdc,BGHS[SelfIndex].hcolumnheadingfont);
1298                             }
1299                             else
1300                             {
1301                               holdfont=(HFONT)SelectObject(hdc,BGHS[SelfIndex].hfont);
1302                             }
1303                         longestline=FindLongestLine(hdc,(TCHAR*)lParam,&size);
1304                         required_width = longestline+15;
1305                         required_height = size.cy;
1306                             {
1307                                 int count=1;
1308                                 TCHAR tbuffer[255] = { '\0' };
1309  							   wcscpy_s(tbuffer,(TCHAR*)lParam);
1310                                 for(int j=0;j<(int)lstrlen(tbuffer);j++)
1311                                     {
1312                                     if(tbuffer[j]=='\n'){count++;}
1313                                     }
1314                                 if((!BGHS[SelfIndex].ELLIPSIS)||(LPBGcell->row == 0))
1315                                     {
1316                                      required_height *= count;
1317                                     }
1318                                 required_height +=5;
1319                             }
1320                         SelectObject(hdc,holdfont);
1321                         ReleaseDC(hWnd,hdc);
1322                         current_width = BGHS[SelfIndex].columnwidths[LPBGcell->col];
1323                         if(LPBGcell->row == 0)
1324                             {
1325                              current_height = BGHS[SelfIndex].headerrowheight;
1326                              if(required_height > current_height)
1327                                  {
1328                                   SendMessage(hWnd,BGM_SETHEADERROWHEIGHT,required_height,0);
1329                                  }
1330                             }
1331                         else
1332                             {
1333                              current_height = BGHS[SelfIndex].rowheight;
1334                              if(required_height > current_height)
1335  							{
1336                                   SendMessage(hWnd, BGM_SETROWHEIGHT, required_height, 0);
1337                              }
1338                             }
1339                         if(required_width > current_width)
1340                             {
1341                              SendMessage(hWnd,BGM_SETCOLWIDTH,LPBGcell->col,required_width);
1342                             }
1343                         ReleaseDC(hWnd,hdc);
1344                        }
1345              break;
1346          case BGM_GETCELLDATA:
1347                LPBGcell=(_BGCELL*)wParam;
1348                if(OutOfRange(LPBGcell))
1349                    {
1350                      wParam = MAKEWPARAM(GetMenu(hWnd), BGN_OUTOFRANGE);
1351                      lParam = 0;
1352                      SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1353                      ReturnValue = -1;
1354                      break;
1355                    }
1356                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1357                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1358                if(FindResult != LB_ERR)
1359                    {
1360                    auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1361                    if (static_cast<size_t>(lbTextLen) > bufferLen)
1362                        return TRUE;
1363                    SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1364                    switch (buffer[10]) 
1365                     {
1366                      case 'U': ReturnValue = 0; break;
1367                      case 'P': ReturnValue = 1; break;
1368                      default : ReturnValue = 0; break;
1369                     }
1370                    switch (buffer[11]) 
1371                     {
1372                      case 'A': ReturnValue |= 1 << 4; break;
1373                      case 'N': ReturnValue |= 2 << 4; break;
1374                      case 'T': ReturnValue |= 3 << 4; break;
1375                      case 'F': ReturnValue |= 4 << 4; break;
1376                      case 'G': ReturnValue |= 5 << 4; break;
1377                      default : ReturnValue |= 1 << 4; break;
1378                     }
1379                     int j,k,c;
1380                     TCHAR tbuffer[1000];
1381                     wcscpy_s(tbuffer,buffer);
1382                     k=lstrlen(tbuffer);
1383                     c=0;
1384                     for(j=13;j<k;j++)
1385                         {
1386                          buffer[c]=tbuffer[j];
1387                          c++;
1388                         }
1389                     buffer[c]=0x00;
1390                     wcscpy_s((TCHAR*)lParam, bufferLen, buffer);
1391                    }
1392  			  else
1393  			  {
1394  				  wcscpy_s((TCHAR*)lParam, bufferLen, TEXT(""));
1395  			  }
1396              break;
1397          case BGM_CLEARGRID:
1398                  SendMessage(BGHS[SelfIndex].hlist1,LB_RESETCONTENT,0,0);
1399                  BGHS[SelfIndex].rows = 0;
1400                  BGHS[SelfIndex].cursorrow = 1;
1401                  BGHS[SelfIndex].homerow = 1;
1402                  BGHS[SelfIndex].homecol = 1;
1403                      {
1404                       RECT rect;
1405                       GetClientRect(hWnd,&rect);
1406                       InvalidateRect(hWnd,&rect,TRUE);
1407                      }
1408              break;
1409          case BGM_DELETECELL:
1410                LPBGcell=(_BGCELL*)wParam;
1411                if(OutOfRange(LPBGcell))
1412                    {
1413                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1414                     lParam = 0;
1415                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1416  				   ReturnValue = -1;
1417                     break;
1418                    }
1419                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1420                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1421                if(FindResult != LB_ERR)
1422                    {
1423                     SendMessage(BGHS[SelfIndex].hlist1,LB_DELETESTRING,FindResult,0);
1424  				   NotifyEndEdit(hWnd,SelfIndex);
1425                    }
1426              break;
1427  		case BGM_SETGRIDDIM:
1428              if (wParam<=MAX_ROWS)
1429              {
1430  	            BGHS[SelfIndex].rows = static_cast<int32_t>(wParam);
1431              }
1432              else
1433              {
1434                  BGHS[SelfIndex].rows = MAX_ROWS;
1435              }
1436  			   if((lParam>0)&&(lParam<=MAX_COLS))
1437  			   {
1438  				   BGHS[SelfIndex].cols = static_cast<int32_t>(lParam);
1439  			   }
1440  			   else
1441  			   {
1442                  if(lParam <= 0)
1443                      {
1444  				     BGHS[SelfIndex].cols = 1;
1445                      }
1446                  else
1447                      {
1448                       BGHS[SelfIndex].cols = MAX_COLS;
1449                      }
1450  			   }
1451                     {RECT rect;
1452                      GetClientRect(hWnd,&rect);
1453                      InvalidateRect(hWnd,&rect,TRUE);
1454                     }
1455                 GetVisibleColumns(hWnd,SelfIndex);
1456  			break;
1457  		case BGM_SETCOLWIDTH:
1458  			  if((wParam <= MAX_COLS) && (lParam >= 0))
1459  			  {
1460                  RECT rect;
1461  				BGHS[SelfIndex].columnwidths[wParam] = static_cast<int32_t>(lParam);
1462                  GetClientRect(hWnd,&rect);
1463                  InvalidateRect(hWnd,&rect,FALSE);
1464                  GetVisibleColumns(hWnd,SelfIndex);
1465  			  }
1466  			break;
1467  		case BGM_SETHEADERROWHEIGHT:
1468              RECT rect;
1469              BGHS[SelfIndex].headerrowheight = static_cast<int32_t>(wParam);
1470              SizeGrid(hWnd, SelfIndex);
1471              GetClientRect(hWnd, &rect);
1472              InvalidateRect(hWnd, &rect, FALSE);
1473              break;
1474          case BGM_GETHOMEROW:
1475                ReturnValue = BGHS[SelfIndex].homerow;
1476              break;
1477          case BGM_GETROW:
1478                ReturnValue = BGHS[SelfIndex].cursorrow;
1479              break;
1480          case BGM_GETCOL:
1481                ReturnValue = BGHS[SelfIndex].cursorcol;
1482              break;
1483          case BGM_GETTYPE:
1484                LPBGcell=(_BGCELL*)wParam;
1485                if(OutOfRange(LPBGcell))
1486                    {
1487                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1488                     lParam = 0;
1489                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1490                     ReturnValue = -1;
1491                     break;
1492                    }
1493                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1494                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1495                if(FindResult != LB_ERR)
1496                    {
1497                    auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1498                    if (static_cast<size_t>(lbTextLen) > bufferLen)
1499                        return TRUE;
1500                    SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1501                    switch (buffer[11])
1502                     {
1503                     case 'A':ReturnValue=1;break;
1504                     case 'N':ReturnValue=2;break;
1505                     case 'T':ReturnValue=3;break;
1506                     case 'F':ReturnValue=4;break;
1507                     case 'G':ReturnValue=5;break;
1508                     default: ReturnValue =1;break;
1509                     }
1510                    }
1511              break;
1512          case BGM_GETPROTECTION:
1513                LPBGcell=(_BGCELL*)wParam;
1514                if(OutOfRange(LPBGcell))
1515                    {
1516                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1517                     lParam = 0;
1518                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1519                     ReturnValue = -1;
1520                     break;
1521                    }
1522                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1523                ReturnValue = 0;
1524                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1525                if(FindResult != LB_ERR)
1526                    {
1527                    auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1528                    if (static_cast<size_t>(lbTextLen) > bufferLen)
1529                        return TRUE;
1530                    SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1531                    switch (buffer[10])
1532                     {
1533                    case 'U':ReturnValue=0;break;
1534                    case 'P':ReturnValue=1;break;
1535                    default: ReturnValue =0;break;
1536                     }
1537                    }
1538  			break;
1539          case BGM_SETROWHEIGHT:
1540  			if(wParam <1){wParam=1;}
1541  			BGHS[SelfIndex].rowheight = static_cast<int32_t>(wParam);
1542              SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1543              SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1544              SizeGrid(hWnd,SelfIndex);
1545              {
1546  				RECT rect;
1547  				GetClientRect(hWnd,&rect);
1548  				InvalidateRect(hWnd,&rect,FALSE);
1549              }
1550              break;
1551          case BGM_SETTITLEHEIGHT:
1552              BGHS[SelfIndex].titleheight = static_cast<int32_t>(wParam);
1553              SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1554              SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1555              {
1556                  RECT rect;
1557                  GetClientRect(hWnd,&rect);
1558                  InvalidateRect(hWnd,&rect,FALSE);
1559              }
1560              break;
1561          case BGM_SETGRIDLINECOLOR:
1562  			  DrawCursor(hWnd,SelfIndex);
1563  			  BGHS[SelfIndex].gridlinecolor = (COLORREF)wParam;
1564  			  DrawCursor(hWnd,SelfIndex);
1565                RefreshGrid(hWnd);
1566              break;
1567  		case BGM_SETCURSORCOLOR:
1568  			  DrawCursor(hWnd,SelfIndex);
1569  			  BGHS[SelfIndex].cursorcolor = (COLORREF)wParam;
1570  			  DrawCursor(hWnd,SelfIndex);
1571                RefreshGrid(hWnd);
1572  			break;
1573          case BGM_SETHILIGHTTEXTCOLOR:
1574                 BGHS[SelfIndex].highlighttextcolor = (COLORREF)wParam;
1575  				  {
1576  				   RECT rect;
1577  				   GetClientRect(hWnd,&rect);
1578  				   InvalidateRect(hWnd,&rect,FALSE);
1579  				  }
1580              break;
1581          case BGM_SETHILIGHTCOLOR:
1582                 BGHS[SelfIndex].highlightcolor = (COLORREF)wParam;
1583  				  {
1584  				   RECT rect;
1585  				   GetClientRect(hWnd,&rect);
1586  				   InvalidateRect(hWnd,&rect,FALSE);
1587  				  }
1588              break;
1589          case BGM_SETHILIGHTCOLOR_NOFOCUS:
1590                 BGHS[SelfIndex].highlightcolorNoFocus = (COLORREF)wParam;
1591  				  {
1592  				   RECT rect;
1593  				   GetClientRect(hWnd,&rect);
1594  				   InvalidateRect(hWnd,&rect,FALSE);
1595  				  }
1596              break;
1597          case BGM_SETHILIGHTCOLOR_PROTECT:
1598                 BGHS[SelfIndex].highlightcolorProtect = (COLORREF)wParam;
1599  				  {
1600  				   RECT rect;
1601  				   GetClientRect(hWnd,&rect);
1602  				   InvalidateRect(hWnd,&rect,FALSE);
1603  				  }
1604              break;
1605          case BGM_SETHILIGHTCOLOR_PROTECT_NOFOCUS:
1606                 BGHS[SelfIndex].highlightcolorProtectNoFocus = (COLORREF)wParam;
1607  				  {
1608  				   RECT rect;
1609  				   GetClientRect(hWnd,&rect);
1610  				   InvalidateRect(hWnd,&rect,FALSE);
1611  				  }
1612              break;
1613  		case BGM_SETPROTECTCOLOR:
1614  			  BGHS[SelfIndex].protectcolor = (COLORREF)wParam;
1615  				  {
1616  				   RECT rect;
1617  				   GetClientRect(hWnd,&rect);
1618  				   InvalidateRect(hWnd,&rect,FALSE);
1619  				  }
1620  			break;
1621  		case BGM_SETUNPROTECTCOLOR:
1622  			  BGHS[SelfIndex].unprotectcolor = (COLORREF)wParam;
1623  				  {
1624  				   RECT rect;
1625  				   GetClientRect(hWnd,&rect);
1626  				   InvalidateRect(hWnd,&rect,FALSE);
1627  				  }
1628  			break;
1629  		case BGM_SETTEXTCOLOR:
1630  			  BGHS[SelfIndex].textcolor = (COLORREF)wParam;
1631  				  {
1632  				   RECT rect;
1633  				   GetClientRect(hWnd,&rect);
1634  				   InvalidateRect(hWnd,&rect,FALSE);
1635  				  }
1636  			break;
1637  		case BGM_SETBACKGROUNDCOLOR:
1638  			  BGHS[SelfIndex].backgroundcolor = (COLORREF)wParam;
1639  				  {
1640  				   RECT rect;
1641  				   GetClientRect(hWnd,&rect);
1642  				   InvalidateRect(hWnd,&rect,FALSE);
1643  				  }
1644  			break;
1645  		case BGM_SETTITLETEXTCOLOR:
1646  			  BGHS[SelfIndex].titletextcolor = (COLORREF)wParam;
1647  				  {
1648  				   RECT rect;
1649  				   GetClientRect(hWnd,&rect);
1650  				   InvalidateRect(hWnd,&rect,FALSE);
1651  				  }
1652  			break;
1653  		case BGM_SETTITLECOLOR:
1654  			  BGHS[SelfIndex].titlecolor = (COLORREF)wParam;
1655  				  {
1656  				   RECT rect;
1657  				   GetClientRect(hWnd,&rect);
1658  				   InvalidateRect(hWnd,&rect,FALSE);
1659  				  }
1660  			break;
1661  		case BGM_SETTITLEGRIDLINECOLOR:
1662  			  BGHS[SelfIndex].titlegridlinecolor = (COLORREF)wParam;
1663  				  {
1664  				   RECT rect;
1665  				   GetClientRect(hWnd,&rect);
1666  				   InvalidateRect(hWnd,&rect,FALSE);
1667  				  }
1668  			break;
1669          case BGM_SETELLIPSIS:
1670                 BGHS[SelfIndex].ELLIPSIS = (BOOL)wParam;
1671  				  {
1672  				   RECT rect;
1673  				   GetClientRect(hWnd,&rect);
1674  				   InvalidateRect(hWnd,&rect,FALSE);
1675  				  }
1676              break;
1677          case BGM_SETTITLEFONT:
1678                 BGHS[SelfIndex].htitlefont = (HFONT)wParam;
1679  				  {
1680  				   RECT rect;
1681  				   GetClientRect(hWnd,&rect);
1682  				   InvalidateRect(hWnd,&rect,FALSE);
1683  				  }
1684              break;
1685          case BGM_SETHEADINGFONT:
1686                 BGHS[SelfIndex].hcolumnheadingfont = (HFONT)wParam;
1687  				  {
1688  				   RECT rect;
1689  				   GetClientRect(hWnd,&rect);
1690  				   InvalidateRect(hWnd,&rect,FALSE);
1691  				  }
1692              break;
1693          case BGM_SETROWSNUMBERED:
1694                 BGHS[SelfIndex].ROWSNUMBERED = (BOOL)wParam;
1695  				  {
1696  				   RECT rect;
1697  				   GetClientRect(hWnd,&rect);
1698  				   InvalidateRect(hWnd,&rect,FALSE);
1699  				  }
1700              break;
1701          case BGM_SETCOLSNUMBERED:
1702                 BGHS[SelfIndex].COLUMNSNUMBERED = (BOOL)wParam;
1703  				  {
1704  				   RECT rect;
1705  				   GetClientRect(hWnd,&rect);
1706  				   InvalidateRect(hWnd,&rect,FALSE);
1707  				  }
1708              break;
1709  		case WM_ENABLE:
1710  			if(wParam == FALSE)
1711  				{
1712  				 BGHS[SelfIndex].textcolor = RGB(120,120,120);
1713  				}
1714  			else
1715  				{
1716  				 BGHS[SelfIndex].textcolor = RGB(0,0,0);
1717  				}
1718  			break;
1719          case WM_MOUSEMOVE:
1720                int x,y,r,c,t,z;
1721                x=LOWORD(lParam);
1722                y=HIWORD(lParam);
1723                r=GetRowOfMouse(SelfIndex,y);
1724                c=GetColOfMouse(SelfIndex,x);
1725                t=GetColOfMouse(SelfIndex,x+10);
1726                z=GetColOfMouse(SelfIndex,x-10);
1727                if(BGHS[SelfIndex].COLUMNSIZING)
1728                    {
1729                     int dx,nx,cr;
1730                     dx=x-BGHS[SelfIndex].columntoresizeinitx;
1731                     nx=BGHS[SelfIndex].columntoresizeinitsize + dx;
1732                     if(nx<=0){nx=0;}
1733                     cr=BGHS[SelfIndex].columntoresize;
1734                     SendMessage(hWnd,BGM_SETCOLWIDTH,cr,nx);
1735                    }
1736                if((r==0)&&(c>=-1)&&((t!=c)||(z!=c))&&(!BGHS[SelfIndex].COLUMNSIZING))
1737                    {
1738                     if((BGHS[SelfIndex].cursortype != 2)&&(BGHS[SelfIndex].ALLOWCOLUMNRESIZING))
1739                         {
1740                          BGHS[SelfIndex].cursortype = 2;
1741                          SetCursor(LoadCursor(NULL, IDC_SIZEWE));
1742                         }
1743                    }
1744                else
1745                    {
1746                     if((BGHS[SelfIndex].cursortype != 1)&&(!BGHS[SelfIndex].COLUMNSIZING))
1747                         {
1748                          BGHS[SelfIndex].cursortype = 1;
1749                          SetCursor(LoadCursor(NULL, IDC_ARROW));
1750                         }
1751                    }
1752              break;
1753          case WM_LBUTTONUP:
1754                if(BGHS[SelfIndex].COLUMNSIZING)
1755                    {
1756                     BGHS[SelfIndex].COLUMNSIZING = FALSE;
1757                     SetCursor(LoadCursor(NULL, IDC_ARROW));
1758                     BGHS[SelfIndex].cursortype = 1;
1759                     BGHS[SelfIndex].SHOWINTEGRALROWS=BGHS[SelfIndex].REMEMBERINTEGRALROWS;
1760                     SizeGrid(hWnd,SelfIndex);
1761                    }
1762              break;
1763  		case WM_RBUTTONUP :
1764  		case WM_LBUTTONDBLCLK :
1765  		case WM_LBUTTONDOWN:
1766  			{
1767  			 int x,y,r,c;
1768               if(BGHS[SelfIndex].cursortype == 2)
1769                   {
1770                    int c,x,t,z;
1771                    if(!BGHS[SelfIndex].COLUMNSIZING)
1772  					  {
1773                         BGHS[SelfIndex].REMEMBERINTEGRALROWS = BGHS[SelfIndex].SHOWINTEGRALROWS;
1774  					  }
1775  				  BGHS[SelfIndex].COLUMNSIZING = TRUE;
1776                    BGHS[SelfIndex].SHOWINTEGRALROWS = FALSE;
1777                    x=LOWORD(lParam);
1778                    BGHS[SelfIndex].columntoresizeinitx=x;
1779                       t=GetColOfMouse(SelfIndex,x+10);
1780                       z=GetColOfMouse(SelfIndex,x-10);
1781                    c=GetColOfMouse(SelfIndex,x);
1782                      if(t!=c)
1783                          {
1784                          BGHS[SelfIndex].columntoresize = c;
1785                          }
1786                      if(z!=c)
1787                          {
1788                          if(c==-1)
1789                              {
1790  								c = static_cast<int32_t>(SendMessage(hWnd, BGM_GETCOLS, 0, 0));
1791                              }
1792                          else
1793                              {
1794                                c-=1;
1795                              }
1796                           BGHS[SelfIndex].columntoresize = c;
1797                          }
1798                    BGHS[SelfIndex].columntoresizeinitsize = BGHS[SelfIndex].columnwidths[c];
1799                   }
1800               if(BGHS[SelfIndex].EDITING)
1801                   {
1802                    CloseEdit(hWnd,SelfIndex);
1803                   }
1804               else
1805                   {
1806                    SetFocus(hWnd);
1807                   }
1808               BOOL NRC,NCC;
1809               NRC=FALSE;
1810               NCC=FALSE;
1811  			 if(GetFocus()==hWnd)
1812  				 {
1813  				  x=LOWORD(lParam);
1814  				  y=HIWORD(lParam);
1815  				  r=GetRowOfMouse(SelfIndex,y);
1816  				  c=GetColOfMouse(SelfIndex,x);
1817  				   DrawCursor(hWnd,SelfIndex);
1818  				   if((r>0)&&(c>0))
1819  					   {
1820  					    if(r != BGHS[SelfIndex].cursorrow)
1821  							{
1822  							 BGHS[SelfIndex].cursorrow = r;
1823                               NRC=TRUE;
1824  							}
1825  						else
1826  							{
1827  					         BGHS[SelfIndex].cursorrow = r;
1828  							}
1829  						if(c != BGHS[SelfIndex].cursorcol)
1830  							{
1831  							 BGHS[SelfIndex].cursorcol = c;
1832                               NCC=TRUE;
1833  							}
1834  						else
1835  							{
1836  						     BGHS[SelfIndex].cursorcol = c;
1837  							}
1838  					   }
1839                     if(NRC){NotifyRowChanged(hWnd,SelfIndex);}
1840                     if(NCC){NotifyColChanged(hWnd,SelfIndex);}
1841  				   DrawCursor(hWnd,SelfIndex);
1842  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1843  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1844  				   RefreshGrid(hWnd);
1845  					if (message == WM_LBUTTONDOWN)
1846  						NotifyCellClicked(hWnd,SelfIndex);
1847  					else if (message == WM_LBUTTONDBLCLK)
1848  						NotifyCellDbClicked(hWnd,SelfIndex);
1849  					else 
1850  						NotifyCellRClicked(hWnd,SelfIndex);
1851  				 }
1852  			 else
1853  				 {
1854  				  SetFocus(hWnd);
1855  				 }
1856  			}
1857  			break;
1858          case WM_ERASEBKGND:
1859              return TRUE;
1860              break;
1861          case WM_GETDLGCODE:
1862                ReturnValue = DLGC_WANTARROWS|DLGC_WANTCHARS|DLGC_DEFPUSHBUTTON;
1863                   if(wParam == 13)
1864                       {
1865  					 NotifyCellDbClicked(hWnd, SelfIndex);
1866                     if(BGHS[SelfIndex].EDITING)
1867                         {
1868                          CloseEdit(hWnd,SelfIndex);
1869                         }
1870  				   DrawCursor(hWnd,SelfIndex);
1871  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1872  				   RefreshGrid(hWnd);
1873                     BGHS[SelfIndex].EDITING = FALSE;
1874                     break;
1875                       }
1876                if(wParam == VK_ESCAPE)
1877                    {
1878                     if(BGHS[SelfIndex].EDITING)
1879                         {
1880                           BGHS[SelfIndex].EDITING = FALSE;
1881  						 wcscpy_s(BGHS[SelfIndex].editstring, TEXT(""));
1882                           HideCaret(hWnd);
1883                           RefreshGrid(hWnd);
1884                           NotifyEditEnd(hWnd,SelfIndex);
1885                         }
1886                      else
1887                          {
1888                            ReturnValue = 0;
1889                          }
1890                      break;
1891                    }
1892              break;
1893  		case WM_KEYDOWN:
1894                if(wParam == VK_ESCAPE)
1895                    {
1896                     if(BGHS[SelfIndex].EDITING)
1897                         {
1898                           BGHS[SelfIndex].EDITING = FALSE;
1899  						 wcscpy_s(BGHS[SelfIndex].editstring, TEXT(""));
1900                           HideCaret(hWnd);
1901                           RefreshGrid(hWnd);
1902                           NotifyEditEnd(hWnd,SelfIndex);
1903                         }
1904                     break;
1905                    }
1906  			  if(wParam == VK_DELETE)
1907  				  {
1908                     NotifyDelete(hWnd,SelfIndex);
1909  				   break;
1910  				  }
1911                if(wParam == VK_TAB)
1912                    {
1913                     SetFocus(GetParent(hWnd));
1914                     break;
1915                    }
1916  			  if(wParam == VK_NEXT)
1917  				  {
1918  				   RECT gridrect;
1919  				   int rpp;
1920                     if(BGHS[SelfIndex].EDITING)
1921                         {
1922                          CloseEdit(hWnd,SelfIndex);
1923                         }
1924                     if(BGHS[SelfIndex].rows == 0){break;}
1925  				   if(BGHS[SelfIndex].cursorrow == BGHS[SelfIndex].rows){break;}
1926  				   GetClientRect(hWnd,&gridrect);
1927  				   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
1928  				   DrawCursor(hWnd,SelfIndex);
1929  				   BGHS[SelfIndex].cursorrow += rpp;
1930  				   if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
1931  					   {
1932  						BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
1933  					   }
1934  				   NotifyRowChanged(hWnd,SelfIndex);
1935  				   DrawCursor(hWnd,SelfIndex);
1936  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1937                     SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1938  				   RefreshGrid(hWnd);
1939                     break;
1940  				  }
1941  			  if(wParam == VK_PRIOR)
1942  				  {
1943  				   RECT gridrect;
1944  				   int rpp;
1945                     if(BGHS[SelfIndex].EDITING)
1946                         {
1947                          CloseEdit(hWnd,SelfIndex);
1948                         }
1949                     if(BGHS[SelfIndex].rows == 0){break;}
1950  				   if(BGHS[SelfIndex].cursorrow == 1){break;}
1951  				   GetClientRect(hWnd,&gridrect);
1952  				   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
1953  				   DrawCursor(hWnd,SelfIndex);
1954  				   BGHS[SelfIndex].cursorrow -= rpp;
1955  				   if(BGHS[SelfIndex].cursorrow < 1)
1956  					   {
1957  						BGHS[SelfIndex].cursorrow = 1;
1958  					   }
1959  				   NotifyRowChanged(hWnd,SelfIndex);
1960  				   DrawCursor(hWnd,SelfIndex);
1961  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1962  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1963  				   RefreshGrid(hWnd);
1964                     break;
1965  				  }
1966  			  if(wParam == VK_DOWN)
1967  				  {
1968                     if(BGHS[SelfIndex].EDITING)
1969                         {
1970                          CloseEdit(hWnd,SelfIndex);
1971                         }
1972                     if(BGHS[SelfIndex].rows == 0){break;}
1973  				   if(BGHS[SelfIndex].cursorrow == BGHS[SelfIndex].rows){break;}
1974  				   DrawCursor(hWnd,SelfIndex);
1975  				   BGHS[SelfIndex].cursorrow ++;
1976  				   if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
1977  					   {
1978  					    BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
1979  					   }
1980  				   else
1981  					   {
1982  				        NotifyRowChanged(hWnd,SelfIndex);
1983  					   }
1984  				   DrawCursor(hWnd,SelfIndex);
1985  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1986  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1987  				   RefreshGrid(hWnd);
1988                     break;
1989  				  }
1990  			  if(wParam == VK_UP)
1991  				  {
1992                     if(BGHS[SelfIndex].EDITING)
1993                         {
1994                          CloseEdit(hWnd,SelfIndex);
1995                         }
1996                     if(BGHS[SelfIndex].rows == 0){break;}
1997  				   if(BGHS[SelfIndex].cursorrow == 1){break;}
1998  				   DrawCursor(hWnd,SelfIndex);
1999  				   BGHS[SelfIndex].cursorrow --;
2000  				   if(BGHS[SelfIndex].cursorrow < 1)
2001                         {
2002                          BGHS[SelfIndex].cursorrow = 1;
2003                         }
2004                     else
2005                         {
2006  				        NotifyRowChanged(hWnd,SelfIndex);
2007                         }
2008  				   DrawCursor(hWnd,SelfIndex);
2009  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2010  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2011  				   RefreshGrid(hWnd);
2012                     break;
2013  				  }
2014  			  if(wParam == VK_LEFT)
2015  				  {
2016                     int k;
2017                     if(BGHS[SelfIndex].EDITING)
2018                         {
2019                          CloseEdit(hWnd,SelfIndex);
2020                         }
2021                     if(!GetNextColWithWidth(SelfIndex,BGHS[SelfIndex].cursorcol,-1))
2022                         {
2023                          break;
2024                         }
2025  				   DrawCursor(hWnd,SelfIndex);
2026                     k=GetNextColWithWidth(SelfIndex,BGHS[SelfIndex].cursorcol,-1);
2027                     if(k)
2028                         {
2029                          BGHS[SelfIndex].cursorcol = k;
2030  						NotifyColChanged(hWnd,SelfIndex);
2031                         }
2032  				   DrawCursor(hWnd,SelfIndex);
2033  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2034  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2035                     break;
2036  				  }
2037  			  if(wParam == VK_RIGHT)
2038  				  {
2039                     int k;
2040                     if(BGHS[SelfIndex].EDITING)
2041                         {
2042                          CloseEdit(hWnd,SelfIndex);
2043                         }
2044  				   DrawCursor(hWnd,SelfIndex);
2045                     k=GetNextColWithWidth(SelfIndex,BGHS[SelfIndex].cursorcol,1);
2046                     if(k)
2047                         {
2048                          BGHS[SelfIndex].cursorcol = k;
2049  						NotifyColChanged(hWnd,SelfIndex);
2050                         }
2051  				   DrawCursor(hWnd,SelfIndex);
2052  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2053  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2054                     RefreshGrid(hWnd);
2055                     break;
2056  				  }
2057                SetCurrentCellStatus(hWnd,SelfIndex);
2058                if((BGHS[SelfIndex].CURRENTCELLPROTECTED)&&(wParam == 13))
2059                    {
2060  				   DrawCursor(hWnd,SelfIndex);
2061  				   BGHS[SelfIndex].cursorrow ++;
2062  				   if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
2063  					   {
2064  					    BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
2065  					   }
2066  				   else
2067  					   {
2068  				         NotifyRowChanged(hWnd,SelfIndex);
2069  					   }
2070  				   DrawCursor(hWnd,SelfIndex);
2071  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2072  				   RefreshGrid(hWnd);
2073                     break;
2074                    }
2075                if(BGHS[SelfIndex].CURRENTCELLPROTECTED){break;}
2076                if(!BGHS[SelfIndex].EDITABLE)
2077                    {
2078                     int ascii;
2079                     ascii=GetASCII(wParam,lParam);
2080                     if(ascii == 13) 
2081                         {
2082  				           DrawCursor(hWnd,SelfIndex);
2083  				           BGHS[SelfIndex].cursorrow ++;
2084  				           if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
2085  							   {
2086  								BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
2087  							   }
2088  						   else
2089  							   {
2090  							    NotifyRowChanged(hWnd,SelfIndex);
2091  							   }
2092  				           DrawCursor(hWnd,SelfIndex);
2093  						   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2094  						   RefreshGrid(hWnd);
2095                             break;
2096                         }
2097                    }
2098                if((BGHS[SelfIndex].EDITABLE)&&(BGHS[SelfIndex].rows > 0))
2099                    {
2100  				  SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2101  				  DrawCursor(hWnd,SelfIndex);
2102  				  DrawCursor(hWnd,SelfIndex);
2103                        {
2104                          int ascii;
2105                            ascii=GetASCII(wParam,lParam);
2106                            wParam = ascii;
2107                            if((wParam >= 32)&&(wParam <= 125))
2108                                {
2109                                 TCHAR tstring[2];
2110                                 if(!BGHS[SelfIndex].EDITING)
2111                                     {
2112                                      NotifyEditBegin(hWnd,SelfIndex);
2113                                     }
2114                                 BGHS[SelfIndex].EDITING = TRUE;
2115                                 tstring[0]= (TCHAR)wParam;
2116                                 tstring[1]=0x00;
2117                                 DisplayEditString(hWnd,SelfIndex,tstring);
2118                                 break;
2119                                }
2120                            if(wParam == 8) 
2121                                {
2122                                 if(!BGHS[SelfIndex].EDITING)
2123                                     {
2124                                      NotifyEditBegin(hWnd,SelfIndex);
2125                                     }
2126                                BGHS[SelfIndex].EDITING = TRUE;
2127                                if(lstrlen(BGHS[SelfIndex].editstring)==0)
2128                                    {
2129                                     DisplayEditString(hWnd,SelfIndex, TEXT(""));
2130                                     break;
2131                                    }
2132                                else
2133                                    {
2134                                     int j;
2135                                     j=lstrlen(BGHS[SelfIndex].editstring);
2136                                     BGHS[SelfIndex].editstring[j-1]=0x00;
2137                                     DisplayEditString(hWnd,SelfIndex, TEXT(""));
2138                                    }
2139                                 break;
2140                                }
2141                            if(wParam == 13)
2142                                {
2143                                 if(BGHS[SelfIndex].EDITING)
2144                                     {
2145                                      CloseEdit(hWnd,SelfIndex);
2146                                     }
2147  				               DrawCursor(hWnd,SelfIndex);
2148  				               BGHS[SelfIndex].cursorrow ++;
2149  				               if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
2150  								   {
2151  								    BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
2152  								   }
2153  							   else
2154  								   {
2155  							        NotifyRowChanged(hWnd,SelfIndex);
2156  								   }
2157  				               DrawCursor(hWnd,SelfIndex);
2158  							   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2159  							   RefreshGrid(hWnd);
2160                                 BGHS[SelfIndex].EDITING = FALSE;
2161                                 break;
2162                                }
2163                        }
2164                    }
2165  			break;
2166          case WM_HSCROLL:
2167                    SetFocus(hWnd);
2168                    if((LOWORD(wParam==SB_LINERIGHT))||(LOWORD(wParam)==SB_PAGERIGHT))
2169                        {
2170                         int cp,np;
2171                         cp=GetScrollPos(hWnd,SB_HORZ);
2172                         SetScrollPos(hWnd,SB_HORZ,cp+1,TRUE);
2173                         cp=GetScrollPos(hWnd,SB_HORZ);
2174                         np=GetNthVisibleColumn(hWnd,SelfIndex,cp);
2175                         BGHS[SelfIndex].homecol = np;
2176                         SetScrollPos(hWnd,SB_HORZ,cp,TRUE);
2177                         RefreshGrid(hWnd);
2178                        }
2179                    if((LOWORD(wParam==SB_LINELEFT))||(LOWORD(wParam)==SB_PAGELEFT))
2180                        {
2181                         int cp,np;
2182                         cp=GetScrollPos(hWnd,SB_HORZ);
2183                         SetScrollPos(hWnd,SB_HORZ,cp-1,TRUE);
2184                         cp=GetScrollPos(hWnd,SB_HORZ);
2185                         np=GetNthVisibleColumn(hWnd,SelfIndex,cp);
2186                         BGHS[SelfIndex].homecol = np;
2187                         SetScrollPos(hWnd,SB_HORZ,cp,TRUE);
2188                         RefreshGrid(hWnd);
2189                        }
2190                    if(LOWORD(wParam)==SB_THUMBTRACK)
2191                        {
2192                         int cp,np;
2193                         cp=HIWORD(wParam);
2194                         np=GetNthVisibleColumn(hWnd,SelfIndex,cp);
2195                         SetScrollPos(hWnd,SB_HORZ,np,TRUE);
2196                         BGHS[SelfIndex].homecol = np;
2197                         SetScrollPos(hWnd,SB_HORZ,cp,TRUE);
2198                         RefreshGrid(hWnd);
2199                        }
2200              break;
2201  		case WM_MOUSEWHEEL :
2202  		{
2203  			short zDelta = (short) HIWORD(wParam);
2204  			::SendMessage(hWnd, WM_VSCROLL, zDelta < 0?SB_LINEDOWN:SB_LINEUP, 0);
2205              return TRUE;
2206  		}
2207  		case WM_VSCROLL:
2208                    SetFocus(hWnd);
2209  				  if(LOWORD(wParam)==SB_THUMBTRACK)
2210  					  {
2211  					   RECT gridrect;
2212  					   int min,max;
2213  					   BGHS[SelfIndex].homerow = HIWORD(wParam);
2214  					   SetScrollPos(hWnd,SB_VERT,HIWORD(wParam),TRUE);
2215  					   GetClientRect(hWnd,&gridrect);
2216  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2217  					   if(HIWORD(wParam)==max)
2218  						   {
2219  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2220  							InvalidateRect(hWnd,&gridrect,TRUE);
2221  						   }
2222  					   else
2223  						   {
2224  					        InvalidateRect(hWnd,&gridrect,FALSE);
2225  						   }
2226  					  }
2227  				  if(LOWORD(wParam)==SB_PAGEDOWN)
2228  					  {
2229  					   RECT gridrect;
2230  					   int min,max,sp,rpp;
2231  					   GetClientRect(hWnd,&gridrect);
2232  					   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
2233  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2234  					   sp=GetScrollPos(hWnd,SB_VERT);
2235  					   sp += rpp;
2236  					   if(sp > max){sp=max;}
2237  					   BGHS[SelfIndex].homerow = sp;
2238  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2239  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2240  					   if(sp==max)
2241  						   {
2242  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2243  							InvalidateRect(hWnd,&gridrect,TRUE);
2244  						   }
2245  					   else
2246  						   {
2247  					        InvalidateRect(hWnd,&gridrect,FALSE);
2248  						   }
2249  					  }
2250  				  if(LOWORD(wParam)==SB_LINEDOWN)
2251  					  {
2252  					   RECT gridrect;
2253  					   int min,max,sp;
2254  					   GetClientRect(hWnd,&gridrect);
2255  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2256  					   sp=GetScrollPos(hWnd,SB_VERT);
2257  					   sp += 1;
2258  					   if(sp > max){sp=max;}
2259  					   BGHS[SelfIndex].homerow = sp;
2260  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2261  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2262  					   if(sp==max)
2263  						   {
2264  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2265  							InvalidateRect(hWnd,&gridrect,TRUE);
2266  						   }
2267  					   else
2268  						   {
2269  					        InvalidateRect(hWnd,&gridrect,FALSE);
2270  						   }
2271  					  }
2272  				  	if(LOWORD(wParam)==SB_PAGEUP)
2273  					  {
2274  					   RECT gridrect;
2275  					   int min,max,sp,rpp;
2276  					   GetClientRect(hWnd,&gridrect);
2277  					   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
2278  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2279  					   sp=GetScrollPos(hWnd,SB_VERT);
2280  					   sp -= rpp;
2281  					   if(sp < 1){sp=1;}
2282  					   BGHS[SelfIndex].homerow = sp;
2283  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2284  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2285  					   if(sp==max)
2286  						   {
2287  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2288  							InvalidateRect(hWnd,&gridrect,TRUE);
2289  						   }
2290  					   else
2291  						   {
2292  					        InvalidateRect(hWnd,&gridrect,FALSE);
2293  						   }
2294  					  }
2295  				  	if(LOWORD(wParam)==SB_LINEUP)
2296  					  {
2297  					   RECT gridrect;
2298  					   int min,max,sp;
2299  					   GetClientRect(hWnd,&gridrect);
2300  					   sp=GetScrollPos(hWnd,SB_VERT);
2301  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2302  					   sp -= 1;
2303  					   if(sp < 1){sp=1;}
2304  					   BGHS[SelfIndex].homerow = sp;
2305  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2306  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2307  					   if(sp==max)
2308  						   {
2309  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2310  							InvalidateRect(hWnd,&gridrect,TRUE);
2311  						   }
2312  					   else
2313  						   {
2314  					        InvalidateRect(hWnd,&gridrect,FALSE);
2315  						   }
2316  					  }
2317                        RefreshGrid(hWnd);
2318  			break;
2319  		case WM_DESTROY:
2320  			{ int k;
2321                  if(CountGrids()==0)
2322                      {
2323                       DeleteObject(hfontbody);
2324                       DeleteObject(hfontheader);
2325                       DeleteObject(hfonttitle);
2326                      }
2327                  SendMessage(BGHS[SelfIndex].hlist1,LB_RESETCONTENT,0,0);
2328  			    DestroyWindow(BGHS[SelfIndex].hlist1);
2329  				BGHS[SelfIndex].gridmenu = 0;
2330  				BGHS[SelfIndex].hlist1 = NULL;
2331  				BGHS[SelfIndex].hfont = NULL;
2332  				wcscpy_s(BGHS[SelfIndex].protect, TEXT("U"));
2333  				BGHS[SelfIndex].rows = 100;
2334  				BGHS[SelfIndex].cols = 255;
2335  				BGHS[SelfIndex].homerow = 1;
2336  				BGHS[SelfIndex].homecol = 1;
2337  				BGHS[SelfIndex].rowheight = 20;
2338  				BGHS[SelfIndex].headerrowheight = 20;
2339  				BGHS[SelfIndex].ROWSNUMBERED = TRUE;
2340  				BGHS[SelfIndex].COLUMNSNUMBERED = TRUE;
2341                  BGHS[SelfIndex].DRAWHIGHLIGHT = TRUE;
2342  				BGHS[SelfIndex].cursorcol = 1;
2343  				BGHS[SelfIndex].cursorrow = 1;
2344  				BGHS[SelfIndex].columnwidths[0]=40;
2345  				BGHS[SelfIndex].ADVANCEROW = TRUE;
2346  				BGHS[SelfIndex].cursorcolor = RGB(255,255,255);
2347  				BGHS[SelfIndex].protectcolor = RGB(128,128,128);
2348  				BGHS[SelfIndex].unprotectcolor = RGB(255,255,255);
2349  				for(k=1;k<MAX_COLS;k++)
2350  					{
2351  					 BGHS[SelfIndex].columnwidths[k]=50;
2352  					}
2353  				}
2354  			break;
2355  		case WM_SETFOCUS:
2356  			   DrawCursor(hWnd,SelfIndex);
2357  			   BGHS[SelfIndex].GRIDHASFOCUS	= TRUE;
2358                 DrawCursor(hWnd,SelfIndex);
2359                 SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2360                 SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2361                 wParam=MAKEWPARAM(GetMenu(hWnd),BGN_GOTFOCUS);
2362                 lParam = 0;
2363                 SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
2364                     {TEXTMETRIC tm;
2365                      HDC hdc;
2366                      hdc=GetDC(hWnd);
2367                      GetTextMetrics(hdc,&tm);
2368                      ReleaseDC(hWnd,hdc);
2369                      BGHS[SelfIndex].fontascentheight = (int)tm.tmAscent;
2370                      CreateCaret(hWnd,NULL,3,tm.tmAscent);
2371                     }
2372  			   RefreshGrid(hWnd);
2373  			break;
2374  		case WM_KILLFOCUS:
2375                 DestroyCaret();
2376  			   DrawCursor(hWnd,SelfIndex);
2377  			   BGHS[SelfIndex].GRIDHASFOCUS	= FALSE;
2378                 wParam=MAKEWPARAM(GetMenu(hWnd),BGN_LOSTFOCUS);
2379                 lParam = 0;
2380                 SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
2381                 RefreshGrid(hWnd);
2382  			break;
2383          case WM_SETFONT:
2384                BGHS[SelfIndex].hfont = (HFONT)wParam;
2385                if(!BGHS[SelfIndex].hcolumnheadingfont)
2386                    {
2387                     BGHS[SelfIndex].hcolumnheadingfont = (HFONT)wParam;
2388                    }
2389                if(!BGHS[SelfIndex].htitlefont)
2390                    {
2391                     BGHS[SelfIndex].htitlefont = (HFONT)wParam;
2392                    }
2393                RefreshGrid(hWnd);
2394              break;
2395  		case WM_SIZE:
2396  		{
2397  			if (!BGHS[SelfIndex].SHOWINTEGRALROWS)
2398  				break;
2399  			ShowHscroll(hWnd, SelfIndex);
2400  			ShowVscroll(hWnd, SelfIndex);
2401  			if (BGHS[SelfIndex].VSCROLL)
2402  			{
2403  				static int masterHeight = 0; 
2404  				WINDOWPLACEMENT wp;
2405  				wp.length = sizeof(wp);
2406  				::GetWindowPlacement(hWnd, &wp);
2407  				if (masterHeight < 1)
2408  				{
2409  					masterHeight = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
2410  					if (masterHeight < 1)
2411  						break;
2412  				}
2413  				int outerHeight = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
2414  				int innerHeight = outerHeight;
2415  				innerHeight -= BGHS[SelfIndex].titleheight;
2416  				innerHeight -= BGHS[SelfIndex].headerrowheight;
2417  				if (::GetWindowLong(hWnd, GWL_EXSTYLE) & WS_EX_CLIENTEDGE)
2418  					innerHeight -= ::GetSystemMetrics(SM_CYEDGE) * 2;
2419  				if (BGHS[SelfIndex].HSCROLL)
2420  					innerHeight -= ::GetSystemMetrics(SM_CYHSCROLL);
2421  				if (innerHeight <= BGHS[SelfIndex].rowheight * 4)
2422  					break;
2423  				else
2424  				{
2425  					int remainder = innerHeight % BGHS[SelfIndex].rowheight;
2426  					if ((outerHeight + BGHS[SelfIndex].rowheight - remainder) <= masterHeight)
2427  						outerHeight += BGHS[SelfIndex].rowheight - remainder;
2428  					else
2429  						outerHeight -= remainder;
2430  					wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + outerHeight;
2431  					::SetWindowPlacement(hWnd, &wp);
2432  				}
2433  			}
2434  		}
2435  		break;
2436  		case WM_CREATE:
2437  			  lpcs = (LPCREATESTRUCT)lParam;
2438  			  hInst = lpcs->hInstance;
2439                BG_GridIndex = AddGrid(GetMenu(hWnd));
2440                if(CountGrids()==1)
2441                    {
2442                     hfontbody=CreateFont(16,0,0, 0,
2443  										100,
2444  										FALSE,
2445  										FALSE,FALSE,DEFAULT_CHARSET,
2446  										OUT_DEFAULT_PRECIS,
2447  										CLIP_DEFAULT_PRECIS,
2448  										0,
2449  										0 ,
2450  										TEXT("MS Shell Dlg"));
2451                     hfontheader=CreateFont(18,0,0, 0,FW_HEAVY,FALSE,FALSE,FALSE,DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, 0, 0, TEXT("MS Shell Dlg"));
2452                     hfonttitle=CreateFont(20,0,0, 0,FW_HEAVY,FALSE,FALSE,FALSE,DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, 0, 0, TEXT("MS Shell Dlg"));
2453                    }
2454                if((BG_GridIndex >= 0)&&(BG_GridIndex < MAX_GRIDS))
2455                    {
2456  			          BGHS[BG_GridIndex].gridmenu = GetMenu(hWnd);
2457  			          BGHS[BG_GridIndex].hlist1=CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("LISTBOX"), TEXT(""),
2458  				          WS_CHILD|LBS_STANDARD,50,150,200,100,hWnd,NULL,hInst,NULL);
2459  		              BGHS[BG_GridIndex].hfont = hfontbody;
2460                        BGHS[BG_GridIndex].htitlefont = hfonttitle;
2461                        BGHS[BG_GridIndex].hcolumnheadingfont = hfontheader;
2462  					  wcscpy_s(BGHS[BG_GridIndex].title,lpcs->lpszName);
2463  					  SendMessage(hWnd, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(lpcs->lpszName));
2464                    }
2465                if(BG_GridIndex == -1)
2466                    {
2467                     DestroyWindow(hWnd);
2468                    }
2469  			break;
2470  		default:
2471  			return DefWindowProc(hWnd, message, wParam, lParam);
2472     }
2473     return ReturnValue;
2474  }
2475  int CountGrids()
2476  	{
2477  	 int j,count;
2478  	 count=0;
2479  	 for(j=0;j<MAX_GRIDS;j++)
2480  		 if(BGHS[j].gridmenu != 0)
2481  			 {
2482  			  count++;
2483  			 }
2484  	 return count;
2485  	}
2486  int AddGrid( HMENU menuid)
2487      {
2488       int empty_space = -1;
2489       int returnvalue = 0;
2490       int j;
2491       BOOL MATCH;
2492       MATCH=FALSE;
2493       for(j=0;j<MAX_GRIDS;j++)
2494           {
2495            if(BGHS[j].gridmenu == menuid)
2496                {
2497                 MATCH=TRUE;
2498                 returnvalue=j;
2499                }
2500            if(BGHS[j].gridmenu == 0)
2501                {
2502                 empty_space = j;
2503                }
2504           }
2505       if((!MATCH)&&(empty_space >= 0))
2506           {
2507            BGHS[empty_space].gridmenu = menuid;
2508            returnvalue=empty_space;
2509           }
2510       if(MATCH)
2511           {
2512            return returnvalue+MAX_GRIDS;
2513           }
2514       if((!MATCH)&&(empty_space == -1))
2515           {
2516            return -1;
2517           }
2518       return returnvalue;
2519      }
2520  int FindGrid( HMENU menuid)
2521      {
2522       int returnvalue;
2523       int j;
2524       returnvalue = -1;
2525       for(j=0;j<MAX_GRIDS;j++)
2526           {
2527            if(BGHS[j].gridmenu == menuid)
2528                {
2529                 returnvalue=j;
2530                }
2531           }
2532       return returnvalue;
2533      }
2534  int BinarySearchListBox(HWND lbhWnd,TCHAR* searchtext)
2535      {
2536        int ReturnValue;
2537        int lbcount;
2538        int head,tail,finger;
2539        int FindResult;
2540  	  const size_t bufLen = 1000;
2541        TCHAR tbuffer[bufLen];
2542  	  TCHAR headtext[bufLen];
2543  	  TCHAR tailtext[bufLen];
2544        int p;
2545       BOOL FOUND;
2546       FOUND=FALSE;
2547  	 lbcount = static_cast<int32_t>(SendMessage(lbhWnd, LB_GETCOUNT, 0, 0));
2548       if(lbcount == 0)
2549           {
2550             ReturnValue = LB_ERR;
2551             return ReturnValue;
2552           }
2553       if(lbcount < 12)
2554           {
2555  			 FindResult = static_cast<int32_t>(SendMessage(lbhWnd, LB_FINDSTRING, static_cast<unsigned int>(-1), reinterpret_cast<LPARAM>(searchtext)));
2556            ReturnValue = FindResult;
2557            return ReturnValue;
2558           }
2559       head = 0;
2560       tail = lbcount - 1;
2561  	 auto lbTextLen = ::SendMessage(lbhWnd, LB_GETTEXTLEN, head, 0);
2562  	 if (static_cast<size_t>(lbTextLen) > bufLen)
2563  		 return 0;
2564       SendMessage(lbhWnd, LB_GETTEXT, head, reinterpret_cast<LPARAM>(headtext));
2565       headtext[9] = 0x00;
2566  	 p=lstrcmp(searchtext,headtext);
2567       if(p==0)
2568           {
2569            ReturnValue = head;
2570            return ReturnValue;
2571           }
2572  	 if(p<0)
2573  		 {
2574  		  ReturnValue = LB_ERR;
2575  		  return ReturnValue;
2576  		 }
2577  	 lbTextLen = ::SendMessage(lbhWnd, LB_GETTEXTLEN, tail, 0);
2578  	 if (static_cast<size_t>(lbTextLen) > bufLen)
2579  		 return 0;
2580  	 SendMessage(lbhWnd, LB_GETTEXT, tail, reinterpret_cast<LPARAM>(tailtext));
2581       tailtext[9] = 0x00;
2582  	 p=lstrcmp(searchtext,tailtext);
2583       if(p==0)
2584           {
2585            ReturnValue = tail;
2586            return ReturnValue;
2587           }
2588  	 if(p>0)
2589  		 {
2590  		  ReturnValue = LB_ERR;
2591  		  return ReturnValue;
2592  		 }
2593       ReturnValue = LB_ERR;
2594  	 FOUND=FALSE;
2595       while ((!FOUND)&&((tail-head)>1))
2596           {
2597                    finger = head + ((tail - head) / 2);
2598  				  lbTextLen = ::SendMessage(lbhWnd, LB_GETTEXTLEN, finger, 0);
2599  				  if (static_cast<size_t>(lbTextLen) > bufLen)
2600  					  return 0;
2601  				  SendMessage(lbhWnd, LB_GETTEXT, finger, reinterpret_cast<LPARAM>(tbuffer));
2602                   tbuffer[9] = 0x00;
2603                   p=lstrcmp(tbuffer,searchtext);
2604                   if(p==0)
2605                       {
2606                        FOUND=TRUE;
2607                        ReturnValue = finger;
2608                       }
2609                   if(p<0)
2610                       {
2611                        head = finger;
2612                       }
2613                   if(p>0)
2614                           {
2615                           tail = finger;
2616                           }
2617           }
2618       return ReturnValue;
2619      }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tabfind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "alignedblob.h"
5  #include "colpartitiongrid.h"
6  #include "detlinefit.h"
7  #include "host.h" 
8  #include "linefind.h"
9  #include "tabfind.h"
10  #include <algorithm>
11  namespace tesseract {
12  const int kTabRadiusFactor = 5;
13  const int kMinVerticalSearch = 3;
14  const int kMaxVerticalSearch = 12;
15  const int kMaxRaggedSearch = 25;
16  const int kMinLinesInColumn = 10;
17  const int kMinColumnWidth = 200;
18  const double kMinFractionalLinesInColumn = 0.125;
19  const double kAlignedFraction = 0.03125;
20  const double kMaxGutterWidthAbsolute = 2.00;
21  const int kRaggedGutterMultiple = 5;
22  const double kLineFragmentAspectRatio = 10.0;
23  const int kMinEvaluatedTabs = 3;
24  const double kCosMaxSkewAngle = 0.866025;
25  static BOOL_VAR(textord_tabfind_show_initialtabs, false, "Show tab candidates");
26  static BOOL_VAR(textord_tabfind_show_finaltabs, false, "Show tab vectors");
27  TabFind::TabFind(int gridsize, const ICOORD &bleft, const ICOORD &tright, TabVector_LIST *vlines,
28                   int vertical_x, int vertical_y, int resolution)
29      : AlignedBlob(gridsize, bleft, tright)
30      , resolution_(resolution)
31      , image_origin_(0, tright.y() - 1)
32      , v_it_(&vectors_) {
33    width_cb_ = nullptr;
34    v_it_.add_list_after(vlines);
35    SetVerticalSkewAndParallelize(vertical_x, vertical_y);
36    using namespace std::placeholders; 
37    width_cb_ = std::bind(&TabFind::CommonWidth, this, _1);
38  }
39  TabFind::~TabFind() = default;
40  void TabFind::InsertBlobsToGrid(bool h_spread, bool v_spread, BLOBNBOX_LIST *blobs,
41                                  BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> *grid) {
42    BLOBNBOX_IT blob_it(blobs);
43    int b_count = 0;
44    int reject_count = 0;
45    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
46      BLOBNBOX *blob = blob_it.data();
47      if (InsertBlob(h_spread, v_spread, blob, grid)) {
48        ++b_count;
49      } else {
50        ++reject_count;
51      }
52    }
53    if (textord_debug_tabfind) {
54      tprintf("Inserted %d blobs into grid, %d rejected.\n", b_count, reject_count);
55    }
56  }
57  bool TabFind::InsertBlob(bool h_spread, bool v_spread, BLOBNBOX *blob,
58                           BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> *grid) {
59    TBOX box = blob->bounding_box();
60    blob->set_left_rule(LeftEdgeForBox(box, false, false));
61    blob->set_right_rule(RightEdgeForBox(box, false, false));
62    blob->set_left_crossing_rule(LeftEdgeForBox(box, true, false));
63    blob->set_right_crossing_rule(RightEdgeForBox(box, true, false));
64    if (blob->joined_to_prev()) {
65      return false;
66    }
67    grid->InsertBBox(h_spread, v_spread, blob);
68    return true;
69  }
70  void TabFind::SetBlockRuleEdges(TO_BLOCK *block) {
71    SetBlobRuleEdges(&block->blobs);
72    SetBlobRuleEdges(&block->small_blobs);
73    SetBlobRuleEdges(&block->noise_blobs);
74    SetBlobRuleEdges(&block->large_blobs);
75  }
76  void TabFind::SetBlobRuleEdges(BLOBNBOX_LIST *blobs) {
77    BLOBNBOX_IT blob_it(blobs);
78    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
79      BLOBNBOX *blob = blob_it.data();
80      TBOX box = blob->bounding_box();
81      blob->set_left_rule(LeftEdgeForBox(box, false, false));
82      blob->set_right_rule(RightEdgeForBox(box, false, false));
83      blob->set_left_crossing_rule(LeftEdgeForBox(box, true, false));
84      blob->set_right_crossing_rule(RightEdgeForBox(box, true, false));
85    }
86  }
87  int TabFind::GutterWidth(int bottom_y, int top_y, const TabVector &v, bool ignore_unmergeables,
88                           int max_gutter_width, int *required_shift) {
89    bool right_to_left = v.IsLeftTab();
90    int bottom_x = v.XAtY(bottom_y);
91    int top_x = v.XAtY(top_y);
92    int start_x = right_to_left ? std::max(top_x, bottom_x) : std::min(top_x, bottom_x);
93    BlobGridSearch sidesearch(this);
94    sidesearch.StartSideSearch(start_x, bottom_y, top_y);
95    int min_gap = max_gutter_width;
96    *required_shift = 0;
97    BLOBNBOX *blob = nullptr;
98    while ((blob = sidesearch.NextSideSearch(right_to_left)) != nullptr) {
99      const TBOX &box = blob->bounding_box();
100      if (box.bottom() >= top_y || box.top() <= bottom_y) {
101        continue; 
102      }
103      if (box.height() >= gridsize() * 2 && box.height() > box.width() * kLineFragmentAspectRatio) {
104        continue;
105      }
106      if (ignore_unmergeables && BLOBNBOX::UnMergeableType(blob->region_type())) {
107        continue; 
108      }
109      int mid_y = (box.bottom() + box.top()) / 2;
110      int tab_x = v.XAtY(mid_y);
111      int gap;
112      if (right_to_left) {
113        gap = tab_x - box.right();
114        if (gap < 0 && box.left() - tab_x < *required_shift) {
115          *required_shift = box.left() - tab_x;
116        }
117      } else {
118        gap = box.left() - tab_x;
119        if (gap < 0 && box.right() - tab_x > *required_shift) {
120          *required_shift = box.right() - tab_x;
121        }
122      }
123      if (gap > 0 && gap < min_gap) {
124        min_gap = gap;
125      }
126    }
127    return min_gap - abs(*required_shift);
128  }
129  void TabFind::GutterWidthAndNeighbourGap(int tab_x, int mean_height, int max_gutter, bool left,
130                                           BLOBNBOX *bbox, int *gutter_width, int *neighbour_gap) {
131    const TBOX &box = bbox->bounding_box();
132    int gutter_x = left ? box.left() : box.right();
133    int internal_x = left ? box.right() : box.left();
134    int tab_gap = left ? gutter_x - tab_x : tab_x - gutter_x;
135    *gutter_width = max_gutter;
136    if (tab_gap > 0) {
137      *gutter_width += tab_gap;
138    }
139    bool debug = WithinTestRegion(2, box.left(), box.bottom());
140    if (debug) {
141      tprintf("Looking in gutter\n");
142    }
143    BLOBNBOX *gutter_bbox = AdjacentBlob(bbox, left, bbox->flow() == BTFT_TEXT_ON_IMAGE, 0.0,
144                                         *gutter_width, box.top(), box.bottom());
145    if (gutter_bbox != nullptr) {
146      const TBOX &gutter_box = gutter_bbox->bounding_box();
147      *gutter_width = left ? tab_x - gutter_box.right() : gutter_box.left() - tab_x;
148    }
149    if (*gutter_width >= max_gutter) {
150      TBOX gutter_box(box);
151      if (left) {
152        gutter_box.set_left(tab_x - max_gutter - 1);
153        gutter_box.set_right(tab_x - max_gutter);
154        int tab_gutter = RightEdgeForBox(gutter_box, true, false);
155        if (tab_gutter < tab_x - 1) {
156          *gutter_width = tab_x - tab_gutter;
157        }
158      } else {
159        gutter_box.set_left(tab_x + max_gutter);
160        gutter_box.set_right(tab_x + max_gutter + 1);
161        int tab_gutter = LeftEdgeForBox(gutter_box, true, false);
162        if (tab_gutter > tab_x + 1) {
163          *gutter_width = tab_gutter - tab_x;
164        }
165      }
166    }
167    if (*gutter_width > max_gutter) {
168      *gutter_width = max_gutter;
169    }
170    if (debug) {
171      tprintf("Looking for neighbour\n");
172    }
173    BLOBNBOX *neighbour = AdjacentBlob(bbox, !left, bbox->flow() == BTFT_TEXT_ON_IMAGE, 0.0,
174                                       *gutter_width, box.top(), box.bottom());
175    int neighbour_edge = left ? RightEdgeForBox(box, true, false) : LeftEdgeForBox(box, true, false);
176    if (neighbour != nullptr) {
177      const TBOX &n_box = neighbour->bounding_box();
178      if (debug) {
179        tprintf("Found neighbour:");
180        n_box.print();
181      }
182      if (left && n_box.left() < neighbour_edge) {
183        neighbour_edge = n_box.left();
184      } else if (!left && n_box.right() > neighbour_edge) {
185        neighbour_edge = n_box.right();
186      }
187    }
188    *neighbour_gap = left ? neighbour_edge - internal_x : internal_x - neighbour_edge;
189  }
190  int TabFind::RightEdgeForBox(const TBOX &box, bool crossing, bool extended) {
191    TabVector *v = RightTabForBox(box, crossing, extended);
192    return v == nullptr ? tright_.x() : v->XAtY((box.top() + box.bottom()) / 2);
193  }
194  int TabFind::LeftEdgeForBox(const TBOX &box, bool crossing, bool extended) {
195    TabVector *v = LeftTabForBox(box, crossing, extended);
196    return v == nullptr ? bleft_.x() : v->XAtY((box.top() + box.bottom()) / 2);
197  }
198  TabVector *TabFind::RightTabForBox(const TBOX &box, bool crossing, bool extended) {
199    if (v_it_.empty()) {
200      return nullptr;
201    }
202    int top_y = box.top();
203    int bottom_y = box.bottom();
204    int mid_y = (top_y + bottom_y) / 2;
205    int right = crossing ? (box.left() + box.right()) / 2 : box.right();
206    int min_key, max_key;
207    SetupTabSearch(right, mid_y, &min_key, &max_key);
208    while (!v_it_.at_first() && v_it_.data()->sort_key() >= min_key) {
209      v_it_.backward();
210    }
211    while (!v_it_.at_last() && v_it_.data()->sort_key() < min_key) {
212      v_it_.forward();
213    }
214    TabVector *best_v = nullptr;
215    int best_x = -1;
216    int key_limit = -1;
217    do {
218      TabVector *v = v_it_.data();
219      int x = v->XAtY(mid_y);
220      if (x >= right && (v->VOverlap(top_y, bottom_y) > 0 ||
221                         (extended && v->ExtendedOverlap(top_y, bottom_y) > 0))) {
222        if (best_v == nullptr || x < best_x) {
223          best_v = v;
224          best_x = x;
225          key_limit = v->sort_key() + max_key - min_key;
226        }
227      }
228      if (v_it_.at_last() || (best_v != nullptr && v->sort_key() > key_limit)) {
229        break; 
230      }
231      v_it_.forward();
232    } while (!v_it_.at_first());
233    return best_v;
234  }
235  TabVector *TabFind::LeftTabForBox(const TBOX &box, bool crossing, bool extended) {
236    if (v_it_.empty()) {
237      return nullptr;
238    }
239    int top_y = box.top();
240    int bottom_y = box.bottom();
241    int mid_y = (top_y + bottom_y) / 2;
242    int left = crossing ? (box.left() + box.right()) / 2 : box.left();
243    int min_key, max_key;
244    SetupTabSearch(left, mid_y, &min_key, &max_key);
245    while (!v_it_.at_last() && v_it_.data()->sort_key() <= max_key) {
246      v_it_.forward();
247    }
248    while (!v_it_.at_first() && v_it_.data()->sort_key() > max_key) {
249      v_it_.backward();
250    }
251    TabVector *best_v = nullptr;
252    int best_x = -1;
253    int key_limit = -1;
254    do {
255      TabVector *v = v_it_.data();
256      int x = v->XAtY(mid_y);
257      if (x <= left && (v->VOverlap(top_y, bottom_y) > 0 ||
258                        (extended && v->ExtendedOverlap(top_y, bottom_y) > 0))) {
259        if (best_v == nullptr || x > best_x) {
260          best_v = v;
261          best_x = x;
262          key_limit = v->sort_key() - (max_key - min_key);
263        }
264      }
265      if (v_it_.at_first() || (best_v != nullptr && v->sort_key() < key_limit)) {
266        break; 
267      }
268      v_it_.backward();
269    } while (!v_it_.at_last());
270    return best_v;
271  }
272  bool TabFind::CommonWidth(int width) {
273    width /= kColumnWidthFactor;
274    ICOORDELT_IT it(&column_widths_);
275    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
276      ICOORDELT *w = it.data();
277      if (w->x() - 1 <= width && width <= w->y() + 1) {
278        return true;
279      }
280    }
281    return false;
282  }
283  bool TabFind::DifferentSizes(int size1, int size2) {
284    return size1 > size2 * 2 || size2 > size1 * 2;
285  }
286  bool TabFind::VeryDifferentSizes(int size1, int size2) {
287    return size1 > size2 * 5 || size2 > size1 * 5;
288  }
289  bool TabFind::FindTabVectors(TabVector_LIST *hlines, BLOBNBOX_LIST *image_blobs, TO_BLOCK *block,
<span onclick='openModal()' class='match'>290                               int min_gutter_width, double tabfind_aligned_gap_fraction,
291                               ColPartitionGrid *part_grid, FCOORD *deskew, FCOORD *reskew) {
292    ScrollView *tab_win =
293        FindInitialTabVectors(image_blobs, min_gutter_width, tabfind_aligned_gap_fraction, block);
294    ComputeColumnWidths(tab_win, part_grid);
</span>295    TabVector::MergeSimilarTabVectors(vertical_skew_, &vectors_, this);
296    SortVectors();
297    CleanupTabs();
298    if (!Deskew(hlines, image_blobs, block, deskew, reskew)) {
299      return false; 
300    }
301    part_grid->Deskew(*deskew);
302    ApplyTabConstraints();
303  #ifndef GRAPHICS_DISABLED
304    if (textord_tabfind_show_finaltabs) {
305      tab_win = MakeWindow(640, 50, "FinalTabs");
306      DisplayBoxes(tab_win);
307      DisplayTabs("FinalTabs", tab_win);
308      tab_win = DisplayTabVectors(tab_win);
309    }
310  #endif 
311    return true;
312  }
313  void TabFind::DontFindTabVectors(BLOBNBOX_LIST *image_blobs, TO_BLOCK *block, FCOORD *deskew,
314                                   FCOORD *reskew) {
315    InsertBlobsToGrid(false, false, image_blobs, this);
316    InsertBlobsToGrid(true, false, &block->blobs, this);
317    deskew->set_x(1.0f);
318    deskew->set_y(0.0f);
319    reskew->set_x(1.0f);
320    reskew->set_y(0.0f);
321  }
322  void TabFind::TidyBlobs(TO_BLOCK *block) {
323    BLOBNBOX_IT large_it = &block->large_blobs;
324    BLOBNBOX_IT blob_it = &block->blobs;
325    int b_count = 0;
326    for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
327      BLOBNBOX *large_blob = large_it.data();
328      if (large_blob->owner() != nullptr) {
329        blob_it.add_to_end(large_it.extract());
330        ++b_count;
331      }
332    }
333    if (textord_debug_tabfind) {
334      tprintf("Moved %d large blobs to normal list\n", b_count);
335  #ifndef GRAPHICS_DISABLED
336      ScrollView *rej_win = MakeWindow(500, 300, "Image blobs");
337      block->plot_graded_blobs(rej_win);
338      block->plot_noise_blobs(rej_win);
339      rej_win->Update();
340  #endif 
341    }
342    block->DeleteUnownedNoise();
343  }
344  void TabFind::SetupTabSearch(int x, int y, int *min_key, int *max_key) {
345    int key1 = TabVector::SortKey(vertical_skew_, x, (y + tright_.y()) / 2);
346    int key2 = TabVector::SortKey(vertical_skew_, x, (y + bleft_.y()) / 2);
347    *min_key = std::min(key1, key2);
348    *max_key = std::max(key1, key2);
349  }
350  #ifndef GRAPHICS_DISABLED
351  ScrollView *TabFind::DisplayTabVectors(ScrollView *tab_win) {
352    TabVector_IT it(&vectors_);
353    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
354      TabVector *vector = it.data();
355      vector->Display(tab_win);
356    }
357    tab_win->Update();
358    return tab_win;
359  }
360  #endif
361  ScrollView *TabFind::FindInitialTabVectors(BLOBNBOX_LIST *image_blobs, int min_gutter_width,
362                                             double tabfind_aligned_gap_fraction, TO_BLOCK *block) {
363  #ifndef GRAPHICS_DISABLED
364    if (textord_tabfind_show_initialtabs) {
365      ScrollView *line_win = MakeWindow(0, 0, "VerticalLines");
366      line_win = DisplayTabVectors(line_win);
367    }
368  #endif
369    if (image_blobs != nullptr) {
370      InsertBlobsToGrid(true, false, image_blobs, this);
371    }
372    InsertBlobsToGrid(true, false, &block->blobs, this);
373    ScrollView *initial_win = FindTabBoxes(min_gutter_width, tabfind_aligned_gap_fraction);
374    FindAllTabVectors(min_gutter_width);
375    TabVector::MergeSimilarTabVectors(vertical_skew_, &vectors_, this);
376    SortVectors();
377    EvaluateTabs();
378  #ifndef GRAPHICS_DISABLED
379    if (textord_tabfind_show_initialtabs && initial_win != nullptr) {
380      initial_win = DisplayTabVectors(initial_win);
381    }
382  #endif
383    MarkVerticalText();
384    return initial_win;
385  }
386  #ifndef GRAPHICS_DISABLED
387  static void DisplayBoxVector(const std::vector<BLOBNBOX *> &boxes, ScrollView *win) {
388    for (auto boxe : boxes) {
389      TBOX box = boxe->bounding_box();
390      int left_x = box.left();
391      int right_x = box.right();
392      int top_y = box.top();
393      int bottom_y = box.bottom();
394      ScrollView::Color box_color = boxe->BoxColor();
395      win->Pen(box_color);
396      win->Rectangle(left_x, bottom_y, right_x, top_y);
397    }
398    win->Update();
399  }
400  #endif 
401  ScrollView *TabFind::FindTabBoxes(int min_gutter_width, double tabfind_aligned_gap_fraction) {
402    left_tab_boxes_.clear();
403    right_tab_boxes_.clear();
404    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
405    gsearch.StartFullSearch();
406    BLOBNBOX *bbox;
407    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
408      if (TestBoxForTabs(bbox, min_gutter_width, tabfind_aligned_gap_fraction)) {
409        if (bbox->left_tab_type() != TT_NONE) {
410          left_tab_boxes_.push_back(bbox);
411        }
412        if (bbox->right_tab_type() != TT_NONE) {
413          right_tab_boxes_.push_back(bbox);
414        }
415      }
416    }
417    std::sort(left_tab_boxes_.begin(), left_tab_boxes_.end(), StdSortByBoxLeft<BLOBNBOX>);
418    std::sort(right_tab_boxes_.begin(), right_tab_boxes_.end(), StdSortRightToLeft<BLOBNBOX>);
419    ScrollView *tab_win = nullptr;
420  #ifndef GRAPHICS_DISABLED
421    if (textord_tabfind_show_initialtabs) {
422      tab_win = MakeWindow(0, 100, "InitialTabs");
423      tab_win->Pen(ScrollView::BLUE);
424      tab_win->Brush(ScrollView::NONE);
425      DisplayBoxVector(left_tab_boxes_, tab_win);
426      DisplayBoxVector(right_tab_boxes_, tab_win);
427      tab_win = DisplayTabs("Tabs", tab_win);
428    }
429  #endif 
430    return tab_win;
431  }
432  bool TabFind::TestBoxForTabs(BLOBNBOX *bbox, int min_gutter_width,
433                               double tabfind_aligned_gap_fraction) {
434    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> radsearch(this);
435    TBOX box = bbox->bounding_box();
436    int left_column_edge = bbox->left_rule();
437    int right_column_edge = bbox->right_rule();
438    int left_x = box.left();
439    int right_x = box.right();
440    int top_y = box.top();
441    int bottom_y = box.bottom();
442    int height = box.height();
443    bool debug = WithinTestRegion(3, left_x, top_y);
444    if (debug) {
445      tprintf("Column edges for blob at (%d,%d)->(%d,%d) are [%d, %d]\n", left_x, top_y, right_x,
446              bottom_y, left_column_edge, right_column_edge);
447    }
448    int radius = (height * kTabRadiusFactor + gridsize_ - 1) / gridsize_;
449    radsearch.StartRadSearch((left_x + right_x) / 2, (top_y + bottom_y) / 2, radius);
450    int min_spacing = static_cast<int>(height * tabfind_aligned_gap_fraction);
451    if (min_gutter_width > min_spacing) {
452      min_spacing = min_gutter_width;
453    }
454    int min_ragged_gutter = kRaggedGutterMultiple * gridsize();
455    if (min_gutter_width > min_ragged_gutter) {
456      min_ragged_gutter = min_gutter_width;
457    }
458    int target_right = left_x - min_spacing;
459    int target_left = right_x + min_spacing;
460    bool is_left_tab = true;
461    bool is_right_tab = true;
462    bool maybe_ragged_left = true;
463    bool maybe_ragged_right = true;
464    int maybe_left_tab_up = 0;
465    int maybe_right_tab_up = 0;
466    int maybe_left_tab_down = 0;
467    int maybe_right_tab_down = 0;
468    if (bbox->leader_on_left()) {
469      is_left_tab = false;
470      maybe_ragged_left = false;
471      maybe_left_tab_up = -INT32_MAX;
472      maybe_left_tab_down = -INT32_MAX;
473    }
474    if (bbox->leader_on_right()) {
475      is_right_tab = false;
476      maybe_ragged_right = false;
477      maybe_right_tab_up = -INT32_MAX;
478      maybe_right_tab_down = -INT32_MAX;
479    }
480    int alignment_tolerance = static_cast<int>(resolution_ * kAlignedFraction);
481    BLOBNBOX *neighbour = nullptr;
482    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
483      if (neighbour == bbox) {
484        continue;
485      }
486      TBOX nbox = neighbour->bounding_box();
487      int n_left = nbox.left();
488      int n_right = nbox.right();
489      if (debug) {
490        tprintf("Neighbour at (%d,%d)->(%d,%d)\n", n_left, nbox.bottom(), n_right, nbox.top());
491      }
492      if (n_right > right_column_edge || n_left < left_column_edge ||
493          left_x < neighbour->left_rule() || right_x > neighbour->right_rule()) {
494        continue; 
495      }
496      int n_mid_x = (n_left + n_right) / 2;
497      int n_mid_y = (nbox.top() + nbox.bottom()) / 2;
498      if (n_mid_x <= left_x && n_right >= target_right) {
499        if (debug) {
500          tprintf("Not a left tab\n");
501        }
502        is_left_tab = false;
503        if (n_mid_y < top_y) {
504          maybe_left_tab_down = -INT32_MAX;
505        }
506        if (n_mid_y > bottom_y) {
507          maybe_left_tab_up = -INT32_MAX;
508        }
509      } else if (NearlyEqual(left_x, n_left, alignment_tolerance)) {
510        if (debug) {
511          tprintf("Maybe a left tab\n");
512        }
513        if (n_mid_y > top_y && maybe_left_tab_up > -INT32_MAX) {
514          ++maybe_left_tab_up;
515        }
516        if (n_mid_y < bottom_y && maybe_left_tab_down > -INT32_MAX) {
517          ++maybe_left_tab_down;
518        }
519      } else if (n_left < left_x && n_right >= left_x) {
520        if (debug) {
521          tprintf("Maybe Not a left tab\n");
522        }
523        if (n_mid_y > top_y && maybe_left_tab_up > -INT32_MAX) {
524          --maybe_left_tab_up;
525        }
526        if (n_mid_y < bottom_y && maybe_left_tab_down > -INT32_MAX) {
527          --maybe_left_tab_down;
528        }
529      }
530      if (n_left < left_x && nbox.y_overlap(box) && n_right >= target_right) {
531        maybe_ragged_left = false;
532        if (debug) {
533          tprintf("Not a ragged left\n");
534        }
535      }
536      if (n_mid_x >= right_x && n_left <= target_left) {
537        if (debug) {
538          tprintf("Not a right tab\n");
539        }
540        is_right_tab = false;
541        if (n_mid_y < top_y) {
542          maybe_right_tab_down = -INT32_MAX;
543        }
544        if (n_mid_y > bottom_y) {
545          maybe_right_tab_up = -INT32_MAX;
546        }
547      } else if (NearlyEqual(right_x, n_right, alignment_tolerance)) {
548        if (debug) {
549          tprintf("Maybe a right tab\n");
550        }
551        if (n_mid_y > top_y && maybe_right_tab_up > -INT32_MAX) {
552          ++maybe_right_tab_up;
553        }
554        if (n_mid_y < bottom_y && maybe_right_tab_down > -INT32_MAX) {
555          ++maybe_right_tab_down;
556        }
557      } else if (n_right > right_x && n_left <= right_x) {
558        if (debug) {
559          tprintf("Maybe Not a right tab\n");
560        }
561        if (n_mid_y > top_y && maybe_right_tab_up > -INT32_MAX) {
562          --maybe_right_tab_up;
563        }
564        if (n_mid_y < bottom_y && maybe_right_tab_down > -INT32_MAX) {
565          --maybe_right_tab_down;
566        }
567      }
568      if (n_right > right_x && nbox.y_overlap(box) && n_left <= target_left) {
569        maybe_ragged_right = false;
570        if (debug) {
571          tprintf("Not a ragged right\n");
572        }
573      }
574      if (maybe_left_tab_down == -INT32_MAX && maybe_left_tab_up == -INT32_MAX &&
575          maybe_right_tab_down == -INT32_MAX && maybe_right_tab_up == -INT32_MAX) {
576        break;
577      }
578    }
579    if (is_left_tab || maybe_left_tab_up > 1 || maybe_left_tab_down > 1) {
580      bbox->set_left_tab_type(TT_MAYBE_ALIGNED);
581    } else if (maybe_ragged_left && ConfirmRaggedLeft(bbox, min_ragged_gutter)) {
582      bbox->set_left_tab_type(TT_MAYBE_RAGGED);
583    } else {
584      bbox->set_left_tab_type(TT_NONE);
585    }
586    if (is_right_tab || maybe_right_tab_up > 1 || maybe_right_tab_down > 1) {
587      bbox->set_right_tab_type(TT_MAYBE_ALIGNED);
588    } else if (maybe_ragged_right && ConfirmRaggedRight(bbox, min_ragged_gutter)) {
589      bbox->set_right_tab_type(TT_MAYBE_RAGGED);
590    } else {
591      bbox->set_right_tab_type(TT_NONE);
592    }
593    if (debug) {
594      tprintf("Left result = %s, Right result=%s\n",
595              bbox->left_tab_type() == TT_MAYBE_ALIGNED
596                  ? "Aligned"
597                  : (bbox->left_tab_type() == TT_MAYBE_RAGGED ? "Ragged" : "None"),
598              bbox->right_tab_type() == TT_MAYBE_ALIGNED
599                  ? "Aligned"
600                  : (bbox->right_tab_type() == TT_MAYBE_RAGGED ? "Ragged" : "None"));
601    }
602    return bbox->left_tab_type() != TT_NONE || bbox->right_tab_type() != TT_NONE;
603  }
604  bool TabFind::ConfirmRaggedLeft(BLOBNBOX *bbox, int min_gutter) {
605    TBOX search_box(bbox->bounding_box());
606    search_box.set_right(search_box.left());
607    search_box.set_left(search_box.left() - min_gutter);
608    return NothingYOverlapsInBox(search_box, bbox->bounding_box());
609  }
610  bool TabFind::ConfirmRaggedRight(BLOBNBOX *bbox, int min_gutter) {
611    TBOX search_box(bbox->bounding_box());
612    search_box.set_left(search_box.right());
613    search_box.set_right(search_box.right() + min_gutter);
614    return NothingYOverlapsInBox(search_box, bbox->bounding_box());
615  }
616  bool TabFind::NothingYOverlapsInBox(const TBOX &search_box, const TBOX &target_box) {
617    BlobGridSearch rsearch(this);
618    rsearch.StartRectSearch(search_box);
619    BLOBNBOX *blob;
620    while ((blob = rsearch.NextRectSearch()) != nullptr) {
621      const TBOX &box = blob->bounding_box();
622      if (box.y_overlap(target_box) && !(box == target_box)) {
623        return false;
624      }
625    }
626    return true;
627  }
628  void TabFind::FindAllTabVectors(int min_gutter_width) {
629    TabVector_LIST dummy_vectors;
630    int vertical_x = 0;
631    int vertical_y = 1;
632    for (int search_size = kMinVerticalSearch; search_size < kMaxVerticalSearch;
633         search_size += kMinVerticalSearch) {
634      int vector_count = FindTabVectors(search_size, TA_LEFT_ALIGNED, min_gutter_width,
635                                        &dummy_vectors, &vertical_x, &vertical_y);
636      vector_count += FindTabVectors(search_size, TA_RIGHT_ALIGNED, min_gutter_width, &dummy_vectors,
637                                     &vertical_x, &vertical_y);
638      if (vector_count > 0) {
639        break;
640      }
641    }
642    dummy_vectors.clear();
643    for (auto bbox : left_tab_boxes_) {
644      if (bbox->left_tab_type() == TT_CONFIRMED) {
645        bbox->set_left_tab_type(TT_MAYBE_ALIGNED);
646      }
647    }
648    for (auto bbox : right_tab_boxes_) {
649      if (bbox->right_tab_type() == TT_CONFIRMED) {
650        bbox->set_right_tab_type(TT_MAYBE_ALIGNED);
651      }
652    }
653    if (textord_debug_tabfind) {
654      tprintf("Beginning real tab search with vertical = %d,%d...\n", vertical_x, vertical_y);
655    }
656    FindTabVectors(kMaxVerticalSearch, TA_LEFT_ALIGNED, min_gutter_width, &dummy_vectors, &vertical_x,
657                   &vertical_y);
658    FindTabVectors(kMaxVerticalSearch, TA_RIGHT_ALIGNED, min_gutter_width, &dummy_vectors,
659                   &vertical_x, &vertical_y);
660    FindTabVectors(kMaxRaggedSearch, TA_LEFT_RAGGED, min_gutter_width, &dummy_vectors, &vertical_x,
661                   &vertical_y);
662    FindTabVectors(kMaxRaggedSearch, TA_RIGHT_RAGGED, min_gutter_width, &dummy_vectors, &vertical_x,
663                   &vertical_y);
664    TabVector_IT v_it(&vectors_);
665    v_it.add_list_after(&dummy_vectors);
666    SetVerticalSkewAndParallelize(vertical_x, vertical_y);
667  }
668  int TabFind::FindTabVectors(int search_size_multiple, TabAlignment alignment, int min_gutter_width,
669                              TabVector_LIST *vectors, int *vertical_x, int *vertical_y) {
670    TabVector_IT vector_it(vectors);
671    int vector_count = 0;
672    bool right = alignment == TA_RIGHT_ALIGNED || alignment == TA_RIGHT_RAGGED;
673    const std::vector<BLOBNBOX *> &boxes = right ? right_tab_boxes_ : left_tab_boxes_;
674    for (auto bbox : boxes) {
675      if ((!right && bbox->left_tab_type() == TT_MAYBE_ALIGNED) ||
676          (right && bbox->right_tab_type() == TT_MAYBE_ALIGNED)) {
677        TabVector *vector = FindTabVector(search_size_multiple, min_gutter_width, alignment, bbox,
678                                          vertical_x, vertical_y);
679        if (vector != nullptr) {
680          ++vector_count;
681          vector_it.add_to_end(vector);
682        }
683      }
684    }
685    return vector_count;
686  }
687  TabVector *TabFind::FindTabVector(int search_size_multiple, int min_gutter_width,
688                                    TabAlignment alignment, BLOBNBOX *bbox, int *vertical_x,
689                                    int *vertical_y) {
690    int height = std::max(static_cast<int>(bbox->bounding_box().height()), gridsize());
691    AlignedBlobParams align_params(*vertical_x, *vertical_y, height, search_size_multiple,
692                                   min_gutter_width, resolution_, alignment);
693    return FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
694  }
695  void TabFind::SetVerticalSkewAndParallelize(int vertical_x, int vertical_y) {
696    vertical_skew_.set_with_shrink(vertical_x, vertical_y);
697    if (textord_debug_tabfind) {
698      tprintf("Vertical skew vector=(%d,%d)\n", vertical_skew_.x(), vertical_skew_.y());
699    }
700    v_it_.set_to_list(&vectors_);
701    for (v_it_.mark_cycle_pt(); !v_it_.cycled_list(); v_it_.forward()) {
702      TabVector *v = v_it_.data();
703      v->Fit(vertical_skew_, true);
704    }
705    SortVectors();
706  }
707  void TabFind::SortVectors() {
708    vectors_.sort(TabVector::SortVectorsByKey);
709    v_it_.set_to_list(&vectors_);
710  }
711  void TabFind::EvaluateTabs() {
712    TabVector_IT rule_it(&vectors_);
713    for (rule_it.mark_cycle_pt(); !rule_it.cycled_list(); rule_it.forward()) {
714      TabVector *tab = rule_it.data();
715      if (!tab->IsSeparator()) {
716        tab->Evaluate(vertical_skew_, this);
717        if (tab->BoxCount() < kMinEvaluatedTabs) {
718          if (textord_debug_tabfind > 2) {
719            tab->Print("Too few boxes");
720          }
721          delete rule_it.extract();
722          v_it_.set_to_list(&vectors_);
723        } else if (WithinTestRegion(3, tab->startpt().x(), tab->startpt().y())) {
724          tab->Print("Evaluated tab");
725        }
726      }
727    }
728  }
729  void TabFind::ComputeColumnWidths(ScrollView *tab_win, ColPartitionGrid *part_grid) {
730  #ifndef GRAPHICS_DISABLED
731    if (tab_win != nullptr) {
732      tab_win->Pen(ScrollView::WHITE);
733    }
734  #endif 
735    int col_widths_size = (tright_.x() - bleft_.x()) / kColumnWidthFactor;
736    STATS col_widths(0, col_widths_size);
737    ApplyPartitionsToColumnWidths(part_grid, &col_widths);
738  #ifndef GRAPHICS_DISABLED
739    if (tab_win != nullptr) {
740      tab_win->Update();
741    }
742  #endif 
743    if (textord_debug_tabfind > 1) {
744      col_widths.print();
745    }
746    MakeColumnWidths(col_widths_size, &col_widths);
747    ApplyPartitionsToColumnWidths(part_grid, nullptr);
748  }
749  void TabFind::ApplyPartitionsToColumnWidths(ColPartitionGrid *part_grid, STATS *col_widths) {
750    ColPartitionGridSearch gsearch(part_grid);
751    gsearch.StartFullSearch();
752    ColPartition *part;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      BLOBNBOX_C_IT blob_it(part->boxes());
755      if (blob_it.empty()) {
756        continue;
757      }
758      BLOBNBOX *left_blob = blob_it.data();
759      blob_it.move_to_last();
760      BLOBNBOX *right_blob = blob_it.data();
761      TabVector *left_vector = LeftTabForBox(left_blob->bounding_box(), true, false);
762      if (left_vector == nullptr || left_vector->IsRightTab()) {
763        continue;
764      }
765      TabVector *right_vector = RightTabForBox(right_blob->bounding_box(), true, false);
766      if (right_vector == nullptr || right_vector->IsLeftTab()) {
767        continue;
768      }
769      int line_left = left_vector->XAtY(left_blob->bounding_box().bottom());
770      int line_right = right_vector->XAtY(right_blob->bounding_box().bottom());
771      int width = line_right - line_left;
772      if (col_widths != nullptr) {
773        AddPartnerVector(left_blob, right_blob, left_vector, right_vector);
774        if (width >= kMinColumnWidth) {
775          col_widths->add(width / kColumnWidthFactor, 1);
776        }
777      } else {
778        width /= kColumnWidthFactor;
779        ICOORDELT_IT it(&column_widths_);
780        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
781          ICOORDELT *w = it.data();
782          if (NearlyEqual<int>(width, w->y(), 1)) {
783            int true_width = part->bounding_box().width() / kColumnWidthFactor;
784            if (true_width <= w->y() && true_width > w->x()) {
785              w->set_x(true_width);
786            }
787            break;
788          }
789        }
790      }
791    }
792  }
793  void TabFind::MakeColumnWidths(int col_widths_size, STATS *col_widths) {
794    ICOORDELT_IT w_it(&column_widths_);
795    int total_col_count = col_widths->get_total();
796    while (col_widths->get_total() > 0) {
797      int width = col_widths->mode();
798      int col_count = col_widths->pile_count(width);
799      col_widths->add(width, -col_count);
800      for (int left = width - 1; left > 0 && col_widths->pile_count(left) > 0; --left) {
801        int new_count = col_widths->pile_count(left);
802        col_count += new_count;
803        col_widths->add(left, -new_count);
804      }
805      for (int right = width + 1; right < col_widths_size && col_widths->pile_count(right) > 0;
806           ++right) {
807        int new_count = col_widths->pile_count(right);
808        col_count += new_count;
809        col_widths->add(right, -new_count);
810      }
811      if (col_count > kMinLinesInColumn &&
812          col_count > kMinFractionalLinesInColumn * total_col_count) {
813        auto *w = new ICOORDELT(0, width);
814        w_it.add_after_then_move(w);
815        if (textord_debug_tabfind) {
816          tprintf("Column of width %d has %d = %.2f%% lines\n", width * kColumnWidthFactor, col_count,
817                  100.0 * col_count / total_col_count);
818        }
819      }
820    }
821  }
822  void TabFind::MarkVerticalText() {
823    if (textord_debug_tabfind) {
824      tprintf("Checking for vertical lines\n");
825    }
826    BlobGridSearch gsearch(this);
827    gsearch.StartFullSearch();
828    BLOBNBOX *blob = nullptr;
829    while ((blob = gsearch.NextFullSearch()) != nullptr) {
830      if (blob->region_type() < BRT_UNKNOWN) {
831        continue;
832      }
833      if (blob->UniquelyVertical()) {
834        blob->set_region_type(BRT_VERT_TEXT);
835      }
836    }
837  }
838  int TabFind::FindMedianGutterWidth(TabVector_LIST *lines) {
839    TabVector_IT it(lines);
840    int prev_right = -1;
841    int max_gap = static_cast<int>(kMaxGutterWidthAbsolute * resolution_);
842    STATS gaps(0, max_gap - 1);
843    STATS heights(0, max_gap - 1);
844    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
845      TabVector *v = it.data();
846      TabVector *partner = v->GetSinglePartner();
847      if (!v->IsLeftTab() || v->IsSeparator() || !partner) {
848        continue;
849      }
850      heights.add(partner->startpt().x() - v->startpt().x(), 1);
851      if (prev_right > 0 && v->startpt().x() > prev_right) {
852        gaps.add(v->startpt().x() - prev_right, 1);
853      }
854      prev_right = partner->startpt().x();
855    }
856    if (textord_debug_tabfind) {
857      tprintf("TabGutter total %d  median_gap %.2f  median_hgt %.2f\n", gaps.get_total(),
858              gaps.median(), heights.median());
859    }
860    if (gaps.get_total() < kMinLinesInColumn) {
861      return 0;
862    }
863    return static_cast<int>(gaps.median());
864  }
865  BLOBNBOX *TabFind::AdjacentBlob(const BLOBNBOX *bbox, bool look_left, bool ignore_images,
866                                  double min_overlap_fraction, int gap_limit, int top_y,
867                                  int bottom_y) {
868    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> sidesearch(this);
869    const TBOX &box = bbox->bounding_box();
870    int left = box.left();
871    int right = box.right();
872    int mid_x = (left + right) / 2;
873    sidesearch.StartSideSearch(mid_x, bottom_y, top_y);
874    int best_gap = 0;
875    bool debug = WithinTestRegion(3, left, bottom_y);
876    BLOBNBOX *result = nullptr;
877    BLOBNBOX *neighbour = nullptr;
878    while ((neighbour = sidesearch.NextSideSearch(look_left)) != nullptr) {
879      if (debug) {
880        tprintf("Adjacent blob: considering box:");
881        neighbour->bounding_box().print();
882      }
883      if (neighbour == bbox || (ignore_images && neighbour->region_type() < BRT_UNKNOWN)) {
884        continue;
885      }
886      const TBOX &nbox = neighbour->bounding_box();
887      int n_top_y = nbox.top();
888      int n_bottom_y = nbox.bottom();
889      int v_overlap = std::min(n_top_y, top_y) - std::max(n_bottom_y, bottom_y);
890      int height = top_y - bottom_y;
891      int n_height = n_top_y - n_bottom_y;
892      if (v_overlap > min_overlap_fraction * std::min(height, n_height) &&
893          (min_overlap_fraction == 0.0 || !DifferentSizes(height, n_height))) {
894        int n_left = nbox.left();
895        int n_right = nbox.right();
896        int h_gap = std::max(n_left, left) - std::min(n_right, right);
897        int n_mid_x = (n_left + n_right) / 2;
898        if (look_left == (n_mid_x < mid_x) && n_mid_x != mid_x) {
899          if (h_gap > gap_limit) {
900            if (debug) {
901              tprintf("Giving up due to big gap = %d vs %d\n", h_gap, gap_limit);
902            }
903            return result;
904          }
905          if (h_gap > 0 && (look_left ? neighbour->right_tab_type() : neighbour->left_tab_type()) >=
906                               TT_CONFIRMED) {
907            if (debug) {
908              tprintf("Collision with like tab of type %d at %d,%d\n",
909                      look_left ? neighbour->right_tab_type() : neighbour->left_tab_type(), n_left,
910                      nbox.bottom());
911            }
912            return result;
913          }
914          if (result == nullptr || h_gap < best_gap) {
915            if (debug) {
916              tprintf("Good result\n");
917            }
918            result = neighbour;
919            best_gap = h_gap;
920          } else {
921            return result;
922          }
923        } else if (debug) {
924          tprintf("Wrong way\n");
925        }
926      } else if (debug) {
927        tprintf("Insufficient overlap\n");
928      }
929    }
930    if (WithinTestRegion(3, left, box.top())) {
931      tprintf("Giving up due to end of search\n");
932    }
933    return result; 
934  }
935  void TabFind::AddPartnerVector(BLOBNBOX *left_blob, BLOBNBOX *right_blob, TabVector *left,
936                                 TabVector *right) {
937    const TBOX &left_box = left_blob->bounding_box();
938    const TBOX &right_box = right_blob->bounding_box();
939    if (left->IsSeparator()) {
940      TabVector *v = LeftTabForBox(left_box, true, true);
941      if (v != nullptr && v != left && v->IsLeftTab() &&
942          v->XAtY(left_box.top()) > left->XAtY(left_box.top())) {
943        left = v; 
944        left->ExtendToBox(left_blob);
945      } else {
946        left = new TabVector(*left, TA_LEFT_RAGGED, vertical_skew_, left_blob);
947        vectors_.add_sorted(TabVector::SortVectorsByKey, left);
948        v_it_.move_to_first();
949      }
950    }
951    if (right->IsSeparator()) {
952      if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
953        tprintf("Box edge (%d,%d-%d)", right_box.right(), right_box.bottom(), right_box.top());
954        right->Print(" looking for improvement for");
955      }
956      TabVector *v = RightTabForBox(right_box, true, true);
957      if (v != nullptr && v != right && v->IsRightTab() &&
958          v->XAtY(right_box.top()) < right->XAtY(right_box.top())) {
959        right = v; 
960        right->ExtendToBox(right_blob);
961        if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
962          right->Print("Extended vector");
963        }
964      } else {
965        right = new TabVector(*right, TA_RIGHT_RAGGED, vertical_skew_, right_blob);
966        vectors_.add_sorted(TabVector::SortVectorsByKey, right);
967        v_it_.move_to_first();
968        if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
969          right->Print("Created new vector");
970        }
971      }
972    }
973    left->AddPartner(right);
974    right->AddPartner(left);
975  }
976  void TabFind::CleanupTabs() {
977    TabVector_IT it(&vectors_);
978    TabVector_IT dead_it(&dead_vectors_);
979    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
980      TabVector *v = it.data();
981      if (v->IsSeparator() || v->Partnerless()) {
982        dead_it.add_after_then_move(it.extract());
983        v_it_.set_to_list(&vectors_);
984      } else {
985        v->FitAndEvaluateIfNeeded(vertical_skew_, this);
986      }
987    }
988  }
989  void TabFind::RotateBlobList(const FCOORD &rotation, BLOBNBOX_LIST *blobs) {
990    BLOBNBOX_IT it(blobs);
991    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
992      it.data()->rotate_box(rotation);
993    }
994  }
995  bool TabFind::Deskew(TabVector_LIST *hlines, BLOBNBOX_LIST *image_blobs, TO_BLOCK *block,
996                       FCOORD *deskew, FCOORD *reskew) {
997    ComputeDeskewVectors(deskew, reskew);
998    if (deskew->x() < kCosMaxSkewAngle) {
999      return false;
1000    }
1001    RotateBlobList(*deskew, image_blobs);
1002    RotateBlobList(*deskew, &block->blobs);
1003    RotateBlobList(*deskew, &block->small_blobs);
1004    RotateBlobList(*deskew, &block->noise_blobs);
1005    TabVector_IT h_it(hlines);
1006    for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
1007      TabVector *h = h_it.data();
1008      h->Rotate(*deskew);
1009    }
1010    TabVector_IT d_it(&dead_vectors_);
1011    for (d_it.mark_cycle_pt(); !d_it.cycled_list(); d_it.forward()) {
1012      TabVector *d = d_it.data();
1013      d->Rotate(*deskew);
1014    }
1015    SetVerticalSkewAndParallelize(0, 1);
1016    TBOX grid_box(bleft_, tright_);
1017    grid_box.rotate_large(*deskew);
1018    Init(gridsize(), grid_box.botleft(), grid_box.topright());
1019    InsertBlobsToGrid(false, false, image_blobs, this);
1020    InsertBlobsToGrid(true, false, &block->blobs, this);
1021    return true;
1022  }
1023  void TabFind::ResetForVerticalText(const FCOORD &rotate, const FCOORD &rerotate,
1024                                     TabVector_LIST *horizontal_lines, int *min_gutter_width) {
1025    TabVector_LIST ex_verticals;
1026    TabVector_IT ex_v_it(&ex_verticals);
1027    TabVector_LIST vlines;
1028    TabVector_IT v_it(&vlines);
1029    while (!v_it_.empty()) {
1030      TabVector *v = v_it_.extract();
1031      if (v->IsSeparator()) {
1032        v->Rotate(rotate);
1033        ex_v_it.add_after_then_move(v);
1034      } else {
1035        v_it.add_after_then_move(v);
1036      }
1037      v_it_.forward();
1038    }
1039    int median_gutter = FindMedianGutterWidth(&vlines);
1040    if (median_gutter > *min_gutter_width) {
1041      *min_gutter_width = median_gutter;
1042    }
1043    TabVector_IT h_it(horizontal_lines);
1044    for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
1045      TabVector *h = h_it.data();
1046      h->Rotate(rotate);
1047    }
1048    v_it_.add_list_after(horizontal_lines);
1049    v_it_.move_to_first();
1050    h_it.set_to_list(horizontal_lines);
1051    h_it.add_list_after(&ex_verticals);
1052    TBOX grid_box(bleft(), tright());
1053    grid_box.rotate_large(rotate);
1054    Init(gridsize(), grid_box.botleft(), grid_box.topright());
1055  }
1056  void TabFind::Reset() {
1057    v_it_.move_to_first();
1058    for (v_it_.mark_cycle_pt(); !v_it_.cycled_list(); v_it_.forward()) {
1059      if (!v_it_.data()->IsSeparator()) {
1060        delete v_it_.extract();
1061      }
1062    }
1063    Clear();
1064  }
1065  void TabFind::ReflectInYAxis() {
1066    TabVector_LIST temp_list;
1067    TabVector_IT temp_it(&temp_list);
1068    v_it_.move_to_first();
1069    while (!v_it_.empty()) {
1070      TabVector *v = v_it_.extract();
1071      v_it_.forward();
1072      v->ReflectInYAxis();
1073      temp_it.add_before_then_move(v);
1074    }
1075    v_it_.add_list_after(&temp_list);
1076    v_it_.move_to_first();
1077    TBOX grid_box(bleft(), tright());
1078    int tmp = grid_box.left();
1079    grid_box.set_left(-grid_box.right());
1080    grid_box.set_right(-tmp);
1081    Init(gridsize(), grid_box.botleft(), grid_box.topright());
1082  }
1083  void TabFind::ComputeDeskewVectors(FCOORD *deskew, FCOORD *reskew) {
1084    double length = vertical_skew_ % vertical_skew_;
1085    length = sqrt(length);
1086    deskew->set_x(static_cast<float>(vertical_skew_.y() / length));
1087    deskew->set_y(static_cast<float>(vertical_skew_.x() / length));
1088    reskew->set_x(deskew->x());
1089    reskew->set_y(-deskew->y());
1090  }
1091  void TabFind::ApplyTabConstraints() {
1092    TabVector_IT it(&vectors_);
1093    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1094      TabVector *v = it.data();
1095      v->SetupConstraints();
1096    }
1097    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1098      TabVector *v = it.data();
1099      v->SetupPartnerConstraints();
1100    }
1101    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1102      TabVector *v = it.data();
1103      if (!v->IsRightTab()) {
1104        continue;
1105      }
1106      TabVector_IT partner_it(it);
1107      for (partner_it.forward(); !partner_it.at_first(); partner_it.forward()) {
1108        TabVector *partner = partner_it.data();
1109        if (!partner->IsLeftTab() || !v->VOverlap(*partner)) {
1110          continue;
1111        }
1112        v->SetupPartnerConstraints(partner);
1113      }
1114    }
1115    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1116      TabVector *v = it.data();
1117      if (!v->IsSeparator()) {
1118        v->ApplyConstraints();
1119      }
1120    }
1121  }
1122  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-BabyGrid.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tabfind.cpp</div>
                </div>
                <div class="column column_space"><pre><code>255  void DisplayTitle(HWND hWnd,int SI,HFONT hfont)
256      {
257       RECT rect;
258       HDC gdc;
259       HFONT holdfont;
260       GetClientRect(hWnd,&rect);
261       gdc=GetDC(hWnd);
262       SetBkMode(gdc,TRANSPARENT);
</pre></code></div>
                <div class="column column_space"><pre><code>290                               int min_gutter_width, double tabfind_aligned_gap_fraction,
291                               ColPartitionGrid *part_grid, FCOORD *deskew, FCOORD *reskew) {
292    ScrollView *tab_win =
293        FindInitialTabVectors(image_blobs, min_gutter_width, tabfind_aligned_gap_fraction, block);
294    ComputeColumnWidths(tab_win, part_grid);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    