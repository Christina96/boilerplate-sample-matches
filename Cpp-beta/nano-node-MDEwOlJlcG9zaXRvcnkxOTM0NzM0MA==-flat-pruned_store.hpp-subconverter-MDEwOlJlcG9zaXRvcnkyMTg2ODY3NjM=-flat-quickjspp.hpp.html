
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.8535645472061653%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-pruned_store.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/secure/store.hpp>
3  namespace nano
4  {
5  namespace rocksdb
6  {
7  	class store;
8  	class pruned_store : public nano::pruned_store
9  	{
10  	private:
<span onclick='openModal()' class='match'>11  		nano::rocksdb::store & store;
12  	public:
13  		explicit pruned_store (nano::rocksdb::store & store_a);
14  		void put (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a) override;
15  		void del (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a) override;
</span>16  		bool exists (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const override;
17  		nano::block_hash random (nano::transaction const & transaction_a) override;
18  		size_t count (nano::transaction const & transaction_a) const override;
19  		void clear (nano::write_transaction const & transaction_a) override;
20  		nano::store_iterator<nano::block_hash, std::nullptr_t> begin (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const override;
21  		nano::store_iterator<nano::block_hash, std::nullptr_t> begin (nano::transaction const & transaction_a) const override;
22  		nano::store_iterator<nano::block_hash, std::nullptr_t> end () const override;
23  		void for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::block_hash, std::nullptr_t>, nano::store_iterator<nano::block_hash, std::nullptr_t>)> const & action_a) const override;
24  	};
25  }
26  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-quickjspp.hpp</h3>
            <pre><code>1  #pragma once
2  #include "quickjs/quickjs.h"
3  #include "quickjs/quickjs-libc.h"
4  #include <vector>
5  #include <string_view>
6  #include <string>
7  #include <cassert>
8  #include <memory>
9  #include <cstddef>
10  #include <algorithm>
11  #include <tuple>
12  #include <functional>
13  #include <stdexcept>
14  #include <variant>
15  #include <optional>
16  #if defined(__cpp_rtti)
17  #define QJSPP_TYPENAME(...) (typeid(__VA_ARGS__).name())
18  #else
19  #define QJSPP_TYPENAME(...) #__VA_ARGS__
20  #endif
21  namespace qjs {
22  class exception {};
23  template <typename R, typename &bsol;*_SFINAE*/ = void>
24  struct js_traits
25  {
<span onclick='openModal()' class='match'>26      static R unwrap(JSContext * ctx, JSValueConst v);
27      static JSValue wrap(JSContext * ctx, R value);
</span>28  };
29  template <>
30  struct js_traits<JSValue>
31  {
32      static JSValue unwrap(JSContext * ctx, JSValueConst v) noexcept
33      {
34          return JS_DupValue(ctx, v);
35      }
36      static JSValue wrap(JSContext * ctx, JSValue v) noexcept
37      {
38          return v;
39      }
40  };
41  template <typename Int>
42  struct js_traits<Int, std::enable_if_t<std::is_integral_v<Int> && sizeof(Int) <= sizeof(int64_t)>>
43  {
44      static Int unwrap(JSContext * ctx, JSValueConst v)
45      {
46          if constexpr (sizeof(Int) > sizeof(int32_t))
47          {
48              int64_t r;
49              if(JS_ToInt64(ctx, &r, v))
50                  throw exception{};
51              return static_cast<Int>(r);
52          }
53          else
54          {
55              int32_t r;
56              if(JS_ToInt32(ctx, &r, v))
57                  throw exception{};
58              return static_cast<Int>(r);
59          }
60      }
61      static JSValue wrap(JSContext * ctx, Int i) noexcept
62      {
63          if constexpr (std::is_same_v<Int, uint32_t> || sizeof(Int) > sizeof(int32_t))
64              return JS_NewInt64(ctx, static_cast<Int>(i));
65          else
66              return JS_NewInt32(ctx, static_cast<Int>(i));
67      }
68  };
69  template <>
70  struct js_traits<bool>
71  {
72      static bool unwrap(JSContext * ctx, JSValueConst v) noexcept
73      {
74          return JS_ToBool(ctx, v) > 0;
75      }
76      static JSValue wrap(JSContext * ctx, bool i) noexcept
77      {
78          return JS_NewBool(ctx, i);
79      }
80  };
81  template <>
82  struct js_traits<void>
83  {
84      static void unwrap(JSContext * ctx, JSValueConst value)
85      {
86          if(JS_IsException(value))
87              throw exception{};
88      }
89  };
90  template <>
91  struct js_traits<double>
92  {
93      static double unwrap(JSContext * ctx, JSValueConst v)
94      {
95          double r;
96          if(JS_ToFloat64(ctx, &r, v))
97              throw exception{};
98          return r;
99      }
100      static JSValue wrap(JSContext * ctx, double i) noexcept
101      {
102          return JS_NewFloat64(ctx, i);
103      }
104  };
105  namespace detail {
106  class js_string : public std::string_view
107  {
108      using Base = std::string_view;
109      JSContext * ctx = nullptr;
110      friend struct js_traits<std::string_view>;
111      js_string(JSContext * ctx, const char * ptr, std::size_t len) : Base(ptr, len), ctx(ctx) {}
112  public:
113      template <typename... Args>
114      js_string(Args&& ... args) : Base(std::forward<Args>(args)...), ctx(nullptr) {}
115      js_string(const js_string& other) = delete;
116      operator const char *() const
117      {
118          return this->data();
119      }
120      ~js_string()
121      {
122          if(ctx)
123              JS_FreeCString(ctx, this->data());
124      }
125  };
126  } 
127  template <>
128  struct js_traits<std::string_view>
129  {
130      static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
131      {
132          size_t plen;
133          const char * ptr = JS_ToCStringLen(ctx, &plen, v);
134          if(!ptr)
135              throw exception{};
136          return detail::js_string{ctx, ptr, plen};
137      }
138      static JSValue wrap(JSContext * ctx, std::string_view str) noexcept
139      {
140          return JS_NewStringLen(ctx, str.data(), str.size());
141      }
142  };
143  template <> 
144  struct js_traits<std::string>
145  {
146      static std::string unwrap(JSContext * ctx, JSValueConst v)
147      {
148          auto str_view = js_traits<std::string_view>::unwrap(ctx, v);
149          return std::string{str_view.data(), str_view.size()};
150      }
151      static JSValue wrap(JSContext * ctx, const std::string& str) noexcept
152      {
153          return JS_NewStringLen(ctx, str.data(), str.size());
154      }
155  };
156  template <>
157  struct js_traits<const char *>
158  {
159      static JSValue wrap(JSContext * ctx, const char * str) noexcept
160      {
161          return JS_NewString(ctx, str);
162      }
163      static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
164      {
165          return js_traits<std::string_view>::unwrap(ctx, v);
166      }
167  };
168  template <typename ... Ts>
169  struct js_traits<std::variant<Ts...>>
170  {
171      static JSValue wrap(JSContext * ctx, std::variant<Ts...> value) noexcept
172      {
173          return std::visit([ctx](auto&& value) {
174              using T = std::decay_t<decltype(value)>;
175              return js_traits<T>::wrap(ctx, value);
176          }, std::move(value));
177      }
178      template <typename T> struct is_shared_ptr : std::false_type {};
179      template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};
180      template <typename T> struct is_string
181      {
182          static constexpr bool value = std::is_same_v<T, const char *> || std::is_same_v<std::decay_t<T>, std::string> ||
183                                        std::is_same_v<std::decay_t<T>, std::string_view>;
184      };
185      template <typename T> struct is_boolean { static constexpr bool value = std::is_same_v<std::decay_t<T>, bool>; };
186      template <typename T> struct is_double { static constexpr bool value = std::is_same_v<std::decay_t<T>, double>; };
187      template <typename T> struct is_vector : std::false_type {};
188      template <typename T> struct is_vector<std::vector<T>> : std::true_type {};
189      template <typename T> struct is_pair : std::false_type {};
190      template <typename U, typename V> struct is_pair<std::pair<U, V>> : std::true_type {};
191      template <typename T> struct is_variant : std::false_type {};
192      template <typename ... Us> struct is_variant<std::variant<Us...>> : std::true_type {};
193      template <template <typename R> typename Trait, typename U, typename ... Us>
194      static std::optional<std::variant<Ts...>> unwrapImpl(JSContext * ctx, JSValueConst v)
195      {
196          if constexpr (Trait<U>::value)
197          {
198              return js_traits<U>::unwrap(ctx, v);
199          }
200          if constexpr ((sizeof ... (Us)) > 0)
201          {
202              return unwrapImpl<Trait, Us...>(ctx, v);
203          }
204          return std::nullopt;
205      }
206      template <typename U, typename ... Us>
207      static std::optional<std::variant<Ts...>> unwrapObj(JSContext * ctx, JSValueConst v, JSClassID class_id)
208      {
209          if constexpr (is_shared_ptr<U>::value)
210          {
211              if(class_id == js_traits<U>::QJSClassId)
212              {
213                  return js_traits<U>::unwrap(ctx, v);
214              }
215          }
216          if constexpr (is_variant<U>::value)
217          {
218              if(auto opt = js_traits<std::optional<U>>::unwrap(ctx, v))
219                  return *opt;
220          }
221          if constexpr (is_vector<U>::value)
222          {
223              if(JS_IsArray(ctx, v) == 1)
224              {
225                  auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
226                  bool ok = isCompatible<std::decay_t<typename U::value_type>>(ctx, firstElement);
227                  JS_FreeValue(ctx, firstElement);
228                  if(ok)
229                  {
230                      return U{js_traits<U>::unwrap(ctx, v)};
231                  }
232              }
233          }
234          if constexpr (is_pair<U>::value)
235          {
236              if(JS_IsArray(ctx, v) == 1)
237              {
238                  auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
239                  auto secondElement = JS_GetPropertyUint32(ctx, v, 1);
240                  bool ok = isCompatible<std::decay_t<typename U::first_type>>(ctx, firstElement)
241                            && isCompatible<std::decay_t<typename U::second_type>>(ctx, secondElement);
242                  JS_FreeValue(ctx, firstElement);
243                  JS_FreeValue(ctx, secondElement);
244                  if(ok)
245                  {
246                      return U{js_traits<U>::unwrap(ctx, v)};
247                  }
248              }
249          }
250          if constexpr ((sizeof ... (Us)) > 0)
251          {
252              return unwrapObj<Us...>(ctx, v, class_id);
253          }
254          return std::nullopt;
255      }
256      template <template <typename T> typename Trait, template <typename T> typename ... Traits>
257      static std::variant<Ts...> unwrapPriority(JSContext * ctx, JSValueConst v)
258      {
259          if(auto result = unwrapImpl<Trait, Ts...>(ctx, v))
260          {
261              return *result;
262          }
263          if constexpr ((sizeof ... (Traits)) > 0)
264          {
265              return unwrapPriority<Traits...>(ctx, v);
266          }
267          JS_ThrowTypeError(ctx, "Expected type %s", QJSPP_TYPENAME(std::variant<Ts...>));
268          throw exception{};
269      }
270      template <typename T>
271      static bool isCompatible(JSContext * ctx, JSValueConst v) noexcept
272      {
273          switch(JS_VALUE_GET_TAG(v))
274          {
275              case JS_TAG_STRING:
276                  return is_string<T>::value;
277              case JS_TAG_FUNCTION_BYTECODE:
278                  return std::is_function<T>::value;
279              case JS_TAG_OBJECT:
280                  if(JS_IsArray(ctx, v) == 1)
281                      return is_vector<T>::value || is_pair<T>::value;
282                  if constexpr (is_shared_ptr<T>::value)
283                  {
284                      if(JS_GetClassID(v) == js_traits<T>::QJSClassId)
285                          return true;
286                  }
287                  return false;
288              case JS_TAG_INT:
289                  [[fallthrough]];
290              case JS_TAG_BIG_INT:
291                  return std::is_integral_v<T> || std::is_floating_point_v<T>;
292              case JS_TAG_BOOL:
293                  return is_boolean<T>::value || std::is_integral_v<T> || std::is_floating_point_v<T>;
294              case JS_TAG_BIG_DECIMAL:
295                  [[fallthrough]];
296              case JS_TAG_BIG_FLOAT:
297                  [[fallthrough]];
298              case JS_TAG_FLOAT64:
299              default: 
300                  return is_double<T>::value || std::is_floating_point_v<T>;
301              case JS_TAG_SYMBOL:
302                  [[fallthrough]];
303              case JS_TAG_MODULE:
304                  [[fallthrough]];
305              case JS_TAG_NULL:
306                  [[fallthrough]];
307              case JS_TAG_UNDEFINED:
308                  [[fallthrough]];
309              case JS_TAG_UNINITIALIZED:
310                  [[fallthrough]];
311              case JS_TAG_CATCH_OFFSET:
312                  [[fallthrough]];
313              case JS_TAG_EXCEPTION:
314                  break;
315          }
316          return false;
317      }
318      static std::variant<Ts...> unwrap(JSContext * ctx, JSValueConst v)
319      {
320          const auto tag = JS_VALUE_GET_TAG(v);
321          switch(tag)
322          {
323              case JS_TAG_STRING:
324                  return unwrapPriority<is_string>(ctx, v);
325              case JS_TAG_FUNCTION_BYTECODE:
326                  return unwrapPriority<std::is_function>(ctx, v);
327              case JS_TAG_OBJECT:
328                  if(auto result = unwrapObj<Ts...>(ctx, v, JS_GetClassID(v)))
329                  {
330                      return *result;
331                  }
332                  JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
333                                    QJSPP_TYPENAME(std::variant<Ts...>), JS_GetClassID(v));
334                  break;
335              case JS_TAG_INT:
336                  [[fallthrough]];
337              case JS_TAG_BIG_INT:
338                  return unwrapPriority<std::is_integral, std::is_floating_point>(ctx, v);
339              case JS_TAG_BOOL:
340                  return unwrapPriority<is_boolean, std::is_integral, std::is_floating_point>(ctx, v);
341              case JS_TAG_SYMBOL:
342                  [[fallthrough]];
343              case JS_TAG_MODULE:
344                  [[fallthrough]];
345              case JS_TAG_NULL:
346                  [[fallthrough]];
347              case JS_TAG_UNDEFINED:
348                  [[fallthrough]];
349              case JS_TAG_UNINITIALIZED:
350                  [[fallthrough]];
351              case JS_TAG_CATCH_OFFSET:
352                  JS_ThrowTypeError(ctx, "Expected type %s, got tag %d", QJSPP_TYPENAME(std::variant<Ts...>), tag);
353                  [[fallthrough]];
354              case JS_TAG_EXCEPTION:
355                  break;
356              case JS_TAG_BIG_DECIMAL:
357                  [[fallthrough]];
358              case JS_TAG_BIG_FLOAT:
359                  [[fallthrough]];
360              case JS_TAG_FLOAT64:
361                  [[fallthrough]];
362              default: 
363                  return unwrapPriority<is_double, std::is_floating_point>(ctx, v);
364          }
365          throw exception{};
366      }
367  };
368  namespace detail {
369  template <typename T>
370  T unwrap_free(JSContext * ctx, JSValue val)
371  {
372      if constexpr(std::is_same_v<T, void>)
373      {
374          JS_FreeValue(ctx, val);
375          return js_traits<T>::unwrap(ctx, val);
376      }
377      else
378      {
379          try
380          {
381              T result = js_traits<std::decay_t<T>>::unwrap(ctx, val);
382              JS_FreeValue(ctx, val);
383              return result;
384          }
385          catch(...)
386          {
387              JS_FreeValue(ctx, val);
388              throw;
389          }
390      }
391  }
392  template <class Tuple, std::size_t... I>
393  Tuple unwrap_args_impl(JSContext * ctx, JSValueConst * argv, std::index_sequence<I...>)
394  {
395      return Tuple{js_traits<std::decay_t<std::tuple_element_t<I, Tuple>>>::unwrap(ctx, argv[I])...};
396  }
397  template <typename... Args>
398  std::tuple<std::decay_t<Args>...> unwrap_args(JSContext * ctx, JSValueConst * argv)
399  {
400      return unwrap_args_impl<std::tuple<std::decay_t<Args>...>>(ctx, argv, std::make_index_sequence<sizeof...(Args)>());
401  }
402  template <typename R, typename... Args, typename Callable>
403  JSValue wrap_call(JSContext * ctx, Callable&& f, JSValueConst * argv) noexcept
404  {
405      try
406      {
407          if constexpr(std::is_same_v<R, void>)
408          {
409              std::apply(std::forward<Callable>(f), unwrap_args<Args...>(ctx, argv));
410              return JS_NULL;
411          }
412          else
413          {
414              return js_traits<std::decay_t<R>>::wrap(ctx,
415                                                      std::apply(std::forward<Callable>(f),
416                                                                 unwrap_args<Args...>(ctx, argv)));
417          }
418      }
419      catch(exception)
420      {
421          return JS_EXCEPTION;
422      }
423  }
424  template <typename R, typename FirstArg, typename... Args, typename Callable>
425  JSValue wrap_this_call(JSContext * ctx, Callable&& f, JSValueConst this_value, JSValueConst * argv) noexcept
426  {
427      try
428      {
429          if constexpr(std::is_same_v<R, void>)
430          {
431              std::apply(std::forward<Callable>(f), std::tuple_cat(unwrap_args<FirstArg>(ctx, &this_value),
432                                                                   unwrap_args<Args...>(ctx, argv)));
433              return JS_NULL;
434          }
435          else
436          {
437              return js_traits<std::decay_t<R>>::wrap(ctx,
438                                                      std::apply(std::forward<Callable>(f),
439                                                                 std::tuple_cat(
440                                                                         unwrap_args<FirstArg>(ctx, &this_value),
441                                                                         unwrap_args<Args...>(ctx, argv))));
442          }
443      }
444      catch(exception)
445      {
446          return JS_EXCEPTION;
447      }
448  }
449  template <class Tuple, std::size_t... I>
450  void wrap_args_impl(JSContext * ctx, JSValue * argv, Tuple tuple, std::index_sequence<I...>)
451  {
452      ((argv[I] = js_traits<std::decay_t<std::tuple_element_t<I, Tuple>>>::wrap(ctx, std::get<I>(tuple))), ...);
453  }
454  template <typename... Args>
455  void wrap_args(JSContext * ctx, JSValue * argv, Args&& ... args)
456  {
457      wrap_args_impl(ctx, argv, std::make_tuple(std::forward<Args>(args)...),
458                     std::make_index_sequence<sizeof...(Args)>());
459  }
460  } 
461  template <auto F, bool PassThis = false &bsol;* pass this as the first argument */>
462  struct fwrapper
463  {
464      const char * name = nullptr;
465  };
466  template <typename R, typename... Args, R (* F)(Args...), bool PassThis>
467  struct js_traits<fwrapper<F, PassThis>>
468  {
469      static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
470      {
471          return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
472                                         JSValueConst * argv) noexcept -> JSValue {
473              if constexpr(PassThis)
474                  return detail::wrap_this_call<R, Args...>(ctx, F, this_value, argv);
475              else
476                  return detail::wrap_call<R, Args...>(ctx, F, argv);
477          }, fw.name, sizeof...(Args));
478      }
479  };
480  template <typename R, class T, typename... Args, R (T::*F)(Args...), bool PassThis&bsol;*=ignored*/>
481  struct js_traits<fwrapper<F, PassThis>>
482  {
483      static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
484      {
485          return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
486                                         JSValueConst * argv) noexcept -> JSValue {
487              return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argv);
488          }, fw.name, sizeof...(Args));
489      }
490  };
491  template <typename R, class T, typename... Args, R (T::*F)(Args...) const, bool PassThis&bsol;*=ignored*/>
492  struct js_traits<fwrapper<F, PassThis>>
493  {
494      static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
495      {
496          return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
497                                         JSValueConst * argv) noexcept -> JSValue {
498              return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argv);
499          }, fw.name, sizeof...(Args));
500      }
501  };
502  template <class T, typename... Args>
503  struct ctor_wrapper
504  {
505      static_assert(std::is_constructible<T, Args...>::value, "no such constructor!");
506      const char * name = nullptr;
507  };
508  template <class T, typename... Args>
509  struct js_traits<ctor_wrapper<T, Args...>>
510  {
511      static JSValue wrap(JSContext * ctx, ctor_wrapper<T, Args...> cw) noexcept
512      {
513          return JS_NewCFunction2(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
514                                          JSValueConst * argv) noexcept -> JSValue {
515              if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) 
516              {
517  #if defined(__cpp_rtti)
518                  js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
519  #else
520                  JS_ThrowTypeError(ctx, "quickjspp ctor_wrapper<T>::wrap: Class is not registered");
521                  return JS_EXCEPTION;
522  #endif
523              }
524              auto proto = JS_GetPropertyStr(ctx, this_value, "prototype");
525              if(JS_IsException(proto))
526                  return proto;
527              auto jsobj = JS_NewObjectProtoClass(ctx, proto, js_traits<std::shared_ptr<T>>::QJSClassId);
528              JS_FreeValue(ctx, proto);
529              if(JS_IsException(jsobj))
530                  return jsobj;
531              std::shared_ptr<T> ptr = std::apply(std::make_shared<T, Args...>, detail::unwrap_args<Args...>(ctx, argv));
532              JS_SetOpaque(jsobj, new std::shared_ptr<T>(std::move(ptr)));
533              return jsobj;
534          }, cw.name, sizeof...(Args), JS_CFUNC_constructor, 0);
535      }
536  };
537  template <class T>
538  struct js_traits<std::shared_ptr<T>>
539  {
540      inline static JSClassID QJSClassId = 0;
541      static void register_class(JSContext * ctx, const char * name, JSValue proto = JS_NULL)
542      {
543          if(QJSClassId == 0)
544          {
545              JS_NewClassID(&QJSClassId);
546          }
547          auto rt = JS_GetRuntime(ctx);
548          if(!JS_IsRegisteredClass(rt, QJSClassId))
549          {
550              JSClassDef def{
551                      name,
552                      [](JSRuntime * rt, JSValue obj) noexcept {
553                          auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(obj, QJSClassId));
554                          delete pptr;
555                      },
556                      nullptr,
557                      nullptr,
558                      nullptr
559              };
560              int e = JS_NewClass(rt, QJSClassId, &def);
561              if(e < 0)
562              {
563                  JS_ThrowInternalError(ctx, "Cant register class %s", name);
564                  throw exception{};
565              }
566          }
567          JS_SetClassProto(ctx, QJSClassId, proto);
568      }
569      static JSValue wrap(JSContext * ctx, std::shared_ptr<T> ptr)
570      {
571          if(QJSClassId == 0) 
572          {
573  #if defined(__cpp_rtti)
574              register_class(ctx, typeid(T).name());
575  #else
576              JS_ThrowTypeError(ctx, "quickjspp std::shared_ptr<T>::wrap: Class is not registered");
577              return JS_EXCEPTION;
578  #endif
579          }
580          auto jsobj = JS_NewObjectClass(ctx, QJSClassId);
581          if(JS_IsException(jsobj))
582              return jsobj;
583          auto pptr = new std::shared_ptr<T>(std::move(ptr));
584          JS_SetOpaque(jsobj, pptr);
585          return jsobj;
586      }
587      static const std::shared_ptr<T>& unwrap(JSContext * ctx, JSValueConst v)
588      {
589          auto ptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque2(ctx, v, QJSClassId));
590          if(!ptr)
591              throw exception{};
592          return *ptr;
593      }
594  };
595  template <class T>
596  struct js_traits<T *, std::enable_if_t<std::is_class_v<T>>>
597  {
598      static JSValue wrap(JSContext * ctx, T * ptr)
599      {
600          if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) 
601          {
602  #if defined(__cpp_rtti)
603              js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
604  #else
605              JS_ThrowTypeError(ctx, "quickjspp js_traits<T *>::wrap: Class is not registered");
606              return JS_EXCEPTION;
607  #endif
608          }
609          auto jsobj = JS_NewObjectClass(ctx, js_traits<std::shared_ptr<T>>::QJSClassId);
610          if(JS_IsException(jsobj))
611              return jsobj;
612          auto pptr = new std::shared_ptr<T>(ptr, [](T *) {});
613          JS_SetOpaque(jsobj, pptr);
614          return jsobj;
615      }
616      static T * unwrap(JSContext * ctx, JSValueConst v)
617      {
618          auto ptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque2(ctx, v, js_traits<std::shared_ptr<T>>::QJSClassId));
619          if(!ptr)
620              throw exception{};
621          return ptr->get();
622      }
623  };
624  namespace detail {
625  struct function
626  {
627      JSValue
628      (* invoker)(function * self, JSContext * ctx, JSValueConst this_value, int argc, JSValueConst * argv) = nullptr;
629      void (* destroyer)(function * self) = nullptr;
630      alignas(std::max_align_t) char functor[];
631      template <typename Functor>
632      static function * create(JSRuntime * rt, Functor&& f)
633      {
634          auto fptr = static_cast<function *>(js_malloc_rt(rt, sizeof(function) + sizeof(Functor)));
635          if(!fptr)
636              throw std::bad_alloc{};
637          new(fptr) function;
638          auto functorptr = reinterpret_cast<Functor *>(fptr->functor);
639          new(functorptr) Functor(std::forward<Functor>(f));
640          fptr->destroyer = nullptr;
641          if constexpr(!std::is_trivially_destructible_v<Functor>)
642          {
643              fptr->destroyer = [](function * fptr) {
644                  auto functorptr = static_cast<Functor *>(fptr->functor);
645                  functorptr->~Functor();
646              };
647          }
648          return fptr;
649      }
650  };
651  static_assert(std::is_trivially_destructible_v<function>);
652  }
653  template <>
654  struct js_traits<detail::function>
655  {
656      inline static JSClassID QJSClassId = 0;
657      static void register_class(JSContext * ctx, const char * name)
658      {
659          if(QJSClassId == 0)
660          {
661              JS_NewClassID(&QJSClassId);
662          }
663          auto rt = JS_GetRuntime(ctx);
664          if(JS_IsRegisteredClass(rt, QJSClassId))
665              return;
666          JSClassDef def{
667                  name,
668                  [](JSRuntime * rt, JSValue obj) noexcept {
669                      auto fptr = static_cast<detail::function *>(JS_GetOpaque(obj, QJSClassId));
670                      assert(fptr);
671                      if(fptr->destroyer)
672                          fptr->destroyer(fptr);
673                      js_free_rt(rt, fptr);
674                  },
675                  nullptr, 
676                  [](JSContext * ctx, JSValueConst func_obj, JSValueConst this_val, int argc,
677                     JSValueConst * argv, int flags) -> JSValue {
678                      auto ptr = static_cast<detail::function *>(JS_GetOpaque2(ctx, func_obj, QJSClassId));
679                      if(!ptr)
680                          return JS_EXCEPTION;
681                      return ptr->invoker(ptr, ctx, this_val, argc, argv);
682                  },
683                  nullptr
684          };
685          int e = JS_NewClass(rt, QJSClassId, &def);
686          if(e < 0)
687              throw std::runtime_error{"Cannot register C++ function class"};
688      }
689  };
690  template <typename Key>
691  struct js_property_traits
692  {
693      static void set_property(JSContext * ctx, JSValue this_obj, Key key, JSValue value);
694      static JSValue get_property(JSContext * ctx, JSValue this_obj, Key key);
695  };
696  template <>
697  struct js_property_traits<const char *>
698  {
699      static void set_property(JSContext * ctx, JSValue this_obj, const char * name, JSValue value)
700      {
701          int err = JS_SetPropertyStr(ctx, this_obj, name, value);
702          if(err < 0)
703              throw exception{};
704      }
705      static JSValue get_property(JSContext * ctx, JSValue this_obj, const char * name) noexcept
706      {
707          return JS_GetPropertyStr(ctx, this_obj, name);
708      }
709  };
710  template <>
711  struct js_property_traits<uint32_t>
712  {
713      static void set_property(JSContext * ctx, JSValue this_obj, uint32_t idx, JSValue value)
714      {
715          int err = JS_SetPropertyUint32(ctx, this_obj, idx, value);
716          if(err < 0)
717              throw exception{};
718      }
719      static JSValue get_property(JSContext * ctx, JSValue this_obj, uint32_t idx) noexcept
720      {
721          return JS_GetPropertyUint32(ctx, this_obj, idx);
722      }
723  };
724  class Value;
725  namespace detail {
726  template <typename Key>
727  struct property_proxy
728  {
729      JSContext * ctx;
730      JSValue this_obj;
731      Key key;
732      template <typename T>
733      T as() const
734      {
735          return unwrap_free<T>(ctx, js_property_traits<Key>::get_property(ctx, this_obj, key));
736      }
737      template <typename T>
738      explicit operator T() const { return as<T>(); }
739      operator Value() const; 
740      template <typename Value>
741      property_proxy& operator =(Value value)
742      {
743          js_property_traits<Key>::set_property(ctx, this_obj, key,
744                                                js_traits<Value>::wrap(ctx, std::move(value)));
745          return *this;
746      }
747  };
748  template <auto M>
749  struct get_set {};
750  template <class T, typename R, R T::*M>
751  struct get_set<M>
752  {
753      using is_const = std::is_const<R>;
754      static const R& get(const std::shared_ptr<T>& ptr)
755      {
756          return *ptr.*M;
757      }
758      static R& set(const std::shared_ptr<T>& ptr, R value)
759      {
760          return *ptr.*M = std::move(value);
761      }
762  };
763  } 
764  class Value
765  {
766  public:
767      JSValue v;
768      JSContext * ctx = nullptr;
769  public:
770      template <typename T>
771      Value(JSContext * ctx, T&& val) : ctx(ctx)
772      {
773          v = js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(val));
774          if(JS_IsException(v))
775              throw exception{};
776      }
777      Value(const Value& rhs)
778      {
779          ctx = rhs.ctx;
780          v = JS_DupValue(ctx, rhs.v);
781      }
782      Value(Value&& rhs)
783      {
784          std::swap(ctx, rhs.ctx);
785          v = rhs.v;
786      }
787      Value& operator =(Value rhs)
788      {
789          std::swap(ctx, rhs.ctx);
790          std::swap(v, rhs.v);
791          return *this;
792      }
793      bool operator ==(JSValueConst other) const
794      {
795          return JS_VALUE_GET_TAG(v) == JS_VALUE_GET_TAG(other) && JS_VALUE_GET_PTR(v) == JS_VALUE_GET_PTR(other);
796      }
797      bool operator !=(JSValueConst other) const { return !((*this) == other); }
798      bool operator ==(const Value& rhs) const
799      {
800          return ctx == rhs.ctx && (*this == rhs.v);
801      }
802      bool operator !=(const Value& rhs) const { return !((*this) == rhs); }
803      ~Value()
804      {
805          if(ctx) JS_FreeValue(ctx, v);
806      }
807      bool isError() const { return JS_IsError(ctx, v); }
808      template <typename T>
809      auto as() const { return js_traits<std::decay_t<T>>::unwrap(ctx, v); }
810      template <typename T>
811      explicit operator T() const { return as<T>(); }
812      JSValue release() 
813      {
814          ctx = nullptr;
815          return v;
816      }
817      operator JSValue()&& { return release(); }
818      template <typename Key>
819      detail::property_proxy<Key> operator [](Key key)
820      {
821          return {ctx, v, std::move(key)};
822      }
823      template <typename Function>
824      Value& add(const char * name, Function&& f)
825      {
826          (*this)[name] = js_traits<decltype(std::function{std::forward<Function>(f)})>::wrap(ctx,
827                                                                                              std::forward<Function>(f));
828          return *this;
829      }
830      template <auto F>
831      std::enable_if_t<!std::is_member_object_pointer_v<decltype(F)>, Value&>
832      add(const char * name)
833      {
834          (*this)[name] = fwrapper<F>{name};
835          return *this;
836      }
837      template <auto FGet, auto FSet>
838      Value& add_getter_setter(const char * name)
839      {
840          auto prop = JS_NewAtom(ctx, name);
841          using fgetter = fwrapper<FGet, true>;
842          using fsetter = fwrapper<FSet, true>;
843          int ret = JS_DefinePropertyGetSet(ctx, v, prop,
844                                            js_traits<fgetter>::wrap(ctx, fgetter{name}),
845                                            js_traits<fsetter>::wrap(ctx, fsetter{name}),
846                                            JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE
847          );
848          JS_FreeAtom(ctx, prop);
849          if(ret < 0)
850              throw exception{};
851          return *this;
852      }
853      template <auto FGet>
854      Value& add_getter(const char * name)
855      {
856          auto prop = JS_NewAtom(ctx, name);
857          using fgetter = fwrapper<FGet, true>;
858          int ret = JS_DefinePropertyGetSet(ctx, v, prop,
859                                            js_traits<fgetter>::wrap(ctx, fgetter{name}),
860                                            JS_UNDEFINED,
861                                            JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE
862          );
863          JS_FreeAtom(ctx, prop);
864          if(ret < 0)
865              throw exception{};
866          return *this;
867      }
868      template <auto M>
869      std::enable_if_t<std::is_member_object_pointer_v<decltype(M)>, Value&>
870      add(const char * name)
871      {
872          if constexpr (detail::get_set<M>::is_const::value)
873          {
874              return add_getter<detail::get_set<M>::get>(name);
875          }
876          else
877          {
878              return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
879          }
880      }
881      std::string
882      toJSON(const Value& replacer = Value{nullptr, JS_UNDEFINED}, const Value& space = Value{nullptr, JS_UNDEFINED})
883      {
884          assert(ctx);
885          assert(!replacer.ctx || ctx == replacer.ctx);
886          assert(!space.ctx || ctx == space.ctx);
887          JSValue json = JS_JSONStringify(ctx, v, replacer.v, space.v);
888          return (std::string) Value{ctx, json};
889      }
890  };
891  class Runtime
892  {
893  public:
894      JSRuntime * rt;
895      Runtime()
896      {
897          rt = JS_NewRuntime();
898          if(!rt)
899              throw std::runtime_error{"qjs: Cannot create runtime"};
900      }
901      Runtime(const Runtime&) = delete;
902      ~Runtime()
903      {
904          JS_FreeRuntime(rt);
905      }
906  };
907  class Context
908  {
909  public:
910      JSContext * ctx;
911      class Module
912      {
913          friend class Context;
914          JSModuleDef * m;
915          JSContext * ctx;
916          const char * name;
917          using nvp = std::pair<const char *, Value>;
918          std::vector<nvp> exports;
919      public:
920          Module(JSContext * ctx, const char * name) : ctx(ctx), name(name)
921          {
922              m = JS_NewCModule(ctx, name, [](JSContext * ctx, JSModuleDef * m) noexcept {
923                  auto& context = Context::get(ctx);
924                  auto it = std::find_if(context.modules.begin(), context.modules.end(),
925                                         [m](const Module& module) { return module.m == m; });
926                  if(it == context.modules.end())
927                      return -1;
928                  for(const auto& e : it->exports)
929                  {
930                      if(JS_SetModuleExport(ctx, m, e.first, JS_DupValue(ctx, e.second.v)) != 0)
931                          return -1;
932                  }
933                  return 0;
934              });
935              if(!m)
936                  throw exception{};
937          }
938          Module& add(const char * name, JSValue value)
939          {
940              exports.push_back({name, {ctx, value}});
941              JS_AddModuleExport(ctx, m, name);
942              return *this;
943          }
944          Module& add(const char * name, Value value)
945          {
946              assert(value.ctx == ctx);
947              exports.push_back({name, std::move(value)});
948              JS_AddModuleExport(ctx, m, name);
949              return *this;
950          }
951          template <typename T>
952          Module& add(const char * name, T value)
953          {
954              return add(name, js_traits<T>::wrap(ctx, std::move(value)));
955          }
956          Module(const Module&) = delete;
957          Module(Module&&) = default;
958          template <auto F>
959          Module& function(const char * name)
960          {
961              return add(name, qjs::fwrapper<F>{name});
962          }
963          template <typename F>
964          Module& function(const char * name, F&& f)
965          {
966              return add(name, js_traits<decltype(std::function{std::forward<F>(f)})>::wrap(ctx, std::forward<F>(f)));
967          }
968      private:
969          template <class T>
970          class class_registrar
971          {
972              const char * name;
973              qjs::Value prototype;
974              qjs::Context::Module& module;
975              qjs::Context& context;
976          public:
977              explicit class_registrar(const char * name, qjs::Context::Module& module, qjs::Context& context) :
978                      name(name),
979                      prototype(context.newObject()),
980                      module(module),
981                      context(context)
982              {
983              }
984              class_registrar(const class_registrar&) = delete;
985              template <typename F>
986              class_registrar& fun(const char * name, F&& f)
987              {
988                  prototype.add(name, std::forward<F>(f));
989                  return *this;
990              }
991              template <auto F>
992              class_registrar& fun(const char * name)
993              {
994                  prototype.add<F>(name);
995                  return *this;
996              }
997              template <auto FGet, auto FSet = nullptr>
998              class_registrar& property(const char * name)
999              {
1000                  if constexpr (std::is_same_v<decltype(FSet), std::nullptr_t>)
1001                      prototype.add_getter<FGet>(name);
1002                  else
1003                      prototype.add_getter_setter<FGet, FSet>(name);
1004                  return *this;
1005              }
1006              template <typename... Args>
1007              class_registrar& constructor(const char * name = nullptr)
1008              {
1009                  if(!name)
1010                      name = this->name;
1011                  Value ctor = context.newValue(qjs::ctor_wrapper<T, Args...>{name});
1012                  JS_SetConstructor(context.ctx, ctor.v, prototype.v);
1013                  module.add(name, std::move(ctor));
1014                  return *this;
1015              }
1016              ~class_registrar()
1017              {
1018                  context.registerClass<T>(name, std::move(prototype));
1019              }
1020          };
1021      public:
1022          template <class T>
1023          class_registrar<T> class_(const char * name)
1024          {
1025              return class_registrar<T>{name, *this, qjs::Context::get(ctx)};
1026          }
1027      };
1028      std::vector<Module> modules;
1029  private:
1030      void init()
1031      {
1032          JS_SetContextOpaque(ctx, this);
1033          js_traits<detail::function>::register_class(ctx, "C++ function");
1034      }
1035  public:
1036      Context(Runtime& rt) : Context(rt.rt) {}
1037      Context(JSRuntime * rt)
1038      {
1039          ctx = JS_NewContext(rt);
1040          if(!ctx)
1041              throw std::runtime_error{"qjs: Cannot create context"};
1042          init();
1043      }
1044      Context(JSContext * ctx) : ctx{ctx}
1045      {
1046          init();
1047      }
1048      Context(const Context&) = delete;
1049      ~Context()
1050      {
1051          modules.clear();
1052          JS_FreeContext(ctx);
1053      }
1054      Module& addModule(const char * name)
1055      {
1056          modules.emplace_back(ctx, name);
1057          return modules.back();
1058      }
1059      Value global() { return Value{ctx, JS_GetGlobalObject(ctx)}; }
1060      Value newObject() { return Value{ctx, JS_NewObject(ctx)}; }
1061      template <typename T>
1062      Value newValue(T&& val) { return Value{ctx, std::forward<T>(val)}; }
1063      Value getException() { return Value{ctx, JS_GetException(ctx)}; }
1064      template <class T>
1065      void registerClass(const char * name, JSValue proto = JS_NULL)
1066      {
1067          js_traits<std::shared_ptr<T>>::register_class(ctx, name, proto);
1068      }
1069      Value eval(std::string_view buffer, const char * filename = "<eval>", unsigned eval_flags = 0)
1070      {
1071          assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); 
1072          JSValue v = JS_Eval(ctx, buffer.data(), buffer.size(), filename, eval_flags);
1073          return Value{ctx, v};
1074      }
1075      Value evalFile(const char * filename, unsigned eval_flags = 0)
1076      {
1077          size_t buf_len;
1078          auto deleter = [this](void * p) { js_free(ctx, p); };
1079          auto buf = std::unique_ptr<uint8_t, decltype(deleter)>{js_load_file(ctx, &buf_len, filename), deleter};
1080          if(!buf)
1081              throw std::runtime_error{std::string{"evalFile: can't read file: "} + filename};
1082          return eval({reinterpret_cast<char *>(buf.get()), buf_len}, filename, eval_flags);
1083      }
1084      Value fromJSON(std::string_view buffer, const char * filename = "<fromJSON>")
1085      {
1086          assert(buffer.data()[buffer.size()] == '\0' &&
1087                 "fromJSON buffer is not null-terminated"); 
1088          JSValue v = JS_ParseJSON(ctx, buffer.data(), buffer.size(), filename);
1089          return Value{ctx, v};
1090      }
1091      static Context& get(JSContext * ctx)
1092      {
1093          void * ptr = JS_GetContextOpaque(ctx);
1094          assert(ptr);
1095          return *static_cast<Context *>(ptr);
1096      }
1097  };
1098  template <>
1099  struct js_traits<Value>
1100  {
1101      static Value unwrap(JSContext * ctx, JSValueConst v)
1102      {
1103          return Value{ctx, JS_DupValue(ctx, v)};
1104      }
1105      static JSValue wrap(JSContext * ctx, Value v) noexcept
1106      {
1107          assert(ctx == v.ctx);
1108          return v.release();
1109      }
1110  };
1111  template <typename R, typename... Args>
1112  struct js_traits<std::function<R(Args...)>>
1113  {
1114      static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
1115      {
1116          const int argc = sizeof...(Args);
1117          if constexpr(argc == 0)
1118          {
1119              return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}]() -> R {
1120                  JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, 0, nullptr);
1121                  if(JS_IsException(result))
1122                  {
1123                      JS_FreeValue(jsfun_obj.ctx, result);
1124                      throw exception{};
1125                  }
1126                  return detail::unwrap_free<R>(jsfun_obj.ctx, result);
1127              };
1128          }
1129          else
1130          {
1131              return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}](Args&& ... args) -> R {
1132                  const int argc = sizeof...(Args);
1133                  JSValue argv[argc];
1134                  detail::wrap_args(jsfun_obj.ctx, argv, std::forward<Args>(args)...);
1135                  JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, argc,
1136                                           const_cast<JSValueConst *>(argv));
1137                  for(int i = 0; i < argc; i++) JS_FreeValue(jsfun_obj.ctx, argv[i]);
1138                  if(JS_IsException(result))
1139                  {
1140                      JS_FreeValue(jsfun_obj.ctx, result);
1141                      throw exception{};
1142                  }
1143                  return detail::unwrap_free<R>(jsfun_obj.ctx, result);
1144              };
1145          }
1146      }
1147      template <typename Functor>
1148      static JSValue wrap(JSContext * ctx, Functor&& functor)
1149      {
1150          using detail::function;
1151          assert(js_traits<function>::QJSClassId);
1152          auto obj = JS_NewObjectClass(ctx, js_traits<function>::QJSClassId);
1153          if(JS_IsException(obj))
1154              return JS_EXCEPTION;
1155          auto fptr = function::create(JS_GetRuntime(ctx), std::forward<Functor>(functor));
1156          fptr->invoker = [](function * self, JSContext * ctx, JSValueConst this_value, int argc, JSValueConst * argv) {
1157              assert(self);
1158              auto f = reinterpret_cast<Functor *>(&self->functor);
1159              return detail::wrap_call<R, Args...>(ctx, *f, argv);
1160          };
1161          JS_SetOpaque(obj, fptr);
1162          return obj;
1163      }
1164  };
1165  template <class T>
1166  struct js_traits<std::vector<T>>
1167  {
1168      static JSValue wrap(JSContext * ctx, const std::vector<T>& arr) noexcept
1169      {
1170          try
1171          {
1172              auto jsarray = Value{ctx, JS_NewArray(ctx)};
1173              for(uint32_t i = 0; i < (uint32_t) arr.size(); i++)
1174                  jsarray[i] = arr[i];
1175              return jsarray.release();
1176          }
1177          catch(exception)
1178          {
1179              return JS_EXCEPTION;
1180          }
1181      }
1182      static std::vector<T> unwrap(JSContext * ctx, JSValueConst jsarr)
1183      {
1184          int e = JS_IsArray(ctx, jsarr);
1185          if(e == 0)
1186              JS_ThrowTypeError(ctx, "js_traits<std::vector<T>>::unwrap expects array");
1187          if(e <= 0)
1188              throw exception{};
1189          Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
1190          std::vector<T> arr;
1191          auto len = static_cast<int32_t>(jsarray["length"]);
1192          arr.reserve((uint32_t) len);
1193          for(uint32_t i = 0; i < (uint32_t) len; i++)
1194              arr.push_back(static_cast<T>(jsarray[i]));
1195          return arr;
1196      }
1197  };
1198  template <typename U, typename V>
1199  struct js_traits<std::pair<U, V>>
1200  {
1201      static JSValue wrap(JSContext * ctx, std::pair<U, V> obj) noexcept
1202      {
1203          try
1204          {
1205              auto jsarray = Value{ctx, JS_NewArray(ctx)};
1206              jsarray[uint32_t(0)] = std::move(obj.first);
1207              jsarray[uint32_t(1)] = std::move(obj.second);
1208              return jsarray.release();
1209          }
1210          catch(exception)
1211          {
1212              return JS_EXCEPTION;
1213          }
1214      }
1215      static std::pair<U, V> unwrap(JSContext * ctx, JSValueConst jsarr)
1216      {
1217          int e = JS_IsArray(ctx, jsarr);
1218          if(e == 0)
1219              JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expects array", QJSPP_TYPENAME(std::pair<U, V>));
1220          if(e <= 0)
1221              throw exception{};
1222          Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
1223          const auto len = static_cast<uint32_t>(jsarray["length"]);
1224          if(len != 2)
1225          {
1226              JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expected array of length 2, got length %d",
1227                                QJSPP_TYPENAME(std::pair<U, V>), len);
1228              throw exception{};
1229          }
1230          return std::pair<U, V>{
1231                  static_cast<U>(jsarray[uint32_t(0)]),
1232                  static_cast<V>(jsarray[uint32_t(1)])
1233          };
1234      }
1235  };
1236  template <typename T>
1237  struct js_traits<std::optional<T>>
1238  {
1239      static JSValue wrap(JSContext * ctx, std::optional<T> obj) noexcept
1240      {
1241          if(obj)
1242              return js_traits<std::decay_t<T>>::wrap(ctx, *obj);
1243          return JS_NULL;
1244      }
1245      static auto unwrap(JSContext * ctx, JSValueConst v) noexcept -> std::optional<decltype(js_traits<std::decay_t<T>>::unwrap(ctx, v))>
1246      {
1247          try
1248          {
1249              if(JS_IsNull(v))
1250                  return std::nullopt;
1251              return js_traits<std::decay_t<T>>::unwrap(ctx, v);
1252          }
1253          catch(exception)
1254          {
1255              JS_FreeValue(ctx, JS_GetException(ctx));
1256          }
1257          return std::nullopt;
1258      }
1259  };
1260  namespace detail {
1261  template <typename Key>
1262  property_proxy<Key>::operator Value() const
1263  {
1264      return as<Value>();
1265  }
1266  }
1267  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-pruned_store.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-quickjspp.hpp</div>
                </div>
                <div class="column column_space"><pre><code>11  		nano::rocksdb::store & store;
12  	public:
13  		explicit pruned_store (nano::rocksdb::store & store_a);
14  		void put (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a) override;
15  		void del (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a) override;
</pre></code></div>
                <div class="column column_space"><pre><code>26      static R unwrap(JSContext * ctx, JSValueConst v);
27      static JSValue wrap(JSContext * ctx, R value);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    