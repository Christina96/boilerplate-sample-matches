
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.243654822335024%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahooex.cpp</h3>
            <pre><code>1  #include "yahooex.h"
2  #include "ss.h"
3  const TStr TYExpr::LogFPfx="Log";
4  const TStr TYExpr::DatFExt=".Dat";
5  const TStr TYExpr::TxtFExt=".Txt";
6  const TStr TYExpr::TmpFExt=".Tmp";
7  const TStr TYExpr::YWebBsFPfx="Y";
8  const TStr TYExpr::YTsWebBsFPfx="YTs";
9  const TStr TYExpr::YBsFPfx="YBs";
10  const TStr TYExpr::YWordFPfx="YWord";
11  const TStr TYExpr::YCtgFPfx="YCtg";
12  const TStr TYExpr::YMdFPfx="YMd";
13  const TStr TYExpr::YDsBsFPfx="YDsBs";
14  const TStr TYExpr::YFSelFPfx="YFSel";
15  const TStr TYExpr::YInvIxFPfx="YInvIx";
16  void TYExpr::GenYBs(
17   const TStr& YRootFPath, const TStr& YDmNm, const PNotify& Notify){
18    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
19    PXWebBs WebBs=PXWebBs(new TWebMemBs(NrYRootFPath+YWebBsFPfx+YDmNm));
20    PYBs YBs=PYBs(new TYBs(WebBs, 5, 4, swstEnglish523, TStrV(), Notify));
21    YBs->Save(NrYRootFPath+YBsFPfx+YDmNm+DatFExt);
22    YBs->SaveTxt(NrYRootFPath+YBsFPfx+YDmNm+TxtFExt);
23    YBs->SaveTxtWords(NrYRootFPath+YWordFPfx+YDmNm+TxtFExt);
24    YBs->SaveTxtCtgs(NrYRootFPath+YCtgFPfx+YDmNm+TxtFExt);
25  }
26  void TYExpr::GenYDsBs(
27   const TStr& YRootFPath, const TStr& YDmNm, const PNotify& Notify){
28    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
29    TStr YBsFNm=NrYRootFPath+YBsFPfx+YDmNm+DatFExt;
30    TStr YDsBsFNm=NrYRootFPath+YDsBsFPfx+YDmNm+DatFExt;
31    TStr YDsBsTxtFNm=NrYRootFPath+YDsBsFPfx+YDmNm+TxtFExt;
32    TFIn YBsFIn(YBsFNm);
33    PYBs YBs=PYBs(new TYBs(YBsFIn));
34    PYDsBs YDsBs=PYDsBs(new TYDsBs(ydnLnSects, 1.00, 0.001, 0.0001, YBs, Notify));
35    YDsBs->Save(YDsBsFNm);
36    YDsBs->SaveTxt(TFOut::New(YDsBsTxtFNm), YBs);
37  }
38  void TYExpr::PutMomHd(TOLx& Lx, const TStr& VarNm){
39    Lx.PutUQStr(VarNm+"Mean"); Lx.PutUQStr(VarNm+"SDev");
40    Lx.PutUQStr(VarNm+"SErr"); Lx.PutUQStr(VarNm+"Med");
41    Lx.PutUQStr(VarNm+"Q1"); Lx.PutUQStr(VarNm+"Q3");
42  }
43  void TYExpr::PutMomVal(TOLx& Lx, const PMom& Mom){
44    if (Mom->IsUsable()){
45      Lx.PutFlt(Mom->GetMean()); Lx.PutFlt(Mom->GetSDev());
46      Lx.PutFlt(Mom->GetSErr()); Lx.PutFlt(Mom->GetMedian());
47      Lx.PutFlt(Mom->GetQuart1()); Lx.PutFlt(Mom->GetQuart3());
48    } else {
49      for (int MomN=0; MomN<6; MomN++){Lx.PutFlt(-1);}
50    }
51  }
52  void TYExpr::Go(
53   const PSOut& SOut, const bool& PutHd, const bool& SaveTmp,
54   const TStr& YDmNm, const TStr& YRootFPath, const TStr& InfoMsg,
55   const PYBs& _YBs, const PYDsBs& _YDsBs,
56   const PYFSelBs& _YFSelBs, const PYInvIx& _YInvIx,
57   const int& SampleDocs,
58   const int& TsRuns, const int& TsDocs,
59   const int& MnTsWords, const double& MnTsWordPrb, const bool& ExclTs,
60   const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
61   const TYDsBsNrType& YDsBsNrType, const double& YDsBsWordFqExp,
62   const double& YDsBsMnDocWordPrb, const double& YDsBsSumAllWordPrb,
63   const TYFSelType& YFSelType, const TFltV& YFSelsV,
64   const bool& YFSelPosWords, const PAttrEstV& YFSelAttrEstV,
65   const TYNegDsType& YNegDsType, const TYPriorType& YPriorType,
66   const double& YInvIxEstExp, const TFltV& YInvIxSumEstPrbV,
67   const TIntV& YInvIxMnDocFqV,
68   const TFltV& PrRePrbTshV,
69   const int& ShowTopHits, const PNotify& Notify){
70    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
71    if (!_YInvIx.Empty()){
72      IAssert((!_YBs.Empty())&&(!_YDsBs.Empty())&&(!_YFSelBs.Empty()));}
73    if (!_YFSelBs.Empty()){
74      IAssert((!_YBs.Empty())&&(!_YDsBs.Empty()));}
75    if (!_YDsBs.Empty()){
76      IAssert(!_YBs.Empty());}
77    PXWebBs TsWebBs=PXWebBs(new TWebMemBs(NrYRootFPath+YTsWebBsFPfx+YDmNm));
78    TIntV TsWebPgIdV;
79    {int TsWebPgP=TsWebBs->FFirstWebPg(); int TsWebPgId;
80    while (TsWebBs->FNextWebPg(TsWebPgP, TsWebPgId)){
81      TsWebPgIdV.Add(TsWebPgId);}}
82    IAssert(TsRuns*TsDocs<=TsWebPgIdV.Len());
83    TRnd Rnd; TsWebPgIdV.Shuffle(Rnd);
84    for (int TsRunN=0; TsRunN<TsRuns; TsRunN++){
85      int MnTsDocN=TsRunN*TsDocs;
86      int MxTsDocN=MnTsDocN+TsDocs-1;
87      PYBs YBs=_YBs;
88      if (YBs.Empty()){
89        if (ExclTs){
90          TStrV TsUrlStrV;
91          for (int TsWebPgN=MnTsDocN; TsWebPgN<=MxTsDocN; TsWebPgN++){
92            int TsWebPgId=TsWebPgIdV[TsWebPgN];
93            TsUrlStrV.Add(TsWebBs->GetUrlStr(TsWebPgId));
94          }
95          PXWebBs WebBs=new TWebMemBs(NrYRootFPath+YWebBsFPfx+YDmNm);
96          YBs=PYBs(new TYBs(
97           WebBs, MxNGram, MnWordFq, SwSetTy, TsUrlStrV, Notify));
98          if (SaveTmp){YBs->SaveTxt(PSOut(new TFOut(YBsFPfx+YDmNm+TxtFExt)));}
99        } else {
100          TFIn YBsFIn(NrYRootFPath+YBsFPfx+YDmNm+DatFExt);
101          YBs=PYBs(new TYBs(YBsFIn));
102          if (SaveTmp){YBs->SaveTxt(PSOut(new TFOut(YBsFPfx+YDmNm+TxtFExt)));}
103        }
104      }
105      PYDsBs YDsBs=_YDsBs;
106      if (YDsBs.Empty()){
107        YDsBs=PYDsBs(new TYDsBs(YDsBsNrType, YDsBsWordFqExp,
108         YDsBsMnDocWordPrb, YDsBsSumAllWordPrb, YBs, Notify));
109        if (SaveTmp){YDsBs->SaveTxt(PSOut(new TFOut(YDsBsFPfx+YDmNm+TxtFExt)), YBs);}
110      }
111      PMom DocDistMom=PMom(new TMom());
112      PMom DocSectsMom=PMom(new TMom());
113      PMom DocWordsMom=PMom(new TMom());
114      for (int DocIdN=0; DocIdN<SampleDocs; DocIdN++){
115        int DocId1=TInt::GetRnd(YBs->GetDocs());
116        int DocId2=TInt::GetRnd(YBs->GetDocs());
117        int DocDist=YBs->GetDocDist(DocId1, DocId2);
118        int DocSects=YBs->GetDocSects(DocId1);
119        int DocWords=YDsBs->GetWordDs(DocId1)->GetWordIds();
120        if (DocDist!=-1){DocDistMom->Add(DocDist);}
121        DocSectsMom->Add(DocSects);
122        DocWordsMom->Add(DocWords);
123      }
124      DocDistMom->Def();
125      DocSectsMom->Def();
126      DocWordsMom->Def();
127      TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
128      if (PutHd){
129        Lx.PutUQStr("DmNm"); Lx.PutUQStr("Info");
130        Lx.PutUQStr("NrType"); Lx.PutUQStr("WordFqExp");
131        Lx.PutUQStr("MnDocWordPrb"); Lx.PutUQStr("SumAllWordPrb");
132        Lx.PutUQStr("FSelType"); Lx.PutUQStr("FSelPosWords");
133        Lx.PutUQStr("FSels"); Lx.PutUQStr("FSelAttrEst");
134        Lx.PutUQStr("NegDsType"); Lx.PutUQStr("PriorType");
135        Lx.PutUQStr("EstExp"); Lx.PutUQStr("SumEstPrb"); Lx.PutUQStr("MnDocFq");
136        Lx.PutUQStr("TsRunN"); Lx.PutUQStr("MnTsDocN"); Lx.PutUQStr("MxTsDocN");
137        Lx.PutUQStr("MnTsWords"); Lx.PutUQStr("MnTsWordPrb");
138        Lx.PutUQStr("ExclTs");
139        Lx.PutUQStr("PrRcPrbTsh");
140        Lx.PutUQStr("TsDocs"); Lx.PutUQStr("BadTsDocsPrb");
141        Lx.PutUQStr("AllCfs"); Lx.PutUQStr("UnknownCfPrb");
142        PutMomHd(Lx, "Visits"); PutMomHd(Lx, "Plc"); PutMomHd(Lx, "Prb");
143        PutMomHd(Lx, "KwF05"); PutMomHd(Lx, "KwF1"); PutMomHd(Lx, "KwF2");
144        PutMomHd(Lx, "KwF4"); PutMomHd(Lx, "KwF8"); PutMomHd(Lx, "KwF16");
145        PutMomHd(Lx, "KwPrecis"); PutMomHd(Lx, "KwRecall");
146        PutMomHd(Lx, "DocF05"); PutMomHd(Lx, "DocF1"); PutMomHd(Lx, "DocF2");
147        PutMomHd(Lx, "DocF4"); PutMomHd(Lx, "DocF8"); PutMomHd(Lx, "DocF16");
148        PutMomHd(Lx, "DocPrecis"); PutMomHd(Lx, "DocRecall");
149        PutMomHd(Lx, "Prb95Dist"); PutMomHd(Lx, "Prb95Docs");
150        Lx.PutUQStr("Prb95DocsPrb"); Lx.PutUQStr("Prb95NoDocs");
151        PutMomHd(Lx, "Dist"); PutMomHd(Lx, "Sects");
152        Lx.PutUQStr("Sects"); Lx.PutUQStr("AbsSects");
153        PutMomHd(Lx, "Words"); PutMomHd(Lx, "FSelWords");
154        Lx.PutLn();
155      }
156      PSOut LogSOut=new TFOut(LogFPfx+YDmNm+TxtFExt);
157      for (int YFSelsN=0; YFSelsN<YFSelsV.Len(); YFSelsN++){
158        double YFSels=YFSelsV[YFSelsN];
159        TNotify::OnNotify(Notify, ntInfo,
160         TStr("  | YFSels: ")+TFlt::GetStr(YFSels)+"%");
161        for (int AttrEstN=0; AttrEstN<YFSelAttrEstV.Len(); AttrEstN++){
162          PAttrEst YFSelAttrEst=YFSelAttrEstV[AttrEstN];
163          TStr YFSelAttrEstNm;
164          if (YFSelAttrEst.Empty()){YFSelAttrEstNm="OddsRatio";} \
165          else {YFSelAttrEstNm=YFSelAttrEst->GetNm();}
166          TNotify::OnNotify(Notify, ntInfo,
167            TStr("  |  | AttrEst: ")+YFSelAttrEstNm);
168          PYFSelBs YFSelBs=_YFSelBs;
169          if (YFSelBs.Empty()){
170            YFSelBs=PYFSelBs(new TYFSelBs(
171             YFSelType, YFSels, YFSelPosWords, YFSelAttrEst,
172             YNegDsType, YPriorType, YBs, YDsBs, Notify));
173            if (SaveTmp){
174              PSOut SOut=TFOut::New(YFSelFPfx+YDmNm+TxtFExt);
175              YFSelBs->SaveTxt(SOut, YBs, YDsBs);
176            }
177          }
178          PMom DocFSelWordsMom=PMom(new TMom());
179          for (int DocIdN=0; DocIdN<SampleDocs; DocIdN++){
180            int DocId=TInt::GetRnd(YBs->GetDocs());
181            int DocWords=YFSelBs->GetWords(DocId);
182            DocFSelWordsMom->Add(DocWords);
183          }
184          DocFSelWordsMom->Def();
185          for (int SumEstPrbN=0; SumEstPrbN<YInvIxSumEstPrbV.Len(); SumEstPrbN++){
186            double YInvIxSumEstPrb=YInvIxSumEstPrbV[SumEstPrbN];
187            TNotify::OnNotify(Notify, ntInfo,
188             TStr("  |  |  | SumEstPrb: ")+TFlt::GetStr(YInvIxSumEstPrb));
189            PYInvIx YInvIx=_YInvIx;
190            if (YInvIx.Empty()){
191              YInvIx=PYInvIx(new TYInvIx(YInvIxEstExp, YInvIxSumEstPrb,
192               YBs, YDsBs, YFSelBs, Notify));
193              if (SaveTmp){
194                PSOut SOut=PSOut(new TFOut(YInvIxFPfx+YDmNm+TxtFExt));
195                YInvIx->SaveTxt(SOut, YBs);
196              }
197            }
198            PMd Md=new TMdYBayes(
199             YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx);
200            for (int MnDocFqN=0; MnDocFqN<YInvIxMnDocFqV.Len(); MnDocFqN++){
201              int MnDocFq=YInvIxMnDocFqV[MnDocFqN];
202              TNotify::OnNotify(Notify, ntInfo,
203               TStr("  |  |  |  | MnDocFq: ")+TInt::GetStr(MnDocFq));
204              for (int PrRePrbTshN=0; PrRePrbTshN<PrRePrbTshV.Len(); PrRePrbTshN++){
205                double PrRePrbTsh=PrRePrbTshV[PrRePrbTshN];
206                TNotify::OnNotify(Notify, ntInfo,
207                 TStr("  |  |  |  |  | PrRePrbTsh: ")+TFlt::GetStr(PrRePrbTsh));
208                int BadTsDocs=0;
209                int AllCfs=0; int UnknownCfs=0;
210                PMom VisitsMom=PMom(new TMom());
211                PMom RefDocPlcMom=PMom(new TMom());
212                PMom RefDocPrbMom=PMom(new TMom());
213                PMom KwF05Mom=PMom(new TMom());
214                PMom KwF1Mom=PMom(new TMom());
215                PMom KwF2Mom=PMom(new TMom());
216                PMom KwF4Mom=PMom(new TMom());
217                PMom KwF8Mom=PMom(new TMom());
218                PMom KwF16Mom=PMom(new TMom());
219                PMom KwPrecisMom=PMom(new TMom());
220                PMom KwRecallMom=PMom(new TMom());
221                PMom DocF05Mom=PMom(new TMom());
222                PMom DocF1Mom=PMom(new TMom());
223                PMom DocF2Mom=PMom(new TMom());
224                PMom DocF4Mom=PMom(new TMom());
225                PMom DocF8Mom=PMom(new TMom());
226                PMom DocF16Mom=PMom(new TMom());
227                PMom DocPrecisMom=PMom(new TMom());
228                PMom DocRecallMom=PMom(new TMom());
229                PMom Prb95DistMom=PMom(new TMom());
230                PMom Prb95DocsMom=PMom(new TMom());
231                int Prb95NoDocs=0;
232                for (int TsWebPgN=MnTsDocN; TsWebPgN<=MxTsDocN; TsWebPgN++){
233                  int TsWebPgId=TsWebPgIdV[TsWebPgN];
234                  PXWebPg TsWebPg=TsWebBs->GetWebPg(TsWebPgId);
235                  PYWordDs TsWordDs=YBs->GetWordDs(TsWebPg);
236                  if (SaveTmp){TsWordDs->SaveTxt(LogSOut, YBs());}
237                  TOLx LogLx(LogSOut, TFSet()|oloFrcEoln|oloSigNum);
238                  PValRet ValRet=new TYValRet(
239                   MnTsWordPrb, Md->GetDmHd(), YBs, TsWordDs);
240                  TStr TsUrlStr=TsWebPg->GetUrlStr();
241                  TStr RefUrlStr=TsWebPg->GetRefUrlStrV()[0];
242                  TStr RefUrlStrPath=TUrl(RefUrlStr).GetPathStr();
243                  int RefDocId=YBs->GetDocId(RefUrlStr);
244                  if (SaveTmp){
245                    LogLx.PutVarStr("UrlStr", TsWebPg->GetUrlStr());
246                    LogLx.PutVarStr("FromCategory", RefUrlStrPath);
247                  }
248                  if (TsWordDs->GetSumWordFq()<MnTsWords){
249                    if (SaveTmp){
250                      TChA Msg;
251                      Msg+=" *** Bad Document";
252                      Msg+=TStr(' ')+TFlt::GetStr(YFSels)+'%';
253                      Msg+=TStr(' ')+TFlt::GetStr(MnDocFq);
254                      Msg+=TStr(" [")+TFlt::GetStr(TsWordDs->GetSumWordFq());
255                      Msg+=TStr('<')+TFlt::GetStr(MnTsWords)+']';
256                      TNotify::OnNotify(Notify, ntInfo, Msg);
257                      LogLx.PutVarStr("Classification", Msg);
258                    }
259                    BadTsDocs++; continue;
260                  };
261                  TIntV ClassNV; YInvIx->GetDocIdV(TsWordDs, MnDocFq, ClassNV);
262                  TFltStrKdV PrbUrlStrKdV(ClassNV.Len(), 0);
263                  for (int ClassNN=0; ClassNN<ClassNV.Len(); ClassNN++){
264                    int ClassN=ClassNV[ClassNN];
265                    TStr UrlStr=Md->GetDmHd()->GetClassNm(ClassN);
266                    PTbValDs ValDs=Md->GetPostrValDs(ValRet, ClassN);
267                    double ClassPrb=ValDs->GetPrb_RelFq(TTbVal(true));
268                    PrbUrlStrKdV.Add(TFltStrKd(ClassPrb, UrlStr));
269                  }
270                  PrbUrlStrKdV.Sort(false);
271                  TIntV RefCtgIdV; YBs->GetCtgIdV(RefDocId, RefCtgIdV);
272                  TIntV BestCtgIdV;
273                  {int DocPlcN=0;
274                  while ((DocPlcN<PrbUrlStrKdV.Len())&&
275                   (PrbUrlStrKdV[DocPlcN].Key>PrRePrbTsh)){
276                    TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
277                    int DocId=YBs->GetDocId(UrlStr);
278                    TIntV CtgIdV; YBs->GetCtgIdV(DocId, CtgIdV);
279                    BestCtgIdV.AddVMerged(CtgIdV);
280                    DocPlcN++;
281                  }}
282                  TIntV IntsCtgIdV; RefCtgIdV.Intrs(BestCtgIdV, IntsCtgIdV);
283                  double KwPrecis=1; double KwRecall=1;
284                  double KwF05=0; double KwF1=0; double KwF2=0;
285                  double KwF4=0; double KwF8=0; double KwF16=0;
286                  if (BestCtgIdV.Len()>0){
287                    KwPrecis=IntsCtgIdV.Len()/double(BestCtgIdV.Len());}
288                  if (RefCtgIdV.Len()>0){
289                    KwRecall=IntsCtgIdV.Len()/double(RefCtgIdV.Len());}
290                  if (KwPrecis+KwRecall>0){
291                    KwF05=(1.25*KwPrecis*KwRecall)/(0.25*KwPrecis+KwRecall);
292                    KwF1=(2*KwPrecis*KwRecall)/(1*KwPrecis+KwRecall);
293                    KwF2=(5*KwPrecis*KwRecall)/(4*KwPrecis+KwRecall);
294                    KwF4=(17*KwPrecis*KwRecall)/(16*KwPrecis+KwRecall);
295                    KwF8=(65*KwPrecis*KwRecall)/(64*KwPrecis+KwRecall);
296                    KwF16=(257*KwPrecis*KwRecall)/(256*KwPrecis+KwRecall);
297                  }
298                  KwPrecisMom->Add(KwPrecis); KwRecallMom->Add(KwRecall);
299                  KwF05Mom->Add(KwF05); KwF1Mom->Add(KwF1); KwF2Mom->Add(KwF2);
300                  KwF4Mom->Add(KwF4); KwF8Mom->Add(KwF8); KwF16Mom->Add(KwF16);
301                  TIntV ParentDocIdV; YBs->GetParentDocIdV(RefDocId, ParentDocIdV);
302                  TIntV BestDocIdV;
303                  {int DocPlcN=0;
304                  while ((DocPlcN<PrbUrlStrKdV.Len())&&
305                   (PrbUrlStrKdV[DocPlcN].Key>PrRePrbTsh)){
306                    TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
307                    int DocId=YBs->GetDocId(UrlStr);
308                    BestDocIdV.AddSorted(DocId);
309                    DocPlcN++;
310                  }}
311                  TIntV IntsDocIdV; ParentDocIdV.Intrs(BestDocIdV, IntsDocIdV);
312                  double DocPrecis=1; double DocRecall=1;
313                  double DocF05=0; double DocF1=0; double DocF2=0;
314                  double DocF4=0; double DocF8=0; double DocF16=0;
315                  if (BestDocIdV.Len()>0){
316                    DocPrecis=IntsDocIdV.Len()/double(BestDocIdV.Len());}
317                  if (ParentDocIdV.Len()>0){
318                    DocRecall=IntsDocIdV.Len()/double(ParentDocIdV.Len());}
319                  if (DocPrecis+DocRecall>0){
320                    DocF05=(1.25*DocPrecis*DocRecall)/(0.25*DocPrecis+DocRecall);
321                    DocF1=(2*DocPrecis*DocRecall)/(1*DocPrecis+DocRecall);
322                    DocF2=(5*DocPrecis*DocRecall)/(4*DocPrecis+DocRecall);
323                    DocF4=(17*DocPrecis*DocRecall)/(16*DocPrecis+DocRecall);
324                    DocF8=(65*DocPrecis*DocRecall)/(64*DocPrecis+DocRecall);
325                    DocF16=(257*DocPrecis*DocRecall)/(256*DocPrecis+DocRecall);
326                  }
327                  DocPrecisMom->Add(DocPrecis); DocRecallMom->Add(DocRecall);
328                  DocF05Mom->Add(DocF05); DocF1Mom->Add(DocF1); DocF2Mom->Add(DocF2);
329                  DocF4Mom->Add(DocF4); DocF8Mom->Add(DocF8); DocF16Mom->Add(DocF16);
330                  AllCfs++;
331                  {int DocPlcN=0; int Prb95Docs=0;
332                  while ((DocPlcN<PrbUrlStrKdV.Len())&&
333                   ((DocPlcN<10)||(double(PrbUrlStrKdV[DocPlcN].Key))>0.95)){
334                    double DocPrb=PrbUrlStrKdV[DocPlcN].Key;
335                    TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
336                    int DocDist=YBs->GetDocDist(RefDocId, YBs->GetDocId(UrlStr));
337                    if (DocDist!=-1){
338                      if (DocPrb>0.95){Prb95DistMom->Add(DocDist); Prb95Docs++;}
339                    }
340                    DocPlcN++;
341                  }
342                  Prb95DocsMom->Add(Prb95Docs);
343                  if (Prb95Docs==0){Prb95NoDocs++;}}
344                  int RefDocPlcN=0;
345                  while ((RefDocPlcN<PrbUrlStrKdV.Len())&&
346                   (PrbUrlStrKdV[RefDocPlcN].Dat!=RefUrlStr)){RefDocPlcN++;}
347                  if (RefDocPlcN==PrbUrlStrKdV.Len()){
348                    UnknownCfs++;
349                    VisitsMom->Add(PrbUrlStrKdV.Len());
350                    RefDocPlcMom->Add(
351                     PrbUrlStrKdV.Len()+(YBs->GetDocs()-PrbUrlStrKdV.Len())/2);
352                    RefDocPrbMom->Add(0);
353                    if (SaveTmp){
354                      TStr Msg;
355                      Msg+=TInt::GetStr(PrbUrlStrKdV.Len());
356                      Msg+=TStr(" *** Not Found");
357                      Msg+=TStr(' ')+TFlt::GetStr(YFSels)+'%';
358                      Msg+=TStr(' ')+TFlt::GetStr(MnDocFq);
359                      Msg+=TStr(" [")+TFlt::GetStr(TsWordDs->GetSumWordFq());
360                      Msg+=TStr(">=")+TFlt::GetStr(MnTsWords)+']';
361                      TNotify::OnNotify(Notify, ntInfo, Msg);
362                      LogLx.PutVarStr("Classification", Msg);
363                      LogLx.PutVarStr("RefCtgIdV", YBs->GetCtgIdVStr(RefCtgIdV));
364                      LogLx.PutVarStr("BestCtgIdV", YBs->GetCtgIdVStr(BestCtgIdV));
365                      LogLx.PutVarStr("IntsCtgIdV", YBs->GetCtgIdVStr(IntsCtgIdV));
366                    }
367                  } else {
368                    double RefDocPrb=PrbUrlStrKdV[RefDocPlcN].Key;
369                    int MnRefDocPlcN=RefDocPlcN; int MxRefDocPlcN=RefDocPlcN;
370                    while ((MnRefDocPlcN>0)&&
371                     (fabs(RefDocPrb-PrbUrlStrKdV[MnRefDocPlcN-1].Key)<0.00001)){
372                      MnRefDocPlcN--;}
373                    while ((MxRefDocPlcN<PrbUrlStrKdV.Len()-1)&&
374                     (fabs(RefDocPrb-PrbUrlStrKdV[MxRefDocPlcN+1].Key)<0.00001)){
375                      MxRefDocPlcN++;}
376                    int OrigRefDocPlcN=RefDocPlcN;
377                    RefDocPlcN=(MxRefDocPlcN+MnRefDocPlcN)/2;
378                    VisitsMom->Add(PrbUrlStrKdV.Len());
379                    RefDocPlcMom->Add(RefDocPlcN+1); RefDocPrbMom->Add(RefDocPrb);
380                    TChA Msg;
381                    Msg+=TStr(" place:")+TInt::GetStr(RefDocPlcN+1);
382                    Msg+=TStr(" [orig:")+TInt::GetStr(OrigRefDocPlcN+1)+']';
383                    Msg+=TStr(" prob.:")+TFlt::GetStr(RefDocPrb);
384                    Msg+=TStr(" [first:")+TFlt::GetStr(PrbUrlStrKdV[0].Key)+']';
385                    Msg+=TStr(' ')+TInt::GetStr(PrbUrlStrKdV.Len());
386                    Msg+=TStr(' ')+TFlt::GetStr(YFSels)+'%';
387                    Msg+=TStr(' ')+TFlt::GetStr(MnDocFq);
388                    if (SaveTmp){
389                      TNotify::OnNotify(Notify, ntInfo, Msg);
390                      LogLx.PutVarStr("Classification", Msg);
391                      TChA KwPrRcStr; TChA DocPrRcStr;
392                      KwPrRcStr+=TStr(" P:")+TFlt::GetStr(KwPrecis);
393                      KwPrRcStr+=TStr(" R:")+TFlt::GetStr(KwRecall);
394                      DocPrRcStr+=TStr(" P:")+TFlt::GetStr(DocPrecis);
395                      DocPrRcStr+=TStr(" R:")+TFlt::GetStr(DocRecall);
396                      LogLx.PutVarStr("KwPrRc", KwPrRcStr);
397                      LogLx.PutVarStr("DocPrRc", DocPrRcStr);
398                      LogLx.PutVarStr("RefCtgIdV", YBs->GetCtgIdVStr(RefCtgIdV));
399                      LogLx.PutVarStr("BestCtgIdV", YBs->GetCtgIdVStr(BestCtgIdV));
400                      LogLx.PutVarStr("IntsCtgIdV", YBs->GetCtgIdVStr(IntsCtgIdV));
401                    }
402                  }
403                  if (SaveTmp){
404                    int DocPlcN=0;
405                    while ((DocPlcN<PrbUrlStrKdV.Len())&&(DocPlcN<ShowTopHits)){
406                      double DocPrb=PrbUrlStrKdV[DocPlcN].Key;
407                      TStr UrlStr=PrbUrlStrKdV[DocPlcN].Dat;
408                      int DocId=YBs->GetDocId(UrlStr);
409                      int DocDist=YBs->GetDocDist(RefDocId, DocId);
410                      TChA Msg;
411                      Msg+=TStr("  ")+TInt::GetStr(DocPlcN+1)+'.';
412                      Msg+=TStr(' ')+TFlt::GetStr(DocPrb);
413                      Msg+=TStr(' ')+TInt::GetStr(DocDist);
414                      Msg+=TStr(' ')+TUrl(UrlStr).GetPathStr();
415                      LogLx.PutVarStr("Rank", Msg);
416                      DocPlcN++;
417                    }
418                  }
419                  if (SaveTmp){LogLx.PutLn();}
420                } 
421                VisitsMom->Def(); RefDocPlcMom->Def(); RefDocPrbMom->Def();
422                KwF05Mom->Def(); KwF1Mom->Def(); KwF2Mom->Def();
423                KwF4Mom->Def(); KwF8Mom->Def(); KwF16Mom->Def();
424                KwPrecisMom->Def(); KwRecallMom->Def();
425                DocF05Mom->Def(); DocF1Mom->Def(); DocF2Mom->Def();
426                DocF4Mom->Def(); DocF8Mom->Def(); DocF16Mom->Def();
427                DocPrecisMom->Def(); DocRecallMom->Def();
428                Prb95DistMom->Def(); Prb95DocsMom->Def();
429                Lx.PutStr(YDmNm);
430                if (InfoMsg.Empty()){Lx.PutStr("No");} else {Lx.PutStr(InfoMsg);}
431                Lx.PutStr(TYDsBs::GetNrTypeStr(YDsBsNrType));
432                Lx.PutFlt(YDsBsWordFqExp);
433                Lx.PutFlt(YDsBsMnDocWordPrb);
434                Lx.PutFlt(YDsBsSumAllWordPrb);
435                Lx.PutStr(TYFSelBs::GetYFSelTypeStr(YFSelType));
436                Lx.PutBool(YFSelPosWords);
437                Lx.PutFlt(YFSels);
438                Lx.PutStr(YFSelAttrEstNm);
439                Lx.PutStr(TYDmDs::GetYNegDsTypeStr(YNegDsType));
440                Lx.PutStr(TYDmDs::GetYPriorTypeStr(YPriorType));
441                Lx.PutFlt(YInvIxEstExp);
442                Lx.PutFlt(YInvIxSumEstPrb);
443                Lx.PutInt(MnDocFq);
444                Lx.PutInt(TsRunN); Lx.PutInt(MnTsDocN); Lx.PutInt(MxTsDocN);
445                Lx.PutInt(MnTsWords); Lx.PutFlt(MnTsWordPrb);
446                Lx.PutBool(ExclTs);
447                Lx.PutFlt(PrRePrbTsh);
448                Lx.PutFlt(TsDocs); Lx.PutFlt(BadTsDocs/double(TsDocs));
449                Lx.PutFlt(AllCfs); Lx.PutFlt(UnknownCfs/double(AllCfs));
450                PutMomVal(Lx, VisitsMom);
451                PutMomVal(Lx, RefDocPlcMom); PutMomVal(Lx, RefDocPrbMom);
452                PutMomVal(Lx, KwF05Mom); PutMomVal(Lx, KwF1Mom);
453                PutMomVal(Lx, KwF2Mom); PutMomVal(Lx, KwF4Mom);
454                PutMomVal(Lx, KwF8Mom); PutMomVal(Lx, KwF16Mom);
455                PutMomVal(Lx, KwPrecisMom); PutMomVal(Lx, KwRecallMom);
456                PutMomVal(Lx, DocF05Mom); PutMomVal(Lx, DocF1Mom);
457                PutMomVal(Lx, DocF2Mom); PutMomVal(Lx, DocF4Mom);
458                PutMomVal(Lx, DocF8Mom); PutMomVal(Lx, DocF16Mom);
459                PutMomVal(Lx, DocPrecisMom); PutMomVal(Lx, DocRecallMom);
460                PutMomVal(Lx, Prb95DistMom); PutMomVal(Lx, Prb95DocsMom);
461                Lx.PutFlt((AllCfs-Prb95NoDocs)/double(AllCfs)); Lx.PutInt(Prb95NoDocs);
462                PutMomVal(Lx, DocDistMom); PutMomVal(Lx, DocSectsMom);
463                Lx.PutInt(TInt(YBs->GetSects())); Lx.PutInt(TInt(YBs->GetAbsSects()));
464                PutMomVal(Lx, DocWordsMom); PutMomVal(Lx, DocFSelWordsMom);
465                Lx.PutLn();
466                SOut->Flush();
467              } 
468            } 
469          } 
470        } 
471      }  
472    } 
473    TNotify::OnNotify(Notify, ntInfo, "Finished.");
474  }
475  void TYExpr::ExtrResMlj(const PNotify& Notify){
476    TStrStrVH VarToMomVH(100);
477    VarToMomVH.AddDat("FSels").Add("Mean");
478    VarToMomVH.AddDat("MnDocFq").Add("Mean");
479    VarToMomVH.AddDat("PrRcPrbTsh").Add("Mean");
480    VarToMomVH.AddDat("PlcMed").Add("Mean");
481    VarToMomVH.AddDat("PlcMed").Add("SDev");
482    VarToMomVH.AddDat("PlcMed").Add("SErr");
483    VarToMomVH.AddDat("PrbMed").Add("Mean");
484    VarToMomVH.AddDat("PrbMed").Add("SDev");
485    VarToMomVH.AddDat("PrbMed").Add("SErr");
486    VarToMomVH.AddDat("KwPrecisMed").Add("Mean");
487    VarToMomVH.AddDat("KwPrecisMed").Add("SDev");
488    VarToMomVH.AddDat("KwPrecisMed").Add("SErr");
489    VarToMomVH.AddDat("KwRecallMed").Add("Mean");
490    VarToMomVH.AddDat("KwRecallMed").Add("SDev");
491    VarToMomVH.AddDat("KwRecallMed").Add("SErr");
492    VarToMomVH.AddDat("DocPrecisMed").Add("Mean");
493    VarToMomVH.AddDat("DocPrecisMed").Add("SDev");
494    VarToMomVH.AddDat("DocPrecisMed").Add("SErr");
495    VarToMomVH.AddDat("DocRecallMed").Add("Mean");
496    VarToMomVH.AddDat("DocRecallMed").Add("SDev");
497    VarToMomVH.AddDat("DocRecallMed").Add("SErr");
498    VarToMomVH.AddDat("KwF2").Add("Mean");
499    VarToMomVH.AddDat("KwF2").Add("SDev");
500    VarToMomVH.AddDat("KwF2").Add("SErr");
501    VarToMomVH.AddDat("DocF2").Add("Mean");
502    VarToMomVH.AddDat("DocF2").Add("SDev");
503    VarToMomVH.AddDat("DocF2").Add("SErr");
504    TStrV FPathV; FPathV.Add("../results");
505    TStrV FExtV; FExtV.Add("st");
506    TFFile FFile(FPathV, FExtV); TStr FNm;
507    while (FFile.Next(FNm)){
508      PSIn SIn=new TFIn(FNm);
509      TILx ILx(SIn, TFSet()|iloRetEoln|iloSigNum|iloUniStr);
510      TNotify::OnNotify(Notify, ntInfo, TStr("Processing ")+FNm);
511      TStrV VarNmV;
512      TVec<TVec<TStrV> > VarValVVV;
513      ILx.GetSym();
514      while (ILx.Sym!=syEof){
515        TStrV NmV;
516        IAssert((ILx.Sym==syStr)&&(ILx.Str=="DmNm"));
517        while (ILx.Sym!=syEoln){NmV.Add(ILx.Str); ILx.GetSym();}
518        if (VarNmV.Empty()){VarNmV=NmV;} else {IAssert(VarNmV==NmV);}
519        TVec<TStrV> ValVV;
520        ILx.GetSym();
521        while ((ILx.Sym!=syEof)&&((ILx.Sym!=syStr)||(ILx.Str!="DmNm"))){
522          TStrV ValV(VarNmV.Len(), 0);
523          while (ILx.Sym!=syEoln){ValV.Add(ILx.Str); ILx.GetSym();}
524          IAssert(VarNmV.Len()==ValV.Len());
525          ValVV.Add(ValV);
526          ILx.GetSym();
527        }
528        VarValVVV.Add(ValVV);
529        TNotify::OnNotify(Notify, ntInfo,
530         TStr("... lines ")+TInt::GetStr(ValVV.Len()));
531      }
532      int InvIxMnDocFqVarN=VarNmV.SearchForw("MnDocFq");
533      int PrRcPrbTshVarN=VarNmV.SearchForw("PrRcPrbTsh");
534      THash<TStr, TVec<PMom> > VarNmToValMomVH(100);
535      {int VarToMomVP=VarToMomVH.FFirstKeyId();
536      while (VarToMomVH.FNextKeyId(VarToMomVP)){
537        TStr VarNm=VarToMomVH.GetKey(VarToMomVP);
538        int VarN=VarNmV.SearchForw(VarNm);
539        int Vals=VarValVVV[0].Len();
540        for (int ValN=0; ValN<Vals; ValN++){
541          double InvIxMnDocFq=VarValVVV[0][ValN][InvIxMnDocFqVarN].GetFlt();
542          double PrRcPrbTsh=VarValVVV[0][ValN][PrRcPrbTshVarN].GetFlt();
543          if ((fabs(InvIxMnDocFq-3)>0.0001)||(fabs(PrRcPrbTsh-0.95)>0.0001)){
544            VarNmToValMomVH.AddDat(VarNm).Add(NULL); continue;}
545          PMom ValMom=PMom(new TMom());
546          for (int ValSetN=0; ValSetN<VarValVVV.Len(); ValSetN++){
547            TStr ValStr=VarValVVV[ValSetN][ValN][VarN];
548            double Val=ValStr.GetFlt();
549            ValMom->Add(Val);
550          }
551          ValMom->Def();
552          VarNmToValMomVH.AddDat(VarNm).Add(ValMom);
553        }
554      }}
555      PSOut SOut=PSOut(new TFOut(FNm+"t"));
556      TOLx OLx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
557      {int VarToMomVP=VarToMomVH.FFirstKeyId();
558      while (VarToMomVH.FNextKeyId(VarToMomVP)){
559        TStr VarNm=VarToMomVH.GetKey(VarToMomVP);
560        TStrV& MomNmV=VarToMomVH[VarToMomVP];
561        for (int MomNmN=0; MomNmN<MomNmV.Len(); MomNmN++){
562          OLx.PutUQStr(VarNm+"_"+MomNmV[MomNmN]);
563        }
564      }}
565      OLx.PutLn();
566      int Vals=VarValVVV[0].Len();
567      for (int ValN=0; ValN<Vals; ValN++){
568        double InvIxMnDocFq=VarValVVV[0][ValN][InvIxMnDocFqVarN].GetFlt();
569        double PrRcPrbTsh=VarValVVV[0][ValN][PrRcPrbTshVarN].GetFlt();
570        if ((fabs(InvIxMnDocFq-3)>0.0001)||(fabs(PrRcPrbTsh-0.95)>0.0001)){continue;}
571        {int VarToMomVP=VarToMomVH.FFirstKeyId();
572        while (VarToMomVH.FNextKeyId(VarToMomVP)){
573          TStr VarNm=VarToMomVH.GetKey(VarToMomVP);
574          TStrV& MomNmV=VarToMomVH[VarToMomVP];
575          for (int MomNmN=0; MomNmN<MomNmV.Len(); MomNmN++){
576            PMom Mom=VarNmToValMomVH.GetDat(VarNm)[ValN];
577            double Val=Mom->GetByNm(MomNmV[MomNmN]);
578            OLx.PutFlt(Val);
579          }
580        }}
581        OLx.PutLn();
582      }
583    }
584    TNotify::OnNotify(Notify, ntInfo, "Finished.");
585  }
586  void TYExpr::ExtrResKdd(const PNotify& Notify){
587    TStr FNm="../resultsKdd/resultAllA.st";
588    PSIn SIn=new TFIn(FNm);
589    TILx ILx(SIn, TFSet()|iloRetEoln|iloSigNum|iloUniStr);
590    TNotify::OnNotify(Notify, ntInfo, TStr("Processing ")+FNm);
591    TStrV NmV;
592    TVec<TFltV> ValVV;
593    ILx.GetSym(syStr, syEoln);
594    IAssert((ILx.Sym==syStr)&&(ILx.Str=="DmNm"));
595    while (ILx.Sym!=syEoln){NmV.Add(ILx.Str); ILx.GetSym(syStr, syEoln);}
596    ILx.GetSym(syStr, syFlt, syEof);
597    while (ILx.Sym!=syEof){
598      TFltV ValV(NmV.Len(), 0);
599      while (ILx.Sym!=syEoln){
600        if (ILx.Sym==syFlt){ValV.Add(ILx.Flt);}
601        else if (ILx.Sym==syStr){ValV.Add(TStr(ILx.Str).GetPrimHashCd());}
602        else {Fail;}
603        ILx.GetSym(syStr, syFlt, syEoln);
604      }
605      IAssert(NmV.Len()==ValV.Len());
606      ValVV.Add(ValV);
607      ILx.GetSym(syStr, syFlt, syEof);
608    }
609    TNotify::OnNotify(Notify, ntInfo,
610     TStr("... lines ")+TInt::GetStr(ValVV.Len()));
611    TFltV FSelsV;
612    FSelsV.Add(0.25); FSelsV.Add(0.50); FSelsV.Add(0.75); FSelsV.Add(1.0);
613    FSelsV.Add(1.5); FSelsV.Add(2.0); FSelsV.Add(3.0); FSelsV.Add(5.0);
614    FSelsV.Add(7.0); FSelsV.Add(9.0);
615    TIntV MnDocFqV;
616    MnDocFqV.Add(TInt(1)); MnDocFqV.Add(TInt(2)); MnDocFqV.Add(TInt(3)); 
617    MnDocFqV.Add(TInt(4)); MnDocFqV.Add(TInt(5)); MnDocFqV.Add(TInt(6));
618    MnDocFqV.Add(TInt(7)); MnDocFqV.Add(TInt(8)); MnDocFqV.Add(TInt(9));
619    MnDocFqV.Add(TInt(10));
620    TFltV SumEstPrbV;
621    SumEstPrbV.Add(1.00); SumEstPrbV.Add(0.90); SumEstPrbV.Add(0.80);
622    SumEstPrbV.Add(0.70); SumEstPrbV.Add(0.60); SumEstPrbV.Add(0.50);
623    SumEstPrbV.Add(0.40);
624    int DmNmVarN=NmV.SearchForw("DmNm");
625    int FSelsVarN=NmV.SearchForw("FSels");
626    int SumEstPrbVarN=NmV.SearchForw("SumEstPrb");
627    int MnDocFqVarN=NmV.SearchForw("MnDocFq");
628    int VisitsMeanVarN=NmV.SearchForw("VisitsMean");
629    int VisitsSErrVarN=NmV.SearchForw("VisitsErr");
630    int PlcMedVarN=NmV.SearchForw("PlcMed");
631    int KwPrecisMeanVarN=NmV.SearchForw("KwPrecisMean");
632    int KwRecallMeanVarN=NmV.SearchForw("KwRecallMean");
633    int KwF2VarN=NmV.SearchForw("KwF2");
634    for (int SumEstPrbN=0; SumEstPrbN<SumEstPrbV.Len(); SumEstPrbN++){
635      TStr OutFNm="../resultskdd/tt/EntSMF1_"+TInt::GetStr(SumEstPrbN)+".st";
636      TNotify::OnNotify(Notify, ntInfo, TStr("... writing ")+OutFNm);
637      PSOut SOut=PSOut(new TFOut(OutFNm));
638      TOLx OLx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
639      OLx.PutUQStr("FSels");
640      OLx.PutUQStr("SumEstPrb");
641      OLx.PutUQStr("MnDocFq");
642      OLx.PutUQStr("VisitsMean");
643      OLx.PutUQStr("VisitsSErr");
644      OLx.PutUQStr("PlcMed");
645      OLx.PutUQStr("KwPrecisMean");
646      OLx.PutUQStr("KwRecallMean");
647      OLx.PutUQStr("KwF2");
648      OLx.PutLn();
649      double SumEstPrb=SumEstPrbV[SumEstPrbN];
650      for (int MnDocFqN=0; MnDocFqN<MnDocFqV.Len(); MnDocFqN++){
651        double MnDocFq=MnDocFqV[MnDocFqN];
652        for (int FSelsN=0; FSelsN<FSelsV.Len(); FSelsN++){
653          double FSels=FSelsV[FSelsN];
654          if (!TFlt::Eq6(FSels, 1.0)){continue;}
655          for (int ValN=0; ValN<ValVV.Len(); ValN++){
656            int DmNmHashCd=int(ValVV[ValN][DmNmVarN]);
657            if (DmNmHashCd!=TStr("Ent").GetPrimHashCd()){continue;}
658            double FSelsVal=ValVV[ValN][FSelsVarN];
659            double SumEstPrbVal=ValVV[ValN][SumEstPrbVarN];
660            double MnDocFqVal=ValVV[ValN][MnDocFqVarN];
661            double VisitsMeanVal=ValVV[ValN][VisitsMeanVarN];
662            double VisitsSErrVal=ValVV[ValN][VisitsSErrVarN];
663            double PlcMedVal=ValVV[ValN][PlcMedVarN];
664            double KwPrecisMeanVal=ValVV[ValN][KwPrecisMeanVarN];
665            double KwRecallMeanVal=ValVV[ValN][KwRecallMeanVarN];
666            double KwF2Val=ValVV[ValN][KwF2VarN];
667            if ((TFlt::Eq6(FSels, FSelsVal))&&
668             (TFlt::Eq6(SumEstPrb, SumEstPrbVal))&&
669             (TFlt::Eq6(MnDocFq, MnDocFqVal))){
670              OLx.PutFlt(FSelsVal);
671              OLx.PutFlt(SumEstPrbVal);
672              OLx.PutFlt(MnDocFqVal);
673              OLx.PutFlt(VisitsMeanVal);
674              OLx.PutFlt(VisitsSErrVal);
675              OLx.PutFlt(PlcMedVal);
676              OLx.PutFlt(KwPrecisMeanVal);
677              OLx.PutFlt(KwRecallMeanVal);
678              OLx.PutFlt(KwF2Val);
679              OLx.PutLn();
680            }
681          }
682        }
683      }
684    }
685    {for (int SumEstPrbN=0; SumEstPrbN<SumEstPrbV.Len(); SumEstPrbN++){
686      TStr OutFNm="../resultskdd/tt/EntSFM9_"+TInt::GetStr(SumEstPrbN)+".st";
687      TNotify::OnNotify(Notify, ntInfo, TStr("... writing ")+OutFNm);
688      PSOut SOut=PSOut(new TFOut(OutFNm));
689      TOLx OLx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
690      OLx.PutUQStr("FSels");
691      OLx.PutUQStr("SumEstPrb");
692      OLx.PutUQStr("MnDocFq");
693      OLx.PutUQStr("VisitsMean");
694      OLx.PutUQStr("VisitsSErr");
695      OLx.PutUQStr("PlcMed");
696      OLx.PutUQStr("KwF2");
697      OLx.PutUQStr("KwPrecisMean");
698      OLx.PutUQStr("KwRecallMean");
699      OLx.PutLn();
700      double SumEstPrb=SumEstPrbV[SumEstPrbN];
701      for (int MnDocFqN=0; MnDocFqN<MnDocFqV.Len(); MnDocFqN++){
702        double MnDocFq=MnDocFqV[MnDocFqN];
703        if (!TFlt::Eq6(MnDocFq, 9.0)){continue;}
704        for (int FSelsN=0; FSelsN<FSelsV.Len(); FSelsN++){
705          double FSels=FSelsV[FSelsN];
706          for (int ValN=0; ValN<ValVV.Len(); ValN++){
707            int DmNmHashCd=int(ValVV[ValN][DmNmVarN]);
708            if (DmNmHashCd!=TStr("Ent").GetPrimHashCd()){continue;}
709            double FSelsVal=ValVV[ValN][FSelsVarN];
710            double SumEstPrbVal=ValVV[ValN][SumEstPrbVarN];
711            double MnDocFqVal=ValVV[ValN][MnDocFqVarN];
712            double VisitsMeanVal=ValVV[ValN][VisitsMeanVarN];
713            double VisitsSErrVal=ValVV[ValN][VisitsSErrVarN];
714            double PlcMedVal=ValVV[ValN][PlcMedVarN];
715            double KwPrecisMeanVal=ValVV[ValN][KwPrecisMeanVarN];
716            double KwRecallMeanVal=ValVV[ValN][KwRecallMeanVarN];
717            double KwF2Val=ValVV[ValN][KwF2VarN];
718            if ((TFlt::Eq6(FSels, FSelsVal))&&
719             (TFlt::Eq6(SumEstPrb, SumEstPrbVal))&&
720             (TFlt::Eq6(MnDocFq, MnDocFqVal))){
721              OLx.PutFlt(FSelsVal);
722              OLx.PutFlt(SumEstPrbVal);
723              OLx.PutFlt(MnDocFqVal);
724              OLx.PutFlt(VisitsMeanVal);
725              OLx.PutFlt(VisitsSErrVal);
726              OLx.PutFlt(PlcMedVal);
727              OLx.PutFlt(KwPrecisMeanVal);
728              OLx.PutFlt(KwRecallMeanVal);
729              OLx.PutFlt(KwF2Val);
730              OLx.PutLn();
731            }
732          }
733        }
734      }
735    }}
736    TNotify::OnNotify(Notify, ntInfo, "Finished.");
737  }
738  PMd TYExpr::GenMd(
739   const TStr& YDmNm, const TStr& YRootFPath, const bool& DoSave,
740   const int& MxNGram, const int& MnWordFq, const TSwSetTy& SwSetTy,
741   const TYDsBsNrType& YDsBsNrType, const double& YDsBsWordFqExp,
742   const double& YDsBsMnDocWordPrb, const double& YDsBsSumAllWordPrb,
743   const TYFSelType& YFSelType, const double& YFSels,
744   const bool& YFSelPosWords, const PAttrEst& YFSelAttrEst,
745   const TYNegDsType& YNegDsType, const TYPriorType& YPriorType,
746   const double& YInvIxEstExp, const double& YInvIxSumEstPrb,
747   const PNotify& Notify){
748    TStr NrYRootFPath=TStr::GetNrFPath(YRootFPath);
749    PXWebBs WebBs=PXWebBs(new TWebMemBs(NrYRootFPath+YWebBsFPfx+YDmNm));
750    PYBs YBs=PYBs(new TYBs(
751     WebBs, MxNGram, MnWordFq, SwSetTy, TStrV(), Notify));
752    PYDsBs YDsBs=PYDsBs(new TYDsBs(
753     YDsBsNrType, YDsBsWordFqExp, YDsBsMnDocWordPrb, YDsBsSumAllWordPrb,
754     YBs, Notify));
755    PYFSelBs YFSelBs=PYFSelBs(new TYFSelBs(
756     YFSelType, YFSels, YFSelPosWords, YFSelAttrEst,
757     YNegDsType, YPriorType, YBs, YDsBs, Notify));
758    PYInvIx YInvIx=PYInvIx(new TYInvIx(
759     YInvIxEstExp, YInvIxSumEstPrb,
760     YBs, YDsBs, YFSelBs, Notify));
761    PMd Md=PMd(new TMdYBayes(
762     YNegDsType, YPriorType, YBs, YDsBs, YFSelBs, YInvIx));
763    if (DoSave){
764      YBs->Save(NrYRootFPath+YBsFPfx+YDmNm+DatFExt);
765      YBs->SaveTxt(NrYRootFPath+YBsFPfx+YDmNm+TxtFExt);
766      YBs->SaveTxtWords(NrYRootFPath+YWordFPfx+YDmNm+TxtFExt);
767      YBs->SaveTxtCtgs(NrYRootFPath+YCtgFPfx+YDmNm+TxtFExt);
768      TStr YDsBsFNm=NrYRootFPath+YDsBsFPfx+YDmNm+TxtFExt;
769      TStr YFSelBsFNm=NrYRootFPath+YFSelFPfx+YDmNm+TxtFExt;
770      TStr YInvIxFNm=NrYRootFPath+YInvIxFPfx+YDmNm+TxtFExt;
771      YDsBs->SaveTxt(PSOut(new TFOut(YDsBsFNm)), YBs);
772      YFSelBs->SaveTxt(PSOut(new TFOut(YFSelBsFNm)), YBs, YDsBs);
773      YInvIx->SaveTxt(PSOut(new TFOut(YInvIxFNm)), YBs);
774      TStr MdFNm=NrYRootFPath+YMdFPfx+YDmNm+DatFExt;
775      TStr CheckMdFNm=NrYRootFPath+YMdFPfx+YDmNm+TmpFExt;
776      TNotify::OnNotify(Notify, ntInfo, TStr("Saving to ")+MdFNm);
777      {TFOut FOut(MdFNm); Md->Save(FOut);}
778    }
779    TNotify::OnNotify(Notify, ntInfo, "Finished.");
780    return Md;
781  }
782  void TYExpr::UseMd(
783   const TStr& YDmNm, const TStr& YRootFPath,
784   const PSIn& SIn, const PSOut& SOut,
785   const double& MnDocPrbTsh, const int& MxTopHits,
786   const double& MnTsWordPrb, const int& MnDocFq,
787   const PNotify&){
788    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum);
789    TStr YMdFNm=
790     TStr::GetNrFPath(YRootFPath)+TYExpr::YMdFPfx+YDmNm+TYExpr::DatFExt;
791    TFIn YMdFIn(YMdFNm);
792    PMd Md=TMdYBayes::Load(YMdFIn);
793    TMdYBayes& YMd=*(TMdYBayes*)Md();
794    PYBs YBs=YMd.GetYBs();
795    PYInvIx YInvIx=YMd.GetYInvIx();
796    PYWordDs TsWordDs=YBs->GetWordDs(SIn);
797    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
798    Lx.PutUQStr("Input Text Distribution"); Lx.PutLn();
799    TsWordDs->SaveTxt(SOut, &(*YBs));
800    PValRet ValRet=
801     PValRet(new TYValRet(MnTsWordPrb, YMd.GetDmHd(), YBs, TsWordDs));
802    TIntV ClassNV; YInvIx->GetDocIdV(TsWordDs, MnDocFq, ClassNV);
803    TDocCfV DocCfV(ClassNV.Len(), 0);
804    for (int ClassNN=0; ClassNN<ClassNV.Len(); ClassNN++){
805      int ClassN=ClassNV[ClassNN];
806      TStr UrlStr=Md->GetDmHd()->GetClassNm(ClassN);
807      TFltIntKdV WordPrbIdV;
808      PTbValDs ValDs=YMd.GetPostrValDs(ValRet, ClassN, WordPrbIdV);
809      double ClassPrb=ValDs->GetPrb_RelFq(TTbVal(true));
810      DocCfV.Add(TDocCf(UrlStr, ClassPrb, WordPrbIdV));
811    }
812    DocCfV.Sort(false);
813    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
814    Lx.PutLn(); Lx.PutUQStr("Best Categories"); Lx.PutLn();
815    {int DocCfN=0; int TbDocCfN=0;
816    while ((DocCfN<DocCfV.Len())&&(DocCfV[DocCfN].DocPrb>MnDocPrbTsh)&&
817     (DocCfN<MxTopHits)){
818      double DocPrb=DocCfV[DocCfN].DocPrb;
819      TStr UrlStr=DocCfV[DocCfN].UrlStr;
820      TStr RankStr=TInt::GetStr(TbDocCfN+1)+'.';
821      TStr DocPrbStr=TFlt::GetStr(DocPrb, 4, 2);
822      TStr DocPathStr=TUrl(UrlStr).GetPathStr();
823      TStrV WordStrV;
824      TFltIntKdV& WordPrbIdV=DocCfV[DocCfN].WordPrbIdV;
825      for (int WordPrbIdN=0; WordPrbIdN<WordPrbIdV.Len(); WordPrbIdN++){
826        double WordPrb=WordPrbIdV[WordPrbIdN].Key;
827        int WordId=WordPrbIdV[WordPrbIdN].Dat;
828        TStr WordStr=YBs->GetWordStr(WordId);
829        TStr WordStrPrbStr=WordStr+" ["+TFlt::GetStr(WordPrb, 0, 4)+"]";
830        WordStrV.Add(WordStrPrbStr);
831      }
832      int Slashes=0;
833      for (int ChN=0; ChN<DocPathStr.Len(); ChN++){
834        if (DocPathStr[ChN]=='/'){Slashes++;}
835      }
836      if (Slashes>2){
837        Lx.PutVarStr("Category", RankStr+" "+DocPrbStr+" "+DocPathStr);
838        Lx.PutVarStrV("Words", WordStrV);
839        TbDocCfN++;
840      }
841      DocCfN++;
842    }}
843    {TIntV CtgIdV;
844    TIntFltH CtgIdToWFqH(1000);
845    int DocCfN=0;
846    while ((DocCfN<DocCfV.Len())&&(DocCfV[DocCfN].DocPrb>MnDocPrbTsh)){
847      double DocPrb=DocCfV[DocCfN].DocPrb;
848      TStr UrlStr=DocCfV[DocCfN].UrlStr;
849      int DocId=YBs->GetDocId(UrlStr);
850      TIntV DocCtgIdV; YBs->GetCtgIdV(DocId, DocCtgIdV);
851      CtgIdV.AddVMerged(DocCtgIdV);
852      for (int DocCtgIdN=0; DocCtgIdN<DocCtgIdV.Len(); DocCtgIdN++){
853        int CtgId=DocCtgIdV[DocCtgIdN];
854        double WFq=DocPrb/log(1+YBs->GetCtgFq(CtgId));
855        CtgIdToWFqH.AddDat(CtgId)+=WFq;
856      }
857      DocCfN++;
858    }
<span onclick='openModal()' class='match'>859    TStr CtgIdVStr=YBs->GetCtgIdVStr(CtgIdV);
860    TStrV CtgStrV; YBs->GetCtgStrV(CtgIdV, CtgStrV);
861    TStr CtgIdToWFqHStr=YBs->GetCtgIdToWFqHStr(CtgIdToWFqH, 0.9);
862    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
863    Lx.PutLn();Lx.PutUQStr("Best Keywords"); Lx.PutLn();
864    Lx.PutVarStr("CtgIdV", CtgIdVStr);
865    Lx.PutVarStrV("CtgStrV", CtgStrV);}
</span>866  }
867  void TYExpr::Extr(const TStr& FNm, const PSOut& SOut){
868    TStrV VarNmV;
869    VarNmV.Add("DmNm"); VarNmV.Add("KNNbrs"); VarNmV.Add("RndSel");
870    VarNmV.Add("HldPrecisMean"); VarNmV.Add("HldRecallMean");
871    VarNmV.Add("HldF2Mean");
872    VarNmV.Add("HlLenMed"); VarNmV.Add("DocLenMed");
873    PSs Ss=TSs::LoadTxt(FNm);
874    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloTabSep);
875    int VarNmN=0;
876    for (int Y=0; Y<Ss->GetYLen(); Y++){
877      for (int X=0; X<Ss->GetXLen(Y); X++){
878        if (Ss->GetVal(X, Y)==VarNmV[VarNmN]){
879          TStr VarNm=VarNmV[VarNmN];
880          TStr ValStr;
881          if (Ss->GetVal(X, Y+1).IsFlt()){
882            PMom Mom=PMom(new TMom()); int RelY=1;
883            while (Ss->GetVal(X, Y+RelY).IsFlt()){
884              double Flt=Ss->GetVal(X, Y+RelY).GetFlt();
885              Mom->Add(Flt);
886              RelY++;
887            }
888            Mom->Def();
889            if (Mom->GetWgt()!=5){
890              double Wgt=Mom->GetWgt();
891              printf("%g", Wgt);
892            }
893            ValStr=TFlt::GetStr(Mom->GetMean())+"/"+TFlt::GetStr(Mom->GetSErr());
894          } else {
895            ValStr=Ss->GetVal(X, Y+1);
896          }
897          Lx.PutUQStr(VarNm);
898          Lx.PutUQStr(ValStr);
899          VarNmN=(VarNmN+1)%VarNmV.Len();
900          if (VarNmN==0){Lx.PutLn();}
901        }
902      }
903    }
904  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/lmdbconfig.hpp>
3  #include <nano/lib/logger_mt.hpp>
4  #include <nano/lib/stats.hpp>
5  #include <nano/lib/utility.hpp>
6  #include <nano/lib/work.hpp>
7  #include <nano/node/common.hpp>
8  #include <nano/node/lmdb/lmdb.hpp>
9  #include <nano/node/rocksdb/rocksdb.hpp>
10  #include <nano/secure/ledger.hpp>
11  #include <nano/secure/utility.hpp>
12  #include <nano/secure/versioning.hpp>
13  #include <nano/test_common/system.hpp>
14  #include <nano/test_common/testutil.hpp>
15  #include <gtest/gtest.h>
16  #include <boost/filesystem.hpp>
17  #include <cstdlib>
18  #include <fstream>
19  #include <unordered_set>
20  #include <vector>
21  using namespace std::chrono_literals;
22  namespace nano
23  {
24  namespace lmdb
25  {
26  	void modify_account_info_to_v14 (nano::lmdb::store & store, nano::transaction const & transaction_a, nano::account const & account_a, uint64_t confirmation_height, nano::block_hash const & rep_block);
27  	void modify_confirmation_height_to_v15 (nano::lmdb::store & store, nano::transaction const & transaction, nano::account const & account, uint64_t confirmation_height);
28  	void write_sideband_v14 (nano::lmdb::store & store_a, nano::transaction & transaction_a, nano::block const & block_a, MDB_dbi db_a);
29  	void write_sideband_v15 (nano::lmdb::store & store_a, nano::transaction & transaction_a, nano::block const & block_a);
30  	void write_block_w_sideband_v18 (nano::lmdb::store & store_a, MDB_dbi database, nano::write_transaction & transaction_a, nano::block const & block_a);
31  }
32  }
33  TEST (block_store, construction)
34  {
35  	nano::logger_mt logger;
36  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
37  	ASSERT_TRUE (!store->init_error ());
38  }
39  TEST (block_store, block_details)
40  {
41  	nano::block_details details_send (nano::epoch::epoch_0, true, false, false);
42  	ASSERT_TRUE (details_send.is_send);
43  	ASSERT_FALSE (details_send.is_receive);
44  	ASSERT_FALSE (details_send.is_epoch);
45  	ASSERT_EQ (nano::epoch::epoch_0, details_send.epoch);
46  	nano::block_details details_receive (nano::epoch::epoch_1, false, true, false);
47  	ASSERT_FALSE (details_receive.is_send);
48  	ASSERT_TRUE (details_receive.is_receive);
49  	ASSERT_FALSE (details_receive.is_epoch);
50  	ASSERT_EQ (nano::epoch::epoch_1, details_receive.epoch);
51  	nano::block_details details_epoch (nano::epoch::epoch_2, false, false, true);
52  	ASSERT_FALSE (details_epoch.is_send);
53  	ASSERT_FALSE (details_epoch.is_receive);
54  	ASSERT_TRUE (details_epoch.is_epoch);
55  	ASSERT_EQ (nano::epoch::epoch_2, details_epoch.epoch);
56  	nano::block_details details_none (nano::epoch::unspecified, false, false, false);
57  	ASSERT_FALSE (details_none.is_send);
58  	ASSERT_FALSE (details_none.is_receive);
59  	ASSERT_FALSE (details_none.is_epoch);
60  	ASSERT_EQ (nano::epoch::unspecified, details_none.epoch);
61  }
62  TEST (block_store, block_details_serialization)
63  {
64  	nano::block_details details1;
65  	details1.epoch = nano::epoch::epoch_2;
66  	details1.is_epoch = false;
67  	details1.is_receive = true;
68  	details1.is_send = false;
69  	std::vector<uint8_t> vector;
70  	{
71  		nano::vectorstream stream1 (vector);
72  		details1.serialize (stream1);
73  	}
74  	nano::bufferstream stream2 (vector.data (), vector.size ());
75  	nano::block_details details2;
76  	ASSERT_FALSE (details2.deserialize (stream2));
77  	ASSERT_EQ (details1, details2);
78  }
79  TEST (block_store, sideband_serialization)
80  {
81  	nano::block_sideband sideband1;
82  	sideband1.account = 1;
83  	sideband1.balance = 2;
84  	sideband1.height = 3;
85  	sideband1.successor = 4;
86  	sideband1.timestamp = 5;
87  	std::vector<uint8_t> vector;
88  	{
89  		nano::vectorstream stream1 (vector);
90  		sideband1.serialize (stream1, nano::block_type::receive);
91  	}
92  	nano::bufferstream stream2 (vector.data (), vector.size ());
93  	nano::block_sideband sideband2;
94  	ASSERT_FALSE (sideband2.deserialize (stream2, nano::block_type::receive));
95  	ASSERT_EQ (sideband1.account, sideband2.account);
96  	ASSERT_EQ (sideband1.balance, sideband2.balance);
97  	ASSERT_EQ (sideband1.height, sideband2.height);
98  	ASSERT_EQ (sideband1.successor, sideband2.successor);
99  	ASSERT_EQ (sideband1.timestamp, sideband2.timestamp);
100  }
101  TEST (block_store, add_item)
102  {
103  	nano::logger_mt logger;
104  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
105  	ASSERT_TRUE (!store->init_error ());
106  	nano::block_builder builder;
107  	auto block = builder
108  				 .open ()
109  				 .source (0)
110  				 .representative (1)
111  				 .account (0)
112  				 .sign (nano::keypair ().prv, 0)
113  				 .work (0)
114  				 .build ();
115  	block->sideband_set ({});
116  	auto hash1 (block->hash ());
117  	auto transaction (store->tx_begin_write ());
118  	auto latest1 (store->block.get (transaction, hash1));
119  	ASSERT_EQ (nullptr, latest1);
120  	ASSERT_FALSE (store->block.exists (transaction, hash1));
121  	store->block.put (transaction, hash1, *block);
122  	auto latest2 (store->block.get (transaction, hash1));
123  	ASSERT_NE (nullptr, latest2);
124  	ASSERT_EQ (*block, *latest2);
125  	ASSERT_TRUE (store->block.exists (transaction, hash1));
126  	ASSERT_FALSE (store->block.exists (transaction, hash1.number () - 1));
127  	store->block.del (transaction, hash1);
128  	auto latest3 (store->block.get (transaction, hash1));
129  	ASSERT_EQ (nullptr, latest3);
130  }
131  TEST (block_store, clear_successor)
132  {
133  	nano::logger_mt logger;
134  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
135  	ASSERT_TRUE (!store->init_error ());
136  	nano::block_builder builder;
137  	auto block1 = builder
138  				  .open ()
139  				  .source (0)
140  				  .representative (1)
141  				  .account (0)
142  				  .sign (nano::keypair ().prv, 0)
143  				  .work (0)
144  				  .build ();
145  	block1->sideband_set ({});
146  	auto transaction (store->tx_begin_write ());
147  	store->block.put (transaction, block1->hash (), *block1);
148  	auto block2 = builder
149  				  .open ()
150  				  .source (0)
151  				  .representative (2)
152  				  .account (0)
153  				  .sign (nano::keypair ().prv, 0)
154  				  .work (0)
155  				  .build ();
156  	block2->sideband_set ({});
157  	store->block.put (transaction, block2->hash (), *block2);
158  	auto block2_store (store->block.get (transaction, block1->hash ()));
159  	ASSERT_NE (nullptr, block2_store);
160  	ASSERT_EQ (0, block2_store->sideband ().successor.number ());
161  	auto modified_sideband = block2_store->sideband ();
162  	modified_sideband.successor = block2->hash ();
163  	block1->sideband_set (modified_sideband);
164  	store->block.put (transaction, block1->hash (), *block1);
165  	{
166  		auto block1_store (store->block.get (transaction, block1->hash ()));
167  		ASSERT_NE (nullptr, block1_store);
168  		ASSERT_EQ (block2->hash (), block1_store->sideband ().successor);
169  	}
170  	store->block.successor_clear (transaction, block1->hash ());
171  	{
172  		auto block1_store (store->block.get (transaction, block1->hash ()));
173  		ASSERT_NE (nullptr, block1_store);
174  		ASSERT_EQ (0, block1_store->sideband ().successor.number ());
175  	}
176  }
177  TEST (block_store, add_nonempty_block)
178  {
179  	nano::logger_mt logger;
180  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
181  	ASSERT_TRUE (!store->init_error ());
182  	nano::keypair key1;
183  	nano::block_builder builder;
184  	auto block = builder
185  				 .open ()
186  				 .source (0)
187  				 .representative (1)
188  				 .account (0)
189  				 .sign (nano::keypair ().prv, 0)
190  				 .work (0)
191  				 .build ();
192  	block->sideband_set ({});
193  	auto hash1 (block->hash ());
194  	block->signature = nano::sign_message (key1.prv, key1.pub, hash1);
195  	auto transaction (store->tx_begin_write ());
196  	auto latest1 (store->block.get (transaction, hash1));
197  	ASSERT_EQ (nullptr, latest1);
198  	store->block.put (transaction, hash1, *block);
199  	auto latest2 (store->block.get (transaction, hash1));
200  	ASSERT_NE (nullptr, latest2);
201  	ASSERT_EQ (*block, *latest2);
202  }
203  TEST (block_store, add_two_items)
204  {
205  	nano::logger_mt logger;
206  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
207  	ASSERT_TRUE (!store->init_error ());
208  	nano::keypair key1;
209  	nano::block_builder builder;
210  	auto block = builder
211  				 .open ()
212  				 .source (0)
213  				 .representative (1)
214  				 .account (1)
215  				 .sign (nano::keypair ().prv, 0)
216  				 .work (0)
217  				 .build ();
218  	block->sideband_set ({});
219  	auto hash1 (block->hash ());
220  	block->signature = nano::sign_message (key1.prv, key1.pub, hash1);
<span onclick='openModal()' class='match'>221  	auto transaction (store->tx_begin_write ());
222  	auto latest1 (store->block.get (transaction, hash1));
223  	ASSERT_EQ (nullptr, latest1);
224  	auto block2 = builder
225  				  .open ()
226  				  .source (0)
227  				  .representative (1)
228  				  .account (3)
229  				  .sign (nano::keypair ().prv, 0)
</span>230  				  .work (0)
231  				  .build ();
232  	block2->sideband_set ({});
233  	block2->hashables.account = 3;
234  	auto hash2 (block2->hash ());
235  	block2->signature = nano::sign_message (key1.prv, key1.pub, hash2);
236  	auto latest2 (store->block.get (transaction, hash2));
237  	ASSERT_EQ (nullptr, latest2);
238  	store->block.put (transaction, hash1, *block);
239  	store->block.put (transaction, hash2, *block2);
240  	auto latest3 (store->block.get (transaction, hash1));
241  	ASSERT_NE (nullptr, latest3);
242  	ASSERT_EQ (*block, *latest3);
243  	auto latest4 (store->block.get (transaction, hash2));
244  	ASSERT_NE (nullptr, latest4);
245  	ASSERT_EQ (*block2, *latest4);
246  	ASSERT_FALSE (*latest3 == *latest4);
247  }
248  TEST (block_store, add_receive)
249  {
250  	nano::logger_mt logger;
251  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
252  	ASSERT_TRUE (!store->init_error ());
253  	nano::keypair key1;
254  	nano::keypair key2;
255  	nano::block_builder builder;
256  	auto block1 = builder
257  				  .open ()
258  				  .source (0)
259  				  .representative (1)
260  				  .account (0)
261  				  .sign (nano::keypair ().prv, 0)
262  				  .work (0)
263  				  .build ();
264  	block1->sideband_set ({});
265  	auto transaction (store->tx_begin_write ());
266  	store->block.put (transaction, block1->hash (), *block1);
267  	auto block = builder
268  				 .receive ()
269  				 .previous (block1->hash ())
270  				 .source (1)
271  				 .sign (nano::keypair ().prv, 2)
272  				 .work (3)
273  				 .build ();
274  	block->sideband_set ({});
275  	nano::block_hash hash1 (block->hash ());
276  	auto latest1 (store->block.get (transaction, hash1));
277  	ASSERT_EQ (nullptr, latest1);
278  	store->block.put (transaction, hash1, *block);
279  	auto latest2 (store->block.get (transaction, hash1));
280  	ASSERT_NE (nullptr, latest2);
281  	ASSERT_EQ (*block, *latest2);
282  }
283  TEST (block_store, add_pending)
284  {
285  	nano::logger_mt logger;
286  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
287  	ASSERT_TRUE (!store->init_error ());
288  	nano::keypair key1;
289  	nano::pending_key key2 (0, 0);
290  	nano::pending_info pending1;
291  	auto transaction (store->tx_begin_write ());
292  	ASSERT_TRUE (store->pending.get (transaction, key2, pending1));
293  	store->pending.put (transaction, key2, pending1);
294  	nano::pending_info pending2;
295  	ASSERT_FALSE (store->pending.get (transaction, key2, pending2));
296  	ASSERT_EQ (pending1, pending2);
297  	store->pending.del (transaction, key2);
298  	ASSERT_TRUE (store->pending.get (transaction, key2, pending2));
299  }
300  TEST (block_store, pending_iterator)
301  {
302  	nano::logger_mt logger;
303  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
304  	ASSERT_TRUE (!store->init_error ());
305  	auto transaction (store->tx_begin_write ());
306  	ASSERT_EQ (store->pending.end (), store->pending.begin (transaction));
307  	store->pending.put (transaction, nano::pending_key (1, 2), { 2, 3, nano::epoch::epoch_1 });
308  	auto current (store->pending.begin (transaction));
309  	ASSERT_NE (store->pending.end (), current);
310  	nano::pending_key key1 (current->first);
311  	ASSERT_EQ (nano::account (1), key1.account);
312  	ASSERT_EQ (nano::block_hash (2), key1.hash);
313  	nano::pending_info pending (current->second);
314  	ASSERT_EQ (nano::account (2), pending.source);
315  	ASSERT_EQ (nano::amount (3), pending.amount);
316  	ASSERT_EQ (nano::epoch::epoch_1, pending.epoch);
317  }
318  TEST (block_store, pending_iterator_comparison)
319  {
320  	nano::logger_mt logger;
321  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
322  	ASSERT_TRUE (!store->init_error ());
323  	nano::stats stats;
324  	auto transaction (store->tx_begin_write ());
325  	store->pending.put (transaction, nano::pending_key (nano::account (3), nano::block_hash (1)), nano::pending_info (nano::account (10), nano::amount (1), nano::epoch::epoch_0));
326  	store->pending.put (transaction, nano::pending_key (nano::account (3), nano::block_hash (4)), nano::pending_info (nano::account (10), nano::amount (0), nano::epoch::epoch_0));
327  	store->pending.put (transaction, nano::pending_key (nano::account (2), nano::block_hash (2)), nano::pending_info (nano::account (10), nano::amount (2), nano::epoch::epoch_1));
328  	store->pending.put (transaction, nano::pending_key (nano::account (2), nano::block_hash (3)), nano::pending_info (nano::account (10), nano::amount (3), nano::epoch::epoch_1));
329  	{
330  		size_t count = 0;
331  		nano::account begin (3);
332  		nano::account end (begin.number () + 1);
333  		for (auto i (store->pending.begin (transaction, nano::pending_key (begin, 0))), n (store->pending.begin (transaction, nano::pending_key (end, 0))); i != n; ++i, ++count)
334  		{
335  			nano::pending_key key (i->first);
336  			ASSERT_EQ (key.account, begin);
337  			ASSERT_LT (count, 3);
338  		}
339  		ASSERT_EQ (count, 2);
340  	}
341  	{
342  		size_t count = 0;
343  		nano::account begin (2);
344  		nano::account end (begin.number () + 1);
345  		for (auto i (store->pending.begin (transaction, nano::pending_key (begin, 0))), n (store->pending.begin (transaction, nano::pending_key (end, 0))); i != n; ++i, ++count)
346  		{
347  			nano::pending_key key (i->first);
348  			ASSERT_EQ (key.account, begin);
349  			ASSERT_LT (count, 3);
350  		}
351  		ASSERT_EQ (count, 2);
352  	}
353  }
354  TEST (block_store, genesis)
355  {
356  	nano::logger_mt logger;
357  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
358  	ASSERT_TRUE (!store->init_error ());
359  	nano::ledger_cache ledger_cache;
360  	auto transaction (store->tx_begin_write ());
361  	store->initialize (transaction, ledger_cache, nano::dev::constants);
362  	nano::account_info info;
363  	ASSERT_FALSE (store->account.get (transaction, nano::dev::genesis->account (), info));
364  	ASSERT_EQ (nano::dev::genesis->hash (), info.head);
365  	auto block1 (store->block.get (transaction, info.head));
366  	ASSERT_NE (nullptr, block1);
367  	auto receive1 (dynamic_cast<nano::open_block *> (block1.get ()));
368  	ASSERT_NE (nullptr, receive1);
369  	ASSERT_LE (info.modified, nano::seconds_since_epoch ());
370  	ASSERT_EQ (info.block_count, 1);
371  	nano::confirmation_height_info confirmation_height_info;
372  	ASSERT_FALSE (store->confirmation_height.get (transaction, nano::dev::genesis->account (), confirmation_height_info));
373  	ASSERT_EQ (confirmation_height_info.height, 1);
374  	ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis->hash ());
375  	auto dev_pub_text (nano::dev::genesis_key.pub.to_string ());
376  	auto dev_pub_account (nano::dev::genesis_key.pub.to_account ());
377  	auto dev_prv_text (nano::dev::genesis_key.prv.to_string ());
378  	ASSERT_EQ (nano::dev::genesis->account (), nano::dev::genesis_key.pub);
379  }
380  TEST (block_store, empty_accounts)
381  {
382  	nano::logger_mt logger;
383  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
384  	ASSERT_TRUE (!store->init_error ());
385  	auto transaction (store->tx_begin_read ());
386  	auto begin (store->account.begin (transaction));
387  	auto end (store->account.end ());
388  	ASSERT_EQ (end, begin);
389  }
390  TEST (block_store, one_block)
391  {
392  	nano::logger_mt logger;
393  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
394  	ASSERT_TRUE (!store->init_error ());
395  	nano::block_builder builder;
396  	auto block1 = builder
397  				  .open ()
398  				  .source (0)
399  				  .representative (1)
400  				  .account (0)
401  				  .sign (nano::keypair ().prv, 0)
402  				  .work (0)
403  				  .build ();
404  	block1->sideband_set ({});
405  	auto transaction (store->tx_begin_write ());
406  	store->block.put (transaction, block1->hash (), *block1);
407  	ASSERT_TRUE (store->block.exists (transaction, block1->hash ()));
408  }
409  TEST (block_store, empty_bootstrap)
410  {
411  	nano::test::system system{};
412  	nano::logger_mt logger;
413  	nano::unchecked_map unchecked{ system.stats, false };
414  	size_t count = 0;
415  	unchecked.for_each ([&count] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
416  		++count;
417  	});
418  	ASSERT_EQ (count, 0);
419  }
420  TEST (block_store, unchecked_begin_search)
421  {
422  	nano::logger_mt logger;
423  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
424  	ASSERT_TRUE (!store->init_error ());
425  	nano::keypair key0;
426  	nano::block_builder builder;
427  	auto block1 = builder
428  				  .send ()
429  				  .previous (0)
430  				  .destination (1)
431  				  .balance (2)
432  				  .sign (key0.prv, key0.pub)
433  				  .work (3)
434  				  .build ();
435  	auto block2 = builder
436  				  .send ()
437  				  .previous (5)
438  				  .destination (6)
439  				  .balance (7)
440  				  .sign (key0.prv, key0.pub)
441  				  .work (8)
442  				  .build ();
443  }
444  TEST (block_store, frontier_retrieval)
445  {
446  	nano::logger_mt logger;
447  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
448  	ASSERT_TRUE (!store->init_error ());
449  	nano::account account1{};
450  	nano::account_info info1 (0, 0, 0, 0, 0, 0, nano::epoch::epoch_0);
451  	auto transaction (store->tx_begin_write ());
452  	store->confirmation_height.put (transaction, account1, { 0, nano::block_hash (0) });
453  	store->account.put (transaction, account1, info1);
454  	nano::account_info info2;
455  	store->account.get (transaction, account1, info2);
456  	ASSERT_EQ (info1, info2);
457  }
458  TEST (block_store, one_account)
459  {
460  	nano::logger_mt logger;
461  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
462  	ASSERT_TRUE (!store->init_error ());
463  	nano::account account{};
464  	nano::block_hash hash (0);
465  	auto transaction (store->tx_begin_write ());
466  	store->confirmation_height.put (transaction, account, { 20, nano::block_hash (15) });
467  	store->account.put (transaction, account, { hash, account, hash, 42, 100, 200, nano::epoch::epoch_0 });
468  	auto begin (store->account.begin (transaction));
469  	auto end (store->account.end ());
470  	ASSERT_NE (end, begin);
471  	ASSERT_EQ (account, nano::account (begin->first));
472  	nano::account_info info (begin->second);
473  	ASSERT_EQ (hash, info.head);
474  	ASSERT_EQ (42, info.balance.number ());
475  	ASSERT_EQ (100, info.modified);
476  	ASSERT_EQ (200, info.block_count);
477  	nano::confirmation_height_info confirmation_height_info;
478  	ASSERT_FALSE (store->confirmation_height.get (transaction, account, confirmation_height_info));
479  	ASSERT_EQ (20, confirmation_height_info.height);
480  	ASSERT_EQ (nano::block_hash (15), confirmation_height_info.frontier);
481  	++begin;
482  	ASSERT_EQ (end, begin);
483  }
484  TEST (block_store, two_block)
485  {
486  	nano::logger_mt logger;
487  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
488  	ASSERT_TRUE (!store->init_error ());
489  	nano::block_builder builder;
490  	auto block1 = builder
491  				  .open ()
492  				  .source (0)
493  				  .representative (1)
494  				  .account (1)
495  				  .sign (nano::keypair ().prv, 0)
496  				  .work (0)
497  				  .build ();
498  	block1->sideband_set ({});
499  	block1->hashables.account = 1;
500  	std::vector<nano::block_hash> hashes;
501  	std::vector<nano::open_block> blocks;
502  	hashes.push_back (block1->hash ());
503  	blocks.push_back (*block1);
504  	auto transaction (store->tx_begin_write ());
505  	store->block.put (transaction, hashes[0], *block1);
506  	auto block2 = builder
507  				  .open ()
508  				  .source (0)
509  				  .representative (1)
510  				  .account (2)
511  				  .sign (nano::keypair ().prv, 0)
512  				  .work (0)
513  				  .build ();
514  	block2->sideband_set ({});
515  	hashes.push_back (block2->hash ());
516  	blocks.push_back (*block2);
517  	store->block.put (transaction, hashes[1], *block2);
518  	ASSERT_TRUE (store->block.exists (transaction, block1->hash ()));
519  	ASSERT_TRUE (store->block.exists (transaction, block2->hash ()));
520  }
521  TEST (block_store, two_account)
522  {
523  	nano::logger_mt logger;
524  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
525  	ASSERT_TRUE (!store->init_error ());
526  	nano::account account1 (1);
527  	nano::block_hash hash1 (2);
528  	nano::account account2 (3);
529  	nano::block_hash hash2 (4);
530  	auto transaction (store->tx_begin_write ());
531  	store->confirmation_height.put (transaction, account1, { 20, nano::block_hash (10) });
532  	store->account.put (transaction, account1, { hash1, account1, hash1, 42, 100, 300, nano::epoch::epoch_0 });
533  	store->confirmation_height.put (transaction, account2, { 30, nano::block_hash (20) });
534  	store->account.put (transaction, account2, { hash2, account2, hash2, 84, 200, 400, nano::epoch::epoch_0 });
535  	auto begin (store->account.begin (transaction));
536  	auto end (store->account.end ());
537  	ASSERT_NE (end, begin);
538  	ASSERT_EQ (account1, nano::account (begin->first));
539  	nano::account_info info1 (begin->second);
540  	ASSERT_EQ (hash1, info1.head);
541  	ASSERT_EQ (42, info1.balance.number ());
542  	ASSERT_EQ (100, info1.modified);
543  	ASSERT_EQ (300, info1.block_count);
544  	nano::confirmation_height_info confirmation_height_info;
545  	ASSERT_FALSE (store->confirmation_height.get (transaction, account1, confirmation_height_info));
546  	ASSERT_EQ (20, confirmation_height_info.height);
547  	ASSERT_EQ (nano::block_hash (10), confirmation_height_info.frontier);
548  	++begin;
549  	ASSERT_NE (end, begin);
550  	ASSERT_EQ (account2, nano::account (begin->first));
551  	nano::account_info info2 (begin->second);
552  	ASSERT_EQ (hash2, info2.head);
553  	ASSERT_EQ (84, info2.balance.number ());
554  	ASSERT_EQ (200, info2.modified);
555  	ASSERT_EQ (400, info2.block_count);
556  	ASSERT_FALSE (store->confirmation_height.get (transaction, account2, confirmation_height_info));
557  	ASSERT_EQ (30, confirmation_height_info.height);
558  	ASSERT_EQ (nano::block_hash (20), confirmation_height_info.frontier);
559  	++begin;
560  	ASSERT_EQ (end, begin);
561  }
562  TEST (block_store, latest_find)
563  {
564  	nano::logger_mt logger;
565  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
566  	ASSERT_TRUE (!store->init_error ());
567  	nano::account account1 (1);
568  	nano::block_hash hash1 (2);
569  	nano::account account2 (3);
570  	nano::block_hash hash2 (4);
571  	auto transaction (store->tx_begin_write ());
572  	store->confirmation_height.put (transaction, account1, { 0, nano::block_hash (0) });
573  	store->account.put (transaction, account1, { hash1, account1, hash1, 100, 0, 300, nano::epoch::epoch_0 });
574  	store->confirmation_height.put (transaction, account2, { 0, nano::block_hash (0) });
575  	store->account.put (transaction, account2, { hash2, account2, hash2, 200, 0, 400, nano::epoch::epoch_0 });
576  	auto first (store->account.begin (transaction));
577  	auto second (store->account.begin (transaction));
578  	++second;
579  	auto find1 (store->account.begin (transaction, 1));
580  	ASSERT_EQ (first, find1);
581  	auto find2 (store->account.begin (transaction, 3));
582  	ASSERT_EQ (second, find2);
583  	auto find3 (store->account.begin (transaction, 2));
584  	ASSERT_EQ (second, find3);
585  }
586  namespace nano
587  {
588  namespace lmdb
589  {
590  	TEST (mdb_block_store, supported_version_upgrades)
591  	{
592  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
593  		{
594  			GTEST_SKIP ();
595  		}
596  		auto path (nano::unique_path () / "data.ldb");
597  		nano::logger_mt logger;
598  		{
599  			nano::lmdb::store store (logger, path, nano::dev::constants);
600  			nano::stats stats;
601  			nano::ledger ledger (store, stats, nano::dev::constants);
602  			auto transaction (store.tx_begin_write ());
603  			store.initialize (transaction, ledger.cache, nano::dev::constants);
604  			store.version.put (transaction, store.version_minimum - 1);
605  		}
606  		{
607  			nano::lmdb::store store (logger, path, nano::dev::constants);
608  			ASSERT_TRUE (store.init_error ());
609  		}
610  		auto path1 (nano::unique_path () / "data.ldb");
611  		{
612  			nano::lmdb::store store (logger, path1, nano::dev::constants);
613  			nano::stats stats;
614  			nano::ledger ledger (store, stats, nano::dev::constants);
615  			auto transaction (store.tx_begin_write ());
616  			store.initialize (transaction, ledger.cache, nano::dev::constants);
617  			store.version.put (transaction, store.version_minimum);
618  			store.confirmation_height.del (transaction, nano::dev::genesis->account ());
619  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "accounts_v1", MDB_CREATE,
620  			&store.account_store.accounts_v1_handle));
621  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "open", MDB_CREATE, &store.block_store.open_blocks_handle));
622  			modify_account_info_to_v14 (store, transaction, nano::dev::genesis->account (), 1,
623  			nano::dev::genesis->hash ());
624  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
625  		}
626  		{
627  			nano::lmdb::store store (logger, path1, nano::dev::constants);
628  			ASSERT_FALSE (store.init_error ());
629  		}
630  	}
631  }
632  }
633  TEST (mdb_block_store, bad_path)
634  {
635  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
636  	{
637  		GTEST_SKIP ();
638  	}
639  	nano::logger_mt logger;
640  	nano::lmdb::store store (logger, boost::filesystem::path ("&bsol;&bsol;/"), nano::dev::constants);
641  	ASSERT_TRUE (store.init_error ());
642  }
643  TEST (block_store, DISABLED_already_open) 
644  {
645  	auto path (nano::unique_path ());
646  	boost::filesystem::create_directories (path.parent_path ());
647  	nano::set_secure_perm_directory (path.parent_path ());
648  	std::ofstream file;
649  	file.open (path.string ().c_str ());
650  	ASSERT_TRUE (file.is_open ());
651  	nano::logger_mt logger;
652  	auto store = nano::make_store (logger, path, nano::dev::constants);
653  	ASSERT_TRUE (store->init_error ());
654  }
655  TEST (block_store, roots)
656  {
657  	nano::logger_mt logger;
658  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
659  	ASSERT_TRUE (!store->init_error ());
660  	nano::block_builder builder;
661  	auto send_block = builder
662  					  .send ()
663  					  .previous (0)
664  					  .destination (1)
665  					  .balance (2)
666  					  .sign (nano::keypair ().prv, 4)
667  					  .work (5)
668  					  .build ();
669  	ASSERT_EQ (send_block->hashables.previous, send_block->root ().as_block_hash ());
670  	auto change_block = builder
671  						.change ()
672  						.previous (0)
673  						.representative (1)
674  						.sign (nano::keypair ().prv, 3)
675  						.work (4)
676  						.build ();
677  	ASSERT_EQ (change_block->hashables.previous, change_block->root ().as_block_hash ());
678  	auto receive_block = builder
679  						 .receive ()
680  						 .previous (0)
681  						 .source (1)
682  						 .sign (nano::keypair ().prv, 3)
683  						 .work (4)
684  						 .build ();
685  	ASSERT_EQ (receive_block->hashables.previous, receive_block->root ().as_block_hash ());
686  	auto open_block = builder
687  					  .open ()
688  					  .source (0)
689  					  .representative (1)
690  					  .account (2)
691  					  .sign (nano::keypair ().prv, 4)
692  					  .work (5)
693  					  .build ();
694  	ASSERT_EQ (open_block->hashables.account, open_block->root ().as_account ());
695  }
696  TEST (block_store, pending_exists)
697  {
698  	nano::logger_mt logger;
699  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
700  	ASSERT_TRUE (!store->init_error ());
701  	nano::pending_key two (2, 0);
702  	nano::pending_info pending;
703  	auto transaction (store->tx_begin_write ());
704  	store->pending.put (transaction, two, pending);
705  	nano::pending_key one (1, 0);
706  	ASSERT_FALSE (store->pending.exists (transaction, one));
707  }
708  TEST (block_store, latest_exists)
709  {
710  	nano::logger_mt logger;
711  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
712  	ASSERT_TRUE (!store->init_error ());
713  	nano::account two (2);
714  	nano::account_info info;
715  	auto transaction (store->tx_begin_write ());
716  	store->confirmation_height.put (transaction, two, { 0, nano::block_hash (0) });
717  	store->account.put (transaction, two, info);
718  	nano::account one (1);
719  	ASSERT_FALSE (store->account.exists (transaction, one));
720  }
721  TEST (block_store, large_iteration)
722  {
723  	nano::logger_mt logger;
724  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
725  	ASSERT_TRUE (!store->init_error ());
726  	std::unordered_set<nano::account> accounts1;
727  	for (auto i (0); i < 1000; ++i)
728  	{
729  		auto transaction (store->tx_begin_write ());
730  		nano::account account;
731  		nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
732  		accounts1.insert (account);
733  		store->confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
734  		store->account.put (transaction, account, nano::account_info ());
735  	}
736  	std::unordered_set<nano::account> accounts2;
737  	nano::account previous{};
738  	auto transaction (store->tx_begin_read ());
739  	for (auto i (store->account.begin (transaction, 0)), n (store->account.end ()); i != n; ++i)
740  	{
741  		nano::account current (i->first);
742  		ASSERT_GT (current.number (), previous.number ());
743  		accounts2.insert (current);
744  		previous = current;
745  	}
746  	ASSERT_EQ (accounts1, accounts2);
747  	std::unordered_set<nano::account> accounts3;
748  	previous = std::numeric_limits<nano::uint256_t>::max ();
749  	for (auto i (store->account.rbegin (transaction)), n (store->account.end ()); i != n; --i)
750  	{
751  		nano::account current (i->first);
752  		ASSERT_LT (current.number (), previous.number ());
753  		accounts3.insert (current);
754  		previous = current;
755  	}
756  	ASSERT_EQ (accounts1, accounts3);
757  }
758  TEST (block_store, frontier)
759  {
760  	nano::logger_mt logger;
761  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
762  	ASSERT_TRUE (!store->init_error ());
763  	auto transaction (store->tx_begin_write ());
764  	nano::block_hash hash (100);
765  	nano::account account (200);
766  	ASSERT_TRUE (store->frontier.get (transaction, hash).is_zero ());
767  	store->frontier.put (transaction, hash, account);
768  	ASSERT_EQ (account, store->frontier.get (transaction, hash));
769  	store->frontier.del (transaction, hash);
770  	ASSERT_TRUE (store->frontier.get (transaction, hash).is_zero ());
771  }
772  TEST (block_store, block_replace)
773  {
774  	nano::logger_mt logger;
775  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
776  	ASSERT_TRUE (!store->init_error ());
777  	nano::block_builder builder;
778  	auto send1 = builder
779  				 .send ()
780  				 .previous (0)
781  				 .destination (0)
782  				 .balance (0)
783  				 .sign (nano::keypair ().prv, 0)
784  				 .work (1)
785  				 .build ();
786  	send1->sideband_set ({});
787  	auto send2 = builder
788  				 .send ()
789  				 .previous (0)
790  				 .destination (0)
791  				 .balance (0)
792  				 .sign (nano::keypair ().prv, 0)
793  				 .work (2)
794  				 .build ();
795  	send2->sideband_set ({});
796  	auto transaction (store->tx_begin_write ());
797  	store->block.put (transaction, 0, *send1);
798  	store->block.put (transaction, 0, *send2);
799  	auto block3 (store->block.get (transaction, 0));
800  	ASSERT_NE (nullptr, block3);
801  	ASSERT_EQ (2, block3->block_work ());
802  }
803  TEST (block_store, block_count)
804  {
805  	nano::logger_mt logger;
806  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
807  	ASSERT_TRUE (!store->init_error ());
808  	{
809  		auto transaction (store->tx_begin_write ());
810  		ASSERT_EQ (0, store->block.count (transaction));
811  		nano::block_builder builder;
812  		auto block = builder
813  					 .open ()
814  					 .source (0)
815  					 .representative (1)
816  					 .account (0)
817  					 .sign (nano::keypair ().prv, 0)
818  					 .work (0)
819  					 .build ();
820  		block->sideband_set ({});
821  		auto hash1 (block->hash ());
822  		store->block.put (transaction, hash1, *block);
823  	}
824  	auto transaction (store->tx_begin_read ());
825  	ASSERT_EQ (1, store->block.count (transaction));
826  }
827  TEST (block_store, account_count)
828  {
829  	nano::logger_mt logger;
830  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
831  	ASSERT_TRUE (!store->init_error ());
832  	{
833  		auto transaction (store->tx_begin_write ());
834  		ASSERT_EQ (0, store->account.count (transaction));
835  		nano::account account (200);
836  		store->confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
837  		store->account.put (transaction, account, nano::account_info ());
838  	}
839  	auto transaction (store->tx_begin_read ());
840  	ASSERT_EQ (1, store->account.count (transaction));
841  }
842  TEST (block_store, cemented_count_cache)
843  {
844  	nano::logger_mt logger;
845  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
846  	ASSERT_TRUE (!store->init_error ());
847  	auto transaction (store->tx_begin_write ());
848  	nano::ledger_cache ledger_cache;
849  	store->initialize (transaction, ledger_cache, nano::dev::constants);
850  	ASSERT_EQ (1, ledger_cache.cemented_count);
851  }
852  TEST (block_store, block_random)
853  {
854  	nano::logger_mt logger;
855  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
856  	{
857  		nano::ledger_cache ledger_cache;
858  		auto transaction (store->tx_begin_write ());
859  		store->initialize (transaction, ledger_cache, nano::dev::constants);
860  	}
861  	auto transaction (store->tx_begin_read ());
862  	auto block (store->block.random (transaction));
863  	ASSERT_NE (nullptr, block);
864  	ASSERT_EQ (*block, *nano::dev::genesis);
865  }
866  TEST (block_store, pruned_random)
867  {
868  	nano::logger_mt logger;
869  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
870  	ASSERT_TRUE (!store->init_error ());
871  	nano::block_builder builder;
872  	auto block = builder
873  				 .open ()
874  				 .source (0)
875  				 .representative (1)
876  				 .account (0)
877  				 .sign (nano::keypair ().prv, 0)
878  				 .work (0)
879  				 .build ();
880  	block->sideband_set ({});
881  	auto hash1 (block->hash ());
882  	{
883  		nano::ledger_cache ledger_cache;
884  		auto transaction (store->tx_begin_write ());
885  		store->initialize (transaction, ledger_cache, nano::dev::constants);
886  		store->pruned.put (transaction, hash1);
887  	}
888  	auto transaction (store->tx_begin_read ());
889  	auto random_hash (store->pruned.random (transaction));
890  	ASSERT_EQ (hash1, random_hash);
891  }
892  TEST (block_store, state_block)
893  {
894  	nano::logger_mt logger;
895  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
896  	ASSERT_FALSE (store->init_error ());
897  	nano::keypair key1;
898  	nano::block_builder builder;
899  	auto block1 = builder
900  				  .state ()
901  				  .account (1)
902  				  .previous (nano::dev::genesis->hash ())
903  				  .representative (3)
904  				  .balance (4)
905  				  .link (6)
906  				  .sign (key1.prv, key1.pub)
907  				  .work (7)
908  				  .build ();
909  	block1->sideband_set ({});
910  	{
911  		nano::ledger_cache ledger_cache;
912  		auto transaction (store->tx_begin_write ());
913  		store->initialize (transaction, ledger_cache, nano::dev::constants);
914  		ASSERT_EQ (nano::block_type::state, block1->type ());
915  		store->block.put (transaction, block1->hash (), *block1);
916  		ASSERT_TRUE (store->block.exists (transaction, block1->hash ()));
917  		auto block2 (store->block.get (transaction, block1->hash ()));
918  		ASSERT_NE (nullptr, block2);
919  		ASSERT_EQ (*block1, *block2);
920  	}
921  	{
922  		auto transaction (store->tx_begin_write ());
923  		auto count (store->block.count (transaction));
924  		ASSERT_EQ (2, count);
925  		store->block.del (transaction, block1->hash ());
926  		ASSERT_FALSE (store->block.exists (transaction, block1->hash ()));
927  	}
928  	auto transaction (store->tx_begin_read ());
929  	auto count2 (store->block.count (transaction));
930  	ASSERT_EQ (1, count2);
931  }
932  TEST (mdb_block_store, sideband_height)
933  {
934  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
935  	{
936  		GTEST_SKIP ();
937  	}
938  	nano::logger_mt logger;
939  	nano::keypair key1;
940  	nano::keypair key2;
941  	nano::keypair key3;
942  	nano::lmdb::store store (logger, nano::unique_path () / "data.ldb", nano::dev::constants);
943  	ASSERT_FALSE (store.init_error ());
944  	nano::stats stats;
945  	nano::ledger ledger (store, stats, nano::dev::constants);
946  	nano::block_builder builder;
947  	auto transaction (store.tx_begin_write ());
948  	store.initialize (transaction, ledger.cache, nano::dev::constants);
949  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
950  	auto send = builder
951  				.send ()
952  				.previous (nano::dev::genesis->hash ())
953  				.destination (nano::dev::genesis_key.pub)
954  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
955  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
956  				.work (*pool.generate (nano::dev::genesis->hash ()))
957  				.build ();
958  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
959  	auto receive = builder
960  				   .receive ()
961  				   .previous (send->hash ())
962  				   .source (send->hash ())
963  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
964  				   .work (*pool.generate (send->hash ()))
965  				   .build ();
966  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
967  	auto change = builder
968  				  .change ()
969  				  .previous (receive->hash ())
970  				  .representative (0)
971  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
972  				  .work (*pool.generate (receive->hash ()))
973  				  .build ();
974  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
975  	auto state_send1 = builder
976  					   .state ()
977  					   .account (nano::dev::genesis_key.pub)
978  					   .previous (change->hash ())
979  					   .representative (0)
980  					   .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
981  					   .link (key1.pub)
982  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
983  					   .work (*pool.generate (change->hash ()))
984  					   .build ();
985  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send1).code);
986  	auto state_send2 = builder
987  					   .state ()
988  					   .account (nano::dev::genesis_key.pub)
989  					   .previous (state_send1->hash ())
990  					   .representative (0)
991  					   .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
992  					   .link (key2.pub)
993  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
994  					   .work (*pool.generate (state_send1->hash ()))
995  					   .build ();
996  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send2).code);
997  	auto state_send3 = builder
998  					   .state ()
999  					   .account (nano::dev::genesis_key.pub)
1000  					   .previous (state_send2->hash ())
1001  					   .representative (0)
1002  					   .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
1003  					   .link (key3.pub)
1004  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1005  					   .work (*pool.generate (state_send2->hash ()))
1006  					   .build ();
1007  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send3).code);
1008  	auto state_open = builder
1009  					  .state ()
1010  					  .account (key1.pub)
1011  					  .previous (0)
1012  					  .representative (0)
1013  					  .balance (nano::Gxrb_ratio)
1014  					  .link (state_send1->hash ())
1015  					  .sign (key1.prv, key1.pub)
1016  					  .work (*pool.generate (key1.pub))
1017  					  .build ();
1018  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1019  	auto epoch = builder
1020  				 .state ()
1021  				 .account (key1.pub)
1022  				 .previous (state_open->hash ())
1023  				 .representative (0)
1024  				 .balance (nano::Gxrb_ratio)
1025  				 .link (ledger.epoch_link (nano::epoch::epoch_1))
1026  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1027  				 .work (*pool.generate (state_open->hash ()))
1028  				 .build ();
1029  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1030  	ASSERT_EQ (nano::epoch::epoch_1, store.block.version (transaction, epoch->hash ()));
1031  	auto epoch_open = builder
1032  					  .state ()
1033  					  .account (key2.pub)
1034  					  .previous (0)
1035  					  .representative (0)
1036  					  .balance (0)
1037  					  .link (ledger.epoch_link (nano::epoch::epoch_1))
1038  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1039  					  .work (*pool.generate (key2.pub))
1040  					  .build ();
1041  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch_open).code);
1042  	ASSERT_EQ (nano::epoch::epoch_1, store.block.version (transaction, epoch_open->hash ()));
1043  	auto state_receive = builder
1044  						 .state ()
1045  						 .account (key2.pub)
1046  						 .previous (epoch_open->hash ())
1047  						 .representative (0)
1048  						 .balance (nano::Gxrb_ratio)
1049  						 .link (state_send2->hash ())
1050  						 .sign (key2.prv, key2.pub)
1051  						 .work (*pool.generate (epoch_open->hash ()))
1052  						 .build ();
1053  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive).code);
1054  	auto open = builder
1055  				.open ()
1056  				.source (state_send3->hash ())
1057  				.representative (nano::dev::genesis_key.pub)
1058  				.account (key3.pub)
1059  				.sign (key3.prv, key3.pub)
1060  				.work (*pool.generate (key3.pub))
1061  				.build ();
1062  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1063  	auto block1 (store.block.get (transaction, nano::dev::genesis->hash ()));
1064  	ASSERT_EQ (block1->sideband ().height, 1);
1065  	auto block2 (store.block.get (transaction, send->hash ()));
1066  	ASSERT_EQ (block2->sideband ().height, 2);
1067  	auto block3 (store.block.get (transaction, receive->hash ()));
1068  	ASSERT_EQ (block3->sideband ().height, 3);
1069  	auto block4 (store.block.get (transaction, change->hash ()));
1070  	ASSERT_EQ (block4->sideband ().height, 4);
1071  	auto block5 (store.block.get (transaction, state_send1->hash ()));
1072  	ASSERT_EQ (block5->sideband ().height, 5);
1073  	auto block6 (store.block.get (transaction, state_send2->hash ()));
1074  	ASSERT_EQ (block6->sideband ().height, 6);
1075  	auto block7 (store.block.get (transaction, state_send3->hash ()));
1076  	ASSERT_EQ (block7->sideband ().height, 7);
1077  	auto block8 (store.block.get (transaction, state_open->hash ()));
1078  	ASSERT_EQ (block8->sideband ().height, 1);
1079  	auto block9 (store.block.get (transaction, epoch->hash ()));
1080  	ASSERT_EQ (block9->sideband ().height, 2);
1081  	auto block10 (store.block.get (transaction, epoch_open->hash ()));
1082  	ASSERT_EQ (block10->sideband ().height, 1);
1083  	auto block11 (store.block.get (transaction, state_receive->hash ()));
1084  	ASSERT_EQ (block11->sideband ().height, 2);
1085  	auto block12 (store.block.get (transaction, open->hash ()));
1086  	ASSERT_EQ (block12->sideband ().height, 1);
1087  }
1088  TEST (block_store, peers)
1089  {
1090  	nano::logger_mt logger;
1091  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1092  	ASSERT_TRUE (!store->init_error ());
1093  	nano::endpoint_key endpoint (boost::asio::ip::address_v6::any ().to_bytes (), 100);
1094  	{
1095  		auto transaction (store->tx_begin_write ());
1096  		ASSERT_FALSE (store->peer.exists (transaction, endpoint));
1097  		ASSERT_EQ (store->peer.count (transaction), 0);
1098  		store->peer.put (transaction, endpoint);
1099  		ASSERT_TRUE (store->peer.exists (transaction, endpoint));
1100  	}
1101  	{
1102  		auto transaction (store->tx_begin_read ());
1103  		ASSERT_EQ (store->peer.count (transaction), 1);
1104  	}
1105  	nano::endpoint_key endpoint1 (boost::asio::ip::address_v6::any ().to_bytes (), 101);
1106  	{
1107  		auto transaction (store->tx_begin_write ());
1108  		store->peer.put (transaction, endpoint1);
1109  		ASSERT_TRUE (store->peer.exists (transaction, endpoint1)); 
1110  		ASSERT_TRUE (store->peer.exists (transaction, endpoint)); 
1111  	}
1112  	{
1113  		auto transaction (store->tx_begin_read ());
1114  		ASSERT_EQ (store->peer.count (transaction), 2);
1115  	}
1116  	{
1117  		auto transaction (store->tx_begin_write ());
1118  		store->peer.del (transaction, endpoint1);
1119  		ASSERT_FALSE (store->peer.exists (transaction, endpoint1)); 
1120  		ASSERT_TRUE (store->peer.exists (transaction, endpoint)); 
1121  	}
1122  	{
1123  		auto transaction (store->tx_begin_read ());
1124  		ASSERT_EQ (store->peer.count (transaction), 1);
1125  	}
1126  	{
1127  		auto transaction (store->tx_begin_write ());
1128  		store->peer.del (transaction, endpoint);
1129  		ASSERT_FALSE (store->peer.exists (transaction, endpoint));
1130  	}
1131  	{
1132  		auto transaction (store->tx_begin_read ());
1133  		ASSERT_EQ (store->peer.count (transaction), 0);
1134  	}
1135  }
1136  TEST (block_store, endpoint_key_byte_order)
1137  {
1138  	boost::asio::ip::address_v6 address (boost::asio::ip::make_address_v6 ("::ffff:127.0.0.1"));
1139  	uint16_t port = 100;
1140  	nano::endpoint_key endpoint_key (address.to_bytes (), port);
1141  	std::vector<uint8_t> bytes;
1142  	{
1143  		nano::vectorstream stream (bytes);
1144  		nano::write (stream, endpoint_key);
1145  	}
1146  	ASSERT_EQ (bytes.size (), 18);
1147  	ASSERT_EQ (bytes[10], 0xff);
1148  	ASSERT_EQ (bytes[11], 0xff);
1149  	ASSERT_EQ (bytes[12], 127);
1150  	ASSERT_EQ (bytes[bytes.size () - 2], 0);
1151  	ASSERT_EQ (bytes.back (), 100);
1152  	nano::bufferstream stream1 (bytes.data (), bytes.size ());
1153  	nano::endpoint_key endpoint_key1;
1154  	nano::read (stream1, endpoint_key1);
1155  	ASSERT_EQ (address.to_bytes (), endpoint_key1.address_bytes ());
1156  	ASSERT_EQ (port, endpoint_key1.port ());
1157  }
1158  TEST (block_store, online_weight)
1159  {
1160  	nano::logger_mt logger;
1161  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1162  	ASSERT_FALSE (store->init_error ());
1163  	{
1164  		auto transaction (store->tx_begin_write ());
1165  		ASSERT_EQ (0, store->online_weight.count (transaction));
1166  		ASSERT_EQ (store->online_weight.end (), store->online_weight.begin (transaction));
1167  		ASSERT_EQ (store->online_weight.end (), store->online_weight.rbegin (transaction));
1168  		store->online_weight.put (transaction, 1, 2);
1169  		store->online_weight.put (transaction, 3, 4);
1170  	}
1171  	{
1172  		auto transaction (store->tx_begin_write ());
1173  		ASSERT_EQ (2, store->online_weight.count (transaction));
1174  		auto item (store->online_weight.begin (transaction));
1175  		ASSERT_NE (store->online_weight.end (), item);
1176  		ASSERT_EQ (1, item->first);
1177  		ASSERT_EQ (2, item->second.number ());
1178  		auto item_last (store->online_weight.rbegin (transaction));
1179  		ASSERT_NE (store->online_weight.end (), item_last);
1180  		ASSERT_EQ (3, item_last->first);
1181  		ASSERT_EQ (4, item_last->second.number ());
1182  		store->online_weight.del (transaction, 1);
1183  		ASSERT_EQ (1, store->online_weight.count (transaction));
1184  		ASSERT_EQ (store->online_weight.begin (transaction), store->online_weight.rbegin (transaction));
1185  		store->online_weight.del (transaction, 3);
1186  	}
1187  	auto transaction (store->tx_begin_read ());
1188  	ASSERT_EQ (0, store->online_weight.count (transaction));
1189  	ASSERT_EQ (store->online_weight.end (), store->online_weight.begin (transaction));
1190  	ASSERT_EQ (store->online_weight.end (), store->online_weight.rbegin (transaction));
1191  }
1192  TEST (block_store, pruned_blocks)
1193  {
1194  	nano::logger_mt logger;
1195  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1196  	ASSERT_TRUE (!store->init_error ());
1197  	nano::keypair key1;
1198  	nano::block_builder builder;
1199  	auto block1 = builder
1200  				  .open ()
1201  				  .source (0)
1202  				  .representative (1)
1203  				  .account (key1.pub)
1204  				  .sign (key1.prv, key1.pub)
1205  				  .work (0)
1206  				  .build ();
1207  	auto hash1 (block1->hash ());
1208  	{
1209  		auto transaction (store->tx_begin_write ());
1210  		ASSERT_FALSE (store->pruned.exists (transaction, hash1));
1211  		ASSERT_EQ (store->pruned.count (transaction), 0);
1212  		store->pruned.put (transaction, hash1);
1213  		ASSERT_TRUE (store->pruned.exists (transaction, hash1));
1214  	}
1215  	ASSERT_EQ (store->pruned.count (store->tx_begin_read ()), 1);
1216  	auto block2 = builder
1217  				  .open ()
1218  				  .source (1)
1219  				  .representative (2)
1220  				  .account (key1.pub)
1221  				  .sign (key1.prv, key1.pub)
1222  				  .work (0)
1223  				  .build ();
1224  	block2->sideband_set ({});
1225  	auto hash2 (block2->hash ());
1226  	{
1227  		auto transaction (store->tx_begin_write ());
1228  		store->pruned.put (transaction, hash2);
1229  		ASSERT_TRUE (store->pruned.exists (transaction, hash2)); 
1230  		ASSERT_FALSE (store->block.exists (transaction, hash2));
1231  		ASSERT_TRUE (store->pruned.exists (transaction, hash1)); 
1232  		ASSERT_FALSE (store->block.exists (transaction, hash1));
1233  	}
1234  	ASSERT_EQ (store->pruned.count (store->tx_begin_read ()), 2);
1235  	{
1236  		auto transaction (store->tx_begin_write ());
1237  		store->pruned.del (transaction, hash2);
1238  		ASSERT_FALSE (store->pruned.exists (transaction, hash2)); 
1239  		ASSERT_FALSE (store->block.exists (transaction, hash2)); 
1240  		store->block.put (transaction, hash2, *block2); 
1241  		ASSERT_TRUE (store->block.exists (transaction, hash2));
1242  		ASSERT_TRUE (store->pruned.exists (transaction, hash1)); 
1243  		ASSERT_FALSE (store->block.exists (transaction, hash1));
1244  	}
1245  	ASSERT_EQ (store->pruned.count (store->tx_begin_read ()), 1);
1246  	{
1247  		auto transaction (store->tx_begin_write ());
1248  		store->pruned.del (transaction, hash1);
1249  		ASSERT_FALSE (store->pruned.exists (transaction, hash1));
1250  	}
1251  	ASSERT_EQ (store->pruned.count (store->tx_begin_read ()), 0);
1252  }
1253  namespace nano
1254  {
1255  namespace lmdb
1256  {
1257  	TEST (mdb_block_store, upgrade_v14_v15)
1258  	{
1259  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1260  		{
1261  			GTEST_SKIP ();
1262  		}
1263  		auto path (nano::unique_path () / "data.ldb");
1264  		nano::block_builder builder;
1265  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1266  		auto send = builder
1267  					.send ()
1268  					.previous (nano::dev::genesis->hash ())
1269  					.destination (nano::dev::genesis_key.pub)
1270  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1271  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1272  					.work (*pool.generate (nano::dev::genesis->hash ()))
1273  					.build ();
1274  		auto epoch = builder
1275  					 .state ()
1276  					 .account (nano::dev::genesis_key.pub)
1277  					 .previous (send->hash ())
1278  					 .representative (nano::dev::genesis_key.pub)
1279  					 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1280  					 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1281  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1282  					 .work (*pool.generate (send->hash ()))
1283  					 .build ();
1284  		auto state_send = builder
1285  						  .state ()
1286  						  .account (nano::dev::genesis_key.pub)
1287  						  .previous (epoch->hash ())
1288  						  .representative (nano::dev::genesis_key.pub)
1289  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
1290  						  .link (nano::dev::genesis_key.pub)
1291  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1292  						  .work (*pool.generate (epoch->hash ()))
1293  						  .build ();
1294  		{
1295  			nano::logger_mt logger;
1296  			nano::lmdb::store store (logger, path, nano::dev::constants);
1297  			nano::stats stats;
1298  			nano::ledger ledger (store, stats, nano::dev::constants);
1299  			auto transaction (store.tx_begin_write ());
1300  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1301  			auto account_info = ledger.account_info (transaction, nano::dev::genesis->account ());
1302  			ASSERT_TRUE (account_info);
1303  			nano::confirmation_height_info confirmation_height_info;
1304  			ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis->account (),
1305  			confirmation_height_info));
1306  			ASSERT_EQ (confirmation_height_info.height, 1);
1307  			ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis->hash ());
1308  			ASSERT_FALSE (
1309  			mdb_dbi_open (store.env.tx (transaction), "state_v1", MDB_CREATE, &store.block_store.state_blocks_v1_handle));
1310  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "accounts_v1", MDB_CREATE,
1311  			&store.account_store.accounts_v1_handle));
1312  			ASSERT_FALSE (
1313  			mdb_dbi_open (store.env.tx (transaction), "pending_v1", MDB_CREATE, &store.pending_store.pending_v1_handle));
1314  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "open", MDB_CREATE, &store.block_store.open_blocks_handle));
1315  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "send", MDB_CREATE, &store.block_store.send_blocks_handle));
1316  			ASSERT_FALSE (
1317  			mdb_dbi_open (store.env.tx (transaction), "state_blocks", MDB_CREATE,
1318  			&store.block_store.state_blocks_handle));
1319  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1320  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1321  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1322  			store.version.put (transaction, 14);
1323  			store.confirmation_height.del (transaction, nano::dev::genesis->account ());
1324  			modify_account_info_to_v14 (store, transaction, nano::dev::genesis->account (),
1325  			confirmation_height_info.height, state_send->hash ());
1326  			store.pending.del (transaction, nano::pending_key (nano::dev::genesis->account (), state_send->hash ()));
1327  			write_sideband_v14 (store, transaction, *state_send, store.block_store.state_blocks_v1_handle);
1328  			write_sideband_v14 (store, transaction, *epoch, store.block_store.state_blocks_v1_handle);
1329  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1330  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send);
1331  			store.block.del (transaction, state_send->hash ());
1332  			store.block.del (transaction, epoch->hash ());
1333  			ASSERT_FALSE (mdb_put (store.env.tx (transaction), store.pending_store.pending_v0_handle,
1334  			nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, send->hash ())),
1335  			nano::mdb_val (
1336  			nano::pending_info_v14 (nano::dev::genesis->account (), nano::Gxrb_ratio,
1337  			nano::epoch::epoch_0)),
1338  			0));
1339  			ASSERT_FALSE (mdb_put (store.env.tx (transaction), store.pending_store.pending_v1_handle,
1340  			nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, state_send->hash ())),
1341  			nano::mdb_val (
1342  			nano::pending_info_v14 (nano::dev::genesis->account (), nano::Gxrb_ratio,
1343  			nano::epoch::epoch_1)),
1344  			0));
1345  			nano::mdb_val value;
1346  			ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.account_store.accounts_v1_handle,
1347  			nano::mdb_val (nano::dev::genesis->account ()), value));
1348  			nano::account_info info;
1349  			ASSERT_NE (value.size (), info.db_size ());
1350  			store.account.del (transaction, nano::dev::genesis->account ());
1351  			ASSERT_TRUE (mdb_get (store.env.tx (transaction), store.confirmation_height_store.confirmation_height_handle,
1352  			nano::mdb_val (nano::dev::genesis->account ()), value));
1353  		}
1354  		nano::logger_mt logger;
1355  		nano::lmdb::store store (logger, path, nano::dev::constants);
1356  		ASSERT_FALSE (store.init_error ());
1357  		auto transaction (store.tx_begin_read ());
1358  		nano::mdb_val value;
1359  		ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.account_store.accounts_handle,
1360  		nano::mdb_val (nano::dev::genesis->account ()), value));
1361  		nano::account_info info (value);
1362  		ASSERT_EQ (value.size (), info.db_size ());
1363  		nano::confirmation_height_info confirmation_height_info;
1364  		ASSERT_FALSE (
1365  		store.confirmation_height.get (transaction, nano::dev::genesis->account (),
1366  		confirmation_height_info));
1367  		ASSERT_EQ (confirmation_height_info.height, 1);
1368  		ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis->hash ());
1369  		auto error_get_accounts_v1 (mdb_get (store.env.tx (transaction), store.account_store.accounts_v1_handle,
1370  		nano::mdb_val (nano::dev::genesis->account ()), value));
1371  		ASSERT_NE (error_get_accounts_v1, MDB_SUCCESS);
1372  		auto error_get_pending_v1 (mdb_get (store.env.tx (transaction), store.pending_store.pending_v1_handle, nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, state_send->hash ())), value));
1373  		ASSERT_NE (error_get_pending_v1, MDB_SUCCESS);
1374  		auto error_get_state_v1 (
1375  		mdb_get (store.env.tx (transaction), store.block_store.state_blocks_v1_handle, nano::mdb_val (state_send->hash ()),
1376  		value));
1377  		ASSERT_NE (error_get_state_v1, MDB_SUCCESS);
1378  		auto block = store.block.get (transaction, state_send->hash ());
1379  		ASSERT_NE (block, nullptr);
1380  		ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1381  		block = store.block.get (transaction, send->hash ());
1382  		ASSERT_NE (block, nullptr);
1383  		ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_0);
1384  		ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1385  		nano::pending_info pending_info;
1386  		store.pending.get (transaction, nano::pending_key (nano::dev::genesis_key.pub, send->hash ()), pending_info);
1387  		ASSERT_EQ (pending_info.epoch, nano::epoch::epoch_0);
1388  		store.pending.get (transaction, nano::pending_key (nano::dev::genesis_key.pub, state_send->hash ()),
1389  		pending_info);
1390  		ASSERT_EQ (pending_info.epoch, nano::epoch::epoch_1);
1391  		ASSERT_LT (14, store.version.get (transaction));
1392  	}
1393  	TEST (mdb_block_store, upgrade_v15_v16)
1394  	{
1395  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1396  		{
1397  			GTEST_SKIP ();
1398  		}
1399  		auto path (nano::unique_path () / "data.ldb");
1400  		nano::mdb_val value;
1401  		{
1402  			nano::logger_mt logger;
1403  			nano::lmdb::store store (logger, path, nano::dev::constants);
1404  			nano::stats stats;
1405  			nano::ledger ledger (store, stats, nano::dev::constants);
1406  			auto transaction (store.tx_begin_write ());
1407  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1408  			auto txn = store.env.tx (transaction);
1409  			ASSERT_FALSE (
1410  			mdb_dbi_open (txn, "representation", MDB_CREATE, &store.account_store.representation_handle));
1411  			auto weight = ledger.cache.rep_weights.representation_get (nano::dev::genesis->account ());
1412  			ASSERT_EQ (MDB_SUCCESS, mdb_put (txn, store.account_store.representation_handle, nano::mdb_val (nano::dev::genesis->account ()), nano::mdb_val (nano::uint128_union (weight)), 0));
1413  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "open", MDB_CREATE, &store.block_store.open_blocks_handle));
1414  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1415  			store.version.put (transaction, 15);
1416  			ASSERT_EQ (MDB_SUCCESS, mdb_get (store.env.tx (transaction), store.account_store.representation_handle, nano::mdb_val (nano::dev::genesis->account ()), value));
1417  			store.confirmation_height.del (transaction, nano::dev::genesis->account ());
1418  		}
1419  		nano::logger_mt logger;
1420  		nano::lmdb::store store (logger, path, nano::dev::constants);
1421  		ASSERT_FALSE (store.init_error ());
1422  		auto transaction (store.tx_begin_read ());
1423  		auto error_get_representation (mdb_get (store.env.tx (transaction), store.account_store.representation_handle,
1424  		nano::mdb_val (nano::dev::genesis->account ()), value));
1425  		ASSERT_NE (MDB_SUCCESS, error_get_representation);
1426  		ASSERT_EQ (store.account_store.representation_handle, 0);
1427  		ASSERT_LT (15, store.version.get (transaction));
1428  	}
1429  	TEST (mdb_block_store, upgrade_v16_v17)
1430  	{
1431  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1432  		{
1433  			GTEST_SKIP ();
1434  		}
1435  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1436  		nano::block_builder builder;
1437  		auto block1 = builder
1438  					  .state ()
1439  					  .account (nano::dev::genesis_key.pub)
1440  					  .previous (nano::dev::genesis->hash ())
1441  					  .representative (nano::dev::genesis_key.pub)
1442  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1443  					  .link (nano::dev::genesis_key.pub)
1444  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1445  					  .work (*pool.generate (nano::dev::genesis->hash ()))
1446  					  .build ();
1447  		auto block2 = builder
1448  					  .state ()
1449  					  .account (nano::dev::genesis_key.pub)
1450  					  .previous (block1->hash ())
1451  					  .representative (nano::dev::genesis_key.pub)
1452  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
1453  					  .link (nano::dev::genesis_key.pub)
1454  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1455  					  .work (*pool.generate (block1->hash ()))
1456  					  .build ();
1457  		auto block3 = builder
1458  					  .state ()
1459  					  .account (nano::dev::genesis_key.pub)
1460  					  .previous (block2->hash ())
1461  					  .representative (nano::dev::genesis_key.pub)
1462  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 2)
1463  					  .link (nano::dev::genesis_key.pub)
1464  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1465  					  .work (*pool.generate (block2->hash ()))
1466  					  .build ();
1467  		auto code = [&block1, &block2, &block3] (auto confirmation_height, nano::block_hash const & expected_cemented_frontier) {
1468  			auto path (nano::unique_path () / "data.ldb");
1469  			nano::mdb_val value;
1470  			{
1471  				nano::logger_mt logger;
1472  				nano::lmdb::store store (logger, path, nano::dev::constants);
1473  				nano::stats stats;
1474  				nano::ledger ledger (store, stats, nano::dev::constants);
1475  				auto transaction (store.tx_begin_write ());
1476  				store.initialize (transaction, ledger.cache, nano::dev::constants);
1477  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1478  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
1479  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
1480  				modify_confirmation_height_to_v15 (store, transaction, nano::dev::genesis->account (), confirmation_height);
1481  				ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "open", MDB_CREATE, &store.block_store.open_blocks_handle));
1482  				write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1483  				ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "state_blocks", MDB_CREATE, &store.block_store.state_blocks_handle));
1484  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block1);
1485  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block2);
1486  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block3);
1487  				store.version.put (transaction, 16);
1488  			}
1489  			nano::logger_mt logger;
1490  			nano::lmdb::store store (logger, path, nano::dev::constants);
1491  			ASSERT_FALSE (store.init_error ());
1492  			auto transaction (store.tx_begin_read ());
1493  			nano::confirmation_height_info confirmation_height_info;
1494  			ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis->account (), confirmation_height_info));
1495  			ASSERT_EQ (confirmation_height_info.height, confirmation_height);
1496  			ASSERT_EQ (confirmation_height_info.frontier, expected_cemented_frontier);
1497  			ASSERT_LT (16, store.version.get (transaction));
1498  		};
1499  		code (0, nano::block_hash (0));
1500  		code (1, nano::dev::genesis->hash ());
1501  		code (2, block1->hash ());
1502  		code (3, block2->hash ());
1503  		code (4, block3->hash ());
1504  	}
1505  	TEST (mdb_block_store, upgrade_v17_v18)
1506  	{
1507  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1508  		{
1509  			GTEST_SKIP ();
1510  		}
1511  		auto path (nano::unique_path () / "data.ldb");
1512  		nano::block_builder builder;
1513  		nano::keypair key1;
1514  		nano::keypair key2;
1515  		nano::keypair key3;
1516  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1517  		auto send_zero = builder
1518  						 .send ()
1519  						 .previous (nano::dev::genesis->hash ())
1520  						 .destination (nano::dev::genesis_key.pub)
1521  						 .balance (nano::dev::constants.genesis_amount)
1522  						 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1523  						 .work (*pool.generate (nano::dev::genesis->hash ()))
1524  						 .build ();
1525  		auto state_receive_zero = builder
1526  								  .state ()
1527  								  .account (nano::dev::genesis_key.pub)
1528  								  .previous (send_zero->hash ())
1529  								  .representative (nano::dev::genesis_key.pub)
1530  								  .balance (nano::dev::constants.genesis_amount)
1531  								  .link (send_zero->hash ())
1532  								  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1533  								  .work (*pool.generate (send_zero->hash ()))
1534  								  .build ();
1535  		auto epoch = builder
1536  					 .state ()
1537  					 .account (nano::dev::genesis_key.pub)
1538  					 .previous (state_receive_zero->hash ())
1539  					 .representative (nano::dev::genesis_key.pub)
1540  					 .balance (nano::dev::constants.genesis_amount)
1541  					 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1542  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1543  					 .work (*pool.generate (state_receive_zero->hash ()))
1544  					 .build ();
1545  		auto state_send = builder
1546  						  .state ()
1547  						  .account (nano::dev::genesis_key.pub)
1548  						  .previous (epoch->hash ())
1549  						  .representative (nano::dev::genesis_key.pub)
1550  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1551  						  .link (nano::dev::genesis_key.pub)
1552  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1553  						  .work (*pool.generate (epoch->hash ()))
1554  						  .build ();
1555  		auto state_receive = builder
1556  							 .state ()
1557  							 .account (nano::dev::genesis_key.pub)
1558  							 .previous (state_send->hash ())
1559  							 .representative (nano::dev::genesis_key.pub)
1560  							 .balance (nano::dev::constants.genesis_amount)
1561  							 .link (state_send->hash ())
1562  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1563  							 .work (*pool.generate (state_send->hash ()))
1564  							 .build ();
1565  		auto state_change = builder
1566  							.state ()
1567  							.account (nano::dev::genesis_key.pub)
1568  							.previous (state_receive->hash ())
1569  							.representative (nano::dev::genesis_key.pub)
1570  							.balance (nano::dev::constants.genesis_amount)
1571  							.link (0)
1572  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1573  							.work (*pool.generate (state_receive->hash ()))
1574  							.build ();
1575  		auto state_send_change = builder
1576  								 .state ()
1577  								 .account (nano::dev::genesis_key.pub)
1578  								 .previous (state_change->hash ())
1579  								 .representative (key1.pub)
1580  								 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1581  								 .link (key1.pub)
1582  								 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1583  								 .work (*pool.generate (state_change->hash ()))
1584  								 .build ();
1585  		auto epoch_first = builder
1586  						   .state ()
1587  						   .account (key1.pub)
1588  						   .previous (0)
1589  						   .representative (0)
1590  						   .balance (0)
1591  						   .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_2))
1592  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1593  						   .work (*pool.generate (key1.pub))
1594  						   .build ();
1595  		auto state_receive2 = builder
1596  							  .state ()
1597  							  .account (key1.pub)
1598  							  .previous (epoch_first->hash ())
1599  							  .representative (key1.pub)
1600  							  .balance (nano::Gxrb_ratio)
1601  							  .link (state_send_change->hash ())
1602  							  .sign (key1.prv, key1.pub)
1603  							  .work (*pool.generate (epoch_first->hash ()))
1604  							  .build ();
1605  		auto state_send2 = builder
1606  						   .state ()
1607  						   .account (nano::dev::genesis_key.pub)
1608  						   .previous (state_send_change->hash ())
1609  						   .representative (key1.pub)
1610  						   .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
1611  						   .link (key2.pub)
1612  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1613  						   .work (*pool.generate (state_send_change->hash ()))
1614  						   .build ();
1615  		auto state_open = builder
1616  						  .state ()
1617  						  .account (key2.pub)
1618  						  .previous (0)
1619  						  .representative (key2.pub)
1620  						  .balance (nano::Gxrb_ratio)
1621  						  .link (state_send2->hash ())
1622  						  .sign (key2.prv, key2.pub)
1623  						  .work (*pool.generate (key2.pub))
1624  						  .build ();
1625  		auto state_send_epoch_link = builder
1626  									 .state ()
1627  									 .account (key2.pub)
1628  									 .previous (state_open->hash ())
1629  									 .representative (key2.pub)
1630  									 .balance (0)
1631  									 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_2))
1632  									 .sign (key2.prv, key2.pub)
1633  									 .work (*pool.generate (state_open->hash ()))
1634  									 .build ();
1635  		{
1636  			nano::logger_mt logger;
1637  			nano::lmdb::store store (logger, path, nano::dev::constants);
1638  			auto transaction (store.tx_begin_write ());
1639  			nano::stats stats;
1640  			nano::ledger ledger (store, stats, nano::dev::constants);
1641  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1642  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_zero).code);
1643  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive_zero).code);
1644  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1645  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1646  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive).code);
1647  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_change).code);
1648  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send_change).code);
1649  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch_first).code);
1650  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive2).code);
1651  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send2).code);
1652  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1653  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send_epoch_link).code);
1654  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "open", MDB_CREATE, &store.block_store.open_blocks_handle));
1655  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "send", MDB_CREATE, &store.block_store.send_blocks_handle));
1656  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "state_blocks", MDB_CREATE, &store.block_store.state_blocks_handle));
1657  			store.version.put (transaction, 17);
1658  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_receive);
1659  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *epoch_first);
1660  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send2);
1661  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send_epoch_link);
1662  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1663  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send_zero);
1664  			write_sideband_v15 (store, transaction, *state_receive_zero);
1665  			write_sideband_v15 (store, transaction, *epoch);
1666  			write_sideband_v15 (store, transaction, *state_send);
1667  			write_sideband_v15 (store, transaction, *state_change);
1668  			write_sideband_v15 (store, transaction, *state_send_change);
1669  			write_sideband_v15 (store, transaction, *state_receive2);
1670  			write_sideband_v15 (store, transaction, *state_open);
1671  			store.block.del (transaction, state_receive_zero->hash ());
1672  			store.block.del (transaction, epoch->hash ());
1673  			store.block.del (transaction, state_send->hash ());
1674  			store.block.del (transaction, state_change->hash ());
1675  			store.block.del (transaction, state_send_change->hash ());
1676  			store.block.del (transaction, state_receive2->hash ());
1677  			store.block.del (transaction, state_open->hash ());
1678  		}
1679  		nano::logger_mt logger;
1680  		nano::lmdb::store store (logger, path, nano::dev::constants);
1681  		ASSERT_FALSE (store.init_error ());
1682  		auto transaction (store.tx_begin_read ());
1683  		nano::mdb_val value;
1684  		ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.block_store.blocks_handle, nano::mdb_val (state_send->hash ()), value));
1685  		ASSERT_EQ (value.size (), sizeof (nano::block_type) + nano::state_block::size + nano::block_sideband::size (nano::block_type::state));
1686  		{
1687  			auto block = store.block.get (transaction, send_zero->hash ());
1688  			ASSERT_NE (block, nullptr);
1689  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_0);
1690  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1691  			ASSERT_FALSE (block->sideband ().details.is_send);
1692  			ASSERT_FALSE (block->sideband ().details.is_receive);
1693  		}
1694  		{
1695  			auto block = store.block.get (transaction, state_receive_zero->hash ());
1696  			ASSERT_NE (block, nullptr);
1697  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_0);
1698  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1699  			ASSERT_FALSE (block->sideband ().details.is_send);
1700  			ASSERT_TRUE (block->sideband ().details.is_receive);
1701  		}
1702  		{
1703  			auto block = store.block.get (transaction, epoch->hash ());
1704  			ASSERT_NE (block, nullptr);
1705  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1706  			ASSERT_TRUE (block->sideband ().details.is_epoch);
1707  			ASSERT_FALSE (block->sideband ().details.is_send);
1708  			ASSERT_FALSE (block->sideband ().details.is_receive);
1709  		}
1710  		{
1711  			auto block = store.block.get (transaction, state_send->hash ());
1712  			ASSERT_NE (block, nullptr);
1713  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1714  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1715  			ASSERT_TRUE (block->sideband ().details.is_send);
1716  			ASSERT_FALSE (block->sideband ().details.is_receive);
1717  		}
1718  		{
1719  			auto block = store.block.get (transaction, state_receive->hash ());
1720  			ASSERT_NE (block, nullptr);
1721  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1722  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1723  			ASSERT_FALSE (block->sideband ().details.is_send);
1724  			ASSERT_TRUE (block->sideband ().details.is_receive);
1725  		}
1726  		{
1727  			auto block = store.block.get (transaction, state_change->hash ());
1728  			ASSERT_NE (block, nullptr);
1729  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1730  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1731  			ASSERT_FALSE (block->sideband ().details.is_send);
1732  			ASSERT_FALSE (block->sideband ().details.is_receive);
1733  		}
1734  		{
1735  			auto block = store.block.get (transaction, state_send_change->hash ());
1736  			ASSERT_NE (block, nullptr);
1737  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1738  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1739  			ASSERT_TRUE (block->sideband ().details.is_send);
1740  			ASSERT_FALSE (block->sideband ().details.is_receive);
1741  		}
1742  		{
1743  			auto block = store.block.get (transaction, epoch_first->hash ());
1744  			ASSERT_NE (block, nullptr);
1745  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_2);
1746  			ASSERT_TRUE (block->sideband ().details.is_epoch);
1747  			ASSERT_FALSE (block->sideband ().details.is_send);
1748  			ASSERT_FALSE (block->sideband ().details.is_receive);
1749  		}
1750  		{
1751  			auto block = store.block.get (transaction, state_receive2->hash ());
1752  			ASSERT_NE (block, nullptr);
1753  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_2);
1754  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1755  			ASSERT_FALSE (block->sideband ().details.is_send);
1756  			ASSERT_TRUE (block->sideband ().details.is_receive);
1757  		}
1758  		{
1759  			auto block = store.block.get (transaction, state_send2->hash ());
1760  			ASSERT_NE (block, nullptr);
1761  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1762  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1763  			ASSERT_TRUE (block->sideband ().details.is_send);
1764  			ASSERT_FALSE (block->sideband ().details.is_receive);
1765  		}
1766  		{
1767  			auto block = store.block.get (transaction, state_open->hash ());
1768  			ASSERT_NE (block, nullptr);
1769  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1770  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1771  			ASSERT_FALSE (block->sideband ().details.is_send);
1772  			ASSERT_TRUE (block->sideband ().details.is_receive);
1773  		}
1774  		{
1775  			auto block = store.block.get (transaction, state_send_epoch_link->hash ());
1776  			ASSERT_NE (block, nullptr);
1777  			ASSERT_EQ (block->sideband ().details.epoch, nano::epoch::epoch_1);
1778  			ASSERT_FALSE (block->sideband ().details.is_epoch);
1779  			ASSERT_TRUE (block->sideband ().details.is_send);
1780  			ASSERT_FALSE (block->sideband ().details.is_receive);
1781  		}
1782  		ASSERT_LT (17, store.version.get (transaction));
1783  	}
1784  	TEST (mdb_block_store, upgrade_v18_v19)
1785  	{
1786  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1787  		{
1788  			GTEST_SKIP ();
1789  		}
1790  		auto path (nano::unique_path () / "data.ldb");
1791  		nano::keypair key1;
1792  		nano::block_builder builder;
1793  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1794  		auto send = builder
1795  					.send ()
1796  					.previous (nano::dev::genesis->hash ())
1797  					.destination (nano::dev::genesis_key.pub)
1798  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1799  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1800  					.work (*pool.generate (nano::dev::genesis->hash ()))
1801  					.build ();
1802  		auto receive = builder
1803  					   .receive ()
1804  					   .previous (send->hash ())
1805  					   .source (send->hash ())
1806  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1807  					   .work (*pool.generate (send->hash ()))
1808  					   .build ();
1809  		auto change = builder
1810  					  .change ()
1811  					  .previous (receive->hash ())
1812  					  .representative (0)
1813  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1814  					  .work (*pool.generate (receive->hash ()))
1815  					  .build ();
1816  		auto state_epoch = builder
1817  						   .state ()
1818  						   .account (nano::dev::genesis_key.pub)
1819  						   .previous (change->hash ())
1820  						   .representative (0)
1821  						   .balance (nano::dev::constants.genesis_amount)
1822  						   .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1823  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  						   .work (*pool.generate (change->hash ()))
1825  						   .build ();
1826  		auto state_send = builder
1827  						  .state ()
1828  						  .account (nano::dev::genesis_key.pub)
1829  						  .previous (state_epoch->hash ())
1830  						  .representative (0)
1831  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1832  						  .link (key1.pub)
1833  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1834  						  .work (*pool.generate (state_epoch->hash ()))
1835  						  .build ();
1836  		auto state_open = builder
1837  						  .state ()
1838  						  .account (key1.pub)
1839  						  .previous (0)
1840  						  .representative (0)
1841  						  .balance (nano::Gxrb_ratio)
1842  						  .link (state_send->hash ())
1843  						  .sign (key1.prv, key1.pub)
1844  						  .work (*pool.generate (key1.pub))
1845  						  .build ();
1846  		{
1847  			nano::logger_mt logger;
1848  			nano::lmdb::store store (logger, path, nano::dev::constants);
1849  			nano::stats stats;
1850  			nano::ledger ledger (store, stats, nano::dev::constants);
1851  			auto transaction (store.tx_begin_write ());
1852  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1853  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1854  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
1855  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
1856  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_epoch).code);
1857  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1858  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1859  			auto txn = store.env.tx (transaction);
1860  			ASSERT_FALSE (mdb_dbi_open (txn, "open", MDB_CREATE, &store.block_store.open_blocks_handle));
1861  			ASSERT_FALSE (mdb_dbi_open (txn, "receive", MDB_CREATE, &store.block_store.receive_blocks_handle));
1862  			ASSERT_FALSE (mdb_dbi_open (txn, "send", MDB_CREATE, &store.block_store.send_blocks_handle));
1863  			ASSERT_FALSE (mdb_dbi_open (txn, "change", MDB_CREATE, &store.block_store.change_blocks_handle));
1864  			ASSERT_FALSE (mdb_dbi_open (txn, "state_blocks", MDB_CREATE, &store.block_store.state_blocks_handle));
1865  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1866  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send);
1867  			write_block_w_sideband_v18 (store, store.block_store.receive_blocks_handle, transaction, *receive);
1868  			write_block_w_sideband_v18 (store, store.block_store.change_blocks_handle, transaction, *change);
1869  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_epoch);
1870  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send);
1871  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_open);
1872  			store.version.put (transaction, 18);
1873  		}
1874  		nano::logger_mt logger;
1875  		nano::lmdb::store store (logger, path, nano::dev::constants);
1876  		ASSERT_FALSE (store.init_error ());
1877  		auto transaction (store.tx_begin_read ());
1878  		ASSERT_EQ (store.block_store.send_blocks_handle, 0);
1879  		ASSERT_EQ (store.block_store.receive_blocks_handle, 0);
1880  		ASSERT_EQ (store.block_store.change_blocks_handle, 0);
1881  		ASSERT_EQ (store.block_store.open_blocks_handle, 0);
1882  		ASSERT_EQ (store.block_store.state_blocks_handle, 0);
1883  		ASSERT_TRUE (store.block.get (transaction, send->hash ()));
1884  		ASSERT_TRUE (store.block.get (transaction, receive->hash ()));
1885  		ASSERT_TRUE (store.block.get (transaction, change->hash ()));
1886  		ASSERT_TRUE (store.block.get (transaction, nano::dev::genesis->hash ()));
1887  		auto state_epoch_disk (store.block.get (transaction, state_epoch->hash ()));
1888  		ASSERT_NE (nullptr, state_epoch_disk);
1889  		ASSERT_EQ (nano::epoch::epoch_1, state_epoch_disk->sideband ().details.epoch);
1890  		ASSERT_EQ (nano::epoch::epoch_0, state_epoch_disk->sideband ().source_epoch); 
1891  		ASSERT_TRUE (store.block.get (transaction, state_send->hash ()));
1892  		auto state_send_disk (store.block.get (transaction, state_send->hash ()));
1893  		ASSERT_NE (nullptr, state_send_disk);
1894  		ASSERT_EQ (nano::epoch::epoch_1, state_send_disk->sideband ().details.epoch);
1895  		ASSERT_EQ (nano::epoch::epoch_0, state_send_disk->sideband ().source_epoch); 
1896  		ASSERT_TRUE (store.block.get (transaction, state_open->hash ()));
1897  		auto state_open_disk (store.block.get (transaction, state_open->hash ()));
1898  		ASSERT_NE (nullptr, state_open_disk);
1899  		ASSERT_EQ (nano::epoch::epoch_1, state_open_disk->sideband ().details.epoch);
1900  		ASSERT_EQ (nano::epoch::epoch_1, state_open_disk->sideband ().source_epoch);
1901  		ASSERT_EQ (7, store.count (transaction, store.block_store.blocks_handle));
1902  		ASSERT_LT (18, store.version.get (transaction));
1903  	}
1904  	TEST (mdb_block_store, upgrade_v19_v20)
1905  	{
1906  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1907  		{
1908  			GTEST_SKIP ();
1909  		}
1910  		auto path (nano::unique_path () / "data.ldb");
1911  		nano::logger_mt logger;
1912  		nano::stats stats;
1913  		{
1914  			nano::lmdb::store store (logger, path, nano::dev::constants);
1915  			nano::ledger ledger (store, stats, nano::dev::constants);
1916  			auto transaction (store.tx_begin_write ());
1917  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1918  			ASSERT_FALSE (mdb_drop (store.env.tx (transaction), store.pruned_store.pruned_handle, 1));
1919  			store.version.put (transaction, 19);
1920  		}
1921  		nano::lmdb::store store (logger, path, nano::dev::constants);
1922  		ASSERT_FALSE (store.init_error ());
1923  		ASSERT_NE (store.pruned_store.pruned_handle, 0);
1924  		auto transaction (store.tx_begin_read ());
1925  		ASSERT_LT (19, store.version.get (transaction));
1926  	}
1927  	TEST (mdb_block_store, upgrade_v20_v21)
1928  	{
1929  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1930  		{
1931  			GTEST_SKIP ();
1932  		}
1933  		auto path (nano::unique_path () / "data.ldb");
1934  		nano::logger_mt logger;
1935  		nano::stats stats;
1936  		{
1937  			nano::lmdb::store store (logger, path, nano::dev::constants);
1938  			nano::ledger ledger (store, stats, nano::dev::constants);
1939  			auto transaction (store.tx_begin_write ());
1940  			store.initialize (transaction, ledger.cache, ledger.constants);
1941  			ASSERT_FALSE (mdb_drop (store.env.tx (transaction), store.final_vote_store.final_votes_handle, 1));
1942  			store.version.put (transaction, 20);
1943  		}
1944  		nano::lmdb::store store (logger, path, nano::dev::constants);
1945  		ASSERT_FALSE (store.init_error ());
1946  		ASSERT_NE (store.final_vote_store.final_votes_handle, 0);
1947  		auto transaction (store.tx_begin_read ());
1948  		ASSERT_LT (19, store.version.get (transaction));
1949  	}
1950  	TEST (mdb_block_store, upgrade_v21_v22)
1951  	{
1952  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1953  		{
1954  			GTEST_SKIP ();
1955  		}
1956  		auto path (nano::unique_path () / "data.ldb");
1957  		nano::logger_mt logger;
1958  		nano::stats stats;
1959  		auto const check_correct_state = [&] () {
1960  			nano::lmdb::store store (logger, path, nano::dev::constants);
1961  			auto transaction (store.tx_begin_write ());
1962  			ASSERT_EQ (store.version.get (transaction), store.version_current);
1963  			MDB_dbi unchecked_handle{ 0 };
1964  			ASSERT_EQ (MDB_NOTFOUND, mdb_dbi_open (store.env.tx (transaction), "unchecked", 0, &unchecked_handle));
1965  		};
1966  		check_correct_state ();
1967  		{
1968  			nano::lmdb::store store (logger, path, nano::dev::constants);
1969  			auto transaction (store.tx_begin_write ());
1970  			store.version.put (transaction, 21);
1971  			MDB_dbi unchecked_handle{ 0 };
1972  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), "unchecked", MDB_CREATE, &unchecked_handle));
1973  			ASSERT_EQ (store.version.get (transaction), 21);
1974  		}
1975  		check_correct_state ();
1976  	}
1977  }
1978  namespace rocksdb
1979  {
1980  	TEST (rocksdb_block_store, upgrade_v21_v22)
1981  	{
1982  		if (!nano::rocksdb_config::using_rocksdb_in_tests ())
1983  		{
1984  			GTEST_SKIP ();
1985  		}
1986  		auto const path = nano::unique_path () / "rocksdb";
1987  		nano::logger_mt logger;
1988  		nano::stats stats;
1989  		auto const check_correct_state = [&] () {
1990  			nano::rocksdb::store store (logger, path, nano::dev::constants);
1991  			auto transaction (store.tx_begin_write ());
1992  			ASSERT_EQ (store.version.get (transaction), store.version_current);
1993  			ASSERT_FALSE (store.column_family_exists ("unchecked"));
1994  		};
1995  		check_correct_state ();
1996  		{
1997  			nano::rocksdb::store store (logger, path, nano::dev::constants);
1998  			::rocksdb::ColumnFamilyOptions new_cf_options;
1999  			::rocksdb::ColumnFamilyHandle * new_cf_handle;
2000  			::rocksdb::Status status = store.db->CreateColumnFamily (new_cf_options, "unchecked", &new_cf_handle);
2001  			store.handles.emplace_back (new_cf_handle);
2002  			ASSERT_TRUE (status.ok ());
2003  			auto transaction (store.tx_begin_write ());
2004  			store.version.put (transaction, 21);
2005  			ASSERT_EQ (store.version.get (transaction), 21);
2006  		}
2007  		check_correct_state ();
2008  	}
2009  }
2010  }
2011  TEST (mdb_block_store, upgrade_backup)
2012  {
2013  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2014  	{
2015  		GTEST_SKIP ();
2016  	}
2017  	auto dir (nano::unique_path ());
2018  	namespace fs = boost::filesystem;
2019  	fs::create_directory (dir);
2020  	auto path = dir / "data.ldb";
2021  	auto get_backup_path = [&dir] () {
2022  		for (fs::directory_iterator itr (dir); itr != fs::directory_iterator (); ++itr)
2023  		{
2024  			if (itr->path ().filename ().string ().find ("data_backup_") != std::string::npos)
2025  			{
2026  				return itr->path ();
2027  			}
2028  		}
2029  		return dir;
2030  	};
2031  	{
2032  		nano::logger_mt logger;
2033  		nano::lmdb::store store (logger, path, nano::dev::constants);
2034  		auto transaction (store.tx_begin_write ());
2035  		store.version.put (transaction, 14);
2036  	}
2037  	ASSERT_EQ (get_backup_path ().string (), dir.string ());
2038  	nano::logger_mt logger;
2039  	nano::lmdb::store store (logger, path, nano::dev::constants, nano::txn_tracking_config{}, std::chrono::seconds (5), nano::lmdb_config{}, true);
2040  	ASSERT_FALSE (store.init_error ());
2041  	auto transaction (store.tx_begin_read ());
2042  	ASSERT_LT (14, store.version.get (transaction));
2043  	ASSERT_NE (get_backup_path ().string (), dir.string ());
2044  }
2045  TEST (block_store, confirmation_height)
2046  {
2047  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2048  	{
2049  		GTEST_SKIP ();
2050  	}
2051  	auto path (nano::unique_path ());
2052  	nano::logger_mt logger;
2053  	auto store = nano::make_store (logger, path, nano::dev::constants);
2054  	nano::account account1{};
2055  	nano::account account2{ 1 };
2056  	nano::account account3{ 2 };
2057  	nano::block_hash cemented_frontier1 (3);
2058  	nano::block_hash cemented_frontier2 (4);
2059  	nano::block_hash cemented_frontier3 (5);
2060  	{
2061  		auto transaction (store->tx_begin_write ());
2062  		store->confirmation_height.put (transaction, account1, { 500, cemented_frontier1 });
2063  		store->confirmation_height.put (transaction, account2, { std::numeric_limits<uint64_t>::max (), cemented_frontier2 });
2064  		store->confirmation_height.put (transaction, account3, { 10, cemented_frontier3 });
2065  		nano::confirmation_height_info confirmation_height_info;
2066  		ASSERT_FALSE (store->confirmation_height.get (transaction, account1, confirmation_height_info));
2067  		ASSERT_EQ (confirmation_height_info.height, 500);
2068  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier1);
2069  		ASSERT_FALSE (store->confirmation_height.get (transaction, account2, confirmation_height_info));
2070  		ASSERT_EQ (confirmation_height_info.height, std::numeric_limits<uint64_t>::max ());
2071  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier2);
2072  		ASSERT_FALSE (store->confirmation_height.get (transaction, account3, confirmation_height_info));
2073  		ASSERT_EQ (confirmation_height_info.height, 10);
2074  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier3);
2075  		store->confirmation_height.clear (transaction);
2076  	}
2077  	auto transaction (store->tx_begin_read ());
2078  	ASSERT_EQ (store->confirmation_height.count (transaction), 0);
2079  	nano::confirmation_height_info confirmation_height_info;
2080  	ASSERT_TRUE (store->confirmation_height.get (transaction, account1, confirmation_height_info));
2081  	ASSERT_TRUE (store->confirmation_height.get (transaction, account2, confirmation_height_info));
2082  	ASSERT_TRUE (store->confirmation_height.get (transaction, account3, confirmation_height_info));
2083  }
2084  TEST (block_store, final_vote)
2085  {
2086  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2087  	{
2088  		GTEST_SKIP ();
2089  	}
2090  	auto path (nano::unique_path ());
2091  	nano::logger_mt logger;
2092  	auto store = nano::make_store (logger, path, nano::dev::constants);
2093  	{
2094  		auto qualified_root = nano::dev::genesis->qualified_root ();
2095  		auto transaction (store->tx_begin_write ());
2096  		store->final_vote.put (transaction, qualified_root, nano::block_hash (2));
2097  		ASSERT_EQ (store->final_vote.count (transaction), 1);
2098  		store->final_vote.clear (transaction);
2099  		ASSERT_EQ (store->final_vote.count (transaction), 0);
2100  		store->final_vote.put (transaction, qualified_root, nano::block_hash (2));
2101  		ASSERT_EQ (store->final_vote.count (transaction), 1);
2102  		store->final_vote.clear (transaction, qualified_root.previous ());
2103  		ASSERT_EQ (store->final_vote.count (transaction), 1);
2104  		store->final_vote.clear (transaction, qualified_root.root ());
2105  		ASSERT_EQ (store->final_vote.count (transaction), 0);
2106  	}
2107  }
2108  TEST (block_store, incompatible_version)
2109  {
2110  	auto path (nano::unique_path ());
2111  	nano::logger_mt logger;
2112  	{
2113  		auto store = nano::make_store (logger, path, nano::dev::constants);
2114  		ASSERT_FALSE (store->init_error ());
2115  		auto transaction (store->tx_begin_write ());
2116  		store->version.put (transaction, std::numeric_limits<int>::max ());
2117  	}
2118  	{
2119  		auto store = nano::make_store (logger, path, nano::dev::constants, true);
2120  		ASSERT_TRUE (store->init_error ());
2121  		auto transaction = store->tx_begin_read ();
2122  		auto version_l = store->version.get (transaction);
2123  		ASSERT_EQ (version_l, std::numeric_limits<int>::max ());
2124  	}
2125  }
2126  TEST (block_store, reset_renew_existing_transaction)
2127  {
2128  	nano::logger_mt logger;
2129  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
2130  	ASSERT_TRUE (!store->init_error ());
2131  	nano::keypair key1;
2132  	nano::block_builder builder;
2133  	auto block = builder
2134  				 .open ()
2135  				 .source (0)
2136  				 .representative (1)
2137  				 .account (1)
2138  				 .sign (nano::keypair ().prv, 0)
2139  				 .work (0)
2140  				 .build ();
2141  	block->sideband_set ({});
2142  	auto hash1 (block->hash ());
2143  	auto read_transaction = store->tx_begin_read ();
2144  	auto block_non_existing (store->block.get (read_transaction, hash1));
2145  	ASSERT_EQ (nullptr, block_non_existing);
2146  	read_transaction.reset ();
2147  	{
2148  		auto write_transaction (store->tx_begin_write ());
2149  		store->block.put (write_transaction, hash1, *block);
2150  	}
2151  	read_transaction.renew ();
2152  	auto block_existing (store->block.get (read_transaction, hash1));
2153  	ASSERT_NE (nullptr, block_existing);
2154  }
2155  TEST (block_store, rocksdb_force_test_env_variable)
2156  {
2157  	nano::logger_mt logger;
2158  	constexpr auto env_var = "TEST_USE_ROCKSDB";
2159  	auto value = std::getenv (env_var);
2160  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
2161  	auto mdb_cast = dynamic_cast<nano::lmdb::store *> (store.get ());
2162  	if (value && boost::lexical_cast<int> (value) == 1)
2163  	{
2164  		ASSERT_NE (boost::polymorphic_downcast<nano::rocksdb::store *> (store.get ()), nullptr);
2165  	}
2166  	else
2167  	{
2168  		ASSERT_NE (mdb_cast, nullptr);
2169  	}
2170  }
2171  namespace nano
2172  {
2173  TEST (rocksdb_block_store, tombstone_count)
2174  {
2175  	if (!nano::rocksdb_config::using_rocksdb_in_tests ())
2176  	{
2177  		GTEST_SKIP ();
2178  	}
2179  	nano::test::system system;
2180  	nano::logger_mt logger;
2181  	auto store = std::make_unique<nano::rocksdb::store> (logger, nano::unique_path () / "rocksdb", nano::dev::constants);
2182  	ASSERT_TRUE (!store->init_error ());
2183  	nano::block_builder builder;
2184  	auto block = builder
2185  				 .send ()
2186  				 .previous (0)
2187  				 .destination (1)
2188  				 .balance (2)
2189  				 .sign (nano::keypair ().prv, 4)
2190  				 .work (5)
2191  				 .build_shared ();
2192  	nano::account account{ 1 };
2193  	store->account.put (store->tx_begin_write (), account, nano::account_info{});
2194  	auto check_block_is_listed = [&] (nano::transaction const & transaction_a) {
2195  		return store->account.exists (transaction_a, account);
2196  	};
2197  	ASSERT_TIMELY (5s, check_block_is_listed (store->tx_begin_read ()));
2198  	ASSERT_EQ (store->tombstone_map.at (nano::tables::accounts).num_since_last_flush.load (), 0);
2199  	store->account.del (store->tx_begin_write (), account);
2200  	ASSERT_TIMELY (5s, store->tombstone_map.at (nano::tables::accounts).num_since_last_flush.load () == 1);
2201  }
2202  }
2203  namespace nano
2204  {
2205  namespace lmdb
2206  {
2207  	void write_sideband_v14 (nano::lmdb::store & store_a, nano::transaction & transaction_a, nano::block const & block_a, MDB_dbi db_a)
2208  	{
2209  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2210  		ASSERT_NE (block, nullptr);
2211  		nano::block_sideband_v14 sideband_v14 (block->type (), block->sideband ().account, block->sideband ().successor, block->sideband ().balance, block->sideband ().timestamp, block->sideband ().height);
2212  		std::vector<uint8_t> data;
2213  		{
2214  			nano::vectorstream stream (data);
2215  			block_a.serialize (stream);
2216  			sideband_v14.serialize (stream);
2217  		}
2218  		MDB_val val{ data.size (), data.data () };
2219  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), block->sideband ().details.epoch == nano::epoch::epoch_0 ? store_a.block_store.state_blocks_v0_handle : store_a.block_store.state_blocks_v1_handle, nano::mdb_val (block_a.hash ()), &val, 0));
2220  	}
2221  	void write_sideband_v15 (nano::lmdb::store & store_a, nano::transaction & transaction_a, nano::block const & block_a)
2222  	{
2223  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2224  		ASSERT_NE (block, nullptr);
2225  		ASSERT_LE (block->sideband ().details.epoch, nano::epoch::max);
2226  		nano::block_sideband_v18 sideband_v15 (block->sideband ().account, block->sideband ().successor, block->sideband ().balance, block->sideband ().timestamp, block->sideband ().height, block->sideband ().details.epoch, false, false, false);
2227  		std::vector<uint8_t> data;
2228  		{
2229  			nano::vectorstream stream (data);
2230  			block_a.serialize (stream);
2231  			sideband_v15.serialize (stream, block_a.type ());
2232  		}
2233  		MDB_val val{ data.size (), data.data () };
2234  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), store_a.block_store.state_blocks_handle, nano::mdb_val (block_a.hash ()), &val, 0));
2235  	}
2236  	void write_block_w_sideband_v18 (nano::lmdb::store & store_a, MDB_dbi database, nano::write_transaction & transaction_a, nano::block const & block_a)
2237  	{
2238  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2239  		ASSERT_NE (block, nullptr);
2240  		auto new_sideband (block->sideband ());
2241  		nano::block_sideband_v18 sideband_v18 (new_sideband.account, new_sideband.successor, new_sideband.balance, new_sideband.height, new_sideband.timestamp, new_sideband.details.epoch, new_sideband.details.is_send, new_sideband.details.is_receive, new_sideband.details.is_epoch);
2242  		std::vector<uint8_t> data;
2243  		{
2244  			nano::vectorstream stream (data);
2245  			block->serialize (stream);
2246  			sideband_v18.serialize (stream, block->type ());
2247  		}
2248  		MDB_val val{ data.size (), data.data () };
2249  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), database, nano::mdb_val (block_a.hash ()), &val, 0));
2250  		store_a.del (transaction_a, nano::tables::blocks, nano::mdb_val (block_a.hash ()));
2251  	}
2252  	void modify_account_info_to_v14 (nano::lmdb::store & store, nano::transaction const & transaction, nano::account const & account, uint64_t confirmation_height, nano::block_hash const & rep_block)
2253  	{
2254  		nano::account_info info;
2255  		ASSERT_FALSE (store.account.get (transaction, account, info));
2256  		nano::account_info_v14 account_info_v14 (info.head, rep_block, info.open_block, info.balance, info.modified, info.block_count, confirmation_height, info.epoch ());
2257  		auto status (mdb_put (store.env.tx (transaction), info.epoch () == nano::epoch::epoch_0 ? store.account_store.accounts_v0_handle : store.account_store.accounts_v1_handle, nano::mdb_val (account), nano::mdb_val (account_info_v14), 0));
2258  		ASSERT_EQ (status, 0);
2259  	}
2260  	void modify_confirmation_height_to_v15 (nano::lmdb::store & store, nano::transaction const & transaction, nano::account const & account, uint64_t confirmation_height)
2261  	{
2262  		auto status (mdb_put (store.env.tx (transaction), store.confirmation_height_store.confirmation_height_handle, nano::mdb_val (account), nano::mdb_val (confirmation_height), 0));
2263  		ASSERT_EQ (status, 0);
2264  	}
2265  }
2266  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahooex.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store.cpp</div>
                </div>
                <div class="column column_space"><pre><code>859    TStr CtgIdVStr=YBs->GetCtgIdVStr(CtgIdV);
860    TStrV CtgStrV; YBs->GetCtgStrV(CtgIdV, CtgStrV);
861    TStr CtgIdToWFqHStr=YBs->GetCtgIdToWFqHStr(CtgIdToWFqH, 0.9);
862    Lx.PutUQStr("------------------------------------------"); Lx.PutLn();
863    Lx.PutLn();Lx.PutUQStr("Best Keywords"); Lx.PutLn();
864    Lx.PutVarStr("CtgIdV", CtgIdVStr);
865    Lx.PutVarStrV("CtgStrV", CtgStrV);}
</pre></code></div>
                <div class="column column_space"><pre><code>221  	auto transaction (store->tx_begin_write ());
222  	auto latest1 (store->block.get (transaction, hash1));
223  	ASSERT_EQ (nullptr, latest1);
224  	auto block2 = builder
225  				  .open ()
226  				  .source (0)
227  				  .representative (1)
228  				  .account (3)
229  				  .sign (nano::keypair ().prv, 0)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    