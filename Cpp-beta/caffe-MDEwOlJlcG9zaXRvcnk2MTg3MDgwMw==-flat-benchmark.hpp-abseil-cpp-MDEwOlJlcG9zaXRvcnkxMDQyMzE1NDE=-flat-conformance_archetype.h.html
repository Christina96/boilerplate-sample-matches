
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.700123915737299%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-benchmark.hpp</h3>
            <pre><code>1  #ifndef CAFFE_UTIL_BENCHMARK_H_
2  #define CAFFE_UTIL_BENCHMARK_H_
3  #include <boost/date_time/posix_time/posix_time.hpp>
4  #include "caffe/util/device_alternate.hpp"
5  namespace caffe {
6  class Timer {
7   public:
8    Timer();
9    virtual ~Timer();
10    virtual void Start();
11    virtual void Stop();
12    virtual float MilliSeconds();
13    virtual float MicroSeconds();
14    virtual float Seconds();
15    virtual void InitTime();
16    virtual void InitTime(Timer &);
17    virtual float Duration();
18    inline bool initted() { return initted_; }
19    inline bool running() { return running_; }
<span onclick='openModal()' class='match'>20    inline bool has_run_at_least_once() { return has_run_at_least_once_; }
21   protected:
22    void Init();
23    bool initted_;
24    bool running_;
25    bool has_run_at_least_once_;
26  #ifndef CPU_ONLY
27    cudaEvent_t start_gpu_;
28    cudaEvent_t stop_gpu_;
29  #endif
30    boost::posix_time::ptime init_cpu_;
31    boost::posix_time::ptime start_cpu_;
32    boost::posix_time::ptime stop_cpu_;
33    float elapsed_milliseconds_;
34    float elapsed_microseconds_;
</span>35  };
36  class CPUTimer : public Timer {
37   public:
38    explicit CPUTimer();
39    virtual ~CPUTimer() {}
40    virtual void Start();
41    virtual void Stop();
42    virtual float MilliSeconds();
43    virtual float MicroSeconds();
44  };
45  }  
46  #endif   
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_archetype.h</h3>
            <pre><code>1  #ifndef ABSL_TYPES_INTERNAL_CONFORMANCE_ARCHETYPE_H_
2  #define ABSL_TYPES_INTERNAL_CONFORMANCE_ARCHETYPE_H_
3  #include <cstddef>
4  #include <functional>
5  #include <type_traits>
6  #include <utility>
7  #include "absl/meta/type_traits.h"
8  #include "absl/types/internal/conformance_profile.h"
9  namespace absl {
10  ABSL_NAMESPACE_BEGIN
11  namespace types_internal {
12  template <class Prof, class &bsol;*Enabler*/ = void>
13  class Archetype;
14  template <class Archetype>
15  struct PropertiesOfArchetype;
16  template <class Prof>
17  struct PropertiesOfArchetype<Archetype<Prof>> {
18    using type = PropertiesOfT<Prof>;
19  };
20  template <class Archetype>
21  using PropertiesOfArchetypeT = typename PropertiesOfArchetype<Archetype>::type;
22  template <class T>
23  struct IsArchetype : std::false_type {};
24  template <class Prof>
25  struct IsArchetype<Archetype<Prof>> : std::true_type {};
26  struct MakeArchetypeState {};
27  using ArchetypeState = std::size_t;
28  template <default_constructible DefaultConstructibleValue>
29  struct ArchetypeStateBase {
30    static_assert(DefaultConstructibleValue == default_constructible::yes ||
31                      DefaultConstructibleValue == default_constructible::nothrow,
32                  "");
33    ArchetypeStateBase() noexcept(
34        DefaultConstructibleValue ==
35        default_constructible::
36            nothrow) &bsol;*Vacuous archetype_state initialization*/ {}
37    explicit ArchetypeStateBase(MakeArchetypeState, ArchetypeState state) noexcept
38        : archetype_state(state) {}
39    ArchetypeState archetype_state;
40  };
41  template <>
42  struct ArchetypeStateBase<default_constructible::maybe> {
43    explicit ArchetypeStateBase() = delete;
44    explicit ArchetypeStateBase(MakeArchetypeState, ArchetypeState state) noexcept
45        : archetype_state(state) {}
46    ArchetypeState archetype_state;
47  };
48  template <>
49  struct ArchetypeStateBase<default_constructible::trivial> {
50    ArchetypeStateBase() = default;
51    explicit ArchetypeStateBase(MakeArchetypeState, ArchetypeState state) noexcept
52        : archetype_state(state) {}
53    ArchetypeState archetype_state;
54  };
55  template <default_constructible DefaultConstructibleValue,
56            move_constructible MoveConstructibleValue>
57  struct ArchetypeMoveConstructor
58      : ArchetypeStateBase<DefaultConstructibleValue> {
59    static_assert(MoveConstructibleValue == move_constructible::yes ||
60                      MoveConstructibleValue == move_constructible::nothrow,
61                  "");
62    explicit ArchetypeMoveConstructor(MakeArchetypeState,
63                                      ArchetypeState state) noexcept
64        : ArchetypeStateBase<DefaultConstructibleValue>(MakeArchetypeState(),
65                                                        state) {}
66    ArchetypeMoveConstructor() = default;
67    ArchetypeMoveConstructor(ArchetypeMoveConstructor&& other) noexcept(
68        MoveConstructibleValue == move_constructible::nothrow)
69        : ArchetypeStateBase<DefaultConstructibleValue>(MakeArchetypeState(),
70                                                        other.archetype_state) {}
71    ArchetypeMoveConstructor(const ArchetypeMoveConstructor&) = default;
72    ArchetypeMoveConstructor& operator=(ArchetypeMoveConstructor&&) = default;
73    ArchetypeMoveConstructor& operator=(const ArchetypeMoveConstructor&) =
74        default;
75  };
76  template <default_constructible DefaultConstructibleValue>
77  struct ArchetypeMoveConstructor<DefaultConstructibleValue,
78                                  move_constructible::trivial>
79      : ArchetypeStateBase<DefaultConstructibleValue> {
80    explicit ArchetypeMoveConstructor(MakeArchetypeState,
81                                      ArchetypeState state) noexcept
82        : ArchetypeStateBase<DefaultConstructibleValue>(MakeArchetypeState(),
83                                                        state) {}
84    ArchetypeMoveConstructor() = default;
85  };
86  template <default_constructible DefaultConstructibleValue,
87            move_constructible MoveConstructibleValue,
88            copy_constructible CopyConstructibleValue>
89  struct ArchetypeCopyConstructor
90      : ArchetypeMoveConstructor<DefaultConstructibleValue,
91                                 MoveConstructibleValue> {
92    static_assert(CopyConstructibleValue == copy_constructible::yes ||
93                      CopyConstructibleValue == copy_constructible::nothrow,
94                  "");
95    explicit ArchetypeCopyConstructor(MakeArchetypeState,
96                                      ArchetypeState state) noexcept
97        : ArchetypeMoveConstructor<DefaultConstructibleValue,
98                                   MoveConstructibleValue>(MakeArchetypeState(),
99                                                           state) {}
100    ArchetypeCopyConstructor() = default;
101    ArchetypeCopyConstructor(ArchetypeCopyConstructor&&) = default;
102    ArchetypeCopyConstructor(const ArchetypeCopyConstructor& other) noexcept(
103        CopyConstructibleValue == copy_constructible::nothrow)
104        : ArchetypeMoveConstructor<DefaultConstructibleValue,
105                                   MoveConstructibleValue>(
106              MakeArchetypeState(), other.archetype_state) {}
107    ArchetypeCopyConstructor& operator=(ArchetypeCopyConstructor&&) = default;
108    ArchetypeCopyConstructor& operator=(const ArchetypeCopyConstructor&) =
109        default;
110  };
111  template <default_constructible DefaultConstructibleValue,
112            move_constructible MoveConstructibleValue>
113  struct ArchetypeCopyConstructor<DefaultConstructibleValue,
114                                  MoveConstructibleValue,
115                                  copy_constructible::maybe>
116      : ArchetypeMoveConstructor<DefaultConstructibleValue,
117                                 MoveConstructibleValue> {
118    explicit ArchetypeCopyConstructor(MakeArchetypeState,
119                                      ArchetypeState state) noexcept
120        : ArchetypeMoveConstructor<DefaultConstructibleValue,
121                                   MoveConstructibleValue>(MakeArchetypeState(),
122                                                           state) {}
123    ArchetypeCopyConstructor() = default;
124    ArchetypeCopyConstructor(ArchetypeCopyConstructor&&) = default;
125    ArchetypeCopyConstructor(const ArchetypeCopyConstructor&) = delete;
126    ArchetypeCopyConstructor& operator=(ArchetypeCopyConstructor&&) = default;
127    ArchetypeCopyConstructor& operator=(const ArchetypeCopyConstructor&) =
128        default;
129  };
130  template <default_constructible DefaultConstructibleValue,
131            move_constructible MoveConstructibleValue>
132  struct ArchetypeCopyConstructor<DefaultConstructibleValue,
133                                  MoveConstructibleValue,
134                                  copy_constructible::trivial>
135      : ArchetypeMoveConstructor<DefaultConstructibleValue,
136                                 MoveConstructibleValue> {
137    explicit ArchetypeCopyConstructor(MakeArchetypeState,
138                                      ArchetypeState state) noexcept
139        : ArchetypeMoveConstructor<DefaultConstructibleValue,
140                                   MoveConstructibleValue>(MakeArchetypeState(),
141                                                           state) {}
142    ArchetypeCopyConstructor() = default;
143  };
144  template <default_constructible DefaultConstructibleValue,
145            move_constructible MoveConstructibleValue,
146            copy_constructible CopyConstructibleValue,
147            move_assignable MoveAssignableValue>
148  struct ArchetypeMoveAssign
149      : ArchetypeCopyConstructor<DefaultConstructibleValue,
150                                 MoveConstructibleValue, CopyConstructibleValue> {
151    static_assert(MoveAssignableValue == move_assignable::yes ||
152                      MoveAssignableValue == move_assignable::nothrow,
153                  "");
154    explicit ArchetypeMoveAssign(MakeArchetypeState,
155                                 ArchetypeState state) noexcept
156        : ArchetypeCopyConstructor<DefaultConstructibleValue,
157                                   MoveConstructibleValue,
158                                   CopyConstructibleValue>(MakeArchetypeState(),
159                                                           state) {}
160    ArchetypeMoveAssign() = default;
161    ArchetypeMoveAssign(ArchetypeMoveAssign&&) = default;
162    ArchetypeMoveAssign(const ArchetypeMoveAssign&) = default;
163    ArchetypeMoveAssign& operator=(ArchetypeMoveAssign&& other) noexcept(
164        MoveAssignableValue == move_assignable::nothrow) {
165      this->archetype_state = other.archetype_state;
166      return *this;
167    }
168    ArchetypeMoveAssign& operator=(const ArchetypeMoveAssign&) = default;
169  };
170  template <default_constructible DefaultConstructibleValue,
171            move_constructible MoveConstructibleValue,
172            copy_constructible CopyConstructibleValue>
173  struct ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
174                             CopyConstructibleValue, move_assignable::trivial>
175      : ArchetypeCopyConstructor<DefaultConstructibleValue,
176                                 MoveConstructibleValue, CopyConstructibleValue> {
177    explicit ArchetypeMoveAssign(MakeArchetypeState,
178                                 ArchetypeState state) noexcept
179        : ArchetypeCopyConstructor<DefaultConstructibleValue,
180                                   MoveConstructibleValue,
181                                   CopyConstructibleValue>(MakeArchetypeState(),
182                                                           state) {}
183    ArchetypeMoveAssign() = default;
184  };
185  template <default_constructible DefaultConstructibleValue,
186            move_constructible MoveConstructibleValue,
187            copy_constructible CopyConstructibleValue,
188            move_assignable MoveAssignableValue,
189            copy_assignable CopyAssignableValue>
190  struct ArchetypeCopyAssign
191      : ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
192                            CopyConstructibleValue, MoveAssignableValue> {
193    static_assert(CopyAssignableValue == copy_assignable::yes ||
194                      CopyAssignableValue == copy_assignable::nothrow,
195                  "");
196    explicit ArchetypeCopyAssign(MakeArchetypeState,
197                                 ArchetypeState state) noexcept
198        : ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
199                              CopyConstructibleValue, MoveAssignableValue>(
200              MakeArchetypeState(), state) {}
201    ArchetypeCopyAssign() = default;
202    ArchetypeCopyAssign(ArchetypeCopyAssign&&) = default;
203    ArchetypeCopyAssign(const ArchetypeCopyAssign&) = default;
204    ArchetypeCopyAssign& operator=(ArchetypeCopyAssign&&) = default;
205    ArchetypeCopyAssign& operator=(const ArchetypeCopyAssign& other) noexcept(
206        CopyAssignableValue == copy_assignable::nothrow) {
207      this->archetype_state = other.archetype_state;
208      return *this;
209    }
210  };
211  template <default_constructible DefaultConstructibleValue,
212            move_constructible MoveConstructibleValue,
213            copy_constructible CopyConstructibleValue,
214            move_assignable MoveAssignableValue>
215  struct ArchetypeCopyAssign<DefaultConstructibleValue, MoveConstructibleValue,
216                             CopyConstructibleValue, MoveAssignableValue,
217                             copy_assignable::maybe>
218      : ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
219                            CopyConstructibleValue, MoveAssignableValue> {
220    explicit ArchetypeCopyAssign(MakeArchetypeState,
221                                 ArchetypeState state) noexcept
222        : ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
223                              CopyConstructibleValue, MoveAssignableValue>(
224              MakeArchetypeState(), state) {}
225    ArchetypeCopyAssign() = default;
226    ArchetypeCopyAssign(ArchetypeCopyAssign&&) = default;
227    ArchetypeCopyAssign(const ArchetypeCopyAssign&) = default;
228    ArchetypeCopyAssign& operator=(ArchetypeCopyAssign&&) = default;
229    ArchetypeCopyAssign& operator=(const ArchetypeCopyAssign&) = delete;
230  };
231  template <default_constructible DefaultConstructibleValue,
232            move_constructible MoveConstructibleValue,
233            copy_constructible CopyConstructibleValue,
234            move_assignable MoveAssignableValue>
235  struct ArchetypeCopyAssign<DefaultConstructibleValue, MoveConstructibleValue,
236                             CopyConstructibleValue, MoveAssignableValue,
237                             copy_assignable::trivial>
238      : ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
239                            CopyConstructibleValue, MoveAssignableValue> {
240    explicit ArchetypeCopyAssign(MakeArchetypeState,
241                                 ArchetypeState state) noexcept
242        : ArchetypeMoveAssign<DefaultConstructibleValue, MoveConstructibleValue,
243                              CopyConstructibleValue, MoveAssignableValue>(
244              MakeArchetypeState(), state) {}
245    ArchetypeCopyAssign() = default;
246  };
247  template <default_constructible DefaultConstructibleValue,
248            move_constructible MoveConstructibleValue,
249            copy_constructible CopyConstructibleValue,
250            move_assignable MoveAssignableValue,
251            copy_assignable CopyAssignableValue, destructible DestructibleValue>
252  struct ArchetypeDestructor
253      : ArchetypeCopyAssign<DefaultConstructibleValue, MoveConstructibleValue,
254                            CopyConstructibleValue, MoveAssignableValue,
255                            CopyAssignableValue> {
256    static_assert(DestructibleValue == destructible::yes ||
257                      DestructibleValue == destructible::nothrow,
258                  "");
259    explicit ArchetypeDestructor(MakeArchetypeState,
260                                 ArchetypeState state) noexcept
261        : ArchetypeCopyAssign<DefaultConstructibleValue, MoveConstructibleValue,
262                              CopyConstructibleValue, MoveAssignableValue,
263                              CopyAssignableValue>(MakeArchetypeState(), state) {}
264    ArchetypeDestructor() = default;
265    ArchetypeDestructor(ArchetypeDestructor&&) = default;
266    ArchetypeDestructor(const ArchetypeDestructor&) = default;
267    ArchetypeDestructor& operator=(ArchetypeDestructor&&) = default;
268    ArchetypeDestructor& operator=(const ArchetypeDestructor&) = default;
269    ~ArchetypeDestructor() noexcept(DestructibleValue == destructible::nothrow) {}
270  };
271  template <default_constructible DefaultConstructibleValue,
272            move_constructible MoveConstructibleValue,
273            copy_constructible CopyConstructibleValue,
274            move_assignable MoveAssignableValue,
275            copy_assignable CopyAssignableValue>
276  struct ArchetypeDestructor<DefaultConstructibleValue, MoveConstructibleValue,
277                             CopyConstructibleValue, MoveAssignableValue,
278                             CopyAssignableValue, destructible::trivial>
279      : ArchetypeCopyAssign<DefaultConstructibleValue, MoveConstructibleValue,
280                            CopyConstructibleValue, MoveAssignableValue,
281                            CopyAssignableValue> {
282    explicit ArchetypeDestructor(MakeArchetypeState,
283                                 ArchetypeState state) noexcept
284        : ArchetypeCopyAssign<DefaultConstructibleValue, MoveConstructibleValue,
285                              CopyConstructibleValue, MoveAssignableValue,
286                              CopyAssignableValue>(MakeArchetypeState(), state) {}
287    ArchetypeDestructor() = default;
288  };
289  template <default_constructible DefaultConstructibleValue,
290            move_constructible MoveConstructibleValue,
291            copy_constructible CopyConstructibleValue,
292            move_assignable MoveAssignableValue,
293            copy_assignable CopyAssignableValue, destructible DestructibleValue>
294  using ArchetypeSpecialMembersBase = ArchetypeDestructor<
295      DefaultConstructibleValue,
296      MoveConstructibleValue != move_constructible::maybe
297          ? MoveConstructibleValue
298          : move_constructible::nothrow,
299      CopyConstructibleValue,
300      MoveAssignableValue != move_assignable::maybe ? MoveAssignableValue
301                                                    : move_assignable::nothrow,
302      CopyAssignableValue,
303      DestructibleValue != destructible::maybe ? DestructibleValue
304                                               : destructible::nothrow>;
305  template <class Arch>
306  Arch MakeArchetype(ArchetypeState state) noexcept {
307    static_assert(IsArchetype<Arch>::value,
308                  "The explicit template argument to MakeArchetype is required "
309                  "to be an Archetype.");
310    return Arch(MakeArchetypeState(), state);
311  }
312  template <class Prof, class T>
313  constexpr bool ShouldDeleteConstructor() {
314    return !((PropertiesOfT<Prof>::move_constructible_support !=
315                  move_constructible::maybe &&
316              std::is_same<T, Archetype<Prof>>::value) ||
317             (PropertiesOfT<Prof>::copy_constructible_support !=
318                  copy_constructible::maybe &&
319              (std::is_same<T, const Archetype<Prof>&>::value ||
320               std::is_same<T, Archetype<Prof>&>::value ||
321               std::is_same<T, const Archetype<Prof>>::value)));
322  }
323  template <class Prof, class T>
324  constexpr bool ShouldDeleteAssign() {
325    return !(
326        (PropertiesOfT<Prof>::move_assignable_support != move_assignable::maybe &&
327         std::is_same<T, Archetype<Prof>>::value) ||
328        (PropertiesOfT<Prof>::copy_assignable_support != copy_assignable::maybe &&
329         (std::is_same<T, const Archetype<Prof>&>::value ||
330          std::is_same<T, Archetype<Prof>&>::value ||
331          std::is_same<T, const Archetype<Prof>>::value)));
332  }
333  template <class Prof, class Enabler>
334  class Archetype : ArchetypeSpecialMembersBase<
335                        PropertiesOfT<Prof>::default_constructible_support,
336                        PropertiesOfT<Prof>::move_constructible_support,
337                        PropertiesOfT<Prof>::copy_constructible_support,
338                        PropertiesOfT<Prof>::move_assignable_support,
339                        PropertiesOfT<Prof>::copy_assignable_support,
340                        PropertiesOfT<Prof>::destructible_support> {
341    static_assert(std::is_same<Enabler, void>::value,
342                  "An explicit type must not be passed as the second template "
343                  "argument to 'Archetype`.");
344    static_assert(PropertiesOfT<Prof>::destructible_support !=
345                      destructible::maybe,
346                  "");
347    static_assert(PropertiesOfT<Prof>::move_constructible_support !=
348                          move_constructible::maybe ||
349                      PropertiesOfT<Prof>::copy_constructible_support ==
350                          copy_constructible::maybe,
351                  "");
352    static_assert(PropertiesOfT<Prof>::move_assignable_support !=
353                          move_assignable::maybe ||
354                      PropertiesOfT<Prof>::copy_assignable_support ==
355                          copy_assignable::maybe,
356                  "");
357   public:
358    Archetype() = default;
359    template <class T, typename std::enable_if<
360                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
361    Archetype(T&&) = delete;
362    template <class T, typename std::enable_if<
363                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
364    Archetype& operator=(T&&) = delete;
365    using ArchetypeSpecialMembersBase<
366        PropertiesOfT<Prof>::default_constructible_support,
367        PropertiesOfT<Prof>::move_constructible_support,
368        PropertiesOfT<Prof>::copy_constructible_support,
369        PropertiesOfT<Prof>::move_assignable_support,
370        PropertiesOfT<Prof>::copy_assignable_support,
371        PropertiesOfT<Prof>::destructible_support>::archetype_state;
372   private:
373    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
374        : ArchetypeSpecialMembersBase<
375              PropertiesOfT<Prof>::default_constructible_support,
376              PropertiesOfT<Prof>::move_constructible_support,
377              PropertiesOfT<Prof>::copy_constructible_support,
378              PropertiesOfT<Prof>::move_assignable_support,
379              PropertiesOfT<Prof>::copy_assignable_support,
380              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
381                                                         state) {}
382    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
383  };
384  template <class Prof>
385  class Archetype<Prof, typename std::enable_if<
386                            PropertiesOfT<Prof>::move_constructible_support !=
387                                move_constructible::maybe &&
388                            PropertiesOfT<Prof>::move_assignable_support ==
389                                move_assignable::maybe &&
390                            PropertiesOfT<Prof>::destructible_support !=
391                                destructible::maybe>::type>
392      : ArchetypeSpecialMembersBase<
393            PropertiesOfT<Prof>::default_constructible_support,
394            PropertiesOfT<Prof>::move_constructible_support,
395            PropertiesOfT<Prof>::copy_constructible_support,
396            PropertiesOfT<Prof>::move_assignable_support,
397            PropertiesOfT<Prof>::copy_assignable_support,
398            PropertiesOfT<Prof>::destructible_support> {
399   public:
400    Archetype() = default;
401    Archetype(Archetype&&) = default;
402    Archetype(const Archetype&) = default;
403    Archetype& operator=(Archetype&&) = delete;
404    Archetype& operator=(const Archetype&) = default;
405    template <class T, typename std::enable_if<
406                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
407    Archetype(T&&) = delete;
408    template <class T, typename std::enable_if<
409                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
<span onclick='openModal()' class='match'>410    Archetype& operator=(T&&) = delete;
411    using ArchetypeSpecialMembersBase<
412        PropertiesOfT<Prof>::default_constructible_support,
413        PropertiesOfT<Prof>::move_constructible_support,
414        PropertiesOfT<Prof>::copy_constructible_support,
415        PropertiesOfT<Prof>::move_assignable_support,
416        PropertiesOfT<Prof>::copy_assignable_support,
417        PropertiesOfT<Prof>::destructible_support>::archetype_state;
</span>418   private:
419    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
420        : ArchetypeSpecialMembersBase<
421              PropertiesOfT<Prof>::default_constructible_support,
422              PropertiesOfT<Prof>::move_constructible_support,
423              PropertiesOfT<Prof>::copy_constructible_support,
424              PropertiesOfT<Prof>::move_assignable_support,
425              PropertiesOfT<Prof>::copy_assignable_support,
426              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
427                                                         state) {}
428    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
429  };
430  template <class Prof>
431  class Archetype<Prof, typename std::enable_if<
432                            PropertiesOfT<Prof>::move_constructible_support ==
433                                move_constructible::maybe &&
434                            PropertiesOfT<Prof>::move_assignable_support ==
435                                move_assignable::maybe &&
436                            PropertiesOfT<Prof>::destructible_support !=
437                                destructible::maybe>::type>
438      : ArchetypeSpecialMembersBase<
439            PropertiesOfT<Prof>::default_constructible_support,
440            PropertiesOfT<Prof>::move_constructible_support,
441            PropertiesOfT<Prof>::copy_constructible_support,
442            PropertiesOfT<Prof>::move_assignable_support,
443            PropertiesOfT<Prof>::copy_assignable_support,
444            PropertiesOfT<Prof>::destructible_support> {
445   public:
446    Archetype() = default;
447    Archetype(Archetype&&) = delete;
448    Archetype(const Archetype&) = default;
449    Archetype& operator=(Archetype&&) = delete;
450    Archetype& operator=(const Archetype&) = default;
451    template <class T, typename std::enable_if<
452                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
453    Archetype(T&&) = delete;
454    template <class T, typename std::enable_if<
455                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
456    Archetype& operator=(T&&) = delete;
457    using ArchetypeSpecialMembersBase<
458        PropertiesOfT<Prof>::default_constructible_support,
459        PropertiesOfT<Prof>::move_constructible_support,
460        PropertiesOfT<Prof>::copy_constructible_support,
461        PropertiesOfT<Prof>::move_assignable_support,
462        PropertiesOfT<Prof>::copy_assignable_support,
463        PropertiesOfT<Prof>::destructible_support>::archetype_state;
464   private:
465    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
466        : ArchetypeSpecialMembersBase<
467              PropertiesOfT<Prof>::default_constructible_support,
468              PropertiesOfT<Prof>::move_constructible_support,
469              PropertiesOfT<Prof>::copy_constructible_support,
470              PropertiesOfT<Prof>::move_assignable_support,
471              PropertiesOfT<Prof>::copy_assignable_support,
472              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
473                                                         state) {}
474    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
475  };
476  template <class Prof>
477  class Archetype<Prof, typename std::enable_if<
478                            PropertiesOfT<Prof>::move_constructible_support ==
479                                move_constructible::maybe &&
480                            PropertiesOfT<Prof>::move_assignable_support !=
481                                move_assignable::maybe &&
482                            PropertiesOfT<Prof>::destructible_support !=
483                                destructible::maybe>::type>
484      : ArchetypeSpecialMembersBase<
485            PropertiesOfT<Prof>::default_constructible_support,
486            PropertiesOfT<Prof>::move_constructible_support,
487            PropertiesOfT<Prof>::copy_constructible_support,
488            PropertiesOfT<Prof>::move_assignable_support,
489            PropertiesOfT<Prof>::copy_assignable_support,
490            PropertiesOfT<Prof>::destructible_support> {
491   public:
492    Archetype() = default;
493    Archetype(Archetype&&) = delete;
494    Archetype(const Archetype&) = default;
495    Archetype& operator=(Archetype&&) = default;
496    Archetype& operator=(const Archetype&) = default;
497    template <class T, typename std::enable_if<
498                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
499    Archetype(T&&) = delete;
500    template <class T, typename std::enable_if<
501                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
502    Archetype& operator=(T&&) = delete;
503    using ArchetypeSpecialMembersBase<
504        PropertiesOfT<Prof>::default_constructible_support,
505        PropertiesOfT<Prof>::move_constructible_support,
506        PropertiesOfT<Prof>::copy_constructible_support,
507        PropertiesOfT<Prof>::move_assignable_support,
508        PropertiesOfT<Prof>::copy_assignable_support,
509        PropertiesOfT<Prof>::destructible_support>::archetype_state;
510   private:
511    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
512        : ArchetypeSpecialMembersBase<
513              PropertiesOfT<Prof>::default_constructible_support,
514              PropertiesOfT<Prof>::move_constructible_support,
515              PropertiesOfT<Prof>::copy_constructible_support,
516              PropertiesOfT<Prof>::move_assignable_support,
517              PropertiesOfT<Prof>::copy_assignable_support,
518              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
519                                                         state) {}
520    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
521  };
522  template <class Prof>
523  class Archetype<Prof, typename std::enable_if<
524                            PropertiesOfT<Prof>::move_constructible_support !=
525                                move_constructible::maybe &&
526                            PropertiesOfT<Prof>::move_assignable_support ==
527                                move_assignable::maybe &&
528                            PropertiesOfT<Prof>::destructible_support ==
529                                destructible::maybe>::type>
530      : ArchetypeSpecialMembersBase<
531            PropertiesOfT<Prof>::default_constructible_support,
532            PropertiesOfT<Prof>::move_constructible_support,
533            PropertiesOfT<Prof>::copy_constructible_support,
534            PropertiesOfT<Prof>::move_assignable_support,
535            PropertiesOfT<Prof>::copy_assignable_support,
536            PropertiesOfT<Prof>::destructible_support> {
537   public:
538    Archetype() = default;
539    Archetype(Archetype&&) = default;
540    Archetype(const Archetype&) = default;
541    Archetype& operator=(Archetype&&) = delete;
542    Archetype& operator=(const Archetype&) = default;
543    ~Archetype() = delete;
544    template <class T, typename std::enable_if<
545                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
546    Archetype(T&&) = delete;
547    template <class T, typename std::enable_if<
548                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
549    Archetype& operator=(T&&) = delete;
550    using ArchetypeSpecialMembersBase<
551        PropertiesOfT<Prof>::default_constructible_support,
552        PropertiesOfT<Prof>::move_constructible_support,
553        PropertiesOfT<Prof>::copy_constructible_support,
554        PropertiesOfT<Prof>::move_assignable_support,
555        PropertiesOfT<Prof>::copy_assignable_support,
556        PropertiesOfT<Prof>::destructible_support>::archetype_state;
557   private:
558    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
559        : ArchetypeSpecialMembersBase<
560              PropertiesOfT<Prof>::default_constructible_support,
561              PropertiesOfT<Prof>::move_constructible_support,
562              PropertiesOfT<Prof>::copy_constructible_support,
563              PropertiesOfT<Prof>::move_assignable_support,
564              PropertiesOfT<Prof>::copy_assignable_support,
565              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
566                                                         state) {}
567    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
568  };
569  template <class Prof>
570  class Archetype<Prof, typename std::enable_if<
571                            PropertiesOfT<Prof>::move_constructible_support ==
572                                move_constructible::maybe &&
573                            PropertiesOfT<Prof>::move_assignable_support ==
574                                move_assignable::maybe &&
575                            PropertiesOfT<Prof>::destructible_support ==
576                                destructible::maybe>::type>
577      : ArchetypeSpecialMembersBase<
578            PropertiesOfT<Prof>::default_constructible_support,
579            PropertiesOfT<Prof>::move_constructible_support,
580            PropertiesOfT<Prof>::copy_constructible_support,
581            PropertiesOfT<Prof>::move_assignable_support,
582            PropertiesOfT<Prof>::copy_assignable_support,
583            PropertiesOfT<Prof>::destructible_support> {
584   public:
585    Archetype() = default;
586    Archetype(Archetype&&) = delete;
587    Archetype(const Archetype&) = default;
588    Archetype& operator=(Archetype&&) = delete;
589    Archetype& operator=(const Archetype&) = default;
590    ~Archetype() = delete;
591    template <class T, typename std::enable_if<
592                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
593    Archetype(T&&) = delete;
594    template <class T, typename std::enable_if<
595                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
596    Archetype& operator=(T&&) = delete;
597    using ArchetypeSpecialMembersBase<
598        PropertiesOfT<Prof>::default_constructible_support,
599        PropertiesOfT<Prof>::move_constructible_support,
600        PropertiesOfT<Prof>::copy_constructible_support,
601        PropertiesOfT<Prof>::move_assignable_support,
602        PropertiesOfT<Prof>::copy_assignable_support,
603        PropertiesOfT<Prof>::destructible_support>::archetype_state;
604   private:
605    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
606        : ArchetypeSpecialMembersBase<
607              PropertiesOfT<Prof>::default_constructible_support,
608              PropertiesOfT<Prof>::move_constructible_support,
609              PropertiesOfT<Prof>::copy_constructible_support,
610              PropertiesOfT<Prof>::move_assignable_support,
611              PropertiesOfT<Prof>::copy_assignable_support,
612              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
613                                                         state) {}
614    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
615  };
616  template <class Prof>
617  class Archetype<Prof, typename std::enable_if<
618                            PropertiesOfT<Prof>::move_constructible_support ==
619                                move_constructible::maybe &&
620                            PropertiesOfT<Prof>::move_assignable_support !=
621                                move_assignable::maybe &&
622                            PropertiesOfT<Prof>::destructible_support ==
623                                destructible::maybe>::type>
624      : ArchetypeSpecialMembersBase<
625            PropertiesOfT<Prof>::default_constructible_support,
626            PropertiesOfT<Prof>::move_constructible_support,
627            PropertiesOfT<Prof>::copy_constructible_support,
628            PropertiesOfT<Prof>::move_assignable_support,
629            PropertiesOfT<Prof>::copy_assignable_support,
630            PropertiesOfT<Prof>::destructible_support> {
631   public:
632    Archetype() = default;
633    Archetype(Archetype&&) = delete;
634    Archetype(const Archetype&) = default;
635    Archetype& operator=(Archetype&&) = default;
636    Archetype& operator=(const Archetype&) = default;
637    ~Archetype() = delete;
638    template <class T, typename std::enable_if<
639                           ShouldDeleteConstructor<Prof, T>()>::type* = nullptr>
640    Archetype(T&&) = delete;
641    template <class T, typename std::enable_if<
642                           ShouldDeleteAssign<Prof, T>()>::type* = nullptr>
643    Archetype& operator=(T&&) = delete;
644    using ArchetypeSpecialMembersBase<
645        PropertiesOfT<Prof>::default_constructible_support,
646        PropertiesOfT<Prof>::move_constructible_support,
647        PropertiesOfT<Prof>::copy_constructible_support,
648        PropertiesOfT<Prof>::move_assignable_support,
649        PropertiesOfT<Prof>::copy_assignable_support,
650        PropertiesOfT<Prof>::destructible_support>::archetype_state;
651   private:
652    explicit Archetype(MakeArchetypeState, ArchetypeState state) noexcept
653        : ArchetypeSpecialMembersBase<
654              PropertiesOfT<Prof>::default_constructible_support,
655              PropertiesOfT<Prof>::move_constructible_support,
656              PropertiesOfT<Prof>::copy_constructible_support,
657              PropertiesOfT<Prof>::move_assignable_support,
658              PropertiesOfT<Prof>::copy_assignable_support,
659              PropertiesOfT<Prof>::destructible_support>(MakeArchetypeState(),
660                                                         state) {}
661    friend Archetype MakeArchetype<Archetype>(ArchetypeState) noexcept;
662  };
663  template <class Prof,
664            absl::enable_if_t<!PropertiesOfT<Prof>::is_swappable, int> = 0>
665  void swap(Archetype<Prof>&, Archetype<Prof>&) = delete;  
666  template <class Prof,
667            absl::enable_if_t<PropertiesOfT<Prof>::is_swappable, int> = 0>
668  void swap(Archetype<Prof>& lhs, Archetype<Prof>& rhs)  
669      noexcept(PropertiesOfT<Prof>::swappable_support != swappable::yes) {
670    std::swap(lhs.archetype_state, rhs.archetype_state);
671  }
672  struct NothrowBool {
673    explicit NothrowBool() = delete;
674    ~NothrowBool() = default;
675    NothrowBool& operator=(NothrowBool const&) = delete;
676    explicit operator bool() const noexcept { return value; }
677    static NothrowBool make(bool const value) noexcept {
678      return NothrowBool(value);
679    }
680   private:
681    explicit NothrowBool(bool const value) noexcept : value(value) {}
682    bool value;
683  };
684  struct ExceptionalBool {
685    explicit ExceptionalBool() = delete;
686    ~ExceptionalBool() = default;
687    ExceptionalBool& operator=(ExceptionalBool const&) = delete;
688    explicit operator bool() const { return value; }  
689    static ExceptionalBool make(bool const value) noexcept {
690      return ExceptionalBool(value);
691    }
692   private:
693    explicit ExceptionalBool(bool const value) noexcept : value(value) {}
694    bool value;
695  };
696  #define ABSL_TYPES_INTERNAL_OP(enum_name, op)                                \
697    template <class Prof>                                                      \
698    absl::enable_if_t<!PropertiesOfT<Prof>::is_##enum_name, bool> operator op( \
699        const Archetype<Prof>&, const Archetype<Prof>&) = delete;              \
700                                                                               \
701    template <class Prof>                                                      \
702    typename absl::enable_if_t<                                                \
703        PropertiesOfT<Prof>::is_##enum_name,                                   \
704        std::conditional<PropertiesOfT<Prof>::enum_name##_support ==           \
705                             enum_name::nothrow,                               \
706                         NothrowBool, ExceptionalBool>>::type                  \
707    operator op(const Archetype<Prof>& lhs,                                    \
708                const Archetype<Prof>& rhs) noexcept {                         \
709      return absl::conditional_t<                                              \
710          PropertiesOfT<Prof>::enum_name##_support == enum_name::nothrow,      \
711          NothrowBool, ExceptionalBool>::make(lhs.archetype_state op           \
712                                                  rhs.archetype_state);        \
713    }
714  ABSL_TYPES_INTERNAL_OP(equality_comparable, ==);
715  ABSL_TYPES_INTERNAL_OP(inequality_comparable, !=);
716  ABSL_TYPES_INTERNAL_OP(less_than_comparable, <);
717  ABSL_TYPES_INTERNAL_OP(less_equal_comparable, <=);
718  ABSL_TYPES_INTERNAL_OP(greater_equal_comparable, >=);
719  ABSL_TYPES_INTERNAL_OP(greater_than_comparable, >);
720  #undef ABSL_TYPES_INTERNAL_OP
721  struct PoisonedHash {
722    PoisonedHash() = delete;
723    PoisonedHash(const PoisonedHash&) = delete;
724    PoisonedHash& operator=(const PoisonedHash&) = delete;
725  };
726  template <class Prof>
727  struct EnabledHash {
728    using argument_type = Archetype<Prof>;
729    using result_type = std::size_t;
730    result_type operator()(const argument_type& arg) const {
731      return std::hash<ArchetypeState>()(arg.archetype_state);
732    }
733  };
734  }  
735  ABSL_NAMESPACE_END
736  }  
737  namespace std {
738  template <class Prof>  
739  struct hash<::absl::types_internal::Archetype<Prof>>
740      : conditional<::absl::types_internal::PropertiesOfT<Prof>::is_hashable,
741                    ::absl::types_internal::EnabledHash<Prof>,
742                    ::absl::types_internal::PoisonedHash>::type {};
743  }  
744  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-benchmark.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-conformance_archetype.h</div>
                </div>
                <div class="column column_space"><pre><code>20    inline bool has_run_at_least_once() { return has_run_at_least_once_; }
21   protected:
22    void Init();
23    bool initted_;
24    bool running_;
25    bool has_run_at_least_once_;
26  #ifndef CPU_ONLY
27    cudaEvent_t start_gpu_;
28    cudaEvent_t stop_gpu_;
29  #endif
30    boost::posix_time::ptime init_cpu_;
31    boost::posix_time::ptime start_cpu_;
32    boost::posix_time::ptime stop_cpu_;
33    float elapsed_milliseconds_;
34    float elapsed_microseconds_;
</pre></code></div>
                <div class="column column_space"><pre><code>410    Archetype& operator=(T&&) = delete;
411    using ArchetypeSpecialMembersBase<
412        PropertiesOfT<Prof>::default_constructible_support,
413        PropertiesOfT<Prof>::move_constructible_support,
414        PropertiesOfT<Prof>::copy_constructible_support,
415        PropertiesOfT<Prof>::move_assignable_support,
416        PropertiesOfT<Prof>::copy_assignable_support,
417        PropertiesOfT<Prof>::destructible_support>::archetype_state;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    