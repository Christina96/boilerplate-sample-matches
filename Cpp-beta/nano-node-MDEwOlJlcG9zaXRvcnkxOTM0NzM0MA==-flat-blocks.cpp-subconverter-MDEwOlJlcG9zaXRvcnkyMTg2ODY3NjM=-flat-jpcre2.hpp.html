
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.967391304347826%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blocks.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/blocks.hpp>
3  #include <nano/lib/memory.hpp>
4  #include <nano/lib/numbers.hpp>
5  #include <nano/lib/threading.hpp>
6  #include <nano/secure/common.hpp>
7  #include <boost/endian/conversion.hpp>
8  #include <boost/property_tree/json_parser.hpp>
9  #include <bitset>
10  #include <cryptopp/words.h>
11  namespace
12  {
13  template <typename T>
14  bool blocks_equal (T const & first, nano::block const & second)
15  {
16  	static_assert (std::is_base_of<nano::block, T>::value, "Input parameter is not a block type");
17  	return (first.type () == second.type ()) && (static_cast<T const &> (second)) == first;
18  }
19  template <typename block>
20  std::shared_ptr<block> deserialize_block (nano::stream & stream_a)
21  {
22  	auto error (false);
23  	auto result = nano::make_shared<block> (error, stream_a);
24  	if (error)
25  	{
26  		result = nullptr;
27  	}
28  	return result;
29  }
30  }
31  void nano::block_memory_pool_purge ()
32  {
33  	nano::purge_shared_ptr_singleton_pool_memory<nano::open_block> ();
34  	nano::purge_shared_ptr_singleton_pool_memory<nano::state_block> ();
35  	nano::purge_shared_ptr_singleton_pool_memory<nano::send_block> ();
36  	nano::purge_shared_ptr_singleton_pool_memory<nano::change_block> ();
37  }
38  std::string nano::block::to_json () const
39  {
40  	std::string result;
41  	serialize_json (result);
42  	return result;
43  }
44  size_t nano::block::size (nano::block_type type_a)
45  {
46  	size_t result (0);
47  	switch (type_a)
48  	{
49  		case nano::block_type::invalid:
50  		case nano::block_type::not_a_block:
51  			debug_assert (false);
52  			break;
53  		case nano::block_type::send:
54  			result = nano::send_block::size;
55  			break;
56  		case nano::block_type::receive:
57  			result = nano::receive_block::size;
58  			break;
59  		case nano::block_type::change:
60  			result = nano::change_block::size;
61  			break;
62  		case nano::block_type::open:
63  			result = nano::open_block::size;
64  			break;
65  		case nano::block_type::state:
66  			result = nano::state_block::size;
67  			break;
68  	}
69  	return result;
70  }
71  nano::work_version nano::block::work_version () const
72  {
73  	return nano::work_version::work_1;
74  }
75  nano::block_hash nano::block::generate_hash () const
76  {
77  	nano::block_hash result;
78  	blake2b_state hash_l;
79  	auto status (blake2b_init (&hash_l, sizeof (result.bytes)));
80  	debug_assert (status == 0);
81  	hash (hash_l);
82  	status = blake2b_final (&hash_l, result.bytes.data (), sizeof (result.bytes));
83  	debug_assert (status == 0);
84  	return result;
85  }
86  void nano::block::refresh ()
87  {
88  	if (!cached_hash.is_zero ())
89  	{
90  		cached_hash = generate_hash ();
91  	}
92  }
93  nano::block_hash const & nano::block::hash () const
94  {
95  	if (!cached_hash.is_zero ())
96  	{
97  		debug_assert (cached_hash == generate_hash ());
98  	}
99  	else
100  	{
101  		cached_hash = generate_hash ();
102  	}
103  	return cached_hash;
104  }
105  nano::block_hash nano::block::full_hash () const
106  {
107  	nano::block_hash result;
108  	blake2b_state state;
109  	blake2b_init (&state, sizeof (result.bytes));
110  	blake2b_update (&state, hash ().bytes.data (), sizeof (hash ()));
111  	auto signature (block_signature ());
112  	blake2b_update (&state, signature.bytes.data (), sizeof (signature));
113  	auto work (block_work ());
114  	blake2b_update (&state, &work, sizeof (work));
115  	blake2b_final (&state, result.bytes.data (), sizeof (result.bytes));
116  	return result;
117  }
118  nano::block_sideband const & nano::block::sideband () const
119  {
120  	debug_assert (sideband_m.is_initialized ());
121  	return *sideband_m;
122  }
123  void nano::block::sideband_set (nano::block_sideband const & sideband_a)
124  {
125  	sideband_m = sideband_a;
126  }
127  bool nano::block::has_sideband () const
128  {
129  	return sideband_m.is_initialized ();
130  }
131  nano::account const & nano::block::representative () const
132  {
133  	static nano::account representative{};
134  	return representative;
135  }
136  nano::block_hash const & nano::block::source () const
137  {
138  	static nano::block_hash source{ 0 };
139  	return source;
140  }
141  nano::account const & nano::block::destination () const
142  {
143  	static nano::account destination{};
144  	return destination;
145  }
146  nano::link const & nano::block::link () const
147  {
148  	static nano::link link{ 0 };
149  	return link;
150  }
151  nano::account const & nano::block::account () const
152  {
153  	static nano::account account{};
154  	return account;
155  }
156  nano::qualified_root nano::block::qualified_root () const
157  {
158  	return nano::qualified_root (root (), previous ());
159  }
160  nano::amount const & nano::block::balance () const
161  {
162  	static nano::amount amount{ 0 };
163  	return amount;
164  }
165  void nano::send_block::visit (nano::block_visitor & visitor_a) const
166  {
167  	visitor_a.send_block (*this);
168  }
169  void nano::send_block::visit (nano::mutable_block_visitor & visitor_a)
170  {
171  	visitor_a.send_block (*this);
172  }
173  void nano::send_block::hash (blake2b_state & hash_a) const
174  {
175  	hashables.hash (hash_a);
176  }
177  uint64_t nano::send_block::block_work () const
178  {
179  	return work;
180  }
181  void nano::send_block::block_work_set (uint64_t work_a)
182  {
183  	work = work_a;
184  }
185  nano::send_hashables::send_hashables (nano::block_hash const & previous_a, nano::account const & destination_a, nano::amount const & balance_a) :
186  	previous (previous_a),
187  	destination (destination_a),
188  	balance (balance_a)
189  {
190  }
191  nano::send_hashables::send_hashables (bool & error_a, nano::stream & stream_a)
192  {
193  	try
194  	{
195  		nano::read (stream_a, previous.bytes);
196  		nano::read (stream_a, destination.bytes);
197  		nano::read (stream_a, balance.bytes);
198  	}
199  	catch (std::runtime_error const &)
200  	{
201  		error_a = true;
202  	}
203  }
204  nano::send_hashables::send_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
205  {
206  	try
207  	{
208  		auto previous_l (tree_a.get<std::string> ("previous"));
209  		auto destination_l (tree_a.get<std::string> ("destination"));
210  		auto balance_l (tree_a.get<std::string> ("balance"));
211  		error_a = previous.decode_hex (previous_l);
212  		if (!error_a)
213  		{
214  			error_a = destination.decode_account (destination_l);
215  			if (!error_a)
216  			{
217  				error_a = balance.decode_hex (balance_l);
218  			}
219  		}
220  	}
221  	catch (std::runtime_error const &)
222  	{
223  		error_a = true;
224  	}
225  }
226  void nano::send_hashables::hash (blake2b_state & hash_a) const
227  {
228  	auto status (blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes)));
229  	debug_assert (status == 0);
230  	status = blake2b_update (&hash_a, destination.bytes.data (), sizeof (destination.bytes));
231  	debug_assert (status == 0);
232  	status = blake2b_update (&hash_a, balance.bytes.data (), sizeof (balance.bytes));
233  	debug_assert (status == 0);
234  }
235  void nano::send_block::serialize (nano::stream & stream_a) const
236  {
237  	write (stream_a, hashables.previous.bytes);
238  	write (stream_a, hashables.destination.bytes);
239  	write (stream_a, hashables.balance.bytes);
240  	write (stream_a, signature.bytes);
241  	write (stream_a, work);
242  }
243  bool nano::send_block::deserialize (nano::stream & stream_a)
244  {
245  	auto error (false);
246  	try
247  	{
248  		read (stream_a, hashables.previous.bytes);
249  		read (stream_a, hashables.destination.bytes);
250  		read (stream_a, hashables.balance.bytes);
251  		read (stream_a, signature.bytes);
252  		read (stream_a, work);
253  	}
254  	catch (std::exception const &)
255  	{
256  		error = true;
257  	}
258  	return error;
259  }
260  void nano::send_block::serialize_json (std::string & string_a, bool single_line) const
261  {
262  	boost::property_tree::ptree tree;
263  	serialize_json (tree);
264  	std::stringstream ostream;
265  	boost::property_tree::write_json (ostream, tree, !single_line);
266  	string_a = ostream.str ();
267  }
268  void nano::send_block::serialize_json (boost::property_tree::ptree & tree) const
269  {
270  	tree.put ("type", "send");
271  	std::string previous;
272  	hashables.previous.encode_hex (previous);
273  	tree.put ("previous", previous);
274  	tree.put ("destination", hashables.destination.to_account ());
275  	std::string balance;
276  	hashables.balance.encode_hex (balance);
277  	tree.put ("balance", balance);
278  	std::string signature_l;
279  	signature.encode_hex (signature_l);
280  	tree.put ("work", nano::to_string_hex (work));
281  	tree.put ("signature", signature_l);
282  }
283  bool nano::send_block::deserialize_json (boost::property_tree::ptree const & tree_a)
284  {
285  	auto error (false);
286  	try
287  	{
288  		debug_assert (tree_a.get<std::string> ("type") == "send");
289  		auto previous_l (tree_a.get<std::string> ("previous"));
290  		auto destination_l (tree_a.get<std::string> ("destination"));
291  		auto balance_l (tree_a.get<std::string> ("balance"));
292  		auto work_l (tree_a.get<std::string> ("work"));
293  		auto signature_l (tree_a.get<std::string> ("signature"));
294  		error = hashables.previous.decode_hex (previous_l);
295  		if (!error)
296  		{
297  			error = hashables.destination.decode_account (destination_l);
298  			if (!error)
299  			{
300  				error = hashables.balance.decode_hex (balance_l);
301  				if (!error)
302  				{
303  					error = nano::from_string_hex (work_l, work);
304  					if (!error)
305  					{
306  						error = signature.decode_hex (signature_l);
307  					}
308  				}
309  			}
310  		}
311  	}
312  	catch (std::runtime_error const &)
313  	{
314  		error = true;
315  	}
316  	return error;
317  }
318  nano::send_block::send_block (nano::block_hash const & previous_a, nano::account const & destination_a, nano::amount const & balance_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
319  	hashables (previous_a, destination_a, balance_a),
320  	signature (nano::sign_message (prv_a, pub_a, hash ())),
321  	work (work_a)
322  {
323  	debug_assert (destination_a != nullptr);
324  	debug_assert (pub_a != nullptr);
325  }
326  nano::send_block::send_block (bool & error_a, nano::stream & stream_a) :
327  	hashables (error_a, stream_a)
328  {
329  	if (!error_a)
330  	{
331  		try
332  		{
333  			nano::read (stream_a, signature.bytes);
334  			nano::read (stream_a, work);
335  		}
336  		catch (std::runtime_error const &)
337  		{
338  			error_a = true;
339  		}
340  	}
341  }
342  nano::send_block::send_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
343  	hashables (error_a, tree_a)
344  {
345  	if (!error_a)
346  	{
347  		try
348  		{
349  			auto signature_l (tree_a.get<std::string> ("signature"));
350  			auto work_l (tree_a.get<std::string> ("work"));
351  			error_a = signature.decode_hex (signature_l);
352  			if (!error_a)
353  			{
354  				error_a = nano::from_string_hex (work_l, work);
355  			}
356  		}
357  		catch (std::runtime_error const &)
358  		{
359  			error_a = true;
360  		}
361  	}
362  }
363  bool nano::send_block::operator== (nano::block const & other_a) const
364  {
365  	return blocks_equal (*this, other_a);
366  }
367  bool nano::send_block::valid_predecessor (nano::block const & block_a) const
368  {
369  	bool result;
370  	switch (block_a.type ())
371  	{
372  		case nano::block_type::send:
373  		case nano::block_type::receive:
374  		case nano::block_type::open:
375  		case nano::block_type::change:
376  			result = true;
377  			break;
378  		default:
379  			result = false;
380  			break;
381  	}
382  	return result;
383  }
384  nano::block_type nano::send_block::type () const
385  {
386  	return nano::block_type::send;
387  }
388  bool nano::send_block::operator== (nano::send_block const & other_a) const
389  {
390  	auto result (hashables.destination == other_a.hashables.destination && hashables.previous == other_a.hashables.previous && hashables.balance == other_a.hashables.balance && work == other_a.work && signature == other_a.signature);
391  	return result;
392  }
393  nano::block_hash const & nano::send_block::previous () const
394  {
395  	return hashables.previous;
396  }
397  nano::account const & nano::send_block::destination () const
398  {
399  	return hashables.destination;
400  }
401  nano::root const & nano::send_block::root () const
402  {
403  	return hashables.previous;
404  }
405  nano::amount const & nano::send_block::balance () const
406  {
407  	return hashables.balance;
408  }
409  nano::signature const & nano::send_block::block_signature () const
410  {
411  	return signature;
412  }
413  void nano::send_block::signature_set (nano::signature const & signature_a)
414  {
415  	signature = signature_a;
416  }
417  nano::open_hashables::open_hashables (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a) :
418  	source (source_a),
419  	representative (representative_a),
420  	account (account_a)
421  {
422  }
423  nano::open_hashables::open_hashables (bool & error_a, nano::stream & stream_a)
424  {
425  	try
426  	{
427  		nano::read (stream_a, source.bytes);
428  		nano::read (stream_a, representative.bytes);
429  		nano::read (stream_a, account.bytes);
430  	}
431  	catch (std::runtime_error const &)
432  	{
433  		error_a = true;
434  	}
435  }
436  nano::open_hashables::open_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
437  {
438  	try
439  	{
440  		auto source_l (tree_a.get<std::string> ("source"));
441  		auto representative_l (tree_a.get<std::string> ("representative"));
442  		auto account_l (tree_a.get<std::string> ("account"));
443  		error_a = source.decode_hex (source_l);
444  		if (!error_a)
445  		{
446  			error_a = representative.decode_account (representative_l);
447  			if (!error_a)
448  			{
449  				error_a = account.decode_account (account_l);
450  			}
451  		}
452  	}
453  	catch (std::runtime_error const &)
454  	{
455  		error_a = true;
456  	}
457  }
458  void nano::open_hashables::hash (blake2b_state & hash_a) const
459  {
460  	blake2b_update (&hash_a, source.bytes.data (), sizeof (source.bytes));
461  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
462  	blake2b_update (&hash_a, account.bytes.data (), sizeof (account.bytes));
463  }
464  nano::open_block::open_block (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
465  	hashables (source_a, representative_a, account_a),
466  	signature (nano::sign_message (prv_a, pub_a, hash ())),
467  	work (work_a)
468  {
469  	debug_assert (representative_a != nullptr);
470  	debug_assert (account_a != nullptr);
471  	debug_assert (pub_a != nullptr);
472  }
473  nano::open_block::open_block (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a, std::nullptr_t) :
474  	hashables (source_a, representative_a, account_a),
475  	work (0)
476  {
477  	debug_assert (representative_a != nullptr);
478  	debug_assert (account_a != nullptr);
479  	signature.clear ();
480  }
481  nano::open_block::open_block (bool & error_a, nano::stream & stream_a) :
482  	hashables (error_a, stream_a)
483  {
484  	if (!error_a)
485  	{
486  		try
487  		{
488  			nano::read (stream_a, signature);
489  			nano::read (stream_a, work);
490  		}
491  		catch (std::runtime_error const &)
492  		{
493  			error_a = true;
494  		}
495  	}
496  }
497  nano::open_block::open_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
498  	hashables (error_a, tree_a)
499  {
500  	if (!error_a)
501  	{
502  		try
503  		{
504  			auto work_l (tree_a.get<std::string> ("work"));
505  			auto signature_l (tree_a.get<std::string> ("signature"));
506  			error_a = nano::from_string_hex (work_l, work);
507  			if (!error_a)
508  			{
509  				error_a = signature.decode_hex (signature_l);
510  			}
511  		}
512  		catch (std::runtime_error const &)
513  		{
514  			error_a = true;
515  		}
516  	}
517  }
518  void nano::open_block::hash (blake2b_state & hash_a) const
519  {
520  	hashables.hash (hash_a);
521  }
522  uint64_t nano::open_block::block_work () const
523  {
524  	return work;
525  }
526  void nano::open_block::block_work_set (uint64_t work_a)
527  {
528  	work = work_a;
529  }
530  nano::block_hash const & nano::open_block::previous () const
531  {
532  	static nano::block_hash result{ 0 };
533  	return result;
534  }
535  nano::account const & nano::open_block::account () const
536  {
537  	return hashables.account;
538  }
539  void nano::open_block::serialize (nano::stream & stream_a) const
540  {
541  	write (stream_a, hashables.source);
542  	write (stream_a, hashables.representative);
543  	write (stream_a, hashables.account);
544  	write (stream_a, signature);
545  	write (stream_a, work);
546  }
547  bool nano::open_block::deserialize (nano::stream & stream_a)
548  {
549  	auto error (false);
550  	try
551  	{
552  		read (stream_a, hashables.source);
553  		read (stream_a, hashables.representative);
554  		read (stream_a, hashables.account);
555  		read (stream_a, signature);
556  		read (stream_a, work);
557  	}
558  	catch (std::runtime_error const &)
559  	{
560  		error = true;
561  	}
562  	return error;
563  }
564  void nano::open_block::serialize_json (std::string & string_a, bool single_line) const
565  {
566  	boost::property_tree::ptree tree;
567  	serialize_json (tree);
568  	std::stringstream ostream;
569  	boost::property_tree::write_json (ostream, tree, !single_line);
570  	string_a = ostream.str ();
571  }
572  void nano::open_block::serialize_json (boost::property_tree::ptree & tree) const
573  {
574  	tree.put ("type", "open");
575  	tree.put ("source", hashables.source.to_string ());
576  	tree.put ("representative", representative ().to_account ());
577  	tree.put ("account", hashables.account.to_account ());
578  	std::string signature_l;
579  	signature.encode_hex (signature_l);
580  	tree.put ("work", nano::to_string_hex (work));
581  	tree.put ("signature", signature_l);
582  }
583  bool nano::open_block::deserialize_json (boost::property_tree::ptree const & tree_a)
584  {
585  	auto error (false);
586  	try
587  	{
588  		debug_assert (tree_a.get<std::string> ("type") == "open");
589  		auto source_l (tree_a.get<std::string> ("source"));
590  		auto representative_l (tree_a.get<std::string> ("representative"));
591  		auto account_l (tree_a.get<std::string> ("account"));
592  		auto work_l (tree_a.get<std::string> ("work"));
593  		auto signature_l (tree_a.get<std::string> ("signature"));
594  		error = hashables.source.decode_hex (source_l);
595  		if (!error)
596  		{
597  			error = hashables.representative.decode_hex (representative_l);
598  			if (!error)
599  			{
600  				error = hashables.account.decode_hex (account_l);
601  				if (!error)
602  				{
603  					error = nano::from_string_hex (work_l, work);
604  					if (!error)
605  					{
606  						error = signature.decode_hex (signature_l);
607  					}
608  				}
609  			}
610  		}
611  	}
612  	catch (std::runtime_error const &)
613  	{
614  		error = true;
615  	}
616  	return error;
617  }
618  void nano::open_block::visit (nano::block_visitor & visitor_a) const
619  {
620  	visitor_a.open_block (*this);
621  }
622  void nano::open_block::visit (nano::mutable_block_visitor & visitor_a)
623  {
624  	visitor_a.open_block (*this);
625  }
626  nano::block_type nano::open_block::type () const
627  {
628  	return nano::block_type::open;
629  }
630  bool nano::open_block::operator== (nano::block const & other_a) const
631  {
632  	return blocks_equal (*this, other_a);
633  }
634  bool nano::open_block::operator== (nano::open_block const & other_a) const
635  {
636  	return hashables.source == other_a.hashables.source && hashables.representative == other_a.hashables.representative && hashables.account == other_a.hashables.account && work == other_a.work && signature == other_a.signature;
637  }
638  bool nano::open_block::valid_predecessor (nano::block const & block_a) const
639  {
640  	return false;
641  }
642  nano::block_hash const & nano::open_block::source () const
643  {
644  	return hashables.source;
645  }
646  nano::root const & nano::open_block::root () const
647  {
648  	return hashables.account;
649  }
650  nano::account const & nano::open_block::representative () const
651  {
652  	return hashables.representative;
653  }
654  nano::signature const & nano::open_block::block_signature () const
655  {
656  	return signature;
657  }
658  void nano::open_block::signature_set (nano::signature const & signature_a)
659  {
660  	signature = signature_a;
661  }
662  nano::change_hashables::change_hashables (nano::block_hash const & previous_a, nano::account const & representative_a) :
663  	previous (previous_a),
664  	representative (representative_a)
665  {
666  }
667  nano::change_hashables::change_hashables (bool & error_a, nano::stream & stream_a)
668  {
669  	try
670  	{
671  		nano::read (stream_a, previous);
672  		nano::read (stream_a, representative);
673  	}
674  	catch (std::runtime_error const &)
675  	{
676  		error_a = true;
677  	}
678  }
679  nano::change_hashables::change_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
680  {
681  	try
682  	{
683  		auto previous_l (tree_a.get<std::string> ("previous"));
684  		auto representative_l (tree_a.get<std::string> ("representative"));
685  		error_a = previous.decode_hex (previous_l);
686  		if (!error_a)
687  		{
688  			error_a = representative.decode_account (representative_l);
689  		}
690  	}
691  	catch (std::runtime_error const &)
692  	{
693  		error_a = true;
694  	}
695  }
696  void nano::change_hashables::hash (blake2b_state & hash_a) const
697  {
698  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
699  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
700  }
701  nano::change_block::change_block (nano::block_hash const & previous_a, nano::account const & representative_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
702  	hashables (previous_a, representative_a),
703  	signature (nano::sign_message (prv_a, pub_a, hash ())),
704  	work (work_a)
705  {
706  	debug_assert (representative_a != nullptr);
707  	debug_assert (pub_a != nullptr);
708  }
709  nano::change_block::change_block (bool & error_a, nano::stream & stream_a) :
710  	hashables (error_a, stream_a)
711  {
712  	if (!error_a)
713  	{
714  		try
715  		{
716  			nano::read (stream_a, signature);
717  			nano::read (stream_a, work);
718  		}
719  		catch (std::runtime_error const &)
720  		{
721  			error_a = true;
722  		}
723  	}
724  }
725  nano::change_block::change_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
726  	hashables (error_a, tree_a)
727  {
728  	if (!error_a)
729  	{
730  		try
731  		{
732  			auto work_l (tree_a.get<std::string> ("work"));
733  			auto signature_l (tree_a.get<std::string> ("signature"));
734  			error_a = nano::from_string_hex (work_l, work);
735  			if (!error_a)
736  			{
737  				error_a = signature.decode_hex (signature_l);
738  			}
739  		}
740  		catch (std::runtime_error const &)
741  		{
742  			error_a = true;
743  		}
744  	}
745  }
746  void nano::change_block::hash (blake2b_state & hash_a) const
747  {
748  	hashables.hash (hash_a);
749  }
750  uint64_t nano::change_block::block_work () const
751  {
752  	return work;
753  }
754  void nano::change_block::block_work_set (uint64_t work_a)
755  {
756  	work = work_a;
757  }
758  nano::block_hash const & nano::change_block::previous () const
759  {
760  	return hashables.previous;
761  }
762  void nano::change_block::serialize (nano::stream & stream_a) const
763  {
764  	write (stream_a, hashables.previous);
765  	write (stream_a, hashables.representative);
766  	write (stream_a, signature);
767  	write (stream_a, work);
768  }
769  bool nano::change_block::deserialize (nano::stream & stream_a)
770  {
771  	auto error (false);
772  	try
773  	{
774  		read (stream_a, hashables.previous);
775  		read (stream_a, hashables.representative);
776  		read (stream_a, signature);
777  		read (stream_a, work);
778  	}
779  	catch (std::runtime_error const &)
780  	{
781  		error = true;
782  	}
783  	return error;
784  }
785  void nano::change_block::serialize_json (std::string & string_a, bool single_line) const
786  {
787  	boost::property_tree::ptree tree;
788  	serialize_json (tree);
789  	std::stringstream ostream;
790  	boost::property_tree::write_json (ostream, tree, !single_line);
791  	string_a = ostream.str ();
792  }
793  void nano::change_block::serialize_json (boost::property_tree::ptree & tree) const
794  {
795  	tree.put ("type", "change");
796  	tree.put ("previous", hashables.previous.to_string ());
797  	tree.put ("representative", representative ().to_account ());
798  	tree.put ("work", nano::to_string_hex (work));
799  	std::string signature_l;
800  	signature.encode_hex (signature_l);
801  	tree.put ("signature", signature_l);
802  }
803  bool nano::change_block::deserialize_json (boost::property_tree::ptree const & tree_a)
804  {
805  	auto error (false);
806  	try
807  	{
808  		debug_assert (tree_a.get<std::string> ("type") == "change");
809  		auto previous_l (tree_a.get<std::string> ("previous"));
810  		auto representative_l (tree_a.get<std::string> ("representative"));
811  		auto work_l (tree_a.get<std::string> ("work"));
812  		auto signature_l (tree_a.get<std::string> ("signature"));
813  		error = hashables.previous.decode_hex (previous_l);
814  		if (!error)
815  		{
816  			error = hashables.representative.decode_hex (representative_l);
817  			if (!error)
818  			{
819  				error = nano::from_string_hex (work_l, work);
820  				if (!error)
821  				{
822  					error = signature.decode_hex (signature_l);
823  				}
824  			}
825  		}
826  	}
827  	catch (std::runtime_error const &)
828  	{
829  		error = true;
830  	}
831  	return error;
832  }
833  void nano::change_block::visit (nano::block_visitor & visitor_a) const
834  {
835  	visitor_a.change_block (*this);
836  }
837  void nano::change_block::visit (nano::mutable_block_visitor & visitor_a)
838  {
839  	visitor_a.change_block (*this);
840  }
841  nano::block_type nano::change_block::type () const
842  {
843  	return nano::block_type::change;
844  }
845  bool nano::change_block::operator== (nano::block const & other_a) const
846  {
847  	return blocks_equal (*this, other_a);
848  }
849  bool nano::change_block::operator== (nano::change_block const & other_a) const
850  {
851  	return hashables.previous == other_a.hashables.previous && hashables.representative == other_a.hashables.representative && work == other_a.work && signature == other_a.signature;
852  }
853  bool nano::change_block::valid_predecessor (nano::block const & block_a) const
854  {
855  	bool result;
856  	switch (block_a.type ())
857  	{
858  		case nano::block_type::send:
859  		case nano::block_type::receive:
860  		case nano::block_type::open:
861  		case nano::block_type::change:
862  			result = true;
863  			break;
864  		default:
865  			result = false;
866  			break;
867  	}
<span onclick='openModal()' class='match'>868  	return result;
869  }
870  nano::root const & nano::change_block::root () const
871  {
872  	return hashables.previous;
873  }
874  nano::account const & nano::change_block::representative () const
875  {
876  	return hashables.representative;
877  }
878  nano::signature const & nano::change_block::block_signature () const
879  {
880  	return signature;
</span>881  }
882  void nano::change_block::signature_set (nano::signature const & signature_a)
883  {
884  	signature = signature_a;
885  }
886  nano::state_hashables::state_hashables (nano::account const & account_a, nano::block_hash const & previous_a, nano::account const & representative_a, nano::amount const & balance_a, nano::link const & link_a) :
887  	account (account_a),
888  	previous (previous_a),
889  	representative (representative_a),
890  	balance (balance_a),
891  	link (link_a)
892  {
893  }
894  nano::state_hashables::state_hashables (bool & error_a, nano::stream & stream_a)
895  {
896  	try
897  	{
898  		nano::read (stream_a, account);
899  		nano::read (stream_a, previous);
900  		nano::read (stream_a, representative);
901  		nano::read (stream_a, balance);
902  		nano::read (stream_a, link);
903  	}
904  	catch (std::runtime_error const &)
905  	{
906  		error_a = true;
907  	}
908  }
909  nano::state_hashables::state_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
910  {
911  	try
912  	{
913  		auto account_l (tree_a.get<std::string> ("account"));
914  		auto previous_l (tree_a.get<std::string> ("previous"));
915  		auto representative_l (tree_a.get<std::string> ("representative"));
916  		auto balance_l (tree_a.get<std::string> ("balance"));
917  		auto link_l (tree_a.get<std::string> ("link"));
918  		error_a = account.decode_account (account_l);
919  		if (!error_a)
920  		{
921  			error_a = previous.decode_hex (previous_l);
922  			if (!error_a)
923  			{
924  				error_a = representative.decode_account (representative_l);
925  				if (!error_a)
926  				{
927  					error_a = balance.decode_dec (balance_l);
928  					if (!error_a)
929  					{
930  						error_a = link.decode_account (link_l) && link.decode_hex (link_l);
931  					}
932  				}
933  			}
934  		}
935  	}
936  	catch (std::runtime_error const &)
937  	{
938  		error_a = true;
939  	}
940  }
941  void nano::state_hashables::hash (blake2b_state & hash_a) const
942  {
943  	blake2b_update (&hash_a, account.bytes.data (), sizeof (account.bytes));
944  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
945  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
946  	blake2b_update (&hash_a, balance.bytes.data (), sizeof (balance.bytes));
947  	blake2b_update (&hash_a, link.bytes.data (), sizeof (link.bytes));
948  }
949  nano::state_block::state_block (nano::account const & account_a, nano::block_hash const & previous_a, nano::account const & representative_a, nano::amount const & balance_a, nano::link const & link_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
950  	hashables (account_a, previous_a, representative_a, balance_a, link_a),
951  	signature (nano::sign_message (prv_a, pub_a, hash ())),
952  	work (work_a)
953  {
954  	debug_assert (account_a != nullptr);
955  	debug_assert (representative_a != nullptr);
956  	debug_assert (link_a.as_account () != nullptr);
957  	debug_assert (pub_a != nullptr);
958  }
959  nano::state_block::state_block (bool & error_a, nano::stream & stream_a) :
960  	hashables (error_a, stream_a)
961  {
962  	if (!error_a)
963  	{
964  		try
965  		{
966  			nano::read (stream_a, signature);
967  			nano::read (stream_a, work);
968  			boost::endian::big_to_native_inplace (work);
969  		}
970  		catch (std::runtime_error const &)
971  		{
972  			error_a = true;
973  		}
974  	}
975  }
976  nano::state_block::state_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
977  	hashables (error_a, tree_a)
978  {
979  	if (!error_a)
980  	{
981  		try
982  		{
983  			auto type_l (tree_a.get<std::string> ("type"));
984  			auto signature_l (tree_a.get<std::string> ("signature"));
985  			auto work_l (tree_a.get<std::string> ("work"));
986  			error_a = type_l != "state";
987  			if (!error_a)
988  			{
989  				error_a = nano::from_string_hex (work_l, work);
990  				if (!error_a)
991  				{
992  					error_a = signature.decode_hex (signature_l);
993  				}
994  			}
995  		}
996  		catch (std::runtime_error const &)
997  		{
998  			error_a = true;
999  		}
1000  	}
1001  }
1002  void nano::state_block::hash (blake2b_state & hash_a) const
1003  {
1004  	nano::uint256_union preamble (static_cast<uint64_t> (nano::block_type::state));
1005  	blake2b_update (&hash_a, preamble.bytes.data (), preamble.bytes.size ());
1006  	hashables.hash (hash_a);
1007  }
1008  uint64_t nano::state_block::block_work () const
1009  {
1010  	return work;
1011  }
1012  void nano::state_block::block_work_set (uint64_t work_a)
1013  {
1014  	work = work_a;
1015  }
1016  nano::block_hash const & nano::state_block::previous () const
1017  {
1018  	return hashables.previous;
1019  }
1020  nano::account const & nano::state_block::account () const
1021  {
1022  	return hashables.account;
1023  }
1024  void nano::state_block::serialize (nano::stream & stream_a) const
1025  {
1026  	write (stream_a, hashables.account);
1027  	write (stream_a, hashables.previous);
1028  	write (stream_a, hashables.representative);
1029  	write (stream_a, hashables.balance);
1030  	write (stream_a, hashables.link);
1031  	write (stream_a, signature);
1032  	write (stream_a, boost::endian::native_to_big (work));
1033  }
1034  bool nano::state_block::deserialize (nano::stream & stream_a)
1035  {
1036  	auto error (false);
1037  	try
1038  	{
1039  		read (stream_a, hashables.account);
1040  		read (stream_a, hashables.previous);
1041  		read (stream_a, hashables.representative);
1042  		read (stream_a, hashables.balance);
1043  		read (stream_a, hashables.link);
1044  		read (stream_a, signature);
1045  		read (stream_a, work);
1046  		boost::endian::big_to_native_inplace (work);
1047  	}
1048  	catch (std::runtime_error const &)
1049  	{
1050  		error = true;
1051  	}
1052  	return error;
1053  }
1054  void nano::state_block::serialize_json (std::string & string_a, bool single_line) const
1055  {
1056  	boost::property_tree::ptree tree;
1057  	serialize_json (tree);
1058  	std::stringstream ostream;
1059  	boost::property_tree::write_json (ostream, tree, !single_line);
1060  	string_a = ostream.str ();
1061  }
1062  void nano::state_block::serialize_json (boost::property_tree::ptree & tree) const
1063  {
1064  	tree.put ("type", "state");
1065  	tree.put ("account", hashables.account.to_account ());
1066  	tree.put ("previous", hashables.previous.to_string ());
1067  	tree.put ("representative", representative ().to_account ());
1068  	tree.put ("balance", hashables.balance.to_string_dec ());
1069  	tree.put ("link", hashables.link.to_string ());
1070  	tree.put ("link_as_account", hashables.link.to_account ());
1071  	std::string signature_l;
1072  	signature.encode_hex (signature_l);
1073  	tree.put ("signature", signature_l);
1074  	tree.put ("work", nano::to_string_hex (work));
1075  }
1076  bool nano::state_block::deserialize_json (boost::property_tree::ptree const & tree_a)
1077  {
1078  	auto error (false);
1079  	try
1080  	{
1081  		debug_assert (tree_a.get<std::string> ("type") == "state");
1082  		auto account_l (tree_a.get<std::string> ("account"));
1083  		auto previous_l (tree_a.get<std::string> ("previous"));
1084  		auto representative_l (tree_a.get<std::string> ("representative"));
1085  		auto balance_l (tree_a.get<std::string> ("balance"));
1086  		auto link_l (tree_a.get<std::string> ("link"));
1087  		auto work_l (tree_a.get<std::string> ("work"));
1088  		auto signature_l (tree_a.get<std::string> ("signature"));
1089  		error = hashables.account.decode_account (account_l);
1090  		if (!error)
1091  		{
1092  			error = hashables.previous.decode_hex (previous_l);
1093  			if (!error)
1094  			{
1095  				error = hashables.representative.decode_account (representative_l);
1096  				if (!error)
1097  				{
1098  					error = hashables.balance.decode_dec (balance_l);
1099  					if (!error)
1100  					{
1101  						error = hashables.link.decode_account (link_l) && hashables.link.decode_hex (link_l);
1102  						if (!error)
1103  						{
1104  							error = nano::from_string_hex (work_l, work);
1105  							if (!error)
1106  							{
1107  								error = signature.decode_hex (signature_l);
1108  							}
1109  						}
1110  					}
1111  				}
1112  			}
1113  		}
1114  	}
1115  	catch (std::runtime_error const &)
1116  	{
1117  		error = true;
1118  	}
1119  	return error;
1120  }
1121  void nano::state_block::visit (nano::block_visitor & visitor_a) const
1122  {
1123  	visitor_a.state_block (*this);
1124  }
1125  void nano::state_block::visit (nano::mutable_block_visitor & visitor_a)
1126  {
1127  	visitor_a.state_block (*this);
1128  }
1129  nano::block_type nano::state_block::type () const
1130  {
1131  	return nano::block_type::state;
1132  }
1133  bool nano::state_block::operator== (nano::block const & other_a) const
1134  {
1135  	return blocks_equal (*this, other_a);
1136  }
1137  bool nano::state_block::operator== (nano::state_block const & other_a) const
1138  {
1139  	return hashables.account == other_a.hashables.account && hashables.previous == other_a.hashables.previous && hashables.representative == other_a.hashables.representative && hashables.balance == other_a.hashables.balance && hashables.link == other_a.hashables.link && signature == other_a.signature && work == other_a.work;
1140  }
1141  bool nano::state_block::valid_predecessor (nano::block const & block_a) const
1142  {
1143  	return true;
1144  }
1145  nano::root const & nano::state_block::root () const
1146  {
1147  	if (!hashables.previous.is_zero ())
1148  	{
1149  		return hashables.previous;
1150  	}
1151  	else
1152  	{
1153  		return hashables.account;
1154  	}
1155  }
1156  nano::link const & nano::state_block::link () const
1157  {
1158  	return hashables.link;
1159  }
1160  nano::account const & nano::state_block::representative () const
1161  {
1162  	return hashables.representative;
1163  }
1164  nano::amount const & nano::state_block::balance () const
1165  {
1166  	return hashables.balance;
1167  }
1168  nano::signature const & nano::state_block::block_signature () const
1169  {
1170  	return signature;
1171  }
1172  void nano::state_block::signature_set (nano::signature const & signature_a)
1173  {
1174  	signature = signature_a;
1175  }
1176  std::shared_ptr<nano::block> nano::deserialize_block_json (boost::property_tree::ptree const & tree_a, nano::block_uniquer * uniquer_a)
1177  {
1178  	std::shared_ptr<nano::block> result;
1179  	try
1180  	{
1181  		auto type (tree_a.get<std::string> ("type"));
1182  		bool error (false);
1183  		std::unique_ptr<nano::block> obj;
1184  		if (type == "receive")
1185  		{
1186  			obj = std::make_unique<nano::receive_block> (error, tree_a);
1187  		}
1188  		else if (type == "send")
1189  		{
1190  			obj = std::make_unique<nano::send_block> (error, tree_a);
1191  		}
1192  		else if (type == "open")
1193  		{
1194  			obj = std::make_unique<nano::open_block> (error, tree_a);
1195  		}
1196  		else if (type == "change")
1197  		{
1198  			obj = std::make_unique<nano::change_block> (error, tree_a);
1199  		}
1200  		else if (type == "state")
1201  		{
1202  			obj = std::make_unique<nano::state_block> (error, tree_a);
1203  		}
1204  		if (!error)
1205  		{
1206  			result = std::move (obj);
1207  		}
1208  	}
1209  	catch (std::runtime_error const &)
1210  	{
1211  	}
1212  	if (uniquer_a != nullptr)
1213  	{
1214  		result = uniquer_a->unique (result);
1215  	}
1216  	return result;
1217  }
1218  void nano::serialize_block_type (nano::stream & stream, const nano::block_type & type)
1219  {
1220  	nano::write (stream, type);
1221  }
1222  void nano::serialize_block (nano::stream & stream_a, nano::block const & block_a)
1223  {
1224  	nano::serialize_block_type (stream_a, block_a.type ());
1225  	block_a.serialize (stream_a);
1226  }
1227  std::shared_ptr<nano::block> nano::deserialize_block (nano::stream & stream_a)
1228  {
1229  	nano::block_type type;
1230  	auto error (try_read (stream_a, type));
1231  	std::shared_ptr<nano::block> result;
1232  	if (!error)
1233  	{
1234  		result = nano::deserialize_block (stream_a, type);
1235  	}
1236  	return result;
1237  }
1238  std::shared_ptr<nano::block> nano::deserialize_block (nano::stream & stream_a, nano::block_type type_a, nano::block_uniquer * uniquer_a)
1239  {
1240  	std::shared_ptr<nano::block> result;
1241  	switch (type_a)
1242  	{
1243  		case nano::block_type::receive:
1244  		{
1245  			result = ::deserialize_block<nano::receive_block> (stream_a);
1246  			break;
1247  		}
1248  		case nano::block_type::send:
1249  		{
1250  			result = ::deserialize_block<nano::send_block> (stream_a);
1251  			break;
1252  		}
1253  		case nano::block_type::open:
1254  		{
1255  			result = ::deserialize_block<nano::open_block> (stream_a);
1256  			break;
1257  		}
1258  		case nano::block_type::change:
1259  		{
1260  			result = ::deserialize_block<nano::change_block> (stream_a);
1261  			break;
1262  		}
1263  		case nano::block_type::state:
1264  		{
1265  			result = ::deserialize_block<nano::state_block> (stream_a);
1266  			break;
1267  		}
1268  		default:
1269  		{
1270  			return {};
1271  		}
1272  	}
1273  	if (result && uniquer_a != nullptr)
1274  	{
1275  		result = uniquer_a->unique (result);
1276  	}
1277  	return result;
1278  }
1279  void nano::receive_block::visit (nano::block_visitor & visitor_a) const
1280  {
1281  	visitor_a.receive_block (*this);
1282  }
1283  void nano::receive_block::visit (nano::mutable_block_visitor & visitor_a)
1284  {
1285  	visitor_a.receive_block (*this);
1286  }
1287  bool nano::receive_block::operator== (nano::receive_block const & other_a) const
1288  {
1289  	auto result (hashables.previous == other_a.hashables.previous && hashables.source == other_a.hashables.source && work == other_a.work && signature == other_a.signature);
1290  	return result;
1291  }
1292  void nano::receive_block::serialize (nano::stream & stream_a) const
1293  {
1294  	write (stream_a, hashables.previous.bytes);
1295  	write (stream_a, hashables.source.bytes);
1296  	write (stream_a, signature.bytes);
1297  	write (stream_a, work);
1298  }
1299  bool nano::receive_block::deserialize (nano::stream & stream_a)
1300  {
1301  	auto error (false);
1302  	try
1303  	{
1304  		read (stream_a, hashables.previous.bytes);
1305  		read (stream_a, hashables.source.bytes);
1306  		read (stream_a, signature.bytes);
1307  		read (stream_a, work);
1308  	}
1309  	catch (std::runtime_error const &)
1310  	{
1311  		error = true;
1312  	}
1313  	return error;
1314  }
1315  void nano::receive_block::serialize_json (std::string & string_a, bool single_line) const
1316  {
1317  	boost::property_tree::ptree tree;
1318  	serialize_json (tree);
1319  	std::stringstream ostream;
1320  	boost::property_tree::write_json (ostream, tree, !single_line);
1321  	string_a = ostream.str ();
1322  }
1323  void nano::receive_block::serialize_json (boost::property_tree::ptree & tree) const
1324  {
1325  	tree.put ("type", "receive");
1326  	std::string previous;
1327  	hashables.previous.encode_hex (previous);
1328  	tree.put ("previous", previous);
1329  	std::string source;
1330  	hashables.source.encode_hex (source);
1331  	tree.put ("source", source);
1332  	std::string signature_l;
1333  	signature.encode_hex (signature_l);
1334  	tree.put ("work", nano::to_string_hex (work));
1335  	tree.put ("signature", signature_l);
1336  }
1337  bool nano::receive_block::deserialize_json (boost::property_tree::ptree const & tree_a)
1338  {
1339  	auto error (false);
1340  	try
1341  	{
1342  		debug_assert (tree_a.get<std::string> ("type") == "receive");
1343  		auto previous_l (tree_a.get<std::string> ("previous"));
1344  		auto source_l (tree_a.get<std::string> ("source"));
1345  		auto work_l (tree_a.get<std::string> ("work"));
1346  		auto signature_l (tree_a.get<std::string> ("signature"));
1347  		error = hashables.previous.decode_hex (previous_l);
1348  		if (!error)
1349  		{
1350  			error = hashables.source.decode_hex (source_l);
1351  			if (!error)
1352  			{
1353  				error = nano::from_string_hex (work_l, work);
1354  				if (!error)
1355  				{
1356  					error = signature.decode_hex (signature_l);
1357  				}
1358  			}
1359  		}
1360  	}
1361  	catch (std::runtime_error const &)
1362  	{
1363  		error = true;
1364  	}
1365  	return error;
1366  }
1367  nano::receive_block::receive_block (nano::block_hash const & previous_a, nano::block_hash const & source_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
1368  	hashables (previous_a, source_a),
1369  	signature (nano::sign_message (prv_a, pub_a, hash ())),
1370  	work (work_a)
1371  {
1372  	debug_assert (pub_a != nullptr);
1373  }
1374  nano::receive_block::receive_block (bool & error_a, nano::stream & stream_a) :
1375  	hashables (error_a, stream_a)
1376  {
1377  	if (!error_a)
1378  	{
1379  		try
1380  		{
1381  			nano::read (stream_a, signature);
1382  			nano::read (stream_a, work);
1383  		}
1384  		catch (std::runtime_error const &)
1385  		{
1386  			error_a = true;
1387  		}
1388  	}
1389  }
1390  nano::receive_block::receive_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
1391  	hashables (error_a, tree_a)
1392  {
1393  	if (!error_a)
1394  	{
1395  		try
1396  		{
1397  			auto signature_l (tree_a.get<std::string> ("signature"));
1398  			auto work_l (tree_a.get<std::string> ("work"));
1399  			error_a = signature.decode_hex (signature_l);
1400  			if (!error_a)
1401  			{
1402  				error_a = nano::from_string_hex (work_l, work);
1403  			}
1404  		}
1405  		catch (std::runtime_error const &)
1406  		{
1407  			error_a = true;
1408  		}
1409  	}
1410  }
1411  void nano::receive_block::hash (blake2b_state & hash_a) const
1412  {
1413  	hashables.hash (hash_a);
1414  }
1415  uint64_t nano::receive_block::block_work () const
1416  {
1417  	return work;
1418  }
1419  void nano::receive_block::block_work_set (uint64_t work_a)
1420  {
1421  	work = work_a;
1422  }
1423  bool nano::receive_block::operator== (nano::block const & other_a) const
1424  {
1425  	return blocks_equal (*this, other_a);
1426  }
1427  bool nano::receive_block::valid_predecessor (nano::block const & block_a) const
1428  {
1429  	bool result;
1430  	switch (block_a.type ())
1431  	{
1432  		case nano::block_type::send:
1433  		case nano::block_type::receive:
1434  		case nano::block_type::open:
1435  		case nano::block_type::change:
1436  			result = true;
1437  			break;
1438  		default:
1439  			result = false;
1440  			break;
1441  	}
1442  	return result;
1443  }
1444  nano::block_hash const & nano::receive_block::previous () const
1445  {
1446  	return hashables.previous;
1447  }
1448  nano::block_hash const & nano::receive_block::source () const
1449  {
1450  	return hashables.source;
1451  }
1452  nano::root const & nano::receive_block::root () const
1453  {
1454  	return hashables.previous;
1455  }
1456  nano::signature const & nano::receive_block::block_signature () const
1457  {
1458  	return signature;
1459  }
1460  void nano::receive_block::signature_set (nano::signature const & signature_a)
1461  {
1462  	signature = signature_a;
1463  }
1464  nano::block_type nano::receive_block::type () const
1465  {
1466  	return nano::block_type::receive;
1467  }
1468  nano::receive_hashables::receive_hashables (nano::block_hash const & previous_a, nano::block_hash const & source_a) :
1469  	previous (previous_a),
1470  	source (source_a)
1471  {
1472  }
1473  nano::receive_hashables::receive_hashables (bool & error_a, nano::stream & stream_a)
1474  {
1475  	try
1476  	{
1477  		nano::read (stream_a, previous.bytes);
1478  		nano::read (stream_a, source.bytes);
1479  	}
1480  	catch (std::runtime_error const &)
1481  	{
1482  		error_a = true;
1483  	}
1484  }
1485  nano::receive_hashables::receive_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
1486  {
1487  	try
1488  	{
1489  		auto previous_l (tree_a.get<std::string> ("previous"));
1490  		auto source_l (tree_a.get<std::string> ("source"));
1491  		error_a = previous.decode_hex (previous_l);
1492  		if (!error_a)
1493  		{
1494  			error_a = source.decode_hex (source_l);
1495  		}
1496  	}
1497  	catch (std::runtime_error const &)
1498  	{
1499  		error_a = true;
1500  	}
1501  }
1502  void nano::receive_hashables::hash (blake2b_state & hash_a) const
1503  {
1504  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
1505  	blake2b_update (&hash_a, source.bytes.data (), sizeof (source.bytes));
1506  }
1507  nano::block_details::block_details (nano::epoch const epoch_a, bool const is_send_a, bool const is_receive_a, bool const is_epoch_a) :
1508  	epoch (epoch_a), is_send (is_send_a), is_receive (is_receive_a), is_epoch (is_epoch_a)
1509  {
1510  }
1511  bool nano::block_details::operator== (nano::block_details const & other_a) const
1512  {
1513  	return epoch == other_a.epoch && is_send == other_a.is_send && is_receive == other_a.is_receive && is_epoch == other_a.is_epoch;
1514  }
1515  uint8_t nano::block_details::packed () const
1516  {
1517  	std::bitset<8> result (static_cast<uint8_t> (epoch));
1518  	result.set (7, is_send);
1519  	result.set (6, is_receive);
1520  	result.set (5, is_epoch);
1521  	return static_cast<uint8_t> (result.to_ulong ());
1522  }
1523  void nano::block_details::unpack (uint8_t details_a)
1524  {
1525  	constexpr std::bitset<8> epoch_mask{ 0b00011111 };
1526  	auto as_bitset = static_cast<std::bitset<8>> (details_a);
1527  	is_send = as_bitset.test (7);
1528  	is_receive = as_bitset.test (6);
1529  	is_epoch = as_bitset.test (5);
1530  	epoch = static_cast<nano::epoch> ((as_bitset & epoch_mask).to_ulong ());
1531  }
1532  void nano::block_details::serialize (nano::stream & stream_a) const
1533  {
1534  	nano::write (stream_a, packed ());
1535  }
1536  bool nano::block_details::deserialize (nano::stream & stream_a)
1537  {
1538  	bool result (false);
1539  	try
1540  	{
1541  		uint8_t packed{ 0 };
1542  		nano::read (stream_a, packed);
1543  		unpack (packed);
1544  	}
1545  	catch (std::runtime_error &)
1546  	{
1547  		result = true;
1548  	}
1549  	return result;
1550  }
1551  std::string nano::state_subtype (nano::block_details const details_a)
1552  {
1553  	debug_assert (details_a.is_epoch + details_a.is_receive + details_a.is_send <= 1);
1554  	if (details_a.is_send)
1555  	{
1556  		return "send";
1557  	}
1558  	else if (details_a.is_receive)
1559  	{
1560  		return "receive";
1561  	}
1562  	else if (details_a.is_epoch)
1563  	{
1564  		return "epoch";
1565  	}
1566  	else
1567  	{
1568  		return "change";
1569  	}
1570  }
1571  nano::block_sideband::block_sideband (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t const height_a, nano::seconds_t const timestamp_a, nano::block_details const & details_a, nano::epoch const source_epoch_a) :
1572  	successor (successor_a),
1573  	account (account_a),
1574  	balance (balance_a),
1575  	height (height_a),
1576  	timestamp (timestamp_a),
1577  	details (details_a),
1578  	source_epoch (source_epoch_a)
1579  {
1580  }
1581  nano::block_sideband::block_sideband (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t const height_a, nano::seconds_t const timestamp_a, nano::epoch const epoch_a, bool const is_send, bool const is_receive, bool const is_epoch, nano::epoch const source_epoch_a) :
1582  	successor (successor_a),
1583  	account (account_a),
1584  	balance (balance_a),
1585  	height (height_a),
1586  	timestamp (timestamp_a),
1587  	details (epoch_a, is_send, is_receive, is_epoch),
1588  	source_epoch (source_epoch_a)
1589  {
1590  }
1591  size_t nano::block_sideband::size (nano::block_type type_a)
1592  {
1593  	size_t result (0);
1594  	result += sizeof (successor);
1595  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1596  	{
1597  		result += sizeof (account);
1598  	}
1599  	if (type_a != nano::block_type::open)
1600  	{
1601  		result += sizeof (height);
1602  	}
1603  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1604  	{
1605  		result += sizeof (balance);
1606  	}
1607  	result += sizeof (timestamp);
1608  	if (type_a == nano::block_type::state)
1609  	{
1610  		static_assert (sizeof (nano::epoch) == nano::block_details::size (), "block_details is larger than the epoch enum");
1611  		result += nano::block_details::size () + sizeof (nano::epoch);
1612  	}
1613  	return result;
1614  }
1615  void nano::block_sideband::serialize (nano::stream & stream_a, nano::block_type type_a) const
1616  {
1617  	nano::write (stream_a, successor.bytes);
1618  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1619  	{
1620  		nano::write (stream_a, account.bytes);
1621  	}
1622  	if (type_a != nano::block_type::open)
1623  	{
1624  		nano::write (stream_a, boost::endian::native_to_big (height));
1625  	}
1626  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1627  	{
1628  		nano::write (stream_a, balance.bytes);
1629  	}
1630  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
1631  	if (type_a == nano::block_type::state)
1632  	{
1633  		details.serialize (stream_a);
1634  		nano::write (stream_a, static_cast<uint8_t> (source_epoch));
1635  	}
1636  }
1637  bool nano::block_sideband::deserialize (nano::stream & stream_a, nano::block_type type_a)
1638  {
1639  	bool result (false);
1640  	try
1641  	{
1642  		nano::read (stream_a, successor.bytes);
1643  		if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1644  		{
1645  			nano::read (stream_a, account.bytes);
1646  		}
1647  		if (type_a != nano::block_type::open)
1648  		{
1649  			nano::read (stream_a, height);
1650  			boost::endian::big_to_native_inplace (height);
1651  		}
1652  		else
1653  		{
1654  			height = 1;
1655  		}
1656  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1657  		{
1658  			nano::read (stream_a, balance.bytes);
1659  		}
1660  		nano::read (stream_a, timestamp);
1661  		boost::endian::big_to_native_inplace (timestamp);
1662  		if (type_a == nano::block_type::state)
1663  		{
1664  			result = details.deserialize (stream_a);
1665  			uint8_t source_epoch_uint8_t{ 0 };
1666  			nano::read (stream_a, source_epoch_uint8_t);
1667  			source_epoch = static_cast<nano::epoch> (source_epoch_uint8_t);
1668  		}
1669  	}
1670  	catch (std::runtime_error &)
1671  	{
1672  		result = true;
1673  	}
1674  	return result;
1675  }
1676  std::shared_ptr<nano::block> nano::block_uniquer::unique (std::shared_ptr<nano::block> const & block_a)
1677  {
1678  	auto result (block_a);
1679  	if (result != nullptr)
1680  	{
1681  		nano::uint256_union key (block_a->full_hash ());
1682  		nano::lock_guard<nano::mutex> lock{ mutex };
1683  		auto & existing (blocks[key]);
1684  		if (auto block_l = existing.lock ())
1685  		{
1686  			result = block_l;
1687  		}
1688  		else
1689  		{
1690  			existing = block_a;
1691  		}
1692  		release_assert (std::numeric_limits<CryptoPP::word32>::max () > blocks.size ());
1693  		for (auto i (0); i < cleanup_count && !blocks.empty (); ++i)
1694  		{
1695  			auto random_offset (nano::random_pool::generate_word32 (0, static_cast<CryptoPP::word32> (blocks.size () - 1)));
1696  			auto existing (std::next (blocks.begin (), random_offset));
1697  			if (existing == blocks.end ())
1698  			{
1699  				existing = blocks.begin ();
1700  			}
1701  			if (existing != blocks.end ())
1702  			{
1703  				if (auto block_l = existing->second.lock ())
1704  				{
1705  				}
1706  				else
1707  				{
1708  					blocks.erase (existing);
1709  				}
1710  			}
1711  		}
1712  	}
1713  	return result;
1714  }
1715  size_t nano::block_uniquer::size ()
1716  {
1717  	nano::lock_guard<nano::mutex> lock{ mutex };
1718  	return blocks.size ();
1719  }
1720  std::unique_ptr<nano::container_info_component> nano::collect_container_info (block_uniquer & block_uniquer, std::string const & name)
1721  {
1722  	auto count = block_uniquer.size ();
1723  	auto sizeof_element = sizeof (block_uniquer::value_type);
1724  	auto composite = std::make_unique<container_info_composite> (name);
1725  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "blocks", count, sizeof_element }));
1726  	return composite;
1727  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-jpcre2.hpp</h3>
            <pre><code>1  #ifndef JPCRE2_HPP
2  #define JPCRE2_HPP
3  #ifndef PCRE2_CODE_UNIT_WIDTH
4  #define PCRE2_CODE_UNIT_WIDTH 0
5  #endif
6  #ifndef PCRE2_MAJOR
7      #include <pcre2.h>  
8  #endif
9  #include <string>       
10  #include <vector>       
11  #include <map>          
12  #include <cstdio>       
13  #include <climits>      
14  #include <cstdlib>      
15  #if __cplusplus >= 201103L || _MSVC_LANG >= 201103L
16      #define JPCRE2_USE_MINIMUM_CXX_11 1
17      #include <utility>
18      #ifndef JPCRE2_USE_FUNCTION_POINTER_CALLBACK
19          #include <functional>   
20      #endif
21  #else
22      #define JPCRE2_USE_MINIMUM_CXX_11 0
23  #endif
24  #define JPCRE2_UNUSED(x) ((void)(x))
25  #if defined(NDEBUG) || defined(JPCRE2_NDEBUG)
26      #define JPCRE2_ASSERT(cond, msg) ((void)0)
27      #define JPCRE2_VECTOR_DATA_ASSERT(cond, name) ((void)0)
28  #else
29      #define JPCRE2_ASSERT(cond, msg) jpcre2::jassert(cond, msg, __FILE__, __LINE__)
30      #define JPCRE2_VECTOR_DATA_ASSERT(cond, name) jpcre2::_jvassert(cond, name, __FILE__, __LINE__)
31  #endif
32  #ifdef ERROR
33  #undef ERROR
34  #endif
35  namespace jpcre2 {
36  #define JPCRE2_VERSION 103201L
37  namespace INFO {
38      static const char NAME[] = "JPCRE2";               
39      static const char FULL_VERSION[] = "10.32.01";     
40      static const char VERSION_GENRE[] = "10";          
41      static const char VERSION_MAJOR[] = "32";          
42      static const char VERSION_MINOR[] = "01";          
43      static const char VERSION_PRE_RELEASE[] = "";      
44  }
45  typedef PCRE2_SIZE SIZE_T;                          
46  typedef uint32_t Uint;                              
47  typedef uint8_t Ush;                                
48  typedef std::vector<SIZE_T> VecOff;                 
49  typedef std::vector<Uint> VecOpt;                   
50  namespace ERROR {
51      enum {
52          INVALID_MODIFIER        = 2,  
53          INSUFFICIENT_OVECTOR    = 3   
54      };
55  }
56  enum {
57      NONE                    = 0x0000000u,           
58      FIND_ALL                = 0x0000002u,           
59      JIT_COMPILE             = 0x0000004u            
60  };
61  template<bool B, typename T = void>
62  struct EnableIf{};
63  template<typename T>
64  struct EnableIf<true, T>{typedef T Type;};
65  template<typename T1, typename T2>
66  struct IsSame{ static const bool value = false; };
67  template<typename T>
68  struct IsSame<T,T>{ static const bool value = true; };
69  static inline void jassert(bool cond, const char* msg, const char* f, size_t line){
70      if(!cond) {
71          std::fprintf(stderr,"\n\tE: AssertionFailure\n%s\nAssertion failed in file: %s\t at line: %u\n", msg, f, (unsigned)line);
72          std::abort();
73      }
74  }
75  static inline void _jvassert(bool cond, char const * name, const char* f, size_t line){
76      jassert(cond, (std::string("ValueError: \n\
77      Required data vector of type ")+std::string(name)+" is empty.\n\
78      Your MatchEvaluator callback function is not\n\
79      compatible with existing data!!\n\
80      You are trying to use a vector that does not\n\
81      have any match data. Either call nreplace() or replace()\n\
82      with true or perform a match with appropriate\n\
83      callback function. For more details, refer to\n\
84      the doc in MatchEvaluator section.").c_str(), f, line);
85  }
86  static inline std::string _tostdstring(unsigned x){
87      char buf[128];
88      int written = std::sprintf(buf, "%u", x);
89      return (written > 0) ? std::string(buf, buf + written) : std::string();
90  }
91  template<Ush BS> struct Pcre2Type;
92  template<Ush BS> struct Pcre2Func;
93  template<Ush BS> struct Pcre2Type {};
94  template<> struct Pcre2Type<8>{
95      typedef PCRE2_UCHAR8 Pcre2Uchar;
96      typedef PCRE2_SPTR8 Pcre2Sptr;
97      typedef pcre2_code_8 Pcre2Code;
98      typedef pcre2_compile_context_8 CompileContext;
99      typedef pcre2_match_data_8 MatchData;
100      typedef pcre2_general_context_8 GeneralContext;
101      typedef pcre2_match_context_8 MatchContext;
102      typedef pcre2_jit_callback_8 JitCallback;
103      typedef pcre2_jit_stack_8 JitStack;
104  };
105  template<> struct Pcre2Type<16>{
106      typedef PCRE2_UCHAR16 Pcre2Uchar;
107      typedef PCRE2_SPTR16 Pcre2Sptr;
108      typedef pcre2_code_16 Pcre2Code;
109      typedef pcre2_compile_context_16 CompileContext;
110      typedef pcre2_match_data_16 MatchData;
111      typedef pcre2_general_context_16 GeneralContext;
112      typedef pcre2_match_context_16 MatchContext;
113      typedef pcre2_jit_callback_16 JitCallback;
114      typedef pcre2_jit_stack_16 JitStack;
115  };
116  template<> struct Pcre2Type<32>{
117      typedef PCRE2_UCHAR32 Pcre2Uchar;
118      typedef PCRE2_SPTR32 Pcre2Sptr;
119      typedef pcre2_code_32 Pcre2Code;
120      typedef pcre2_compile_context_32 CompileContext;
121      typedef pcre2_match_data_32 MatchData;
122      typedef pcre2_general_context_32 GeneralContext;
123      typedef pcre2_match_context_32 MatchContext;
124      typedef pcre2_jit_callback_32 JitCallback;
125      typedef pcre2_jit_stack_32 JitStack;
126  };
127  template<Ush BS> struct Pcre2Func{};
128  template<> struct Pcre2Func<8> {
129      static Pcre2Type<8>::CompileContext* compile_context_create(Pcre2Type<8>::GeneralContext *gcontext){
130          return pcre2_compile_context_create_8(gcontext);
131      }
132      static void compile_context_free(Pcre2Type<8>::CompileContext *ccontext){
133          pcre2_compile_context_free_8(ccontext);
134      }
135      static Pcre2Type<8>::CompileContext* compile_context_copy(Pcre2Type<8>::CompileContext* ccontext){
136      return pcre2_compile_context_copy_8(ccontext);
137      }
138      static const unsigned char * maketables(Pcre2Type<8>::GeneralContext* gcontext){
139          return pcre2_maketables_8(gcontext);
140      }
141      static int set_character_tables(Pcre2Type<8>::CompileContext * ccontext, const unsigned char * table){
142          return pcre2_set_character_tables_8(ccontext, table);
143      }
144      static Pcre2Type<8>::Pcre2Code * compile(Pcre2Type<8>::Pcre2Sptr pattern,
145                                       PCRE2_SIZE length,
146                                       uint32_t options,
147                                       int *errorcode,
148                                       PCRE2_SIZE *erroroffset,
149                                       Pcre2Type<8>::CompileContext *ccontext){
150          return pcre2_compile_8(pattern, length, options, errorcode, erroroffset, ccontext);
151      }
152      static int jit_compile(Pcre2Type<8>::Pcre2Code *code, uint32_t options){
153          return pcre2_jit_compile_8(code, options);
154      }
155      static int substitute( const Pcre2Type<8>::Pcre2Code *code,
156                      Pcre2Type<8>::Pcre2Sptr subject,
157                      PCRE2_SIZE length,
158                      PCRE2_SIZE startoffset,
159                      uint32_t options,
160                      Pcre2Type<8>::MatchData *match_data,
161                      Pcre2Type<8>::MatchContext *mcontext,
162                      Pcre2Type<8>::Pcre2Sptr replacement,
163                      PCRE2_SIZE rlength,
164                      Pcre2Type<8>::Pcre2Uchar *outputbuffer,
165                      PCRE2_SIZE *outlengthptr){
166          return pcre2_substitute_8( code, subject, length, startoffset, options, match_data,
167                                     mcontext, replacement, rlength, outputbuffer, outlengthptr);
168      }
169      static void code_free(Pcre2Type<8>::Pcre2Code *code){
170          pcre2_code_free_8(code);
171      }
172      static int get_error_message(  int errorcode,
173                              Pcre2Type<8>::Pcre2Uchar *buffer,
174                              PCRE2_SIZE bufflen){
175          return pcre2_get_error_message_8(errorcode, buffer, bufflen);
176      }
177      static Pcre2Type<8>::MatchData * match_data_create_from_pattern(
178                                const Pcre2Type<8>::Pcre2Code *code,
179                                Pcre2Type<8>::GeneralContext *gcontext){
180          return pcre2_match_data_create_from_pattern_8(code, gcontext);
181      }
182      static int match(  const Pcre2Type<8>::Pcre2Code *code,
183                              Pcre2Type<8>::Pcre2Sptr subject,
184                              PCRE2_SIZE length,
185                              PCRE2_SIZE startoffset,
186                              uint32_t options,
187                              Pcre2Type<8>::MatchData *match_data,
188                              Pcre2Type<8>::MatchContext *mcontext){
189          return pcre2_match_8(code, subject, length, startoffset, options, match_data, mcontext);
190      }
191      static void match_data_free(Pcre2Type<8>::MatchData *match_data){
192          pcre2_match_data_free_8(match_data);
193      }
194      static PCRE2_SIZE * get_ovector_pointer(Pcre2Type<8>::MatchData *match_data){
195          return pcre2_get_ovector_pointer_8(match_data);
196      }
197      static int pattern_info(const Pcre2Type<8>::Pcre2Code *code, uint32_t what, void *where){
198          return pcre2_pattern_info_8(code, what, where);
199      }
200      static int set_newline(Pcre2Type<8>::CompileContext *ccontext, uint32_t value){
201          return pcre2_set_newline_8(ccontext, value);
202      }
203      static uint32_t get_ovector_count(Pcre2Type<8>::MatchData *match_data){
204          return pcre2_get_ovector_count_8(match_data);
205      }
206  };
207  template<> struct Pcre2Func<16> {
208      static Pcre2Type<16>::CompileContext* compile_context_create(Pcre2Type<16>::GeneralContext *gcontext){
209          return pcre2_compile_context_create_16(gcontext);
210      }
211      static void compile_context_free(Pcre2Type<16>::CompileContext *ccontext){
212          pcre2_compile_context_free_16(ccontext);
213      }
214      static Pcre2Type<16>::CompileContext* compile_context_copy(Pcre2Type<16>::CompileContext* ccontext){
215      return pcre2_compile_context_copy_16(ccontext);
216      }
217      static const unsigned char * maketables(Pcre2Type<16>::GeneralContext* gcontext){
218          return pcre2_maketables_16(gcontext);
219      }
220      static int set_character_tables(Pcre2Type<16>::CompileContext * ccontext, const unsigned char * table){
221          return pcre2_set_character_tables_16(ccontext, table);
222      }
223      static Pcre2Type<16>::Pcre2Code * compile(Pcre2Type<16>::Pcre2Sptr pattern,
224                                       PCRE2_SIZE length,
225                                       uint32_t options,
226                                       int *errorcode,
227                                       PCRE2_SIZE *erroroffset,
228                                       Pcre2Type<16>::CompileContext *ccontext){
229          return pcre2_compile_16(pattern, length, options, errorcode, erroroffset, ccontext);
230      }
231      static int jit_compile(Pcre2Type<16>::Pcre2Code *code, uint32_t options){
232          return pcre2_jit_compile_16(code, options);
233      }
234      static int substitute( const Pcre2Type<16>::Pcre2Code *code,
235                      Pcre2Type<16>::Pcre2Sptr subject,
236                      PCRE2_SIZE length,
237                      PCRE2_SIZE startoffset,
238                      uint32_t options,
239                      Pcre2Type<16>::MatchData *match_data,
240                      Pcre2Type<16>::MatchContext *mcontext,
241                      Pcre2Type<16>::Pcre2Sptr replacement,
242                      PCRE2_SIZE rlength,
243                      Pcre2Type<16>::Pcre2Uchar *outputbuffer,
244                      PCRE2_SIZE *outlengthptr){
245          return pcre2_substitute_16( code, subject, length, startoffset, options, match_data,
246                                     mcontext, replacement, rlength, outputbuffer, outlengthptr);
247      }
248      static void code_free(Pcre2Type<16>::Pcre2Code *code){
249          pcre2_code_free_16(code);
250      }
251      static int get_error_message(  int errorcode,
252                              Pcre2Type<16>::Pcre2Uchar *buffer,
253                              PCRE2_SIZE bufflen){
254          return pcre2_get_error_message_16(errorcode, buffer, bufflen);
255      }
256      static Pcre2Type<16>::MatchData * match_data_create_from_pattern(
257                                const Pcre2Type<16>::Pcre2Code *code,
258                                Pcre2Type<16>::GeneralContext *gcontext){
259          return pcre2_match_data_create_from_pattern_16(code, gcontext);
260      }
261      static int match(  const Pcre2Type<16>::Pcre2Code *code,
262                              Pcre2Type<16>::Pcre2Sptr subject,
263                              PCRE2_SIZE length,
264                              PCRE2_SIZE startoffset,
265                              uint32_t options,
266                              Pcre2Type<16>::MatchData *match_data,
267                              Pcre2Type<16>::MatchContext *mcontext){
268          return pcre2_match_16(code, subject, length, startoffset, options, match_data, mcontext);
269      }
270      static void match_data_free(Pcre2Type<16>::MatchData *match_data){
271          pcre2_match_data_free_16(match_data);
272      }
273      static PCRE2_SIZE * get_ovector_pointer(Pcre2Type<16>::MatchData *match_data){
274          return pcre2_get_ovector_pointer_16(match_data);
275      }
276      static int pattern_info(const Pcre2Type<16>::Pcre2Code *code, uint32_t what, void *where){
277          return pcre2_pattern_info_16(code, what, where);
278      }
279      static int set_newline(Pcre2Type<16>::CompileContext *ccontext, uint32_t value){
280          return pcre2_set_newline_16(ccontext, value);
281      }
282      static uint32_t get_ovector_count(Pcre2Type<16>::MatchData *match_data){
283          return pcre2_get_ovector_count_16(match_data);
284      }
285  };
286  template<> struct Pcre2Func<32> {
287      static Pcre2Type<32>::CompileContext* compile_context_create(Pcre2Type<32>::GeneralContext *gcontext){
288          return pcre2_compile_context_create_32(gcontext);
289      }
290      static void compile_context_free(Pcre2Type<32>::CompileContext *ccontext){
291          pcre2_compile_context_free_32(ccontext);
292      }
293      static Pcre2Type<32>::CompileContext* compile_context_copy(Pcre2Type<32>::CompileContext* ccontext){
294      return pcre2_compile_context_copy_32(ccontext);
295      }
296      static const unsigned char * maketables(Pcre2Type<32>::GeneralContext* gcontext){
297          return pcre2_maketables_32(gcontext);
298      }
299      static int set_character_tables(Pcre2Type<32>::CompileContext * ccontext, const unsigned char * table){
300          return pcre2_set_character_tables_32(ccontext, table);
301      }
302      static Pcre2Type<32>::Pcre2Code * compile(Pcre2Type<32>::Pcre2Sptr pattern,
303                                       PCRE2_SIZE length,
304                                       uint32_t options,
305                                       int *errorcode,
306                                       PCRE2_SIZE *erroroffset,
307                                       Pcre2Type<32>::CompileContext *ccontext){
308          return pcre2_compile_32(pattern, length, options, errorcode, erroroffset, ccontext);
309      }
310      static int jit_compile(Pcre2Type<32>::Pcre2Code *code, uint32_t options){
311          return pcre2_jit_compile_32(code, options);
312      }
313      static int substitute( const Pcre2Type<32>::Pcre2Code *code,
314                      Pcre2Type<32>::Pcre2Sptr subject,
315                      PCRE2_SIZE length,
316                      PCRE2_SIZE startoffset,
317                      uint32_t options,
318                      Pcre2Type<32>::MatchData *match_data,
319                      Pcre2Type<32>::MatchContext *mcontext,
320                      Pcre2Type<32>::Pcre2Sptr replacement,
321                      PCRE2_SIZE rlength,
322                      Pcre2Type<32>::Pcre2Uchar *outputbuffer,
323                      PCRE2_SIZE *outlengthptr){
324          return pcre2_substitute_32( code, subject, length, startoffset, options, match_data,
325                                     mcontext, replacement, rlength, outputbuffer, outlengthptr);
326      }
327      static void code_free(Pcre2Type<32>::Pcre2Code *code){
328          pcre2_code_free_32(code);
329      }
330      static int get_error_message(  int errorcode,
331                              Pcre2Type<32>::Pcre2Uchar *buffer,
332                              PCRE2_SIZE bufflen){
333          return pcre2_get_error_message_32(errorcode, buffer, bufflen);
334      }
335      static Pcre2Type<32>::MatchData * match_data_create_from_pattern(
336                                const Pcre2Type<32>::Pcre2Code *code,
337                                Pcre2Type<32>::GeneralContext *gcontext){
338          return pcre2_match_data_create_from_pattern_32(code, gcontext);
339      }
340      static int match(  const Pcre2Type<32>::Pcre2Code *code,
341                              Pcre2Type<32>::Pcre2Sptr subject,
342                              PCRE2_SIZE length,
343                              PCRE2_SIZE startoffset,
344                              uint32_t options,
345                              Pcre2Type<32>::MatchData *match_data,
346                              Pcre2Type<32>::MatchContext *mcontext){
347          return pcre2_match_32(code, subject, length, startoffset, options, match_data, mcontext);
348      }
349      static void match_data_free(Pcre2Type<32>::MatchData *match_data){
350          pcre2_match_data_free_32(match_data);
351      }
352      static PCRE2_SIZE * get_ovector_pointer(Pcre2Type<32>::MatchData *match_data){
353          return pcre2_get_ovector_pointer_32(match_data);
354      }
355      static int pattern_info(const Pcre2Type<32>::Pcre2Code *code, uint32_t what, void *where){
356          return pcre2_pattern_info_32(code, what, where);
357      }
358      static int set_newline(Pcre2Type<32>::CompileContext *ccontext, uint32_t value){
359          return pcre2_set_newline_32(ccontext, value);
360      }
361      static uint32_t get_ovector_count(Pcre2Type<32>::MatchData *match_data){
362          return pcre2_get_ovector_count_32(match_data);
363      }
364  };
365  class Modifier{
366      std::string mod;
367      public:
368      Modifier(){}
369      Modifier(std::string const& x):mod(x){}
370      Modifier(char const *x):mod(x?x:""){}
371      std::string str() const { return mod; }
372      char const * c_str() const { return mod.c_str(); }
373      SIZE_T length() const{ return mod.length(); }
374      char operator[](SIZE_T i) const { return mod[i]; }
375  };
376  namespace MOD {
377      static const char C_N[] = "eijmnsuxADJU";
378      static const jpcre2::Uint C_V[12] = { PCRE2_MATCH_UNSET_BACKREF,                  
379                                            PCRE2_CASELESS,                             
380                                            PCRE2_ALT_BSUX | PCRE2_MATCH_UNSET_BACKREF, 
381                                            PCRE2_MULTILINE,                            
382                                            PCRE2_UTF | PCRE2_UCP,                      
383                                            PCRE2_DOTALL,                               
384                                            PCRE2_UTF,                                  
385                                            PCRE2_EXTENDED,                             
386                                            PCRE2_ANCHORED,                             
387                                            PCRE2_DOLLAR_ENDONLY,                       
388                                            PCRE2_DUPNAMES,                             
389                                            PCRE2_UNGREEDY                              
390                                          };
391      static const char CJ_N[] = "S";
392      static const jpcre2::Uint CJ_V[1] = { JIT_COMPILE,                                
393                                          };
394      static const char R_N[] = "eEgx";
395      static const jpcre2::Uint R_V[4]  = {  PCRE2_SUBSTITUTE_UNSET_EMPTY,                
396                                             PCRE2_SUBSTITUTE_UNKNOWN_UNSET | PCRE2_SUBSTITUTE_UNSET_EMPTY,   
397                                             PCRE2_SUBSTITUTE_GLOBAL,                     
398                                             PCRE2_SUBSTITUTE_EXTENDED                    
399                                          };
400      static const char RJ_N[] = "";
401      static const jpcre2::Uint RJ_V[1] = { NONE  
402                                          };
403      static const char M_N[] = "A";
404      static const jpcre2::Uint M_V[1]  = { PCRE2_ANCHORED                               
405                                          };
406      static const char MJ_N[] = "g";
407      static const jpcre2::Uint MJ_V[1] = { FIND_ALL,                                   
408                                          };
409      static inline void toOption(Modifier const& mod, bool x,
410                                  Uint const * J_V, char const * J_N, SIZE_T SJ,
411                                  Uint const * V, char const * N, SIZE_T S,
412                                  Uint* po, Uint* jo,
413                                  int* en, SIZE_T* eo
414                                  ){
415          SIZE_T n = mod.length();
416          for (SIZE_T i = 0; i < n; ++i) {
417              for(SIZE_T j = 0; j < SJ; ++j){
418                  if(J_N[j] == mod[i]) {
419                      if(x) *jo |= J_V[j];
420                      else  *jo &= ~J_V[j];
421                      goto endfor;
422                  }
423              }
424              for(SIZE_T j = 0; j< S; ++j){
425                  if(N[j] == mod[i]){
426                      if(x) *po |= V[j];
427                      else  *po &= ~V[j];
428                      goto endfor;
429                  }
430              }
431              *en = (int)ERROR::INVALID_MODIFIER;
432              *eo = (int)mod[i];
433              endfor:;
434          }
435      }
436      static inline void toMatchOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo){
437          toOption(mod, x,
438                   MJ_V, MJ_N, sizeof(MJ_V)/sizeof(Uint),
439                   M_V, M_N, sizeof(M_V)/sizeof(Uint),
440                   po, jo, en, eo);
441      }
442      static inline void toReplaceOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo){
443          toOption(mod, x,
444                   RJ_V, RJ_N, sizeof(RJ_V)/sizeof(Uint),
445                   R_V, R_N, sizeof(R_V)/sizeof(Uint),
446                   po, jo, en, eo);
447      }
448      static inline void toCompileOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo){
449          toOption(mod, x,
450                   CJ_V, CJ_N, sizeof(CJ_V)/sizeof(Uint),
451                   C_V, C_N, sizeof(C_V)/sizeof(Uint),
452                   po, jo, en, eo);
453      }
454      static inline std::string fromOption(Uint const * J_V, char const * J_N, SIZE_T SJ,
455                                           Uint const * V, char const * N, SIZE_T S,
456                                           Uint po, Uint jo
457                                           ){
458          std::string mod;
459          for(SIZE_T i = 0; i < S; ++i){
460              if( (V[i] & po) != 0 &&
461                  (V[i] & po) == V[i]) 
462                  mod += N[i];
463          }
464          for(SIZE_T i = 0; i < SJ; ++i){
465              if( (J_V[i] & jo) != 0 &&
466                  (J_V[i] & jo) == J_V[i]) 
467                  mod += J_N[i];
468          }
469          return mod;
470      }
471      static inline std::string fromMatchOption(Uint po, Uint jo){
472          return fromOption(MJ_V, MJ_N, sizeof(MJ_V)/sizeof(Uint),
473                            M_V, M_N, sizeof(M_V)/sizeof(Uint),
474                            po, jo);
475      }
476      static inline std::string fromReplaceOption(Uint po, Uint jo){
477          return fromOption(RJ_V, RJ_N, sizeof(RJ_V)/sizeof(Uint),
478                            R_V, R_N, sizeof(R_V)/sizeof(Uint),
479                            po, jo);
480      }
481      static inline std::string fromCompileOption(Uint po, Uint jo){
482          return fromOption(CJ_V, CJ_N, sizeof(CJ_V)/sizeof(Uint),
483                            C_V, C_N, sizeof(C_V)/sizeof(Uint),
484                            po, jo);
485      }
486  } 
487  class ModifierTable{
488      std::string tabjms;
489      std::string tabms;
490      std::string tabjrs;
491      std::string tabrs;
492      std::string tabjcs;
493      std::string tabcs;
494      VecOpt tabjmv;
495      VecOpt tabmv;
496      VecOpt tabjrv;
497      VecOpt tabrv;
498      VecOpt tabjcv;
499      VecOpt tabcv;
500      void toOption(Modifier const& mod, bool x,
501                    VecOpt const& J_V, std::string const& J_N,
502                    VecOpt const& V, std::string const& N,
503                    Uint* po, Uint* jo, int* en, SIZE_T* eo
504                    ) const{
505          SIZE_T SJ = J_V.size();
506          SIZE_T S = V.size();
507          JPCRE2_ASSERT(SJ == J_N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(SJ) + " == " + _tostdstring(J_N.length()) + ").").c_str());
508          JPCRE2_ASSERT(S == N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(S) + " == " + _tostdstring(N.length()) + ").").c_str());
509          MOD::toOption(mod, x,
510                       J_V.empty()?0:&J_V[0], J_N.c_str(), SJ,
511                       V.empty()?0:&V[0], N.c_str(), S,
512                       po, jo, en, eo
513                       );
514      }
515      std::string fromOption(VecOpt const& J_V, std::string const& J_N,
516                             VecOpt const& V, std::string const& N,
517                             Uint po, Uint jo) const{
518          SIZE_T SJ = J_V.size();
519          SIZE_T S = V.size();
520          JPCRE2_ASSERT(SJ == J_N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(SJ) + " == " + _tostdstring(J_N.length()) + ").").c_str());
521          JPCRE2_ASSERT(S == N.length(), ("ValueError: Modifier character and value table must be of the same size (" + _tostdstring(S) + " == " + _tostdstring(N.length()) + ").").c_str());
522          return MOD::fromOption(J_V.empty()?0:&J_V[0], J_N.c_str(), SJ,
523                       V.empty()?0:&V[0], N.c_str(), S,
524                       po, jo);
525      }
526      void parseModifierTable(std::string& tabjs, VecOpt& tabjv,
527                              std::string& tab_s, VecOpt& tab_v,
528                              std::string const& tabs, VecOpt const& tabv);
529      public:
530      ModifierTable(){}
531      ModifierTable(bool deflt){
532          if(deflt) setAllToDefault();
533      }
534      ModifierTable& resetMatchModifierTable(){
535          std::string().swap(tabjms);
536          std::string().swap(tabms);
537          VecOpt().swap(tabjmv);
538          VecOpt().swap(tabmv);
539          return *this;
540      }
541      ModifierTable& resetReplaceModifierTable(){
542          std::string().swap(tabjrs);
543          std::string().swap(tabrs);
544          VecOpt().swap(tabjrv);
545          VecOpt().swap(tabrv);
546          return *this;
547      }
548      ModifierTable& resetCompileModifierTable(){
549          std::string().swap(tabjcs);
550          std::string().swap(tabcs);
551          VecOpt().swap(tabjcv);
552          VecOpt().swap(tabcv);
553          return *this;
554      }
555      ModifierTable& reset(){
556          resetMatchModifierTable();
557          resetReplaceModifierTable();
558          resetCompileModifierTable();
559          return *this;
560      }
561      ModifierTable& clearMatchModifierTable(){
562          tabjms.clear();
563          tabms.clear();
564          tabjmv.clear();
565          tabmv.clear();
566          return *this;
567      }
568      ModifierTable& clearReplaceModifierTable(){
569          tabjrs.clear();
570          tabrs.clear();
571          tabjrv.clear();
572          tabrv.clear();
573          return *this;
574      }
575      ModifierTable& clearCompileModifierTable(){
576          tabjcs.clear();
577          tabcs.clear();
578          tabjcv.clear();
579          tabcv.clear();
580          return *this;
581      }
582      ModifierTable& clear(){
583          clearMatchModifierTable();
584          clearReplaceModifierTable();
585          clearCompileModifierTable();
586          return *this;
587      }
588      void toMatchOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo) const {
589          toOption(mod, x,tabjmv,tabjms,tabmv, tabms,po,jo,en,eo);
590      }
591      void toReplaceOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo) const {
592          return toOption(mod, x,tabjrv,tabjrs,tabrv,tabrs,po,jo,en,eo);
593      }
594      void toCompileOption(Modifier const& mod, bool x, Uint* po, Uint* jo, int* en, SIZE_T* eo) const {
595          return toOption(mod, x,tabjcv,tabjcs,tabcv,tabcs,po,jo,en,eo);
596      }
597      std::string fromMatchOption(Uint po, Uint jo) const {
598          return fromOption(tabjmv,tabjms,tabmv,tabms,po,jo);
599      }
600      std::string fromReplaceOption(Uint po, Uint jo) const {
601          return fromOption(tabjrv,tabjrs,tabrv,tabrs,po,jo);
602      }
603      std::string fromCompileOption(Uint po, Uint jo) const {
604          return fromOption(tabjcv,tabjcs,tabcv,tabcs,po,jo);
605      }
606      ModifierTable& setMatchModifierTable(std::string const& tabs, VecOpt const& tabv){
607          parseModifierTable(tabjms, tabjmv, tabms, tabmv, tabs, tabv);
608          return *this;
609      }
610      ModifierTable& setMatchModifierTable(std::string const& tabs, const Uint* tabvp){
611          if(tabvp) {
612              VecOpt tabv(tabvp, tabvp + tabs.length());
613              setMatchModifierTable(tabs, tabv);
614          } else clearMatchModifierTable();
615          return *this;
616      }
617      ModifierTable& setMatchModifierTable(const char* tabsp, const Uint* tabvp){
618          if(tabsp && tabvp) {
619              std::string tabs(tabsp);
620              VecOpt tabv(tabvp, tabvp + tabs.length());
621              setMatchModifierTable(tabs, tabv);
622          } else clearMatchModifierTable();
623          return *this;
624      }
625      ModifierTable& setReplaceModifierTable(std::string const& tabs, VecOpt const& tabv){
626          parseModifierTable(tabjrs, tabjrv, tabrs, tabrv, tabs, tabv);
627          return *this;
628      }
629      ModifierTable& setReplaceModifierTable(std::string const& tabs, const Uint* tabvp){
630          if(tabvp) {
631              VecOpt tabv(tabvp, tabvp + tabs.length());
632              setReplaceModifierTable(tabs, tabv);
633          } else clearReplaceModifierTable();
634          return *this;
635      }
636      ModifierTable& setReplaceModifierTable(const char* tabsp, const Uint* tabvp){
637          if(tabsp && tabvp) {
638              std::string tabs(tabsp);
639              VecOpt tabv(tabvp, tabvp + tabs.length());
640              setReplaceModifierTable(tabs, tabv);
641          } else clearReplaceModifierTable();
642          return *this;
643      }
644      ModifierTable& setCompileModifierTable(std::string const& tabs, VecOpt const& tabv){
645          parseModifierTable(tabjcs, tabjcv, tabcs, tabcv, tabs, tabv);
646          return *this;
647      }
648      ModifierTable& setCompileModifierTable(std::string const& tabs, const Uint* tabvp){
649          if(tabvp) {
650              VecOpt tabv(tabvp, tabvp + tabs.length());
651              setCompileModifierTable(tabs, tabv);
652          } else clearCompileModifierTable();
653          return *this;
654      }
655      ModifierTable& setCompileModifierTable(const char* tabsp, const Uint* tabvp){
656          if(tabsp && tabvp) {
657              std::string tabs(tabsp);
658              VecOpt tabv(tabvp, tabvp + tabs.length());
659              setCompileModifierTable(tabs, tabv);
660          } else clearCompileModifierTable();
661          return *this;
662      }
663      ModifierTable& setMatchModifierTableToDefault(){
664          tabjms = std::string(MOD::MJ_N, MOD::MJ_N + sizeof(MOD::MJ_V)/sizeof(Uint));
665          tabms = std::string(MOD::M_N, MOD::M_N  + sizeof(MOD::M_V)/sizeof(Uint));
666          tabjmv = VecOpt(MOD::MJ_V, MOD::MJ_V + sizeof(MOD::MJ_V)/sizeof(Uint));
667          tabmv = VecOpt(MOD::M_V, MOD::M_V + sizeof(MOD::M_V)/sizeof(Uint));
668          return *this;
669      }
670      ModifierTable& setReplaceModifierTableToDefault(){
671          tabjrs = std::string(MOD::RJ_N, MOD::RJ_N  + sizeof(MOD::RJ_V)/sizeof(Uint));
672          tabrs = std::string(MOD::R_N, MOD::R_N  + sizeof(MOD::R_V)/sizeof(Uint));
673          tabjrv = VecOpt(MOD::RJ_V, MOD::RJ_V + sizeof(MOD::RJ_V)/sizeof(Uint));
674          tabrv = VecOpt(MOD::R_V, MOD::R_V + sizeof(MOD::R_V)/sizeof(Uint));
675          return *this;
676      }
677      ModifierTable& setCompileModifierTableToDefault(){
678          tabjcs = std::string(MOD::CJ_N, MOD::CJ_N  + sizeof(MOD::CJ_V)/sizeof(Uint));
679          tabcs = std::string(MOD::C_N, MOD::C_N  + sizeof(MOD::C_V)/sizeof(Uint));
680          tabjcv = VecOpt(MOD::CJ_V, MOD::CJ_V + sizeof(MOD::CJ_V)/sizeof(Uint));
681          tabcv = VecOpt(MOD::C_V, MOD::C_V + sizeof(MOD::C_V)/sizeof(Uint));
682          return *this;
683      }
684      ModifierTable& setAllToDefault(){
685          setMatchModifierTableToDefault();
686          setReplaceModifierTableToDefault();
687          setCompileModifierTableToDefault();
688          return *this;
689      }
690  };
691  template<typename Char_T> struct MSG{
692      static std::basic_string<Char_T> INVALID_MODIFIER(void);
693      static std::basic_string<Char_T> INSUFFICIENT_OVECTOR(void);
694  };
695  template<> inline std::basic_string<char> MSG<char>::INVALID_MODIFIER(){ return "Invalid modifier: "; }
696  template<> inline std::basic_string<wchar_t> MSG<wchar_t>::INVALID_MODIFIER(){ return L"Invalid modifier: "; }
697  template<> inline std::basic_string<char> MSG<char>::INSUFFICIENT_OVECTOR(){ return "ovector wasn't big enough"; }
698  template<> inline std::basic_string<wchar_t> MSG<wchar_t>::INSUFFICIENT_OVECTOR(){ return L"ovector wasn't big enough"; }
699  #if JPCRE2_USE_MINIMUM_CXX_11
700  template<> inline std::basic_string<char16_t> MSG<char16_t>::INVALID_MODIFIER(){ return u"Invalid modifier: "; }
701  template<> inline std::basic_string<char32_t> MSG<char32_t>::INVALID_MODIFIER(){ return U"Invalid modifier: "; }
702  template<> inline std::basic_string<char16_t> MSG<char16_t>::INSUFFICIENT_OVECTOR(){ return u"ovector wasn't big enough"; }
703  template<> inline std::basic_string<char32_t> MSG<char32_t>::INSUFFICIENT_OVECTOR(){ return U"ovector wasn't big enough"; }
704  #endif
705  #if JPCRE2_USE_MINIMUM_CXX_11
706  template<typename Char_T, template<typename...> class Map=std::map>
707  #else
708  template<typename Char_T>
709  #endif
710  struct select{
711      typedef Char_T Char;
712      typedef typename std::basic_string<Char_T> String;
713      #if JPCRE2_USE_MINIMUM_CXX_11
714      typedef class Map<String, String> MapNas;
715      typedef class Map<String, SIZE_T> MapNtN;
716      #else
717      typedef typename std::map<String, String> MapNas;
718      typedef typename std::map<String, SIZE_T> MapNtN;
719      #endif
720      typedef MapNtN MapNtn;
721      typedef typename std::vector<String> NumSub;
722      typedef typename std::vector<MapNas> VecNas;
723      typedef typename std::vector<MapNtN> VecNtN;
724      typedef VecNtN VecNtn;
725      typedef typename std::vector<NumSub> VecNum;
726      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::Pcre2Uchar Pcre2Uchar;
727      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::Pcre2Sptr Pcre2Sptr;
728      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::Pcre2Code Pcre2Code;
729      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::CompileContext CompileContext;
730      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::MatchData MatchData;
731      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::GeneralContext GeneralContext;
732      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::MatchContext MatchContext;
733      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::JitCallback JitCallback;
734      typedef typename Pcre2Type<sizeof( Char_T ) * CHAR_BIT>::JitStack JitStack;
735      template<typename T>
736      static String toString(T); 
737      static String toString(Char a){
738          return a?String(1, a):String();
739      }
740      static String toString(Char const *a){
741          return a?String(a):String();
742      }
743      static String toString(Char* a){
744          return a?String(a):String();
745      }
746      static String toString(Pcre2Uchar* a) {
747          return a?String((Char*) a):String();
748      }
749      static String getPcre2ErrorMessage(int err_num) {
750          Pcre2Uchar buffer[sizeof(Char)*CHAR_BIT*1024];
751          Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::get_error_message(err_num, buffer, sizeof(buffer));
752          return toString((Pcre2Uchar*) buffer);
753      }
754      static String getErrorMessage(int err_num, int err_off)  {
755          if(err_num == (int)ERROR::INVALID_MODIFIER){
756              return MSG<Char>::INVALID_MODIFIER() + toString((Char)err_off);
757          } else if(err_num == (int)ERROR::INSUFFICIENT_OVECTOR){
758              return MSG<Char>::INSUFFICIENT_OVECTOR();
759          } else if(err_num != 0) {
760              return getPcre2ErrorMessage((int) err_num);
761          } else return String();
762      }
763      class Regex;
764      class RegexMatch;
765      class RegexReplace;
766      class MatchEvaluator;
767      class RegexMatch {
768      private:
769          friend class MatchEvaluator;
770          Regex const *re;
771          String m_subject;
772          String const *m_subject_ptr;
773          Uint match_opts;
774          Uint jpcre2_match_opts;
775          MatchContext *mcontext;
776          ModifierTable const * modtab;
777          MatchData * mdata;
778          PCRE2_SIZE _start_offset; 
779          VecNum* vec_num;
780          VecNas* vec_nas;
781          VecNtN* vec_ntn;
782          VecOff* vec_soff;
783          VecOff* vec_eoff;
784          bool getNumberedSubstrings(int, Pcre2Sptr, PCRE2_SIZE*, uint32_t);
785          bool getNamedSubstrings(int, int, Pcre2Sptr, Pcre2Sptr, PCRE2_SIZE*);
786          void init_vars() {
787              re = 0;
788              vec_num = 0;
789              vec_nas = 0;
790              vec_ntn = 0;
791              vec_soff = 0;
792              vec_eoff = 0;
793              match_opts = 0;
794              jpcre2_match_opts = 0;
795              error_number = 0;
796              error_offset = 0;
797              _start_offset = 0;
798              m_subject_ptr = &m_subject;
799              mcontext = 0;
800              modtab = 0;
801              mdata = 0;
802          }
803          void onlyCopy(RegexMatch const &rm){
804              re = rm.re; 
805              m_subject_ptr = (rm.m_subject_ptr == &rm.m_subject) ? &m_subject  
806                                                                  : rm.m_subject_ptr;
807              vec_num = rm.vec_num;
808              vec_nas = rm.vec_nas;
809              vec_ntn = rm.vec_ntn;
810              vec_soff = rm.vec_soff;
811              vec_eoff = rm.vec_eoff;
812              match_opts = rm.match_opts;
813              jpcre2_match_opts = rm.jpcre2_match_opts;
814              error_number = rm.error_number;
815              error_offset = rm.error_offset;
816              _start_offset = rm._start_offset;
817              mcontext = rm.mcontext;
818              modtab = rm.modtab;
819              mdata = rm.mdata;
820          }
821          void deepCopy(RegexMatch const &rm){
822              m_subject = rm.m_subject;
823              onlyCopy(rm);
824          }
825          #if JPCRE2_USE_MINIMUM_CXX_11
826          void deepMove(RegexMatch& rm){
827              m_subject = std::move_if_noexcept(rm.m_subject);
828              onlyCopy(rm);
829          }
830          #endif
831          friend class Regex;
832          protected:
833          int error_number;
834          PCRE2_SIZE error_offset;
835      public:
836          RegexMatch(){
837              init_vars();
838          }
839          RegexMatch(Regex const *r) {
840              init_vars();
841              re = r;
842          }
843          RegexMatch(RegexMatch const &rm){
844              init_vars();
845              deepCopy(rm);
846          }
847          virtual RegexMatch& operator=(RegexMatch const &rm){
848              if(this == &rm) return *this;
849              deepCopy(rm);
850              return *this;
851          }
852          #if JPCRE2_USE_MINIMUM_CXX_11
853          RegexMatch(RegexMatch&& rm){
854              init_vars();
855              deepMove(rm);
856          }
857          virtual RegexMatch& operator=(RegexMatch&& rm){
858              if(this == &rm) return *this;
859              deepMove(rm);
860              return *this;
861          }
862          #endif
863          virtual ~RegexMatch() {}
864          virtual RegexMatch& reset() {
865              String().swap(m_subject); 
866              init_vars();
867              return *this;
868          }
869          virtual RegexMatch& clear(){
870              m_subject.clear(); 
871              init_vars();
872              return *this;
873          }
874          virtual RegexMatch& resetErrors(){
875              error_number = 0;
876              error_offset = 0;
<span onclick='openModal()' class='match'>877              return *this;
878          }
879          virtual int getErrorNumber() const {
880              return error_number;
881          }
882          virtual int getErrorOffset() const  {
883              return (int)error_offset;
884          }
885          virtual String getErrorMessage() const  {
886              #if JPCRE2_USE_MINIMUM_CXX_11
887              return select<Char, Map>::getErrorMessage(error_number, error_offset);
</span>888              #else
889              return select<Char>::getErrorMessage(error_number, error_offset);
890              #endif
891          }
892          virtual String getSubject() const  {
893              return *m_subject_ptr;
894          }
895          virtual String const * getSubjectPointer() const  {
896              return m_subject_ptr;
897          }
898          virtual std::string getModifier() const {
899              return modtab ? modtab->fromMatchOption(match_opts, jpcre2_match_opts)
900                            : MOD::fromMatchOption(match_opts, jpcre2_match_opts);
901          }
902          virtual ModifierTable const* getModifierTable(){
903              return modtab;
904          }
905          virtual Uint getPcre2Option() const  {
906              return match_opts;
907          }
908          virtual Uint getJpcre2Option() const  {
909              return jpcre2_match_opts;
910          }
911          virtual PCRE2_SIZE getStartOffset() const  {
912              return _start_offset;
913          }
914          virtual VecOff const* getMatchStartOffsetVector() const {
915              return vec_soff;
916          }
917          virtual VecOff const* getMatchEndOffsetVector() const {
918              return vec_eoff;
919          }
920          virtual Regex const * getRegexObject() const {
921              return re;
922          }
923          virtual VecNum const* getNumberedSubstringVector() const {
924              return vec_num;
925          }
926          virtual VecNas const* getNamedSubstringVector() const {
927              return vec_nas;
928          }
929          virtual VecNtN const* getNameToNumberMapVector() const {
930              return vec_ntn;
931          }
932          virtual RegexMatch& setRegexObject(Regex const *r){
933              re = r;
934              return *this;
935          }
936          virtual RegexMatch& setNumberedSubstringVector(VecNum* v) {
937              vec_num = v;
938              return *this;
939          }
940          virtual RegexMatch& setNamedSubstringVector(VecNas* v) {
941              vec_nas = v;
942              return *this;
943          }
944          virtual RegexMatch& setNameToNumberMapVector(VecNtN* v) {
945              vec_ntn = v;
946              return *this;
947          }
948          virtual RegexMatch& setMatchStartOffsetVector(VecOff* v){
949              vec_soff = v;
950              return *this;
951          }
952          virtual RegexMatch& setMatchEndOffsetVector(VecOff* v){
953              vec_eoff = v;
954              return *this;
955          }
956          virtual RegexMatch& setSubject(String const &s) {
957              m_subject = s;
958              m_subject_ptr = &m_subject; 
959              return *this;
960          }
961          virtual RegexMatch& setSubject(String const *s) {
962              if(s) m_subject_ptr = s;
963              else {
964                  m_subject.clear();
965                  m_subject_ptr = &m_subject;
966              }
967              return *this;
968          }
969          virtual RegexMatch& setModifier(Modifier const& s) {
970              match_opts = 0;
971              jpcre2_match_opts = 0;
972              changeModifier(s, true);
973              return *this;
974          }
975          virtual RegexMatch& setModifierTable(ModifierTable const * mdt){
976              modtab = mdt;
977              return *this;
978          }
979          virtual RegexMatch& setJpcre2Option(Uint x) {
980              jpcre2_match_opts = x;
981              return *this;
982          }
983          virtual RegexMatch& setPcre2Option(Uint x) {
984              match_opts = x;
985              return *this;
986          }
987          virtual RegexMatch& setFindAll(bool x) {
988              jpcre2_match_opts = x?jpcre2_match_opts | FIND_ALL:jpcre2_match_opts & ~FIND_ALL;
989              return *this;
990          }
991          virtual RegexMatch& setFindAll() {
992              return setFindAll(true);
993          }
994          virtual RegexMatch& setStartOffset(PCRE2_SIZE offset) {
995              _start_offset = offset;
996              return *this;
997          }
998          virtual RegexMatch& setMatchContext(MatchContext *match_context){
999              mcontext = match_context;
1000              return *this;
1001          }
1002          virtual MatchContext* getMatchContext(){
1003              return mcontext;
1004          }
1005          virtual RegexMatch& setMatchDataBlock(MatchData* madt){
1006              mdata = madt;
1007              return *this;
1008          }
1009          virtual MatchData* getMatchDataBlock(){
1010              return mdata;
1011          }
1012          virtual RegexMatch& changeModifier(Modifier const& mod, bool x){
1013              modtab ? modtab->toMatchOption(mod, x, &match_opts, &jpcre2_match_opts, &error_number, &error_offset)
1014                     : MOD::toMatchOption(mod, x, &match_opts, &jpcre2_match_opts, &error_number, &error_offset);
1015              return *this;
1016          }
1017          virtual RegexMatch& changeJpcre2Option(Uint opt, bool x) {
1018              jpcre2_match_opts = x ? jpcre2_match_opts | opt : jpcre2_match_opts & ~opt;
1019              return *this;
1020          }
1021          virtual RegexMatch& changePcre2Option(Uint opt, bool x) {
1022              match_opts = x ? match_opts | opt : match_opts & ~opt;
1023              return *this;
1024          }
1025          virtual RegexMatch& addModifier(Modifier const& mod){
1026              return changeModifier(mod, true);
1027          }
1028          virtual RegexMatch& addJpcre2Option(Uint x) {
1029              jpcre2_match_opts |= x;
1030              return *this;
1031          }
1032          virtual RegexMatch& addPcre2Option(Uint x) {
1033              match_opts |= x;
1034              return *this;
1035          }
1036          virtual SIZE_T match(void);
1037      };
1038      template<typename T1, typename T2, typename T3>
1039      struct MatchEvaluatorCallback{
1040          #if !defined JPCRE2_USE_FUNCTION_POINTER_CALLBACK && JPCRE2_USE_MINIMUM_CXX_11
1041          typedef std::function<String (T1,T2,T3)> Callback;
1042          #else
1043          typedef String (*Callback)(T1,T2,T3);
1044          #endif
1045      };
1046      struct callback{
1047          static String eraseFill(NumSub const &num, MapNas const &nas, MapNtN const &ntn){
1048              return String();
1049          }
1050          static String erase(void*, void*, void*){
1051              return String();
1052          }
1053          static String fill(NumSub const &num, MapNas const &nas, MapNtn const &ntn){
1054              return num[0];
1055          }
1056          private:
1057          callback();
1058          callback(callback const &);
1059          #if JPCRE2_USE_MINIMUM_CXX_11
1060          callback(callback&&);
1061          #endif
1062          ~callback();
1063      };
1064      class MatchEvaluator: virtual public RegexMatch{
1065          private:
1066          friend class RegexReplace;
1067          VecNum vec_num;
1068          VecNas vec_nas;
1069          VecNtN vec_ntn;
1070          VecOff vec_soff;
1071          VecOff vec_eoff;
1072          int callbackn;
1073          typename MatchEvaluatorCallback<void*, void*, void*>::Callback callback0;
1074          typename MatchEvaluatorCallback<NumSub const &, void*, void*>::Callback callback1;
1075          typename MatchEvaluatorCallback<void*, MapNas const &, void*>::Callback callback2;
1076          typename MatchEvaluatorCallback<NumSub const &, MapNas const &, void*>::Callback callback3;
1077          typename MatchEvaluatorCallback<void*, void*, MapNtN const &>::Callback callback4;
1078          typename MatchEvaluatorCallback<NumSub const &, void*, MapNtN const &>::Callback callback5;
1079          typename MatchEvaluatorCallback<void*, MapNas const &, MapNtN const &>::Callback callback6;
1080          typename MatchEvaluatorCallback<NumSub const &, MapNas const &, MapNtN const &>::Callback callback7;
1081          PCRE2_SIZE buffer_size;
1082          void init(){
1083              callbackn = 0;
1084              callback0 = callback::erase;
1085              callback1 = 0;
1086              callback2 = 0;
1087              callback3 = 0;
1088              callback4 = 0;
1089              callback5 = 0;
1090              callback6 = 0;
1091              callback7 = 0;
1092              setMatchStartOffsetVector(&vec_soff);
1093              setMatchEndOffsetVector(&vec_eoff);
1094              buffer_size = 0;
1095          }
1096          void setVectorPointersAccordingToCallback(){
1097              switch(callbackn){
1098                  case 0: break;
1099                  case 1: setNumberedSubstringVector(&vec_num);break;
1100                  case 2: setNamedSubstringVector(&vec_nas);break;
1101                  case 3: setNumberedSubstringVector(&vec_num).setNamedSubstringVector(&vec_nas);break;
1102                  case 4: setNameToNumberMapVector(&vec_ntn);break;
1103                  case 5: setNumberedSubstringVector(&vec_num).setNameToNumberMapVector(&vec_ntn);break;
1104                  case 6: setNamedSubstringVector(&vec_nas).setNameToNumberMapVector(&vec_ntn);break;
1105                  case 7: setNumberedSubstringVector(&vec_num).setNamedSubstringVector(&vec_nas).setNameToNumberMapVector(&vec_ntn);break;
1106              }
1107          }
1108          void onlyCopy(MatchEvaluator const &me){
1109              callbackn = me.callbackn;
1110              callback0 = me.callback0;
1111              callback1 = me.callback1;
1112              callback2 = me.callback2;
1113              callback3 = me.callback3;
1114              callback4 = me.callback4;
1115              callback5 = me.callback5;
1116              callback6 = me.callback6;
1117              callback7 = me.callback7;
1118              setVectorPointersAccordingToCallback();
1119              buffer_size = me.buffer_size;
1120          }
1121          void deepCopy(MatchEvaluator const &me) {
1122              vec_num = me.vec_num;
1123              vec_nas = me.vec_nas;
1124              vec_ntn = me.vec_ntn;
1125              vec_soff = me.vec_soff;
1126              vec_eoff = me.vec_eoff;
1127              onlyCopy(me);
1128          }
1129          #if JPCRE2_USE_MINIMUM_CXX_11
1130          void deepMove(MatchEvaluator& me){
1131              vec_num = std::move_if_noexcept(me.vec_num);
1132              vec_nas = std::move_if_noexcept(me.vec_nas);
1133              vec_ntn = std::move_if_noexcept(me.vec_ntn);
1134              vec_soff = std::move_if_noexcept(me.vec_soff);
1135              vec_eoff = std::move_if_noexcept(me.vec_eoff);
1136              onlyCopy(me);
1137          }
1138          #endif
1139          MatchEvaluator& setNumberedSubstringVector(VecNum* v){
1140              RegexMatch::setNumberedSubstringVector(v);
1141              return *this;
1142          }
1143          MatchEvaluator& setNamedSubstringVector(VecNas* v){
1144              RegexMatch::setNamedSubstringVector(v);
1145              return *this;
1146          }
1147          MatchEvaluator& setNameToNumberMapVector(VecNtN* v){
1148              RegexMatch::setNameToNumberMapVector(v);
1149              return *this;
1150          }
1151          MatchEvaluator& setMatchStartOffsetVector(VecOff* v){
1152              RegexMatch::setMatchStartOffsetVector(v);
1153              return *this;
1154          }
1155          MatchEvaluator& setMatchEndOffsetVector(VecOff* v){
1156              RegexMatch::setMatchEndOffsetVector(v);
1157              return *this;
1158          }
1159          public:
1160          explicit
1161          MatchEvaluator():RegexMatch(){
1162              init();
1163          }
1164          explicit
1165          MatchEvaluator(Regex const *r):RegexMatch(r){
1166              init();
1167          }
1168          explicit
1169          MatchEvaluator(typename MatchEvaluatorCallback<void*, void*, void*>::Callback mef): RegexMatch(){
1170              init();
1171              setCallback(mef);
1172          }
1173          explicit
1174          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, void*, void*>::Callback mef): RegexMatch(){
1175              init();
1176              setCallback(mef);
1177          }
1178          explicit
1179          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, void*>::Callback mef): RegexMatch(){
1180              init();
1181              setCallback(mef);
1182          }
1183          explicit
1184          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, void*,  MapNtN const &>::Callback mef): RegexMatch(){
1185              init();
1186              setCallback(mef);
1187          }
1188          explicit
1189          MatchEvaluator(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, MapNtN const &>::Callback mef): RegexMatch(){
1190              init();
1191              setCallback(mef);
1192          }
1193          explicit
1194          MatchEvaluator(typename MatchEvaluatorCallback<void*, MapNas const &, void*>::Callback mef): RegexMatch(){
1195              init();
1196              setCallback(mef);
1197          }
1198          explicit
1199          MatchEvaluator(typename MatchEvaluatorCallback<void*, MapNas const &,  MapNtN const &>::Callback mef): RegexMatch(){
1200              init();
1201              setCallback(mef);
1202          }
1203          explicit
1204          MatchEvaluator(typename MatchEvaluatorCallback<void*, void*,  MapNtN const &>::Callback mef): RegexMatch(){
1205              init();
1206              setCallback(mef);
1207          }
1208          MatchEvaluator(MatchEvaluator const &me): RegexMatch(me){
1209              init();
1210              deepCopy(me);
1211          }
1212          MatchEvaluator& operator=(MatchEvaluator const &me){
1213              if(this == &me) return *this;
1214              RegexMatch::operator=(me);
1215              deepCopy(me);
1216              return *this;
1217          }
1218          #if JPCRE2_USE_MINIMUM_CXX_11
1219          MatchEvaluator(MatchEvaluator&& me): RegexMatch(me){
1220              init();
1221              deepMove(me);
1222          }
1223          MatchEvaluator& operator=(MatchEvaluator&& me){
1224              if(this == &me) return *this;
1225              RegexMatch::operator=(me);
1226              deepMove(me);
1227              return *this;
1228          }
1229          #endif
1230          virtual ~MatchEvaluator(){}
1231          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, void*, void*>::Callback mef){
1232              callback0 = mef;
1233              callbackn = 0;
1234              return *this;
1235          }
1236          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, void*, void*>::Callback mef){
1237              callback1 = mef;
1238              callbackn = 1;
1239              setNumberedSubstringVector(&vec_num);
1240              return *this;
1241          }
1242          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, void*>::Callback mef){
1243              callback3 = mef;
1244              callbackn = 3;
1245              setNumberedSubstringVector(&vec_num);
1246              setNamedSubstringVector(&vec_nas);
1247              return *this;
1248          }
1249          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, void*,  MapNtN const &>::Callback mef){
1250              callback5 = mef;
1251              callbackn = 5;
1252              setNumberedSubstringVector(&vec_num);
1253              setNameToNumberMapVector(&vec_ntn);
1254              return *this;
1255          }
1256          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<NumSub const &, MapNas const &, MapNtN const &>::Callback mef){
1257              callback7 = mef;
1258              callbackn = 7;
1259              setNumberedSubstringVector(&vec_num);
1260              setNamedSubstringVector(&vec_nas);
1261              setNameToNumberMapVector(&vec_ntn);
1262              return *this;
1263          }
1264          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, MapNas const &, void*>::Callback mef){
1265              callback2 = mef;
1266              callbackn = 2;
1267              setNamedSubstringVector(&vec_nas);
1268              return *this;
1269          }
1270          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, MapNas const &,  MapNtN const &>::Callback mef){
1271              callback6 = mef;
1272              callbackn = 6;
1273              setNamedSubstringVector(&vec_nas);
1274              setNameToNumberMapVector(&vec_ntn);
1275              return *this;
1276          }
1277          MatchEvaluator& setCallback(typename MatchEvaluatorCallback<void*, void*,  MapNtN const &>::Callback mef){
1278              callback4 = mef;
1279              callbackn = 4;
1280              setNameToNumberMapVector(&vec_ntn);
1281              return *this;
1282          }
1283          MatchEvaluator& clearMatchData(){
1284              vec_num.clear();
1285              vec_nas.clear();
1286              vec_ntn.clear();
1287              vec_soff.clear();
1288              vec_eoff.clear();
1289              return *this;
1290          }
1291          MatchEvaluator& resetMatchData(){
1292              VecNum().swap(vec_num);
1293              VecNas().swap(vec_nas);
1294              VecNtN().swap(vec_ntn);
1295              VecOff().swap(vec_soff);
1296              VecOff().swap(vec_eoff);
1297              return *this;
1298          }
1299          MatchEvaluator& reset(){
1300              RegexMatch::reset();
1301              resetMatchData();
1302              init();
1303              return *this;
1304          }
1305          MatchEvaluator& clear(){
1306              RegexMatch::clear();
1307              clearMatchData();
1308              init();
1309              return *this;
1310          }
1311          MatchEvaluator& resetErrors(){
1312              RegexMatch::resetErrors();
1313              return *this;
1314          }
1315          MatchEvaluator& setRegexObject (Regex const *r){
1316              RegexMatch::setRegexObject(r);
1317              return *this;
1318          }
1319          MatchEvaluator& setSubject (String const &s){
1320              RegexMatch::setSubject(s);
1321              return *this;
1322          }
1323          MatchEvaluator& setSubject (String const *s){
1324              RegexMatch::setSubject(s);
1325              return *this;
1326          }
1327          MatchEvaluator& setModifier (Modifier const& s){
1328              RegexMatch::setModifier(s);
1329              return *this;
1330          }
1331          MatchEvaluator& setModifierTable (ModifierTable const * mdt){
1332              RegexMatch::setModifierTable(mdt);
1333              return *this;
1334          }
1335          MatchEvaluator& setJpcre2Option (Uint x){
1336              RegexMatch::setJpcre2Option(x);
1337              return *this;
1338          }
1339          MatchEvaluator& setPcre2Option (Uint x){
1340              RegexMatch::setPcre2Option(x);
1341              return *this;
1342          }
1343          MatchEvaluator& setFindAll (bool x){
1344              RegexMatch::setFindAll(x);
1345              return *this;
1346          }
1347          MatchEvaluator& setFindAll(){
1348              RegexMatch::setFindAll();
1349              return *this;
1350          }
1351          MatchEvaluator& setStartOffset (PCRE2_SIZE offset){
1352              RegexMatch::setStartOffset(offset);
1353              return *this;
1354          }
1355          MatchEvaluator& setMatchContext (MatchContext *match_context){
1356              RegexMatch::setMatchContext(match_context);
1357              return *this;
1358          }
1359          MatchEvaluator& setMatchDataBlock(MatchData* mdt){
1360              RegexMatch::setMatchDataBlock(mdt);
1361              return *this;
1362          }
1363          MatchEvaluator& setBufferSize(PCRE2_SIZE x){
1364              buffer_size = x;
1365              return *this;
1366          }
1367          PCRE2_SIZE getBufferSize(){
1368              return buffer_size;
1369          }
1370          MatchEvaluator& changeModifier (Modifier const& mod, bool x){
1371              RegexMatch::changeModifier(mod, x);
1372              return *this;
1373          }
1374          MatchEvaluator& changeJpcre2Option (Uint opt, bool x){
1375              RegexMatch::changeJpcre2Option(opt, x);
1376              return *this;
1377          }
1378          MatchEvaluator& changePcre2Option (Uint opt, bool x){
1379              RegexMatch::changePcre2Option(opt, x);
1380              return *this;
1381          }
1382          MatchEvaluator& addModifier (Modifier const& mod){
1383              RegexMatch::addModifier(mod);
1384              return *this;
1385          }
1386          MatchEvaluator& addJpcre2Option (Uint x){
1387              RegexMatch::addJpcre2Option(x);
1388              return *this;
1389          }
1390          MatchEvaluator& addPcre2Option (Uint x){
1391              RegexMatch::addPcre2Option(x);
1392              return *this;
1393          }
1394          SIZE_T match(void){
1395              RegexMatch::changePcre2Option(PCRE2_PARTIAL_HARD|PCRE2_PARTIAL_SOFT, false);
1396              return RegexMatch::match();
1397          }
1398          String nreplace(bool do_match=true, Uint jro=0, SIZE_T* counter=0);
1399          String replace(bool do_match=true, Uint ro=0, SIZE_T* counter=0);
1400      };
1401      class RegexReplace {
1402      private:
1403          friend class Regex;
1404          Regex const *re;
1405          String r_subject;
1406          String *r_subject_ptr; 
1407          String r_replw;
1408          String const *r_replw_ptr;
1409          Uint replace_opts;
1410          Uint jpcre2_replace_opts;
1411          PCRE2_SIZE buffer_size;
1412          PCRE2_SIZE _start_offset;
1413          MatchData *mdata;
1414          MatchContext *mcontext;
1415          ModifierTable const * modtab;
1416          SIZE_T last_replace_count;
1417          SIZE_T* last_replace_counter;
1418          void init_vars() {
1419              re = 0;
1420              r_subject_ptr = &r_subject;
1421              r_replw_ptr = &r_replw;
1422              replace_opts = PCRE2_SUBSTITUTE_OVERFLOW_LENGTH;
1423              jpcre2_replace_opts = 0;
1424              buffer_size = 0;
1425              error_number = 0;
1426              error_offset = 0;
1427              _start_offset = 0;
1428              mdata = 0;
1429              mcontext = 0;
1430              modtab = 0;
1431              last_replace_count = 0;
1432              last_replace_counter = &last_replace_count;
1433          }
1434          void onlyCopy(RegexReplace const &rr){
1435              re = rr.re; 
1436              r_subject_ptr = (rr.r_subject_ptr == &rr.r_subject) ? &r_subject 
1437                                                                  : rr.r_subject_ptr; 
1438              r_replw = rr.r_replw;
1439              r_replw_ptr = (rr.r_replw_ptr == &rr.r_replw) ? &r_replw 
1440                                                            : rr.r_replw_ptr; 
1441              replace_opts = rr.replace_opts;
1442              jpcre2_replace_opts = rr.jpcre2_replace_opts;
1443              buffer_size = rr.buffer_size;
1444              error_number = rr.error_number;
1445              error_offset = rr.error_offset;
1446              _start_offset = rr._start_offset;
1447              mdata = rr.mdata;
1448              mcontext = rr.mcontext;
1449              modtab = rr.modtab;
1450              last_replace_count = rr.last_replace_count;
1451              last_replace_counter = (rr.last_replace_counter == &rr.last_replace_count) ? &last_replace_count
1452                                                                                         : rr.last_replace_counter;
1453          }
1454          void deepCopy(RegexReplace const &rr){
1455              r_subject = rr.r_subject;
1456              onlyCopy(rr);
1457          }
1458          #if JPCRE2_USE_MINIMUM_CXX_11
1459          void deepMove(RegexReplace& rr){
1460              r_subject = std::move_if_noexcept(rr.r_subject);
1461              onlyCopy(rr);
1462          }
1463          #endif
1464          protected:
1465          int error_number;
1466          PCRE2_SIZE error_offset;
1467      public:
1468          RegexReplace(){
1469              init_vars();
1470          }
1471          RegexReplace(Regex const *r) {
1472              init_vars();
1473              re = r;
1474          }
1475          RegexReplace(RegexReplace const &rr){
1476              init_vars();
1477              deepCopy(rr);
1478          }
1479          RegexReplace& operator=(RegexReplace const &rr){
1480              if(this == &rr) return *this;
1481              deepCopy(rr);
1482              return *this;
1483          }
1484          #if JPCRE2_USE_MINIMUM_CXX_11
1485          RegexReplace(RegexReplace&& rr){
1486              init_vars();
1487              deepMove(rr);
1488          }
1489          RegexReplace& operator=(RegexReplace&& rr){
1490              if(this == &rr) return *this;
1491              deepMove(rr);
1492              return *this;
1493          }
1494          #endif
1495          virtual ~RegexReplace() {}
1496          RegexReplace& reset() {
1497              String().swap(r_subject);
1498              String().swap(r_replw);
1499              init_vars();
1500              return *this;
1501          }
1502          RegexReplace& clear() {
1503              r_subject.clear();
1504              r_replw.clear();
1505              init_vars();
1506              return *this;
1507          }
1508          RegexReplace& resetErrors(){
1509              error_number = 0;
1510              error_offset = 0;
1511              return *this;
1512          }
1513          int getErrorNumber() const {
1514              return error_number;
1515          }
1516          int getErrorOffset() const  {
1517              return (int)error_offset;
1518          }
1519          String getErrorMessage() const  {
1520              #if JPCRE2_USE_MINIMUM_CXX_11
1521              return select<Char, Map>::getErrorMessage(error_number, error_offset);
1522              #else
1523              return select<Char>::getErrorMessage(error_number, error_offset);
1524              #endif
1525          }
1526          String getReplaceWith() const  {
1527              return *r_replw_ptr;
1528          }
1529          String const * getReplaceWithPointer() const  {
1530              return r_replw_ptr;
1531          }
1532          String getSubject() const  {
1533              return *r_subject_ptr;
1534          }
1535          String const *  getSubjectPointer() const  {
1536              return r_subject_ptr;
1537          }
1538          std::string getModifier() const {
1539              return modtab ? modtab->fromReplaceOption(replace_opts, jpcre2_replace_opts)
1540                            : MOD::fromReplaceOption(replace_opts, jpcre2_replace_opts);
1541          }
1542          ModifierTable const* getModifierTable(){
1543              return modtab;
1544          }
1545          PCRE2_SIZE getStartOffset() const {
1546              return _start_offset;
1547          }
1548          Uint getPcre2Option() const  {
1549              return replace_opts;
1550          }
1551          Uint getJpcre2Option() const  {
1552              return jpcre2_replace_opts;
1553          }
1554          Regex const * getRegexObject() const {
1555              return re;
1556          }
1557          MatchContext* getMatchContext(){
1558              return mcontext;
1559          }
1560          virtual MatchData* getMatchDataBlock(){
1561              return mdata;
1562          }
1563          PCRE2_SIZE getBufferSize(){
1564              return buffer_size;
1565          }
1566          SIZE_T getLastReplaceCount(){
1567              return *last_replace_counter;
1568          }
1569          RegexReplace& setReplaceCounter(SIZE_T* counter){
1570              last_replace_count = 0;
1571              last_replace_counter = counter ? counter : &last_replace_count;
1572              return *this;
1573          }
1574          RegexReplace& setRegexObject(Regex const *r){
1575              re = r;
1576              return *this;
1577          }
1578          RegexReplace& setSubject(String const &s) {
1579              r_subject = s;
1580              r_subject_ptr = &r_subject; 
1581              return *this;
1582          }
1583          RegexReplace& setSubject(String *s) {
1584              if(s) r_subject_ptr = s;
1585              else {
1586                  r_subject.clear();
1587                  r_subject_ptr = &r_subject;
1588              }
1589              return *this;
1590          }
1591          RegexReplace& setReplaceWith(String const &s) {
1592              r_replw = s;
1593              r_replw_ptr = &r_replw; 
1594              return *this;
1595          }
1596          RegexReplace& setReplaceWith(String const *s) {
1597              if(s) r_replw_ptr = s;
1598              else {
1599                  r_replw.clear();
1600                  r_replw_ptr = &r_replw;
1601              }
1602              return *this;
1603          }
1604          RegexReplace& setModifier(Modifier const& s) {
1605              replace_opts = PCRE2_SUBSTITUTE_OVERFLOW_LENGTH; &bsol;* must not be initialized to 0 */
1606              jpcre2_replace_opts = 0;
1607              return changeModifier(s, true);
1608          }
1609          RegexReplace& setModifierTable(ModifierTable const * mdt){
1610              modtab = mdt;
1611              return *this;
1612          }
1613          RegexReplace& setBufferSize(PCRE2_SIZE x) {
1614              buffer_size = x;
1615              return *this;
1616          }
1617          RegexReplace& setStartOffset(PCRE2_SIZE start_offset){
1618              _start_offset = start_offset;
1619              return *this;
1620          }
1621          RegexReplace& setJpcre2Option(Uint x) {
1622              jpcre2_replace_opts = x;
1623              return *this;
1624          }
1625          RegexReplace& setPcre2Option(Uint x) {
1626              replace_opts = PCRE2_SUBSTITUTE_OVERFLOW_LENGTH | x;
1627              return *this;
1628          }
1629          RegexReplace& setMatchContext(MatchContext * match_context){
1630              mcontext = match_context;
1631              return *this;
1632          }
1633          RegexReplace& setMatchDataBlock(MatchData *match_data){
1634              mdata = match_data;
1635              return *this;
1636          }
1637          RegexReplace& changeModifier(Modifier const& mod, bool x){
1638              modtab ? modtab->toReplaceOption(mod, x, &replace_opts, &jpcre2_replace_opts, &error_number, &error_offset)
1639                     : MOD::toReplaceOption(mod, x, &replace_opts, &jpcre2_replace_opts, &error_number, &error_offset);
1640              return *this;
1641          }
1642          RegexReplace& changeJpcre2Option(Uint opt, bool x) {
1643              jpcre2_replace_opts = x ? jpcre2_replace_opts | opt : jpcre2_replace_opts & ~opt;
1644              return *this;
1645          }
1646          RegexReplace& changePcre2Option(Uint opt, bool x) {
1647              replace_opts = x ? replace_opts | opt : replace_opts & ~opt;
1648              return *this;
1649          }
1650          RegexReplace& addModifier(Modifier const& mod){
1651              return changeModifier(mod, true);
1652          }
1653          RegexReplace& addJpcre2Option(Uint x) {
1654              jpcre2_replace_opts |= x;
1655              return *this;
1656          }
1657          RegexReplace& addPcre2Option(Uint x) {
1658              replace_opts |= x;
1659              return *this;
1660          }
1661          String replace(void);
1662          SIZE_T preplace(void){
1663              *r_subject_ptr = replace();
1664              return *last_replace_counter;
1665          }
1666          SIZE_T preplace(MatchEvaluator me){
1667              *r_subject_ptr = me.setRegexObject(getRegexObject())
1668                                 .setSubject(r_subject_ptr) 
1669                                 .setFindAll((getPcre2Option() & PCRE2_SUBSTITUTE_GLOBAL)!=0)
1670                                 .setMatchContext(getMatchContext())
1671                                 .setMatchDataBlock(getMatchDataBlock())
1672                                 .setBufferSize(getBufferSize())
1673                                 .setStartOffset(getStartOffset())
1674                                 .replace(true, getPcre2Option(), last_replace_counter);
1675              return *last_replace_counter;
1676          }
1677          String nreplace(MatchEvaluator me){
1678              return me.setRegexObject(getRegexObject())
1679                       .setSubject(getSubjectPointer())
1680                       .setFindAll((getPcre2Option() & PCRE2_SUBSTITUTE_GLOBAL)!=0)
1681                       .setMatchContext(getMatchContext())
1682                       .setMatchDataBlock(getMatchDataBlock())
1683                       .setStartOffset(getStartOffset())
1684                       .nreplace(true, getJpcre2Option(), last_replace_counter);
1685          }
1686          String replace(MatchEvaluator me){
1687              return me.setRegexObject(getRegexObject())
1688                       .setSubject(getSubjectPointer())
1689                       .setFindAll((getPcre2Option() & PCRE2_SUBSTITUTE_GLOBAL)!=0)
1690                       .setMatchContext(getMatchContext())
1691                       .setMatchDataBlock(getMatchDataBlock())
1692                       .setBufferSize(getBufferSize())
1693                       .setStartOffset(getStartOffset())
1694                       .replace(true, getPcre2Option(), last_replace_counter);
1695          }
1696      };
1697      class Regex {
1698      private:
1699          friend class RegexMatch;
1700          friend class RegexReplace;
1701          friend class MatchEvaluator;
1702          String pat_str;
1703          String const *pat_str_ptr;
1704          Pcre2Code *code;
1705          Uint compile_opts;
1706          Uint jpcre2_compile_opts;
1707          ModifierTable const * modtab;
1708          CompileContext *ccontext;
1709          std::vector<unsigned char> tabv;
1710          void init_vars() {
1711              jpcre2_compile_opts = 0;
1712              compile_opts = 0;
1713              error_number = 0;
1714              error_offset = 0;
1715              code = 0;
1716              pat_str_ptr = &pat_str;
1717              ccontext = 0;
1718              modtab = 0;
1719          }
1720          void freeRegexMemory(void) {
1721              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::code_free(code);
1722              code = 0; 
1723          }
1724          void freeCompileContext(){
1725              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_free(ccontext);
1726              ccontext = 0;
1727          }
1728          void onlyCopy(Regex const &r){
1729              pat_str_ptr = (r.pat_str_ptr == &r.pat_str) ? &pat_str 
1730                                                          : r.pat_str_ptr; 
1731              compile_opts = r.compile_opts;
1732              jpcre2_compile_opts = r.jpcre2_compile_opts;
1733              error_number = r.error_number;
1734              error_offset = r.error_offset;
1735              modtab = r.modtab;
1736          }
1737          void deepCopy(Regex const &r) {
1738              pat_str = r.pat_str; 
1739              onlyCopy(r);
1740              tabv = r.tabv;
1741              freeCompileContext();
1742              ccontext = (r.ccontext) ? Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_copy(r.ccontext) : 0;
1743              if(ccontext  && !tabv.empty()) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_character_tables(ccontext, &tabv[0]);
1744              r.code ? compile() 
1745                     : freeRegexMemory();
1746          }
1747          #if JPCRE2_USE_MINIMUM_CXX_11
1748          void deepMove(Regex& r) {
1749              pat_str = std::move_if_noexcept(r.pat_str);
1750              onlyCopy(r);
1751              tabv = std::move_if_noexcept(r.tabv);
1752              freeCompileContext();
1753              ccontext = r.ccontext; r.ccontext = 0; 
1754              if(ccontext && !tabv.empty()) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_character_tables(ccontext, &tabv[0]);
1755              freeRegexMemory();
1756              code = r.code; r.code = 0; 
1757          }
1758          #endif
1759          protected:
1760          int error_number;
1761          PCRE2_SIZE error_offset;
1762      public:
1763          Regex() {
1764              init_vars();
1765          }
1766          Regex(String const &re) {
1767              init_vars();
1768              compile(re);
1769          }
1770          Regex(String const *re) {
1771              init_vars();
1772              compile(re);
1773          }
1774          Regex(String const &re, Modifier const& mod) {
1775              init_vars();
1776              compile(re, mod);
1777          }
1778          Regex(String const *re, Modifier const& mod) {
1779              init_vars();
1780              compile(re, mod);
1781          }
1782          Regex(String const &re, Uint po) {
1783              init_vars();
1784              compile(re, po);
1785          }
1786          Regex(String const *re, Uint po) {
1787              init_vars();
1788              compile(re, po);
1789          }
1790          Regex(String const &re, Uint po, Uint jo) {
1791              init_vars();
1792              compile(re, po, jo);
1793          }
1794          Regex(String const *re, Uint po, Uint jo) {
1795              init_vars();
1796              compile(re, po, jo);
1797          }
1798          Regex(Regex const &r) {
1799              init_vars();
1800              deepCopy(r);
1801          }
1802          Regex& operator=(Regex const &r) {
1803              if (this == &r) return *this;
1804              deepCopy(r);
1805              return *this;
1806          }
1807          #if JPCRE2_USE_MINIMUM_CXX_11
1808          Regex(Regex&& r) {
1809              init_vars();
1810              deepMove(r);
1811          }
1812          Regex& operator=(Regex&& r) {
1813              if (this == &r) return *this;
1814              deepMove(r);
1815              return *this;
1816          }
1817          explicit operator bool() const {
1818              return (code != 0);
1819          }
1820          #endif
1821          bool operator!() const {
1822              return (code == 0);
1823          }
1824          virtual ~Regex() {
1825              freeRegexMemory();
1826              freeCompileContext();
1827          }
1828          Regex& reset() {
1829              freeRegexMemory();
1830              freeCompileContext();
1831              String().swap(pat_str);
1832              init_vars();
1833              return *this;
1834          }
1835          Regex& clear() {
1836              freeRegexMemory();
1837              freeCompileContext();
1838              pat_str.clear();
1839              init_vars();
1840              return *this;
1841          }
1842          Regex& resetErrors() {
1843              error_number = 0;
1844              error_offset = 0;
1845              return *this;
1846          }
1847          Regex& resetCharacterTables() {
1848              const unsigned char* tables = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::maketables(0); 
1849              tabv = std::vector<unsigned char>(tables, tables+1088);
1850              ::free((void*)tables); 
1851              if(!ccontext)
1852                  ccontext = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_create(0);
1853              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_character_tables(ccontext, &tabv[0]);
1854              return *this;
1855          }
1856          Pcre2Code const* getPcre2Code() const{
1857              return code;
1858          }
1859          String getPattern() const  {
1860              return *pat_str_ptr;
1861          }
1862          String const * getPatternPointer() const  {
1863              return pat_str_ptr;
1864          }
1865          std::string getModifier() const {
1866              return modtab ? modtab->fromCompileOption(compile_opts, jpcre2_compile_opts)
1867                            : MOD::fromCompileOption(compile_opts, jpcre2_compile_opts);
1868          }
1869          Uint getPcre2Option() const  {
1870              return compile_opts;
1871          }
1872          Uint getJpcre2Option() const  {
1873              return jpcre2_compile_opts;
1874          }
1875          int getErrorNumber() const {
1876              return error_number;
1877          }
1878          int getErrorOffset() const  {
1879              return (int)error_offset;
1880          }
1881          String getErrorMessage() const  {
1882              #if JPCRE2_USE_MINIMUM_CXX_11
1883              return select<Char, Map>::getErrorMessage(error_number, error_offset);
1884              #else
1885              return select<Char>::getErrorMessage(error_number, error_offset);
1886              #endif
1887          }
1888          Uint getNewLine() {
1889              if(!code) return 0;
1890              Uint newline = 0;
1891              int ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info(code, PCRE2_INFO_NEWLINE, &newline);
1892              if(ret < 0) error_number = ret;
1893              return newline;
1894          }
1895          ModifierTable const* getModifierTable(){
1896              return modtab;
1897          }
1898          Regex& setNewLine(Uint value){
1899              if(!ccontext)
1900                  ccontext = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile_context_create(0);
1901              int ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::set_newline(ccontext, value);
1902              if(ret < 0) error_number = ret;
1903              return *this;
1904          }
1905          Regex& setPattern(String const &re) {
1906              pat_str = re;
1907              pat_str_ptr = &pat_str; 
1908              return *this;
1909          }
1910          Regex& setPattern(String const *re) {
1911              if(re) pat_str_ptr = re;
1912              else {
1913                  pat_str.clear();
1914                  pat_str_ptr = &pat_str;
1915              }
1916              return *this;
1917          }
1918          Regex& setModifier(Modifier const& x) {
1919              compile_opts = 0;
1920              jpcre2_compile_opts = 0;
1921              return changeModifier(x, true);
1922          }
1923          Regex& setModifierTable(ModifierTable const * mdt){
1924              modtab = mdt;
1925              return *this;
1926          }
1927          Regex& setJpcre2Option(Uint x) {
1928              jpcre2_compile_opts = x;
1929              return *this;
1930          }
1931          Regex& setPcre2Option(Uint x) {
1932              compile_opts = x;
1933              return *this;
1934          }
1935          Regex& changeModifier(Modifier const& mod, bool x){
1936              modtab ? modtab->toCompileOption(mod, x, &compile_opts, &jpcre2_compile_opts, &error_number, &error_offset)
1937                     : MOD::toCompileOption(mod, x, &compile_opts, &jpcre2_compile_opts, &error_number, &error_offset);
1938              return *this;
1939          }
1940          Regex& changeJpcre2Option(Uint opt, bool x) {
1941              jpcre2_compile_opts = x ? jpcre2_compile_opts | opt : jpcre2_compile_opts & ~opt;
1942              return *this;
1943          }
1944          Regex& changePcre2Option(Uint opt, bool x) {
1945              compile_opts = x ? compile_opts | opt : compile_opts & ~opt;
1946              return *this;
1947          }
1948          Regex& addModifier(Modifier const& mod){
1949              return changeModifier(mod, true);
1950          }
1951          Regex& addJpcre2Option(Uint x) {
1952              jpcre2_compile_opts |= x;
1953              return *this;
1954          }
1955          Regex& addPcre2Option(Uint x) {
1956              compile_opts |= x;
1957              return *this;
1958          }
1959          void compile(void);
1960          void compile(String const &re, Uint po, Uint jo) {
1961              setPattern(re).setPcre2Option(po).setJpcre2Option(jo);
1962              compile();
1963          }
1964          void compile(String const *re, Uint po, Uint jo) {
1965              setPattern(re).setPcre2Option(po).setJpcre2Option(jo);
1966              compile();
1967          }
1968          void compile(String const &re, Uint po) {
1969              setPattern(re).setPcre2Option(po);
1970              compile();
1971          }
1972          void compile(String const *re, Uint po) {
1973              setPattern(re).setPcre2Option(po);
1974              compile();
1975          }
1976          void compile(String const &re, Modifier const& mod) {
1977              setPattern(re).setModifier(mod);
1978              compile();
1979          }
1980          void compile(String const *re, Modifier const& mod) {
1981              setPattern(re).setModifier(mod);
1982              compile();
1983          }
1984          void compile(String const &re) {
1985              setPattern(re);
1986              compile();
1987          }
1988          void compile(String const *re) {
1989              setPattern(re);
1990              compile();
1991          }
1992          RegexMatch initMatch(){
1993              RegexMatch rm(this);
1994              rm.setModifierTable(modtab);
1995              return rm;
1996          }
1997          RegexMatch getMatchObject(){
1998              return initMatch();
1999          }
2000          SIZE_T match(String const &s, Modifier const& mod, PCRE2_SIZE start_offset=0) {
2001              return initMatch().setStartOffset(start_offset).setSubject(s).setModifier(mod).match();
2002          }
2003          SIZE_T match(String const *s, Modifier const& mod, PCRE2_SIZE start_offset=0) {
2004              return initMatch().setStartOffset(start_offset).setSubject(s).setModifier(mod).match();
2005          }
2006          SIZE_T match(String const &s,  PCRE2_SIZE start_offset=0) {
2007              return initMatch().setStartOffset(start_offset).setSubject(s).match();
2008          }
2009          SIZE_T match(String const *s,  PCRE2_SIZE start_offset=0) {
2010              return initMatch().setStartOffset(start_offset).setSubject(s).match();
2011          }
2012          RegexReplace initReplace(){
2013              RegexReplace rr(this);
2014              rr.setModifierTable(modtab);
2015              return rr;
2016          }
2017          RegexReplace getReplaceObject(){
2018              return initReplace();
2019          }
2020          String replace(String const &mains, String const &repl, Modifier const& mod="", SIZE_T* counter=0) {
2021              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2022          }
2023          String replace(String *mains, String const &repl, Modifier const& mod="", SIZE_T* counter=0) {
2024              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2025          }
2026          String replace(String const &mains, String const *repl, Modifier const& mod="", SIZE_T* counter=0) {
2027              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2028          }
2029          String replace(String *mains, String const *repl, Modifier const& mod="", SIZE_T* counter=0) {
2030              return initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(counter).replace();
2031          }
2032          SIZE_T preplace(String * mains, String const& repl, Modifier const& mod=""){
2033              SIZE_T counter = 0;
2034              if(mains) *mains = initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2035              return counter;
2036          }
2037          SIZE_T preplace(String * mains, String const* repl, Modifier const& mod=""){
2038              SIZE_T counter = 0;
2039              if(mains) *mains = initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2040              return counter;
2041          }
2042          SIZE_T preplace(String const& mains, String const& repl, Modifier const& mod=""){
2043              SIZE_T counter = 0;
2044              initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2045              return counter;
2046          }
2047          SIZE_T preplace(String const& mains, String const* repl, Modifier const& mod=""){
2048              SIZE_T counter = 0;
2049              initReplace().setSubject(mains).setReplaceWith(repl).setModifier(mod).setReplaceCounter(&counter).replace();
2050              return counter;
2051          }
2052      };
2053      private:
2054      select();
2055      select(select const &);
2056      #if JPCRE2_USE_MINIMUM_CXX_11
2057      select(select&&);
2058      #endif
2059      ~select();
2060  };
2061  }
2062  inline void jpcre2::ModifierTable::parseModifierTable(std::string& tabjs, VecOpt& tabjv,
2063                                                       std::string& tab_s, VecOpt& tab_v,
2064                                                       std::string const& tabs, VecOpt const& tabv){
2065      SIZE_T n = tabs.length();
2066      JPCRE2_ASSERT(n == tabv.size(), ("ValueError: Could not set Modifier table.\
2067      Modifier character and value tables are not of the same size (" + _tostdstring(n) + " == " + _tostdstring(tabv.size()) + ").").c_str());
2068      tabjs.clear();
2069      tab_s.clear(); tab_s.reserve(n);
2070      tabjv.clear();
2071      tab_v.clear(); tab_v.reserve(n);
2072      for(SIZE_T i=0;i<n;++i){
2073          switch(tabv[i]){
2074              case JIT_COMPILE:
2075              case FIND_ALL: 
2076                  tabjs.push_back(tabs[i]); tabjv.push_back(tabv[i]);break;
2077              default: tab_s.push_back(tabs[i]); tab_v.push_back(tabv[i]); break;
2078          }
2079      }
2080  }
2081  #if JPCRE2_USE_MINIMUM_CXX_11
2082  template<typename Char_T, template<typename...> class Map>
2083  void jpcre2::select<Char_T, Map>::Regex::compile() {
2084  #else
2085  template<typename Char_T>
2086  void jpcre2::select<Char_T>::Regex::compile() {
2087  #endif
2088      Pcre2Sptr c_pattern = (Pcre2Sptr) pat_str_ptr->c_str();
2089      int err_number = 0;
2090      PCRE2_SIZE err_offset = 0;
2091      freeRegexMemory();
2092      code = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::compile(  c_pattern,              &bsol;* the pattern */
2093                                      PCRE2_ZERO_TERMINATED,  &bsol;* indicates pattern is zero-terminated */
2094                                      compile_opts,           &bsol;* default options */
2095                                      &err_number,            &bsol;* for error number */
2096                                      &err_offset,            &bsol;* for error offset */
2097                                      ccontext);              &bsol;* use compile context */
2098      if (code == 0) {
2099          error_number = err_number;
2100          error_offset = err_offset;
2101          return;
2102      } else if ((jpcre2_compile_opts & JIT_COMPILE) != 0) {
2103          int jit_ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::jit_compile(code, PCRE2_JIT_COMPLETE);
2104          if(jit_ret < 0) error_number = jit_ret;
2105      }
2106  }
2107  #if JPCRE2_USE_MINIMUM_CXX_11
2108  template<typename Char_T, template<typename...> class Map>
2109  typename jpcre2::select<Char_T, Map>::String jpcre2::select<Char_T, Map>::MatchEvaluator::replace(bool do_match, Uint replace_opts, SIZE_T * counter) {
2110  #else
2111  template<typename Char_T>
2112  typename jpcre2::select<Char_T>::String jpcre2::select<Char_T>::MatchEvaluator::replace(bool do_match, Uint replace_opts, SIZE_T * counter) {
2113  #endif
2114      if(counter) *counter = 0;
2115      replace_opts |= PCRE2_SUBSTITUTE_OVERFLOW_LENGTH;
2116      replace_opts &= ~PCRE2_SUBSTITUTE_GLOBAL;
2117      Regex const * re = RegexMatch::getRegexObject();
2118      if (!re || re->code == 0)
2119          return RegexMatch::getSubject();
2120      Pcre2Sptr r_subject_ptr = (Pcre2Sptr) RegexMatch::getSubjectPointer()->c_str();
2121      if(do_match) match();
2122      SIZE_T mcount = vec_soff.size();
2123      if(!mcount) return RegexMatch::getSubject();
2124      SIZE_T current_offset = 0; 
2125      String res, tmp;
2126      SIZE_T last = vec_eoff.size();
2127      last = (last>0)?last-1:0;
2128      JPCRE2_ASSERT(vec_eoff[last] <= RegexMatch::getSubject().size(), "ValueError: subject string is not of the required size, may be it's changed!!!\
2129      If you are using esisting match data, try a new match.");
2130      for(SIZE_T i=0;i<mcount;++i){
2131          if(vec_soff[i] < current_offset || vec_eoff[i] < vec_soff[i]){
2132              RegexMatch::error_number = PCRE2_ERROR_BADSUBSPATTERN;
2133              return RegexMatch::getSubject();
2134          } else {
2135              res += String(r_subject_ptr+current_offset, r_subject_ptr+vec_soff[i]);
2136          }
2137          switch(callbackn){
2138              case 0: tmp = callback0((void*)0, (void*)0, (void*)0); break;
2139              case 1: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount, "VecNum");
2140                      tmp = callback1(vec_num[i], (void*)0, (void*)0); break;
2141              case 2: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount, "VecNas");
2142                      tmp = callback2((void*)0, vec_nas[i], (void*)0); break;
2143              case 3: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount, "VecNum or VecNas");
2144                      tmp = callback3(vec_num[i], vec_nas[i], (void*)0); break;
2145              case 4: JPCRE2_VECTOR_DATA_ASSERT(vec_ntn.size() == mcount, "VecNtn");
2146                      tmp = callback4((void*)0, (void*)0, vec_ntn[i]); break;
2147              case 5: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_ntn.size() == mcount, "VecNum or VecNtn");
2148                      tmp = callback5(vec_num[i], (void*)0, vec_ntn[i]); break;
2149              case 6: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNas or VecNtn");
2150                      tmp = callback6((void*)0, vec_nas[i], vec_ntn[i]); break;
2151              case 7: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNum\n or VecNas or VecNtn");
2152                      tmp = callback7(vec_num[i], vec_nas[i], vec_ntn[i]); break;
2153              default: JPCRE2_ASSERT(2 == 1, "Invalid callbackn. Please file a bug report (must include the line number from below)."); break;
2154          }
2155          current_offset = vec_eoff[i];
2156          Pcre2Sptr subject = r_subject_ptr + vec_soff[i];
2157          PCRE2_SIZE subject_length = vec_eoff[i] - vec_soff[i];
2158          Pcre2Sptr replace = (Pcre2Sptr) tmp.c_str();
2159          PCRE2_SIZE replace_length = tmp.length();
2160          bool retry = true;
2161          int ret = 0;
2162          PCRE2_SIZE outlengthptr = 0;
2163          Pcre2Uchar* output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2164          while (true) {
2165              ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::substitute(
2166                          re->code,               &bsol;*Points to the compiled pattern*/
2167                          subject,                &bsol;*Points to the subject string*/
2168                          subject_length,         &bsol;*Length of the subject string*/
2169                          0,                      &bsol;*Offset in the subject at which to start matching*/ 
2170                          replace_opts,           &bsol;*Option bits*/
2171                          RegexMatch::mdata,      &bsol;*Points to a match data block, or is NULL*/
2172                          RegexMatch::mcontext,   &bsol;*Points to a match context, or is NULL*/
2173                          replace,                &bsol;*Points to the replacement string*/
2174                          replace_length,         &bsol;*Length of the replacement string*/
2175                          output_buffer,          &bsol;*Points to the output buffer*/
2176                          &outlengthptr           &bsol;*Points to the length of the output buffer*/
2177                          );
2178              if (ret < 0) {
2179                  if ((replace_opts & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0
2180                          && ret == (int) PCRE2_ERROR_NOMEMORY && retry) {
2181                      retry = false;
2182                      delete[] output_buffer;
2183                      output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2184                      continue;
2185                  } else {
2186                      RegexMatch::error_number = ret;
2187                      delete[] output_buffer;
2188                      return RegexMatch::getSubject();
2189                  }
2190              }
2191              break;
2192          }
2193          res += String((Char*) output_buffer,(Char*) (output_buffer + outlengthptr) );
2194          delete[] output_buffer;
2195          if(counter) *counter += ret;
2196          if((RegexMatch::getJpcre2Option() & FIND_ALL) == 0) break;
2197      }
2198      res += RegexMatch::getSubject().substr(current_offset, String::npos);
2199      return res;
2200  }
2201  #if JPCRE2_USE_MINIMUM_CXX_11
2202  template<typename Char_T, template<typename...> class Map>
2203  typename jpcre2::select<Char_T, Map>::String jpcre2::select<Char_T, Map>::MatchEvaluator::nreplace(bool do_match, Uint jo, SIZE_T* counter){
2204  #else
2205  template<typename Char_T>
2206  typename jpcre2::select<Char_T>::String jpcre2::select<Char_T>::MatchEvaluator::nreplace(bool do_match, Uint jo, SIZE_T* counter){
2207  #endif
2208      if(counter) *counter = 0;
2209      if(do_match) match();
2210      SIZE_T mcount = vec_soff.size();
2211      if(!mcount) return RegexMatch::getSubject();
2212      SIZE_T current_offset = 0; 
2213      String res;
2214      SIZE_T last = vec_eoff.size();
2215      last = (last>0)?last-1:0;
2216      JPCRE2_ASSERT(vec_eoff[last] <= RegexMatch::getSubject().size(), "ValueError: subject string is not of the required size, may be it's changed!!!\
2217      If you are using esisting match data, try a new match.");
2218      for(SIZE_T i=0;i<mcount;++i){
2219          if(vec_soff[i] < current_offset){
2220              RegexMatch::error_number = PCRE2_ERROR_BADSUBSPATTERN;
2221              return RegexMatch::getSubject();
2222          } else {
2223              res += RegexMatch::getSubject().substr(current_offset, vec_soff[i]-current_offset);
2224          }
2225          switch(callbackn){
2226              case 0: res += callback0((void*)0, (void*)0, (void*)0); break;
2227              case 1: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount, "VecNum");
2228                      res += callback1(vec_num[i], (void*)0, (void*)0); break;
2229              case 2: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount, "VecNas");
2230                      res += callback2((void*)0, vec_nas[i], (void*)0); break;
2231              case 3: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount, "VecNum or VecNas");
2232                      res += callback3(vec_num[i], vec_nas[i], (void*)0); break;
2233              case 4: JPCRE2_VECTOR_DATA_ASSERT(vec_ntn.size() == mcount, "VecNtn");
2234                      res += callback4((void*)0, (void*)0, vec_ntn[i]); break;
2235              case 5: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_ntn.size() == mcount, "VecNum or VecNtn");
2236                      res += callback5(vec_num[i], (void*)0, vec_ntn[i]); break;
2237              case 6: JPCRE2_VECTOR_DATA_ASSERT(vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNas or VecNtn");
2238                      res += callback6((void*)0, vec_nas[i], vec_ntn[i]); break;
2239              case 7: JPCRE2_VECTOR_DATA_ASSERT(vec_num.size() == mcount && vec_nas.size() == mcount && vec_ntn.size() == mcount, "VecNum\n or VecNas or VecNtn");
2240                      res += callback7(vec_num[i], vec_nas[i], vec_ntn[i]); break;
2241              default: JPCRE2_ASSERT(2 == 1, "Invalid callbackn. Please file a bug report (must include the line number from below)."); break;
2242          }
2243          current_offset = vec_eoff[i];
2244          if(counter) *counter += 1;
2245          if((RegexMatch::getJpcre2Option() & FIND_ALL) == 0) break;
2246      }
2247      res += RegexMatch::getSubject().substr(current_offset, String::npos);
2248      return res;
2249  }
2250  #if JPCRE2_USE_MINIMUM_CXX_11
2251  template<typename Char_T, template<typename...> class Map>
2252  typename jpcre2::select<Char_T, Map>::String jpcre2::select<Char_T, Map>::RegexReplace::replace() {
2253  #else
2254  template<typename Char_T>
2255  typename jpcre2::select<Char_T>::String jpcre2::select<Char_T>::RegexReplace::replace() {
2256  #endif
2257      *last_replace_counter = 0;
2258      if (!re || re->code == 0)
2259          return *r_subject_ptr;
2260      Pcre2Sptr subject = (Pcre2Sptr) r_subject_ptr->c_str();
2261      PCRE2_SIZE subject_length = r_subject_ptr->length();
2262      Pcre2Sptr replace = (Pcre2Sptr) r_replw_ptr->c_str();
2263      PCRE2_SIZE replace_length = r_replw_ptr->length();
2264      PCRE2_SIZE outlengthptr = (PCRE2_SIZE) buffer_size;
2265      bool retry = true;
2266      int ret = 0;
2267      Pcre2Uchar* output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2268      while (true) {
2269          ret = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::substitute(
2270                      re->code,               &bsol;*Points to the compiled pattern*/
2271                      subject,                &bsol;*Points to the subject string*/
2272                      subject_length,         &bsol;*Length of the subject string*/
2273                      _start_offset,          &bsol;*Offset in the subject at which to start matching*/
2274                      replace_opts,           &bsol;*Option bits*/
2275                      mdata,                  &bsol;*Points to a match data block, or is NULL*/
2276                      mcontext,               &bsol;*Points to a match context, or is NULL*/
2277                      replace,                &bsol;*Points to the replacement string*/
2278                      replace_length,         &bsol;*Length of the replacement string*/
2279                      output_buffer,          &bsol;*Points to the output buffer*/
2280                      &outlengthptr           &bsol;*Points to the length of the output buffer*/
2281                      );
2282          if (ret < 0) {
2283              if ((replace_opts & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0
2284                      && ret == (int) PCRE2_ERROR_NOMEMORY && retry) {
2285                  retry = false;
2286                  delete[] output_buffer;
2287                  output_buffer = new Pcre2Uchar[outlengthptr + 1]();
2288                  continue;
2289              } else {
2290                  error_number = ret;
2291                  delete[] output_buffer;
2292                  return *r_subject_ptr;
2293              }
2294          }
2295          break;
2296      }
2297      *last_replace_counter += ret;
2298      String result = String((Char*) output_buffer,(Char*) (output_buffer + outlengthptr) );
2299      delete[] output_buffer;
2300      return result;
2301  }
2302  #if JPCRE2_USE_MINIMUM_CXX_11
2303  template<typename Char_T, template<typename...> class Map>
2304  bool jpcre2::select<Char_T, Map>::RegexMatch::getNumberedSubstrings(int rc, Pcre2Sptr subject, PCRE2_SIZE* ovector, uint32_t ovector_count) {
2305  #else
2306  template<typename Char_T>
2307  bool jpcre2::select<Char_T>::RegexMatch::getNumberedSubstrings(int rc, Pcre2Sptr subject, PCRE2_SIZE* ovector, uint32_t ovector_count) {
2308  #endif
2309      NumSub num_sub;
2310      uint32_t rcu = rc;
2311      num_sub.reserve(rcu); 
2312      uint32_t i;
2313      for (i = 0u; i < rcu; i++)
2314          num_sub.push_back(String((Char*)(subject + ovector[2*i]), ovector[2*i+1] - ovector[2*i]));
2315      for (uint32_t j = i; j < ovector_count; j++)
2316          num_sub.push_back(String());
2317      vec_num->push_back(num_sub); 
2318      return true;
2319  }
2320  #if JPCRE2_USE_MINIMUM_CXX_11
2321  template<typename Char_T, template<typename...> class Map>
2322  bool jpcre2::select<Char_T, Map>::RegexMatch::getNamedSubstrings(int namecount, int name_entry_size,
2323                                                              Pcre2Sptr name_table,
2324                                                              Pcre2Sptr subject, PCRE2_SIZE* ovector ) {
2325  #else
2326  template<typename Char_T>
2327  bool jpcre2::select<Char_T>::RegexMatch::getNamedSubstrings(int namecount, int name_entry_size,
2328                                                              Pcre2Sptr name_table,
2329                                                              Pcre2Sptr subject, PCRE2_SIZE* ovector ) {
2330  #endif
2331      Pcre2Sptr tabptr = name_table;
2332      String key;
2333      MapNas map_nas;
2334      MapNtN map_ntn;
2335      for (int i = 0; i < namecount; i++) {
2336          int n;
2337          if(sizeof( Char_T ) * CHAR_BIT == 8){
2338              n = (int)((tabptr[0] << 8) | tabptr[1]);
2339              key = toString((Char*) (tabptr + 2));
2340          }
2341          else{
2342              n = (int)tabptr[0];
2343              key = toString((Char*) (tabptr + 1));
2344          }
2345          tabptr += name_entry_size;
2346          String value((Char*)(subject + ovector[2*n]), ovector[2*n+1] - ovector[2*n]); 
2347          if(vec_nas) map_nas[key] = value;
2348          if(vec_ntn) map_ntn[key] = n;
2349      }
2350      if(vec_nas) vec_nas->push_back(map_nas);
2351      if(vec_ntn) vec_ntn->push_back(map_ntn);
2352      return true;
2353  }
2354  #if JPCRE2_USE_MINIMUM_CXX_11
2355  template<typename Char_T, template<typename...> class Map>
2356  jpcre2::SIZE_T jpcre2::select<Char_T, Map>::RegexMatch::match() {
2357  #else
2358  template<typename Char_T>
2359  jpcre2::SIZE_T jpcre2::select<Char_T>::RegexMatch::match() {
2360  #endif
2361      if (!re || re->code == 0)
2362          return 0;
2363      Pcre2Sptr subject = (Pcre2Sptr) m_subject_ptr->c_str();
2364      Pcre2Sptr name_table = 0;
2365      int crlf_is_newline = 0;
2366      int namecount = 0;
2367      int name_entry_size = 0;
2368      int rc = 0;
2369      uint32_t ovector_count = 0;
2370      int utf = 0;
2371      SIZE_T count = 0;
2372      Uint option_bits;
2373      Uint newline = 0;
2374      PCRE2_SIZE *ovector = 0;
2375      SIZE_T subject_length = 0;
2376      MatchData *match_data = 0;
2377      subject_length = m_subject_ptr->length();
2378      bool mdc = false; 
2379      if (vec_num) vec_num->clear();
2380      if (vec_nas) vec_nas->clear();
2381      if (vec_ntn) vec_ntn->clear();
2382      if(vec_soff) vec_soff->clear();
2383      if(vec_eoff) vec_eoff->clear();
2384      if(mdata) match_data = mdata;
2385      else {
2386          match_data = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_create_from_pattern(re->code, 0);
2387          mdc = true;
2388      }
2389      rc = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match(  re->code,       &bsol;* the compiled pattern */
2390                                  subject,        &bsol;* the subject string */
2391                                  subject_length, &bsol;* the length of the subject */
2392                                  _start_offset,  &bsol;* start at offset 'start_offset' in the subject */
2393                                  match_opts,     &bsol;* default options */
2394                                  match_data,     &bsol;* block for storing the result */
2395                                  mcontext);      &bsol;* use default match context */
2396      if (rc < 0) {
2397          if(mdc)
2398              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data); &bsol;* Release memory used for the match */
2399          switch (rc) {
2400              case PCRE2_ERROR_NOMATCH:
2401                  return count;
2402              default:;
2403          }
2404          error_number = rc;
2405          return count;
2406      }
2407      ++count; 
2408      ovector = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::get_ovector_pointer(match_data);
2409      ovector_count = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::get_ovector_count(match_data);
2410      if (rc == 0) {
2411          error_number = (int)ERROR::INSUFFICIENT_OVECTOR;
2412          rc = ovector_count;
2413      }
2414      if(vec_soff) vec_soff->push_back(ovector[0]);
2415      if(vec_eoff) vec_eoff->push_back(ovector[1]);
2416      if (vec_num) { 
2417          if(!getNumberedSubstrings(rc, subject, ovector, ovector_count))
2418              return count;
2419      }
2420      if (vec_nas || vec_ntn) {
2421          (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info( re->code,               &bsol;* the compiled pattern */
2422                                              PCRE2_INFO_NAMECOUNT,   &bsol;* get the number of named substrings */
2423                                              &namecount);            &bsol;* where to put the answer */
2424          if (namecount <= 0); &bsol;*No named substrings*/
2425          else {
2426              (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info( re->code,               &bsol;* the compiled pattern */
2427                                                  PCRE2_INFO_NAMETABLE,   &bsol;* address of the table */
2428                                                  &name_table);           &bsol;* where to put the answer */
2429              (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info( re->code,                   &bsol;* the compiled pattern */
2430                                                  PCRE2_INFO_NAMEENTRYSIZE,   &bsol;* size of each entry in the table */
2431                                                  &name_entry_size);          &bsol;* where to put the answer */
2432          }
2433          if(!getNamedSubstrings(namecount, name_entry_size, name_table, subject, ovector))
2434              return count;
2435      }
2436      if ((jpcre2_match_opts & FIND_ALL) == 0) {
2437          if(mdc)
2438              Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data); &bsol;* Release the memory that was used */
2439          return count; &bsol;* Exit the program. */
2440      }
2441      (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info(re->code, PCRE2_INFO_ALLOPTIONS, &option_bits);
2442      utf = ((option_bits & PCRE2_UTF) != 0);
2443      (void) Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::pattern_info(re->code, PCRE2_INFO_NEWLINE, &newline);
2444      crlf_is_newline = newline == PCRE2_NEWLINE_ANY
2445              || newline == PCRE2_NEWLINE_CRLF
2446              || newline == PCRE2_NEWLINE_ANYCRLF;
2447      for (;;) {
2448          Uint options = match_opts; &bsol;* Normally no options */
2449          PCRE2_SIZE start_offset = ovector[1]; &bsol;* Start at end of previous match */
2450          if (ovector[0] == ovector[1]) {
2451              if (ovector[0] == subject_length)
2452                  break;
2453              options |= PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;
2454          }
2455          rc = Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match(  re->code,       &bsol;* the compiled pattern */
2456                                      subject,        &bsol;* the subject string */
2457                                      subject_length, &bsol;* the length of the subject */
2458                                      start_offset,   &bsol;* starting offset in the subject */
2459                                      options,        &bsol;* options */
2460                                      match_data,     &bsol;* block for storing the result */
2461                                      mcontext);      &bsol;* use match context */
2462          if (rc == PCRE2_ERROR_NOMATCH) {
2463              if (options == 0)
2464                  break;                          &bsol;* All matches found */
2465              ovector[1] = start_offset + 1; &bsol;* Advance one code unit */
2466              if (crlf_is_newline &&                      &bsol;* If CRLF is newline & */
2467                  start_offset < subject_length - 1 &&    &bsol;* we are at CRLF, */
2468                  subject[start_offset] == '\r' && subject[start_offset + 1] == '\n')
2469                  ovector[1] += 1;                        &bsol;* Advance by one more. */
2470              else if (utf) { &bsol;* advance a whole UTF (8 or 16), for UTF-32, it's not needed */
2471                  while (ovector[1] < subject_length) {
2472                      if(sizeof( Char_T ) * CHAR_BIT == 8 && (subject[ovector[1]] & 0xc0) != 0x80) break;
2473                      else if(sizeof( Char_T ) * CHAR_BIT == 16 && (subject[ovector[1]] & 0xfc00) != 0xdc00) break;
2474                      else if(sizeof( Char_T ) * CHAR_BIT == 32) break; 
2475                      ovector[1] += 1;
2476                  }
2477              }
2478              continue; &bsol;* Go round the loop again */
2479          }
2480          if (rc < 0) {
2481              if(mdc)
2482                  Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data);
2483              error_number = rc;
2484              return count;
2485          }
2486          ++count; 
2487          if (rc == 0) {
2488              error_number = (int)ERROR::INSUFFICIENT_OVECTOR;
2489              rc = ovector_count;
2490          }
2491          if(vec_soff) vec_soff->push_back(ovector[0]);
2492          if(vec_eoff) vec_eoff->push_back(ovector[1]);
2493          if (vec_num) { 
2494              if(!getNumberedSubstrings(rc, subject, ovector, ovector_count))
2495                  return count;
2496          }
2497          if (vec_nas || vec_ntn) {
2498              if(!getNamedSubstrings(namecount, name_entry_size, name_table, subject, ovector))
2499                  return count;
2500          }
2501      } &bsol;* End of loop to find second and subsequent matches */
2502      if(mdc)
2503          Pcre2Func<sizeof( Char_T ) * CHAR_BIT>::match_data_free(match_data);
2504      return count;
2505  }
2506  #undef JPCRE2_VECTOR_DATA_ASSERT
2507  #undef JPCRE2_UNUSED
2508  #undef JPCRE2_USE_MINIMUM_CXX_11
2509  #ifdef __DOXYGEN__
2510  #ifndef JPCRE2_USE_FUNCTION_POINTER_CALLBACK
2511  #define JPCRE2_USE_FUNCTION_POINTER_CALLBACK
2512  #endif
2513  #ifndef JPCRE2_NDEBUG
2514  #define JPCRE2_NDEBUG
2515  #endif
2516  #endif
2517  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blocks.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-jpcre2.hpp</div>
                </div>
                <div class="column column_space"><pre><code>868  	return result;
869  }
870  nano::root const & nano::change_block::root () const
871  {
872  	return hashables.previous;
873  }
874  nano::account const & nano::change_block::representative () const
875  {
876  	return hashables.representative;
877  }
878  nano::signature const & nano::change_block::block_signature () const
879  {
880  	return signature;
</pre></code></div>
                <div class="column column_space"><pre><code>877              return *this;
878          }
879          virtual int getErrorNumber() const {
880              return error_number;
881          }
882          virtual int getErrorOffset() const  {
883              return (int)error_offset;
884          }
885          virtual String getErrorMessage() const  {
886              #if JPCRE2_USE_MINIMUM_CXX_11
887              return select<Char, Map>::getErrorMessage(error_number, error_offset);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    