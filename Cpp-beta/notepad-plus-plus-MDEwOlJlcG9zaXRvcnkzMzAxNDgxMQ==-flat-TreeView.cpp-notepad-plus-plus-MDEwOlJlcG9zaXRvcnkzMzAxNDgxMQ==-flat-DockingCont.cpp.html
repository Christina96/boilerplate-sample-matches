
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.511627906976744%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TreeView.cpp</h3>
            <pre><code>1  #include "TreeView.h"
2  #include "Parameters.h"
3  #define CY_ITEMHEIGHT     18
4  void TreeView::init(HINSTANCE hInst, HWND parent, int treeViewID)
5  {
6  	Window::init(hInst, parent);
7  	_hSelf = ::GetDlgItem(parent, treeViewID);
8  	const auto treeViewStyles = WS_HSCROLL | WS_TABSTOP | TVS_LINESATROOT\
9  						| TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS\
10  						| TVS_EDITLABELS | TVS_INFOTIP;
11  	_hSelf = CreateWindowEx(0,
12  							WC_TREEVIEW,
13  							TEXT("Tree View"),
14  							WS_CHILD | WS_BORDER | treeViewStyles,
15  							0,
16  							0,
17  							0,
18  							0,
19  							_hParent,
20  							nullptr,
21  							_hInst,
22  							nullptr);
23  	NppDarkMode::setTreeViewStyle(_hSelf);
24  	int itemHeight = NppParameters::getInstance()._dpiManager.scaleY(CY_ITEMHEIGHT);
25  	TreeView_SetItemHeight(_hSelf, itemHeight);
26  	::SetWindowLongPtr(_hSelf, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
27  	_defaultProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSelf, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(staticProc)));
28  }
29  void TreeView::destroy()
30  {
31  	HTREEITEM root = TreeView_GetRoot(_hSelf);
32  	cleanSubEntries(root);
33  	::DestroyWindow(_hSelf);
34  	_hSelf = NULL;
35  }
36  LRESULT TreeView::runProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
37  {
38  	if (Message == TVM_EXPAND)
39  	{
40  		if (wParam & (TVE_COLLAPSE | TVE_EXPAND))
41  		{
42  			TVITEM tvItem = {};
43  			tvItem.hItem = reinterpret_cast<HTREEITEM>(lParam);
44  			tvItem.mask = TVIF_STATE | TVIF_HANDLE | TVIF_PARAM;
45  			tvItem.stateMask = TVIS_EXPANDEDONCE;
46  			TreeView_GetItem(_hSelf, &tvItem);
47  			if (tvItem.state & TVIS_EXPANDEDONCE)
48  			{
49  				NMTREEVIEW nmtv = {};
50  				nmtv.hdr.code = TVN_ITEMEXPANDED;
51  				nmtv.hdr.hwndFrom = _hSelf;
52  				nmtv.hdr.idFrom = 0;
53  				nmtv.action = wParam & TVE_COLLAPSE ? TVE_COLLAPSE : TVE_EXPAND;
54  				nmtv.itemNew.hItem = tvItem.hItem;
55  				::SendMessage(_hParent, WM_NOTIFY, nmtv.hdr.idFrom, reinterpret_cast<LPARAM>(&nmtv));
56  			}
57  		}
58  	}
59  	return ::CallWindowProc(_defaultProc, hwnd, Message, wParam, lParam);
60  }
61  void TreeView::makeLabelEditable(bool toBeEnabled)
62  {
63  	DWORD dwNewStyle = (DWORD)GetWindowLongPtr(_hSelf, GWL_STYLE);
64  	if (toBeEnabled)
65  		dwNewStyle |= TVS_EDITLABELS;
66  	else
67  		dwNewStyle &= ~TVS_EDITLABELS;
68  	::SetWindowLongPtr(_hSelf, GWL_STYLE, dwNewStyle);
69  }
70  bool TreeView::setItemParam(HTREEITEM Item2Set, LPARAM param)
71  {
72  	if (!Item2Set)
73  		return false;
74  	TVITEM tvItem;
75  	tvItem.hItem = Item2Set;
76  	tvItem.mask = TVIF_PARAM;
77  	tvItem.lParam = param;
78  	SendMessage(_hSelf, TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
79  	return true;
80  }
81  LPARAM TreeView::getItemParam(HTREEITEM Item2Get) const
82  {
83  	if (!Item2Get)
84  		return false;
85  	TVITEM tvItem;
86  	tvItem.hItem = Item2Get;
87  	tvItem.mask = TVIF_PARAM;
88  	tvItem.lParam = 0;
89  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
90  	return tvItem.lParam;
91  }
92  generic_string TreeView::getItemDisplayName(HTREEITEM Item2Set) const
93  {
94  	if (!Item2Set)
95  		return TEXT("");
96  	TCHAR textBuffer[MAX_PATH] = { '\0' };
97  	TVITEM tvItem;
98  	tvItem.hItem = Item2Set;
99  	tvItem.mask = TVIF_TEXT;
100  	tvItem.pszText = textBuffer;
101  	tvItem.cchTextMax = MAX_PATH;
102  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
103  	return tvItem.pszText;
104  }
105  bool TreeView::renameItem(HTREEITEM Item2Set, const TCHAR *newName)
106  {
107  	if (!Item2Set || !newName)
108  		return false;
109  	TVITEM tvItem;
110  	tvItem.hItem = Item2Set;
111  	tvItem.mask = TVIF_TEXT;
112  	tvItem.pszText = (LPWSTR)newName;
113  	tvItem.cchTextMax = MAX_PATH;
114  	SendMessage(_hSelf, TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
115  	return true;
116  }
117  HTREEITEM TreeView::addItem(const TCHAR *itemName, HTREEITEM hParentItem, int iImage, LPARAM lParam)
118  {
119  	TVITEM tvi;
120  	tvi.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
121  	tvi.pszText = (LPTSTR)itemName;
122  	tvi.cchTextMax = MAX_PATH;
123  	tvi.iImage = iImage;
124  	tvi.iSelectedImage = iImage;
125  	tvi.lParam = lParam;
126  	TVINSERTSTRUCT tvInsertStruct;
127  	tvInsertStruct.item = tvi;
128  	tvInsertStruct.hInsertAfter = TVI_LAST;
129  	tvInsertStruct.hParent = hParentItem;
130  	return reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&tvInsertStruct)));
131  }
132  void TreeView::removeItem(HTREEITEM hTreeItem)
133  {
134  	cleanSubEntries(hTreeItem);
135  	TVITEM tvItem;
136  	tvItem.hItem = hTreeItem;
137  	tvItem.mask = TVIF_PARAM;
138  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
139  	TreeView_DeleteItem(_hSelf, hTreeItem);
140  }
141  void TreeView::removeAllItems()
142  {
143  	for (HTREEITEM tvProj = getRoot();
144  		tvProj != NULL;
145  		tvProj = getNextSibling(tvProj))
146  	{
147  		cleanSubEntries(tvProj);
148  	}
149  	TreeView_DeleteAllItems(_hSelf);
150  }
151  void TreeView::dupTree(HTREEITEM hTree2Dup, HTREEITEM hParentItem)
152  {
153  	for (HTREEITEM hItem = getChildFrom(hTree2Dup); hItem != NULL; hItem = getNextSibling(hItem))
154  	{
155  		TCHAR textBuffer[MAX_PATH];
156  		TVITEM tvItem;
157  		tvItem.hItem = hItem;
158  		tvItem.pszText = textBuffer;
159  		tvItem.cchTextMax = MAX_PATH;
160  		tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
161  		SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
162  		TVINSERTSTRUCT tvInsertStruct;
163  		tvInsertStruct.item = tvItem;
164  		tvInsertStruct.hInsertAfter = TVI_LAST;
165  		tvInsertStruct.hParent = hParentItem;
166  		HTREEITEM hTreeParent = reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&tvInsertStruct)));
167  		dupTree(hItem, hTreeParent);
168  	}
169  }
170  HTREEITEM TreeView::searchSubItemByName(const TCHAR *itemName, HTREEITEM hParentItem)
171  {
172  	HTREEITEM hItem = NULL;
173  	if (hParentItem != NULL)
174  		hItem = getChildFrom(hParentItem);
175  	else
176  		hItem = getRoot();
177  	for ( ; hItem != NULL; hItem = getNextSibling(hItem))
178  	{
179  		TCHAR textBuffer[MAX_PATH] = { '\0' };
180  		TVITEM tvItem;
181  		tvItem.hItem = hItem;
182  		tvItem.pszText = textBuffer;
183  		tvItem.cchTextMax = MAX_PATH;
184  		tvItem.mask = TVIF_TEXT;
185  		SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
186  		if (lstrcmp(itemName, tvItem.pszText) == 0)
187  		{
188  			return hItem;
189  		}
190  	}
191  	return NULL;
192  }
193  BOOL TreeView::setImageList(int w, int h, int nbImage, int image_id, ...)
194  {
195  	HBITMAP hbmp;
196  	COLORREF maskColour = RGB(192, 192, 192);
197  	int bmDpiDynW = NppParameters::getInstance()._dpiManager.scaleX(w);
198  	int bmDpiDynH = NppParameters::getInstance()._dpiManager.scaleY(h);
199  	if ((_hImaLst = ImageList_Create(bmDpiDynW, bmDpiDynH, ILC_COLOR32 | ILC_MASK, nbImage, 0)) == NULL)
200  		return FALSE;
201  	va_list argLst;
202  	va_start(argLst, image_id);
203  	int imageID = image_id;
204  	for (int i = 0; i < nbImage; i++)
205  	{
206  		if (i > 0)
207  			imageID = va_arg(argLst, int);
208  		hbmp = (HBITMAP)::LoadImage(_hInst, MAKEINTRESOURCE(imageID), IMAGE_BITMAP, bmDpiDynW, bmDpiDynH, 0);
209  		if (hbmp == NULL)
210  			return FALSE;
211  		ImageList_AddMasked(_hImaLst, hbmp, maskColour);
212  		DeleteObject(hbmp);
213  	}
214  	va_end(argLst);
215  	TreeView_SetImageList(_hSelf, _hImaLst, TVSIL_NORMAL);
216  	return TRUE;
217  }
218  void TreeView::cleanSubEntries(HTREEITEM hTreeItem)
219  {
220  	for (HTREEITEM hItem = getChildFrom(hTreeItem); hItem != NULL; hItem = getNextSibling(hItem))
221  	{
222  		TVITEM tvItem;
223  		tvItem.hItem = hItem;
224  		tvItem.mask = TVIF_PARAM;
225  		SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
226  		cleanSubEntries(hItem);
227  	}
228  }
229  void TreeView::foldExpandRecursively(HTREEITEM hParentItem, bool isFold) const
230  {
231  	if (!hParentItem)
232  		return;
233  	HTREEITEM hItem = getChildFrom(hParentItem);
234  	for (; hItem != NULL; hItem = getNextSibling(hItem))
235  	{
236  		foldExpandRecursively(hItem, isFold);
237  		if (isFold)
238  		{
239  			fold(hItem);
240  		}
241  		else
242  		{
243  			expand(hItem);
244  		}
245  	}
246  }
247  void TreeView::foldExpandAll(bool isFold) const
248  {
249  	for (HTREEITEM tvProj = getRoot();
250  		tvProj != NULL;
251  		tvProj = getNextSibling(tvProj))
252  	{
253  		foldExpandRecursively(tvProj, isFold);
254  		if (isFold)
255  		{
256  			fold(tvProj);
257  		}
258  		else
259  		{
260  			expand(tvProj);
261  		}
262  	}
263  }
264  void TreeView::setItemImage(HTREEITEM hTreeItem, int iImage, int iSelectedImage)
265  {
266  	TVITEM tvItem;
267  	tvItem.hItem = hTreeItem;
268  	tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
269  	tvItem.iImage = iImage;
270  	tvItem.iSelectedImage = iSelectedImage;
271  	TreeView_SetItem(_hSelf, &tvItem);
272  }
273  void TreeView::beginDrag(NMTREEVIEW* tv)
274  {
275  	if (!canDragOut(tv->itemNew.hItem))
276  		return;
277  	_draggedItem = tv->itemNew.hItem;
278  	_draggedImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(_hSelf, TVM_CREATEDRAGIMAGE, 0, reinterpret_cast<LPARAM>(_draggedItem)));
279  	::ImageList_BeginDrag(_draggedImageList, 0, 0, 0);
280  	::ImageList_DragEnter(_hSelf, tv->ptDrag.x, tv->ptDrag.y);
281  	::SetCapture(::GetParent(_hSelf));
282  	::ShowCursor(false);          
283  	_isItemDragged = true;
284  }
285  void TreeView::dragItem(HWND parentHandle, int x, int y)
286  {
287  	POINT point;
288  	point.x = (SHORT)x;
289  	point.y = (SHORT)y;
290  	::ClientToScreen(parentHandle, &point);
291  	::ScreenToClient(_hSelf, &point);
292  	::ImageList_DragMove(point.x, point.y);
293  	::ImageList_DragShowNolock(false);
294  	TVHITTESTINFO hitTestInfo;
295  	hitTestInfo.pt.x = point.x;
296  	hitTestInfo.pt.y = point.y;
297  	HTREEITEM targetItem = reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_HITTEST, 0, reinterpret_cast<LPARAM>(&hitTestInfo)));
298  	if (targetItem)
299  	{
300  		::SendMessage(_hSelf, TVM_SELECTITEM, TVGN_DROPHILITE, reinterpret_cast<LPARAM>(targetItem));
301  	}
302  	::ImageList_DragShowNolock(true);
303  }
304  bool TreeView::dropItem()
305  {
306  	bool isFilesMoved = false;
307  	HTREEITEM targetItem = reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0));
308  	if (canBeDropped(_draggedItem, targetItem))
309  	{
310  		moveTreeViewItem(_draggedItem, targetItem);
311  		isFilesMoved = true;
312  	}
313  	::ImageList_EndDrag();
314  	::ImageList_Destroy(_draggedImageList);
315  	::ReleaseCapture();
316  	::ShowCursor(true);
317  	SendMessage(_hSelf, TVM_SELECTITEM, TVGN_CARET, reinterpret_cast<LPARAM>(targetItem));
318  	SendMessage(_hSelf,TVM_SELECTITEM,TVGN_DROPHILITE,0);
319  	_draggedItem = 0;
320  	_draggedImageList = 0;
321  	_isItemDragged = false;
322  	return isFilesMoved;
323  }
324  bool TreeView::canBeDropped(HTREEITEM draggedItem, HTREEITEM targetItem)
325  {
326  	if (targetItem == NULL)
327  		return false;
328  	if (draggedItem == targetItem)
329  		return false;
330  	if (targetItem == TreeView_GetRoot(_hSelf))
331  		return false;
332  	if (isDescendant(targetItem, draggedItem))
333  		return false;
334  	if (isParent(targetItem, draggedItem))
335  		return false;
336  	if (!canDropIn(targetItem))
337  		return false;
338  	return true;
339  }
340  bool TreeView::isDescendant(HTREEITEM targetItem, HTREEITEM draggedItem)
341  {
342  	if (targetItem == NULL)
343  		return false;
344  	if (TreeView_GetRoot(_hSelf) == targetItem)
345  		return false;
346  	HTREEITEM parent = getParent(targetItem);
347  	if (parent == draggedItem)
348  		return true;
349  	return isDescendant(parent, draggedItem);
350  }
351  bool TreeView::isParent(HTREEITEM targetItem, HTREEITEM draggedItem)
352  {
353  	HTREEITEM parent = getParent(draggedItem);
354  	if (parent == targetItem)
355  		return true;
356  	return false;
357  }
358  void TreeView::moveTreeViewItem(HTREEITEM draggedItem, HTREEITEM targetItem)
359  {
360  	TCHAR textBuffer[MAX_PATH];
361  	TVITEM tvDraggingItem;
362  	tvDraggingItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
363  	tvDraggingItem.pszText = textBuffer;
364  	tvDraggingItem.cchTextMax = MAX_PATH;
365  	tvDraggingItem.hItem = draggedItem;
366  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvDraggingItem));
367  	TVINSERTSTRUCT tvInsertStruct;
368  	tvInsertStruct.item = tvDraggingItem;
369  	tvInsertStruct.hInsertAfter = (HTREEITEM)TVI_LAST;
370  	tvInsertStruct.hParent = targetItem;
371  	HTREEITEM hTreeParent = reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&tvInsertStruct)));
372  	dupTree(draggedItem, hTreeParent);
373  	removeItem(draggedItem);
374  }
375  bool TreeView::moveDown(HTREEITEM itemToMove)
376  {
377  	HTREEITEM hItemToUp = getNextSibling(itemToMove);
378  	if (!hItemToUp)
379  		return false;
380  	return swapTreeViewItem(itemToMove, hItemToUp);
381  }
382  bool TreeView::moveUp(HTREEITEM itemToMove)
383  {
384  	HTREEITEM hItemToDown = getPrevSibling(itemToMove);
385  	if (!hItemToDown)
386  		return false;
387  	return swapTreeViewItem(hItemToDown, itemToMove);
388  }
389  bool TreeView::swapTreeViewItem(HTREEITEM itemGoDown, HTREEITEM itemGoUp)
390  {
391  	HTREEITEM selectedItem = getSelection();
392  	int itemSelected = selectedItem == itemGoDown?1:(selectedItem == itemGoUp?2:0);
393  	HTREEITEM itemTop = getPrevSibling(itemGoDown);
394  	itemTop = itemTop?itemTop:(HTREEITEM)TVI_FIRST;
395  	HTREEITEM parentGoDown = getParent(itemGoDown);
396  	HTREEITEM parentGoUp = getParent(itemGoUp);
397  	if (parentGoUp != parentGoDown)
398  		return false;
399  	TCHAR textBufferUp[MAX_PATH];
400  	TCHAR textBufferDown[MAX_PATH];
401  	TVITEM tvUpItem;
402  	TVITEM tvDownItem;
403  	tvUpItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
404  	tvDownItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
405  	tvUpItem.pszText = textBufferUp;
406  	tvDownItem.pszText = textBufferDown;
407  	tvUpItem.cchTextMax = MAX_PATH;
408  	tvDownItem.cchTextMax = MAX_PATH;
409  	tvUpItem.hItem = itemGoUp;
410  	tvDownItem.hItem = itemGoDown;
411  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvUpItem));
412  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvDownItem));
413  	TVINSERTSTRUCT tvInsertUp;
414  	tvInsertUp.item = tvUpItem;
415  	tvInsertUp.hInsertAfter = itemTop;
416  	tvInsertUp.hParent = parentGoUp;
417  	HTREEITEM hTreeParent1stInserted = reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&tvInsertUp)));
418  	dupTree(itemGoUp, hTreeParent1stInserted);
419  	TVINSERTSTRUCT tvInsertDown;
420  	tvInsertDown.item = tvDownItem;
421  	tvInsertDown.hInsertAfter = hTreeParent1stInserted;
422  	tvInsertDown.hParent = parentGoDown;
423  	HTREEITEM hTreeParent2ndInserted = reinterpret_cast<HTREEITEM>(::SendMessage(_hSelf, TVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&tvInsertDown)));
424  	dupTree(itemGoDown, hTreeParent2ndInserted);
425  	removeItem(itemGoUp);
426  	removeItem(itemGoDown);
427  	switch (itemSelected)
428  	{
429  		case 1:
430  			selectItem(hTreeParent2ndInserted);
431  			break;
432  		case 2:
433  			selectItem(hTreeParent1stInserted);
434  			break;
435  		default:
436  			break;
437  	}
438  	return true;
439  }
440  bool TreeView::canDropIn(HTREEITEM targetItem)
441  {
442  	TVITEM tvItem;
443  	tvItem.mask = TVIF_IMAGE;
444  	tvItem.hItem = targetItem;
445  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
446  	for (size_t i = 0, len = _canNotDropInList.size(); i < len; ++i)
447  	{
448  		if (tvItem.iImage == _canNotDropInList[i])
449  			return false;
450  	}
451  	return true;
452  }
453  bool TreeView::canDragOut(HTREEITEM targetItem)
454  {
455  	TVITEM tvItem;
456  	tvItem.mask = TVIF_IMAGE;
457  	tvItem.hItem = targetItem;
458  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
459  	for (size_t i = 0, len = _canNotDragOutList.size(); i < len; ++i)
460  	{
461  		if (tvItem.iImage == _canNotDragOutList[i])
462  			return false;
463  	}
464  	return true;
465  }
466  bool TreeView::searchLeafAndBuildTree(const TreeView & tree2Build, const generic_string & text2Search, int index2Search)
467  {
468  	return searchLeafRecusivelyAndBuildTree(tree2Build.getRoot(), text2Search, index2Search, getRoot());
469  }
470  bool TreeView::searchLeafRecusivelyAndBuildTree(HTREEITEM tree2Build, const generic_string & text2Search, int index2Search, HTREEITEM tree2Search)
471  {
<span onclick='openModal()' class='match'>472  	if (!tree2Search)
473  		return false;
474  	TCHAR textBuffer[MAX_PATH] = { '\0' };
475  	TVITEM tvItem;
476  	tvItem.hItem = tree2Search;
</span>477  	tvItem.pszText = textBuffer;
478  	tvItem.cchTextMax = MAX_PATH;
479  	tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
480  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
481  	if (tvItem.iImage == index2Search)
482  	{
483  		generic_string itemNameUpperCase = stringToUpper(tvItem.pszText);
484  		generic_string text2SearchUpperCase = stringToUpper(text2Search);
485  		size_t res = itemNameUpperCase.find(text2SearchUpperCase);
486  		if (res != generic_string::npos)
487  		{
488  			TVINSERTSTRUCT tvInsertStruct;
489  			tvInsertStruct.item = tvItem;
490  			tvInsertStruct.hInsertAfter = TVI_LAST;
491  			tvInsertStruct.hParent = tree2Build;
492  			::SendMessage(_hSelf, TVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&tvInsertStruct));
493  		}
494  	}
495  	size_t i = 0;
496  	bool isOk = true;
497  	for (HTREEITEM hItem = getChildFrom(tree2Search); hItem != NULL; hItem = getNextSibling(hItem))
498  	{
499  		isOk = searchLeafRecusivelyAndBuildTree(tree2Build, text2Search, index2Search, hItem);
500  		if (!isOk)
501  			break;
502  		++i;
503  	}
504  	return isOk;
505  }
506  bool TreeView::retrieveFoldingStateTo(TreeStateNode & treeState2Construct, HTREEITEM treeviewNode)
507  {
508  	if (!treeviewNode)
509  		return false;
510  	TCHAR textBuffer[MAX_PATH] = { '\0' };
511  	TVITEM tvItem;
512  	tvItem.hItem = treeviewNode;
513  	tvItem.pszText = textBuffer;
514  	tvItem.cchTextMax = MAX_PATH;
515  	tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
516  	SendMessage(_hSelf, TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
517  	treeState2Construct._label = textBuffer;
518  	treeState2Construct._isExpanded = (tvItem.state & TVIS_EXPANDED) != 0;
519  	treeState2Construct._isSelected = (tvItem.state & TVIS_SELECTED) != 0;
520  	if (tvItem.lParam)
521  	{
522  		treeState2Construct._extraData = *((generic_string *)tvItem.lParam);
523  	}
524  	int i = 0;
525  	for (HTREEITEM hItem = getChildFrom(treeviewNode); hItem != NULL; hItem = getNextSibling(hItem))
526  	{
527  		treeState2Construct._children.push_back(TreeStateNode());
528  		retrieveFoldingStateTo(treeState2Construct._children.at(i), hItem);
529  		++i;
530  	}
531  	return true;
532  }
533  bool TreeView::restoreFoldingStateFrom(const TreeStateNode & treeState2Compare, HTREEITEM treeviewNode)
534  {
535  	if (!treeviewNode)
536  		return false;
537  	if (treeState2Compare._isExpanded) 
538  		expand(treeviewNode);
539  	else
540  		fold(treeviewNode);
541  	if (treeState2Compare._isSelected) 
542  		selectItem(treeviewNode);
543  	size_t i = 0;
544  	bool isOk = true;
545  	for (HTREEITEM hItem = getChildFrom(treeviewNode); hItem != NULL; hItem = getNextSibling(hItem))
546  	{
547  		if (i >= treeState2Compare._children.size())
548  			return false;
549  		isOk = restoreFoldingStateFrom(treeState2Compare._children.at(i), hItem);
550  		if (!isOk)
551  			break;
552  		++i;
553  	}
554  	return isOk;
555  }
556  void TreeView::sort(HTREEITEM hTreeItem, bool isRecusive)
557  {
558  	::SendMessage(_hSelf, TVM_SORTCHILDREN, TRUE, reinterpret_cast<LPARAM>(hTreeItem));
559  	if (!isRecusive)
560  		return;
561  	for (HTREEITEM hItem = getChildFrom(hTreeItem); hItem != NULL; hItem = getNextSibling(hItem))
562  		sort(hItem, isRecusive);
563  }
564  void TreeView::customSorting(HTREEITEM hTreeItem, PFNTVCOMPARE sortingCallbackFunc, LPARAM lParam, bool isRecusive)
565  {
566  	TVSORTCB treeViewSortCB;
567  	treeViewSortCB.hParent = hTreeItem;
568  	treeViewSortCB.lpfnCompare = sortingCallbackFunc;
569  	treeViewSortCB.lParam = lParam;
570  	::SendMessage(_hSelf, TVM_SORTCHILDRENCB, 0, reinterpret_cast<LPARAM>(&treeViewSortCB));
571  	if (!isRecusive)
572  		return;
573  	for (HTREEITEM hItem = getChildFrom(hTreeItem); hItem != NULL; hItem = getNextSibling(hItem))
574  		customSorting(hItem, sortingCallbackFunc, lParam, isRecusive);
575  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingCont.cpp</h3>
            <pre><code>1  #include "dockingResource.h"
2  #include "DockingCont.h"
3  #include "SplitterContainer.h"
4  #include "ToolTip.h"
5  #include "Parameters.h"
6  #include "localization.h"
7  using namespace std;
8  #ifndef WH_MOUSE_LL
9  #define WH_MOUSE_LL 14
10  #endif
11  static HWND		hWndServer		= NULL;
12  static HHOOK	hookMouse		= NULL;
13  static LRESULT CALLBACK hookProcMouse(int nCode, WPARAM wParam, LPARAM lParam)
14  {
15  	if (nCode >= 0)
16  	{
17  		switch (wParam)
18  		{
19  		case WM_MOUSEMOVE:
20  		case WM_NCMOUSEMOVE:
21  			::PostMessage(hWndServer, UINT(wParam), 0, 0);
22  			break;
23  		case WM_LBUTTONUP:
24  		case WM_NCLBUTTONUP:
25  			::PostMessage(hWndServer, UINT(wParam), 0, 0);
26  			break;
27  		default:
28  			break;
29  		}
30  	}
31  	return ::CallNextHookEx(hookMouse, nCode, wParam, lParam);
32  }
33  DockingCont::DockingCont()
34  {
35  	_isMouseOver		= FALSE;
36  	_isMouseClose		= FALSE;
37  	_isMouseDown		= FALSE;
38  	_isFloating			= false;
39  	_isTopCaption		= CAPTION_TOP;
40  	_dragFromTab		= FALSE;
41  	_hContTab			= NULL;
42  	_hDefaultTabProc	= NULL;
43  	_beginDrag			= FALSE;
44  	_prevItem			= 0;
45  	_hFont				= NULL;
46  	_bTabTTHover		= FALSE;
47  	_bCaptionTT			= FALSE;
48  	_bCapTTHover		= FALSE;
49  	_hoverMPos			= posClose;
50  	_bDrawOgLine		= TRUE;
51  	_vTbData.clear();
52  	_captionHeightDynamic = NppParameters::getInstance()._dpiManager.scaleY(_captionHeightDynamic);
53  	_captionGapDynamic = NppParameters::getInstance()._dpiManager.scaleY(_captionGapDynamic);
54  	_closeButtonPosLeftDynamic = NppParameters::getInstance()._dpiManager.scaleX(_closeButtonPosLeftDynamic);
55  	_closeButtonPosTopDynamic = NppParameters::getInstance()._dpiManager.scaleY(_closeButtonPosTopDynamic);
56  	_closeButtonWidth = NppParameters::getInstance()._dpiManager.scaleX(12); 
57  	_closeButtonHeight = NppParameters::getInstance()._dpiManager.scaleY(12);
58  }
59  DockingCont::~DockingCont()
60  {
61  	if (_hFont != nullptr)
62  	{
63  		::DeleteObject(_hFont);
64  		_hFont = nullptr;
65  	}
66  	if (_hFontCaption != nullptr)
67  	{
68  		::DeleteObject(_hFontCaption);
69  		_hFontCaption = nullptr;
70  	}
71  }
72  void DockingCont::doDialog(bool willBeShown, bool isFloating)
73  {
74  	if (!isCreated())
75  	{
76  		NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
77  		create(IDD_CONTAINER_DLG, pNativeSpeaker->isRTL());
78  		_isFloating  = isFloating;
79  		if (_isFloating)
80  		{
81  			::SetWindowLongPtr(_hSelf, GWL_STYLE, POPUP_STYLES);
82  			::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, pNativeSpeaker->isRTL()? POPUP_EXSTYLES | WS_EX_LAYOUTRTL : POPUP_EXSTYLES);
83  			::ShowWindow(_hCaption, SW_HIDE);
84  		}
85  		else
86  		{
87  			::SetWindowLongPtr(_hSelf, GWL_STYLE, CHILD_STYLES);
88  			::SetWindowLongPtr(_hSelf, GWL_EXSTYLE, CHILD_EXSTYLES);
89  			::ShowWindow(_hCaption, SW_SHOW);
90  		}
91  		LOGFONT lfTab{ NppParameters::getDefaultGUIFont() };
92  		_hFont = ::CreateFontIndirect(&lfTab);
93  		LOGFONT lfCaption{ NppParameters::getDefaultGUIFont(NppParameters::DefaultFontType::smcaption) };
94  		_hFontCaption = ::CreateFontIndirect(&lfCaption);
95  	}
96  	display(willBeShown);
97  }
98  tTbData* DockingCont::createToolbar(tTbData data)
99  {
100  	tTbData *pTbData = new tTbData;
101  	*pTbData = data;
102  	::SetWindowLongPtr(pTbData->hClient, GWL_STYLE, CHILD_STYLES);
103  	::SetWindowLongPtr(pTbData->hClient, GWL_EXSTYLE, CHILD_EXSTYLES);
104  	if ((_isFloating) && (::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0) == 0))
105  	{
106  		reSizeToWH(pTbData->rcFloat);
107  	}
108  	::SetParent(pTbData->hClient, ::GetDlgItem(_hSelf, IDC_CLIENT_TAB));
109  	viewToolbar(pTbData);
110  	_vTbData.push_back(pTbData);
111  	return pTbData;
112  }
113  void DockingCont::removeToolbar(tTbData TbData)
114  {
115  	for (size_t iTb = 0 ; iTb < _vTbData.size(); ++iTb)
116  	{
117  		if (_vTbData[iTb]->hClient == TbData.hClient)
118  		{
119  			removeTab(_vTbData[iTb]);
120  			delete _vTbData[iTb];
121  			vector<tTbData*>::iterator itr = _vTbData.begin() + iTb;
122  			_vTbData.erase(itr);
123  		}
124  	}
125  }
126  tTbData* DockingCont::findToolbarByWnd(HWND hClient)
127  {
128  	tTbData*	pTbData		= NULL;
129  	for (size_t iTb = 0, len = _vTbData.size(); iTb < len; ++iTb)
130  	{
131  		if (hClient == _vTbData[iTb]->hClient)
132  		{
133  			pTbData = _vTbData[iTb];
134  		}
135  	}
136  	return pTbData;
137  }
138  tTbData* DockingCont::findToolbarByName(TCHAR* pszName)
139  {
140  	tTbData*	pTbData		= NULL;
141  	for (size_t iTb = 0, len = _vTbData.size(); iTb < len; ++iTb)
142  	{
143  		if (lstrcmp(pszName, _vTbData[iTb]->pszName) == 0)
144  		{
145  			pTbData = _vTbData[iTb];
146  		}
147  	}
148  	return pTbData;
149  }
150  void DockingCont::setActiveTb(tTbData* pTbData)
151  {
152  	int iItem = searchPosInTab(pTbData);
153  	setActiveTb(iItem);
154  }
155  void DockingCont::setActiveTb(int iItem)
156  {
157  	if (iItem < ::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0))
158  	{
159  		selectTab(iItem);
160  	}
161  }
162  int DockingCont::getActiveTb()
163  {
164  	return static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETCURSEL, 0, 0));
165  }
166  tTbData* DockingCont::getDataOfActiveTb()
167  {
168  	tTbData*	pTbData	= NULL;
169  	int			iItem	= getActiveTb();
170  	if (iItem != -1)
171  	{
172  		TCITEM	tcItem	= {};
173  		tcItem.mask		= TCIF_PARAM;
174  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
175  		pTbData = (tTbData*)tcItem.lParam;
176  	}
177  	return pTbData;
178  }
179  vector<tTbData*> DockingCont::getDataOfVisTb()
180  {
181  	vector<tTbData*> vTbData;
182  	TCITEM tcItem = {};
183  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
184  	tcItem.mask	= TCIF_PARAM;
185  	for (int iItem = 0; iItem < iItemCnt; ++iItem)
186  	{
187  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
188  		vTbData.push_back((tTbData*)tcItem.lParam);
189  	}
190  	return vTbData;
191  }
192  bool DockingCont::isTbVis(tTbData* data)
193  {
194  	TCITEM tcItem = {};
195  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
196  	tcItem.mask	= TCIF_PARAM;
197  	for (int iItem = 0; iItem < iItemCnt; ++iItem)
198  	{
199  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
200  		if (!tcItem.lParam)
201  			return false;
202  		if (((tTbData*)tcItem.lParam) == data)
203  			return true;
204  	}
205  	return false;
206  }
207  LRESULT DockingCont::runProcCaption(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
208  {
209  	static ToolTip	toolTip;
210  	switch (Message)
211  	{
212  		case WM_ERASEBKGND:
213  		{
214  			if (!NppDarkMode::isEnabled())
215  			{
216  				break;
217  			}
218  			RECT rc{};
219  			::GetClientRect(hwnd, &rc);
220  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
221  			return TRUE;
222  		}
223  		case WM_LBUTTONDOWN:
224  		{
225  			_isMouseDown = TRUE;
226  			if (isInRect(hwnd, LOWORD(lParam), HIWORD(lParam)) == posClose)
227  			{
228  				_isMouseClose	= TRUE;
229  				_isMouseOver	= TRUE;
230  				hWndServer		= _hCaption;
231  				hookMouse = ::SetWindowsHookEx(WH_MOUSE_LL, hookProcMouse, _hInst, 0);
232  				if (!hookMouse)
233  				{
234  					DWORD dwError = ::GetLastError();
235  					TCHAR str[128]{};
236  					::wsprintf(str, TEXT("GetLastError() returned %lu"), dwError);
237  					::MessageBox(NULL, str, TEXT("SetWindowsHookEx(MOUSE) failed on runProcCaption"), MB_OK | MB_ICONERROR);
238  				}
239  				::RedrawWindow(hwnd, nullptr, nullptr, RDW_INVALIDATE);
240  			}
241  			focusClient();
242  			return TRUE;
243  		}
244  		case WM_LBUTTONUP:
245  		{
246  			_isMouseDown = FALSE;
247  			if (_isMouseClose == TRUE)
248  			{
249  				::UnhookWindowsHookEx(hookMouse);
250  				if (_isMouseOver == TRUE)
251  				{
252  					doClose(GetKeyState(VK_SHIFT) < 0);
253  				}
254  				_isMouseClose	= FALSE;
255  				_isMouseOver	= FALSE;
256  			}
257  			focusClient();
258  			return TRUE;
259  		}
260  		case WM_LBUTTONDBLCLK:
261  		{
262  			if (isInRect(hwnd, LOWORD(lParam), HIWORD(lParam)) == posCaption)
263  				::SendMessage(_hParent, DMM_FLOATALL, 0, reinterpret_cast<LPARAM>(this));
264  			focusClient();
265  			return TRUE;
266  		}
267  		case WM_MOUSEMOVE:
268  		{
269  			POINT	pt			= {};
270  			::GetCursorPos(&pt);
271  			::ScreenToClient(_hCaption, &pt);
272  			if (_isMouseDown == TRUE)
273  			{
274  				if (_isMouseClose == FALSE)
275  				{
276  					if ((wParam == MK_LBUTTON) && (isInRect(hwnd, pt.x, pt.y) == posCaption))
277  					{
278  						_dragFromTab = FALSE;
279  						NotifyParent(DMM_MOVE);
280  						_isMouseDown = FALSE;
281  					}
282  					else
283  					{
284  						_isMouseDown = FALSE;
285  					}
286  				}
287  				else
288  				{
289  					BOOL isMouseOver = _isMouseOver;
290  					_isMouseOver = (isInRect(hwnd, pt.x, pt.y) == posClose ? TRUE : FALSE);
291  					if (_isMouseOver != isMouseOver)
292  					{
293  						::SetFocus(NULL);
294  						::RedrawWindow(hwnd, nullptr, nullptr, RDW_INVALIDATE);
295  					}
296  				}
297  			}
298  			else if (_bCapTTHover == FALSE)
299  			{
300  				_hoverMPos = isInRect(hwnd, LOWORD(lParam), HIWORD(lParam));
301  				if ((_bCaptionTT == TRUE) || (_hoverMPos == posClose))
302  				{
303  					TRACKMOUSEEVENT tme{};
304  					tme.cbSize = sizeof(tme);
305  					tme.hwndTrack = hwnd;
306  					tme.dwFlags = TME_LEAVE | TME_HOVER;
307  					tme.dwHoverTime = 1000;
308  					_bCapTTHover = _TrackMouseEvent(&tme);
309  				}
310  			}
311  			else if ((_bCapTTHover == TRUE) &&
312  				(_hoverMPos != isInRect(hwnd, LOWORD(lParam), HIWORD(lParam))))
313  			{
314  				toolTip.destroy();
315  				_bCapTTHover = FALSE;
316  			}
317  			return TRUE;
318  		}
319  		case WM_MOUSEHOVER:
320  		{
321  			RECT	rc	= {};
322  			POINT	pt	= {};
323  			::GetCursorPos(&pt);
324  			toolTip.init(_hInst, hwnd);
325  			if (_hoverMPos == posCaption)
326  			{
327  				toolTip.Show(rc, _pszCaption.c_str(), pt.x, pt.y + 20);
328  			}
329  			else
330  			{
331  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
332  				generic_string tip = pNativeSpeaker->getLocalizedStrFromID("close-panel-tip", TEXT("Close"));
333  				toolTip.Show(rc, tip.c_str(), pt.x, pt.y + 20);
334  			}
335  			return TRUE;
336  		}
337  		case WM_MOUSELEAVE:
338  		{
339  			toolTip.destroy();
340  			_bCapTTHover = FALSE;
341  			return TRUE;
342  		}
343  		case WM_SIZE:
344  		{
345  			::GetWindowRect(hwnd, &_rcCaption);
346  			ScreenRectToClientRect(hwnd, &_rcCaption);
347  			break;
348  		}
349  		case WM_SETTEXT:
350  		{
351  			::RedrawWindow(hwnd, nullptr, nullptr, RDW_INVALIDATE);
352  			return TRUE;
353  		}
354  		default:
355  			break;
356  	}
357  	return ::CallWindowProc(_hDefaultCaptionProc, hwnd, Message, wParam, lParam);
358  }
359  void DockingCont::drawCaptionItem(DRAWITEMSTRUCT *pDrawItemStruct)
360  {
361  	HBRUSH		bgbrush		= NULL;
362  	HFONT		hOldFont	= NULL;
363  	RECT		rc			= pDrawItemStruct->rcItem;
364  	HDC			hDc			= pDrawItemStruct->hDC;
365  	HPEN		hPen		= ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW));
366  	BITMAP		bmp			= {};
367  	HBITMAP		hBmpCur		= NULL;
368  	HBITMAP		hBmpOld 	= NULL;
369  	HBITMAP		hBmpNew		= NULL;
370  	int length = static_cast<int32_t>(_pszCaption.length());
371  	int nSavedDC			= ::SaveDC(hDc);
372  	::SetBkMode(hDc, TRANSPARENT);
373  	auto holdPen = static_cast<HPEN>(::SelectObject(hDc, NppDarkMode::isEnabled() ? NppDarkMode::getEdgePen() : hPen));
374  	if (NppDarkMode::isEnabled())
375  	{
376  		bgbrush = ::CreateSolidBrush(_isActive ? NppDarkMode::getSofterBackgroundColor() : NppDarkMode::getBackgroundColor());
377  		SetTextColor(hDc, NppDarkMode::getTextColor());
378  	}
379  	else
380  	{
381  		if (_isActive == TRUE)
382  		{
383  			bgbrush = ::CreateSolidBrush(::GetSysColor(COLOR_ACTIVECAPTION));
384  			::SetTextColor(hDc, ::GetSysColor(COLOR_CAPTIONTEXT));
385  		}
386  		else
387  		{
388  			bgbrush = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
389  		}
390  	}
391  	if (_isTopCaption == TRUE)
392  	{
393  		if (_isActive == TRUE)
394  		{
395  			::FillRect(hDc, &rc, bgbrush);
396  			rc.right	-= 1;
397  			rc.bottom	-= 1;
398  		}
399  		else
400  		{
401  			rc.right	-= 1;
402  			rc.bottom	-= 1;
403  			::FillRect(hDc, &rc, bgbrush);
404  			MoveToEx(hDc, rc.left , rc.top , NULL);
405  			LineTo  (hDc, rc.right, rc.top );
406  			LineTo  (hDc, rc.right, rc.bottom );
407  			LineTo  (hDc, rc.left , rc.bottom );
408  			LineTo  (hDc, rc.left , rc.top);
409  		}
410  		rc.left		+= 2;
411  		rc.top		+= 1;
412  		rc.right	-= 16;
413  		hOldFont = static_cast<HFONT>(::SelectObject(hDc, _hFontCaption));
414  		::DrawText(hDc, _pszCaption.c_str(), length, &rc, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX);
415  		SIZE	size	= {};
416  		GetTextExtentPoint32(hDc, _pszCaption.c_str(), length, &size);
417  		_bCaptionTT = (((rc.right - rc.left) < size.cx) ? TRUE : FALSE);
418  		::SelectObject(hDc, hOldFont);
419  	}
420  	else
421  	{
422  		HFONT	hFont;
423  		if (_isActive == TRUE)
424  		{
425  			::FillRect(hDc, &rc, bgbrush);
426  			rc.right	-= 1;
427  			rc.bottom	-= 1;
428  		}
429  		else
430  		{
431  			rc.right	-= 1;
432  			rc.bottom	-= 1;
433  			::FillRect(hDc, &rc, bgbrush);
434  			MoveToEx(hDc, rc.left , rc.top , NULL);
435  			LineTo  (hDc, rc.right, rc.top );
436  			LineTo  (hDc, rc.right, rc.bottom );
437  			LineTo  (hDc, rc.left , rc.bottom );
438  			LineTo  (hDc, rc.left , rc.top);
439  		}
440  		rc.left		+= 1;
441  		rc.top += _captionHeightDynamic;
442  		rc.right	= rc.bottom - rc.top;
443  		rc.bottom	+= 14;
444  		LOGFONT lf{ NppParameters::getDefaultGUIFont(NppParameters::DefaultFontType::smcaption) };
445  		lf.lfEscapement = 900;
446  		hFont = ::CreateFontIndirect(&lf);
447  		if (hFont == nullptr)
448  		{
449  			hFont = ::CreateFont(12, 0, 90 * 10, 0,
450  				FW_NORMAL, FALSE, FALSE, FALSE,
451  				ANSI_CHARSET, OUT_DEFAULT_PRECIS,
452  				CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
453  				DEFAULT_PITCH | FF_ROMAN,
454  				TEXT("MS Shell Dlg"));
455  		}
456  		hOldFont = (HFONT)::SelectObject(hDc, hFont);
457  		::DrawText(hDc, _pszCaption.c_str(), length, &rc, DT_BOTTOM | DT_SINGLELINE | DT_END_ELLIPSIS | DT_NOPREFIX);
458  		SIZE	size	= {};
459  		GetTextExtentPoint32(hDc, _pszCaption.c_str(), length, &size);
460  		_bCaptionTT = (((rc.bottom - rc.top) < size.cy) ? TRUE : FALSE);
461  		::SelectObject(hDc, hOldFont);
462  		::DeleteObject(hFont);
463  	}
464  	::SelectObject(hDc, holdPen);
465  	::DeleteObject(hPen);
466  	::DeleteObject(bgbrush);
467  	if (NppDarkMode::isEnabled())
468  	{
469  		if (_hFont == nullptr)
470  		{
471  			LOGFONT lf{ NppParameters::getDefaultGUIFont() };
472  			_hFont = ::CreateFontIndirect(&lf);
473  		}
474  		auto hOld = static_cast<HFONT>(::SelectObject(hDc, _hFont));
475  		rc = pDrawItemStruct->rcItem;
476  		if (_isTopCaption == TRUE)
477  		{
478  			rc.left = rc.right - _closeButtonWidth - _closeButtonPosLeftDynamic;
479  		}
480  		else
481  		{
482  			rc.bottom = rc.top + _closeButtonWidth + _closeButtonPosLeftDynamic; 
483  		}
484  		if ((_isMouseOver == TRUE) && (_isMouseDown == TRUE))
485  		{
486  			::SetTextColor(hDc, RGB(0xFF, 0xFF, 0xFF));
487  		}
488  		::DrawText(hDc, L"✕", 1, &rc, DT_VCENTER | DT_CENTER | DT_SINGLELINE);
489  		::SelectObject(hDc, hOld);
490  	}
491  	else
492  	{
493  		HDC dcMem = ::CreateCompatibleDC(NULL);
494  		if ((_isMouseOver == TRUE) && (_isMouseDown == TRUE))
495  			hBmpCur = (HBITMAP)::LoadImage(_hInst, MAKEINTRESOURCE(IDB_CLOSE_DOWN), IMAGE_BITMAP, _closeButtonWidth, _closeButtonHeight, 0);
496  		else
497  			hBmpCur = (HBITMAP)::LoadImage(_hInst, MAKEINTRESOURCE(IDB_CLOSE_UP), IMAGE_BITMAP, _closeButtonWidth, _closeButtonHeight, 0);
498  		::GetObject(hBmpCur, sizeof(bmp), &bmp);
499  		hBmpOld = (HBITMAP)::SelectObject(dcMem, hBmpCur);
500  		hBmpNew = ::CreateCompatibleBitmap(dcMem, bmp.bmWidth, bmp.bmHeight);
501  		rc = pDrawItemStruct->rcItem;
502  		::SelectObject(hDc, hBmpNew);
503  		if (_isTopCaption == TRUE)
504  			::BitBlt(hDc, rc.right - bmp.bmWidth - _closeButtonPosLeftDynamic, _closeButtonPosTopDynamic, bmp.bmWidth, bmp.bmHeight, dcMem, 0, 0, SRCCOPY);
505  		else
506  			::BitBlt(hDc, _closeButtonPosLeftDynamic, _closeButtonPosLeftDynamic, bmp.bmWidth, bmp.bmHeight, dcMem, 0, 0, SRCCOPY);
507  		::SelectObject(dcMem, hBmpOld);
508  		::DeleteObject(hBmpCur);
509  		::DeleteObject(hBmpNew);
510  		::DeleteDC(dcMem);
511  	}
512  	::RestoreDC(hDc, nSavedDC);
513  }
514  eMousePos DockingCont::isInRect(HWND hwnd, int x, int y)
515  {
516  	RECT		rc;
517  	eMousePos	ret	= posOutside;
518  	::GetWindowRect(hwnd, &rc);
519  	::MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
520  	if (_isTopCaption == TRUE)
521  	{
522  		if ((x > rc.left) && (x < rc.right - _captionHeightDynamic) && (y > rc.top) && (y < rc.bottom))
523  		{
524  			ret = posCaption;
525  		}
526  		else if ((x > rc.right - (_closeButtonWidth + _closeButtonPosLeftDynamic)) && (x < (rc.right - _closeButtonPosLeftDynamic)) &&
527  			(y >(rc.top + _closeButtonPosTopDynamic)) && (y < (rc.bottom - _closeButtonPosTopDynamic)))
528  		{
529  			ret = posClose;
530  		}
531  	}
532  	else
533  	{
534  		if ((x > rc.left) && (x < rc.right) && (y > rc.top + _captionHeightDynamic) && (y < rc.bottom))
535  		{
536  			ret = posCaption;
537  		}
538  		else if ((x > rc.left + _closeButtonPosLeftDynamic) && (x < rc.right - _closeButtonPosLeftDynamic) &&
539  			(y >(rc.top + _closeButtonPosTopDynamic)) && (y < (rc.top + (_closeButtonHeight + _closeButtonPosLeftDynamic))))
540  		{
541  			ret = posClose;
542  		}
543  	}
544  	return ret;
545  }
546  LRESULT DockingCont::runProcTab(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
547  {
548  	static	ToolTip	toolTip;
549  	switch (Message)
550  	{
551  		case WM_ERASEBKGND:
552  		{
553  			if (!NppDarkMode::isEnabled())
554  			{
555  				break;
556  			}
557  			RECT rc{};
558  			::GetClientRect(hwnd, &rc);
559  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
560  			return TRUE;
561  		}
562  		case WM_PAINT:
563  		{
564  			if (!NppDarkMode::isEnabled())
565  			{
566  				break;
567  			}
568  			LONG_PTR dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
569  			if (!(dwStyle & TCS_OWNERDRAWFIXED))
570  			{
571  				break;
572  			}
573  			PAINTSTRUCT ps{};
574  			HDC hdc = ::BeginPaint(hwnd, &ps);
575  			::FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
576  			UINT id = ::GetDlgCtrlID(hwnd);
577  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
578  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
579  			if (1 != GetClipRgn(hdc, holdClip))
580  			{
581  				DeleteObject(holdClip);
582  				holdClip = nullptr;
583  			}
584  			int nTabs = TabCtrl_GetItemCount(hwnd);
585  			int nFocusTab = TabCtrl_GetCurFocus(hwnd);
586  			int nSelTab = TabCtrl_GetCurSel(hwnd);
587  			for (int i = 0; i < nTabs; ++i)
588  			{
589  				DRAWITEMSTRUCT dis{};
590  				dis.CtlType = ODT_TAB;
591  				dis.CtlID = id;
592  				dis.itemID = static_cast<UINT>(i);
593  				dis.itemAction = ODA_DRAWENTIRE;
594  				dis.itemState = ODS_DEFAULT;
595  				dis.hwndItem = hwnd;
596  				dis.hDC = hdc;
597  				TabCtrl_GetItemRect(hwnd, i, &dis.rcItem);
598  				if (i == nFocusTab)
599  				{
600  					dis.itemState |= ODS_FOCUS;
601  				}
602  				if (i == nSelTab)
603  				{
604  					dis.itemState |= ODS_SELECTED;
605  				}
606  				dis.itemState |= ODS_NOFOCUSRECT; 
607  				RECT rcIntersect = {};
608  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &dis.rcItem))
609  				{
610  					dis.rcItem.top += NppParameters::getInstance()._dpiManager.scaleY(1);
611  					dis.rcItem.right -= 1;
612  					dis.rcItem.bottom += 2;
613  					if (i == 0)
614  					{
615  						POINT edges[] = {
616  							{dis.rcItem.left - 1, dis.rcItem.top},
617  							{dis.rcItem.left - 1, dis.rcItem.bottom}
618  						};
619  						Polyline(hdc, edges, _countof(edges));
620  					}
621  					{
622  						POINT edges[] = {
623  							{dis.rcItem.right, dis.rcItem.top},
624  							{dis.rcItem.right, dis.rcItem.bottom}
625  						};
626  						Polyline(hdc, edges, _countof(edges));
627  					}
628  					HRGN hClip = CreateRectRgnIndirect(&dis.rcItem);
629  					SelectClipRgn(hdc, hClip);
630  					drawTabItem(&dis);
631  					DeleteObject(hClip);
632  					SelectClipRgn(hdc, holdClip);
633  				}
634  			}
635  			SelectClipRgn(hdc, holdClip);
636  			if (holdClip)
637  			{
638  				DeleteObject(holdClip);
639  				holdClip = nullptr;
640  			}
641  			SelectObject(hdc, holdPen);
642  			EndPaint(hwnd, &ps);
643  			return 0;
644  		}
645  		case WM_LBUTTONDOWN:
646  		{
647  			_beginDrag	= TRUE;
648  			return TRUE;
649  		}
650  		case WM_LBUTTONUP:
651  		{
652  			int				iItem	= 0;
653  			TCHITTESTINFO	info	= {};
654  			info.pt.x = LOWORD(lParam);
655  			info.pt.y = HIWORD(lParam);
656  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
657  			selectTab(iItem);
658  			_beginDrag = FALSE;
659  			return TRUE;
660  		}
661  		case WM_LBUTTONDBLCLK:
662  		{
663  			NotifyParent((_isFloating == true)?DMM_DOCK:DMM_FLOAT);
664  			return TRUE;
665  		}
666  		case WM_MBUTTONUP:
667  		{
668  			int				iItem	= 0;
669  			TCITEM			tcItem	= {};
670  			TCHITTESTINFO	info	= {};
671  			info.pt.x = LOWORD(lParam);
672  			info.pt.y = HIWORD(lParam);
673  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
674  			selectTab(iItem);
675  			tcItem.mask		= TCIF_PARAM;
676  			::SendMessage(hwnd, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
677  			if (!tcItem.lParam)
678  				return FALSE;
679  			if (NotifyParent(DMM_CLOSE) == 0)
680  			{
681  				hideToolbar((tTbData*)tcItem.lParam);
682  			}
683  			return TRUE;
684  		}
685  		case WM_MOUSEMOVE:
686  		{
687  			int				iItem	= 0;
688  			TCHITTESTINFO	info	= {};
689  			info.pt.x = LOWORD(lParam);
690  			info.pt.y = HIWORD(lParam);
691  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
692  			if ((_beginDrag == TRUE) && (wParam == MK_LBUTTON))
693  			{
694  				selectTab(iItem);
695  				_dragFromTab = TRUE;
696  				NotifyParent(DMM_MOVE);
697  				_beginDrag = FALSE;
698  			}
699  			else
700  			{
701  				int	iItemSel = static_cast<int32_t>(::SendMessage(hwnd, TCM_GETCURSEL, 0, 0));
702  				if ((_bTabTTHover == FALSE) && (iItem != iItemSel))
703  				{
704  					TRACKMOUSEEVENT tme{};
705  					tme.cbSize = sizeof(tme);
706  					tme.hwndTrack = hwnd;
707  					tme.dwFlags = TME_LEAVE | TME_HOVER;
708  					tme.dwHoverTime = 1000;
709  					_bTabTTHover = _TrackMouseEvent(&tme);
710  				}
711  				else
712  				{
713  					if (iItem == iItemSel)
714  					{
715  						toolTip.destroy();
716  						_bTabTTHover = FALSE;
717  					}
718  					else if (iItem != _iLastHovered)
719  					{
720  						TCITEM	tcItem	= {};
721  						RECT	rc		= {};
722  						toolTip.destroy();
723  						::ClientToScreen(hwnd, &info.pt);
724  						tcItem.mask		= TCIF_PARAM;
725  						::SendMessage(hwnd, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
726  						if (!tcItem.lParam)
727  							return FALSE;
728  						toolTip.init(_hInst, hwnd);
729  						toolTip.Show(rc, (reinterpret_cast<tTbData*>(tcItem.lParam))->pszName, info.pt.x, info.pt.y + 20);
730  					}
731  				}
732  				_iLastHovered = iItem;
733  				_beginDrag = FALSE;
734  			}
735  			return TRUE;
736  		}
737  		case WM_MOUSEHOVER:
738  		{
739  			int				iItem	= 0;
740  			TCITEM			tcItem	= {};
741  			RECT			rc		= {};
742  			TCHITTESTINFO	info	= {};
743  			info.pt.x = LOWORD(lParam);
744  			info.pt.y = HIWORD(lParam);
745  			iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
746  			::ClientToScreen(hwnd, &info.pt);
747  			tcItem.mask		= TCIF_PARAM;
748  			::SendMessage(hwnd, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
749  			if (!tcItem.lParam)
750  				return FALSE;
751  			toolTip.init(_hInst, hwnd);
752  			toolTip.Show(rc, ((tTbData*)tcItem.lParam)->pszName, info.pt.x, info.pt.y + 20);
753  			return TRUE;
754  		}
755  		case WM_MOUSELEAVE:
756  		{
757  			toolTip.destroy();
758  			_bTabTTHover = FALSE;
759  			return TRUE;
760  		}
761  		case WM_NOTIFY:
762  		{
763  			LPNMHDR	lpnmhdr = (LPNMHDR)lParam;
764  			if ((lpnmhdr->hwndFrom == _hContTab) && (lpnmhdr->code == TCN_GETOBJECT))
765  			{
766  				int				iItem	= 0;
767  				TCHITTESTINFO	info	= {};
768  				info.pt.x = LOWORD(lParam);
769  				info.pt.y = HIWORD(lParam);
770  				iItem = static_cast<int32_t>(::SendMessage(hwnd, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&info)));
771  				selectTab(iItem);
772  			}
773  			break;
774  		}
775  		case WM_PARENTNOTIFY:
776  		{
777  			switch (LOWORD(wParam))
778  			{
779  				case WM_CREATE:
780  				{
781  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
782  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
783  					{
784  						_hTabUpdown = hwndUpdown;
785  						return 0;
786  					}
787  					break;
788  				}
789  			}
790  			return 0;
791  		}
792  		default:
793  			break;
794  	}
795  	return ::CallWindowProc(_hDefaultTabProc, hwnd, Message, wParam, lParam);
796  }
797  void DockingCont::drawTabItem(DRAWITEMSTRUCT *pDrawItemStruct)
798  {
799  	TCITEM	tcItem		= {};
800  	RECT	rc			= pDrawItemStruct->rcItem;
801  	int		nTab		= pDrawItemStruct->itemID;
802  	bool	isSelected	= (nTab == getActiveTb());
803  	tcItem.mask = TCIF_PARAM;
804  	::SendMessage(_hContTab, TCM_GETITEM, nTab, reinterpret_cast<LPARAM>(&tcItem));
805  	if (!tcItem.lParam)
806  		return;
807  	const TCHAR *text = reinterpret_cast<tTbData*>(tcItem.lParam)->pszName;
808  	int		length = lstrlen(reinterpret_cast<tTbData*>(tcItem.lParam)->pszName);
809  	HDC hDc = pDrawItemStruct->hDC;
810  	int nSavedDC = ::SaveDC(hDc);
811  	rc.top += ::GetSystemMetrics(SM_CYEDGE);
812  	::SetBkMode(hDc, TRANSPARENT);
813  	if (NppDarkMode::isEnabled())
814  	{
815  		RECT selectedRect = rc;
816  		selectedRect.top -= 2;
817  		selectedRect.bottom += 2;
818  		if (isSelected)
819  		{
820  			::FillRect(hDc, &selectedRect, NppDarkMode::getSofterBackgroundBrush());
821  		}
822  		else
823  		{
824  			::FillRect(hDc, &selectedRect, NppDarkMode::getBackgroundBrush());
825  		}
826  	}
827  	if (!NppDarkMode::isEnabled() && _bDrawOgLine && isSelected)
828  	{
829  		RECT barRect = rc;
830  		barRect.top += rc.bottom - 4;
831  		HBRUSH hBrush = ::CreateSolidBrush(RGB(250, 170, 60));
832  		::FillRect(hDc, &barRect, hBrush);
833  		::DeleteObject(hBrush);
834  	}
835  	if (((tTbData*)tcItem.lParam)->uMask & DWS_ICONTAB)
836  	{
837  		HIMAGELIST	hImageList	= (HIMAGELIST)::SendMessage(_hParent, DMM_GETIMAGELIST, 0, 0);
838  		int iPosImage = static_cast<int32_t>(::SendMessage(_hParent, DMM_GETICONPOS, 0, reinterpret_cast<LPARAM>(reinterpret_cast<tTbData*>(tcItem.lParam)->hClient)));
839  		if ((hImageList != NULL) && (iPosImage >= 0))
840  		{
841  			IMAGEINFO	info		= {};
842  			RECT &		imageRect	= info.rcImage;
843  			ImageList_GetImageInfo(hImageList, iPosImage, &info);
844  			int darkPaddingX = NppDarkMode::isEnabled() ? 1 : 0;
845  			int darkPaddingY = NppDarkMode::isEnabled() ? 2 : (isSelected ? 1 : 0);
846  			int iconDpiDynamicalX = isSelected ? rc.left + 3
847  				: rc.left + (rc.right - rc.left - imageRect.right + imageRect.left) / 2 + darkPaddingX;
848  			int iconDpiDynamicalY = NppParameters::getInstance()._dpiManager.scaleY(5) + darkPaddingY;
849  			ImageList_Draw(hImageList, iPosImage, hDc, iconDpiDynamicalX, iconDpiDynamicalY, ILD_NORMAL);
850  			if (isSelected)
851  			{
852  				rc.left += imageRect.right - imageRect.left + 5;
853  			}
854  		}
855  	}
856  	if (isSelected)
857  	{
858  		COLORREF _unselectedColor = RGB(0, 0, 0);
859  		::SetTextColor(hDc, NppDarkMode::isEnabled() ? NppDarkMode::getTextColor() : _unselectedColor);
860  		rc.top -= ::GetSystemMetrics(SM_CYEDGE);
861  		::SelectObject(hDc, _hFont);
862  		::DrawText(hDc, text, length, &rc, DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);
863  	}
864  	::RestoreDC(hDc, nSavedDC);
865  }
866  intptr_t CALLBACK DockingCont::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
867  {
868  	switch (Message) 
869  	{
870  		case WM_NCACTIVATE:
871  		{
872  			if (static_cast<int>(lParam) != -1)
873  			{
874  				::SendMessage(_hParent, WM_NCACTIVATE, wParam, 0);
875  			}
876  			break;
877  		}
878  		case WM_INITDIALOG:
879  		{
880  			_hContTab = ::GetDlgItem(_hSelf, IDC_TAB_CONT);
881  			_hCaption = ::GetDlgItem(_hSelf, IDC_BTN_CAPTION);
882  			::SetWindowLongPtr(_hCaption, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
883  			_hDefaultCaptionProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hCaption, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(wndCaptionProc)));
884  			::SetWindowLongPtr(_hContTab, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
885  			_hDefaultTabProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hContTab, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(wndTabProc)));
886  			int tabDpiDynamicalMinWidth = NppParameters::getInstance()._dpiManager.scaleX(24);
887  			::SendMessage(_hContTab, TCM_SETMINTABWIDTH, 0, tabDpiDynamicalMinWidth);
888  			return TRUE;
889  		}
890  		case WM_NCCALCSIZE:
891  		case WM_SIZE:
892  		{
893  			onSize();
894  			break;
895  		}
896  		case WM_ERASEBKGND:
897  		{
898  			if (!NppDarkMode::isEnabled())
899  			{
900  				break;
901  			}
902  			RECT rc{};
903  			getClientRect(rc);
904  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
905  			return TRUE;
906  		}
907  		case WM_CTLCOLORDLG:
908  		case WM_CTLCOLORSTATIC:
909  		{
910  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
911  		}
912  		case WM_DRAWITEM :
913  		{
914  			if (reinterpret_cast<DRAWITEMSTRUCT *>(lParam)->CtlID == IDC_TAB_CONT)
915  			{
916  				if (!NppDarkMode::isEnabled())
917  				{
918  					drawTabItem(reinterpret_cast<DRAWITEMSTRUCT*>(lParam));
919  					return TRUE;
920  				}
921  				break;
922  			}
923  			else
924  			{
925  				drawCaptionItem((DRAWITEMSTRUCT *)lParam);
926  				return TRUE;
927  			}
928  			break;
929  		}
930  		case WM_NCLBUTTONDBLCLK :
931  		{
932  			RECT	rcWnd		= {};
933  			RECT	rcClient	= {};
934  			POINT	pt			= {HIWORD(lParam), LOWORD(lParam)};
935  			getWindowRect(rcWnd);
936  			getClientRect(rcClient);
937  			ClientRectToScreenRect(_hSelf, &rcClient);
938  			rcWnd.bottom = rcClient.top;
939  			if ((rcWnd.top  < pt.x) && (rcWnd.bottom > pt.x) &&
940  				(rcWnd.left < pt.y) && (rcWnd.right  > pt.y))
941  			{
942  				NotifyParent(DMM_DOCKALL);
943  				return TRUE;
944  			}
945  			break;
946  		}
947  		case WM_SYSCOMMAND :
948  		{
949  			switch (wParam & 0xfff0)
950  			{
951  				case SC_MOVE:
952  					NotifyParent(DMM_MOVE);
953  					return TRUE;
954  				default: 
955  					break;
956  			}
957  			return FALSE;
958  		}
959  		case WM_COMMAND : 
960  		{
961  			switch (LOWORD(wParam))
962  			{   
963  				case IDCANCEL:
964  					doClose(GetKeyState(VK_SHIFT) < 0);
965  					return TRUE;
966  				default :
967  					break;
968  			}
969  			break;
970  		}
971  		default:
972  			break;
973  	}
974  	return FALSE;
975  }
976  void DockingCont::onSize()
977  {
978  	TCITEM tcItem = {};
979  	RECT rc = {};
980  	RECT rcTemp = {};
981  	UINT iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
982  	UINT iTabOff = 0;
983  	getClientRect(rc);
984  	if (iItemCnt >= 1)
985  	{
986  		int tabDpiDynamicalHeight = NppParameters::getInstance()._dpiManager.scaleY(16) + 8;
987  		if (_isFloating == false)
988  		{
989  			if (_isTopCaption == TRUE)
990  			{
991  				::SetWindowPos(_hCaption, NULL, rc.left, rc.top, rc.right, _captionHeightDynamic, SWP_NOZORDER | SWP_NOACTIVATE);
992  				rc.top += _captionHeightDynamic;
993  				rc.bottom -= _captionHeightDynamic;
994  			}
995  			else
996  			{
997  				::SetWindowPos(_hCaption, NULL, rc.left, rc.top, _captionHeightDynamic, rc.bottom, SWP_NOZORDER | SWP_NOACTIVATE);
998  				rc.left += _captionHeightDynamic;
999  				rc.right -= _captionHeightDynamic;
1000  			}
1001  			if (iItemCnt >= 2)
1002  			{
1003  				rcTemp = rc;
1004  				rcTemp.top = (rcTemp.bottom + rcTemp.top) - (tabDpiDynamicalHeight + _captionGapDynamic);
1005  				rcTemp.bottom	= tabDpiDynamicalHeight;
1006  				iTabOff			= tabDpiDynamicalHeight;
1007  				::SetWindowPos(_hContTab, NULL,
1008  								rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1009  								SWP_NOZORDER | SWP_SHOWWINDOW |  SWP_NOACTIVATE);
1010  				if (_hTabUpdown != nullptr)
1011  				{
1012  					::InvalidateRect(_hTabUpdown, nullptr, TRUE);
1013  					::UpdateWindow(_hTabUpdown);
1014  				}
1015  			}
1016  			rcTemp = rc;
1017  			if (_isTopCaption == TRUE)
1018  			{
1019  				rcTemp.top += _captionGapDynamic;
1020  				rcTemp.bottom -= (iTabOff + _captionGapDynamic);
1021  			}
1022  			else
1023  			{
1024  				rcTemp.left += _captionGapDynamic;
1025  				rcTemp.right -= _captionGapDynamic;
1026  				rcTemp.bottom -= iTabOff;
1027  			}
1028  			::SetWindowPos(::GetDlgItem(_hSelf, IDC_CLIENT_TAB), NULL,
1029  							rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1030  							SWP_NOZORDER | SWP_NOACTIVATE);
1031  		}
1032  		else
1033  		{
1034  			for (size_t iTb = 0, len = _vTbData.size(); iTb < len; ++iTb)
1035  			{
1036  				getWindowRect(_vTbData[iTb]->rcFloat);
1037  			}
1038  			if (iItemCnt >= 2)
1039  			{
1040  				rcTemp = rc;
1041  				rcTemp.top = rcTemp.bottom - (tabDpiDynamicalHeight + _captionGapDynamic);
1042  				rcTemp.bottom = tabDpiDynamicalHeight;
1043  				::SetWindowPos(_hContTab, NULL,
1044  								rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1045  								SWP_NOZORDER | SWP_SHOWWINDOW);
1046  				if (_hTabUpdown != nullptr)
1047  				{
1048  					::InvalidateRect(_hTabUpdown, nullptr, TRUE);
1049  					::UpdateWindow(_hTabUpdown);
1050  				}
1051  			}
1052  			rcTemp = rc;
1053  			rcTemp.bottom -= ((iItemCnt == 1)?0:tabDpiDynamicalHeight);
1054  			::SetWindowPos(::GetDlgItem(_hSelf, IDC_CLIENT_TAB), NULL,
1055  							rcTemp.left, rcTemp.top, rcTemp.right, rcTemp.bottom, 
1056  							SWP_NOZORDER | SWP_NOACTIVATE);
1057  		}
1058  		size_t iItemCnt2 = static_cast<size_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1059  		for (size_t iItem = 0; iItem < iItemCnt2; ++iItem)
1060  		{
1061  			tcItem.mask		= TCIF_PARAM;
1062  			::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1063  			if (!tcItem.lParam)
1064  				continue;
1065  			::SetWindowPos(((tTbData*)tcItem.lParam)->hClient, NULL,
1066  							0, 0, rcTemp.right, rcTemp.bottom, 
1067  							SWP_NOZORDER);
1068  			NMHDR nmhdr{};
1069  			nmhdr.code		= DMN_FLOATDROPPED;
1070  			nmhdr.hwndFrom	= _hSelf;
1071  			nmhdr.idFrom	= 0;
1072  			::SendMessage(((tTbData*)tcItem.lParam)->hClient, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1073  		}
1074  	}
1075  }
1076  void DockingCont::doClose(BOOL closeAll)
1077  {
1078  	int	iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1079  	int iItemCur = getActiveTb();
1080  	TCITEM	tcItem	= {};
1081  	tcItem.mask	= TCIF_PARAM;
1082  	::SendMessage(_hContTab, TCM_GETITEM, iItemCur, reinterpret_cast<LPARAM>(&tcItem));
1083  	if (tcItem.lParam)
1084  	{
1085  		if (NotifyParent(DMM_CLOSE) == 0)
1086  		{
1087  			hideToolbar((tTbData*)tcItem.lParam);
1088  		}
1089  	}
1090  	if (closeAll)
1091  	{
1092  		iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1093  		int iItemOff = 0;
1094  		for (int iItem = 0; iItem < iItemCnt; ++iItem)
1095  		{
1096  			TCITEM	tcItem	= {};
1097  			selectTab(iItemOff);
1098  			tcItem.mask	= TCIF_PARAM;
1099  			::SendMessage(_hContTab, TCM_GETITEM, iItemOff, reinterpret_cast<LPARAM>(&tcItem));
1100  			if (!tcItem.lParam)
1101  				continue;
1102  			if (NotifyParent(DMM_CLOSE) == 0)
1103  			{
1104  				hideToolbar((tTbData*)tcItem.lParam);
1105  			}
1106  			else
1107  			{
1108  				++iItemOff;
1109  			}
1110  		}
1111  	}
1112  	iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1113  	if (iItemCnt == 0)
1114  	{
1115  		doDialog(false);
1116  		::SendMessage(_hParent, WM_SIZE, 0, 0);
1117  	}
1118  }
1119  void DockingCont::showToolbar(tTbData* pTbData, BOOL state)
1120  {
1121  	if (state == SW_SHOW)
1122  	{
1123  		viewToolbar(pTbData);
1124  	}
1125  	else
1126  	{
1127  		hideToolbar(pTbData);
1128  	}
1129  }
1130  int DockingCont::hideToolbar(tTbData *pTbData, BOOL hideClient)
1131  {
1132  	int iItem = searchPosInTab(pTbData);
1133  	BOOL hadFocus = ::IsChild (pTbData->hClient, ::GetFocus());
1134  	if (TRUE == ::SendMessage(_hContTab, TCM_DELETEITEM, iItem, 0))
1135  	{
1136  		auto iItemCnt = ::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0);
1137  		if (iItemCnt != 0)
1138  		{
1139  			if (iItem == iItemCnt)
1140  			{
1141  				iItem--;
1142  			}
1143  			_prevItem = iItem;
1144  			selectTab(iItem);
1145  			if (iItemCnt == 1)
1146  			{
1147  				::ShowWindow(_hContTab, SW_HIDE);
1148  			}
1149  		}
1150  		else 
1151  		{
1152  			doDialog(false);
1153  			if (!_isFloating)
1154  			{
1155  				::SendMessage(_hParent, WM_SIZE, 0, 0);
1156  			}
1157  			if (hadFocus)
1158  				::PostMessage(::GetParent(_hParent), WM_ACTIVATE, WA_ACTIVE, 0);
1159  		}
1160  		if (hideClient == TRUE)
1161  		{
1162  			::ShowWindow(pTbData->hClient, SW_HIDE);
1163  		}
1164  	}
1165  	onSize();
1166  	return iItem;
1167  }
1168  void DockingCont::viewToolbar(tTbData *pTbData)
1169  {
1170  	TCITEM tcItem = {};
1171  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1172  	if (iItemCnt > 0)
1173  	{
1174  		UINT	iItem	= getActiveTb();
1175  		tcItem.mask		= TCIF_PARAM;
1176  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1177  		if (!tcItem.lParam)
1178  			return;
1179  		::ShowWindow(((tTbData*)tcItem.lParam)->hClient, SW_HIDE);
1180  	}
1181  	int iTabPos = searchPosInTab(pTbData);
1182  	tcItem.mask			= TCIF_PARAM;
1183  	tcItem.lParam = reinterpret_cast<LPARAM>(pTbData);
1184  	if (iTabPos == -1)
1185  	{
1186  		::SendMessage(_hContTab, TCM_INSERTITEM, iItemCnt, reinterpret_cast<LPARAM>(&tcItem));
1187  		selectTab(iItemCnt);
1188  	}
1189  	else
1190  	{
1191  		::SendMessage(_hContTab, TCM_SETITEM, iTabPos, reinterpret_cast<LPARAM>(&tcItem));
1192  		selectTab(iTabPos);
1193  	}
1194  	if (isVisible() == false)
1195  	{
1196  		doDialog();
1197  		::SendMessage(_hParent, WM_SIZE, 0, 0);
1198  	}
1199  	onSize();
1200  }
1201  int DockingCont::searchPosInTab(tTbData* pTbData)
1202  {
1203  	TCITEM tcItem = {};
1204  	int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1205  	tcItem.mask	= TCIF_PARAM;
1206  	for (int iItem = 0; iItem < iItemCnt; ++iItem)
1207  	{
1208  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1209  		if (!tcItem.lParam)
1210  			continue;
1211  		if (((tTbData*)tcItem.lParam)->hClient == pTbData->hClient)
1212  			return iItem;
1213  	}
1214  	return -1;
1215  }
1216  void DockingCont::selectTab(int iTab)
1217  {
1218  	if (iTab != -1)
1219  	{
1220  		const TCHAR	*pszMaxTxt	= NULL;
1221  		TCITEM tcItem = {};
1222  		SIZE size = {};
1223  		int maxWidth = 0;
1224  		int iItemCnt = static_cast<int32_t>(::SendMessage(_hContTab, TCM_GETITEMCOUNT, 0, 0));
1225  		tcItem.mask		= TCIF_PARAM;
1226  		::SendMessage(_hContTab, TCM_GETITEM, iTab, reinterpret_cast<LPARAM>(&tcItem));
1227  		if (!tcItem.lParam)
1228  			return;
1229  		::ShowWindow(((tTbData*)tcItem.lParam)->hClient, SW_SHOW);
1230  		::SetFocus(((tTbData*)tcItem.lParam)->hClient);
1231  		NMHDR nmhdr{};
1232  		nmhdr.code		= DMN_SWITCHIN;
1233  		nmhdr.hwndFrom	= _hSelf;
1234  		nmhdr.idFrom	= 0;
1235  		::SendMessage(reinterpret_cast<tTbData*>(tcItem.lParam)->hClient, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1236  		if (static_cast<unsigned int>(iTab) != _prevItem)
1237  		{
1238  			::SendMessage(_hContTab, TCM_GETITEM, _prevItem, reinterpret_cast<LPARAM>(&tcItem));
1239  			if (!tcItem.lParam)
1240  				return;
1241  			::ShowWindow(((tTbData*)tcItem.lParam)->hClient, SW_HIDE);
1242  			NMHDR nmhdr{};
1243  			nmhdr.code		= DMN_SWITCHOFF;
1244  			nmhdr.hwndFrom	= _hSelf;
1245  			nmhdr.idFrom	= 0;
1246  			::SendMessage(((tTbData*)tcItem.lParam)->hClient, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
1247  		}
1248  		HDC		hDc	= ::GetDC(_hContTab);
1249  		SelectObject(hDc, _hFont);
1250  		for (int iItem = 0; iItem < iItemCnt; ++iItem)
1251  		{
1252  			const TCHAR *pszTabTxt = NULL;
1253  			::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1254  			if (!tcItem.lParam)
1255  				continue;
1256  			pszTabTxt = reinterpret_cast<tTbData*>(tcItem.lParam)->pszName;
1257  			GetTextExtentPoint32(hDc, pszTabTxt, lstrlen(pszTabTxt), &size);
1258  			if (maxWidth < size.cx) 
1259  			{
1260  				maxWidth	= size.cx;
1261  				pszMaxTxt	= pszTabTxt;
1262  			}
1263  		}
1264  		::ReleaseDC(_hSelf, hDc);
1265  		tcItem.mask	= TCIF_TEXT;
1266  		for (int iItem = 0; iItem < iItemCnt; ++iItem)
1267  		{
1268  			generic_string szText;
1269  			if (iItem == iTab && pszMaxTxt)
1270  			{
1271  				szText = TEXT("        ");
1272  				szText += pszMaxTxt;
1273  			}
1274  			tcItem.pszText = (TCHAR *)szText.c_str();
1275  			::SendMessage(_hContTab, TCM_SETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1276  		}
1277  		::SendMessage(_hContTab, TCM_SETCURSEL, iTab, 0);
1278  		_prevItem = iTab;
1279  		updateCaption();
1280  		onSize();
1281  	}
1282  }
1283  bool DockingCont::updateCaption()
1284  {
<span onclick='openModal()' class='match'>1285  	if (!_hContTab)
1286  		return false;
1287  	TCITEM			tcItem	= {};
1288  	int				iItem	= getActiveTb();
</span>1289  	if (iItem < 0)
1290  		return false;
1291  	tcItem.mask		= TCIF_PARAM;
1292  	::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1293  	if (!tcItem.lParam) return false;
1294  	_pszCaption = ((tTbData*)tcItem.lParam)->pszName;
1295  	if ((((tTbData*)tcItem.lParam)->uMask & DWS_ADDINFO) && 
1296  		(lstrlen(((tTbData*)tcItem.lParam)->pszAddInfo) != 0))
1297  	{
1298  		_pszCaption += TEXT(" - ");
1299  		_pszCaption += ((tTbData*)tcItem.lParam)->pszAddInfo; 
1300  	}
1301  	if (_isFloating == true)
1302  	{
1303  		::SetWindowText(_hSelf, _pszCaption.c_str());
1304  	}
1305  	else
1306  	{
1307  		::SetWindowText(_hCaption, _pszCaption.c_str());
1308  	}
1309  	return true;
1310  }
1311  void DockingCont::focusClient()
1312  {
1313  	TCITEM		tcItem	= {};
1314  	int			iItem	= getActiveTb();	
1315  	if (iItem != -1)
1316  	{
1317  		tcItem.mask		= TCIF_PARAM;
1318  		::SendMessage(_hContTab, TCM_GETITEM, iItem, reinterpret_cast<LPARAM>(&tcItem));
1319  		if (!tcItem.lParam)
1320  			return;
1321  		tTbData *tbData = (tTbData *)tcItem.lParam;
1322  		if (tbData->pszAddInfo && lstrcmp(tbData->pszAddInfo, DM_NOFOCUSWHILECLICKINGCAPTION) == 0)
1323  			return;
1324  		::SetFocus(tbData->hClient);
1325  	}
1326  }
1327  LPARAM DockingCont::NotifyParent(UINT message)
1328  {
1329  	return ::SendMessage(_hParent, message, 0, reinterpret_cast<LPARAM>(this));
1330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TreeView.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingCont.cpp</div>
                </div>
                <div class="column column_space"><pre><code>472  	if (!tree2Search)
473  		return false;
474  	TCHAR textBuffer[MAX_PATH] = { '\0' };
475  	TVITEM tvItem;
476  	tvItem.hItem = tree2Search;
</pre></code></div>
                <div class="column column_space"><pre><code>1285  	if (!_hContTab)
1286  		return false;
1287  	TCITEM			tcItem	= {};
1288  	int				iItem	= getActiveTb();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    