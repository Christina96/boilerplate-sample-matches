
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.526806526806526%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-config.hpp</h3>
            <pre><code>1  #pragma once
2  #include <boost/config.hpp>
3  #include <boost/version.hpp>
4  #include <algorithm>
5  #include <array>
6  #include <chrono>
7  #include <optional>
8  #include <string>
9  using namespace std::chrono_literals;
10  namespace boost
11  {
12  namespace filesystem
13  {
14  	class path;
15  }
16  }
17  #define xstr(a) ver_str (a)
18  #define ver_str(a) #a
19  char const * const NANO_VERSION_STRING = xstr (TAG_VERSION_STRING);
20  char const * const NANO_MAJOR_VERSION_STRING = xstr (MAJOR_VERSION_STRING);
21  char const * const NANO_MINOR_VERSION_STRING = xstr (MINOR_VERSION_STRING);
22  char const * const NANO_PATCH_VERSION_STRING = xstr (PATCH_VERSION_STRING);
23  char const * const NANO_PRE_RELEASE_VERSION_STRING = xstr (PRE_RELEASE_VERSION_STRING);
24  char const * const BUILD_INFO = xstr (GIT_COMMIT_HASH BOOST_COMPILER) " \"BOOST " xstr (BOOST_VERSION) "\" BUILT " xstr (__DATE__);
25  #if defined(__has_feature)
26  #if __has_feature(address_sanitizer)
27  inline bool is_asan_build ()
28  {
29  	return true;
30  }
31  #else
32  inline bool is_asan_build ()
33  {
34  	return false;
35  }
36  #endif
37  #elif defined(__SANITIZE_ADDRESS__)
38  inline bool is_asan_build ()
39  {
40  	return true;
41  }
42  #else
43  inline bool is_asan_build ()
44  {
45  	return false;
46  }
47  #endif
48  #if defined(__has_feature)
49  #if __has_feature(thread_sanitizer)
50  inline bool is_tsan_build ()
51  {
52  	return true;
53  }
54  #else
55  inline bool is_tsan_build ()
56  {
57  	return false;
58  }
59  #endif
60  #elif defined(__SANITIZE_THREAD__)
61  inline bool is_tsan_build ()
62  {
63  	return true;
64  }
65  #else
66  inline bool is_tsan_build ()
67  {
68  	return false;
69  }
70  #endif
71  namespace nano
72  {
73  uint8_t get_major_node_version ();
74  uint8_t get_minor_node_version ();
75  uint8_t get_patch_node_version ();
76  uint8_t get_pre_release_node_version ();
77  std::optional<std::string> get_env (char const * variable_name);
78  std::string get_env_or_default (char const * variable_name, std::string const default_value);
79  int get_env_int_or_default (char const * variable_name, int const default_value);
80  uint64_t get_env_threshold_or_default (char const * variable_name, uint64_t const default_value);
81  uint16_t test_node_port ();
82  uint16_t test_rpc_port ();
83  uint16_t test_ipc_port ();
84  uint16_t test_websocket_port ();
85  std::array<uint8_t, 2> test_magic_number ();
86  uint32_t test_scan_wallet_reps_delay ();
87  enum class networks : uint16_t
88  {
89  	invalid = 0x0,
90  	nano_dev_network = 0x5241, 
91  	nano_beta_network = 0x5242, 
92  	nano_live_network = 0x5243, 
93  	nano_test_network = 0x5258, 
94  };
95  enum class work_version
96  {
97  	unspecified,
98  	work_1
99  };
100  enum class block_type : uint8_t;
101  class root;
102  class block;
103  class block_details;
104  class work_thresholds
105  {
106  public:
107  	uint64_t const epoch_1;
108  	uint64_t const epoch_2;
109  	uint64_t const epoch_2_receive;
110  	uint64_t const base;
111  	uint64_t const entry;
112  	constexpr work_thresholds (uint64_t epoch_1_a, uint64_t epoch_2_a, uint64_t epoch_2_receive_a) :
113  		epoch_1 (epoch_1_a), epoch_2 (epoch_2_a), epoch_2_receive (epoch_2_receive_a),
114  		base (std::max ({ epoch_1, epoch_2, epoch_2_receive })),
115  		entry (std::min ({ epoch_1, epoch_2, epoch_2_receive }))
116  	{
117  	}
118  	work_thresholds () = delete;
119  	work_thresholds operator= (nano::work_thresholds const & other_a)
120  	{
121  		return other_a;
122  	}
<span onclick='openModal()' class='match'>123  	uint64_t threshold_entry (nano::work_version const, nano::block_type const) const;
124  	uint64_t threshold (nano::block_details const &) const;
125  	uint64_t threshold (nano::work_version const, nano::block_details const) const;
</span>126  	uint64_t threshold_base (nano::work_version const) const;
127  	uint64_t value (nano::root const & root_a, uint64_t work_a) const;
128  	double normalized_multiplier (double const, uint64_t const) const;
129  	double denormalized_multiplier (double const, uint64_t const) const;
130  	uint64_t difficulty (nano::work_version const, nano::root const &, uint64_t const) const;
131  	uint64_t difficulty (nano::block const & block_a) const;
132  	bool validate_entry (nano::work_version const, nano::root const &, uint64_t const) const;
133  	bool validate_entry (nano::block const &) const;
134  	static nano::work_thresholds const publish_full;
135  	static nano::work_thresholds const publish_beta;
136  	static nano::work_thresholds const publish_dev;
137  	static nano::work_thresholds const publish_test;
138  };
139  class network_constants
140  {
141  	static constexpr std::chrono::seconds default_cleanup_period = std::chrono::seconds (60);
142  	static constexpr size_t default_max_peers_per_ip = 10;
143  public:
144  	network_constants (nano::work_thresholds & work_, nano::networks network_a) :
145  		current_network (network_a),
146  		work (work_),
147  		principal_weight_factor (1000), 
148  		default_node_port (44000),
149  		default_rpc_port (45000),
150  		default_ipc_port (46000),
151  		default_websocket_port (47000),
152  		aec_loop_interval_ms (300), 
153  		cleanup_period (default_cleanup_period),
154  		keepalive_period (std::chrono::seconds (15)),
155  		idle_timeout (default_cleanup_period * 2),
156  		silent_connection_tolerance_time (std::chrono::seconds (120)),
157  		syn_cookie_cutoff (std::chrono::seconds (5)),
158  		bootstrap_interval (std::chrono::seconds (15 * 60)),
159  		max_peers_per_ip (default_max_peers_per_ip),
160  		max_peers_per_subnetwork (default_max_peers_per_ip * 4),
161  		ipv6_subnetwork_prefix_for_limiting (64), 
162  		peer_dump_interval (std::chrono::seconds (5 * 60)),
163  		vote_broadcast_interval (15 * 1000)
164  	{
165  		if (is_live_network ())
166  		{
167  			default_node_port = 7075;
168  			default_rpc_port = 7076;
169  			default_ipc_port = 7077;
170  			default_websocket_port = 7078;
171  		}
172  		else if (is_beta_network ())
173  		{
174  			default_node_port = 54000;
175  			default_rpc_port = 55000;
176  			default_ipc_port = 56000;
177  			default_websocket_port = 57000;
178  		}
179  		else if (is_test_network ())
180  		{
181  			default_node_port = test_node_port ();
182  			default_rpc_port = test_rpc_port ();
183  			default_ipc_port = test_ipc_port ();
184  			default_websocket_port = test_websocket_port ();
185  		}
186  		else if (is_dev_network ())
187  		{
188  			aec_loop_interval_ms = 20;
189  			cleanup_period = std::chrono::seconds (1);
190  			keepalive_period = std::chrono::seconds (1);
191  			idle_timeout = cleanup_period * 15;
192  			max_peers_per_ip = 20;
193  			max_peers_per_subnetwork = max_peers_per_ip * 4;
194  			peer_dump_interval = std::chrono::seconds (1);
195  			vote_broadcast_interval = 500;
196  			telemetry_request_cooldown = 500ms;
197  			telemetry_cache_cutoff = 2000ms;
198  			telemetry_request_interval = 500ms;
199  			telemetry_broadcast_interval = 500ms;
200  			optimistic_activation_delay = 2s;
201  		}
202  	}
203  	static char const * active_network_err_msg;
204  	nano::networks current_network{ nano::network_constants::active_network };
205  	nano::work_thresholds & work;
206  	unsigned principal_weight_factor;
207  	uint16_t default_node_port;
208  	uint16_t default_rpc_port;
209  	uint16_t default_ipc_port;
210  	uint16_t default_websocket_port;
211  	unsigned aec_loop_interval_ms;
212  	std::chrono::seconds cleanup_period;
213  	std::chrono::milliseconds cleanup_period_half () const
214  	{
215  		return std::chrono::duration_cast<std::chrono::milliseconds> (cleanup_period) / 2;
216  	}
217  	std::chrono::seconds cleanup_cutoff () const
218  	{
219  		return cleanup_period * 5;
220  	}
221  	std::chrono::seconds keepalive_period;
222  	std::chrono::seconds idle_timeout;
223  	std::chrono::seconds silent_connection_tolerance_time;
224  	std::chrono::seconds syn_cookie_cutoff;
225  	std::chrono::seconds bootstrap_interval;
226  	size_t max_peers_per_ip;
227  	size_t max_peers_per_subnetwork;
228  	size_t ipv6_subnetwork_prefix_for_limiting;
229  	std::chrono::seconds peer_dump_interval;
230  	uint64_t vote_broadcast_interval;
231  	std::chrono::milliseconds telemetry_request_cooldown{ 1000 * 15 };
232  	std::chrono::milliseconds telemetry_request_interval{ 1000 * 60 };
233  	std::chrono::milliseconds telemetry_broadcast_interval{ 1000 * 60 };
234  	std::chrono::milliseconds telemetry_cache_cutoff{ 1000 * 130 }; 
235  	std::chrono::seconds optimistic_activation_delay{ 30 };
236  	nano::networks network () const
237  	{
238  		return current_network;
239  	}
240  	static void set_active_network (nano::networks network_a)
241  	{
242  		active_network = network_a;
243  	}
244  	static bool set_active_network (std::string network_a)
245  	{
246  		auto error{ false };
247  		if (network_a == "live")
248  		{
249  			active_network = nano::networks::nano_live_network;
250  		}
251  		else if (network_a == "beta")
252  		{
253  			active_network = nano::networks::nano_beta_network;
254  		}
255  		else if (network_a == "dev")
256  		{
257  			active_network = nano::networks::nano_dev_network;
258  		}
259  		else if (network_a == "test")
260  		{
261  			active_network = nano::networks::nano_test_network;
262  		}
263  		else
264  		{
265  			error = true;
266  		}
267  		return error;
268  	}
269  	char const * get_current_network_as_string ()
270  	{
271  		return is_live_network () ? "live" : is_beta_network () ? "beta"
272  		: is_test_network ()                                    ? "test"
273  																: "dev";
274  	}
275  	bool is_live_network () const
276  	{
277  		return current_network == nano::networks::nano_live_network;
278  	}
279  	bool is_beta_network () const
280  	{
281  		return current_network == nano::networks::nano_beta_network;
282  	}
283  	bool is_dev_network () const
284  	{
285  		return current_network == nano::networks::nano_dev_network;
286  	}
287  	bool is_test_network () const
288  	{
289  		return current_network == nano::networks::nano_test_network;
290  	}
291  	static nano::networks active_network;
292  	uint8_t const protocol_version = 0x13;
293  	uint8_t const protocol_version_min = 0x12;
294  	uint8_t const bootstrap_protocol_version_min = 0x13;
295  };
296  std::string get_node_toml_config_path (boost::filesystem::path const & data_path);
297  std::string get_rpc_toml_config_path (boost::filesystem::path const & data_path);
298  std::string get_access_toml_config_path (boost::filesystem::path const & data_path);
299  std::string get_qtwallet_toml_config_path (boost::filesystem::path const & data_path);
300  std::string get_tls_toml_config_path (boost::filesystem::path const & data_path);
301  bool running_within_valgrind ();
302  bool memory_intensive_instrumentation ();
303  bool slow_instrumentation ();
304  bool is_sanitizer_build ();
305  void force_nano_dev_network ();
306  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-numbers.cpp</h3>
            <pre><code>1  #include <nano/crypto/blake2/blake2.h>
2  #include <nano/crypto_lib/random_pool.hpp>
3  #include <nano/crypto_lib/secure_memory.hpp>
4  #include <nano/lib/numbers.hpp>
5  #include <nano/lib/utility.hpp>
6  #include <nano/secure/common.hpp>
7  #include <crypto/ed25519-donna/ed25519.h>
8  #include <cryptopp/aes.h>
9  #include <cryptopp/modes.h>
10  namespace
11  {
12  char const * account_lookup ("13456789abcdefghijkmnopqrstuwxyz");
13  char const * account_reverse ("~0~1234567~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~89:;<=>?@AB~CDEFGHIJK~LMNO~~~~~");
14  char account_encode (uint8_t value)
15  {
16  	debug_assert (value < 32);
17  	auto result (account_lookup[value]);
18  	return result;
19  }
20  uint8_t account_decode (char value)
21  {
22  	debug_assert (value >= '0');
23  	debug_assert (value <= '~');
24  	auto result (account_reverse[value - 0x30]);
25  	if (result != '~')
26  	{
27  		result -= 0x30;
28  	}
29  	return result;
30  }
31  }
32  void nano::public_key::encode_account (std::string & destination_a) const
33  {
34  	debug_assert (destination_a.empty ());
35  	destination_a.reserve (65);
36  	uint64_t check (0);
37  	blake2b_state hash;
38  	blake2b_init (&hash, 5);
39  	blake2b_update (&hash, bytes.data (), bytes.size ());
40  	blake2b_final (&hash, reinterpret_cast<uint8_t *> (&check), 5);
41  	nano::uint512_t number_l (number ());
42  	number_l <<= 40;
43  	number_l |= nano::uint512_t (check);
44  	for (auto i (0); i < 60; ++i)
45  	{
46  		uint8_t r (number_l & static_cast<uint8_t> (0x1f));
47  		number_l >>= 5;
48  		destination_a.push_back (account_encode (r));
49  	}
50  	destination_a.append ("_onan"); 
51  	std::reverse (destination_a.begin (), destination_a.end ());
52  }
53  std::string nano::public_key::to_account () const
54  {
55  	std::string result;
56  	encode_account (result);
57  	return result;
58  }
59  nano::public_key::public_key () :
60  	uint256_union{ 0 }
61  {
62  }
63  nano::public_key const & nano::public_key::null ()
64  {
65  	return nano::hardened_constants::get ().not_an_account;
66  }
67  std::string nano::public_key::to_node_id () const
68  {
69  	return to_account ().replace (0, 4, "node");
70  }
71  bool nano::public_key::decode_node_id (std::string const & source_a)
72  {
73  	return decode_account (source_a);
74  }
75  bool nano::public_key::decode_account (std::string const & source_a)
76  {
77  	auto error (source_a.size () < 5);
78  	if (!error)
79  	{
80  		auto xrb_prefix (source_a[0] == 'x' && source_a[1] == 'r' && source_a[2] == 'b' && (source_a[3] == '_' || source_a[3] == '-'));
81  		auto nano_prefix (source_a[0] == 'n' && source_a[1] == 'a' && source_a[2] == 'n' && source_a[3] == 'o' && (source_a[4] == '_' || source_a[4] == '-'));
82  		auto node_id_prefix = (source_a[0] == 'n' && source_a[1] == 'o' && source_a[2] == 'd' && source_a[3] == 'e' && source_a[4] == '_');
83  		error = (xrb_prefix && source_a.size () != 64) || (nano_prefix && source_a.size () != 65);
84  		if (!error)
85  		{
86  			if (xrb_prefix || nano_prefix || node_id_prefix)
87  			{
88  				auto i (source_a.begin () + (xrb_prefix ? 4 : 5));
89  				if (*i == '1' || *i == '3')
90  				{
91  					nano::uint512_t number_l;
92  					for (auto j (source_a.end ()); !error && i != j; ++i)
93  					{
94  						uint8_t character (*i);
95  						error = character < 0x30 || character >= 0x80;
96  						if (!error)
97  						{
98  							uint8_t byte (account_decode (character));
99  							error = byte == '~';
100  							if (!error)
101  							{
102  								number_l <<= 5;
103  								number_l += byte;
104  							}
105  						}
106  					}
107  					if (!error)
108  					{
109  						nano::public_key temp = (number_l >> 40).convert_to<nano::uint256_t> ();
110  						uint64_t check (number_l & static_cast<uint64_t> (0xffffffffff));
111  						uint64_t validation (0);
112  						blake2b_state hash;
113  						blake2b_init (&hash, 5);
114  						blake2b_update (&hash, temp.bytes.data (), temp.bytes.size ());
115  						blake2b_final (&hash, reinterpret_cast<uint8_t *> (&validation), 5);
116  						error = check != validation;
117  						if (!error)
118  						{
119  							*this = temp;
120  						}
121  					}
122  				}
123  				else
124  				{
125  					error = true;
126  				}
127  			}
128  			else
129  			{
130  				error = true;
131  			}
132  		}
133  	}
134  	return error;
135  }
136  nano::uint256_union::uint256_union (nano::uint256_t const & number_a)
137  {
138  	bytes.fill (0);
139  	boost::multiprecision::export_bits (number_a, bytes.rbegin (), 8, false);
140  }
141  void nano::uint256_union::encrypt (nano::raw_key const & cleartext, nano::raw_key const & key, uint128_union const & iv)
142  {
143  	CryptoPP::AES::Encryption alg (key.bytes.data (), sizeof (key.bytes));
144  	CryptoPP::CTR_Mode_ExternalCipher::Encryption enc (alg, iv.bytes.data ());
145  	enc.ProcessData (bytes.data (), cleartext.bytes.data (), sizeof (cleartext.bytes));
146  }
147  bool nano::uint256_union::is_zero () const
148  {
149  	return qwords[0] == 0 && qwords[1] == 0 && qwords[2] == 0 && qwords[3] == 0;
150  }
151  std::string nano::uint256_union::to_string () const
152  {
153  	std::string result;
154  	encode_hex (result);
155  	return result;
156  }
157  nano::uint256_union & nano::uint256_union::operator^= (nano::uint256_union const & other_a)
158  {
159  	auto j (other_a.qwords.begin ());
160  	for (auto i (qwords.begin ()), n (qwords.end ()); i != n; ++i, ++j)
161  	{
162  		*i ^= *j;
163  	}
164  	return *this;
165  }
166  nano::uint256_union nano::uint256_union::operator^ (nano::uint256_union const & other_a) const
167  {
168  	nano::uint256_union result;
169  	auto k (result.qwords.begin ());
170  	for (auto i (qwords.begin ()), j (other_a.qwords.begin ()), n (qwords.end ()); i != n; ++i, ++j, ++k)
171  	{
172  		*k = *i ^ *j;
173  	}
174  	return result;
175  }
176  nano::uint256_union::uint256_union (std::string const & hex_a)
177  {
178  	auto error (decode_hex (hex_a));
179  	release_assert (!error);
180  }
181  void nano::uint256_union::clear ()
182  {
183  	qwords.fill (0);
184  }
185  nano::uint256_t nano::uint256_union::number () const
186  {
187  	nano::uint256_t result;
188  	boost::multiprecision::import_bits (result, bytes.begin (), bytes.end ());
189  	return result;
190  }
191  void nano::uint256_union::encode_hex (std::string & text) const
192  {
193  	debug_assert (text.empty ());
194  	std::stringstream stream;
195  	stream << std::hex << std::uppercase << std::noshowbase << std::setw (64) << std::setfill ('0');
196  	stream << number ();
197  	text = stream.str ();
198  }
199  bool nano::uint256_union::decode_hex (std::string const & text)
200  {
201  	auto error (false);
202  	if (!text.empty () && text.size () <= 64)
203  	{
204  		std::stringstream stream (text);
205  		stream << std::hex << std::noshowbase;
206  		nano::uint256_t number_l;
207  		try
208  		{
209  			stream >> number_l;
210  			*this = number_l;
211  			if (!stream.eof ())
212  			{
213  				error = true;
214  			}
215  		}
216  		catch (std::runtime_error &)
217  		{
218  			error = true;
219  		}
220  	}
221  	else
222  	{
223  		error = true;
224  	}
225  	return error;
226  }
227  void nano::uint256_union::encode_dec (std::string & text) const
228  {
229  	debug_assert (text.empty ());
230  	std::stringstream stream;
231  	stream << std::dec << std::noshowbase;
232  	stream << number ();
233  	text = stream.str ();
234  }
235  bool nano::uint256_union::decode_dec (std::string const & text)
236  {
237  	auto error (text.size () > 78 || (text.size () > 1 && text.front () == '0') || (!text.empty () && text.front () == '-'));
238  	if (!error)
239  	{
240  		std::stringstream stream (text);
241  		stream << std::dec << std::noshowbase;
242  		nano::uint256_t number_l;
243  		try
244  		{
245  			stream >> number_l;
246  			*this = number_l;
247  			if (!stream.eof ())
248  			{
249  				error = true;
250  			}
251  		}
252  		catch (std::runtime_error &)
253  		{
254  			error = true;
255  		}
256  	}
257  	return error;
258  }
259  nano::uint256_union::uint256_union (uint64_t value0)
260  {
261  	*this = nano::uint256_t (value0);
262  }
263  bool nano::uint512_union::operator== (nano::uint512_union const & other_a) const
264  {
265  	return bytes == other_a.bytes;
266  }
267  nano::uint512_union::uint512_union (nano::uint256_union const & upper, nano::uint256_union const & lower)
268  {
269  	uint256s[0] = upper;
270  	uint256s[1] = lower;
271  }
272  nano::uint512_union::uint512_union (nano::uint512_t const & number_a)
273  {
274  	bytes.fill (0);
275  	boost::multiprecision::export_bits (number_a, bytes.rbegin (), 8, false);
276  }
277  bool nano::uint512_union::is_zero () const
278  {
279  	return qwords[0] == 0 && qwords[1] == 0 && qwords[2] == 0 && qwords[3] == 0
280  	&& qwords[4] == 0 && qwords[5] == 0 && qwords[6] == 0 && qwords[7] == 0;
281  }
282  void nano::uint512_union::clear ()
283  {
284  	bytes.fill (0);
285  }
286  nano::uint512_t nano::uint512_union::number () const
287  {
288  	nano::uint512_t result;
289  	boost::multiprecision::import_bits (result, bytes.begin (), bytes.end ());
290  	return result;
291  }
292  void nano::uint512_union::encode_hex (std::string & text) const
293  {
294  	debug_assert (text.empty ());
295  	std::stringstream stream;
296  	stream << std::hex << std::uppercase << std::noshowbase << std::setw (128) << std::setfill ('0');
297  	stream << number ();
298  	text = stream.str ();
299  }
300  bool nano::uint512_union::decode_hex (std::string const & text)
301  {
302  	auto error (text.size () > 128);
303  	if (!error)
304  	{
305  		std::stringstream stream (text);
306  		stream << std::hex << std::noshowbase;
307  		nano::uint512_t number_l;
308  		try
309  		{
310  			stream >> number_l;
311  			*this = number_l;
312  			if (!stream.eof ())
313  			{
314  				error = true;
315  			}
316  		}
317  		catch (std::runtime_error &)
318  		{
319  			error = true;
320  		}
321  	}
322  	return error;
323  }
324  bool nano::uint512_union::operator!= (nano::uint512_union const & other_a) const
325  {
326  	return !(*this == other_a);
327  }
328  nano::uint512_union & nano::uint512_union::operator^= (nano::uint512_union const & other_a)
329  {
330  	uint256s[0] ^= other_a.uint256s[0];
331  	uint256s[1] ^= other_a.uint256s[1];
332  	return *this;
333  }
334  std::string nano::uint512_union::to_string () const
335  {
336  	std::string result;
337  	encode_hex (result);
338  	return result;
339  }
340  nano::raw_key::~raw_key ()
341  {
342  	secure_wipe_memory (bytes.data (), bytes.size ());
343  }
344  void nano::raw_key::decrypt (nano::uint256_union const & ciphertext, nano::raw_key const & key_a, uint128_union const & iv)
345  {
346  	CryptoPP::AES::Encryption alg (key_a.bytes.data (), sizeof (key_a.bytes));
347  	CryptoPP::CTR_Mode_ExternalCipher::Decryption dec (alg, iv.bytes.data ());
348  	dec.ProcessData (bytes.data (), ciphertext.bytes.data (), sizeof (ciphertext.bytes));
349  }
350  nano::raw_key nano::deterministic_key (nano::raw_key const & seed_a, uint32_t index_a)
351  {
352  	nano::raw_key prv_key;
353  	blake2b_state hash;
354  	blake2b_init (&hash, prv_key.bytes.size ());
355  	blake2b_update (&hash, seed_a.bytes.data (), seed_a.bytes.size ());
356  	nano::uint256_union index (index_a);
357  	blake2b_update (&hash, reinterpret_cast<uint8_t *> (&index.dwords[7]), sizeof (uint32_t));
358  	blake2b_final (&hash, prv_key.bytes.data (), prv_key.bytes.size ());
359  	return prv_key;
360  }
361  nano::public_key nano::pub_key (nano::raw_key const & raw_key_a)
362  {
363  	nano::public_key result;
364  	ed25519_publickey (raw_key_a.bytes.data (), result.bytes.data ());
365  	return result;
366  }
367  nano::signature nano::sign_message (nano::raw_key const & private_key, nano::public_key const & public_key, uint8_t const * data, size_t size)
368  {
369  	nano::signature result;
370  	ed25519_sign (data, size, private_key.bytes.data (), public_key.bytes.data (), result.bytes.data ());
371  	return result;
372  }
373  nano::signature nano::sign_message (nano::raw_key const & private_key, nano::public_key const & public_key, nano::uint256_union const & message)
374  {
375  	return nano::sign_message (private_key, public_key, message.bytes.data (), sizeof (message.bytes));
376  }
377  bool nano::validate_message (nano::public_key const & public_key, uint8_t const * data, size_t size, nano::signature const & signature)
378  {
379  	return 0 != ed25519_sign_open (data, size, public_key.bytes.data (), signature.bytes.data ());
380  }
381  bool nano::validate_message (nano::public_key const & public_key, nano::uint256_union const & message, nano::signature const & signature)
382  {
383  	return validate_message (public_key, message.bytes.data (), sizeof (message.bytes), signature);
384  }
385  bool nano::validate_message_batch (const unsigned char ** m, size_t * mlen, const unsigned char ** pk, const unsigned char ** RS, size_t num, int * valid)
386  {
387  	for (size_t i{ 0 }; i < num; ++i)
388  	{
389  		valid[i] = (0 == ed25519_sign_open (m[i], mlen[i], pk[i], RS[i]));
390  	}
391  	return true;
392  }
393  nano::uint128_union::uint128_union (std::string const & string_a)
394  {
395  	auto error (decode_hex (string_a));
396  	release_assert (!error);
397  }
398  nano::uint128_union::uint128_union (uint64_t value_a)
399  {
400  	*this = nano::uint128_t (value_a);
401  }
402  nano::uint128_union::uint128_union (nano::uint128_t const & number_a)
403  {
404  	bytes.fill (0);
405  	boost::multiprecision::export_bits (number_a, bytes.rbegin (), 8, false);
406  }
407  bool nano::uint128_union::operator== (nano::uint128_union const & other_a) const
408  {
409  	return qwords[0] == other_a.qwords[0] && qwords[1] == other_a.qwords[1];
410  }
411  bool nano::uint128_union::operator!= (nano::uint128_union const & other_a) const
412  {
413  	return !(*this == other_a);
414  }
415  bool nano::uint128_union::operator< (nano::uint128_union const & other_a) const
416  {
417  	return std::memcmp (bytes.data (), other_a.bytes.data (), 16) < 0;
418  }
419  bool nano::uint128_union::operator> (nano::uint128_union const & other_a) const
420  {
421  	return std::memcmp (bytes.data (), other_a.bytes.data (), 16) > 0;
422  }
423  nano::uint128_t nano::uint128_union::number () const
424  {
425  	nano::uint128_t result;
426  	boost::multiprecision::import_bits (result, bytes.begin (), bytes.end ());
427  	return result;
428  }
429  void nano::uint128_union::encode_hex (std::string & text) const
430  {
431  	debug_assert (text.empty ());
432  	std::stringstream stream;
433  	stream << std::hex << std::uppercase << std::noshowbase << std::setw (32) << std::setfill ('0');
434  	stream << number ();
435  	text = stream.str ();
436  }
437  bool nano::uint128_union::decode_hex (std::string const & text)
438  {
439  	auto error (text.size () > 32);
440  	if (!error)
441  	{
442  		std::stringstream stream (text);
443  		stream << std::hex << std::noshowbase;
444  		nano::uint128_t number_l;
445  		try
446  		{
447  			stream >> number_l;
448  			*this = number_l;
449  			if (!stream.eof ())
450  			{
451  				error = true;
452  			}
453  		}
454  		catch (std::runtime_error &)
455  		{
456  			error = true;
457  		}
458  	}
459  	return error;
460  }
461  void nano::uint128_union::encode_dec (std::string & text) const
462  {
463  	debug_assert (text.empty ());
464  	std::stringstream stream;
465  	stream << std::dec << std::noshowbase;
466  	stream << number ();
467  	text = stream.str ();
468  }
469  bool nano::uint128_union::decode_dec (std::string const & text, bool decimal)
470  {
471  	auto error (text.size () > 39 || (text.size () > 1 && text.front () == '0' && !decimal) || (!text.empty () && text.front () == '-'));
472  	if (!error)
473  	{
474  		std::stringstream stream (text);
475  		stream << std::dec << std::noshowbase;
476  		boost::multiprecision::checked_uint128_t number_l;
477  		try
478  		{
479  			stream >> number_l;
480  			nano::uint128_t unchecked (number_l);
481  			*this = unchecked;
482  			if (!stream.eof ())
483  			{
484  				error = true;
485  			}
486  		}
487  		catch (std::runtime_error &)
488  		{
489  			error = true;
490  		}
491  	}
492  	return error;
493  }
494  bool nano::uint128_union::decode_dec (std::string const & text, nano::uint128_t scale)
495  {
496  	bool error (text.size () > 40 || (!text.empty () && text.front () == '-'));
497  	if (!error)
498  	{
499  		auto delimiter_position (text.find (".")); 
500  		if (delimiter_position == std::string::npos)
501  		{
502  			nano::uint128_union integer;
503  			error = integer.decode_dec (text);
504  			if (!error)
505  			{
506  				try
507  				{
508  					auto result (boost::multiprecision::checked_uint128_t (integer.number ()) * boost::multiprecision::checked_uint128_t (scale));
509  					error = (result > std::numeric_limits<nano::uint128_t>::max ());
510  					if (!error)
511  					{
512  						*this = nano::uint128_t (result);
513  					}
514  				}
515  				catch (std::overflow_error &)
516  				{
517  					error = true;
518  				}
519  			}
520  		}
521  		else
522  		{
523  			nano::uint128_union integer_part;
524  			std::string integer_text (text.substr (0, delimiter_position));
525  			error = (integer_text.empty () || integer_part.decode_dec (integer_text));
526  			if (!error)
527  			{
528  				try
529  				{
530  					error = ((boost::multiprecision::checked_uint128_t (integer_part.number ()) * boost::multiprecision::checked_uint128_t (scale)) > std::numeric_limits<nano::uint128_t>::max ());
531  				}
532  				catch (std::overflow_error &)
533  				{
534  					error = true;
535  				}
536  				if (!error)
537  				{
538  					nano::uint128_union decimal_part;
539  					std::string decimal_text (text.substr (delimiter_position + 1, text.length ()));
540  					error = (decimal_text.empty () || decimal_part.decode_dec (decimal_text, true));
541  					if (!error)
542  					{
543  						auto scale_length (scale.convert_to<std::string> ().length ());
544  						error = (scale_length <= decimal_text.length ());
545  						if (!error)
546  						{
547  							auto base10 = boost::multiprecision::cpp_int (10);
548  							release_assert ((scale_length - decimal_text.length () - 1) <= std::numeric_limits<unsigned>::max ());
549  							auto pow10 = boost::multiprecision::pow (base10, static_cast<unsigned> (scale_length - decimal_text.length () - 1));
550  							auto decimal_part_num = decimal_part.number ();
551  							auto integer_part_scaled = integer_part.number () * scale;
552  							auto decimal_part_mult_pow = decimal_part_num * pow10;
553  							auto result = integer_part_scaled + decimal_part_mult_pow;
554  							error = (result > std::numeric_limits<nano::uint128_t>::max ());
555  							if (!error)
556  							{
557  								*this = nano::uint128_t (result);
558  							}
559  						}
560  					}
561  				}
562  			}
563  		}
564  	}
565  	return error;
566  }
567  void format_frac (std::ostringstream & stream, nano::uint128_t value, nano::uint128_t scale, int precision)
568  {
569  	auto reduce = scale;
570  	auto rem = value;
571  	while (reduce > 1 && rem > 0 && precision > 0)
572  	{
573  		reduce /= 10;
574  		auto val = rem / reduce;
575  		rem -= val * reduce;
576  		stream << val;
577  		precision--;
578  	}
579  }
580  void format_dec (std::ostringstream & stream, nano::uint128_t value, char group_sep, std::string const & groupings)
581  {
582  	auto largestPow10 = nano::uint256_t (1);
583  	int dec_count = 1;
584  	while (1)
585  	{
586  		auto next = largestPow10 * 10;
587  		if (next > value)
588  		{
589  			break;
590  		}
591  		largestPow10 = next;
592  		dec_count++;
593  	}
594  	if (dec_count > 39)
595  	{
596  		return;
597  	}
598  	bool emit_group[39];
599  	if (group_sep != 0)
600  	{
601  		int group_index = 0;
602  		int group_count = 0;
603  		for (int i = 0; i < dec_count; i++)
604  		{
605  			group_count++;
606  			if (group_count > groupings[group_index])
607  			{
608  				group_index = std::min (group_index + 1, (int)groupings.length () - 1);
609  				group_count = 1;
610  				emit_group[i] = true;
611  			}
612  			else
613  			{
614  				emit_group[i] = false;
615  			}
616  		}
617  	}
618  	auto reduce = nano::uint128_t (largestPow10);
619  	nano::uint128_t rem = value;
620  	while (reduce > 0)
621  	{
622  		auto val = rem / reduce;
623  		rem -= val * reduce;
624  		stream << val;
625  		dec_count--;
626  		if (group_sep != 0 && emit_group[dec_count] && reduce > 1)
627  		{
628  			stream << group_sep;
629  		}
630  		reduce /= 10;
631  	}
632  }
<span onclick='openModal()' class='match'>633  std::string format_balance (nano::uint128_t balance, nano::uint128_t scale, int precision, bool group_digits, char thousands_sep, char decimal_point, std::string & grouping)
634  {
635  	std::ostringstream stream;
636  	auto int_part = balance / scale;
</span>637  	auto frac_part = balance % scale;
638  	auto prec_scale = scale;
639  	for (int i = 0; i < precision; i++)
640  	{
641  		prec_scale /= 10;
642  	}
643  	if (int_part == 0 && frac_part > 0 && frac_part / prec_scale == 0)
644  	{
645  		stream << "< ";
646  		if (precision > 0)
647  		{
648  			stream << "0";
649  			stream << decimal_point;
650  			for (int i = 0; i < precision - 1; i++)
651  			{
652  				stream << "0";
653  			}
654  		}
655  		stream << "1";
656  	}
657  	else
658  	{
659  		format_dec (stream, int_part, group_digits && grouping.length () > 0 ? thousands_sep : 0, grouping);
660  		if (precision > 0 && frac_part > 0)
661  		{
662  			stream << decimal_point;
663  			format_frac (stream, frac_part, scale, precision);
664  		}
665  	}
666  	return stream.str ();
667  }
668  std::string nano::uint128_union::format_balance (nano::uint128_t scale, int precision, bool group_digits) const
669  {
670  	auto thousands_sep = std::use_facet<std::numpunct<char>> (std::locale ()).thousands_sep ();
671  	auto decimal_point = std::use_facet<std::numpunct<char>> (std::locale ()).decimal_point ();
672  	std::string grouping = "\3";
673  	return ::format_balance (number (), scale, precision, group_digits, thousands_sep, decimal_point, grouping);
674  }
675  std::string nano::uint128_union::format_balance (nano::uint128_t scale, int precision, bool group_digits, std::locale const & locale) const
676  {
677  	auto thousands_sep = std::use_facet<std::moneypunct<char>> (locale).thousands_sep ();
678  	auto decimal_point = std::use_facet<std::moneypunct<char>> (locale).decimal_point ();
679  	std::string grouping = std::use_facet<std::moneypunct<char>> (locale).grouping ();
680  	return ::format_balance (number (), scale, precision, group_digits, thousands_sep, decimal_point, grouping);
681  }
682  void nano::uint128_union::clear ()
683  {
684  	qwords.fill (0);
685  }
686  bool nano::uint128_union::is_zero () const
687  {
688  	return qwords[0] == 0 && qwords[1] == 0;
689  }
690  std::string nano::uint128_union::to_string () const
691  {
692  	std::string result;
693  	encode_hex (result);
694  	return result;
695  }
696  std::string nano::uint128_union::to_string_dec () const
697  {
698  	std::string result;
699  	encode_dec (result);
700  	return result;
701  }
702  nano::hash_or_account::hash_or_account () :
703  	account{}
704  {
705  }
706  nano::hash_or_account::hash_or_account (uint64_t value_a) :
707  	raw (value_a)
708  {
709  }
710  bool nano::hash_or_account::is_zero () const
711  {
712  	return raw.is_zero ();
713  }
714  void nano::hash_or_account::clear ()
715  {
716  	raw.clear ();
717  }
718  bool nano::hash_or_account::decode_hex (std::string const & text_a)
719  {
720  	return raw.decode_hex (text_a);
721  }
722  bool nano::hash_or_account::decode_account (std::string const & source_a)
723  {
724  	return account.decode_account (source_a);
725  }
726  std::string nano::hash_or_account::to_string () const
727  {
728  	return raw.to_string ();
729  }
730  std::string nano::hash_or_account::to_account () const
731  {
732  	return account.to_account ();
733  }
734  nano::block_hash const & nano::hash_or_account::as_block_hash () const
735  {
736  	return hash;
737  }
738  nano::account const & nano::hash_or_account::as_account () const
739  {
740  	return account;
741  }
742  nano::hash_or_account::operator nano::uint256_union const & () const
743  {
744  	return raw;
745  }
746  nano::block_hash const & nano::root::previous () const
747  {
748  	return hash;
749  }
750  bool nano::hash_or_account::operator== (nano::hash_or_account const & hash_or_account_a) const
751  {
752  	return bytes == hash_or_account_a.bytes;
753  }
754  bool nano::hash_or_account::operator!= (nano::hash_or_account const & hash_or_account_a) const
755  {
756  	return !(*this == hash_or_account_a);
757  }
758  std::string nano::to_string_hex (uint64_t const value_a)
759  {
760  	std::stringstream stream;
761  	stream << std::hex << std::noshowbase << std::setw (16) << std::setfill ('0');
762  	stream << value_a;
763  	return stream.str ();
764  }
765  std::string nano::to_string_hex (uint16_t const value_a)
766  {
767  	std::stringstream stream;
768  	stream << std::hex << std::noshowbase << std::setw (4) << std::setfill ('0');
769  	stream << value_a;
770  	return stream.str ();
771  }
772  bool nano::from_string_hex (std::string const & value_a, uint64_t & target_a)
773  {
774  	auto error (value_a.empty ());
775  	if (!error)
776  	{
777  		error = value_a.size () > 16;
778  		if (!error)
779  		{
780  			std::stringstream stream (value_a);
781  			stream << std::hex << std::noshowbase;
782  			try
783  			{
784  				uint64_t number_l;
785  				stream >> number_l;
786  				target_a = number_l;
787  				if (!stream.eof ())
788  				{
789  					error = true;
790  				}
791  			}
792  			catch (std::runtime_error &)
793  			{
794  				error = true;
795  			}
796  		}
797  	}
798  	return error;
799  }
800  std::string nano::to_string (double const value_a, int const precision_a)
801  {
802  	std::stringstream stream;
803  	stream << std::setprecision (precision_a) << std::fixed;
804  	stream << value_a;
805  	return stream.str ();
806  }
807  #ifdef _WIN32
808  #pragma warning(push)
809  #pragma warning(disable : 4146) 
810  #endif
811  uint64_t nano::difficulty::from_multiplier (double const multiplier_a, uint64_t const base_difficulty_a)
812  {
813  	debug_assert (multiplier_a > 0.);
814  	nano::uint128_t reverse_difficulty ((-base_difficulty_a) / multiplier_a);
815  	if (reverse_difficulty > std::numeric_limits<std::uint64_t>::max ())
816  	{
817  		return 0;
818  	}
819  	else if (reverse_difficulty != 0 || base_difficulty_a == 0 || multiplier_a < 1.)
820  	{
821  		return -(static_cast<uint64_t> (reverse_difficulty));
822  	}
823  	else
824  	{
825  		return std::numeric_limits<std::uint64_t>::max ();
826  	}
827  }
828  double nano::difficulty::to_multiplier (uint64_t const difficulty_a, uint64_t const base_difficulty_a)
829  {
830  	debug_assert (difficulty_a > 0);
831  	return static_cast<double> (-base_difficulty_a) / (-difficulty_a);
832  }
833  #ifdef _WIN32
834  #pragma warning(pop)
835  #endif
836  nano::public_key::operator nano::link const & () const
837  {
838  	return reinterpret_cast<nano::link const &> (*this);
839  }
840  nano::public_key::operator nano::root const & () const
841  {
842  	return reinterpret_cast<nano::root const &> (*this);
843  }
844  nano::public_key::operator nano::hash_or_account const & () const
845  {
846  	return reinterpret_cast<nano::hash_or_account const &> (*this);
847  }
848  bool nano::public_key::operator== (std::nullptr_t) const
849  {
850  	return bytes == null ().bytes;
851  }
852  bool nano::public_key::operator!= (std::nullptr_t) const
853  {
854  	return !(*this == nullptr);
855  }
856  nano::block_hash::operator nano::link const & () const
857  {
858  	return reinterpret_cast<nano::link const &> (*this);
859  }
860  nano::block_hash::operator nano::root const & () const
861  {
862  	return reinterpret_cast<nano::root const &> (*this);
863  }
864  nano::block_hash::operator nano::hash_or_account const & () const
865  {
866  	return reinterpret_cast<nano::hash_or_account const &> (*this);
867  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-config.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-numbers.cpp</div>
                </div>
                <div class="column column_space"><pre><code>123  	uint64_t threshold_entry (nano::work_version const, nano::block_type const) const;
124  	uint64_t threshold (nano::block_details const &) const;
125  	uint64_t threshold (nano::work_version const, nano::block_details const) const;
</pre></code></div>
                <div class="column column_space"><pre><code>633  std::string format_balance (nano::uint128_t balance, nano::uint128_t scale, int precision, bool group_digits, char thousands_sep, char decimal_point, std::string & grouping)
634  {
635  	std::ostringstream stream;
636  	auto int_part = balance / scale;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    