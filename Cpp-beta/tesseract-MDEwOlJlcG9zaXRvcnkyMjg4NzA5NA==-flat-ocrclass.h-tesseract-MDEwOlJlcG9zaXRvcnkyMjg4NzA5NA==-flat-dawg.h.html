
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 19.52861952861953%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrclass.h</h3>
            <pre><code>1  #ifndef CCUTIL_OCRCLASS_H_
2  #define CCUTIL_OCRCLASS_H_
3  #include <chrono>
4  #include <ctime>
5  namespace tesseract {
6  struct EANYCODE_CHAR { &bsol;*single character */
7    uint16_t char_code; &bsol;*character itself */
8    int16_t left;       &bsol;*of char (-1) */
9    int16_t right;      &bsol;*of char (-1) */
10    int16_t top;        &bsol;*of char (-1) */
11    int16_t bottom;     &bsol;*of char (-1) */
12    int16_t font_index; &bsol;*what font (0) */
13    uint8_t confidence; &bsol;*0=perfect, 100=reject (0/100) */
14    uint8_t point_size; &bsol;*of char, 72=i inch, (10) */
15    int8_t blanks;      &bsol;*no of spaces before this char (1) */
16    uint8_t formatting; &bsol;*char formatting (0) */
<span onclick='openModal()' class='match'>17  };
18  class ETEXT_DESC;
19  using CANCEL_FUNC = bool (*)(void *, int);
20  using PROGRESS_FUNC = bool (*)(int, int, int, int, int);
21  using PROGRESS_FUNC2 = bool (*)(ETEXT_DESC *, int, int, int, int);
</span>22  class ETEXT_DESC { 
23  public:
24    int16_t count{0};    
25    int16_t progress{0}; 
26    int8_t more_to_come{0};       
27    volatile int8_t ocr_alive{0}; 
28    int8_t err_code{0};           
29    CANCEL_FUNC cancel{nullptr};  
30    PROGRESS_FUNC progress_callback{
31        nullptr};                      
32    PROGRESS_FUNC2 progress_callback2; 
33    void *cancel_this{nullptr};        
34    std::chrono::steady_clock::time_point end_time;
35    EANYCODE_CHAR text[1]{}; 
36    ETEXT_DESC() : progress_callback2(&default_progress_func) {
37      end_time = std::chrono::time_point<std::chrono::steady_clock,
38                                         std::chrono::milliseconds>();
39    }
40    void set_deadline_msecs(int32_t deadline_msecs) {
41      if (deadline_msecs > 0) {
42        end_time = std::chrono::steady_clock::now() +
43                   std::chrono::milliseconds(deadline_msecs);
44      }
45    }
46    bool deadline_exceeded() const {
47      if (end_time.time_since_epoch() ==
48          std::chrono::steady_clock::duration::zero()) {
49        return false;
50      }
51      auto now = std::chrono::steady_clock::now();
52      return (now > end_time);
53    }
54  private:
55    static bool default_progress_func(ETEXT_DESC *ths, int left, int right,
56                                      int top, int bottom) {
57      if (ths->progress_callback != nullptr) {
58        return (*(ths->progress_callback))(ths->progress, left, right, top,
59                                           bottom);
60      }
61      return true;
62    }
63  };
64  } 
65  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dawg.h</h3>
            <pre><code>1  #ifndef DICT_DAWG_H_
2  #define DICT_DAWG_H_
3  #include <cinttypes>  
4  #include <functional> 
5  #include <memory>
6  #include "elst.h"
7  #include "params.h"
8  #include "ratngs.h"
9  #ifndef __GNUC__
10  #  ifdef _WIN32
11  #    define NO_EDGE (int64_t)0xffffffffffffffffi64
12  #  endif &bsol;*_WIN32*/
13  #else
14  #  define NO_EDGE (int64_t)0xffffffffffffffffll
15  #endif &bsol;*__GNUC__*/
16  namespace tesseract {
17  class UNICHARSET;
18  using EDGE_RECORD = uint64_t;
19  using EDGE_ARRAY = EDGE_RECORD *;
20  using EDGE_REF = int64_t;
21  using NODE_REF = int64_t;
22  using NODE_MAP = EDGE_REF *;
23  struct NodeChild {
24    UNICHAR_ID unichar_id;
25    EDGE_REF edge_ref;
26    NodeChild(UNICHAR_ID id, EDGE_REF ref) : unichar_id(id), edge_ref(ref) {}
27    NodeChild() : unichar_id(INVALID_UNICHAR_ID), edge_ref(NO_EDGE) {}
28  };
29  using NodeChildVector = std::vector<NodeChild>;
30  using SuccessorList = std::vector<int>;
31  using SuccessorListsVector = std::vector<SuccessorList *>;
32  enum DawgType {
33    DAWG_TYPE_PUNCTUATION,
34    DAWG_TYPE_WORD,
35    DAWG_TYPE_NUMBER,
36    DAWG_TYPE_PATTERN,
37    DAWG_TYPE_COUNT 
38  };
39  #define FORWARD_EDGE (int32_t)0
40  #define BACKWARD_EDGE (int32_t)1
41  #define MAX_NODE_EDGES_DISPLAY (int64_t)100
42  #define MARKER_FLAG (int64_t)1
43  #define DIRECTION_FLAG (int64_t)2
44  #define WERD_END_FLAG (int64_t)4
45  #define LETTER_START_BIT 0
46  #define NUM_FLAG_BITS 3
47  #define REFFORMAT "%" PRId64
48  static const bool kDawgSuccessors[DAWG_TYPE_COUNT][DAWG_TYPE_COUNT] = {
49      {false, true, true, false},   
50      {true, false, false, false},  
51      {true, false, false, false},  
52      {false, false, false, false}, 
53  };
54  static const char kWildcard[] = "*";
55  class TESS_API Dawg {
56  public:
57    static const int16_t kDawgMagicNumber = 42;
58    static const UNICHAR_ID kPatternUnicharID = 0;
59    inline DawgType type() const {
60      return type_;
61    }
62    inline const std::string &lang() const {
63      return lang_;
64    }
65    inline PermuterType permuter() const {
66      return perm_;
67    }
68    virtual ~Dawg();
69    bool word_in_dawg(const WERD_CHOICE &word) const;
70    bool prefix_in_dawg(const WERD_CHOICE &prefix, bool requires_complete) const;
71    int check_for_words(const char *filename, const UNICHARSET &unicharset,
72                        bool enable_wildcard) const;
73    void iterate_words(const UNICHARSET &unicharset,
74                       std::function<void(const WERD_CHOICE *)> cb) const;
75    void iterate_words(const UNICHARSET &unicharset,
76                       const std::function<void(const char *)> &cb) const;
77    virtual EDGE_REF edge_char_of(NODE_REF node, UNICHAR_ID unichar_id,
78                                  bool word_end) const = 0;
79    virtual void unichar_ids_of(NODE_REF node, NodeChildVector *vec,
80                                bool word_end) const = 0;
81    virtual NODE_REF next_node(EDGE_REF edge_ref) const = 0;
82    virtual bool end_of_word(EDGE_REF edge_ref) const = 0;
83    virtual UNICHAR_ID edge_letter(EDGE_REF edge_ref) const = 0;
84    virtual void print_node(NODE_REF node, int max_num_edges) const = 0;
85    virtual void unichar_id_to_patterns(UNICHAR_ID unichar_id,
86                                        const UNICHARSET &unicharset,
87                                        std::vector<UNICHAR_ID> *vec) const {
88      (void)unichar_id;
89      (void)unicharset;
90      (void)vec;
91    }
92    virtual EDGE_REF pattern_loop_edge(EDGE_REF edge_ref, UNICHAR_ID unichar_id,
93                                       bool word_end) const {
94      (void)edge_ref;
95      (void)unichar_id;
96      (void)word_end;
97      return false;
98    }
99  protected:
100    Dawg(DawgType type, const std::string &lang, PermuterType perm,
101         int debug_level)
102        : lang_(lang),
103          type_(type),
104          perm_(perm),
105          unicharset_size_(0),
106          debug_level_(debug_level) {}
107    inline NODE_REF next_node_from_edge_rec(const EDGE_RECORD &edge_rec) const {
108      return ((edge_rec & next_node_mask_) >> next_node_start_bit_);
109    }
110    inline bool marker_flag_from_edge_rec(const EDGE_RECORD &edge_rec) const {
111      return (edge_rec & (MARKER_FLAG << flag_start_bit_)) != 0;
112    }
113    inline int direction_from_edge_rec(const EDGE_RECORD &edge_rec) const {
114      return ((edge_rec & (DIRECTION_FLAG << flag_start_bit_))) ? BACKWARD_EDGE
115                                                                : FORWARD_EDGE;
116    }
117    inline bool end_of_word_from_edge_rec(const EDGE_RECORD &edge_rec) const {
118      return (edge_rec & (WERD_END_FLAG << flag_start_bit_)) != 0;
119    }
120    inline UNICHAR_ID unichar_id_from_edge_rec(
121        const EDGE_RECORD &edge_rec) const {
122      return ((edge_rec & letter_mask_) >> LETTER_START_BIT);
123    }
124    inline void set_next_node_in_edge_rec(EDGE_RECORD *edge_rec, EDGE_REF value) {
125      *edge_rec &= (~next_node_mask_);
126      *edge_rec |= ((value << next_node_start_bit_) & next_node_mask_);
127    }
128    inline void set_marker_flag_in_edge_rec(EDGE_RECORD *edge_rec) {
129      *edge_rec |= (MARKER_FLAG << flag_start_bit_);
130    }
131    inline int given_greater_than_edge_rec(NODE_REF next_node, bool word_end,
132                                           UNICHAR_ID unichar_id,
133                                           const EDGE_RECORD &edge_rec) const {
134      UNICHAR_ID curr_unichar_id = unichar_id_from_edge_rec(edge_rec);
135      NODE_REF curr_next_node = next_node_from_edge_rec(edge_rec);
136      bool curr_word_end = end_of_word_from_edge_rec(edge_rec);
137      if (edge_rec_match(next_node, word_end, unichar_id, curr_next_node,
138                         curr_word_end, curr_unichar_id)) {
139        return 0;
140      }
141      if (unichar_id > curr_unichar_id) {
142        return 1;
143      }
144      if (unichar_id == curr_unichar_id) {
145        if (next_node > curr_next_node) {
146          return 1;
147        }
148        if (next_node == curr_next_node) {
149          if (word_end > curr_word_end) {
150            return 1;
151          }
152        }
153      }
154      return -1;
155    }
156    inline bool edge_rec_match(NODE_REF next_node, bool word_end,
157                               UNICHAR_ID unichar_id, NODE_REF other_next_node,
158                               bool other_word_end,
159                               UNICHAR_ID other_unichar_id) const {
160      return ((unichar_id == other_unichar_id) &&
161              (next_node == NO_EDGE || next_node == other_next_node) &&
162              (!word_end || (word_end == other_word_end)));
<span onclick='openModal()' class='match'>163    }
164    void init(int unicharset_size);
165    bool match_words(WERD_CHOICE *word, uint32_t index, NODE_REF node,
166                     UNICHAR_ID wildcard) const;
167    void iterate_words_rec(
168        const WERD_CHOICE &word_so_far, NODE_REF to_explore,
169        const std::function<void(const WERD_CHOICE *)> &cb) const;
170    std::string lang_;
171    DawgType type_;
172    PermuterType perm_;
</span>173    uint64_t next_node_mask_ = 0;
174    uint64_t flags_mask_ = 0;
175    uint64_t letter_mask_ = 0;
176    int unicharset_size_;
177    int flag_start_bit_ = 0;
178    int next_node_start_bit_ = 0;
179    int debug_level_;
180  };
181  struct DawgPosition {
182    DawgPosition() = default;
183    DawgPosition(int dawg_idx, EDGE_REF dawgref, int punc_idx, EDGE_REF puncref,
184                 bool backtopunc)
185        : dawg_ref(dawgref),
186          punc_ref(puncref),
187          dawg_index(dawg_idx),
188          punc_index(punc_idx),
189          back_to_punc(backtopunc) {}
190    bool operator==(const DawgPosition &other) const {
191      return dawg_index == other.dawg_index && dawg_ref == other.dawg_ref &&
192             punc_index == other.punc_index && punc_ref == other.punc_ref &&
193             back_to_punc == other.back_to_punc;
194    }
195    EDGE_REF dawg_ref = NO_EDGE;
196    EDGE_REF punc_ref = NO_EDGE;
197    int8_t dawg_index = -1;
198    int8_t punc_index = -1;
199    bool back_to_punc = false;
200  };
201  class DawgPositionVector : public std::vector<DawgPosition> {
202  public:
203    inline bool add_unique(const DawgPosition &new_pos, bool debug,
204                           const char *debug_msg) {
205      for (auto &&position : *this) {
206        if (position == new_pos) {
207          return false;
208        }
209      }
210      push_back(new_pos);
211      if (debug) {
212        tprintf("%s[%d, " REFFORMAT "] [punc: " REFFORMAT "%s]\n", debug_msg,
213                new_pos.dawg_index, new_pos.dawg_ref, new_pos.punc_ref,
214                new_pos.back_to_punc ? " returned" : "");
215      }
216      return true;
217    }
218  };
219  class TESS_API SquishedDawg : public Dawg {
220  public:
221    SquishedDawg(DawgType type, const std::string &lang, PermuterType perm,
222                 int debug_level)
223        : Dawg(type, lang, perm, debug_level) {}
224    SquishedDawg(const char *filename, DawgType type, const std::string &lang,
225                 PermuterType perm, int debug_level)
226        : Dawg(type, lang, perm, debug_level) {
227      TFile file;
228      ASSERT_HOST(file.Open(filename, nullptr));
229      ASSERT_HOST(read_squished_dawg(&file));
230      num_forward_edges_in_node0 = num_forward_edges(0);
231    }
232    SquishedDawg(EDGE_ARRAY edges, int num_edges, DawgType type,
233                 const std::string &lang, PermuterType perm, int unicharset_size,
234                 int debug_level)
235        : Dawg(type, lang, perm, debug_level),
236          edges_(edges),
237          num_edges_(num_edges) {
238      init(unicharset_size);
239      num_forward_edges_in_node0 = num_forward_edges(0);
240      if (debug_level > 3) {
241        print_all("SquishedDawg:");
242      }
243    }
244    ~SquishedDawg() override;
245    bool Load(TFile *fp) {
246      if (!read_squished_dawg(fp)) {
247        return false;
248      }
249      num_forward_edges_in_node0 = num_forward_edges(0);
250      return true;
251    }
252    int NumEdges() {
253      return num_edges_;
254    }
255    EDGE_REF edge_char_of(NODE_REF node, UNICHAR_ID unichar_id,
256                          bool word_end) const override;
257    void unichar_ids_of(NODE_REF node, NodeChildVector *vec,
258                        bool word_end) const override {
259      EDGE_REF edge = node;
260      if (!edge_occupied(edge) || edge == NO_EDGE) {
261        return;
262      }
263      assert(forward_edge(edge)); 
264      do {                        
265        if (!word_end || end_of_word_from_edge_rec(edges_[edge])) {
266          vec->push_back(NodeChild(unichar_id_from_edge_rec(edges_[edge]), edge));
267        }
268      } while (!last_edge(edge++));
269    }
270    NODE_REF next_node(EDGE_REF edge) const override {
271      return next_node_from_edge_rec((edges_[edge]));
272    }
273    bool end_of_word(EDGE_REF edge_ref) const override {
274      return end_of_word_from_edge_rec((edges_[edge_ref]));
275    }
276    UNICHAR_ID edge_letter(EDGE_REF edge_ref) const override {
277      return unichar_id_from_edge_rec((edges_[edge_ref]));
278    }
279    void print_node(NODE_REF node, int max_num_edges) const override;
280    bool write_squished_dawg(TFile *file);
281    bool write_squished_dawg(const char *filename) {
282      TFile file;
283      file.OpenWrite(nullptr);
284      if (!this->write_squished_dawg(&file)) {
285        tprintf("Error serializing %s\n", filename);
286        return false;
287      }
288      if (!file.CloseWrite(filename, nullptr)) {
289        tprintf("Error writing file %s\n", filename);
290        return false;
291      }
292      return true;
293    }
294  private:
295    inline void set_next_node(EDGE_REF edge_ref, EDGE_REF value) {
296      set_next_node_in_edge_rec(&(edges_[edge_ref]), value);
297    }
298    inline void set_empty_edge(EDGE_REF edge_ref) {
299      (edges_[edge_ref] = next_node_mask_);
300    }
301    inline void clear_all_edges() {
302      for (int edge = 0; edge < num_edges_; edge++) {
303        set_empty_edge(edge);
304      }
305    }
306    inline void clear_marker_flag(EDGE_REF edge_ref) {
307      (edges_[edge_ref] &= ~(MARKER_FLAG << flag_start_bit_));
308    }
309    inline bool forward_edge(EDGE_REF edge_ref) const {
310      return (edge_occupied(edge_ref) &&
311              (FORWARD_EDGE == direction_from_edge_rec(edges_[edge_ref])));
312    }
313    inline bool backward_edge(EDGE_REF edge_ref) const {
314      return (edge_occupied(edge_ref) &&
315              (BACKWARD_EDGE == direction_from_edge_rec(edges_[edge_ref])));
316    }
317    inline bool edge_occupied(EDGE_REF edge_ref) const {
318      return (edges_[edge_ref] != next_node_mask_);
319    }
320    inline bool last_edge(EDGE_REF edge_ref) const {
321      return (edges_[edge_ref] & (MARKER_FLAG << flag_start_bit_)) != 0;
322    }
323    int32_t num_forward_edges(NODE_REF node) const;
324    bool read_squished_dawg(TFile *file);
325    void print_edge(EDGE_REF edge) const;
326    void print_all(const char *msg) {
327      tprintf("\n__________________________\n%s\n", msg);
328      for (int i = 0; i < num_edges_; ++i) {
329        print_edge(i);
330      }
331      tprintf("__________________________\n");
332    }
333    std::unique_ptr<EDGE_REF[]> build_node_map(int32_t *num_nodes) const;
334    EDGE_ARRAY edges_ = nullptr;
335    int32_t num_edges_ = 0;
336    int num_forward_edges_in_node0 = 0;
337  };
338  } 
339  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrclass.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-dawg.h</div>
                </div>
                <div class="column column_space"><pre><code>17  };
18  class ETEXT_DESC;
19  using CANCEL_FUNC = bool (*)(void *, int);
20  using PROGRESS_FUNC = bool (*)(int, int, int, int, int);
21  using PROGRESS_FUNC2 = bool (*)(ETEXT_DESC *, int, int, int, int);
</pre></code></div>
                <div class="column column_space"><pre><code>163    }
164    void init(int unicharset_size);
165    bool match_words(WERD_CHOICE *word, uint32_t index, NODE_REF node,
166                     UNICHAR_ID wildcard) const;
167    void iterate_words_rec(
168        const WERD_CHOICE &word_so_far, NODE_REF to_explore,
169        const std::function<void(const WERD_CHOICE *)> &cb) const;
170    std::string lang_;
171    DawgType type_;
172    PermuterType perm_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    