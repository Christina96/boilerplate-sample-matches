
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.964216900633085%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-network.cpp</h3>
            <pre><code>1  #include <nano/node/network.hpp>
2  #include <nano/node/nodeconfig.hpp>
3  #include <nano/node/scheduler/buckets.hpp>
4  #include <nano/node/scheduler/component.hpp>
5  #include <nano/node/transport/inproc.hpp>
6  #include <nano/node/transport/socket.hpp>
7  #include <nano/test_common/network.hpp>
8  #include <nano/test_common/system.hpp>
9  #include <nano/test_common/testutil.hpp>
10  #include <gtest/gtest.h>
11  #include <boost/iostreams/stream_buffer.hpp>
12  #include <boost/range/join.hpp>
13  #include <boost/thread.hpp>
14  using namespace std::chrono_literals;
15  TEST (network, tcp_connection)
16  {
17  	nano::test::system system;
18  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
19  	auto port = system.get_available_port ();
20  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v4::any (), port);
21  	acceptor.open (endpoint.protocol ());
22  	acceptor.set_option (boost::asio::ip::tcp::acceptor::reuse_address (true));
23  	acceptor.bind (endpoint);
24  	acceptor.listen ();
25  	boost::asio::ip::tcp::socket incoming (system.io_ctx);
26  	std::atomic<bool> done1 (false);
27  	std::string message1;
28  	acceptor.async_accept (incoming, [&done1, &message1] (boost::system::error_code const & ec_a) {
29  		if (ec_a)
30  		{
31  			message1 = ec_a.message ();
32  			std::cerr << message1;
33  		}
34  		done1 = true;
35  	});
36  	boost::asio::ip::tcp::socket connector (system.io_ctx);
37  	std::atomic<bool> done2 (false);
38  	std::string message2;
39  	connector.async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v4::loopback (), acceptor.local_endpoint ().port ()),
40  	[&done2, &message2] (boost::system::error_code const & ec_a) {
41  		if (ec_a)
42  		{
43  			message2 = ec_a.message ();
44  			std::cerr << message2;
45  		}
46  		done2 = true;
47  	});
48  	ASSERT_TIMELY (5s, done1 && done2);
49  	ASSERT_EQ (0, message1.size ());
50  	ASSERT_EQ (0, message2.size ());
51  }
52  TEST (network, construction_with_specified_port)
53  {
54  	nano::test::system system{};
55  	auto const port = system.get_available_port (&bsol;* do not allow 0 port */ false);
56  	auto const node = system.add_node (nano::node_config{ port, system.logging });
57  	EXPECT_EQ (port, node->network.port);
58  	EXPECT_EQ (port, node->network.endpoint ().port ());
59  	EXPECT_EQ (port, node->tcp_listener.endpoint ().port ());
60  }
61  TEST (network, construction_without_specified_port)
62  {
63  	nano::test::system system{};
64  	auto const node = system.add_node ();
65  	auto const port = node->network.port.load ();
66  	EXPECT_NE (0, port);
67  	EXPECT_EQ (port, node->network.endpoint ().port ());
68  	EXPECT_EQ (port, node->tcp_listener.endpoint ().port ());
69  }
70  TEST (network, send_node_id_handshake_tcp)
71  {
72  	nano::test::system system (1);
73  	auto node0 (system.nodes[0]);
74  	ASSERT_EQ (0, node0->network.size ());
75  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
76  	node1->start ();
77  	system.nodes.push_back (node1);
78  	auto initial (node0->stats.count (nano::stat::type::message, nano::stat::detail::node_id_handshake, nano::stat::dir::in));
79  	auto initial_node1 (node1->stats.count (nano::stat::type::message, nano::stat::detail::node_id_handshake, nano::stat::dir::in));
80  	auto initial_keepalive (node0->stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in));
81  	std::weak_ptr<nano::node> node_w (node0);
82  	node0->network.tcp_channels.start_tcp (node1->network.endpoint ());
83  	ASSERT_EQ (0, node0->network.size ());
84  	ASSERT_EQ (0, node1->network.size ());
85  	ASSERT_TIMELY (10s, node0->stats.count (nano::stat::type::message, nano::stat::detail::node_id_handshake, nano::stat::dir::in) >= initial + 2);
86  	ASSERT_TIMELY (5s, node1->stats.count (nano::stat::type::message, nano::stat::detail::node_id_handshake, nano::stat::dir::in) >= initial_node1 + 2);
87  	ASSERT_TIMELY (5s, node0->stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in) >= initial_keepalive + 2);
88  	ASSERT_TIMELY (5s, node1->stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in) >= initial_keepalive + 2);
89  	ASSERT_EQ (1, node0->network.size ());
90  	ASSERT_EQ (1, node1->network.size ());
91  	auto list1 (node0->network.list (1));
92  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
93  	ASSERT_EQ (node1->get_node_id (), list1[0]->get_node_id ());
94  	auto list2 (node1->network.list (1));
95  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
96  	ASSERT_EQ (node0->get_node_id (), list2[0]->get_node_id ());
97  	node1->stop ();
98  }
99  TEST (network, last_contacted)
100  {
101  	nano::test::system system (1);
102  	auto node0 = system.nodes[0];
103  	ASSERT_EQ (0, node0->network.size ());
104  	nano::node_config node1_config = system.default_config ();
105  	node1_config.tcp_incoming_connections_max = 0; 
106  	auto node1 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), node1_config, system.work));
107  	node1->start ();
108  	system.nodes.push_back (node1);
109  	auto channel1 = nano::test::establish_tcp (system, *node1, node0->network.endpoint ());
110  	ASSERT_NE (nullptr, channel1);
111  	ASSERT_TIMELY (3s, node0->network.size () == 1);
112  	auto channel0 = node0->network.tcp_channels.find_node_id (node1->node_id.pub);
113  	ASSERT_NE (nullptr, channel0);
114  	{
115  		std::shared_ptr<nano::transport::socket> sock0 = channel0->socket.lock ();
116  		std::shared_ptr<nano::transport::socket> sock1 = channel1->socket.lock ();
117  		ASSERT_TRUE (sock0->local_endpoint () == sock1->remote_endpoint ());
118  		ASSERT_TRUE (sock1->local_endpoint () == sock0->remote_endpoint ());
119  	}
120  	auto timestamp_before_keepalive = channel0->get_last_packet_received ();
121  	auto keepalive_count = node0->stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in);
122  	ASSERT_TIMELY (3s, std::chrono::steady_clock::now () > timestamp_before_keepalive);
123  	node1->network.send_keepalive (channel1);
124  	node1->network.send_keepalive (channel1);
125  	node1->network.send_keepalive (channel1);
126  	ASSERT_TIMELY (3s, node0->stats.count (nano::stat::type::message, nano::stat::detail::keepalive, nano::stat::dir::in) >= keepalive_count + 3);
127  	ASSERT_EQ (node0->network.size (), 1);
128  	auto timestamp_after_keepalive = channel0->get_last_packet_received ();
129  	ASSERT_GT (timestamp_after_keepalive, timestamp_before_keepalive);
130  }
131  TEST (network, multi_keepalive)
132  {
133  	nano::test::system system (1);
134  	auto node0 = system.nodes[0];
135  	ASSERT_EQ (0, node0->network.size ());
136  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
137  	ASSERT_FALSE (node1->init_error ());
138  	node1->start ();
139  	system.nodes.push_back (node1);
140  	ASSERT_EQ (0, node1->network.size ());
141  	ASSERT_EQ (0, node0->network.size ());
142  	node1->network.tcp_channels.start_tcp (node0->network.endpoint ());
143  	ASSERT_TIMELY (10s, node0->network.size () == 1 && node0->stats.count (nano::stat::type::message, nano::stat::detail::keepalive) >= 1);
144  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
145  	ASSERT_FALSE (node2->init_error ());
146  	node2->start ();
147  	system.nodes.push_back (node2);
148  	node2->network.tcp_channels.start_tcp (node0->network.endpoint ());
149  	ASSERT_TIMELY (10s, node1->network.size () == 2 && node0->network.size () == 2 && node2->network.size () == 2 && node0->stats.count (nano::stat::type::message, nano::stat::detail::keepalive) >= 2);
150  }
151  TEST (network, send_discarded_publish)
152  {
153  	nano::test::system system (2);
154  	auto & node1 (*system.nodes[0]);
155  	auto & node2 (*system.nodes[1]);
156  	nano::block_builder builder;
157  	auto block = builder
158  				 .send ()
159  				 .previous (1)
160  				 .destination (1)
161  				 .balance (2)
162  				 .sign (nano::keypair ().prv, 4)
163  				 .work (*system.work.generate (nano::root (1)))
164  				 .build_shared ();
165  	{
166  		auto transaction (node1.store.tx_begin_read ());
167  		node1.network.flood_block (block);
168  		ASSERT_EQ (nano::dev::genesis->hash (), node1.ledger.latest (transaction, nano::dev::genesis_key.pub));
169  		ASSERT_EQ (nano::dev::genesis->hash (), node2.latest (nano::dev::genesis_key.pub));
170  	}
171  	ASSERT_TIMELY (10s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) != 0);
172  	auto transaction (node1.store.tx_begin_read ());
173  	ASSERT_EQ (nano::dev::genesis->hash (), node1.ledger.latest (transaction, nano::dev::genesis_key.pub));
174  	ASSERT_EQ (nano::dev::genesis->hash (), node2.latest (nano::dev::genesis_key.pub));
175  }
176  TEST (network, send_invalid_publish)
177  {
178  	nano::test::system system (2);
179  	auto & node1 (*system.nodes[0]);
180  	auto & node2 (*system.nodes[1]);
181  	nano::block_builder builder;
182  	auto block = builder
183  				 .send ()
184  				 .previous (1)
185  				 .destination (1)
186  				 .balance (20)
187  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
188  				 .work (*system.work.generate (nano::root (1)))
189  				 .build_shared ();
190  	{
191  		auto transaction (node1.store.tx_begin_read ());
192  		node1.network.flood_block (block);
193  		ASSERT_EQ (nano::dev::genesis->hash (), node1.ledger.latest (transaction, nano::dev::genesis_key.pub));
194  		ASSERT_EQ (nano::dev::genesis->hash (), node2.latest (nano::dev::genesis_key.pub));
195  	}
196  	ASSERT_TIMELY (10s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) != 0);
197  	auto transaction (node1.store.tx_begin_read ());
198  	ASSERT_EQ (nano::dev::genesis->hash (), node1.ledger.latest (transaction, nano::dev::genesis_key.pub));
199  	ASSERT_EQ (nano::dev::genesis->hash (), node2.latest (nano::dev::genesis_key.pub));
200  }
201  TEST (network, send_valid_confirm_ack)
202  {
203  	auto type = nano::transport::transport_type::tcp;
204  	nano::node_flags node_flags;
205  	nano::test::system system (2, type, node_flags);
206  	auto & node1 (*system.nodes[0]);
207  	auto & node2 (*system.nodes[1]);
208  	nano::keypair key2;
209  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
210  	system.wallet (1)->insert_adhoc (key2.prv);
211  	nano::block_hash latest1 (node1.latest (nano::dev::genesis_key.pub));
212  	nano::block_builder builder;
213  	auto block2 = builder
214  				  .send ()
215  				  .previous (latest1)
216  				  .destination (key2.pub)
217  				  .balance (50)
218  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
219  				  .work (*system.work.generate (latest1))
220  				  .build ();
221  	nano::block_hash latest2 (node2.latest (nano::dev::genesis_key.pub));
222  	node1.process_active (std::make_shared<nano::send_block> (*block2));
223  	ASSERT_TIMELY (10s, node2.latest (nano::dev::genesis_key.pub) != latest2);
224  	ASSERT_EQ (50, node2.balance (nano::dev::genesis_key.pub));
225  }
226  TEST (network, send_valid_publish)
227  {
228  	auto type = nano::transport::transport_type::tcp;
229  	nano::node_flags node_flags;
230  	nano::test::system system (2, type, node_flags);
231  	auto & node1 (*system.nodes[0]);
232  	auto & node2 (*system.nodes[1]);
233  	node1.bootstrap_initiator.stop ();
234  	node2.bootstrap_initiator.stop ();
235  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
236  	nano::keypair key2;
237  	system.wallet (1)->insert_adhoc (key2.prv);
238  	nano::block_hash latest1 (node1.latest (nano::dev::genesis_key.pub));
239  	nano::block_builder builder;
240  	auto block2 = builder
241  				  .send ()
242  				  .previous (latest1)
243  				  .destination (key2.pub)
244  				  .balance (50)
245  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
246  				  .work (*system.work.generate (latest1))
247  				  .build ();
248  	auto hash2 (block2->hash ());
249  	nano::block_hash latest2 (node2.latest (nano::dev::genesis_key.pub));
250  	node2.process_active (std::make_shared<nano::send_block> (*block2));
251  	ASSERT_TIMELY (10s, node1.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) != 0);
252  	ASSERT_NE (hash2, latest2);
253  	ASSERT_TIMELY (10s, node2.latest (nano::dev::genesis_key.pub) != latest2);
254  	ASSERT_EQ (50, node2.balance (nano::dev::genesis_key.pub));
255  }
256  TEST (network, send_insufficient_work)
257  {
258  	nano::test::system system (2);
259  	auto & node1 = *system.nodes[0];
260  	auto & node2 = *system.nodes[1];
261  	nano::block_builder builder;
262  	auto block1 = builder
263  				  .send ()
264  				  .previous (0)
265  				  .destination (1)
266  				  .balance (20)
267  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
268  				  .work (0)
269  				  .build_shared ();
270  	nano::publish publish1{ nano::dev::network_params.network, block1 };
271  	auto tcp_channel (node1.network.tcp_channels.find_node_id (node2.get_node_id ()));
272  	ASSERT_NE (nullptr, tcp_channel);
273  	tcp_channel->send (publish1, [] (boost::system::error_code const & ec, size_t size) {});
274  	ASSERT_EQ (0, node1.stats.count (nano::stat::type::error, nano::stat::detail::insufficient_work));
275  	ASSERT_TIMELY (10s, node2.stats.count (nano::stat::type::error, nano::stat::detail::insufficient_work) != 0);
276  	ASSERT_EQ (1, node2.stats.count (nano::stat::type::error, nano::stat::detail::insufficient_work));
277  	auto block2 = builder
278  				  .send ()
279  				  .previous (block1->hash ())
280  				  .destination (1)
281  				  .balance (20)
282  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
283  				  .work (system.work_generate_limited (block1->hash (), node1.network_params.work.epoch_2_receive, node1.network_params.work.epoch_1 - 1))
284  				  .build_shared ();
285  	nano::publish publish2{ nano::dev::network_params.network, block2 };
286  	tcp_channel->send (publish2, [] (boost::system::error_code const & ec, size_t size) {});
287  	ASSERT_TIMELY (10s, node2.stats.count (nano::stat::type::error, nano::stat::detail::insufficient_work) != 1);
288  	ASSERT_EQ (2, node2.stats.count (nano::stat::type::error, nano::stat::detail::insufficient_work));
289  	auto block3 = builder
290  				  .send ()
291  				  .previous (block2->hash ())
292  				  .destination (1)
293  				  .balance (20)
294  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
295  				  .work (*system.work.generate (block2->hash (), node1.network_params.work.epoch_2))
296  				  .build_shared ();
297  	nano::publish publish3{ nano::dev::network_params.network, block3 };
298  	tcp_channel->send (publish3, [] (boost::system::error_code const & ec, size_t size) {});
299  	ASSERT_EQ (0, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in));
300  	ASSERT_TIMELY (10s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) != 0);
301  	ASSERT_EQ (1, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in));
302  	auto block4 = builder
303  				  .state ()
304  				  .account (nano::dev::genesis_key.pub)
305  				  .previous (block1->hash ())
306  				  .representative (nano::dev::genesis_key.pub)
307  				  .balance (20)
308  				  .link (1)
309  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
310  				  .work (system.work_generate_limited (block1->hash (), node1.network_params.work.epoch_2_receive, node1.network_params.work.epoch_1 - 1))
311  				  .build_shared ();
312  	nano::publish publish4{ nano::dev::network_params.network, block4 };
313  	tcp_channel->send (publish4, [] (boost::system::error_code const & ec, size_t size) {});
314  	ASSERT_TIMELY (10s, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in) != 0);
315  	ASSERT_EQ (1, node2.stats.count (nano::stat::type::message, nano::stat::detail::publish, nano::stat::dir::in));
316  	ASSERT_EQ (2, node2.stats.count (nano::stat::type::error, nano::stat::detail::insufficient_work));
317  }
318  TEST (receivable_processor, confirm_insufficient_pos)
319  {
320  	nano::test::system system (1);
321  	auto & node1 (*system.nodes[0]);
322  	nano::block_builder builder;
323  	auto block1 = builder
324  				  .send ()
325  				  .previous (nano::dev::genesis->hash ())
326  				  .destination (0)
327  				  .balance (0)
328  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
329  				  .work (0)
330  				  .build_shared ();
331  	node1.work_generate_blocking (*block1);
332  	ASSERT_EQ (nano::process_result::progress, node1.process (*block1).code);
333  	node1.scheduler.buckets.activate (nano::dev::genesis_key.pub, node1.store.tx_begin_read ());
334  	nano::keypair key1;
335  	auto vote (std::make_shared<nano::vote> (key1.pub, key1.prv, 0, 0, std::vector<nano::block_hash>{ block1->hash () }));
336  	nano::confirm_ack con1{ nano::dev::network_params.network, vote };
337  	auto channel1 = std::make_shared<nano::transport::inproc::channel> (node1, node1);
338  	node1.network.inbound (con1, channel1);
339  }
340  TEST (receivable_processor, confirm_sufficient_pos)
341  {
342  	nano::test::system system (1);
343  	auto & node1 (*system.nodes[0]);
344  	nano::block_builder builder;
345  	auto block1 = builder
346  				  .send ()
347  				  .previous (nano::dev::genesis->hash ())
348  				  .destination (0)
349  				  .balance (0)
350  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
351  				  .work (0)
352  				  .build_shared ();
353  	node1.work_generate_blocking (*block1);
354  	ASSERT_EQ (nano::process_result::progress, node1.process (*block1).code);
355  	node1.scheduler.buckets.activate (nano::dev::genesis_key.pub, node1.store.tx_begin_read ());
356  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ block1->hash () }));
357  	nano::confirm_ack con1{ nano::dev::network_params.network, vote };
358  	auto channel1 = std::make_shared<nano::transport::inproc::channel> (node1, node1);
359  	node1.network.inbound (con1, channel1);
360  }
361  TEST (receivable_processor, send_with_receive)
362  {
363  	auto type = nano::transport::transport_type::tcp;
364  	nano::node_flags node_flags;
365  	nano::test::system system (2, type, node_flags);
366  	auto & node1 (*system.nodes[0]);
367  	auto & node2 (*system.nodes[1]);
368  	auto amount (std::numeric_limits<nano::uint128_t>::max ());
369  	nano::keypair key2;
370  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
371  	nano::block_hash latest1 (node1.latest (nano::dev::genesis_key.pub));
372  	system.wallet (1)->insert_adhoc (key2.prv);
373  	nano::block_builder builder;
374  	auto block1 = builder
375  				  .send ()
376  				  .previous (latest1)
377  				  .destination (key2.pub)
378  				  .balance (amount - node1.config.receive_minimum.number ())
379  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
380  				  .work (*system.work.generate (latest1))
381  				  .build_shared ();
382  	ASSERT_EQ (amount, node1.balance (nano::dev::genesis_key.pub));
383  	ASSERT_EQ (0, node1.balance (key2.pub));
384  	ASSERT_EQ (amount, node2.balance (nano::dev::genesis_key.pub));
385  	ASSERT_EQ (0, node2.balance (key2.pub));
386  	node1.process_active (block1);
387  	node1.block_processor.flush ();
388  	node2.process_active (block1);
389  	node2.block_processor.flush ();
390  	ASSERT_EQ (amount - node1.config.receive_minimum.number (), node1.balance (nano::dev::genesis_key.pub));
391  	ASSERT_EQ (0, node1.balance (key2.pub));
392  	ASSERT_EQ (amount - node1.config.receive_minimum.number (), node2.balance (nano::dev::genesis_key.pub));
393  	ASSERT_EQ (0, node2.balance (key2.pub));
394  	ASSERT_TIMELY (10s, node1.balance (key2.pub) == node1.config.receive_minimum.number () && node2.balance (key2.pub) == node1.config.receive_minimum.number ());
395  	ASSERT_EQ (amount - node1.config.receive_minimum.number (), node1.balance (nano::dev::genesis_key.pub));
396  	ASSERT_EQ (node1.config.receive_minimum.number (), node1.balance (key2.pub));
397  	ASSERT_EQ (amount - node1.config.receive_minimum.number (), node2.balance (nano::dev::genesis_key.pub));
398  	ASSERT_EQ (node1.config.receive_minimum.number (), node2.balance (key2.pub));
399  }
400  TEST (network, receive_weight_change)
401  {
402  	nano::test::system system (2);
403  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
404  	nano::keypair key2;
405  	system.wallet (1)->insert_adhoc (key2.prv);
406  	{
407  		auto transaction (system.nodes[1]->wallets.tx_begin_write ());
408  		system.wallet (1)->store.representative_set (transaction, key2.pub);
409  	}
410  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
411  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return node_a->weight (key2.pub) == system.nodes[0]->config.receive_minimum.number (); }));
412  }
413  TEST (parse_endpoint, valid)
414  {
415  	std::string string ("::1:24000");
416  	nano::endpoint endpoint;
417  	ASSERT_FALSE (nano::parse_endpoint (string, endpoint));
418  	ASSERT_EQ (boost::asio::ip::address_v6::loopback (), endpoint.address ());
419  	ASSERT_EQ (24000, endpoint.port ());
420  }
421  TEST (parse_endpoint, invalid_port)
422  {
423  	std::string string ("::1:24a00");
424  	nano::endpoint endpoint;
425  	ASSERT_TRUE (nano::parse_endpoint (string, endpoint));
426  }
427  TEST (parse_endpoint, invalid_address)
428  {
429  	std::string string ("::q:24000");
430  	nano::endpoint endpoint;
431  	ASSERT_TRUE (nano::parse_endpoint (string, endpoint));
432  }
433  TEST (parse_endpoint, no_address)
434  {
435  	std::string string (":24000");
436  	nano::endpoint endpoint;
437  	ASSERT_TRUE (nano::parse_endpoint (string, endpoint));
438  }
439  TEST (parse_endpoint, no_port)
440  {
441  	std::string string ("::1:");
442  	nano::endpoint endpoint;
443  	ASSERT_TRUE (nano::parse_endpoint (string, endpoint));
444  }
445  TEST (parse_endpoint, no_colon)
446  {
447  	std::string string ("::1");
448  	nano::endpoint endpoint;
449  	ASSERT_TRUE (nano::parse_endpoint (string, endpoint));
450  }
451  TEST (network, ipv6)
452  {
453  	boost::asio::ip::address_v6 address (boost::asio::ip::make_address_v6 ("::ffff:127.0.0.1"));
454  	ASSERT_TRUE (address.is_v4_mapped ());
455  	nano::endpoint endpoint1 (address, 16384);
456  	std::vector<uint8_t> bytes1;
457  	{
458  		nano::vectorstream stream (bytes1);
459  		nano::write (stream, address.to_bytes ());
460  	}
461  	ASSERT_EQ (16, bytes1.size ());
462  	for (auto i (bytes1.begin ()), n (bytes1.begin () + 10); i != n; ++i)
463  	{
464  		ASSERT_EQ (0, *i);
465  	}
466  	ASSERT_EQ (0xff, bytes1[10]);
467  	ASSERT_EQ (0xff, bytes1[11]);
468  	std::array<uint8_t, 16> bytes2;
469  	nano::bufferstream stream (bytes1.data (), bytes1.size ());
470  	auto error (nano::try_read (stream, bytes2));
471  	ASSERT_FALSE (error);
472  	nano::endpoint endpoint2 (boost::asio::ip::address_v6 (bytes2), 16384);
473  	ASSERT_EQ (endpoint1, endpoint2);
474  }
475  TEST (network, ipv6_from_ipv4)
476  {
477  	nano::endpoint endpoint1 (boost::asio::ip::address_v4::loopback (), 16000);
478  	ASSERT_TRUE (endpoint1.address ().is_v4 ());
479  	nano::endpoint endpoint2 (boost::asio::ip::address_v6::v4_mapped (endpoint1.address ().to_v4 ()), 16000);
480  	ASSERT_TRUE (endpoint2.address ().is_v6 ());
481  }
482  TEST (network, ipv6_bind_send_ipv4)
483  {
484  	nano::test::system system;
485  	nano::endpoint endpoint1 (boost::asio::ip::address_v6::any (), 0);
486  	nano::endpoint endpoint2 (boost::asio::ip::address_v4::any (), 0);
487  	std::array<uint8_t, 16> bytes1{};
488  	std::atomic<bool> finish1{ false };
489  	nano::endpoint endpoint3;
490  	boost::asio::ip::udp::socket socket1 (system.io_ctx, endpoint1);
491  	socket1.async_receive_from (boost::asio::buffer (bytes1.data (), bytes1.size ()), endpoint3, [&finish1] (boost::system::error_code const & error, size_t size_a) {
492  		ASSERT_FALSE (error);
493  		ASSERT_EQ (16, size_a);
494  		finish1 = true;
495  	});
496  	boost::asio::ip::udp::socket socket2 (system.io_ctx, endpoint2);
497  	nano::endpoint endpoint5 (boost::asio::ip::address_v4::loopback (), socket1.local_endpoint ().port ());
498  	nano::endpoint endpoint6 (boost::asio::ip::address_v6::v4_mapped (boost::asio::ip::address_v4::loopback ()), socket2.local_endpoint ().port ());
499  	socket2.async_send_to (boost::asio::buffer (std::array<uint8_t, 16>{}, 16), endpoint5, [] (boost::system::error_code const & error, size_t size_a) {
500  		ASSERT_FALSE (error);
501  		ASSERT_EQ (16, size_a);
502  	});
503  	auto iterations (0);
504  	ASSERT_TIMELY (5s, finish1);
505  	ASSERT_EQ (endpoint6, endpoint3);
506  	std::array<uint8_t, 16> bytes2;
507  	nano::endpoint endpoint4;
508  	socket2.async_receive_from (boost::asio::buffer (bytes2.data (), bytes2.size ()), endpoint4, [] (boost::system::error_code const & error, size_t size_a) {
509  		ASSERT_FALSE (!error);
510  		ASSERT_EQ (16, size_a);
511  	});
512  	socket1.async_send_to (boost::asio::buffer (std::array<uint8_t, 16>{}, 16), endpoint6, [] (boost::system::error_code const & error, size_t size_a) {
513  		ASSERT_FALSE (error);
514  		ASSERT_EQ (16, size_a);
515  	});
516  }
517  TEST (network, endpoint_bad_fd)
518  {
519  	nano::test::system system (1);
520  	system.nodes[0]->stop ();
521  	auto endpoint (system.nodes[0]->network.endpoint ());
522  	ASSERT_TRUE (endpoint.address ().is_loopback ());
523  	ASSERT_TIMELY (10s, system.nodes[0]->network.endpoint ().port () == 0);
524  }
525  TEST (network, reserved_address)
526  {
527  	nano::test::system system (1);
528  	ASSERT_TRUE (nano::transport::reserved_address (nano::endpoint (boost::asio::ip::make_address_v6 ("2001::"), 0)));
529  	ASSERT_FALSE (nano::transport::reserved_address (nano::endpoint (boost::asio::ip::make_address_v6 ("2001::"), 1)));
530  	nano::endpoint loopback (boost::asio::ip::make_address_v6 ("::1"), 1);
531  	ASSERT_FALSE (nano::transport::reserved_address (loopback));
532  	nano::endpoint private_network_peer (boost::asio::ip::make_address_v6 ("::ffff:10.0.0.0"), 1);
533  	ASSERT_TRUE (nano::transport::reserved_address (private_network_peer, false));
534  	ASSERT_FALSE (nano::transport::reserved_address (private_network_peer, true));
535  }
536  TEST (network, ipv6_bind_subnetwork)
537  {
538  	auto address1 (boost::asio::ip::make_address_v6 ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713"));
539  	auto subnet1 (boost::asio::ip::make_network_v6 (address1, 48));
540  	ASSERT_EQ (boost::asio::ip::make_address_v6 ("a41d:b7b2:8298::"), subnet1.network ());
541  	auto address1_subnet (nano::transport::ipv4_address_or_ipv6_subnet (address1));
542  	ASSERT_EQ (subnet1.network (), address1_subnet);
543  	auto address2 (boost::asio::ip::make_address_v6 ("::ffff:192.168.1.1"));
544  	auto address2_subnet (nano::transport::ipv4_address_or_ipv6_subnet (address2));
545  	ASSERT_EQ (address2, address2_subnet);
546  }
547  TEST (network, network_range_ipv6)
548  {
549  	auto address1 (boost::asio::ip::make_address_v6 ("a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713"));
550  	auto subnet1 (boost::asio::ip::make_network_v6 (address1, 58));
551  	ASSERT_EQ (boost::asio::ip::make_address_v6 ("a41d:b7b2:8298:cf40::"), subnet1.network ());
552  	auto address2 (boost::asio::ip::make_address_v6 ("520d:2402:3d:5e65:11:f8:7c54:3f"));
553  	auto subnet2 (boost::asio::ip::make_network_v6 (address2, 33));
554  	ASSERT_EQ (boost::asio::ip::make_address_v6 ("520d:2402:0::"), subnet2.network ());
555  	auto address3 (boost::asio::ip::make_address_v6 ("a719:0f12:536e:d88a:1331:ba53:4598:04e5"));
556  	auto subnet3 (boost::asio::ip::make_network_v6 (address3, 32));
557  	ASSERT_EQ (boost::asio::ip::make_address_v6 ("a719:0f12::"), subnet3.network ());
558  	auto address3_subnet (nano::transport::map_address_to_subnetwork (address3));
559  	ASSERT_EQ (subnet3.network (), address3_subnet);
560  }
561  TEST (network, network_range_ipv4)
562  {
563  	auto address1 (boost::asio::ip::make_address_v6 ("::ffff:192.168.1.1"));
564  	auto subnet1 (boost::asio::ip::make_network_v6 (address1, 96 + 16));
565  	ASSERT_EQ (boost::asio::ip::make_address_v6 ("::ffff:192.168.0.0"), subnet1.network ());
566  	auto address2 (boost::asio::ip::make_address_v6 ("::ffff:80.67.148.225"));
567  	auto subnet2 (boost::asio::ip::make_network_v6 (address2, 96 + 24));
568  	ASSERT_EQ (boost::asio::ip::make_address_v6 ("::ffff:80.67.148.0"), subnet2.network ());
569  	auto address2_subnet (nano::transport::map_address_to_subnetwork (address2));
570  	ASSERT_EQ (subnet2.network (), address2_subnet);
571  }
572  TEST (node, port_mapping)
573  {
574  	nano::test::system system (1);
575  	auto node0 (system.nodes[0]);
576  	node0->port_mapping.refresh_devices ();
577  	node0->port_mapping.start ();
578  	auto end (std::chrono::steady_clock::now () + std::chrono::seconds (500));
579  	(void)end;
580  	{
581  		ASSERT_NO_ERROR (system.poll ());
582  	}
583  }
584  TEST (tcp_listener, tcp_node_id_handshake)
585  {
586  	nano::test::system system (1);
587  	auto socket (std::make_shared<nano::transport::client_socket> (*system.nodes[0]));
588  	auto bootstrap_endpoint (system.nodes[0]->tcp_listener.endpoint ());
589  	auto cookie (system.nodes[0]->network.syn_cookies.assign (nano::transport::map_tcp_to_endpoint (bootstrap_endpoint)));
590  	ASSERT_TRUE (cookie);
591  	nano::node_id_handshake::query_payload query{ *cookie };
592  	nano::node_id_handshake node_id_handshake{ nano::dev::network_params.network, query };
593  	auto input (node_id_handshake.to_shared_const_buffer ());
594  	std::atomic<bool> write_done (false);
595  	socket->async_connect (bootstrap_endpoint, [&input, socket, &write_done] (boost::system::error_code const & ec) {
596  		ASSERT_FALSE (ec);
597  		socket->async_write (input, [&input, &write_done] (boost::system::error_code const & ec, size_t size_a) {
598  			ASSERT_FALSE (ec);
599  			ASSERT_EQ (input.size (), size_a);
600  			write_done = true;
601  		});
602  	});
603  	ASSERT_TIMELY (5s, write_done);
604  	nano::node_id_handshake::response_payload response_zero{ 0 };
605  	nano::node_id_handshake node_id_handshake_response{ nano::dev::network_params.network, std::nullopt, response_zero };
606  	auto output (node_id_handshake_response.to_bytes ());
607  	std::atomic<bool> done (false);
608  	socket->async_read (output, output->size (), [&output, &done] (boost::system::error_code const & ec, size_t size_a) {
609  		ASSERT_FALSE (ec);
610  		ASSERT_EQ (output->size (), size_a);
611  		done = true;
612  	});
613  	ASSERT_TIMELY (5s, done);
614  }
615  TEST (tcp_listener, DISABLED_tcp_listener_timeout_empty)
616  {
617  	nano::test::system system (1);
618  	auto node0 (system.nodes[0]);
619  	auto socket (std::make_shared<nano::transport::client_socket> (*node0));
620  	std::atomic<bool> connected (false);
621  	socket->async_connect (node0->tcp_listener.endpoint (), [&connected] (boost::system::error_code const & ec) {
622  		ASSERT_FALSE (ec);
623  		connected = true;
624  	});
625  	ASSERT_TIMELY (5s, connected);
626  	bool disconnected (false);
627  	system.deadline_set (std::chrono::seconds (6));
628  	while (!disconnected)
629  	{
630  		{
631  			nano::lock_guard<nano::mutex> guard (node0->tcp_listener.mutex);
632  			disconnected = node0->tcp_listener.connections.empty ();
633  		}
634  		ASSERT_NO_ERROR (system.poll ());
635  	}
636  }
637  TEST (tcp_listener, tcp_listener_timeout_node_id_handshake)
638  {
639  	nano::test::system system (1);
640  	auto node0 (system.nodes[0]);
641  	auto socket (std::make_shared<nano::transport::client_socket> (*node0));
642  	auto cookie (node0->network.syn_cookies.assign (nano::transport::map_tcp_to_endpoint (node0->tcp_listener.endpoint ())));
643  	ASSERT_TRUE (cookie);
644  	nano::node_id_handshake::query_payload query{ *cookie };
645  	nano::node_id_handshake node_id_handshake{ nano::dev::network_params.network, query };
646  	auto channel = std::make_shared<nano::transport::channel_tcp> (*node0, socket);
647  	socket->async_connect (node0->tcp_listener.endpoint (), [&node_id_handshake, channel] (boost::system::error_code const & ec) {
648  		ASSERT_FALSE (ec);
649  		channel->send (node_id_handshake, [] (boost::system::error_code const & ec, size_t size_a) {
650  			ASSERT_FALSE (ec);
651  		});
652  	});
653  	ASSERT_TIMELY (5s, node0->stats.count (nano::stat::type::message, nano::stat::detail::node_id_handshake) != 0);
654  	{
655  		nano::lock_guard<nano::mutex> guard (node0->tcp_listener.mutex);
656  		ASSERT_EQ (node0->tcp_listener.connections.size (), 1);
657  	}
658  	bool disconnected (false);
659  	system.deadline_set (std::chrono::seconds (20));
660  	while (!disconnected)
661  	{
662  		{
663  			nano::lock_guard<nano::mutex> guard (node0->tcp_listener.mutex);
664  			disconnected = node0->tcp_listener.connections.empty ();
665  		}
666  		ASSERT_NO_ERROR (system.poll ());
667  	}
668  }
669  #ifndef _WIN32
670  TEST (network, peer_max_tcp_attempts)
671  {
672  	nano::node_flags node_flags;
673  	node_flags.disable_connection_cleanup = true;
674  	nano::test::system system;
675  	auto node = system.add_node (node_flags);
676  	for (auto i (0); i < node->network_params.network.max_peers_per_ip; ++i)
677  	{
678  		auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
679  		node2->start ();
680  		system.nodes.push_back (node2);
681  		node->network.merge_peer (node2->network.endpoint ());
682  	}
683  	ASSERT_EQ (0, node->network.size ());
684  	ASSERT_TRUE (node->network.tcp_channels.reachout (nano::endpoint (node->network.endpoint ().address (), system.get_available_port ())));
685  	ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::out));
686  }
687  #endif
688  namespace nano
689  {
690  namespace transport
691  {
692  	TEST (network, peer_max_tcp_attempts_subnetwork)
693  	{
694  		nano::node_flags node_flags;
695  		node_flags.disable_max_peers_per_ip = true;
696  		nano::test::system system;
697  		system.add_node (node_flags);
698  		auto node (system.nodes[0]);
699  		for (auto i (0); i < node->network_params.network.max_peers_per_subnetwork; ++i)
700  		{
701  			auto address (boost::asio::ip::address_v6::v4_mapped (boost::asio::ip::address_v4 (0x7f000001 + i))); 
702  			nano::endpoint endpoint (address, system.get_available_port ());
703  			ASSERT_FALSE (node->network.tcp_channels.reachout (endpoint));
704  		}
705  		ASSERT_EQ (0, node->network.size ());
706  		ASSERT_EQ (0, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_subnetwork, nano::stat::dir::out));
707  		ASSERT_TRUE (node->network.tcp_channels.reachout (nano::endpoint (boost::asio::ip::make_address_v6 ("::ffff:127.0.0.1"), system.get_available_port ())));
708  		ASSERT_EQ (1, node->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_subnetwork, nano::stat::dir::out));
709  	}
710  }
711  }
712  TEST (network, duplicate_detection)
713  {
714  	nano::test::system system;
715  	nano::node_flags node_flags;
716  	auto & node0 = *system.add_node (node_flags);
717  	auto & node1 = *system.add_node (node_flags);
718  	nano::publish publish{ nano::dev::network_params.network, nano::dev::genesis };
719  	ASSERT_EQ (0, node1.stats.count (nano::stat::type::filter, nano::stat::detail::duplicate_publish));
720  	auto tcp_channel = node0.network.tcp_channels.find_node_id (node1.get_node_id ());
721  	ASSERT_NE (nullptr, tcp_channel);
722  	ASSERT_EQ (0, node1.stats.count (nano::stat::type::filter, nano::stat::detail::duplicate_publish));
723  	tcp_channel->send (publish);
724  	ASSERT_TIMELY (2s, node1.stats.count (nano::stat::type::filter, nano::stat::detail::duplicate_publish) == 0);
725  	tcp_channel->send (publish);
726  	ASSERT_TIMELY (2s, node1.stats.count (nano::stat::type::filter, nano::stat::detail::duplicate_publish) == 1);
727  }
728  TEST (network, duplicate_revert_publish)
729  {
730  	nano::test::system system;
731  	nano::node_flags node_flags;
732  	node_flags.block_processor_full_size = 0;
733  	auto & node (*system.add_node (node_flags));
734  	ASSERT_TRUE (node.block_processor.full ());
735  	nano::publish publish{ nano::dev::network_params.network, nano::dev::genesis };
736  	std::vector<uint8_t> bytes;
737  	{
738  		nano::vectorstream stream (bytes);
739  		publish.block->serialize (stream);
740  	}
741  	nano::uint128_t digest;
742  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size (), &digest));
743  	ASSERT_TRUE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
744  	auto other_node (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
745  	other_node->start ();
746  	system.nodes.push_back (other_node);
747  	auto channel = nano::test::establish_tcp (system, *other_node, node.network.endpoint ());
748  	ASSERT_NE (nullptr, channel);
749  	ASSERT_EQ (0, publish.digest);
750  	node.network.inbound (publish, channel);
751  	ASSERT_TRUE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
752  	publish.digest = digest;
753  	node.network.inbound (publish, channel);
754  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
755  }
756  TEST (network, bandwidth_limiter_4_messages)
757  {
758  	nano::test::system system;
759  	nano::publish message{ nano::dev::network_params.network, nano::dev::genesis };
760  	auto message_size = message.to_bytes ()->size ();
761  	auto message_limit = 4; 
762  	nano::node_config node_config = system.default_config ();
763  	node_config.bandwidth_limit = message_limit * message_size;
764  	node_config.bandwidth_limit_burst_ratio = 1.0;
765  	auto & node = *system.add_node (node_config);
766  	nano::transport::inproc::channel channel1{ node, node };
767  	nano::transport::inproc::channel channel2{ node, node };
768  	for (auto i = 0; i < message_limit; i += 2) 
769  	{
770  		channel1.send (message);
771  		channel2.send (message);
772  	}
773  	ASSERT_TIMELY (1s, 0 == node.stats.count (nano::stat::type::drop, nano::stat::detail::publish, nano::stat::dir::out));
774  	channel1.send (message);
775  	ASSERT_TIMELY (1s, 1 == node.stats.count (nano::stat::type::drop, nano::stat::detail::publish, nano::stat::dir::out));
776  	channel2.send (message, nullptr, nano::transport::buffer_drop_policy::no_limiter_drop);
777  	ASSERT_TIMELY (1s, 1 == node.stats.count (nano::stat::type::drop, nano::stat::detail::publish, nano::stat::dir::out));
778  }
779  TEST (network, bandwidth_limiter_2_messages)
780  {
781  	nano::test::system system;
782  	nano::publish message{ nano::dev::network_params.network, nano::dev::genesis };
783  	auto message_size = message.to_bytes ()->size ();
784  	auto message_limit = 2; 
785  	nano::node_config node_config = system.default_config ();
786  	node_config.bandwidth_limit = message_limit * message_size;
787  	node_config.bandwidth_limit_burst_ratio = 1.0;
788  	auto & node = *system.add_node (node_config);
789  	nano::transport::inproc::channel channel1{ node, node };
790  	nano::transport::inproc::channel channel2{ node, node };
791  	channel1.send (message);
792  	channel2.send (message);
793  	channel1.send (message);
794  	channel2.send (message);
795  	ASSERT_TIMELY (1s, 2 == node.stats.count (nano::stat::type::drop, nano::stat::detail::publish, nano::stat::dir::out));
796  }
797  TEST (network, bandwidth_limiter_with_burst)
798  {
799  	nano::test::system system;
800  	nano::publish message{ nano::dev::network_params.network, nano::dev::genesis };
801  	auto message_size = message.to_bytes ()->size ();
802  	auto message_limit = 2; 
803  	nano::node_config node_config = system.default_config ();
804  	node_config.bandwidth_limit = message_limit * message_size;
805  	node_config.bandwidth_limit_burst_ratio = 4.0; 
806  	auto & node = *system.add_node (node_config);
807  	nano::transport::inproc::channel channel1{ node, node };
808  	nano::transport::inproc::channel channel2{ node, node };
809  	channel1.send (message);
810  	channel2.send (message);
811  	channel1.send (message);
812  	channel2.send (message);
813  	ASSERT_TIMELY (1s, 0 == node.stats.count (nano::stat::type::drop, nano::stat::detail::publish, nano::stat::dir::out));
814  }
815  namespace nano
816  {
817  TEST (peer_exclusion, validate)
818  {
819  	std::size_t max_size = 10;
820  	nano::peer_exclusion excluded_peers{ max_size };
821  	for (auto i = 0; i < max_size + 1; ++i)
822  	{
823  		nano::tcp_endpoint endpoint{ boost::asio::ip::address_v6::v4_mapped (boost::asio::ip::address_v4 (i)), 0 };
824  		ASSERT_FALSE (excluded_peers.check (endpoint));
825  		ASSERT_EQ (1, excluded_peers.add (endpoint));
826  		ASSERT_FALSE (excluded_peers.check (endpoint));
827  	}
828  	ASSERT_EQ (max_size, excluded_peers.size ());
829  	nano::tcp_endpoint oldest{ boost::asio::ip::address_v6::v4_mapped (boost::asio::ip::address_v4 (0x0)), 0 };
830  	ASSERT_EQ (excluded_peers.score (oldest), 0);
831  	auto to_seconds = [] (std::chrono::steady_clock::time_point const & timepoint) {
832  		return static_cast<double> (std::chrono::duration_cast<std::chrono::seconds> (timepoint.time_since_epoch ()).count ());
833  	};
834  	nano::tcp_endpoint first{ boost::asio::ip::address_v6::v4_mapped (boost::asio::ip::address_v4 (0x1)), 0 };
835  	ASSERT_NE (excluded_peers.score (first), 0);
836  	nano::tcp_endpoint second{ boost::asio::ip::address_v6::v4_mapped (boost::asio::ip::address_v4 (0x2)), 0 };
837  	ASSERT_NE (excluded_peers.score (second), 0);
838  	ASSERT_NEAR (to_seconds (std::chrono::steady_clock::now () + excluded_peers.exclude_time_hours), to_seconds (excluded_peers.until (second)), 2);
839  	ASSERT_EQ (2, excluded_peers.add (second));
840  	ASSERT_NEAR (to_seconds (std::chrono::steady_clock::now () + excluded_peers.exclude_time_hours), to_seconds (excluded_peers.until (second)), 2);
841  	ASSERT_EQ (3, excluded_peers.add (second));
842  	ASSERT_NEAR (to_seconds (std::chrono::steady_clock::now () + excluded_peers.exclude_time_hours * 3 * 2), to_seconds (excluded_peers.until (second)), 2);
843  	ASSERT_EQ (max_size, excluded_peers.size ());
844  }
845  }
846  TEST (network, tcp_no_connect_excluded_peers)
847  {
848  	nano::test::system system (1);
849  	auto node0 (system.nodes[0]);
850  	ASSERT_EQ (0, node0->network.size ());
851  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
852  	node1->start ();
853  	system.nodes.push_back (node1);
854  	auto endpoint1_tcp (nano::transport::map_endpoint_to_tcp (node1->network.endpoint ()));
855  	while (!node0->network.excluded_peers.check (endpoint1_tcp))
856  	{
857  		node0->network.excluded_peers.add (endpoint1_tcp);
858  	}
859  	ASSERT_EQ (0, node0->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_excluded));
860  	node1->network.merge_peer (node0->network.endpoint ());
861  	ASSERT_TIMELY (5s, node0->stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_excluded) >= 1);
862  	ASSERT_EQ (nullptr, node0->network.find_node_id (node1->get_node_id ()));
863  	ASSERT_TRUE (node0->network.reachout (node1->network.endpoint (), true));
864  	node0->network.excluded_peers.remove (endpoint1_tcp);
865  	ASSERT_FALSE (node0->network.excluded_peers.check (endpoint1_tcp));
866  	ASSERT_TIMELY (5s, node1->network.syn_cookies.cookies_size () != 0);
867  	node1->network.cleanup (std::chrono::steady_clock::now ());
868  	node1->network.syn_cookies.purge (std::chrono::steady_clock::now ());
869  	ASSERT_EQ (0, node0->network.size ());
870  	node1->network.merge_peer (node0->network.endpoint ());
871  	ASSERT_TIMELY (5s, node0->network.size () == 1);
872  }
873  namespace nano
874  {
875  TEST (network, tcp_message_manager)
876  {
877  	nano::tcp_message_manager manager (1);
878  	nano::tcp_message_item item;
879  	item.node_id = nano::account (100);
880  	ASSERT_EQ (0, manager.entries.size ());
881  	manager.put_message (item);
882  	ASSERT_EQ (1, manager.entries.size ());
883  	ASSERT_EQ (manager.get_message ().node_id, item.node_id);
884  	ASSERT_EQ (0, manager.entries.size ());
885  	manager.entries = decltype (manager.entries) (manager.max_entries, item);
886  	ASSERT_EQ (manager.entries.size (), manager.max_entries);
887  	auto future = std::async (std::launch::async, [&] {
888  		manager.put_message (item);
889  	});
890  	std::this_thread::sleep_for (CI ? 200ms : 100ms);
891  	ASSERT_EQ (manager.entries.size (), manager.max_entries);
892  	ASSERT_EQ (manager.get_message ().node_id, item.node_id);
893  	ASSERT_NE (std::future_status::timeout, future.wait_for (1s));
894  	ASSERT_EQ (manager.entries.size (), manager.max_entries);
895  	nano::tcp_message_manager manager2 (2);
896  	size_t message_count = 10'000;
897  	std::vector<std::thread> consumers;
898  	for (auto i = 0; i < 4; ++i)
899  	{
900  		consumers.emplace_back ([&] {
901  			for (auto i = 0; i < message_count; ++i)
902  			{
903  				ASSERT_EQ (manager.get_message ().node_id, item.node_id);
904  			}
905  		});
906  	}
907  	std::vector<std::thread> producers;
908  	for (auto i = 0; i < 4; ++i)
909  	{
910  		producers.emplace_back ([&] {
911  			for (auto i = 0; i < message_count; ++i)
912  			{
913  				manager.put_message (item);
914  			}
915  		});
916  	}
917  	for (auto & t : boost::range::join (producers, consumers))
918  	{
919  		t.join ();
920  	}
921  }
922  }
923  TEST (network, cleanup_purge)
924  {
925  	auto test_start = std::chrono::steady_clock::now ();
926  	nano::test::system system (1);
927  	auto & node1 (*system.nodes[0]);
928  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
929  	node2->start ();
930  	system.nodes.push_back (node2);
931  	ASSERT_EQ (0, node1.network.size ());
932  	node1.network.cleanup (test_start);
933  	ASSERT_EQ (0, node1.network.size ());
934  	node1.network.cleanup (std::chrono::steady_clock::now ());
935  	ASSERT_EQ (0, node1.network.size ());
936  	std::weak_ptr<nano::node> node_w = node1.shared ();
937  	node1.network.tcp_channels.start_tcp (node2->network.endpoint ());
938  	ASSERT_TIMELY (3s, node1.network.size () == 1);
939  	node1.network.cleanup (test_start);
940  	ASSERT_EQ (1, node1.network.size ());
941  	node1.network.cleanup (std::chrono::steady_clock::now ());
942  	ASSERT_EQ (0, node1.network.size ());
943  }
944  TEST (network, loopback_channel)
945  {
946  	nano::test::system system (2);
947  	auto & node1 = *system.nodes[0];
948  	auto & node2 = *system.nodes[1];
949  	nano::transport::inproc::channel channel1 (node1, node1);
950  	ASSERT_EQ (channel1.get_type (), nano::transport::transport_type::loopback);
951  	ASSERT_EQ (channel1.get_endpoint (), node1.network.endpoint ());
952  	ASSERT_EQ (channel1.get_tcp_endpoint (), nano::transport::map_endpoint_to_tcp (node1.network.endpoint ()));
953  	ASSERT_EQ (channel1.get_network_version (), node1.network_params.network.protocol_version);
954  	ASSERT_EQ (channel1.get_node_id (), node1.node_id.pub);
955  	ASSERT_EQ (channel1.get_node_id_optional ().value_or (0), node1.node_id.pub);
956  	nano::transport::inproc::channel channel2 (node2, node2);
957  	ASSERT_TRUE (channel1 == channel1);
958  	ASSERT_FALSE (channel1 == channel2);
959  	++node1.network.port;
960  	ASSERT_NE (channel1.get_endpoint (), node1.network.endpoint ());
961  }
962  TEST (network, filter_invalid_network_bytes)
963  {
964  	nano::test::system system{ 2 };
965  	auto & node1 = *system.nodes[0];
966  	auto & node2 = *system.nodes[1];
967  	auto channel = node2.network.find_node_id (node1.get_node_id ());
968  	ASSERT_NE (nullptr, channel);
969  	nano::keepalive keepalive{ nano::dev::network_params.network };
970  	const_cast<nano::networks &> (keepalive.header.network) = nano::networks::invalid;
971  	channel->send (keepalive);
972  	ASSERT_TIMELY (5s, 1 == node1.stats.count (nano::stat::type::error, nano::stat::detail::invalid_network));
973  }
974  TEST (network, filter_invalid_version_using)
975  {
976  	nano::test::system system{ 2 };
977  	auto & node1 = *system.nodes[0];
978  	auto & node2 = *system.nodes[1];
979  	auto channel = node2.network.find_node_id (node1.get_node_id ());
980  	ASSERT_NE (nullptr, channel);
981  	nano::keepalive keepalive{ nano::dev::network_params.network };
982  	const_cast<uint8_t &> (keepalive.header.version_using) = nano::dev::network_params.network.protocol_version_min - 1;
983  	channel->send (keepalive);
984  	ASSERT_TIMELY (5s, 1 == node1.stats.count (nano::stat::type::error, nano::stat::detail::outdated_version));
985  }
986  TEST (network, fill_keepalive_self)
987  {
988  	nano::test::system system{ 2 };
989  	std::array<nano::endpoint, 8> target;
990  	system.nodes[0]->network.fill_keepalive_self (target);
991  	ASSERT_TRUE (target[2].port () == system.nodes[1]->network.port);
992  }
993  TEST (network, purge_dead_channel_outgoing)
994  {
995  	nano::test::system system{};
996  	nano::node_flags flags;
997  	flags.disable_bootstrap_bulk_push_client = true;
998  	flags.disable_bootstrap_bulk_pull_server = true;
999  	flags.disable_bootstrap_listener = true;
1000  	flags.disable_lazy_bootstrap = true;
1001  	flags.disable_legacy_bootstrap = true;
1002  	flags.disable_wallet_bootstrap = true;
1003  	auto & node1 = *system.add_node (flags);
1004  	std::shared_ptr<nano::transport::socket> outgoing;
1005  	std::shared_ptr<nano::transport::socket> incoming;
1006  	std::atomic<int> connected_count{ 0 };
1007  	node1.observers.socket_connected.add ([&] (nano::transport::socket & socket) {
1008  		connected_count++;
1009  		outgoing = socket.shared_from_this ();
1010  		std::cout << "connected: " << socket.remote_endpoint () << std::endl;
1011  	});
1012  	std::atomic<int> accepted_count{ 0 };
1013  	node1.observers.socket_accepted.add ([&] (nano::transport::socket & socket) {
1014  		accepted_count++;
1015  		incoming = socket.shared_from_this ();
1016  		std::cout << "accepted: " << socket.remote_endpoint () << std::endl;
1017  	});
1018  	auto & node2 = *system.add_node (flags);
1019  	ASSERT_TIMELY_EQ (5s, connected_count, 1);
1020  	ASSERT_ALWAYS_EQ (1s, connected_count, 1);
1021  	ASSERT_TIMELY_EQ (5s, accepted_count, 1);
1022  	ASSERT_ALWAYS_EQ (1s, accepted_count, 1);
1023  	ASSERT_EQ (node1.network.size (), 1);
1024  	ASSERT_ALWAYS_EQ (1s, node1.network.size (), 1);
1025  	auto channels = node1.network.list ();
1026  	ASSERT_EQ (channels.size (), 1);
1027  	auto channel = channels.front ();
1028  	ASSERT_TRUE (channel);
1029  	ASSERT_TRUE (channel->alive ());
<span onclick='openModal()' class='match'>1030  	outgoing->close ();
1031  	ASSERT_TIMELY (5s, !channel->alive ());
1032  	ASSERT_TIMELY_EQ (5s, connected_count, 2);
1033  	ASSERT_ALWAYS_EQ (1s, connected_count, 2);
1034  	auto channels2 = node1.network.list ();
1035  	ASSERT_EQ (channels2.size (), 1);
1036  	auto channel2 = channels2.front ();
1037  	ASSERT_TRUE (channel2);
</span>1038  	ASSERT_TRUE (channel2->alive ());
1039  }
1040  TEST (network, purge_dead_channel_incoming)
1041  {
1042  	nano::test::system system{};
1043  	nano::node_flags flags;
1044  	flags.disable_bootstrap_bulk_push_client = true;
1045  	flags.disable_bootstrap_bulk_pull_server = true;
1046  	flags.disable_bootstrap_listener = true;
1047  	flags.disable_lazy_bootstrap = true;
1048  	flags.disable_legacy_bootstrap = true;
1049  	flags.disable_wallet_bootstrap = true;
1050  	auto & node1 = *system.add_node (flags);
1051  	std::shared_ptr<nano::transport::socket> outgoing;
1052  	std::shared_ptr<nano::transport::socket> incoming;
1053  	std::atomic<int> connected_count{ 0 };
1054  	node1.observers.socket_connected.add ([&] (nano::transport::socket & socket) {
1055  		connected_count++;
1056  		outgoing = socket.shared_from_this ();
1057  		std::cout << "connected: " << socket.remote_endpoint () << std::endl;
1058  	});
1059  	std::atomic<int> accepted_count{ 0 };
1060  	node1.observers.socket_accepted.add ([&] (nano::transport::socket & socket) {
1061  		accepted_count++;
1062  		incoming = socket.shared_from_this ();
1063  		std::cout << "accepted: " << socket.remote_endpoint () << std::endl;
1064  	});
1065  	auto & node2 = *system.add_node (flags);
1066  	ASSERT_TIMELY_EQ (5s, connected_count, 1);
1067  	ASSERT_ALWAYS_EQ (1s, connected_count, 1);
1068  	ASSERT_TIMELY_EQ (5s, accepted_count, 1);
1069  	ASSERT_ALWAYS_EQ (1s, accepted_count, 1);
1070  	ASSERT_EQ (node2.network.size (), 1);
1071  	ASSERT_ALWAYS_EQ (1s, node2.network.size (), 1);
1072  	auto channels = node2.network.list ();
1073  	ASSERT_EQ (channels.size (), 1);
1074  	auto channel = channels.front ();
1075  	ASSERT_TRUE (channel);
1076  	ASSERT_TRUE (channel->alive ());
1077  	incoming->close ();
1078  	ASSERT_TIMELY (5s, !channel->alive ());
1079  	ASSERT_TIMELY_EQ (5s, accepted_count, 2);
1080  	ASSERT_ALWAYS_EQ (1s, accepted_count, 2);
1081  	auto channels2 = node2.network.list ();
1082  	ASSERT_EQ (channels2.size (), 1);
1083  	auto channel2 = channels2.front ();
1084  	ASSERT_TRUE (channel2);
1085  	ASSERT_TRUE (channel2->alive ());
1086  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartitiongrid.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartitiongrid.h"
5  #include "colpartitionset.h"
6  #include "imagefind.h"
7  #include <algorithm>
8  #include <utility>
9  namespace tesseract {
10  const int kMaxPadFactor = 6;
11  const int kMaxNeighbourDistFactor = 4;
12  const int kMaxCaptionLines = 7;
13  const double kMinCaptionGapRatio = 2.0;
14  const double kMinCaptionGapHeightRatio = 0.5;
15  const double kMarginOverlapFraction = 0.25;
16  const double kBigPartSizeRatio = 1.75;
17  const double kTinyEnoughTextlineOverlapFraction = 0.25;
18  const double kMaxPartitionSpacing = 1.75;
19  const int kSmoothDecisionMargin = 4;
20  ColPartitionGrid::ColPartitionGrid(int gridsize, const ICOORD &bleft,
21                                     const ICOORD &tright)
22      : BBGrid<ColPartition, ColPartition_CLIST, ColPartition_C_IT>(
23            gridsize, bleft, tright) {}
24  void ColPartitionGrid::HandleClick(int x, int y) {
25    BBGrid<ColPartition, ColPartition_CLIST, ColPartition_C_IT>::HandleClick(x,
26                                                                             y);
27    ColPartitionGridSearch radsearch(this);
28    radsearch.SetUniqueMode(true);
29    radsearch.StartRadSearch(x, y, 1);
30    ColPartition *neighbour;
31    FCOORD click(x, y);
32    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
33      const TBOX &nbox = neighbour->bounding_box();
34      if (nbox.contains(click)) {
35        tprintf("Block box:");
36        neighbour->bounding_box().print();
37        neighbour->Print();
38      }
39    }
40  }
41  void ColPartitionGrid::Merges(
42      const std::function<bool(ColPartition *, TBOX *)> &box_cb,
43      const std::function<bool(const ColPartition *, const ColPartition *)>
44          &confirm_cb) {
45    ColPartitionGridSearch gsearch(this);
46    gsearch.StartFullSearch();
47    ColPartition *part;
48    while ((part = gsearch.NextFullSearch()) != nullptr) {
49      if (MergePart(box_cb, confirm_cb, part)) {
50        gsearch.RepositionIterator();
51      }
52    }
53  }
54  bool ColPartitionGrid::MergePart(
55      const std::function<bool(ColPartition *, TBOX *)> &box_cb,
56      const std::function<bool(const ColPartition *, const ColPartition *)>
57          &confirm_cb,
58      ColPartition *part) {
59    if (part->IsUnMergeableType()) {
60      return false;
61    }
62    bool any_done = false;
63    bool merge_done = false;
64    do {
65      merge_done = false;
66      TBOX box = part->bounding_box();
67      bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
68      if (debug) {
69        tprintf("Merge candidate:");
70        box.print();
71      }
72      if (!box_cb(part, &box)) {
73        continue;
74      }
75      ColPartition_CLIST merge_candidates;
76      FindMergeCandidates(part, box, debug, &merge_candidates);
77      int overlap_increase;
78      ColPartition *neighbour = BestMergeCandidate(part, &merge_candidates, debug,
79                                                   confirm_cb, &overlap_increase);
80      if (neighbour != nullptr && overlap_increase <= 0) {
81        if (debug) {
82          tprintf("Merging:hoverlap=%d, voverlap=%d, OLI=%d\n",
83                  part->HCoreOverlap(*neighbour), part->VCoreOverlap(*neighbour),
84                  overlap_increase);
85        }
86        RemoveBBox(neighbour);
87        RemoveBBox(part);
88        part->Absorb(neighbour, nullptr);
89        InsertBBox(true, true, part);
90        merge_done = true;
91        any_done = true;
92      } else if (neighbour != nullptr) {
93        if (debug) {
94          tprintf("Overlapped when merged with increase %d: ", overlap_increase);
95          neighbour->bounding_box().print();
96        }
97      } else if (debug) {
98        tprintf("No candidate neighbour returned\n");
99      }
100    } while (merge_done);
101    return any_done;
102  }
103  static bool OKMergeCandidate(const ColPartition *part,
104                               const ColPartition *candidate, bool debug) {
105    const TBOX &part_box = part->bounding_box();
106    if (candidate == part) {
107      return false; 
108    }
109    if (!part->TypesMatch(*candidate) || candidate->IsUnMergeableType()) {
110      return false; 
111    }
112    const TBOX &c_box = candidate->bounding_box();
113    if (debug) {
114      tprintf("Examining merge candidate:");
115      c_box.print();
116    }
117    if (candidate->IsVerticalType() || part->IsVerticalType()) {
118      int h_dist = -part->HCoreOverlap(*candidate);
119      if (h_dist >= std::max(part_box.width(), c_box.width()) / 2) {
120        if (debug) {
121          tprintf("Too far away: h_dist = %d\n", h_dist);
122        }
123        return false;
124      }
125    } else {
126      int v_dist = -part->VCoreOverlap(*candidate);
127      if (v_dist >= std::max(part_box.height(), c_box.height()) / 2) {
128        if (debug) {
129          tprintf("Too far away: v_dist = %d\n", v_dist);
130        }
131        return false;
132      }
133      if (!part->VSignificantCoreOverlap(*candidate) &&
134          !part->OKDiacriticMerge(*candidate, debug) &&
135          !candidate->OKDiacriticMerge(*part, debug)) {
136        if (debug) {
137          tprintf("Candidate fails overlap and diacritic tests!\n");
138        }
139        return false;
140      }
141    }
142    return true;
143  }
144  static int IncreaseInOverlap(const ColPartition *merge1,
145                               const ColPartition *merge2, int ok_overlap,
146                               ColPartition_CLIST *parts) {
147    ASSERT_HOST(merge1 != nullptr && merge2 != nullptr);
148    int total_area = 0;
149    ColPartition_C_IT it(parts);
150    TBOX merged_box(merge1->bounding_box());
151    merged_box += merge2->bounding_box();
152    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
153      ColPartition *part = it.data();
154      if (part == merge1 || part == merge2) {
155        continue;
156      }
157      TBOX part_box = part->bounding_box();
158      int overlap_area = part_box.intersection(merged_box).area();
159      if (overlap_area > 0 &&
160          !part->OKMergeOverlap(*merge1, *merge2, ok_overlap, false)) {
161        total_area += overlap_area;
162        overlap_area = part_box.intersection(merge1->bounding_box()).area();
163        if (overlap_area > 0) {
164          total_area -= overlap_area;
165        }
166        TBOX intersection_box = part_box.intersection(merge2->bounding_box());
167        overlap_area = intersection_box.area();
168        if (overlap_area > 0) {
169          total_area -= overlap_area;
170          intersection_box &= merge1->bounding_box(); 
171          overlap_area = intersection_box.area();
172          if (overlap_area > 0) {
173            total_area += overlap_area;
174          }
175        }
176      }
177    }
178    return total_area;
179  }
180  static bool TestCompatibleCandidates(const ColPartition &part, bool debug,
181                                       ColPartition_CLIST *candidates) {
182    ColPartition_C_IT it(candidates);
183    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
184      ColPartition *candidate = it.data();
185      if (!candidate->OKDiacriticMerge(part, false)) {
186        ColPartition_C_IT it2(it);
187        for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
188          ColPartition *candidate2 = it2.data();
189          if (candidate2 != candidate &&
190              !OKMergeCandidate(candidate, candidate2, false)) {
191            if (debug) {
192              tprintf("NC overlap failed:Candidate:");
193              candidate2->bounding_box().print();
194              tprintf("fails to be a good merge with:");
195              candidate->bounding_box().print();
196            }
197            return false;
198          }
199        }
200      }
201    }
202    return true;
203  }
204  int ColPartitionGrid::ComputeTotalOverlap(ColPartitionGrid **overlap_grid) {
205    int total_overlap = 0;
206    ColPartitionGridSearch gsearch(this);
207    gsearch.StartFullSearch();
208    ColPartition *part;
209    while ((part = gsearch.NextFullSearch()) != nullptr) {
210      ColPartition_CLIST neighbors;
211      const TBOX &part_box = part->bounding_box();
212      FindOverlappingPartitions(part_box, part, &neighbors);
213      ColPartition_C_IT n_it(&neighbors);
214      bool any_part_overlap = false;
215      for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
216        const TBOX &n_box = n_it.data()->bounding_box();
217        int overlap = n_box.intersection(part_box).area();
218        if (overlap > 0 && overlap_grid != nullptr) {
219          if (*overlap_grid == nullptr) {
220            *overlap_grid = new ColPartitionGrid(gridsize(), bleft(), tright());
221          }
222          (*overlap_grid)->InsertBBox(true, true, n_it.data()->ShallowCopy());
223          if (!any_part_overlap) {
224            (*overlap_grid)->InsertBBox(true, true, part->ShallowCopy());
225          }
226        }
227        any_part_overlap = true;
228        total_overlap += overlap;
229      }
230    }
231    return total_overlap;
232  }
233  void ColPartitionGrid::FindOverlappingPartitions(const TBOX &box,
234                                                   const ColPartition *not_this,
235                                                   ColPartition_CLIST *parts) {
236    ColPartitionGridSearch rsearch(this);
237    rsearch.StartRectSearch(box);
238    ColPartition *part;
239    while ((part = rsearch.NextRectSearch()) != nullptr) {
240      if (part != not_this) {
241        parts->add_sorted(SortByBoxLeft<ColPartition>, true, part);
242      }
243    }
244  }
245  ColPartition *ColPartitionGrid::BestMergeCandidate(
246      const ColPartition *part, ColPartition_CLIST *candidates, bool debug,
247      const std::function<bool(const ColPartition *, const ColPartition *)>
248          &confirm_cb,
249      int *overlap_increase) {
250    if (overlap_increase != nullptr) {
251      *overlap_increase = 0;
252    }
253    if (candidates->empty()) {
254      return nullptr;
255    }
256    int ok_overlap =
257        static_cast<int>(kTinyEnoughTextlineOverlapFraction * gridsize() + 0.5);
258    const TBOX &part_box = part->bounding_box();
259    ColPartition_C_IT it(candidates);
260    ColPartition *best_candidate = nullptr;
261    TBOX full_box(part_box);
262    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
263      ColPartition *candidate = it.data();
264      full_box += candidate->bounding_box();
265    }
266    ColPartition_CLIST neighbours;
267    FindOverlappingPartitions(full_box, part, &neighbours);
268    if (debug) {
269      tprintf("Finding best merge candidate from %d, %d neighbours for box:",
270              candidates->length(), neighbours.length());
271      part_box.print();
272    }
273    ColPartition_CLIST non_candidate_neighbours;
274    non_candidate_neighbours.set_subtract(SortByBoxLeft<ColPartition>, true,
275                                          &neighbours, candidates);
276    int worst_nc_increase = 0;
277    int best_increase = INT32_MAX;
278    int best_area = 0;
279    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
280      ColPartition *candidate = it.data();
281      if (confirm_cb != nullptr && !confirm_cb(part, candidate)) {
282        if (debug) {
283          tprintf("Candidate not confirmed:");
284          candidate->bounding_box().print();
285        }
286        continue;
287      }
288      int increase = IncreaseInOverlap(part, candidate, ok_overlap, &neighbours);
289      const TBOX &cand_box = candidate->bounding_box();
290      if (best_candidate == nullptr || increase < best_increase) {
291        best_candidate = candidate;
292        best_increase = increase;
293        best_area = cand_box.bounding_union(part_box).area() - cand_box.area();
294        if (debug) {
295          tprintf("New best merge candidate has increase %d, area %d, over box:",
296                  increase, best_area);
297          full_box.print();
298          candidate->Print();
299        }
300      } else if (increase == best_increase) {
301        int area = cand_box.bounding_union(part_box).area() - cand_box.area();
302        if (area < best_area) {
303          best_area = area;
304          best_candidate = candidate;
305        }
306      }
307      increase = IncreaseInOverlap(part, candidate, ok_overlap,
308                                   &non_candidate_neighbours);
309      if (increase > worst_nc_increase) {
310        worst_nc_increase = increase;
311      }
312    }
313    if (best_increase > 0) {
314      if (worst_nc_increase < best_increase &&
315          TestCompatibleCandidates(*part, debug, candidates)) {
316        best_increase = worst_nc_increase;
317      }
318    }
319    if (overlap_increase != nullptr) {
320      *overlap_increase = best_increase;
321    }
322    return best_candidate;
323  }
324  static void RemoveBadBox(BLOBNBOX *box, ColPartition *part,
325                           ColPartition_LIST *part_list) {
326    part->RemoveBox(box);
327    ColPartition::MakeBigPartition(box, part_list);
328  }
329  void ColPartitionGrid::SplitOverlappingPartitions(
330      ColPartition_LIST *big_parts) {
331    int ok_overlap =
332        static_cast<int>(kTinyEnoughTextlineOverlapFraction * gridsize() + 0.5);
333    ColPartitionGridSearch gsearch(this);
334    gsearch.StartFullSearch();
335    ColPartition *part;
336    while ((part = gsearch.NextFullSearch()) != nullptr) {
337      const TBOX &box = part->bounding_box();
338      ColPartitionGridSearch rsearch(this);
339      rsearch.SetUniqueMode(true);
340      rsearch.StartRectSearch(box);
341      int unresolved_overlaps = 0;
342      ColPartition *neighbour;
343      while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
344        if (neighbour == part) {
345          continue;
346        }
347        const TBOX &neighbour_box = neighbour->bounding_box();
348        if (neighbour->OKMergeOverlap(*part, *part, ok_overlap, false) &&
349            part->OKMergeOverlap(*neighbour, *neighbour, ok_overlap, false)) {
350          continue; 
351        }
352        if (!part->IsSingleton()) {
353          BLOBNBOX *excluded = part->BiggestBox();
354          TBOX shrunken = part->BoundsWithoutBox(excluded);
355          if (!shrunken.overlap(neighbour_box) &&
356              excluded->bounding_box().height() >
357                  kBigPartSizeRatio * shrunken.height()) {
358            gsearch.RemoveBBox();
359            RemoveBadBox(excluded, part, big_parts);
360            InsertBBox(true, true, part);
361            gsearch.RepositionIterator();
362            break;
363          }
364        } else if (box.contains(neighbour_box)) {
365          ++unresolved_overlaps;
366          continue; 
367        }
368        if (!neighbour->IsSingleton()) {
369          BLOBNBOX *excluded = neighbour->BiggestBox();
370          TBOX shrunken = neighbour->BoundsWithoutBox(excluded);
371          if (!shrunken.overlap(box) &&
372              excluded->bounding_box().height() >
373                  kBigPartSizeRatio * shrunken.height()) {
374            rsearch.RemoveBBox();
375            RemoveBadBox(excluded, neighbour, big_parts);
376            InsertBBox(true, true, neighbour);
377            gsearch.RepositionIterator();
378            break;
379          }
380        }
381        int part_overlap_count = part->CountOverlappingBoxes(neighbour_box);
382        int neighbour_overlap_count = neighbour->CountOverlappingBoxes(box);
383        ColPartition *right_part = nullptr;
384        if (neighbour_overlap_count <= part_overlap_count ||
385            part->IsSingleton()) {
386          BLOBNBOX *split_blob = neighbour->OverlapSplitBlob(box);
387          if (split_blob != nullptr) {
388            rsearch.RemoveBBox();
389            right_part = neighbour->SplitAtBlob(split_blob);
390            InsertBBox(true, true, neighbour);
391            ASSERT_HOST(right_part != nullptr);
392          }
393        } else {
394          BLOBNBOX *split_blob = part->OverlapSplitBlob(neighbour_box);
395          if (split_blob != nullptr) {
396            gsearch.RemoveBBox();
397            right_part = part->SplitAtBlob(split_blob);
398            InsertBBox(true, true, part);
399            ASSERT_HOST(right_part != nullptr);
400          }
401        }
402        if (right_part != nullptr) {
403          InsertBBox(true, true, right_part);
404          gsearch.RepositionIterator();
405          rsearch.RepositionIterator();
406          break;
407        }
408      }
409      if (unresolved_overlaps > 2 && part->IsSingleton()) {
410        RemoveBBox(part);
411        ColPartition_IT big_it(big_parts);
412        part->set_block_owned(true);
413        big_it.add_to_end(part);
414        gsearch.RepositionIterator();
415      }
416    }
417  }
418  bool ColPartitionGrid::GridSmoothNeighbours(BlobTextFlowType source_type,
419                                              Image nontext_map,
420                                              const TBOX &im_box,
421                                              const FCOORD &rotation) {
422    ColPartitionGridSearch gsearch(this);
423    gsearch.StartFullSearch();
424    ColPartition *part;
425    bool any_changed = false;
426    while ((part = gsearch.NextFullSearch()) != nullptr) {
427      if (part->flow() != source_type ||
428          BLOBNBOX::IsLineType(part->blob_type())) {
429        continue;
430      }
431      const TBOX &box = part->bounding_box();
432      bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
433      if (SmoothRegionType(nontext_map, im_box, rotation, debug, part)) {
434        any_changed = true;
435      }
436    }
437    return any_changed;
438  }
439  void ColPartitionGrid::ReflectInYAxis() {
440    ColPartition_LIST parts;
441    ColPartition_IT part_it(&parts);
442    ColPartitionGridSearch gsearch(this);
443    gsearch.StartFullSearch();
444    ColPartition *part;
445    while ((part = gsearch.NextFullSearch()) != nullptr) {
446      part_it.add_after_then_move(part);
447    }
448    ICOORD bot_left(-tright().x(), bleft().y());
449    ICOORD top_right(-bleft().x(), tright().y());
450    Init(gridsize(), bot_left, top_right);
451    for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
452      part = part_it.extract();
453      part->ReflectInYAxis();
454      InsertBBox(true, true, part);
455    }
456  }
457  void ColPartitionGrid::ExtractPartitionsAsBlocks(BLOCK_LIST *blocks,
458                                                   TO_BLOCK_LIST *to_blocks) {
459    TO_BLOCK_IT to_block_it(to_blocks);
460    BLOCK_IT block_it(blocks);
461    ColPartition_LIST parts;
462    ColPartition_IT part_it(&parts);
463    ColPartitionGridSearch gsearch(this);
464    gsearch.StartFullSearch();
465    ColPartition *part;
466    while ((part = gsearch.NextFullSearch()) != nullptr) {
467      part_it.add_after_then_move(part);
468      BlobRegionType blob_type = part->blob_type();
469      if (BLOBNBOX::IsTextType(blob_type) ||
470          (blob_type == BRT_UNKNOWN && part->boxes_count() > 1)) {
471        PolyBlockType type =
472            blob_type == BRT_VERT_TEXT ? PT_VERTICAL_TEXT : PT_FLOWING_TEXT;
473        TBOX box = part->bounding_box();
474        int median_width = part->median_width();
475        int median_height = part->median_height();
476        TO_ROW *row = part->MakeToRow();
477        if (row == nullptr) {
478          part->DeleteBoxes();
479          continue;
480        }
481        auto *block = new BLOCK("", true, 0, 0, box.left(), box.bottom(),
482                                box.right(), box.top());
483        block->pdblk.set_poly_block(new POLY_BLOCK(box, type));
484        auto *to_block = new TO_BLOCK(block);
485        TO_ROW_IT row_it(to_block->get_rows());
486        row_it.add_after_then_move(row);
487        if (blob_type == BRT_VERT_TEXT) {
488          to_block->line_size = static_cast<float>(median_width);
489          to_block->line_spacing = static_cast<float>(box.width());
490          to_block->max_blob_size = static_cast<float>(box.width() + 1);
491        } else {
492          to_block->line_size = static_cast<float>(median_height);
493          to_block->line_spacing = static_cast<float>(box.height());
494          to_block->max_blob_size = static_cast<float>(box.height() + 1);
495        }
496        if (to_block->line_size == 0) {
497          to_block->line_size = 1;
498        }
499        block_it.add_to_end(block);
500        to_block_it.add_to_end(to_block);
501      } else {
502        part->DeleteBoxes();
503      }
504    }
505    Clear();
506  }
507  void ColPartitionGrid::Deskew(const FCOORD &deskew) {
508    ColPartition_LIST parts;
509    ColPartition_IT part_it(&parts);
510    ColPartitionGridSearch gsearch(this);
511    gsearch.StartFullSearch();
512    ColPartition *part;
513    while ((part = gsearch.NextFullSearch()) != nullptr) {
514      part_it.add_after_then_move(part);
515    }
516    TBOX grid_box(bleft_, tright_);
517    grid_box.rotate_large(deskew);
518    Init(gridsize(), grid_box.botleft(), grid_box.topright());
519    for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
520      part = part_it.extract();
521      part->ComputeLimits();
522      InsertBBox(true, true, part);
523    }
524  }
525  void ColPartitionGrid::SetTabStops(TabFind *tabgrid) {
526    ColPartitionGridSearch gsearch(this);
527    gsearch.StartFullSearch();
528    ColPartition *part;
529    while ((part = gsearch.NextFullSearch()) != nullptr) {
530      const TBOX &part_box = part->bounding_box();
531      TabVector *left_line = tabgrid->LeftTabForBox(part_box, true, false);
532      if (left_line != nullptr && !left_line->IsLeftTab()) {
533        left_line = tabgrid->LeftTabForBox(part_box, false, false);
534      }
535      if (left_line != nullptr && left_line->IsLeftTab()) {
536        part->SetLeftTab(left_line);
537      }
538      TabVector *right_line = tabgrid->RightTabForBox(part_box, true, false);
539      if (right_line != nullptr && !right_line->IsRightTab()) {
540        right_line = tabgrid->RightTabForBox(part_box, false, false);
541      }
542      if (right_line != nullptr && right_line->IsRightTab()) {
543        part->SetRightTab(right_line);
544      }
545      part->SetColumnGoodness(tabgrid->WidthCB());
546    }
547  }
548  bool ColPartitionGrid::MakeColPartSets(PartSetVector *part_sets) {
549    auto *part_lists = new ColPartition_LIST[gridheight()];
550    part_sets->reserve(gridheight());
551    ColPartitionGridSearch gsearch(this);
552    gsearch.StartFullSearch();
553    ColPartition *part;
554    bool any_parts_found = false;
555    while ((part = gsearch.NextFullSearch()) != nullptr) {
556      BlobRegionType blob_type = part->blob_type();
557      if (blob_type != BRT_NOISE &&
558          (blob_type != BRT_UNKNOWN || !part->boxes()->singleton())) {
559        int grid_x, grid_y;
560        const TBOX &part_box = part->bounding_box();
561        GridCoords(part_box.left(), part_box.bottom(), &grid_x, &grid_y);
562        ColPartition_IT part_it(&part_lists[grid_y]);
563        part_it.add_to_end(part);
564        any_parts_found = true;
565      }
566    }
567    if (any_parts_found) {
568      for (int grid_y = 0; grid_y < gridheight(); ++grid_y) {
569        ColPartitionSet *line_set = nullptr;
570        if (!part_lists[grid_y].empty()) {
571          line_set = new ColPartitionSet(&part_lists[grid_y]);
572        }
573        part_sets->push_back(line_set);
574      }
575    }
576    delete[] part_lists;
577    return any_parts_found;
578  }
579  ColPartitionSet *ColPartitionGrid::MakeSingleColumnSet(WidthCallback cb) {
580    ColPartition *single_column_part = nullptr;
581    ColPartitionGridSearch gsearch(this);
582    gsearch.StartFullSearch();
583    ColPartition *part;
584    while ((part = gsearch.NextFullSearch()) != nullptr) {
585      BlobRegionType blob_type = part->blob_type();
586      if (blob_type != BRT_NOISE &&
587          (blob_type != BRT_UNKNOWN || !part->boxes()->singleton())) {
588        BlobTextFlowType flow = part->flow();
589        if ((blob_type == BRT_TEXT &&
590             (flow == BTFT_STRONG_CHAIN || flow == BTFT_CHAIN ||
591              flow == BTFT_LEADER || flow == BTFT_TEXT_ON_IMAGE)) ||
592            blob_type == BRT_RECTIMAGE || blob_type == BRT_POLYIMAGE) {
593          if (single_column_part == nullptr) {
594            single_column_part = part->ShallowCopy();
595            single_column_part->set_blob_type(BRT_TEXT);
596            single_column_part->CopyLeftTab(*single_column_part, false);
597            single_column_part->CopyRightTab(*single_column_part, false);
598          } else {
599            if (part->left_key() < single_column_part->left_key()) {
600              single_column_part->CopyLeftTab(*part, false);
601            }
602            if (part->right_key() > single_column_part->right_key()) {
603              single_column_part->CopyRightTab(*part, false);
604            }
605          }
606        }
607      }
608    }
609    if (single_column_part != nullptr) {
610      single_column_part->SetColumnGoodness(cb);
611      return new ColPartitionSet(single_column_part);
612    }
613    return nullptr;
614  }
615  void ColPartitionGrid::ClaimBoxes() {
616    ColPartitionGridSearch gsearch(this);
617    gsearch.StartFullSearch();
618    ColPartition *part;
619    while ((part = gsearch.NextFullSearch()) != nullptr) {
620      part->ClaimBoxes();
621    }
622  }
623  void ColPartitionGrid::ReTypeBlobs(BLOBNBOX_LIST *im_blobs) {
624    BLOBNBOX_IT im_blob_it(im_blobs);
625    ColPartition_LIST dead_parts;
626    ColPartition_IT dead_part_it(&dead_parts);
627    ColPartitionGridSearch gsearch(this);
628    gsearch.StartFullSearch();
629    ColPartition *part;
630    while ((part = gsearch.NextFullSearch()) != nullptr) {
631      BlobRegionType blob_type = part->blob_type();
632      BlobTextFlowType flow = part->flow();
633      bool any_blobs_moved = false;
634      if (blob_type == BRT_POLYIMAGE || blob_type == BRT_RECTIMAGE) {
635        BLOBNBOX_C_IT blob_it(part->boxes());
636        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
637          BLOBNBOX *blob = blob_it.data();
638          im_blob_it.add_after_then_move(blob);
639        }
640      } else if (blob_type != BRT_NOISE) {
641        BLOBNBOX_C_IT blob_it(part->boxes());
642        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
643          BLOBNBOX *blob = blob_it.data();
644          if (blob->region_type() == BRT_NOISE) {
645            ASSERT_HOST(blob->cblob()->area() != 0);
646            blob->set_owner(nullptr);
647            blob_it.extract();
648            any_blobs_moved = true;
649          } else {
650            blob->set_region_type(blob_type);
651            if (blob->flow() != BTFT_LEADER) {
652              blob->set_flow(flow);
653            }
654          }
655        }
656      }
657      if (blob_type == BRT_NOISE || part->boxes()->empty()) {
658        BLOBNBOX_C_IT blob_it(part->boxes());
659        part->DisownBoxes();
660        dead_part_it.add_to_end(part);
661        gsearch.RemoveBBox();
662        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
663          BLOBNBOX *blob = blob_it.data();
664          if (blob->cblob()->area() == 0) {
665            delete blob->cblob();
666            delete blob;
667          }
668        }
669      } else if (any_blobs_moved) {
670        gsearch.RemoveBBox();
671        part->ComputeLimits();
672        InsertBBox(true, true, part);
673        gsearch.RepositionIterator();
674      }
675    }
676  }
677  void ColPartitionGrid::RecomputeBounds(int gridsize, const ICOORD &bleft,
678                                         const ICOORD &tright,
679                                         const ICOORD &vertical) {
680    ColPartition_LIST saved_parts;
681    ColPartition_IT part_it(&saved_parts);
682    ColPartitionGridSearch gsearch(this);
683    gsearch.StartFullSearch();
684    ColPartition *part;
685    while ((part = gsearch.NextFullSearch()) != nullptr) {
686      part_it.add_to_end(part);
687    }
688    Init(gridsize, bleft, tright);
689    for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
690      part = part_it.extract();
691      part->set_vertical(vertical);
692      part->ComputeLimits();
693      InsertBBox(true, true, part);
694    }
695  }
696  void ColPartitionGrid::GridFindMargins(ColPartitionSet **best_columns) {
697    ColPartitionGridSearch gsearch(this);
698    gsearch.StartFullSearch();
699    ColPartition *part;
700    while ((part = gsearch.NextFullSearch()) != nullptr) {
701      ColPartitionSet *columns =
702          best_columns != nullptr ? best_columns[gsearch.GridY()] : nullptr;
703      FindPartitionMargins(columns, part);
704      const TBOX &box = part->bounding_box();
705      if (AlignedBlob::WithinTestRegion(2, box.left(), box.bottom())) {
706        tprintf("Computed margins for part:");
707        part->Print();
708      }
709    }
710  }
711  void ColPartitionGrid::ListFindMargins(ColPartitionSet **best_columns,
712                                         ColPartition_LIST *parts) {
713    ColPartition_IT part_it(parts);
714    for (part_it.mark_cycle_pt(); !part_it.cycled_list(); part_it.forward()) {
715      ColPartition *part = part_it.data();
716      ColPartitionSet *columns = nullptr;
717      if (best_columns != nullptr) {
718        const TBOX &part_box = part->bounding_box();
719        int grid_x, grid_y;
720        GridCoords(part_box.left(), part_box.bottom(), &grid_x, &grid_y);
721        columns = best_columns[grid_y];
722      }
723      FindPartitionMargins(columns, part);
724    }
725  }
726  void ColPartitionGrid::DeleteParts() {
727    ColPartition_LIST dead_parts;
728    ColPartition_IT dead_it(&dead_parts);
729    ColPartitionGridSearch gsearch(this);
730    gsearch.StartFullSearch();
731    ColPartition *part;
732    while ((part = gsearch.NextFullSearch()) != nullptr) {
733      part->DisownBoxes();
734      dead_it.add_to_end(part); 
735    }
736    Clear();
737  }
738  void ColPartitionGrid::DeleteUnknownParts(TO_BLOCK *block) {
739    ColPartitionGridSearch gsearch(this);
740    gsearch.StartFullSearch();
741    ColPartition *part;
742    while ((part = gsearch.NextFullSearch()) != nullptr) {
743      if (part->blob_type() == BRT_UNKNOWN) {
744        gsearch.RemoveBBox();
745        part->set_flow(BTFT_NONTEXT);
746        part->set_blob_type(BRT_NOISE);
747        part->SetBlobTypes();
748        part->DisownBoxes();
749        delete part;
750      }
751    }
752    block->DeleteUnownedNoise();
753  }
754  void ColPartitionGrid::DeleteNonLeaderParts() {
755    ColPartitionGridSearch gsearch(this);
756    gsearch.StartFullSearch();
757    ColPartition *part;
758    while ((part = gsearch.NextFullSearch()) != nullptr) {
759      if (part->flow() != BTFT_LEADER) {
760        gsearch.RemoveBBox();
761        if (part->ReleaseNonLeaderBoxes()) {
762          InsertBBox(true, true, part);
763          gsearch.RepositionIterator();
764        } else {
765          delete part;
766        }
767      }
768    }
769  }
770  void ColPartitionGrid::FindFigureCaptions() {
771    ColPartitionGridSearch gsearch(this);
772    gsearch.StartFullSearch();
773    ColPartition *part;
774    while ((part = gsearch.NextFullSearch()) != nullptr) {
775      if (part->IsImageType()) {
776        const TBOX &part_box = part->bounding_box();
777        bool debug =
778            AlignedBlob::WithinTestRegion(2, part_box.left(), part_box.bottom());
779        ColPartition *best_caption = nullptr;
780        int best_dist = 0;  
781        int best_upper = 0; 
782        for (int upper = 0; upper < 2; ++upper) {
783          ColPartition_C_IT partner_it(upper ? part->upper_partners()
784                                             : part->lower_partners());
785          for (partner_it.mark_cycle_pt(); !partner_it.cycled_list();
786               partner_it.forward()) {
787            ColPartition *partner = partner_it.data();
788            if (partner->IsImageType()) {
789              break;
790            }
791          }
792          if (!partner_it.cycled_list()) {
793            continue;
794          }
795          for (partner_it.mark_cycle_pt(); !partner_it.cycled_list();
796               partner_it.forward()) {
797            ColPartition *partner = partner_it.data();
798            if (!partner->IsTextType() || partner->type() == PT_TABLE) {
799              continue;
800            }
801            const TBOX &partner_box = partner->bounding_box();
802            if (debug) {
803              tprintf("Finding figure captions for image part:");
804              part_box.print();
805              tprintf("Considering partner:");
806              partner_box.print();
807            }
808            if (partner_box.left() >= part_box.left() &&
809                partner_box.right() <= part_box.right()) {
810              int dist = partner_box.y_gap(part_box);
811              if (best_caption == nullptr || dist < best_dist) {
812                best_dist = dist;
813                best_caption = partner;
814                best_upper = upper;
815              }
816            }
817          }
818        }
819        if (best_caption != nullptr) {
820          if (debug) {
821            tprintf("Best caption candidate:");
822            best_caption->bounding_box().print();
823          }
824          int line_count = 0;
825          int biggest_gap = 0;
826          int smallest_gap = INT16_MAX;
827          int total_height = 0;
828          int mean_height = 0;
829          ColPartition *end_partner = nullptr;
830          ColPartition *next_partner = nullptr;
831          for (ColPartition *partner = best_caption;
832               partner != nullptr && line_count <= kMaxCaptionLines;
833               partner = next_partner) {
834            if (!partner->IsTextType()) {
835              end_partner = partner;
836              break;
837            }
838            ++line_count;
839            total_height += partner->bounding_box().height();
840            next_partner = partner->SingletonPartner(best_upper);
841            if (next_partner != nullptr) {
842              int gap =
843                  partner->bounding_box().y_gap(next_partner->bounding_box());
844              if (gap > biggest_gap) {
845                biggest_gap = gap;
846                end_partner = next_partner;
847                mean_height = total_height / line_count;
848              } else if (gap < smallest_gap) {
849                smallest_gap = gap;
850              }
851              if (biggest_gap > mean_height * kMinCaptionGapHeightRatio &&
852                  biggest_gap > smallest_gap * kMinCaptionGapRatio) {
853                break;
854              }
855            }
856          }
857          if (debug) {
858            tprintf("Line count=%d, biggest gap %d, smallest%d, mean height %d\n",
859                    line_count, biggest_gap, smallest_gap, mean_height);
860            if (end_partner != nullptr) {
861              tprintf("End partner:");
862              end_partner->bounding_box().print();
863            }
864          }
865          if (next_partner == nullptr && line_count <= kMaxCaptionLines) {
866            end_partner = nullptr; 
867          }
868          if (line_count <= kMaxCaptionLines) {
869            for (ColPartition *partner = best_caption;
870                 partner != nullptr && partner != end_partner;
871                 partner = next_partner) {
872              partner->set_type(PT_CAPTION_TEXT);
873              partner->SetBlobTypes();
874              if (debug) {
875                tprintf("Set caption type for partition:");
876                partner->bounding_box().print();
877              }
878              next_partner = partner->SingletonPartner(best_upper);
879            }
880          }
881        }
882      }
883    }
884  }
885  void ColPartitionGrid::FindPartitionPartners() {
886    ColPartitionGridSearch gsearch(this);
887    gsearch.StartFullSearch();
888    ColPartition *part;
889    while ((part = gsearch.NextFullSearch()) != nullptr) {
890      if (part->IsVerticalType()) {
891        FindVPartitionPartners(true, part);
892        FindVPartitionPartners(false, part);
893      } else {
894        FindPartitionPartners(true, part);
895        FindPartitionPartners(false, part);
896      }
897    }
898  }
899  void ColPartitionGrid::FindPartitionPartners(bool upper, ColPartition *part) {
900    if (part->type() == PT_NOISE) {
901      return; 
902    }
903    const TBOX &box = part->bounding_box();
904    int top = part->median_top();
905    int bottom = part->median_bottom();
906    int height = top - bottom;
907    int mid_y = (bottom + top) / 2;
908    ColPartitionGridSearch vsearch(this);
909    vsearch.StartVerticalSearch(box.left(), box.right(), part->MidY());
910    ColPartition *neighbour;
911    ColPartition *best_neighbour = nullptr;
912    int best_dist = INT32_MAX;
913    while ((neighbour = vsearch.NextVerticalSearch(!upper)) != nullptr) {
914      if (neighbour == part || neighbour->type() == PT_NOISE) {
915        continue; 
916      }
917      int neighbour_bottom = neighbour->median_bottom();
918      int neighbour_top = neighbour->median_top();
919      int neighbour_y = (neighbour_bottom + neighbour_top) / 2;
920      if (upper != (neighbour_y > mid_y)) {
921        continue;
922      }
923      if (!part->HOverlaps(*neighbour) && !part->WithinSameMargins(*neighbour)) {
924        continue;
925      }
926      if (!part->TypesMatch(*neighbour)) {
927        if (best_neighbour == nullptr) {
928          best_neighbour = neighbour;
929        }
930        continue;
931      }
932      int dist = upper ? neighbour_bottom - top : bottom - neighbour_top;
933      if (dist <= kMaxPartitionSpacing * height) {
934        if (dist < best_dist) {
935          best_dist = dist;
936          best_neighbour = neighbour;
937        }
938      } else {
939        break;
940      }
941    }
942    if (best_neighbour != nullptr) {
943      part->AddPartner(upper, best_neighbour);
944    }
945  }
946  void ColPartitionGrid::FindVPartitionPartners(bool to_the_left,
947                                                ColPartition *part) {
948    if (part->type() == PT_NOISE) {
949      return; 
950    }
951    const TBOX &box = part->bounding_box();
952    int left = part->median_left();
953    int right = part->median_right();
954    int width = right >= left ? right - left : -1;
955    int mid_x = (left + right) / 2;
956    ColPartitionGridSearch hsearch(this);
957    hsearch.StartSideSearch(mid_x, box.bottom(), box.top());
958    ColPartition *neighbour;
959    ColPartition *best_neighbour = nullptr;
960    int best_dist = INT32_MAX;
961    while ((neighbour = hsearch.NextSideSearch(to_the_left)) != nullptr) {
962      if (neighbour == part || neighbour->type() == PT_NOISE) {
963        continue; 
964      }
965      int neighbour_left = neighbour->median_left();
966      int neighbour_right = neighbour->median_right();
967      int neighbour_x = (neighbour_left + neighbour_right) / 2;
968      if (to_the_left != (neighbour_x < mid_x)) {
969        continue;
970      }
971      if (!part->VOverlaps(*neighbour)) {
972        continue;
973      }
974      if (!part->TypesMatch(*neighbour)) {
975        continue; 
976      }
977      int dist = to_the_left ? left - neighbour_right : neighbour_left - right;
978      if (dist <= kMaxPartitionSpacing * width) {
979        if (dist < best_dist || best_neighbour == nullptr) {
980          best_dist = dist;
981          best_neighbour = neighbour;
982        }
983      } else {
984        break;
985      }
986    }
987    if (best_neighbour != nullptr) {
988      part->AddPartner(to_the_left, best_neighbour);
989    }
990  }
991  void ColPartitionGrid::RefinePartitionPartners(bool get_desperate) {
992    ColPartitionGridSearch gsearch(this);
993    for (int type = PT_UNKNOWN + 1; type <= PT_COUNT; type++) {
994      gsearch.StartFullSearch();
995      ColPartition *part;
996      while ((part = gsearch.NextFullSearch()) != nullptr) {
997        part->RefinePartners(static_cast<PolyBlockType>(type), get_desperate,
998                             this);
999        gsearch.RepositionIterator();
1000      }
1001    }
1002  }
1003  void ColPartitionGrid::FindMergeCandidates(const ColPartition *part,
1004                                             const TBOX &search_box, bool debug,
1005                                             ColPartition_CLIST *candidates) {
1006    int ok_overlap =
1007        static_cast<int>(kTinyEnoughTextlineOverlapFraction * gridsize() + 0.5);
1008    const TBOX &part_box = part->bounding_box();
1009    ColPartitionGridSearch rsearch(this);
1010    rsearch.SetUniqueMode(true);
1011    rsearch.StartRectSearch(search_box);
1012    ColPartition *candidate;
1013    while ((candidate = rsearch.NextRectSearch()) != nullptr) {
1014      if (!OKMergeCandidate(part, candidate, debug)) {
1015        continue;
1016      }
1017      const TBOX &c_box = candidate->bounding_box();
1018      if (!part_box.contains(c_box) && !c_box.contains(part_box)) {
1019        TBOX merged_box(part_box);
1020        merged_box += c_box;
1021        ColPartitionGridSearch msearch(this);
1022        msearch.SetUniqueMode(true);
1023        msearch.StartRectSearch(merged_box);
1024        ColPartition *neighbour;
1025        while ((neighbour = msearch.NextRectSearch()) != nullptr) {
1026          if (neighbour == part || neighbour == candidate) {
1027            continue; 
1028          }
1029          if (neighbour->OKMergeOverlap(*part, *candidate, ok_overlap, false)) {
1030            continue; 
1031          }
1032          TBOX n_box = neighbour->bounding_box();
1033          if (!n_box.overlap(part_box) && !n_box.overlap(c_box) &&
1034              !OKMergeCandidate(part, neighbour, false) &&
1035              !OKMergeCandidate(candidate, neighbour, false)) {
1036            break;
1037          }
1038        }
1039        if (neighbour != nullptr) {
1040          if (debug) {
1041            tprintf(
1042                "Combined box overlaps another that is not OK despite"
1043                " allowance of %d:",
1044                ok_overlap);
1045            neighbour->bounding_box().print();
1046            tprintf("Reason:");
1047            OKMergeCandidate(part, neighbour, true);
1048            tprintf("...and:");
1049            OKMergeCandidate(candidate, neighbour, true);
1050            tprintf("Overlap:");
1051            neighbour->OKMergeOverlap(*part, *candidate, ok_overlap, true);
1052          }
1053          continue;
1054        }
1055      }
1056      if (debug) {
1057        tprintf("Adding candidate:");
1058        candidate->bounding_box().print();
1059      }
1060      candidates->add_sorted(SortByBoxLeft<ColPartition>, true, candidate);
1061    }
1062  }
1063  bool ColPartitionGrid::SmoothRegionType(Image nontext_map, const TBOX &im_box,
1064                                          const FCOORD &rerotation, bool debug,
1065                                          ColPartition *part) {
1066    const TBOX &part_box = part->bounding_box();
1067    if (debug) {
1068      tprintf("Smooothing part at:");
1069      part_box.print();
1070    }
1071    BlobRegionType best_type = BRT_UNKNOWN;
1072    int best_dist = INT32_MAX;
1073    int max_dist = std::min(part_box.width(), part_box.height());
1074    max_dist = std::max(max_dist * kMaxNeighbourDistFactor, gridsize() * 2);
1075    bool any_image = false;
1076    bool all_image = true;
1077    for (int d = 0; d < BND_COUNT; ++d) {
1078      int dist;
1079      auto dir = static_cast<BlobNeighbourDir>(d);
1080      BlobRegionType type = SmoothInOneDirection(dir, nontext_map, im_box,
1081                                                 rerotation, debug, *part, &dist);
1082      if (debug) {
1083        tprintf("Result in dir %d = %d at dist %d\n", dir, type, dist);
1084      }
1085      if (type != BRT_UNKNOWN && dist < best_dist) {
1086        best_dist = dist;
1087        best_type = type;
1088      }
1089      if (type == BRT_POLYIMAGE) {
1090        any_image = true;
1091      } else {
1092        all_image = false;
1093      }
1094    }
1095    if (best_dist > max_dist) {
1096      return false; 
1097    }
1098    if (part->flow() == BTFT_STRONG_CHAIN && !all_image) {
1099      return false; 
1100    }
1101    BlobRegionType new_type = part->blob_type();
1102    BlobTextFlowType new_flow = part->flow();
1103    if (best_type == BRT_TEXT && !any_image) {
1104      new_flow = BTFT_STRONG_CHAIN;
1105      new_type = BRT_TEXT;
1106    } else if (best_type == BRT_VERT_TEXT && !any_image) {
1107      new_flow = BTFT_STRONG_CHAIN;
1108      new_type = BRT_VERT_TEXT;
1109    } else if (best_type == BRT_POLYIMAGE) {
1110      new_flow = BTFT_NONTEXT;
1111      new_type = BRT_UNKNOWN;
1112    }
1113    if (new_type != part->blob_type() || new_flow != part->flow()) {
1114      part->set_flow(new_flow);
1115      part->set_blob_type(new_type);
1116      part->SetBlobTypes();
1117      if (debug) {
1118        tprintf("Modified part:");
1119        part->Print();
1120      }
1121      return true;
1122    } else {
1123      return false;
1124    }
1125  }
1126  static void ComputeSearchBoxAndScaling(BlobNeighbourDir direction,
1127                                         const TBOX &part_box, int min_padding,
1128                                         TBOX *search_box, ICOORD *dist_scaling) {
1129    *search_box = part_box;
1130    int padding = std::min(part_box.height(), part_box.width());
1131    padding = std::max(padding, min_padding);
1132    padding *= kMaxPadFactor;
1133    search_box->pad(padding, padding);
1134    switch (direction) {
1135      case BND_LEFT:
1136        search_box->set_left(part_box.left());
1137        *dist_scaling = ICOORD(2, 1);
1138        break;
1139      case BND_BELOW:
1140        search_box->set_bottom(part_box.bottom());
1141        *dist_scaling = ICOORD(1, 2);
1142        break;
1143      case BND_RIGHT:
1144        search_box->set_right(part_box.right());
1145        *dist_scaling = ICOORD(2, 1);
1146        break;
1147      case BND_ABOVE:
1148        search_box->set_top(part_box.top());
1149        *dist_scaling = ICOORD(1, 2);
1150        break;
1151      default:
1152        ASSERT_HOST(false);
1153    }
1154  }
1155  enum NeighbourPartitionType {
1156    NPT_HTEXT,      
1157    NPT_VTEXT,      
1158    NPT_WEAK_HTEXT, 
1159    NPT_WEAK_VTEXT, 
1160    NPT_IMAGE,      
1161    NPT_COUNT       
1162  };
1163  BlobRegionType ColPartitionGrid::SmoothInOneDirection(
1164      BlobNeighbourDir direction, Image nontext_map, const TBOX &im_box,
1165      const FCOORD &rerotation, bool debug, const ColPartition &part,
1166      int *best_distance) {
1167    const TBOX &part_box = part.bounding_box();
1168    TBOX search_box;
1169    ICOORD dist_scaling;
1170    ComputeSearchBoxAndScaling(direction, part_box, gridsize(), &search_box,
1171                               &dist_scaling);
1172    bool image_region = ImageFind::CountPixelsInRotatedBox(
1173                            search_box, im_box, rerotation, nontext_map) > 0;
1174    std::vector<int> dists[NPT_COUNT];
1175    AccumulatePartDistances(part, dist_scaling, search_box, nontext_map, im_box,
1176                            rerotation, debug, dists);
1177    unsigned counts[NPT_COUNT];
1178    memset(counts, 0, sizeof(counts));
1179    int image_bias = image_region ? kSmoothDecisionMargin / 2 : 0;
1180    BlobRegionType text_dir = part.blob_type();
1181    BlobTextFlowType flow_type = part.flow();
1182    int min_dist = 0;
1183    do {
1184      min_dist = INT32_MAX;
1185      for (int i = 0; i < NPT_COUNT; ++i) {
1186        if (counts[i] < dists[i].size() && dists[i][counts[i]] < min_dist) {
1187          min_dist = dists[i][counts[i]];
1188        }
1189      }
1190      for (int i = 0; i < NPT_COUNT; ++i) {
1191        while (counts[i] < dists[i].size() && dists[i][counts[i]] <= min_dist) {
1192          ++counts[i];
1193        }
1194      }
1195      *best_distance = min_dist;
1196      if (debug) {
1197        tprintf("Totals: htext=%u+%u, vtext=%u+%u, image=%u+%u, at dist=%d\n",
1198                counts[NPT_HTEXT], counts[NPT_WEAK_HTEXT], counts[NPT_VTEXT],
1199                counts[NPT_WEAK_VTEXT], counts[NPT_IMAGE], image_bias, min_dist);
1200      }
1201      auto image_count = counts[NPT_IMAGE];
1202      auto htext_score = counts[NPT_HTEXT] + counts[NPT_WEAK_HTEXT] -
1203                         (image_count + counts[NPT_WEAK_VTEXT]);
1204      auto vtext_score = counts[NPT_VTEXT] + counts[NPT_WEAK_VTEXT] -
1205                         (image_count + counts[NPT_WEAK_HTEXT]);
1206      if (image_count > 0 && image_bias - htext_score >= kSmoothDecisionMargin &&
1207          image_bias - vtext_score >= kSmoothDecisionMargin) {
1208        *best_distance = dists[NPT_IMAGE][0];
1209        if (!dists[NPT_WEAK_VTEXT].empty() &&
1210            *best_distance > dists[NPT_WEAK_VTEXT][0]) {
1211          *best_distance = dists[NPT_WEAK_VTEXT][0];
1212        }
1213        if (!dists[NPT_WEAK_HTEXT].empty() &&
1214            *best_distance > dists[NPT_WEAK_HTEXT][0]) {
1215          *best_distance = dists[NPT_WEAK_HTEXT][0];
1216        }
1217        return BRT_POLYIMAGE;
1218      }
1219      if ((text_dir != BRT_VERT_TEXT || flow_type != BTFT_CHAIN) &&
1220          counts[NPT_HTEXT] > 0 && htext_score >= kSmoothDecisionMargin) {
1221        *best_distance = dists[NPT_HTEXT][0];
1222        return BRT_TEXT;
1223      } else if ((text_dir != BRT_TEXT || flow_type != BTFT_CHAIN) &&
1224                 counts[NPT_VTEXT] > 0 && vtext_score >= kSmoothDecisionMargin) {
1225        *best_distance = dists[NPT_VTEXT][0];
1226        return BRT_VERT_TEXT;
1227      }
1228    } while (min_dist < INT32_MAX);
1229    return BRT_UNKNOWN;
1230  }
1231  void ColPartitionGrid::AccumulatePartDistances(
1232      const ColPartition &base_part, const ICOORD &dist_scaling,
1233      const TBOX &search_box, Image nontext_map, const TBOX &im_box,
1234      const FCOORD &rerotation, bool debug, std::vector<int> *dists) {
1235    const TBOX &part_box = base_part.bounding_box();
1236    ColPartitionGridSearch rsearch(this);
1237    rsearch.SetUniqueMode(true);
1238    rsearch.StartRectSearch(search_box);
1239    ColPartition *neighbour;
1240    while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1241      if (neighbour->IsUnMergeableType() ||
1242          !base_part.ConfirmNoTabViolation(*neighbour) ||
1243          neighbour == &base_part) {
1244        continue;
1245      }
1246      TBOX nbox = neighbour->bounding_box();
1247      BlobRegionType n_type = neighbour->blob_type();
1248      if ((n_type == BRT_TEXT || n_type == BRT_VERT_TEXT) &&
1249          !ImageFind::BlankImageInBetween(part_box, nbox, im_box, rerotation,
1250                                          nontext_map)) {
1251        continue; 
1252      }
1253      if (BLOBNBOX::IsLineType(n_type)) {
1254        continue; 
1255      }
<span onclick='openModal()' class='match'>1256      int x_gap = std::max(part_box.x_gap(nbox), 0);
1257      int y_gap = std::max(part_box.y_gap(nbox), 0);
1258      int n_dist = x_gap * dist_scaling.x() + y_gap * dist_scaling.y();
</span>1259      if (debug) {
1260        tprintf("Part has x-gap=%d, y=%d, dist=%d at:", x_gap, y_gap, n_dist);
1261        nbox.print();
1262      }
1263      int n_boxes = std::min(neighbour->boxes_count(), kSmoothDecisionMargin);
1264      BlobTextFlowType n_flow = neighbour->flow();
1265      std::vector<int> *count_vector = nullptr;
1266      if (n_flow == BTFT_STRONG_CHAIN) {
1267        if (n_type == BRT_TEXT) {
1268          count_vector = &dists[NPT_HTEXT];
1269        } else {
1270          count_vector = &dists[NPT_VTEXT];
1271        }
1272        if (debug) {
1273          tprintf("%s %d\n", n_type == BRT_TEXT ? "Htext" : "Vtext", n_boxes);
1274        }
1275      } else if ((n_type == BRT_TEXT || n_type == BRT_VERT_TEXT) &&
1276                 (n_flow == BTFT_CHAIN || n_flow == BTFT_NEIGHBOURS)) {
1277        if (n_type == BRT_TEXT) {
1278          count_vector = &dists[NPT_WEAK_HTEXT];
1279        } else {
1280          count_vector = &dists[NPT_WEAK_VTEXT];
1281        }
1282        if (debug) {
1283          tprintf("Weak %d\n", n_boxes);
1284        }
1285      } else {
1286        count_vector = &dists[NPT_IMAGE];
1287        if (debug) {
1288          tprintf("Image %d\n", n_boxes);
1289        }
1290      }
1291      if (count_vector != nullptr) {
1292        for (int i = 0; i < n_boxes; ++i) {
1293          count_vector->push_back(n_dist);
1294        }
1295      }
1296      if (debug) {
1297        neighbour->Print();
1298      }
1299    }
1300    for (int i = 0; i < NPT_COUNT; ++i) {
1301      std::sort(dists[i].begin(), dists[i].end());
1302    }
1303  }
1304  void ColPartitionGrid::FindPartitionMargins(ColPartitionSet *columns,
1305                                              ColPartition *part) {
1306    TBOX box = part->bounding_box();
1307    int y = part->MidY();
1308    int left_margin = bleft().x();
1309    int right_margin = tright().x();
1310    if (columns != nullptr) {
1311      ColPartition *column = columns->ColumnContaining(box.left(), y);
1312      if (column != nullptr) {
1313        left_margin = column->LeftAtY(y);
1314      }
1315      column = columns->ColumnContaining(box.right(), y);
1316      if (column != nullptr) {
1317        right_margin = column->RightAtY(y);
1318      }
1319    }
1320    left_margin -= kColumnWidthFactor;
1321    right_margin += kColumnWidthFactor;
1322    left_margin = FindMargin(box.left() + box.height(), true, left_margin,
1323                             box.bottom(), box.top(), part);
1324    part->set_left_margin(left_margin);
1325    right_margin = FindMargin(box.right() - box.height(), false, right_margin,
1326                              box.bottom(), box.top(), part);
1327    part->set_right_margin(right_margin);
1328  }
1329  int ColPartitionGrid::FindMargin(int x, bool right_to_left, int x_limit,
1330                                   int y_bottom, int y_top,
1331                                   const ColPartition *not_this) {
1332    int height = y_top - y_bottom;
1333    ColPartitionGridSearch side_search(this);
1334    side_search.SetUniqueMode(true);
1335    side_search.StartSideSearch(x, y_bottom, y_top);
1336    ColPartition *part;
1337    while ((part = side_search.NextSideSearch(right_to_left)) != nullptr) {
1338      if (part == not_this) { 
1339        continue;
1340      }
1341      TBOX box = part->bounding_box();
1342      int min_overlap = std::min(height, static_cast<int>(box.height()));
1343      min_overlap = static_cast<int>(min_overlap * kMarginOverlapFraction + 0.5);
1344      int y_overlap = std::min(y_top, static_cast<int>(box.top())) -
1345                      std::max(y_bottom, static_cast<int>(box.bottom()));
1346      if (y_overlap < min_overlap) {
1347        continue;
1348      }
1349      int x_edge = right_to_left ? box.right() : box.left();
1350      if ((x_edge < x) != right_to_left) {
1351        continue;
1352      }
1353      if ((x_edge < x_limit) == right_to_left) {
1354        break;
1355      }
1356      x_limit = x_edge;
1357    }
1358    return x_limit;
1359  }
1360  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-network.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartitiongrid.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1030  	outgoing->close ();
1031  	ASSERT_TIMELY (5s, !channel->alive ());
1032  	ASSERT_TIMELY_EQ (5s, connected_count, 2);
1033  	ASSERT_ALWAYS_EQ (1s, connected_count, 2);
1034  	auto channels2 = node1.network.list ();
1035  	ASSERT_EQ (channels2.size (), 1);
1036  	auto channel2 = channels2.front ();
1037  	ASSERT_TRUE (channel2);
</pre></code></div>
                <div class="column column_space"><pre><code>1256      int x_gap = std::max(part_box.x_gap(nbox), 0);
1257      int y_gap = std::max(part_box.y_gap(nbox), 0);
1258      int n_dist = x_gap * dist_scaling.x() + y_gap * dist_scaling.y();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    