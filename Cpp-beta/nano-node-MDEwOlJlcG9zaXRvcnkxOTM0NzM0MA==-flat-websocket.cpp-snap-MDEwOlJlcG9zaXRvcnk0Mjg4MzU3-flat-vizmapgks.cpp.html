
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 21.302193913658883%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-websocket.cpp</h3>
            <pre><code>1  #include <nano/core_test/fakes/websocket_client.hpp>
2  #include <nano/node/transport/fake.hpp>
3  #include <nano/node/websocket.hpp>
4  #include <nano/test_common/network.hpp>
5  #include <nano/test_common/system.hpp>
6  #include <nano/test_common/telemetry.hpp>
7  #include <nano/test_common/testutil.hpp>
8  #include <gtest/gtest.h>
9  #include <boost/property_tree/json_parser.hpp>
10  #include <chrono>
11  #include <cstdlib>
12  #include <memory>
13  #include <sstream>
14  #include <string>
15  #include <vector>
16  using namespace std::chrono_literals;
17  TEST (websocket, subscription_edge)
18  {
19  	nano::test::system system;
20  	nano::node_config config = system.default_config ();
21  	config.websocket_config.enabled = true;
22  	config.websocket_config.port = system.get_available_port ();
23  	auto node1 (system.add_node (config));
24  	ASSERT_EQ (0, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
25  	auto task = ([config, &node1] () {
26  		fake_websocket_client client (node1->websocket.server->listening_port ());
27  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": true})json");
28  		client.await_ack ();
29  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
30  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": true})json");
31  		client.await_ack ();
32  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
33  		client.send_message (R"json({"action": "unsubscribe", "topic": "confirmation", "ack": true})json");
34  		client.await_ack ();
35  		EXPECT_EQ (0, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
36  		client.send_message (R"json({"action": "unsubscribe", "topic": "confirmation", "ack": true})json");
37  		client.await_ack ();
38  		EXPECT_EQ (0, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
39  	});
40  	auto future = std::async (std::launch::async, task);
41  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
42  }
43  TEST (websocket, confirmation)
44  {
45  	nano::test::system system;
46  	nano::node_config config = system.default_config ();
47  	config.websocket_config.enabled = true;
48  	config.websocket_config.port = system.get_available_port ();
49  	auto node1 (system.add_node (config));
50  	std::atomic<bool> ack_ready{ false };
51  	std::atomic<bool> unsubscribed{ false };
52  	auto task = ([&ack_ready, &unsubscribed, config, &node1] () {
53  		fake_websocket_client client (node1->websocket.server->listening_port ());
54  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": true})json");
55  		client.await_ack ();
56  		ack_ready = true;
57  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
58  		auto response = client.get_response ();
59  		EXPECT_TRUE (response);
60  		boost::property_tree::ptree event;
61  		std::stringstream stream;
62  		stream << response.get ();
63  		boost::property_tree::read_json (stream, event);
64  		EXPECT_EQ (event.get<std::string> ("topic"), "confirmation");
65  		client.send_message (R"json({"action": "unsubscribe", "topic": "confirmation", "ack": true})json");
66  		client.await_ack ();
67  		unsubscribed = true;
68  		EXPECT_FALSE (client.get_response (1s));
69  	});
70  	auto future = std::async (std::launch::async, task);
71  	ASSERT_TIMELY (5s, ack_ready);
72  	nano::keypair key;
73  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
74  	auto balance = nano::dev::constants.genesis_amount;
75  	auto send_amount = node1->online_reps.delta () + 1;
76  	{
77  		nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
78  		balance -= send_amount;
79  		nano::block_builder builder;
80  		auto send = builder
81  					.send ()
82  					.previous (previous)
83  					.destination (key.pub)
84  					.balance (balance)
85  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
86  					.work (*system.work.generate (previous))
87  					.build_shared ();
88  		node1->process_active (send);
89  	}
90  	ASSERT_TIMELY (5s, unsubscribed);
91  	{
92  		nano::state_block_builder builder;
93  		nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
94  		balance -= send_amount;
95  		auto send = builder
96  					.account (nano::dev::genesis_key.pub)
97  					.previous (previous)
98  					.representative (nano::dev::genesis_key.pub)
99  					.balance (balance)
100  					.link (key.pub)
101  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
102  					.work (*system.work.generate (previous))
103  					.build_shared ();
104  		node1->process_active (send);
105  	}
106  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
107  }
108  TEST (websocket, started_election)
109  {
110  	nano::test::system system;
111  	nano::node_config config = system.default_config ();
112  	config.websocket_config.enabled = true;
113  	config.websocket_config.port = system.get_available_port ();
114  	auto node1 = system.add_node (config);
115  	std::atomic<bool> ack_ready{ false };
116  	auto task = ([&ack_ready, config, &node1] () {
117  		fake_websocket_client client (node1->websocket.server->listening_port ());
118  		client.send_message (R"json({"action": "subscribe", "topic": "started_election", "ack": "true"})json");
119  		client.await_ack ();
120  		ack_ready = true;
121  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::started_election));
122  		return client.get_response ();
123  	});
124  	auto future = std::async (std::launch::async, task);
125  	ASSERT_TIMELY (5s, ack_ready);
126  	nano::keypair key1;
127  	nano::block_builder builder;
128  	auto send1 = builder
129  				 .send ()
130  				 .previous (nano::dev::genesis->hash ())
131  				 .destination (key1.pub)
132  				 .balance (0)
133  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
134  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
135  				 .build_shared ();
136  	nano::publish publish1{ nano::dev::network_params.network, send1 };
137  	auto channel1 = std::make_shared<nano::transport::fake::channel> (*node1);
138  	node1->network.inbound (publish1, channel1);
139  	ASSERT_TIMELY (1s, node1->active.election (send1->qualified_root ()));
140  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
141  	auto response = future.get ();
142  	ASSERT_TRUE (response);
143  	boost::property_tree::ptree event;
144  	std::stringstream stream;
145  	stream << response.get ();
146  	boost::property_tree::read_json (stream, event);
147  	ASSERT_EQ (event.get<std::string> ("topic"), "started_election");
148  }
149  TEST (websocket, stopped_election)
150  {
151  	nano::test::system system;
152  	nano::node_config config = system.default_config ();
153  	config.websocket_config.enabled = true;
154  	config.websocket_config.port = system.get_available_port ();
155  	auto node1 (system.add_node (config));
156  	std::atomic<bool> ack_ready{ false };
157  	auto task = ([&ack_ready, config, &node1] () {
158  		fake_websocket_client client (node1->websocket.server->listening_port ());
159  		client.send_message (R"json({"action": "subscribe", "topic": "stopped_election", "ack": "true"})json");
160  		client.await_ack ();
161  		ack_ready = true;
162  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::stopped_election));
163  		return client.get_response ();
164  	});
165  	auto future = std::async (std::launch::async, task);
166  	ASSERT_TIMELY (5s, ack_ready);
167  	nano::keypair key1;
168  	nano::block_builder builder;
169  	auto send1 = builder
170  				 .send ()
171  				 .previous (nano::dev::genesis->hash ())
172  				 .destination (key1.pub)
173  				 .balance (0)
174  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
175  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
176  				 .build_shared ();
177  	nano::publish publish1{ nano::dev::network_params.network, send1 };
178  	auto channel1 = std::make_shared<nano::transport::fake::channel> (*node1);
179  	node1->network.inbound (publish1, channel1);
180  	node1->block_processor.flush ();
181  	ASSERT_TIMELY (1s, node1->active.election (send1->qualified_root ()));
182  	node1->active.erase (*send1);
183  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
184  	auto response = future.get ();
185  	ASSERT_TRUE (response);
186  	boost::property_tree::ptree event;
187  	std::stringstream stream;
188  	stream << response.get ();
189  	boost::property_tree::read_json (stream, event);
190  	ASSERT_EQ (event.get<std::string> ("topic"), "stopped_election");
191  }
192  TEST (websocket, confirmation_options)
193  {
194  	nano::test::system system;
195  	nano::node_config config = system.default_config ();
196  	config.websocket_config.enabled = true;
197  	config.websocket_config.port = system.get_available_port ();
198  	auto node1 (system.add_node (config));
199  	std::atomic<bool> ack_ready{ false };
200  	auto task1 = ([&ack_ready, config, &node1] () {
201  		fake_websocket_client client (node1->websocket.server->listening_port ());
202  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": "true", "options": {"confirmation_type": "active_quorum", "accounts": ["xrb_invalid"]}})json");
203  		client.await_ack ();
204  		ack_ready = true;
205  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
206  		auto response = client.get_response (1s);
207  		EXPECT_FALSE (response);
208  	});
209  	auto future1 = std::async (std::launch::async, task1);
210  	ASSERT_TIMELY (5s, ack_ready);
211  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
212  	nano::keypair key;
213  	auto balance = nano::dev::constants.genesis_amount;
214  	auto send_amount = node1->online_reps.delta () + 1;
215  	nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
216  	{
217  		balance -= send_amount;
218  		nano::state_block_builder builder;
219  		auto send = builder
220  					.account (nano::dev::genesis_key.pub)
221  					.previous (previous)
222  					.representative (nano::dev::genesis_key.pub)
223  					.balance (balance)
224  					.link (key.pub)
225  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
226  					.work (*system.work.generate (previous))
227  					.build_shared ();
228  		node1->process_active (send);
229  		previous = send->hash ();
230  	}
231  	ASSERT_TIMELY (5s, future1.wait_for (0s) == std::future_status::ready);
232  	ack_ready = false;
233  	auto task2 = ([&ack_ready, config, &node1] () {
234  		fake_websocket_client client (node1->websocket.server->listening_port ());
235  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": "true", "options": {"confirmation_type": "active_quorum", "all_local_accounts": "true", "include_election_info": "true"}})json");
236  		client.await_ack ();
237  		ack_ready = true;
238  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
239  		return client.get_response ();
240  	});
241  	auto future2 = std::async (std::launch::async, task2);
242  	ASSERT_TIMELY (10s, ack_ready);
243  	{
244  		balance -= send_amount;
245  		nano::state_block_builder builder;
246  		auto send = builder
247  					.account (nano::dev::genesis_key.pub)
248  					.previous (previous)
249  					.representative (nano::dev::genesis_key.pub)
250  					.balance (balance)
251  					.link (key.pub)
252  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
253  					.work (*system.work.generate (previous))
254  					.build_shared ();
255  		node1->process_active (send);
256  		previous = send->hash ();
257  	}
258  	ASSERT_TIMELY (5s, future2.wait_for (0s) == std::future_status::ready);
259  	auto response2 = future2.get ();
260  	ASSERT_TRUE (response2);
261  	boost::property_tree::ptree event;
262  	std::stringstream stream;
263  	stream << response2.get ();
264  	boost::property_tree::read_json (stream, event);
265  	ASSERT_EQ (event.get<std::string> ("topic"), "confirmation");
266  	try
267  	{
268  		boost::property_tree::ptree election_info = event.get_child ("message.election_info");
269  		auto tally (election_info.get<std::string> ("tally"));
270  		auto final_tally (election_info.get<std::string> ("final"));
271  		auto time (election_info.get<std::string> ("time"));
272  		ASSERT_EQ (1, election_info.count ("duration"));
273  		ASSERT_EQ (1, election_info.count ("request_count"));
274  		ASSERT_EQ (1, election_info.count ("voters"));
275  		ASSERT_GE (1U, election_info.get<unsigned> ("blocks"));
276  		ASSERT_NE ("0", tally);
277  		ASSERT_NE ("0", time);
278  		auto votes_l (election_info.get_child_optional ("votes"));
279  		ASSERT_FALSE (votes_l.is_initialized ());
280  	}
281  	catch (std::runtime_error const & ex)
282  	{
283  		FAIL () << ex.what ();
284  	}
285  	ack_ready = false;
286  	auto task3 = ([&ack_ready, config, &node1] () {
287  		fake_websocket_client client (node1->websocket.server->listening_port ());
288  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": "true", "options": {"confirmation_type": "active_quorum", "all_local_accounts": "true"}})json");
289  		client.await_ack ();
290  		ack_ready = true;
291  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
292  		auto response = client.get_response (1s);
293  		EXPECT_FALSE (response);
294  	});
295  	auto future3 = std::async (std::launch::async, task3);
296  	ASSERT_TIMELY (5s, ack_ready);
297  	{
298  		balance -= send_amount;
299  		nano::block_builder builder;
300  		auto send = builder
301  					.send ()
302  					.previous (previous)
303  					.destination (key.pub)
304  					.balance (balance)
305  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
306  					.work (*system.work.generate (previous))
307  					.build_shared ();
308  		node1->process_active (send);
309  		previous = send->hash ();
310  	}
311  	ASSERT_TIMELY (5s, future3.wait_for (0s) == std::future_status::ready);
312  }
313  TEST (websocket, confirmation_options_votes)
314  {
315  	nano::test::system system;
316  	nano::node_config config = system.default_config ();
317  	config.websocket_config.enabled = true;
318  	config.websocket_config.port = system.get_available_port ();
319  	auto node1 (system.add_node (config));
320  	std::atomic<bool> ack_ready{ false };
321  	auto task1 = ([&ack_ready, config, &node1] () {
322  		fake_websocket_client client (node1->websocket.server->listening_port ());
323  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": "true", "options": {"confirmation_type": "active_quorum", "include_election_info_with_votes": "true", "include_block": "false"}})json");
324  		client.await_ack ();
325  		ack_ready = true;
326  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
327  		return client.get_response ();
328  	});
329  	auto future1 = std::async (std::launch::async, task1);
330  	ASSERT_TIMELY (10s, ack_ready);
331  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
332  	nano::keypair key;
333  	auto balance = nano::dev::constants.genesis_amount;
334  	auto send_amount = node1->config.online_weight_minimum.number () + 1;
335  	nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
336  	{
337  		nano::state_block_builder builder;
338  		balance -= send_amount;
339  		auto send = builder
340  					.account (nano::dev::genesis_key.pub)
341  					.previous (previous)
342  					.representative (nano::dev::genesis_key.pub)
343  					.balance (balance)
344  					.link (key.pub)
345  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
346  					.work (*system.work.generate (previous))
347  					.build_shared ();
348  		node1->process_active (send);
349  		previous = send->hash ();
350  	}
351  	ASSERT_TIMELY (5s, future1.wait_for (0s) == std::future_status::ready);
352  	auto response1 = future1.get ();
353  	ASSERT_TRUE (response1);
354  	boost::property_tree::ptree event;
355  	std::stringstream stream;
356  	stream << response1.get ();
357  	boost::property_tree::read_json (stream, event);
358  	ASSERT_EQ (event.get<std::string> ("topic"), "confirmation");
359  	try
360  	{
361  		boost::property_tree::ptree election_info = event.get_child ("message.election_info");
362  		auto tally (election_info.get<std::string> ("tally"));
363  		auto time (election_info.get<std::string> ("time"));
364  		ASSERT_EQ (1, election_info.count ("duration"));
365  		ASSERT_EQ (1, election_info.count ("request_count"));
366  		ASSERT_EQ (1, election_info.count ("voters"));
367  		ASSERT_GE (1U, election_info.get<unsigned> ("blocks"));
368  		ASSERT_NE ("0", tally);
369  		ASSERT_NE ("0", time);
370  		auto votes_l (election_info.get_child_optional ("votes"));
371  		ASSERT_TRUE (votes_l.is_initialized ());
372  		ASSERT_EQ (1, votes_l.get ().size ());
373  		for (auto & vote : votes_l.get ())
374  		{
375  			std::string representative (vote.second.get<std::string> ("representative"));
376  			ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), representative);
377  			std::string timestamp (vote.second.get<std::string> ("timestamp"));
378  			ASSERT_NE ("0", timestamp);
379  			std::string hash (vote.second.get<std::string> ("hash"));
380  			ASSERT_EQ (node1->latest (nano::dev::genesis_key.pub).to_string (), hash);
381  			std::string weight (vote.second.get<std::string> ("weight"));
382  			ASSERT_EQ (node1->balance (nano::dev::genesis_key.pub).convert_to<std::string> (), weight);
383  		}
384  	}
385  	catch (std::runtime_error const & ex)
386  	{
387  		FAIL () << ex.what ();
388  	}
389  }
390  TEST (websocket, confirmation_options_sideband)
391  {
392  	nano::test::system system;
393  	nano::node_config config = system.default_config ();
394  	config.websocket_config.enabled = true;
395  	config.websocket_config.port = system.get_available_port ();
396  	auto node1 (system.add_node (config));
397  	std::atomic<bool> ack_ready{ false };
398  	auto task1 = ([&ack_ready, config, &node1] () {
399  		fake_websocket_client client (node1->websocket.server->listening_port ());
400  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": "true", "options": {"confirmation_type": "active_quorum", "include_block": "false", "include_sideband_info": "true"}})json");
401  		client.await_ack ();
402  		ack_ready = true;
403  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
404  		return client.get_response ();
405  	});
406  	auto future1 = std::async (std::launch::async, task1);
407  	ASSERT_TIMELY (10s, ack_ready);
408  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
409  	nano::keypair key;
410  	auto balance = nano::dev::constants.genesis_amount;
411  	auto send_amount = node1->config.online_weight_minimum.number () + 1;
412  	nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
413  	{
414  		nano::state_block_builder builder;
415  		balance -= send_amount;
416  		auto send = builder
417  					.account (nano::dev::genesis_key.pub)
418  					.previous (previous)
419  					.representative (nano::dev::genesis_key.pub)
420  					.balance (balance)
421  					.link (key.pub)
422  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
423  					.work (*system.work.generate (previous))
424  					.build_shared ();
425  		node1->process_active (send);
426  		previous = send->hash ();
427  	}
428  	ASSERT_TIMELY (5s, future1.wait_for (0s) == std::future_status::ready);
429  	auto response1 = future1.get ();
430  	ASSERT_TRUE (response1);
431  	boost::property_tree::ptree event;
432  	std::stringstream stream;
433  	stream << response1.get ();
434  	boost::property_tree::read_json (stream, event);
435  	ASSERT_EQ (event.get<std::string> ("topic"), "confirmation");
436  	try
437  	{
438  		boost::property_tree::ptree sideband_info = event.get_child ("message.sideband");
439  		ASSERT_EQ (1, sideband_info.count ("height"));
440  		ASSERT_EQ (1, sideband_info.count ("local_timestamp"));
441  		ASSERT_NE ("0", sideband_info.get<std::string> ("height"));
442  		ASSERT_NE ("0", sideband_info.get<std::string> ("local_timestamp"));
443  	}
444  	catch (std::runtime_error const & ex)
445  	{
446  		FAIL () << ex.what ();
447  	}
448  }
449  TEST (websocket, confirmation_options_update)
450  {
451  	nano::test::system system;
452  	nano::node_config config = system.default_config ();
453  	config.websocket_config.enabled = true;
454  	config.websocket_config.port = system.get_available_port ();
455  	auto node1 (system.add_node (config));
456  	std::atomic<bool> added{ false };
457  	std::atomic<bool> deleted{ false };
458  	auto task = ([&added, &deleted, config, &node1] () {
459  		fake_websocket_client client (node1->websocket.server->listening_port ());
460  		client.send_message (R"json({"action": "subscribe", "topic": "confirmation", "ack": "true", "options": {}})json");
461  		client.await_ack ();
462  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
463  		std::string add_message = boost::str (boost::format (R"json({"action": "update", "topic": "confirmation", "ack": "true", "options": {"accounts_add": ["%1%"]}})json") % nano::dev::genesis_key.pub.to_account ());
464  		client.send_message (add_message);
465  		client.await_ack ();
466  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
467  		added = true;
468  		EXPECT_TRUE (client.get_response ());
469  		std::string delete_message = boost::str (boost::format (R"json({"action": "update", "topic": "confirmation", "ack": "true", "options": {"accounts_del": ["%1%"]}})json") % nano::dev::genesis_key.pub.to_account ());
470  		client.send_message (delete_message);
471  		client.await_ack ();
472  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::confirmation));
473  		deleted = true;
474  		EXPECT_FALSE (client.get_response (1s));
475  	});
476  	auto future = std::async (std::launch::async, task);
477  	ASSERT_TIMELY (5s, added);
478  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
479  	nano::keypair key;
480  	nano::state_block_builder builder;
481  	auto previous (node1->latest (nano::dev::genesis_key.pub));
482  	auto send = builder
483  				.account (nano::dev::genesis_key.pub)
484  				.previous (previous)
485  				.representative (nano::dev::genesis_key.pub)
486  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
487  				.link (key.pub)
488  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
489  				.work (*system.work.generate (previous))
490  				.build_shared ();
491  	node1->process_active (send);
492  	ASSERT_TIMELY (5s, deleted);
493  	previous = send->hash ();
494  	auto send2 = builder
495  				 .make_block ()
496  				 .account (nano::dev::genesis_key.pub)
497  				 .previous (previous)
498  				 .representative (nano::dev::genesis_key.pub)
499  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
500  				 .link (key.pub)
501  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
502  				 .work (*system.work.generate (previous))
503  				 .build_shared ();
504  	node1->process_active (send2);
505  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
506  }
507  TEST (websocket, vote)
508  {
509  	nano::test::system system;
510  	nano::node_config config = system.default_config ();
511  	config.websocket_config.enabled = true;
512  	config.websocket_config.port = system.get_available_port ();
513  	auto node1 (system.add_node (config));
514  	std::atomic<bool> ack_ready{ false };
515  	auto task = ([&ack_ready, config, &node1] () {
516  		fake_websocket_client client (node1->websocket.server->listening_port ());
517  		client.send_message (R"json({"action": "subscribe", "topic": "vote", "ack": true})json");
518  		client.await_ack ();
519  		ack_ready = true;
520  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::vote));
521  		return client.get_response ();
522  	});
523  	auto future = std::async (std::launch::async, task);
524  	ASSERT_TIMELY (5s, ack_ready);
525  	nano::keypair key;
526  	nano::state_block_builder builder;
527  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
528  	nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
529  	auto send = builder
530  				.account (nano::dev::genesis_key.pub)
531  				.previous (previous)
532  				.representative (nano::dev::genesis_key.pub)
533  				.balance (nano::dev::constants.genesis_amount - (node1->online_reps.delta () + 1))
534  				.link (key.pub)
535  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
536  				.work (*system.work.generate (previous))
537  				.build_shared ();
538  	node1->process_active (send);
539  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
540  	auto response = future.get ();
541  	ASSERT_TRUE (response);
542  	boost::property_tree::ptree event;
543  	std::stringstream stream;
544  	stream << response;
545  	boost::property_tree::read_json (stream, event);
546  	ASSERT_EQ (event.get<std::string> ("topic"), "vote");
547  }
548  TEST (websocket, vote_options_type)
549  {
550  	nano::test::system system;
551  	nano::node_config config = system.default_config ();
552  	config.websocket_config.enabled = true;
553  	config.websocket_config.port = system.get_available_port ();
554  	auto node1 (system.add_node (config));
555  	std::atomic<bool> ack_ready{ false };
556  	auto task = ([&ack_ready, config, &node1] () {
557  		fake_websocket_client client (node1->websocket.server->listening_port ());
558  		client.send_message (R"json({"action": "subscribe", "topic": "vote", "ack": true, "options": {"include_replays": "true", "include_indeterminate": "false"}})json");
559  		client.await_ack ();
560  		ack_ready = true;
561  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::vote));
562  		return client.get_response ();
563  	});
564  	auto future = std::async (std::launch::async, task);
565  	ASSERT_TIMELY (5s, ack_ready);
566  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () }));
567  	nano::websocket::message_builder builder;
568  	auto msg (builder.vote_received (vote, nano::vote_code::replay));
569  	node1->websocket.server->broadcast (msg);
570  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
571  	auto response = future.get ();
572  	ASSERT_TRUE (response);
573  	boost::property_tree::ptree event;
574  	std::stringstream stream;
575  	stream << response;
576  	boost::property_tree::read_json (stream, event);
577  	auto message_contents = event.get_child ("message");
578  	ASSERT_EQ (1, message_contents.count ("type"));
579  	ASSERT_EQ ("replay", message_contents.get<std::string> ("type"));
580  }
581  TEST (websocket, vote_options_representatives)
582  {
583  	nano::test::system system;
584  	nano::node_config config = system.default_config ();
585  	config.websocket_config.enabled = true;
586  	config.websocket_config.port = system.get_available_port ();
587  	auto node1 (system.add_node (config));
588  	std::atomic<bool> ack_ready{ false };
589  	auto task1 = ([&ack_ready, config, &node1] () {
590  		fake_websocket_client client (node1->websocket.server->listening_port ());
591  		std::string message = boost::str (boost::format (R"json({"action": "subscribe", "topic": "vote", "ack": "true", "options": {"representatives": ["%1%"]}})json") % nano::dev::genesis_key.pub.to_account ());
592  		client.send_message (message);
593  		client.await_ack ();
594  		ack_ready = true;
595  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::vote));
596  		auto response = client.get_response ();
597  		EXPECT_TRUE (response);
598  		boost::property_tree::ptree event;
599  		std::stringstream stream;
600  		stream << response;
601  		boost::property_tree::read_json (stream, event);
602  		EXPECT_EQ (event.get<std::string> ("topic"), "vote");
603  	});
604  	auto future1 = std::async (std::launch::async, task1);
605  	ASSERT_TIMELY (5s, ack_ready);
606  	nano::keypair key;
607  	auto balance = nano::dev::constants.genesis_amount;
608  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
609  	auto send_amount = node1->online_reps.delta () + 1;
610  	auto confirm_block = [&] () {
611  		nano::block_hash previous (node1->latest (nano::dev::genesis_key.pub));
612  		balance -= send_amount;
613  		nano::state_block_builder builder;
614  		auto send = builder
615  					.account (nano::dev::genesis_key.pub)
616  					.previous (previous)
617  					.representative (nano::dev::genesis_key.pub)
618  					.balance (balance)
619  					.link (key.pub)
620  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
621  					.work (*system.work.generate (previous))
622  					.build_shared ();
623  		node1->process_active (send);
624  	};
625  	confirm_block ();
626  	ASSERT_TIMELY (5s, future1.wait_for (0s) == std::future_status::ready);
627  	ack_ready = false;
628  	auto task2 = ([&ack_ready, config, &node1] () {
629  		fake_websocket_client client (node1->websocket.server->listening_port ());
630  		client.send_message (R"json({"action": "subscribe", "topic": "vote", "ack": "true", "options": {"representatives": ["xrb_invalid"]}})json");
631  		client.await_ack ();
632  		ack_ready = true;
633  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::vote));
634  		auto response = client.get_response ();
635  		EXPECT_TRUE (response);
636  	});
637  	auto future2 = std::async (std::launch::async, task2);
638  	ASSERT_TIMELY (5s, ack_ready);
639  	confirm_block ();
640  	ASSERT_TIMELY (5s, future2.wait_for (0s) == std::future_status::ready);
641  }
642  TEST (websocket, work)
643  {
644  	nano::test::system system;
645  	nano::node_config config = system.default_config ();
646  	config.websocket_config.enabled = true;
647  	config.websocket_config.port = system.get_available_port ();
648  	auto node1 (system.add_node (config));
649  	ASSERT_EQ (0, node1->websocket.server->subscriber_count (nano::websocket::topic::work));
650  	std::atomic<bool> ack_ready{ false };
651  	auto task = ([&ack_ready, config, &node1] () {
652  		fake_websocket_client client (node1->websocket.server->listening_port ());
653  		client.send_message (R"json({"action": "subscribe", "topic": "work", "ack": true})json");
654  		client.await_ack ();
655  		ack_ready = true;
656  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::work));
657  		return client.get_response ();
658  	});
659  	auto future = std::async (std::launch::async, task);
660  	ASSERT_TIMELY (5s, ack_ready);
661  	ASSERT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::work));
662  	nano::block_hash hash{ 1 };
663  	auto work (node1->work_generate_blocking (hash));
664  	ASSERT_TRUE (work.is_initialized ());
665  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
666  	auto response = future.get ();
667  	ASSERT_TRUE (response);
668  	std::stringstream stream;
669  	stream << response;
670  	boost::property_tree::ptree event;
671  	boost::property_tree::read_json (stream, event);
672  	ASSERT_EQ (event.get<std::string> ("topic"), "work");
673  	auto & contents = event.get_child ("message");
674  	ASSERT_EQ (contents.get<std::string> ("success"), "true");
675  	ASSERT_LT (contents.get<unsigned> ("duration"), 10000U);
676  	ASSERT_EQ (1, contents.count ("request"));
677  	auto & request = contents.get_child ("request");
678  	ASSERT_EQ (request.get<std::string> ("version"), nano::to_string (nano::work_version::work_1));
679  	ASSERT_EQ (request.get<std::string> ("hash"), hash.to_string ());
680  	ASSERT_EQ (request.get<std::string> ("difficulty"), nano::to_string_hex (node1->default_difficulty (nano::work_version::work_1)));
681  	ASSERT_EQ (request.get<double> ("multiplier"), 1.0);
682  	ASSERT_EQ (1, contents.count ("result"));
683  	auto & result = contents.get_child ("result");
684  	uint64_t result_difficulty;
685  	nano::from_string_hex (result.get<std::string> ("difficulty"), result_difficulty);
686  	ASSERT_GE (result_difficulty, node1->default_difficulty (nano::work_version::work_1));
687  	ASSERT_NEAR (result.get<double> ("multiplier"), nano::difficulty::to_multiplier (result_difficulty, node1->default_difficulty (nano::work_version::work_1)), 1e-6);
688  	ASSERT_EQ (result.get<std::string> ("work"), nano::to_string_hex (work.get ()));
689  	ASSERT_EQ (1, contents.count ("bad_peers"));
690  	auto & bad_peers = contents.get_child ("bad_peers");
691  	ASSERT_TRUE (bad_peers.empty ());
692  	ASSERT_EQ (contents.get<std::string> ("reason"), "");
693  }
694  TEST (websocket, bootstrap)
695  {
696  	nano::test::system system;
697  	nano::node_config config = system.default_config ();
698  	config.websocket_config.enabled = true;
699  	config.websocket_config.port = system.get_available_port ();
700  	auto node1 (system.add_node (config));
701  	ASSERT_EQ (0, node1->websocket.server->subscriber_count (nano::websocket::topic::bootstrap));
702  	std::atomic<bool> ack_ready{ false };
703  	auto task = ([&ack_ready, config, &node1] () {
704  		fake_websocket_client client (node1->websocket.server->listening_port ());
705  		client.send_message (R"json({"action": "subscribe", "topic": "bootstrap", "ack": true})json");
706  		client.await_ack ();
707  		ack_ready = true;
708  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::bootstrap));
709  		return client.get_response ();
710  	});
711  	auto future = std::async (std::launch::async, task);
712  	ASSERT_TIMELY (5s, ack_ready);
713  	node1->bootstrap_initiator.bootstrap (true, "123abc");
714  	ASSERT_TIMELY (5s, nullptr == node1->bootstrap_initiator.current_attempt ());
715  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
716  	auto response = future.get ();
717  	ASSERT_TRUE (response);
718  	std::stringstream stream;
719  	stream << response;
720  	boost::property_tree::ptree event;
721  	boost::property_tree::read_json (stream, event);
722  	ASSERT_EQ (event.get<std::string> ("topic"), "bootstrap");
723  	auto & contents = event.get_child ("message");
724  	ASSERT_EQ (contents.get<std::string> ("reason"), "started");
725  	ASSERT_EQ (contents.get<std::string> ("id"), "123abc");
726  	ASSERT_EQ (contents.get<std::string> ("mode"), "legacy");
727  	ASSERT_TIMELY (5s, !node1->bootstrap_initiator.in_progress ());
728  }
729  TEST (websocket, bootstrap_exited)
730  {
731  	nano::test::system system;
732  	nano::node_config config = system.default_config ();
733  	config.websocket_config.enabled = true;
734  	config.websocket_config.port = system.get_available_port ();
735  	auto node1 (system.add_node (config));
736  	std::atomic<bool> bootstrap_started{ false };
737  	nano::test::counted_completion subscribed_completion (1);
738  	std::thread bootstrap_thread ([node1, &system, &bootstrap_started, &subscribed_completion] () {
739  		std::shared_ptr<nano::bootstrap_attempt> attempt;
740  		while (attempt == nullptr)
741  		{
742  			std::this_thread::sleep_for (50ms);
743  			node1->bootstrap_initiator.bootstrap (true, "123abc");
744  			attempt = node1->bootstrap_initiator.current_attempt ();
745  		}
746  		ASSERT_NE (nullptr, attempt);
747  		bootstrap_started = true;
748  		EXPECT_FALSE (subscribed_completion.await_count_for (5s));
749  	});
750  	ASSERT_TIMELY (5s, bootstrap_started);
751  	std::atomic<bool> ack_ready{ false };
752  	auto task = ([&ack_ready, config, &node1] () {
753  		fake_websocket_client client (node1->websocket.server->listening_port ());
754  		client.send_message (R"json({"action": "subscribe", "topic": "bootstrap", "ack": true})json");
755  		client.await_ack ();
756  		ack_ready = true;
757  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::bootstrap));
758  		return client.get_response ();
759  	});
760  	auto future = std::async (std::launch::async, task);
761  	ASSERT_TIMELY (5s, ack_ready);
762  	subscribed_completion.increment ();
763  	bootstrap_thread.join ();
764  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
765  	auto response = future.get ();
766  	ASSERT_TRUE (response);
767  	std::stringstream stream;
768  	stream << response;
769  	boost::property_tree::ptree event;
770  	boost::property_tree::read_json (stream, event);
771  	ASSERT_EQ (event.get<std::string> ("topic"), "bootstrap");
772  	auto & contents = event.get_child ("message");
773  	ASSERT_EQ (contents.get<std::string> ("reason"), "exited");
774  	ASSERT_EQ (contents.get<std::string> ("id"), "123abc");
775  	ASSERT_EQ (contents.get<std::string> ("mode"), "legacy");
776  	ASSERT_EQ (contents.get<unsigned> ("total_blocks"), 0U);
777  	ASSERT_LT (contents.get<unsigned> ("duration"), 15000U);
778  }
779  TEST (websocket, ws_keepalive)
780  {
781  	nano::test::system system;
782  	nano::node_config config = system.default_config ();
783  	config.websocket_config.enabled = true;
784  	config.websocket_config.port = system.get_available_port ();
785  	auto node1 (system.add_node (config));
786  	auto task = ([&node1] () {
787  		fake_websocket_client client (node1->websocket.server->listening_port ());
788  		client.send_message (R"json({"action": "ping"})json");
789  		client.await_ack ();
790  	});
791  	auto future = std::async (std::launch::async, task);
792  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
793  }
794  TEST (websocket, telemetry)
795  {
796  	nano::test::system system;
797  	nano::node_config config = system.default_config ();
798  	config.websocket_config.enabled = true;
799  	config.websocket_config.port = system.get_available_port ();
800  	nano::node_flags node_flags;
801  	auto node1 (system.add_node (config, node_flags));
802  	config.peering_port = system.get_available_port ();
803  	config.websocket_config.enabled = true;
804  	config.websocket_config.port = system.get_available_port ();
805  	auto node2 (system.add_node (config, node_flags));
806  	nano::test::wait_peer_connections (system);
807  	std::atomic<bool> done{ false };
808  	auto task = ([config = node1->config, &node1, &done] () {
809  		fake_websocket_client client (node1->websocket.server->listening_port ());
810  		client.send_message (R"json({"action": "subscribe", "topic": "telemetry", "ack": true})json");
811  		client.await_ack ();
812  		done = true;
813  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::telemetry));
814  		return client.get_response ();
815  	});
816  	auto future = std::async (std::launch::async, task);
817  	ASSERT_TIMELY (10s, done);
818  	auto channel = node1->network.find_node_id (node2->get_node_id ());
819  	ASSERT_NE (channel, nullptr);
820  	ASSERT_TIMELY (5s, node1->telemetry.get_telemetry (channel->get_endpoint ()));
821  	ASSERT_TIMELY (10s, future.wait_for (0s) == std::future_status::ready);
822  	auto response = future.get ();
823  	std::stringstream stream;
824  	stream << response;
825  	boost::property_tree::ptree event;
826  	boost::property_tree::read_json (stream, event);
827  	ASSERT_EQ (event.get<std::string> ("topic"), "telemetry");
828  	auto & contents = event.get_child ("message");
829  	nano::jsonconfig telemetry_contents (contents);
830  	nano::telemetry_data telemetry_data;
831  	telemetry_data.deserialize_json (telemetry_contents, false);
832  	ASSERT_TRUE (nano::test::compare_telemetry (telemetry_data, *node2));
<span onclick='openModal()' class='match'>833  	ASSERT_EQ (contents.get<std::string> ("address"), node2->network.endpoint ().address ().to_string ());
834  	ASSERT_EQ (contents.get<uint16_t> ("port"), node2->network.endpoint ().port ());
835  	EXPECT_EQ (0, node2->websocket.server->subscriber_count (nano::websocket::topic::telemetry));
836  }
837  TEST (websocket, new_unconfirmed_block)
838  {
839  	nano::test::system system;
840  	nano::node_config config = system.default_config ();
</span>841  	config.websocket_config.enabled = true;
842  	config.websocket_config.port = system.get_available_port ();
843  	auto node1 (system.add_node (config));
844  	std::atomic<bool> ack_ready{ false };
845  	auto task = ([&ack_ready, config, node1] () {
846  		fake_websocket_client client (node1->websocket.server->listening_port ());
847  		client.send_message (R"json({"action": "subscribe", "topic": "new_unconfirmed_block", "ack": "true"})json");
848  		client.await_ack ();
849  		ack_ready = true;
850  		EXPECT_EQ (1, node1->websocket.server->subscriber_count (nano::websocket::topic::new_unconfirmed_block));
851  		return client.get_response ();
852  	});
853  	auto future = std::async (std::launch::async, task);
854  	ASSERT_TIMELY (5s, ack_ready);
855  	nano::state_block_builder builder;
856  	auto send1 = builder
857  				 .account (nano::dev::genesis_key.pub)
858  				 .previous (nano::dev::genesis->hash ())
859  				 .representative (nano::dev::genesis_key.pub)
860  				 .balance (nano::dev::constants.genesis_amount - 1)
861  				 .link (nano::dev::genesis_key.pub)
862  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
863  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
864  				 .build_shared ();
865  	ASSERT_EQ (nano::process_result::progress, node1->process_local (send1).value ().code);
866  	ASSERT_TIMELY (5s, future.wait_for (0s) == std::future_status::ready);
867  	boost::optional<std::string> response = future.get ();
868  	ASSERT_TRUE (response);
869  	std::stringstream stream;
870  	stream << response;
871  	boost::property_tree::ptree event;
872  	boost::property_tree::read_json (stream, event);
873  	ASSERT_EQ (event.get<std::string> ("topic"), "new_unconfirmed_block");
874  	auto message_contents = event.get_child ("message");
875  	ASSERT_EQ ("state", message_contents.get<std::string> ("type"));
876  	ASSERT_EQ ("send", message_contents.get<std::string> ("subtype"));
877  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</h3>
            <pre><code>1  #include "vizmapgks.h"
2  #include <gkswf.h>
3  TGksColor TVizMapContext::ColorLandscapeAbove = TGksColor(54, 92, 120);
4  TGksColor TVizMapContext::ColorAddFirstLevel = TGksColor(9, 7, 6);
5  TGksColor TVizMapContext::ColorAddSecondLevel = TGksColor(18, 14, 12);
6  TGksColor TVizMapContext::ColorLegendGridColor = TGksColor(192, 255, 255, 255);
7  TGksColor TVizMapContext::ColorPointCross = TGksColor(255, 220, 0);
8  TGksColor TVizMapContext::ColorSelPointCross = TGksColor(255, 145, 145);
9  TGksColor TVizMapContext::ColorPointFont = TGksColor(255, 220, 0);
10  TGksColor TVizMapContext::ColorSelPointFont = TGksColor(255, 255, 30);
11  TGksColor TVizMapContext::ColorLink = TGksColor(100, 100, 255, 100);
12  TGksColor TVizMapContext::ColorKeyWdFont = TGksColor(240,240,255);
13  TGksColor TVizMapContext::ColorCatNmFont = TGksColor(255,240,255);
14  TGksColor TVizMapContext::ColorZoomRect = TGksColor(100, 0, 0, 0); 
15  TGksColor TVizMapContext::ColorMgGlass = TGksColor(50, 0, 0, 0);
16  TGksColor TVizMapContext::ColorMgGlassWnd = TGksColor(192, 255, 255, 255);
17  TGksColor TVizMapContext::ColorMgGlassWndFrm = TGksColor(100, 0, 0, 0); 
18  TGksColor TVizMapContext::ColorMgGlassWndShadow = TGksColor(50, 0, 0, 0);
19  int TVizMapContext::SizePointCross = 2;
20  int TVizMapContext::PointNmWidth = 100;
21  int TVizMapContext::PointNmMxLines = 3;
22  double TVizMapContext::PointNmFontScale = 20.0;
23  int TVizMapContext::MgGlassWindowWidth = 150;
24  int TVizMapContext::RndKeyWdN = 3000;
25  double TVizMapContext::RelRadius = 0.2;
26  int TVizMapContext::KeyWdCandidates = 10;
27  double TVizMapContext::RelMnRptDist = 0.1;
28  double TVizMapContext::RelSparsity = 0.05;
29  void TVizMapContext::LoadColor() {
30      LandscapeCatColorV.Clr();
31      LandscapeCatColorV.Add(TGksColor(43, 76, 115));
32      LandscapeCatColorV.Add(TGksColor(53, 46, 115));
33      LandscapeCatColorV.Add(TGksColor(33, 106, 115));
34      LandscapeCatColorV.Add(TGksColor(63, 80, 170));
35      LandscapeCatColorV.Add(TGksColor(61, 106, 200));
36      LandscapeCatColorV.Add(TGksColor(71, 106, 190));
37      LandscapeCatColorV.Add(TGksColor(51, 106, 210));
38      LandscapeCatColorV.Add(TGksColor(81, 106, 180));
39      LandscapeCatColorV.Add(TGksColor(43, 91, 125));
40      LandscapeCatColorV.Add(TGksColor(43, 91, 135));
41      LandscapeCatColorV.Add(TGksColor(43, 91, 145));
42      LandscapeCatColorV.Add(TGksColor(43, 91, 155));
43      LandscapeCatColorV.Add(TGksColor(43, 106, 125));
44      LandscapeCatColorV.Add(TGksColor(43, 106, 135));
45      LandscapeCatColorV.Add(TGksColor(43, 106, 145));
46      LandscapeCatColorV.Add(TGksColor(43, 106, 155));
47  }
48  void TVizMapContext::LoadCatFullNms() {
49      CatFullNmH.AddDat("1POL", "CURRENT NEWS - POLITICS");
50      CatFullNmH.AddDat("2ECO", "CURRENT NEWS - ECONOMICS");
51      CatFullNmH.AddDat("3SPO", "CURRENT NEWS - SPORT");
52      CatFullNmH.AddDat("4GEN", "CURRENT NEWS - GENERAL");
53      CatFullNmH.AddDat("6INS", "CURRENT NEWS - INSURANCE");
54      CatFullNmH.AddDat("7RSK", "CURRENT NEWS - RISK NEWS");
55      CatFullNmH.AddDat("8YDB", "TEMPORARY");
56      CatFullNmH.AddDat("9BNX", "TEMPORARY");
57      CatFullNmH.AddDat("ADS10", "CURRENT NEWS - ADVERTISING");
58      CatFullNmH.AddDat("BNW14", "CURRENT NEWS - BUSINESS NEWS");
59      CatFullNmH.AddDat("BRP11", "CURRENT NEWS - BRANDS");
60      CatFullNmH.AddDat("C11", "STRATEGY/PLANS");
61      CatFullNmH.AddDat("C12", "LEGAL/JUDICIAL");
62      CatFullNmH.AddDat("C13", "REGULATION/POLICY");
63      CatFullNmH.AddDat("C14", "SHARE LISTINGS");
64      CatFullNmH.AddDat("C15", "PERFORMANCE");
65      CatFullNmH.AddDat("C151", "ACCOUNTS/EARNINGS");
66      CatFullNmH.AddDat("C1511", "ANNUAL RESULTS");
67      CatFullNmH.AddDat("C152", "COMMENT/FORECASTS");
68      CatFullNmH.AddDat("C16", "INSOLVENCY/LIQUIDITY");
69      CatFullNmH.AddDat("C17", "FUNDING/CAPITAL");
70      CatFullNmH.AddDat("C171", "SHARE CAPITAL");
71      CatFullNmH.AddDat("C172", "BONDS/DEBT ISSUES");
72      CatFullNmH.AddDat("C173", "LOANS/CREDITS");
73      CatFullNmH.AddDat("C174", "CREDIT RATINGS");
74      CatFullNmH.AddDat("C18", "OWNERSHIP CHANGES");
75      CatFullNmH.AddDat("C181", "MERGERS/ACQUISITIONS");
76      CatFullNmH.AddDat("C182", "ASSET TRANSFERS");
77      CatFullNmH.AddDat("C183", "PRIVATISATIONS");
78      CatFullNmH.AddDat("C21", "PRODUCTION/SERVICES");
79      CatFullNmH.AddDat("C22", "NEW PRODUCTS/SERVICES");
80      CatFullNmH.AddDat("C23", "RESEARCH/DEVELOPMENT");
81      CatFullNmH.AddDat("C24", "CAPACITY/FACILITIES");
82      CatFullNmH.AddDat("C31", "MARKETS/MARKETING");
83      CatFullNmH.AddDat("C311", "DOMESTIC MARKETS");
84      CatFullNmH.AddDat("C312", "EXTERNAL MARKETS");
85      CatFullNmH.AddDat("C313", "MARKET SHARE");
86      CatFullNmH.AddDat("C32", "ADVERTISING/PROMOTION");
87      CatFullNmH.AddDat("C33", "CONTRACTS/ORDERS");
88      CatFullNmH.AddDat("C331", "DEFENCE CONTRACTS");
89      CatFullNmH.AddDat("C34", "MONOPOLIES/COMPETITION");
90      CatFullNmH.AddDat("C41", "MANAGEMENT");
91      CatFullNmH.AddDat("C411", "MANAGEMENT MOVES");
92      CatFullNmH.AddDat("C42", "LABOUR");
93      CatFullNmH.AddDat("CCAT", "CORPORATE/INDUSTRIAL");
94      CatFullNmH.AddDat("E11", "ECONOMIC PERFORMANCE");
95      CatFullNmH.AddDat("E12", "MONETARY/ECONOMIC");
96      CatFullNmH.AddDat("E121", "MONEY SUPPLY");
97      CatFullNmH.AddDat("E13", "INFLATION/PRICES");
98      CatFullNmH.AddDat("E131", "CONSUMER PRICES");
99      CatFullNmH.AddDat("E132", "WHOLESALE PRICES");
100      CatFullNmH.AddDat("E14", "CONSUMER FINANCE");
101      CatFullNmH.AddDat("E141", "PERSONAL INCOME");
102      CatFullNmH.AddDat("E142", "CONSUMER CREDIT");
103      CatFullNmH.AddDat("E143", "RETAIL SALES");
104      CatFullNmH.AddDat("E21", "GOVERNMENT FINANCE");
105      CatFullNmH.AddDat("E211", "EXPENDITURE/REVENUE");
106      CatFullNmH.AddDat("E212", "GOVERNMENT BORROWING");
107      CatFullNmH.AddDat("E31", "OUTPUT/CAPACITY");
108      CatFullNmH.AddDat("E311", "INDUSTRIAL PRODUCTION");
109      CatFullNmH.AddDat("E312", "CAPACITY UTILIZATION");
110      CatFullNmH.AddDat("E313", "INVENTORIES");
111      CatFullNmH.AddDat("E41", "EMPLOYMENT/LABOUR");
112      CatFullNmH.AddDat("E411", "UNEMPLOYMENT");
113      CatFullNmH.AddDat("E51", "TRADE/RESERVES");
114      CatFullNmH.AddDat("E511", "BALANCE OF PAYMENTS");
115      CatFullNmH.AddDat("E512", "MERCHANDISE TRADE");
116      CatFullNmH.AddDat("E513", "RESERVES");
117      CatFullNmH.AddDat("E61", "HOUSING STARTS");
118      CatFullNmH.AddDat("E71", "LEADING INDICATORS");
119      CatFullNmH.AddDat("ECAT", "ECONOMICS");
120      CatFullNmH.AddDat("ENT12", "CURRENT NEWS - ENTERTAINMENT");
121      CatFullNmH.AddDat("G11", "SOCIAL AFFAIRS");
122      CatFullNmH.AddDat("G111", "HEALTH/SAFETY");
123      CatFullNmH.AddDat("G112", "SOCIAL SECURITY");
124      CatFullNmH.AddDat("G113", "EDUCATION/RESEARCH");
125      CatFullNmH.AddDat("G12", "INTERNAL POLITICS");
126      CatFullNmH.AddDat("G13", "INTERNATIONAL RELATIONS");
127      CatFullNmH.AddDat("G131", "DEFENCE");
128      CatFullNmH.AddDat("G14", "ENVIRONMENT");
129      CatFullNmH.AddDat("G15", "EUROPEAN COMMUNITY");
130      CatFullNmH.AddDat("G151", "EC INTERNAL MARKET");
131      CatFullNmH.AddDat("G152", "EC CORPORATE POLICY");
132      CatFullNmH.AddDat("G153", "EC AGRICULTURE POLICY");
133      CatFullNmH.AddDat("G154", "EC MONETARY/ECONOMIC");
134      CatFullNmH.AddDat("G155", "EC INSTITUTIONS");
135      CatFullNmH.AddDat("G156", "EC ENVIRONMENT ISSUES");
136      CatFullNmH.AddDat("G157", "EC COMPETITION/SUBSIDY");
137      CatFullNmH.AddDat("G158", "EC EXTERNAL RELATIONS");
138      CatFullNmH.AddDat("G159", "EC GENERAL");
139      CatFullNmH.AddDat("GCAT", "GOVERNMENT/SOCIAL");
140      CatFullNmH.AddDat("GCRIM", "CRIME, LAW ENFORCEMENT");
141      CatFullNmH.AddDat("GDEF", "DEFENCE");
142      CatFullNmH.AddDat("GDIP", "INTERNATIONAL RELATIONS");
143      CatFullNmH.AddDat("GDIS", "DISASTERS AND ACCIDENTS");
144      CatFullNmH.AddDat("GEDU", "EDUCATION");
145      CatFullNmH.AddDat("GENT", "ARTS, CULTURE, ENTERTAINMENT");
146      CatFullNmH.AddDat("GENV", "ENVIRONMENT AND NATURAL WORLD");
147      CatFullNmH.AddDat("GFAS", "FASHION");
148      CatFullNmH.AddDat("GHEA", "HEALTH");
149      CatFullNmH.AddDat("GJOB", "LABOUR ISSUES");
150      CatFullNmH.AddDat("GMIL", "MILLENNIUM ISSUES");
151      CatFullNmH.AddDat("GOBIT", "OBITUARIES");
152      CatFullNmH.AddDat("GODD", "HUMAN INTEREST");
153      CatFullNmH.AddDat("GPOL", "DOMESTIC POLITICS");
154      CatFullNmH.AddDat("GPRO", "BIOGRAPHIES, PERSONALITIES, PEOPLE");
155      CatFullNmH.AddDat("GREL", "RELIGION");
156      CatFullNmH.AddDat("GSCI", "SCIENCE AND TECHNOLOGY");
157      CatFullNmH.AddDat("GSPO", "SPORTS");
158      CatFullNmH.AddDat("GTOUR", "TRAVEL AND TOURISM");
159      CatFullNmH.AddDat("GVIO", "WAR, CIVIL WAR");
160      CatFullNmH.AddDat("GVOTE", "ELECTIONS");
161      CatFullNmH.AddDat("GWEA", "WEATHER");
162      CatFullNmH.AddDat("GWELF", "WELFARE, SOCIAL SERVICES");
163      CatFullNmH.AddDat("M11", "EQUITY MARKETS");
164      CatFullNmH.AddDat("M12", "BOND MARKETS");
165      CatFullNmH.AddDat("M13", "MONEY MARKETS");
166      CatFullNmH.AddDat("M131", "INTERBANK MARKETS");
167      CatFullNmH.AddDat("M132", "FOREX MARKETS");
168      CatFullNmH.AddDat("M14", "COMMODITY MARKETS");
169      CatFullNmH.AddDat("M141", "SOFT COMMODITIES");
170      CatFullNmH.AddDat("M142", "METALS TRADING");
171      CatFullNmH.AddDat("M143", "ENERGY MARKETS");
172      CatFullNmH.AddDat("MCAT", "MARKETS");
173      CatFullNmH.AddDat("MEUR", "EURO CURRENCY");
174      CatFullNmH.AddDat("PRB13", "CURRENT NEWS - PRESS RELEASE WIRES");
175  }
176  TFltRect TVizMapContext::GetZoomRect() {
177      if (!ZoomS.Empty()) {
178          return ZoomS.Top();
179      } else {
180          return TFltRect(0.0, 0.0, 1.0, 1.0);
181      }
182  }
183  void TVizMapContext::RenderLandscapeBmp() {
184      if (SelLandscape.Empty()) return;
185      TFltRect ZoomRect = GetZoomRect();
186      const int MaxWidth = SelLandscape->GetXDim();
187      const int MaxHeight = SelLandscape->GetYDim();
188      const int Width = TFlt::Round(ZoomRect.GetXLen()*MaxWidth);
189      const int Height = TFlt::Round(ZoomRect.GetYLen()*MaxHeight);
190      const int LeftX = TFlt::Round(ZoomRect.GetMnX()*MaxWidth);
191      const int TopY = TFlt::Round(ZoomRect.GetMnY()*MaxHeight);
192      if (Width > 0 && Height > 0) {        
193          const TSFltVV& HeightVV = SelLandscape->HeightVV();
194              Assert(SelLandscape->GetLevels() == 2);
195              const double First = SelLandscape->GetLevel(0);
196              const double Second = SelLandscape->GetLevel(1);
197              LandscapeBmp = TGksBitmap::New(Width, Height, ColorLandscapeAbove);
198              for (int X = 0; X < Width; X++) {
199                  for (int Y = 0; Y < Height; Y++) {
200                      double Val = HeightVV(LeftX+X, TopY+Y);
201                      if (Val > Second) { Val = Second + 3*(Val - Second); }
202                      TGksColor PixelColor = ColorLandscapeAbove.Add(
203                          TFlt::Round(Val*34), TFlt::Round(Val*28), TFlt::Round(Val*24));
204                      if (Val > Second) { PixelColor = PixelColor.Add(ColorAddSecondLevel); } 
205                      if (Val > First) { PixelColor = PixelColor.Add(ColorAddFirstLevel); }
206                      LandscapeBmp->SetPixel(X, Y, PixelColor);
207                  }
208              }
209      } else {
210          LandscapeBmp = TGksBitmap::New(1, 1, ColorLandscapeAbove);
211      }
212  }
213  void TVizMapContext::ResetMgGlassSize() { 
214      TFltRect ZoomRect = GetZoomRect();
215      MgGlassSize = 0.2 * TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen()); 
216  }
217  void TVizMapContext::ResetMgGlassKeyWd(const int& MgGlassKeyWds) {
218      MgGlassPoints = VizMapFrame->GenKeyWd(TFltV::GetV(MouseX, MouseY), 
219          MgGlassSize, MgGlassKeyWds, MgGlassKeyWdV, false, false);
220  }
221  void TVizMapContext::ResetKeyWd() {
222      TFltRect ZoomRect = GetZoomRect();
223      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
224      const double Radius = RelRadius * MnZoomRectSize; 
225      VizMapFrame->GenKeyWds(RndKeyWdN, Radius, KeyWdCandidates, 0, ZoomRect); 
226  }
227  void TVizMapContext::ResetNearPointN() {
228      double MnDist = TFlt::Mx;
229      NearPointN = -1;
230      int Points = VizMapFrame->GetPoints();
231      for (int PointN = 0; PointN < Points; PointN++) {
232          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
233          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
234          const double Dist = TMath::Sqr(PointX - MouseX) + 
235              TMath::Sqr(PointY - MouseY);
236          if (Dist < MnDist) { MnDist = Dist; NearPointN = PointN; }
237      }
238      if (TMath::Sqrt(MnDist) > 0.1) { NearPointN = -1; }
239  }
240  inline double TVizMapContext::GetMapCoord(const int& ScreenCoord, 
241          const int& ScreenLen, const double& MapMn, const double& MapLen) {
242      return MapMn + MapLen*(double(ScreenCoord)/double(ScreenLen));
243  }
244  inline int TVizMapContext::GetScreenCoord(const double& MapCoord, const double& MapMn, 
245          const double& MapLen, const int& ScreenLen) {
246      return TFlt::Round(ScreenLen * ((MapCoord - MapMn)/MapLen));
247  }
248  int TVizMapContext::GetEncoderClsid(const TStr& EncoderType, CLSID* pClsid) {
249      const int StrLen = EncoderType.Len() + 1;
250      WCHAR* format = new WCHAR[StrLen];
251      const int Res = MultiByteToWideChar(CP_ACP, 0, 
252          EncoderType.CStr(), StrLen, format, StrLen);
253      UINT  num = 0;          
254      UINT  size = 0;         
255      Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;
256      Gdiplus::GetImageEncodersSize(&num, &size);
257      if (size == 0) { return -1; } 
258      pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
259      if(pImageCodecInfo == NULL) { return -1; } 
260      Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);
261      for(UINT j = 0; j < num; ++j) {
262          if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
263              *pClsid = pImageCodecInfo[j].Clsid;
264              free(pImageCodecInfo);
265              return j;  
266          }    
267      }
268      free(pImageCodecInfo);
269      return -1;  
270  }
271  void TVizMapContext::ResetFrame() {
272      if (VizMapFrame->GetLandscapes() > 0) {
273          SelLandscape = VizMapFrame->GetLandscape(0); 
274          RenderLandscapeBmp();
275      }
276      ResetKeyWd(); SelPointV.Clr();
277  }
278  TVizMapContext::TVizMapContext(PVizMap _VizMap): 
279          VizMap(_VizMap), VizMapFrameN(0),
280          VizMapFrame(_VizMap->GetFirst()), SelMode(vmsmZoom), 
281          MgGlassPoints(0), MouseInP(false), LeftButtonDownP(false), 
282          MgGlassSize(0.2), NearPointN(-1) { 
283      LoadColor();
284      LoadCatFullNms();
285      ResetFrame();
286  }
287  void TVizMapContext::SetVizMapFrame(const int& NewVizMapFrameN) {
288      VizMapFrameN = NewVizMapFrameN;
289      VizMapFrame = VizMap->GetVizMapFrame(VizMapFrameN);
290      ResetFrame();
291  }
292  void TVizMapContext::SaveVrml(const TStr& VrmlFNm, bool ShowPointNmP, bool ShowKeyWdP) {    
293      VizMapFrame->SaveVrml(VrmlFNm, SelLandscape, ShowPointNmP, !ShowPointNmP,  ShowKeyWdP);
294  }
295  void TVizMapContext::PaintEmpty(PGks Gks) {
<span onclick='openModal()' class='match'>296      Gks->SetBrush(TGksBrush::New(ColorLandscapeAbove));
297      Gks->FillRect(-1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
298  }
299  void TVizMapContext::Paint(PGks Gks, const bool& ShowPointNmP, const int& PointFontSize,
300          const int& PointNmFontScale, const double& PointWgtThreshold, const int& CatId,
</span>301          const bool& ShowCatNmP, const bool& ShowKeyWdP, const int& KeyWdFontSize, 
302          const bool& ShowMgGlassP, const int& LegendGridWidth, const int& LegendGridHeight) {
303      if (!SelLandscape.Empty()) { PaintLandscape(Gks); } 
304      else { PaintEmpty(Gks); }
305      PaintLegendGrid(Gks, LegendGridWidth, LegendGridHeight);
306      PaintLinks(Gks);
307      TVec<TFltRect> PointNmRectV;
308      if (ShowPointNmP) { 
309          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
310              PointWgtThreshold, CatId, ShowMgGlassP, PointNmRectV); 
311      } else { 
312          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
313              TFlt::Mx, CatId, ShowMgGlassP, PointNmRectV); 
314      }
315      if (ShowCatNmP && !SelLandscape.Empty()) { 
316          PaintCatNms(Gks, KeyWdFontSize, PointNmRectV); };
317      if (ShowKeyWdP) { PaintKeyWds(Gks, KeyWdFontSize, PointNmRectV); }
318      if (LeftButtonDownP) { PaintZoomRect(Gks); }
319      else if (MouseInP && ShowMgGlassP) { PaintMgGlass(Gks, KeyWdFontSize); }
320  }
321  void TVizMapContext::PaintLandscape(PGks Gks){
322      Gks->Bitmap(LandscapeBmp, -1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
323  }
324  void TVizMapContext::PaintLegendGrid(PGks Gks, 
325          const int& LegendGridWidth, const int& LegendGridHeight) {
326      Gks->SetPen(TGksPen::New(ColorLegendGridColor));
327      for (int LineN = 1; LineN < LegendGridWidth; LineN++) {
328          const double RelativeWidth = double(LineN) / double(LegendGridWidth);
329          const int X = TFlt::Round(RelativeWidth * Gks->GetWidth());
330          Gks->Line(X, -1, X, Gks->GetHeight());
331      }
332      for (int LineN = 1; LineN < LegendGridHeight; LineN++) {
333          const double RelativeHeight = double(LineN) / double(LegendGridHeight);
334          const int Y = TFlt::Round(RelativeHeight * Gks->GetHeight());
335          Gks->Line(-1, Y, Gks->GetWidth(), Y);
336      }
337  }
338  void TVizMapContext::PaintLinks(PGks Gks) {
339      int Links = VizMapFrame->GetLinks();
340      TFltRect ZoomRect = GetZoomRect();
341      for (int LinkN = 0; LinkN < Links; LinkN++) {
342          PVizMapLink Link = VizMapFrame->GetLink(LinkN);
343          PVizMapPoint SrcPoint = VizMapFrame->GetPoint(Link->GetSrcPointN());
344          PVizMapPoint DstPoint = VizMapFrame->GetPoint(Link->GetDstPointN());
345          const double SrcPointX = SrcPoint->GetPointX(), SrcPointY = SrcPoint->GetPointY();
346          const double DstPointX = DstPoint->GetPointX(), DstPointY = DstPoint->GetPointY();
347          const int SrcX = GetScreenCoord(SrcPointX, ZoomRect.GetMnX(), 
348              ZoomRect.GetXLen(), Gks->GetWidth());
349          const int SrcY = GetScreenCoord(SrcPointY, ZoomRect.GetMnY(), 
350              ZoomRect.GetYLen(), Gks->GetHeight());
351          const int DstX = GetScreenCoord(DstPointX, ZoomRect.GetMnX(), 
352              ZoomRect.GetXLen(), Gks->GetWidth());
353          const int DstY = GetScreenCoord(DstPointY, ZoomRect.GetMnY(), 
354              ZoomRect.GetYLen(), Gks->GetHeight());
355          PaintArrow(Gks, SrcX, SrcY, DstX, DstY, 3);
356      }
357  }
358  void TVizMapContext::PaintArrow(PGks Gks, const int& SrcX, const int& SrcY, 
359          const int& DstX, const int& DstY, const int& Width) {
360      Gks->SetPen(TGksPen::New(ColorLink, gpmCopy, gpsSolid, Width));
361      Gks->Line(SrcX, SrcY, DstX, DstY);
362      TFltV DirectionV = TFltV::GetV(DstX - SrcX, DstY - SrcY); 
363      TLinAlg::Normalize(DirectionV);
364      const int HeadSize = TFlt::Round(2.5*Width); 
365      const double AngleRad = 0.75*TMath::Pi;
366      const int dX1 = TFlt::Round(HeadSize*DirectionV[0]);
367      const int dY1 = TFlt::Round(HeadSize*DirectionV[1]);
368      double dxx, dyy;
369      TLinAlg::Rotate(DirectionV[0], DirectionV[1], AngleRad, dxx, dyy);
370      const int dX2 = TFlt::Round(HeadSize*dxx);
371      const int dY2 = TFlt::Round(HeadSize*dyy);
372      TLinAlg::Rotate(DirectionV[0], DirectionV[1], -AngleRad, dxx, dyy);
373      const int dX3 = TFlt::Round(HeadSize*dxx);
374      const int dY3 = TFlt::Round(HeadSize*dyy);
375      TGksSPointV HeadPointV(3, 0);
376      HeadPointV.Add(TGksSPoint(DstX, DstY));
377      HeadPointV.Add(TGksSPoint(DstX-dX1+dX2, DstY-dY1+dY2));
378      HeadPointV.Add(TGksSPoint(DstX-dX1+dX3, DstY-dY1+dY3)); 
379      Gks->SetBrush(TGksBrush::New(ColorLink));
380      Gks->Polygon(HeadPointV);
381  }
382  void TVizMapContext::PaintPoints(PGks Gks, const int& PointFontSize, 
383          const int& PointNmFontScale, const double& PointWgtThreshold, 
384          const int& CatId, const bool& ShowMgGlassP,
385          TVec<TFltRect>& PointNmRectV) {
386      int Points = VizMapFrame->GetPoints();
387      TFltRect ZoomRect = GetZoomRect();
388      for (int PointN = 0; PointN < Points; PointN++) {
389          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
390          bool IsSelPointP = SelPointV.IsInBin(PointN);
391          if (IsSelPointP || ((NearPointN == PointN) && !ShowMgGlassP)) { continue; }
392          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
393          if (ZoomRect.IsXYIn(PointX, PointY)) {
394              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
395                  ZoomRect.GetXLen(), Gks->GetWidth());
396              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
397                  ZoomRect.GetYLen(), Gks->GetHeight());
398              bool IsCatP = Point->IsCatId(CatId);
399              if (Point->IsPointNm() && 
400                  ((Point->GetWgt() > PointWgtThreshold) || IsSelPointP)) {
401                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
402                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
403              } else {
404                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
405              }
406          }
407      }
408      for (int SelPointN = 0; SelPointN < SelPointV.Len(); SelPointN++) {
409          const int PointN = SelPointV[SelPointN];
410          if ((NearPointN == PointN) && !ShowMgGlassP) { continue; }
411          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
412          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
413          if (ZoomRect.IsXYIn(PointX, PointY)) {
414              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
415                  ZoomRect.GetXLen(), Gks->GetWidth());
416              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
417                  ZoomRect.GetYLen(), Gks->GetHeight());
418              bool IsCatP = Point->IsCatId(CatId);
419              if (Point->IsPointNm()) {
420                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
421                      PointFontSize, PointNmFontScale, true, IsCatP));
422              } else {
423                  PaintPointCross(Gks, X, Y, true, IsCatP);
424              }
425          }
426      }
427      if (!ShowMgGlassP && (NearPointN != -1)) {
428          PVizMapPoint Point = VizMapFrame->GetPoint(NearPointN);
429          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
430          if (ZoomRect.IsXYIn(PointX, PointY)) {
431              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
432                  ZoomRect.GetXLen(), Gks->GetWidth());
433              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
434                  ZoomRect.GetYLen(), Gks->GetHeight());
435              bool IsCatP = Point->IsCatId(CatId);
436              bool IsSelPointP = SelPointV.IsInBin(NearPointN);
437              if (Point->IsPointNm()) {
438                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
439                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
440              } else {
441                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
442              }
443          }
444      }
445  }
446  void TVizMapContext::PaintPointCross(PGks Gks, const int& X, 
447          const int& Y, const bool& SelPointP, const bool& IsCatP) {
448      Gks->SetPen(TGksPen::New(SelPointP ? ColorSelPointCross : ColorPointCross));
449      Gks->Line(X - SizePointCross, Y - SizePointCross, 
450                X + SizePointCross, Y + SizePointCross);
451      Gks->Line(X - SizePointCross, Y + SizePointCross, 
452                X + SizePointCross, Y - SizePointCross);
453      if (IsCatP) {
454          Gks->Line(X - SizePointCross + 1, Y - SizePointCross, 
455                    X + SizePointCross + 1, Y + SizePointCross);
456          Gks->Line(X - SizePointCross + 1, Y + SizePointCross, 
457                    X + SizePointCross + 1, Y - SizePointCross);
458      }
459  }
460  TFltRect TVizMapContext::PaintPointNm(PGks Gks, PVizMapPoint Point, const int& X, 
461          const int& Y, const int& PointFontSize, const int& PointNmFontScale, 
462          const bool& SelPointP, const bool& IsCatP) {
463      TStr PointNm = Point->GetPointNm(); 
464      PointNm.ChangeChAll('_', ' ');
465      if (PointNm.IsStrIn("[[")) {
466          const int StartPos = PointNm.SearchStr("[[");
467          PointNm = PointNm.Left(StartPos - 1);
468      }
469      TGksColor FontColor = SelPointP ? ColorSelPointFont : ColorPointFont;
470      const int FontSize = PointFontSize + TFlt::Round(Point->GetWgt()*PointNmFontScale);
471      Gks->SetFont(TGksFont::New("ARIAL", FontSize, FontColor));
472      TStr ScreenPointNm = Gks->BreakTxt(PointNm, " ", "", PointNmWidth, PointNmMxLines);
473      const int HalfTxtWidth = Gks->GetTxtWidth(ScreenPointNm) / 2;
474      const int HalfTxtHeight = Gks->GetTxtHeight(ScreenPointNm) / 2;
475      const int MnX = X - HalfTxtWidth;
476      int CurrY = Y - HalfTxtHeight;
477      TStrV LineV; ScreenPointNm.SplitOnAllCh('\n', LineV);
478      for (int LineN = 0; LineN < LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks->GetTxtWidth(LineV[LineN]) / 2;
480          const int LineHeight = Gks->GetTxtHeight(LineV[LineN]);
481          Gks->PutTxt(LineV[LineN], MnX + (HalfTxtWidth - HalfLineWidth), CurrY);
482          CurrY += LineHeight-3;
483      }
484      return TFltRect(X - HalfTxtWidth, Y - HalfTxtHeight,
485          X + HalfTxtWidth, Y + HalfTxtHeight - LineV.Len()*3);
486  }
487  void TVizMapContext::PaintCatNms(PGks Gks, const int& KeyWdFontSize, 
488          TVec<TFltRect>& PointNmRectV) {
489      TIntH CatH; TIntFltPrH CatPosH;
490      PBowDocBs BowDocBs = VizMapFrame->GetKeyWdBow();
491      const int Points = VizMapFrame->GetPoints();
492      for (int PointN = 0; PointN < Points; PointN++) {
493          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
494          const int DId = Point->GetDocId();
495          const int CIds = BowDocBs->GetDocCIds(DId);
496          for (int CIdN = 0; CIdN < CIds; CIdN++) {
497              const int CId = BowDocBs->GetDocCId(DId, CIdN);
498              CatH.AddDat(CId)++;
499              CatPosH.AddDat(CId).Val1 += Point->GetPointX();
500              CatPosH.AddDat(CId).Val2 += Point->GetPointY();
501          }
502      }
503      CatH.SortByDat(false); 
504      const int TopCats = Points > 100 ? 6 : 4; 
505      TFltRect ZoomRect = GetZoomRect();    
506      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize + 3, ColorCatNmFont));
507      TVec<TFltRect> CatNmRectV; TVec<TFltV> CatNmPosV;
508      const int MnSize = TInt::GetMn(Gks->GetWidth(), Gks->GetHeight());
509      const int MnDist = TFlt::Round(0.3 * double(MnSize));
510      int Cats = 0, CatKeyId = CatH.FFirstKeyId();
511      while (CatH.FNextKeyId(CatKeyId)) {
512          if (Cats == TopCats) { break; } 
513          if (double(CatH[CatKeyId]) / double(Points) < 0.05) { break; } 
514          const int CId = CatH.GetKey(CatKeyId);
515          TStr CatNm = BowDocBs->GetCatNm(CId);
516          if (CatFullNmH.IsKey(CatNm)) {
517              CatNm = CatFullNmH.GetDat(CatNm);
518          } else { continue; }
519          TFltPr CatPos = CatPosH.GetDat(CId);
520          const int CatCount = CatH.GetDat(CId); IAssert(CatCount > 0);
521          const double CatX = CatPos.Val1 / double(CatCount);
522          const double CatY = CatPos.Val2 / double(CatCount);
523          if (!ZoomRect.IsXYIn(CatX, CatY)) { continue; }
524          const int HalfTxtWidth = Gks->GetTxtWidth(CatNm) / 2;
525          const int HalfTxtHeight = Gks->GetTxtHeight(CatNm) / 2;
526          const int X = GetScreenCoord(CatX , ZoomRect.GetMnX(), 
527              ZoomRect.GetXLen(), Gks->GetWidth());
528          const int Y = GetScreenCoord(CatY, ZoomRect.GetMnY(), 
529              ZoomRect.GetYLen(), Gks->GetHeight());
530          int CatNmDist = MnSize; TFltV CatNmPos = TFltV::GetV(double(X), double(Y));
531          for (int CatNmPosN = 0; CatNmPosN < CatNmPosV.Len(); CatNmPosN++) {
532              const double Dist = TLinAlg::EuclDist(CatNmPosV[CatNmPosN], CatNmPos);
533              CatNmDist = TInt::GetMn(TFlt::Round(Dist), CatNmDist);
534          }
535          if (CatNmDist < MnDist) { continue; }
536          TFltRect CatNmRect(X - HalfTxtWidth, Y - HalfTxtHeight,
537              X + HalfTxtWidth, Y + HalfTxtHeight);
538          bool DoDraw = true; const int Rects = CatNmRectV.Len();
539          for (int RectN = 0; (RectN < Rects) && DoDraw; RectN++) {
540              DoDraw = !TFltRect::Intersection(CatNmRect, CatNmRectV[RectN]); }
541          if (!DoDraw) { continue; }
542          Gks->PutTxt(CatNm, X - HalfTxtWidth, Y - HalfTxtHeight); 
543          CatNmRectV.Add(CatNmRect); Cats++;
544          CatNmPosV.Add(CatNmPos);
545      }
546      PointNmRectV.AddV(CatNmRectV);
547  }
548  void TVizMapContext::PaintKeyWds(PGks Gks, const int& KeyWdFontSize, 
549          TVec<TFltRect>& PointNmRectV) {
550      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, ColorKeyWdFont));
551      TFltRect ZoomRect = GetZoomRect();    
552      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
553      const double MnRptDist = RelMnRptDist * MnZoomRectSize;
554      const double Sparsity = RelSparsity * MnZoomRectSize;
555      TVizMapKeyWdV OkKeyWdV;
556      int KeyWds = VizMapFrame->GetKeyWds();
557      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
558          PVizMapKeyWd KeyWd = VizMapFrame->GetKeyWd(KeyWdN);
559          TStr KeyWdStr = KeyWd->GetKeyWdStr().GetLc();
560          const double KeyWdX = KeyWd->GetKeyWdX();
561          const double KeyWdY = KeyWd->GetKeyWdY();
562          if (ZoomRect.IsXYIn(KeyWdX, KeyWdY)) {
563              const int X = GetScreenCoord(KeyWdX, ZoomRect.GetMnX(), 
564                  ZoomRect.GetXLen(), Gks->GetWidth());
565              const int Y = GetScreenCoord(KeyWdY, ZoomRect.GetMnY(), 
566                  ZoomRect.GetYLen(), Gks->GetHeight());
567              const int HalfTxtWidth = Gks->GetTxtWidth(KeyWdStr) / 2;
568              const int HalfTxtHeight = Gks->GetTxtHeight(KeyWdStr) / 2;
569              TFltRect KeyWdRect(X - HalfTxtWidth, Y - HalfTxtHeight,
570                  X + HalfTxtWidth, Y + HalfTxtHeight);
571              bool DoDrawP = true; const int Rects = PointNmRectV.Len();
572              for (int RectN = 0; RectN < Rects; RectN++) {
573                  if (TFltRect::Intersection(KeyWdRect, PointNmRectV[RectN])) { 
574                      DoDrawP = false; break; }
575              }
576              if (!DoDrawP) { continue; } 
577              TFltV KeyWdCoodV = TFltV::GetV(KeyWdX, KeyWdY);
578              const int OkKeyWds = OkKeyWdV.Len(); bool KeyWdOkP = true;
579              for (int OkKeyWdN = 0; OkKeyWdN < OkKeyWds; OkKeyWdN++) {
580                  PVizMapKeyWd OkKeyWd = OkKeyWdV[OkKeyWdN];
581                  TStr OkKeyWdStr = OkKeyWd->GetKeyWdStr().GetLc();
582                  const double Dist = TLinAlg::EuclDist(KeyWdCoodV, OkKeyWd->GetCoordV());
583                  if (Dist < Sparsity) { KeyWdOkP = false; break; }
584                  if (OkKeyWdStr == KeyWdStr) {
585                      if (Dist < MnRptDist) { KeyWdOkP = false; break; }
586                  }
587              }
588              if (!KeyWdOkP) { continue; } 
589              Gks->PutTxt(KeyWdStr, X - HalfTxtWidth, Y - HalfTxtHeight); 
590              PointNmRectV.Add(KeyWdRect); OkKeyWdV.Add(KeyWd);
591          }
592      }
593  }
594  void TVizMapContext::PaintZoomRect(PGks Gks) {
595      Gks->SetPen(TGksPen::New(ColorZoomRect, gpmCopy, gpsSolid, 2));
596      Gks->FrameRect(DownX, DownY, ScreenX, ScreenY);
597  }
598  void TVizMapContext::PaintMgGlass(PGks Gks, const int& KeyWdFontSize) {
599      TFltRect ZoomRect = GetZoomRect();
600      int SizeX = TFlt::Round((MgGlassSize/ZoomRect.GetXLen()) * Gks->GetWidth());
601      int SizeY = TFlt::Round((MgGlassSize/ZoomRect.GetYLen()) * Gks->GetHeight());
602      Gks->SetBrush(TGksBrush::New(ColorMgGlass));
603      Gks->FillEllipse(ScreenX-SizeX, ScreenY-SizeY, ScreenX+SizeX, ScreenY+SizeY);
604      if (MgGlassKeyWdV.Len() > 0) {
605          Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, TGksColor::GetBlack(), TFSet()|gfsBold));
606          TStr KeyWdStr = Gks->BreakTxt(MgGlassKeyWdV, ", ", ",", MgGlassWindowWidth);       
607          TStr NearPointStr;
608          if (NearPointN != -1) {
609              PVizMapPoint NearPoint = VizMapFrame->GetPoint(NearPointN);
610              if (NearPoint->IsPointNm()) {
611                  TStr NearPointNm = NearPoint->GetPointNm();
612                  if (NearPointNm.IsStrIn("[[")) {
613                      const int StartPos = NearPointNm.SearchStr("[[");
614                      NearPointNm = NearPointNm.Left(StartPos - 1);
615                  }
616                  NearPointStr = Gks->BreakTxt(NearPointNm, 
617                      " ", "", MgGlassWindowWidth, 1);
618                  NearPointStr.DelChAll('\n');
619                  NearPointStr += "\n";
620              }
621          }
622          TStr DocCountStr = "#documents = " + MgGlassPoints.GetStr() + "\n";
623          KeyWdStr = NearPointStr + DocCountStr + KeyWdStr;
624          int WndWidth = Gks->GetTxtWidth(KeyWdStr) + 6;
625          int WndHeight = Gks->GetTxtHeight(KeyWdStr) + 6;
626          int PosX = ScreenX + 20, PosY = ScreenY + 20;
627          if (PosX + WndWidth > Gks->GetWidth()) {
628              PosX = ScreenX - 20 - WndWidth; }
629          if (PosY + WndHeight > Gks->GetHeight()) {
630              PosY = ScreenY - 20 - WndHeight; }
631          Gks->SetBrush(TGksBrush::New(ColorMgGlassWndShadow));
632          Gks->FillRect(PosX + 5, PosY + 5, 
633              PosX + WndWidth + 5, PosY + WndHeight + 5);
634          Gks->SetBrush(TGksBrush::New(ColorMgGlassWnd));
635          Gks->SetPen(TGksPen::New(ColorMgGlassWndFrm));
636          Gks->Rectangle(PosX, PosY, 
637              PosX + WndWidth, PosY + WndHeight);
638          Gks->PutTxt(KeyWdStr, PosX+3, PosY+3);
639      }
640  }
641  void TVizMapContext::Export(const TStr& FNm, const TStr& EncoderType, const int& Width, 
642          const int& Height, const bool& ShowPointNmP, const int& PointFontSize, 
643          const int& PointNmFontScale, const double& PointWgtThreshold, const bool& ShowCatNmP,
644          const bool& ShowKeyWdP, const int& KeyWdFontSize, const bool& ShowMgGlassP, 
645          const int& LegendGridWidth, const int& LegendGridHeight) {
646      Gdiplus::Bitmap* Bmp = new Gdiplus::Bitmap(Width, Height);
647      Gdiplus::Graphics* g = Gdiplus::Graphics::FromImage(Bmp);
648      PGks BmpGks = TWfGks::New();
649      HDC HdcHandle = g->GetHDC(); BmpGks->BeginPaint(HdcHandle);
650      Paint(BmpGks, ShowPointNmP, PointFontSize, PointNmFontScale,
651          PointWgtThreshold, -1, ShowCatNmP, ShowKeyWdP, KeyWdFontSize, ShowMgGlassP, 
652          LegendGridWidth, LegendGridHeight);
653      BmpGks->EndPaint(); g->ReleaseHDC(HdcHandle);
654      WCHAR* FNmWChar = new WCHAR[FNm.Len() + 1];
655      const int Res = MultiByteToWideChar(CP_ACP, 0, 
656          FNm.CStr(), FNm.Len() + 1, FNmWChar, FNm.Len() + 1);
657      CLSID pngClsid; GetEncoderClsid(EncoderType, &pngClsid);
658      Bmp->Save(FNmWChar, &pngClsid, NULL);
659      delete FNmWChar; delete Bmp; delete g;
660  }
661  bool TVizMapContext::MouseMove(const int& X, const int& Y, 
662          const int& Width, const int& Height, const int& MgGlassKeyWds) {
663      const int MoveDiff = TInt::Abs(X - ScreenX) + TInt::Abs(Y - ScreenY);
664      ScreenX = X; ScreenY = Y;
665      TFltRect ZoomRect = GetZoomRect();
666      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
667      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
668      if (!LeftButtonDownP && (MoveDiff > 0)) { 
669          ResetMgGlassKeyWd(MgGlassKeyWds);
670          ResetNearPointN();
671      }
672      return (MoveDiff > 0);
673  }
674  void TVizMapContext::MouseLeftDown(const int& X, 
675          const int& Y, const int& Width, const int& Height) {
676      LeftButtonDownP = true;
677      DownX = X; DownY = Y;
678  }
679  void TVizMapContext::MouseLeftUp(const int& X, 
680          const int& Y, const int& Width, const int& Height) {
681      LeftButtonDownP = false;
682      TFltRect ZoomRect = GetZoomRect();
683      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
684      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
685      if (TInt::Abs(DownX - X) > 10 && TInt::Abs(DownY - Y) > 10) {
686          const double StartX = GetMapCoord(DownX, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
687          const double StartY = GetMapCoord(DownY, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
688          if (IsZoomMode()) { 
689              ZoomIn(StartX, StartY, MouseX, MouseY); 
690          } else if (IsSelectMode()) {
691              Select(StartX, StartY, MouseX, MouseY);
692          }
693      } else {
694          SelectDoc(MouseX, MouseY);
695      }
696  }
697  void TVizMapContext::MouseWheel(const int& Degree, const int& MgGlassKeyWds) { 
698      MgGlassSize *= pow(TMath::E / 2, Degree); 
699      if (!LeftButtonDownP) { ResetMgGlassKeyWd(MgGlassKeyWds); }
700  }
701  void TVizMapContext::ZoomIn(const double& X1, const double& Y1, const double& X2, const double& Y2) { 
702      ZoomIn(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
703                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2))); 
704  }
705  void TVizMapContext::ZoomIn(const TFltRect& ZoomInRect) { 
706      ZoomS.Push(ZoomInRect); 
707      RenderLandscapeBmp();
708      ResetMgGlassSize();
709      ResetKeyWd();
710  }
711  bool TVizMapContext::ZoomOut() { 
712      if (!ZoomS.Empty()) { 
713          ZoomS.Pop(); 
714          RenderLandscapeBmp(); 
715          ResetMgGlassSize();
716          ResetKeyWd();
717          return true;
718      } 
719      return false;
720  }
721  bool TVizMapContext::ZoomAll() { 
722      if (!ZoomS.Empty()) { 
723          ZoomS.Clr(); 
724          RenderLandscapeBmp(); 
725          ResetMgGlassSize();
726          ResetKeyWd();
727          return true;
728      }
729      return false;
730  }
731  void TVizMapContext::Select(const double& X1, const double& Y1, const double& X2, const double& Y2) {
732      Select(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
733                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2)));
734  }
735  void TVizMapContext::Select(const TFltRect& SelRect) {
736      TIntV NewSelPointV; 
737      if (VizMapFrame->GetRectPointV(SelRect, NewSelPointV) > 0) {
738          SelPointV.Union(NewSelPointV);
739      }
740  }
741  void TVizMapContext::Select(const int& DocId) {
742      SelPointV.Clr();
743      int Points = VizMapFrame->GetPoints();
744      for (int PointN = 0; PointN < Points; PointN++) {
745          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
746          if (Point->IsDocId() && Point->GetDocId() == DocId) {
747              SelPointV.Add(PointN); break;
748          }
749      }
750      if (SelPointV.Empty()) {
751          const int Frames = VizMap->GetVizMapFrames();
752          for (int FrameN = 0; FrameN < Frames; FrameN++) {
753              if (FrameN == VizMapFrameN) { continue; }
754              PVizMapFrame OtherFrame = VizMap->GetVizMapFrame(FrameN);
755              int Points = OtherFrame->GetPoints();
756              for (int PointN = 0; PointN < Points; PointN++) {
757                  PVizMapPoint Point = OtherFrame->GetPoint(PointN);
758                  if (Point->IsDocId() && Point->GetDocId() == DocId) {
759                      SelPointV.Add(PointN); SetVizMapFrame(FrameN); break;
760                  }
761              }
762          }
763      }
764  }
765  void TVizMapContext::GetSelectDIdV(TIntV& DIdV) {
766      DIdV.Gen(SelPointV.Len(), 0);
767      const int SelPoints = SelPointV.Len();
768      for (int SelPointN = 0; SelPointN < SelPoints; SelPointN++) {
769          DIdV.Add(VizMapFrame->GetPoint(SelPointV[SelPointN])->GetDocId());
770      }
771  }
772  void TVizMapContext::UnselectAll() {
773      SelPointV.Clr();
774  }
775  void TVizMapContext::SelectDoc(const double& DocX, const double& DocY) {
776      const int PointN = VizMapFrame->GetPointN(TFltV::GetV(DocX, DocY), 1.5);
777      if (IsZoomMode()) { 
778          if (PointN != -1) { 
779              SelPointV = TIntV::GetV(PointN); 
780          } else { 
781              SelPointV.Clr(); 
782          }
783      } else if (IsSelectMode()) {
784          if (PointN != -1) { 
785              if (SelPointV.IsInBin(PointN)) {
786                  SelPointV.DelIfIn(PointN);
787              } else {
788                  SelPointV.AddSorted(PointN); 
789              }
790          }
791      }
792  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-websocket.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</div>
                </div>
                <div class="column column_space"><pre><code>833  	ASSERT_EQ (contents.get<std::string> ("address"), node2->network.endpoint ().address ().to_string ());
834  	ASSERT_EQ (contents.get<uint16_t> ("port"), node2->network.endpoint ().port ());
835  	EXPECT_EQ (0, node2->websocket.server->subscriber_count (nano::websocket::topic::telemetry));
836  }
837  TEST (websocket, new_unconfirmed_block)
838  {
839  	nano::test::system system;
840  	nano::node_config config = system.default_config ();
</pre></code></div>
                <div class="column column_space"><pre><code>296      Gks->SetBrush(TGksBrush::New(ColorLandscapeAbove));
297      Gks->FillRect(-1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
298  }
299  void TVizMapContext::Paint(PGks Gks, const bool& ShowPointNmP, const int& PointFontSize,
300          const int& PointNmFontScale, const double& PointWgtThreshold, const int& CatId,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    