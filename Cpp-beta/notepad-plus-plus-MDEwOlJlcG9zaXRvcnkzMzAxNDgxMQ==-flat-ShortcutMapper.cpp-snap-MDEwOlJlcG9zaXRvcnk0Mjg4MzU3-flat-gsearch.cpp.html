
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.153896244844802%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ShortcutMapper.cpp</h3>
            <pre><code>1  #include "ShortcutMapper.h"
2  #include "Notepad_plus.h"
3  using namespace std;
4  void ShortcutMapper::initTabs()
5  {
6  	HWND hTab = _hTabCtrl = ::GetDlgItem(_hSelf, IDC_BABYGRID_TABBAR);
7  	NppDarkMode::subclassTabControl(hTab);
8  	TCITEM tie{};
9  	tie.mask = TCIF_TEXT;
10  	for (size_t i = 0; i < _nbTab; ++i)
11  	{
12  		_tabNames[i] = getTabString(i);
13  		tie.pszText = const_cast<LPWSTR>(_tabNames[i].c_str());
14  		::SendMessage(hTab, TCM_INSERTITEM, i, reinterpret_cast<LPARAM>(&tie));
15  	}
16      TabCtrl_SetCurSel(_hTabCtrl, int(_currentState));
17  	RECT rcTab{};
18  	WINDOWPLACEMENT wp{};
19  	wp.length = sizeof(wp);
20  	::GetWindowPlacement(hTab, &wp);
21  	::SendMessage(hTab, TCM_GETITEMRECT, 0, reinterpret_cast<LPARAM>(&rcTab));
22  	wp.rcNormalPosition.bottom = NppParameters::getInstance()._dpiManager.scaleY(30);
23  	wp.rcNormalPosition.top = wp.rcNormalPosition.bottom - rcTab.bottom;
24  	::SetWindowPlacement(hTab, &wp);
25  }
26  void ShortcutMapper::getClientRect(RECT & rc) const 
27  {
28  		Window::getClientRect(rc);
29  		RECT tabRect{}, btnRect{};
30  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_TABBAR), &tabRect);
31  		int tabH = tabRect.bottom - tabRect.top;
32  		int paddingTop = tabH / 2;
33  		rc.top += tabH + paddingTop;
34  		RECT infoRect{}, filterRect{};
35  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_INFO), &infoRect);
36  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER), &filterRect);
37  		::GetClientRect(::GetDlgItem(_hSelf, IDOK), &btnRect);
38  		int infoH = infoRect.bottom - infoRect.top;
39  		int filterH = filterRect.bottom - filterRect.top;
40  		int btnH = btnRect.bottom - btnRect.top;
41  		int paddingBottom = btnH + NppParameters::getInstance()._dpiManager.scaleY(16);
42  		rc.bottom -= btnH + filterH + infoH + paddingBottom;
43  		rc.left += NppParameters::getInstance()._dpiManager.scaleX(5);
44  		rc.right -= NppParameters::getInstance()._dpiManager.scaleX(5);
45  }
46  generic_string ShortcutMapper::getTabString(size_t i) const
47  {
48  	if (i >= _nbTab)
49  		return TEXT("");
50  	NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
51  	switch (i)
52  	{
53  		case 1:
54  			return nativeLangSpeaker->getShortcutMapperLangStr("MacrosTab", TEXT("Macros"));
55  		case 2:
56  			return nativeLangSpeaker->getShortcutMapperLangStr("RunCommandsTab", TEXT("Run commands"));
57  		case 3:
58  			return nativeLangSpeaker->getShortcutMapperLangStr("PluginCommandsTab", TEXT("Plugin commands"));
59  		case 4:
60  			return nativeLangSpeaker->getShortcutMapperLangStr("ScintillaCommandsTab", TEXT("Scintilla commands"));
61  		default: 
62  			return nativeLangSpeaker->getShortcutMapperLangStr("MainMenuTab", TEXT("Main menu"));
63  	}
64  }
65  void ShortcutMapper::initBabyGrid()
66  {
67  	RECT rect{};
68  	getClientRect(rect);
69  	_lastHomeRow.resize(5, 1);
70  	_lastCursorRow.resize(5, 1);
71  	_hGridFonts.resize(MAX_GRID_FONTS);
72  	_hGridFonts.at(GFONT_HEADER) = ::CreateFont(
73  		NppParameters::getInstance()._dpiManager.scaleY(18), 0, 0, 0, FW_BOLD,
74  		FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH,
75  		TEXT("MS Shell Dlg"));
76  	_hGridFonts.at(GFONT_ROWS) = ::CreateFont(
77  		NppParameters::getInstance()._dpiManager.scaleY(16), 0, 0, 0, FW_NORMAL,
78  		FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH,
79  		TEXT("MS Shell Dlg"));
80  	_babygrid.init(_hInst, _hSelf, IDD_BABYGRID_ID1);
<span onclick='openModal()' class='match'>81  	NppDarkMode::setDarkScrollBar(_babygrid.getHSelf());
82  	_babygrid.setHeaderFont(_hGridFonts.at(GFONT_HEADER));
83  	_babygrid.setRowFont(_hGridFonts.at(GFONT_ROWS));
84  	_babygrid.reSizeToWH(rect);
85  	_babygrid.hideCursor();
86  	_babygrid.makeColAutoWidth(true);
87  	_babygrid.setAutoRow(true);
88  	_babygrid.setColsNumbered(false);
</span>89  	_babygrid.setColWidth(0, NppParameters::getInstance()._dpiManager.scaleX(30));  
90  	_babygrid.setHeaderHeight(NppParameters::getInstance()._dpiManager.scaleY(21));
91  	_babygrid.setRowHeight(NppParameters::getInstance()._dpiManager.scaleY(21));
92  	if (NppDarkMode::isEnabled())
93  	{
94  		_babygrid.setTextColor(NppDarkMode::getDarkerTextColor());
95  		_babygrid.setHighlightTextColor(NppDarkMode::getTextColor());
96  		_babygrid.setTitleTextColor(NppDarkMode::getTextColor());
97  		_babygrid.setUnprotectColor(NppDarkMode::getBackgroundColor());
98  		_babygrid.setTitleColor(NppDarkMode::getBackgroundColor());
99  		_babygrid.setBackgroundColor(NppDarkMode::getDarkerBackgroundColor());
100  		_babygrid.setHighlightColor(NppDarkMode::getHotBackgroundColor());
101  		_babygrid.setHighlightColorNoFocus(NppDarkMode::getSofterBackgroundColor());
102  		_babygrid.setProtectColor(NppDarkMode::getErrorBackgroundColor());
103  		_babygrid.setHighlightColorProtect(RGB(244, 10, 20));
104  		_babygrid.setHighlightColorProtectNoFocus(RGB(230, 100, 110));
105  		_babygrid.setGridlinesColor(NppDarkMode::getEdgeColor());
106  		_babygrid.setTitleGridlinesColor(NppDarkMode::getHotEdgeColor());
107  	}
108  	else
109  	{
110  		_babygrid.setTextColor(RGB(0, 0, 0));
111  		_babygrid.setHighlightTextColor(RGB(255, 255, 255));
112  		_babygrid.setTitleTextColor(RGB(0, 0, 0));
113  		_babygrid.setUnprotectColor(RGB(255, 255, 255));
114  		_babygrid.setTitleColor(::GetSysColor(COLOR_BTNFACE));
115  		_babygrid.setBackgroundColor(::GetSysColor(COLOR_BTNFACE));
116  		_babygrid.setHighlightColor(RGB(0, 0, 128));
117  		_babygrid.setHighlightColorNoFocus(RGB(200, 200, 210));
118  		_babygrid.setProtectColor(RGB(255, 130, 120));
119  		_babygrid.setHighlightColorProtect(RGB(244, 10, 20));
120  		_babygrid.setHighlightColorProtectNoFocus(RGB(230, 194, 190));
121  		_babygrid.setGridlinesColor(RGB(220, 220, 220));
122  		_babygrid.setTitleGridlinesColor(RGB(120, 120, 120));
123  	}
124  	NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
125  	nativeLangSpeaker->changeDlgLang(_hSelf, "ShortcutMapper");
126  	_conflictInfoOk = nativeLangSpeaker->getShortcutMapperLangStr("ConflictInfoOk", TEXT("No shortcut conflicts for this item."));
127  	_conflictInfoEditing = nativeLangSpeaker->getShortcutMapperLangStr("ConflictInfoEditing", TEXT("No conflicts . . ."));
128  }
129  generic_string ShortcutMapper::getTextFromCombo(HWND hCombo)
130  {
131  	const int NB_MAX(128);
132  	TCHAR str[NB_MAX](TEXT("\0"));
133  	::SendMessage(hCombo, WM_GETTEXT, NB_MAX, reinterpret_cast<LPARAM>(str));
134  	generic_string res(str);
135  	return stringToLower(res);
136  }
137  bool ShortcutMapper::isFilterValid(Shortcut sc)
138  {
139  	if (_shortcutFilter.empty())
140  		return true;
141  	wstring shortcut_name = stringToLower(string2wstring(sc.getName(), CP_UTF8));
142  	wstring shortcut_value = stringToLower(string2wstring(sc.toString(), CP_UTF8));
143  	return (shortcut_name.find(_shortcutFilter) != std::string::npos) || 
144  		(shortcut_value.find(_shortcutFilter) != std::string::npos);
145  }
146  bool ShortcutMapper::isFilterValid(PluginCmdShortcut sc)
147  {
148  	Shortcut shortcut = sc;
149  	bool match = false;
150  	wstring module_name = stringToLower(string2wstring(sc.getModuleName(), CP_UTF8));
151  	if (isFilterValid(shortcut)){
152  		return true;
153  	}
154  	size_t match_pos = module_name.find(_shortcutFilter);
155  	if (match_pos != std::string::npos){
156  		match = true;
157  	}
158  	return match;
159  }
160  void ShortcutMapper::fillOutBabyGrid()
161  {
162  	NppParameters& nppParam = NppParameters::getInstance();
163  	_babygrid.clear();
164  	_babygrid.setInitialContent(true);
165  	_shortcutIndex.clear();
166  	size_t nbItems = 0;
167  	NativeLangSpeaker* nativeLangSpeaker = nppParam.getNativeLangSpeaker();
168  	generic_string nameStr = nativeLangSpeaker->getShortcutMapperLangStr("ColumnName", TEXT("Name"));
169  	generic_string shortcutStr = nativeLangSpeaker->getShortcutMapperLangStr("ColumnShortcut", TEXT("Shortcut"));
170  	_babygrid.setText(0, 1, nameStr.c_str());
171  	_babygrid.setText(0, 2, shortcutStr.c_str());
172  	switch(_currentState)
173  	{
174  		case STATE_MENU:
175  		{
176  			nbItems = nppParam.getUserShortcuts().size();
177  			_babygrid.setLineColNumber(nbItems, 3);
178  			generic_string categoryStr = nativeLangSpeaker->getShortcutMapperLangStr("ColumnCategory", TEXT("Category"));
179  			_babygrid.setText(0, 3, categoryStr.c_str());
180  		}
181  		break;
182  		case STATE_MACRO:
183  		{
184  			nbItems = nppParam.getMacroList().size();
185  			_babygrid.setLineColNumber(nbItems, 2);
186  		}
187  		break;
188  		case STATE_USER:
189  		{
190  			nbItems = nppParam.getUserCommandList().size();
191  			_babygrid.setLineColNumber(nbItems, 2);
192  		}
193  		break;
194  		case STATE_PLUGIN:
195  		{
196  			nbItems = nppParam.getPluginCommandList().size();
197  			_babygrid.setLineColNumber(nbItems, 3);
198  			generic_string pluginStr = nativeLangSpeaker->getShortcutMapperLangStr("ColumnPlugin", TEXT("Plugin"));
199  			_babygrid.setText(0, 3, pluginStr.c_str());
200  		}
201  		break;
202  		case STATE_SCINTILLA:
203  		{
204  			nbItems = nppParam.getScintillaKeyList().size();
205  			_babygrid.setLineColNumber(nbItems, 2);
206  		}
207  		break;
208  	}
209  	bool isMarker = false;
210  	size_t cs_index = 0;
211  	_shortcutFilter = getTextFromCombo(::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER));
212  	switch(_currentState) 
213  	{
214  		case STATE_MENU:
215  		{
216  			vector<CommandShortcut> & cshortcuts = nppParam.getUserShortcuts();
217  			cs_index = 1;
218  			for (size_t i = 0; i < nbItems; ++i)
219  			{
220  				if (isFilterValid(cshortcuts[i]))
221  				{
222  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
223  						isMarker = _babygrid.setMarker(true);
224  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
225  					if (cshortcuts[i].isEnabled()) 
226  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
227  					const TCHAR* category = cshortcuts[i].getCategory();
228  					generic_string categoryStr = nativeLangSpeaker->getShortcutMapperLangStr((std::string(wstring2string(category, CP_UTF8)) + "Category").c_str(), category);
229  					_babygrid.setText(cs_index, 3, categoryStr.c_str());
230  					if (isMarker)
231  						isMarker = _babygrid.setMarker(false);
232  					_shortcutIndex.push_back(i);
233  					cs_index++;
234  				}
235  			}
236  			_babygrid.setLineColNumber(cs_index - 1 , 3);
237  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), true);
238  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), true);
239  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
240  		}
241  		break;
242  		case STATE_MACRO:
243  		{
244  			vector<MacroShortcut> & cshortcuts = nppParam.getMacroList();
245  			cs_index = 1;
246  			for (size_t i = 0; i < nbItems; ++i)
247  			{
248  				if (isFilterValid(cshortcuts[i]))
249  				{
250  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
251  						isMarker = _babygrid.setMarker(true);
252  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
253  					if (cshortcuts[i].isEnabled()) 
254  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
255  					if (isMarker)
256  						isMarker = _babygrid.setMarker(false);
257  					_shortcutIndex.push_back(i);
258  					cs_index++;
259  				}
260  			}
261  			_babygrid.setLineColNumber(cs_index - 1 , 2);
262              bool shouldBeEnabled = nbItems > 0;
263              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
264              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
265              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), shouldBeEnabled);
266  		}
267  		break;
268  		case STATE_USER:
269  		{
270  			vector<UserCommand> & cshortcuts = nppParam.getUserCommandList();
271  			cs_index = 1;
272  			for (size_t i = 0; i < nbItems; ++i)
273  			{
274  				if (isFilterValid(cshortcuts[i]))
275  				{
276  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
277  						isMarker = _babygrid.setMarker(true);
278  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
279  					if (cshortcuts[i].isEnabled()) 
280  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
281  					if (isMarker)
282  						isMarker = _babygrid.setMarker(false);
283  					_shortcutIndex.push_back(i);
284  					cs_index++;
285  				}
286  			}
287  			_babygrid.setLineColNumber(cs_index - 1 , 2);
288              bool shouldBeEnabled = nbItems > 0;
289              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
290              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
291              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), shouldBeEnabled);
292  		}
293  		break;
294  		case STATE_PLUGIN:
295  		{
296  			vector<PluginCmdShortcut> & cshortcuts = nppParam.getPluginCommandList();
297  			cs_index = 1;
298  			for (size_t i = 0; i < nbItems; ++i)
299  			{
300  				if (isFilterValid(cshortcuts[i]))
301  				{
302  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
303  						isMarker = _babygrid.setMarker(true);
304  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
305  					if (cshortcuts[i].isEnabled()) 
306  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
307  					_babygrid.setText(cs_index, 3, string2wstring(cshortcuts[i].getModuleName(), CP_UTF8).c_str());
308  					if (isMarker)
309  						isMarker = _babygrid.setMarker(false);
310  					_shortcutIndex.push_back(i);
311  					cs_index++;
312  				}
313  			}
314  			_babygrid.setLineColNumber(cs_index - 1 , 3);
315              bool shouldBeEnabled = nbItems > 0;
316              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
317              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
318              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
319  		}
320  		break;
321  		case STATE_SCINTILLA:
322  		{
323  			vector<ScintillaKeyMap> & cshortcuts = nppParam.getScintillaKeyList();
324  			cs_index=1;
325  			for (size_t i = 0; i < nbItems; ++i)
326  			{
327  				if (isFilterValid(cshortcuts[i]))
328  				{
329  					if (cshortcuts[i].isEnabled())
330  					{
331  						size_t sciCombos = cshortcuts[i].getSize();
332  						for (size_t sciIndex = 0; sciIndex < sciCombos; ++sciIndex)
333  						{
334  							if (findKeyConflicts(nullptr, cshortcuts[i].getKeyComboByIndex(sciIndex), i))
335  							{
336  								isMarker = _babygrid.setMarker(true);
337  								break;
338  							}
339  						}
340  					}
341  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
342  					if (cshortcuts[i].isEnabled()) 
343  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
344  					if (isMarker)
345  						isMarker = _babygrid.setMarker(false);
346  					_shortcutIndex.push_back(i);
347  					cs_index++;
348  				}
349  			}
350  			_babygrid.setLineColNumber(cs_index - 1 , 2);
351              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), true);
352              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), false);
353              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
354  		}
355  		break;
356  	}
357  	if (nbItems > 0) 
358  		_babygrid.setLastView(_lastHomeRow[_currentState], _lastCursorRow[_currentState]);
359  	else 
360  		::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, 0);
361  	_babygrid.setInitialContent(false);
362  }
363  intptr_t CALLBACK ShortcutMapper::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
364  {
365  	switch (message) 
366  	{
367  		case WM_INITDIALOG :
368  		{
369  			initBabyGrid();
370  			initTabs();
371  			fillOutBabyGrid();
372  			_babygrid.display();	
373  			goToCenter();
374  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
375  			RECT rect;
376  			Window::getClientRect(rect);
377  			_clientWidth = rect.right - rect.left;
378  			_clientHeight = rect.bottom - rect.top;
379  			int cy_border = GetSystemMetrics(SM_CYFRAME);
380  			int cy_caption = GetSystemMetrics(SM_CYCAPTION);
381  			_initClientWidth = _clientWidth;
382  			_initClientHeight = _clientHeight + cy_caption + cy_border;
383  			_dialogInitDone = true;
384  			return TRUE;
385  		}
386  		case WM_CTLCOLOREDIT:
387  		{
388  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
389  		}
390  		case WM_CTLCOLORDLG:
391  		case WM_CTLCOLORSTATIC:
392  		{
393  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
394  		}
395  		case WM_PRINTCLIENT:
396  		{
397  			if (NppDarkMode::isEnabled())
398  			{
399  				return TRUE;
400  			}
401  			break;
402  		}
403  		case NPPM_INTERNAL_REFRESHDARKMODE:
404  		{
405  			NppDarkMode::autoThemeChildControls(_hSelf);
406  			return TRUE;
407  		}
408  		case WM_GETMINMAXINFO :
409  		{
410  			MINMAXINFO* mmi = (MINMAXINFO*)lParam;
411  			if (_dialogInitDone)
412  			{
413  				mmi->ptMinTrackSize.x = _initClientWidth;
414  				mmi->ptMinTrackSize.y = _initClientHeight;
415  			}
416  			return 0;
417  		}
418  		case WM_DESTROY:
419  		{
420  			for (const HFONT & hFont : _hGridFonts)
421  				::DeleteObject(hFont);
422  			_hGridFonts.clear();
423  			_hGridFonts.shrink_to_fit();
424  			break;
425  		}
426  		case WM_SIZE:
427  		{
428  			LONG newWidth = LOWORD(lParam);
429  			LONG newHeight = HIWORD(lParam);
430  			RECT rect;
431  			LONG addWidth = newWidth - _clientWidth;
432  			LONG addHeight = newHeight - _clientHeight;
433  			_clientWidth = newWidth;
434  			_clientHeight = newHeight;
435  			getClientRect(rect);
436  			_babygrid.reSizeToWH(rect);
437  			const auto moveWindowIDs = {
438  				IDM_BABYGRID_MODIFY, IDM_BABYGRID_CLEAR, IDM_BABYGRID_DELETE, IDOK
439  			};
440  			const UINT flags = SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS;
441  			Window::getClientRect(rect);
442  			for (int moveWndID : moveWindowIDs)
443  			{
444  				HWND moveHwnd = ::GetDlgItem(_hSelf, moveWndID);
445  				::GetWindowRect(moveHwnd, &rect);
446  				::MapWindowPoints(NULL, _hSelf, (LPPOINT)&rect, 2);
447  				::SetWindowPos(moveHwnd, NULL, rect.left + addWidth / 2, rect.top + addHeight, 0, 0, SWP_NOSIZE | flags);
448  			}
449  			HWND moveHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_STATIC);
450  			::GetWindowRect(moveHwnd, &rect);
451  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&rect, 2);
452  			::SetWindowPos(moveHwnd, NULL, rect.left, rect.top + addHeight, 0, 0, SWP_NOSIZE | flags);
453  			HWND resizeHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_INFO);
454  			::GetWindowRect(resizeHwnd, &rect);
455  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&rect, 2);
456  			::SetWindowPos(resizeHwnd, NULL, rect.left, rect.top + addHeight, rect.right - rect.left + addWidth, rect.bottom - rect.top, flags);
457  			resizeHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER);
458  			::GetWindowRect(resizeHwnd, &rect);
459  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&rect, 2);
460  			::SetWindowPos(resizeHwnd, NULL, rect.left, rect.top + addHeight, rect.right - rect.left + addWidth, rect.bottom - rect.top, flags);
461  			break;
462  		}
463  		break;
464  		case WM_NOTIFY:
465  		{
466  			NMHDR nmh = *((NMHDR*)lParam);
467  			if (nmh.hwndFrom == _hTabCtrl)
468  			{
469  				if (nmh.code == TCN_SELCHANGE)
470  				{
471  					_lastHomeRow[_currentState] = _babygrid.getHomeRow();
472  					_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
473  					int index = TabCtrl_GetCurSel(_hTabCtrl);
474  					switch (index)
475  					{
476  						case 0:
477  							_currentState = STATE_MENU;
478  							break;
479  						case 1:
480  							_currentState = STATE_MACRO;
481  							break;
482  						case 2:
483  							_currentState = STATE_USER;
484  							break;
485  						case 3:
486  							_currentState = STATE_PLUGIN;
487  							break;
488  						case 4:
489  							_currentState = STATE_SCINTILLA;
490  							break;
491  					}
492  					fillOutBabyGrid();
493  				}
494  			}
495  		}
496  		break;
497  		case NPPM_INTERNAL_FINDKEYCONFLICTS:
498  		{
499  			if (!wParam || !lParam)
500  				break;
501  			generic_string conflictInfo;
502  			size_t realIndexOfSelectedItem = _shortcutIndex[_babygrid.getSelectedRow() - 1];
503  			const bool isConflict = findKeyConflicts(&conflictInfo, *reinterpret_cast<KeyCombo*>(wParam), realIndexOfSelectedItem);
504  			*reinterpret_cast<bool*>(lParam) = isConflict;
505  			if (isConflict)
506  				::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(conflictInfo.c_str()));
507  			else
508  				::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_conflictInfoEditing.c_str()));
509  			return TRUE;
510  		}
511  		case WM_COMMAND : 
512  		{
513  			switch (LOWORD(wParam))
514  			{
515  				case IDCANCEL :
516  				{
517  					::EndDialog(_hSelf, -1);
518  					return TRUE;
519  				}
520  				case IDOK :
521  				{
522  					::EndDialog(_hSelf, 0);
523  					return TRUE;
524  				}
525  				case IDM_BABYGRID_CLEAR :
526  				{
527  					if (_babygrid.getNumberRows() < 1)
528  						return TRUE;
529  					NppParameters& nppParam = NppParameters::getInstance();
530  					int row = _babygrid.getSelectedRow();
531  					size_t shortcutIndex = _shortcutIndex[row-1];
532  					bool isModified = false;
533  					switch(_currentState)
534  					{
535  						case STATE_MENU:
536  						{
537  							vector<CommandShortcut> & shortcuts = nppParam.getUserShortcuts();
538  							CommandShortcut csc = shortcuts[shortcutIndex];
539  							csc.clear();
540  							shortcuts[shortcutIndex] = csc;
541  							nppParam.addUserModifiedIndex(shortcutIndex);
542  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
543  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
544  							fillOutBabyGrid();
545  							isModified = true;
546  							nppParam.getAccelerator()->updateShortcuts();
547  							nppParam.setShortcutDirty();
548  						}
549  						break;
550  						case STATE_MACRO: 
551  						{
552  							vector<MacroShortcut> & shortcuts = nppParam.getMacroList();
553  							MacroShortcut msc = shortcuts[shortcutIndex];
554  							msc.clear();
555  							shortcuts[shortcutIndex] = msc;
556  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
557  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
558  							fillOutBabyGrid();
559  							isModified = true;
560  							nppParam.getAccelerator()->updateShortcuts();
561  							nppParam.setShortcutDirty();
562  						}
563  						break;
564  						case STATE_USER: 
565  						{
566  							vector<UserCommand> & shortcuts = nppParam.getUserCommandList();
567  							UserCommand ucmd = shortcuts[shortcutIndex];
568  							ucmd.clear();
569  							shortcuts[shortcutIndex] = ucmd;
570  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
571  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
572  							fillOutBabyGrid();
573  							isModified = true;
574  							nppParam.getAccelerator()->updateShortcuts();
575  							nppParam.setShortcutDirty();
576  						}
577  						break;
578  						case STATE_PLUGIN: 
579  						{
580  							vector<PluginCmdShortcut> & shortcuts = nppParam.getPluginCommandList();
581  							PluginCmdShortcut pcsc = shortcuts[shortcutIndex];
582  							pcsc.clear();
583  							nppParam.addPluginModifiedIndex(shortcutIndex);
584  							shortcuts[shortcutIndex] = pcsc;
585  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
586  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
587  							fillOutBabyGrid();
588  							isModified = true;
589  							nppParam.getAccelerator()->updateShortcuts();
590  							unsigned long cmdID = pcsc.getID();
591  							ShortcutKey shortcut;
592  							shortcut._isAlt = FALSE;
593  							shortcut._isCtrl = FALSE;
594  							shortcut._isShift = FALSE;
595  							shortcut._key = '\0';
596  							::SendMessage(_hParent, NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED, cmdID, reinterpret_cast<LPARAM>(&shortcut));
597  							nppParam.setShortcutDirty();
598  						}
599  						break;
600  						case STATE_SCINTILLA: 
601  						{
602  						}
603  						break;
604  					}
605  					if (!isModified)
606  						::SendMessage(_hSelf, WM_COMMAND, MAKEWPARAM(IDD_BABYGRID_ID1, BGN_ROWCHANGED), row);
607  					return TRUE;
608  				}
609  				case IDM_BABYGRID_MODIFY :
610  				{
611  					if (_babygrid.getNumberRows() < 1)
612  						return TRUE;
613  					NppParameters& nppParam = NppParameters::getInstance();
614  					int row = _babygrid.getSelectedRow();
615  					size_t shortcutIndex = _shortcutIndex[row-1];
616  					bool isModified = false;
617  					switch(_currentState)
618  					{
619  						case STATE_MENU:
620  						{
621  							vector<CommandShortcut> & shortcuts = nppParam.getUserShortcuts();
622  							CommandShortcut csc = shortcuts[shortcutIndex], prevcsc = shortcuts[shortcutIndex];
623  							csc.init(_hInst, _hSelf);
624  							if (csc.doDialog() != -1 && prevcsc != csc)
625  							{
626  								nppParam.addUserModifiedIndex(shortcutIndex);
627  								shortcuts[shortcutIndex] = csc;
628  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
629  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
630  								fillOutBabyGrid();
631  								isModified = true;
632  								nppParam.getAccelerator()->updateShortcuts();
633  								nppParam.setShortcutDirty();
634  							}
635  						}
636  						break;
637  						case STATE_MACRO: 
638  						{
639  							vector<MacroShortcut> & shortcuts = nppParam.getMacroList();
640  							MacroShortcut msc = shortcuts[shortcutIndex], prevmsc = shortcuts[shortcutIndex];
641  							msc.init(_hInst, _hSelf);
642  							if (msc.doDialog() != -1 && prevmsc != msc)
643  							{
644  								shortcuts[shortcutIndex] = msc;
645  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
646  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
647  								fillOutBabyGrid();
648  								isModified = true;
649  								nppParam.getAccelerator()->updateShortcuts();
650  								nppParam.setShortcutDirty();
651  							}
652  						}
653  						break; 
654  						case STATE_USER: 
655  						{
656  							vector<UserCommand> & shortcuts = nppParam.getUserCommandList();
657  							UserCommand ucmd = shortcuts[shortcutIndex];
658  							ucmd.init(_hInst, _hSelf);
659  							UserCommand prevucmd = ucmd;
660  							if (ucmd.doDialog() != -1 && prevucmd != ucmd)
661  							{
662  								shortcuts[shortcutIndex] = ucmd;
663  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
664  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
665  								fillOutBabyGrid();
666  								isModified = true;
667  								nppParam.getAccelerator()->updateShortcuts();
668  								nppParam.setShortcutDirty();
669  							}
670  						}
671  						break; 
672  						case STATE_PLUGIN:
673  						{
674  							vector<PluginCmdShortcut> & shortcuts = nppParam.getPluginCommandList();
675  							PluginCmdShortcut pcsc = shortcuts[shortcutIndex];
676  							pcsc.init(_hInst, _hSelf);
677  							PluginCmdShortcut prevpcsc = pcsc;
678  							if (pcsc.doDialog() != -1 && prevpcsc != pcsc)
679  							{
680  								nppParam.addPluginModifiedIndex(shortcutIndex);
681  								shortcuts[shortcutIndex] = pcsc;
682  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
683  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
684  								fillOutBabyGrid();
685  								isModified = true;
686  								nppParam.getAccelerator()->updateShortcuts();
687  								unsigned long cmdID = pcsc.getID();
688  								ShortcutKey shortcut;
689  								shortcut._isAlt = pcsc.getKeyCombo()._isAlt;
690  								shortcut._isCtrl = pcsc.getKeyCombo()._isCtrl;
691  								shortcut._isShift = pcsc.getKeyCombo()._isShift;
692  								shortcut._key = pcsc.getKeyCombo()._key;
693  								::SendMessage(_hParent, NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED, cmdID, reinterpret_cast<LPARAM>(&shortcut));
694  								nppParam.setShortcutDirty();
695  							}
696  						}
697  						break;
698  						case STATE_SCINTILLA:
699  						{
700  							vector<ScintillaKeyMap> & shortcuts = nppParam.getScintillaKeyList();
701  							ScintillaKeyMap skm = shortcuts[shortcutIndex], prevskm = shortcuts[shortcutIndex];
702  							skm.init(_hInst, _hSelf);
703  							if (skm.doDialog() != -1 && prevskm != skm)
704  							{
705  								nppParam.addScintillaModifiedIndex((int)shortcutIndex);
706  								shortcuts[shortcutIndex] = skm;
707  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
708  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
709  								fillOutBabyGrid();
710  								_babygrid.updateView();
711  								isModified = true;
712  								nppParam.getScintillaAccelerator()->updateKeys();
713  								nppParam.setShortcutDirty();
714  							}
715  						}
716  						break;  
717  					}
718  					if (!isModified)
719  						::SendMessage(_hSelf, WM_COMMAND, MAKEWPARAM(IDD_BABYGRID_ID1, BGN_ROWCHANGED), row);
720  					return TRUE;
721  				}
722  				case IDM_BABYGRID_DELETE :
723  				{
724  					if (_babygrid.getNumberRows() < 1)
725  						return TRUE;
726  					NppParameters& nppParam = NppParameters::getInstance();
727  					int res = nppParam.getNativeLangSpeaker()->messageBox("SCMapperDoDeleteOrNot",
728  						_hSelf,
729  						TEXT("Are you sure you want to delete this shortcut?"),
730  						TEXT("Are you sure?"),
731  						MB_OKCANCEL);
732  					if (res == IDOK)
733  					{
734  						const int row = _babygrid.getSelectedRow();
735  						size_t shortcutIndex = _shortcutIndex[row-1];
736  						switch(_currentState) 
737  						{
738  							case STATE_MENU:
739  							case STATE_PLUGIN:
740  							case STATE_SCINTILLA: 
741  							{
742  								return FALSE;
743  							}
744  							case STATE_MACRO: 
745  							{
746  								vector<MacroShortcut> & theMacros = nppParam.getMacroList();
747  								theMacros.erase(theMacros.begin() + shortcutIndex);
748  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
749  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
750  								const size_t numberRows = _babygrid.getNumberRows();
751  								if (_lastHomeRow[_currentState] == numberRows)
752  									--_lastHomeRow[_currentState];
753  								if (_lastCursorRow[_currentState] == numberRows)
754  									--_lastCursorRow[_currentState];
755  								fillOutBabyGrid();
756  								DynamicMenu& macroMenu = nppParam.getMacroMenuItems();
757  								macroMenu.clearMenu();
758  								macroMenu.erase(shortcutIndex);
759  								size_t nbElem = theMacros.size();
760  								for (size_t i = shortcutIndex; i < nbElem; ++i)	
761  								{
762  									MacroShortcut ms = theMacros[i];
763  									ms.setID(ms.getID() - 1);	
764  									theMacros[i] = ms;
765  									MenuItemUnit& miu = macroMenu.getItemFromIndex(i);
766  									miu._cmdID -= 1;	
767  								}
768  								macroMenu.createMenu();
769  								HMENU m = reinterpret_cast<HMENU>(::SendMessage(_hParent, NPPM_INTERNAL_GETMENU, 0, 0));
770  								HMENU hMenu = ::GetSubMenu(m, MENUINDEX_MACRO);
771  								if (!hMenu) return FALSE;
772  								int32_t posBase = macroMenu.getPosBase();
773  								if (nbElem == 0)
774  								{
775  									::RemoveMenu(hMenu, IDM_SETTING_SHORTCUT_MAPPER_MACRO, MF_BYCOMMAND);
776  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
777  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
778  								}
779  							}
780  							break; 
781  							case STATE_USER: 
782  							{
783  								vector<UserCommand> & theUserCmds = nppParam.getUserCommandList();
784  								theUserCmds.erase(theUserCmds.begin() + shortcutIndex);
785  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
786  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
787  								const size_t numberRows = _babygrid.getNumberRows();
788  								if (_lastHomeRow[_currentState] == numberRows)
789  									--_lastHomeRow[_currentState];
790  								if (_lastCursorRow[_currentState] == numberRows)
791  									--_lastCursorRow[_currentState];
792  								fillOutBabyGrid();
793  								DynamicMenu& runMenu = nppParam.getRunMenuItems();
794  								runMenu.clearMenu();
795  								runMenu.erase(shortcutIndex);
796  								size_t nbElem = theUserCmds.size();
797  								for (size_t i = shortcutIndex; i < nbElem; ++i)	
798  								{
799  									UserCommand uc = theUserCmds[i];
800  									uc.setID(uc.getID() - 1);	
801  									theUserCmds[i] = uc;
802  									MenuItemUnit& miu = runMenu.getItemFromIndex(i);
803  									miu._cmdID -= 1;	
804  								}
805  								runMenu.createMenu();
806  								HMENU m = reinterpret_cast<HMENU>(::SendMessage(_hParent, NPPM_INTERNAL_GETMENU, 0, 0));
807  								HMENU hMenu = ::GetSubMenu(m, MENUINDEX_RUN);
808  								if (!hMenu) return FALSE;
809  								int32_t posBase = runMenu.getPosBase();
810  								if (nbElem == 0)
811  								{
812  									::RemoveMenu(hMenu, IDM_SETTING_SHORTCUT_MAPPER_RUN, MF_BYCOMMAND);
813  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
814  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
815  								}
816  							}
817  							break;
818  						}
819  						nppParam.getAccelerator()->updateShortcuts();
820  						nppParam.setShortcutDirty();
821  					}
822  					return TRUE;
823  				}
824  				case IDD_BABYGRID_ID1: 
825  				{
826  					switch (HIWORD(wParam))
827  					{
828  						case BGN_CELLDBCLICKED: 
829  						{
830  							return ::SendMessage(_hSelf, WM_COMMAND, IDM_BABYGRID_MODIFY, LOWORD(lParam));
831  						}
832  						case BGN_CELLRCLICKED: 
833  						{
834  							POINT p{};
835  							::GetCursorPos(&p);
836  							if (!_rightClickMenu.isCreated())
837  							{
838  								vector<MenuItemUnit> itemUnitArray;
839  								NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
840  								generic_string modifyStr = nativeLangSpeaker->getShortcutMapperLangStr("ModifyContextMenu", TEXT("Modify"));
841  								generic_string deleteStr = nativeLangSpeaker->getShortcutMapperLangStr("DeleteContextMenu", TEXT("Delete"));
842  								generic_string clearStr = nativeLangSpeaker->getShortcutMapperLangStr("ClearContextMenu", TEXT("Clear"));
843  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_MODIFY, modifyStr.c_str()));
844  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_DELETE, deleteStr.c_str()));
845  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_CLEAR, clearStr.c_str()));
846  								_rightClickMenu.create(_hSelf, itemUnitArray);
847  							}
848  							if (_babygrid.getNumberRows() < 1)
849  							{
850  								_rightClickMenu.enableItem(IDM_BABYGRID_MODIFY, false);
851  								_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, false);
852  								_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, false);
853  							}
854  							else
855  							{
856  								_rightClickMenu.enableItem(IDM_BABYGRID_MODIFY, true);
857  								_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, true);
858  								if (_currentState == STATE_SCINTILLA)
859  									_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, false);
860  								else
861  									_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, true);
862  								switch(_currentState)
863  								{
864  									case STATE_MACRO:
865  									case STATE_USER:
866  									{
867  										_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, true);
868  									}
869  									break;
870  									case STATE_MENU:
871  									case STATE_PLUGIN:
872  									case STATE_SCINTILLA:
873  									{
874  										_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, false);
875  									}
876  									break;
877  								}
878  							}
879  							_rightClickMenu.display(p);
880  							return TRUE;
881  						}
882  						case BGN_DELETECELL: 
883  						{
884  							switch(_currentState) 
885  							{
886  								case STATE_MACRO:
887  								case STATE_USER:
888  									return ::SendMessage(_hSelf, WM_COMMAND, IDM_BABYGRID_DELETE, 0);
889  								case STATE_MENU:
890  								case STATE_PLUGIN:
891  								case STATE_SCINTILLA:
892  								default:
893  									break;
894  							}
895  							return TRUE;
896  						}
897  						case BGN_ROWCHANGED:
898  						{
899  							if (_babygrid.getNumberRows() < 1)
900  								return TRUE;
901  							NppParameters& nppParam = NppParameters::getInstance();
902  							const size_t currentIndex = LOWORD(lParam) - 1;
903  							size_t realIndexOfSelectedItem = _shortcutIndex[currentIndex];
904  							generic_string conflictInfo;
905  							switch (_currentState)
906  							{
907  								case STATE_MENU:
908  								{
909  									vector<CommandShortcut> & vShortcuts = nppParam.getUserShortcuts();
910  									findKeyConflicts(&conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
911  								}
912  								break;
913  								case STATE_MACRO:
914  								{
915  									vector<MacroShortcut> & vShortcuts = nppParam.getMacroList();
916  									findKeyConflicts(&conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
917  								}
918  								break;
919  								case STATE_USER:
920  								{
921  									vector<UserCommand> & vShortcuts = nppParam.getUserCommandList();
922  									findKeyConflicts(&conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
923  								}
924  								break;
925  								case STATE_PLUGIN:
926  								{
927  									vector<PluginCmdShortcut> & vShortcuts = nppParam.getPluginCommandList();
928  									findKeyConflicts(&conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
929  								}
930  								break;
931  								case STATE_SCINTILLA:
932  								{
933  									vector<ScintillaKeyMap> & vShortcuts = nppParam.getScintillaKeyList();
934  									size_t sciCombos = vShortcuts[realIndexOfSelectedItem].getSize();
935  									for (size_t sciIndex = 0; sciIndex < sciCombos; ++sciIndex)
936  										findKeyConflicts(&conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyComboByIndex(sciIndex), realIndexOfSelectedItem);
937  								}
938  								break;
939  							}
940  							if (conflictInfo.empty())
941  								::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_conflictInfoOk.c_str()));
942  							else
943  								::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(conflictInfo.c_str()));
944  							return TRUE;
945  						}
946  					}
947  					break;
948  				}
949  				case IDC_BABYGRID_FILTER:
950  				{
951  					if (HIWORD(wParam) == EN_CHANGE)
952  					{
953  						fillOutBabyGrid();
954  					}
955  					return TRUE;
956  				}
957  				default:
958  				{
959  					break;
960  				}
961  			}
962  			break;
963  		}
964  		default:
965  			return FALSE;
966  	}
967  	return FALSE;
968  }
969  bool ShortcutMapper::findKeyConflicts(__inout_opt generic_string * const keyConflictLocation,
970  										const KeyCombo & itemKeyComboToTest, const size_t & itemIndexToTest) const
971  {
972  	if (itemKeyComboToTest._key == 0) 
973  		return false;
974  	bool retIsConflict = false; 
975  	NppParameters& nppParam = NppParameters::getInstance();
976  	for (size_t gridState = STATE_MENU; gridState <= STATE_SCINTILLA; ++gridState)
977  	{
978  		switch (gridState)
979  		{
980  			case STATE_MENU:
981  			{
982  				vector<CommandShortcut> & vShortcuts = nppParam.getUserShortcuts();
983  				size_t nbItems = vShortcuts.size();
984  				for (size_t itemIndex = 0; itemIndex < nbItems; ++itemIndex)
985  				{
986  					if (!vShortcuts[itemIndex].isEnabled()) 
987  						continue;
988  					if ((itemIndex == itemIndexToTest) && (gridState == static_cast<size_t>(_currentState))) 
989  						continue;
990  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
991  					{
992  						retIsConflict = true;
993  						if (keyConflictLocation == nullptr)
994  							return retIsConflict;
995  						else
996  						{
997  							if (!keyConflictLocation->empty())
998  								*keyConflictLocation += TEXT("\r\n");
999  							*keyConflictLocation += _tabNames[gridState];
1000  							*keyConflictLocation += TEXT("  |  ");
1001  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1002  							*keyConflictLocation += TEXT("   ");
1003  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1004  							*keyConflictLocation += TEXT("  ( ");
1005  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1006  							*keyConflictLocation += TEXT(" )");
1007  						}
1008  					}
1009  				}
1010  				break;
1011  			} 
1012  			case STATE_MACRO:
1013  			{
1014  				vector<MacroShortcut> & vShortcuts = nppParam.getMacroList();
1015  				size_t nbItems = vShortcuts.size();
1016  				for (size_t itemIndex = 0; itemIndex < nbItems; ++itemIndex)
1017  				{
1018  					if (!vShortcuts[itemIndex].isEnabled()) 
1019  						continue;
1020  					if ((itemIndex == itemIndexToTest) && (gridState == static_cast<size_t>(_currentState))) 
1021  						continue;
1022  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1023  					{
1024  						retIsConflict = true;
1025  						if (keyConflictLocation == nullptr)
1026  							return retIsConflict;
1027  						else
1028  						{
1029  							if (!keyConflictLocation->empty())
1030  								*keyConflictLocation += TEXT("\r\n");
1031  							*keyConflictLocation += _tabNames[gridState];
1032  							*keyConflictLocation += TEXT("  |  ");
1033  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1034  							*keyConflictLocation += TEXT("   ");
1035  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1036  							*keyConflictLocation += TEXT("  ( ");
1037  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1038  							*keyConflictLocation += TEXT(" )");
1039  						}
1040  					}
1041  				}
1042  				break;
1043  			} 
1044  			case STATE_USER:
1045  			{
1046  				vector<UserCommand> & vShortcuts = nppParam.getUserCommandList();
1047  				size_t nbItems = vShortcuts.size();
1048  				for (size_t itemIndex = 0; itemIndex < nbItems; ++itemIndex)
1049  				{
1050  					if (!vShortcuts[itemIndex].isEnabled()) 
1051  						continue;
1052  					if ((itemIndex == itemIndexToTest) && (gridState == static_cast<size_t>(_currentState))) 
1053  						continue;
1054  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1055  					{
1056  						retIsConflict = true;
1057  						if (keyConflictLocation == nullptr)
1058  							return retIsConflict;
1059  						else
1060  						{
1061  							if (!keyConflictLocation->empty())
1062  								*keyConflictLocation += TEXT("\r\n");
1063  							*keyConflictLocation += _tabNames[gridState];
1064  							*keyConflictLocation += TEXT("  |  ");
1065  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1066  							*keyConflictLocation += TEXT("   ");
1067  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1068  							*keyConflictLocation += TEXT("  ( ");
1069  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1070  							*keyConflictLocation += TEXT(" )");
1071  						}
1072  					}
1073  				}
1074  				break;
1075  			} 
1076  			case STATE_PLUGIN:
1077  			{
1078  				vector<PluginCmdShortcut> & vShortcuts = nppParam.getPluginCommandList();
1079  				size_t nbItems = vShortcuts.size();
1080  				for (size_t itemIndex = 0; itemIndex < nbItems; ++itemIndex)
1081  				{
1082  					if (!vShortcuts[itemIndex].isEnabled()) 
1083  						continue;
1084  					if ((itemIndex == itemIndexToTest) && (gridState == static_cast<size_t>(_currentState))) 
1085  						continue;
1086  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1087  					{
1088  						retIsConflict = true;
1089  						if (keyConflictLocation == nullptr)
1090  							return retIsConflict;
1091  						else
1092  						{
1093  							if (!keyConflictLocation->empty())
1094  								*keyConflictLocation += TEXT("\r\n");
1095  							*keyConflictLocation += _tabNames[gridState];
1096  							*keyConflictLocation += TEXT("  |  ");
1097  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1098  							*keyConflictLocation += TEXT("   ");
1099  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);;
1100  							*keyConflictLocation += TEXT("  ( ");
1101  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1102  							*keyConflictLocation += TEXT(" )");
1103  						}
1104  					}
1105  				}
1106  				break;
1107  			} 
1108  			case STATE_SCINTILLA:
1109  			{
1110  				vector<ScintillaKeyMap> & vShortcuts = nppParam.getScintillaKeyList();
1111  				size_t nbItems = vShortcuts.size();
1112  				for (size_t itemIndex = 0; itemIndex < nbItems; ++itemIndex)
1113  				{
1114  					if (!vShortcuts[itemIndex].isEnabled()) 
1115  						continue;
1116  					if ((itemIndex == itemIndexToTest) && (gridState == static_cast<size_t>(_currentState))) 
1117  						continue;
1118  					size_t sciCombos = vShortcuts[itemIndex].getSize();
1119  					for (size_t sciIndex = 0; sciIndex < sciCombos; ++sciIndex)
1120  					{
1121  						if (isConflict(vShortcuts[itemIndex].getKeyComboByIndex(sciIndex), itemKeyComboToTest))
1122  						{
1123  							retIsConflict = true;
1124  							if (keyConflictLocation == nullptr)
1125  								return retIsConflict;
1126  							else
1127  							{
1128  								if (!keyConflictLocation->empty())
1129  									*keyConflictLocation += TEXT("\r\n");
1130  								*keyConflictLocation += _tabNames[gridState];
1131  								*keyConflictLocation += TEXT("  |  ");
1132  								*keyConflictLocation += std::to_wstring(itemIndex + 1);
1133  								if (sciIndex > 0)
1134  									*keyConflictLocation += TEXT("*   ");
1135  								else
1136  									*keyConflictLocation += TEXT("   ");
1137  								*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1138  								*keyConflictLocation += TEXT("  ( ");
1139  								*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(sciIndex), CP_UTF8);
1140  								*keyConflictLocation += TEXT(" )");
1141  							}
1142  						}
1143  					}
1144  				}
1145  				break;
1146  			}
1147  		}
1148  	}
1149  	return retIsConflict;
1150  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</h3>
            <pre><code>1  TStr TGixConst::WdGixFNm = "WdGix";
2  TStr TGixConst::WdGixDatFNm = "WdGix.Dat";
3  TStr TGixConst::WdGixBsFNm = "WdGixBs.MBlobBs";
4  TStr TGixConst::WdGixMDSFNm = "WdGixMDS.Dat";
5  TStr TGixConst::TrGixFNm = "TrGix";
6  TStr TGixConst::TrGixDatFNm = "TrGix.Dat";
7  TStr TGixConst::TrGixDocBsFNm = "TrGixDocBs.MBlobBs";
8  TStr TGixConst::TrGixSentBsFNm = "TrGixSentBs.MBlobBs";
9  TStr TGixConst::TrGixTrAttrBsFNm = "TrGixTrAttrBs.MBlobBs";
10  TStr TGixConst::MWdGixFNm = "MWdGix";
11  TStr TGixConst::MWdGixDatFNm = "MWdGix.Dat";
12  TStr TGixConst::MWdGixDocBsFNm = "MWdGixDocBs.MBlobBs";
13  TStr TGixConst::MWdGixBsFNm = "MWdGixBs.Dat";
14  int TWdGixItem::TitleBit = 0;
15  int TWdGixItem::NmObjBit = 1;
16  int TWdGixItem::AnchorBit = 2;
17  int TWdGixItem::EmphBit = 3;
18  TWdGixItem::TWdGixItem(const TBlobPt& BlobPt, const uchar& _Wgt, const uchar& _WdPos,
19          const bool& TitleP, const bool& NmObjP, const bool& AnchorP, const bool& EmphP):
20              Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()), WdPos(_WdPos) {
21      FSet.SetBit(TitleBit, TitleP);
22      FSet.SetBit(NmObjBit, NmObjP);
23      FSet.SetBit(AnchorBit, AnchorP);
24      FSet.SetBit(EmphBit, EmphP);
25  }
26  TWdGixItem::TWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _Wgt,
27          const uchar& _WdPos, const bool& TitleP, const bool& NmObjP, const bool& AnchorP,
28          const bool& EmphP): Seg(_Seg), Addr(_Addr), Wgt(_Wgt), WdPos(_WdPos) {
29      FSet.SetBit(TitleBit, TitleP);
30      FSet.SetBit(NmObjBit, NmObjP);
31      FSet.SetBit(AnchorBit, AnchorP);
32      FSet.SetBit(EmphBit, EmphP);
33  }
34  TWdGixItem::TWdGixItem(TSIn& SIn) {
35      SIn.Load(Seg); SIn.Load(Addr);
36      SIn.Load(Wgt); SIn.Load(WdPos); FSet=TB8Set(SIn);
37  }
38  void TWdGixItem::Save(TSOut& SOut) const {
39      SOut.Save(Seg); SOut.Save(Addr);
40      SOut.Save(Wgt); SOut.Save(WdPos); FSet.Save(SOut);
41  }
42  inline bool TWdGixItem::operator==(const TWdGixItem& Item) const {
43      return (Seg == Item.Seg) && (Addr == Item.Addr); 
44  }
45  inline bool TWdGixItem::operator<(const TWdGixItem& Item) const {
46      return (Seg < Item.Seg) ||
47          ((Seg == Item.Seg) && (Addr < Item.Addr)); 
48  }
49  void TWdGix::LoadTags() {
50      TitleTagH.AddKey("<TITLE>");
51      NmObjTagH.AddKey("<NMOBJ>");
52      EmphTagH.AddKey("<EM>"); EmphTagH.AddKey("<A>"); EmphTagH.AddKey("<B>");
53      EmphTagH.AddKey("<I>"); EmphTagH.AddKey("<H1>"); EmphTagH.AddKey("<H2>");
54      EmphTagH.AddKey("<H3>"); EmphTagH.AddKey("<H4>"); EmphTagH.AddKey("<H5>");
55  }
56  TWdGix::TWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
57      FPath = _FPath; FAccess = _FAccess;
58      WGix = TWGix::New(TGixConst::WdGixFNm, FPath, FAccess, CacheSize);
59      if (FAccess == faCreate) {
60          Stemmer = TStemmer::New(stmtPorter, false);
61          SwSet = TSwSet::New(swstEn523);
62      } else {
63          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
64          TFIn FIn(WdGixDatFNm);
65          WordH.Load(FIn);
66          Stemmer = TStemmer::Load(FIn);
67          SwSet = TSwSet::Load(FIn);
68      }
69      LoadTags();
70  }
71  TWdGix::~TWdGix() {
72      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
73          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
74          TFOut FOut(WdGixDatFNm);
75          WordH.Save(FOut);
76          Stemmer->Save(FOut);
77          SwSet->Save(FOut);
78      }
79  }
80  void TWdGix::AddHtml(const TStr& HtmlStr, const TBlobPt& BlobPt, const uchar& Wgt) {
81      PSIn HtmlSIn = TStrIn::New(HtmlStr);
82      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
83      THash<TInt, TWdGixItemV> WIdToItemVH; uchar WdPos = 0;
84      bool TitleP = false, NmObjP = false; int EmphLv = 0;
85      while (HtmlLx.Sym != hsyEof) {
86          if (HtmlLx.Sym == hsyStr) {
87              TStr WordStr = HtmlLx.UcChA;
88              if (!SwSet->IsIn(WordStr)) {
89                  WordStr=Stemmer->GetStem(WordStr);
90                  const int WId = WordH.AddKey(WordStr);
91                  WdPos++;
92                  WIdToItemVH.AddDat(WId).Add(
93                      TWdGixItem(BlobPt, Wgt, WdPos, TitleP, NmObjP, false, (EmphLv>0)));
94              }
95          } else if (HtmlLx.Sym == hsyBTag) {
96              TStr TagStr = HtmlLx.UcChA;
97              if (TitleTagH.IsKey(TagStr)) { TitleP = true; }
98              if (NmObjTagH.IsKey(TagStr)) { NmObjP = true; }
99              if (EmphTagH.IsKey(TagStr)) { EmphLv++; }
100          } else if (HtmlLx.Sym == hsyETag) {
101              TStr TagStr = HtmlLx.UcChA;
102              if (TitleTagH.IsKey(TagStr)) { TitleP = false; }
103              if (NmObjTagH.IsKey(TagStr)) { NmObjP = false; }
104              if (EmphTagH.IsKey(TagStr)) { EmphLv--; EmphLv = TInt::GetMx(0, EmphLv); }
105          }
106          HtmlLx.GetSym();
107      }
108      int WdKeyId = WIdToItemVH.FFirstKeyId();
109      while (WIdToItemVH.FNextKeyId(WdKeyId)) {
110          const int WId = WIdToItemVH.GetKey(WdKeyId); WordH[WId]++;
111          const TWdGixItemV& ItemV = WIdToItemVH[WdKeyId];
112          const uchar Seg = ItemV[0].GetSeg();
113          const uint Addr = ItemV[0].GetAddr();
114          const uchar Count = uchar(TInt::GetMn(int(TUCh::Mx), ItemV.Len()));
115          bool TitleP = false, NmObjP = false, EmphP = false, AnchorP = false;
116          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
117              const TWdGixItem& Item = ItemV[ItemN];
118              TitleP = TitleP || Item.IsTitle();
119              NmObjP = NmObjP || Item.IsNmObj();
120              EmphP = EmphP || Item.IsAnchor();
121              AnchorP = AnchorP || Item.IsEmph();
122          }
123          TWdGixItem Item(Seg, Addr, Wgt, Count, TitleP, NmObjP, AnchorP, EmphP);
124          WGix->AddItem(WId, Item);
125      }
126  }
127  bool TWdGix::Search(const TStr& QueryStr, TWdGixItemV& ResItemV) {
128      PWGixExpItem WGixExp = TWGixExpItem::NewEmpty();
129      PSIn HtmlSIn = TStrIn::New(QueryStr);
130      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
131      while (HtmlLx.Sym != hsyEof) {
132          if (HtmlLx.Sym == hsyStr) {
133              TStr WordStr = HtmlLx.UcChA;
134              WordStr=Stemmer->GetStem(WordStr);
135              const int WId = WordH.GetKeyId(WordStr);
136              if (WId != -1) {
137                  PWGixExpItem WGixExpItem = TWGixExpItem::NewItem(WId);
138                  if (WGixExp->IsEmpty()) { WGixExp = WGixExpItem; }
139                  else { WGixExp = TWGixExpItem::NewAnd(WGixExp, WGixExpItem); }
140              }
141          }
142          HtmlLx.GetSym();
143      }
144      return WGixExp->Eval(WGix, ResItemV);
145  }
146  void TWdGixMDS::AddDate(const TBlobPt& DocBlobPt, const TTm& DateTime) {
147      TAddrPr AddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr());
148      const uint64 DateMSecs = TTm::GetMSecsFromTm(DateTime);
149      AddrPrToDateH.AddDat(AddrPr, DateMSecs);
150  }
151  inline uint64 TWdGixMDS::GetDateMSecs(const TBlobPt& DocBlobPt) const {
152      return AddrPrToDateH.GetDat(TAddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr()));
153  }
154  inline TTm TWdGixMDS::GetDateTTm(const TBlobPt& DocBlobPt) const {
155      return TTm::GetTmFromMSecs(GetDateMSecs(DocBlobPt));
156  }
157  void TWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
158          const TStrV& CatNmV, const TTm& DateTime) {
159      DocTitleV.Add(DocTitle);
160      DocTitleV.Last().DelChAll('\n');
161      DocTitleV.Last().DelChAll('\r');
162      DocStrV.Add(DocStr);
163      CatNmVV.Add(CatNmV);
164      DateTimeV.Add(DateTime);
165  }
166  void TWdGixRSet::SortByDate(const bool& Asc) {
167      typedef TPair<TUInt64, TInt> TUInt64IntPr;
168      TVec<TUInt64IntPr> TmMSecsDocNV;
169      const int Docs = GetDocs();
170      for (int DocN = 0; DocN < Docs; DocN++) {
171          uint64 TmMSecs = TTm::GetMSecsFromTm(DateTimeV[DocN]);
172          TmMSecsDocNV.Add(TUInt64IntPr(TmMSecs, DocN));
173      }
174      TmMSecsDocNV.Sort(Asc);
175      TStrV NewDocTitleV(Docs, 0), NewDocStrV(Docs, 0);
176      TVec<TStrV> NewCatNmVV(Docs, 0); TTmV NewDateTimeV(Docs, 0);
177      for (int NewDocN = 0; NewDocN < Docs; NewDocN++) {
178          const int OldDocN = TmMSecsDocNV[NewDocN].Val2;
179          NewDocTitleV.Add(DocTitleV[OldDocN]);
180          NewDocStrV.Add(DocStrV[OldDocN]);
181          NewCatNmVV.Add(CatNmVV[OldDocN]);
182          NewDateTimeV.Add(DateTimeV[OldDocN]);
183      }
184      DocTitleV = NewDocTitleV; DocStrV = NewDocStrV;
185      CatNmVV = NewCatNmVV; DateTimeV = NewDateTimeV;
186  }
187  void TWdGixRSet::PrintRes(PNotify Notify) {
188      const int Docs = GetDocs();
189      Notify->OnStatus(TStr::Fmt(
190          "All results: %d, Showing results from %d to %d",
191          AllDocs.Val, Docs, Docs + Offset.Val));
192      for (int DocN = 0; DocN < Docs; DocN++) {
193          TTm DateTime = DateTimeV[DocN];
194          if (DateTime.IsDef()) {
195              Notify->OnStatus(TStr::Fmt("[%d: %s] %s ...", DocN+1,
196                  DateTime.GetWebLogDateStr().CStr(),
197                  DocTitleV[DocN].Left(50).CStr()));
198          } else {
199              Notify->OnStatus(TStr::Fmt("[%d] %s ...", DocN+1,
200                  DocTitleV[DocN].Left(60).CStr()));
201          }
202      }
203      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
204          AllDocs.Val, Docs, Docs + Offset.Val));
205  }
206  PBowDocBs TWdGixRSet::GenBowDocBs() const {
207      PSwSet SwSet = TSwSet::New(swstEn523);
208      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
209      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
210      const int Docs = GetDocs();
211      for (int DocN = 0; DocN < Docs; DocN++) {
212          const TStr& DocNm = DocTitleV[DocN];
213          const TStr& DocStr = DocStrV[DocN];
214          BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, true);
215      }
216      return BowDocBs;
217  }
218  void TWdGixBs::Filter(const TWgtWdGixItemKdV& InItemV,
219          const TWdGixBsGrouping& Grouping, TWgtWdGixItemKdV& OutItemV) {
220      OutItemV.Clr();
221      if (Grouping == wgbgName) {
222          TStrFltH NameToRankH; TStrH NameToItemNH;
223          const int Items = InItemV.Len();
224          for (int ItemN = 0; ItemN < Items; ItemN++) {
225              TBlobPt BlobPt = InItemV[ItemN].Dat.GetBlobPt();
226              TStr Name = GetDocTitle(BlobPt);
227              const double Rank = InItemV[ItemN].Key;
228              if (NameToRankH.IsKey(Name)) {
229                  const double OldRank = NameToRankH.GetDat(Name);
230                  if (Rank > OldRank) {
231                      NameToRankH.GetDat(Name) = Rank;
232                      NameToItemNH.GetDat(Name) = ItemN;
233                  }
234              } else {
235                  NameToRankH.AddDat(Name) = Rank;
236                  NameToItemNH.AddDat(Name) = ItemN;
237              }
238          }
239          int KeyId = NameToItemNH.FFirstKeyId();
240          while (NameToItemNH.FNextKeyId(KeyId)) {
241              const int ItemN = NameToItemNH[KeyId];
242              OutItemV.Add(InItemV[ItemN]);
243          }
244      } else if (Grouping == wgbgDate) {
245          Fail;
246      } else if (Grouping == wgbgDateTime) {
247          Fail;
248      }
249  }
250  TWdGixBs::TWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
251      FPath = _FPath; FAccess = _FAccess;
252      TStr WdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixBsFNm;
253      DocBBs = TMBlobBs::New(WdGixBsFNm, FAccess);
254      if (FAccess == faCreate) { WdGixMDS = TWdGixMDS::New(); }
255      else {
256          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
257          WdGixMDS = TWdGixMDS::LoadBin(WdGixMDSFNm);
258      }
259      WdGix = TWdGix::New(FPath, FAccess, CacheSize);
260  }
261  TWdGixBs::~TWdGixBs() {
262      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
263          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
264          WdGixMDS->SaveBin(WdGixMDSFNm);
265      }
266  }
267  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
268          const TStrV& CatNmV, const TTm& DateTime, const uchar& Wgt) {
269      TMOut DocMOut;
270      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
271      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
272      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
273      WdGix->AddHtml(DocStr, DocBlobPt, Wgt);
274  }
275  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStoreStr,
276          const TStr& DocIndexStr, const TStrV& CatNmV,
277          const TTm& DateTime, const uchar& Wgt) {
278      TMOut DocMOut;
279      DocTitle.Save(DocMOut); DocStoreStr.Save(DocMOut); CatNmV.Save(DocMOut);
280      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
281      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
282      WdGix->AddHtml(DocIndexStr, DocBlobPt, Wgt);
283  }
284  void TWdGixBs::GetDoc(const TBlobPt& BlobPt,
285          TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
286      PSIn SIn = DocBBs->GetBlob(BlobPt);
287      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
288  }
289  TStr TWdGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
290      PSIn SIn = DocBBs->GetBlob(BlobPt);
291      TStr DocTitle; DocTitle.Load(*SIn);
292      return DocTitle;
293  }
294  TStr TWdGixBs::GetDocStr(const TBlobPt& BlobPt) const {
295      PSIn SIn = DocBBs->GetBlob(BlobPt);
296      {TStr DocTitle; DocTitle.Load(*SIn);}
297      TStr DocStr; DocStr.Load(*SIn);
298      return DocStr;
299  }
300  TStrV TWdGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
301      PSIn SIn = DocBBs->GetBlob(BlobPt);
302      {TStr DocTitle; DocTitle.Load(*SIn);}
303      {TStr DocStr; DocStr.Load(*SIn);}
304      TStrV CatNmV; CatNmV.Load(*SIn);
305      return CatNmV;
306  }
307  PWdGixRSet TWdGixBs::SearchDoc(const TStr& QueryStr,
308          const TWdGixBsGrouping& Grouping, TWdGixRankFun& RankFun,
309          const int& Docs, const int& Offset, const TTm& MnDate,
310          const TTm& MxDate) {
311      printf("  Loading from Gix ...\n");
312      TWdGixItemV ResItemV; WdGix->Search(QueryStr, ResItemV);
313      printf("  Weighting %d hits ...\n", ResItemV.Len());
314      TWgtWdGixItemKdV FullWgtItemV(ResItemV.Len(), 0);
315      const bool CheckMnDateP = MnDate.IsDef();
316      const bool CheckMxDateP = MxDate.IsDef();
317      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
318          const TWdGixItem& Item = ResItemV[ItemN];
319          TTm DateTime = WdGixMDS->GetDateTTm(Item.GetBlobPt());
320          if (CheckMnDateP && DateTime < MnDate) { continue; }
321          if (CheckMxDateP && DateTime > MxDate) { continue; }
322          const double Wgt = RankFun(DateTime, Item.GetWgt(), Item.GetWdPos(),
323              Item.IsTitle(), Item.IsNmObj(), Item.IsAnchor(), Item.IsEmph());
324          FullWgtItemV.Add(TWgtWdGixItemKd(Wgt, Item));
325      }
326      printf("  Filtering ...\n");
327      if (Grouping != wgbgNone) {
328          TWgtWdGixItemKdV TmpWgtItemV;
329          Filter(FullWgtItemV, Grouping, TmpWgtItemV);
330          FullWgtItemV = TmpWgtItemV;
331      }
332      printf("  Sorting %d hits ...\n", FullWgtItemV.Len());
333      TWgtWdGixItemKdV WgtItemV;
334      if (Docs == -1) {
335          WgtItemV = FullWgtItemV;
336      } else if (ResItemV.Len() >= (Docs + Offset)) {
337          WgtItemV = FullWgtItemV;
338          WgtItemV.Sort(false); WgtItemV.Trunc(Docs + Offset);
339          WgtItemV.Sort(true); WgtItemV.Trunc(Docs);
340      } else if (ResItemV.Len() > Offset) {
341          WgtItemV = FullWgtItemV; WgtItemV.Sort(true);
342          WgtItemV.Trunc(FullWgtItemV.Len() - Offset);
343      } else {
344      }
345      WgtItemV.Sort(false);
346      printf("  Loading content for %d hits ...\n", WgtItemV.Len());
347      PWdGixRSet RSet = TWdGixRSet::New(
348          QueryStr, FullWgtItemV.Len(), Offset);
349      for (int ItemN = 0; ItemN < WgtItemV.Len(); ItemN++) {
350          const TWdGixItem& Item = WgtItemV[ItemN].Dat;
351          TBlobPt DocBlobPt = Item.GetBlobPt();
352          TStr DocTitle, DocStr; TStrV CatNmV;
353          GetDoc(DocBlobPt, DocTitle, DocStr, CatNmV);
354          TTm DateTime = WdGixMDS->GetDateTTm(DocBlobPt);
355          RSet->AddDoc(DocTitle, DocStr, CatNmV, DateTime);
356      }
357      printf("  Done\n");
358      return RSet;
359  }
360  void TWdGixBs::AddReuters(const TStr& XmlFNm) {
361      PXmlDoc Doc=TXmlDoc::LoadTxt(XmlFNm);
362      TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
363      TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
364      TChA DocChA; DocChA += "<doc>";
365      TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
366      DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
367      DocChA += "<body>";
368      TStr DocHeadline = Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
369      DocChA += "<p><em>"; DocChA += TXmlDoc::GetXmlStr(DocHeadline); DocChA += "</em></p>\n";
370      TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
371      for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
372          TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
373          TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("enamex", NmObjTokV);
374          for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
375              TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
376              ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
377          }
378          DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
379      }
380      DocChA += "</body></doc>";
381      TStrV CatNmV;
382      TXmlTokV CdsTokV; Doc->GetTagTokV("newsitem|metadata|codes", CdsTokV);
383      for (int CdsTokN = 0; CdsTokN < CdsTokV.Len(); CdsTokN++){
384          PXmlTok CdsTok = CdsTokV[CdsTokN];
385          TXmlTokV CdTokV; CdsTok->GetTagTokV("code", CdTokV);
386          if (CdsTok->GetArgVal("class") == "bip:topics:1.0"){
387              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
388                  TStr CdNm = CdTokV[CdTokN]->GetArgVal("code");
389                  CatNmV.AddMerged(CdNm);
390              }
391          } else if (CdsTok->GetArgVal("class")=="bip:countries:1.0"){
392              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
393                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
394                  CatNmV.AddMerged(CdNm);
395              }
396          } else if (CdsTok->GetArgVal("class")=="bip:industries:1.0"){
397              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
398                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
399                  CatNmV.AddMerged(CdNm);
400              }
401          } else { Fail; }
402      }
403      AddDoc(DocTitle, DocChA, CatNmV, DateTm);
404  }
405  void TWdGixBs::IndexReuters(const TStr& FPath) {
406      PNotify Notify = TStdNotify::New();
407      Notify->OnStatus("Loading Reuters documents from " + FPath + " ...\n");
408      TFFile FFile(FPath, ".xml", true);
409      TStr XmlFNm; int Files = 0;
410      while (FFile.Next(XmlFNm)) {
411          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm); Files++; }
412          if (Files % 1000 == 0) { Notify->OnStatus(TStr::Fmt("F:%d\r", Files)); }
413      }
414      Notify->OnStatus(TStr::Fmt("F:%d\n", Files));
415  }
416  void TWdGixBs::IndexNmEnBs(const TStr& FNm) {
417      PNotify Notify = TStdNotify::New();
418      Notify->OnStatus("Loading name-entitites from " + FNm + " ...\n");
419      PNmEnBs NmEnBs = TNmEnBs::LoadBin(FNm, true);
420      int NmEnKeyId = NmEnBs->GetFFirstNmEn();
421      int NmEnN = 0; const int NmEns = NmEnBs->GetNmEns();
422      while (NmEnBs->GetFNextNmEn(NmEnKeyId)) {
423          if (NmEnN > 100000) { break; }
424          if (NmEnN % 1000 == 0) { Notify->OnStatus(TStr::Fmt("N:%d/%d\r", NmEnN, NmEns)); }
425          TStr NmEnStr = NmEnBs->GetNmEnStr(NmEnKeyId);
426          IAssertR(NmEnBs->IsNmEn(NmEnStr), NmEnStr);
427          THash<TUInt, TChA> DateIntToCtxH; THash<TUInt, TInt> DateIntToCountH;
428          const TIntV& NmEnCtxIdV = NmEnBs->GetCtxIdV(NmEnKeyId);
429          for (int CtxIdN = 0; CtxIdN < NmEnCtxIdV.Len(); CtxIdN++) {
430              const int CtxId = NmEnCtxIdV[CtxIdN];
431              TStr NmEnCtxStr = NmEnBs->GetCtxStr(CtxId);
432              TTm NmEnCtxTm = NmEnBs->GetCtxTm(CtxId);
433              const uint DateInt = TTm::GetDateIntFromTm(NmEnCtxTm);
434              DateIntToCtxH.AddDat(DateInt) += NmEnCtxStr;
435              DateIntToCountH.AddDat(DateInt)++;
436          }
437          int CtxKeyId = DateIntToCtxH.FFirstKeyId();
438          while (DateIntToCtxH.FNextKeyId(CtxKeyId)) {
439              const int DateInt = DateIntToCtxH.GetKey(CtxKeyId);
440              TTm CtxDate = TTm::GetTmFromDateTimeInt(DateInt);
441              TStr CtxStr = DateIntToCtxH[CtxKeyId];
442              const uchar Wgt = uchar(DateIntToCountH.GetDat(DateInt).Val);
443              AddDoc(NmEnStr, CtxStr, TStrV(), CtxDate, Wgt);
444          }
445          NmEnN++;
446      }
447      Notify->OnStatus(TStr::Fmt("N:%d/%d", NmEnN, NmEns));
448  }
449  void TWdGixBs::IndexNyt(const TStr& XmlFNm) {
450      PNotify Notify = TStdNotify::New();
451      Notify->OnStatus("Loading NYT documents from " + XmlFNm + " ...\n");
452      PSIn SIn = TFIn::New(XmlFNm); int Docs = 0;
453      TStr LastTitle = "";
454      forever {
455          if (Docs % 1000 == 0) { Notify->OnStatus(TStr::Fmt("Docs: %d\r", Docs)); }
456          PXmlDoc Doc = TXmlDoc::LoadTxt(SIn); Docs++;
457          if (!Doc->IsOk()) { printf("%s - %s\n", LastTitle.CStr(), Doc->GetMsgStr().CStr()); break; }
458          TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
459          TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
460          TChA DocChA; DocChA += "<doc>";
461          TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
462          DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
463          DocChA += "<body>";
464          TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
465          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
466              TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
467              TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("ent", NmObjTokV);
468              for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
469                  TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
470                  ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
471              }
472              DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
473          }
474          DocChA += "</body></doc>";
475          AddDoc(DocTitle, DocChA, TStrV(), DateTm);
476          LastTitle = DocTitle;
477      }
478      Notify->OnStatus(TStr::Fmt("Docs: %d", Docs));
479  }
480  TSearchTopics::TSearchTopics(PWdGixRSet RSet, const int& Topics) {
481      PBowDocBs BowDocBs = RSet->GenBowDocBs();
482      TRnd Rnd(1);
483      PBowDocPart BowDocPart = TBowClust::GetKMeansPart(
484          TNullNotify::New(), BowDocBs, TBowSim::New(bstCos), Rnd,
485          Topics, 1, 10, 1, bwwtLogDFNrmTFIDF, 0.0, 0);
486      TopicV.Gen(Topics, 0);
487      TIntH FrameH; THash<TInt, TIntH> FrameTopicHH;
488      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
489          PBowDocPartClust Clust = BowDocPart->GetClust(ClustN);
490          TStr TopicNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 3, 1, ", ", false, false);
491          TopicV.Add(TopicNm);
492          for (int DocN = 0; DocN < Clust->GetDocs(); DocN++) {
493              const int DocId = Clust->GetDId(DocN);
494              TTm DocDate = RSet->GetDocDateTime(DocId);
495              const uint FrameId = TTm::GetYearIntFromTm(DocDate);
496              FrameH.AddDat(FrameId)++;
497              FrameTopicHH.AddDat(FrameId).AddDat(ClustN)++;
498          }
499      }
500      const int Frames = FrameH.Len();
501      FrameV.Gen(Frames, 0);
502      TopicFrameFqVV.Gen(Topics, Frames); TopicFrameFqVV.PutAll(0.0);
503      FrameH.SortByKey(); int FrameKeyId = FrameH.FFirstKeyId();
504      while (FrameH.FNextKeyId(FrameKeyId)) {
505          int FrameId = FrameH.GetKey(FrameKeyId);
506          TTm FrameDate = TTm::GetTmFromDateTimeInt(FrameId);
507          TStr FrameNm = TStr::Fmt("%4d", FrameDate.GetYear());
508          const int FrameN = FrameV.Add(FrameNm);
509          const TIntH& TopicH = FrameTopicHH.GetDat(FrameId);
510          int TopicKeyId = TopicH.FFirstKeyId(); int CountSum = 0;
511          while (TopicH.FNextKeyId(TopicKeyId)) {
512              const int TopicN = TopicH.GetKey(TopicKeyId);
513              int TopicCount = TInt::Abs(TopicH.GetDat(TopicKeyId)) > 1000 ?
514                  0 : TopicH.GetDat(TopicKeyId)();
515              CountSum += TopicCount;
516              const double Fq = double(CountSum); 
517              TopicFrameFqVV(TopicN, FrameN) = Fq;
518          }
519      }
520  }
521  TTrGixItem::TTrGixItem(const TBlobPt& BlobPt, const int& _SubjectId,
522      const int& _PredicatId, const int& _ObjectId, const int& _WdId,
523      const uchar& Type, const uchar& Pos, const bool& Full, const bool& Stem,
524      const uchar& Hyper): Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()),
525          SubjectId(_SubjectId), PredicatId(_PredicatId), ObjectId(_ObjectId), WdId(_WdId) {
526      SetWordInfo(Type, Pos, Full, Stem, Hyper);
527      ClrMergeInfo();
528  }
529  TTrGixItem::TTrGixItem(TSIn& SIn) {
530      SIn.Load(Seg); SIn.Load(Addr);
531      SIn.Load(SubjectId);
532      SIn.Load(PredicatId);
533      SIn.Load(ObjectId);
534      SIn.Load(WdId);
535      SIn.Load(WdInfo);
536      ClrMergeInfo();
537  }
538  void TTrGixItem::Save(TSOut& SOut) const {
539      SOut.Save(Seg); SOut.Save(Addr);
540      SOut.Save(SubjectId);
541      SOut.Save(PredicatId);
542      SOut.Save(ObjectId);
543      SOut.Save(WdId);
544      SOut.Save(WdInfo);
545  }
546  bool TTrGixItem::operator==(const TTrGixItem& Item) const {
547      return ((Seg==Item.Seg)&&(Addr==Item.Addr)&&
548          (SubjectId==Item.SubjectId)&&
549          (PredicatId==Item.PredicatId)&&
550          (ObjectId==Item.ObjectId));
551  }
552  bool TTrGixItem::operator<(const TTrGixItem& Item) const {
553      return (Seg<Item.Seg) ||
554          ((Seg==Item.Seg)&&(Addr<Item.Addr)) ||
555          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId<Item.SubjectId)) ||
556          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId<Item.PredicatId)) ||
557          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId==Item.PredicatId)&&(ObjectId<Item.ObjectId));
558  }
559  void TTrGixItem::SetWordInfo(const uchar& Type, const uchar& Pos,
560          const bool& Full, const bool& Stem, const uchar& Hyper) {
561      TTrGixItemWdInfo Info;
562      Info.Short = 0;
563      Info.Bits.Type = Type;
564      Info.Bits.Pos = Type;
565      Info.Bits.Full = Full ? 1 : 0;
566      Info.Bits.Stem = Stem ? 1 : 0;
567      Info.Bits.Hyper = Hyper;
568      WdInfo = Info.Short;
569  }
570  char TTrGix::SubjectType = 0;
571  char TTrGix::SubjectWdType = 1;
572  char TTrGix::SubjectAttrWdType = 2;
573  char TTrGix::SubjectStemType = 3;
574  char TTrGix::SubjectAttrStemType = 4;
575  char TTrGix::PredicatType = 5;
576  char TTrGix::PredicatWdType = 6;
577  char TTrGix::PredicatAttrWdType = 7;
578  char TTrGix::PredicatStemType = 8;
579  char TTrGix::PredicatAttrStemType = 9;
580  char TTrGix::ObjectType = 10;
581  char TTrGix::ObjectWdType = 11;
582  char TTrGix::ObjectAttrWdType = 12;
583  char TTrGix::ObjectStemType = 13;
584  char TTrGix::ObjectAttrStemType = 14;
585  void TTrGix::AddTrPart(const int& FullId, const char& Type, const int& SubjectId,
586          const int& PredicatId, const int& ObjectId, const TBlobPt& BlobPt) {
587      Gix->AddItem(TTrGixKey(FullId, Type),
588          TTrGixItem(BlobPt, SubjectId, PredicatId,
589              ObjectId, FullId, Type, 0, true, false, 0));
590  }
591  void TTrGix::AddTrPart(const TIntPrV& IdPrV, const char& WdType, const char& StemType,
592          const int& SubjectId, const int& PredicatId, const int& ObjectId,
593          const TBlobPt& BlobPt) {
594      for (int IdPrN = 0; IdPrN < IdPrV.Len(); IdPrN++) {
595          const int WdId = IdPrV[IdPrN].Val1;
596          Gix->AddItem(TTrGixKey(WdId, WdType),
597              TTrGixItem(BlobPt, SubjectId, PredicatId,
598                  ObjectId, WdId, WdType, IdPrN, false, false, 0));
599          const int StemId = IdPrV[IdPrN].Val2;
600          Gix->AddItem(TTrGixKey(StemId, StemType),
601              TTrGixItem(BlobPt, SubjectId, PredicatId,
602                  ObjectId, StemId, StemType, IdPrN, false, true, 0));
603      }
604  }
605  TTrGix::PTGixExpItem TTrGix::GetExactExp(const TStr& Str, const char& Type) {
606      TTrGixKey FullTrKey = TTrGixKey(GetWordId(Str, false), Type);
607      return TTGixExpItem::NewItem(FullTrKey);
608  }
609  TTrGix::PTGixExpItem TTrGix::GetPartExp(const TStr& Str, const char& WdType, const char& StemType) {
610      TIntPrV WordStemIdV; GetWordIdV(Str, WordStemIdV, false);
611      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
612      for (int WordStemIdN = 0; WordStemIdN < WordStemIdV.Len(); WordStemIdN++) {
613          TTrGixKey WdKey(WordStemIdV[WordStemIdN].Val1, WdType);
614          TTrGixKey StemKey(WordStemIdV[WordStemIdN].Val2, StemType);
615          PTGixExpItem ExpItem = TTGixExpItem::NewOr(
616              TTGixExpItem::NewItem(WdKey), TTGixExpItem::NewItem(StemKey));
617          if (Exp->IsEmpty()) { Exp = ExpItem; }
618          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
619      }
620      return Exp;
621  }
622  TTrGix::TTrGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
623      FPath = _FPath; FAccess = _FAccess;
624      Gix = TTGix::New(TGixConst::TrGixFNm, FPath, FAccess, CacheSize);
625      if (FAccess == faCreate) {
626          Stemmer = TStemmer::New(stmtPorter, true);
627      } else {
628          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
629          TFIn FIn(TrGixDatFNm);
630          WordH.Load(FIn);
631          Stemmer = TStemmer::Load(FIn);
632      }
633  }
634  TTrGix::~TTrGix() {
635      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
636          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
637          TFOut FOut(TrGixDatFNm);
638          WordH.Save(FOut);
639          Stemmer->Save(FOut);
640      }
641  }
642  int TTrGix::GetWordId(const TStr& WordStr, const bool& AddIfNotExistP) {
643      if (WordStr.Empty()) { return -1; }
644      if (AddIfNotExistP) { return WordH.AddKey(WordStr.GetUc()); }
645      else { return WordH.GetKeyId(WordStr.GetUc()); }
646  }
647  inline TStr TTrGix::GetWordStr(const int& WId) const {
648      return WId != -1 ? WordH.GetKey(WId) : "";
649  }
650  void TTrGix::GetWordIdV(const TStr& Str,
651          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
652      PSIn HtmlSIn = TStrIn::New(Str);
653      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
654      while (HtmlLx.Sym != hsyEof) {
655          if (HtmlLx.Sym == hsyStr) {
656              const TStr WordStr = HtmlLx.UcChA;
657              const int WordId = GetWordId(WordStr, AddIfNotExistP);
658              const int StemId = GetWordId(Stemmer->GetStem(WordStr), AddIfNotExistP);
659              WordStemIdV.Add(TIntPr(WordId, StemId));
660          }
661          HtmlLx.GetSym();
662      }
663  }
664  void TTrGix::GetWordIdV(const TStrV& WordStrV,
665          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
666      for (int WordStrN = 0; WordStrN < WordStrV.Len(); WordStrN++) {
667          GetWordIdV(WordStrV[WordStrN], WordStemIdV, AddIfNotExistP);
668      }
669  }
670  void TTrGix::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
671          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
672          const TStrV& ObjectAttrV, const TBlobPt& BlobPt) {
673      const int SubjectId = GetWordId(SubjectStr, true);
674      const int PredicatId = GetWordId(PredicatStr, true);
675      const int ObjectId = GetWordId(ObjectStr, true);
676      AddTrPart(SubjectId, SubjectType, SubjectId, PredicatId, ObjectId, BlobPt);
677      AddTrPart(PredicatId, PredicatType, SubjectId, PredicatId, ObjectId, BlobPt);
678      AddTrPart(ObjectId, ObjectType, SubjectId, PredicatId, ObjectId, BlobPt);
679      TIntPrV SubjectWIdSIdV; GetWordIdV(SubjectStr, SubjectWIdSIdV, true);
680      TIntPrV SubjectAttrWIdSIdV; GetWordIdV(SubjectAttrV, SubjectAttrWIdSIdV, true);
681      TIntPrV PredicatWIdSIdV; GetWordIdV(PredicatStr, PredicatWIdSIdV, true);
682      TIntPrV PredicatAttrWIdSIdV; GetWordIdV(PredicatAttrV, PredicatAttrWIdSIdV, true);
683      TIntPrV ObjectWIdSIdV; GetWordIdV(ObjectStr, ObjectWIdSIdV, true);
684      TIntPrV ObjectAttrWIdSIdV; GetWordIdV(ObjectAttrV, ObjectAttrWIdSIdV, true);
685      AddTrPart(SubjectWIdSIdV, SubjectWdType, SubjectStemType,
686          SubjectId, PredicatId, ObjectId, BlobPt);
687      AddTrPart(SubjectAttrWIdSIdV, SubjectAttrWdType, SubjectAttrStemType,
688          SubjectId, PredicatId, ObjectId, BlobPt);
689      AddTrPart(PredicatWIdSIdV, PredicatWdType, PredicatStemType,
690          SubjectId, PredicatId, ObjectId, BlobPt);
691      AddTrPart(PredicatAttrWIdSIdV, PredicatAttrWdType, PredicatAttrStemType,
692          SubjectId, PredicatId, ObjectId, BlobPt);
693      AddTrPart(ObjectWIdSIdV, ObjectWdType, ObjectStemType,
694          SubjectId, PredicatId, ObjectId, BlobPt);
695      AddTrPart(ObjectAttrWIdSIdV, ObjectAttrWdType, ObjectAttrStemType,
696          SubjectId, PredicatId, ObjectId, BlobPt);
697  }
698  bool TTrGix::SearchExact(const TStr& SubjectStr, const TStr& PredicatStr,
699          const TStr& ObjectStr, TTrGixItemV& ResItemV) {
700      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
701      if (!SubjectStr.Empty()) {
702          PTGixExpItem ExpItem = GetExactExp(SubjectStr, SubjectType);
703          if (Exp->IsEmpty()) { Exp = ExpItem; }
704          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
705      }
706      if (!PredicatStr.Empty()) {
707          PTGixExpItem ExpItem = GetExactExp(PredicatStr, PredicatType);
708          if (Exp->IsEmpty()) { Exp = ExpItem; }
709          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
710      }
711      if (!ObjectStr.Empty()) {
712          PTGixExpItem ExpItem = GetExactExp(ObjectStr, ObjectType);
713          if (Exp->IsEmpty()) { Exp = ExpItem; }
714          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
715      }
716      return Exp->Eval(Gix, ResItemV);
717  }
718  bool TTrGix::SearchPart(const TStr& SubjectStr, const TStr& PredicatStr,
719          const TStr& ObjectStr, TTrGixItemV& ResItemV, const bool& IncExactP) {
720      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
721      if (!SubjectStr.Empty()) {
722          PTGixExpItem ExpItem = GetPartExp(SubjectStr, SubjectWdType, SubjectStemType);
723          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(SubjectStr, SubjectType), ExpItem); }
724          if (Exp->IsEmpty()) { Exp = ExpItem; }
725          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
726      }
727      if (!PredicatStr.Empty()) {
728          PTGixExpItem ExpItem = GetPartExp(PredicatStr, PredicatWdType, PredicatStemType);
729          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(PredicatStr, PredicatType), ExpItem); }
730          if (Exp->IsEmpty()) { Exp = ExpItem; }
731          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
732      }
733      if (!ObjectStr.Empty()) {
734          PTGixExpItem ExpItem = GetPartExp(ObjectStr, ObjectWdType, ObjectStemType);
735          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(ObjectStr, ObjectType), ExpItem); }
736          if (Exp->IsEmpty()) { Exp = ExpItem; }
737          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
738      }
739      return Exp->Eval(Gix, ResItemV);
740  }
741  void TTrGixRSet::AddTr(const TStrTr& TrStr, const TBlobPtV& TrAttrBlobPtV) {
742      TrStrV.Add(TrStr);
743      TrAttrBlobPtVV.Add(TrAttrBlobPtV);
744  }
745  void TTrGixRSet::GetSubjectV(TStrIntKdV& SubjectStrWgtV) {
746      TIntStrKdV SubjectWgtStrV;
747      for (int TrN = 0; TrN < GetTrs(); TrN++) {
748          const TStr& SubjectStr = TrStrV[TrN].Val1;
749          const int Wgt = GetTrCount(TrN);
750          SubjectWgtStrV.Add(TIntStrKd(Wgt, SubjectStr));
751      }
752      SubjectWgtStrV.Sort(false);
753      GetSwitchedKdV<TInt, TStr>(SubjectWgtStrV, SubjectStrWgtV);
754  }
755  void TTrGixRSet::GetPredicatV(TStrIntKdV& PredicatStrWgtV) {
756      TIntStrKdV PredicatWgtStrV;
757      for (int TrN = 0; TrN < GetTrs(); TrN++) {
758          const TStr& PredicatStr = TrStrV[TrN].Val2;
759          const int Wgt = GetTrCount(TrN);
760          PredicatWgtStrV.Add(TIntStrKd(Wgt, PredicatStr));
761      }
762      PredicatWgtStrV.Sort(false);
763      GetSwitchedKdV<TInt, TStr>(PredicatWgtStrV, PredicatStrWgtV);
764  }
765  void TTrGixRSet::GetObjectV(TStrIntKdV& ObjectStrWgtV) {
766      TIntStrKdV ObjectWgtStrV;
767      for (int TrN = 0; TrN < GetTrs(); TrN++) {
768          const TStr& ObjectStr = TrStrV[TrN].Val3;
769          const int Wgt = GetTrCount(TrN);
770          ObjectWgtStrV.Add(TIntStrKd(Wgt, ObjectStr));
771      }
772      ObjectWgtStrV.Sort(false);
773      GetSwitchedKdV<TInt, TStr>(ObjectWgtStrV, ObjectStrWgtV);
774  }
775  void TTrGixRSet::PrintRes(const bool& PrintSentsP, PNotify Notify) const {
776      printf("Query:\n");
777      printf("  Subject: '%s'\n", GetSubjectStr().CStr());
778      printf("  Predicat: '%s'\n", GetPredicatStr().CStr());
779      printf("  Object: '%s'\n", GetObjectStr().CStr());
780      printf("Displaying: %d - %d (All hits: %d)\n",
781          GetOffset()+1, Offset.Val+GetTrs()+1, GetAllTrs());
782      for (int TrN = 0; TrN < GetTrs(); TrN++) {
783          printf("%d. [%s <- %s -> %s], (Support:%d)\n", TrN+GetOffset()+1,
784              GetTrSubjectStr(TrN).CStr(), GetTrPredicatStr(TrN).CStr(),
785              GetTrObjectStr(TrN).CStr(), GetTrCount(TrN));
786      }
787  }
788  void TTrGixBs::GetAttrV(PXmlTok XmlTok, TStrV& AttrV) {
789      TXmlTokV AttrTokV; XmlTok->GetTagTokV("attrib", AttrTokV);
790      for (int AttrTokN = 0; AttrTokN < AttrTokV.Len(); AttrTokN++) {
791          PXmlTok AttrTok = AttrTokV[AttrTokN];
792          AttrV.Add(AttrTok->GetStrArgVal("word"));
793          GetAttrV(AttrTok, AttrV);
794      }
795  }
796  TTrGixBs::TTrGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
797      FPath = _FPath; FAccess = _FAccess;
798      TStr TrGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDocBsFNm;
799      DocBBs = TMBlobBs::New(TrGixDocBsFNm, FAccess);
800      TStr TrGixSentBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixSentBsFNm;
801      SentBBs = TMBlobBs::New(TrGixSentBsFNm, FAccess);
802      TStr TrGixTrAttrBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixTrAttrBsFNm;
803      TrAttrBBs = TMBlobBs::New(TrGixTrAttrBsFNm, FAccess);
804      TrGix = TTrGix::New(FPath, FAccess, CacheSize);
805  }
806  TTrGixBs::~TTrGixBs() {
807      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
808      }
809  }
810  TBlobPt TTrGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr, const TStrV& CatNmV) {
811      TMOut DocMOut;
812      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
813      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
814      return DocBlobPt;
815  }
816  TBlobPt TTrGixBs::AddSent(const TStr& SentStr) {
817      TMOut SentMOut; SentStr.Save(SentMOut);
818      TBlobPt SentBlobPt = SentBBs->PutBlob(SentMOut.GetSIn());
819      return SentBlobPt;
820  }
821  TBlobPt TTrGixBs::AddTrAttr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
822          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
823          const TStrV& ObjectAttrV, const TBlobPt& SentBlobPt, const TBlobPt& DocBlobPt) {
824      TMOut TrAttrMOut;
825      SubjectStr.Save(TrAttrMOut); SubjectAttrV.Save(TrAttrMOut);
826      PredicatStr.Save(TrAttrMOut); PredicatAttrV.Save(TrAttrMOut);
827      ObjectStr.Save(TrAttrMOut); ObjectAttrV.Save(TrAttrMOut);
828      SentBlobPt.Save(TrAttrMOut); DocBlobPt.Save(TrAttrMOut);
829      TBlobPt TrAttrBlobPt = TrAttrBBs->PutBlob(TrAttrMOut.GetSIn());
830      return TrAttrBlobPt;
831  }
832  void TTrGixBs::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
833          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
834          const TStrV& ObjectAttrV, const TBlobPt& TrAttrBlobPt) {
835      TrGix->AddTr(SubjectStr, SubjectAttrV, PredicatStr,
836          PredicatAttrV, ObjectStr, ObjectAttrV, TrAttrBlobPt);
837  }
838  void TTrGixBs::GetDoc(const TBlobPt& DocBlobPt, TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
839      PSIn SIn = DocBBs->GetBlob(DocBlobPt);
840      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
841  }
842  TStr TTrGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
843      PSIn SIn = DocBBs->GetBlob(BlobPt);
844      TStr DocTitle; DocTitle.Load(*SIn);
845      return DocTitle;
846  }
847  TStr TTrGixBs::GetDocStr(const TBlobPt& BlobPt) const {
848      PSIn SIn = DocBBs->GetBlob(BlobPt);
849      {TStr DocTitle; DocTitle.Load(*SIn);}
850      TStr DocStr; DocStr.Load(*SIn);
851      return DocStr;
852  }
853  TStrV TTrGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
854      PSIn SIn = DocBBs->GetBlob(BlobPt);
855      {TStr DocTitle; DocTitle.Load(*SIn);}
856      {TStr DocStr; DocStr.Load(*SIn);}
857      TStrV CatNmV; CatNmV.Load(*SIn);
858      return CatNmV;
859  }
860  TStr TTrGixBs::GetSentStr(const TBlobPt& SentBlobPt) {
861      PSIn SIn = SentBBs->GetBlob(SentBlobPt);
862      return TStr(*SIn);
863  }
864  void TTrGixBs::GetTrAttr(const TBlobPt& TrAttrBlobPt, TStr& SubjectStr,
865          TStrV& SubjectAttrV, TStr& PredicatStr, TStrV& PredicatAttrV,
866          TStr& ObjectStr, TStrV& ObjectAttrV, TBlobPt& SentBlobPt,
867          TBlobPt& DocBlobPt) {
868      PSIn SIn = TrAttrBBs->GetBlob(TrAttrBlobPt);
869      SubjectStr.Load(*SIn); SubjectAttrV.Load(*SIn);
870      PredicatStr.Load(*SIn); PredicatAttrV.Load(*SIn);
871      ObjectStr.Load(*SIn); ObjectAttrV.Load(*SIn);
872      SentBlobPt = TBlobPt(*SIn); DocBlobPt = TBlobPt(*SIn);
873  }
874  PTrGixRSet TTrGixBs::SearchTr(const TStr& SubjectStr, const TStr& PredicatStr,
875          const TStr& ObjectStr, TTrGixRankFun& RankFun, const int& Docs,
876          const int& Offset, const bool& ExactP) {
877      TTrGixItemV ResItemV;
878      if (ExactP) { TrGix->SearchExact(SubjectStr, PredicatStr, ObjectStr, ResItemV); }
879      else { TrGix->SearchPart(SubjectStr, PredicatStr, ObjectStr, ResItemV, true); }
880      THash<TIntTr, TIntV> TrToItemVH;
881      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
882          const TTrGixItem& Item = ResItemV[ItemN];
883          TrToItemVH.AddDat(Item.GetIdTr()).Add(ItemN);
884      }
885      TFltIntKdV FullWgtTrKeyIdV;
886      int TrKeyId = TrToItemVH.FFirstKeyId();
887      while (TrToItemVH.FNextKeyId(TrKeyId)) {
888          const double Wgt = RankFun(TrToItemVH[TrKeyId].Len());
889          FullWgtTrKeyIdV.Add(TFltIntKd(Wgt, TrKeyId));
890      }
891      TFltIntKdV WgtTrKeyIdV;
892      if (Docs == -1) {
893          WgtTrKeyIdV = FullWgtTrKeyIdV;
894      } else if (ResItemV.Len() >= (Docs + Offset)) {
895          WgtTrKeyIdV = FullWgtTrKeyIdV;
896          WgtTrKeyIdV.Sort(false); WgtTrKeyIdV.Trunc(Docs + Offset);
897          WgtTrKeyIdV.Sort(true); WgtTrKeyIdV.Trunc(Docs);
898      } else if (ResItemV.Len() > Offset) {
899          WgtTrKeyIdV = FullWgtTrKeyIdV; WgtTrKeyIdV.Sort(true);
900          WgtTrKeyIdV.Trunc(FullWgtTrKeyIdV.Len() - Offset);
901      } else {
902      }
903      WgtTrKeyIdV.Sort(false);
904      PTrGixRSet RSet = TTrGixRSet::New(SubjectStr, PredicatStr,
905          ObjectStr, FullWgtTrKeyIdV.Len(), Offset);
906      for (int TrN = 0; TrN < WgtTrKeyIdV.Len(); TrN++) {
907          const int TrKeyId = WgtTrKeyIdV[TrN].Dat;
908          const TIntTr& WIdTr = TrToItemVH.GetKey(TrKeyId);
909          const TIntV& ItemV = TrToItemVH[TrKeyId];
910          TStr SubjectStr = TrGix->GetWordStr(WIdTr.Val1);
911          TStr PredicatStr = TrGix->GetWordStr(WIdTr.Val2);
912          TStr ObjectStr = TrGix->GetWordStr(WIdTr.Val3);
913          TStrTr TrStr(SubjectStr, PredicatStr, ObjectStr);
914          TBlobPtV TrAttrBlobPtV;
915          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
916              const TTrGixItem& Item = ResItemV[ItemV[ItemN]];
917              TBlobPt TrAttrBlobPt = Item.GetBlobPt();
918              TrAttrBlobPtV.Add(TrAttrBlobPt);
919          }
920          RSet->AddTr(TrStr, TrAttrBlobPtV);
921      }
922      return RSet;
923  }
924  void TTrGixBs::AddReuters(const TStr& XmlFNm, int& Trs, const PSOut& CsvOut) {
925      PNotify Notify = TStdNotify::New();
926      TBlobPt EmptyDocBlobPt = AddDoc("No full document text!");
927      PSIn XmlSIn = TFIn::New(XmlFNm);
928      TXmlDoc::SkipTopTag(XmlSIn);
929      PXmlDoc XmlDoc; int XmlDocs = 0;
930      forever{
931          if (Trs % 100 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", Trs)); }
932          XmlDocs++; XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
933          if (!XmlDoc->IsOk()) { break; }
934          PXmlTok TopTok = XmlDoc->GetTok();
935          if (TopTok->IsTag("sentence")){
936              TStr DocStr = ""; TBlobPt DocBlobPt = EmptyDocBlobPt;
937              TStr SentStr = TopTok->GetTagTok("originalSentence")->GetTokStr(false);
938              TBlobPt SentBlobPt = AddSent(SentStr);
939              TXmlTokV TrTokV; TopTok->GetTagTokV("triplet", TrTokV);
940              for (int TrTokN = 0; TrTokN < TrTokV.Len(); TrTokN++) {
941                  PXmlTok TrTok = TrTokV[TrTokN];
942                  TStr SubjectStr = TrTok->GetTagTok("subject")->GetStrArgVal("word");
943                  TStr PredicatStr = TrTok->GetTagTok("verb")->GetStrArgVal("word");
944                  TStr ObjectStr = TrTok->GetTagTok("object")->GetStrArgVal("word");
945                  TStrV SubjectAttrV; GetAttrV(TrTok->GetTagTok("subject"), SubjectAttrV);
946                  TStrV PredicatAttrV; GetAttrV(TrTok->GetTagTok("verb"), PredicatAttrV);
947                  TStrV ObjectAttrV; GetAttrV(TrTok->GetTagTok("object"), ObjectAttrV);
948                  TBlobPt TrAttrBlobPt = AddTrAttr(SubjectStr, SubjectAttrV,
949                      PredicatStr, PredicatAttrV, ObjectStr, ObjectAttrV,
950                      SentBlobPt, DocBlobPt);
951                  AddTr(SubjectStr, SubjectAttrV, PredicatStr, PredicatAttrV,
952                      ObjectStr, ObjectAttrV, TrAttrBlobPt);
953                  Trs++;
954                  if (!CsvOut.Empty()) {
955                      SubjectStr.DelChAll(','); CsvOut->PutStr(SubjectStr + ",");
956                      PredicatStr.DelChAll(','); CsvOut->PutStr(PredicatStr + ",");
957                      ObjectStr.DelChAll(','); CsvOut->PutStr(ObjectStr + ",");
958                      CsvOut->PutStr(TStr::Fmt("%u,", uint(SentBlobPt.GetSeg())));
959                      CsvOut->PutStr(TStr::Fmt("%u,", SentBlobPt.GetAddr()));
960                      CsvOut->PutStr(TStr::Fmt("%d,", SubjectAttrV.Len()));
961                      for (int AttrN = 0; AttrN < SubjectAttrV.Len(); AttrN++) {
962                          SubjectAttrV[AttrN].DelChAll(',');
963                          CsvOut->PutStr(SubjectAttrV[AttrN]);
964                          CsvOut->PutStr(",");
965                      }
966                      CsvOut->PutStr(TStr::Fmt("%d,", PredicatAttrV.Len()));
967                      for (int AttrN = 0; AttrN < PredicatAttrV.Len(); AttrN++) {
968                          PredicatAttrV[AttrN].DelChAll(',');
969                          CsvOut->PutStr(PredicatAttrV[AttrN]);
970                          CsvOut->PutStr(",");
971                      }
972                      CsvOut->PutStr(TStr::Fmt("%d,", ObjectAttrV.Len()));
973                      for (int AttrN = 0; AttrN < ObjectAttrV.Len(); AttrN++) {
974                          ObjectAttrV[AttrN].DelChAll(',');
975                          CsvOut->PutStr(ObjectAttrV[AttrN]);
976                          CsvOut->PutStr(",");
977                      }
978                      CsvOut->PutStr("-1"); CsvOut->PutLn();
979                  }
980              }
981          }
982      }
983      CsvOut->Flush();
984  }
985  void TTrGixBs::IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm, const int& MxTrs) {
986      PNotify Notify = TStdNotify::New();
987      Notify->OnStatus("Loading Reuters documents from " + XmlFPath + " ...\n");
988      TFFile FFile(XmlFPath, ".xml", true); TStr XmlFNm; int Files = 0, Trs = 0;
989      PSOut CsvOut; if (!CsvFNm.Empty()) { CsvOut = TFOut::New(CsvFNm); }
990      while (FFile.Next(XmlFNm) && ((MxTrs == -11)||(MxTrs > Trs))) {
991          Notify->OnStatus(TStr::Fmt("Loading %3d : %s ...", Files+1, XmlFNm.CStr()));
992          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm, Trs, CsvOut); Files++; }
993      }
994      Notify->OnStatus(TStr::Fmt("Triplets loaded: %d", Trs));
995  }
996  TMWdGixItem::TMWdGixItem(TSIn& SIn) {
997      SIn.Load(Seg); SIn.Load(Addr);
998      SIn.Load(WdFq); SIn.Load(DocWds);
999  }
1000  void TMWdGixItem::Save(TSOut& SOut) const {
1001      SOut.Save(Seg); SOut.Save(Addr);
1002      SOut.Save(WdFq); SOut.Save(DocWds);
1003  }
1004  inline bool TMWdGixItem::operator==(const TMWdGixItem& Item) const {
1005      return (Seg == Item.Seg) && (Addr == Item.Addr);
1006  }
1007  inline bool TMWdGixItem::operator<(const TMWdGixItem& Item) const {
1008      return (Seg < Item.Seg) || ((Seg == Item.Seg) && (Addr < Item.Addr));
1009  }
1010  void TMWdGixDefMerger::Union(TMWdGixItemV& DstV, const TMWdGixItemV& SrcV) const {
1011      TMWdGixItemV DstValV(TInt::GetMx(DstV.Len(), SrcV.Len()), 0);
1012      int ValN1 = 0; int ValN2 = 0;
1013      while ((ValN1<DstV.Len()) && (ValN2<SrcV.Len())){
1014          const TMWdGixItem& Val1 = DstV.GetVal(ValN1);
1015          const TMWdGixItem& Val2 = SrcV.GetVal(ValN2);
1016          if (Val1 < Val2) { DstValV.Add(Val1); ValN1++; }
1017          else if (Val1>Val2) { DstValV.Add(Val2); ValN2++; }
1018          else { DstValV.Add(TMWdGixItem(Val1, Val2)); ValN1++; ValN2++; }
1019      }
1020      for (int RestValN1=ValN1; RestValN1<DstV.Len(); RestValN1++){
1021          DstValV.Add(DstV.GetVal(RestValN1));}
1022      for (int RestValN2=ValN2; RestValN2<SrcV.Len(); RestValN2++){
1023          DstValV.Add(SrcV.GetVal(RestValN2));}
1024      DstV = DstValV;
1025  }
1026  void TMWdGixDefMerger::Def(const TInt& Key, TMWdGixItemV& ItemV) const  {
1027      const int WdDocFq = MWdGix->GetWdFq(Key);
1028      const int Docs = MWdGix->GetAllDocs();
1029      const double AvgDocWds = MWdGix->GetAvgDocWds();
1030      const int Items = ItemV.Len();
1031      for (int ItemN = 0; ItemN < Items; ItemN++) {
1032          TMWdGixItem& Item = ItemV[ItemN];
1033          const int WdFq = Item.GetWdFq();
1034          const int DocWds = Item.GetDocWds();
1035          const double Wgt = RankFun->WdRank(WdFq, DocWds, WdDocFq, Docs, AvgDocWds);
1036          Item.PutWgt(Wgt);
1037      }
1038  }
1039  TMWdGix::TMWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
1040      FPath = _FPath; FAccess = _FAccess;
1041      printf("Loading '%s' .. ", FPath.CStr());
1042      if (FAccess == faCreate) { printf("create .. "); }
1043      if (FAccess == faRdOnly) { printf("read-only .. "); }
1044      printf("Cache[%s]\n", TUInt64::GetMegaStr(CacheSize).CStr());
1045      MWGix = TMWGix::New(TGixConst::MWdGixFNm, FPath, FAccess, CacheSize);
1046      if (FAccess != faCreate) {
1047          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1048          TFIn FIn(MWdGixDatFNm);
1049          WordH.Load(FIn);
1050          AllDocs.Load(FIn);
1051          AllWords.Load(FIn);
1052      }
1053  }
1054  TMWdGix::~TMWdGix() {
1055      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1056          printf("Closing %s: docs=%d, words=%d\n",
1057              FPath.CStr(), AllDocs.Val, AllWords.Val);
1058          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1059          TFOut FOut(MWdGixDatFNm);
1060          WordH.Save(FOut);
1061          AllDocs.Save(FOut);
1062          AllWords.Save(FOut);
1063      }
1064  }
1065  void TMWdGix::AddHtml(const TStr& DocStr, const TBlobPt& BlobPt) {
1066      PSIn HtmlSIn = TStrIn::New(DocStr);
1067      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1068      TIntH DocWIdH; int DocWds = 0;
1069      while (HtmlLx.Sym != hsyEof) {
1070          if (HtmlLx.Sym == hsyStr) {
1071              TStr WordStr = HtmlLx.UcChA;
1072              const int WId = WordH.AddKey(WordStr);
1073              DocWIdH.AddDat(WId)++;
1074              DocWds++;
1075          }
1076          HtmlLx.GetSym();
1077      }
1078      int WdKeyId = DocWIdH.FFirstKeyId();
1079      while (DocWIdH.FNextKeyId(WdKeyId)) {
1080          const int WId = DocWIdH.GetKey(WdKeyId);
1081          const int WdFq = DocWIdH[WdKeyId];
1082          WordH[WId]++; 
1083          TMWdGixKey Key(WId);
1084          TMWdGixItem Item(BlobPt, WdFq, DocWds);
1085          MWGix->AddItem(Key, Item);
1086      }
1087      AllDocs++; AllWords += DocWds;
1088  }
1089  bool TMWdGix::Search(const TStr& QueryStr,
1090          TMWdGixItemV& ResItemV, const TMWdGixDefMerger& Merger) {
1091      PMWGixExpItem MWGixExp = TMWGixExpItem::NewEmpty();
1092      PSIn HtmlSIn = TStrIn::New(QueryStr);
1093      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1094      while (HtmlLx.Sym != hsyEof) {
1095          if (HtmlLx.Sym == hsyStr) {
1096              TStr WordStr = HtmlLx.UcChA;
1097              const int WId = WordH.GetKeyId(WordStr);
1098              if (WId != -1) {
1099                  PMWGixExpItem MWGixExpItem = TMWGixExpItem::NewItem(TMWdGixKey(WId));
1100                  if (MWGixExp->IsEmpty()) { MWGixExp = MWGixExpItem; }
1101                  else { MWGixExp = TMWGixExpItem::NewOr(MWGixExp, MWGixExpItem); }
1102              }
1103          }
1104          HtmlLx.GetSym();
1105      }
1106      return MWGixExp->Eval(MWGix, ResItemV, Merger);
1107  }
1108  TStr TMWdGixRSet::GetMainPara(const TStr& QueryStr, const TStr& FullStr) {
1109      PBowDocBs BowDocBs = TBowDocBs::New();
1110      BowDocBs->AddHtmlDoc("Query", TStrV(), QueryStr, false);
1111      TStrV ParaV; FullStr.SplitOnAllCh('\n', ParaV);
1112      if (ParaV.Empty()) { return ""; }
1113      for (int ParaN = 0; ParaN < ParaV.Len(); ParaN++) {
1114          BowDocBs->AddHtmlDoc("Doc" + TInt::GetStr(ParaN), TStrV(), ParaV[ParaN], false);
1115      }
1116      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
1117      PBowSpV QuerySpV = BowDocWgtBs->GetSpV(0); int MxParaN = 0;
1118      double MxParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(1));
1119      for (int ParaN = 1; ParaN < ParaV.Len(); ParaN++) {
1120          const double ParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(ParaN+1));
1121          if (ParaSim > MxParaSim) {
1122              MxParaSim = ParaSim;
1123              MxParaN = ParaN;
1124          }
1125      }
1126      return ParaV[MxParaN];
1127  }
1128  void TMWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
<span onclick='openModal()' class='match'>1129          const TStr& DocLang, const TStrV& KeyWdV) {
1130      DocTitleV.Add(DocTitle);
1131      DocTitleV.Last().DelChAll('\n');
1132      DocTitleV.Last().DelChAll('\r');
1133      DocStrV.Add(GetMainPara(LangQueryH.GetDat(DocLang), DocStr));
1134      DocLangV.Add(DocLang);
1135      KeyWdVV.Add(KeyWdV);
</span>1136  }
1137  void TMWdGixRSet::PrintRes(PNotify Notify) {
1138      const int Docs = GetDocs();
1139      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1140          AllDocs.Val, Docs, Docs + Offset.Val));
1141      for (int DocN = 0; DocN < Docs; DocN++) {
1142          TStr DocStr = DocTitleV[DocN] + " - " + DocStrV[DocN];
1143          DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
1144          Notify->OnStatus(TStr::Fmt("[%d:%s] %s ...", DocN+1,
1145              DocLangV[DocN].CStr(), DocStr.Left(60).CStr()));
1146      }
1147      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1148          AllDocs.Val, Docs, Docs + Offset.Val));
1149  }
1150  TStr TMWdGixRSet::GetWsXml(const TStrPrStrH& EurovocH) const {
1151      PXmlTok TopTok = TXmlTok::New("cca");
1152      TopTok->AddArg("allhits", GetAllDocs());
1153      for (int DocN = 0; DocN < GetDocs(); DocN++) {
1154          PXmlTok HitTok = TXmlTok::New("hit");
1155          HitTok->AddArg("rank", DocN+1);
1156          HitTok->AddArg("lang", DocLangV[DocN]);
1157          TStr Title = DocTitleV[DocN];
1158          if (Title.Len() > 100) { Title = Title.Left(100) + "..."; }
1159          TStr Snipet = DocStrV[DocN].Left(800);
1160          if (Snipet.Len() > 800) { Snipet = Snipet.Left(800) + "..."; }
1161          HitTok->AddSubTok(TXmlTok::New("title", Title));
1162          HitTok->AddSubTok(TXmlTok::New("snipet", Snipet));
1163          PXmlTok KeyWdTok = TXmlTok::New("keywords");
1164          const TStrV& KeyWdV = KeyWdVV[DocN]; int GoodKeyWds = 0;
1165          for (int KeyWdN = 0; KeyWdN < KeyWdV.Len(); KeyWdN++) {
1166              TStrPr KeyWd(QueryLang, KeyWdV[KeyWdN]);
1167              if (EurovocH.IsKey(KeyWd)) {
1168                  KeyWdTok->AddSubTok(TXmlTok::New("keyword", EurovocH.GetDat(KeyWd)));
1169                  GoodKeyWds++;
1170              }
1171          }
1172          HitTok->AddSubTok(KeyWdTok);
1173          if (GoodKeyWds == 0) { continue; }
1174          TopTok->AddSubTok(HitTok);
1175      }
1176      return TopTok->GetTokStr();
1177  }
1178  TMWdGixBs::TMWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& _CacheSize) {
1179      FPath = _FPath; FAccess = _FAccess; CacheSize = _CacheSize;
1180      TStr MWdGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDocBsFNm;
1181      DocBBs = TMBlobBs::New(MWdGixDocBsFNm, FAccess);
1182      if (FAccess != faCreate) {
1183          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1184          AlignPairBs = TAlignPairBs::LoadBin(MWdGixBsFNm);
1185          InitGixs(FAccess);
1186      }
1187  }
1188  TMWdGixBs::~TMWdGixBs() {
1189      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1190          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1191          AlignPairBs->SaveBin(MWdGixBsFNm);
1192      }
1193  }
1194  void TMWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1195          const TStr& DocLang, const TStrV& KeyWdV) {
1196      TMOut DocMOut;
1197      DocTitle.Save(DocMOut); DocStr.Save(DocMOut);
1198      DocLang.Save(DocMOut); KeyWdV.Save(DocMOut);
1199      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
1200      LangMWdGixH.GetDat(DocLang)->AddHtml(DocStr, DocBlobPt);
1201  }
1202  void TMWdGixBs::GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
1203          TStr& DocStr, TStr& DocLang, TStrV& KeyWdV) const {
1204      PSIn SIn = DocBBs->GetBlob(BlobPt);
1205      DocTitle.Load(*SIn); DocStr.Load(*SIn);
1206      DocLang.Load(*SIn); KeyWdV.Load(*SIn);
1207  }
1208  PMWdGixRSet TMWdGixBs::SearchDoc(const TStr& QueryStr, const TStr& QueryLang,
1209          const TStrV& TargetLangV, const int& Docs, const int& Offset,
1210          PMWdGixRankFun& RankFun) {
1211      if (!AlignPairBs->IsLang(QueryLang)) {
1212          return TMWdGixRSet::New(QueryStr, "", TStrStrH(), 0, 0); }
1213      const int Queries = TargetLangV.Len();
1214      printf("  Translationg %d queries ...\n", Queries);
1215      const int QueryLangId = AlignPairBs->GetLangId(QueryLang);
1216      TStrStrH LangQueryH;
1217      TWgtMWdGixIntItemKdV FullWgtLangItemV;
1218      for (int TargetLangN = 0; TargetLangN < Queries; TargetLangN++) {
1219          if (!AlignPairBs->IsLang(TargetLangV[TargetLangN])) { continue; }
1220          const TStr& TargetLang = TargetLangV[TargetLangN];
1221          const int TargetLangId = AlignPairBs->GetLangId(TargetLang);
1222          if (TargetLangId == QueryLangId) { continue; }
1223          TStr TargetQueryStr = AlignPairBs->MapQuery(
1224              AlignPairMap, QueryStr, QueryLangId, TargetLangId);
1225          LangQueryH.AddDat(TargetLang, TargetQueryStr);
1226          printf("  Query: '%s' -> '%s'\n", QueryStr.CStr(), TargetQueryStr.CStr());
1227          printf("  Loading from Gix ...\n");
1228          TMWdGixItemV LangResItemV;
1229          PMWdGix LangMWdGix = LangMWdGixH.GetDat(TargetLang);
1230          TMWdGixDefMerger LangMerger(LangMWdGix, RankFun);
1231          LangMWdGix->Search(TargetQueryStr, LangResItemV, LangMerger);
1232          double MxWgt = 0.0;
1233          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1234              const TMWdGixItem& Item = LangResItemV[ItemN];
1235              MxWgt = TFlt::GetMx(Item.GetWgt(), MxWgt);
1236          }
1237          printf("  MxWgt: %g\n", MxWgt);
1238          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1239              const TMWdGixItem& Item = LangResItemV[ItemN];
1240              const double Wgt = MxWgt > 0.0 ? Item.GetWgt() / MxWgt : 0.0;
1241              TMWdGixIntItemPr LangItemPr(TargetLangId, Item);
1242              FullWgtLangItemV.Add(TWgtMWdGixIntItemKd(Wgt, LangItemPr));
1243          }
1244      }
1245      FullWgtLangItemV.Sort(false);
1246      printf("  Sorting %d hits ...\n", FullWgtLangItemV.Len());
1247      TWgtMWdGixIntItemKdV WgtLangItemV;
1248      if (Docs == -1) {
1249          WgtLangItemV = FullWgtLangItemV;
1250      } else if (FullWgtLangItemV.Len() >= (Docs + Offset)) {
1251          WgtLangItemV = FullWgtLangItemV;
1252          WgtLangItemV.Sort(false); WgtLangItemV.Trunc(Docs + Offset);
1253          WgtLangItemV.Sort(true); WgtLangItemV.Trunc(Docs);
1254      } else if (FullWgtLangItemV.Len() > Offset) {
1255          WgtLangItemV = FullWgtLangItemV; WgtLangItemV.Sort(true);
1256          WgtLangItemV.Trunc(FullWgtLangItemV.Len() - Offset);
1257      } else {
1258      }
1259      WgtLangItemV.Sort(false);
1260      printf("  Loading content for %d hits ...\n", WgtLangItemV.Len());
1261      PMWdGixRSet RSet = TMWdGixRSet::New(QueryStr,
1262          QueryLang, LangQueryH, FullWgtLangItemV.Len(), Offset);
1263      for (int ItemN = 0; ItemN < WgtLangItemV.Len(); ItemN++) {
1264          const TMWdGixIntItemPr& LangItem = WgtLangItemV[ItemN].Dat;
1265          const TMWdGixItem& Item = LangItem.Val2;
1266          TBlobPt DocBlobPt = Item.GetBlobPt();
1267          TStr DocTitle, DocStr, DocLang; TStrV KeyWdV;
1268          GetDoc(DocBlobPt, DocTitle, DocStr, DocLang, KeyWdV);
1269          RSet->AddDoc(DocTitle, DocStr, DocLang, KeyWdV);
1270      }
1271      printf("  Done\n");
1272      return RSet;
1273  }
1274  void TMWdGixBs::AddAcquis(const TStr& XmlFNm, const TStr& Lang) {
1275      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlFNm);
1276      if (!XmlDoc->IsOk()) { return; }
1277      PXmlTok TopTok = XmlDoc->GetTok();
1278      PXmlTok TextTok = TopTok->GetTagTok("text|body");
1279      if (TextTok.Empty()) { printf("  Bad file '%s'\n", XmlFNm.CStr()); return; }
1280      TStr DocTitle; TChA DocChA;
1281      for (int SubTokN = 0; SubTokN < TextTok->GetSubToks(); SubTokN++) {
1282          PXmlTok SubTok = TextTok->GetSubTok(SubTokN);
1283          if (!SubTok->IsTag()) { continue; }
1284          if (SubTok->GetTagNm() == "head") {
1285              DocTitle = SubTok->GetTokStr(false);
1286          } else if (SubTok->GetTagNm() == "div") {
1287              for (int ParaN = 0; ParaN < SubTok->GetSubToks(); ParaN++) {
1288                  if (SubTok->IsTag()) {
1289                      DocChA += SubTok->GetSubTok(ParaN)->GetTokStr(false);
1290                      DocChA += '\n';
1291                  }
1292              }
1293              DocChA += '\n';
1294          }
1295      }
1296      TStrV KeyWdV;
1297      PXmlTok KeyWdTok = TopTok->GetTagTok("teiHeader|profileDesc|textClass");
1298      if (!KeyWdTok.Empty()) {
1299          for (int SubTokN = 0; SubTokN < KeyWdTok->GetSubToks(); SubTokN++) {
1300              PXmlTok SubTok = KeyWdTok->GetSubTok(SubTokN);
1301              if (!SubTok->IsTag()) { continue; }
1302              if (SubTok->IsArg("scheme")) {
1303                  KeyWdV.Add(SubTok->GetStrArgVal("scheme") + "-" + SubTok->GetTokStr(false));
1304              }
1305          }
1306      }
1307      if (!KeyWdV.Empty()) { AddDoc(DocTitle, DocChA, Lang, KeyWdV); }
1308  }
1309  void TMWdGixBs::IndexAcquis(const TStr& InFPath, PAlignPairBs _AlignPairBs,
1310          const int& MxDocs, const int64& IndexCacheSize) {
1311      AlignPairBs = _AlignPairBs;
1312      int LangId = AlignPairBs->FFirstLangId();
1313      while (AlignPairBs->FNextLangId(LangId)) {
1314          const TStr& Lang = AlignPairBs->GetLang(LangId);
1315          TStr LangFPath = InFPath + "/" + Lang;
1316          printf("Indexing %s ...\n", LangFPath.CStr());
1317          LangMWdGixH.AddDat(Lang) =
1318                  TMWdGix::New(FPath + "/" + Lang, FAccess, IndexCacheSize);
1319          TFFile FFile(LangFPath, ".xml", true);
1320          TStr XmlFNm; int XmlFNms = 0;
1321          while (FFile.Next(XmlFNm)) {
1322              if (XmlFNms == MxDocs) { break; }
1323              if (XmlFNms % 100 == 0) { printf("  %d\r", XmlFNms); }
1324              try { AddAcquis(XmlFNm, Lang); } catch (...) { }
1325              XmlFNms++;
1326          } printf("\n");
1327          LangMWdGixH.Clr();
1328      }
1329      InitGixs(faRdOnly);
1330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ShortcutMapper.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>81  	NppDarkMode::setDarkScrollBar(_babygrid.getHSelf());
82  	_babygrid.setHeaderFont(_hGridFonts.at(GFONT_HEADER));
83  	_babygrid.setRowFont(_hGridFonts.at(GFONT_ROWS));
84  	_babygrid.reSizeToWH(rect);
85  	_babygrid.hideCursor();
86  	_babygrid.makeColAutoWidth(true);
87  	_babygrid.setAutoRow(true);
88  	_babygrid.setColsNumbered(false);
</pre></code></div>
                <div class="column column_space"><pre><code>1129          const TStr& DocLang, const TStrV& KeyWdV) {
1130      DocTitleV.Add(DocTitle);
1131      DocTitleV.Last().DelChAll('\n');
1132      DocTitleV.Last().DelChAll('\r');
1133      DocStrV.Add(GetMainPara(LangQueryH.GetDat(DocLang), DocStr));
1134      DocLangV.Add(DocLang);
1135      KeyWdVV.Add(KeyWdV);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    