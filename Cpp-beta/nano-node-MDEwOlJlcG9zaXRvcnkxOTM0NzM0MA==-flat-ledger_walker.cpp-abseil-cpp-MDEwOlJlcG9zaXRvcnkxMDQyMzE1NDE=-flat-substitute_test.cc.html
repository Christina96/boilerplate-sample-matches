
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.522504892367906%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ledger_walker.cpp</h3>
            <pre><code>1  #include <nano/node/ledger_walker.hpp>
2  #include <nano/test_common/system.hpp>
3  #include <nano/test_common/testutil.hpp>
4  #include <gtest/gtest.h>
5  #include <numeric>
6  #ifndef _WIN32
7  using namespace std::chrono_literals;
8  TEST (ledger_walker, genesis_block)
9  {
10  	nano::test::system system{};
11  	auto const node = system.add_node ();
12  	nano::ledger_walker ledger_walker{ node->ledger };
13  	std::size_t walked_blocks_count = 0;
14  	ledger_walker.walk_backward (nano::dev::genesis->hash (),
15  	[&] (auto const & block) {
16  		++walked_blocks_count;
17  		EXPECT_EQ (block->hash (), nano::dev::genesis->hash ());
18  	});
19  	EXPECT_EQ (walked_blocks_count, 1);
20  	walked_blocks_count = 0;
21  	ledger_walker.walk (nano::dev::genesis->hash (),
22  	[&] (auto const & block) {
23  		++walked_blocks_count;
24  		EXPECT_EQ (block->hash (), nano::dev::genesis->hash ());
25  	});
26  	EXPECT_EQ (walked_blocks_count, 1);
27  }
28  namespace nano
29  {
30  TEST (ledger_walker, genesis_account_longer)
31  {
32  	nano::test::system system{};
33  	nano::node_config node_config = system.default_config ();
34  	node_config.enable_voting = true;
35  	node_config.receive_minimum = 1;
36  	auto const node = system.add_node (node_config);
37  	nano::ledger_walker ledger_walker{ node->ledger };
38  	EXPECT_TRUE (ledger_walker.walked_blocks.empty ());
39  	EXPECT_LE (ledger_walker.walked_blocks.bucket_count (), 1);
40  	EXPECT_TRUE (ledger_walker.blocks_to_walk.empty ());
41  	auto const get_number_of_walked_blocks = [&ledger_walker] (auto const & start_block_hash) {
42  		std::size_t walked_blocks_count = 0;
43  		ledger_walker.walk_backward (start_block_hash,
44  		[&] (auto const & block) {
45  			++walked_blocks_count;
46  		});
47  		return walked_blocks_count;
48  	};
49  	auto const transaction = node->ledger.store.tx_begin_read ();
50  	auto genesis_account_info = node->ledger.account_info (transaction, nano::dev::genesis_key.pub);
51  	ASSERT_TRUE (genesis_account_info);
52  	EXPECT_EQ (get_number_of_walked_blocks (genesis_account_info->open_block), 1);
53  	EXPECT_EQ (get_number_of_walked_blocks (genesis_account_info->head), 1);
54  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
55  	for (auto itr = 1; itr <= 5; ++itr)
56  	{
57  		auto const send = system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 1);
58  		ASSERT_TRUE (send);
59  		EXPECT_EQ (get_number_of_walked_blocks (send->hash ()), 1 + itr * 2 - 1);
60  		ASSERT_TIMELY (3s, 1 + itr * 2 == node->ledger.cache.cemented_count);
61  		ASSERT_TRUE (node->ledger.account_info (transaction, nano::dev::genesis_key.pub));
62  	}
63  	EXPECT_TRUE (ledger_walker.walked_blocks.empty ());
64  	EXPECT_LE (ledger_walker.walked_blocks.bucket_count (), 1);
65  	EXPECT_TRUE (ledger_walker.blocks_to_walk.empty ());
66  }
67  }
68  TEST (ledger_walker, cross_account)
69  {
70  	nano::test::system system{};
71  	nano::node_config node_config = system.default_config ();
72  	node_config.enable_voting = true;
73  	node_config.receive_minimum = 1;
<span onclick='openModal()' class='match'>74  	auto const node = system.add_node (node_config);
75  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
76  	ASSERT_TRUE (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 1));
77  	ASSERT_TIMELY (3s, 3 == node->ledger.cache.cemented_count);
78  	nano::keypair key{};
79  	system.wallet (0)->insert_adhoc (key.prv);
</span>80  	ASSERT_TRUE (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
81  	ASSERT_TIMELY (3s, 5 == node->ledger.cache.cemented_count);
82  	auto const transaction = node->ledger.store.tx_begin_read ();
83  	auto account_info = node->ledger.account_info (transaction, key.pub);
84  	ASSERT_TRUE (account_info);
85  }
86  TEST (ledger_walker, DISABLED_ladder_geometry)
87  {
88  	nano::test::system system{};
89  	nano::node_config node_config = system.default_config ();
90  	node_config.enable_voting = true;
91  	node_config.receive_minimum = 1;
92  	auto const node = system.add_node (node_config);
93  	std::array<nano::keypair, 3> keys{};
94  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
95  	for (auto itr = 0; itr != keys.size (); ++itr)
96  	{
97  		system.wallet (0)->insert_adhoc (keys[itr].prv);
98  		auto const block = system.wallet (0)->send_action (nano::dev::genesis_key.pub, keys[itr].pub, 1000);
99  		ASSERT_TRUE (block);
100  		ASSERT_TIMELY (3s, 1 + (itr + 1) * 2 == node->ledger.cache.cemented_count);
101  	}
102  	std::vector<nano::uint128_t> amounts_to_send (10);
103  	std::iota (amounts_to_send.begin (), amounts_to_send.end (), 1);
104  	nano::account const * last_destination{};
105  	for (auto itr = 0; itr != amounts_to_send.size (); ++itr)
106  	{
107  		auto const source_index = itr % keys.size ();
108  		auto const destination_index = (source_index + 1) % keys.size ();
109  		last_destination = &keys[destination_index].pub;
110  		auto const send = system.wallet (0)->send_action (keys[source_index].pub, keys[destination_index].pub, amounts_to_send[itr]);
111  		ASSERT_TRUE (send);
112  		ASSERT_TIMELY (3s, 1 + keys.size () * 2 + (itr + 1) * 2 == node->ledger.cache.cemented_count);
113  	}
114  	ASSERT_TRUE (last_destination);
115  	auto last_destination_info = node->ledger.account_info (node->ledger.store.tx_begin_read (), *last_destination);
116  	ASSERT_TRUE (last_destination_info);
117  	std::vector<nano::uint128_t> amounts_expected_backwards{ 10, 9, 8, 5, 4, 3, 1000, 1, 1000, 2, 1000, 6, 7 };
118  	auto amounts_expected_backwards_itr = amounts_expected_backwards.cbegin ();
119  	nano::ledger_walker ledger_walker{ node->ledger };
120  	ledger_walker.walk_backward (last_destination_info->head,
121  	[&] (auto const & block) {
122  		if (block->sideband ().details.is_receive)
123  		{
124  			nano::amount previous_balance{};
125  			if (!block->previous ().is_zero ())
126  			{
127  				auto const previous_block = node->ledger.store.block.get_no_sideband (node->ledger.store.tx_begin_read (), block->previous ());
128  				previous_balance = previous_block->balance ();
129  			}
130  			EXPECT_EQ (*amounts_expected_backwards_itr++, block->balance ().number () - previous_balance.number ());
131  		}
132  	});
133  	EXPECT_EQ (amounts_expected_backwards_itr, amounts_expected_backwards.cend ());
134  	auto amounts_expected_itr = amounts_expected_backwards.crbegin ();
135  	ledger_walker.walk (last_destination_info->head,
136  	[&] (auto const & block) {
137  		if (block->sideband ().details.is_receive)
138  		{
139  			nano::amount previous_balance{};
140  			if (!block->previous ().is_zero ())
141  			{
142  				auto const previous_block = node->ledger.store.block.get_no_sideband (node->ledger.store.tx_begin_read (), block->previous ());
143  				previous_balance = previous_block->balance ();
144  			}
145  			EXPECT_EQ (*amounts_expected_itr++, block->balance ().number () - previous_balance.number ());
146  		}
147  	});
148  	EXPECT_EQ (amounts_expected_itr, amounts_expected_backwards.crend ());
149  }
150  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-substitute_test.cc</h3>
            <pre><code>1  #include "absl/strings/substitute.h"
2  #include <cstdint>
3  #include <vector>
4  #include "gtest/gtest.h"
5  #include "absl/strings/str_cat.h"
6  namespace {
7  struct MyStruct {
8    template <typename Sink>
9    friend void AbslStringify(Sink& sink, const MyStruct& s) {
10      sink.Append("MyStruct{.value = ");
11      sink.Append(absl::StrCat(s.value));
12      sink.Append("}");
13    }
14    int value;
15  };
16  TEST(SubstituteTest, Substitute) {
17    EXPECT_EQ("Hello, world!", absl::Substitute("$0, $1!", "Hello", "world"));
18    EXPECT_EQ("123 0.2 0.1 foo true false x",
19              absl::Substitute("$0 $1 $2 $3 $4 $5 $6", 123, 0.2, 0.1f,
20                               std::string("foo"), true, false, 'x'));
21    EXPECT_EQ(
22        "-32767 65535 "
23        "-1234567890 3234567890 "
24        "-1234567890 3234567890 "
25        "-1234567890123456789 9234567890123456789",
26        absl::Substitute(
27            "$0 $1 $2 $3 $4 $5 $6 $7",
28            static_cast<short>(-32767),          
29            static_cast<unsigned short>(65535),  
30            -1234567890, 3234567890U, -1234567890L, 3234567890UL,
31            -int64_t{1234567890123456789}, uint64_t{9234567890123456789u}));
32    EXPECT_EQ("0 1 f ffff0ffff 0123456789abcdef",
<span onclick='openModal()' class='match'>33              absl::Substitute("$0$1$2$3$4 $5",  
34                               absl::Hex(0), absl::Hex(1, absl::kSpacePad2),
35                               absl::Hex(0xf, absl::kSpacePad2),
36                               absl::Hex(int16_t{-1}, absl::kSpacePad5),
37                               absl::Hex(int16_t{-1}, absl::kZeroPad5),
</span>38                               absl::Hex(0x123456789abcdef, absl::kZeroPad16)));
39    EXPECT_EQ("0 115   -1-0001 81985529216486895",
40              absl::Substitute("$0$1$2$3$4 $5",  
41                               absl::Dec(0), absl::Dec(1, absl::kSpacePad2),
42                               absl::Dec(0xf, absl::kSpacePad2),
43                               absl::Dec(int16_t{-1}, absl::kSpacePad5),
44                               absl::Dec(int16_t{-1}, absl::kZeroPad5),
45                               absl::Dec(0x123456789abcdef, absl::kZeroPad16)));
46    const int* int_p = reinterpret_cast<const int*>(0x12345);
47    std::string str = absl::Substitute("$0", int_p);
48    EXPECT_EQ(absl::StrCat("0x", absl::Hex(int_p)), str);
49    volatile int vol = 237;
50    volatile int* volatile volptr = &vol;
51    str = absl::Substitute("$0", volptr);
52    EXPECT_EQ("true", str);
53    const uint64_t* null_p = nullptr;
54    str = absl::Substitute("$0", null_p);
55    EXPECT_EQ("NULL", str);
56    const char* char_p = "print me";
57    str = absl::Substitute("$0", char_p);
58    EXPECT_EQ("print me", str);
59    char char_buf[16];
60    strncpy(char_buf, "print me too", sizeof(char_buf));
61    str = absl::Substitute("$0", char_buf);
62    EXPECT_EQ("print me too", str);
63    char_p = nullptr;
64    str = absl::Substitute("$0", char_p);
65    EXPECT_EQ("", str);
66    EXPECT_EQ("b, a, c, b", absl::Substitute("$1, $0, $2, $1", "a", "b", "c"));
67    EXPECT_EQ("$", absl::Substitute("$$"));
68    EXPECT_EQ("$1", absl::Substitute("$$1"));
69    EXPECT_EQ("a", absl::Substitute("$0", "a"));
70    EXPECT_EQ("a b", absl::Substitute("$0 $1", "a", "b"));
71    EXPECT_EQ("a b c", absl::Substitute("$0 $1 $2", "a", "b", "c"));
72    EXPECT_EQ("a b c d", absl::Substitute("$0 $1 $2 $3", "a", "b", "c", "d"));
73    EXPECT_EQ("a b c d e",
74              absl::Substitute("$0 $1 $2 $3 $4", "a", "b", "c", "d", "e"));
75    EXPECT_EQ("a b c d e f", absl::Substitute("$0 $1 $2 $3 $4 $5", "a", "b", "c",
76                                              "d", "e", "f"));
77    EXPECT_EQ("a b c d e f g", absl::Substitute("$0 $1 $2 $3 $4 $5 $6", "a", "b",
78                                                "c", "d", "e", "f", "g"));
79    EXPECT_EQ("a b c d e f g h",
80              absl::Substitute("$0 $1 $2 $3 $4 $5 $6 $7", "a", "b", "c", "d", "e",
81                               "f", "g", "h"));
82    EXPECT_EQ("a b c d e f g h i",
83              absl::Substitute("$0 $1 $2 $3 $4 $5 $6 $7 $8", "a", "b", "c", "d",
84                               "e", "f", "g", "h", "i"));
85    EXPECT_EQ("a b c d e f g h i j",
86              absl::Substitute("$0 $1 $2 $3 $4 $5 $6 $7 $8 $9", "a", "b", "c",
87                               "d", "e", "f", "g", "h", "i", "j"));
88    EXPECT_EQ("a b c d e f g h i j b0",
89              absl::Substitute("$0 $1 $2 $3 $4 $5 $6 $7 $8 $9 $10", "a", "b", "c",
90                               "d", "e", "f", "g", "h", "i", "j"));
91    const char* null_cstring = nullptr;
92    EXPECT_EQ("Text: ''", absl::Substitute("Text: '$0'", null_cstring));
93    MyStruct s1 = MyStruct{17};
94    MyStruct s2 = MyStruct{1043};
95    EXPECT_EQ("MyStruct{.value = 17}, MyStruct{.value = 1043}",
96              absl::Substitute("$0, $1", s1, s2));
97  }
98  TEST(SubstituteTest, SubstituteAndAppend) {
99    std::string str = "Hello";
100    absl::SubstituteAndAppend(&str, ", $0!", "world");
101    EXPECT_EQ("Hello, world!", str);
102    str.clear();
103    absl::SubstituteAndAppend(&str, "$0", "a");
104    EXPECT_EQ("a", str);
105    str.clear();
106    absl::SubstituteAndAppend(&str, "$0 $1", "a", "b");
107    EXPECT_EQ("a b", str);
108    str.clear();
109    absl::SubstituteAndAppend(&str, "$0 $1 $2", "a", "b", "c");
110    EXPECT_EQ("a b c", str);
111    str.clear();
112    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3", "a", "b", "c", "d");
113    EXPECT_EQ("a b c d", str);
114    str.clear();
115    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3 $4", "a", "b", "c", "d", "e");
116    EXPECT_EQ("a b c d e", str);
117    str.clear();
118    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3 $4 $5", "a", "b", "c", "d", "e",
119                              "f");
120    EXPECT_EQ("a b c d e f", str);
121    str.clear();
122    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3 $4 $5 $6", "a", "b", "c", "d",
123                              "e", "f", "g");
124    EXPECT_EQ("a b c d e f g", str);
125    str.clear();
126    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3 $4 $5 $6 $7", "a", "b", "c", "d",
127                              "e", "f", "g", "h");
128    EXPECT_EQ("a b c d e f g h", str);
129    str.clear();
130    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3 $4 $5 $6 $7 $8", "a", "b", "c",
131                              "d", "e", "f", "g", "h", "i");
132    EXPECT_EQ("a b c d e f g h i", str);
133    str.clear();
134    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3 $4 $5 $6 $7 $8 $9", "a", "b",
135                              "c", "d", "e", "f", "g", "h", "i", "j");
136    EXPECT_EQ("a b c d e f g h i j", str);
137    str.clear();
138    MyStruct s1 = MyStruct{17};
139    MyStruct s2 = MyStruct{1043};
140    absl::SubstituteAndAppend(&str, "$0, $1", s1, s2);
141    EXPECT_EQ("MyStruct{.value = 17}, MyStruct{.value = 1043}", str);
142  }
143  TEST(SubstituteTest, VectorBoolRef) {
144    std::vector<bool> v = {true, false};
145    const auto& cv = v;
146    EXPECT_EQ("true false true false",
147              absl::Substitute("$0 $1 $2 $3", v[0], v[1], cv[0], cv[1]));
148    std::string str = "Logic be like: ";
149    absl::SubstituteAndAppend(&str, "$0 $1 $2 $3", v[0], v[1], cv[0], cv[1]);
150    EXPECT_EQ("Logic be like: true false true false", str);
151  }
152  TEST(SubstituteTest, Enums) {
153    enum UnscopedEnum { kEnum0 = 0, kEnum1 = 1 };
154    EXPECT_EQ("0 1", absl::Substitute("$0 $1", UnscopedEnum::kEnum0,
155                                      UnscopedEnum::kEnum1));
156    enum class ScopedEnum { kEnum0 = 0, kEnum1 = 1 };
157    EXPECT_EQ("0 1",
158              absl::Substitute("$0 $1", ScopedEnum::kEnum0, ScopedEnum::kEnum1));
159    enum class ScopedEnumInt32 : int32_t { kEnum0 = 989, kEnum1 = INT32_MIN };
160    EXPECT_EQ("989 -2147483648",
161              absl::Substitute("$0 $1", ScopedEnumInt32::kEnum0,
162                               ScopedEnumInt32::kEnum1));
163    enum class ScopedEnumUInt32 : uint32_t { kEnum0 = 1, kEnum1 = UINT32_MAX };
164    EXPECT_EQ("1 4294967295", absl::Substitute("$0 $1", ScopedEnumUInt32::kEnum0,
165                                               ScopedEnumUInt32::kEnum1));
166    enum class ScopedEnumInt64 : int64_t { kEnum0 = -1, kEnum1 = 42949672950 };
167    EXPECT_EQ("-1 42949672950", absl::Substitute("$0 $1", ScopedEnumInt64::kEnum0,
168                                                 ScopedEnumInt64::kEnum1));
169    enum class ScopedEnumUInt64 : uint64_t { kEnum0 = 1, kEnum1 = 42949672950 };
170    EXPECT_EQ("1 42949672950", absl::Substitute("$0 $1", ScopedEnumUInt64::kEnum0,
171                                                ScopedEnumUInt64::kEnum1));
172    enum class ScopedEnumChar : signed char { kEnum0 = -1, kEnum1 = 1 };
173    EXPECT_EQ("-1 1", absl::Substitute("$0 $1", ScopedEnumChar::kEnum0,
174                                       ScopedEnumChar::kEnum1));
175    enum class ScopedEnumUChar : unsigned char {
176      kEnum0 = 0,
177      kEnum1 = 1,
178      kEnumMax = 255
179    };
180    EXPECT_EQ("0 1 255", absl::Substitute("$0 $1 $2", ScopedEnumUChar::kEnum0,
181                                          ScopedEnumUChar::kEnum1,
182                                          ScopedEnumUChar::kEnumMax));
183    enum class ScopedEnumInt16 : int16_t { kEnum0 = -100, kEnum1 = 10000 };
184    EXPECT_EQ("-100 10000", absl::Substitute("$0 $1", ScopedEnumInt16::kEnum0,
185                                             ScopedEnumInt16::kEnum1));
186    enum class ScopedEnumUInt16 : uint16_t { kEnum0 = 0, kEnum1 = 10000 };
187    EXPECT_EQ("0 10000", absl::Substitute("$0 $1", ScopedEnumUInt16::kEnum0,
188                                          ScopedEnumUInt16::kEnum1));
189  }
190  enum class EnumWithStringify { Many = 0, Choices = 1 };
191  template <typename Sink>
192  void AbslStringify(Sink& sink, EnumWithStringify e) {
193    sink.Append(e == EnumWithStringify::Many ? "Many" : "Choices");
194  }
195  TEST(SubstituteTest, AbslStringifyWithEnum) {
196    const auto e = EnumWithStringify::Choices;
197    EXPECT_EQ(absl::Substitute("$0", e), "Choices");
198  }
199  #if GTEST_HAS_DEATH_TEST
200  TEST(SubstituteDeathTest, SubstituteDeath) {
201    EXPECT_DEBUG_DEATH(
202        static_cast<void>(absl::Substitute(absl::string_view("-$2"), "a", "b")),
203        "Invalid absl::Substitute\\(\\) format string: asked for \"\\$2\", "
204        "but only 2 args were given.");
205    EXPECT_DEBUG_DEATH(
206        static_cast<void>(absl::Substitute(absl::string_view("-$z-"))),
207        "Invalid absl::Substitute\\(\\) format string: \"-\\$z-\"");
208    EXPECT_DEBUG_DEATH(
209        static_cast<void>(absl::Substitute(absl::string_view("-$"))),
210        "Invalid absl::Substitute\\(\\) format string: \"-\\$\"");
211  }
212  #endif  
213  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ledger_walker.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-substitute_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>74  	auto const node = system.add_node (node_config);
75  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
76  	ASSERT_TRUE (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 1));
77  	ASSERT_TIMELY (3s, 3 == node->ledger.cache.cemented_count);
78  	nano::keypair key{};
79  	system.wallet (0)->insert_adhoc (key.prv);
</pre></code></div>
                <div class="column column_space"><pre><code>33              absl::Substitute("$0$1$2$3$4 $5",  
34                               absl::Hex(0), absl::Hex(1, absl::kSpacePad2),
35                               absl::Hex(0xf, absl::kSpacePad2),
36                               absl::Hex(int16_t{-1}, absl::kSpacePad5),
37                               absl::Hex(int16_t{-1}, absl::kZeroPad5),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    