
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.945273631840796%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</h3>
            <pre><code>1  class TSockSys{
2  public:
3    static bool Active;
4    static HWND SockWndHnd;
5    static HWND DnsWndHnd;
6    static HWND ReportWndHnd;
7    static HWND TimerWndHnd;
8    static UINT SockMsgHnd;
9    static UINT SockErrMsgHnd;
10    static UINT DnsMsgHnd;
11    static UINT ReportMsgHnd;
12    static uint64 SockBytesRead;
13    static uint64 SockBytesWritten;
14    static THash<TInt, TUInt64> SockIdToHndH;
15    static THash<TUInt64, TInt> SockHndToIdH;
16    static THash<TUInt64, TInt> SockHndToEventIdH;
17    static TIntH SockTimerIdH;
18    static TUInt64H ActiveSockHndH;
19    static THash<TUInt64, PSockHost> HndToSockHostH;
20    static THash<TInt, PSockEvent> IdToSockEventH;
21    static TIntH ActiveSockEventIdH;
22    static THash<TInt, PReportEvent> IdToReportEventH;
23    static THash<TInt, ATimer> IdToTimerH;
24  public:
25    static TStr GetErrStr(const int ErrCd);
26    static LRESULT CALLBACK MainWndProc(
27     HWND WndHnd, UINT Msg, WPARAM wParam, LPARAM lParam);
28  public:
29    TSockSys();
30    ~TSockSys();
31    TSockSys& operator=(const TSockSys&){Fail; return *this;}
32    static HWND GetSockWndHnd(){IAssert(Active); return SockWndHnd;}
33    static HWND GetDnsWndHnd(){IAssert(Active); return DnsWndHnd;}
34    static HWND GetReportWndHnd(){IAssert(Active); return ReportWndHnd;}
35    static HWND GetTimerWndHnd(){IAssert(Active); return TimerWndHnd;}
36    static UINT GetSockMsgHnd(){IAssert(Active); return SockMsgHnd;}
37    static UINT GetSockErrMsgHnd(){IAssert(Active); return SockErrMsgHnd;}
38    static UINT GetDnsMsgHnd(){IAssert(Active); return DnsMsgHnd;}
39    static UINT GetReportMsgHnd(){IAssert(Active); return ReportMsgHnd;}
40    static int GetAllSockEventCdSet(){
41      return (FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE);}
42    static uint64 GetSockBytesRead(){return SockBytesRead;}
43    static uint64 GetSockBytesWritten(){return SockBytesWritten;}
44    static void AddSock(
45     const int& SockId, const TSockHnd& SockHnd, const int& SockEventId);
46    static void DelSock(const int& SockId);
47    static bool IsSockId(const int& SockId){
48      IAssert(Active); return SockIdToHndH.IsKey(SockId);}
49    static bool IsSockHnd(const TSockHnd& SockHnd){
50      IAssert(Active); return SockHndToIdH.IsKey(SockHnd);}
51    static TSockHnd GetSockHnd(const int& SockId){
52      IAssert(Active); return TSockHnd(SockIdToHndH.GetDat(SockId));}
53    static TSockHnd GetSockId(const TSockHnd& SockHnd){
54      IAssert(Active); return SockHndToIdH.GetDat(SockHnd);}
55    static int GetSockEventId(const TSockHnd& SockHnd){
56      IAssert(Active); return SockHndToEventIdH.GetDat(SockHnd);}
57    static void AddSockTimer(const int& SockId, const int& MSecs){
58      UINT ErrCd=(UINT)SetTimer(GetSockWndHnd(), SockId, uint(MSecs), NULL);
59      ESAssert(ErrCd!=0);
60      SockTimerIdH.AddKey(SockId);}
61    static void DelIfSockTimer(const int& SockId){
62      KillTimer(GetSockWndHnd(), SockId);
63      SockTimerIdH.DelIfKey(SockId);}
64    static bool IsSockActive(const TSockHnd& SockHnd){
65      return ActiveSockHndH.IsKey(SockHnd);}
66    static void SetSockActive(const TSockHnd& SockHnd, const bool& Active){
67      IAssert(
68       (Active&&!IsSockActive(SockHnd))||
69       (!Active&&IsSockActive(SockHnd)));
70      if (Active){ActiveSockHndH.AddKey(SockHnd);}
71      else {ActiveSockHndH.DelKey(SockHnd);}}
72    static const int MxSockBfL;
73    static void AddSockHost(const TUInt64& SockHostHnd, const PSockHost& SockHost){
74      HndToSockHostH.AddDat(SockHostHnd, SockHost);}
75    static void DelSockHost(const TUInt64& SockHostHnd){
76      HndToSockHostH.DelKey(SockHostHnd);}
77    static bool IsSockHost(const TUInt64& SockHostHnd){
78      return HndToSockHostH.IsKey(SockHostHnd);}
79    static PSockHost GetSockHost(const TUInt64& SockHostHnd){
80      return HndToSockHostH.GetDat(SockHostHnd);}
81    static void AddSockEvent(const PSockEvent& SockEvent){
82      IAssert(!IsSockEvent(SockEvent));
83      IdToSockEventH.AddDat(SockEvent->GetSockEventId(), SockEvent);}
84    static void DelSockEvent(const PSockEvent& SockEvent){
85      IdToSockEventH.DelKey(SockEvent->GetSockEventId());}
86    static bool IsSockEvent(const int& SockEventId){
87      return IdToSockEventH.IsKey(TInt(SockEventId));}
88    static bool IsSockEvent(const PSockEvent& SockEvent){
89      return IdToSockEventH.IsKey(TInt(SockEvent->GetSockEventId()));}
90    static PSockEvent GetSockEvent(const int& SockEventId){
91      return IdToSockEventH.GetDat(SockEventId);}
92    static bool IsSockEventActive(const int& SockEventId){
93      return ActiveSockEventIdH.IsKey(SockEventId);}
94    static void SetSockEventActive(const int& SockEventId, const bool& Active){
95      IAssert(
96       (Active&&!IsSockEventActive(SockEventId))||
97       (!Active&&IsSockEventActive(SockEventId)));
98      if (Active){ActiveSockEventIdH.AddKey(SockEventId);}
99      else {ActiveSockEventIdH.DelKey(SockEventId);}}
100    static void AddReportEvent(const PReportEvent& ReportEvent){
101      IAssert(!IsReportEvent(ReportEvent));
102      IdToReportEventH.AddDat(TInt(ReportEvent->GetReportEventId()), ReportEvent);}
103    static void DelReportEvent(const PReportEvent& ReportEvent){
104      IdToReportEventH.DelKey(TInt(ReportEvent->GetReportEventId()));}
105    static bool IsReportEvent(const PReportEvent& ReportEvent){
106      return IdToReportEventH.IsKey(TInt(ReportEvent->GetReportEventId()));}
107    static PReportEvent GetReportEvent(const int& ReportEventId){
108      return IdToReportEventH.GetDat(ReportEventId);}
<span onclick='openModal()' class='match'>109    static void AddTimer(const ATimer& Timer){
110      IAssert(!IsTimer(Timer->GetTimerId()));
111      IdToTimerH.AddDat(TInt(Timer->GetTimerId()), Timer);}
112    static void DelTimer(const int& TimerId){
</span>113      IdToTimerH.DelKey(TimerId);}
114    static bool IsTimer(const int& TimerId){
115      return IdToTimerH.IsKey(TimerId);}
116    static ATimer GetTimer(const int& TimerId){
117      return IdToTimerH.GetDat(TimerId);}
118    static void OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
119    static void OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
120    static void OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
121    static void OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
122    static void OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
123    static void OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
124    static void OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent);
125    static void OnError(
126     const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd);
127    static void OnGetHost(const PSockHost& SockHost);
128    static TStr GetStatusStr();
129  };
130  bool TSockSys::Active=false;
131  HWND TSockSys::SockWndHnd=0;
132  HWND TSockSys::DnsWndHnd=0;
133  HWND TSockSys::ReportWndHnd=0;
134  HWND TSockSys::TimerWndHnd=0;
135  UINT TSockSys::SockMsgHnd=0;
136  UINT TSockSys::SockErrMsgHnd=0;
137  UINT TSockSys::DnsMsgHnd=0;
138  UINT TSockSys::ReportMsgHnd=0;
139  uint64 TSockSys::SockBytesRead=0;
140  uint64 TSockSys::SockBytesWritten=0;
141  THash<TInt, TUInt64> TSockSys::SockIdToHndH;
142  THash<TUInt64, TInt> TSockSys::SockHndToIdH;
143  THash<TUInt64, TInt> TSockSys::SockHndToEventIdH;
144  TIntH TSockSys::SockTimerIdH;
145  TUInt64H TSockSys::ActiveSockHndH;
146  const int TSockSys::MxSockBfL=100*1024;
147  THash<TUInt64, PSockHost> TSockSys::HndToSockHostH;
148  THash<TInt, PSockEvent> TSockSys::IdToSockEventH;
149  TIntH TSockSys::ActiveSockEventIdH;
150  THash<TInt, PReportEvent> TSockSys::IdToReportEventH;
151  THash<TInt, ATimer> TSockSys::IdToTimerH;
152  TSockSys SockSys; 
153  TStr TSockSys::GetErrStr(const int ErrCd){
154    switch (ErrCd){
155      case WSASYSNOTREADY: return "Underlying network subsystem is not ready for network communication.";
156      case WSAVERNOTSUPPORTED: return "The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.";
157      case WSAEPROCLIM: return "Limit on the number of tasks supported by the Windows Sockets implementation has been reached.";
158      case WSANOTINITIALISED: return "Windows Sockets not initialized.";
159      case WSAENETDOWN: return "The network subsystem has failed.";
160      case WSAEWOULDBLOCK: return "Resource temporarily unavailable (op. would block).";
161      case WSAEINPROGRESS: return "A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.";
162      case WSAEADDRINUSE: return "The specified address is already in use.";
163      case WSAEADDRNOTAVAIL: return "The specified address is not available from the local machine.";
164      case WSAEAFNOSUPPORT: return "Addresses in the specified family cannot be used with this socket.";
165      case WSAECONNREFUSED: return "The attempt to connect was forcefully rejected.";
166      case WSAENETUNREACH: return "The network cannot be reached from this host at this time.";
167      case WSAEFAULT: return "Bad parameter.";
168      case WSAEINVAL: return "The socket is already bound to an address.";
169      case WSAEISCONN: return "The socket is already connected.";
170      case WSAEMFILE: return "No more file descriptors are available.";
171      case WSAENOBUFS: return "No buffer space is available. The socket cannot be connected.";
172      case WSAENOTCONN: return "The socket is not connected.";
173      case WSAETIMEDOUT: return "Attempt to connect timed out without establishing a connection.";
174      case WSAECONNRESET: return "The connection was reset by the remote side.";
175      case WSAECONNABORTED: return "The connection was terminated due to a time-out or other failure.";
176      default: return TStr("Unknown socket error (code ")+TInt::GetStr(ErrCd)+TStr(").");
177    }
178  }
179  LRESULT CALLBACK TSockSys::MainWndProc(
180   HWND WndHnd, UINT MsgHnd, WPARAM wParam, LPARAM lParam){
181    if (MsgHnd==TSockSys::SockMsgHnd){
182      IAssert(WndHnd==GetSockWndHnd());
183      TSockHnd SockHnd=wParam;
184      if (IsSockHnd(SockHnd)){
185        int SockEventId=GetSockEventId(SockHnd);
186        PSockEvent SockEvent=GetSockEvent(SockEventId);
187        SetSockEventActive(SockEventId, true);
188        try {
189          int ErrCd=WSAGETSELECTERROR(lParam);
190          if (ErrCd==0){
191            int EventCd=WSAGETSELECTEVENT(lParam);
192            switch (EventCd){
193              case FD_READ: OnRead(SockHnd, SockEvent); break;
194              case FD_WRITE: OnWrite(SockHnd, SockEvent); break;
195              case FD_OOB: OnOob(SockHnd, SockEvent); break;
196              case FD_ACCEPT: OnAccept(SockHnd, SockEvent); break;
197              case FD_CONNECT: OnConnect(SockHnd, SockEvent); break;
198              case FD_CLOSE: OnClose(SockHnd, SockEvent); break;
199              default: Fail;
200            }
201          } else {
202            OnError(SockHnd, SockEvent, ErrCd);
203          }
204        } catch (...){
205          SaveToErrLog("Exception from 'switch (EventCd)'");
206        }
207        SetSockEventActive(SockEventId, false);
208      }
209    } else
210    if (MsgHnd==TSockSys::SockErrMsgHnd){
211      IAssert(WndHnd==GetSockWndHnd());
212      TSockHnd SockHnd=wParam;
213      if (IsSockHnd(SockHnd)){
214        int SockEventId=GetSockEventId(SockHnd);
215        PSockEvent SockEvent=GetSockEvent(SockEventId);
216        SetSockEventActive(SockEventId, true);
217        try {
218          int ErrCd=int(lParam);
219          OnError(SockHnd, SockEvent, ErrCd);
220        } catch (...){
221          SaveToErrLog("Exception from 'OnError(SockHnd, SockEvent, ErrCd)'");
222        }
223        SetSockEventActive(SockEventId, false);
224      }
225    } else
226    if (MsgHnd==WM_TIMER){
227      if (WndHnd==GetSockWndHnd()){
228        int SockId=int(wParam);
229        DelIfSockTimer(SockId);
230        if (IsSockId(SockId)){
231          TSockHnd SockHnd=GetSockHnd(SockId);
232          int SockEventId=GetSockEventId(SockHnd);
233          PSockEvent SockEvent=GetSockEvent(SockEventId);
234          SetSockEventActive(SockEventId, true);
235          try {
236            OnTimeOut(SockHnd, SockEvent);
237          } catch (...){
238            SaveToErrLog("Exception from OnTimeOut(SockHnd, SockEvent);");
239          }
240          SetSockEventActive(SockEventId, false);
241        }
242      } else
243      if (WndHnd==GetTimerWndHnd()){
244        int TimerId=int(wParam);
245        if (TSockSys::IsTimer(TimerId)){
246          PTimer Timer=TSockSys::GetTimer(TimerId)();
247          Timer->IncTicks();
248          try {
249            Timer->OnTimeOut();
250          } catch (...){
251            SaveToErrLog("Exception from Timer->OnTimeOut();");
252          }
253        }
254      } else {
255        Fail;
256      }
257    } else
258    if (MsgHnd==TSockSys::DnsMsgHnd){
259      IAssert(WndHnd==GetDnsWndHnd());
260      uint SockHostHnd=int(wParam);
261      if (TSockSys::IsSockHost(SockHostHnd)){
262        TSockHostStatus Status=TSockHost::GetStatus(WSAGETASYNCERROR(lParam));
263        PSockHost SockHost=TSockSys::GetSockHost(SockHostHnd);
264        SockHost->GetFromHostEnt(Status, (hostent*)SockHost->HostEntBf);
265        DelSockHost(SockHostHnd);
266        try {
267          OnGetHost(SockHost);
268        } catch (...){
269          SaveToErrLog("Exception from OnGetHost(SockHost);");
270        }
271      }
272    } else
273    if (MsgHnd==TSockSys::ReportMsgHnd){
274      IAssert(WndHnd==GetReportWndHnd());
275      int ReportEventId=int(lParam);
276      PReportEvent ReportEvent=TSockSys::GetReportEvent(ReportEventId);
277      try {
278        ReportEvent->OnReport();
279      } catch (...){
280        SaveToErrLog("Exception from ReportEvent->OnReport()");
281      }
282      TSockSys::DelReportEvent(ReportEvent);
283    } else {
284      return DefWindowProc(WndHnd, MsgHnd, wParam, lParam);
285    }
286    return 0;
287  }
288  TSockSys::TSockSys(){
289    IAssert(Active==false);
290    WNDCLASS WndClass;
291    WndClass.style=0;
292    WndClass.lpfnWndProc=MainWndProc;
293    WndClass.cbClsExtra=0;
294    WndClass.cbWndExtra=0;
295    FSAssert((WndClass.hInstance=GetModuleHandle(NULL))!=NULL);
296    WndClass.hIcon=NULL;
297    WndClass.hCursor=NULL;
298    WndClass.hbrBackground=NULL;
299    WndClass.lpszMenuName=NULL;
300    WndClass.lpszClassName="SockWndClass";
301    FSAssert(RegisterClass(&WndClass)!=0);
302    TSockSys::SockWndHnd=CreateWindow(
303     "SockWndClass", "Socket Window",
304     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
305     GetModuleHandle(NULL), NULL);
306    FSAssert(TSockSys::SockWndHnd!=NULL);
307    TSockSys::DnsWndHnd=CreateWindow(
308     "SockWndClass", "Dns Window",
309     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
310     GetModuleHandle(NULL), NULL);
311    FSAssert(TSockSys::DnsWndHnd!=NULL);
312    TSockSys::ReportWndHnd=CreateWindow(
313     "SockWndClass", "RepMsg Window",
314     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
315     GetModuleHandle(NULL), NULL);
316    FSAssert(TSockSys::ReportWndHnd!=NULL);
317    TSockSys::TimerWndHnd=CreateWindow(
318     "SockWndClass", "Net Timer",
319     WS_OVERLAPPEDWINDOW, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
320     GetModuleHandle(NULL), NULL);
321    FSAssert(TSockSys::TimerWndHnd!=NULL);
322    SockMsgHnd=RegisterWindowMessage("SockSys.SockMsg"); FSAssert(SockMsgHnd!=0);
323    SockErrMsgHnd=RegisterWindowMessage("SockSys.SockErrorMsg"); FSAssert(SockErrMsgHnd!=0);
324    DnsMsgHnd=RegisterWindowMessage("SockSys.DnsMsg"); FSAssert(DnsMsgHnd!=0);
325    ReportMsgHnd=RegisterWindowMessage("SockSys.RepMsg"); FSAssert(ReportMsgHnd!=0);
326    WORD Version=((WORD) (((BYTE) (2)) | (((WORD) ((BYTE) (0))) << 8)));
327    WSADATA WsaData;
328    int WsaErrCd=WSAStartup(Version, &WsaData);
329    FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
330    FAssert(
331     WsaData.wVersion==Version,
332     "Can not find appropriate version of WinSock DLL.");
333    Active=true;
334  }
335  TSockSys::~TSockSys(){
336    if (Active){
337      IAssert(ActiveSockHndH.Len()==0);
338      IAssert(ActiveSockEventIdH.Len()==0);
339      int WsaErrCd=WSACleanup();
340      FAssert(WsaErrCd==0, TSockSys::GetErrStr(WsaErrCd));
341      Active=false;
342    }
343  }
344  void TSockSys::AddSock(
345   const int& SockId, const TSockHnd& SockHnd, const int& SockEventId){
346    IAssert(Active);
347    SockIdToHndH.AddDat(SockId, SockHnd);
348    SockHndToIdH.AddDat(SockHnd, SockId);
349    SockHndToEventIdH.AddDat(SockHnd, SockEventId);
350  }
351  void TSockSys::DelSock(const int& SockId){
352    IAssert(Active);
353    TSockHnd SockHnd=TSockHnd(SockIdToHndH.GetDat(SockId));
354    IAssert(!IsSockActive(SockHnd));
355    SockIdToHndH.DelKey(SockId);
356    SockHndToIdH.DelKey(SockHnd);
357    SockHndToEventIdH.DelKey(SockHnd);
358    DelIfSockTimer(SockId);
359  }
360  void TSockSys::OnRead(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
361    TMem Mem(MxSockBfL);
362    char* Bf=new char[MxSockBfL]; int BfL;
363    do {
364      BfL=recv(SockHnd, Bf, MxSockBfL, 0);
365      if (BfL!=SOCKET_ERROR){
366        Mem.AddBf(Bf, BfL); SockBytesRead+=BfL;}
367    } while ((BfL>0)&&(BfL!=SOCKET_ERROR));
368    delete[] Bf;
369    if (!SockEvent.Empty()){
370      PSIn SIn=Mem.GetSIn();
371      SockEvent->OnRead(int(GetSockId(SockHnd)), SIn);
372    }
373  }
374  void TSockSys::OnWrite(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
375    if (!SockEvent.Empty()){
376      SockEvent->OnWrite(int(GetSockId(SockHnd)));}
377  }
378  void TSockSys::OnOob(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
379    if (!SockEvent.Empty()){
380      SockEvent->OnOob(int(GetSockId(SockHnd)));}
381  }
382  void TSockSys::OnAccept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
383    PSock AccSock=TSock::Accept(SockHnd, SockEvent);
384    if (!SockEvent.Empty()){
385      SockEvent->OnAccept(AccSock->GetSockId(), AccSock);}
386  }
387  void TSockSys::OnConnect(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
388    if (!SockEvent.Empty()){
389      SockEvent->OnConnect(int(GetSockId(SockHnd)));}
390  }
391  void TSockSys::OnClose(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
392    if (!SockEvent.Empty()){
393      SockEvent->OnClose(int(GetSockId(SockHnd)));}
394  }
395  void TSockSys::OnTimeOut(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
396    if (!SockEvent.Empty()){
397      SockEvent->OnTimeOut(int(GetSockId(SockHnd)));}
398  }
399  void TSockSys::OnError(
400   const TSockHnd& SockHnd, const PSockEvent& SockEvent, const int& ErrCd){
401    if (!SockEvent.Empty()){
402      SockEvent->OnError(int(GetSockId(SockHnd)), ErrCd, GetErrStr(ErrCd));}
403  }
404  void TSockSys::OnGetHost(const PSockHost& SockHost){
405    if (IsSockEvent(SockHost->GetSockEventId())){
406      PSockEvent SockEvent=SockHost->GetSockEvent();
407      if (!SockEvent.Empty()){
408        SockEvent->OnGetHost(SockHost);}
409    }
410  }
411  TStr TSockSys::GetStatusStr(){
412    TChA ChA;
413    ChA+="Sockets: "; ChA+=TInt::GetStr(SockIdToHndH.Len()); ChA+="\r\n";
414    ChA+="Host-Resolutions: "; ChA+=TInt::GetStr(HndToSockHostH.Len()); ChA+="\r\n";
415    ChA+="Socket-Events: "; ChA+=TInt::GetStr(IdToSockEventH.Len()); ChA+="\r\n";
416    ChA+="Report-Events: "; ChA+=TInt::GetStr(IdToReportEventH.Len()); ChA+="\r\n";
417    ChA+="Timers: "; ChA+=TInt::GetStr(IdToTimerH.Len()); ChA+="\r\n";
418    return ChA;
419  }
420  int TSockEvent::LastSockEventId=0;
421  TSockEvent::~TSockEvent(){
422    IAssert(!TSockSys::IsSockEventActive(SockEventId));
423  }
424  bool TSockEvent::IsReg(const PSockEvent& SockEvent){
425    return TSockSys::IsSockEvent(SockEvent);
426  }
427  void TSockEvent::Reg(const PSockEvent& SockEvent){
428    IAssert(!TSockSys::IsSockEvent(SockEvent));
429    TSockSys::AddSockEvent(SockEvent);
430  }
431  void TSockEvent::UnReg(const PSockEvent& SockEvent){
432    IAssert(TSockSys::IsSockEvent(SockEvent));
433    TSockSys::DelSockEvent(SockEvent);
434  }
435  void TSockHost::GetFromHostEnt(
436   const TSockHostStatus& _Status, const hostent* HostEnt){
437    if ((Status=_Status)==shsOk){
438      IAssert(HostEnt!=NULL);
439      IAssert(HostEnt->h_addrtype==AF_INET);
440      IAssert(HostEnt->h_length==4);
441      HostNmV.Add(TStr(HostEnt->h_name).GetLc());
442      int HostNmN=0;
443      while (HostEnt->h_aliases[HostNmN]!=NULL){
444        HostNmV.Add(TStr(HostEnt->h_aliases[HostNmN]).GetLc()); HostNmN++;}
445      int IpNumN=0;
446      while (HostEnt->h_addr_list[IpNumN]!=NULL){
447        TStr IpNum=
448         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][0]))+"."+
449         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][1]))+"."+
450         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][2]))+"."+
451         TInt::GetStr(uchar(HostEnt->h_addr_list[IpNumN][3]));
452        IpNumV.Add(IpNum); IpNumN++;
453      }
454    }
455  }
456  PSockEvent TSockHost::GetSockEvent() const {
457    return TSockSys::GetSockEvent(SockEventId);
458  }
459  bool TSockHost::IsIpNum(const TStr& HostNm){
460    int HostNmLen=HostNm.Len();
461    for (int ChN=0; ChN<HostNmLen; ChN++){
462      if (TCh::IsAlpha(HostNm[ChN])){return false;}}
463    return true;
464  }
465  TStr TSockHost::GetIpNum(const uint& IpNum){
466    TChA IpNumChA;
467    IpNumChA+=TUInt::GetStr(IpNum/0x1000000);
468    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x10000)%0x100);
469    IpNumChA+='.'; IpNumChA+=TUInt::GetStr((IpNum/0x100)%0x100);
470    IpNumChA+='.'; IpNumChA+=TUInt::GetStr(IpNum%0x100);
471    return IpNumChA;
472  }
473  PSockHost TSockHost::GetSyncSockHost(const TStr& HostNm){
474    hostent* HostEnt; TSockHostStatus Status(shsUndef);
475    if ((HostNm.Len()>0)&&(!IsIpNum(HostNm))){
476      HostEnt=gethostbyname(HostNm.CStr());
477      if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
478      else {Status=shsOk;}
479    } else {
480      uint HostIpNum=inet_addr(HostNm.CStr());
481      if (HostIpNum==INADDR_NONE){
482        Status=shsError; HostEnt=NULL;
483      } else {
484        HostEnt=gethostbyaddr((char*)&HostIpNum, 4, AF_INET);
485        if (HostEnt==NULL){Status=GetStatus(WSAGetLastError());}
486        else {Status=shsOk;}
487      }
488    }
489    PSockHost SockHost=PSockHost(new TSockHost());
490    SockHost->GetFromHostEnt(Status, HostEnt);
491    return SockHost;
492  }
493  void TSockHost::GetAsyncSockHost(
494   const TStr& HostNm, const PSockEvent& SockEvent){
495    PSockHost SockHost=PSockHost(new TSockHost(SockEvent));
496    HANDLE SockHostHnd=0;
497    if ((HostNm.Len()>0)){
498      SockHostHnd=WSAAsyncGetHostByName(TSockSys::GetDnsWndHnd(),
499       TSockSys::GetDnsMsgHnd(), HostNm.CStr(),
500       SockHost->HostEntBf, MAXGETHOSTSTRUCT);
501    } else {
502      uint HostIpNum=inet_addr(HostNm.CStr());
503      if (HostIpNum==INADDR_NONE){
504        SockHostHnd=0;
505      } else {
506        SockHostHnd=WSAAsyncGetHostByAddr(TSockSys::GetDnsWndHnd(),
507         TSockSys::GetDnsMsgHnd(), (char*)&HostIpNum, 4, AF_INET,
508         SockHost->HostEntBf, MAXGETHOSTSTRUCT);
509      }
510    }
511    EAssertR(SockHostHnd!=0, TSockSys::GetErrStr(WSAGetLastError()));
512    if (SockHostHnd!=0){
513      TSockSys::AddSockHost(TUInt64(SockHostHnd), SockHost);
514    }
515  }
516  TSockHostStatus TSockHost::GetStatus(const int& ErrCd){
517    switch (ErrCd){
518      case 0: return shsOk;
519      case WSAHOST_NOT_FOUND: return shsHostNotFound;
520      case WSATRY_AGAIN: return shsTryAgain;
521      default: return shsError;
522    }
523  }
524  PSockHost TSockHost::GetLocalSockHost(){
525    PSockHost SockHost=TSockHost::GetSyncSockHost(LocalHostNm);
526    if (SockHost->IsOk()){
527      SockHost=TSockHost::GetSyncSockHost(SockHost->GetHostNm());}
528    return SockHost;
529  }
530  const TStr TSockHost::LocalHostNm("localhost");
531  int TSock::LastSockId=0;
532  TSock::TSock(const PSockEvent& SockEvent):
533    SockId(++LastSockId), SockHnd(0),
534    SockEventId(SockEvent->GetSockEventId()){
535    SockHnd=socket(AF_INET, SOCK_STREAM, 0);
536    EAssertR(SockHnd!=INVALID_SOCKET, TSockSys::GetErrStr(WSAGetLastError()));
537    TSockSys::AddSock(SockId, SockHnd, SockEventId);
538    IAssert(TSockEvent::IsReg(SockEvent));
539  }
540  TSock::TSock(const TSockHnd& _SockHnd, const PSockEvent& SockEvent):
541    SockId(++LastSockId), SockHnd(_SockHnd),
542    SockEventId(SockEvent->GetSockEventId()){
543    TSockSys::AddSock(SockId, SockHnd, SockEventId);
544    IAssert(TSockEvent::IsReg(SockEvent));
545  }
546  TSock::~TSock(){
547    IAssert(!TSockSys::IsSockActive(SockHnd));
548    TSockSys::DelSock(SockId);
549    closesocket(SockHnd);
550  }
551  PSockEvent TSock::GetSockEvent() const {
552    return TSockSys::GetSockEvent(SockEventId);
553  }
554  void TSock::Listen(const int& PortN){
555    sockaddr_in SockAddr;
556    memset(&SockAddr, 0, sizeof(SockAddr));
557    SockAddr.sin_family=AF_INET;
558    SockAddr.sin_addr.s_addr=INADDR_ANY;
559    SockAddr.sin_port=htons(u_short(PortN));
560    EAssertR(
561     bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr))==0,
562     TSockSys::GetErrStr(WSAGetLastError()));
563    EAssertR(
564     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
565      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
566     TSockSys::GetErrStr(WSAGetLastError()));
567    EAssertR(
568     listen(SockHnd, SOMAXCONN)==0,
569     TSockSys::GetErrStr(WSAGetLastError()));
570  }
571  int TSock::GetPortAndListen(const int& MnPortN){
572    int PortN=MnPortN-1;
573    int ErrCd=0;
574    forever {
575      PortN++;
576      sockaddr_in SockAddr;
577      memset(&SockAddr, 0, sizeof(SockAddr));
578      SockAddr.sin_family=AF_INET;
579      SockAddr.sin_addr.s_addr=INADDR_ANY;
580      SockAddr.sin_port=htons(u_short(PortN));
581      int OkCd=bind(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
582      if (OkCd==SOCKET_ERROR){
583        ErrCd=WSAGetLastError();
584        if (ErrCd!=WSAEADDRINUSE){break;}
585      } else {
586        ErrCd=0; break;
587      }
588    }
589    EAssertR(ErrCd==0, TSockSys::GetErrStr(ErrCd));
590    EAssertR(
591     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
592     TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
593     TSockSys::GetErrStr(WSAGetLastError()));
594    EAssertR(
595     listen(SockHnd, SOMAXCONN)==0,
596     TSockSys::GetErrStr(WSAGetLastError()));
597    return PortN;
598  }
599  void TSock::Connect(const PSockHost& SockHost, const int& PortN){
600    IAssert(SockHost->IsOk());
601    uint HostIpNum=inet_addr(SockHost->GetIpNum().CStr());
602    IAssert(HostIpNum!=INADDR_NONE);
603    sockaddr_in SockAddr;
604    memset(&SockAddr, 0, sizeof(SockAddr));
605    memcpy(&(SockAddr.sin_addr), &HostIpNum, sizeof(HostIpNum));
606    SockAddr.sin_family=AF_INET;
607    SockAddr.sin_port=htons(u_short(PortN));
608    EAssertR(
609     WSAAsyncSelect(SockHnd, TSockSys::GetSockWndHnd(),
610      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
611     TSockSys::GetErrStr(WSAGetLastError()));
612    int ErrCd=connect(SockHnd, (sockaddr*)&SockAddr, sizeof(SockAddr));
613    EAssertR(
614     (ErrCd==SOCKET_ERROR)&&(WSAGetLastError()==WSAEWOULDBLOCK),
615     "Unsuccessful socket-connect.");
616  }
617  void TSock::Send(const PSIn& SIn, bool& Ok, int& ErrCd){
618    if (!SIn.Empty()){UnsentBf+=SIn;}
619    Ok=true; ErrCd=0;
620    int SentChs=0;
621    while (SentChs<UnsentBf.Len()){
622      int SendBfL=UnsentBf.Len()-SentChs;
623      if (SendBfL>TSockSys::MxSockBfL){SendBfL=TSockSys::MxSockBfL;}
624      int LSentChs=send(SockHnd, &UnsentBf[SentChs], SendBfL, 0);
625      if (LSentChs==SOCKET_ERROR){
626        ErrCd=WSAGetLastError();
627        Ok=(ErrCd==WSAEWOULDBLOCK);
628        break;
629      } else {
630        SentChs+=LSentChs;
631        TSockSys::SockBytesWritten+=LSentChs;
632      }
633    }
634    UnsentBf.Del(0, SentChs-1);
635  }
636  void TSock::Send(const PSIn& SIn){
637    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
638    if (!Ok){
639     ESAssert(PostMessage(
640      TSockSys::GetSockWndHnd(), TSockSys::SockErrMsgHnd, SockHnd, ErrCd));
641    }
642  }
643  void TSock::SendSafe(const PSIn& SIn){
644    bool Ok; int ErrCd; Send(SIn, Ok, ErrCd);
645  }
646  TStr TSock::GetPeerIpNum() const {
647    sockaddr_in SockAddr;
648    memset(&SockAddr, 0, sizeof(SockAddr));
649    int NmLen=sizeof(sockaddr_in);
650    EAssertR(
651     getpeername(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
652     TSockSys::GetErrStr(WSAGetLastError()));
653    TStr IpNum=
654     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
655     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
656     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
657     TInt::GetStr(SockAddr.sin_addr.s_impno);
658    return IpNum;
659  }
660  TStr TSock::GetLocalIpNum() const {
661    sockaddr_in SockAddr;
662    memset(&SockAddr, 0, sizeof(SockAddr));
663    int NmLen=sizeof(sockaddr_in);
664    EAssertR(
665     getsockname(SockHnd, (sockaddr*)&SockAddr, &NmLen)==0,
666     TSockSys::GetErrStr(WSAGetLastError()));
667    TStr IpNum=
668     TInt::GetStr(SockAddr.sin_addr.s_net)+"."+
669     TInt::GetStr(SockAddr.sin_addr.s_host)+"."+
670     TInt::GetStr(SockAddr.sin_addr.s_lh)+"."+
671     TInt::GetStr(SockAddr.sin_addr.s_impno);
672    return IpNum;
673  }
674  void TSock::PutTimeOut(const int& MSecs){
675    TSockSys::AddSockTimer(SockId, MSecs);
676  }
677  void TSock::DelTimeOut(){
678    TSockSys::DelIfSockTimer(SockId);
679  }
680  PSock TSock::Accept(const TSockHnd& SockHnd, const PSockEvent& SockEvent){
681    sockaddr_in SockAddr;
682    int SockAddrLen=sizeof(SockAddr);
683    memset(&SockAddr, 0, sizeof(SockAddr));
684    TSockHnd AccSockHnd=accept(SockHnd, (sockaddr*)&SockAddr, &SockAddrLen);
685    EAssertR(
686     AccSockHnd!=INVALID_SOCKET,
687     TSockSys::GetErrStr(WSAGetLastError()));
688    PSock AccSock=PSock(new TSock(AccSockHnd, SockEvent));
689    EAssertR(
690     WSAAsyncSelect(AccSock->GetSockHnd(), TSockSys::GetSockWndHnd(),
691      TSockSys::GetSockMsgHnd(), TSockSys::GetAllSockEventCdSet())==0,
692     TSockSys::GetErrStr(WSAGetLastError()));
693    return AccSock;
694  }
695  TStr TSock::GetSockSysStatusStr(){
696    return TSockSys::GetStatusStr();
697  }
698  uint64 TSock::GetSockSysBytesRead(){
699    return TSockSys::SockBytesRead;
700  }
701  uint64 TSock::GetSockSysBytesWritten(){
702    return TSockSys::SockBytesWritten;
703  }
704  bool TSock::IsSockId(const int& SockId){
705    return TSockSys::IsSockId(SockId);
706  }
707  int TReportEvent::LastReportEventId=0;
708  void TReportEvent::SendReport(){
709    TSockSys::AddReportEvent(this);
710    ESAssert(PostMessage(
711     TSockSys::GetReportWndHnd(), TSockSys::GetReportMsgHnd(), 0, ReportEventId));
712  }
713  int TTTimer::LastTimerId=0;
714  TTTimer::TTTimer(const int& _TimeOut):
715    TimerId(++LastTimerId), TimerHnd(0), TimeOut(_TimeOut),
716    Ticks(0), StartTm(TSecTm::GetCurTm()){
717    IAssert(TimeOut>=0);
718    StartTimer(TimeOut);
719  }
720  TTTimer::~TTTimer(){
721    StopTimer();
722  }
723  void TTTimer::StartTimer(const int& _TimeOut){
724    IAssert((_TimeOut==-1)||(_TimeOut>=0));
725    if (_TimeOut!=-1){
726      TimeOut=_TimeOut;}
727    StopTimer();
728    if (TimeOut>0){
729      TimerHnd=uint(SetTimer(
730       TSockSys::GetTimerWndHnd(), UINT(TimerId), UINT(TimeOut), NULL));
731      ESAssert(TimerHnd!=0);
732      TSockSys::AddTimer(this);
733    }
734  }
735  void TTTimer::StopTimer(){
736    if (TimerHnd!=0){
737      ESAssert(KillTimer(TSockSys::GetTimerWndHnd(), TimerId));
738      TSockSys::DelTimer(TimerId);
739      TimerHnd=0;
740    }
741  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ledger.cpp</h3>
            <pre><code>1  #include <nano/lib/stats.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/node/election.hpp>
4  #include <nano/node/rocksdb/rocksdb.hpp>
5  #include <nano/node/scheduler/buckets.hpp>
6  #include <nano/node/scheduler/component.hpp>
7  #include <nano/node/transport/inproc.hpp>
8  #include <nano/test_common/ledger.hpp>
9  #include <nano/test_common/system.hpp>
10  #include <nano/test_common/testutil.hpp>
11  #include <gtest/gtest.h>
12  using namespace std::chrono_literals;
13  TEST (ledger, store_error)
14  {
15  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
16  	{
17  		GTEST_SKIP ();
18  	}
19  	auto ctx = nano::test::context::ledger_empty ();
20  }
21  TEST (ledger, empty)
22  {
23  	auto ctx = nano::test::context::ledger_empty ();
24  	auto & ledger = ctx.ledger ();
25  	auto & store = ctx.store ();
26  	auto transaction = store.tx_begin_read ();
27  	nano::account account;
28  	auto balance (ledger.account_balance (transaction, account));
29  	ASSERT_TRUE (balance.is_zero ());
30  }
31  TEST (ledger, genesis_balance)
32  {
33  	auto ctx = nano::test::context::ledger_empty ();
34  	auto & ledger = ctx.ledger ();
35  	auto & store = ctx.store ();
36  	auto transaction = store.tx_begin_write ();
37  	auto balance = ledger.account_balance (transaction, nano::dev::genesis->account ());
38  	ASSERT_EQ (nano::dev::constants.genesis_amount, balance);
39  	auto amount = ledger.amount (transaction, nano::dev::genesis->account ());
40  	ASSERT_EQ (nano::dev::constants.genesis_amount, amount);
41  	auto info = ledger.account_info (transaction, nano::dev::genesis->account ());
42  	ASSERT_TRUE (info);
43  	ASSERT_EQ (1, ledger.cache.account_count);
44  	ASSERT_GE (nano::seconds_since_epoch (), info->modified);
45  	ASSERT_LT (nano::seconds_since_epoch () - info->modified, 10);
46  	nano::confirmation_height_info confirmation_height_info;
47  	ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis->account (), confirmation_height_info));
48  	ASSERT_EQ (confirmation_height_info.height, 1);
49  	ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis->hash ());
50  }
51  TEST (ledger, process_modifies_sideband)
52  {
53  	auto ctx = nano::test::context::ledger_empty ();
54  	auto & ledger = ctx.ledger ();
55  	auto & store = ctx.store ();
56  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
57  	nano::block_builder builder;
58  	auto send1 = builder
59  				 .state ()
60  				 .account (nano::dev::genesis->account ())
61  				 .previous (nano::dev::genesis->hash ())
62  				 .representative (nano::dev::genesis->account ())
63  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
64  				 .link (nano::dev::genesis->account ())
65  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
66  				 .work (*pool.generate (nano::dev::genesis->hash ()))
67  				 .build ();
68  	ASSERT_EQ (nano::process_result::progress, ledger.process (store.tx_begin_write (), *send1).code);
69  	ASSERT_EQ (send1->sideband ().timestamp, store.block.get (store.tx_begin_read (), send1->hash ())->sideband ().timestamp);
70  }
71  TEST (ledger, process_send)
72  {
73  	auto ctx = nano::test::context::ledger_empty ();
74  	auto & ledger = ctx.ledger ();
75  	auto & store = ctx.store ();
76  	auto transaction = store.tx_begin_write ();
77  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
78  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
79  	ASSERT_TRUE (info1);
80  	nano::keypair key2;
81  	nano::block_builder builder;
82  	auto send = builder
83  				.send ()
84  				.previous (info1->head)
85  				.destination (key2.pub)
86  				.balance (50)
87  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
88  				.work (*pool.generate (info1->head))
89  				.build ();
90  	nano::block_hash hash1 = send->hash ();
91  	ASSERT_EQ (nano::dev::genesis_key.pub, store.frontier.get (transaction, info1->head));
92  	ASSERT_EQ (1, info1->block_count);
93  	auto return1 = ledger.process (transaction, *send);
94  	ASSERT_EQ (nano::dev::genesis_key.pub, send->sideband ().account);
95  	ASSERT_EQ (2, send->sideband ().height);
96  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.amount (transaction, hash1));
97  	ASSERT_TRUE (store.frontier.get (transaction, info1->head).is_zero ());
98  	ASSERT_EQ (nano::dev::genesis_key.pub, store.frontier.get (transaction, hash1));
99  	ASSERT_EQ (nano::process_result::progress, return1.code);
100  	ASSERT_EQ (nano::dev::genesis_key.pub, store.block.account_calculated (*send));
101  	ASSERT_EQ (50, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
102  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.account_receivable (transaction, key2.pub));
103  	auto info2 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
104  	ASSERT_TRUE (info2);
105  	ASSERT_EQ (2, info2->block_count);
106  	auto latest6 = store.block.get (transaction, info2->head);
107  	ASSERT_NE (nullptr, latest6);
108  	auto latest7 = dynamic_cast<nano::send_block *> (latest6.get ());
109  	ASSERT_NE (nullptr, latest7);
110  	ASSERT_EQ (*send, *latest7);
111  	auto open = builder
112  				.open ()
113  				.source (hash1)
114  				.representative (key2.pub)
115  				.account (key2.pub)
116  				.sign (key2.prv, key2.pub)
117  				.work (*pool.generate (key2.pub))
118  				.build ();
119  	nano::block_hash hash2 (open->hash ());
120  	auto return2 = ledger.process (transaction, *open);
121  	ASSERT_EQ (nano::process_result::progress, return2.code);
122  	ASSERT_EQ (key2.pub, open->sideband ().account);
123  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, open->sideband ().balance.number ());
124  	ASSERT_EQ (1, open->sideband ().height);
125  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.amount (transaction, hash2));
126  	ASSERT_EQ (nano::process_result::progress, return2.code);
127  	ASSERT_EQ (key2.pub, store.block.account_calculated (*open));
128  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.amount (transaction, hash2));
129  	ASSERT_EQ (key2.pub, store.frontier.get (transaction, hash2));
130  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.account_balance (transaction, key2.pub));
131  	ASSERT_EQ (0, ledger.account_receivable (transaction, key2.pub));
132  	ASSERT_EQ (50, ledger.weight (nano::dev::genesis_key.pub));
133  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.weight (key2.pub));
134  	auto info3 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
135  	ASSERT_TRUE (info3);
136  	auto latest2 = store.block.get (transaction, info3->head);
137  	ASSERT_NE (nullptr, latest2);
138  	auto latest3 = dynamic_cast<nano::send_block *> (latest2.get ());
139  	ASSERT_NE (nullptr, latest3);
140  	ASSERT_EQ (*send, *latest3);
141  	auto info4 = ledger.account_info (transaction, key2.pub);
142  	ASSERT_TRUE (info4);
143  	auto latest4 = store.block.get (transaction, info4->head);
144  	ASSERT_NE (nullptr, latest4);
145  	auto latest5 = dynamic_cast<nano::open_block *> (latest4.get ());
146  	ASSERT_NE (nullptr, latest5);
147  	ASSERT_EQ (*open, *latest5);
148  	ASSERT_FALSE (ledger.rollback (transaction, hash2));
149  	ASSERT_TRUE (store.frontier.get (transaction, hash2).is_zero ());
150  	auto info5 = ledger.account_info (transaction, key2.pub);
151  	ASSERT_FALSE (info5);
152  	auto pending1 = ledger.pending_info (transaction, nano::pending_key (key2.pub, hash1));
153  	ASSERT_TRUE (pending1);
154  	ASSERT_EQ (nano::dev::genesis_key.pub, pending1->source);
155  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, pending1->amount.number ());
156  	ASSERT_EQ (0, ledger.account_balance (transaction, key2.pub));
157  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.account_receivable (transaction, key2.pub));
158  	ASSERT_EQ (50, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
159  	ASSERT_EQ (50, ledger.weight (nano::dev::genesis_key.pub));
160  	ASSERT_EQ (0, ledger.weight (key2.pub));
161  	auto info6 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
162  	ASSERT_TRUE (info6);
163  	ASSERT_EQ (hash1, info6->head);
164  	ASSERT_FALSE (ledger.rollback (transaction, info6->head));
165  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis_key.pub));
166  	ASSERT_EQ (nano::dev::genesis_key.pub, store.frontier.get (transaction, info1->head));
167  	ASSERT_TRUE (store.frontier.get (transaction, hash1).is_zero ());
168  	auto info7 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
169  	ASSERT_TRUE (info7);
170  	ASSERT_EQ (1, info7->block_count);
171  	ASSERT_EQ (info1->head, info7->head);
172  	ASSERT_FALSE (ledger.pending_info (transaction, nano::pending_key (key2.pub, hash1)));
173  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
174  	ASSERT_EQ (0, ledger.account_receivable (transaction, key2.pub));
175  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
176  }
177  TEST (ledger, process_receive)
178  {
179  	auto ctx = nano::test::context::ledger_empty ();
180  	auto & ledger = ctx.ledger ();
181  	auto & store = ctx.store ();
182  	auto transaction = store.tx_begin_write ();
183  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
184  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
185  	ASSERT_TRUE (info1);
186  	nano::keypair key2;
187  	nano::block_builder builder;
188  	auto send = builder
189  				.send ()
190  				.previous (info1->head)
191  				.destination (key2.pub)
192  				.balance (50)
193  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
194  				.work (*pool.generate (info1->head))
195  				.build ();
196  	nano::block_hash hash1 (send->hash ());
197  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
198  	nano::keypair key3;
199  	auto open = builder
200  				.open ()
201  				.source (hash1)
202  				.representative (key3.pub)
203  				.account (key2.pub)
204  				.sign (key2.prv, key2.pub)
205  				.work (*pool.generate (key2.pub))
206  				.build ();
207  	nano::block_hash hash2 (open->hash ());
208  	auto return1 = ledger.process (transaction, *open);
209  	ASSERT_EQ (nano::process_result::progress, return1.code);
210  	ASSERT_EQ (key2.pub, store.block.account_calculated (*open));
211  	ASSERT_EQ (key2.pub, open->sideband ().account);
212  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, open->sideband ().balance.number ());
213  	ASSERT_EQ (1, open->sideband ().height);
214  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.amount (transaction, hash2));
215  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.weight (key3.pub));
216  	auto send2 = builder
217  				 .send ()
218  				 .previous (hash1)
219  				 .destination (key2.pub)
220  				 .balance (25)
221  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
222  				 .work (*pool.generate (hash1))
223  				 .build ();
224  	nano::block_hash hash3 = send2->hash ();
225  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
226  	auto receive = builder
227  				   .receive ()
228  				   .previous (hash2)
229  				   .source (hash3)
230  				   .sign (key2.prv, key2.pub)
231  				   .work (*pool.generate (hash2))
232  				   .build ();
233  	auto hash4 = receive->hash ();
234  	ASSERT_EQ (key2.pub, store.frontier.get (transaction, hash2));
235  	auto return2 = ledger.process (transaction, *receive);
236  	ASSERT_EQ (key2.pub, receive->sideband ().account);
237  	ASSERT_EQ (nano::dev::constants.genesis_amount - 25, receive->sideband ().balance.number ());
238  	ASSERT_EQ (2, receive->sideband ().height);
239  	ASSERT_EQ (25, ledger.amount (transaction, hash4));
240  	ASSERT_TRUE (store.frontier.get (transaction, hash2).is_zero ());
241  	ASSERT_EQ (key2.pub, store.frontier.get (transaction, hash4));
242  	ASSERT_EQ (nano::process_result::progress, return2.code);
243  	ASSERT_EQ (key2.pub, store.block.account_calculated (*receive));
244  	ASSERT_EQ (hash4, ledger.latest (transaction, key2.pub));
245  	ASSERT_EQ (25, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
246  	ASSERT_EQ (0, ledger.account_receivable (transaction, key2.pub));
247  	ASSERT_EQ (nano::dev::constants.genesis_amount - 25, ledger.account_balance (transaction, key2.pub));
248  	ASSERT_EQ (nano::dev::constants.genesis_amount - 25, ledger.weight (key3.pub));
249  	ASSERT_FALSE (ledger.rollback (transaction, hash4));
250  	ASSERT_TRUE (store.block.successor (transaction, hash2).is_zero ());
251  	ASSERT_EQ (key2.pub, store.frontier.get (transaction, hash2));
252  	ASSERT_TRUE (store.frontier.get (transaction, hash4).is_zero ());
253  	ASSERT_EQ (25, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
254  	ASSERT_EQ (25, ledger.account_receivable (transaction, key2.pub));
255  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.account_balance (transaction, key2.pub));
256  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.weight (key3.pub));
257  	ASSERT_EQ (hash2, ledger.latest (transaction, key2.pub));
258  	auto pending1 = ledger.pending_info (transaction, nano::pending_key (key2.pub, hash3));
259  	ASSERT_TRUE (pending1);
260  	ASSERT_EQ (nano::dev::genesis_key.pub, pending1->source);
261  	ASSERT_EQ (25, pending1->amount.number ());
262  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
263  }
264  TEST (ledger, rollback_receiver)
265  {
266  	auto ctx = nano::test::context::ledger_empty ();
267  	auto & ledger = ctx.ledger ();
268  	auto & store = ctx.store ();
269  	auto transaction = store.tx_begin_write ();
270  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
271  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
272  	ASSERT_TRUE (info1);
273  	nano::keypair key2;
274  	nano::block_builder builder;
275  	auto send = builder
276  				.send ()
277  				.previous (info1->head)
278  				.destination (key2.pub)
279  				.balance (50)
280  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
281  				.work (*pool.generate (info1->head))
282  				.build ();
283  	nano::block_hash hash1 (send->hash ());
284  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
285  	nano::keypair key3;
286  	auto open = builder
287  				.open ()
288  				.source (hash1)
289  				.representative (key3.pub)
290  				.account (key2.pub)
291  				.sign (key2.prv, key2.pub)
292  				.work (*pool.generate (key2.pub))
293  				.build ();
294  	nano::block_hash hash2 (open->hash ());
295  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
296  	ASSERT_EQ (hash2, ledger.latest (transaction, key2.pub));
297  	ASSERT_EQ (50, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
298  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.account_balance (transaction, key2.pub));
299  	ASSERT_EQ (50, ledger.weight (nano::dev::genesis_key.pub));
300  	ASSERT_EQ (0, ledger.weight (key2.pub));
301  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.weight (key3.pub));
302  	ASSERT_FALSE (ledger.rollback (transaction, hash1));
303  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.account_balance (transaction, nano::dev::genesis_key.pub));
304  	ASSERT_EQ (0, ledger.account_balance (transaction, key2.pub));
305  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis_key.pub));
306  	ASSERT_EQ (0, ledger.weight (key2.pub));
307  	ASSERT_EQ (0, ledger.weight (key3.pub));
308  	ASSERT_FALSE (ledger.account_info (transaction, key2.pub));
309  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
310  	ASSERT_FALSE (ledger.pending_info (transaction, nano::pending_key{ key2.pub, hash1 }));
311  }
312  TEST (ledger, rollback_representation)
313  {
314  	auto ctx = nano::test::context::ledger_empty ();
315  	auto & ledger = ctx.ledger ();
316  	auto & store = ctx.store ();
317  	auto transaction = store.tx_begin_write ();
318  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
319  	nano::keypair key5;
320  	nano::block_builder builder;
321  	auto change1 = builder
322  				   .change ()
323  				   .previous (nano::dev::genesis->hash ())
324  				   .representative (key5.pub)
325  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
326  				   .work (*pool.generate (nano::dev::genesis->hash ()))
327  				   .build ();
328  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change1).code);
329  	nano::keypair key3;
330  	auto change2 = builder
331  				   .change ()
332  				   .previous (change1->hash ())
333  				   .representative (key3.pub)
334  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
335  				   .work (*pool.generate (change1->hash ()))
336  				   .build ();
337  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change2).code);
338  	nano::keypair key2;
339  	auto send1 = builder
340  				 .send ()
341  				 .previous (change2->hash ())
342  				 .destination (key2.pub)
343  				 .balance (50)
344  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
345  				 .work (*pool.generate (change2->hash ()))
346  				 .build ();
347  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
348  	nano::keypair key4;
349  	auto open = builder
350  				.open ()
351  				.source (send1->hash ())
352  				.representative (key4.pub)
353  				.account (key2.pub)
354  				.sign (key2.prv, key2.pub)
355  				.work (*pool.generate (key2.pub))
356  				.build ();
357  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
358  	auto send2 = builder
359  				 .send ()
360  				 .previous (send1->hash ())
361  				 .destination (key2.pub)
362  				 .balance (1)
363  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
364  				 .work (*pool.generate (send1->hash ()))
365  				 .build ();
366  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
367  	auto receive1 = builder
368  					.receive ()
369  					.previous (open->hash ())
370  					.source (send2->hash ())
371  					.sign (key2.prv, key2.pub)
372  					.work (*pool.generate (open->hash ()))
373  					.build ();
374  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
375  	ASSERT_EQ (1, ledger.weight (key3.pub));
376  	ASSERT_EQ (nano::dev::constants.genesis_amount - 1, ledger.weight (key4.pub));
377  	auto info1 = ledger.account_info (transaction, key2.pub);
378  	ASSERT_TRUE (info1);
379  	ASSERT_EQ (key4.pub, info1->representative);
380  	ASSERT_FALSE (ledger.rollback (transaction, receive1->hash ()));
381  	auto info2 = ledger.account_info (transaction, key2.pub);
382  	ASSERT_TRUE (info2);
383  	ASSERT_EQ (key4.pub, info2->representative);
384  	ASSERT_EQ (0, ledger.weight (key2.pub));
385  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.weight (key4.pub));
386  	ASSERT_FALSE (ledger.rollback (transaction, open->hash ()));
387  	ASSERT_EQ (1, ledger.weight (key3.pub));
388  	ASSERT_EQ (0, ledger.weight (key4.pub));
389  	ledger.rollback (transaction, send1->hash ());
390  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (key3.pub));
391  	auto info3 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
392  	ASSERT_TRUE (info3);
393  	ASSERT_EQ (key3.pub, info3->representative);
394  	ASSERT_FALSE (ledger.rollback (transaction, change2->hash ()));
395  	auto info4 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
396  	ASSERT_TRUE (info4);
397  	ASSERT_EQ (key5.pub, info4->representative);
398  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (key5.pub));
399  	ASSERT_EQ (0, ledger.weight (key3.pub));
400  }
401  TEST (ledger, receive_rollback)
402  {
403  	auto ctx = nano::test::context::ledger_empty ();
404  	auto & ledger = ctx.ledger ();
405  	auto & store = ctx.store ();
406  	auto transaction = store.tx_begin_write ();
407  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
408  	nano::block_builder builder;
409  	auto send = builder
410  				.send ()
411  				.previous (nano::dev::genesis->hash ())
412  				.destination (nano::dev::genesis_key.pub)
413  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
414  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
415  				.work (*pool.generate (nano::dev::genesis->hash ()))
416  				.build ();
417  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
418  	auto receive = builder
419  				   .receive ()
420  				   .previous (send->hash ())
421  				   .source (send->hash ())
422  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
423  				   .work (*pool.generate (send->hash ()))
424  				   .build ();
425  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
426  	ASSERT_FALSE (ledger.rollback (transaction, receive->hash ()));
427  }
428  TEST (ledger, process_duplicate)
429  {
430  	auto ctx = nano::test::context::ledger_empty ();
431  	auto & ledger = ctx.ledger ();
432  	auto & store = ctx.store ();
433  	auto transaction = store.tx_begin_write ();
434  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
435  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
436  	ASSERT_TRUE (info1);
437  	nano::keypair key2;
438  	nano::block_builder builder;
439  	auto send = builder
440  				.send ()
441  				.previous (info1->head)
442  				.destination (key2.pub)
443  				.balance (50)
444  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
445  				.work (*pool.generate (info1->head))
446  				.build ();
447  	nano::block_hash hash1 (send->hash ());
448  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
449  	ASSERT_EQ (nano::process_result::old, ledger.process (transaction, *send).code);
450  	auto open = builder
451  				.open ()
452  				.source (hash1)
453  				.representative (1)
454  				.account (key2.pub)
455  				.sign (key2.prv, key2.pub)
456  				.work (*pool.generate (key2.pub))
457  				.build ();
458  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
459  	ASSERT_EQ (nano::process_result::old, ledger.process (transaction, *open).code);
460  }
461  TEST (ledger, representative_genesis)
462  {
463  	auto ctx = nano::test::context::ledger_empty ();
464  	auto & ledger = ctx.ledger ();
465  	auto & store = ctx.store ();
466  	auto transaction = store.tx_begin_write ();
467  	auto latest = ledger.latest (transaction, nano::dev::genesis_key.pub);
468  	ASSERT_FALSE (latest.is_zero ());
469  	ASSERT_EQ (nano::dev::genesis->hash (), ledger.representative (transaction, latest));
470  }
471  TEST (ledger, weight)
472  {
473  	auto ctx = nano::test::context::ledger_empty ();
474  	auto & ledger = ctx.ledger ();
475  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
476  }
477  TEST (ledger, representative_change)
478  {
479  	auto ctx = nano::test::context::ledger_empty ();
480  	auto & ledger = ctx.ledger ();
481  	auto & store = ctx.store ();
482  	auto transaction = store.tx_begin_write ();
483  	nano::keypair key2;
484  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
485  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis_key.pub));
486  	ASSERT_EQ (0, ledger.weight (key2.pub));
487  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
488  	ASSERT_TRUE (info1);
489  	nano::block_builder builder;
490  	auto block = builder
491  				 .change ()
492  				 .previous (info1->head)
493  				 .representative (key2.pub)
494  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
495  				 .work (*pool.generate (info1->head))
496  				 .build ();
497  	ASSERT_EQ (nano::dev::genesis_key.pub, store.frontier.get (transaction, info1->head));
498  	auto return1 (ledger.process (transaction, *block));
499  	ASSERT_EQ (0, ledger.amount (transaction, block->hash ()));
500  	ASSERT_TRUE (store.frontier.get (transaction, info1->head).is_zero ());
501  	ASSERT_EQ (nano::dev::genesis_key.pub, store.frontier.get (transaction, block->hash ()));
502  	ASSERT_EQ (nano::process_result::progress, return1.code);
503  	ASSERT_EQ (nano::dev::genesis_key.pub, store.block.account_calculated (*block));
504  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis_key.pub));
505  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (key2.pub));
506  	auto info2 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
507  	ASSERT_TRUE (info2);
508  	ASSERT_EQ (block->hash (), info2->head);
509  	ASSERT_FALSE (ledger.rollback (transaction, info2->head));
510  	ASSERT_EQ (nano::dev::genesis_key.pub, store.frontier.get (transaction, info1->head));
511  	ASSERT_TRUE (store.frontier.get (transaction, block->hash ()).is_zero ());
512  	auto info3 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
513  	ASSERT_TRUE (info3);
514  	ASSERT_EQ (info1->head, info3->head);
515  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis_key.pub));
516  	ASSERT_EQ (0, ledger.weight (key2.pub));
517  }
518  TEST (ledger, send_fork)
519  {
520  	auto ctx = nano::test::context::ledger_empty ();
521  	auto & ledger = ctx.ledger ();
522  	auto & store = ctx.store ();
523  	nano::keypair key2;
524  	nano::keypair key3;
525  	auto transaction = store.tx_begin_write ();
526  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
527  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
528  	ASSERT_TRUE (info1);
529  	nano::block_builder builder;
530  	auto block = builder
531  				 .send ()
532  				 .previous (info1->head)
533  				 .destination (key2.pub)
534  				 .balance (100)
535  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
536  				 .work (*pool.generate (info1->head))
537  				 .build ();
538  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block).code);
539  	auto block2 = builder
540  				  .send ()
541  				  .previous (info1->head)
542  				  .destination (key3.pub)
543  				  .balance (0)
544  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
545  				  .work (*pool.generate (info1->head))
546  				  .build ();
547  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *block2).code);
548  }
549  TEST (ledger, receive_fork)
550  {
551  	auto ctx = nano::test::context::ledger_empty ();
552  	auto & ledger = ctx.ledger ();
553  	auto & store = ctx.store ();
554  	nano::keypair key2;
555  	nano::keypair key3;
556  	auto transaction = store.tx_begin_write ();
557  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
558  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
559  	ASSERT_TRUE (info1);
560  	nano::block_builder builder;
561  	auto block = builder
562  				 .send ()
563  				 .previous (info1->head)
564  				 .destination (key2.pub)
565  				 .balance (100)
566  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
567  				 .work (*pool.generate (info1->head))
568  				 .build ();
569  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block).code);
570  	auto block2 = builder
571  				  .open ()
572  				  .source (block->hash ())
573  				  .representative (key2.pub)
574  				  .account (key2.pub)
575  				  .sign (key2.prv, key2.pub)
576  				  .work (*pool.generate (key2.pub))
577  				  .build ();
578  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
579  	auto block3 = builder
580  				  .change ()
581  				  .previous (block2->hash ())
582  				  .representative (key3.pub)
583  				  .sign (key2.prv, key2.pub)
584  				  .work (*pool.generate (block2->hash ()))
585  				  .build ();
586  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
587  	auto block4 = builder
588  				  .send ()
589  				  .previous (block->hash ())
590  				  .destination (key2.pub)
591  				  .balance (0)
592  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
593  				  .work (*pool.generate (block->hash ()))
594  				  .build ();
595  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block4).code);
596  	auto block5 = builder
597  				  .receive ()
598  				  .previous (block2->hash ())
599  				  .source (block4->hash ())
600  				  .sign (key2.prv, key2.pub)
601  				  .work (*pool.generate (block2->hash ()))
602  				  .build ();
603  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *block5).code);
604  }
605  TEST (ledger, open_fork)
606  {
607  	auto ctx = nano::test::context::ledger_empty ();
608  	auto & ledger = ctx.ledger ();
609  	auto & store = ctx.store ();
610  	nano::keypair key2;
611  	nano::keypair key3;
612  	auto transaction = store.tx_begin_write ();
613  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
614  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
615  	ASSERT_TRUE (info1);
616  	nano::block_builder builder;
617  	auto block = builder
618  				 .send ()
619  				 .previous (info1->head)
620  				 .destination (key2.pub)
621  				 .balance (100)
622  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
623  				 .work (*pool.generate (info1->head))
624  				 .build ();
625  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block).code);
626  	auto block2 = builder
627  				  .open ()
628  				  .source (block->hash ())
629  				  .representative (key2.pub)
630  				  .account (key2.pub)
631  				  .sign (key2.prv, key2.pub)
632  				  .work (*pool.generate (key2.pub))
633  				  .build ();
634  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
635  	auto block3 = builder
636  				  .open ()
637  				  .source (block->hash ())
638  				  .representative (key3.pub)
639  				  .account (key2.pub)
640  				  .sign (key2.prv, key2.pub)
641  				  .work (*pool.generate (key2.pub))
642  				  .build ();
643  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *block3).code);
644  }
645  TEST (ledger, representation_changes)
646  {
647  	nano::keypair key1;
<span onclick='openModal()' class='match'>648  	nano::rep_weights rep_weights;
649  	ASSERT_EQ (0, rep_weights.representation_get (key1.pub));
650  	rep_weights.representation_put (key1.pub, 1);
651  	ASSERT_EQ (1, rep_weights.representation_get (key1.pub));
652  	rep_weights.representation_put (key1.pub, 2);
653  	ASSERT_EQ (2, rep_weights.representation_get (key1.pub));
654  }
655  TEST (ledger, representation)
</span>656  {
657  	auto ctx = nano::test::context::ledger_empty ();
658  	auto & ledger = ctx.ledger ();
659  	auto & store = ctx.store ();
660  	auto & rep_weights = ledger.cache.rep_weights;
661  	auto transaction = store.tx_begin_write ();
662  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
663  	ASSERT_EQ (nano::dev::constants.genesis_amount, rep_weights.representation_get (nano::dev::genesis_key.pub));
664  	nano::keypair key2;
665  	nano::block_builder builder;
666  	auto block1 = builder
667  				  .send ()
668  				  .previous (nano::dev::genesis->hash ())
669  				  .destination (key2.pub)
670  				  .balance (nano::dev::constants.genesis_amount - 100)
671  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
672  				  .work (*pool.generate (nano::dev::genesis->hash ()))
673  				  .build ();
674  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
675  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, rep_weights.representation_get (nano::dev::genesis_key.pub));
676  	nano::keypair key3;
677  	auto block2 = builder
678  				  .open ()
679  				  .source (block1->hash ())
680  				  .representative (key3.pub)
681  				  .account (key2.pub)
682  				  .sign (key2.prv, key2.pub)
683  				  .work (*pool.generate (key2.pub))
684  				  .build ();
685  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
686  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, rep_weights.representation_get (nano::dev::genesis_key.pub));
687  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
688  	ASSERT_EQ (100, rep_weights.representation_get (key3.pub));
689  	auto block3 = builder
690  				  .send ()
691  				  .previous (block1->hash ())
692  				  .destination (key2.pub)
693  				  .balance (nano::dev::constants.genesis_amount - 200)
694  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
695  				  .work (*pool.generate (block1->hash ()))
696  				  .build ();
697  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
698  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
699  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
700  	ASSERT_EQ (100, rep_weights.representation_get (key3.pub));
701  	auto block4 = builder
702  				  .receive ()
703  				  .previous (block2->hash ())
704  				  .source (block3->hash ())
705  				  .sign (key2.prv, key2.pub)
706  				  .work (*pool.generate (block2->hash ()))
707  				  .build ();
708  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block4).code);
709  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
710  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
711  	ASSERT_EQ (200, rep_weights.representation_get (key3.pub));
712  	nano::keypair key4;
713  	auto block5 = builder
714  				  .change ()
715  				  .previous (block4->hash ())
716  				  .representative (key4.pub)
717  				  .sign (key2.prv, key2.pub)
718  				  .work (*pool.generate (block4->hash ()))
719  				  .build ();
720  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block5).code);
721  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
722  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
723  	ASSERT_EQ (0, rep_weights.representation_get (key3.pub));
724  	ASSERT_EQ (200, rep_weights.representation_get (key4.pub));
725  	nano::keypair key5;
726  	auto block6 = builder
727  				  .send ()
728  				  .previous (block5->hash ())
729  				  .destination (key5.pub)
730  				  .balance (100)
731  				  .sign (key2.prv, key2.pub)
732  				  .work (*pool.generate (block5->hash ()))
733  				  .build ();
734  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block6).code);
735  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
736  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
737  	ASSERT_EQ (0, rep_weights.representation_get (key3.pub));
738  	ASSERT_EQ (100, rep_weights.representation_get (key4.pub));
739  	ASSERT_EQ (0, rep_weights.representation_get (key5.pub));
740  	nano::keypair key6;
741  	auto block7 = builder
742  				  .open ()
743  				  .source (block6->hash ())
744  				  .representative (key6.pub)
745  				  .account (key5.pub)
746  				  .sign (key5.prv, key5.pub)
747  				  .work (*pool.generate (key5.pub))
748  				  .build ();
749  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block7).code);
750  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
751  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
752  	ASSERT_EQ (0, rep_weights.representation_get (key3.pub));
753  	ASSERT_EQ (100, rep_weights.representation_get (key4.pub));
754  	ASSERT_EQ (0, rep_weights.representation_get (key5.pub));
755  	ASSERT_EQ (100, rep_weights.representation_get (key6.pub));
756  	auto block8 = builder
757  				  .send ()
758  				  .previous (block6->hash ())
759  				  .destination (key5.pub)
760  				  .balance (0)
761  				  .sign (key2.prv, key2.pub)
762  				  .work (*pool.generate (block6->hash ()))
763  				  .build ();
764  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block8).code);
765  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
766  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
767  	ASSERT_EQ (0, rep_weights.representation_get (key3.pub));
768  	ASSERT_EQ (0, rep_weights.representation_get (key4.pub));
769  	ASSERT_EQ (0, rep_weights.representation_get (key5.pub));
770  	ASSERT_EQ (100, rep_weights.representation_get (key6.pub));
771  	auto block9 = builder
772  				  .receive ()
773  				  .previous (block7->hash ())
774  				  .source (block8->hash ())
775  				  .sign (key5.prv, key5.pub)
776  				  .work (*pool.generate (block7->hash ()))
777  				  .build ();
778  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block9).code);
779  	ASSERT_EQ (nano::dev::constants.genesis_amount - 200, rep_weights.representation_get (nano::dev::genesis_key.pub));
780  	ASSERT_EQ (0, rep_weights.representation_get (key2.pub));
781  	ASSERT_EQ (0, rep_weights.representation_get (key3.pub));
782  	ASSERT_EQ (0, rep_weights.representation_get (key4.pub));
783  	ASSERT_EQ (0, rep_weights.representation_get (key5.pub));
784  	ASSERT_EQ (200, rep_weights.representation_get (key6.pub));
785  }
786  TEST (ledger, double_open)
787  {
788  	nano::logger_mt logger;
789  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
790  	ASSERT_TRUE (!store->init_error ());
791  	nano::stats stats;
792  	nano::ledger ledger (*store, stats, nano::dev::constants);
793  	auto transaction (store->tx_begin_write ());
794  	store->initialize (transaction, ledger.cache, ledger.constants);
795  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
796  	nano::keypair key2;
797  	nano::block_builder builder;
798  	auto send1 = builder
799  				 .send ()
800  				 .previous (nano::dev::genesis->hash ())
801  				 .destination (key2.pub)
802  				 .balance (1)
803  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
804  				 .work (*pool.generate (nano::dev::genesis->hash ()))
805  				 .build ();
806  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
807  	auto open1 = builder
808  				 .open ()
809  				 .source (send1->hash ())
810  				 .representative (key2.pub)
811  				 .account (key2.pub)
812  				 .sign (key2.prv, key2.pub)
813  				 .work (*pool.generate (key2.pub))
814  				 .build ();
815  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
816  	auto open2 = builder
817  				 .open ()
818  				 .source (send1->hash ())
819  				 .representative (nano::dev::genesis_key.pub)
820  				 .account (key2.pub)
821  				 .sign (key2.prv, key2.pub)
822  				 .work (*pool.generate (key2.pub))
823  				 .build ();
824  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *open2).code);
825  }
826  TEST (ledger, double_receive)
827  {
828  	auto ctx = nano::test::context::ledger_empty ();
829  	auto & ledger = ctx.ledger ();
830  	auto & store = ctx.store ();
831  	auto transaction = store.tx_begin_write ();
832  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
833  	nano::keypair key2;
834  	nano::block_builder builder;
835  	auto send1 = builder
836  				 .send ()
837  				 .previous (nano::dev::genesis->hash ())
838  				 .destination (key2.pub)
839  				 .balance (1)
840  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
841  				 .work (*pool.generate (nano::dev::genesis->hash ()))
842  				 .build ();
843  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
844  	auto open1 = builder
845  				 .open ()
846  				 .source (send1->hash ())
847  				 .representative (key2.pub)
848  				 .account (key2.pub)
849  				 .sign (key2.prv, key2.pub)
850  				 .work (*pool.generate (key2.pub))
851  				 .build ();
852  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
853  	auto receive1 = builder
854  					.receive ()
855  					.previous (open1->hash ())
856  					.source (send1->hash ())
857  					.sign (key2.prv, key2.pub)
858  					.work (*pool.generate (open1->hash ()))
859  					.build ();
860  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *receive1).code);
861  }
862  TEST (votes, check_signature)
863  {
864  	nano::test::system system;
865  	nano::node_config node_config = system.default_config ();
866  	node_config.online_weight_minimum = std::numeric_limits<nano::uint128_t>::max ();
867  	auto & node1 = *system.add_node (node_config);
868  	nano::keypair key1;
869  	nano::block_builder builder;
870  	auto send1 = builder
871  				 .send ()
872  				 .previous (nano::dev::genesis->hash ())
873  				 .destination (key1.pub)
874  				 .balance (nano::dev::constants.genesis_amount - 100)
875  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
876  				 .work (0)
877  				 .build_shared ();
878  	node1.work_generate_blocking (*send1);
879  	{
880  		auto transaction (node1.store.tx_begin_write ());
881  		ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send1).code);
882  	}
883  	node1.scheduler.buckets.activate (nano::dev::genesis_key.pub, node1.store.tx_begin_read ());
884  	ASSERT_TIMELY (5s, node1.active.election (send1->qualified_root ()));
885  	auto election1 = node1.active.election (send1->qualified_root ());
886  	ASSERT_EQ (1, election1->votes ().size ());
887  	auto vote1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ send1->hash () }));
888  	vote1->signature.bytes[0] ^= 1;
889  	ASSERT_EQ (nano::vote_code::invalid, node1.vote_processor.vote_blocking (vote1, std::make_shared<nano::transport::inproc::channel> (node1, node1)));
890  	vote1->signature.bytes[0] ^= 1;
891  	ASSERT_EQ (nano::vote_code::vote, node1.vote_processor.vote_blocking (vote1, std::make_shared<nano::transport::inproc::channel> (node1, node1)));
892  	ASSERT_EQ (nano::vote_code::replay, node1.vote_processor.vote_blocking (vote1, std::make_shared<nano::transport::inproc::channel> (node1, node1)));
893  }
894  TEST (votes, add_one)
895  {
896  	nano::test::system system (1);
897  	auto & node1 (*system.nodes[0]);
898  	nano::keypair key1;
899  	nano::block_builder builder;
900  	auto send1 = builder
901  				 .send ()
902  				 .previous (nano::dev::genesis->hash ())
903  				 .destination (key1.pub)
904  				 .balance (nano::dev::constants.genesis_amount - 100)
905  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
906  				 .work (0)
907  				 .build_shared ();
908  	node1.work_generate_blocking (*send1);
909  	auto transaction (node1.store.tx_begin_write ());
910  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send1).code);
911  	node1.block_confirm (send1);
912  	ASSERT_TIMELY (5s, node1.active.election (send1->qualified_root ()));
913  	auto election1 = node1.active.election (send1->qualified_root ());
914  	ASSERT_EQ (1, election1->votes ().size ());
915  	auto vote1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ send1->hash () }));
916  	ASSERT_EQ (nano::vote_code::vote, node1.active.vote (vote1));
917  	auto vote2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 2, 0, std::vector<nano::block_hash>{ send1->hash () }));
918  	ASSERT_EQ (nano::vote_code::vote, node1.active.vote (vote2));
919  	ASSERT_EQ (2, election1->votes ().size ());
920  	auto votes1 (election1->votes ());
921  	auto existing1 (votes1.find (nano::dev::genesis_key.pub));
922  	ASSERT_NE (votes1.end (), existing1);
923  	ASSERT_EQ (send1->hash (), existing1->second.hash);
924  	nano::lock_guard<nano::mutex> guard{ node1.active.mutex };
925  	auto winner (*election1->tally ().begin ());
926  	ASSERT_EQ (*send1, *winner.second);
927  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
928  }
929  namespace nano
930  {
931  TEST (votes, add_existing)
932  {
933  	nano::test::system system;
934  	nano::node_config node_config = system.default_config ();
935  	node_config.online_weight_minimum = nano::dev::constants.genesis_amount;
936  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
937  	auto & node1 = *system.add_node (node_config);
938  	nano::keypair key1;
939  	nano::block_builder builder;
940  	std::shared_ptr<nano::block> send1 = builder.state ()
941  										 .account (nano::dev::genesis_key.pub)
942  										 .previous (nano::dev::genesis->hash ())
943  										 .representative (nano::dev::genesis_key.pub) 
944  										 .balance (nano::dev::constants.genesis_amount / 2 - nano::Gxrb_ratio)
945  										 .link (key1.pub)
946  										 .work (0)
947  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
948  										 .build ();
949  	node1.work_generate_blocking (*send1);
950  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (node1.store.tx_begin_write (), *send1).code);
951  	node1.scheduler.buckets.activate (nano::dev::genesis_key.pub, node1.store.tx_begin_read ());
952  	ASSERT_TIMELY (5s, node1.active.election (send1->qualified_root ()));
953  	auto election1 = node1.active.election (send1->qualified_root ());
954  	auto vote1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ send1->hash () }));
955  	ASSERT_EQ (nano::vote_code::vote, node1.active.vote (vote1));
956  	ASSERT_TRUE (node1.active.publish (send1));
957  	ASSERT_EQ (nano::vote::timestamp_min * 1, election1->last_votes[nano::dev::genesis_key.pub].timestamp);
958  	nano::keypair key2;
959  	std::shared_ptr<nano::block> send2 = builder.state ()
960  										 .account (nano::dev::genesis_key.pub)
961  										 .previous (nano::dev::genesis->hash ())
962  										 .representative (nano::dev::genesis_key.pub) 
963  										 .balance (nano::dev::constants.genesis_amount / 2 - nano::Gxrb_ratio)
964  										 .link (key2.pub)
965  										 .work (0)
966  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
967  										 .build ();
968  	node1.work_generate_blocking (*send2);
969  	ASSERT_FALSE (node1.active.publish (send2));
970  	ASSERT_TIMELY (5s, node1.active.active (*send2));
971  	auto vote2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 2, 0, std::vector<nano::block_hash>{ send2->hash () }));
972  	nano::unique_lock<nano::mutex> lock{ election1->mutex };
973  	election1->last_votes[nano::dev::genesis_key.pub].time = std::chrono::steady_clock::now () - std::chrono::seconds (20);
974  	lock.unlock ();
975  	ASSERT_EQ (nano::vote_code::vote, node1.active.vote (vote2));
976  	ASSERT_EQ (nano::vote::timestamp_min * 2, election1->last_votes[nano::dev::genesis_key.pub].timestamp);
977  	lock.lock ();
978  	election1->last_votes[nano::dev::genesis_key.pub].time = std::chrono::steady_clock::now () - std::chrono::seconds (20);
979  	lock.unlock ();
980  	ASSERT_EQ (nano::vote_code::replay, node1.active.vote (vote1));
981  	ASSERT_EQ (nano::vote::timestamp_min * 2, election1->votes ()[nano::dev::genesis_key.pub].timestamp);
982  	auto votes (election1->votes ());
983  	ASSERT_EQ (2, votes.size ());
984  	ASSERT_NE (votes.end (), votes.find (nano::dev::genesis_key.pub));
985  	ASSERT_EQ (send2->hash (), votes[nano::dev::genesis_key.pub].hash);
986  	ASSERT_EQ (*send2, *election1->tally ().begin ()->second);
987  }
988  TEST (votes, add_old)
989  {
990  	nano::test::system system (1);
991  	auto & node1 (*system.nodes[0]);
992  	nano::keypair key1;
993  	nano::block_builder builder;
994  	auto send1 = builder
995  				 .send ()
996  				 .previous (nano::dev::genesis->hash ())
997  				 .destination (key1.pub)
998  				 .balance (0)
999  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1000  				 .work (0)
1001  				 .build_shared ();
1002  	node1.work_generate_blocking (*send1);
1003  	auto transaction (node1.store.tx_begin_write ());
1004  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send1).code);
1005  	node1.block_confirm (send1);
1006  	ASSERT_TIMELY (5s, node1.active.election (send1->qualified_root ()));
1007  	auto election1 = node1.active.election (send1->qualified_root ());
1008  	auto vote1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 2, 0, std::vector<nano::block_hash>{ send1->hash () }));
1009  	auto channel (std::make_shared<nano::transport::inproc::channel> (node1, node1));
1010  	node1.vote_processor.vote_blocking (vote1, channel);
1011  	nano::keypair key2;
1012  	auto send2 = builder
1013  				 .send ()
1014  				 .previous (nano::dev::genesis->hash ())
1015  				 .destination (key2.pub)
1016  				 .balance (0)
1017  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1018  				 .work (0)
1019  				 .build_shared ();
1020  	node1.work_generate_blocking (*send2);
1021  	auto vote2 = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ send2->hash () });
1022  	{
1023  		nano::lock_guard<nano::mutex> lock{ election1->mutex };
1024  		election1->last_votes[nano::dev::genesis_key.pub].time = std::chrono::steady_clock::now () - std::chrono::seconds (20);
1025  	}
1026  	node1.vote_processor.vote_blocking (vote2, channel);
1027  	ASSERT_EQ (2, election1->votes ().size ());
1028  	auto votes (election1->votes ());
1029  	ASSERT_NE (votes.end (), votes.find (nano::dev::genesis_key.pub));
1030  	ASSERT_EQ (send1->hash (), votes[nano::dev::genesis_key.pub].hash);
1031  	ASSERT_EQ (*send1, *election1->winner ());
1032  }
1033  }
1034  TEST (votes, DISABLED_add_old_different_account)
1035  {
1036  	nano::test::system system (1);
1037  	auto & node1 (*system.nodes[0]);
1038  	nano::keypair key1;
1039  	nano::block_builder builder;
1040  	auto send1 = builder
1041  				 .send ()
1042  				 .previous (nano::dev::genesis->hash ())
1043  				 .destination (key1.pub)
1044  				 .balance (0)
1045  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1046  				 .work (0)
1047  				 .build_shared ();
1048  	node1.work_generate_blocking (*send1);
1049  	auto send2 = builder
1050  				 .send ()
1051  				 .previous (send1->hash ())
1052  				 .destination (key1.pub)
1053  				 .balance (0)
1054  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1055  				 .work (0)
1056  				 .build_shared ();
1057  	node1.work_generate_blocking (*send2);
1058  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
1059  	ASSERT_EQ (nano::process_result::progress, node1.process (*send2).code);
1060  	nano::test::start_elections (system, node1, { send1, send2 });
1061  	auto election1 = node1.active.election (send1->qualified_root ());
1062  	ASSERT_NE (nullptr, election1);
1063  	auto election2 = node1.active.election (send2->qualified_root ());
1064  	ASSERT_NE (nullptr, election2);
1065  	ASSERT_EQ (1, election1->votes ().size ());
1066  	ASSERT_EQ (1, election2->votes ().size ());
1067  	auto vote1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 2, 0, std::vector<nano::block_hash>{ send1->hash () }));
1068  	auto channel (std::make_shared<nano::transport::inproc::channel> (node1, node1));
1069  	auto vote_result1 (node1.vote_processor.vote_blocking (vote1, channel));
1070  	ASSERT_EQ (nano::vote_code::vote, vote_result1);
1071  	ASSERT_EQ (2, election1->votes ().size ());
1072  	ASSERT_EQ (1, election2->votes ().size ());
1073  	auto vote2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ send2->hash () }));
1074  	auto vote_result2 (node1.vote_processor.vote_blocking (vote2, channel));
1075  	ASSERT_EQ (nano::vote_code::vote, vote_result2);
1076  	ASSERT_EQ (2, election1->votes ().size ());
1077  	ASSERT_EQ (2, election2->votes ().size ());
1078  	auto votes1 (election1->votes ());
1079  	auto votes2 (election2->votes ());
1080  	ASSERT_NE (votes1.end (), votes1.find (nano::dev::genesis_key.pub));
1081  	ASSERT_NE (votes2.end (), votes2.find (nano::dev::genesis_key.pub));
1082  	ASSERT_EQ (send1->hash (), votes1[nano::dev::genesis_key.pub].hash);
1083  	ASSERT_EQ (send2->hash (), votes2[nano::dev::genesis_key.pub].hash);
1084  	ASSERT_EQ (*send1, *election1->winner ());
1085  	ASSERT_EQ (*send2, *election2->winner ());
1086  }
1087  TEST (votes, add_cooldown)
1088  {
1089  	nano::test::system system (1);
1090  	auto & node1 (*system.nodes[0]);
1091  	nano::keypair key1;
1092  	nano::block_builder builder;
1093  	auto send1 = builder
1094  				 .send ()
1095  				 .previous (nano::dev::genesis->hash ())
1096  				 .destination (key1.pub)
1097  				 .balance (0)
1098  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1099  				 .work (0)
1100  				 .build_shared ();
1101  	node1.work_generate_blocking (*send1);
1102  	auto transaction (node1.store.tx_begin_write ());
1103  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send1).code);
1104  	node1.block_confirm (send1);
1105  	ASSERT_TIMELY (5s, node1.active.election (send1->qualified_root ()));
1106  	auto election1 = node1.active.election (send1->qualified_root ());
1107  	auto vote1 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 1, 0, std::vector<nano::block_hash>{ send1->hash () }));
1108  	auto channel (std::make_shared<nano::transport::inproc::channel> (node1, node1));
1109  	node1.vote_processor.vote_blocking (vote1, channel);
1110  	nano::keypair key2;
1111  	auto send2 = builder
1112  				 .send ()
1113  				 .previous (nano::dev::genesis->hash ())
1114  				 .destination (key2.pub)
1115  				 .balance (0)
1116  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1117  				 .work (0)
1118  				 .build_shared ();
1119  	node1.work_generate_blocking (*send2);
1120  	auto vote2 (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_min * 2, 0, std::vector<nano::block_hash>{ send2->hash () }));
1121  	node1.vote_processor.vote_blocking (vote2, channel);
1122  	ASSERT_EQ (2, election1->votes ().size ());
1123  	auto votes (election1->votes ());
1124  	ASSERT_NE (votes.end (), votes.find (nano::dev::genesis_key.pub));
1125  	ASSERT_EQ (send1->hash (), votes[nano::dev::genesis_key.pub].hash);
1126  	ASSERT_EQ (*send1, *election1->winner ());
1127  }
1128  TEST (ledger, successor)
1129  {
1130  	nano::test::system system (1);
1131  	auto & node1 (*system.nodes[0]);
1132  	nano::keypair key1;
1133  	nano::block_builder builder;
1134  	auto send1 = builder
1135  				 .send ()
1136  				 .previous (nano::dev::genesis->hash ())
1137  				 .destination (key1.pub)
1138  				 .balance (0)
1139  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1140  				 .work (0)
1141  				 .build ();
1142  	node1.work_generate_blocking (*send1);
1143  	auto transaction (node1.store.tx_begin_write ());
1144  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send1).code);
1145  	ASSERT_EQ (*send1, *node1.ledger.successor (transaction, nano::qualified_root (nano::root (0), nano::dev::genesis->hash ())));
1146  	ASSERT_EQ (*nano::dev::genesis, *node1.ledger.successor (transaction, nano::dev::genesis->qualified_root ()));
1147  	ASSERT_EQ (nullptr, node1.ledger.successor (transaction, nano::qualified_root (0)));
1148  }
1149  TEST (ledger, fail_change_old)
1150  {
1151  	auto ctx = nano::test::context::ledger_empty ();
1152  	auto & ledger = ctx.ledger ();
1153  	auto & store = ctx.store ();
1154  	auto transaction = store.tx_begin_write ();
1155  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1156  	nano::keypair key1;
1157  	nano::block_builder builder;
1158  	auto block = builder
1159  				 .change ()
1160  				 .previous (nano::dev::genesis->hash ())
1161  				 .representative (key1.pub)
1162  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1163  				 .work (*pool.generate (nano::dev::genesis->hash ()))
1164  				 .build ();
1165  	auto result1 = ledger.process (transaction, *block);
1166  	ASSERT_EQ (nano::process_result::progress, result1.code);
1167  	auto result2 = ledger.process (transaction, *block);
1168  	ASSERT_EQ (nano::process_result::old, result2.code);
1169  }
1170  TEST (ledger, fail_change_gap_previous)
1171  {
1172  	auto ctx = nano::test::context::ledger_empty ();
1173  	auto & ledger = ctx.ledger ();
1174  	auto & store = ctx.store ();
1175  	auto transaction = store.tx_begin_write ();
1176  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1177  	nano::keypair key1;
1178  	nano::block_builder builder;
1179  	auto block = builder
1180  				 .change ()
1181  				 .previous (1)
1182  				 .representative (key1.pub)
1183  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1184  				 .work (*pool.generate (nano::root (1)))
1185  				 .build ();
1186  	auto result1 = ledger.process (transaction, *block);
1187  	ASSERT_EQ (nano::process_result::gap_previous, result1.code);
1188  }
1189  TEST (ledger, fail_change_bad_signature)
1190  {
1191  	auto ctx = nano::test::context::ledger_empty ();
1192  	auto & ledger = ctx.ledger ();
1193  	auto & store = ctx.store ();
1194  	auto transaction = store.tx_begin_write ();
1195  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1196  	nano::keypair key1;
1197  	nano::block_builder builder;
1198  	auto block = builder
1199  				 .change ()
1200  				 .previous (nano::dev::genesis->hash ())
1201  				 .representative (key1.pub)
1202  				 .sign (nano::keypair ().prv, 0)
1203  				 .work (*pool.generate (nano::dev::genesis->hash ()))
1204  				 .build ();
1205  	auto result1 = ledger.process (transaction, *block);
1206  	ASSERT_EQ (nano::process_result::bad_signature, result1.code);
1207  }
1208  TEST (ledger, fail_change_fork)
1209  {
1210  	auto ctx = nano::test::context::ledger_empty ();
1211  	auto & ledger = ctx.ledger ();
1212  	auto & store = ctx.store ();
1213  	auto transaction = store.tx_begin_write ();
1214  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1215  	nano::keypair key1;
1216  	nano::block_builder builder;
1217  	auto block1 = builder
1218  				  .change ()
1219  				  .previous (nano::dev::genesis->hash ())
1220  				  .representative (key1.pub)
1221  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1222  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1223  				  .build ();
1224  	auto result1 = ledger.process (transaction, *block1);
1225  	ASSERT_EQ (nano::process_result::progress, result1.code);
1226  	nano::keypair key2;
1227  	auto block2 = builder
1228  				  .change ()
1229  				  .previous (nano::dev::genesis->hash ())
1230  				  .representative (key2.pub)
1231  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1232  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1233  				  .build ();
1234  	auto result2 = ledger.process (transaction, *block2);
1235  	ASSERT_EQ (nano::process_result::fork, result2.code);
1236  }
1237  TEST (ledger, fail_send_old)
1238  {
1239  	auto ctx = nano::test::context::ledger_empty ();
1240  	auto & ledger = ctx.ledger ();
1241  	auto & store = ctx.store ();
1242  	auto transaction = store.tx_begin_write ();
1243  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1244  	nano::keypair key1;
1245  	nano::block_builder builder;
1246  	auto block = builder
1247  				 .send ()
1248  				 .previous (nano::dev::genesis->hash ())
1249  				 .destination (key1.pub)
1250  				 .balance (1)
1251  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1252  				 .work (*pool.generate (nano::dev::genesis->hash ()))
1253  				 .build ();
1254  	auto result1 = ledger.process (transaction, *block);
1255  	ASSERT_EQ (nano::process_result::progress, result1.code);
1256  	auto result2 = ledger.process (transaction, *block);
1257  	ASSERT_EQ (nano::process_result::old, result2.code);
1258  }
1259  TEST (ledger, fail_send_gap_previous)
1260  {
1261  	auto ctx = nano::test::context::ledger_empty ();
1262  	auto & ledger = ctx.ledger ();
1263  	auto & store = ctx.store ();
1264  	auto transaction = store.tx_begin_write ();
1265  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1266  	nano::keypair key1;
1267  	nano::block_builder builder;
1268  	auto block = builder
1269  				 .send ()
1270  				 .previous (1)
1271  				 .destination (key1.pub)
1272  				 .balance (1)
1273  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1274  				 .work (*pool.generate (nano::root (1)))
1275  				 .build ();
1276  	auto result1 = ledger.process (transaction, *block);
1277  	ASSERT_EQ (nano::process_result::gap_previous, result1.code);
1278  }
1279  TEST (ledger, fail_send_bad_signature)
1280  {
1281  	auto ctx = nano::test::context::ledger_empty ();
1282  	auto & ledger = ctx.ledger ();
1283  	auto & store = ctx.store ();
1284  	auto transaction = store.tx_begin_write ();
1285  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1286  	nano::keypair key1;
1287  	nano::block_builder builder;
1288  	auto block = builder
1289  				 .send ()
1290  				 .previous (nano::dev::genesis->hash ())
1291  				 .destination (key1.pub)
1292  				 .balance (1)
1293  				 .sign (nano::keypair ().prv, 0)
1294  				 .work (*pool.generate (nano::dev::genesis->hash ()))
1295  				 .build ();
1296  	auto result1 = ledger.process (transaction, *block);
1297  	ASSERT_EQ (nano::process_result::bad_signature, result1.code);
1298  }
1299  TEST (ledger, fail_send_negative_spend)
1300  {
1301  	auto ctx = nano::test::context::ledger_empty ();
1302  	auto & ledger = ctx.ledger ();
1303  	auto & store = ctx.store ();
1304  	auto transaction = store.tx_begin_write ();
1305  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1306  	nano::keypair key1;
1307  	nano::block_builder builder;
1308  	auto block1 = builder
1309  				  .send ()
1310  				  .previous (nano::dev::genesis->hash ())
1311  				  .destination (key1.pub)
1312  				  .balance (1)
1313  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1314  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1315  				  .build ();
1316  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1317  	nano::keypair key2;
1318  	auto block2 = builder
1319  				  .send ()
1320  				  .previous (block1->hash ())
1321  				  .destination (key2.pub)
1322  				  .balance (2)
1323  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1324  				  .work (*pool.generate (block1->hash ()))
1325  				  .build ();
1326  	ASSERT_EQ (nano::process_result::negative_spend, ledger.process (transaction, *block2).code);
1327  }
1328  TEST (ledger, fail_send_fork)
1329  {
1330  	auto ctx = nano::test::context::ledger_empty ();
1331  	auto & ledger = ctx.ledger ();
1332  	auto & store = ctx.store ();
1333  	auto transaction = store.tx_begin_write ();
1334  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1335  	nano::keypair key1;
1336  	nano::block_builder builder;
1337  	auto block1 = builder
1338  				  .send ()
1339  				  .previous (nano::dev::genesis->hash ())
1340  				  .destination (key1.pub)
1341  				  .balance (1)
1342  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1343  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1344  				  .build ();
1345  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1346  	nano::keypair key2;
1347  	auto block2 = builder
1348  				  .send ()
1349  				  .previous (nano::dev::genesis->hash ())
1350  				  .destination (key2.pub)
1351  				  .balance (1)
1352  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1353  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1354  				  .build ();
1355  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *block2).code);
1356  }
1357  TEST (ledger, fail_open_old)
1358  {
1359  	auto ctx = nano::test::context::ledger_empty ();
1360  	auto & ledger = ctx.ledger ();
1361  	auto & store = ctx.store ();
1362  	auto transaction = store.tx_begin_write ();
1363  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1364  	nano::keypair key1;
1365  	nano::block_builder builder;
1366  	auto block1 = builder
1367  				  .send ()
1368  				  .previous (nano::dev::genesis->hash ())
1369  				  .destination (key1.pub)
1370  				  .balance (1)
1371  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1372  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1373  				  .build ();
1374  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1375  	auto block2 = builder
1376  				  .open ()
1377  				  .source (block1->hash ())
1378  				  .representative (1)
1379  				  .account (key1.pub)
1380  				  .sign (key1.prv, key1.pub)
1381  				  .work (*pool.generate (key1.pub))
1382  				  .build ();
1383  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
1384  	ASSERT_EQ (nano::process_result::old, ledger.process (transaction, *block2).code);
1385  }
1386  TEST (ledger, fail_open_gap_source)
1387  {
1388  	auto ctx = nano::test::context::ledger_empty ();
1389  	auto & ledger = ctx.ledger ();
1390  	auto & store = ctx.store ();
1391  	auto transaction = store.tx_begin_write ();
1392  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1393  	nano::keypair key1;
1394  	nano::block_builder builder;
1395  	auto block2 = builder
1396  				  .open ()
1397  				  .source (1)
1398  				  .representative (1)
1399  				  .account (key1.pub)
1400  				  .sign (key1.prv, key1.pub)
1401  				  .work (*pool.generate (key1.pub))
1402  				  .build ();
1403  	auto result2 = ledger.process (transaction, *block2);
1404  	ASSERT_EQ (nano::process_result::gap_source, result2.code);
1405  }
1406  TEST (ledger, fail_open_bad_signature)
1407  {
1408  	auto ctx = nano::test::context::ledger_empty ();
1409  	auto & ledger = ctx.ledger ();
1410  	auto & store = ctx.store ();
1411  	auto transaction = store.tx_begin_write ();
1412  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1413  	nano::keypair key1;
1414  	nano::block_builder builder;
1415  	auto block1 = builder
1416  				  .send ()
1417  				  .previous (nano::dev::genesis->hash ())
1418  				  .destination (key1.pub)
1419  				  .balance (1)
1420  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1421  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1422  				  .build ();
1423  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1424  	auto block2 = builder
1425  				  .open ()
1426  				  .source (block1->hash ())
1427  				  .representative (1)
1428  				  .account (key1.pub)
1429  				  .sign (key1.prv, key1.pub)
1430  				  .work (*pool.generate (key1.pub))
1431  				  .build ();
1432  	block2->signature.clear ();
1433  	ASSERT_EQ (nano::process_result::bad_signature, ledger.process (transaction, *block2).code);
1434  }
1435  TEST (ledger, fail_open_fork_previous)
1436  {
1437  	auto ctx = nano::test::context::ledger_empty ();
1438  	auto & ledger = ctx.ledger ();
1439  	auto & store = ctx.store ();
1440  	auto transaction = store.tx_begin_write ();
1441  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1442  	nano::keypair key1;
1443  	nano::block_builder builder;
1444  	auto block1 = builder
1445  				  .send ()
1446  				  .previous (nano::dev::genesis->hash ())
1447  				  .destination (key1.pub)
1448  				  .balance (1)
1449  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1450  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1451  				  .build ();
1452  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1453  	auto block2 = builder
1454  				  .send ()
1455  				  .previous (block1->hash ())
1456  				  .destination (key1.pub)
1457  				  .balance (0)
1458  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1459  				  .work (*pool.generate (block1->hash ()))
1460  				  .build ();
1461  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
1462  	auto block3 = builder
1463  				  .open ()
1464  				  .source (block1->hash ())
1465  				  .representative (1)
1466  				  .account (key1.pub)
1467  				  .sign (key1.prv, key1.pub)
1468  				  .work (*pool.generate (key1.pub))
1469  				  .build ();
1470  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
1471  	auto block4 = builder
1472  				  .open ()
1473  				  .source (block2->hash ())
1474  				  .representative (1)
1475  				  .account (key1.pub)
1476  				  .sign (key1.prv, key1.pub)
1477  				  .work (*pool.generate (key1.pub))
1478  				  .build ();
1479  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *block4).code);
1480  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
1481  }
1482  TEST (ledger, fail_open_account_mismatch)
1483  {
1484  	auto ctx = nano::test::context::ledger_empty ();
1485  	auto & ledger = ctx.ledger ();
1486  	auto & store = ctx.store ();
1487  	auto transaction = store.tx_begin_write ();
1488  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1489  	nano::keypair key1;
1490  	nano::block_builder builder;
1491  	auto block1 = builder
1492  				  .send ()
1493  				  .previous (nano::dev::genesis->hash ())
1494  				  .destination (key1.pub)
1495  				  .balance (1)
1496  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1497  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1498  				  .build ();
1499  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1500  	nano::keypair badkey;
1501  	auto block2 = builder
1502  				  .open ()
1503  				  .source (block1->hash ())
1504  				  .representative (1)
1505  				  .account (badkey.pub)
1506  				  .sign (badkey.prv, badkey.pub)
1507  				  .work (*pool.generate (badkey.pub))
1508  				  .build ();
1509  	ASSERT_NE (nano::process_result::progress, ledger.process (transaction, *block2).code);
1510  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
1511  }
1512  TEST (ledger, fail_receive_old)
1513  {
1514  	auto ctx = nano::test::context::ledger_empty ();
1515  	auto & ledger = ctx.ledger ();
1516  	auto & store = ctx.store ();
1517  	auto transaction = store.tx_begin_write ();
1518  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1519  	nano::keypair key1;
1520  	nano::block_builder builder;
1521  	auto block1 = builder
1522  				  .send ()
1523  				  .previous (nano::dev::genesis->hash ())
1524  				  .destination (key1.pub)
1525  				  .balance (1)
1526  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1527  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1528  				  .build ();
1529  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1530  	auto block2 = builder
1531  				  .send ()
1532  				  .previous (block1->hash ())
1533  				  .destination (key1.pub)
1534  				  .balance (0)
1535  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1536  				  .work (*pool.generate (block1->hash ()))
1537  				  .build ();
1538  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
1539  	auto block3 = builder
1540  				  .open ()
1541  				  .source (block1->hash ())
1542  				  .representative (1)
1543  				  .account (key1.pub)
1544  				  .sign (key1.prv, key1.pub)
1545  				  .work (*pool.generate (key1.pub))
1546  				  .build ();
1547  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
1548  	auto block4 = builder
1549  				  .receive ()
1550  				  .previous (block3->hash ())
1551  				  .source (block2->hash ())
1552  				  .sign (key1.prv, key1.pub)
1553  				  .work (*pool.generate (block3->hash ()))
1554  				  .build ();
1555  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block4).code);
1556  	ASSERT_EQ (nano::process_result::old, ledger.process (transaction, *block4).code);
1557  }
1558  TEST (ledger, fail_receive_gap_source)
1559  {
1560  	auto ctx = nano::test::context::ledger_empty ();
1561  	auto & ledger = ctx.ledger ();
1562  	auto & store = ctx.store ();
1563  	auto transaction = store.tx_begin_write ();
1564  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1565  	nano::keypair key1;
1566  	nano::block_builder builder;
1567  	auto block1 = builder
1568  				  .send ()
1569  				  .previous (nano::dev::genesis->hash ())
1570  				  .destination (key1.pub)
1571  				  .balance (1)
1572  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1573  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1574  				  .build ();
1575  	auto result1 = ledger.process (transaction, *block1);
1576  	ASSERT_EQ (nano::process_result::progress, result1.code);
1577  	auto block2 = builder
1578  				  .send ()
1579  				  .previous (block1->hash ())
1580  				  .destination (key1.pub)
1581  				  .balance (0)
1582  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1583  				  .work (*pool.generate (block1->hash ()))
1584  				  .build ();
1585  	auto result2 = ledger.process (transaction, *block2);
1586  	ASSERT_EQ (nano::process_result::progress, result2.code);
1587  	auto block3 = builder
1588  				  .open ()
1589  				  .source (block1->hash ())
1590  				  .representative (1)
1591  				  .account (key1.pub)
1592  				  .sign (key1.prv, key1.pub)
1593  				  .work (*pool.generate (key1.pub))
1594  				  .build ();
1595  	auto result3 = ledger.process (transaction, *block3);
1596  	ASSERT_EQ (nano::process_result::progress, result3.code);
1597  	auto block4 = builder
1598  				  .receive ()
1599  				  .previous (block3->hash ())
1600  				  .source (1)
1601  				  .sign (key1.prv, key1.pub)
1602  				  .work (*pool.generate (block3->hash ()))
1603  				  .build ();
1604  	auto result4 = ledger.process (transaction, *block4);
1605  	ASSERT_EQ (nano::process_result::gap_source, result4.code);
1606  }
1607  TEST (ledger, fail_receive_overreceive)
1608  {
1609  	auto ctx = nano::test::context::ledger_empty ();
1610  	auto & ledger = ctx.ledger ();
1611  	auto & store = ctx.store ();
1612  	auto transaction = store.tx_begin_write ();
1613  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1614  	nano::keypair key1;
1615  	nano::block_builder builder;
1616  	auto block1 = builder
1617  				  .send ()
1618  				  .previous (nano::dev::genesis->hash ())
1619  				  .destination (key1.pub)
1620  				  .balance (1)
1621  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1622  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1623  				  .build ();
1624  	auto result1 = ledger.process (transaction, *block1);
1625  	ASSERT_EQ (nano::process_result::progress, result1.code);
1626  	auto block2 = builder
1627  				  .open ()
1628  				  .source (block1->hash ())
1629  				  .representative (1)
1630  				  .account (key1.pub)
1631  				  .sign (key1.prv, key1.pub)
1632  				  .work (*pool.generate (key1.pub))
1633  				  .build ();
1634  	auto result3 = ledger.process (transaction, *block2);
1635  	ASSERT_EQ (nano::process_result::progress, result3.code);
1636  	auto block3 = builder
1637  				  .receive ()
1638  				  .previous (block2->hash ())
1639  				  .source (block1->hash ())
1640  				  .sign (key1.prv, key1.pub)
1641  				  .work (*pool.generate (block2->hash ()))
1642  				  .build ();
1643  	auto result4 = ledger.process (transaction, *block3);
1644  	ASSERT_EQ (nano::process_result::unreceivable, result4.code);
1645  }
1646  TEST (ledger, fail_receive_bad_signature)
1647  {
1648  	auto ctx = nano::test::context::ledger_empty ();
1649  	auto & ledger = ctx.ledger ();
1650  	auto & store = ctx.store ();
1651  	auto transaction = store.tx_begin_write ();
1652  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1653  	nano::keypair key1;
1654  	nano::block_builder builder;
1655  	auto block1 = builder
1656  				  .send ()
1657  				  .previous (nano::dev::genesis->hash ())
1658  				  .destination (key1.pub)
1659  				  .balance (1)
1660  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1661  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1662  				  .build ();
1663  	auto result1 = ledger.process (transaction, *block1);
1664  	ASSERT_EQ (nano::process_result::progress, result1.code);
1665  	auto block2 = builder
1666  				  .send ()
1667  				  .previous (block1->hash ())
1668  				  .destination (key1.pub)
1669  				  .balance (0)
1670  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1671  				  .work (*pool.generate (block1->hash ()))
1672  				  .build ();
1673  	auto result2 = ledger.process (transaction, *block2);
1674  	ASSERT_EQ (nano::process_result::progress, result2.code);
1675  	auto block3 = builder
1676  				  .open ()
1677  				  .source (block1->hash ())
1678  				  .representative (1)
1679  				  .account (key1.pub)
1680  				  .sign (key1.prv, key1.pub)
1681  				  .work (*pool.generate (key1.pub))
1682  				  .build ();
1683  	auto result3 = ledger.process (transaction, *block3);
1684  	ASSERT_EQ (nano::process_result::progress, result3.code);
1685  	auto block4 = builder
1686  				  .receive ()
1687  				  .previous (block3->hash ())
1688  				  .source (block2->hash ())
1689  				  .sign (nano::keypair ().prv, 0)
1690  				  .work (*pool.generate (block3->hash ()))
1691  				  .build ();
1692  	auto result4 = ledger.process (transaction, *block4);
1693  	ASSERT_EQ (nano::process_result::bad_signature, result4.code);
1694  }
1695  TEST (ledger, fail_receive_gap_previous_opened)
1696  {
1697  	auto ctx = nano::test::context::ledger_empty ();
1698  	auto & ledger = ctx.ledger ();
1699  	auto & store = ctx.store ();
1700  	auto transaction = store.tx_begin_write ();
1701  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1702  	nano::keypair key1;
1703  	nano::block_builder builder;
1704  	auto block1 = builder
1705  				  .send ()
1706  				  .previous (nano::dev::genesis->hash ())
1707  				  .destination (key1.pub)
1708  				  .balance (1)
1709  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1710  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1711  				  .build ();
1712  	auto result1 = ledger.process (transaction, *block1);
1713  	ASSERT_EQ (nano::process_result::progress, result1.code);
1714  	auto block2 = builder
1715  				  .send ()
1716  				  .previous (block1->hash ())
1717  				  .destination (key1.pub)
1718  				  .balance (0)
1719  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1720  				  .work (*pool.generate (block1->hash ()))
1721  				  .build ();
1722  	auto result2 = ledger.process (transaction, *block2);
1723  	ASSERT_EQ (nano::process_result::progress, result2.code);
1724  	auto block3 = builder
1725  				  .open ()
1726  				  .source (block1->hash ())
1727  				  .representative (1)
1728  				  .account (key1.pub)
1729  				  .sign (key1.prv, key1.pub)
1730  				  .work (*pool.generate (key1.pub))
1731  				  .build ();
1732  	auto result3 = ledger.process (transaction, *block3);
1733  	ASSERT_EQ (nano::process_result::progress, result3.code);
1734  	auto block4 = builder
1735  				  .receive ()
1736  				  .previous (1)
1737  				  .source (block2->hash ())
1738  				  .sign (key1.prv, key1.pub)
1739  				  .work (*pool.generate (nano::root (1)))
1740  				  .build ();
1741  	auto result4 = ledger.process (transaction, *block4);
1742  	ASSERT_EQ (nano::process_result::gap_previous, result4.code);
1743  }
1744  TEST (ledger, fail_receive_gap_previous_unopened)
1745  {
1746  	auto ctx = nano::test::context::ledger_empty ();
1747  	auto & ledger = ctx.ledger ();
1748  	auto & store = ctx.store ();
1749  	auto transaction = store.tx_begin_write ();
1750  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1751  	nano::keypair key1;
1752  	nano::block_builder builder;
1753  	auto block1 = builder
1754  				  .send ()
1755  				  .previous (nano::dev::genesis->hash ())
1756  				  .destination (key1.pub)
1757  				  .balance (1)
1758  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1759  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1760  				  .build ();
1761  	auto result1 = ledger.process (transaction, *block1);
1762  	ASSERT_EQ (nano::process_result::progress, result1.code);
1763  	auto block2 = builder
1764  				  .send ()
1765  				  .previous (block1->hash ())
1766  				  .destination (key1.pub)
1767  				  .balance (0)
1768  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1769  				  .work (*pool.generate (block1->hash ()))
1770  				  .build ();
1771  	auto result2 = ledger.process (transaction, *block2);
1772  	ASSERT_EQ (nano::process_result::progress, result2.code);
1773  	auto block3 = builder
1774  				  .receive ()
1775  				  .previous (1)
1776  				  .source (block2->hash ())
1777  				  .sign (key1.prv, key1.pub)
1778  				  .work (*pool.generate (nano::root (1)))
1779  				  .build ();
1780  	auto result3 = ledger.process (transaction, *block3);
1781  	ASSERT_EQ (nano::process_result::gap_previous, result3.code);
1782  }
1783  TEST (ledger, fail_receive_fork_previous)
1784  {
1785  	auto ctx = nano::test::context::ledger_empty ();
1786  	auto & ledger = ctx.ledger ();
1787  	auto & store = ctx.store ();
1788  	auto transaction = store.tx_begin_write ();
1789  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1790  	nano::keypair key1;
1791  	nano::block_builder builder;
1792  	auto block1 = builder
1793  				  .send ()
1794  				  .previous (nano::dev::genesis->hash ())
1795  				  .destination (key1.pub)
1796  				  .balance (1)
1797  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1798  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1799  				  .build ();
1800  	auto result1 = ledger.process (transaction, *block1);
1801  	ASSERT_EQ (nano::process_result::progress, result1.code);
1802  	auto block2 = builder
1803  				  .send ()
1804  				  .previous (block1->hash ())
1805  				  .destination (key1.pub)
1806  				  .balance (0)
1807  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1808  				  .work (*pool.generate (block1->hash ()))
1809  				  .build ();
1810  	auto result2 = ledger.process (transaction, *block2);
1811  	ASSERT_EQ (nano::process_result::progress, result2.code);
1812  	auto block3 = builder
1813  				  .open ()
1814  				  .source (block1->hash ())
1815  				  .representative (1)
1816  				  .account (key1.pub)
1817  				  .sign (key1.prv, key1.pub)
1818  				  .work (*pool.generate (key1.pub))
1819  				  .build ();
1820  	auto result3 = ledger.process (transaction, *block3);
1821  	ASSERT_EQ (nano::process_result::progress, result3.code);
1822  	nano::keypair key2;
1823  	auto block4 = builder
1824  				  .send ()
1825  				  .previous (block3->hash ())
1826  				  .destination (key1.pub)
1827  				  .balance (1)
1828  				  .sign (key1.prv, key1.pub)
1829  				  .work (*pool.generate (block3->hash ()))
1830  				  .build ();
1831  	auto result4 = ledger.process (transaction, *block4);
1832  	ASSERT_EQ (nano::process_result::progress, result4.code);
1833  	auto block5 = builder
1834  				  .receive ()
1835  				  .previous (block3->hash ())
1836  				  .source (block2->hash ())
1837  				  .sign (key1.prv, key1.pub)
1838  				  .work (*pool.generate (block3->hash ()))
1839  				  .build ();
1840  	auto result5 = ledger.process (transaction, *block5);
1841  	ASSERT_EQ (nano::process_result::fork, result5.code);
1842  }
1843  TEST (ledger, fail_receive_received_source)
1844  {
1845  	auto ctx = nano::test::context::ledger_empty ();
1846  	auto & ledger = ctx.ledger ();
1847  	auto & store = ctx.store ();
1848  	auto transaction = store.tx_begin_write ();
1849  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1850  	nano::keypair key1;
1851  	nano::block_builder builder;
1852  	auto block1 = builder
1853  				  .send ()
1854  				  .previous (nano::dev::genesis->hash ())
1855  				  .destination (key1.pub)
1856  				  .balance (2)
1857  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1858  				  .work (*pool.generate (nano::dev::genesis->hash ()))
1859  				  .build ();
1860  	auto result1 = ledger.process (transaction, *block1);
1861  	ASSERT_EQ (nano::process_result::progress, result1.code);
1862  	auto block2 = builder
1863  				  .send ()
1864  				  .previous (block1->hash ())
1865  				  .destination (key1.pub)
1866  				  .balance (1)
1867  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1868  				  .work (*pool.generate (block1->hash ()))
1869  				  .build ();
1870  	auto result2 = ledger.process (transaction, *block2);
1871  	ASSERT_EQ (nano::process_result::progress, result2.code);
1872  	auto block6 = builder
1873  				  .send ()
1874  				  .previous (block2->hash ())
1875  				  .destination (key1.pub)
1876  				  .balance (0)
1877  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1878  				  .work (*pool.generate (block2->hash ()))
1879  				  .build ();
1880  	auto result6 = ledger.process (transaction, *block6);
1881  	ASSERT_EQ (nano::process_result::progress, result6.code);
1882  	auto block3 = builder
1883  				  .open ()
1884  				  .source (block1->hash ())
1885  				  .representative (1)
1886  				  .account (key1.pub)
1887  				  .sign (key1.prv, key1.pub)
1888  				  .work (*pool.generate (key1.pub))
1889  				  .build ();
1890  	auto result3 = ledger.process (transaction, *block3);
1891  	ASSERT_EQ (nano::process_result::progress, result3.code);
1892  	nano::keypair key2;
1893  	auto block4 = builder
1894  				  .send ()
1895  				  .previous (block3->hash ())
1896  				  .destination (key1.pub)
1897  				  .balance (1)
1898  				  .sign (key1.prv, key1.pub)
1899  				  .work (*pool.generate (block3->hash ()))
1900  				  .build ();
1901  	auto result4 = ledger.process (transaction, *block4);
1902  	ASSERT_EQ (nano::process_result::progress, result4.code);
1903  	auto block5 = builder
1904  				  .receive ()
1905  				  .previous (block4->hash ())
1906  				  .source (block2->hash ())
1907  				  .sign (key1.prv, key1.pub)
1908  				  .work (*pool.generate (block4->hash ()))
1909  				  .build ();
1910  	auto result5 = ledger.process (transaction, *block5);
1911  	ASSERT_EQ (nano::process_result::progress, result5.code);
1912  	auto block7 = builder
1913  				  .receive ()
1914  				  .previous (block3->hash ())
1915  				  .source (block2->hash ())
1916  				  .sign (key1.prv, key1.pub)
1917  				  .work (*pool.generate (block3->hash ()))
1918  				  .build ();
1919  	auto result7 = ledger.process (transaction, *block7);
1920  	ASSERT_EQ (nano::process_result::fork, result7.code);
1921  }
1922  TEST (ledger, latest_empty)
1923  {
1924  	auto ctx = nano::test::context::ledger_empty ();
1925  	auto & ledger = ctx.ledger ();
1926  	auto & store = ctx.store ();
1927  	nano::keypair key;
1928  	auto transaction = store.tx_begin_read ();
1929  	auto latest = ledger.latest (transaction, key.pub);
1930  	ASSERT_TRUE (latest.is_zero ());
1931  }
1932  TEST (ledger, latest_root)
1933  {
1934  	auto ctx = nano::test::context::ledger_empty ();
1935  	auto & ledger = ctx.ledger ();
1936  	auto & store = ctx.store ();
1937  	auto transaction = store.tx_begin_write ();
1938  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1939  	nano::keypair key;
1940  	ASSERT_EQ (key.pub, ledger.latest_root (transaction, key.pub).as_account ());
1941  	auto hash1 = ledger.latest (transaction, nano::dev::genesis_key.pub);
1942  	nano::block_builder builder;
1943  	auto send = builder
1944  				.send ()
1945  				.previous (hash1)
1946  				.destination (0)
1947  				.balance (1)
1948  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1949  				.work (*pool.generate (hash1))
1950  				.build ();
1951  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1952  	ASSERT_EQ (send->hash (), ledger.latest_root (transaction, nano::dev::genesis_key.pub).as_block_hash ());
1953  }
1954  TEST (ledger, change_representative_move_representation)
1955  {
1956  	auto ctx = nano::test::context::ledger_empty ();
1957  	auto & ledger = ctx.ledger ();
1958  	auto & store = ctx.store ();
1959  	nano::keypair key1;
1960  	auto transaction = store.tx_begin_write ();
1961  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1962  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis_key.pub));
1963  	nano::block_builder builder;
1964  	auto send = builder
1965  				.send ()
1966  				.previous (nano::dev::genesis->hash ())
1967  				.destination (key1.pub)
1968  				.balance (0)
1969  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1970  				.work (*pool.generate (nano::dev::genesis->hash ()))
1971  				.build ();
1972  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1973  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis_key.pub));
1974  	nano::keypair key2;
1975  	auto change = builder
1976  				  .change ()
1977  				  .previous (send->hash ())
1978  				  .representative (key2.pub)
1979  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1980  				  .work (*pool.generate (send->hash ()))
1981  				  .build ();
1982  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
1983  	nano::keypair key3;
1984  	auto open = builder
1985  				.open ()
1986  				.source (send->hash ())
1987  				.representative (key3.pub)
1988  				.account (key1.pub)
1989  				.sign (key1.prv, key1.pub)
1990  				.work (*pool.generate (key1.pub))
1991  				.build ();
1992  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1993  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (key3.pub));
1994  }
1995  TEST (ledger, send_open_receive_rollback)
1996  {
1997  	auto ctx = nano::test::context::ledger_empty ();
1998  	auto & ledger = ctx.ledger ();
1999  	auto & store = ctx.store ();
2000  	auto transaction = store.tx_begin_write ();
2001  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2002  	auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
2003  	ASSERT_TRUE (info1);
2004  	nano::keypair key1;
2005  	nano::block_builder builder;
2006  	auto send1 = builder
2007  				 .send ()
2008  				 .previous (info1->head)
2009  				 .destination (key1.pub)
2010  				 .balance (nano::dev::constants.genesis_amount - 50)
2011  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2012  				 .work (*pool.generate (info1->head))
2013  				 .build ();
2014  	auto return1 = ledger.process (transaction, *send1);
2015  	ASSERT_EQ (nano::process_result::progress, return1.code);
2016  	auto send2 = builder
2017  				 .send ()
2018  				 .previous (send1->hash ())
2019  				 .destination (key1.pub)
2020  				 .balance (nano::dev::constants.genesis_amount - 100)
2021  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2022  				 .work (*pool.generate (send1->hash ()))
2023  				 .build ();
2024  	auto return2 = ledger.process (transaction, *send2);
2025  	ASSERT_EQ (nano::process_result::progress, return2.code);
2026  	nano::keypair key2;
2027  	auto open = builder
2028  				.open ()
2029  				.source (send2->hash ())
2030  				.representative (key2.pub)
2031  				.account (key1.pub)
2032  				.sign (key1.prv, key1.pub)
2033  				.work (*pool.generate (key1.pub))
2034  				.build ();
2035  	auto return4 = ledger.process (transaction, *open);
2036  	ASSERT_EQ (nano::process_result::progress, return4.code);
2037  	auto receive = builder
2038  				   .receive ()
2039  				   .previous (open->hash ())
2040  				   .source (send1->hash ())
2041  				   .sign (key1.prv, key1.pub)
2042  				   .work (*pool.generate (open->hash ()))
2043  				   .build ();
2044  	auto return5 = ledger.process (transaction, *receive);
2045  	ASSERT_EQ (nano::process_result::progress, return5.code);
2046  	nano::keypair key3;
2047  	ASSERT_EQ (100, ledger.weight (key2.pub));
2048  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, ledger.weight (nano::dev::genesis_key.pub));
2049  	ASSERT_EQ (0, ledger.weight (key3.pub));
2050  	auto change1 = builder
2051  				   .change ()
2052  				   .previous (send2->hash ())
2053  				   .representative (key3.pub)
2054  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2055  				   .work (*pool.generate (send2->hash ()))
2056  				   .build ();
2057  	auto return6 = ledger.process (transaction, *change1);
2058  	ASSERT_EQ (nano::process_result::progress, return6.code);
2059  	ASSERT_EQ (100, ledger.weight (key2.pub));
2060  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis_key.pub));
2061  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, ledger.weight (key3.pub));
2062  	ASSERT_FALSE (ledger.rollback (transaction, receive->hash ()));
2063  	ASSERT_EQ (50, ledger.weight (key2.pub));
2064  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis_key.pub));
2065  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, ledger.weight (key3.pub));
2066  	ASSERT_FALSE (ledger.rollback (transaction, open->hash ()));
2067  	ASSERT_EQ (0, ledger.weight (key2.pub));
2068  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis_key.pub));
2069  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, ledger.weight (key3.pub));
2070  	ASSERT_FALSE (ledger.rollback (transaction, change1->hash ()));
2071  	ASSERT_EQ (0, ledger.weight (key2.pub));
2072  	ASSERT_EQ (0, ledger.weight (key3.pub));
2073  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, ledger.weight (nano::dev::genesis_key.pub));
2074  	ASSERT_FALSE (ledger.rollback (transaction, send2->hash ()));
2075  	ASSERT_EQ (0, ledger.weight (key2.pub));
2076  	ASSERT_EQ (0, ledger.weight (key3.pub));
2077  	ASSERT_EQ (nano::dev::constants.genesis_amount - 50, ledger.weight (nano::dev::genesis_key.pub));
2078  	ASSERT_FALSE (ledger.rollback (transaction, send1->hash ()));
2079  	ASSERT_EQ (0, ledger.weight (key2.pub));
2080  	ASSERT_EQ (0, ledger.weight (key3.pub));
2081  	ASSERT_EQ (nano::dev::constants.genesis_amount - 0, ledger.weight (nano::dev::genesis_key.pub));
2082  }
2083  TEST (ledger, bootstrap_rep_weight)
2084  {
2085  	auto ctx = nano::test::context::ledger_empty ();
2086  	auto & ledger = ctx.ledger ();
2087  	auto & store = ctx.store ();
2088  	nano::keypair key2;
2089  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2090  	{
2091  		auto transaction = store.tx_begin_write ();
2092  		auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
2093  		ASSERT_TRUE (info1);
2094  		nano::block_builder builder;
2095  		auto send = builder
2096  					.send ()
2097  					.previous (info1->head)
2098  					.destination (key2.pub)
2099  					.balance (std::numeric_limits<nano::uint128_t>::max () - 50)
2100  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2101  					.work (*pool.generate (info1->head))
2102  					.build ();
2103  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
2104  	}
2105  	ASSERT_EQ (2, ledger.cache.block_count);
2106  	{
2107  		ledger.bootstrap_weight_max_blocks = 3;
2108  		ledger.bootstrap_weights[key2.pub] = 1000;
2109  		ASSERT_EQ (1000, ledger.weight (key2.pub));
2110  	}
2111  	{
2112  		auto transaction = store.tx_begin_write ();
2113  		auto info1 = ledger.account_info (transaction, nano::dev::genesis_key.pub);
2114  		ASSERT_TRUE (info1);
2115  		nano::block_builder builder;
2116  		auto send = builder
2117  					.send ()
2118  					.previous (info1->head)
2119  					.destination (key2.pub)
2120  					.balance (std::numeric_limits<nano::uint128_t>::max () - 100)
2121  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2122  					.work (*pool.generate (info1->head))
2123  					.build ();
2124  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
2125  	}
2126  	ASSERT_EQ (3, ledger.cache.block_count);
2127  	ASSERT_EQ (0, ledger.weight (key2.pub));
2128  }
2129  TEST (ledger, block_destination_source)
2130  {
2131  	auto ctx = nano::test::context::ledger_empty ();
2132  	auto & ledger = ctx.ledger ();
2133  	auto & store = ctx.store ();
2134  	auto transaction = store.tx_begin_write ();
2135  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2136  	nano::keypair dest;
2137  	nano::uint128_t balance (nano::dev::constants.genesis_amount);
2138  	balance -= nano::Gxrb_ratio;
2139  	nano::block_builder builder;
2140  	auto block1 = builder
2141  				  .send ()
2142  				  .previous (nano::dev::genesis->hash ())
2143  				  .destination (dest.pub)
2144  				  .balance (balance)
2145  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2146  				  .work (*pool.generate (nano::dev::genesis->hash ()))
2147  				  .build ();
2148  	balance -= nano::Gxrb_ratio;
2149  	auto block2 = builder
2150  				  .send ()
2151  				  .previous (block1->hash ())
2152  				  .destination (nano::dev::genesis->account ())
2153  				  .balance (balance)
2154  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2155  				  .work (*pool.generate (block1->hash ()))
2156  				  .build ();
2157  	balance += nano::Gxrb_ratio;
2158  	auto block3 = builder
2159  				  .receive ()
2160  				  .previous (block2->hash ())
2161  				  .source (block2->hash ())
2162  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2163  				  .work (*pool.generate (block2->hash ()))
2164  				  .build ();
2165  	balance -= nano::Gxrb_ratio;
2166  	auto block4 = builder
2167  				  .state ()
2168  				  .account (nano::dev::genesis->account ())
2169  				  .previous (block3->hash ())
2170  				  .representative (nano::dev::genesis->account ())
2171  				  .balance (balance)
2172  				  .link (dest.pub)
2173  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2174  				  .work (*pool.generate (block3->hash ()))
2175  				  .build ();
2176  	balance -= nano::Gxrb_ratio;
2177  	auto block5 = builder
2178  				  .state ()
2179  				  .account (nano::dev::genesis->account ())
2180  				  .previous (block4->hash ())
2181  				  .representative (nano::dev::genesis->account ())
2182  				  .balance (balance)
2183  				  .link (nano::dev::genesis->account ())
2184  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2185  				  .work (*pool.generate (block4->hash ()))
2186  				  .build ();
2187  	balance += nano::Gxrb_ratio;
2188  	auto block6 = builder
2189  				  .state ()
2190  				  .account (nano::dev::genesis->account ())
2191  				  .previous (block5->hash ())
2192  				  .representative (nano::dev::genesis->account ())
2193  				  .balance (balance)
2194  				  .link (block5->hash ())
2195  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2196  				  .work (*pool.generate (block5->hash ()))
2197  				  .build ();
2198  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
2199  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
2200  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
2201  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block4).code);
2202  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block5).code);
2203  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block6).code);
2204  	ASSERT_EQ (balance, ledger.balance (transaction, block6->hash ()));
2205  	ASSERT_EQ (dest.pub, ledger.block_destination (transaction, *block1));
2206  	ASSERT_TRUE (ledger.block_source (transaction, *block1).is_zero ());
2207  	ASSERT_EQ (nano::dev::genesis->account (), ledger.block_destination (transaction, *block2));
2208  	ASSERT_TRUE (ledger.block_source (transaction, *block2).is_zero ());
2209  	ASSERT_TRUE (ledger.block_destination (transaction, *block3) == nullptr);
2210  	ASSERT_EQ (block2->hash (), ledger.block_source (transaction, *block3));
2211  	ASSERT_EQ (dest.pub, ledger.block_destination (transaction, *block4));
2212  	ASSERT_TRUE (ledger.block_source (transaction, *block4).is_zero ());
2213  	ASSERT_EQ (nano::dev::genesis->account (), ledger.block_destination (transaction, *block5));
2214  	ASSERT_TRUE (ledger.block_source (transaction, *block5).is_zero ());
2215  	ASSERT_TRUE (ledger.block_destination (transaction, *block6) == nullptr);
2216  	ASSERT_EQ (block5->hash (), ledger.block_source (transaction, *block6));
2217  }
2218  TEST (ledger, state_account)
2219  {
2220  	auto ctx = nano::test::context::ledger_empty ();
2221  	auto & ledger = ctx.ledger ();
2222  	auto & store = ctx.store ();
2223  	auto transaction = store.tx_begin_write ();
2224  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2225  	nano::block_builder builder;
2226  	auto send1 = builder
2227  				 .state ()
2228  				 .account (nano::dev::genesis->account ())
2229  				 .previous (nano::dev::genesis->hash ())
2230  				 .representative (nano::dev::genesis->account ())
2231  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2232  				 .link (nano::dev::genesis->account ())
2233  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2234  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2235  				 .build ();
2236  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2237  	ASSERT_EQ (nano::dev::genesis->account (), ledger.account (transaction, send1->hash ()));
2238  }
2239  TEST (ledger, state_send_receive)
2240  {
2241  	auto ctx = nano::test::context::ledger_empty ();
2242  	auto & ledger = ctx.ledger ();
2243  	auto & store = ctx.store ();
2244  	auto transaction = store.tx_begin_write ();
2245  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2246  	nano::block_builder builder;
2247  	auto send1 = builder
2248  				 .state ()
2249  				 .account (nano::dev::genesis->account ())
2250  				 .previous (nano::dev::genesis->hash ())
2251  				 .representative (nano::dev::genesis->account ())
2252  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2253  				 .link (nano::dev::genesis->account ())
2254  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2255  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2256  				 .build ();
2257  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2258  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2259  	auto send2 = store.block.get (transaction, send1->hash ());
2260  	ASSERT_NE (nullptr, send2);
2261  	ASSERT_EQ (*send1, *send2);
2262  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2263  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2264  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2265  	ASSERT_TRUE (store.pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
2266  	ASSERT_EQ (2, send2->sideband ().height);
2267  	ASSERT_TRUE (send2->sideband ().details.is_send);
2268  	ASSERT_FALSE (send2->sideband ().details.is_receive);
2269  	ASSERT_FALSE (send2->sideband ().details.is_epoch);
2270  	auto receive1 = builder
2271  					.state ()
2272  					.account (nano::dev::genesis->account ())
2273  					.previous (send1->hash ())
2274  					.representative (nano::dev::genesis->account ())
2275  					.balance (nano::dev::constants.genesis_amount)
2276  					.link (send1->hash ())
2277  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2278  					.work (*pool.generate (send1->hash ()))
2279  					.build ();
2280  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
2281  	ASSERT_TRUE (store.block.exists (transaction, receive1->hash ()));
2282  	auto receive2 = store.block.get (transaction, receive1->hash ());
2283  	ASSERT_NE (nullptr, receive2);
2284  	ASSERT_EQ (*receive1, *receive2);
2285  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.balance (transaction, receive1->hash ()));
2286  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, receive1->hash ()));
2287  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
2288  	ASSERT_FALSE (store.pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
2289  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
2290  	ASSERT_EQ (3, receive2->sideband ().height);
2291  	ASSERT_FALSE (receive2->sideband ().details.is_send);
2292  	ASSERT_TRUE (receive2->sideband ().details.is_receive);
2293  	ASSERT_FALSE (receive2->sideband ().details.is_epoch);
2294  }
2295  TEST (ledger, state_receive)
2296  {
2297  	auto ctx = nano::test::context::ledger_empty ();
2298  	auto & ledger = ctx.ledger ();
2299  	auto & store = ctx.store ();
2300  	auto transaction = store.tx_begin_write ();
2301  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2302  	nano::block_builder builder;
2303  	auto send1 = builder
2304  				 .send ()
2305  				 .previous (nano::dev::genesis->hash ())
2306  				 .destination (nano::dev::genesis->account ())
2307  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2308  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2309  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2310  				 .build ();
2311  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2312  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2313  	auto send2 = store.block.get (transaction, send1->hash ());
2314  	ASSERT_NE (nullptr, send2);
2315  	ASSERT_EQ (*send1, *send2);
2316  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2317  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2318  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2319  	auto receive1 = builder
2320  					.state ()
2321  					.account (nano::dev::genesis->account ())
2322  					.previous (send1->hash ())
2323  					.representative (nano::dev::genesis->account ())
2324  					.balance (nano::dev::constants.genesis_amount)
2325  					.link (send1->hash ())
2326  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2327  					.work (*pool.generate (send1->hash ()))
2328  					.build ();
2329  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
2330  	ASSERT_TRUE (store.block.exists (transaction, receive1->hash ()));
2331  	auto receive2 = store.block.get (transaction, receive1->hash ());
2332  	ASSERT_NE (nullptr, receive2);
2333  	ASSERT_EQ (*receive1, *receive2);
2334  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.balance (transaction, receive1->hash ()));
2335  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, receive1->hash ()));
2336  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
2337  	ASSERT_EQ (3, receive2->sideband ().height);
2338  	ASSERT_FALSE (receive2->sideband ().details.is_send);
2339  	ASSERT_TRUE (receive2->sideband ().details.is_receive);
2340  	ASSERT_FALSE (receive2->sideband ().details.is_epoch);
2341  }
2342  TEST (ledger, state_rep_change)
2343  {
2344  	auto ctx = nano::test::context::ledger_empty ();
2345  	auto & ledger = ctx.ledger ();
2346  	auto & store = ctx.store ();
2347  	auto transaction = store.tx_begin_write ();
2348  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2349  	nano::keypair rep;
2350  	nano::block_builder builder;
2351  	auto change1 = builder
2352  				   .state ()
2353  				   .account (nano::dev::genesis->account ())
2354  				   .previous (nano::dev::genesis->hash ())
2355  				   .representative (rep.pub)
2356  				   .balance (nano::dev::constants.genesis_amount)
2357  				   .link (0)
2358  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2359  				   .work (*pool.generate (nano::dev::genesis->hash ()))
2360  				   .build ();
2361  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change1).code);
2362  	ASSERT_TRUE (store.block.exists (transaction, change1->hash ()));
2363  	auto change2 = store.block.get (transaction, change1->hash ());
2364  	ASSERT_NE (nullptr, change2);
2365  	ASSERT_EQ (*change1, *change2);
2366  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.balance (transaction, change1->hash ()));
2367  	ASSERT_EQ (0, ledger.amount (transaction, change1->hash ()));
2368  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis->account ()));
2369  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (rep.pub));
2370  	ASSERT_EQ (2, change2->sideband ().height);
2371  	ASSERT_FALSE (change2->sideband ().details.is_send);
2372  	ASSERT_FALSE (change2->sideband ().details.is_receive);
2373  	ASSERT_FALSE (change2->sideband ().details.is_epoch);
2374  }
2375  TEST (ledger, state_open)
2376  {
2377  	auto ctx = nano::test::context::ledger_empty ();
2378  	auto & ledger = ctx.ledger ();
2379  	auto & store = ctx.store ();
2380  	auto transaction = store.tx_begin_write ();
2381  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2382  	nano::keypair destination;
2383  	nano::block_builder builder;
2384  	auto send1 = builder
2385  				 .state ()
2386  				 .account (nano::dev::genesis->account ())
2387  				 .previous (nano::dev::genesis->hash ())
2388  				 .representative (nano::dev::genesis->account ())
2389  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2390  				 .link (destination.pub)
2391  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2392  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2393  				 .build ();
2394  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2395  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2396  	auto send2 = store.block.get (transaction, send1->hash ());
2397  	ASSERT_NE (nullptr, send2);
2398  	ASSERT_EQ (*send1, *send2);
2399  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2400  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2401  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2402  	ASSERT_TRUE (store.pending.exists (transaction, nano::pending_key (destination.pub, send1->hash ())));
2403  	auto open1 = builder
2404  				 .state ()
2405  				 .account (destination.pub)
2406  				 .previous (0)
2407  				 .representative (nano::dev::genesis->account ())
2408  				 .balance (nano::Gxrb_ratio)
2409  				 .link (send1->hash ())
2410  				 .sign (destination.prv, destination.pub)
2411  				 .work (*pool.generate (destination.pub))
2412  				 .build ();
2413  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
2414  	ASSERT_FALSE (store.pending.exists (transaction, nano::pending_key (destination.pub, send1->hash ())));
2415  	ASSERT_TRUE (store.block.exists (transaction, open1->hash ()));
2416  	auto open2 = store.block.get (transaction, open1->hash ());
2417  	ASSERT_NE (nullptr, open2);
2418  	ASSERT_EQ (*open1, *open2);
2419  	ASSERT_EQ (nano::Gxrb_ratio, ledger.balance (transaction, open1->hash ()));
2420  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, open1->hash ()));
2421  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
2422  	ASSERT_EQ (ledger.cache.account_count, store.account.count (transaction));
2423  	ASSERT_EQ (1, open2->sideband ().height);
2424  	ASSERT_FALSE (open2->sideband ().details.is_send);
2425  	ASSERT_TRUE (open2->sideband ().details.is_receive);
2426  	ASSERT_FALSE (open2->sideband ().details.is_epoch);
2427  }
2428  TEST (ledger, send_after_state_fail)
2429  {
2430  	auto ctx = nano::test::context::ledger_empty ();
2431  	auto & ledger = ctx.ledger ();
2432  	auto & store = ctx.store ();
2433  	auto transaction = store.tx_begin_write ();
2434  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2435  	nano::block_builder builder;
2436  	auto send1 = builder
2437  				 .state ()
2438  				 .account (nano::dev::genesis->account ())
2439  				 .previous (nano::dev::genesis->hash ())
2440  				 .representative (nano::dev::genesis->account ())
2441  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2442  				 .link (nano::dev::genesis->account ())
2443  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2444  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2445  				 .build ();
2446  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2447  	auto send2 = builder
2448  				 .send ()
2449  				 .previous (send1->hash ())
2450  				 .destination (nano::dev::genesis->account ())
2451  				 .balance (nano::dev::constants.genesis_amount - (2 * nano::Gxrb_ratio))
2452  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2453  				 .work (*pool.generate (send1->hash ()))
2454  				 .build ();
2455  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *send2).code);
2456  }
2457  TEST (ledger, receive_after_state_fail)
2458  {
2459  	auto ctx = nano::test::context::ledger_empty ();
2460  	auto & ledger = ctx.ledger ();
2461  	auto & store = ctx.store ();
2462  	auto transaction = store.tx_begin_write ();
2463  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2464  	nano::block_builder builder;
2465  	auto send1 = builder
2466  				 .state ()
2467  				 .account (nano::dev::genesis->account ())
2468  				 .previous (nano::dev::genesis->hash ())
2469  				 .representative (nano::dev::genesis->account ())
2470  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2471  				 .link (nano::dev::genesis->account ())
2472  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2473  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2474  				 .build ();
2475  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2476  	auto receive1 = builder
2477  					.receive ()
2478  					.previous (send1->hash ())
2479  					.source (send1->hash ())
2480  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2481  					.work (*pool.generate (send1->hash ()))
2482  					.build ();
2483  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *receive1).code);
2484  }
2485  TEST (ledger, change_after_state_fail)
2486  {
2487  	auto ctx = nano::test::context::ledger_empty ();
2488  	auto & ledger = ctx.ledger ();
2489  	auto & store = ctx.store ();
2490  	auto transaction = store.tx_begin_write ();
2491  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2492  	nano::block_builder builder;
2493  	auto send1 = builder
2494  				 .state ()
2495  				 .account (nano::dev::genesis->account ())
2496  				 .previous (nano::dev::genesis->hash ())
2497  				 .representative (nano::dev::genesis->account ())
2498  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2499  				 .link (nano::dev::genesis->account ())
2500  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2501  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2502  				 .build ();
2503  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2504  	nano::keypair rep;
2505  	auto change1 = builder
2506  				   .change ()
2507  				   .previous (send1->hash ())
2508  				   .representative (rep.pub)
2509  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2510  				   .work (*pool.generate (send1->hash ()))
2511  				   .build ();
2512  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *change1).code);
2513  }
2514  TEST (ledger, state_unreceivable_fail)
2515  {
2516  	auto ctx = nano::test::context::ledger_empty ();
2517  	auto & ledger = ctx.ledger ();
2518  	auto & store = ctx.store ();
2519  	auto transaction = store.tx_begin_write ();
2520  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2521  	nano::block_builder builder;
2522  	auto send1 = builder
2523  				 .send ()
2524  				 .previous (nano::dev::genesis->hash ())
2525  				 .destination (nano::dev::genesis->account ())
2526  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2527  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2528  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2529  				 .build ();
2530  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2531  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2532  	auto send2 = store.block.get (transaction, send1->hash ());
2533  	ASSERT_NE (nullptr, send2);
2534  	ASSERT_EQ (*send1, *send2);
2535  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2536  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2537  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2538  	auto receive1 = builder
2539  					.state ()
2540  					.account (nano::dev::genesis->account ())
2541  					.previous (send1->hash ())
2542  					.representative (nano::dev::genesis->account ())
2543  					.balance (nano::dev::constants.genesis_amount)
2544  					.link (1)
2545  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2546  					.work (*pool.generate (send1->hash ()))
2547  					.build ();
2548  	ASSERT_EQ (nano::process_result::gap_source, ledger.process (transaction, *receive1).code);
2549  }
2550  TEST (ledger, state_receive_bad_amount_fail)
2551  {
2552  	auto ctx = nano::test::context::ledger_empty ();
2553  	auto & ledger = ctx.ledger ();
2554  	auto & store = ctx.store ();
2555  	auto transaction = store.tx_begin_write ();
2556  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2557  	nano::block_builder builder;
2558  	auto send1 = builder
2559  				 .send ()
2560  				 .previous (nano::dev::genesis->hash ())
2561  				 .destination (nano::dev::genesis->account ())
2562  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2563  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2564  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2565  				 .build ();
2566  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2567  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2568  	auto send2 = store.block.get (transaction, send1->hash ());
2569  	ASSERT_NE (nullptr, send2);
2570  	ASSERT_EQ (*send1, *send2);
2571  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2572  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2573  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2574  	auto receive1 = builder
2575  					.state ()
2576  					.account (nano::dev::genesis->account ())
2577  					.previous (send1->hash ())
2578  					.representative (nano::dev::genesis->account ())
2579  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2580  					.link (send1->hash ())
2581  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2582  					.work (*pool.generate (send1->hash ()))
2583  					.build ();
2584  	ASSERT_EQ (nano::process_result::balance_mismatch, ledger.process (transaction, *receive1).code);
2585  }
2586  TEST (ledger, state_no_link_amount_fail)
2587  {
2588  	auto ctx = nano::test::context::ledger_empty ();
2589  	auto & ledger = ctx.ledger ();
2590  	auto & store = ctx.store ();
2591  	auto transaction = store.tx_begin_write ();
2592  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2593  	nano::block_builder builder;
2594  	auto send1 = builder
2595  				 .state ()
2596  				 .account (nano::dev::genesis->account ())
2597  				 .previous (nano::dev::genesis->hash ())
2598  				 .representative (nano::dev::genesis->account ())
2599  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2600  				 .link (nano::dev::genesis->account ())
2601  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2602  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2603  				 .build ();
2604  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2605  	nano::keypair rep;
2606  	auto change1 = builder
2607  				   .state ()
2608  				   .account (nano::dev::genesis->account ())
2609  				   .previous (send1->hash ())
2610  				   .representative (rep.pub)
2611  				   .balance (nano::dev::constants.genesis_amount)
2612  				   .link (0)
2613  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2614  				   .work (*pool.generate (send1->hash ()))
2615  				   .build ();
2616  	ASSERT_EQ (nano::process_result::balance_mismatch, ledger.process (transaction, *change1).code);
2617  }
2618  TEST (ledger, state_receive_wrong_account_fail)
2619  {
2620  	auto ctx = nano::test::context::ledger_empty ();
2621  	auto & ledger = ctx.ledger ();
2622  	auto & store = ctx.store ();
2623  	auto transaction = store.tx_begin_write ();
2624  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2625  	nano::block_builder builder;
2626  	auto send1 = builder
2627  				 .state ()
2628  				 .account (nano::dev::genesis->account ())
2629  				 .previous (nano::dev::genesis->hash ())
2630  				 .representative (nano::dev::genesis->account ())
2631  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2632  				 .link (nano::dev::genesis->account ())
2633  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2634  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2635  				 .build ();
2636  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2637  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2638  	auto send2 = store.block.get (transaction, send1->hash ());
2639  	ASSERT_NE (nullptr, send2);
2640  	ASSERT_EQ (*send1, *send2);
2641  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2642  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2643  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2644  	nano::keypair key;
2645  	auto receive1 = builder
2646  					.state ()
2647  					.account (key.pub)
2648  					.previous (0)
2649  					.representative (nano::dev::genesis->account ())
2650  					.balance (nano::Gxrb_ratio)
2651  					.link (send1->hash ())
2652  					.sign (key.prv, key.pub)
2653  					.work (*pool.generate (key.pub))
2654  					.build ();
2655  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *receive1).code);
2656  }
2657  TEST (ledger, state_open_state_fork)
2658  {
2659  	auto ctx = nano::test::context::ledger_empty ();
2660  	auto & ledger = ctx.ledger ();
2661  	auto & store = ctx.store ();
2662  	auto transaction = store.tx_begin_write ();
2663  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2664  	nano::keypair destination;
2665  	nano::block_builder builder;
2666  	auto send1 = builder
2667  				 .state ()
2668  				 .account (nano::dev::genesis->account ())
2669  				 .previous (nano::dev::genesis->hash ())
2670  				 .representative (nano::dev::genesis->account ())
2671  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2672  				 .link (destination.pub)
2673  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2674  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2675  				 .build ();
2676  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2677  	auto open1 = builder
2678  				 .state ()
2679  				 .account (destination.pub)
2680  				 .previous (0)
2681  				 .representative (nano::dev::genesis->account ())
2682  				 .balance (nano::Gxrb_ratio)
2683  				 .link (send1->hash ())
2684  				 .sign (destination.prv, destination.pub)
2685  				 .work (*pool.generate (destination.pub))
2686  				 .build ();
2687  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
2688  	auto open2 = builder
2689  				 .open ()
2690  				 .source (send1->hash ())
2691  				 .representative (nano::dev::genesis->account ())
2692  				 .account (destination.pub)
2693  				 .sign (destination.prv, destination.pub)
2694  				 .work (*pool.generate (destination.pub))
2695  				 .build ();
2696  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *open2).code);
2697  	ASSERT_EQ (open1->root (), open2->root ());
2698  }
2699  TEST (ledger, state_state_open_fork)
2700  {
2701  	auto ctx = nano::test::context::ledger_empty ();
2702  	auto & ledger = ctx.ledger ();
2703  	auto & store = ctx.store ();
2704  	auto transaction = store.tx_begin_write ();
2705  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2706  	nano::keypair destination;
2707  	nano::block_builder builder;
2708  	auto send1 = builder
2709  				 .state ()
2710  				 .account (nano::dev::genesis->account ())
2711  				 .previous (nano::dev::genesis->hash ())
2712  				 .representative (nano::dev::genesis->account ())
2713  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2714  				 .link (destination.pub)
2715  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2716  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2717  				 .build ();
2718  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2719  	auto open1 = builder
2720  				 .open ()
2721  				 .source (send1->hash ())
2722  				 .representative (nano::dev::genesis->account ())
2723  				 .account (destination.pub)
2724  				 .sign (destination.prv, destination.pub)
2725  				 .work (*pool.generate (destination.pub))
2726  				 .build ();
2727  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
2728  	auto open2 = builder
2729  				 .state ()
2730  				 .account (destination.pub)
2731  				 .previous (0)
2732  				 .representative (nano::dev::genesis->account ())
2733  				 .balance (nano::Gxrb_ratio)
2734  				 .link (send1->hash ())
2735  				 .sign (destination.prv, destination.pub)
2736  				 .work (*pool.generate (destination.pub))
2737  				 .build ();
2738  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *open2).code);
2739  	ASSERT_EQ (open1->root (), open2->root ());
2740  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
2741  }
2742  TEST (ledger, state_open_previous_fail)
2743  {
2744  	auto ctx = nano::test::context::ledger_empty ();
2745  	auto & ledger = ctx.ledger ();
2746  	auto & store = ctx.store ();
2747  	auto transaction = store.tx_begin_write ();
2748  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2749  	nano::keypair destination;
2750  	nano::block_builder builder;
2751  	auto send1 = builder
2752  				 .state ()
2753  				 .account (nano::dev::genesis->account ())
2754  				 .previous (nano::dev::genesis->hash ())
2755  				 .representative (nano::dev::genesis->account ())
2756  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2757  				 .link (destination.pub)
2758  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2759  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2760  				 .build ();
2761  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2762  	auto open1 = builder
2763  				 .state ()
2764  				 .account (destination.pub)
2765  				 .previous (1)
2766  				 .representative (nano::dev::genesis->account ())
2767  				 .balance (nano::Gxrb_ratio)
2768  				 .link (send1->hash ())
2769  				 .sign (destination.prv, destination.pub)
2770  				 .work (*pool.generate (1))
2771  				 .build ();
2772  	ASSERT_EQ (nano::process_result::gap_previous, ledger.process (transaction, *open1).code);
2773  }
2774  TEST (ledger, state_open_source_fail)
2775  {
2776  	auto ctx = nano::test::context::ledger_empty ();
2777  	auto & ledger = ctx.ledger ();
2778  	auto & store = ctx.store ();
2779  	auto transaction = store.tx_begin_write ();
2780  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2781  	nano::keypair destination;
2782  	nano::block_builder builder;
2783  	auto send1 = builder
2784  				 .state ()
2785  				 .account (nano::dev::genesis->account ())
2786  				 .previous (nano::dev::genesis->hash ())
2787  				 .representative (nano::dev::genesis->account ())
2788  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2789  				 .link (destination.pub)
2790  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2791  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2792  				 .build ();
2793  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2794  	auto open1 = builder
2795  				 .state ()
2796  				 .account (destination.pub)
2797  				 .previous (0)
2798  				 .representative (nano::dev::genesis->account ())
2799  				 .balance (0)
2800  				 .link (0)
2801  				 .sign (destination.prv, destination.pub)
2802  				 .work (*pool.generate (destination.pub))
2803  				 .build ();
2804  	ASSERT_EQ (nano::process_result::gap_source, ledger.process (transaction, *open1).code);
2805  }
2806  TEST (ledger, state_send_change)
2807  {
2808  	auto ctx = nano::test::context::ledger_empty ();
2809  	auto & ledger = ctx.ledger ();
2810  	auto & store = ctx.store ();
2811  	auto transaction = store.tx_begin_write ();
2812  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2813  	nano::keypair rep;
2814  	nano::block_builder builder;
2815  	auto send1 = builder
2816  				 .state ()
2817  				 .account (nano::dev::genesis->account ())
2818  				 .previous (nano::dev::genesis->hash ())
2819  				 .representative (rep.pub)
2820  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2821  				 .link (nano::dev::genesis->account ())
2822  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2823  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2824  				 .build ();
2825  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2826  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2827  	auto send2 = store.block.get (transaction, send1->hash ());
2828  	ASSERT_NE (nullptr, send2);
2829  	ASSERT_EQ (*send1, *send2);
2830  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2831  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2832  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis->account ()));
2833  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (rep.pub));
2834  	ASSERT_EQ (2, send2->sideband ().height);
2835  	ASSERT_TRUE (send2->sideband ().details.is_send);
2836  	ASSERT_FALSE (send2->sideband ().details.is_receive);
2837  	ASSERT_FALSE (send2->sideband ().details.is_epoch);
2838  }
2839  TEST (ledger, state_receive_change)
2840  {
2841  	auto ctx = nano::test::context::ledger_empty ();
2842  	auto & ledger = ctx.ledger ();
2843  	auto & store = ctx.store ();
2844  	auto transaction = store.tx_begin_write ();
2845  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2846  	nano::block_builder builder;
2847  	auto send1 = builder
2848  				 .state ()
2849  				 .account (nano::dev::genesis->account ())
2850  				 .previous (nano::dev::genesis->hash ())
2851  				 .representative (nano::dev::genesis->account ())
2852  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2853  				 .link (nano::dev::genesis->account ())
2854  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2855  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2856  				 .build ();
2857  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2858  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2859  	auto send2 = store.block.get (transaction, send1->hash ());
2860  	ASSERT_NE (nullptr, send2);
2861  	ASSERT_EQ (*send1, *send2);
2862  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.balance (transaction, send1->hash ()));
2863  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, send1->hash ()));
2864  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
2865  	nano::keypair rep;
2866  	auto receive1 = builder
2867  					.state ()
2868  					.account (nano::dev::genesis->account ())
2869  					.previous (send1->hash ())
2870  					.representative (rep.pub)
2871  					.balance (nano::dev::constants.genesis_amount)
2872  					.link (send1->hash ())
2873  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2874  					.work (*pool.generate (send1->hash ()))
2875  					.build ();
2876  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
2877  	ASSERT_TRUE (store.block.exists (transaction, receive1->hash ()));
2878  	auto receive2 = store.block.get (transaction, receive1->hash ());
2879  	ASSERT_NE (nullptr, receive2);
2880  	ASSERT_EQ (*receive1, *receive2);
2881  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.balance (transaction, receive1->hash ()));
2882  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, receive1->hash ()));
2883  	ASSERT_EQ (0, ledger.weight (nano::dev::genesis->account ()));
2884  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (rep.pub));
2885  	ASSERT_EQ (3, receive2->sideband ().height);
2886  	ASSERT_FALSE (receive2->sideband ().details.is_send);
2887  	ASSERT_TRUE (receive2->sideband ().details.is_receive);
2888  	ASSERT_FALSE (receive2->sideband ().details.is_epoch);
2889  }
2890  TEST (ledger, state_open_old)
2891  {
2892  	auto ctx = nano::test::context::ledger_empty ();
2893  	auto & ledger = ctx.ledger ();
2894  	auto & store = ctx.store ();
2895  	auto transaction = store.tx_begin_write ();
2896  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2897  	nano::keypair destination;
2898  	nano::block_builder builder;
2899  	auto send1 = builder
2900  				 .state ()
2901  				 .account (nano::dev::genesis->account ())
2902  				 .previous (nano::dev::genesis->hash ())
2903  				 .representative (nano::dev::genesis->account ())
2904  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2905  				 .link (destination.pub)
2906  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2907  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2908  				 .build ();
2909  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2910  	auto open1 = builder
2911  				 .open ()
2912  				 .source (send1->hash ())
2913  				 .representative (nano::dev::genesis->account ())
2914  				 .account (destination.pub)
2915  				 .sign (destination.prv, destination.pub)
2916  				 .work (*pool.generate (destination.pub))
2917  				 .build ();
2918  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
2919  	ASSERT_EQ (nano::Gxrb_ratio, ledger.balance (transaction, open1->hash ()));
2920  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, open1->hash ()));
2921  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
2922  }
2923  TEST (ledger, state_receive_old)
2924  {
2925  	auto ctx = nano::test::context::ledger_empty ();
2926  	auto & ledger = ctx.ledger ();
2927  	auto & store = ctx.store ();
2928  	auto transaction = store.tx_begin_write ();
2929  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2930  	nano::keypair destination;
2931  	nano::block_builder builder;
2932  	auto send1 = builder
2933  				 .state ()
2934  				 .account (nano::dev::genesis->account ())
2935  				 .previous (nano::dev::genesis->hash ())
2936  				 .representative (nano::dev::genesis->account ())
2937  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2938  				 .link (destination.pub)
2939  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2940  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2941  				 .build ();
2942  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2943  	auto send2 = builder
2944  				 .state ()
2945  				 .account (nano::dev::genesis->account ())
2946  				 .previous (send1->hash ())
2947  				 .representative (nano::dev::genesis->account ())
2948  				 .balance (nano::dev::constants.genesis_amount - (2 * nano::Gxrb_ratio))
2949  				 .link (destination.pub)
2950  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2951  				 .work (*pool.generate (send1->hash ()))
2952  				 .build ();
2953  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
2954  	auto open1 = builder
2955  				 .open ()
2956  				 .source (send1->hash ())
2957  				 .representative (nano::dev::genesis->account ())
2958  				 .account (destination.pub)
2959  				 .sign (destination.prv, destination.pub)
2960  				 .work (*pool.generate (destination.pub))
2961  				 .build ();
2962  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
2963  	auto receive1 = builder
2964  					.receive ()
2965  					.previous (open1->hash ())
2966  					.source (send2->hash ())
2967  					.sign (destination.prv, destination.pub)
2968  					.work (*pool.generate (open1->hash ()))
2969  					.build ();
2970  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
2971  	ASSERT_EQ (2 * nano::Gxrb_ratio, ledger.balance (transaction, receive1->hash ()));
2972  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, receive1->hash ()));
2973  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
2974  }
2975  TEST (ledger, state_rollback_send)
2976  {
2977  	auto ctx = nano::test::context::ledger_empty ();
2978  	auto & ledger = ctx.ledger ();
2979  	auto & store = ctx.store ();
2980  	auto transaction = store.tx_begin_write ();
2981  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
2982  	nano::block_builder builder;
2983  	auto send1 = builder
2984  				 .state ()
2985  				 .account (nano::dev::genesis->account ())
2986  				 .previous (nano::dev::genesis->hash ())
2987  				 .representative (nano::dev::genesis->account ())
2988  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2989  				 .link (nano::dev::genesis->account ())
2990  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2991  				 .work (*pool.generate (nano::dev::genesis->hash ()))
2992  				 .build ();
2993  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
2994  	ASSERT_TRUE (store.block.exists (transaction, send1->hash ()));
2995  	auto send2 = store.block.get (transaction, send1->hash ());
2996  	ASSERT_NE (nullptr, send2);
2997  	ASSERT_EQ (*send1, *send2);
2998  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.account_balance (transaction, nano::dev::genesis->account ()));
2999  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
3000  	auto info = ledger.pending_info (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ()));
3001  	ASSERT_TRUE (info);
3002  	ASSERT_EQ (nano::dev::genesis->account (), info->source);
3003  	ASSERT_EQ (nano::Gxrb_ratio, info->amount.number ());
3004  	ASSERT_FALSE (ledger.rollback (transaction, send1->hash ()));
3005  	ASSERT_FALSE (store.block.exists (transaction, send1->hash ()));
3006  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.account_balance (transaction, nano::dev::genesis->account ()));
3007  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
3008  	ASSERT_FALSE (store.pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
3009  	ASSERT_TRUE (store.block.successor (transaction, nano::dev::genesis->hash ()).is_zero ());
3010  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3011  }
3012  TEST (ledger, state_rollback_receive)
3013  {
3014  	auto ctx = nano::test::context::ledger_empty ();
3015  	auto & ledger = ctx.ledger ();
3016  	auto & store = ctx.store ();
3017  	auto transaction = store.tx_begin_write ();
3018  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3019  	nano::block_builder builder;
3020  	auto send1 = builder
3021  				 .state ()
3022  				 .account (nano::dev::genesis->account ())
3023  				 .previous (nano::dev::genesis->hash ())
3024  				 .representative (nano::dev::genesis->account ())
3025  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3026  				 .link (nano::dev::genesis->account ())
3027  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3028  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3029  				 .build ();
3030  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3031  	auto receive1 = builder
3032  					.state ()
3033  					.account (nano::dev::genesis->account ())
3034  					.previous (send1->hash ())
3035  					.representative (nano::dev::genesis->account ())
3036  					.balance (nano::dev::constants.genesis_amount)
3037  					.link (send1->hash ())
3038  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3039  					.work (*pool.generate (send1->hash ()))
3040  					.build ();
3041  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
3042  	ASSERT_FALSE (store.pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), receive1->hash ())));
3043  	ASSERT_FALSE (ledger.rollback (transaction, receive1->hash ()));
3044  	auto info = ledger.pending_info (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ()));
3045  	ASSERT_TRUE (info);
3046  	ASSERT_EQ (nano::dev::genesis->account (), info->source);
3047  	ASSERT_EQ (nano::Gxrb_ratio, info->amount.number ());
3048  	ASSERT_FALSE (store.block.exists (transaction, receive1->hash ()));
3049  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.account_balance (transaction, nano::dev::genesis->account ()));
3050  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
3051  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3052  }
3053  TEST (ledger, state_rollback_received_send)
3054  {
3055  	auto ctx = nano::test::context::ledger_empty ();
3056  	auto & ledger = ctx.ledger ();
3057  	auto & store = ctx.store ();
3058  	auto transaction = store.tx_begin_write ();
3059  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3060  	nano::keypair key;
3061  	nano::block_builder builder;
3062  	auto send1 = builder
3063  				 .state ()
3064  				 .account (nano::dev::genesis->account ())
3065  				 .previous (nano::dev::genesis->hash ())
3066  				 .representative (nano::dev::genesis->account ())
3067  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3068  				 .link (key.pub)
3069  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3070  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3071  				 .build ();
3072  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3073  	auto receive1 = builder
3074  					.state ()
3075  					.account (key.pub)
3076  					.previous (0)
3077  					.representative (key.pub)
3078  					.balance (nano::Gxrb_ratio)
3079  					.link (send1->hash ())
3080  					.sign (key.prv, key.pub)
3081  					.work (*pool.generate (key.pub))
3082  					.build ();
3083  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
3084  	ASSERT_FALSE (store.pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), receive1->hash ())));
3085  	ASSERT_FALSE (ledger.rollback (transaction, send1->hash ()));
3086  	ASSERT_FALSE (store.pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
3087  	ASSERT_FALSE (store.block.exists (transaction, send1->hash ()));
3088  	ASSERT_FALSE (store.block.exists (transaction, receive1->hash ()));
3089  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.account_balance (transaction, nano::dev::genesis->account ()));
3090  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
3091  	ASSERT_EQ (0, ledger.account_balance (transaction, key.pub));
3092  	ASSERT_EQ (0, ledger.weight (key.pub));
3093  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3094  }
3095  TEST (ledger, state_rep_change_rollback)
3096  {
3097  	auto ctx = nano::test::context::ledger_empty ();
3098  	auto & ledger = ctx.ledger ();
3099  	auto & store = ctx.store ();
3100  	auto transaction = store.tx_begin_write ();
3101  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3102  	nano::keypair rep;
3103  	nano::block_builder builder;
3104  	auto change1 = builder
3105  				   .state ()
3106  				   .account (nano::dev::genesis->account ())
3107  				   .previous (nano::dev::genesis->hash ())
3108  				   .representative (rep.pub)
3109  				   .balance (nano::dev::constants.genesis_amount)
3110  				   .link (0)
3111  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3112  				   .work (*pool.generate (nano::dev::genesis->hash ()))
3113  				   .build ();
3114  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change1).code);
3115  	ASSERT_FALSE (ledger.rollback (transaction, change1->hash ()));
3116  	ASSERT_FALSE (store.block.exists (transaction, change1->hash ()));
3117  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.account_balance (transaction, nano::dev::genesis->account ()));
3118  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
3119  	ASSERT_EQ (0, ledger.weight (rep.pub));
3120  }
3121  TEST (ledger, state_open_rollback)
3122  {
3123  	auto ctx = nano::test::context::ledger_empty ();
3124  	auto & ledger = ctx.ledger ();
3125  	auto & store = ctx.store ();
3126  	auto transaction = store.tx_begin_write ();
3127  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3128  	nano::keypair destination;
3129  	nano::block_builder builder;
3130  	auto send1 = builder
3131  				 .state ()
3132  				 .account (nano::dev::genesis->account ())
3133  				 .previous (nano::dev::genesis->hash ())
3134  				 .representative (nano::dev::genesis->account ())
3135  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3136  				 .link (destination.pub)
3137  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3138  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3139  				 .build ();
3140  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3141  	auto open1 = builder
3142  				 .state ()
3143  				 .account (destination.pub)
3144  				 .previous (0)
3145  				 .representative (nano::dev::genesis->account ())
3146  				 .balance (nano::Gxrb_ratio)
3147  				 .link (send1->hash ())
3148  				 .sign (destination.prv, destination.pub)
3149  				 .work (*pool.generate (destination.pub))
3150  				 .build ();
3151  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
3152  	ASSERT_FALSE (ledger.rollback (transaction, open1->hash ()));
3153  	ASSERT_FALSE (store.block.exists (transaction, open1->hash ()));
3154  	ASSERT_EQ (0, ledger.account_balance (transaction, destination.pub));
3155  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
3156  	auto info = ledger.pending_info (transaction, nano::pending_key (destination.pub, send1->hash ()));
3157  	ASSERT_TRUE (info);
3158  	ASSERT_EQ (nano::dev::genesis->account (), info->source);
3159  	ASSERT_EQ (nano::Gxrb_ratio, info->amount.number ());
3160  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3161  }
3162  TEST (ledger, state_send_change_rollback)
3163  {
3164  	auto ctx = nano::test::context::ledger_empty ();
3165  	auto & ledger = ctx.ledger ();
3166  	auto & store = ctx.store ();
3167  	auto transaction = store.tx_begin_write ();
3168  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3169  	nano::keypair rep;
3170  	nano::block_builder builder;
3171  	auto send1 = builder
3172  				 .state ()
3173  				 .account (nano::dev::genesis->account ())
3174  				 .previous (nano::dev::genesis->hash ())
3175  				 .representative (rep.pub)
3176  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3177  				 .link (nano::dev::genesis->account ())
3178  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3179  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3180  				 .build ();
3181  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3182  	ASSERT_FALSE (ledger.rollback (transaction, send1->hash ()));
3183  	ASSERT_FALSE (store.block.exists (transaction, send1->hash ()));
3184  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.account_balance (transaction, nano::dev::genesis->account ()));
3185  	ASSERT_EQ (nano::dev::constants.genesis_amount, ledger.weight (nano::dev::genesis->account ()));
3186  	ASSERT_EQ (0, ledger.weight (rep.pub));
3187  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3188  }
3189  TEST (ledger, state_receive_change_rollback)
3190  {
3191  	auto ctx = nano::test::context::ledger_empty ();
3192  	auto & ledger = ctx.ledger ();
3193  	auto & store = ctx.store ();
3194  	auto transaction = store.tx_begin_write ();
3195  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3196  	nano::block_builder builder;
3197  	auto send1 = builder
3198  				 .state ()
3199  				 .account (nano::dev::genesis->account ())
3200  				 .previous (nano::dev::genesis->hash ())
3201  				 .representative (nano::dev::genesis->account ())
3202  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3203  				 .link (nano::dev::genesis->account ())
3204  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3205  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3206  				 .build ();
3207  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3208  	nano::keypair rep;
3209  	auto receive1 = builder
3210  					.state ()
3211  					.account (nano::dev::genesis->account ())
3212  					.previous (send1->hash ())
3213  					.representative (rep.pub)
3214  					.balance (nano::dev::constants.genesis_amount)
3215  					.link (send1->hash ())
3216  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3217  					.work (*pool.generate (send1->hash ()))
3218  					.build ();
3219  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
3220  	ASSERT_FALSE (ledger.rollback (transaction, receive1->hash ()));
3221  	ASSERT_FALSE (store.block.exists (transaction, receive1->hash ()));
3222  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.account_balance (transaction, nano::dev::genesis->account ()));
3223  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
3224  	ASSERT_EQ (0, ledger.weight (rep.pub));
3225  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3226  }
3227  TEST (ledger, epoch_blocks_v1_general)
3228  {
3229  	auto ctx = nano::test::context::ledger_empty ();
3230  	auto & ledger = ctx.ledger ();
3231  	auto & store = ctx.store ();
3232  	auto transaction = store.tx_begin_write ();
3233  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3234  	nano::keypair destination;
3235  	nano::block_builder builder;
3236  	auto epoch1 = builder
3237  				  .state ()
3238  				  .account (nano::dev::genesis->account ())
3239  				  .previous (nano::dev::genesis->hash ())
3240  				  .representative (nano::dev::genesis->account ())
3241  				  .balance (nano::dev::constants.genesis_amount)
3242  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3243  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3244  				  .work (*pool.generate (nano::dev::genesis->hash ()))
3245  				  .build ();
3246  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
3247  	ASSERT_FALSE (epoch1->sideband ().details.is_send);
3248  	ASSERT_FALSE (epoch1->sideband ().details.is_receive);
3249  	ASSERT_TRUE (epoch1->sideband ().details.is_epoch);
3250  	ASSERT_EQ (nano::epoch::epoch_1, epoch1->sideband ().details.epoch);
3251  	ASSERT_EQ (nano::epoch::epoch_0, epoch1->sideband ().source_epoch); 
3252  	auto epoch2 = builder
3253  				  .state ()
3254  				  .account (nano::dev::genesis->account ())
3255  				  .previous (epoch1->hash ())
3256  				  .representative (nano::dev::genesis->account ())
3257  				  .balance (nano::dev::constants.genesis_amount)
3258  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3259  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3260  				  .work (*pool.generate (epoch1->hash ()))
3261  				  .build ();
3262  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *epoch2).code);
3263  	auto genesis_info = ledger.account_info (transaction, nano::dev::genesis->account ());
3264  	ASSERT_TRUE (genesis_info);
3265  	ASSERT_EQ (genesis_info->epoch (), nano::epoch::epoch_1);
3266  	ASSERT_FALSE (ledger.rollback (transaction, epoch1->hash ()));
3267  	genesis_info = ledger.account_info (transaction, nano::dev::genesis->account ());
3268  	ASSERT_TRUE (genesis_info);
3269  	ASSERT_EQ (genesis_info->epoch (), nano::epoch::epoch_0);
3270  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
3271  	genesis_info = ledger.account_info (transaction, nano::dev::genesis->account ());
3272  	ASSERT_TRUE (genesis_info);
3273  	ASSERT_EQ (genesis_info->epoch (), nano::epoch::epoch_1);
3274  	ASSERT_FALSE (epoch1->sideband ().details.is_send);
3275  	ASSERT_FALSE (epoch1->sideband ().details.is_receive);
3276  	ASSERT_TRUE (epoch1->sideband ().details.is_epoch);
3277  	ASSERT_EQ (nano::epoch::epoch_1, epoch1->sideband ().details.epoch);
3278  	ASSERT_EQ (nano::epoch::epoch_0, epoch1->sideband ().source_epoch); 
3279  	auto change1 = builder
3280  				   .change ()
3281  				   .previous (epoch1->hash ())
3282  				   .representative (nano::dev::genesis->account ())
3283  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3284  				   .work (*pool.generate (epoch1->hash ()))
3285  				   .build ();
3286  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *change1).code);
3287  	auto send1 = builder
3288  				 .state ()
3289  				 .account (nano::dev::genesis->account ())
3290  				 .previous (epoch1->hash ())
3291  				 .representative (nano::dev::genesis->account ())
3292  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3293  				 .link (destination.pub)
3294  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3295  				 .work (*pool.generate (epoch1->hash ()))
3296  				 .build ();
3297  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3298  	ASSERT_TRUE (send1->sideband ().details.is_send);
3299  	ASSERT_FALSE (send1->sideband ().details.is_receive);
3300  	ASSERT_FALSE (send1->sideband ().details.is_epoch);
3301  	ASSERT_EQ (nano::epoch::epoch_1, send1->sideband ().details.epoch);
3302  	ASSERT_EQ (nano::epoch::epoch_0, send1->sideband ().source_epoch); 
3303  	auto open1 = builder
3304  				 .open ()
3305  				 .source (send1->hash ())
3306  				 .representative (nano::dev::genesis->account ())
3307  				 .account (destination.pub)
3308  				 .sign (destination.prv, destination.pub)
3309  				 .work (*pool.generate (destination.pub))
3310  				 .build ();
3311  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *open1).code);
3312  	auto epoch3 = builder
3313  				  .state ()
3314  				  .account (destination.pub)
3315  				  .previous (0)
3316  				  .representative (nano::dev::genesis->account ())
3317  				  .balance (0)
3318  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3319  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3320  				  .work (*pool.generate (destination.pub))
3321  				  .build ();
3322  	ASSERT_EQ (nano::process_result::representative_mismatch, ledger.process (transaction, *epoch3).code);
3323  	auto epoch4 = builder
3324  				  .state ()
3325  				  .account (destination.pub)
3326  				  .previous (0)
3327  				  .representative (0)
3328  				  .balance (0)
3329  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3330  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3331  				  .work (*pool.generate (destination.pub))
3332  				  .build ();
3333  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch4).code);
3334  	ASSERT_FALSE (epoch4->sideband ().details.is_send);
3335  	ASSERT_FALSE (epoch4->sideband ().details.is_receive);
3336  	ASSERT_TRUE (epoch4->sideband ().details.is_epoch);
3337  	ASSERT_EQ (nano::epoch::epoch_1, epoch4->sideband ().details.epoch);
3338  	ASSERT_EQ (nano::epoch::epoch_0, epoch4->sideband ().source_epoch); 
3339  	auto receive1 = builder
3340  					.receive ()
3341  					.previous (epoch4->hash ())
3342  					.source (send1->hash ())
3343  					.sign (destination.prv, destination.pub)
3344  					.work (*pool.generate (epoch4->hash ()))
3345  					.build ();
3346  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *receive1).code);
3347  	auto receive2 = builder
3348  					.state ()
3349  					.account (destination.pub)
3350  					.previous (epoch4->hash ())
3351  					.representative (destination.pub)
3352  					.balance (nano::Gxrb_ratio)
3353  					.link (send1->hash ())
3354  					.sign (destination.prv, destination.pub)
3355  					.work (*pool.generate (epoch4->hash ()))
3356  					.build ();
3357  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive2).code);
3358  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().details.epoch);
3359  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().source_epoch);
3360  	ASSERT_EQ (0, ledger.balance (transaction, epoch4->hash ()));
3361  	ASSERT_EQ (nano::Gxrb_ratio, ledger.balance (transaction, receive2->hash ()));
3362  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, receive2->hash ()));
3363  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
3364  	ASSERT_EQ (nano::Gxrb_ratio, ledger.weight (destination.pub));
3365  	ASSERT_FALSE (receive2->sideband ().details.is_send);
3366  	ASSERT_TRUE (receive2->sideband ().details.is_receive);
3367  	ASSERT_FALSE (receive2->sideband ().details.is_epoch);
3368  }
3369  TEST (ledger, epoch_blocks_v2_general)
3370  {
3371  	auto ctx = nano::test::context::ledger_empty ();
3372  	auto & ledger = ctx.ledger ();
3373  	auto & store = ctx.store ();
3374  	auto transaction = store.tx_begin_write ();
3375  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3376  	nano::keypair destination;
3377  	nano::block_builder builder;
3378  	auto epoch1 = builder
3379  				  .state ()
3380  				  .account (nano::dev::genesis->account ())
3381  				  .previous (nano::dev::genesis->hash ())
3382  				  .representative (nano::dev::genesis->account ())
3383  				  .balance (nano::dev::constants.genesis_amount)
3384  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3385  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3386  				  .work (*pool.generate (nano::dev::genesis->hash ()))
3387  				  .build ();
3388  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *epoch1).code);
3389  	epoch1 = builder
3390  			 .state ()
3391  			 .account (nano::dev::genesis->account ())
3392  			 .previous (nano::dev::genesis->hash ())
3393  			 .representative (nano::dev::genesis->account ())
3394  			 .balance (nano::dev::constants.genesis_amount)
3395  			 .link (ledger.epoch_link (nano::epoch::epoch_1))
3396  			 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3397  			 .work (epoch1->work)
3398  			 .build ();
3399  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
3400  	ASSERT_EQ (nano::epoch::epoch_1, epoch1->sideband ().details.epoch);
3401  	ASSERT_EQ (nano::epoch::epoch_0, epoch1->sideband ().source_epoch); 
3402  	auto epoch2 = builder
3403  				  .state ()
3404  				  .account (nano::dev::genesis->account ())
3405  				  .previous (epoch1->hash ())
3406  				  .representative (nano::dev::genesis->account ())
3407  				  .balance (nano::dev::constants.genesis_amount)
3408  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3409  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3410  				  .work (*pool.generate (epoch1->hash ()))
3411  				  .build ();
3412  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch2).code);
3413  	ASSERT_EQ (nano::epoch::epoch_2, epoch2->sideband ().details.epoch);
3414  	ASSERT_EQ (nano::epoch::epoch_0, epoch2->sideband ().source_epoch); 
3415  	auto epoch3 = builder
3416  				  .state ()
3417  				  .account (nano::dev::genesis->account ())
3418  				  .previous (epoch2->hash ())
3419  				  .representative (nano::dev::genesis->account ())
3420  				  .balance (nano::dev::constants.genesis_amount)
3421  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3422  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3423  				  .work (*pool.generate (epoch2->hash ()))
3424  				  .build ();
3425  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *epoch3).code);
3426  	auto genesis_info = ledger.account_info (transaction, nano::dev::genesis->account ());
3427  	ASSERT_TRUE (genesis_info);
3428  	ASSERT_EQ (genesis_info->epoch (), nano::epoch::epoch_2);
3429  	ASSERT_FALSE (ledger.rollback (transaction, epoch1->hash ()));
3430  	genesis_info = ledger.account_info (transaction, nano::dev::genesis->account ());
3431  	ASSERT_TRUE (genesis_info);
3432  	ASSERT_EQ (genesis_info->epoch (), nano::epoch::epoch_0);
3433  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
3434  	genesis_info = ledger.account_info (transaction, nano::dev::genesis->account ());
3435  	ASSERT_TRUE (genesis_info);
3436  	ASSERT_EQ (genesis_info->epoch (), nano::epoch::epoch_1);
3437  	auto change1 = builder
3438  				   .change ()
3439  				   .previous (epoch1->hash ())
3440  				   .representative (nano::dev::genesis->account ())
3441  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3442  				   .work (*pool.generate (epoch1->hash ()))
3443  				   .build ();
3444  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *change1).code);
3445  	auto send1 = builder
3446  				 .state ()
3447  				 .account (nano::dev::genesis->account ())
3448  				 .previous (epoch1->hash ())
3449  				 .representative (nano::dev::genesis->account ())
3450  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3451  				 .link (destination.pub)
3452  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3453  				 .work (*pool.generate (epoch1->hash ()))
3454  				 .build ();
3455  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3456  	ASSERT_EQ (nano::epoch::epoch_1, send1->sideband ().details.epoch);
3457  	ASSERT_EQ (nano::epoch::epoch_0, send1->sideband ().source_epoch); 
3458  	auto open1 = builder
3459  				 .open ()
3460  				 .source (send1->hash ())
3461  				 .representative (nano::dev::genesis->account ())
3462  				 .account (destination.pub)
3463  				 .sign (destination.prv, destination.pub)
3464  				 .work (*pool.generate (destination.pub))
3465  				 .build ();
3466  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *open1).code);
3467  	auto epoch4 = builder
3468  				  .state ()
3469  				  .account (destination.pub)
3470  				  .previous (0)
3471  				  .representative (0)
3472  				  .balance (0)
3473  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3474  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3475  				  .work (*pool.generate (destination.pub))
3476  				  .build ();
3477  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch4).code);
3478  	ASSERT_EQ (nano::epoch::epoch_1, epoch4->sideband ().details.epoch);
3479  	ASSERT_EQ (nano::epoch::epoch_0, epoch4->sideband ().source_epoch); 
3480  	auto epoch5 = builder
3481  				  .state ()
3482  				  .account (destination.pub)
3483  				  .previous (epoch4->hash ())
3484  				  .representative (nano::dev::genesis->account ())
3485  				  .balance (0)
3486  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3487  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3488  				  .work (*pool.generate (epoch4->hash ()))
3489  				  .build ();
3490  	ASSERT_EQ (nano::process_result::representative_mismatch, ledger.process (transaction, *epoch5).code);
3491  	auto epoch6 = builder
3492  				  .state ()
3493  				  .account (destination.pub)
3494  				  .previous (epoch4->hash ())
3495  				  .representative (0)
3496  				  .balance (0)
3497  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3498  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3499  				  .work (*pool.generate (epoch4->hash ()))
3500  				  .build ();
3501  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch6).code);
3502  	ASSERT_EQ (nano::epoch::epoch_2, epoch6->sideband ().details.epoch);
3503  	ASSERT_EQ (nano::epoch::epoch_0, epoch6->sideband ().source_epoch); 
3504  	auto receive1 = builder
3505  					.receive ()
3506  					.previous (epoch6->hash ())
3507  					.source (send1->hash ())
3508  					.sign (destination.prv, destination.pub)
3509  					.work (*pool.generate (epoch6->hash ()))
3510  					.build ();
3511  	ASSERT_EQ (nano::process_result::block_position, ledger.process (transaction, *receive1).code);
3512  	auto receive2 = builder
3513  					.state ()
3514  					.account (destination.pub)
3515  					.previous (epoch6->hash ())
3516  					.representative (destination.pub)
3517  					.balance (nano::Gxrb_ratio)
3518  					.link (send1->hash ())
3519  					.sign (destination.prv, destination.pub)
3520  					.work (*pool.generate (epoch6->hash ()))
3521  					.build ();
3522  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive2).code);
3523  	ASSERT_EQ (nano::epoch::epoch_2, receive2->sideband ().details.epoch);
3524  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().source_epoch);
3525  	ASSERT_EQ (0, ledger.balance (transaction, epoch6->hash ()));
3526  	ASSERT_EQ (nano::Gxrb_ratio, ledger.balance (transaction, receive2->hash ()));
3527  	ASSERT_EQ (nano::Gxrb_ratio, ledger.amount (transaction, receive2->hash ()));
3528  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, ledger.weight (nano::dev::genesis->account ()));
3529  	ASSERT_EQ (nano::Gxrb_ratio, ledger.weight (destination.pub));
3530  }
3531  TEST (ledger, epoch_blocks_receive_upgrade)
3532  {
3533  	auto ctx = nano::test::context::ledger_empty ();
3534  	auto & ledger = ctx.ledger ();
3535  	auto & store = ctx.store ();
3536  	auto transaction = store.tx_begin_write ();
3537  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3538  	nano::keypair destination;
3539  	nano::block_builder builder;
3540  	auto send1 = builder
3541  				 .state ()
3542  				 .account (nano::dev::genesis->account ())
3543  				 .previous (nano::dev::genesis->hash ())
3544  				 .representative (nano::dev::genesis->account ())
3545  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3546  				 .link (destination.pub)
3547  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3548  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3549  				 .build ();
3550  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3551  	auto epoch1 = builder
3552  				  .state ()
3553  				  .account (nano::dev::genesis->account ())
3554  				  .previous (send1->hash ())
3555  				  .representative (nano::dev::genesis->account ())
3556  				  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3557  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3558  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3559  				  .work (*pool.generate (send1->hash ()))
3560  				  .build ();
3561  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
3562  	auto send2 = builder
3563  				 .state ()
3564  				 .account (nano::dev::genesis->account ())
3565  				 .previous (epoch1->hash ())
3566  				 .representative (nano::dev::genesis->account ())
3567  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
3568  				 .link (destination.pub)
3569  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3570  				 .work (*pool.generate (epoch1->hash ()))
3571  				 .build ();
3572  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
3573  	ASSERT_EQ (nano::epoch::epoch_1, send2->sideband ().details.epoch);
3574  	ASSERT_EQ (nano::epoch::epoch_0, send2->sideband ().source_epoch); 
3575  	auto open1 = builder
3576  				 .open ()
3577  				 .source (send1->hash ())
3578  				 .representative (destination.pub)
3579  				 .account (destination.pub)
3580  				 .sign (destination.prv, destination.pub)
3581  				 .work (*pool.generate (destination.pub))
3582  				 .build ();
3583  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
3584  	ASSERT_EQ (nano::epoch::epoch_0, open1->sideband ().details.epoch);
3585  	ASSERT_EQ (nano::epoch::epoch_0, open1->sideband ().source_epoch);
3586  	auto receive1 = builder
3587  					.receive ()
3588  					.previous (open1->hash ())
3589  					.source (send2->hash ())
3590  					.sign (destination.prv, destination.pub)
3591  					.work (*pool.generate (open1->hash ()))
3592  					.build ();
3593  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *receive1).code);
3594  	auto receive2 = builder
3595  					.state ()
3596  					.account (destination.pub)
3597  					.previous (open1->hash ())
3598  					.representative (destination.pub)
3599  					.balance (nano::Gxrb_ratio * 2)
3600  					.link (send2->hash ())
3601  					.sign (destination.prv, destination.pub)
3602  					.work (*pool.generate (open1->hash ()))
3603  					.build ();
3604  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive2).code);
3605  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().details.epoch);
3606  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().source_epoch);
3607  	auto destination_info = ledger.account_info (transaction, destination.pub);
3608  	ASSERT_TRUE (destination_info);
3609  	ASSERT_EQ (destination_info->epoch (), nano::epoch::epoch_1);
3610  	ASSERT_FALSE (ledger.rollback (transaction, receive2->hash ()));
3611  	destination_info = ledger.account_info (transaction, destination.pub);
3612  	ASSERT_TRUE (destination_info);
3613  	ASSERT_EQ (destination_info->epoch (), nano::epoch::epoch_0);
3614  	auto pending_send2 = ledger.pending_info (transaction, nano::pending_key (destination.pub, send2->hash ()));
3615  	ASSERT_TRUE (pending_send2);
3616  	ASSERT_EQ (nano::dev::genesis_key.pub, pending_send2->source);
3617  	ASSERT_EQ (nano::Gxrb_ratio, pending_send2->amount.number ());
3618  	ASSERT_EQ (nano::epoch::epoch_1, pending_send2->epoch);
3619  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive2).code);
3620  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().details.epoch);
3621  	ASSERT_EQ (nano::epoch::epoch_1, receive2->sideband ().source_epoch);
3622  	destination_info = ledger.account_info (transaction, destination.pub);
3623  	ASSERT_TRUE (destination_info);
3624  	ASSERT_EQ (destination_info->epoch (), nano::epoch::epoch_1);
3625  	nano::keypair destination2;
3626  	auto send3 = builder
3627  				 .state ()
3628  				 .account (destination.pub)
3629  				 .previous (receive2->hash ())
3630  				 .representative (destination.pub)
3631  				 .balance (nano::Gxrb_ratio)
3632  				 .link (destination2.pub)
3633  				 .sign (destination.prv, destination.pub)
3634  				 .work (*pool.generate (receive2->hash ()))
3635  				 .build ();
3636  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send3).code);
3637  	auto open2 = builder
3638  				 .open ()
3639  				 .source (send3->hash ())
3640  				 .representative (destination2.pub)
3641  				 .account (destination2.pub)
3642  				 .sign (destination2.prv, destination2.pub)
3643  				 .work (*pool.generate (destination2.pub))
3644  				 .build ();
3645  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *open2).code);
3646  	nano::keypair destination3;
3647  	auto epoch2 = builder
3648  				  .state ()
3649  				  .account (nano::dev::genesis->account ())
3650  				  .previous (send2->hash ())
3651  				  .representative (nano::dev::genesis->account ())
3652  				  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
3653  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3654  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3655  				  .work (*pool.generate (send2->hash ()))
3656  				  .build ();
3657  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch2).code);
3658  	auto send4 = builder
3659  				 .state ()
3660  				 .account (nano::dev::genesis->account ())
3661  				 .previous (epoch2->hash ())
3662  				 .representative (nano::dev::genesis->account ())
3663  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 3)
3664  				 .link (destination3.pub)
3665  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3666  				 .work (*pool.generate (epoch2->hash ()))
3667  				 .build ();
3668  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send4).code);
3669  	auto open3 = builder
3670  				 .open ()
3671  				 .source (send4->hash ())
3672  				 .representative (destination3.pub)
3673  				 .account (destination3.pub)
3674  				 .sign (destination3.prv, destination3.pub)
3675  				 .work (*pool.generate (destination3.pub))
3676  				 .build ();
3677  	ASSERT_EQ (nano::process_result::unreceivable, ledger.process (transaction, *open3).code);
3678  	auto send5 = builder
3679  				 .state ()
3680  				 .account (nano::dev::genesis->account ())
3681  				 .previous (send4->hash ())
3682  				 .representative (nano::dev::genesis->account ())
3683  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 4)
3684  				 .link (destination.pub)
3685  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3686  				 .work (*pool.generate (send4->hash ()))
3687  				 .build ();
3688  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send5).code);
3689  	destination_info = ledger.account_info (transaction, destination.pub);
3690  	ASSERT_TRUE (destination_info);
3691  	ASSERT_EQ (destination_info->epoch (), nano::epoch::epoch_1);
3692  	auto receive3 = builder
3693  					.state ()
3694  					.account (destination.pub)
3695  					.previous (send3->hash ())
3696  					.representative (destination.pub)
3697  					.balance (nano::Gxrb_ratio * 2)
3698  					.link (send5->hash ())
3699  					.sign (destination.prv, destination.pub)
3700  					.work (*pool.generate (send3->hash ()))
3701  					.build ();
3702  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive3).code);
3703  	ASSERT_EQ (nano::epoch::epoch_2, receive3->sideband ().details.epoch);
3704  	ASSERT_EQ (nano::epoch::epoch_2, receive3->sideband ().source_epoch);
3705  	destination_info = ledger.account_info (transaction, destination.pub);
3706  	ASSERT_TRUE (destination_info);
3707  	ASSERT_EQ (destination_info->epoch (), nano::epoch::epoch_2);
3708  	nano::keypair destination4;
3709  	auto send6 = builder
3710  				 .state ()
3711  				 .account (nano::dev::genesis->account ())
3712  				 .previous (send5->hash ())
3713  				 .representative (nano::dev::genesis->account ())
3714  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 5)
3715  				 .link (destination4.pub)
3716  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3717  				 .work (*pool.generate (send5->hash ()))
3718  				 .build ();
3719  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send6).code);
3720  	auto epoch4 = builder
3721  				  .state ()
3722  				  .account (destination4.pub)
3723  				  .previous (0)
3724  				  .representative (0)
3725  				  .balance (0)
3726  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3727  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3728  				  .work (*pool.generate (destination4.pub))
3729  				  .build ();
3730  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch4).code);
3731  	ASSERT_EQ (nano::epoch::epoch_2, epoch4->sideband ().details.epoch);
3732  	ASSERT_EQ (nano::epoch::epoch_0, epoch4->sideband ().source_epoch); 
3733  	ASSERT_EQ (store.account.count (transaction), ledger.cache.account_count);
3734  }
3735  TEST (ledger, epoch_blocks_fork)
3736  {
3737  	auto ctx = nano::test::context::ledger_empty ();
3738  	auto & ledger = ctx.ledger ();
3739  	auto & store = ctx.store ();
3740  	auto transaction = store.tx_begin_write ();
3741  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3742  	nano::keypair destination;
3743  	nano::block_builder builder;
3744  	auto send1 = builder
3745  				 .send ()
3746  				 .previous (nano::dev::genesis->hash ())
3747  				 .destination (nano::account{})
3748  				 .balance (nano::dev::constants.genesis_amount)
3749  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3750  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3751  				 .build ();
3752  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
3753  	auto epoch1 = builder
3754  				  .state ()
3755  				  .account (nano::dev::genesis->account ())
3756  				  .previous (nano::dev::genesis->hash ())
3757  				  .representative (nano::dev::genesis->account ())
3758  				  .balance (nano::dev::constants.genesis_amount)
3759  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3760  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3761  				  .work (*pool.generate (nano::dev::genesis->hash ()))
3762  				  .build ();
3763  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *epoch1).code);
3764  	auto epoch2 = builder
3765  				  .state ()
3766  				  .account (nano::dev::genesis->account ())
3767  				  .previous (nano::dev::genesis->hash ())
3768  				  .representative (nano::dev::genesis->account ())
3769  				  .balance (nano::dev::constants.genesis_amount)
3770  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3771  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3772  				  .work (*pool.generate (nano::dev::genesis->hash ()))
3773  				  .build ();
3774  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *epoch2).code);
3775  	auto epoch3 = builder
3776  				  .state ()
3777  				  .account (nano::dev::genesis->account ())
3778  				  .previous (send1->hash ())
3779  				  .representative (nano::dev::genesis->account ())
3780  				  .balance (nano::dev::constants.genesis_amount)
3781  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
3782  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3783  				  .work (*pool.generate (send1->hash ()))
3784  				  .build ();
3785  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch3).code);
3786  	ASSERT_EQ (nano::epoch::epoch_1, epoch3->sideband ().details.epoch);
3787  	ASSERT_EQ (nano::epoch::epoch_0, epoch3->sideband ().source_epoch); 
3788  	auto epoch4 = builder
3789  				  .state ()
3790  				  .account (nano::dev::genesis->account ())
3791  				  .previous (send1->hash ())
3792  				  .representative (nano::dev::genesis->account ())
3793  				  .balance (nano::dev::constants.genesis_amount)
3794  				  .link (ledger.epoch_link (nano::epoch::epoch_2))
3795  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3796  				  .work (*pool.generate (send1->hash ()))
3797  				  .build ();
3798  	ASSERT_EQ (nano::process_result::fork, ledger.process (transaction, *epoch2).code);
3799  }
3800  TEST (ledger, successor_epoch)
3801  {
3802  	nano::test::system system (1);
3803  	auto & node1 (*system.nodes[0]);
3804  	nano::keypair key1;
3805  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3806  	nano::block_builder builder;
3807  	auto send1 = builder
3808  				 .send ()
3809  				 .previous (nano::dev::genesis->hash ())
3810  				 .destination (key1.pub)
3811  				 .balance (nano::dev::constants.genesis_amount - 1)
3812  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3813  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3814  				 .build ();
3815  	auto open = builder
3816  				.state ()
3817  				.account (key1.pub)
3818  				.previous (0)
3819  				.representative (key1.pub)
3820  				.balance (1)
3821  				.link (send1->hash ())
3822  				.sign (key1.prv, key1.pub)
3823  				.work (*pool.generate (key1.pub))
3824  				.build ();
3825  	auto change = builder
3826  				  .state ()
3827  				  .account (key1.pub)
3828  				  .previous (open->hash ())
3829  				  .representative (key1.pub)
3830  				  .balance (1)
3831  				  .link (0)
3832  				  .sign (key1.prv, key1.pub)
3833  				  .work (*pool.generate (open->hash ()))
3834  				  .build ();
3835  	auto open_hash = open->hash ();
3836  	auto send2 = builder
3837  				 .send ()
3838  				 .previous (send1->hash ())
3839  				 .destination (reinterpret_cast<nano::account const &> (open_hash))
3840  				 .balance (nano::dev::constants.genesis_amount - 2)
3841  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3842  				 .work (*pool.generate (send1->hash ()))
3843  				 .build ();
3844  	auto epoch_open = builder
3845  					  .state ()
3846  					  .account (reinterpret_cast<nano::account const &> (open_hash))
3847  					  .previous (0)
3848  					  .representative (0)
3849  					  .balance (0)
3850  					  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
3851  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3852  					  .work (*pool.generate (open->hash ()))
3853  					  .build ();
3854  	auto transaction (node1.store.tx_begin_write ());
3855  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send1).code);
3856  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *open).code);
3857  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *change).code);
3858  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *send2).code);
3859  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *epoch_open).code);
3860  	ASSERT_EQ (*change, *node1.ledger.successor (transaction, change->qualified_root ()));
3861  	ASSERT_EQ (*epoch_open, *node1.ledger.successor (transaction, epoch_open->qualified_root ()));
3862  	ASSERT_EQ (nano::epoch::epoch_1, epoch_open->sideband ().details.epoch);
3863  	ASSERT_EQ (nano::epoch::epoch_0, epoch_open->sideband ().source_epoch); 
3864  }
3865  TEST (ledger, epoch_open_pending)
3866  {
3867  	nano::block_builder builder{};
3868  	nano::test::system system{ 1 };
3869  	auto & node1 = *system.nodes[0];
3870  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3871  	nano::keypair key1{};
3872  	auto epoch_open = builder.state ()
3873  					  .account (key1.pub)
3874  					  .previous (0)
3875  					  .representative (0)
3876  					  .balance (0)
3877  					  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
3878  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3879  					  .work (*pool.generate (key1.pub))
3880  					  .build_shared ();
3881  	auto process_result = node1.ledger.process (node1.store.tx_begin_write (), *epoch_open);
3882  	ASSERT_EQ (nano::process_result::gap_epoch_open_pending, process_result.code);
3883  	node1.block_processor.add (epoch_open);
3884  	ASSERT_TIMELY (10s, 1 == node1.unchecked.count ());
3885  	ASSERT_FALSE (node1.ledger.block_or_pruned_exists (epoch_open->hash ()));
3886  	auto blocks = node1.unchecked.get (nano::hash_or_account (epoch_open->account ()).hash);
3887  	ASSERT_EQ (blocks.size (), 1);
3888  	ASSERT_EQ (blocks[0].block->full_hash (), epoch_open->full_hash ());
3889  	auto send1 = builder.state ()
3890  				 .account (nano::dev::genesis->account ())
3891  				 .previous (nano::dev::genesis->hash ())
3892  				 .representative (nano::dev::genesis->account ())
3893  				 .balance (nano::dev::constants.genesis_amount - 100)
3894  				 .link (key1.pub)
3895  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3896  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3897  				 .build_shared ();
3898  	node1.block_processor.add (send1);
3899  	ASSERT_TIMELY (10s, node1.ledger.block_or_pruned_exists (epoch_open->hash ()));
3900  }
3901  TEST (ledger, block_hash_account_conflict)
3902  {
3903  	nano::block_builder builder;
3904  	nano::test::system system (1);
3905  	auto & node1 (*system.nodes[0]);
3906  	nano::keypair key1;
3907  	nano::keypair key2;
3908  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3909  	auto send1 = builder.state ()
3910  				 .account (nano::dev::genesis->account ())
3911  				 .previous (nano::dev::genesis->hash ())
3912  				 .representative (nano::dev::genesis->account ())
3913  				 .balance (nano::dev::constants.genesis_amount - 100)
3914  				 .link (key1.pub)
3915  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3916  				 .work (*pool.generate (nano::dev::genesis->hash ()))
3917  				 .build_shared ();
3918  	auto receive1 = builder.state ()
3919  					.account (key1.pub)
3920  					.previous (0)
3921  					.representative (nano::dev::genesis->account ())
3922  					.balance (100)
3923  					.link (send1->hash ())
3924  					.sign (key1.prv, key1.pub)
3925  					.work (*pool.generate (key1.pub))
3926  					.build_shared ();
3927  	auto send2 = builder.state ()
3928  				 .account (key1.pub)
3929  				 .previous (receive1->hash ())
3930  				 .representative (nano::dev::genesis->account ())
3931  				 .balance (90)
3932  				 .link (receive1->hash ())
3933  				 .sign (key1.prv, key1.pub)
3934  				 .work (*pool.generate (receive1->hash ()))
3935  				 .build_shared ();
3936  	auto receive1_hash = receive1->hash ();
3937  	auto open_epoch1 = builder.state ()
3938  					   .account (reinterpret_cast<nano::account const &> (receive1_hash))
3939  					   .previous (0)
3940  					   .representative (0)
3941  					   .balance (0)
3942  					   .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
3943  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3944  					   .work (*pool.generate (receive1->hash ()))
3945  					   .build_shared ();
3946  	node1.work_generate_blocking (*send1);
3947  	node1.work_generate_blocking (*receive1);
3948  	node1.work_generate_blocking (*send2);
3949  	node1.work_generate_blocking (*open_epoch1);
3950  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
3951  	ASSERT_EQ (nano::process_result::progress, node1.process (*receive1).code);
3952  	ASSERT_EQ (nano::process_result::progress, node1.process (*send2).code);
3953  	ASSERT_EQ (nano::process_result::progress, node1.process (*open_epoch1).code);
3954  	nano::test::start_elections (system, node1, { send1, receive1, send2, open_epoch1 });
3955  	auto election1 = node1.active.election (send1->qualified_root ());
3956  	ASSERT_NE (nullptr, election1);
3957  	auto election2 = node1.active.election (receive1->qualified_root ());
3958  	ASSERT_NE (nullptr, election2);
3959  	auto election3 = node1.active.election (send2->qualified_root ());
3960  	ASSERT_NE (nullptr, election3);
3961  	auto election4 = node1.active.election (open_epoch1->qualified_root ());
3962  	ASSERT_NE (nullptr, election4);
3963  	auto winner1 (election1->winner ());
3964  	auto winner2 (election2->winner ());
3965  	auto winner3 (election3->winner ());
3966  	auto winner4 (election4->winner ());
3967  	ASSERT_EQ (*send1, *winner1);
3968  	ASSERT_EQ (*receive1, *winner2);
3969  	ASSERT_EQ (*send2, *winner3);
3970  	ASSERT_EQ (*open_epoch1, *winner4);
3971  }
3972  TEST (ledger, could_fit)
3973  {
3974  	nano::logger_mt logger;
3975  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
3976  	ASSERT_TRUE (!store->init_error ());
3977  	nano::stats stats;
3978  	nano::ledger ledger (*store, stats, nano::dev::constants);
3979  	auto transaction (store->tx_begin_write ());
3980  	store->initialize (transaction, ledger.cache, ledger.constants);
3981  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
3982  	nano::keypair destination;
3983  	nano::block_builder builder;
3984  	auto change1 = builder
3985  				   .change ()
3986  				   .previous (nano::dev::genesis->hash ())
3987  				   .representative (nano::dev::genesis->account ())
3988  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3989  				   .work (*pool.generate (nano::dev::genesis->hash ()))
3990  				   .build ();
3991  	auto change2 = builder
3992  				   .state ()
3993  				   .account (nano::dev::genesis->account ())
3994  				   .previous (nano::dev::genesis->hash ())
3995  				   .representative (nano::dev::genesis->account ())
3996  				   .balance (nano::dev::constants.genesis_amount)
3997  				   .link (0)
3998  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3999  				   .work (*pool.generate (nano::dev::genesis->hash ()))
4000  				   .build ();
4001  	ASSERT_TRUE (ledger.could_fit (transaction, *change1));
4002  	ASSERT_TRUE (ledger.could_fit (transaction, *change2));
4003  	nano::keypair key1;
4004  	auto send1 = builder
4005  				 .send ()
4006  				 .previous (change1->hash ())
4007  				 .destination (key1.pub)
4008  				 .balance (nano::dev::constants.genesis_amount - 1)
4009  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4010  				 .work (*pool.generate (change1->hash ()))
4011  				 .build ();
4012  	auto send2 = builder
4013  				 .state ()
4014  				 .account (nano::dev::genesis->account ())
4015  				 .previous (change1->hash ())
4016  				 .representative (nano::dev::genesis->account ())
4017  				 .balance (nano::dev::constants.genesis_amount - 1)
4018  				 .link (key1.pub)
4019  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4020  				 .work (*pool.generate (change1->hash ()))
4021  				 .build ();
4022  	ASSERT_FALSE (ledger.could_fit (transaction, *send1));
4023  	ASSERT_FALSE (ledger.could_fit (transaction, *send2));
4024  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change1).code);
4025  	ASSERT_TRUE (ledger.could_fit (transaction, *change1));
4026  	ASSERT_TRUE (ledger.could_fit (transaction, *change2));
4027  	ASSERT_TRUE (ledger.could_fit (transaction, *send1));
4028  	ASSERT_TRUE (ledger.could_fit (transaction, *send2));
4029  	auto open1 = builder
4030  				 .open ()
4031  				 .source (send2->hash ())
4032  				 .representative (nano::dev::genesis->account ())
4033  				 .account (key1.pub)
4034  				 .sign (key1.prv, key1.pub)
4035  				 .work (*pool.generate (key1.pub))
4036  				 .build ();
4037  	auto open2 = builder
4038  				 .state ()
4039  				 .account (key1.pub)
4040  				 .previous (0)
4041  				 .representative (nano::dev::genesis->account ())
4042  				 .balance (1)
4043  				 .link (send2->hash ())
4044  				 .sign (key1.prv, key1.pub)
4045  				 .work (*pool.generate (key1.pub))
4046  				 .build ();
4047  	ASSERT_FALSE (ledger.could_fit (transaction, *open1));
4048  	ASSERT_FALSE (ledger.could_fit (transaction, *open2));
4049  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
4050  	ASSERT_TRUE (ledger.could_fit (transaction, *send1));
4051  	ASSERT_TRUE (ledger.could_fit (transaction, *send2));
4052  	ASSERT_TRUE (ledger.could_fit (transaction, *open1));
4053  	ASSERT_TRUE (ledger.could_fit (transaction, *open2));
4054  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
4055  	ASSERT_TRUE (ledger.could_fit (transaction, *open1));
4056  	ASSERT_TRUE (ledger.could_fit (transaction, *open2));
4057  	auto send3 = builder
4058  				 .state ()
4059  				 .account (nano::dev::genesis->account ())
4060  				 .previous (send2->hash ())
4061  				 .representative (nano::dev::genesis->account ())
4062  				 .balance (nano::dev::constants.genesis_amount - 2)
4063  				 .link (key1.pub)
4064  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4065  				 .work (*pool.generate (send2->hash ()))
4066  				 .build ();
4067  	auto receive1 = builder
4068  					.receive ()
4069  					.previous (open1->hash ())
4070  					.source (send3->hash ())
4071  					.sign (key1.prv, key1.pub)
4072  					.work (*pool.generate (open1->hash ()))
4073  					.build ();
4074  	auto receive2 = builder
4075  					.state ()
4076  					.account (key1.pub)
4077  					.previous (open1->hash ())
4078  					.representative (nano::dev::genesis->account ())
4079  					.balance (2)
4080  					.link (send3->hash ())
4081  					.sign (key1.prv, key1.pub)
4082  					.work (*pool.generate (open1->hash ()))
4083  					.build ();
4084  	ASSERT_FALSE (ledger.could_fit (transaction, *receive1));
4085  	ASSERT_FALSE (ledger.could_fit (transaction, *receive2));
4086  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send3).code);
4087  	ASSERT_TRUE (ledger.could_fit (transaction, *receive1));
4088  	ASSERT_TRUE (ledger.could_fit (transaction, *receive2));
4089  	auto epoch1 = builder
4090  				  .state ()
4091  				  .account (key1.pub)
4092  				  .previous (receive1->hash ())
4093  				  .representative (nano::dev::genesis->account ())
4094  				  .balance (2)
4095  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
4096  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4097  				  .work (*pool.generate (receive1->hash ()))
4098  				  .build ();
4099  	ASSERT_FALSE (ledger.could_fit (transaction, *epoch1));
4100  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
4101  	ASSERT_TRUE (ledger.could_fit (transaction, *receive1));
4102  	ASSERT_TRUE (ledger.could_fit (transaction, *receive2));
4103  	ASSERT_TRUE (ledger.could_fit (transaction, *epoch1));
4104  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
4105  	ASSERT_TRUE (ledger.could_fit (transaction, *epoch1));
4106  }
4107  TEST (ledger, unchecked_epoch)
4108  {
4109  	nano::test::system system (1);
4110  	auto & node1 (*system.nodes[0]);
4111  	nano::keypair destination;
4112  	nano::block_builder builder;
4113  	auto send1 = builder
4114  				 .state ()
4115  				 .account (nano::dev::genesis->account ())
4116  				 .previous (nano::dev::genesis->hash ())
4117  				 .representative (nano::dev::genesis->account ())
4118  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4119  				 .link (destination.pub)
4120  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4121  				 .work (0)
4122  				 .build_shared ();
4123  	node1.work_generate_blocking (*send1);
4124  	auto open1 = builder
4125  				 .state ()
4126  				 .account (destination.pub)
4127  				 .previous (0)
4128  				 .representative (destination.pub)
4129  				 .balance (nano::Gxrb_ratio)
4130  				 .link (send1->hash ())
4131  				 .sign (destination.prv, destination.pub)
4132  				 .work (0)
4133  				 .build_shared ();
4134  	node1.work_generate_blocking (*open1);
4135  	auto epoch1 = builder
4136  				  .state ()
4137  				  .account (destination.pub)
4138  				  .previous (open1->hash ())
4139  				  .representative (destination.pub)
4140  				  .balance (nano::Gxrb_ratio)
4141  				  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
4142  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4143  				  .work (0)
4144  				  .build_shared ();
4145  	node1.work_generate_blocking (*epoch1);
4146  	node1.block_processor.add (epoch1);
4147  	{
4148  		ASSERT_TIMELY (10s, 1 == node1.unchecked.count ());
4149  		auto blocks = node1.unchecked.get (epoch1->previous ());
4150  		ASSERT_EQ (blocks.size (), 1);
4151  	}
4152  	node1.block_processor.add (send1);
4153  	node1.block_processor.add (open1);
4154  	ASSERT_TIMELY (5s, node1.store.block.exists (node1.store.tx_begin_read (), epoch1->hash ()));
4155  	{
4156  		ASSERT_TIMELY (10s, 0 == node1.unchecked.count ());
4157  		auto info = node1.ledger.account_info (node1.store.tx_begin_read (), destination.pub);
4158  		ASSERT_TRUE (info);
4159  		ASSERT_EQ (info->epoch (), nano::epoch::epoch_1);
4160  	}
4161  }
4162  TEST (ledger, unchecked_epoch_invalid)
4163  {
4164  	nano::test::system system;
4165  	nano::node_config node_config = system.default_config ();
4166  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
4167  	auto & node1 (*system.add_node (node_config));
4168  	nano::keypair destination;
4169  	nano::block_builder builder;
4170  	auto send1 = builder
4171  				 .state ()
4172  				 .account (nano::dev::genesis->account ())
4173  				 .previous (nano::dev::genesis->hash ())
4174  				 .representative (nano::dev::genesis->account ())
4175  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4176  				 .link (destination.pub)
4177  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4178  				 .work (0)
4179  				 .build_shared ();
4180  	node1.work_generate_blocking (*send1);
4181  	auto open1 = builder
4182  				 .state ()
4183  				 .account (destination.pub)
4184  				 .previous (0)
4185  				 .representative (destination.pub)
4186  				 .balance (nano::Gxrb_ratio)
4187  				 .link (send1->hash ())
4188  				 .sign (destination.prv, destination.pub)
4189  				 .work (0)
4190  				 .build_shared ();
4191  	node1.work_generate_blocking (*open1);
4192  	auto epoch1 = builder
4193  				  .state ()
4194  				  .account (destination.pub)
4195  				  .previous (open1->hash ())
4196  				  .representative (destination.pub)
4197  				  .balance (nano::Gxrb_ratio)
4198  				  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
4199  				  .sign (destination.prv, destination.pub)
4200  				  .work (0)
4201  				  .build_shared ();
4202  	node1.work_generate_blocking (*epoch1);
4203  	auto epoch2 = builder
4204  				  .state ()
4205  				  .account (destination.pub)
4206  				  .previous (open1->hash ())
4207  				  .representative (destination.pub)
4208  				  .balance (nano::Gxrb_ratio - 1)
4209  				  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
4210  				  .sign (destination.prv, destination.pub)
4211  				  .work (0)
4212  				  .build_shared ();
4213  	node1.work_generate_blocking (*epoch2);
4214  	node1.block_processor.add (epoch1);
4215  	node1.block_processor.add (epoch2);
4216  	{
4217  		ASSERT_TIMELY (10s, 2 == node1.unchecked.count ());
4218  		auto blocks = node1.unchecked.get (epoch1->previous ());
4219  		ASSERT_EQ (blocks.size (), 2);
4220  	}
4221  	node1.block_processor.add (send1);
4222  	node1.block_processor.add (open1);
4223  	ASSERT_TIMELY (10s, node1.store.block.exists (node1.store.tx_begin_read (), epoch2->hash ()));
4224  	{
4225  		auto transaction = node1.store.tx_begin_read ();
4226  		ASSERT_FALSE (node1.store.block.exists (transaction, epoch1->hash ()));
4227  		auto unchecked_count = node1.unchecked.count ();
4228  		ASSERT_EQ (unchecked_count, 0);
4229  		ASSERT_EQ (unchecked_count, node1.unchecked.count ());
4230  		auto info = node1.ledger.account_info (transaction, destination.pub);
4231  		ASSERT_TRUE (info);
4232  		ASSERT_NE (info->epoch (), nano::epoch::epoch_1);
4233  		auto epoch2_store = node1.store.block.get (transaction, epoch2->hash ());
4234  		ASSERT_NE (nullptr, epoch2_store);
4235  		ASSERT_EQ (nano::epoch::epoch_0, epoch2_store->sideband ().details.epoch);
4236  		ASSERT_TRUE (epoch2_store->sideband ().details.is_send);
4237  		ASSERT_FALSE (epoch2_store->sideband ().details.is_epoch);
4238  		ASSERT_FALSE (epoch2_store->sideband ().details.is_receive);
4239  	}
4240  }
4241  TEST (ledger, unchecked_open)
4242  {
4243  	nano::test::system system (1);
4244  	auto & node1 (*system.nodes[0]);
4245  	nano::keypair destination;
4246  	nano::block_builder builder;
4247  	auto send1 = builder
4248  				 .state ()
4249  				 .account (nano::dev::genesis->account ())
4250  				 .previous (nano::dev::genesis->hash ())
4251  				 .representative (nano::dev::genesis->account ())
4252  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4253  				 .link (destination.pub)
4254  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4255  				 .work (0)
4256  				 .build_shared ();
4257  	node1.work_generate_blocking (*send1);
4258  	auto open1 = builder
4259  				 .open ()
4260  				 .source (send1->hash ())
4261  				 .representative (destination.pub)
4262  				 .account (destination.pub)
4263  				 .sign (destination.prv, destination.pub)
4264  				 .work (0)
4265  				 .build_shared ();
4266  	node1.work_generate_blocking (*open1);
4267  	auto open2 = builder
4268  				 .open ()
4269  				 .source (send1->hash ())
4270  				 .representative (nano::dev::genesis_key.pub)
4271  				 .account (destination.pub)
4272  				 .sign (destination.prv, destination.pub)
4273  				 .work (0)
4274  				 .build_shared ();
4275  	node1.work_generate_blocking (*open2);
4276  	open2->signature.bytes[0] ^= 1;
4277  	node1.block_processor.add (open2); 
4278  	node1.block_processor.add (open1);
4279  	{
4280  		ASSERT_TIMELY (10s, 1 == node1.unchecked.count ());
4281  		auto blocks = node1.unchecked.get (open1->source ());
4282  		ASSERT_EQ (blocks.size (), 1);
4283  	}
4284  	node1.block_processor.add (send1);
4285  	ASSERT_TIMELY (5s, node1.store.block.exists (node1.store.tx_begin_read (), open1->hash ()));
4286  	ASSERT_EQ (0, node1.unchecked.count ());
4287  }
4288  TEST (ledger, unchecked_receive)
4289  {
4290  	nano::test::system system{ 1 };
4291  	auto & node1 = *system.nodes[0];
4292  	nano::keypair destination{};
4293  	nano::block_builder builder;
4294  	auto send1 = builder
4295  				 .state ()
4296  				 .account (nano::dev::genesis->account ())
4297  				 .previous (nano::dev::genesis->hash ())
4298  				 .representative (nano::dev::genesis->account ())
4299  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4300  				 .link (destination.pub)
4301  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4302  				 .work (0)
4303  				 .build_shared ();
4304  	node1.work_generate_blocking (*send1);
4305  	auto send2 = builder
4306  				 .state ()
4307  				 .account (nano::dev::genesis->account ())
4308  				 .previous (send1->hash ())
4309  				 .representative (nano::dev::genesis->account ())
4310  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
4311  				 .link (destination.pub)
4312  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4313  				 .work (0)
4314  				 .build_shared ();
4315  	node1.work_generate_blocking (*send2);
4316  	auto open1 = builder
4317  				 .open ()
4318  				 .source (send1->hash ())
4319  				 .representative (destination.pub)
4320  				 .account (destination.pub)
4321  				 .sign (destination.prv, destination.pub)
4322  				 .work (0)
4323  				 .build_shared ();
4324  	node1.work_generate_blocking (*open1);
4325  	auto receive1 = builder
4326  					.receive ()
4327  					.previous (open1->hash ())
4328  					.source (send2->hash ())
4329  					.sign (destination.prv, destination.pub)
4330  					.work (0)
4331  					.build_shared ();
4332  	node1.work_generate_blocking (*receive1);
4333  	node1.block_processor.add (send1);
4334  	node1.block_processor.add (receive1);
4335  	auto check_block_is_listed = [&] (nano::transaction const & transaction_a, nano::block_hash const & block_hash_a) {
4336  		return !node1.unchecked.get (block_hash_a).empty ();
4337  	};
4338  	{
4339  		ASSERT_TIMELY (15s, check_block_is_listed (node1.store.tx_begin_read (), receive1->previous ()));
4340  		auto blocks = node1.unchecked.get (receive1->previous ());
4341  		ASSERT_EQ (blocks.size (), 1);
4342  	}
4343  	node1.block_processor.add (open1);
4344  	ASSERT_TIMELY (15s, check_block_is_listed (node1.store.tx_begin_read (), receive1->source ()));
4345  	{
4346  		auto transaction = node1.store.tx_begin_read ();
4347  		auto blocks (node1.unchecked.get (receive1->source ()));
4348  		ASSERT_EQ (blocks.size (), 1);
4349  	}
4350  	node1.block_processor.add (send2);
4351  	ASSERT_TIMELY (10s, node1.store.block.exists (node1.store.tx_begin_read (), receive1->hash ()));
4352  	ASSERT_EQ (0, node1.unchecked.count ());
4353  }
4354  TEST (ledger, confirmation_height_not_updated)
4355  {
4356  	auto ctx = nano::test::context::ledger_empty ();
4357  	auto & ledger = ctx.ledger ();
4358  	auto & store = ctx.store ();
4359  	auto transaction = store.tx_begin_write ();
4360  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4361  	auto account_info = ledger.account_info (transaction, nano::dev::genesis_key.pub);
4362  	ASSERT_TRUE (account_info);
4363  	nano::keypair key;
4364  	nano::block_builder builder;
4365  	auto send1 = builder
4366  				 .send ()
4367  				 .previous (account_info->head)
4368  				 .destination (key.pub)
4369  				 .balance (50)
4370  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4371  				 .work (*pool.generate (account_info->head))
4372  				 .build ();
4373  	nano::confirmation_height_info confirmation_height_info;
4374  	ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis->account (), confirmation_height_info));
4375  	ASSERT_EQ (1, confirmation_height_info.height);
4376  	ASSERT_EQ (nano::dev::genesis->hash (), confirmation_height_info.frontier);
4377  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4378  	ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis->account (), confirmation_height_info));
4379  	ASSERT_EQ (1, confirmation_height_info.height);
4380  	ASSERT_EQ (nano::dev::genesis->hash (), confirmation_height_info.frontier);
4381  	auto open1 = builder
4382  				 .open ()
4383  				 .source (send1->hash ())
4384  				 .representative (nano::dev::genesis->account ())
4385  				 .account (key.pub)
4386  				 .sign (key.prv, key.pub)
4387  				 .work (*pool.generate (key.pub))
4388  				 .build ();
4389  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
4390  	ASSERT_TRUE (store.confirmation_height.get (transaction, key.pub, confirmation_height_info));
4391  	ASSERT_EQ (0, confirmation_height_info.height);
4392  	ASSERT_EQ (nano::block_hash (0), confirmation_height_info.frontier);
4393  }
4394  TEST (ledger, zero_rep)
4395  {
4396  	nano::test::system system (1);
4397  	auto & node1 (*system.nodes[0]);
4398  	nano::block_builder builder;
4399  	auto block1 = builder.state ()
4400  				  .account (nano::dev::genesis_key.pub)
4401  				  .previous (nano::dev::genesis->hash ())
4402  				  .representative (0)
4403  				  .balance (nano::dev::constants.genesis_amount)
4404  				  .link (0)
4405  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4406  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
4407  				  .build ();
4408  	auto transaction (node1.store.tx_begin_write ());
4409  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *block1).code);
4410  	ASSERT_EQ (0, node1.ledger.cache.rep_weights.representation_get (nano::dev::genesis_key.pub));
4411  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.ledger.cache.rep_weights.representation_get (0));
4412  	auto block2 = builder.state ()
4413  				  .account (nano::dev::genesis_key.pub)
4414  				  .previous (block1->hash ())
4415  				  .representative (nano::dev::genesis_key.pub)
4416  				  .balance (nano::dev::constants.genesis_amount)
4417  				  .link (0)
4418  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4419  				  .work (*system.work.generate (block1->hash ()))
4420  				  .build ();
4421  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction, *block2).code);
4422  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.ledger.cache.rep_weights.representation_get (nano::dev::genesis_key.pub));
4423  	ASSERT_EQ (0, node1.ledger.cache.rep_weights.representation_get (0));
4424  }
4425  TEST (ledger, work_validation)
4426  {
4427  	auto ctx = nano::test::context::ledger_empty ();
4428  	auto & ledger = ctx.ledger ();
4429  	auto & store = ctx.store ();
4430  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4431  	nano::block_builder builder;
4432  	auto gen = nano::dev::genesis_key;
4433  	nano::keypair key;
4434  	auto process_block = [&store, &ledger, &pool] (nano::block & block_a, nano::block_details const details_a) {
4435  		auto threshold = nano::dev::network_params.work.threshold (block_a.work_version (), details_a);
4436  		while (nano::dev::network_params.work.difficulty (block_a) >= threshold)
4437  		{
4438  			block_a.block_work_set (block_a.block_work () + 1);
4439  		}
4440  		EXPECT_EQ (nano::process_result::insufficient_work, ledger.process (store.tx_begin_write (), block_a).code);
4441  		block_a.block_work_set (*pool.generate (block_a.root (), threshold));
4442  		EXPECT_EQ (nano::process_result::progress, ledger.process (store.tx_begin_write (), block_a).code);
4443  	};
4444  	std::error_code ec;
4445  	auto send = *builder.send ()
4446  				 .previous (nano::dev::genesis->hash ())
4447  				 .destination (gen.pub)
4448  				 .balance (nano::dev::constants.genesis_amount - 1)
4449  				 .sign (gen.prv, gen.pub)
4450  				 .work (0)
4451  				 .build (ec);
4452  	ASSERT_FALSE (ec);
4453  	auto receive = *builder.receive ()
4454  					.previous (send.hash ())
4455  					.source (send.hash ())
4456  					.sign (gen.prv, gen.pub)
4457  					.work (0)
4458  					.build (ec);
4459  	ASSERT_FALSE (ec);
4460  	auto change = *builder.change ()
4461  				   .previous (receive.hash ())
4462  				   .representative (key.pub)
4463  				   .sign (gen.prv, gen.pub)
4464  				   .work (0)
4465  				   .build (ec);
4466  	ASSERT_FALSE (ec);
4467  	auto state = *builder.state ()
4468  				  .account (gen.pub)
4469  				  .previous (change.hash ())
4470  				  .representative (gen.pub)
4471  				  .balance (nano::dev::constants.genesis_amount - 1)
4472  				  .link (key.pub)
4473  				  .sign (gen.prv, gen.pub)
4474  				  .work (0)
4475  				  .build (ec);
4476  	ASSERT_FALSE (ec);
4477  	auto open = *builder.open ()
4478  				 .account (key.pub)
4479  				 .source (state.hash ())
4480  				 .representative (key.pub)
4481  				 .sign (key.prv, key.pub)
4482  				 .work (0)
4483  				 .build (ec);
4484  	ASSERT_FALSE (ec);
4485  	auto epoch = *builder.state ()
4486  				  .account (key.pub)
4487  				  .previous (open.hash ())
4488  				  .balance (1)
4489  				  .representative (key.pub)
4490  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
4491  				  .sign (gen.prv, gen.pub)
4492  				  .work (0)
4493  				  .build (ec);
4494  	ASSERT_FALSE (ec);
4495  	process_block (send, {});
4496  	process_block (receive, {});
4497  	process_block (change, {});
4498  	process_block (state, nano::block_details (nano::epoch::epoch_0, true, false, false));
4499  	process_block (open, {});
4500  	process_block (epoch, nano::block_details (nano::epoch::epoch_1, false, false, true));
4501  }
4502  TEST (ledger, dependents_confirmed)
4503  {
4504  	auto ctx = nano::test::context::ledger_empty ();
4505  	auto & ledger = ctx.ledger ();
4506  	auto & store = ctx.store ();
4507  	auto transaction = store.tx_begin_write ();
4508  	nano::block_builder builder;
4509  	ASSERT_TRUE (ledger.dependents_confirmed (transaction, *nano::dev::genesis));
4510  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4511  	nano::keypair key1;
4512  	auto send1 = builder.state ()
4513  				 .account (nano::dev::genesis->account ())
4514  				 .previous (nano::dev::genesis->hash ())
4515  				 .representative (nano::dev::genesis->account ())
4516  				 .balance (nano::dev::constants.genesis_amount - 100)
4517  				 .link (key1.pub)
4518  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4519  				 .work (*pool.generate (nano::dev::genesis->hash ()))
4520  				 .build_shared ();
4521  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4522  	ASSERT_TRUE (ledger.dependents_confirmed (transaction, *send1));
4523  	auto send2 = builder.state ()
4524  				 .account (nano::dev::genesis->account ())
4525  				 .previous (send1->hash ())
4526  				 .representative (nano::dev::genesis->account ())
4527  				 .balance (nano::dev::constants.genesis_amount - 200)
4528  				 .link (key1.pub)
4529  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4530  				 .work (*pool.generate (send1->hash ()))
4531  				 .build_shared ();
4532  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
4533  	ASSERT_FALSE (ledger.dependents_confirmed (transaction, *send2));
4534  	auto receive1 = builder.state ()
4535  					.account (key1.pub)
4536  					.previous (0)
4537  					.representative (nano::dev::genesis->account ())
4538  					.balance (100)
4539  					.link (send1->hash ())
4540  					.sign (key1.prv, key1.pub)
4541  					.work (*pool.generate (key1.pub))
4542  					.build_shared ();
4543  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
4544  	ASSERT_FALSE (ledger.dependents_confirmed (transaction, *receive1));
4545  	nano::confirmation_height_info height;
4546  	ASSERT_FALSE (ledger.store.confirmation_height.get (transaction, nano::dev::genesis->account (), height));
4547  	height.height += 1;
4548  	ledger.store.confirmation_height.put (transaction, nano::dev::genesis->account (), height);
4549  	ASSERT_TRUE (ledger.dependents_confirmed (transaction, *receive1));
4550  	auto receive2 = builder.state ()
4551  					.account (key1.pub)
4552  					.previous (receive1->hash ())
4553  					.representative (nano::dev::genesis->account ())
4554  					.balance (200)
4555  					.link (send2->hash ())
4556  					.sign (key1.prv, key1.pub)
4557  					.work (*pool.generate (receive1->hash ()))
4558  					.build_shared ();
4559  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive2).code);
4560  	ASSERT_FALSE (ledger.dependents_confirmed (transaction, *receive2));
4561  	ASSERT_TRUE (ledger.store.confirmation_height.get (transaction, key1.pub, height));
4562  	height.height += 1;
4563  	ledger.store.confirmation_height.put (transaction, key1.pub, height);
4564  	ASSERT_FALSE (ledger.dependents_confirmed (transaction, *receive2));
4565  	ASSERT_FALSE (ledger.store.confirmation_height.get (transaction, nano::dev::genesis->account (), height));
4566  	height.height += 1;
4567  	ledger.store.confirmation_height.put (transaction, nano::dev::genesis->account (), height);
4568  	ASSERT_TRUE (ledger.dependents_confirmed (transaction, *receive2));
4569  }
4570  TEST (ledger, dependents_confirmed_pruning)
4571  {
4572  	nano::logger_mt logger;
4573  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
4574  	ASSERT_FALSE (store->init_error ());
4575  	nano::stats stats;
4576  	nano::ledger ledger (*store, stats, nano::dev::constants);
4577  	ledger.pruning = true;
4578  	auto transaction (store->tx_begin_write ());
4579  	store->initialize (transaction, ledger.cache, ledger.constants);
4580  	nano::block_builder builder;
4581  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4582  	nano::keypair key1;
4583  	auto send1 = builder.state ()
4584  				 .account (nano::dev::genesis->account ())
4585  				 .previous (nano::dev::genesis->hash ())
4586  				 .representative (nano::dev::genesis->account ())
4587  				 .balance (nano::dev::constants.genesis_amount - 100)
4588  				 .link (key1.pub)
4589  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4590  				 .work (*pool.generate (nano::dev::genesis->hash ()))
4591  				 .build_shared ();
4592  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4593  	auto send2 = builder.state ()
4594  				 .account (nano::dev::genesis->account ())
4595  				 .previous (send1->hash ())
4596  				 .representative (nano::dev::genesis->account ())
4597  				 .balance (nano::dev::constants.genesis_amount - 200)
4598  				 .link (key1.pub)
4599  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4600  				 .work (*pool.generate (send1->hash ()))
4601  				 .build_shared ();
4602  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
4603  	nano::confirmation_height_info height;
4604  	ASSERT_FALSE (ledger.store.confirmation_height.get (transaction, nano::dev::genesis->account (), height));
4605  	height.height = 3;
4606  	ledger.store.confirmation_height.put (transaction, nano::dev::genesis->account (), height);
4607  	ASSERT_TRUE (ledger.block_confirmed (transaction, send1->hash ()));
4608  	ASSERT_EQ (2, ledger.pruning_action (transaction, send2->hash (), 1));
4609  	auto receive1 = builder.state ()
4610  					.account (key1.pub)
4611  					.previous (0)
4612  					.representative (nano::dev::genesis->account ())
4613  					.balance (100)
4614  					.link (send1->hash ())
4615  					.sign (key1.prv, key1.pub)
4616  					.work (*pool.generate (key1.pub))
4617  					.build_shared ();
4618  	ASSERT_TRUE (ledger.dependents_confirmed (transaction, *receive1));
4619  }
4620  TEST (ledger, block_confirmed)
4621  {
4622  	auto ctx = nano::test::context::ledger_empty ();
4623  	auto & ledger = ctx.ledger ();
4624  	auto & store = ctx.store ();
4625  	auto transaction = store.tx_begin_write ();
4626  	nano::block_builder builder;
4627  	ASSERT_TRUE (ledger.block_confirmed (transaction, nano::dev::genesis->hash ()));
4628  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4629  	nano::keypair key1;
4630  	auto send1 = builder.state ()
4631  				 .account (nano::dev::genesis->account ())
4632  				 .previous (nano::dev::genesis->hash ())
4633  				 .representative (nano::dev::genesis->account ())
4634  				 .balance (nano::dev::constants.genesis_amount - 100)
4635  				 .link (key1.pub)
4636  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4637  				 .work (*pool.generate (nano::dev::genesis->hash ()))
4638  				 .build ();
4639  	ASSERT_FALSE (ledger.block_confirmed (transaction, send1->hash ()));
4640  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4641  	ASSERT_FALSE (ledger.block_confirmed (transaction, send1->hash ()));
4642  	nano::confirmation_height_info height;
4643  	ASSERT_FALSE (ledger.store.confirmation_height.get (transaction, nano::dev::genesis->account (), height));
4644  	++height.height;
4645  	ledger.store.confirmation_height.put (transaction, nano::dev::genesis->account (), height);
4646  	ASSERT_TRUE (ledger.block_confirmed (transaction, send1->hash ()));
4647  }
4648  TEST (ledger, cache)
4649  {
4650  	auto ctx = nano::test::context::ledger_empty ();
4651  	auto & ledger = ctx.ledger ();
4652  	auto & store = ctx.store ();
4653  	auto & stats = ctx.stats ();
4654  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4655  	nano::block_builder builder;
4656  	size_t const total = 100;
4657  	for (size_t i (0); i < total; ++i)
4658  	{
4659  		auto account_count = 1 + i;
4660  		auto block_count = 1 + 2 * (i + 1) - 2;
4661  		auto cemented_count = 1 + 2 * (i + 1) - 2;
4662  		auto genesis_weight = nano::dev::constants.genesis_amount - i;
4663  		auto pruned_count = i;
4664  		auto cache_check = [&, i] (nano::ledger_cache const & cache_a) {
4665  			ASSERT_EQ (account_count, cache_a.account_count);
4666  			ASSERT_EQ (block_count, cache_a.block_count);
4667  			ASSERT_EQ (cemented_count, cache_a.cemented_count);
4668  			ASSERT_EQ (genesis_weight, cache_a.rep_weights.representation_get (nano::dev::genesis->account ()));
4669  			ASSERT_EQ (pruned_count, cache_a.pruned_count);
4670  		};
4671  		nano::keypair key;
4672  		auto const latest = ledger.latest (store.tx_begin_read (), nano::dev::genesis->account ());
4673  		auto send = builder.state ()
4674  					.account (nano::dev::genesis->account ())
4675  					.previous (latest)
4676  					.representative (nano::dev::genesis->account ())
4677  					.balance (nano::dev::constants.genesis_amount - (i + 1))
4678  					.link (key.pub)
4679  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4680  					.work (*pool.generate (latest))
4681  					.build ();
4682  		auto open = builder.state ()
4683  					.account (key.pub)
4684  					.previous (0)
4685  					.representative (key.pub)
4686  					.balance (1)
4687  					.link (send->hash ())
4688  					.sign (key.prv, key.pub)
4689  					.work (*pool.generate (key.pub))
4690  					.build ();
4691  		{
4692  			auto transaction (store.tx_begin_write ());
4693  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
4694  		}
4695  		++block_count;
4696  		--genesis_weight;
4697  		cache_check (ledger.cache);
4698  		cache_check (nano::ledger (store, stats, nano::dev::constants).cache);
4699  		{
4700  			auto transaction (store.tx_begin_write ());
4701  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
4702  		}
4703  		++block_count;
4704  		++account_count;
4705  		cache_check (ledger.cache);
4706  		cache_check (nano::ledger (store, stats, nano::dev::constants).cache);
4707  		{
4708  			auto transaction (store.tx_begin_write ());
4709  			nano::confirmation_height_info height;
4710  			ASSERT_FALSE (ledger.store.confirmation_height.get (transaction, nano::dev::genesis->account (), height));
4711  			++height.height;
4712  			height.frontier = send->hash ();
4713  			ledger.store.confirmation_height.put (transaction, nano::dev::genesis->account (), height);
4714  			ASSERT_TRUE (ledger.block_confirmed (transaction, send->hash ()));
4715  			++ledger.cache.cemented_count;
4716  		}
4717  		++cemented_count;
4718  		cache_check (ledger.cache);
4719  		cache_check (nano::ledger (store, stats, nano::dev::constants).cache);
4720  		{
4721  			auto transaction (store.tx_begin_write ());
4722  			nano::confirmation_height_info height;
4723  			ledger.store.confirmation_height.get (transaction, key.pub, height);
4724  			height.height += 1;
4725  			height.frontier = open->hash ();
4726  			ledger.store.confirmation_height.put (transaction, key.pub, height);
4727  			ASSERT_TRUE (ledger.block_confirmed (transaction, open->hash ()));
4728  			++ledger.cache.cemented_count;
4729  		}
4730  		++cemented_count;
4731  		cache_check (ledger.cache);
4732  		cache_check (nano::ledger (store, stats, nano::dev::constants).cache);
4733  		{
4734  			auto transaction (store.tx_begin_write ());
4735  			ledger.store.pruned.put (transaction, open->hash ());
4736  			++ledger.cache.pruned_count;
4737  		}
4738  		++pruned_count;
4739  		cache_check (ledger.cache);
4740  		cache_check (nano::ledger (store, stats, nano::dev::constants).cache);
4741  	}
4742  }
4743  TEST (ledger, pruning_action)
4744  {
4745  	nano::logger_mt logger;
4746  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
4747  	ASSERT_TRUE (!store->init_error ());
4748  	nano::stats stats;
4749  	nano::ledger ledger (*store, stats, nano::dev::constants);
4750  	ledger.pruning = true;
4751  	auto transaction (store->tx_begin_write ());
4752  	store->initialize (transaction, ledger.cache, ledger.constants);
4753  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4754  	nano::block_builder builder;
4755  	auto send1 = builder
4756  				 .state ()
4757  				 .account (nano::dev::genesis->account ())
4758  				 .previous (nano::dev::genesis->hash ())
4759  				 .representative (nano::dev::genesis->account ())
4760  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4761  				 .link (nano::dev::genesis->account ())
4762  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4763  				 .work (*pool.generate (nano::dev::genesis->hash ()))
4764  				 .build ();
4765  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4766  	ASSERT_TRUE (store->block.exists (transaction, send1->hash ()));
4767  	auto send1_stored (store->block.get (transaction, send1->hash ()));
4768  	ASSERT_NE (nullptr, send1_stored);
4769  	ASSERT_EQ (*send1, *send1_stored);
4770  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4771  	auto send2 = builder
4772  				 .state ()
4773  				 .account (nano::dev::genesis->account ())
4774  				 .previous (send1->hash ())
4775  				 .representative (nano::dev::genesis->account ())
4776  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
4777  				 .link (nano::dev::genesis->account ())
4778  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4779  				 .work (*pool.generate (send1->hash ()))
4780  				 .build ();
4781  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
4782  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
4783  	ASSERT_EQ (1, ledger.pruning_action (transaction, send1->hash (), 1));
4784  	ASSERT_EQ (0, ledger.pruning_action (transaction, nano::dev::genesis->hash (), 1));
4785  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4786  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
4787  	ASSERT_TRUE (ledger.block_or_pruned_exists (transaction, send1->hash ()));
4788  	ledger.pruning = false;
4789  	ASSERT_TRUE (ledger.block_or_pruned_exists (transaction, send1->hash ()));
4790  	ledger.pruning = true;
4791  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
4792  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
4793  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
4794  	auto receive1 = builder
4795  					.state ()
4796  					.account (nano::dev::genesis->account ())
4797  					.previous (send2->hash ())
4798  					.representative (nano::dev::genesis->account ())
4799  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4800  					.link (send1->hash ())
4801  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4802  					.work (*pool.generate (send2->hash ()))
4803  					.build ();
4804  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
4805  	ASSERT_TRUE (store->block.exists (transaction, receive1->hash ()));
4806  	auto receive1_stored (store->block.get (transaction, receive1->hash ()));
4807  	ASSERT_NE (nullptr, receive1_stored);
4808  	ASSERT_EQ (*receive1, *receive1_stored);
4809  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4810  	ASSERT_EQ (4, receive1_stored->sideband ().height);
4811  	ASSERT_FALSE (receive1_stored->sideband ().details.is_send);
4812  	ASSERT_TRUE (receive1_stored->sideband ().details.is_receive);
4813  	ASSERT_FALSE (receive1_stored->sideband ().details.is_epoch);
4814  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
4815  	ASSERT_EQ (1, ledger.pruning_action (transaction, send2->hash (), 1));
4816  	ASSERT_TRUE (store->pruned.exists (transaction, send2->hash ()));
4817  	ASSERT_FALSE (store->block.exists (transaction, send2->hash ()));
4818  	ASSERT_EQ (store->account.count (transaction), ledger.cache.account_count);
4819  	ASSERT_EQ (store->pruned.count (transaction), ledger.cache.pruned_count);
4820  	ASSERT_EQ (store->block.count (transaction), ledger.cache.block_count - ledger.cache.pruned_count);
4821  }
4822  TEST (ledger, pruning_large_chain)
4823  {
4824  	nano::logger_mt logger;
4825  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
4826  	ASSERT_TRUE (!store->init_error ());
4827  	nano::stats stats;
4828  	nano::ledger ledger (*store, stats, nano::dev::constants);
4829  	ledger.pruning = true;
4830  	auto transaction (store->tx_begin_write ());
4831  	store->initialize (transaction, ledger.cache, ledger.constants);
4832  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4833  	size_t send_receive_pairs (20);
4834  	auto last_hash (nano::dev::genesis->hash ());
4835  	nano::block_builder builder;
4836  	for (auto i (0); i < send_receive_pairs; i++)
4837  	{
4838  		auto send = builder
4839  					.state ()
4840  					.account (nano::dev::genesis->account ())
4841  					.previous (last_hash)
4842  					.representative (nano::dev::genesis->account ())
4843  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4844  					.link (nano::dev::genesis->account ())
4845  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4846  					.work (*pool.generate (last_hash))
4847  					.build ();
4848  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
4849  		ASSERT_TRUE (store->block.exists (transaction, send->hash ()));
4850  		auto receive = builder
4851  					   .state ()
4852  					   .account (nano::dev::genesis->account ())
4853  					   .previous (send->hash ())
4854  					   .representative (nano::dev::genesis->account ())
4855  					   .balance (nano::dev::constants.genesis_amount)
4856  					   .link (send->hash ())
4857  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4858  					   .work (*pool.generate (send->hash ()))
4859  					   .build ();
4860  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
4861  		ASSERT_TRUE (store->block.exists (transaction, receive->hash ()));
4862  		last_hash = receive->hash ();
4863  	}
4864  	ASSERT_EQ (0, store->pruned.count (transaction));
4865  	ASSERT_EQ (send_receive_pairs * 2 + 1, store->block.count (transaction));
4866  	ASSERT_EQ (send_receive_pairs * 2, ledger.pruning_action (transaction, last_hash, 5));
4867  	ASSERT_TRUE (store->pruned.exists (transaction, last_hash));
4868  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
4869  	ASSERT_FALSE (store->block.exists (transaction, last_hash));
4870  	ASSERT_EQ (store->pruned.count (transaction), ledger.cache.pruned_count);
4871  	ASSERT_EQ (store->block.count (transaction), ledger.cache.block_count - ledger.cache.pruned_count);
4872  	ASSERT_EQ (send_receive_pairs * 2, store->pruned.count (transaction));
4873  	ASSERT_EQ (1, store->block.count (transaction)); 
4874  }
4875  TEST (ledger, pruning_source_rollback)
4876  {
4877  	nano::logger_mt logger;
4878  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
4879  	ASSERT_TRUE (!store->init_error ());
4880  	nano::stats stats;
4881  	nano::ledger ledger (*store, stats, nano::dev::constants);
4882  	ledger.pruning = true;
4883  	auto transaction (store->tx_begin_write ());
4884  	store->initialize (transaction, ledger.cache, ledger.constants);
4885  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4886  	nano::block_builder builder;
4887  	auto epoch1 = builder
4888  				  .state ()
4889  				  .account (nano::dev::genesis->account ())
4890  				  .previous (nano::dev::genesis->hash ())
4891  				  .representative (nano::dev::genesis->account ())
4892  				  .balance (nano::dev::constants.genesis_amount)
4893  				  .link (ledger.epoch_link (nano::epoch::epoch_1))
4894  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4895  				  .work (*pool.generate (nano::dev::genesis->hash ()))
4896  				  .build ();
4897  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch1).code);
4898  	auto send1 = builder
4899  				 .state ()
4900  				 .account (nano::dev::genesis->account ())
4901  				 .previous (epoch1->hash ())
4902  				 .representative (nano::dev::genesis->account ())
4903  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4904  				 .link (nano::dev::genesis->account ())
4905  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4906  				 .work (*pool.generate (epoch1->hash ()))
4907  				 .build ();
4908  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4909  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4910  	auto send2 = builder
4911  				 .state ()
4912  				 .account (nano::dev::genesis->account ())
4913  				 .previous (send1->hash ())
4914  				 .representative (nano::dev::genesis->account ())
4915  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
4916  				 .link (nano::dev::genesis->account ())
4917  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4918  				 .work (*pool.generate (send1->hash ()))
4919  				 .build ();
4920  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
4921  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
4922  	ASSERT_EQ (2, ledger.pruning_action (transaction, send1->hash (), 1));
4923  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
4924  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
4925  	ASSERT_FALSE (store->block.exists (transaction, epoch1->hash ()));
4926  	ASSERT_TRUE (store->pruned.exists (transaction, epoch1->hash ()));
4927  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
4928  	auto info = ledger.pending_info (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ()));
4929  	ASSERT_TRUE (info);
4930  	ASSERT_EQ (nano::dev::genesis->account (), info->source);
4931  	ASSERT_EQ (nano::Gxrb_ratio, info->amount.number ());
4932  	ASSERT_EQ (nano::epoch::epoch_1, info->epoch);
4933  	auto receive1 = builder
4934  					.state ()
4935  					.account (nano::dev::genesis->account ())
4936  					.previous (send2->hash ())
4937  					.representative (nano::dev::genesis->account ())
4938  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4939  					.link (send1->hash ())
4940  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4941  					.work (*pool.generate (send2->hash ()))
4942  					.build ();
4943  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
4944  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4945  	ASSERT_EQ (2, ledger.cache.pruned_count);
4946  	ASSERT_EQ (5, ledger.cache.block_count);
4947  	ASSERT_FALSE (ledger.rollback (transaction, receive1->hash ()));
4948  	auto info2 = ledger.pending_info (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ()));
4949  	ASSERT_TRUE (info2);
4950  	ASSERT_NE (nano::dev::genesis->account (), info2->source); 
4951  	ASSERT_EQ (nano::Gxrb_ratio, info2->amount.number ());
4952  	ASSERT_EQ (nano::epoch::epoch_1, info2->epoch);
4953  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
4954  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4955  	ASSERT_EQ (2, ledger.cache.pruned_count);
4956  	ASSERT_EQ (5, ledger.cache.block_count);
4957  }
4958  TEST (ledger, pruning_source_rollback_legacy)
4959  {
4960  	nano::logger_mt logger;
4961  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
4962  	ASSERT_TRUE (!store->init_error ());
4963  	nano::stats stats;
4964  	nano::ledger ledger (*store, stats, nano::dev::constants);
4965  	ledger.pruning = true;
4966  	auto transaction (store->tx_begin_write ());
4967  	store->initialize (transaction, ledger.cache, ledger.constants);
4968  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
4969  	nano::block_builder builder;
4970  	auto send1 = builder
4971  				 .send ()
4972  				 .previous (nano::dev::genesis->hash ())
4973  				 .destination (nano::dev::genesis->account ())
4974  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4975  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4976  				 .work (*pool.generate (nano::dev::genesis->hash ()))
4977  				 .build ();
4978  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
4979  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
4980  	nano::keypair key1;
4981  	auto send2 = builder
4982  				 .send ()
4983  				 .previous (send1->hash ())
4984  				 .destination (key1.pub)
4985  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
4986  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4987  				 .work (*pool.generate (send1->hash ()))
4988  				 .build ();
4989  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
4990  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
4991  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (key1.pub, send2->hash ())));
4992  	auto send3 = builder
4993  				 .send ()
4994  				 .previous (send2->hash ())
4995  				 .destination (nano::dev::genesis->account ())
4996  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
4997  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4998  				 .work (*pool.generate (send2->hash ()))
4999  				 .build ();
5000  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send3).code);
5001  	ASSERT_TRUE (store->block.exists (transaction, send3->hash ()));
5002  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send3->hash ())));
5003  	ASSERT_EQ (2, ledger.pruning_action (transaction, send2->hash (), 1));
5004  	ASSERT_FALSE (store->block.exists (transaction, send2->hash ()));
5005  	ASSERT_TRUE (store->pruned.exists (transaction, send2->hash ()));
5006  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
5007  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
5008  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
5009  	auto info1 = ledger.pending_info (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ()));
5010  	ASSERT_TRUE (info1);
5011  	ASSERT_EQ (nano::dev::genesis->account (), info1->source);
5012  	ASSERT_EQ (nano::Gxrb_ratio, info1->amount.number ());
5013  	ASSERT_EQ (nano::epoch::epoch_0, info1->epoch);
5014  	auto info2 = ledger.pending_info (transaction, nano::pending_key (key1.pub, send2->hash ()));
5015  	ASSERT_TRUE (info2);
5016  	ASSERT_EQ (nano::dev::genesis->account (), info2->source);
5017  	ASSERT_EQ (nano::Gxrb_ratio, info2->amount.number ());
5018  	ASSERT_EQ (nano::epoch::epoch_0, info2->epoch);
5019  	auto receive1 = builder
5020  					.receive ()
5021  					.previous (send3->hash ())
5022  					.source (send1->hash ())
5023  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5024  					.work (*pool.generate (send3->hash ()))
5025  					.build ();
5026  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
5027  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
5028  	ASSERT_EQ (2, ledger.cache.pruned_count);
5029  	ASSERT_EQ (5, ledger.cache.block_count);
5030  	ASSERT_FALSE (ledger.rollback (transaction, receive1->hash ()));
5031  	auto info3 = ledger.pending_info (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ()));
5032  	ASSERT_TRUE (info3);
5033  	ASSERT_NE (nano::dev::genesis->account (), info3->source); 
5034  	ASSERT_EQ (nano::Gxrb_ratio, info3->amount.number ());
5035  	ASSERT_EQ (nano::epoch::epoch_0, info3->epoch);
5036  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
5037  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
5038  	ASSERT_EQ (2, ledger.cache.pruned_count);
5039  	ASSERT_EQ (5, ledger.cache.block_count);
5040  	auto open1 = builder
5041  				 .open ()
5042  				 .source (send2->hash ())
5043  				 .representative (nano::dev::genesis->account ())
5044  				 .account (key1.pub)
5045  				 .sign (key1.prv, key1.pub)
5046  				 .work (*pool.generate (key1.pub))
5047  				 .build ();
5048  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
5049  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (key1.pub, send2->hash ())));
5050  	ASSERT_EQ (2, ledger.cache.pruned_count);
5051  	ASSERT_EQ (6, ledger.cache.block_count);
5052  	ASSERT_FALSE (ledger.rollback (transaction, open1->hash ()));
5053  	auto info4 = ledger.pending_info (transaction, nano::pending_key (key1.pub, send2->hash ()));
5054  	ASSERT_TRUE (info4);
5055  	ASSERT_NE (nano::dev::genesis->account (), info4->source); 
5056  	ASSERT_EQ (nano::Gxrb_ratio, info4->amount.number ());
5057  	ASSERT_EQ (nano::epoch::epoch_0, info4->epoch);
5058  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
5059  	ASSERT_FALSE (store->pending.exists (transaction, nano::pending_key (key1.pub, send2->hash ())));
5060  	ASSERT_EQ (2, ledger.cache.pruned_count);
5061  	ASSERT_EQ (6, ledger.cache.block_count);
5062  }
5063  TEST (ledger, pruning_process_error)
5064  {
5065  	nano::logger_mt logger;
5066  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
5067  	ASSERT_TRUE (!store->init_error ());
5068  	nano::stats stats;
5069  	nano::ledger ledger (*store, stats, nano::dev::constants);
5070  	ledger.pruning = true;
5071  	auto transaction (store->tx_begin_write ());
5072  	store->initialize (transaction, ledger.cache, ledger.constants);
5073  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
5074  	nano::block_builder builder;
5075  	auto send1 = builder
5076  				 .state ()
5077  				 .account (nano::dev::genesis->account ())
5078  				 .previous (nano::dev::genesis->hash ())
5079  				 .representative (nano::dev::genesis->account ())
5080  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5081  				 .link (nano::dev::genesis->account ())
5082  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5083  				 .work (*pool.generate (nano::dev::genesis->hash ()))
5084  				 .build ();
5085  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
5086  	ASSERT_EQ (0, ledger.cache.pruned_count);
5087  	ASSERT_EQ (2, ledger.cache.block_count);
5088  	ASSERT_EQ (1, ledger.pruning_action (transaction, send1->hash (), 1));
5089  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
5090  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
5091  	ASSERT_EQ (nano::process_result::old, ledger.process (transaction, *send1).code);
5092  	auto send2 = builder
5093  				 .state ()
5094  				 .account (nano::dev::genesis->account ())
5095  				 .previous (send1->hash ())
5096  				 .representative (nano::dev::genesis->account ())
5097  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
5098  				 .link (nano::dev::genesis->account ())
5099  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5100  				 .work (*pool.generate (send1->hash ()))
5101  				 .build ();
5102  	ASSERT_EQ (nano::process_result::gap_previous, ledger.process (transaction, *send2).code);
5103  	ASSERT_EQ (1, ledger.cache.pruned_count);
5104  	ASSERT_EQ (2, ledger.cache.block_count);
5105  }
5106  TEST (ledger, pruning_legacy_blocks)
5107  {
5108  	nano::logger_mt logger;
5109  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
5110  	ASSERT_TRUE (!store->init_error ());
5111  	nano::stats stats;
5112  	nano::ledger ledger (*store, stats, nano::dev::constants);
5113  	ledger.pruning = true;
5114  	nano::keypair key1;
5115  	auto transaction (store->tx_begin_write ());
5116  	store->initialize (transaction, ledger.cache, ledger.constants);
5117  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
5118  	nano::block_builder builder;
5119  	auto send1 = builder
5120  				 .send ()
5121  				 .previous (nano::dev::genesis->hash ())
5122  				 .destination (nano::dev::genesis->account ())
5123  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5124  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5125  				 .work (*pool.generate (nano::dev::genesis->hash ()))
5126  				 .build ();
5127  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
5128  	ASSERT_TRUE (store->pending.exists (transaction, nano::pending_key (nano::dev::genesis->account (), send1->hash ())));
5129  	auto receive1 = builder
5130  					.receive ()
5131  					.previous (send1->hash ())
5132  					.source (send1->hash ())
5133  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5134  					.work (*pool.generate (send1->hash ()))
5135  					.build ();
5136  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive1).code);
5137  	auto change1 = builder
5138  				   .change ()
5139  				   .previous (receive1->hash ())
5140  				   .representative (key1.pub)
5141  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5142  				   .work (*pool.generate (receive1->hash ()))
5143  				   .build ();
5144  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change1).code);
5145  	auto send2 = builder
5146  				 .send ()
5147  				 .previous (change1->hash ())
5148  				 .destination (key1.pub)
5149  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5150  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5151  				 .work (*pool.generate (change1->hash ()))
5152  				 .build ();
5153  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
5154  	auto open1 = builder
5155  				 .open ()
5156  				 .source (send2->hash ())
5157  				 .representative (nano::dev::genesis->account ())
5158  				 .account (key1.pub)
5159  				 .sign (key1.prv, key1.pub)
5160  				 .work (*pool.generate (key1.pub))
5161  				 .build ();
5162  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open1).code);
5163  	auto send3 = builder
5164  				 .send ()
5165  				 .previous (open1->hash ())
5166  				 .destination (nano::dev::genesis->account ())
5167  				 .balance (0)
5168  				 .sign (key1.prv, key1.pub)
5169  				 .work (*pool.generate (open1->hash ()))
5170  				 .build ();
5171  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send3).code);
5172  	ASSERT_EQ (3, ledger.pruning_action (transaction, change1->hash (), 2));
5173  	ASSERT_EQ (1, ledger.pruning_action (transaction, open1->hash (), 1));
5174  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
5175  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
5176  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
5177  	ASSERT_FALSE (store->block.exists (transaction, receive1->hash ()));
5178  	ASSERT_TRUE (store->pruned.exists (transaction, receive1->hash ()));
5179  	ASSERT_FALSE (store->block.exists (transaction, change1->hash ()));
5180  	ASSERT_TRUE (store->pruned.exists (transaction, change1->hash ()));
5181  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
5182  	ASSERT_FALSE (store->block.exists (transaction, open1->hash ()));
5183  	ASSERT_TRUE (store->pruned.exists (transaction, open1->hash ()));
5184  	ASSERT_TRUE (store->block.exists (transaction, send3->hash ()));
5185  	ASSERT_EQ (4, ledger.cache.pruned_count);
5186  	ASSERT_EQ (7, ledger.cache.block_count);
5187  	ASSERT_EQ (store->pruned.count (transaction), ledger.cache.pruned_count);
5188  	ASSERT_EQ (store->block.count (transaction), ledger.cache.block_count - ledger.cache.pruned_count);
5189  }
5190  TEST (ledger, pruning_safe_functions)
5191  {
5192  	nano::logger_mt logger;
5193  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
5194  	ASSERT_TRUE (!store->init_error ());
5195  	nano::stats stats;
5196  	nano::ledger ledger (*store, stats, nano::dev::constants);
5197  	ledger.pruning = true;
5198  	auto transaction (store->tx_begin_write ());
5199  	store->initialize (transaction, ledger.cache, ledger.constants);
5200  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
5201  	nano::block_builder builder;
5202  	auto send1 = builder
5203  				 .state ()
5204  				 .account (nano::dev::genesis->account ())
5205  				 .previous (nano::dev::genesis->hash ())
5206  				 .representative (nano::dev::genesis->account ())
5207  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5208  				 .link (nano::dev::genesis->account ())
5209  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5210  				 .work (*pool.generate (nano::dev::genesis->hash ()))
5211  				 .build ();
5212  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
5213  	ASSERT_TRUE (store->block.exists (transaction, send1->hash ()));
5214  	auto send2 = builder
5215  				 .state ()
5216  				 .account (nano::dev::genesis->account ())
5217  				 .previous (send1->hash ())
5218  				 .representative (nano::dev::genesis->account ())
5219  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
5220  				 .link (nano::dev::genesis->account ())
5221  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5222  				 .work (*pool.generate (send1->hash ()))
5223  				 .build ();
5224  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
5225  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
5226  	ASSERT_EQ (1, ledger.pruning_action (transaction, send1->hash (), 1));
5227  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
5228  	ASSERT_TRUE (ledger.block_or_pruned_exists (transaction, send1->hash ())); 
5229  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
5230  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
5231  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
5232  	bool error (false);
5233  	ASSERT_EQ (0, ledger.balance_safe (transaction, send1->hash (), error));
5234  	ASSERT_TRUE (error);
5235  	error = false;
5236  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2, ledger.balance_safe (transaction, send2->hash (), error));
5237  	ASSERT_FALSE (error);
5238  	error = false;
5239  	ASSERT_EQ (0, ledger.amount_safe (transaction, send2->hash (), error));
5240  	ASSERT_TRUE (error);
5241  	error = false;
5242  	ASSERT_TRUE (ledger.account_safe (transaction, send1->hash (), error).is_zero ());
5243  	ASSERT_TRUE (error);
5244  	error = false;
5245  	ASSERT_EQ (nano::dev::genesis->account (), ledger.account_safe (transaction, send2->hash (), error));
5246  	ASSERT_FALSE (error);
5247  }
5248  TEST (ledger, hash_root_random)
5249  {
5250  	nano::logger_mt logger;
5251  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
5252  	ASSERT_TRUE (!store->init_error ());
5253  	nano::stats stats;
5254  	nano::ledger ledger (*store, stats, nano::dev::constants);
5255  	ledger.pruning = true;
5256  	auto transaction (store->tx_begin_write ());
5257  	store->initialize (transaction, ledger.cache, ledger.constants);
5258  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
5259  	nano::block_builder builder;
5260  	auto send1 = builder
5261  				 .state ()
5262  				 .account (nano::dev::genesis->account ())
5263  				 .previous (nano::dev::genesis->hash ())
5264  				 .representative (nano::dev::genesis->account ())
5265  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5266  				 .link (nano::dev::genesis->account ())
5267  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5268  				 .work (*pool.generate (nano::dev::genesis->hash ()))
5269  				 .build ();
5270  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send1).code);
5271  	ASSERT_TRUE (store->block.exists (transaction, send1->hash ()));
5272  	auto send2 = builder
5273  				 .state ()
5274  				 .account (nano::dev::genesis->account ())
5275  				 .previous (send1->hash ())
5276  				 .representative (nano::dev::genesis->account ())
5277  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
5278  				 .link (nano::dev::genesis->account ())
5279  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5280  				 .work (*pool.generate (send1->hash ()))
5281  				 .build ();
5282  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send2).code);
5283  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
5284  	ASSERT_EQ (1, ledger.pruning_action (transaction, send1->hash (), 1));
5285  	ASSERT_FALSE (store->block.exists (transaction, send1->hash ()));
5286  	ASSERT_TRUE (store->pruned.exists (transaction, send1->hash ()));
5287  	ASSERT_TRUE (store->block.exists (transaction, nano::dev::genesis->hash ()));
5288  	ASSERT_TRUE (store->block.exists (transaction, send2->hash ()));
5289  	bool done (false);
5290  	auto iteration (0);
5291  	while (!done)
5292  	{
5293  		++iteration;
5294  		auto root_hash (ledger.hash_root_random (transaction));
5295  		done = (root_hash.first == send1->hash ()) && (root_hash.second.is_zero ());
5296  		ASSERT_LE (iteration, 1000);
5297  	}
5298  	done = false;
5299  	while (!done)
5300  	{
5301  		++iteration;
5302  		auto root_hash (ledger.hash_root_random (transaction));
5303  		done = (root_hash.first == send2->hash ()) && (root_hash.second == send2->root ().as_block_hash ());
5304  		ASSERT_LE (iteration, 1000);
5305  	}
5306  }
5307  TEST (ledger, migrate_lmdb_to_rocksdb)
5308  {
5309  	nano::test::system system{};
5310  	auto path = nano::unique_path ();
5311  	nano::logger_mt logger{};
5312  	boost::asio::ip::address_v6 address (boost::asio::ip::make_address_v6 ("::ffff:127.0.0.1"));
5313  	uint16_t port = 100;
5314  	nano::lmdb::store store{ logger, path / "data.ldb", nano::dev::constants };
5315  	nano::ledger ledger{ store, system.stats, nano::dev::constants };
5316  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
5317  	std::shared_ptr<nano::block> send = nano::state_block_builder ()
5318  										.account (nano::dev::genesis_key.pub)
5319  										.previous (nano::dev::genesis->hash ())
5320  										.representative (0)
5321  										.link (nano::account (10))
5322  										.balance (nano::dev::constants.genesis_amount - 100)
5323  										.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5324  										.work (*pool.generate (nano::dev::genesis->hash ()))
5325  										.build_shared ();
5326  	nano::endpoint_key endpoint_key (address.to_bytes (), port);
5327  	auto version = nano::store::version_current;
5328  	{
5329  		auto transaction = store.tx_begin_write ();
5330  		store.initialize (transaction, ledger.cache, ledger.constants);
5331  		ASSERT_FALSE (store.init_error ());
5332  		store.confirmation_height.put (transaction, nano::dev::genesis->account (), { 2, send->hash () });
5333  		store.online_weight.put (transaction, 100, nano::amount (2));
5334  		store.frontier.put (transaction, nano::block_hash (2), nano::account (5));
5335  		store.peer.put (transaction, endpoint_key);
5336  		store.pending.put (transaction, nano::pending_key (nano::dev::genesis->account (), send->hash ()), nano::pending_info (nano::dev::genesis->account (), 100, nano::epoch::epoch_0));
5337  		store.pruned.put (transaction, send->hash ());
5338  		store.version.put (transaction, version);
5339  		send->sideband_set ({});
5340  		store.block.put (transaction, send->hash (), *send);
5341  		store.final_vote.put (transaction, send->qualified_root (), nano::block_hash (2));
5342  	}
5343  	auto error = ledger.migrate_lmdb_to_rocksdb (path);
5344  	ASSERT_FALSE (error);
5345  	nano::rocksdb::store rocksdb_store{ logger, path / "rocksdb", nano::dev::constants };
5346  	auto rocksdb_transaction (rocksdb_store.tx_begin_read ());
5347  	nano::pending_info pending_info{};
5348  	ASSERT_FALSE (rocksdb_store.pending.get (rocksdb_transaction, nano::pending_key (nano::dev::genesis->account (), send->hash ()), pending_info));
5349  	for (auto i = rocksdb_store.online_weight.begin (rocksdb_transaction); i != rocksdb_store.online_weight.end (); ++i)
5350  	{
5351  		ASSERT_EQ (i->first, 100);
5352  		ASSERT_EQ (i->second, 2);
5353  	}
5354  	ASSERT_EQ (rocksdb_store.online_weight.count (rocksdb_transaction), 1);
5355  	auto block1 = rocksdb_store.block.get (rocksdb_transaction, send->hash ());
5356  	ASSERT_EQ (*send, *block1);
5357  	ASSERT_TRUE (rocksdb_store.peer.exists (rocksdb_transaction, endpoint_key));
5358  	ASSERT_EQ (rocksdb_store.version.get (rocksdb_transaction), version);
5359  	ASSERT_EQ (rocksdb_store.frontier.get (rocksdb_transaction, 2), 5);
5360  	nano::confirmation_height_info confirmation_height_info;
5361  	ASSERT_FALSE (rocksdb_store.confirmation_height.get (rocksdb_transaction, nano::dev::genesis->account (), confirmation_height_info));
5362  	ASSERT_EQ (confirmation_height_info.height, 2);
5363  	ASSERT_EQ (confirmation_height_info.frontier, send->hash ());
5364  	ASSERT_TRUE (rocksdb_store.final_vote.get (rocksdb_transaction, nano::root (send->previous ())).size () == 1);
5365  	ASSERT_EQ (rocksdb_store.final_vote.get (rocksdb_transaction, nano::root (send->previous ()))[0], nano::block_hash (2));
5366  }
5367  TEST (ledger, unconfirmed_frontiers)
5368  {
5369  	auto ctx = nano::test::context::ledger_empty ();
5370  	auto & ledger = ctx.ledger ();
5371  	auto & store = ctx.store ();
5372  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
5373  	auto unconfirmed_frontiers = ledger.unconfirmed_frontiers ();
5374  	ASSERT_TRUE (unconfirmed_frontiers.empty ());
5375  	nano::state_block_builder builder;
5376  	nano::keypair key;
5377  	auto const latest = ledger.latest (store.tx_begin_read (), nano::dev::genesis->account ());
5378  	auto send = builder.make_block ()
5379  				.account (nano::dev::genesis->account ())
5380  				.previous (latest)
5381  				.representative (nano::dev::genesis->account ())
5382  				.balance (nano::dev::constants.genesis_amount - 100)
5383  				.link (key.pub)
5384  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5385  				.work (*pool.generate (latest))
5386  				.build ();
5387  	ASSERT_EQ (nano::process_result::progress, ledger.process (store.tx_begin_write (), *send).code);
5388  	unconfirmed_frontiers = ledger.unconfirmed_frontiers ();
5389  	ASSERT_EQ (unconfirmed_frontiers.size (), 1);
5390  	ASSERT_EQ (unconfirmed_frontiers.begin ()->first, 1);
5391  	nano::uncemented_info uncemented_info1{ latest, send->hash (), nano::dev::genesis->account () };
5392  	auto uncemented_info2 = unconfirmed_frontiers.begin ()->second;
5393  	ASSERT_EQ (uncemented_info1.account, uncemented_info2.account);
5394  	ASSERT_EQ (uncemented_info1.cemented_frontier, uncemented_info2.cemented_frontier);
5395  	ASSERT_EQ (uncemented_info1.frontier, uncemented_info2.frontier);
5396  }
5397  TEST (ledger, is_send_genesis)
5398  {
5399  	auto ctx = nano::test::context::ledger_empty ();
5400  	auto & ledger = ctx.ledger ();
5401  	auto & store = ctx.store ();
5402  	auto tx = store.tx_begin_read ();
5403  	ASSERT_FALSE (ledger.is_send (tx, *nano::dev::genesis));
5404  }
5405  TEST (ledger, is_send_state)
5406  {
5407  	auto ctx = nano::test::context::ledger_send_receive ();
5408  	auto & ledger = ctx.ledger ();
5409  	auto & store = ctx.store ();
5410  	auto tx = store.tx_begin_read ();
5411  	ASSERT_TRUE (ledger.is_send (tx, *ctx.blocks ()[0]));
5412  	ASSERT_FALSE (ledger.is_send (tx, *ctx.blocks ()[1]));
5413  }
5414  TEST (ledger, is_send_legacy)
5415  {
5416  	auto ctx = nano::test::context::ledger_send_receive_legacy ();
5417  	auto & ledger = ctx.ledger ();
5418  	auto & store = ctx.store ();
5419  	auto tx = store.tx_begin_read ();
5420  	ASSERT_TRUE (ledger.is_send (tx, *ctx.blocks ()[0]));
5421  	ASSERT_FALSE (ledger.is_send (tx, *ctx.blocks ()[1]));
5422  }
5423  TEST (ledger, head_block)
5424  {
5425  	auto ctx = nano::test::context::ledger_empty ();
5426  	auto & ledger = ctx.ledger ();
5427  	auto & store = ctx.store ();
5428  	auto tx = store.tx_begin_read ();
5429  	ASSERT_EQ (*nano::dev::genesis, *ledger.head_block (tx, nano::dev::genesis->account ()));
5430  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sock.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-ledger.cpp</div>
                </div>
                <div class="column column_space"><pre><code>109    static void AddTimer(const ATimer& Timer){
110      IAssert(!IsTimer(Timer->GetTimerId()));
111      IdToTimerH.AddDat(TInt(Timer->GetTimerId()), Timer);}
112    static void DelTimer(const int& TimerId){
</pre></code></div>
                <div class="column column_space"><pre><code>648  	nano::rep_weights rep_weights;
649  	ASSERT_EQ (0, rep_weights.representation_get (key1.pub));
650  	rep_weights.representation_put (key1.pub, 1);
651  	ASSERT_EQ (1, rep_weights.representation_get (key1.pub));
652  	rep_weights.representation_put (key1.pub, 2);
653  	ASSERT_EQ (2, rep_weights.representation_get (key1.pub));
654  }
655  TEST (ledger, representation)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    