
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.689558514365803%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrblock.cpp</h3>
            <pre><code>1  #include "ocrblock.h"
2  #include "stepblob.h"
3  #include "tprintf.h"
4  #include <cstdlib>
5  #include <memory> 
6  namespace tesseract {
7  BLOCK::BLOCK(const char *name, 
8               bool prop,        
9               int16_t kern,     
10               int16_t space,    
11               TDimension xmin,  
12               TDimension ymin,
13               TDimension xmax,  
14               TDimension ymax)
15      : pdblk(xmin, ymin, xmax, ymax)
16      , filename(name)
17      , re_rotation_(1.0f, 0.0f)
18      , classify_rotation_(1.0f, 0.0f)
19      , skew_(1.0f, 0.0f) {
20    ICOORDELT_IT left_it = &pdblk.leftside;
21    ICOORDELT_IT right_it = &pdblk.rightside;
22    proportional = prop;
23    kerning = kern;
24    spacing = space;
25    font_class = -1; 
26    cell_over_xheight_ = 2.0f;
27    pdblk.hand_poly = nullptr;
28    left_it.set_to_list(&pdblk.leftside);
29    right_it.set_to_list(&pdblk.rightside);
30    left_it.add_to_end(new ICOORDELT(xmin, ymin));
31    left_it.add_to_end(new ICOORDELT(xmin, ymax));
32    right_it.add_to_end(new ICOORDELT(xmax, ymin));
33    right_it.add_to_end(new ICOORDELT(xmax, ymax));
34  }
35  static int decreasing_top_order(const void *row1, const void *row2) {
<span onclick='openModal()' class='match'>36    return (*reinterpret_cast<ROW *const *>(row2))->bounding_box().top() -
37           (*reinterpret_cast<ROW *const *>(row1))->bounding_box().top();
38  }
39  void BLOCK::rotate(const FCOORD &rotation) {
</span>40    pdblk.poly_block()->rotate(rotation);
41    pdblk.box = *pdblk.poly_block()->bounding_box();
42  }
43  TBOX BLOCK::restricted_bounding_box(bool upper_dots, bool lower_dots) const {
44    TBOX box;
45    ROW_IT it(const_cast<ROW_LIST *>(&rows));
46    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
47      box += it.data()->restricted_bounding_box(upper_dots, lower_dots);
48    }
49    return box;
50  }
51  void BLOCK::reflect_polygon_in_y_axis() {
52    pdblk.poly_block()->reflect_in_y_axis();
53    pdblk.box = *pdblk.poly_block()->bounding_box();
54  }
55  void BLOCK::sort_rows() { 
56    ROW_IT row_it(&rows);
57    row_it.sort(decreasing_top_order);
58  }
59  void BLOCK::compress() { 
60  #define ROW_SPACING 5
61    ROW_IT row_it(&rows);
62    ROW *row;
63    ICOORD row_spacing(0, ROW_SPACING);
64    ICOORDELT_IT icoordelt_it;
65    sort_rows();
66    pdblk.box = TBOX(pdblk.box.topleft(), pdblk.box.topleft());
67    pdblk.box.move_bottom_edge(ROW_SPACING);
68    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
69      row = row_it.data();
70      row->move(pdblk.box.botleft() - row_spacing - row->bounding_box().topleft());
71      pdblk.box += row->bounding_box();
72    }
73    pdblk.leftside.clear();
74    icoordelt_it.set_to_list(&pdblk.leftside);
75    icoordelt_it.add_to_end(new ICOORDELT(pdblk.box.left(), pdblk.box.bottom()));
76    icoordelt_it.add_to_end(new ICOORDELT(pdblk.box.left(), pdblk.box.top()));
77    pdblk.rightside.clear();
78    icoordelt_it.set_to_list(&pdblk.rightside);
79    icoordelt_it.add_to_end(new ICOORDELT(pdblk.box.right(), pdblk.box.bottom()));
80    icoordelt_it.add_to_end(new ICOORDELT(pdblk.box.right(), pdblk.box.top()));
81  }
82  void BLOCK::check_pitch() { 
83    pitch = -1;
84  }
85  void BLOCK::compress( 
86      const ICOORD vec  
87  ) {
88    pdblk.box.move(vec);
89    compress();
90  }
91  void BLOCK::print( 
92      FILE *,        
93      bool dump      
94  ) {
95    ICOORDELT_IT it = &pdblk.leftside; 
96    pdblk.box.print();
97    tprintf("Proportional= %s\n", proportional ? "TRUE" : "FALSE");
98    tprintf("Kerning= %d\n", kerning);
99    tprintf("Spacing= %d\n", spacing);
100    tprintf("Fixed_pitch=%d\n", pitch);
101    tprintf("Filename= %s\n", filename.c_str());
102    if (dump) {
103      tprintf("Left side coords are:\n");
104      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
105        tprintf("(%d,%d) ", it.data()->x(), it.data()->y());
106      }
107      tprintf("\n");
108      tprintf("Right side coords are:\n");
109      it.set_to_list(&pdblk.rightside);
110      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
111        tprintf("(%d,%d) ", it.data()->x(), it.data()->y());
112      }
113      tprintf("\n");
114    }
115  }
116  BLOCK &BLOCK::operator=( 
117      const BLOCK &source  
118  ) {
119    this->ELIST_LINK::operator=(source);
120    pdblk = source.pdblk;
121    proportional = source.proportional;
122    kerning = source.kerning;
123    spacing = source.spacing;
124    filename = source.filename; 
125    if (!rows.empty()) {
126      rows.clear();
127    }
128    re_rotation_ = source.re_rotation_;
129    classify_rotation_ = source.classify_rotation_;
130    skew_ = source.skew_;
131    return *this;
132  }
133  static bool LeftMargin(ICOORDELT_LIST *segments, int x, int *margin) {
134    bool found = false;
135    *margin = 0;
136    if (segments->empty()) {
137      return found;
138    }
139    ICOORDELT_IT seg_it(segments);
140    for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
141      int cur_margin = x - seg_it.data()->x();
142      if (cur_margin >= 0) {
143        if (!found) {
144          *margin = cur_margin;
145        } else if (cur_margin < *margin) {
146          *margin = cur_margin;
147        }
148        found = true;
149      }
150    }
151    return found;
152  }
153  static bool RightMargin(ICOORDELT_LIST *segments, int x, int *margin) {
154    bool found = false;
155    *margin = 0;
156    if (segments->empty()) {
157      return found;
158    }
159    ICOORDELT_IT seg_it(segments);
160    for (seg_it.mark_cycle_pt(); !seg_it.cycled_list(); seg_it.forward()) {
161      int cur_margin = seg_it.data()->x() + seg_it.data()->y() - x;
162      if (cur_margin >= 0) {
163        if (!found) {
164          *margin = cur_margin;
165        } else if (cur_margin < *margin) {
166          *margin = cur_margin;
167        }
168        found = true;
169      }
170    }
171    return found;
172  }
173  void BLOCK::compute_row_margins() {
174    if (row_list()->empty() || row_list()->singleton()) {
175      return;
176    }
177    POLY_BLOCK rect_block(pdblk.bounding_box(), PT_FLOWING_TEXT);
178    POLY_BLOCK *pblock = &rect_block;
179    if (pdblk.poly_block() != nullptr) {
180      pblock = pdblk.poly_block();
181    }
182    ROW_IT r_it(row_list());
183    ROW *first_row = r_it.data();
184    ROW *second_row = r_it.data_relative(1);
185    int drop_cap_bottom = first_row->bounding_box().top() + first_row->bounding_box().height();
186    int drop_cap_right = first_row->bounding_box().left();
187    int mid_second_line = second_row->bounding_box().top() - second_row->bounding_box().height() / 2;
188    WERD_IT werd_it(r_it.data()->word_list()); 
189    if (!werd_it.empty()) {
190      C_BLOB_IT cblob_it(werd_it.data()->cblob_list());
191      for (cblob_it.mark_cycle_pt(); !cblob_it.cycled_list(); cblob_it.forward()) {
192        TBOX bbox = cblob_it.data()->bounding_box();
193        if (bbox.bottom() <= mid_second_line) {
194          first_row->set_has_drop_cap(true);
195          if (drop_cap_bottom > bbox.bottom()) {
196            drop_cap_bottom = bbox.bottom();
197          }
198          if (drop_cap_right < bbox.right()) {
199            drop_cap_right = bbox.right();
200          }
201        }
202      }
203    }
204    PB_LINE_IT lines(pblock);
205    r_it.set_to_list(row_list());
206    for (r_it.mark_cycle_pt(); !r_it.cycled_list(); r_it.forward()) {
207      ROW *row = r_it.data();
208      TBOX row_box = row->bounding_box();
209      int left_y = row->base_line(row_box.left()) + row->x_height();
210      int left_margin;
211      const std::unique_ptr<&bsol;*non-const*/ ICOORDELT_LIST> segments_left(lines.get_line(left_y));
212      LeftMargin(segments_left.get(), row_box.left(), &left_margin);
213      if (row_box.top() >= drop_cap_bottom) {
214        int drop_cap_distance = row_box.left() - row->space() - drop_cap_right;
215        if (drop_cap_distance < 0) {
216          drop_cap_distance = 0;
217        }
218        if (drop_cap_distance < left_margin) {
219          left_margin = drop_cap_distance;
220        }
221      }
222      int right_y = row->base_line(row_box.right()) + row->x_height();
223      int right_margin;
224      const std::unique_ptr<&bsol;*non-const*/ ICOORDELT_LIST> segments_right(lines.get_line(right_y));
225      RightMargin(segments_right.get(), row_box.right(), &right_margin);
226      row->set_lmargin(left_margin);
227      row->set_rmargin(right_margin);
228    }
229  }
230  void PrintSegmentationStats(BLOCK_LIST *block_list) {
231    int num_blocks = 0;
232    int num_rows = 0;
233    int num_words = 0;
234    int num_blobs = 0;
235    BLOCK_IT block_it(block_list);
236    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
237      BLOCK *block = block_it.data();
238      ++num_blocks;
239      ROW_IT row_it(block->row_list());
240      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
241        ++num_rows;
242        ROW *row = row_it.data();
243        WERD_IT werd_it(row->word_list());
244        for (werd_it.mark_cycle_pt(); !werd_it.cycled_list(); werd_it.forward()) {
245          WERD *werd = werd_it.data();
246          ++num_words;
247          num_blobs += werd->cblob_list()->length();
248        }
249      }
250    }
251    tprintf("Block list stats:\nBlocks = %d\nRows = %d\nWords = %d\nBlobs = %d\n", num_blocks,
252            num_rows, num_words, num_blobs);
253  }
254  void ExtractBlobsFromSegmentation(BLOCK_LIST *blocks, C_BLOB_LIST *output_blob_list) {
255    C_BLOB_IT return_list_it(output_blob_list);
256    BLOCK_IT block_it(blocks);
257    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
258      BLOCK *block = block_it.data();
259      ROW_IT row_it(block->row_list());
260      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
261        ROW *row = row_it.data();
262        WERD_IT werd_it(row->word_list());
263        for (werd_it.mark_cycle_pt(); !werd_it.cycled_list(); werd_it.forward()) {
264          WERD *werd = werd_it.data();
265          return_list_it.move_to_last();
266          return_list_it.add_list_after(werd->cblob_list());
267          return_list_it.move_to_last();
268          return_list_it.add_list_after(werd->rej_cblob_list());
269        }
270      }
271    }
272  }
273  void RefreshWordBlobsFromNewBlobs(BLOCK_LIST *block_list, C_BLOB_LIST *new_blobs,
274                                    C_BLOB_LIST *not_found_blobs) {
275    BLOCK_IT block_it(block_list);
276    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
277      BLOCK *block = block_it.data();
278      if (block->pdblk.poly_block() != nullptr && !block->pdblk.poly_block()->IsText()) {
279        continue; 
280      }
281      ROW_IT row_it(block->row_list());
282      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
283        ROW *row = row_it.data();
284        WERD_IT werd_it(row->word_list());
285        WERD_LIST new_words;
286        WERD_IT new_words_it(&new_words);
287        for (werd_it.mark_cycle_pt(); !werd_it.cycled_list(); werd_it.forward()) {
288          WERD *werd = werd_it.extract();
289          WERD *new_werd = werd->ConstructWerdWithNewBlobs(new_blobs, not_found_blobs);
290          if (new_werd) {
291            new_words_it.add_after_then_move(new_werd);
292            delete werd;
293          } else {
294            new_words_it.add_after_then_move(werd);
295          }
296        }
297        row->word_list()->clear();
298        werd_it.move_to_first();
299        werd_it.add_list_after(&new_words);
300      }
301    }
302  }
303  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ratngs.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "ratngs.h"
5  #include "blobs.h"
6  #include "matrix.h"
7  #include "normalis.h" 
8  #include "unicharset.h"
9  #include <algorithm>
10  #include <cmath>
11  #include <string>
12  #include <vector>
13  namespace tesseract {
14  const float WERD_CHOICE::kBadRating = 100000.0;
15  const int kMinSubscriptOffset = 20;
16  const int kMinSuperscriptOffset = 20;
17  const int kMaxDropCapBottom = -128;
18  const double kMaxOverlapDenominator = 0.125;
19  const double kMinXHeightMatch = 0.5;
20  const double kMaxBaselineDrift = 0.0625;
21  static const char kPermuterTypeNoPerm[] = "None";
22  static const char kPermuterTypePuncPerm[] = "Punctuation";
23  static const char kPermuterTypeTopPerm[] = "Top Choice";
24  static const char kPermuterTypeLowerPerm[] = "Top Lower Case";
25  static const char kPermuterTypeUpperPerm[] = "Top Upper Case";
26  static const char kPermuterTypeNgramPerm[] = "Ngram";
27  static const char kPermuterTypeNumberPerm[] = "Number";
28  static const char kPermuterTypeUserPatPerm[] = "User Pattern";
29  static const char kPermuterTypeSysDawgPerm[] = "System Dictionary";
30  static const char kPermuterTypeDocDawgPerm[] = "Document Dictionary";
31  static const char kPermuterTypeUserDawgPerm[] = "User Dictionary";
32  static const char kPermuterTypeFreqDawgPerm[] = "Frequent Words Dictionary";
33  static const char kPermuterTypeCompoundPerm[] = "Compound";
34  static const char *const kPermuterTypeNames[] = {
35      kPermuterTypeNoPerm,       
36      kPermuterTypePuncPerm,     
37      kPermuterTypeTopPerm,      
38      kPermuterTypeLowerPerm,    
39      kPermuterTypeUpperPerm,    
40      kPermuterTypeNgramPerm,    
41      kPermuterTypeNumberPerm,   
42      kPermuterTypeUserPatPerm,  
43      kPermuterTypeSysDawgPerm,  
44      kPermuterTypeDocDawgPerm,  
45      kPermuterTypeUserDawgPerm, 
46      kPermuterTypeFreqDawgPerm, 
47      kPermuterTypeCompoundPerm  
48  };
49  BLOB_CHOICE::BLOB_CHOICE(UNICHAR_ID src_unichar_id, 
50                           float src_rating,          
51                           float src_cert,            
52                           int src_script_id,         
53                           float min_xheight,         
54                           float max_xheight,         
55                           float yshift,              
56                           BlobChoiceClassifier c) {  
57    unichar_id_ = src_unichar_id;
58    rating_ = src_rating;
59    certainty_ = src_cert;
60    fontinfo_id_ = -1;
61    fontinfo_id2_ = -1;
62    script_id_ = src_script_id;
63    min_xheight_ = min_xheight;
64    max_xheight_ = max_xheight;
65    yshift_ = yshift;
66    classifier_ = c;
67  }
68  BLOB_CHOICE::BLOB_CHOICE(const BLOB_CHOICE &other) : ELIST_LINK(other) {
69    unichar_id_ = other.unichar_id();
70    rating_ = other.rating();
71    certainty_ = other.certainty();
72    fontinfo_id_ = other.fontinfo_id();
73    fontinfo_id2_ = other.fontinfo_id2();
74    script_id_ = other.script_id();
75    matrix_cell_ = other.matrix_cell_;
76    min_xheight_ = other.min_xheight_;
77    max_xheight_ = other.max_xheight_;
78    yshift_ = other.yshift();
79    classifier_ = other.classifier_;
80  #ifndef DISABLED_LEGACY_ENGINE
81    fonts_ = other.fonts_;
82  #endif 
83  }
84  BLOB_CHOICE &BLOB_CHOICE::operator=(const BLOB_CHOICE &other) {
85    ELIST_LINK::operator=(other);
86    unichar_id_ = other.unichar_id();
87    rating_ = other.rating();
88    certainty_ = other.certainty();
89    fontinfo_id_ = other.fontinfo_id();
90    fontinfo_id2_ = other.fontinfo_id2();
91    script_id_ = other.script_id();
92    matrix_cell_ = other.matrix_cell_;
93    min_xheight_ = other.min_xheight_;
94    max_xheight_ = other.max_xheight_;
95    yshift_ = other.yshift();
96    classifier_ = other.classifier_;
97  #ifndef DISABLED_LEGACY_ENGINE
98    fonts_ = other.fonts_;
99  #endif 
100    return *this;
101  }
102  bool BLOB_CHOICE::PosAndSizeAgree(const BLOB_CHOICE &other, float x_height, bool debug) const {
103    double baseline_diff = std::fabs(yshift() - other.yshift());
104    if (baseline_diff > kMaxBaselineDrift * x_height) {
105      if (debug) {
106        tprintf("Baseline diff %g for %d v %d\n", baseline_diff, unichar_id_, other.unichar_id_);
107      }
108      return false;
109    }
110    double this_range = max_xheight() - min_xheight();
111    double other_range = other.max_xheight() - other.min_xheight();
112    double denominator =
113        ClipToRange(std::min(this_range, other_range), 1.0, kMaxOverlapDenominator * x_height);
114    double overlap =
115        std::min(max_xheight(), other.max_xheight()) - std::max(min_xheight(), other.min_xheight());
116    overlap /= denominator;
117    if (debug) {
118      tprintf("PosAndSize for %d v %d: bl diff = %g, ranges %g, %g / %g ->%g\n", unichar_id_,
119              other.unichar_id_, baseline_diff, this_range, other_range, denominator, overlap);
120    }
121    return overlap >= kMinXHeightMatch;
122  }
123  BLOB_CHOICE *FindMatchingChoice(UNICHAR_ID char_id, BLOB_CHOICE_LIST *bc_list) {
124    BLOB_CHOICE_IT choice_it(bc_list);
125    for (choice_it.mark_cycle_pt(); !choice_it.cycled_list(); choice_it.forward()) {
126      BLOB_CHOICE *choice = choice_it.data();
127      if (choice->unichar_id() == char_id) {
128        return choice;
129      }
130    }
131    return nullptr;
132  }
133  const char *WERD_CHOICE::permuter_name(uint8_t permuter) {
134    return kPermuterTypeNames[permuter];
135  }
136  const char *ScriptPosToString(enum ScriptPos script_pos) {
137    switch (script_pos) {
138      case SP_NORMAL:
139        return "NORM";
140      case SP_SUBSCRIPT:
141        return "SUB";
142      case SP_SUPERSCRIPT:
143        return "SUPER";
144      case SP_DROPCAP:
145        return "DROPC";
146    }
147    return "SP_UNKNOWN";
148  }
149  WERD_CHOICE::WERD_CHOICE(const char *src_string, const UNICHARSET &unicharset)
150      : unicharset_(&unicharset) {
151    std::vector<UNICHAR_ID> encoding;
152    std::vector<char> lengths;
153    std::string cleaned = unicharset.CleanupString(src_string);
154    if (unicharset.encode_string(cleaned.c_str(), true, &encoding, &lengths, nullptr)) {
155      lengths.push_back('\0');
156      std::string src_lengths = &lengths[0];
157      this->init(cleaned.c_str(), src_lengths.c_str(), 0.0, 0.0, NO_PERM);
158    } else { 
159      this->init(8);
160      this->make_bad();
161    }
162  }
163  void WERD_CHOICE::init(const char *src_string, const char *src_lengths, float src_rating,
164                         float src_certainty, uint8_t src_permuter) {
165    int src_string_len = strlen(src_string);
166    if (src_string_len == 0) {
167      this->init(8);
168    } else {
169      this->init(src_lengths ? strlen(src_lengths) : src_string_len);
170      length_ = reserved_;
171      int offset = 0;
172      for (unsigned i = 0; i < length_; ++i) {
173        int unichar_length = src_lengths ? src_lengths[i] : 1;
174        unichar_ids_[i] = unicharset_->unichar_to_id(src_string + offset, unichar_length);
175        state_[i] = 1;
176        certainties_[i] = src_certainty;
177        offset += unichar_length;
178      }
179    }
180    adjust_factor_ = 1.0f;
181    rating_ = src_rating;
182    certainty_ = src_certainty;
183    permuter_ = src_permuter;
184    dangerous_ambig_found_ = false;
185  }
186  WERD_CHOICE::~WERD_CHOICE() = default;
187  const char *WERD_CHOICE::permuter_name() const {
188    return kPermuterTypeNames[permuter_];
189  }
190  BLOB_CHOICE_LIST *WERD_CHOICE::blob_choices(unsigned index, MATRIX *ratings) const {
191    MATRIX_COORD coord = MatrixCoord(index);
192    BLOB_CHOICE_LIST *result = ratings->get(coord.col, coord.row);
193    if (result == nullptr) {
194      result = new BLOB_CHOICE_LIST;
195      ratings->put(coord.col, coord.row, result);
196    }
197    return result;
198  }
199  MATRIX_COORD WERD_CHOICE::MatrixCoord(unsigned index) const {
200    int col = 0;
201    for (unsigned i = 0; i < index; ++i) {
202      col += state_[i];
203    }
204    int row = col + state_[index] - 1;
205    return MATRIX_COORD(col, row);
206  }
207  void WERD_CHOICE::set_blob_choice(unsigned index, int blob_count, const BLOB_CHOICE *blob_choice) {
208    unichar_ids_[index] = blob_choice->unichar_id();
209    script_pos_[index] = tesseract::SP_NORMAL;
210    state_[index] = blob_count;
211    certainties_[index] = blob_choice->certainty();
212  }
213  bool WERD_CHOICE::contains_unichar_id(UNICHAR_ID unichar_id) const {
214    for (unsigned i = 0; i < length_; ++i) {
215      if (unichar_ids_[i] == unichar_id) {
216        return true;
217      }
218    }
219    return false;
220  }
221  void WERD_CHOICE::remove_unichar_ids(unsigned start, int num) {
222    ASSERT_HOST(start + num <= length_);
223    for (int i = 0; i < num; ++i) {
224      if (start > 0) {
225        state_[start - 1] += state_[start + i];
226      } else if (start + num < length_) {
227        state_[start + num] += state_[start + i];
228      }
229    }
230    for (unsigned i = start; i + num < length_; ++i) {
231      unichar_ids_[i] = unichar_ids_[i + num];
232      script_pos_[i] = script_pos_[i + num];
233      state_[i] = state_[i + num];
234      certainties_[i] = certainties_[i + num];
235    }
236    length_ -= num;
237  }
238  void WERD_CHOICE::reverse_and_mirror_unichar_ids() {
239    for (unsigned i = 0; i < length_ / 2; ++i) {
240      UNICHAR_ID tmp_id = unichar_ids_[i];
241      unichar_ids_[i] = unicharset_->get_mirror(unichar_ids_[length_ - 1 - i]);
242      unichar_ids_[length_ - 1 - i] = unicharset_->get_mirror(tmp_id);
243    }
244    if (length_ % 2 != 0) {
245      unichar_ids_[length_ / 2] = unicharset_->get_mirror(unichar_ids_[length_ / 2]);
246    }
247  }
248  void WERD_CHOICE::punct_stripped(unsigned *start, unsigned *end) const {
249    *start = 0;
250    *end = length();
251    while (*start < length() && unicharset()->get_ispunctuation(unichar_id(*start))) {
252      (*start)++;
253    }
254    while (*end > 0 && unicharset()->get_ispunctuation(unichar_id(*end - 1))) {
255      (*end)--;
256    }
257  }
258  void WERD_CHOICE::GetNonSuperscriptSpan(int *pstart, int *pend) const {
259    int end = length();
260    while (end > 0 && unicharset_->get_isdigit(unichar_ids_[end - 1]) &&
261           BlobPosition(end - 1) == tesseract::SP_SUPERSCRIPT) {
262      end--;
263    }
264    int start = 0;
265    while (start < end && unicharset_->get_isdigit(unichar_ids_[start]) &&
266           BlobPosition(start) == tesseract::SP_SUPERSCRIPT) {
267      start++;
268    }
269    *pstart = start;
270    *pend = end;
271  }
272  WERD_CHOICE WERD_CHOICE::shallow_copy(unsigned start, unsigned end) const {
273    ASSERT_HOST(start <= length_);
274    ASSERT_HOST(end <= length_);
275    if (end < start) {
276      end = start;
277    }
278    WERD_CHOICE retval(unicharset_, end - start);
279    for (auto i = start; i < end; i++) {
280      retval.append_unichar_id_space_allocated(unichar_ids_[i], state_[i], 0.0f, certainties_[i]);
281    }
282    return retval;
283  }
284  bool WERD_CHOICE::has_rtl_unichar_id() const {
285    for (unsigned i = 0; i < length_; ++i) {
286      UNICHARSET::Direction dir = unicharset_->get_direction(unichar_ids_[i]);
287      if (dir == UNICHARSET::U_RIGHT_TO_LEFT || dir == UNICHARSET::U_RIGHT_TO_LEFT_ARABIC) {
288        return true;
289      }
290    }
291    return false;
292  }
293  void WERD_CHOICE::string_and_lengths(std::string *word_str, std::string *word_lengths_str) const {
294    *word_str = "";
295    if (word_lengths_str != nullptr) {
296      *word_lengths_str = "";
297    }
298    for (unsigned i = 0; i < length_; ++i) {
299      const char *ch = unicharset_->id_to_unichar_ext(unichar_ids_[i]);
300      *word_str += ch;
301      if (word_lengths_str != nullptr) {
302        *word_lengths_str += (char)strlen(ch);
303      }
304    }
305  }
306  void WERD_CHOICE::append_unichar_id(UNICHAR_ID unichar_id, int blob_count, float rating,
307                                      float certainty) {
308    if (length_ == reserved_) {
309      this->double_the_size();
310    }
311    this->append_unichar_id_space_allocated(unichar_id, blob_count, rating, certainty);
312  }
313  WERD_CHOICE &WERD_CHOICE::operator+=(const WERD_CHOICE &second) {
314    ASSERT_HOST(unicharset_ == second.unicharset_);
315    while (reserved_ < length_ + second.length()) {
316      this->double_the_size();
317    }
318    const std::vector<UNICHAR_ID> &other_unichar_ids = second.unichar_ids();
319    for (unsigned i = 0; i < second.length(); ++i) {
320      unichar_ids_[length_ + i] = other_unichar_ids[i];
321      state_[length_ + i] = second.state_[i];
322      certainties_[length_ + i] = second.certainties_[i];
323      script_pos_[length_ + i] = second.BlobPosition(i);
324    }
325    length_ += second.length();
326    if (second.adjust_factor_ > adjust_factor_) {
327      adjust_factor_ = second.adjust_factor_;
328    }
329    rating_ += second.rating();            
330    if (second.certainty() < certainty_) { 
331      certainty_ = second.certainty();
332    }
333    if (second.dangerous_ambig_found_) {
334      dangerous_ambig_found_ = true;
335    }
336    if (permuter_ == NO_PERM) {
337      permuter_ = second.permuter();
338    } else if (second.permuter() != NO_PERM && second.permuter() != permuter_) {
339      permuter_ = COMPOUND_PERM;
340    }
341    return *this;
342  }
343  WERD_CHOICE &WERD_CHOICE::operator=(const WERD_CHOICE &source) {
344    while (reserved_ < source.length()) {
345      this->double_the_size();
346    }
347    unicharset_ = source.unicharset_;
348    const std::vector<UNICHAR_ID> &other_unichar_ids = source.unichar_ids();
349    for (unsigned i = 0; i < source.length(); ++i) {
350      unichar_ids_[i] = other_unichar_ids[i];
351      state_[i] = source.state_[i];
352      certainties_[i] = source.certainties_[i];
353      script_pos_[i] = source.BlobPosition(i);
354    }
355    length_ = source.length();
356    adjust_factor_ = source.adjust_factor_;
357    rating_ = source.rating();
358    certainty_ = source.certainty();
359    min_x_height_ = source.min_x_height();
360    max_x_height_ = source.max_x_height();
361    permuter_ = source.permuter();
362    dangerous_ambig_found_ = source.dangerous_ambig_found_;
363    return *this;
364  }
365  void WERD_CHOICE::SetScriptPositions(bool small_caps, TWERD *word, int debug) {
366    for (unsigned i = 0; i < length_; ++i) {
367      script_pos_[i] = tesseract::SP_NORMAL;
368    }
369    if (word->blobs.empty() || word->NumBlobs() != TotalOfStates()) {
370      return;
371    }
372    unsigned position_counts[4] = {0, 0, 0, 0};
373    int chunk_index = 0;
374    for (unsigned blob_index = 0; blob_index < length_; ++blob_index, ++chunk_index) {
375      TBLOB *tblob = word->blobs[chunk_index];
376      int uni_id = unichar_id(blob_index);
377      TBOX blob_box = tblob->bounding_box();
378      if (!state_.empty()) {
379        for (int i = 1; i < state_[blob_index]; ++i) {
380          ++chunk_index;
381          tblob = word->blobs[chunk_index];
382          blob_box += tblob->bounding_box();
383        }
384      }
385      script_pos_[blob_index] = ScriptPositionOf(false, *unicharset_, blob_box, uni_id);
386      if (small_caps && script_pos_[blob_index] != tesseract::SP_DROPCAP) {
387        script_pos_[blob_index] = tesseract::SP_NORMAL;
388      }
389      position_counts[script_pos_[blob_index]]++;
390    }
391    if (4 * position_counts[tesseract::SP_SUBSCRIPT] > 3 * length_ ||
392        4 * position_counts[tesseract::SP_SUPERSCRIPT] > 3 * length_) {
393      if (debug >= 2) {
394        tprintf(
395            "Most characters of %s are subscript or superscript.\n"
396            "That seems wrong, so I'll assume we got the baseline wrong\n",
397            unichar_string().c_str());
398      }
399      for (unsigned i = 0; i < length_; i++) {
400        ScriptPos sp = script_pos_[i];
401        if (sp == tesseract::SP_SUBSCRIPT || sp == tesseract::SP_SUPERSCRIPT) {
402          ASSERT_HOST(position_counts[sp] > 0);
403          position_counts[sp]--;
404          position_counts[tesseract::SP_NORMAL]++;
405          script_pos_[i] = tesseract::SP_NORMAL;
406        }
407      }
408    }
409    if ((debug >= 1 && position_counts[tesseract::SP_NORMAL] < length_) || debug >= 2) {
410      tprintf("SetScriptPosition on %s\n", unichar_string().c_str());
411      int chunk_index = 0;
412      for (unsigned blob_index = 0; blob_index < length_; ++blob_index) {
413        if (debug >= 2 || script_pos_[blob_index] != tesseract::SP_NORMAL) {
414          TBLOB *tblob = word->blobs[chunk_index];
415          ScriptPositionOf(true, *unicharset_, tblob->bounding_box(), unichar_id(blob_index));
416        }
417        chunk_index += state_.empty() ? 1 : state_[blob_index];
418      }
419    }
420  }
421  void WERD_CHOICE::SetAllScriptPositions(tesseract::ScriptPos position) {
422    for (unsigned i = 0; i < length_; ++i) {
423      script_pos_[i] = position;
424    }
425  }
426  ScriptPos WERD_CHOICE::ScriptPositionOf(bool print_debug, const UNICHARSET &unicharset,
427                                          const TBOX &blob_box, UNICHAR_ID unichar_id) {
428    ScriptPos retval = tesseract::SP_NORMAL;
429    int top = blob_box.top();
430    int bottom = blob_box.bottom();
431    int min_bottom, max_bottom, min_top, max_top;
432    unicharset.get_top_bottom(unichar_id, &min_bottom, &max_bottom, &min_top, &max_top);
433    int sub_thresh_top = min_top - kMinSubscriptOffset;
434    int sub_thresh_bot = kBlnBaselineOffset - kMinSubscriptOffset;
435    int sup_thresh_bot = max_bottom + kMinSuperscriptOffset;
436    if (bottom <= kMaxDropCapBottom) {
437      retval = tesseract::SP_DROPCAP;
438    } else if (top < sub_thresh_top && bottom < sub_thresh_bot) {
439      retval = tesseract::SP_SUBSCRIPT;
440    } else if (bottom > sup_thresh_bot) {
441      retval = tesseract::SP_SUPERSCRIPT;
442    }
443    if (print_debug) {
444      const char *pos = ScriptPosToString(retval);
445      tprintf(
446          "%s Character %s[bot:%d top: %d]  "
447          "bot_range[%d,%d]  top_range[%d, %d] "
448          "sub_thresh[bot:%d top:%d]  sup_thresh_bot %d\n",
449          pos, unicharset.id_to_unichar(unichar_id), bottom, top, min_bottom, max_bottom, min_top,
450          max_top, sub_thresh_bot, sub_thresh_top, sup_thresh_bot);
451    }
452    return retval;
453  }
454  int WERD_CHOICE::GetTopScriptID() const {
455    unsigned max_script = unicharset_->get_script_table_size();
456    std::vector<unsigned> sid(max_script);
457    for (unsigned x = 0; x < length_; ++x) {
458      int script_id = unicharset_->get_script(unichar_id(x));
459      sid[script_id]++;
460    }
461    if (unicharset_->han_sid() != unicharset_->null_sid()) {
462      if (unicharset_->hiragana_sid() != unicharset_->null_sid()) {
463        sid[unicharset_->han_sid()] += sid[unicharset_->hiragana_sid()];
464        sid[unicharset_->hiragana_sid()] = 0;
465      }
466      if (unicharset_->katakana_sid() != unicharset_->null_sid()) {
467        sid[unicharset_->han_sid()] += sid[unicharset_->katakana_sid()];
468        sid[unicharset_->katakana_sid()] = 0;
469      }
470    }
471    unsigned max_sid = 0;
472    for (unsigned x = 1; x < max_script; x++) {
473      if (sid[x] >= sid[max_sid]) {
474        max_sid = x;
475      }
476    }
477    if (sid[max_sid] < length_ / 2) {
478      max_sid = unicharset_->null_sid();
479    }
480    return max_sid;
481  }
482  void WERD_CHOICE::UpdateStateForSplit(int blob_position) {
483    int total_chunks = 0;
484    for (unsigned i = 0; i < length_; ++i) {
485      total_chunks += state_[i];
486      if (total_chunks > blob_position) {
487        ++state_[i];
488        return;
489      }
490    }
491  }
492  unsigned WERD_CHOICE::TotalOfStates() const {
493    unsigned total_chunks = 0;
494    for (unsigned i = 0; i < length_; ++i) {
495      total_chunks += state_[i];
496    }
497    return total_chunks;
498  }
499  void WERD_CHOICE::print(const char *msg) const {
500    tprintf("%s : ", msg);
501    for (unsigned i = 0; i < length_; ++i) {
502      tprintf("%s", unicharset_->id_to_unichar(unichar_ids_[i]));
503    }
504    tprintf(" : R=%g, C=%g, F=%g, Perm=%d, xht=[%g,%g], ambig=%d\n", rating_, certainty_,
505            adjust_factor_, permuter_, min_x_height_, max_x_height_, dangerous_ambig_found_);
506    tprintf("pos");
507    for (unsigned i = 0; i < length_; ++i) {
508      tprintf("\t%s", ScriptPosToString(script_pos_[i]));
509    }
510    tprintf("\nstr");
511    for (unsigned i = 0; i < length_; ++i) {
512      tprintf("\t%s", unicharset_->id_to_unichar(unichar_ids_[i]));
513    }
514    tprintf("\nstate:");
515    for (unsigned i = 0; i < length_; ++i) {
516      tprintf("\t%d ", state_[i]);
517    }
518    tprintf("\nC");
519    for (unsigned i = 0; i < length_; ++i) {
520      tprintf("\t%.3f", certainties_[i]);
521    }
522    tprintf("\n");
523  }
524  void WERD_CHOICE::print_state(const char *msg) const {
525    tprintf("%s", msg);
526    for (unsigned i = 0; i < length_; ++i) {
527      tprintf(" %d", state_[i]);
528    }
529    tprintf("\n");
530  }
531  #ifndef GRAPHICS_DISABLED
532  void WERD_CHOICE::DisplaySegmentation(TWERD *word) {
533    const int kNumColors = 6;
534    static ScrollView *segm_window = nullptr;
535    static std::vector<int> prev_drawn_state;
536    bool already_done = prev_drawn_state.size() == length_;
537    if (!already_done) {
538      prev_drawn_state.clear();
539      prev_drawn_state.resize(length_);
540    }
541    for (unsigned i = 0; i < length_; ++i) {
542      if (prev_drawn_state[i] != state_[i]) {
543        already_done = false;
544      }
545      prev_drawn_state[i] = state_[i];
546    }
547    if (already_done || word->blobs.empty()) {
548      return;
549    }
550    if (segm_window == nullptr) {
551      segm_window = new ScrollView("Segmentation", 5, 10, 500, 256, 2000.0, 256.0, true);
552    } else {
553      segm_window->Clear();
554    }
555    TBOX bbox;
556    int blob_index = 0;
557    for (unsigned c = 0; c < length_; ++c) {
558      auto color = static_cast<ScrollView::Color>(c % kNumColors + 3);
559      for (int i = 0; i < state_[c]; ++i, ++blob_index) {
560        TBLOB *blob = word->blobs[blob_index];
561        bbox += blob->bounding_box();
562        blob->plot(segm_window, color, color);
563      }
564    }
<span onclick='openModal()' class='match'>565    segm_window->ZoomToRectangle(bbox.left(), bbox.top(), bbox.right(), bbox.bottom());
566    segm_window->Update();
567    segm_window->Wait();
568  }
569  #endif 
570  bool EqualIgnoringCaseAndTerminalPunct(const WERD_CHOICE &word1, const WERD_CHOICE &word2) {
</span>571    const UNICHARSET *uchset = word1.unicharset();
572    if (word2.unicharset() != uchset) {
573      return false;
574    }
575    unsigned w1start, w1end;
576    word1.punct_stripped(&w1start, &w1end);
577    unsigned w2start, w2end;
578    word2.punct_stripped(&w2start, &w2end);
579    if (w1end - w1start != w2end - w2start) {
580      return false;
581    }
582    for (unsigned i = 0; i < w1end - w1start; i++) {
583      if (uchset->to_lower(word1.unichar_id(w1start + i)) !=
584          uchset->to_lower(word2.unichar_id(w2start + i))) {
585        return false;
586      }
587    }
588    return true;
589  }
590  void print_ratings_list(const char *msg, BLOB_CHOICE_LIST *ratings,
591                          const UNICHARSET &current_unicharset) {
592    if (ratings->empty()) {
593      tprintf("%s:<none>\n", msg);
594      return;
595    }
596    if (*msg != '\0') {
597      tprintf("%s\n", msg);
598    }
599    BLOB_CHOICE_IT c_it;
600    c_it.set_to_list(ratings);
601    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
602      c_it.data()->print(&current_unicharset);
603      if (!c_it.at_last()) {
604        tprintf("\n");
605      }
606    }
607    tprintf("\n");
608    fflush(stdout);
609  }
610  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ocrblock.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ratngs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>36    return (*reinterpret_cast<ROW *const *>(row2))->bounding_box().top() -
37           (*reinterpret_cast<ROW *const *>(row1))->bounding_box().top();
38  }
39  void BLOCK::rotate(const FCOORD &rotation) {
</pre></code></div>
                <div class="column column_space"><pre><code>565    segm_window->ZoomToRectangle(bbox.left(), bbox.top(), bbox.right(), bbox.bottom());
566    segm_window->Update();
567    segm_window->Wait();
568  }
569  #endif 
570  bool EqualIgnoringCaseAndTerminalPunct(const WERD_CHOICE &word1, const WERD_CHOICE &word2) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    