
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.225806451612903%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-dummy_data_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #include "caffe/filler.hpp"
3  #include "caffe/layers/dummy_data_layer.hpp"
4  namespace caffe {
5  template <typename Dtype>
6  void DummyDataLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
7        const vector<Blob<Dtype>*>& top) {
8    const int num_top = top.size();
9    const DummyDataParameter& param = this->layer_param_.dummy_data_param();
10    const int num_data_filler = param.data_filler_size();
11    CHECK(num_data_filler == 0 || num_data_filler == 1 ||
12          num_data_filler == num_top)
13        << "Number of data fillers must be 0, 1 or equal to the number of tops: "
14        << num_top << "; you specified " << num_data_filler << " data fillers.";
15    const bool legacy_dims = param.num_size() || param.channels_size() ||
16                             param.height_size() || param.width_size();
17    if (legacy_dims) {
18      CHECK_EQ(0, param.shape_size())
19          << "Both shape and legacy fields were specified";
20      CHECK(param.num_size() == 1 || param.num_size() == num_top)
21          << "Must specify 'num' once, or once per top blob "
22          << "(" << num_top << "); specified " << param.num_size() << ".";
23      CHECK(param.channels_size() == 1 || param.channels_size() == num_top)
24          << "Must specify 'channels' once, or once per top blob "
25          << "(" << num_top << "); specified " << param.channels_size() << ".";
26      CHECK(param.height_size() == 1 || param.height_size() == num_top)
27          << "Must specify 'height' once, or once per top blob "
28          << "(" << num_top << "); specified " << param.height_size() << ".";
29      CHECK(param.width_size() == 1 || param.width_size() == num_top)
30          << "Must specify 'width' once, or once per top blob "
31          << "(" << num_top << "); specified " << param.width_size() << ".";
32    } else {
33      CHECK(param.shape_size() == 1 || param.shape_size() == num_top)
34          << "Must specify 'shape' once, or once per top blob "
35          << "(" << num_top << "); specified " << param.shape_size() << ".";
36    }
37    refill_.clear();
38    fillers_.clear();
39    if (num_data_filler <= 1) {
40      FillerParameter filler_param;
41      if (num_data_filler == 0) {
42        filler_param.set_type("constant");
43        filler_param.set_value(0);
44      } else {
45        filler_param.CopyFrom(param.data_filler(0));
46      }
47      refill_.resize(1);
48      refill_[0] = (strcmp(filler_param.type().c_str(), "constant") == 0);
49      fillers_.resize(1);
50      fillers_[0].reset(GetFiller<Dtype>(filler_param));
51    } else {
52      refill_.resize(num_top);
53      fillers_.resize(num_top);
54      for (int i = 0; i < num_top; ++i) {
55        fillers_[i].reset(GetFiller<Dtype>(param.data_filler(i)));
56        refill_[i] =
57            (strcmp(param.data_filler(i).type().c_str(), "constant") == 0);
58      }
59    }
60    for (int i = 0; i < num_top; ++i) {
61      if (legacy_dims) {
62        const int num = (param.num_size() == 1) ? param.num(0) : param.num(i);
63        const int channels =
64            (param.channels_size() == 1) ? param.channels(0) : param.channels(i);
65        const int height =
66            (param.height_size() == 1) ? param.height(0) : param.height(i);
67        const int width =
68            (param.width_size() == 1) ? param.width(0) : param.width(i);
69        top[i]->Reshape(num, channels, height, width);
70      } else {
71        const int shape_index = (param.shape_size() == 1) ? 0 : i;
72        top[i]->Reshape(param.shape(shape_index));
73      }
74    }
75    this->Forward(bottom, top);
76    for (int i = 0; i < refill_.size(); ++i) {
77      refill_[i] = !refill_[i];
78    }
79  }
80  template <typename Dtype>
<span onclick='openModal()' class='match'>81  void DummyDataLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
82        const vector<Blob<Dtype>*>& top) {
83    for (int i = 0; i < top.size(); ++i) {
84      const int filler_id = (fillers_.size() > 1) ? i : 0;
</span>85      if (refill_[filler_id]) {
86        fillers_[filler_id]->Fill(top[i]);
87      }
88    }
89  }
90  INSTANTIATE_CLASS(DummyDataLayer);
91  REGISTER_LAYER_CLASS(DummyData);
92  }  
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <numeric>
3  #include <sstream>
4  #include <string>
5  #include <vector>
6  #include <stdlib.h>
7  #include <time.h>
8  #include "string.h"
9  std::vector<std::string> split(const std::string &s, const std::string &seperator)
10  {
11      std::vector<std::string> result;
12      string_size i = 0;
13      while(i != s.size())
14      {
15          int flag = 0;
16          while(i != s.size() && flag == 0)
17          {
18              flag = 1;
19              for(string_size x = 0; x < seperator.size(); ++x)
20                  if(s[i] == seperator[x])
21                  {
22                      ++i;
23                      flag = 0;
24                      break;
25                  }
26          }
27          flag = 0;
28          string_size j = i;
29          while(j != s.size() && flag == 0)
30          {
31              for(string_size x = 0; x < seperator.size(); ++x)
32                  if(s[j] == seperator[x])
33                  {
34                      flag = 1;
35                      break;
36                  }
37              if(flag == 0)
38                  ++j;
39          }
40          if(i != j)
41          {
42              result.push_back(s.substr(i, j-i));
43              i = j;
44          }
45      }
46      return result;
47  }
<span onclick='openModal()' class='match'>48  std::string UTF8ToCodePoint(const std::string &data)
49  {
50      std::stringstream ss;
51      for(string_size i = 0; i < data.size(); i++)
52      {
53          int charcode = data[i] & 0xff;
</span>54          if((charcode >> 7) == 0)
55          {
56              ss<<data[i];
57          }
58          else if((charcode >> 5) == 6)
59          {
60              ss<<"\\u"<<std::hex<<((data[i + 1] & 0x3f) | (data[i] & 0x1f) << 6);
61              i++;
62          }
63          else if((charcode >> 4) == 14)
64          {
65              ss<<"\\u"<<std::hex<<((data[i + 2] & 0x3f) | (data[i + 1] & 0x3f) << 6 | (data[i] & 0xf) << 12);
66              i += 2;
67          }
68          else if((charcode >> 3) == 30)
69          {
70              ss<<"\\u"<<std::hex<<((data[i + 3] & 0x3f) | (data[i + 2] & 0x3f) << 6 | (data[i + 1] & 0x3f) << 12 | (data[i] & 0x7) << 18);
71              i += 3;
72          }
73      }
74      return ss.str();
75  }
76  std::string toLower(const std::string &str)
77  {
78      std::string result;
79      std::transform(str.begin(), str.end(), std::back_inserter(result), [](unsigned char c) { return std::tolower(c); });
80      return result;
81  }
82  std::string toUpper(const std::string &str)
83  {
84      std::string result;
85      std::transform(str.begin(), str.end(), std::back_inserter(result), [](unsigned char c) { return std::toupper(c); });
86      return result;
87  }
88  void processEscapeChar(std::string &str)
89  {
90      string_size pos = str.find('\\');
91      while(pos != str.npos)
92      {
93          if(pos == str.size())
94              break;
95          switch(str[pos + 1])
96          {
97          case 'n':
98              str.replace(pos, 2, "\n");
99              break;
100          case 'r':
101              str.replace(pos, 2, "\r");
102              break;
103          case 't':
104              str.replace(pos, 2, "\t");
105              break;
106          default:
107              break;
108          }
109          pos = str.find('\\', pos + 1);
110      }
111  }
112  void processEscapeCharReverse(std::string &str)
113  {
114      string_size pos = 0;
115      while(pos < str.size())
116      {
117          switch(str[pos])
118          {
119          case '\n':
120              str.replace(pos, 1, "\\n");
121              break;
122          case '\r':
123              str.replace(pos, 1, "\\r");
124              break;
125          case '\t':
126              str.replace(pos, 1, "\\t");
127              break;
128          default:
129              break;
130          }
131          pos++;
132      }
133  }
134  int parseCommaKeyValue(const std::string &input, const std::string &separator, string_pair_array &result)
135  {
136      string_size bpos = 0, epos = input.find(',');
137      std::string kv;
138      while(bpos < input.size())
139      {
140          if(epos == std::string::npos)
141              epos = input.size();
142          else if(epos && input[epos - 1] == '\\')
143          {
144              kv += input.substr(bpos, epos - bpos - 1);
145              kv += ',';
146              bpos = epos + 1;
147              epos = input.find(',', bpos);
148              continue;
149          }
150          kv += input.substr(bpos, epos - bpos);
151          string_size eqpos = kv.find('=');
152          if(eqpos == std::string::npos)
153              result.emplace_back("{NONAME}", kv);
154          else
155              result.emplace_back(kv.substr(0, eqpos), kv.substr(eqpos + 1));
156          kv.clear();
157          bpos = epos + 1;
158          epos = input.find(',', bpos);
159      }
160      if(kv.size())
161      {
162          string_size eqpos = kv.find('=');
163          if(eqpos == std::string::npos)
164              result.emplace_back("{NONAME}", kv);
165          else
166              result.emplace_back(kv.substr(0, eqpos), kv.substr(eqpos + 1));
167      }
168      return 0;
169  }
170  void trimSelfOf(std::string &str, char target, bool before, bool after)
171  {
172      if (!before && !after)
173          return;
174      std::string::size_type pos = str.size() - 1;
175      if (after)
176          pos = str.find_last_not_of(target);
177      if (pos != std::string::npos)
178          str.erase(pos + 1);
179      if (before)
180          pos = str.find_first_not_of(target);
181      str.erase(0, pos);
182  }
183  std::string trimOf(const std::string& str, char target, bool before, bool after)
184  {
185      if (!before && !after)
186          return str;
187      std::string::size_type pos = 0;
188      if (before)
189          pos = str.find_first_not_of(target);
190      if (pos == std::string::npos)
191      {
192          return str;
193      }
194      std::string::size_type pos2 = str.size() - 1;
195      if (after)
196          pos2 = str.find_last_not_of(target);
197      if (pos2 != std::string::npos)
198      {
199          return str.substr(pos, pos2 - pos + 1);
200      }
201      return str.substr(pos);
202  }
203  std::string trim(const std::string& str, bool before, bool after)
204  {
205      return trimOf(str, ' ', before, after);
206  }
207  std::string trimQuote(const std::string &str, bool before, bool after)
208  {
209      return trimOf(str, '\"', before, after);
210  }
211  std::string trimWhitespace(const std::string &str, bool before, bool after)
212  {
213      static std::string whitespaces(" \t\f\v\n\r");
214      string_size bpos = 0, epos = str.size();
215      if(after)
216      {
217          epos = str.find_last_not_of(whitespaces);
218          if(epos == std::string::npos)
219              return std::string();
220      }
221      if(before)
222      {
223          bpos = str.find_first_not_of(whitespaces);
224          if(bpos == std::string::npos)
225              return std::string();
226      }
227      return str.substr(bpos, epos - bpos + 1);
228  }
229  std::string getUrlArg(const std::string &url, const std::string &request)
230  {
231      std::string pattern = request + "=";
232      std::string::size_type pos = url.size();
233      while(pos)
234      {
235          pos = url.rfind(pattern, pos);
236          if(pos != url.npos)
237          {
238              if(pos == 0 || url[pos - 1] == '&' || url[pos - 1] == '?')
239              {
240                  pos += pattern.size();
241                  return url.substr(pos, url.find("&", pos) - pos);
242              }
243          }
244          else
245              break;
246          pos--;
247      }
248      return std::string();
249  }
250  std::string replaceAllDistinct(std::string str, const std::string &old_value, const std::string &new_value)
251  {
252      for(std::string::size_type pos(0); pos != std::string::npos; pos += new_value.length())
253      {
254          if((pos = str.find(old_value, pos)) != std::string::npos)
255              str.replace(pos, old_value.length(), new_value);
256          else
257              break;
258      }
259      return str;
260  }
261  void removeUTF8BOM(std::string &data)
262  {
263      if(data.compare(0, 3, "\xEF\xBB\xBF") == 0)
264          data = data.substr(3);
265  }
266  bool isStrUTF8(const std::string &data)
267  {
268      const char *str = data.c_str();
269      unsigned int nBytes = 0;
270      for (unsigned int i = 0; str[i] != '\0'; ++i)
271      {
272          unsigned char chr = *(str + i);
273          if (nBytes == 0)
274          {
275              if (chr >= 0x80)
276              {
277                  if (chr >= 0xFC && chr <= 0xFD)
278                      nBytes = 6;
279                  else if (chr >= 0xF8)
280                      nBytes = 5;
281                  else if (chr >= 0xF0)
282                      nBytes = 4;
283                  else if (chr >= 0xE0)
284                      nBytes = 3;
285                  else if (chr >= 0xC0)
286                      nBytes = 2;
287                  else
288                      return false;
289                  nBytes--;
290              }
291          }
292          else
293          {
294              if ((chr & 0xC0) != 0x80)
295                  return false;
296              nBytes--;
297          }
298      }
299      if (nBytes != 0)
300          return false;
301      return true;
302  }
303  std::string randomStr(const int len)
304  {
305      std::string retData;
306      srand(time(NULL));
307      int cnt = 0;
308      while(cnt < len)
309      {
310          switch((rand() % 3))
311          {
312          case 1:
313              retData += ('A' + rand() % 26);
314              break;
315          case 2:
316              retData += ('a' + rand() % 26);
317              break;
318          default:
319              retData += ('0' + rand() % 10);
320              break;
321          }
322          cnt++;
323      }
324      return retData;
325  }
326  int to_int(const std::string &str, int def_value)
327  {
328      if(str.empty())
329          return def_value;
330      return std::atoi(str.data());
331  }
332  std::string join(const string_array &arr, const std::string &delimiter)
333  {
334      if(arr.size() == 0)
335          return "";
336      if(arr.size() == 1)
337          return arr[0];
338      return std::accumulate(arr.begin() + 1, arr.end(), arr[0], [&](const std::string &a, const std::string &b) {return a + delimiter + b; });
339  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-dummy_data_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-string.cpp</div>
                </div>
                <div class="column column_space"><pre><code>81  void DummyDataLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
82        const vector<Blob<Dtype>*>& top) {
83    for (int i = 0; i < top.size(); ++i) {
84      const int filler_id = (fillers_.size() > 1) ? i : 0;
</pre></code></div>
                <div class="column column_space"><pre><code>48  std::string UTF8ToCodePoint(const std::string &data)
49  {
50      std::stringstream ss;
51      for(string_size i = 0; i < data.size(); i++)
52      {
53          int charcode = data[i] & 0xff;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    