
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.584826132771338%, Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-email.cpp</h3>
            <pre><code>1  #include "email.h"
2  PEMailAliasBs TEMailAliasBs::LoadSsTxt(const TStr& FNm){
3    PSs Ss=TSs::LoadTxt(ssfTabSep, FNm);
4    PEMailAliasBs EMailAliasBs=TEMailAliasBs::New();
5    for (int Y=0; Y<Ss->GetYLen(); Y++){
6      TStr PersonNm=Ss->At(0, Y).GetTrunc();
7      TStr DepNm=Ss->At(1, Y).GetTrunc().GetLc();
8      for (int X=2; X<Ss->GetXLen(Y); X++){
9        TStr EAddr=Ss->At(X, Y).GetTrunc().GetLc();
10        if (!PersonNm.Empty()&&!DepNm.Empty()&&!EAddr.Empty()){
11          EMailAliasBs->EAddrToPersonNmDepNmPrH.AddDat(EAddr, TStrPr(PersonNm, DepNm));
12        }
13      }
14    }
15    return EMailAliasBs;
16  }
17  bool TEMailTsactBs::IsEAddrOk(const TStr& EAddr){
18    TChA EAddrChA=EAddr;
19    EAddrChA.ToLc();
20    for (int ChN=0; ChN<EAddrChA.Len(); ChN++){
21      char Ch=EAddrChA[ChN];
22      if ((('a'<=Ch)&&(Ch<='z'))||(('0'<=Ch)&&(Ch<='9'))||
23       (Ch=='@')||(Ch=='.')||(Ch=='-')||(Ch=='_')){
24      } else {
25        return false;
26      }
27    }
28    return true;
29  }
30  int TEMailTsactBs::AddTsact(const TStr& SrcEAddr, const TStrV& DstEAddrV, const TTm& Tm){
31    int SrcEAddrId=EAddrStrToSrcFqDstFqPrH.AddKey(SrcEAddr);
32    TIntV DstEAddrIdV(DstEAddrV.Len(), 0);
33    for (int DstEAddrN=0; DstEAddrN<DstEAddrV.Len(); DstEAddrN++){
34      int DstEAddrId=EAddrStrToSrcFqDstFqPrH.AddKey(DstEAddrV[DstEAddrN]);
35      DstEAddrIdV.Add(DstEAddrId);
36    }
37    TEMailTsact Tsact(SrcEAddrId, DstEAddrIdV, Tm);
38    return EMailTsactV.Add(Tsact);
39  }
40  TTm TEml::GetTmFromRfc2822DateTimeStr(const TStr& DateTimeStr){
41    TChA DateTimeChA=DateTimeStr;
42    int DateTimeChALen=DateTimeChA.Len();
43    TChA ChA; int ChN=0;
44    while ((ChN<DateTimeChALen)&&isspace(DateTimeChA[ChN])){ChN++;}
45    if ((ChN<DateTimeChALen)&&isalpha(DateTimeChA[ChN])){
46      ChA.Clr();
47      while ((ChN<DateTimeChALen)&&((DateTimeChA[ChN]!=',')&&(DateTimeChA[ChN]!=' '))){
48        ChA+=DateTimeChA[ChN]; ChN++;}
49      if ((ChN<DateTimeChALen)&&DateTimeChA[ChN]==','){ChN++;}
50      while ((ChN<DateTimeChALen)&&isspace(DateTimeChA[ChN])){ChN++;}
51    }
52    ChA.Clr(); 
53    while ((ChN<DateTimeChALen)&&(DateTimeChA[ChN]!=' ')){
54      ChA+=DateTimeChA[ChN]; ChN++;}
55    TStr DayStr=ChA;
56    ChA.Clr(); ChN++;
57    while ((ChN<DateTimeChALen)&&(DateTimeChA[ChN]!=' ')){
58      ChA+=DateTimeChA[ChN]; ChN++;}
59    TStr MonthStr=ChA;
60    ChA.Clr(); ChN++;
61    while ((ChN<DateTimeChALen)&&(DateTimeChA[ChN]!=' ')){
62      ChA+=DateTimeChA[ChN]; ChN++;}
63    TStr YearStr=ChA;
64    ChA.Clr(); ChN++;
65    while ((ChN<DateTimeChALen)&&(isdigit(DateTimeChA[ChN]))){
66      ChA+=DateTimeChA[ChN]; ChN++;}
67    TStr HourStr=ChA;
68    TStr MinStr;
69    if ((ChN<DateTimeChALen)&&(DateTimeStr[ChN]==':')){
70      ChA.Clr(); ChN++;
71      while ((ChN<DateTimeChALen)&&(isdigit(DateTimeChA[ChN]))){
72        ChA+=DateTimeStr[ChN]; ChN++;}
73    }
74    MinStr=ChA;
75    TStr SecStr;
76    if ((ChN<DateTimeChALen)&&(DateTimeStr[ChN]==':')){
77      ChA.Clr(); ChN++;
78      while ((ChN<DateTimeChALen)&&isdigit(DateTimeStr[ChN])){
79        ChA+=DateTimeStr[ChN]; ChN++;}
80      SecStr=ChA;
81    }
82    while ((ChN<DateTimeChALen)&&isspace(DateTimeChA[ChN])){ChN++;}
83    TStr ZoneStr;
84    if ((ChN<DateTimeChALen)&&((DateTimeStr[ChN]=='+')||(DateTimeStr[ChN]=='-'))){
85      ChA.Clr(); 
86      ChA+=DateTimeStr[ChN];
87      ChN++;
88      while ((ChN<DateTimeChALen)&&(isdigit(DateTimeStr[ChN]))){
89        ChA+=DateTimeStr[ChN]; ChN++;}
90      ZoneStr=ChA;
91    } else
92    if ((ChN<DateTimeChALen)&&isalpha(DateTimeStr[ChN])){
93      ChA.Clr(); 
94      while ((ChN<DateTimeChALen)&&(isalpha(DateTimeChA[ChN]))){
95        ChA+=DateTimeStr[ChN]; ChN++;}
96      ZoneStr=ChA;
97    }
98    if (TTmInfo::IsMonthNm(DayStr)){
99      TStr MonthStr1=DayStr; DayStr=MonthStr; MonthStr=MonthStr1;}
100    int YearN=YearStr.GetInt(-1); if ((0<=YearN)&&(YearN<=100)){YearN+=1900;}
<span onclick='openModal()' class='match'>101    int MonthN=TTmInfo::GetMonthN(MonthStr);
102    int DayN=DayStr.GetInt(-1);
103    int HourN=HourStr.GetInt(0);
104    int MinN=MinStr.GetInt(0);
105    int SecN=SecStr.GetInt(0);
106    char ZoneSign=+1;
</span>107    int ZoneMins=0;
108    if (!ZoneStr.Empty()&&!ZoneStr.IsInt()){
109      ZoneStr=TTmInfo::GetTmZoneDiffStr(ZoneStr.GetUc());
110    }
111    if (!ZoneStr.Empty()&&ZoneStr.IsInt()){
112      ZoneMins=ZoneStr.GetSubStr(1, 2).GetInt(-1)*60+ZoneStr.GetSubStr(3, 4).GetInt(-1);
113      if (ZoneStr[0]=='-'){ZoneSign=-1;}
114    }
115    TTm Tm;
116    if ((YearN!=-1)&&(MonthN!=-1)&&(DayN!=-1)){
117      Tm=TTm(YearN, MonthN, DayN, -1, HourN, MinN, SecN, 0);
118      TStr S1=Tm.GetWebLogDateTimeStr(true);
119      if (ZoneSign>0){Tm.AddTime(0, ZoneMins, 0, 0);}
120      else {Tm.SubTime(0, ZoneMins, 0, 0);}
121      TStr S2=Tm.GetWebLogDateTimeStr(true);
122    }
123    return Tm;
124  }
125  void TEml::ExtrMergeToAddrStrV(const TStr& FldVal, TStrV& AddrStrV){
126    TStrV CandAddrStrV; FldVal.SplitOnAllAnyCh("\x09 ,;", CandAddrStrV);
127    for (int CandN=0; CandN<CandAddrStrV.Len(); CandN++){
128      TStr CandAddrStr=CandAddrStrV[CandN];
129      if (!CandAddrStr.IsChIn('@')){continue;}
130      char FirstCh=CandAddrStr[0]; char LastCh=CandAddrStr.LastCh();
131      if ((FirstCh=='<')&&(LastCh=='>')){
132        CandAddrStr=CandAddrStr.GetSubStr(1, CandAddrStr.Len()-2);
133      }
134      if (!isalnum(CandAddrStr[0])){continue;}
135      AddrStrV.AddUnique(CandAddrStr);
136    }
137  }
138  bool TEml::IsFieldNmCh(const uchar& Ch) const {
139    return (32<=Ch)&&(Ch<=126)&&(Ch!=':');
140  }
141  void TEml::ToNrEncoding(const TStr& ContTransferEncVal, TChA& ChA){
142    if (ContTransferEncVal=="base64"){
143      ChA.Clr();
144    } else
145    if (ContTransferEncVal=="quoted-printable"){
146      TChA NrChA(ChA.Len()); int ChN=0;
147      while (ChN<ChA.Len()){
148        if ((ChA[ChN]=='=')&&(ChN+2<ChA.Len())){
149          ChN++; char HexCh1=ChA[ChN++]; char HexCh2=ChA[ChN++];
150          if ((TCh::IsHex(HexCh1))&&(TCh::IsHex(HexCh2))){
151            int ChVal=16*TCh::GetHex(HexCh1)+TCh::GetHex(HexCh2);
152            NrChA.AddCh(ChVal);
153          }
154        } else {
155          NrChA.AddCh(ChA[ChN]); ChN++;
156        }
157      }
158      ChA=NrChA;
159    }
160  }
161  void TEml::ExtrAddBoundaryStr(const TStr& ContTypeVal, TStrV& BoundaryStrV) const {
162    TStr FldStr="boundary=";
163    int FldChN=ContTypeVal.SearchStr(FldStr);
164    TStr BoundaryStr;
165    if (FldChN==-1){
166      BoundaryStr="";
167    } else {
168      TChA ChA=ContTypeVal.GetSubStr(FldChN+FldStr.Len(), ContTypeVal.Len());
169      if ((ChA.Len()>0)&&(ChA[0]=='\"')){ChA.Del(0);}
170      int ChN=0;
171      while ((ChN<ChA.Len())&&(ChA[ChN]!='\"')){ChN++;}
172      ChA.Trunc(ChN);
173      BoundaryStr=ChA;
174    }
175    if (!BoundaryStr.Empty()){
176      BoundaryStrV.AddUnique(BoundaryStr);}
177  }
178  bool TEml::LoadField(const PSIn& SIn, TChA& FldNm, TChA& FldVal, TChA& LcFldVal){
179    FldNm.Clr(); FldVal.Clr(); LcFldVal.Clr();
180    while (IsFieldNmCh(SIn->PeekCh())){
181      FldNm+=tolower(SIn->GetCh());} 
182    if (FldNm.Empty()){return false;}
183    if (SIn->PeekCh()!=':'){return false;} else {SIn->GetCh();}
184    forever{
185      if (SIn->PeekCh()==13){
186        SIn->GetCh(); 
187        if (SIn->PeekCh()==10){
188          SIn->GetCh();
189          if ((SIn->PeekCh()==32)||(SIn->PeekCh()==9)){
190          } else {
191            break;
192          }
193        }
194      }
195      FldVal+=SIn->GetCh();
196    }
197    LcFldVal=FldVal; LcFldVal.ToLc();
198    return true;
199  }
200  void TEml::LoadMessage(const PSIn& SIn){
201    TChA FldNm; TChA FldVal; TChA LcFldVal;
202    TStr ContTypeVal; TStr LcContTypeVal;
203    TStr ContTransferEncVal; 
204    TStrV BoundaryStrV;
205    TChA SubjChA;
206    forever {
207      bool IsFld=LoadField(SIn, FldNm, FldVal, LcFldVal); 
208      if (IsFld){
209        if (FldNm=="from"){
210          ExtrMergeToAddrStrV(LcFldVal, FromAddrStrV);}
211        else if ((FldNm=="to")||(FldNm=="cc")||(FldNm=="bcc")){
212          ExtrMergeToAddrStrV(LcFldVal, ToAddrStrV);}
213        else if (FldNm=="date"){
214          Tm=GetTmFromRfc2822DateTimeStr(LcFldVal);
215        }
216        else if (FldNm=="subject"){
217          SubjChA=FldVal;}
218        else if (FldNm=="content-type"){
219          ContTypeVal=FldVal; LcContTypeVal=LcFldVal;}
220        else if (FldNm=="content-transfer-encoding"){
221          ContTransferEncVal=LcFldVal; ContTransferEncVal.ToTrunc();}
222      } else {
223        if (SIn->PeekCh()==13){
224          SIn->GetCh(); if (SIn->PeekCh()==10){SIn->GetCh();} else {}
225        }
226        break;
227      }
228    }
229    ToNrEncoding(ContTransferEncVal, SubjChA); SubjStr=SubjChA;
230    TChA ContChA;
231    if (LcContTypeVal.Empty()||LcContTypeVal.IsStrIn("text/plain")||LcContTypeVal.IsStrIn("text/html")){
232      TStrV LnStrV; TChA LnChA;
233      while (SIn->PeekCh()!=0){
234        LnChA+=SIn->GetCh();
235        if ((LnChA.LastCh()==10)||(SIn->PeekCh()!=0)){
236          ContChA+=LnChA; LnStrV.Add(LnChA.CStr()); LnChA.Clr();}
237      }
238    } else
239    if (LcContTypeVal.IsStrIn("multipart/")){
240      ExtrAddBoundaryStr(ContTypeVal, BoundaryStrV);
241      TStrV LnStrV; TChA LnChA; bool InsLnP=false;
242      while (SIn->PeekCh()!=0){
243        LnChA+=SIn->GetCh();
244        if ((LnChA.LastCh()==10)||(SIn->PeekCh()==0)){
245          if ((ContChA.Len()>0)&&(ContChA.LastCh()!=' ')){ContChA+=' ';}
246          bool IsBoundary=false;
247          for (int BoundaryN=0; BoundaryN<BoundaryStrV.Len(); BoundaryN++){
248            if (LnChA.IsStrIn(BoundaryStrV[BoundaryN])){
249              IsBoundary=true; break;}
250          }
251          if (InsLnP&&!IsBoundary){
252            ContChA+=LnChA; LnStrV.Add(LnChA.CStr());} 
253          if (IsBoundary){
254            TStr PartContTypeVal; TStr PartLcContTypeVal; 
255            TChA PartFldNm; TChA PartFldVal; TChA PartLcFldVal;
256            forever {
257              bool IsPartFld=LoadField(SIn, PartFldNm, PartFldVal, PartLcFldVal);
258              if (IsPartFld){
259                if (PartFldNm=="content-type"){
260                  PartContTypeVal=PartFldVal; PartLcContTypeVal=PartLcFldVal;
261                  ExtrAddBoundaryStr(PartContTypeVal, BoundaryStrV);
262                } 
263                else if (PartFldNm=="content-transfer-encoding"){
264                  if (ContTransferEncVal.Empty()){
265                    ContTransferEncVal=PartLcFldVal; 
266                    ContTransferEncVal.ToTrunc();
267                  }
268                }
269              } else {
270                break;
271              }
272            }
273            InsLnP=PartLcContTypeVal.IsStrIn("text/plain")||PartLcContTypeVal.IsStrIn("text/html");
274          }
275          LnChA.Clr();
276        }
277      }
278    }
279    ToNrEncoding(ContTransferEncVal, ContChA); 
280    ContStr=ContChA; 
281  }
282  PEml TEml::LoadEml(const TStr& FNm, const TStr& OwnerNm){
283    PSIn SIn=TFIn::New(FNm);
284    PEml Eml=TEml::New();
285    Eml->OwnerNm=OwnerNm;
286    Eml->LoadMessage(SIn);
287    return Eml;
288  }
289  void TEmlBs::AddEml(const TStr& EmlNm, const PEml& Eml){
290    NmToEmlH.AddDat(EmlNm, Eml);
291    int EmlP=NmToEmlH.GetKeyId(EmlNm);
292    for (int EAddrN=0; EAddrN<Eml->GetFromEAddrs(); EAddrN++){
293      AddEAddr(Eml->GetFromEAddr(EAddrN), EmlP);}
294    for (int EAddrN=0; EAddrN<Eml->GetToEAddrs(); EAddrN++){
295      AddEAddr(Eml->GetToEAddr(EAddrN), EmlP);}
296  }
297  void TEmlBs::DelEml(const TStr& EmlNm){
298    PEml Eml=NmToEmlH.GetDat(EmlNm);
299    int EmlP=NmToEmlH.GetKeyId(EmlNm);
300    for (int EAddrN=0; EAddrN<Eml->GetFromEAddrs(); EAddrN++){
301      DelEAddr(Eml->GetFromEAddr(EAddrN), EmlP);}
302    for (int EAddrN=0; EAddrN<Eml->GetToEAddrs(); EAddrN++){
303      DelEAddr(Eml->GetToEAddr(EAddrN), EmlP);}
304    NmToEmlH.DelKey(EmlNm);
305  }
306  void TEmlBs::GetTmEmlNmPrV(TTmStrPrV& TmEmlNmPrV) const {
307    TStrV EmlIdV; GetEmlNmV(EmlIdV);
308    TmEmlNmPrV.Gen(EmlIdV.Len(), 0);
309    for (int EmlN=0; EmlN<EmlIdV.Len(); EmlN++){
310      TStr EmlNm=EmlIdV[EmlN];
311      PEml Eml=GetEml(EmlNm);
312      TmEmlNmPrV.Add(TTmStrPr(Eml->GetTm(), EmlNm));
313    }
314    TmEmlNmPrV.Sort();
315  }
316  void TEmlBs::LoadWinMailAccount(const TStr& FPath, const TStr& OwnerNm, const int& MxEmls){
317    printf("Processing WinMail-Account at '%s' ...\n", FPath.CStr());
318    TStr NrFPath=TStr::GetNrFPath(FPath);
319    PFFile FFile=TFFile::New(FPath, "eml", true); 
320    TStr EmlFNm; int Emls=0; 
321    while (FFile->Next(EmlFNm)){
322      Emls++; if ((MxEmls!=-1)&&(Emls>=MxEmls)){break;}
323      printf("%d\r", Emls);
324      TStr EmlNm=EmlFNm;
325      if (EmlNm.IsPrefix(NrFPath)){
326        EmlNm=EmlNm.GetSubStr(NrFPath.Len(), EmlNm.Len());}
327      PEml Eml=TEml::LoadEml(EmlFNm, OwnerNm);
328      if (Eml->GetTm().IsDef()){
329        AddEml(EmlNm, Eml);}
330    }
331    printf("Done.\n");
332  }
333  void TEmlBs::LoadEnronEMail(const TStr& FPath, const int& MxEmls){
334    printf("Processing Enron-EMail at '%s' ...\n", FPath.CStr());
335    TStr NrFPath=TStr::GetNrFPath(FPath);
336    PFFile FFile=TFFile::New(FPath, "", true);
337    TStr EmlFNm; int Emls=0; 
338    while (FFile->Next(EmlFNm)){
339      Emls++; if ((MxEmls!=-1)&&(Emls>=MxEmls)){break;}
340      printf("%d\r", Emls);
341      TStr EmlNm=EmlFNm;
342      if (EmlNm.IsPrefix(NrFPath)){
343        EmlNm=EmlNm.GetSubStr(NrFPath.Len(), EmlNm.Len());}
344      int OwnerEChN=EmlNm.SearchCh('/')-1;
345      TStr OwnerNm=EmlNm.GetSubStr(0, OwnerEChN);
346      PEml Eml=TEml::LoadEml(EmlFNm, OwnerNm);
347      AddEml(EmlNm, Eml);
348    }
349    printf("\nDone.\n");
350  }
351  void TEmlBs::SaveTxt(const TStr& FNm){
352    TTmStrPrV TmEmlNmPrV; GetTmEmlNmPrV(TmEmlNmPrV);
353    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
354    for (int EmlN=0; EmlN<TmEmlNmPrV.Len(); EmlN++){
355      TStr EmlNm=TmEmlNmPrV[EmlN].Val2;
356      PEml Eml=GetEml(EmlNm);
357      fprintf(fOut, "==================================\n");
358      fprintf(fOut, "Id: %s\n", EmlNm.CStr());
359      fprintf(fOut, "Owner: %s\n", Eml->GetOwnerNm().CStr());
360      fprintf(fOut, "From:");
361      for (int EAddrN=0; EAddrN<Eml->GetFromEAddrs(); EAddrN++){
362        fprintf(fOut, " %s", Eml->GetFromEAddr(EAddrN).CStr());
363      }
364      fprintf(fOut, "\n");
365      fprintf(fOut, "To:");
366      for (int EAddrN=0; EAddrN<Eml->GetToEAddrs(); EAddrN++){
367        fprintf(fOut, " %s", Eml->GetToEAddr(EAddrN).CStr());
368      }
369      fprintf(fOut, "\n"); 
370      fprintf(fOut, "Time: %s\n", Eml->GetTm().GetWebLogDateTimeStr(true).CStr());
371      fprintf(fOut, "Subject: %s\n", Eml->GetSubjStr().CStr());
372      TChA ContChA=Eml->GetContStr(); 
373      ContChA.ChangeCh('\r', ' '); ContChA.ChangeCh('\n', ' ');
374      fprintf(fOut, "Content: %s\n", ContChA.CStr());
375    }}
376  }
377  void TEmlBs::SaveTxtEAddr(const TStr& FNm){
378    TIntStrPrV FqAddrStrPrV; 
379    int EAddrs=GetEAddrs();
380    for (int EAddrN=0; EAddrN<EAddrs; EAddrN++){
381      FqAddrStrPrV.Add(TIntStrPr(GetEAddrFq(EAddrN), GetEAddrStr(EAddrN)));
382    }
383    {FqAddrStrPrV.Sort(false);
384    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
385    for (int AddrN=0; AddrN<FqAddrStrPrV.Len(); AddrN++){
386      fprintf(fOut, "%d. #%d %s\n", 1+AddrN, FqAddrStrPrV[AddrN].Val1, FqAddrStrPrV[AddrN].Val2.CStr());
387    }}
388  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intsimdmatrixavx2.cpp</h3>
            <pre><code>1  #include "intsimdmatrix.h"
2  #if !defined(__AVX2__)
3  #  if defined(__i686__) || defined(__x86_64__)
4  #    error Implementation only for AVX2 capable architectures
5  #  endif
6  #else
7  #  include <immintrin.h>
8  #  include <algorithm>
9  #  include <cstdint>
10  #  include <vector>
11  #  if defined(_MSC_VER) && _MSC_VER >= 1925 && _MSC_VER <= 1929 && \
12        defined(_WIN32) && !defined(_WIN64)
13  #    pragma optimize("", off)
14  #    pragma optimize("s", on)
15  #  endif
16  namespace tesseract {
17  constexpr int kNumOutputsPerRegister = 8;
18  constexpr int kMaxOutputRegisters = 8;
19  constexpr int kNumInputsPerRegister = 32;
20  constexpr int kNumInputsPerGroup = 4;
21  constexpr int kNumInputGroups = kNumInputsPerRegister / kNumInputsPerGroup;
22  static inline void MultiplyGroup(const __m256i &rep_input, const __m256i &ones, const int8_t *&wi,
23                                   __m256i &weights, __m256i &reps, __m256i &result) {
24    weights = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(wi));
25    wi += kNumInputsPerRegister;
26    reps = _mm256_sign_epi8(rep_input, weights);
27    weights = _mm256_sign_epi8(weights, weights);
28    weights = _mm256_maddubs_epi16(weights, reps);
29    weights = _mm256_madd_epi16(weights, ones);
30    result = _mm256_add_epi32(result, weights);
31  }
32  static inline __m128i load64_to_128(const int8_t *wi_) {
33    const auto *wi = reinterpret_cast<const int64_t *>(wi_);
34    return _mm_set_epi64x(0, wi[0]);
35  }
36  #if defined(FAST_FLOAT)
37  static inline void ExtractResults8(__m256i result, const int8_t *wi,
38                                     const float *scales, float *v) {
39    __m128i w128 = load64_to_128(wi); 
40    __m256i w256 = _mm256_cvtepi8_epi32(w128); 
41    __m256i bias_scale = _mm256_set_epi32(127, 127, 127, 127, 127, 127, 127, 127);
42    __m256 scale01234567 = _mm256_loadu_ps(scales);
43    w256 = _mm256_mullo_epi32(w256, bias_scale); 
44    result = _mm256_add_epi32(result, w256);     
45    __m256 res01234567 = _mm256_cvtepi32_ps(result);
46    result = _mm256_permute4x64_epi64(result, 2 + (3 << 2));
47    res01234567 = _mm256_mul_ps(res01234567, scale01234567);
48    _mm256_storeu_ps(v, res01234567);
49  }
50  static inline void ExtractResults16(__m256i result0, __m256i result1,
51                                      const int8_t *&wi, const float *&scales,
52                                      float *&v) {
53    __m128i w8 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(wi));
54    const __m256i bias_scale =
55        _mm256_set_epi32(127, 127, 127, 127, 127, 127, 127, 127);
56    __m256i w256 = _mm256_cvtepi8_epi32(w8); 
57    __m256 scale01234567 = _mm256_loadu_ps(scales);
58    w256 = _mm256_mullo_epi32(w256, bias_scale); 
59    result0 = _mm256_add_epi32(result0, w256);   
60    __m256 res01234567 = _mm256_cvtepi32_ps(result0);
61    result0 = _mm256_permute4x64_epi64(result0, 2 + (3 << 2));
62    res01234567 = _mm256_mul_ps(res01234567, scale01234567);
63    _mm256_storeu_ps(v, res01234567);
64    w8 = _mm_shuffle_epi32(w8, 2 + (3 << 2));
65    w256 = _mm256_cvtepi8_epi32(w8); 
66    scale01234567 = _mm256_loadu_ps(scales + 8);
67    w256 = _mm256_mullo_epi32(w256, bias_scale); 
68    result1 = _mm256_add_epi32(result1, w256);   
69    res01234567 = _mm256_cvtepi32_ps(result1);
70    result1 = _mm256_permute4x64_epi64(result1, 2 + (3 << 2));
71    res01234567 = _mm256_mul_ps(res01234567, scale01234567);
72    _mm256_storeu_ps(v + 8, res01234567);
73    wi += 16;
74    scales += 16;
75    v += 16;
76  }
77  static void PartialMatrixDotVector64(const int8_t *wi, const float *scales, const int8_t *u,
78                                       int num_in, float *v) {
<span onclick='openModal()' class='match'>79    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
80    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
81    __m256i result0 = _mm256_setzero_si256();
82    __m256i result1 = _mm256_setzero_si256();
83    __m256i result2 = _mm256_setzero_si256();
84    __m256i result3 = _mm256_setzero_si256();
</span>85    __m256i result4 = _mm256_setzero_si256();
86    __m256i result5 = _mm256_setzero_si256();
87    __m256i result6 = _mm256_setzero_si256();
88    __m256i result7 = _mm256_setzero_si256();
89    for (int j = 0; j < num_in;) {
90      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
91      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
92        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
93        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
94        __m256i weights, reps;
95        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
96        MultiplyGroup(rep_input, ones, wi, weights, reps, result1);
97        MultiplyGroup(rep_input, ones, wi, weights, reps, result2);
98        MultiplyGroup(rep_input, ones, wi, weights, reps, result3);
99        MultiplyGroup(rep_input, ones, wi, weights, reps, result4);
100        MultiplyGroup(rep_input, ones, wi, weights, reps, result5);
101        MultiplyGroup(rep_input, ones, wi, weights, reps, result6);
102        MultiplyGroup(rep_input, ones, wi, weights, reps, result7);
103      }
104    }
105    ExtractResults16(result0, result1, wi, scales, v);
106    ExtractResults16(result2, result3, wi, scales, v);
107    ExtractResults16(result4, result5, wi, scales, v);
108    ExtractResults16(result6, result7, wi, scales, v);
109  }
110  static void PartialMatrixDotVector32(const int8_t *wi, const float *scales, const int8_t *u,
111                                       int num_in, float *v) {
112    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
113    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
114    __m256i result0 = _mm256_setzero_si256();
115    __m256i result1 = _mm256_setzero_si256();
116    __m256i result2 = _mm256_setzero_si256();
117    __m256i result3 = _mm256_setzero_si256();
118    for (int j = 0; j < num_in;) {
119      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
120      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
121        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
122        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
123        __m256i weights, reps;
124        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
125        MultiplyGroup(rep_input, ones, wi, weights, reps, result1);
126        MultiplyGroup(rep_input, ones, wi, weights, reps, result2);
127        MultiplyGroup(rep_input, ones, wi, weights, reps, result3);
128      }
129    }
130    ExtractResults16(result0, result1, wi, scales, v);
131    ExtractResults16(result2, result3, wi, scales, v);
132  }
133  static void PartialMatrixDotVector16(const int8_t *wi, const float *scales, const int8_t *u,
134                                       int num_in, float *v) {
135    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
136    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
137    __m256i result0 = _mm256_setzero_si256();
138    __m256i result1 = _mm256_setzero_si256();
139    for (int j = 0; j < num_in;) {
140      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
141      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
142        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
143        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
144        __m256i weights, reps;
145        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
146        MultiplyGroup(rep_input, ones, wi, weights, reps, result1);
147      }
148    }
149    ExtractResults16(result0, result1, wi, scales, v);
150  }
151  static inline void PartialMatrixDotVector8(const int8_t *wi, const float *scales, const int8_t *u,
152                                             int num_in, float *v) {
153    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
154    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
155    __m256i result0 = _mm256_setzero_si256();
156    for (int j = 0; j < num_in;) {
157      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
158      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
159        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
160        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
161        __m256i weights, reps;
162        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
163      }
164    }
165    ExtractResults8(result0, wi, scales, v);
166  }
167  static void matrixDotVector(int dim1, int dim2, const int8_t *wi, const float *scales,
168                              const int8_t *u, float *v) {
169    const int num_out = dim1;
170    const int num_in = dim2 - 1;
171    const int rounded_num_in = IntSimdMatrix::Roundup(num_in, kNumInputsPerGroup);
172    const int rounded_num_out = IntSimdMatrix::Roundup(num_out, kNumOutputsPerRegister);
173    int group_size = kNumOutputsPerRegister * kMaxOutputRegisters;
174    int output = 0;
175    int w_step = (rounded_num_in + 1) * group_size;
176    for (; output + group_size <= rounded_num_out; output += group_size) {
177      PartialMatrixDotVector64(wi, scales, u, rounded_num_in, v);
178      wi += w_step;
179      scales += group_size;
180      v += group_size;
181    }
182    group_size /= 2;
183    w_step /= 2;
184    if (output + group_size <= rounded_num_out) {
185      PartialMatrixDotVector32(wi, scales, u, rounded_num_in, v);
186      wi += w_step;
187      scales += group_size;
188      v += group_size;
189      output += group_size;
190    }
191    group_size /= 2;
192    w_step /= 2;
193    if (output + group_size <= rounded_num_out) {
194      PartialMatrixDotVector16(wi, scales, u, rounded_num_in, v);
195      wi += w_step;
196      scales += group_size;
197      v += group_size;
198      output += group_size;
199    }
200    group_size /= 2;
201    w_step /= 2;
202    if (output + group_size <= rounded_num_out) {
203      PartialMatrixDotVector8(wi, scales, u, rounded_num_in, v);
204    }
205  }
206  #else
207  static inline void ExtractResults8(__m256i result, const int8_t *wi, const double *scales,
208                                     double *v) {
209    __m128i w128 = load64_to_128(wi);          
210    __m256i w256 = _mm256_cvtepi8_epi32(w128); 
211    __m256i bias_scale = _mm256_set_epi32(127, 127, 127, 127, 127, 127, 127, 127);
212    __m256d scale0123 = _mm256_loadu_pd(scales);
213    __m256d scale4567 = _mm256_loadu_pd(scales + 4);
214    w256 = _mm256_mullo_epi32(w256, bias_scale); 
215    result = _mm256_add_epi32(result, w256);     
216    __m256d res0123 = _mm256_cvtepi32_pd(_mm256_castsi256_si128(result));
217    result = _mm256_permute4x64_epi64(result, 2 + (3 << 2));
218    __m256d res4567 = _mm256_cvtepi32_pd(_mm256_castsi256_si128(result));
219    res0123 = _mm256_mul_pd(res0123, scale0123);
220    res4567 = _mm256_mul_pd(res4567, scale4567);
221    _mm256_storeu_pd(v, res0123);
222    _mm256_storeu_pd(v + 4, res4567);
223  }
224  static inline void ExtractResults16(__m256i result0, __m256i result1, const int8_t *&wi,
225                                      const double *&scales, double *&v) {
226    __m128i w8 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(wi));
227    const __m256i bias_scale = _mm256_set_epi32(127, 127, 127, 127, 127, 127, 127, 127);
228    __m256i w256 = _mm256_cvtepi8_epi32(w8); 
229    __m256d scale0123 = _mm256_loadu_pd(scales);
230    __m256d scale4567 = _mm256_loadu_pd(scales + 4);
231    w256 = _mm256_mullo_epi32(w256, bias_scale); 
232    result0 = _mm256_add_epi32(result0, w256);   
233    __m256d res0123 = _mm256_cvtepi32_pd(_mm256_castsi256_si128(result0));
234    result0 = _mm256_permute4x64_epi64(result0, 2 + (3 << 2));
235    __m256d res4567 = _mm256_cvtepi32_pd(_mm256_castsi256_si128(result0));
236    res0123 = _mm256_mul_pd(res0123, scale0123);
237    res4567 = _mm256_mul_pd(res4567, scale4567);
238    _mm256_storeu_pd(v, res0123);
239    _mm256_storeu_pd(v + 4, res4567);
240    w8 = _mm_shuffle_epi32(w8, 2 + (3 << 2));
241    w256 = _mm256_cvtepi8_epi32(w8); 
242    scale0123 = _mm256_loadu_pd(scales + 8);
243    scale4567 = _mm256_loadu_pd(scales + 12);
244    w256 = _mm256_mullo_epi32(w256, bias_scale); 
245    result1 = _mm256_add_epi32(result1, w256);   
246    res0123 = _mm256_cvtepi32_pd(_mm256_castsi256_si128(result1));
247    result1 = _mm256_permute4x64_epi64(result1, 2 + (3 << 2));
248    res4567 = _mm256_cvtepi32_pd(_mm256_castsi256_si128(result1));
249    res0123 = _mm256_mul_pd(res0123, scale0123);
250    res4567 = _mm256_mul_pd(res4567, scale4567);
251    _mm256_storeu_pd(v + 8, res0123);
252    _mm256_storeu_pd(v + 12, res4567);
253    wi += 16;
254    scales += 16;
255    v += 16;
256  }
257  static void PartialMatrixDotVector64(const int8_t *wi, const double *scales, const int8_t *u,
258                                       int num_in, double *v) {
259    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
260    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
261    __m256i result0 = _mm256_setzero_si256();
262    __m256i result1 = _mm256_setzero_si256();
263    __m256i result2 = _mm256_setzero_si256();
264    __m256i result3 = _mm256_setzero_si256();
265    __m256i result4 = _mm256_setzero_si256();
266    __m256i result5 = _mm256_setzero_si256();
267    __m256i result6 = _mm256_setzero_si256();
268    __m256i result7 = _mm256_setzero_si256();
269    for (int j = 0; j < num_in;) {
270      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
271      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
272        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
273        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
274        __m256i weights, reps;
275        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
276        MultiplyGroup(rep_input, ones, wi, weights, reps, result1);
277        MultiplyGroup(rep_input, ones, wi, weights, reps, result2);
278        MultiplyGroup(rep_input, ones, wi, weights, reps, result3);
279        MultiplyGroup(rep_input, ones, wi, weights, reps, result4);
280        MultiplyGroup(rep_input, ones, wi, weights, reps, result5);
281        MultiplyGroup(rep_input, ones, wi, weights, reps, result6);
282        MultiplyGroup(rep_input, ones, wi, weights, reps, result7);
283      }
284    }
285    ExtractResults16(result0, result1, wi, scales, v);
286    ExtractResults16(result2, result3, wi, scales, v);
287    ExtractResults16(result4, result5, wi, scales, v);
288    ExtractResults16(result6, result7, wi, scales, v);
289  }
290  static void PartialMatrixDotVector32(const int8_t *wi, const double *scales, const int8_t *u,
291                                       int num_in, double *v) {
292    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
293    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
294    __m256i result0 = _mm256_setzero_si256();
295    __m256i result1 = _mm256_setzero_si256();
296    __m256i result2 = _mm256_setzero_si256();
297    __m256i result3 = _mm256_setzero_si256();
298    for (int j = 0; j < num_in;) {
299      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
300      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
301        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
302        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
303        __m256i weights, reps;
304        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
305        MultiplyGroup(rep_input, ones, wi, weights, reps, result1);
306        MultiplyGroup(rep_input, ones, wi, weights, reps, result2);
307        MultiplyGroup(rep_input, ones, wi, weights, reps, result3);
308      }
309    }
310    ExtractResults16(result0, result1, wi, scales, v);
311    ExtractResults16(result2, result3, wi, scales, v);
312  }
313  static void PartialMatrixDotVector16(const int8_t *wi, const double *scales, const int8_t *u,
314                                       int num_in, double *v) {
315    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
316    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
317    __m256i result0 = _mm256_setzero_si256();
318    __m256i result1 = _mm256_setzero_si256();
319    for (int j = 0; j < num_in;) {
320      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
321      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
322        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
323        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
324        __m256i weights, reps;
325        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
326        MultiplyGroup(rep_input, ones, wi, weights, reps, result1);
327      }
328    }
329    ExtractResults16(result0, result1, wi, scales, v);
330  }
331  static inline void PartialMatrixDotVector8(const int8_t *wi, const double *scales, const int8_t *u,
332                                             int num_in, double *v) {
333    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
334    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
335    __m256i result0 = _mm256_setzero_si256();
336    for (int j = 0; j < num_in;) {
337      __m256i inputs = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(u + j));
338      for (int ig = 0; ig < kNumInputGroups && j < num_in; ++ig, j += kNumInputsPerGroup) {
339        __m256i rep_input = _mm256_broadcastd_epi32(_mm256_castsi256_si128(inputs));
340        inputs = _mm256_permutevar8x32_epi32(inputs, shift_id);
341        __m256i weights, reps;
342        MultiplyGroup(rep_input, ones, wi, weights, reps, result0);
343      }
344    }
345    ExtractResults8(result0, wi, scales, v);
346  }
347  static void matrixDotVector(int dim1, int dim2, const int8_t *wi, const double *scales,
348                              const int8_t *u, double *v) {
349    const int num_out = dim1;
350    const int num_in = dim2 - 1;
351    const int rounded_num_in = IntSimdMatrix::Roundup(num_in, kNumInputsPerGroup);
352    const int rounded_num_out = IntSimdMatrix::Roundup(num_out, kNumOutputsPerRegister);
353    int group_size = kNumOutputsPerRegister * kMaxOutputRegisters;
354    int output = 0;
355    int w_step = (rounded_num_in + 1) * group_size;
356    for (; output + group_size <= rounded_num_out; output += group_size) {
357      PartialMatrixDotVector64(wi, scales, u, rounded_num_in, v);
358      wi += w_step;
359      scales += group_size;
360      v += group_size;
361    }
362    group_size /= 2;
363    w_step /= 2;
364    if (output + group_size <= rounded_num_out) {
365      PartialMatrixDotVector32(wi, scales, u, rounded_num_in, v);
366      wi += w_step;
367      scales += group_size;
368      v += group_size;
369      output += group_size;
370    }
371    group_size /= 2;
372    w_step /= 2;
373    if (output + group_size <= rounded_num_out) {
374      PartialMatrixDotVector16(wi, scales, u, rounded_num_in, v);
375      wi += w_step;
376      scales += group_size;
377      v += group_size;
378      output += group_size;
379    }
380    group_size /= 2;
381    w_step /= 2;
382    if (output + group_size <= rounded_num_out) {
383      PartialMatrixDotVector8(wi, scales, u, rounded_num_in, v);
384    }
385  }
386  #endif
387  const IntSimdMatrix IntSimdMatrix::intSimdMatrixAVX2 = {
388      matrixDotVector,
389      kNumOutputsPerRegister,
390      kMaxOutputRegisters,
391      kNumInputsPerRegister,
392      kNumInputsPerGroup
393  };
394  } 
395  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-email.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intsimdmatrixavx2.cpp</div>
                </div>
                <div class="column column_space"><pre><code>101    int MonthN=TTmInfo::GetMonthN(MonthStr);
102    int DayN=DayStr.GetInt(-1);
103    int HourN=HourStr.GetInt(0);
104    int MinN=MinStr.GetInt(0);
105    int SecN=SecStr.GetInt(0);
106    char ZoneSign=+1;
</pre></code></div>
                <div class="column column_space"><pre><code>79    __m256i ones = _mm256_set_epi16(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
80    __m256i shift_id = _mm256_set_epi32(0, 7, 6, 5, 4, 3, 2, 1);
81    __m256i result0 = _mm256_setzero_si256();
82    __m256i result1 = _mm256_setzero_si256();
83    __m256i result2 = _mm256_setzero_si256();
84    __m256i result3 = _mm256_setzero_si256();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    