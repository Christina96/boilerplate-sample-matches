
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.3612750885478158%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-webserver.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <fstream>
3  #include <map>
4  #include <atomic>
5  #include <thread>
6  #include <pthread.h>
7  #include "../utils/file.h"
8  #include "../utils/string.h"
9  #include "../utils/system.h"
10  #include "socket.h"
11  #include "webserver.h"
12  using string_array = std::vector<std::string>;
13  int def_timeout = 5;
14  struct responseRoute
15  {
16      std::string method;
17      std::string path;
18      std::string content_type;
19      response_callback rc;
20  };
21  std::vector<responseRoute> responses;
22  int max_send_failure = 10;
23  std::atomic_bool SERVER_EXIT_FLAG(false);
24  std::atomic_int working_thread(0);
25  int sendall(SOCKET sock, std::string data)
26  {
27      unsigned int total = 0, bytesleft = data.size();
28      int sent = 0;
29      const char* datastr = data.data();
30      while(total < bytesleft)
31      {
32          sent = send(sock, datastr + total, bytesleft, 0);
33          if(sent < 0)
34          {
35              std::cerr<<strerror(errno)<<std::endl;
36              if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
37              {
38                  continue;
39              }
40              else
41              {
42                  break;
43              }
44          }
45          total += sent;
46          bytesleft -= sent;
47      }
48      return sent == -1 ? -1 : 0;
49  }
50  void wrong_req(SOCKET sock)
51  {
52      std::string response = "HTTP/1.1 501 Not Implemented\r\n"
53                             "Access-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: *\r\n"
54                             "Content-Type: text/plain\r\n\r\n"
55                             "The command is not yet completed\r\n";
56      if (sendall(sock, response) == -1)
57      {
58          std::cerr << "Sending failed!" << std::endl;
59      }
60  }
61  void file_not_found(std::string arguments, int sock)
62  {
<span onclick='openModal()' class='match'>63      std::string prompt_info = "Not found:  " + arguments;
64      std::string response = "HTTP/1.1 404 Not Found\r\n"
65                             "Content-Type: text/plain\r\nConnection: close\r\n"
66                             "Access-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: *\r\n"
67                             "Content-Length: " + std::__cxx11::to_string(prompt_info.size()) + "\r\n\r\n" + prompt_info + "\r\n";
68      if (sendall(sock, response) == -1)
69      {
70          printf("Sending error!");
71          return;
72      }
</span>73  }
74  void send_header(SOCKET send_to, std::string content_type)
75  {
76      std::string header = "HTTP/1.1 200 OK\r\nConnection: close\r\nCache-Control: no-cache, no-store, must-revalidate\r\nAccess-Control-Allow-Origin: *\r\n";
77      if(content_type.size())
78          header += "Content-Type: " + content_type + "\r\n";
79      if(sendall(send_to, header) == -1)
80      {
81          printf("Sending error!");
82      }
83  }
84  void send_options_header(SOCKET send_to)
85  {
86      std::string header = "HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: *\r\n";
87      if(sendall(send_to, header) == -1)
88      {
89          printf("Sending error!");
90      }
91  }
92  char* file_type(const char* arg)
93  {
94      char * temp;
95      if ((temp=strrchr(arg,'.')) != NULL)
96      {
97          return temp+1;
98      }
99      return nullptr;
100  }
101  void serve_options(SOCKET sock)
102  {
103      send_options_header(sock);
104      std::string extra_header = "Content-Length: 0\r\n\r\n";
105      sendall(sock, extra_header);
106      sendall(sock, "\r\n\r\n");
107  }
108  void serve_content(SOCKET sock, std::string type, std::string content)
109  {
110      send_header(sock, type.data());
111      std::string extra_header = "Content-Length: " + std::__cxx11::to_string(content.size()) + "\r\n";
112      sendall(sock, extra_header);
113      send(sock, "\r\n", 2, 0);
114      if (sendall(sock, content) == -1)
115      {
116          printf("Sending error!");
117      }
118      sendall(sock, "\r\n\r\n");
119  }
120  void send_file(std::string arguments, int sock)
121  {
122      char* extension = file_type(arguments.data());
123      std::string content_type = "text/plain", data;
124      char sizestr[16] = {};
125      int len;
126      if (strcmp(extension, "html") == 0)
127      {
128          content_type = "text/html";
129      }
130      if (strcmp(extension, "gif") == 0)
131      {
132          content_type = "image/gif";
133      }
134      if (strcmp(extension, "jpg") == 0)
135      {
136          content_type = "image/jpg";
137      }
138      send_header(sock, content_type);
139      sendall(sock, "Transfer-Encoding: chunked\r\n\r\n");
140      data = fileGet(arguments);
141      len = data.size();
142      sprintf(sizestr, "%x\r\n", len);
143      if (sendall(sock, sizestr) == -1)
144      {
145          printf("Sending error!");
146      }
147      if (sendall(sock, data) == -1)
148      {
149          printf("Sending error!");
150      }
151      len = 2;
152      sendall(sock, "\r\n");
153      len = 7;
154      sendall(sock, "0\r\n\r\n");
155  }
156  int setTimeout(SOCKET s, int timeout)
157  {
158      int ret = -1;
159  #ifdef _WIN32
160      ret = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(int));
161      ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(int));
162  #else
163      struct timeval timeo = {timeout / 1000, (timeout % 1000) * 1000};
164      ret = setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeo, sizeof(timeo));
165      ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeo, sizeof(timeo));
166  #endif
167      def_timeout = timeout;
168      return ret;
169  }
170  void handle_req(std::string request, int client_sock)
171  {
172      working_thread++;
173      std::cerr<<"worker startup"<<std::endl;
174      string_array vArray;
175      char command[16] = {};
176      char arguments[BUFSIZ] = {};
177      std::string uri, args, target, postdata;
178      if (sscanf(request.data(), "%s%s", command, arguments) != 2)
179      {
180          goto end;
181      }
182      std::cerr<<"handle_cmd:    "<<command<<"\n"<<"handle_path:   "<<arguments<<"\n";
183      vArray = split(arguments, "?");
184      if(vArray.size() > 2)
185      {
186          wrong_req(client_sock);
187          goto end;
188      }
189      else if(vArray.size() > 1)
190      {
191          uri = vArray[0];
192          args = vArray[1];
193      }
194      else
195          uri = arguments;
196      if(strcmp(command, "POST") == 0)
197      {
198          if(request.find("\r\n\r\n") != request.npos)
199              postdata = request.substr(request.find("\r\n\r\n") + 4);
200      }
201      else if(strcmp(command, "OPTIONS") == 0)
202      {
203          serve_options(client_sock);
204          goto end;
205      }
206      for(std::vector<responseRoute>::iterator iter = responses.begin(); iter != responses.end(); ++iter)
207      {
208          if(iter->method.compare(command) == 0 && iter->path == uri)
209          {
210              response_callback &rc = iter->rc;
211              serve_content(client_sock, iter->content_type, rc(args, postdata));
212              goto end;
213          }
214      }
215      file_not_found(uri, client_sock);
216  end:
217      std::cerr<<"worker stop"<<std::endl;
218      sleepMs(1);
219      closesocket(client_sock);
220      working_thread--;
221  }
222  void append_response(const std::string &type, const std::string &request, const std::string &content_type, response_callback response)
223  {
224      responseRoute rr;
225      rr.method = type;
226      rr.path = request;
227      rr.content_type = content_type;
228      rr.rc = response;
229      responses.push_back(std::move(rr));
230  }
231  void stop_web_server()
232  {
233      SERVER_EXIT_FLAG = true;
234  }
235  int start_web_server(void *argv)
236  {
237      struct listener_args *args = (listener_args*)argv;
238      args->max_workers = 1;
239      return start_web_server_multi(args);
240  }
241  int start_web_server_multi(void *argv)
242  {
243      struct listener_args *args = (listener_args*)argv;
244      std::string listen_address = args->listen_address, request;
245      int port = args->port, max_conn = args->max_conn, max_workers = args->max_workers, numbytes, worker_index = 0;
246      socklen_t sock_size = sizeof(struct sockaddr_in);
247      char buf[BUFSIZ];
248      struct sockaddr_in user_socket, server_addr;
249      SOCKET acc_socket;
250      int server_socket, fail_counter = 0;
251      server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
252      std::thread workers[max_workers];
253      if (server_socket == -1)
254      {
255          std::cerr<<"socket build error!"<<std::endl;
256          return 0;
257      }
258      ZeroMemory(&server_addr, sizeof(server_addr));
259      server_addr.sin_family = AF_INET;
260      server_addr.sin_port = htons((short)port);
261      server_addr.sin_addr.s_addr = inet_addr(listen_address.data());
262      if (::bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
263      {
264          std::cerr<<"socket bind error!"<<std::endl;
265          closesocket(server_socket);
266          return 0;
267      }
268      if (listen(server_socket, max_conn) == -1 )
269      {
270          std::cerr<<"socket listen error!"<<std::endl;
271          closesocket(server_socket);
272          return 0;
273      }
274      setTimeout(server_socket, 500);
275      while(true)
276      {
277          acc_socket = accept(server_socket, (struct sockaddr *)&user_socket, &sock_size); 
278          if(acc_socket < 0)
279          {
280              if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
281              {
282                  fail_counter++;
283                  if(fail_counter > max_send_failure)
284                      break;
285                  continue;
286              }
287              else
288              {
289                  break;
290              }
291          }
292          request = "";
293          while(true) 
294          {
295              numbytes = recv(acc_socket, buf, BUFSIZ - 1, 0);
296              if(numbytes > 0) 
297                  request.append(buf);
298              if(numbytes < 0)
299              {
300                  if(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
301                  {
302                      continue;
303                  }
304                  else
305                  {
306                      break;
307                  }
308              }
309              if(numbytes == 0)
310                  break;
311          }
312          while(working_thread >= max_workers)
313          {
314              sleepMs(10);
315              if(SERVER_EXIT_FLAG)
316                  break;
317          }
318          while(workers[worker_index].get_id() != std::thread::id())
319          {
320              worker_index++;
321          }
322          workers[worker_index] = std::thread(handle_req, request, acc_socket);
323          workers[worker_index].detach();
324          worker_index++;
325          if(worker_index > max_workers)
326              worker_index = 0;
327      }
328      return 0;
329  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-compareToolUtilities.h</h3>
            <pre><code>1  #ifndef INCLUDE_CAFFE_UTIL_COMPARETOOLUTILITIES_H_
2  #define INCLUDE_CAFFE_UTIL_COMPARETOOLUTILITIES_H_
3  #include <algorithm>
4  #include <cmath>
5  #include <cstdarg>
6  #include <cstdint>
7  #include <cstdio>
8  #include <cstring>
9  #include <string>
10  #include <unordered_set>
11  #include <vector>
12  #include "float_compare.hpp"
13  template <typename DataType>
14  class Data {
15      int dataSize;
16      DataType *dataPointer;
17      Data(const Data<DataType> &data);
18      Data<DataType> &operator =(const Data<DataType> &data);
19   public:
20          Data() :
21              dataSize(0),
22              dataPointer(NULL) {
23          }
24          ~Data() {
25              clear();
26          }
27          int getDataSize() const {
28              return dataSize;
29          }
30          const DataType *getDataPointer() const {
31              return dataPointer;
32          }
33          void clear() {
34              delete [] dataPointer;
35              dataPointer = NULL;
36              dataSize = 0;
37          }
38          bool loadFromFile(const char *fileName) {
39              boost::filesystem::path filePath(fileName);
40              if (!boost::filesystem::exists(filePath)) {
41                  return false;
42              }
43              if (boost::filesystem::is_empty(filePath)) {
44                  return false;
45              }
46              FILE *file = fopen(fileName, "rb");
47              if (!file)
48                  return false;
49              int64_t fileSize = boost::filesystem::file_size(filePath);
50              DataType *fileDataPointer = new DataType[fileSize];
51              size_t bytesRead = fread(fileDataPointer, 1, fileSize, file);
52              fclose(file);
53              if (bytesRead != fileSize) {
54                  delete [] fileDataPointer;
55                  return false;
56              }
57              clear();
58              dataPointer = fileDataPointer;
59              dataSize = fileSize / sizeof(DataType);
60              return true;
61          }
62  };
63  class Log {
64      FILE *logFile;
65      Log() {
66          logFile = fopen("log.txt", "w+b");
67          CHECK(logFile != NULL) << "Could not open log.txt file";
68      }
69   public:
70          ~Log() {
71              if (logFile)
72                  fclose(logFile);
73          }
74          static void log(const char *format, ...) {
75              va_list args;
76              static Log log;
77              va_start(args, format);
78              vfprintf(log.logFile, format, args);
79              va_start(args, format);
80              vprintf(format, args);
81              va_end(args);
82          }
83  };
84  void getFileName(char *file_name, bool is_target, const char *name, int id) {
85      snprintf(file_name, FILENAME_MAX, "%s%04i.bin", name, id);
86  }
87  void getBinFilePath(char *file_path, const char *name) {
88      snprintf(file_path, FILENAME_MAX, "%s/%s",
89          FLAGS_collect_dir.c_str(), name);
90  }
91  bool saveToFile(const char *prefix,
92      int id, const float *data, unsigned count) {
93      char file_name[FILENAME_MAX];
94      getFileName(file_name, false, prefix, id);
95      FILE *file = fopen((FLAGS_collect_dir + "/" + file_name).c_str(), "w+b");
96      if (!file) {
97          LOG(ERROR) << "Failed to create file '" << FLAGS_collect_dir << "'.";
98          return false;
99      }
<span onclick='openModal()' class='match'>100      size_t bytesToWrite = count * sizeof(data[0]);
101      size_t bytesWritten = fwrite(data, 1, bytesToWrite, file);
102      fclose(file);
103      if (bytesWritten != bytesToWrite) {
104          LOG(ERROR) << "Failed to write data to '" << FLAGS_collect_dir
105              << "' file.";
106          return false;
107      }
</span>108      return true;
109  }
110  bool loadFromFile(const char *file_path, float *data, unsigned count) {
111      FILE *file = fopen(file_path, "rb");
112      if (!file) {
113          LOG(ERROR) << "Failed to open file '" << file_path << "' for read.";
114          return false;
115      }
116      size_t bytesToRead = count * sizeof(data[0]);
117      size_t bytesRead = fread(data, 1, bytesToRead, file);
118      fclose(file);
119      if (bytesRead != bytesToRead) {
120          LOG(ERROR) << "Failed to read data from '" << file_path << "' file.";
121          return false;
122      }
123      return true;
124  }
125  bool compareDataWithFileData(const char *referenceFileName,
126    const float *targetDataPointer, double *maxDiff,
127    unsigned *diffCounter, const char *outputDir) {
128      typedef uint32_t CastType;
129      const char *format = "%i;%08X;%08X;%g;%g;%g\n";
130      const float epsilon = static_cast<float>(FLAGS_epsilon);
131      bool is_nan_filler =
132        std::isnan(static_cast<float>(FLAGS_buffer_filler));
133      Data<float> referenceData;
134      char file_path[FILENAME_MAX];
135      getBinFilePath(file_path, referenceFileName);
136      if (!referenceData.loadFromFile(file_path)) {
137          Log::log("Failed to load reference data file '%s'.\n",
138              referenceFileName);
139          return false;
140      }
141      char diffFileName[FILENAME_MAX];
142      snprintf(diffFileName, FILENAME_MAX, "./%s/OUT%s", outputDir,
143          referenceFileName);
144      FILE *file = fopen(diffFileName, "w+t");
145      if (!file) {
146          return false;
147      }
148      *maxDiff = -1;
149      *diffCounter = 0;
150      int dataSize = referenceData.getDataSize();
151      const float *referenceDataPointer = referenceData.getDataPointer();
152      for (int i = 0; i < dataSize; i++) {
153          float a = referenceDataPointer[i];
154          float b = targetDataPointer[i];
155          if (std::isnan(a) && std::isnan(b) && is_nan_filler){
156              continue;
157          }
158          float diff = caffe::floatDiff(a, b, epsilon);
159          if (diff != FP_ZERO) {
160              fprintf(file, format, i,(CastType)a, (CastType)b, diff, a, b);
161              (*diffCounter)++;
162          }
163          if (*maxDiff < diff) {
164              *maxDiff = diff;
165          }
166          if (FLAGS_fast_compare && (*diffCounter) >= FLAGS_fast_compare_max) {
167              break;
168          }
169      }
170      if (file)
171          fclose(file);
172      return true;
173  }
174  void checkData(const char *referenceFileName, const float *targetDataPointer,
175    const char *layerName, const char *outputDir,
176    std::unordered_set<string> *erronousLayers) {
177      double maxDiff;
178      unsigned diffCounter;
179      bool success = compareDataWithFileData(referenceFileName,
180          targetDataPointer, &maxDiff, &diffCounter, outputDir);
181      if (!success) {
182          Log::log("%-18s %-20s  : failed\n", referenceFileName, layerName);
183      } else if (!diffCounter) {
184          Log::log("%-18s %-20s  : success\n", referenceFileName, layerName);
185      } else {
186          Log::log("%-18s %-20s  : %g %u\n", referenceFileName, layerName,
187              maxDiff, diffCounter);
188          (*erronousLayers).insert(layerName);
189      }
190  }
191  void checkAllNans(const float *targetDataPointer, unsigned count,
192    const char *bufferName, const char *layerName,
193    std::unordered_set<string> *erronousLayers) {
194      float buffer_filler = static_cast<float>(FLAGS_buffer_filler);
195      float epsilon = static_cast<float>(FLAGS_epsilon);
196      if (std::isnan(buffer_filler)){
197          for (int i = 0; i < count; i++) {
198              if (!std::isnan(targetDataPointer[i])) {
199                  Log::log("Not all elements in %s are NaNs\n", bufferName);
200                  (*erronousLayers).insert(layerName);
201                  return;
202              }
203          }
204      } else {
205          for (int i = 0; i < count; i++) {
206              if (caffe::floatDiff(targetDataPointer[i], buffer_filler, epsilon)
207                != FP_ZERO) {
208                  Log::log("Not all elements in %s are %.1f\n",
209                    bufferName, buffer_filler);
210                  (*erronousLayers).insert(layerName);
211                  return;
212              }
213          }
214      }
215  }
216  int collectAndCheckLayerData(bool collect_step,
217    bool use_gpu, const char *output_dir) {
218      Net<float> caffe_net(FLAGS_model, caffe::TRAIN, FLAGS_level,
219        NULL, NULL, FLAGS_engine);
220      const vector<shared_ptr<Layer<float> > >& layers = caffe_net.layers();
221      const vector<shared_ptr<Blob<float> > >& params = caffe_net.params();
222      const vector<vector<Blob<float>*> >& bottom_vecs = caffe_net.bottom_vecs();
223      const vector<vector<Blob<float>*> >& top_vecs = caffe_net.top_vecs();
224      const vector<vector<bool> >& bottom_need_backward =
225          caffe_net.bottom_need_backward();
226      std::unordered_set<string> erronous_layers;
227      FILE *infoFile = fopen(use_gpu ?
228          (FLAGS_collect_dir + "/" + "GPUInfo.txt").c_str() :
229          (FLAGS_collect_dir + "/" + "CPUInfo.txt").c_str(), "w+t");
230      CHECK(infoFile != NULL) << "Could not open info file";
231      char file_name[FILENAME_MAX];
232      char file_path[FILENAME_MAX];
233      string message_prefix = collect_step ? "Collecting" : "Comparing";
234      float buffer_filler = static_cast<float>(FLAGS_buffer_filler);
235      LOG(INFO) << message_prefix << " weights";
236      for (int i = 0; i < params.size(); i++) {
237          if (collect_step) {
238              saveToFile("Wght", i,
239                  params[i]->cpu_data(), params[i]->count());
240          } else {
241              getFileName(file_name, false, "Wght", i);
242              checkData(file_name, params[i]->cpu_data(),
243                  layers[i]->type(), output_dir,
244                  &erronous_layers);
245          }
246          caffe::caffe_set(params[i]->count(), buffer_filler,
247              params[i]->mutable_cpu_diff());
248      }
249      LOG(INFO) << message_prefix << " FW Layers";
250      for (int i = 0; i < layers.size(); ++i) {
251          fprintf(infoFile, "Fwrd%04i %s\n", i, layers[i]->type());
252          if (bottom_need_backward[i].size() > 0 && bottom_need_backward[i][0]) {
253              if (collect_step) {
254                  saveToFile("FwrdBtmDat", i, bottom_vecs[i][0]->cpu_data(),
255                      bottom_vecs[i][0]->count());
256              } else {
257                  getFileName(file_name, false, "FwrdBtmDat", i);
258                  getBinFilePath(file_path, file_name);
259                  loadFromFile(file_path, bottom_vecs[i][0]->mutable_cpu_data(),
260                      bottom_vecs[i][0]->count());
261              }
262          }
263          for (int j = 0; j < bottom_vecs[i].size(); j++) {
264              caffe::caffe_set(bottom_vecs[i][j]->count(), buffer_filler,
265                  bottom_vecs[i][j]->mutable_cpu_diff());
266          }
267          for (int j = 0; j < top_vecs[i].size(); j++) {
268              caffe::caffe_set(top_vecs[i][j]->count(), buffer_filler,
269                  top_vecs[i][j]->mutable_cpu_diff());
270          }
271          layers[i]->Forward(bottom_vecs[i], top_vecs[i]);
272          if (collect_step) {
273              saveToFile("FwrdTopDat", i, top_vecs[i][0]->cpu_data(),
274                  top_vecs[i][0]->count());
275          } else {
276              getFileName(file_name, false, "FwrdTopDat", i);
277              checkData(file_name, top_vecs[i][0]->cpu_data(),
278                  layers[i]->type(), output_dir,
279                  &erronous_layers);
280          }
281          if (bottom_need_backward[i].size() > 0 && bottom_need_backward[i][0]) {
282            if (bottom_vecs[i][0] != top_vecs[i][0]) {
283                getFileName(file_name, false, "FwrdBtmDat", i);
284                checkData(file_name, bottom_vecs[i][0]->cpu_data(),
285                    layers[i]->type(), output_dir,
286                    &erronous_layers);
287            }
288            checkAllNans(bottom_vecs[i][0]->cpu_diff(),
289                bottom_vecs[i][0]->count(), "bottom.diff",
290                layers[i]->type(), &erronous_layers);
291          }
292          checkAllNans(top_vecs[i][0]->cpu_diff(),
293              top_vecs[i][0]->count(), "top.diff",
294              layers[i]->type(), &erronous_layers);
295      }
296      LOG(INFO) << message_prefix
297          << " weights again";
298      for (int i = 0; i < params.size(); i++) {
299          getFileName(file_name, false, "Wght", i);
300          checkData(file_name, params[i]->cpu_data(),
301              layers[i]->type(), output_dir,
302              &erronous_layers);
303          checkAllNans(params[i]->cpu_diff(), params[i]->count(), "param.diff",
304              layers[i]->type(), &erronous_layers);
305      }
306      LOG(INFO) << message_prefix << " BW Layers";
307      for (int i = layers.size() - 1; i >= 0; --i) {
308          fprintf(infoFile, "Bwrd%04i %s\n", i, layers[i]->type());
309          layers[i]->Backward(top_vecs[i],
310              bottom_need_backward[i], bottom_vecs[i]);
311          if (collect_step) {
312              saveToFile("BwrdTopDif", i,
313                  top_vecs[i][0]->cpu_diff(), top_vecs[i][0]->count());
314              if (bottom_need_backward[i].size() > 0 &&
315                  bottom_need_backward[i][0]) {
316                  saveToFile("BwrdBtmDif", i,
317                      bottom_vecs[i][0]->cpu_diff(), bottom_vecs[i][0]->count());
318              }
319          } else {
320              getFileName(file_name, false, "BwrdTopDif", i);
321              checkData(file_name, top_vecs[i][0]->cpu_diff(),
322                  layers[i]->type(), output_dir,
323                  &erronous_layers);
324              if (bottom_need_backward[i].size() > 0 &&
325                  bottom_need_backward[i][0]) {
326                  getFileName(file_name, false, "BwrdBtmDif", i);
327                  checkData(file_name, bottom_vecs[i][0]->cpu_diff(),
328                      layers[i]->type(), output_dir,
329                      &erronous_layers);
330              }
331          }
332      }
333      LOG(INFO) << message_prefix
334          << " weights and gradients";
335      for (int i = 0; i < params.size(); i++) {
336          getFileName(file_name, false, "Wght", i);
337          checkData(file_name, params[i]->cpu_data(),
338              layers[i]->type(), output_dir,
339              &erronous_layers);
340          if (collect_step) {
341              saveToFile("Grad", i,
342                  params[i]->cpu_diff(), params[i]->count());
343          } else {
344              getFileName(file_name, false, "Grad", i);
345              checkData(file_name, params[i]->cpu_diff(),
346                  layers[i]->type(), output_dir,
347                  &erronous_layers);
348          }
349      }
350      fclose(infoFile);
351      if (erronous_layers.size() > 0) {
352          LOG(INFO) << "Invalid layer behaviour detected on: ";
353          for (const std::string& layer_name : erronous_layers) {
354              LOG(WARNING) << "\t" << layer_name;
355          }
356      }
357      return 0;
358  }
359  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-webserver.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-compareToolUtilities.h</div>
                </div>
                <div class="column column_space"><pre><code>63      std::string prompt_info = "Not found:  " + arguments;
64      std::string response = "HTTP/1.1 404 Not Found\r\n"
65                             "Content-Type: text/plain\r\nConnection: close\r\n"
66                             "Access-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: *\r\n"
67                             "Content-Length: " + std::__cxx11::to_string(prompt_info.size()) + "\r\n\r\n" + prompt_info + "\r\n";
68      if (sendall(sock, response) == -1)
69      {
70          printf("Sending error!");
71          return;
72      }
</pre></code></div>
                <div class="column column_space"><pre><code>100      size_t bytesToWrite = count * sizeof(data[0]);
101      size_t bytesWritten = fwrite(data, 1, bytesToWrite, file);
102      fclose(file);
103      if (bytesWritten != bytesToWrite) {
104          LOG(ERROR) << "Failed to write data to '" << FLAGS_collect_dir
105              << "' file.";
106          return false;
107      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    