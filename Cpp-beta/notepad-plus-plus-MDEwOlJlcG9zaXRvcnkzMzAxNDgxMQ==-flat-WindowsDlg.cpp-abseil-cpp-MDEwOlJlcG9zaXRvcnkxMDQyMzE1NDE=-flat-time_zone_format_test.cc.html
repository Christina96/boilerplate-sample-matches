
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.303996770286636%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WindowsDlg.cpp</h3>
            <pre><code>1  #include <functional>
2  #include <algorithm>
3  #include "WindowsDlg.h"
4  #include "WindowsDlgRc.h"
5  #include "DocTabView.h"
6  #include "EncodingMapper.h"
7  #include "localization.h"
8  using namespace std;
9  #ifndef _countof
10  #define _countof(x) (sizeof(x)/sizeof((x)[0]))
11  #endif
12  #ifndef LVS_EX_DOUBLEBUFFER
13  #define LVS_EX_DOUBLEBUFFER     0x00010000
14  #endif
15  #define WD_ROOTNODE					"WindowsDlg"
16  #define WD_CLMNNAME					"ColumnName"
17  #define WD_CLMNPATH					"ColumnPath"
18  #define WD_CLMNTYPE					"ColumnType"
19  #define WD_CLMNSIZE					"ColumnSize"
20  #define WD_NBDOCSTOTAL				"NbDocsTotal"
21  #define WD_MENUCOPYNAME				"MenuCopyName"
22  #define WD_MENUCOPYPATH				"MenuCopyPath"
23  static const TCHAR *readonlyString = TEXT(" [Read Only]");
24  const UINT WDN_NOTIFY = RegisterWindowMessage(TEXT("WDN_NOTIFY"));
25  struct NumericStringEquivalence
26  {
27  	int operator()(const TCHAR* s1, const TCHAR* s2) const
28  	{
29  		return numstrcmp(s1, s2);
30  	}
31  	static inline int numstrcmp_get(const TCHAR **str, int *length)
32  	{
33  		const TCHAR *p = *str;
34  		int value = 0;
35  		for (*length = 0; isdigit(*p); ++(*length))
36  			value = value * 10 + *p++ - '0';
37  		*str = p;
38  		return (value);
39  	}
40  	static int numstrcmp(const TCHAR *str1, const TCHAR *str2)
41  	{
42  		TCHAR *p1 = nullptr, *p2 = nullptr;
43  		int c1 = 0, c2 = 0, lcmp = 0;
44  		for (;;)
45  		{
46  			if (*str1 == 0 || *str2 == 0)
47  			{
48  				if (*str1 != *str2)
49  					lcmp = *str1 - *str2;
50  				break;
51  			}
52  			if (_istdigit(*str1) && _istdigit(*str2))
53  			{
54  				lcmp = wcstol(str1, &p1, 10) - wcstol(str2, &p2, 10);
55  				if ( lcmp == 0 )
56  					lcmp = static_cast<int32_t>((p2 - str2) - (p1 - str1));
57  				if ( lcmp != 0 )
58  					break;
59  				str1 = p1, str2 = p2;
60  			}
61  			else
62  			{
63  				if (_istascii(*str1) && _istupper(*str1))
64  					c1 = towlower(*str1);
65  				else
66  					c1 = *str1;
67  				if (_istascii(*str2) && _istupper(*str2))
68  					c2 = towlower(*str2);
69  				else
70  					c2 = *str2;
71  				lcmp = (c1 - c2);
72  				if (lcmp != 0)
73  					break;
74  				++str1, ++str2;
75  			}
76  		}
77  		return ( lcmp < 0 ) ? -1 : (lcmp > 0 ? 1 : 0);
78  	}
79  };
80  struct BufferEquivalent
81  {
82  	NumericStringEquivalence _strequiv{};
83  	DocTabView* _pTab = nullptr;
84  	int _iColumn = 0;
85  	bool _reverse = false;
86  	BufferEquivalent(DocTabView* pTab, int iColumn, bool reverse)
87  		: _pTab(pTab), _iColumn(iColumn), _reverse(reverse)
88  	{}
89  	bool operator()(int i1, int i2) const
90  	{
91  		if (i1 == i2) return false; 
92  		if (_reverse) std::swap(i1, i2);
93  		return compare(i1, i2);
94  	}
95  	bool compare(int i1, int i2) const
96  	{
97  		if (_iColumn >= 0 && _iColumn <= 3)
98  		{
99  			BufferID bid1 = _pTab->getBufferByIndex(i1);
100  			BufferID bid2 = _pTab->getBufferByIndex(i2);
101  			Buffer * b1 = MainFileManager.getBufferByID(bid1);
102  			Buffer * b2 = MainFileManager.getBufferByID(bid2);
103  			if (_iColumn == 0)
104  			{
105  				const TCHAR *s1 = b1->getFileName();
106  				const TCHAR *s2 = b2->getFileName();
107  				int result = _strequiv(s1, s2);
108  				if (result != 0) 
109  					return result < 0;
110  			}
111  			else if (_iColumn == 2)
112  			{
113  				NppParameters & nppParameters = NppParameters::getInstance();
114  				const TCHAR *s1;
115  				const TCHAR *s2;
116  				Lang *lang1 = nppParameters.getLangFromID(b1->getLangType());
117  				if (lang1)
118  				{
119  					s1 = lang1->getLangName();
120  				}
121  				else
122  					s1 = TEXT("");
123  				Lang *lang2 = nppParameters.getLangFromID(b2->getLangType());
124  				if (lang2)
125  				{
126  					s2 = lang2->getLangName();
127  				}
128  				else
129  					s2 = TEXT("");
130  				int result = _strequiv(s1, s2);
131  				if (result != 0) 
132  					return result < 0;
133  			}
134  			else if (_iColumn == 3)
135  			{
136  				auto t1 = b1->docLength();
137  				auto t2 = b2->docLength();
138  				if (t1 != t2) 
139  					return (t1 < t2);
140  			}
141  			const TCHAR *s1 = b1->getFullPathName();
142  			const TCHAR *s2 = b2->getFullPathName();
143  			return _strequiv(s1, s2) < 0;	
144  		}
145  		return false;
146  	}
147  };
148  BEGIN_WINDOW_MAP(WindowsDlgMap)
149  	BEGINROWS(WRCT_REST,0,RCMARGINS(8,8))
150  		BEGINCOLS(WRCT_REST,0,0)                       
151  			BEGINROWS(WRCT_REST,0,0)
152  				RCREST(IDC_WINDOWS_LIST)
153  			ENDGROUP()
154  			RCSPACE(12)
155  			BEGINROWS(WRCT_TOFIT,0,0)
156  			RCSPACE(12)
157  			RCTOFIT(IDOK)
158  			RCSPACE(-12)
159  			RCTOFIT(IDC_WINDOWS_SAVE)
160  			RCSPACE(-12)
161  			RCTOFIT(IDC_WINDOWS_CLOSE)
162  			RCSPACE(-12)
163  			RCTOFIT(IDC_WINDOWS_SORT)
164  			RCREST(-1)
165  			RCTOFIT(IDCANCEL)
166  			ENDGROUP()
167  		ENDGROUP()
168  	ENDGROUP()
169  END_WINDOW_MAP()
170  RECT WindowsDlg::_lastKnownLocation;
171  WindowsDlg::WindowsDlg() : MyBaseClass(WindowsDlgMap)
172  {
173  	_szMinButton = SIZEZERO;
174  	_szMinListCtrl = SIZEZERO;
175  }
176  void WindowsDlg::init(HINSTANCE hInst, HWND parent, DocTabView *pTab)
177  {
178  	MyBaseClass::init(hInst, parent);
179  	_pTab = pTab;
180  }
181  void WindowsDlg::init(HINSTANCE hInst, HWND parent)
182  {
183  	assert(!"Call other initialize method");
184  	MyBaseClass::init(hInst, parent);
185  	_pTab = NULL;
186  }
187  intptr_t CALLBACK WindowsDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
188  {
189  	switch (message)
190  	{
191  		case WM_INITDIALOG :
192  		{
193  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
194  			pNativeSpeaker->changeDlgLang(_hSelf, "Window");
195  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
196  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
197  			return MyBaseClass::run_dlgProc(message, wParam, lParam);
198  		}
199  		case WM_CTLCOLORDLG:
200  		case WM_CTLCOLORSTATIC:
201  		{
202  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
203  		}
204  		case WM_PRINTCLIENT:
205  		{
206  			if (NppDarkMode::isEnabled())
207  			{
208  				return TRUE;
209  			}
210  			break;
211  		}
212  		case NPPM_INTERNAL_REFRESHDARKMODE:
213  		{
214  			NppDarkMode::autoThemeChildControls(_hSelf);
215  			return TRUE;
216  		}
217  		case WM_COMMAND :
218  		{
219  			switch (wParam)
220  			{
221  				case IDOK:
222  				{
223  					activateCurrent();
224  					return TRUE;
225  				}
226  				case IDCANCEL:
227  				{
228  					::GetWindowRect(_hSelf, &_lastKnownLocation);
229  					EndDialog(_hSelf, IDCANCEL);
230  					return TRUE;
231  				}
232  				case IDC_WINDOWS_SAVE:
233  				{
234  					doSave();
235  					return TRUE;
236  				}
237  				case IDC_WINDOWS_CLOSE:
238  				{
239  					doClose();
240  					return TRUE;
241  				}
242  				case IDC_WINDOWS_SORT:
243  				{
244  					if (_currentColumn == -1)
245  					{
246  						_currentColumn = 0;
247  						_reverseSort = false;
248  						_lastSort = _currentColumn;
249  						updateColumnNames();
250  						doColumnSort();
251  					}
252  					doSortToTabs();
253  					doColumnSort();
254  					break;
255  				}
256  				default:
257  					if (HIWORD(wParam) == 0)
258  					{
259  						switch (LOWORD(wParam))
260  						{
261  						case IDM_WINDOW_COPY_NAME:
262  							putItemsToClipboard(false);
263  							break;
264  						case IDM_WINDOW_COPY_PATH:
265  							putItemsToClipboard(true);
266  							break;
267  						}
268  					}
269  					break;
270  			}
271  			break;
272  		}
273  		case WM_DESTROY:
274  		{
275  			return TRUE;
276  		}
277  		case WM_NOTIFY :
278  		{
279  			if (wParam == IDC_WINDOWS_LIST)
280  			{
281  				NMHDR* pNMHDR = reinterpret_cast<NMHDR*>(lParam);
282  				if (pNMHDR->code == LVN_GETDISPINFO)
283  				{
284  					NMLVDISPINFO *pLvdi = (NMLVDISPINFO *)pNMHDR;
285  					if (pLvdi->item.mask & LVIF_TEXT)
286  					{
287  						pLvdi->item.pszText[0] = 0;
288  						Buffer* buf = getBuffer(pLvdi->item.iItem);
289  						if (!buf)
290  							return FALSE;
291  						generic_string text;
292  						if (pLvdi->item.iSubItem == 0) 
293  						{
294  							text = buf->getFileName();
295  							if (buf->isDirty())
296  							{
297  								text += '*';
298  							}
299  							else if (buf->isReadOnly())
300  							{
301  								text += readonlyString;
302  							}
303  						}
304  						else if (pLvdi->item.iSubItem == 1) 
305  						{
<span onclick='openModal()' class='match'>306  							const TCHAR *fullName = buf->getFullPathName();
307  							const TCHAR *fileName = buf->getFileName();
308  							int len = lstrlen(fullName)-lstrlen(fileName);
</span>309  							if (!len) {
310  								len = 1;
311  								fullName = TEXT("");
312  							}
313  							text.assign(fullName, len);
314  						}
315  						else if (pLvdi->item.iSubItem == 2) 
316  						{
317  							NppParameters& nppParameters = NppParameters::getInstance();
318  							Lang *lang = nppParameters.getLangFromID(buf->getLangType());
319  							if (NULL != lang)
320  							{
321  								text = lang->getLangName();
322  							}
323  						}
324  						else if (pLvdi->item.iSubItem == 3) 
325  						{
326  							size_t docSize = buf->docLength();
327  							string docSizeText = to_string(docSize);
328  							text = wstring(docSizeText.begin(), docSizeText.end());
329  						}
330  						if (static_cast<int>(text.length()) < pLvdi->item.cchTextMax)
331  						{
332  							wcscpy_s(pLvdi->item.pszText, text.length() + 1, text.c_str());
333  						}
334  					}
335  					return TRUE;
336  				}
337  				else if (pNMHDR->code == LVN_COLUMNCLICK) 
338  				{
339  					NMLISTVIEW *pNMLV = (NMLISTVIEW *)pNMHDR;
340  					if (pNMLV->iItem == -1)
341  					{
342  						_currentColumn = pNMLV->iSubItem;
343  						if (_lastSort == _currentColumn)
344  						{
345  							_reverseSort = true;
346  							_lastSort = -1;
347  						}
348  						else
349  						{
350  							_reverseSort = false;
351  							_lastSort = _currentColumn;
352  						}
353  						updateColumnNames();
354  						doColumnSort();
355  					}
356  					return TRUE;
357  				}
358  				else if (pNMHDR->code == LVN_ITEMACTIVATE || pNMHDR->code == LVN_ITEMCHANGED || pNMHDR->code == LVN_ODSTATECHANGED)
359  				{
360  					updateButtonState();
361  					return TRUE;
362  				}
363  				else if (pNMHDR->code == NM_DBLCLK)
364  				{
365  					::PostMessage(_hSelf, WM_COMMAND, IDOK, 0);
366  					return TRUE;
367  				}
368  				else if (pNMHDR->code == LVN_KEYDOWN)
369  				{
370  					NMLVKEYDOWN *lvkd = (NMLVKEYDOWN *)pNMHDR;
371  					short ctrl = GetKeyState(VK_CONTROL);
372  					short alt = GetKeyState(VK_MENU);
373  					short shift = GetKeyState(VK_SHIFT);
374  					if (lvkd->wVKey == 'A' && ctrl<0 && alt>=0 && shift>=0)
375  					{
376  						for (int i=0, n=ListView_GetItemCount(_hList); i<n; ++i)
377  							ListView_SetItemState(_hList, i, LVIS_SELECTED, LVIS_SELECTED);
378  					}
379  					else if (lvkd->wVKey == 'C' && ctrl & 0x80)
380  					{
381  						if (ListView_GetSelectedCount(_hList) != 0)
382  							putItemsToClipboard(true);
383  					}
384  					return TRUE;
385  				}
386  			}
387  			break;
388  		}
389  		case WM_CONTEXTMENU:
390  			{
391  				if (!_listMenu.isCreated())
392  				{
393  					NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
394  					const std::vector<MenuItemUnit> itemUnitArray
395  					{
396  						{IDM_WINDOW_COPY_NAME, pNativeSpeaker->getAttrNameStr(TEXT("Copy Name(s)"), WD_ROOTNODE, WD_MENUCOPYNAME)},
397  						{IDM_WINDOW_COPY_PATH, pNativeSpeaker->getAttrNameStr(TEXT("Copy Pathname(s)"), WD_ROOTNODE, WD_MENUCOPYPATH)}
398  					};
399  					_listMenu.create(_hSelf, itemUnitArray);
400  				}
401  				const bool enableMenu = ListView_GetSelectedCount(_hList) != 0;
402  				_listMenu.enableItem(IDM_WINDOW_COPY_NAME, enableMenu);
403  				_listMenu.enableItem(IDM_WINDOW_COPY_PATH, enableMenu);
404  				POINT p{};
405  				::GetCursorPos(&p);
406  				_listMenu.display(p);
407  			}
408  			return TRUE;
409  	}
410  	return MyBaseClass::run_dlgProc(message, wParam, lParam);
411  }
412  void WindowsDlg::doColumnSort()
413  {
414  	if (_currentColumn == -1)
415  		return;
416  	size_t i = 0;
417  	size_t n = _idxMap.size();
418  	vector<int> sortMap;
419  	sortMap.resize(n);
420  	for (; i < n; ++i)
421  		sortMap[_idxMap[i]] = ListView_GetItemState(_hList, i, LVIS_SELECTED);
422  	stable_sort(_idxMap.begin(), _idxMap.end(), BufferEquivalent(_pTab, _currentColumn, _reverseSort));
423  	for (i = 0; i < n; ++i)
424  		ListView_SetItemState(_hList, i, sortMap[_idxMap[i]] ? LVIS_SELECTED : 0, LVIS_SELECTED);
425  	::InvalidateRect(_hList, &_rc, FALSE);
426  	updateButtonState();
427  }
428  void WindowsDlg::updateButtonState()
429  {
430  	int nSelection = ListView_GetSelectedCount(_hList);
431  	if (nSelection == 0)
432  	{
433  		EnableWindow(GetDlgItem(_hSelf, IDOK), FALSE);
434  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SAVE), FALSE);
435  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_CLOSE), FALSE);
436  	}
437  	else
438  	{
439  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SAVE), TRUE);
440  		EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_CLOSE), TRUE);
441  		if (nSelection == 1)
442  			EnableWindow(GetDlgItem(_hSelf, IDOK), TRUE);
443  		else
444  			EnableWindow(GetDlgItem(_hSelf, IDOK), FALSE);
445  	}
446  	EnableWindow(GetDlgItem(_hSelf, IDC_WINDOWS_SORT), TRUE);
447  }
448  int WindowsDlg::doDialog()
449  {
450  	return static_cast<int>(DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_WINDOWS), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
451  }
452  BOOL WindowsDlg::onInitDialog()
453  {
454  	_winMgr.InitToFitSizeFromCurrent(_hSelf);
455  	_szMinButton = RectToSize(_winMgr.GetRect(IDOK));
456  	_szMinListCtrl = RectToSize(_winMgr.GetRect(IDC_WINDOWS_LIST));
457  	_currentColumn = -1;
458  	_lastSort = -1;
459  	_reverseSort = false;
460  	_winMgr.CalcLayout(_hSelf);
461  	_winMgr.SetWindowPositions(_hSelf);
462  	getClientRect(_rc);
463  	_hList = ::GetDlgItem(_hSelf, IDC_WINDOWS_LIST);
464  	DWORD exStyle = ListView_GetExtendedListViewStyle(_hList);
465  	exStyle |= LVS_EX_HEADERDRAGDROP|LVS_EX_FULLROWSELECT|LVS_EX_DOUBLEBUFFER;
466  	ListView_SetExtendedListViewStyle(_hList, exStyle);
467  	COLORREF fgColor = (NppParameters::getInstance()).getCurrentDefaultFgColor();
468  	COLORREF bgColor = (NppParameters::getInstance()).getCurrentDefaultBgColor();
469  	ListView_SetBkColor(_hList, bgColor);
470  	ListView_SetTextBkColor(_hList, bgColor);
471  	ListView_SetTextColor(_hList, fgColor);
472  	RECT rc{};
473  	GetClientRect(_hList, &rc);
474  	LONG width = rc.right - rc.left;
475  	LVCOLUMN lvColumn{};
476  	lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
477  	lvColumn.fmt = LVCFMT_LEFT;
478  	generic_string columnText;
479  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
480  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Name"), WD_ROOTNODE, WD_CLMNNAME);
481  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
482  	lvColumn.cx = width / 4;
483  	SendMessage(_hList, LVM_INSERTCOLUMN, 0, LPARAM(&lvColumn));
484  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Path"), WD_ROOTNODE, WD_CLMNPATH);
485  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
486  	lvColumn.cx = 300;
487  	SendMessage(_hList, LVM_INSERTCOLUMN, 1, LPARAM(&lvColumn));
488  	lvColumn.fmt = LVCFMT_CENTER;
489  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Type"), WD_ROOTNODE, WD_CLMNTYPE);
490  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
491  	lvColumn.cx = 100;
492  	SendMessage(_hList, LVM_INSERTCOLUMN, 2, LPARAM(&lvColumn));
493  	columnText = TEXT("⇵ ") + pNativeSpeaker->getAttrNameStr(TEXT("Size"), WD_ROOTNODE, WD_CLMNSIZE);
494  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
495  	lvColumn.cx = 100;
496  	SendMessage(_hList, LVM_INSERTCOLUMN, 3, LPARAM(&lvColumn));
497  	fitColumnsToSize();
498  	if (_lastKnownLocation.bottom > 0 && _lastKnownLocation.right > 0)
499  	{
500  		SetWindowPos(_hSelf, NULL, _lastKnownLocation.left, _lastKnownLocation.top,
501  			_lastKnownLocation.right-_lastKnownLocation.left, _lastKnownLocation.bottom-_lastKnownLocation.top, SWP_SHOWWINDOW);
502  	}
503  	else
504  	{
505  		goToCenter();
506  	}
507  	doRefresh(true);
508  	return TRUE;
509  }
510  void WindowsDlg::updateColumnNames()
511  {
512  	LVCOLUMN lvColumn{};
513  	lvColumn.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
514  	lvColumn.fmt = LVCFMT_LEFT;
515  	generic_string columnText;
516  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
517  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Name"), WD_ROOTNODE, WD_CLMNNAME);
518  	if (_currentColumn != 0)
519  	{
520  		columnText = TEXT("⇵ ") + columnText;
521  	}
522  	else if (_reverseSort)
523  	{
524  		columnText = TEXT("△ ") + columnText;
525  	}
526  	else
527  	{
528  		columnText = TEXT("▽ ") + columnText;
529  	}
530  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
531  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 0, 0));
532  	SendMessage(_hList, LVM_SETCOLUMN, 0, LPARAM(&lvColumn));
533  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Path"), WD_ROOTNODE, WD_CLMNPATH);
534  	if (_currentColumn != 1)
535  	{
536  		columnText = TEXT("⇵ ") + columnText;
537  	}
538  	else if (_reverseSort)
539  	{
540  		columnText = TEXT("△ ") + columnText;
541  	}
542  	else
543  	{
544  		columnText = TEXT("▽ ") + columnText;
545  	}
546  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
547  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 1, 0));
548  	SendMessage(_hList, LVM_SETCOLUMN, 1, LPARAM(&lvColumn));
549  	lvColumn.fmt = LVCFMT_CENTER;
550  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Type"), WD_ROOTNODE, WD_CLMNTYPE);
551  	if (_currentColumn != 2)
552  	{
553  		columnText = TEXT("⇵ ") + columnText;
554  	}
555  	else if (_reverseSort)
556  	{
557  		columnText = TEXT("△ ") + columnText;
558  	}
559  	else
560  	{
561  		columnText = TEXT("▽ ") + columnText;
562  	}
563  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
564  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 2, 0));
565  	SendMessage(_hList, LVM_SETCOLUMN, 2, LPARAM(&lvColumn));
566  	columnText = pNativeSpeaker->getAttrNameStr(TEXT("Size"), WD_ROOTNODE, WD_CLMNSIZE);
567  	if (_currentColumn != 3)
568  	{
569  		columnText = TEXT("⇵ ") + columnText;
570  	}
571  	else if (_reverseSort)
572  	{
573  		columnText = TEXT("△ ") + columnText;
574  	}
575  	else
576  	{
577  		columnText = TEXT("▽ ") + columnText;
578  	}
579  	lvColumn.pszText = const_cast<TCHAR *>(columnText.c_str());
580  	lvColumn.cx = static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 3, 0));
581  	SendMessage(_hList, LVM_SETCOLUMN, 3, LPARAM(&lvColumn));
582  }
583  void WindowsDlg::onSize(UINT nType, int cx, int cy)
584  {
585  	MyBaseClass::onSize(nType, cx, cy);
586  	fitColumnsToSize();
587  }
588  void WindowsDlg::onGetMinMaxInfo(MINMAXINFO* lpMMI)
589  {
590  	MyBaseClass::onGetMinMaxInfo(lpMMI);
591  }
592  LRESULT WindowsDlg::onWinMgr(WPARAM wp, LPARAM lp)
593  {
594  	NMWINMGR &nmw = *reinterpret_cast<NMWINMGR *>(lp);
595  	if (nmw.code==NMWINMGR::GET_SIZEINFO) {
596  		switch(wp)
597  		{
598  		case IDOK:
599  		case IDCANCEL:
600  		case IDC_WINDOWS_SAVE:
601  		case IDC_WINDOWS_CLOSE:
602  		case IDC_WINDOWS_SORT:
603  			nmw.sizeinfo.szMin = _szMinButton;
604  			nmw.processed = TRUE;
605  			return TRUE;
606  		case IDC_WINDOWS_LIST:
607  			nmw.sizeinfo.szMin = _szMinListCtrl;
608  			nmw.processed = TRUE;
609  			return TRUE;
610  		}
611  	}
612  	return MyBaseClass::onWinMgr(wp, lp);
613  }
614  void WindowsDlg::doRefresh(bool invalidate &bsol;*= false*/)
615  {
616  	if (_hSelf != NULL && isVisible())
617  	{
618  		if (_hList != NULL)
619  		{
620  			size_t count = (_pTab != NULL) ? _pTab->nbItem() : 0;
621  			size_t oldSize = _idxMap.size();
622  			if (!invalidate && count == oldSize)
623  				return;
624  			if (count != oldSize)
625  			{
626  				size_t lo = 0;
627  				_idxMap.resize(count);
628  				if (oldSize < count)
629  					lo = oldSize;
630  				for (size_t i = lo; i < count; ++i)
631  					_idxMap[i] = int(i);
632  			}
633  			LPARAM lp = invalidate ? LVSICF_NOSCROLL|LVSICF_NOINVALIDATEALL : LVSICF_NOSCROLL;
634  			::SendMessage(_hList, LVM_SETITEMCOUNT, count, lp);
635  			::InvalidateRect(_hList, &_rc, FALSE);
636  			resetSelection();
637  			updateButtonState();
638  			doCount();
639  		}
640  	}
641  }
642  void WindowsDlg::fitColumnsToSize()
643  {
644  	RECT rc{};
645  	if (GetClientRect(_hList, &rc))
646  	{
647  		int len = (rc.right - rc.left);
648  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 0, 0));
649  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 2, 0));
650  		len -= static_cast<int>(SendMessage(_hList, LVM_GETCOLUMNWIDTH, 3, 0));
651  		len -= GetSystemMetrics(SM_CXVSCROLL);
652  		len -= 1;
653  		SendMessage(_hList, LVM_SETCOLUMNWIDTH, 1, len);
654  	}
655  }
656  void WindowsDlg::resetSelection()
657  {
658  	assert(_pTab != nullptr);
659  	auto curSel = _pTab->getCurrentTabIndex();
660  	int pos = 0;
661  	for (vector<int>::iterator itr = _idxMap.begin(), end = _idxMap.end(); itr != end; ++itr, ++pos)
662  	{
663  		if (*itr == curSel)
664  		{
665  			ListView_SetItemState(_hList, pos, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
666  		}
667  		else
668  		{
669  			ListView_SetItemState(_hList, pos, 0, LVIS_SELECTED);
670  		}
671  	}
672  }
673  void WindowsDlg::doSave()
674  {
675  	NMWINDLG nmdlg{};
676  	nmdlg.type = WDT_SAVE;
677  	nmdlg.curSel = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
678  	nmdlg.hwndFrom = _hSelf;
679  	nmdlg.code = WDN_NOTIFY;
680  	nmdlg.nItems = ListView_GetSelectedCount(_hList);
681  	nmdlg.Items = new UINT[nmdlg.nItems];
682  	int i = -1;
683  	for (UINT j = 0; j < nmdlg.nItems; ++j)
684  	{
685  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
686  		if (i == -1) break;
687  		nmdlg.Items[j] = _idxMap[i];
688  	}
689  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
690  	delete[] nmdlg.Items;
691  	::InvalidateRect(_hList, &_rc, FALSE);
692  	ListView_RedrawItems(_hList, 0, ListView_GetSelectedCount(_hList));
693  }
694  void WindowsDlg::destroy()
695  {
696  	::GetWindowRect(_hSelf, &_lastKnownLocation);
697  	HWND hSelf = _hSelf;
698  	_hSelf = NULL;
699  	::DestroyWindow(hSelf);
700  }
701  void WindowsDlg::activateCurrent()
702  {
703  	if (ListView_GetSelectedCount(_hList) == 1)
704  	{
705  		NMWINDLG nmdlg{};
706  		nmdlg.type = WDT_ACTIVATE;
707  		nmdlg.curSel = _idxMap[ListView_GetNextItem(_hList, -1, LVNI_ALL|LVNI_SELECTED)];
708  		nmdlg.hwndFrom = _hSelf;
709  		nmdlg.code = WDN_NOTIFY;
710  		SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
711  		::GetWindowRect(_hSelf, &_lastKnownLocation);
712  		EndDialog(_hSelf, IDOK);
713  	}
714  }
715  void WindowsDlg::doClose()
716  {
717  	NMWINDLG nmdlg{};
718  	nmdlg.type = WDT_CLOSE;
719  	int index = ListView_GetNextItem(_hList, -1, LVNI_ALL|LVNI_SELECTED);
720  	if (index == -1) return;
721  	nmdlg.curSel = _idxMap[index];
722  	nmdlg.hwndFrom = _hSelf;
723  	nmdlg.code = WDN_NOTIFY;
724  	UINT n = nmdlg.nItems = ListView_GetSelectedCount(_hList);
725  	nmdlg.Items = new UINT[nmdlg.nItems];
726  	vector<int> key;
727  	key.resize(n, 0x7fffffff);
728  	int i = -1;
729  	for (UINT j = 0; j < n; ++j)
730  	{
731  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
732  		if (i == -1) break;
733  		ListView_SetItemState(_hList, i, 0, LVIS_SELECTED); 
734  		nmdlg.Items[j] = _idxMap[i];
735  		key[j] = i;
736  	}
737  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
738  	if (nmdlg.processed)
739  	{
740  		vector<int>::iterator kitr = key.begin();
741  		for (UINT i = 0; i < n; ++i, ++kitr)
742  		{
743  			if (nmdlg.Items[i] == ((UINT)-1))
744  			{
745  				int oldVal = _idxMap[*kitr];
746  				_idxMap[*kitr] = -1;
747  				for (vector<int>::iterator itr = _idxMap.begin(), end = _idxMap.end(); itr != end; ++itr)
748  					if (*itr > oldVal)
749  						--(*itr);
750  			}
751  		}
752  		_idxMap.erase(remove_if(_idxMap.begin(), _idxMap.end(), bind(equal_to<int>(), placeholders::_1, -1)), _idxMap.end());
753  	}
754  	delete[] nmdlg.Items;
755  	if (_idxMap.size() < 1)
756  		::SendMessage(_hSelf, WM_CLOSE, 0, 0);
757  	else if (_pTab->nbItem() != _idxMap.size())
758  		doRefresh(true);
759  	else
760  	{
761  		if (index == static_cast<int>(_idxMap.size()))
762  			index -= 1;
763  		if (index >= 0)
764  		{
765  			ListView_SetItemState(_hList, index, LVIS_SELECTED, LVIS_SELECTED);
766  			ListView_RedrawItems(_hList, 0, _idxMap.size() - 1);
767  		}
768  		ListView_SetItemCount(_hList, _idxMap.size());
769  	}
770  	doCount();
771  }
772  void WindowsDlg::doCount()
773  {
774  	NativeLangSpeaker* pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
775  	generic_string msg = pNativeSpeaker->getAttrNameStr(TEXT("Windows"), "Dialog", "Window", "title");
776  	msg += TEXT(" - ");
777  	msg += pNativeSpeaker->getAttrNameStr(TEXT("Total documents: "), WD_ROOTNODE, WD_NBDOCSTOTAL);
778  	msg += TEXT(" ");
779  	msg += to_wstring(_idxMap.size());
780  	SetWindowText(_hSelf,msg.c_str());
781  }
782  void WindowsDlg::doSort()
783  {
784  	if (_pTab == NULL)
785  		return;
786  	size_t count =  _pTab->nbItem();
787  	std::vector<UINT> items(count);
788  	auto currrentTabIndex = _pTab->getCurrentTabIndex();
789  	NMWINDLG nmdlg{};
790  	nmdlg.type = WDT_SORT;
791  	nmdlg.hwndFrom = _hSelf;
792  	nmdlg.curSel = currrentTabIndex;
793  	nmdlg.code = WDN_NOTIFY;
794  	nmdlg.nItems = static_cast<UINT>(count);
795  	nmdlg.Items = items.data();
796  	for (size_t i=0; i < count; ++i)
797  	{
798  		nmdlg.Items[i] = _idxMap[i];
799  	}
800  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
801  	if (nmdlg.processed)
802  	{
803  		_idxMap.clear();
804  		refreshMap();
805  	}
806  	__int64 newPosition = -1;
807  	std::vector<int>::iterator it = std::find(_idxMap.begin(), _idxMap.end(), currrentTabIndex);
808  	if (it != _idxMap.end())
809  	{
810  		newPosition = it - _idxMap.begin();
811  	}
812  	nmdlg.type = WDT_ACTIVATE;
813  	nmdlg.curSel = static_cast<UINT>(newPosition);
814  	nmdlg.hwndFrom = _hSelf;
815  	nmdlg.code = WDN_NOTIFY;	
816  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
817  }
818  void WindowsDlg::sort(int columnID, bool reverseSort)
819  {
820  	refreshMap();
821  	_currentColumn = columnID;
822  	_reverseSort = reverseSort;
823  	stable_sort(_idxMap.begin(), _idxMap.end(), BufferEquivalent(_pTab, _currentColumn, _reverseSort));
824  }
825  void WindowsDlg::sortFileNameASC()
826  {
827  	sort(0, false);
828  }
829  void WindowsDlg::sortFileNameDSC()
830  {
831  	sort(0, true);
832  }
833  void WindowsDlg::sortFilePathASC()
834  {
835  	sort(1, false);
836  }
837  void WindowsDlg::sortFilePathDSC()
838  {
839  	sort(1, true);
840  }
841  void WindowsDlg::sortFileTypeASC()
842  {
843  	sort(2, false);
844  }
845  void WindowsDlg::sortFileTypeDSC()
846  {
847  	sort(2, true);
848  }
849  void WindowsDlg::sortFileSizeASC()
850  {
851  	sort(3, false);
852  }
853  void WindowsDlg::sortFileSizeDSC()
854  {
855  	sort(3, true);
856  }
857  void WindowsDlg::refreshMap()
858  {
859  	size_t count = (_pTab != NULL) ? _pTab->nbItem() : 0;
860  	size_t oldSize = _idxMap.size();
861  	if (count == oldSize)
862  		return;
863  	if (count != oldSize)
864  	{
865  		size_t lo = 0;
866  		_idxMap.resize(count);
867  		if (oldSize < count)
868  			lo = oldSize;
869  		for (size_t i = lo; i < count; ++i)
870  			_idxMap[i] = int(i);
871  	}
872  }
873  void WindowsDlg::doSortToTabs()
874  {
875  	int curSel = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
876  	if (curSel == -1)
877  		curSel = 0;
878  	NMWINDLG nmdlg{};
879  	nmdlg.type = WDT_SORT;
880  	nmdlg.hwndFrom = _hSelf;
881  	nmdlg.curSel = _idxMap[curSel];
882  	nmdlg.code = WDN_NOTIFY;
883  	nmdlg.nItems = ListView_GetItemCount(_hList);
884  	nmdlg.Items = new UINT[nmdlg.nItems];
885  	int i = -1;
886  	for (UINT j = 0; j < nmdlg.nItems; ++j)
887  	{
888  		i = ListView_GetNextItem(_hList, i, LVNI_ALL);
889  		if (i == -1)
890  			break;
891  		nmdlg.Items[j] = _idxMap[i];
892  		if (i == curSel)
893  			nmdlg.curSel = j;
894  	}
895  	SendMessage(_hParent, WDN_NOTIFY, 0, LPARAM(&nmdlg));
896  	if (nmdlg.processed)
897  	{
898  		_idxMap.clear();
899  		doRefresh(true);
900  	}
901  	delete[] nmdlg.Items;
902  }
903  void WindowsDlg::putItemsToClipboard(bool isFullPath)
904  {
905  	std::vector<Buffer*> buffers;
906  	int i = -1;
907  	do
908  	{
909  		i = ListView_GetNextItem(_hList, i, LVNI_SELECTED);
910  		buffers.push_back(getBuffer(i));
911  	}
912  	while (i >= 0);
913  	buf2Clipborad(buffers, isFullPath, _hList);
914  }
915  Buffer* WindowsDlg::getBuffer(int index) const
916  {
917  	if (index < 0 || index >= static_cast<int>(_idxMap.size()))
918  		return nullptr;
919  	index = _idxMap[index];
920  	if (index < 0 || !_pTab || index >= static_cast<int>(_pTab->nbItem()))
921  		return nullptr;
922  	BufferID bufID = _pTab->getBufferByIndex(index);
923  	return MainFileManager.getBufferByID(bufID);
924  }
925  void WindowsMenu::init(HMENU hMainMenu)
926  {
927  	_hMenu = ::GetSubMenu(hMainMenu, MENUINDEX_WINDOW);
928  	_hMenuList = ::GetSubMenu(hMainMenu, MENUINDEX_LIST);
929  }
930  void WindowsMenu::initPopupMenu(HMENU hMenu, DocTabView* pTab)
931  {
932  	bool isDropListMenu = false;
933  	UINT firstId = 0;
934  	UINT limitId = 0;
935  	UINT menuPosId = 0;
936  	if (hMenu == _hMenu)
937  	{
938  		firstId = IDM_WINDOW_MRU_FIRST;
939  		limitId = IDM_WINDOW_MRU_LIMIT;
940  		menuPosId = IDM_WINDOW_WINDOWS;
941  	}
942  	else if (hMenu == _hMenuList)
943  	{
944  		isDropListMenu = true;
945  		if (_limitPrev < pTab->nbItem())
946  		{
947  			_limitPrev = static_cast<UINT>(pTab->nbItem());
948  		}
949  		firstId = IDM_DROPLIST_MRU_FIRST;
950  		limitId = IDM_DROPLIST_MRU_FIRST + _limitPrev - 1;
951  		menuPosId = IDM_DROPLIST_LIST;
952  	}
953  	if (firstId > 0 && limitId > 0 && menuPosId > 0)
954  	{
955  		auto curDoc = pTab->getCurrentTabIndex();
956  		size_t nMaxDoc = static_cast<size_t>(limitId) - firstId + 1;
957  		size_t nDoc = pTab->nbItem();
958  		nDoc = std::min<size_t>(nDoc, nMaxDoc);
959  		UINT id = firstId;
960  		UINT guard = firstId + static_cast<int32_t>(nDoc);
961  		size_t pos = 0;
962  		for (; id < guard; ++id, ++pos)
963  		{
964  			BufferID bufID = pTab->getBufferByIndex(pos);
965  			Buffer* buf = MainFileManager.getBufferByID(bufID);
966  			MENUITEMINFO mii{};
967  			mii.cbSize = sizeof(mii);
968  			mii.fMask = MIIM_STRING | MIIM_STATE | MIIM_ID;
969  			generic_string strBuffer(BuildMenuFileName(60, static_cast<int32_t>(pos), buf->getFileName(), !isDropListMenu));
970  			std::vector<TCHAR> vBuffer(strBuffer.begin(), strBuffer.end());
971  			vBuffer.push_back('\0');
972  			mii.dwTypeData = (&vBuffer[0]);
973  			mii.fState &= ~(MF_GRAYED | MF_DISABLED | MF_CHECKED);
974  			if (static_cast<int32_t>(pos) == curDoc)
975  			{
976  				mii.fState |= MF_CHECKED;
977  			}
978  			mii.wID = id;
979  			UINT state = GetMenuState(hMenu, id, MF_BYCOMMAND);
980  			if (state == static_cast<UINT>(-1))
981  			{
982  				InsertMenuItem(hMenu, menuPosId, TRUE, &mii);
983  				if (isDropListMenu)
984  				{
985  					DeleteMenu(hMenu, menuPosId, FALSE);
986  				}
987  			}
988  			else
989  			{
990  				SetMenuItemInfo(hMenu, id, FALSE, &mii);
991  			}
992  		}
993  		for (; id <= limitId; ++id)
994  		{
995  			DeleteMenu(hMenu, id, FALSE);
996  		}
997  		if (isDropListMenu)
998  		{
999  			_limitPrev = static_cast<UINT>(pTab->nbItem());
1000  		}
1001  	}
1002  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format_test.cc</h3>
            <pre><code>1  #include <chrono>
2  #include <cstdint>
3  #include <iomanip>
4  #include <sstream>
5  #include <string>
6  #include "absl/base/config.h"
7  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
8  #if defined(__linux__)
9  #include <features.h>
10  #endif
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
14  namespace chrono = std::chrono;
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace time_internal {
18  namespace cctz {
19  namespace {
20  #define ExpectTime(tp, tz, y, m, d, hh, mm, ss, off, isdst, zone) \
21    do {                                                            \
22      time_zone::absolute_lookup al = tz.lookup(tp);                \
23      EXPECT_EQ(y, al.cs.year());                                   \
24      EXPECT_EQ(m, al.cs.month());                                  \
25      EXPECT_EQ(d, al.cs.day());                                    \
26      EXPECT_EQ(hh, al.cs.hour());                                  \
27      EXPECT_EQ(mm, al.cs.minute());                                \
28      EXPECT_EQ(ss, al.cs.second());                                \
29      EXPECT_EQ(off, al.offset);                                    \
30      EXPECT_TRUE(isdst == al.is_dst);                              \
31      EXPECT_STREQ(zone, al.abbr);                                  \
32    } while (0)
33  const char RFC3339_full[] = "%Y-%m-%d%ET%H:%M:%E*S%Ez";
34  const char RFC3339_sec[] = "%Y-%m-%d%ET%H:%M:%S%Ez";
35  const char RFC1123_full[] = "%a, %d %b %Y %H:%M:%S %z";
36  const char RFC1123_no_wday[] = "%d %b %Y %H:%M:%S %z";
37  template <typename D>
38  void TestFormatSpecifier(time_point<D> tp, time_zone tz, const std::string& fmt,
39                           const std::string& ans) {
40    EXPECT_EQ(ans, absl::time_internal::cctz::format(fmt, tp, tz)) << fmt;
41    EXPECT_EQ("xxx " + ans,
42              absl::time_internal::cctz::format("xxx " + fmt, tp, tz));
43    EXPECT_EQ(ans + " yyy",
44              absl::time_internal::cctz::format(fmt + " yyy", tp, tz));
45    EXPECT_EQ("xxx " + ans + " yyy",
46              absl::time_internal::cctz::format("xxx " + fmt + " yyy", tp, tz));
47  }
48  }  
49  TEST(Format, TimePointResolution) {
50    const char kFmt[] = "%H:%M:%E*S";
51    const time_zone utc = utc_time_zone();
52    const time_point<chrono::nanoseconds> t0 =
53        chrono::system_clock::from_time_t(1420167845) +
54        chrono::milliseconds(123) + chrono::microseconds(456) +
55        chrono::nanoseconds(789);
56    EXPECT_EQ("03:04:05.123456789",
57              absl::time_internal::cctz::format(
58                  kFmt, chrono::time_point_cast<chrono::nanoseconds>(t0), utc));
59    EXPECT_EQ("03:04:05.123456",
60              absl::time_internal::cctz::format(
61                  kFmt, chrono::time_point_cast<chrono::microseconds>(t0), utc));
62    EXPECT_EQ("03:04:05.123",
63              absl::time_internal::cctz::format(
64                  kFmt, chrono::time_point_cast<chrono::milliseconds>(t0), utc));
65    EXPECT_EQ("03:04:05",
66              absl::time_internal::cctz::format(
67                  kFmt, chrono::time_point_cast<chrono::seconds>(t0), utc));
68    EXPECT_EQ(
69        "03:04:05",
70        absl::time_internal::cctz::format(
71            kFmt, chrono::time_point_cast<absl::time_internal::cctz::seconds>(t0),
72            utc));
73    EXPECT_EQ("03:04:00",
74              absl::time_internal::cctz::format(
75                  kFmt, chrono::time_point_cast<chrono::minutes>(t0), utc));
76    EXPECT_EQ("03:00:00",
77              absl::time_internal::cctz::format(
78                  kFmt, chrono::time_point_cast<chrono::hours>(t0), utc));
79  }
80  TEST(Format, TimePointExtendedResolution) {
81    const char kFmt[] = "%H:%M:%E*S";
82    const time_zone utc = utc_time_zone();
83    const time_point<absl::time_internal::cctz::seconds> tp =
84        chrono::time_point_cast<absl::time_internal::cctz::seconds>(
85            chrono::system_clock::from_time_t(0)) +
86        chrono::hours(12) + chrono::minutes(34) + chrono::seconds(56);
87    EXPECT_EQ(
88        "12:34:56.123456789012345",
89        detail::format(kFmt, tp, detail::femtoseconds(123456789012345), utc));
90    EXPECT_EQ(
91        "12:34:56.012345678901234",
92        detail::format(kFmt, tp, detail::femtoseconds(12345678901234), utc));
93    EXPECT_EQ("12:34:56.001234567890123",
94              detail::format(kFmt, tp, detail::femtoseconds(1234567890123), utc));
95    EXPECT_EQ("12:34:56.000123456789012",
96              detail::format(kFmt, tp, detail::femtoseconds(123456789012), utc));
97    EXPECT_EQ("12:34:56.000000000000123",
98              detail::format(kFmt, tp, detail::femtoseconds(123), utc));
99    EXPECT_EQ("12:34:56.000000000000012",
100              detail::format(kFmt, tp, detail::femtoseconds(12), utc));
101    EXPECT_EQ("12:34:56.000000000000001",
102              detail::format(kFmt, tp, detail::femtoseconds(1), utc));
103  }
104  TEST(Format, Basics) {
105    time_zone tz = utc_time_zone();
106    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
107    EXPECT_EQ("", absl::time_internal::cctz::format("", tp, tz));
108    EXPECT_EQ(" ", absl::time_internal::cctz::format(" ", tp, tz));
109    EXPECT_EQ("  ", absl::time_internal::cctz::format("  ", tp, tz));
110    EXPECT_EQ("xxx", absl::time_internal::cctz::format("xxx", tp, tz));
111    std::string big(128, 'x');
112    EXPECT_EQ(big, absl::time_internal::cctz::format(big, tp, tz));
113    std::string bigger(100000, 'x');
114    EXPECT_EQ(bigger, absl::time_internal::cctz::format(bigger, tp, tz));
115    tp += chrono::hours(13) + chrono::minutes(4) + chrono::seconds(5);
116    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
117          chrono::nanoseconds(8);
118    EXPECT_EQ("1970-01-01",
119              absl::time_internal::cctz::format("%Y-%m-%d", tp, tz));
120    EXPECT_EQ("13:04:05", absl::time_internal::cctz::format("%H:%M:%S", tp, tz));
121    EXPECT_EQ("13:04:05.006",
122              absl::time_internal::cctz::format("%H:%M:%E3S", tp, tz));
123    EXPECT_EQ("13:04:05.006007",
124              absl::time_internal::cctz::format("%H:%M:%E6S", tp, tz));
125    EXPECT_EQ("13:04:05.006007008",
126              absl::time_internal::cctz::format("%H:%M:%E9S", tp, tz));
127  }
128  TEST(Format, PosixConversions) {
129    const time_zone tz = utc_time_zone();
130    auto tp = chrono::system_clock::from_time_t(0);
131    TestFormatSpecifier(tp, tz, "%d", "01");
132    TestFormatSpecifier(tp, tz, "%e", " 1");  
133    TestFormatSpecifier(tp, tz, "%H", "00");
134    TestFormatSpecifier(tp, tz, "%I", "12");
135    TestFormatSpecifier(tp, tz, "%j", "001");
136    TestFormatSpecifier(tp, tz, "%m", "01");
137    TestFormatSpecifier(tp, tz, "%M", "00");
138    TestFormatSpecifier(tp, tz, "%S", "00");
139    TestFormatSpecifier(tp, tz, "%U", "00");
140  #if !defined(__EMSCRIPTEN__)
141    TestFormatSpecifier(tp, tz, "%w", "4");  
142  #endif
143    TestFormatSpecifier(tp, tz, "%W", "00");
144    TestFormatSpecifier(tp, tz, "%y", "70");
145    TestFormatSpecifier(tp, tz, "%Y", "1970");
146    TestFormatSpecifier(tp, tz, "%z", "+0000");
147    TestFormatSpecifier(tp, tz, "%Z", "UTC");
148    TestFormatSpecifier(tp, tz, "%%", "%");
149  #if defined(__linux__)
150    TestFormatSpecifier(tp, tz, "%C", "19");
151    TestFormatSpecifier(tp, tz, "%D", "01/01/70");
152    TestFormatSpecifier(tp, tz, "%F", "1970-01-01");
153    TestFormatSpecifier(tp, tz, "%g", "70");
154    TestFormatSpecifier(tp, tz, "%G", "1970");
155  #if defined(__GLIBC__)
156    TestFormatSpecifier(tp, tz, "%k", " 0");
157    TestFormatSpecifier(tp, tz, "%l", "12");
158  #endif
159    TestFormatSpecifier(tp, tz, "%n", "\n");
160    TestFormatSpecifier(tp, tz, "%R", "00:00");
161    TestFormatSpecifier(tp, tz, "%t", "\t");
162    TestFormatSpecifier(tp, tz, "%T", "00:00:00");
163    TestFormatSpecifier(tp, tz, "%u", "4");  
164    TestFormatSpecifier(tp, tz, "%V", "01");
165    TestFormatSpecifier(tp, tz, "%s", "0");
166  #endif
167  }
168  TEST(Format, LocaleSpecific) {
<span onclick='openModal()' class='match'>169    const time_zone tz = utc_time_zone();
170    auto tp = chrono::system_clock::from_time_t(0);
171    TestFormatSpecifier(tp, tz, "%a", "Thu");
172    TestFormatSpecifier(tp, tz, "%A", "Thursday");
173    TestFormatSpecifier(tp, tz, "%b", "Jan");
174    TestFormatSpecifier(tp, tz, "%B", "January");
175    const std::string s =
176        absl::time_internal::cctz::format("%c", tp, utc_time_zone());
</span>177    EXPECT_THAT(s, testing::HasSubstr("1970"));
178    EXPECT_THAT(s, testing::HasSubstr("00:00:00"));
179    TestFormatSpecifier(tp, tz, "%p", "AM");
180    TestFormatSpecifier(tp, tz, "%x", "01/01/70");
181    TestFormatSpecifier(tp, tz, "%X", "00:00:00");
182  #if defined(__linux__)
183    TestFormatSpecifier(tp, tz, "%h", "Jan");  
184  #if defined(__GLIBC__)
185    TestFormatSpecifier(tp, tz, "%P", "am");
186  #endif
187    TestFormatSpecifier(tp, tz, "%r", "12:00:00 AM");
188    TestFormatSpecifier(tp, tz, "%Ec", "Thu Jan  1 00:00:00 1970");
189    TestFormatSpecifier(tp, tz, "%EC", "19");
190    TestFormatSpecifier(tp, tz, "%Ex", "01/01/70");
191    TestFormatSpecifier(tp, tz, "%EX", "00:00:00");
192    TestFormatSpecifier(tp, tz, "%Ey", "70");
193    TestFormatSpecifier(tp, tz, "%EY", "1970");
194    TestFormatSpecifier(tp, tz, "%Od", "01");
195    TestFormatSpecifier(tp, tz, "%Oe", " 1");
196    TestFormatSpecifier(tp, tz, "%OH", "00");
197    TestFormatSpecifier(tp, tz, "%OI", "12");
198    TestFormatSpecifier(tp, tz, "%Om", "01");
199    TestFormatSpecifier(tp, tz, "%OM", "00");
200    TestFormatSpecifier(tp, tz, "%OS", "00");
201    TestFormatSpecifier(tp, tz, "%Ou", "4");  
202    TestFormatSpecifier(tp, tz, "%OU", "00");
203    TestFormatSpecifier(tp, tz, "%OV", "01");
204    TestFormatSpecifier(tp, tz, "%Ow", "4");  
205    TestFormatSpecifier(tp, tz, "%OW", "00");
206    TestFormatSpecifier(tp, tz, "%Oy", "70");
207  #endif
208  }
209  TEST(Format, Escaping) {
210    const time_zone tz = utc_time_zone();
211    auto tp = chrono::system_clock::from_time_t(0);
212    TestFormatSpecifier(tp, tz, "%%", "%");
213    TestFormatSpecifier(tp, tz, "%%a", "%a");
214    TestFormatSpecifier(tp, tz, "%%b", "%b");
215    TestFormatSpecifier(tp, tz, "%%Ea", "%Ea");
216    TestFormatSpecifier(tp, tz, "%%Es", "%Es");
217    TestFormatSpecifier(tp, tz, "%%E3S", "%E3S");
218    TestFormatSpecifier(tp, tz, "%%OS", "%OS");
219    TestFormatSpecifier(tp, tz, "%%O3S", "%O3S");
220    TestFormatSpecifier(tp, tz, "%%%Y", "%1970");
221    TestFormatSpecifier(tp, tz, "%%%E3S", "%00.000");
222    TestFormatSpecifier(tp, tz, "%%%%E3S", "%%E3S");
223  }
224  TEST(Format, ExtendedSeconds) {
225    const time_zone tz = utc_time_zone();
226    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
227    tp += chrono::seconds(5);
228    EXPECT_EQ("05", absl::time_internal::cctz::format("%E*S", tp, tz));
229    EXPECT_EQ("05", absl::time_internal::cctz::format("%E0S", tp, tz));
230    EXPECT_EQ("05.0", absl::time_internal::cctz::format("%E1S", tp, tz));
231    EXPECT_EQ("05.00", absl::time_internal::cctz::format("%E2S", tp, tz));
232    EXPECT_EQ("05.000", absl::time_internal::cctz::format("%E3S", tp, tz));
233    EXPECT_EQ("05.0000", absl::time_internal::cctz::format("%E4S", tp, tz));
234    EXPECT_EQ("05.00000", absl::time_internal::cctz::format("%E5S", tp, tz));
235    EXPECT_EQ("05.000000", absl::time_internal::cctz::format("%E6S", tp, tz));
236    EXPECT_EQ("05.0000000", absl::time_internal::cctz::format("%E7S", tp, tz));
237    EXPECT_EQ("05.00000000", absl::time_internal::cctz::format("%E8S", tp, tz));
238    EXPECT_EQ("05.000000000", absl::time_internal::cctz::format("%E9S", tp, tz));
239    EXPECT_EQ("05.0000000000",
240              absl::time_internal::cctz::format("%E10S", tp, tz));
241    EXPECT_EQ("05.00000000000",
242              absl::time_internal::cctz::format("%E11S", tp, tz));
243    EXPECT_EQ("05.000000000000",
244              absl::time_internal::cctz::format("%E12S", tp, tz));
245    EXPECT_EQ("05.0000000000000",
246              absl::time_internal::cctz::format("%E13S", tp, tz));
247    EXPECT_EQ("05.00000000000000",
248              absl::time_internal::cctz::format("%E14S", tp, tz));
249    EXPECT_EQ("05.000000000000000",
250              absl::time_internal::cctz::format("%E15S", tp, tz));
251    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
252          chrono::nanoseconds(8);
253    EXPECT_EQ("05.006007008", absl::time_internal::cctz::format("%E*S", tp, tz));
254    EXPECT_EQ("05", absl::time_internal::cctz::format("%E0S", tp, tz));
255    EXPECT_EQ("05.0", absl::time_internal::cctz::format("%E1S", tp, tz));
256    EXPECT_EQ("05.00", absl::time_internal::cctz::format("%E2S", tp, tz));
257    EXPECT_EQ("05.006", absl::time_internal::cctz::format("%E3S", tp, tz));
258    EXPECT_EQ("05.0060", absl::time_internal::cctz::format("%E4S", tp, tz));
259    EXPECT_EQ("05.00600", absl::time_internal::cctz::format("%E5S", tp, tz));
260    EXPECT_EQ("05.006007", absl::time_internal::cctz::format("%E6S", tp, tz));
261    EXPECT_EQ("05.0060070", absl::time_internal::cctz::format("%E7S", tp, tz));
262    EXPECT_EQ("05.00600700", absl::time_internal::cctz::format("%E8S", tp, tz));
263    EXPECT_EQ("05.006007008", absl::time_internal::cctz::format("%E9S", tp, tz));
264    EXPECT_EQ("05.0060070080",
265              absl::time_internal::cctz::format("%E10S", tp, tz));
266    EXPECT_EQ("05.00600700800",
267              absl::time_internal::cctz::format("%E11S", tp, tz));
268    EXPECT_EQ("05.006007008000",
269              absl::time_internal::cctz::format("%E12S", tp, tz));
270    EXPECT_EQ("05.0060070080000",
271              absl::time_internal::cctz::format("%E13S", tp, tz));
272    EXPECT_EQ("05.00600700800000",
273              absl::time_internal::cctz::format("%E14S", tp, tz));
274    EXPECT_EQ("05.006007008000000",
275              absl::time_internal::cctz::format("%E15S", tp, tz));
276    tp = chrono::system_clock::from_time_t(0) + chrono::microseconds(-1);
277    EXPECT_EQ("1969-12-31 23:59:59.999999",
278              absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
279    tp = chrono::system_clock::from_time_t(0) +
280         chrono::microseconds(1395024427333304);
281    EXPECT_EQ("2014-03-17 02:47:07.333304",
282              absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
283    tp += chrono::microseconds(1);
284    EXPECT_EQ("2014-03-17 02:47:07.333305",
285              absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
286  }
287  TEST(Format, ExtendedSubeconds) {
288    const time_zone tz = utc_time_zone();
289    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
290    tp += chrono::seconds(5);
291    EXPECT_EQ("0", absl::time_internal::cctz::format("%E*f", tp, tz));
292    EXPECT_EQ("", absl::time_internal::cctz::format("%E0f", tp, tz));
293    EXPECT_EQ("0", absl::time_internal::cctz::format("%E1f", tp, tz));
294    EXPECT_EQ("00", absl::time_internal::cctz::format("%E2f", tp, tz));
295    EXPECT_EQ("000", absl::time_internal::cctz::format("%E3f", tp, tz));
296    EXPECT_EQ("0000", absl::time_internal::cctz::format("%E4f", tp, tz));
297    EXPECT_EQ("00000", absl::time_internal::cctz::format("%E5f", tp, tz));
298    EXPECT_EQ("000000", absl::time_internal::cctz::format("%E6f", tp, tz));
299    EXPECT_EQ("0000000", absl::time_internal::cctz::format("%E7f", tp, tz));
300    EXPECT_EQ("00000000", absl::time_internal::cctz::format("%E8f", tp, tz));
301    EXPECT_EQ("000000000", absl::time_internal::cctz::format("%E9f", tp, tz));
302    EXPECT_EQ("0000000000", absl::time_internal::cctz::format("%E10f", tp, tz));
303    EXPECT_EQ("00000000000", absl::time_internal::cctz::format("%E11f", tp, tz));
304    EXPECT_EQ("000000000000", absl::time_internal::cctz::format("%E12f", tp, tz));
305    EXPECT_EQ("0000000000000",
306              absl::time_internal::cctz::format("%E13f", tp, tz));
307    EXPECT_EQ("00000000000000",
308              absl::time_internal::cctz::format("%E14f", tp, tz));
309    EXPECT_EQ("000000000000000",
310              absl::time_internal::cctz::format("%E15f", tp, tz));
311    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
312          chrono::nanoseconds(8);
313    EXPECT_EQ("006007008", absl::time_internal::cctz::format("%E*f", tp, tz));
314    EXPECT_EQ("", absl::time_internal::cctz::format("%E0f", tp, tz));
315    EXPECT_EQ("0", absl::time_internal::cctz::format("%E1f", tp, tz));
316    EXPECT_EQ("00", absl::time_internal::cctz::format("%E2f", tp, tz));
317    EXPECT_EQ("006", absl::time_internal::cctz::format("%E3f", tp, tz));
318    EXPECT_EQ("0060", absl::time_internal::cctz::format("%E4f", tp, tz));
319    EXPECT_EQ("00600", absl::time_internal::cctz::format("%E5f", tp, tz));
320    EXPECT_EQ("006007", absl::time_internal::cctz::format("%E6f", tp, tz));
321    EXPECT_EQ("0060070", absl::time_internal::cctz::format("%E7f", tp, tz));
322    EXPECT_EQ("00600700", absl::time_internal::cctz::format("%E8f", tp, tz));
323    EXPECT_EQ("006007008", absl::time_internal::cctz::format("%E9f", tp, tz));
324    EXPECT_EQ("0060070080", absl::time_internal::cctz::format("%E10f", tp, tz));
325    EXPECT_EQ("00600700800", absl::time_internal::cctz::format("%E11f", tp, tz));
326    EXPECT_EQ("006007008000", absl::time_internal::cctz::format("%E12f", tp, tz));
327    EXPECT_EQ("0060070080000",
328              absl::time_internal::cctz::format("%E13f", tp, tz));
329    EXPECT_EQ("00600700800000",
330              absl::time_internal::cctz::format("%E14f", tp, tz));
331    EXPECT_EQ("006007008000000",
332              absl::time_internal::cctz::format("%E15f", tp, tz));
333    tp = chrono::system_clock::from_time_t(0) + chrono::microseconds(-1);
334    EXPECT_EQ(
335        "1969-12-31 23:59:59.999999",
336        absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
337    tp = chrono::system_clock::from_time_t(0) +
338         chrono::microseconds(1395024427333304);
339    EXPECT_EQ(
340        "2014-03-17 02:47:07.333304",
341        absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
342    tp += chrono::microseconds(1);
343    EXPECT_EQ(
344        "2014-03-17 02:47:07.333305",
345        absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
346  }
347  TEST(Format, CompareExtendSecondsVsSubseconds) {
348    const time_zone tz = utc_time_zone();
349    auto fmt_A = [](const std::string& prec) { return "%E" + prec + "S"; };
350    auto fmt_B = [](const std::string& prec) { return "%S.%E" + prec + "f"; };
351    time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
352    tp += chrono::seconds(5);
353    EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("*"), tp, tz));
354    EXPECT_EQ("05.0", absl::time_internal::cctz::format(fmt_B("*"), tp, tz));
355    EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("0"), tp, tz));
356    EXPECT_EQ("05.", absl::time_internal::cctz::format(fmt_B("0"), tp, tz));
357    for (int prec = 1; prec <= 15; ++prec) {
358      const std::string a =
359          absl::time_internal::cctz::format(fmt_A(std::to_string(prec)), tp, tz);
360      const std::string b =
361          absl::time_internal::cctz::format(fmt_B(std::to_string(prec)), tp, tz);
362      EXPECT_EQ(a, b) << "prec=" << prec;
363    }
364    tp += chrono::milliseconds(6) + chrono::microseconds(7) +
365          chrono::nanoseconds(8);
366    EXPECT_EQ("05.006007008",
367              absl::time_internal::cctz::format(fmt_A("*"), tp, tz));
368    EXPECT_EQ("05.006007008",
369              absl::time_internal::cctz::format(fmt_B("*"), tp, tz));
370    EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("0"), tp, tz));
371    EXPECT_EQ("05.", absl::time_internal::cctz::format(fmt_B("0"), tp, tz));
372    for (int prec = 1; prec <= 15; ++prec) {
373      const std::string a =
374          absl::time_internal::cctz::format(fmt_A(std::to_string(prec)), tp, tz);
375      const std::string b =
376          absl::time_internal::cctz::format(fmt_B(std::to_string(prec)), tp, tz);
377      EXPECT_EQ(a, b) << "prec=" << prec;
378    }
379  }
380  TEST(Format, ExtendedOffset) {
381    const auto tp = chrono::system_clock::from_time_t(0);
382    auto tz = fixed_time_zone(absl::time_internal::cctz::seconds::zero());
383    TestFormatSpecifier(tp, tz, "%z", "+0000");
384    TestFormatSpecifier(tp, tz, "%:z", "+00:00");
385    TestFormatSpecifier(tp, tz, "%Ez", "+00:00");
386    tz = fixed_time_zone(chrono::seconds(56));
387    TestFormatSpecifier(tp, tz, "%z", "+0000");
388    TestFormatSpecifier(tp, tz, "%:z", "+00:00");
389    TestFormatSpecifier(tp, tz, "%Ez", "+00:00");
390    tz = fixed_time_zone(-chrono::seconds(56));  
391    TestFormatSpecifier(tp, tz, "%z", "+0000");
392    TestFormatSpecifier(tp, tz, "%:z", "+00:00");
393    TestFormatSpecifier(tp, tz, "%Ez", "+00:00");
394    tz = fixed_time_zone(chrono::minutes(34));
395    TestFormatSpecifier(tp, tz, "%z", "+0034");
396    TestFormatSpecifier(tp, tz, "%:z", "+00:34");
397    TestFormatSpecifier(tp, tz, "%Ez", "+00:34");
398    tz = fixed_time_zone(-chrono::minutes(34));
399    TestFormatSpecifier(tp, tz, "%z", "-0034");
400    TestFormatSpecifier(tp, tz, "%:z", "-00:34");
401    TestFormatSpecifier(tp, tz, "%Ez", "-00:34");
402    tz = fixed_time_zone(chrono::minutes(34) + chrono::seconds(56));
403    TestFormatSpecifier(tp, tz, "%z", "+0034");
404    TestFormatSpecifier(tp, tz, "%:z", "+00:34");
405    TestFormatSpecifier(tp, tz, "%Ez", "+00:34");
406    tz = fixed_time_zone(-chrono::minutes(34) - chrono::seconds(56));
407    TestFormatSpecifier(tp, tz, "%z", "-0034");
408    TestFormatSpecifier(tp, tz, "%:z", "-00:34");
409    TestFormatSpecifier(tp, tz, "%Ez", "-00:34");
410    tz = fixed_time_zone(chrono::hours(12));
411    TestFormatSpecifier(tp, tz, "%z", "+1200");
412    TestFormatSpecifier(tp, tz, "%:z", "+12:00");
413    TestFormatSpecifier(tp, tz, "%Ez", "+12:00");
414    tz = fixed_time_zone(-chrono::hours(12));
415    TestFormatSpecifier(tp, tz, "%z", "-1200");
416    TestFormatSpecifier(tp, tz, "%:z", "-12:00");
417    TestFormatSpecifier(tp, tz, "%Ez", "-12:00");
418    tz = fixed_time_zone(chrono::hours(12) + chrono::seconds(56));
419    TestFormatSpecifier(tp, tz, "%z", "+1200");
420    TestFormatSpecifier(tp, tz, "%:z", "+12:00");
421    TestFormatSpecifier(tp, tz, "%Ez", "+12:00");
422    tz = fixed_time_zone(-chrono::hours(12) - chrono::seconds(56));
423    TestFormatSpecifier(tp, tz, "%z", "-1200");
424    TestFormatSpecifier(tp, tz, "%:z", "-12:00");
425    TestFormatSpecifier(tp, tz, "%Ez", "-12:00");
426    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34));
427    TestFormatSpecifier(tp, tz, "%z", "+1234");
428    TestFormatSpecifier(tp, tz, "%:z", "+12:34");
429    TestFormatSpecifier(tp, tz, "%Ez", "+12:34");
430    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34));
431    TestFormatSpecifier(tp, tz, "%z", "-1234");
432    TestFormatSpecifier(tp, tz, "%:z", "-12:34");
433    TestFormatSpecifier(tp, tz, "%Ez", "-12:34");
434    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34) +
435                         chrono::seconds(56));
436    TestFormatSpecifier(tp, tz, "%z", "+1234");
437    TestFormatSpecifier(tp, tz, "%:z", "+12:34");
438    TestFormatSpecifier(tp, tz, "%Ez", "+12:34");
439    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34) -
440                         chrono::seconds(56));
441    TestFormatSpecifier(tp, tz, "%z", "-1234");
442    TestFormatSpecifier(tp, tz, "%:z", "-12:34");
443    TestFormatSpecifier(tp, tz, "%Ez", "-12:34");
444  }
445  TEST(Format, ExtendedSecondOffset) {
446    const auto tp = chrono::system_clock::from_time_t(0);
447    auto tz = fixed_time_zone(absl::time_internal::cctz::seconds::zero());
448    TestFormatSpecifier(tp, tz, "%E*z", "+00:00:00");
449    TestFormatSpecifier(tp, tz, "%::z", "+00:00:00");
450    TestFormatSpecifier(tp, tz, "%:::z", "+00");
451    tz = fixed_time_zone(chrono::seconds(56));
452    TestFormatSpecifier(tp, tz, "%E*z", "+00:00:56");
453    TestFormatSpecifier(tp, tz, "%::z", "+00:00:56");
454    TestFormatSpecifier(tp, tz, "%:::z", "+00:00:56");
455    tz = fixed_time_zone(-chrono::seconds(56));
456    TestFormatSpecifier(tp, tz, "%E*z", "-00:00:56");
457    TestFormatSpecifier(tp, tz, "%::z", "-00:00:56");
458    TestFormatSpecifier(tp, tz, "%:::z", "-00:00:56");
459    tz = fixed_time_zone(chrono::minutes(34));
460    TestFormatSpecifier(tp, tz, "%E*z", "+00:34:00");
461    TestFormatSpecifier(tp, tz, "%::z", "+00:34:00");
462    TestFormatSpecifier(tp, tz, "%:::z", "+00:34");
463    tz = fixed_time_zone(-chrono::minutes(34));
464    TestFormatSpecifier(tp, tz, "%E*z", "-00:34:00");
465    TestFormatSpecifier(tp, tz, "%::z", "-00:34:00");
466    TestFormatSpecifier(tp, tz, "%:::z", "-00:34");
467    tz = fixed_time_zone(chrono::minutes(34) + chrono::seconds(56));
468    TestFormatSpecifier(tp, tz, "%E*z", "+00:34:56");
469    TestFormatSpecifier(tp, tz, "%::z", "+00:34:56");
470    TestFormatSpecifier(tp, tz, "%:::z", "+00:34:56");
471    tz = fixed_time_zone(-chrono::minutes(34) - chrono::seconds(56));
472    TestFormatSpecifier(tp, tz, "%E*z", "-00:34:56");
473    TestFormatSpecifier(tp, tz, "%::z", "-00:34:56");
474    TestFormatSpecifier(tp, tz, "%:::z", "-00:34:56");
475    tz = fixed_time_zone(chrono::hours(12));
476    TestFormatSpecifier(tp, tz, "%E*z", "+12:00:00");
477    TestFormatSpecifier(tp, tz, "%::z", "+12:00:00");
478    TestFormatSpecifier(tp, tz, "%:::z", "+12");
479    tz = fixed_time_zone(-chrono::hours(12));
480    TestFormatSpecifier(tp, tz, "%E*z", "-12:00:00");
481    TestFormatSpecifier(tp, tz, "%::z", "-12:00:00");
482    TestFormatSpecifier(tp, tz, "%:::z", "-12");
483    tz = fixed_time_zone(chrono::hours(12) + chrono::seconds(56));
484    TestFormatSpecifier(tp, tz, "%E*z", "+12:00:56");
485    TestFormatSpecifier(tp, tz, "%::z", "+12:00:56");
486    TestFormatSpecifier(tp, tz, "%:::z", "+12:00:56");
487    tz = fixed_time_zone(-chrono::hours(12) - chrono::seconds(56));
488    TestFormatSpecifier(tp, tz, "%E*z", "-12:00:56");
489    TestFormatSpecifier(tp, tz, "%::z", "-12:00:56");
490    TestFormatSpecifier(tp, tz, "%:::z", "-12:00:56");
491    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34));
492    TestFormatSpecifier(tp, tz, "%E*z", "+12:34:00");
493    TestFormatSpecifier(tp, tz, "%::z", "+12:34:00");
494    TestFormatSpecifier(tp, tz, "%:::z", "+12:34");
495    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34));
496    TestFormatSpecifier(tp, tz, "%E*z", "-12:34:00");
497    TestFormatSpecifier(tp, tz, "%::z", "-12:34:00");
498    TestFormatSpecifier(tp, tz, "%:::z", "-12:34");
499    tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34) +
500                         chrono::seconds(56));
501    TestFormatSpecifier(tp, tz, "%E*z", "+12:34:56");
502    TestFormatSpecifier(tp, tz, "%::z", "+12:34:56");
503    TestFormatSpecifier(tp, tz, "%:::z", "+12:34:56");
504    tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34) -
505                         chrono::seconds(56));
506    TestFormatSpecifier(tp, tz, "%E*z", "-12:34:56");
507    TestFormatSpecifier(tp, tz, "%::z", "-12:34:56");
508    TestFormatSpecifier(tp, tz, "%:::z", "-12:34:56");
509  }
510  TEST(Format, ExtendedYears) {
511    const time_zone utc = utc_time_zone();
512    const char e4y_fmt[] = "%E4Y%m%d";  
513    auto tp = convert(civil_second(-999, 11, 27, 0, 0, 0), utc);
514    EXPECT_EQ("-9991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
515    tp = convert(civil_second(-99, 11, 27, 0, 0, 0), utc);
516    EXPECT_EQ("-0991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
517    tp = convert(civil_second(-9, 11, 27, 0, 0, 0), utc);
518    EXPECT_EQ("-0091127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
519    tp = convert(civil_second(-1, 11, 27, 0, 0, 0), utc);
520    EXPECT_EQ("-0011127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
521    tp = convert(civil_second(0, 11, 27, 0, 0, 0), utc);
522    EXPECT_EQ("00001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
523    tp = convert(civil_second(1, 11, 27, 0, 0, 0), utc);
524    EXPECT_EQ("00011127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
525    tp = convert(civil_second(9, 11, 27, 0, 0, 0), utc);
526    EXPECT_EQ("00091127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
527    tp = convert(civil_second(99, 11, 27, 0, 0, 0), utc);
528    EXPECT_EQ("00991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
529    tp = convert(civil_second(999, 11, 27, 0, 0, 0), utc);
530    EXPECT_EQ("09991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
531    tp = convert(civil_second(9999, 11, 27, 0, 0, 0), utc);
532    EXPECT_EQ("99991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
533    tp = convert(civil_second(-1000, 11, 27, 0, 0, 0), utc);
534    EXPECT_EQ("-10001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
535    tp = convert(civil_second(10000, 11, 27, 0, 0, 0), utc);
536    EXPECT_EQ("100001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
537  }
538  TEST(Format, RFC3339Format) {
539    time_zone tz;
540    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
541    time_point<chrono::nanoseconds> tp =
542        convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
543    EXPECT_EQ("1977-06-28T09:08:07-07:00",
544              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
545    EXPECT_EQ("1977-06-28T09:08:07-07:00",
546              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
547    tp += chrono::milliseconds(100);
548    EXPECT_EQ("1977-06-28T09:08:07.1-07:00",
549              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
550    EXPECT_EQ("1977-06-28T09:08:07-07:00",
551              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
552    tp += chrono::milliseconds(20);
553    EXPECT_EQ("1977-06-28T09:08:07.12-07:00",
554              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
555    EXPECT_EQ("1977-06-28T09:08:07-07:00",
556              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
557    tp += chrono::milliseconds(3);
558    EXPECT_EQ("1977-06-28T09:08:07.123-07:00",
559              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
560    EXPECT_EQ("1977-06-28T09:08:07-07:00",
561              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
562    tp += chrono::microseconds(400);
563    EXPECT_EQ("1977-06-28T09:08:07.1234-07:00",
564              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
565    EXPECT_EQ("1977-06-28T09:08:07-07:00",
566              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
567    tp += chrono::microseconds(50);
568    EXPECT_EQ("1977-06-28T09:08:07.12345-07:00",
569              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
570    EXPECT_EQ("1977-06-28T09:08:07-07:00",
571              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
572    tp += chrono::microseconds(6);
573    EXPECT_EQ("1977-06-28T09:08:07.123456-07:00",
574              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
575    EXPECT_EQ("1977-06-28T09:08:07-07:00",
576              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
577    tp += chrono::nanoseconds(700);
578    EXPECT_EQ("1977-06-28T09:08:07.1234567-07:00",
579              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
580    EXPECT_EQ("1977-06-28T09:08:07-07:00",
581              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
582    tp += chrono::nanoseconds(80);
583    EXPECT_EQ("1977-06-28T09:08:07.12345678-07:00",
584              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
585    EXPECT_EQ("1977-06-28T09:08:07-07:00",
586              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
587    tp += chrono::nanoseconds(9);
588    EXPECT_EQ("1977-06-28T09:08:07.123456789-07:00",
589              absl::time_internal::cctz::format(RFC3339_full, tp, tz));
590    EXPECT_EQ("1977-06-28T09:08:07-07:00",
591              absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
592  }
593  TEST(Format, RFC1123Format) {  
594    time_zone tz;
595    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
596    auto tp = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
597    EXPECT_EQ("Tue, 28 Jun 1977 09:08:07 -0700",
598              absl::time_internal::cctz::format(RFC1123_full, tp, tz));
599    EXPECT_EQ("28 Jun 1977 09:08:07 -0700",
600              absl::time_internal::cctz::format(RFC1123_no_wday, tp, tz));
601  }
602  TEST(Format, Week) {
603    const time_zone utc = utc_time_zone();
604    auto tp = convert(civil_second(2017, 1, 1, 0, 0, 0), utc);
605    EXPECT_EQ("2017-01-7",
606              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
607    EXPECT_EQ("2017-00-0",
608              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
609    tp = convert(civil_second(2017, 12, 31, 0, 0, 0), utc);
610    EXPECT_EQ("2017-53-7",
611              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
612    EXPECT_EQ("2017-52-0",
613              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
614    tp = convert(civil_second(2018, 1, 1, 0, 0, 0), utc);
615    EXPECT_EQ("2018-00-1",
616              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
617    EXPECT_EQ("2018-01-1",
618              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
619    tp = convert(civil_second(2018, 12, 31, 0, 0, 0), utc);
620    EXPECT_EQ("2018-52-1",
621              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
622    EXPECT_EQ("2018-53-1",
623              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
624    tp = convert(civil_second(2019, 1, 1, 0, 0, 0), utc);
625    EXPECT_EQ("2019-00-2",
626              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
627    EXPECT_EQ("2019-00-2",
628              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
629    tp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
630    EXPECT_EQ("2019-52-2",
631              absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
632    EXPECT_EQ("2019-52-2",
633              absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
634  }
635  TEST(Parse, TimePointResolution) {
636    const char kFmt[] = "%H:%M:%E*S";
637    const time_zone utc = utc_time_zone();
638    time_point<chrono::nanoseconds> tp_ns;
639    EXPECT_TRUE(parse(kFmt, "03:04:05.123456789", utc, &tp_ns));
640    EXPECT_EQ("03:04:05.123456789",
641              absl::time_internal::cctz::format(kFmt, tp_ns, utc));
642    EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_ns));
643    EXPECT_EQ("03:04:05.123456",
644              absl::time_internal::cctz::format(kFmt, tp_ns, utc));
645    time_point<chrono::microseconds> tp_us;
646    EXPECT_TRUE(parse(kFmt, "03:04:05.123456789", utc, &tp_us));
647    EXPECT_EQ("03:04:05.123456",
648              absl::time_internal::cctz::format(kFmt, tp_us, utc));
649    EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_us));
650    EXPECT_EQ("03:04:05.123456",
651              absl::time_internal::cctz::format(kFmt, tp_us, utc));
652    EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_us));
653    EXPECT_EQ("03:04:05.123",
654              absl::time_internal::cctz::format(kFmt, tp_us, utc));
655    time_point<chrono::milliseconds> tp_ms;
656    EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_ms));
657    EXPECT_EQ("03:04:05.123",
658              absl::time_internal::cctz::format(kFmt, tp_ms, utc));
659    EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_ms));
660    EXPECT_EQ("03:04:05.123",
661              absl::time_internal::cctz::format(kFmt, tp_ms, utc));
662    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_ms));
663    EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_ms, utc));
664    time_point<chrono::seconds> tp_s;
665    EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_s));
666    EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_s, utc));
667    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_s));
668    EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_s, utc));
669    time_point<chrono::minutes> tp_m;
670    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_m));
671    EXPECT_EQ("03:04:00", absl::time_internal::cctz::format(kFmt, tp_m, utc));
672    time_point<chrono::hours> tp_h;
673    EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_h));
674    EXPECT_EQ("03:00:00", absl::time_internal::cctz::format(kFmt, tp_h, utc));
675  }
676  TEST(Parse, TimePointExtendedResolution) {
677    const char kFmt[] = "%H:%M:%E*S";
678    const time_zone utc = utc_time_zone();
679    time_point<absl::time_internal::cctz::seconds> tp;
680    detail::femtoseconds fs;
681    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.123456789012345", utc, &tp, &fs));
682    EXPECT_EQ("12:34:56.123456789012345", detail::format(kFmt, tp, fs, utc));
683    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.012345678901234", utc, &tp, &fs));
684    EXPECT_EQ("12:34:56.012345678901234", detail::format(kFmt, tp, fs, utc));
685    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.001234567890123", utc, &tp, &fs));
686    EXPECT_EQ("12:34:56.001234567890123", detail::format(kFmt, tp, fs, utc));
687    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000123", utc, &tp, &fs));
688    EXPECT_EQ("12:34:56.000000000000123", detail::format(kFmt, tp, fs, utc));
689    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000012", utc, &tp, &fs));
690    EXPECT_EQ("12:34:56.000000000000012", detail::format(kFmt, tp, fs, utc));
691    EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000001", utc, &tp, &fs));
692    EXPECT_EQ("12:34:56.000000000000001", detail::format(kFmt, tp, fs, utc));
693  }
694  TEST(Parse, Basics) {
695    time_zone tz = utc_time_zone();
696    time_point<chrono::nanoseconds> tp =
697        chrono::system_clock::from_time_t(1234567890);
698    EXPECT_TRUE(parse("", "", tz, &tp));
699    EXPECT_EQ(chrono::system_clock::from_time_t(0), tp);  
700    EXPECT_TRUE(parse(" ", " ", tz, &tp));
701    EXPECT_TRUE(parse("  ", "  ", tz, &tp));
702    EXPECT_TRUE(parse("x", "x", tz, &tp));
703    EXPECT_TRUE(parse("xxx", "xxx", tz, &tp));
704    EXPECT_TRUE(
705        parse("%Y-%m-%d %H:%M:%S %z", "2013-06-28 19:08:09 -0800", tz, &tp));
706    ExpectTime(tp, tz, 2013, 6, 29, 3, 8, 9, 0, false, "UTC");
707  }
708  TEST(Parse, WithTimeZone) {
709    time_zone tz;
710    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
711    time_point<chrono::nanoseconds> tp;
712    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2013-06-28 19:08:09", tz, &tp));
713    ExpectTime(tp, tz, 2013, 6, 28, 19, 8, 9, -7 * 60 * 60, true, "PDT");
714    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S %z", "2013-06-28 19:08:09 +0800",
715                      utc_time_zone(), &tp));
716    ExpectTime(tp, tz, 2013, 6, 28, 19 - 8 - 7, 8, 9, -7 * 60 * 60, true, "PDT");
717    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2011-03-13 02:15:00", tz, &tp));
718    ExpectTime(tp, tz, 2011, 3, 13, 3, 15, 0, -7 * 60 * 60, true, "PDT");
719    EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2011-11-06 01:15:00", tz, &tp));
720    ExpectTime(tp, tz, 2011, 11, 6, 1, 15, 0, -7 * 60 * 60, true, "PDT");
721  }
722  TEST(Parse, LeapSecond) {
723    time_zone tz;
724    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
725    time_point<chrono::nanoseconds> tp;
726    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:59-08:00", tz, &tp));
727    ExpectTime(tp, tz, 2013, 6, 28, 8, 8, 59, -7 * 60 * 60, true, "PDT");
728    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:59.5-08:00", tz, &tp));
729    ExpectTime(tp, tz, 2013, 6, 28, 8, 8, 59, -7 * 60 * 60, true, "PDT");
730    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:60-08:00", tz, &tp));
731    ExpectTime(tp, tz, 2013, 6, 28, 8, 9, 0, -7 * 60 * 60, true, "PDT");
732    EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:60.5-08:00", tz, &tp));
733    ExpectTime(tp, tz, 2013, 6, 28, 8, 9, 0, -7 * 60 * 60, true, "PDT");
734    EXPECT_FALSE(parse(RFC3339_full, "2013-06-28T07:08:61-08:00", tz, &tp));
735  }
736  TEST(Parse, ErrorCases) {
737    const time_zone tz = utc_time_zone();
738    auto tp = chrono::system_clock::from_time_t(0);
739    EXPECT_FALSE(parse("%S", "123", tz, &tp));
740    EXPECT_FALSE(parse("%Q", "x", tz, &tp));
741    EXPECT_FALSE(parse("%m-%d", "2-3 blah", tz, &tp));
742    EXPECT_TRUE(parse("%m-%d", "2-3  ", tz, &tp));
743    EXPECT_EQ(2, convert(tp, utc_time_zone()).month());
744    EXPECT_EQ(3, convert(tp, utc_time_zone()).day());
745    EXPECT_FALSE(parse("%m-%d", "2-31", tz, &tp));
746    EXPECT_TRUE(parse("%z", "-0203", tz, &tp));
747    EXPECT_FALSE(parse("%z", "- 2 3", tz, &tp));
748    EXPECT_TRUE(parse("%Ez", "-02:03", tz, &tp));
749    EXPECT_FALSE(parse("%Ez", "- 2: 3", tz, &tp));
750    EXPECT_FALSE(parse("%Ez", "+-08:00", tz, &tp));
751    EXPECT_FALSE(parse("%Ez", "-+08:00", tz, &tp));
752    EXPECT_FALSE(parse("%Y", "-0", tz, &tp));
753    EXPECT_FALSE(parse("%E4Y", "-0", tz, &tp));
754    EXPECT_FALSE(parse("%H", "-0", tz, &tp));
755    EXPECT_FALSE(parse("%M", "-0", tz, &tp));
756    EXPECT_FALSE(parse("%S", "-0", tz, &tp));
757    EXPECT_FALSE(parse("%z", "+-000", tz, &tp));
758    EXPECT_FALSE(parse("%Ez", "+-0:00", tz, &tp));
759    EXPECT_FALSE(parse("%z", "-00-0", tz, &tp));
760    EXPECT_FALSE(parse("%Ez", "-00:-0", tz, &tp));
761  }
762  TEST(Parse, PosixConversions) {
763    time_zone tz = utc_time_zone();
764    auto tp = chrono::system_clock::from_time_t(0);
765    const auto reset = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
766    tp = reset;
767    EXPECT_TRUE(parse("%d", "15", tz, &tp));
768    EXPECT_EQ(15, convert(tp, tz).day());
769    tp = reset;
770    EXPECT_TRUE(parse("%e", "15", tz, &tp));
771    EXPECT_EQ(15, convert(tp, tz).day());  
772    tp = reset;
773    EXPECT_TRUE(parse("%H", "17", tz, &tp));
774    EXPECT_EQ(17, convert(tp, tz).hour());
775    tp = reset;
776    EXPECT_TRUE(parse("%I", "5", tz, &tp));
777    EXPECT_EQ(5, convert(tp, tz).hour());
778    EXPECT_TRUE(parse("%j", "32", tz, &tp));
779    tp = reset;
780    EXPECT_TRUE(parse("%m", "11", tz, &tp));
781    EXPECT_EQ(11, convert(tp, tz).month());
782    tp = reset;
783    EXPECT_TRUE(parse("%M", "33", tz, &tp));
784    EXPECT_EQ(33, convert(tp, tz).minute());
785    tp = reset;
786    EXPECT_TRUE(parse("%S", "55", tz, &tp));
787    EXPECT_EQ(55, convert(tp, tz).second());
788    EXPECT_TRUE(parse("%U", "15", tz, &tp));
789    EXPECT_TRUE(parse("%w", "2", tz, &tp));
790    EXPECT_TRUE(parse("%W", "22", tz, &tp));
791    tp = reset;
792    EXPECT_TRUE(parse("%y", "04", tz, &tp));
793    EXPECT_EQ(2004, convert(tp, tz).year());
794    tp = reset;
795    EXPECT_TRUE(parse("%Y", "2004", tz, &tp));
796    EXPECT_EQ(2004, convert(tp, tz).year());
797    EXPECT_TRUE(parse("%%", "%", tz, &tp));
798  #if defined(__linux__)
799  #if 0
800    tp = reset;
801    EXPECT_TRUE(parse("%C %y", "20 04", tz, &tp));
802    EXPECT_EQ(2004, convert(tp, tz).year());
803  #endif
804    tp = reset;
805    EXPECT_TRUE(parse("%D", "02/03/04", tz, &tp));
806    EXPECT_EQ(2, convert(tp, tz).month());
807    EXPECT_EQ(3, convert(tp, tz).day());
808    EXPECT_EQ(2004, convert(tp, tz).year());
809    EXPECT_TRUE(parse("%n", "\n", tz, &tp));
810    tp = reset;
811    EXPECT_TRUE(parse("%R", "03:44", tz, &tp));
812    EXPECT_EQ(3, convert(tp, tz).hour());
813    EXPECT_EQ(44, convert(tp, tz).minute());
814    EXPECT_TRUE(parse("%t", "\t\v\f\n\r ", tz, &tp));
815    tp = reset;
816    EXPECT_TRUE(parse("%T", "03:44:55", tz, &tp));
817    EXPECT_EQ(3, convert(tp, tz).hour());
818    EXPECT_EQ(44, convert(tp, tz).minute());
819    EXPECT_EQ(55, convert(tp, tz).second());
820    tp = reset;
821    EXPECT_TRUE(parse("%s", "1234567890", tz, &tp));
822    EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);
823    time_zone lax;
824    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &lax));
825    tp = reset;
826    EXPECT_TRUE(parse("%s", "1234567890", lax, &tp));
827    EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);
828    tp = reset;
829    EXPECT_TRUE(parse("%s", "1414917000", lax, &tp));
830    EXPECT_EQ(chrono::system_clock::from_time_t(1414917000), tp);
831    tp = reset;
832    EXPECT_TRUE(parse("%s", "1414920600", lax, &tp));
833    EXPECT_EQ(chrono::system_clock::from_time_t(1414920600), tp);
834  #endif
835  }
836  TEST(Parse, LocaleSpecific) {
837    time_zone tz = utc_time_zone();
838    auto tp = chrono::system_clock::from_time_t(0);
839    const auto reset = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
840    EXPECT_TRUE(parse("%a", "Mon", tz, &tp));
841    EXPECT_TRUE(parse("%A", "Monday", tz, &tp));
842    tp = reset;
843    EXPECT_TRUE(parse("%b", "Feb", tz, &tp));
844    EXPECT_EQ(2, convert(tp, tz).month());
845    tp = reset;
846    EXPECT_TRUE(parse("%B", "February", tz, &tp));
847    EXPECT_EQ(2, convert(tp, tz).month());
848    EXPECT_TRUE(parse("%p", "AM", tz, &tp));
849    tp = reset;
850    EXPECT_TRUE(parse("%I %p", "5 PM", tz, &tp));
851    EXPECT_EQ(17, convert(tp, tz).hour());
852    tp = reset;
853    EXPECT_TRUE(parse("%x", "02/03/04", tz, &tp));
854    if (convert(tp, tz).month() == 2) {
855      EXPECT_EQ(3, convert(tp, tz).day());
856    } else {
857      EXPECT_EQ(2, convert(tp, tz).day());
858      EXPECT_EQ(3, convert(tp, tz).month());
859    }
860    EXPECT_EQ(2004, convert(tp, tz).year());
861    tp = reset;
862    EXPECT_TRUE(parse("%X", "15:44:55", tz, &tp));
863    EXPECT_EQ(15, convert(tp, tz).hour());
864    EXPECT_EQ(44, convert(tp, tz).minute());
865    EXPECT_EQ(55, convert(tp, tz).second());
866  #if defined(__linux__)
867    tp = reset;
868    EXPECT_TRUE(parse("%h", "Feb", tz, &tp));
869    EXPECT_EQ(2, convert(tp, tz).month());  
870  #if defined(__GLIBC__)
871    tp = reset;
872    EXPECT_TRUE(parse("%l %p", "5 PM", tz, &tp));
873    EXPECT_EQ(17, convert(tp, tz).hour());
874  #endif
875    tp = reset;
876    EXPECT_TRUE(parse("%r", "03:44:55 PM", tz, &tp));
877    EXPECT_EQ(15, convert(tp, tz).hour());
878    EXPECT_EQ(44, convert(tp, tz).minute());
879    EXPECT_EQ(55, convert(tp, tz).second());
880  #if defined(__GLIBC__)
881    tp = reset;
882    EXPECT_TRUE(parse("%Ec", "Tue Nov 19 05:06:07 2013", tz, &tp));
883    EXPECT_EQ(convert(civil_second(2013, 11, 19, 5, 6, 7), tz), tp);
884    tp = reset;
885    EXPECT_TRUE(parse("%Ex", "02/03/04", tz, &tp));
886    EXPECT_EQ(2, convert(tp, tz).month());
887    EXPECT_EQ(3, convert(tp, tz).day());
888    EXPECT_EQ(2004, convert(tp, tz).year());
889    tp = reset;
890    EXPECT_TRUE(parse("%EX", "15:44:55", tz, &tp));
891    EXPECT_EQ(15, convert(tp, tz).hour());
892    EXPECT_EQ(44, convert(tp, tz).minute());
893    EXPECT_EQ(55, convert(tp, tz).second());
894    tp = reset;
895    EXPECT_TRUE(parse("%EY", "2004", tz, &tp));
896    EXPECT_EQ(2004, convert(tp, tz).year());
897    tp = reset;
898    EXPECT_TRUE(parse("%Od", "15", tz, &tp));
899    EXPECT_EQ(15, convert(tp, tz).day());
900    tp = reset;
901    EXPECT_TRUE(parse("%Oe", "15", tz, &tp));
902    EXPECT_EQ(15, convert(tp, tz).day());  
903    tp = reset;
904    EXPECT_TRUE(parse("%OH", "17", tz, &tp));
905    EXPECT_EQ(17, convert(tp, tz).hour());
906    tp = reset;
907    EXPECT_TRUE(parse("%OI", "5", tz, &tp));
908    EXPECT_EQ(5, convert(tp, tz).hour());
909    tp = reset;
910    EXPECT_TRUE(parse("%Om", "11", tz, &tp));
911    EXPECT_EQ(11, convert(tp, tz).month());
912    tp = reset;
913    EXPECT_TRUE(parse("%OM", "33", tz, &tp));
914    EXPECT_EQ(33, convert(tp, tz).minute());
915    tp = reset;
916    EXPECT_TRUE(parse("%OS", "55", tz, &tp));
917    EXPECT_EQ(55, convert(tp, tz).second());
918    EXPECT_TRUE(parse("%OU", "15", tz, &tp));
919    EXPECT_TRUE(parse("%Ow", "2", tz, &tp));
920    EXPECT_TRUE(parse("%OW", "22", tz, &tp));
921    tp = reset;
922    EXPECT_TRUE(parse("%Oy", "04", tz, &tp));
923    EXPECT_EQ(2004, convert(tp, tz).year());
924  #endif
925  #endif
926  }
927  TEST(Parse, ExtendedSeconds) {
928    const time_zone tz = utc_time_zone();
929    const time_point<chrono::nanoseconds> unix_epoch =
930        chrono::system_clock::from_time_t(0);
931    auto precisions = {"*", "0", "1",  "2",  "3",  "4",  "5",  "6", "7",
932                       "8", "9", "10", "11", "12", "13", "14", "15"};
933    for (const std::string prec : precisions) {
934      const std::string fmt = "%E" + prec + "S";
935      SCOPED_TRACE(fmt);
936      time_point<chrono::nanoseconds> tp = unix_epoch;
937      EXPECT_TRUE(parse(fmt, "5", tz, &tp));
938      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
939      tp = unix_epoch;
940      EXPECT_TRUE(parse(fmt, "05", tz, &tp));
941      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
942      tp = unix_epoch;
943      EXPECT_TRUE(parse(fmt, "05.0", tz, &tp));
944      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
945      tp = unix_epoch;
946      EXPECT_TRUE(parse(fmt, "05.00", tz, &tp));
947      EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
948      tp = unix_epoch;
949      EXPECT_TRUE(parse(fmt, "05.6", tz, &tp));
950      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
951      tp = unix_epoch;
952      EXPECT_TRUE(parse(fmt, "05.60", tz, &tp));
953      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
954      tp = unix_epoch;
955      EXPECT_TRUE(parse(fmt, "05.600", tz, &tp));
956      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
957      tp = unix_epoch;
958      EXPECT_TRUE(parse(fmt, "05.67", tz, &tp));
959      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(670), tp);
960      tp = unix_epoch;
961      EXPECT_TRUE(parse(fmt, "05.670", tz, &tp));
962      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(670), tp);
963      tp = unix_epoch;
964      EXPECT_TRUE(parse(fmt, "05.678", tz, &tp));
965      EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(678), tp);
966    }
967    time_point<chrono::nanoseconds> tp = unix_epoch;
968    EXPECT_TRUE(parse("%E*S", "0.2147483647", tz, &tp));
969    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
970    tp = unix_epoch;
971    EXPECT_TRUE(parse("%E*S", "0.2147483648", tz, &tp));
972    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
973    tp = unix_epoch;
974    EXPECT_TRUE(parse(
975        "%E*S", "0.214748364801234567890123456789012345678901234567890123456789",
976        tz, &tp));
977    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
978  }
979  TEST(Parse, ExtendedSecondsScan) {
980    const time_zone tz = utc_time_zone();
981    time_point<chrono::nanoseconds> tp;
982    for (int ms = 0; ms < 1000; ms += 111) {
983      for (int us = 0; us < 1000; us += 27) {
984        const int micros = ms * 1000 + us;
985        for (int ns = 0; ns < 1000; ns += 9) {
986          const auto expected = chrono::system_clock::from_time_t(0) +
987                                chrono::nanoseconds(micros * 1000 + ns);
988          std::ostringstream oss;
989          oss << "0." << std::setfill('0') << std::setw(3);
990          oss << ms << std::setw(3) << us << std::setw(3) << ns;
991          const std::string input = oss.str();
992          EXPECT_TRUE(parse("%E*S", input, tz, &tp));
993          EXPECT_EQ(expected, tp) << input;
994        }
995      }
996    }
997  }
998  TEST(Parse, ExtendedSubeconds) {
999    const time_zone tz = utc_time_zone();
1000    const time_point<chrono::nanoseconds> unix_epoch =
1001        chrono::system_clock::from_time_t(0);
1002    auto precisions = {"*", "0", "1",  "2",  "3",  "4",  "5",  "6", "7",
1003                       "8", "9", "10", "11", "12", "13", "14", "15"};
1004    for (const std::string prec : precisions) {
1005      const std::string fmt = "%E" + prec + "f";
1006      SCOPED_TRACE(fmt);
1007      time_point<chrono::nanoseconds> tp = unix_epoch - chrono::seconds(1);
1008      EXPECT_TRUE(parse(fmt, "", tz, &tp));
1009      EXPECT_EQ(unix_epoch, tp);
1010      tp = unix_epoch;
1011      EXPECT_TRUE(parse(fmt, "6", tz, &tp));
1012      EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
1013      tp = unix_epoch;
1014      EXPECT_TRUE(parse(fmt, "60", tz, &tp));
1015      EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
1016      tp = unix_epoch;
1017      EXPECT_TRUE(parse(fmt, "600", tz, &tp));
1018      EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
1019      tp = unix_epoch;
1020      EXPECT_TRUE(parse(fmt, "67", tz, &tp));
1021      EXPECT_EQ(unix_epoch + chrono::milliseconds(670), tp);
1022      tp = unix_epoch;
1023      EXPECT_TRUE(parse(fmt, "670", tz, &tp));
1024      EXPECT_EQ(unix_epoch + chrono::milliseconds(670), tp);
1025      tp = unix_epoch;
1026      EXPECT_TRUE(parse(fmt, "678", tz, &tp));
1027      EXPECT_EQ(unix_epoch + chrono::milliseconds(678), tp);
1028      tp = unix_epoch;
1029      EXPECT_TRUE(parse(fmt, "6789", tz, &tp));
1030      EXPECT_EQ(
1031          unix_epoch + chrono::milliseconds(678) + chrono::microseconds(900), tp);
1032    }
1033    time_point<chrono::nanoseconds> tp = unix_epoch;
1034    EXPECT_TRUE(parse("%E*f", "2147483647", tz, &tp));
1035    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
1036    tp = unix_epoch;
1037    EXPECT_TRUE(parse("%E*f", "2147483648", tz, &tp));
1038    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
1039    tp = unix_epoch;
1040    EXPECT_TRUE(parse(
1041        "%E*f", "214748364801234567890123456789012345678901234567890123456789",
1042        tz, &tp));
1043    EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
1044  }
1045  TEST(Parse, ExtendedSubecondsScan) {
1046    time_point<chrono::nanoseconds> tp;
1047    const time_zone tz = utc_time_zone();
1048    for (int ms = 0; ms < 1000; ms += 111) {
1049      for (int us = 0; us < 1000; us += 27) {
1050        const int micros = ms * 1000 + us;
1051        for (int ns = 0; ns < 1000; ns += 9) {
1052          std::ostringstream oss;
1053          oss << std::setfill('0') << std::setw(3) << ms;
1054          oss << std::setw(3) << us << std::setw(3) << ns;
1055          const std::string nanos = oss.str();
1056          const auto expected = chrono::system_clock::from_time_t(0) +
1057                                chrono::nanoseconds(micros * 1000 + ns);
1058          for (int ps = 0; ps < 1000; ps += 250) {
1059            std::ostringstream ps_oss;
1060            oss << std::setfill('0') << std::setw(3) << ps;
1061            const std::string input = nanos + ps_oss.str() + "999";
1062            EXPECT_TRUE(parse("%E*f", input, tz, &tp));
1063            EXPECT_EQ(expected + chrono::nanoseconds(ps) / 1000, tp) << input;
1064          }
1065        }
1066      }
1067    }
1068  }
1069  TEST(Parse, ExtendedOffset) {
1070    const time_zone utc = utc_time_zone();
1071    time_point<absl::time_internal::cctz::seconds> tp;
1072    EXPECT_TRUE(parse("%Ez", "+00:00", utc, &tp));
1073    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1074    EXPECT_TRUE(parse("%Ez", "-12:34", utc, &tp));
1075    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1076    EXPECT_TRUE(parse("%Ez", "+12:34", utc, &tp));
1077    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1078    EXPECT_FALSE(parse("%Ez", "-12:3", utc, &tp));
1079    for (auto fmt : {"%Ez", "%z"}) {
1080      EXPECT_TRUE(parse(fmt, "+0000", utc, &tp));
1081      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1082      EXPECT_TRUE(parse(fmt, "-1234", utc, &tp));
1083      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1084      EXPECT_TRUE(parse(fmt, "+1234", utc, &tp));
1085      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1086      EXPECT_FALSE(parse(fmt, "-123", utc, &tp));
1087      EXPECT_TRUE(parse(fmt, "+00", utc, &tp));
1088      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1089      EXPECT_TRUE(parse(fmt, "-12", utc, &tp));
1090      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 0, 0), utc), tp);
1091      EXPECT_TRUE(parse(fmt, "+12", utc, &tp));
1092      EXPECT_EQ(convert(civil_second(1969, 12, 31, 12, 0, 0), utc), tp);
1093      EXPECT_FALSE(parse(fmt, "-1", utc, &tp));
1094    }
1095  }
1096  TEST(Parse, ExtendedSecondOffset) {
1097    const time_zone utc = utc_time_zone();
1098    time_point<absl::time_internal::cctz::seconds> tp;
1099    for (auto fmt : {"%Ez", "%E*z", "%:z", "%::z", "%:::z"}) {
1100      EXPECT_TRUE(parse(fmt, "+00:00:00", utc, &tp));
1101      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1102      EXPECT_TRUE(parse(fmt, "-12:34:56", utc, &tp));
1103      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 56), utc), tp);
1104      EXPECT_TRUE(parse(fmt, "+12:34:56", utc, &tp));
1105      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 25, 4), utc), tp);
1106      EXPECT_FALSE(parse(fmt, "-12:34:5", utc, &tp));
1107      EXPECT_TRUE(parse(fmt, "+000000", utc, &tp));
1108      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1109      EXPECT_TRUE(parse(fmt, "-123456", utc, &tp));
1110      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 56), utc), tp);
1111      EXPECT_TRUE(parse(fmt, "+123456", utc, &tp));
1112      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 25, 4), utc), tp);
1113      EXPECT_FALSE(parse(fmt, "-12345", utc, &tp));
1114      EXPECT_TRUE(parse(fmt, "+00:00", utc, &tp));
1115      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1116      EXPECT_TRUE(parse(fmt, "-12:34", utc, &tp));
1117      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1118      EXPECT_TRUE(parse(fmt, "+12:34", utc, &tp));
1119      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1120      EXPECT_FALSE(parse(fmt, "-12:3", utc, &tp));
1121      EXPECT_TRUE(parse(fmt, "+0000", utc, &tp));
1122      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1123      EXPECT_TRUE(parse(fmt, "-1234", utc, &tp));
1124      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
1125      EXPECT_TRUE(parse(fmt, "+1234", utc, &tp));
1126      EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
1127      EXPECT_FALSE(parse(fmt, "-123", utc, &tp));
1128      EXPECT_TRUE(parse(fmt, "+00", utc, &tp));
1129      EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
1130      EXPECT_TRUE(parse(fmt, "-12", utc, &tp));
1131      EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 0, 0), utc), tp);
1132      EXPECT_TRUE(parse(fmt, "+12", utc, &tp));
1133      EXPECT_EQ(convert(civil_second(1969, 12, 31, 12, 0, 0), utc), tp);
1134      EXPECT_FALSE(parse(fmt, "-1", utc, &tp));
1135    }
1136  }
1137  TEST(Parse, ExtendedYears) {
1138    const time_zone utc = utc_time_zone();
1139    const char e4y_fmt[] = "%E4Y%m%d";  
1140    time_point<absl::time_internal::cctz::seconds> tp;
1141    EXPECT_TRUE(parse(e4y_fmt, "-9991127", utc, &tp));
1142    EXPECT_EQ(convert(civil_second(-999, 11, 27, 0, 0, 0), utc), tp);
1143    EXPECT_TRUE(parse(e4y_fmt, "-0991127", utc, &tp));
1144    EXPECT_EQ(convert(civil_second(-99, 11, 27, 0, 0, 0), utc), tp);
1145    EXPECT_TRUE(parse(e4y_fmt, "-0091127", utc, &tp));
1146    EXPECT_EQ(convert(civil_second(-9, 11, 27, 0, 0, 0), utc), tp);
1147    EXPECT_TRUE(parse(e4y_fmt, "-0011127", utc, &tp));
1148    EXPECT_EQ(convert(civil_second(-1, 11, 27, 0, 0, 0), utc), tp);
1149    EXPECT_TRUE(parse(e4y_fmt, "00001127", utc, &tp));
1150    EXPECT_EQ(convert(civil_second(0, 11, 27, 0, 0, 0), utc), tp);
1151    EXPECT_TRUE(parse(e4y_fmt, "00011127", utc, &tp));
1152    EXPECT_EQ(convert(civil_second(1, 11, 27, 0, 0, 0), utc), tp);
1153    EXPECT_TRUE(parse(e4y_fmt, "00091127", utc, &tp));
1154    EXPECT_EQ(convert(civil_second(9, 11, 27, 0, 0, 0), utc), tp);
1155    EXPECT_TRUE(parse(e4y_fmt, "00991127", utc, &tp));
1156    EXPECT_EQ(convert(civil_second(99, 11, 27, 0, 0, 0), utc), tp);
1157    EXPECT_TRUE(parse(e4y_fmt, "09991127", utc, &tp));
1158    EXPECT_EQ(convert(civil_second(999, 11, 27, 0, 0, 0), utc), tp);
1159    EXPECT_TRUE(parse(e4y_fmt, "99991127", utc, &tp));
1160    EXPECT_EQ(convert(civil_second(9999, 11, 27, 0, 0, 0), utc), tp);
1161    EXPECT_FALSE(parse(e4y_fmt, "-10001127", utc, &tp));
1162    EXPECT_FALSE(parse(e4y_fmt, "100001127", utc, &tp));
1163  }
1164  TEST(Parse, RFC3339Format) {
1165    const time_zone tz = utc_time_zone();
1166    time_point<chrono::nanoseconds> tp;
1167    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00+00:00", tz, &tp));
1168    ExpectTime(tp, tz, 2014, 2, 12, 20, 21, 0, 0, false, "UTC");
1169    time_point<chrono::nanoseconds> tp2;
1170    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12t20:21:00+00:00", tz, &tp2));
1171    EXPECT_EQ(tp, tp2);
1172    time_point<chrono::nanoseconds> tp3;
1173    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00Z", tz, &tp3));
1174    EXPECT_EQ(tp, tp3);
1175    time_point<chrono::nanoseconds> tp4;
1176    EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00z", tz, &tp4));
1177    EXPECT_EQ(tp, tp4);
1178  }
1179  TEST(Parse, Week) {
1180    const time_zone utc = utc_time_zone();
1181    time_point<absl::time_internal::cctz::seconds> tp;
1182    auto exp = convert(civil_second(2017, 1, 1, 0, 0, 0), utc);
1183    EXPECT_TRUE(parse("%Y-%U-%u", "2017-01-7", utc, &tp));
1184    EXPECT_EQ(exp, tp);
1185    EXPECT_TRUE(parse("%Y-%W-%w", "2017-00-0", utc, &tp));
1186    EXPECT_EQ(exp, tp);
1187    exp = convert(civil_second(2017, 12, 31, 0, 0, 0), utc);
1188    EXPECT_TRUE(parse("%Y-%U-%u", "2017-53-7", utc, &tp));
1189    EXPECT_EQ(exp, tp);
1190    EXPECT_TRUE(parse("%Y-%W-%w", "2017-52-0", utc, &tp));
1191    EXPECT_EQ(exp, tp);
1192    exp = convert(civil_second(2018, 1, 1, 0, 0, 0), utc);
1193    EXPECT_TRUE(parse("%Y-%U-%u", "2018-00-1", utc, &tp));
1194    EXPECT_EQ(exp, tp);
1195    EXPECT_TRUE(parse("%Y-%W-%w", "2018-01-1", utc, &tp));
1196    EXPECT_EQ(exp, tp);
1197    exp = convert(civil_second(2018, 12, 31, 0, 0, 0), utc);
1198    EXPECT_TRUE(parse("%Y-%U-%u", "2018-52-1", utc, &tp));
1199    EXPECT_EQ(exp, tp);
1200    EXPECT_TRUE(parse("%Y-%W-%w", "2018-53-1", utc, &tp));
1201    EXPECT_EQ(exp, tp);
1202    exp = convert(civil_second(2019, 1, 1, 0, 0, 0), utc);
1203    EXPECT_TRUE(parse("%Y-%U-%u", "2019-00-2", utc, &tp));
1204    EXPECT_EQ(exp, tp);
1205    EXPECT_TRUE(parse("%Y-%W-%w", "2019-00-2", utc, &tp));
1206    EXPECT_EQ(exp, tp);
1207    exp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
1208    EXPECT_TRUE(parse("%Y-%U-%u", "2019-52-2", utc, &tp));
1209    EXPECT_EQ(exp, tp);
1210    EXPECT_TRUE(parse("%Y-%W-%w", "2019-52-2", utc, &tp));
1211    EXPECT_EQ(exp, tp);
1212  }
1213  TEST(Parse, WeekYearShift) {
1214    const time_zone utc = utc_time_zone();
1215    time_point<absl::time_internal::cctz::seconds> tp;
1216    auto exp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
1217    EXPECT_TRUE(parse("%Y-%U-%u", "2020-00-2", utc, &tp));
1218    EXPECT_EQ(exp, tp);
1219    EXPECT_TRUE(parse("%Y-%W-%w", "2020-00-2", utc, &tp));
1220    EXPECT_EQ(exp, tp);
1221    exp = convert(civil_second(2021, 1, 1, 0, 0, 0), utc);
1222    EXPECT_TRUE(parse("%Y-%U-%u", "2020-52-5", utc, &tp));
1223    EXPECT_EQ(exp, tp);
1224    EXPECT_TRUE(parse("%Y-%W-%w", "2020-52-5", utc, &tp));
1225    EXPECT_EQ(exp, tp);
1226    EXPECT_FALSE(parse("%Y-%U-%u", "-9223372036854775808-0-7", utc, &tp));
1227    EXPECT_FALSE(parse("%Y-%U-%u", "9223372036854775807-53-7", utc, &tp));
1228  }
1229  TEST(Parse, MaxRange) {
1230    const time_zone utc = utc_time_zone();
1231    time_point<absl::time_internal::cctz::seconds> tp;
1232    EXPECT_TRUE(
1233        parse(RFC3339_sec, "292277026596-12-04T15:30:07+00:00", utc, &tp));
1234    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::max());
1235    EXPECT_FALSE(
1236        parse(RFC3339_sec, "292277026596-12-04T15:30:08+00:00", utc, &tp));
1237    EXPECT_TRUE(
1238        parse(RFC3339_sec, "292277026596-12-04T14:30:07-01:00", utc, &tp));
1239    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::max());
1240    EXPECT_FALSE(
1241        parse(RFC3339_sec, "292277026596-12-04T14:30:08-01:00", utc, &tp));
1242    EXPECT_TRUE(
1243        parse(RFC3339_sec, "-292277022657-01-27T08:29:52+00:00", utc, &tp));
1244    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::min());
1245    EXPECT_FALSE(
1246        parse(RFC3339_sec, "-292277022657-01-27T08:29:51+00:00", utc, &tp));
1247    EXPECT_TRUE(
1248        parse(RFC3339_sec, "-292277022657-01-27T09:29:52+01:00", utc, &tp));
1249    EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::min());
1250    EXPECT_FALSE(
1251        parse(RFC3339_sec, "-292277022657-01-27T08:29:51+01:00", utc, &tp));
1252    EXPECT_FALSE(
1253        parse(RFC3339_sec, "9223372036854775807-12-31T23:59:59-00:01", utc, &tp));
1254    EXPECT_FALSE(parse(RFC3339_sec, "-9223372036854775808-01-01T00:00:00+00:01",
1255                       utc, &tp));
1256  }
1257  TEST(Parse, TimePointOverflow) {
1258    const time_zone utc = utc_time_zone();
1259    using D = chrono::duration<std::int64_t, std::nano>;
1260    time_point<D> tp;
1261    EXPECT_TRUE(
1262        parse(RFC3339_full, "2262-04-11T23:47:16.8547758079+00:00", utc, &tp));
1263    EXPECT_EQ(tp, time_point<D>::max());
1264    EXPECT_EQ("2262-04-11T23:47:16.854775807+00:00",
1265              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1266  #if 0
1267    EXPECT_FALSE(
1268        parse(RFC3339_full, "2262-04-11T23:47:16.8547758080+00:00", utc, &tp));
1269    EXPECT_TRUE(
1270        parse(RFC3339_full, "1677-09-21T00:12:43.1452241920+00:00", utc, &tp));
1271    EXPECT_EQ(tp, time_point<D>::min());
1272    EXPECT_EQ("1677-09-21T00:12:43.145224192+00:00",
1273              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1274    EXPECT_FALSE(
1275        parse(RFC3339_full, "1677-09-21T00:12:43.1452241919+00:00", utc, &tp));
1276  #endif
1277    using DS = chrono::duration<std::int8_t, chrono::seconds::period>;
1278    time_point<DS> stp;
1279    EXPECT_TRUE(parse(RFC3339_full, "1970-01-01T00:02:07.9+00:00", utc, &stp));
1280    EXPECT_EQ(stp, time_point<DS>::max());
1281    EXPECT_EQ("1970-01-01T00:02:07+00:00",
1282              absl::time_internal::cctz::format(RFC3339_full, stp, utc));
1283    EXPECT_FALSE(parse(RFC3339_full, "1970-01-01T00:02:08+00:00", utc, &stp));
1284    EXPECT_TRUE(parse(RFC3339_full, "1969-12-31T23:57:52+00:00", utc, &stp));
1285    EXPECT_EQ(stp, time_point<DS>::min());
1286    EXPECT_EQ("1969-12-31T23:57:52+00:00",
1287              absl::time_internal::cctz::format(RFC3339_full, stp, utc));
1288    EXPECT_FALSE(parse(RFC3339_full, "1969-12-31T23:57:51.9+00:00", utc, &stp));
1289    using DM = chrono::duration<std::int8_t, chrono::minutes::period>;
1290    time_point<DM> mtp;
1291    EXPECT_TRUE(parse(RFC3339_full, "1970-01-01T02:07:59+00:00", utc, &mtp));
1292    EXPECT_EQ(mtp, time_point<DM>::max());
1293    EXPECT_EQ("1970-01-01T02:07:00+00:00",
1294              absl::time_internal::cctz::format(RFC3339_full, mtp, utc));
1295    EXPECT_FALSE(parse(RFC3339_full, "1970-01-01T02:08:00+00:00", utc, &mtp));
1296    EXPECT_TRUE(parse(RFC3339_full, "1969-12-31T21:52:00+00:00", utc, &mtp));
1297    EXPECT_EQ(mtp, time_point<DM>::min());
1298    EXPECT_EQ("1969-12-31T21:52:00+00:00",
1299              absl::time_internal::cctz::format(RFC3339_full, mtp, utc));
1300    EXPECT_FALSE(parse(RFC3339_full, "1969-12-31T21:51:59+00:00", utc, &mtp));
1301  }
1302  TEST(Parse, TimePointOverflowFloor) {
1303    const time_zone utc = utc_time_zone();
1304    using D = chrono::duration<std::int64_t, std::micro>;
1305    time_point<D> tp;
1306    EXPECT_TRUE(
1307        parse(RFC3339_full, "294247-01-10T04:00:54.7758079+00:00", utc, &tp));
1308    EXPECT_EQ(tp, time_point<D>::max());
1309    EXPECT_EQ("294247-01-10T04:00:54.775807+00:00",
1310              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1311  #if 0
1312    EXPECT_FALSE(
1313        parse(RFC3339_full, "294247-01-10T04:00:54.7758080+00:00", utc, &tp));
1314    EXPECT_TRUE(
1315        parse(RFC3339_full, "-290308-12-21T19:59:05.2241920+00:00", utc, &tp));
1316    EXPECT_EQ(tp, time_point<D>::min());
1317    EXPECT_EQ("-290308-12-21T19:59:05.224192+00:00",
1318              absl::time_internal::cctz::format(RFC3339_full, tp, utc));
1319    EXPECT_FALSE(
1320        parse(RFC3339_full, "-290308-12-21T19:59:05.2241919+00:00", utc, &tp));
1321  #endif
1322  }
1323  TEST(FormatParse, RoundTrip) {
1324    time_zone lax;
1325    EXPECT_TRUE(load_time_zone("America/Los_Angeles", &lax));
1326    const auto in = convert(civil_second(1977, 6, 28, 9, 8, 7), lax);
1327    const auto subseconds = chrono::nanoseconds(654321);
1328    {
1329      time_point<chrono::nanoseconds> out;
1330      const std::string s =
1331          absl::time_internal::cctz::format(RFC3339_full, in + subseconds, lax);
1332      EXPECT_TRUE(parse(RFC3339_full, s, lax, &out)) << s;
1333      EXPECT_EQ(in + subseconds, out);  
1334    }
1335    {
1336      time_point<chrono::nanoseconds> out;
1337      const std::string s =
1338          absl::time_internal::cctz::format(RFC1123_full, in, lax);
1339      EXPECT_TRUE(parse(RFC1123_full, s, lax, &out)) << s;
1340      EXPECT_EQ(in, out);  
1341    }
1342  #if defined(_WIN32) || defined(_WIN64)
1343  #elif defined(__EMSCRIPTEN__)
1344  #else
1345    {
1346      time_point<chrono::nanoseconds> out;
1347      time_zone utc = utc_time_zone();
1348      const std::string s = absl::time_internal::cctz::format("%c", in, utc);
1349      EXPECT_TRUE(parse("%c", s, utc, &out)) << s;
1350      EXPECT_EQ(in, out);
1351    }
1352  #endif
1353  }
1354  TEST(FormatParse, RoundTripDistantFuture) {
1355    const time_zone utc = utc_time_zone();
1356    const time_point<absl::time_internal::cctz::seconds> in =
1357        time_point<absl::time_internal::cctz::seconds>::max();
1358    const std::string s =
1359        absl::time_internal::cctz::format(RFC3339_full, in, utc);
1360    time_point<absl::time_internal::cctz::seconds> out;
1361    EXPECT_TRUE(parse(RFC3339_full, s, utc, &out)) << s;
1362    EXPECT_EQ(in, out);
1363  }
1364  TEST(FormatParse, RoundTripDistantPast) {
1365    const time_zone utc = utc_time_zone();
1366    const time_point<absl::time_internal::cctz::seconds> in =
1367        time_point<absl::time_internal::cctz::seconds>::min();
1368    const std::string s =
1369        absl::time_internal::cctz::format(RFC3339_full, in, utc);
1370    time_point<absl::time_internal::cctz::seconds> out;
1371    EXPECT_TRUE(parse(RFC3339_full, s, utc, &out)) << s;
1372    EXPECT_EQ(in, out);
1373  }
1374  }  
1375  }  
1376  ABSL_NAMESPACE_END
1377  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WindowsDlg.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_format_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>306  							const TCHAR *fullName = buf->getFullPathName();
307  							const TCHAR *fileName = buf->getFileName();
308  							int len = lstrlen(fullName)-lstrlen(fileName);
</pre></code></div>
                <div class="column column_space"><pre><code>169    const time_zone tz = utc_time_zone();
170    auto tp = chrono::system_clock::from_time_t(0);
171    TestFormatSpecifier(tp, tz, "%a", "Thu");
172    TestFormatSpecifier(tp, tz, "%A", "Thursday");
173    TestFormatSpecifier(tp, tz, "%b", "Jan");
174    TestFormatSpecifier(tp, tz, "%B", "January");
175    const std::string s =
176        absl::time_internal::cctz::format("%c", tp, utc_time_zone());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    