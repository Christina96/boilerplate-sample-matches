
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.221932114882506%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-skygrid.cpp</h3>
            <pre><code>1  #include "skygrid.h"
2  void TSkyGridBinDoc::SaveBinDocV(
3   const TStr& InXmlFPath, const TStr& OutBinFNm, const int& MxDocs){
4    printf("Processing SkyGrid-News-Xml files from '%s'...\n", InXmlFPath.CStr());
5    TFOut SOut(OutBinFNm);
6    TFFile FFile(InXmlFPath, true); TStr FNm;
7    int Docs=0; int DateDocs=0; uint64 PrevTm=0;
8    while (FFile.Next(FNm)){
9      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
10      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
11      PXmlTok ContentTok=XmlDoc->GetTagTok("item|content");
12      TStr SwIdStr=ContentTok->GetTagTok("swid")->GetArgVal("value");
13      TStr UrlStr=ContentTok->GetTagTok("url")->GetTokStr(false);
14      TStr TitleStr=ContentTok->GetTagTok("title")->GetTokStr(false);
15      TStr FetchedValStr=ContentTok->GetTagTok("fetched")->GetArgVal("value");
16      TXmlTokV EntityTokV; ContentTok->GetTagTokV("annotations|entity", EntityTokV);
17      TStr BodyStr=ContentTok->GetTagTok("body")->GetTokStr(false);
18      TStr DateStr=SwIdStr.GetSubStr(0, 7);
19      TStr YearStr=DateStr.GetSubStr(0, 3);
20      TStr MonthStr=DateStr.GetSubStr(4, 5);
21      TStr DayStr=DateStr.GetSubStr(6, 7);
22      TTm DateTm(YearStr.GetInt(), MonthStr.GetInt(), DayStr.GetInt());
23      uint64 Tm=TTm::GetMSecsFromTm(DateTm);
24      TStrIntH EntNmToFqH;
25      for (int EntityTokN=0; EntityTokN<EntityTokV.Len(); EntityTokN++){
26        PXmlTok EntityTok=EntityTokV[EntityTokN];
27        if (!EntityTok->IsTag("entity")){continue;}
28        TStr CanonicalNm=EntityTok->GetArgVal("canonical", "");
29        TStr TextStr=EntityTok->GetArgVal("text", "");
30        TStr TypeNm=EntityTok->GetArgVal("type", "");
31        TStr EntNm=CanonicalNm.Empty() ? TextStr : CanonicalNm;
32        EntNmToFqH.AddDat(EntNm)++;
33      }
34      TIntStrPrV FqEntNmPrV; EntNmToFqH.GetDatKeyPrV(FqEntNmPrV); FqEntNmPrV.Sort(false);
35      TChA HeadlineChA=BodyStr.GetSubStr(0, 250);
36      while ((HeadlineChA.Len()>0)&&(HeadlineChA.LastCh()!=' ')){
37        HeadlineChA.Trunc(HeadlineChA.Len()-1);}
38      HeadlineChA+="...";
39      TSkyGridBinDoc Doc(SwIdStr, Tm, TitleStr, HeadlineChA, FqEntNmPrV);
40      Doc.Save(SOut);
41      if (PrevTm!=Tm){
42        if (PrevTm!=0){printf("\n");}
43        PrevTm=Tm; DateDocs=0;
44      }
45      Docs++; DateDocs++;
46      printf("  %s [Day:%d / All:%d]\r", DateStr.CStr(), DateDocs, Docs);
47    }
48    printf("\nDone.\n");
49  }
50  void TSkyGridBinDoc::LoadBinDocV(const TStr& InBinFNm){
51    printf("Processing SkyGrid News-Binary file '%s'...\n", InBinFNm.CStr());
52    TFIn SIn(InBinFNm); int Docs=0;
53    while (!SIn.Eof()){
54      TSkyGridBinDoc Doc(SIn);
55      Docs++; printf("%d\r", Docs);
56    }
57    printf("\nDone.\n");
58  }
59  void TSkyGridEnt::GetDocIdV(const TSkyGridBs* SkyGridBs,
60   const uint64& MnTm, const uint64& MxTm, TIntV& DocIdV) const {
61    DocIdV.Gen(GetDocIds(), 0);
62    for (int DocN=0; DocN<GetDocIds(); DocN++){
63      int DocId=GetDocId(DocN);
64      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
65      uint64 DocTm=Doc->GetTm();
66      if (((MnTm==0)||(MnTm<=DocTm))&&((MxTm==0)||(DocTm<MxTm))){
67        DocIdV.Add(DocId);
68      }
69    }
70  }
71  void TSkyGridEnt::GetDocsPerDateV(
72   const TSkyGridBs* SkyGridBs, TStrIntPrV& DateStrDocsPrV, int& Docs) const {
73    TStrIntH DateStrToDocsH; Docs=0;
74    for (int DocN=0; DocN<GetDocIds(); DocN++){
75      int DocId=GetDocId(DocN);
76      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
77      uint64 DocTm=Doc->GetTm();
78      TStr DocDateStr=TTm::GetTmFromMSecs(DocTm).GetWebLogDateStr();
79      DateStrToDocsH.AddDat(DocDateStr)++; Docs++;
80    }
81    DateStrToDocsH.GetKeyDatPrV(DateStrDocsPrV);
82    DateStrDocsPrV.Sort();
83  }
84  void TSkyGridEnt::GetDocCentroid(const TSkyGridBs* SkyGridBs,
85   const int& TopWords, const double& TopWordsWgtSumPrc,
86   TStrFltPrV& WordStrWgtPrV) const {
87    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
88    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
89    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NULL);
90    for (int DocN=0; DocN<GetDocIds(); DocN++){
91      int DocId=GetDocId(DocN);
92      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
93      TStr DocStr=Doc->GetHeadlineStr();
94      BowDocBs->AddHtmlDoc(TInt::GetStr(DocId), TStrV(), DocStr);
95    }
96    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
97    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
98    PBowSim BowSim=TBowSim::New(bstCos); 
99    TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
100    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, AllDIdV);
101    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, WordStrWgtPrV);
102  }
103  void TSkyGridEnt::GetDocCentroid(const TSkyGridBs* SkyGridBs,
104   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
105   const uint64& MnTm, const int& TopWords, const double& TopWordsWgtSumPrc,
106   int& Docs, TStrFltPrV& WordStrWgtPrV) const {
107    TIntV DocIdV; GetDocIdV(SkyGridBs, MnTm, 0, DocIdV);
108    TIntV BowDIdV(DocIdV.Len(), 0);
109    for (int DocN=0; DocN<DocIdV.Len(); DocN++){
110      int DocId=DocIdV[DocN];
111      TStr BowDocNm=TInt::GetStr(DocId);
112      int BowDId=BowDocBs->GetDId(BowDocNm);
113      BowDIdV.Add(BowDId);
114    }
115    PBowSim BowSim=TBowSim::New(bstCos); 
116    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, BowDIdV);
117    Docs=DocIdV.Len();
118    ConceptSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtSumPrc, WordStrWgtPrV);
119  }
120  void TSkyGridEnt::GetEntClustV(const TSkyGridBs* SkyGridBs,
121   const uint64& MnTm, const int& MnDocs, const int& MxDocs, const int& Clusts,
122   TVec<TStrFltPrV>& EntNmWgtPrVV) const {
123    EntNmWgtPrVV.Clr();
124    PBowDocBs BowDocBs=TBowDocBs::New();
125    TIntV DocIdV; GetDocIdV(SkyGridBs, MnTm, 0, DocIdV);
126    DocIdV.Reverse(); DocIdV.Shuffle(TRnd(1)); DocIdV.Trunc(MxDocs);
127    if (DocIdV.Len()<MnDocs){return;}
128    for (int DocN=0; DocN<DocIdV.Len(); DocN++){
129      int DocId=DocIdV[DocN];
130      PSkyGridDoc Doc=SkyGridBs->GetDoc(DocId);
131      TIntFltPrV WIdWgtPrV;
132      for (int EntN=0; EntN<Doc->GetEnts(); EntN++){
133        int EntId; int EntFq; Doc->GetEntNmFq(EntN, EntId, EntFq);
134        TStr EntNm=SkyGridBs->GetEntNm(EntId);
135        int EntWId=BowDocBs->AddWordStr(EntNm);
136        WIdWgtPrV.Add(TIntFltPr(EntWId, EntFq));
137      }
138      int DId=BowDocBs->AddDoc(TInt::GetStr(DocId), TStrV(), WIdWgtPrV);
139      TStr DocDescStr=Doc->GetTitleStr();
140      BowDocBs->PutDocDescStr(DId, DocDescStr);
141    }
142    PBowSim BowSim=TBowSim::New(bstCos); 
143    TBowWordWgtType WordWgtType=bwwtNrmTFIDF; 
144    PBowDocPart BowDocPart=TBowClust::GetKMeansPart(
145     TNotify::StdNotify, 
146     BowDocBs, 
147     BowSim, 
148     TRnd(1), 
149     Clusts, 
150     1, 
151     1, 
152     1, 
153     WordWgtType, 
154     0, 
155     0); 
156    EntNmWgtPrVV.Clr();
157    for (int ClustN=0; ClustN<BowDocPart->GetClusts(); ClustN++){
158      PBowDocPartClust Clust=BowDocPart->GetClust(ClustN);
159      TStrFltPrV WordStrWgtPrV;
160      Clust->GetTopWordStrWgtPrV(BowDocBs, 25, 0.5, WordStrWgtPrV);
161      EntNmWgtPrVV.Add(WordStrWgtPrV);
162    }
163  }
164  void TSkyGridEnt::GetSorted_LinkWgtDstEntIdPrV(
165   const uint64& MnTm, const double& TopWgtSumPrc, TIntPrV& LinkWgtDstEntIdPrV) const {
166    double AllLinkWgtSum=0;
167    TIntIntH DstEntIdLinkWgtH;
168    int LinkEnts=GetLinkEnts();
169    for (int LinkEntN=0; LinkEntN<LinkEnts; LinkEntN++){
170      int DstEntId=GetLinkEntId(LinkEntN);
171      int EntLinks=GetEntLinks(LinkEntN);
172      int EntLinkWgtSum=0;
173      for (int EntLinkN=0; EntLinkN<EntLinks; EntLinkN++){
174        const TSkyGridEntLinkCtx& EntLinkCtx=GetEntLinkCtx(LinkEntN, EntLinkN);
175        if (EntLinkCtx.Tm>=MnTm){
176          EntLinkWgtSum+=EntLinkCtx.LinkWgt;}
177      }
178      DstEntIdLinkWgtH.AddDat(DstEntId, EntLinkWgtSum);
179      AllLinkWgtSum+=EntLinkWgtSum;
180    }
181    LinkWgtDstEntIdPrV.Clr(); DstEntIdLinkWgtH.GetDatKeyPrV(LinkWgtDstEntIdPrV);
182    LinkWgtDstEntIdPrV.Sort(false);
183    if ((TopWgtSumPrc>0.0)&&(LinkWgtDstEntIdPrV.Len()>0)){
184      int TopLinkWgt=LinkWgtDstEntIdPrV[0].Val1;
185      if (TopLinkWgt>(3*AllLinkWgtSum)/LinkWgtDstEntIdPrV.Len()){
186        double CutWgtSum=AllLinkWgtSum*(1-TopWgtSumPrc);
187        int LastValN=LinkWgtDstEntIdPrV.Len()-1;
188        while ((LastValN>0)&&(CutWgtSum>0)){
189          CutWgtSum-=LinkWgtDstEntIdPrV[LastValN].Val1;
190          LastValN--;
191        }
192        LinkWgtDstEntIdPrV.Trunc(LastValN+1);
193      }
194    }
195  }
196  void TSkyGridBs::GetSorted_DocsEntIdPrV(TIntPrV& DocsEntIdPrV){
197    TIntIntH EntIdToDocsH;
198    for (int EntId=0; EntId<GetEnts(); EntId++){
199      int Docs=GetEnt(EntId).GetDocIds();
200      EntIdToDocsH.AddDat(EntId, Docs);
201    }
<span onclick='openModal()' class='match'>202    DocsEntIdPrV.Clr(); EntIdToDocsH.GetDatKeyPrV(DocsEntIdPrV);
203    DocsEntIdPrV.Sort(false);
204  }
205  int TSkyGridBs::AddDoc(
206   const TStr& SwIdStr, const uint64& Tm,
207   const TStr& TitleStr, const TStr& HeadlineStr,
</span>208   const TIntStrPrV FqEntNmPrV){
209    TIntPrV EntIdFqPrV(FqEntNmPrV.Len(), 0);
210    for (int EntN=0; EntN<FqEntNmPrV.Len(); EntN++){
211      TStr EntNm=FqEntNmPrV[EntN].Val2;
212      int EntFq=FqEntNmPrV[EntN].Val1;
213      if (EntFq>=GetMnEntFqPerDoc()){
214        int EntId=AddEntNm(EntNm);
215        EntIdFqPrV.Add(TIntPr(EntId, EntFq));
216      }
217    }
218    if (EntIdFqPrV.Len()<GetMnEntsPerDoc()){
219      return -1;}
220    PSkyGridDoc Doc=
221     TSkyGridDoc::New(SwIdStr, Tm, TitleStr, HeadlineStr, EntIdFqPrV);
222    int DocId=GetNewDocId();
223    IdToDocH.AddDat(DocId, Doc);
224    for (int EntN=0; EntN<EntIdFqPrV.Len(); EntN++){
225      int EntId=EntIdFqPrV[EntN].Val1;
226      TSkyGridEnt& Ent=GetEnt(EntId);
227      Ent.PushDocId(DocId);
228    }
229    int EntLinkWgtSum=0;
230    for (int EntN1=0; EntN1<EntIdFqPrV.Len(); EntN1++){
231      int EntId1=EntIdFqPrV[EntN1].Val1;
232      TSkyGridEnt& Ent1=GetEnt(EntId1);
233      int EntWgt1=EntIdFqPrV[EntN1].Val2;
234      for (int EntN2=0; EntN2<EntIdFqPrV.Len(); EntN2++){
235        if (EntN1==EntN2){continue;}
236        int EntId2=EntIdFqPrV[EntN2].Val1;
237        int EntWgt2=EntIdFqPrV[EntN2].Val2;
238        int EntLinkWgt=EntWgt1*EntWgt2;
239        EntLinkWgtSum+=EntLinkWgt;
240        TSkyGridEntLinkCtx LinkCtx(EntLinkWgt, DocId, Tm);
241        Ent1.AddLink(EntId2, LinkCtx);
242      }
243    }
244    return DocId;
245  }
246  PBowDocBs TSkyGridBs::GetBowDocBs(
247   const int& MxNGramLen, const int& MnNGramFq) const {
248    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
249    PStemmer Stemmer=TStemmer::GetStemmer(stmtPorter);
250    PNGramBs NGramBs;
251    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
252      TStrV HtmlStrV;
253      TSkyGridIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV);
254      for (int DocN=0; DocN<IdDocPrV.Len(); DocN++){
255        PSkyGridDoc Doc=IdDocPrV[DocN].Val2;
256        TStr DocStr=Doc->GetHeadlineStr();
257        HtmlStrV.Add(DocStr);
258      }
259      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
260       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
261    }
262    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
263    TSkyGridIdDocPrV IdDocPrV; GetIdDocPrV(IdDocPrV);
264    for (int DocN=0; DocN<IdDocPrV.Len(); DocN++){
265      int DocId=IdDocPrV[DocN].Val1;
266      PSkyGridDoc Doc=IdDocPrV[DocN].Val2;
267      TStr DocStr=Doc->GetHeadlineStr();
268      BowDocBs->AddHtmlDoc(TInt::GetStr(DocId), TStrV(), DocStr);
269    }
270    return BowDocBs;
271  }
272  PBowDocWgtBs TSkyGridBs::GetBowDocWgtBs(const PBowDocBs& BowDocBs) const {
273    TBowWordWgtType WordWgtType=bwwtNrmTFIDF;
274    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0);
275    return BowDocWgtBs;
276  }
277  void TSkyGridBs::GetWordStrWgtPrVDiff(
278   const TStrFltPrV& OldWordStrWgtPrV, const TStrFltPrV& NewWordStrWgtPrV,
279   TStrFltPrV& NegDiffWordStrWgtPrV, TStrFltPrV& PosDiffWordStrWgtPrV){
280    TStrFltH WordStrToWgtH;
281    for (int WordN=0; WordN<NewWordStrWgtPrV.Len(); WordN++){
282      TStr WStr=NewWordStrWgtPrV[WordN].Val1;
283      double WWgt=NewWordStrWgtPrV[WordN].Val2;
284      WordStrToWgtH.AddDat(WStr, WWgt);
285    }
286    for (int WordN=0; WordN<OldWordStrWgtPrV.Len(); WordN++){
287      TStr WStr=OldWordStrWgtPrV[WordN].Val1;
288      double WWgt=OldWordStrWgtPrV[WordN].Val2;
289      double CurWWgt=WordStrToWgtH.AddDat(WStr);
290      WordStrToWgtH.AddDat(WStr, CurWWgt-WWgt);
291    }
292    TFltStrPrV DiffWordWgtStrPrV; WordStrToWgtH.GetDatKeyPrV(DiffWordWgtStrPrV);
293    DiffWordWgtStrPrV.Sort(true);
294    NegDiffWordStrWgtPrV.Gen(DiffWordWgtStrPrV.Len(), 0);
295    for (int WordN=0; WordN<DiffWordWgtStrPrV.Len(); WordN++){
296      TStr WStr=DiffWordWgtStrPrV[WordN].Val2;
297      double WWgt=DiffWordWgtStrPrV[WordN].Val1;
298      if (WWgt!=0){NegDiffWordStrWgtPrV.Add(TStrFltPr(WStr, WWgt));}
299    }
300    DiffWordWgtStrPrV.Sort(false);
301    PosDiffWordStrWgtPrV.Gen(DiffWordWgtStrPrV.Len(), 0);
302    for (int WordN=0; WordN<DiffWordWgtStrPrV.Len(); WordN++){
303      TStr WStr=DiffWordWgtStrPrV[WordN].Val2;
304      double WWgt=DiffWordWgtStrPrV[WordN].Val1;
305      if (WWgt!=0){PosDiffWordStrWgtPrV.Add(TStrFltPr(WStr, WWgt));}
306    }
307  }
308  void TSkyGridBs::GetWordStrWgtPrVChA(
309   const TStrFltPrV& WordStrWgtPrV, TChA& WordStrWgtPrVChA){
310    WordStrWgtPrVChA.Clr();
311    for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
312      TStr WStr=WordStrWgtPrV[WordN].Val1;
313      double WWgt=WordStrWgtPrV[WordN].Val2;
314      if (WordN>0){WordStrWgtPrVChA+=' ';}
315      WordStrWgtPrVChA+=TStr::Fmt("['%s':%.3f]", WStr.CStr(), WWgt);
316    }
317  }
318  void TSkyGridBs::GetLinkWgtDstEntIdPrVDiff(
319   const TIntPrV& OldLinkWgtDstEntIdPrV, const TIntPrV& NewLinkWgtDstEntIdPrV,
320   TIntPrV& NegDiffLinkWgtDstEntIdPrV, TIntPrV& PosDiffLinkWgtDstEntIdPrV){
321    TIntIntH DstEntIdToLinkWgtH;
322    for (int WordN=0; WordN<NewLinkWgtDstEntIdPrV.Len(); WordN++){
323      int LinkWgt=NewLinkWgtDstEntIdPrV[WordN].Val1;
324      int DstEntId=NewLinkWgtDstEntIdPrV[WordN].Val2;
325      DstEntIdToLinkWgtH.AddDat(DstEntId, LinkWgt);
326    }
327    for (int WordN=0; WordN<OldLinkWgtDstEntIdPrV.Len(); WordN++){
328      int LinkWgt=OldLinkWgtDstEntIdPrV[WordN].Val1;
329      int DstEntId=OldLinkWgtDstEntIdPrV[WordN].Val2;
330      int CurLinkWgt=DstEntIdToLinkWgtH.AddDat(DstEntId);
331      DstEntIdToLinkWgtH.AddDat(DstEntId, CurLinkWgt-LinkWgt);
332    }
333    TIntPrV _DiffLinkWgtDstEntIdPrV;
334    DstEntIdToLinkWgtH.GetDatKeyPrV(_DiffLinkWgtDstEntIdPrV);
335    TIntPrV DiffLinkWgtDstEntIdPrV(_DiffLinkWgtDstEntIdPrV.Len(), 0);
336    for (int EntN=0; EntN<_DiffLinkWgtDstEntIdPrV.Len(); EntN++){
337      int LinkWgt=_DiffLinkWgtDstEntIdPrV[EntN].Val1;
338      if (LinkWgt!=0){
339        DiffLinkWgtDstEntIdPrV.Add(_DiffLinkWgtDstEntIdPrV[EntN]);}
340    }
341    DiffLinkWgtDstEntIdPrV.Sort(true);
342    NegDiffLinkWgtDstEntIdPrV=DiffLinkWgtDstEntIdPrV;
343    DiffLinkWgtDstEntIdPrV.Sort(false);
344    PosDiffLinkWgtDstEntIdPrV=DiffLinkWgtDstEntIdPrV;
345  }
346  void TSkyGridBs::GetLinkWgtDstEntIdPrVChA(
347   const TIntPrV& LinkWgtDstEntIdPrV, TChA& LinkWgtDstEntIdPrVChA){
348    LinkWgtDstEntIdPrVChA.Clr();
349    for (int DstEntN=0; DstEntN<LinkWgtDstEntIdPrV.Len(); DstEntN++){
350      int DstEntId=LinkWgtDstEntIdPrV[DstEntN].Val2;
351      TStr DstEntNm=GetEntNm(DstEntId);
352      int LinkWgt=LinkWgtDstEntIdPrV[DstEntN].Val1;
353      if (DstEntN>0){LinkWgtDstEntIdPrVChA+=' ';}
354      LinkWgtDstEntIdPrVChA+=TStr::Fmt("['%s':%d]", DstEntNm.CStr(), LinkWgt);
355    }
356  }
357  void TSkyGridBs::SaveTxt(const TStr& FNm, const uint64& CurTm){
358    TStr CurTmStr=TTm::GetTmFromMSecs(CurTm).GetWebLogDateTimeStr();
359    uint64 CurDateTm=TTm::GetMSecsFromTm(TTm::GetTmFromWebLogDateTimeStr(TTm::GetTmFromMSecs(CurTm).GetWebLogDateStr()));
360    TStr CurDateTmStr=TTm::GetTmFromMSecs(CurDateTm).GetWebLogDateTimeStr();
361    TUInt64V MnTmV;
362    MnTmV.Add(CurDateTm-0*TTmInfo::GetDayMSecs());
363    MnTmV.Add(CurDateTm-1*TTmInfo::GetDayMSecs());
364    MnTmV.Add(CurDateTm-2*TTmInfo::GetDayMSecs());
365    MnTmV.Add(CurDateTm-4*TTmInfo::GetDayMSecs());
366    MnTmV.Add(CurDateTm-8*TTmInfo::GetDayMSecs());
367    MnTmV.Add(CurDateTm-16*TTmInfo::GetDayMSecs());
368    MnTmV.Add(CurDateTm-32*TTmInfo::GetDayMSecs());
369    PBowDocBs BowDocBs=GetBowDocBs();
370    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs(BowDocBs);
371    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
372    TIntPrV DocsEntIdPrV; GetSorted_DocsEntIdPrV(DocsEntIdPrV);
373    for (int EntN=0; EntN<DocsEntIdPrV.Len(); EntN++){
374      int EntId=DocsEntIdPrV[EntN].Val2;
375      TStr EntNm=GetEntNm(EntId);
376      int EntDocs=DocsEntIdPrV[EntN].Val1;
377      TSkyGridEnt& Ent=GetEnt(EntId);
378      int LinkEnts=Ent.GetLinkEnts();
379      fprintf(fOut, "'%s' [%d docs] [%d ents]\n", EntNm.CStr(), EntDocs, LinkEnts);
380      {TStrIntPrV DateStrDocsPrV; int _EntDocs;
381      Ent.GetDocsPerDateV(this, DateStrDocsPrV, _EntDocs);
382      fprintf(fOut, "   Docs per Date (%d docs):", _EntDocs);
383      for (int DateN=0; DateN<DateStrDocsPrV.Len(); DateN++){
384        TStr DateStr=DateStrDocsPrV[DateN].Val1;
385        int Docs=DateStrDocsPrV[DateN].Val2;
386        fprintf(fOut, " [%s:%d]", DateStr.CStr(), Docs);
387      }
388      fprintf(fOut, "\n");}
389      fprintf(fOut, "   [Now: %s]\n", CurTmStr.CStr());
390      TIntPrV PrevLinkWgtDstEntIdPrV;
391      TStrFltPrV PrevWordStrWgtPrV;
392      for (int MnTmN=0; MnTmN<MnTmV.Len(); MnTmN++){
393        uint64 MnTm=MnTmV[MnTmN];
394        double PastDays=(CurDateTm-MnTm)/double(TTmInfo::GetDayMSecs());
395        TStr MnTmStr=TTm::GetTmFromMSecs(MnTm).GetWebLogDateTimeStr();
396        TIntPrV LinkWgtDstEntIdPrV;
397        Ent.GetSorted_LinkWgtDstEntIdPrV(MnTm, 0.9, LinkWgtDstEntIdPrV);
398        if (MnTmN>0){
399          TIntPrV NegDiffLinkWgtDstEntIdPrV; TIntPrV PosDiffLinkWgtDstEntIdPrV;
400          GetLinkWgtDstEntIdPrVDiff(LinkWgtDstEntIdPrV, PrevLinkWgtDstEntIdPrV,
401           NegDiffLinkWgtDstEntIdPrV, PosDiffLinkWgtDstEntIdPrV);
402          TChA PosDiffLinkWgtDstEntIdPrVChA;
403          GetLinkWgtDstEntIdPrVChA(PosDiffLinkWgtDstEntIdPrV, PosDiffLinkWgtDstEntIdPrVChA);
404          fprintf(fOut, "         Pos-Diff: %s\n", PosDiffLinkWgtDstEntIdPrVChA.CStr());
405          TChA NegDiffLinkWgtDstEntIdPrVChA;
406          GetLinkWgtDstEntIdPrVChA(NegDiffLinkWgtDstEntIdPrV, NegDiffLinkWgtDstEntIdPrVChA);
407          fprintf(fOut, "         Neg-Diff: %s\n", NegDiffLinkWgtDstEntIdPrVChA.CStr());
408        }
409        PrevLinkWgtDstEntIdPrV=LinkWgtDstEntIdPrV;
410        int TopLinkEnts=LinkWgtDstEntIdPrV.Len();
411        TChA LinkWgtDstEntIdPrVChA;
412        GetLinkWgtDstEntIdPrVChA(LinkWgtDstEntIdPrV, LinkWgtDstEntIdPrVChA);
413        fprintf(fOut, "      Entities (%d ents): %s\n",
414         TopLinkEnts, LinkWgtDstEntIdPrVChA.CStr());
415        int CtrDocs; TStrFltPrV WordStrWgtPrV;
416        Ent.GetDocCentroid(this, BowDocBs, BowDocWgtBs, MnTm, 150, 0.9, CtrDocs, WordStrWgtPrV);
417        if (MnTmN>0){
418          TStrFltPrV NegDiffWordStrWgtPrV; TStrFltPrV PosDiffWordStrWgtPrV;
419          GetWordStrWgtPrVDiff(WordStrWgtPrV, PrevWordStrWgtPrV,
420           NegDiffWordStrWgtPrV, PosDiffWordStrWgtPrV);
421          TChA PosDiffWordStrWgtPrVChA; GetWordStrWgtPrVChA(PosDiffWordStrWgtPrV, PosDiffWordStrWgtPrVChA);
422          fprintf(fOut, "         Pos-Diff: %s\n", PosDiffWordStrWgtPrVChA.CStr());
423          TChA NegDiffWordStrWgtPrVChA; GetWordStrWgtPrVChA(NegDiffWordStrWgtPrV, NegDiffWordStrWgtPrVChA);
424          fprintf(fOut, "         Neg-Diff: %s\n", NegDiffWordStrWgtPrVChA.CStr());
425        }
426        PrevWordStrWgtPrV=WordStrWgtPrV;
427        TChA WordStrWgtPrVChA; GetWordStrWgtPrVChA(WordStrWgtPrV, WordStrWgtPrVChA);
428        fprintf(fOut, "      Centroid (%d docs, %d words): %s\n",
429         CtrDocs, WordStrWgtPrV.Len(), WordStrWgtPrVChA.CStr());
430        fprintf(fOut, "   [-%.1f days: %s]\n", PastDays, MnTmStr.CStr());
431      }
432      fprintf(fOut, "\n");
433    }
434  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_invocable_test.cc</h3>
            <pre><code>1  #include "absl/functional/any_invocable.h"
2  #include <cstddef>
3  #include <initializer_list>
4  #include <memory>
5  #include <numeric>
6  #include <type_traits>
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/meta/type_traits.h"
10  #include "absl/utility/utility.h"
11  static_assert(absl::internal_any_invocable::kStorageSize >= sizeof(void*),
12                "These tests assume that the small object storage is at least "
13                "the size of a pointer.");
14  namespace {
15  #if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
16  #define ABSL_INTERNAL_NOEXCEPT_SPEC(noex) noexcept(noex)
17  #else
18  #define ABSL_INTERNAL_NOEXCEPT_SPEC(noex)
19  #endif
20  struct _ {};
21  template <class T>
22  struct Wrapper {
23    template <class U,
24              class = absl::enable_if_t<std::is_convertible<U, T>::value>>
25    Wrapper(U&&);  
26  };
27  static_assert(std::is_constructible<Wrapper<absl::AnyInvocable<void()>>,
28                                      Wrapper<absl::AnyInvocable<void()>>>::value,
29                "");
30  template <class Qualifiers, class This>
31  struct QualifiersForThisImpl {
32    static_assert(std::is_object<This>::value, "");
33    using type =
34        absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&;
35  };
36  template <class Qualifiers, class This>
37  struct QualifiersForThisImpl<Qualifiers&, This>
38      : QualifiersForThisImpl<Qualifiers, This> {};
39  template <class Qualifiers, class This>
40  struct QualifiersForThisImpl<Qualifiers&&, This> {
41    static_assert(std::is_object<This>::value, "");
42    using type =
43        absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&&;
44  };
45  template <class Qualifiers, class This>
46  using QualifiersForThis =
47      typename QualifiersForThisImpl<Qualifiers, This>::type;
48  template <class T, class Fun>
49  struct GiveQualifiersToFunImpl;
50  template <class T, class R, class... P>
51  struct GiveQualifiersToFunImpl<T, R(P...)> {
52    using type =
53        absl::conditional_t<std::is_const<T>::value, R(P...) const, R(P...)>;
54  };
55  template <class T, class R, class... P>
56  struct GiveQualifiersToFunImpl<T&, R(P...)> {
57    using type =
58        absl::conditional_t<std::is_const<T>::value, R(P...) const&, R(P...)&>;
59  };
60  template <class T, class R, class... P>
61  struct GiveQualifiersToFunImpl<T&&, R(P...)> {
62    using type =
63        absl::conditional_t<std::is_const<T>::value, R(P...) const&&, R(P...) &&>;
64  };
65  #if defined(__cpp_noexcept_function_type)
66  template <class T, class R, class... P>
67  struct GiveQualifiersToFunImpl<T, R(P...) noexcept> {
68    using type = absl::conditional_t<std::is_const<T>::value,
69                                     R(P...) const noexcept, R(P...) noexcept>;
70  };
71  template <class T, class R, class... P>
72  struct GiveQualifiersToFunImpl<T&, R(P...) noexcept> {
73    using type =
74        absl::conditional_t<std::is_const<T>::value, R(P...) const & noexcept,
75                            R(P...) & noexcept>;
76  };
77  template <class T, class R, class... P>
78  struct GiveQualifiersToFunImpl<T&&, R(P...) noexcept> {
79    using type =
80        absl::conditional_t<std::is_const<T>::value, R(P...) const && noexcept,
81                            R(P...) && noexcept>;
82  };
83  #endif  
84  template <class T, class Fun>
85  using GiveQualifiersToFun = typename GiveQualifiersToFunImpl<T, Fun>::type;
86  enum class ObjSize { small, large };
87  template <ObjSize Size>
88  struct TypeErasedPadding;
89  template <>
90  struct TypeErasedPadding<ObjSize::small> {};
91  template <>
92  struct TypeErasedPadding<ObjSize::large> {
93    char dummy_data[absl::internal_any_invocable::kStorageSize + 1] = {};
94  };
95  struct Int {
96    Int(int v) noexcept : value(v) {}  
97  #ifndef _MSC_VER
98    Int(Int&&) noexcept {
99      std::abort();
100    }
101  #else
102    Int(Int&& v) noexcept = default;
103  #endif
104    operator int() && noexcept { return value; }  
105    int MemberFunctionAdd(int const& b, int c) noexcept {  
106      return value + b + c;
107    }
108    int value;
109  };
110  enum class Movable { no, yes, nothrow, trivial };
111  enum class NothrowCall { no, yes };
112  enum class Destructible { nothrow, trivial };
113  enum class ObjAlign : std::size_t {
114    normal = absl::internal_any_invocable::kAlignment,
115    large = absl::internal_any_invocable::kAlignment * 2,
116  };
117  template <Movable Movability, Destructible Destructibility, class Qual,
118            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
119  struct add;
120  #define ABSL_INTERNALS_ADD(qual)                                              \
121    template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
122    struct alignas(static_cast<std::size_t>(Alignment))                         \
123        add<Movable::trivial, Destructible::trivial, _ qual, CallExceptionSpec, \
124            Size, Alignment> : TypeErasedPadding<Size> {                        \
125      explicit add(int state_init) : state(state_init) {}                       \
126      explicit add(std::initializer_list<int> state_init, int tail)             \
127          : state(std::accumulate(std::begin(state_init), std::end(state_init), \
128                                  0) +                                          \
129                  tail) {}                                                      \
130      add(add&& other) = default; &bsol;*NOLINT*/                                    \
131      Int operator()(int a, int b, int c) qual                                  \
132          ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
133        return state + a + b + c;                                               \
134      }                                                                         \
135      int state;                                                                \
136    };                                                                          \
137                                                                                \
138    template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
139    struct alignas(static_cast<std::size_t>(Alignment))                         \
140        add<Movable::trivial, Destructible::nothrow, _ qual, CallExceptionSpec, \
141            Size, Alignment> : TypeErasedPadding<Size> {                        \
142      explicit add(int state_init) : state(state_init) {}                       \
143      explicit add(std::initializer_list<int> state_init, int tail)             \
144          : state(std::accumulate(std::begin(state_init), std::end(state_init), \
145                                  0) +                                          \
146                  tail) {}                                                      \
147      ~add() noexcept {}                                                        \
148      add(add&& other) = default; &bsol;*NOLINT*/                                    \
149      Int operator()(int a, int b, int c) qual                                  \
150          ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
151        return state + a + b + c;                                               \
152      }                                                                         \
153      int state;                                                                \
154    }
155  #define ABSL_INTERNALS_NOARG
156  ABSL_INTERNALS_ADD(ABSL_INTERNALS_NOARG);
157  #undef ABSL_INTERNALS_NOARG
158  ABSL_INTERNALS_ADD(const);
159  ABSL_INTERNALS_ADD(&);
160  ABSL_INTERNALS_ADD(const&);
161  ABSL_INTERNALS_ADD(&&);       
162  ABSL_INTERNALS_ADD(const&&);  
163  #undef ABSL_INTERNALS_ADD
164  template <Destructible Destructibility, class Qual,
165            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
166  struct add<Movable::no, Destructibility, Qual, CallExceptionSpec, Size,
167             Alignment> : private add<Movable::trivial, Destructibility, Qual,
168                                      CallExceptionSpec, Size, Alignment> {
169    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
170                     Size, Alignment>;
171    explicit add(int state_init) : Base(state_init) {}
172    explicit add(std::initializer_list<int> state_init, int tail)
173        : Base(state_init, tail) {}
174    add(add&&) = delete;
175    using Base::operator();
176    using Base::state;
177  };
178  template <Destructible Destructibility, class Qual,
179            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
180  struct add<Movable::yes, Destructibility, Qual, CallExceptionSpec, Size,
181             Alignment> : private add<Movable::trivial, Destructibility, Qual,
182                                      CallExceptionSpec, Size, Alignment> {
183    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
184                     Size, Alignment>;
185    explicit add(int state_init) : Base(state_init) {}
186    explicit add(std::initializer_list<int> state_init, int tail)
187        : Base(state_init, tail) {}
188    add(add&& other) noexcept(false) : Base(other.state) {}  
189    using Base::operator();
190    using Base::state;
191  };
192  template <Destructible Destructibility, class Qual,
193            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
194  struct add<Movable::nothrow, Destructibility, Qual, CallExceptionSpec, Size,
195             Alignment> : private add<Movable::trivial, Destructibility, Qual,
196                                      CallExceptionSpec, Size, Alignment> {
197    using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
198                     Size, Alignment>;
199    explicit add(int state_init) : Base(state_init) {}
200    explicit add(std::initializer_list<int> state_init, int tail)
201        : Base(state_init, tail) {}
202    add(add&& other) noexcept : Base(other.state) {}
203    using Base::operator();
204    using Base::state;
205  };
206  Int add_function(Int&& a, int b, int c) noexcept { return a.value + b + c; }
207  Int mult_function(Int&& a, int b, int c) noexcept { return a.value * b * c; }
208  Int square_function(Int const&& a) noexcept { return a.value * a.value; }
209  template <class Sig>
210  using AnyInvocable = absl::AnyInvocable<Sig>;
211  template <Movable Movability, Destructible Destructibility, class Qual,
212            NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
213  struct TestParams {
214    static constexpr Movable kMovability = Movability;
215    static constexpr Destructible kDestructibility = Destructibility;
216    using Qualifiers = Qual;
217    static constexpr NothrowCall kCallExceptionSpec = CallExceptionSpec;
218    static constexpr bool kIsNoexcept = kCallExceptionSpec == NothrowCall::yes;
219    static constexpr bool kIsRvalueQualified =
220        std::is_rvalue_reference<Qual>::value;
221    static constexpr ObjSize kSize = Size;
222    static constexpr ObjAlign kAlignment = Alignment;
223    using UnqualifiedUnaryFunType = int(Int const&&)
224        ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes);
225    using UnaryFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedUnaryFunType>;
226    using MemObjPtrType = int(Int::*);
227    using UnaryAnyInvType = AnyInvocable<UnaryFunType>;
228    using UnaryThisParamType = QualifiersForThis<Qualifiers, UnaryAnyInvType>;
229    template <class T>
230    static UnaryThisParamType ToUnaryThisParam(T&& fun) {
231      return static_cast<UnaryThisParamType>(fun);
232    }
233    using ResultType = Int;
234    using AnyInvocableFunTypeNotNoexcept = Int(Int, const int&, int);
235    using UnqualifiedFunType =
236        typename std::conditional<kIsNoexcept, Int(Int, const int&, int) noexcept,
237                                  Int(Int, const int&, int)>::type;
238    using FunType = GiveQualifiersToFun<Qualifiers, UnqualifiedFunType>;
239    using MemFunPtrType =
240        typename std::conditional<kIsNoexcept,
241                                  Int (Int::*)(const int&, int) noexcept,
242                                  Int (Int::*)(const int&, int)>::type;
243    using AnyInvType = AnyInvocable<FunType>;
244    using AddType = add<kMovability, kDestructibility, Qualifiers,
245                        kCallExceptionSpec, kSize, kAlignment>;
246    using ThisParamType = QualifiersForThis<Qualifiers, AnyInvType>;
247    template <class T>
248    static ThisParamType ToThisParam(T&& fun) {
249      return static_cast<ThisParamType>(fun);
250    }
251    using UnqualifiedVoidFunType =
252        typename std::conditional<kIsNoexcept,
253                                  void(Int, const int&, int) noexcept,
254                                  void(Int, const int&, int)>::type;
255    using VoidFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedVoidFunType>;
256    using VoidAnyInvType = AnyInvocable<VoidFunType>;
257    using VoidThisParamType = QualifiersForThis<Qualifiers, VoidAnyInvType>;
258    template <class T>
259    static VoidThisParamType ToVoidThisParam(T&& fun) {
260      return static_cast<VoidThisParamType>(fun);
261    }
262    using CompatibleAnyInvocableFunType =
263        absl::conditional_t<std::is_rvalue_reference<Qual>::value,
264                            GiveQualifiersToFun<const _&&, UnqualifiedFunType>,
265                            GiveQualifiersToFun<const _&, UnqualifiedFunType>>;
266    using CompatibleAnyInvType = AnyInvocable<CompatibleAnyInvocableFunType>;
267    using IncompatibleInvocable =
268        absl::conditional_t<std::is_rvalue_reference<Qual>::value,
269                            GiveQualifiersToFun<_&, UnqualifiedFunType>(_::*),
270                            GiveQualifiersToFun<_&&, UnqualifiedFunType>(_::*)>;
271  };
272  template <class MemberPtrType>
273  struct MemberTypeOfImpl;
274  template <class Class, class T>
275  struct MemberTypeOfImpl<T(Class::*)> {
276    using type = T;
277  };
278  template <class MemberPtrType>
279  using MemberTypeOf = typename MemberTypeOfImpl<MemberPtrType>::type;
280  template <class T, class = void>
281  struct IsMemberSwappableImpl : std::false_type {
282    static constexpr bool kIsNothrow = false;
283  };
284  template <class T>
285  struct IsMemberSwappableImpl<
286      T, absl::void_t<decltype(std::declval<T&>().swap(std::declval<T&>()))>>
287      : std::true_type {
288    static constexpr bool kIsNothrow =
289        noexcept(std::declval<T&>().swap(std::declval<T&>()));
290  };
291  template <class T>
292  using IsMemberSwappable = IsMemberSwappableImpl<T>;
293  template <class T>
294  using IsNothrowMemberSwappable =
295      std::integral_constant<bool, IsMemberSwappableImpl<T>::kIsNothrow>;
296  template <class T>
297  class AnyInvTestBasic : public ::testing::Test {};
298  TYPED_TEST_SUITE_P(AnyInvTestBasic);
299  TYPED_TEST_P(AnyInvTestBasic, DefaultConstruction) {
300    using AnyInvType = typename TypeParam::AnyInvType;
301    AnyInvType fun;
302    EXPECT_FALSE(static_cast<bool>(fun));
303    EXPECT_TRUE(std::is_nothrow_default_constructible<AnyInvType>::value);
304  }
305  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullptr) {
306    using AnyInvType = typename TypeParam::AnyInvType;
307    AnyInvType fun = nullptr;
308    EXPECT_FALSE(static_cast<bool>(fun));
309    EXPECT_TRUE(
310        (std::is_nothrow_constructible<AnyInvType, std::nullptr_t>::value));
311  }
312  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullFunctionPtr) {
313    using AnyInvType = typename TypeParam::AnyInvType;
314    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
315    UnqualifiedFunType* const null_fun_ptr = nullptr;
316    AnyInvType fun = null_fun_ptr;
317    EXPECT_FALSE(static_cast<bool>(fun));
318  }
319  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberFunctionPtr) {
320    using AnyInvType = typename TypeParam::AnyInvType;
321    using MemFunPtrType = typename TypeParam::MemFunPtrType;
322    const MemFunPtrType null_mem_fun_ptr = nullptr;
323    AnyInvType fun = null_mem_fun_ptr;
324    EXPECT_FALSE(static_cast<bool>(fun));
325  }
326  TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberObjectPtr) {
327    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
328    using MemObjPtrType = typename TypeParam::MemObjPtrType;
329    const MemObjPtrType null_mem_obj_ptr = nullptr;
330    UnaryAnyInvType fun = null_mem_obj_ptr;
331    EXPECT_FALSE(static_cast<bool>(fun));
332  }
333  TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberFunctionPtr) {
334    using AnyInvType = typename TypeParam::AnyInvType;
335    AnyInvType fun = &Int::MemberFunctionAdd;
336    EXPECT_TRUE(static_cast<bool>(fun));
337    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
338  }
339  TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberObjectPtr) {
340    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
341    UnaryAnyInvType fun = &Int::value;
342    EXPECT_TRUE(static_cast<bool>(fun));
343    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
344  }
345  TYPED_TEST_P(AnyInvTestBasic, ConstructionFunctionReferenceDecay) {
346    using AnyInvType = typename TypeParam::AnyInvType;
347    AnyInvType fun = add_function;
348    EXPECT_TRUE(static_cast<bool>(fun));
349    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
350  }
351  TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableEmpty) {
352    using AnyInvType = typename TypeParam::AnyInvType;
353    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
354    CompatibleAnyInvType other;
355    AnyInvType fun = std::move(other);
356    EXPECT_FALSE(static_cast<bool>(other));  
357    EXPECT_EQ(other, nullptr);               
358    EXPECT_EQ(nullptr, other);               
359    EXPECT_FALSE(static_cast<bool>(fun));
360  }
361  TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableNonempty) {
362    using AnyInvType = typename TypeParam::AnyInvType;
363    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
364    CompatibleAnyInvType other = &add_function;
365    AnyInvType fun = std::move(other);
366    EXPECT_FALSE(static_cast<bool>(other));  
367    EXPECT_EQ(other, nullptr);               
368    EXPECT_EQ(nullptr, other);               
369    EXPECT_TRUE(static_cast<bool>(fun));
370    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
371  }
372  TYPED_TEST_P(AnyInvTestBasic, ConversionToBool) {
373    using AnyInvType = typename TypeParam::AnyInvType;
374    {
375      AnyInvType fun;
376      EXPECT_FALSE(fun ? true : false);  
377      EXPECT_TRUE(
378          (std::is_nothrow_constructible<bool, const AnyInvType&>::value));
379      EXPECT_FALSE((std::is_convertible<const AnyInvType&, bool>::value));
380    }
381    {
382      AnyInvType fun = &add_function;
383      EXPECT_TRUE(fun ? true : false);  
384    }
385  }
386  TYPED_TEST_P(AnyInvTestBasic, Invocation) {
387    using AnyInvType = typename TypeParam::AnyInvType;
388    using FunType = typename TypeParam::FunType;
389    using AnyInvCallType = MemberTypeOf<decltype(&AnyInvType::operator())>;
390    EXPECT_TRUE((std::is_same<AnyInvCallType, FunType>::value));
391    AnyInvType fun = &add_function;
392    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
393  }
394  TYPED_TEST_P(AnyInvTestBasic, InPlaceConstruction) {
395    using AnyInvType = typename TypeParam::AnyInvType;
396    using AddType = typename TypeParam::AddType;
397    AnyInvType fun(absl::in_place_type<AddType>, 5);
398    EXPECT_TRUE(static_cast<bool>(fun));
399    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
400  }
401  TYPED_TEST_P(AnyInvTestBasic, InPlaceConstructionInitializerList) {
402    using AnyInvType = typename TypeParam::AnyInvType;
403    using AddType = typename TypeParam::AddType;
404    AnyInvType fun(absl::in_place_type<AddType>, {1, 2, 3, 4}, 5);
405    EXPECT_TRUE(static_cast<bool>(fun));
406    EXPECT_EQ(39, TypeParam::ToThisParam(fun)(7, 8, 9).value);
407  }
408  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstruction) {
409    using AnyInvType = typename TypeParam::AnyInvType;
410    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
411    AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>, nullptr);
412    EXPECT_TRUE(static_cast<bool>(fun));
413  }
414  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstructionValueInit) {
415    using AnyInvType = typename TypeParam::AnyInvType;
416    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
417    AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>);
418    EXPECT_TRUE(static_cast<bool>(fun));
419  }
420  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstruction) {
421    using AnyInvType = typename TypeParam::AnyInvType;
422    using MemFunPtrType = typename TypeParam::MemFunPtrType;
423    AnyInvType fun(absl::in_place_type<MemFunPtrType>, nullptr);
424    EXPECT_TRUE(static_cast<bool>(fun));
425  }
426  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstructionValueInit) {
427    using AnyInvType = typename TypeParam::AnyInvType;
428    using MemFunPtrType = typename TypeParam::MemFunPtrType;
429    AnyInvType fun(absl::in_place_type<MemFunPtrType>);
430    EXPECT_TRUE(static_cast<bool>(fun));
431  }
432  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstruction) {
433    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
434    using MemObjPtrType = typename TypeParam::MemObjPtrType;
435    UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>, nullptr);
436    EXPECT_TRUE(static_cast<bool>(fun));
437  }
438  TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstructionValueInit) {
439    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
440    using MemObjPtrType = typename TypeParam::MemObjPtrType;
441    UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>);
442    EXPECT_TRUE(static_cast<bool>(fun));
443  }
444  TYPED_TEST_P(AnyInvTestBasic, InPlaceVoidCovarianceConstruction) {
445    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
446    using AddType = typename TypeParam::AddType;
447    VoidAnyInvType fun(absl::in_place_type<AddType>, 5);
448    EXPECT_TRUE(static_cast<bool>(fun));
449  }
450  TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromEmpty) {
451    using AnyInvType = typename TypeParam::AnyInvType;
452    AnyInvType source_fun;
453    AnyInvType fun(std::move(source_fun));
454    EXPECT_FALSE(static_cast<bool>(fun));
455    EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
456  }
457  TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromNonEmpty) {
458    using AnyInvType = typename TypeParam::AnyInvType;
459    using AddType = typename TypeParam::AddType;
460    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
461    AnyInvType fun(std::move(source_fun));
462    EXPECT_TRUE(static_cast<bool>(fun));
463    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
464    EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
465  }
466  TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrEmpty) {
467    using AnyInvType = typename TypeParam::AnyInvType;
468    AnyInvType fun;
469    EXPECT_TRUE(fun == nullptr);
470    EXPECT_TRUE(nullptr == fun);
471    EXPECT_FALSE(fun != nullptr);
472    EXPECT_FALSE(nullptr != fun);
473  }
474  TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrNonempty) {
475    using AnyInvType = typename TypeParam::AnyInvType;
476    using AddType = typename TypeParam::AddType;
477    AnyInvType fun(absl::in_place_type<AddType>, 5);
478    EXPECT_FALSE(fun == nullptr);
479    EXPECT_FALSE(nullptr == fun);
480    EXPECT_TRUE(fun != nullptr);
481    EXPECT_TRUE(nullptr != fun);
482  }
483  TYPED_TEST_P(AnyInvTestBasic, ResultType) {
484    using AnyInvType = typename TypeParam::AnyInvType;
485    using ExpectedResultType = typename TypeParam::ResultType;
486    EXPECT_TRUE((std::is_same<typename AnyInvType::result_type,
487                              ExpectedResultType>::value));
488  }
489  template <class T>
490  class AnyInvTestCombinatoric : public ::testing::Test {};
491  TYPED_TEST_SUITE_P(AnyInvTestCombinatoric);
492  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs) {
493    using AnyInvType = typename TypeParam::AnyInvType;
494    AnyInvType source_fun;
495    AnyInvType fun;
496    fun = std::move(source_fun);
497    EXPECT_FALSE(static_cast<bool>(fun));
498  }
499  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyLhsNonemptyRhs) {
500    using AnyInvType = typename TypeParam::AnyInvType;
501    using AddType = typename TypeParam::AddType;
502    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
503    AnyInvType fun;
504    fun = std::move(source_fun);
505    EXPECT_TRUE(static_cast<bool>(fun));
506    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
507  }
508  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyEmptyLhsRhs) {
509    using AnyInvType = typename TypeParam::AnyInvType;
510    using AddType = typename TypeParam::AddType;
511    AnyInvType source_fun;
512    AnyInvType fun(absl::in_place_type<AddType>, 5);
513    fun = std::move(source_fun);
514    EXPECT_FALSE(static_cast<bool>(fun));
515  }
516  TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyLhsNonemptyRhs) {
517    using AnyInvType = typename TypeParam::AnyInvType;
518    using AddType = typename TypeParam::AddType;
519    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
520    AnyInvType fun(absl::in_place_type<AddType>, 20);
521    fun = std::move(source_fun);
522    EXPECT_TRUE(static_cast<bool>(fun));
523    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
524  }
525  TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignEmpty) {
526    using AnyInvType = typename TypeParam::AnyInvType;
527    AnyInvType source_fun;
528    source_fun = std::move(source_fun);
529  }
530  TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignNonempty) {
531    using AnyInvType = typename TypeParam::AnyInvType;
532    using AddType = typename TypeParam::AddType;
533    AnyInvType source_fun(absl::in_place_type<AddType>, 5);
534    source_fun = std::move(source_fun);
535  }
536  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrEmptyLhs) {
537    using AnyInvType = typename TypeParam::AnyInvType;
538    AnyInvType fun;
539    fun = nullptr;
540    EXPECT_FALSE(static_cast<bool>(fun));
541  }
542  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrEmptyLhs) {
543    using AnyInvType = typename TypeParam::AnyInvType;
544    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
545    UnqualifiedFunType* const null_fun_ptr = nullptr;
546    AnyInvType fun;
547    fun = null_fun_ptr;
548    EXPECT_FALSE(static_cast<bool>(fun));
549  }
550  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrEmptyLhs) {
551    using AnyInvType = typename TypeParam::AnyInvType;
552    using MemFunPtrType = typename TypeParam::MemFunPtrType;
553    const MemFunPtrType null_mem_fun_ptr = nullptr;
554    AnyInvType fun;
555    fun = null_mem_fun_ptr;
556    EXPECT_FALSE(static_cast<bool>(fun));
557  }
558  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrEmptyLhs) {
559    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
560    using MemObjPtrType = typename TypeParam::MemObjPtrType;
561    const MemObjPtrType null_mem_obj_ptr = nullptr;
562    UnaryAnyInvType fun;
563    fun = null_mem_obj_ptr;
564    EXPECT_FALSE(static_cast<bool>(fun));
565  }
566  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrEmptyLhs) {
567    using AnyInvType = typename TypeParam::AnyInvType;
568    AnyInvType fun;
569    fun = &Int::MemberFunctionAdd;
570    EXPECT_TRUE(static_cast<bool>(fun));
571    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
572  }
573  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrEmptyLhs) {
574    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
575    UnaryAnyInvType fun;
576    fun = &Int::value;
577    EXPECT_TRUE(static_cast<bool>(fun));
578    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
579  }
580  TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayEmptyLhs) {
581    using AnyInvType = typename TypeParam::AnyInvType;
582    AnyInvType fun;
583    fun = add_function;
584    EXPECT_TRUE(static_cast<bool>(fun));
585    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
586  }
587  TYPED_TEST_P(AnyInvTestCombinatoric,
588               AssignCompatibleAnyInvocableEmptyLhsEmptyRhs) {
589    using AnyInvType = typename TypeParam::AnyInvType;
590    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
591    CompatibleAnyInvType other;
592    AnyInvType fun;
593    fun = std::move(other);
594    EXPECT_FALSE(static_cast<bool>(other));  
595    EXPECT_EQ(other, nullptr);               
596    EXPECT_EQ(nullptr, other);               
597    EXPECT_FALSE(static_cast<bool>(fun));
598  }
599  TYPED_TEST_P(AnyInvTestCombinatoric,
600               AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs) {
601    using AnyInvType = typename TypeParam::AnyInvType;
602    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
603    CompatibleAnyInvType other = &add_function;
604    AnyInvType fun;
605    fun = std::move(other);
606    EXPECT_FALSE(static_cast<bool>(other));  
607    EXPECT_TRUE(static_cast<bool>(fun));
608    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
609  }
610  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrNonemptyLhs) {
611    using AnyInvType = typename TypeParam::AnyInvType;
612    AnyInvType fun = &mult_function;
613    fun = nullptr;
614    EXPECT_FALSE(static_cast<bool>(fun));
615  }
616  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrNonemptyLhs) {
617    using AnyInvType = typename TypeParam::AnyInvType;
618    using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;
619    UnqualifiedFunType* const null_fun_ptr = nullptr;
620    AnyInvType fun = &mult_function;
621    fun = null_fun_ptr;
622    EXPECT_FALSE(static_cast<bool>(fun));
623  }
624  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrNonemptyLhs) {
625    using AnyInvType = typename TypeParam::AnyInvType;
626    using MemFunPtrType = typename TypeParam::MemFunPtrType;
627    const MemFunPtrType null_mem_fun_ptr = nullptr;
628    AnyInvType fun = &mult_function;
629    fun = null_mem_fun_ptr;
630    EXPECT_FALSE(static_cast<bool>(fun));
631  }
632  TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrNonemptyLhs) {
633    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
634    using MemObjPtrType = typename TypeParam::MemObjPtrType;
635    const MemObjPtrType null_mem_obj_ptr = nullptr;
636    UnaryAnyInvType fun = &square_function;
637    fun = null_mem_obj_ptr;
638    EXPECT_FALSE(static_cast<bool>(fun));
639  }
640  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrNonemptyLhs) {
641    using AnyInvType = typename TypeParam::AnyInvType;
642    AnyInvType fun = &mult_function;
643    fun = &Int::MemberFunctionAdd;
644    EXPECT_TRUE(static_cast<bool>(fun));
645    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
646  }
647  TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrNonemptyLhs) {
648    using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
649    UnaryAnyInvType fun = &square_function;
650    fun = &Int::value;
651    EXPECT_TRUE(static_cast<bool>(fun));
652    EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
653  }
654  TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayNonemptyLhs) {
655    using AnyInvType = typename TypeParam::AnyInvType;
656    AnyInvType fun = &mult_function;
657    fun = add_function;
658    EXPECT_TRUE(static_cast<bool>(fun));
659    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
660  }
661  TYPED_TEST_P(AnyInvTestCombinatoric,
662               AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs) {
663    using AnyInvType = typename TypeParam::AnyInvType;
664    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
665    CompatibleAnyInvType other;
666    AnyInvType fun = &mult_function;
667    fun = std::move(other);
668    EXPECT_FALSE(static_cast<bool>(other));  
669    EXPECT_EQ(other, nullptr);               
670    EXPECT_EQ(nullptr, other);               
671    EXPECT_FALSE(static_cast<bool>(fun));
672  }
673  TYPED_TEST_P(AnyInvTestCombinatoric,
674               AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs) {
675    using AnyInvType = typename TypeParam::AnyInvType;
676    using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;
677    CompatibleAnyInvType other = &add_function;
678    AnyInvType fun = &mult_function;
679    fun = std::move(other);
680    EXPECT_FALSE(static_cast<bool>(other));  
681    EXPECT_TRUE(static_cast<bool>(fun));
682    EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
683  }
684  TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsEmptyRhs) {
685    using AnyInvType = typename TypeParam::AnyInvType;
686    {
687      AnyInvType fun;
688      AnyInvType other;
689      using std::swap;
690      swap(fun, other);
691      EXPECT_FALSE(static_cast<bool>(fun));
692      EXPECT_FALSE(static_cast<bool>(other));
693      EXPECT_TRUE(
694          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
695    }
696    {
697      AnyInvType fun;
698      AnyInvType other;
699      fun.swap(other);
700      EXPECT_FALSE(static_cast<bool>(fun));
701      EXPECT_FALSE(static_cast<bool>(other));
702      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
703    }
704  }
705  TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsNonemptyRhs) {
706    using AnyInvType = typename TypeParam::AnyInvType;
707    using AddType = typename TypeParam::AddType;
708    {
709      AnyInvType fun;
710      AnyInvType other(absl::in_place_type<AddType>, 5);
711      using std::swap;
712      swap(fun, other);
713      EXPECT_TRUE(static_cast<bool>(fun));
714      EXPECT_FALSE(static_cast<bool>(other));
715      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
716      EXPECT_TRUE(
717          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
718    }
719    {
720      AnyInvType fun;
721      AnyInvType other(absl::in_place_type<AddType>, 5);
722      fun.swap(other);
723      EXPECT_TRUE(static_cast<bool>(fun));
724      EXPECT_FALSE(static_cast<bool>(other));
<span onclick='openModal()' class='match'>725      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
726      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
727    }
728  }
729  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsEmptyRhs) {
730    using AnyInvType = typename TypeParam::AnyInvType;
731    using AddType = typename TypeParam::AddType;
732    {
733      AnyInvType fun(absl::in_place_type<AddType>, 5);
734      AnyInvType other;
</span>735      using std::swap;
736      swap(fun, other);
737      EXPECT_FALSE(static_cast<bool>(fun));
738      EXPECT_TRUE(static_cast<bool>(other));
739      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
740      EXPECT_TRUE(
741          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
742    }
743    {
744      AnyInvType fun(absl::in_place_type<AddType>, 5);
745      AnyInvType other;
746      fun.swap(other);
747      EXPECT_FALSE(static_cast<bool>(fun));
748      EXPECT_TRUE(static_cast<bool>(other));
749      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
750      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
751    }
752  }
753  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsNonemptyRhs) {
754    using AnyInvType = typename TypeParam::AnyInvType;
755    using AddType = typename TypeParam::AddType;
756    {
757      AnyInvType fun(absl::in_place_type<AddType>, 5);
758      AnyInvType other(absl::in_place_type<AddType>, 6);
759      using std::swap;
760      swap(fun, other);
761      EXPECT_TRUE(static_cast<bool>(fun));
762      EXPECT_TRUE(static_cast<bool>(other));
763      EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
764      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
765      EXPECT_TRUE(
766          absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
767    }
768    {
769      AnyInvType fun(absl::in_place_type<AddType>, 5);
770      AnyInvType other(absl::in_place_type<AddType>, 6);
771      fun.swap(other);
772      EXPECT_TRUE(static_cast<bool>(fun));
773      EXPECT_TRUE(static_cast<bool>(other));
774      EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
775      EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);
776      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
777    }
778  }
779  template <class T>
780  class AnyInvTestMovable : public ::testing::Test {};
781  TYPED_TEST_SUITE_P(AnyInvTestMovable);
782  TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionUserDefinedType) {
783    using AnyInvType = typename TypeParam::AnyInvType;
784    using AddType = typename TypeParam::AddType;
785    AnyInvType fun(AddType(5));
786    EXPECT_TRUE(static_cast<bool>(fun));
787    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
788  }
789  TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionVoidCovariance) {
790    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
791    using AddType = typename TypeParam::AddType;
792    VoidAnyInvType fun(AddType(5));
793    EXPECT_TRUE(static_cast<bool>(fun));
794  }
795  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeEmptyLhs) {
796    using AnyInvType = typename TypeParam::AnyInvType;
797    using AddType = typename TypeParam::AddType;
798    AnyInvType fun;
799    fun = AddType(5);
800    EXPECT_TRUE(static_cast<bool>(fun));
801    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
802  }
803  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeNonemptyLhs) {
804    using AnyInvType = typename TypeParam::AnyInvType;
805    using AddType = typename TypeParam::AddType;
806    AnyInvType fun = &add_function;
807    fun = AddType(5);
808    EXPECT_TRUE(static_cast<bool>(fun));
809    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
810  }
811  TYPED_TEST_P(AnyInvTestMovable, ConversionAssignVoidCovariance) {
812    using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
813    using AddType = typename TypeParam::AddType;
814    VoidAnyInvType fun;
815    fun = AddType(5);
816    EXPECT_TRUE(static_cast<bool>(fun));
817  }
818  template <class T>
819  class AnyInvTestNoexceptFalse : public ::testing::Test {};
820  TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse);
821  TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionConstructionConstraints) {
822    using AnyInvType = typename TypeParam::AnyInvType;
823    EXPECT_TRUE((std::is_constructible<
824                 AnyInvType,
825                 typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
826    EXPECT_FALSE((
827        std::is_constructible<AnyInvType,
828                              typename TypeParam::IncompatibleInvocable>::value));
829  }
830  TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionAssignConstraints) {
831    using AnyInvType = typename TypeParam::AnyInvType;
832    EXPECT_TRUE((std::is_assignable<
833                 AnyInvType&,
834                 typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
835    EXPECT_FALSE(
836        (std::is_assignable<AnyInvType&,
837                            typename TypeParam::IncompatibleInvocable>::value));
838  }
839  template <class T>
840  class AnyInvTestNoexceptTrue : public ::testing::Test {};
841  TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue);
842  TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionConstructionConstraints) {
843  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
844    GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
845  #else
846    using AnyInvType = typename TypeParam::AnyInvType;
847    EXPECT_FALSE((std::is_constructible<
848                  AnyInvType,
849                  typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
850    EXPECT_FALSE((
851        std::is_constructible<AnyInvType,
852                              typename TypeParam::IncompatibleInvocable>::value));
853  #endif
854  }
855  TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionAssignConstraints) {
856  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
857    GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
858  #else
859    using AnyInvType = typename TypeParam::AnyInvType;
860    EXPECT_FALSE((std::is_assignable<
861                  AnyInvType&,
862                  typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
863    EXPECT_FALSE(
864        (std::is_assignable<AnyInvType&,
865                            typename TypeParam::IncompatibleInvocable>::value));
866  #endif
867  }
868  template <class T>
869  class AnyInvTestNonRvalue : public ::testing::Test {};
870  TYPED_TEST_SUITE_P(AnyInvTestNonRvalue);
871  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionConstructionReferenceWrapper) {
872    using AnyInvType = typename TypeParam::AnyInvType;
873    using AddType = typename TypeParam::AddType;
874    AddType add(4);
875    AnyInvType fun = std::ref(add);
876    add.state = 5;
877    EXPECT_TRUE(static_cast<bool>(fun));
878    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
879    EXPECT_TRUE(static_cast<bool>(fun));
880    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
881  }
882  TYPED_TEST_P(AnyInvTestNonRvalue, NonMoveableResultType) {
883  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
884    GTEST_SKIP() << "Copy/move elision was not standard before C++17";
885  #else
886    struct Result {
887      int x;
888      explicit Result(const int x_in) : x(x_in) {}
889      Result(Result&&) = delete;
890    };
891    static_assert(!std::is_move_constructible<Result>::value, "");
892    static_assert(!std::is_copy_constructible<Result>::value, "");
893    const auto return_17 = []() noexcept { return Result(17); };
894    EXPECT_EQ(17, return_17().x);
895    using UnqualifiedFun =
896        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
897    using Fun =
898        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
899    AnyInvocable<Fun> any_inv(return_17);
900    EXPECT_EQ(17, any_inv().x);
901  #endif
902  }
903  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperEmptyLhs) {
904    using AnyInvType = typename TypeParam::AnyInvType;
905    using AddType = typename TypeParam::AddType;
906    AddType add(4);
907    AnyInvType fun;
908    fun = std::ref(add);
909    add.state = 5;
910    EXPECT_TRUE(
911        (std::is_nothrow_assignable<AnyInvType&,
912                                    std::reference_wrapper<AddType>>::value));
913    EXPECT_TRUE(static_cast<bool>(fun));
914    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
915    EXPECT_TRUE(static_cast<bool>(fun));
916    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
917  }
918  TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperNonemptyLhs) {
919    using AnyInvType = typename TypeParam::AnyInvType;
920    using AddType = typename TypeParam::AddType;
921    AddType add(4);
922    AnyInvType fun = &mult_function;
923    fun = std::ref(add);
924    add.state = 5;
925    EXPECT_TRUE(
926        (std::is_nothrow_assignable<AnyInvType&,
927                                    std::reference_wrapper<AddType>>::value));
928    EXPECT_TRUE(static_cast<bool>(fun));
929    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
930    EXPECT_TRUE(static_cast<bool>(fun));
931    EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
932  }
933  template <class T>
934  class AnyInvTestRvalue : public ::testing::Test {};
935  TYPED_TEST_SUITE_P(AnyInvTestRvalue);
936  TYPED_TEST_P(AnyInvTestRvalue, ConversionConstructionReferenceWrapper) {
937    using AnyInvType = typename TypeParam::AnyInvType;
938    using AddType = typename TypeParam::AddType;
939    EXPECT_FALSE((
940        std::is_convertible<std::reference_wrapper<AddType>, AnyInvType>::value));
941  }
942  TYPED_TEST_P(AnyInvTestRvalue, NonMoveableResultType) {
943  #if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
944    GTEST_SKIP() << "Copy/move elision was not standard before C++17";
945  #else
946    struct Result {
947      int x;
948      explicit Result(const int x_in) : x(x_in) {}
949      Result(Result&&) = delete;
950    };
951    static_assert(!std::is_move_constructible<Result>::value, "");
952    static_assert(!std::is_copy_constructible<Result>::value, "");
953    const auto return_17 = []() noexcept { return Result(17); };
954    EXPECT_EQ(17, return_17().x);
955    using UnqualifiedFun =
956        absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;
957    using Fun =
958        GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;
959    EXPECT_EQ(17, AnyInvocable<Fun>(return_17)().x);
960  #endif
961  }
962  TYPED_TEST_P(AnyInvTestRvalue, ConversionAssignReferenceWrapper) {
963    using AnyInvType = typename TypeParam::AnyInvType;
964    using AddType = typename TypeParam::AddType;
965    EXPECT_FALSE((
966        std::is_assignable<AnyInvType&, std::reference_wrapper<AddType>>::value));
967  }
968  TYPED_TEST_P(AnyInvTestRvalue, NonConstCrashesOnSecondCall) {
969    using AnyInvType = typename TypeParam::AnyInvType;
970    using AddType = typename TypeParam::AddType;
971    AnyInvType fun(absl::in_place_type<AddType>, 5);
972    EXPECT_TRUE(static_cast<bool>(fun));
973    std::move(fun)(7, 8, 9);
974    EXPECT_TRUE(static_cast<bool>(fun));  
975  #if !defined(NDEBUG)
976    EXPECT_DEATH_IF_SUPPORTED(std::move(fun)(7, 8, 9), "");
977  #endif
978  }
979  TYPED_TEST_P(AnyInvTestRvalue, QualifierIndependentObjectLifetime) {
980    using AnyInvType = typename TypeParam::AnyInvType;
981    auto refs = std::make_shared<std::nullptr_t>();
982    {
983      AnyInvType fun([refs](auto&&...) noexcept { return 0; });
984      EXPECT_GT(refs.use_count(), 1);
985      std::move(fun)(7, 8, 9);
986      EXPECT_GT(refs.use_count(), 1);
987    }
988    EXPECT_EQ(refs.use_count(), 1);
989  }
990  template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
991            ObjSize Size, ObjAlign Align>
992  using NonRvalueQualifiedTestParams = ::testing::Types<               
993      TestParams<Mov, Dest, _, CallExceptionSpec, Size, Align>,        
994      TestParams<Mov, Dest, const _, CallExceptionSpec, Size, Align>,  
995      TestParams<Mov, Dest, _&, CallExceptionSpec, Size, Align>,       
996      TestParams<Mov, Dest, const _&, CallExceptionSpec, Size, Align>>;
997  template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
998            ObjSize Size, ObjAlign Align>
999  using RvalueQualifiedTestParams = ::testing::Types<
1000      TestParams<Mov, Dest, _&&, CallExceptionSpec, Size, Align>,       
1001      TestParams<Mov, Dest, const _&&, CallExceptionSpec, Size, Align>  
1002      >;
1003  using TestParameterListNonRvalueQualifiersNothrowCall =
1004      NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1005                                   NothrowCall::yes, ObjSize::small,
1006                                   ObjAlign::normal>;
1007  using TestParameterListRvalueQualifiersNothrowCall =
1008      RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1009                                NothrowCall::yes, ObjSize::small,
1010                                ObjAlign::normal>;
1011  using TestParameterListNonRvalueQualifiersCallMayThrow =
1012      NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1013                                   NothrowCall::no, ObjSize::small,
1014                                   ObjAlign::normal>;
1015  using TestParameterListRvalueQualifiersCallMayThrow =
1016      RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
1017                                NothrowCall::no, ObjSize::small,
1018                                ObjAlign::normal>;
1019  using TestParameterListRemoteMovable = ::testing::Types<
1020      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1021                 ObjSize::large, ObjAlign::normal>,  
1022      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1023                 ObjSize::large, ObjAlign::normal>,  
1024      TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
1025                 ObjSize::small, ObjAlign::normal>,  
1026      TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
1027                 ObjSize::large, ObjAlign::normal>,  
1028      TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
1029                 ObjSize::large, ObjAlign::normal>,  
1030      TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
1031                 ObjSize::large, ObjAlign::normal>,  
1032      TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
1033                 ObjSize::small, ObjAlign::normal>,  
1034      TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
1035                 ObjSize::large, ObjAlign::normal>  
1036  #if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
1037      ,
1038      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1039                 ObjSize::small, ObjAlign::large>,  
1040      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1041                 ObjSize::small, ObjAlign::large>,  
1042      TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
1043                 ObjSize::small, ObjAlign::large>,  
1044      TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
1045                 ObjSize::small, ObjAlign::large>  
1046  #endif
1047      >;
1048  using TestParameterListRemoteNonMovable = ::testing::Types<
1049      TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
1050                 ObjSize::small, ObjAlign::normal>,  
1051      TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
1052                 ObjSize::large, ObjAlign::normal>,  
1053      TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
1054                 ObjSize::small, ObjAlign::normal>,  
1055      TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
1056                 ObjSize::large, ObjAlign::normal>  
1057      >;
1058  using TestParameterListLocal = ::testing::Types<
1059      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1060                 ObjSize::small, ObjAlign::normal>,  
1061      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1062                 ObjSize::small, ObjAlign::normal>,  
1063      TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
1064                 ObjSize::small, ObjAlign::normal>,  
1065      TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
1066                 ObjSize::small, ObjAlign::normal>  
1067      >;
1068  REGISTER_TYPED_TEST_SUITE_P(
1069      AnyInvTestBasic, DefaultConstruction, ConstructionNullptr,
1070      ConstructionNullFunctionPtr, ConstructionNullMemberFunctionPtr,
1071      ConstructionNullMemberObjectPtr, ConstructionMemberFunctionPtr,
1072      ConstructionMemberObjectPtr, ConstructionFunctionReferenceDecay,
1073      ConstructionCompatibleAnyInvocableEmpty,
1074      ConstructionCompatibleAnyInvocableNonempty, InPlaceConstruction,
1075      ConversionToBool, Invocation, InPlaceConstructionInitializerList,
1076      InPlaceNullFunPtrConstruction, InPlaceNullFunPtrConstructionValueInit,
1077      InPlaceNullMemFunPtrConstruction, InPlaceNullMemFunPtrConstructionValueInit,
1078      InPlaceNullMemObjPtrConstruction, InPlaceNullMemObjPtrConstructionValueInit,
1079      InPlaceVoidCovarianceConstruction, MoveConstructionFromEmpty,
1080      MoveConstructionFromNonEmpty, ComparisonWithNullptrEmpty,
1081      ComparisonWithNullptrNonempty, ResultType);
1082  INSTANTIATE_TYPED_TEST_SUITE_P(
1083      NonRvalueCallMayThrow, AnyInvTestBasic,
1084      TestParameterListNonRvalueQualifiersCallMayThrow);
1085  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestBasic,
1086                                 TestParameterListRvalueQualifiersCallMayThrow);
1087  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestBasic,
1088                                 TestParameterListRemoteMovable);
1089  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestBasic,
1090                                 TestParameterListRemoteNonMovable);
1091  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestBasic, TestParameterListLocal);
1092  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestBasic,
1093                                 TestParameterListNonRvalueQualifiersNothrowCall);
1094  INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestBasic,
1095                                 TestParameterListRvalueQualifiersNothrowCall);
1096  REGISTER_TYPED_TEST_SUITE_P(
1097      AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs,
1098      MoveAssignEmptyLhsNonemptyRhs, MoveAssignNonemptyEmptyLhsRhs,
1099      MoveAssignNonemptyLhsNonemptyRhs, SelfMoveAssignEmpty,
1100      SelfMoveAssignNonempty, AssignNullptrEmptyLhs,
1101      AssignNullFunctionPtrEmptyLhs, AssignNullMemberFunctionPtrEmptyLhs,
1102      AssignNullMemberObjectPtrEmptyLhs, AssignMemberFunctionPtrEmptyLhs,
1103      AssignMemberObjectPtrEmptyLhs, AssignFunctionReferenceDecayEmptyLhs,
1104      AssignCompatibleAnyInvocableEmptyLhsEmptyRhs,
1105      AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs, AssignNullptrNonemptyLhs,
1106      AssignNullFunctionPtrNonemptyLhs, AssignNullMemberFunctionPtrNonemptyLhs,
1107      AssignNullMemberObjectPtrNonemptyLhs, AssignMemberFunctionPtrNonemptyLhs,
1108      AssignMemberObjectPtrNonemptyLhs, AssignFunctionReferenceDecayNonemptyLhs,
1109      AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs,
1110      AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs, SwapEmptyLhsEmptyRhs,
1111      SwapEmptyLhsNonemptyRhs, SwapNonemptyLhsEmptyRhs,
1112      SwapNonemptyLhsNonemptyRhs);
1113  INSTANTIATE_TYPED_TEST_SUITE_P(
1114      NonRvalueCallMayThrow, AnyInvTestCombinatoric,
1115      TestParameterListNonRvalueQualifiersCallMayThrow);
1116  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestCombinatoric,
1117                                 TestParameterListRvalueQualifiersCallMayThrow);
1118  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestCombinatoric,
1119                                 TestParameterListRemoteMovable);
1120  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestCombinatoric,
1121                                 TestParameterListRemoteNonMovable);
1122  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestCombinatoric,
1123                                 TestParameterListLocal);
1124  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestCombinatoric,
1125                                 TestParameterListNonRvalueQualifiersNothrowCall);
1126  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestCombinatoric,
1127                                 TestParameterListRvalueQualifiersNothrowCall);
1128  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestMovable,
1129                              ConversionConstructionUserDefinedType,
1130                              ConversionConstructionVoidCovariance,
1131                              ConversionAssignUserDefinedTypeEmptyLhs,
1132                              ConversionAssignUserDefinedTypeNonemptyLhs,
1133                              ConversionAssignVoidCovariance);
1134  INSTANTIATE_TYPED_TEST_SUITE_P(
1135      NonRvalueCallMayThrow, AnyInvTestMovable,
1136      TestParameterListNonRvalueQualifiersCallMayThrow);
1137  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestMovable,
1138                                 TestParameterListRvalueQualifiersCallMayThrow);
1139  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestMovable,
1140                                 TestParameterListRemoteMovable);
1141  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestMovable,
1142                                 TestParameterListLocal);
1143  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestMovable,
1144                                 TestParameterListNonRvalueQualifiersNothrowCall);
1145  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestMovable,
1146                                 TestParameterListRvalueQualifiersNothrowCall);
1147  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse,
1148                              ConversionConstructionConstraints,
1149                              ConversionAssignConstraints);
1150  INSTANTIATE_TYPED_TEST_SUITE_P(
1151      NonRvalueCallMayThrow, AnyInvTestNoexceptFalse,
1152      TestParameterListNonRvalueQualifiersCallMayThrow);
1153  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestNoexceptFalse,
1154                                 TestParameterListRvalueQualifiersCallMayThrow);
1155  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNoexceptFalse,
1156                                 TestParameterListRemoteMovable);
1157  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNoexceptFalse,
1158                                 TestParameterListRemoteNonMovable);
1159  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNoexceptFalse,
1160                                 TestParameterListLocal);
1161  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue,
1162                              ConversionConstructionConstraints,
1163                              ConversionAssignConstraints);
1164  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNoexceptTrue,
1165                                 TestParameterListNonRvalueQualifiersNothrowCall);
1166  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestNoexceptTrue,
1167                                 TestParameterListRvalueQualifiersNothrowCall);
1168  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNonRvalue,
1169                              ConversionConstructionReferenceWrapper,
1170                              NonMoveableResultType,
1171                              ConversionAssignReferenceWrapperEmptyLhs,
1172                              ConversionAssignReferenceWrapperNonemptyLhs);
1173  INSTANTIATE_TYPED_TEST_SUITE_P(
1174      NonRvalueCallMayThrow, AnyInvTestNonRvalue,
1175      TestParameterListNonRvalueQualifiersCallMayThrow);
1176  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNonRvalue,
1177                                 TestParameterListRemoteMovable);
1178  INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNonRvalue,
1179                                 TestParameterListRemoteNonMovable);
1180  INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNonRvalue,
1181                                 TestParameterListLocal);
1182  INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNonRvalue,
1183                                 TestParameterListNonRvalueQualifiersNothrowCall);
1184  REGISTER_TYPED_TEST_SUITE_P(AnyInvTestRvalue,
1185                              ConversionConstructionReferenceWrapper,
1186                              NonMoveableResultType,
1187                              ConversionAssignReferenceWrapper,
1188                              NonConstCrashesOnSecondCall,
1189                              QualifierIndependentObjectLifetime);
1190  INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestRvalue,
1191                                 TestParameterListRvalueQualifiersCallMayThrow);
1192  INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestRvalue,
1193                                 TestParameterListRvalueQualifiersNothrowCall);
1194  static_assert(
1195      std::is_convertible<void (*)(), absl::AnyInvocable<void() &&>>::value, "");
1196  static_assert(!std::is_convertible<void*, absl::AnyInvocable<void() &&>>::value,
1197                "");
1198  #undef ABSL_INTERNAL_NOEXCEPT_SPEC
1199  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-skygrid.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-any_invocable_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>202    DocsEntIdPrV.Clr(); EntIdToDocsH.GetDatKeyPrV(DocsEntIdPrV);
203    DocsEntIdPrV.Sort(false);
204  }
205  int TSkyGridBs::AddDoc(
206   const TStr& SwIdStr, const uint64& Tm,
207   const TStr& TitleStr, const TStr& HeadlineStr,
</pre></code></div>
                <div class="column column_space"><pre><code>725      EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
726      EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
727    }
728  }
729  TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsEmptyRhs) {
730    using AnyInvType = typename TypeParam::AnyInvType;
731    using AddType = typename TypeParam::AddType;
732    {
733      AnyInvType fun(absl::in_place_type<AddType>, 5);
734      AnyInvType other;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    