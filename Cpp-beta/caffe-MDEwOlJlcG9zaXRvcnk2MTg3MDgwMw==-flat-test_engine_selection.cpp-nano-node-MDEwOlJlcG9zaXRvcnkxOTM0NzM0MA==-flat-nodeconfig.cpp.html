
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.905380333951761%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_engine_selection.cpp</h3>
            <pre><code>1  #include <string>
2  #include <vector>
3  #include "google/protobuf/text_format.h"
4  #include "gtest/gtest.h"
5  #include "caffe/blob.hpp"
6  #include "caffe/common.hpp"
7  #include "caffe/engine_parser.hpp"
8  #include "caffe/filler.hpp"
9  #include "caffe/layer.hpp"
10  #include "caffe/layer_factory.hpp"
11  #include "caffe/layers/batch_norm_layer.hpp"
12  #include "caffe/layers/concat_layer.hpp"
13  #include "caffe/layers/conv_layer.hpp"
14  #include "caffe/layers/inner_product_layer.hpp"
15  #include "caffe/layers/lrn_layer.hpp"
16  #include "caffe/layers/pooling_layer.hpp"
17  #include "caffe/layers/relu_layer.hpp"
18  #include "caffe/layers/sigmoid_layer.hpp"
19  #include "caffe/layers/softmax_layer.hpp"
20  #include "caffe/layers/tanh_layer.hpp"
21  #ifdef MKL2017_SUPPORTED
22  #include "caffe/layers/mkl_layers.hpp"
23  #endif
24  #ifdef MKLDNN_SUPPORTED
25  #include "caffe/layers/mkldnn_layers.hpp"
26  #endif
27  #include "caffe/test/test_caffe_main.hpp"
28  #include "caffe/test/test_gradient_check_util.hpp"
29  namespace caffe {
30  template <typename TypeParam>
31  class TestEngineSelection : public MultiDeviceTest<TypeParam> {
32    typedef typename TypeParam::Dtype Dtype;
33   protected:
34    TestEngineSelection() {}
35    virtual ~TestEngineSelection() {}
36    virtual void InitNetFromProtoString(const string& proto) {
37      NetParameter param;
38      CHECK(google::protobuf::TextFormat::ParseFromString(proto, &param));
39      net_.reset(new Net<Dtype>(param));
40    }
41    virtual void InitNet(const string& net_engine) {
42      string proto =
43          "engine: '" + net_engine + "' "
44          "layer { "
45          "  name: 'data' "
46          "  type: 'Input' "
47          "  top: 'data' "
48          "  input_param { "
49          "  shape: { dim: 1 dim: 3 dim: 100 dim: 100 } "
50          "  } "
51          "} "
52          "layer { "
53          "  name: 'conv1' "
54          "  type: 'Convolution' "
55          "  bottom: 'data' "
56          "  top: 'conv1' "
57          "  convolution_param { "
58          "    num_output: 5 "
59          "    kernel_size: 3 "
60          "    stride: 2 "
61          "  } "
62          "} "
63          "layer { "
64          "  name: 'relu1' "
65          "  type: 'ReLU' "
66          "  bottom: 'conv1' "
67          "  top: 'conv1' "
68          "} "
69          "layer { "
70          "  name: 'pool1' "
71          "  type: 'Pooling' "
72          "  bottom: 'conv1' "
73          "  top: 'pool1' "
74          "  pooling_param { "
75          "    pool: MAX "
76          "    kernel_size: 2 "
77          "    stride: 2 "
78          "  } "
79          "} "
80          "layer { "
81          "  name: 'norm1' "
82          "  type: 'LRN' "
83          "  bottom: 'pool1' "
84          "  top: 'norm1' "
85          "  lrn_param { "
86          "    local_size: 3 "
87          "  } "
88          "} "
89          "layer { "
90          "  name: 'ip1' "
91          "  type: 'InnerProduct' "
92          "  inner_product_param { "
93          "    num_output: 1 "
94          "  } "
95          "  bottom: 'norm1' "
96          "  top: 'ip1' "
97          "} "
98          "layer { "
99          "  name: 'relu2' "
100          "  type: 'ReLU' "
101          "  bottom: 'ip1' "
102          "  top: 'ip1' "
103          "} "
104          " layer {"
105          "   bottom: 'ip1'"
106          "   top: 'bn1'"
107          "   name: 'bn1'"
108          "   type: 'BatchNorm'"
109          " }"
110          " layer {"
111          "   bottom: 'pool1'"
112          "   bottom: 'norm1'"
113          "   top: 'concat1'"
114          "   name: 'concat1'"
115          "   type: 'Concat'"
116          " } "
117          " layer { "
118          "   bottom: 'concat1' "
119          "   bottom: 'concat1' "
120          "   top: 'eltw1' "
121          "   name: 'eltw1' "
122          "   type: 'Eltwise' "
123          "}"
124          " layer { "
125          "   bottom: 'eltw1' "
126          "   top: 'split1' "
127          "   name: 'split1' "
128          "   type: 'Split' "
129          "}";
130      InitNetFromProtoString(proto);
131    }
132      shared_ptr<Net<Dtype> > net_;
133  };
134  TYPED_TEST_CASE(TestEngineSelection, TestDtypesAndDevices);
135  TYPED_TEST(TestEngineSelection, TestEngineParser) {
136    EngineParser ep1("CAFFE");
137    EXPECT_TRUE(ep1.isEngine("CAFFE"));
138    EXPECT_FALSE(ep1.isEngine("MKLDNN"));
139    EXPECT_FALSE(ep1.isEngine("MKL2017"));
140    EXPECT_FALSE(ep1.isEngine("CUDNN"));
141  #ifdef MKL2017_SUPPORTED
142    EngineParser ep2("MKL2017");
143    EXPECT_FALSE(ep2.isEngine("CAFFE"));
144    EXPECT_FALSE(ep2.isEngine("MKLDNN"));
145    EXPECT_TRUE(ep2.isEngine("MKL2017"));
146    EXPECT_FALSE(ep2.isEngine("CUDNN"));
147  #endif
148  #ifdef MKLDNN_SUPPORTED
149    EngineParser ep3("MKLDNN:CPU,FPGA,DLA");
150    EXPECT_FALSE(ep3.isEngine("CAFFE"));
151    EXPECT_TRUE(ep3.isEngine("MKLDNN"));
152    EXPECT_FALSE(ep3.isEngine("MKL2017"));
153    EXPECT_FALSE(ep3.isEngine("CUDNN"));
154    EXPECT_EQ(3, ep3.getNumberOfSubEngines());
155    EXPECT_EQ(&ep3.getMKLDNNSubEngine(0), &CpuEngine::Instance().get_engine());
156  #ifdef FPGA_ENABLED
157    EXPECT_EQ(&ep3.getMKLDNNSubEngine(1), &FPGAEngine::Instance().get_engine());
158  #endif
159  #ifdef DLA_ENABLED
160    EXPECT_EQ(&ep3.getMKLDNNSubEngine(2), &DLAEngine::Instance().get_engine());
161  #endif
162    EngineParser ep4("MKLDNN:FPGA,CPU,FPGA");
163    EXPECT_FALSE(ep4.isEngine("CAFFE"));
164    EXPECT_TRUE(ep4.isEngine("MKLDNN"));
165    EXPECT_FALSE(ep4.isEngine("MKL2017"));
166    EXPECT_FALSE(ep4.isEngine("CUDNN"));
167    EXPECT_EQ(3, ep4.getNumberOfSubEngines());
168    EXPECT_EQ(&ep4.getMKLDNNSubEngine(1), &CpuEngine::Instance().get_engine());
169  #ifdef FPGA_ENABLED
170    EXPECT_EQ(&ep4.getMKLDNNSubEngine(0), &FPGAEngine::Instance().get_engine());
171    EXPECT_EQ(&ep4.getMKLDNNSubEngine(2), &FPGAEngine::Instance().get_engine());
172  #endif
173  #endif  
174  #ifdef USE_CUDNN
175    EngineParser ep5("CUDNN");
176    EXPECT_FALSE(ep5.isEngine("CAFFE"));
177    EXPECT_FALSE(ep5.isEngine("MKLDNN"));
178    EXPECT_FALSE(ep5.isEngine("MKL2017"));
179    EXPECT_TRUE(ep5.isEngine("CUDNN"));
180  #endif
181  }
182  TYPED_TEST(TestEngineSelection, TestEngineParserNetCAFFE) {
183    typedef typename TypeParam::Dtype Dtype;
<span onclick='openModal()' class='match'>184    void* null_ptr = NULL;
185    this->InitNet("CAFFE");
186    Net<Dtype>* net = this->net_.get();
187    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
</span>188    ConvolutionLayer<Dtype>* conv1_caffe =
189            dynamic_cast<ConvolutionLayer<Dtype>* >(conv1_layer);
190    EXPECT_NE(null_ptr, conv1_caffe);
191  #ifdef MKL2017_SUPPORTED
192    MKLConvolutionLayer<Dtype>* conv1_mkl =
193            dynamic_cast<MKLConvolutionLayer<Dtype>* >(conv1_layer);
194    EXPECT_EQ(null_ptr, conv1_mkl);
195  #endif
196  #ifdef MKLDNN_SUPPORTED
197    MKLDNNConvolutionLayer<Dtype>* conv1_mkldnn =
198            dynamic_cast<MKLDNNConvolutionLayer<Dtype>* >(conv1_layer);
199    EXPECT_EQ(null_ptr, conv1_mkldnn);
200  #endif
201    Layer<Dtype>* relu1_layer = net->layer_by_name("relu1").get();
202    ReLULayer<Dtype>* relu1_caffe =
203            dynamic_cast<ReLULayer<Dtype>* >(relu1_layer);
204    EXPECT_NE(null_ptr, relu1_caffe);
205    Layer<Dtype>* relu2_layer = net->layer_by_name("relu2").get();
206    ReLULayer<Dtype>* relu2_caffe =
207            dynamic_cast<ReLULayer<Dtype>* >(relu2_layer);
208    EXPECT_NE(null_ptr, relu2_caffe);
209    Layer<Dtype>* pool1_layer = net->layer_by_name("pool1").get();
210    PoolingLayer<Dtype>* pool1_caffe =
211            dynamic_cast<PoolingLayer<Dtype>* >(pool1_layer);
212    EXPECT_NE(null_ptr, pool1_caffe);
213    Layer<Dtype>* norm1_layer = net->layer_by_name("norm1").get();
214    LRNLayer<Dtype>* norm1_caffe =
215            dynamic_cast<LRNLayer<Dtype>* >(norm1_layer);
216    EXPECT_NE(null_ptr, norm1_caffe);
217    Layer<Dtype>* ip1_layer = net->layer_by_name("ip1").get();
218    InnerProductLayer<Dtype>* ip1_caffe =
219            dynamic_cast<InnerProductLayer<Dtype>* >(ip1_layer);
220    EXPECT_NE(null_ptr, ip1_caffe);
221    Layer<Dtype>* bn1_layer = net->layer_by_name("bn1").get();
222    BatchNormLayer<Dtype>* bn1_caffe =
223            dynamic_cast<BatchNormLayer<Dtype>* >(bn1_layer);
224    EXPECT_NE(null_ptr, bn1_caffe);
225    Layer<Dtype>* concat1_layer = net->layer_by_name("concat1").get();
226    ConcatLayer<Dtype>* concat1_caffe =
227            dynamic_cast<ConcatLayer<Dtype>* >(concat1_layer);
228    EXPECT_NE(null_ptr, concat1_caffe);
229    Layer<Dtype>* eltw1_layer = net->layer_by_name("eltw1").get();
230    EltwiseLayer<Dtype>* eltw1_caffe =
231            dynamic_cast<EltwiseLayer<Dtype>* >(eltw1_layer);
232    EXPECT_NE(null_ptr, eltw1_caffe);
233    const vector<shared_ptr<Layer<Dtype> > >& layers = net->layers();
234    for (int i = 0; i < layers.size(); i++) {
235      if (layers[i]->layer_param().type() == "Split") {
236        string name = layers[i]->layer_param().name();
237        Layer<Dtype>* split_layer = net->layer_by_name(name).get();
238        SplitLayer<Dtype>* split_caffe =
239            dynamic_cast<SplitLayer<Dtype>* >(split_layer);
240        EXPECT_NE(null_ptr, split_caffe);
241      }
242    }
243  }
244  #ifdef MKL2017_SUPPORTED
245  TYPED_TEST(TestEngineSelection, TestEngineParserNetMKL2017) {
246    typedef typename TypeParam::Dtype Dtype;
247    void* null_ptr = NULL;
248    this->InitNet("MKL2017");
249    Net<Dtype>* net = this->net_.get();
250    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
251    MKLConvolutionLayer<Dtype>* conv1_mkl =
252            dynamic_cast<MKLConvolutionLayer<Dtype>* >(conv1_layer);
253    EXPECT_NE(null_ptr, conv1_mkl);
254    ConvolutionLayer<Dtype>* conv1_caffe =
255            dynamic_cast<ConvolutionLayer<Dtype>* >(conv1_layer);
256    EXPECT_NE(null_ptr, conv1_caffe);
257    Layer<Dtype>* relu1_layer = net->layer_by_name("relu1").get();
258    MKLReLULayer<Dtype>* relu1_mkl =
259            dynamic_cast<MKLReLULayer<Dtype>* >(relu1_layer);
260    EXPECT_NE(null_ptr, relu1_mkl);
261    Layer<Dtype>* relu2_layer = net->layer_by_name("relu2").get();
262    MKLReLULayer<Dtype>* relu2_mkl =
263            dynamic_cast<MKLReLULayer<Dtype>* >(relu2_layer);
264    EXPECT_NE(null_ptr, relu2_mkl);
265    Layer<Dtype>* pool1_layer = net->layer_by_name("pool1").get();
266    MKLPoolingLayer<Dtype>* pool1_mkl =
267            dynamic_cast<MKLPoolingLayer<Dtype>* >(pool1_layer);
268    EXPECT_NE(null_ptr, pool1_mkl);
269    Layer<Dtype>* norm1_layer = net->layer_by_name("norm1").get();
270    MKLLRNLayer<Dtype>* norm1_mkl =
271            dynamic_cast<MKLLRNLayer<Dtype>* >(norm1_layer);
272    EXPECT_NE(null_ptr, norm1_mkl);
273    Layer<Dtype>* ip1_layer = net->layer_by_name("ip1").get();
274    InnerProductLayer<Dtype>* ip1_caffe =
275            dynamic_cast<InnerProductLayer<Dtype>* >(ip1_layer);
276    EXPECT_NE(null_ptr, ip1_caffe);
277    Layer<Dtype>* bn1_layer = net->layer_by_name("bn1").get();
278    MKLBatchNormLayer<Dtype>* bn1_mkl =
279            dynamic_cast<MKLBatchNormLayer<Dtype>* >(bn1_layer);
280    EXPECT_NE(null_ptr, bn1_mkl);
281    Layer<Dtype>* concat1_layer = net->layer_by_name("concat1").get();
282    MKLConcatLayer<Dtype>* concat1_mkl =
283            dynamic_cast<MKLConcatLayer<Dtype>* >(concat1_layer);
284    EXPECT_NE(null_ptr, concat1_mkl);
285    Layer<Dtype>* eltw1_layer = net->layer_by_name("eltw1").get();
286    MKLEltwiseLayer<Dtype>* eltw1_mkl =
287            dynamic_cast<MKLEltwiseLayer<Dtype>* >(eltw1_layer);
288    EXPECT_NE(null_ptr, eltw1_mkl);
289    const vector<shared_ptr<Layer<Dtype> > >& layers = net->layers();
290    for (int i = 0; i < layers.size(); i++) {
291      if (layers[i]->layer_param().type() == "Split") {
292        string name = layers[i]->layer_param().name();
293        Layer<Dtype>* split_layer = net->layer_by_name(name).get();
294        MKLSplitLayer<Dtype>* split_mkl =
295            dynamic_cast<MKLSplitLayer<Dtype>* >(split_layer);
296        EXPECT_NE(null_ptr, split_mkl);
297      }
298    }
299  }
300  #endif
301  #ifdef MKLDNN_SUPPORTED
302  TYPED_TEST(TestEngineSelection, TestEngineParserNetMKLDNN) {
303    typedef typename TypeParam::Dtype Dtype;
304    void* null_ptr = NULL;
305    this->InitNet("MKLDNN:CPU");
306    Net<Dtype>* net = this->net_.get();
307    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
308    MKLDNNConvolutionLayer<Dtype>* conv1_mkldnn =
309            dynamic_cast<MKLDNNConvolutionLayer<Dtype>* >(conv1_layer);
310    EXPECT_NE(null_ptr, conv1_mkldnn);
311    ConvolutionLayer<Dtype>* conv1_caffe =
312            dynamic_cast<ConvolutionLayer<Dtype>* >(conv1_layer);
313    EXPECT_NE(null_ptr, conv1_caffe);
314    Layer<Dtype>* relu1_layer = net->layer_by_name("relu1").get();
315    MKLDNNReLULayer<Dtype>* relu1_mkldnn =
316            dynamic_cast<MKLDNNReLULayer<Dtype>* >(relu1_layer);
317    EXPECT_EQ(null_ptr, relu1_mkldnn);
318    Layer<Dtype>* pool1_layer = net->layer_by_name("pool1").get();
319    MKLDNNPoolingLayer<Dtype>* pool1_mkldnn =
320            dynamic_cast<MKLDNNPoolingLayer<Dtype>* >(pool1_layer);
321    EXPECT_NE(null_ptr, pool1_mkldnn);
322    Layer<Dtype>* norm1_layer = net->layer_by_name("norm1").get();
323    MKLDNNLRNLayer<Dtype>* norm1_mkldnn =
324            dynamic_cast<MKLDNNLRNLayer<Dtype>* >(norm1_layer);
325    EXPECT_NE(null_ptr, norm1_mkldnn);
326    Layer<Dtype>* ip1_layer = net->layer_by_name("ip1").get();
327    MKLDNNInnerProductLayer<Dtype>* ip1_mkldnn =
328            dynamic_cast<MKLDNNInnerProductLayer<Dtype>* >(ip1_layer);
329    EXPECT_NE(null_ptr, ip1_mkldnn);
330    Layer<Dtype>* bn1_layer = net->layer_by_name("bn1").get();
331    MKLDNNBatchNormLayer<Dtype>* bn1_mkldnn =
332            dynamic_cast<MKLDNNBatchNormLayer<Dtype>* >(bn1_layer);
333    EXPECT_NE(null_ptr, bn1_mkldnn);
334    Layer<Dtype>* concat1_layer = net->layer_by_name("concat1").get();
335    MKLDNNConcatLayer<Dtype>* concat1_mkldnn =
336            dynamic_cast<MKLDNNConcatLayer<Dtype>* >(concat1_layer);
337    EXPECT_NE(null_ptr, concat1_mkldnn);
338    Layer<Dtype>* eltw1_layer = net->layer_by_name("eltw1").get();
339    MKLDNNEltwiseLayer<Dtype>* eltw1_mkldnn =
340            dynamic_cast<MKLDNNEltwiseLayer<Dtype>* >(eltw1_layer);
341    EXPECT_NE(null_ptr, eltw1_mkldnn);
342    const vector<shared_ptr<Layer<Dtype> > >& layers = net->layers();
343    for (int i = 0; i < layers.size(); i++) {
344      if (layers[i]->layer_param().type() == "Split") {
345        string name = layers[i]->layer_param().name();
346        Layer<Dtype>* split_layer = net->layer_by_name(name).get();
347        MKLDNNSplitLayer<Dtype>* split_caffe =
348            dynamic_cast<MKLDNNSplitLayer<Dtype>* >(split_layer);
349        EXPECT_NE(null_ptr, split_caffe);
350      }
351    }
352  }
353  #endif
354  }  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-nodeconfig.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/config.hpp>
3  #include <nano/lib/jsonconfig.hpp>
4  #include <nano/lib/rpcconfig.hpp>
5  #include <nano/lib/tomlconfig.hpp>
6  #include <nano/node/nodeconfig.hpp>
7  #include <nano/node/transport/transport.hpp>
8  #include <boost/format.hpp>
9  #include <cryptopp/words.h>
10  namespace
11  {
12  char const * preconfigured_peers_key = "preconfigured_peers";
13  char const * signature_checker_threads_key = "signature_checker_threads";
14  char const * pow_sleep_interval_key = "pow_sleep_interval";
<span onclick='openModal()' class='match'>15  std::string const default_live_peer_network = nano::get_env_or_default ("NANO_DEFAULT_PEER", "peering.nano.org");
16  std::string const default_beta_peer_network = nano::get_env_or_default ("NANO_DEFAULT_PEER", "peering-beta.nano.org");
17  std::string const default_test_peer_network = nano::get_env_or_default ("NANO_DEFAULT_PEER", "peering-test.nano.org");
</span>18  }
19  nano::node_config::node_config (nano::network_params & network_params) :
20  	node_config (std::nullopt, nano::logging (), network_params)
21  {
22  }
23  nano::node_config::node_config (const std::optional<uint16_t> & peering_port_a, nano::logging const & logging_a, nano::network_params & network_params) :
24  	network_params{ network_params },
25  	peering_port{ peering_port_a },
26  	logging{ logging_a },
27  	websocket_config{ network_params.network },
28  	ipc_config{ network_params.network },
29  	external_address{ boost::asio::ip::address_v6{}.to_string () }
30  {
31  	if (peering_port == 0)
32  	{
33  	}
34  	switch (network_params.network.network ())
35  	{
36  		case nano::networks::nano_dev_network:
37  			enable_voting = true;
38  			preconfigured_representatives.push_back (network_params.ledger.genesis->account ());
39  			break;
40  		case nano::networks::nano_beta_network:
41  		{
42  			preconfigured_peers.emplace_back (default_beta_peer_network);
43  			nano::account offline_representative;
44  			release_assert (!offline_representative.decode_account ("nano_1defau1t9off1ine9rep99999999999999999999999999999999wgmuzxxy"));
45  			preconfigured_representatives.emplace_back (offline_representative);
46  			break;
47  		}
48  		case nano::networks::nano_live_network:
49  			preconfigured_peers.emplace_back (default_live_peer_network);
50  			preconfigured_representatives.emplace_back ("A30E0A32ED41C8607AA9212843392E853FCBCB4E7CB194E35C94F07F91DE59EF");
51  			preconfigured_representatives.emplace_back ("67556D31DDFC2A440BF6147501449B4CB9572278D034EE686A6BEE29851681DF");
52  			preconfigured_representatives.emplace_back ("5C2FBB148E006A8E8BA7A75DD86C9FE00C83F5FFDBFD76EAA09531071436B6AF");
53  			preconfigured_representatives.emplace_back ("AE7AC63990DAAAF2A69BF11C913B928844BF5012355456F2F164166464024B29");
54  			preconfigured_representatives.emplace_back ("BD6267D6ECD8038327D2BCC0850BDF8F56EC0414912207E81BCF90DFAC8A4AAA");
55  			preconfigured_representatives.emplace_back ("2399A083C600AA0572F5E36247D978FCFC840405F8D4B6D33161C0066A55F431");
56  			preconfigured_representatives.emplace_back ("2298FAB7C61058E77EA554CB93EDEEDA0692CBFCC540AB213B2836B29029E23A");
57  			preconfigured_representatives.emplace_back ("3FE80B4BC842E82C1C18ABFEEC47EA989E63953BC82AC411F304D13833D52A56");
58  			break;
59  		case nano::networks::nano_test_network:
60  			preconfigured_peers.push_back (default_test_peer_network);
61  			preconfigured_representatives.push_back (network_params.ledger.genesis->account ());
62  			break;
63  		default:
64  			debug_assert (false);
65  			break;
66  	}
67  }
68  nano::error nano::node_config::serialize_toml (nano::tomlconfig & toml) const
69  {
70  	if (peering_port.has_value ())
71  	{
72  		toml.put ("peering_port", *peering_port, "Node peering port.\ntype:uint16");
73  	}
74  	toml.put ("bootstrap_fraction_numerator", bootstrap_fraction_numerator, "Change bootstrap threshold (online stake / 256 * bootstrap_fraction_numerator).\ntype:uint32");
75  	toml.put ("receive_minimum", receive_minimum.to_string_dec (), "Minimum receive amount. Only affects node wallets. A large amount is recommended to avoid automatic work generation for tiny transactions.\ntype:string,amount,raw");
76  	toml.put ("online_weight_minimum", online_weight_minimum.to_string_dec (), "When calculating online weight, the node is forced to assume at least this much voting weight is online, thus setting a floor for voting weight to confirm transactions at online_weight_minimum * \"quorum delta\".\ntype:string,amount,raw");
77  	toml.put ("election_hint_weight_percent", election_hint_weight_percent, "Percentage of online weight to hint at starting an election. Defaults to 10.\ntype:uint32,[5,50]");
78  	toml.put ("password_fanout", password_fanout, "Password fanout factor.\ntype:uint64");
79  	toml.put ("io_threads", io_threads, "Number of threads dedicated to I/O operations. Defaults to the number of CPU threads, and at least 4.\ntype:uint64");
80  	toml.put ("network_threads", network_threads, "Number of threads dedicated to processing network messages. Defaults to the number of CPU threads, and at least 4.\ntype:uint64");
81  	toml.put ("work_threads", work_threads, "Number of threads dedicated to CPU generated work. Defaults to all available CPU threads.\ntype:uint64");
82  	toml.put ("background_threads", background_threads, "Number of threads dedicated to background node work, including handling of RPC requests. Defaults to all available CPU threads.\ntype:uint64");
83  	toml.put ("signature_checker_threads", signature_checker_threads, "Number of additional threads dedicated to signature verification. Defaults to number of CPU threads / 2.\ntype:uint64");
84  	toml.put ("enable_voting", enable_voting, "Enable or disable voting. Enabling this option requires additional system resources, namely increased CPU, bandwidth and disk usage.\ntype:bool");
85  	toml.put ("bootstrap_connections", bootstrap_connections, "Number of outbound bootstrap connections. Must be a power of 2. Defaults to 4.\nWarning: a larger amount of connections may use substantially more system memory.\ntype:uint64");
86  	toml.put ("bootstrap_connections_max", bootstrap_connections_max, "Maximum number of inbound bootstrap connections. Defaults to 64.\nWarning: a larger amount of connections may use additional system memory.\ntype:uint64");
87  	toml.put ("bootstrap_initiator_threads", bootstrap_initiator_threads, "Number of threads dedicated to concurrent bootstrap attempts. Defaults to 1.\nWarning: a larger amount of attempts may use additional system memory and disk IO.\ntype:uint64");
88  	toml.put ("bootstrap_serving_threads", bootstrap_serving_threads, "Number of threads dedicated to serving bootstrap data to other peers. Defaults to half the number of CPU threads, and at least 2.\ntype:uint64");
89  	toml.put ("bootstrap_frontier_request_count", bootstrap_frontier_request_count, "Number frontiers per bootstrap frontier request. Defaults to 1048576.\ntype:uint32,[1024..4294967295]");
90  	toml.put ("block_processor_batch_max_time", block_processor_batch_max_time.count (), "The maximum time the block processor can continuously process blocks for.\ntype:milliseconds");
91  	toml.put ("block_process_timeout", block_process_timeout.count (), "Time to wait for block processing result.\ntype:seconds");
92  	toml.put ("allow_local_peers", allow_local_peers, "Enable or disable local host peering.\ntype:bool");
93  	toml.put ("vote_minimum", vote_minimum.to_string_dec (), "Local representatives do not vote if the delegated weight is under this threshold. Saves on system resources.\ntype:string,amount,raw");
94  	toml.put ("vote_generator_delay", vote_generator_delay.count (), "Delay before votes are sent to allow for efficient bundling of hashes in votes.\ntype:milliseconds");
95  	toml.put ("vote_generator_threshold", vote_generator_threshold, "Number of bundled hashes required for an additional generator delay.\ntype:uint64,[1..11]");
96  	toml.put ("unchecked_cutoff_time", unchecked_cutoff_time.count (), "Number of seconds before deleting an unchecked entry.\nWarning: lower values (e.g., 3600 seconds, or 1 hour) may result in unsuccessful bootstraps, especially a bootstrap from scratch.\ntype:seconds");
97  	toml.put ("tcp_io_timeout", tcp_io_timeout.count (), "Timeout for TCP connect-, read- and write operations.\nWarning: a low value (e.g., below 5 seconds) may result in TCP connections failing.\ntype:seconds");
98  	toml.put ("pow_sleep_interval", pow_sleep_interval.count (), "Time to sleep between batch work generation attempts. Reduces max CPU usage at the expense of a longer generation time.\ntype:nanoseconds");
99  	toml.put ("external_address", external_address, "The external address of this node (NAT). If not set, the node will request this information via UPnP.\ntype:string,ip");
100  	toml.put ("external_port", external_port, "The external port number of this node (NAT). Only used if external_address is set.\ntype:uint16");
101  	toml.put ("tcp_incoming_connections_max", tcp_incoming_connections_max, "Maximum number of incoming TCP connections.\ntype:uint64");
102  	toml.put ("use_memory_pools", use_memory_pools, "If true, allocate memory from memory pools. Enabling this may improve performance. Memory is never released to the OS.\ntype:bool");
103  	toml.put ("confirmation_history_size", confirmation_history_size, "Maximum confirmation history size. If tracking the rate of block confirmations, the websocket feature is recommended instead.\ntype:uint64");
104  	toml.put ("active_elections_size", active_elections_size, "Number of active elections. Elections beyond this limit have limited survival time.\nWarning: modifying this value may result in a lower confirmation rate.\ntype:uint64,[250..]");
105  	toml.put ("bandwidth_limit", bandwidth_limit, "Outbound traffic limit in bytes/sec after which messages will be dropped.\nNote: changing to unlimited bandwidth (0) is not recommended for limited connections.\ntype:uint64");
106  	toml.put ("bandwidth_limit_burst_ratio", bandwidth_limit_burst_ratio, "Burst ratio for outbound traffic shaping.\ntype:double");
107  	toml.put ("bootstrap_bandwidth_limit", bootstrap_bandwidth_limit, "Outbound bootstrap traffic limit in bytes/sec after which messages will be dropped.\nNote: changing to unlimited bandwidth (0) is not recommended for limited connections.\ntype:uint64");
108  	toml.put ("bootstrap_bandwidth_burst_ratio", bootstrap_bandwidth_burst_ratio, "Burst ratio for outbound bootstrap traffic.\ntype:double");
109  	toml.put ("conf_height_processor_batch_min_time", conf_height_processor_batch_min_time.count (), "Minimum write batching time when there are blocks pending confirmation height.\ntype:milliseconds");
110  	toml.put ("backup_before_upgrade", backup_before_upgrade, "Backup the ledger database before performing upgrades.\nWarning: uses more disk storage and increases startup time when upgrading.\ntype:bool");
111  	toml.put ("max_work_generate_multiplier", max_work_generate_multiplier, "Maximum allowed difficulty multiplier for work generation.\ntype:double,[1..]");
112  	toml.put ("frontiers_confirmation", serialize_frontiers_confirmation (frontiers_confirmation), "Mode controlling frontier confirmation rate.\ntype:string,{auto,always,disabled}");
113  	toml.put ("max_queued_requests", max_queued_requests, "Limit for number of queued confirmation requests for one channel, after which new requests are dropped until the queue drops below this value.\ntype:uint32");
114  	toml.put ("rep_crawler_weight_minimum", rep_crawler_weight_minimum.to_string_dec (), "Rep crawler minimum weight, if this is less than minimum principal weight then this is taken as the minimum weight a rep must have to be tracked. If you want to track all reps set this to 0. If you do not want this to influence anything then set it to max value. This is only useful for debugging or for people who really know what they are doing.\ntype:string,amount,raw");
115  	toml.put ("backlog_scan_batch_size", backlog_scan_batch_size, "Number of accounts per second to process when doing backlog population scan. Increasing this value will help unconfirmed frontiers get into election prioritization queue faster, however it will also increase resource usage. \ntype:uint");
116  	toml.put ("backlog_scan_frequency", backlog_scan_frequency, "Backlog scan divides the scan into smaller batches, number of which is controlled by this value. Higher frequency helps to utilize resources more uniformly, however it also introduces more overhead. The resulting number of accounts per single batch is `backlog_scan_batch_size / backlog_scan_frequency` \ntype:uint");
117  	auto work_peers_l (toml.create_array ("work_peers", "A list of \"address:port\" entries to identify work peers."));
118  	for (auto i (work_peers.begin ()), n (work_peers.end ()); i != n; ++i)
119  	{
120  		work_peers_l->push_back (boost::str (boost::format ("%1%:%2%") % i->first % i->second));
121  	}
122  	auto preconfigured_peers_l (toml.create_array ("preconfigured_peers", "A list of \"address\" (hostname or ipv6 notation ip address) entries to identify preconfigured peers.\nThe contents of the NANO_DEFAULT_PEER environment variable are added to preconfigured_peers."));
123  	for (auto i (preconfigured_peers.begin ()), n (preconfigured_peers.end ()); i != n; ++i)
124  	{
125  		preconfigured_peers_l->push_back (*i);
126  	}
127  	auto preconfigured_representatives_l (toml.create_array ("preconfigured_representatives", "A list of representative account addresses used when creating new accounts in internal wallets."));
128  	for (auto i (preconfigured_representatives.begin ()), n (preconfigured_representatives.end ()); i != n; ++i)
129  	{
130  		preconfigured_representatives_l->push_back (i->to_account ());
131  	}
132  	nano::tomlconfig experimental_l;
133  	auto secondary_work_peers_l (experimental_l.create_array ("secondary_work_peers", "A list of \"address:port\" entries to identify work peers for secondary work generation."));
134  	for (auto i (secondary_work_peers.begin ()), n (secondary_work_peers.end ()); i != n; ++i)
135  	{
136  		secondary_work_peers_l->push_back (boost::str (boost::format ("%1%:%2%") % i->first % i->second));
137  	}
138  	experimental_l.put ("max_pruning_age", max_pruning_age.count (), "Time limit for blocks age after pruning.\ntype:seconds");
139  	experimental_l.put ("max_pruning_depth", max_pruning_depth, "Limit for full blocks in chain after pruning.\ntype:uint64");
140  	toml.put_child ("experimental", experimental_l);
141  	nano::tomlconfig callback_l;
142  	callback_l.put ("address", callback_address, "Callback address.\ntype:string,ip");
143  	callback_l.put ("port", callback_port, "Callback port number.\ntype:uint16");
144  	callback_l.put ("target", callback_target, "Callback target path.\ntype:string,uri");
145  	toml.put_child ("httpcallback", callback_l);
146  	nano::tomlconfig logging_l;
147  	logging.serialize_toml (logging_l);
148  	toml.put_child ("logging", logging_l);
149  	nano::tomlconfig websocket_l;
150  	websocket_config.serialize_toml (websocket_l);
151  	toml.put_child ("websocket", websocket_l);
152  	nano::tomlconfig ipc_l;
153  	ipc_config.serialize_toml (ipc_l);
154  	toml.put_child ("ipc", ipc_l);
155  	nano::tomlconfig diagnostics_l;
156  	diagnostics_config.serialize_toml (diagnostics_l);
157  	toml.put_child ("diagnostics", diagnostics_l);
158  	nano::tomlconfig stat_l;
159  	stats_config.serialize_toml (stat_l);
160  	toml.put_child ("statistics", stat_l);
161  	nano::tomlconfig rocksdb_l;
162  	rocksdb_config.serialize_toml (rocksdb_l);
163  	toml.put_child ("rocksdb", rocksdb_l);
164  	nano::tomlconfig lmdb_l;
165  	lmdb_config.serialize_toml (lmdb_l);
166  	toml.put_child ("lmdb", lmdb_l);
167  	nano::tomlconfig optimistic_l;
168  	optimistic_scheduler.serialize (optimistic_l);
169  	toml.put_child ("optimistic_scheduler", optimistic_l);
170  	nano::tomlconfig bootstrap_ascending_l;
171  	bootstrap_ascending.serialize (bootstrap_ascending_l);
172  	toml.put_child ("bootstrap_ascending", bootstrap_ascending_l);
173  	return toml.get_error ();
174  }
175  nano::error nano::node_config::deserialize_toml (nano::tomlconfig & toml)
176  {
177  	try
178  	{
179  		if (toml.has_key ("httpcallback"))
180  		{
181  			auto callback_l (toml.get_required_child ("httpcallback"));
182  			callback_l.get<std::string> ("address", callback_address);
183  			callback_l.get<uint16_t> ("port", callback_port);
184  			callback_l.get<std::string> ("target", callback_target);
185  		}
186  		if (toml.has_key ("logging"))
187  		{
188  			auto logging_l (toml.get_required_child ("logging"));
189  			logging.deserialize_toml (logging_l);
190  		}
191  		if (toml.has_key ("websocket"))
192  		{
193  			auto websocket_config_l (toml.get_required_child ("websocket"));
194  			websocket_config.deserialize_toml (websocket_config_l);
195  		}
196  		if (toml.has_key ("ipc"))
197  		{
198  			auto ipc_config_l (toml.get_required_child ("ipc"));
199  			ipc_config.deserialize_toml (ipc_config_l);
200  		}
201  		if (toml.has_key ("diagnostics"))
202  		{
203  			auto diagnostics_config_l (toml.get_required_child ("diagnostics"));
204  			diagnostics_config.deserialize_toml (diagnostics_config_l);
205  		}
206  		if (toml.has_key ("statistics"))
207  		{
208  			auto stats_config_l (toml.get_required_child ("statistics"));
209  			stats_config.deserialize_toml (stats_config_l);
210  		}
211  		if (toml.has_key ("rocksdb"))
212  		{
213  			auto rocksdb_config_l (toml.get_required_child ("rocksdb"));
214  			rocksdb_config.deserialize_toml (rocksdb_config_l);
215  		}
216  		if (toml.has_key ("optimistic_scheduler"))
217  		{
218  			auto config_l = toml.get_required_child ("optimistic_scheduler");
219  			optimistic_scheduler.deserialize (config_l);
220  		}
221  		if (toml.has_key ("bootstrap_ascending"))
222  		{
223  			auto config_l = toml.get_required_child ("bootstrap_ascending");
224  			bootstrap_ascending.deserialize (config_l);
225  		}
226  		if (toml.has_key ("work_peers"))
227  		{
228  			work_peers.clear ();
229  			toml.array_entries_required<std::string> ("work_peers", [this] (std::string const & entry_a) {
230  				this->deserialize_address (entry_a, this->work_peers);
231  			});
232  		}
233  		if (toml.has_key (preconfigured_peers_key))
234  		{
235  			preconfigured_peers.clear ();
236  			toml.array_entries_required<std::string> (preconfigured_peers_key, [this] (std::string entry) {
237  				preconfigured_peers.push_back (entry);
238  			});
239  		}
240  		if (toml.has_key ("preconfigured_representatives"))
241  		{
242  			preconfigured_representatives.clear ();
243  			toml.array_entries_required<std::string> ("preconfigured_representatives", [this, &toml] (std::string entry) {
244  				nano::account representative{};
245  				if (representative.decode_account (entry))
246  				{
247  					toml.get_error ().set ("Invalid representative account: " + entry);
248  				}
249  				preconfigured_representatives.push_back (representative);
250  			});
251  		}
252  		if (preconfigured_representatives.empty ())
253  		{
254  			toml.get_error ().set ("At least one representative account must be set");
255  		}
256  		auto receive_minimum_l (receive_minimum.to_string_dec ());
257  		if (toml.has_key ("receive_minimum"))
258  		{
259  			receive_minimum_l = toml.get<std::string> ("receive_minimum");
260  		}
261  		if (receive_minimum.decode_dec (receive_minimum_l))
262  		{
263  			toml.get_error ().set ("receive_minimum contains an invalid decimal amount");
264  		}
265  		auto online_weight_minimum_l (online_weight_minimum.to_string_dec ());
266  		if (toml.has_key ("online_weight_minimum"))
267  		{
268  			online_weight_minimum_l = toml.get<std::string> ("online_weight_minimum");
269  		}
270  		if (online_weight_minimum.decode_dec (online_weight_minimum_l))
271  		{
272  			toml.get_error ().set ("online_weight_minimum contains an invalid decimal amount");
273  		}
274  		auto vote_minimum_l (vote_minimum.to_string_dec ());
275  		if (toml.has_key ("vote_minimum"))
276  		{
277  			vote_minimum_l = toml.get<std::string> ("vote_minimum");
278  		}
279  		if (vote_minimum.decode_dec (vote_minimum_l))
280  		{
281  			toml.get_error ().set ("vote_minimum contains an invalid decimal amount");
282  		}
283  		auto delay_l = vote_generator_delay.count ();
284  		toml.get ("vote_generator_delay", delay_l);
285  		vote_generator_delay = std::chrono::milliseconds (delay_l);
286  		toml.get<unsigned> ("vote_generator_threshold", vote_generator_threshold);
287  		auto block_processor_batch_max_time_l = block_processor_batch_max_time.count ();
288  		toml.get ("block_processor_batch_max_time", block_processor_batch_max_time_l);
289  		block_processor_batch_max_time = std::chrono::milliseconds (block_processor_batch_max_time_l);
290  		auto block_process_timeout_l = block_process_timeout.count ();
291  		toml.get ("block_process_timeout", block_process_timeout_l);
292  		block_process_timeout = std::chrono::seconds{ block_process_timeout_l };
293  		auto unchecked_cutoff_time_l = static_cast<unsigned long> (unchecked_cutoff_time.count ());
294  		toml.get ("unchecked_cutoff_time", unchecked_cutoff_time_l);
295  		unchecked_cutoff_time = std::chrono::seconds (unchecked_cutoff_time_l);
296  		auto tcp_io_timeout_l = static_cast<unsigned long> (tcp_io_timeout.count ());
297  		toml.get ("tcp_io_timeout", tcp_io_timeout_l);
298  		tcp_io_timeout = std::chrono::seconds (tcp_io_timeout_l);
299  		if (toml.has_key ("peering_port"))
300  		{
301  			std::uint16_t peering_port_l{};
302  			toml.get_required<uint16_t> ("peering_port", peering_port_l);
303  			peering_port = peering_port_l;
304  		}
305  		toml.get<unsigned> ("bootstrap_fraction_numerator", bootstrap_fraction_numerator);
306  		toml.get<unsigned> ("election_hint_weight_percent", election_hint_weight_percent);
307  		toml.get<unsigned> ("password_fanout", password_fanout);
308  		toml.get<unsigned> ("io_threads", io_threads);
309  		toml.get<unsigned> ("work_threads", work_threads);
310  		toml.get<unsigned> ("network_threads", network_threads);
311  		toml.get<unsigned> ("background_threads", background_threads);
312  		toml.get<unsigned> ("bootstrap_connections", bootstrap_connections);
313  		toml.get<unsigned> ("bootstrap_connections_max", bootstrap_connections_max);
314  		toml.get<unsigned> ("bootstrap_initiator_threads", bootstrap_initiator_threads);
315  		toml.get<unsigned> ("bootstrap_serving_threads", bootstrap_serving_threads);
316  		toml.get<uint32_t> ("bootstrap_frontier_request_count", bootstrap_frontier_request_count);
317  		toml.get<bool> ("enable_voting", enable_voting);
318  		toml.get<bool> ("allow_local_peers", allow_local_peers);
319  		toml.get<unsigned> (signature_checker_threads_key, signature_checker_threads);
320  		if (toml.has_key ("lmdb"))
321  		{
322  			auto lmdb_config_l (toml.get_required_child ("lmdb"));
323  			lmdb_config.deserialize_toml (lmdb_config_l);
324  		}
325  		boost::asio::ip::address_v6 external_address_l;
326  		toml.get<boost::asio::ip::address_v6> ("external_address", external_address_l);
327  		external_address = external_address_l.to_string ();
328  		toml.get<uint16_t> ("external_port", external_port);
329  		toml.get<unsigned> ("tcp_incoming_connections_max", tcp_incoming_connections_max);
330  		auto pow_sleep_interval_l (pow_sleep_interval.count ());
331  		toml.get (pow_sleep_interval_key, pow_sleep_interval_l);
332  		pow_sleep_interval = std::chrono::nanoseconds (pow_sleep_interval_l);
333  		toml.get<bool> ("use_memory_pools", use_memory_pools);
334  		toml.get<std::size_t> ("confirmation_history_size", confirmation_history_size);
335  		toml.get<std::size_t> ("active_elections_size", active_elections_size);
336  		toml.get<std::size_t> ("bandwidth_limit", bandwidth_limit);
337  		toml.get<double> ("bandwidth_limit_burst_ratio", bandwidth_limit_burst_ratio);
338  		toml.get<std::size_t> ("bootstrap_bandwidth_limit", bootstrap_bandwidth_limit);
339  		toml.get<double> ("bootstrap_bandwidth_burst_ratio", bootstrap_bandwidth_burst_ratio);
340  		toml.get<bool> ("backup_before_upgrade", backup_before_upgrade);
341  		auto conf_height_processor_batch_min_time_l (conf_height_processor_batch_min_time.count ());
342  		toml.get ("conf_height_processor_batch_min_time", conf_height_processor_batch_min_time_l);
343  		conf_height_processor_batch_min_time = std::chrono::milliseconds (conf_height_processor_batch_min_time_l);
344  		toml.get<double> ("max_work_generate_multiplier", max_work_generate_multiplier);
345  		toml.get<uint32_t> ("max_queued_requests", max_queued_requests);
346  		auto rep_crawler_weight_minimum_l (rep_crawler_weight_minimum.to_string_dec ());
347  		if (toml.has_key ("rep_crawler_weight_minimum"))
348  		{
349  			rep_crawler_weight_minimum_l = toml.get<std::string> ("rep_crawler_weight_minimum");
350  		}
351  		if (rep_crawler_weight_minimum.decode_dec (rep_crawler_weight_minimum_l))
352  		{
353  			toml.get_error ().set ("rep_crawler_weight_minimum contains an invalid decimal amount");
354  		}
355  		if (toml.has_key ("frontiers_confirmation"))
356  		{
357  			auto frontiers_confirmation_l (toml.get<std::string> ("frontiers_confirmation"));
358  			frontiers_confirmation = deserialize_frontiers_confirmation (frontiers_confirmation_l);
359  		}
360  		toml.get<unsigned> ("backlog_scan_batch_size", backlog_scan_batch_size);
361  		toml.get<unsigned> ("backlog_scan_frequency", backlog_scan_frequency);
362  		if (toml.has_key ("experimental"))
363  		{
364  			auto experimental_config_l (toml.get_required_child ("experimental"));
365  			if (experimental_config_l.has_key ("secondary_work_peers"))
366  			{
367  				secondary_work_peers.clear ();
368  				experimental_config_l.array_entries_required<std::string> ("secondary_work_peers", [this] (std::string const & entry_a) {
369  					this->deserialize_address (entry_a, this->secondary_work_peers);
370  				});
371  			}
372  			auto max_pruning_age_l (max_pruning_age.count ());
373  			experimental_config_l.get ("max_pruning_age", max_pruning_age_l);
374  			max_pruning_age = std::chrono::seconds (max_pruning_age_l);
375  			experimental_config_l.get<uint64_t> ("max_pruning_depth", max_pruning_depth);
376  		}
377  		if (election_hint_weight_percent < 5 || election_hint_weight_percent > 50)
378  		{
379  			toml.get_error ().set ("election_hint_weight_percent must be a number between 5 and 50");
380  		}
381  		if (password_fanout < 16 || password_fanout > 1024 * 1024)
382  		{
383  			toml.get_error ().set ("password_fanout must be a number between 16 and 1048576");
384  		}
385  		if (io_threads == 0)
386  		{
387  			toml.get_error ().set ("io_threads must be non-zero");
388  		}
389  		if (active_elections_size <= 250 && !network_params.network.is_dev_network ())
390  		{
391  			toml.get_error ().set ("active_elections_size must be greater than 250");
392  		}
393  		if (bandwidth_limit > std::numeric_limits<std::size_t>::max ())
394  		{
395  			toml.get_error ().set ("bandwidth_limit unbounded = 0, default = 10485760, max = 18446744073709551615");
396  		}
397  		if (vote_generator_threshold < 1 || vote_generator_threshold > 11)
398  		{
399  			toml.get_error ().set ("vote_generator_threshold must be a number between 1 and 11");
400  		}
401  		if (max_work_generate_multiplier < 1)
402  		{
403  			toml.get_error ().set ("max_work_generate_multiplier must be greater than or equal to 1");
404  		}
405  		if (frontiers_confirmation == nano::frontiers_confirmation_mode::invalid)
406  		{
407  			toml.get_error ().set ("frontiers_confirmation value is invalid (available: always, auto, disabled)");
408  		}
409  		if (block_processor_batch_max_time < network_params.node.process_confirmed_interval)
410  		{
411  			toml.get_error ().set ((boost::format ("block_processor_batch_max_time value must be equal or larger than %1%ms") % network_params.node.process_confirmed_interval.count ()).str ());
412  		}
413  		if (max_pruning_age < std::chrono::seconds (5 * 60) && !network_params.network.is_dev_network ())
414  		{
415  			toml.get_error ().set ("max_pruning_age must be greater than or equal to 5 minutes");
416  		}
417  		if (bootstrap_frontier_request_count < 1024)
418  		{
419  			toml.get_error ().set ("bootstrap_frontier_request_count must be greater than or equal to 1024");
420  		}
421  	}
422  	catch (std::runtime_error const & ex)
423  	{
424  		toml.get_error ().set (ex.what ());
425  	}
426  	return toml.get_error ();
427  }
428  std::string nano::node_config::serialize_frontiers_confirmation (nano::frontiers_confirmation_mode mode_a) const
429  {
430  	switch (mode_a)
431  	{
432  		case nano::frontiers_confirmation_mode::always:
433  			return "always";
434  		case nano::frontiers_confirmation_mode::automatic:
435  			return "auto";
436  		case nano::frontiers_confirmation_mode::disabled:
437  			return "disabled";
438  		default:
439  			return "auto";
440  	}
441  }
442  nano::frontiers_confirmation_mode nano::node_config::deserialize_frontiers_confirmation (std::string const & string_a)
443  {
444  	if (string_a == "always")
445  	{
446  		return nano::frontiers_confirmation_mode::always;
447  	}
448  	else if (string_a == "auto")
449  	{
450  		return nano::frontiers_confirmation_mode::automatic;
451  	}
452  	else if (string_a == "disabled")
453  	{
454  		return nano::frontiers_confirmation_mode::disabled;
455  	}
456  	else
457  	{
458  		return nano::frontiers_confirmation_mode::invalid;
459  	}
460  }
461  void nano::node_config::deserialize_address (std::string const & entry_a, std::vector<std::pair<std::string, uint16_t>> & container_a) const
462  {
463  	auto port_position (entry_a.rfind (':'));
464  	bool result = (port_position == -1);
465  	if (!result)
466  	{
467  		auto port_str (entry_a.substr (port_position + 1));
468  		uint16_t port;
469  		result |= parse_port (port_str, port);
470  		if (!result)
471  		{
472  			auto address (entry_a.substr (0, port_position));
473  			container_a.emplace_back (address, port);
474  		}
475  	}
476  }
477  nano::account nano::node_config::random_representative () const
478  {
479  	debug_assert (!preconfigured_representatives.empty ());
480  	std::size_t index (nano::random_pool::generate_word32 (0, static_cast<CryptoPP::word32> (preconfigured_representatives.size () - 1)));
481  	auto result (preconfigured_representatives[index]);
482  	return result;
483  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_engine_selection.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-nodeconfig.cpp</div>
                </div>
                <div class="column column_space"><pre><code>184    void* null_ptr = NULL;
185    this->InitNet("CAFFE");
186    Net<Dtype>* net = this->net_.get();
187    Layer<Dtype>* conv1_layer = net->layer_by_name("conv1").get();
</pre></code></div>
                <div class="column column_space"><pre><code>15  std::string const default_live_peer_network = nano::get_env_or_default ("NANO_DEFAULT_PEER", "peering.nano.org");
16  std::string const default_beta_peer_network = nano::get_env_or_default ("NANO_DEFAULT_PEER", "peering-beta.nano.org");
17  std::string const default_test_peer_network = nano::get_env_or_default ("NANO_DEFAULT_PEER", "peering-test.nano.org");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    