
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.869009584664537%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type.hpp</h3>
            <pre><code>1  #ifndef glm_core_type
2  #define glm_core_type
3  #include "type_half.hpp"
4  #include "type_float.hpp"
5  #include "type_int.hpp"
6  #include "type_gentype.hpp"
7  #include "type_vec1.hpp"
8  #include "type_vec2.hpp"
9  #include "type_vec3.hpp"
10  #include "type_vec4.hpp"
11  #include "type_mat2x2.hpp"
12  #include "type_mat2x3.hpp"
13  #include "type_mat2x4.hpp"
14  #include "type_mat3x2.hpp"
15  #include "type_mat3x3.hpp"
16  #include "type_mat3x4.hpp"
17  #include "type_mat4x2.hpp"
18  #include "type_mat4x3.hpp"
19  #include "type_mat4x4.hpp"
20  namespace glm
21  {
22  #if(defined(GLM_PRECISION_HIGHP_FLOAT))
23  	typedef highp_vec2          vec2;
24  	typedef highp_vec3          vec3;
25  	typedef highp_vec4          vec4;
26  	typedef highp_mat2x2		mat2x2;
27  	typedef highp_mat2x3		mat2x3;
28  	typedef highp_mat2x4		mat2x4;
29  	typedef highp_mat3x2		mat3x2;
30  	typedef highp_mat3x3		mat3x3;
31  	typedef highp_mat3x4		mat3x4;
32  	typedef highp_mat4x2		mat4x2;
33  	typedef highp_mat4x3		mat4x3;
34  	typedef highp_mat4x4		mat4x4;
35  #elif(defined(GLM_PRECISION_MEDIUMP_FLOAT))
36  	typedef mediump_vec2		vec2;
37  	typedef mediump_vec3		vec3;
38  	typedef mediump_vec4		vec4;
39  	typedef mediump_mat2x2      mat2x2;
40  	typedef mediump_mat2x3      mat2x3;
41  	typedef mediump_mat2x4      mat2x4;
42  	typedef mediump_mat3x2      mat3x2;
43  	typedef mediump_mat3x3      mat3x3;
44  	typedef mediump_mat3x4      mat3x4;
45  	typedef mediump_mat4x2      mat4x2;
46  	typedef mediump_mat4x3      mat4x3;
47  	typedef mediump_mat4x4      mat4x4;
48  #elif(defined(GLM_PRECISION_LOWP_FLOAT))
49  	typedef lowp_vec2			vec2;
50  	typedef lowp_vec3			vec3;
51  	typedef lowp_vec4			vec4;
52  	typedef lowp_mat2x2			mat2x2;
53  	typedef lowp_mat2x3			mat2x3;
54  	typedef lowp_mat2x4			mat2x4;
55  	typedef lowp_mat3x2			mat3x2;
56  	typedef lowp_mat3x3			mat3x3;
57  	typedef lowp_mat3x4			mat3x4;
58  	typedef lowp_mat4x2			mat4x2;
<span onclick='openModal()' class='match'>59  	typedef lowp_mat4x3			mat4x3;
60  	typedef lowp_mat4x4			mat4x4;
61  #else
62  	typedef mediump_vec2		vec2;
63  	typedef mediump_vec3		vec3;
64  	typedef mediump_vec4		vec4;
65  	typedef mediump_mat2x2		mat2x2;
66  	typedef mediump_mat2x3		mat2x3;
67  	typedef mediump_mat2x4		mat2x4;
68  	typedef mediump_mat3x2		mat3x2;
</span>69  	typedef mediump_mat3x3		mat3x3;
70  	typedef mediump_mat3x4		mat3x4;
71  	typedef mediump_mat4x2		mat4x2;
72  	typedef mediump_mat4x3		mat4x3;
73  	typedef mediump_mat4x4		mat4x4;
74  #endif
75  	typedef mat2x2							mat2;
76  	typedef mat3x3							mat3;
77  	typedef mat4x4							mat4;
78  #if(defined(GLM_PRECISION_HIGHP_INT))
79  	typedef highp_ivec2			ivec2;
80  	typedef highp_ivec3			ivec3;
81  	typedef highp_ivec4			ivec4;
82  #elif(defined(GLM_PRECISION_MEDIUMP_INT))
83  	typedef mediump_ivec2		ivec2;
84  	typedef mediump_ivec3		ivec3;
85  	typedef mediump_ivec4		ivec4;
86  #elif(defined(GLM_PRECISION_LOWP_INT))
87  	typedef lowp_ivec2			ivec2;
88  	typedef lowp_ivec3			ivec3;
89  	typedef lowp_ivec4			ivec4;
90  #else
91  	typedef mediump_ivec2		ivec2;
92  	typedef mediump_ivec3		ivec3;
93  	typedef mediump_ivec4		ivec4;
94  #endif
95  #if(defined(GLM_PRECISION_HIGHP_UINT))
96  	typedef highp_uvec2			uvec2;
97  	typedef highp_uvec3			uvec3;
98  	typedef highp_uvec4			uvec4;
99  #elif(defined(GLM_PRECISION_MEDIUMP_UINT))
100  	typedef mediump_uvec2		uvec2;
101  	typedef mediump_uvec3		uvec3;
102  	typedef mediump_uvec4		uvec4;
103  #elif(defined(GLM_PRECISION_LOWP_UINT))
104  	typedef lowp_uvec2			uvec2;
105  	typedef lowp_uvec3			uvec3;
106  	typedef lowp_uvec4			uvec4;
107  #else
108  	typedef mediump_uvec2		uvec2;
109  	typedef mediump_uvec3		uvec3;
110  	typedef mediump_uvec4		uvec4;
111  #endif
112  	typedef detail::tvec2<bool>		bvec2;
113  	typedef detail::tvec3<bool>		bvec3;
114  	typedef detail::tvec4<bool>		bvec4;
115  	typedef detail::tvec2<double>	dvec2;
116  	typedef detail::tvec3<double>	dvec3;
117  	typedef detail::tvec4<double>	dvec4;
118  	typedef detail::tmat2x2<double>	dmat2;
119  	typedef detail::tmat3x3<double>	dmat3;
120  	typedef detail::tmat4x4<double>	dmat4;
121  	typedef detail::tmat2x2<double>	dmat2x2;
122  	typedef detail::tmat2x3<double>	dmat2x3;
123  	typedef detail::tmat2x4<double>	dmat2x4;
124  	typedef detail::tmat3x2<double>	dmat3x2;
125  	typedef detail::tmat3x3<double>	dmat3x3;
126  	typedef detail::tmat3x4<double>	dmat3x4;
127  	typedef detail::tmat4x2<double>	dmat4x2;
128  	typedef detail::tmat4x3<double>	dmat4x3;
129  	typedef detail::tmat4x4<double>	dmat4x4;
130  }
131  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "coutln.h"
5  #include "arrayaccess.h" 
6  #include "blobs.h"       
7  #include "crakedge.h"    
8  #include "environ.h"     
9  #include "errcode.h"     
10  #include "normalis.h"    
11  #include "helpers.h" 
12  #include <allheaders.h> 
13  #include "pix.h"        
14  #include <algorithm> 
15  #include <cmath>     
16  #include <cstdlib>   
17  #include <cstring>   
18  namespace tesseract {
19  ICOORD C_OUTLINE::step_coords[4] = {ICOORD(-1, 0), ICOORD(0, -1), ICOORD(1, 0), ICOORD(0, 1)};
20  C_OUTLINE::C_OUTLINE(CRACKEDGE *startpt, ICOORD bot_left, ICOORD top_right, int16_t length)
21      : box(bot_left, top_right), start(startpt->pos), offsets(nullptr) {
22    int16_t stepindex; 
23    CRACKEDGE *edgept; 
24    stepcount = length; 
25    if (length == 0) {
26      return;
27    }
28    steps.resize(step_mem());
29    edgept = startpt;
30    for (stepindex = 0; stepindex < length; stepindex++) {
31      set_step(stepindex, edgept->stepdir);
32      edgept = edgept->next;
33    }
34  }
35  C_OUTLINE::C_OUTLINE(
36      ICOORD startpt, DIR128 *new_steps,
37      int16_t length 
38      )
39      : start(startpt), offsets(nullptr) {
40    int8_t dirdiff;    
41    DIR128 prevdir;    
42    DIR128 dir;        
43    DIR128 lastdir;    
44    TBOX new_box;      
45    int16_t stepindex; 
46    int16_t srcindex;  
47    ICOORD pos;        
48    pos = startpt;
49    stepcount = length; 
50    ASSERT_HOST(length >= 0);
51    steps.resize(step_mem()); 
52    lastdir = new_steps[length - 1];
53    prevdir = lastdir;
54    for (stepindex = 0, srcindex = 0; srcindex < length; stepindex++, srcindex++) {
55      new_box = TBOX(pos, pos);
56      box += new_box;
57      dir = new_steps[srcindex];
58      set_step(stepindex, dir);
59      dirdiff = dir - prevdir;
60      pos += step(stepindex);
61      if ((dirdiff == 64 || dirdiff == -64) && stepindex > 0) {
62        stepindex -= 2; 
63        prevdir = stepindex >= 0 ? step_dir(stepindex) : lastdir;
64      } else {
65        prevdir = dir;
66      }
67    }
68    ASSERT_HOST(pos.x() == startpt.x() && pos.y() == startpt.y());
69    do {
70      dirdiff = step_dir(stepindex - 1) - step_dir(0);
71      if (dirdiff == 64 || dirdiff == -64) {
72        start += step(0);
73        stepindex -= 2; 
74        for (int i = 0; i < stepindex; ++i) {
75          set_step(i, step_dir(i + 1));
76        }
77      }
78    } while (stepindex > 1 && (dirdiff == 64 || dirdiff == -64));
79    stepcount = stepindex;
80    ASSERT_HOST(stepcount >= 4);
81  }
82  C_OUTLINE::C_OUTLINE(C_OUTLINE *srcline, FCOORD rotation) : offsets(nullptr) {
83    TBOX new_box;      
84    int16_t stepindex; 
85    int16_t dirdiff;   
86    ICOORD pos;        
87    ICOORD prevpos;    
88    ICOORD destpos;                
89    int16_t destindex = INT16_MAX; 
90    DIR128 dir;                    
91    uint8_t new_step;
92    stepcount = srcline->stepcount * 2;
93    if (stepcount == 0) {
94      box = srcline->box;
95      box.rotate(rotation);
96      return;
97    }
98    steps.resize(step_mem());
99    for (int iteration = 0; iteration < 2; ++iteration) {
100      DIR128 round1 = iteration == 0 ? 32 : 0;
101      DIR128 round2 = iteration != 0 ? 32 : 0;
102      pos = srcline->start;
103      prevpos = pos;
104      prevpos.rotate(rotation);
105      start = prevpos;
106      box = TBOX(start, start);
107      destindex = 0;
108      for (stepindex = 0; stepindex < srcline->stepcount; stepindex++) {
109        pos += srcline->step(stepindex);
110        destpos = pos;
111        destpos.rotate(rotation);
112        while (destpos.x() != prevpos.x() || destpos.y() != prevpos.y()) {
113          dir = DIR128(FCOORD(destpos - prevpos));
114          dir += 64; 
115          new_step = dir.get_dir();
116          if (new_step & 31) {
117            set_step(destindex++, dir + round1);
118            prevpos += step(destindex - 1);
119            if (destindex < 2 ||
120                ((dirdiff = step_dir(destindex - 1) - step_dir(destindex - 2)) != -64 &&
121                 dirdiff != 64)) {
122              set_step(destindex++, dir + round2);
123              prevpos += step(destindex - 1);
124            } else {
125              prevpos -= step(destindex - 1);
126              destindex--;
127              prevpos -= step(destindex - 1);
128              set_step(destindex - 1, dir + round2);
129              prevpos += step(destindex - 1);
130            }
131          } else {
132            set_step(destindex++, dir);
133            prevpos += step(destindex - 1);
134          }
135          while (destindex >= 2 &&
136                 ((dirdiff = step_dir(destindex - 1) - step_dir(destindex - 2)) == -64 ||
137                  dirdiff == 64)) {
138            prevpos -= step(destindex - 1);
139            prevpos -= step(destindex - 2);
140            destindex -= 2; 
141          }
142          new_box = TBOX(destpos, destpos);
143          box += new_box;
144        }
145      }
146      ASSERT_HOST(destpos.x() == start.x() && destpos.y() == start.y());
147      while (destindex > 1) {
148        dirdiff = step_dir(destindex - 1) - step_dir(0);
149        if (dirdiff != 64 && dirdiff != -64) {
150          break;
151        }
152        start += step(0);
153        destindex -= 2;
154        for (int i = 0; i < destindex; ++i) {
155          set_step(i, step_dir(i + 1));
156        }
157      }
158      if (destindex >= 4) {
159        break;
160      }
161    }
162    ASSERT_HOST(destindex <= stepcount);
163    stepcount = destindex;
164    destpos = start;
165    for (stepindex = 0; stepindex < stepcount; stepindex++) {
166      destpos += step(stepindex);
167    }
168    ASSERT_HOST(destpos.x() == start.x() && destpos.y() == start.y());
169  }
170  void C_OUTLINE::FakeOutline(const TBOX &box, C_OUTLINE_LIST *outlines) {
171    C_OUTLINE_IT ol_it(outlines);
172    CRACKEDGE start;
173    start.pos = box.topleft();
174    auto *outline = new C_OUTLINE(&start, box.topleft(), box.botright(), 0);
175    ol_it.add_to_end(outline);
176  }
177  int32_t C_OUTLINE::area() const {
178    int stepindex;       
179    int32_t total_steps; 
180    int32_t total;       
181    ICOORD pos;          
182    ICOORD next_step;    
183    C_OUTLINE_IT it(const_cast<C_OUTLINE_LIST *>(&children));
184    pos = start_pos();
185    total_steps = pathlength();
186    total = 0;
187    for (stepindex = 0; stepindex < total_steps; stepindex++) {
188      next_step = step(stepindex);
189      if (next_step.x() < 0) {
190        total += pos.y();
191      } else if (next_step.x() > 0) {
192        total -= pos.y();
193      }
194      pos += next_step;
195    }
196    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
197      total += it.data()->area(); 
198    }
199    return total;
200  }
201  int32_t C_OUTLINE::perimeter() const {
202    int32_t total_steps; 
203    C_OUTLINE_IT it(const_cast<C_OUTLINE_LIST *>(&children));
204    total_steps = pathlength();
205    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
206      total_steps += it.data()->pathlength(); 
207    }
208    return total_steps;
209  }
210  int32_t C_OUTLINE::outer_area() const {
211    int stepindex;       
212    int32_t total_steps; 
213    int32_t total;       
214    ICOORD pos;          
215    ICOORD next_step;    
216    pos = start_pos();
217    total_steps = pathlength();
218    if (total_steps == 0) {
219      return box.area();
220    }
221    total = 0;
222    for (stepindex = 0; stepindex < total_steps; stepindex++) {
223      next_step = step(stepindex);
224      if (next_step.x() < 0) {
225        total += pos.y();
226      } else if (next_step.x() > 0) {
227        total -= pos.y();
228      }
229      pos += next_step;
230    }
231    return total;
232  }
233  int32_t C_OUTLINE::count_transitions(int32_t threshold) {
234    bool first_was_max_x; 
235    bool first_was_max_y;
236    bool looking_for_max_x; 
237    bool looking_for_min_x;
238    bool looking_for_max_y; 
239    bool looking_for_min_y;
240    int stepindex;       
241    int32_t total_steps; 
242    int32_t max_x, min_x, max_y, min_y;
243    int32_t initial_x, initial_y; 
244    int32_t total;                
245    ICOORD pos;                   
246    ICOORD next_step;             
247    pos = start_pos();
248    total_steps = pathlength();
249    total = 0;
250    max_x = min_x = pos.x();
251    max_y = min_y = pos.y();
252    looking_for_max_x = true;
253    looking_for_min_x = true;
254    looking_for_max_y = true;
255    looking_for_min_y = true;
256    first_was_max_x = false;
257    first_was_max_y = false;
258    initial_x = pos.x();
259    initial_y = pos.y(); 
260    for (stepindex = 0; stepindex < total_steps; stepindex++) {
261      next_step = step(stepindex);
262      pos += next_step;
263      if (next_step.x() < 0) {
264        if (looking_for_max_x && pos.x() < min_x) {
265          min_x = pos.x();
266        }
267        if (looking_for_min_x && max_x - pos.x() > threshold) {
268          if (looking_for_max_x) {
269            initial_x = max_x;
270            first_was_max_x = false;
271          }
272          total++;
273          looking_for_max_x = true;
274          looking_for_min_x = false;
275          min_x = pos.x(); 
276        }
277      } else if (next_step.x() > 0) {
278        if (looking_for_min_x && pos.x() > max_x) {
279          max_x = pos.x();
280        }
281        if (looking_for_max_x && pos.x() - min_x > threshold) {
282          if (looking_for_min_x) {
283            initial_x = min_x; 
284            first_was_max_x = true;
285          }
286          total++;
287          looking_for_max_x = false;
288          looking_for_min_x = true;
289          max_x = pos.x();
290        }
291      } else if (next_step.y() < 0) {
292        if (looking_for_max_y && pos.y() < min_y) {
293          min_y = pos.y();
294        }
295        if (looking_for_min_y && max_y - pos.y() > threshold) {
296          if (looking_for_max_y) {
297            initial_y = max_y; 
298            first_was_max_y = false;
299          }
300          total++;
301          looking_for_max_y = true;
302          looking_for_min_y = false;
303          min_y = pos.y(); 
304        }
305      } else {
306        if (looking_for_min_y && pos.y() > max_y) {
307          max_y = pos.y();
308        }
309        if (looking_for_max_y && pos.y() - min_y > threshold) {
310          if (looking_for_min_y) {
311            initial_y = min_y; 
312            first_was_max_y = true;
313          }
314          total++;
315          looking_for_max_y = false;
316          looking_for_min_y = true;
317          max_y = pos.y();
318        }
319      }
320    }
321    if (first_was_max_x && looking_for_min_x) {
322      if (max_x - initial_x > threshold) {
323        total++;
324      } else {
325        total--;
326      }
327    } else if (!first_was_max_x && looking_for_max_x) {
328      if (initial_x - min_x > threshold) {
329        total++;
330      } else {
331        total--;
332      }
333    }
334    if (first_was_max_y && looking_for_min_y) {
335      if (max_y - initial_y > threshold) {
336        total++;
337      } else {
338        total--;
339      }
340    } else if (!first_was_max_y && looking_for_max_y) {
341      if (initial_y - min_y > threshold) {
342        total++;
343      } else {
344        total--;
345      }
346    }
347    return total;
348  }
349  bool C_OUTLINE::operator<(const C_OUTLINE &other) const {
350    int16_t count = 0; 
351    ICOORD pos;        
352    int32_t stepindex; 
353    if (!box.overlap(other.box)) {
354      return false; 
355    }
356    if (stepcount == 0) {
357      return other.box.contains(this->box);
358    }
359    pos = start;
360    for (stepindex = 0; stepindex < stepcount && (count = other.winding_number(pos)) == INTERSECTING;
361         stepindex++) {
362      pos += step(stepindex); 
363    }
364    if (count == INTERSECTING) {
365      pos = other.start;
366      for (stepindex = 0;
367           stepindex < other.stepcount && (count = winding_number(pos)) == INTERSECTING;
368           stepindex++) {
369        pos += other.step(stepindex);
370      }
371      return count == INTERSECTING || count == 0;
372    }
373    return count != 0;
374  }
375  int16_t C_OUTLINE::winding_number(ICOORD point) const {
376    int16_t stepindex; 
377    int16_t count;     
378    ICOORD vec;        
379    ICOORD stepvec;    
380    int32_t cross;     
381    vec = start - point; 
382    count = 0;
383    for (stepindex = 0; stepindex < stepcount; stepindex++) {
384      stepvec = step(stepindex); 
385      if (vec.y() <= 0 && vec.y() + stepvec.y() > 0) {
386        cross = vec * stepvec; 
387        if (cross > 0) {
388          count++; 
389        } else if (cross == 0) {
390          return INTERSECTING; 
391        }
392      } else if (vec.y() > 0 && vec.y() + stepvec.y() <= 0) {
393        cross = vec * stepvec;
394        if (cross < 0) {
395          count--; 
396        } else if (cross == 0) {
397          return INTERSECTING; 
398        }
399      }
400      vec += stepvec; 
401    }
402    return count; 
403  }
404  int16_t C_OUTLINE::turn_direction() const { 
405    DIR128 prevdir;                           
406    DIR128 dir;                               
407    int16_t stepindex;                        
408    int8_t dirdiff;                           
409    int16_t count;                            
410    if (stepcount == 0) {
411      return 128;
412    }
413    count = 0;
414    prevdir = step_dir(stepcount - 1);
415    for (stepindex = 0; stepindex < stepcount; stepindex++) {
416      dir = step_dir(stepindex);
417      dirdiff = dir - prevdir;
418      ASSERT_HOST(dirdiff == 0 || dirdiff == 32 || dirdiff == -32);
419      count += dirdiff;
420      prevdir = dir;
421    }
422    ASSERT_HOST(count == 128 || count == -128);
423    return count; 
424  }
425  void C_OUTLINE::reverse() {      
426    DIR128 halfturn = MODULUS / 2; 
427    DIR128 stepdir;                
428    int16_t stepindex;             
429    int16_t farindex;              
430    int16_t halfsteps;             
431    halfsteps = (stepcount + 1) / 2;
432    for (stepindex = 0; stepindex < halfsteps; stepindex++) {
433      farindex = stepcount - stepindex - 1;
434      stepdir = step_dir(stepindex);
435      set_step(stepindex, step_dir(farindex) + halfturn);
436      set_step(farindex, stepdir + halfturn);
437    }
438  }
439  void C_OUTLINE::move(const ICOORD vec) {
440    C_OUTLINE_IT it(&children); 
441    box.move(vec);
442    start += vec;
443    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
444      it.data()->move(vec); 
445    }
446  }
447  bool C_OUTLINE::IsLegallyNested() const {
448    if (stepcount == 0) {
449      return true;
450    }
451    int64_t parent_area = outer_area();
452    C_OUTLINE_IT child_it(const_cast<C_OUTLINE_LIST *>(&children));
453    for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
454      const C_OUTLINE *child = child_it.data();
455      if (child->outer_area() * parent_area > 0 || !child->IsLegallyNested()) {
456        return false;
457      }
458    }
459    return true;
460  }
461  void C_OUTLINE::RemoveSmallRecursive(int min_size, C_OUTLINE_IT *it) {
462    if (box.width() < min_size || box.height() < min_size) {
463      ASSERT_HOST(this == it->data());
464      delete it->extract(); 
465    } else if (!children.empty()) {
466      C_OUTLINE_IT child_it(&children);
467      for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
468        C_OUTLINE *child = child_it.data();
469        child->RemoveSmallRecursive(min_size, &child_it);
470      }
471    }
472  }
473  static void ComputeGradient(const l_uint32 *data, int wpl, int x, int y, int width, int height,
474                              ICOORD *gradient) {
475    const l_uint32 *line = data + y * wpl;
476    int pix_x_y = x < width && y < height ? GET_DATA_BYTE(line, x) : 255;
477    int pix_x_prevy = x < width && y > 0 ? GET_DATA_BYTE(line - wpl, x) : 255;
478    int pix_prevx_prevy = x > 0 && y > 0 ? GET_DATA_BYTE(line - wpl, x - 1) : 255;
479    int pix_prevx_y = x > 0 && y < height ? GET_DATA_BYTE(line, x - 1) : 255;
480    gradient->set_x(pix_x_y + pix_x_prevy - (pix_prevx_y + pix_prevx_prevy));
481    gradient->set_y(pix_x_prevy + pix_prevx_prevy - (pix_x_y + pix_prevx_y));
482  }
<span onclick='openModal()' class='match'>483  static bool EvaluateVerticalDiff(const l_uint32 *data, int wpl, int diff_sign, int x, int y,
484                                   int height, int *best_diff, int *best_sum, int *best_y) {
</span>485    if (y <= 0 || y >= height) {
486      return false;
487    }
488    const l_uint32 *line = data + y * wpl;
489    int pixel1 = GET_DATA_BYTE(line - wpl, x);
490    int pixel2 = GET_DATA_BYTE(line, x);
491    int diff = (pixel2 - pixel1) * diff_sign;
492    if (diff > *best_diff) {
493      *best_diff = diff;
494      *best_sum = pixel1 + pixel2;
495      *best_y = y;
496    }
497    return diff > 0;
498  }
499  static bool EvaluateHorizontalDiff(const l_uint32 *line, int diff_sign, int x, int width,
500                                     int *best_diff, int *best_sum, int *best_x) {
501    if (x <= 0 || x >= width) {
502      return false;
503    }
504    int pixel1 = GET_DATA_BYTE(line, x - 1);
505    int pixel2 = GET_DATA_BYTE(line, x);
506    int diff = (pixel2 - pixel1) * diff_sign;
507    if (diff > *best_diff) {
508      *best_diff = diff;
509      *best_sum = pixel1 + pixel2;
510      *best_x = x;
511    }
512    return diff > 0;
513  }
514  void C_OUTLINE::ComputeEdgeOffsets(int threshold, Image pix) {
515    if (pixGetDepth(pix) != 8) {
516      return;
517    }
518    const l_uint32 *data = pixGetData(pix);
519    int wpl = pixGetWpl(pix);
520    int width = pixGetWidth(pix);
521    int height = pixGetHeight(pix);
522    bool negative = flag(COUT_INVERSE);
523    delete[] offsets;
524    offsets = new EdgeOffset[stepcount];
525    ICOORD pos = start;
526    ICOORD prev_gradient;
527    ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &prev_gradient);
528    for (int s = 0; s < stepcount; ++s) {
529      ICOORD step_vec = step(s);
530      TPOINT pt1(pos);
531      pos += step_vec;
532      TPOINT pt2(pos);
533      ICOORD next_gradient;
534      ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &next_gradient);
535      ICOORD gradient = prev_gradient + next_gradient;
536      int best_diff = 0;
537      int offset = 0;
538      if (pt1.y == pt2.y && abs(gradient.y()) * 2 >= abs(gradient.x())) {
539        int diff_sign = (pt1.x > pt2.x) == negative ? 1 : -1;
540        int x = std::min(pt1.x, pt2.x);
541        int y = height - pt1.y;
542        int best_sum = 0;
543        int best_y = y;
544        EvaluateVerticalDiff(data, wpl, diff_sign, x, y, height, &best_diff, &best_sum, &best_y);
545        int test_y = y;
546        do {
547          ++test_y;
548        } while (EvaluateVerticalDiff(data, wpl, diff_sign, x, test_y, height, &best_diff, &best_sum,
549                                      &best_y));
550        test_y = y;
551        do {
552          --test_y;
553        } while (EvaluateVerticalDiff(data, wpl, diff_sign, x, test_y, height, &best_diff, &best_sum,
554                                      &best_y));
555        offset = diff_sign * (best_sum / 2 - threshold) + (y - best_y) * best_diff;
556      } else if (pt1.x == pt2.x && abs(gradient.x()) * 2 >= abs(gradient.y())) {
557        int diff_sign = (pt1.y > pt2.y) == negative ? 1 : -1;
558        int x = pt1.x;
559        int y = height - std::max(pt1.y, pt2.y);
560        const l_uint32 *line = pixGetData(pix) + y * wpl;
561        int best_sum = 0;
562        int best_x = x;
563        EvaluateHorizontalDiff(line, diff_sign, x, width, &best_diff, &best_sum, &best_x);
564        int test_x = x;
565        do {
566          ++test_x;
567        } while (
568            EvaluateHorizontalDiff(line, diff_sign, test_x, width, &best_diff, &best_sum, &best_x));
569        test_x = x;
570        do {
571          --test_x;
572        } while (
573            EvaluateHorizontalDiff(line, diff_sign, test_x, width, &best_diff, &best_sum, &best_x));
574        offset = diff_sign * (threshold - best_sum / 2) + (best_x - x) * best_diff;
575      }
576      offsets[s].offset_numerator = ClipToRange<int>(offset, -INT8_MAX, INT8_MAX);
577      offsets[s].pixel_diff = ClipToRange<int>(best_diff, 0, UINT8_MAX);
578      if (negative) {
579        gradient = -gradient;
580      }
581      offsets[s].direction = Modulo(FCOORD::binary_angle_plus_pi(gradient.angle()) + 64, 256);
582      prev_gradient = next_gradient;
583    }
584  }
585  void C_OUTLINE::ComputeBinaryOffsets() {
586    delete[] offsets;
587    offsets = new EdgeOffset[stepcount];
588    int dir_counts[4];
589    int pos_totals[4];
590    memset(dir_counts, 0, sizeof(dir_counts));
591    memset(pos_totals, 0, sizeof(pos_totals));
592    ICOORD pos = start;
593    ICOORD tail_pos = pos;
594    tail_pos -= step(stepcount - 1);
595    tail_pos -= step(stepcount - 2);
596    ICOORD head_pos = tail_pos;
597    for (int s = -2; s < 2; ++s) {
598      increment_step(s, 1, &head_pos, dir_counts, pos_totals);
599    }
600    for (int s = 0; s < stepcount; pos += step(s++)) {
601      increment_step(s + 2, 1, &head_pos, dir_counts, pos_totals);
602      int dir_index = chain_code(s);
603      ICOORD step_vec = step(s);
604      int best_diff = 0;
605      int offset = 0;
606      if (dir_counts[dir_index] >= 2 ||
607          (dir_counts[dir_index] == 1 && dir_counts[Modulo(dir_index - 1, 4)] == 2 &&
608           dir_counts[Modulo(dir_index + 1, 4)] == 2)) {
609        best_diff = dir_counts[dir_index];
610        int edge_pos = step_vec.x() == 0 ? pos.x() : pos.y();
611        offset = pos_totals[dir_index] - best_diff * edge_pos;
612      }
613      offsets[s].offset_numerator = ClipToRange<int>(offset, -INT8_MAX, INT8_MAX);
614      offsets[s].pixel_diff = ClipToRange<int>(best_diff, 0, UINT8_MAX);
615      FCOORD direction(head_pos.x() - tail_pos.x(), head_pos.y() - tail_pos.y());
616      offsets[s].direction = direction.to_direction();
617      increment_step(s - 2, -1, &tail_pos, dir_counts, pos_totals);
618    }
619  }
620  void C_OUTLINE::render(int left, int top, Image pix) const {
621    ICOORD pos = start;
622    for (int stepindex = 0; stepindex < stepcount; ++stepindex) {
623      ICOORD next_step = step(stepindex);
624      if (next_step.y() < 0) {
625        pixRasterop(pix, 0, top - pos.y(), pos.x() - left, 1, PIX_NOT(PIX_DST), nullptr, 0, 0);
626      } else if (next_step.y() > 0) {
627        pixRasterop(pix, 0, top - pos.y() - 1, pos.x() - left, 1, PIX_NOT(PIX_DST), nullptr, 0, 0);
628      }
629      pos += next_step;
630    }
631  }
632  void C_OUTLINE::render_outline(int left, int top, Image pix) const {
633    ICOORD pos = start;
634    for (int stepindex = 0; stepindex < stepcount; ++stepindex) {
635      ICOORD next_step = step(stepindex);
636      if (next_step.y() < 0) {
637        pixSetPixel(pix, pos.x() - left, top - pos.y(), 1);
638      } else if (next_step.y() > 0) {
639        pixSetPixel(pix, pos.x() - left - 1, top - pos.y() - 1, 1);
640      } else if (next_step.x() < 0) {
641        pixSetPixel(pix, pos.x() - left - 1, top - pos.y(), 1);
642      } else if (next_step.x() > 0) {
643        pixSetPixel(pix, pos.x() - left, top - pos.y() - 1, 1);
644      }
645      pos += next_step;
646    }
647  }
648  #ifndef GRAPHICS_DISABLED
649  void C_OUTLINE::plot(ScrollView *window, ScrollView::Color colour) const {
650    int16_t stepindex; 
651    ICOORD pos;        
652    DIR128 stepdir;    
653    pos = start; 
654    window->Pen(colour);
655    if (stepcount == 0) {
656      window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
657      return;
658    }
659    window->SetCursor(pos.x(), pos.y());
660    stepindex = 0;
661    while (stepindex < stepcount) {
662      pos += step(stepindex); 
663      stepdir = step_dir(stepindex);
664      stepindex++; 
665      while (stepindex < stepcount && stepdir.get_dir() == step_dir(stepindex).get_dir()) {
666        pos += step(stepindex);
667        stepindex++;
668      }
669      window->DrawTo(pos.x(), pos.y());
670    }
671  }
672  void C_OUTLINE::plot_normed(const DENORM &denorm, ScrollView::Color colour,
673                              ScrollView *window) const {
674    window->Pen(colour);
675    if (stepcount == 0) {
676      window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
677      return;
678    }
679    const DENORM *root_denorm = denorm.RootDenorm();
680    ICOORD pos = start; 
681    FCOORD f_pos = sub_pixel_pos_at_index(pos, 0);
682    FCOORD pos_normed;
683    denorm.NormTransform(root_denorm, f_pos, &pos_normed);
684    window->SetCursor(IntCastRounded(pos_normed.x()), IntCastRounded(pos_normed.y()));
685    for (int s = 0; s < stepcount; pos += step(s++)) {
686      int edge_weight = edge_strength_at_index(s);
687      if (edge_weight == 0) {
688        continue;
689      }
690      FCOORD f_pos = sub_pixel_pos_at_index(pos, s);
691      FCOORD pos_normed;
692      denorm.NormTransform(root_denorm, f_pos, &pos_normed);
693      window->DrawTo(IntCastRounded(pos_normed.x()), IntCastRounded(pos_normed.y()));
694    }
695  }
696  #endif
697  C_OUTLINE &C_OUTLINE::operator=(const C_OUTLINE &source) {
698    box = source.box;
699    start = source.start;
700    if (!children.empty()) {
701      children.clear();
702    }
703    children.deep_copy(&source.children, &deep_copy);
704    delete[] offsets;
705    offsets = nullptr;
706    stepcount = source.stepcount;
707    if (stepcount > 0) {
708      steps.resize(step_mem());
709      memmove(&steps[0], &source.steps[0], step_mem());
710      if (source.offsets != nullptr) {
711        offsets = new EdgeOffset[stepcount];
712        memcpy(offsets, source.offsets, stepcount * sizeof(*offsets));
713      }
714    }
715    return *this;
716  }
717  void C_OUTLINE::increment_step(int s, int increment, ICOORD *pos, int *dir_counts,
718                                 int *pos_totals) const {
719    int step_index = Modulo(s, stepcount);
720    int dir_index = chain_code(step_index);
721    dir_counts[dir_index] += increment;
722    ICOORD step_vec = step(step_index);
723    if (step_vec.x() == 0) {
724      pos_totals[dir_index] += pos->x() * increment;
725    } else {
726      pos_totals[dir_index] += pos->y() * increment;
727    }
728    *pos += step_vec;
729  }
730  ICOORD C_OUTLINE::chain_step(int chaindir) {
731    return step_coords[chaindir % 4];
732  }
733  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from glm-MDEwOlJlcG9zaXRvcnk4NDM2MzE=-flat-type.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.cpp</div>
                </div>
                <div class="column column_space"><pre><code>59  	typedef lowp_mat4x3			mat4x3;
60  	typedef lowp_mat4x4			mat4x4;
61  #else
62  	typedef mediump_vec2		vec2;
63  	typedef mediump_vec3		vec3;
64  	typedef mediump_vec4		vec4;
65  	typedef mediump_mat2x2		mat2x2;
66  	typedef mediump_mat2x3		mat2x3;
67  	typedef mediump_mat2x4		mat2x4;
68  	typedef mediump_mat3x2		mat3x2;
</pre></code></div>
                <div class="column column_space"><pre><code>483  static bool EvaluateVerticalDiff(const l_uint32 *data, int wpl, int diff_sign, int x, int y,
484                                   int height, int *best_diff, int *best_sum, int *best_y) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    